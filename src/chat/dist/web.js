"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);

// src/util/vs/base/common/collections.ts
function groupBy(data, groupFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const element of data) {
    const key = groupFn(element);
    let target = result[key];
    if (!target) {
      target = result[key] = [];
    }
    target.push(element);
  }
  return result;
}
var _a, _b, SetWithKey;
var init_collections = __esm({
  "src/util/vs/base/common/collections.ts"() {
    "use strict";
    SetWithKey = class {
      constructor(values, toKey) {
        this.toKey = toKey;
        this._map = /* @__PURE__ */ new Map();
        this[_a] = "SetWithKey";
        for (const value of values) {
          this.add(value);
        }
      }
      get size() {
        return this._map.size;
      }
      add(value) {
        const key = this.toKey(value);
        this._map.set(key, value);
        return this;
      }
      delete(value) {
        return this._map.delete(this.toKey(value));
      }
      has(value) {
        return this._map.has(this.toKey(value));
      }
      *entries() {
        for (const entry of this._map.values()) {
          yield [entry, entry];
        }
      }
      keys() {
        return this.values();
      }
      *values() {
        for (const entry of this._map.values()) {
          yield entry;
        }
      }
      clear() {
        this._map.clear();
      }
      forEach(callbackfn, thisArg) {
        this._map.forEach((entry) => callbackfn.call(thisArg, entry, entry, this));
      }
      [(_b = Symbol.iterator, _a = Symbol.toStringTag, _b)]() {
        return this.values();
      }
    };
  }
});

// src/util/vs/base/common/errors.ts
var errors_exports = {};
__export(errors_exports, {
  BugIndicatingError: () => BugIndicatingError,
  CancellationError: () => CancellationError,
  ErrorHandler: () => ErrorHandler,
  ErrorNoTelemetry: () => ErrorNoTelemetry,
  ExpectedError: () => ExpectedError,
  NotImplementedError: () => NotImplementedError,
  NotSupportedError: () => NotSupportedError,
  PendingMigrationError: () => PendingMigrationError,
  ReadonlyError: () => ReadonlyError,
  canceled: () => canceled,
  canceledName: () => canceledName,
  errorHandler: () => errorHandler,
  getErrorMessage: () => getErrorMessage,
  illegalArgument: () => illegalArgument,
  illegalState: () => illegalState,
  isCancellationError: () => isCancellationError,
  isSigPipeError: () => isSigPipeError,
  onBugIndicatingError: () => onBugIndicatingError,
  onUnexpectedError: () => onUnexpectedError,
  onUnexpectedExternalError: () => onUnexpectedExternalError,
  setUnexpectedErrorHandler: () => setUnexpectedErrorHandler,
  transformErrorForSerialization: () => transformErrorForSerialization,
  transformErrorFromSerialization: () => transformErrorFromSerialization
});
function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
  errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
}
function isSigPipeError(e) {
  if (!e || typeof e !== "object") {
    return false;
  }
  const cast = e;
  return cast.code === "EPIPE" && cast.syscall?.toUpperCase() === "WRITE";
}
function onBugIndicatingError(e) {
  errorHandler.onUnexpectedError(e);
  return void 0;
}
function onUnexpectedError(e) {
  if (!isCancellationError(e)) {
    errorHandler.onUnexpectedError(e);
  }
  return void 0;
}
function onUnexpectedExternalError(e) {
  if (!isCancellationError(e)) {
    errorHandler.onUnexpectedExternalError(e);
  }
  return void 0;
}
function transformErrorForSerialization(error2) {
  if (error2 instanceof Error) {
    const { name, message, cause } = error2;
    const stack = error2.stacktrace || error2.stack;
    return {
      $isError: true,
      name,
      message,
      stack,
      noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error2),
      cause: cause ? transformErrorForSerialization(cause) : void 0,
      code: error2.code
    };
  }
  return error2;
}
function transformErrorFromSerialization(data) {
  let error2;
  if (data.noTelemetry) {
    error2 = new ErrorNoTelemetry();
  } else {
    error2 = new Error();
    error2.name = data.name;
  }
  error2.message = data.message;
  error2.stack = data.stack;
  if (data.code) {
    error2.code = data.code;
  }
  if (data.cause) {
    error2.cause = transformErrorFromSerialization(data.cause);
  }
  return error2;
}
function isCancellationError(error2) {
  if (error2 instanceof CancellationError) {
    return true;
  }
  return error2 instanceof Error && error2.name === canceledName && error2.message === canceledName;
}
function canceled() {
  const error2 = new Error(canceledName);
  error2.name = error2.message;
  return error2;
}
function illegalArgument(name) {
  if (name) {
    return new Error(`Illegal argument: ${name}`);
  } else {
    return new Error("Illegal argument");
  }
}
function illegalState(name) {
  if (name) {
    return new Error(`Illegal state: ${name}`);
  } else {
    return new Error("Illegal state");
  }
}
function getErrorMessage(err) {
  if (!err) {
    return "Error";
  }
  if (err.message) {
    return err.message;
  }
  if (err.stack) {
    return err.stack.split("\n")[0];
  }
  return String(err);
}
var ErrorHandler, errorHandler, canceledName, CancellationError, PendingMigrationError, ReadonlyError, NotImplementedError, NotSupportedError, ExpectedError, ErrorNoTelemetry, BugIndicatingError;
var init_errors = __esm({
  "src/util/vs/base/common/errors.ts"() {
    "use strict";
    ErrorHandler = class {
      constructor() {
        this.listeners = [];
        this.unexpectedErrorHandler = function(e) {
          setTimeout(() => {
            if (e.stack) {
              if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {
                throw new ErrorNoTelemetry(e.message + "\n\n" + e.stack);
              }
              throw new Error(e.message + "\n\n" + e.stack);
            }
            throw e;
          }, 0);
        };
      }
      addListener(listener) {
        this.listeners.push(listener);
        return () => {
          this._removeListener(listener);
        };
      }
      emit(e) {
        this.listeners.forEach((listener) => {
          listener(e);
        });
      }
      _removeListener(listener) {
        this.listeners.splice(this.listeners.indexOf(listener), 1);
      }
      setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        this.unexpectedErrorHandler = newUnexpectedErrorHandler;
      }
      getUnexpectedErrorHandler() {
        return this.unexpectedErrorHandler;
      }
      onUnexpectedError(e) {
        this.unexpectedErrorHandler(e);
        this.emit(e);
      }
      // For external errors, we don't want the listeners to be called
      onUnexpectedExternalError(e) {
        this.unexpectedErrorHandler(e);
      }
    };
    errorHandler = new ErrorHandler();
    canceledName = "Canceled";
    CancellationError = class extends Error {
      constructor() {
        super(canceledName);
        this.name = this.message;
      }
    };
    PendingMigrationError = class _PendingMigrationError extends Error {
      static {
        this._name = "PendingMigrationError";
      }
      static is(error2) {
        return error2 instanceof _PendingMigrationError || error2 instanceof Error && error2.name === _PendingMigrationError._name;
      }
      constructor(message) {
        super(message);
        this.name = _PendingMigrationError._name;
      }
    };
    ReadonlyError = class extends TypeError {
      constructor(name) {
        super(name ? `${name} is read-only and cannot be changed` : "Cannot change read-only property");
      }
    };
    NotImplementedError = class extends Error {
      constructor(message) {
        super("NotImplemented");
        if (message) {
          this.message = message;
        }
      }
    };
    NotSupportedError = class extends Error {
      constructor(message) {
        super("NotSupported");
        if (message) {
          this.message = message;
        }
      }
    };
    ExpectedError = class extends Error {
      constructor() {
        super(...arguments);
        this.isExpected = true;
      }
    };
    ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {
      constructor(msg) {
        super(msg);
        this.name = "CodeExpectedError";
      }
      static fromError(err) {
        if (err instanceof _ErrorNoTelemetry) {
          return err;
        }
        const result = new _ErrorNoTelemetry();
        result.message = err.message;
        result.stack = err.stack;
        return result;
      }
      static isErrorNoTelemetry(err) {
        return err.name === "CodeExpectedError";
      }
    };
    BugIndicatingError = class _BugIndicatingError extends Error {
      constructor(message) {
        super(message || "An unexpected bug occurred.");
        Object.setPrototypeOf(this, _BugIndicatingError.prototype);
      }
    };
  }
});

// src/util/vs/base/common/functional.ts
var init_functional = __esm({
  "src/util/vs/base/common/functional.ts"() {
    "use strict";
  }
});

// src/util/vs/base/common/arraysFind.ts
var arraysFind_exports = {};
__export(arraysFind_exports, {
  MonotonousArray: () => MonotonousArray,
  findFirstIdxMonotonous: () => findFirstIdxMonotonous,
  findFirstIdxMonotonousOrArrLen: () => findFirstIdxMonotonousOrArrLen,
  findFirstMax: () => findFirstMax,
  findFirstMin: () => findFirstMin,
  findFirstMonotonous: () => findFirstMonotonous,
  findLast: () => findLast,
  findLastIdx: () => findLastIdx,
  findLastIdxMonotonous: () => findLastIdxMonotonous,
  findLastMax: () => findLastMax,
  findLastMonotonous: () => findLastMonotonous,
  findMaxIdx: () => findMaxIdx,
  mapFindFirst: () => mapFindFirst
});
function findLast(array, predicate, fromIndex = array.length - 1) {
  const idx = findLastIdx(array, predicate, fromIndex);
  if (idx === -1) {
    return void 0;
  }
  return array[idx];
}
function findLastIdx(array, predicate, fromIndex = array.length - 1) {
  for (let i = fromIndex; i >= 0; i--) {
    const element = array[i];
    if (predicate(element)) {
      return i;
    }
  }
  return -1;
}
function findLastMonotonous(array, predicate) {
  const idx = findLastIdxMonotonous(array, predicate);
  return idx === -1 ? void 0 : array[idx];
}
function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
  let i = startIdx;
  let j = endIdxEx;
  while (i < j) {
    const k = Math.floor((i + j) / 2);
    if (predicate(array[k])) {
      i = k + 1;
    } else {
      j = k;
    }
  }
  return i - 1;
}
function findFirstMonotonous(array, predicate) {
  const idx = findFirstIdxMonotonousOrArrLen(array, predicate);
  return idx === array.length ? void 0 : array[idx];
}
function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {
  let i = startIdx;
  let j = endIdxEx;
  while (i < j) {
    const k = Math.floor((i + j) / 2);
    if (predicate(array[k])) {
      j = k;
    } else {
      i = k + 1;
    }
  }
  return i;
}
function findFirstIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
  const idx = findFirstIdxMonotonousOrArrLen(array, predicate, startIdx, endIdxEx);
  return idx === array.length ? -1 : idx;
}
function findFirstMax(array, comparator) {
  if (array.length === 0) {
    return void 0;
  }
  let max = array[0];
  for (let i = 1; i < array.length; i++) {
    const item = array[i];
    if (comparator(item, max) > 0) {
      max = item;
    }
  }
  return max;
}
function findLastMax(array, comparator) {
  if (array.length === 0) {
    return void 0;
  }
  let max = array[0];
  for (let i = 1; i < array.length; i++) {
    const item = array[i];
    if (comparator(item, max) >= 0) {
      max = item;
    }
  }
  return max;
}
function findFirstMin(array, comparator) {
  return findFirstMax(array, (a, b) => -comparator(a, b));
}
function findMaxIdx(array, comparator) {
  if (array.length === 0) {
    return -1;
  }
  let maxIdx = 0;
  for (let i = 1; i < array.length; i++) {
    const item = array[i];
    if (comparator(item, array[maxIdx]) > 0) {
      maxIdx = i;
    }
  }
  return maxIdx;
}
function mapFindFirst(items, mapFn) {
  for (const value of items) {
    const mapped = mapFn(value);
    if (mapped !== void 0) {
      return mapped;
    }
  }
  return void 0;
}
var MonotonousArray;
var init_arraysFind = __esm({
  "src/util/vs/base/common/arraysFind.ts"() {
    "use strict";
    MonotonousArray = class _MonotonousArray {
      constructor(_array) {
        this._array = _array;
        this._findLastMonotonousLastIdx = 0;
      }
      static {
        this.assertInvariants = false;
      }
      /**
       * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
       * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
       */
      findLastMonotonous(predicate) {
        if (_MonotonousArray.assertInvariants) {
          if (this._prevFindLastPredicate) {
            for (const item of this._array) {
              if (this._prevFindLastPredicate(item) && !predicate(item)) {
                throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
              }
            }
          }
          this._prevFindLastPredicate = predicate;
        }
        const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);
        this._findLastMonotonousLastIdx = idx + 1;
        return idx === -1 ? void 0 : this._array[idx];
      }
    };
  }
});

// src/util/vs/base/common/arrays.ts
function equals(one, other, itemEquals = (a, b) => a === b) {
  if (one === other) {
    return true;
  }
  if (!one || !other) {
    return false;
  }
  if (one.length !== other.length) {
    return false;
  }
  for (let i = 0, len = one.length; i < len; i++) {
    if (!itemEquals(one[i], other[i])) {
      return false;
    }
  }
  return true;
}
function* groupAdjacentBy(items, shouldBeGrouped) {
  let currentGroup;
  let last;
  for (const item of items) {
    if (last !== void 0 && shouldBeGrouped(last, item)) {
      currentGroup.push(item);
    } else {
      if (currentGroup) {
        yield currentGroup;
      }
      currentGroup = [item];
    }
    last = item;
  }
  if (currentGroup) {
    yield currentGroup;
  }
}
function coalesce(array) {
  return array.filter((e) => !!e);
}
function distinct(array, keyFn = (value) => value) {
  const seen = /* @__PURE__ */ new Set();
  return array.filter((element) => {
    const key = keyFn(element);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}
function uniqueFilter(keyFn) {
  const seen = /* @__PURE__ */ new Set();
  return (element) => {
    const key = keyFn(element);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  };
}
function compareBy(selector, comparator) {
  return (a, b) => comparator(selector(a), selector(b));
}
function sumBy(array, selector) {
  return array.reduce((acc, value) => acc + selector(value), 0);
}
var CompareResult, numberComparator, CallbackIterable;
var init_arrays = __esm({
  "src/util/vs/base/common/arrays.ts"() {
    "use strict";
    init_arraysFind();
    init_errors();
    ((CompareResult2) => {
      function isLessThan(result) {
        return result < 0;
      }
      CompareResult2.isLessThan = isLessThan;
      function isLessThanOrEqual(result) {
        return result <= 0;
      }
      CompareResult2.isLessThanOrEqual = isLessThanOrEqual;
      function isGreaterThan(result) {
        return result > 0;
      }
      CompareResult2.isGreaterThan = isGreaterThan;
      function isNeitherLessOrGreaterThan(result) {
        return result === 0;
      }
      CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
      CompareResult2.greaterThan = 1;
      CompareResult2.lessThan = -1;
      CompareResult2.neitherLessOrGreaterThan = 0;
    })(CompareResult || (CompareResult = {}));
    numberComparator = (a, b) => a - b;
    CallbackIterable = class _CallbackIterable {
      constructor(iterate) {
        this.iterate = iterate;
      }
      static {
        this.empty = new _CallbackIterable((_callback) => {
        });
      }
      forEach(handler) {
        this.iterate((item) => {
          handler(item);
          return true;
        });
      }
      toArray() {
        const result = [];
        this.iterate((item) => {
          result.push(item);
          return true;
        });
        return result;
      }
      filter(predicate) {
        return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
      }
      map(mapFn) {
        return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
      }
      some(predicate) {
        let result = false;
        this.iterate((item) => {
          result = predicate(item);
          return !result;
        });
        return result;
      }
      findFirst(predicate) {
        let result;
        this.iterate((item) => {
          if (predicate(item)) {
            result = item;
            return false;
          }
          return true;
        });
        return result;
      }
      findLast(predicate) {
        let result;
        this.iterate((item) => {
          if (predicate(item)) {
            result = item;
          }
          return true;
        });
        return result;
      }
      findLastMaxBy(comparator) {
        let result;
        let first = true;
        this.iterate((item) => {
          if (first || CompareResult.isGreaterThan(comparator(item, result))) {
            first = false;
            result = item;
          }
          return true;
        });
        return result;
      }
    };
  }
});

// src/util/vs/base/common/map.ts
function isEntries(arg) {
  return Array.isArray(arg);
}
var ResourceMapEntry, _a2, ResourceMap, _a3, ResourceSet, _a4, LinkedMap, Cache, LRUCache, SetMap;
var init_map = __esm({
  "src/util/vs/base/common/map.ts"() {
    "use strict";
    ResourceMapEntry = class {
      constructor(uri, value) {
        this.uri = uri;
        this.value = value;
      }
    };
    ResourceMap = class _ResourceMap {
      constructor(arg, toKey) {
        this[_a2] = "ResourceMap";
        if (arg instanceof _ResourceMap) {
          this.map = new Map(arg.map);
          this.toKey = toKey ?? _ResourceMap.defaultToKey;
        } else if (isEntries(arg)) {
          this.map = /* @__PURE__ */ new Map();
          this.toKey = toKey ?? _ResourceMap.defaultToKey;
          for (const [resource, value] of arg) {
            this.set(resource, value);
          }
        } else {
          this.map = /* @__PURE__ */ new Map();
          this.toKey = arg ?? _ResourceMap.defaultToKey;
        }
      }
      static {
        this.defaultToKey = (resource) => resource.toString();
      }
      set(resource, value) {
        this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));
        return this;
      }
      get(resource) {
        return this.map.get(this.toKey(resource))?.value;
      }
      has(resource) {
        return this.map.has(this.toKey(resource));
      }
      get size() {
        return this.map.size;
      }
      clear() {
        this.map.clear();
      }
      delete(resource) {
        return this.map.delete(this.toKey(resource));
      }
      forEach(clb, thisArg) {
        if (typeof thisArg !== "undefined") {
          clb = clb.bind(thisArg);
        }
        for (const [_, entry] of this.map) {
          clb(entry.value, entry.uri, this);
        }
      }
      *values() {
        for (const entry of this.map.values()) {
          yield entry.value;
        }
      }
      *keys() {
        for (const entry of this.map.values()) {
          yield entry.uri;
        }
      }
      *entries() {
        for (const entry of this.map.values()) {
          yield [entry.uri, entry.value];
        }
      }
      *[(_a2 = Symbol.toStringTag, Symbol.iterator)]() {
        for (const [, entry] of this.map) {
          yield [entry.uri, entry.value];
        }
      }
    };
    ResourceSet = class {
      constructor(entriesOrKey, toKey) {
        this[_a3] = "ResourceSet";
        if (!entriesOrKey || typeof entriesOrKey === "function") {
          this._map = new ResourceMap(entriesOrKey);
        } else {
          this._map = new ResourceMap(toKey);
          entriesOrKey.forEach(this.add, this);
        }
      }
      get size() {
        return this._map.size;
      }
      add(value) {
        this._map.set(value, value);
        return this;
      }
      clear() {
        this._map.clear();
      }
      delete(value) {
        return this._map.delete(value);
      }
      forEach(callbackfn, thisArg) {
        this._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));
      }
      has(value) {
        return this._map.has(value);
      }
      entries() {
        return this._map.entries();
      }
      keys() {
        return this._map.keys();
      }
      values() {
        return this._map.keys();
      }
      [(_a3 = Symbol.toStringTag, Symbol.iterator)]() {
        return this.keys();
      }
    };
    LinkedMap = class {
      constructor() {
        this[_a4] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = 0 /* None */) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== 0 /* None */) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = 0 /* None */) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== 0 /* None */) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case 0 /* None */:
              this.addItemLast(item);
              break;
            case 1 /* AsOld */:
              this.addItemFirst(item);
              break;
            case 2 /* AsNew */:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const map2 = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map2._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const map2 = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map2._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const map2 = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map2._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a4 = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      trimNew(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._tail;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.previous;
          currentSize--;
        }
        this._tail = current;
        this._size = currentSize;
        if (current) {
          current.next = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== 1 /* AsOld */ && touch !== 2 /* AsNew */) {
          return;
        }
        if (touch === 1 /* AsOld */) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === 2 /* AsNew */) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    Cache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = 2 /* AsNew */) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, 0 /* None */);
      }
      set(key, value) {
        super.set(key, value, 2 /* AsNew */);
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trim(Math.round(this._limit * this._ratio));
        }
      }
    };
    LRUCache = class extends Cache {
      constructor(limit, ratio = 1) {
        super(limit, ratio);
      }
      trim(newSize) {
        this.trimOld(newSize);
      }
      set(key, value) {
        super.set(key, value);
        this.checkTrim();
        return this;
      }
    };
    SetMap = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map();
      }
      add(key, value) {
        let values = this.map.get(key);
        if (!values) {
          values = /* @__PURE__ */ new Set();
          this.map.set(key, values);
        }
        values.add(value);
      }
      delete(key, value) {
        const values = this.map.get(key);
        if (!values) {
          return;
        }
        values.delete(value);
        if (values.size === 0) {
          this.map.delete(key);
        }
      }
      forEach(key, fn) {
        const values = this.map.get(key);
        if (!values) {
          return;
        }
        values.forEach(fn);
      }
      get(key) {
        const values = this.map.get(key);
        if (!values) {
          return /* @__PURE__ */ new Set();
        }
        return values;
      }
    };
  }
});

// src/util/vs/base/common/assert.ts
function assertNever(value, message = "Unreachable") {
  throw new Error(message);
}
function assert(condition, messageOrError = "unexpected state") {
  if (!condition) {
    const errorToThrow = typeof messageOrError === "string" ? new BugIndicatingError(`Assertion Failed: ${messageOrError}`) : messageOrError;
    throw errorToThrow;
  }
}
function assertFn(condition) {
  if (!condition()) {
    debugger;
    condition();
    onUnexpectedError(new BugIndicatingError("Assertion Failed"));
  }
}
function checkAdjacentItems(items, predicate) {
  let i = 0;
  while (i < items.length - 1) {
    const a = items[i];
    const b = items[i + 1];
    if (!predicate(a, b)) {
      return false;
    }
    i++;
  }
  return true;
}
var init_assert = __esm({
  "src/util/vs/base/common/assert.ts"() {
    "use strict";
    init_errors();
  }
});

// src/util/vs/base/common/types.ts
function isString(str) {
  return typeof str === "string";
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
function isIterable(obj) {
  return !!obj && typeof obj[Symbol.iterator] === "function";
}
function isUndefined(obj) {
  return typeof obj === "undefined";
}
function isDefined(arg) {
  return !isUndefinedOrNull(arg);
}
function isUndefinedOrNull(obj) {
  return isUndefined(obj) || obj === null;
}
function assertType(condition, type) {
  if (!condition) {
    throw new Error(type ? `Unexpected type, expected '${type}'` : "Unexpected type");
  }
}
var init_types = __esm({
  "src/util/vs/base/common/types.ts"() {
    "use strict";
    init_assert();
  }
});

// src/util/vs/base/common/iterator.ts
var Iterable;
var init_iterator = __esm({
  "src/util/vs/base/common/iterator.ts"() {
    "use strict";
    init_types();
    ((Iterable2) => {
      function is(thing) {
        return !!thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
      }
      Iterable2.is = is;
      const _empty2 = Object.freeze([]);
      function empty() {
        return _empty2;
      }
      Iterable2.empty = empty;
      function* single(element) {
        yield element;
      }
      Iterable2.single = single;
      function wrap(iterableOrElement) {
        if (is(iterableOrElement)) {
          return iterableOrElement;
        } else {
          return single(iterableOrElement);
        }
      }
      Iterable2.wrap = wrap;
      function from(iterable) {
        return iterable || _empty2;
      }
      Iterable2.from = from;
      function* reverse(array) {
        for (let i = array.length - 1; i >= 0; i--) {
          yield array[i];
        }
      }
      Iterable2.reverse = reverse;
      function isEmpty2(iterable) {
        return !iterable || iterable[Symbol.iterator]().next().done === true;
      }
      Iterable2.isEmpty = isEmpty2;
      function first(iterable) {
        return iterable[Symbol.iterator]().next().value;
      }
      Iterable2.first = first;
      function some(iterable, predicate) {
        let i = 0;
        for (const element of iterable) {
          if (predicate(element, i++)) {
            return true;
          }
        }
        return false;
      }
      Iterable2.some = some;
      function every(iterable, predicate) {
        let i = 0;
        for (const element of iterable) {
          if (!predicate(element, i++)) {
            return false;
          }
        }
        return true;
      }
      Iterable2.every = every;
      function find(iterable, predicate) {
        for (const element of iterable) {
          if (predicate(element)) {
            return element;
          }
        }
        return void 0;
      }
      Iterable2.find = find;
      function* filter(iterable, predicate) {
        for (const element of iterable) {
          if (predicate(element)) {
            yield element;
          }
        }
      }
      Iterable2.filter = filter;
      function* map2(iterable, fn) {
        let index = 0;
        for (const element of iterable) {
          yield fn(element, index++);
        }
      }
      Iterable2.map = map2;
      function* flatMap(iterable, fn) {
        let index = 0;
        for (const element of iterable) {
          yield* fn(element, index++);
        }
      }
      Iterable2.flatMap = flatMap;
      function* concat(...iterables) {
        for (const item of iterables) {
          if (isIterable(item)) {
            yield* item;
          } else {
            yield item;
          }
        }
      }
      Iterable2.concat = concat;
      function reduce(iterable, reducer, initialValue) {
        let value = initialValue;
        for (const element of iterable) {
          value = reducer(value, element);
        }
        return value;
      }
      Iterable2.reduce = reduce;
      function length(iterable) {
        let count2 = 0;
        for (const _ of iterable) {
          count2++;
        }
        return count2;
      }
      Iterable2.length = length;
      function* slice(arr, from2, to = arr.length) {
        if (from2 < -arr.length) {
          from2 = 0;
        }
        if (from2 < 0) {
          from2 += arr.length;
        }
        if (to < 0) {
          to += arr.length;
        } else if (to > arr.length) {
          to = arr.length;
        }
        for (; from2 < to; from2++) {
          yield arr[from2];
        }
      }
      Iterable2.slice = slice;
      function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
        const consumed = [];
        if (atMost === 0) {
          return [consumed, iterable];
        }
        const iterator = iterable[Symbol.iterator]();
        for (let i = 0; i < atMost; i++) {
          const next = iterator.next();
          if (next.done) {
            return [consumed, Iterable2.empty()];
          }
          consumed.push(next.value);
        }
        return [consumed, { [Symbol.iterator]() {
          return iterator;
        } }];
      }
      Iterable2.consume = consume;
      async function asyncToArray(iterable) {
        const result = [];
        for await (const item of iterable) {
          result.push(item);
        }
        return result;
      }
      Iterable2.asyncToArray = asyncToArray;
      async function asyncToArrayFlat(iterable) {
        let result = [];
        for await (const item of iterable) {
          result = result.concat(item);
        }
        return result;
      }
      Iterable2.asyncToArrayFlat = asyncToArrayFlat;
    })(Iterable || (Iterable = {}));
  }
});

// src/util/vs/base/common/lifecycle.ts
function setDisposableTracker(tracker) {
  disposableTracker = tracker;
}
function trackDisposable(x) {
  disposableTracker?.trackDisposable(x);
  return x;
}
function markAsDisposed(disposable) {
  disposableTracker?.markAsDisposed(disposable);
}
function setParentOfDisposable(child, parent) {
  disposableTracker?.setParent(child, parent);
}
function setParentOfDisposables(children, parent) {
  if (!disposableTracker) {
    return;
  }
  for (const child of children) {
    disposableTracker.setParent(child, parent);
  }
}
function isDisposable(thing) {
  return typeof thing === "object" && thing !== null && typeof thing.dispose === "function" && thing.dispose.length === 0;
}
function dispose(arg) {
  if (Iterable.is(arg)) {
    const errors2 = [];
    for (const d of arg) {
      if (d) {
        try {
          d.dispose();
        } catch (e) {
          errors2.push(e);
        }
      }
    }
    if (errors2.length === 1) {
      throw errors2[0];
    } else if (errors2.length > 1) {
      throw new AggregateError(errors2, "Encountered errors while disposing of store");
    }
    return Array.isArray(arg) ? [] : arg;
  } else if (arg) {
    arg.dispose();
    return arg;
  }
}
function combinedDisposable(...disposables) {
  const parent = toDisposable(() => dispose(disposables));
  setParentOfDisposables(disposables, parent);
  return parent;
}
function toDisposable(fn) {
  return new FunctionDisposable(fn);
}
var TRACK_DISPOSABLES, disposableTracker, DisposableTracker, FunctionDisposable, DisposableStore, Disposable;
var init_lifecycle = __esm({
  "src/util/vs/base/common/lifecycle.ts"() {
    "use strict";
    init_arrays();
    init_collections();
    init_map();
    init_functional();
    init_iterator();
    init_errors();
    TRACK_DISPOSABLES = false;
    disposableTracker = null;
    DisposableTracker = class _DisposableTracker {
      constructor() {
        this.livingDisposables = /* @__PURE__ */ new Map();
      }
      static {
        this.idx = 0;
      }
      getDisposableData(d) {
        let val = this.livingDisposables.get(d);
        if (!val) {
          val = { parent: null, source: null, isSingleton: false, value: d, idx: _DisposableTracker.idx++ };
          this.livingDisposables.set(d, val);
        }
        return val;
      }
      trackDisposable(d) {
        const data = this.getDisposableData(d);
        if (!data.source) {
          data.source = new Error().stack;
        }
      }
      setParent(child, parent) {
        const data = this.getDisposableData(child);
        data.parent = parent;
      }
      markAsDisposed(x) {
        this.livingDisposables.delete(x);
      }
      markAsSingleton(disposable) {
        this.getDisposableData(disposable).isSingleton = true;
      }
      getRootParent(data, cache) {
        const cacheValue = cache.get(data);
        if (cacheValue) {
          return cacheValue;
        }
        const result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;
        cache.set(data, result);
        return result;
      }
      getTrackedDisposables() {
        const rootParentCache = /* @__PURE__ */ new Map();
        const leaking = [...this.livingDisposables.entries()].filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton).flatMap(([k]) => k);
        return leaking;
      }
      computeLeakingDisposables(maxReported = 10, preComputedLeaks) {
        let uncoveredLeakingObjs;
        if (preComputedLeaks) {
          uncoveredLeakingObjs = preComputedLeaks;
        } else {
          const rootParentCache = /* @__PURE__ */ new Map();
          const leakingObjects = [...this.livingDisposables.values()].filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);
          if (leakingObjects.length === 0) {
            return;
          }
          const leakingObjsSet = new Set(leakingObjects.map((o) => o.value));
          uncoveredLeakingObjs = leakingObjects.filter((l) => {
            return !(l.parent && leakingObjsSet.has(l.parent));
          });
          if (uncoveredLeakingObjs.length === 0) {
            throw new Error("There are cyclic diposable chains!");
          }
        }
        if (!uncoveredLeakingObjs) {
          return void 0;
        }
        function getStackTracePath(leaking) {
          function removePrefix(array, linesToRemove) {
            while (array.length > 0 && linesToRemove.some((regexp) => typeof regexp === "string" ? regexp === array[0] : array[0].match(regexp))) {
              array.shift();
            }
          }
          const lines = leaking.source.split("\n").map((p) => p.trim().replace("at ", "")).filter((l) => l !== "");
          removePrefix(lines, ["Error", /^trackDisposable \(.*\)$/, /^DisposableTracker.trackDisposable \(.*\)$/]);
          return lines.reverse();
        }
        const stackTraceStarts = new SetMap();
        for (const leaking of uncoveredLeakingObjs) {
          const stackTracePath = getStackTracePath(leaking);
          for (let i2 = 0; i2 <= stackTracePath.length; i2++) {
            stackTraceStarts.add(stackTracePath.slice(0, i2).join("\n"), leaking);
          }
        }
        uncoveredLeakingObjs.sort(compareBy((l) => l.idx, numberComparator));
        let message = "";
        let i = 0;
        for (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {
          i++;
          const stackTracePath = getStackTracePath(leaking);
          const stackTraceFormattedLines = [];
          for (let i2 = 0; i2 < stackTracePath.length; i2++) {
            let line = stackTracePath[i2];
            const starts = stackTraceStarts.get(stackTracePath.slice(0, i2 + 1).join("\n"));
            line = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;
            const prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i2).join("\n"));
            const continuations = groupBy([...prevStarts].map((d) => getStackTracePath(d)[i2]), (v) => v);
            delete continuations[stackTracePath[i2]];
            for (const [cont, set2] of Object.entries(continuations)) {
              if (set2) {
                stackTraceFormattedLines.unshift(`    - stacktraces of ${set2.length} other leaks continue with ${cont}`);
              }
            }
            stackTraceFormattedLines.unshift(line);
          }
          message += `


==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================
${stackTraceFormattedLines.join("\n")}
============================================================

`;
        }
        if (uncoveredLeakingObjs.length > maxReported) {
          message += `


... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables

`;
        }
        return { leaks: uncoveredLeakingObjs, details: message };
      }
    };
    if (TRACK_DISPOSABLES) {
      const __is_disposable_tracked__ = "__is_disposable_tracked__";
      setDisposableTracker(new class {
        trackDisposable(x) {
          const stack = new Error("Potentially leaked disposable").stack;
          setTimeout(() => {
            if (!x[__is_disposable_tracked__]) {
              console.log(stack);
            }
          }, 3e3);
        }
        setParent(child, parent) {
          if (child && child !== Disposable.None) {
            try {
              child[__is_disposable_tracked__] = true;
            } catch {
            }
          }
        }
        markAsDisposed(disposable) {
          if (disposable && disposable !== Disposable.None) {
            try {
              disposable[__is_disposable_tracked__] = true;
            } catch {
            }
          }
        }
        markAsSingleton(disposable) {
        }
      }());
    }
    FunctionDisposable = class {
      constructor(fn) {
        this._isDisposed = false;
        this._fn = fn;
        trackDisposable(this);
      }
      dispose() {
        if (this._isDisposed) {
          return;
        }
        if (!this._fn) {
          throw new Error(`Unbound disposable context: Need to use an arrow function to preserve the value of this`);
        }
        this._isDisposed = true;
        markAsDisposed(this);
        this._fn();
      }
    };
    DisposableStore = class _DisposableStore {
      constructor() {
        this._toDispose = /* @__PURE__ */ new Set();
        this._isDisposed = false;
        trackDisposable(this);
      }
      static {
        this.DISABLE_DISPOSED_WARNING = false;
      }
      /**
       * Dispose of all registered disposables and mark this object as disposed.
       *
       * Any future disposables added to this object will be disposed of on `add`.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        markAsDisposed(this);
        this._isDisposed = true;
        this.clear();
      }
      /**
       * @return `true` if this object has been disposed of.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of all registered disposables but do not mark this object as disposed.
       */
      clear() {
        if (this._toDispose.size === 0) {
          return;
        }
        try {
          dispose(this._toDispose);
        } finally {
          this._toDispose.clear();
        }
      }
      /**
       * Add a new {@link IDisposable disposable} to the collection.
       */
      add(o) {
        if (!o || o === Disposable.None) {
          return o;
        }
        if (o === this) {
          throw new Error("Cannot register a disposable on itself!");
        }
        setParentOfDisposable(o, this);
        if (this._isDisposed) {
          if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
            console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
          }
        } else {
          this._toDispose.add(o);
        }
        return o;
      }
      /**
       * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the
       * disposable even when the disposable is not part in the store.
       */
      delete(o) {
        if (!o) {
          return;
        }
        if (o === this) {
          throw new Error("Cannot dispose a disposable on itself!");
        }
        this._toDispose.delete(o);
        o.dispose();
      }
      /**
       * Deletes the value from the store, but does not dispose it.
       */
      deleteAndLeak(o) {
        if (!o) {
          return;
        }
        if (this._toDispose.has(o)) {
          this._toDispose.delete(o);
          setParentOfDisposable(o, null);
        }
      }
      assertNotDisposed() {
        if (this._isDisposed) {
          onUnexpectedError(new BugIndicatingError("Object disposed"));
        }
      }
    };
    Disposable = class {
      constructor() {
        this._store = new DisposableStore();
        trackDisposable(this);
        setParentOfDisposable(this._store, this);
      }
      static {
        /**
         * A disposable that does nothing when it is disposed of.
         *
         * TODO: This should not be a static property.
         */
        this.None = Object.freeze({ dispose() {
        } });
      }
      dispose() {
        markAsDisposed(this);
        this._store.dispose();
      }
      /**
       * Adds `o` to the collection of disposables managed by this object.
       */
      _register(o) {
        if (o === this) {
          throw new Error("Cannot register a disposable on itself!");
        }
        return this._store.add(o);
      }
    };
  }
});

// src/util/vs/base/common/linkedList.ts
var Node, LinkedList;
var init_linkedList = __esm({
  "src/util/vs/base/common/linkedList.ts"() {
    "use strict";
    Node = class _Node {
      static {
        this.Undefined = new _Node(void 0);
      }
      constructor(element) {
        this.element = element;
        this.next = _Node.Undefined;
        this.prev = _Node.Undefined;
      }
    };
    LinkedList = class {
      constructor() {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
      }
      get size() {
        return this._size;
      }
      isEmpty() {
        return this._first === Node.Undefined;
      }
      clear() {
        let node = this._first;
        while (node !== Node.Undefined) {
          const next = node.next;
          node.prev = Node.Undefined;
          node.next = Node.Undefined;
          node = next;
        }
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
      }
      unshift(element) {
        return this._insert(element, false);
      }
      push(element) {
        return this._insert(element, true);
      }
      _insert(element, atTheEnd) {
        const newNode = new Node(element);
        if (this._first === Node.Undefined) {
          this._first = newNode;
          this._last = newNode;
        } else if (atTheEnd) {
          const oldLast = this._last;
          this._last = newNode;
          newNode.prev = oldLast;
          oldLast.next = newNode;
        } else {
          const oldFirst = this._first;
          this._first = newNode;
          newNode.next = oldFirst;
          oldFirst.prev = newNode;
        }
        this._size += 1;
        let didRemove = false;
        return () => {
          if (!didRemove) {
            didRemove = true;
            this._remove(newNode);
          }
        };
      }
      shift() {
        if (this._first === Node.Undefined) {
          return void 0;
        } else {
          const res = this._first.element;
          this._remove(this._first);
          return res;
        }
      }
      pop() {
        if (this._last === Node.Undefined) {
          return void 0;
        } else {
          const res = this._last.element;
          this._remove(this._last);
          return res;
        }
      }
      _remove(node) {
        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
          const anchor = node.prev;
          anchor.next = node.next;
          node.next.prev = anchor;
        } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
          this._first = Node.Undefined;
          this._last = Node.Undefined;
        } else if (node.next === Node.Undefined) {
          this._last = this._last.prev;
          this._last.next = Node.Undefined;
        } else if (node.prev === Node.Undefined) {
          this._first = this._first.next;
          this._first.prev = Node.Undefined;
        }
        this._size -= 1;
      }
      *[Symbol.iterator]() {
        let node = this._first;
        while (node !== Node.Undefined) {
          yield node.element;
          node = node.next;
        }
      }
    };
  }
});

// src/util/vs/base/common/stopwatch.ts
var performanceNow, StopWatch;
var init_stopwatch = __esm({
  "src/util/vs/base/common/stopwatch.ts"() {
    "use strict";
    performanceNow = globalThis.performance.now.bind(globalThis.performance);
    StopWatch = class _StopWatch {
      static create(highResolution) {
        return new _StopWatch(highResolution);
      }
      constructor(highResolution) {
        this._now = highResolution === false ? Date.now : performanceNow;
        this._startTime = this._now();
        this._stopTime = -1;
      }
      stop() {
        this._stopTime = this._now();
      }
      reset() {
        this._startTime = this._now();
        this._stopTime = -1;
      }
      elapsed() {
        if (this._stopTime !== -1) {
          return this._stopTime - this._startTime;
        }
        return this._now() - this._startTime;
      }
    };
  }
});

// src/util/vs/base/common/event.ts
var _enableDisposeWithListenerWarning, _enableSnapshotPotentialLeakWarning, Event, EventProfiling, _globalLeakWarningThreshold, LeakageMonitor, Stacktrace, ListenerLeakError, ListenerRefusalError, id, UniqueContainer, compactionThreshold, forEachListener, Emitter, EventDeliveryQueuePrivate;
var init_event = __esm({
  "src/util/vs/base/common/event.ts"() {
    "use strict";
    init_collections();
    init_errors();
    init_functional();
    init_lifecycle();
    init_linkedList();
    init_stopwatch();
    _enableDisposeWithListenerWarning = false;
    _enableSnapshotPotentialLeakWarning = false;
    ((Event11) => {
      Event11.None = () => Disposable.None;
      function _addLeakageTraceLogic(options) {
        if (_enableSnapshotPotentialLeakWarning) {
          const { onDidAddListener: origListenerDidAdd } = options;
          const stack = Stacktrace.create();
          let count2 = 0;
          options.onDidAddListener = () => {
            if (++count2 === 2) {
              console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
              stack.print();
            }
            origListenerDidAdd?.();
          };
        }
      }
      function defer(event, disposable) {
        return debounce(event, () => void 0, 0, void 0, true, void 0, disposable);
      }
      Event11.defer = defer;
      function once(event) {
        return (listener, thisArgs = null, disposables) => {
          let didFire = false;
          let result = void 0;
          result = event((e) => {
            if (didFire) {
              return;
            } else if (result) {
              result.dispose();
            } else {
              didFire = true;
            }
            return listener.call(thisArgs, e);
          }, null, disposables);
          if (didFire) {
            result.dispose();
          }
          return result;
        };
      }
      Event11.once = once;
      function onceIf(event, condition) {
        return Event11.once(Event11.filter(event, condition));
      }
      Event11.onceIf = onceIf;
      function map2(event, map3, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map3(i)), null, disposables), disposable);
      }
      Event11.map = map2;
      function forEach(event, each, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event((i) => {
          each(i);
          listener.call(thisArgs, i);
        }, null, disposables), disposable);
      }
      Event11.forEach = forEach;
      function filter(event, filter2, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event((e) => filter2(e) && listener.call(thisArgs, e), null, disposables), disposable);
      }
      Event11.filter = filter;
      function signal(event) {
        return event;
      }
      Event11.signal = signal;
      function any(...events) {
        return (listener, thisArgs = null, disposables) => {
          const disposable = combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e))));
          return addAndReturnDisposable(disposable, disposables);
        };
      }
      Event11.any = any;
      function reduce(event, merge, initial, disposable) {
        let output = initial;
        return map2(event, (e) => {
          output = merge(output, e);
          return output;
        }, disposable);
      }
      Event11.reduce = reduce;
      function snapshot(event, disposable) {
        let listener;
        const options = {
          onWillAddFirstListener() {
            listener = event(emitter.fire, emitter);
          },
          onDidRemoveLastListener() {
            listener?.dispose();
          }
        };
        if (!disposable) {
          _addLeakageTraceLogic(options);
        }
        const emitter = new Emitter(options);
        disposable?.add(emitter);
        return emitter.event;
      }
      function addAndReturnDisposable(d, store) {
        if (store instanceof Array) {
          store.push(d);
        } else if (store) {
          store.add(d);
        }
        return d;
      }
      function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
        let subscription;
        let output = void 0;
        let handle = void 0;
        let numDebouncedCalls = 0;
        let doFire;
        const options = {
          leakWarningThreshold,
          onWillAddFirstListener() {
            subscription = event((cur) => {
              numDebouncedCalls++;
              output = merge(output, cur);
              if (leading && !handle) {
                emitter.fire(output);
                output = void 0;
              }
              doFire = () => {
                const _output = output;
                output = void 0;
                handle = void 0;
                if (!leading || numDebouncedCalls > 1) {
                  emitter.fire(_output);
                }
                numDebouncedCalls = 0;
              };
              if (typeof delay === "number") {
                if (handle) {
                  clearTimeout(handle);
                }
                handle = setTimeout(doFire, delay);
              } else {
                if (handle === void 0) {
                  handle = null;
                  queueMicrotask(doFire);
                }
              }
            });
          },
          onWillRemoveListener() {
            if (flushOnListenerRemove && numDebouncedCalls > 0) {
              doFire?.();
            }
          },
          onDidRemoveLastListener() {
            doFire = void 0;
            subscription.dispose();
          }
        };
        if (!disposable) {
          _addLeakageTraceLogic(options);
        }
        const emitter = new Emitter(options);
        disposable?.add(emitter);
        return emitter.event;
      }
      Event11.debounce = debounce;
      function accumulate(event, delay = 0, disposable) {
        return Event11.debounce(event, (last, e) => {
          if (!last) {
            return [e];
          }
          last.push(e);
          return last;
        }, delay, void 0, true, void 0, disposable);
      }
      Event11.accumulate = accumulate;
      function latch(event, equals3 = (a, b) => a === b, disposable) {
        let firstCall = true;
        let cache;
        return filter(event, (value) => {
          const shouldEmit = firstCall || !equals3(value, cache);
          firstCall = false;
          cache = value;
          return shouldEmit;
        }, disposable);
      }
      Event11.latch = latch;
      function split(event, isT, disposable) {
        return [
          Event11.filter(event, isT, disposable),
          Event11.filter(event, (e) => !isT(e), disposable)
        ];
      }
      Event11.split = split;
      function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {
        let buffer2 = _buffer.slice();
        let listener = event((e) => {
          if (buffer2) {
            buffer2.push(e);
          } else {
            emitter.fire(e);
          }
        });
        if (disposable) {
          disposable.add(listener);
        }
        const flush = () => {
          buffer2?.forEach((e) => emitter.fire(e));
          buffer2 = null;
        };
        const emitter = new Emitter({
          onWillAddFirstListener() {
            if (!listener) {
              listener = event((e) => emitter.fire(e));
              if (disposable) {
                disposable.add(listener);
              }
            }
          },
          onDidAddFirstListener() {
            if (buffer2) {
              if (flushAfterTimeout) {
                setTimeout(flush);
              } else {
                flush();
              }
            }
          },
          onDidRemoveLastListener() {
            if (listener) {
              listener.dispose();
            }
            listener = null;
          }
        });
        if (disposable) {
          disposable.add(emitter);
        }
        return emitter.event;
      }
      Event11.buffer = buffer;
      function chain(event, sythensize) {
        const fn = (listener, thisArgs, disposables) => {
          const cs = sythensize(new ChainableSynthesis());
          return event(function(value) {
            const result = cs.evaluate(value);
            if (result !== HaltChainable) {
              listener.call(thisArgs, result);
            }
          }, void 0, disposables);
        };
        return fn;
      }
      Event11.chain = chain;
      const HaltChainable = Symbol("HaltChainable");
      class ChainableSynthesis {
        constructor() {
          this.steps = [];
        }
        map(fn) {
          this.steps.push(fn);
          return this;
        }
        forEach(fn) {
          this.steps.push((v) => {
            fn(v);
            return v;
          });
          return this;
        }
        filter(fn) {
          this.steps.push((v) => fn(v) ? v : HaltChainable);
          return this;
        }
        reduce(merge, initial) {
          let last = initial;
          this.steps.push((v) => {
            last = merge(last, v);
            return last;
          });
          return this;
        }
        latch(equals3 = (a, b) => a === b) {
          let firstCall = true;
          let cache;
          this.steps.push((value) => {
            const shouldEmit = firstCall || !equals3(value, cache);
            firstCall = false;
            cache = value;
            return shouldEmit ? value : HaltChainable;
          });
          return this;
        }
        evaluate(value) {
          for (const step of this.steps) {
            value = step(value);
            if (value === HaltChainable) {
              break;
            }
          }
          return value;
        }
      }
      function fromNodeEventEmitter(emitter, eventName, map3 = (id2) => id2) {
        const fn = (...args) => result.fire(map3(...args));
        const onFirstListenerAdd = () => emitter.on(eventName, fn);
        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
        return result.event;
      }
      Event11.fromNodeEventEmitter = fromNodeEventEmitter;
      function fromDOMEventEmitter(emitter, eventName, map3 = (id2) => id2) {
        const fn = (...args) => result.fire(map3(...args));
        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
        return result.event;
      }
      Event11.fromDOMEventEmitter = fromDOMEventEmitter;
      function toPromise(event, disposables) {
        let cancelRef;
        const promise = new Promise((resolve2, reject) => {
          const listener = once(event)(resolve2, null, disposables);
          cancelRef = () => listener.dispose();
        });
        promise.cancel = cancelRef;
        return promise;
      }
      Event11.toPromise = toPromise;
      function forward(from, to) {
        return from((e) => to.fire(e));
      }
      Event11.forward = forward;
      function runAndSubscribe(event, handler, initial) {
        handler(initial);
        return event((e) => handler(e));
      }
      Event11.runAndSubscribe = runAndSubscribe;
      class EmitterObserver {
        constructor(_observable, store) {
          this._observable = _observable;
          this._counter = 0;
          this._hasChanged = false;
          const options = {
            onWillAddFirstListener: () => {
              _observable.addObserver(this);
              this._observable.reportChanges();
            },
            onDidRemoveLastListener: () => {
              _observable.removeObserver(this);
            }
          };
          if (!store) {
            _addLeakageTraceLogic(options);
          }
          this.emitter = new Emitter(options);
          if (store) {
            store.add(this.emitter);
          }
        }
        beginUpdate(_observable) {
          this._counter++;
        }
        handlePossibleChange(_observable) {
        }
        handleChange(_observable, _change) {
          this._hasChanged = true;
        }
        endUpdate(_observable) {
          this._counter--;
          if (this._counter === 0) {
            this._observable.reportChanges();
            if (this._hasChanged) {
              this._hasChanged = false;
              this.emitter.fire(this._observable.get());
            }
          }
        }
      }
      function fromObservable(obs, store) {
        const observer = new EmitterObserver(obs, store);
        return observer.emitter.event;
      }
      Event11.fromObservable = fromObservable;
      function fromObservableLight(observable) {
        return (listener, thisArgs, disposables) => {
          let count2 = 0;
          let didChange = false;
          const observer = {
            beginUpdate() {
              count2++;
            },
            endUpdate() {
              count2--;
              if (count2 === 0) {
                observable.reportChanges();
                if (didChange) {
                  didChange = false;
                  listener.call(thisArgs);
                }
              }
            },
            handlePossibleChange() {
            },
            handleChange() {
              didChange = true;
            }
          };
          observable.addObserver(observer);
          observable.reportChanges();
          const disposable = {
            dispose() {
              observable.removeObserver(observer);
            }
          };
          if (disposables instanceof DisposableStore) {
            disposables.add(disposable);
          } else if (Array.isArray(disposables)) {
            disposables.push(disposable);
          }
          return disposable;
        };
      }
      Event11.fromObservableLight = fromObservableLight;
    })(Event || (Event = {}));
    EventProfiling = class _EventProfiling {
      constructor(name) {
        this.listenerCount = 0;
        this.invocationCount = 0;
        this.elapsedOverall = 0;
        this.durations = [];
        this.name = `${name}_${_EventProfiling._idPool++}`;
        _EventProfiling.all.add(this);
      }
      static {
        this.all = /* @__PURE__ */ new Set();
      }
      static {
        this._idPool = 0;
      }
      start(listenerCount) {
        this._stopWatch = new StopWatch();
        this.listenerCount = listenerCount;
      }
      stop() {
        if (this._stopWatch) {
          const elapsed = this._stopWatch.elapsed();
          this.durations.push(elapsed);
          this.elapsedOverall += elapsed;
          this.invocationCount += 1;
          this._stopWatch = void 0;
        }
      }
    };
    _globalLeakWarningThreshold = -1;
    LeakageMonitor = class _LeakageMonitor {
      constructor(_errorHandler, threshold, name = (_LeakageMonitor._idPool++).toString(16).padStart(3, "0")) {
        this._errorHandler = _errorHandler;
        this.threshold = threshold;
        this.name = name;
        this._warnCountdown = 0;
      }
      static {
        this._idPool = 1;
      }
      dispose() {
        this._stacks?.clear();
      }
      check(stack, listenerCount) {
        const threshold = this.threshold;
        if (threshold <= 0 || listenerCount < threshold) {
          return void 0;
        }
        if (!this._stacks) {
          this._stacks = /* @__PURE__ */ new Map();
        }
        const count2 = this._stacks.get(stack.value) || 0;
        this._stacks.set(stack.value, count2 + 1);
        this._warnCountdown -= 1;
        if (this._warnCountdown <= 0) {
          this._warnCountdown = threshold * 0.5;
          const [topStack, topCount] = this.getMostFrequentStack();
          const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;
          console.warn(message);
          console.warn(topStack);
          const error2 = new ListenerLeakError(message, topStack);
          this._errorHandler(error2);
        }
        return () => {
          const count3 = this._stacks.get(stack.value) || 0;
          this._stacks.set(stack.value, count3 - 1);
        };
      }
      getMostFrequentStack() {
        if (!this._stacks) {
          return void 0;
        }
        let topStack;
        let topCount = 0;
        for (const [stack, count2] of this._stacks) {
          if (!topStack || topCount < count2) {
            topStack = [stack, count2];
            topCount = count2;
          }
        }
        return topStack;
      }
    };
    Stacktrace = class _Stacktrace {
      constructor(value) {
        this.value = value;
      }
      static create() {
        const err = new Error();
        return new _Stacktrace(err.stack ?? "");
      }
      print() {
        console.warn(this.value.split("\n").slice(2).join("\n"));
      }
    };
    ListenerLeakError = class extends Error {
      constructor(message, stack) {
        super(message);
        this.name = "ListenerLeakError";
        this.stack = stack;
      }
    };
    ListenerRefusalError = class extends Error {
      constructor(message, stack) {
        super(message);
        this.name = "ListenerRefusalError";
        this.stack = stack;
      }
    };
    id = 0;
    UniqueContainer = class {
      constructor(value) {
        this.value = value;
        this.id = id++;
      }
    };
    compactionThreshold = 2;
    forEachListener = (listeners, fn) => {
      if (listeners instanceof UniqueContainer) {
        fn(listeners);
      } else {
        for (let i = 0; i < listeners.length; i++) {
          const l = listeners[i];
          if (l) {
            fn(l);
          }
        }
      }
    };
    Emitter = class {
      constructor(options) {
        this._size = 0;
        this._options = options;
        this._leakageMon = _globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold ? new LeakageMonitor(options?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) : void 0;
        this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : void 0;
        this._deliveryQueue = this._options?.deliveryQueue;
      }
      dispose() {
        if (!this._disposed) {
          this._disposed = true;
          if (this._deliveryQueue?.current === this) {
            this._deliveryQueue.reset();
          }
          if (this._listeners) {
            if (_enableDisposeWithListenerWarning) {
              const listeners = this._listeners;
              queueMicrotask(() => {
                forEachListener(listeners, (l) => l.stack?.print());
              });
            }
            this._listeners = void 0;
            this._size = 0;
          }
          this._options?.onDidRemoveLastListener?.();
          this._leakageMon?.dispose();
        }
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        this._event ??= (callback, thisArgs, disposables) => {
          if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
            const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
            console.warn(message);
            const tuple = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1];
            const error2 = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);
            const errorHandler2 = this._options?.onListenerError || onUnexpectedError;
            errorHandler2(error2);
            return Disposable.None;
          }
          if (this._disposed) {
            return Disposable.None;
          }
          if (thisArgs) {
            callback = callback.bind(thisArgs);
          }
          const contained = new UniqueContainer(callback);
          let removeMonitor;
          let stack;
          if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
            contained.stack = Stacktrace.create();
            removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
          }
          if (_enableDisposeWithListenerWarning) {
            contained.stack = stack ?? Stacktrace.create();
          }
          if (!this._listeners) {
            this._options?.onWillAddFirstListener?.(this);
            this._listeners = contained;
            this._options?.onDidAddFirstListener?.(this);
          } else if (this._listeners instanceof UniqueContainer) {
            this._deliveryQueue ??= new EventDeliveryQueuePrivate();
            this._listeners = [this._listeners, contained];
          } else {
            this._listeners.push(contained);
          }
          this._options?.onDidAddListener?.(this);
          this._size++;
          const result = toDisposable(() => {
            removeMonitor?.();
            this._removeListener(contained);
          });
          if (disposables instanceof DisposableStore) {
            disposables.add(result);
          } else if (Array.isArray(disposables)) {
            disposables.push(result);
          }
          return result;
        };
        return this._event;
      }
      _removeListener(listener) {
        this._options?.onWillRemoveListener?.(this);
        if (!this._listeners) {
          return;
        }
        if (this._size === 1) {
          this._listeners = void 0;
          this._options?.onDidRemoveLastListener?.(this);
          this._size = 0;
          return;
        }
        const listeners = this._listeners;
        const index = listeners.indexOf(listener);
        if (index === -1) {
          console.log("disposed?", this._disposed);
          console.log("size?", this._size);
          console.log("arr?", JSON.stringify(this._listeners));
          throw new Error("Attempted to dispose unknown listener");
        }
        this._size--;
        listeners[index] = void 0;
        const adjustDeliveryQueue = this._deliveryQueue.current === this;
        if (this._size * compactionThreshold <= listeners.length) {
          let n = 0;
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]) {
              listeners[n++] = listeners[i];
            } else if (adjustDeliveryQueue && n < this._deliveryQueue.end) {
              this._deliveryQueue.end--;
              if (n < this._deliveryQueue.i) {
                this._deliveryQueue.i--;
              }
            }
          }
          listeners.length = n;
        }
      }
      _deliver(listener, value) {
        if (!listener) {
          return;
        }
        const errorHandler2 = this._options?.onListenerError || onUnexpectedError;
        if (!errorHandler2) {
          listener.value(value);
          return;
        }
        try {
          listener.value(value);
        } catch (e) {
          errorHandler2(e);
        }
      }
      /** Delivers items in the queue. Assumes the queue is ready to go. */
      _deliverQueue(dq) {
        const listeners = dq.current._listeners;
        while (dq.i < dq.end) {
          this._deliver(listeners[dq.i++], dq.value);
        }
        dq.reset();
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._deliveryQueue?.current) {
          this._deliverQueue(this._deliveryQueue);
          this._perfMon?.stop();
        }
        this._perfMon?.start(this._size);
        if (!this._listeners) {
        } else if (this._listeners instanceof UniqueContainer) {
          this._deliver(this._listeners, event);
        } else {
          const dq = this._deliveryQueue;
          dq.enqueue(this, event, this._listeners.length);
          this._deliverQueue(dq);
        }
        this._perfMon?.stop();
      }
      hasListeners() {
        return this._size > 0;
      }
    };
    EventDeliveryQueuePrivate = class {
      constructor() {
        /**
         * Index in current's listener list.
         */
        this.i = -1;
        /**
         * The last index in the listener's list to deliver.
         */
        this.end = 0;
      }
      enqueue(emitter, value, end) {
        this.i = 0;
        this.end = end;
        this.current = emitter;
        this.value = value;
      }
      reset() {
        this.i = this.end;
        this.current = void 0;
        this.value = void 0;
      }
    };
  }
});

// src/util/vs/base/common/cancellation.ts
function cancelOnDispose(store) {
  const source = new CancellationTokenSource();
  store.add({ dispose() {
    source.cancel();
  } });
  return source.token;
}
var shortcutEvent, CancellationToken, MutableToken, CancellationTokenSource;
var init_cancellation = __esm({
  "src/util/vs/base/common/cancellation.ts"() {
    "use strict";
    init_event();
    init_lifecycle();
    shortcutEvent = Object.freeze(function(callback, context) {
      const handle = setTimeout(callback.bind(context), 0);
      return { dispose() {
        clearTimeout(handle);
      } };
    });
    ((CancellationToken6) => {
      function isCancellationToken(thing) {
        if (thing === CancellationToken6.None || thing === CancellationToken6.Cancelled) {
          return true;
        }
        if (thing instanceof MutableToken) {
          return true;
        }
        if (!thing || typeof thing !== "object") {
          return false;
        }
        return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
      }
      CancellationToken6.isCancellationToken = isCancellationToken;
      CancellationToken6.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: Event.None
      });
      CancellationToken6.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: shortcutEvent
      });
    })(CancellationToken || (CancellationToken = {}));
    MutableToken = class {
      constructor() {
        this._isCancelled = false;
        this._emitter = null;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = null;
        }
      }
    };
    CancellationTokenSource = class {
      constructor(parent) {
        this._token = void 0;
        this._parentListener = void 0;
        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
      }
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else if (this._token instanceof MutableToken) {
          this._token.cancel();
        }
      }
      dispose(cancel = false) {
        if (cancel) {
          this.cancel();
        }
        this._parentListener?.dispose();
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
  }
});

// src/util/vs/base/common/charCode.ts
var init_charCode = __esm({
  "src/util/vs/base/common/charCode.ts"() {
    "use strict";
  }
});

// src/util/vs/base/common/cache.ts
function identity(t2) {
  return t2;
}
var LRUCachedFunction, CachedFunction;
var init_cache = __esm({
  "src/util/vs/base/common/cache.ts"() {
    "use strict";
    init_cancellation();
    LRUCachedFunction = class {
      constructor(arg1, arg2) {
        this.lastCache = void 0;
        this.lastArgKey = void 0;
        if (typeof arg1 === "function") {
          this._fn = arg1;
          this._computeKey = identity;
        } else {
          this._fn = arg2;
          this._computeKey = arg1.getCacheKey;
        }
      }
      get(arg) {
        const key = this._computeKey(arg);
        if (this.lastArgKey !== key) {
          this.lastArgKey = key;
          this.lastCache = this._fn(arg);
        }
        return this.lastCache;
      }
    };
    CachedFunction = class {
      constructor(arg1, arg2) {
        this._map = /* @__PURE__ */ new Map();
        this._map2 = /* @__PURE__ */ new Map();
        if (typeof arg1 === "function") {
          this._fn = arg1;
          this._computeKey = identity;
        } else {
          this._fn = arg2;
          this._computeKey = arg1.getCacheKey;
        }
      }
      get cachedValues() {
        return this._map;
      }
      get(arg) {
        const key = this._computeKey(arg);
        if (this._map2.has(key)) {
          return this._map2.get(key);
        }
        const value = this._fn(arg);
        this._map.set(arg, value);
        this._map2.set(key, value);
        return value;
      }
    };
  }
});

// src/util/vs/base/common/lazy.ts
var Lazy;
var init_lazy = __esm({
  "src/util/vs/base/common/lazy.ts"() {
    "use strict";
    Lazy = class {
      constructor(executor) {
        this.executor = executor;
        this._state = 0 /* Uninitialized */;
      }
      /**
       * True if the lazy value has been resolved.
       */
      get hasValue() {
        return this._state === 2 /* Completed */;
      }
      /**
       * Get the wrapped value.
       *
       * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
       * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
       */
      get value() {
        if (this._state === 0 /* Uninitialized */) {
          this._state = 1 /* Running */;
          try {
            this._value = this.executor();
          } catch (err) {
            this._error = err;
          } finally {
            this._state = 2 /* Completed */;
          }
        } else if (this._state === 1 /* Running */) {
          throw new Error("Cannot read the value of a lazy that is being initialized");
        }
        if (this._error) {
          throw this._error;
        }
        return this._value;
      }
      /**
       * Get the wrapped value without forcing evaluation.
       */
      get rawValue() {
        return this._value;
      }
    };
  }
});

// src/util/vs/base/common/uint.ts
function toUint32(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 4294967295 /* MAX_UINT_32 */) {
    return 4294967295 /* MAX_UINT_32 */;
  }
  return v | 0;
}
var init_uint = __esm({
  "src/util/vs/base/common/uint.ts"() {
    "use strict";
  }
});

// src/util/vs/base/common/strings.ts
var strings_exports = {};
__export(strings_exports, {
  AmbiguousCharacters: () => AmbiguousCharacters,
  CodePointIterator: () => CodePointIterator,
  Ellipsis: () => Ellipsis,
  GraphemeBreakType: () => GraphemeBreakType,
  GraphemeIterator: () => GraphemeIterator,
  InvisibleCharacters: () => InvisibleCharacters,
  UNUSUAL_LINE_TERMINATORS: () => UNUSUAL_LINE_TERMINATORS,
  UTF8_BOM_CHARACTER: () => UTF8_BOM_CHARACTER,
  charCount: () => charCount,
  commonPrefixLength: () => commonPrefixLength,
  commonSuffixLength: () => commonSuffixLength,
  compare: () => compare,
  compareIgnoreCase: () => compareIgnoreCase,
  compareSubstring: () => compareSubstring,
  compareSubstringIgnoreCase: () => compareSubstringIgnoreCase,
  computeCodePoint: () => computeCodePoint,
  containsRTL: () => containsRTL,
  containsUnusualLineTerminators: () => containsUnusualLineTerminators,
  containsUppercaseCharacter: () => containsUppercaseCharacter,
  convertSimple2RegExpPattern: () => convertSimple2RegExpPattern,
  count: () => count,
  createRegExp: () => createRegExp,
  equalsIgnoreCase: () => equalsIgnoreCase,
  escape: () => escape,
  escapeRegExpCharacters: () => escapeRegExpCharacters,
  firstNonWhitespaceIndex: () => firstNonWhitespaceIndex,
  forAnsiStringParts: () => forAnsiStringParts,
  format: () => format3,
  format2: () => format22,
  fuzzyContains: () => fuzzyContains,
  getCharContainingOffset: () => getCharContainingOffset,
  getGraphemeBreakType: () => getGraphemeBreakType,
  getIndentationLength: () => getIndentationLength,
  getLeadingWhitespace: () => getLeadingWhitespace,
  getLeftDeleteOffset: () => getLeftDeleteOffset,
  getNLines: () => getNLines,
  getNextCodePoint: () => getNextCodePoint,
  htmlAttributeEncodeValue: () => htmlAttributeEncodeValue,
  indexOfPattern: () => indexOfPattern,
  isAsciiDigit: () => isAsciiDigit,
  isBasicASCII: () => isBasicASCII,
  isEmojiImprecise: () => isEmojiImprecise,
  isFalsyOrWhitespace: () => isFalsyOrWhitespace,
  isFullWidthCharacter: () => isFullWidthCharacter,
  isHighSurrogate: () => isHighSurrogate,
  isLowSurrogate: () => isLowSurrogate,
  isLowerAsciiLetter: () => isLowerAsciiLetter,
  isUpperAsciiLetter: () => isUpperAsciiLetter,
  joinStrings: () => joinStrings,
  lastNonWhitespaceIndex: () => lastNonWhitespaceIndex,
  lcut: () => lcut,
  ltrim: () => ltrim,
  multibyteAwareBtoa: () => multibyteAwareBtoa,
  nextCharLength: () => nextCharLength,
  noBreakWhitespace: () => noBreakWhitespace,
  prevCharLength: () => prevCharLength,
  regExpLeadsToEndlessLoop: () => regExpLeadsToEndlessLoop,
  removeAnsiEscapeCodes: () => removeAnsiEscapeCodes,
  removeAnsiEscapeCodesFromPrompt: () => removeAnsiEscapeCodesFromPrompt,
  replaceAsync: () => replaceAsync,
  rtrim: () => rtrim,
  singleLetterHash: () => singleLetterHash,
  splitLines: () => splitLines,
  splitLinesIncludeSeparators: () => splitLinesIncludeSeparators,
  startsWithIgnoreCase: () => startsWithIgnoreCase,
  startsWithUTF8BOM: () => startsWithUTF8BOM,
  stripUTF8BOM: () => stripUTF8BOM,
  trim: () => trim,
  truncate: () => truncate,
  truncateMiddle: () => truncateMiddle,
  uppercaseFirstLetter: () => uppercaseFirstLetter
});
function isFalsyOrWhitespace(str) {
  if (!str || typeof str !== "string") {
    return true;
  }
  return str.trim().length === 0;
}
function format3(value, ...args) {
  if (args.length === 0) {
    return value;
  }
  return value.replace(_formatRegexp, function(match3, group) {
    const idx = parseInt(group, 10);
    return isNaN(idx) || idx < 0 || idx >= args.length ? match3 : args[idx];
  });
}
function format22(template, values) {
  if (Object.keys(values).length === 0) {
    return template;
  }
  return template.replace(_format2Regexp2, (match3, group) => values[group] ?? match3);
}
function htmlAttributeEncodeValue(value) {
  return value.replace(/[<>"'&]/g, (ch) => {
    switch (ch) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "'":
        return "&apos;";
      case "&":
        return "&amp;";
    }
    return ch;
  });
}
function escape(html) {
  return html.replace(/[<>&]/g, function(match3) {
    switch (match3) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      default:
        return match3;
    }
  });
}
function escapeRegExpCharacters(value) {
  return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function count(value, substr) {
  let result = 0;
  let index = value.indexOf(substr);
  while (index !== -1) {
    result++;
    index = value.indexOf(substr, index + substr.length);
  }
  return result;
}
function truncate(value, maxLength, suffix = Ellipsis) {
  if (value.length <= maxLength) {
    return value;
  }
  return `${value.substr(0, maxLength)}${suffix}`;
}
function truncateMiddle(value, maxLength, suffix = Ellipsis) {
  if (value.length <= maxLength) {
    return value;
  }
  const prefixLength = Math.ceil(maxLength / 2) - suffix.length / 2;
  const suffixLength = Math.floor(maxLength / 2) - suffix.length / 2;
  return `${value.substr(0, prefixLength)}${suffix}${value.substr(value.length - suffixLength)}`;
}
function trim(haystack, needle = " ") {
  const trimmed = ltrim(haystack, needle);
  return rtrim(trimmed, needle);
}
function ltrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }
  const needleLen = needle.length;
  if (needleLen === 0 || haystack.length === 0) {
    return haystack;
  }
  let offset = 0;
  while (haystack.indexOf(needle, offset) === offset) {
    offset = offset + needleLen;
  }
  return haystack.substring(offset);
}
function rtrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }
  const needleLen = needle.length, haystackLen = haystack.length;
  if (needleLen === 0 || haystackLen === 0) {
    return haystack;
  }
  let offset = haystackLen, idx = -1;
  while (true) {
    idx = haystack.lastIndexOf(needle, offset - 1);
    if (idx === -1 || idx + needleLen !== offset) {
      break;
    }
    if (idx === 0) {
      return "";
    }
    offset = idx;
  }
  return haystack.substring(0, offset);
}
function convertSimple2RegExpPattern(pattern) {
  return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
}
function createRegExp(searchString, isRegex, options = {}) {
  if (!searchString) {
    throw new Error("Cannot create regex from empty string");
  }
  if (!isRegex) {
    searchString = escapeRegExpCharacters(searchString);
  }
  if (options.wholeWord) {
    if (!/\B/.test(searchString.charAt(0))) {
      searchString = "\\b" + searchString;
    }
    if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
      searchString = searchString + "\\b";
    }
  }
  let modifiers = "";
  if (options.global) {
    modifiers += "g";
  }
  if (!options.matchCase) {
    modifiers += "i";
  }
  if (options.multiline) {
    modifiers += "m";
  }
  if (options.unicode) {
    modifiers += "u";
  }
  return new RegExp(searchString, modifiers);
}
function regExpLeadsToEndlessLoop(regexp) {
  if (regexp.source === "^" || regexp.source === "^$" || regexp.source === "$" || regexp.source === "^\\s*$") {
    return false;
  }
  const match3 = regexp.exec("");
  return !!(match3 && regexp.lastIndex === 0);
}
function joinStrings(items, separator) {
  return items.filter((item) => item !== void 0 && item !== null && item !== false).join(separator);
}
function splitLines(str) {
  return str.split(/\r\n|\r|\n/);
}
function splitLinesIncludeSeparators(str) {
  const linesWithSeparators = [];
  const splitLinesAndSeparators = str.split(/(\r\n|\r|\n)/);
  for (let i = 0; i < Math.ceil(splitLinesAndSeparators.length / 2); i++) {
    linesWithSeparators.push(splitLinesAndSeparators[2 * i] + (splitLinesAndSeparators[2 * i + 1] ?? ""));
  }
  return linesWithSeparators;
}
function indexOfPattern(str, re) {
  const match3 = re.exec(str);
  if (match3) {
    return match3.index;
  }
  return -1;
}
function firstNonWhitespaceIndex(str) {
  for (let i = 0, len = str.length; i < len; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
      return i;
    }
  }
  return -1;
}
function getLeadingWhitespace(str, start = 0, end = str.length) {
  for (let i = start; i < end; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
      return str.substring(start, i);
    }
  }
  return str.substring(start, end);
}
function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
  for (let i = startIndex; i >= 0; i--) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
      return i;
    }
  }
  return -1;
}
function getIndentationLength(str) {
  const idx = firstNonWhitespaceIndex(str);
  if (idx === -1) {
    return str.length;
  }
  return idx;
}
function replaceAsync(str, search, replacer) {
  const parts = [];
  let last = 0;
  for (const match3 of str.matchAll(search)) {
    parts.push(str.slice(last, match3.index));
    if (match3.index === void 0) {
      throw new Error("match.index should be defined");
    }
    last = match3.index + match3[0].length;
    parts.push(replacer(match3[0], ...match3.slice(1), match3.index, str, match3.groups));
  }
  parts.push(str.slice(last));
  return Promise.all(parts).then((p) => p.join(""));
}
function compare(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}
function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    const codeA = a.charCodeAt(aStart);
    const codeB = b.charCodeAt(bStart);
    if (codeA < codeB) {
      return -1;
    } else if (codeA > codeB) {
      return 1;
    }
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function compareIgnoreCase(a, b) {
  return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);
}
function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    let codeA = a.charCodeAt(aStart);
    let codeB = b.charCodeAt(bStart);
    if (codeA === codeB) {
      continue;
    }
    if (codeA >= 128 || codeB >= 128) {
      return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);
    }
    if (isLowerAsciiLetter(codeA)) {
      codeA -= 32;
    }
    if (isLowerAsciiLetter(codeB)) {
      codeB -= 32;
    }
    const diff2 = codeA - codeB;
    if (diff2 === 0) {
      continue;
    }
    return diff2;
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function isAsciiDigit(code2) {
  return code2 >= 48 /* Digit0 */ && code2 <= 57 /* Digit9 */;
}
function isLowerAsciiLetter(code2) {
  return code2 >= 97 /* a */ && code2 <= 122 /* z */;
}
function isUpperAsciiLetter(code2) {
  return code2 >= 65 /* A */ && code2 <= 90 /* Z */;
}
function equalsIgnoreCase(a, b) {
  return a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;
}
function startsWithIgnoreCase(str, candidate) {
  const candidateLength = candidate.length;
  if (candidate.length > str.length) {
    return false;
  }
  return compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;
}
function commonPrefixLength(a, b) {
  const len = Math.min(a.length, b.length);
  let i;
  for (i = 0; i < len; i++) {
    if (a.charCodeAt(i) !== b.charCodeAt(i)) {
      return i;
    }
  }
  return len;
}
function commonSuffixLength(a, b) {
  const len = Math.min(a.length, b.length);
  let i;
  const aLastIndex = a.length - 1;
  const bLastIndex = b.length - 1;
  for (i = 0; i < len; i++) {
    if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
      return i;
    }
  }
  return len;
}
function isHighSurrogate(charCode) {
  return 55296 <= charCode && charCode <= 56319;
}
function isLowSurrogate(charCode) {
  return 56320 <= charCode && charCode <= 57343;
}
function computeCodePoint(highSurrogate, lowSurrogate) {
  return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
}
function getNextCodePoint(str, len, offset) {
  const charCode = str.charCodeAt(offset);
  if (isHighSurrogate(charCode) && offset + 1 < len) {
    const nextCharCode = str.charCodeAt(offset + 1);
    if (isLowSurrogate(nextCharCode)) {
      return computeCodePoint(charCode, nextCharCode);
    }
  }
  return charCode;
}
function getPrevCodePoint(str, offset) {
  const charCode = str.charCodeAt(offset - 1);
  if (isLowSurrogate(charCode) && offset > 1) {
    const prevCharCode = str.charCodeAt(offset - 2);
    if (isHighSurrogate(prevCharCode)) {
      return computeCodePoint(prevCharCode, charCode);
    }
  }
  return charCode;
}
function nextCharLength(str, initialOffset) {
  const iterator = new GraphemeIterator(str, initialOffset);
  return iterator.nextGraphemeLength();
}
function prevCharLength(str, initialOffset) {
  const iterator = new GraphemeIterator(str, initialOffset);
  return iterator.prevGraphemeLength();
}
function getCharContainingOffset(str, offset) {
  if (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {
    offset--;
  }
  const endOffset = offset + nextCharLength(str, offset);
  const startOffset = endOffset - prevCharLength(str, endOffset);
  return [startOffset, endOffset];
}
function charCount(str) {
  const iterator = new GraphemeIterator(str);
  let length = 0;
  while (!iterator.eol()) {
    length++;
    iterator.nextGraphemeLength();
  }
  return length;
}
function makeContainsRtl() {
  return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
}
function containsRTL(str) {
  if (!CONTAINS_RTL) {
    CONTAINS_RTL = makeContainsRtl();
  }
  return CONTAINS_RTL.test(str);
}
function isBasicASCII(str) {
  return IS_BASIC_ASCII.test(str);
}
function containsUnusualLineTerminators(str) {
  return UNUSUAL_LINE_TERMINATORS.test(str);
}
function isFullWidthCharacter(charCode) {
  return charCode >= 11904 && charCode <= 55215 || charCode >= 63744 && charCode <= 64255 || charCode >= 65281 && charCode <= 65374;
}
function isEmojiImprecise(x) {
  return x >= 127462 && x <= 127487 || x === 8986 || x === 8987 || x === 9200 || x === 9203 || x >= 9728 && x <= 10175 || x === 11088 || x === 11093 || x >= 127744 && x <= 128591 || x >= 128640 && x <= 128764 || x >= 128992 && x <= 129008 || x >= 129280 && x <= 129535 || x >= 129648 && x <= 129782;
}
function lcut(text2, n, prefix = "") {
  const trimmed = text2.trimStart();
  if (trimmed.length < n) {
    return trimmed;
  }
  const re = /\b/g;
  let i = 0;
  while (re.test(trimmed)) {
    if (trimmed.length - re.lastIndex < n) {
      break;
    }
    i = re.lastIndex;
    re.lastIndex += 1;
  }
  if (i === 0) {
    return trimmed;
  }
  return prefix + trimmed.substring(i).trimStart();
}
function* forAnsiStringParts(str) {
  let last = 0;
  for (const match3 of str.matchAll(CONTROL_SEQUENCES)) {
    if (last !== match3.index) {
      yield { isCode: false, str: str.substring(last, match3.index) };
    }
    yield { isCode: true, str: match3[0] };
    last = match3.index + match3[0].length;
  }
  if (last !== str.length) {
    yield { isCode: false, str: str.substring(last) };
  }
}
function removeAnsiEscapeCodes(str) {
  if (str) {
    str = str.replace(CONTROL_SEQUENCES, "");
  }
  return str;
}
function removeAnsiEscapeCodesFromPrompt(str) {
  return removeAnsiEscapeCodes(str).replace(PROMPT_NON_PRINTABLE, "");
}
function startsWithUTF8BOM(str) {
  return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);
}
function stripUTF8BOM(str) {
  return startsWithUTF8BOM(str) ? str.substr(1) : str;
}
function fuzzyContains(target, query) {
  if (!target || !query) {
    return false;
  }
  if (target.length < query.length) {
    return false;
  }
  const queryLen = query.length;
  const targetLower = target.toLowerCase();
  let index = 0;
  let lastIndexOf = -1;
  while (index < queryLen) {
    const indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);
    if (indexOf < 0) {
      return false;
    }
    lastIndexOf = indexOf;
    index++;
  }
  return true;
}
function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
  if (!target) {
    return false;
  }
  if (ignoreEscapedChars) {
    target = target.replace(/\\./g, "");
  }
  return target.toLowerCase() !== target;
}
function uppercaseFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function getNLines(str, n = 1) {
  if (n === 0) {
    return "";
  }
  let idx = -1;
  do {
    idx = str.indexOf("\n", idx + 1);
    n--;
  } while (n > 0 && idx >= 0);
  if (idx === -1) {
    return str;
  }
  if (str[idx - 1] === "\r") {
    idx--;
  }
  return str.substr(0, idx);
}
function singleLetterHash(n) {
  const LETTERS_CNT = 90 /* Z */ - 65 /* A */ + 1;
  n = n % (2 * LETTERS_CNT);
  if (n < LETTERS_CNT) {
    return String.fromCharCode(97 /* a */ + n);
  }
  return String.fromCharCode(65 /* A */ + n - LETTERS_CNT);
}
function getGraphemeBreakType(codePoint) {
  const graphemeBreakTree = GraphemeBreakTree.getInstance();
  return graphemeBreakTree.getGraphemeBreakType(codePoint);
}
function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
  if (breakTypeA === 0 /* Other */) {
    return breakTypeB !== 5 /* Extend */ && breakTypeB !== 7 /* SpacingMark */;
  }
  if (breakTypeA === 2 /* CR */) {
    if (breakTypeB === 3 /* LF */) {
      return false;
    }
  }
  if (breakTypeA === 4 /* Control */ || breakTypeA === 2 /* CR */ || breakTypeA === 3 /* LF */) {
    return true;
  }
  if (breakTypeB === 4 /* Control */ || breakTypeB === 2 /* CR */ || breakTypeB === 3 /* LF */) {
    return true;
  }
  if (breakTypeA === 8 /* L */) {
    if (breakTypeB === 8 /* L */ || breakTypeB === 9 /* V */ || breakTypeB === 11 /* LV */ || breakTypeB === 12 /* LVT */) {
      return false;
    }
  }
  if (breakTypeA === 11 /* LV */ || breakTypeA === 9 /* V */) {
    if (breakTypeB === 9 /* V */ || breakTypeB === 10 /* T */) {
      return false;
    }
  }
  if (breakTypeA === 12 /* LVT */ || breakTypeA === 10 /* T */) {
    if (breakTypeB === 10 /* T */) {
      return false;
    }
  }
  if (breakTypeB === 5 /* Extend */ || breakTypeB === 13 /* ZWJ */) {
    return false;
  }
  if (breakTypeB === 7 /* SpacingMark */) {
    return false;
  }
  if (breakTypeA === 1 /* Prepend */) {
    return false;
  }
  if (breakTypeA === 13 /* ZWJ */ && breakTypeB === 14 /* Extended_Pictographic */) {
    return false;
  }
  if (breakTypeA === 6 /* Regional_Indicator */ && breakTypeB === 6 /* Regional_Indicator */) {
    return false;
  }
  return true;
}
function getGraphemeBreakRawData() {
  return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
}
function getLeftDeleteOffset(offset, str) {
  if (offset === 0) {
    return 0;
  }
  const emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);
  if (emojiOffset !== void 0) {
    return emojiOffset;
  }
  const iterator = new CodePointIterator(str, offset);
  iterator.prevCodePoint();
  return iterator.offset;
}
function getOffsetBeforeLastEmojiComponent(initialOffset, str) {
  const iterator = new CodePointIterator(str, initialOffset);
  let codePoint = iterator.prevCodePoint();
  while (isEmojiModifier(codePoint) || codePoint === 65039 /* emojiVariantSelector */ || codePoint === 8419 /* enclosingKeyCap */) {
    if (iterator.offset === 0) {
      return void 0;
    }
    codePoint = iterator.prevCodePoint();
  }
  if (!isEmojiImprecise(codePoint)) {
    return void 0;
  }
  let resultOffset = iterator.offset;
  if (resultOffset > 0) {
    const optionalZwjCodePoint = iterator.prevCodePoint();
    if (optionalZwjCodePoint === 8205 /* zwj */) {
      resultOffset = iterator.offset;
    }
  }
  return resultOffset;
}
function isEmojiModifier(codePoint) {
  return 127995 <= codePoint && codePoint <= 127999;
}
function toBinary(str) {
  const codeUnits = new Uint16Array(str.length);
  for (let i = 0; i < codeUnits.length; i++) {
    codeUnits[i] = str.charCodeAt(i);
  }
  let binary = "";
  const uint8array = new Uint8Array(codeUnits.buffer);
  for (let i = 0; i < uint8array.length; i++) {
    binary += String.fromCharCode(uint8array[i]);
  }
  return binary;
}
function multibyteAwareBtoa(str) {
  return btoa(toBinary(str));
}
var _formatRegexp, _format2Regexp2, CodePointIterator, GraphemeIterator, CONTAINS_RTL, IS_BASIC_ASCII, UNUSUAL_LINE_TERMINATORS, CSI_SEQUENCE, OSC_SEQUENCE, ESC_SEQUENCE, CONTROL_SEQUENCES, PROMPT_NON_PRINTABLE, UTF8_BOM_CHARACTER, GraphemeBreakType, GraphemeBreakTree, noBreakWhitespace, AmbiguousCharacters, InvisibleCharacters, Ellipsis;
var init_strings = __esm({
  "src/util/vs/base/common/strings.ts"() {
    "use strict";
    init_cache();
    init_charCode();
    init_lazy();
    init_uint();
    _formatRegexp = /{(\d+)}/g;
    _format2Regexp2 = /{([^}]+)}/g;
    CodePointIterator = class {
      get offset() {
        return this._offset;
      }
      constructor(str, offset = 0) {
        this._str = str;
        this._len = str.length;
        this._offset = offset;
      }
      setOffset(offset) {
        this._offset = offset;
      }
      prevCodePoint() {
        const codePoint = getPrevCodePoint(this._str, this._offset);
        this._offset -= codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1;
        return codePoint;
      }
      nextCodePoint() {
        const codePoint = getNextCodePoint(this._str, this._len, this._offset);
        this._offset += codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1;
        return codePoint;
      }
      eol() {
        return this._offset >= this._len;
      }
    };
    GraphemeIterator = class {
      get offset() {
        return this._iterator.offset;
      }
      constructor(str, offset = 0) {
        this._iterator = new CodePointIterator(str, offset);
      }
      nextGraphemeLength() {
        const graphemeBreakTree = GraphemeBreakTree.getInstance();
        const iterator = this._iterator;
        const initialOffset = iterator.offset;
        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
        while (!iterator.eol()) {
          const offset = iterator.offset;
          const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
          if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
            iterator.setOffset(offset);
            break;
          }
          graphemeBreakType = nextGraphemeBreakType;
        }
        return iterator.offset - initialOffset;
      }
      prevGraphemeLength() {
        const graphemeBreakTree = GraphemeBreakTree.getInstance();
        const iterator = this._iterator;
        const initialOffset = iterator.offset;
        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
        while (iterator.offset > 0) {
          const offset = iterator.offset;
          const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
          if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
            iterator.setOffset(offset);
            break;
          }
          graphemeBreakType = prevGraphemeBreakType;
        }
        return initialOffset - iterator.offset;
      }
      eol() {
        return this._iterator.eol();
      }
    };
    CONTAINS_RTL = void 0;
    IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
    UNUSUAL_LINE_TERMINATORS = /[\u2028\u2029]/;
    CSI_SEQUENCE = /(?:\x1b\[|\x9b)[=?>!]?[\d;:]*["$#'* ]?[a-zA-Z@^`{}|~]/;
    OSC_SEQUENCE = /(?:\x1b\]|\x9d).*?(?:\x1b\\|\x07|\x9c)/;
    ESC_SEQUENCE = /\x1b(?:[ #%\(\)\*\+\-\.\/]?[a-zA-Z0-9\|}~@])/;
    CONTROL_SEQUENCES = new RegExp("(?:" + [
      CSI_SEQUENCE.source,
      OSC_SEQUENCE.source,
      ESC_SEQUENCE.source
    ].join("|") + ")", "g");
    PROMPT_NON_PRINTABLE = /\\\[.*?\\\]/g;
    UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);
    GraphemeBreakType = /* @__PURE__ */ ((GraphemeBreakType2) => {
      GraphemeBreakType2[GraphemeBreakType2["Other"] = 0] = "Other";
      GraphemeBreakType2[GraphemeBreakType2["Prepend"] = 1] = "Prepend";
      GraphemeBreakType2[GraphemeBreakType2["CR"] = 2] = "CR";
      GraphemeBreakType2[GraphemeBreakType2["LF"] = 3] = "LF";
      GraphemeBreakType2[GraphemeBreakType2["Control"] = 4] = "Control";
      GraphemeBreakType2[GraphemeBreakType2["Extend"] = 5] = "Extend";
      GraphemeBreakType2[GraphemeBreakType2["Regional_Indicator"] = 6] = "Regional_Indicator";
      GraphemeBreakType2[GraphemeBreakType2["SpacingMark"] = 7] = "SpacingMark";
      GraphemeBreakType2[GraphemeBreakType2["L"] = 8] = "L";
      GraphemeBreakType2[GraphemeBreakType2["V"] = 9] = "V";
      GraphemeBreakType2[GraphemeBreakType2["T"] = 10] = "T";
      GraphemeBreakType2[GraphemeBreakType2["LV"] = 11] = "LV";
      GraphemeBreakType2[GraphemeBreakType2["LVT"] = 12] = "LVT";
      GraphemeBreakType2[GraphemeBreakType2["ZWJ"] = 13] = "ZWJ";
      GraphemeBreakType2[GraphemeBreakType2["Extended_Pictographic"] = 14] = "Extended_Pictographic";
      return GraphemeBreakType2;
    })(GraphemeBreakType || {});
    GraphemeBreakTree = class _GraphemeBreakTree {
      static {
        this._INSTANCE = null;
      }
      static getInstance() {
        if (!_GraphemeBreakTree._INSTANCE) {
          _GraphemeBreakTree._INSTANCE = new _GraphemeBreakTree();
        }
        return _GraphemeBreakTree._INSTANCE;
      }
      constructor() {
        this._data = getGraphemeBreakRawData();
      }
      getGraphemeBreakType(codePoint) {
        if (codePoint < 32) {
          if (codePoint === 10 /* LineFeed */) {
            return 3 /* LF */;
          }
          if (codePoint === 13 /* CarriageReturn */) {
            return 2 /* CR */;
          }
          return 4 /* Control */;
        }
        if (codePoint < 127) {
          return 0 /* Other */;
        }
        const data = this._data;
        const nodeCount = data.length / 3;
        let nodeIndex = 1;
        while (nodeIndex <= nodeCount) {
          if (codePoint < data[3 * nodeIndex]) {
            nodeIndex = 2 * nodeIndex;
          } else if (codePoint > data[3 * nodeIndex + 1]) {
            nodeIndex = 2 * nodeIndex + 1;
          } else {
            return data[3 * nodeIndex + 2];
          }
        }
        return 0 /* Other */;
      }
    };
    noBreakWhitespace = "\xA0";
    AmbiguousCharacters = class _AmbiguousCharacters {
      constructor(confusableDictionary) {
        this.confusableDictionary = confusableDictionary;
      }
      static {
        this.ambiguousCharacterData = new Lazy(() => {
          return JSON.parse(
            '{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,1523,96,8242,96,1370,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,118002,50,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,118003,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,118004,52,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,118005,53,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,118006,54,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,118007,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,118008,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,118009,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,117974,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,117975,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71913,67,71922,67,65315,67,8557,67,8450,67,8493,67,117976,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,117977,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,117978,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,117979,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,117980,71,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,117981,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,117983,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,117984,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,118001,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,117982,108,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,117985,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,117986,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,117987,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,118000,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,117988,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,117989,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,117990,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,117991,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,117992,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,117993,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,117994,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,117995,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71910,87,71919,87,117996,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,117997,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,117998,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,71909,90,66293,90,65338,90,8484,90,8488,90,117999,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65283,35,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"cs":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"es":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"fr":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"it":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ja":[8211,45,8218,44,65281,33,8216,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65292,44,65297,49,65307,59],"ko":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pt-BR":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ru":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"zh-hans":[160,32,65374,126,8218,44,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65297,49],"zh-hant":[8211,45,65374,126,8218,44,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89]}'
          );
        });
      }
      static {
        this.cache = new LRUCachedFunction({ getCacheKey: JSON.stringify }, (locales) => {
          function arrayToMap(arr) {
            const result = /* @__PURE__ */ new Map();
            for (let i = 0; i < arr.length; i += 2) {
              result.set(arr[i], arr[i + 1]);
            }
            return result;
          }
          function mergeMaps(map1, map22) {
            const result = new Map(map1);
            for (const [key, value] of map22) {
              result.set(key, value);
            }
            return result;
          }
          function intersectMaps(map1, map22) {
            if (!map1) {
              return map22;
            }
            const result = /* @__PURE__ */ new Map();
            for (const [key, value] of map1) {
              if (map22.has(key)) {
                result.set(key, value);
              }
            }
            return result;
          }
          const data = this.ambiguousCharacterData.value;
          let filteredLocales = locales.filter(
            (l) => !l.startsWith("_") && l in data
          );
          if (filteredLocales.length === 0) {
            filteredLocales = ["_default"];
          }
          let languageSpecificMap = void 0;
          for (const locale of filteredLocales) {
            const map3 = arrayToMap(data[locale]);
            languageSpecificMap = intersectMaps(languageSpecificMap, map3);
          }
          const commonMap = arrayToMap(data["_common"]);
          const map2 = mergeMaps(commonMap, languageSpecificMap);
          return new _AmbiguousCharacters(map2);
        });
      }
      static getInstance(locales) {
        return _AmbiguousCharacters.cache.get(Array.from(locales));
      }
      static {
        this._locales = new Lazy(
          () => Object.keys(_AmbiguousCharacters.ambiguousCharacterData.value).filter(
            (k) => !k.startsWith("_")
          )
        );
      }
      static getLocales() {
        return _AmbiguousCharacters._locales.value;
      }
      isAmbiguous(codePoint) {
        return this.confusableDictionary.has(codePoint);
      }
      containsAmbiguousCharacter(str) {
        for (let i = 0; i < str.length; i++) {
          const codePoint = str.codePointAt(i);
          if (typeof codePoint === "number" && this.isAmbiguous(codePoint)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Returns the non basic ASCII code point that the given code point can be confused,
       * or undefined if such code point does note exist.
       */
      getPrimaryConfusable(codePoint) {
        return this.confusableDictionary.get(codePoint);
      }
      getConfusableCodePoints() {
        return new Set(this.confusableDictionary.keys());
      }
    };
    InvisibleCharacters = class _InvisibleCharacters {
      static getRawData() {
        return JSON.parse('{"_common":[11,12,13,127,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999],"cs":[173,8203,12288],"de":[173,8203,12288],"es":[8203,12288],"fr":[173,8203,12288],"it":[160,173,12288],"ja":[173],"ko":[173,12288],"pl":[173,8203,12288],"pt-BR":[173,8203,12288],"qps-ploc":[160,173,8203,12288],"ru":[173,12288],"tr":[160,173,8203,12288],"zh-hans":[160,173,8203,12288],"zh-hant":[173,12288]}');
      }
      static {
        this._data = void 0;
      }
      static getData() {
        if (!this._data) {
          this._data = new Set([...Object.values(_InvisibleCharacters.getRawData())].flat());
        }
        return this._data;
      }
      static isInvisibleCharacter(codePoint) {
        return _InvisibleCharacters.getData().has(codePoint);
      }
      static containsInvisibleCharacter(str) {
        for (let i = 0; i < str.length; i++) {
          const codePoint = str.codePointAt(i);
          if (typeof codePoint === "number" && (_InvisibleCharacters.isInvisibleCharacter(codePoint) || codePoint === 32 /* space */)) {
            return true;
          }
        }
        return false;
      }
      static get codePoints() {
        return _InvisibleCharacters.getData();
      }
    };
    Ellipsis = "\u2026";
  }
});

// package.json
var require_package = __commonJS({
  "package.json"(exports, module2) {
    module2.exports = {
      name: "puku-editor",
      displayName: "Puku Editor",
      description: "AI-powered code editor with GLM model support via Z.AI",
      version: "0.43.32",
      build: "1",
      internalAIKey: "1058ec22-3c95-4951-8443-f26c1f325911",
      completionsCoreVersion: "1.378.1799",
      internalLargeStorageAriaKey: "ec712b3202c5462fb6877acae7f1f9d7-c19ad55e-3e3c-4f99-984b-827f6d95bd9e-6917",
      ariaKey: "0c6ae279ed8443289764825290e4f9e2-1a736e7c-1324-4338-be46-fc2a58ae4d14-7255",
      buildType: "dev",
      publisher: "GitHub",
      homepage: "https://github.com/features/copilot?editor=vscode",
      license: "SEE LICENSE IN LICENSE.txt",
      repository: {
        type: "git",
        url: "https://github.com/microsoft/vscode-copilot-chat"
      },
      bugs: {
        url: "https://github.com/microsoft/vscode/issues"
      },
      qna: "https://github.com/github-community/community/discussions/categories/copilot",
      icon: "assets/copilot.png",
      pricing: "Trial",
      engines: {
        vscode: "^1.107.0",
        npm: ">=9.0.0",
        node: ">=22.14.0"
      },
      categories: [
        "AI",
        "Chat",
        "Programming Languages",
        "Machine Learning"
      ],
      keywords: [
        "ai",
        "openai",
        "codex",
        "pilot",
        "snippets",
        "documentation",
        "autocomplete",
        "intellisense",
        "refactor",
        "javascript",
        "python",
        "typescript",
        "php",
        "go",
        "golang",
        "ruby",
        "c++",
        "c#",
        "java",
        "kotlin",
        "co-pilot"
      ],
      badges: [
        {
          url: "https://img.shields.io/badge/GitHub%20Copilot-Subscription%20Required-orange",
          href: "https://github.com/github-copilot/signup?editor=vscode",
          description: "%puku.badge.signUp%"
        },
        {
          url: "https://img.shields.io/github/stars/github/copilot-docs?style=social",
          href: "https://github.com/github/copilot-docs",
          description: "%puku.badge.star%"
        },
        {
          url: "https://img.shields.io/youtube/channel/views/UC7c3Kb6jYCRj4JOHHZTxKsQ?style=social",
          href: "https://www.youtube.com/@GitHub/search?query=copilot",
          description: "%puku.badge.youtube%"
        },
        {
          url: "https://img.shields.io/twitter/follow/github?style=social",
          href: "https://twitter.com/github",
          description: "%puku.badge.twitter%"
        }
      ],
      activationEvents: [
        "onStartupFinished",
        "onLanguageModelChat:copilot",
        "onUri",
        "onFileSystem:ccreq",
        "onFileSystem:ccsettings"
      ],
      main: "./dist/extension",
      l10n: "./l10n",
      enabledApiProposals: [
        "extensionsAny",
        "newSymbolNamesProvider",
        "interactive",
        "codeActionAI",
        "activeComment",
        "commentReveal",
        "contribCommentThreadAdditionalMenu",
        "contribCommentsViewThreadMenus",
        "documentFiltersExclusive",
        "embeddings",
        "findTextInFiles",
        "findTextInFiles2",
        "findFiles2@2",
        "textSearchProvider",
        "terminalDataWriteEvent",
        "terminalExecuteCommandEvent",
        "terminalSelection",
        "terminalQuickFixProvider",
        "mappedEditsProvider",
        "aiRelatedInformation",
        "aiSettingsSearch",
        "chatParticipantAdditions",
        "chatEditing",
        "defaultChatParticipant@4",
        "contribSourceControlInputBoxMenu",
        "authLearnMore",
        "testObserver",
        "aiTextSearchProvider@2",
        "chatParticipantPrivate@11",
        "chatProvider@4",
        "contribDebugCreateConfiguration",
        "chatReferenceDiagnostic",
        "textSearchProvider2",
        "chatReferenceBinaryData",
        "languageModelSystem",
        "languageModelCapabilities",
        "inlineCompletionsAdditions",
        "chatStatusItem",
        "taskProblemMatcherStatus",
        "contribLanguageModelToolSets",
        "textDocumentChangeReason",
        "resolvers",
        "taskExecutionTerminal",
        "dataChannels",
        "languageModelThinkingPart",
        "chatSessionsProvider@3",
        "devDeviceId",
        "contribEditorContentMenu"
      ],
      contributes: {
        authenticationProviders: [
          {
            id: "puku",
            label: "Puku"
          }
        ],
        languageModelTools: [
          {
            name: "puku_searchCodebase",
            toolReferenceName: "codebase",
            displayName: "%puku.tools.searchCodebase.name%",
            icon: "$(folder)",
            userDescription: "%puku.codebase.tool.description%",
            modelDescription: "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
            tags: [
              "codesearch",
              "vscode_codesearch"
            ],
            inputSchema: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                }
              },
              required: [
                "query"
              ]
            }
          },
          {
            name: "puku_searchWorkspaceSymbols",
            toolReferenceName: "symbols",
            displayName: "%puku.tools.searchWorkspaceSymbols.name%",
            icon: "$(symbol)",
            userDescription: "%puku.workspaceSymbols.tool.description%",
            modelDescription: "Search the user's workspace for code symbols using language services. Use this tool when the user is looking for a specific symbol in their workspace.",
            tags: [
              "vscode_codesearch"
            ],
            inputSchema: {
              type: "object",
              properties: {
                symbolName: {
                  type: "string",
                  description: "The symbol to search for, such as a function name, class name, or variable name."
                }
              },
              required: [
                "symbolName"
              ]
            }
          },
          {
            name: "puku_listCodeUsages",
            toolReferenceName: "usages",
            displayName: "%puku.tools.listCodeUsages.name%",
            icon: "$(references)",
            canBeReferencedInPrompt: true,
            userDescription: "%puku.listCodeUsages.tool.description%",
            modelDescription: "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
            tags: [
              "vscode_codesearch"
            ],
            inputSchema: {
              type: "object",
              properties: {
                symbolName: {
                  type: "string",
                  description: "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                },
                filePaths: {
                  type: "array",
                  description: "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                  items: {
                    type: "string"
                  }
                }
              },
              required: [
                "symbolName"
              ]
            }
          },
          {
            name: "puku_getVSCodeAPI",
            toolReferenceName: "vscodeAPI",
            displayName: "%puku.tools.getVSCodeAPI.name%",
            icon: "$(references)",
            userDescription: "%puku.vscode.tool.description%",
            modelDescription: "Get comprehensive VS Code API documentation and references for extension development. This tool provides authoritative documentation for VS Code's extensive API surface, including proposed APIs, contribution points, and best practices. Use this tool for understanding complex VS Code API interactions.\n\nWhen to use this tool:\n- User asks about specific VS Code APIs, interfaces, or extension capabilities\n- Need documentation for VS Code extension contribution points (commands, views, settings, etc.)\n- Questions about proposed APIs and their usage patterns\n- Understanding VS Code extension lifecycle, activation events, and packaging\n- Best practices for VS Code extension development architecture\n- API examples and code patterns for extension features\n- Troubleshooting extension-specific issues or API limitations\n\nWhen NOT to use this tool:\n- Creating simple standalone files or scripts unrelated to VS Code extensions\n- General programming questions not specific to VS Code extension development\n- Questions about using VS Code as an editor (user-facing features)\n- Non-extension related development tasks\n- File creation or editing that doesn't involve VS Code extension APIs\n\nCRITICAL usage guidelines:\n1. Always include specific API names, interfaces, or concepts in your query\n2. Mention the extension feature you're trying to implement\n3. Include context about proposed vs stable APIs when relevant\n4. Reference specific contribution points when asking about extension manifest\n5. Be specific about the VS Code version or API version when known\n\nScope: This tool is for EXTENSION DEVELOPMENT ONLY - building tools that extend VS Code itself, not for general file creation or non-extension programming tasks.",
            inputSchema: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "The query to search vscode documentation for. Should contain all relevant context."
                }
              },
              required: [
                "query"
              ]
            },
            tags: [],
            canBeReferencedInPrompt: true
          },
          {
            name: "puku_findFiles",
            toolReferenceName: "fileSearch",
            displayName: "%puku.tools.findFiles.name%",
            modelDescription: "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
            tags: [
              "vscode_codesearch"
            ],
            inputSchema: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "Search for files with names or paths matching this glob pattern."
                },
                maxResults: {
                  type: "number",
                  description: "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                }
              },
              required: [
                "query"
              ]
            }
          },
          {
            name: "puku_findTextInFiles",
            toolReferenceName: "textSearch",
            displayName: "%puku.tools.findTextInFiles.name%",
            modelDescription: "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
            tags: [
              "vscode_codesearch"
            ],
            inputSchema: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                },
                isRegexp: {
                  type: "boolean",
                  description: "Whether the pattern is a regex."
                },
                includePattern: {
                  type: "string",
                  description: 'Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like "src/folder/**". Do not use | in includePattern.'
                },
                maxResults: {
                  type: "number",
                  description: "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                }
              },
              required: [
                "query",
                "isRegexp"
              ]
            }
          },
          {
            name: "puku_applyPatch",
            displayName: "%puku.tools.applyPatch.name%",
            toolReferenceName: "applyPatch",
            userDescription: "%puku.tools.applyPatch.description%",
            modelDescription: 'Edit text files. Do not use this tool to edit Jupyter notebooks. `apply_patch` allows you to execute a diff/patch against a text file, but the format of the diff specification is unique to this task, so pay careful attention to these instructions. To use the `apply_patch` command, you should pass a message of the following structure as "input":\n\n*** Begin Patch\n[YOUR_PATCH]\n*** End Patch\n\nWhere [YOUR_PATCH] is the actual content of your patch, specified in the following V4A diff format.\n\n*** [ACTION] File: [/absolute/path/to/file] -> ACTION can be one of Add, Update, or Delete.\nAn example of a message that you might pass as "input" to this function, in order to apply a patch, is shown below.\n\n*** Begin Patch\n*** Update File: /Users/someone/pygorithm/searching/binary_search.py\n@@class BaseClass\n@@    def search():\n-        pass\n+        raise NotImplementedError()\n\n@@class Subclass\n@@    def search():\n-        pass\n+        raise NotImplementedError()\n\n*** End Patch\nDo not use line numbers in this diff format.',
            inputSchema: {
              type: "object",
              properties: {
                input: {
                  type: "string",
                  description: "The edit patch to apply."
                },
                explanation: {
                  type: "string",
                  description: "A short description of what the tool call is aiming to achieve."
                }
              },
              required: [
                "input",
                "explanation"
              ]
            }
          },
          {
            name: "puku_readFile",
            toolReferenceName: "readFile",
            displayName: "%puku.tools.readFile.name%",
            modelDescription: "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
            tags: [
              "vscode_codesearch"
            ],
            inputSchema: {
              type: "object",
              properties: {
                filePath: {
                  description: "The absolute path of the file to read.",
                  type: "string"
                },
                startLine: {
                  type: "number",
                  description: "The line number to start reading from, 1-based."
                },
                endLine: {
                  type: "number",
                  description: "The inclusive line number to end reading at, 1-based."
                }
              },
              required: [
                "filePath",
                "startLine",
                "endLine"
              ]
            }
          },
          {
            name: "puku_listDirectory",
            toolReferenceName: "listDirectory",
            displayName: "%puku.tools.listDirectory.name%",
            modelDescription: "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
            tags: [
              "vscode_codesearch"
            ],
            inputSchema: {
              type: "object",
              properties: {
                path: {
                  type: "string",
                  description: "The absolute path to the directory to list."
                }
              },
              required: [
                "path"
              ]
            }
          },
          {
            name: "puku_getErrors",
            displayName: "%puku.tools.getErrors.name%",
            toolReferenceName: "problems",
            canBeReferencedInPrompt: true,
            icon: "$(error)",
            userDescription: "%puku.tools.errors.description%",
            modelDescription: "Get any compile or lint errors in a specific file or across all files. If the user mentions errors or problems in a file, they may be referring to these. Use the tool to see the same errors that the user is seeing. If the user asks you to analyze all errors, or does not specify a file, use this tool to gather errors for all files. Also use this tool after editing a file to validate the change.",
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                filePaths: {
                  description: "The absolute paths to the files or folders to check for errors. Omit 'filePaths' when retrieving all errors.",
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          },
          {
            name: "puku_readProjectStructure",
            displayName: "%puku.tools.readProjectStructure.name%",
            modelDescription: "Get a file tree representation of the workspace.",
            tags: []
          },
          {
            name: "puku_getChangedFiles",
            displayName: "%puku.tools.getChangedFiles.name%",
            toolReferenceName: "changes",
            icon: "$(diff)",
            canBeReferencedInPrompt: true,
            userDescription: "%puku.tools.changes.description%",
            modelDescription: "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
            tags: [
              "vscode_codesearch"
            ],
            inputSchema: {
              type: "object",
              properties: {
                repositoryPath: {
                  type: "string",
                  description: "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                },
                sourceControlState: {
                  type: "array",
                  items: {
                    type: "string",
                    enum: [
                      "staged",
                      "unstaged",
                      "merge-conflicts"
                    ]
                  },
                  description: "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                }
              }
            }
          },
          {
            name: "puku_testFailure",
            toolReferenceName: "testFailure",
            displayName: "%puku.tools.testFailure.name%",
            icon: "$(beaker)",
            userDescription: "%puku.testFailure.tool.description%",
            modelDescription: "Includes test failure information in the prompt.",
            inputSchema: {},
            tags: [
              "vscode_editing_with_tests",
              "enable_other_tool_copilot_readFile",
              "enable_other_tool_copilot_listDirectory",
              "enable_other_tool_copilot_findFiles",
              "enable_other_tool_copilot_runTests"
            ],
            canBeReferencedInPrompt: true
          },
          {
            name: "puku_updateUserPreferences",
            toolReferenceName: "updateUserPreferences",
            displayName: "%puku.tools.updateUserPreferences.name%",
            modelDescription: "Update the user's preferences file with new information about the user and their coding preferences, based on the current chat history.",
            canBeReferencedInPrompt: true,
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                facts: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "An array of new user preferences to remember."
                }
              },
              required: [
                "facts"
              ]
            },
            when: "config.puku.chat.enableUserPreferences"
          },
          {
            name: "puku_createNewWorkspace",
            displayName: "%puku.tools.createNewWorkspace.name%",
            toolReferenceName: "newWorkspace",
            icon: "$(new-folder)",
            userDescription: "%puku.tools.createNewWorkspace.userDescription%",
            when: "config.puku.chat.newWorkspaceCreation.enabled",
            modelDescription: 'Get comprehensive setup steps to help the user create complete project structures in a VS Code workspace. This tool is designed for full project initialization and scaffolding, not for creating individual files.\n\nWhen to use this tool:\n- User wants to create a new complete project from scratch\n- Setting up entire project frameworks (TypeScript projects, React apps, Node.js servers, etc.)\n- Initializing Model Context Protocol (MCP) servers with full structure\n- Creating VS Code extensions with proper scaffolding\n- Setting up Next.js, Vite, or other framework-based projects\n- User asks for "new project", "create a workspace", "set up a [framework] project"\n- Need to establish complete development environment with dependencies, config files, and folder structure\n\nWhen NOT to use this tool:\n- Creating single files or small code snippets\n- Adding individual files to existing projects\n- Making modifications to existing codebases\n- User asks to "create a file" or "add a component"\n- Simple code examples or demonstrations\n- Debugging or fixing existing code\n\nThis tool provides complete project setup including:\n- Folder structure creation\n- Package.json and dependency management\n- Configuration files (tsconfig, eslint, etc.)\n- Initial boilerplate code\n- Development environment setup\n- Build and run instructions\n\nUse other file creation tools for individual files within existing projects.',
            inputSchema: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "The query to use to generate the new workspace. This should be a clear and concise description of the workspace the user wants to create."
                }
              },
              required: [
                "query"
              ]
            },
            tags: [
              "enable_other_tool_install_extension",
              "enable_other_tool_get_project_setup_info"
            ]
          },
          {
            name: "puku_getProjectSetupInfo",
            displayName: "%puku.tools.getProjectSetupInfo.name%",
            when: "config.puku.chat.newWorkspaceCreation.enabled",
            toolReferenceName: "getProjectSetupInfo",
            modelDescription: "Do not call this tool without first calling the tool to create a workspace. This tool provides a project setup information for a Visual Studio Code workspace based on a project type and programming language.",
            inputSchema: {
              type: "object",
              properties: {
                projectType: {
                  type: "string",
                  description: "The type of project to create. Supported values are: 'python-script', 'python-project', 'mcp-server', 'model-context-protocol-server', 'vscode-extension', 'next-js', 'vite' and 'other'"
                }
              },
              required: [
                "projectType"
              ]
            },
            tags: []
          },
          {
            name: "puku_installExtension",
            displayName: "Install Extension in VS Code",
            when: "config.puku.chat.newWorkspaceCreation.enabled",
            toolReferenceName: "installExtension",
            modelDescription: "Install an extension in VS Code. Use this tool to install an extension in Visual Studio Code as part of a new workspace creation process only.",
            inputSchema: {
              type: "object",
              properties: {
                id: {
                  type: "string",
                  description: "The ID of the extension to install. This should be in the format <publisher>.<extension>."
                },
                name: {
                  type: "string",
                  description: "The name of the extension to install. This should be a clear and concise description of the extension."
                }
              },
              required: [
                "id",
                "name"
              ]
            },
            tags: []
          },
          {
            name: "puku_runVscodeCommand",
            displayName: "Run VS Code Command",
            when: "config.puku.chat.newWorkspaceCreation.enabled",
            toolReferenceName: "runVscodeCommand",
            modelDescription: "Run a command in VS Code. Use this tool to run a command in Visual Studio Code as part of a new workspace creation process only.",
            inputSchema: {
              type: "object",
              properties: {
                commandId: {
                  type: "string",
                  description: "The ID of the command to execute. This should be in the format <command>."
                },
                name: {
                  type: "string",
                  description: "The name of the command to execute. This should be a clear and concise description of the command."
                },
                args: {
                  type: "array",
                  description: "The arguments to pass to the command. This should be an array of strings.",
                  items: {
                    type: "string"
                  }
                }
              },
              required: [
                "commandId",
                "name"
              ]
            },
            tags: []
          },
          {
            name: "puku_createNewJupyterNotebook",
            displayName: "Create New Jupyter Notebook",
            icon: "$(notebook)",
            toolReferenceName: "newJupyterNotebook",
            modelDescription: "Generates a new Jupyter Notebook (.ipynb) in VS Code. Jupyter Notebooks are interactive documents commonly used for data exploration, analysis, visualization, and combining code with narrative text. Prefer creating plain Python files or similar unless a user explicitly requests creating a new Jupyter Notebook or already has a Jupyter Notebook opened or exists in the workspace.",
            userDescription: "%puku.tools.newJupyterNotebook.description%",
            inputSchema: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "The query to use to generate the jupyter notebook. This should be a clear and concise description of the notebook the user wants to create."
                }
              },
              required: [
                "query"
              ]
            },
            tags: []
          },
          {
            name: "puku_insertEdit",
            toolReferenceName: "insertEdit",
            displayName: "%puku.tools.insertEdit.name%",
            modelDescription: 'Insert new code into an existing file in the workspace. Use this tool once per file that needs to be modified, even if there are multiple changes for a file. Generate the "explanation" property first.\nThe system is very smart and can understand how to apply your edits to the files, you just need to provide minimal hints.\nAvoid repeating existing code, instead use comments to represent regions of unchanged code. Be as concise as possible. For example:\n// ...existing code...\n{ changed code }\n// ...existing code...\n{ changed code }\n// ...existing code...\n\nHere is an example of how you should use format an edit to an existing Person class:\nclass Person {\n	// ...existing code...\n	age: number;\n	// ...existing code...\n	getAge() {\n	return this.age;\n	}\n}',
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                explanation: {
                  type: "string",
                  description: "A short explanation of the edit being made."
                },
                filePath: {
                  type: "string",
                  description: "An absolute path to the file to edit."
                },
                code: {
                  type: "string",
                  description: "The code change to apply to the file.\nThe system is very smart and can understand how to apply your edits to the files, you just need to provide minimal hints.\nAvoid repeating existing code, instead use comments to represent regions of unchanged code. Be as concise as possible. For example:\n// ...existing code...\n{ changed code }\n// ...existing code...\n{ changed code }\n// ...existing code...\n\nHere is an example of how you should use format an edit to an existing Person class:\nclass Person {\n	// ...existing code...\n	age: number;\n	// ...existing code...\n	getAge() {\n		return this.age;\n	}\n}"
                }
              },
              required: [
                "explanation",
                "filePath",
                "code"
              ]
            }
          },
          {
            name: "puku_createFile",
            toolReferenceName: "createFile",
            displayName: "%puku.tools.createFile.name%",
            userDescription: "%puku.tools.createFile.description%",
            modelDescription: "This is a tool for creating a new file in the workspace. The file will be created with the specified content. The directory will be created if it does not already exist. Never use this tool to edit a file that already exists.",
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                filePath: {
                  type: "string",
                  description: "The absolute path to the file to create."
                },
                content: {
                  type: "string",
                  description: "The content to write to the file."
                }
              },
              required: [
                "filePath",
                "content"
              ]
            }
          },
          {
            name: "puku_createDirectory",
            toolReferenceName: "createDirectory",
            displayName: "%puku.tools.createDirectory.name%",
            userDescription: "%puku.tools.createDirectory.description%",
            modelDescription: "Create a new directory structure in the workspace. Will recursively create all directories in the path, like mkdir -p. You do not need to use this tool before using create_file, that tool will automatically create the needed directories.",
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                dirPath: {
                  type: "string",
                  description: "The absolute path to the directory to create."
                }
              },
              required: [
                "dirPath"
              ]
            }
          },
          {
            name: "puku_openSimpleBrowser",
            displayName: "%puku.tools.openSimpleBrowser.name%",
            modelDescription: "Preview a website or open a URL in the editor's Simple Browser. Useful for quickly viewing locally hosted websites, demos, or resources without leaving the coding environment.",
            userDescription: "%puku.tools.openSimpleBrowser.description%",
            toolReferenceName: "openSimpleBrowser",
            canBeReferencedInPrompt: true,
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "The website URL to preview or open in the Simple Browser inside the editor. Must be either an http or https URL"
                }
              },
              required: [
                "url"
              ]
            }
          },
          {
            name: "puku_replaceString",
            toolReferenceName: "replaceString",
            displayName: "%puku.tools.replaceString.name%",
            modelDescription: "This is a tool for making edits in an existing file in the workspace. For moving or renaming files, use run in terminal tool with the 'mv' command instead. For larger edits, split them into smaller edits and call the edit tool multiple times to ensure accuracy. Before editing, always ensure you have the context to understand the file's contents and context. To edit a file, provide: 1) filePath (absolute path), 2) oldString (MUST be the exact literal text to replace including all whitespace, indentation, newlines, and surrounding code etc), and 3) newString (MUST be the exact literal text to replace \\`oldString\\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.). Each use of this tool replaces exactly ONE occurrence of oldString.\n\nCRITICAL for \\`oldString\\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail. Never use 'Lines 123-456 omitted' from summarized documents or ...existing code... comments in the oldString or newString.",
            when: "!config.puku.chat.disableReplaceTool",
            inputSchema: {
              type: "object",
              properties: {
                filePath: {
                  type: "string",
                  description: "An absolute path to the file to edit."
                },
                oldString: {
                  type: "string",
                  description: "The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. For multiple replacements, specify expected_replacements parameter. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail."
                },
                newString: {
                  type: "string",
                  description: "The exact literal text to replace `old_string` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                }
              },
              required: [
                "filePath",
                "oldString",
                "newString"
              ]
            }
          },
          {
            name: "puku_multiReplaceString",
            toolReferenceName: "multiReplaceString",
            displayName: "%puku.tools.multiReplaceString.name%",
            modelDescription: "This tool allows you to apply multiple replace_string_in_file operations in a single call, which is more efficient than calling replace_string_in_file multiple times. It takes an array of replacement operations and applies them sequentially. Each replacement operation has the same parameters as replace_string_in_file: filePath, oldString, newString, and explanation. This tool is ideal when you need to make multiple edits across different files or multiple edits in the same file. The tool will provide a summary of successful and failed operations.",
            when: "!config.puku.chat.disableReplaceTool",
            inputSchema: {
              type: "object",
              properties: {
                explanation: {
                  type: "string",
                  description: "A brief explanation of what the multi-replace operation will accomplish."
                },
                replacements: {
                  type: "array",
                  description: "An array of replacement operations to apply sequentially.",
                  items: {
                    type: "object",
                    properties: {
                      explanation: {
                        type: "string",
                        description: "A brief explanation of this specific replacement operation."
                      },
                      filePath: {
                        type: "string",
                        description: "An absolute path to the file to edit."
                      },
                      oldString: {
                        type: "string",
                        description: "The exact literal text to replace, preferably unescaped. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text or does not match exactly, this replacement will fail."
                      },
                      newString: {
                        type: "string",
                        description: "The exact literal text to replace `oldString` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                      }
                    },
                    required: [
                      "explanation",
                      "filePath",
                      "oldString",
                      "newString"
                    ]
                  },
                  minItems: 1
                }
              },
              required: [
                "explanation",
                "replacements"
              ]
            }
          },
          {
            name: "puku_editNotebook",
            toolReferenceName: "editNotebook",
            displayName: "%puku.tools.editNotebook.name%",
            modelDescription: 'This is a tool for editing an existing Notebook file in the workspace. Generate the "explanation" property first.\nThe system is very smart and can understand how to apply your edits to the notebooks.\nWhen updating the content of an existing cell, ensure newCode preserves whitespace and indentation exactly and does NOT include any code markers such as (...existing code...).',
            tags: [
              "enable_other_tool_copilot_getNotebookSummary"
            ],
            inputSchema: {
              type: "object",
              properties: {
                filePath: {
                  type: "string",
                  description: "An absolute path to the notebook file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1."
                },
                cellId: {
                  type: "string",
                  description: "Id of the cell that needs to be deleted or edited. Use the value `TOP`, `BOTTOM` when inserting a cell at the top or bottom of the notebook, else provide the id of the cell after which a new cell is to be inserted. Remember, if a cellId is provided and editType=insert, then a cell will be inserted after the cell with the provided cellId."
                },
                newCode: {
                  anyOf: [
                    {
                      type: "string",
                      description: "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags. Do NOT include code markers such as (...existing code...) to indicate existing code."
                    },
                    {
                      type: "array",
                      items: {
                        type: "string",
                        description: "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags"
                      }
                    }
                  ]
                },
                language: {
                  type: "string",
                  description: "The language of the cell. `markdown`, `python`, `javascript`, `julia`, etc."
                },
                editType: {
                  type: "string",
                  enum: [
                    "insert",
                    "delete",
                    "edit"
                  ],
                  description: "The operation peformed on the cell, whether `insert`, `delete` or `edit`.\nUse the `editType` field to specify the operation: `insert` to add a new cell, `edit` to modify an existing cell's content, and `delete` to remove a cell."
                }
              },
              required: [
                "filePath",
                "editType",
                "cellId"
              ]
            }
          },
          {
            name: "puku_runNotebookCell",
            displayName: "%puku.tools.runNotebookCell.name%",
            toolReferenceName: "runCell",
            icon: "$(play)",
            modelDescription: "This is a tool for running a code cell in a notebook file directly in the notebook editor. The output from the execution will be returned. Code cells should be run as they are added or edited when working through a problem to bring the kernel state up to date and ensure the code executes successfully. Code cells are ready to run and don't require any pre-processing. If asked to run the first cell in a notebook, you should run the first code cell since markdown cells cannot be executed. NOTE: Avoid executing Markdown cells or providing Markdown cell IDs, as Markdown cells cannot be  executed.",
            userDescription: "%puku.tools.runNotebookCell.description%",
            tags: [
              "enable_other_tool_copilot_getNotebookSummary"
            ],
            inputSchema: {
              type: "object",
              properties: {
                filePath: {
                  type: "string",
                  description: "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                },
                reason: {
                  type: "string",
                  description: "An optional explanation of why the cell is being run. This will be shown to the user before the tool is run and is not necessary if it's self-explanatory."
                },
                cellId: {
                  type: "string",
                  description: "The ID for the code cell to execute. Avoid providing markdown cell IDs as nothing will be executed."
                },
                continueOnError: {
                  type: "boolean",
                  description: "Whether or not execution should continue for remaining cells if an error is encountered. Default to false unless instructed otherwise."
                }
              },
              required: [
                "filePath",
                "cellId"
              ]
            }
          },
          {
            name: "puku_getNotebookSummary",
            toolReferenceName: "getNotebookSummary",
            displayName: "Get the structure of a notebook",
            modelDescription: "This is a tool returns the list of the Notebook cells along with the id, cell types, line ranges, language, execution information and output mime types for each cell. This is useful to get Cell Ids when executing a notebook or determine what cells have been executed and what order, or what cells have outputs. If required to read contents of a cell use this to determine the line range of a cells, and then use read_file tool to read a specific line range. Requery this tool if the contents of the notebook change.",
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                filePath: {
                  type: "string",
                  description: "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                }
              },
              required: [
                "filePath"
              ]
            }
          },
          {
            name: "puku_readNotebookCellOutput",
            displayName: "%puku.tools.getNotebookCellOutput.name%",
            toolReferenceName: "readNotebookCellOutput",
            icon: "$(notebook-render-output)",
            modelDescription: "This tool will retrieve the output for a notebook cell from its most recent execution or restored from disk. The cell may have output even when it has not been run in the current kernel session. This tool has a higher token limit for output length than the runNotebookCell tool.",
            userDescription: "%puku.tools.getNotebookCellOutput.description%",
            when: "userHasOpenedNotebook",
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                filePath: {
                  type: "string",
                  description: "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                },
                cellId: {
                  type: "string",
                  description: "The ID of the cell for which output should be retrieved."
                }
              },
              required: [
                "filePath",
                "cellId"
              ]
            }
          },
          {
            name: "puku_fetchWebPage",
            displayName: "%puku.tools.fetchWebPage.name%",
            toolReferenceName: "fetch",
            when: "!isWeb",
            canBeReferencedInPrompt: true,
            icon: "$(globe)",
            userDescription: "%puku.tools.fetchWebPage.description%",
            modelDescription: "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                urls: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "An array of URLs to fetch content from."
                },
                query: {
                  type: "string",
                  description: "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                }
              },
              required: [
                "urls",
                "query"
              ]
            }
          },
          {
            name: "puku_findTestFiles",
            displayName: "%puku.tools.findTestFiles.name%",
            icon: "$(beaker)",
            canBeReferencedInPrompt: false,
            toolReferenceName: "findTestFiles",
            userDescription: "%puku.tools.findTestFiles.description%",
            modelDescription: "For a source code file, find the file that contains the tests. For a test file find the file that contains the code under test.",
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                filePaths: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              },
              required: [
                "filePaths"
              ]
            }
          },
          {
            name: "puku_getDocInfo",
            displayName: "%puku.tools.getDocInfo.name%",
            icon: "$(beaker)",
            canBeReferencedInPrompt: false,
            toolReferenceName: "docInfo",
            userDescription: "%puku.tools.getDocInfo.description%",
            modelDescription: "Find information about how to document it a symbol like a class or function. This tool is useful for generating documentation comments for code symbols. You should use this tool when you think the user is looking for information about how to document a specific code symbol.",
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                filePaths: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "The file paths for which documentation information is needed."
                }
              },
              required: [
                "filePaths"
              ]
            }
          },
          {
            name: "puku_getSearchResults",
            toolReferenceName: "searchResults",
            displayName: "%puku.tools.searchResults.name%",
            icon: "$(search)",
            userDescription: "%puku.tools.searchResults.description%",
            modelDescription: "The results from the search view"
          },
          {
            name: "puku_githubRepo",
            toolReferenceName: "githubRepo",
            displayName: "%puku.tools.githubRepo.name%",
            modelDescription: "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
            userDescription: "%puku.tools.githubRepo.userDescription%",
            icon: "$(repo)",
            canBeReferencedInPrompt: true,
            inputSchema: {
              type: "object",
              properties: {
                repo: {
                  type: "string",
                  description: "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                },
                query: {
                  type: "string",
                  description: "The query to search for repo. Should contain all relevant context."
                }
              },
              required: [
                "repo",
                "query"
              ]
            }
          },
          {
            name: "puku_toolReplay",
            modelDescription: "Replays a tool call from a previous chat session.",
            displayName: "tool replay",
            when: "false",
            inputSchema: {
              type: "object",
              properties: {
                toolCallId: {
                  type: "string",
                  description: "the id of the tool original tool call"
                },
                toolName: {
                  type: "string",
                  description: "the name of the tool being replayed"
                },
                toolCallArgs: {
                  type: "object",
                  description: "the arguments of the tool call"
                }
              }
            }
          },
          {
            name: "puku_memory",
            toolReferenceName: "memory",
            displayName: "%puku.tools.memory.name%",
            userDescription: "%puku.tools.memory.description%",
            modelDescription: "Manage persistent memory across conversations. This tool allows you to create, view, update, and delete memory files that persist between chat sessions. Use this to remember important information about the user, their preferences, project context, or anything that should be recalled in future conversations. Available commands: view (list/read memories), create (new memory file), str_replace (edit content), insert (add content), delete (remove memory), rename (change filename).",
            icon: "$(database)",
            when: "config.puku.chat.tools.memory.enabled",
            canBeReferencedInPrompt: true,
            tags: [],
            inputSchema: {
              type: "object",
              properties: {
                command: {
                  type: "string",
                  enum: [
                    "view",
                    "create",
                    "str_replace",
                    "insert",
                    "delete",
                    "rename"
                  ],
                  description: "The memory operation to perform:\n- view: Show directory contents or file contents (optional line ranges)\n- create: Create or overwrite a file\n- str_replace: Replace text in a file\n- insert: Insert text at a specific line\n- delete: Delete a file or directory\n- rename: Rename or move a file or directory"
                },
                path: {
                  type: "string",
                  description: "Path to the memory file or directory. Must start with /memories.\n- For view: /memories or /memories/file.md\n- For create/str_replace/insert/delete: /memories/file.md\n- Not used for rename (use old_path/new_path instead)"
                },
                view_range: {
                  type: "array",
                  items: {
                    type: "number"
                  },
                  minItems: 2,
                  maxItems: 2,
                  description: "[view only] Optional line range [start, end] to view specific lines. Example: [1, 10]"
                },
                file_text: {
                  type: "string",
                  description: "[create only] Content to write to the file. Required for create command."
                },
                old_str: {
                  type: "string",
                  description: "[str_replace only] The exact literal text to find and replace. Must be unique in the file. Required for str_replace command."
                },
                new_str: {
                  type: "string",
                  description: "[str_replace only] The exact literal text to replace old_str with. Can be empty string. Required for str_replace command."
                },
                insert_line: {
                  type: "number",
                  description: "[insert only] Line number at which to insert text (0-indexed, 0 = before first line). Required for insert command."
                },
                insert_text: {
                  type: "string",
                  description: "[insert only] Text to insert at the specified line. Required for insert command."
                },
                old_path: {
                  type: "string",
                  description: "[rename only] Current path of the file or directory. Must start with /memories. Required for rename command."
                },
                new_path: {
                  type: "string",
                  description: "[rename only] New path for the file or directory. Must start with /memories. Required for rename command."
                }
              },
              required: [
                "command"
              ]
            }
          },
          {
            name: "puku_editFiles",
            modelDescription: "This is a placeholder tool, do not use",
            userDescription: "Edit files",
            icon: "$(pencil)",
            displayName: "Edit Files",
            toolReferenceName: "editFiles"
          }
        ],
        languageModelToolSets: [
          {
            name: "edit",
            description: "%puku.toolSet.editing.description%",
            icon: "$(pencil)",
            tools: [
              "createFile",
              "createDirectory",
              "editNotebook",
              "newJupyterNotebook",
              "editFiles"
            ]
          },
          {
            name: "runNotebooks",
            description: "%puku.toolSet.runNotebook.description%",
            icon: "$(notebook)",
            tools: [
              "runCell",
              "getNotebookSummary",
              "readNotebookCellOutput"
            ]
          },
          {
            name: "search",
            description: "%puku.toolSet.search.description%",
            icon: "$(search)",
            tools: [
              "fileSearch",
              "textSearch",
              "listDirectory",
              "readFile",
              "codebase",
              "searchResults"
            ]
          },
          {
            name: "new",
            description: "%puku.toolSet.new.description%",
            icon: "$(new-folder)",
            tools: [
              "newWorkspace",
              "runVscodeCommand",
              "getProjectSetupInfo",
              "installExtension"
            ]
          }
        ],
        chatParticipants: [
          {
            id: "puku.default",
            name: "GitHubCopilot",
            fullName: "GitHub Copilot",
            description: "%puku.description%",
            isDefault: true,
            locations: [
              "panel"
            ],
            modes: [
              "ask"
            ],
            disambiguation: [
              {
                category: "generate_code_sample",
                description: "The user wants to generate code snippets without referencing the contents of the current workspace. This category does not include generating entire projects.",
                examples: [
                  "Write an example of computing a SHA256 hash."
                ]
              },
              {
                category: "add_feature_to_file",
                description: "The user wants to change code in a file that is provided in their request, without referencing the contents of the current workspace. This category does not include generating entire projects.",
                examples: [
                  "Add a refresh button to the table widget."
                ]
              },
              {
                category: "question_about_specific_files",
                description: "The user has a question about a specific file or code snippet that they have provided as part of their query, and the question does not require additional workspace context to answer.",
                examples: [
                  "What does this file do?"
                ]
              }
            ]
          },
          {
            id: "puku.editingSession",
            name: "GitHubCopilot",
            fullName: "GitHub Copilot",
            description: "%puku.edits.description%",
            isDefault: true,
            locations: [
              "panel"
            ],
            modes: [
              "edit"
            ],
            when: "!config.chat.edits2.enabled"
          },
          {
            id: "puku.editingSessionEditor",
            name: "GitHubCopilot",
            fullName: "GitHub Copilot",
            description: "%puku.edits.description%",
            isDefault: true,
            when: "config.inlineChat.enableV2",
            locations: [
              "editor",
              "editorInline"
            ]
          },
          {
            id: "puku.editingSession2",
            name: "GitHubCopilot",
            fullName: "GitHub Copilot",
            description: "%puku.edits.description%",
            isDefault: true,
            locations: [
              "panel"
            ],
            modes: [
              "edit"
            ],
            when: "config.chat.edits2.enabled"
          },
          {
            id: "puku.editsAgent",
            name: "agent",
            fullName: "GitHub Copilot",
            description: "%puku.agent.description%",
            locations: [
              "panel"
            ],
            modes: [
              "agent"
            ],
            isEngine: true,
            isDefault: true,
            isAgent: true,
            when: "config.chat.agent.enabled",
            commands: [
              {
                name: "list"
              },
              {
                name: "error",
                description: "Make a model request which will result in an error",
                when: "puku.chat.debug"
              }
            ]
          },
          {
            id: "puku.editor",
            name: "Copilot",
            fullName: "GitHub Copilot",
            description: "%puku.description%",
            isDefault: true,
            locations: [
              "editor",
              "editorInline"
            ],
            when: "!config.inlineChat.enableV2",
            disambiguation: [
              {
                category: "unknown",
                description: "Intent of this command is unclear or is not related to information technologies",
                examples: [
                  "Add a dog to this comment."
                ]
              }
            ],
            commands: [
              {
                name: "generate",
                description: "%puku.workspace.generate.description%",
                disambiguation: [
                  {
                    category: "generate",
                    description: "Generate new code",
                    examples: [
                      "Add a function that returns the sum of two numbers"
                    ]
                  }
                ]
              },
              {
                name: "edit",
                description: "%puku.workspace.edit.inline.description%",
                disambiguation: [
                  {
                    category: "edit",
                    description: "Make changes to existing code",
                    examples: [
                      "Change this method to use async/await"
                    ]
                  }
                ]
              },
              {
                name: "doc",
                description: "%puku.workspace.doc.description%",
                disambiguation: [
                  {
                    category: "doc",
                    description: "Add documentation comment for this symbol",
                    examples: [
                      "Add jsdoc to this method"
                    ]
                  }
                ]
              },
              {
                name: "fix",
                description: "%puku.workspace.fix.description%",
                disambiguation: [
                  {
                    category: "fix",
                    description: "Propose a fix for the problems in the selected code",
                    examples: [
                      "There is a problem in this code. Rewrite the code to show it with the bug fixed."
                    ]
                  }
                ]
              },
              {
                name: "explain",
                description: "%puku.workspace.explain.description%",
                disambiguation: [
                  {
                    category: "explain",
                    description: "Explain how the code in your active editor works",
                    examples: [
                      "Write an explanation for the code above as paragraphs of text."
                    ]
                  }
                ]
              },
              {
                name: "review",
                description: "%puku.workspace.review.description%",
                when: "puku.advanced.review.intent"
              },
              {
                name: "tests",
                description: "%puku.workspace.tests.description%",
                disambiguation: [
                  {
                    category: "tests",
                    description: "Generate unit tests for the selected code. The user does not want to fix their existing tests.",
                    examples: [
                      "Write a set of detailed unit test functions for the code above."
                    ]
                  }
                ]
              }
            ]
          },
          {
            id: "puku.notebook",
            name: "GitHubCopilot",
            fullName: "GitHub Copilot",
            description: "%puku.description%",
            isDefault: true,
            locations: [
              "notebook"
            ],
            when: "!config.inlineChat.notebookAgent",
            commands: [
              {
                name: "fix",
                description: "%puku.workspace.fix.description%"
              },
              {
                name: "explain",
                description: "%puku.workspace.explain.description%"
              }
            ]
          },
          {
            id: "puku.notebookEditorAgent",
            name: "GitHubCopilot",
            fullName: "GitHub Copilot",
            description: "%puku.description%",
            isDefault: true,
            locations: [
              "notebook"
            ],
            when: "config.inlineChat.notebookAgent",
            commands: [
              {
                name: "fix",
                description: "%puku.workspace.fix.description%"
              },
              {
                name: "explain",
                description: "%puku.workspace.explain.description%"
              }
            ]
          },
          {
            id: "puku.workspace",
            name: "workspace",
            fullName: "Workspace",
            description: "%puku.workspace.description%",
            when: "!puku.interactiveSession.disabled",
            sampleRequest: "%puku.workspace.sampleRequest%",
            locations: [
              "panel"
            ],
            disambiguation: [
              {
                category: "workspace_project_questions",
                description: "The user wants to learn about or update the code or files in their current workspace. Questions in this category may be about understanding what the whole workspace does or locating the implementation of some code. This does not include generating or updating tests.",
                examples: [
                  "What does this project do?"
                ]
              },
              {
                category: "find_code_in_workspace",
                description: "The user wants to locate the implementation of some functionality in their current workspace.",
                examples: [
                  "Where is the tree widget implemented?"
                ]
              },
              {
                category: "generate_with_workspace_context",
                description: "The user wants to generate code based on multiple files in the workspace and did not specify which files to reference.",
                examples: [
                  "Create a README for this project."
                ]
              }
            ],
            commands: [
              {
                name: "explain",
                description: "%puku.workspace.explain.description%"
              },
              {
                name: "review",
                description: "%puku.workspace.review.description%",
                when: "puku.advanced.review.intent"
              },
              {
                name: "tests",
                description: "%puku.workspace.tests.description%",
                disambiguation: [
                  {
                    category: "create_tests",
                    description: "The user wants to generate unit tests.",
                    examples: [
                      "Generate tests for my selection using pytest."
                    ]
                  }
                ]
              },
              {
                name: "fix",
                description: "%puku.workspace.fix.description%",
                sampleRequest: "%puku.workspace.fix.sampleRequest%"
              },
              {
                name: "new",
                description: "%puku.workspace.new.description%",
                sampleRequest: "%puku.workspace.new.sampleRequest%",
                isSticky: true,
                disambiguation: [
                  {
                    category: "create_new_workspace_or_extension",
                    description: "The user wants to create a complete Visual Studio Code workspace from scratch, such as a new application or a Visual Studio Code extension. Use this category only if the question relates to generating or creating new workspaces in Visual Studio Code. Do not use this category for updating existing code or generating sample code snippets",
                    examples: [
                      "Scaffold a Node server.",
                      "Create a sample project which uses the fileSystemProvider API.",
                      "react application"
                    ]
                  }
                ]
              },
              {
                name: "newNotebook",
                description: "%puku.workspace.newNotebook.description%",
                sampleRequest: "%puku.workspace.newNotebook.sampleRequest%",
                disambiguation: [
                  {
                    category: "create_jupyter_notebook",
                    description: "The user wants to create a new Jupyter notebook in Visual Studio Code.",
                    examples: [
                      "Create a notebook to analyze this CSV file."
                    ]
                  }
                ]
              },
              {
                name: "semanticSearch",
                description: "%puku.workspace.semanticSearch.description%",
                sampleRequest: "%puku.workspace.semanticSearch.sampleRequest%",
                when: "config.puku.semanticSearch.enabled"
              },
              {
                name: "setupTests",
                description: "%puku.vscode.setupTests.description%",
                sampleRequest: "%puku.vscode.setupTests.sampleRequest%",
                when: "config.puku.chat.setupTests.enabled",
                disambiguation: [
                  {
                    category: "set_up_tests",
                    description: "The user wants to configure project test setup, framework, or test runner. The user does not want to fix their existing tests.",
                    examples: [
                      "Set up tests for this project."
                    ]
                  }
                ]
              }
            ]
          },
          {
            id: "puku.vscode",
            name: "vscode",
            fullName: "VS Code",
            description: "%puku.vscode.description%",
            when: "!puku.interactiveSession.disabled",
            sampleRequest: "%puku.vscode.sampleRequest%",
            locations: [
              "panel"
            ],
            disambiguation: [
              {
                category: "vscode_configuration_questions",
                description: "The user wants to learn about, use, or configure the Visual Studio Code. Use this category if the users question is specifically about commands, settings, keybindings, extensions and other features available in Visual Studio Code. Do not use this category to answer questions about generating code or creating new projects including Visual Studio Code extensions.",
                examples: [
                  "Switch to light mode.",
                  "Keyboard shortcut to toggle terminal visibility.",
                  "Settings to enable minimap.",
                  "Whats new in the latest release?"
                ]
              },
              {
                category: "configure_python_environment",
                description: "The user wants to set up their Python environment.",
                examples: [
                  "Create a virtual environment for my project."
                ]
              }
            ],
            commands: [
              {
                name: "search",
                description: "%puku.vscode.search.description%",
                sampleRequest: "%puku.vscode.search.sampleRequest%"
              }
            ]
          },
          {
            id: "puku.terminal",
            name: "terminal",
            fullName: "Terminal",
            description: "%puku.terminal.description%",
            when: "!puku.interactiveSession.disabled",
            sampleRequest: "%puku.terminal.sampleRequest%",
            isDefault: true,
            locations: [
              "terminal"
            ],
            commands: [
              {
                name: "explain",
                description: "%puku.terminal.explain.description%",
                sampleRequest: "%puku.terminal.explain.sampleRequest%"
              }
            ]
          },
          {
            id: "puku.terminalPanel",
            name: "terminal",
            fullName: "Terminal",
            description: "%puku.terminalPanel.description%",
            when: "!puku.interactiveSession.disabled",
            sampleRequest: "%puku.terminal.sampleRequest%",
            locations: [
              "panel"
            ],
            commands: [
              {
                name: "explain",
                description: "%puku.terminal.explain.description%",
                sampleRequest: "%puku.terminal.explain.sampleRequest%",
                disambiguation: [
                  {
                    category: "terminal_state_questions",
                    description: "The user wants to learn about specific state such as the selection, command, or failed command in the integrated terminal in Visual Studio Code.",
                    examples: [
                      "Why did the latest terminal command fail?"
                    ]
                  }
                ]
              }
            ]
          },
          {
            id: "puku.chatReplay",
            name: "chatReplay",
            fullName: "Chat Replay",
            when: "debugType == 'vscode-chat-replay'",
            locations: [
              "panel"
            ]
          },
          {
            id: "claude-code",
            name: "claude-code",
            fullName: "Claude Code",
            locations: [
              "panel"
            ]
          }
        ],
        languageModelChatProviders: [
          {
            vendor: "copilot",
            displayName: "Copilot"
          },
          {
            vendor: "pukuai",
            displayName: "Puku AI"
          },
          {
            vendor: "azure",
            displayName: "Azure",
            managementCommand: "puku.chat.manageBYOK"
          },
          {
            vendor: "anthropic",
            displayName: "Anthropic",
            managementCommand: "puku.chat.manageBYOK"
          },
          {
            vendor: "xai",
            displayName: "xAI",
            managementCommand: "puku.chat.manageBYOK"
          },
          {
            vendor: "ollama",
            displayName: "Ollama"
          },
          {
            vendor: "openai",
            displayName: "OpenAI",
            managementCommand: "puku.chat.manageBYOK"
          },
          {
            vendor: "gemini",
            displayName: "Google",
            managementCommand: "puku.chat.manageBYOK"
          },
          {
            vendor: "groq",
            displayName: "Groq",
            managementCommand: "puku.chat.manageBYOK"
          },
          {
            vendor: "openrouter",
            displayName: "OpenRouter",
            managementCommand: "puku.chat.manageBYOK"
          },
          {
            vendor: "customoai",
            when: "productQualityType != 'stable'",
            displayName: "OpenAI Compatible",
            managementCommand: "puku.chat.manageBYOK"
          }
        ],
        interactiveSession: [
          {
            label: "GitHub Copilot",
            id: "copilot",
            icon: "",
            when: "!puku.interactiveSession.disabled"
          }
        ],
        viewsWelcome: [
          {
            view: "debug",
            when: "puku-chat.activated",
            contents: "%puku.viewsWelcome.debug%"
          },
          {
            view: "codex-placeholder",
            when: "true",
            contents: "%puku.viewsWelcome.codexPlaceholder%"
          },
          {
            view: "workbench.view.chat.sessions.openai-codex",
            contents: "%puku.viewsWelcome.codexWelcomeView%"
          },
          {
            view: "copilot-agents-placeholder",
            when: "true",
            contents: "%puku.viewsWelcome.agentsPlaceholder%"
          },
          {
            view: "workbench.view.chat.sessions.copilot-cloud-agent",
            when: "puku.auth.missingPermissiveSession",
            contents: "%puku.viewsWelcome.noPermissiveToken.contents%"
          },
          {
            view: "workbench.view.chat.sessions.copilot-cloud-agent",
            when: "workspaceFolderCount == 0",
            contents: "%puku.viewsWelcome.noFolder.contents%"
          },
          {
            view: "workbench.view.chat.sessions.copilot-cloud-agent",
            when: "git.state == initialized && gitOpenRepositoryCount == 0 && workspaceFolderCount > 0 && git.parentRepositoryCount == 0",
            contents: "%puku.viewsWelcome.noRepo.contents%"
          },
          {
            view: "workbench.view.chat.sessions.copilot-cloud-agent",
            when: "git.state == initialized && workspaceFolderCount > 0 && (git.parentRepositoryCount > 0 || gitOpenRepositoryCount > 0) && !github:hasGitHubRemotes",
            contents: "%puku.viewsWelcome.noGitHub.contents%"
          },
          {
            view: "workbench.view.chat.sessions.copilot-cloud-agent",
            when: "puku.chat.cloudSessionsEmpty",
            contents: "%puku.viewsWelcome.cloudSessionsEmpty.contents%"
          },
          {
            view: "workbench.view.chat.sessions.copilotcli",
            when: "puku.chat.cliSessionsEmpty",
            contents: "%puku.viewsWelcome.cliSessionsEmpty.contents%"
          }
        ],
        chatViewsWelcome: [
          {
            icon: "$(copilot-large)",
            title: "Ask Copilot",
            content: "%puku.viewsWelcome.signIn%",
            when: "!puku-chat.activated && !puku.offline && !puku.interactiveSession.individual.expired && !puku.interactiveSession.enterprise.disabled && !puku.interactiveSession.contactSupport && !puku.interactiveSession.chatDisabled && !puku.interactiveSession.switchToReleaseChannel"
          },
          {
            icon: "$(copilot-large)",
            title: "Ask Copilot",
            content: "%puku.viewsWelcome.individual.expired%",
            when: "puku.interactiveSession.individual.expired"
          },
          {
            icon: "$(copilot-large)",
            title: "Ask Copilot",
            content: "%puku.viewsWelcome.enterprise%",
            when: "puku.interactiveSession.enterprise.disabled"
          },
          {
            icon: "$(copilot-large)",
            title: "Ask Copilot",
            content: "%puku.viewsWelcome.offline%",
            when: "puku.offline"
          },
          {
            icon: "$(copilot-large)",
            title: "Ask Copilot",
            content: "%puku.viewsWelcome.contactSupport%",
            when: "puku.interactiveSession.contactSupport"
          },
          {
            icon: "$(copilot-large)",
            title: "Ask Copilot",
            content: "%puku.viewsWelcome.chatDisabled%",
            when: "puku.interactiveSession.chatDisabled"
          },
          {
            icon: "$(copilot-large)",
            title: "Ask Copilot",
            content: "%puku.viewsWelcome.switchToReleaseChannel%",
            when: "puku.interactiveSession.switchToReleaseChannel"
          }
        ],
        commands: [
          {
            command: "puku.chat.triggerPermissiveSignIn",
            title: "%puku.command.triggerPermissiveSignIn%"
          },
          {
            command: "puku.claude.sessions.refresh",
            title: "%puku.command.refreshClaudeCodeSessions%",
            icon: "$(refresh)",
            category: "Claude Code"
          },
          {
            command: "puku.cli.sessions.refresh",
            title: "%puku.command.refreshAgentSessions%",
            icon: "$(refresh)",
            category: "Copilot CLI"
          },
          {
            command: "puku.cli.sessions.delete",
            title: "%puku.command.deleteAgentSession%",
            icon: "$(close)",
            category: "Copilot CLI"
          },
          {
            command: "puku.cli.sessions.resumeInTerminal",
            title: "%puku.command.cli.sessions.resumeInTerminal%",
            icon: "$(terminal)",
            category: "Copilot CLI"
          },
          {
            command: "puku.cli.sessions.newTerminalSession",
            title: "%puku.cli.sessions.newTerminalSession%",
            icon: "$(terminal)",
            category: "Copilot CLI"
          },
          {
            command: "puku.chat.replay",
            title: "Start Chat Replay",
            icon: "$(debug-line-by-line)",
            enablement: "resourceFilename === 'benchRun.chatReplay.json' && !inDebugMode"
          },
          {
            command: "puku.chat.replay.enableWorkspaceEditTracing",
            title: "%puku.command.enableEditTracing%",
            category: "Developer",
            enablement: "!puku.chat.replay.workspaceEditTracing"
          },
          {
            command: "puku.chat.replay.disableWorkspaceEditTracing",
            title: "%puku.command.disableEditTracing%",
            category: "Developer",
            enablement: "puku.chat.replay.workspaceEditTracing"
          },
          {
            command: "puku.chat.explain",
            title: "%puku.command.explainThis%",
            enablement: "!puku.interactiveSession.disabled",
            category: "Chat"
          },
          {
            command: "puku.chat.explain.palette",
            title: "%puku.command.explainThis%",
            enablement: "!puku.interactiveSession.disabled && !editorReadonly",
            category: "Chat"
          },
          {
            command: "puku.chat.review",
            title: "%puku.command.reviewAndComment%",
            enablement: "config.puku.chat.reviewSelection.enabled && !puku.interactiveSession.disabled",
            category: "Chat"
          },
          {
            command: "puku.chat.review.apply",
            title: "%puku.command.applyReviewSuggestion%",
            icon: "$(sparkle)",
            enablement: "commentThread =~ /hasSuggestion/",
            category: "Chat"
          },
          {
            command: "puku.chat.review.applyAndNext",
            title: "%puku.command.applyReviewSuggestionAndNext%",
            icon: "$(sparkle)",
            enablement: "commentThread =~ /hasSuggestion/",
            category: "Chat"
          },
          {
            command: "puku.chat.review.discard",
            title: "%puku.command.discardReviewSuggestion%",
            icon: "$(close)",
            category: "Chat"
          },
          {
            command: "puku.chat.review.discardAndNext",
            title: "%puku.command.discardReviewSuggestionAndNext%",
            icon: "$(close)",
            category: "Chat"
          },
          {
            command: "puku.chat.review.discardAll",
            title: "%puku.command.discardAllReviewSuggestion%",
            icon: "$(close-all)",
            category: "Chat"
          },
          {
            command: "puku.chat.review.stagedChanges",
            title: "%puku.command.reviewStagedChanges%",
            icon: "$(code-review)",
            enablement: "puku.chat.reviewDiff.enabled && !puku.interactiveSession.disabled",
            category: "Chat"
          },
          {
            command: "puku.chat.review.unstagedChanges",
            title: "%puku.command.reviewUnstagedChanges%",
            icon: "$(code-review)",
            enablement: "puku.chat.reviewDiff.enabled && !puku.interactiveSession.disabled",
            category: "Chat"
          },
          {
            command: "puku.chat.review.changes",
            title: "%puku.command.reviewChanges%",
            icon: "$(code-review)",
            enablement: "puku.chat.reviewDiff.enabled && !puku.interactiveSession.disabled",
            category: "Chat"
          },
          {
            command: "puku.chat.review.stagedFileChange",
            title: "%puku.command.reviewFileChange%",
            icon: "$(code-review)",
            enablement: "puku.chat.reviewDiff.enabled && !puku.interactiveSession.disabled",
            category: "Chat"
          },
          {
            command: "puku.chat.review.unstagedFileChange",
            title: "%puku.command.reviewFileChange%",
            icon: "$(code-review)",
            enablement: "puku.chat.reviewDiff.enabled && !puku.interactiveSession.disabled",
            category: "Chat"
          },
          {
            command: "puku.chat.review.previous",
            title: "%puku.command.gotoPreviousReviewSuggestion%",
            icon: "$(arrow-up)",
            category: "Chat"
          },
          {
            command: "puku.chat.review.next",
            title: "%puku.command.gotoNextReviewSuggestion%",
            icon: "$(arrow-down)",
            category: "Chat"
          },
          {
            command: "puku.chat.review.continueInInlineChat",
            title: "%puku.command.continueReviewInInlineChat%",
            icon: "$(comment-discussion)",
            category: "Chat"
          },
          {
            command: "puku.chat.review.continueInChat",
            title: "%puku.command.continueReviewInChat%",
            icon: "$(comment-discussion)",
            category: "Chat"
          },
          {
            command: "puku.chat.review.markHelpful",
            title: "%puku.command.helpfulReviewSuggestion%",
            icon: "$(thumbsup)",
            enablement: "!(commentThread =~ /markedAsHelpful/)",
            category: "Chat"
          },
          {
            command: "puku.chat.openUserPreferences",
            title: "%puku.command.openUserPreferences%",
            category: "Chat",
            enablement: "config.puku.chat.enableUserPreferences"
          },
          {
            command: "puku.chat.tools.memory.openFolder",
            title: "%puku.command.openMemoryFolder%",
            category: "Chat",
            enablement: "config.puku.chat.tools.memory.enabled"
          },
          {
            command: "puku.chat.review.markUnhelpful",
            title: "%puku.command.unhelpfulReviewSuggestion%",
            icon: "$(thumbsdown)",
            enablement: "!(commentThread =~ /markedAsUnhelpful/)",
            category: "Chat"
          },
          {
            command: "puku.chat.generate",
            title: "%puku.command.generateThis%",
            icon: "$(sparkle)",
            enablement: "!puku.interactiveSession.disabled && !editorReadonly",
            category: "Chat"
          },
          {
            command: "puku.chat.generateDocs",
            title: "%puku.command.generateDocs%",
            enablement: "!puku.interactiveSession.disabled && !editorReadonly",
            category: "Chat"
          },
          {
            command: "puku.chat.generateTests",
            title: "%puku.command.generateTests%",
            enablement: "!puku.interactiveSession.disabled && !editorReadonly",
            category: "Chat"
          },
          {
            command: "puku.chat.fix",
            title: "%puku.command.fixThis%",
            enablement: "!puku.interactiveSession.disabled && !editorReadonly",
            category: "Chat"
          },
          {
            command: "puku.interactiveSession.feedback",
            title: "%puku.command.sendChatFeedback%",
            enablement: "puku-chat.activated && !puku.interactiveSession.disabled",
            icon: "$(feedback)",
            category: "Chat"
          },
          {
            command: "puku.debug.workbenchState",
            title: "%puku.command.logWorkbenchState%",
            category: "Developer"
          },
          {
            command: "puku.debug.showChatLogView",
            title: "%puku.command.showChatLogView%",
            category: "Developer"
          },
          {
            command: "puku.debug.showOutputChannel",
            title: "%puku.command.showOutputChannel%",
            category: "Developer"
          },
          {
            command: "puku.debug.showContextInspectorView",
            title: "%puku.command.showContextInspectorView%",
            icon: "$(inspect)",
            category: "Developer"
          },
          {
            command: "puku.debug.resetVirtualToolGroups",
            title: "%puku.command.resetVirtualToolGroups%",
            icon: "$(inspect)",
            category: "Developer"
          },
          {
            command: "puku.terminal.explainTerminalLastCommand",
            title: "%puku.command.explainTerminalLastCommand%",
            category: "Chat"
          },
          {
            command: "puku.git.generateCommitMessage",
            title: "%puku.git.generateCommitMessage%",
            icon: "$(sparkle)",
            enablement: "!puku.interactiveSession.disabled",
            category: "Chat"
          },
          {
            command: "puku.git.resolveMergeConflicts",
            title: "%puku.git.resolveMergeConflicts%",
            icon: "$(chat-sparkle)",
            enablement: "!puku.interactiveSession.disabled",
            category: "Chat"
          },
          {
            command: "puku.devcontainer.generateDevContainerConfig",
            title: "%puku.devcontainer.generateDevContainerConfig%",
            category: "Chat"
          },
          {
            command: "puku.tests.fixTestFailure",
            icon: "$(sparkle)",
            title: "%puku.command.fixTestFailure%",
            category: "Chat"
          },
          {
            command: "puku.tests.fixTestFailure.fromInline",
            icon: "$(sparkle)",
            title: "%puku.command.fixTestFailure%"
          },
          {
            command: "puku.chat.attachFile",
            title: "%puku.chat.attachFile%",
            category: "Chat"
          },
          {
            command: "puku.chat.attachSelection",
            title: "%puku.chat.attachSelection%",
            icon: "$(comment-discussion)",
            category: "Chat"
          },
          {
            command: "puku.debug.collectDiagnostics",
            title: "%puku.command.collectDiagnostics%",
            category: "Developer"
          },
          {
            command: "puku.debug.inlineEdit.clearCache",
            title: "%puku.command.inlineEdit.clearCache%",
            category: "Developer"
          },
          {
            command: "puku.debug.inlineEdit.reportNotebookNESIssue",
            title: "%puku.command.inlineEdit.reportNotebookNESIssue%",
            enablement: "config.puku.chat.advanced.notebook.alternativeNESFormat.enabled || puku.chat.enableEnhancedNotebookNES",
            category: "Developer"
          },
          {
            command: "puku.debug.generateSTest",
            title: "%puku.command.generateSTest%",
            enablement: "puku.debugReportFeedback",
            category: "Developer"
          },
          {
            command: "puku.open.walkthrough",
            title: "%puku.command.openWalkthrough%",
            category: "Chat"
          },
          {
            command: "puku.debug.generateInlineEditTests",
            title: "Generate Inline Edit Tests",
            category: "Chat",
            enablement: "resourceScheme == 'ccreq'"
          },
          {
            command: "puku.buildLocalWorkspaceIndex",
            title: "%puku.command.buildLocalWorkspaceIndex%",
            category: "Chat",
            enablement: "puku-chat.activated"
          },
          {
            command: "puku.buildRemoteWorkspaceIndex",
            title: "%puku.command.buildRemoteWorkspaceIndex%",
            category: "Chat",
            enablement: "puku-chat.activated"
          },
          {
            command: "puku.report",
            title: "Report Issue",
            category: "Chat"
          },
          {
            command: "puku.chat.rerunWithCopilotDebug",
            title: "%puku.command.rerunWithCopilotDebug%",
            category: "Chat"
          },
          {
            command: "puku.chat.startCopilotDebugCommand",
            title: "Start Copilot Debug"
          },
          {
            command: "puku.chat.clearTemporalContext",
            title: "Clear Temporal Context",
            category: "Developer"
          },
          {
            command: "puku.search.markHelpful",
            title: "Helpful",
            icon: "$(thumbsup)",
            enablement: "!puku.search.feedback.sent"
          },
          {
            command: "puku.search.markUnhelpful",
            title: "Unhelpful",
            icon: "$(thumbsdown)",
            enablement: "!puku.search.feedback.sent"
          },
          {
            command: "puku.search.feedback",
            title: "Feedback",
            icon: "$(feedback)",
            enablement: "!puku.search.feedback.sent"
          },
          {
            command: "puku.chat.debug.showElements",
            title: "Show Rendered Elements"
          },
          {
            command: "puku.chat.debug.hideElements",
            title: "Hide Rendered Elements"
          },
          {
            command: "puku.chat.debug.showTools",
            title: "Show Tools"
          },
          {
            command: "puku.chat.debug.hideTools",
            title: "Hide Tools"
          },
          {
            command: "puku.chat.debug.showNesRequests",
            title: "Show NES Requests"
          },
          {
            command: "puku.chat.debug.hideNesRequests",
            title: "Hide NES Requests"
          },
          {
            command: "puku.chat.debug.showRawRequestBody",
            title: "Show Raw Request Body"
          },
          {
            command: "puku.chat.debug.exportLogItem",
            title: "Export as...",
            icon: "$(export)"
          },
          {
            command: "puku.chat.debug.exportPromptArchive",
            title: "Export All as Archive...",
            icon: "$(archive)"
          },
          {
            command: "puku.chat.debug.exportPromptLogsAsJson",
            title: "Export All as JSON...",
            icon: "$(export)"
          },
          {
            command: "puku.chat.debug.exportAllPromptLogsAsJson",
            title: "Export All Prompt Logs as JSON...",
            icon: "$(export)"
          },
          {
            command: "puku.chat.showAsChatSession",
            title: "Show as chat session",
            icon: "$(chat-sparkle)"
          },
          {
            command: "puku.debug.collectWorkspaceIndexDiagnostics",
            title: "%puku.command.collectWorkspaceIndexDiagnostics%",
            category: "Developer"
          },
          {
            command: "puku.chat.mcp.setup.check",
            title: "MCP Check: is supported"
          },
          {
            command: "puku.chat.mcp.setup.validatePackage",
            title: "MCP Check: validate package"
          },
          {
            command: "puku.chat.mcp.setup.flow",
            title: "MCP Check: do prompts"
          },
          {
            command: "puku.chat.generateAltText",
            title: "Generate/Refine Alt Text"
          },
          {
            command: "puku.chat.notebook.enableFollowCellExecution",
            title: "Enable Follow Cell Execution from Chat",
            shortTitle: "Follow",
            icon: "$(pinned)"
          },
          {
            command: "puku.chat.notebook.disableFollowCellExecution",
            title: "Disable Follow Cell Execution from Chat",
            shortTitle: "Unfollow",
            icon: "$(pinned-dirty)"
          },
          {
            command: "puku.chat.manageBYOK",
            title: "Manage Bring Your Own Key Vendor",
            enablement: "false"
          },
          {
            command: "puku.chat.manageBYOKAPIKey",
            title: "Manage Bring Your Own Key API Key",
            enablement: "false"
          },
          {
            command: "puku.cloud.sessions.refresh",
            title: "%puku.command.refreshAgentSessions%",
            icon: "$(refresh)"
          },
          {
            command: "puku.cloud.sessions.openInBrowser",
            title: "%puku.command.openCopilotAgentSessionsInBrowser%",
            icon: "$(link-external)"
          },
          {
            command: "puku.cloud.sessions.proxy.closeChatSessionPullRequest",
            title: "%puku.command.closeChatSessionPullRequest.title%"
          },
          {
            command: "puku.chat.openSuggestionsPanel",
            title: "Open Completions Panel",
            enablement: "puku.extensionUnification.activated && !isWeb",
            category: "GitHub Copilot"
          },
          {
            command: "puku.chat.toggleStatusMenu",
            title: "Open Status Menu",
            enablement: "puku.extensionUnification.activated",
            category: "GitHub Copilot"
          },
          {
            command: "puku.chat.completions.disable",
            title: "Disable Inline Suggestions",
            enablement: "puku.extensionUnification.activated && puku.activated && config.editor.inlineSuggest.enabled && puku.completions.enabled",
            category: "GitHub Copilot"
          },
          {
            command: "puku.chat.completions.enable",
            title: "Enable Inline Suggestions",
            enablement: "puku.extensionUnification.activated && puku.activated && !(config.editor.inlineSuggest.enabled && puku.completions.enabled)",
            category: "GitHub Copilot"
          },
          {
            command: "puku.chat.completions.toggle",
            title: "Toggle (Enable/Disable) Inline Suggestions",
            enablement: "puku.extensionUnification.activated && puku.activated",
            category: "GitHub Copilot"
          },
          {
            command: "puku.chat.openModelPicker",
            title: "Change Completions Model",
            category: "GitHub Copilot",
            enablement: "puku.extensionUnification.activated && !isWeb"
          },
          {
            command: "puku.chat.applyCopilotCLIAgentSessionChanges",
            title: "%puku.command.applyCopilotCLIAgentSessionChanges%",
            icon: "$(git-stash-pop)",
            category: "GitHub Copilot"
          }
        ],
        configuration: [
          {
            title: "GitHub Copilot Chat",
            id: "stable",
            properties: {
              "puku.chat.codeGeneration.useInstructionFiles": {
                type: "boolean",
                default: true,
                markdownDescription: "%puku.config.codeGeneration.useInstructionFiles%"
              },
              "puku.editor.enableCodeActions": {
                type: "boolean",
                default: true,
                description: "%puku.config.enableCodeActions%"
              },
              "puku.renameSuggestions.triggerAutomatically": {
                type: "boolean",
                default: true,
                description: "%puku.config.renameSuggestions.triggerAutomatically%"
              },
              "puku.chat.localeOverride": {
                type: "string",
                enum: [
                  "auto",
                  "en",
                  "fr",
                  "it",
                  "de",
                  "es",
                  "ru",
                  "zh-CN",
                  "zh-TW",
                  "ja",
                  "ko",
                  "cs",
                  "pt-br",
                  "tr",
                  "pl"
                ],
                enumDescriptions: [
                  "Use VS Code's configured display language",
                  "English",
                  "fran\xE7ais",
                  "italiano",
                  "Deutsch",
                  "espa\xF1ol",
                  "\u0440\u0443\u0441\u0441\u043A\u0438\u0439",
                  "\u4E2D\u6587(\u7B80\u4F53)",
                  "\u4E2D\u6587(\u7E41\u9AD4)",
                  "\u65E5\u672C\u8A9E",
                  "\uD55C\uAD6D\uC5B4",
                  "\u010De\u0161tina",
                  "portugu\xEAs",
                  "T\xFCrk\xE7e",
                  "polski"
                ],
                default: "auto",
                markdownDescription: "%puku.config.localeOverride%"
              },
              "puku.chat.terminalChatLocation": {
                type: "string",
                default: "chatView",
                markdownDescription: "%puku.config.terminalChatLocation%",
                markdownEnumDescriptions: [
                  "%puku.config.terminalChatLocation.chatView%",
                  "%puku.config.terminalChatLocation.quickChat%",
                  "%puku.config.terminalChatLocation.terminal%"
                ],
                enum: [
                  "chatView",
                  "quickChat",
                  "terminal"
                ]
              },
              "puku.chat.scopeSelection": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.scopeSelection%"
              },
              "puku.chat.useProjectTemplates": {
                type: "boolean",
                default: true,
                markdownDescription: "%puku.config.useProjectTemplates%"
              },
              "puku.nextEditSuggestions.enabled": {
                type: "boolean",
                default: false,
                tags: [
                  "nextEditSuggestions",
                  "onExp"
                ],
                markdownDescription: "%puku.nextEditSuggestions.enabled%",
                scope: "language-overridable"
              },
              "puku.nextEditSuggestions.fixes": {
                type: "boolean",
                default: true,
                tags: [
                  "nextEditSuggestions",
                  "onExp"
                ],
                markdownDescription: "%puku.nextEditSuggestions.fixes%",
                scope: "language-overridable"
              },
              "puku.nextEditSuggestions.allowWhitespaceOnlyChanges": {
                type: "boolean",
                default: true,
                tags: [
                  "nextEditSuggestions",
                  "onExp"
                ],
                markdownDescription: "%puku.nextEditSuggestions.allowWhitespaceOnlyChanges%",
                scope: "language-overridable"
              },
              "puku.chat.agent.autoFix": {
                type: "boolean",
                default: true,
                description: "%puku.config.autoFix%",
                tags: [
                  "onExp"
                ]
              },
              "puku.chat.customInstructionsInSystemMessage": {
                type: "boolean",
                default: true,
                description: "%puku.config.customInstructionsInSystemMessage%"
              },
              "puku.chat.agent.currentEditorContext.enabled": {
                type: "boolean",
                default: true,
                description: "%puku.config.agent.currentEditorContext.enabled%"
              },
              "puku.enable": {
                type: "object",
                scope: "window",
                default: {
                  "*": true,
                  plaintext: false,
                  markdown: false,
                  scminput: false
                },
                additionalProperties: {
                  type: "boolean"
                },
                markdownDescription: "Enable or disable auto triggering of Copilot completions for specified [languages](https://code.visualstudio.com/docs/languages/identifiers). You can still trigger suggestions manually using `Alt + \\`"
              },
              "puku.selectedCompletionModel": {
                type: "string",
                default: "",
                markdownDescription: 'The currently selected completion model ID. To select from a list of available models, use the __"Change Completions Model"__ command or open the model picker (from the Copilot menu in the VS Code title bar, select __"Configure Code Completions"__ then __"Change Completions Model"__. The value must be a valid model ID. An empty value indicates that the default model will be used.'
              }
            }
          },
          {
            id: "preview",
            properties: {
              "puku.chat.reviewAgent.enabled": {
                type: "boolean",
                default: true,
                description: "%puku.config.reviewAgent.enabled%",
                tags: [
                  "preview"
                ]
              },
              "puku.chat.reviewSelection.enabled": {
                type: "boolean",
                default: true,
                description: "%puku.config.reviewSelection.enabled%",
                tags: [
                  "preview"
                ]
              },
              "puku.chat.reviewSelection.instructions": {
                type: "array",
                items: {
                  oneOf: [
                    {
                      type: "object",
                      markdownDescription: "%puku.config.reviewSelection.instruction.file%",
                      properties: {
                        file: {
                          type: "string",
                          examples: [
                            ".copilot-review-instructions.md"
                          ]
                        },
                        language: {
                          type: "string"
                        }
                      },
                      examples: [
                        {
                          file: ".copilot-review-instructions.md"
                        }
                      ],
                      required: [
                        "file"
                      ]
                    },
                    {
                      type: "object",
                      markdownDescription: "%puku.config.reviewSelection.instruction.text%",
                      properties: {
                        text: {
                          type: "string",
                          examples: [
                            "Use underscore for field names."
                          ]
                        },
                        language: {
                          type: "string"
                        }
                      },
                      required: [
                        "text"
                      ],
                      examples: [
                        {
                          text: "Use underscore for field names."
                        },
                        {
                          text: "Resolve all TODO tasks."
                        }
                      ]
                    }
                  ]
                },
                default: [],
                markdownDescription: "%puku.config.reviewSelection.instructions%",
                examples: [
                  [
                    {
                      file: ".copilot-review-instructions.md"
                    },
                    {
                      text: "Resolve all TODO tasks."
                    }
                  ]
                ],
                tags: [
                  "preview"
                ]
              },
              "puku.chat.copilotDebugCommand.enabled": {
                type: "boolean",
                default: true,
                tags: [
                  "preview"
                ],
                description: "%puku.chat.copilotDebugCommand.enabled%"
              },
              "puku.chat.codesearch.enabled": {
                type: "boolean",
                default: false,
                tags: [
                  "preview"
                ],
                markdownDescription: "%puku.config.codesearch.enabled%"
              },
              "puku.chat.byok.ollamaEndpoint": {
                type: "string",
                default: "http://localhost:11434",
                tags: [
                  "preview"
                ],
                markdownDescription: "%puku.config.byok.ollamaEndpoint%"
              }
            }
          },
          {
            id: "experimental",
            properties: {
              "puku.chat.imageUpload.enabled": {
                type: "boolean",
                default: true,
                tags: [
                  "experimental",
                  "onExp"
                ],
                markdownDescription: "%puku.config.imageUpload.enabled%"
              },
              "puku.chat.edits.suggestRelatedFilesFromGitHistory": {
                type: "boolean",
                default: true,
                tags: [
                  "experimental"
                ],
                markdownDescription: "%puku.config.edits.suggestRelatedFilesFromGitHistory%"
              },
              "puku.chat.edits.suggestRelatedFilesForTests": {
                type: "boolean",
                default: true,
                tags: [
                  "experimental"
                ],
                markdownDescription: "%puku.chat.edits.suggestRelatedFilesForTests%"
              },
              "puku.chat.codeGeneration.instructions": {
                markdownDeprecationMessage: "%puku.config.codeGeneration.instructions.deprecated%",
                type: "array",
                items: {
                  oneOf: [
                    {
                      type: "object",
                      markdownDescription: "%puku.config.codeGeneration.instruction.file%",
                      properties: {
                        file: {
                          type: "string",
                          examples: [
                            ".copilot-codeGeneration-instructions.md"
                          ]
                        },
                        language: {
                          type: "string"
                        }
                      },
                      examples: [
                        {
                          file: ".copilot-codeGeneration-instructions.md"
                        }
                      ],
                      required: [
                        "file"
                      ]
                    },
                    {
                      type: "object",
                      markdownDescription: "%puku.config.codeGeneration.instruction.text%",
                      properties: {
                        text: {
                          type: "string",
                          examples: [
                            "Use underscore for field names."
                          ]
                        },
                        language: {
                          type: "string"
                        }
                      },
                      required: [
                        "text"
                      ],
                      examples: [
                        {
                          text: "Use underscore for field names."
                        },
                        {
                          text: "Always add a comment: 'Generated by Copilot'."
                        }
                      ]
                    }
                  ]
                },
                default: [],
                markdownDescription: "%puku.config.codeGeneration.instructions%",
                examples: [
                  [
                    {
                      file: ".copilot-codeGeneration-instructions.md"
                    },
                    {
                      text: "Always add a comment: 'Generated by Copilot'."
                    }
                  ]
                ],
                tags: [
                  "experimental"
                ]
              },
              "puku.chat.testGeneration.instructions": {
                markdownDeprecationMessage: "%puku.config.testGeneration.instructions.deprecated%",
                type: "array",
                items: {
                  oneOf: [
                    {
                      type: "object",
                      markdownDescription: "%puku.config.experimental.testGeneration.instruction.file%",
                      properties: {
                        file: {
                          type: "string",
                          examples: [
                            ".copilot-test-instructions.md"
                          ]
                        },
                        language: {
                          type: "string"
                        }
                      },
                      examples: [
                        {
                          file: ".copilot-test-instructions.md"
                        }
                      ],
                      required: [
                        "file"
                      ]
                    },
                    {
                      type: "object",
                      markdownDescription: "%puku.config.experimental.testGeneration.instruction.text%",
                      properties: {
                        text: {
                          type: "string",
                          examples: [
                            "Use suite and test instead of describe and it."
                          ]
                        },
                        language: {
                          type: "string"
                        }
                      },
                      required: [
                        "text"
                      ],
                      examples: [
                        {
                          text: "Always try uniting related tests in a suite."
                        }
                      ]
                    }
                  ]
                },
                default: [],
                markdownDescription: "%puku.config.testGeneration.instructions%",
                examples: [
                  [
                    {
                      file: ".copilot-test-instructions.md"
                    },
                    {
                      text: "Always try uniting related tests in a suite."
                    }
                  ]
                ],
                tags: [
                  "experimental"
                ]
              },
              "puku.chat.commitMessageGeneration.instructions": {
                type: "array",
                items: {
                  oneOf: [
                    {
                      type: "object",
                      markdownDescription: "%puku.config.commitMessageGeneration.instruction.file%",
                      properties: {
                        file: {
                          type: "string",
                          examples: [
                            ".copilot-commit-message-instructions.md"
                          ]
                        }
                      },
                      examples: [
                        {
                          file: ".copilot-commit-message-instructions.md"
                        }
                      ],
                      required: [
                        "file"
                      ]
                    },
                    {
                      type: "object",
                      markdownDescription: "%puku.config.commitMessageGeneration.instruction.text%",
                      properties: {
                        text: {
                          type: "string",
                          examples: [
                            "Use conventional commit message format."
                          ]
                        }
                      },
                      required: [
                        "text"
                      ],
                      examples: [
                        {
                          text: "Use conventional commit message format."
                        }
                      ]
                    }
                  ]
                },
                default: [],
                markdownDescription: "%puku.config.commitMessageGeneration.instructions%",
                examples: [
                  [
                    {
                      file: ".copilot-commit-message-instructions.md"
                    },
                    {
                      text: "Use conventional commit message format."
                    }
                  ]
                ],
                tags: [
                  "experimental"
                ]
              },
              "puku.chat.pullRequestDescriptionGeneration.instructions": {
                type: "array",
                items: {
                  oneOf: [
                    {
                      type: "object",
                      markdownDescription: "%puku.config.pullRequestDescriptionGeneration.instruction.file%",
                      properties: {
                        file: {
                          type: "string",
                          examples: [
                            ".copilot-pull-request-description-instructions.md"
                          ]
                        }
                      },
                      examples: [
                        {
                          file: ".copilot-pull-request-description-instructions.md"
                        }
                      ],
                      required: [
                        "file"
                      ]
                    },
                    {
                      type: "object",
                      markdownDescription: "%puku.config.pullRequestDescriptionGeneration.instruction.text%",
                      properties: {
                        text: {
                          type: "string",
                          examples: [
                            "Include every commit message in the pull request description."
                          ]
                        }
                      },
                      required: [
                        "text"
                      ],
                      examples: [
                        {
                          text: "Include every commit message in the pull request description."
                        }
                      ]
                    }
                  ]
                },
                default: [],
                markdownDescription: "%puku.config.pullRequestDescriptionGeneration.instructions%",
                examples: [
                  [
                    {
                      file: ".copilot-pull-request-description-instructions.md"
                    },
                    {
                      text: "Use conventional commit message format."
                    }
                  ]
                ],
                tags: [
                  "experimental"
                ]
              },
              "puku.chat.generateTests.codeLens": {
                type: "boolean",
                default: false,
                description: "%puku.config.generateTests.codeLens%",
                tags: [
                  "experimental"
                ]
              },
              "puku.chat.setupTests.enabled": {
                type: "boolean",
                default: true,
                markdownDescription: "%puku.config.setupTests.enabled%",
                tags: [
                  "experimental"
                ]
              },
              "puku.chat.languageContext.typescript.enabled": {
                type: "boolean",
                default: false,
                scope: "resource",
                tags: [
                  "experimental",
                  "onExP"
                ],
                markdownDescription: "%puku.chat.languageContext.typescript.enabled%"
              },
              "puku.chat.languageContext.typescript.items": {
                type: "string",
                enum: [
                  "minimal",
                  "double",
                  "fillHalf",
                  "fill"
                ],
                default: "minimal",
                scope: "resource",
                tags: [
                  "experimental",
                  "onExP"
                ],
                markdownDescription: "%puku.chat.languageContext.typescript.items%"
              },
              "puku.chat.languageContext.typescript.includeDocumentation": {
                type: "boolean",
                default: false,
                scope: "resource",
                tags: [
                  "experimental",
                  "onExP"
                ],
                markdownDescription: "%puku.chat.languageContext.typescript.includeDocumentation%"
              },
              "puku.chat.languageContext.typescript.cacheTimeout": {
                type: "number",
                default: 500,
                scope: "resource",
                tags: [
                  "experimental",
                  "onExP"
                ],
                markdownDescription: "%puku.chat.languageContext.typescript.cacheTimeout%"
              },
              "puku.chat.languageContext.fix.typescript.enabled": {
                type: "boolean",
                default: false,
                scope: "resource",
                tags: [
                  "experimental",
                  "onExP"
                ],
                markdownDescription: "%puku.chat.languageContext.fix.typescript.enabled%"
              },
              "puku.chat.languageContext.inline.typescript.enabled": {
                type: "boolean",
                default: false,
                scope: "resource",
                tags: [
                  "experimental",
                  "onExP"
                ],
                markdownDescription: "%puku.chat.languageContext.inline.typescript.enabled%"
              },
              "puku.chat.newWorkspaceCreation.enabled": {
                type: "boolean",
                default: true,
                tags: [
                  "experimental"
                ],
                description: "%puku.config.newWorkspaceCreation.enabled%"
              },
              "puku.chat.newWorkspace.useContext7": {
                type: "boolean",
                default: false,
                tags: [
                  "experimental"
                ],
                markdownDescription: "%puku.config.newWorkspace.useContext7%"
              },
              "puku.chat.notebook.followCellExecution.enabled": {
                type: "boolean",
                default: false,
                tags: [
                  "experimental"
                ],
                description: "%puku.config.notebook.followCellExecution%"
              },
              "puku.chat.notebook.enhancedNextEditSuggestions.enabled": {
                type: "boolean",
                default: false,
                tags: [
                  "experimental",
                  "onExp"
                ],
                description: "%puku.config.notebook.enhancedNextEditSuggestions%"
              },
              "puku.chat.summarizeAgentConversationHistory.enabled": {
                type: "boolean",
                default: true,
                tags: [
                  "experimental"
                ],
                description: "%puku.config.summarizeAgentConversationHistory.enabled%"
              },
              "puku.chat.virtualTools.threshold": {
                type: "number",
                minimum: 0,
                maximum: 128,
                default: 128,
                tags: [
                  "experimental"
                ],
                markdownDescription: "%puku.config.virtualTools.threshold%"
              },
              "puku.chat.azureModels": {
                type: "object",
                default: {},
                tags: [
                  "experimental"
                ],
                additionalProperties: {
                  type: "object",
                  properties: {
                    name: {
                      type: "string",
                      description: "Display name of the Azure model"
                    },
                    url: {
                      type: "string",
                      markdownDescription: "URL endpoint for the Azure model.\n\n**Important:** Base URLs default to Chat Completions API. Explicit API paths including `/responses` or `/chat/completions` are respected. Both behaviors are independent of the `#puku.chat.useResponsesApi#` setting."
                    },
                    toolCalling: {
                      type: "boolean",
                      description: "Whether the model supports tool calling"
                    },
                    vision: {
                      type: "boolean",
                      description: "Whether the model supports vision capabilities"
                    },
                    maxInputTokens: {
                      type: "number",
                      description: "Maximum number of input tokens supported by the model"
                    },
                    maxOutputTokens: {
                      type: "number",
                      description: "Maximum number of output tokens supported by the model"
                    },
                    thinking: {
                      type: "boolean",
                      default: false,
                      description: "Whether the model supports thinking capabilities"
                    },
                    requestHeaders: {
                      type: "object",
                      description: "Additional HTTP headers to include with requests to this model. These reserved headers are not allowed and ignored if present: forbidden request headers (https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_request_header), forwarding headers ('forwarded', 'x-forwarded-for', 'x-forwarded-host', 'x-forwarded-proto'), and others ('api-key', 'authorization', 'content-type', 'openai-intent', 'x-github-api-version', 'x-initiator', 'x-interaction-id', 'x-interaction-type', 'x-onbehalf-extension-id', 'x-request-id', 'x-vscode-user-agent-library-version'). Pattern-based forbidden headers ('proxy-*', 'sec-*', 'x-http-method*' with forbidden methods) are also blocked.",
                      additionalProperties: {
                        type: "string"
                      }
                    }
                  },
                  required: [
                    "name",
                    "url",
                    "toolCalling",
                    "vision",
                    "maxInputTokens",
                    "maxOutputTokens"
                  ],
                  additionalProperties: false
                },
                markdownDescription: "Configure custom Azure OpenAI models. Each key should be a unique model ID, and the value should be an object with model configuration including name, url, toolCalling, vision, maxInputTokens, and maxOutputTokens properties."
              },
              "puku.chat.customOAIModels": {
                type: "object",
                default: {},
                tags: [
                  "experimental"
                ],
                additionalProperties: {
                  type: "object",
                  properties: {
                    name: {
                      type: "string",
                      description: "Display name of the custom OpenAI model"
                    },
                    url: {
                      type: "string",
                      markdownDescription: "URL endpoint for the custom OpenAI-compatible model.\n\n**Important:** Base URLs default to Chat Completions API. Explicit API paths including `/responses` or `/chat/completions` are respected. Both behaviors are independent of the `#puku.chat.useResponsesApi#` setting."
                    },
                    toolCalling: {
                      type: "boolean",
                      description: "Whether the model supports tool calling"
                    },
                    vision: {
                      type: "boolean",
                      description: "Whether the model supports vision capabilities"
                    },
                    maxInputTokens: {
                      type: "number",
                      description: "Maximum number of input tokens supported by the model"
                    },
                    maxOutputTokens: {
                      type: "number",
                      description: "Maximum number of output tokens supported by the model"
                    },
                    requiresAPIKey: {
                      type: "boolean",
                      description: "Whether the model requires an API key for authentication",
                      default: true
                    },
                    editTools: {
                      type: "array",
                      description: "List of edit tools supported by the model. If this is not configured, the editor will try multiple edit tools and pick the best one.\n\n- 'find-replace': Find and replace text in a document.\n- 'multi-find-replace': Find and replace text in a document.\n- 'apply-patch': A file-oriented diff format used by some OpenAI models\n- 'code-rewrite': A general but slower editing tool that allows the model to rewrite and code snippet and provide only the replacement to the editor.",
                      items: {
                        type: "string",
                        enum: [
                          "find-replace",
                          "multi-find-replace",
                          "apply-patch",
                          "code-rewrite"
                        ]
                      }
                    },
                    thinking: {
                      type: "boolean",
                      default: false,
                      description: "Whether the model supports thinking capabilities"
                    },
                    requestHeaders: {
                      type: "object",
                      description: "Additional HTTP headers to include with requests to this model. These reserved headers are not allowed and ignored if present: forbidden request headers (https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_request_header), forwarding headers ('forwarded', 'x-forwarded-for', 'x-forwarded-host', 'x-forwarded-proto'), and others ('api-key', 'authorization', 'content-type', 'openai-intent', 'x-github-api-version', 'x-initiator', 'x-interaction-id', 'x-interaction-type', 'x-onbehalf-extension-id', 'x-request-id', 'x-vscode-user-agent-library-version'). Pattern-based forbidden headers ('proxy-*', 'sec-*', 'x-http-method*' with forbidden methods) are also blocked.",
                      additionalProperties: {
                        type: "string"
                      }
                    }
                  },
                  required: [
                    "name",
                    "url",
                    "toolCalling",
                    "vision",
                    "maxInputTokens",
                    "maxOutputTokens",
                    "requiresAPIKey"
                  ],
                  additionalProperties: false
                },
                markdownDescription: "Configure custom OpenAI-compatible models. Each key should be a unique model ID, and the value should be an object with model configuration including name, url, toolCalling, vision, maxInputTokens, and maxOutputTokens properties."
              },
              "puku.chat.alternateGptPrompt.enabled": {
                type: "boolean",
                default: false,
                tags: [
                  "experimental"
                ],
                description: "%puku.config.alternateGptPrompt.enabled%"
              },
              "puku.chat.useResponsesApi": {
                type: "boolean",
                default: true,
                markdownDescription: "%puku.config.useResponsesApi%",
                tags: [
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.responsesApiReasoningEffort": {
                type: "string",
                default: "default",
                markdownDescription: "%puku.config.responsesApiReasoningEffort%",
                tags: [
                  "experimental",
                  "onExp"
                ],
                enum: [
                  "low",
                  "medium",
                  "high",
                  "default"
                ]
              },
              "puku.chat.responsesApiReasoningSummary": {
                type: "string",
                default: "detailed",
                markdownDescription: "%puku.config.responsesApiReasoningSummary%",
                tags: [
                  "experimental",
                  "onExp"
                ],
                enum: [
                  "off",
                  "detailed"
                ]
              },
              "puku.chat.anthropic.thinking.enabled": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.anthropic.thinking.enabled%",
                tags: [
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.anthropic.thinking.maxTokens": {
                type: [
                  "number",
                  "null"
                ],
                default: null,
                markdownDescription: "%puku.config.anthropic.thinking.maxTokens%",
                minimum: 1024,
                maximum: 32e3,
                tags: [
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.anthropic.tools.websearch.enabled": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.anthropic.tools.websearch.enabled%",
                tags: [
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.anthropic.tools.websearch.maxUses": {
                type: "number",
                default: 5,
                markdownDescription: "%puku.config.anthropic.tools.websearch.maxUses%",
                minimum: 1,
                maximum: 20,
                tags: [
                  "experimental"
                ]
              },
              "puku.chat.anthropic.tools.websearch.allowedDomains": {
                type: "array",
                default: [],
                markdownDescription: "%puku.config.anthropic.tools.websearch.allowedDomains%",
                items: {
                  type: "string"
                },
                tags: [
                  "experimental"
                ]
              },
              "puku.chat.anthropic.tools.websearch.blockedDomains": {
                type: "array",
                default: [],
                markdownDescription: "%puku.config.anthropic.tools.websearch.blockedDomains%",
                items: {
                  type: "string"
                },
                tags: [
                  "experimental"
                ]
              },
              "puku.chat.anthropic.tools.websearch.userLocation": {
                type: [
                  "object",
                  "null"
                ],
                default: null,
                markdownDescription: "%puku.config.anthropic.tools.websearch.userLocation%",
                properties: {
                  city: {
                    type: "string",
                    description: "City name (e.g., 'San Francisco')"
                  },
                  region: {
                    type: "string",
                    description: "State or region (e.g., 'California')"
                  },
                  country: {
                    type: "string",
                    description: "ISO country code (e.g., 'US')"
                  },
                  timezone: {
                    type: "string",
                    description: "IANA timezone identifier (e.g., 'America/Los_Angeles')"
                  }
                },
                tags: [
                  "experimental"
                ]
              },
              "puku.chat.tools.memory.enabled": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.tools.memory.enabled%",
                tags: [
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.completionsFetcher": {
                type: [
                  "string",
                  "null"
                ],
                markdownDescription: "%puku.config.completionsFetcher%",
                tags: [
                  "experimental",
                  "onExp"
                ],
                enum: [
                  "electron-fetch",
                  "node-fetch"
                ]
              },
              "puku.chat.nesFetcher": {
                type: [
                  "string",
                  "null"
                ],
                markdownDescription: "%puku.config.nesFetcher%",
                tags: [
                  "experimental",
                  "onExp"
                ],
                enum: [
                  "electron-fetch",
                  "node-fetch"
                ]
              }
            }
          },
          {
            id: "advanced",
            properties: {
              "puku.chat.debug.overrideChatEngine": {
                type: [
                  "string",
                  "null"
                ],
                markdownDescription: "%puku.config.debug.overrideChatEngine%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.projectLabels.expanded": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.projectLabels.expanded%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.projectLabels.chat": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.projectLabels.chat%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.projectLabels.inline": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.projectLabels.inline%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.workspace.maxLocalIndexSize": {
                type: "number",
                default: 1e5,
                markdownDescription: "%puku.config.workspace.maxLocalIndexSize%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.workspace.enableFullWorkspace": {
                type: "boolean",
                default: true,
                markdownDescription: "%puku.config.workspace.enableFullWorkspace%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.workspace.enableCodeSearch": {
                type: "boolean",
                default: true,
                markdownDescription: "%puku.config.workspace.enableCodeSearch%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.workspace.enableEmbeddingsSearch": {
                type: "boolean",
                default: true,
                markdownDescription: "%puku.config.workspace.enableEmbeddingsSearch%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.workspace.preferredEmbeddingsModel": {
                type: "string",
                default: "",
                markdownDescription: "%puku.config.workspace.preferredEmbeddingsModel%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.workspace.prototypeAdoCodeSearchEndpointOverride": {
                type: "string",
                default: "",
                markdownDescription: "%puku.config.workspace.prototypeAdoCodeSearchEndpointOverride%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.feedback.onChange": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.feedback.onChange%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.review.intent": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.review.intent%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.notebook.summaryExperimentEnabled": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.notebook.summaryExperimentEnabled%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.notebook.variableFilteringEnabled": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.notebook.variableFilteringEnabled%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.notebook.alternativeFormat": {
                type: "string",
                default: "xml",
                enum: [
                  "xml",
                  "markdown"
                ],
                markdownDescription: "%puku.config.notebook.alternativeFormat%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.notebook.alternativeNESFormat.enabled": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.notebook.alternativeNESFormat.enabled%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.debugTerminalCommandPatterns": {
                type: "array",
                default: [],
                items: {
                  type: "string"
                },
                markdownDescription: "%puku.config.debugTerminalCommandPatterns%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.editSourceTracking.showDecorations": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.editSourceTracking.showDecorations%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.editSourceTracking.showStatusBar": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.editSourceTracking.showStatusBar%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.localWorkspaceRecording.enabled": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.localWorkspaceRecording.enabled%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.editRecording.enabled": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.editRecording.enabled%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.temporalContext.maxAge": {
                type: "number",
                default: 100,
                markdownDescription: "%puku.config.temporalContext.maxAge%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.temporalContext.preferSameLang": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.temporalContext.preferSameLang%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.codesearch.agent.enabled": {
                type: "boolean",
                default: true,
                markdownDescription: "%puku.config.codesearch.agent.enabled%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.agent.temperature": {
                type: [
                  "number",
                  "null"
                ],
                markdownDescription: "%puku.config.agent.temperature%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.instantApply.shortContextModelName": {
                type: "string",
                default: "gpt-4o-instant-apply-full-ft-v66-short",
                markdownDescription: "%puku.config.instantApply.shortContextModelName%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.instantApply.shortContextLimit": {
                type: "number",
                default: 8e3,
                markdownDescription: "%puku.config.instantApply.shortContextLimit%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.enableUserPreferences": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.enableUserPreferences%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.summarizeAgentConversationHistoryThreshold": {
                type: [
                  "number",
                  "null"
                ],
                markdownDescription: "%puku.config.summarizeAgentConversationHistoryThreshold%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.agentHistorySummarizationMode": {
                type: [
                  "string",
                  "null"
                ],
                markdownDescription: "%puku.config.agentHistorySummarizationMode%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.agentHistorySummarizationWithPromptCache": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.agentHistorySummarizationWithPromptCache%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.agentHistorySummarizationForceGpt41": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.agentHistorySummarizationForceGpt41%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.useResponsesApiTruncation": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.useResponsesApiTruncation%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.omitBaseAgentInstructions": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.omitBaseAgentInstructions%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.promptFileContextProvider.enabled": {
                type: "boolean",
                default: true,
                markdownDescription: "%puku.config.promptFileContextProvider.enabled%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.tools.defaultToolsGrouped": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.tools.defaultToolsGrouped%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.virtualTools.embeddingRanking": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.virtualTools.embeddingRanking%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.multiReplaceStringGrok.enabled": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.multiReplaceStringGrok.enabled%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.claudeCode.enabled": {
                type: [
                  "boolean",
                  "string"
                ],
                default: false,
                markdownDescription: "%puku.config.claudeCode.enabled%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.claudeCode.debug": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.claudeCode.debug%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.copilotCLI.enabled": {
                type: "boolean",
                default: true,
                markdownDescription: "%puku.config.copilotCLI.enabled%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.gpt5AlternativePatch": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.gpt5AlternativePatch%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.inlineEdits.triggerOnEditorChangeAfterSeconds": {
                type: [
                  "number",
                  "null"
                ],
                markdownDescription: "%puku.config.inlineEdits.triggerOnEditorChangeAfterSeconds%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.inlineEdits.nextCursorPrediction.displayLine": {
                type: "boolean",
                default: true,
                markdownDescription: "%puku.config.inlineEdits.nextCursorPrediction.displayLine%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.chat.inlineEdits.nextCursorPrediction.currentFileMaxTokens": {
                type: "number",
                default: 2e3,
                markdownDescription: "%puku.config.inlineEdits.nextCursorPrediction.currentFileMaxTokens%",
                tags: [
                  "advanced",
                  "experimental",
                  "onExp"
                ]
              },
              "puku.nes.enabled": {
                type: "boolean",
                default: false,
                markdownDescription: "Enable NES (Next Edit Suggestions) for intelligent refactoring based on edit history. This experimental feature provides context-aware code suggestions by analyzing recent edits across your workspace.",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.suggestRelatedFilesFromGitHistory.useEmbeddings": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.suggestRelatedFilesFromGitHistory.useEmbeddings%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.cli.isolation.enabled": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.cli.isolation.enabled%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              },
              "puku.chat.cli.mcp.enabled": {
                type: "boolean",
                default: false,
                markdownDescription: "%puku.config.cli.mcp.enabled%",
                tags: [
                  "advanced",
                  "experimental"
                ]
              }
            }
          }
        ],
        submenus: [
          {
            id: "copilot/reviewComment/additionalActions/applyAndNext",
            label: "%puku.submenu.reviewComment.applyAndNext.label%"
          },
          {
            id: "copilot/reviewComment/additionalActions/discardAndNext",
            label: "%puku.submenu.reviewComment.discardAndNext.label%"
          },
          {
            id: "copilot/reviewComment/additionalActions/discard",
            label: "%puku.submenu.reviewComment.discard.label%"
          },
          {
            id: "puku.chat.debug.filter",
            label: "Filter",
            icon: "$(filter)"
          },
          {
            id: "puku.chat.debug.exportAllPromptLogsAsJson",
            label: "Export All Logs as JSON",
            icon: "$(file-export)"
          }
        ],
        menus: {
          "editor/title": [
            {
              command: "puku.debug.generateInlineEditTests",
              when: "resourceScheme == 'ccreq'"
            },
            {
              command: "puku.chat.notebook.enableFollowCellExecution",
              when: "config.puku.chat.notebook.followCellExecution.enabled && !puku.notebookFollowInSessionEnabled && puku.notebookAgentModeUsage && !config.notebook.globalToolbar",
              group: "navigation@10"
            },
            {
              command: "puku.chat.notebook.disableFollowCellExecution",
              when: "config.puku.chat.notebook.followCellExecution.enabled && puku.notebookFollowInSessionEnabled && puku.notebookAgentModeUsage && !config.notebook.globalToolbar",
              group: "navigation@10"
            },
            {
              command: "puku.chat.replay",
              group: "navigation@9",
              when: "resourceFilename === 'benchRun.chatReplay.json'"
            },
            {
              command: "puku.chat.showAsChatSession",
              group: "navigation@9",
              when: "resourceFilename === 'benchRun.chatReplay.json' || resourceFilename === 'chat-export-logs.json'"
            },
            {
              command: "puku.chat.applyCopilotCLIAgentSessionChanges",
              group: "navigation@1",
              when: "resourceScheme == copilotcli-worktree-changes"
            }
          ],
          "explorer/context": [
            {
              command: "puku.chat.showAsChatSession",
              when: "resourceFilename === 'benchRun.chatReplay.json' || resourceFilename === 'chat-export-logs.json'",
              group: "2_copilot@1"
            }
          ],
          "editor/context": [
            {
              command: "puku.chat.explain",
              when: "!puku.interactiveSession.disabled",
              group: "1_chat@4"
            }
          ],
          "editor/context/chat": [
            {
              command: "puku.chat.fix",
              when: "!puku.interactiveSession.disabled && !editorReadonly",
              group: "copilotAction@1"
            },
            {
              command: "puku.chat.review",
              when: "config.puku.chat.reviewSelection.enabled && !puku.interactiveSession.disabled && resourceScheme != 'vscode-chat-code-block'",
              group: "copilotAction@2"
            },
            {
              command: "puku.chat.generateDocs",
              when: "!puku.interactiveSession.disabled && !editorReadonly",
              group: "copilotGenerate@1"
            },
            {
              command: "puku.chat.generateTests",
              when: "!puku.interactiveSession.disabled && !editorReadonly",
              group: "copilotGenerate@2"
            }
          ],
          "testing/item/result": [
            {
              command: "puku.tests.fixTestFailure.fromInline",
              when: "testResultState == failed && !testResultOutdated",
              group: "inline@2"
            }
          ],
          "testing/item/context": [
            {
              command: "puku.tests.fixTestFailure.fromInline",
              when: "testResultState == failed && !testResultOutdated",
              group: "inline@2"
            }
          ],
          commandPalette: [
            {
              command: "puku.chat.triggerPermissiveSignIn",
              when: "false"
            },
            {
              command: "puku.interactiveSession.feedback",
              when: "puku-chat.activated && !puku.interactiveSession.disabled"
            },
            {
              command: "puku.debug.workbenchState",
              when: "true"
            },
            {
              command: "puku.chat.rerunWithCopilotDebug",
              when: "false"
            },
            {
              command: "puku.chat.startCopilotDebugCommand",
              when: "false"
            },
            {
              command: "puku.git.generateCommitMessage",
              when: "false"
            },
            {
              command: "puku.git.resolveMergeConflicts",
              when: "false"
            },
            {
              command: "puku.chat.explain",
              when: "false"
            },
            {
              command: "puku.chat.review",
              when: "!puku.interactiveSession.disabled"
            },
            {
              command: "puku.chat.review.apply",
              when: "false"
            },
            {
              command: "puku.chat.review.applyAndNext",
              when: "false"
            },
            {
              command: "puku.chat.review.discard",
              when: "false"
            },
            {
              command: "puku.chat.review.discardAndNext",
              when: "false"
            },
            {
              command: "puku.chat.review.discardAll",
              when: "false"
            },
            {
              command: "puku.chat.review.stagedChanges",
              when: "false"
            },
            {
              command: "puku.chat.review.unstagedChanges",
              when: "false"
            },
            {
              command: "puku.chat.review.changes",
              when: "false"
            },
            {
              command: "puku.chat.review.stagedFileChange",
              when: "false"
            },
            {
              command: "puku.chat.review.unstagedFileChange",
              when: "false"
            },
            {
              command: "puku.chat.review.previous",
              when: "false"
            },
            {
              command: "puku.chat.review.next",
              when: "false"
            },
            {
              command: "puku.chat.review.continueInInlineChat",
              when: "false"
            },
            {
              command: "puku.chat.review.continueInChat",
              when: "false"
            },
            {
              command: "puku.chat.review.markHelpful",
              when: "false"
            },
            {
              command: "puku.chat.review.markUnhelpful",
              when: "false"
            },
            {
              command: "puku.devcontainer.generateDevContainerConfig",
              when: "false"
            },
            {
              command: "puku.tests.fixTestFailure",
              when: "false"
            },
            {
              command: "puku.tests.fixTestFailure.fromInline",
              when: "false"
            },
            {
              command: "puku.search.markHelpful",
              when: "false"
            },
            {
              command: "puku.search.markUnhelpful",
              when: "false"
            },
            {
              command: "puku.search.feedback",
              when: "false"
            },
            {
              command: "puku.chat.debug.showElements",
              when: "false"
            },
            {
              command: "puku.chat.debug.hideElements",
              when: "false"
            },
            {
              command: "puku.chat.debug.showTools",
              when: "false"
            },
            {
              command: "puku.chat.debug.hideTools",
              when: "false"
            },
            {
              command: "puku.chat.debug.showNesRequests",
              when: "false"
            },
            {
              command: "puku.chat.debug.hideNesRequests",
              when: "false"
            },
            {
              command: "puku.chat.debug.exportLogItem",
              when: "false"
            },
            {
              command: "puku.chat.debug.exportPromptArchive",
              when: "false"
            },
            {
              command: "puku.chat.debug.exportPromptLogsAsJson",
              when: "false"
            },
            {
              command: "puku.chat.debug.exportAllPromptLogsAsJson",
              when: "false"
            },
            {
              command: "puku.chat.mcp.setup.check",
              when: "false"
            },
            {
              command: "puku.chat.mcp.setup.validatePackage",
              when: "false"
            },
            {
              command: "puku.chat.mcp.setup.flow",
              when: "false"
            },
            {
              command: "puku.chat.debug.showRawRequestBody",
              when: "false"
            },
            {
              command: "puku.debug.showOutputChannel",
              when: "false"
            },
            {
              command: "puku.cli.sessions.delete",
              when: "false"
            },
            {
              command: "puku.cli.sessions.refresh",
              when: "false"
            },
            {
              command: "puku.cli.sessions.resumeInTerminal",
              when: "false"
            },
            {
              command: "puku.cli.sessions.newTerminalSession",
              when: "false"
            },
            {
              command: "puku.cloud.sessions.refresh",
              when: "false"
            },
            {
              command: "puku.cloud.sessions.openInBrowser",
              when: "false"
            },
            {
              command: "puku.cloud.sessions.proxy.closeChatSessionPullRequest",
              when: "false"
            },
            {
              command: "puku.chat.applyCopilotCLIAgentSessionChanges",
              when: "false"
            },
            {
              command: "puku.chat.showAsChatSession",
              when: "false"
            }
          ],
          "view/title": [
            {
              command: "puku.claude.sessions.refresh",
              when: "view == workbench.view.chat.sessions.claude-code",
              group: "navigation@1"
            },
            {
              command: "puku.cli.sessions.refresh",
              when: "view == workbench.view.chat.sessions.copilotcli",
              group: "navigation@1"
            },
            {
              submenu: "puku.chat.debug.filter",
              when: "view == copilot-chat",
              group: "navigation"
            },
            {
              command: "puku.chat.debug.exportAllPromptLogsAsJson",
              when: "view == copilot-chat",
              group: "export@1"
            },
            {
              command: "puku.debug.showOutputChannel",
              when: "view == copilot-chat",
              group: "3_show@1"
            },
            {
              command: "puku.debug.showChatLogView",
              when: "view == workbench.panel.chat.view.copilot",
              group: "3_show"
            },
            {
              command: "puku.cloud.sessions.refresh",
              when: "view == workbench.view.chat.sessions.copilot-cloud-agent",
              group: "navigation@1"
            }
          ],
          "view/item/context": [
            {
              command: "puku.chat.debug.showRawRequestBody",
              when: "view == copilot-chat && viewItem == request",
              group: "export@0"
            },
            {
              command: "puku.chat.debug.exportLogItem",
              when: "view == copilot-chat && (viewItem == toolcall || viewItem == request)",
              group: "export@1"
            },
            {
              command: "puku.chat.debug.exportPromptArchive",
              when: "view == copilot-chat && viewItem == chatprompt",
              group: "export@2"
            },
            {
              command: "puku.chat.debug.exportPromptLogsAsJson",
              when: "view == copilot-chat && viewItem == chatprompt",
              group: "export@3"
            }
          ],
          "searchPanel/aiResults/commands": [
            {
              command: "puku.search.markHelpful",
              group: "inline@0",
              when: "aiResultsTitle && aiResultsRequested"
            },
            {
              command: "puku.search.markUnhelpful",
              group: "inline@1",
              when: "aiResultsTitle && aiResultsRequested"
            },
            {
              command: "puku.search.feedback",
              group: "inline@2",
              when: "aiResultsTitle && aiResultsRequested && puku.debugReportFeedback"
            }
          ],
          "comments/comment/title": [
            {
              command: "puku.chat.review.markHelpful",
              group: "inline@0",
              when: "commentController == github-copilot-review"
            },
            {
              command: "puku.chat.review.markUnhelpful",
              group: "inline@1",
              when: "commentController == github-copilot-review"
            }
          ],
          "commentsView/commentThread/context": [
            {
              command: "puku.chat.review.apply",
              group: "context@1",
              when: "commentController == github-copilot-review"
            },
            {
              command: "puku.chat.review.discard",
              group: "context@2",
              when: "commentController == github-copilot-review"
            },
            {
              command: "puku.chat.review.discardAll",
              group: "context@3",
              when: "commentController == github-copilot-review"
            }
          ],
          "comments/commentThread/additionalActions": [
            {
              submenu: "copilot/reviewComment/additionalActions/applyAndNext",
              group: "inline@1",
              when: "commentController == github-copilot-review && puku.chat.review.numberOfComments > 1"
            },
            {
              command: "puku.chat.review.apply",
              group: "inline@1",
              when: "commentController == github-copilot-review && puku.chat.review.numberOfComments == 1"
            },
            {
              submenu: "copilot/reviewComment/additionalActions/discardAndNext",
              group: "inline@2",
              when: "commentController == github-copilot-review && puku.chat.review.numberOfComments > 1"
            },
            {
              submenu: "copilot/reviewComment/additionalActions/discard",
              group: "inline@2",
              when: "commentController == github-copilot-review && puku.chat.review.numberOfComments == 1"
            }
          ],
          "copilot/reviewComment/additionalActions/applyAndNext": [
            {
              command: "puku.chat.review.applyAndNext",
              group: "inline@1",
              when: "commentController == github-copilot-review"
            },
            {
              command: "puku.chat.review.apply",
              group: "inline@2",
              when: "commentController == github-copilot-review"
            }
          ],
          "copilot/reviewComment/additionalActions/discardAndNext": [
            {
              command: "puku.chat.review.discardAndNext",
              group: "inline@1",
              when: "commentController == github-copilot-review"
            },
            {
              command: "puku.chat.review.discard",
              group: "inline@2",
              when: "commentController == github-copilot-review"
            },
            {
              command: "puku.chat.review.continueInInlineChat",
              group: "inline@3",
              when: "commentController == github-copilot-review"
            }
          ],
          "copilot/reviewComment/additionalActions/discard": [
            {
              command: "puku.chat.review.discard",
              group: "inline@2",
              when: "commentController == github-copilot-review"
            },
            {
              command: "puku.chat.review.continueInInlineChat",
              group: "inline@3",
              when: "commentController == github-copilot-review"
            }
          ],
          "comments/commentThread/title": [
            {
              command: "puku.chat.review.previous",
              group: "inline@1",
              when: "commentController == github-copilot-review"
            },
            {
              command: "puku.chat.review.next",
              group: "inline@2",
              when: "commentController == github-copilot-review"
            },
            {
              command: "puku.chat.review.continueInChat",
              group: "inline@3",
              when: "commentController == github-copilot-review"
            },
            {
              command: "puku.chat.review.discardAll",
              group: "inline@4",
              when: "commentController == github-copilot-review"
            }
          ],
          "scm/title": [
            {
              command: "puku.chat.review.changes",
              group: "navigation",
              when: "config.puku.chat.reviewAgent.enabled && puku.chat.reviewDiff.enabled && scmProvider == git && scmProviderRootUri in puku.chat.reviewDiff.enabledRootUris"
            }
          ],
          "scm/resourceGroup/context": [
            {
              command: "puku.chat.review.stagedChanges",
              when: "config.puku.chat.reviewAgent.enabled && puku.chat.reviewDiff.enabled && scmProvider == git && scmResourceGroup == index",
              group: "inline@-3"
            },
            {
              command: "puku.chat.review.unstagedChanges",
              when: "config.puku.chat.reviewAgent.enabled && puku.chat.reviewDiff.enabled && scmProvider == git && scmResourceGroup == workingTree",
              group: "inline@-3"
            }
          ],
          "scm/resourceState/context": [
            {
              command: "puku.git.resolveMergeConflicts",
              when: "scmProvider == git && scmResourceGroup == merge && git.activeResourceHasMergeConflicts",
              group: "z_chat@1"
            },
            {
              command: "puku.chat.review.stagedFileChange",
              group: "3_copilot",
              when: "config.puku.chat.reviewAgent.enabled && puku.chat.reviewDiff.enabled && scmProvider == git && scmResourceGroup == index"
            },
            {
              command: "puku.chat.review.unstagedFileChange",
              group: "3_copilot",
              when: "config.puku.chat.reviewAgent.enabled && puku.chat.reviewDiff.enabled && scmProvider == git && scmResourceGroup == workingTree"
            }
          ],
          "scm/inputBox": [
            {
              command: "puku.git.generateCommitMessage",
              when: "scmProvider == git"
            }
          ],
          "testing/message/context": [
            {
              command: "puku.tests.fixTestFailure",
              when: "testing.testItemHasUri",
              group: "inline@1"
            }
          ],
          "issue/reporter": [
            {
              command: "puku.report"
            }
          ],
          "puku.chat.debug.filter": [
            {
              command: "puku.chat.debug.showElements",
              when: "puku.chat.debug.elementsHidden",
              group: "commands@0"
            },
            {
              command: "puku.chat.debug.hideElements",
              when: "!puku.chat.debug.elementsHidden",
              group: "commands@0"
            },
            {
              command: "puku.chat.debug.showTools",
              when: "puku.chat.debug.toolsHidden",
              group: "commands@1"
            },
            {
              command: "puku.chat.debug.hideTools",
              when: "!puku.chat.debug.toolsHidden",
              group: "commands@1"
            },
            {
              command: "puku.chat.debug.showNesRequests",
              when: "puku.chat.debug.nesRequestsHidden",
              group: "commands@2"
            },
            {
              command: "puku.chat.debug.hideNesRequests",
              when: "!puku.chat.debug.nesRequestsHidden",
              group: "commands@2"
            }
          ],
          "notebook/toolbar": [
            {
              command: "puku.chat.notebook.enableFollowCellExecution",
              when: "config.puku.chat.notebook.followCellExecution.enabled && !puku.notebookFollowInSessionEnabled && puku.notebookAgentModeUsage && config.notebook.globalToolbar",
              group: "navigation/execute@15"
            },
            {
              command: "puku.chat.notebook.disableFollowCellExecution",
              when: "config.puku.chat.notebook.followCellExecution.enabled && puku.notebookFollowInSessionEnabled && puku.notebookAgentModeUsage && config.notebook.globalToolbar",
              group: "navigation/execute@15"
            }
          ],
          "editor/content": [
            {
              command: "puku.git.resolveMergeConflicts",
              group: "z_chat@1",
              when: "config.git.enabled && !git.missing && !isInDiffEditor && !isMergeEditor && resource in git.mergeChanges && git.activeResourceHasMergeConflicts"
            }
          ],
          "chat/chatSessions": [
            {
              command: "puku.cli.sessions.resumeInTerminal",
              when: "chatSessionType == copilotcli",
              group: "inline@1"
            },
            {
              command: "puku.cli.sessions.delete",
              when: "chatSessionType == copilotcli",
              group: "inline@2"
            },
            {
              command: "puku.cli.sessions.newTerminalSession",
              when: "view == workbench.view.chat.sessions.copilotcli",
              group: "submenu"
            },
            {
              command: "puku.cli.sessions.refresh",
              when: "view == workbench.view.chat.sessions.copilotcli",
              group: "navigation@1"
            },
            {
              command: "puku.cloud.sessions.openInBrowser",
              when: "chatSessionType == copilot-cloud-agent",
              group: "navigation@10"
            },
            {
              command: "puku.cloud.sessions.proxy.closeChatSessionPullRequest",
              when: "chatSessionType == copilot-cloud-agent",
              group: "context"
            },
            {
              command: "puku.cli.sessions.delete",
              when: "chatSessionType == copilotcli && config.chat.agentSessionsViewLocation == 'single-view'",
              group: "context"
            }
          ]
        },
        icons: {
          "copilot-logo": {
            description: "%puku.icon%",
            default: {
              fontPath: "assets/copilot.woff",
              fontCharacter: "\\0041"
            }
          },
          "copilot-warning": {
            description: "%puku.icon%",
            default: {
              fontPath: "assets/copilot.woff",
              fontCharacter: "\\0042"
            }
          },
          "copilot-notconnected": {
            description: "%puku.icon%",
            default: {
              fontPath: "assets/copilot.woff",
              fontCharacter: "\\0043"
            }
          }
        },
        iconFonts: [
          {
            id: "copilot-font",
            src: [
              {
                path: "assets/copilot.woff",
                format: "woff"
              }
            ]
          }
        ],
        terminalQuickFixes: [
          {
            id: "copilot-chat.fixWithCopilot",
            commandLineMatcher: ".+",
            commandExitResult: "error",
            outputMatcher: {
              anchor: "bottom",
              length: 1,
              lineMatcher: ".+",
              offset: 0
            },
            kind: "explain"
          },
          {
            id: "copilot-chat.generateCommitMessage",
            commandLineMatcher: "git add .+",
            commandExitResult: "success",
            kind: "explain",
            outputMatcher: {
              anchor: "bottom",
              length: 1,
              lineMatcher: ".+",
              offset: 0
            }
          },
          {
            id: "copilot-chat.terminalToDebugging",
            commandLineMatcher: ".+",
            kind: "explain",
            commandExitResult: "error",
            outputMatcher: {
              anchor: "bottom",
              length: 1,
              lineMatcher: "",
              offset: 0
            }
          },
          {
            id: "copilot-chat.terminalToDebuggingSuccess",
            commandLineMatcher: ".+",
            kind: "explain",
            commandExitResult: "success",
            outputMatcher: {
              anchor: "bottom",
              length: 1,
              lineMatcher: "",
              offset: 0
            }
          }
        ],
        languages: [
          {
            id: "ignore",
            filenamePatterns: [
              ".pukuignore"
            ],
            aliases: []
          },
          {
            id: "markdown",
            extensions: [
              ".copilotmd"
            ]
          }
        ],
        views: {
          "copilot-chat": [
            {
              id: "copilot-chat",
              name: "Chat Debug",
              icon: "assets/debug-icon.svg",
              when: "puku.chat.showLogView"
            }
          ],
          "context-inspector": [
            {
              id: "context-inspector",
              name: "Language Context Inspector",
              icon: "$(inspect)",
              when: "puku.chat.showContextInspectorView"
            }
          ],
          agentSessions: [
            {
              id: "codex-placeholder",
              name: "OpenAI Codex",
              when: "puku.chat.codex.showPlaceholder",
              icon: "$(file)"
            },
            {
              id: "copilot-agents-placeholder",
              name: "GitHub Copilot Agents",
              when: "chatEntitlementSignedOut || !chatIsEnabled",
              icon: "$(copilot)"
            }
          ]
        },
        viewsContainers: {
          activitybar: [
            {
              id: "copilot-chat",
              title: "Chat Debug",
              icon: "assets/debug-icon.svg"
            },
            {
              id: "context-inspector",
              title: "Language Context Inspector",
              icon: "$(inspect)"
            }
          ]
        },
        configurationDefaults: {
          "workbench.editorAssociations": {
            "*.copilotmd": "vscode.markdown.preview.editor"
          }
        },
        keybindings: [
          {
            command: "puku.chat.rerunWithCopilotDebug",
            key: "ctrl+alt+.",
            mac: "cmd+alt+.",
            when: "puku-chat.activated && terminalShellIntegrationEnabled && terminalFocus && !terminalAltBufferActive"
          }
        ],
        walkthroughs: [
          {
            id: "copilotWelcome",
            title: "%puku.walkthrough.title%",
            description: "%puku.walkthrough.description%",
            when: "!isWeb",
            steps: [
              {
                id: "copilot.setup.signIn",
                title: "%puku.walkthrough.setup.signIn.title%",
                description: "%puku.walkthrough.setup.signIn.description%",
                when: "chatEntitlementSignedOut && !view.workbench.panel.chat.view.copilot.visible && !puku-chat.activated && !puku.offline && !puku.interactiveSession.individual.disabled && !puku.interactiveSession.individual.expired && !puku.interactiveSession.enterprise.disabled && !puku.interactiveSession.contactSupport",
                media: {
                  video: {
                    dark: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace.mp4",
                    light: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-light.mp4",
                    hc: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-hc.mp4",
                    hcLight: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-hclight.mp4"
                  },
                  altText: "%puku.walkthrough.panelChat.media.altText%"
                }
              },
              {
                id: "copilot.setup.signInNoAction",
                title: "%puku.walkthrough.setup.signIn.title%",
                description: "%puku.walkthrough.setup.noAction.description%",
                when: "chatEntitlementSignedOut && view.workbench.panel.chat.view.copilot.visible && !puku-chat.activated && !puku.offline && !puku.interactiveSession.individual.disabled && !puku.interactiveSession.individual.expired && !puku.interactiveSession.enterprise.disabled && !puku.interactiveSession.contactSupport",
                media: {
                  video: {
                    dark: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace.mp4",
                    light: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-light.mp4",
                    hc: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-hc.mp4",
                    hcLight: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-hclight.mp4"
                  },
                  altText: "%puku.walkthrough.panelChat.media.altText%"
                }
              },
              {
                id: "copilot.setup.signUp",
                title: "%puku.walkthrough.setup.signUp.title%",
                description: "%puku.walkthrough.setup.signUp.description%",
                when: "chatPlanCanSignUp && !view.workbench.panel.chat.view.copilot.visible && !puku-chat.activated && !puku.offline && (puku.interactiveSession.individual.disabled || puku.interactiveSession.individual.expired) && !puku.interactiveSession.enterprise.disabled && !puku.interactiveSession.contactSupport",
                media: {
                  video: {
                    dark: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace.mp4",
                    light: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-light.mp4",
                    hc: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-hc.mp4",
                    hcLight: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-hclight.mp4"
                  },
                  altText: "%puku.walkthrough.panelChat.media.altText%"
                }
              },
              {
                id: "copilot.setup.signUpNoAction",
                title: "%puku.walkthrough.setup.signUp.title%",
                description: "%puku.walkthrough.setup.noAction.description%",
                when: "chatPlanCanSignUp && view.workbench.panel.chat.view.copilot.visible && !puku-chat.activated && !puku.offline && (puku.interactiveSession.individual.disabled || puku.interactiveSession.individual.expired) && !puku.interactiveSession.enterprise.disabled && !puku.interactiveSession.contactSupport",
                media: {
                  video: {
                    dark: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace.mp4",
                    light: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-light.mp4",
                    hc: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-hc.mp4",
                    hcLight: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-hclight.mp4"
                  },
                  altText: "%puku.walkthrough.panelChat.media.altText%"
                }
              },
              {
                id: "copilot.panelChat",
                title: "%puku.walkthrough.panelChat.title%",
                description: "%puku.walkthrough.panelChat.description%",
                when: "!chatEntitlementSignedOut || chatIsEnabled ",
                media: {
                  video: {
                    dark: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace.mp4",
                    light: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-light.mp4",
                    hc: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-hc.mp4",
                    hcLight: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/workspace-hclight.mp4"
                  },
                  altText: "%puku.walkthrough.panelChat.media.altText%"
                }
              },
              {
                id: "copilot.edits",
                title: "%puku.walkthrough.edits.title%",
                description: "%puku.walkthrough.edits.description%",
                when: "!chatEntitlementSignedOut || chatIsEnabled ",
                media: {
                  video: {
                    dark: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/edits.mp4",
                    light: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/edits-light.mp4",
                    hc: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/edits-hc.mp4",
                    hcLight: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/edits-hclight.mp4"
                  },
                  altText: "%puku.walkthrough.edits.media.altText%"
                }
              },
              {
                id: "copilot.firstSuggest",
                title: "%puku.walkthrough.firstSuggest.title%",
                description: "%puku.walkthrough.firstSuggest.description%",
                when: "!chatEntitlementSignedOut || chatIsEnabled ",
                media: {
                  video: {
                    dark: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/ghost-text.mp4",
                    light: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/ghost-text-light.mp4",
                    hc: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/ghost-text-hc.mp4",
                    hcLight: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/ghost-text-hclight.mp4"
                  },
                  altText: "%puku.walkthrough.firstSuggest.media.altText%"
                }
              },
              {
                id: "copilot.inlineChatNotMac",
                title: "%puku.walkthrough.inlineChatNotMac.title%",
                description: "%puku.walkthrough.inlineChatNotMac.description%",
                when: "!isMac && (!chatEntitlementSignedOut || chatIsEnabled )",
                media: {
                  video: {
                    dark: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/inline.mp4",
                    light: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/inline-light.mp4",
                    hc: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/inline-hc.mp4",
                    hcLight: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/inline-hclight.mp4"
                  },
                  altText: "%puku.walkthrough.inlineChatNotMac.media.altText%"
                }
              },
              {
                id: "copilot.inlineChatMac",
                title: "%puku.walkthrough.inlineChatMac.title%",
                description: "%puku.walkthrough.inlineChatMac.description%",
                when: "isMac && (!chatEntitlementSignedOut || chatIsEnabled )",
                media: {
                  video: {
                    dark: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/inline.mp4",
                    light: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/inline-light.mp4",
                    hc: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/inline-hc.mp4",
                    hcLight: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/inline-hclight.mp4"
                  },
                  altText: "%puku.walkthrough.inlineChatMac.media.altText%"
                }
              },
              {
                id: "copilot.sparkle",
                title: "%puku.walkthrough.sparkle.title%",
                description: "%puku.walkthrough.sparkle.description%",
                when: "!chatEntitlementSignedOut || chatIsEnabled",
                media: {
                  video: {
                    dark: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/git-commit.mp4",
                    light: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/git-commit-light.mp4",
                    hc: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/git-commit-hc.mp4",
                    hcLight: "https://vscodewalkthroughs.z1.web.core.windows.net/v0.26/git-commit-hclight.mp4"
                  },
                  altText: "%puku.walkthrough.sparkle.media.altText%"
                }
              }
            ]
          }
        ],
        jsonValidation: [
          {
            fileMatch: "settings.json",
            url: "ccsettings://root/schema.json"
          }
        ],
        typescriptServerPlugins: [
          {
            name: "@vscode/copilot-typescript-server-plugin",
            enableForWorkspaceTypeScriptVersions: true
          }
        ],
        chatSessions: [
          {
            type: "claude-code",
            name: "claude",
            displayName: "Claude Code CLI Agent",
            icon: "$(sparkle)",
            welcomeTitle: "Claude Code Agent",
            welcomeMessage: "Run local background tasks",
            inputPlaceholder: "Describe your task, type `#` for adding context",
            order: 3,
            description: "The Claude Code Agent works on your local machine",
            when: "config.puku.chat.advanced.claudeCode.enabled",
            capabilities: {
              supportsFileAttachments: true
            },
            commands: [
              {
                name: "init",
                description: "Initialize a new CLAUDE.md file with codebase documentation"
              },
              {
                name: "compact",
                description: "Clear conversation history but keep a summary in context. Optional: /compact [instructions for summarization]"
              },
              {
                name: "pr-comments",
                description: "Get comments from a GitHub pull request"
              },
              {
                name: "review",
                description: "Review a pull request"
              },
              {
                name: "security-review",
                description: "Complete a security review of the pending changes on the current branch"
              }
            ]
          },
          {
            type: "copilotcli",
            name: "cli",
            displayName: "GitHub Copilot CLI Agent",
            icon: "$(copilot)",
            welcomeTitle: "GitHub Copilot CLI Agent",
            welcomeMessage: "Run local background tasks",
            inputPlaceholder: "Describe your task, type `#` for adding context",
            order: 2,
            description: "The GitHub Copilot CLI Agent works on your local machine",
            capabilities: {
              supportsFileAttachments: true,
              supportsProblemAttachments: true,
              supportsToolAttachments: false
            },
            commands: [
              {
                name: "delegate",
                description: "Delegate chat session to cloud agent and create associated PR"
              }
            ]
          },
          {
            type: "copilot-cloud-agent",
            alternativeIds: [
              "copilot-swe-agent"
            ],
            name: "cloud",
            displayName: "GitHub Copilot Cloud Agent",
            icon: {
              light: "assets/copilot-cloud.svg",
              dark: "assets/copilot-cloud-dark.svg"
            },
            welcomeTitle: "GitHub Copilot Cloud Agent",
            welcomeMessage: "Delegate tasks to the cloud",
            inputPlaceholder: "Describe your task, type `#` for adding context",
            order: 1,
            description: "Delegate tasks to the GitHub Copilot Cloud Agent. The agent works asynchronously in the cloud to implement changes, iterates via chat, and can create or update pull requests as needed.",
            capabilities: {
              supportsFileAttachments: true
            }
          }
        ],
        debuggers: [
          {
            type: "vscode-chat-replay",
            label: "vscode-chat-replay",
            languages: [
              "json"
            ],
            when: "resourceFilename === 'benchRun.chatReplay.json'",
            configurationAttributes: {
              launch: {
                properties: {
                  program: {
                    type: "string",
                    description: "Chat replay file to debug (parse for headers)",
                    default: "${file}"
                  },
                  stopOnEntry: {
                    type: "boolean",
                    default: true,
                    description: "Break immediately to step through manually."
                  }
                },
                required: [
                  "program"
                ]
              }
            }
          }
        ],
        chatAgents: [
          {
            name: "Plan",
            path: "./assets/agents/Plan.agent.md",
            description: "Researches a task to create multi-step plans"
          }
        ],
        chatPromptFiles: [
          {
            name: "savePrompt",
            path: "./assets/prompts/savePrompt.prompt.md",
            description: "Generalize the current discussion into a reusable prompt and save it as a file"
          }
        ]
      },
      extensionPack: [
        "GitHub.copilot"
      ],
      prettier: {
        useTabs: true,
        tabWidth: 4,
        singleQuote: true
      },
      scripts: {
        compile: "npx tsx .esbuild.ts --dev",
        build: "npx tsx .esbuild.ts",
        watch: "npx tsx .esbuild.ts --watch --dev",
        lint: 'eslint . || echo "\u26A0\uFE0F Found lint errors (non-blocking for now)"',
        "test:unit": "vitest run",
        "test:unit:watch": "vitest",
        "test:extension": "vscode-test",
        "test:simulation": "npx tsx test/testExecutor.ts",
        test: "npm run test:unit && npm run test:extension"
      },
      devDependencies: {
        "@azure/identity": "4.9.1",
        "@azure/keyvault-secrets": "^4.10.0",
        "@azure/msal-node": "^3.6.3",
        "@c4312/scip": "^0.1.0",
        "@fluentui/react-components": "^9.66.6",
        "@fluentui/react-icons": "^2.0.305",
        "@hediet/node-reload": "^0.8.0",
        "@keyv/sqlite": "^4.0.5",
        "@octokit/types": "^14.1.0",
        "@parcel/watcher": "^2.5.1",
        "@stylistic/eslint-plugin": "^3.0.1",
        "@types/eslint": "^9.0.0",
        "@types/google-protobuf": "^3.15.12",
        "@types/js-yaml": "^4.0.9",
        "@types/markdown-it": "^14.0.0",
        "@types/minimist": "^1.2.5",
        "@types/mocha": "^10.0.10",
        "@types/node": "^22.16.3",
        "@types/picomatch": "^4.0.0",
        "@types/react": "^18.2.17",
        "@types/react-dom": "^18.2.17",
        "@types/sinon": "^17.0.4",
        "@types/source-map-support": "^0.5.10",
        "@types/tar": "^6.1.13",
        "@types/vinyl": "^2.0.12",
        "@types/vscode": "^1.102.0",
        "@types/vscode-webview": "^1.57.4",
        "@types/yargs": "^17.0.24",
        "@typescript-eslint/eslint-plugin": "^8.35.0",
        "@typescript-eslint/parser": "^8.32.0",
        "@typescript-eslint/typescript-estree": "^8.26.1",
        "@vitest/coverage-v8": "^3.2.4",
        "@vitest/snapshot": "^1.5.0",
        "@vscode/debugadapter": "^1.68.0",
        "@vscode/debugprotocol": "^1.68.0",
        "@vscode/dts": "^0.4.1",
        "@vscode/lsif-language-service": "^0.1.0-pre.4",
        "@vscode/test-cli": "^0.0.11",
        "@vscode/test-electron": "^2.5.2",
        "@vscode/test-web": "^0.0.71",
        "@vscode/vsce": "3.6.0",
        copyfiles: "^2.4.1",
        "csv-parse": "^6.0.0",
        dotenv: "^17.2.0",
        electron: "^37.2.1",
        esbuild: "^0.25.6",
        eslint: "^9.30.0",
        "eslint-import-resolver-typescript": "^4.4.4",
        "eslint-plugin-header": "^3.1.1",
        "eslint-plugin-import": "^2.32.0",
        "eslint-plugin-jsdoc": "^51.3.4",
        "eslint-plugin-no-only-tests": "^3.3.0",
        fastq: "^1.19.1",
        glob: "^11.0.3",
        husky: "^9.1.7",
        "js-yaml": "^4.1.0",
        keyv: "^5.3.2",
        "lint-staged": "15.2.9",
        minimist: "^1.2.8",
        mobx: "^6.13.7",
        "mobx-react-lite": "^4.1.0",
        mocha: "^11.7.1",
        "mocha-junit-reporter": "^2.2.1",
        "mocha-multi-reporters": "^1.5.1",
        "monaco-editor": "0.44.0",
        "npm-run-all": "^4.1.5",
        open: "^10.1.2",
        openai: "^6.7.0",
        outdent: "^0.8.0",
        picomatch: "^4.0.2",
        playwright: "^1.56.1",
        prettier: "^3.6.2",
        react: "^17.0.2",
        "react-dom": "17.0.2",
        rimraf: "^6.0.1",
        "run-script-os": "^1.1.6",
        shiki: "~1.15.0",
        sinon: "^21.0.0",
        "source-map-support": "^0.5.21",
        tar: "^7.4.3",
        "ts-dedent": "^2.2.0",
        tsx: "^4.20.3",
        typescript: "^5.8.3",
        "typescript-eslint": "^8.36.0",
        "typescript-formatter": "github:jrieken/typescript-formatter#497efb26bc40b5fa59a350e6eab17bce650a7e4b",
        "vite-plugin-top-level-await": "^1.5.0",
        "vite-plugin-wasm": "^3.5.0",
        vitest: "^3.0.5",
        "vscode-languageserver-protocol": "^3.17.5",
        "vscode-languageserver-textdocument": "^1.0.12",
        "vscode-languageserver-types": "^3.17.5",
        yaml: "^2.8.0",
        yargs: "^17.7.2"
      },
      dependencies: {
        "@anthropic-ai/claude-code": "^1.0.120",
        "@anthropic-ai/sdk": "^0.68.0",
        "@github/copilot": "^0.0.356",
        "@google/genai": "^1.22.0",
        "@humanwhocodes/gitignore-to-minimatch": "1.0.2",
        "@microsoft/tiktokenizer": "^1.0.10",
        "@vscode/copilot-api": "^0.1.13",
        "@vscode/extension-telemetry": "^1.2.0",
        "@vscode/l10n": "^0.0.18",
        "@vscode/prompt-tsx": "^0.4.0-alpha.5",
        "@vscode/tree-sitter-wasm": "0.0.5-php.2",
        "@vscode/webview-ui-toolkit": "^1.3.1",
        "@xterm/headless": "^5.5.0",
        ajv: "^8.17.1",
        applicationinsights: "^2.9.7",
        diff: "^8.0.2",
        dompurify: "^3.3.0",
        ignore: "^7.0.5",
        isbinaryfile: "^5.0.4",
        "jsonc-parser": "^3.3.1",
        "lru-cache": "^11.1.0",
        "markdown-it": "^14.1.0",
        minimatch: "^10.0.3",
        "sqlite-vec": "^0.1.7-alpha.2",
        undici: "^7.11.0",
        "vscode-tas-client": "^0.1.84",
        "web-tree-sitter": "^0.23.0"
      },
      overrides: {
        "@aminya/node-gyp-build": "npm:node-gyp-build@4.8.1",
        string_decoder: "npm:string_decoder@1.2.0",
        "node-gyp": "npm:node-gyp@10.3.1"
      }
    };
  }
});

// src/util/vs/editor/common/core/ranges/offsetRange.ts
var OffsetRange;
var init_offsetRange = __esm({
  "src/util/vs/editor/common/core/ranges/offsetRange.ts"() {
    "use strict";
    init_errors();
    OffsetRange = class _OffsetRange {
      constructor(start, endExclusive) {
        this.start = start;
        this.endExclusive = endExclusive;
        if (start > endExclusive) {
          throw new BugIndicatingError(`Invalid range: ${this.toString()}`);
        }
      }
      static fromTo(start, endExclusive) {
        return new _OffsetRange(start, endExclusive);
      }
      static addRange(range, sortedRanges) {
        let i = 0;
        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {
          i++;
        }
        let j = i;
        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {
          j++;
        }
        if (i === j) {
          sortedRanges.splice(i, 0, range);
        } else {
          const start = Math.min(range.start, sortedRanges[i].start);
          const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);
          sortedRanges.splice(i, j - i, new _OffsetRange(start, end));
        }
      }
      static tryCreate(start, endExclusive) {
        if (start > endExclusive) {
          return void 0;
        }
        return new _OffsetRange(start, endExclusive);
      }
      static ofLength(length) {
        return new _OffsetRange(0, length);
      }
      static ofStartAndLength(start, length) {
        return new _OffsetRange(start, start + length);
      }
      static emptyAt(offset) {
        return new _OffsetRange(offset, offset);
      }
      get isEmpty() {
        return this.start === this.endExclusive;
      }
      delta(offset) {
        return new _OffsetRange(this.start + offset, this.endExclusive + offset);
      }
      deltaStart(offset) {
        return new _OffsetRange(this.start + offset, this.endExclusive);
      }
      deltaEnd(offset) {
        return new _OffsetRange(this.start, this.endExclusive + offset);
      }
      get length() {
        return this.endExclusive - this.start;
      }
      toString() {
        return `[${this.start}, ${this.endExclusive})`;
      }
      equals(other) {
        return this.start === other.start && this.endExclusive === other.endExclusive;
      }
      containsRange(other) {
        return this.start <= other.start && other.endExclusive <= this.endExclusive;
      }
      contains(offset) {
        return this.start <= offset && offset < this.endExclusive;
      }
      /**
       * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
       * The joined range is the smallest range that contains both ranges.
       */
      join(other) {
        return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
      }
      /**
       * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
       *
       * The resulting range is empty if the ranges do not intersect, but touch.
       * If the ranges don't even touch, the result is undefined.
       */
      intersect(other) {
        const start = Math.max(this.start, other.start);
        const end = Math.min(this.endExclusive, other.endExclusive);
        if (start <= end) {
          return new _OffsetRange(start, end);
        }
        return void 0;
      }
      intersectionLength(range) {
        const start = Math.max(this.start, range.start);
        const end = Math.min(this.endExclusive, range.endExclusive);
        return Math.max(0, end - start);
      }
      intersects(other) {
        const start = Math.max(this.start, other.start);
        const end = Math.min(this.endExclusive, other.endExclusive);
        return start < end;
      }
      intersectsOrTouches(other) {
        const start = Math.max(this.start, other.start);
        const end = Math.min(this.endExclusive, other.endExclusive);
        return start <= end;
      }
      isBefore(other) {
        return this.endExclusive <= other.start;
      }
      isAfter(other) {
        return this.start >= other.endExclusive;
      }
      slice(arr) {
        return arr.slice(this.start, this.endExclusive);
      }
      substring(str) {
        return str.substring(this.start, this.endExclusive);
      }
      /**
       * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
       * The range must not be empty.
       */
      clip(value) {
        if (this.isEmpty) {
          throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
        }
        return Math.max(this.start, Math.min(this.endExclusive - 1, value));
      }
      /**
       * Returns `r := value + k * length` such that `r` is contained in this range.
       * The range must not be empty.
       *
       * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
       */
      clipCyclic(value) {
        if (this.isEmpty) {
          throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
        }
        if (value < this.start) {
          return this.endExclusive - (this.start - value) % this.length;
        }
        if (value >= this.endExclusive) {
          return this.start + (value - this.start) % this.length;
        }
        return value;
      }
      map(f) {
        const result = [];
        for (let i = this.start; i < this.endExclusive; i++) {
          result.push(f(i));
        }
        return result;
      }
      forEach(f) {
        for (let i = this.start; i < this.endExclusive; i++) {
          f(i);
        }
      }
      /**
       * this: [ 5, 10), range: [10, 15) => [5, 15)]
       * Throws if the ranges are not touching.
      */
      joinRightTouching(range) {
        if (this.endExclusive !== range.start) {
          throw new BugIndicatingError(`Invalid join: ${this.toString()} and ${range.toString()}`);
        }
        return new _OffsetRange(this.start, range.endExclusive);
      }
    };
  }
});

// src/util/vs/editor/common/core/position.ts
var position_exports = {};
__export(position_exports, {
  Position: () => Position
});
var Position;
var init_position = __esm({
  "src/util/vs/editor/common/core/position.ts"() {
    "use strict";
    Position = class _Position {
      constructor(lineNumber, column) {
        this.lineNumber = lineNumber;
        this.column = column;
      }
      /**
       * Create a new position from this position.
       *
       * @param newLineNumber new line number
       * @param newColumn new column
       */
      with(newLineNumber = this.lineNumber, newColumn = this.column) {
        if (newLineNumber === this.lineNumber && newColumn === this.column) {
          return this;
        } else {
          return new _Position(newLineNumber, newColumn);
        }
      }
      /**
       * Derive a new position from this position.
       *
       * @param deltaLineNumber line number delta
       * @param deltaColumn column delta
       */
      delta(deltaLineNumber = 0, deltaColumn = 0) {
        return this.with(Math.max(1, this.lineNumber + deltaLineNumber), Math.max(1, this.column + deltaColumn));
      }
      /**
       * Test if this position equals other position
       */
      equals(other) {
        return _Position.equals(this, other);
      }
      /**
       * Test if position `a` equals position `b`
       */
      static equals(a, b) {
        if (!a && !b) {
          return true;
        }
        return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;
      }
      /**
       * Test if this position is before other position.
       * If the two positions are equal, the result will be false.
       */
      isBefore(other) {
        return _Position.isBefore(this, other);
      }
      /**
       * Test if position `a` is before position `b`.
       * If the two positions are equal, the result will be false.
       */
      static isBefore(a, b) {
        if (a.lineNumber < b.lineNumber) {
          return true;
        }
        if (b.lineNumber < a.lineNumber) {
          return false;
        }
        return a.column < b.column;
      }
      /**
       * Test if this position is before other position.
       * If the two positions are equal, the result will be true.
       */
      isBeforeOrEqual(other) {
        return _Position.isBeforeOrEqual(this, other);
      }
      /**
       * Test if position `a` is before position `b`.
       * If the two positions are equal, the result will be true.
       */
      static isBeforeOrEqual(a, b) {
        if (a.lineNumber < b.lineNumber) {
          return true;
        }
        if (b.lineNumber < a.lineNumber) {
          return false;
        }
        return a.column <= b.column;
      }
      /**
       * A function that compares positions, useful for sorting
       */
      static compare(a, b) {
        const aLineNumber = a.lineNumber | 0;
        const bLineNumber = b.lineNumber | 0;
        if (aLineNumber === bLineNumber) {
          const aColumn = a.column | 0;
          const bColumn = b.column | 0;
          return aColumn - bColumn;
        }
        return aLineNumber - bLineNumber;
      }
      /**
       * Clone this position.
       */
      clone() {
        return new _Position(this.lineNumber, this.column);
      }
      /**
       * Convert to a human-readable representation.
       */
      toString() {
        return "(" + this.lineNumber + "," + this.column + ")";
      }
      // ---
      /**
       * Create a `Position` from an `IPosition`.
       */
      static lift(pos) {
        return new _Position(pos.lineNumber, pos.column);
      }
      /**
       * Test if `obj` is an `IPosition`.
       */
      static isIPosition(obj) {
        return !!obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
      }
      toJSON() {
        return {
          lineNumber: this.lineNumber,
          column: this.column
        };
      }
    };
  }
});

// src/util/vs/editor/common/core/range.ts
var range_exports = {};
__export(range_exports, {
  Range: () => Range
});
var Range;
var init_range = __esm({
  "src/util/vs/editor/common/core/range.ts"() {
    "use strict";
    init_position();
    Range = class _Range {
      constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
        if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
          this.startLineNumber = endLineNumber;
          this.startColumn = endColumn;
          this.endLineNumber = startLineNumber;
          this.endColumn = startColumn;
        } else {
          this.startLineNumber = startLineNumber;
          this.startColumn = startColumn;
          this.endLineNumber = endLineNumber;
          this.endColumn = endColumn;
        }
      }
      /**
       * Test if this range is empty.
       */
      isEmpty() {
        return _Range.isEmpty(this);
      }
      /**
       * Test if `range` is empty.
       */
      static isEmpty(range) {
        return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
      }
      /**
       * Test if position is in this range. If the position is at the edges, will return true.
       */
      containsPosition(position) {
        return _Range.containsPosition(this, position);
      }
      /**
       * Test if `position` is in `range`. If the position is at the edges, will return true.
       */
      static containsPosition(range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
          return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
          return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if `position` is in `range`. If the position is at the edges, will return false.
       * @internal
       */
      static strictContainsPosition(range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
          return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
          return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if range is in this range. If the range is equal to this range, will return true.
       */
      containsRange(range) {
        return _Range.containsRange(this, range);
      }
      /**
       * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
       */
      static containsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
          return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
       */
      strictContainsRange(range) {
        return _Range.strictContainsRange(this, range);
      }
      /**
       * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
       */
      static strictContainsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
          return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * A reunion of the two ranges.
       * The smallest position will be used as the start point, and the largest one as the end point.
       */
      plusRange(range) {
        return _Range.plusRange(this, range);
      }
      /**
       * A reunion of the two ranges.
       * The smallest position will be used as the start point, and the largest one as the end point.
       */
      static plusRange(a, b) {
        let startLineNumber;
        let startColumn;
        let endLineNumber;
        let endColumn;
        if (b.startLineNumber < a.startLineNumber) {
          startLineNumber = b.startLineNumber;
          startColumn = b.startColumn;
        } else if (b.startLineNumber === a.startLineNumber) {
          startLineNumber = b.startLineNumber;
          startColumn = Math.min(b.startColumn, a.startColumn);
        } else {
          startLineNumber = a.startLineNumber;
          startColumn = a.startColumn;
        }
        if (b.endLineNumber > a.endLineNumber) {
          endLineNumber = b.endLineNumber;
          endColumn = b.endColumn;
        } else if (b.endLineNumber === a.endLineNumber) {
          endLineNumber = b.endLineNumber;
          endColumn = Math.max(b.endColumn, a.endColumn);
        } else {
          endLineNumber = a.endLineNumber;
          endColumn = a.endColumn;
        }
        return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      /**
       * A intersection of the two ranges.
       */
      intersectRanges(range) {
        return _Range.intersectRanges(this, range);
      }
      /**
       * A intersection of the two ranges.
       */
      static intersectRanges(a, b) {
        let resultStartLineNumber = a.startLineNumber;
        let resultStartColumn = a.startColumn;
        let resultEndLineNumber = a.endLineNumber;
        let resultEndColumn = a.endColumn;
        const otherStartLineNumber = b.startLineNumber;
        const otherStartColumn = b.startColumn;
        const otherEndLineNumber = b.endLineNumber;
        const otherEndColumn = b.endColumn;
        if (resultStartLineNumber < otherStartLineNumber) {
          resultStartLineNumber = otherStartLineNumber;
          resultStartColumn = otherStartColumn;
        } else if (resultStartLineNumber === otherStartLineNumber) {
          resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
        }
        if (resultEndLineNumber > otherEndLineNumber) {
          resultEndLineNumber = otherEndLineNumber;
          resultEndColumn = otherEndColumn;
        } else if (resultEndLineNumber === otherEndLineNumber) {
          resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
        }
        if (resultStartLineNumber > resultEndLineNumber) {
          return null;
        }
        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
          return null;
        }
        return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
      }
      /**
       * Test if this range equals other.
       */
      equalsRange(other) {
        return _Range.equalsRange(this, other);
      }
      /**
       * Test if range `a` equals `b`.
       */
      static equalsRange(a, b) {
        if (!a && !b) {
          return true;
        }
        return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;
      }
      /**
       * Return the end position (which will be after or equal to the start position)
       */
      getEndPosition() {
        return _Range.getEndPosition(this);
      }
      /**
       * Return the end position (which will be after or equal to the start position)
       */
      static getEndPosition(range) {
        return new Position(range.endLineNumber, range.endColumn);
      }
      /**
       * Return the start position (which will be before or equal to the end position)
       */
      getStartPosition() {
        return _Range.getStartPosition(this);
      }
      /**
       * Return the start position (which will be before or equal to the end position)
       */
      static getStartPosition(range) {
        return new Position(range.startLineNumber, range.startColumn);
      }
      /**
       * Transform to a user presentable string representation.
       */
      toString() {
        return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
      }
      /**
       * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
       */
      setEndPosition(endLineNumber, endColumn) {
        return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
      }
      /**
       * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
       */
      setStartPosition(startLineNumber, startColumn) {
        return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
      }
      /**
       * Create a new empty range using this range's start position.
       */
      collapseToStart() {
        return _Range.collapseToStart(this);
      }
      /**
       * Create a new empty range using this range's start position.
       */
      static collapseToStart(range) {
        return new _Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
      }
      /**
       * Create a new empty range using this range's end position.
       */
      collapseToEnd() {
        return _Range.collapseToEnd(this);
      }
      /**
       * Create a new empty range using this range's end position.
       */
      static collapseToEnd(range) {
        return new _Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
      }
      /**
       * Moves the range by the given amount of lines.
       */
      delta(lineCount) {
        return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
      }
      isSingleLine() {
        return this.startLineNumber === this.endLineNumber;
      }
      // ---
      static fromPositions(start, end = start) {
        return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
      }
      static lift(range) {
        if (!range) {
          return null;
        }
        return new _Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
      }
      /**
       * Test if `obj` is an `IRange`.
       */
      static isIRange(obj) {
        return !!obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
      }
      /**
       * Test if the two ranges are touching in any way.
       */
      static areIntersectingOrTouching(a, b) {
        if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {
          return false;
        }
        if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if the two ranges are intersecting. If the ranges are touching it returns true.
       */
      static areIntersecting(a, b) {
        if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {
          return false;
        }
        if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if the two ranges are intersecting, but not touching at all.
       */
      static areOnlyIntersecting(a, b) {
        if (a.endLineNumber < b.startLineNumber - 1 || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn - 1) {
          return false;
        }
        if (b.endLineNumber < a.startLineNumber - 1 || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn - 1) {
          return false;
        }
        return true;
      }
      /**
       * A function that compares ranges, useful for sorting ranges
       * It will first compare ranges on the startPosition and then on the endPosition
       */
      static compareRangesUsingStarts(a, b) {
        if (a && b) {
          const aStartLineNumber = a.startLineNumber | 0;
          const bStartLineNumber = b.startLineNumber | 0;
          if (aStartLineNumber === bStartLineNumber) {
            const aStartColumn = a.startColumn | 0;
            const bStartColumn = b.startColumn | 0;
            if (aStartColumn === bStartColumn) {
              const aEndLineNumber = a.endLineNumber | 0;
              const bEndLineNumber = b.endLineNumber | 0;
              if (aEndLineNumber === bEndLineNumber) {
                const aEndColumn = a.endColumn | 0;
                const bEndColumn = b.endColumn | 0;
                return aEndColumn - bEndColumn;
              }
              return aEndLineNumber - bEndLineNumber;
            }
            return aStartColumn - bStartColumn;
          }
          return aStartLineNumber - bStartLineNumber;
        }
        const aExists = a ? 1 : 0;
        const bExists = b ? 1 : 0;
        return aExists - bExists;
      }
      /**
       * A function that compares ranges, useful for sorting ranges
       * It will first compare ranges on the endPosition and then on the startPosition
       */
      static compareRangesUsingEnds(a, b) {
        if (a.endLineNumber === b.endLineNumber) {
          if (a.endColumn === b.endColumn) {
            if (a.startLineNumber === b.startLineNumber) {
              return a.startColumn - b.startColumn;
            }
            return a.startLineNumber - b.startLineNumber;
          }
          return a.endColumn - b.endColumn;
        }
        return a.endLineNumber - b.endLineNumber;
      }
      /**
       * Test if the range spans multiple lines.
       */
      static spansMultipleLines(range) {
        return range.endLineNumber > range.startLineNumber;
      }
      toJSON() {
        return this;
      }
    };
  }
});

// src/util/vs/editor/common/core/ranges/lineRange.ts
var LineRange, LineRangeSet;
var init_lineRange = __esm({
  "src/util/vs/editor/common/core/ranges/lineRange.ts"() {
    "use strict";
    init_errors();
    init_offsetRange();
    init_range();
    init_arraysFind();
    init_arrays();
    LineRange = class _LineRange {
      static ofLength(startLineNumber, length) {
        return new _LineRange(startLineNumber, startLineNumber + length);
      }
      static fromRange(range) {
        return new _LineRange(range.startLineNumber, range.endLineNumber);
      }
      static fromRangeInclusive(range) {
        return new _LineRange(range.startLineNumber, range.endLineNumber + 1);
      }
      static {
        this.compareByStart = compareBy((l) => l.startLineNumber, numberComparator);
      }
      static subtract(a, b) {
        if (!b) {
          return [a];
        }
        if (a.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a.endLineNumberExclusive) {
          return [
            new _LineRange(a.startLineNumber, b.startLineNumber),
            new _LineRange(b.endLineNumberExclusive, a.endLineNumberExclusive)
          ];
        } else if (b.startLineNumber <= a.startLineNumber && a.endLineNumberExclusive <= b.endLineNumberExclusive) {
          return [];
        } else if (b.endLineNumberExclusive < a.endLineNumberExclusive) {
          return [new _LineRange(Math.max(b.endLineNumberExclusive, a.startLineNumber), a.endLineNumberExclusive)];
        } else {
          return [new _LineRange(a.startLineNumber, Math.min(b.startLineNumber, a.endLineNumberExclusive))];
        }
      }
      /**
       * @param lineRanges An array of arrays of of sorted line ranges.
       */
      static joinMany(lineRanges) {
        if (lineRanges.length === 0) {
          return [];
        }
        let result = new LineRangeSet(lineRanges[0].slice());
        for (let i = 1; i < lineRanges.length; i++) {
          result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));
        }
        return result.ranges;
      }
      static join(lineRanges) {
        if (lineRanges.length === 0) {
          throw new BugIndicatingError("lineRanges cannot be empty");
        }
        let startLineNumber = lineRanges[0].startLineNumber;
        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;
        for (let i = 1; i < lineRanges.length; i++) {
          startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);
          endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);
        }
        return new _LineRange(startLineNumber, endLineNumberExclusive);
      }
      /**
       * @internal
       */
      static deserialize(lineRange) {
        return new _LineRange(lineRange[0], lineRange[1]);
      }
      constructor(startLineNumber, endLineNumberExclusive) {
        if (startLineNumber > endLineNumberExclusive) {
          throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
        }
        this.startLineNumber = startLineNumber;
        this.endLineNumberExclusive = endLineNumberExclusive;
      }
      /**
       * Indicates if this line range contains the given line number.
       */
      contains(lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
      }
      containsRange(range) {
        return this.startLineNumber <= range.startLineNumber && range.endLineNumberExclusive <= this.endLineNumberExclusive;
      }
      /**
       * Indicates if this line range is empty.
       */
      get isEmpty() {
        return this.startLineNumber === this.endLineNumberExclusive;
      }
      /**
       * Moves this line range by the given offset of line numbers.
       */
      delta(offset) {
        return new _LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
      }
      deltaLength(offset) {
        return new _LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);
      }
      /**
       * The number of lines this line range spans.
       */
      get length() {
        return this.endLineNumberExclusive - this.startLineNumber;
      }
      /**
       * Creates a line range that combines this and the given line range.
       */
      join(other) {
        return new _LineRange(
          Math.min(this.startLineNumber, other.startLineNumber),
          Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive)
        );
      }
      toString() {
        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
      }
      /**
       * The resulting range is empty if the ranges do not intersect, but touch.
       * If the ranges don't even touch, the result is undefined.
       */
      intersect(other) {
        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
        if (startLineNumber <= endLineNumberExclusive) {
          return new _LineRange(startLineNumber, endLineNumberExclusive);
        }
        return void 0;
      }
      intersectsStrict(other) {
        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
      }
      intersectsOrTouches(other) {
        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
      }
      equals(b) {
        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;
      }
      toInclusiveRange() {
        if (this.isEmpty) {
          return null;
        }
        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
      }
      /**
       * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!
      */
      toExclusiveRange() {
        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
      }
      mapToLineArray(f) {
        const result = [];
        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
          result.push(f(lineNumber));
        }
        return result;
      }
      forEach(f) {
        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
          f(lineNumber);
        }
      }
      /**
       * @internal
       */
      serialize() {
        return [this.startLineNumber, this.endLineNumberExclusive];
      }
      /**
       * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
       * @internal
       */
      toOffsetRange() {
        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
      }
      distanceToRange(other) {
        if (this.endLineNumberExclusive <= other.startLineNumber) {
          return other.startLineNumber - this.endLineNumberExclusive;
        }
        if (other.endLineNumberExclusive <= this.startLineNumber) {
          return this.startLineNumber - other.endLineNumberExclusive;
        }
        return 0;
      }
      distanceToLine(lineNumber) {
        if (this.contains(lineNumber)) {
          return 0;
        }
        if (lineNumber < this.startLineNumber) {
          return this.startLineNumber - lineNumber;
        }
        return lineNumber - this.endLineNumberExclusive;
      }
      addMargin(marginTop, marginBottom) {
        return new _LineRange(
          this.startLineNumber - marginTop,
          this.endLineNumberExclusive + marginBottom
        );
      }
    };
    LineRangeSet = class _LineRangeSet {
      constructor(_normalizedRanges = []) {
        this._normalizedRanges = _normalizedRanges;
      }
      get ranges() {
        return this._normalizedRanges;
      }
      addRange(range) {
        if (range.length === 0) {
          return;
        }
        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range.startLineNumber);
        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range.endLineNumberExclusive) + 1;
        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
          this._normalizedRanges.splice(joinRangeStartIdx, 0, range);
        } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {
          const joinRange = this._normalizedRanges[joinRangeStartIdx];
          this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);
        } else {
          const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);
          this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);
        }
      }
      contains(lineNumber) {
        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= lineNumber);
        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;
      }
      intersects(range) {
        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) => r.startLineNumber < range.endLineNumberExclusive);
        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;
      }
      getUnion(other) {
        if (this._normalizedRanges.length === 0) {
          return other;
        }
        if (other._normalizedRanges.length === 0) {
          return this;
        }
        const result = [];
        let i1 = 0;
        let i2 = 0;
        let current = null;
        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {
          let next = null;
          if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
            const lineRange1 = this._normalizedRanges[i1];
            const lineRange2 = other._normalizedRanges[i2];
            if (lineRange1.startLineNumber < lineRange2.startLineNumber) {
              next = lineRange1;
              i1++;
            } else {
              next = lineRange2;
              i2++;
            }
          } else if (i1 < this._normalizedRanges.length) {
            next = this._normalizedRanges[i1];
            i1++;
          } else {
            next = other._normalizedRanges[i2];
            i2++;
          }
          if (current === null) {
            current = next;
          } else {
            if (current.endLineNumberExclusive >= next.startLineNumber) {
              current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));
            } else {
              result.push(current);
              current = next;
            }
          }
        }
        if (current !== null) {
          result.push(current);
        }
        return new _LineRangeSet(result);
      }
      /**
       * Subtracts all ranges in this set from `range` and returns the result.
       */
      subtractFrom(range) {
        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range.startLineNumber);
        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range.endLineNumberExclusive) + 1;
        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
          return new _LineRangeSet([range]);
        }
        const result = [];
        let startLineNumber = range.startLineNumber;
        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {
          const r = this._normalizedRanges[i];
          if (r.startLineNumber > startLineNumber) {
            result.push(new LineRange(startLineNumber, r.startLineNumber));
          }
          startLineNumber = r.endLineNumberExclusive;
        }
        if (startLineNumber < range.endLineNumberExclusive) {
          result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));
        }
        return new _LineRangeSet(result);
      }
      toString() {
        return this._normalizedRanges.map((r) => r.toString()).join(", ");
      }
      getIntersection(other) {
        const result = [];
        let i1 = 0;
        let i2 = 0;
        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
          const r1 = this._normalizedRanges[i1];
          const r2 = other._normalizedRanges[i2];
          const i = r1.intersect(r2);
          if (i && !i.isEmpty) {
            result.push(i);
          }
          if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {
            i1++;
          } else {
            i2++;
          }
        }
        return new _LineRangeSet(result);
      }
      getWithDelta(value) {
        return new _LineRangeSet(this._normalizedRanges.map((r) => r.delta(value)));
      }
    };
  }
});

// src/util/vs/editor/common/core/text/textLength.ts
var textLength_exports = {};
__export(textLength_exports, {
  TextLength: () => TextLength
});
var TextLength;
var init_textLength = __esm({
  "src/util/vs/editor/common/core/text/textLength.ts"() {
    "use strict";
    init_lineRange();
    init_position();
    init_range();
    TextLength = class _TextLength {
      constructor(lineCount, columnCount) {
        this.lineCount = lineCount;
        this.columnCount = columnCount;
      }
      static {
        this.zero = new _TextLength(0, 0);
      }
      static lengthDiffNonNegative(start, end) {
        if (end.isLessThan(start)) {
          return _TextLength.zero;
        }
        if (start.lineCount === end.lineCount) {
          return new _TextLength(0, end.columnCount - start.columnCount);
        } else {
          return new _TextLength(end.lineCount - start.lineCount, end.columnCount);
        }
      }
      static betweenPositions(position1, position2) {
        if (position1.lineNumber === position2.lineNumber) {
          return new _TextLength(0, position2.column - position1.column);
        } else {
          return new _TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);
        }
      }
      static fromPosition(pos) {
        return new _TextLength(pos.lineNumber - 1, pos.column - 1);
      }
      static ofRange(range) {
        return _TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());
      }
      static ofText(text2) {
        let line = 0;
        let column = 0;
        for (const c of text2) {
          if (c === "\n") {
            line++;
            column = 0;
          } else {
            column++;
          }
        }
        return new _TextLength(line, column);
      }
      static ofSubstr(str, range) {
        return _TextLength.ofText(range.substring(str));
      }
      static sum(fragments, getLength) {
        return fragments.reduce((acc, f) => acc.add(getLength(f)), _TextLength.zero);
      }
      isZero() {
        return this.lineCount === 0 && this.columnCount === 0;
      }
      isLessThan(other) {
        if (this.lineCount !== other.lineCount) {
          return this.lineCount < other.lineCount;
        }
        return this.columnCount < other.columnCount;
      }
      isGreaterThan(other) {
        if (this.lineCount !== other.lineCount) {
          return this.lineCount > other.lineCount;
        }
        return this.columnCount > other.columnCount;
      }
      isGreaterThanOrEqualTo(other) {
        if (this.lineCount !== other.lineCount) {
          return this.lineCount > other.lineCount;
        }
        return this.columnCount >= other.columnCount;
      }
      equals(other) {
        return this.lineCount === other.lineCount && this.columnCount === other.columnCount;
      }
      compare(other) {
        if (this.lineCount !== other.lineCount) {
          return this.lineCount - other.lineCount;
        }
        return this.columnCount - other.columnCount;
      }
      add(other) {
        if (other.lineCount === 0) {
          return new _TextLength(this.lineCount, this.columnCount + other.columnCount);
        } else {
          return new _TextLength(this.lineCount + other.lineCount, other.columnCount);
        }
      }
      createRange(startPosition) {
        if (this.lineCount === 0) {
          return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);
        } else {
          return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);
        }
      }
      toRange() {
        return new Range(1, 1, this.lineCount + 1, this.columnCount + 1);
      }
      toLineRange() {
        return LineRange.ofLength(1, this.lineCount + 1);
      }
      addToPosition(position) {
        if (this.lineCount === 0) {
          return new Position(position.lineNumber, position.column + this.columnCount);
        } else {
          return new Position(position.lineNumber + this.lineCount, this.columnCount + 1);
        }
      }
      addToRange(range) {
        return Range.fromPositions(
          this.addToPosition(range.getStartPosition()),
          this.addToPosition(range.getEndPosition())
        );
      }
      toString() {
        return `${this.lineCount},${this.columnCount}`;
      }
    };
  }
});

// src/util/vs/base/common/arrays.js
var require_arrays = __commonJS({
  "src/util/vs/base/common/arrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Permutation = exports.CallbackIterable = exports.ArrayQueue = exports.booleanComparator = exports.numberComparator = exports.CompareResult = void 0;
    exports.tail = tail;
    exports.equals = equals3;
    exports.removeFastWithoutKeepingOrder = removeFastWithoutKeepingOrder;
    exports.binarySearch = binarySearch;
    exports.binarySearch2 = binarySearch2;
    exports.quickSelect = quickSelect;
    exports.groupBy = groupBy2;
    exports.groupAdjacentBy = groupAdjacentBy2;
    exports.forEachAdjacent = forEachAdjacent;
    exports.forEachWithNeighbors = forEachWithNeighbors;
    exports.concatArrays = concatArrays;
    exports.sortedDiff = sortedDiff;
    exports.delta = delta;
    exports.top = top;
    exports.topAsync = topAsync;
    exports.coalesce = coalesce2;
    exports.coalesceInPlace = coalesceInPlace;
    exports.move = move;
    exports.isFalsyOrEmpty = isFalsyOrEmpty;
    exports.isNonEmptyArray = isNonEmptyArray;
    exports.distinct = distinct2;
    exports.uniqueFilter = uniqueFilter2;
    exports.commonPrefixLength = commonPrefixLength2;
    exports.range = range;
    exports.index = index;
    exports.insert = insert;
    exports.remove = remove;
    exports.arrayInsert = arrayInsert2;
    exports.shuffle = shuffle;
    exports.pushToStart = pushToStart;
    exports.pushToEnd = pushToEnd;
    exports.pushMany = pushMany;
    exports.mapArrayOrNot = mapArrayOrNot;
    exports.asArray = asArray;
    exports.getRandomElement = getRandomElement;
    exports.insertInto = insertInto;
    exports.splice = splice;
    exports.compareBy = compareBy2;
    exports.tieBreakComparators = tieBreakComparators;
    exports.reverseOrder = reverseOrder;
    exports.compareUndefinedSmallest = compareUndefinedSmallest;
    exports.findAsync = findAsync;
    exports.sum = sum2;
    exports.sumBy = sumBy2;
    var arraysFind_1 = (init_arraysFind(), __toCommonJS(arraysFind_exports));
    var errors_1 = (init_errors(), __toCommonJS(errors_exports));
    function tail(arr) {
      if (arr.length === 0) {
        throw new Error("Invalid tail call");
      }
      return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
    }
    function equals3(one, other, itemEquals = (a, b) => a === b) {
      if (one === other) {
        return true;
      }
      if (!one || !other) {
        return false;
      }
      if (one.length !== other.length) {
        return false;
      }
      for (let i = 0, len = one.length; i < len; i++) {
        if (!itemEquals(one[i], other[i])) {
          return false;
        }
      }
      return true;
    }
    function removeFastWithoutKeepingOrder(array, index2) {
      const last = array.length - 1;
      if (index2 < last) {
        array[index2] = array[last];
      }
      array.pop();
    }
    function binarySearch(array, key, comparator) {
      return binarySearch2(array.length, (i) => comparator(array[i], key));
    }
    function binarySearch2(length, compareToKey) {
      let low = 0, high = length - 1;
      while (low <= high) {
        const mid = (low + high) / 2 | 0;
        const comp = compareToKey(mid);
        if (comp < 0) {
          low = mid + 1;
        } else if (comp > 0) {
          high = mid - 1;
        } else {
          return mid;
        }
      }
      return -(low + 1);
    }
    function quickSelect(nth, data, compare2) {
      nth = nth | 0;
      if (nth >= data.length) {
        throw new TypeError("invalid index");
      }
      const pivotValue = data[Math.floor(data.length * Math.random())];
      const lower = [];
      const higher = [];
      const pivots = [];
      for (const value of data) {
        const val = compare2(value, pivotValue);
        if (val < 0) {
          lower.push(value);
        } else if (val > 0) {
          higher.push(value);
        } else {
          pivots.push(value);
        }
      }
      if (nth < lower.length) {
        return quickSelect(nth, lower, compare2);
      } else if (nth < lower.length + pivots.length) {
        return pivots[0];
      } else {
        return quickSelect(nth - (lower.length + pivots.length), higher, compare2);
      }
    }
    function groupBy2(data, compare2) {
      const result = [];
      let currentGroup = void 0;
      for (const element of data.slice(0).sort(compare2)) {
        if (!currentGroup || compare2(currentGroup[0], element) !== 0) {
          currentGroup = [element];
          result.push(currentGroup);
        } else {
          currentGroup.push(element);
        }
      }
      return result;
    }
    function* groupAdjacentBy2(items, shouldBeGrouped) {
      let currentGroup;
      let last;
      for (const item of items) {
        if (last !== void 0 && shouldBeGrouped(last, item)) {
          currentGroup.push(item);
        } else {
          if (currentGroup) {
            yield currentGroup;
          }
          currentGroup = [item];
        }
        last = item;
      }
      if (currentGroup) {
        yield currentGroup;
      }
    }
    function forEachAdjacent(arr, f) {
      for (let i = 0; i <= arr.length; i++) {
        f(i === 0 ? void 0 : arr[i - 1], i === arr.length ? void 0 : arr[i]);
      }
    }
    function forEachWithNeighbors(arr, f) {
      for (let i = 0; i < arr.length; i++) {
        f(i === 0 ? void 0 : arr[i - 1], arr[i], i + 1 === arr.length ? void 0 : arr[i + 1]);
      }
    }
    function concatArrays(...arrays) {
      return [].concat(...arrays);
    }
    function sortedDiff(before, after, compare2) {
      const result = [];
      function pushSplice(start, deleteCount, toInsert) {
        if (deleteCount === 0 && toInsert.length === 0) {
          return;
        }
        const latest = result[result.length - 1];
        if (latest && latest.start + latest.deleteCount === start) {
          latest.deleteCount += deleteCount;
          latest.toInsert.push(...toInsert);
        } else {
          result.push({ start, deleteCount, toInsert });
        }
      }
      let beforeIdx = 0;
      let afterIdx = 0;
      while (true) {
        if (beforeIdx === before.length) {
          pushSplice(beforeIdx, 0, after.slice(afterIdx));
          break;
        }
        if (afterIdx === after.length) {
          pushSplice(beforeIdx, before.length - beforeIdx, []);
          break;
        }
        const beforeElement = before[beforeIdx];
        const afterElement = after[afterIdx];
        const n = compare2(beforeElement, afterElement);
        if (n === 0) {
          beforeIdx += 1;
          afterIdx += 1;
        } else if (n < 0) {
          pushSplice(beforeIdx, 1, []);
          beforeIdx += 1;
        } else if (n > 0) {
          pushSplice(beforeIdx, 0, [afterElement]);
          afterIdx += 1;
        }
      }
      return result;
    }
    function delta(before, after, compare2) {
      const splices = sortedDiff(before, after, compare2);
      const removed = [];
      const added = [];
      for (const splice2 of splices) {
        removed.push(...before.slice(splice2.start, splice2.start + splice2.deleteCount));
        added.push(...splice2.toInsert);
      }
      return { removed, added };
    }
    function top(array, compare2, n) {
      if (n === 0) {
        return [];
      }
      const result = array.slice(0, n).sort(compare2);
      topStep(array, compare2, result, n, array.length);
      return result;
    }
    function topAsync(array, compare2, n, batch, token) {
      if (n === 0) {
        return Promise.resolve([]);
      }
      return new Promise((resolve2, reject) => {
        (async () => {
          const o = array.length;
          const result = array.slice(0, n).sort(compare2);
          for (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {
            if (i > n) {
              await new Promise((resolve3) => setTimeout(resolve3));
            }
            if (token && token.isCancellationRequested) {
              throw new errors_1.CancellationError();
            }
            topStep(array, compare2, result, i, m);
          }
          return result;
        })().then(resolve2, reject);
      });
    }
    function topStep(array, compare2, result, i, m) {
      for (const n = result.length; i < m; i++) {
        const element = array[i];
        if (compare2(element, result[n - 1]) < 0) {
          result.pop();
          const j = (0, arraysFind_1.findFirstIdxMonotonousOrArrLen)(result, (e) => compare2(element, e) < 0);
          result.splice(j, 0, element);
        }
      }
    }
    function coalesce2(array) {
      return array.filter((e) => !!e);
    }
    function coalesceInPlace(array) {
      let to = 0;
      for (let i = 0; i < array.length; i++) {
        if (!!array[i]) {
          array[to] = array[i];
          to += 1;
        }
      }
      array.length = to;
    }
    function move(array, from, to) {
      array.splice(to, 0, array.splice(from, 1)[0]);
    }
    function isFalsyOrEmpty(obj) {
      return !Array.isArray(obj) || obj.length === 0;
    }
    function isNonEmptyArray(obj) {
      return Array.isArray(obj) && obj.length > 0;
    }
    function distinct2(array, keyFn = (value) => value) {
      const seen = /* @__PURE__ */ new Set();
      return array.filter((element) => {
        const key = keyFn(element);
        if (seen.has(key)) {
          return false;
        }
        seen.add(key);
        return true;
      });
    }
    function uniqueFilter2(keyFn) {
      const seen = /* @__PURE__ */ new Set();
      return (element) => {
        const key = keyFn(element);
        if (seen.has(key)) {
          return false;
        }
        seen.add(key);
        return true;
      };
    }
    function commonPrefixLength2(one, other, equals4 = (a, b) => a === b) {
      let result = 0;
      for (let i = 0, len = Math.min(one.length, other.length); i < len && equals4(one[i], other[i]); i++) {
        result++;
      }
      return result;
    }
    function range(arg, to) {
      let from = typeof to === "number" ? arg : 0;
      if (typeof to === "number") {
        from = arg;
      } else {
        from = 0;
        to = arg;
      }
      const result = [];
      if (from <= to) {
        for (let i = from; i < to; i++) {
          result.push(i);
        }
      } else {
        for (let i = from; i > to; i--) {
          result.push(i);
        }
      }
      return result;
    }
    function index(array, indexer, mapper) {
      return array.reduce((r, t2) => {
        r[indexer(t2)] = mapper ? mapper(t2) : t2;
        return r;
      }, /* @__PURE__ */ Object.create(null));
    }
    function insert(array, element) {
      array.push(element);
      return () => remove(array, element);
    }
    function remove(array, element) {
      const index2 = array.indexOf(element);
      if (index2 > -1) {
        array.splice(index2, 1);
        return element;
      }
      return void 0;
    }
    function arrayInsert2(target, insertIndex, insertArr) {
      const before = target.slice(0, insertIndex);
      const after = target.slice(insertIndex);
      return before.concat(insertArr, after);
    }
    function shuffle(array, _seed) {
      let rand;
      if (typeof _seed === "number") {
        let seed = _seed;
        rand = () => {
          const x = Math.sin(seed++) * 179426549;
          return x - Math.floor(x);
        };
      } else {
        rand = Math.random;
      }
      for (let i = array.length - 1; i > 0; i -= 1) {
        const j = Math.floor(rand() * (i + 1));
        const temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
    }
    function pushToStart(arr, value) {
      const index2 = arr.indexOf(value);
      if (index2 > -1) {
        arr.splice(index2, 1);
        arr.unshift(value);
      }
    }
    function pushToEnd(arr, value) {
      const index2 = arr.indexOf(value);
      if (index2 > -1) {
        arr.splice(index2, 1);
        arr.push(value);
      }
    }
    function pushMany(arr, items) {
      for (const item of items) {
        arr.push(item);
      }
    }
    function mapArrayOrNot(items, fn) {
      return Array.isArray(items) ? items.map(fn) : fn(items);
    }
    function asArray(x) {
      return Array.isArray(x) ? x : [x];
    }
    function getRandomElement(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    function insertInto(array, start, newItems) {
      const startIdx = getActualStartIndex(array, start);
      const originalLength = array.length;
      const newItemsLength = newItems.length;
      array.length = originalLength + newItemsLength;
      for (let i = originalLength - 1; i >= startIdx; i--) {
        array[i + newItemsLength] = array[i];
      }
      for (let i = 0; i < newItemsLength; i++) {
        array[i + startIdx] = newItems[i];
      }
    }
    function splice(array, start, deleteCount, newItems) {
      const index2 = getActualStartIndex(array, start);
      let result = array.splice(index2, deleteCount);
      if (result === void 0) {
        result = [];
      }
      insertInto(array, index2, newItems);
      return result;
    }
    function getActualStartIndex(array, start) {
      return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);
    }
    var CompareResult2;
    (function(CompareResult3) {
      function isLessThan(result) {
        return result < 0;
      }
      CompareResult3.isLessThan = isLessThan;
      function isLessThanOrEqual(result) {
        return result <= 0;
      }
      CompareResult3.isLessThanOrEqual = isLessThanOrEqual;
      function isGreaterThan(result) {
        return result > 0;
      }
      CompareResult3.isGreaterThan = isGreaterThan;
      function isNeitherLessOrGreaterThan(result) {
        return result === 0;
      }
      CompareResult3.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
      CompareResult3.greaterThan = 1;
      CompareResult3.lessThan = -1;
      CompareResult3.neitherLessOrGreaterThan = 0;
    })(CompareResult2 || (exports.CompareResult = CompareResult2 = {}));
    function compareBy2(selector, comparator) {
      return (a, b) => comparator(selector(a), selector(b));
    }
    function tieBreakComparators(...comparators) {
      return (item1, item2) => {
        for (const comparator of comparators) {
          const result = comparator(item1, item2);
          if (!CompareResult2.isNeitherLessOrGreaterThan(result)) {
            return result;
          }
        }
        return CompareResult2.neitherLessOrGreaterThan;
      };
    }
    var numberComparator2 = (a, b) => a - b;
    exports.numberComparator = numberComparator2;
    var booleanComparator = (a, b) => (0, exports.numberComparator)(a ? 1 : 0, b ? 1 : 0);
    exports.booleanComparator = booleanComparator;
    function reverseOrder(comparator) {
      return (a, b) => -comparator(a, b);
    }
    function compareUndefinedSmallest(comparator) {
      return (a, b) => {
        if (a === void 0) {
          return b === void 0 ? CompareResult2.neitherLessOrGreaterThan : CompareResult2.lessThan;
        } else if (b === void 0) {
          return CompareResult2.greaterThan;
        }
        return comparator(a, b);
      };
    }
    var ArrayQueue2 = class {
      /**
       * Constructs a queue that is backed by the given array. Runtime is O(1).
      */
      constructor(items) {
        this.firstIdx = 0;
        this.items = items;
        this.lastIdx = this.items.length - 1;
      }
      get length() {
        return this.lastIdx - this.firstIdx + 1;
      }
      /**
       * Consumes elements from the beginning of the queue as long as the predicate returns true.
       * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).
      */
      takeWhile(predicate) {
        let startIdx = this.firstIdx;
        while (startIdx < this.items.length && predicate(this.items[startIdx])) {
          startIdx++;
        }
        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);
        this.firstIdx = startIdx;
        return result;
      }
      /**
       * Consumes elements from the end of the queue as long as the predicate returns true.
       * If no elements were consumed, `null` is returned.
       * The result has the same order as the underlying array!
      */
      takeFromEndWhile(predicate) {
        let endIdx = this.lastIdx;
        while (endIdx >= 0 && predicate(this.items[endIdx])) {
          endIdx--;
        }
        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);
        this.lastIdx = endIdx;
        return result;
      }
      peek() {
        if (this.length === 0) {
          return void 0;
        }
        return this.items[this.firstIdx];
      }
      peekLast() {
        if (this.length === 0) {
          return void 0;
        }
        return this.items[this.lastIdx];
      }
      dequeue() {
        const result = this.items[this.firstIdx];
        this.firstIdx++;
        return result;
      }
      removeLast() {
        const result = this.items[this.lastIdx];
        this.lastIdx--;
        return result;
      }
      takeCount(count2) {
        const result = this.items.slice(this.firstIdx, this.firstIdx + count2);
        this.firstIdx += count2;
        return result;
      }
    };
    exports.ArrayQueue = ArrayQueue2;
    var CallbackIterable2 = class _CallbackIterable {
      static {
        this.empty = new _CallbackIterable((_callback) => {
        });
      }
      constructor(iterate) {
        this.iterate = iterate;
      }
      forEach(handler) {
        this.iterate((item) => {
          handler(item);
          return true;
        });
      }
      toArray() {
        const result = [];
        this.iterate((item) => {
          result.push(item);
          return true;
        });
        return result;
      }
      filter(predicate) {
        return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
      }
      map(mapFn) {
        return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
      }
      some(predicate) {
        let result = false;
        this.iterate((item) => {
          result = predicate(item);
          return !result;
        });
        return result;
      }
      findFirst(predicate) {
        let result;
        this.iterate((item) => {
          if (predicate(item)) {
            result = item;
            return false;
          }
          return true;
        });
        return result;
      }
      findLast(predicate) {
        let result;
        this.iterate((item) => {
          if (predicate(item)) {
            result = item;
          }
          return true;
        });
        return result;
      }
      findLastMaxBy(comparator) {
        let result;
        let first = true;
        this.iterate((item) => {
          if (first || CompareResult2.isGreaterThan(comparator(item, result))) {
            first = false;
            result = item;
          }
          return true;
        });
        return result;
      }
    };
    exports.CallbackIterable = CallbackIterable2;
    var Permutation = class _Permutation {
      constructor(_indexMap) {
        this._indexMap = _indexMap;
      }
      /**
       * Returns a permutation that sorts the given array according to the given compare function.
       */
      static createSortPermutation(arr, compareFn) {
        const sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));
        return new _Permutation(sortIndices);
      }
      /**
       * Returns a new array with the elements of the given array re-arranged according to this permutation.
       */
      apply(arr) {
        return arr.map((_, index2) => arr[this._indexMap[index2]]);
      }
      /**
       * Returns a new permutation that undoes the re-arrangement of this permutation.
      */
      inverse() {
        const inverseIndexMap = this._indexMap.slice();
        for (let i = 0; i < this._indexMap.length; i++) {
          inverseIndexMap[this._indexMap[i]] = i;
        }
        return new _Permutation(inverseIndexMap);
      }
    };
    exports.Permutation = Permutation;
    async function findAsync(array, predicate) {
      const results = await Promise.all(array.map(async (element, index2) => ({ element, ok: await predicate(element, index2) })));
      return results.find((r) => r.ok)?.element;
    }
    function sum2(array) {
      return array.reduce((acc, value) => acc + value, 0);
    }
    function sumBy2(array, selector) {
      return array.reduce((acc, value) => acc + selector(value), 0);
    }
  }
});

// src/platform/inlineEdits/common/dataTypes/textEditLengthHelper/length.js
var require_length = __commonJS({
  "src/platform/inlineEdits/common/dataTypes/textEditLengthHelper/length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lengthZero = void 0;
    exports.lengthDiff = lengthDiff2;
    exports.lengthIsZero = lengthIsZero3;
    exports.toLength = toLength2;
    exports.lengthToObj = lengthToObj3;
    exports.lengthGetLineCount = lengthGetLineCount2;
    exports.lengthGetColumnCountIfZeroLineCount = lengthGetColumnCountIfZeroLineCount2;
    exports.lengthAdd = lengthAdd3;
    exports.sumLengths = sumLengths3;
    exports.lengthEquals = lengthEquals3;
    exports.lengthDiffNonNegative = lengthDiffNonNegative3;
    exports.lengthLessThan = lengthLessThan2;
    exports.lengthLessThanEqual = lengthLessThanEqual2;
    exports.lengthGreaterThanEqual = lengthGreaterThanEqual2;
    exports.lengthToPosition = lengthToPosition2;
    exports.positionToLength = positionToLength2;
    exports.lengthsToRange = lengthsToRange2;
    exports.lengthOfRange = lengthOfRange2;
    exports.lengthCompare = lengthCompare2;
    exports.lengthOfString = lengthOfString2;
    exports.lengthOfStringObj = lengthOfStringObj2;
    exports.lengthHash = lengthHash2;
    exports.lengthMax = lengthMax2;
    var strings_1 = (init_strings(), __toCommonJS(strings_exports));
    var position_1 = (init_position(), __toCommonJS(position_exports));
    var range_1 = (init_range(), __toCommonJS(range_exports));
    var textLength_1 = (init_textLength(), __toCommonJS(textLength_exports));
    function lengthDiff2(startLineCount, startColumnCount, endLineCount, endColumnCount) {
      return startLineCount !== endLineCount ? toLength2(endLineCount - startLineCount, endColumnCount) : toLength2(0, endColumnCount - startColumnCount);
    }
    exports.lengthZero = 0;
    function lengthIsZero3(length) {
      return length === 0;
    }
    var factor2 = 2 ** 26;
    function toLength2(lineCount, columnCount) {
      return lineCount * factor2 + columnCount;
    }
    function lengthToObj3(length) {
      const l = length;
      const lineCount = Math.floor(l / factor2);
      const columnCount = l - lineCount * factor2;
      return new textLength_1.TextLength(lineCount, columnCount);
    }
    function lengthGetLineCount2(length) {
      return Math.floor(length / factor2);
    }
    function lengthGetColumnCountIfZeroLineCount2(length) {
      return length;
    }
    function lengthAdd3(l1, l2) {
      let r = l1 + l2;
      if (l2 >= factor2) {
        r = r - l1 % factor2;
      }
      return r;
    }
    function sumLengths3(items, lengthFn) {
      return items.reduce((a, b) => lengthAdd3(a, lengthFn(b)), exports.lengthZero);
    }
    function lengthEquals3(length1, length2) {
      return length1 === length2;
    }
    function lengthDiffNonNegative3(length1, length2) {
      const l1 = length1;
      const l2 = length2;
      const diff2 = l2 - l1;
      if (diff2 <= 0) {
        return exports.lengthZero;
      }
      const lineCount1 = Math.floor(l1 / factor2);
      const lineCount2 = Math.floor(l2 / factor2);
      const colCount2 = l2 - lineCount2 * factor2;
      if (lineCount1 === lineCount2) {
        const colCount1 = l1 - lineCount1 * factor2;
        return toLength2(0, colCount2 - colCount1);
      } else {
        return toLength2(lineCount2 - lineCount1, colCount2);
      }
    }
    function lengthLessThan2(length1, length2) {
      return length1 < length2;
    }
    function lengthLessThanEqual2(length1, length2) {
      return length1 <= length2;
    }
    function lengthGreaterThanEqual2(length1, length2) {
      return length1 >= length2;
    }
    function lengthToPosition2(length) {
      const l = length;
      const lineCount = Math.floor(l / factor2);
      const colCount = l - lineCount * factor2;
      return new position_1.Position(lineCount + 1, colCount + 1);
    }
    function positionToLength2(position) {
      return toLength2(position.lineNumber - 1, position.column - 1);
    }
    function lengthsToRange2(lengthStart, lengthEnd) {
      const l = lengthStart;
      const lineCount = Math.floor(l / factor2);
      const colCount = l - lineCount * factor2;
      const l2 = lengthEnd;
      const lineCount2 = Math.floor(l2 / factor2);
      const colCount2 = l2 - lineCount2 * factor2;
      return new range_1.Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);
    }
    function lengthOfRange2(range) {
      if (range.startLineNumber === range.endLineNumber) {
        return new textLength_1.TextLength(0, range.endColumn - range.startColumn);
      } else {
        return new textLength_1.TextLength(range.endLineNumber - range.startLineNumber, range.endColumn - 1);
      }
    }
    function lengthCompare2(length1, length2) {
      const l1 = length1;
      const l2 = length2;
      return l1 - l2;
    }
    function lengthOfString2(str) {
      const lines = (0, strings_1.splitLines)(str);
      return toLength2(lines.length - 1, lines[lines.length - 1].length);
    }
    function lengthOfStringObj2(str) {
      const lines = (0, strings_1.splitLines)(str);
      return new textLength_1.TextLength(lines.length - 1, lines[lines.length - 1].length);
    }
    function lengthHash2(length) {
      return length;
    }
    function lengthMax2(length1, length2) {
      return length1 > length2 ? length1 : length2;
    }
  }
});

// src/platform/inlineEdits/common/dataTypes/textEditLengthHelper/length.ts
var length_exports = {};
__export(length_exports, {
  lengthAdd: () => lengthAdd,
  lengthCompare: () => lengthCompare,
  lengthDiff: () => lengthDiff,
  lengthDiffNonNegative: () => lengthDiffNonNegative,
  lengthEquals: () => lengthEquals,
  lengthGetColumnCountIfZeroLineCount: () => lengthGetColumnCountIfZeroLineCount,
  lengthGetLineCount: () => lengthGetLineCount,
  lengthGreaterThanEqual: () => lengthGreaterThanEqual,
  lengthHash: () => lengthHash,
  lengthIsZero: () => lengthIsZero,
  lengthLessThan: () => lengthLessThan,
  lengthLessThanEqual: () => lengthLessThanEqual,
  lengthMax: () => lengthMax,
  lengthOfRange: () => lengthOfRange,
  lengthOfString: () => lengthOfString,
  lengthOfStringObj: () => lengthOfStringObj,
  lengthToObj: () => lengthToObj,
  lengthToPosition: () => lengthToPosition,
  lengthZero: () => lengthZero,
  lengthsToRange: () => lengthsToRange,
  positionToLength: () => positionToLength,
  sumLengths: () => sumLengths,
  toLength: () => toLength
});
function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {
  return startLineCount !== endLineCount ? toLength(endLineCount - startLineCount, endColumnCount) : toLength(0, endColumnCount - startColumnCount);
}
function lengthIsZero(length) {
  return length === 0;
}
function toLength(lineCount, columnCount) {
  return lineCount * factor + columnCount;
}
function lengthToObj(length) {
  const l = length;
  const lineCount = Math.floor(l / factor);
  const columnCount = l - lineCount * factor;
  return new TextLength(lineCount, columnCount);
}
function lengthGetLineCount(length) {
  return Math.floor(length / factor);
}
function lengthGetColumnCountIfZeroLineCount(length) {
  return length;
}
function lengthAdd(l1, l2) {
  let r = l1 + l2;
  if (l2 >= factor) {
    r = r - l1 % factor;
  }
  return r;
}
function sumLengths(items, lengthFn) {
  return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);
}
function lengthEquals(length1, length2) {
  return length1 === length2;
}
function lengthDiffNonNegative(length1, length2) {
  const l1 = length1;
  const l2 = length2;
  const diff2 = l2 - l1;
  if (diff2 <= 0) {
    return lengthZero;
  }
  const lineCount1 = Math.floor(l1 / factor);
  const lineCount2 = Math.floor(l2 / factor);
  const colCount2 = l2 - lineCount2 * factor;
  if (lineCount1 === lineCount2) {
    const colCount1 = l1 - lineCount1 * factor;
    return toLength(0, colCount2 - colCount1);
  } else {
    return toLength(lineCount2 - lineCount1, colCount2);
  }
}
function lengthLessThan(length1, length2) {
  return length1 < length2;
}
function lengthLessThanEqual(length1, length2) {
  return length1 <= length2;
}
function lengthGreaterThanEqual(length1, length2) {
  return length1 >= length2;
}
function lengthToPosition(length) {
  const l = length;
  const lineCount = Math.floor(l / factor);
  const colCount = l - lineCount * factor;
  return new Position(lineCount + 1, colCount + 1);
}
function positionToLength(position) {
  return toLength(position.lineNumber - 1, position.column - 1);
}
function lengthsToRange(lengthStart, lengthEnd) {
  const l = lengthStart;
  const lineCount = Math.floor(l / factor);
  const colCount = l - lineCount * factor;
  const l2 = lengthEnd;
  const lineCount2 = Math.floor(l2 / factor);
  const colCount2 = l2 - lineCount2 * factor;
  return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);
}
function lengthOfRange(range) {
  if (range.startLineNumber === range.endLineNumber) {
    return new TextLength(0, range.endColumn - range.startColumn);
  } else {
    return new TextLength(range.endLineNumber - range.startLineNumber, range.endColumn - 1);
  }
}
function lengthCompare(length1, length2) {
  const l1 = length1;
  const l2 = length2;
  return l1 - l2;
}
function lengthOfString(str) {
  const lines = splitLines(str);
  return toLength(lines.length - 1, lines[lines.length - 1].length);
}
function lengthOfStringObj(str) {
  const lines = splitLines(str);
  return new TextLength(lines.length - 1, lines[lines.length - 1].length);
}
function lengthHash(length) {
  return length;
}
function lengthMax(length1, length2) {
  return length1 > length2 ? length1 : length2;
}
var lengthZero, factor;
var init_length = __esm({
  "src/platform/inlineEdits/common/dataTypes/textEditLengthHelper/length.ts"() {
    "use strict";
    init_strings();
    init_position();
    init_range();
    init_textLength();
    lengthZero = 0;
    factor = 2 ** 26;
  }
});

// src/platform/inlineEdits/common/dataTypes/textEditLengthHelper/textEditInfo.js
var require_textEditInfo = __commonJS({
  "src/platform/inlineEdits/common/dataTypes/textEditLengthHelper/textEditInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextEditInfo = void 0;
    var length_1 = (init_length(), __toCommonJS(length_exports));
    var TextEditInfo3 = class {
      /*public static fromModelContentChanges(changes: IModelContentChange[]): TextEditInfo[] {
          // Must be sorted in ascending order
          const edits = changes.map(c => {
              const range = Range.lift(c.range);
              return new TextEditInfo(
                  positionToLength(range.getStartPosition()),
                  positionToLength(range.getEndPosition()),
                  lengthOfString(c.text)
              );
          }).reverse();
          return edits;
      }*/
      constructor(startOffset, endOffset, newLength) {
        this.startOffset = startOffset;
        this.endOffset = endOffset;
        this.newLength = newLength;
      }
      toString() {
        return `[${(0, length_1.lengthToObj)(this.startOffset)}...${(0, length_1.lengthToObj)(this.endOffset)}) -> ${(0, length_1.lengthToObj)(this.newLength)}`;
      }
    };
    exports.TextEditInfo = TextEditInfo3;
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/util/assert.js
var require_assert = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/util/assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertNever = assertNever2;
    function assertNever2(value, msg = `unexpected value ${value}`) {
      throw new Error(`Unreachable: ${msg}`);
    }
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/output/rawTypes.js
var require_rawTypes = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/output/rawTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChatCompletionContentPartOpaque = exports.ChatCompletionContentPartKind = exports.ChatRole = void 0;
    var assert_1 = require_assert();
    var ChatRole;
    (function(ChatRole2) {
      ChatRole2[ChatRole2["System"] = 0] = "System";
      ChatRole2[ChatRole2["User"] = 1] = "User";
      ChatRole2[ChatRole2["Assistant"] = 2] = "Assistant";
      ChatRole2[ChatRole2["Tool"] = 3] = "Tool";
    })(ChatRole || (exports.ChatRole = ChatRole = {}));
    (function(ChatRole2) {
      function display(role) {
        switch (role) {
          case ChatRole2.System:
            return "system";
          case ChatRole2.User:
            return "user";
          case ChatRole2.Assistant:
            return "assistant";
          case ChatRole2.Tool:
            return "tool";
          default:
            (0, assert_1.assertNever)(role, `unknown chat role ${role}}`);
        }
      }
      ChatRole2.display = display;
    })(ChatRole || (exports.ChatRole = ChatRole = {}));
    var ChatCompletionContentPartKind2;
    (function(ChatCompletionContentPartKind3) {
      ChatCompletionContentPartKind3[ChatCompletionContentPartKind3["Image"] = 0] = "Image";
      ChatCompletionContentPartKind3[ChatCompletionContentPartKind3["Text"] = 1] = "Text";
      ChatCompletionContentPartKind3[ChatCompletionContentPartKind3["Opaque"] = 2] = "Opaque";
      ChatCompletionContentPartKind3[ChatCompletionContentPartKind3["CacheBreakpoint"] = 3] = "CacheBreakpoint";
    })(ChatCompletionContentPartKind2 || (exports.ChatCompletionContentPartKind = ChatCompletionContentPartKind2 = {}));
    var ChatCompletionContentPartOpaque;
    (function(ChatCompletionContentPartOpaque2) {
      function usableIn(part, mode) {
        return !part.scope || (part.scope & mode) !== 0;
      }
      ChatCompletionContentPartOpaque2.usableIn = usableIn;
    })(ChatCompletionContentPartOpaque || (exports.ChatCompletionContentPartOpaque = ChatCompletionContentPartOpaque = {}));
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/output/openaiTypes.js
var require_openaiTypes = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/output/openaiTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseTokensPerName = exports.BaseTokensPerMessage = exports.BaseTokensPerCompletion = exports.ChatRole = void 0;
    var ChatRole;
    (function(ChatRole2) {
      ChatRole2["System"] = "system";
      ChatRole2["User"] = "user";
      ChatRole2["Assistant"] = "assistant";
      ChatRole2["Function"] = "function";
      ChatRole2["Tool"] = "tool";
    })(ChatRole || (exports.ChatRole = ChatRole = {}));
    exports.BaseTokensPerCompletion = 3;
    exports.BaseTokensPerMessage = 3;
    exports.BaseTokensPerName = 1;
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/output/openaiConvert.js
var require_openaiConvert = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/output/openaiConvert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toOpenAiChatMessage = toOpenAiChatMessage;
    exports.toOpenAIChatMessages = toOpenAIChatMessages;
    var Raw3 = require_rawTypes();
    var OpenAI2 = require_openaiTypes();
    var mode_1 = require_mode();
    function onlyStringContent(content) {
      return content.filter((part) => part.type === Raw3.ChatCompletionContentPartKind.Text).map((part) => part.text).join("");
    }
    function stringAndImageContent(content) {
      const parts = content.map((part) => {
        if (part.type === Raw3.ChatCompletionContentPartKind.Text) {
          return {
            type: "text",
            text: part.text
          };
        } else if (part.type === Raw3.ChatCompletionContentPartKind.Image) {
          return {
            image_url: part.imageUrl,
            type: "image_url"
          };
        } else if (part.type === Raw3.ChatCompletionContentPartKind.Opaque && Raw3.ChatCompletionContentPartOpaque.usableIn(part, mode_1.OutputMode.OpenAI)) {
          return part.value;
        }
      }).filter((r) => !!r);
      if (parts.every((part) => part.type === "text")) {
        return parts.map((p) => p.text).join("");
      }
      return parts;
    }
    function toOpenAiChatMessage(message) {
      switch (message.role) {
        case Raw3.ChatRole.System:
          return {
            role: OpenAI2.ChatRole.System,
            content: onlyStringContent(message.content),
            name: message.name
          };
        case Raw3.ChatRole.User:
          return {
            role: OpenAI2.ChatRole.User,
            content: stringAndImageContent(message.content),
            name: message.name
          };
        case Raw3.ChatRole.Assistant:
          return {
            role: OpenAI2.ChatRole.Assistant,
            content: onlyStringContent(message.content),
            name: message.name,
            tool_calls: message.toolCalls?.map((toolCall) => ({
              id: toolCall.id,
              function: toolCall.function,
              type: "function"
            }))
          };
        case Raw3.ChatRole.Tool:
          return {
            role: OpenAI2.ChatRole.Tool,
            content: stringAndImageContent(message.content),
            tool_call_id: message.toolCallId
          };
        default:
          return void 0;
      }
    }
    function toOpenAIChatMessages(messages) {
      return messages.map(toOpenAiChatMessage).filter((r) => !!r);
    }
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/output/vscode.js
var require_vscode = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/output/vscode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toVsCodeChatMessage = toVsCodeChatMessage;
    exports.toVsCodeChatMessages = toVsCodeChatMessages;
    var Raw3 = require_rawTypes();
    function onlyStringContent(content) {
      return content.filter((part) => part.type === Raw3.ChatCompletionContentPartKind.Text).map((part) => part.text).join("");
    }
    var vscode23;
    function toVsCodeChatMessage(m) {
      vscode23 ??= require("vscode");
      switch (m.role) {
        case Raw3.ChatRole.Assistant:
          const message = vscode23.LanguageModelChatMessage.Assistant(onlyStringContent(m.content), m.name);
          if (m.toolCalls) {
            message.content = [
              new vscode23.LanguageModelTextPart(onlyStringContent(m.content)),
              ...m.toolCalls.map((tc) => {
                let parsedArgs;
                try {
                  parsedArgs = JSON.parse(tc.function.arguments);
                } catch (err) {
                  throw new Error("Invalid JSON in tool call arguments for tool call: " + tc.id);
                }
                return new vscode23.LanguageModelToolCallPart(tc.id, tc.function.name, parsedArgs);
              })
            ];
          }
          return message;
        case Raw3.ChatRole.User:
          return vscode23.LanguageModelChatMessage.User(onlyStringContent(m.content), m.name);
        case Raw3.ChatRole.Tool: {
          const message2 = vscode23.LanguageModelChatMessage.User("");
          message2.content = [
            new vscode23.LanguageModelToolResultPart(m.toolCallId, [
              new vscode23.LanguageModelTextPart(onlyStringContent(m.content))
            ])
          ];
          return message2;
        }
        default:
          return void 0;
      }
    }
    function toVsCodeChatMessages(messages) {
      return messages.map(toVsCodeChatMessage).filter((r) => !!r);
    }
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/output/mode.js
var require_mode = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/output/mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutputMode = exports.Raw = exports.OpenAI = void 0;
    exports.toMode = toMode2;
    exports.toVSCode = toVSCode;
    exports.toOpenAI = toOpenAI;
    var openaiConvert_1 = require_openaiConvert();
    var vscode_1 = require_vscode();
    exports.OpenAI = require_openaiTypes();
    exports.Raw = require_rawTypes();
    var OutputMode2;
    (function(OutputMode3) {
      OutputMode3[OutputMode3["Raw"] = 1] = "Raw";
      OutputMode3[OutputMode3["OpenAI"] = 2] = "OpenAI";
      OutputMode3[OutputMode3["VSCode"] = 4] = "VSCode";
    })(OutputMode2 || (exports.OutputMode = OutputMode2 = {}));
    function toMode2(mode, messages) {
      switch (mode) {
        case OutputMode2.Raw:
          return messages;
        case OutputMode2.VSCode:
          return messages instanceof Array ? (0, vscode_1.toVsCodeChatMessages)(messages) : (0, vscode_1.toVsCodeChatMessage)(messages);
        case OutputMode2.OpenAI:
          return messages instanceof Array ? (0, openaiConvert_1.toOpenAIChatMessages)(messages) : (0, openaiConvert_1.toOpenAiChatMessage)(messages);
        default:
          throw new Error(`Unknown output mode: ${mode}`);
      }
    }
    function toVSCode(messages) {
      return toMode2(OutputMode2.VSCode, messages);
    }
    function toOpenAI(messages) {
      return toMode2(OutputMode2.OpenAI, messages);
    }
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/jsonTypes.js
var require_jsonTypes = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/jsonTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRetainedProps = void 0;
    exports.forEachNode = forEachNode;
    exports.jsonRetainedProps = Object.keys({
      flexBasis: 1,
      flexGrow: 1,
      flexReserve: 1,
      passPriority: 1,
      priority: 1
    });
    function forEachNode(node, fn) {
      fn(node);
      if (node.type === 1) {
        for (const child of node.children) {
          forEachNode(child, fn);
        }
      }
    }
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/once.js
var require_once = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/once.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.once = once;
    function once(fn) {
      let result;
      let called = false;
      const wrappedFunction = ((...args) => {
        if (!called) {
          result = fn(...args);
          called = true;
        }
        return result;
      });
      wrappedFunction.clear = () => {
        called = false;
      };
      return wrappedFunction;
    }
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/materialized.js
var require_materialized = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/materialized.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BudgetExceededError = exports.MaterializedChatMessageImage = exports.MaterializedChatMessageBreakpoint = exports.MaterializedChatMessageOpaque = exports.MaterializedChatMessage = exports.MaterializedChatMessageTextChunk = exports.GenericMaterializedContainer = void 0;
    var once_1 = require_once();
    var mode_1 = require_mode();
    var GenericMaterializedContainer = class _GenericMaterializedContainer {
      parent;
      id;
      name;
      priority;
      metadata;
      flags;
      children;
      keepWithId;
      constructor(parent, id2, name, priority, childrenRef, metadata, flags) {
        this.parent = parent;
        this.id = id2;
        this.name = name;
        this.priority = priority;
        this.metadata = metadata;
        this.flags = flags;
        this.children = childrenRef(this);
        if (flags & 8) {
          if (this.children.length !== 2) {
            throw new Error("Invalid number of children for EmptyAlternate flag");
          }
          const [ifEmpty, defaultChild] = this.children;
          if (defaultChild.isEmpty) {
            this.children = [ifEmpty];
          } else {
            this.children = [defaultChild];
          }
        }
      }
      has(flag) {
        return !!(this.flags & flag);
      }
      /** @inheritdoc */
      async tokenCount(tokenizer) {
        let total = 0;
        await Promise.all(this.children.map(async (child) => {
          const amt = isContainerType(child) ? await child.tokenCount(tokenizer) : await child.upperBoundTokenCount(tokenizer);
          total += amt;
        }));
        return total;
      }
      /** @inheritdoc */
      async upperBoundTokenCount(tokenizer) {
        let total = 0;
        await Promise.all(this.children.map(async (child) => {
          const amt = await child.upperBoundTokenCount(tokenizer);
          total += amt;
        }));
        return total;
      }
      /**
       * Replaces a node in the tree with the given one, by its ID.
       */
      replaceNode(nodeId, withNode) {
        return replaceNode(nodeId, this.children, withNode);
      }
      /**
       * Gets all metadata the container holds.
       */
      allMetadata() {
        return allMetadata(this);
      }
      /**
       * Finds a node in the tree by ID.
       */
      findById(nodeId) {
        return findNodeById(nodeId, this);
      }
      /**
       * Gets whether the container is empty.
       */
      get isEmpty() {
        return !this.children.some((c) => !c.isEmpty);
      }
      /**
       * Called when children change, so caches can be invalidated.
       */
      onChunksChange() {
        this.parent?.onChunksChange();
      }
      /**
       * Gets the chat messages the container holds.
       */
      *toChatMessages() {
        for (const child of this.children) {
          assertContainerOrChatMessage(child);
          if (child instanceof _GenericMaterializedContainer) {
            yield* child.toChatMessages();
          } else if (!child.isEmpty && child instanceof MaterializedChatMessage) {
            yield child.toChatMessage();
          }
        }
      }
      async baseMessageTokenCount(tokenizer) {
        let sum2 = 0;
        await Promise.all(this.children.map(async (child) => {
          if (child instanceof MaterializedChatMessage || child instanceof _GenericMaterializedContainer) {
            const amount = await child.baseMessageTokenCount(tokenizer);
            sum2 += amount;
          }
        }));
        return sum2;
      }
      /**
       * Removes the node in the tree with the lowest priority. Returns the
       * list of nodes that were removed.
       */
      removeLowestPriorityChild() {
        const removed = [];
        removeLowestPriorityChild(this, removed);
        return removed;
      }
    };
    exports.GenericMaterializedContainer = GenericMaterializedContainer;
    var MaterializedChatMessageTextChunk = class {
      parent;
      text;
      priority;
      metadata;
      lineBreakBefore;
      constructor(parent, text2, priority, metadata = [], lineBreakBefore) {
        this.parent = parent;
        this.text = text2;
        this.priority = priority;
        this.metadata = metadata;
        this.lineBreakBefore = lineBreakBefore;
      }
      upperBoundTokenCount(tokenizer) {
        return this._upperBound(tokenizer);
      }
      _upperBound = (0, once_1.once)(async (tokenizer) => {
        const textTokens = await tokenizer.tokenLength({
          type: mode_1.Raw.ChatCompletionContentPartKind.Text,
          text: this.text
        });
        return textTokens + (this.lineBreakBefore !== 0 ? 1 : 0);
      });
      get isEmpty() {
        return !/\S/.test(this.text);
      }
    };
    exports.MaterializedChatMessageTextChunk = MaterializedChatMessageTextChunk;
    var MaterializedChatMessage = class {
      parent;
      id;
      role;
      name;
      toolCalls;
      toolCallId;
      priority;
      metadata;
      children;
      constructor(parent, id2, role, name, toolCalls, toolCallId, priority, metadata, childrenRef) {
        this.parent = parent;
        this.id = id2;
        this.role = role;
        this.name = name;
        this.toolCalls = toolCalls;
        this.toolCallId = toolCallId;
        this.priority = priority;
        this.metadata = metadata;
        this.children = childrenRef(this);
      }
      /** @inheritdoc */
      async tokenCount(tokenizer) {
        return this._tokenCount(tokenizer);
      }
      /** @inheritdoc */
      async upperBoundTokenCount(tokenizer) {
        return this._upperBound(tokenizer);
      }
      /** Gets the text this message contains */
      get text() {
        return this._text();
      }
      /** Gets whether the message is empty */
      get isEmpty() {
        return !this.toolCalls?.length && !this.children.some((element) => !element.isEmpty);
      }
      /**
       * Replaces a node in the tree with the given one, by its ID.
       */
      replaceNode(nodeId, withNode) {
        const replaced = replaceNode(nodeId, this.children, withNode);
        if (replaced) {
          this.onChunksChange();
        }
        return replaced;
      }
      removeLowestPriorityChild() {
        const removed = [];
        removeLowestPriorityChild(this, removed);
        return removed;
      }
      onChunksChange() {
        this._tokenCount.clear();
        this._upperBound.clear();
        this._text.clear();
        this.parent?.onChunksChange();
      }
      /**
       * Finds a node in the tree by ID.
       */
      findById(nodeId) {
        return findNodeById(nodeId, this);
      }
      _tokenCount = (0, once_1.once)(async (tokenizer) => {
        const raw = this.toChatMessage();
        return tokenizer.countMessageTokens((0, mode_1.toMode)(tokenizer.mode, raw));
      });
      _upperBound = (0, once_1.once)(async (tokenizer) => {
        let total = await this.baseMessageTokenCount(tokenizer);
        await Promise.all(this.children.map(async (chunk) => {
          const amt = await chunk.upperBoundTokenCount(tokenizer);
          total += amt;
        }));
        return total;
      });
      baseMessageTokenCount = (0, once_1.once)((tokenizer) => {
        const raw = this.toChatMessage();
        raw.content = raw.content.map((message) => {
          if (message.type === mode_1.Raw.ChatCompletionContentPartKind.Text) {
            return { ...message, text: "" };
          } else if (message.type === mode_1.Raw.ChatCompletionContentPartKind.Image) {
            return void 0;
          } else {
            return message;
          }
        }).filter((r) => !!r);
        return tokenizer.countMessageTokens((0, mode_1.toMode)(tokenizer.mode, raw));
      });
      _text = (0, once_1.once)(() => {
        let result = [];
        for (const { content, isTextSibling } of contentChunks(this)) {
          if (content instanceof MaterializedChatMessageImage || content instanceof MaterializedChatMessageOpaque) {
            result.push(content);
            continue;
          }
          if (content instanceof MaterializedChatMessageBreakpoint) {
            if (result.at(-1) instanceof MaterializedChatMessageBreakpoint) {
              result[result.length - 1] = content;
            } else {
              result.push(content);
            }
            continue;
          }
          if (content.lineBreakBefore === 1 || content.lineBreakBefore === 2 && !isTextSibling) {
            let prev = result[result.length - 1];
            if (typeof prev === "string" && prev && !prev.endsWith("\n")) {
              result[result.length - 1] = prev + "\n";
            }
          }
          if (typeof result[result.length - 1] === "string") {
            result[result.length - 1] += content.text;
          } else {
            result.push(content.text);
          }
        }
        return result;
      });
      toChatMessage() {
        const content = this.text.map((element) => {
          if (typeof element === "string") {
            return { type: mode_1.Raw.ChatCompletionContentPartKind.Text, text: element };
          } else if (element instanceof MaterializedChatMessageImage) {
            return {
              type: mode_1.Raw.ChatCompletionContentPartKind.Image,
              // updated type reference
              imageUrl: { url: getEncodedBase64(element.src), detail: element.detail }
            };
          } else if (element instanceof MaterializedChatMessageOpaque) {
            return { type: mode_1.Raw.ChatCompletionContentPartKind.Opaque, value: element.value };
          } else if (element instanceof MaterializedChatMessageBreakpoint) {
            return element.part;
          } else {
            throw new Error("Unexpected element type");
          }
        });
        if (this.role === mode_1.Raw.ChatRole.System) {
          return {
            role: this.role,
            content,
            ...this.name ? { name: this.name } : {}
          };
        } else if (this.role === mode_1.Raw.ChatRole.Assistant) {
          const msg = { role: this.role, content };
          if (this.name) {
            msg.name = this.name;
          }
          if (this.toolCalls?.length) {
            msg.toolCalls = this.toolCalls.map((tc) => ({
              function: tc.function,
              id: tc.id,
              type: tc.type
            }));
          }
          return msg;
        } else if (this.role === mode_1.Raw.ChatRole.User) {
          return {
            role: this.role,
            content,
            ...this.name ? { name: this.name } : {}
          };
        } else if (this.role === mode_1.Raw.ChatRole.Tool) {
          return {
            role: this.role,
            content,
            toolCallId: this.toolCallId
          };
        } else {
          return {
            role: this.role,
            content,
            name: this.name
          };
        }
      }
    };
    exports.MaterializedChatMessage = MaterializedChatMessage;
    var MaterializedChatMessageOpaque = class {
      parent;
      part;
      priority;
      metadata = [];
      get value() {
        return this.part.value;
      }
      constructor(parent, part, priority = Number.MAX_SAFE_INTEGER) {
        this.parent = parent;
        this.part = part;
        this.priority = priority;
      }
      upperBoundTokenCount(tokenizer) {
        return this.part.tokenUsage && mode_1.Raw.ChatCompletionContentPartOpaque.usableIn(this.part, tokenizer.mode) ? this.part.tokenUsage : 0;
      }
      isEmpty = false;
    };
    exports.MaterializedChatMessageOpaque = MaterializedChatMessageOpaque;
    var MaterializedChatMessageBreakpoint = class {
      parent;
      part;
      metadata = [];
      priority = Number.MAX_SAFE_INTEGER;
      constructor(parent, part) {
        this.parent = parent;
        this.part = part;
      }
      upperBoundTokenCount(_tokenizer) {
        return 0;
      }
      isEmpty = false;
    };
    exports.MaterializedChatMessageBreakpoint = MaterializedChatMessageBreakpoint;
    var MaterializedChatMessageImage = class {
      parent;
      id;
      src;
      priority;
      metadata;
      lineBreakBefore;
      detail;
      constructor(parent, id2, src, priority, metadata = [], lineBreakBefore, detail) {
        this.parent = parent;
        this.id = id2;
        this.src = src;
        this.priority = priority;
        this.metadata = metadata;
        this.lineBreakBefore = lineBreakBefore;
        this.detail = detail;
      }
      upperBoundTokenCount(tokenizer) {
        return this._upperBound(tokenizer);
      }
      _upperBound = (0, once_1.once)(async (tokenizer) => {
        return tokenizer.tokenLength({
          type: mode_1.Raw.ChatCompletionContentPartKind.Image,
          imageUrl: { url: getEncodedBase64(this.src), detail: this.detail }
        });
      });
      isEmpty = false;
    };
    exports.MaterializedChatMessageImage = MaterializedChatMessageImage;
    function isContainerType(node) {
      return node instanceof GenericMaterializedContainer || node instanceof MaterializedChatMessage;
    }
    function isContentType(node) {
      return node instanceof MaterializedChatMessageTextChunk || node instanceof MaterializedChatMessageImage || node instanceof MaterializedChatMessageOpaque || node instanceof MaterializedChatMessageBreakpoint;
    }
    function assertContainerOrChatMessage(v) {
      if (!isContainerType(v)) {
        throw new Error(`Cannot have a text node outside a ChatMessage. Text: "${v.text}"`);
      }
    }
    function* contentChunks(node, isTextSibling = false) {
      for (const child of node.children) {
        if (child instanceof MaterializedChatMessageTextChunk) {
          yield { content: child, isTextSibling };
          isTextSibling = true;
        } else if (child instanceof MaterializedChatMessageImage || child instanceof MaterializedChatMessageOpaque || child instanceof MaterializedChatMessageBreakpoint) {
          yield { content: child, isTextSibling: false };
        } else if (child instanceof MaterializedChatMessageOpaque) {
          yield { content: child, isTextSibling: true };
        } else {
          if (child)
            yield* contentChunks(child, isTextSibling);
          isTextSibling = false;
        }
      }
    }
    function removeLowestPriorityLegacy(root, removed) {
      let lowest;
      function findLowestInTree(node, chain) {
        if (isContentType(node)) {
          if (!lowest || node.priority < lowest.node.priority) {
            lowest = { chain: chain.slice(), node };
          }
        } else {
          chain.push(node);
          for (const child of node.children) {
            findLowestInTree(child, chain);
          }
          chain.pop();
        }
      }
      findLowestInTree(root, []);
      if (!lowest) {
        throw new Error("No lowest priority node found");
      }
      removeNode(lowest.node, removed);
    }
    var _hasCachePointMemo = /* @__PURE__ */ new WeakMap();
    function hasCachePoint(node) {
      let known = _hasCachePointMemo.get(node);
      if (known !== void 0) {
        return known;
      }
      let result = false;
      if (node instanceof MaterializedChatMessageBreakpoint) {
        result = true;
      } else if (node instanceof MaterializedChatMessage) {
        result = node.children.some((c) => c instanceof MaterializedChatMessageBreakpoint);
      } else if (node instanceof GenericMaterializedContainer) {
        result = node.children.some(hasCachePoint);
      }
      _hasCachePointMemo.set(node, result);
      return result;
    }
    function shouldLookForCachePointInNode(node) {
      if (node instanceof MaterializedChatMessage) {
        return true;
      }
      for (let p = node.parent; p; p = p.parent) {
        if (p instanceof MaterializedChatMessage) {
          return false;
        }
      }
      return true;
    }
    function removeLowestPriorityChild(node, removed) {
      let lowest;
      if (node instanceof GenericMaterializedContainer && node.has(
        1
        /* ContainerFlags.IsLegacyPrioritization */
      )) {
        removeLowestPriorityLegacy(node, removed);
        return;
      }
      const shouldLookForCachePoint = shouldLookForCachePointInNode(node);
      const queue = node.children.map((_, i) => ({ chain: [node], index: i }));
      for (let i = 0; i < queue.length; i++) {
        const { chain, index } = queue[i];
        const child = chain[chain.length - 1].children[index];
        if (shouldLookForCachePoint && hasCachePoint(child)) {
          lowest = void 0;
          if (child instanceof MaterializedChatMessageBreakpoint) {
            continue;
          }
        }
        if (child instanceof GenericMaterializedContainer && child.has(
          4
          /* ContainerFlags.PassPriority */
        ) && child.children.length) {
          const newChain = [...chain, child];
          queue.splice(i + 1, 0, ...child.children.map((_, i2) => ({ chain: newChain, index: i2 })));
        } else if (!lowest || child.priority < lowest.value.priority) {
          lowest = { chain, index, value: child };
        } else if (child.priority === lowest.value.priority) {
          lowest.lowestNested ??= getLowestPriorityAmongChildren(lowest.value);
          const lowestNestedPriority = getLowestPriorityAmongChildren(child);
          if (lowestNestedPriority < lowest.lowestNested) {
            lowest = { chain, index, value: child, lowestNested: lowestNestedPriority };
          }
        }
      }
      if (!lowest) {
        throw new BudgetExceededError(node);
      }
      if (isContentType(lowest.value) || lowest.value instanceof GenericMaterializedContainer && lowest.value.has(
        2
        /* ContainerFlags.IsChunk */
      ) || isContainerType(lowest.value) && !lowest.value.children.length) {
        removeNode(lowest.value, removed);
      } else {
        removeLowestPriorityChild(lowest.value, removed);
      }
    }
    var BudgetExceededError = class extends Error {
      metadata;
      messages;
      constructor(node) {
        let path = [node];
        while (path[0].parent) {
          path.unshift(path[0].parent);
        }
        const parts = path.map((n) => n instanceof MaterializedChatMessage ? n.role : n.name || "(anonymous)");
        super(`No lowest priority node found (path: ${parts.join(" -> ")})`);
      }
    };
    exports.BudgetExceededError = BudgetExceededError;
    function getLowestPriorityAmongChildren(node) {
      if (!isContainerType(node)) {
        return -1;
      }
      let lowest = Number.MAX_SAFE_INTEGER;
      for (const child of node.children) {
        lowest = Math.min(lowest, child.priority);
      }
      return lowest;
    }
    function* allMetadata(node) {
      yield* node.metadata;
      for (const child of node.children) {
        if (isContainerType(child)) {
          yield* allMetadata(child);
        } else {
          yield* child.metadata;
        }
      }
    }
    function replaceNode(nodeId, children, withNode) {
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isContainerType(child)) {
          if (child.id === nodeId) {
            const oldNode = children[i];
            withNode.parent = child.parent;
            children[i] = withNode;
            return oldNode;
          }
          const inner = child.replaceNode(nodeId, withNode);
          if (inner) {
            return inner;
          }
        }
      }
    }
    function* forEachNode(node) {
      const queue = [node];
      while (queue.length > 0) {
        const current = queue.pop();
        yield current;
        if (isContainerType(current)) {
          queue.push(...current.children);
        }
      }
    }
    function getRoot2(node) {
      let current = node;
      while (current.parent) {
        current = current.parent;
      }
      return current;
    }
    function isKeepWith(node) {
      return node instanceof GenericMaterializedContainer && node.keepWithId !== void 0;
    }
    var currentlyBeingRemovedKeepWiths = /* @__PURE__ */ new Set();
    function removeOtherKeepWiths(nodeThatWasRemoved, removed) {
      const removeKeepWithIds = /* @__PURE__ */ new Set();
      for (const node of forEachNode(nodeThatWasRemoved)) {
        if (isKeepWith(node) && !currentlyBeingRemovedKeepWiths.has(node.keepWithId)) {
          removeKeepWithIds.add(node.keepWithId);
        }
      }
      if (removeKeepWithIds.size === 0) {
        return false;
      }
      for (const id2 of removeKeepWithIds) {
        currentlyBeingRemovedKeepWiths.add(id2);
      }
      try {
        const root = getRoot2(nodeThatWasRemoved);
        for (const node of forEachNode(root)) {
          if (isKeepWith(node) && removeKeepWithIds.has(node.keepWithId)) {
            removeNode(node, removed);
          } else if (node instanceof MaterializedChatMessage && node.toolCalls) {
            node.toolCalls = filterIfDifferent(node.toolCalls, (c) => !(c.keepWith && removeKeepWithIds.has(c.keepWith.id)));
            if (node.isEmpty) {
              removeNode(node, removed);
            }
          }
        }
      } finally {
        for (const id2 of removeKeepWithIds) {
          currentlyBeingRemovedKeepWiths.delete(id2);
        }
      }
    }
    function findNodeById(nodeId, container) {
      if (container.id === nodeId) {
        return container;
      }
      for (const child of container.children) {
        if (isContainerType(child)) {
          const inner = findNodeById(nodeId, child);
          if (inner) {
            return inner;
          }
        }
      }
    }
    function removeNode(node, removed) {
      const parent = node.parent;
      if (!parent) {
        return;
      }
      const index = parent.children.indexOf(node);
      if (index === -1) {
        return;
      }
      parent.children.splice(index, 1);
      removed.push(node);
      removeOtherKeepWiths(node, removed);
      if (parent.isEmpty) {
        removeNode(parent, removed);
      } else {
        parent.onChunksChange();
      }
    }
    function getEncodedBase64(base64String) {
      const mimeTypes = {
        "/9j/": "image/jpeg",
        iVBOR: "image/png",
        R0lGOD: "image/gif",
        UklGR: "image/webp"
      };
      for (const prefix of Object.keys(mimeTypes)) {
        if (base64String.startsWith(prefix)) {
          return `data:${mimeTypes[prefix]};base64,${base64String}`;
        }
      }
      return base64String;
    }
    function filterIfDifferent(arr, predicate) {
      for (let i = 0; i < arr.length; i++) {
        if (predicate(arr[i])) {
          continue;
        }
        const newArr = arr.slice(0, i);
        for (let k = i + 1; k < arr.length; k++) {
          if (predicate(arr[k])) {
            newArr.push(arr[k]);
          }
        }
        return newArr;
      }
      return arr;
    }
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/tsx.js
var require_tsx = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/tsx.js"() {
    "use strict";
    function _vscpp(ctor, props, ...children) {
      return { ctor, props, children: children.flat() };
    }
    function _vscppf() {
      throw new Error(`This should not be invoked!`);
    }
    _vscppf.isFragment = true;
    globalThis.vscpp = _vscpp;
    globalThis.vscppf = _vscppf;
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/promptElement.js
var require_promptElement = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/promptElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromptElement = void 0;
    require_tsx();
    var PromptElement3 = class {
      props;
      get priority() {
        return this.props.priority ?? Number.MAX_SAFE_INTEGER;
      }
      get insertLineBreakBefore() {
        return true;
      }
      constructor(props) {
        this.props = props;
      }
    };
    exports.PromptElement = PromptElement3;
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/promptElements.js
var require_promptElements = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/promptElements.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LogicalWrapper = exports.IfEmpty = exports.AbstractKeepWith = exports.TokenLimit = exports.Expandable = exports.Chunk = exports.LegacyPrioritization = exports.ToolResult = exports.PrioritizedList = exports.Image = exports.TextChunk = exports.ToolMessage = exports.AssistantMessage = exports.UserMessage = exports.SystemMessage = exports.BaseChatMessage = void 0;
    exports.isChatMessagePromptElement = isChatMessagePromptElement;
    exports.useKeepWith = useKeepWith;
    var _1 = require_base();
    var promptElement_1 = require_promptElement();
    function isChatMessagePromptElement(element) {
      return element instanceof SystemMessage2 || element instanceof UserMessage2 || element instanceof AssistantMessage;
    }
    var BaseChatMessage = class extends promptElement_1.PromptElement {
      render() {
        return vscpp(vscppf, null, this.props.children);
      }
    };
    exports.BaseChatMessage = BaseChatMessage;
    var SystemMessage2 = class extends BaseChatMessage {
      constructor(props) {
        props.role = _1.Raw.ChatRole.System;
        super(props);
      }
    };
    exports.SystemMessage = SystemMessage2;
    var UserMessage2 = class extends BaseChatMessage {
      constructor(props) {
        props.role = _1.Raw.ChatRole.User;
        super(props);
      }
    };
    exports.UserMessage = UserMessage2;
    var AssistantMessage = class extends BaseChatMessage {
      constructor(props) {
        props.role = _1.Raw.ChatRole.Assistant;
        super(props);
      }
    };
    exports.AssistantMessage = AssistantMessage;
    var WHITESPACE_RE = /\s+/g;
    var ToolMessage = class extends BaseChatMessage {
      constructor(props) {
        props.role = _1.Raw.ChatRole.Tool;
        super(props);
      }
    };
    exports.ToolMessage = ToolMessage;
    var TextChunk = class extends promptElement_1.PromptElement {
      async prepare(sizing, _progress, token) {
        const breakOn = this.props.breakOnWhitespace ? WHITESPACE_RE : this.props.breakOn;
        if (!breakOn) {
          return vscpp(vscppf, null, this.props.children);
        }
        let fullText = "";
        const intrinsics = [];
        for (const child of this.props.children || []) {
          if (child && typeof child === "object") {
            if (typeof child.ctor !== "string") {
              throw new Error("TextChunk children must be text literals or intrinsic attributes.");
            } else if (child.ctor === "br") {
              fullText += "\n";
            } else {
              intrinsics.push(child);
            }
          } else if (child != null) {
            fullText += child;
          }
        }
        const text2 = await getTextContentBelowBudget(sizing, breakOn, fullText, token);
        return vscpp(
          vscppf,
          null,
          intrinsics,
          text2
        );
      }
      render(piece) {
        return piece;
      }
    };
    exports.TextChunk = TextChunk;
    async function getTextContentBelowBudget(sizing, breakOn, fullText, cancellation) {
      if (breakOn instanceof RegExp) {
        if (!breakOn.global) {
          throw new Error(`\`breakOn\` expression must have the global flag set (got ${breakOn})`);
        }
        breakOn.lastIndex = 0;
      }
      let outputText = "";
      let lastIndex = -1;
      while (lastIndex < fullText.length) {
        let index;
        if (typeof breakOn === "string") {
          index = fullText.indexOf(breakOn, lastIndex === -1 ? 0 : lastIndex + breakOn.length);
        } else {
          index = breakOn.exec(fullText)?.index ?? -1;
        }
        if (index === -1) {
          index = fullText.length;
        }
        const next = outputText + fullText.slice(Math.max(0, lastIndex), index);
        if (await sizing.countTokens({ type: _1.Raw.ChatCompletionContentPartKind.Text, text: next }, cancellation) > sizing.tokenBudget) {
          return outputText;
        }
        outputText = next;
        lastIndex = index;
      }
      return outputText;
    }
    var Image = class extends promptElement_1.PromptElement {
      constructor(props) {
        super(props);
      }
      render() {
        return vscpp(vscppf, null, this.props.children);
      }
    };
    exports.Image = Image;
    var PrioritizedList = class extends promptElement_1.PromptElement {
      render() {
        const { children, priority = 0, descending } = this.props;
        if (!children) {
          return;
        }
        return vscpp(vscppf, null, children.map((child, i) => {
          if (!child) {
            return;
          }
          const thisPriority = descending ? (
            // First element in array of children has highest priority
            priority - i
          ) : (
            // Last element in array of children has highest priority
            priority - children.length + i
          );
          if (typeof child !== "object") {
            return vscpp(TextChunk, { priority: thisPriority }, child);
          }
          child.props ??= {};
          child.props.priority = thisPriority;
          return child;
        }));
      }
    };
    exports.PrioritizedList = PrioritizedList;
    var ToolResult = class extends promptElement_1.PromptElement {
      render() {
        return vscpp(vscppf, null, this.props.data.content.map((part) => {
          if (part && typeof part.value === "string") {
            return part.value;
          } else if (part && part.value && typeof part.value.node === "object") {
            return vscpp("elementJSON", { data: part.value });
          }
        }));
      }
    };
    exports.ToolResult = ToolResult;
    var LegacyPrioritization = class extends promptElement_1.PromptElement {
      render() {
        return vscpp(vscppf, null, this.props.children);
      }
    };
    exports.LegacyPrioritization = LegacyPrioritization;
    var Chunk = class extends promptElement_1.PromptElement {
      render() {
        return vscpp(vscppf, null, this.props.children);
      }
    };
    exports.Chunk = Chunk;
    var Expandable = class extends promptElement_1.PromptElement {
      async render(_state, sizing) {
        return vscpp(vscppf, null, await this.props.value(sizing));
      }
    };
    exports.Expandable = Expandable;
    var TokenLimit = class extends promptElement_1.PromptElement {
      render() {
        return vscpp(vscppf, null, this.props.children);
      }
    };
    exports.TokenLimit = TokenLimit;
    var AbstractKeepWith = class extends promptElement_1.PromptElement {
    };
    exports.AbstractKeepWith = AbstractKeepWith;
    var keepWidthId = 0;
    function useKeepWith() {
      const id2 = keepWidthId++;
      return class KeepWith extends AbstractKeepWith {
        static id = id2;
        id = id2;
        render() {
          return vscpp(vscppf, null, this.props.children);
        }
      };
    }
    var IfEmpty = class extends promptElement_1.PromptElement {
      render() {
        return vscpp(
          vscppf,
          null,
          vscpp(LogicalWrapper, null, this.props.alt),
          vscpp(LogicalWrapper, { flexGrow: 1 }, this.props.children)
        );
      }
    };
    exports.IfEmpty = IfEmpty;
    var LogicalWrapper = class extends promptElement_1.PromptElement {
      render() {
        return vscpp(vscppf, null, this.props.children);
      }
    };
    exports.LogicalWrapper = LogicalWrapper;
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/util/vs/nls.js
var require_nls = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/util/vs/nls.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.localize = localize;
    exports.localize2 = localize2;
    exports.getConfiguredDefaultLocale = getConfiguredDefaultLocale;
    function _format2(message, args) {
      let result;
      if (args.length === 0) {
        result = message;
      } else {
        result = message.replace(/\{(\d+)\}/g, function(match3, rest) {
          const index = rest[0];
          return typeof args[index] !== "undefined" ? args[index] : match3;
        });
      }
      return result;
    }
    function localize(data, message, ...args) {
      return _format2(message, args);
    }
    function localize2(data, message, ...args) {
      const res = _format2(message, args);
      return {
        original: res,
        value: res
      };
    }
    function getConfiguredDefaultLocale(_) {
      return void 0;
    }
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/util/vs/common/platform.js
var require_platform = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/util/vs/common/platform.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAndroid = exports.isEdge = exports.isSafari = exports.isFirefox = exports.isChrome = exports.OS = exports.setTimeout0 = exports.setTimeout0IsFaster = exports.translationsConfigFile = exports.platformLocale = exports.locale = exports.Language = exports.language = exports.userAgent = exports.platform = exports.isCI = exports.isMobile = exports.isIOS = exports.webWorkerOrigin = exports.isWebWorker = exports.isWeb = exports.isElectron = exports.isNative = exports.isLinuxSnap = exports.isLinux = exports.isMacintosh = exports.isWindows = exports.LANGUAGE_DEFAULT = void 0;
    exports.PlatformToString = PlatformToString;
    exports.isLittleEndian = isLittleEndian;
    exports.isBigSurOrNewer = isBigSurOrNewer;
    var nls = require_nls();
    exports.LANGUAGE_DEFAULT = "en";
    var _isWindows2 = false;
    var _isMacintosh2 = false;
    var _isLinux2 = false;
    var _isLinuxSnap2 = false;
    var _isNative2 = false;
    var _isWeb2 = false;
    var _isElectron2 = false;
    var _isIOS2 = false;
    var _isCI2 = false;
    var _isMobile2 = false;
    var _locale2 = void 0;
    var _language2 = exports.LANGUAGE_DEFAULT;
    var _platformLocale2 = exports.LANGUAGE_DEFAULT;
    var _translationsConfigFile2 = void 0;
    var _userAgent2 = void 0;
    var $globalThis2 = globalThis;
    var nodeProcess2 = void 0;
    if (typeof $globalThis2.vscode !== "undefined" && typeof $globalThis2.vscode.process !== "undefined") {
      nodeProcess2 = $globalThis2.vscode.process;
    } else if (typeof process !== "undefined") {
      nodeProcess2 = process;
    }
    var isElectronProcess2 = typeof nodeProcess2?.versions?.electron === "string";
    var isElectronRenderer2 = isElectronProcess2 && nodeProcess2?.type === "renderer";
    if (typeof nodeProcess2 === "object") {
      _isWindows2 = nodeProcess2.platform === "win32";
      _isMacintosh2 = nodeProcess2.platform === "darwin";
      _isLinux2 = nodeProcess2.platform === "linux";
      _isLinuxSnap2 = _isLinux2 && !!nodeProcess2.env["SNAP"] && !!nodeProcess2.env["SNAP_REVISION"];
      _isElectron2 = isElectronProcess2;
      _isCI2 = !!nodeProcess2.env["CI"] || !!nodeProcess2.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
      _locale2 = exports.LANGUAGE_DEFAULT;
      _language2 = exports.LANGUAGE_DEFAULT;
      const rawNlsConfig = nodeProcess2.env["VSCODE_NLS_CONFIG"];
      if (rawNlsConfig) {
        try {
          const nlsConfig = JSON.parse(rawNlsConfig);
          const resolved = nlsConfig.availableLanguages["*"];
          _locale2 = nlsConfig.locale;
          _platformLocale2 = nlsConfig.osLocale;
          _language2 = resolved ? resolved : exports.LANGUAGE_DEFAULT;
          _translationsConfigFile2 = nlsConfig._translationsConfigFile;
        } catch (e) {
        }
      }
      _isNative2 = true;
    } else if (typeof navigator === "object" && !isElectronRenderer2) {
      _userAgent2 = navigator.userAgent;
      _isWindows2 = _userAgent2.indexOf("Windows") >= 0;
      _isMacintosh2 = _userAgent2.indexOf("Macintosh") >= 0;
      _isIOS2 = (_userAgent2.indexOf("Macintosh") >= 0 || _userAgent2.indexOf("iPad") >= 0 || _userAgent2.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
      _isLinux2 = _userAgent2.indexOf("Linux") >= 0;
      _isMobile2 = _userAgent2?.indexOf("Mobi") >= 0;
      _isWeb2 = true;
      const configuredLocale = nls.getConfiguredDefaultLocale(
        // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`
        // to ensure that the NLS AMD Loader plugin has been loaded and configured.
        // This is because the loader plugin decides what the default locale is based on
        // how it's able to resolve the strings.
        nls.localize({ key: "ensureLoaderPluginIsLoaded", comment: ["{Locked}"] }, "_")
      );
      _locale2 = configuredLocale || exports.LANGUAGE_DEFAULT;
      _language2 = _locale2;
      _platformLocale2 = navigator.language;
    } else {
      console.error("Unable to resolve platform.");
    }
    function PlatformToString(platform3) {
      switch (platform3) {
        case 0:
          return "Web";
        case 1:
          return "Mac";
        case 2:
          return "Linux";
        case 3:
          return "Windows";
      }
    }
    var _platform2 = 0;
    if (_isMacintosh2) {
      _platform2 = 1;
    } else if (_isWindows2) {
      _platform2 = 3;
    } else if (_isLinux2) {
      _platform2 = 2;
    }
    exports.isWindows = _isWindows2;
    exports.isMacintosh = _isMacintosh2;
    exports.isLinux = _isLinux2;
    exports.isLinuxSnap = _isLinuxSnap2;
    exports.isNative = _isNative2;
    exports.isElectron = _isElectron2;
    exports.isWeb = _isWeb2;
    exports.isWebWorker = _isWeb2 && typeof $globalThis2.importScripts === "function";
    exports.webWorkerOrigin = exports.isWebWorker ? $globalThis2.origin : void 0;
    exports.isIOS = _isIOS2;
    exports.isMobile = _isMobile2;
    exports.isCI = _isCI2;
    exports.platform = _platform2;
    exports.userAgent = _userAgent2;
    exports.language = _language2;
    var Language2;
    (function(Language3) {
      function value() {
        return exports.language;
      }
      Language3.value = value;
      function isDefaultVariant() {
        if (exports.language.length === 2) {
          return exports.language === "en";
        } else if (exports.language.length >= 3) {
          return exports.language[0] === "e" && exports.language[1] === "n" && exports.language[2] === "-";
        } else {
          return false;
        }
      }
      Language3.isDefaultVariant = isDefaultVariant;
      function isDefault() {
        return exports.language === "en";
      }
      Language3.isDefault = isDefault;
    })(Language2 || (exports.Language = Language2 = {}));
    exports.locale = _locale2;
    exports.platformLocale = _platformLocale2;
    exports.translationsConfigFile = _translationsConfigFile2;
    exports.setTimeout0IsFaster = typeof $globalThis2.postMessage === "function" && !$globalThis2.importScripts;
    exports.setTimeout0 = (() => {
      if (exports.setTimeout0IsFaster) {
        const pending = [];
        $globalThis2.addEventListener("message", (e) => {
          if (e.data && e.data.vscodeScheduleAsyncWork) {
            for (let i = 0, len = pending.length; i < len; i++) {
              const candidate = pending[i];
              if (candidate.id === e.data.vscodeScheduleAsyncWork) {
                pending.splice(i, 1);
                candidate.callback();
                return;
              }
            }
          }
        });
        let lastId = 0;
        return (callback) => {
          const myId = ++lastId;
          pending.push({
            id: myId,
            callback
          });
          $globalThis2.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
        };
      }
      return (callback) => setTimeout(callback);
    })();
    exports.OS = _isMacintosh2 || _isIOS2 ? 2 : _isWindows2 ? 1 : 3;
    var _isLittleEndian = true;
    var _isLittleEndianComputed = false;
    function isLittleEndian() {
      if (!_isLittleEndianComputed) {
        _isLittleEndianComputed = true;
        const test2 = new Uint8Array(2);
        test2[0] = 1;
        test2[1] = 2;
        const view = new Uint16Array(test2.buffer);
        _isLittleEndian = view[0] === (2 << 8) + 1;
      }
      return _isLittleEndian;
    }
    exports.isChrome = !!(exports.userAgent && exports.userAgent.indexOf("Chrome") >= 0);
    exports.isFirefox = !!(exports.userAgent && exports.userAgent.indexOf("Firefox") >= 0);
    exports.isSafari = !!(!exports.isChrome && (exports.userAgent && exports.userAgent.indexOf("Safari") >= 0));
    exports.isEdge = !!(exports.userAgent && exports.userAgent.indexOf("Edg/") >= 0);
    exports.isAndroid = !!(exports.userAgent && exports.userAgent.indexOf("Android") >= 0);
    function isBigSurOrNewer(osVersion) {
      return parseFloat(osVersion) >= 20;
    }
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/util/vs/common/process.js
var require_process = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/util/vs/common/process.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arch = exports.platform = exports.env = exports.cwd = void 0;
    var platform_1 = require_platform();
    var safeProcess2;
    var vscodeGlobal2 = globalThis.vscode;
    if (typeof vscodeGlobal2 !== "undefined" && typeof vscodeGlobal2.process !== "undefined") {
      const sandboxProcess = vscodeGlobal2.process;
      safeProcess2 = {
        get platform() {
          return sandboxProcess.platform;
        },
        get arch() {
          return sandboxProcess.arch;
        },
        get env() {
          return sandboxProcess.env;
        },
        cwd() {
          return sandboxProcess.cwd();
        }
      };
    } else if (typeof process !== "undefined") {
      safeProcess2 = {
        get platform() {
          return process.platform;
        },
        get arch() {
          return process.arch;
        },
        get env() {
          return process.env;
        },
        cwd() {
          return process.env["VSCODE_CWD"] || process.cwd();
        }
      };
    } else {
      safeProcess2 = {
        // Supported
        get platform() {
          return platform_1.isWindows ? "win32" : platform_1.isMacintosh ? "darwin" : "linux";
        },
        get arch() {
          return void 0;
        },
        // Unsupported
        get env() {
          return {};
        },
        cwd() {
          return "/";
        }
      };
    }
    exports.cwd = safeProcess2.cwd;
    exports.env = safeProcess2.env;
    exports.platform = safeProcess2.platform;
    exports.arch = safeProcess2.arch;
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/util/vs/common/path.js
var require_path = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/util/vs/common/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delimiter = exports.sep = exports.toNamespacedPath = exports.parse = exports.format = exports.extname = exports.basename = exports.dirname = exports.relative = exports.resolve = exports.join = exports.isAbsolute = exports.normalize = exports.posix = exports.win32 = void 0;
    var process2 = require_process();
    var CHAR_UPPERCASE_A2 = 65;
    var CHAR_LOWERCASE_A2 = 97;
    var CHAR_UPPERCASE_Z2 = 90;
    var CHAR_LOWERCASE_Z2 = 122;
    var CHAR_DOT2 = 46;
    var CHAR_FORWARD_SLASH2 = 47;
    var CHAR_BACKWARD_SLASH2 = 92;
    var CHAR_COLON2 = 58;
    var CHAR_QUESTION_MARK2 = 63;
    var ErrorInvalidArgType2 = class extends Error {
      code;
      constructor(name, expected, actual) {
        let determiner;
        if (typeof expected === "string" && expected.indexOf("not ") === 0) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        const type = name.indexOf(".") !== -1 ? "property" : "argument";
        let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
        msg += `. Received type ${typeof actual}`;
        super(msg);
        this.code = "ERR_INVALID_ARG_TYPE";
      }
    };
    function validateObject2(pathObject, name) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new ErrorInvalidArgType2(name, "Object", pathObject);
      }
    }
    function validateString2(value, name) {
      if (typeof value !== "string") {
        throw new ErrorInvalidArgType2(name, "string", value);
      }
    }
    var platformIsWin322 = process2.platform === "win32";
    function isPathSeparator3(code2) {
      return code2 === CHAR_FORWARD_SLASH2 || code2 === CHAR_BACKWARD_SLASH2;
    }
    function isPosixPathSeparator2(code2) {
      return code2 === CHAR_FORWARD_SLASH2;
    }
    function isWindowsDeviceRoot2(code2) {
      return code2 >= CHAR_UPPERCASE_A2 && code2 <= CHAR_UPPERCASE_Z2 || code2 >= CHAR_LOWERCASE_A2 && code2 <= CHAR_LOWERCASE_Z2;
    }
    function normalizeString2(path, allowAboveRoot, separator, isPathSeparator4) {
      let res = "";
      let lastSegmentLength = 0;
      let lastSlash = -1;
      let dots = 0;
      let code2 = 0;
      for (let i = 0; i <= path.length; ++i) {
        if (i < path.length) {
          code2 = path.charCodeAt(i);
        } else if (isPathSeparator4(code2)) {
          break;
        } else {
          code2 = CHAR_FORWARD_SLASH2;
        }
        if (isPathSeparator4(code2)) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT2 || res.charCodeAt(res.length - 2) !== CHAR_DOT2) {
              if (res.length > 2) {
                const lastSlashIndex = res.lastIndexOf(separator);
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                }
                lastSlash = i;
                dots = 0;
                continue;
              } else if (res.length !== 0) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              res += res.length > 0 ? `${separator}..` : "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0) {
              res += `${separator}${path.slice(lastSlash + 1, i)}`;
            } else {
              res = path.slice(lastSlash + 1, i);
            }
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code2 === CHAR_DOT2 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format2(sep2, pathObject) {
      validateObject2(pathObject, "pathObject");
      const dir = pathObject.dir || pathObject.root;
      const base2 = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
      if (!dir) {
        return base2;
      }
      return dir === pathObject.root ? `${dir}${base2}` : `${dir}${sep2}${base2}`;
    }
    exports.win32 = {
      // path.resolve([from ...], to)
      resolve(...pathSegments) {
        let resolvedDevice = "";
        let resolvedTail = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
          let path;
          if (i >= 0) {
            path = pathSegments[i];
            validateString2(path, "path");
            if (path.length === 0) {
              continue;
            }
          } else if (resolvedDevice.length === 0) {
            path = process2.cwd();
          } else {
            path = process2.env[`=${resolvedDevice}`] || process2.cwd();
            if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH2) {
              path = `${resolvedDevice}\\`;
            }
          }
          const len = path.length;
          let rootEnd = 0;
          let device = "";
          let isAbsolute2 = false;
          const code2 = path.charCodeAt(0);
          if (len === 1) {
            if (isPathSeparator3(code2)) {
              rootEnd = 1;
              isAbsolute2 = true;
            }
          } else if (isPathSeparator3(code2)) {
            isAbsolute2 = true;
            if (isPathSeparator3(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator3(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                const firstPart = path.slice(last, j);
                last = j;
                while (j < len && isPathSeparator3(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator3(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len || j !== last) {
                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                    rootEnd = j;
                  }
                }
              }
            } else {
              rootEnd = 1;
            }
          } else if (isWindowsDeviceRoot2(code2) && path.charCodeAt(1) === CHAR_COLON2) {
            device = path.slice(0, 2);
            rootEnd = 2;
            if (len > 2 && isPathSeparator3(path.charCodeAt(2))) {
              isAbsolute2 = true;
              rootEnd = 3;
            }
          }
          if (device.length > 0) {
            if (resolvedDevice.length > 0) {
              if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                continue;
              }
            } else {
              resolvedDevice = device;
            }
          }
          if (resolvedAbsolute) {
            if (resolvedDevice.length > 0) {
              break;
            }
          } else {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute2;
            if (isAbsolute2 && resolvedDevice.length > 0) {
              break;
            }
          }
        }
        resolvedTail = normalizeString2(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator3);
        return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
      },
      normalize(path) {
        validateString2(path, "path");
        const len = path.length;
        if (len === 0) {
          return ".";
        }
        let rootEnd = 0;
        let device;
        let isAbsolute2 = false;
        const code2 = path.charCodeAt(0);
        if (len === 1) {
          return isPosixPathSeparator2(code2) ? "\\" : path;
        }
        if (isPathSeparator3(code2)) {
          isAbsolute2 = true;
          if (isPathSeparator3(path.charCodeAt(1))) {
            let j = 2;
            let last = j;
            while (j < len && !isPathSeparator3(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              const firstPart = path.slice(last, j);
              last = j;
              while (j < len && isPathSeparator3(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && !isPathSeparator3(path.charCodeAt(j))) {
                  j++;
                }
                if (j === len) {
                  return `\\\\${firstPart}\\${path.slice(last)}\\`;
                }
                if (j !== last) {
                  device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                  rootEnd = j;
                }
              }
            }
          } else {
            rootEnd = 1;
          }
        } else if (isWindowsDeviceRoot2(code2) && path.charCodeAt(1) === CHAR_COLON2) {
          device = path.slice(0, 2);
          rootEnd = 2;
          if (len > 2 && isPathSeparator3(path.charCodeAt(2))) {
            isAbsolute2 = true;
            rootEnd = 3;
          }
        }
        let tail = rootEnd < len ? normalizeString2(path.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator3) : "";
        if (tail.length === 0 && !isAbsolute2) {
          tail = ".";
        }
        if (tail.length > 0 && isPathSeparator3(path.charCodeAt(len - 1))) {
          tail += "\\";
        }
        if (device === void 0) {
          return isAbsolute2 ? `\\${tail}` : tail;
        }
        return isAbsolute2 ? `${device}\\${tail}` : `${device}${tail}`;
      },
      isAbsolute(path) {
        validateString2(path, "path");
        const len = path.length;
        if (len === 0) {
          return false;
        }
        const code2 = path.charCodeAt(0);
        return isPathSeparator3(code2) || // Possible device root
        len > 2 && isWindowsDeviceRoot2(code2) && path.charCodeAt(1) === CHAR_COLON2 && isPathSeparator3(path.charCodeAt(2));
      },
      join(...paths) {
        if (paths.length === 0) {
          return ".";
        }
        let joined;
        let firstPart;
        for (let i = 0; i < paths.length; ++i) {
          const arg = paths[i];
          validateString2(arg, "path");
          if (arg.length > 0) {
            if (joined === void 0) {
              joined = firstPart = arg;
            } else {
              joined += `\\${arg}`;
            }
          }
        }
        if (joined === void 0) {
          return ".";
        }
        let needsReplace = true;
        let slashCount = 0;
        if (typeof firstPart === "string" && isPathSeparator3(firstPart.charCodeAt(0))) {
          ++slashCount;
          const firstLen = firstPart.length;
          if (firstLen > 1 && isPathSeparator3(firstPart.charCodeAt(1))) {
            ++slashCount;
            if (firstLen > 2) {
              if (isPathSeparator3(firstPart.charCodeAt(2))) {
                ++slashCount;
              } else {
                needsReplace = false;
              }
            }
          }
        }
        if (needsReplace) {
          while (slashCount < joined.length && isPathSeparator3(joined.charCodeAt(slashCount))) {
            slashCount++;
          }
          if (slashCount >= 2) {
            joined = `\\${joined.slice(slashCount)}`;
          }
        }
        return exports.win32.normalize(joined);
      },
      // It will solve the relative path from `from` to `to`, for instance:
      //  from = 'C:\\orandea\\test\\aaa'
      //  to = 'C:\\orandea\\impl\\bbb'
      // The output of the function should be: '..\\..\\impl\\bbb'
      relative(from, to) {
        validateString2(from, "from");
        validateString2(to, "to");
        if (from === to) {
          return "";
        }
        const fromOrig = exports.win32.resolve(from);
        const toOrig = exports.win32.resolve(to);
        if (fromOrig === toOrig) {
          return "";
        }
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to) {
          return "";
        }
        let fromStart = 0;
        while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH2) {
          fromStart++;
        }
        let fromEnd = from.length;
        while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH2) {
          fromEnd--;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 0;
        while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH2) {
          toStart++;
        }
        let toEnd = to.length;
        while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH2) {
          toEnd--;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i < length; i++) {
          const fromCode = from.charCodeAt(fromStart + i);
          if (fromCode !== to.charCodeAt(toStart + i)) {
            break;
          } else if (fromCode === CHAR_BACKWARD_SLASH2) {
            lastCommonSep = i;
          }
        }
        if (i !== length) {
          if (lastCommonSep === -1) {
            return toOrig;
          }
        } else {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH2) {
              return toOrig.slice(toStart + i + 1);
            }
            if (i === 2) {
              return toOrig.slice(toStart + i);
            }
          }
          if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH2) {
              lastCommonSep = i;
            } else if (i === 2) {
              lastCommonSep = 3;
            }
          }
          if (lastCommonSep === -1) {
            lastCommonSep = 0;
          }
        }
        let out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH2) {
            out += out.length === 0 ? ".." : "\\..";
          }
        }
        toStart += lastCommonSep;
        if (out.length > 0) {
          return `${out}${toOrig.slice(toStart, toEnd)}`;
        }
        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH2) {
          ++toStart;
        }
        return toOrig.slice(toStart, toEnd);
      },
      toNamespacedPath(path) {
        if (typeof path !== "string" || path.length === 0) {
          return path;
        }
        const resolvedPath = exports.win32.resolve(path);
        if (resolvedPath.length <= 2) {
          return path;
        }
        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH2) {
          if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH2) {
            const code2 = resolvedPath.charCodeAt(2);
            if (code2 !== CHAR_QUESTION_MARK2 && code2 !== CHAR_DOT2) {
              return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
            }
          }
        } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON2 && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH2) {
          return `\\\\?\\${resolvedPath}`;
        }
        return path;
      },
      dirname(path) {
        validateString2(path, "path");
        const len = path.length;
        if (len === 0) {
          return ".";
        }
        let rootEnd = -1;
        let offset = 0;
        const code2 = path.charCodeAt(0);
        if (len === 1) {
          return isPathSeparator3(code2) ? path : ".";
        }
        if (isPathSeparator3(code2)) {
          rootEnd = offset = 1;
          if (isPathSeparator3(path.charCodeAt(1))) {
            let j = 2;
            let last = j;
            while (j < len && !isPathSeparator3(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && isPathSeparator3(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && !isPathSeparator3(path.charCodeAt(j))) {
                  j++;
                }
                if (j === len) {
                  return path;
                }
                if (j !== last) {
                  rootEnd = offset = j + 1;
                }
              }
            }
          }
        } else if (isWindowsDeviceRoot2(code2) && path.charCodeAt(1) === CHAR_COLON2) {
          rootEnd = len > 2 && isPathSeparator3(path.charCodeAt(2)) ? 3 : 2;
          offset = rootEnd;
        }
        let end = -1;
        let matchedSlash = true;
        for (let i = len - 1; i >= offset; --i) {
          if (isPathSeparator3(path.charCodeAt(i))) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) {
          if (rootEnd === -1) {
            return ".";
          }
          end = rootEnd;
        }
        return path.slice(0, end);
      },
      basename(path, ext) {
        if (ext !== void 0) {
          validateString2(ext, "ext");
        }
        validateString2(path, "path");
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (path.length >= 2 && isWindowsDeviceRoot2(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON2) {
          start = 2;
        }
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext === path) {
            return "";
          }
          let extIdx = ext.length - 1;
          let firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= start; --i) {
            const code2 = path.charCodeAt(i);
            if (isPathSeparator3(code2)) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code2 === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) {
            end = firstNonSlashEnd;
          } else if (end === -1) {
            end = path.length;
          }
          return path.slice(start, end);
        }
        for (i = path.length - 1; i >= start; --i) {
          if (isPathSeparator3(path.charCodeAt(i))) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
        }
        if (end === -1) {
          return "";
        }
        return path.slice(start, end);
      },
      extname(path) {
        validateString2(path, "path");
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON2 && isWindowsDeviceRoot2(path.charCodeAt(0))) {
          start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
          const code2 = path.charCodeAt(i);
          if (isPathSeparator3(code2)) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code2 === CHAR_DOT2) {
            if (startDot === -1) {
              startDot = i;
            } else if (preDotState !== 1) {
              preDotState = 1;
            }
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: _format2.bind(null, "\\"),
      parse(path) {
        validateString2(path, "path");
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0) {
          return ret;
        }
        const len = path.length;
        let rootEnd = 0;
        let code2 = path.charCodeAt(0);
        if (len === 1) {
          if (isPathSeparator3(code2)) {
            ret.root = ret.dir = path;
            return ret;
          }
          ret.base = ret.name = path;
          return ret;
        }
        if (isPathSeparator3(code2)) {
          rootEnd = 1;
          if (isPathSeparator3(path.charCodeAt(1))) {
            let j = 2;
            let last = j;
            while (j < len && !isPathSeparator3(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && isPathSeparator3(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && !isPathSeparator3(path.charCodeAt(j))) {
                  j++;
                }
                if (j === len) {
                  rootEnd = j;
                } else if (j !== last) {
                  rootEnd = j + 1;
                }
              }
            }
          }
        } else if (isWindowsDeviceRoot2(code2) && path.charCodeAt(1) === CHAR_COLON2) {
          if (len <= 2) {
            ret.root = ret.dir = path;
            return ret;
          }
          rootEnd = 2;
          if (isPathSeparator3(path.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path;
              return ret;
            }
            rootEnd = 3;
          }
        }
        if (rootEnd > 0) {
          ret.root = path.slice(0, rootEnd);
        }
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= rootEnd; --i) {
          code2 = path.charCodeAt(i);
          if (isPathSeparator3(code2)) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code2 === CHAR_DOT2) {
            if (startDot === -1) {
              startDot = i;
            } else if (preDotState !== 1) {
              preDotState = 1;
            }
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (end !== -1) {
          if (startDot === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            ret.base = ret.name = path.slice(startPart, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
            ret.ext = path.slice(startDot, end);
          }
        }
        if (startPart > 0 && startPart !== rootEnd) {
          ret.dir = path.slice(0, startPart - 1);
        } else {
          ret.dir = ret.root;
        }
        return ret;
      },
      sep: "\\",
      delimiter: ";",
      win32: null,
      posix: null
    };
    var posixCwd2 = (() => {
      if (platformIsWin322) {
        const regexp = /\\/g;
        return () => {
          const cwd2 = process2.cwd().replace(regexp, "/");
          return cwd2.slice(cwd2.indexOf("/"));
        };
      }
      return () => process2.cwd();
    })();
    exports.posix = {
      // path.resolve([from ...], to)
      resolve(...pathSegments) {
        let resolvedPath = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          const path = i >= 0 ? pathSegments[i] : posixCwd2();
          validateString2(path, "path");
          if (path.length === 0) {
            continue;
          }
          resolvedPath = `${path}/${resolvedPath}`;
          resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH2;
        }
        resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator2);
        if (resolvedAbsolute) {
          return `/${resolvedPath}`;
        }
        return resolvedPath.length > 0 ? resolvedPath : ".";
      },
      normalize(path) {
        validateString2(path, "path");
        if (path.length === 0) {
          return ".";
        }
        const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH2;
        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH2;
        path = normalizeString2(path, !isAbsolute2, "/", isPosixPathSeparator2);
        if (path.length === 0) {
          if (isAbsolute2) {
            return "/";
          }
          return trailingSeparator ? "./" : ".";
        }
        if (trailingSeparator) {
          path += "/";
        }
        return isAbsolute2 ? `/${path}` : path;
      },
      isAbsolute(path) {
        validateString2(path, "path");
        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH2;
      },
      join(...paths) {
        if (paths.length === 0) {
          return ".";
        }
        let joined;
        for (let i = 0; i < paths.length; ++i) {
          const arg = paths[i];
          validateString2(arg, "path");
          if (arg.length > 0) {
            if (joined === void 0) {
              joined = arg;
            } else {
              joined += `/${arg}`;
            }
          }
        }
        if (joined === void 0) {
          return ".";
        }
        return exports.posix.normalize(joined);
      },
      relative(from, to) {
        validateString2(from, "from");
        validateString2(to, "to");
        if (from === to) {
          return "";
        }
        from = exports.posix.resolve(from);
        to = exports.posix.resolve(to);
        if (from === to) {
          return "";
        }
        const fromStart = 1;
        const fromEnd = from.length;
        const fromLen = fromEnd - fromStart;
        const toStart = 1;
        const toLen = to.length - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i < length; i++) {
          const fromCode = from.charCodeAt(fromStart + i);
          if (fromCode !== to.charCodeAt(toStart + i)) {
            break;
          } else if (fromCode === CHAR_FORWARD_SLASH2) {
            lastCommonSep = i;
          }
        }
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH2) {
              return to.slice(toStart + i + 1);
            }
            if (i === 0) {
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH2) {
              lastCommonSep = i;
            } else if (i === 0) {
              lastCommonSep = 0;
            }
          }
        }
        let out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH2) {
            out += out.length === 0 ? ".." : "/..";
          }
        }
        return `${out}${to.slice(toStart + lastCommonSep)}`;
      },
      toNamespacedPath(path) {
        return path;
      },
      dirname(path) {
        validateString2(path, "path");
        if (path.length === 0) {
          return ".";
        }
        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH2;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
          if (path.charCodeAt(i) === CHAR_FORWARD_SLASH2) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) {
          return hasRoot ? "/" : ".";
        }
        if (hasRoot && end === 1) {
          return "//";
        }
        return path.slice(0, end);
      },
      basename(path, ext) {
        if (ext !== void 0) {
          validateString2(ext, "ext");
        }
        validateString2(path, "path");
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext === path) {
            return "";
          }
          let extIdx = ext.length - 1;
          let firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            const code2 = path.charCodeAt(i);
            if (code2 === CHAR_FORWARD_SLASH2) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code2 === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) {
            end = firstNonSlashEnd;
          } else if (end === -1) {
            end = path.length;
          }
          return path.slice(start, end);
        }
        for (i = path.length - 1; i >= 0; --i) {
          if (path.charCodeAt(i) === CHAR_FORWARD_SLASH2) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
        }
        if (end === -1) {
          return "";
        }
        return path.slice(start, end);
      },
      extname(path) {
        validateString2(path, "path");
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
          const code2 = path.charCodeAt(i);
          if (code2 === CHAR_FORWARD_SLASH2) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code2 === CHAR_DOT2) {
            if (startDot === -1) {
              startDot = i;
            } else if (preDotState !== 1) {
              preDotState = 1;
            }
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: _format2.bind(null, "/"),
      parse(path) {
        validateString2(path, "path");
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0) {
          return ret;
        }
        const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH2;
        let start;
        if (isAbsolute2) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= start; --i) {
          const code2 = path.charCodeAt(i);
          if (code2 === CHAR_FORWARD_SLASH2) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code2 === CHAR_DOT2) {
            if (startDot === -1) {
              startDot = i;
            } else if (preDotState !== 1) {
              preDotState = 1;
            }
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (end !== -1) {
          const start2 = startPart === 0 && isAbsolute2 ? 1 : startPart;
          if (startDot === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            ret.base = ret.name = path.slice(start2, end);
          } else {
            ret.name = path.slice(start2, startDot);
            ret.base = path.slice(start2, end);
            ret.ext = path.slice(startDot, end);
          }
        }
        if (startPart > 0) {
          ret.dir = path.slice(0, startPart - 1);
        } else if (isAbsolute2) {
          ret.dir = "/";
        }
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    exports.posix.win32 = exports.win32.win32 = exports.win32;
    exports.posix.posix = exports.win32.posix = exports.posix;
    exports.normalize = platformIsWin322 ? exports.win32.normalize : exports.posix.normalize;
    exports.isAbsolute = platformIsWin322 ? exports.win32.isAbsolute : exports.posix.isAbsolute;
    exports.join = platformIsWin322 ? exports.win32.join : exports.posix.join;
    exports.resolve = platformIsWin322 ? exports.win32.resolve : exports.posix.resolve;
    exports.relative = platformIsWin322 ? exports.win32.relative : exports.posix.relative;
    exports.dirname = platformIsWin322 ? exports.win32.dirname : exports.posix.dirname;
    exports.basename = platformIsWin322 ? exports.win32.basename : exports.posix.basename;
    exports.extname = platformIsWin322 ? exports.win32.extname : exports.posix.extname;
    exports.format = platformIsWin322 ? exports.win32.format : exports.posix.format;
    exports.parse = platformIsWin322 ? exports.win32.parse : exports.posix.parse;
    exports.toNamespacedPath = platformIsWin322 ? exports.win32.toNamespacedPath : exports.posix.toNamespacedPath;
    exports.sep = platformIsWin322 ? exports.win32.sep : exports.posix.sep;
    exports.delimiter = platformIsWin322 ? exports.win32.delimiter : exports.posix.delimiter;
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/util/vs/common/uri.js
var require_uri = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/util/vs/common/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URI = void 0;
    exports.isUriComponents = isUriComponents2;
    exports.uriToFsPath = uriToFsPath2;
    var paths = require_path();
    var platform_1 = require_platform();
    var _schemePattern2 = /^\w[\w\d+.-]*$/;
    var _singleSlashStart2 = /^\//;
    var _doubleSlashStart2 = /^\/\//;
    function _validateUri2(ret, _strict) {
      if (!ret.scheme && _strict) {
        throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
      }
      if (ret.scheme && !_schemePattern2.test(ret.scheme)) {
        throw new Error("[UriError]: Scheme contains illegal characters.");
      }
      if (ret.path) {
        if (ret.authority) {
          if (!_singleSlashStart2.test(ret.path)) {
            throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
          }
        } else {
          if (_doubleSlashStart2.test(ret.path)) {
            throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
      }
    }
    function _schemeFix2(scheme, _strict) {
      if (!scheme && !_strict) {
        return "file";
      }
      return scheme;
    }
    function _referenceResolution2(scheme, path) {
      switch (scheme) {
        case "https":
        case "http":
        case "file":
          if (!path) {
            path = _slash2;
          } else if (path[0] !== _slash2) {
            path = _slash2 + path;
          }
          break;
      }
      return path;
    }
    var _empty2 = "";
    var _slash2 = "/";
    var _regexp2 = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    var URI2 = class _URI {
      static isUri(thing) {
        if (thing instanceof _URI) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
      }
      /**
       * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.
       * The part before the first colon.
       */
      scheme;
      /**
       * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.
       * The part between the first double slashes and the next slash.
       */
      authority;
      /**
       * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.
       */
      path;
      /**
       * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.
       */
      query;
      /**
       * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.
       */
      fragment;
      /**
       * @internal
       */
      constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
        if (typeof schemeOrData === "object") {
          this.scheme = schemeOrData.scheme || _empty2;
          this.authority = schemeOrData.authority || _empty2;
          this.path = schemeOrData.path || _empty2;
          this.query = schemeOrData.query || _empty2;
          this.fragment = schemeOrData.fragment || _empty2;
        } else {
          this.scheme = _schemeFix2(schemeOrData, _strict);
          this.authority = authority || _empty2;
          this.path = _referenceResolution2(this.scheme, path || _empty2);
          this.query = query || _empty2;
          this.fragment = fragment || _empty2;
          _validateUri2(this, _strict);
        }
      }
      // ---- filesystem path -----------------------
      /**
       * Returns a string representing the corresponding file system path of this URI.
       * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
       * platform specific path separator.
       *
       * * Will *not* validate the path for invalid characters and semantics.
       * * Will *not* look at the scheme of this URI.
       * * The result shall *not* be used for display purposes but for accessing a file on disk.
       *
       *
       * The *difference* to `URI#path` is the use of the platform specific separator and the handling
       * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
       *
       * ```ts
          const u = URI.parse('file://server/c$/folder/file.txt')
          u.authority === 'server'
          u.path === '/shares/c$/file.txt'
          u.fsPath === '\\server\c$\folder\file.txt'
      ```
       *
       * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
       * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
       * with URIs that represent files on disk (`file` scheme).
       */
      get fsPath() {
        return uriToFsPath2(this, false);
      }
      // ---- modify to new -------------------------
      with(change) {
        if (!change) {
          return this;
        }
        let { scheme, authority, path, query, fragment } = change;
        if (scheme === void 0) {
          scheme = this.scheme;
        } else if (scheme === null) {
          scheme = _empty2;
        }
        if (authority === void 0) {
          authority = this.authority;
        } else if (authority === null) {
          authority = _empty2;
        }
        if (path === void 0) {
          path = this.path;
        } else if (path === null) {
          path = _empty2;
        }
        if (query === void 0) {
          query = this.query;
        } else if (query === null) {
          query = _empty2;
        }
        if (fragment === void 0) {
          fragment = this.fragment;
        } else if (fragment === null) {
          fragment = _empty2;
        }
        if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
          return this;
        }
        return new Uri13(scheme, authority, path, query, fragment);
      }
      // ---- parse & validate ------------------------
      /**
       * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
       * `file:///usr/home`, or `scheme:with/path`.
       *
       * @param value A string which represents an URI (see `URI#toString`).
       */
      static parse(value, _strict = false) {
        const match3 = _regexp2.exec(value);
        if (!match3) {
          return new Uri13(_empty2, _empty2, _empty2, _empty2, _empty2);
        }
        return new Uri13(match3[2] || _empty2, percentDecode2(match3[4] || _empty2), percentDecode2(match3[5] || _empty2), percentDecode2(match3[7] || _empty2), percentDecode2(match3[9] || _empty2), _strict);
      }
      /**
       * Creates a new URI from a file system path, e.g. `c:\my\files`,
       * `/usr/home`, or `\\server\share\some\path`.
       *
       * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
       * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
       * `URI.parse('file://' + path)` because the path might contain characters that are
       * interpreted (# and ?). See the following sample:
       * ```ts
      const good = URI.file('/coding/c#/project1');
      good.scheme === 'file';
      good.path === '/coding/c#/project1';
      good.fragment === '';
      const bad = URI.parse('file://' + '/coding/c#/project1');
      bad.scheme === 'file';
      bad.path === '/coding/c'; // path is now broken
      bad.fragment === '/project1';
      ```
       *
       * @param path A file system path (see `URI#fsPath`)
       */
      static file(path) {
        let authority = _empty2;
        if (platform_1.isWindows) {
          path = path.replace(/\\/g, _slash2);
        }
        if (path[0] === _slash2 && path[1] === _slash2) {
          const idx = path.indexOf(_slash2, 2);
          if (idx === -1) {
            authority = path.substring(2);
            path = _slash2;
          } else {
            authority = path.substring(2, idx);
            path = path.substring(idx) || _slash2;
          }
        }
        return new Uri13("file", authority, path, _empty2, _empty2);
      }
      /**
       * Creates new URI from uri components.
       *
       * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
       * validation and should be used for untrusted uri components retrieved from storage,
       * user input, command arguments etc
       */
      static from(components, strict) {
        const result = new Uri13(components.scheme, components.authority, components.path, components.query, components.fragment, strict);
        return result;
      }
      /**
       * Join a URI path with path fragments and normalizes the resulting path.
       *
       * @param uri The input URI.
       * @param pathFragment The path fragment to add to the URI path.
       * @returns The resulting URI.
       */
      static joinPath(uri, ...pathFragment) {
        if (!uri.path) {
          throw new Error(`[UriError]: cannot call joinPath on URI without path`);
        }
        let newPath;
        if (platform_1.isWindows && uri.scheme === "file") {
          newPath = _URI.file(paths.win32.join(uriToFsPath2(uri, true), ...pathFragment)).path;
        } else {
          newPath = paths.posix.join(uri.path, ...pathFragment);
        }
        return uri.with({ path: newPath });
      }
      // ---- printing/externalize ---------------------------
      /**
       * Creates a string representation for this URI. It's guaranteed that calling
       * `URI.parse` with the result of this function creates an URI which is equal
       * to this URI.
       *
       * * The result shall *not* be used for display purposes but for externalization or transport.
       * * The result will be encoded using the percentage encoding and encoding happens mostly
       * ignore the scheme-specific encoding rules.
       *
       * @param skipEncoding Do not encode the result, default is `false`
       */
      toString(skipEncoding = false) {
        return _asFormatted2(this, skipEncoding);
      }
      toJSON() {
        return this;
      }
      static revive(data) {
        if (!data) {
          return data;
        } else if (data instanceof _URI) {
          return data;
        } else {
          const result = new Uri13(data);
          result._formatted = data.external ?? null;
          result._fsPath = data._sep === _pathSepMarker2 ? data.fsPath ?? null : null;
          return result;
        }
      }
    };
    exports.URI = URI2;
    function isUriComponents2(thing) {
      if (!thing || typeof thing !== "object") {
        return false;
      }
      return typeof thing.scheme === "string" && (typeof thing.authority === "string" || typeof thing.authority === "undefined") && (typeof thing.path === "string" || typeof thing.path === "undefined") && (typeof thing.query === "string" || typeof thing.query === "undefined") && (typeof thing.fragment === "string" || typeof thing.fragment === "undefined");
    }
    var _pathSepMarker2 = platform_1.isWindows ? 1 : void 0;
    var Uri13 = class extends URI2 {
      _formatted = null;
      _fsPath = null;
      get fsPath() {
        if (!this._fsPath) {
          this._fsPath = uriToFsPath2(this, false);
        }
        return this._fsPath;
      }
      toString(skipEncoding = false) {
        if (!skipEncoding) {
          if (!this._formatted) {
            this._formatted = _asFormatted2(this, false);
          }
          return this._formatted;
        } else {
          return _asFormatted2(this, true);
        }
      }
      toJSON() {
        const res = {
          $mid: 1
          /* MarshalledId.Uri */
        };
        if (this._fsPath) {
          res.fsPath = this._fsPath;
          res._sep = _pathSepMarker2;
        }
        if (this._formatted) {
          res.external = this._formatted;
        }
        if (this.path) {
          res.path = this.path;
        }
        if (this.scheme) {
          res.scheme = this.scheme;
        }
        if (this.authority) {
          res.authority = this.authority;
        }
        if (this.query) {
          res.query = this.query;
        }
        if (this.fragment) {
          res.fragment = this.fragment;
        }
        return res;
      }
    };
    var encodeTable2 = {
      [
        58
        /* CharCode.Colon */
      ]: "%3A",
      // gen-delims
      [
        47
        /* CharCode.Slash */
      ]: "%2F",
      [
        63
        /* CharCode.QuestionMark */
      ]: "%3F",
      [
        35
        /* CharCode.Hash */
      ]: "%23",
      [
        91
        /* CharCode.OpenSquareBracket */
      ]: "%5B",
      [
        93
        /* CharCode.CloseSquareBracket */
      ]: "%5D",
      [
        64
        /* CharCode.AtSign */
      ]: "%40",
      [
        33
        /* CharCode.ExclamationMark */
      ]: "%21",
      // sub-delims
      [
        36
        /* CharCode.DollarSign */
      ]: "%24",
      [
        38
        /* CharCode.Ampersand */
      ]: "%26",
      [
        39
        /* CharCode.SingleQuote */
      ]: "%27",
      [
        40
        /* CharCode.OpenParen */
      ]: "%28",
      [
        41
        /* CharCode.CloseParen */
      ]: "%29",
      [
        42
        /* CharCode.Asterisk */
      ]: "%2A",
      [
        43
        /* CharCode.Plus */
      ]: "%2B",
      [
        44
        /* CharCode.Comma */
      ]: "%2C",
      [
        59
        /* CharCode.Semicolon */
      ]: "%3B",
      [
        61
        /* CharCode.Equals */
      ]: "%3D",
      [
        32
        /* CharCode.Space */
      ]: "%20"
    };
    function encodeURIComponentFast2(uriComponent, isPath, isAuthority) {
      let res = void 0;
      let nativeEncodePos = -1;
      for (let pos = 0; pos < uriComponent.length; pos++) {
        const code2 = uriComponent.charCodeAt(pos);
        if (code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90 || code2 >= 48 && code2 <= 57 || code2 === 45 || code2 === 46 || code2 === 95 || code2 === 126 || isPath && code2 === 47 || isAuthority && code2 === 91 || isAuthority && code2 === 93 || isAuthority && code2 === 58) {
          if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
            nativeEncodePos = -1;
          }
          if (res !== void 0) {
            res += uriComponent.charAt(pos);
          }
        } else {
          if (res === void 0) {
            res = uriComponent.substr(0, pos);
          }
          const escaped = encodeTable2[code2];
          if (escaped !== void 0) {
            if (nativeEncodePos !== -1) {
              res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
              nativeEncodePos = -1;
            }
            res += escaped;
          } else if (nativeEncodePos === -1) {
            nativeEncodePos = pos;
          }
        }
      }
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
      }
      return res !== void 0 ? res : uriComponent;
    }
    function encodeURIComponentMinimal2(path) {
      let res = void 0;
      for (let pos = 0; pos < path.length; pos++) {
        const code2 = path.charCodeAt(pos);
        if (code2 === 35 || code2 === 63) {
          if (res === void 0) {
            res = path.substr(0, pos);
          }
          res += encodeTable2[code2];
        } else {
          if (res !== void 0) {
            res += path[pos];
          }
        }
      }
      return res !== void 0 ? res : path;
    }
    function uriToFsPath2(uri, keepDriveLetterCasing) {
      let value;
      if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
        value = `//${uri.authority}${uri.path}`;
      } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
        if (!keepDriveLetterCasing) {
          value = uri.path[1].toLowerCase() + uri.path.substr(2);
        } else {
          value = uri.path.substr(1);
        }
      } else {
        value = uri.path;
      }
      if (platform_1.isWindows) {
        value = value.replace(/\//g, "\\");
      }
      return value;
    }
    function _asFormatted2(uri, skipEncoding) {
      const encoder = !skipEncoding ? encodeURIComponentFast2 : encodeURIComponentMinimal2;
      let res = "";
      let { scheme, authority, path, query, fragment } = uri;
      if (scheme) {
        res += scheme;
        res += ":";
      }
      if (authority || scheme === "file") {
        res += _slash2;
        res += _slash2;
      }
      if (authority) {
        let idx = authority.indexOf("@");
        if (idx !== -1) {
          const userinfo = authority.substr(0, idx);
          authority = authority.substr(idx + 1);
          idx = userinfo.lastIndexOf(":");
          if (idx === -1) {
            res += encoder(userinfo, false, false);
          } else {
            res += encoder(userinfo.substr(0, idx), false, false);
            res += ":";
            res += encoder(userinfo.substr(idx + 1), false, true);
          }
          res += "@";
        }
        authority = authority.toLowerCase();
        idx = authority.lastIndexOf(":");
        if (idx === -1) {
          res += encoder(authority, false, true);
        } else {
          res += encoder(authority.substr(0, idx), false, true);
          res += authority.substr(idx);
        }
      }
      if (path) {
        if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
          const code2 = path.charCodeAt(1);
          if (code2 >= 65 && code2 <= 90) {
            path = `/${String.fromCharCode(code2 + 32)}:${path.substr(3)}`;
          }
        } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
          const code2 = path.charCodeAt(0);
          if (code2 >= 65 && code2 <= 90) {
            path = `${String.fromCharCode(code2 + 32)}:${path.substr(2)}`;
          }
        }
        res += encoder(path, true, false);
      }
      if (query) {
        res += "?";
        res += encoder(query, false, false);
      }
      if (fragment) {
        res += "#";
        res += !skipEncoding ? encodeURIComponentFast2(fragment, false, false) : fragment;
      }
      return res;
    }
    function decodeURIComponentGraceful2(str) {
      try {
        return decodeURIComponent(str);
      } catch {
        if (str.length > 3) {
          return str.substr(0, 3) + decodeURIComponentGraceful2(str.substr(3));
        } else {
          return str;
        }
      }
    }
    var _rEncodedAsHex2 = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    function percentDecode2(str) {
      if (!str.match(_rEncodedAsHex2)) {
        return str;
      }
      return str.replace(_rEncodedAsHex2, (match3) => decodeURIComponentGraceful2(match3));
    }
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/results.js
var require_results = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/results.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromptReference = exports.ChatResponseReferencePartStatusKind = exports.PromptMetadata = void 0;
    var uri_1 = require_uri();
    var PromptMetadata = class {
      _marker;
      toString() {
        return Object.getPrototypeOf(this).constructor.name;
      }
    };
    exports.PromptMetadata = PromptMetadata;
    var ChatResponseReferencePartStatusKind;
    (function(ChatResponseReferencePartStatusKind2) {
      ChatResponseReferencePartStatusKind2[ChatResponseReferencePartStatusKind2["Complete"] = 1] = "Complete";
      ChatResponseReferencePartStatusKind2[ChatResponseReferencePartStatusKind2["Partial"] = 2] = "Partial";
      ChatResponseReferencePartStatusKind2[ChatResponseReferencePartStatusKind2["Omitted"] = 3] = "Omitted";
    })(ChatResponseReferencePartStatusKind || (exports.ChatResponseReferencePartStatusKind = ChatResponseReferencePartStatusKind = {}));
    var PromptReference = class _PromptReference {
      anchor;
      iconPath;
      options;
      static fromJSON(json) {
        const uriOrLocation = (v) => "scheme" in v ? uri_1.URI.from(v) : { uri: uri_1.URI.from(v.uri), range: v.range };
        return new _PromptReference("variableName" in json.anchor ? {
          variableName: json.anchor.variableName,
          value: json.anchor.value && uriOrLocation(json.anchor.value)
        } : uriOrLocation(json.anchor), json.iconPath && ("scheme" in json.iconPath ? uri_1.URI.from(json.iconPath) : "light" in json.iconPath ? { light: uri_1.URI.from(json.iconPath.light), dark: uri_1.URI.from(json.iconPath.dark) } : json.iconPath), json.options);
      }
      constructor(anchor, iconPath, options) {
        this.anchor = anchor;
        this.iconPath = iconPath;
        this.options = options;
      }
      toJSON() {
        return {
          anchor: this.anchor,
          iconPath: this.iconPath,
          options: this.options
        };
      }
    };
    exports.PromptReference = PromptReference;
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/promptRenderer.js
var require_promptRenderer = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/promptRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromptRenderer = exports.MetadataMap = void 0;
    var JSONT = require_jsonTypes();
    var materialized_1 = require_materialized();
    var mode_1 = require_mode();
    var promptElements_1 = require_promptElements();
    var results_1 = require_results();
    var MetadataMap;
    (function(MetadataMap2) {
      MetadataMap2.empty = {
        get: () => void 0,
        getAll: () => []
      };
      MetadataMap2.from = (metadata) => {
        return {
          get: (ctor) => metadata.find((m) => m instanceof ctor),
          getAll: (ctor) => metadata.filter((m) => m instanceof ctor)
        };
      };
    })(MetadataMap || (exports.MetadataMap = MetadataMap = {}));
    var PromptRenderer2 = class {
      _endpoint;
      _ctor;
      _props;
      _tokenizer;
      _usedContext = [];
      _ignoredFiles = [];
      _growables = [];
      _root = new PromptTreeElement(null, 0);
      _tokenLimits = [];
      /** Epoch used to tracing the order in which elements render. */
      tracer = void 0;
      /**
       * @param _endpoint The chat endpoint that the rendered prompt will be sent to.
       * @param _ctor The prompt element constructor to render.
       * @param _props The props to pass to the prompt element.
       */
      constructor(_endpoint, _ctor, _props, _tokenizer) {
        this._endpoint = _endpoint;
        this._ctor = _ctor;
        this._props = _props;
        this._tokenizer = _tokenizer;
      }
      getIgnoredFiles() {
        return Array.from(new Set(this._ignoredFiles));
      }
      getUsedContext() {
        return this._usedContext;
      }
      createElement(element) {
        return new element.ctor(element.props);
      }
      async _processPromptPieces(sizing, pieces, progress, token) {
        const promptElements = /* @__PURE__ */ new Map();
        for (const [i, element] of pieces.entries()) {
          if (Array.isArray(element.children)) {
            element.props = element.props ?? {};
            element.props.children = element.children;
          }
          if (!element.ctor) {
            const loc = atPath(element.path);
            throw new Error(`Invalid ChatMessage child! Child must be a TSX component that extends PromptElement at ${loc}`);
          }
          const promptElement = this.createElement(element);
          let tokenLimit;
          if (promptElement instanceof promptElements_1.TokenLimit) {
            tokenLimit = element.props.max;
            this._tokenLimits.push({ limit: tokenLimit, id: element.node.id });
          }
          element.node.setObj(promptElement);
          const flexGroupValue = element.props.flexGrow ?? Infinity;
          let flexGroup = promptElements.get(flexGroupValue);
          if (!flexGroup) {
            flexGroup = [];
            promptElements.set(flexGroupValue, flexGroup);
          }
          flexGroup.push({ element, promptElementInstance: promptElement, tokenLimit });
        }
        if (promptElements.size === 0) {
          return;
        }
        const flexGroups = [...promptElements.entries()].sort(([a], [b]) => b - a).map(([_, group]) => group);
        const setReserved = (groupIndex) => {
          let reservedTokens = 0;
          for (let i = groupIndex + 1; i < flexGroups.length; i++) {
            for (const { element } of flexGroups[i]) {
              if (!element.props.flexReserve) {
                continue;
              }
              const reserve = typeof element.props.flexReserve === "string" ? (
                // Typings ensure the string is `/${number}`
                Math.floor(sizing.remainingTokenBudget / Number(element.props.flexReserve.slice(1)))
              ) : element.props.flexReserve;
              reservedTokens += reserve;
            }
          }
          sizing.consume(reservedTokens);
          return reservedTokens;
        };
        for (const [groupIndex, promptElements2] of flexGroups.entries()) {
          const reservedTokens = setReserved(groupIndex);
          let flexBasisSum = 0;
          for (const { element } of promptElements2) {
            flexBasisSum += element.props.flexBasis ?? 1;
          }
          let constantTokenLimits = 0;
          const useConstantLimitsForIndex = promptElements2.map((e) => {
            if (e.tokenLimit === void 0) {
              return false;
            }
            const flexBasis = e.element.props.flexBasis ?? 1;
            const proportion = flexBasis / flexBasisSum;
            const proportionateUsage = Math.floor(sizing.remainingTokenBudget * proportion);
            if (proportionateUsage < e.tokenLimit) {
              return false;
            }
            flexBasisSum -= flexBasis;
            constantTokenLimits += e.tokenLimit;
            return true;
          });
          const elementSizings = promptElements2.map((e, i) => {
            const proportion = (e.element.props.flexBasis ?? 1) / flexBasisSum;
            return {
              tokenBudget: useConstantLimitsForIndex[i] ? e.tokenLimit : Math.floor((sizing.remainingTokenBudget - constantTokenLimits) * proportion),
              endpoint: sizing.endpoint,
              countTokens: (text2, cancellation) => this._tokenizer.tokenLength(typeof text2 === "string" ? { type: mode_1.Raw.ChatCompletionContentPartKind.Text, text: text2 } : text2, cancellation)
            };
          });
          sizing.consume(-reservedTokens);
          this.tracer?.addRenderEpoch?.({
            inNode: promptElements2[0].element.node.parent?.id,
            flexValue: promptElements2[0].element.props.flexGrow ?? 0,
            tokenBudget: sizing.remainingTokenBudget,
            reservedTokens,
            elements: promptElements2.map((e, i) => ({
              id: e.element.node.id,
              tokenBudget: elementSizings[i].tokenBudget
            }))
          });
          await Promise.all(promptElements2.map(async ({ element, promptElementInstance }, i) => {
            const state = await annotateError(element, () => promptElementInstance.prepare?.(elementSizings[i], progress, token));
            element.node.setState(state);
          }));
          const templates = await Promise.all(promptElements2.map(async ({ element, promptElementInstance }, i) => {
            const elementSizing = elementSizings[i];
            return await annotateError(element, () => promptElementInstance.render(element.node.getState(), elementSizing, progress, token));
          }));
          for (const [i, { element, promptElementInstance }] of promptElements2.entries()) {
            const elementSizing = elementSizings[i];
            const template = templates[i];
            if (!template) {
              continue;
            }
            const childConsumption = await this._processPromptRenderPiece(new PromptSizingContext(elementSizing.tokenBudget, this._endpoint), element, promptElementInstance, template, progress, token);
            if (promptElementInstance instanceof promptElements_1.Expandable) {
              this._growables.push({ initialConsume: childConsumption, elem: element.node });
            }
            sizing.consume(childConsumption);
          }
        }
      }
      async _processPromptRenderPiece(elementSizing, element, promptElementInstance, template, progress, token) {
        const pieces = flattenAndReduce(template);
        const childSizing = new PromptSizingContext(elementSizing.tokenBudget, this._endpoint);
        const { tokensConsumed } = await computeTokensConsumedByLiterals(this._tokenizer, element, promptElementInstance, pieces);
        childSizing.consume(tokensConsumed);
        await this._handlePromptChildren(element, pieces, childSizing, progress, token);
        return childSizing.consumed;
      }
      /**
       * Renders the prompt element and its children to a JSON-serializable state.
       * @returns A promise that resolves to an object containing the rendered chat messages and the total token count.
       * The total token count is guaranteed to be less than or equal to the token budget.
       */
      async renderElementJSON(token) {
        await this._processPromptPieces(new PromptSizingContext(this._endpoint.modelMaxPromptTokens, this._endpoint), [
          {
            node: this._root,
            ctor: this._ctor,
            props: this._props,
            children: [],
            path: [this._ctor]
          }
        ], void 0, token);
        return {
          node: this._root.toJSON()
        };
      }
      /**
       * Renders the prompt element and its children.
       * @returns A promise that resolves to an object containing the rendered chat messages and the total token count.
       * The total token count is guaranteed to be less than or equal to the token budget.
       */
      async render(progress, token) {
        const result = await this.renderRaw(progress, token);
        return { ...result, messages: (0, mode_1.toMode)(this._tokenizer.mode, result.messages) };
      }
      /**
       * Renders the prompt element and its children. Similar to {@link render}, but
       * returns the original message representation.
       */
      async renderRaw(progress, token) {
        await this._processPromptPieces(new PromptSizingContext(this._endpoint.modelMaxPromptTokens, this._endpoint), [
          {
            node: this._root,
            ctor: this._ctor,
            props: this._props,
            children: [],
            path: [this._ctor]
          }
        ], progress, token);
        const { container, allMetadata, removed } = await this._getFinalElementTree(this._endpoint.modelMaxPromptTokens, token);
        this.tracer?.didMaterializeTree?.({
          budget: this._endpoint.modelMaxPromptTokens,
          renderedTree: { container, removed, budget: this._endpoint.modelMaxPromptTokens },
          tokenizer: this._tokenizer,
          renderTree: (budget) => this._getFinalElementTree(budget, void 0).then((r) => ({ ...r, budget }))
        });
        const messageResult = [...container.toChatMessages()];
        const tokenCount = await container.tokenCount(this._tokenizer);
        const remainingMetadata = [...container.allMetadata()];
        const referenceNames = /* @__PURE__ */ new Set();
        const references = remainingMetadata.map((m) => {
          if (!(m instanceof ReferenceMetadata)) {
            return;
          }
          const ref = m.reference;
          const isVariableName = "variableName" in ref.anchor;
          if (isVariableName && !referenceNames.has(ref.anchor.variableName)) {
            referenceNames.add(ref.anchor.variableName);
            return ref;
          } else if (!isVariableName) {
            return ref;
          }
        }).filter(isDefined2);
        const omittedReferences = allMetadata.map((m) => {
          if (!(m instanceof ReferenceMetadata) || remainingMetadata.includes(m)) {
            return;
          }
          const ref = m.reference;
          const isVariableName = "variableName" in ref.anchor;
          if (isVariableName && !referenceNames.has(ref.anchor.variableName)) {
            referenceNames.add(ref.anchor.variableName);
            return ref;
          } else if (!isVariableName) {
            return ref;
          }
        }).filter(isDefined2);
        return {
          metadata: MetadataMap.from(remainingMetadata),
          messages: messageResult,
          hasIgnoredFiles: this._ignoredFiles.length > 0,
          tokenCount,
          references,
          omittedReferences
        };
      }
      /**
       * Note: this may be called multiple times from the tracer as users play
       * around with budgets. It should be side-effect-free.
       */
      async _getFinalElementTree(tokenBudget, token) {
        const root = this._root.materialize();
        const originalMessages = [...root.toChatMessages()];
        const allMetadata = [...root.allMetadata()];
        const limits = [{ limit: tokenBudget, id: this._root.id }, ...this._tokenLimits];
        let removed = 0;
        for (let i = limits.length - 1; i >= 0; i--) {
          const limit = limits[i];
          if (limit.limit > tokenBudget) {
            continue;
          }
          const container = root.findById(limit.id);
          if (!container) {
            continue;
          }
          const initialTokenCount = await container.tokenCount(this._tokenizer);
          if (initialTokenCount < limit.limit) {
            const didChange = await this._grow(container, initialTokenCount, limit.limit, token);
            if (!didChange) {
              continue;
            }
          }
          try {
            let tokenCount = await container.tokenCount(this._tokenizer);
            while (tokenCount > limit.limit) {
              const overhead = await container.baseMessageTokenCount(this._tokenizer);
              do {
                for (const node of container.removeLowestPriorityChild()) {
                  removed++;
                  const rmCount = node.upperBoundTokenCount(this._tokenizer);
                  tokenCount -= (typeof rmCount === "number" ? rmCount : await rmCount) * 1.25;
                }
              } while (tokenCount - overhead > limit.limit);
              tokenCount = await container.tokenCount(this._tokenizer);
            }
          } catch (e) {
            if (e instanceof materialized_1.BudgetExceededError) {
              e.metadata = MetadataMap.from([...root.allMetadata()]);
              e.messages = originalMessages;
            }
            throw e;
          }
        }
        return { container: root, allMetadata, removed };
      }
      /** Grows all Expandable elements, returns if any changes were made. */
      async _grow(tree, tokensUsed, tokenBudget, token) {
        if (!this._growables.length) {
          return false;
        }
        for (const growable of this._growables) {
          if (!tree.findById(growable.elem.id)) {
            continue;
          }
          const obj = growable.elem.getObj();
          if (!(obj instanceof promptElements_1.Expandable)) {
            throw new Error("unreachable: expected growable");
          }
          const tempRoot = new PromptTreeElement(null, 0, growable.elem.id);
          const sizing = new PromptSizingContext(tokenBudget - tokensUsed + growable.initialConsume, this._endpoint);
          const newConsumed = await this._processPromptRenderPiece(sizing, { node: tempRoot, ctor: this._ctor, props: {}, children: [], path: [this._ctor] }, obj, await obj.render(void 0, {
            tokenBudget: sizing.tokenBudget,
            endpoint: this._endpoint,
            countTokens: (text2, cancellation) => this._tokenizer.tokenLength(typeof text2 === "string" ? { type: mode_1.Raw.ChatCompletionContentPartKind.Text, text: text2 } : text2, cancellation)
          }), void 0, token);
          const newContainer = tempRoot.materialize();
          const oldContainer = tree.replaceNode(growable.elem.id, newContainer);
          if (!oldContainer) {
            throw new Error("unreachable: could not find old element to replace");
          }
          tokensUsed -= growable.initialConsume;
          tokensUsed += newConsumed;
          if (tokensUsed >= tokenBudget) {
            break;
          }
        }
        return true;
      }
      _handlePromptChildren(element, pieces, sizing, progress, token) {
        if (element.ctor === promptElements_1.TextChunk) {
          this._handleExtrinsicTextChunkChildren(element.node, element.node, element.props, pieces);
          return;
        }
        let todo = [];
        for (const piece of pieces) {
          if (piece.kind === "literal") {
            element.node.appendStringChild(piece.value, element.props.priority ?? Number.MAX_SAFE_INTEGER);
            continue;
          }
          if (piece.kind === "intrinsic") {
            this._handleIntrinsic(element.node, piece.name, {
              priority: element.props.priority ?? Number.MAX_SAFE_INTEGER,
              ...piece.props
            }, flattenAndReduceArr(piece.children));
            continue;
          }
          const childNode = element.node.createChild();
          todo.push({
            node: childNode,
            ctor: piece.ctor,
            props: piece.props,
            children: piece.children,
            path: [...element.path, piece.ctor]
          });
        }
        return this._processPromptPieces(sizing, todo, progress, token);
      }
      _handleIntrinsic(node, name, props, children, sortIndex) {
        switch (name) {
          case "meta":
            return this._handleIntrinsicMeta(node, props, children);
          case "br":
            return this._handleIntrinsicLineBreak(node, props, children, props.priority, sortIndex);
          case "usedContext":
            return this._handleIntrinsicUsedContext(node, props, children);
          case "references":
            return this._handleIntrinsicReferences(node, props, children);
          case "ignoredFiles":
            return this._handleIntrinsicIgnoredFiles(node, props, children);
          case "elementJSON":
            return this._handleIntrinsicElementJSON(node, props.data);
          case "cacheBreakpoint":
            return this._handleIntrinsicCacheBreakpoint(node, props, children, sortIndex);
          case "opaque":
            return this._handleIntrinsicOpaque(node, props, sortIndex);
        }
        throw new Error(`Unknown intrinsic element ${name}!`);
      }
      _handleIntrinsicCacheBreakpoint(node, props, children, sortIndex) {
        if (children.length > 0) {
          throw new Error(`<cacheBreakpoint /> must not have children!`);
        }
        node.addCacheBreakpoint(props, sortIndex);
      }
      _handleIntrinsicMeta(node, props, children) {
        if (children.length > 0) {
          throw new Error(`<meta /> must not have children!`);
        }
        if (props.local) {
          node.addMetadata(props.value);
        } else {
          this._root.addMetadata(props.value);
        }
      }
      _handleIntrinsicLineBreak(node, props, children, inheritedPriority, sortIndex) {
        if (children.length > 0) {
          throw new Error(`<br /> must not have children!`);
        }
        node.appendLineBreak(inheritedPriority ?? Number.MAX_SAFE_INTEGER, sortIndex);
      }
      _handleIntrinsicOpaque(node, props, sortIndex) {
        node.appendOpaque(props.value, props.tokenUsage, props.priority, sortIndex);
      }
      _handleIntrinsicElementJSON(node, data) {
        const appended = node.appendPieceJSON(data.node);
        if (this.tracer?.includeInEpoch) {
          for (const child of appended.elements()) {
            this.tracer.includeInEpoch({ id: child.id, tokenBudget: 0 });
          }
        }
      }
      _handleIntrinsicUsedContext(node, props, children) {
        if (children.length > 0) {
          throw new Error(`<usedContext /> must not have children!`);
        }
        this._usedContext.push(...props.value);
      }
      _handleIntrinsicReferences(node, props, children) {
        if (children.length > 0) {
          throw new Error(`<reference /> must not have children!`);
        }
        for (const ref of props.value) {
          node.addMetadata(new ReferenceMetadata(ref));
        }
      }
      _handleIntrinsicIgnoredFiles(node, props, children) {
        if (children.length > 0) {
          throw new Error(`<ignoredFiles /> must not have children!`);
        }
        this._ignoredFiles.push(...props.value);
      }
      /**
       * @param node Parent of the <TextChunk />
       * @param textChunkNode The <TextChunk /> node. All children are in-order
       * appended to the parent using the same sort index to ensure order is preserved.
       * @param props Props of the <TextChunk />
       * @param children Rendered children of the <TextChunk />
       */
      _handleExtrinsicTextChunkChildren(node, textChunkNode, props, children) {
        const content = [];
        const metadata = [];
        for (const child of children) {
          if (child.kind === "extrinsic") {
            throw new Error("TextChunk cannot have extrinsic children!");
          }
          if (child.kind === "literal") {
            content.push(child.value);
          }
          if (child.kind === "intrinsic") {
            if (child.name === "br") {
              content.push("\n");
            } else if (child.name === "references") {
              for (const reference2 of child.props.value) {
                metadata.push(new ReferenceMetadata(reference2));
              }
            } else {
              this._handleIntrinsic(node, child.name, child.props, flattenAndReduceArr(child.children), textChunkNode.childIndex);
            }
          }
        }
        node.appendStringChild(content.join(""), props?.priority ?? Number.MAX_SAFE_INTEGER, metadata, textChunkNode.childIndex, true);
      }
    };
    exports.PromptRenderer = PromptRenderer2;
    async function computeTokensConsumedByLiterals(tokenizer, element, instance, pieces) {
      let tokensConsumed = 0;
      if ((0, promptElements_1.isChatMessagePromptElement)(instance)) {
        const raw = {
          role: element.props.role,
          content: [],
          ...element.props.name ? { name: element.props.name } : void 0,
          ...element.props.toolCalls ? { toolCalls: element.props.toolCalls } : void 0,
          ...element.props.toolCallId ? { toolCallId: element.props.toolCallId } : void 0
        };
        tokensConsumed += await tokenizer.countMessageTokens((0, mode_1.toMode)(tokenizer.mode, raw));
      }
      for (const piece of pieces) {
        if (piece.kind === "literal") {
          tokensConsumed += await tokenizer.tokenLength({
            type: mode_1.Raw.ChatCompletionContentPartKind.Text,
            text: piece.value
          });
        }
      }
      return { tokensConsumed };
    }
    function flattenAndReduce(c, into = []) {
      if (typeof c === "undefined" || typeof c === "boolean") {
        return [];
      } else if (typeof c === "string" || typeof c === "number") {
        into.push(new LiteralPromptPiece(String(c)));
      } else if (isFragmentCtor(c)) {
        flattenAndReduceArr(c.children, into);
      } else if (isIterable2(c)) {
        flattenAndReduceArr(c, into);
      } else if (typeof c.ctor === "string") {
        into.push(new IntrinsicPromptPiece(c.ctor, c.props, c.children));
      } else {
        into.push(new ExtrinsicPromptPiece(c.ctor, c.props, c.children));
      }
      return into;
    }
    function flattenAndReduceArr(arr, into = []) {
      for (const entry of arr) {
        flattenAndReduce(entry, into);
      }
      return into;
    }
    var IntrinsicPromptPiece = class {
      name;
      props;
      children;
      kind = "intrinsic";
      constructor(name, props, children) {
        this.name = name;
        this.props = props;
        this.children = children;
      }
    };
    var ExtrinsicPromptPiece = class {
      ctor;
      props;
      children;
      kind = "extrinsic";
      constructor(ctor, props, children) {
        this.ctor = ctor;
        this.props = props;
        this.children = children;
      }
    };
    var LiteralPromptPiece = class {
      value;
      priority;
      kind = "literal";
      constructor(value, priority) {
        this.value = value;
        this.priority = priority;
      }
    };
    var PromptOpaque = class _PromptOpaque {
      parent;
      childIndex;
      value;
      tokenUsage;
      priority;
      static fromJSON(parent, index, json) {
        return new _PromptOpaque(parent, index, json.value, json.tokenUsage, json.priority);
      }
      kind = 2;
      constructor(parent, childIndex, value, tokenUsage, priority) {
        this.parent = parent;
        this.childIndex = childIndex;
        this.value = value;
        this.tokenUsage = tokenUsage;
        this.priority = priority;
      }
      materialize(parent) {
        return new materialized_1.MaterializedChatMessageOpaque(parent, {
          type: mode_1.Raw.ChatCompletionContentPartKind.Opaque,
          value: this.value,
          tokenUsage: this.tokenUsage
        }, this.priority);
      }
      toJSON() {
        return {
          type: 3,
          value: this.value,
          tokenUsage: this.tokenUsage,
          priority: this.priority
        };
      }
    };
    var PromptSizingContext = class {
      tokenBudget;
      endpoint;
      _consumed = 0;
      constructor(tokenBudget, endpoint) {
        this.tokenBudget = tokenBudget;
        this.endpoint = endpoint;
      }
      get consumed() {
        return this._consumed > this.tokenBudget ? this.tokenBudget : this._consumed;
      }
      get remainingTokenBudget() {
        return Math.max(0, this.tokenBudget - this._consumed);
      }
      /** Marks part of the budget as having been consumed by a render() call. */
      consume(budget) {
        this._consumed += budget;
      }
    };
    var PromptTreeElement = class _PromptTreeElement {
      parent;
      childIndex;
      id;
      static _nextId = 0;
      static fromJSON(index, json, keepWithMap) {
        const element = new _PromptTreeElement(null, index);
        element._metadata = json.references?.map((r) => new ReferenceMetadata(results_1.PromptReference.fromJSON(r))) ?? [];
        element._children = json.children.map((childJson, i) => {
          switch (childJson.type) {
            case 1:
              return _PromptTreeElement.fromJSON(i, childJson, keepWithMap);
            case 2:
              return PromptText.fromJSON(element, i, childJson);
            case 3:
              return PromptOpaque.fromJSON(element, i, childJson);
            default:
              softAssertNever(childJson);
          }
        }).filter(isDefined2);
        switch (json.ctor) {
          case 1:
            element._objFlags = json.flags ?? 0;
            element._obj = new promptElements_1.BaseChatMessage(json.props);
            break;
          case 2: {
            if (json.keepWithId !== void 0) {
              let kw = keepWithMap.get(json.keepWithId);
              if (!kw) {
                kw = (0, promptElements_1.useKeepWith)();
                keepWithMap.set(json.keepWithId, kw);
              }
              element._obj = new kw(json.props || {});
            } else {
              element._obj = new promptElements_1.LogicalWrapper(json.props || {});
            }
            element._objFlags = json.flags ?? 0;
            break;
          }
          case 3:
            element._obj = new promptElements_1.Image(json.props);
            break;
          default:
            softAssertNever(json);
        }
        return element;
      }
      kind = 1;
      _obj = null;
      _state = void 0;
      _children = [];
      _metadata = [];
      _objFlags = 0;
      constructor(parent = null, childIndex, id2 = _PromptTreeElement._nextId++) {
        this.parent = parent;
        this.childIndex = childIndex;
        this.id = id2;
      }
      setObj(obj) {
        this._obj = obj;
        if (this._obj instanceof promptElements_1.LegacyPrioritization)
          this._objFlags |= 1;
        if (this._obj instanceof promptElements_1.Chunk)
          this._objFlags |= 2;
        if (this._obj instanceof promptElements_1.IfEmpty)
          this._objFlags |= 8;
        if (this._obj.props.passPriority)
          this._objFlags |= 4;
      }
      /** @deprecated remove when Expandable is gone */
      getObj() {
        return this._obj;
      }
      setState(state) {
        this._state = state;
      }
      getState() {
        return this._state;
      }
      createChild() {
        const child = new _PromptTreeElement(this, this._children.length);
        this._children.push(child);
        return child;
      }
      appendPieceJSON(data) {
        const child = _PromptTreeElement.fromJSON(this._children.length, data, /* @__PURE__ */ new Map());
        this._children.push(child);
        return child;
      }
      appendStringChild(text2, priority, metadata, sortIndex = this._children.length, lineBreakBefore = false) {
        this._children.push(new PromptText(this, sortIndex, text2, priority, metadata, lineBreakBefore));
      }
      appendLineBreak(priority, sortIndex = this._children.length) {
        this._children.push(new PromptText(this, sortIndex, "\n", priority));
      }
      appendOpaque(value, tokenUsage, priority, sortIndex = this._children.length) {
        this._children.push(new PromptOpaque(this, sortIndex, value, tokenUsage, priority));
      }
      toJSON() {
        const json = {
          type: 1,
          ctor: 2,
          ctorName: this._obj?.constructor.name,
          children: this._children.slice().sort((a, b) => a.childIndex - b.childIndex).map((c) => c.toJSON()).filter(isDefined2),
          props: {},
          references: this._metadata.filter((m) => m instanceof ReferenceMetadata).map((r) => r.reference.toJSON())
        };
        if (this._obj) {
          json.props = pickProps(this._obj.props, JSONT.jsonRetainedProps);
        }
        if (this._obj instanceof promptElements_1.BaseChatMessage) {
          json.ctor = 1;
          Object.assign(json.props, pickProps(this._obj.props, ["role", "name", "toolCalls", "toolCallId"]));
        } else if (this._obj instanceof promptElements_1.Image) {
          return {
            ...json,
            ctor: 3,
            props: {
              ...json.props,
              ...pickProps(this._obj.props, ["src", "detail"])
            }
          };
        } else if (this._obj instanceof promptElements_1.AbstractKeepWith) {
          json.keepWithId = this._obj.id;
        }
        if (this._objFlags !== 0) {
          json.flags = this._objFlags;
        }
        return json;
      }
      materialize(parent) {
        this._children.sort((a, b) => a.childIndex - b.childIndex);
        if (this._obj instanceof promptElements_1.Image) {
          return new materialized_1.MaterializedChatMessageImage(parent, this.id, this._obj.props.src, this._obj.props.priority ?? Number.MAX_SAFE_INTEGER, this._metadata, 0, this._obj.props.detail ?? void 0);
        }
        if (this._obj instanceof promptElements_1.BaseChatMessage) {
          if (this._obj.props.role === void 0 || typeof this._obj.props.role !== "number") {
            throw new Error(`Invalid ChatMessage!`);
          }
          return new materialized_1.MaterializedChatMessage(parent, this.id, this._obj.props.role, this._obj.props.name, this._obj instanceof promptElements_1.AssistantMessage ? this._obj.props.toolCalls : void 0, this._obj instanceof promptElements_1.ToolMessage ? this._obj.props.toolCallId : void 0, this._obj.props.priority ?? Number.MAX_SAFE_INTEGER, this._metadata, (parent2) => this._children.map((child) => child.materialize(parent2)));
        } else {
          const container = new materialized_1.GenericMaterializedContainer(parent, this.id, this._obj?.constructor.name, this._obj?.props.priority ?? (this._obj?.props.passPriority ? 0 : Number.MAX_SAFE_INTEGER), (parent2) => this._children.map((child) => child.materialize(parent2)), this._metadata, this._objFlags);
          if (this._obj instanceof promptElements_1.AbstractKeepWith) {
            container.keepWithId = this._obj.id;
          }
          return container;
        }
      }
      addMetadata(metadata) {
        this._metadata.push(metadata);
      }
      addCacheBreakpoint(breakpoint, sortIndex = this._children.length) {
        if (!(this._obj instanceof promptElements_1.BaseChatMessage)) {
          throw new Error("Cache breakpoints may only be direct children of chat messages");
        }
        this._children.push(new PromptCacheBreakpoint({ type: mode_1.Raw.ChatCompletionContentPartKind.CacheBreakpoint, cacheType: breakpoint.type }, sortIndex));
      }
      *elements() {
        yield this;
        for (const child of this._children) {
          if (child instanceof _PromptTreeElement) {
            yield* child.elements();
          }
        }
      }
    };
    var PromptCacheBreakpoint = class {
      part;
      childIndex;
      constructor(part, childIndex) {
        this.part = part;
        this.childIndex = childIndex;
      }
      toJSON() {
        return void 0;
      }
      materialize(parent) {
        return new materialized_1.MaterializedChatMessageBreakpoint(parent, this.part);
      }
    };
    var PromptText = class _PromptText {
      parent;
      childIndex;
      text;
      priority;
      metadata;
      lineBreakBefore;
      static fromJSON(parent, index, json) {
        return new _PromptText(parent, index, json.text, json.priority, json.references?.map((r) => new ReferenceMetadata(results_1.PromptReference.fromJSON(r))), json.lineBreakBefore);
      }
      kind = 2;
      constructor(parent, childIndex, text2, priority, metadata, lineBreakBefore = false) {
        this.parent = parent;
        this.childIndex = childIndex;
        this.text = text2;
        this.priority = priority;
        this.metadata = metadata;
        this.lineBreakBefore = lineBreakBefore;
      }
      materialize(parent) {
        const lineBreak = this.lineBreakBefore ? 1 : this.childIndex === 0 ? 2 : 0;
        return new materialized_1.MaterializedChatMessageTextChunk(parent, this.text, this.priority ?? Number.MAX_SAFE_INTEGER, this.metadata || [], lineBreak);
      }
      toJSON() {
        return {
          type: 2,
          priority: this.priority,
          text: this.text,
          references: this.metadata?.filter((m) => m instanceof ReferenceMetadata).map((r) => r.reference.toJSON()),
          lineBreakBefore: this.lineBreakBefore
        };
      }
    };
    function isFragmentCtor(template) {
      return (typeof template.ctor === "function" && template.ctor.isFragment) ?? false;
    }
    function softAssertNever(x) {
    }
    function isDefined2(x) {
      return x !== void 0;
    }
    var InternalMetadata = class extends results_1.PromptMetadata {
    };
    var ReferenceMetadata = class extends InternalMetadata {
      reference;
      constructor(reference2) {
        super();
        this.reference = reference2;
      }
    };
    function isIterable2(t2) {
      return !!t2 && typeof t2[Symbol.iterator] === "function";
    }
    function pickProps(obj, keys) {
      const result = {};
      for (const key of keys) {
        if (obj.hasOwnProperty(key)) {
          result[key] = obj[key];
        }
      }
      return result;
    }
    function atPath(path) {
      return path.map((p) => typeof p === "string" ? p : p ? p.name || "<anonymous>" : String(p)).join(" > ");
    }
    var annotatedErrors = /* @__PURE__ */ new WeakSet();
    async function annotateError(q, fn) {
      try {
        return await fn();
      } catch (e) {
        if (e instanceof Error && !annotatedErrors.has(e) && e.constructor.name !== "CancellationError") {
          annotatedErrors.add(e);
          e.message += ` (at tsx element ${atPath(q.path)})`;
        }
        throw e;
      }
    }
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/tokenizer/tokenizer.js
var require_tokenizer = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/tokenizer/tokenizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VSCodeTokenizer = void 0;
    var mode_1 = require_mode();
    var VSCodeTokenizer = class {
      countTokens;
      mode = mode_1.OutputMode.VSCode;
      constructor(countTokens, mode) {
        this.countTokens = countTokens;
        if (mode !== mode_1.OutputMode.VSCode) {
          throw new Error("`mode` must be set to vscode when using vscode.LanguageModelChat as the tokenizer");
        }
      }
      async tokenLength(part, token) {
        if (part.type === mode_1.Raw.ChatCompletionContentPartKind.Text) {
          return this.countTokens(part.text, token);
        }
        return Promise.resolve(0);
      }
      async countMessageTokens(message) {
        return this.countTokens(message);
      }
    };
    exports.VSCodeTokenizer = VSCodeTokenizer;
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/htmlTracerSrc.js
var require_htmlTracerSrc = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/htmlTracerSrc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tracerCss = exports.tracerSrc = void 0;
    exports.tracerSrc = '"use strict";(()=>{var $,m,se,Ue,w,re,le,q,X,G,K,Ae,D={},ce=[],Re=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,J=Array.isArray;function E(t,e){for(var n in e)t[n]=e[n];return t}function ue(t){t&&t.parentNode&&t.parentNode.removeChild(t)}function l(t,e,n){var o,r,_,c={};for(_ in e)_=="key"?o=e[_]:_=="ref"?r=e[_]:c[_]=e[_];if(arguments.length>2&&(c.children=arguments.length>3?$.call(arguments,2):n),typeof t=="function"&&t.defaultProps!=null)for(_ in t.defaultProps)c[_]===void 0&&(c[_]=t.defaultProps[_]);return R(t,c,o,r,null)}function R(t,e,n,o,r){var _={type:t,props:e,key:n,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:r??++se,__i:-1,__u:0};return r==null&&m.vnode!=null&&m.vnode(_),_}function N(t){return t.children}function B(t,e){this.props=t,this.context=e}function I(t,e){if(e==null)return t.__?I(t.__,t.__i+1):null;for(var n;e<t.__k.length;e++)if((n=t.__k[e])!=null&&n.__e!=null)return n.__e;return typeof t.type=="function"?I(t):null}function de(t){var e,n;if((t=t.__)!=null&&t.__c!=null){for(t.__e=t.__c.base=null,e=0;e<t.__k.length;e++)if((n=t.__k[e])!=null&&n.__e!=null){t.__e=t.__c.base=n.__e;break}return de(t)}}function ie(t){(!t.__d&&(t.__d=!0)&&w.push(t)&&!O.__r++||re!==m.debounceRendering)&&((re=m.debounceRendering)||le)(O)}function O(){var t,e,n,o,r,_,c,a;for(w.sort(q);t=w.shift();)t.__d&&(e=w.length,o=void 0,_=(r=(n=t).__v).__e,c=[],a=[],n.__P&&((o=E({},r)).__v=r.__v+1,m.vnode&&m.vnode(o),Q(n.__P,o,r,n.__n,n.__P.namespaceURI,32&r.__u?[_]:null,c,_??I(r),!!(32&r.__u),a),o.__v=r.__v,o.__.__k[o.__i]=o,me(c,o,a),o.__e!=_&&de(o)),w.length>e&&w.sort(q));O.__r=0}function pe(t,e,n,o,r,_,c,a,u,s,p){var i,f,d,b,x,C=o&&o.__k||ce,h=e.length;for(n.__d=u,Be(n,e,C),u=n.__d,i=0;i<h;i++)(d=n.__k[i])!=null&&(f=d.__i===-1?D:C[d.__i]||D,d.__i=i,Q(t,d,f,r,_,c,a,u,s,p),b=d.__e,d.ref&&f.ref!=d.ref&&(f.ref&&Y(f.ref,null,d),p.push(d.ref,d.__c||b,d)),x==null&&b!=null&&(x=b),65536&d.__u||f.__k===d.__k?u=fe(d,u,t):typeof d.type=="function"&&d.__d!==void 0?u=d.__d:b&&(u=b.nextSibling),d.__d=void 0,d.__u&=-196609);n.__d=u,n.__e=x}function Be(t,e,n){var o,r,_,c,a,u=e.length,s=n.length,p=s,i=0;for(t.__k=[],o=0;o<u;o++)(r=e[o])!=null&&typeof r!="boolean"&&typeof r!="function"?(c=o+i,(r=t.__k[o]=typeof r=="string"||typeof r=="number"||typeof r=="bigint"||r.constructor==String?R(null,r,null,null,null):J(r)?R(N,{children:r},null,null,null):r.constructor===void 0&&r.__b>0?R(r.type,r.props,r.key,r.ref?r.ref:null,r.__v):r).__=t,r.__b=t.__b+1,_=null,(a=r.__i=Oe(r,n,c,p))!==-1&&(p--,(_=n[a])&&(_.__u|=131072)),_==null||_.__v===null?(a==-1&&i--,typeof r.type!="function"&&(r.__u|=65536)):a!==c&&(a==c-1?i--:a==c+1?i++:(a>c?i--:i++,r.__u|=65536))):r=t.__k[o]=null;if(p)for(o=0;o<s;o++)(_=n[o])!=null&&(131072&_.__u)==0&&(_.__e==t.__d&&(t.__d=I(_)),he(_,_))}function fe(t,e,n){var o,r;if(typeof t.type=="function"){for(o=t.__k,r=0;o&&r<o.length;r++)o[r]&&(o[r].__=t,e=fe(o[r],e,n));return e}t.__e!=e&&(e&&t.type&&!n.contains(e)&&(e=I(t)),n.insertBefore(t.__e,e||null),e=t.__e);do e=e&&e.nextSibling;while(e!=null&&e.nodeType===8);return e}function Oe(t,e,n,o){var r=t.key,_=t.type,c=n-1,a=n+1,u=e[n];if(u===null||u&&r==u.key&&_===u.type&&(131072&u.__u)==0)return n;if(o>(u!=null&&(131072&u.__u)==0?1:0))for(;c>=0||a<e.length;){if(c>=0){if((u=e[c])&&(131072&u.__u)==0&&r==u.key&&_===u.type)return c;c--}if(a<e.length){if((u=e[a])&&(131072&u.__u)==0&&r==u.key&&_===u.type)return a;a++}}return-1}function _e(t,e,n){e[0]==="-"?t.setProperty(e,n??""):t[e]=n==null?"":typeof n!="number"||Re.test(e)?n:n+"px"}function A(t,e,n,o,r){var _;e:if(e==="style")if(typeof n=="string")t.style.cssText=n;else{if(typeof o=="string"&&(t.style.cssText=o=""),o)for(e in o)n&&e in n||_e(t.style,e,"");if(n)for(e in n)o&&n[e]===o[e]||_e(t.style,e,n[e])}else if(e[0]==="o"&&e[1]==="n")_=e!==(e=e.replace(/(PointerCapture)$|Capture$/i,"$1")),e=e.toLowerCase()in t||e==="onFocusOut"||e==="onFocusIn"?e.toLowerCase().slice(2):e.slice(2),t.l||(t.l={}),t.l[e+_]=n,n?o?n.u=o.u:(n.u=X,t.addEventListener(e,_?K:G,_)):t.removeEventListener(e,_?K:G,_);else{if(r=="http://www.w3.org/2000/svg")e=e.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if(e!="width"&&e!="height"&&e!="href"&&e!="list"&&e!="form"&&e!="tabIndex"&&e!="download"&&e!="rowSpan"&&e!="colSpan"&&e!="role"&&e!="popover"&&e in t)try{t[e]=n??"";break e}catch{}typeof n=="function"||(n==null||n===!1&&e[4]!=="-"?t.removeAttribute(e):t.setAttribute(e,e=="popover"&&n==1?"":n))}}function ae(t){return function(e){if(this.l){var n=this.l[e.type+t];if(e.t==null)e.t=X++;else if(e.t<n.u)return;return n(m.event?m.event(e):e)}}}function Q(t,e,n,o,r,_,c,a,u,s){var p,i,f,d,b,x,C,h,v,H,M,P,F,oe,z,j,k=e.type;if(e.constructor!==void 0)return null;128&n.__u&&(u=!!(32&n.__u),_=[a=e.__e=n.__e]),(p=m.__b)&&p(e);e:if(typeof k=="function")try{if(h=e.props,v="prototype"in k&&k.prototype.render,H=(p=k.contextType)&&o[p.__c],M=p?H?H.props.value:p.__:o,n.__c?C=(i=e.__c=n.__c).__=i.__E:(v?e.__c=i=new k(h,M):(e.__c=i=new B(h,M),i.constructor=k,i.render=We),H&&H.sub(i),i.props=h,i.state||(i.state={}),i.context=M,i.__n=o,f=i.__d=!0,i.__h=[],i._sb=[]),v&&i.__s==null&&(i.__s=i.state),v&&k.getDerivedStateFromProps!=null&&(i.__s==i.state&&(i.__s=E({},i.__s)),E(i.__s,k.getDerivedStateFromProps(h,i.__s))),d=i.props,b=i.state,i.__v=e,f)v&&k.getDerivedStateFromProps==null&&i.componentWillMount!=null&&i.componentWillMount(),v&&i.componentDidMount!=null&&i.__h.push(i.componentDidMount);else{if(v&&k.getDerivedStateFromProps==null&&h!==d&&i.componentWillReceiveProps!=null&&i.componentWillReceiveProps(h,M),!i.__e&&(i.shouldComponentUpdate!=null&&i.shouldComponentUpdate(h,i.__s,M)===!1||e.__v===n.__v)){for(e.__v!==n.__v&&(i.props=h,i.state=i.__s,i.__d=!1),e.__e=n.__e,e.__k=n.__k,e.__k.some(function(U){U&&(U.__=e)}),P=0;P<i._sb.length;P++)i.__h.push(i._sb[P]);i._sb=[],i.__h.length&&c.push(i);break e}i.componentWillUpdate!=null&&i.componentWillUpdate(h,i.__s,M),v&&i.componentDidUpdate!=null&&i.__h.push(function(){i.componentDidUpdate(d,b,x)})}if(i.context=M,i.props=h,i.__P=t,i.__e=!1,F=m.__r,oe=0,v){for(i.state=i.__s,i.__d=!1,F&&F(e),p=i.render(i.props,i.state,i.context),z=0;z<i._sb.length;z++)i.__h.push(i._sb[z]);i._sb=[]}else do i.__d=!1,F&&F(e),p=i.render(i.props,i.state,i.context),i.state=i.__s;while(i.__d&&++oe<25);i.state=i.__s,i.getChildContext!=null&&(o=E(E({},o),i.getChildContext())),v&&!f&&i.getSnapshotBeforeUpdate!=null&&(x=i.getSnapshotBeforeUpdate(d,b)),pe(t,J(j=p!=null&&p.type===N&&p.key==null?p.props.children:p)?j:[j],e,n,o,r,_,c,a,u,s),i.base=e.__e,e.__u&=-161,i.__h.length&&c.push(i),C&&(i.__E=i.__=null)}catch(U){if(e.__v=null,u||_!=null){for(e.__u|=u?160:32;a&&a.nodeType===8&&a.nextSibling;)a=a.nextSibling;_[_.indexOf(a)]=null,e.__e=a}else e.__e=n.__e,e.__k=n.__k;m.__e(U,e,n)}else _==null&&e.__v===n.__v?(e.__k=n.__k,e.__e=n.__e):e.__e=$e(n.__e,e,n,o,r,_,c,u,s);(p=m.diffed)&&p(e)}function me(t,e,n){e.__d=void 0;for(var o=0;o<n.length;o++)Y(n[o],n[++o],n[++o]);m.__c&&m.__c(e,t),t.some(function(r){try{t=r.__h,r.__h=[],t.some(function(_){_.call(r)})}catch(_){m.__e(_,r.__v)}})}function $e(t,e,n,o,r,_,c,a,u){var s,p,i,f,d,b,x,C=n.props,h=e.props,v=e.type;if(v==="svg"?r="http://www.w3.org/2000/svg":v==="math"?r="http://www.w3.org/1998/Math/MathML":r||(r="http://www.w3.org/1999/xhtml"),_!=null){for(s=0;s<_.length;s++)if((d=_[s])&&"setAttribute"in d==!!v&&(v?d.localName===v:d.nodeType===3)){t=d,_[s]=null;break}}if(t==null){if(v===null)return document.createTextNode(h);t=document.createElementNS(r,v,h.is&&h),a&&(m.__m&&m.__m(e,_),a=!1),_=null}if(v===null)C===h||a&&t.data===h||(t.data=h);else{if(_=_&&$.call(t.childNodes),C=n.props||D,!a&&_!=null)for(C={},s=0;s<t.attributes.length;s++)C[(d=t.attributes[s]).name]=d.value;for(s in C)if(d=C[s],s!="children"){if(s=="dangerouslySetInnerHTML")i=d;else if(!(s in h)){if(s=="value"&&"defaultValue"in h||s=="checked"&&"defaultChecked"in h)continue;A(t,s,null,d,r)}}for(s in h)d=h[s],s=="children"?f=d:s=="dangerouslySetInnerHTML"?p=d:s=="value"?b=d:s=="checked"?x=d:a&&typeof d!="function"||C[s]===d||A(t,s,d,C[s],r);if(p)a||i&&(p.__html===i.__html||p.__html===t.innerHTML)||(t.innerHTML=p.__html),e.__k=[];else if(i&&(t.innerHTML=""),pe(t,J(f)?f:[f],e,n,o,v==="foreignObject"?"http://www.w3.org/1999/xhtml":r,_,c,_?_[0]:n.__k&&I(n,0),a,u),_!=null)for(s=_.length;s--;)ue(_[s]);a||(s="value",v==="progress"&&b==null?t.removeAttribute("value"):b!==void 0&&(b!==t[s]||v==="progress"&&!b||v==="option"&&b!==C[s])&&A(t,s,b,C[s],r),s="checked",x!==void 0&&x!==t[s]&&A(t,s,x,C[s],r))}return t}function Y(t,e,n){try{if(typeof t=="function"){var o=typeof t.__u=="function";o&&t.__u(),o&&e==null||(t.__u=t(e))}else t.current=e}catch(r){m.__e(r,n)}}function he(t,e,n){var o,r;if(m.unmount&&m.unmount(t),(o=t.ref)&&(o.current&&o.current!==t.__e||Y(o,null,e)),(o=t.__c)!=null){if(o.componentWillUnmount)try{o.componentWillUnmount()}catch(_){m.__e(_,e)}o.base=o.__P=null}if(o=t.__k)for(r=0;r<o.length;r++)o[r]&&he(o[r],e,n||typeof t.type!="function");n||ue(t.__e),t.__c=t.__=t.__e=t.__d=void 0}function We(t,e,n){return this.constructor(t,n)}function ve(t,e,n){var o,r,_,c;m.__&&m.__(t,e),r=(o=typeof n=="function")?null:n&&n.__k||e.__k,_=[],c=[],Q(e,t=(!o&&n||e).__k=l(N,null,[t]),r||D,D,e.namespaceURI,!o&&n?[n]:r?null:e.firstChild?$.call(e.childNodes):null,_,!o&&n?n:r?r.__e:e.firstChild,o,c),me(_,t,c)}$=ce.slice,m={__e:function(t,e,n,o){for(var r,_,c;e=e.__;)if((r=e.__c)&&!r.__)try{if((_=r.constructor)&&_.getDerivedStateFromError!=null&&(r.setState(_.getDerivedStateFromError(t)),c=r.__d),r.componentDidCatch!=null&&(r.componentDidCatch(t,o||{}),c=r.__d),c)return r.__E=r}catch(a){t=a}throw t}},se=0,Ue=function(t){return t!=null&&t.constructor==null},B.prototype.setState=function(t,e){var n;n=this.__s!=null&&this.__s!==this.state?this.__s:this.__s=E({},this.state),typeof t=="function"&&(t=t(E({},n),this.props)),t&&E(n,t),t!=null&&this.__v&&(e&&this._sb.push(e),ie(this))},B.prototype.forceUpdate=function(t){this.__v&&(this.__e=!0,t&&this.__h.push(t),ie(this))},B.prototype.render=N,w=[],le=typeof Promise=="function"?Promise.prototype.then.bind(Promise.resolve()):setTimeout,q=function(t,e){return t.__v.__b-e.__v.__b},O.__r=0,X=0,G=ae(!1),K=ae(!0),Ae=0;var L,g,Z,ge,V=0,Ee=[],y=m,be=y.__b,ye=y.__r,Ce=y.diffed,xe=y.__c,ke=y.unmount,Te=y.__;function te(t,e){y.__h&&y.__h(g,t,V||e),V=0;var n=g.__H||(g.__H={__:[],__h:[]});return t>=n.__.length&&n.__.push({}),n.__[t]}function S(t){return V=1,Ve(Ne,t)}function Ve(t,e,n){var o=te(L++,2);if(o.t=t,!o.__c&&(o.__=[n?n(e):Ne(void 0,e),function(a){var u=o.__N?o.__N[0]:o.__[0],s=o.t(u,a);u!==s&&(o.__N=[s,o.__[1]],o.__c.setState({}))}],o.__c=g,!g.u)){var r=function(a,u,s){if(!o.__c.__H)return!0;var p=o.__c.__H.__.filter(function(f){return!!f.__c});if(p.every(function(f){return!f.__N}))return!_||_.call(this,a,u,s);var i=!1;return p.forEach(function(f){if(f.__N){var d=f.__[0];f.__=f.__N,f.__N=void 0,d!==f.__[0]&&(i=!0)}}),!(!i&&o.__c.props===a)&&(!_||_.call(this,a,u,s))};g.u=!0;var _=g.shouldComponentUpdate,c=g.componentWillUpdate;g.componentWillUpdate=function(a,u,s){if(this.__e){var p=_;_=void 0,r(a,u,s),_=p}c&&c.call(this,a,u,s)},g.shouldComponentUpdate=r}return o.__N||o.__}function Se(t,e){var n=te(L++,3);!y.__s&&Ie(n.__H,e)&&(n.__=t,n.i=e,g.__H.__h.push(n))}function we(t){return V=5,je(function(){return{current:t}},[])}function je(t,e){var n=te(L++,7);return Ie(n.__H,e)&&(n.__=t(),n.__H=e,n.__h=t),n.__}function qe(){for(var t;t=Ee.shift();)if(t.__P&&t.__H)try{t.__H.__h.forEach(W),t.__H.__h.forEach(ee),t.__H.__h=[]}catch(e){t.__H.__h=[],y.__e(e,t.__v)}}y.__b=function(t){g=null,be&&be(t)},y.__=function(t,e){t&&e.__k&&e.__k.__m&&(t.__m=e.__k.__m),Te&&Te(t,e)},y.__r=function(t){ye&&ye(t),L=0;var e=(g=t.__c).__H;e&&(Z===g?(e.__h=[],g.__h=[],e.__.forEach(function(n){n.__N&&(n.__=n.__N),n.i=n.__N=void 0})):(e.__h.forEach(W),e.__h.forEach(ee),e.__h=[],L=0)),Z=g},y.diffed=function(t){Ce&&Ce(t);var e=t.__c;e&&e.__H&&(e.__H.__h.length&&(Ee.push(e)!==1&&ge===y.requestAnimationFrame||((ge=y.requestAnimationFrame)||Ge)(qe)),e.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.i=void 0})),Z=g=null},y.__c=function(t,e){e.some(function(n){try{n.__h.forEach(W),n.__h=n.__h.filter(function(o){return!o.__||ee(o)})}catch(o){e.some(function(r){r.__h&&(r.__h=[])}),e=[],y.__e(o,n.__v)}}),xe&&xe(t,e)},y.unmount=function(t){ke&&ke(t);var e,n=t.__c;n&&n.__H&&(n.__H.__.forEach(function(o){try{W(o)}catch(r){e=r}}),n.__H=void 0,e&&y.__e(e,n.__v))};var Me=typeof requestAnimationFrame=="function";function Ge(t){var e,n=function(){clearTimeout(o),Me&&cancelAnimationFrame(e),setTimeout(t)},o=setTimeout(n,100);Me&&(e=requestAnimationFrame(n))}function W(t){var e=g,n=t.__c;typeof n=="function"&&(t.__c=void 0,n()),g=e}function ee(t){var e=g;t.__c=t.__(),g=e}function Ie(t,e){return!t||t.length!==e.length||e.some(function(n,o){return n!==t[o]})}function Ne(t,e){return typeof e=="function"?e(t):e}function He(t,e){let n=we(void 0),o=(...r)=>{n.current&&clearTimeout(n.current),n.current=window.setTimeout(()=>{t(...r)},e)};return Se(()=>()=>{n.current&&clearTimeout(n.current)},[]),o}var Ke=new Intl.NumberFormat("en-US"),T=({value:t})=>l(N,null,Ke.format(t));var ne=[{bg:"#c1e7ff",fg:"#000"},{bg:"#abd2ec",fg:"#000"},{bg:"#94bed9",fg:"#000"},{bg:"#7faac6",fg:"#000"},{bg:"#6996b3",fg:"#fff"},{bg:"#5383a1",fg:"#fff"},{bg:"#3d708f",fg:"#fff"},{bg:"#255e7e",fg:"#fff"}],Xe=({scoreBy:t,nodes:e,epoch:n})=>{if(e.length===0)return null;let o=t;if(t.field!=="tokens"){let r=e[0][t.field],_=e[0][t.field];for(let c=1;c<e.length;c++)r=Math.max(r,e[c][t.field]),_=Math.max(_,e[c][t.field]);o={field:t.field,max:r,min:_}}return l("div",{className:"node-children"},e.map((r,_)=>r.type===2?l(Je,{scoreBy:o,key:_,node:r}):l(Le,{scoreBy:o,key:_,node:r,epoch:n})))},Fe=({node:t})=>l("div",{className:"node-stats"},"Used Tokens: ",l(T,{value:t.tokens})," / ","Priority:"," ",t.priority===Number.MAX_SAFE_INTEGER?"MAX":l(T,{value:t.priority})),De=({scoreBy:t,node:e,children:n,...o})=>{let r=0;if(t.max!==t.min){let _=(e[t.field]-t.min)/(t.max-t.min);r=Math.round((ne.length-1)*_)}return l("div",{...o,className:`node ${o.className||""}`,style:{backgroundColor:ne[r].bg,color:ne[r].fg}},n)},Je=({scoreBy:t,node:e})=>l(De,{node:e,scoreBy:t,tabIndex:0,className:"node-text"},l(Fe,{node:e}),l("div",{className:"node-content"},e.value)),Le=({scoreBy:t,node:e,epoch:n})=>{let[o,r]=S(!1),_=EPOCHS.findIndex(i=>i.elements.some(f=>f.id===e.id));if(_===void 0)throw new Error(`epoch not found for ${e.id}`);let c=EPOCHS[_],a=EPOCHS.at(n),u=c.elements.find(i=>i.id===e.id).tokenBudget,s=e.type===1?e.name||e.role.slice(0,1).toUpperCase()+e.role.slice(1)+"Message":e.name,p=_===n?"new-in-epoch":n<_?"before-epoch":"";return l(De,{node:e,scoreBy:t,className:p},l(Fe,{node:e}),l("div",{className:"node-content node-toggler",onClick:()=>r(i=>!i)},l("span",null,a?.inNode===e.id?"\\u{1F3C3} ":"",`<${s}>`),l("span",{className:"indicator"},o?"[+]":"[-]")),n===_&&l("div",{className:"node-stats"},"Token Budget: ",l(T,{value:u})),a?.inNode===e.id&&l("div",{className:"node-stats"},"Rendering flexGrow=",a.flexValue,l("br",null),l("br",null),"Splitting"," ",a.reservedTokens?`${a.tokenBudget} - ${a.reservedTokens} (reserved) = `:"",l(T,{value:a.tokenBudget})," tokens among ",a.elements.length," ","elements"),!o&&l(Xe,{nodes:e.children,scoreBy:t,epoch:n}))},Pe=({scoreBy:t,node:e,epoch:n})=>{let o;return t==="tokens"?o={field:"tokens",max:e.tokens,min:0}:o={field:"priority",max:e.priority,min:e.priority},l(Le,{scoreBy:o,node:e,epoch:n})};var ze=({label:t,value:e,onChange:n,min:o,max:r})=>{let _=a=>{n(a.target.valueAsNumber)},c=`number-slider-${Math.random()}`;return l("div",{className:"controls-slider"},l("label",{htmlFor:c},t),l("input",{id:c,type:"range",min:o,max:r,value:e,onInput:_}),l("input",{type:"number",min:o,value:e,onInput:_,onChange:_}))},Qe=({scoreBy:t,onScoreByChange:e})=>{let n=o=>{let r=o.target.value;e(r)};return l("div",{className:"controls-scoreby"},"Visualize by",l("label",null,l("input",{type:"radio",name:"scoreBy",value:"tokens",checked:t==="tokens",onChange:n}),"Tokens"),l("label",null,l("input",{type:"radio",name:"scoreBy",value:"priority",checked:t==="priority",onChange:n}),"Priority"))},Ye=()=>{let[t,e]=S(DEFAULT_TOKENS),[n,o]=S(EPOCHS.length),[r,_]=S(DEFAULT_MODEL),[c,a]=S("tokens"),[u,s]=S("epoch"),p=He(async f=>{if(f===DEFAULT_TOKENS)return DEFAULT_MODEL;let b=await(await fetch(`${SERVER_ADDRESS}regen?n=${f}`)).json();_(b)},100),i=f=>{e(f),p(f),o(EPOCHS.length)};return l("div",{className:"app"},l("div",{className:"controls"},l("div",{className:"tabs"},l("div",{className:`tab ${u==="epoch"?"active":""}`,onClick:()=>s("epoch")},"View Order"),l("div",{className:`tab ${u==="tokens"?"active":""}`,onClick:()=>s("tokens")},"Change Token Budget")),l("div",{className:`tab-content ${u==="epoch"?"active":""}`},l(ze,{label:"Render Epoch",value:n,onChange:o,min:0,max:EPOCHS.length})),l("div",{className:`tab-content ${u==="tokens"?"active":""}`},l(ze,{label:"Token Budget",value:t,onChange:i,min:0,max:DEFAULT_TOKENS*2}))),l("div",{className:"control-description"},u==="tokens"?l("p",null,"Token changes here will prune elements and re-render Expandable ones, but the entire prompt is not being re-rendered"):l("p",null,"Changing the render epoch lets you see the order in which elements are rendered and how the token budget is allocated."),l("div",{className:"controls-stats"},l("span",null,"Used ",l(T,{value:r.container.tokens}),"/",l(T,{value:r.budget})," tokens"),l("span",null,"Removed ",l(T,{value:r.removed})," nodes"),l(Qe,{scoreBy:c,onScoreByChange:a}))),l(Pe,{node:r.container,scoreBy:c,epoch:n}))};ve(l(Ye,null),document.body);})();\n';
    exports.tracerCss = "body{font-family:-apple-system,BlinkMacSystemFont,Segoe WPC,Segoe UI,system-ui,Ubuntu,Droid Sans,sans-serif;background:#fff;margin:0}.render-pass{border-left:2px solid #ccc;&:hover{border-left-color:#000}}.literals li{white-space:pre;font-family:SF Mono,Monaco,Menlo,Consolas,Ubuntu Mono,Liberation Mono,DejaVu Sans Mono,Courier New,monospace}.render-flex,.render-element{padding-left:10px}.node{border:1px solid rgba(255,255,255,.5);margin:3px 10px;padding:3px 10px;border-radius:4px;width:fit-content;&.new-in-epoch{box-shadow:0 0 3px 2px red}&.before-epoch{pointer-events:none;filter:grayscale(1);color:#777!important;.node{color:#777!important}}&:last-child{margin-bottom:0}}.node-content{font-weight:700}.node-children{margin-left:20px;border-left:2px dashed rgba(255,255,255,.5);padding-left:10px}.node-toggler{cursor:pointer;display:flex;align-items:center;justify-content:space-between;.indicator{font-size:.7em}}.node-text{width:400px;&:focus,&:focus-within{outline:1px solid orange;.node-content{white-space:normal}}.node-content{font-weight:400;font-size:.8em;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}}.node-stats{font-family:SF Mono,Monaco,Menlo,Consolas,Ubuntu Mono,Liberation Mono,DejaVu Sans Mono,Courier New,monospace;font-size:.8em}.control-description{padding:10px;p{font-size:.9em;max-width:500px;margin-top:0}}.controls{display:flex;flex-direction:column;gap:10px;position:sticky;top:0;padding:10px;background:#fff;border-bottom:1px solid #ccc;z-index:1}.controls-slider{display:flex;align-items:center;gap:10px}.controls-stats{display:flex;gap:20px;list-style:none;padding:0;margin-top:0}.controls-scoreby{display:flex;gap:10px}.tabs{display:flex;border-bottom:1px solid #ccc;margin-bottom:10px}.tab{padding:10px;cursor:pointer;border:1px solid transparent;border-bottom:none}.tab.active{border-color:#ccc;border-bottom:1px solid #fff;background-color:#f9f9f9}.tab-content{display:none}.tab-content.active{display:block}\n";
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/htmlTracer.js
var require_htmlTracer = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/htmlTracer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HTMLTracer = void 0;
    var htmlTracerSrc_1 = require_htmlTracerSrc();
    var materialized_1 = require_materialized();
    var mode_1 = require_mode();
    var HTMLTracer = class {
      traceData;
      epochs = [];
      addRenderEpoch(epoch) {
        this.epochs.push(epoch);
      }
      includeInEpoch(data) {
        this.epochs[this.epochs.length - 1].elements.push(data);
      }
      didMaterializeTree(traceData) {
        this.traceData = traceData;
      }
      /**
       * Returns HTML to trace the output. Note that is starts a server which is
       * used for client interaction to resize the prompt and its `address` should
       * be displayed or opened as a link in a browser.
       *
       * The server runs until it is disposed.
       */
      async serveHTML() {
        return RequestServer.create({
          epochs: this.epochs,
          traceData: mustGet(this.traceData)
        });
      }
      /**
       * Gets an HTML router for a server at the URL. URL is the form `http://127.0.0.1:1234`.
       */
      serveRouter(url) {
        return new RequestRouter({
          baseAddress: url,
          epochs: this.epochs,
          traceData: mustGet(this.traceData)
        });
      }
    };
    exports.HTMLTracer = HTMLTracer;
    var RequestRouter = class {
      opts;
      serverToken = crypto.randomUUID();
      constructor(opts) {
        this.opts = opts;
      }
      route(httpIncomingMessage, httpOutgoingMessage) {
        const req = httpIncomingMessage;
        const res = httpOutgoingMessage;
        const url = new URL(req.url || "/", `http://localhost`);
        const prefix = `/${this.serverToken}`;
        switch (url.pathname) {
          case prefix:
          case `${prefix}/`:
            this.onRoot(url, req, res);
            break;
          case `${prefix}/regen`:
            this.onRegen(url, req, res);
            break;
          default:
            return false;
        }
        return true;
      }
      get address() {
        return this.opts.baseAddress + "/" + this.serverToken;
      }
      async getHTML() {
        const { traceData, epochs } = this.opts;
        return `<body>
			<style>${htmlTracerSrc_1.tracerCss}</style>
			<script>
				const DEFAULT_TOKENS = ${JSON.stringify(traceData.budget)};
				const EPOCHS = ${JSON.stringify(epochs)};
				const DEFAULT_MODEL = ${JSON.stringify(await serializeRenderData(traceData.tokenizer, traceData.renderedTree))};
				const SERVER_ADDRESS = ${JSON.stringify(this.opts.baseAddress + "/" + this.serverToken + "/")};
				${htmlTracerSrc_1.tracerSrc}
			<\/script>
		</body>`;
      }
      async onRegen(url, _req, res) {
        const { traceData } = this.opts;
        const budget = Number(url.searchParams.get("n") || traceData.budget);
        const renderedTree = await traceData.renderTree(budget);
        const serialized = await serializeRenderData(traceData.tokenizer, renderedTree);
        const json = JSON.stringify(serialized);
        res.setHeader("Content-Type", "application/json");
        res.setHeader("Content-Length", Buffer.byteLength(json));
        res.end(json);
      }
      onRoot(_url, _req, res) {
        this.getHTML().then((html) => {
          res.setHeader("Content-Type", "text/html");
          res.setHeader("Content-Length", Buffer.byteLength(html));
          res.end(html);
        });
      }
    };
    var RequestServer = class _RequestServer extends RequestRouter {
      server;
      static async create(opts) {
        const { createServer } = await Promise.resolve().then(() => require("http"));
        const server = createServer((req, res) => {
          try {
            if (!instance.route(req, res)) {
              res.statusCode = 404;
              res.end("Not Found");
            }
          } catch (e) {
            res.statusCode = 500;
            res.end(String(e));
          }
        });
        const port = await new Promise((resolve2, reject) => {
          server.listen(0, "127.0.0.1", () => resolve2(server.address().port)).on("error", reject);
        });
        const instance = new _RequestServer({
          ...opts,
          baseAddress: `http://127.0.0.1:${port}`
        }, server);
        return instance;
      }
      constructor(opts, server) {
        super(opts);
        this.server = server;
      }
      dispose() {
        this.server.closeAllConnections();
        this.server.close();
      }
    };
    async function serializeRenderData(tokenizer, tree) {
      return {
        container: await serializeMaterialized(tokenizer, tree.container, false),
        removed: tree.removed,
        budget: tree.budget
      };
    }
    async function serializeMaterialized(tokenizer, materialized, inChatMessage) {
      const common = {
        metadata: materialized.metadata.map(serializeMetadata),
        priority: materialized.priority
      };
      if (materialized instanceof materialized_1.MaterializedChatMessageTextChunk) {
        return {
          ...common,
          type: 2,
          value: materialized.text,
          tokens: await materialized.upperBoundTokenCount(tokenizer)
        };
      } else if (materialized instanceof materialized_1.MaterializedChatMessageImage) {
        return {
          ...common,
          name: materialized.id.toString(),
          id: materialized.id,
          type: 3,
          value: materialized.src,
          tokens: await materialized.upperBoundTokenCount(tokenizer)
        };
      } else if (materialized instanceof materialized_1.MaterializedChatMessageOpaque || materialized instanceof materialized_1.MaterializedChatMessageBreakpoint) {
        return void 0;
      } else {
        const containerCommon = {
          ...common,
          id: materialized.id,
          name: materialized.name,
          children: (await Promise.all(materialized.children.map((c) => serializeMaterialized(tokenizer, c, inChatMessage || materialized instanceof materialized_1.MaterializedChatMessage)))).filter((r) => !!r),
          tokens: inChatMessage ? await materialized.upperBoundTokenCount(tokenizer) : await materialized.tokenCount(tokenizer)
        };
        if (materialized instanceof materialized_1.GenericMaterializedContainer) {
          return {
            ...containerCommon,
            type: 0
          };
        } else if (materialized instanceof materialized_1.MaterializedChatMessage) {
          const content = materialized.text.filter((element) => typeof element === "string").join("").trim();
          return {
            ...containerCommon,
            type: 1,
            role: mode_1.Raw.ChatRole.display(materialized.role),
            text: content
          };
        }
      }
      assertNever2(materialized);
    }
    function assertNever2(x) {
      throw new Error("unreachable");
    }
    function serializeMetadata(metadata) {
      return { name: metadata.constructor.name, value: JSON.stringify(metadata) };
    }
    var mustGet = (value) => {
      if (value === void 0) {
        throw new Error("Prompt must be rendered before calling HTMLTRacer.serveHTML");
      }
      return value;
    };
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/tracer.js
var require_tracer = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/tracer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/tsx-globals.js
var require_tsx_globals = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/tsx-globals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/types.js
var require_types = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@vscode/prompt-tsx/dist/base/index.js
var require_base = __commonJS({
  "node_modules/@vscode/prompt-tsx/dist/base/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentType = exports.PromptRenderer = exports.MetadataMap = exports.PromptElement = exports.JSONTree = void 0;
    exports.renderPrompt = renderPrompt;
    exports.renderElementJSON = renderElementJSON;
    var mode_1 = require_mode();
    var promptRenderer_1 = require_promptRenderer();
    var tokenizer_1 = require_tokenizer();
    __exportStar(require_htmlTracer(), exports);
    exports.JSONTree = require_jsonTypes();
    __exportStar(require_mode(), exports);
    __exportStar(require_promptElements(), exports);
    __exportStar(require_results(), exports);
    __exportStar(require_tracer(), exports);
    __exportStar(require_tsx_globals(), exports);
    __exportStar(require_types(), exports);
    var promptElement_1 = require_promptElement();
    Object.defineProperty(exports, "PromptElement", { enumerable: true, get: function() {
      return promptElement_1.PromptElement;
    } });
    var promptRenderer_2 = require_promptRenderer();
    Object.defineProperty(exports, "MetadataMap", { enumerable: true, get: function() {
      return promptRenderer_2.MetadataMap;
    } });
    Object.defineProperty(exports, "PromptRenderer", { enumerable: true, get: function() {
      return promptRenderer_2.PromptRenderer;
    } });
    async function renderPrompt(ctor, props, endpoint, tokenizerMetadata, progress, token, mode = mode_1.OutputMode.VSCode) {
      let tokenizer = "countTokens" in tokenizerMetadata ? new tokenizer_1.VSCodeTokenizer((text2, token2) => tokenizerMetadata.countTokens(text2, token2), mode) : tokenizerMetadata;
      const renderer = new promptRenderer_1.PromptRenderer(endpoint, ctor, props, tokenizer);
      const renderResult = await renderer.render(progress, token);
      const usedContext = renderer.getUsedContext();
      return { ...renderResult, usedContext };
    }
    exports.contentType = "application/vnd.codechat.prompt+json.1";
    function renderElementJSON(ctor, props, budgetInformation, token) {
      const renderer = new promptRenderer_1.PromptRenderer(
        { modelMaxPromptTokens: budgetInformation?.tokenBudget ?? Number.MAX_SAFE_INTEGER },
        ctor,
        props,
        // note: if tokenBudget is given, countTokens is also give and vise-versa.
        // `1` is used only as a dummy fallback to avoid errors if no/unlimited budget is provided.
        {
          mode: mode_1.OutputMode.Raw,
          countMessageTokens(message) {
            throw new Error("Tools may only return text, not messages.");
          },
          tokenLength(part, token2) {
            if (part.type === mode_1.Raw.ChatCompletionContentPartKind.Text) {
              return Promise.resolve(budgetInformation?.countTokens(part.text, token2) ?? Promise.resolve(1));
            }
            return Promise.resolve(1);
          }
        }
      );
      return renderer.renderElementJSON(token);
    }
  }
});

// src/extension/extension/vscode-worker/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate
});
module.exports = __toCommonJS(extension_exports);

// node_modules/@vscode/l10n/dist/browser.js
async function readFileFromUri(uri) {
  if (uri.protocol === "http:" || uri.protocol === "https:") {
    const res = await fetch(uri);
    return await res.text();
  }
  throw new Error("Unsupported protocol");
}
function readFileFromFsPath(_) {
  throw new Error("Unsupported in browser");
}
var bundle;
function config(config22) {
  if ("contents" in config22) {
    if (typeof config22.contents === "string") {
      bundle = JSON.parse(config22.contents);
    } else {
      bundle = config22.contents;
    }
    return;
  }
  if ("fsPath" in config22) {
    const fileContent = readFileFromFsPath(config22.fsPath);
    const content = JSON.parse(fileContent);
    bundle = isBuiltinExtension(content) ? content.contents.bundle : content;
    return;
  }
  if (config22.uri) {
    let uri = config22.uri;
    if (typeof config22.uri === "string") {
      uri = new URL(config22.uri);
    }
    return new Promise((resolve2, reject) => {
      readFileFromUri(uri).then((uriContent) => {
        try {
          const content = JSON.parse(uriContent);
          bundle = isBuiltinExtension(content) ? content.contents.bundle : content;
          resolve2();
        } catch (err) {
          reject(err);
        }
      }).catch((err) => {
        reject(err);
      });
    });
  }
}
function t(...args) {
  const firstArg = args[0];
  let key;
  let message;
  let formatArgs;
  if (typeof firstArg === "string") {
    key = firstArg;
    message = firstArg;
    args.splice(0, 1);
    formatArgs = !args || typeof args[0] !== "object" ? args : args[0];
  } else if (firstArg instanceof Array) {
    const replacements = args.slice(1);
    if (firstArg.length !== replacements.length + 1) {
      throw new Error("expected a string as the first argument to l10n.t");
    }
    let str = firstArg[0];
    for (let i = 1; i < firstArg.length; i++) {
      str += `{${i - 1}}` + firstArg[i];
    }
    return t(str, ...replacements);
  } else {
    message = firstArg.message;
    key = message;
    if (firstArg.comment && firstArg.comment.length > 0) {
      key += `/${Array.isArray(firstArg.comment) ? firstArg.comment.join("") : firstArg.comment}`;
    }
    formatArgs = firstArg.args ?? {};
  }
  const messageFromBundle = bundle?.[key];
  if (!messageFromBundle) {
    return format(message, formatArgs);
  }
  if (typeof messageFromBundle === "string") {
    return format(messageFromBundle, formatArgs);
  }
  if (messageFromBundle.comment) {
    return format(messageFromBundle.message, formatArgs);
  }
  return format(message, formatArgs);
}
var _format2Regexp = /{([^}]+)}/g;
function format(template, values) {
  if (Object.keys(values).length === 0) {
    return template;
  }
  return template.replace(_format2Regexp, (match3, group) => values[group] ?? match3);
}
function isBuiltinExtension(json) {
  return !!(typeof json?.contents?.bundle === "object" && typeof json?.version === "string");
}

// src/extension/extension/vscode/extension.ts
var import_vscode2 = require("vscode");

// src/util/vs/platform/instantiation/common/instantiation.ts
var _util;
((_util2) => {
  _util2.serviceIds = /* @__PURE__ */ new Map();
  _util2.DI_TARGET = "$di$target";
  _util2.DI_DEPENDENCIES = "$di$dependencies";
  function getServiceDependencies(ctor) {
    return ctor[_util2.DI_DEPENDENCIES] || [];
  }
  _util2.getServiceDependencies = getServiceDependencies;
})(_util || (_util = {}));
var IInstantiationService = createDecorator("instantiationService");
function storeServiceDependency(id2, target, index) {
  if (target[_util.DI_TARGET] === target) {
    target[_util.DI_DEPENDENCIES].push({ id: id2, index });
  } else {
    target[_util.DI_DEPENDENCIES] = [{ id: id2, index }];
    target[_util.DI_TARGET] = target;
  }
}
function createDecorator(serviceId) {
  if (_util.serviceIds.has(serviceId)) {
    return _util.serviceIds.get(serviceId);
  }
  const id2 = function(target, key, index) {
    if (arguments.length !== 3) {
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    }
    storeServiceDependency(id2, target, index);
  };
  id2.toString = () => serviceId;
  _util.serviceIds.set(serviceId, id2);
  return id2;
}

// src/util/vs/base/common/async.ts
init_cancellation();
init_errors();
init_event();
init_lifecycle();

// src/util/vs/base/common/resources.ts
init_charCode();

// src/util/vs/base/common/extpath.ts
init_charCode();

// src/util/vs/nls.messages.ts
function getNLSLanguage() {
  return globalThis._VSCODE_NLS_LANGUAGE;
}

// src/util/vs/nls.ts
var isPseudo = getNLSLanguage() === "pseudo" || typeof document !== "undefined" && document.location && typeof document.location.hash === "string" && document.location.hash.indexOf("pseudo=true") >= 0;

// src/util/vs/base/common/platform.ts
var LANGUAGE_DEFAULT = "en";
var _isWindows = false;
var _isMacintosh = false;
var _isLinux = false;
var _isLinuxSnap = false;
var _isNative = false;
var _isWeb = false;
var _isElectron = false;
var _isIOS = false;
var _isCI = false;
var _isMobile = false;
var _locale = void 0;
var _language = LANGUAGE_DEFAULT;
var _platformLocale = LANGUAGE_DEFAULT;
var _translationsConfigFile = void 0;
var _userAgent = void 0;
var $globalThis = globalThis;
var nodeProcess = void 0;
if (typeof $globalThis.vscode !== "undefined" && typeof $globalThis.vscode.process !== "undefined") {
  nodeProcess = $globalThis.vscode.process;
} else if (typeof process !== "undefined" && typeof process?.versions?.node === "string") {
  nodeProcess = process;
}
var isElectronProcess = typeof nodeProcess?.versions?.electron === "string";
var isElectronRenderer = isElectronProcess && nodeProcess?.type === "renderer";
if (typeof nodeProcess === "object") {
  _isWindows = nodeProcess.platform === "win32";
  _isMacintosh = nodeProcess.platform === "darwin";
  _isLinux = nodeProcess.platform === "linux";
  _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
  _isElectron = isElectronProcess;
  _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"] || !!nodeProcess.env["GITHUB_WORKSPACE"];
  _locale = LANGUAGE_DEFAULT;
  _language = LANGUAGE_DEFAULT;
  const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
  if (rawNlsConfig) {
    try {
      const nlsConfig = JSON.parse(rawNlsConfig);
      _locale = nlsConfig.userLocale;
      _platformLocale = nlsConfig.osLocale;
      _language = nlsConfig.resolvedLanguage || LANGUAGE_DEFAULT;
      _translationsConfigFile = nlsConfig.languagePack?.translationsConfigFile;
    } catch (e) {
    }
  }
  _isNative = true;
} else if (typeof navigator === "object" && !isElectronRenderer) {
  _userAgent = navigator.userAgent;
  _isWindows = _userAgent.indexOf("Windows") >= 0;
  _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
  _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
  _isLinux = _userAgent.indexOf("Linux") >= 0;
  _isMobile = _userAgent?.indexOf("Mobi") >= 0;
  _isWeb = true;
  _language = getNLSLanguage() || LANGUAGE_DEFAULT;
  _locale = navigator.language.toLowerCase();
  _platformLocale = _locale;
} else {
  console.error("Unable to resolve platform.");
}
var _platform = 0 /* Web */;
if (_isMacintosh) {
  _platform = 1 /* Mac */;
} else if (_isWindows) {
  _platform = 3 /* Windows */;
} else if (_isLinux) {
  _platform = 2 /* Linux */;
}
var isWindows = _isWindows;
var isMacintosh = _isMacintosh;
var isLinux = _isLinux;
var isNative = _isNative;
var isWeb = _isWeb;
var isWebWorker = _isWeb && typeof $globalThis.importScripts === "function";
var webWorkerOrigin = isWebWorker ? $globalThis.origin : void 0;
var platform = _platform;
var userAgent = _userAgent;
var language = _language;
var Language;
((Language2) => {
  function value() {
    return language;
  }
  Language2.value = value;
  function isDefaultVariant() {
    if (language.length === 2) {
      return language === "en";
    } else if (language.length >= 3) {
      return language[0] === "e" && language[1] === "n" && language[2] === "-";
    } else {
      return false;
    }
  }
  Language2.isDefaultVariant = isDefaultVariant;
  function isDefault() {
    return language === "en";
  }
  Language2.isDefault = isDefault;
})(Language || (Language = {}));
var setTimeout0IsFaster = typeof $globalThis.postMessage === "function" && !$globalThis.importScripts;
var setTimeout0 = (() => {
  if (setTimeout0IsFaster) {
    const pending = [];
    $globalThis.addEventListener("message", (e) => {
      if (e.data && e.data.vscodeScheduleAsyncWork) {
        for (let i = 0, len = pending.length; i < len; i++) {
          const candidate = pending[i];
          if (candidate.id === e.data.vscodeScheduleAsyncWork) {
            pending.splice(i, 1);
            candidate.callback();
            return;
          }
        }
      }
    });
    let lastId = 0;
    return (callback) => {
      const myId = ++lastId;
      pending.push({
        id: myId,
        callback
      });
      $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
    };
  }
  return (callback) => setTimeout(callback);
})();
var isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
var isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
var isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
var isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
var isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);

// src/util/vs/base/common/process.ts
var safeProcess;
var vscodeGlobal = globalThis.vscode;
if (typeof vscodeGlobal !== "undefined" && typeof vscodeGlobal.process !== "undefined") {
  const sandboxProcess = vscodeGlobal.process;
  safeProcess = {
    get platform() {
      return sandboxProcess.platform;
    },
    get arch() {
      return sandboxProcess.arch;
    },
    get env() {
      return sandboxProcess.env;
    },
    cwd() {
      return sandboxProcess.cwd();
    }
  };
} else if (typeof process !== "undefined" && typeof process?.versions?.node === "string") {
  safeProcess = {
    get platform() {
      return process.platform;
    },
    get arch() {
      return process.arch;
    },
    get env() {
      return process.env;
    },
    cwd() {
      return process.env["VSCODE_CWD"] || process.cwd();
    }
  };
} else {
  safeProcess = {
    // Supported
    get platform() {
      return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
    },
    get arch() {
      return void 0;
    },
    // Unsupported
    get env() {
      return {};
    },
    cwd() {
      return "/";
    }
  };
}
var cwd = safeProcess.cwd;
var env = safeProcess.env;
var platform2 = safeProcess.platform;
var arch = safeProcess.arch;

// src/util/vs/base/common/path.ts
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;
var CHAR_QUESTION_MARK = 63;
var ErrorInvalidArgType = class extends Error {
  constructor(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && expected.indexOf("not ") === 0) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    const type = name.indexOf(".") !== -1 ? "property" : "argument";
    let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
    msg += `. Received type ${typeof actual}`;
    super(msg);
    this.code = "ERR_INVALID_ARG_TYPE";
  }
};
function validateObject(pathObject, name) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ErrorInvalidArgType(name, "Object", pathObject);
  }
}
function validateString(value, name) {
  if (typeof value !== "string") {
    throw new ErrorInvalidArgType(name, "string", value);
  }
}
var platformIsWin32 = platform2 === "win32";
function isPathSeparator(code2) {
  return code2 === CHAR_FORWARD_SLASH || code2 === CHAR_BACKWARD_SLASH;
}
function isPosixPathSeparator(code2) {
  return code2 === CHAR_FORWARD_SLASH;
}
function isWindowsDeviceRoot(code2) {
  return code2 >= CHAR_UPPERCASE_A && code2 <= CHAR_UPPERCASE_Z || code2 >= CHAR_LOWERCASE_A && code2 <= CHAR_LOWERCASE_Z;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2 = 0;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code2 = path.charCodeAt(i);
    } else if (isPathSeparator3(code2)) {
      break;
    } else {
      code2 = CHAR_FORWARD_SLASH;
    }
    if (isPathSeparator3(code2)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length !== 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? `${separator}..` : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `${separator}${path.slice(lastSlash + 1, i)}`;
        } else {
          res = path.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function formatExt(ext) {
  return ext ? `${ext[0] === "." ? "" : "."}${ext}` : "";
}
function _format(sep2, pathObject) {
  validateObject(pathObject, "pathObject");
  const dir = pathObject.dir || pathObject.root;
  const base2 = pathObject.base || `${pathObject.name || ""}${formatExt(pathObject.ext)}`;
  if (!dir) {
    return base2;
  }
  return dir === pathObject.root ? `${dir}${base2}` : `${dir}${sep2}${base2}`;
}
var win32 = {
  // path.resolve([from ...], to)
  resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for (let i = pathSegments.length - 1; i >= -1; i--) {
      let path;
      if (i >= 0) {
        path = pathSegments[i];
        validateString(path, `paths[${i}]`);
        if (path.length === 0) {
          continue;
        }
      } else if (resolvedDevice.length === 0) {
        path = cwd();
      } else {
        path = env[`=${resolvedDevice}`] || cwd();
        if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
          path = `${resolvedDevice}\\`;
        }
      }
      const len = path.length;
      let rootEnd = 0;
      let device = "";
      let isAbsolute2 = false;
      const code2 = path.charCodeAt(0);
      if (len === 1) {
        if (isPathSeparator(code2)) {
          rootEnd = 1;
          isAbsolute2 = true;
        }
      } else if (isPathSeparator(code2)) {
        isAbsolute2 = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            last = j;
            while (j < len && isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j === len || j !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code2) && path.charCodeAt(1) === CHAR_COLON) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
          isAbsolute2 = true;
          rootEnd = 3;
        }
      }
      if (device.length > 0) {
        if (resolvedDevice.length > 0) {
          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
          }
        } else {
          resolvedDevice = device;
        }
      }
      if (resolvedAbsolute) {
        if (resolvedDevice.length > 0) {
          break;
        }
      } else {
        resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
        resolvedAbsolute = isAbsolute2;
        if (isAbsolute2 && resolvedDevice.length > 0) {
          break;
        }
      }
    }
    resolvedTail = normalizeString(
      resolvedTail,
      !resolvedAbsolute,
      "\\",
      isPathSeparator
    );
    return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
  },
  normalize(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return ".";
    }
    let rootEnd = 0;
    let device;
    let isAbsolute2 = false;
    const code2 = path.charCodeAt(0);
    if (len === 1) {
      return isPosixPathSeparator(code2) ? "\\" : path;
    }
    if (isPathSeparator(code2)) {
      isAbsolute2 = true;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          const firstPart = path.slice(last, j);
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path.slice(last)}\\`;
            }
            if (j !== last) {
              device = `\\\\${firstPart}\\${path.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code2) && path.charCodeAt(1) === CHAR_COLON) {
      device = path.slice(0, 2);
      rootEnd = 2;
      if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
        isAbsolute2 = true;
        rootEnd = 3;
      }
    }
    let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator) : "";
    if (tail.length === 0 && !isAbsolute2) {
      tail = ".";
    }
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
      tail += "\\";
    }
    if (!isAbsolute2 && device === void 0 && path.includes(":")) {
      if (tail.length >= 2 && isWindowsDeviceRoot(tail.charCodeAt(0)) && tail.charCodeAt(1) === CHAR_COLON) {
        return `.\\${tail}`;
      }
      let index = path.indexOf(":");
      do {
        if (index === len - 1 || isPathSeparator(path.charCodeAt(index + 1))) {
          return `.\\${tail}`;
        }
      } while ((index = path.indexOf(":", index + 1)) !== -1);
    }
    if (device === void 0) {
      return isAbsolute2 ? `\\${tail}` : tail;
    }
    return isAbsolute2 ? `${device}\\${tail}` : `${device}${tail}`;
  },
  isAbsolute(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return false;
    }
    const code2 = path.charCodeAt(0);
    return isPathSeparator(code2) || // Possible device root
    len > 2 && isWindowsDeviceRoot(code2) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
  },
  join(...paths) {
    if (paths.length === 0) {
      return ".";
    }
    let joined;
    let firstPart;
    for (let i = 0; i < paths.length; ++i) {
      const arg = paths[i];
      validateString(arg, "path");
      if (arg.length > 0) {
        if (joined === void 0) {
          joined = firstPart = arg;
        } else {
          joined += `\\${arg}`;
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    let needsReplace = true;
    let slashCount = 0;
    if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
      ++slashCount;
      const firstLen = firstPart.length;
      if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2))) {
            ++slashCount;
          } else {
            needsReplace = false;
          }
        }
      }
    }
    if (needsReplace) {
      while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
        slashCount++;
      }
      if (slashCount >= 2) {
        joined = `\\${joined.slice(slashCount)}`;
      }
    }
    return win32.normalize(joined);
  },
  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    const fromOrig = win32.resolve(from);
    const toOrig = win32.resolve(to);
    if (fromOrig === toOrig) {
      return "";
    }
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) {
      return "";
    }
    if (fromOrig.length !== from.length || toOrig.length !== to.length) {
      const fromSplit = fromOrig.split("\\");
      const toSplit = toOrig.split("\\");
      if (fromSplit[fromSplit.length - 1] === "") {
        fromSplit.pop();
      }
      if (toSplit[toSplit.length - 1] === "") {
        toSplit.pop();
      }
      const fromLen2 = fromSplit.length;
      const toLen2 = toSplit.length;
      const length2 = fromLen2 < toLen2 ? fromLen2 : toLen2;
      let i2;
      for (i2 = 0; i2 < length2; i2++) {
        if (fromSplit[i2].toLowerCase() !== toSplit[i2].toLowerCase()) {
          break;
        }
      }
      if (i2 === 0) {
        return toOrig;
      } else if (i2 === length2) {
        if (toLen2 > length2) {
          return toSplit.slice(i2).join("\\");
        }
        if (fromLen2 > length2) {
          return "..\\".repeat(fromLen2 - 1 - i2) + "..";
        }
        return "";
      }
      return "..\\".repeat(fromLen2 - i2) + toSplit.slice(i2).join("\\");
    }
    let fromStart = 0;
    while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
      fromStart++;
    }
    let fromEnd = from.length;
    while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
      fromEnd--;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      toStart++;
    }
    let toEnd = to.length;
    while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
      toEnd--;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_BACKWARD_SLASH) {
        lastCommonSep = i;
      }
    }
    if (i !== length) {
      if (lastCommonSep === -1) {
        return toOrig;
      }
    } else {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i + 1);
        }
        if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      if (lastCommonSep === -1) {
        lastCommonSep = 0;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
        out += out.length === 0 ? ".." : "\\..";
      }
    }
    toStart += lastCommonSep;
    if (out.length > 0) {
      return `${out}${toOrig.slice(toStart, toEnd)}`;
    }
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      ++toStart;
    }
    return toOrig.slice(toStart, toEnd);
  },
  toNamespacedPath(path) {
    if (typeof path !== "string" || path.length === 0) {
      return path;
    }
    const resolvedPath = win32.resolve(path);
    if (resolvedPath.length <= 2) {
      return path;
    }
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== CHAR_QUESTION_MARK && code2 !== CHAR_DOT) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
      return `\\\\?\\${resolvedPath}`;
    }
    return resolvedPath;
  },
  dirname(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return ".";
    }
    let rootEnd = -1;
    let offset = 0;
    const code2 = path.charCodeAt(0);
    if (len === 1) {
      return isPathSeparator(code2) ? path : ".";
    }
    if (isPathSeparator(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              return path;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2) && path.charCodeAt(1) === CHAR_COLON) {
      rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
      offset = rootEnd;
    }
    let end = -1;
    let matchedSlash = true;
    for (let i = len - 1; i >= offset; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) {
      if (rootEnd === -1) {
        return ".";
      }
      end = rootEnd;
    }
    return path.slice(0, end);
  },
  basename(path, suffix) {
    if (suffix !== void 0) {
      validateString(suffix, "suffix");
    }
    validateString(path, "path");
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
      start = 2;
    }
    if (suffix !== void 0 && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path) {
        return "";
      }
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= start; --i) {
        const code2 = path.charCodeAt(i);
        if (isPathSeparator(code2)) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code2 === suffix.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path.length;
      }
      return path.slice(start, end);
    }
    for (i = path.length - 1; i >= start; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1) {
      return "";
    }
    return path.slice(start, end);
  },
  extname(path) {
    validateString(path, "path");
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
      start = startPart = 2;
    }
    for (let i = path.length - 1; i >= start; --i) {
      const code2 = path.charCodeAt(i);
      if (isPathSeparator(code2)) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code2 === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  },
  format: _format.bind(null, "\\"),
  parse(path) {
    validateString(path, "path");
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path.length === 0) {
      return ret;
    }
    const len = path.length;
    let rootEnd = 0;
    let code2 = path.charCodeAt(0);
    if (len === 1) {
      if (isPathSeparator(code2)) {
        ret.root = ret.dir = path;
        return ret;
      }
      ret.base = ret.name = path;
      return ret;
    }
    if (isPathSeparator(code2)) {
      rootEnd = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2) && path.charCodeAt(1) === CHAR_COLON) {
      if (len <= 2) {
        ret.root = ret.dir = path;
        return ret;
      }
      rootEnd = 2;
      if (isPathSeparator(path.charCodeAt(2))) {
        if (len === 3) {
          ret.root = ret.dir = path;
          return ret;
        }
        rootEnd = 3;
      }
    }
    if (rootEnd > 0) {
      ret.root = path.slice(0, rootEnd);
    }
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (; i >= rootEnd; --i) {
      code2 = path.charCodeAt(i);
      if (isPathSeparator(code2)) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code2 === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (end !== -1) {
      if (startDot === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path.slice(startPart, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
      }
    }
    if (startPart > 0 && startPart !== rootEnd) {
      ret.dir = path.slice(0, startPart - 1);
    } else {
      ret.dir = ret.root;
    }
    return ret;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
};
var posixCwd = (() => {
  if (platformIsWin32) {
    const regexp = /\\/g;
    return () => {
      const cwd2 = cwd().replace(regexp, "/");
      return cwd2.slice(cwd2.indexOf("/"));
    };
  }
  return () => cwd();
})();
var posix = {
  // path.resolve([from ...], to)
  resolve(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for (let i = pathSegments.length - 1; i >= 0 && !resolvedAbsolute; i--) {
      const path = pathSegments[i];
      validateString(path, `paths[${i}]`);
      if (path.length === 0) {
        continue;
      }
      resolvedPath = `${path}/${resolvedPath}`;
      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    if (!resolvedAbsolute) {
      const cwd2 = posixCwd();
      resolvedPath = `${cwd2}/${resolvedPath}`;
      resolvedAbsolute = cwd2.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(
      resolvedPath,
      !resolvedAbsolute,
      "/",
      isPosixPathSeparator
    );
    if (resolvedAbsolute) {
      return `/${resolvedPath}`;
    }
    return resolvedPath.length > 0 ? resolvedPath : ".";
  },
  normalize(path) {
    validateString(path, "path");
    if (path.length === 0) {
      return ".";
    }
    const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
    path = normalizeString(path, !isAbsolute2, "/", isPosixPathSeparator);
    if (path.length === 0) {
      if (isAbsolute2) {
        return "/";
      }
      return trailingSeparator ? "./" : ".";
    }
    if (trailingSeparator) {
      path += "/";
    }
    return isAbsolute2 ? `/${path}` : path;
  },
  isAbsolute(path) {
    validateString(path, "path");
    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
  },
  join(...paths) {
    if (paths.length === 0) {
      return ".";
    }
    const path = [];
    for (let i = 0; i < paths.length; ++i) {
      const arg = paths[i];
      validateString(arg, "path");
      if (arg.length > 0) {
        path.push(arg);
      }
    }
    if (path.length === 0) {
      return ".";
    }
    return posix.normalize(path.join("/"));
  },
  relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to) {
      return "";
    }
    const fromStart = 1;
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    const toStart = 1;
    const toLen = to.length - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_FORWARD_SLASH) {
        lastCommonSep = i;
      }
    }
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
          return to.slice(toStart + i + 1);
        }
        if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        out += out.length === 0 ? ".." : "/..";
      }
    }
    return `${out}${to.slice(toStart + lastCommonSep)}`;
  },
  toNamespacedPath(path) {
    return path;
  },
  dirname(path) {
    validateString(path, "path");
    if (path.length === 0) {
      return ".";
    }
    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let end = -1;
    let matchedSlash = true;
    for (let i = path.length - 1; i >= 1; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) {
      return hasRoot ? "/" : ".";
    }
    if (hasRoot && end === 1) {
      return "//";
    }
    return path.slice(0, end);
  },
  basename(path, suffix) {
    if (suffix !== void 0) {
      validateString(suffix, "suffix");
    }
    validateString(path, "path");
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (suffix !== void 0 && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path) {
        return "";
      }
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        const code2 = path.charCodeAt(i);
        if (code2 === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code2 === suffix.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path.length;
      }
      return path.slice(start, end);
    }
    for (i = path.length - 1; i >= 0; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1) {
      return "";
    }
    return path.slice(start, end);
  },
  extname(path) {
    validateString(path, "path");
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path.length - 1; i >= 0; --i) {
      const char = path[i];
      if (char === "/") {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (char === ".") {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  },
  format: _format.bind(null, "/"),
  parse(path) {
    validateString(path, "path");
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path.length === 0) {
      return ret;
    }
    const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let start;
    if (isAbsolute2) {
      ret.root = "/";
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      const code2 = path.charCodeAt(i);
      if (code2 === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code2 === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (end !== -1) {
      const start2 = startPart === 0 && isAbsolute2 ? 1 : startPart;
      if (startDot === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path.slice(start2, end);
      } else {
        ret.name = path.slice(start2, startDot);
        ret.base = path.slice(start2, end);
        ret.ext = path.slice(startDot, end);
      }
    }
    if (startPart > 0) {
      ret.dir = path.slice(0, startPart - 1);
    } else if (isAbsolute2) {
      ret.dir = "/";
    }
    return ret;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
posix.win32 = win32.win32 = win32;
posix.posix = win32.posix = posix;
var normalize = platformIsWin32 ? win32.normalize : posix.normalize;
var isAbsolute = platformIsWin32 ? win32.isAbsolute : posix.isAbsolute;
var join = platformIsWin32 ? win32.join : posix.join;
var resolve = platformIsWin32 ? win32.resolve : posix.resolve;
var relative = platformIsWin32 ? win32.relative : posix.relative;
var dirname = platformIsWin32 ? win32.dirname : posix.dirname;
var basename = platformIsWin32 ? win32.basename : posix.basename;
var extname = platformIsWin32 ? win32.extname : posix.extname;
var format2 = platformIsWin32 ? win32.format : posix.format;
var parse = platformIsWin32 ? win32.parse : posix.parse;
var toNamespacedPath = platformIsWin32 ? win32.toNamespacedPath : posix.toNamespacedPath;
var sep = platformIsWin32 ? win32.sep : posix.sep;
var delimiter = platformIsWin32 ? win32.delimiter : posix.delimiter;

// src/util/vs/base/common/extpath.ts
init_strings();
init_types();
function isPathSeparator2(code2) {
  return code2 === 47 /* Slash */ || code2 === 92 /* Backslash */;
}
function toSlashes(osPath) {
  return osPath.replace(/[\\/]/g, posix.sep);
}
function toPosixPath(osPath) {
  if (osPath.indexOf("/") === -1) {
    osPath = toSlashes(osPath);
  }
  if (/^[a-zA-Z]:(\/|$)/.test(osPath)) {
    osPath = "/" + osPath;
  }
  return osPath;
}
function getRoot(path, sep2 = posix.sep) {
  if (!path) {
    return "";
  }
  const len = path.length;
  const firstLetter = path.charCodeAt(0);
  if (isPathSeparator2(firstLetter)) {
    if (isPathSeparator2(path.charCodeAt(1))) {
      if (!isPathSeparator2(path.charCodeAt(2))) {
        let pos2 = 3;
        const start = pos2;
        for (; pos2 < len; pos2++) {
          if (isPathSeparator2(path.charCodeAt(pos2))) {
            break;
          }
        }
        if (start !== pos2 && !isPathSeparator2(path.charCodeAt(pos2 + 1))) {
          pos2 += 1;
          for (; pos2 < len; pos2++) {
            if (isPathSeparator2(path.charCodeAt(pos2))) {
              return path.slice(0, pos2 + 1).replace(/[\\/]/g, sep2);
            }
          }
        }
      }
    }
    return sep2;
  } else if (isWindowsDriveLetter(firstLetter)) {
    if (path.charCodeAt(1) === 58 /* Colon */) {
      if (isPathSeparator2(path.charCodeAt(2))) {
        return path.slice(0, 2) + sep2;
      } else {
        return path.slice(0, 2);
      }
    }
  }
  let pos = path.indexOf("://");
  if (pos !== -1) {
    pos += 3;
    for (; pos < len; pos++) {
      if (isPathSeparator2(path.charCodeAt(pos))) {
        return path.slice(0, pos + 1);
      }
    }
  }
  return "";
}
function isEqualOrParent(base2, parentCandidate, ignoreCase, separator = sep) {
  if (base2 === parentCandidate) {
    return true;
  }
  if (!base2 || !parentCandidate) {
    return false;
  }
  if (parentCandidate.length > base2.length) {
    return false;
  }
  if (ignoreCase) {
    const beginsWith = startsWithIgnoreCase(base2, parentCandidate);
    if (!beginsWith) {
      return false;
    }
    if (parentCandidate.length === base2.length) {
      return true;
    }
    let sepOffset = parentCandidate.length;
    if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {
      sepOffset--;
    }
    return base2.charAt(sepOffset) === separator;
  }
  if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {
    parentCandidate += separator;
  }
  return base2.indexOf(parentCandidate) === 0;
}
function isWindowsDriveLetter(char0) {
  return char0 >= 65 /* A */ && char0 <= 90 /* Z */ || char0 >= 97 /* a */ && char0 <= 122 /* z */;
}
function hasDriveLetter(path, isWindowsOS = isWindows) {
  if (isWindowsOS) {
    return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58 /* Colon */;
  }
  return false;
}

// src/util/vs/base/common/network.ts
init_errors();
init_strings();

// src/util/vs/base/common/uri.ts
init_charCode();
var _schemePattern = /^\w[\w\d+.-]*$/;
var _singleSlashStart = /^\//;
var _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
  if (!ret.scheme && _strict) {
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
  }
  if (ret.scheme && !_schemePattern.test(ret.scheme)) {
    throw new Error("[UriError]: Scheme contains illegal characters.");
  }
  if (ret.path) {
    if (ret.authority) {
      if (!_singleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
}
function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return "file";
  }
  return scheme;
}
function _referenceResolution(scheme, path) {
  switch (scheme) {
    case "https":
    case "http":
    case "file":
      if (!path) {
        path = _slash;
      } else if (path[0] !== _slash) {
        path = _slash + path;
      }
      break;
  }
  return path;
}
var _empty = "";
var _slash = "/";
var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
var URI = class _URI {
  static isUri(thing) {
    if (thing instanceof _URI) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
  }
  /**
   * @internal
   */
  constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
    if (typeof schemeOrData === "object") {
      this.scheme = schemeOrData.scheme || _empty;
      this.authority = schemeOrData.authority || _empty;
      this.path = schemeOrData.path || _empty;
      this.query = schemeOrData.query || _empty;
      this.fragment = schemeOrData.fragment || _empty;
    } else {
      this.scheme = _schemeFix(schemeOrData, _strict);
      this.authority = authority || _empty;
      this.path = _referenceResolution(this.scheme, path || _empty);
      this.query = query || _empty;
      this.fragment = fragment || _empty;
      _validateUri(this, _strict);
    }
  }
  // ---- filesystem path -----------------------
  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
  	const u = URI.parse('file://server/c$/folder/file.txt')
  	u.authority === 'server'
  	u.path === '/shares/c$/file.txt'
  	u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */
  get fsPath() {
    return uriToFsPath(this, false);
  }
  // ---- modify to new -------------------------
  with(change) {
    if (!change) {
      return this;
    }
    let { scheme, authority, path, query, fragment } = change;
    if (scheme === void 0) {
      scheme = this.scheme;
    } else if (scheme === null) {
      scheme = _empty;
    }
    if (authority === void 0) {
      authority = this.authority;
    } else if (authority === null) {
      authority = _empty;
    }
    if (path === void 0) {
      path = this.path;
    } else if (path === null) {
      path = _empty;
    }
    if (query === void 0) {
      query = this.query;
    } else if (query === null) {
      query = _empty;
    }
    if (fragment === void 0) {
      fragment = this.fragment;
    } else if (fragment === null) {
      fragment = _empty;
    }
    if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
      return this;
    }
    return new Uri(scheme, authority, path, query, fragment);
  }
  // ---- parse & validate ------------------------
  /**
   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */
  static parse(value, _strict = false) {
    const match3 = _regexp.exec(value);
    if (!match3) {
      return new Uri(_empty, _empty, _empty, _empty, _empty);
    }
    return new Uri(
      match3[2] || _empty,
      percentDecode(match3[4] || _empty),
      percentDecode(match3[5] || _empty),
      percentDecode(match3[7] || _empty),
      percentDecode(match3[9] || _empty),
      _strict
    );
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */
  static file(path) {
    let authority = _empty;
    if (isWindows) {
      path = path.replace(/\\/g, _slash);
    }
    if (path[0] === _slash && path[1] === _slash) {
      const idx = path.indexOf(_slash, 2);
      if (idx === -1) {
        authority = path.substring(2);
        path = _slash;
      } else {
        authority = path.substring(2, idx);
        path = path.substring(idx) || _slash;
      }
    }
    return new Uri("file", authority, path, _empty, _empty);
  }
  /**
   * Creates new URI from uri components.
   *
   * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
   * validation and should be used for untrusted uri components retrieved from storage,
   * user input, command arguments etc
   */
  static from(components, strict) {
    const result = new Uri(
      components.scheme,
      components.authority,
      components.path,
      components.query,
      components.fragment,
      strict
    );
    return result;
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */
  static joinPath(uri, ...pathFragment) {
    if (!uri.path) {
      throw new Error(`[UriError]: cannot call joinPath on URI without path`);
    }
    let newPath;
    if (isWindows && uri.scheme === "file") {
      newPath = _URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
    } else {
      newPath = posix.join(uri.path, ...pathFragment);
    }
    return uri.with({ path: newPath });
  }
  // ---- printing/externalize ---------------------------
  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */
  toString(skipEncoding = false) {
    return _asFormatted(this, skipEncoding);
  }
  toJSON() {
    return this;
  }
  static revive(data) {
    if (!data) {
      return data;
    } else if (data instanceof _URI) {
      return data;
    } else {
      const result = new Uri(data);
      result._formatted = data.external ?? null;
      result._fsPath = data._sep === _pathSepMarker ? data.fsPath ?? null : null;
      return result;
    }
  }
  [Symbol.for("debug.description")]() {
    return `URI(${this.toString()})`;
  }
};
var _pathSepMarker = isWindows ? 1 : void 0;
var Uri = class extends URI {
  constructor() {
    super(...arguments);
    this._formatted = null;
    this._fsPath = null;
  }
  get fsPath() {
    if (!this._fsPath) {
      this._fsPath = uriToFsPath(this, false);
    }
    return this._fsPath;
  }
  toString(skipEncoding = false) {
    if (!skipEncoding) {
      if (!this._formatted) {
        this._formatted = _asFormatted(this, false);
      }
      return this._formatted;
    } else {
      return _asFormatted(this, true);
    }
  }
  toJSON() {
    const res = {
      $mid: 1 /* Uri */
    };
    if (this._fsPath) {
      res.fsPath = this._fsPath;
      res._sep = _pathSepMarker;
    }
    if (this._formatted) {
      res.external = this._formatted;
    }
    if (this.path) {
      res.path = this.path;
    }
    if (this.scheme) {
      res.scheme = this.scheme;
    }
    if (this.authority) {
      res.authority = this.authority;
    }
    if (this.query) {
      res.query = this.query;
    }
    if (this.fragment) {
      res.fragment = this.fragment;
    }
    return res;
  }
};
var encodeTable = {
  [58 /* Colon */]: "%3A",
  // gen-delims
  [47 /* Slash */]: "%2F",
  [63 /* QuestionMark */]: "%3F",
  [35 /* Hash */]: "%23",
  [91 /* OpenSquareBracket */]: "%5B",
  [93 /* CloseSquareBracket */]: "%5D",
  [64 /* AtSign */]: "%40",
  [33 /* ExclamationMark */]: "%21",
  // sub-delims
  [36 /* DollarSign */]: "%24",
  [38 /* Ampersand */]: "%26",
  [39 /* SingleQuote */]: "%27",
  [40 /* OpenParen */]: "%28",
  [41 /* CloseParen */]: "%29",
  [42 /* Asterisk */]: "%2A",
  [43 /* Plus */]: "%2B",
  [44 /* Comma */]: "%2C",
  [59 /* Semicolon */]: "%3B",
  [61 /* Equals */]: "%3D",
  [32 /* Space */]: "%20"
};
function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
  let res = void 0;
  let nativeEncodePos = -1;
  for (let pos = 0; pos < uriComponent.length; pos++) {
    const code2 = uriComponent.charCodeAt(pos);
    if (code2 >= 97 /* a */ && code2 <= 122 /* z */ || code2 >= 65 /* A */ && code2 <= 90 /* Z */ || code2 >= 48 /* Digit0 */ && code2 <= 57 /* Digit9 */ || code2 === 45 /* Dash */ || code2 === 46 /* Period */ || code2 === 95 /* Underline */ || code2 === 126 /* Tilde */ || isPath && code2 === 47 /* Slash */ || isAuthority && code2 === 91 /* OpenSquareBracket */ || isAuthority && code2 === 93 /* CloseSquareBracket */ || isAuthority && code2 === 58 /* Colon */) {
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      }
      if (res !== void 0) {
        res += uriComponent.charAt(pos);
      }
    } else {
      if (res === void 0) {
        res = uriComponent.substr(0, pos);
      }
      const escaped = encodeTable[code2];
      if (escaped !== void 0) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        res += escaped;
      } else if (nativeEncodePos === -1) {
        nativeEncodePos = pos;
      }
    }
  }
  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }
  return res !== void 0 ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
  let res = void 0;
  for (let pos = 0; pos < path.length; pos++) {
    const code2 = path.charCodeAt(pos);
    if (code2 === 35 /* Hash */ || code2 === 63 /* QuestionMark */) {
      if (res === void 0) {
        res = path.substr(0, pos);
      }
      res += encodeTable[code2];
    } else {
      if (res !== void 0) {
        res += path[pos];
      }
    }
  }
  return res !== void 0 ? res : path;
}
function uriToFsPath(uri, keepDriveLetterCasing) {
  let value;
  if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
    value = `//${uri.authority}${uri.path}`;
  } else if (uri.path.charCodeAt(0) === 47 /* Slash */ && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */) && uri.path.charCodeAt(2) === 58 /* Colon */) {
    if (!keepDriveLetterCasing) {
      value = uri.path[1].toLowerCase() + uri.path.substr(2);
    } else {
      value = uri.path.substr(1);
    }
  } else {
    value = uri.path;
  }
  if (isWindows) {
    value = value.replace(/\//g, "\\");
  }
  return value;
}
function _asFormatted(uri, skipEncoding) {
  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  let res = "";
  let { scheme, authority, path, query, fragment } = uri;
  if (scheme) {
    res += scheme;
    res += ":";
  }
  if (authority || scheme === "file") {
    res += _slash;
    res += _slash;
  }
  if (authority) {
    let idx = authority.indexOf("@");
    if (idx !== -1) {
      const userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.lastIndexOf(":");
      if (idx === -1) {
        res += encoder(userinfo, false, false);
      } else {
        res += encoder(userinfo.substr(0, idx), false, false);
        res += ":";
        res += encoder(userinfo.substr(idx + 1), false, true);
      }
      res += "@";
    }
    authority = authority.toLowerCase();
    idx = authority.lastIndexOf(":");
    if (idx === -1) {
      res += encoder(authority, false, true);
    } else {
      res += encoder(authority.substr(0, idx), false, true);
      res += authority.substr(idx);
    }
  }
  if (path) {
    if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {
      const code2 = path.charCodeAt(1);
      if (code2 >= 65 /* A */ && code2 <= 90 /* Z */) {
        path = `/${String.fromCharCode(code2 + 32)}:${path.substr(3)}`;
      }
    } else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {
      const code2 = path.charCodeAt(0);
      if (code2 >= 65 /* A */ && code2 <= 90 /* Z */) {
        path = `${String.fromCharCode(code2 + 32)}:${path.substr(2)}`;
      }
    }
    res += encoder(path, true, false);
  }
  if (query) {
    res += "?";
    res += encoder(query, false, false);
  }
  if (fragment) {
    res += "#";
    res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
  }
  return res;
}
function decodeURIComponentGraceful(str) {
  try {
    return decodeURIComponent(str);
  } catch {
    if (str.length > 3) {
      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
    } else {
      return str;
    }
  }
}
var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
  if (!str.match(_rEncodedAsHex)) {
    return str;
  }
  return str.replace(_rEncodedAsHex, (match3) => decodeURIComponentGraceful(match3));
}

// src/util/vs/base/common/network.ts
var Schemas;
((Schemas2) => {
  Schemas2.inMemory = "inmemory";
  Schemas2.vscode = "vscode";
  Schemas2.internal = "private";
  Schemas2.walkThrough = "walkThrough";
  Schemas2.walkThroughSnippet = "walkThroughSnippet";
  Schemas2.http = "http";
  Schemas2.https = "https";
  Schemas2.file = "file";
  Schemas2.mailto = "mailto";
  Schemas2.untitled = "untitled";
  Schemas2.data = "data";
  Schemas2.command = "command";
  Schemas2.vscodeRemote = "vscode-remote";
  Schemas2.vscodeRemoteResource = "vscode-remote-resource";
  Schemas2.vscodeManagedRemoteResource = "vscode-managed-remote-resource";
  Schemas2.vscodeUserData = "vscode-userdata";
  Schemas2.vscodeCustomEditor = "vscode-custom-editor";
  Schemas2.vscodeNotebookCell = "vscode-notebook-cell";
  Schemas2.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata";
  Schemas2.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff";
  Schemas2.vscodeNotebookCellOutput = "vscode-notebook-cell-output";
  Schemas2.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff";
  Schemas2.vscodeNotebookMetadata = "vscode-notebook-metadata";
  Schemas2.vscodeInteractiveInput = "vscode-interactive-input";
  Schemas2.vscodeSettings = "vscode-settings";
  Schemas2.vscodeWorkspaceTrust = "vscode-workspace-trust";
  Schemas2.vscodeTerminal = "vscode-terminal";
  Schemas2.vscodeChatCodeBlock = "vscode-chat-code-block";
  Schemas2.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block";
  Schemas2.vscodeChatEditor = "vscode-chat-editor";
  Schemas2.vscodeChatInput = "chatSessionInput";
  Schemas2.vscodeChatSession = "vscode-chat-session";
  Schemas2.webviewPanel = "webview-panel";
  Schemas2.vscodeWebview = "vscode-webview";
  Schemas2.extension = "extension";
  Schemas2.vscodeFileResource = "vscode-file";
  Schemas2.tmp = "tmp";
  Schemas2.vsls = "vsls";
  Schemas2.vscodeSourceControl = "vscode-scm";
  Schemas2.commentsInput = "comment";
  Schemas2.codeSetting = "code-setting";
  Schemas2.outputChannel = "output";
  Schemas2.accessibleView = "accessible-view";
  Schemas2.chatEditingSnapshotScheme = "chat-editing-snapshot-text-model";
  Schemas2.chatEditingModel = "chat-editing-text-model";
})(Schemas || (Schemas = {}));
var connectionTokenQueryName = "tkn";
var RemoteAuthoritiesImpl = class {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null);
    this._ports = /* @__PURE__ */ Object.create(null);
    this._connectionTokens = /* @__PURE__ */ Object.create(null);
    this._preferredWebSchema = "http";
    this._delegate = null;
    this._serverRootPath = "/";
  }
  setPreferredWebSchema(schema) {
    this._preferredWebSchema = schema;
  }
  setDelegate(delegate) {
    this._delegate = delegate;
  }
  setServerRootPath(product, serverBasePath) {
    this._serverRootPath = posix.join(serverBasePath ?? "/", getServerProductSegment(product));
  }
  getServerRootPath() {
    return this._serverRootPath;
  }
  get _remoteResourcesPath() {
    return posix.join(this._serverRootPath, Schemas.vscodeRemoteResource);
  }
  set(authority, host, port) {
    this._hosts[authority] = host;
    this._ports[authority] = port;
  }
  setConnectionToken(authority, connectionToken) {
    this._connectionTokens[authority] = connectionToken;
  }
  getPreferredWebSchema() {
    return this._preferredWebSchema;
  }
  rewrite(uri) {
    if (this._delegate) {
      try {
        return this._delegate(uri);
      } catch (err) {
        onUnexpectedError(err);
        return uri;
      }
    }
    const authority = uri.authority;
    let host = this._hosts[authority];
    if (host && host.indexOf(":") !== -1 && host.indexOf("[") === -1) {
      host = `[${host}]`;
    }
    const port = this._ports[authority];
    const connectionToken = this._connectionTokens[authority];
    let query = `path=${encodeURIComponent(uri.path)}`;
    if (typeof connectionToken === "string") {
      query += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;
    }
    return URI.from({
      scheme: isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,
      authority: `${host}:${port}`,
      path: this._remoteResourcesPath,
      query
    });
  }
};
var RemoteAuthorities = new RemoteAuthoritiesImpl();
function getServerProductSegment(product) {
  return `${product.quality ?? "oss"}-${product.commit ?? "dev"}`;
}
var VSCODE_AUTHORITY = "vscode-app";
var FileAccessImpl = class _FileAccessImpl {
  static {
    this.FALLBACK_AUTHORITY = VSCODE_AUTHORITY;
  }
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  asBrowserUri(resourcePath) {
    const uri = this.toUri(resourcePath);
    return this.uriToBrowserUri(uri);
  }
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  uriToBrowserUri(uri) {
    if (uri.scheme === Schemas.vscodeRemote) {
      return RemoteAuthorities.rewrite(uri);
    }
    if (
      // ...only ever for `file` resources
      uri.scheme === Schemas.file && // ...and we run in native environments
      (isNative || // ...or web worker extensions on desktop
      webWorkerOrigin === `${Schemas.vscodeFileResource}://${_FileAccessImpl.FALLBACK_AUTHORITY}`)
    ) {
      return uri.with({
        scheme: Schemas.vscodeFileResource,
        // We need to provide an authority here so that it can serve
        // as origin for network and loading matters in chromium.
        // If the URI is not coming with an authority already, we
        // add our own
        authority: uri.authority || _FileAccessImpl.FALLBACK_AUTHORITY,
        query: null,
        fragment: null
      });
    }
    return uri;
  }
  /**
   * Returns the `file` URI to use in contexts where node.js
   * is responsible for loading.
   */
  asFileUri(resourcePath) {
    const uri = this.toUri(resourcePath);
    return this.uriToFileUri(uri);
  }
  /**
   * Returns the `file` URI to use in contexts where node.js
   * is responsible for loading.
   */
  uriToFileUri(uri) {
    if (uri.scheme === Schemas.vscodeFileResource) {
      return uri.with({
        scheme: Schemas.file,
        // Only preserve the `authority` if it is different from
        // our fallback authority. This ensures we properly preserve
        // Windows UNC paths that come with their own authority.
        authority: uri.authority !== _FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,
        query: null,
        fragment: null
      });
    }
    return uri;
  }
  toUri(uriOrModule) {
    if (URI.isUri(uriOrModule)) {
      return uriOrModule;
    }
    if (globalThis._VSCODE_FILE_ROOT) {
      const rootUriOrPath = globalThis._VSCODE_FILE_ROOT;
      if (/^\w[\w\d+.-]*:\/\//.test(rootUriOrPath)) {
        return URI.joinPath(URI.parse(rootUriOrPath, true), uriOrModule);
      }
      const modulePath = join(rootUriOrPath, uriOrModule);
      return URI.file(modulePath);
    }
    throw new Error("Cannot determine URI for module id!");
  }
};
var FileAccess = new FileAccessImpl();
var CacheControlheaders = Object.freeze({
  "Cache-Control": "no-cache, no-store"
});
var DocumentPolicyheaders = Object.freeze({
  "Document-Policy": "include-js-call-stacks-in-crash-reports"
});
var COI;
((COI2) => {
  const coiHeaders = /* @__PURE__ */ new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
  ]);
  COI2.CoopAndCoep = Object.freeze(coiHeaders.get("3"));
  const coiSearchParamName = "vscode-coi";
  function getHeadersFromQuery(url) {
    let params;
    if (typeof url === "string") {
      params = new URL(url).searchParams;
    } else if (url instanceof URL) {
      params = url.searchParams;
    } else if (URI.isUri(url)) {
      params = new URL(url.toString(true)).searchParams;
    }
    const value = params?.get(coiSearchParamName);
    if (!value) {
      return void 0;
    }
    return coiHeaders.get(value);
  }
  COI2.getHeadersFromQuery = getHeadersFromQuery;
  function addSearchParam(urlOrSearch, coop, coep) {
    if (!globalThis.crossOriginIsolated) {
      return;
    }
    const value = coop && coep ? "3" : coep ? "2" : "1";
    if (urlOrSearch instanceof URLSearchParams) {
      urlOrSearch.set(coiSearchParamName, value);
    } else {
      urlOrSearch[coiSearchParamName] = value;
    }
  }
  COI2.addSearchParam = addSearchParam;
})(COI || (COI = {}));

// src/util/vs/base/common/resources.ts
init_strings();
function originalFSPath(uri) {
  return uriToFsPath(uri, true);
}
var ExtUri = class {
  constructor(_ignorePathCasing) {
    this._ignorePathCasing = _ignorePathCasing;
  }
  compare(uri1, uri2, ignoreFragment = false) {
    if (uri1 === uri2) {
      return 0;
    }
    return compare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));
  }
  isEqual(uri1, uri2, ignoreFragment = false) {
    if (uri1 === uri2) {
      return true;
    }
    if (!uri1 || !uri2) {
      return false;
    }
    return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);
  }
  getComparisonKey(uri, ignoreFragment = false) {
    return uri.with({
      path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : void 0,
      fragment: ignoreFragment ? null : void 0
    }).toString();
  }
  ignorePathCasing(uri) {
    return this._ignorePathCasing(uri);
  }
  isEqualOrParent(base2, parentCandidate, ignoreFragment = false) {
    if (base2.scheme === parentCandidate.scheme) {
      if (base2.scheme === Schemas.file) {
        return isEqualOrParent(originalFSPath(base2), originalFSPath(parentCandidate), this._ignorePathCasing(base2)) && base2.query === parentCandidate.query && (ignoreFragment || base2.fragment === parentCandidate.fragment);
      }
      if (isEqualAuthority(base2.authority, parentCandidate.authority)) {
        return isEqualOrParent(base2.path, parentCandidate.path, this._ignorePathCasing(base2), "/") && base2.query === parentCandidate.query && (ignoreFragment || base2.fragment === parentCandidate.fragment);
      }
    }
    return false;
  }
  // --- path math
  joinPath(resource, ...pathFragment) {
    return URI.joinPath(resource, ...pathFragment);
  }
  basenameOrAuthority(resource) {
    return basename2(resource) || resource.authority;
  }
  basename(resource) {
    return posix.basename(resource.path);
  }
  extname(resource) {
    return posix.extname(resource.path);
  }
  dirname(resource) {
    if (resource.path.length === 0) {
      return resource;
    }
    let dirname3;
    if (resource.scheme === Schemas.file) {
      dirname3 = URI.file(dirname(originalFSPath(resource))).path;
    } else {
      dirname3 = posix.dirname(resource.path);
      if (resource.authority && dirname3.length && dirname3.charCodeAt(0) !== 47 /* Slash */) {
        console.error(`dirname("${resource.toString})) resulted in a relative path`);
        dirname3 = "/";
      }
    }
    return resource.with({
      path: dirname3
    });
  }
  normalizePath(resource) {
    if (!resource.path.length) {
      return resource;
    }
    let normalizedPath;
    if (resource.scheme === Schemas.file) {
      normalizedPath = URI.file(normalize(originalFSPath(resource))).path;
    } else {
      normalizedPath = posix.normalize(resource.path);
    }
    return resource.with({
      path: normalizedPath
    });
  }
  relativePath(from, to) {
    if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {
      return void 0;
    }
    if (from.scheme === Schemas.file) {
      const relativePath2 = relative(originalFSPath(from), originalFSPath(to));
      return isWindows ? toSlashes(relativePath2) : relativePath2;
    }
    let fromPath = from.path || "/";
    const toPath = to.path || "/";
    if (this._ignorePathCasing(from)) {
      let i = 0;
      for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {
        if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {
          if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {
            break;
          }
        }
      }
      fromPath = toPath.substr(0, i) + fromPath.substr(i);
    }
    return posix.relative(fromPath, toPath);
  }
  resolvePath(base2, path) {
    if (base2.scheme === Schemas.file) {
      const newURI = URI.file(resolve(originalFSPath(base2), path));
      return base2.with({
        authority: newURI.authority,
        path: newURI.path
      });
    }
    path = toPosixPath(path);
    return base2.with({
      path: posix.resolve(base2.path, path)
    });
  }
  // --- misc
  isAbsolutePath(resource) {
    return !!resource.path && resource.path[0] === "/";
  }
  isEqualAuthority(a1, a2) {
    return a1 === a2 || a1 !== void 0 && a2 !== void 0 && equalsIgnoreCase(a1, a2);
  }
  hasTrailingPathSeparator(resource, sep2 = sep) {
    if (resource.scheme === Schemas.file) {
      const fsp = originalFSPath(resource);
      return fsp.length > getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
    } else {
      const p = resource.path;
      return p.length > 1 && p.charCodeAt(p.length - 1) === 47 /* Slash */ && !/^[a-zA-Z]:(\/$|\\$)/.test(resource.fsPath);
    }
  }
  removeTrailingPathSeparator(resource, sep2 = sep) {
    if (hasTrailingPathSeparator(resource, sep2)) {
      return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });
    }
    return resource;
  }
  addTrailingPathSeparator(resource, sep2 = sep) {
    let isRootSep = false;
    if (resource.scheme === Schemas.file) {
      const fsp = originalFSPath(resource);
      isRootSep = fsp !== void 0 && fsp.length === getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
    } else {
      sep2 = "/";
      const p = resource.path;
      isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47 /* Slash */;
    }
    if (!isRootSep && !hasTrailingPathSeparator(resource, sep2)) {
      return resource.with({ path: resource.path + "/" });
    }
    return resource;
  }
};
var extUri = new ExtUri(() => false);
var extUriBiasedIgnorePathCase = new ExtUri((uri) => {
  return uri.scheme === Schemas.file ? !isLinux : true;
});
var extUriIgnorePathCase = new ExtUri((_) => true);
var isEqual = extUri.isEqual.bind(extUri);
var isEqualOrParent2 = extUri.isEqualOrParent.bind(extUri);
var getComparisonKey = extUri.getComparisonKey.bind(extUri);
var basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);
var basename2 = extUri.basename.bind(extUri);
var extname2 = extUri.extname.bind(extUri);
var dirname2 = extUri.dirname.bind(extUri);
var joinPath = extUri.joinPath.bind(extUri);
var normalizePath = extUri.normalizePath.bind(extUri);
var relativePath = extUri.relativePath.bind(extUri);
var resolvePath = extUri.resolvePath.bind(extUri);
var isAbsolutePath = extUri.isAbsolutePath.bind(extUri);
var isEqualAuthority = extUri.isEqualAuthority.bind(extUri);
var hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);
var removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);
var addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);
var DataUri;
((DataUri2) => {
  DataUri2.META_DATA_LABEL = "label";
  DataUri2.META_DATA_DESCRIPTION = "description";
  DataUri2.META_DATA_SIZE = "size";
  DataUri2.META_DATA_MIME = "mime";
  function parseMetaData(dataUri) {
    const metadata = /* @__PURE__ */ new Map();
    const meta = dataUri.path.substring(dataUri.path.indexOf(";") + 1, dataUri.path.lastIndexOf(";"));
    meta.split(";").forEach((property) => {
      const [key, value] = property.split(":");
      if (key && value) {
        metadata.set(key, value);
      }
    });
    const mime = dataUri.path.substring(0, dataUri.path.indexOf(";"));
    if (mime) {
      metadata.set(DataUri2.META_DATA_MIME, mime);
    }
    return metadata;
  }
  DataUri2.parseMetaData = parseMetaData;
})(DataUri || (DataUri = {}));

// src/util/vs/base/common/symbols.ts
var MicrotaskDelay = Symbol("MicrotaskDelay");

// src/util/vs/base/common/async.ts
init_lazy();
function isThenable(obj) {
  return !!obj && typeof obj.then === "function";
}
function createCancelablePromise(callback) {
  const source = new CancellationTokenSource();
  const thenable = callback(source.token);
  let isCancelled = false;
  const promise = new Promise((resolve2, reject) => {
    const subscription = source.token.onCancellationRequested(() => {
      isCancelled = true;
      subscription.dispose();
      reject(new CancellationError());
    });
    Promise.resolve(thenable).then((value) => {
      subscription.dispose();
      source.dispose();
      if (!isCancelled) {
        resolve2(value);
      } else if (isDisposable(value)) {
        value.dispose();
      }
    }, (err) => {
      subscription.dispose();
      source.dispose();
      reject(err);
    });
  });
  return new class {
    cancel() {
      source.cancel();
      source.dispose();
    }
    then(resolve2, reject) {
      return promise.then(resolve2, reject);
    }
    catch(reject) {
      return this.then(void 0, reject);
    }
    finally(onfinally) {
      return promise.finally(onfinally);
    }
  }();
}
function raceCancellationError(promise, token) {
  return new Promise((resolve2, reject) => {
    const ref = token.onCancellationRequested(() => {
      ref.dispose();
      reject(new CancellationError());
    });
    promise.then(resolve2, reject).finally(() => ref.dispose());
  });
}
function timeout(millis, token) {
  if (!token) {
    return createCancelablePromise((token2) => timeout(millis, token2));
  }
  return new Promise((resolve2, reject) => {
    const handle = setTimeout(() => {
      disposable.dispose();
      resolve2();
    }, millis);
    const disposable = token.onCancellationRequested(() => {
      clearTimeout(handle);
      disposable.dispose();
      reject(new CancellationError());
    });
  });
}
var Limiter = class {
  constructor(maxDegreeOfParalellism) {
    this._size = 0;
    this._isDisposed = false;
    this.maxDegreeOfParalellism = maxDegreeOfParalellism;
    this.outstandingPromises = [];
    this.runningPromises = 0;
    this._onDrained = new Emitter();
  }
  /**
   *
   * @returns A promise that resolved when all work is done (onDrained) or when
   * there is nothing to do
   */
  whenIdle() {
    return this.size > 0 ? Event.toPromise(this.onDrained) : Promise.resolve();
  }
  get onDrained() {
    return this._onDrained.event;
  }
  get size() {
    return this._size;
  }
  queue(factory) {
    if (this._isDisposed) {
      throw new Error("Object has been disposed");
    }
    this._size++;
    return new Promise((c, e) => {
      this.outstandingPromises.push({ factory, c, e });
      this.consume();
    });
  }
  consume() {
    while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
      const iLimitedTask = this.outstandingPromises.shift();
      this.runningPromises++;
      const promise = iLimitedTask.factory();
      promise.then(iLimitedTask.c, iLimitedTask.e);
      promise.then(() => this.consumed(), () => this.consumed());
    }
  }
  consumed() {
    if (this._isDisposed) {
      return;
    }
    this.runningPromises--;
    if (--this._size === 0) {
      this._onDrained.fire();
    }
    if (this.outstandingPromises.length > 0) {
      this.consume();
    }
  }
  clear() {
    if (this._isDisposed) {
      throw new Error("Object has been disposed");
    }
    this.outstandingPromises.length = 0;
    this._size = this.runningPromises;
  }
  dispose() {
    this._isDisposed = true;
    this.outstandingPromises.length = 0;
    this._size = 0;
    this._onDrained.dispose();
  }
};
var TimeoutTimer = class {
  constructor(runner, timeout2) {
    this._isDisposed = false;
    this._token = void 0;
    if (typeof runner === "function" && typeof timeout2 === "number") {
      this.setIfNotSet(runner, timeout2);
    }
  }
  dispose() {
    this.cancel();
    this._isDisposed = true;
  }
  cancel() {
    if (this._token !== void 0) {
      clearTimeout(this._token);
      this._token = void 0;
    }
  }
  cancelAndSet(runner, timeout2) {
    if (this._isDisposed) {
      throw new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);
    }
    this.cancel();
    this._token = setTimeout(() => {
      this._token = void 0;
      runner();
    }, timeout2);
  }
  setIfNotSet(runner, timeout2) {
    if (this._isDisposed) {
      throw new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);
    }
    if (this._token !== void 0) {
      return;
    }
    this._token = setTimeout(() => {
      this._token = void 0;
      runner();
    }, timeout2);
  }
};
var RunOnceScheduler = class {
  constructor(runner, delay) {
    this.timeoutToken = void 0;
    this.runner = runner;
    this.timeout = delay;
    this.timeoutHandler = this.onTimeout.bind(this);
  }
  /**
   * Dispose RunOnceScheduler
   */
  dispose() {
    this.cancel();
    this.runner = null;
  }
  /**
   * Cancel current scheduled runner (if any).
   */
  cancel() {
    if (this.isScheduled()) {
      clearTimeout(this.timeoutToken);
      this.timeoutToken = void 0;
    }
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */
  schedule(delay = this.timeout) {
    this.cancel();
    this.timeoutToken = setTimeout(this.timeoutHandler, delay);
  }
  get delay() {
    return this.timeout;
  }
  set delay(value) {
    this.timeout = value;
  }
  /**
   * Returns true if scheduled.
   */
  isScheduled() {
    return this.timeoutToken !== void 0;
  }
  flush() {
    if (this.isScheduled()) {
      this.cancel();
      this.doRun();
    }
  }
  onTimeout() {
    this.timeoutToken = void 0;
    if (this.runner) {
      this.doRun();
    }
  }
  doRun() {
    this.runner?.();
  }
};
var runWhenGlobalIdle;
var _runWhenIdle;
(function() {
  const safeGlobal = globalThis;
  if (typeof safeGlobal.requestIdleCallback !== "function" || typeof safeGlobal.cancelIdleCallback !== "function") {
    _runWhenIdle = (_targetWindow, runner, timeout2) => {
      setTimeout0(() => {
        if (disposed) {
          return;
        }
        const end = Date.now() + 15;
        const deadline = {
          didTimeout: true,
          timeRemaining() {
            return Math.max(0, end - Date.now());
          }
        };
        runner(Object.freeze(deadline));
      });
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }
          disposed = true;
        }
      };
    };
  } else {
    _runWhenIdle = (targetWindow, runner, timeout2) => {
      const handle = targetWindow.requestIdleCallback(runner, typeof timeout2 === "number" ? { timeout: timeout2 } : void 0);
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }
          disposed = true;
          targetWindow.cancelIdleCallback(handle);
        }
      };
    };
  }
  runWhenGlobalIdle = (runner, timeout2) => _runWhenIdle(globalThis, runner, timeout2);
})();
var AbstractIdleValue = class {
  constructor(targetWindow, executor) {
    this._didRun = false;
    this._executor = () => {
      try {
        this._value = executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._didRun = true;
      }
    };
    this._handle = _runWhenIdle(targetWindow, () => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (!this._didRun) {
      this._handle.dispose();
      this._executor();
    }
    if (this._error) {
      throw this._error;
    }
    return this._value;
  }
  get isInitialized() {
    return this._didRun;
  }
};
var GlobalIdleValue = class extends AbstractIdleValue {
  constructor(executor) {
    super(globalThis, executor);
  }
};
var DeferredPromise = class _DeferredPromise {
  static fromPromise(promise) {
    const deferred = new _DeferredPromise();
    deferred.settleWith(promise);
    return deferred;
  }
  get isRejected() {
    return this.outcome?.outcome === 1 /* Rejected */;
  }
  get isResolved() {
    return this.outcome?.outcome === 0 /* Resolved */;
  }
  get isSettled() {
    return !!this.outcome;
  }
  get value() {
    return this.outcome?.outcome === 0 /* Resolved */ ? this.outcome?.value : void 0;
  }
  constructor() {
    this.p = new Promise((c, e) => {
      this.completeCallback = c;
      this.errorCallback = e;
    });
  }
  complete(value) {
    if (this.isSettled) {
      return Promise.resolve();
    }
    return new Promise((resolve2) => {
      this.completeCallback(value);
      this.outcome = { outcome: 0 /* Resolved */, value };
      resolve2();
    });
  }
  error(err) {
    if (this.isSettled) {
      return Promise.resolve();
    }
    return new Promise((resolve2) => {
      this.errorCallback(err);
      this.outcome = { outcome: 1 /* Rejected */, value: err };
      resolve2();
    });
  }
  settleWith(promise) {
    return promise.then(
      (value) => this.complete(value),
      (error2) => this.error(error2)
    );
  }
  cancel() {
    return this.error(new CancellationError());
  }
};
var Promises;
((Promises2) => {
  async function settled(promises) {
    let firstError = void 0;
    const result = await Promise.all(promises.map((promise) => promise.then((value) => value, (error2) => {
      if (!firstError) {
        firstError = error2;
      }
      return void 0;
    })));
    if (typeof firstError !== "undefined") {
      throw firstError;
    }
    return result;
  }
  Promises2.settled = settled;
  function withAsyncBody(bodyFn) {
    return new Promise(async (resolve2, reject) => {
      try {
        await bodyFn(resolve2, reject);
      } catch (error2) {
        reject(error2);
      }
    });
  }
  Promises2.withAsyncBody = withAsyncBody;
})(Promises || (Promises = {}));
var AsyncIterableObject = class _AsyncIterableObject {
  static fromArray(items) {
    return new _AsyncIterableObject((writer) => {
      writer.emitMany(items);
    });
  }
  static fromPromise(promise) {
    return new _AsyncIterableObject(async (emitter) => {
      emitter.emitMany(await promise);
    });
  }
  static fromPromisesResolveOrder(promises) {
    return new _AsyncIterableObject(async (emitter) => {
      await Promise.all(promises.map(async (p) => emitter.emitOne(await p)));
    });
  }
  static merge(iterables) {
    return new _AsyncIterableObject(async (emitter) => {
      await Promise.all(iterables.map(async (iterable) => {
        for await (const item of iterable) {
          emitter.emitOne(item);
        }
      }));
    });
  }
  static {
    this.EMPTY = _AsyncIterableObject.fromArray([]);
  }
  constructor(executor, onReturn) {
    this._state = 0 /* Initial */;
    this._results = [];
    this._error = null;
    this._onReturn = onReturn;
    this._onStateChanged = new Emitter();
    queueMicrotask(async () => {
      const writer = {
        emitOne: (item) => this.emitOne(item),
        emitMany: (items) => this.emitMany(items),
        reject: (error2) => this.reject(error2)
      };
      try {
        await Promise.resolve(executor(writer));
        this.resolve();
      } catch (err) {
        this.reject(err);
      } finally {
        writer.emitOne = void 0;
        writer.emitMany = void 0;
        writer.reject = void 0;
      }
    });
  }
  [Symbol.asyncIterator]() {
    let i = 0;
    return {
      next: async () => {
        do {
          if (this._state === 2 /* DoneError */) {
            throw this._error;
          }
          if (i < this._results.length) {
            return { done: false, value: this._results[i++] };
          }
          if (this._state === 1 /* DoneOK */) {
            return { done: true, value: void 0 };
          }
          await Event.toPromise(this._onStateChanged.event);
        } while (true);
      },
      return: async () => {
        this._onReturn?.();
        return { done: true, value: void 0 };
      }
    };
  }
  static map(iterable, mapFn) {
    return new _AsyncIterableObject(async (emitter) => {
      for await (const item of iterable) {
        emitter.emitOne(mapFn(item));
      }
    });
  }
  map(mapFn) {
    return _AsyncIterableObject.map(this, mapFn);
  }
  static filter(iterable, filterFn) {
    return new _AsyncIterableObject(async (emitter) => {
      for await (const item of iterable) {
        if (filterFn(item)) {
          emitter.emitOne(item);
        }
      }
    });
  }
  filter(filterFn) {
    return _AsyncIterableObject.filter(this, filterFn);
  }
  static coalesce(iterable) {
    return _AsyncIterableObject.filter(iterable, (item) => !!item);
  }
  coalesce() {
    return _AsyncIterableObject.coalesce(this);
  }
  static async toPromise(iterable) {
    const result = [];
    for await (const item of iterable) {
      result.push(item);
    }
    return result;
  }
  toPromise() {
    return _AsyncIterableObject.toPromise(this);
  }
  /**
   * The value will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitOne(value) {
    if (this._state !== 0 /* Initial */) {
      return;
    }
    this._results.push(value);
    this._onStateChanged.fire();
  }
  /**
   * The values will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitMany(values) {
    if (this._state !== 0 /* Initial */) {
      return;
    }
    this._results = this._results.concat(values);
    this._onStateChanged.fire();
  }
  /**
   * Calling `resolve()` will mark the result array as complete.
   *
   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  resolve() {
    if (this._state !== 0 /* Initial */) {
      return;
    }
    this._state = 1 /* DoneOK */;
    this._onStateChanged.fire();
  }
  /**
   * Writing an error will permanently invalidate this iterable.
   * The current users will receive an error thrown, as will all future users.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  reject(error2) {
    if (this._state !== 0 /* Initial */) {
      return;
    }
    this._state = 2 /* DoneError */;
    this._error = error2;
    this._onStateChanged.fire();
  }
};
var AsyncIterableSource = class {
  /**
   *
   * @param onReturn A function that will be called when consuming the async iterable
   * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.
   * This is NOT called when resolving this source by its owner.
   */
  constructor(onReturn) {
    this._deferred = new DeferredPromise();
    this._asyncIterable = new AsyncIterableObject((emitter) => {
      if (earlyError) {
        emitter.reject(earlyError);
        return;
      }
      if (earlyItems) {
        emitter.emitMany(earlyItems);
      }
      this._errorFn = (error2) => emitter.reject(error2);
      this._emitOneFn = (item) => emitter.emitOne(item);
      this._emitManyFn = (items) => emitter.emitMany(items);
      return this._deferred.p;
    }, onReturn);
    let earlyError;
    let earlyItems;
    this._errorFn = (error2) => {
      if (!earlyError) {
        earlyError = error2;
      }
    };
    this._emitOneFn = (item) => {
      if (!earlyItems) {
        earlyItems = [];
      }
      earlyItems.push(item);
    };
    this._emitManyFn = (items) => {
      if (!earlyItems) {
        earlyItems = items.slice();
      } else {
        items.forEach((item) => earlyItems.push(item));
      }
    };
  }
  get asyncIterable() {
    return this._asyncIterable;
  }
  resolve() {
    this._deferred.complete();
  }
  reject(error2) {
    this._errorFn(error2);
    this._deferred.complete();
  }
  emitOne(item) {
    this._emitOneFn(item);
  }
  emitMany(items) {
    this._emitManyFn(items);
  }
};
var ProducerConsumer = class {
  constructor() {
    this._unsatisfiedConsumers = [];
    this._unconsumedValues = [];
  }
  get hasFinalValue() {
    return !!this._finalValue;
  }
  produce(value) {
    this._ensureNoFinalValue();
    if (this._unsatisfiedConsumers.length > 0) {
      const deferred = this._unsatisfiedConsumers.shift();
      this._resolveOrRejectDeferred(deferred, value);
    } else {
      this._unconsumedValues.push(value);
    }
  }
  produceFinal(value) {
    this._ensureNoFinalValue();
    this._finalValue = value;
    for (const deferred of this._unsatisfiedConsumers) {
      this._resolveOrRejectDeferred(deferred, value);
    }
    this._unsatisfiedConsumers.length = 0;
  }
  _ensureNoFinalValue() {
    if (this._finalValue) {
      throw new BugIndicatingError("ProducerConsumer: cannot produce after final value has been set");
    }
  }
  _resolveOrRejectDeferred(deferred, value) {
    if (value.ok) {
      deferred.complete(value.value);
    } else {
      deferred.error(value.error);
    }
  }
  consume() {
    if (this._unconsumedValues.length > 0 || this._finalValue) {
      const value = this._unconsumedValues.length > 0 ? this._unconsumedValues.shift() : this._finalValue;
      if (value.ok) {
        return Promise.resolve(value.value);
      } else {
        return Promise.reject(value.error);
      }
    } else {
      const deferred = new DeferredPromise();
      this._unsatisfiedConsumers.push(deferred);
      return deferred.p;
    }
  }
};
var AsyncIterableProducer = class _AsyncIterableProducer {
  constructor(executor, _onReturn) {
    this._onReturn = _onReturn;
    this._producerConsumer = new ProducerConsumer();
    this._iterator = {
      next: () => this._producerConsumer.consume(),
      return: () => {
        this._onReturn?.();
        return Promise.resolve({ done: true, value: void 0 });
      },
      throw: async (e) => {
        this._finishError(e);
        return { done: true, value: void 0 };
      }
    };
    queueMicrotask(async () => {
      const p = executor({
        emitOne: (value) => this._producerConsumer.produce({ ok: true, value: { done: false, value } }),
        emitMany: (values) => {
          for (const value of values) {
            this._producerConsumer.produce({ ok: true, value: { done: false, value } });
          }
        },
        reject: (error2) => this._finishError(error2)
      });
      if (!this._producerConsumer.hasFinalValue) {
        try {
          await p;
          this._finishOk();
        } catch (error2) {
          this._finishError(error2);
        }
      }
    });
  }
  static fromArray(items) {
    return new _AsyncIterableProducer((writer) => {
      writer.emitMany(items);
    });
  }
  static fromPromise(promise) {
    return new _AsyncIterableProducer(async (emitter) => {
      emitter.emitMany(await promise);
    });
  }
  static fromPromisesResolveOrder(promises) {
    return new _AsyncIterableProducer(async (emitter) => {
      await Promise.all(promises.map(async (p) => emitter.emitOne(await p)));
    });
  }
  static merge(iterables) {
    return new _AsyncIterableProducer(async (emitter) => {
      await Promise.all(iterables.map(async (iterable) => {
        for await (const item of iterable) {
          emitter.emitOne(item);
        }
      }));
    });
  }
  static {
    this.EMPTY = _AsyncIterableProducer.fromArray([]);
  }
  static map(iterable, mapFn) {
    return new _AsyncIterableProducer(async (emitter) => {
      for await (const item of iterable) {
        emitter.emitOne(mapFn(item));
      }
    });
  }
  map(mapFn) {
    return _AsyncIterableProducer.map(this, mapFn);
  }
  static coalesce(iterable) {
    return _AsyncIterableProducer.filter(iterable, (item) => !!item);
  }
  coalesce() {
    return _AsyncIterableProducer.coalesce(this);
  }
  static filter(iterable, filterFn) {
    return new _AsyncIterableProducer(async (emitter) => {
      for await (const item of iterable) {
        if (filterFn(item)) {
          emitter.emitOne(item);
        }
      }
    });
  }
  filter(filterFn) {
    return _AsyncIterableProducer.filter(this, filterFn);
  }
  _finishOk() {
    if (!this._producerConsumer.hasFinalValue) {
      this._producerConsumer.produceFinal({ ok: true, value: { done: true, value: void 0 } });
    }
  }
  _finishError(error2) {
    if (!this._producerConsumer.hasFinalValue) {
      this._producerConsumer.produceFinal({ ok: false, error: error2 });
    }
  }
  [Symbol.asyncIterator]() {
    return this._iterator;
  }
};
var AsyncReaderEndOfStream = Symbol("AsyncReaderEndOfStream");

// src/util/vs/platform/instantiation/common/instantiationService.ts
init_errors();
init_lifecycle();

// src/util/vs/platform/instantiation/common/descriptors.ts
var SyncDescriptor = class {
  constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {
    this.ctor = ctor;
    this.staticArguments = staticArguments;
    this.supportsDelayedInstantiation = supportsDelayedInstantiation;
  }
};

// src/util/vs/platform/instantiation/common/graph.ts
var Node2 = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
    this.incoming = /* @__PURE__ */ new Map();
    this.outgoing = /* @__PURE__ */ new Map();
  }
};
var Graph = class {
  constructor(_hashFn) {
    this._hashFn = _hashFn;
    this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const ret = [];
    for (const node of this._nodes.values()) {
      if (node.outgoing.size === 0) {
        ret.push(node);
      }
    }
    return ret;
  }
  insertEdge(from, to) {
    const fromNode = this.lookupOrInsertNode(from);
    const toNode = this.lookupOrInsertNode(to);
    fromNode.outgoing.set(toNode.key, toNode);
    toNode.incoming.set(fromNode.key, fromNode);
  }
  removeNode(data) {
    const key = this._hashFn(data);
    this._nodes.delete(key);
    for (const node of this._nodes.values()) {
      node.outgoing.delete(key);
      node.incoming.delete(key);
    }
  }
  lookupOrInsertNode(data) {
    const key = this._hashFn(data);
    let node = this._nodes.get(key);
    if (!node) {
      node = new Node2(key, data);
      this._nodes.set(key, node);
    }
    return node;
  }
  lookup(data) {
    return this._nodes.get(this._hashFn(data));
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    const data = [];
    for (const [key, value] of this._nodes) {
      data.push(`${key}
	(-> incoming)[${[...value.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...value.outgoing.keys()].join(",")}]
`);
    }
    return data.join("\n");
  }
  /**
   * This is brute force and slow and **only** be used
   * to trouble shoot.
   */
  findCycleSlow() {
    for (const [id2, node] of this._nodes) {
      const seen = /* @__PURE__ */ new Set([id2]);
      const res = this._findCycle(node, seen);
      if (res) {
        return res;
      }
    }
    return void 0;
  }
  _findCycle(node, seen) {
    for (const [id2, outgoing] of node.outgoing) {
      if (seen.has(id2)) {
        return [...seen, id2].join(" -> ");
      }
      seen.add(id2);
      const value = this._findCycle(outgoing, seen);
      if (value) {
        return value;
      }
      seen.delete(id2);
    }
    return void 0;
  }
};

// src/util/vs/platform/instantiation/common/serviceCollection.ts
var ServiceCollection = class {
  constructor(...entries) {
    this._entries = /* @__PURE__ */ new Map();
    for (const [id2, service] of entries) {
      this.set(id2, service);
    }
  }
  set(id2, instanceOrDescriptor) {
    const result = this._entries.get(id2);
    this._entries.set(id2, instanceOrDescriptor);
    return result;
  }
  has(id2) {
    return this._entries.has(id2);
  }
  get(id2) {
    return this._entries.get(id2);
  }
};

// src/util/vs/platform/instantiation/common/instantiationService.ts
init_linkedList();
var _enableAllTracing = false;
var CyclicDependencyError = class extends Error {
  constructor(graph) {
    super("cyclic dependency between services");
    this.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: 
${graph.toString()}`;
  }
};
var InstantiationService = class _InstantiationService {
  constructor(_services = new ServiceCollection(), _strict = false, _parent, _enableTracing = _enableAllTracing) {
    this._services = _services;
    this._strict = _strict;
    this._parent = _parent;
    this._enableTracing = _enableTracing;
    this._isDisposed = false;
    this._servicesToMaybeDispose = /* @__PURE__ */ new Set();
    this._children = /* @__PURE__ */ new Set();
    this._activeInstantiations = /* @__PURE__ */ new Set();
    this._services.set(IInstantiationService, this);
    this._globalGraph = _enableTracing ? _parent?._globalGraph ?? new Graph((e) => e) : void 0;
  }
  dispose() {
    if (!this._isDisposed) {
      this._isDisposed = true;
      dispose(this._children);
      this._children.clear();
      for (const candidate of this._servicesToMaybeDispose) {
        if (isDisposable(candidate)) {
          candidate.dispose();
        }
      }
      this._servicesToMaybeDispose.clear();
    }
  }
  _throwIfDisposed() {
    if (this._isDisposed) {
      throw new Error("InstantiationService has been disposed");
    }
  }
  createChild(services, store) {
    this._throwIfDisposed();
    const that = this;
    const result = new class extends _InstantiationService {
      dispose() {
        that._children.delete(result);
        super.dispose();
      }
    }(services, this._strict, this, this._enableTracing);
    this._children.add(result);
    store?.add(result);
    return result;
  }
  invokeFunction(fn, ...args) {
    this._throwIfDisposed();
    const _trace = Trace.traceInvocation(this._enableTracing, fn);
    let _done = false;
    try {
      const accessor = {
        get: (id2) => {
          if (_done) {
            throw illegalState("service accessor is only valid during the invocation of its target method");
          }
          const result = this._getOrCreateServiceInstance(id2, _trace);
          if (!result) {
            throw new Error(`[invokeFunction] unknown service '${id2}'`);
          }
          return result;
        },
        getIfExists: (id2) => {
          if (_done) {
            throw illegalState("service accessor is only valid during the invocation of its target method");
          }
          const result = this._getOrCreateServiceInstance(id2, _trace);
          return result;
        }
      };
      return fn(accessor, ...args);
    } finally {
      _done = true;
      _trace.stop();
    }
  }
  createInstance(ctorOrDescriptor, ...rest) {
    this._throwIfDisposed();
    let _trace;
    let result;
    if (ctorOrDescriptor instanceof SyncDescriptor) {
      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);
      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);
    } else {
      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);
      result = this._createInstance(ctorOrDescriptor, rest, _trace);
    }
    _trace.stop();
    return result;
  }
  _createInstance(ctor, args = [], _trace) {
    const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);
    const serviceArgs = [];
    for (const dependency of serviceDependencies) {
      const service = this._getOrCreateServiceInstance(dependency.id, _trace);
      if (!service) {
        this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);
      }
      serviceArgs.push(service);
    }
    const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;
    if (args.length !== firstServiceArgPos) {
      console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);
      const delta = firstServiceArgPos - args.length;
      if (delta > 0) {
        args = args.concat(new Array(delta));
      } else {
        args = args.slice(0, firstServiceArgPos);
      }
    }
    return Reflect.construct(ctor, args.concat(serviceArgs));
  }
  _setCreatedServiceInstance(id2, instance) {
    if (this._services.get(id2) instanceof SyncDescriptor) {
      this._services.set(id2, instance);
    } else if (this._parent) {
      this._parent._setCreatedServiceInstance(id2, instance);
    } else {
      throw new Error("illegalState - setting UNKNOWN service instance");
    }
  }
  _getServiceInstanceOrDescriptor(id2) {
    const instanceOrDesc = this._services.get(id2);
    if (!instanceOrDesc && this._parent) {
      return this._parent._getServiceInstanceOrDescriptor(id2);
    } else {
      return instanceOrDesc;
    }
  }
  _getOrCreateServiceInstance(id2, _trace) {
    if (this._globalGraph && this._globalGraphImplicitDependency) {
      this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id2));
    }
    const thing = this._getServiceInstanceOrDescriptor(id2);
    if (thing instanceof SyncDescriptor) {
      return this._safeCreateAndCacheServiceInstance(id2, thing, _trace.branch(id2, true));
    } else {
      _trace.branch(id2, false);
      return thing;
    }
  }
  _safeCreateAndCacheServiceInstance(id2, desc, _trace) {
    if (this._activeInstantiations.has(id2)) {
      throw new Error(`illegal state - RECURSIVELY instantiating service '${id2}'`);
    }
    this._activeInstantiations.add(id2);
    try {
      return this._createAndCacheServiceInstance(id2, desc, _trace);
    } finally {
      this._activeInstantiations.delete(id2);
    }
  }
  _createAndCacheServiceInstance(id2, desc, _trace) {
    const graph = new Graph((data) => data.id.toString());
    let cycleCount = 0;
    const stack = [{ id: id2, desc, _trace }];
    const seen = /* @__PURE__ */ new Set();
    while (stack.length) {
      const item = stack.pop();
      if (seen.has(String(item.id))) {
        continue;
      }
      seen.add(String(item.id));
      graph.lookupOrInsertNode(item);
      if (cycleCount++ > 1e3) {
        throw new CyclicDependencyError(graph);
      }
      for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {
        const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);
        if (!instanceOrDesc) {
          this._throwIfStrict(`[createInstance] ${id2} depends on ${dependency.id} which is NOT registered.`, true);
        }
        this._globalGraph?.insertEdge(String(item.id), String(dependency.id));
        if (instanceOrDesc instanceof SyncDescriptor) {
          const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };
          graph.insertEdge(item, d);
          stack.push(d);
        }
      }
    }
    while (true) {
      const roots = graph.roots();
      if (roots.length === 0) {
        if (!graph.isEmpty()) {
          throw new CyclicDependencyError(graph);
        }
        break;
      }
      for (const { data } of roots) {
        const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);
        if (instanceOrDesc instanceof SyncDescriptor) {
          const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);
          this._setCreatedServiceInstance(data.id, instance);
        }
        graph.removeNode(data);
      }
    }
    return this._getServiceInstanceOrDescriptor(id2);
  }
  _createServiceInstanceWithOwner(id2, ctor, args = [], supportsDelayedInstantiation, _trace) {
    if (this._services.get(id2) instanceof SyncDescriptor) {
      return this._createServiceInstance(id2, ctor, args, supportsDelayedInstantiation, _trace, this._servicesToMaybeDispose);
    } else if (this._parent) {
      return this._parent._createServiceInstanceWithOwner(id2, ctor, args, supportsDelayedInstantiation, _trace);
    } else {
      throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);
    }
  }
  _createServiceInstance(id2, ctor, args = [], supportsDelayedInstantiation, _trace, disposeBucket) {
    if (!supportsDelayedInstantiation) {
      const result = this._createInstance(ctor, args, _trace);
      disposeBucket.add(result);
      return result;
    } else {
      const child = new _InstantiationService(void 0, this._strict, this, this._enableTracing);
      child._globalGraphImplicitDependency = String(id2);
      const earlyListeners = /* @__PURE__ */ new Map();
      const idle = new GlobalIdleValue(() => {
        const result = child._createInstance(ctor, args, _trace);
        for (const [key, values] of earlyListeners) {
          const candidate = result[key];
          if (typeof candidate === "function") {
            for (const value of values) {
              value.disposable = candidate.apply(result, value.listener);
            }
          }
        }
        earlyListeners.clear();
        disposeBucket.add(result);
        return result;
      });
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(target, key) {
          if (!idle.isInitialized) {
            if (typeof key === "string" && (key.startsWith("onDid") || key.startsWith("onWill"))) {
              let list2 = earlyListeners.get(key);
              if (!list2) {
                list2 = new LinkedList();
                earlyListeners.set(key, list2);
              }
              const event = (callback, thisArg, disposables) => {
                if (idle.isInitialized) {
                  return idle.value[key](callback, thisArg, disposables);
                } else {
                  const entry = { listener: [callback, thisArg, disposables], disposable: void 0 };
                  const rm = list2.push(entry);
                  const result = toDisposable(() => {
                    rm();
                    entry.disposable?.dispose();
                  });
                  return result;
                }
              };
              return event;
            }
          }
          if (key in target) {
            return target[key];
          }
          const obj = idle.value;
          let prop = obj[key];
          if (typeof prop !== "function") {
            return prop;
          }
          prop = prop.bind(obj);
          target[key] = prop;
          return prop;
        },
        set(_target, p, value) {
          idle.value[p] = value;
          return true;
        },
        getPrototypeOf(_target) {
          return ctor.prototype;
        }
      });
    }
  }
  _throwIfStrict(msg, printWarning) {
    if (printWarning) {
      console.warn(msg);
    }
    if (this._strict) {
      throw new Error(msg);
    }
  }
};
var Trace = class _Trace {
  constructor(type, name) {
    this.type = type;
    this.name = name;
    this._start = Date.now();
    this._dep = [];
  }
  static {
    this.all = /* @__PURE__ */ new Set();
  }
  static {
    this._None = new class extends _Trace {
      constructor() {
        super(0 /* None */, null);
      }
      stop() {
      }
      branch() {
        return this;
      }
    }();
  }
  static traceInvocation(_enableTracing, ctor) {
    return !_enableTracing ? _Trace._None : new _Trace(2 /* Invocation */, ctor.name || new Error().stack.split("\n").slice(3, 4).join("\n"));
  }
  static traceCreation(_enableTracing, ctor) {
    return !_enableTracing ? _Trace._None : new _Trace(1 /* Creation */, ctor.name);
  }
  static {
    this._totals = 0;
  }
  branch(id2, first) {
    const child = new _Trace(3 /* Branch */, id2.toString());
    this._dep.push([id2, first, child]);
    return child;
  }
  stop() {
    const dur = Date.now() - this._start;
    _Trace._totals += dur;
    let causedCreation = false;
    function printChild(n, trace) {
      const res = [];
      const prefix = new Array(n + 1).join("	");
      for (const [id2, first, child] of trace._dep) {
        if (first && child) {
          causedCreation = true;
          res.push(`${prefix}CREATES -> ${id2}`);
          const nested = printChild(n + 1, child);
          if (nested) {
            res.push(nested);
          }
        } else {
          res.push(`${prefix}uses -> ${id2}`);
        }
      }
      return res.join("\n");
    }
    const lines = [
      `${this.type === 1 /* Creation */ ? "CREATE" : "CALL"} ${this.name}`,
      `${printChild(1, this)}`,
      `DONE, took ${dur.toFixed(2)}ms (grand total ${_Trace._totals.toFixed(2)}ms)`
    ];
    if (dur > 2 || causedCreation) {
      _Trace.all.add(lines.join("\n"));
    }
  }
};

// src/util/common/services.ts
var InstantiationServiceBuilder = class {
  constructor(entries) {
    this._isSealed = false;
    this._collection = Array.isArray(entries) ? new ServiceCollection(...entries) : entries ?? new ServiceCollection();
  }
  define(id2, instance) {
    if (this._isSealed) {
      throw new Error("This accessor is sealed and cannot be modified anymore.");
    }
    this._collection.set(id2, instance);
  }
  seal() {
    if (this._isSealed) {
      throw new Error("This accessor is sealed and cannot be seal again anymore.");
    }
    this._isSealed = true;
    return new InstantiationService(this._collection, true);
  }
};

// src/platform/env/common/packagejson.ts
var packageJson = require_package();
var isProduction = packageJson.buildType !== "dev";
var isPreRelease = packageJson.isPreRelease || !isProduction;
var vscodeEngineVersion = packageJson.engines.vscode;

// src/platform/env/common/envService.ts
var NameAndVersion = class {
  constructor(name, version2) {
    this.name = name;
    this.version = version2;
  }
  format() {
    return `${this.name}/${this.version}`;
  }
};
var IEnvService = createDecorator("IEnvService");
var INativeEnvService = createDecorator("INativeEnvService");
var isScenarioAutomation = env["IS_SCENARIO_AUTOMATION"] === "1";

// src/platform/ignore/common/ignoreService.ts
var HAS_IGNORED_FILES_MESSAGE = t("\n\n**Note:** Some files were excluded from the context due to content exclusion rules (.pukuignore).");
var IIgnoreService = createDecorator("IIgnoreService");
var NullIgnoreService = class _NullIgnoreService {
  static {
    this.Instance = new _NullIgnoreService();
  }
  dispose() {
  }
  get isEnabled() {
    return false;
  }
  get isRegexExclusionsEnabled() {
    return false;
  }
  async init() {
  }
  async isPukuIgnored(file) {
    return false;
  }
  async asMinimatchPattern() {
    return void 0;
  }
};

// src/platform/telemetry/common/nullExperimentationService.ts
init_event();
var IExperimentationService = createDecorator("IExperimentationService");

// src/extension/api/vscode/extensionApi.ts
var import_vscode = require("vscode");

// src/platform/languageContextProvider/common/languageContextProviderService.ts
var ILanguageContextProviderService = createDecorator("ILanguageContextProviderService");

// src/platform/scopeSelection/common/scopeSelection.ts
var IScopeSelector = createDecorator("IScopeSelector");

// src/extension/api/vscode/vscodeContextProviderApi.ts
var VSCodeContextProviderApiV1 = class {
  constructor(contextProviderService) {
    this.contextProviderService = contextProviderService;
  }
  registerContextProvider(provider) {
    return this.contextProviderService.registerContextProvider(provider);
  }
};
VSCodeContextProviderApiV1 = __decorateClass([
  __decorateParam(0, ILanguageContextProviderService)
], VSCodeContextProviderApiV1);

// src/extension/api/vscode/extensionApi.ts
var CopilotExtensionApi = class {
  constructor(_scopeSelector, _languageContextProviderService) {
    this._scopeSelector = _scopeSelector;
    this._languageContextProviderService = _languageContextProviderService;
  }
  static {
    this.version = 1;
  }
  async selectScope(editor, options) {
    editor ??= import_vscode.window.activeTextEditor;
    if (!editor) {
      return;
    }
    return this._scopeSelector.selectEnclosingScope(editor, options);
  }
  getContextProviderAPI(_version) {
    return new VSCodeContextProviderApiV1(this._languageContextProviderService);
  }
};
CopilotExtensionApi = __decorateClass([
  __decorateParam(0, IScopeSelector),
  __decorateParam(1, ILanguageContextProviderService)
], CopilotExtensionApi);

// src/platform/log/common/logService.ts
init_lifecycle();
var ILogService = createDecorator("ILogService");
var LogLevel = /* @__PURE__ */ ((LogLevel3) => {
  LogLevel3[LogLevel3["Off"] = 0] = "Off";
  LogLevel3[LogLevel3["Trace"] = 1] = "Trace";
  LogLevel3[LogLevel3["Debug"] = 2] = "Debug";
  LogLevel3[LogLevel3["Info"] = 3] = "Info";
  LogLevel3[LogLevel3["Warning"] = 4] = "Warning";
  LogLevel3[LogLevel3["Error"] = 5] = "Error";
  return LogLevel3;
})(LogLevel || {});
var LogServiceImpl = class extends Disposable {
  constructor(logTargets) {
    super();
    this.logger = new LoggerImpl(logTargets);
  }
  // Delegate logging methods directly to the internal logger
  trace(message) {
    this.logger.trace(message);
  }
  debug(message) {
    this.logger.debug(message);
  }
  info(message) {
    this.logger.info(message);
  }
  warn(message) {
    this.logger.warn(message);
  }
  error(error2, message) {
    this.logger.error(error2, message);
  }
  show(preserveFocus) {
    this.logger.show(preserveFocus);
  }
};
var LoggerImpl = class {
  constructor(_logTargets) {
    this._logTargets = _logTargets;
  }
  _logIt(level, message) {
    LogMemory.addLog(LogLevel[level], message);
    this._logTargets.forEach((t2) => t2.logIt(level, message));
  }
  trace(message) {
    this._logIt(1 /* Trace */, message);
  }
  debug(message) {
    this._logIt(2 /* Debug */, message);
  }
  info(message) {
    this._logIt(3 /* Info */, message);
  }
  warn(message) {
    this._logIt(4 /* Warning */, message);
  }
  error(error2, message) {
    this._logIt(5 /* Error */, collectErrorMessages(error2) + (message ? `: ${message}` : ""));
  }
  show(preserveFocus) {
    this._logTargets.forEach((t2) => t2.show?.(preserveFocus));
  }
};
function collectErrorMessages(e) {
  const seen = /* @__PURE__ */ new Set();
  function collect(e2, indent) {
    if (!e2 || !["object", "string"].includes(typeof e2) || seen.has(e2)) {
      return "";
    }
    seen.add(e2);
    const message = typeof e2 === "string" ? e2 : e2.stack || e2.message || e2.code || e2.toString?.() || "";
    const messageStr = message.toString?.() || "";
    return [
      messageStr ? `${messageStr.split("\n").map((line) => `${indent}${line}`).join("\n")}
` : "",
      collect(e2.cause, indent + "  "),
      ...Array.isArray(e2.errors) ? e2.errors.map((e3) => collect(e3, indent + "  ")) : []
    ].join("");
  }
  return collect(e, "").trim();
}
var LogMemory = class {
  static {
    this._logs = [];
  }
  static {
    this._requestIds = [];
  }
  static {
    this.MAX_LOGS = 50;
  }
  /**
   * Extracts the requestId from a log message if it matches the expected pattern.
   * Returns a string in the format 'requestId: {string}' or undefined if not found.
   */
  static extractRequestIdFromMessage(message) {
    const match3 = message.match(/request done: requestId: \[([0-9a-fA-F-]+)\] model deployment ID: \[/);
    if (match3) {
      const requestId = match3[1];
      if (!this._requestIds.includes(requestId)) {
        return requestId;
      }
    }
    return void 0;
  }
  static addLog(level, message) {
    if (this._logs.length >= this.MAX_LOGS) {
      this._logs.shift();
    }
    this._logs.push(`${level}: ${message}`);
    if (this._requestIds.length >= this.MAX_LOGS) {
      this._requestIds.shift();
    }
    const requestId = this.extractRequestIdFromMessage(message);
    if (requestId) {
      this._requestIds.push(requestId);
    }
  }
  static getLogs() {
    return this._logs;
  }
  static getRequestIds() {
    return this._requestIds;
  }
};

// src/extension/common/contributions.ts
init_lifecycle();
init_stopwatch();
function asContributionFactory(ctor) {
  return {
    create(accessor) {
      const instantiationService = accessor.get(IInstantiationService);
      return instantiationService.createInstance(ctor);
    }
  };
}
var ContributionCollection = class extends Disposable {
  constructor(contribs, logService, instaService) {
    super();
    this.allActivationBlockers = [];
    for (const contribution of contribs) {
      let instance;
      try {
        instance = instaService.invokeFunction(contribution.create);
        if (isDisposable(instance)) {
          this._register(instance);
        }
        if (instance?.activationBlocker) {
          const sw = StopWatch.create();
          const id2 = instance.id || "UNKNOWN";
          this.allActivationBlockers.push(instance.activationBlocker.finally(() => {
            logService.info(`activationBlocker from '${id2}' took for ${Math.round(sw.elapsed())}ms`);
          }));
        }
      } catch (error2) {
        logService.error(error2, `Error while loading contribution`);
      }
    }
  }
  async waitForActivationBlockers() {
    await Promise.allSettled(this.allActivationBlockers);
  }
};
ContributionCollection = __decorateClass([
  __decorateParam(1, ILogService),
  __decorateParam(2, IInstantiationService)
], ContributionCollection);

// src/extension/extension/vscode/extension.ts
async function baseActivate(configuration) {
  const context = configuration.context;
  if (context.extensionMode === import_vscode2.ExtensionMode.Test && !configuration.forceActivation && !isScenarioAutomation) {
    return context;
  }
  const isStableVsCode = !(import_vscode2.env.appName.includes("Insiders") || import_vscode2.env.appName.includes("Exploration") || import_vscode2.env.appName.includes("OSS"));
  const showSwitchToReleaseViewCtxKey = "puku.interactiveSession.switchToReleaseChannel";
  if (context.extension.packageJSON.isPreRelease && isStableVsCode) {
    import_vscode2.commands.executeCommand("setContext", showSwitchToReleaseViewCtxKey, true);
    return context;
  } else {
    import_vscode2.commands.executeCommand("setContext", showSwitchToReleaseViewCtxKey, void 0);
  }
  if (import_vscode2.l10n.bundle) {
    config({ contents: import_vscode2.l10n.bundle });
  }
  if (!isProduction) {
    configuration.configureDevPackages?.();
  }
  const instantiationService = createInstantiationService(configuration);
  await instantiationService.invokeFunction(async (accessor) => {
    const expService = accessor.get(IExperimentationService);
    await expService.hasTreatments();
    const contributions = instantiationService.createInstance(ContributionCollection, configuration.contributions);
    context.subscriptions.push(contributions);
    await contributions.waitForActivationBlockers();
  });
  if (import_vscode2.ExtensionMode.Test === context.extensionMode && !isScenarioAutomation) {
    return instantiationService;
  }
  return {
    getAPI(version2) {
      if (version2 > CopilotExtensionApi.version) {
        throw new Error("Invalid Copilot Chat extension API version. Please upgrade Copilot Chat.");
      }
      return instantiationService.createInstance(CopilotExtensionApi);
    }
  };
}
function createInstantiationService(configuration) {
  const accessor = new InstantiationServiceBuilder();
  configuration.registerServices(accessor, configuration.context);
  const instantiationService = accessor.seal();
  configuration.context.subscriptions.push(instantiationService);
  instantiationService.invokeFunction((accessor2) => {
    accessor2.get(IIgnoreService).init();
  });
  return instantiationService;
}

// src/platform/configuration/common/configurationService.ts
init_errors();
init_event();

// src/util/vs/base/common/buffer.ts
init_lazy();

// src/util/vs/base/common/stream.ts
init_errors();
init_lifecycle();

// src/util/vs/base/common/buffer.ts
var hasBuffer = typeof Buffer !== "undefined";
var indexOfTable = new Lazy(() => new Uint8Array(256));
var textEncoder;
var textDecoder;
var VSBuffer = class _VSBuffer {
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */
  static alloc(byteLength) {
    if (hasBuffer) {
      return new _VSBuffer(Buffer.allocUnsafe(byteLength));
    } else {
      return new _VSBuffer(new Uint8Array(byteLength));
    }
  }
  /**
   * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
   * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
   * which is not transferrable.
   */
  static wrap(actual) {
    if (hasBuffer && !Buffer.isBuffer(actual)) {
      actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
    }
    return new _VSBuffer(actual);
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */
  static fromString(source, options) {
    const dontUseNodeBuffer = options?.dontUseNodeBuffer || false;
    if (!dontUseNodeBuffer && hasBuffer) {
      return new _VSBuffer(Buffer.from(source));
    } else {
      if (!textEncoder) {
        textEncoder = new TextEncoder();
      }
      return new _VSBuffer(textEncoder.encode(source));
    }
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */
  static fromByteArray(source) {
    const result = _VSBuffer.alloc(source.length);
    for (let i = 0, len = source.length; i < len; i++) {
      result.buffer[i] = source[i];
    }
    return result;
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */
  static concat(buffers, totalLength) {
    if (typeof totalLength === "undefined") {
      totalLength = 0;
      for (let i = 0, len = buffers.length; i < len; i++) {
        totalLength += buffers[i].byteLength;
      }
    }
    const ret = _VSBuffer.alloc(totalLength);
    let offset = 0;
    for (let i = 0, len = buffers.length; i < len; i++) {
      const element = buffers[i];
      ret.set(element, offset);
      offset += element.byteLength;
    }
    return ret;
  }
  static isNativeBuffer(buffer) {
    return hasBuffer && Buffer.isBuffer(buffer);
  }
  constructor(buffer) {
    this.buffer = buffer;
    this.byteLength = this.buffer.byteLength;
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */
  clone() {
    const result = _VSBuffer.alloc(this.byteLength);
    result.set(this);
    return result;
  }
  toString() {
    if (hasBuffer) {
      return this.buffer.toString();
    } else {
      if (!textDecoder) {
        textDecoder = new TextDecoder();
      }
      return textDecoder.decode(this.buffer);
    }
  }
  slice(start, end) {
    return new _VSBuffer(this.buffer.subarray(start, end));
  }
  set(array, offset) {
    if (array instanceof _VSBuffer) {
      this.buffer.set(array.buffer, offset);
    } else if (array instanceof Uint8Array) {
      this.buffer.set(array, offset);
    } else if (array instanceof ArrayBuffer) {
      this.buffer.set(new Uint8Array(array), offset);
    } else if (ArrayBuffer.isView(array)) {
      this.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);
    } else {
      throw new Error(`Unknown argument 'array'`);
    }
  }
  readUInt32BE(offset) {
    return readUInt32BE(this.buffer, offset);
  }
  writeUInt32BE(value, offset) {
    writeUInt32BE(this.buffer, value, offset);
  }
  readUInt32LE(offset) {
    return readUInt32LE(this.buffer, offset);
  }
  writeUInt32LE(value, offset) {
    writeUInt32LE(this.buffer, value, offset);
  }
  readUInt8(offset) {
    return readUInt8(this.buffer, offset);
  }
  writeUInt8(value, offset) {
    writeUInt8(this.buffer, value, offset);
  }
  indexOf(subarray, offset = 0) {
    return binaryIndexOf(this.buffer, subarray instanceof _VSBuffer ? subarray.buffer : subarray, offset);
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (this.byteLength !== other.byteLength) {
      return false;
    }
    return this.buffer.every((value, index) => value === other.buffer[index]);
  }
};
function binaryIndexOf(haystack, needle, offset = 0) {
  const needleLen = needle.byteLength;
  const haystackLen = haystack.byteLength;
  if (needleLen === 0) {
    return 0;
  }
  if (needleLen === 1) {
    return haystack.indexOf(needle[0]);
  }
  if (needleLen > haystackLen - offset) {
    return -1;
  }
  const table2 = indexOfTable.value;
  table2.fill(needle.length);
  for (let i2 = 0; i2 < needle.length; i2++) {
    table2[needle[i2]] = needle.length - i2 - 1;
  }
  let i = offset + needle.length - 1;
  let j = i;
  let result = -1;
  while (i < haystackLen) {
    if (haystack[i] === needle[j]) {
      if (j === 0) {
        result = i;
        break;
      }
      i--;
      j--;
    } else {
      i += Math.max(needle.length - j, table2[haystack[i]]);
      j = needle.length - 1;
    }
  }
  return result;
}
function readUInt32BE(source, offset) {
  return source[offset] * 2 ** 24 + source[offset + 1] * 2 ** 16 + source[offset + 2] * 2 ** 8 + source[offset + 3];
}
function writeUInt32BE(destination, value, offset) {
  destination[offset + 3] = value;
  value = value >>> 8;
  destination[offset + 2] = value;
  value = value >>> 8;
  destination[offset + 1] = value;
  value = value >>> 8;
  destination[offset] = value;
}
function readUInt32LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0 | source[offset + 2] << 16 >>> 0 | source[offset + 3] << 24 >>> 0;
}
function writeUInt32LE(destination, value, offset) {
  destination[offset + 0] = value & 255;
  value = value >>> 8;
  destination[offset + 1] = value & 255;
  value = value >>> 8;
  destination[offset + 2] = value & 255;
  value = value >>> 8;
  destination[offset + 3] = value & 255;
}
function readUInt8(source, offset) {
  return source[offset];
}
function writeUInt8(destination, value, offset) {
  destination[offset] = value;
}
function decodeBase64(encoded) {
  let building = 0;
  let remainder = 0;
  let bufi = 0;
  const buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));
  const append = (value) => {
    switch (remainder) {
      case 3:
        buffer[bufi++] = building | value;
        remainder = 0;
        break;
      case 2:
        buffer[bufi++] = building | value >>> 2;
        building = value << 6;
        remainder = 3;
        break;
      case 1:
        buffer[bufi++] = building | value >>> 4;
        building = value << 4;
        remainder = 2;
        break;
      default:
        building = value << 2;
        remainder = 1;
    }
  };
  for (let i = 0; i < encoded.length; i++) {
    const code2 = encoded.charCodeAt(i);
    if (code2 >= 65 && code2 <= 90) {
      append(code2 - 65);
    } else if (code2 >= 97 && code2 <= 122) {
      append(code2 - 97 + 26);
    } else if (code2 >= 48 && code2 <= 57) {
      append(code2 - 48 + 52);
    } else if (code2 === 43 || code2 === 45) {
      append(62);
    } else if (code2 === 47 || code2 === 95) {
      append(63);
    } else if (code2 === 61) {
      break;
    } else {
      throw new SyntaxError(`Unexpected base64 character ${encoded[i]}`);
    }
  }
  const unpadded = bufi;
  while (remainder > 0) {
    append(0);
  }
  return VSBuffer.wrap(buffer).slice(0, unpadded);
}
var base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var base64UrlSafeAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
function encodeBase64({ buffer }, padded = true, urlSafe = false) {
  const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;
  let output = "";
  const remainder = buffer.byteLength % 3;
  let i = 0;
  for (; i < buffer.byteLength - remainder; i += 3) {
    const a = buffer[i + 0];
    const b = buffer[i + 1];
    const c = buffer[i + 2];
    output += dictionary[a >>> 2];
    output += dictionary[(a << 4 | b >>> 4) & 63];
    output += dictionary[(b << 2 | c >>> 6) & 63];
    output += dictionary[c & 63];
  }
  if (remainder === 1) {
    const a = buffer[i + 0];
    output += dictionary[a >>> 2];
    output += dictionary[a << 4 & 63];
    if (padded) {
      output += "==";
    }
  } else if (remainder === 2) {
    const a = buffer[i + 0];
    const b = buffer[i + 1];
    output += dictionary[a >>> 2];
    output += dictionary[(a << 4 | b >>> 4) & 63];
    output += dictionary[b << 2 & 63];
    if (padded) {
      output += "=";
    }
  }
  return output;
}
var hexChars = "0123456789abcdef";
function encodeHex({ buffer }) {
  let result = "";
  for (let i = 0; i < buffer.length; i++) {
    const byte = buffer[i];
    result += hexChars[byte >>> 4];
    result += hexChars[byte & 15];
  }
  return result;
}
function decodeHex(hex) {
  if (hex.length % 2 !== 0) {
    throw new SyntaxError("Hex string must have an even length");
  }
  const out = new Uint8Array(hex.length >> 1);
  for (let i = 0; i < hex.length; ) {
    out[i >> 1] = decodeHexChar(hex, i++) << 4 | decodeHexChar(hex, i++);
  }
  return VSBuffer.wrap(out);
}
function decodeHexChar(str, position) {
  const s = str.charCodeAt(position);
  if (s >= 48 && s <= 57) {
    return s - 48;
  } else if (s >= 97 && s <= 102) {
    return s - 87;
  } else if (s >= 65 && s <= 70) {
    return s - 55;
  } else {
    throw new SyntaxError(`Invalid hex character at position ${position}`);
  }
}

// src/util/vs/base/common/hash.ts
init_strings();
function leftRotate(value, bits, totalBits = 32) {
  const delta = totalBits - bits;
  const mask = ~((1 << delta) - 1);
  return (value << bits | (mask & value) >>> delta) >>> 0;
}
function toHexString(bufferOrValue, bitsize = 32) {
  if (bufferOrValue instanceof ArrayBuffer) {
    return encodeHex(VSBuffer.wrap(new Uint8Array(bufferOrValue)));
  }
  return (bufferOrValue >>> 0).toString(16).padStart(bitsize / 4, "0");
}
var StringSHA1 = class _StringSHA1 {
  constructor() {
    // 80 * 4 = 320
    this._h0 = 1732584193;
    this._h1 = 4023233417;
    this._h2 = 2562383102;
    this._h3 = 271733878;
    this._h4 = 3285377520;
    this._buff = new Uint8Array(
      64 /* BLOCK_SIZE */ + 3
      /* to fit any utf-8 */
    );
    this._buffDV = new DataView(this._buff.buffer);
    this._buffLen = 0;
    this._totalLen = 0;
    this._leftoverHighSurrogate = 0;
    this._finished = false;
  }
  static {
    this._bigBlock32 = new DataView(new ArrayBuffer(320));
  }
  update(str) {
    const strLen = str.length;
    if (strLen === 0) {
      return;
    }
    const buff = this._buff;
    let buffLen = this._buffLen;
    let leftoverHighSurrogate = this._leftoverHighSurrogate;
    let charCode;
    let offset;
    if (leftoverHighSurrogate !== 0) {
      charCode = leftoverHighSurrogate;
      offset = -1;
      leftoverHighSurrogate = 0;
    } else {
      charCode = str.charCodeAt(0);
      offset = 0;
    }
    while (true) {
      let codePoint = charCode;
      if (isHighSurrogate(charCode)) {
        if (offset + 1 < strLen) {
          const nextCharCode = str.charCodeAt(offset + 1);
          if (isLowSurrogate(nextCharCode)) {
            offset++;
            codePoint = computeCodePoint(charCode, nextCharCode);
          } else {
            codePoint = 65533 /* UNICODE_REPLACEMENT */;
          }
        } else {
          leftoverHighSurrogate = charCode;
          break;
        }
      } else if (isLowSurrogate(charCode)) {
        codePoint = 65533 /* UNICODE_REPLACEMENT */;
      }
      buffLen = this._push(buff, buffLen, codePoint);
      offset++;
      if (offset < strLen) {
        charCode = str.charCodeAt(offset);
      } else {
        break;
      }
    }
    this._buffLen = buffLen;
    this._leftoverHighSurrogate = leftoverHighSurrogate;
  }
  _push(buff, buffLen, codePoint) {
    if (codePoint < 128) {
      buff[buffLen++] = codePoint;
    } else if (codePoint < 2048) {
      buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    } else if (codePoint < 65536) {
      buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
      buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    } else {
      buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
      buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
      buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    }
    if (buffLen >= 64 /* BLOCK_SIZE */) {
      this._step();
      buffLen -= 64 /* BLOCK_SIZE */;
      this._totalLen += 64 /* BLOCK_SIZE */;
      buff[0] = buff[64 /* BLOCK_SIZE */ + 0];
      buff[1] = buff[64 /* BLOCK_SIZE */ + 1];
      buff[2] = buff[64 /* BLOCK_SIZE */ + 2];
    }
    return buffLen;
  }
  digest() {
    if (!this._finished) {
      this._finished = true;
      if (this._leftoverHighSurrogate) {
        this._leftoverHighSurrogate = 0;
        this._buffLen = this._push(this._buff, this._buffLen, 65533 /* UNICODE_REPLACEMENT */);
      }
      this._totalLen += this._buffLen;
      this._wrapUp();
    }
    return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
  }
  _wrapUp() {
    this._buff[this._buffLen++] = 128;
    this._buff.subarray(this._buffLen).fill(0);
    if (this._buffLen > 56) {
      this._step();
      this._buff.fill(0);
    }
    const ml = 8 * this._totalLen;
    this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
    this._buffDV.setUint32(60, ml % 4294967296, false);
    this._step();
  }
  _step() {
    const bigBlock32 = _StringSHA1._bigBlock32;
    const data = this._buffDV;
    for (let j = 0; j < 64; j += 4) {
      bigBlock32.setUint32(j, data.getUint32(j, false), false);
    }
    for (let j = 64; j < 320; j += 4) {
      bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
    }
    let a = this._h0;
    let b = this._h1;
    let c = this._h2;
    let d = this._h3;
    let e = this._h4;
    let f, k;
    let temp;
    for (let j = 0; j < 80; j++) {
      if (j < 20) {
        f = b & c | ~b & d;
        k = 1518500249;
      } else if (j < 40) {
        f = b ^ c ^ d;
        k = 1859775393;
      } else if (j < 60) {
        f = b & c | b & d | c & d;
        k = 2400959708;
      } else {
        f = b ^ c ^ d;
        k = 3395469782;
      }
      temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) & 4294967295;
      e = d;
      d = c;
      c = leftRotate(b, 30);
      b = a;
      a = temp;
    }
    this._h0 = this._h0 + a & 4294967295;
    this._h1 = this._h1 + b & 4294967295;
    this._h2 = this._h2 + c & 4294967295;
    this._h3 = this._h3 + d & 4294967295;
    this._h4 = this._h4 + e & 4294967295;
  }
};

// src/platform/configuration/common/configurationService.ts
init_lifecycle();

// src/util/vs/base/common/objects.ts
init_types();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function cloneAndChange(obj, changer) {
  return _cloneAndChange(obj, changer, /* @__PURE__ */ new Set());
}
function _cloneAndChange(obj, changer, seen) {
  if (isUndefinedOrNull(obj)) {
    return obj;
  }
  const changed = changer(obj);
  if (typeof changed !== "undefined") {
    return changed;
  }
  if (Array.isArray(obj)) {
    const r1 = [];
    for (const e of obj) {
      r1.push(_cloneAndChange(e, changer, seen));
    }
    return r1;
  }
  if (isObject(obj)) {
    if (seen.has(obj)) {
      throw new Error("Cannot clone recursive data-structure");
    }
    seen.add(obj);
    const r2 = {};
    for (const i2 in obj) {
      if (_hasOwnProperty.call(obj, i2)) {
        r2[i2] = _cloneAndChange(obj[i2], changer, seen);
      }
    }
    seen.delete(obj);
    return r2;
  }
  return obj;
}
function equals2(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals2(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals2(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals2(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
function mapValues(obj, fn) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    result[key] = fn(value, key);
  }
  return result;
}

// src/util/vs/base/common/observableInternal/debugName.ts
var DebugNameData = class {
  constructor(owner, debugNameSource, referenceFn) {
    this.owner = owner;
    this.debugNameSource = debugNameSource;
    this.referenceFn = referenceFn;
  }
  getDebugName(target) {
    return getDebugName(target, this);
  }
};
var countPerName = /* @__PURE__ */ new Map();
var cachedDebugName = /* @__PURE__ */ new WeakMap();
function getDebugName(target, data) {
  const cached = cachedDebugName.get(target);
  if (cached) {
    return cached;
  }
  const dbgName = computeDebugName(target, data);
  if (dbgName) {
    let count2 = countPerName.get(dbgName) ?? 0;
    count2++;
    countPerName.set(dbgName, count2);
    const result = count2 === 1 ? dbgName : `${dbgName}#${count2}`;
    cachedDebugName.set(target, result);
    return result;
  }
  return void 0;
}
function computeDebugName(self, data) {
  const cached = cachedDebugName.get(self);
  if (cached) {
    return cached;
  }
  const ownerStr = data.owner ? formatOwner(data.owner) + `.` : "";
  let result;
  const debugNameSource = data.debugNameSource;
  if (debugNameSource !== void 0) {
    if (typeof debugNameSource === "function") {
      result = debugNameSource();
      if (result !== void 0) {
        return ownerStr + result;
      }
    } else {
      return ownerStr + debugNameSource;
    }
  }
  const referenceFn = data.referenceFn;
  if (referenceFn !== void 0) {
    result = getFunctionName(referenceFn);
    if (result !== void 0) {
      return ownerStr + result;
    }
  }
  if (data.owner !== void 0) {
    const key = findKey(data.owner, self);
    if (key !== void 0) {
      return ownerStr + key;
    }
  }
  return void 0;
}
function findKey(obj, value) {
  for (const key in obj) {
    if (obj[key] === value) {
      return key;
    }
  }
  return void 0;
}
var countPerClassName = /* @__PURE__ */ new Map();
var ownerId = /* @__PURE__ */ new WeakMap();
function formatOwner(owner) {
  const id2 = ownerId.get(owner);
  if (id2) {
    return id2;
  }
  const className = getClassName(owner) ?? "Object";
  let count2 = countPerClassName.get(className) ?? 0;
  count2++;
  countPerClassName.set(className, count2);
  const result = count2 === 1 ? className : `${className}#${count2}`;
  ownerId.set(owner, result);
  return result;
}
function getClassName(obj) {
  const ctor = obj.constructor;
  if (ctor) {
    if (ctor.name === "Object") {
      return void 0;
    }
    return ctor.name;
  }
  return void 0;
}
function getFunctionName(fn) {
  const fnSrc = fn.toString();
  const regexp = /\/\*\*\s*@description\s*([^*]*)\*\//;
  const match3 = regexp.exec(fnSrc);
  const result = match3 ? match3[1] : void 0;
  return result?.trim();
}

// src/util/vs/base/common/observableInternal/commonFacade/deps.ts
init_assert();

// src/util/vs/base/common/equals.ts
init_arrays();
var strictEquals = (a, b) => a === b;

// src/util/vs/base/common/observableInternal/commonFacade/deps.ts
init_errors();
init_event();
init_lifecycle();

// src/util/vs/base/common/observableInternal/base.ts
function handleBugIndicatingErrorRecovery(message) {
  const err = new Error("BugIndicatingErrorRecovery: " + message);
  onUnexpectedError(err);
  console.error("recovered from an error that indicates a bug", err);
}

// src/util/vs/base/common/observableInternal/logging/logging.ts
var globalObservableLogger;
function addLogger(logger) {
  if (!globalObservableLogger) {
    globalObservableLogger = logger;
  } else if (globalObservableLogger instanceof ComposedLogger) {
    globalObservableLogger.loggers.push(logger);
  } else {
    globalObservableLogger = new ComposedLogger([globalObservableLogger, logger]);
  }
}
function getLogger() {
  return globalObservableLogger;
}
var globalObservableLoggerFn = void 0;
function setLogObservableFn(fn) {
  globalObservableLoggerFn = fn;
}
function logObservable(obs) {
  if (globalObservableLoggerFn) {
    globalObservableLoggerFn(obs);
  }
}
var ComposedLogger = class {
  constructor(loggers) {
    this.loggers = loggers;
  }
  handleObservableCreated(observable, location) {
    for (const logger of this.loggers) {
      logger.handleObservableCreated(observable, location);
    }
  }
  handleOnListenerCountChanged(observable, newCount) {
    for (const logger of this.loggers) {
      logger.handleOnListenerCountChanged(observable, newCount);
    }
  }
  handleObservableUpdated(observable, info) {
    for (const logger of this.loggers) {
      logger.handleObservableUpdated(observable, info);
    }
  }
  handleAutorunCreated(autorun2, location) {
    for (const logger of this.loggers) {
      logger.handleAutorunCreated(autorun2, location);
    }
  }
  handleAutorunDisposed(autorun2) {
    for (const logger of this.loggers) {
      logger.handleAutorunDisposed(autorun2);
    }
  }
  handleAutorunDependencyChanged(autorun2, observable, change) {
    for (const logger of this.loggers) {
      logger.handleAutorunDependencyChanged(autorun2, observable, change);
    }
  }
  handleAutorunStarted(autorun2) {
    for (const logger of this.loggers) {
      logger.handleAutorunStarted(autorun2);
    }
  }
  handleAutorunFinished(autorun2) {
    for (const logger of this.loggers) {
      logger.handleAutorunFinished(autorun2);
    }
  }
  handleDerivedDependencyChanged(derived2, observable, change) {
    for (const logger of this.loggers) {
      logger.handleDerivedDependencyChanged(derived2, observable, change);
    }
  }
  handleDerivedCleared(observable) {
    for (const logger of this.loggers) {
      logger.handleDerivedCleared(observable);
    }
  }
  handleBeginTransaction(transaction2) {
    for (const logger of this.loggers) {
      logger.handleBeginTransaction(transaction2);
    }
  }
  handleEndTransaction(transaction2) {
    for (const logger of this.loggers) {
      logger.handleEndTransaction(transaction2);
    }
  }
};

// src/util/vs/base/common/observableInternal/transaction.ts
function transaction(fn, getDebugName2) {
  const tx = new TransactionImpl(fn, getDebugName2);
  try {
    fn(tx);
  } finally {
    tx.finish();
  }
}
function subtransaction(tx, fn, getDebugName2) {
  if (!tx) {
    transaction(fn, getDebugName2);
  } else {
    fn(tx);
  }
}
var TransactionImpl = class {
  constructor(_fn, _getDebugName) {
    this._fn = _fn;
    this._getDebugName = _getDebugName;
    this._updatingObservers = [];
    getLogger()?.handleBeginTransaction(this);
  }
  getDebugName() {
    if (this._getDebugName) {
      return this._getDebugName();
    }
    return getFunctionName(this._fn);
  }
  updateObserver(observer, observable) {
    if (!this._updatingObservers) {
      handleBugIndicatingErrorRecovery("Transaction already finished!");
      transaction((tx) => {
        tx.updateObserver(observer, observable);
      });
      return;
    }
    this._updatingObservers.push({ observer, observable });
    observer.beginUpdate(observable);
  }
  finish() {
    const updatingObservers = this._updatingObservers;
    if (!updatingObservers) {
      handleBugIndicatingErrorRecovery("transaction.finish() has already been called!");
      return;
    }
    for (let i = 0; i < updatingObservers.length; i++) {
      const { observer, observable } = updatingObservers[i];
      observer.endUpdate(observable);
    }
    this._updatingObservers = null;
    getLogger()?.handleEndTransaction(this);
  }
  debugGetUpdatingObservers() {
    return this._updatingObservers;
  }
};

// src/util/vs/base/common/observableInternal/debugLocation.ts
var DebugLocation;
((DebugLocation2) => {
  let enabled = false;
  function enable() {
    enabled = true;
  }
  DebugLocation2.enable = enable;
  function ofCaller() {
    if (!enabled) {
      return void 0;
    }
    const Err = Error;
    const l = Err.stackTraceLimit;
    Err.stackTraceLimit = 3;
    const stack = new Error().stack;
    Err.stackTraceLimit = l;
    return DebugLocationImpl.fromStack(stack, 2);
  }
  DebugLocation2.ofCaller = ofCaller;
})(DebugLocation || (DebugLocation = {}));
var DebugLocationImpl = class _DebugLocationImpl {
  constructor(fileName, line, column, id2) {
    this.fileName = fileName;
    this.line = line;
    this.column = column;
    this.id = id2;
  }
  static fromStack(stack, parentIdx) {
    const lines = stack.split("\n");
    const location = parseLine(lines[parentIdx + 1]);
    if (location) {
      return new _DebugLocationImpl(
        location.fileName,
        location.line,
        location.column,
        location.id
      );
    } else {
      return void 0;
    }
  }
};
function parseLine(stackLine) {
  const match3 = stackLine.match(/\((.*):(\d+):(\d+)\)/);
  if (match3) {
    return {
      fileName: match3[1],
      line: parseInt(match3[2]),
      column: parseInt(match3[3]),
      id: stackLine
    };
  }
  const match22 = stackLine.match(/at ([^\(\)]*):(\d+):(\d+)/);
  if (match22) {
    return {
      fileName: match22[1],
      line: parseInt(match22[2]),
      column: parseInt(match22[3]),
      id: stackLine
    };
  }
  return void 0;
}

// src/util/vs/base/common/observableInternal/observables/baseObservable.ts
var _derived;
function _setDerivedOpts(derived2) {
  _derived = derived2;
}
var _recomputeInitiallyAndOnChange;
function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange2) {
  _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange2;
}
var _keepObserved;
function _setKeepObserved(keepObserved2) {
  _keepObserved = keepObserved2;
}
var _debugGetDependencyGraph;
function _setDebugGetDependencyGraph(debugGetDependencyGraph2) {
  _debugGetDependencyGraph = debugGetDependencyGraph2;
}
var ConvenientObservable = class {
  get TChange() {
    return null;
  }
  reportChanges() {
    this.get();
  }
  /** @sealed */
  read(reader) {
    if (reader) {
      return reader.readObservable(this);
    } else {
      return this.get();
    }
  }
  map(fnOrOwner, fnOrUndefined, debugLocation = DebugLocation.ofCaller()) {
    const owner = fnOrUndefined === void 0 ? void 0 : fnOrOwner;
    const fn = fnOrUndefined === void 0 ? fnOrOwner : fnOrUndefined;
    return _derived(
      {
        owner,
        debugName: () => {
          const name = getFunctionName(fn);
          if (name !== void 0) {
            return name;
          }
          const regexp = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/;
          const match3 = regexp.exec(fn.toString());
          if (match3) {
            return `${this.debugName}.${match3[2]}`;
          }
          if (!owner) {
            return `${this.debugName} (mapped)`;
          }
          return void 0;
        },
        debugReferenceFn: fn
      },
      (reader) => fn(this.read(reader), reader),
      debugLocation
    );
  }
  /**
   * @sealed
   * Converts an observable of an observable value into a direct observable of the value.
  */
  flatten() {
    return _derived(
      {
        owner: void 0,
        debugName: () => `${this.debugName} (flattened)`
      },
      (reader) => this.read(reader).read(reader)
    );
  }
  recomputeInitiallyAndOnChange(store, handleValue) {
    store.add(_recomputeInitiallyAndOnChange(this, handleValue));
    return this;
  }
  /**
   * Ensures that this observable is observed. This keeps the cache alive.
   * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).
   * Use `recomputeInitiallyAndOnChange` for eager evaluation.
   */
  keepObserved(store) {
    store.add(_keepObserved(this));
    return this;
  }
  get debugValue() {
    return this.get();
  }
  debugGetDependencyGraph() {
    return _debugGetDependencyGraph(this);
  }
};
var BaseObservable = class extends ConvenientObservable {
  constructor(debugLocation) {
    super();
    this._observers = /* @__PURE__ */ new Set();
    getLogger()?.handleObservableCreated(this, debugLocation);
  }
  addObserver(observer) {
    const len = this._observers.size;
    this._observers.add(observer);
    if (len === 0) {
      this.onFirstObserverAdded();
    }
    if (len !== this._observers.size) {
      getLogger()?.handleOnListenerCountChanged(this, this._observers.size);
    }
  }
  removeObserver(observer) {
    const deleted = this._observers.delete(observer);
    if (deleted && this._observers.size === 0) {
      this.onLastObserverRemoved();
    }
    if (deleted) {
      getLogger()?.handleOnListenerCountChanged(this, this._observers.size);
    }
  }
  onFirstObserverAdded() {
  }
  onLastObserverRemoved() {
  }
  log() {
    const hadLogger = !!getLogger();
    logObservable(this);
    if (!hadLogger) {
      getLogger()?.handleObservableCreated(this, DebugLocation.ofCaller());
    }
    return this;
  }
  debugGetObservers() {
    return this._observers;
  }
};

// src/util/vs/base/common/observableInternal/observables/observableValue.ts
function observableValue(nameOrOwner, initialValue, debugLocation = DebugLocation.ofCaller()) {
  let debugNameData;
  if (typeof nameOrOwner === "string") {
    debugNameData = new DebugNameData(void 0, nameOrOwner, void 0);
  } else {
    debugNameData = new DebugNameData(nameOrOwner, void 0, void 0);
  }
  return new ObservableValue(debugNameData, initialValue, strictEquals, debugLocation);
}
var ObservableValue = class extends BaseObservable {
  constructor(_debugNameData, initialValue, _equalityComparator, debugLocation) {
    super(debugLocation);
    this._debugNameData = _debugNameData;
    this._equalityComparator = _equalityComparator;
    this._value = initialValue;
    getLogger()?.handleObservableUpdated(this, { hadValue: false, newValue: initialValue, change: void 0, didChange: true, oldValue: void 0 });
  }
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "ObservableValue";
  }
  get() {
    return this._value;
  }
  set(value, tx, change) {
    if (change === void 0 && this._equalityComparator(this._value, value)) {
      return;
    }
    let _tx;
    if (!tx) {
      tx = _tx = new TransactionImpl(() => {
      }, () => `Setting ${this.debugName}`);
    }
    try {
      const oldValue = this._value;
      this._setValue(value);
      getLogger()?.handleObservableUpdated(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });
      for (const observer of this._observers) {
        tx.updateObserver(observer, this);
        observer.handleChange(this, change);
      }
    } finally {
      if (_tx) {
        _tx.finish();
      }
    }
  }
  toString() {
    return `${this.debugName}: ${this._value}`;
  }
  _setValue(newValue) {
    this._value = newValue;
  }
  debugGetState() {
    return {
      value: this._value
    };
  }
  debugSetValue(value) {
    this._value = value;
  }
};

// src/util/vs/base/common/observableInternal/reactions/autorunImpl.ts
function autorunStateToString(state) {
  switch (state) {
    case 1 /* dependenciesMightHaveChanged */:
      return "dependenciesMightHaveChanged";
    case 2 /* stale */:
      return "stale";
    case 3 /* upToDate */:
      return "upToDate";
    default:
      return "<unknown>";
  }
}
var AutorunObserver = class {
  constructor(_debugNameData, _runFn, _changeTracker, debugLocation) {
    this._debugNameData = _debugNameData;
    this._runFn = _runFn;
    this._changeTracker = _changeTracker;
    this._state = 2 /* stale */;
    this._updateCount = 0;
    this._disposed = false;
    this._dependencies = /* @__PURE__ */ new Set();
    this._dependenciesToBeRemoved = /* @__PURE__ */ new Set();
    this._isRunning = false;
    this._store = void 0;
    this._delayedStore = void 0;
    this._changeSummary = this._changeTracker?.createChangeSummary(void 0);
    getLogger()?.handleAutorunCreated(this, debugLocation);
    this._run();
    trackDisposable(this);
  }
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  dispose() {
    if (this._disposed) {
      return;
    }
    this._disposed = true;
    for (const o of this._dependencies) {
      o.removeObserver(this);
    }
    this._dependencies.clear();
    if (this._store !== void 0) {
      this._store.dispose();
    }
    if (this._delayedStore !== void 0) {
      this._delayedStore.dispose();
    }
    getLogger()?.handleAutorunDisposed(this);
    markAsDisposed(this);
  }
  _run() {
    const emptySet = this._dependenciesToBeRemoved;
    this._dependenciesToBeRemoved = this._dependencies;
    this._dependencies = emptySet;
    this._state = 3 /* upToDate */;
    try {
      if (!this._disposed) {
        getLogger()?.handleAutorunStarted(this);
        const changeSummary = this._changeSummary;
        const delayedStore = this._delayedStore;
        if (delayedStore !== void 0) {
          this._delayedStore = void 0;
        }
        try {
          this._isRunning = true;
          if (this._changeTracker) {
            this._changeTracker.beforeUpdate?.(this, changeSummary);
            this._changeSummary = this._changeTracker.createChangeSummary(changeSummary);
          }
          if (this._store !== void 0) {
            this._store.dispose();
            this._store = void 0;
          }
          this._runFn(this, changeSummary);
        } catch (e) {
          onBugIndicatingError(e);
        } finally {
          this._isRunning = false;
          if (delayedStore !== void 0) {
            delayedStore.dispose();
          }
        }
      }
    } finally {
      if (!this._disposed) {
        getLogger()?.handleAutorunFinished(this);
      }
      for (const o of this._dependenciesToBeRemoved) {
        o.removeObserver(this);
      }
      this._dependenciesToBeRemoved.clear();
    }
  }
  toString() {
    return `Autorun<${this.debugName}>`;
  }
  // IObserver implementation
  beginUpdate(_observable) {
    if (this._state === 3 /* upToDate */) {
      this._state = 1 /* dependenciesMightHaveChanged */;
    }
    this._updateCount++;
  }
  endUpdate(_observable) {
    try {
      if (this._updateCount === 1) {
        do {
          if (this._state === 1 /* dependenciesMightHaveChanged */) {
            this._state = 3 /* upToDate */;
            for (const d of this._dependencies) {
              d.reportChanges();
              if (this._state === 2 /* stale */) {
                break;
              }
            }
          }
          if (this._state !== 3 /* upToDate */) {
            this._run();
          }
        } while (this._state !== 3 /* upToDate */);
      }
    } finally {
      this._updateCount--;
    }
    assertFn(() => this._updateCount >= 0);
  }
  handlePossibleChange(observable) {
    if (this._state === 3 /* upToDate */ && this._isDependency(observable)) {
      this._state = 1 /* dependenciesMightHaveChanged */;
    }
  }
  handleChange(observable, change) {
    if (this._isDependency(observable)) {
      getLogger()?.handleAutorunDependencyChanged(this, observable, change);
      try {
        const shouldReact = this._changeTracker ? this._changeTracker.handleChange({
          changedObservable: observable,
          change,
          // eslint-disable-next-line local/code-no-any-casts
          didChange: (o) => o === observable
        }, this._changeSummary) : true;
        if (shouldReact) {
          this._state = 2 /* stale */;
        }
      } catch (e) {
        onBugIndicatingError(e);
      }
    }
  }
  _isDependency(observable) {
    return this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable);
  }
  // IReader implementation
  _ensureNoRunning() {
    if (!this._isRunning) {
      throw new BugIndicatingError("The reader object cannot be used outside its compute function!");
    }
  }
  readObservable(observable) {
    this._ensureNoRunning();
    if (this._disposed) {
      return observable.get();
    }
    observable.addObserver(this);
    const value = observable.get();
    this._dependencies.add(observable);
    this._dependenciesToBeRemoved.delete(observable);
    return value;
  }
  get store() {
    this._ensureNoRunning();
    if (this._disposed) {
      throw new BugIndicatingError("Cannot access store after dispose");
    }
    if (this._store === void 0) {
      this._store = new DisposableStore();
    }
    return this._store;
  }
  get delayedStore() {
    this._ensureNoRunning();
    if (this._disposed) {
      throw new BugIndicatingError("Cannot access store after dispose");
    }
    if (this._delayedStore === void 0) {
      this._delayedStore = new DisposableStore();
    }
    return this._delayedStore;
  }
  debugGetState() {
    return {
      isRunning: this._isRunning,
      updateCount: this._updateCount,
      dependencies: this._dependencies,
      state: this._state,
      stateStr: autorunStateToString(this._state)
    };
  }
  debugRerun() {
    if (!this._isRunning) {
      this._run();
    } else {
      this._state = 2 /* stale */;
    }
  }
};

// src/util/vs/base/common/observableInternal/reactions/autorun.ts
function autorun(fn, debugLocation = DebugLocation.ofCaller()) {
  return new AutorunObserver(
    new DebugNameData(void 0, void 0, fn),
    fn,
    void 0,
    debugLocation
  );
}

// src/util/vs/base/common/observableInternal/observables/derivedImpl.ts
function derivedStateToString(state) {
  switch (state) {
    case 0 /* initial */:
      return "initial";
    case 1 /* dependenciesMightHaveChanged */:
      return "dependenciesMightHaveChanged";
    case 2 /* stale */:
      return "stale";
    case 3 /* upToDate */:
      return "upToDate";
    default:
      return "<unknown>";
  }
}
var Derived = class extends BaseObservable {
  constructor(_debugNameData, _computeFn, _changeTracker, _handleLastObserverRemoved = void 0, _equalityComparator, debugLocation) {
    super(debugLocation);
    this._debugNameData = _debugNameData;
    this._computeFn = _computeFn;
    this._changeTracker = _changeTracker;
    this._handleLastObserverRemoved = _handleLastObserverRemoved;
    this._equalityComparator = _equalityComparator;
    this._state = 0 /* initial */;
    this._value = void 0;
    this._updateCount = 0;
    this._dependencies = /* @__PURE__ */ new Set();
    this._dependenciesToBeRemoved = /* @__PURE__ */ new Set();
    this._changeSummary = void 0;
    this._isUpdating = false;
    this._isComputing = false;
    this._didReportChange = false;
    this._isInBeforeUpdate = false;
    this._isReaderValid = false;
    this._store = void 0;
    this._delayedStore = void 0;
    this._removedObserverToCallEndUpdateOn = null;
    this._changeSummary = this._changeTracker?.createChangeSummary(void 0);
  }
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  onLastObserverRemoved() {
    this._state = 0 /* initial */;
    this._value = void 0;
    getLogger()?.handleDerivedCleared(this);
    for (const d of this._dependencies) {
      d.removeObserver(this);
    }
    this._dependencies.clear();
    if (this._store !== void 0) {
      this._store.dispose();
      this._store = void 0;
    }
    if (this._delayedStore !== void 0) {
      this._delayedStore.dispose();
      this._delayedStore = void 0;
    }
    this._handleLastObserverRemoved?.();
  }
  get() {
    const checkEnabled = false;
    if (this._isComputing && checkEnabled) {
      throw new BugIndicatingError("Cyclic deriveds are not supported yet!");
    }
    if (this._observers.size === 0) {
      let result;
      try {
        this._isReaderValid = true;
        let changeSummary = void 0;
        if (this._changeTracker) {
          changeSummary = this._changeTracker.createChangeSummary(void 0);
          this._changeTracker.beforeUpdate?.(this, changeSummary);
        }
        result = this._computeFn(this, changeSummary);
      } finally {
        this._isReaderValid = false;
      }
      this.onLastObserverRemoved();
      return result;
    } else {
      do {
        if (this._state === 1 /* dependenciesMightHaveChanged */) {
          for (const d of this._dependencies) {
            d.reportChanges();
            if (this._state === 2 /* stale */) {
              break;
            }
          }
        }
        if (this._state === 1 /* dependenciesMightHaveChanged */) {
          this._state = 3 /* upToDate */;
        }
        if (this._state !== 3 /* upToDate */) {
          this._recompute();
        }
      } while (this._state !== 3 /* upToDate */);
      return this._value;
    }
  }
  _recompute() {
    let didChange = false;
    this._isComputing = true;
    this._didReportChange = false;
    const emptySet = this._dependenciesToBeRemoved;
    this._dependenciesToBeRemoved = this._dependencies;
    this._dependencies = emptySet;
    try {
      const changeSummary = this._changeSummary;
      this._isReaderValid = true;
      if (this._changeTracker) {
        this._isInBeforeUpdate = true;
        this._changeTracker.beforeUpdate?.(this, changeSummary);
        this._isInBeforeUpdate = false;
        this._changeSummary = this._changeTracker?.createChangeSummary(changeSummary);
      }
      const hadValue = this._state !== 0 /* initial */;
      const oldValue = this._value;
      this._state = 3 /* upToDate */;
      const delayedStore = this._delayedStore;
      if (delayedStore !== void 0) {
        this._delayedStore = void 0;
      }
      try {
        if (this._store !== void 0) {
          this._store.dispose();
          this._store = void 0;
        }
        this._value = this._computeFn(this, changeSummary);
      } finally {
        this._isReaderValid = false;
        for (const o of this._dependenciesToBeRemoved) {
          o.removeObserver(this);
        }
        this._dependenciesToBeRemoved.clear();
        if (delayedStore !== void 0) {
          delayedStore.dispose();
        }
      }
      didChange = this._didReportChange || hadValue && !this._equalityComparator(oldValue, this._value);
      getLogger()?.handleObservableUpdated(this, {
        oldValue,
        newValue: this._value,
        change: void 0,
        didChange,
        hadValue
      });
    } catch (e) {
      onBugIndicatingError(e);
    }
    this._isComputing = false;
    if (!this._didReportChange && didChange) {
      for (const r of this._observers) {
        r.handleChange(this, void 0);
      }
    } else {
      this._didReportChange = false;
    }
  }
  toString() {
    return `LazyDerived<${this.debugName}>`;
  }
  // IObserver Implementation
  beginUpdate(_observable) {
    if (this._isUpdating) {
      throw new BugIndicatingError("Cyclic deriveds are not supported yet!");
    }
    this._updateCount++;
    this._isUpdating = true;
    try {
      const propagateBeginUpdate = this._updateCount === 1;
      if (this._state === 3 /* upToDate */) {
        this._state = 1 /* dependenciesMightHaveChanged */;
        if (!propagateBeginUpdate) {
          for (const r of this._observers) {
            r.handlePossibleChange(this);
          }
        }
      }
      if (propagateBeginUpdate) {
        for (const r of this._observers) {
          r.beginUpdate(this);
        }
      }
    } finally {
      this._isUpdating = false;
    }
  }
  endUpdate(_observable) {
    this._updateCount--;
    if (this._updateCount === 0) {
      const observers = [...this._observers];
      for (const r of observers) {
        r.endUpdate(this);
      }
      if (this._removedObserverToCallEndUpdateOn) {
        const observers2 = [...this._removedObserverToCallEndUpdateOn];
        this._removedObserverToCallEndUpdateOn = null;
        for (const r of observers2) {
          r.endUpdate(this);
        }
      }
    }
    assertFn(() => this._updateCount >= 0);
  }
  handlePossibleChange(observable) {
    if (this._state === 3 /* upToDate */ && this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable)) {
      this._state = 1 /* dependenciesMightHaveChanged */;
      for (const r of this._observers) {
        r.handlePossibleChange(this);
      }
    }
  }
  handleChange(observable, change) {
    if (this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable) || this._isInBeforeUpdate) {
      getLogger()?.handleDerivedDependencyChanged(this, observable, change);
      let shouldReact = false;
      try {
        shouldReact = this._changeTracker ? this._changeTracker.handleChange({
          changedObservable: observable,
          change,
          // eslint-disable-next-line local/code-no-any-casts
          didChange: (o) => o === observable
        }, this._changeSummary) : true;
      } catch (e) {
        onBugIndicatingError(e);
      }
      const wasUpToDate = this._state === 3 /* upToDate */;
      if (shouldReact && (this._state === 1 /* dependenciesMightHaveChanged */ || wasUpToDate)) {
        this._state = 2 /* stale */;
        if (wasUpToDate) {
          for (const r of this._observers) {
            r.handlePossibleChange(this);
          }
        }
      }
    }
  }
  // IReader Implementation
  _ensureReaderValid() {
    if (!this._isReaderValid) {
      throw new BugIndicatingError("The reader object cannot be used outside its compute function!");
    }
  }
  readObservable(observable) {
    this._ensureReaderValid();
    observable.addObserver(this);
    const value = observable.get();
    this._dependencies.add(observable);
    this._dependenciesToBeRemoved.delete(observable);
    return value;
  }
  reportChange(change) {
    this._ensureReaderValid();
    this._didReportChange = true;
    for (const r of this._observers) {
      r.handleChange(this, change);
    }
  }
  get store() {
    this._ensureReaderValid();
    if (this._store === void 0) {
      this._store = new DisposableStore();
    }
    return this._store;
  }
  get delayedStore() {
    this._ensureReaderValid();
    if (this._delayedStore === void 0) {
      this._delayedStore = new DisposableStore();
    }
    return this._delayedStore;
  }
  addObserver(observer) {
    const shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCount > 0;
    super.addObserver(observer);
    if (shouldCallBeginUpdate) {
      if (this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(observer)) {
        this._removedObserverToCallEndUpdateOn.delete(observer);
      } else {
        observer.beginUpdate(this);
      }
    }
  }
  removeObserver(observer) {
    if (this._observers.has(observer) && this._updateCount > 0) {
      if (!this._removedObserverToCallEndUpdateOn) {
        this._removedObserverToCallEndUpdateOn = /* @__PURE__ */ new Set();
      }
      this._removedObserverToCallEndUpdateOn.add(observer);
    }
    super.removeObserver(observer);
  }
  debugGetState() {
    return {
      state: this._state,
      stateStr: derivedStateToString(this._state),
      updateCount: this._updateCount,
      isComputing: this._isComputing,
      dependencies: this._dependencies,
      value: this._value
    };
  }
  debugSetValue(newValue) {
    this._value = newValue;
  }
  debugRecompute() {
    if (!this._isComputing) {
      this._recompute();
    } else {
      this._state = 2 /* stale */;
    }
  }
  setValue(newValue, tx, change) {
    this._value = newValue;
    const observers = this._observers;
    tx.updateObserver(this, this);
    for (const d of observers) {
      d.handleChange(this, change);
    }
  }
};

// src/util/vs/base/common/observableInternal/observables/derived.ts
function derived(computeFnOrOwner, computeFn, debugLocation = DebugLocation.ofCaller()) {
  if (computeFn !== void 0) {
    return new Derived(
      new DebugNameData(computeFnOrOwner, void 0, computeFn),
      computeFn,
      void 0,
      void 0,
      strictEquals,
      debugLocation
    );
  }
  return new Derived(
    // eslint-disable-next-line local/code-no-any-casts
    new DebugNameData(void 0, void 0, computeFnOrOwner),
    // eslint-disable-next-line local/code-no-any-casts
    computeFnOrOwner,
    void 0,
    void 0,
    strictEquals,
    debugLocation
  );
}
function derivedOpts(options, computeFn, debugLocation = DebugLocation.ofCaller()) {
  return new Derived(
    new DebugNameData(options.owner, options.debugName, options.debugReferenceFn),
    computeFn,
    void 0,
    options.onLastObserverRemoved,
    options.equalsFn ?? strictEquals,
    debugLocation
  );
}
_setDerivedOpts(derivedOpts);

// src/util/vs/base/common/observableInternal/commonFacade/cancellation.ts
init_errors();
init_cancellation();

// src/util/vs/base/common/observableInternal/utils/utilsCancellation.ts
function waitForState(observable, predicate, isError, cancellationToken) {
  if (!predicate) {
    predicate = (state) => state !== null && state !== void 0;
  }
  return new Promise((resolve2, reject) => {
    let isImmediateRun = true;
    let shouldDispose = false;
    const stateObs = observable.map((state) => {
      return {
        isFinished: predicate(state),
        error: isError ? isError(state) : false,
        state
      };
    });
    const d = autorun((reader) => {
      const { isFinished, error: error2, state } = stateObs.read(reader);
      if (isFinished || error2) {
        if (isImmediateRun) {
          shouldDispose = true;
        } else {
          d.dispose();
        }
        if (error2) {
          reject(error2 === true ? state : error2);
        } else {
          resolve2(state);
        }
      }
    });
    if (cancellationToken) {
      const dc = cancellationToken.onCancellationRequested(() => {
        d.dispose();
        dc.dispose();
        reject(new CancellationError());
      });
      if (cancellationToken.isCancellationRequested) {
        d.dispose();
        dc.dispose();
        reject(new CancellationError());
        return;
      }
    }
    isImmediateRun = false;
    if (shouldDispose) {
      d.dispose();
    }
  });
}

// src/util/vs/base/common/observableInternal/observables/observableFromEvent.ts
function observableFromEvent(...args) {
  let owner;
  let event;
  let getValue;
  let debugLocation;
  if (args.length === 2) {
    [event, getValue] = args;
  } else {
    [owner, event, getValue, debugLocation] = args;
  }
  return new FromEventObservable(
    new DebugNameData(owner, void 0, getValue),
    event,
    getValue,
    () => FromEventObservable.globalTransaction,
    strictEquals,
    debugLocation ?? DebugLocation.ofCaller()
  );
}
function observableFromEventOpts(options, event, getValue, debugLocation = DebugLocation.ofCaller()) {
  return new FromEventObservable(
    new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue),
    event,
    getValue,
    () => FromEventObservable.globalTransaction,
    options.equalsFn ?? strictEquals,
    debugLocation
  );
}
var FromEventObservable = class extends BaseObservable {
  constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator, debugLocation) {
    super(debugLocation);
    this._debugNameData = _debugNameData;
    this.event = event;
    this._getValue = _getValue;
    this._getTransaction = _getTransaction;
    this._equalityComparator = _equalityComparator;
    this._hasValue = false;
    this.handleEvent = (args) => {
      const newValue = this._getValue(args);
      const oldValue = this._value;
      const didChange = !this._hasValue || !this._equalityComparator(oldValue, newValue);
      let didRunTransaction = false;
      if (didChange) {
        this._value = newValue;
        if (this._hasValue) {
          didRunTransaction = true;
          subtransaction(
            this._getTransaction(),
            (tx) => {
              getLogger()?.handleObservableUpdated(this, { oldValue, newValue, change: void 0, didChange, hadValue: this._hasValue });
              for (const o of this._observers) {
                tx.updateObserver(o, this);
                o.handleChange(this, void 0);
              }
            },
            () => {
              const name = this.getDebugName();
              return "Event fired" + (name ? `: ${name}` : "");
            }
          );
        }
        this._hasValue = true;
      }
      if (!didRunTransaction) {
        getLogger()?.handleObservableUpdated(this, { oldValue, newValue, change: void 0, didChange, hadValue: this._hasValue });
      }
    };
  }
  getDebugName() {
    return this._debugNameData.getDebugName(this);
  }
  get debugName() {
    const name = this.getDebugName();
    return "From Event" + (name ? `: ${name}` : "");
  }
  onFirstObserverAdded() {
    this._subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this._subscription.dispose();
    this._subscription = void 0;
    this._hasValue = false;
    this._value = void 0;
  }
  get() {
    if (this._subscription) {
      if (!this._hasValue) {
        this.handleEvent(void 0);
      }
      return this._value;
    } else {
      const value = this._getValue(void 0);
      return value;
    }
  }
  debugSetValue(value) {
    this._value = value;
  }
  debugGetState() {
    return { value: this._value, hasValue: this._hasValue };
  }
};
((observableFromEvent2) => {
  observableFromEvent2.Observer = FromEventObservable;
  function batchEventsGlobally(tx, fn) {
    let didSet = false;
    if (FromEventObservable.globalTransaction === void 0) {
      FromEventObservable.globalTransaction = tx;
      didSet = true;
    }
    try {
      fn();
    } finally {
      if (didSet) {
        FromEventObservable.globalTransaction = void 0;
      }
    }
  }
  observableFromEvent2.batchEventsGlobally = batchEventsGlobally;
})(observableFromEvent || (observableFromEvent = {}));

// src/util/vs/base/common/observableInternal/utils/utils.ts
function keepObserved(observable) {
  const o = new KeepAliveObserver(false, void 0);
  observable.addObserver(o);
  return toDisposable(() => {
    observable.removeObserver(o);
  });
}
_setKeepObserved(keepObserved);
function recomputeInitiallyAndOnChange(observable, handleValue) {
  const o = new KeepAliveObserver(true, handleValue);
  observable.addObserver(o);
  try {
    o.beginUpdate(observable);
  } finally {
    o.endUpdate(observable);
  }
  return toDisposable(() => {
    observable.removeObserver(o);
  });
}
_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);
var KeepAliveObserver = class {
  constructor(_forceRecompute, _handleValue) {
    this._forceRecompute = _forceRecompute;
    this._handleValue = _handleValue;
    this._counter = 0;
  }
  beginUpdate(observable) {
    this._counter++;
  }
  endUpdate(observable) {
    if (this._counter === 1 && this._forceRecompute) {
      if (this._handleValue) {
        this._handleValue(observable.get());
      } else {
        observable.reportChanges();
      }
    }
    this._counter--;
  }
  handlePossibleChange(observable) {
  }
  handleChange(observable, change) {
  }
};

// src/util/vs/base/common/observableInternal/observables/observableSignalFromEvent.ts
function observableSignalFromEvent(owner, event, debugLocation = DebugLocation.ofCaller()) {
  return new FromEventObservableSignal(typeof owner === "string" ? owner : new DebugNameData(owner, void 0, void 0), event, debugLocation);
}
var FromEventObservableSignal = class extends BaseObservable {
  constructor(debugNameDataOrName, event, debugLocation) {
    super(debugLocation);
    this.event = event;
    this.handleEvent = () => {
      transaction(
        (tx) => {
          for (const o of this._observers) {
            tx.updateObserver(o, this);
            o.handleChange(this, void 0);
          }
        },
        () => this.debugName
      );
    };
    this.debugName = typeof debugNameDataOrName === "string" ? debugNameDataOrName : debugNameDataOrName.getDebugName(this) ?? "Observable Signal From Event";
  }
  onFirstObserverAdded() {
    this.subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this.subscription.dispose();
    this.subscription = void 0;
  }
  get() {
  }
};

// src/util/vs/base/common/observableInternal/logging/consoleObservableLogger.ts
var consoleObservableLogger;
function logObservableToConsole(obs) {
  if (!consoleObservableLogger) {
    consoleObservableLogger = new ConsoleObservableLogger();
    addLogger(consoleObservableLogger);
  }
  consoleObservableLogger.addFilteredObj(obs);
}
var ConsoleObservableLogger = class {
  constructor() {
    this.indentation = 0;
    this.changedObservablesSets = /* @__PURE__ */ new WeakMap();
  }
  addFilteredObj(obj) {
    if (!this._filteredObjects) {
      this._filteredObjects = /* @__PURE__ */ new Set();
    }
    this._filteredObjects.add(obj);
  }
  _isIncluded(obj) {
    return this._filteredObjects?.has(obj) ?? true;
  }
  textToConsoleArgs(text2) {
    return consoleTextToArgs([
      normalText(repeat("|  ", this.indentation)),
      text2
    ]);
  }
  formatInfo(info) {
    if (!info.hadValue) {
      return [
        normalText(` `),
        styled(formatValue(info.newValue, 60), {
          color: "green"
        }),
        normalText(` (initial)`)
      ];
    }
    return info.didChange ? [
      normalText(` `),
      styled(formatValue(info.oldValue, 70), {
        color: "red",
        strikeThrough: true
      }),
      normalText(` `),
      styled(formatValue(info.newValue, 60), {
        color: "green"
      })
    ] : [normalText(` (unchanged)`)];
  }
  handleObservableCreated(observable) {
    if (observable instanceof Derived) {
      const derived2 = observable;
      this.changedObservablesSets.set(derived2, /* @__PURE__ */ new Set());
      const debugTrackUpdating = false;
      if (debugTrackUpdating) {
        const updating = [];
        derived2.__debugUpdating = updating;
        const existingBeginUpdate = derived2.beginUpdate;
        derived2.beginUpdate = (obs) => {
          updating.push(obs);
          return existingBeginUpdate.apply(derived2, [obs]);
        };
        const existingEndUpdate = derived2.endUpdate;
        derived2.endUpdate = (obs) => {
          const idx = updating.indexOf(obs);
          if (idx === -1) {
            console.error("endUpdate called without beginUpdate", derived2.debugName, obs.debugName);
          }
          updating.splice(idx, 1);
          return existingEndUpdate.apply(derived2, [obs]);
        };
      }
    }
  }
  handleOnListenerCountChanged(observable, newCount) {
  }
  handleObservableUpdated(observable, info) {
    if (!this._isIncluded(observable)) {
      return;
    }
    if (observable instanceof Derived) {
      this._handleDerivedRecomputed(observable, info);
      return;
    }
    console.log(...this.textToConsoleArgs([
      formatKind("observable value changed"),
      styled(observable.debugName, { color: "BlueViolet" }),
      ...this.formatInfo(info)
    ]));
  }
  formatChanges(changes) {
    if (changes.size === 0) {
      return void 0;
    }
    return styled(
      " (changed deps: " + [...changes].map((o) => o.debugName).join(", ") + ")",
      { color: "gray" }
    );
  }
  handleDerivedDependencyChanged(derived2, observable, change) {
    if (!this._isIncluded(derived2)) {
      return;
    }
    this.changedObservablesSets.get(derived2)?.add(observable);
  }
  _handleDerivedRecomputed(derived2, info) {
    if (!this._isIncluded(derived2)) {
      return;
    }
    const changedObservables = this.changedObservablesSets.get(derived2);
    if (!changedObservables) {
      return;
    }
    console.log(...this.textToConsoleArgs([
      formatKind("derived recomputed"),
      styled(derived2.debugName, { color: "BlueViolet" }),
      ...this.formatInfo(info),
      this.formatChanges(changedObservables),
      { data: [{ fn: derived2._debugNameData.referenceFn ?? derived2._computeFn }] }
    ]));
    changedObservables.clear();
  }
  handleDerivedCleared(derived2) {
    if (!this._isIncluded(derived2)) {
      return;
    }
    console.log(...this.textToConsoleArgs([
      formatKind("derived cleared"),
      styled(derived2.debugName, { color: "BlueViolet" })
    ]));
  }
  handleFromEventObservableTriggered(observable, info) {
    if (!this._isIncluded(observable)) {
      return;
    }
    console.log(...this.textToConsoleArgs([
      formatKind("observable from event triggered"),
      styled(observable.debugName, { color: "BlueViolet" }),
      ...this.formatInfo(info),
      { data: [{ fn: observable._getValue }] }
    ]));
  }
  handleAutorunCreated(autorun2) {
    if (!this._isIncluded(autorun2)) {
      return;
    }
    this.changedObservablesSets.set(autorun2, /* @__PURE__ */ new Set());
  }
  handleAutorunDisposed(autorun2) {
  }
  handleAutorunDependencyChanged(autorun2, observable, change) {
    if (!this._isIncluded(autorun2)) {
      return;
    }
    this.changedObservablesSets.get(autorun2).add(observable);
  }
  handleAutorunStarted(autorun2) {
    const changedObservables = this.changedObservablesSets.get(autorun2);
    if (!changedObservables) {
      return;
    }
    if (this._isIncluded(autorun2)) {
      console.log(...this.textToConsoleArgs([
        formatKind("autorun"),
        styled(autorun2.debugName, { color: "BlueViolet" }),
        this.formatChanges(changedObservables),
        { data: [{ fn: autorun2._debugNameData.referenceFn ?? autorun2._runFn }] }
      ]));
    }
    changedObservables.clear();
    this.indentation++;
  }
  handleAutorunFinished(autorun2) {
    this.indentation--;
  }
  handleBeginTransaction(transaction2) {
    let transactionName = transaction2.getDebugName();
    if (transactionName === void 0) {
      transactionName = "";
    }
    if (this._isIncluded(transaction2)) {
      console.log(...this.textToConsoleArgs([
        formatKind("transaction"),
        styled(transactionName, { color: "BlueViolet" }),
        { data: [{ fn: transaction2._fn }] }
      ]));
    }
    this.indentation++;
  }
  handleEndTransaction() {
    this.indentation--;
  }
};
function consoleTextToArgs(text2) {
  const styles = new Array();
  const data = [];
  let firstArg = "";
  function process2(t2) {
    if ("length" in t2) {
      for (const item of t2) {
        if (item) {
          process2(item);
        }
      }
    } else if ("text" in t2) {
      firstArg += `%c${t2.text}`;
      styles.push(t2.style);
      if (t2.data) {
        data.push(...t2.data);
      }
    } else if ("data" in t2) {
      data.push(...t2.data);
    }
  }
  process2(text2);
  const result = [firstArg, ...styles];
  result.push(...data);
  return result;
}
function normalText(text2) {
  return styled(text2, { color: "black" });
}
function formatKind(kind) {
  return styled(padStr(`${kind}: `, 10), { color: "black", bold: true });
}
function styled(text2, options = {
  color: "black"
}) {
  function objToCss(styleObj) {
    return Object.entries(styleObj).reduce(
      (styleString, [propName, propValue]) => {
        return `${styleString}${propName}:${propValue};`;
      },
      ""
    );
  }
  const style = {
    color: options.color
  };
  if (options.strikeThrough) {
    style["text-decoration"] = "line-through";
  }
  if (options.bold) {
    style["font-weight"] = "bold";
  }
  return {
    text: text2,
    style: objToCss(style)
  };
}
function formatValue(value, availableLen) {
  switch (typeof value) {
    case "number":
      return "" + value;
    case "string":
      if (value.length + 2 <= availableLen) {
        return `"${value}"`;
      }
      return `"${value.substr(0, availableLen - 7)}"+...`;
    case "boolean":
      return value ? "true" : "false";
    case "undefined":
      return "undefined";
    case "object":
      if (value === null) {
        return "null";
      }
      if (Array.isArray(value)) {
        return formatArray(value, availableLen);
      }
      return formatObject(value, availableLen);
    case "symbol":
      return value.toString();
    case "function":
      return `[[Function${value.name ? " " + value.name : ""}]]`;
    default:
      return "" + value;
  }
}
function formatArray(value, availableLen) {
  let result = "[ ";
  let first = true;
  for (const val of value) {
    if (!first) {
      result += ", ";
    }
    if (result.length - 5 > availableLen) {
      result += "...";
      break;
    }
    first = false;
    result += `${formatValue(val, availableLen - result.length)}`;
  }
  result += " ]";
  return result;
}
function formatObject(value, availableLen) {
  if (typeof value.toString === "function" && value.toString !== Object.prototype.toString) {
    const val = value.toString();
    if (val.length <= availableLen) {
      return val;
    }
    return val.substring(0, availableLen - 3) + "...";
  }
  const className = getClassName(value);
  let result = className ? className + "(" : "{ ";
  let first = true;
  for (const [key, val] of Object.entries(value)) {
    if (!first) {
      result += ", ";
    }
    if (result.length - 5 > availableLen) {
      result += "...";
      break;
    }
    first = false;
    result += `${key}: ${formatValue(val, availableLen - result.length)}`;
  }
  result += className ? ")" : " }";
  return result;
}
function repeat(str, count2) {
  let result = "";
  for (let i = 1; i <= count2; i++) {
    result += str;
  }
  return result;
}
function padStr(str, length) {
  while (str.length < length) {
    str += " ";
  }
  return str;
}

// src/util/vs/base/common/observableInternal/logging/debugger/rpc.ts
var SimpleTypedRpcConnection = class _SimpleTypedRpcConnection {
  constructor(_channelFactory, _getHandler) {
    this._channelFactory = _channelFactory;
    this._getHandler = _getHandler;
    this._channel = this._channelFactory({
      handleNotification: (notificationData) => {
        const m = notificationData;
        const fn = this._getHandler().notifications[m[0]];
        if (!fn) {
          throw new Error(`Unknown notification "${m[0]}"!`);
        }
        fn(...m[1]);
      },
      handleRequest: (requestData) => {
        const m = requestData;
        try {
          const result = this._getHandler().requests[m[0]](...m[1]);
          return { type: "result", value: result };
        } catch (e) {
          return { type: "error", value: e };
        }
      }
    });
    const requests = new Proxy({}, {
      get: (target, key) => {
        return async (...args) => {
          const result = await this._channel.sendRequest([key, args]);
          if (result.type === "error") {
            throw result.value;
          } else {
            return result.value;
          }
        };
      }
    });
    const notifications = new Proxy({}, {
      get: (target, key) => {
        return (...args) => {
          this._channel.sendNotification([key, args]);
        };
      }
    });
    this.api = { notifications, requests };
  }
  static createHost(channelFactory, getHandler) {
    return new _SimpleTypedRpcConnection(channelFactory, getHandler);
  }
  static createClient(channelFactory, getHandler) {
    return new _SimpleTypedRpcConnection(channelFactory, getHandler);
  }
};

// src/util/vs/base/common/observableInternal/logging/debugger/debuggerRpc.ts
function registerDebugChannel(channelId, createClient) {
  const g = globalThis;
  let queuedNotifications = [];
  let curHost = void 0;
  const { channel, handler } = createChannelFactoryFromDebugChannel({
    sendNotification: (data) => {
      if (curHost) {
        curHost.sendNotification(data);
      } else {
        queuedNotifications.push(data);
      }
    }
  });
  let curClient = void 0;
  (g.$$debugValueEditor_debugChannels ?? (g.$$debugValueEditor_debugChannels = {}))[channelId] = (host) => {
    curClient = createClient();
    curHost = host;
    for (const n of queuedNotifications) {
      host.sendNotification(n);
    }
    queuedNotifications = [];
    return handler;
  };
  return SimpleTypedRpcConnection.createClient(channel, () => {
    if (!curClient) {
      throw new Error("Not supported");
    }
    return curClient;
  });
}
function createChannelFactoryFromDebugChannel(host) {
  let h;
  const channel = (handler) => {
    h = handler;
    return {
      sendNotification: (data) => {
        host.sendNotification(data);
      },
      sendRequest: (data) => {
        throw new Error("not supported");
      }
    };
  };
  return {
    channel,
    handler: {
      handleRequest: (data) => {
        if (data.type === "notification") {
          return h?.handleNotification(data.data);
        } else {
          return h?.handleRequest(data.data);
        }
      }
    }
  };
}

// src/util/vs/base/common/observableInternal/logging/debugger/utils.ts
var Throttler = class {
  constructor() {
    this._timeout = void 0;
  }
  throttle(fn, timeoutMs) {
    if (this._timeout === void 0) {
      this._timeout = setTimeout(() => {
        this._timeout = void 0;
        fn();
      }, timeoutMs);
    }
  }
  dispose() {
    if (this._timeout !== void 0) {
      clearTimeout(this._timeout);
    }
  }
};
function deepAssign(target, source) {
  for (const key in source) {
    if (!!target[key] && typeof target[key] === "object" && !!source[key] && typeof source[key] === "object") {
      deepAssign(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
}
function deepAssignDeleteNulls(target, source) {
  for (const key in source) {
    if (source[key] === null) {
      delete target[key];
    } else if (!!target[key] && typeof target[key] === "object" && !!source[key] && typeof source[key] === "object") {
      deepAssignDeleteNulls(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
}

// src/util/vs/base/common/observableInternal/logging/debugger/devToolsLogger.ts
init_types();
init_errors();
var DevToolsLogger = class _DevToolsLogger {
  constructor() {
    this._declarationId = 0;
    this._instanceId = 0;
    this._declarations = /* @__PURE__ */ new Map();
    this._instanceInfos = /* @__PURE__ */ new WeakMap();
    this._aliveInstances = /* @__PURE__ */ new Map();
    this._activeTransactions = /* @__PURE__ */ new Set();
    this._channel = registerDebugChannel("observableDevTools", () => {
      return {
        notifications: {
          setDeclarationIdFilter: (declarationIds) => {
          },
          logObservableValue: (observableId) => {
            console.log("logObservableValue", observableId);
          },
          flushUpdates: () => {
            this._flushUpdates();
          },
          resetUpdates: () => {
            this._pendingChanges = null;
            this._channel.api.notifications.handleChange(this._fullState, true);
          }
        },
        requests: {
          getDeclarations: () => {
            const result = {};
            for (const decl of this._declarations.values()) {
              result[decl.id] = decl;
            }
            return { decls: result };
          },
          getSummarizedInstances: () => {
            return null;
          },
          getObservableValueInfo: (instanceId) => {
            const obs = this._aliveInstances.get(instanceId);
            return {
              observers: [...obs.debugGetObservers()].map((d) => this._formatObserver(d)).filter(isDefined)
            };
          },
          getDerivedInfo: (instanceId) => {
            const d = this._aliveInstances.get(instanceId);
            return {
              dependencies: [...d.debugGetState().dependencies].map((d2) => this._formatObservable(d2)).filter(isDefined),
              observers: [...d.debugGetObservers()].map((d2) => this._formatObserver(d2)).filter(isDefined)
            };
          },
          getAutorunInfo: (instanceId) => {
            const obs = this._aliveInstances.get(instanceId);
            return {
              dependencies: [...obs.debugGetState().dependencies].map((d) => this._formatObservable(d)).filter(isDefined)
            };
          },
          getTransactionState: () => {
            return this.getTransactionState();
          },
          setValue: (instanceId, jsonValue) => {
            const obs = this._aliveInstances.get(instanceId);
            if (obs instanceof Derived) {
              obs.debugSetValue(jsonValue);
            } else if (obs instanceof ObservableValue) {
              obs.debugSetValue(jsonValue);
            } else if (obs instanceof FromEventObservable) {
              obs.debugSetValue(jsonValue);
            } else {
              throw new BugIndicatingError("Observable is not supported");
            }
            const observers = [...obs.debugGetObservers()];
            for (const d of observers) {
              d.beginUpdate(obs);
            }
            for (const d of observers) {
              d.handleChange(obs, void 0);
            }
            for (const d of observers) {
              d.endUpdate(obs);
            }
          },
          getValue: (instanceId) => {
            const obs = this._aliveInstances.get(instanceId);
            if (obs instanceof Derived) {
              return formatValue(obs.debugGetState().value, 200);
            } else if (obs instanceof ObservableValue) {
              return formatValue(obs.debugGetState().value, 200);
            }
            return void 0;
          },
          logValue: (instanceId) => {
            const obs = this._aliveInstances.get(instanceId);
            if (obs && "get" in obs) {
              console.log("Logged Value:", obs.get());
            } else {
              throw new BugIndicatingError("Observable is not supported");
            }
          },
          rerun: (instanceId) => {
            const obs = this._aliveInstances.get(instanceId);
            if (obs instanceof Derived) {
              obs.debugRecompute();
            } else if (obs instanceof AutorunObserver) {
              obs.debugRerun();
            } else {
              throw new BugIndicatingError("Observable is not supported");
            }
          }
        }
      };
    });
    this._pendingChanges = null;
    this._changeThrottler = new Throttler();
    this._fullState = {};
    this._flushUpdates = () => {
      if (this._pendingChanges !== null) {
        this._channel.api.notifications.handleChange(this._pendingChanges, false);
        this._pendingChanges = null;
      }
    };
    DebugLocation.enable();
  }
  static {
    this._instance = void 0;
  }
  static getInstance() {
    if (_DevToolsLogger._instance === void 0) {
      _DevToolsLogger._instance = new _DevToolsLogger();
    }
    return _DevToolsLogger._instance;
  }
  getTransactionState() {
    const affected = [];
    const txs = [...this._activeTransactions];
    if (txs.length === 0) {
      return void 0;
    }
    const observerQueue = txs.flatMap((t2) => t2.debugGetUpdatingObservers() ?? []).map((o) => o.observer);
    const processedObservers = /* @__PURE__ */ new Set();
    while (observerQueue.length > 0) {
      const observer = observerQueue.shift();
      if (processedObservers.has(observer)) {
        continue;
      }
      processedObservers.add(observer);
      const state = this._getInfo(observer, (d) => {
        if (!processedObservers.has(d)) {
          observerQueue.push(d);
        }
      });
      if (state) {
        affected.push(state);
      }
    }
    return { names: txs.map((t2) => t2.getDebugName() ?? "tx"), affected };
  }
  _getObservableInfo(observable) {
    const info = this._instanceInfos.get(observable);
    if (!info) {
      onUnexpectedError(new BugIndicatingError("No info found"));
      return void 0;
    }
    return info;
  }
  _getAutorunInfo(autorun2) {
    const info = this._instanceInfos.get(autorun2);
    if (!info) {
      onUnexpectedError(new BugIndicatingError("No info found"));
      return void 0;
    }
    return info;
  }
  _getInfo(observer, queue) {
    if (observer instanceof Derived) {
      const observersToUpdate = [...observer.debugGetObservers()];
      for (const o of observersToUpdate) {
        queue(o);
      }
      const info = this._getObservableInfo(observer);
      if (!info) {
        return;
      }
      const observerState = observer.debugGetState();
      const base2 = { name: observer.debugName, instanceId: info.instanceId, updateCount: observerState.updateCount };
      const changedDependencies = [...info.changedObservables].map((o) => this._instanceInfos.get(o)?.instanceId).filter(isDefined);
      if (observerState.isComputing) {
        return { ...base2, type: "observable/derived", state: "updating", changedDependencies, initialComputation: false };
      }
      switch (observerState.state) {
        case 0 /* initial */:
          return { ...base2, type: "observable/derived", state: "noValue" };
        case 3 /* upToDate */:
          return { ...base2, type: "observable/derived", state: "upToDate" };
        case 2 /* stale */:
          return { ...base2, type: "observable/derived", state: "stale", changedDependencies };
        case 1 /* dependenciesMightHaveChanged */:
          return { ...base2, type: "observable/derived", state: "possiblyStale" };
      }
    } else if (observer instanceof AutorunObserver) {
      const info = this._getAutorunInfo(observer);
      if (!info) {
        return void 0;
      }
      const base2 = { name: observer.debugName, instanceId: info.instanceId, updateCount: info.updateCount };
      const changedDependencies = [...info.changedObservables].map((o) => this._instanceInfos.get(o).instanceId);
      if (observer.debugGetState().isRunning) {
        return { ...base2, type: "autorun", state: "updating", changedDependencies };
      }
      switch (observer.debugGetState().state) {
        case 3 /* upToDate */:
          return { ...base2, type: "autorun", state: "upToDate" };
        case 2 /* stale */:
          return { ...base2, type: "autorun", state: "stale", changedDependencies };
        case 1 /* dependenciesMightHaveChanged */:
          return { ...base2, type: "autorun", state: "possiblyStale" };
      }
    }
    return void 0;
  }
  _formatObservable(obs) {
    const info = this._getObservableInfo(obs);
    if (!info) {
      return void 0;
    }
    return { name: obs.debugName, instanceId: info.instanceId };
  }
  _formatObserver(obs) {
    if (obs instanceof Derived) {
      return { name: obs.toString(), instanceId: this._getObservableInfo(obs)?.instanceId };
    }
    const autorunInfo = this._getAutorunInfo(obs);
    if (autorunInfo) {
      return { name: obs.toString(), instanceId: autorunInfo.instanceId };
    }
    return void 0;
  }
  _handleChange(update) {
    deepAssignDeleteNulls(this._fullState, update);
    if (this._pendingChanges === null) {
      this._pendingChanges = update;
    } else {
      deepAssign(this._pendingChanges, update);
    }
    this._changeThrottler.throttle(this._flushUpdates, 10);
  }
  _getDeclarationId(type, location) {
    if (!location) {
      return -1;
    }
    let decInfo = this._declarations.get(location.id);
    if (decInfo === void 0) {
      decInfo = {
        id: this._declarationId++,
        type,
        url: location.fileName,
        line: location.line,
        column: location.column
      };
      this._declarations.set(location.id, decInfo);
      this._handleChange({ decls: { [decInfo.id]: decInfo } });
    }
    return decInfo.id;
  }
  handleObservableCreated(observable, location) {
    const declarationId = this._getDeclarationId("observable/value", location);
    const info = {
      declarationId,
      instanceId: this._instanceId++,
      listenerCount: 0,
      lastValue: void 0,
      updateCount: 0,
      changedObservables: /* @__PURE__ */ new Set()
    };
    this._instanceInfos.set(observable, info);
  }
  handleOnListenerCountChanged(observable, newCount) {
    const info = this._getObservableInfo(observable);
    if (!info) {
      return;
    }
    if (info.listenerCount === 0 && newCount > 0) {
      const type = observable instanceof Derived ? "observable/derived" : "observable/value";
      this._aliveInstances.set(info.instanceId, observable);
      this._handleChange({
        instances: {
          [info.instanceId]: {
            instanceId: info.instanceId,
            declarationId: info.declarationId,
            formattedValue: info.lastValue,
            type,
            name: observable.debugName
          }
        }
      });
    } else if (info.listenerCount > 0 && newCount === 0) {
      this._handleChange({
        instances: { [info.instanceId]: null }
      });
      this._aliveInstances.delete(info.instanceId);
    }
    info.listenerCount = newCount;
  }
  handleObservableUpdated(observable, changeInfo) {
    if (observable instanceof Derived) {
      this._handleDerivedRecomputed(observable, changeInfo);
      return;
    }
    const info = this._getObservableInfo(observable);
    if (info) {
      if (changeInfo.didChange) {
        info.lastValue = formatValue(changeInfo.newValue, 30);
        if (info.listenerCount > 0) {
          this._handleChange({
            instances: { [info.instanceId]: { formattedValue: info.lastValue } }
          });
        }
      }
    }
  }
  handleAutorunCreated(autorun2, location) {
    const declarationId = this._getDeclarationId("autorun", location);
    const info = {
      declarationId,
      instanceId: this._instanceId++,
      updateCount: 0,
      changedObservables: /* @__PURE__ */ new Set()
    };
    this._instanceInfos.set(autorun2, info);
    this._aliveInstances.set(info.instanceId, autorun2);
    if (info) {
      this._handleChange({
        instances: {
          [info.instanceId]: {
            instanceId: info.instanceId,
            declarationId: info.declarationId,
            runCount: 0,
            type: "autorun",
            name: autorun2.debugName
          }
        }
      });
    }
  }
  handleAutorunDisposed(autorun2) {
    const info = this._getAutorunInfo(autorun2);
    if (!info) {
      return;
    }
    this._handleChange({
      instances: { [info.instanceId]: null }
    });
    this._instanceInfos.delete(autorun2);
    this._aliveInstances.delete(info.instanceId);
  }
  handleAutorunDependencyChanged(autorun2, observable, change) {
    const info = this._getAutorunInfo(autorun2);
    if (!info) {
      return;
    }
    info.changedObservables.add(observable);
  }
  handleAutorunStarted(autorun2) {
  }
  handleAutorunFinished(autorun2) {
    const info = this._getAutorunInfo(autorun2);
    if (!info) {
      return;
    }
    info.changedObservables.clear();
    info.updateCount++;
    this._handleChange({
      instances: { [info.instanceId]: { runCount: info.updateCount } }
    });
  }
  handleDerivedDependencyChanged(derived2, observable, change) {
    const info = this._getObservableInfo(derived2);
    if (info) {
      info.changedObservables.add(observable);
    }
  }
  _handleDerivedRecomputed(observable, changeInfo) {
    const info = this._getObservableInfo(observable);
    if (!info) {
      return;
    }
    const formattedValue = formatValue(changeInfo.newValue, 30);
    info.updateCount++;
    info.changedObservables.clear();
    info.lastValue = formattedValue;
    if (info.listenerCount > 0) {
      this._handleChange({
        instances: { [info.instanceId]: { formattedValue, recomputationCount: info.updateCount } }
      });
    }
  }
  handleDerivedCleared(observable) {
    const info = this._getObservableInfo(observable);
    if (!info) {
      return;
    }
    info.lastValue = void 0;
    info.changedObservables.clear();
    if (info.listenerCount > 0) {
      this._handleChange({
        instances: {
          [info.instanceId]: {
            formattedValue: void 0
          }
        }
      });
    }
  }
  handleBeginTransaction(transaction2) {
    this._activeTransactions.add(transaction2);
  }
  handleEndTransaction(transaction2) {
    this._activeTransactions.delete(transaction2);
  }
};

// src/util/vs/base/common/observableInternal/logging/debugGetDependencyGraph.ts
function debugGetDependencyGraph(obs, options) {
  const debugNamePostProcessor = options?.debugNamePostProcessor ?? ((str) => str);
  const info = Info.from(obs, debugNamePostProcessor);
  if (!info) {
    return "";
  }
  const alreadyListed = /* @__PURE__ */ new Set();
  return formatObservableInfo(info, 0, alreadyListed).trim();
}
function formatObservableInfo(info, indentLevel, alreadyListed) {
  const indent = "		".repeat(indentLevel);
  const lines = [];
  const isAlreadyListed = alreadyListed.has(info.sourceObj);
  if (isAlreadyListed) {
    lines.push(`${indent}* ${info.type} ${info.name} (already listed)`);
    return lines.join("\n");
  }
  alreadyListed.add(info.sourceObj);
  lines.push(`${indent}* ${info.type} ${info.name}:`);
  lines.push(`${indent}  value: ${formatValue(info.value, 50)}`);
  lines.push(`${indent}  state: ${info.state}`);
  if (info.dependencies.length > 0) {
    lines.push(`${indent}  dependencies:`);
    for (const dep of info.dependencies) {
      lines.push(formatObservableInfo(dep, indentLevel + 1, alreadyListed));
    }
  }
  return lines.join("\n");
}
var Info = class _Info {
  constructor(sourceObj, name, type, value, state, dependencies) {
    this.sourceObj = sourceObj;
    this.name = name;
    this.type = type;
    this.value = value;
    this.state = state;
    this.dependencies = dependencies;
  }
  static from(obs, debugNamePostProcessor) {
    if (obs instanceof AutorunObserver) {
      const state = obs.debugGetState();
      return new _Info(
        obs,
        debugNamePostProcessor(obs.debugName),
        "autorun",
        void 0,
        state.stateStr,
        Array.from(state.dependencies).map((dep) => _Info.from(dep, debugNamePostProcessor) || _Info.unknown(dep))
      );
    } else if (obs instanceof Derived) {
      const state = obs.debugGetState();
      return new _Info(
        obs,
        debugNamePostProcessor(obs.debugName),
        "derived",
        state.value,
        state.stateStr,
        Array.from(state.dependencies).map((dep) => _Info.from(dep, debugNamePostProcessor) || _Info.unknown(dep))
      );
    } else if (obs instanceof ObservableValue) {
      const state = obs.debugGetState();
      return new _Info(
        obs,
        debugNamePostProcessor(obs.debugName),
        "observableValue",
        state.value,
        "upToDate",
        []
      );
    } else if (obs instanceof FromEventObservable) {
      const state = obs.debugGetState();
      return new _Info(
        obs,
        debugNamePostProcessor(obs.debugName),
        "fromEvent",
        state.value,
        state.hasValue ? "upToDate" : "initial",
        []
      );
    }
    return void 0;
  }
  static unknown(obs) {
    return new _Info(
      obs,
      "(unknown)",
      "unknown",
      void 0,
      "unknown",
      []
    );
  }
};

// src/util/vs/base/common/observableInternal/index.ts
_setDebugGetDependencyGraph(debugGetDependencyGraph);
setLogObservableFn(logObservableToConsole);
var enableLogging = false;
if (enableLogging) {
  addLogger(new ConsoleObservableLogger());
}
if (env && env["VSCODE_DEV_DEBUG_OBSERVABLES"]) {
  addLogger(DevToolsLogger.getInstance());
}

// src/platform/configuration/common/configurationService.ts
init_types();

// src/platform/inlineEdits/common/dataTypes/xtabPromptOptions.ts
init_assert();

// src/platform/configuration/common/validator.ts
var TypeofValidator = class {
  constructor(type) {
    this.type = type;
  }
  validate(content) {
    if (typeof content !== this.type) {
      return { content: void 0, error: { message: `Expected ${this.type}, but got ${typeof content}` } };
    }
    return { content, error: void 0 };
  }
  toSchema() {
    return { type: this.type };
  }
};
var vStringValidator = new TypeofValidator("string");
function vString() {
  return vStringValidator;
}
var vNumberValidator = new TypeofValidator("number");
var vBooleanValidator = new TypeofValidator("boolean");
function vBoolean() {
  return vBooleanValidator;
}
var vObjAnyValidator = new TypeofValidator("object");
var vUndefinedValidator = new TypeofValidator("undefined");
function vUndefined() {
  return vUndefinedValidator;
}
function vRequired(validator) {
  return {
    validate(content) {
      if (content === void 0) {
        return { content: void 0, error: { message: "Required field is missing" } };
      }
      return validator.validate(content);
    },
    toSchema() {
      return validator.toSchema();
    },
    isRequired() {
      return true;
    }
  };
}
function vObj(properties) {
  return {
    validate(content) {
      if (typeof content !== "object" || content === null) {
        return { content: void 0, error: { message: "Expected object" } };
      }
      const result = {};
      for (const key in properties) {
        const validator = properties[key];
        const fieldValue = content[key];
        const isRequired = validator.isRequired?.() ?? false;
        if (isRequired && fieldValue === void 0) {
          return { content: void 0, error: { message: `Required field '${key}' is missing` } };
        }
        if (!isRequired && fieldValue === void 0) {
          continue;
        }
        const { content: value, error: error2 } = validator.validate(fieldValue);
        if (error2) {
          return { content: void 0, error: { message: `Error in property '${key}': ${error2.message}` } };
        }
        result[key] = value;
      }
      return { content: result, error: void 0 };
    },
    toSchema() {
      const requiredFields = [];
      const schemaProperties = {};
      for (const [key, validator] of Object.entries(properties)) {
        schemaProperties[key] = validator.toSchema();
        if (validator.isRequired?.()) {
          requiredFields.push(key);
        }
      }
      const schema = {
        type: "object",
        properties: schemaProperties,
        ...requiredFields.length > 0 ? { required: requiredFields } : {}
      };
      return schema;
    }
  };
}
function vUnion(...validators) {
  return {
    validate(content) {
      let lastError;
      for (const validator of validators) {
        const { content: value, error: error2 } = validator.validate(content);
        if (!error2) {
          return { content: value, error: void 0 };
        }
        lastError = error2;
      }
      return { content: void 0, error: lastError };
    },
    toSchema() {
      return {
        oneOf: validators.map((validator) => validator.toSchema())
      };
    }
  };
}
function vEnum(...values) {
  return {
    validate(content) {
      if (values.indexOf(content) === -1) {
        return { content: void 0, error: { message: `Expected one of: ${values.join(", ")}` } };
      }
      return { content, error: void 0 };
    },
    toSchema() {
      return {
        enum: values
      };
    }
  };
}

// src/platform/inlineEdits/common/dataTypes/xtabPromptOptions.ts
var PromptingStrategy = /* @__PURE__ */ ((PromptingStrategy2) => {
  PromptingStrategy2["UnifiedModel"] = "xtabUnifiedModel";
  PromptingStrategy2["Codexv21NesUnified"] = "codexv21nesUnified";
  PromptingStrategy2["Nes41Miniv3"] = "nes41miniv3";
  PromptingStrategy2["SimplifiedSystemPrompt"] = "simplifiedSystemPrompt";
  PromptingStrategy2["Xtab275"] = "xtab275";
  return PromptingStrategy2;
})(PromptingStrategy || {});
var ResponseFormat = /* @__PURE__ */ ((ResponseFormat2) => {
  ResponseFormat2["CodeBlock"] = "codeBlock";
  ResponseFormat2["UnifiedWithXml"] = "unifiedWithXml";
  ResponseFormat2["EditWindowOnly"] = "editWindowOnly";
  return ResponseFormat2;
})(ResponseFormat || {});
((ResponseFormat2) => {
  function fromPromptingStrategy(strategy) {
    switch (strategy) {
      case "xtabUnifiedModel" /* UnifiedModel */:
      case "codexv21nesUnified" /* Codexv21NesUnified */:
      case "nes41miniv3" /* Nes41Miniv3 */:
        return "unifiedWithXml" /* UnifiedWithXml */;
      case "xtab275" /* Xtab275 */:
        return "editWindowOnly" /* EditWindowOnly */;
      case "simplifiedSystemPrompt" /* SimplifiedSystemPrompt */:
      case void 0:
        return "codeBlock" /* CodeBlock */;
      default:
        assertNever(strategy);
    }
  }
  ResponseFormat2.fromPromptingStrategy = fromPromptingStrategy;
})(ResponseFormat || (ResponseFormat = {}));
var DEFAULT_OPTIONS = {
  promptingStrategy: void 0,
  currentFile: {
    maxTokens: 2e3,
    includeTags: true,
    prioritizeAboveCursor: false
  },
  pagedClipping: {
    pageSize: 10
  },
  recentlyViewedDocuments: {
    nDocuments: 5,
    maxTokens: 2e3,
    includeViewedFiles: false
  },
  languageContext: {
    enabled: true,
    maxTokens: 2e3
  },
  diffHistory: {
    nEntries: 25,
    maxTokens: 1e3,
    onlyForDocsInPrompt: false,
    useRelativePaths: false
  },
  includePostScript: true
};
var LANGUAGE_CONTEXT_ENABLED_LANGUAGES = {
  // Currently empty - all languages enabled by default via languageContext.enabled=true
  // Add entries here only to override specific languages, e.g.:
  // 'plaintext': false,  // disable for plaintext files
};
var MODEL_CONFIGURATION_VALIDATOR = vObj({
  "modelName": vRequired(vString()),
  "promptingStrategy": vUnion(vEnum(...Object.values(PromptingStrategy)), vUndefined()),
  "includeTagsInCurrentFile": vRequired(vBoolean())
});

// src/platform/inlineEdits/common/responseProcessor.ts
init_errors();

// src/util/vs/editor/common/core/edits/lineEdit.ts
init_arrays();
init_assert();
init_strings();
init_lineRange();

// src/util/vs/editor/common/core/edits/stringEdit.ts
init_strings();
init_offsetRange();

// src/util/vs/editor/common/core/text/abstractText.ts
init_assert();
init_strings();
init_position();
init_range();
init_textLength();

// src/util/vs/editor/common/core/text/positionToOffsetImpl.ts
init_arraysFind();
init_offsetRange();
init_position();
init_range();
var PositionOffsetTransformerBase = class {
  getOffsetRange(range) {
    return new OffsetRange(
      this.getOffset(range.getStartPosition()),
      this.getOffset(range.getEndPosition())
    );
  }
  getRange(offsetRange) {
    return Range.fromPositions(
      this.getPosition(offsetRange.start),
      this.getPosition(offsetRange.endExclusive)
    );
  }
  getStringEdit(edit) {
    const edits = edit.replacements.map((e) => this.getStringReplacement(e));
    return new Deps.deps.StringEdit(edits);
  }
  getStringReplacement(edit) {
    return new Deps.deps.StringReplacement(this.getOffsetRange(edit.range), edit.text);
  }
  getTextReplacement(edit) {
    return new Deps.deps.TextReplacement(this.getRange(edit.replaceRange), edit.newText);
  }
  getTextEdit(edit) {
    const edits = edit.replacements.map((e) => this.getTextReplacement(e));
    return new Deps.deps.TextEdit(edits);
  }
};
var Deps = class {
  static {
    this._deps = void 0;
  }
  static get deps() {
    if (!this._deps) {
      throw new Error("Dependencies not set. Call _setDependencies first.");
    }
    return this._deps;
  }
};
function _setPositionOffsetTransformerDependencies(deps) {
  Deps._deps = deps;
}
var PositionOffsetTransformer = class extends PositionOffsetTransformerBase {
  constructor(text2) {
    super();
    this.text = text2;
    this.lineStartOffsetByLineIdx = [];
    this.lineEndOffsetByLineIdx = [];
    this.lineStartOffsetByLineIdx.push(0);
    for (let i = 0; i < text2.length; i++) {
      if (text2.charAt(i) === "\n") {
        this.lineStartOffsetByLineIdx.push(i + 1);
        if (i > 0 && text2.charAt(i - 1) === "\r") {
          this.lineEndOffsetByLineIdx.push(i - 1);
        } else {
          this.lineEndOffsetByLineIdx.push(i);
        }
      }
    }
    this.lineEndOffsetByLineIdx.push(text2.length);
  }
  getOffset(position) {
    const valPos = this._validatePosition(position);
    return this.lineStartOffsetByLineIdx[valPos.lineNumber - 1] + valPos.column - 1;
  }
  _validatePosition(position) {
    if (position.lineNumber < 1) {
      return new Position(1, 1);
    }
    const lineCount = this.textLength.lineCount + 1;
    if (position.lineNumber > lineCount) {
      const lineLength2 = this.getLineLength(lineCount);
      return new Position(lineCount, lineLength2 + 1);
    }
    if (position.column < 1) {
      return new Position(position.lineNumber, 1);
    }
    const lineLength = this.getLineLength(position.lineNumber);
    if (position.column - 1 > lineLength) {
      return new Position(position.lineNumber, lineLength + 1);
    }
    return position;
  }
  getPosition(offset) {
    const idx = findLastIdxMonotonous(this.lineStartOffsetByLineIdx, (i) => i <= offset);
    const lineNumber = idx + 1;
    const column = offset - this.lineStartOffsetByLineIdx[idx] + 1;
    return new Position(lineNumber, column);
  }
  getTextLength(offsetRange) {
    return Deps.deps.TextLength.ofRange(this.getRange(offsetRange));
  }
  get textLength() {
    const lineIdx = this.lineStartOffsetByLineIdx.length - 1;
    return new Deps.deps.TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);
  }
  getLineLength(lineNumber) {
    return this.lineEndOffsetByLineIdx[lineNumber - 1] - this.lineStartOffsetByLineIdx[lineNumber - 1];
  }
};

// src/util/vs/editor/common/core/text/abstractText.ts
var AbstractText = class {
  constructor() {
    this._transformer = void 0;
  }
  get endPositionExclusive() {
    return this.length.addToPosition(new Position(1, 1));
  }
  get lineRange() {
    return this.length.toLineRange();
  }
  getValue() {
    return this.getValueOfRange(this.length.toRange());
  }
  getValueOfOffsetRange(range) {
    return this.getValueOfRange(this.getTransformer().getRange(range));
  }
  getLineLength(lineNumber) {
    return this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER)).length;
  }
  getTransformer() {
    if (!this._transformer) {
      this._transformer = new PositionOffsetTransformer(this.getValue());
    }
    return this._transformer;
  }
  getLineAt(lineNumber) {
    return this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER));
  }
  getLines() {
    const value = this.getValue();
    return splitLines(value);
  }
  getLinesOfRange(range) {
    return range.mapToLineArray((lineNumber) => this.getLineAt(lineNumber));
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    return this.getValue() === other.getValue();
  }
};
var StringText = class extends AbstractText {
  constructor(value) {
    super();
    this.value = value;
    this._t = new PositionOffsetTransformer(this.value);
  }
  getValueOfRange(range) {
    return this._t.getOffsetRange(range).substring(this.value);
  }
  get length() {
    return this._t.textLength;
  }
  // Override the getTransformer method to return the cached transformer
  getTransformer() {
    return this._t;
  }
};

// src/util/vs/editor/common/core/edits/edit.ts
init_arrays();
init_errors();
init_offsetRange();
var BaseEdit = class {
  constructor(replacements) {
    this.replacements = replacements;
    let lastEndEx = -1;
    for (const replacement of replacements) {
      if (!(replacement.replaceRange.start >= lastEndEx)) {
        throw new BugIndicatingError(`Edits must be disjoint and sorted. Found ${replacement} after ${lastEndEx}`);
      }
      lastEndEx = replacement.replaceRange.endExclusive;
    }
  }
  /**
   * Returns true if and only if this edit and the given edit are structurally equal.
   * Note that this does not mean that the edits have the same effect on a given input!
   * See `.normalize()` or `.normalizeOnBase(base)` for that.
  */
  equals(other) {
    if (this.replacements.length !== other.replacements.length) {
      return false;
    }
    for (let i = 0; i < this.replacements.length; i++) {
      if (!this.replacements[i].equals(other.replacements[i])) {
        return false;
      }
    }
    return true;
  }
  toString() {
    const edits = this.replacements.map((e) => e.toString()).join(", ");
    return `[${edits}]`;
  }
  /**
   * Normalizes the edit by removing empty replacements and joining touching replacements (if the replacements allow joining).
   * Two edits have an equal normalized edit if and only if they have the same effect on any input.
   *
   * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_normalize.drawio.png)
   *
   * Invariant:
   * ```
   * (forall base: TEdit.apply(base).equals(other.apply(base))) <-> this.normalize().equals(other.normalize())
   * ```
   * and
   * ```
   * forall base: TEdit.apply(base).equals(this.normalize().apply(base))
   * ```
   *
   */
  normalize() {
    const newReplacements = [];
    let lastReplacement;
    for (const r of this.replacements) {
      if (r.getNewLength() === 0 && r.replaceRange.length === 0) {
        continue;
      }
      if (lastReplacement && lastReplacement.replaceRange.endExclusive === r.replaceRange.start) {
        const joined = lastReplacement.tryJoinTouching(r);
        if (joined) {
          lastReplacement = joined;
          continue;
        }
      }
      if (lastReplacement) {
        newReplacements.push(lastReplacement);
      }
      lastReplacement = r;
    }
    if (lastReplacement) {
      newReplacements.push(lastReplacement);
    }
    return this._createNew(newReplacements);
  }
  /**
   * Combines two edits into one with the same effect.
   *
   * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_compose.drawio.png)
   *
   * Invariant:
   * ```
   * other.apply(this.apply(s0)) = this.compose(other).apply(s0)
   * ```
   */
  compose(other) {
    const edits1 = this.normalize();
    const edits2 = other.normalize();
    if (edits1.isEmpty()) {
      return edits2;
    }
    if (edits2.isEmpty()) {
      return edits1;
    }
    const edit1Queue = [...edits1.replacements];
    const result = [];
    let edit1ToEdit2 = 0;
    for (const r2 of edits2.replacements) {
      while (true) {
        const r1 = edit1Queue[0];
        if (!r1 || r1.replaceRange.start + edit1ToEdit2 + r1.getNewLength() >= r2.replaceRange.start) {
          break;
        }
        edit1Queue.shift();
        result.push(r1);
        edit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;
      }
      const firstEdit1ToEdit2 = edit1ToEdit2;
      let firstIntersecting;
      let lastIntersecting;
      while (true) {
        const r1 = edit1Queue[0];
        if (!r1 || r1.replaceRange.start + edit1ToEdit2 > r2.replaceRange.endExclusive) {
          break;
        }
        if (!firstIntersecting) {
          firstIntersecting = r1;
        }
        lastIntersecting = r1;
        edit1Queue.shift();
        edit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;
      }
      if (!firstIntersecting) {
        result.push(r2.delta(-edit1ToEdit2));
      } else {
        const newReplaceRangeStart = Math.min(firstIntersecting.replaceRange.start, r2.replaceRange.start - firstEdit1ToEdit2);
        const prefixLength = r2.replaceRange.start - (firstIntersecting.replaceRange.start + firstEdit1ToEdit2);
        if (prefixLength > 0) {
          const prefix = firstIntersecting.slice(OffsetRange.emptyAt(newReplaceRangeStart), new OffsetRange(0, prefixLength));
          result.push(prefix);
        }
        if (!lastIntersecting) {
          throw new BugIndicatingError(`Invariant violation: lastIntersecting is undefined`);
        }
        const suffixLength = lastIntersecting.replaceRange.endExclusive + edit1ToEdit2 - r2.replaceRange.endExclusive;
        if (suffixLength > 0) {
          const e = lastIntersecting.slice(
            OffsetRange.ofStartAndLength(lastIntersecting.replaceRange.endExclusive, 0),
            new OffsetRange(lastIntersecting.getNewLength() - suffixLength, lastIntersecting.getNewLength())
          );
          edit1Queue.unshift(e);
          edit1ToEdit2 -= e.getNewLength() - e.replaceRange.length;
        }
        const newReplaceRange = new OffsetRange(
          newReplaceRangeStart,
          r2.replaceRange.endExclusive - edit1ToEdit2
        );
        const middle = r2.slice(newReplaceRange, new OffsetRange(0, r2.getNewLength()));
        result.push(middle);
      }
    }
    while (true) {
      const item = edit1Queue.shift();
      if (!item) {
        break;
      }
      result.push(item);
    }
    return this._createNew(result).normalize();
  }
  decomposeSplit(shouldBeInE1) {
    const e1 = [];
    const e2 = [];
    let e2delta = 0;
    for (const edit of this.replacements) {
      if (shouldBeInE1(edit)) {
        e1.push(edit);
        e2delta += edit.getNewLength() - edit.replaceRange.length;
      } else {
        e2.push(edit.slice(edit.replaceRange.delta(e2delta), new OffsetRange(0, edit.getNewLength())));
      }
    }
    return { e1: this._createNew(e1), e2: this._createNew(e2) };
  }
  /**
   * Returns the range of each replacement in the applied value.
  */
  getNewRanges() {
    const ranges = [];
    let offset = 0;
    for (const e of this.replacements) {
      ranges.push(OffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.getNewLength()));
      offset += e.getLengthDelta();
    }
    return ranges;
  }
  getJoinedReplaceRange() {
    if (this.replacements.length === 0) {
      return void 0;
    }
    return this.replacements[0].replaceRange.join(this.replacements.at(-1).replaceRange);
  }
  isEmpty() {
    return this.replacements.length === 0;
  }
  getLengthDelta() {
    return sumBy(this.replacements, (replacement) => replacement.getLengthDelta());
  }
  getNewDataLength(dataLength) {
    return dataLength + this.getLengthDelta();
  }
  applyToOffset(originalOffset) {
    let accumulatedDelta = 0;
    for (const r of this.replacements) {
      if (r.replaceRange.start <= originalOffset) {
        if (originalOffset < r.replaceRange.endExclusive) {
          return r.replaceRange.start + accumulatedDelta;
        }
        accumulatedDelta += r.getNewLength() - r.replaceRange.length;
      } else {
        break;
      }
    }
    return originalOffset + accumulatedDelta;
  }
  applyToOffsetRange(originalRange) {
    return new OffsetRange(
      this.applyToOffset(originalRange.start),
      this.applyToOffset(originalRange.endExclusive)
    );
  }
  applyInverseToOffset(postEditsOffset) {
    let accumulatedDelta = 0;
    for (const edit of this.replacements) {
      const editLength = edit.getNewLength();
      if (edit.replaceRange.start <= postEditsOffset - accumulatedDelta) {
        if (postEditsOffset - accumulatedDelta < edit.replaceRange.start + editLength) {
          return edit.replaceRange.start;
        }
        accumulatedDelta += editLength - edit.replaceRange.length;
      } else {
        break;
      }
    }
    return postEditsOffset - accumulatedDelta;
  }
  /**
   * Return undefined if the originalOffset is within an edit
   */
  applyToOffsetOrUndefined(originalOffset) {
    let accumulatedDelta = 0;
    for (const edit of this.replacements) {
      if (edit.replaceRange.start <= originalOffset) {
        if (originalOffset < edit.replaceRange.endExclusive) {
          return void 0;
        }
        accumulatedDelta += edit.getNewLength() - edit.replaceRange.length;
      } else {
        break;
      }
    }
    return originalOffset + accumulatedDelta;
  }
  /**
   * Return undefined if the originalRange is within an edit
   */
  applyToOffsetRangeOrUndefined(originalRange) {
    const start = this.applyToOffsetOrUndefined(originalRange.start);
    if (start === void 0) {
      return void 0;
    }
    const end = this.applyToOffsetOrUndefined(originalRange.endExclusive);
    if (end === void 0) {
      return void 0;
    }
    return new OffsetRange(start, end);
  }
};
var BaseReplacement = class {
  constructor(replaceRange) {
    this.replaceRange = replaceRange;
  }
  delta(offset) {
    return this.slice(this.replaceRange.delta(offset), new OffsetRange(0, this.getNewLength()));
  }
  getLengthDelta() {
    return this.getNewLength() - this.replaceRange.length;
  }
  toString() {
    return `{ ${this.replaceRange.toString()} -> ${this.getNewLength()} }`;
  }
  get isEmpty() {
    return this.getNewLength() === 0 && this.replaceRange.length === 0;
  }
  getRangeAfterReplace() {
    return new OffsetRange(this.replaceRange.start, this.replaceRange.start + this.getNewLength());
  }
};
var Edit = class _Edit extends BaseEdit {
  static {
    /**
     * Represents a set of edits to a string.
     * All these edits are applied at once.
    */
    this.empty = new _Edit([]);
  }
  static create(replacements) {
    return new _Edit(replacements);
  }
  static single(replacement) {
    return new _Edit([replacement]);
  }
  _createNew(replacements) {
    return new _Edit(replacements);
  }
};

// src/util/vs/editor/common/core/edits/stringEdit.ts
var BaseStringEdit = class extends BaseEdit {
  get TReplacement() {
    throw new Error("TReplacement is not defined for BaseStringEdit");
  }
  static composeOrUndefined(edits) {
    if (edits.length === 0) {
      return void 0;
    }
    let result = edits[0];
    for (let i = 1; i < edits.length; i++) {
      result = result.compose(edits[i]);
    }
    return result;
  }
  /**
   * r := trySwap(e1, e2);
   * e1.compose(e2) === r.e1.compose(r.e2)
  */
  static trySwap(e1, e2) {
    const e1Inv = e1.inverseOnSlice((start, endEx) => " ".repeat(endEx - start));
    const e1_ = e2.tryRebase(e1Inv);
    if (!e1_) {
      return void 0;
    }
    const e2_ = e1.tryRebase(e1_);
    if (!e2_) {
      return void 0;
    }
    return { e1: e1_, e2: e2_ };
  }
  apply(base2) {
    const resultText = [];
    let pos = 0;
    for (const edit of this.replacements) {
      resultText.push(base2.substring(pos, edit.replaceRange.start));
      resultText.push(edit.newText);
      pos = edit.replaceRange.endExclusive;
    }
    resultText.push(base2.substring(pos));
    return resultText.join("");
  }
  /**
   * Creates an edit that reverts this edit.
   */
  inverseOnSlice(getOriginalSlice) {
    const edits = [];
    let offset = 0;
    for (const e of this.replacements) {
      edits.push(StringReplacement.replace(
        OffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.newText.length),
        getOriginalSlice(e.replaceRange.start, e.replaceRange.endExclusive)
      ));
      offset += e.newText.length - e.replaceRange.length;
    }
    return new StringEdit(edits);
  }
  /**
   * Creates an edit that reverts this edit.
   */
  inverse(original) {
    return this.inverseOnSlice((start, endEx) => original.substring(start, endEx));
  }
  rebaseSkipConflicting(base2) {
    return this._tryRebase(base2, false);
  }
  tryRebase(base2) {
    return this._tryRebase(base2, true);
  }
  _tryRebase(base2, noOverlap) {
    const newEdits = [];
    let baseIdx = 0;
    let ourIdx = 0;
    let offset = 0;
    while (ourIdx < this.replacements.length || baseIdx < base2.replacements.length) {
      const baseEdit = base2.replacements[baseIdx];
      const ourEdit = this.replacements[ourIdx];
      if (!ourEdit) {
        break;
      } else if (!baseEdit) {
        newEdits.push(new StringReplacement(
          ourEdit.replaceRange.delta(offset),
          ourEdit.newText
        ));
        ourIdx++;
      } else if (ourEdit.replaceRange.intersectsOrTouches(baseEdit.replaceRange)) {
        ourIdx++;
        if (noOverlap) {
          return void 0;
        }
      } else if (ourEdit.replaceRange.start < baseEdit.replaceRange.start) {
        newEdits.push(new StringReplacement(
          ourEdit.replaceRange.delta(offset),
          ourEdit.newText
        ));
        ourIdx++;
      } else {
        baseIdx++;
        offset += baseEdit.newText.length - baseEdit.replaceRange.length;
      }
    }
    return new StringEdit(newEdits);
  }
  toJson() {
    return this.replacements.map((e) => e.toJson());
  }
  isNeutralOn(text2) {
    return this.replacements.every((e) => e.isNeutralOn(text2));
  }
  removeCommonSuffixPrefix(originalText) {
    const edits = [];
    for (const e of this.replacements) {
      const edit = e.removeCommonSuffixPrefix(originalText);
      if (!edit.isEmpty) {
        edits.push(edit);
      }
    }
    return new StringEdit(edits);
  }
  normalizeEOL(eol) {
    return new StringEdit(this.replacements.map((edit) => edit.normalizeEOL(eol)));
  }
  /**
   * If `e1.apply(source) === e2.apply(source)`, then `e1.normalizeOnSource(source).equals(e2.normalizeOnSource(source))`.
  */
  normalizeOnSource(source) {
    const result = this.apply(source);
    const edit = StringReplacement.replace(OffsetRange.ofLength(source.length), result);
    const e = edit.removeCommonSuffixAndPrefix(source);
    if (e.isEmpty) {
      return StringEdit.empty;
    }
    return e.toEdit();
  }
  removeCommonSuffixAndPrefix(source) {
    return this._createNew(this.replacements.map((e) => e.removeCommonSuffixAndPrefix(source))).normalize();
  }
  applyOnText(docContents) {
    return new StringText(this.apply(docContents.value));
  }
  mapData(f) {
    return new AnnotatedStringEdit(
      this.replacements.map((e) => new AnnotatedStringReplacement(
        e.replaceRange,
        e.newText,
        f(e)
      ))
    );
  }
};
var BaseStringReplacement = class extends BaseReplacement {
  constructor(range, newText) {
    super(range);
    this.newText = newText;
  }
  getNewLength() {
    return this.newText.length;
  }
  toString() {
    return `${this.replaceRange} -> ${JSON.stringify(this.newText)}`;
  }
  replace(str) {
    return str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);
  }
  /**
   * Checks if the edit would produce no changes when applied to the given text.
   */
  isNeutralOn(text2) {
    return this.newText === text2.substring(this.replaceRange.start, this.replaceRange.endExclusive);
  }
  removeCommonSuffixPrefix(originalText) {
    const oldText = originalText.substring(this.replaceRange.start, this.replaceRange.endExclusive);
    const prefixLen = commonPrefixLength(oldText, this.newText);
    const suffixLen = Math.min(
      oldText.length - prefixLen,
      this.newText.length - prefixLen,
      commonSuffixLength(oldText, this.newText)
    );
    const replaceRange = new OffsetRange(
      this.replaceRange.start + prefixLen,
      this.replaceRange.endExclusive - suffixLen
    );
    const newText = this.newText.substring(prefixLen, this.newText.length - suffixLen);
    return new StringReplacement(replaceRange, newText);
  }
  normalizeEOL(eol) {
    const newText = this.newText.replace(/\r\n|\n/g, eol);
    return new StringReplacement(this.replaceRange, newText);
  }
  removeCommonSuffixAndPrefix(source) {
    return this.removeCommonSuffix(source).removeCommonPrefix(source);
  }
  removeCommonPrefix(source) {
    const oldText = this.replaceRange.substring(source);
    const prefixLen = commonPrefixLength(oldText, this.newText);
    if (prefixLen === 0) {
      return this;
    }
    return this.slice(this.replaceRange.deltaStart(prefixLen), new OffsetRange(prefixLen, this.newText.length));
  }
  removeCommonSuffix(source) {
    const oldText = this.replaceRange.substring(source);
    const suffixLen = commonSuffixLength(oldText, this.newText);
    if (suffixLen === 0) {
      return this;
    }
    return this.slice(this.replaceRange.deltaEnd(-suffixLen), new OffsetRange(0, this.newText.length - suffixLen));
  }
  toEdit() {
    return new StringEdit([this]);
  }
  toJson() {
    return {
      txt: this.newText,
      pos: this.replaceRange.start,
      len: this.replaceRange.length
    };
  }
};
var StringEdit = class _StringEdit extends BaseStringEdit {
  static {
    this.empty = new _StringEdit([]);
  }
  static create(replacements) {
    return new _StringEdit(replacements);
  }
  static single(replacement) {
    return new _StringEdit([replacement]);
  }
  static replace(range, replacement) {
    return new _StringEdit([new StringReplacement(range, replacement)]);
  }
  static insert(offset, replacement) {
    return new _StringEdit([new StringReplacement(OffsetRange.emptyAt(offset), replacement)]);
  }
  static delete(range) {
    return new _StringEdit([new StringReplacement(range, "")]);
  }
  static fromJson(data) {
    return new _StringEdit(data.map(StringReplacement.fromJson));
  }
  static compose(edits) {
    if (edits.length === 0) {
      return _StringEdit.empty;
    }
    let result = edits[0];
    for (let i = 1; i < edits.length; i++) {
      result = result.compose(edits[i]);
    }
    return result;
  }
  /**
   * The replacements are applied in order!
   * Equals `StringEdit.compose(replacements.map(r => r.toEdit()))`, but is much more performant.
  */
  static composeSequentialReplacements(replacements) {
    let edit = _StringEdit.empty;
    let curEditReplacements = [];
    for (const r of replacements) {
      const last = curEditReplacements.at(-1);
      if (!last || r.replaceRange.isBefore(last.replaceRange)) {
        curEditReplacements.push(r);
      } else {
        edit = edit.compose(_StringEdit.create(curEditReplacements.reverse()));
        curEditReplacements = [r];
      }
    }
    edit = edit.compose(_StringEdit.create(curEditReplacements.reverse()));
    return edit;
  }
  constructor(replacements) {
    super(replacements);
  }
  _createNew(replacements) {
    return new _StringEdit(replacements);
  }
};
var StringReplacement = class _StringReplacement extends BaseStringReplacement {
  static insert(offset, text2) {
    return new _StringReplacement(OffsetRange.emptyAt(offset), text2);
  }
  static replace(range, text2) {
    return new _StringReplacement(range, text2);
  }
  static delete(range) {
    return new _StringReplacement(range, "");
  }
  static fromJson(data) {
    return new _StringReplacement(OffsetRange.ofStartAndLength(data.pos, data.len), data.txt);
  }
  equals(other) {
    return this.replaceRange.equals(other.replaceRange) && this.newText === other.newText;
  }
  tryJoinTouching(other) {
    return new _StringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText);
  }
  slice(range, rangeInReplacement) {
    return new _StringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText);
  }
};
var AnnotatedStringEdit = class _AnnotatedStringEdit extends BaseStringEdit {
  static {
    this.empty = new _AnnotatedStringEdit([]);
  }
  static create(replacements) {
    return new _AnnotatedStringEdit(replacements);
  }
  static single(replacement) {
    return new _AnnotatedStringEdit([replacement]);
  }
  static replace(range, replacement, data) {
    return new _AnnotatedStringEdit([new AnnotatedStringReplacement(range, replacement, data)]);
  }
  static insert(offset, replacement, data) {
    return new _AnnotatedStringEdit([new AnnotatedStringReplacement(OffsetRange.emptyAt(offset), replacement, data)]);
  }
  static delete(range, data) {
    return new _AnnotatedStringEdit([new AnnotatedStringReplacement(range, "", data)]);
  }
  static compose(edits) {
    if (edits.length === 0) {
      return _AnnotatedStringEdit.empty;
    }
    let result = edits[0];
    for (let i = 1; i < edits.length; i++) {
      result = result.compose(edits[i]);
    }
    return result;
  }
  constructor(replacements) {
    super(replacements);
  }
  _createNew(replacements) {
    return new _AnnotatedStringEdit(replacements);
  }
  toStringEdit(filter) {
    const newReplacements = [];
    for (const r of this.replacements) {
      if (!filter || filter(r)) {
        newReplacements.push(new StringReplacement(r.replaceRange, r.newText));
      }
    }
    return new StringEdit(newReplacements);
  }
};
var AnnotatedStringReplacement = class _AnnotatedStringReplacement extends BaseStringReplacement {
  constructor(range, newText, data) {
    super(range, newText);
    this.data = data;
  }
  static insert(offset, text2, data) {
    return new _AnnotatedStringReplacement(OffsetRange.emptyAt(offset), text2, data);
  }
  static replace(range, text2, data) {
    return new _AnnotatedStringReplacement(range, text2, data);
  }
  static delete(range, data) {
    return new _AnnotatedStringReplacement(range, "", data);
  }
  equals(other) {
    return this.replaceRange.equals(other.replaceRange) && this.newText === other.newText && this.data === other.data;
  }
  tryJoinTouching(other) {
    const joined = this.data.join(other.data);
    if (joined === void 0) {
      return void 0;
    }
    return new _AnnotatedStringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText, joined);
  }
  slice(range, rangeInReplacement) {
    return new _AnnotatedStringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText, this.data);
  }
};

// src/util/vs/editor/common/core/edits/lineEdit.ts
init_position();
init_range();

// src/util/vs/editor/common/core/edits/textEdit.ts
init_arrays();
init_assert();
init_errors();
init_strings();
init_position();
init_range();
init_textLength();
var TextEdit = class _TextEdit {
  constructor(replacements) {
    this.replacements = replacements;
    assertFn(() => checkAdjacentItems(replacements, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));
  }
  static fromStringEdit(edit, initialState) {
    const edits = edit.replacements.map((e) => TextReplacement.fromStringReplacement(e, initialState));
    return new _TextEdit(edits);
  }
  static replace(originalRange, newText) {
    return new _TextEdit([new TextReplacement(originalRange, newText)]);
  }
  static delete(range) {
    return new _TextEdit([new TextReplacement(range, "")]);
  }
  static insert(position, newText) {
    return new _TextEdit([new TextReplacement(Range.fromPositions(position, position), newText)]);
  }
  static fromParallelReplacementsUnsorted(replacements) {
    const r = replacements.slice().sort(compareBy((i) => i.range, Range.compareRangesUsingStarts));
    return new _TextEdit(r);
  }
  /**
   * Joins touching edits and removes empty edits.
   */
  normalize() {
    const replacements = [];
    for (const r of this.replacements) {
      if (replacements.length > 0 && replacements[replacements.length - 1].range.getEndPosition().equals(r.range.getStartPosition())) {
        const last = replacements[replacements.length - 1];
        replacements[replacements.length - 1] = new TextReplacement(last.range.plusRange(r.range), last.text + r.text);
      } else if (!r.isEmpty) {
        replacements.push(r);
      }
    }
    return new _TextEdit(replacements);
  }
  mapPosition(position) {
    let lineDelta = 0;
    let curLine = 0;
    let columnDeltaInCurLine = 0;
    for (const replacement of this.replacements) {
      const start = replacement.range.getStartPosition();
      if (position.isBeforeOrEqual(start)) {
        break;
      }
      const end = replacement.range.getEndPosition();
      const len = TextLength.ofText(replacement.text);
      if (position.isBefore(end)) {
        const startPos = new Position(start.lineNumber + lineDelta, start.column + (start.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));
        const endPos = len.addToPosition(startPos);
        return rangeFromPositions(startPos, endPos);
      }
      if (start.lineNumber + lineDelta !== curLine) {
        columnDeltaInCurLine = 0;
      }
      lineDelta += len.lineCount - (replacement.range.endLineNumber - replacement.range.startLineNumber);
      if (len.lineCount === 0) {
        if (end.lineNumber !== start.lineNumber) {
          columnDeltaInCurLine += len.columnCount - (end.column - 1);
        } else {
          columnDeltaInCurLine += len.columnCount - (end.column - start.column);
        }
      } else {
        columnDeltaInCurLine = len.columnCount;
      }
      curLine = end.lineNumber + lineDelta;
    }
    return new Position(position.lineNumber + lineDelta, position.column + (position.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));
  }
  mapRange(range) {
    function getStart(p) {
      return p instanceof Position ? p : p.getStartPosition();
    }
    function getEnd(p) {
      return p instanceof Position ? p : p.getEndPosition();
    }
    const start = getStart(this.mapPosition(range.getStartPosition()));
    const end = getEnd(this.mapPosition(range.getEndPosition()));
    return rangeFromPositions(start, end);
  }
  // TODO: `doc` is not needed for this!
  inverseMapPosition(positionAfterEdit, doc) {
    const reversed = this.inverse(doc);
    return reversed.mapPosition(positionAfterEdit);
  }
  inverseMapRange(range, doc) {
    const reversed = this.inverse(doc);
    return reversed.mapRange(range);
  }
  apply(text2) {
    let result = "";
    let lastEditEnd = new Position(1, 1);
    for (const replacement of this.replacements) {
      const editRange = replacement.range;
      const editStart = editRange.getStartPosition();
      const editEnd = editRange.getEndPosition();
      const r2 = rangeFromPositions(lastEditEnd, editStart);
      if (!r2.isEmpty()) {
        result += text2.getValueOfRange(r2);
      }
      result += replacement.text;
      lastEditEnd = editEnd;
    }
    const r = rangeFromPositions(lastEditEnd, text2.endPositionExclusive);
    if (!r.isEmpty()) {
      result += text2.getValueOfRange(r);
    }
    return result;
  }
  applyToString(str) {
    const strText = new StringText(str);
    return this.apply(strText);
  }
  inverse(doc) {
    const ranges = this.getNewRanges();
    return new _TextEdit(this.replacements.map((e, idx) => new TextReplacement(ranges[idx], doc.getValueOfRange(e.range))));
  }
  getNewRanges() {
    const newRanges = [];
    let previousEditEndLineNumber = 0;
    let lineOffset = 0;
    let columnOffset = 0;
    for (const replacement of this.replacements) {
      const textLength = TextLength.ofText(replacement.text);
      const newRangeStart = Position.lift({
        lineNumber: replacement.range.startLineNumber + lineOffset,
        column: replacement.range.startColumn + (replacement.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)
      });
      const newRange = textLength.createRange(newRangeStart);
      newRanges.push(newRange);
      lineOffset = newRange.endLineNumber - replacement.range.endLineNumber;
      columnOffset = newRange.endColumn - replacement.range.endColumn;
      previousEditEndLineNumber = replacement.range.endLineNumber;
    }
    return newRanges;
  }
  toReplacement(text2) {
    if (this.replacements.length === 0) {
      throw new BugIndicatingError();
    }
    if (this.replacements.length === 1) {
      return this.replacements[0];
    }
    const startPos = this.replacements[0].range.getStartPosition();
    const endPos = this.replacements[this.replacements.length - 1].range.getEndPosition();
    let newText = "";
    for (let i = 0; i < this.replacements.length; i++) {
      const curEdit = this.replacements[i];
      newText += curEdit.text;
      if (i < this.replacements.length - 1) {
        const nextEdit = this.replacements[i + 1];
        const gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());
        const gapText = text2.getValueOfRange(gapRange);
        newText += gapText;
      }
    }
    return new TextReplacement(Range.fromPositions(startPos, endPos), newText);
  }
  equals(other) {
    return equals(this.replacements, other.replacements, (a, b) => a.equals(b));
  }
  toString(text2) {
    if (text2 === void 0) {
      return this.replacements.map((edit) => edit.toString()).join("\n");
    }
    if (typeof text2 === "string") {
      return this.toString(new StringText(text2));
    }
    if (this.replacements.length === 0) {
      return "";
    }
    return this.replacements.map((r) => {
      const maxLength = 10;
      const originalText = text2.getValueOfRange(r.range);
      const beforeRange = Range.fromPositions(
        new Position(Math.max(1, r.range.startLineNumber - 1), 1),
        r.range.getStartPosition()
      );
      let beforeText = text2.getValueOfRange(beforeRange);
      if (beforeText.length > maxLength) {
        beforeText = "..." + beforeText.substring(beforeText.length - maxLength);
      }
      const afterRange = Range.fromPositions(
        r.range.getEndPosition(),
        new Position(r.range.endLineNumber + 1, 1)
      );
      let afterText = text2.getValueOfRange(afterRange);
      if (afterText.length > maxLength) {
        afterText = afterText.substring(0, maxLength) + "...";
      }
      let replacedText = originalText;
      if (replacedText.length > maxLength) {
        const halfMax = Math.floor(maxLength / 2);
        replacedText = replacedText.substring(0, halfMax) + "..." + replacedText.substring(replacedText.length - halfMax);
      }
      let newText = r.text;
      if (newText.length > maxLength) {
        const halfMax = Math.floor(maxLength / 2);
        newText = newText.substring(0, halfMax) + "..." + newText.substring(newText.length - halfMax);
      }
      if (replacedText.length === 0) {
        return `${beforeText}\u2770${newText}\u2771${afterText}`;
      }
      return `${beforeText}\u2770${replacedText}\u21A6${newText}\u2771${afterText}`;
    }).join("\n");
  }
};
var TextReplacement = class _TextReplacement {
  constructor(range, text2) {
    this.range = range;
    this.text = text2;
  }
  static joinReplacements(replacements, initialValue) {
    if (replacements.length === 0) {
      throw new BugIndicatingError();
    }
    if (replacements.length === 1) {
      return replacements[0];
    }
    const startPos = replacements[0].range.getStartPosition();
    const endPos = replacements[replacements.length - 1].range.getEndPosition();
    let newText = "";
    for (let i = 0; i < replacements.length; i++) {
      const curEdit = replacements[i];
      newText += curEdit.text;
      if (i < replacements.length - 1) {
        const nextEdit = replacements[i + 1];
        const gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());
        const gapText = initialValue.getValueOfRange(gapRange);
        newText += gapText;
      }
    }
    return new _TextReplacement(Range.fromPositions(startPos, endPos), newText);
  }
  static fromStringReplacement(replacement, initialState) {
    return new _TextReplacement(initialState.getTransformer().getRange(replacement.replaceRange), replacement.newText);
  }
  static delete(range) {
    return new _TextReplacement(range, "");
  }
  get isEmpty() {
    return this.range.isEmpty() && this.text.length === 0;
  }
  static equals(first, second) {
    return first.range.equalsRange(second.range) && first.text === second.text;
  }
  toSingleEditOperation() {
    return {
      range: this.range,
      text: this.text
    };
  }
  toEdit() {
    return new TextEdit([this]);
  }
  equals(other) {
    return _TextReplacement.equals(this, other);
  }
  extendToCoverRange(range, initialValue) {
    if (this.range.containsRange(range)) {
      return this;
    }
    const newRange = this.range.plusRange(range);
    const textBefore = initialValue.getValueOfRange(Range.fromPositions(newRange.getStartPosition(), this.range.getStartPosition()));
    const textAfter = initialValue.getValueOfRange(Range.fromPositions(this.range.getEndPosition(), newRange.getEndPosition()));
    const newText = textBefore + this.text + textAfter;
    return new _TextReplacement(newRange, newText);
  }
  extendToFullLine(initialValue) {
    const newRange = new Range(
      this.range.startLineNumber,
      1,
      this.range.endLineNumber,
      initialValue.getTransformer().getLineLength(this.range.endLineNumber) + 1
    );
    return this.extendToCoverRange(newRange, initialValue);
  }
  removeCommonPrefixAndSuffix(text2) {
    const prefix = this.removeCommonPrefix(text2);
    const suffix = prefix.removeCommonSuffix(text2);
    return suffix;
  }
  removeCommonPrefix(text2) {
    const normalizedOriginalText = text2.getValueOfRange(this.range).replaceAll("\r\n", "\n");
    const normalizedModifiedText = this.text.replaceAll("\r\n", "\n");
    const commonPrefixLen = commonPrefixLength(normalizedOriginalText, normalizedModifiedText);
    const start = TextLength.ofText(normalizedOriginalText.substring(0, commonPrefixLen)).addToPosition(this.range.getStartPosition());
    const newText = normalizedModifiedText.substring(commonPrefixLen);
    const range = Range.fromPositions(start, this.range.getEndPosition());
    return new _TextReplacement(range, newText);
  }
  removeCommonSuffix(text2) {
    const normalizedOriginalText = text2.getValueOfRange(this.range).replaceAll("\r\n", "\n");
    const normalizedModifiedText = this.text.replaceAll("\r\n", "\n");
    const commonSuffixLen = commonSuffixLength(normalizedOriginalText, normalizedModifiedText);
    const end = TextLength.ofText(normalizedOriginalText.substring(0, normalizedOriginalText.length - commonSuffixLen)).addToPosition(this.range.getStartPosition());
    const newText = normalizedModifiedText.substring(0, normalizedModifiedText.length - commonSuffixLen);
    const range = Range.fromPositions(this.range.getStartPosition(), end);
    return new _TextReplacement(range, newText);
  }
  isEffectiveDeletion(text2) {
    let newText = this.text.replaceAll("\r\n", "\n");
    let existingText = text2.getValueOfRange(this.range).replaceAll("\r\n", "\n");
    const l = commonPrefixLength(newText, existingText);
    newText = newText.substring(l);
    existingText = existingText.substring(l);
    const r = commonSuffixLength(newText, existingText);
    newText = newText.substring(0, newText.length - r);
    existingText = existingText.substring(0, existingText.length - r);
    return newText === "";
  }
  toString() {
    const start = this.range.getStartPosition();
    const end = this.range.getEndPosition();
    return `(${start.lineNumber},${start.column} -> ${end.lineNumber},${end.column}): "${this.text}"`;
  }
};
function rangeFromPositions(start, end) {
  if (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {
    return Range.fromPositions(end, end);
  } else if (!start.isBeforeOrEqual(end)) {
    throw new BugIndicatingError("start must be before end");
  }
  return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
}

// src/util/vs/editor/common/core/edits/lineEdit.ts
var LineEdit = class _LineEdit {
  constructor(replacements) {
    this.replacements = replacements;
    assert(checkAdjacentItems(replacements, (i1, i2) => i1.lineRange.endLineNumberExclusive <= i2.lineRange.startLineNumber));
  }
  static {
    this.empty = new _LineEdit([]);
  }
  static deserialize(data) {
    return new _LineEdit(data.map((e) => LineReplacement.deserialize(e)));
  }
  static fromStringEdit(edit, initialValue) {
    const textEdit = TextEdit.fromStringEdit(edit, initialValue);
    return _LineEdit.fromTextEdit(textEdit, initialValue);
  }
  static fromTextEdit(edit, initialValue) {
    const edits = edit.replacements;
    const result = [];
    const currentEdits = [];
    for (let i = 0; i < edits.length; i++) {
      const edit2 = edits[i];
      const nextEditRange = i + 1 < edits.length ? edits[i + 1] : void 0;
      currentEdits.push(edit2);
      if (nextEditRange && nextEditRange.range.startLineNumber === edit2.range.endLineNumber) {
        continue;
      }
      const singleEdit = TextReplacement.joinReplacements(currentEdits, initialValue);
      currentEdits.length = 0;
      const singleLineEdit = LineReplacement.fromSingleTextEdit(singleEdit, initialValue);
      result.push(singleLineEdit);
    }
    return new _LineEdit(result);
  }
  static createFromUnsorted(edits) {
    const result = edits.slice();
    result.sort(compareBy((i) => i.lineRange.startLineNumber, numberComparator));
    return new _LineEdit(result);
  }
  isEmpty() {
    return this.replacements.length === 0;
  }
  toEdit(initialValue) {
    const edits = [];
    for (const edit of this.replacements) {
      const singleEdit = edit.toSingleEdit(initialValue);
      edits.push(singleEdit);
    }
    return new StringEdit(edits);
  }
  toString() {
    return this.replacements.map((e) => e.toString()).join(",");
  }
  serialize() {
    return this.replacements.map((e) => e.serialize());
  }
  getNewLineRanges() {
    const ranges = [];
    let offset = 0;
    for (const e of this.replacements) {
      ranges.push(LineRange.ofLength(e.lineRange.startLineNumber + offset, e.newLines.length));
      offset += e.newLines.length - e.lineRange.length;
    }
    return ranges;
  }
  mapLineNumber(lineNumber) {
    let lineDelta = 0;
    for (const e of this.replacements) {
      if (e.lineRange.endLineNumberExclusive > lineNumber) {
        break;
      }
      lineDelta += e.newLines.length - e.lineRange.length;
    }
    return lineNumber + lineDelta;
  }
  mapLineRange(lineRange) {
    return new LineRange(
      this.mapLineNumber(lineRange.startLineNumber),
      this.mapLineNumber(lineRange.endLineNumberExclusive)
    );
  }
  /** TODO improve, dont require originalLines */
  mapBackLineRange(lineRange, originalLines) {
    const i = this.inverse(originalLines);
    return i.mapLineRange(lineRange);
  }
  touches(other) {
    return this.replacements.some((e1) => other.replacements.some((e2) => e1.lineRange.intersect(e2.lineRange)));
  }
  rebase(base2) {
    return new _LineEdit(
      this.replacements.map((e) => new LineReplacement(base2.mapLineRange(e.lineRange), e.newLines))
    );
  }
  humanReadablePatch(originalLines) {
    const result = [];
    function pushLine(originalLineNumber, modifiedLineNumber, kind, content) {
      const specialChar = kind === "unmodified" ? " " : kind === "deleted" ? "-" : "+";
      if (content === void 0) {
        content = "[[[[[ WARNING: LINE DOES NOT EXIST ]]]]]";
      }
      const origLn = originalLineNumber === -1 ? "   " : originalLineNumber.toString().padStart(3, " ");
      const modLn = modifiedLineNumber === -1 ? "   " : modifiedLineNumber.toString().padStart(3, " ");
      result.push(`${specialChar} ${origLn} ${modLn} ${content}`);
    }
    function pushSeperator() {
      result.push("---");
    }
    let lineDelta = 0;
    let first = true;
    for (const edits of groupAdjacentBy(this.replacements, (e1, e2) => e1.lineRange.distanceToRange(e2.lineRange) <= 5)) {
      if (!first) {
        pushSeperator();
      } else {
        first = false;
      }
      let lastLineNumber = edits[0].lineRange.startLineNumber - 2;
      for (const edit of edits) {
        for (let i = Math.max(1, lastLineNumber); i < edit.lineRange.startLineNumber; i++) {
          pushLine(i, i + lineDelta, "unmodified", originalLines[i - 1]);
        }
        const range = edit.lineRange;
        const newLines = edit.newLines;
        for (const replaceLineNumber of range.mapToLineArray((n) => n)) {
          const line = originalLines[replaceLineNumber - 1];
          pushLine(replaceLineNumber, -1, "deleted", line);
        }
        for (let i = 0; i < newLines.length; i++) {
          const line = newLines[i];
          pushLine(-1, range.startLineNumber + lineDelta + i, "added", line);
        }
        lastLineNumber = range.endLineNumberExclusive;
        lineDelta += edit.newLines.length - edit.lineRange.length;
      }
      for (let i = lastLineNumber; i <= Math.min(lastLineNumber + 2, originalLines.length); i++) {
        pushLine(i, i + lineDelta, "unmodified", originalLines[i - 1]);
      }
    }
    return result.join("\n");
  }
  apply(lines) {
    const result = [];
    let currentLineIndex = 0;
    for (const edit of this.replacements) {
      while (currentLineIndex < edit.lineRange.startLineNumber - 1) {
        result.push(lines[currentLineIndex]);
        currentLineIndex++;
      }
      for (const newLine of edit.newLines) {
        result.push(newLine);
      }
      currentLineIndex = edit.lineRange.endLineNumberExclusive - 1;
    }
    while (currentLineIndex < lines.length) {
      result.push(lines[currentLineIndex]);
      currentLineIndex++;
    }
    return result;
  }
  inverse(originalLines) {
    const newRanges = this.getNewLineRanges();
    return new _LineEdit(this.replacements.map((e, idx) => new LineReplacement(
      newRanges[idx],
      originalLines.slice(e.lineRange.startLineNumber - 1, e.lineRange.endLineNumberExclusive - 1)
    )));
  }
};
var LineReplacement = class _LineReplacement {
  constructor(lineRange, newLines) {
    this.lineRange = lineRange;
    this.newLines = newLines;
  }
  static deserialize(e) {
    return new _LineReplacement(
      LineRange.ofLength(e[0], e[1] - e[0]),
      e[2]
    );
  }
  static fromSingleTextEdit(edit, initialValue) {
    const newLines = splitLines(edit.text);
    let startLineNumber = edit.range.startLineNumber;
    const survivingFirstLineText = initialValue.getValueOfRange(Range.fromPositions(
      new Position(edit.range.startLineNumber, 1),
      edit.range.getStartPosition()
    ));
    newLines[0] = survivingFirstLineText + newLines[0];
    let endLineNumberEx = edit.range.endLineNumber + 1;
    const editEndLineNumberMaxColumn = initialValue.getTransformer().getLineLength(edit.range.endLineNumber) + 1;
    const survivingEndLineText = initialValue.getValueOfRange(Range.fromPositions(
      edit.range.getEndPosition(),
      new Position(edit.range.endLineNumber, editEndLineNumberMaxColumn)
    ));
    newLines[newLines.length - 1] = newLines[newLines.length - 1] + survivingEndLineText;
    const startBeforeNewLine = edit.range.startColumn === initialValue.getTransformer().getLineLength(edit.range.startLineNumber) + 1;
    const endAfterNewLine = edit.range.endColumn === 1;
    if (startBeforeNewLine && newLines[0].length === survivingFirstLineText.length) {
      startLineNumber++;
      newLines.shift();
    }
    if (newLines.length > 0 && startLineNumber < endLineNumberEx && endAfterNewLine && newLines[newLines.length - 1].length === survivingEndLineText.length) {
      endLineNumberEx--;
      newLines.pop();
    }
    return new _LineReplacement(new LineRange(startLineNumber, endLineNumberEx), newLines);
  }
  toSingleTextEdit(initialValue) {
    if (this.newLines.length === 0) {
      const textLen = initialValue.getTransformer().textLength;
      if (this.lineRange.endLineNumberExclusive === textLen.lineCount + 2) {
        let startPos;
        if (this.lineRange.startLineNumber > 1) {
          const startLineNumber = this.lineRange.startLineNumber - 1;
          const startColumn = initialValue.getTransformer().getLineLength(startLineNumber) + 1;
          startPos = new Position(startLineNumber, startColumn);
        } else {
          startPos = new Position(1, 1);
        }
        const lastPosition = textLen.addToPosition(new Position(1, 1));
        return new TextReplacement(Range.fromPositions(startPos, lastPosition), "");
      } else {
        return new TextReplacement(new Range(this.lineRange.startLineNumber, 1, this.lineRange.endLineNumberExclusive, 1), "");
      }
    } else if (this.lineRange.isEmpty) {
      let endLineNumber;
      let column;
      let text2;
      const insertionLine = this.lineRange.startLineNumber;
      if (insertionLine === initialValue.getTransformer().textLength.lineCount + 2) {
        endLineNumber = insertionLine - 1;
        column = initialValue.getTransformer().getLineLength(endLineNumber) + 1;
        text2 = this.newLines.map((l) => "\n" + l).join("");
      } else {
        endLineNumber = insertionLine;
        column = 1;
        text2 = this.newLines.map((l) => l + "\n").join("");
      }
      return new TextReplacement(Range.fromPositions(new Position(endLineNumber, column)), text2);
    } else {
      const endLineNumber = this.lineRange.endLineNumberExclusive - 1;
      const endLineNumberMaxColumn = initialValue.getTransformer().getLineLength(endLineNumber) + 1;
      const range = new Range(
        this.lineRange.startLineNumber,
        1,
        endLineNumber,
        endLineNumberMaxColumn
      );
      const text2 = this.newLines.join("\n");
      return new TextReplacement(range, text2);
    }
  }
  toSingleEdit(initialValue) {
    const textEdit = this.toSingleTextEdit(initialValue);
    const range = initialValue.getTransformer().getOffsetRange(textEdit.range);
    return new StringReplacement(range, textEdit.text);
  }
  toString() {
    return `${this.lineRange}->${JSON.stringify(this.newLines)}`;
  }
  serialize() {
    return [
      this.lineRange.startLineNumber,
      this.lineRange.endLineNumberExclusive,
      this.newLines
    ];
  }
  removeCommonSuffixPrefixLines(initialValue) {
    let startLineNumber = this.lineRange.startLineNumber;
    let endLineNumberEx = this.lineRange.endLineNumberExclusive;
    let trimStartCount = 0;
    while (startLineNumber < endLineNumberEx && trimStartCount < this.newLines.length && this.newLines[trimStartCount] === initialValue.getLineAt(startLineNumber)) {
      startLineNumber++;
      trimStartCount++;
    }
    let trimEndCount = 0;
    while (startLineNumber < endLineNumberEx && trimEndCount + trimStartCount < this.newLines.length && this.newLines[this.newLines.length - 1 - trimEndCount] === initialValue.getLineAt(endLineNumberEx - 1)) {
      endLineNumberEx--;
      trimEndCount++;
    }
    if (trimStartCount === 0 && trimEndCount === 0) {
      return this;
    }
    return new _LineReplacement(new LineRange(startLineNumber, endLineNumberEx), this.newLines.slice(trimStartCount, this.newLines.length - trimEndCount));
  }
  toLineEdit() {
    return new LineEdit([this]);
  }
};
var SerializedLineReplacement;
((SerializedLineReplacement2) => {
  function is(thing) {
    return Array.isArray(thing) && thing.length === 3 && typeof thing[0] === "number" && typeof thing[1] === "number" && Array.isArray(thing[2]) && thing[2].every((e) => typeof e === "string");
  }
  SerializedLineReplacement2.is = is;
})(SerializedLineReplacement || (SerializedLineReplacement = {}));

// src/platform/inlineEdits/common/responseProcessor.ts
init_lineRange();
var ResponseProcessor;
((ResponseProcessor2) => {
  ResponseProcessor2.DEFAULT_DIFF_PARAMS = {
    emitFastCursorLineChange: false,
    nSignificantLinesToConverge: 2,
    nLinesToConverge: 3
  };
  async function* diff2(originalLines, modifiedLines, cursorOriginalLinesOffset, params) {
    const lineToIdxs = new ArrayMap();
    for (const [i, line] of originalLines.entries()) {
      lineToIdxs.add(line, i);
    }
    let editWindowIdx = 0;
    let updatedEditWindowIdx = -1;
    let state = { k: "aligned" };
    for await (const line of modifiedLines) {
      ++updatedEditWindowIdx;
      if (editWindowIdx >= originalLines.length) {
        switch (state.k) {
          case "aligned": {
            state = { k: "diverged", startLineIdx: editWindowIdx, newLines: [line] };
            break;
          }
          case "diverged": {
            state.newLines.push(line);
          }
        }
        continue;
      }
      if (state.k === "aligned") {
        if (originalLines[editWindowIdx] === line) {
          ++editWindowIdx;
          continue;
        }
        state = { k: "diverged", startLineIdx: editWindowIdx, newLines: [] };
      }
      state.newLines.push(line);
      const convergenceResult = checkForConvergence(
        originalLines,
        cursorOriginalLinesOffset,
        lineToIdxs,
        state,
        editWindowIdx,
        params
      );
      if (convergenceResult) {
        yield convergenceResult.singleLineEdit;
        editWindowIdx = convergenceResult.convergenceEndIdx;
        state = { k: "aligned" };
      }
    }
    switch (state.k) {
      case "diverged": {
        const lineRange = new LineRange(state.startLineIdx + 1, originalLines.length + 1);
        yield new LineReplacement(lineRange, state.newLines);
        break;
      }
      case "aligned": {
        if (editWindowIdx < originalLines.length) {
          const lineRange = new LineRange(editWindowIdx + 1, originalLines.length + 1);
          yield new LineReplacement(lineRange, []);
        }
        break;
      }
    }
  }
  ResponseProcessor2.diff = diff2;
  function isSignificant(s) {
    return !!s.match(/[a-zA-Z1-9]+/);
  }
  function checkForConvergence(originalLines, cursorOriginalLinesOffset, lineToIndexes, state, editWindowIdx, params) {
    if (state.newLines.length === 0) {
      throw illegalArgument("Cannot check for convergence without new lines");
    }
    let newLinesIdx = state.newLines.length - 1;
    let candidates = lineToIndexes.get(state.newLines[newLinesIdx]).map((idx) => [idx, idx]);
    if (candidates.length === 0) {
      if (!params.emitFastCursorLineChange || editWindowIdx !== cursorOriginalLinesOffset || state.newLines.length > 1) {
        return;
      }
      const zeroBasedLineRange2 = [editWindowIdx, editWindowIdx + 1];
      const lineRange2 = new LineRange(zeroBasedLineRange2[0] + 1, zeroBasedLineRange2[1] + 1);
      return {
        singleLineEdit: new LineReplacement(lineRange2, state.newLines),
        convergenceEndIdx: editWindowIdx + 1
      };
    }
    if (state.newLines.length < params.nSignificantLinesToConverge) {
      return;
    }
    let nNonSigMatches = 1;
    let nSigMatches = isSignificant(state.newLines[newLinesIdx]) ? 1 : 0;
    --newLinesIdx;
    let result;
    let match3 = candidates[0];
    if (nNonSigMatches > 0 && match3[0] - state.startLineIdx === state.newLines.length - 1) {
      result = "found_significant_matches";
    }
    for (; newLinesIdx >= 0; --newLinesIdx) {
      candidates = candidates.map(([convEndIdx, convIdx]) => [convEndIdx, convIdx - 1]);
      candidates = candidates.filter(([_, currentIdx]) => currentIdx >= 0 && editWindowIdx <= currentIdx);
      candidates = candidates.filter(([_, currentIdx]) => originalLines[currentIdx] === state.newLines[newLinesIdx]);
      if (candidates.length === 0) {
        break;
      } else {
        ++nNonSigMatches;
        if (isSignificant(state.newLines[newLinesIdx])) {
          ++nSigMatches;
        }
      }
      if (nSigMatches === params.nSignificantLinesToConverge) {
        result = "found_significant_matches";
        match3 = candidates[0];
      }
      if (nNonSigMatches === params.nLinesToConverge) {
        result = "found_matches";
        match3 = candidates[0];
        break;
      }
    }
    if (!result) {
      return;
    }
    const originalLinesConvIdx = match3[1];
    const originalLinesConvEndIdx = match3[0];
    const nLinesToConverge = originalLinesConvEndIdx - originalLinesConvIdx + 1;
    const nLinesRemoved = originalLinesConvIdx - state.startLineIdx;
    const linesInserted = state.newLines.slice(0, state.newLines.length - nLinesToConverge);
    const nLinesInserted = linesInserted.length;
    if (nLinesRemoved - nLinesInserted > 1 && nLinesInserted > 0) {
      return;
    }
    const zeroBasedLineRange = [state.startLineIdx, originalLinesConvIdx];
    const lineRange = new LineRange(zeroBasedLineRange[0] + 1, zeroBasedLineRange[1] + 1);
    const singleLineEdit = new LineReplacement(lineRange, linesInserted);
    return {
      singleLineEdit,
      convergenceEndIdx: originalLinesConvEndIdx + 1
    };
  }
})(ResponseProcessor || (ResponseProcessor = {}));
var ArrayMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * Appends a value to the array of values for the given key.
   */
  add(key, value) {
    const values = this.map.get(key);
    if (values) {
      values.push(value);
    } else {
      this.map.set(key, [value]);
    }
  }
  /**
   * Gets the array of values for the given key.
   * Returns an empty array if the key does not exist.
   */
  get(key) {
    return this.map.get(key) || [];
  }
};

// src/platform/configuration/common/configurationService.ts
var CopilotConfigPrefix = "puku";
var IConfigurationService = createDecorator("IConfigurationService");
var AbstractConfigurationService = class _AbstractConfigurationService extends Disposable {
  constructor(copilotTokenStore) {
    super();
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._isInternal = false;
    this._isTeamMember = false;
    this._teamMemberUsername = void 0;
    this.observables = /* @__PURE__ */ new Map();
    if (copilotTokenStore) {
      this._register(copilotTokenStore.onDidStoreUpdate(() => {
        const isTeamMember = !!copilotTokenStore.copilotToken?.isVscodeTeamMember;
        this._setUserInfo({
          isInternal: !!copilotTokenStore.copilotToken?.isInternal,
          isTeamMember,
          teamMemberUsername: isTeamMember ? copilotTokenStore.copilotToken?.username : void 0
        });
      }));
    }
  }
  getConfigMixedWithDefaults(key) {
    if (key.options?.valueIgnoredForExternals && !this._isInternal) {
      return this.getDefaultValue(key);
    }
    const userValue = this.getConfig(key);
    if (userValue === void 0) {
      return this.getDefaultValue(key);
    }
    if (isObject(userValue) && isObject(key.defaultValue)) {
      return { ...key.defaultValue, ...userValue };
    }
    return userValue;
  }
  getDefaultValue(key) {
    if (ConfigValueValidators.isDefaultValueWithTeamAndInternalValue(key.defaultValue)) {
      return this._isUsingTeamDefault(key) ? key.defaultValue.teamDefaultValue : this._isInternal ? key.defaultValue.internalDefaultValue : key.defaultValue.defaultValue;
    }
    if (ConfigValueValidators.isDefaultValueWithTeamValue(key.defaultValue)) {
      return this._isUsingTeamDefault(key) ? key.defaultValue.teamDefaultValue : key.defaultValue.defaultValue;
    }
    return key.defaultValue;
  }
  _setUserInfo(userInfo) {
    if (this._isInternal === userInfo.isInternal && this._isTeamMember === userInfo.isTeamMember && this._teamMemberUsername === userInfo.teamMemberUsername) {
      return;
    }
    this._isInternal = userInfo.isInternal;
    this._isTeamMember = userInfo.isTeamMember;
    this._teamMemberUsername = userInfo.teamMemberUsername;
    this._onDidChangeConfiguration.fire({ affectsConfiguration: () => true });
  }
  updateExperimentBasedConfiguration(treatments) {
    if (treatments.length === 0) {
      return;
    }
    this._onDidChangeConfiguration.fire({ affectsConfiguration: () => true });
  }
  getConfigObservable(key) {
    return this._getObservable_$show2FramesUp(key, () => this.getConfig(key));
  }
  getExperimentBasedConfigObservable(key, experimentationService) {
    return this._getObservable_$show2FramesUp(key, () => this.getExperimentBasedConfig(key, experimentationService));
  }
  _getObservable_$show2FramesUp(key, getValue) {
    let observable = this.observables.get(key.id);
    if (!observable) {
      observable = observableFromEventOpts(
        { debugName: () => `Configuration Key "${key.id}"` },
        (handleChange) => this._register(this.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(key.fullyQualifiedId)) {
            handleChange(e);
          }
        })),
        getValue
      );
      this.observables.set(key.id, observable);
    }
    return observable;
  }
  _isUsingTeamDefault(key) {
    if (!this._isTeamMember) {
      return false;
    }
    if (!ConfigValueValidators.isDefaultValueWithTeamAndInternalValue(key.defaultValue) && !ConfigValueValidators.isDefaultValueWithTeamValue(key.defaultValue)) {
      return false;
    }
    const rolloutRatio = key.defaultValue.teamDefaultValueRollout;
    if (rolloutRatio === void 0 || rolloutRatio >= 1) {
      return true;
    }
    const selectedValue = `${key.fullyQualifiedId};${this._teamMemberUsername}`;
    const hashValue = _AbstractConfigurationService._extractHashValue(selectedValue);
    return hashValue < rolloutRatio;
  }
  /**
   * Extracts a normalized value (0-1) from a string
   */
  static _extractHashValue(input) {
    const hash = new StringSHA1();
    hash.update(input);
    const firstPortion = hash.digest().substring(0, 8);
    const hashNumber = parseInt(firstPortion, 16);
    return hashNumber / 4294967295;
  }
  /**
   * Checks if the key is configured by the user in any of the configuration scopes.
   */
  isConfigured(key, scope) {
    const inspect = this.inspectConfig(key, scope);
    const isConfigured = inspect?.globalValue !== void 0 || inspect?.globalLanguageValue !== void 0 || inspect?.workspaceFolderValue !== void 0 || inspect?.workspaceFolderLanguageValue !== void 0 || inspect?.workspaceValue !== void 0 || inspect?.workspaceLanguageValue !== void 0;
    return isConfigured;
  }
};
var ConfigValueValidators;
((ConfigValueValidators2) => {
  function isDefaultValueWithTeamValue(value) {
    return isObject(value) && "defaultValue" in value && "teamDefaultValue" in value;
  }
  ConfigValueValidators2.isDefaultValueWithTeamValue = isDefaultValueWithTeamValue;
  function isDefaultValueWithTeamAndInternalValue(value) {
    return ConfigValueValidators2.isDefaultValueWithTeamValue(value) && "internalDefaultValue" in value;
  }
  ConfigValueValidators2.isDefaultValueWithTeamAndInternalValue = isDefaultValueWithTeamAndInternalValue;
})(ConfigValueValidators || (ConfigValueValidators = {}));
var INTERNAL_RESTRICTED = {
  internal: true,
  valueIgnoredForExternals: true
};
var packageJsonDefaults = void 0;
function getPackageJsonDefaults() {
  if (!packageJsonDefaults) {
    packageJsonDefaults = /* @__PURE__ */ new Map();
    const config3 = packageJson.contributes.configuration;
    const propertyGroups = config3.map((c) => c.properties);
    const configProps = Object.assign({}, ...propertyGroups);
    for (const key in configProps) {
      packageJsonDefaults.set(key, configProps[key].default);
    }
  }
  return packageJsonDefaults;
}
function toBaseConfig(key, defaultValue, options) {
  const fullyQualifiedId = `${CopilotConfigPrefix}.${key}`;
  const fullyQualifiedOldId = options?.oldKey ? `${CopilotConfigPrefix}.${options.oldKey}` : void 0;
  const packageJsonDefaults2 = getPackageJsonDefaults();
  const isPublic = packageJsonDefaults2.has(fullyQualifiedId);
  const packageJsonDefaultValue = packageJsonDefaults2.get(fullyQualifiedId);
  if (isPublic) {
    const publicDefaultValue = ConfigValueValidators.isDefaultValueWithTeamAndInternalValue(defaultValue) ? defaultValue.defaultValue : ConfigValueValidators.isDefaultValueWithTeamValue(defaultValue) ? defaultValue.defaultValue : defaultValue;
    if (!equals2(publicDefaultValue, packageJsonDefaultValue)) {
      throw new BugIndicatingError(`The default value for setting ${key} is different in packageJson and in code`);
    }
  }
  if (isPublic && options?.internal) {
    throw new BugIndicatingError(`The setting ${key} is public, it therefore cannot be marked internal!`);
  }
  if (isPublic && options?.valueIgnoredForExternals) {
    throw new BugIndicatingError(`The setting ${key} is public, it therefore cannot be restricted to internal!`);
  }
  if (ConfigValueValidators.isDefaultValueWithTeamAndInternalValue(defaultValue) || ConfigValueValidators.isDefaultValueWithTeamValue(defaultValue)) {
    const rolloutRatio = defaultValue?.teamDefaultValueRollout;
    if (rolloutRatio !== void 0 && (rolloutRatio < 0 || rolloutRatio > 1)) {
      throw new BugIndicatingError(`The rollout ratio for setting ${key} is invalid`);
    }
  }
  const advancedSubKey = fullyQualifiedId.startsWith("puku.advanced.") ? fullyQualifiedId.substring("puku.advanced.".length) : void 0;
  return { id: key, oldId: options?.oldKey, isPublic, fullyQualifiedId, fullyQualifiedOldId, advancedSubKey, defaultValue, options };
}
var ConfigRegistry = class {
  constructor() {
    /**
     * A map of all registered configs, keyed by their full id, eg `puku.advanced.debug.overrideProxyUrl`.
     */
    this.configs = /* @__PURE__ */ new Map();
  }
  registerConfig(config3) {
    this.configs.set(config3.fullyQualifiedId, config3);
  }
};
var globalConfigRegistry = new ConfigRegistry();
var ConfigurationMigrationRegistryImpl = class {
  constructor() {
    this.migrations = [];
    this._onDidRegisterConfigurationMigrations = new Emitter();
    this.onDidRegisterConfigurationMigration = this._onDidRegisterConfigurationMigrations.event;
  }
  registerConfigurationMigrations(configurationMigrations) {
    this.migrations.push(...configurationMigrations);
    this._onDidRegisterConfigurationMigrations.fire(configurationMigrations);
  }
};
var ConfigurationMigrationRegistry = new ConfigurationMigrationRegistryImpl();
function defineValidatedSetting(key, validator, defaultValue, options) {
  const value = { ...toBaseConfig(key, defaultValue, options), configType: 0 /* Simple */, validator };
  globalConfigRegistry.registerConfig(value);
  return value;
}
function defineSetting(key, defaultValue, options) {
  const value = { ...toBaseConfig(key, defaultValue, options), configType: 0 /* Simple */ };
  globalConfigRegistry.registerConfig(value);
  return value;
}
function defineExpSetting(key, defaultValue, options, expOptions) {
  const value = { ...toBaseConfig(key, defaultValue, options), configType: 1 /* ExperimentBased */, experimentName: expOptions?.experimentName };
  if (value.advancedSubKey) {
    throw new BugIndicatingError("Shared settings cannot be experiment based");
  }
  globalConfigRegistry.registerConfig(value);
  return value;
}
function migrateSetting(newKey, oldKey) {
  ConfigurationMigrationRegistry.registerConfigurationMigrations([{
    key: `${CopilotConfigPrefix}.${oldKey}`,
    migrateFn: async (migrationValue) => {
      return [
        [`${CopilotConfigPrefix}.${newKey}`, { value: migrationValue }],
        [`${CopilotConfigPrefix}.${oldKey}`, { value: void 0 }]
      ];
    }
  }]);
}
function defineAndMigrateSetting(oldKey, newKey, defaultValue, options) {
  migrateSetting(newKey, oldKey);
  return defineSetting(newKey, defaultValue, { ...options, oldKey });
}
function defineAndMigrateExpSetting(oldKey, newKey, defaultValue, options, expOptions) {
  migrateSetting(newKey, oldKey);
  return defineExpSetting(newKey, defaultValue, { ...options, oldKey }, expOptions);
}
var HARD_TOOL_LIMIT = 128;
var ConfigKey;
((ConfigKey2) => {
  let Shared;
  ((Shared2) => {
    Shared2.DebugOverrideProxyUrl = defineSetting("advanced.debug.overrideProxyUrl", void 0);
    Shared2.DebugOverrideCAPIUrl = defineSetting("advanced.debug.overrideCapiUrl", void 0);
    Shared2.DebugUseNodeFetchFetcher = defineSetting("advanced.debug.useNodeFetchFetcher", true);
    Shared2.DebugUseNodeFetcher = defineSetting("advanced.debug.useNodeFetcher", false);
    Shared2.DebugUseElectronFetcher = defineSetting("advanced.debug.useElectronFetcher", true);
    Shared2.AuthProvider = defineSetting("advanced.authProvider", "github" /* GitHub */);
    Shared2.AuthPermissions = defineSetting("advanced.authPermissions", "default" /* Default */);
  })(Shared = ConfigKey2.Shared || (ConfigKey2.Shared = {}));
  let AdvancedExperimental;
  ((AdvancedExperimental2) => {
    AdvancedExperimental2.DebugOverrideChatEngine = defineAndMigrateSetting("chat.advanced.debug.overrideChatEngine", "chat.debug.overrideChatEngine", void 0);
    AdvancedExperimental2.WorkspacePrototypeAdoCodeSearchEndpointOverride = defineAndMigrateSetting("chat.advanced.workspace.prototypeAdoCodeSearchEndpointOverride", "chat.workspace.prototypeAdoCodeSearchEndpointOverride", "");
    AdvancedExperimental2.FeedbackOnChange = defineAndMigrateSetting("chat.advanced.feedback.onChange", "chat.feedback.onChange", false);
    AdvancedExperimental2.ReviewIntent = defineAndMigrateSetting("chat.advanced.review.intent", "chat.review.intent", false);
    AdvancedExperimental2.NotebookSummaryExperimentEnabled = defineAndMigrateSetting("chat.advanced.notebook.summaryExperimentEnabled", "chat.notebook.summaryExperimentEnabled", false);
    AdvancedExperimental2.NotebookVariableFilteringEnabled = defineAndMigrateSetting("chat.advanced.notebook.variableFilteringEnabled", "chat.notebook.variableFilteringEnabled", false);
    AdvancedExperimental2.TerminalToDebuggerPatterns = defineAndMigrateSetting("chat.advanced.debugTerminalCommandPatterns", "chat.debugTerminalCommandPatterns", []);
    AdvancedExperimental2.WorkspaceRecordingEnabled = defineAndMigrateSetting("chat.advanced.localWorkspaceRecording.enabled", "chat.localWorkspaceRecording.enabled", false);
    AdvancedExperimental2.EditRecordingEnabled = defineAndMigrateSetting("chat.advanced.editRecording.enabled", "chat.editRecording.enabled", false);
    AdvancedExperimental2.CodeSearchAgentEnabled = defineAndMigrateSetting("chat.advanced.codesearch.agent.enabled", "chat.codesearch.agent.enabled", true);
    AdvancedExperimental2.AgentTemperature = defineAndMigrateSetting("chat.advanced.agent.temperature", "chat.agent.temperature", void 0);
    AdvancedExperimental2.EnableUserPreferences = defineAndMigrateSetting("chat.advanced.enableUserPreferences", "chat.enableUserPreferences", false);
    AdvancedExperimental2.SummarizeAgentConversationHistoryThreshold = defineAndMigrateSetting("chat.advanced.summarizeAgentConversationHistoryThreshold", "chat.summarizeAgentConversationHistoryThreshold", void 0);
    AdvancedExperimental2.AgentHistorySummarizationMode = defineAndMigrateSetting("chat.advanced.agentHistorySummarizationMode", "chat.agentHistorySummarizationMode", void 0);
    AdvancedExperimental2.UseResponsesApiTruncation = defineAndMigrateSetting("chat.advanced.useResponsesApiTruncation", "chat.useResponsesApiTruncation", false);
    AdvancedExperimental2.OmitBaseAgentInstructions = defineAndMigrateSetting("chat.advanced.omitBaseAgentInstructions", "chat.omitBaseAgentInstructions", false);
    AdvancedExperimental2.ClaudeCodeDebugEnabled = defineAndMigrateSetting("chat.advanced.claudeCode.debug", "chat.claudeCode.debug", false);
    AdvancedExperimental2.CopilotCLIEnabled = defineAndMigrateSetting("chat.advanced.copilotCLI.enabled", "chat.copilotCLI.enabled", true);
    AdvancedExperimental2.GitHistoryRelatedFilesUsingEmbeddings = defineAndMigrateSetting("chat.advanced.suggestRelatedFilesFromGitHistory.useEmbeddings", "chat.suggestRelatedFilesFromGitHistory.useEmbeddings", false);
    AdvancedExperimental2.CLIIsolationEnabled = defineAndMigrateSetting("chat.advanced.cli.isolation.enabled", "chat.cli.isolation.enabled", false);
    AdvancedExperimental2.CLIMCPServerEnabled = defineAndMigrateSetting("chat.advanced.cli.mcp.enabled", "chat.cli.mcp.enabled", false);
    AdvancedExperimental2.EditSourceTrackingShowDecorations = defineAndMigrateSetting("chat.advanced.editSourceTracking.showDecorations", "chat.editSourceTracking.showDecorations", false);
    AdvancedExperimental2.EditSourceTrackingShowStatusBar = defineAndMigrateSetting("chat.advanced.editSourceTracking.showStatusBar", "chat.editSourceTracking.showStatusBar", false);
    AdvancedExperimental2.EnableClaudeCodeAgent = defineAndMigrateSetting("chat.advanced.claudeCode.enabled", "chat.claudeCode.enabled", false);
  })(AdvancedExperimental = ConfigKey2.AdvancedExperimental || (ConfigKey2.AdvancedExperimental = {}));
  let AdvancedExperimentalExperiments;
  ((AdvancedExperimentalExperiments2) => {
    AdvancedExperimentalExperiments2.ProjectLabelsExpanded = defineAndMigrateExpSetting("chat.advanced.projectLabels.expanded", "chat.projectLabels.expanded", false);
    AdvancedExperimentalExperiments2.ProjectLabelsChat = defineAndMigrateExpSetting("chat.advanced.projectLabels.chat", "chat.projectLabels.chat", false);
    AdvancedExperimentalExperiments2.ProjectLabelsInline = defineAndMigrateExpSetting("chat.advanced.projectLabels.inline", "chat.projectLabels.inline", false);
    AdvancedExperimentalExperiments2.WorkspaceMaxLocalIndexSize = defineAndMigrateExpSetting("chat.advanced.workspace.maxLocalIndexSize", "chat.workspace.maxLocalIndexSize", 1e5);
    AdvancedExperimentalExperiments2.WorkspaceEnableFullWorkspace = defineAndMigrateExpSetting("chat.advanced.workspace.enableFullWorkspace", "chat.workspace.enableFullWorkspace", true);
    AdvancedExperimentalExperiments2.WorkspaceEnableCodeSearch = defineAndMigrateExpSetting("chat.advanced.workspace.enableCodeSearch", "chat.workspace.enableCodeSearch", true);
    AdvancedExperimentalExperiments2.WorkspaceEnableEmbeddingsSearch = defineAndMigrateExpSetting("chat.advanced.workspace.enableEmbeddingsSearch", "chat.workspace.enableEmbeddingsSearch", true);
    AdvancedExperimentalExperiments2.WorkspacePreferredEmbeddingsModel = defineAndMigrateExpSetting("chat.advanced.workspace.preferredEmbeddingsModel", "chat.workspace.preferredEmbeddingsModel", "");
    AdvancedExperimentalExperiments2.NotebookAlternativeDocumentFormat = defineAndMigrateExpSetting("chat.advanced.notebook.alternativeFormat", "chat.notebook.alternativeFormat", "xml" /* xml */);
    AdvancedExperimentalExperiments2.UseAlternativeNESNotebookFormat = defineAndMigrateExpSetting("chat.advanced.notebook.alternativeNESFormat.enabled", "chat.notebook.alternativeNESFormat.enabled", false);
    AdvancedExperimentalExperiments2.TemporalContextMaxAge = defineAndMigrateExpSetting("chat.advanced.temporalContext.maxAge", "chat.temporalContext.maxAge", 100);
    AdvancedExperimentalExperiments2.TemporalContextPreferSameLang = defineAndMigrateExpSetting("chat.advanced.temporalContext.preferSameLang", "chat.temporalContext.preferSameLang", false);
    AdvancedExperimentalExperiments2.InstantApplyShortModelName = defineAndMigrateExpSetting("chat.advanced.instantApply.shortContextModelName", "chat.instantApply.shortContextModelName", "gpt-4o-instant-apply-full-ft-v66-short" /* SHORT_INSTANT_APPLY */);
    AdvancedExperimentalExperiments2.InstantApplyShortContextLimit = defineAndMigrateExpSetting("chat.advanced.instantApply.shortContextLimit", "chat.instantApply.shortContextLimit", 8e3);
    AdvancedExperimentalExperiments2.AgentHistorySummarizationWithPromptCache = defineAndMigrateExpSetting("chat.advanced.agentHistorySummarizationWithPromptCache", "chat.agentHistorySummarizationWithPromptCache", false);
    AdvancedExperimentalExperiments2.AgentHistorySummarizationForceGpt41 = defineAndMigrateExpSetting("chat.advanced.agentHistorySummarizationForceGpt41", "chat.agentHistorySummarizationForceGpt41", false);
    AdvancedExperimentalExperiments2.PromptFileContext = defineAndMigrateExpSetting("chat.advanced.promptFileContextProvider.enabled", "chat.promptFileContextProvider.enabled", true);
    AdvancedExperimentalExperiments2.DefaultToolsGrouped = defineAndMigrateExpSetting("chat.advanced.tools.defaultToolsGrouped", "chat.tools.defaultToolsGrouped", false);
    AdvancedExperimentalExperiments2.Gpt5AlternativePatch = defineAndMigrateExpSetting("chat.advanced.gpt5AlternativePatch", "chat.gpt5AlternativePatch", false);
    AdvancedExperimentalExperiments2.InlineEditsTriggerOnEditorChangeAfterSeconds = defineAndMigrateExpSetting("chat.advanced.inlineEdits.triggerOnEditorChangeAfterSeconds", "chat.inlineEdits.triggerOnEditorChangeAfterSeconds", { defaultValue: void 0, teamDefaultValue: 10 });
    AdvancedExperimentalExperiments2.InlineEditsNextCursorPredictionDisplayLine = defineAndMigrateExpSetting("chat.advanced.inlineEdits.nextCursorPrediction.displayLine", "chat.inlineEdits.nextCursorPrediction.displayLine", true);
    AdvancedExperimentalExperiments2.InlineEditsNextCursorPredictionCurrentFileMaxTokens = defineAndMigrateExpSetting("chat.advanced.inlineEdits.nextCursorPrediction.currentFileMaxTokens", "chat.inlineEdits.nextCursorPrediction.currentFileMaxTokens", DEFAULT_OPTIONS.currentFile.maxTokens);
    AdvancedExperimentalExperiments2.VirtualToolEmbeddingRanking = defineAndMigrateExpSetting("chat.advanced.virtualTools.embeddingRanking", "chat.virtualTools.embeddingRanking", false);
    AdvancedExperimentalExperiments2.MultiReplaceStringGrok = defineAndMigrateExpSetting("chat.advanced.multiReplaceStringGrok.enabled", "chat.multiReplaceStringGrok.enabled", false);
  })(AdvancedExperimentalExperiments = ConfigKey2.AdvancedExperimentalExperiments || (ConfigKey2.AdvancedExperimentalExperiments = {}));
  let Internal;
  ((Internal2) => {
    Internal2.DebugOverrideChatMaxTokenNum = defineSetting("chat.advanced.debug.overrideChatMaxTokenNum", 0, INTERNAL_RESTRICTED);
    Internal2.DebugReportFeedback = defineSetting("chat.advanced.debug.reportFeedback", { defaultValue: false, teamDefaultValue: true }, INTERNAL_RESTRICTED);
    Internal2.DebugCollectFetcherTelemetry = defineExpSetting("chat.advanced.debug.collectFetcherTelemetry", true, INTERNAL_RESTRICTED);
    Internal2.DebugExpUseNodeFetchFetcher = defineExpSetting("chat.advanced.debug.useNodeFetchFetcher", void 0, INTERNAL_RESTRICTED);
    Internal2.DebugExpUseNodeFetcher = defineExpSetting("chat.advanced.debug.useNodeFetcher", void 0, INTERNAL_RESTRICTED);
    Internal2.DebugExpUseElectronFetcher = defineExpSetting("chat.advanced.debug.useElectronFetcher", void 0, INTERNAL_RESTRICTED);
    Internal2.RequestLoggerMaxEntries = defineSetting("chat.advanced.debug.requestLogger.maxEntries", 100);
    Internal2.InlineEditsIgnoreCompletionsDisablement = defineValidatedSetting("chat.advanced.inlineEdits.ignoreCompletionsDisablement", vBoolean(), false, INTERNAL_RESTRICTED);
    Internal2.InlineEditsAsyncCompletions = defineExpSetting("chat.advanced.inlineEdits.asyncCompletions", true, INTERNAL_RESTRICTED);
    Internal2.InlineEditsDebounceUseCoreRequestTime = defineExpSetting("chat.advanced.inlineEdits.debounceUseCoreRequestTime", false, INTERNAL_RESTRICTED);
    Internal2.InlineEditsYieldToCopilot = defineExpSetting("chat.advanced.inlineEdits.yieldToCopilot", false, INTERNAL_RESTRICTED);
    Internal2.InlineEditsExcludedProviders = defineExpSetting("chat.advanced.inlineEdits.excludedProviders", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsEnableCompletionsProvider = defineExpSetting("chat.advanced.inlineEdits.completionsProvider.enabled", false, INTERNAL_RESTRICTED);
    Internal2.InlineEditsEnableGhCompletionsProvider = defineExpSetting("chat.advanced.inlineEdits.githubCompletionsProvider.enabled", false, INTERNAL_RESTRICTED);
    Internal2.InlineEditsCompletionsUrl = defineExpSetting("chat.advanced.inlineEdits.completionsProvider.url", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsLogContextRecorderEnabled = defineSetting("chat.advanced.inlineEdits.logContextRecorder.enabled", false, INTERNAL_RESTRICTED);
    Internal2.InlineEditsDebounce = defineExpSetting("chat.advanced.inlineEdits.debounce", 200, INTERNAL_RESTRICTED);
    Internal2.InlineEditsCacheDelay = defineExpSetting("chat.advanced.inlineEdits.cacheDelay", 300, INTERNAL_RESTRICTED);
    Internal2.InlineEditsSubsequentCacheDelay = defineExpSetting("chat.advanced.inlineEdits.subsequentCacheDelay", 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsRebasedCacheDelay = defineExpSetting("chat.advanced.inlineEdits.rebasedCacheDelay", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsBackoffDebounceEnabled = defineExpSetting("chat.advanced.inlineEdits.backoffDebounceEnabled", true, INTERNAL_RESTRICTED);
    Internal2.InlineEditsExtraDebounceEndOfLine = defineExpSetting("chat.advanced.inlineEdits.extraDebounceEndOfLine", 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsDebounceOnSelectionChange = defineExpSetting("chat.advanced.inlineEdits.debounceOnSelectionChange", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsProviderId = defineExpSetting("chat.advanced.inlineEdits.providerId", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsHideInternalInterface = defineValidatedSetting("chat.advanced.inlineEdits.hideInternalInterface", vBoolean(), false, INTERNAL_RESTRICTED);
    Internal2.InlineEditsLogCancelledRequests = defineValidatedSetting("chat.advanced.inlineEdits.logCancelledRequests", vBoolean(), false, INTERNAL_RESTRICTED);
    Internal2.InlineEditsUnification = defineExpSetting("chat.advanced.inlineEdits.unification", false, INTERNAL_RESTRICTED);
    Internal2.InlineEditsNextCursorPredictionEnabled = defineExpSetting("chat.advanced.inlineEdits.nextCursorPrediction.enabled", { defaultValue: void 0, teamDefaultValue: "onlyWithEdit" /* OnlyWithEdit */ }, INTERNAL_RESTRICTED);
    Internal2.InlineEditsNextCursorPredictionModelName = defineExpSetting("chat.advanced.inlineEdits.nextCursorPrediction.modelName", { defaultValue: void 0, teamDefaultValue: "xtab-cursor-jump-1104" }, INTERNAL_RESTRICTED);
    Internal2.InlineEditsNextCursorPredictionUrl = defineValidatedSetting("chat.advanced.inlineEdits.nextCursorPrediction.url", vString(), void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsNextCursorPredictionApiKey = defineValidatedSetting("chat.advanced.inlineEdits.nextCursorPrediction.apiKey", vString(), void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabProviderUrl = defineValidatedSetting("chat.advanced.inlineEdits.xtabProvider.url", vString(), void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabProviderApiKey = defineValidatedSetting("chat.advanced.inlineEdits.xtabProvider.apiKey", vString(), void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabProviderModelConfiguration = defineValidatedSetting("chat.advanced.inlineEdits.xtabProvider.modelConfiguration", MODEL_CONFIGURATION_VALIDATOR, { defaultValue: void 0, teamDefaultValue: { modelName: "puku-nes-codestral", promptingStrategy: "xtab275" /* Xtab275 */, includeTagsInCurrentFile: false } }, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabProviderModelConfigurationString = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.modelConfigurationString", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabProviderDefaultModelConfigurationString = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.defaultModelConfigurationString", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsInlineCompletionsEnabled = defineValidatedSetting("chat.advanced.inlineEdits.inlineCompletions.enabled", vBoolean(), true, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabProviderUsePrediction = defineValidatedSetting("chat.advanced.inlineEdits.xtabProvider.usePrediction", vBoolean(), true, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabProviderUseVaryingLinesAbove = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.useVaryingLinesAbove", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabProviderNLinesAbove = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.nLinesAbove", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabProviderNLinesBelow = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.nLinesBelow", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabProviderRetryWithNMoreLinesBelow = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.retryWithNMoreLinesBelow", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsAutoExpandEditWindowLines = defineExpSetting("chat.advanced.inlineEdits.autoExpandEditWindowLines", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabNRecentlyViewedDocuments = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.nRecentlyViewedDocuments", DEFAULT_OPTIONS.recentlyViewedDocuments.nDocuments, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabRecentlyViewedDocumentsMaxTokens = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.recentlyViewedDocuments.maxTokens", DEFAULT_OPTIONS.recentlyViewedDocuments.maxTokens, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabDiffNEntries = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.diffNEntries", DEFAULT_OPTIONS.diffHistory.nEntries, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabDiffMaxTokens = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.diffMaxTokens", DEFAULT_OPTIONS.diffHistory.maxTokens, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabProviderEmitFastCursorLineChange = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.emitFastCursorLineChange", true, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabIncludeViewedFiles = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.includeViewedFiles", DEFAULT_OPTIONS.recentlyViewedDocuments.includeViewedFiles, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabPageSize = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.pageSize", DEFAULT_OPTIONS.pagedClipping.pageSize, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabEditWindowMaxTokens = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.editWindowMaxTokens", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabIncludeTagsInCurrentFile = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.includeTagsInCurrentFile", DEFAULT_OPTIONS.currentFile.includeTags, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabCurrentFileMaxTokens = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.currentFileMaxTokens", DEFAULT_OPTIONS.currentFile.maxTokens, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabPrioritizeAboveCursor = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.currentFile.prioritizeAboveCursor", DEFAULT_OPTIONS.currentFile.prioritizeAboveCursor, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabDiffOnlyForDocsInPrompt = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.diffOnlyForDocsInPrompt", DEFAULT_OPTIONS.diffHistory.onlyForDocsInPrompt, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabDiffUseRelativePaths = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.diffUseRelativePaths", DEFAULT_OPTIONS.diffHistory.useRelativePaths, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabNNonSignificantLinesToConverge = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.nNonSignificantLinesToConverge", ResponseProcessor.DEFAULT_DIFF_PARAMS.nLinesToConverge, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabNSignificantLinesToConverge = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.nSignificantLinesToConverge", ResponseProcessor.DEFAULT_DIFF_PARAMS.nSignificantLinesToConverge, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabLanguageContextEnabled = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.languageContext.enabled", DEFAULT_OPTIONS.languageContext.enabled, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabLanguageContextEnabledLanguages = defineSetting("chat.advanced.inlineEdits.xtabProvider.languageContext.enabledLanguages", LANGUAGE_CONTEXT_ENABLED_LANGUAGES, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabLanguageContextMaxTokens = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.languageContext.maxTokens", DEFAULT_OPTIONS.languageContext.maxTokens, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabMaxMergeConflictLines = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.maxMergeConflictLines", void 0, INTERNAL_RESTRICTED);
    Internal2.InlineEditsXtabOnlyMergeConflictLines = defineExpSetting("chat.advanced.inlineEdits.xtabProvider.onlyMergeConflictLines", false, INTERNAL_RESTRICTED);
    Internal2.InlineEditsUndoInsertionFiltering = defineExpSetting("chat.advanced.inlineEdits.undoInsertionFiltering", "v1", INTERNAL_RESTRICTED);
    Internal2.InlineEditsDiagnosticsExplorationEnabled = defineSetting("chat.advanced.inlineEdits.inlineEditsDiagnosticsExplorationEnabled", false, INTERNAL_RESTRICTED);
    Internal2.InternalWelcomeHintEnabled = defineSetting("chat.advanced.welcomePageHint.enabled", { defaultValue: false, internalDefaultValue: true, teamDefaultValue: true }, INTERNAL_RESTRICTED);
    Internal2.InlineChatUseCodeMapper = defineSetting("chat.advanced.inlineChat.useCodeMapper", false, INTERNAL_RESTRICTED);
    Internal2.InstantApplyModelName = defineExpSetting("chat.advanced.instantApply.modelName", "gpt-4o-instant-apply-full-ft-v66", INTERNAL_RESTRICTED);
    Internal2.VerifyTextDocumentChanges = defineExpSetting("chat.advanced.inlineEdits.verifyTextDocumentChanges", false, INTERNAL_RESTRICTED);
    Internal2.DiagnosticsContextProvider = defineExpSetting("chat.advanced.inlineEdits.diagnosticsContextProvider.enabled", true);
    Internal2.EnableReadFileV2 = defineExpSetting("chat.advanced.enableReadFileV2", isPreRelease);
    Internal2.AskAgent = defineExpSetting("chat.advanced.enableAskAgent", { defaultValue: false, teamDefaultValue: true, internalDefaultValue: true });
  })(Internal = ConfigKey2.Internal || (ConfigKey2.Internal = {}));
  ConfigKey2.Enable = defineSetting("enable", {
    "*": true,
    "plaintext": false,
    "markdown": false,
    "scminput": false
  });
  ConfigKey2.selectedCompletionsModel = defineSetting("selectedCompletionModel", "");
  ConfigKey2.UseResponsesApi = defineExpSetting("chat.useResponsesApi", true);
  ConfigKey2.ResponsesApiReasoningEffort = defineExpSetting("chat.responsesApiReasoningEffort", "default");
  ConfigKey2.ResponsesApiReasoningSummary = defineExpSetting("chat.responsesApiReasoningSummary", "detailed");
  ConfigKey2.EnableChatImageUpload = defineExpSetting("chat.imageUpload.enabled", true);
  ConfigKey2.AnthropicThinkingEnabled = defineExpSetting("chat.anthropic.thinking.enabled", false);
  ConfigKey2.MaxAnthropicThinkingTokens = defineSetting("chat.anthropic.thinking.maxTokens", null);
  ConfigKey2.AnthropicWebSearchToolEnabled = defineExpSetting("chat.anthropic.tools.websearch.enabled", false);
  ConfigKey2.AnthropicWebSearchMaxUses = defineSetting("chat.anthropic.tools.websearch.maxUses", 5);
  ConfigKey2.AnthropicWebSearchAllowedDomains = defineSetting("chat.anthropic.tools.websearch.allowedDomains", []);
  ConfigKey2.AnthropicWebSearchBlockedDomains = defineSetting("chat.anthropic.tools.websearch.blockedDomains", []);
  ConfigKey2.AnthropicWebSearchUserLocation = defineSetting("chat.anthropic.tools.websearch.userLocation", null);
  ConfigKey2.MemoryToolEnabled = defineExpSetting("chat.tools.memory.enabled", false);
  ConfigKey2.CodeGenerationInstructions = defineSetting("chat.codeGeneration.instructions", []);
  ConfigKey2.TestGenerationInstructions = defineSetting("chat.testGeneration.instructions", []);
  ConfigKey2.CommitMessageGenerationInstructions = defineSetting("chat.commitMessageGeneration.instructions", []);
  ConfigKey2.PullRequestDescriptionGenerationInstructions = defineSetting("chat.pullRequestDescriptionGeneration.instructions", []);
  ConfigKey2.GenerateTestsCodeLens = defineSetting("chat.generateTests.codeLens", false);
  ConfigKey2.SetupTests = defineSetting("chat.setupTests.enabled", true);
  ConfigKey2.TypeScriptLanguageContext = defineExpSetting("chat.languageContext.typescript.enabled", false);
  ConfigKey2.TypeScriptLanguageContextMode = defineExpSetting("chat.languageContext.typescript.items", "minimal");
  ConfigKey2.TypeScriptLanguageContextIncludeDocumentation = defineExpSetting("chat.languageContext.typescript.includeDocumentation", false);
  ConfigKey2.TypeScriptLanguageContextCacheTimeout = defineExpSetting("chat.languageContext.typescript.cacheTimeout", 500);
  ConfigKey2.TypeScriptLanguageContextFix = defineExpSetting("chat.languageContext.fix.typescript.enabled", false);
  ConfigKey2.TypeScriptLanguageContextInline = defineExpSetting("chat.languageContext.inline.typescript.enabled", false);
  ConfigKey2.UseInstructionFiles = defineSetting("chat.codeGeneration.useInstructionFiles", true);
  ConfigKey2.ReviewAgent = defineSetting("chat.reviewAgent.enabled", true);
  ConfigKey2.CodeFeedback = defineSetting("chat.reviewSelection.enabled", true);
  ConfigKey2.CodeFeedbackInstructions = defineSetting("chat.reviewSelection.instructions", []);
  ConfigKey2.UseProjectTemplates = defineSetting("chat.useProjectTemplates", true);
  ConfigKey2.ExplainScopeSelection = defineSetting("chat.scopeSelection", false);
  ConfigKey2.EnableCodeActions = defineSetting("editor.enableCodeActions", true);
  ConfigKey2.LocaleOverride = defineSetting("chat.localeOverride", "auto");
  ConfigKey2.TerminalChatLocation = defineSetting("chat.terminalChatLocation", "chatView");
  ConfigKey2.AutomaticRenameSuggestions = defineSetting("renameSuggestions.triggerAutomatically", true);
  ConfigKey2.GitHistoryRelatedFilesProvider = defineSetting("chat.edits.suggestRelatedFilesFromGitHistory", true);
  ConfigKey2.Test2SrcRelatedFilesProvider = defineSetting("chat.edits.suggestRelatedFilesForTests", true);
  ConfigKey2.TerminalToDebuggerEnabled = defineSetting("chat.copilotDebugCommand.enabled", true);
  ConfigKey2.CodeSearchAgentEnabled = defineSetting("chat.codesearch.enabled", false);
  ConfigKey2.InlineEditsEnabled = defineExpSetting("nextEditSuggestions.enabled", { defaultValue: false, teamDefaultValue: true });
  ConfigKey2.InlineEditsEnableDiagnosticsProvider = defineExpSetting("nextEditSuggestions.fixes", { defaultValue: true, teamDefaultValue: true });
  ConfigKey2.InlineEditsAllowWhitespaceOnlyChanges = defineExpSetting("nextEditSuggestions.allowWhitespaceOnlyChanges", true);
  ConfigKey2.NewWorkspaceCreationAgentEnabled = defineSetting("chat.newWorkspaceCreation.enabled", true);
  ConfigKey2.NewWorkspaceUseContext7 = defineSetting("chat.newWorkspace.useContext7", false);
  ConfigKey2.SummarizeAgentConversationHistory = defineSetting("chat.summarizeAgentConversationHistory.enabled", true);
  ConfigKey2.VirtualToolThreshold = defineExpSetting("chat.virtualTools.threshold", HARD_TOOL_LIMIT);
  ConfigKey2.CurrentEditorAgentContext = defineSetting("chat.agent.currentEditorContext.enabled", true);
  ConfigKey2.PukuAIEndpoint = defineSetting("pukuai.endpoint", "https://api.puku.sh");
  ConfigKey2.PukuAIModel = defineSetting("pukuai.model", "puku-ai");
  ConfigKey2.OllamaEndpoint = defineSetting("chat.byok.ollamaEndpoint", "http://localhost:11434");
  ConfigKey2.AzureModels = defineSetting("chat.azureModels", {});
  ConfigKey2.CustomOAIModels = defineSetting("chat.customOAIModels", {});
  ConfigKey2.AutoFixDiagnostics = defineExpSetting("chat.agent.autoFix", true);
  ConfigKey2.NotebookFollowCellExecution = defineSetting("chat.notebook.followCellExecution.enabled", false);
  ConfigKey2.UseAlternativeNESNotebookFormat = defineExpSetting("chat.notebook.enhancedNextEditSuggestions.enabled", false);
  ConfigKey2.CustomInstructionsInSystemMessage = defineSetting("chat.customInstructionsInSystemMessage", true);
  ConfigKey2.EnableAlternateGptPrompt = defineExpSetting("chat.alternateGptPrompt.enabled", false);
  ConfigKey2.CompletionsFetcher = defineExpSetting("chat.completionsFetcher", void 0);
  ConfigKey2.NextEditSuggestionsFetcher = defineExpSetting("chat.nesFetcher", void 0);
})(ConfigKey || (ConfigKey = {}));

// src/platform/authentication/common/copilotTokenStore.ts
init_event();
init_lifecycle();
var ICopilotTokenStore = createDecorator("ICopilotTokenStore");
var CopilotTokenStore = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onDidStoreUpdate = this._register(new Emitter());
    this.onDidStoreUpdate = this._onDidStoreUpdate.event;
  }
  get copilotToken() {
    return this._copilotToken;
  }
  set copilotToken(token) {
    const oldToken = this._copilotToken?.token;
    this._copilotToken = token;
    if (oldToken !== token?.token) {
      this._onDidStoreUpdate.fire();
    }
  }
};

// src/platform/telemetry/common/telemetry.ts
var ITelemetryUserConfig = createDecorator("ITelemetryUserConfig");
var TelemetryUserConfigImpl = class {
  constructor(trackingId, optedIn, _tokenStore) {
    this._tokenStore = _tokenStore;
    this.trackingId = trackingId;
    this.optedIn = optedIn ?? false;
    this.setupUpdateOnToken();
  }
  setupUpdateOnToken() {
    this._tokenStore.onDidStoreUpdate(() => {
      const token = this._tokenStore.copilotToken;
      if (!token) {
        return;
      }
      const enhancedTelemetry = token.getTokenValue("rt") === "1";
      const trackingId = token.getTokenValue("tid");
      if (trackingId !== void 0) {
        this.trackingId = trackingId;
        this.organizationsList = token.organizationList.toString();
        this.optedIn = enhancedTelemetry;
      }
    });
  }
};
TelemetryUserConfigImpl = __decorateClass([
  __decorateParam(2, ICopilotTokenStore)
], TelemetryUserConfigImpl);
var ITelemetryService = createDecorator("ITelemetryService");
var MAX_PROPERTY_LENGTH = 8192;
var MAX_CONCATENATED_PROPERTIES = 50;
function multiplexProperties(properties) {
  const newProperties = { ...properties };
  for (const key in properties) {
    const value = properties[key];
    let remainingValueCharactersLength = value?.length ?? 0;
    if (remainingValueCharactersLength > MAX_PROPERTY_LENGTH) {
      let lastStartIndex = 0;
      let newPropertiesCount = 0;
      while (remainingValueCharactersLength > 0 && newPropertiesCount < MAX_CONCATENATED_PROPERTIES) {
        newPropertiesCount += 1;
        let propertyName = key;
        if (newPropertiesCount > 1) {
          propertyName = key + "_" + (newPropertiesCount < 10 ? "0" : "") + newPropertiesCount;
        }
        let offsetIndex = lastStartIndex + MAX_PROPERTY_LENGTH;
        if (remainingValueCharactersLength < MAX_PROPERTY_LENGTH) {
          offsetIndex = lastStartIndex + remainingValueCharactersLength;
        }
        newProperties[propertyName] = value.slice(lastStartIndex, offsetIndex);
        remainingValueCharactersLength -= MAX_PROPERTY_LENGTH;
        lastStartIndex += MAX_PROPERTY_LENGTH;
      }
    }
  }
  return newProperties;
}

// src/platform/inlineEdits/common/nesActivationStatusTelemetry.contribution.ts
var NesActivationTelemetryContribution = class {
  constructor(_telemetryService, _configurationService, _expService) {
    const completionsConfigValue = _configurationService.getConfig(ConfigKey.Enable);
    const isCompletionsEnabled = "*" in completionsConfigValue ? completionsConfigValue["*"] : true;
    const isCompletionsUserConfigured = _configurationService.isConfigured(ConfigKey.Enable);
    const isNesEnabled = _configurationService.getExperimentBasedConfig(ConfigKey.InlineEditsEnabled, _expService);
    const isNesUserConfigured = _configurationService.isConfigured(ConfigKey.InlineEditsEnabled);
    _telemetryService.sendMSFTTelemetryEvent(
      "nesStatusOnActivation",
      {},
      {
        isCompletionsEnabled: toNumber(isCompletionsEnabled),
        isCompletionsUserConfigured: toNumber(isCompletionsUserConfigured),
        isNesEnabled: toNumber(isNesEnabled),
        isNesUserConfigured: toNumber(isNesUserConfigured)
      }
    );
  }
};
NesActivationTelemetryContribution = __decorateClass([
  __decorateParam(0, ITelemetryService),
  __decorateParam(1, IConfigurationService),
  __decorateParam(2, IExperimentationService)
], NesActivationTelemetryContribution);
function toNumber(v) {
  return v ? 1 : 0;
}

// src/extension/context/vscode/context.contribution.ts
var context_contribution_exports = {};
__export(context_contribution_exports, {
  create: () => create
});
var import_vscode3 = require("vscode");
init_lifecycle();
function create(accessor) {
  const disposables = new DisposableStore();
  disposables.add(registerContextCommands(accessor));
  return disposables;
}
function registerContextCommands(accessor) {
  return import_vscode3.Disposable.from(
    import_vscode3.commands.registerCommand("puku.chat.attachFile", () => {
      return import_vscode3.commands.executeCommand("workbench.action.chat.attachFile");
    }),
    import_vscode3.commands.registerCommand("puku.chat.attachSelection", () => {
      return import_vscode3.commands.executeCommand("workbench.action.chat.attachSelection");
    })
  );
}

// src/extension/telemetry/common/lifecycleTelemetryContrib.ts
var LifecycleTelemetryContrib = class {
  constructor(telemetryService) {
    this.telemetryService = telemetryService;
    telemetryService.sendGHTelemetryEvent("extension.activate");
  }
  dispose() {
    this.telemetryService.sendGHTelemetryEvent("extension.deactivate");
  }
};
LifecycleTelemetryContrib = __decorateClass([
  __decorateParam(0, ITelemetryService)
], LifecycleTelemetryContrib);

// src/extension/telemetry/vscode/githubTelemetryForwardingContrib.ts
var import_vscode4 = require("vscode");

// src/platform/git/common/gitService.ts
init_strings();
var IGitService = createDecorator("IGitService");
function getGitHubRepoInfoFromContext(repoContext) {
  for (const remoteUrl of getOrderedRemoteUrlsFromContext(repoContext)) {
    if (remoteUrl) {
      const id2 = getGithubRepoIdFromFetchUrl(remoteUrl);
      if (id2) {
        return { id: id2, remoteUrl };
      }
    }
  }
  return void 0;
}
function getOrderedRemoteUrlsFromContext(repoContext) {
  const out = /* @__PURE__ */ new Set();
  if (repoContext.remoteFetchUrls?.length === 1) {
    out.add(repoContext.remoteFetchUrls[0]);
    return out;
  }
  const remoteIndex = repoContext.remotes.findIndex((r) => r === repoContext.upstreamRemote);
  if (remoteIndex !== -1) {
    const fetchUrl = repoContext.remoteFetchUrls?.[remoteIndex];
    if (fetchUrl) {
      out.add(fetchUrl);
    }
  }
  const originIndex = repoContext.remotes.findIndex((r) => r === "origin");
  if (originIndex !== -1) {
    const fetchUrl = repoContext.remoteFetchUrls?.[originIndex];
    if (fetchUrl) {
      out.add(fetchUrl);
    }
  }
  for (const remote of repoContext.remoteFetchUrls ?? []) {
    if (remote) {
      out.add(remote);
    }
  }
  return out;
}
function parseRemoteUrl(fetchUrl) {
  fetchUrl = fetchUrl.trim();
  try {
    if (/^[\w\d\-]+@/i.test(fetchUrl)) {
      const parts = fetchUrl.split(":");
      if (parts.length !== 2) {
        return void 0;
      }
      fetchUrl = "ssh://" + parts[0] + "/" + parts[1];
    }
    const repoUrl = URI.parse(fetchUrl);
    const authority = repoUrl.authority;
    const path = repoUrl.path;
    if (!(equalsIgnoreCase(repoUrl.scheme, "ssh") || equalsIgnoreCase(repoUrl.scheme, "https") || equalsIgnoreCase(repoUrl.scheme, "http"))) {
      return;
    }
    const splitAuthority = authority.split("@");
    if (splitAuthority.length > 2) {
      return void 0;
    }
    const extractedHost = splitAuthority.at(-1);
    if (!extractedHost) {
      return;
    }
    const normalizedHost = extractedHost.toLowerCase().replace(/:\d+$/, "").replace(/^[\w\-]+-/, "").replace(/-[\w\-]+$/, "");
    return { host: normalizedHost, path };
  } catch (err) {
    return void 0;
  }
}
var GithubRepoId = class _GithubRepoId {
  constructor(org, repo) {
    this.org = org;
    this.repo = repo;
    this.type = "github";
  }
  static parse(nwo) {
    const parts = nwo.split("/");
    if (parts.length !== 2) {
      return void 0;
    }
    return new _GithubRepoId(parts[0], parts[1]);
  }
  toString() {
    return toGithubNwo(this);
  }
};
function toGithubNwo(id2) {
  return `${id2.org}/${id2.repo}`.toLowerCase();
}
function getGithubRepoIdFromFetchUrl(fetchUrl) {
  const parsed = parseRemoteUrl(fetchUrl);
  if (!parsed) {
    return void 0;
  }
  const topLevelUrls = ["github.com", "ghe.com"];
  const matchedHost = topLevelUrls.find((topLevelUrl) => parsed.host === topLevelUrl || parsed.host.endsWith("." + topLevelUrl));
  if (!matchedHost) {
    return;
  }
  const pathMatch = parsed.path.match(/^\/?([^/]+)\/([^/]+?)(\/|\.git\/?)?$/i);
  return pathMatch ? new GithubRepoId(pathMatch[1], pathMatch[2]) : void 0;
}

// src/extension/telemetry/vscode/githubTelemetryForwardingContrib.ts
init_lifecycle();
var GithubTelemetryForwardingContrib = class extends Disposable {
  constructor(_telemetryService, _gitService) {
    super();
    this._telemetryService = _telemetryService;
    this._gitService = _gitService;
    const channel = import_vscode4.env.getDataChannel("editTelemetry");
    this._register(channel.onDidReceiveData((args) => {
      const r = this._gitService.activeRepository.get();
      const id2 = r ? getGitHubRepoInfoFromContext(r)?.id : void 0;
      const data = translateToGithubProperties(args.data.data, id2);
      const { properties, measurements } = dataToPropsAndMeasurements(data);
      this._telemetryService.sendGHTelemetryEvent("vscode." + args.data.eventName, properties, measurements);
    }));
  }
};
GithubTelemetryForwardingContrib = __decorateClass([
  __decorateParam(0, ITelemetryService),
  __decorateParam(1, IGitService)
], GithubTelemetryForwardingContrib);
function translateToGithubProperties(data, githubRepo) {
  if (githubRepo) {
    data["githubOrg"] = githubRepo.org;
    data["githubRepo"] = githubRepo.repo;
  }
  return data;
}
function dataToPropsAndMeasurements(data) {
  const properties = {};
  const measurements = {};
  for (const [key, value] of Object.entries(data)) {
    if (typeof value === "number") {
      measurements[key] = value;
    } else if (typeof value === "boolean") {
      measurements[key] = value ? 1 : 0;
    } else {
      properties[key] = value;
    }
  }
  return { properties, measurements };
}

// src/extension/extension/vscode/contributions.ts
var vscodeContributions = [
  asContributionFactory(LifecycleTelemetryContrib),
  asContributionFactory(NesActivationTelemetryContribution),
  asContributionFactory(GithubTelemetryForwardingContrib),
  context_contribution_exports
];
var contributions_default = vscodeContributions;

// src/extension/extension/vscode-worker/contributions.ts
var vscodeWebContributions = [
  ...contributions_default
];

// src/extension/extension/vscode/services.ts
var import_vscode18 = require("vscode");

// src/platform/authentication/common/authenticationUpgrade.ts
var IAuthenticationChatUpgradeService = createDecorator("IAuthenticationChatUpgradeService");
var AuthenticationChatUpgradeService = class {
  async shouldRequestPermissiveSessionUpgrade() {
    return false;
  }
  async showPermissiveSessionModal(_force) {
    return false;
  }
};

// src/platform/chat/common/blockedExtensionService.ts
var IBlockedExtensionService = createDecorator("IBlockedExtensionService");
var BlockedExtensionService = class {
  constructor() {
    this.blockedExtensions = /* @__PURE__ */ new Map();
  }
  reportBlockedExtension(extensionId, timeout2) {
    if (this.blockedExtensions.has(extensionId)) {
      clearTimeout(this.blockedExtensions.get(extensionId));
    }
    const timer = setTimeout(() => {
      this.blockedExtensions.delete(extensionId);
    }, timeout2 * 1e3);
    this.blockedExtensions.set(extensionId, timer);
  }
  isExtensionBlocked(extensionId) {
    return this.blockedExtensions.has(extensionId);
  }
};

// src/platform/chat/common/chatQuotaService.ts
var IChatQuotaService = createDecorator("IChatQuotaService");

// src/platform/chat/common/chatQuotaServiceImpl.ts
init_lifecycle();

// src/platform/authentication/common/authentication.ts
init_event();
init_lifecycle();

// src/platform/authentication/common/copilotTokenManager.ts
var ICopilotTokenManager = createDecorator("ICopilotTokenManager");

// src/platform/authentication/common/authentication.ts
var IAuthenticationService = createDecorator("IAuthenticationService");
var BaseAuthenticationService = class extends Disposable {
  constructor(_logService, _tokenStore, _tokenManager, _configurationService) {
    super();
    this._logService = _logService;
    this._tokenStore = _tokenStore;
    this._tokenManager = _tokenManager;
    this._configurationService = _configurationService;
    this._onDidAuthenticationChange = this._register(new Emitter());
    this.onDidAuthenticationChange = this._onDidAuthenticationChange.event;
    this._onDidAccessTokenChange = this._register(new Emitter());
    this.onDidAccessTokenChange = this._onDidAccessTokenChange.event;
    this._onDidAdoAuthenticationChange = this._register(new Emitter());
    this.onDidAdoAuthenticationChange = this._onDidAdoAuthenticationChange.event;
    //#region isMinimalMode
    this._isMinimalMode = derived((r) => this._configurationService.getConfigObservable(ConfigKey.Shared.AuthPermissions).read(r) === "minimal" /* Minimal */);
    this._register(_tokenManager.onDidCopilotTokenRefresh(() => {
      this._logService.debug("Handling CopilotToken refresh.");
      void this._handleAuthChangeEvent();
    }));
  }
  get isMinimalMode() {
    return this._isMinimalMode.get();
  }
  get anyGitHubSession() {
    return void 0;
  }
  get permissiveGitHubSession() {
    return void 0;
  }
  get anyAdoSession() {
    return this._anyAdoSession;
  }
  get copilotToken() {
    return this._tokenStore.copilotToken;
  }
  async getCopilotToken(force) {
    try {
      const token = await this._tokenManager.getCopilotToken(force);
      this._tokenStore.copilotToken = token;
      this._copilotTokenError = void 0;
      return token;
    } catch (afterError) {
      this._tokenStore.copilotToken = void 0;
      if (afterError instanceof Error && afterError.name === "PukuLoginRequired") {
        this._logService.debug("PukuLoginRequired error caught - auth flow will handle sign-in");
        throw afterError;
      }
      const beforeError = this._copilotTokenError;
      this._copilotTokenError = afterError;
      if (beforeError && afterError && beforeError.message !== afterError.message) {
        this._onDidAuthenticationChange.fire();
      }
      throw afterError;
    }
  }
  resetCopilotToken(httpError) {
    this._tokenStore.copilotToken = void 0;
    this._tokenManager.resetCopilotToken(httpError);
  }
  //#endregion
  async _handleAuthChangeEvent() {
    const anyAdoSessionBefore = this._anyAdoSession;
    const copilotTokenBefore = this._tokenStore.copilotToken;
    const copilotTokenErrorBefore = this._copilotTokenError;
    const resolved = await Promise.allSettled([
      this.getAnyAdoSession({ silent: true })
    ]);
    for (const res of resolved) {
      if (res.status === "rejected") {
        this._logService.error(`Error getting a session: ${res.reason}`);
      }
    }
    if (anyAdoSessionBefore?.accessToken !== this._anyAdoSession?.accessToken) {
      this._logService.debug(`Ado auth state changed, firing event. Had token before: ${!!anyAdoSessionBefore?.accessToken}. Has token now: ${!!this._anyAdoSession?.accessToken}.`);
      this._onDidAdoAuthenticationChange.fire();
    }
    try {
      await this.getCopilotToken();
    } catch (e) {
    }
    if (copilotTokenBefore?.token !== this._tokenStore.copilotToken?.token || // React to errors changing too (i.e. I go from zero session to a session that doesn't have Puku access)
    copilotTokenErrorBefore?.message !== this._copilotTokenError?.message) {
      this._logService.debug("Puku token state changed, firing event.");
      this._onDidAuthenticationChange.fire();
    }
    this._logService.debug("Finished handling auth change event.");
  }
};
BaseAuthenticationService = __decorateClass([
  __decorateParam(0, ILogService),
  __decorateParam(1, ICopilotTokenStore),
  __decorateParam(2, ICopilotTokenManager),
  __decorateParam(3, IConfigurationService)
], BaseAuthenticationService);

// src/platform/chat/common/chatQuotaServiceImpl.ts
var ChatQuotaService = class extends Disposable {
  constructor(_authService) {
    super();
    this._authService = _authService;
    this._register(this._authService.onDidAuthenticationChange(() => {
      this.processUserInfoQuotaSnapshot(this._authService.copilotToken?.quotaInfo);
    }));
  }
  get quotaExhausted() {
    if (!this._quotaInfo) {
      return false;
    }
    return this._quotaInfo.used >= this._quotaInfo.quota && !this._quotaInfo.overageEnabled && !this._quotaInfo.unlimited;
  }
  get overagesEnabled() {
    if (!this._quotaInfo) {
      return false;
    }
    return this._quotaInfo.overageEnabled;
  }
  clearQuota() {
    this._quotaInfo = void 0;
  }
  processQuotaHeaders(headers) {
    const quotaHeader = this._authService.copilotToken?.isFreeUser ? headers.get("x-quota-snapshot-chat") : headers.get("x-quota-snapshot-premium_models") || headers.get("x-quota-snapshot-premium_interactions");
    if (!quotaHeader) {
      return;
    }
    try {
      const params = new URLSearchParams(quotaHeader);
      const entitlement = parseInt(params.get("ent") || "0", 10);
      const overageUsed = parseFloat(params.get("ov") || "0.0");
      const overageEnabled = params.get("ovPerm") === "true";
      const percentRemaining = parseFloat(params.get("rem") || "0.0");
      const resetDateString = params.get("rst");
      let resetDate;
      if (resetDateString) {
        resetDate = new Date(resetDateString);
      } else {
        resetDate = /* @__PURE__ */ new Date();
        resetDate.setMonth(resetDate.getMonth() + 1);
      }
      const used = Math.max(0, entitlement * (1 - percentRemaining / 100));
      this._quotaInfo = {
        quota: entitlement,
        unlimited: entitlement === -1,
        used,
        overageUsed,
        overageEnabled,
        resetDate
      };
    } catch (error2) {
      console.error("Failed to parse quota header", error2);
    }
  }
  processUserInfoQuotaSnapshot(quotaInfo) {
    if (!quotaInfo || !quotaInfo.quota_snapshots || !quotaInfo.quota_reset_date) {
      return;
    }
    this._quotaInfo = {
      unlimited: quotaInfo.quota_snapshots.premium_interactions.unlimited,
      overageEnabled: quotaInfo.quota_snapshots.premium_interactions.overage_permitted,
      overageUsed: quotaInfo.quota_snapshots.premium_interactions.overage_count,
      quota: quotaInfo.quota_snapshots.premium_interactions.entitlement,
      resetDate: new Date(quotaInfo.quota_reset_date),
      used: Math.max(0, quotaInfo.quota_snapshots.premium_interactions.entitlement * (1 - quotaInfo.quota_snapshots.premium_interactions.percent_remaining / 100))
    };
  }
};
ChatQuotaService = __decorateClass([
  __decorateParam(0, IAuthenticationService)
], ChatQuotaService);

// src/platform/chat/common/chatSessionService.ts
var IChatSessionService = createDecorator("IChatSessionService");

// src/platform/chat/common/conversationOptions.ts
var IConversationOptions = createDecorator("ConversationOptions");

// src/util/vs/base/common/uuid.ts
var generateUuid = (function() {
  if (typeof crypto.randomUUID === "function") {
    return crypto.randomUUID.bind(crypto);
  }
  const _data = new Uint8Array(16);
  const _hex = [];
  for (let i = 0; i < 256; i++) {
    _hex.push(i.toString(16).padStart(2, "0"));
  }
  return function generateUuid2() {
    crypto.getRandomValues(_data);
    _data[6] = _data[6] & 15 | 64;
    _data[8] = _data[8] & 63 | 128;
    let i = 0;
    let result = "";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    return result;
  };
})();

// src/platform/chat/common/interactionService.ts
var IInteractionService = createDecorator("IInteractionService");
var InteractionService = class {
  constructor() {
    this._interactionId = generateUuid();
  }
  startInteraction() {
    this._interactionId = generateUuid();
  }
  get interactionId() {
    return this._interactionId;
  }
};

// src/platform/chat/vscode/chatSessionService.ts
var vscode = __toESM(require("vscode"));
var ChatSessionService = class {
  get onDidDisposeChatSession() {
    return vscode.chat.onDidDisposeChatSession;
  }
};

// src/platform/commands/common/runCommandExecutionService.ts
var IRunCommandExecutionService = createDecorator("IRunCommandExecutionService");

// src/platform/commands/vscode/runCommandExecutionServiceImpl.ts
var vscode2 = __toESM(require("vscode"));
init_lifecycle();
var RunCommandExecutionServiceImpl = class extends Disposable {
  constructor(telemetryService) {
    super();
    this.telemetryService = telemetryService;
  }
  async executeCommand(command, ...args) {
    try {
      const result = vscode2.commands.executeCommand(command, ...args);
      this.telemetryService.sendMSFTTelemetryEvent("automaticCommandExecutedSucceeded", { command, args: args?.join(",") });
      return result;
    } catch (e) {
      this.telemetryService.sendMSFTTelemetryEvent("automaticCommandExecutedFailed", { command, args: args?.join(","), e });
    }
  }
};
RunCommandExecutionServiceImpl = __decorateClass([
  __decorateParam(0, ITelemetryService)
], RunCommandExecutionServiceImpl);

// src/platform/configuration/vscode/configurationServiceImpl.ts
var vscode3 = __toESM(require("vscode"));
init_arrays();
function stringOrStringify(value) {
  if (typeof value === "string") {
    return value;
  }
  return JSON.stringify(value);
}
var ConfigurationServiceImpl = class extends AbstractConfigurationService {
  constructor(copilotTokenStore) {
    super(copilotTokenStore);
    this.config = vscode3.workspace.getConfiguration(CopilotConfigPrefix);
    vscode3.workspace.onDidChangeConfiguration((changeEvent) => {
      if (changeEvent.affectsConfiguration(CopilotConfigPrefix)) {
        this.config = vscode3.workspace.getConfiguration(CopilotConfigPrefix);
      }
      this._onDidChangeConfiguration.fire({
        affectsConfiguration: (section, scope) => {
          if (changeEvent.affectsConfiguration(section, scope)) {
            return true;
          }
          const oldId = globalConfigRegistry.configs.get(section)?.fullyQualifiedOldId;
          if (oldId && changeEvent.affectsConfiguration(oldId, scope)) {
            return true;
          }
          return false;
        }
      });
    });
  }
  getConfig(key, scope) {
    if (key.options?.valueIgnoredForExternals && !this._isInternal) {
      return this.getDefaultValue(key);
    }
    const config3 = scope === void 0 ? this.config : vscode3.workspace.getConfiguration(CopilotConfigPrefix, scope);
    let configuredValue;
    if (key.advancedSubKey) {
      const advancedConfigFlatStyleValue = config3.get(key.id);
      if (advancedConfigFlatStyleValue !== void 0) {
        configuredValue = advancedConfigFlatStyleValue;
      } else {
        const advancedConfig = config3.get("advanced");
        configuredValue = advancedConfig?.[key.advancedSubKey];
      }
    } else {
      const hasCustomDefaultValue = ConfigValueValidators.isDefaultValueWithTeamAndInternalValue(key.defaultValue) || ConfigValueValidators.isDefaultValueWithTeamValue(key.defaultValue);
      const userIsInternalOrTeamMember = this._isInternal || this._isTeamMember;
      if (key.isPublic && hasCustomDefaultValue && userIsInternalOrTeamMember) {
        if (this.isConfigured(key, scope)) {
          configuredValue = config3.get(key.id) ?? (key.oldId ? config3.get(key.oldId) : void 0);
        }
      } else {
        if (key.oldId && key.oldId.startsWith("chat.advanced")) {
          if (this.isConfigured(key, scope)) {
            configuredValue = config3.get(key.id) ?? (key.oldId ? config3.get(key.oldId) : void 0);
          }
        } else {
          configuredValue = config3.get(key.id) ?? (key.oldId ? config3.get(key.oldId) : void 0);
        }
      }
    }
    if (configuredValue === void 0) {
      return this.getDefaultValue(key);
    }
    if (!key.validator) {
      return configuredValue;
    }
    const value = key.validator.validate(configuredValue);
    if (value.error) {
      console.error(`Could not read "${key.fullyQualifiedId}": ${value.error.message}`);
      return this.getDefaultValue(key);
    }
    return value.content;
  }
  inspectConfig(key, scope) {
    if (key.options?.valueIgnoredForExternals && !this._isInternal) {
      return { defaultValue: this.getDefaultValue(key) };
    }
    const config3 = scope === void 0 ? this.config : vscode3.workspace.getConfiguration(CopilotConfigPrefix, scope);
    const inspectResult = config3.inspect(key.id);
    if (!key.oldId) {
      return inspectResult;
    }
    const oldInspectResult = config3.inspect(key.oldId);
    const languageIds = distinct([...inspectResult?.languageIds ?? [], ...oldInspectResult?.languageIds ?? []]);
    return {
      defaultValue: inspectResult?.defaultValue ?? oldInspectResult?.defaultValue,
      globalValue: inspectResult?.globalValue ?? oldInspectResult?.globalValue,
      workspaceValue: inspectResult?.workspaceValue ?? oldInspectResult?.workspaceValue,
      workspaceFolderValue: inspectResult?.workspaceFolderValue ?? oldInspectResult?.workspaceFolderValue,
      defaultLanguageValue: inspectResult?.defaultLanguageValue ?? oldInspectResult?.defaultLanguageValue,
      globalLanguageValue: inspectResult?.globalLanguageValue ?? oldInspectResult?.globalLanguageValue,
      workspaceLanguageValue: inspectResult?.workspaceLanguageValue ?? oldInspectResult?.workspaceLanguageValue,
      workspaceFolderLanguageValue: inspectResult?.workspaceFolderLanguageValue ?? oldInspectResult?.workspaceFolderLanguageValue,
      languageIds: languageIds.length ? languageIds : void 0
    };
  }
  getNonExtensionConfig(configKey) {
    return vscode3.workspace.getConfiguration().get(configKey);
  }
  _getTargetFromInspect(inspect) {
    let target;
    if (!inspect) {
      target = vscode3.ConfigurationTarget.Global;
    } else if (inspect.workspaceFolderValue !== void 0) {
      target = vscode3.ConfigurationTarget.WorkspaceFolder;
    } else if (inspect.workspaceValue !== void 0) {
      target = vscode3.ConfigurationTarget.Workspace;
    } else {
      target = vscode3.ConfigurationTarget.Global;
    }
    return target;
  }
  setConfig(key, value) {
    if (key.advancedSubKey) {
      const flatConfigStyle = this.config.inspect(key.id);
      const hasFlatStyle = flatConfigStyle?.globalValue !== void 0 || flatConfigStyle?.workspaceFolderValue !== void 0 || flatConfigStyle?.workspaceValue !== void 0;
      if (hasFlatStyle) {
        throw new Error(`Cannot write to "${key.fullyQualifiedId}". Please update the setting manually to ${JSON.stringify(value)}.`);
      }
      let currentValue = this.config.get("advanced");
      if (!currentValue) {
        currentValue = {
          [key.advancedSubKey]: value
        };
      } else {
        currentValue[key.advancedSubKey] = value;
      }
      return this.config.update("advanced", currentValue, this._getTargetFromInspect(this.config.inspect("advanced")));
    }
    return this.config.update(key.id, value, this._getTargetFromInspect(this.config.inspect(key.id)));
  }
  getExperimentBasedConfig(key, experimentationService, scope) {
    const configuredValue = this._getUserConfiguredValueForExperimentBasedConfig(key, scope);
    if (configuredValue !== void 0) {
      return configuredValue;
    }
    if (key.experimentName) {
      const expValue3 = experimentationService.getTreatmentVariable(key.experimentName);
      if (expValue3 !== void 0) {
        return expValue3;
      }
    }
    const expValue = experimentationService.getTreatmentVariable(`copilotchat.config.${key.id}`);
    if (expValue !== void 0) {
      return expValue;
    }
    const expValue2 = experimentationService.getTreatmentVariable(`config.${key.fullyQualifiedId}`);
    if (expValue2 !== void 0) {
      return expValue2;
    }
    if (key.fullyQualifiedOldId) {
      const oldExpValue = experimentationService.getTreatmentVariable(`copilotchat.config.${key.oldId}`);
      if (oldExpValue !== void 0) {
        return oldExpValue;
      }
      const oldExpValue2 = experimentationService.getTreatmentVariable(`config.${key.fullyQualifiedOldId}`);
      if (oldExpValue2 !== void 0) {
        return oldExpValue2;
      }
    }
    return this.getDefaultValue(key);
  }
  _getUserConfiguredValueForExperimentBasedConfig(key, scope) {
    if (key.options?.valueIgnoredForExternals && !this._isInternal) {
      return void 0;
    }
    const config3 = scope === void 0 ? this.config : vscode3.workspace.getConfiguration(CopilotConfigPrefix, scope);
    if (!this.isConfigured(key, scope)) {
      return void 0;
    }
    return config3.get(key.id) ?? (key.oldId ? config3.get(key.oldId) : void 0);
  }
  // Dumps config settings defined in the extension json
  dumpConfig() {
    const configProperties = {};
    try {
      const config3 = packageJson.contributes.configuration;
      const propertyGroups = config3.map((c) => c.properties);
      const extensionConfigProps = Object.assign({}, ...propertyGroups);
      for (const key in extensionConfigProps) {
        const localKey = key.replace(`${CopilotConfigPrefix}.`, "");
        const value = localKey.split(".").reduce((o, i) => o[i], this.config);
        if (typeof value === "object" && value !== null) {
          Object.keys(value).filter((k) => k !== "secret_key").forEach((k) => configProperties[`${key}.${k}`] = stringOrStringify(value[k]));
        } else {
          configProperties[key] = stringOrStringify(value);
        }
      }
    } catch (ex) {
      console.error(`Failed to retrieve configuration properties ${ex}`);
    }
    return configProperties;
  }
  updateExperimentBasedConfiguration(treatments) {
    if (treatments.length === 0) {
      return;
    }
    this.config = vscode3.workspace.getConfiguration(CopilotConfigPrefix);
    this._onDidChangeConfiguration.fire({
      affectsConfiguration: (section, _scope) => {
        if (treatments.some((t2) => t2.startsWith(`config.${section}`))) {
          return true;
        }
        const oldId = globalConfigRegistry.configs.get(section)?.fullyQualifiedOldId;
        if (oldId && treatments.some((t2) => t2.startsWith(`config.${oldId}`))) {
          return true;
        }
        return false;
      }
    });
  }
};
ConfigurationServiceImpl = __decorateClass([
  __decorateParam(0, ICopilotTokenStore)
], ConfigurationServiceImpl);

// src/util/vs/base/common/glob.ts
init_arrays();
init_charCode();
init_map();
init_strings();
var GLOBSTAR = "**";
var GLOB_SPLIT = "/";
var PATH_REGEX = "[/\\\\]";
var NO_PATH_REGEX = "[^/\\\\]";
var ALL_FORWARD_SLASHES = /\//g;
function starsToRegExp(starCount, isLastPattern) {
  switch (starCount) {
    case 0:
      return "";
    case 1:
      return `${NO_PATH_REGEX}*?`;
    // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
    default:
      return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ""})*?`;
  }
}
function splitGlobAware(pattern, splitChar) {
  if (!pattern) {
    return [];
  }
  const segments = [];
  let inBraces = false;
  let inBrackets = false;
  let curVal = "";
  for (const char of pattern) {
    switch (char) {
      case splitChar:
        if (!inBraces && !inBrackets) {
          segments.push(curVal);
          curVal = "";
          continue;
        }
        break;
      case "{":
        inBraces = true;
        break;
      case "}":
        inBraces = false;
        break;
      case "[":
        inBrackets = true;
        break;
      case "]":
        inBrackets = false;
        break;
    }
    curVal += char;
  }
  if (curVal) {
    segments.push(curVal);
  }
  return segments;
}
function parseRegExp(pattern) {
  if (!pattern) {
    return "";
  }
  let regEx = "";
  const segments = splitGlobAware(pattern, GLOB_SPLIT);
  if (segments.every((segment) => segment === GLOBSTAR)) {
    regEx = ".*";
  } else {
    let previousSegmentWasGlobStar = false;
    segments.forEach((segment, index) => {
      if (segment === GLOBSTAR) {
        if (previousSegmentWasGlobStar) {
          return;
        }
        regEx += starsToRegExp(2, index === segments.length - 1);
      } else {
        let inBraces = false;
        let braceVal = "";
        let inBrackets = false;
        let bracketVal = "";
        for (const char of segment) {
          if (char !== "}" && inBraces) {
            braceVal += char;
            continue;
          }
          if (inBrackets && (char !== "]" || !bracketVal)) {
            let res;
            if (char === "-") {
              res = char;
            } else if ((char === "^" || char === "!") && !bracketVal) {
              res = "^";
            } else if (char === GLOB_SPLIT) {
              res = "";
            } else {
              res = escapeRegExpCharacters(char);
            }
            bracketVal += res;
            continue;
          }
          switch (char) {
            case "{":
              inBraces = true;
              continue;
            case "[":
              inBrackets = true;
              continue;
            case "}": {
              const choices = splitGlobAware(braceVal, ",");
              const braceRegExp = `(?:${choices.map((choice) => parseRegExp(choice)).join("|")})`;
              regEx += braceRegExp;
              inBraces = false;
              braceVal = "";
              break;
            }
            case "]": {
              regEx += "[" + bracketVal + "]";
              inBrackets = false;
              bracketVal = "";
              break;
            }
            case "?":
              regEx += NO_PATH_REGEX;
              continue;
            case "*":
              regEx += starsToRegExp(1);
              continue;
            default:
              regEx += escapeRegExpCharacters(char);
          }
        }
        if (index < segments.length - 1 && // more segments to come after this
        (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...
        index + 2 < segments.length)) {
          regEx += PATH_REGEX;
        }
      }
      previousSegmentWasGlobStar = segment === GLOBSTAR;
    });
  }
  return regEx;
}
var T1 = /^\*\*\/\*\.[\w\.-]+$/;
var T2 = /^\*\*\/([\w\.-]+)\/?$/;
var T3 = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/;
var T3_2 = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/;
var T4 = /^\*\*((\/[\w\.-]+)+)\/?$/;
var T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/;
var CACHE = new LRUCache(1e4);
var FALSE = function() {
  return false;
};
var NULL = function() {
  return null;
};
function parsePattern(arg1, options) {
  if (!arg1) {
    return NULL;
  }
  let pattern;
  if (typeof arg1 !== "string") {
    pattern = arg1.pattern;
  } else {
    pattern = arg1;
  }
  pattern = pattern.trim();
  const patternKey = `${pattern}_${!!options.trimForExclusions}`;
  let parsedPattern = CACHE.get(patternKey);
  if (parsedPattern) {
    return wrapRelativePattern(parsedPattern, arg1);
  }
  let match3;
  if (T1.test(pattern)) {
    parsedPattern = trivia1(pattern.substr(4), pattern);
  } else if (match3 = T2.exec(trimForExclusions(pattern, options))) {
    parsedPattern = trivia2(match3[1], pattern);
  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {
    parsedPattern = trivia3(pattern, options);
  } else if (match3 = T4.exec(trimForExclusions(pattern, options))) {
    parsedPattern = trivia4and5(match3[1].substr(1), pattern, true);
  } else if (match3 = T5.exec(trimForExclusions(pattern, options))) {
    parsedPattern = trivia4and5(match3[1], pattern, false);
  } else {
    parsedPattern = toRegExp(pattern);
  }
  CACHE.set(patternKey, parsedPattern);
  return wrapRelativePattern(parsedPattern, arg1);
}
function wrapRelativePattern(parsedPattern, arg2) {
  if (typeof arg2 === "string") {
    return parsedPattern;
  }
  const wrappedPattern = function(path, basename3) {
    if (!isEqualOrParent(path, arg2.base, !isLinux)) {
      return null;
    }
    return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename3);
  };
  wrappedPattern.allBasenames = parsedPattern.allBasenames;
  wrappedPattern.allPaths = parsedPattern.allPaths;
  wrappedPattern.basenames = parsedPattern.basenames;
  wrappedPattern.patterns = parsedPattern.patterns;
  return wrappedPattern;
}
function trimForExclusions(pattern, options) {
  return options.trimForExclusions && pattern.endsWith("/**") ? pattern.substr(0, pattern.length - 2) : pattern;
}
function trivia1(base2, pattern) {
  return function(path, basename3) {
    return typeof path === "string" && path.endsWith(base2) ? pattern : null;
  };
}
function trivia2(base2, pattern) {
  const slashBase = `/${base2}`;
  const backslashBase = `\\${base2}`;
  const parsedPattern = function(path, basename3) {
    if (typeof path !== "string") {
      return null;
    }
    if (basename3) {
      return basename3 === base2 ? pattern : null;
    }
    return path === base2 || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;
  };
  const basenames = [base2];
  parsedPattern.basenames = basenames;
  parsedPattern.patterns = [pattern];
  parsedPattern.allBasenames = basenames;
  return parsedPattern;
}
function trivia3(pattern, options) {
  const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(",").map((pattern2) => parsePattern(pattern2, options)).filter((pattern2) => pattern2 !== NULL), pattern);
  const patternsLength = parsedPatterns.length;
  if (!patternsLength) {
    return NULL;
  }
  if (patternsLength === 1) {
    return parsedPatterns[0];
  }
  const parsedPattern = function(path, basename3) {
    for (let i = 0, n = parsedPatterns.length; i < n; i++) {
      if (parsedPatterns[i](path, basename3)) {
        return pattern;
      }
    }
    return null;
  };
  const withBasenames = parsedPatterns.find((pattern2) => !!pattern2.allBasenames);
  if (withBasenames) {
    parsedPattern.allBasenames = withBasenames.allBasenames;
  }
  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
  if (allPaths.length) {
    parsedPattern.allPaths = allPaths;
  }
  return parsedPattern;
}
function trivia4and5(targetPath, pattern, matchPathEnds) {
  const usingPosixSep = sep === posix.sep;
  const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);
  const nativePathEnd = sep + nativePath;
  const targetPathEnd = posix.sep + targetPath;
  let parsedPattern;
  if (matchPathEnds) {
    parsedPattern = function(path, basename3) {
      return typeof path === "string" && (path === nativePath || path.endsWith(nativePathEnd) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;
    };
  } else {
    parsedPattern = function(path, basename3) {
      return typeof path === "string" && (path === nativePath || !usingPosixSep && path === targetPath) ? pattern : null;
    };
  }
  parsedPattern.allPaths = [(matchPathEnds ? "*/" : "./") + targetPath];
  return parsedPattern;
}
function toRegExp(pattern) {
  try {
    const regExp = new RegExp(`^${parseRegExp(pattern)}$`);
    return function(path) {
      regExp.lastIndex = 0;
      return typeof path === "string" && regExp.test(path) ? pattern : null;
    };
  } catch {
    return NULL;
  }
}
function match(arg1, path, hasSibling) {
  if (!arg1 || typeof path !== "string") {
    return false;
  }
  return parse2(arg1)(path, void 0, hasSibling);
}
function parse2(arg1, options = {}) {
  if (!arg1) {
    return FALSE;
  }
  if (typeof arg1 === "string" || isRelativePattern(arg1)) {
    const parsedPattern = parsePattern(arg1, options);
    if (parsedPattern === NULL) {
      return FALSE;
    }
    const resultPattern = function(path, basename3) {
      return !!parsedPattern(path, basename3);
    };
    if (parsedPattern.allBasenames) {
      resultPattern.allBasenames = parsedPattern.allBasenames;
    }
    if (parsedPattern.allPaths) {
      resultPattern.allPaths = parsedPattern.allPaths;
    }
    return resultPattern;
  }
  return parsedExpression(arg1, options);
}
function isRelativePattern(obj) {
  const rp = obj;
  if (!rp) {
    return false;
  }
  return typeof rp.base === "string" && typeof rp.pattern === "string";
}
function parsedExpression(expression, options) {
  const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map((pattern) => parseExpressionPattern(pattern, expression[pattern], options)).filter((pattern) => pattern !== NULL));
  const patternsLength = parsedPatterns.length;
  if (!patternsLength) {
    return NULL;
  }
  if (!parsedPatterns.some((parsedPattern) => !!parsedPattern.requiresSiblings)) {
    if (patternsLength === 1) {
      return parsedPatterns[0];
    }
    const resultExpression2 = function(path, basename3) {
      let resultPromises = void 0;
      for (let i = 0, n = parsedPatterns.length; i < n; i++) {
        const result = parsedPatterns[i](path, basename3);
        if (typeof result === "string") {
          return result;
        }
        if (isThenable(result)) {
          if (!resultPromises) {
            resultPromises = [];
          }
          resultPromises.push(result);
        }
      }
      if (resultPromises) {
        return (async () => {
          for (const resultPromise of resultPromises) {
            const result = await resultPromise;
            if (typeof result === "string") {
              return result;
            }
          }
          return null;
        })();
      }
      return null;
    };
    const withBasenames2 = parsedPatterns.find((pattern) => !!pattern.allBasenames);
    if (withBasenames2) {
      resultExpression2.allBasenames = withBasenames2.allBasenames;
    }
    const allPaths2 = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
    if (allPaths2.length) {
      resultExpression2.allPaths = allPaths2;
    }
    return resultExpression2;
  }
  const resultExpression = function(path, base2, hasSibling) {
    let name = void 0;
    let resultPromises = void 0;
    for (let i = 0, n = parsedPatterns.length; i < n; i++) {
      const parsedPattern = parsedPatterns[i];
      if (parsedPattern.requiresSiblings && hasSibling) {
        if (!base2) {
          base2 = basename(path);
        }
        if (!name) {
          name = base2.substr(0, base2.length - extname(path).length);
        }
      }
      const result = parsedPattern(path, base2, name, hasSibling);
      if (typeof result === "string") {
        return result;
      }
      if (isThenable(result)) {
        if (!resultPromises) {
          resultPromises = [];
        }
        resultPromises.push(result);
      }
    }
    if (resultPromises) {
      return (async () => {
        for (const resultPromise of resultPromises) {
          const result = await resultPromise;
          if (typeof result === "string") {
            return result;
          }
        }
        return null;
      })();
    }
    return null;
  };
  const withBasenames = parsedPatterns.find((pattern) => !!pattern.allBasenames);
  if (withBasenames) {
    resultExpression.allBasenames = withBasenames.allBasenames;
  }
  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
  if (allPaths.length) {
    resultExpression.allPaths = allPaths;
  }
  return resultExpression;
}
function parseExpressionPattern(pattern, value, options) {
  if (value === false) {
    return NULL;
  }
  const parsedPattern = parsePattern(pattern, options);
  if (parsedPattern === NULL) {
    return NULL;
  }
  if (typeof value === "boolean") {
    return parsedPattern;
  }
  if (value) {
    const when = value.when;
    if (typeof when === "string") {
      const result = (path, basename3, name, hasSibling) => {
        if (!hasSibling || !parsedPattern(path, basename3)) {
          return null;
        }
        const clausePattern = when.replace("$(basename)", () => name);
        const matched = hasSibling(clausePattern);
        return isThenable(matched) ? matched.then((match3) => match3 ? pattern : null) : matched ? pattern : null;
      };
      result.requiresSiblings = true;
      return result;
    }
  }
  return parsedPattern;
}
function aggregateBasenameMatches(parsedPatterns, result) {
  const basenamePatterns = parsedPatterns.filter((parsedPattern) => !!parsedPattern.basenames);
  if (basenamePatterns.length < 2) {
    return parsedPatterns;
  }
  const basenames = basenamePatterns.reduce((all, current) => {
    const basenames2 = current.basenames;
    return basenames2 ? all.concat(basenames2) : all;
  }, []);
  let patterns;
  if (result) {
    patterns = [];
    for (let i = 0, n = basenames.length; i < n; i++) {
      patterns.push(result);
    }
  } else {
    patterns = basenamePatterns.reduce((all, current) => {
      const patterns2 = current.patterns;
      return patterns2 ? all.concat(patterns2) : all;
    }, []);
  }
  const aggregate = function(path, basename3) {
    if (typeof path !== "string") {
      return null;
    }
    if (!basename3) {
      let i;
      for (i = path.length; i > 0; i--) {
        const ch = path.charCodeAt(i - 1);
        if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {
          break;
        }
      }
      basename3 = path.substr(i);
    }
    const index = basenames.indexOf(basename3);
    return index !== -1 ? patterns[index] : null;
  };
  aggregate.basenames = basenames;
  aggregate.patterns = patterns;
  aggregate.allBasenames = basenames;
  const aggregatedPatterns = parsedPatterns.filter((parsedPattern) => !parsedPattern.basenames);
  aggregatedPatterns.push(aggregate);
  return aggregatedPatterns;
}

// src/platform/customInstructions/common/customInstructionsService.ts
init_lifecycle();
init_map();
init_types();

// src/vscodeTypes.ts
var vscode4 = __toESM(require("vscode"));
var Position3 = vscode4.Position;
var Range3 = vscode4.Range;
var Selection2 = vscode4.Selection;
var TextEdit3 = vscode4.TextEdit;
var Uri3 = vscode4.Uri;
var EndOfLine2 = vscode4.EndOfLine;
var LanguageModelToolResult3 = vscode4.LanguageModelToolResult;
var LanguageModelTextPart3 = vscode4.LanguageModelTextPart;
var LanguageModelToolMCPSource2 = vscode4.LanguageModelToolMCPSource;
var LanguageModelToolExtensionSource2 = vscode4.LanguageModelToolExtensionSource;
var NotebookCellKind2 = vscode4.NotebookCellKind;
var NotebookRange2 = vscode4.NotebookRange;
var NotebookEdit2 = vscode4.NotebookEdit;
var NotebookCellData2 = vscode4.NotebookCellData;
var FileType2 = vscode4.FileType;
var l10n2 = {
  /**
   * @deprecated Only use this import in tests. For the actual extension,
   * use `import { l10n } from 'vscode'` or `import * as l10n from '@vscode/l10n'`.
   */
  t: vscode4.l10n.t
};

// src/platform/extensions/common/extensionsService.ts
var IExtensionsService = createDecorator("IExtensionsService");

// src/util/common/cache.ts
var Node3 = class {
  constructor(key, value) {
    this.prev = null;
    this.next = null;
    this.key = key;
    this.value = value;
  }
};
var LRUCache2 = class {
  constructor(size = 10) {
    if (size < 1) {
      throw new Error("Cache size must be at least 1");
    }
    this._capacity = size;
    this._cache = /* @__PURE__ */ new Map();
    this._head = new Node3("", null);
    this._tail = new Node3("", null);
    this._head.next = this._tail;
    this._tail.prev = this._head;
  }
  _addNode(node) {
    node.prev = this._head;
    node.next = this._head.next;
    this._head.next.prev = node;
    this._head.next = node;
  }
  _removeNode(node) {
    const prev = node.prev;
    const next = node.next;
    prev.next = next;
    next.prev = prev;
  }
  _moveToHead(node) {
    this._removeNode(node);
    this._addNode(node);
  }
  _popTail() {
    const res = this._tail.prev;
    this._removeNode(res);
    return res;
  }
  clear() {
    this._cache.clear();
    this._head.next = this._tail;
    this._tail.prev = this._head;
  }
  /**
   * Deletes the cache entry for the given key, if it exists.
   * @param key The key of the cache entry to delete.
   * @returns The value of the deleted cache entry, or undefined if the key was not found.
   */
  deleteKey(key) {
    const node = this._cache.get(key);
    if (!node) {
      return void 0;
    }
    this._removeNode(node);
    this._cache.delete(key);
    return node.value;
  }
  get(key) {
    const node = this._cache.get(key);
    if (!node) {
      return void 0;
    }
    this._moveToHead(node);
    return node.value;
  }
  /**
   * Return a copy of all the keys stored in the LRU cache, in LRU order.
   *
   * The returned array is safe to modify, as this call allocates a copy of a
   * private array used to represent those keys.
   */
  keys() {
    const keys = [];
    let current = this._head.next;
    while (current !== this._tail) {
      keys.push(current.key);
      current = current.next;
    }
    return keys;
  }
  getValues() {
    const values = [];
    let current = this._head.next;
    while (current !== this._tail) {
      values.push(current.value);
      current = current.next;
    }
    return values;
  }
  /** @returns the evicted [key, value]  */
  put(key, value) {
    let node = this._cache.get(key);
    if (node) {
      node.value = value;
      this._moveToHead(node);
    } else {
      node = new Node3(key, value);
      this._cache.set(key, node);
      this._addNode(node);
      if (this._cache.size > this._capacity) {
        const tail = this._popTail();
        this._cache.delete(tail.key);
        return [tail.key, tail.value];
      }
    }
  }
  entries() {
    const entries = [];
    let current = this._head.next;
    while (current !== this._tail) {
      entries.push([current.key, current.value]);
      current = current.next;
    }
    return entries;
  }
};

// src/platform/filesystem/common/fileSystemService.ts
var IFileSystemService = createDecorator("IFileSystemService");
var fileSystemServiceReadAsJSON = new class {
  constructor() {
    this._cache = null;
  }
  enable() {
    this._cache = new LRUCache2(10);
  }
  async readJSON(fileSystemService, uri) {
    if (!this._cache) {
      return this._readJSON(fileSystemService, uri);
    }
    const cachedValue = this._cache.get(uri.toString());
    if (cachedValue !== void 0) {
      return cachedValue;
    }
    const value = await this._readJSON(fileSystemService, uri);
    this._cache.put(uri.toString(), value);
    return value;
  }
  async _readJSON(fileSystemService, uri) {
    const buffer = await fileSystemService.readFile(uri, true);
    return JSON.parse(buffer.toString());
  }
}();
var FS_READ_MAX_FILE_SIZE = 1024 * 1024 * 5;
async function assertReadFileSizeLimit(fileSystemService, uri, onlyWarn) {
  const stat = await fileSystemService.stat(uri);
  if (stat.size > FS_READ_MAX_FILE_SIZE) {
    if (!onlyWarn) {
      const message = `[FileSystemService] ${uri.toString()} EXCEEDS max file size. FAILED to read ${Math.round(stat.size / (1024 * 1024))}MB > ${Math.round(FS_READ_MAX_FILE_SIZE / (1024 * 1024))}MB`;
      throw new Error(message);
    } else {
      const message = `[FileSystemService] ${uri.toString()} is a LARGE file (${Math.round(stat.size / (1024 * 1024))}MB > ${Math.round(FS_READ_MAX_FILE_SIZE / (1024 * 1024))}MB)`;
      console.warn(message);
    }
  }
}

// src/platform/prompts/common/promptPathRepresentationService.ts
var IPromptPathRepresentationService = createDecorator("IPromptPathRepresentationService");
var PromptPathRepresentationService = class {
  isWindows() {
    return isWindows;
  }
  getFilePath(uri) {
    if (uri.scheme === Schemas.file || uri.scheme === Schemas.vscodeRemote) {
      return uri.fsPath;
    }
    return uri.toString();
  }
  /**
   * Resolves an `filepath` used in a prompt to a URI. The `filepath` should have been created by `getFilePath`.
   *
   * @param filepath The file path to resolve.
   * @param predominantScheme The predominant scheme to use if the path is a file path. Defaults to 'file'.
   *
   * @returns The resolved URI or undefined if filepath does not look like a file path or URI.
   */
  resolveFilePath(filepath, predominantScheme = Schemas.file) {
    const isPosixPath = filepath.startsWith("/");
    const isWindowsPath = this.isWindows() && (hasDriveLetter(filepath) || filepath.startsWith("\\"));
    if (isPosixPath || isWindowsPath) {
      if (isWindowsPath) {
        const isUncPath = filepath.startsWith("\\\\");
        filepath = filepath.replace(/\\+/g, "\\");
        if (isUncPath) {
          filepath = "\\" + filepath;
        }
      }
      const fileUri = URI.file(filepath);
      return predominantScheme === Schemas.file ? fileUri : URI.from({ scheme: predominantScheme, path: fileUri.path });
    }
    if (/\w[\w\d+.-]*:\S/.test(filepath)) {
      try {
        return URI.parse(filepath);
      } catch (e) {
        return void 0;
      }
    }
    return void 0;
  }
  getExampleFilePath(absolutePosixFilePath) {
    if (this.isWindows()) {
      return this.getFilePath(URI.parse(`file:///C:${absolutePosixFilePath}`));
    } else {
      return this.getFilePath(URI.parse(`file://${absolutePosixFilePath}`));
    }
  }
};

// src/util/common/notebooks.ts
function findNotebook(uri, notebookDocuments) {
  return notebookDocuments.find((doc) => isEqual(doc.uri, uri) || doc.uri.path === uri.path || findCell(uri, doc));
}
function findCell(cellUri, notebook) {
  if (cellUri.scheme === Schemas.vscodeNotebookCell || cellUri.scheme === Schemas.vscodeNotebookCellOutput) {
    const index = notebook.getCells().findIndex((cell) => isEqual(cell.document.uri, cellUri) || cell.document.uri.fragment === cellUri.fragment && cell.document.uri.path === cellUri.path);
    if (index !== -1) {
      return notebook.getCells()[index];
    }
  }
}
function isJupyterNotebookUri(uri) {
  return uri.path.endsWith(".ipynb");
}
function isDocumentExcludePattern(pattern) {
  const arg = pattern;
  return typeof arg === "object" && arg !== null && (typeof arg.include === "string" || isRelativePattern2(arg.include));
}
function isFilenamePattern(pattern) {
  const arg = pattern;
  return typeof arg === "object" && arg !== null && typeof arg.filenamePattern === "string";
}
function isRelativePattern2(obj) {
  const rp = obj;
  if (!rp) {
    return false;
  }
  return typeof rp.base === "string" && typeof rp.pattern === "string";
}
function isNotebookEditorContribution(contrib) {
  const candidate = contrib;
  return !!candidate && !!candidate.type && !!candidate.displayName && !!candidate.selector;
}
function extractEditorAssociation(raw) {
  const associations = [];
  for (const [filenamePattern, viewType] of Object.entries(raw)) {
    if (viewType) {
      associations.push({ filenamePattern, viewType });
    }
  }
  return associations;
}
function notebookSelectorMatches(resource, selector) {
  if (typeof selector === "string") {
    if (match(selector.toLowerCase(), basename(resource.fsPath).toLowerCase())) {
      return true;
    }
  }
  if (isDocumentExcludePattern(selector)) {
    const filenamePattern = selector.include;
    const excludeFilenamePattern = selector.exclude;
    if (!filenamePattern) {
      return false;
    }
    if (match(filenamePattern, basename(resource.fsPath).toLowerCase())) {
      if (excludeFilenamePattern && match(excludeFilenamePattern, basename(resource.fsPath).toLowerCase())) {
        return false;
      }
      return true;
    }
  }
  if (isFilenamePattern(selector)) {
    if (match(selector.filenamePattern, basename(resource.fsPath).toLowerCase())) {
      if (selector.excludeFileNamePattern && match(selector.excludeFileNamePattern, basename(resource.fsPath).toLowerCase())) {
        return false;
      }
      return true;
    }
  }
  return false;
}
function getNotebookEditorAssociations(resource, editorAssociations) {
  const validAssociations = [];
  for (const a of editorAssociations) {
    if (a.filenamePattern && match(a.filenamePattern.toLowerCase(), basename(resource.fsPath).toLowerCase())) {
      validAssociations.push({ filenamePattern: a.filenamePattern, viewType: a.viewType });
    }
  }
  return validAssociations;
}
function _hasSupportedNotebooks(uri, workspaceNotebookDocuments, notebookEditorContributions, editorAssociations) {
  if (findNotebook(uri, workspaceNotebookDocuments)) {
    return true;
  }
  const validNotebookEditorContribs = notebookEditorContributions.filter((notebookEditorContrib) => notebookEditorContrib.selector.some((selector) => notebookSelectorMatches(uri, selector)));
  if (validNotebookEditorContribs.length === 0) {
    return false;
  }
  const validAssociations = getNotebookEditorAssociations(uri, editorAssociations);
  for (const association of validAssociations) {
    if (validNotebookEditorContribs.some((notebookEditorContrib) => notebookEditorContrib.type === association.viewType)) {
      return true;
    }
  }
  if (validNotebookEditorContribs.some((notebookEditorContrib) => (notebookEditorContrib.priority ?? "default" /* default */) === "default" /* default */)) {
    return true;
  } else {
    return false;
  }
}

// src/platform/editing/common/notebookDocumentSnapshot.ts
init_types();

// src/util/common/crypto.ts
async function createRequestHMAC(hmacSecret) {
  if (!hmacSecret) {
    return void 0;
  }
  const key = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(hmacSecret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const current = Math.floor(Date.now() / 1e3).toString();
  const textEncoder2 = new TextEncoder();
  const data = textEncoder2.encode(current);
  const signature = await crypto.subtle.sign("HMAC", key, data);
  const signatureArray = Array.from(new Uint8Array(signature));
  const signatureHex = signatureArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return `${current}.${signatureHex}`;
}

// src/platform/endpoint/common/chatModelCapabilities.ts
function modelPrefersJsonNotebookRepresentation(model) {
  return model.family.startsWith("gpt") && !model.family.includes("gpt-4o") || model.family === "o4-mini";
}

// node_modules/jsonc-parser/lib/esm/impl/scanner.js
function createScanner(text2, ignoreTrivia = false) {
  const len = text2.length;
  let pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count2, exact) {
    let digits = 0;
    let value2 = 0;
    while (digits < count2 || !exact) {
      let ch = text2.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count2) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    let start = pos;
    if (text2.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text2.length && isDigit(text2.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text2.length && text2.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text2.length && isDigit(text2.charCodeAt(pos))) {
        pos++;
        while (pos < text2.length && isDigit(text2.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text2.substring(start, pos);
      }
    }
    let end = pos;
    if (pos < text2.length && (text2.charCodeAt(pos) === 69 || text2.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text2.length && text2.charCodeAt(pos) === 43 || text2.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text2.length && isDigit(text2.charCodeAt(pos))) {
        pos++;
        while (pos < text2.length && isDigit(text2.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text2.substring(start, end);
  }
  function scanString() {
    let result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text2.substring(start, pos);
        scanError = 2;
        break;
      }
      const ch = text2.charCodeAt(pos);
      if (ch === 34) {
        result += text2.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text2.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        const ch2 = text2.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            const ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text2.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    let code2 = text2.charCodeAt(pos);
    if (isWhiteSpace(code2)) {
      do {
        pos++;
        value += String.fromCharCode(code2);
        code2 = text2.charCodeAt(pos);
      } while (isWhiteSpace(code2));
      return token = 15;
    }
    if (isLineBreak(code2)) {
      pos++;
      value += String.fromCharCode(code2);
      if (code2 === 13 && text2.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code2) {
      // tokens: []{}:,
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      // strings
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      // comments
      case 47:
        const start = pos - 1;
        if (text2.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text2.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text2.substring(start, pos);
          return token = 12;
        }
        if (text2.charCodeAt(pos + 1) === 42) {
          pos += 2;
          const safeLength = len - 1;
          let commentClosed = false;
          while (pos < safeLength) {
            const ch = text2.charCodeAt(pos);
            if (ch === 42 && text2.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text2.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text2.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code2);
        pos++;
        return token = 16;
      // numbers
      case 45:
        value += String.fromCharCode(code2);
        pos++;
        if (pos === len || !isDigit(text2.charCodeAt(pos))) {
          return token = 16;
        }
      // found a minus, followed by a number so
      // we fall through to proceed with scanning
      // numbers
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      // literals and unknown symbols
      default:
        while (pos < len && isUnknownContentCharacter(code2)) {
          pos++;
          code2 = text2.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text2.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code2);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code2) {
    if (isWhiteSpace(code2) || isLineBreak(code2)) {
      return false;
    }
    switch (code2) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    let result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: () => pos,
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: () => token,
    getTokenValue: () => value,
    getTokenOffset: () => tokenOffset,
    getTokenLength: () => pos - tokenOffset,
    getTokenStartLine: () => lineStartOffset,
    getTokenStartCharacter: () => tokenOffset - prevTokenLineStartOffset,
    getTokenError: () => scanError
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var CharacterCodes;
(function(CharacterCodes2) {
  CharacterCodes2[CharacterCodes2["lineFeed"] = 10] = "lineFeed";
  CharacterCodes2[CharacterCodes2["carriageReturn"] = 13] = "carriageReturn";
  CharacterCodes2[CharacterCodes2["space"] = 32] = "space";
  CharacterCodes2[CharacterCodes2["_0"] = 48] = "_0";
  CharacterCodes2[CharacterCodes2["_1"] = 49] = "_1";
  CharacterCodes2[CharacterCodes2["_2"] = 50] = "_2";
  CharacterCodes2[CharacterCodes2["_3"] = 51] = "_3";
  CharacterCodes2[CharacterCodes2["_4"] = 52] = "_4";
  CharacterCodes2[CharacterCodes2["_5"] = 53] = "_5";
  CharacterCodes2[CharacterCodes2["_6"] = 54] = "_6";
  CharacterCodes2[CharacterCodes2["_7"] = 55] = "_7";
  CharacterCodes2[CharacterCodes2["_8"] = 56] = "_8";
  CharacterCodes2[CharacterCodes2["_9"] = 57] = "_9";
  CharacterCodes2[CharacterCodes2["a"] = 97] = "a";
  CharacterCodes2[CharacterCodes2["b"] = 98] = "b";
  CharacterCodes2[CharacterCodes2["c"] = 99] = "c";
  CharacterCodes2[CharacterCodes2["d"] = 100] = "d";
  CharacterCodes2[CharacterCodes2["e"] = 101] = "e";
  CharacterCodes2[CharacterCodes2["f"] = 102] = "f";
  CharacterCodes2[CharacterCodes2["g"] = 103] = "g";
  CharacterCodes2[CharacterCodes2["h"] = 104] = "h";
  CharacterCodes2[CharacterCodes2["i"] = 105] = "i";
  CharacterCodes2[CharacterCodes2["j"] = 106] = "j";
  CharacterCodes2[CharacterCodes2["k"] = 107] = "k";
  CharacterCodes2[CharacterCodes2["l"] = 108] = "l";
  CharacterCodes2[CharacterCodes2["m"] = 109] = "m";
  CharacterCodes2[CharacterCodes2["n"] = 110] = "n";
  CharacterCodes2[CharacterCodes2["o"] = 111] = "o";
  CharacterCodes2[CharacterCodes2["p"] = 112] = "p";
  CharacterCodes2[CharacterCodes2["q"] = 113] = "q";
  CharacterCodes2[CharacterCodes2["r"] = 114] = "r";
  CharacterCodes2[CharacterCodes2["s"] = 115] = "s";
  CharacterCodes2[CharacterCodes2["t"] = 116] = "t";
  CharacterCodes2[CharacterCodes2["u"] = 117] = "u";
  CharacterCodes2[CharacterCodes2["v"] = 118] = "v";
  CharacterCodes2[CharacterCodes2["w"] = 119] = "w";
  CharacterCodes2[CharacterCodes2["x"] = 120] = "x";
  CharacterCodes2[CharacterCodes2["y"] = 121] = "y";
  CharacterCodes2[CharacterCodes2["z"] = 122] = "z";
  CharacterCodes2[CharacterCodes2["A"] = 65] = "A";
  CharacterCodes2[CharacterCodes2["B"] = 66] = "B";
  CharacterCodes2[CharacterCodes2["C"] = 67] = "C";
  CharacterCodes2[CharacterCodes2["D"] = 68] = "D";
  CharacterCodes2[CharacterCodes2["E"] = 69] = "E";
  CharacterCodes2[CharacterCodes2["F"] = 70] = "F";
  CharacterCodes2[CharacterCodes2["G"] = 71] = "G";
  CharacterCodes2[CharacterCodes2["H"] = 72] = "H";
  CharacterCodes2[CharacterCodes2["I"] = 73] = "I";
  CharacterCodes2[CharacterCodes2["J"] = 74] = "J";
  CharacterCodes2[CharacterCodes2["K"] = 75] = "K";
  CharacterCodes2[CharacterCodes2["L"] = 76] = "L";
  CharacterCodes2[CharacterCodes2["M"] = 77] = "M";
  CharacterCodes2[CharacterCodes2["N"] = 78] = "N";
  CharacterCodes2[CharacterCodes2["O"] = 79] = "O";
  CharacterCodes2[CharacterCodes2["P"] = 80] = "P";
  CharacterCodes2[CharacterCodes2["Q"] = 81] = "Q";
  CharacterCodes2[CharacterCodes2["R"] = 82] = "R";
  CharacterCodes2[CharacterCodes2["S"] = 83] = "S";
  CharacterCodes2[CharacterCodes2["T"] = 84] = "T";
  CharacterCodes2[CharacterCodes2["U"] = 85] = "U";
  CharacterCodes2[CharacterCodes2["V"] = 86] = "V";
  CharacterCodes2[CharacterCodes2["W"] = 87] = "W";
  CharacterCodes2[CharacterCodes2["X"] = 88] = "X";
  CharacterCodes2[CharacterCodes2["Y"] = 89] = "Y";
  CharacterCodes2[CharacterCodes2["Z"] = 90] = "Z";
  CharacterCodes2[CharacterCodes2["asterisk"] = 42] = "asterisk";
  CharacterCodes2[CharacterCodes2["backslash"] = 92] = "backslash";
  CharacterCodes2[CharacterCodes2["closeBrace"] = 125] = "closeBrace";
  CharacterCodes2[CharacterCodes2["closeBracket"] = 93] = "closeBracket";
  CharacterCodes2[CharacterCodes2["colon"] = 58] = "colon";
  CharacterCodes2[CharacterCodes2["comma"] = 44] = "comma";
  CharacterCodes2[CharacterCodes2["dot"] = 46] = "dot";
  CharacterCodes2[CharacterCodes2["doubleQuote"] = 34] = "doubleQuote";
  CharacterCodes2[CharacterCodes2["minus"] = 45] = "minus";
  CharacterCodes2[CharacterCodes2["openBrace"] = 123] = "openBrace";
  CharacterCodes2[CharacterCodes2["openBracket"] = 91] = "openBracket";
  CharacterCodes2[CharacterCodes2["plus"] = 43] = "plus";
  CharacterCodes2[CharacterCodes2["slash"] = 47] = "slash";
  CharacterCodes2[CharacterCodes2["formFeed"] = 12] = "formFeed";
  CharacterCodes2[CharacterCodes2["tab"] = 9] = "tab";
})(CharacterCodes || (CharacterCodes = {}));

// node_modules/jsonc-parser/lib/esm/impl/string-intern.js
var cachedSpaces = new Array(20).fill(0).map((_, index) => {
  return " ".repeat(index);
});
var maxCachedValues = 200;
var cachedBreakLinesWithSpaces = {
  " ": {
    "\n": new Array(maxCachedValues).fill(0).map((_, index) => {
      return "\n" + " ".repeat(index);
    }),
    "\r": new Array(maxCachedValues).fill(0).map((_, index) => {
      return "\r" + " ".repeat(index);
    }),
    "\r\n": new Array(maxCachedValues).fill(0).map((_, index) => {
      return "\r\n" + " ".repeat(index);
    })
  },
  "	": {
    "\n": new Array(maxCachedValues).fill(0).map((_, index) => {
      return "\n" + "	".repeat(index);
    }),
    "\r": new Array(maxCachedValues).fill(0).map((_, index) => {
      return "\r" + "	".repeat(index);
    }),
    "\r\n": new Array(maxCachedValues).fill(0).map((_, index) => {
      return "\r\n" + "	".repeat(index);
    })
  }
};

// node_modules/jsonc-parser/lib/esm/impl/parser.js
var ParseOptions;
(function(ParseOptions2) {
  ParseOptions2.DEFAULT = {
    allowTrailingComma: false
  };
})(ParseOptions || (ParseOptions = {}));
function parse3(text2, errors2 = [], options = ParseOptions.DEFAULT) {
  let currentProperty = null;
  let currentParent = [];
  const previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  const visitor = {
    onObjectBegin: () => {
      const object = {};
      onValue(object);
      previousParents.push(currentParent);
      currentParent = object;
      currentProperty = null;
    },
    onObjectProperty: (name) => {
      currentProperty = name;
    },
    onObjectEnd: () => {
      currentParent = previousParents.pop();
    },
    onArrayBegin: () => {
      const array = [];
      onValue(array);
      previousParents.push(currentParent);
      currentParent = array;
      currentProperty = null;
    },
    onArrayEnd: () => {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: (error2, offset, length) => {
      errors2.push({ error: error2, offset, length });
    }
  };
  visit(text2, visitor, options);
  return currentParent[0];
}
function parseTree(text2, errors2 = [], options = ParseOptions.DEFAULT) {
  let currentParent = { type: "array", offset: -1, length: -1, children: [], parent: void 0 };
  function ensurePropertyComplete(endOffset) {
    if (currentParent.type === "property") {
      currentParent.length = endOffset - currentParent.offset;
      currentParent = currentParent.parent;
    }
  }
  function onValue(valueNode) {
    currentParent.children.push(valueNode);
    return valueNode;
  }
  const visitor = {
    onObjectBegin: (offset) => {
      currentParent = onValue({ type: "object", offset, length: -1, parent: currentParent, children: [] });
    },
    onObjectProperty: (name, offset, length) => {
      currentParent = onValue({ type: "property", offset, length: -1, parent: currentParent, children: [] });
      currentParent.children.push({ type: "string", value: name, offset, length, parent: currentParent });
    },
    onObjectEnd: (offset, length) => {
      ensurePropertyComplete(offset + length);
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onArrayBegin: (offset, length) => {
      currentParent = onValue({ type: "array", offset, length: -1, parent: currentParent, children: [] });
    },
    onArrayEnd: (offset, length) => {
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onLiteralValue: (value, offset, length) => {
      onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });
      ensurePropertyComplete(offset + length);
    },
    onSeparator: (sep2, offset, length) => {
      if (currentParent.type === "property") {
        if (sep2 === ":") {
          currentParent.colonOffset = offset;
        } else if (sep2 === ",") {
          ensurePropertyComplete(offset);
        }
      }
    },
    onError: (error2, offset, length) => {
      errors2.push({ error: error2, offset, length });
    }
  };
  visit(text2, visitor, options);
  const result = currentParent.children[0];
  if (result) {
    delete result.parent;
  }
  return result;
}
function findNodeAtLocation(root, path) {
  if (!root) {
    return void 0;
  }
  let node = root;
  for (let segment of path) {
    if (typeof segment === "string") {
      if (node.type !== "object" || !Array.isArray(node.children)) {
        return void 0;
      }
      let found = false;
      for (const propertyNode of node.children) {
        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {
          node = propertyNode.children[1];
          found = true;
          break;
        }
      }
      if (!found) {
        return void 0;
      }
    } else {
      const index = segment;
      if (node.type !== "array" || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
        return void 0;
      }
      node = node.children[index];
    }
  }
  return node;
}
function visit(text2, visitor, options = ParseOptions.DEFAULT) {
  const _scanner = createScanner(text2, false);
  const _jsonPath = [];
  let suppressedCallbacks = 0;
  function toNoArgVisit(visitFunction) {
    return visitFunction ? () => suppressedCallbacks === 0 && visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? (arg) => suppressedCallbacks === 0 && visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toOneArgVisitWithPath(visitFunction) {
    return visitFunction ? (arg) => suppressedCallbacks === 0 && visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
  }
  function toBeginVisit(visitFunction) {
    return visitFunction ? () => {
      if (suppressedCallbacks > 0) {
        suppressedCallbacks++;
      } else {
        let cbReturn = visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice());
        if (cbReturn === false) {
          suppressedCallbacks = 1;
        }
      }
    } : () => true;
  }
  function toEndVisit(visitFunction) {
    return visitFunction ? () => {
      if (suppressedCallbacks > 0) {
        suppressedCallbacks--;
      }
      if (suppressedCallbacks === 0) {
        visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
      }
    } : () => true;
  }
  const onObjectBegin = toBeginVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toEndVisit(visitor.onObjectEnd), onArrayBegin = toBeginVisit(visitor.onArrayBegin), onArrayEnd = toEndVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  const disallowComments = options && options.disallowComments;
  const allowTrailingComma = options && options.allowTrailingComma;
  function scanNext() {
    while (true) {
      const token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(
            14
            /* ParseErrorCode.InvalidUnicode */
          );
          break;
        case 5:
          handleError(
            15
            /* ParseErrorCode.InvalidEscapeCharacter */
          );
          break;
        case 3:
          handleError(
            13
            /* ParseErrorCode.UnexpectedEndOfNumber */
          );
          break;
        case 1:
          if (!disallowComments) {
            handleError(
              11
              /* ParseErrorCode.UnexpectedEndOfComment */
            );
          }
          break;
        case 2:
          handleError(
            12
            /* ParseErrorCode.UnexpectedEndOfString */
          );
          break;
        case 6:
          handleError(
            16
            /* ParseErrorCode.InvalidCharacter */
          );
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(
              10
              /* ParseErrorCode.InvalidCommentToken */
            );
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(
            1
            /* ParseErrorCode.InvalidSymbol */
          );
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error2, skipUntilAfter = [], skipUntil = []) {
    onError(error2);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      let token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    const value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
      _jsonPath.push(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        const tokenValue = _scanner.getTokenValue();
        let value = Number(tokenValue);
        if (isNaN(value)) {
          handleError(
            2
            /* ParseErrorCode.InvalidNumberFormat */
          );
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
    } else {
      handleError(5, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
    }
    _jsonPath.pop();
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    let needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [
        2
        /* SyntaxKind.CloseBraceToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    let isFirstElement = true;
    let needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (isFirstElement) {
        _jsonPath.push(0);
        isFirstElement = false;
      } else {
        _jsonPath[_jsonPath.length - 1]++;
      }
      if (!parseValue()) {
        handleError(4, [], [
          4,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (!isFirstElement) {
      _jsonPath.pop();
    }
    if (_scanner.getToken() !== 4) {
      handleError(8, [
        4
        /* SyntaxKind.CloseBracketToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}
function getNodeType(value) {
  switch (typeof value) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    case "object": {
      if (!value) {
        return "null";
      } else if (Array.isArray(value)) {
        return "array";
      }
      return "object";
    }
    default:
      return "null";
  }
}

// node_modules/jsonc-parser/lib/esm/main.js
var ScanError;
(function(ScanError2) {
  ScanError2[ScanError2["None"] = 0] = "None";
  ScanError2[ScanError2["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
  ScanError2[ScanError2["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
  ScanError2[ScanError2["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
  ScanError2[ScanError2["InvalidUnicode"] = 4] = "InvalidUnicode";
  ScanError2[ScanError2["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
  ScanError2[ScanError2["InvalidCharacter"] = 6] = "InvalidCharacter";
})(ScanError || (ScanError = {}));
var SyntaxKind;
(function(SyntaxKind2) {
  SyntaxKind2[SyntaxKind2["OpenBraceToken"] = 1] = "OpenBraceToken";
  SyntaxKind2[SyntaxKind2["CloseBraceToken"] = 2] = "CloseBraceToken";
  SyntaxKind2[SyntaxKind2["OpenBracketToken"] = 3] = "OpenBracketToken";
  SyntaxKind2[SyntaxKind2["CloseBracketToken"] = 4] = "CloseBracketToken";
  SyntaxKind2[SyntaxKind2["CommaToken"] = 5] = "CommaToken";
  SyntaxKind2[SyntaxKind2["ColonToken"] = 6] = "ColonToken";
  SyntaxKind2[SyntaxKind2["NullKeyword"] = 7] = "NullKeyword";
  SyntaxKind2[SyntaxKind2["TrueKeyword"] = 8] = "TrueKeyword";
  SyntaxKind2[SyntaxKind2["FalseKeyword"] = 9] = "FalseKeyword";
  SyntaxKind2[SyntaxKind2["StringLiteral"] = 10] = "StringLiteral";
  SyntaxKind2[SyntaxKind2["NumericLiteral"] = 11] = "NumericLiteral";
  SyntaxKind2[SyntaxKind2["LineCommentTrivia"] = 12] = "LineCommentTrivia";
  SyntaxKind2[SyntaxKind2["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
  SyntaxKind2[SyntaxKind2["LineBreakTrivia"] = 14] = "LineBreakTrivia";
  SyntaxKind2[SyntaxKind2["Trivia"] = 15] = "Trivia";
  SyntaxKind2[SyntaxKind2["Unknown"] = 16] = "Unknown";
  SyntaxKind2[SyntaxKind2["EOF"] = 17] = "EOF";
})(SyntaxKind || (SyntaxKind = {}));
var parse4 = parse3;
var parseTree2 = parseTree;
var findNodeAtLocation2 = findNodeAtLocation;
var visit2 = visit;
var ParseErrorCode;
(function(ParseErrorCode2) {
  ParseErrorCode2[ParseErrorCode2["InvalidSymbol"] = 1] = "InvalidSymbol";
  ParseErrorCode2[ParseErrorCode2["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
  ParseErrorCode2[ParseErrorCode2["PropertyNameExpected"] = 3] = "PropertyNameExpected";
  ParseErrorCode2[ParseErrorCode2["ValueExpected"] = 4] = "ValueExpected";
  ParseErrorCode2[ParseErrorCode2["ColonExpected"] = 5] = "ColonExpected";
  ParseErrorCode2[ParseErrorCode2["CommaExpected"] = 6] = "CommaExpected";
  ParseErrorCode2[ParseErrorCode2["CloseBraceExpected"] = 7] = "CloseBraceExpected";
  ParseErrorCode2[ParseErrorCode2["CloseBracketExpected"] = 8] = "CloseBracketExpected";
  ParseErrorCode2[ParseErrorCode2["EndOfFileExpected"] = 9] = "EndOfFileExpected";
  ParseErrorCode2[ParseErrorCode2["InvalidCommentToken"] = 10] = "InvalidCommentToken";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
  ParseErrorCode2[ParseErrorCode2["InvalidUnicode"] = 14] = "InvalidUnicode";
  ParseErrorCode2[ParseErrorCode2["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
  ParseErrorCode2[ParseErrorCode2["InvalidCharacter"] = 16] = "InvalidCharacter";
})(ParseErrorCode || (ParseErrorCode = {}));

// src/platform/notebook/common/alternativeContentProvider.ts
var BaseAlternativeNotebookContentProvider = class {
  constructor(kind) {
    this.kind = kind;
  }
};

// src/util/vs/editor/common/core/wordHelper.ts
init_iterator();
init_lifecycle();
init_linkedList();
var USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function createWordRegExp(allowInWords = "") {
  let source = "(-?\\d*\\.\\d\\w*)|([^";
  for (const sep2 of USUAL_WORD_SEPARATORS) {
    if (allowInWords.indexOf(sep2) >= 0) {
      continue;
    }
    source += "\\" + sep2;
  }
  source += "\\s]+)";
  return new RegExp(source, "g");
}
var DEFAULT_WORD_REGEXP = createWordRegExp();
function ensureValidWordDefinition(wordDefinition) {
  let result = DEFAULT_WORD_REGEXP;
  if (wordDefinition && wordDefinition instanceof RegExp) {
    if (!wordDefinition.global) {
      let flags = "g";
      if (wordDefinition.ignoreCase) {
        flags += "i";
      }
      if (wordDefinition.multiline) {
        flags += "m";
      }
      if (wordDefinition.unicode) {
        flags += "u";
      }
      result = new RegExp(wordDefinition.source, flags);
    } else {
      result = wordDefinition;
    }
  }
  result.lastIndex = 0;
  return result;
}
var _defaultConfig = new LinkedList();
_defaultConfig.unshift({
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
});
function getWordAtText(column, wordDefinition, text2, textOffset, config3) {
  wordDefinition = ensureValidWordDefinition(wordDefinition);
  if (!config3) {
    config3 = Iterable.first(_defaultConfig);
  }
  if (text2.length > config3.maxLen) {
    let start = column - config3.maxLen / 2;
    if (start < 0) {
      start = 0;
    } else {
      textOffset += start;
    }
    text2 = text2.substring(start, column + config3.maxLen / 2);
    return getWordAtText(column, wordDefinition, text2, textOffset, config3);
  }
  const t1 = Date.now();
  const pos = column - 1 - textOffset;
  let prevRegexIndex = -1;
  let match3 = null;
  for (let i = 1; ; i++) {
    if (Date.now() - t1 >= config3.timeBudget) {
      break;
    }
    const regexIndex = pos - config3.windowSize * i;
    wordDefinition.lastIndex = Math.max(0, regexIndex);
    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text2, pos, prevRegexIndex);
    if (!thisMatch && match3) {
      break;
    }
    match3 = thisMatch;
    if (regexIndex <= 0) {
      break;
    }
    prevRegexIndex = regexIndex;
  }
  if (match3) {
    const result = {
      word: match3[0],
      startColumn: textOffset + 1 + match3.index,
      endColumn: textOffset + 1 + match3.index + match3[0].length
    };
    wordDefinition.lastIndex = 0;
    return result;
  }
  return null;
}
function _findRegexMatchEnclosingPosition(wordDefinition, text2, pos, stopPos) {
  let match3;
  while (match3 = wordDefinition.exec(text2)) {
    const matchIndex = match3.index || 0;
    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
      return match3;
    } else if (stopPos > 0 && matchIndex > stopPos) {
      return null;
    }
  }
  return null;
}

// src/platform/editing/common/positionOffsetTransformer.ts
init_strings();
init_offsetRange();

// src/util/vs/editor/common/model/prefixSumComputer.ts
init_arrays();
init_uint();
var PrefixSumComputer = class {
  constructor(values) {
    this.values = values;
    this.prefixSum = new Uint32Array(values.length);
    this.prefixSumValidIndex = new Int32Array(1);
    this.prefixSumValidIndex[0] = -1;
  }
  getCount() {
    return this.values.length;
  }
  insertValues(insertIndex, insertValues) {
    insertIndex = toUint32(insertIndex);
    const oldValues = this.values;
    const oldPrefixSum = this.prefixSum;
    const insertValuesLen = insertValues.length;
    if (insertValuesLen === 0) {
      return false;
    }
    this.values = new Uint32Array(oldValues.length + insertValuesLen);
    this.values.set(oldValues.subarray(0, insertIndex), 0);
    this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
    this.values.set(insertValues, insertIndex);
    if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = insertIndex - 1;
    }
    this.prefixSum = new Uint32Array(this.values.length);
    if (this.prefixSumValidIndex[0] >= 0) {
      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
    }
    return true;
  }
  setValue(index, value) {
    index = toUint32(index);
    value = toUint32(value);
    if (this.values[index] === value) {
      return false;
    }
    this.values[index] = value;
    if (index - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = index - 1;
    }
    return true;
  }
  removeValues(startIndex, count2) {
    startIndex = toUint32(startIndex);
    count2 = toUint32(count2);
    const oldValues = this.values;
    const oldPrefixSum = this.prefixSum;
    if (startIndex >= oldValues.length) {
      return false;
    }
    const maxCount = oldValues.length - startIndex;
    if (count2 >= maxCount) {
      count2 = maxCount;
    }
    if (count2 === 0) {
      return false;
    }
    this.values = new Uint32Array(oldValues.length - count2);
    this.values.set(oldValues.subarray(0, startIndex), 0);
    this.values.set(oldValues.subarray(startIndex + count2), startIndex);
    this.prefixSum = new Uint32Array(this.values.length);
    if (startIndex - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = startIndex - 1;
    }
    if (this.prefixSumValidIndex[0] >= 0) {
      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
    }
    return true;
  }
  getTotalSum() {
    if (this.values.length === 0) {
      return 0;
    }
    return this._getPrefixSum(this.values.length - 1);
  }
  /**
   * Returns the sum of the first `index + 1` many items.
   * @returns `SUM(0 <= j <= index, values[j])`.
   */
  getPrefixSum(index) {
    if (index < 0) {
      return 0;
    }
    index = toUint32(index);
    return this._getPrefixSum(index);
  }
  _getPrefixSum(index) {
    if (index <= this.prefixSumValidIndex[0]) {
      return this.prefixSum[index];
    }
    let startIndex = this.prefixSumValidIndex[0] + 1;
    if (startIndex === 0) {
      this.prefixSum[0] = this.values[0];
      startIndex++;
    }
    if (index >= this.values.length) {
      index = this.values.length - 1;
    }
    for (let i = startIndex; i <= index; i++) {
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    }
    this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
    return this.prefixSum[index];
  }
  getIndexOf(sum2) {
    sum2 = Math.floor(sum2);
    this.getTotalSum();
    let low = 0;
    let high = this.values.length - 1;
    let mid = 0;
    let midStop = 0;
    let midStart = 0;
    while (low <= high) {
      mid = low + (high - low) / 2 | 0;
      midStop = this.prefixSum[mid];
      midStart = midStop - this.values[mid];
      if (sum2 < midStart) {
        high = mid - 1;
      } else if (sum2 >= midStop) {
        low = mid + 1;
      } else {
        break;
      }
    }
    return new PrefixSumIndexOfResult(mid, sum2 - midStart);
  }
};
var PrefixSumIndexOfResult = class {
  constructor(index, remainder) {
    this.index = index;
    this.remainder = remainder;
    this._prefixSumIndexOfResultBrand = void 0;
    this.index = index;
    this.remainder = remainder;
  }
};

// src/platform/editing/common/positionOffsetTransformer.ts
var PositionOffsetTransformer2 = class {
  constructor(text2) {
    this._lines = splitLines(text2);
    this._eol = text2.charAt(this._lines[0].length) === "\r" ? "\r\n" : "\n";
    const lineStartValues = new Uint32Array(this._lines.length);
    for (let i = 0; i < this._lines.length; i++) {
      lineStartValues[i] = this._lines[i].length + this._eol.length;
    }
    this._lineStarts = new PrefixSumComputer(lineStartValues);
  }
  getText() {
    return this._lines.join(this._eol);
  }
  applyOffsetEdits(offsetEdits) {
    const { replacements } = offsetEdits;
    for (let i = replacements.length - 1; i >= 0; i--) {
      const edit = replacements[i];
      const range = this.toRange(edit.replaceRange);
      this._acceptDeleteRange(range);
      this._acceptInsertText(range.start, edit.newText);
    }
  }
  _acceptDeleteRange(range) {
    if (range.start.line === range.end.line) {
      if (range.start.character === range.end.character) {
        return;
      }
      this._setLineText(
        range.start.line,
        this._lines[range.start.line].substring(0, range.start.character) + this._lines[range.start.line].substring(range.end.character)
      );
      return;
    }
    this._setLineText(
      range.start.line,
      this._lines[range.start.line].substring(0, range.start.character) + this._lines[range.end.line].substring(range.end.character)
    );
    this._lines.splice(range.start.line + 1, range.end.line - range.start.line);
    this._lineStarts.removeValues(range.start.line + 1, range.end.line - range.start.line);
  }
  _acceptInsertText(position, insertText) {
    if (insertText.length === 0) {
      return;
    }
    const insertLines = splitLines(insertText);
    if (insertLines.length === 1) {
      this._setLineText(
        position.line,
        this._lines[position.line].substring(0, position.character) + insertLines[0] + this._lines[position.line].substring(position.character)
      );
      return;
    }
    insertLines[insertLines.length - 1] += this._lines[position.line].substring(position.character);
    this._setLineText(
      position.line,
      this._lines[position.line].substring(0, position.character) + insertLines[0]
    );
    const newLengths = new Uint32Array(insertLines.length - 1);
    for (let i = 1; i < insertLines.length; i++) {
      this._lines.splice(position.line + 1 + i - 1, 0, insertLines[i]);
      newLengths[i - 1] = insertLines[i].length + this._eol.length;
    }
    this._lineStarts.insertValues(position.line + 1, newLengths);
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(lineIndex, newValue) {
    this._lines[lineIndex] = newValue;
    this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
  }
  getLineCount() {
    return this._lines.length;
  }
  getOffset(position) {
    position = this.validatePosition(position);
    return this._lineStarts.getPrefixSum(position.line - 1) + position.character;
  }
  getPosition(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    const out = this._lineStarts.getIndexOf(offset);
    const lineLength = this._lines[out.index].length;
    return new Position3(out.index, Math.min(out.remainder, lineLength));
  }
  toRange(offsetRange) {
    return new Range3(this.getPosition(offsetRange.start), this.getPosition(offsetRange.endExclusive));
  }
  toOffsetRange(range) {
    return new OffsetRange(
      this.getOffset(range.start),
      this.getOffset(range.end)
    );
  }
  toOffsetEdit(edits) {
    const validEdits = edits.map((edit) => new TextEdit3(this.validateRange(edit.range), edit.newText));
    return new StringEdit(validEdits.map((edit) => {
      return new StringReplacement(this.toOffsetRange(edit.range), edit.newText);
    }));
  }
  toTextEdits(edit) {
    return edit.replacements.map((edit2) => {
      return new TextEdit3(this.toRange(edit2.replaceRange), edit2.newText);
    });
  }
  validatePosition(position) {
    if (!(position instanceof Position3)) {
      throw new Error("Invalid argument");
    }
    if (this._lines.length === 0) {
      return position.with(0, 0);
    }
    let { line, character } = position;
    let hasChanged = false;
    if (line < 0) {
      line = 0;
      character = 0;
      hasChanged = true;
    } else if (line >= this._lines.length) {
      line = this._lines.length - 1;
      character = this._lines[line].length;
      hasChanged = true;
    } else {
      const maxCharacter = this._lines[line].length;
      if (character < 0) {
        character = 0;
        hasChanged = true;
      } else if (character > maxCharacter) {
        character = maxCharacter;
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return position;
    }
    return new Position3(line, character);
  }
  validateRange(range) {
    return new Range3(
      this.validatePosition(range.start),
      this.validatePosition(range.end)
    );
  }
};

// src/platform/editing/common/textDocumentSnapshot.ts
init_types();
var TextDocumentSnapshot = class _TextDocumentSnapshot {
  constructor(document2, uri, text2, languageId, eol, version2) {
    this._transformer = null;
    this._lines = null;
    this.document = document2;
    this.uri = uri;
    this._text = text2;
    this.languageId = languageId;
    this.eol = eol;
    this.version = version2;
  }
  static create(doc) {
    return new _TextDocumentSnapshot(
      doc,
      doc.uri,
      doc.getText(),
      doc.languageId,
      doc.eol,
      doc.version
    );
  }
  static fromNewText(text2, doc) {
    return new _TextDocumentSnapshot(
      doc instanceof _TextDocumentSnapshot ? doc.document : doc,
      doc.uri,
      text2,
      doc.languageId,
      doc.eol,
      doc.version + 1
    );
  }
  static fromJSON(doc, json) {
    return new _TextDocumentSnapshot(
      doc,
      URI.from(json.uri),
      json._text,
      json.languageId,
      json.eol,
      json.version
    );
  }
  get transformer() {
    if (!this._transformer) {
      this._transformer = new PositionOffsetTransformer2(this._text);
    }
    return this._transformer;
  }
  get fileName() {
    return this.uri.fsPath;
  }
  get isUntitled() {
    return this.uri.scheme === "untitled";
  }
  get lineCount() {
    return this.lines.length;
  }
  get lines() {
    if (!this._lines) {
      this._lines = this._text.split(/\r\n|\r|\n/g);
    }
    return this._lines;
  }
  lineAt(lineOrPosition) {
    let line;
    if (lineOrPosition instanceof Position3) {
      line = lineOrPosition.line;
    } else if (typeof lineOrPosition === "number") {
      line = lineOrPosition;
    } else {
      throw new Error(`Invalid argument`);
    }
    if (line < 0 || line >= this.lines.length) {
      throw new Error("Illegal value for `line`");
    }
    return new SnapshotDocumentLine(line, this.lines[line], line === this.lines.length - 1);
  }
  offsetAt(position) {
    if (this.version === this.document.version) {
      return this.document.offsetAt(position);
    }
    position = this.validatePosition(position);
    return this.transformer.getOffset(position);
  }
  positionAt(offset) {
    if (this.version === this.document.version) {
      return this.document.positionAt(offset);
    }
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    return this.transformer.getPosition(offset);
  }
  getText(range) {
    return range ? this._getTextInRange(range) : this._text;
  }
  _getTextInRange(_range) {
    if (this.version === this.document.version) {
      return this.document.getText(_range);
    }
    const range = this.validateRange(_range);
    if (range.isEmpty) {
      return "";
    }
    const offsetRange = this.transformer.toOffsetRange(range);
    return this._text.substring(offsetRange.start, offsetRange.endExclusive);
  }
  getWordRangeAtPosition(_position) {
    const position = this.validatePosition(_position);
    const wordAtText = getWordAtText(
      position.character + 1,
      DEFAULT_WORD_REGEXP,
      this.lines[position.line],
      0
    );
    if (wordAtText) {
      return new Range3(position.line, wordAtText.startColumn - 1, position.line, wordAtText.endColumn - 1);
    }
    return void 0;
  }
  validateRange(range) {
    const start = this.validatePosition(range.start);
    const end = this.validatePosition(range.end);
    if (start === range.start && end === range.end) {
      return range;
    }
    return new Range3(start.line, start.character, end.line, end.character);
  }
  validatePosition(position) {
    if (this._text.length === 0) {
      return position.with(0, 0);
    }
    let { line, character } = position;
    let hasChanged = false;
    if (line < 0) {
      line = 0;
      character = 0;
      hasChanged = true;
    } else if (line >= this.lines.length) {
      line = this.lines.length - 1;
      character = this.lines[line].length;
      hasChanged = true;
    } else {
      const maxCharacter = this.lines[line].length;
      if (character < 0) {
        character = 0;
        hasChanged = true;
      } else if (character > maxCharacter) {
        character = maxCharacter;
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return position;
    }
    return new Position3(line, character);
  }
  toJSON() {
    return {
      uri: this.uri.toJSON(),
      languageId: this.languageId,
      version: this.version,
      eol: this.eol,
      _text: this._text
    };
  }
};
var SnapshotDocumentLine = class {
  constructor(line, text2, isLastLine) {
    this._line = line;
    this._text = text2;
    this._isLastLine = isLastLine;
  }
  get lineNumber() {
    return this._line;
  }
  get text() {
    return this._text;
  }
  get range() {
    return new Range3(this._line, 0, this._line, this._text.length);
  }
  get rangeIncludingLineBreak() {
    if (this._isLastLine) {
      return this.range;
    }
    return new Range3(this._line, 0, this._line + 1, 0);
  }
  get firstNonWhitespaceCharacterIndex() {
    return /^(\s*)/.exec(this._text)[1].length;
  }
  get isEmptyOrWhitespace() {
    return this.firstNonWhitespaceCharacterIndex === this._text.length;
  }
};

// src/platform/notebook/common/alternativeNotebookDocument.ts
var AlternativeNotebookDocument = class {
  constructor(_text, notebook) {
    this._text = _text;
    this.notebook = notebook;
    this._transformer = null;
    this._lines = null;
  }
  get transformer() {
    if (!this._transformer) {
      this._transformer = new PositionOffsetTransformer2(this._text);
    }
    return this._transformer;
  }
  getText(range) {
    return range ? this._getTextInRange(range) : this._text;
  }
  _getTextInRange(_range) {
    const range = this.validateRange(_range);
    if (range.isEmpty) {
      return "";
    }
    const offsetRange = this.transformer.toOffsetRange(range);
    return this._text.substring(offsetRange.start, offsetRange.endExclusive);
  }
  positionToOffset(position) {
    position = this.validatePosition(position);
    return this.transformer.getOffset(position);
  }
  getWordRangeAtPosition(_position) {
    const position = this.validatePosition(_position);
    const wordAtText = getWordAtText(
      position.character + 1,
      DEFAULT_WORD_REGEXP,
      this.lines[position.line],
      0
    );
    if (wordAtText) {
      return new Range3(position.line, wordAtText.startColumn - 1, position.line, wordAtText.endColumn - 1);
    }
    return void 0;
  }
  get lines() {
    if (!this._lines) {
      this._lines = this._text.split(/\r\n|\r|\n/g);
    }
    return this._lines;
  }
  get lineCount() {
    return this.lines.length;
  }
  lineAt(lineOrPosition) {
    let line;
    if (lineOrPosition instanceof Position3) {
      line = lineOrPosition.line;
    } else if (typeof lineOrPosition === "number") {
      line = lineOrPosition;
    } else {
      throw new Error(`Invalid argument`);
    }
    if (line < 0 || line >= this.lines.length) {
      throw new Error("Illegal value for `line`");
    }
    return new SnapshotDocumentLine(line, this.lines[line], line === this.lines.length - 1);
  }
  offsetAt(position) {
    return this.transformer.getOffset(position);
  }
  positionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    return this.transformer.getPosition(offset);
  }
  validateRange(range) {
    const start = this.validatePosition(range.start);
    const end = this.validatePosition(range.end);
    if (start === range.start && end === range.end) {
      return range;
    }
    return new Range3(start.line, start.character, end.line, end.character);
  }
  validatePosition(position) {
    if (this._text.length === 0) {
      return position.with(0, 0);
    }
    let { line, character } = position;
    let hasChanged = false;
    if (line < 0) {
      line = 0;
      character = 0;
      hasChanged = true;
    } else if (line >= this.lines.length) {
      line = this.lines.length - 1;
      character = this.lines[line].length;
      hasChanged = true;
    } else {
      const maxCharacter = this.lines[line].length;
      if (character < 0) {
        character = 0;
        hasChanged = true;
      } else if (character > maxCharacter) {
        character = maxCharacter;
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return position;
    }
    return new Position3(line, character);
  }
};

// src/util/common/types.ts
function isUri(thing) {
  return URI.isUri(thing);
}

// src/platform/notebook/common/helpers.ts
init_strings();
var LineOfText = class {
  constructor(value) {
    this.__lineOfTextBrand = void 0;
    this.value = value.replace(/\r$/, "");
  }
};
var EOL = "\n";
function summarize(cell) {
  const cellType = cell.kind === NotebookCellKind2.Code ? "code" : "markdown";
  const id2 = getCellId(cell);
  const source = getCellCode(cell.document);
  return { cell_type: cellType, id: id2, language: cell.document.languageId, source, index: cell.index };
}
function getCellIdMap(notebook) {
  const cellIdMap = /* @__PURE__ */ new Map();
  notebook.getCells().forEach((cell) => {
    cellIdMap.set(getCellId(cell), cell);
  });
  return cellIdMap;
}
var cellIdCache = /* @__PURE__ */ new WeakMap();
var CELL_ID_HASH_LENGTH = 8;
var CELL_ID_PREFIX = "#VSC-";
var CellIdPatternRe = new RegExp(`(\\s+|^|\\b|\\W)(#VSC-[a-f0-9]{${CELL_ID_HASH_LENGTH}})\\b`, "gi");
function getCellId(cell) {
  let oldId = cellIdCache.get(cell);
  if (oldId) {
    return oldId;
  }
  const hash = new StringSHA1();
  hash.update(cell.document.uri.toString());
  oldId = `${CELL_ID_PREFIX}${hash.digest().substring(0, CELL_ID_HASH_LENGTH)}`;
  cellIdCache.set(cell, oldId);
  return oldId;
}
function getCellCode(document2) {
  if (document2.lineCount === 0) {
    return [];
  }
  return new Array(document2.lineCount).fill("").map((_, i) => document2.lineAt(i).text);
}
function getDefaultLanguage(notebook) {
  const codeCell = notebook.getCells().find((cell) => cell.kind === NotebookCellKind2.Code);
  if (codeCell) {
    return codeCell.document.languageId;
  }
  if (notebook.notebookType === "jupyter-notebook") {
    return notebook.metadata?.language_info?.name || notebook.metadata?.kernelspec?.language || "python";
  }
}

// src/platform/notebook/common/alternativeContentProvider.json.ts
var IndentSize = 4;
var AlternativeJsonDocument = class extends AlternativeNotebookDocument {
  fromCellPosition(cell, position) {
    const cellId = getCellId(cell);
    const alternativeContentText = this.getText();
    const sourcePrefix = `                `;
    const cellMarker = `"id": "${cellId}",`;
    const positionOfSource = alternativeContentText.indexOf(`"source": [`, alternativeContentText.indexOf(cellMarker));
    const firstLineIndexOfCellSource = this.positionAt(positionOfSource).line + 1;
    const leadingCharacters = cell.document.getText(new Range3(position.line, 0, position.line, position.character));
    const characterPositionInAltContent = `${sourcePrefix}${JSON.stringify(leadingCharacters).slice(0, -1)}`;
    const linePositionInAltContent = position.line + firstLineIndexOfCellSource;
    return new Position3(linePositionInAltContent, characterPositionInAltContent.length);
  }
  toCellPosition(position) {
    throw new Error("Method not implemented.");
  }
};
var AlternativeJsonNotebookContentProvider = class extends BaseAlternativeNotebookContentProvider {
  constructor() {
    super("json");
  }
  stripCellMarkers(text2) {
    return text2;
  }
  parseAlternateContent(notebookOrUri, inputStream, token) {
    return this.parseAlternateContentImpl(notebookOrUri, inputStream, token);
  }
  getAlternativeDocumentFromText(text2, notebook) {
    return new AlternativeJsonDocument(text2, notebook);
  }
  getAlternativeDocument(notebook, excludeMarkdownCells) {
    const cells = notebook.getCells().filter((cell) => excludeMarkdownCells ? cell.kind !== NotebookCellKind2.Markup : true).map((cell) => {
      const summary = summarize(cell);
      const source = getCellCode2(cell.document);
      return {
        cell_type: summary.cell_type,
        id: summary.id,
        metadata: {
          language: summary.language
        },
        source
      };
    });
    const json = { cells };
    const text2 = JSON.stringify(json, void 0, IndentSize);
    return new AlternativeJsonDocument(text2, notebook);
  }
  getSummaryOfStructure(notebook, cellsToInclude, existingCodeMarker) {
    const lines = ["{", '    "cells: ['];
    const existingCodeMarkerWithComment = `// ${existingCodeMarker}`;
    notebook.getCells().forEach((cell) => {
      if (cellsToInclude.includes(cell)) {
        const cellSummary = summarize(cell);
        if (cellSummary.source.length && cellSummary.source[0].trim().length) {
          cellSummary.source = [cellSummary.source[0], existingCodeMarkerWithComment];
        } else if (cellSummary.source.length && cellSummary.source.some((line) => line.trim().length)) {
          cellSummary.source = [existingCodeMarkerWithComment, cellSummary.source.filter((line) => line.trim().length)[0], existingCodeMarkerWithComment];
        } else {
          cellSummary.source = [existingCodeMarkerWithComment];
        }
        const summary = JSON.stringify(cellSummary, void 0, IndentSize).split(/\r?\n/).map((line) => `    ${line}`);
        lines.push(...summary);
        lines.push(",");
      } else if (!lines.length || lines[lines.length - 1] !== existingCodeMarkerWithComment) {
        lines.push(existingCodeMarkerWithComment);
      }
    });
    lines.push(`    ]`);
    lines.push(`}`);
    return lines.join(EOL);
  }
  parseAlternateContentImpl(notebookOrUri, inputStream, token) {
    return new AsyncIterableObject(async (emitter) => {
      const cellIdMap = URI.isUri(notebookOrUri) ? /* @__PURE__ */ new Map() : getCellIdMap(notebookOrUri);
      const cellIdsSeen = /* @__PURE__ */ new Set();
      let jsonText = "";
      let lastSeenOffset = -1;
      const cellInfo = {
        index: -1,
        startOffset: -1,
        endOffset: -1,
        kind: NotebookCellKind2.Code,
        source: []
      };
      const defaultLanguage = URI.isUri(notebookOrUri) ? "python" : getDefaultLanguage(notebookOrUri);
      const emitCell = (endOffset) => {
        cellInfo.language = cellInfo.language || defaultLanguage;
        if (cellInfo.id && cellIdMap.get(cellInfo.id)?.document.languageId === cellInfo.language) {
          if (cellIdsSeen.has(cellInfo.id)) {
            cellInfo.id = "";
          } else {
            cellIdsSeen.add(cellInfo.id);
          }
        } else {
          cellInfo.id = "";
        }
        const cell = cellIdMap.get(cellInfo.id);
        cellInfo.uri = cell?.document.uri;
        cellInfo.kind = cell?.kind || (cellInfo.language === "markdown" ? NotebookCellKind2.Markup : NotebookCellKind2.Code);
        emitter.emitOne({ index: cellInfo.index, type: "start", kind: cellInfo.kind, language: cellInfo.language, uri: cellInfo.uri, id: cellInfo.id });
        cellInfo.source.forEach((cellLine) => emitter.emitOne({ index: cellInfo.index, type: "line", line: cellLine }));
        emitter.emitOne({ index: cellInfo.index, type: "end" });
      };
      let finalOffset = 0;
      for await (const lineOfText of inputStream) {
        if (token.isCancellationRequested) {
          break;
        }
        const line = lineOfText.value;
        jsonText += line;
        visit2(jsonText, {
          onObjectEnd(offset, _length, _startLine, _startCharacter) {
            finalOffset = offset;
          },
          onLiteralValue: (value, offset, _length, _startLine, _startCharacter, pathSupplier) => {
            if (lastSeenOffset >= offset) {
              return;
            }
            const segments = pathSupplier();
            if (segments.length < 2) {
              return;
            }
            if (segments.shift() !== "cells") {
              return;
            }
            const cellIndex = segments.shift();
            if (typeof cellIndex !== "number") {
              return;
            }
            const property = segments.shift();
            lastSeenOffset = offset;
            if (cellInfo.index !== -1 && cellInfo.index !== cellIndex) {
              emitCell(offset);
              cellInfo.startOffset = offset;
              cellInfo.id = void 0;
              cellInfo.kind = NotebookCellKind2.Code;
              cellInfo.source = [];
              cellInfo.uri = void 0;
              cellInfo.language = void 0;
            }
            cellInfo.index = cellIndex;
            if (property === "cell_type") {
              cellInfo.kind = value === "code" ? NotebookCellKind2.Code : NotebookCellKind2.Markup;
              if (cellInfo.kind === NotebookCellKind2.Markup) {
                cellInfo.language = "markdown";
              }
            } else if (property === "id") {
              cellInfo.id = value;
            } else if (property === "metadata" && segments[0] === "id") {
              cellInfo.id = value;
            } else if (property === "metadata" && segments[0] === "language") {
              cellInfo.language = value;
              if (cellInfo.language === "markdown") {
                cellInfo.kind = NotebookCellKind2.Markup;
              }
            } else if (property === "source" && segments.length && typeof segments[0] === "number") {
              if (segments[0] === 0) {
                cellInfo.startOffset = offset;
              }
              let code2 = typeof value === "string" ? value : `${value || ""}`;
              if (code2.endsWith("\n")) {
                code2 = code2.substr(0, code2.length - 1);
              }
              cellInfo.source.push(code2);
            }
          }
        });
      }
      if (cellInfo.index !== -1) {
        emitCell(finalOffset);
      }
    });
  }
};
function getCellCode2(document2) {
  if (document2.lineCount === 0) {
    return [];
  }
  if (document2.lineCount === 1) {
    return [document2.lineAt(0).text];
  }
  const lineCount = document2.lineCount;
  return new Array(lineCount).fill("").map((_, i) => document2.lineAt(i).text);
}

// src/util/common/languages.ts
var languages = Object.freeze({
  "abap": {
    lineComment: { start: "'" },
    markdownLanguageIds: ["abap", "sap-abap"]
  },
  "bat": {
    lineComment: { start: "REM" },
    alternativeLineComments: [{ start: "::" }],
    aliases: [
      "Batch",
      "bat"
    ],
    extensions: [
      ".bat",
      ".cmd"
    ]
  },
  "bibtex": {
    lineComment: { start: "%" },
    aliases: [
      "BibTeX",
      "bibtex"
    ],
    extensions: [
      ".bib"
    ]
  },
  "blade": {
    lineComment: { start: "#" }
  },
  "c": {
    lineComment: { start: "//" },
    aliases: [
      "C",
      "c"
    ],
    extensions: [
      ".c",
      ".i"
    ],
    markdownLanguageIds: ["c", "h"]
  },
  "clojure": {
    lineComment: { start: ";" },
    aliases: [
      "Clojure",
      "clojure"
    ],
    extensions: [
      ".clj",
      ".cljs",
      ".cljc",
      ".cljx",
      ".clojure",
      ".edn"
    ],
    markdownLanguageIds: ["clojure", "clj"]
  },
  "coffeescript": {
    lineComment: { start: "//" },
    aliases: [
      "CoffeeScript",
      "coffeescript",
      "coffee"
    ],
    extensions: [
      ".coffee",
      ".cson",
      ".iced"
    ],
    markdownLanguageIds: ["coffeescript", "coffee", "cson", "iced"],
    blockComment: ["###", "###"]
  },
  "cpp": {
    lineComment: { start: "//" },
    aliases: [
      "C++",
      "Cpp",
      "cpp"
    ],
    extensions: [
      ".cpp",
      ".cc",
      ".cxx",
      ".c++",
      ".hpp",
      ".hh",
      ".hxx",
      ".h++",
      ".h",
      ".ii",
      ".ino",
      ".inl",
      ".ipp",
      ".ixx",
      ".tpp",
      ".txx",
      ".hpp.in",
      ".h.in"
    ],
    markdownLanguageIds: ["cpp", "hpp", "cc", "hh", "c++", "h++", "cxx", "hxx"],
    blockComment: ["/*", "*/"]
  },
  "csharp": {
    lineComment: { start: "//" },
    aliases: [
      "C#",
      "csharp"
    ],
    extensions: [
      ".cs",
      ".csx",
      ".cake"
    ],
    markdownLanguageIds: ["csharp", "cs"],
    blockComment: ["/*", "*/"]
  },
  "css": {
    lineComment: { start: "/*", end: "*/" },
    aliases: [
      "CSS",
      "css"
    ],
    extensions: [
      ".css"
    ],
    blockComment: ["/*", "*/"]
  },
  "dart": {
    lineComment: { start: "//" },
    aliases: [
      "Dart"
    ],
    extensions: [
      ".dart"
    ],
    blockComment: ["/*", "*/"]
  },
  "dockerfile": {
    lineComment: { start: "#" },
    aliases: [
      "Docker",
      "Dockerfile",
      "Containerfile"
    ],
    extensions: [
      ".dockerfile",
      ".containerfile"
    ],
    markdownLanguageIds: ["dockerfile", "docker"]
  },
  "elixir": {
    lineComment: { start: "#" }
  },
  "erb": {
    lineComment: { start: "<%#", end: "%>" }
  },
  "erlang": {
    lineComment: { start: "%" },
    markdownLanguageIds: ["erlang", "erl"]
  },
  "fsharp": {
    lineComment: { start: "//" },
    aliases: [
      "F#",
      "FSharp",
      "fsharp"
    ],
    extensions: [
      ".fs",
      ".fsi",
      ".fsx",
      ".fsscript"
    ],
    markdownLanguageIds: ["fsharp", "fs", "fsx", "fsi", "fsscript"],
    blockComment: ["(*", "*)"]
  },
  "go": {
    lineComment: { start: "//" },
    aliases: [
      "Go"
    ],
    extensions: [
      ".go"
    ],
    markdownLanguageIds: ["go", "golang"],
    blockComment: ["/*", "*/"]
  },
  "groovy": {
    lineComment: { start: "//" },
    aliases: [
      "Groovy",
      "groovy"
    ],
    extensions: [
      ".groovy",
      ".gvy",
      ".gradle",
      ".jenkinsfile",
      ".nf"
    ],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "haml": {
    lineComment: { start: "-#" }
  },
  "handlebars": {
    lineComment: { start: "{{!", end: "}}" },
    extensions: [
      ".hbs",
      ".handlebars"
    ],
    markdownLanguageIds: ["handlebars", "hbs", "html.hbs", "html.handlebars"],
    blockComment: [
      "{{!--",
      "--}}"
    ]
  },
  "haskell": {
    lineComment: { start: "--" },
    markdownLanguageIds: ["haskell", "hs"]
  },
  "html": {
    lineComment: { start: "<!--", end: "-->" },
    aliases: [
      "HTML",
      "htm",
      "html",
      "xhtml"
    ],
    extensions: [
      ".html",
      ".htm",
      ".shtml",
      ".xhtml",
      ".xht",
      ".mdoc",
      ".jsp",
      ".asp",
      ".aspx",
      ".jshtm",
      ".volt",
      ".ejs",
      ".rhtml"
    ],
    markdownLanguageIds: ["html", "xhtml"],
    blockComment: [
      "<!--",
      "-->"
    ]
  },
  "ini": {
    lineComment: { start: ";" },
    blockComment: [
      ";",
      " "
    ]
  },
  "java": {
    lineComment: { start: "//" },
    extensions: [
      ".java",
      ".class"
    ],
    markdownLanguageIds: ["java", "jsp"],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "javascript": {
    lineComment: { start: "//" },
    aliases: [
      "JavaScript",
      "javascript",
      "js"
    ],
    extensions: [
      ".js",
      ".es6",
      ".mjs",
      ".cjs",
      ".pac"
    ],
    markdownLanguageIds: ["javascript", "js"],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "javascriptreact": {
    lineComment: { start: "//" },
    aliases: [
      "JavaScript JSX",
      "JavaScript React",
      "jsx"
    ],
    extensions: [
      ".jsx"
    ],
    markdownLanguageIds: ["jsx"]
  },
  "json": {
    extensions: [
      ".json"
    ],
    lineComment: { start: "//" },
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "jsonc": {
    lineComment: { start: "//" }
  },
  "jsx": {
    lineComment: { start: "//" },
    markdownLanguageIds: ["jsx"]
  },
  "julia": {
    lineComment: { start: "#" },
    aliases: [
      "Julia",
      "julia"
    ],
    extensions: [
      ".jl"
    ],
    markdownLanguageIds: ["julia", "jl"],
    blockComment: [
      "#=",
      "=#"
    ]
  },
  "kotlin": {
    lineComment: { start: "//" },
    markdownLanguageIds: ["kotlin", "kt"]
  },
  "latex": {
    lineComment: { start: "%" },
    aliases: [
      "LaTeX",
      "latex"
    ],
    extensions: [
      ".tex",
      ".ltx",
      ".ctx"
    ],
    markdownLanguageIds: ["tex"]
  },
  "less": {
    lineComment: { start: "//" },
    aliases: [
      "Less",
      "less"
    ],
    extensions: [
      ".less"
    ],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "lua": {
    lineComment: { start: "--" },
    aliases: [
      "Lua",
      "lua"
    ],
    extensions: [
      ".lua"
    ],
    markdownLanguageIds: ["lua", "pluto"],
    blockComment: [
      "--[[",
      "]]"
    ]
  },
  "makefile": {
    lineComment: { start: "#" },
    aliases: [
      "Makefile",
      "makefile"
    ],
    extensions: [
      ".mak",
      ".mk"
    ],
    markdownLanguageIds: ["makefile", "mk", "mak", "make"]
  },
  "markdown": {
    lineComment: { start: "<!--", end: "-->" },
    alternativeLineComments: [
      { start: "[]: #" }
    ],
    aliases: [
      "Markdown",
      "markdown"
    ],
    extensions: [
      ".md",
      ".mkd",
      ".mdwn",
      ".mdown",
      ".markdown",
      ".markdn",
      ".mdtxt",
      ".mdtext",
      ".workbook"
    ],
    markdownLanguageIds: ["markdown", "md", "mkdown", "mkd"]
  },
  "objective-c": {
    lineComment: { start: "//" },
    aliases: [
      "Objective-C"
    ],
    extensions: [
      ".m"
    ],
    markdownLanguageIds: ["objectivec", "mm", "objc", "obj-c"],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "objective-cpp": {
    lineComment: { start: "//" },
    aliases: [
      "Objective-C++"
    ],
    extensions: [
      ".mm"
    ],
    markdownLanguageIds: ["objectivec++", "objc+"]
  },
  "perl": {
    lineComment: { start: "#" },
    aliases: [
      "Perl",
      "perl"
    ],
    extensions: [
      ".pl",
      ".pm",
      ".pod",
      ".t",
      ".PL",
      ".psgi"
    ],
    markdownLanguageIds: ["perl", "pl", "pm"]
  },
  "php": {
    lineComment: { start: "//" },
    aliases: [
      "PHP",
      "php"
    ],
    extensions: [
      ".php",
      ".php4",
      ".php5",
      ".phtml",
      ".ctp"
    ],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "powershell": {
    lineComment: { start: "#" },
    aliases: [
      "PowerShell",
      "powershell",
      "ps",
      "ps1"
    ],
    extensions: [
      ".ps1",
      ".psm1",
      ".psd1",
      ".pssc",
      ".psrc"
    ],
    markdownLanguageIds: ["powershell", "ps", "ps1"],
    blockComment: [
      "<#",
      "#>"
    ]
  },
  "pug": {
    lineComment: { start: "//" }
  },
  "python": {
    lineComment: { start: "#" },
    aliases: [
      "Python",
      "py"
    ],
    extensions: [
      ".py",
      ".rpy",
      ".pyw",
      ".cpy",
      ".gyp",
      ".gypi",
      ".pyi",
      ".ipy",
      ".pyt"
    ],
    markdownLanguageIds: ["python", "py", "gyp"],
    blockComment: [
      '"""',
      '"""'
    ]
  },
  "ql": {
    lineComment: { start: "//" }
  },
  "r": {
    lineComment: { start: "#" },
    aliases: [
      "R",
      "r"
    ],
    extensions: [
      ".r",
      ".rhistory",
      ".rprofile",
      ".rt"
    ]
  },
  "razor": {
    lineComment: { start: "<!--", end: "-->" },
    aliases: [
      "Razor",
      "razor"
    ],
    extensions: [
      ".cshtml",
      ".razor"
    ],
    markdownLanguageIds: ["cshtml", "razor", "razor-cshtml"],
    blockComment: [
      "<!--",
      "-->"
    ]
  },
  "ruby": {
    lineComment: { start: "#" },
    aliases: [
      "Ruby",
      "rb"
    ],
    extensions: [
      ".rb",
      ".rbx",
      ".rjs",
      ".gemspec",
      ".rake",
      ".ru",
      ".erb",
      ".podspec",
      ".rbi"
    ],
    markdownLanguageIds: ["ruby", "rb", "gemspec", "podspec", "thor", "irb"],
    blockComment: [
      "=begin",
      "=end"
    ]
  },
  "rust": {
    lineComment: { start: "//" },
    aliases: [
      "Rust",
      "rust"
    ],
    extensions: [
      ".rs"
    ],
    markdownLanguageIds: ["rust", "rs"],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "sass": {
    lineComment: { start: "//" }
  },
  "scala": {
    lineComment: { start: "//" }
  },
  "scss": {
    lineComment: { start: "//" },
    aliases: [
      "SCSS",
      "scss"
    ],
    extensions: [
      ".scss"
    ],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "shellscript": {
    lineComment: { start: "#" },
    aliases: [
      "Shell Script",
      "shellscript",
      "bash",
      "fish",
      "sh",
      "zsh",
      "ksh",
      "csh"
    ],
    extensions: [
      ".sh",
      ".bash",
      ".bashrc",
      ".bash_aliases",
      ".bash_profile",
      ".bash_login",
      ".ebuild",
      ".profile",
      ".bash_logout",
      ".xprofile",
      ".xsession",
      ".xsessionrc",
      ".Xsession",
      ".zsh",
      ".zshrc",
      ".zprofile",
      ".zlogin",
      ".zlogout",
      ".zshenv",
      ".zsh-theme",
      ".fish",
      ".ksh",
      ".csh",
      ".cshrc",
      ".tcshrc",
      ".yashrc",
      ".yash_profile"
    ],
    markdownLanguageIds: ["bash", "sh", "zsh"]
  },
  "slim": {
    lineComment: { start: "/" }
  },
  "solidity": {
    lineComment: { start: "//" },
    markdownLanguageIds: ["solidity", "sol"]
  },
  "sql": {
    lineComment: { start: "--" },
    aliases: [
      "SQL"
    ],
    extensions: [
      ".sql",
      ".dsql"
    ],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "stylus": {
    lineComment: { start: "//" }
  },
  "svelte": {
    lineComment: { start: "<!--", end: "-->" }
  },
  "swift": {
    lineComment: { start: "//" },
    aliases: [
      "Swift",
      "swift"
    ],
    extensions: [
      ".swift"
    ],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "terraform": {
    lineComment: { start: "#" }
  },
  "tex": {
    lineComment: { start: "%" },
    aliases: [
      "TeX",
      "tex"
    ],
    extensions: [
      ".sty",
      ".cls",
      ".bbx",
      ".cbx"
    ]
  },
  "typescript": {
    lineComment: { start: "//" },
    aliases: [
      "TypeScript",
      "ts",
      "typescript"
    ],
    extensions: [
      ".ts",
      ".cts",
      ".mts"
    ],
    markdownLanguageIds: ["typescript", "ts"],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "typescriptreact": {
    lineComment: { start: "//" },
    aliases: [
      "TypeScript JSX",
      "TypeScript React",
      "tsx"
    ],
    extensions: [
      ".tsx"
    ],
    markdownLanguageIds: ["tsx"],
    blockComment: [
      "/*",
      "*/"
    ]
  },
  "vb": {
    lineComment: { start: "'" },
    aliases: [
      "Visual Basic",
      "vb"
    ],
    extensions: [
      ".vb",
      ".brs",
      ".vbs",
      ".bas",
      ".vba"
    ],
    markdownLanguageIds: ["vb", "vbscript"]
  },
  "verilog": {
    lineComment: { start: "//" }
  },
  "vue-html": {
    lineComment: { start: "<!--", end: "-->" }
  },
  "vue": {
    lineComment: { start: "//" },
    extensions: [
      ".vue"
    ]
  },
  "xml": {
    lineComment: { start: "<!--", end: "-->" },
    aliases: [
      "XML",
      "xml"
    ],
    extensions: [
      ".xml",
      ".xsd",
      ".ascx",
      ".atom",
      ".axml",
      ".axaml",
      ".bpmn",
      ".cpt",
      ".csl",
      ".csproj",
      ".csproj.user",
      ".dita",
      ".ditamap",
      ".dtd",
      ".ent",
      ".mod",
      ".dtml",
      ".fsproj",
      ".fxml",
      ".iml",
      ".isml",
      ".jmx",
      ".launch",
      ".menu",
      ".mxml",
      ".nuspec",
      ".opml",
      ".owl",
      ".proj",
      ".props",
      ".pt",
      ".publishsettings",
      ".pubxml",
      ".pubxml.user",
      ".rbxlx",
      ".rbxmx",
      ".rdf",
      ".rng",
      ".rss",
      ".shproj",
      ".storyboard",
      ".svg",
      ".targets",
      ".tld",
      ".tmx",
      ".vbproj",
      ".vbproj.user",
      ".vcxproj",
      ".vcxproj.filters",
      ".wsdl",
      ".wxi",
      ".wxl",
      ".wxs",
      ".xaml",
      ".xbl",
      ".xib",
      ".xlf",
      ".xliff",
      ".xpdl",
      ".xul",
      ".xoml"
    ],
    blockComment: [
      "<!--",
      "-->"
    ]
  },
  "xsl": {
    lineComment: { start: "<!--", end: "-->" },
    aliases: [
      "XSL",
      "xsl"
    ],
    extensions: [
      ".xsl",
      ".xslt"
    ]
  },
  "yaml": {
    lineComment: { start: "#" },
    markdownLanguageIds: ["yaml", "yml"]
  }
});
var wellKnownLanguages = new Map(
  Object.entries(languages).map(([languageId, info]) => [languageId, { languageId, ...info }])
);
function getLanguage(v) {
  if (typeof v === "string") {
    return _getLanguage(v);
  }
  if (typeof v === "undefined") {
    return _getLanguage("plaintext");
  }
  return _getLanguage(v.languageId);
}
function _getLanguage(languageId) {
  return wellKnownLanguages.get(languageId.toLowerCase()) ?? { languageId, lineComment: { start: "//" } };
}

// src/platform/notebook/common/alternativeContentProvider.text.ts
init_arraysFind();
function generateCellTextMarker(cell, lineComment) {
  const cellIdStr = cell.id ? `[id=${cell.id}] ` : "";
  return `${lineComment}%% vscode.cell ${cellIdStr}[language=${cell.language}]`;
}
function lineMightHaveCellMarker(line) {
  return line.toLowerCase().includes("vscode.cell");
}
var AlternativeTextDocument = class extends AlternativeNotebookDocument {
  constructor(text2, cellOffsetMap, notebook) {
    super(text2, notebook);
    this.cellOffsetMap = cellOffsetMap;
  }
  fromCellPosition(cell, position) {
    const cellSummary = summarize(cell);
    const lineCommentStart = getLineCommentStart(this.notebook);
    const cellMarker = generateCellTextMarker(cellSummary, lineCommentStart);
    const eolLength = cell.document.eol === EndOfLine2.LF ? 1 : 2;
    const blockComment = getBlockComment(this.notebook);
    const alternativeContentText = this.getText();
    const offsetInCell = cell.document.offsetAt(position);
    const markdownOffset = cell.kind === NotebookCellKind2.Markup ? blockComment[0].length + eolLength : 0;
    const offset = alternativeContentText.indexOf(cellMarker) + cellMarker.length + eolLength + markdownOffset + offsetInCell;
    return this.positionAt(offset);
  }
  toCellPosition(position) {
    const offset = this.offsetAt(position);
    const cell = findLast(this.cellOffsetMap, (cell2) => cell2.sourceOffset <= offset);
    if (!cell) {
      return void 0;
    }
    const cellPosition = cell.cell.document.positionAt(offset - cell.sourceOffset);
    return { cell: cell.cell, position: cellPosition };
  }
};
var AlternativeTextNotebookContentProvider = class extends BaseAlternativeNotebookContentProvider {
  constructor() {
    super("text");
  }
  stripCellMarkers(text2) {
    const lines = text2.split(EOL);
    if (lines.length && lineMightHaveCellMarker(lines[0])) {
      lines.shift();
      return lines.join(EOL);
    } else {
      return text2;
    }
  }
  getSummaryOfStructure(notebook, cellsToInclude, existingCodeMarker) {
    const blockComment = getBlockComment(notebook);
    const lineCommentStart = getLineCommentStart(notebook);
    const existingCodeMarkerWithComment = `${lineCommentStart} ${existingCodeMarker}`;
    const lines = [];
    notebook.getCells().forEach((cell) => {
      if (cellsToInclude.includes(cell)) {
        const cellSummary = summarize(cell);
        if (cellSummary.source.length && cellSummary.source[0].trim().length) {
          cellSummary.source = [cellSummary.source[0], existingCodeMarkerWithComment];
        } else if (cellSummary.source.length && cellSummary.source.some((line) => line.trim().length)) {
          cellSummary.source = [existingCodeMarkerWithComment, cellSummary.source.filter((line) => line.trim().length)[0], existingCodeMarkerWithComment];
        } else {
          cellSummary.source = [existingCodeMarkerWithComment];
        }
        lines.push(generateAlternativeCellTextContent(cellSummary, lineCommentStart, blockComment).content);
      } else if (!lines.length || lines[lines.length - 1] !== existingCodeMarkerWithComment) {
        lines.push(existingCodeMarkerWithComment);
      }
    });
    return lines.join(EOL);
  }
  async *parseAlternateContent(notebookOrUri, inputStream, token) {
    const isNotebook = !isUri(notebookOrUri);
    const cellIdMap = isNotebook ? getCellIdMap(notebookOrUri) : /* @__PURE__ */ new Map();
    let inMarkdownCell = false;
    let isInTripleQuotes = false;
    let pendingTripleQuotes = false;
    let emittedStart = false;
    let cellIndex = -1;
    const lineCommentStart = getLineCommentStart(isNotebook ? notebookOrUri : void 0);
    const blockComment = getBlockComment(isNotebook ? notebookOrUri : void 0);
    const defaultLanguage = isNotebook ? getLanguage(getDefaultLanguage(notebookOrUri)).languageId : void 0;
    const cellIdsSeen = /* @__PURE__ */ new Set();
    for await (const lineOfText of inputStream) {
      if (token.isCancellationRequested) {
        break;
      }
      const line = lineOfText.value;
      const isLineCommentForEmptyCellWithoutCellMarker = line.startsWith(`${lineCommentStart}%% [`) && line.trimEnd().endsWith("]");
      const isLineCommentWithCellMarker = line.startsWith(`${lineCommentStart}%% vscode.cell`);
      const cellParts = isLineCommentWithCellMarker || isLineCommentForEmptyCellWithoutCellMarker ? extractCellParts(line, defaultLanguage) : void 0;
      if ((isLineCommentWithCellMarker || isLineCommentForEmptyCellWithoutCellMarker) && cellParts?.language) {
        if (pendingTripleQuotes) {
          pendingTripleQuotes = false;
        }
        const lineOfCellText = { index: -1, uri: void 0, language: void 0, kind: NotebookCellKind2.Code, emitted: false, type: "start" };
        lineOfCellText.index = cellIndex += 1;
        lineOfCellText.emitted = false;
        if (cellParts.id && cellIdMap.get(cellParts.id)?.document.languageId === cellParts.language) {
          if (cellIdsSeen.has(cellParts.id)) {
            cellParts.id = "";
          } else {
            cellIdsSeen.add(cellParts.id);
          }
        } else {
          cellParts.id = "";
        }
        const cell = cellIdMap.get(cellParts.id);
        lineOfCellText.id = cellParts.id;
        lineOfCellText.language = cellParts.language;
        lineOfCellText.uri = cell?.document.uri;
        lineOfCellText.kind = cell?.kind || (lineOfCellText.language === "markdown" ? NotebookCellKind2.Markup : NotebookCellKind2.Code);
        inMarkdownCell = lineOfCellText.language === "markdown";
        isInTripleQuotes = false;
        if (emittedStart) {
          yield { index: cellIndex - 1, type: "end" };
        }
        emittedStart = true;
        yield lineOfCellText;
        continue;
      }
      if (!emittedStart) {
        continue;
      }
      if (inMarkdownCell) {
        if (!isInTripleQuotes) {
          if (line === blockComment[0]) {
            isInTripleQuotes = true;
          } else {
            yield { index: cellIndex, line, type: "line" };
          }
        } else {
          if (line === blockComment[1]) {
            isInTripleQuotes = false;
            pendingTripleQuotes = true;
          } else {
            yield { index: cellIndex, line, type: "line" };
          }
        }
      } else {
        yield { index: cellIndex, line, type: "line" };
      }
    }
    if (emittedStart) {
      yield { index: cellIndex, type: "end" };
    }
  }
  getAlternativeDocumentFromText(text2, notebook) {
    const blockComment = getBlockComment(notebook);
    const lineCommentStart = getLineCommentStart(notebook);
    const cellIdMap = getCellIdMap(notebook);
    const cellOffsetMap = [];
    const lines = text2.split(EOL);
    let currentOffset = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isLineCommentForEmptyCellWithoutCellMarker = line.startsWith(`${lineCommentStart}%% [`) && line.trimEnd().endsWith("]");
      const isLineCommentWithCellMarker = line.startsWith(`${lineCommentStart}%% vscode.cell`);
      if (isLineCommentWithCellMarker || isLineCommentForEmptyCellWithoutCellMarker) {
        const cellParts = extractCellParts(line, void 0);
        if (cellParts) {
          const cell = cellIdMap.get(cellParts.id) || notebook.getCells().find(
            (c) => c.document.languageId === cellParts.language && !cellOffsetMap.some((entry) => entry.cell === c)
          );
          if (cell) {
            const offset = currentOffset;
            const eolLength = EOL.length;
            const isMarkdown = cellParts.language === "markdown";
            const sourceOffset = offset + line.length + eolLength + (isMarkdown ? blockComment[0].length + eolLength : 0);
            cellOffsetMap.push({ offset, sourceOffset, cell });
          }
        }
      }
      currentOffset += line.length + EOL.length;
    }
    return new AlternativeTextDocument(text2, cellOffsetMap, notebook);
  }
  getAlternativeDocument(notebook, excludeMarkdownCells) {
    const cells = notebook.getCells().filter((cell) => excludeMarkdownCells ? cell.kind !== NotebookCellKind2.Markup : true).map((cell) => summarize(cell));
    const blockComment = getBlockComment(notebook);
    const lineCommentStart = getLineCommentStart(notebook);
    const cellContent = cells.map((cell) => ({ ...generateAlternativeCellTextContent(cell, lineCommentStart, blockComment), cell: notebook.cellAt(cell.index) }));
    const content = cellContent.map((cell) => cell.content).join(EOL);
    const cellOffsetMap = cellContent.map((cellContent2) => {
      const offset = content.indexOf(cellContent2.content);
      const sourceOffset = offset + cellContent2.prefix.length;
      return { offset, sourceOffset, cell: notebook.cellAt(cellContent2.cell.index) };
    });
    return new AlternativeTextDocument(content, cellOffsetMap, notebook);
  }
};
function generateAlternativeCellTextContent(cell, lineCommentStart, blockComment) {
  const cellMarker = generateCellTextMarker(cell, lineCommentStart);
  const src = cell.source.join(EOL);
  const prefix = cell.language === "markdown" ? `${cellMarker}${EOL}${blockComment[0]}${EOL}` : `${cellMarker}${EOL}`;
  const content = cell.language === "markdown" ? `${prefix}${src}${EOL}${blockComment[1]}` : `${prefix}${src}`;
  return { content, prefix };
}
function getBlockComment(notebook) {
  if (!notebook) {
    return ['"""', '"""'];
  }
  const language2 = getLanguage(getDefaultLanguage(notebook));
  return language2.blockComment ?? ["```", "```"];
}
function getLineCommentStart(notebook) {
  if (!notebook) {
    return "#";
  }
  const language2 = getLanguage(getDefaultLanguage(notebook));
  return language2.lineComment.start || "#";
}
function extractCellParts(line, defaultLanguage) {
  const idMatch = line.match(/\[id=(.+?)\]/);
  const languageMatch = line.match(/\[language=(.+?)\]/);
  if (!languageMatch) {
    if (lineMightHaveCellMarker(line) && typeof defaultLanguage === "string") {
      return { id: idMatch ? idMatch[1].trim() : "", language: defaultLanguage };
    }
    return;
  }
  return { id: idMatch ? idMatch[1].trim() : "", language: languageMatch[1].trim() };
}

// src/platform/notebook/common/alternativeContentProvider.xml.ts
init_arraysFind();
var StartDelimter = `<VSCode.Cell `;
var StartEmptyCellDelimter = `<VSCode.Cell>`;
var EndDelimter = `</VSCode.Cell>`;
function generatePartialStartDelimiterWithId(id2) {
  return `${StartDelimter}id="${id2}" `;
}
function generateCellMarker(cell) {
  return `${generatePartialStartDelimiterWithId(cell.id)}language="${cell.language}">`;
}
function isXmlContent(text2) {
  return text2.includes(StartDelimter) || text2.includes(EndDelimter) || text2.includes(StartEmptyCellDelimter);
}
var AlternativeXmlDocument = class extends AlternativeNotebookDocument {
  constructor(text2, cellOffsetMap, notebook) {
    super(text2, notebook);
    this.cellOffsetMap = cellOffsetMap;
  }
  fromCellPosition(cell, position) {
    const cellSummary = summarize(cell);
    const cellMarker = generateCellMarker(cellSummary);
    const eolLength = cell.document.eol === EndOfLine2.LF ? 1 : 2;
    const alternativeContentText = this.getText();
    const offsetInCell = cell.document.offsetAt(position);
    const offset = alternativeContentText.indexOf(cellMarker) + cellMarker.length + eolLength + offsetInCell;
    return this.positionAt(offset);
  }
  toCellPosition(position) {
    const offset = this.offsetAt(position);
    const cell = findLast(this.cellOffsetMap, (cell2) => cell2.offset <= offset);
    if (!cell) {
      return void 0;
    }
    const cellPosition = cell.cell.document.positionAt(offset - cell.offset);
    return { cell: cell.cell, position: cellPosition };
  }
};
var AlternativeXmlNotebookContentProvider = class extends BaseAlternativeNotebookContentProvider {
  constructor() {
    super("xml");
  }
  stripCellMarkers(text2) {
    const lines = text2.split(EOL);
    if (lines.length && (lines[0].startsWith(StartDelimter) || lines[0].startsWith(StartEmptyCellDelimter))) {
      lines.shift();
    }
    if (lines.length && lines[lines.length - 1].trim().endsWith(EndDelimter)) {
      lines[lines.length - 1] = lines[lines.length - 1].substring(0, lines[lines.length - 1].lastIndexOf(EndDelimter));
    }
    return lines.join(EOL);
  }
  getSummaryOfStructure(notebook, cellsToInclude, existingCodeMarker) {
    const lines = [];
    const existingCodeMarkerWithComment = `// ${existingCodeMarker}`;
    notebook.getCells().forEach((cell) => {
      if (cellsToInclude.includes(cell)) {
        const cellSummary = summarize(cell);
        lines.push(generateCellMarker(cellSummary));
        if (cellSummary.source.length && cellSummary.source[0].trim().length) {
          lines.push(cellSummary.source[0]);
          lines.push(existingCodeMarkerWithComment);
        } else if (cellSummary.source.length && cellSummary.source.some((line) => line.trim().length)) {
          cellSummary.source = [existingCodeMarkerWithComment, cellSummary.source.filter((line) => line.trim().length)[0], existingCodeMarkerWithComment];
        } else {
          lines.push(existingCodeMarkerWithComment);
        }
        lines.push(EndDelimter);
      } else if (!lines.length || lines[lines.length - 1] !== existingCodeMarkerWithComment) {
        lines.push(existingCodeMarkerWithComment);
      }
    });
    return lines.join(EOL);
  }
  async *parseAlternateContent(notebookOrUri, inputStream, token) {
    const isNotebook = !isUri(notebookOrUri);
    const cellIdMap = isNotebook ? getCellIdMap(notebookOrUri) : /* @__PURE__ */ new Map();
    let index = -1;
    let endDelimiterSeen = false;
    const cellIdsSeen = /* @__PURE__ */ new Set();
    let previousLineEndedWithEndCellMarker = false;
    let previousLine = void 0;
    const defaultLanguage = isNotebook ? getLanguage(getDefaultLanguage(notebookOrUri)).languageId : void 0;
    for await (const lineOfText of inputStream) {
      if (token.isCancellationRequested) {
        break;
      }
      const line = lineOfText.value;
      if ((line.startsWith(StartDelimter) || line.startsWith(StartEmptyCellDelimter)) && (index < 0 || (endDelimiterSeen || previousLineEndedWithEndCellMarker && previousLine))) {
        if (!endDelimiterSeen && previousLineEndedWithEndCellMarker && previousLine) {
          previousLine.line = previousLine.line.substring(0, previousLine.line.lastIndexOf(EndDelimter));
          yield previousLine;
          yield { type: "end", index: previousLine.index };
        }
        previousLineEndedWithEndCellMarker = false;
        previousLine = void 0;
        index += 1;
        endDelimiterSeen = false;
        const lineOfCellText = { type: "start", index, uri: void 0, language: void 0, kind: NotebookCellKind2.Code };
        const cellParts = extractCellParts2(line, defaultLanguage);
        if (cellParts.id && cellIdMap.get(cellParts.id)?.document.languageId === cellParts.language) {
          if (cellIdsSeen.has(cellParts.id)) {
            cellParts.id = "";
          } else {
            cellIdsSeen.add(cellParts.id);
          }
        } else {
          cellParts.id = "";
        }
        const cell = cellIdMap.get(cellParts.id)?.document.languageId === cellParts.language ? cellIdMap.get(cellParts.id) : void 0;
        lineOfCellText.id = cellParts.id;
        lineOfCellText.language = cellParts.language;
        lineOfCellText.uri = cell?.document.uri;
        lineOfCellText.kind = cell?.kind || (lineOfCellText.language === "markdown" ? NotebookCellKind2.Markup : NotebookCellKind2.Code);
        yield lineOfCellText;
      } else if (line.startsWith(EndDelimter)) {
        if (previousLineEndedWithEndCellMarker && previousLine) {
          yield previousLine;
        }
        endDelimiterSeen = true;
        previousLineEndedWithEndCellMarker = false;
        previousLine = void 0;
        yield { type: "end", index };
      } else if (index >= 0) {
        if (previousLineEndedWithEndCellMarker && previousLine) {
          yield previousLine;
          previousLine = void 0;
        }
        previousLineEndedWithEndCellMarker = line.endsWith(EndDelimter);
        if (previousLineEndedWithEndCellMarker) {
          previousLine = { type: "line", index, line };
        } else {
          yield { type: "line", index, line };
        }
      }
    }
  }
  getAlternativeDocumentFromText(text2, notebook) {
    const cellIdMap = getCellIdMap(notebook);
    const cellOffsetMap = [];
    const lines = text2.split(EOL);
    let currentOffset = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.startsWith(StartDelimter) || line.startsWith(StartEmptyCellDelimter)) {
        const cellParts = extractCellParts2(line, void 0);
        const cell = cellIdMap.get(cellParts.id) || notebook.getCells().find(
          (c) => c.document.languageId === cellParts.language && !cellOffsetMap.some((entry) => entry.cell === c)
        );
        if (cell) {
          const eolLength = EOL.length;
          const offset = currentOffset + line.length + eolLength;
          cellOffsetMap.push({ offset, cell });
        }
      }
      currentOffset += line.length + EOL.length;
    }
    return new AlternativeXmlDocument(text2, cellOffsetMap, notebook);
  }
  getAlternativeDocument(notebook, excludeMarkdownCells) {
    const cells = notebook.getCells().filter((cell) => excludeMarkdownCells ? cell.kind !== NotebookCellKind2.Markup : true).map((cell) => summarize(cell));
    const cellContent = cells.map((cell) => {
      const cellMarker = generateCellMarker(cell);
      const prefix = `${cellMarker}${EOL}`;
      return { content: `${prefix}${cell.source.join(EOL)}${EOL}${EndDelimter}`, prefix, cell: notebook.cellAt(cell.index) };
    });
    const content = cellContent.map((cell) => cell.content).join(EOL);
    const cellOffsetMap = cellContent.map((cellContent2) => ({ offset: content.indexOf(cellContent2.content) + cellContent2.prefix.length, cell: cellContent2.cell }));
    return new AlternativeXmlDocument(content, cellOffsetMap, notebook);
  }
};
function extractCellParts2(line, defaultLanguage) {
  const idMatch = line.match(/id="([^"]+)"/);
  const languageMatch = line.match(/language="([^"]+)"/);
  if (!languageMatch) {
    if (isXmlContent(line) && typeof defaultLanguage === "string") {
      return { id: idMatch ? idMatch[1].trim() : "", language: defaultLanguage };
    }
    throw new Error(`Invalid cell part in ${line}`);
  }
  return { id: idMatch ? idMatch[1].trim() : "", language: languageMatch[1].trim() };
}

// src/platform/notebook/common/alternativeContent.ts
function getAlternativeNotebookDocumentProvider(kind) {
  switch (kind) {
    case "xml":
      return new AlternativeXmlNotebookContentProvider();
    case "text":
      return new AlternativeTextNotebookContentProvider();
    case "json":
      return new AlternativeJsonNotebookContentProvider();
    default:
      throw new Error(`Unsupported kind '${kind}'`);
  }
}
var IAlternativeNotebookContentService = createDecorator("IAlternativeNotebookContentService");
var AlternativeNotebookContentService = class {
  constructor(configurationService, experimentationService) {
    this.configurationService = configurationService;
    this.experimentationService = experimentationService;
  }
  getFormat(options) {
    if (options && modelPrefersJsonNotebookRepresentation(options)) {
      return "json";
    }
    return this.configurationService.getExperimentBasedConfig(ConfigKey.AdvancedExperimentalExperiments.NotebookAlternativeDocumentFormat, this.experimentationService);
  }
  create(format6) {
    return getAlternativeNotebookDocumentProvider(format6);
  }
};
AlternativeNotebookContentService = __decorateClass([
  __decorateParam(0, IConfigurationService),
  __decorateParam(1, IExperimentationService)
], AlternativeNotebookContentService);

// src/platform/editing/common/notebookDocumentSnapshot.ts
var NotebookDocumentSnapshot = class _NotebookDocumentSnapshot {
  constructor(doc, uri, version2, alternativeFormat, _alternativeDocument) {
    this.alternativeFormat = alternativeFormat;
    this._alternativeDocument = _alternativeDocument;
    this.type = "notebook";
    this.document = doc;
    this.uri = uri;
    this.version = version2;
    this.languageId = alternativeFormat === "text" ? getDefaultLanguage(doc) || "python" : alternativeFormat;
  }
  static create(doc, format6) {
    const uri = doc.uri;
    const version2 = doc.version;
    const alternativeDocument = getAlternativeNotebookDocumentProvider(format6).getAlternativeDocument(doc);
    return new _NotebookDocumentSnapshot(doc, uri, version2, format6, alternativeDocument);
  }
  static fromNewText(text2, doc) {
    const alternativeDocument = getAlternativeNotebookDocumentProvider(doc.alternativeFormat).getAlternativeDocumentFromText(text2, doc.document);
    const nd = new _NotebookDocumentSnapshot(doc.document, doc.uri, doc.version, doc.alternativeFormat, alternativeDocument);
    return nd;
  }
  static fromJSON(doc, json) {
    return _NotebookDocumentSnapshot.create(doc, json.alternativeFormat);
  }
  getText(range) {
    return this._alternativeDocument.getText(range);
  }
  getSelection() {
    return new Selection2(0, 0, this.lineCount, 0);
  }
  getWholeRange() {
    return new Range3(0, 0, this.lineCount, 0);
  }
  get lines() {
    return this._alternativeDocument.lines;
  }
  get lineCount() {
    return this._alternativeDocument.lineCount;
  }
  lineAt(lineOrPosition) {
    let line;
    if (lineOrPosition instanceof Position3) {
      line = lineOrPosition.line;
    } else if (typeof lineOrPosition === "number") {
      line = lineOrPosition;
    } else {
      throw new Error(`Invalid argument`);
    }
    if (line < 0 || line >= this.lines.length) {
      throw new Error("Illegal value for `line`");
    }
    return this._alternativeDocument.lineAt(line);
  }
  offsetAt(position) {
    return this._alternativeDocument.offsetAt(position);
  }
  positionAt(offset) {
    return this._alternativeDocument.positionAt(offset);
  }
  validateRange(range) {
    return this._alternativeDocument.validateRange(range);
  }
  validatePosition(position) {
    return this._alternativeDocument.validatePosition(position);
  }
  toJSON() {
    return {
      type: "notebook",
      uri: this.uri.toJSON(),
      languageId: this.languageId,
      version: this.version,
      _text: this._alternativeDocument.getText(),
      alternativeFormat: this.alternativeFormat
    };
  }
};

// src/platform/workspace/common/workspaceService.ts
init_lifecycle();
init_event();
var IWorkspaceService = createDecorator("IWorkspaceService");
var AbstractWorkspaceService = class {
  asRelativePath(pathOrUri, includeWorkspaceFolder) {
    let resource;
    let path = "";
    if (typeof pathOrUri === "string") {
      resource = URI.file(pathOrUri);
      path = pathOrUri;
    } else if (typeof pathOrUri !== "undefined") {
      resource = pathOrUri;
      path = pathOrUri.fsPath;
    }
    if (!resource) {
      return path;
    }
    const folder = this.getWorkspaceFolder(resource);
    if (!folder) {
      return path;
    }
    if (typeof includeWorkspaceFolder === "undefined") {
      includeWorkspaceFolder = this.getWorkspaceFolders().length > 1;
    }
    let result = relativePath(folder, resource);
    if (includeWorkspaceFolder) {
      const name = this.getWorkspaceFolderName(folder);
      result = `${name}/${result}`;
    }
    return result;
  }
  async openTextDocumentAndSnapshot(uri) {
    const doc = await this.openTextDocument(uri);
    return TextDocumentSnapshot.create(doc);
  }
  async openNotebookDocumentAndSnapshot(uri, format6) {
    const doc = findNotebook(uri, this.notebookDocuments) || await this.openNotebookDocument(uri);
    return NotebookDocumentSnapshot.create(doc, format6);
  }
  getWorkspaceFolder(resource) {
    return this.getWorkspaceFolders().find((folder) => extUriBiasedIgnorePathCase.isEqualOrParent(resource, folder));
  }
};
function getWorkspaceFileDisplayPath(workspaceService, file) {
  const workspaceUri = workspaceService.getWorkspaceFolder(file);
  return workspaceUri ? posix.relative(workspaceUri.path, file.path) : file.path;
}

// src/platform/customInstructions/common/customInstructionsService.ts
var ICustomInstructionsService = createDecorator("ICustomInstructionsService");
function isCodeGenerationImportInstruction(instruction) {
  if (typeof instruction === "object" && instruction !== null) {
    return typeof instruction.file === "string" && (instruction.language === void 0 || typeof instruction.language === "string");
  }
  return false;
}
function isCodeGenerationTextInstruction(instruction) {
  if (typeof instruction === "object" && instruction !== null) {
    return typeof instruction.text === "string" && (instruction.language === void 0 || typeof instruction.language === "string");
  }
  return false;
}
var INSTRUCTION_FILE_EXTENSION = ".instructions.md";
var INSTRUCTIONS_LOCATION_KEY = "chat.instructionsFilesLocations";
var COPILOT_INSTRUCTIONS_PATH = ".github/copilot-instructions.md";
var CustomInstructionsService = class extends Disposable {
  constructor(configurationService, envService, workspaceService, fileSystemService, promptPathRepresentationService, logService, extensionService) {
    super();
    this.configurationService = configurationService;
    this.envService = envService;
    this.workspaceService = workspaceService;
    this.fileSystemService = fileSystemService;
    this.promptPathRepresentationService = promptPathRepresentationService;
    this.logService = logService;
    this.extensionService = extensionService;
    this._register(this.extensionService.onDidChange(() => {
      this._contributedInstructions = void 0;
    }));
  }
  async fetchInstructionsFromFile(fileUri) {
    return await this.readInstructionsFromFile(fileUri);
  }
  async getAgentInstructions() {
    const result = [];
    if (this.configurationService.getConfig(ConfigKey.UseInstructionFiles)) {
      for (const folder of this.workspaceService.getWorkspaceFolders()) {
        try {
          const uri = joinPath(folder, COPILOT_INSTRUCTIONS_PATH);
          if ((await this.fileSystemService.stat(uri)).type === FileType2.File) {
            result.push(uri);
          }
        } catch (e) {
        }
      }
    }
    return result;
  }
  async fetchInstructionsFromSetting(configKey) {
    const result = [];
    const instructions = [];
    const seenFiles = /* @__PURE__ */ new Set();
    const inspect = this.configurationService.inspectConfig(configKey);
    if (inspect) {
      await this.collectInstructionsFromSettings([inspect.workspaceFolderValue, inspect.workspaceValue, inspect.globalValue], seenFiles, instructions, result);
    }
    const reference2 = Uri3.from({ scheme: this.envService.uriScheme, authority: "settings", path: `/${configKey.fullyQualifiedId}` });
    if (instructions.length > 0) {
      result.push({
        kind: 1 /* Setting */,
        content: instructions,
        reference: reference2
      });
    }
    return result;
  }
  async collectInstructionsFromSettings(instructionsArrays, seenFiles, instructions, result) {
    const seenInstructions = /* @__PURE__ */ new Set();
    for (const instructionsArray of instructionsArrays) {
      if (Array.isArray(instructionsArray)) {
        for (const entry of instructionsArray) {
          if (isCodeGenerationImportInstruction(entry) && !seenFiles.has(entry.file)) {
            seenFiles.add(entry.file);
            await this._collectInstructionsFromFile(entry.file, entry.language, result);
          }
          if (isCodeGenerationTextInstruction(entry) && !seenInstructions.has(entry.text)) {
            seenInstructions.add(entry.text);
            instructions.push({ instruction: entry.text, languageId: entry.language });
          }
        }
      }
    }
  }
  async _collectInstructionsFromFile(customInstructionsFile, language2, result) {
    this.logService.debug(`Collect instructions from file: ${customInstructionsFile}`);
    const promises = this.workspaceService.getWorkspaceFolders().map(async (folderUri) => {
      const fileUri = Uri3.joinPath(folderUri, customInstructionsFile);
      const instruction = await this.readInstructionsFromFile(fileUri);
      if (instruction) {
        result.push(instruction);
      }
    });
    await Promise.all(promises);
  }
  async readInstructionsFromFile(fileUri, languageId) {
    try {
      const fileContents = await this.fileSystemService.readFile(fileUri);
      const content = new TextDecoder().decode(fileContents);
      const instruction = content.trim();
      if (!instruction) {
        this.logService.debug(`Instructions file is empty: ${fileUri.toString()}`);
        return;
      }
      return {
        kind: 0 /* File */,
        content: [{ instruction, languageId }],
        reference: fileUri
      };
    } catch (e) {
      this.logService.debug(`Instructions file not found: ${fileUri.toString()}`);
      return void 0;
    }
  }
  isExternalInstructionsFile(uri) {
    if (!uri.path.endsWith(INSTRUCTION_FILE_EXTENSION)) {
      return false;
    }
    if (uri.scheme === Schemas.vscodeUserData) {
      return true;
    }
    if (this.getInstructionURLFromExtensionPoint().has(uri)) {
      return true;
    }
    if (uri.scheme !== Schemas.file) {
      return false;
    }
    const instructionFilePath = this.promptPathRepresentationService.getFilePath(uri);
    const instructionFolderPath = dirname(instructionFilePath);
    const locations = this.configurationService.getNonExtensionConfig(INSTRUCTIONS_LOCATION_KEY);
    if (isObject(locations)) {
      for (const key in locations) {
        const location = key.trim();
        const value = locations[key];
        if (value === true && isAbsolute(location)) {
          const pathToMatch = location.endsWith("/") || location.endsWith("*") ? instructionFolderPath : location;
          if (match(pathToMatch, location)) {
            return true;
          }
        }
      }
    }
    return true;
  }
  getInstructionURLFromExtensionPoint() {
    if (!this._contributedInstructions) {
      const result = new ResourceSet();
      for (const extension of this.extensionService.all) {
        const chatInstructions = extension.packageJSON["contributes"]?.["chatInstructions"];
        if (Array.isArray(chatInstructions)) {
          for (const contribution of chatInstructions) {
            if (contribution.path) {
              const fileUri = joinPath(extension.extensionUri, contribution.path);
              result.add(fileUri);
            }
          }
        }
      }
      this._contributedInstructions = result;
    }
    return this._contributedInstructions;
  }
};
CustomInstructionsService = __decorateClass([
  __decorateParam(0, IConfigurationService),
  __decorateParam(1, IEnvService),
  __decorateParam(2, IWorkspaceService),
  __decorateParam(3, IFileSystemService),
  __decorateParam(4, IPromptPathRepresentationService),
  __decorateParam(5, ILogService),
  __decorateParam(6, IExtensionsService)
], CustomInstructionsService);

// src/platform/debug/common/debugOutputService.ts
var IDebugOutputService = createDecorator("IDebugOutputService");

// src/platform/debug/vscode/debugOutputServiceImpl.ts
init_lifecycle();

// src/platform/debug/vscode/debugOutputListener.ts
var import_vscode5 = require("vscode");
var debugOutput = [];
function getMostRecentDebugOutput() {
  return debugOutput.join("\n");
}
function appendLimitedWindow(target, data) {
  target.push(removeAnsiEscapeCodes2(data));
  if (target.length > 40) {
    target.shift();
  }
}
var DebugSessionTracker = class {
  constructor(session) {
    this.session = session;
  }
  onWillStartSession() {
  }
  onWillReceiveMessage(message) {
  }
  onDidSendMessage(message) {
    if (import_vscode5.debug.activeDebugSession !== this.session) {
      return;
    }
    const output = this.extractOutput(message);
    if (output) {
      appendLimitedWindow(debugOutput, output);
    }
  }
  extractOutput(message) {
    if (message.event === "output" && (message.body.category === "stdout" || message.body.category === "stderr")) {
      return message.body.output;
    }
    return void 0;
  }
  onWillStopSession() {
  }
  onError(error2) {
  }
  onExit(code2, signal) {
  }
};
function removeAnsiEscapeCodes2(str) {
  const CSI_SEQUENCE2 = /(:?\x1b\[|\x9B)[=?>!]?[\d;:]*["$#'* ]?[a-zA-Z@^`{}|~]/g;
  if (str) {
    str = str.replace(CSI_SEQUENCE2, "");
  }
  return str;
}
function installDebugOutputListeners() {
  const debugAdapter = import_vscode5.debug.registerDebugAdapterTrackerFactory("*", new DebugSessionLoggingFactory());
  return [debugAdapter];
}
var DebugSessionLoggingFactory = class {
  createDebugAdapterTracker(session) {
    return new DebugSessionTracker(session);
  }
};

// src/platform/debug/vscode/debugOutputServiceImpl.ts
var DebugOutputServiceImpl = class extends Disposable {
  constructor() {
    super();
    for (const l of installDebugOutputListeners()) {
      this._register(l);
    }
  }
  get consoleOutput() {
    return getMostRecentDebugOutput();
  }
};

// src/platform/dialog/common/dialogService.ts
var IDialogService = createDecorator("IDialogService");

// src/platform/dialog/vscode/dialogServiceImpl.ts
var vscode5 = __toESM(require("vscode"));
var DialogServiceImpl = class {
  showQuickPick(items, options, token) {
    return vscode5.window.showQuickPick(items, options, token);
  }
  showOpenDialog(options) {
    return vscode5.window.showOpenDialog(options).then((result) => result);
  }
};

// src/platform/editSurvivalTracking/common/editCollector.ts
init_charCode();
init_offsetRange();

// src/platform/diff/common/diffService.ts
var IDiffService = createDecorator("IDiffService");

// src/platform/editing/common/edit.ts
init_offsetRange();

// src/platform/editing/common/offsetLineColumnConverter.ts
init_charCode();
init_position();
var OffsetLineColumnConverter = class {
  /** 1-based number of lines in the source text. */
  get lines() {
    return this._lineStartOffsets.length;
  }
  constructor(text2) {
    this._lineStartOffsets = [0];
    let index = 0;
    while (index < text2.length) {
      const ch = text2.charCodeAt(index);
      index++;
      if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
        if (ch === 13 /* CarriageReturn */ && index < text2.length && text2.charCodeAt(index) === 10 /* LineFeed */) {
          index++;
        }
        this._lineStartOffsets.push(index);
      }
    }
  }
  lineOffset(lineNumber) {
    return this._lineStartOffsets[lineNumber - 1];
  }
  offsetToPosition(offset) {
    let lineNumber = 1;
    for (; lineNumber < this._lineStartOffsets.length; lineNumber++) {
      if (this._lineStartOffsets[lineNumber] > offset) {
        break;
      }
    }
    const column = offset - this._lineStartOffsets[lineNumber - 1];
    return new Position(lineNumber, column + 1);
  }
  startOffsetOfLineContaining(offset) {
    let lineNumber = 1;
    for (; lineNumber < this._lineStartOffsets.length; lineNumber++) {
      if (this._lineStartOffsets[lineNumber] > offset) {
        break;
      }
    }
    return this._lineStartOffsets[lineNumber - 1];
  }
  positionToOffset(position) {
    if (position.lineNumber >= this._lineStartOffsets.length) {
      return this._lineStartOffsets[this._lineStartOffsets.length - 1] + position.column - 1;
    }
    return this._lineStartOffsets[position.lineNumber - 1] + position.column - 1;
  }
};

// src/platform/editing/common/edit.ts
async function stringEditFromDiff(original, modified, diffService, timeoutMs = 5e3) {
  const diff2 = await diffService.computeDiff(original, modified, { maxComputationTimeMs: timeoutMs, computeMoves: false, ignoreTrimWhitespace: false });
  const origConverter = new OffsetLineColumnConverter(original);
  const modConverter = new OffsetLineColumnConverter(modified);
  const edits = [];
  for (const c of diff2.changes) {
    for (const i of c.innerChanges ?? []) {
      const startMod = modConverter.positionToOffset(i.modifiedRange.getStartPosition());
      const endExMod = modConverter.positionToOffset(i.modifiedRange.getEndPosition());
      const newText = modified.substring(startMod, endExMod);
      const startOrig = origConverter.positionToOffset(i.originalRange.getStartPosition());
      const endExOrig = origConverter.positionToOffset(i.originalRange.getEndPosition());
      const origRange = new OffsetRange(startOrig, endExOrig);
      edits.push(new StringReplacement(origRange, newText));
    }
  }
  return new StringEdit(edits);
}
function stringEditFromTextContentChange(contentChanges) {
  const editsArr = contentChanges.map((c) => new StringReplacement(OffsetRange.ofStartAndLength(c.rangeOffset, c.rangeLength), c.text));
  editsArr.reverse();
  const edits = new StringEdit(editsArr);
  return edits;
}

// src/platform/editSurvivalTracking/common/editCollector.ts
var EditCollector = class {
  constructor(initialText, _diffService) {
    this.initialText = initialText;
    this._diffService = _diffService;
    this._document = new OffsetBasedTextDocument(initialText);
  }
  addEdits(edits) {
    this._document.applyTextEdits(edits);
  }
  getText() {
    return this._document.getValue();
  }
  async getEdits() {
    const newText = this.getText();
    const edits = await stringEditFromDiff(this.initialText, newText, this._diffService);
    return edits;
  }
};
EditCollector = __decorateClass([
  __decorateParam(1, IDiffService)
], EditCollector);
var OffsetBasedTextDocument = class {
  constructor(initialValue = "") {
    this._converter = void 0;
    this._value = "";
    this._value = initialValue;
  }
  getValue() {
    return this._value;
  }
  applyTextEdits(edits) {
    const offsetEdit = new StringEdit(edits.map((e) => {
      const start = this.positionToOffset(e.range.start);
      const end = this.positionToOffset(e.range.end);
      return new StringReplacement(new OffsetRange(start, end), e.newText);
    }));
    this.applyOffsetEdit(offsetEdit);
  }
  applyOffsetEdit(edit) {
    this._value = edit.apply(this._value);
    this._converter = void 0;
  }
  positionToOffset(position) {
    if (!this._converter) {
      this._converter = new OffsetLineColumnConverter(this._value);
    }
    const line = position.line;
    if (line < 0) {
      return 0;
    } else if (line >= this._converter.lines) {
      return this._value.length;
    }
    const character = position.character;
    const lineOffet = this._converter.lineOffset(line + 1);
    if (character <= 0) {
      return lineOffet;
    }
    let endLineOffest;
    if (line + 1 < this._converter.lines) {
      endLineOffest = this._converter.lineOffset(line + 2);
      if (endLineOffest > lineOffet) {
        const ch = this._value.charCodeAt(endLineOffest - 1);
        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
          endLineOffest--;
        }
        if (ch === 10 /* LineFeed */ && endLineOffest > lineOffet && this._value.charCodeAt(endLineOffest - 1) === 13 /* CarriageReturn */) {
          endLineOffest--;
        }
      } else {
        endLineOffest = lineOffet;
      }
    } else {
      endLineOffest = this._value.length;
    }
    if (character > endLineOffest - lineOffet) {
      return endLineOffest;
    }
    return lineOffet + character;
  }
};

// src/platform/editSurvivalTracking/common/editComputer.ts
init_errors();
init_lifecycle();
var EditComputer = class extends Disposable {
  constructor(_baseText, _document, _workspaceService, _diffService) {
    super();
    this._baseText = _baseText;
    this._document = _document;
    this._workspaceService = _workspaceService;
    this._diffService = _diffService;
    this._baseDocumentText = this._document.getText();
    /**
     * ```
     * _baseText
     * ----diffEdits---->
     * _baseDocumentText
     * ----_editsOnTop---->
     * _document.getText()
     * ```
    */
    this._editsOnTop = StringEdit.empty;
    this._register(this._workspaceService.onDidChangeTextDocument((e) => {
      if (e.document.uri.toString() !== this._document.uri.toString()) {
        return;
      }
      const edits = stringEditFromTextContentChange(e.contentChanges);
      this._editsOnTop = this._editsOnTop.compose(edits);
    }));
  }
  async compute() {
    const diffEdits = await stringEditFromDiff(this._baseText, this._baseDocumentText, this._diffService);
    return {
      document: this._document,
      baseText: this._baseText,
      getEditsSinceInitial: () => {
        if (this._store.isDisposed) {
          throw new BugIndicatingError("EditComputer has been disposed");
        }
        return diffEdits.compose(this._editsOnTop);
      }
    };
  }
};
EditComputer = __decorateClass([
  __decorateParam(2, IWorkspaceService),
  __decorateParam(3, IDiffService)
], EditComputer);
var DocumentEditRecorder = class extends Disposable {
  constructor(textDocument, _workspaceService) {
    super();
    this.textDocument = textDocument;
    this._workspaceService = _workspaceService;
    this._edits = StringEdit.empty;
    this.initialTextVersion = this.textDocument.version;
    this._register(this._workspaceService.onDidChangeTextDocument((e) => {
      if (e.document.uri.toString() === this.textDocument.uri.toString()) {
        const edits = stringEditFromTextContentChange(e.contentChanges);
        this._edits = this._edits.compose(edits);
      }
    }));
  }
  /**
   * ```
   * this.initialTextVersion
   * ----this.getEdits()---->
   * this.textDocument.version
   * ```
  */
  getEdits() {
    if (this._store.isDisposed) {
      throw new BugIndicatingError("DocumentEditRecorder has been disposed");
    }
    return this._edits;
  }
};
DocumentEditRecorder = __decorateClass([
  __decorateParam(1, IWorkspaceService)
], DocumentEditRecorder);

// src/platform/editSurvivalTracking/common/editSurvivalReporter.ts
init_lifecycle();

// src/platform/inlineEdits/common/workspaceEditTracker/nesHistoryContextProvider.ts
init_lifecycle();
init_types();

// src/platform/inlineEdits/common/dataTypes/edit.ts
init_assert();

// src/platform/inlineEdits/common/dataTypes/editUtils.ts
init_errors();
init_offsetRange();
function serializeStringEdit(edit) {
  return edit.replacements.map((e) => serializeSingleEdit(e));
}
function serializeSingleEdit(edit) {
  return [edit.replaceRange.start, edit.replaceRange.endExclusive, edit.newText];
}
function deserializeStringEdit(serialized) {
  return new StringEdit(serialized.map((e) => deserializeSingleEdit(e)));
}
function deserializeSingleEdit(serialized) {
  return new StringReplacement(
    new OffsetRange(serialized[0], serialized[1]),
    serialized[2]
  );
}

// src/util/vs/editor/common/core/text/positionToOffset.ts
init_textLength();
_setPositionOffsetTransformerDependencies({
  StringEdit,
  StringReplacement,
  TextReplacement,
  TextEdit,
  TextLength
});
function ensureDependenciesAreSet() {
}

// src/platform/inlineEdits/common/dataTypes/rootedLineEdit.ts
ensureDependenciesAreSet();
var RootedLineEdit = class _RootedLineEdit {
  constructor(base2, edit) {
    this.base = base2;
    this.edit = edit;
  }
  static fromEdit(edit) {
    const lineEdit = LineEdit.fromStringEdit(edit.edit, edit.base);
    return new _RootedLineEdit(edit.base, lineEdit);
  }
  toString() {
    return this.edit.humanReadablePatch(this.base.getLines());
  }
  toEdit() {
    return this.edit.toEdit(this.base);
  }
  toRootedEdit() {
    return new RootedEdit(this.base, this.toEdit());
  }
  getEditedState() {
    const lines = this.base.getLines();
    const newLines = this.edit.apply(lines);
    return newLines;
  }
  removeCommonSuffixPrefixLines() {
    const isNotEmptyEdit = (edit) => !edit.lineRange.isEmpty || edit.newLines.length > 0;
    const newEdit = this.edit.replacements.map((e) => e.removeCommonSuffixPrefixLines(this.base)).filter((e) => isNotEmptyEdit(e));
    return new _RootedLineEdit(this.base, new LineEdit(newEdit));
  }
};

// src/platform/inlineEdits/common/dataTypes/edit.ts
var RootedEdit = class _RootedEdit {
  constructor(base2, edit) {
    this.base = base2;
    this.edit = edit;
  }
  static toLineEdit(edit) {
    return LineEdit.fromStringEdit(edit.edit, edit.base);
  }
  getEditedState() {
    return this.edit.applyOnText(this.base);
  }
  /**
   * Creates a rooted edit `r`, such that
   * * `r.initialState.equals(this.initialState.apply(onto))`
   * * `(r.initialState.apply(r.edit)).equals(this.initialState.apply(onto).apply(this.edit))`
  */
  rebase(onto) {
    const result = null;
    assertFn(() => result.base.equals(onto.applyOnText(this.base)));
    assertFn(() => result.edit.applyOnText(result.base).equals(this.edit.applyOnText(onto.applyOnText(this.base))));
    return result;
  }
  toString() {
    const e = RootedLineEdit.fromEdit(this);
    return e.toString();
  }
  /**
   * If `r.base.equals(this.base)` and `r.getEditedState().equals(this.getEditedState())`, then `r.normalize().equals(this.normalize())`.
  */
  normalize() {
    return new _RootedEdit(this.base, this.edit.normalizeOnSource(this.base.value));
  }
  equals(other) {
    return this.base.equals(other.base) && this.edit.equals(other.edit);
  }
};
var Edits = class _Edits {
  constructor(_editType, edits) {
    this._editType = _editType;
    this.edits = edits;
  }
  static single(edit) {
    return new _Edits(StringEdit, [edit]);
  }
  compose() {
    let edit = new this._editType([]);
    for (const e of this.edits) {
      edit = edit.compose(e);
    }
    return edit;
  }
  add(edit) {
    return new _Edits(this._editType, [...this.edits, edit]);
  }
  apply(value) {
    return this.compose().apply(value);
  }
  isEmpty() {
    return this.edits.length === 0;
  }
  swap(editFirst) {
    let eM = editFirst;
    const newEdits = [];
    for (const e of this.edits) {
      const e_ = BaseStringEdit.trySwap(eM, e);
      if (!e_) {
        return void 0;
      }
      newEdits.push(e_.e1);
      eM = e_.e2;
    }
    return { edits: new _Edits(StringEdit, newEdits), editLast: eM };
  }
  /*mapData<T2 extends IEditData<T2> | void = void>(f: (data: T) => T2): Edits<T2> {
  	return new Edits(this.edits.map(e => e.mapData(f)));
  }*/
  serialize() {
    return this.edits.map((e) => serializeStringEdit(e));
  }
  static deserialize(v) {
    return new _Edits(StringEdit, v.map((e) => deserializeStringEdit(e)));
  }
  toHumanReadablePatch(base2) {
    let curBase = base2;
    const result = [];
    for (const edit of this.edits) {
      const lineEdit = RootedEdit.toLineEdit(new RootedEdit(curBase, edit));
      result.push(lineEdit.humanReadablePatch(curBase.getLines()));
      curBase = edit.applyOnText(curBase);
    }
    return result.join("\n---\n");
  }
};

// src/platform/inlineEdits/common/dataTypes/textEditLength.ts
init_range();
init_textLength();

// src/platform/inlineEdits/common/dataTypes/textEditLengthHelper/combineTextEditInfos.ts
var import_arrays9 = __toESM(require_arrays());
var import_length = __toESM(require_length());
var import_textEditInfo = __toESM(require_textEditInfo());
function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {
  if (textEditInfoFirst.length === 0) {
    return textEditInfoSecond;
  }
  if (textEditInfoSecond.length === 0) {
    return textEditInfoFirst;
  }
  const s0ToS1Map = new import_arrays9.ArrayQueue(toLengthMapping(textEditInfoFirst));
  const s1ToS2Map = toLengthMapping(textEditInfoSecond);
  s1ToS2Map.push({ modified: false, lengthBefore: void 0, lengthAfter: void 0 });
  let curItem = s0ToS1Map.dequeue();
  function nextS0ToS1MapWithS1LengthOf(s1Length) {
    if (s1Length === void 0) {
      const arr = s0ToS1Map.takeWhile((v) => true) || [];
      if (curItem) {
        arr.unshift(curItem);
      }
      return arr;
    }
    const result2 = [];
    while (curItem && !(0, import_length.lengthIsZero)(s1Length)) {
      const [item, remainingItem] = curItem.splitAt(s1Length);
      result2.push(item);
      s1Length = (0, import_length.lengthDiffNonNegative)(item.lengthAfter, s1Length);
      curItem = remainingItem ?? s0ToS1Map.dequeue();
    }
    if (!(0, import_length.lengthIsZero)(s1Length)) {
      result2.push(new LengthMapping(false, s1Length, s1Length));
    }
    return result2;
  }
  const result = [];
  function pushEdit(startOffset, endOffset, newLength) {
    if (result.length > 0 && (0, import_length.lengthEquals)(result[result.length - 1].endOffset, startOffset)) {
      const lastResult = result[result.length - 1];
      result[result.length - 1] = new import_textEditInfo.TextEditInfo(lastResult.startOffset, endOffset, (0, import_length.lengthAdd)(lastResult.newLength, newLength));
    } else {
      result.push({ startOffset, endOffset, newLength });
    }
  }
  let s0offset = import_length.lengthZero;
  for (const s1ToS2 of s1ToS2Map) {
    const s0ToS1Map2 = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);
    if (s1ToS2.modified) {
      const s0Length = (0, import_length.sumLengths)(s0ToS1Map2, (s) => s.lengthBefore);
      const s0EndOffset = (0, import_length.lengthAdd)(s0offset, s0Length);
      pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);
      s0offset = s0EndOffset;
    } else {
      for (const s1 of s0ToS1Map2) {
        const s0startOffset = s0offset;
        s0offset = (0, import_length.lengthAdd)(s0offset, s1.lengthBefore);
        if (s1.modified) {
          pushEdit(s0startOffset, s0offset, s1.lengthAfter);
        }
      }
    }
  }
  return result;
}
var LengthMapping = class _LengthMapping {
  constructor(modified, lengthBefore, lengthAfter) {
    this.modified = modified;
    this.lengthBefore = lengthBefore;
    this.lengthAfter = lengthAfter;
  }
  splitAt(lengthAfter) {
    const remainingLengthAfter = (0, import_length.lengthDiffNonNegative)(lengthAfter, this.lengthAfter);
    if ((0, import_length.lengthEquals)(remainingLengthAfter, import_length.lengthZero)) {
      return [this, void 0];
    } else if (this.modified) {
      return [
        new _LengthMapping(this.modified, this.lengthBefore, lengthAfter),
        new _LengthMapping(this.modified, import_length.lengthZero, remainingLengthAfter)
      ];
    } else {
      return [
        new _LengthMapping(this.modified, lengthAfter, lengthAfter),
        new _LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)
      ];
    }
  }
  toString() {
    return `${this.modified ? "M" : "U"}:${(0, import_length.lengthToObj)(this.lengthBefore)} -> ${(0, import_length.lengthToObj)(this.lengthAfter)}`;
  }
};
function toLengthMapping(textEditInfos) {
  const result = [];
  let lastOffset = import_length.lengthZero;
  for (const textEditInfo of textEditInfos) {
    const spaceLength = (0, import_length.lengthDiffNonNegative)(lastOffset, textEditInfo.startOffset);
    if (!(0, import_length.lengthIsZero)(spaceLength)) {
      result.push(new LengthMapping(false, spaceLength, spaceLength));
    }
    const lengthBefore = (0, import_length.lengthDiffNonNegative)(textEditInfo.startOffset, textEditInfo.endOffset);
    result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));
    lastOffset = textEditInfo.endOffset;
  }
  return result;
}

// src/platform/inlineEdits/common/dataTypes/textEditLength.ts
init_length();

// src/platform/inlineEdits/common/dataTypes/textEditLengthHelper/textEditInfo.ts
init_length();
var TextEditInfo2 = class {
  /*public static fromModelContentChanges(changes: IModelContentChange[]): TextEditInfo[] {
  	// Must be sorted in ascending order
  	const edits = changes.map(c => {
  		const range = Range.lift(c.range);
  		return new TextEditInfo(
  			positionToLength(range.getStartPosition()),
  			positionToLength(range.getEndPosition()),
  			lengthOfString(c.text)
  		);
  	}).reverse();
  	return edits;
  }*/
  constructor(startOffset, endOffset, newLength) {
    this.startOffset = startOffset;
    this.endOffset = endOffset;
    this.newLength = newLength;
  }
  toString() {
    return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;
  }
};

// src/platform/inlineEdits/common/dataTypes/textEditLength.ts
var TextLengthEdit = class _TextLengthEdit {
  constructor(edits) {
    this.edits = edits;
  }
  static {
    this.empty = new _TextLengthEdit([]);
  }
  static fromTextEdit(textEdit) {
    const edits = textEdit.replacements.map((e) => new SingleTextEditLength(e.range, TextLength.ofText(e.text)));
    return new _TextLengthEdit(edits);
  }
  static _fromTextEditInfo(info) {
    const edits = info.map((e) => {
      const newLen = lengthToObj(e.newLength);
      return new SingleTextEditLength(
        lengthsToRange(e.startOffset, e.endOffset),
        new TextLength(newLen.lineCount, newLen.columnCount)
      );
    });
    return new _TextLengthEdit(edits);
  }
  _toTextEditInfo() {
    return this.edits.map((e) => new TextEditInfo2(
      toLength(e.range.startLineNumber - 1, e.range.startColumn - 1),
      toLength(e.range.endLineNumber - 1, e.range.endColumn - 1),
      toLength(e.newLength.lineCount, e.newLength.columnCount)
    ));
  }
  compose(other) {
    const self = this._toTextEditInfo();
    const o = other._toTextEditInfo();
    const result = combineTextEditInfos(self, o);
    return _TextLengthEdit._fromTextEditInfo(result);
  }
  /**
   * Returns the range of the edit, or undefined if the edit is empty.
   */
  getRange() {
    if (this.edits.length === 0) {
      return void 0;
    }
    return Range.fromPositions(this.edits[0].range.getStartPosition(), this.edits.at(-1).range.getEndPosition());
  }
  toString() {
    return `[${this.edits.join(", ")}]`;
  }
};
var SingleTextEditLength = class {
  constructor(range, newLength) {
    this.range = range;
    this.newLength = newLength;
  }
  toString() {
    return `{ range: ${this.range}, newLength: ${this.newLength} }`;
  }
};

// src/util/vs/base/common/codiconsUtil.ts
init_types();
var _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
function register(id2, fontCharacter) {
  if (isString(fontCharacter)) {
    const val = _codiconFontCharacters[fontCharacter];
    if (val === void 0) {
      throw new Error(`${id2} references an unknown codicon: ${fontCharacter}`);
    }
    fontCharacter = val;
  }
  _codiconFontCharacters[id2] = fontCharacter;
  return { id: id2 };
}

// src/util/vs/base/common/codiconsLibrary.ts
var codiconsLibrary = {
  add: register("add", 6e4),
  plus: register("plus", 6e4),
  gistNew: register("gist-new", 6e4),
  repoCreate: register("repo-create", 6e4),
  lightbulb: register("lightbulb", 60001),
  lightBulb: register("light-bulb", 60001),
  repo: register("repo", 60002),
  repoDelete: register("repo-delete", 60002),
  gistFork: register("gist-fork", 60003),
  repoForked: register("repo-forked", 60003),
  gitPullRequest: register("git-pull-request", 60004),
  gitPullRequestAbandoned: register("git-pull-request-abandoned", 60004),
  recordKeys: register("record-keys", 60005),
  keyboard: register("keyboard", 60005),
  tag: register("tag", 60006),
  gitPullRequestLabel: register("git-pull-request-label", 60006),
  tagAdd: register("tag-add", 60006),
  tagRemove: register("tag-remove", 60006),
  person: register("person", 60007),
  personFollow: register("person-follow", 60007),
  personOutline: register("person-outline", 60007),
  personFilled: register("person-filled", 60007),
  gitBranch: register("git-branch", 60008),
  gitBranchCreate: register("git-branch-create", 60008),
  gitBranchDelete: register("git-branch-delete", 60008),
  sourceControl: register("source-control", 60008),
  mirror: register("mirror", 60009),
  mirrorPublic: register("mirror-public", 60009),
  star: register("star", 60010),
  starAdd: register("star-add", 60010),
  starDelete: register("star-delete", 60010),
  starEmpty: register("star-empty", 60010),
  comment: register("comment", 60011),
  commentAdd: register("comment-add", 60011),
  alert: register("alert", 60012),
  warning: register("warning", 60012),
  search: register("search", 60013),
  searchSave: register("search-save", 60013),
  logOut: register("log-out", 60014),
  signOut: register("sign-out", 60014),
  logIn: register("log-in", 60015),
  signIn: register("sign-in", 60015),
  eye: register("eye", 60016),
  eyeUnwatch: register("eye-unwatch", 60016),
  eyeWatch: register("eye-watch", 60016),
  circleFilled: register("circle-filled", 60017),
  primitiveDot: register("primitive-dot", 60017),
  closeDirty: register("close-dirty", 60017),
  debugBreakpoint: register("debug-breakpoint", 60017),
  debugBreakpointDisabled: register("debug-breakpoint-disabled", 60017),
  debugHint: register("debug-hint", 60017),
  terminalDecorationSuccess: register("terminal-decoration-success", 60017),
  primitiveSquare: register("primitive-square", 60018),
  edit: register("edit", 60019),
  pencil: register("pencil", 60019),
  info: register("info", 60020),
  issueOpened: register("issue-opened", 60020),
  gistPrivate: register("gist-private", 60021),
  gitForkPrivate: register("git-fork-private", 60021),
  lock: register("lock", 60021),
  mirrorPrivate: register("mirror-private", 60021),
  close: register("close", 60022),
  removeClose: register("remove-close", 60022),
  x: register("x", 60022),
  repoSync: register("repo-sync", 60023),
  sync: register("sync", 60023),
  clone: register("clone", 60024),
  desktopDownload: register("desktop-download", 60024),
  beaker: register("beaker", 60025),
  microscope: register("microscope", 60025),
  vm: register("vm", 60026),
  deviceDesktop: register("device-desktop", 60026),
  file: register("file", 60027),
  more: register("more", 60028),
  ellipsis: register("ellipsis", 60028),
  kebabHorizontal: register("kebab-horizontal", 60028),
  mailReply: register("mail-reply", 60029),
  reply: register("reply", 60029),
  organization: register("organization", 60030),
  organizationFilled: register("organization-filled", 60030),
  organizationOutline: register("organization-outline", 60030),
  newFile: register("new-file", 60031),
  fileAdd: register("file-add", 60031),
  newFolder: register("new-folder", 60032),
  fileDirectoryCreate: register("file-directory-create", 60032),
  trash: register("trash", 60033),
  trashcan: register("trashcan", 60033),
  history: register("history", 60034),
  clock: register("clock", 60034),
  folder: register("folder", 60035),
  fileDirectory: register("file-directory", 60035),
  symbolFolder: register("symbol-folder", 60035),
  logoGithub: register("logo-github", 60036),
  markGithub: register("mark-github", 60036),
  github: register("github", 60036),
  terminal: register("terminal", 60037),
  console: register("console", 60037),
  repl: register("repl", 60037),
  zap: register("zap", 60038),
  symbolEvent: register("symbol-event", 60038),
  error: register("error", 60039),
  stop: register("stop", 60039),
  variable: register("variable", 60040),
  symbolVariable: register("symbol-variable", 60040),
  array: register("array", 60042),
  symbolArray: register("symbol-array", 60042),
  symbolModule: register("symbol-module", 60043),
  symbolPackage: register("symbol-package", 60043),
  symbolNamespace: register("symbol-namespace", 60043),
  symbolObject: register("symbol-object", 60043),
  symbolMethod: register("symbol-method", 60044),
  symbolFunction: register("symbol-function", 60044),
  symbolConstructor: register("symbol-constructor", 60044),
  symbolBoolean: register("symbol-boolean", 60047),
  symbolNull: register("symbol-null", 60047),
  symbolNumeric: register("symbol-numeric", 60048),
  symbolNumber: register("symbol-number", 60048),
  symbolStructure: register("symbol-structure", 60049),
  symbolStruct: register("symbol-struct", 60049),
  symbolParameter: register("symbol-parameter", 60050),
  symbolTypeParameter: register("symbol-type-parameter", 60050),
  symbolKey: register("symbol-key", 60051),
  symbolText: register("symbol-text", 60051),
  symbolReference: register("symbol-reference", 60052),
  goToFile: register("go-to-file", 60052),
  symbolEnum: register("symbol-enum", 60053),
  symbolValue: register("symbol-value", 60053),
  symbolRuler: register("symbol-ruler", 60054),
  symbolUnit: register("symbol-unit", 60054),
  activateBreakpoints: register("activate-breakpoints", 60055),
  archive: register("archive", 60056),
  arrowBoth: register("arrow-both", 60057),
  arrowDown: register("arrow-down", 60058),
  arrowLeft: register("arrow-left", 60059),
  arrowRight: register("arrow-right", 60060),
  arrowSmallDown: register("arrow-small-down", 60061),
  arrowSmallLeft: register("arrow-small-left", 60062),
  arrowSmallRight: register("arrow-small-right", 60063),
  arrowSmallUp: register("arrow-small-up", 60064),
  arrowUp: register("arrow-up", 60065),
  bell: register("bell", 60066),
  bold: register("bold", 60067),
  book: register("book", 60068),
  bookmark: register("bookmark", 60069),
  debugBreakpointConditionalUnverified: register("debug-breakpoint-conditional-unverified", 60070),
  debugBreakpointConditional: register("debug-breakpoint-conditional", 60071),
  debugBreakpointConditionalDisabled: register("debug-breakpoint-conditional-disabled", 60071),
  debugBreakpointDataUnverified: register("debug-breakpoint-data-unverified", 60072),
  debugBreakpointData: register("debug-breakpoint-data", 60073),
  debugBreakpointDataDisabled: register("debug-breakpoint-data-disabled", 60073),
  debugBreakpointLogUnverified: register("debug-breakpoint-log-unverified", 60074),
  debugBreakpointLog: register("debug-breakpoint-log", 60075),
  debugBreakpointLogDisabled: register("debug-breakpoint-log-disabled", 60075),
  briefcase: register("briefcase", 60076),
  broadcast: register("broadcast", 60077),
  browser: register("browser", 60078),
  bug: register("bug", 60079),
  calendar: register("calendar", 60080),
  caseSensitive: register("case-sensitive", 60081),
  check: register("check", 60082),
  checklist: register("checklist", 60083),
  chevronDown: register("chevron-down", 60084),
  chevronLeft: register("chevron-left", 60085),
  chevronRight: register("chevron-right", 60086),
  chevronUp: register("chevron-up", 60087),
  chromeClose: register("chrome-close", 60088),
  chromeMaximize: register("chrome-maximize", 60089),
  chromeMinimize: register("chrome-minimize", 60090),
  chromeRestore: register("chrome-restore", 60091),
  circleOutline: register("circle-outline", 60092),
  circle: register("circle", 60092),
  debugBreakpointUnverified: register("debug-breakpoint-unverified", 60092),
  terminalDecorationIncomplete: register("terminal-decoration-incomplete", 60092),
  circleSlash: register("circle-slash", 60093),
  circuitBoard: register("circuit-board", 60094),
  clearAll: register("clear-all", 60095),
  clippy: register("clippy", 60096),
  closeAll: register("close-all", 60097),
  cloudDownload: register("cloud-download", 60098),
  cloudUpload: register("cloud-upload", 60099),
  code: register("code", 60100),
  collapseAll: register("collapse-all", 60101),
  colorMode: register("color-mode", 60102),
  commentDiscussion: register("comment-discussion", 60103),
  creditCard: register("credit-card", 60105),
  dash: register("dash", 60108),
  dashboard: register("dashboard", 60109),
  database: register("database", 60110),
  debugContinue: register("debug-continue", 60111),
  debugDisconnect: register("debug-disconnect", 60112),
  debugPause: register("debug-pause", 60113),
  debugRestart: register("debug-restart", 60114),
  debugStart: register("debug-start", 60115),
  debugStepInto: register("debug-step-into", 60116),
  debugStepOut: register("debug-step-out", 60117),
  debugStepOver: register("debug-step-over", 60118),
  debugStop: register("debug-stop", 60119),
  debug: register("debug", 60120),
  deviceCameraVideo: register("device-camera-video", 60121),
  deviceCamera: register("device-camera", 60122),
  deviceMobile: register("device-mobile", 60123),
  diffAdded: register("diff-added", 60124),
  diffIgnored: register("diff-ignored", 60125),
  diffModified: register("diff-modified", 60126),
  diffRemoved: register("diff-removed", 60127),
  diffRenamed: register("diff-renamed", 60128),
  diff: register("diff", 60129),
  diffSidebyside: register("diff-sidebyside", 60129),
  discard: register("discard", 60130),
  editorLayout: register("editor-layout", 60131),
  emptyWindow: register("empty-window", 60132),
  exclude: register("exclude", 60133),
  extensions: register("extensions", 60134),
  eyeClosed: register("eye-closed", 60135),
  fileBinary: register("file-binary", 60136),
  fileCode: register("file-code", 60137),
  fileMedia: register("file-media", 60138),
  filePdf: register("file-pdf", 60139),
  fileSubmodule: register("file-submodule", 60140),
  fileSymlinkDirectory: register("file-symlink-directory", 60141),
  fileSymlinkFile: register("file-symlink-file", 60142),
  fileZip: register("file-zip", 60143),
  files: register("files", 60144),
  filter: register("filter", 60145),
  flame: register("flame", 60146),
  foldDown: register("fold-down", 60147),
  foldUp: register("fold-up", 60148),
  fold: register("fold", 60149),
  folderActive: register("folder-active", 60150),
  folderOpened: register("folder-opened", 60151),
  gear: register("gear", 60152),
  gift: register("gift", 60153),
  gistSecret: register("gist-secret", 60154),
  gist: register("gist", 60155),
  gitCommit: register("git-commit", 60156),
  gitCompare: register("git-compare", 60157),
  compareChanges: register("compare-changes", 60157),
  gitMerge: register("git-merge", 60158),
  githubAction: register("github-action", 60159),
  githubAlt: register("github-alt", 60160),
  globe: register("globe", 60161),
  grabber: register("grabber", 60162),
  graph: register("graph", 60163),
  gripper: register("gripper", 60164),
  heart: register("heart", 60165),
  home: register("home", 60166),
  horizontalRule: register("horizontal-rule", 60167),
  hubot: register("hubot", 60168),
  inbox: register("inbox", 60169),
  issueReopened: register("issue-reopened", 60171),
  issues: register("issues", 60172),
  italic: register("italic", 60173),
  jersey: register("jersey", 60174),
  json: register("json", 60175),
  kebabVertical: register("kebab-vertical", 60176),
  key: register("key", 60177),
  law: register("law", 60178),
  lightbulbAutofix: register("lightbulb-autofix", 60179),
  linkExternal: register("link-external", 60180),
  link: register("link", 60181),
  listOrdered: register("list-ordered", 60182),
  listUnordered: register("list-unordered", 60183),
  liveShare: register("live-share", 60184),
  loading: register("loading", 60185),
  location: register("location", 60186),
  mailRead: register("mail-read", 60187),
  mail: register("mail", 60188),
  markdown: register("markdown", 60189),
  megaphone: register("megaphone", 60190),
  mention: register("mention", 60191),
  milestone: register("milestone", 60192),
  gitPullRequestMilestone: register("git-pull-request-milestone", 60192),
  mortarBoard: register("mortar-board", 60193),
  move: register("move", 60194),
  multipleWindows: register("multiple-windows", 60195),
  mute: register("mute", 60196),
  noNewline: register("no-newline", 60197),
  note: register("note", 60198),
  octoface: register("octoface", 60199),
  openPreview: register("open-preview", 60200),
  package: register("package", 60201),
  paintcan: register("paintcan", 60202),
  pin: register("pin", 60203),
  play: register("play", 60204),
  run: register("run", 60204),
  plug: register("plug", 60205),
  preserveCase: register("preserve-case", 60206),
  preview: register("preview", 60207),
  project: register("project", 60208),
  pulse: register("pulse", 60209),
  question: register("question", 60210),
  quote: register("quote", 60211),
  radioTower: register("radio-tower", 60212),
  reactions: register("reactions", 60213),
  references: register("references", 60214),
  refresh: register("refresh", 60215),
  regex: register("regex", 60216),
  remoteExplorer: register("remote-explorer", 60217),
  remote: register("remote", 60218),
  remove: register("remove", 60219),
  replaceAll: register("replace-all", 60220),
  replace: register("replace", 60221),
  repoClone: register("repo-clone", 60222),
  repoForcePush: register("repo-force-push", 60223),
  repoPull: register("repo-pull", 60224),
  repoPush: register("repo-push", 60225),
  report: register("report", 60226),
  requestChanges: register("request-changes", 60227),
  rocket: register("rocket", 60228),
  rootFolderOpened: register("root-folder-opened", 60229),
  rootFolder: register("root-folder", 60230),
  rss: register("rss", 60231),
  ruby: register("ruby", 60232),
  saveAll: register("save-all", 60233),
  saveAs: register("save-as", 60234),
  save: register("save", 60235),
  screenFull: register("screen-full", 60236),
  screenNormal: register("screen-normal", 60237),
  searchStop: register("search-stop", 60238),
  server: register("server", 60240),
  settingsGear: register("settings-gear", 60241),
  settings: register("settings", 60242),
  shield: register("shield", 60243),
  smiley: register("smiley", 60244),
  sortPrecedence: register("sort-precedence", 60245),
  splitHorizontal: register("split-horizontal", 60246),
  splitVertical: register("split-vertical", 60247),
  squirrel: register("squirrel", 60248),
  starFull: register("star-full", 60249),
  starHalf: register("star-half", 60250),
  symbolClass: register("symbol-class", 60251),
  symbolColor: register("symbol-color", 60252),
  symbolConstant: register("symbol-constant", 60253),
  symbolEnumMember: register("symbol-enum-member", 60254),
  symbolField: register("symbol-field", 60255),
  symbolFile: register("symbol-file", 60256),
  symbolInterface: register("symbol-interface", 60257),
  symbolKeyword: register("symbol-keyword", 60258),
  symbolMisc: register("symbol-misc", 60259),
  symbolOperator: register("symbol-operator", 60260),
  symbolProperty: register("symbol-property", 60261),
  wrench: register("wrench", 60261),
  wrenchSubaction: register("wrench-subaction", 60261),
  symbolSnippet: register("symbol-snippet", 60262),
  tasklist: register("tasklist", 60263),
  telescope: register("telescope", 60264),
  textSize: register("text-size", 60265),
  threeBars: register("three-bars", 60266),
  thumbsdown: register("thumbsdown", 60267),
  thumbsup: register("thumbsup", 60268),
  tools: register("tools", 60269),
  triangleDown: register("triangle-down", 60270),
  triangleLeft: register("triangle-left", 60271),
  triangleRight: register("triangle-right", 60272),
  triangleUp: register("triangle-up", 60273),
  twitter: register("twitter", 60274),
  unfold: register("unfold", 60275),
  unlock: register("unlock", 60276),
  unmute: register("unmute", 60277),
  unverified: register("unverified", 60278),
  verified: register("verified", 60279),
  versions: register("versions", 60280),
  vmActive: register("vm-active", 60281),
  vmOutline: register("vm-outline", 60282),
  vmRunning: register("vm-running", 60283),
  watch: register("watch", 60284),
  whitespace: register("whitespace", 60285),
  wholeWord: register("whole-word", 60286),
  window: register("window", 60287),
  wordWrap: register("word-wrap", 60288),
  zoomIn: register("zoom-in", 60289),
  zoomOut: register("zoom-out", 60290),
  listFilter: register("list-filter", 60291),
  listFlat: register("list-flat", 60292),
  listSelection: register("list-selection", 60293),
  selection: register("selection", 60293),
  listTree: register("list-tree", 60294),
  debugBreakpointFunctionUnverified: register("debug-breakpoint-function-unverified", 60295),
  debugBreakpointFunction: register("debug-breakpoint-function", 60296),
  debugBreakpointFunctionDisabled: register("debug-breakpoint-function-disabled", 60296),
  debugStackframeActive: register("debug-stackframe-active", 60297),
  circleSmallFilled: register("circle-small-filled", 60298),
  debugStackframeDot: register("debug-stackframe-dot", 60298),
  terminalDecorationMark: register("terminal-decoration-mark", 60298),
  debugStackframe: register("debug-stackframe", 60299),
  debugStackframeFocused: register("debug-stackframe-focused", 60299),
  debugBreakpointUnsupported: register("debug-breakpoint-unsupported", 60300),
  symbolString: register("symbol-string", 60301),
  debugReverseContinue: register("debug-reverse-continue", 60302),
  debugStepBack: register("debug-step-back", 60303),
  debugRestartFrame: register("debug-restart-frame", 60304),
  debugAlt: register("debug-alt", 60305),
  callIncoming: register("call-incoming", 60306),
  callOutgoing: register("call-outgoing", 60307),
  menu: register("menu", 60308),
  expandAll: register("expand-all", 60309),
  feedback: register("feedback", 60310),
  gitPullRequestReviewer: register("git-pull-request-reviewer", 60310),
  groupByRefType: register("group-by-ref-type", 60311),
  ungroupByRefType: register("ungroup-by-ref-type", 60312),
  account: register("account", 60313),
  gitPullRequestAssignee: register("git-pull-request-assignee", 60313),
  bellDot: register("bell-dot", 60314),
  debugConsole: register("debug-console", 60315),
  library: register("library", 60316),
  output: register("output", 60317),
  runAll: register("run-all", 60318),
  syncIgnored: register("sync-ignored", 60319),
  pinned: register("pinned", 60320),
  githubInverted: register("github-inverted", 60321),
  serverProcess: register("server-process", 60322),
  serverEnvironment: register("server-environment", 60323),
  pass: register("pass", 60324),
  issueClosed: register("issue-closed", 60324),
  stopCircle: register("stop-circle", 60325),
  playCircle: register("play-circle", 60326),
  record: register("record", 60327),
  debugAltSmall: register("debug-alt-small", 60328),
  vmConnect: register("vm-connect", 60329),
  cloud: register("cloud", 60330),
  merge: register("merge", 60331),
  export: register("export", 60332),
  graphLeft: register("graph-left", 60333),
  magnet: register("magnet", 60334),
  notebook: register("notebook", 60335),
  redo: register("redo", 60336),
  checkAll: register("check-all", 60337),
  pinnedDirty: register("pinned-dirty", 60338),
  passFilled: register("pass-filled", 60339),
  circleLargeFilled: register("circle-large-filled", 60340),
  circleLarge: register("circle-large", 60341),
  circleLargeOutline: register("circle-large-outline", 60341),
  combine: register("combine", 60342),
  gather: register("gather", 60342),
  table: register("table", 60343),
  variableGroup: register("variable-group", 60344),
  typeHierarchy: register("type-hierarchy", 60345),
  typeHierarchySub: register("type-hierarchy-sub", 60346),
  typeHierarchySuper: register("type-hierarchy-super", 60347),
  gitPullRequestCreate: register("git-pull-request-create", 60348),
  runAbove: register("run-above", 60349),
  runBelow: register("run-below", 60350),
  notebookTemplate: register("notebook-template", 60351),
  debugRerun: register("debug-rerun", 60352),
  workspaceTrusted: register("workspace-trusted", 60353),
  workspaceUntrusted: register("workspace-untrusted", 60354),
  workspaceUnknown: register("workspace-unknown", 60355),
  terminalCmd: register("terminal-cmd", 60356),
  terminalDebian: register("terminal-debian", 60357),
  terminalLinux: register("terminal-linux", 60358),
  terminalPowershell: register("terminal-powershell", 60359),
  terminalTmux: register("terminal-tmux", 60360),
  terminalUbuntu: register("terminal-ubuntu", 60361),
  terminalBash: register("terminal-bash", 60362),
  arrowSwap: register("arrow-swap", 60363),
  copy: register("copy", 60364),
  personAdd: register("person-add", 60365),
  filterFilled: register("filter-filled", 60366),
  wand: register("wand", 60367),
  debugLineByLine: register("debug-line-by-line", 60368),
  inspect: register("inspect", 60369),
  layers: register("layers", 60370),
  layersDot: register("layers-dot", 60371),
  layersActive: register("layers-active", 60372),
  compass: register("compass", 60373),
  compassDot: register("compass-dot", 60374),
  compassActive: register("compass-active", 60375),
  azure: register("azure", 60376),
  issueDraft: register("issue-draft", 60377),
  gitPullRequestClosed: register("git-pull-request-closed", 60378),
  gitPullRequestDraft: register("git-pull-request-draft", 60379),
  debugAll: register("debug-all", 60380),
  debugCoverage: register("debug-coverage", 60381),
  runErrors: register("run-errors", 60382),
  folderLibrary: register("folder-library", 60383),
  debugContinueSmall: register("debug-continue-small", 60384),
  beakerStop: register("beaker-stop", 60385),
  graphLine: register("graph-line", 60386),
  graphScatter: register("graph-scatter", 60387),
  pieChart: register("pie-chart", 60388),
  bracket: register("bracket", 60175),
  bracketDot: register("bracket-dot", 60389),
  bracketError: register("bracket-error", 60390),
  lockSmall: register("lock-small", 60391),
  azureDevops: register("azure-devops", 60392),
  verifiedFilled: register("verified-filled", 60393),
  newline: register("newline", 60394),
  layout: register("layout", 60395),
  layoutActivitybarLeft: register("layout-activitybar-left", 60396),
  layoutActivitybarRight: register("layout-activitybar-right", 60397),
  layoutPanelLeft: register("layout-panel-left", 60398),
  layoutPanelCenter: register("layout-panel-center", 60399),
  layoutPanelJustify: register("layout-panel-justify", 60400),
  layoutPanelRight: register("layout-panel-right", 60401),
  layoutPanel: register("layout-panel", 60402),
  layoutSidebarLeft: register("layout-sidebar-left", 60403),
  layoutSidebarRight: register("layout-sidebar-right", 60404),
  layoutStatusbar: register("layout-statusbar", 60405),
  layoutMenubar: register("layout-menubar", 60406),
  layoutCentered: register("layout-centered", 60407),
  target: register("target", 60408),
  indent: register("indent", 60409),
  recordSmall: register("record-small", 60410),
  errorSmall: register("error-small", 60411),
  terminalDecorationError: register("terminal-decoration-error", 60411),
  arrowCircleDown: register("arrow-circle-down", 60412),
  arrowCircleLeft: register("arrow-circle-left", 60413),
  arrowCircleRight: register("arrow-circle-right", 60414),
  arrowCircleUp: register("arrow-circle-up", 60415),
  layoutSidebarRightOff: register("layout-sidebar-right-off", 60416),
  layoutPanelOff: register("layout-panel-off", 60417),
  layoutSidebarLeftOff: register("layout-sidebar-left-off", 60418),
  blank: register("blank", 60419),
  heartFilled: register("heart-filled", 60420),
  map: register("map", 60421),
  mapHorizontal: register("map-horizontal", 60421),
  foldHorizontal: register("fold-horizontal", 60421),
  mapFilled: register("map-filled", 60422),
  mapHorizontalFilled: register("map-horizontal-filled", 60422),
  foldHorizontalFilled: register("fold-horizontal-filled", 60422),
  circleSmall: register("circle-small", 60423),
  bellSlash: register("bell-slash", 60424),
  bellSlashDot: register("bell-slash-dot", 60425),
  commentUnresolved: register("comment-unresolved", 60426),
  gitPullRequestGoToChanges: register("git-pull-request-go-to-changes", 60427),
  gitPullRequestNewChanges: register("git-pull-request-new-changes", 60428),
  searchFuzzy: register("search-fuzzy", 60429),
  commentDraft: register("comment-draft", 60430),
  send: register("send", 60431),
  sparkle: register("sparkle", 60432),
  insert: register("insert", 60433),
  mic: register("mic", 60434),
  thumbsdownFilled: register("thumbsdown-filled", 60435),
  thumbsupFilled: register("thumbsup-filled", 60436),
  coffee: register("coffee", 60437),
  snake: register("snake", 60438),
  game: register("game", 60439),
  vr: register("vr", 60440),
  chip: register("chip", 60441),
  piano: register("piano", 60442),
  music: register("music", 60443),
  micFilled: register("mic-filled", 60444),
  repoFetch: register("repo-fetch", 60445),
  copilot: register("copilot", 60446),
  lightbulbSparkle: register("lightbulb-sparkle", 60447),
  robot: register("robot", 60448),
  sparkleFilled: register("sparkle-filled", 60449),
  diffSingle: register("diff-single", 60450),
  diffMultiple: register("diff-multiple", 60451),
  surroundWith: register("surround-with", 60452),
  share: register("share", 60453),
  gitStash: register("git-stash", 60454),
  gitStashApply: register("git-stash-apply", 60455),
  gitStashPop: register("git-stash-pop", 60456),
  vscode: register("vscode", 60457),
  vscodeInsiders: register("vscode-insiders", 60458),
  codeOss: register("code-oss", 60459),
  runCoverage: register("run-coverage", 60460),
  runAllCoverage: register("run-all-coverage", 60461),
  coverage: register("coverage", 60462),
  githubProject: register("github-project", 60463),
  mapVertical: register("map-vertical", 60464),
  foldVertical: register("fold-vertical", 60464),
  mapVerticalFilled: register("map-vertical-filled", 60465),
  foldVerticalFilled: register("fold-vertical-filled", 60465),
  goToSearch: register("go-to-search", 60466),
  percentage: register("percentage", 60467),
  sortPercentage: register("sort-percentage", 60467),
  attach: register("attach", 60468),
  goToEditingSession: register("go-to-editing-session", 60469),
  editSession: register("edit-session", 60470),
  codeReview: register("code-review", 60471),
  copilotWarning: register("copilot-warning", 60472),
  python: register("python", 60473),
  copilotLarge: register("copilot-large", 60474),
  copilotWarningLarge: register("copilot-warning-large", 60475),
  keyboardTab: register("keyboard-tab", 60476),
  copilotBlocked: register("copilot-blocked", 60477),
  copilotNotConnected: register("copilot-not-connected", 60478),
  flag: register("flag", 60479),
  lightbulbEmpty: register("lightbulb-empty", 60480),
  symbolMethodArrow: register("symbol-method-arrow", 60481),
  copilotUnavailable: register("copilot-unavailable", 60482),
  repoPinned: register("repo-pinned", 60483),
  keyboardTabAbove: register("keyboard-tab-above", 60484),
  keyboardTabBelow: register("keyboard-tab-below", 60485),
  gitPullRequestDone: register("git-pull-request-done", 60486),
  mcp: register("mcp", 60487),
  extensionsLarge: register("extensions-large", 60488),
  layoutPanelDock: register("layout-panel-dock", 60489),
  layoutSidebarLeftDock: register("layout-sidebar-left-dock", 60490),
  layoutSidebarRightDock: register("layout-sidebar-right-dock", 60491),
  copilotInProgress: register("copilot-in-progress", 60492),
  copilotError: register("copilot-error", 60493),
  copilotSuccess: register("copilot-success", 60494),
  chatSparkle: register("chat-sparkle", 60495),
  searchSparkle: register("search-sparkle", 60496),
  editSparkle: register("edit-sparkle", 60497),
  copilotSnooze: register("copilot-snooze", 60498),
  sendToRemoteAgent: register("send-to-remote-agent", 60499),
  commentDiscussionSparkle: register("comment-discussion-sparkle", 60500),
  chatSparkleWarning: register("chat-sparkle-warning", 60501),
  chatSparkleError: register("chat-sparkle-error", 60502),
  collection: register("collection", 60503),
  newCollection: register("new-collection", 60504),
  thinking: register("thinking", 60505),
  build: register("build", 60506),
  commentDiscussionQuote: register("comment-discussion-quote", 60507),
  cursor: register("cursor", 60508),
  eraser: register("eraser", 60509),
  fileText: register("file-text", 60510),
  gitLens: register("git-lens", 60511),
  quotes: register("quotes", 60512),
  rename: register("rename", 60513),
  runWithDeps: register("run-with-deps", 60514),
  debugConnected: register("debug-connected", 60515),
  strikethrough: register("strikethrough", 60516),
  openInProduct: register("open-in-product", 60517),
  indexZero: register("index-zero", 60518)
};

// src/util/vs/base/common/codicons.ts
var codiconsDerived = {
  dialogError: register("dialog-error", "error"),
  dialogWarning: register("dialog-warning", "warning"),
  dialogInfo: register("dialog-info", "info"),
  dialogClose: register("dialog-close", "close"),
  treeItemExpanded: register("tree-item-expanded", "chevron-down"),
  // collapsed is done with rotation
  treeFilterOnTypeOn: register("tree-filter-on-type-on", "list-filter"),
  treeFilterOnTypeOff: register("tree-filter-on-type-off", "list-selection"),
  treeFilterClear: register("tree-filter-clear", "close"),
  treeItemLoading: register("tree-item-loading", "loading"),
  menuSelection: register("menu-selection", "check"),
  menuSubmenu: register("menu-submenu", "chevron-right"),
  menuBarMore: register("menubar-more", "more"),
  scrollbarButtonLeft: register("scrollbar-button-left", "triangle-left"),
  scrollbarButtonRight: register("scrollbar-button-right", "triangle-right"),
  scrollbarButtonUp: register("scrollbar-button-up", "triangle-up"),
  scrollbarButtonDown: register("scrollbar-button-down", "triangle-down"),
  toolBarMore: register("toolbar-more", "more"),
  quickInputBack: register("quick-input-back", "arrow-left"),
  dropDownButton: register("drop-down-button", 60084),
  symbolCustomColor: register("symbol-customcolor", 60252),
  exportIcon: register("export", 60332),
  workspaceUnspecified: register("workspace-unspecified", 60355),
  newLine: register("newline", 60394),
  thumbsDownFilled: register("thumbsdown-filled", 60435),
  thumbsUpFilled: register("thumbsup-filled", 60436),
  gitFetch: register("git-fetch", 60445),
  lightbulbSparkleAutofix: register("lightbulb-sparkle-autofix", 60447),
  debugBreakpointPending: register("debug-breakpoint-pending", 60377)
};
var Codicon = {
  ...codiconsLibrary,
  ...codiconsDerived
};

// src/util/vs/base/common/themables.ts
var ThemeColor;
((ThemeColor2) => {
  function isThemeColor(obj) {
    return !!obj && typeof obj === "object" && typeof obj.id === "string";
  }
  ThemeColor2.isThemeColor = isThemeColor;
})(ThemeColor || (ThemeColor = {}));
var ThemeIcon;
((ThemeIcon2) => {
  ThemeIcon2.iconNameSegment = "[A-Za-z0-9]+";
  ThemeIcon2.iconNameExpression = "[A-Za-z0-9-]+";
  ThemeIcon2.iconModifierExpression = "~[A-Za-z]+";
  ThemeIcon2.iconNameCharacter = "[A-Za-z0-9~-]";
  const ThemeIconIdRegex = new RegExp(`^(${ThemeIcon2.iconNameExpression})(${ThemeIcon2.iconModifierExpression})?$`);
  function asClassNameArray(icon) {
    const match3 = ThemeIconIdRegex.exec(icon.id);
    if (!match3) {
      return asClassNameArray(Codicon.error);
    }
    const [, id2, modifier] = match3;
    const classNames = ["codicon", "codicon-" + id2];
    if (modifier) {
      classNames.push("codicon-modifier-" + modifier.substring(1));
    }
    return classNames;
  }
  ThemeIcon2.asClassNameArray = asClassNameArray;
  function asClassName(icon) {
    return asClassNameArray(icon).join(" ");
  }
  ThemeIcon2.asClassName = asClassName;
  function asCSSSelector(icon) {
    return "." + asClassNameArray(icon).join(".");
  }
  ThemeIcon2.asCSSSelector = asCSSSelector;
  function isThemeIcon(obj) {
    return !!obj && typeof obj === "object" && typeof obj.id === "string" && (typeof obj.color === "undefined" || ThemeColor.isThemeColor(obj.color));
  }
  ThemeIcon2.isThemeIcon = isThemeIcon;
  const _regexFromString = new RegExp(`^\\$\\((${ThemeIcon2.iconNameExpression}(?:${ThemeIcon2.iconModifierExpression})?)\\)$`);
  function fromString(str) {
    const match3 = _regexFromString.exec(str);
    if (!match3) {
      return void 0;
    }
    const [, name] = match3;
    return { id: name };
  }
  ThemeIcon2.fromString = fromString;
  function fromId(id2) {
    return { id: id2 };
  }
  ThemeIcon2.fromId = fromId;
  function modify(icon, modifier) {
    let id2 = icon.id;
    const tildeIndex = id2.lastIndexOf("~");
    if (tildeIndex !== -1) {
      id2 = id2.substring(0, tildeIndex);
    }
    if (modifier) {
      id2 = `${id2}~${modifier}`;
    }
    return { id: id2 };
  }
  ThemeIcon2.modify = modify;
  function getModifier(icon) {
    const tildeIndex = icon.id.lastIndexOf("~");
    if (tildeIndex !== -1) {
      return icon.id.substring(tildeIndex + 1);
    }
    return void 0;
  }
  ThemeIcon2.getModifier = getModifier;
  function isEqual2(ti1, ti2) {
    return ti1.id === ti2.id && ti1.color?.id === ti2.color?.id;
  }
  ThemeIcon2.isEqual = isEqual2;
  function isFile(icon) {
    return icon?.id === Codicon.file.id;
  }
  ThemeIcon2.isFile = isFile;
  function isFolder(icon) {
    return icon?.id === Codicon.folder.id;
  }
  ThemeIcon2.isFolder = isFolder;
})(ThemeIcon || (ThemeIcon = {}));

// src/platform/inlineEdits/common/utils/utils.ts
var overridenNowValue = -1;
function now() {
  if (overridenNowValue !== -1) {
    return overridenNowValue;
  }
  return Date.now();
}
var Icon;
((Icon2) => {
  Icon2.circleSlash = {
    themeIcon: ThemeIcon.fromId("circle-slash"),
    svg: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill="currentColor" d="M8 1a7 7 0 1 1-7 7a7.01 7.01 0 0 1 7-7M2 8c0 1.418.504 2.79 1.423 3.87l8.447-8.447A5.993 5.993 0 0 0 2 8m12 0c0-1.418-.504-2.79-1.423-3.87L4.13 12.577A5.993 5.993 0 0 0 14 8"/></svg>`
  };
  Icon2.error = {
    themeIcon: ThemeIcon.fromId("error"),
    svg: `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentColor" fill-rule="evenodd" d="M8.6 1c1.6.1 3.1.9 4.2 2c1.3 1.4 2 3.1 2 5.1c0 1.6-.6 3.1-1.6 4.4c-1 1.2-2.4 2.1-4 2.4s-3.2.1-4.6-.7s-2.5-2-3.1-3.5S.8 7.5 1.3 6c.5-1.6 1.4-2.9 2.8-3.8C5.4 1.3 7 .9 8.6 1m.5 12.9c1.3-.3 2.5-1 3.4-2.1c.8-1.1 1.3-2.4 1.2-3.8c0-1.6-.6-3.2-1.7-4.3c-1-1-2.2-1.6-3.6-1.7c-1.3-.1-2.7.2-3.8 1S2.7 4.9 2.3 6.3c-.4 1.3-.4 2.7.2 4q.9 1.95 2.7 3c1.2.7 2.6.9 3.9.6M7.9 7.5L10.3 5l.7.7l-2.4 2.5l2.4 2.5l-.7.7l-2.4-2.5l-2.4 2.5l-.7-.7l2.4-2.5l-2.4-2.5l.7-.7z" clip-rule="evenodd"/></svg>`
  };
  Icon2.skipped = {
    themeIcon: ThemeIcon.fromId("testing-skipped-icon"),
    svg: `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentColor" fill-rule="evenodd" d="M14.25 5.75v-4h-1.5v2.542c-1.145-1.359-2.911-2.209-4.84-2.209c-3.177 0-5.92 2.307-6.16 5.398l-.02.269h1.501l.022-.226c.212-2.195 2.202-3.94 4.656-3.94c1.736 0 3.244.875 4.05 2.166h-2.83v1.5h4.163l.962-.975V5.75zM8 14a2 2 0 1 0 0-4a2 2 0 0 0 0 4" clip-rule="evenodd"/></svg>`
  };
  Icon2.lightbulbFull = {
    themeIcon: ThemeIcon.fromId("refactor-preview-view-icon"),
    svg: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill="currentColor" fill-rule="evenodd" d="M11.67 8.658a3.7 3.7 0 0 0-.781 1.114a3.3 3.3 0 0 0-.268 1.329v1.6a1.3 1.3 0 0 1-.794 1.197a1.3 1.3 0 0 1-.509.102H7.712a1.3 1.3 0 0 1-.922-.379a1.3 1.3 0 0 1-.38-.92v-1.6q0-.718-.274-1.329a3.6 3.6 0 0 0-.776-1.114a4.7 4.7 0 0 1-1.006-1.437A4.2 4.2 0 0 1 4 5.5a4.43 4.43 0 0 1 .616-2.27q.296-.504.705-.914a4.6 4.6 0 0 1 .911-.702q.508-.294 1.084-.454a4.5 4.5 0 0 1 1.2-.16a4.5 4.5 0 0 1 2.276.614a4.5 4.5 0 0 1 1.622 1.616a4.44 4.44 0 0 1 .616 2.27q0 .926-.353 1.721a4.7 4.7 0 0 1-1.006 1.437zM9.623 10.5H7.409v2.201q-.001.12.09.212a.3.3 0 0 0 .213.09h1.606a.3.3 0 0 0 .213-.09a.3.3 0 0 0 .09-.212V10.5z" clip-rule="evenodd"/></svg>`
  };
  Icon2.database = {
    themeIcon: ThemeIcon.fromId("database"),
    svg: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill="currentColor" d="M13 3.5C13 2.119 10.761 1 8 1S3 2.119 3 3.5c0 .04.02.077.024.117H3v8.872l.056.357C3.336 14.056 5.429 15 8 15s4.664-.944 4.944-2.154l.056-.357V3.617h-.024c.004-.04.024-.077.024-.117M8 2.032c2.442 0 4 .964 4 1.468s-1.558 1.468-4 1.468S4 4 4 3.5s1.558-1.468 4-1.468m4 10.458l-.03.131C11.855 13.116 10.431 14 8 14s-3.855-.884-3.97-1.379L4 12.49v-7.5A7.4 7.4 0 0 0 8 6a7.4 7.4 0 0 0 4-1.014z"/></svg>`
  };
})(Icon || (Icon = {}));

// src/platform/inlineEdits/common/workspaceEditTracker/historyContextProvider.ts
init_assert();
var DocumentHistory = class {
  constructor(docId, languageId, base2, lastEdits, lastSelection) {
    this.docId = docId;
    this.languageId = languageId;
    this.base = base2;
    this.lastEdits = lastEdits;
    this.lastSelection = lastSelection;
    this.lastEdit = new RootedEdit(this.base, this.lastEdits.compose());
  }
};

// src/platform/inlineEdits/common/workspaceEditTracker/nesHistoryContextProvider.ts
var DocumentState = class _DocumentState {
  constructor(docId, initialValue, languageId, selection) {
    this.docId = docId;
    this.languageId = languageId;
    this._edits = [];
    this._isUserDocument = false;
    this._baseValue = new StringText(initialValue);
    this._currentValue = this._baseValue;
    this.handleSelection(selection);
  }
  static {
    this.MAX_EDITED_LINES_PER_EDIT = 10;
  }
  static {
    this.MAX_EDITED_CHARS_PER_EDIT = 5e3;
  }
  getSelection() {
    return this._selection;
  }
  handleSelection(selection) {
    if (selection) {
      this._isUserDocument = true;
    }
    this._selection = selection;
  }
  handleEdit(edit, isInCooldown) {
    if (edit.isEmpty()) {
      return;
    }
    this._currentValue = edit.applyOnText(this._currentValue);
    const textEdit = TextEdit.fromStringEdit(edit, this._currentValue);
    const textLengthEdit = TextLengthEdit.fromTextEdit(textEdit);
    if (isInCooldown) {
      this._baseValue = this._currentValue;
      this._edits = [];
      return;
    }
    function editInsertSize(edit2) {
      return sum(edit2.replacements, (e) => e.newText.length);
    }
    const lastEdit = this._edits.at(-1);
    if (lastEdit && editInsertSize(lastEdit.edit) < 200 && editExtends(edit, lastEdit.edit)) {
      lastEdit.edit = lastEdit.edit.compose(edit);
      lastEdit.textLengthEdit = lastEdit.textLengthEdit.compose(textLengthEdit);
      lastEdit.instant = now();
      if (lastEdit.edit.isEmpty()) {
        this._edits.pop();
      }
    } else {
      this._edits.push({ edit, textLengthEdit, instant: now() });
    }
  }
  getRecentEdit(maxEditCount) {
    if (!this._isUserDocument) {
      return void 0;
    }
    const { editCount } = this._applyStaleEdits(maxEditCount);
    const edits = new Edits(StringEdit, this._edits.map((e) => e.edit));
    return {
      history: new DocumentHistory(this.docId, this.languageId, this._baseValue, edits, this._selection),
      editCount
    };
  }
  applyAllEdits() {
    this._baseValue = this._currentValue;
    this._edits = [];
  }
  _applyStaleEdits(maxEditCount) {
    let lastValue = this._currentValue;
    let recentEdit = StringEdit.empty;
    let recentTextLengthEdit = TextLengthEdit.empty;
    let i;
    let editCount = 0;
    let mostRecentEdit = StringEdit.empty;
    for (i = this._edits.length - 1; i >= 0; i--) {
      const e = this._edits[i];
      if (now() - e.instant > 10 * 60 * 1e3) {
        break;
      }
      const potentialNewTextLengthEdit = e.textLengthEdit.compose(recentTextLengthEdit);
      const potentialNewRange = potentialNewTextLengthEdit.getRange();
      assertType(potentialNewRange, "we only compose non-empty Edits");
      if (potentialNewRange.endLineNumber - potentialNewRange.startLineNumber > 100) {
        break;
      }
      const changedLines = sum(e.textLengthEdit.edits, (e2) => e2.range.endLineNumber - e2.range.startLineNumber + e2.newLength.lineCount);
      if (changedLines > _DocumentState.MAX_EDITED_LINES_PER_EDIT) {
        break;
      }
      const newCharacterCount = sum(e.edit.replacements, (singleEdit) => singleEdit.newText.length);
      if (newCharacterCount > _DocumentState.MAX_EDITED_CHARS_PER_EDIT) {
        break;
      }
      const replacedCharacterCount = sum(e.edit.replacements, (singleEdit) => singleEdit.replaceRange.length);
      if (replacedCharacterCount > _DocumentState.MAX_EDITED_CHARS_PER_EDIT) {
        break;
      }
      if (i === this._edits.length - 1) {
        mostRecentEdit = e.edit;
      } else {
        const swapResult = StringEdit.trySwap(e.edit, mostRecentEdit);
        if (swapResult) {
          mostRecentEdit = swapResult.e1;
        } else {
          if (changedLines >= 2) {
            break;
          }
          mostRecentEdit = e.edit.compose(mostRecentEdit);
        }
      }
      const inverseE = e.edit.inverse(lastValue.value);
      lastValue = inverseE.applyOnText(lastValue);
      const potentialRecentEdit = e.edit.compose(recentEdit);
      const potentialLineEdit = RootedEdit.toLineEdit(new RootedEdit(lastValue, potentialRecentEdit));
      const rootedLineEdit = new RootedLineEdit(lastValue, potentialLineEdit).removeCommonSuffixPrefixLines();
      const editLineCount = rootedLineEdit.edit.replacements.length;
      if (editLineCount > maxEditCount) {
        break;
      }
      editCount = editLineCount;
      recentEdit = potentialRecentEdit;
      recentTextLengthEdit = potentialNewTextLengthEdit;
    }
    for (let j = 0; j <= i; j++) {
      const e = this._edits[j];
      this._baseValue = e.edit.applyOnText(this._baseValue);
    }
    this._edits = this._edits.slice(i + 1);
    return { editCount };
  }
  toString() {
    return new Edits(StringEdit, this._edits.map((e) => e.edit)).toHumanReadablePatch(this._baseValue);
  }
};
function sum(arr, f) {
  let result = 0;
  for (const e of arr) {
    result += f(e);
  }
  return result;
}
function editExtends(edit, previousEdit) {
  const newRanges = previousEdit.getNewRanges();
  return edit.replacements.every((e) => doesTouch(e.replaceRange, newRanges));
}
function doesTouch(range, sortedRanges) {
  return sortedRanges.some((r) => range.start === r.endExclusive || range.endExclusive === r.start);
}

// src/platform/editSurvivalTracking/common/arcTracker.ts
var ArcTracker = class {
  constructor(originalText, _trackedEdit) {
    this.originalText = originalText;
    this._trackedEdit = _trackedEdit;
    const eNormalized = _trackedEdit.removeCommonSuffixPrefix(originalText);
    this._updatedTrackedEdit = eNormalized.mapData(() => new IsTrackedEditData(true));
  }
  handleEdits(edit) {
    const e = edit.mapData((_d) => new IsTrackedEditData(false));
    const composedEdit = this._updatedTrackedEdit.compose(e);
    const onlyTrackedEdit = composedEdit.decomposeSplit((e2) => !e2.data.isTrackedEdit).e2;
    this._updatedTrackedEdit = onlyTrackedEdit;
  }
  getAcceptedRestrainedCharactersCount() {
    const s = sum(this._updatedTrackedEdit.replacements, (e) => e.getNewLength());
    return s;
  }
  getOriginalCharacterCount() {
    return sum(this._trackedEdit.replacements, (e) => e.getNewLength());
  }
  getDebugState() {
    return {
      edits: this._updatedTrackedEdit.replacements.map((e) => ({
        range: e.replaceRange.toString(),
        newText: e.newText,
        isTrackedEdit: e.data.isTrackedEdit
      }))
    };
  }
};
var IsTrackedEditData = class {
  constructor(isTrackedEdit) {
    this.isTrackedEdit = isTrackedEdit;
  }
  join(data) {
    if (this.isTrackedEdit !== data.isTrackedEdit) {
      return void 0;
    }
    return this;
  }
};

// src/platform/editSurvivalTracking/common/editSurvivalTracker.ts
var EditSurvivalTracker = class {
  constructor(originalText, trackedEdits) {
    this.originalText = originalText;
    this._combinedEditsSinceStart = StringEdit.empty;
    this._text = trackedEdits.apply(this.originalText);
    this._textAfterTrackedEdits = this._text;
    this._originalEdits = trackedEdits;
  }
  handleEdits(edit) {
    const newText = edit.apply(this._text);
    let newEdits = this._combinedEditsSinceStart.compose(edit);
    newEdits = newEdits.removeCommonSuffixPrefix(this._textAfterTrackedEdits);
    this._combinedEditsSinceStart = newEdits;
    this._text = newText;
  }
  /**
   * fourGram: Number between 0 (no edits survived) and 1 (all edits survived).
   * noRevert: Number between 0 (the text after user edits equals the text before the AI edits) and 1 (the text after user edits does not revert any text to the initial state)
   */
  computeTrackedEditsSurvivalScore() {
    let similarityScoreSumFourGram = 0;
    let similarityScoreSumMax = 0;
    let noRevertSum = 0;
    let noRevertSumMax = 0;
    const ranges = this._originalEdits.getNewRanges();
    const updatedRanges = applyEditsToRanges(ranges, this._combinedEditsSinceStart);
    for (let i = 0; i < ranges.length; i++) {
      const originalEdit = this._originalEdits.replacements[i];
      const textBeforeAiEdits = this.originalText.substring(originalEdit.replaceRange.start, originalEdit.replaceRange.endExclusive);
      const textAfterAiEdits = originalEdit.newText;
      const newRange = updatedRanges[i];
      const textAfterUserEdits = this._text.substring(newRange.start, newRange.endExclusive);
      const similarity = compute4GramTextSimilarity(textAfterUserEdits, textAfterAiEdits);
      const aiEditSimilarity = compute4GramTextSimilarity(textAfterAiEdits, textBeforeAiEdits);
      const userEditSimilarity = compute4GramTextSimilarity(textAfterUserEdits, textBeforeAiEdits);
      if (aiEditSimilarity !== 1) {
        const v = 1 - Math.max(userEditSimilarity - aiEditSimilarity, 0) / (1 - aiEditSimilarity);
        noRevertSum += originalEdit.replaceRange.length * v;
        noRevertSumMax += originalEdit.replaceRange.length;
      }
      const similarityScoreFourGram = originalEdit.newText.length * similarity;
      const similarityScoreMax = originalEdit.newText.length;
      similarityScoreSumFourGram += similarityScoreFourGram;
      similarityScoreSumMax += similarityScoreMax;
    }
    return {
      fourGram: similarityScoreSumMax === 0 ? 1 : similarityScoreSumFourGram / similarityScoreSumMax,
      noRevert: noRevertSumMax === 0 ? 1 : noRevertSum / noRevertSumMax
    };
  }
};
function compute4GramTextSimilarity(text1, text2) {
  const n = 4;
  if (text1.length < n || text2.length < n) {
    return text1 === text2 ? 1 : 0;
  }
  const nGramIdx = /* @__PURE__ */ new Map();
  for (let i = 0; i <= text1.length - n; i++) {
    const nGram = text1.substring(i, i + n);
    const count2 = nGramIdx.get(nGram) || 0;
    nGramIdx.set(nGram, count2 + 1);
  }
  for (let i = 0; i <= text2.length - n; i++) {
    const nGram = text2.substring(i, i + n);
    const count2 = nGramIdx.get(nGram) || 0;
    nGramIdx.set(nGram, count2 - 1);
  }
  const totalNGramCount = text1.length - n + 1 + text2.length - n + 1;
  let differentNGramCount = 0;
  for (const count2 of nGramIdx.values()) {
    differentNGramCount += Math.abs(count2);
  }
  const equalNGramCount = totalNGramCount - differentNGramCount;
  return equalNGramCount / totalNGramCount;
}
function applyEditsToRanges(sortedRanges, edits) {
  sortedRanges = sortedRanges.slice();
  const result = [];
  let offset = 0;
  for (const e of edits.replacements) {
    while (true) {
      const r = sortedRanges[0];
      if (!r || r.endExclusive >= e.replaceRange.start) {
        break;
      }
      sortedRanges.shift();
      result.push(r.delta(offset));
    }
    const intersecting = [];
    while (true) {
      const r = sortedRanges[0];
      if (!r || !r.intersectsOrTouches(e.replaceRange)) {
        break;
      }
      sortedRanges.shift();
      intersecting.push(r);
    }
    for (let i = intersecting.length - 1; i >= 0; i--) {
      let r = intersecting[i];
      const overlap = r.intersect(e.replaceRange).length;
      r = r.deltaEnd(-overlap + (i === 0 ? e.newText.length : 0));
      const rangeAheadOfReplaceRange = r.start - e.replaceRange.start;
      if (rangeAheadOfReplaceRange > 0) {
        r = r.delta(-rangeAheadOfReplaceRange);
      }
      if (i !== 0) {
        r = r.delta(e.newText.length);
      }
      r = r.delta(-(e.newText.length - e.replaceRange.length));
      sortedRanges.unshift(r);
    }
    offset += e.newText.length - e.replaceRange.length;
  }
  while (true) {
    const r = sortedRanges[0];
    if (!r) {
      break;
    }
    sortedRanges.shift();
    result.push(r.delta(offset));
  }
  return result;
}

// src/platform/editSurvivalTracking/common/editSurvivalReporter.ts
var EditSurvivalReporter = class {
  /**
   * ```
   * _documentTextBeforeMarkedEdits
   * 	----markedEdits---->
   * 	----editsOnTop---->
   * _document.getText()
   *  ----onDidChangeTextDocument edits---->
   * 		[30sec] -> telemetry event of survival rate of markedEdits
   * 		[2min] -> ...
   * 		[5min] -> ...
   * 		[10min] -> ...
   * ```
  */
  constructor(_document, _documentTextBeforeMarkedEdits, _markedEdits, editsOnTop, _options, _sendTelemetryEvent, workspaceService, _gitService, _telemetryService) {
    this._document = _document;
    this._documentTextBeforeMarkedEdits = _documentTextBeforeMarkedEdits;
    this._markedEdits = _markedEdits;
    this._options = _options;
    this._sendTelemetryEvent = _sendTelemetryEvent;
    this._gitService = _gitService;
    this._telemetryService = _telemetryService;
    this._store = new DisposableStore();
    this._editSurvivalTracker = new EditSurvivalTracker(this._documentTextBeforeMarkedEdits, this._markedEdits);
    this._arcTracker = this._options.includeArc === true ? new ArcTracker(this._documentTextBeforeMarkedEdits, this._markedEdits) : void 0;
    this._store.add(workspaceService.onDidChangeTextDocument((e) => {
      if (e.document !== this._document) {
        return;
      }
      const edits = stringEditFromTextContentChange(e.contentChanges);
      this._editSurvivalTracker.handleEdits(edits);
      this._arcTracker?.handleEdits(edits);
    }));
    this._editSurvivalTracker.handleEdits(editsOnTop);
    this._arcTracker?.handleEdits(editsOnTop);
    this._initialBranchName = this._gitService.activeRepository.get()?.headBranchName;
    this._reportAfter(30 * 1e3);
    this._reportAfter(120 * 1e3);
    this._reportAfter(300 * 1e3);
    this._reportAfter(600 * 1e3);
    this._reportAfter(900 * 1e3, () => {
      this._store.dispose();
    });
  }
  _getCurrentBranchName() {
    return this._gitService.activeRepository.get()?.headBranchName;
  }
  _reportAfter(timeoutMs, cb) {
    const timer = new TimeoutTimer(() => {
      this._report(timeoutMs);
      timer.dispose();
      if (cb) {
        cb();
      }
    }, timeoutMs);
    this._store.add(timer);
  }
  _report(timeMs) {
    const survivalRate = this._editSurvivalTracker.computeTrackedEditsSurvivalScore();
    const currentBranch = this._getCurrentBranchName();
    const didBranchChange = currentBranch !== this._initialBranchName;
    this._sendTelemetryEvent({
      telemetryService: this._telemetryService,
      fourGram: survivalRate.fourGram,
      noRevert: survivalRate.noRevert,
      timeDelayMs: timeMs,
      didBranchChange,
      currentFileContent: this._document.getText(),
      arc: this._arcTracker?.getAcceptedRestrainedCharactersCount()
    });
  }
  cancel() {
    this._store.dispose();
  }
};
EditSurvivalReporter = __decorateClass([
  __decorateParam(6, IWorkspaceService),
  __decorateParam(7, IGitService),
  __decorateParam(8, ITelemetryService)
], EditSurvivalReporter);

// src/platform/editSurvivalTracking/common/editSurvivalTrackerService.ts
var IEditSurvivalTrackerService = createDecorator("IEditSurvivalTrackerService");
var EditSurvivalTrackerService = class {
  constructor(_instantiationService, _logService) {
    this._instantiationService = _instantiationService;
    this._logService = _logService;
  }
  initialize(document2) {
    const editCollector = this._instantiationService.createInstance(EditCollector, document2.getText());
    let reporter;
    return {
      collectAIEdits: (edits) => {
        try {
          editCollector.addEdits(Array.isArray(edits) ? edits : [edits]);
        } catch (error2) {
          this._logService.error("[EditSurvivalTrackerService] Error while collecting edits", error2);
        }
      },
      startReporter: (sendTelemetryEvent) => {
        const userEditComputer = this._instantiationService.createInstance(EditComputer, editCollector.getText(), document2);
        (async () => {
          try {
            const [aiEdits, userEditsResult] = await Promise.all([editCollector.getEdits(), userEditComputer.compute()]);
            const userEdits = userEditsResult.getEditsSinceInitial();
            reporter = this._instantiationService.createInstance(EditSurvivalReporter, document2, editCollector.initialText, aiEdits, userEdits, {}, sendTelemetryEvent);
          } finally {
            userEditComputer.dispose();
          }
        })();
      },
      cancel: () => {
        reporter?.cancel();
      }
    };
  }
};
EditSurvivalTrackerService = __decorateClass([
  __decorateParam(0, IInstantiationService),
  __decorateParam(1, ILogService)
], EditSurvivalTrackerService);

// src/platform/embeddings/common/embeddingsComputer.ts
var EmbeddingType = class _EmbeddingType {
  constructor(id2) {
    this.id = id2;
  }
  static {
    this.text3small_512 = new _EmbeddingType("text-embedding-3-small-512");
  }
  static {
    this.metis_1024_I16_Binary = new _EmbeddingType("metis-1024-I16-Binary");
  }
  static {
    this.codestralEmbed = new _EmbeddingType("mistralai/codestral-embed-2505");
  }
  toString() {
    return this.id;
  }
  equals(other) {
    return this.id === other.id;
  }
};
var wellKnownEmbeddingMetadata = Object.freeze({
  [EmbeddingType.text3small_512.id]: {
    model: "text-embedding-3-small" /* TEXT3SMALL */,
    dimensions: 512,
    quantization: {
      query: "float32",
      document: "float32"
    }
  },
  [EmbeddingType.metis_1024_I16_Binary.id]: {
    model: "metis-I16-Binary" /* Metis_I16_Binary */,
    dimensions: 1024,
    quantization: {
      query: "float16",
      document: "binary"
    }
  },
  [EmbeddingType.codestralEmbed.id]: {
    model: "text-embedding-3-small" /* TEXT3SMALL */,
    // Use TEXT3SMALL as fallback for legacy API
    dimensions: 1024,
    // Codestral Embed outputs 1024-dimensional vectors
    quantization: {
      query: "float32",
      document: "float32"
    }
  }
});
function getWellKnownEmbeddingTypeInfo(type) {
  return wellKnownEmbeddingMetadata[type.id];
}
var IEmbeddingsComputer = createDecorator("IEmbeddingsComputer");
function dotProduct(a, b) {
  if (a.length !== b.length) {
    console.warn("Embeddings do not have same length for computing dot product");
  }
  let dotProduct2 = 0;
  const len = Math.min(a.length, b.length);
  for (let i = 0; i < len; i++) {
    dotProduct2 += a[i] * b[i];
  }
  return dotProduct2;
}
function distance(queryEmbedding, otherEmbedding) {
  if (!queryEmbedding.type.equals(otherEmbedding.type)) {
    throw new Error(`Embeddings must be of the same type to compute similarity. Got: ${queryEmbedding.type.id} and ${otherEmbedding.type.id}`);
  }
  return {
    embeddingType: queryEmbedding.type,
    value: dotProduct(otherEmbedding.value, queryEmbedding.value)
  };
}
function rankEmbeddings(queryEmbedding, items, maxResults, options) {
  const minThreshold = options?.minDistance ?? 0;
  const results = items.map(([value, embedding]) => {
    return { distance: distance(embedding, queryEmbedding), value };
  }).filter((entry) => entry.distance.value > minThreshold).sort((a, b) => b.distance.value - a.distance.value).slice(0, maxResults).map((entry) => {
    return {
      distance: entry.distance,
      value: entry.value
    };
  });
  if (results.length && typeof options?.maxSpread === "number") {
    const minScore = results.at(0).distance.value * (1 - options.maxSpread);
    const out = results.filter((x) => x.distance.value >= minScore);
    return out;
  }
  return results;
}

// src/util/common/telemetryCorrelationId.ts
var CallTracker = class _CallTracker {
  static {
    this.joiner = " <- ";
  }
  constructor(...parts) {
    this.value = parts.join(_CallTracker.joiner);
  }
  toString() {
    return this.value;
  }
  toAscii() {
    return this.value.replace(/[\u{0080}-\u{FFFF}]/gu, "");
  }
  add(...parts) {
    return new _CallTracker(...parts, this.value);
  }
};
var TelemetryCorrelationId = class _TelemetryCorrelationId {
  constructor(caller, correlationId) {
    if (caller instanceof CallTracker) {
      this.callTracker = caller;
    } else {
      this.callTracker = typeof caller === "string" ? new CallTracker(caller) : new CallTracker(...caller);
    }
    this.correlationId = correlationId || generateUuid();
  }
  addCaller(...parts) {
    return new _TelemetryCorrelationId(this.callTracker.add(...parts), this.correlationId);
  }
};

// src/platform/chunking/common/chunkingEndpointClientImpl.ts
init_arrays();
init_lazy();
init_lifecycle();
init_linkedList();
init_strings();
init_range();

// src/platform/endpoint/common/capiClient.ts
var ICAPIClientService = createDecorator("ICAPIClientService");

// src/platform/log/common/logExecTime.ts
init_errors();
init_stopwatch();
async function measureExecTime(fn, cb) {
  const sw = new StopWatch();
  try {
    const result = await fn();
    cb(sw.elapsed(), "success", result);
    return result;
  } catch (error2) {
    cb(sw.elapsed(), isCancellationError(error2) ? "cancelled" : "failed", void 0);
    throw error2;
  }
}
async function logExecTime(logService, name, fn, measureCb) {
  return measureExecTime(() => {
    logService.trace(`${name} started`);
    return fn();
  }, (time, status, result) => {
    logService.trace(`${name} ${status}. Elapsed ${time}`);
    measureCb?.(time, status, result);
  });
}

// src/platform/networking/common/fetcherService.ts
var IFetcherService2 = createDecorator("IFetcherService");

// src/platform/networking/common/networking.ts
init_errors();

// src/platform/networking/common/openai.ts
var import_prompt_tsx2 = __toESM(require_base());
var import_rawTypes = __toESM(require_rawTypes());

// src/platform/endpoint/common/thinkingDataContainer.tsx
var import_prompt_tsx = __toESM(require_base());

// src/platform/endpoint/common/endpointTypes.ts
var CustomDataPartMimeTypes;
((CustomDataPartMimeTypes2) => {
  CustomDataPartMimeTypes2.CacheControl = "cache_control";
  CustomDataPartMimeTypes2.StatefulMarker = "stateful_marker";
  CustomDataPartMimeTypes2.ThinkingData = "thinking";
})(CustomDataPartMimeTypes || (CustomDataPartMimeTypes = {}));

// src/platform/networking/common/networking.ts
var requestTimeoutMs = 30 * 1e3;
function networkRequest(fetcher, telemetryService, capiClientService, requestType, endpointOrUrl, secretKey, intent, requestId, body, additionalHeaders, cancelToken, useFetcher) {
  const endpoint = typeof endpointOrUrl === "string" || "type" in endpointOrUrl ? {
    modelMaxPromptTokens: 0,
    urlOrRequestMetadata: endpointOrUrl,
    family: "",
    tokenizer: "o200k_base" /* O200K */,
    acquireTokenizer: () => {
      throw new Error("Method not implemented.");
    },
    name: "",
    version: ""
  } : endpointOrUrl;
  const headers = {
    Authorization: `Bearer ${secretKey}`,
    "X-Request-Id": requestId,
    "X-Interaction-Type": intent,
    "OpenAI-Intent": intent,
    // Tells CAPI who flighted this request. Helps find buggy features
    "X-GitHub-Api-Version": "2025-05-01",
    ...additionalHeaders,
    ...endpoint.getExtraHeaders ? endpoint.getExtraHeaders() : {}
  };
  if (endpoint.interceptBody) {
    endpoint.interceptBody(body);
  }
  console.log(`networkRequest: body.tools count after interceptBody: ${body?.tools?.length ?? 0}`);
  const endpointFetchOptions = endpoint.getEndpointFetchOptions?.();
  const request = {
    method: requestType,
    headers,
    json: body,
    timeout: requestTimeoutMs,
    useFetcher,
    suppressIntegrationId: endpointFetchOptions?.suppressIntegrationId
  };
  if (cancelToken) {
    const abort = fetcher.makeAbortController();
    cancelToken.onCancellationRequested(() => {
      telemetryService.sendGHTelemetryEvent("networking.cancelRequest", {
        headerRequestId: requestId
      });
      abort.abort();
    });
    request.signal = abort.signal;
  }
  if (typeof endpoint.urlOrRequestMetadata === "string") {
    console.log(`[networkRequest] Making request to ${endpoint.urlOrRequestMetadata}`);
    const requestPromise = fetcher.fetch(endpoint.urlOrRequestMetadata, request).then((response) => {
      console.log(`[networkRequest] Response status: ${response.status}`);
      console.log(`[networkRequest] Response ok: ${response.ok}`);
      return response;
    }).catch((reason) => {
      console.error(`[networkRequest] Request failed:`, reason);
      if (canRetryOnceNetworkError(reason)) {
        telemetryService.sendGHTelemetryEvent("networking.disconnectAll");
        return fetcher.disconnectAll().then(() => {
          return fetcher.fetch(endpoint.urlOrRequestMetadata, request);
        });
      } else if (fetcher.isAbortError(reason)) {
        throw new CancellationError();
      } else {
        throw reason;
      }
    });
    return requestPromise;
  } else {
    return capiClientService.makeRequest(request, endpoint.urlOrRequestMetadata);
  }
}
function canRetryOnceNetworkError(reason) {
  return [
    "ECONNRESET",
    "ETIMEDOUT",
    "ERR_NETWORK_CHANGED",
    "ERR_HTTP2_INVALID_SESSION",
    "ERR_HTTP2_STREAM_CANCEL",
    "ERR_HTTP2_GOAWAY_SESSION",
    "ERR_HTTP2_PROTOCOL_ERROR"
  ].includes(reason?.code);
}
function postRequest(fetcherService, telemetryService, capiClientService, endpointOrUrl, secretKey, hmac, intent, requestId, body, additionalHeaders, cancelToken, useFetcher) {
  return networkRequest(
    fetcherService,
    telemetryService,
    capiClientService,
    "POST",
    endpointOrUrl,
    secretKey,
    intent,
    requestId,
    body,
    additionalHeaders,
    cancelToken,
    useFetcher
  );
}
var IHeaderContributors = createDecorator("headerContributors");
var HeaderContributors = class {
  constructor() {
    this.contributors = [];
  }
  add(contributor) {
    this.contributors.push(contributor);
  }
  remove(contributor) {
    const index = this.contributors.indexOf(contributor);
    if (index === -1) {
      return;
    }
    this.contributors.splice(index, 1);
  }
  contributeHeaders(headers) {
    for (const contributor of this.contributors) {
      contributor.contributeHeaderValues(headers);
    }
  }
  size() {
    return this.contributors.length;
  }
};

// src/platform/chunking/common/chunkingStringUtils.ts
init_strings();
function stripChunkTextMetadata(text2) {
  const lines = splitLines(text2);
  if (lines.length >= 3 && lines[0].startsWith("File: ") && lines[1].startsWith("```") && lines.at(-1)?.startsWith("```")) {
    return lines.slice(2, -1).join("\n");
  }
  return text2;
}

// src/platform/chunking/common/chunkingEndpointClientImpl.ts
var RequestRateLimiter = class extends Disposable {
  constructor(experimentationService) {
    super();
    /** Max number of times to retry a request before failing. */
    this._maxAttempts = 3;
    /**
     * Target quota usage percentage that we want to maintain.
     *
     * Anything under this will be sent as fast as possible. Once we go over this, we start sending requests slower
     * and slower as we approach 100% quota usage.
     */
    this.targetQuota = 80;
    // %
    this.requestQueue = new LinkedList();
    // State
    this._numberInFlightRequests = 0;
    this._lastSendTime = Date.now();
    this._isPumping = false;
    this._maxParallelChunksRequests = experimentationService.getTreatmentVariable("workspace.embeddingIndex.maxParallelChunksRequests") ?? 8;
  }
  static {
    this._abuseLimit = 1e3 / 40;
  }
  enqueue(task, token) {
    const deferred = new DeferredPromise();
    token.onCancellationRequested(() => deferred.cancel());
    this.requestQueue.push({ task, attempt: 0, deferred, token });
    this.pump();
    return deferred.p;
  }
  async pump() {
    if (this._isPumping) {
      return;
    }
    try {
      this._isPumping = true;
      while (!this.requestQueue.isEmpty()) {
        if (this._rateLimitTimeout) {
          await this._rateLimitTimeout;
          this._rateLimitTimeout = void 0;
        }
        const elapsedSinceLastSend = Date.now() - this._lastSendTime;
        if (elapsedSinceLastSend < RequestRateLimiter._abuseLimit) {
          await timeout(RequestRateLimiter._abuseLimit - elapsedSinceLastSend);
        }
        if (this._numberInFlightRequests >= this._maxParallelChunksRequests) {
          await timeout(10);
          continue;
        }
        if (this._latestRateLimitHint) {
          const currentTime = Date.now();
          if (currentTime < this._latestRateLimitHint.resetAt) {
            if (this._latestRateLimitHint.remaining - this._numberInFlightRequests <= 0) {
              const resetTimeSpan = this._latestRateLimitHint.resetAt - currentTime;
              await timeout(Math.min(resetTimeSpan, 2e3));
            }
          }
        }
        if (this._latestQuotaUsed && this._latestQuotaUsed.quota > this.targetQuota) {
          const currentTime = Date.now();
          const quotaDelta = this._latestQuotaUsed.quota - this.targetQuota;
          const quotaDeltaTime = currentTime - this._latestQuotaUsed.timestamp;
          const decayTime = 2500;
          const maxDelay = 1e3;
          let quotaAdjustment = quotaDelta / (100 - this.targetQuota);
          quotaAdjustment *= Math.max(1 - quotaDeltaTime / decayTime, 0);
          const delay = quotaAdjustment * maxDelay;
          if (delay > 0) {
            await timeout(Math.min(delay, maxDelay));
          }
        }
        const e = this.requestQueue.shift();
        if (e.token.isCancellationRequested) {
          e.deferred.cancel();
          continue;
        }
        this._numberInFlightRequests++;
        this._lastSendTime = Date.now();
        const request = e.task(e.attempt);
        request.then((response) => {
          this.updateQuotasFromResponse(response);
          if (e.token.isCancellationRequested) {
            e.deferred.cancel();
            return;
          }
          if (response.ok) {
            e.deferred.complete(response);
            return;
          }
          if (e.attempt < this._maxAttempts) {
            if (response.status === 429 || response.status === 403 || response.status === 408) {
              const retryAfter_seconds = this.getRequestRetryDelay(response);
              if (retryAfter_seconds > 0) {
                this._rateLimitTimeout = timeout(retryAfter_seconds * 1e3);
              }
              this.requestQueue.unshift({ task: e.task, attempt: e.attempt + 1, deferred: e.deferred, token: e.token });
              this.pump();
              return;
            }
          }
          e.deferred.complete(response);
        }).catch((err) => {
          e.deferred.error(err);
        }).finally(() => {
          this._numberInFlightRequests--;
        });
      }
    } finally {
      this._isPumping = false;
    }
  }
  updateQuotasFromResponse(response) {
    const timestamp = Date.now();
    try {
      const rateLimitRemaining = response.headers.get("x-ratelimit-remaining");
      const rateLimitReset = response.headers.get("x-ratelimit-reset");
      if (rateLimitRemaining && rateLimitReset) {
        this._latestRateLimitHint = {
          timestamp,
          remaining: parseFloat(rateLimitRemaining),
          resetAt: parseFloat(rateLimitReset) * 1e3
          // convert to ms
        };
      }
      const totalQuotaUsed = response.headers.get("x-github-total-quota-used");
      if (totalQuotaUsed) {
        if (this._latestQuotaUsed) {
          this._latestQuotaUsed = {
            timestamp,
            quota: parseFloat(totalQuotaUsed)
          };
        } else {
          this._latestQuotaUsed = {
            timestamp,
            quota: parseFloat(totalQuotaUsed)
          };
        }
      }
    } catch (e) {
      console.error("Error parsing rate limit headers", e);
    }
  }
  /**
   * Get the retry delay for a request based on the response.
   *
   * @returns The retry delay in seconds.
   */
  getRequestRetryDelay(response) {
    try {
      const retryAfterHeader = response.headers.get("retry-after");
      if (retryAfterHeader) {
        const intValue = parseFloat(retryAfterHeader);
        if (!isNaN(intValue)) {
          return intValue;
        }
      }
    } catch {
    }
    try {
      const resetHeader = response.headers.get("x-ratelimit-reset");
      if (resetHeader) {
        const intValue = parseFloat(resetHeader);
        if (!isNaN(intValue)) {
          const currentEpochSeconds = Math.floor(Date.now() / 1e3);
          return intValue - currentEpochSeconds;
        }
      }
    } catch {
    }
    if (response.status === 408) {
      return 0.25;
    }
    return 2;
  }
};
RequestRateLimiter = __decorateClass([
  __decorateParam(0, IExperimentationService)
], RequestRateLimiter);
var ChunkingEndpointClientImpl = class extends Disposable {
  constructor(instantiationService, _capiClientService, _envService, _fetcherService, _logService, _telemetryService, _workspaceService) {
    super();
    this._capiClientService = _capiClientService;
    this._envService = _envService;
    this._fetcherService = _fetcherService;
    this._logService = _logService;
    this._telemetryService = _telemetryService;
    this._workspaceService = _workspaceService;
    this._requestHmac = new Lazy(() => createRequestHMAC(env.HMAC_SECRET));
    this._requestLimiter = this._register(instantiationService.createInstance(RequestRateLimiter));
  }
  computeChunks(authToken, embeddingType, content, batchInfo, qos, cache, telemetryInfo, token) {
    return this.doComputeChunksAndEmbeddings(authToken, embeddingType, content, batchInfo, { qos, computeEmbeddings: false }, cache, telemetryInfo, token);
  }
  async computeChunksAndEmbeddings(authToken, embeddingType, content, batchInfo, qos, cache, telemetryInfo, token) {
    const result = await this.doComputeChunksAndEmbeddings(authToken, embeddingType, content, batchInfo, { qos, computeEmbeddings: true }, cache, telemetryInfo, token);
    return result;
  }
  async doComputeChunksAndEmbeddings(authToken, embeddingType, content, batchInfo, options, cache, telemetryInfo, token) {
    const text2 = await raceCancellationError(content.getText(), token);
    if (isFalsyOrWhitespace(text2)) {
      return [];
    }
    try {
      const hmac = await raceCancellationError(this._requestHmac.value, token);
      const makeRequest = async (attempt) => {
        return logExecTime(this._logService, `ChunksEndpointEmbeddingComputer.fetchChunksRequest(${content.uri}, attempt=${attempt})`, () => postRequest(
          this._fetcherService,
          this._telemetryService,
          this._capiClientService,
          { type: "Chunks" /* Chunks */ },
          authToken,
          hmac,
          "copilot-panel",
          "",
          {
            embed: options.computeEmbeddings,
            // Only to online set during re-ranking step
            qos: options.qos,
            content: text2,
            path: getWorkspaceFileDisplayPath(this._workspaceService, content.uri),
            local_hashes: cache ? Array.from(cache.keys()) : [],
            language_id: content.githubLanguageId,
            embedding_model: embeddingType.id
          },
          getGithubMetadataHeaders(telemetryInfo, this._envService),
          token
        ));
      };
      batchInfo.recomputedFileCount++;
      batchInfo.sentContentTextLength += text2.length;
      const response = await raceCancellationError(this._requestLimiter.enqueue(makeRequest, token), token);
      if (!response.ok) {
        this._logService.debug(`Error chunking '${content.uri}'. Status: ${response.status}. Status Text: ${response.statusText}.`);
        this._telemetryService.sendMSFTTelemetryEvent("workspaceChunkEmbeddingsIndex.computeChunksAndEmbeddings.error", {
          source: telemetryInfo.toString()
        }, {
          responseStatus: response.status
        });
        return void 0;
      }
      const body = await response.json();
      if (!body.chunks.length) {
        return [];
      }
      return coalesce(body.chunks.map((chunk) => {
        const range = new Range(chunk.line_range.start, 0, chunk.line_range.end, 0);
        const cached = cache?.get(chunk.hash);
        if (cached) {
          return {
            chunk: {
              file: content.uri,
              text: stripChunkTextMetadata(cached.chunk.text),
              rawText: void 0,
              range,
              isFullFile: cached.chunk.isFullFile
              // TODO: get from endpoint
            },
            chunkHash: chunk.hash,
            embedding: cached.embedding
          };
        }
        if (typeof chunk.text !== "string") {
          return void 0;
        }
        let embedding;
        if (chunk.embedding?.embedding) {
          const returnedEmbeddingsType = new EmbeddingType(body.embedding_model);
          if (!returnedEmbeddingsType.equals(embeddingType)) {
            throw new Error(`Unexpected embedding model. Got: ${returnedEmbeddingsType}. Expected: ${embeddingType}`);
          }
          embedding = { type: returnedEmbeddingsType, value: chunk.embedding.embedding };
        }
        if (options.computeEmbeddings && !embedding) {
          return void 0;
        }
        return {
          chunk: {
            file: content.uri,
            text: stripChunkTextMetadata(chunk.text),
            rawText: void 0,
            range,
            isFullFile: false
            // TODO: get from endpoint
          },
          chunkHash: chunk.hash,
          embedding
        };
      }));
    } catch (e) {
      this._logService.error(e);
      return void 0;
    }
  }
};
ChunkingEndpointClientImpl = __decorateClass([
  __decorateParam(0, IInstantiationService),
  __decorateParam(1, ICAPIClientService),
  __decorateParam(2, IEnvService),
  __decorateParam(3, IFetcherService2),
  __decorateParam(4, ILogService),
  __decorateParam(5, ITelemetryService),
  __decorateParam(6, IWorkspaceService)
], ChunkingEndpointClientImpl);
function getGithubMetadataHeaders(callerInfo, envService) {
  const editorInfo = envService.getEditorInfo();
  const versionNumberAndSubName = editorInfo.version.match(/^(?<version>.+?)(\-(?<subName>\w+?))?$/);
  const application = versionNumberAndSubName && versionNumberAndSubName.groups?.subName ? `${editorInfo.name}-${versionNumberAndSubName.groups.subName}/${versionNumberAndSubName.groups.version}` : editorInfo.format();
  return {
    "X-Client-Application": application,
    "X-Client-Source": envService.getEditorPluginInfo().format(),
    "X-Client-Feature": callerInfo.toAscii().slice(0, 1e3)
  };
}

// src/platform/endpoint/common/endpointProvider.ts
var IEndpointProvider = createDecorator("IEndpointProvider");

// src/platform/embeddings/common/remoteEmbeddingsComputer.ts
var RemoteEmbeddingsComputer = class {
  constructor(_authService, _capiClientService, _envService, _fetcherService, _logService, _telemetryService, _endpointProvider) {
    this._authService = _authService;
    this._capiClientService = _capiClientService;
    this._envService = _envService;
    this._fetcherService = _fetcherService;
    this._logService = _logService;
    this._telemetryService = _telemetryService;
    this._endpointProvider = _endpointProvider;
    this.batchSize = 100;
  }
  async computeEmbeddings(embeddingType, inputs, options, telemetryInfo, cancellationToken) {
    return logExecTime(this._logService, "RemoteEmbeddingsComputer::computeEmbeddings", async () => {
      const copilotToken = await this._authService.getCopilotToken();
      if (copilotToken.isNoAuthUser) {
        const embeddings = await this.computeCAPIEmbeddings(inputs, options, cancellationToken);
        return embeddings ?? { type: embeddingType, values: [] };
      }
      const token = (await this._authService.getAnyGitHubSession({ silent: true }))?.accessToken;
      if (!token) {
        throw new Error("No authentication token available");
      }
      const embeddingsOut = [];
      for (let i = 0; i < inputs.length; i += this.batchSize) {
        const batch = inputs.slice(i, i + this.batchSize);
        if (!batch.length) {
          break;
        }
        const body = {
          inputs: batch,
          input_type: options?.inputType ?? "document",
          embedding_model: embeddingType.id
        };
        const response = await postRequest(
          this._fetcherService,
          this._telemetryService,
          this._capiClientService,
          { type: "DotcomEmbeddings" /* DotcomEmbeddings */ },
          token,
          await createRequestHMAC(env.HMAC_SECRET),
          "copilot-panel",
          generateUuid(),
          body,
          getGithubMetadataHeaders(telemetryInfo?.callTracker ?? new CallTracker(), this._envService),
          cancellationToken
        );
        if (!response.ok) {
          this._telemetryService.sendMSFTTelemetryEvent("remoteEmbeddingsComputer.computeEmbeddings.error", {
            source: telemetryInfo?.callTracker.toString(),
            correlationId: telemetryInfo?.correlationId,
            embeddingType: embeddingType.id
          }, {
            totalInputLength: inputs.length,
            batchInputLength: batch.length,
            statusCode: response.status
          });
          throw new Error(`Error fetching embeddings: ${response.status}`);
        }
        const jsonResponse = await response.json();
        const resolvedType = new EmbeddingType(jsonResponse.embedding_model);
        if (!resolvedType.equals(embeddingType)) {
          throw new Error(`Unexpected embedding model. Got: ${resolvedType}. Expected: ${embeddingType}`);
        }
        if (batch.length !== jsonResponse.embeddings.length) {
          throw new Error(`Mismatched embedding result count. Expected: ${batch.length}. Got: ${jsonResponse.embeddings.length}`);
        }
        embeddingsOut.push(...jsonResponse.embeddings.map((embedding) => ({
          type: resolvedType,
          value: embedding.embedding
        })));
      }
      return { type: embeddingType, values: embeddingsOut };
    });
  }
  async computeCAPIEmbeddings(inputs, options, cancellationToken) {
    const typeInfo = getWellKnownEmbeddingTypeInfo(EmbeddingType.text3small_512);
    if (!typeInfo) {
      throw new Error(`Embeddings type info not found: ${EmbeddingType.text3small_512}`);
    }
    const endpoint = await this._endpointProvider.getEmbeddingsEndpoint("text3small");
    const batchSize = endpoint.maxBatchSize;
    const maxTokens = endpoint.modelMaxPromptTokens - 1;
    return this.fetchResponseWithBatches(typeInfo, endpoint, inputs, cancellationToken, maxTokens, batchSize);
  }
  /**
   * A recursive helper that drives the public `fetchResponse` function. This allows accepting a batch and supports backing off the endpoint.
   * @param inputs The inputs to get embeddings for
   * @param cancellationToken A cancellation token to allow cancelling the requests
   * @param batchSize The batch size to calculate
   * @returns The embeddings
   */
  async fetchResponseWithBatches(type, endpoint, inputs, cancellationToken, maxTokens, batchSize, parallelism = 1) {
    for (const input of inputs) {
      const inputTokenLength = await endpoint.acquireTokenizer().tokenLength(input);
      if (inputTokenLength > maxTokens) {
        return void 0;
      }
    }
    let embeddings = [];
    const promises = [];
    const limiter = new Limiter(parallelism);
    try {
      for (let i = 0; i < inputs.length; i += batchSize) {
        const currentBatch = inputs.slice(i, i + batchSize);
        promises.push(limiter.queue(async () => {
          if (cancellationToken?.isCancellationRequested) {
            return;
          }
          const r = await this.rawEmbeddingsFetchWithTelemetry(type, endpoint, generateUuid(), currentBatch, cancellationToken);
          if (r.type === "failed") {
            throw new Error("Embeddings request failed " + r.reason);
          }
          return r;
        }));
      }
      embeddings = (await Promise.all(promises)).flatMap((response) => response?.embeddings ?? []);
    } catch (e) {
      return void 0;
    } finally {
      limiter.dispose();
    }
    if (cancellationToken?.isCancellationRequested) {
      return void 0;
    }
    if (embeddings.length === 0) {
      return void 0;
    }
    return { type: EmbeddingType.text3small_512, values: embeddings.map((value) => ({ type: EmbeddingType.text3small_512, value })) };
  }
  async rawEmbeddingsFetchWithTelemetry(type, endpoint, requestId, inputs, cancellationToken) {
    const startTime = Date.now();
    const rawRequest = await this.rawEmbeddingsFetch(type, endpoint, requestId, inputs, cancellationToken);
    if (rawRequest.type === "failed") {
      this._telemetryService.sendMSFTTelemetryErrorEvent("embedding.error", {
        type: rawRequest.type,
        reason: rawRequest.reason
      });
      return rawRequest;
    }
    const tokenizer = endpoint.acquireTokenizer();
    const tokenCounts = await Promise.all(inputs.map((input) => tokenizer.tokenLength(input)));
    const inputTokenCount = tokenCounts.reduce((acc, count2) => acc + count2, 0);
    this._telemetryService.sendMSFTTelemetryEvent("embedding.success", {}, {
      batchSize: inputs.length,
      inputTokenCount,
      timeToComplete: Date.now() - startTime
    });
    return rawRequest;
  }
  /**
   * The function which actually makes the request to the API and handles failures.
   * This is separated out from fetchResponse as fetchResponse does some manipulation to the input and handles errors differently
   */
  async rawEmbeddingsFetch(type, endpoint, requestId, inputs, cancellationToken) {
    try {
      const token = await this._authService.getCopilotToken();
      const body = { input: inputs, model: type.model, dimensions: type.dimensions };
      endpoint.interceptBody?.(body);
      const response = await postRequest(
        this._fetcherService,
        this._telemetryService,
        this._capiClientService,
        endpoint,
        token.token,
        await createRequestHMAC(env.HMAC_SECRET),
        "copilot-panel",
        requestId,
        body,
        void 0,
        cancellationToken
      );
      const jsonResponse = response.status === 200 ? await response.json() : await response.text();
      if (response.status === 200 && jsonResponse.data) {
        return { type: "success", embeddings: jsonResponse.data.map((d) => d.embedding) };
      } else {
        return { type: "failed", reason: jsonResponse.error };
      }
    } catch (e) {
      let errorMessage = e?.message ?? "Unknown error";
      if (errorMessage.match(/Unexpected.*JSON/i)) {
        errorMessage = "timeout";
      }
      return { type: "failed", reason: errorMessage };
    }
  }
};
RemoteEmbeddingsComputer = __decorateClass([
  __decorateParam(0, IAuthenticationService),
  __decorateParam(1, ICAPIClientService),
  __decorateParam(2, IEnvService),
  __decorateParam(3, IFetcherService2),
  __decorateParam(4, ILogService),
  __decorateParam(5, ITelemetryService),
  __decorateParam(6, IEndpointProvider)
], RemoteEmbeddingsComputer);

// src/util/common/vscodeVersion.ts
function sanitizeVSCodeVersion(vsCodeVersion) {
  const splitVersion = vsCodeVersion.split(".");
  return `${splitVersion[0]}.${splitVersion[1]}`;
}

// src/platform/workbench/common/workbenchService.ts
var IWorkbenchService = createDecorator("IWorkbenchService");

// src/platform/extContext/common/extensionContext.ts
var IVSCodeExtensionContext = createDecorator("IVSCodeExtensionContext");

// src/platform/embeddings/common/embeddingsIndex.ts
function embeddingsModelToRemoteContainer(embeddingType) {
  switch (getWellKnownEmbeddingTypeInfo(embeddingType)?.model) {
    case "metis-I16-Binary" /* Metis_I16_Binary */:
      return "metis-1024-I16-Binary" /* METIS_1024_I16_BINARY */;
    case "text-embedding-3-small" /* TEXT3SMALL */:
    default:
      return "text-3-small" /* TEXT3SMALL */;
  }
}
var EmbeddingsCache = class {
  constructor(cacheType, cacheKey, cacheVersion, fileSystemService, extensionContext) {
    this.cacheType = cacheType;
    this.cacheKey = cacheKey;
    this.cacheVersion = cacheVersion;
    this.fileSystemService = fileSystemService;
    this.extensionContext = extensionContext;
    this.cacheVersionKey = `${cacheKey}-version`;
  }
  get cacheStorageUri() {
    return this.cacheType === 2 /* WORKSPACE */ ? this.extensionContext.storageUri : this.extensionContext.globalStorageUri;
  }
  get cacheVersionMementoStorage() {
    return this.cacheType === 2 /* WORKSPACE */ ? this.extensionContext.workspaceState : this.extensionContext.globalState;
  }
  async updateCache(value) {
    if (!this.cacheStorageUri || value === void 0) {
      return;
    }
    if (!this.fileSystemService.isWritableFileSystem(this.cacheStorageUri.scheme)) {
      return;
    }
    try {
      await this.fileSystemService.stat(this.cacheStorageUri);
    } catch (e) {
      if (e.code === "ENOENT") {
        await this.fileSystemService.createDirectory(this.cacheStorageUri);
      }
    }
    await this.cacheVersionMementoStorage.update(this.cacheVersionKey, this.cacheVersion);
    const cacheFile = URI.joinPath(this.cacheStorageUri, `${this.cacheKey}.json`);
    try {
      await this.fileSystemService.writeFile(cacheFile, VSBuffer.fromString(JSON.stringify(value)).buffer);
    } catch (e) {
      if (value !== void 0) {
        console.error(`Failed to write embeddings cache to ${cacheFile}`);
      }
    }
  }
  async getCache() {
    if (!this.cacheStorageUri) {
      return;
    }
    const cacheVersion = this.cacheVersionMementoStorage.get(this.cacheVersionKey);
    if (cacheVersion !== this.cacheVersion) {
      return void 0;
    }
    try {
      const cacheEntries = await fileSystemServiceReadAsJSON.readJSON(this.fileSystemService, URI.joinPath(this.cacheStorageUri, `${this.cacheKey}.json`));
      if (this.isEmbeddingCacheEntriesType(cacheEntries)) {
        return this.constructExposedCache(cacheEntries);
      }
      return cacheEntries;
    } catch {
      return void 0;
    }
  }
  async clearCache() {
    if (!this.cacheStorageUri) {
      return;
    }
    const hasOldCache = this.cacheVersionMementoStorage.get(this.cacheKey);
    if (hasOldCache) {
      await this.cacheVersionMementoStorage.update(this.cacheKey, void 0);
    }
    const cacheFile = URI.joinPath(this.cacheStorageUri, `${this.cacheKey}.json`);
    try {
      await this.fileSystemService.stat(this.cacheStorageUri);
      await this.fileSystemService.delete(cacheFile, { useTrash: false });
    } catch (e) {
      if (e.code === "ENOENT") {
        throw new Error(`Cache file ${cacheFile} does not exist`);
      }
    }
  }
  isEmbeddingCacheEntriesType(cache) {
    return cache.core !== void 0 && cache.extensions !== void 0;
  }
  constructExposedCache(cache) {
    const flattenedCache = { ...cache.core };
    for (const extensionId in cache.extensions) {
      const extensionCache = cache.extensions[extensionId];
      for (const key in extensionCache) {
        flattenedCache[key] = extensionCache[key];
      }
    }
    return flattenedCache;
  }
};
EmbeddingsCache = __decorateClass([
  __decorateParam(3, IFileSystemService),
  __decorateParam(4, IVSCodeExtensionContext)
], EmbeddingsCache);
var LocalEmbeddingsCache = class {
  constructor(cacheType, cacheKey, cacheVersion, embeddingType, instantiationService) {
    this.cacheKey = cacheKey;
    this.cacheVersion = cacheVersion;
    this.embeddingType = embeddingType;
    this._embeddingsCache = instantiationService.createInstance(
      EmbeddingsCache,
      cacheType,
      cacheKey,
      cacheVersion
    );
  }
  async getCache() {
    const cacheEntries = await this._embeddingsCache.getCache();
    if (cacheEntries === void 0) {
      throw new Error(`Failed to get cache for ${this.cacheKey}, version ${this.cacheVersion}`);
    }
    return cacheEntries;
  }
  clearCache() {
    return this._embeddingsCache.clearCache();
  }
};
LocalEmbeddingsCache = __decorateClass([
  __decorateParam(4, IInstantiationService)
], LocalEmbeddingsCache);
var RemoteEmbeddingsCache = class {
  constructor(cacheType, cacheKey, cacheVersion, embeddingType, remoteCacheType, fetcherService, instantiationService) {
    this.cacheVersion = cacheVersion;
    this.embeddingType = embeddingType;
    this.remoteCacheType = remoteCacheType;
    this.fetcherService = fetcherService;
    this.embeddingsCache = instantiationService.createInstance(
      EmbeddingsCache,
      cacheType,
      cacheKey,
      cacheVersion
    );
    this.remoteCacheVersionKey = `${cacheKey}-version-remote`;
  }
  async clearCache() {
    await this.embeddingsCache.clearCache();
  }
  async getRemoteContainer() {
    return embeddingsModelToRemoteContainer(this.embeddingType);
  }
  async getRemoteCacheURL() {
    if (!this._remoteCacheURL) {
      const remoteCacheContainer = await this.getRemoteContainer();
      this._remoteCacheURL = RemoteEmbeddingsCache.calculateRemoteCDNURL(remoteCacheContainer, this.remoteCacheType, this.cacheVersion);
    }
    return this._remoteCacheURL;
  }
  async getRemoteCacheLatestUpdateURL() {
    if (!this._remoteCacheLatestUpdateURL) {
      const remoteCacheContainer = await this.getRemoteContainer();
      this._remoteCacheLatestUpdateURL = RemoteEmbeddingsCache.calculateRemoteCDNLatestURL(remoteCacheContainer, this.remoteCacheType, this.cacheVersion);
    }
    return this._remoteCacheLatestUpdateURL;
  }
  async fetchRemoteCache() {
    if (this._remoteCacheEntries) {
      return this._remoteCacheEntries;
    }
    const remoteCacheURL = await this.getRemoteCacheURL();
    try {
      const remoteCacheURL2 = await this.getRemoteCacheURL();
      const response = await this.fetcherService.fetch(remoteCacheURL2, { method: "GET" });
      if (response.ok) {
        this._remoteCacheEntries = await response.json();
        return this._remoteCacheEntries;
      } else {
        console.error(`Failed to fetch remote embeddings cache from ${remoteCacheURL2}`);
        console.error(`Response status: ${response.status}, status text: ${response.statusText}`);
        return;
      }
    } catch (err) {
      console.error(`Failed to fetch remote embeddings cache from ${remoteCacheURL}`);
      console.error(err);
      return;
    }
  }
  async fetchRemoteCacheLatest() {
    const remoteCacheLatestUpdateURL = await this.getRemoteCacheLatestUpdateURL();
    try {
      const response = await this.fetcherService.fetch(remoteCacheLatestUpdateURL, { method: "GET" });
      if (response.ok) {
        return response.text();
      } else {
        console.error(`Failed to fetch remote embeddings cache from ${remoteCacheLatestUpdateURL}`);
        console.error(`Response status: ${response.status}, status text: ${response.statusText}`);
        return;
      }
    } catch (err) {
      console.error(`Failed to fetch remote embeddings cache from ${remoteCacheLatestUpdateURL}`);
      console.error(err);
      return;
    }
  }
  async getCache() {
    const remoteCacheLatest = await this.fetchRemoteCacheLatest();
    const cache = await this.embeddingsCache.getCache();
    if (cache && remoteCacheLatest === this.embeddingsCache.cacheVersionMementoStorage.get(this.remoteCacheVersionKey)) {
      return cache;
    }
    const remoteCache = await this.fetchRemoteCache();
    if (remoteCache === void 0) {
      return cache;
    }
    await this.embeddingsCache.clearCache();
    await this.embeddingsCache.cacheVersionMementoStorage.update(this.remoteCacheVersionKey, remoteCacheLatest);
    await this.embeddingsCache.updateCache(remoteCache);
    return remoteCache;
  }
  static calculateRemoteCDNURL(cacheContainer, embeddingsType, cacheVersion) {
    return `https://embeddings.vscode-cdn.net/${cacheContainer}/v${cacheVersion}/${embeddingsType}/core.json`;
  }
  static calculateRemoteCDNLatestURL(cacheContainer, embeddingsType, cacheVersion) {
    return `https://embeddings.vscode-cdn.net/${cacheContainer}/v${cacheVersion}/${embeddingsType}/latest.txt`;
  }
};
RemoteEmbeddingsCache = __decorateClass([
  __decorateParam(5, IFetcherService2),
  __decorateParam(6, IInstantiationService)
], RemoteEmbeddingsCache);
var RemoteEmbeddingsExtensionCache = class extends RemoteEmbeddingsCache {
  constructor(cacheType, cacheKey, cacheVersion, embeddingType, remoteCacheType, fetcher, workbenchService, instantiationService) {
    super(cacheType, cacheKey, cacheVersion, embeddingType, remoteCacheType, fetcher, instantiationService);
    this.workbenchService = workbenchService;
  }
  async getBaseExtensionCDNURL() {
    if (!this._baseExtensionCDNURL) {
      const remoteCacheContainer = await this.getRemoteContainer();
      this._baseExtensionCDNURL = RemoteEmbeddingsExtensionCache.calculateBaseRemoteExtensionCDNURL(remoteCacheContainer, this.remoteCacheType, this.cacheVersion);
    }
    return this._baseExtensionCDNURL;
  }
  constructExposedCache() {
    if (!this._remoteExtensionCache) {
      return;
    }
    const flattenedCache = { ...this._remoteExtensionCache.core };
    for (const extensionId in this._remoteExtensionCache.extensions) {
      const extensionCache = this._remoteExtensionCache.extensions[extensionId];
      for (const key in extensionCache) {
        flattenedCache[key] = extensionCache[key];
      }
    }
    return flattenedCache;
  }
  async fetchRemoteExtensionCache(extensionId) {
    const baseExtensionCDNURL = await this.getBaseExtensionCDNURL();
    const extensionUrl = `${baseExtensionCDNURL}/${extensionId}.json`;
    try {
      const response = await this.fetcherService.fetch(extensionUrl, { method: "GET" });
      if (response.ok) {
        return await response.json();
      } else {
        if (response.status === 404) {
          return {};
        }
        console.error(`Failed to fetch remote embeddings cache from ${extensionUrl}`);
        console.error(`Response status: ${response.status}, status text: ${response.statusText}`);
        return;
      }
    } catch (err) {
      console.error(`Failed to fetch remote embeddings cache from ${extensionUrl}`);
      console.error(err);
      return;
    }
  }
  async getCache() {
    const coreOrLocalCache = await super.getCache();
    if (coreOrLocalCache === void 0) {
      return;
    }
    let currentCache = { core: {}, extensions: {} };
    if (coreOrLocalCache && RemoteEmbeddingsExtensionCache.isEmbeddingsCacheEntriesWithExtensions(coreOrLocalCache)) {
      currentCache = coreOrLocalCache;
    } else {
      currentCache = { core: coreOrLocalCache, extensions: {} };
    }
    const activatedExtensionIds = RemoteEmbeddingsExtensionCache.getInstalledExtensionIds(this.workbenchService);
    let removedExtensions = false;
    for (const extensionId in currentCache.extensions) {
      if (!activatedExtensionIds.includes(extensionId)) {
        delete currentCache.extensions[extensionId];
        removedExtensions = true;
      }
    }
    const extensionIdsToFetch = activatedExtensionIds.filter(
      (id2) => !(id2 in currentCache.extensions) || currentCache.extensions[id2] === void 0
    );
    for (const extensionId of extensionIdsToFetch) {
      const extensionCache = await this.fetchRemoteExtensionCache(extensionId);
      if (extensionCache) {
        currentCache.extensions[extensionId] = extensionCache;
      }
    }
    this._remoteExtensionCache = currentCache;
    if (extensionIdsToFetch.length > 0 || removedExtensions) {
      await this.embeddingsCache.clearCache();
      await this.embeddingsCache.updateCache(currentCache);
    }
    return this.constructExposedCache();
  }
  static isEmbeddingsCacheEntriesWithExtensions(obj) {
    return "core" in obj && "extensions" in obj;
  }
  static getInstalledExtensionIds(workbenchService) {
    return workbenchService.getAllExtensions().filter((e) => !e.id.startsWith("vscode")).map((e) => e.id);
  }
  static calculateBaseRemoteExtensionCDNURL(cacheContainer, embeddingsType, cacheVersion) {
    return `https://embeddings.vscode-cdn.net/${cacheContainer}/v${cacheVersion}/${embeddingsType}`;
  }
};
RemoteEmbeddingsExtensionCache = __decorateClass([
  __decorateParam(5, IFetcherService2),
  __decorateParam(6, IWorkbenchService),
  __decorateParam(7, IInstantiationService)
], RemoteEmbeddingsExtensionCache);
var BaseEmbeddingsIndex = class {
  constructor(loggerContext, embeddingType, cacheKey, _embeddingsCache, embeddingsComputer, logService) {
    this.embeddingType = embeddingType;
    this.cacheKey = cacheKey;
    this._embeddingsCache = _embeddingsCache;
    this.embeddingsComputer = embeddingsComputer;
    this.logService = logService;
    this._isIndexLoaded = false;
    this._items = /* @__PURE__ */ new Map();
  }
  get isIndexLoaded() {
    return this._isIndexLoaded;
  }
  set isIndexLoaded(value) {
    this._isIndexLoaded = value;
  }
  async rebuildCache() {
    await this._embeddingsCache.clearCache();
    this._items.clear();
    return this.calculateEmbeddings();
  }
  /**
   * Finds the n closest values to a given embedding
   * @param queryEmbedding The embedding to find the n closest values for
   * @param n The number of closest values to return
   * @returns The n closest values to the embedding, sorted by similarity. Could be less than n if there are less than n items indexed
   */
  nClosestValues(queryEmbedding, n) {
    return rankEmbeddings(queryEmbedding, Array.from(this._items.values()).filter((x) => x.embedding).map((x) => [x, { value: x.embedding, type: this.embeddingType }]), n).map((x) => x.value);
  }
  hasItem(key) {
    return this._items.has(key);
  }
  getItem(key) {
    return this._items.get(key);
  }
  async calculateEmbeddings() {
    if (this._calculationPromise) {
      return this._calculationPromise;
    }
    this._calculationPromise = this._calculateEmbeddings();
    return this._calculationPromise.then(() => this._calculationPromise = void 0);
  }
  async _calculateEmbeddings() {
    const startTime = Date.now();
    const allItems = await this.getLatestItems();
    const cachedEmbeddings = await this._embeddingsCache.getCache();
    const latestEmbeddingsIndex = /* @__PURE__ */ new Map();
    for (const item of allItems) {
      let newItem = item;
      const oldItem = this._items.get(item.key);
      const key = item.key;
      if (oldItem?.embedding) {
        newItem = oldItem;
      } else if (cachedEmbeddings && cachedEmbeddings[key]) {
        newItem = { ...item, ...cachedEmbeddings[key] };
      }
      latestEmbeddingsIndex.set(key, newItem);
    }
    this._items = latestEmbeddingsIndex;
    this.logService.debug(`Embeddings for ${this.cacheKey} calculated in ${Date.now() - startTime}ms`);
    this.isIndexLoaded = true;
  }
};

// src/platform/embeddings/common/vscodeIndex.ts
function settingItemToContext(item) {
  let result = `Setting Id: ${item.key}
`;
  result += `Type: ${item.type}
`;
  result += `Description: ${item.description ?? item.markdownDescription ?? ""}
`;
  if (item.enum) {
    result += `Possible values:
`;
    for (let i = 0; i < item.enum.length; i++) {
      result += ` - ${item.enum[i]} - ${item.enumDescriptions?.[i] ?? ""}
`;
    }
  }
  result += "\n";
  return result;
}
var RelatedInformationProviderEmbeddingsIndex = class extends BaseEmbeddingsIndex {
  constructor(loggerContext, embeddingType, cacheKey, embeddingsComputer, embeddingsCache, relatedInformationConfig, _logService, telemetryService) {
    super(
      loggerContext,
      embeddingType,
      cacheKey,
      embeddingsCache,
      embeddingsComputer,
      _logService
    );
    this.relatedInformationConfig = relatedInformationConfig;
    this._logService = _logService;
    this.telemetryService = telemetryService;
    this.isIndexLoaded = false;
  }
  /**
   * Returns related information for the given query
   * @param query The base string which will be compared against indexed items
   * @param types The types of related information to return
   * @param token A cancellation token to cancel the request
   * @returns An array of RelatedInformationResult objects
   */
  async provideRelatedInformation(query, token) {
    const similarityStart = Date.now();
    if (!this.isIndexLoaded) {
      this.calculateEmbeddings();
      this._logService.debug(`Related Information: Index not loaded yet triggering background calculation, returning ${Date.now() - similarityStart}ms`);
      return [];
    }
    if (token.isCancellationRequested) {
      this._logService.debug(`Related Information: Request cancelled, returning ${Date.now() - similarityStart}ms`);
      return [];
    }
    const startOfEmbeddingRequest = Date.now();
    const embeddingResult = await this.embeddingsComputer.computeEmbeddings(EmbeddingType.text3small_512, [query], {}, new TelemetryCorrelationId("RelatedInformationProviderEmbeddingsIndex::provideRelatedInformation"), token);
    this._logService.debug(`Related Information: Remote similarly request took ${Date.now() - startOfEmbeddingRequest}ms`);
    if (token.isCancellationRequested) {
      this._logService.debug(`Related Information: Request cancelled or no embeddings computed, returning ${Date.now() - similarityStart}ms`);
      return [];
    }
    const results = [];
    for (const item of this._items.values()) {
      if (token.isCancellationRequested) {
        this._logService.debug(`Related Information: Request cancelled, returning ${Date.now() - similarityStart}ms`);
        break;
      }
      if (item.embedding) {
        const score = distance(embeddingResult.values[0], { value: item.embedding, type: EmbeddingType.text3small_512 }).value;
        if (score > this.relatedInformationConfig.threshold) {
          results.push(this.toRelatedInformation(item, score));
        }
      }
    }
    this.logService.debug(`Related Information: Successfully Calculated, returning ${Date.now() - similarityStart}ms`);
    if (this.relatedInformationConfig.type === 4 /* SettingInformation */) {
      this.telemetryService.sendInternalMSFTTelemetryEvent("relatedInformationSettings", { query });
    }
    const returnthis = results.sort((a, b) => b.weight - a.weight).slice(0, this.relatedInformationConfig.maxResults);
    return returnthis;
  }
};
var CommandIdIndex = class extends RelatedInformationProviderEmbeddingsIndex {
  constructor(embeddingscache, embeddingsFetcher, logService, telemetryService, workbenchService) {
    super(
      "CommandIdIndex",
      EmbeddingType.text3small_512,
      "commandEmbeddings",
      embeddingsFetcher,
      embeddingscache,
      {
        type: 2 /* CommandInformation */,
        threshold: (
          /* min threshold of 0 for text-3-small*/
          0
        ),
        maxResults: 100
      },
      logService,
      telemetryService
    );
    this.workbenchService = workbenchService;
  }
  async getLatestItems() {
    const allCommands = await this.workbenchService.getAllCommands();
    allCommands.push({
      label: "Extensions: Search the marketplace for extensions",
      command: "workbench.extensions.search",
      keybinding: "Not set"
    });
    allCommands.push({
      label: "Extensions: Install extension from marketplace",
      command: "workbench.extensions.installExtension",
      keybinding: "Not set"
    });
    return allCommands.map((c) => {
      return {
        key: c.command,
        label: c.label.replace("View: Toggle", "View: Toggle or Show or Hide"),
        originalLabel: c.label,
        keybinding: c.keybinding ?? "Not set"
      };
    });
  }
  getEmbeddingQueryString(value) {
    return `${value.label} - ${value.key}`;
  }
  toRelatedInformation(value, score) {
    return {
      type: 2 /* CommandInformation */,
      weight: score,
      command: value.key
    };
  }
};
CommandIdIndex = __decorateClass([
  __decorateParam(1, IEmbeddingsComputer),
  __decorateParam(2, ILogService),
  __decorateParam(3, ITelemetryService),
  __decorateParam(4, IWorkbenchService)
], CommandIdIndex);
var SettingsIndex = class extends RelatedInformationProviderEmbeddingsIndex {
  constructor(embeddingsCache, embeddingsFetcher, logService, telemetryService, workbenchService) {
    super(
      "SettingsIndex",
      EmbeddingType.text3small_512,
      "settingEmbeddings",
      embeddingsFetcher,
      embeddingsCache,
      {
        type: 4 /* SettingInformation */,
        threshold: (
          /* min threshold of 0 for text-3-small*/
          0
        ),
        maxResults: 100
      },
      logService,
      telemetryService
    );
    this.workbenchService = workbenchService;
  }
  async getLatestItems() {
    const settings = await this.workbenchService.getAllSettings();
    const settingsList = [];
    for (const settingId of Object.keys(settings)) {
      const setting = settings[settingId];
      if (setting.deprecationMessage || setting.markdownDeprecationMessage) {
        continue;
      }
      settingsList.push({ ...setting, key: settingId });
    }
    return settingsList;
  }
  getEmbeddingQueryString(value) {
    return settingItemToContext(value);
  }
  toRelatedInformation(value, score) {
    return {
      type: 4 /* SettingInformation */,
      weight: score,
      setting: value.key
    };
  }
};
SettingsIndex = __decorateClass([
  __decorateParam(1, IEmbeddingsComputer),
  __decorateParam(2, ILogService),
  __decorateParam(3, ITelemetryService),
  __decorateParam(4, IWorkbenchService)
], SettingsIndex);
var ICombinedEmbeddingIndex = createDecorator("ICombinedEmbeddingIndex");
var VSCodeCombinedIndexImpl = class {
  constructor(useRemoteCache = true, instantiationService, envService) {
    const settingsEmbeddingsCache = useRemoteCache ? instantiationService.createInstance(RemoteEmbeddingsExtensionCache, 1 /* GLOBAL */, "settingEmbeddings", sanitizeVSCodeVersion(envService.getEditorInfo().version), EmbeddingType.text3small_512, "settings" /* Settings */) : instantiationService.createInstance(LocalEmbeddingsCache, 1 /* GLOBAL */, "settingEmbeddings", "1.98", EmbeddingType.text3small_512);
    const commandsEmbeddingsCache = useRemoteCache ? instantiationService.createInstance(RemoteEmbeddingsExtensionCache, 1 /* GLOBAL */, "commandEmbeddings", sanitizeVSCodeVersion(envService.getEditorInfo().version), EmbeddingType.text3small_512, "commands" /* Commands */) : instantiationService.createInstance(LocalEmbeddingsCache, 1 /* GLOBAL */, "commandEmbeddings", "1.98", EmbeddingType.text3small_512);
    this.settingsIndex = instantiationService.createInstance(SettingsIndex, settingsEmbeddingsCache);
    this.commandIdIndex = instantiationService.createInstance(CommandIdIndex, commandsEmbeddingsCache);
  }
  async loadIndexes() {
    await Promise.all([
      this.commandIdIndex.isIndexLoaded ? Promise.resolve() : this.commandIdIndex.calculateEmbeddings(),
      this.settingsIndex.isIndexLoaded ? Promise.resolve() : this.settingsIndex.calculateEmbeddings()
    ]);
  }
  async nClosestValues(embedding, n) {
    await this.loadIndexes();
    return {
      commands: this.commandIdIndex.nClosestValues(embedding, n),
      settings: this.settingsIndex.nClosestValues(embedding, n)
    };
  }
  hasSetting(settingId) {
    return this.settingsIndex.hasItem(settingId);
  }
  hasCommand(commandId) {
    return this.commandIdIndex.hasItem(commandId);
  }
  getSetting(settingId) {
    return this.settingsIndex.getItem(settingId);
  }
  getCommand(commandId) {
    return this.commandIdIndex.getItem(commandId);
  }
};
VSCodeCombinedIndexImpl = __decorateClass([
  __decorateParam(1, IInstantiationService),
  __decorateParam(2, IEnvService)
], VSCodeCombinedIndexImpl);

// src/platform/env/vscode/envServiceImpl.ts
var vscode6 = __toESM(require("vscode"));
var EnvServiceImpl = class {
  get extensionId() {
    return `${packageJson.publisher}.${packageJson.name}`.toLowerCase();
  }
  get sessionId() {
    return vscode6.env.sessionId;
  }
  get machineId() {
    return vscode6.env.machineId;
  }
  get devDeviceId() {
    return vscode6.env.devDeviceId;
  }
  get vscodeVersion() {
    return vscode6.version;
  }
  get remoteName() {
    return vscode6.env.remoteName;
  }
  get uiKind() {
    switch (vscode6.env.uiKind) {
      case vscode6.UIKind.Desktop:
        return "desktop";
      case vscode6.UIKind.Web:
        return "web";
    }
  }
  get isActive() {
    return vscode6.window.state.active;
  }
  get OS() {
    switch (platform) {
      case 3 /* Windows */:
        return "Windows" /* Windows */;
      case 1 /* Mac */:
        return "Mac" /* Macintosh */;
      case 2 /* Linux */:
        return "Linux" /* Linux */;
      default:
        return "Linux" /* Linux */;
    }
  }
  get language() {
    return vscode6.env.language;
  }
  get uriScheme() {
    return vscode6.env.uriScheme;
  }
  get appRoot() {
    return vscode6.env.appRoot;
  }
  get shell() {
    return vscode6.env.shell;
  }
  isProduction() {
    return isProduction;
  }
  isPreRelease() {
    return isPreRelease;
  }
  isSimulation() {
    return false;
  }
  getBuildType() {
    return packageJson.buildType;
  }
  getVersion() {
    return packageJson.version;
  }
  getBuild() {
    return packageJson.build;
  }
  getName() {
    return packageJson.name;
  }
  getEditorInfo() {
    return new NameAndVersion("vscode", vscode6.version);
  }
  getEditorPluginInfo() {
    return new NameAndVersion("copilot-chat", packageJson.version);
  }
  openExternal(target) {
    return new Promise((resolve2, reject) => vscode6.env.openExternal(target).then(resolve2, reject));
  }
};

// src/platform/extensions/vscode/extensionsService.ts
var vscode7 = __toESM(require("vscode"));
var VSCodeExtensionsService = class {
  get all() {
    return vscode7.extensions.all;
  }
  get allAcrossExtensionHosts() {
    return vscode7.extensions.allAcrossExtensionHosts;
  }
  get onDidChange() {
    return vscode7.extensions.onDidChange;
  }
  get getExtension() {
    return vscode7.extensions.getExtension;
  }
};

// src/platform/filesystem/vscode/fileSystemServiceImpl.ts
var vscode8 = __toESM(require("vscode"));
var VSCodeFileSystemService = class {
  async stat(uri) {
    return vscode8.workspace.fs.stat(uri);
  }
  async readDirectory(uri) {
    return vscode8.workspace.fs.readDirectory(uri);
  }
  async createDirectory(uri) {
    return vscode8.workspace.fs.createDirectory(uri);
  }
  async readFile(uri, disableLimit) {
    await assertReadFileSizeLimit(this, uri, disableLimit);
    return vscode8.workspace.fs.readFile(uri);
  }
  async writeFile(uri, content) {
    return vscode8.workspace.fs.writeFile(uri, content);
  }
  async delete(uri, options) {
    return vscode8.workspace.fs.delete(uri, options);
  }
  async rename(oldURI, newURI, options) {
    return vscode8.workspace.fs.rename(oldURI, newURI, options);
  }
  async copy(source, destination, options) {
    return vscode8.workspace.fs.copy(source, destination, options);
  }
  isWritableFileSystem(scheme) {
    return !!vscode8.workspace.fs.isWritableFileSystem(scheme);
  }
  createFileSystemWatcher(glob) {
    return vscode8.workspace.createFileSystemWatcher(glob);
  }
};

// src/platform/git/common/gitExtensionService.ts
var IGitExtensionService = createDecorator("IGitExtensionService");

// src/platform/git/vscode/gitExtensionServiceImpl.ts
var vscode9 = __toESM(require("vscode"));
var GitExtensionServiceImpl = class {
  constructor(_logService) {
    this._logService = _logService;
    this._onDidChange = new vscode9.EventEmitter();
    this.onDidChange = this._onDidChange.event;
    this._extensionEnablement = void 0;
    this._disposables = [];
    this._logService.info("[GitExtensionServiceImpl] Initializing Git extension service.");
    this._disposables.push(...this._initializeExtensionApi());
  }
  getExtensionApi() {
    return this._api;
  }
  get extensionAvailable() {
    if (this._extensionEnablement === void 0) {
      return !!vscode9.extensions.getExtension("vscode.git");
    } else {
      return this._extensionEnablement;
    }
  }
  _initializeExtensionApi() {
    const disposables = [];
    let gitExtension = vscode9.extensions.getExtension("vscode.git");
    const initialize = async () => {
      let extension;
      try {
        extension = await gitExtension.activate();
        this._logService.info("[GitExtensionServiceImpl] Successfully activated the vscode.git extension.");
      } catch (e) {
        this._logService.error(e, "[GitExtensionServiceImpl] Failed to activate the vscode.git extension.");
        return;
      }
      const onDidChangeGitExtensionEnablement = (enabled) => {
        this._logService.info(`[GitExtensionServiceImpl] Enablement state of the vscode.git extension: ${enabled}.`);
        this._extensionEnablement = enabled;
        if (enabled) {
          this._api = extension.getAPI(1);
          this._onDidChange.fire({ enabled: true });
          this._logService.info("[GitExtensionServiceImpl] Successfully registered Git commit message provider.");
        } else {
          this._api = void 0;
          this._onDidChange.fire({ enabled: false });
        }
      };
      disposables.push(extension.onDidChangeEnablement(onDidChangeGitExtensionEnablement));
      onDidChangeGitExtensionEnablement(extension.enabled);
    };
    if (gitExtension) {
      initialize();
    } else {
      this._logService.info("[GitExtensionServiceImpl] vscode.git extension is not yet activated.");
      const listener = vscode9.extensions.onDidChange(() => {
        if (!gitExtension && vscode9.extensions.getExtension("vscode.git")) {
          gitExtension = vscode9.extensions.getExtension("vscode.git");
          initialize();
          listener.dispose();
        }
      });
    }
    return disposables;
  }
};
GitExtensionServiceImpl = __decorateClass([
  __decorateParam(0, ILogService)
], GitExtensionServiceImpl);

// src/platform/git/vscode/gitServiceImpl.ts
var vscode10 = __toESM(require("vscode"));
var import_vscode6 = require("vscode");

// src/util/common/async.ts
init_errors();
var BatchedProcessor = class {
  constructor(_fn, _waitingTimeMs) {
    this._fn = _fn;
    this._waitingTimeMs = _waitingTimeMs;
    this._queue = [];
    this._timeout = null;
  }
  request(arg) {
    if (this._timeout === null) {
      this._timeout = setTimeout(() => this._flush(), this._waitingTimeMs);
    }
    const p = new DeferredPromise();
    this._queue.push({ arg, promise: p });
    return p.p;
  }
  async _flush() {
    const queue = this._queue;
    this._queue = [];
    this._timeout = null;
    const args = queue.map((e) => e.arg);
    let results;
    try {
      results = await this._fn(args);
    } catch (e) {
      for (const entry of queue) {
        entry.promise.error(e);
      }
      return;
    }
    for (const [i, result] of results.entries()) {
      queue[i].promise.complete(result);
    }
  }
};

// src/platform/git/vscode/gitServiceImpl.ts
init_arrays();
init_cache();
init_cancellation();
init_event();
init_lifecycle();

// src/platform/git/common/utils.ts
var GitConfigParser = class _GitConfigParser {
  static {
    this._lineSeparator = /\r?\n/;
  }
  static {
    this._propertyRegex = /^\s*(\w+)\s*=\s*"?([^"]+)"?$/;
  }
  static {
    this._sectionRegex = /^\s*\[\s*([^\]]+?)\s*(\"[^"]+\")*\]\s*$/;
  }
  static parse(raw) {
    const config3 = { sections: [] };
    let section = { name: "DEFAULT", properties: {} };
    const addSection = (section2) => {
      if (!section2) {
        return;
      }
      config3.sections.push(section2);
    };
    for (const line of raw.split(_GitConfigParser._lineSeparator)) {
      const sectionMatch = line.match(_GitConfigParser._sectionRegex);
      if (sectionMatch?.length === 3) {
        addSection(section);
        section = { name: sectionMatch[1], subSectionName: sectionMatch[2]?.replaceAll('"', ""), properties: {} };
        continue;
      }
      const propertyMatch = line.match(_GitConfigParser._propertyRegex);
      if (propertyMatch?.length === 3 && !Object.keys(section.properties).includes(propertyMatch[1])) {
        section.properties[propertyMatch[1]] = propertyMatch[2];
      }
    }
    addSection(section);
    return config3.sections;
  }
};
function parseGitRemotes(raw) {
  const remotes = [];
  for (const remoteSection of GitConfigParser.parse(raw).filter((s) => s.name === "remote")) {
    if (remoteSection.subSectionName) {
      remotes.push({
        name: remoteSection.subSectionName,
        fetchUrl: remoteSection.properties["url"],
        pushUrl: remoteSection.properties["pushurl"] ?? remoteSection.properties["url"],
        isReadOnly: false
      });
    }
  }
  return remotes;
}
function toGitUri(uri, ref, options = {}) {
  const params = {
    path: uri.fsPath,
    ref
  };
  if (options.submoduleOf) {
    params.submoduleOf = options.submoduleOf;
  }
  let path = uri.path;
  if (options.replaceFileExtension) {
    path = `${path}.git`;
  } else if (options.submoduleOf) {
    path = `${path}.diff`;
  }
  return uri.with({ scheme: options.scheme ?? "git", path, query: JSON.stringify(params) });
}

// src/platform/git/vscode/gitServiceImpl.ts
var GitServiceImpl = class extends Disposable {
  constructor(gitExtensionService, logService) {
    super();
    this.gitExtensionService = gitExtensionService;
    this.logService = logService;
    this.activeRepository = observableValue(this, void 0);
    this._onDidOpenRepository = new Emitter();
    this.onDidOpenRepository = this._onDidOpenRepository.event;
    this._onDidCloseRepository = new Emitter();
    this.onDidCloseRepository = this._onDidCloseRepository.event;
    this._onDidFinishInitialRepositoryDiscovery = new Emitter();
    this.onDidFinishInitialization = this._onDidFinishInitialRepositoryDiscovery.event;
    this._isInitialized = observableValue(this, false);
    this._register(this._onDidOpenRepository);
    this._register(this._onDidCloseRepository);
    this._register(this._onDidFinishInitialRepositoryDiscovery);
    const gitAPI = this.gitExtensionService.getExtensionApi();
    if (gitAPI) {
      this.registerGitAPIListeners(gitAPI);
    } else {
      this._register(this.gitExtensionService.onDidChange((status) => {
        if (status.enabled) {
          const gitAPI2 = this.gitExtensionService.getExtensionApi();
          if (gitAPI2) {
            this.registerGitAPIListeners(gitAPI2);
            return;
          }
        }
        this._onDidFinishInitialRepositoryDiscovery.fire();
      }));
    }
  }
  registerGitAPIListeners(gitAPI) {
    this._register(gitAPI.onDidOpenRepository((repository) => this.doOpenRepository(repository)));
    this._register(gitAPI.onDidCloseRepository((repository) => this.doCloseRepository(repository)));
    for (const repository of gitAPI.repositories) {
      this.doOpenRepository(repository);
    }
    const stateObs = observableFromEvent(
      this,
      gitAPI.onDidChangeState,
      () => gitAPI.state
    );
    this._register(autorun(async (reader) => {
      const state = stateObs.read(reader);
      if (state !== "initialized") {
        return;
      }
      await Promise.all(gitAPI.repositories.map((repository) => {
        const HEAD = observableFromEvent(this, repository.state.onDidChange, () => repository.state.HEAD);
        return waitForState(HEAD, (state2) => state2 !== void 0, void 0, cancelOnDispose(this._store));
      }));
      this._isInitialized.set(true, void 0);
      this._onDidFinishInitialRepositoryDiscovery.fire();
      this.logService.trace(`[GitServiceImpl] Initial repository discovery finished: ${this.repositories.length} repositories found.`);
    }));
  }
  get isInitialized() {
    return this._isInitialized.get();
  }
  async getRepository(uri) {
    const gitAPI = this.gitExtensionService.getExtensionApi();
    if (!gitAPI) {
      return void 0;
    }
    if (!(uri instanceof vscode10.Uri)) {
      uri = vscode10.Uri.parse(uri.toString());
    }
    let repository = gitAPI.getRepository(uri);
    if (repository) {
      await this.waitForRepositoryState(repository);
      return GitServiceImpl.repoToRepoContext(repository);
    }
    repository = await gitAPI.openRepository(uri);
    if (!repository) {
      return void 0;
    }
    await this.waitForRepositoryState(repository);
    return GitServiceImpl.repoToRepoContext(repository);
  }
  async getRepositoryFetchUrls(uri) {
    this.logService.trace(`[GitServiceImpl][getRepositoryFetchUrls] URI: ${uri.toString()}`);
    const gitAPI = this.gitExtensionService.getExtensionApi();
    if (!gitAPI) {
      return void 0;
    }
    const repository = gitAPI.getRepository(uri);
    if (repository) {
      await this.waitForRepositoryState(repository);
      const remotes = {
        rootUri: repository.rootUri,
        remoteFetchUrls: repository.state.remotes.map((r) => r.fetchUrl)
      };
      this.logService.trace(`[GitServiceImpl][getRepositoryFetchUrls] Remotes (open repository): ${JSON.stringify(remotes)}`);
      return remotes;
    }
    try {
      const uriStat = await vscode10.workspace.fs.stat(uri);
      if (uriStat.type !== vscode10.FileType.Directory) {
        uri = URI.file(dirname(uri.fsPath));
      }
      const repositoryRoot = await gitAPI.getRepositoryRoot(uri);
      if (!repositoryRoot) {
        this.logService.trace(`[GitServiceImpl][getRepositoryFetchUrls] No repository root found`);
        return void 0;
      }
      this.logService.trace(`[GitServiceImpl][getRepositoryFetchUrls] Repository root: ${repositoryRoot.toString()}`);
      const buffer = await vscode10.workspace.fs.readFile(URI.file(join(repositoryRoot.fsPath, ".git", "config")));
      const remotes = {
        rootUri: repositoryRoot,
        remoteFetchUrls: parseGitRemotes(buffer.toString()).map((remote) => remote.fetchUrl)
      };
      this.logService.trace(`[GitServiceImpl][getRepositoryFetchUrls] Remotes (.git/config): ${JSON.stringify(remotes)}`);
      return remotes;
    } catch (error2) {
      this.logService.error(`[GitServiceImpl][getRepositoryFetchUrls] Failed to read remotes from .git/config: ${error2.message}`);
      return void 0;
    }
  }
  async add(uri, paths) {
    const gitAPI = this.gitExtensionService.getExtensionApi();
    const repository = gitAPI?.getRepository(uri);
    await repository?.add(paths);
  }
  async log(uri, options) {
    const gitAPI = this.gitExtensionService.getExtensionApi();
    if (!gitAPI) {
      return void 0;
    }
    const repository = gitAPI.getRepository(uri);
    if (!repository) {
      return void 0;
    }
    return repository.log(options);
  }
  async diffBetween(uri, ref1, ref2) {
    const gitAPI = this.gitExtensionService.getExtensionApi();
    const repository = gitAPI?.getRepository(uri);
    return repository?.diffBetween(ref1, ref2);
  }
  async diffWith(uri, ref) {
    const gitAPI = this.gitExtensionService.getExtensionApi();
    const repository = gitAPI?.getRepository(uri);
    return repository?.diffWith(ref);
  }
  async diffIndexWithHEADShortStats(uri) {
    const gitAPI = this.gitExtensionService.getExtensionApi();
    const repository = gitAPI?.getRepository(uri);
    if (!repository?.diffIndexWithHEADShortStats) {
      return void 0;
    }
    return await repository?.diffIndexWithHEADShortStats();
  }
  async fetch(uri, remote, ref, depth) {
    const gitAPI = this.gitExtensionService.getExtensionApi();
    const repository = gitAPI?.getRepository(uri);
    return repository?.fetch(remote, ref, depth);
  }
  async getMergeBase(uri, ref1, ref2) {
    const gitAPI = this.gitExtensionService.getExtensionApi();
    const repository = gitAPI?.getRepository(uri);
    return repository?.getMergeBase(ref1, ref2);
  }
  async initialize() {
    if (this._isInitialized.get()) {
      return;
    }
    await waitForState(this._isInitialized, (state) => state, void 0, cancelOnDispose(this._store));
  }
  async doOpenRepository(repository) {
    this.logService.trace(`[GitServiceImpl][doOpenRepository] Repository: ${repository.rootUri.toString()}`);
    const HEAD = observableFromEvent(this, repository.state.onDidChange, () => repository.state.HEAD);
    await waitForState(HEAD, (state) => state !== void 0, void 0, cancelOnDispose(this._store));
    this.logService.trace(`[GitServiceImpl][doOpenRepository] Repository initialized: ${JSON.stringify(HEAD.get())}`);
    const selectedObs = observableFromEvent(
      this,
      repository.ui.onDidChange,
      () => repository.ui.selected
    );
    const onDidChangeStateSignal = observableSignalFromEvent(this, repository.state.onDidChange);
    this._register(autorun((reader) => {
      onDidChangeStateSignal.read(reader);
      const selected = selectedObs.read(reader);
      const activeRepository = this.activeRepository.get();
      if (activeRepository && !selected) {
        return;
      }
      const repositoryContext2 = GitServiceImpl.repoToRepoContext(repository);
      this.logService.trace(`[GitServiceImpl][doOpenRepository] Active repository: ${JSON.stringify(repositoryContext2)}`);
      this.activeRepository.set(repositoryContext2, void 0);
    }));
    const repositoryContext = GitServiceImpl.repoToRepoContext(repository);
    if (repositoryContext) {
      this._onDidOpenRepository.fire(repositoryContext);
    }
  }
  doCloseRepository(repository) {
    this.logService.trace(`[GitServiceImpl][doCloseRepository] Repository: ${repository.rootUri.toString()}`);
    const repositoryContext = GitServiceImpl.repoToRepoContext(repository);
    if (repositoryContext) {
      this._onDidCloseRepository.fire(repositoryContext);
    }
  }
  async waitForRepositoryState(repository) {
    if (repository.state.HEAD) {
      return;
    }
    const HEAD = observableFromEvent(this, repository.state.onDidChange, () => repository.state.HEAD);
    await waitForState(HEAD, (state) => state !== void 0, void 0, cancelOnDispose(this._store));
  }
  static repoToRepoContext(repo) {
    if (!repo) {
      return void 0;
    }
    return new RepoContextImpl(repo);
  }
  get repositories() {
    const gitAPI = this.gitExtensionService.getExtensionApi();
    if (!gitAPI) {
      return [];
    }
    return coalesce(gitAPI.repositories.filter((repository) => repository.state.HEAD !== void 0).map((repository) => GitServiceImpl.repoToRepoContext(repository)));
  }
};
GitServiceImpl = __decorateClass([
  __decorateParam(0, IGitExtensionService),
  __decorateParam(1, ILogService)
], GitServiceImpl);
var RepoContextImpl = class {
  constructor(_repo) {
    this._repo = _repo;
    this.rootUri = this._repo.rootUri;
    this.headBranchName = this._repo.state.HEAD?.name;
    this.headCommitHash = this._repo.state.HEAD?.commit;
    this.upstreamBranchName = this._repo.state.HEAD?.upstream?.name;
    this.upstreamRemote = this._repo.state.HEAD?.upstream?.remote;
    this.isRebasing = this._repo.state.rebaseCommit !== null;
    this.remotes = this._repo.state.remotes.map((r) => r.name);
    this.remoteFetchUrls = this._repo.state.remotes.map((r) => r.fetchUrl);
    this.changes = {
      mergeChanges: this._repo.state.mergeChanges,
      indexChanges: this._repo.state.indexChanges,
      workingTree: this._repo.state.workingTreeChanges,
      untrackedChanges: this._repo.state.untrackedChanges
    };
    this._onDidChangeSignal = observableSignalFromEvent(this, this._repo.state.onDidChange);
    this.headBranchNameObs = this._onDidChangeSignal.map(() => this._repo.state.HEAD?.name);
    this.headCommitHashObs = this._onDidChangeSignal.map(() => this._repo.state.HEAD?.commit);
    this.upstreamBranchNameObs = this._onDidChangeSignal.map(() => this._repo.state.HEAD?.upstream?.name);
    this.upstreamRemoteObs = this._onDidChangeSignal.map(() => this._repo.state.HEAD?.upstream?.remote);
    this.isRebasingObs = this._onDidChangeSignal.map(() => this._repo.state.rebaseCommit !== null);
    this._checkIsIgnored = new BatchedProcessor(async (paths) => {
      const result = await this._repo.checkIgnore(paths);
      return paths.map((p) => result.has(p));
    }, 1e3);
    this._isIgnored = new CachedFunction(async (documentUri) => {
      const path = import_vscode6.Uri.parse(documentUri).fsPath;
      const result = await this._checkIsIgnored.request(path);
      return result;
    });
  }
  isIgnored(uri) {
    return this._isIgnored.get(uri.toString());
  }
};

// src/platform/github/common/githubAPI.ts
async function makeGitHubAPIRequest(fetcherService, logService, telemetry, host, routeSlug, method, token, body, version2, type = "json", userAgent2, returnStatusCodeOnError = false) {
  const headers = {
    "Accept": "application/vnd.github+json"
  };
  if (token) {
    headers["Authorization"] = `Bearer ${token}`;
  }
  if (version2) {
    headers["X-GitHub-Api-Version"] = version2;
  }
  if (userAgent2) {
    headers["User-Agent"] = userAgent2;
  }
  const response = await fetcherService.fetch(`${host}/${routeSlug}`, {
    method,
    headers,
    body: body ? JSON.stringify(body) : void 0
  });
  if (!response.ok) {
    logService.error(`[GitHubAPI] ${method} ${host}/${routeSlug} - Status: ${response?.status}`);
    if (returnStatusCodeOnError) {
      return { status: response.status };
    }
    return void 0;
  }
  try {
    const result = type === "json" ? await response.json() : await response.text();
    const rateLimit = Number(response.headers.get("x-ratelimit-remaining"));
    const logMessage = `[RateLimit] REST rate limit remaining: ${rateLimit}, ${routeSlug}`;
    if (rateLimit < 1e3) {
      logService.warn(logMessage);
      telemetry.sendMSFTTelemetryEvent("githubAPI.approachingRateLimit", { rateLimit: rateLimit.toString() });
    } else {
      logService.debug(logMessage);
    }
    return result;
  } catch {
    return void 0;
  }
}
async function makeGitHubGraphQLRequest(fetcherService, logService, telemetry, host, query, token, variables) {
  const headers = {
    "Accept": "application/vnd.github+json",
    "Content-Type": "application/json"
  };
  if (token) {
    headers["Authorization"] = `Bearer ${token}`;
  }
  const body = JSON.stringify({
    query,
    variables
  });
  const response = await fetcherService.fetch(`${host}/graphql`, {
    method: "POST",
    headers,
    body
  });
  if (!response.ok) {
    return void 0;
  }
  try {
    const result = await response.json();
    const rateLimit = Number(response.headers.get("x-ratelimit-remaining"));
    const logMessage = `[RateLimit] GraphQL rate limit remaining: ${rateLimit}, query: ${query}`;
    if (rateLimit < 1e3) {
      logService.warn(logMessage);
      telemetry.sendMSFTTelemetryEvent("githubAPI.approachingRateLimit", { rateLimit: rateLimit.toString() });
    } else {
      logService.debug(logMessage);
    }
    return result;
  } catch {
    return void 0;
  }
}
async function makeSearchGraphQLRequest(fetcherService, logService, telemetry, host, token, searchQuery, first = 20) {
  const query = `
		query FetchCopilotAgentPullRequests($searchQuery: String!, $first: Int!, $after: String) {
			search(query: $searchQuery, type: ISSUE, first: $first, after: $after) {
				nodes {
					... on PullRequest {
						number
						id
						fullDatabaseId
						headRefOid
						baseRefOid
						title
						state
						url
						createdAt
						updatedAt
						additions
						deletions
						files {
							totalCount
						}
						author {
							login
						}
						repository {
							owner {
								login
							}
							name
						}
						body
					}
				}
				pageInfo {
					hasNextPage
					endCursor
				}
				issueCount
			}
		}
	`;
  logService.debug(`[FolderRepositoryManager+0] Fetch pull request category ${searchQuery}`);
  const variables = {
    searchQuery,
    first
  };
  const result = await makeGitHubGraphQLRequest(fetcherService, logService, telemetry, host, query, token, variables);
  return result ? result.data.search.nodes : [];
}
async function getPullRequestFromGlobalId(fetcherService, logService, telemetry, host, token, globalId) {
  const query = `
		query GetPullRequestGlobal($globalId: ID!) {
			node(id: $globalId) {
				... on PullRequest {
					number
					id
					fullDatabaseId
					headRefOid
					baseRefOid
					title
					state
					url
					createdAt
					updatedAt
					additions
					deletions
					files {
						totalCount
					}
					author {
						login
					}
					repository {
						owner {
							login
						}
						name
					}
					body
				}
			}
		}
	`;
  logService.debug(`[GitHubAPI] Fetch pull request by global ID ${globalId}`);
  const variables = {
    globalId
  };
  const result = await makeGitHubGraphQLRequest(fetcherService, logService, telemetry, host, query, token, variables);
  return result?.data?.node;
}
async function addPullRequestCommentGraphQLRequest(fetcherService, logService, telemetry, host, token, pullRequestId, commentBody) {
  const mutation = `
		mutation AddPullRequestComment($pullRequestId: ID!, $body: String!) {
			addComment(input: {subjectId: $pullRequestId, body: $body}) {
				commentEdge {
					node {
						id
						body
						createdAt
						author {
							login
						}
						url
					}
				}
			}
		}
	`;
  logService.debug(`[GitHubAPI] Adding comment to pull request ${pullRequestId}`);
  const variables = {
    pullRequestId,
    body: commentBody
  };
  const result = await makeGitHubGraphQLRequest(fetcherService, logService, telemetry, host, mutation, token, variables);
  return result?.data?.addComment?.commentEdge?.node || null;
}
async function closePullRequest(fetcherService, logService, telemetry, host, token, owner, repo, pullNumber) {
  logService.debug(`[GitHubAPI] Closing pull request ${owner}/${repo}#${pullNumber}`);
  const result = await makeGitHubAPIRequest(
    fetcherService,
    logService,
    telemetry,
    host,
    `repos/${owner}/${repo}/pulls/${pullNumber}`,
    "POST",
    token,
    { state: "closed" },
    "2022-11-28"
  );
  const success = result?.state === "closed";
  if (success) {
    logService.debug(`[GitHubAPI] Successfully closed pull request ${owner}/${repo}#${pullNumber}`);
  } else {
    logService.error(`[GitHubAPI] Failed to close pull request ${owner}/${repo}#${pullNumber}. Its state is ${result?.state}`);
  }
  return success;
}
async function makeGitHubAPIRequestWithPagination(fetcherService, logService, host, path, nwo, token) {
  let hasNextPage = false;
  const sessionInfos = [];
  const page_size = 20;
  let page = 1;
  do {
    const response = await fetcherService.fetch(
      `${host}/${path}?page_size=${page_size}&page_number=${page}&resource_state=draft,open&repo_nwo=${nwo}`,
      {
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: "application/json"
        }
      }
    );
    if (!response.ok) {
      logService.error(`[GitHubAPI] Failed to fetch sessions: ${response.status} ${response.statusText}`);
      return sessionInfos;
    }
    const sessions = await response.json();
    sessionInfos.push(...sessions.sessions);
    hasNextPage = sessions.sessions.length === page_size;
    page++;
  } while (hasNextPage);
  return sessionInfos;
}

// src/platform/github/common/githubService.ts
var IGithubRepositoryService = createDecorator("IGithubRepositoryService");
var IOctoKitService = createDecorator("IOctoKitService");
var BaseOctoKitService = class {
  constructor(_capiClientService, _fetcherService, _logService, _telemetryService) {
    this._capiClientService = _capiClientService;
    this._fetcherService = _fetcherService;
    this._logService = _logService;
    this._telemetryService = _telemetryService;
  }
  async getCurrentAuthedUserWithToken(token) {
    return this._makeGHAPIRequest("user", "GET", token);
  }
  async getTeamMembershipWithToken(teamId, token, username) {
    return this._makeGHAPIRequest(`teams/${teamId}/memberships/${username}`, "GET", token);
  }
  async _makeGHAPIRequest(routeSlug, method, token, body) {
    return makeGitHubAPIRequest(this._fetcherService, this._logService, this._telemetryService, this._capiClientService.dotcomAPIURL, routeSlug, method, token, body, "2022-11-28");
  }
  async getCopilotPullRequestForUserWithToken(owner, repo, user, token) {
    const query = `repo:${owner}/${repo} is:open author:copilot-swe-agent[bot] involves:${user}`;
    return makeSearchGraphQLRequest(this._fetcherService, this._logService, this._telemetryService, this._capiClientService.dotcomAPIURL, token, query);
  }
  async getCopilotSessionsForPRWithToken(prId, token) {
    return makeGitHubAPIRequest(this._fetcherService, this._logService, this._telemetryService, "https://api.githubcopilot.com", `agents/sessions/resource/pull/${prId}`, "GET", token);
  }
  async getSessionLogsWithToken(sessionId, token) {
    return makeGitHubAPIRequest(this._fetcherService, this._logService, this._telemetryService, "https://api.githubcopilot.com", `agents/sessions/${sessionId}/logs`, "GET", token, void 0, void 0, "text");
  }
  async getSessionInfoWithToken(sessionId, token) {
    return makeGitHubAPIRequest(this._fetcherService, this._logService, this._telemetryService, "https://api.githubcopilot.com", `agents/sessions/${sessionId}`, "GET", token, void 0, void 0, "text");
  }
  async postCopilotAgentJobWithToken(owner, name, apiVersion, userAgent2, payload, token) {
    return makeGitHubAPIRequest(this._fetcherService, this._logService, this._telemetryService, "https://api.githubcopilot.com", `agents/swe/${apiVersion}/jobs/${owner}/${name}`, "POST", token, payload, void 0, void 0, userAgent2, true);
  }
  async getJobByJobIdWithToken(owner, repo, jobId, userAgent2, token) {
    return makeGitHubAPIRequest(this._fetcherService, this._logService, this._telemetryService, "https://api.githubcopilot.com", `agents/swe/v1/jobs/${owner}/${repo}/${jobId}`, "GET", token, void 0, void 0, void 0, userAgent2);
  }
  async getJobBySessionIdWithToken(owner, repo, sessionId, userAgent2, token) {
    return makeGitHubAPIRequest(this._fetcherService, this._logService, this._telemetryService, "https://api.githubcopilot.com", `agents/swe/v1/jobs/${owner}/${repo}/session/${sessionId}`, "GET", token, void 0, void 0, void 0, userAgent2);
  }
  async addPullRequestCommentWithToken(pullRequestId, commentBody, token) {
    return addPullRequestCommentGraphQLRequest(this._fetcherService, this._logService, this._telemetryService, this._capiClientService.dotcomAPIURL, token, pullRequestId, commentBody);
  }
  async getAllOpenSessionsWithToken(nwo, token) {
    return makeGitHubAPIRequestWithPagination(this._fetcherService, this._logService, `https://api.githubcopilot.com`, "agents/sessions", nwo, token);
  }
  async getPullRequestFromSessionWithToken(globalId, token) {
    return getPullRequestFromGlobalId(this._fetcherService, this._logService, this._telemetryService, this._capiClientService.dotcomAPIURL, token, globalId);
  }
  async getCustomAgentsWithToken(owner, repo, token) {
    const queryParams = "?exclude_invalid_config=true";
    return makeGitHubAPIRequest(this._fetcherService, this._logService, this._telemetryService, "https://api.githubcopilot.com", `agents/swe/custom-agents/${owner}/${repo}${queryParams}`, "GET", token, void 0, void 0, "json", "vscode-copilot-chat");
  }
  async getPullRequestFilesWithToken(owner, repo, pullNumber, token) {
    const result = await makeGitHubAPIRequest(this._fetcherService, this._logService, this._telemetryService, this._capiClientService.dotcomAPIURL, `repos/${owner}/${repo}/pulls/${pullNumber}/files`, "GET", token, void 0, "2022-11-28");
    return result || [];
  }
  async closePullRequestWithToken(owner, repo, pullNumber, token) {
    return closePullRequest(this._fetcherService, this._logService, this._telemetryService, this._capiClientService.dotcomAPIURL, token, owner, repo, pullNumber);
  }
  async getFileContentWithToken(owner, repo, ref, path, token) {
    const route = `repos/${owner}/${repo}/contents/${path}?ref=${encodeURIComponent(ref)}`;
    const response = await makeGitHubAPIRequest(this._fetcherService, this._logService, this._telemetryService, this._capiClientService.dotcomAPIURL, route, "GET", token, void 0);
    if (!response || Array.isArray(response)) {
      throw new Error("Unable to fetch file content");
    }
    const typedResponse = response;
    if (typedResponse.content && typedResponse.encoding === "base64") {
      return decodeBase64(typedResponse.content.replace(/\n/g, "")).toString();
    }
    if (typedResponse.sha) {
      const blob = await this.getBlobContentWithToken(owner, repo, typedResponse.sha, token);
      if (blob) {
        return blob;
      }
    }
    this._logService.error(`Failed to get file content for ${owner}/${repo}/${path} at ref ${ref}`);
    return "";
  }
  async getBlobContentWithToken(owner, repo, sha, token) {
    const blobRoute = `repos/${owner}/${repo}/git/blobs/${sha}`;
    const blobResponse = await makeGitHubAPIRequest(this._fetcherService, this._logService, this._telemetryService, this._capiClientService.dotcomAPIURL, blobRoute, "GET", token, void 0, "2022-11-28");
    if (!blobResponse || Array.isArray(blobResponse)) {
      return void 0;
    }
    const typedBlob = blobResponse;
    if (typedBlob.content && typedBlob.encoding === "base64") {
      return decodeBase64(typedBlob.content.replace(/\n/g, "")).toString();
    }
    return void 0;
  }
};

// src/platform/github/common/nullOctokitServiceImpl.ts
var NullBaseOctoKitService = class extends BaseOctoKitService {
  async getCurrentAuthedUserWithToken(token) {
    return { avatar_url: "", login: "NullUser", name: "Null User" };
  }
  async getTeamMembershipWithToken(teamId, token, username) {
    return void 0;
  }
  async _makeGHAPIRequest(routeSlug, method, token, body) {
    return void 0;
  }
};

// src/platform/github/common/octoKitServiceImpl.ts
var OctoKitService = class extends BaseOctoKitService {
  constructor(_authService, capiClientService, fetcherService, logService, telemetryService) {
    super(capiClientService, fetcherService, logService, telemetryService);
    this._authService = _authService;
  }
  async getCurrentAuthedUser() {
    const authToken = (await this._authService.getAnyGitHubSession())?.accessToken;
    if (!authToken) {
      return void 0;
    }
    return await this.getCurrentAuthedUserWithToken(authToken);
  }
  async getCopilotPullRequestsForUser(owner, repo) {
    const auth = await this._authService.getPermissiveGitHubSession({ createIfNone: true });
    if (!auth?.accessToken) {
      return [];
    }
    const response = await this.getCopilotPullRequestForUserWithToken(
      owner,
      repo,
      auth.account.label,
      auth.accessToken
    );
    return response;
  }
  async getCopilotSessionsForPR(prId) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      return [];
    }
    const response = await this.getCopilotSessionsForPRWithToken(
      prId,
      authToken
    );
    const { sessions } = response;
    return sessions;
  }
  async getSessionLogs(sessionId) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      return "";
    }
    const response = await this.getSessionLogsWithToken(
      sessionId,
      authToken
    );
    return response;
  }
  async getSessionInfo(sessionId) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      throw new Error("No authentication token available");
    }
    const response = await this.getSessionInfoWithToken(
      sessionId,
      authToken
    );
    if (typeof response === "string") {
      return JSON.parse(response);
    }
    return response;
  }
  async postCopilotAgentJob(owner, name, apiVersion, payload) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      throw new Error("No authentication token available");
    }
    return this.postCopilotAgentJobWithToken(owner, name, apiVersion, "vscode-copilot-chat", payload, authToken);
  }
  async getJobByJobId(owner, repo, jobId, userAgent2) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      throw new Error("No authentication token available");
    }
    return this.getJobByJobIdWithToken(owner, repo, jobId, userAgent2, authToken);
  }
  async getJobBySessionId(owner, repo, sessionId, userAgent2) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      throw new Error("No authentication token available");
    }
    return this.getJobBySessionIdWithToken(owner, repo, sessionId, userAgent2, authToken);
  }
  async addPullRequestComment(pullRequestId, commentBody) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      throw new Error("No authentication token available");
    }
    return this.addPullRequestCommentWithToken(pullRequestId, commentBody, authToken);
  }
  async getAllOpenSessions(nwo) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      return [];
    }
    return this.getAllOpenSessionsWithToken(nwo, authToken);
  }
  async getPullRequestFromGlobalId(globalId) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      throw new Error("No authentication token available");
    }
    return this.getPullRequestFromSessionWithToken(globalId, authToken);
  }
  async getCustomAgents(owner, repo) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      return [];
    }
    const { agents } = await this.getCustomAgentsWithToken(owner, repo, authToken);
    if (!Array.isArray(agents)) {
      return [];
    }
    return agents;
  }
  async getPullRequestFiles(owner, repo, pullNumber) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      return [];
    }
    return this.getPullRequestFilesWithToken(owner, repo, pullNumber, authToken);
  }
  async closePullRequest(owner, repo, pullNumber) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      return false;
    }
    return this.closePullRequestWithToken(owner, repo, pullNumber, authToken);
  }
  async getFileContent(owner, repo, ref, path) {
    const authToken = (await this._authService.getPermissiveGitHubSession({ createIfNone: true }))?.accessToken;
    if (!authToken) {
      throw new Error("No GitHub authentication available");
    }
    return this.getFileContentWithToken(owner, repo, ref, path, authToken);
  }
};
OctoKitService = __decorateClass([
  __decorateParam(0, IAuthenticationService),
  __decorateParam(1, ICAPIClientService),
  __decorateParam(2, IFetcherService2),
  __decorateParam(3, ILogService),
  __decorateParam(4, ITelemetryService)
], OctoKitService);

// src/platform/interactive/common/interactiveSessionService.ts
var IInteractiveSessionService = createDecorator("IInteractiveSessionService");

// src/platform/interactive/vscode/interactiveSessionServiceImpl.ts
var import_vscode7 = require("vscode");
var InteractiveSessionServiceImpl = class {
  transferActiveChat(workspaceUri) {
    import_vscode7.interactive.transferActiveChat(workspaceUri);
  }
};

// src/platform/languages/common/languageDiagnosticsService.ts
var ILanguageDiagnosticsService = createDecorator("ILanguageDiagnosticService");
var AbstractLanguageDiagnosticsService = class {
  waitForNewDiagnostics(resource, token, timeout2 = 5e3) {
    let onCancellationRequest;
    let diagnosticsChangeListener;
    let timer;
    return new Promise((resolve2) => {
      onCancellationRequest = token.onCancellationRequested(() => resolve2([]));
      timer = setTimeout(() => resolve2(this.getDiagnostics(resource)), timeout2);
      diagnosticsChangeListener = this.onDidChangeDiagnostics((e) => {
        for (const uri of e.uris) {
          if (isEqual(uri, resource)) {
            resolve2(this.getDiagnostics(resource));
            break;
          }
        }
      });
    }).finally(() => {
      onCancellationRequest.dispose();
      diagnosticsChangeListener.dispose();
      clearTimeout(timer);
    });
  }
};

// src/platform/languages/common/languageFeaturesService.ts
var ILanguageFeaturesService = createDecorator("ILanguageFeaturesService");

// src/platform/languages/vscode/languageDiagnosticsServiceImpl.ts
var vscode11 = __toESM(require("vscode"));
var LanguageDiagnosticsServiceImpl = class _LanguageDiagnosticsServiceImpl extends AbstractLanguageDiagnosticsService {
  constructor() {
    super(...arguments);
    this.onDidChangeDiagnostics = vscode11.languages.onDidChangeDiagnostics;
  }
  static {
    this.ignoredSchemes = /* @__PURE__ */ new Set(["git", "chat-editing-snapshot-text-model", "chat-editing-text-model"]);
  }
  getDiagnostics(resource) {
    return vscode11.languages.getDiagnostics(resource);
  }
  getAllDiagnostics() {
    return vscode11.languages.getDiagnostics().filter(([uri]) => !_LanguageDiagnosticsServiceImpl.ignoredSchemes.has(uri.scheme));
  }
};

// src/platform/languages/vscode/languageFeaturesServicesImpl.ts
var vscode12 = __toESM(require("vscode"));
var LanguageFeaturesServiceImpl = class {
  constructor() {
  }
  async getDefinitions(uri, position) {
    return await vscode12.commands.executeCommand("vscode.executeDefinitionProvider", uri, position);
  }
  async getImplementations(uri, position) {
    return await vscode12.commands.executeCommand("vscode.executeImplementationProvider", uri, position);
  }
  async getReferences(uri, position) {
    return await vscode12.commands.executeCommand("vscode.executeReferenceProvider", uri, position);
  }
  async getWorkspaceSymbols(query) {
    return await vscode12.commands.executeCommand("vscode.executeWorkspaceSymbolProvider", query);
  }
  async getDocumentSymbols(uri) {
    return await vscode12.commands.executeCommand("vscode.executeDocumentSymbolProvider", uri);
  }
  getDiagnostics(uri) {
    return vscode12.languages.getDiagnostics(uri);
  }
};

// src/platform/log/vscode/outputChannelLogTarget.ts
var import_vscode8 = require("vscode");
var outputChannel;
var OutputChannelName = "GitHub Copilot Chat";
var NewOutputChannelLogTarget = class {
  constructor(extensionContext) {
    this._outputChannel = import_vscode8.window.createOutputChannel(OutputChannelName, { log: true });
    outputChannel = this._outputChannel;
    extensionContext.subscriptions.push(this._outputChannel);
  }
  logIt(level, metadataStr, ...extra) {
    switch (level) {
      case import_vscode8.LogLevel.Trace:
        this._outputChannel.trace(metadataStr);
        break;
      case import_vscode8.LogLevel.Debug:
        this._outputChannel.debug(metadataStr);
        break;
      case import_vscode8.LogLevel.Info:
        this._outputChannel.info(metadataStr);
        break;
      case import_vscode8.LogLevel.Warning:
        this._outputChannel.warn(metadataStr);
        break;
      case import_vscode8.LogLevel.Error:
        this._outputChannel.error(metadataStr);
        break;
    }
  }
  show(preserveFocus) {
    this._outputChannel.show(preserveFocus);
  }
};

// src/platform/multiFileEdit/common/editLogService.ts
var IEditLogService = createDecorator("IEditLogService");
var EditLogService = class {
  constructor(_vscodeExtensionContext, _fileSystemService, _configurationService, _logService) {
    this._vscodeExtensionContext = _vscodeExtensionContext;
    this._fileSystemService = _fileSystemService;
    this._configurationService = _configurationService;
    this._logService = _logService;
    this.LOG_DIR = URI.joinPath(this._vscodeExtensionContext.globalStorageUri, "editRecordings");
    this._edits = /* @__PURE__ */ new Map();
  }
  _isEnabled() {
    return this._configurationService.getConfig(ConfigKey.AdvancedExperimental.EditRecordingEnabled);
  }
  logEditChatRequest(turnId, prompt, response) {
    if (!this._isEnabled()) {
      return;
    }
    const entry = this._edits.get(turnId) ?? { prompt, response, edits: [] };
    entry.prompt = prompt;
    entry.response = response;
    this._edits.set(turnId, entry);
  }
  logSpeculationRequest(turnId, uri, prompt, originalContent, editedContent) {
    if (!this._isEnabled()) {
      return;
    }
    const entry = this._edits.get(turnId) ?? { prompt: [], response: "", edits: [] };
    entry.edits.push({
      uri: uri.toString(),
      prompt,
      originalContent,
      editedContent
    });
    this._edits.set(turnId, entry);
  }
  async getEditLog(turnId) {
    if (!this._isEnabled()) {
      return;
    }
    try {
      const data = await this._fileSystemService.readFile(URI.joinPath(this.LOG_DIR, `${turnId}.json`));
      const log = JSON.parse(data.toString());
      return log.edits.map((edit) => ({ prompt: edit.prompt, response: edit.editedContent }));
    } catch {
    }
  }
  async markCompleted(turnId, outcome) {
    if (!this._isEnabled()) {
      return;
    }
    const edit = this._edits.get(turnId);
    if (!edit) {
      return;
    }
    if (edit.edits.length) {
      const path = URI.joinPath(this.LOG_DIR, `${turnId}.json`);
      this._logService.debug(`Edit recording: ${path.toString()}`);
      await this._fileSystemService.writeFile(path, VSBuffer.fromString(JSON.stringify(edit, void 0, 4)).buffer);
    }
    this._edits.delete(turnId);
  }
};
EditLogService = __decorateClass([
  __decorateParam(0, IVSCodeExtensionContext),
  __decorateParam(1, IFileSystemService),
  __decorateParam(2, IConfigurationService),
  __decorateParam(3, ILogService)
], EditLogService);

// src/platform/multiFileEdit/common/multiFileEditQualityTelemetry.ts
init_lifecycle();
init_map();

// src/platform/notebook/common/notebookService.ts
var INotebookService = createDecorator("INotebookService");

// src/platform/multiFileEdit/common/multiFileEditQualityTelemetry.ts
var IMultiFileEditInternalTelemetryService = createDecorator("IMultiFileEditInternalTelemetryService");
var MultiFileEditInternalTelemetryService = class extends Disposable {
  constructor(telemetryService, workspaceService, notebookService, logService, alternativeNotebookContent, chatSessionService) {
    super();
    this.telemetryService = telemetryService;
    this.workspaceService = workspaceService;
    this.notebookService = notebookService;
    this.logService = logService;
    this.alternativeNotebookContent = alternativeNotebookContent;
    this.chatSessionService = chatSessionService;
    // URI -> chatResponseId -> edits
    this.editedFiles = new ResourceMap();
    // sessionId -> (URI -> TextDocument | NotebookDocument)
    this.editedDocuments = /* @__PURE__ */ new Map();
    this._register(this.chatSessionService.onDidDisposeChatSession((sessionId) => {
      this.editedDocuments.delete(sessionId);
    }));
  }
  storeEditPrompt(edit, telemetryOptions) {
    this.logService.debug(`Storing edit prompt for ${edit.uri.toString()} with request ID ${telemetryOptions.chatRequestId}`);
    const existingEditsForUri = this.editedFiles.get(edit.uri) ?? /* @__PURE__ */ new Map();
    const existingEditsForUriInRequest = existingEditsForUri.get(telemetryOptions.chatRequestId) ?? [];
    existingEditsForUriInRequest.push({ ...edit, ...telemetryOptions });
    existingEditsForUri.set(telemetryOptions.chatRequestId, existingEditsForUriInRequest);
    this.editedFiles.set(edit.uri, existingEditsForUri);
    if (edit.document && telemetryOptions.chatSessionId) {
      let sessionMap = this.editedDocuments.get(telemetryOptions.chatSessionId);
      if (!sessionMap) {
        sessionMap = new ResourceMap();
        this.editedDocuments.set(telemetryOptions.chatSessionId, sessionMap);
      }
      sessionMap.set(edit.uri, edit.document);
    }
  }
  async sendEditPromptAndResult(telemetry, uri, outcome) {
    const editsForUri = this.editedFiles.get(uri);
    if (!editsForUri) {
      return;
    }
    if (editsForUri.size > 1) {
      this.logService.debug(`Skipping telemetry for ${uri.toString()} with request ID ${telemetry.chatRequestId} due to multiple edit turns`);
      this.editedFiles.delete(uri);
      return;
    }
    const editsForUriInChatRequest = editsForUri.get(telemetry.chatRequestId);
    if (!editsForUriInChatRequest) {
      return;
    }
    if (editsForUriInChatRequest.length > 1) {
      this.logService.debug(`Skipping telemetry for ${uri.toString()} with request ID ${telemetry.chatRequestId} due to multiple edits in one turn`);
      this.editedFiles.delete(uri);
      return;
    }
    try {
      const edit = editsForUriInChatRequest[0];
      let languageId = void 0;
      let documentText = void 0;
      if (edit.chatSessionId) {
        const editedDocument = this.editedDocuments.get(edit.chatSessionId)?.get(uri);
        if (editedDocument && "getText" in editedDocument) {
          languageId = editedDocument.languageId;
          documentText = editedDocument.getText();
        }
      }
      if (!documentText && !languageId) {
        if (this.notebookService.hasSupportedNotebooks(uri)) {
          const snapshot = await this.workspaceService.openNotebookDocumentAndSnapshot(uri, this.alternativeNotebookContent.getFormat(void 0));
          languageId ??= snapshot.languageId;
          documentText ??= snapshot.getText();
        } else {
          const textDocument = await this.workspaceService.openTextDocument(uri);
          languageId = textDocument.languageId;
          documentText = textDocument.getText();
        }
      }
      this.telemetryService.sendInternalMSFTTelemetryEvent(
        "multiFileEditQuality",
        {
          requestId: telemetry.chatRequestId,
          speculationRequestId: edit.speculationRequestId,
          // NOTE: for now this will always be false because in agent mode the edits are invoked via the MappedEditsProvider, so we lose the turn ID
          isAgent: String(edit.isAgent),
          outcome,
          prompt: edit.prompt,
          languageId,
          file: documentText,
          // Note that this is not necessarily the same as the model output because the user may have made manual edits
          mapper: edit.mapper
        },
        {
          isNotebook: this.notebookService.hasSupportedNotebooks(uri) ? 1 : 0
        }
      );
      const gitHubEnhancedTelemetryProperties = multiplexProperties({
        headerRequestId: edit.speculationRequestId,
        providerId: edit.mapper,
        languageId,
        messageText: edit.prompt,
        suggestion: outcome,
        completionTextJson: documentText,
        // Note that this is not necessarily the same as the model output because the user may have made manual edits
        conversationId: edit.chatSessionId,
        messageId: edit.chatRequestId
      });
      this.telemetryService.sendEnhancedGHTelemetryEvent("fastApply/editOutcome", gitHubEnhancedTelemetryProperties);
      this.logService.debug(`Sent telemetry for ${uri.toString()} with request ID ${edit.chatRequestId}, SD request ID ${edit.speculationRequestId}, and outcome ${outcome}`);
    } catch (e) {
      this.logService.error("Error sending multi-file edit telemetry", JSON.stringify(e));
    } finally {
      this.editedFiles.delete(uri);
    }
  }
};
MultiFileEditInternalTelemetryService = __decorateClass([
  __decorateParam(0, ITelemetryService),
  __decorateParam(1, IWorkspaceService),
  __decorateParam(2, INotebookService),
  __decorateParam(3, ILogService),
  __decorateParam(4, IAlternativeNotebookContentService),
  __decorateParam(5, IChatSessionService)
], MultiFileEditInternalTelemetryService);

// src/platform/notebook/common/alternativeContentEditGenerator.ts
init_uint();

// src/platform/notebook/common/notebookDiff.ts
function computeDiff(originalModel, modifiedModel, cellChanges) {
  const cellDiffInfo = [];
  let originalCellIndex = 0;
  let modifiedCellIndex = 0;
  for (let i = 0; i < cellChanges.length; i++) {
    const change = cellChanges[i];
    for (let j = 0; j < change.original.startLineNumber - 1 - originalCellIndex; j++) {
      cellDiffInfo.push({
        originalCellIndex: originalCellIndex + j,
        modifiedCellIndex: modifiedCellIndex + j,
        type: "unchanged"
      });
    }
    const modifiedLCS = computeModifiedLCS(originalModel, modifiedModel, change);
    cellDiffInfo.push(...modifiedLCS);
    originalCellIndex = change.original.startLineNumber - 1 + change.original.length;
    modifiedCellIndex = change.modified.startLineNumber - 1 + change.modified.length;
  }
  for (let i = originalCellIndex; i < originalModel.length; i++) {
    cellDiffInfo.push({
      originalCellIndex: i,
      modifiedCellIndex: i - originalCellIndex + modifiedCellIndex,
      type: "unchanged"
    });
  }
  return cellDiffInfo;
}
function computeModifiedLCS(original, modified, change) {
  const result = [];
  const modifiedLen = Math.min(change.original.length, change.modified.length);
  for (let j = 0; j < modifiedLen; j++) {
    const originalCell = original[change.original.startLineNumber - 1 + j];
    const modifiedCell = modified[change.modified.startLineNumber - 1 + j];
    if (originalCell !== modifiedCell) {
      result.push({
        originalCellIndex: change.original.startLineNumber - 1 + j,
        type: "delete"
      });
      result.push({
        modifiedCellIndex: change.modified.startLineNumber - 1 + j,
        type: "insert"
      });
    } else {
      result.push({
        originalCellIndex: change.original.startLineNumber - 1 + j,
        modifiedCellIndex: change.modified.startLineNumber - 1 + j,
        type: "unchanged"
      });
    }
  }
  for (let j = modifiedLen; j < change.original.length; j++) {
    result.push({
      originalCellIndex: change.original.startLineNumber - 1 + j,
      type: "delete"
    });
  }
  for (let j = modifiedLen; j < change.modified.length; j++) {
    result.push({
      modifiedCellIndex: change.modified.startLineNumber - 1 + j,
      type: "insert"
    });
  }
  return result;
}

// src/platform/notebook/common/alternativeContentEditGenerator.ts
var IAlternativeNotebookContentEditGenerator = createDecorator("IAlternativeNotebookContentEditGenerator");
var AlternativeNotebookContentEditGenerator = class {
  constructor(alternativeContentService, diffService, logger, telemetryService) {
    this.alternativeContentService = alternativeContentService;
    this.diffService = diffService;
    this.logger = logger;
    this.telemetryService = telemetryService;
  }
  getFormat(firstLine) {
    const firstChar = firstLine.trim().substring(0, 1);
    const format6 = firstChar === "{" ? "json" : firstChar === "<" ? "xml" : "text";
    return format6;
  }
  /**
   * Given a NotebookDocument or Uri, and a cell kind, return the EOL for the new cell.
   * If the notebook is empty, then return the default EOL.
   * Else default to the EOL of the first cell of the given kind.
   * This way we have a consistent EOL for new cells (matching existing cells).
   */
  getEOLForNewCell(notebookOrUri, cellKind) {
    const eolInExistingCodeCell = isUri(notebookOrUri) ? void 0 : notebookOrUri.getCells().find((c) => c.kind === cellKind)?.document.eol ?? void 0;
    return eolInExistingCodeCell ? eolInExistingCodeCell === EndOfLine2.LF ? "\n" : "\r\n" : EOL;
  }
  /**
   * Given a stream of lines for the alternative content, generate the corresponding edits to apply to the notebook document.
   * We accept a NotebookDocument or a Uri.
   * This is because its possible the Notebook may not have been created/loaded as of yet.
   * I.e. for new Notebooks, we can emity the Insert Cell Edits without the notebook being created.
   */
  async *generateNotebookEdits(notebookOrUri, lines, telemetryOptions, token) {
    lines = typeof lines === "string" ? textToAsyncIterableLines(lines) : lines;
    const firstNonEmptyLinePromise = new DeferredPromise();
    lines = readFirstNonEmptyLineAndKeepStreaming(lines, firstNonEmptyLinePromise);
    const firstNonEmptyLine = (await firstNonEmptyLinePromise.p).value;
    const format6 = this.getFormat(firstNonEmptyLine);
    const linesCollected = [];
    lines = collectWhileStreaming(lines, linesCollected);
    const isEmptyNotebook = isUri(notebookOrUri) || notebookOrUri.cellCount === 0;
    let notebookEditEmitted = false;
    let cellTextEditEmitted = false;
    for await (const edit of this.generateNotebookEditsImpl(notebookOrUri, lines, format6, token)) {
      notebookEditEmitted = notebookEditEmitted || !Array.isArray(edit);
      if (Array.isArray(edit)) {
        cellTextEditEmitted = true;
      }
      yield edit;
    }
    if (isEmptyNotebook || !isUri(notebookOrUri)) {
      if (!notebookEditEmitted && format6 === "text" && linesCollected.length && !lineMightHaveCellMarker(firstNonEmptyLine)) {
        const uri = isUri(notebookOrUri) ? notebookOrUri : notebookOrUri.uri;
        if (isJupyterNotebookUri(uri)) {
          const eolForNewCell = this.getEOLForNewCell(notebookOrUri, NotebookCellKind2.Code);
          const cellData = new NotebookCellData2(NotebookCellKind2.Code, linesCollected.join(eolForNewCell), "python");
          yield NotebookEdit2.insertCells(0, [cellData]);
          this.logger.info(`No new cells were emitted for ${uri.toString()}. Emitting a new cell with the contents of the code.`);
        } else {
          this.logger.warn(`No new cells were emitted for ${uri.toString()}`);
        }
      }
    }
    (async () => {
      const model = await Promise.resolve(telemetryOptions?.model).catch(() => void 0);
      this.telemetryService.sendMSFTTelemetryEvent("notebook.editGeneration", {
        requestId: telemetryOptions?.requestId,
        requestSource: telemetryOptions?.source,
        model,
        inputFormat: format6
      }, {
        isEmptyNotebook: isEmptyNotebook ? 1 : 0,
        isNotebookOrUri: isUri(notebookOrUri) ? 0 : 1,
        isJupyterNotebookUri: isJupyterNotebookUri(isUri(notebookOrUri) ? notebookOrUri : notebookOrUri.uri) ? 1 : 0,
        isEditEmitted: notebookEditEmitted ? 1 : 0,
        isCellTextEditEmitted: cellTextEditEmitted ? 1 : 0,
        sourceLength: linesCollected.length
      });
    })();
  }
  async *generateNotebookEditsImpl(notebookOrUri, lines, format6, token) {
    const provider = this.alternativeContentService.create(format6);
    const isEmptyNotebook = isUri(notebookOrUri) || notebookOrUri.cellCount === 0;
    const isNotebookAvailable = !isUri(notebookOrUri);
    const cellIdMap = isNotebookAvailable ? getCellIdMap(notebookOrUri) : /* @__PURE__ */ new Map();
    const cellInfo = {
      index: -1,
      lines: [],
      language: "markdown",
      ended: false
    };
    const cellsSeen = /* @__PURE__ */ new WeakSet();
    function getCellIdOfNewCell(cell) {
      const hash = new StringSHA1();
      hash.update(cell.index.toString());
      return hash.digest().substring(0, 8);
    }
    const expectedCells = [];
    const original = isUri(notebookOrUri) ? [] : notebookOrUri.getCells().map((cell) => ({ id: getCellId(cell), uri: cell.document.uri }));
    const allLines = [];
    lines = collectWhileStreaming(lines, allLines);
    let editsEmitted = false;
    for await (const line of provider.parseAlternateContent(notebookOrUri, lines, token)) {
      if (token.isCancellationRequested) {
        break;
      }
      if (line.type === "start") {
        const expectedCell = {
          index: line.index,
          language: line.language || "markdown",
          lines: [],
          cell: line.id ? cellIdMap.get(line.id) : void 0
        };
        expectedCells.push(expectedCell);
        cellInfo.ended = false;
        cellInfo.insertEdit = void 0;
        cellInfo.index = expectedCell.index;
        cellInfo.lines = expectedCell.lines;
        cellInfo.language = expectedCell.language;
        cellInfo.cell = expectedCell.cell;
        if (cellInfo.cell) {
          cellsSeen.add(cellInfo.cell);
        }
      } else if (line.type === "end") {
        cellInfo.ended = true;
        const doc = cellInfo.cell?.document;
        if (!cellInfo.insertEdit && !cellInfo.cell && !cellInfo.lines.length) {
          const cellData = new NotebookCellData2(cellInfo.language === "markdown" ? NotebookCellKind2.Markup : NotebookCellKind2.Code, "", cellInfo.language);
          const insertEdit = NotebookEdit2.insertCells(cellInfo.index, [cellData]);
          yield insertEdit;
          editsEmitted = true;
          original.splice(cellInfo.index, 0, { id: getCellIdOfNewCell(cellInfo) });
        } else if (cellInfo.insertEdit && !cellInfo.cell) {
          const existingCell = !isEmptyNotebook && isNotebookAvailable && cellInfo.index < notebookOrUri.cellCount ? notebookOrUri.cellAt(cellInfo.index) : void 0;
          if (existingCell && existingCell.document.getText() === cellInfo.insertEdit.newCells[0].value) {
            cellsSeen.add(existingCell);
            expectedCells[expectedCells.length - 1].cell = existingCell;
            const doc2 = existingCell.document;
            for (let i = 0; i < doc2.lineCount; i++) {
              const line2 = doc2.lineAt(i);
              yield [doc2.uri, [new TextEdit3(new Range3(i, 0, i, 1073741824 /* MAX_SAFE_SMALL_INTEGER */), line2.text)]];
              editsEmitted = true;
            }
          } else {
            yield cellInfo.insertEdit;
            editsEmitted = true;
            original.splice(cellInfo.index, 0, { id: getCellIdOfNewCell(cellInfo) });
          }
        } else if (cellInfo.lines.length && doc && cellInfo.lines.length < doc.lineCount) {
          const range = new Range3(cellInfo.lines.length - 1, cellInfo.lines.slice(-1)[0].length, doc.lineCount - 1, doc.lineAt(doc.lineCount - 1).text.length);
          yield [doc.uri, [new TextEdit3(range, "")]];
        }
      } else if (line.type === "line" && !cellInfo.ended) {
        cellInfo.lines.push(line.line);
        if (cellInfo.cell) {
          if (cellInfo.lines.length > cellInfo.cell.document.lineCount) {
            const range = new Range3(cellInfo.lines.length - 1, 0, cellInfo.lines.length - 1, 0);
            const eol = cellInfo.cell.document.eol === EndOfLine2.LF ? "\n" : "\r\n";
            const newText = `${eol}${line.line}`;
            yield [cellInfo.cell.document.uri, [new TextEdit3(range, newText)]];
          } else {
            const lineIndex = cellInfo.lines.length - 1;
            yield [cellInfo.cell.document.uri, [new TextEdit3(new Range3(lineIndex, 0, lineIndex, 1073741824 /* MAX_SAFE_SMALL_INTEGER */), line.line)]];
          }
          editsEmitted = true;
        } else if (cellInfo.insertEdit) {
          const eolForNewCell = this.getEOLForNewCell(notebookOrUri, cellInfo.insertEdit.newCells[0].kind);
          cellInfo.insertEdit.newCells[0].value = cellInfo.lines.join(eolForNewCell);
        } else {
          const cellData = new NotebookCellData2(cellInfo.language === "markdown" ? NotebookCellKind2.Markup : NotebookCellKind2.Code, line.line, cellInfo.language);
          cellInfo.insertEdit = NotebookEdit2.insertCells(cellInfo.index, [cellData]);
        }
      }
    }
    if (isEmptyNotebook || !isNotebookAvailable) {
      return;
    }
    if (!editsEmitted && allLines.length) {
      this.logger.warn(`No edits generated for notebook ${notebookOrUri.uri.toString()}. This is likely due to an invalid format. Expected format: ${format6}. Provided content as follows:

${allLines.join("\n")}`);
      return;
    }
    const modified = expectedCells.map((cell) => cell.cell ? getCellId(cell.cell) : getCellIdOfNewCell(cell));
    for (const missingCell of original.filter((cell) => cell.uri && !modified.includes(cell.id)).reverse()) {
      const cell = cellIdMap.get(missingCell.id);
      if (cell) {
        const index = original.indexOf(missingCell);
        yield NotebookEdit2.deleteCells(new NotebookRange2(index, index + 1));
        original.splice(index, 1);
      }
    }
    const result = await this.diffService.computeDiff(original.map((c) => c.id).join(EOL), modified.join(EOL), { computeMoves: false, ignoreTrimWhitespace: true, maxComputationTimeMs: 5e3 });
    const diffResult = computeDiff(original.map((i) => i.id), modified, result.changes);
    if (diffResult.every((d) => d.type === "unchanged")) {
      return;
    }
    for (const change of diffResult.filter((d) => d.type === "delete").reverse()) {
      yield NotebookEdit2.deleteCells(new NotebookRange2(change.originalCellIndex, change.originalCellIndex + 1));
    }
    for (const change of diffResult.filter((d) => d.type === "insert")) {
      const expectedCell = expectedCells[change.modifiedCellIndex];
      const kind = expectedCell.language === "markdown" ? NotebookCellKind2.Markup : NotebookCellKind2.Code;
      const eolForNewCell = this.getEOLForNewCell(notebookOrUri, kind);
      const source = expectedCell.lines.join(eolForNewCell);
      const cellData = new NotebookCellData2(kind, source, expectedCell.language);
      yield NotebookEdit2.insertCells(expectedCell.index, [cellData]);
    }
  }
};
AlternativeNotebookContentEditGenerator = __decorateClass([
  __decorateParam(0, IAlternativeNotebookContentService),
  __decorateParam(1, IDiffService),
  __decorateParam(2, ILogService),
  __decorateParam(3, ITelemetryService)
], AlternativeNotebookContentEditGenerator);
function textToAsyncIterableLines(text2) {
  const source = new AsyncIterableSource();
  source.emitOne(text2);
  source.resolve();
  return streamLines(source.asyncIterable);
}
function streamLines(source) {
  return new AsyncIterableObject(async (emitter) => {
    let buffer = "";
    for await (const str of source) {
      buffer += str;
      do {
        const newlineIndex = buffer.indexOf("\n");
        if (newlineIndex === -1) {
          break;
        }
        const line = buffer.substring(0, newlineIndex);
        buffer = buffer.substring(newlineIndex + 1);
        emitter.emitOne(new LineOfText(line));
      } while (true);
    }
    if (buffer.length > 0) {
      emitter.emitOne(new LineOfText(buffer));
    }
  });
}
function readFirstNonEmptyLineAndKeepStreaming(source, firstNonEmptyLine) {
  return new AsyncIterableObject(async (emitter) => {
    for await (const line of source) {
      if (!firstNonEmptyLine.isSettled && line.value.trim().length) {
        firstNonEmptyLine.complete(line);
      }
      emitter.emitOne(line);
    }
    if (!firstNonEmptyLine.isSettled) {
      firstNonEmptyLine.complete(new LineOfText(""));
    }
  });
}
function collectWhileStreaming(source, lines) {
  return new AsyncIterableObject(async (emitter) => {
    for await (const line of source) {
      lines.push(line.value);
      emitter.emitOne(line);
    }
  });
}

// src/platform/notebook/common/notebookSummaryTracker.ts
var INotebookSummaryTracker = createDecorator("INotebookSummaryTracker");

// src/platform/notebook/vscode/notebookServiceImpl.ts
var import_vscode10 = require("vscode");

// src/platform/notebook/vscode/notebookExectionServiceImpl.ts
var import_vscode9 = require("vscode");
init_event();
var NotebookExecutionServiceImpl = class {
  constructor() {
    this._onDidChangeNotebookCellExecutionStateEmitter = new Emitter();
    this.onDidChangeNotebookCellExecutionState = this._onDidChangeNotebookCellExecutionStateEmitter.event;
    this._disposables = [];
    // track cell in execution
    this._cellExecution = /* @__PURE__ */ new WeakMap();
    this._disposables.push(import_vscode9.workspace.onDidChangeNotebookDocument((e) => {
      for (const cellChange of e.cellChanges) {
        if (cellChange.executionSummary) {
          const executionSummary = cellChange.executionSummary;
          if (executionSummary.success === void 0) {
            if (!this._cellExecution.has(cellChange.cell)) {
              this._cellExecution.set(cellChange.cell, true);
              this._onDidChangeNotebookCellExecutionStateEmitter.fire({ cell: cellChange.cell, state: 2 /* Executing */ });
            }
          } else {
            this._cellExecution.delete(cellChange.cell);
            this._onDidChangeNotebookCellExecutionStateEmitter.fire({ cell: cellChange.cell, state: 1 /* Idle */ });
          }
        }
      }
    }));
  }
  dispose() {
    this._disposables.forEach((d) => d.dispose());
  }
};

// src/platform/notebook/vscode/notebookServiceImpl.ts
var NOTEBOOK_AGENT_USAGE_KEY = "puku.notebookAgentModeUsage";
var NotebookService = class {
  constructor(_configurationService, _experimentationService, _workspaceService, _logger) {
    this._configurationService = _configurationService;
    this._experimentationService = _experimentationService;
    this._workspaceService = _workspaceService;
    this._logger = _logger;
    this._cellExecution = /* @__PURE__ */ new Map();
    this._cellSymbols = /* @__PURE__ */ new WeakMap();
    this._executionService = new NotebookExecutionServiceImpl();
    this._disposables = [];
    this._isVariableFilteringEnabled = false;
    this._notebookEditorContribInitFlag = false;
    this._notebookEditorContributions = [];
    this.followExecutionState = false;
    this._isVariableFilteringEnabled = this._experimentationService.getTreatmentVariable("copilotchat.notebookVariableFiltering") || this._configurationService.getConfig(ConfigKey.AdvancedExperimental.NotebookVariableFilteringEnabled);
    this._registerExecutionListener();
  }
  get isVariableFilteringEnabled() {
    return this._isVariableFilteringEnabled;
  }
  _hasJupyterExtension() {
    return import_vscode10.extensions.getExtension("ms-toolsai.jupyter")?.isActive;
  }
  trackAgentUsage() {
    import_vscode10.commands.executeCommand("setContext", NOTEBOOK_AGENT_USAGE_KEY, true);
  }
  setFollowState(state) {
    this.followExecutionState = state;
  }
  getFollowState() {
    return this.followExecutionState;
  }
  async getVariables(notebook) {
    if (!this._hasJupyterExtension()) {
      try {
        const results = await import_vscode10.commands.executeCommand("vscode.executeNotebookVariableProvider", notebook);
        if (results && Array.isArray(results)) {
          const variableResults = results.map(this._convertResult);
          return this._filterVariables(notebook, variableResults);
        }
        return [];
      } catch (_ex) {
        this._logger.error(`Failed to get notebook variables (vscode.executeNotebookVariableProvider) for ${notebook.toString()}: ${_ex}`);
        return [];
      }
    }
    try {
      const results = await import_vscode10.commands.executeCommand("jupyter.listVariables", notebook);
      if (results && Array.isArray(results)) {
        const variableResults = results.map(this._convertResult);
        return this._filterVariables(notebook, variableResults);
      }
      return [];
    } catch (_ex) {
      this._logger.error(`Failed to get notebook variables (jupyter.listVariables) for ${notebook.toString()}: ${_ex}`);
      return [];
    }
  }
  _convertResult(result) {
    if ("variable" in result) {
      return result;
    } else {
      return {
        variable: result,
        hasNamedChildren: false,
        indexedChildrenCount: 0
      };
    }
  }
  _filterVariables(notebook, variables) {
    if (!this.isVariableFilteringEnabled) {
      return variables;
    }
    const symbolNames = /* @__PURE__ */ new Set();
    findNotebook(notebook, import_vscode10.workspace.notebookDocuments)?.getCells().forEach((cell) => {
      const cellSymbols = this._cellSymbols.get(cell);
      if (cellSymbols) {
        cellSymbols.forEach((symbol) => symbolNames.add(symbol.name));
      }
    });
    return variables.filter((v) => symbolNames.has(v.variable.name));
  }
  async getPipPackages(notebook) {
    if (!this._hasJupyterExtension()) {
      return [];
    }
    try {
      const packages = await import_vscode10.commands.executeCommand("jupyter.listPipPackages", notebook);
      return packages;
    } catch (_ex) {
      this._logger.error(`Failed to get pip packages (jupyter.listPipPackages) for ${notebook.toString()}: ${_ex}`);
      return [];
    }
  }
  setVariables(notebook, variables) {
  }
  //#region Notebook Support
  populateNotebookEditorContributions() {
    const notebookContributions = [];
    const exts = import_vscode10.extensions.all;
    for (const extension of exts) {
      const contrib = extension.packageJSON.contributes?.notebooks;
      if (Array.isArray(contrib)) {
        notebookContributions.push(...contrib);
      }
    }
    for (const contrib of notebookContributions) {
      if (isNotebookEditorContribution(contrib)) {
        this._notebookEditorContributions.push(contrib);
      }
    }
  }
  hasSupportedNotebooks(uri) {
    if (!this._notebookEditorContribInitFlag) {
      this.populateNotebookEditorContributions();
      this._notebookEditorContribInitFlag = true;
    }
    const editorAssociationObjects = this._configurationService.getNonExtensionConfig("workbench.editorAssociations");
    const validatedEditorAssociations = extractEditorAssociation(editorAssociationObjects ?? {});
    const res = _hasSupportedNotebooks(uri, this._workspaceService.notebookDocuments, this._notebookEditorContributions, validatedEditorAssociations);
    return res;
  }
  //#endregion
  //#region Execution Summary
  _registerExecutionListener() {
    this._disposables.push(this._executionService.onDidChangeNotebookCellExecutionState((e) => {
      const cell = e.cell;
      const notebookUri = cell.notebook.uri;
      const notebookUriString = notebookUri.toString();
      let cellExecutionList = this._cellExecution.get(notebookUriString);
      if (!cellExecutionList) {
        cellExecutionList = [];
        this._cellExecution.set(notebookUriString, cellExecutionList);
      }
      const index = cellExecutionList.findIndex((item) => item.cell === cell);
      if (index !== -1) {
        cellExecutionList.splice(index, 1);
      }
      cellExecutionList.push({ cell, executionCount: cell.executionSummary?.executionOrder });
    }));
    this._disposables.push(import_vscode10.workspace.onDidChangeNotebookDocument((e) => {
      if (!this.isVariableFilteringEnabled) {
        return;
      }
      for (const cellChange of e.cellChanges) {
        if (cellChange.executionSummary) {
          const executionSummary = cellChange.executionSummary;
          if (executionSummary.success) {
            import_vscode10.commands.executeCommand(
              "vscode.executeDocumentSymbolProvider",
              cellChange.cell.document.uri
            ).then((symbols) => {
              this._cellSymbols.set(cellChange.cell, symbols || []);
            });
          }
        }
        if (cellChange.document) {
          this._cellSymbols.delete(cellChange.cell);
        }
      }
      for (const contentChange of e.contentChanges) {
        contentChange.removedCells.forEach((cell) => {
          this._cellSymbols.delete(cell);
        });
      }
    }));
  }
  getCellExecutions(notebook) {
    return this._cellExecution.get(notebook.toString())?.map((e) => e.cell) || [];
  }
  async runCells(notebookUri, range, autoReveal) {
    await import_vscode10.commands.executeCommand("notebook.cell.execute", {
      ranges: [range],
      document: notebookUri,
      autoReveal
    });
  }
  async ensureKernelSelected(notebookUri) {
    if (import_vscode10.window.visibleNotebookEditors.find((editor) => editor.notebook.uri.toString() === notebookUri.toString())) {
      await import_vscode10.commands.executeCommand("notebook.selectKernel", {
        notebookUri,
        skipIfAlreadySelected: true
      });
    }
  }
  //#endregion
  dispose() {
    this._disposables.forEach((d) => d.dispose());
  }
};
NotebookService = __decorateClass([
  __decorateParam(0, IConfigurationService),
  __decorateParam(1, IExperimentationService),
  __decorateParam(2, IWorkspaceService),
  __decorateParam(3, ILogService)
], NotebookService);

// src/platform/notebook/vscode/notebookSummaryTrackerImpl.ts
init_lifecycle();
var NotebookSummaryTrackerImpl = class extends DisposableStore {
  constructor(workspaceService, vsCodeExtensionContext) {
    super();
    this.workspaceService = workspaceService;
    this.trackedNotebooks = /* @__PURE__ */ new WeakSet();
    this.notebooksWithChanges = /* @__PURE__ */ new WeakSet();
    vsCodeExtensionContext.subscriptions.push(this);
    this.add(this.workspaceService.onDidChangeNotebookDocument((e) => {
      if (!this.trackedNotebooks.has(e.notebook)) {
        return;
      }
      if (e.contentChanges.length) {
        this.notebooksWithChanges.add(e.notebook);
      }
      if (e.cellChanges.some((c) => c.executionSummary)) {
        this.notebooksWithChanges.add(e.notebook);
      }
    }));
  }
  trackNotebook(notebook) {
    this.trackedNotebooks.add(notebook);
  }
  clearState(notebook) {
    this.notebooksWithChanges.delete(notebook);
  }
  listNotebooksWithChanges() {
    return this.workspaceService.notebookDocuments.filter((notebook) => this.notebooksWithChanges.has(notebook));
  }
};
NotebookSummaryTrackerImpl = __decorateClass([
  __decorateParam(0, IWorkspaceService),
  __decorateParam(1, IVSCodeExtensionContext)
], NotebookSummaryTrackerImpl);

// src/platform/notification/common/notificationService.ts
init_cancellation();
var NullNotificationService = class {
  showInformationMessage(message, optionsOrItem, ...items) {
    return Promise.resolve(void 0);
  }
  showWarningMessage(message, ...items) {
    return Promise.resolve(void 0);
  }
  showQuotaExceededDialog(options) {
    return Promise.resolve();
  }
  withProgress(options, task) {
    return Promise.resolve(task({ report: () => {
    } }, CancellationToken.None));
  }
};
var INotificationService = createDecorator("INotificationService");

// src/platform/notification/vscode/notificationServiceImpl.ts
var import_vscode11 = require("vscode");
var NotificationService = class {
  async showInformationMessage(message, optionsOrItem, ...items) {
    if (typeof optionsOrItem === "object" && optionsOrItem !== null && !Array.isArray(optionsOrItem)) {
      return import_vscode11.window.showInformationMessage(message, optionsOrItem, ...items);
    }
    return import_vscode11.window.showInformationMessage(message, optionsOrItem, ...items);
  }
  async withProgress(options, task) {
    return import_vscode11.window.withProgress(options, task);
  }
  async showWarningMessage(message, ...items) {
    return import_vscode11.window.showWarningMessage(message, ...items);
  }
  async showQuotaExceededDialog(options) {
    return import_vscode11.commands.executeCommand(options.isNoAuthUser ? "workbench.action.chat.triggerSetup" : "workbench.action.chat.openQuotaExceededDialog");
  }
};

// src/platform/open/common/opener.ts
var IUrlOpener = createDecorator("IUrlOpener");
var NullUrlOpener = class {
  constructor() {
    this.openedUrls = [];
  }
  open(target) {
    this.openedUrls.push(target);
  }
};

// src/platform/open/vscode/opener.ts
var vscode13 = __toESM(require("vscode"));
var RealUrlOpener = class {
  async open(target) {
    await vscode13.commands.executeCommand("vscode.open", vscode13.Uri.parse(target));
  }
};

// src/platform/projectTemplatesIndex/common/projectTemplatesIndex.ts
var IProjectTemplatesIndex = createDecorator("IProjectTemplatesIndex");
var ProjectTemplatesIndex = class {
  constructor(useRemoteCache = true, envService, instantiationService) {
    this._isIndexLoaded = false;
    const cacheVersion = sanitizeVSCodeVersion(envService.getEditorInfo().version);
    this.embeddingsCache = useRemoteCache ? instantiationService.createInstance(RemoteEmbeddingsCache, 1 /* GLOBAL */, "projectTemplateEmbeddings", cacheVersion, EmbeddingType.text3small_512, "project-templates" /* ProjectTemplates */) : instantiationService.createInstance(LocalEmbeddingsCache, 1 /* GLOBAL */, "projectTemplateEmbeddings", cacheVersion, EmbeddingType.text3small_512);
  }
  async updateIndex() {
    if (this._isIndexLoaded) {
      return;
    }
    this._isIndexLoaded = true;
    this._embeddings = await this.embeddingsCache.getCache();
  }
  async nClosestValues(embedding, n) {
    await this.updateIndex();
    if (!this._embeddings) {
      return [];
    }
    return rankEmbeddings(embedding, this._embeddings.filter((x) => x.embedding).map((item) => [`${item.key} `, { type: this.embeddingsCache.embeddingType, value: item.embedding }]), n).map((x) => x.value);
  }
};
ProjectTemplatesIndex = __decorateClass([
  __decorateParam(1, IEnvService),
  __decorateParam(2, IInstantiationService)
], ProjectTemplatesIndex);

// src/util/vs/workbench/contrib/chat/common/promptSyntax/promptFileParser.ts
init_iterator();
init_strings();

// src/util/vs/base/common/yaml.ts
function parse5(input, errors2 = [], options = {}) {
  const lines = input.length === 0 ? [] : input.split(/\r\n|\n/);
  const parser = new YamlParser(lines, errors2, options);
  return parser.parse();
}
function createPosition(line, character) {
  return { line, character };
}
function createStringNode(value, start, end) {
  return { type: "string", value, start, end };
}
function createNumberNode(value, start, end) {
  return { type: "number", value, start, end };
}
function createBooleanNode(value, start, end) {
  return { type: "boolean", value, start, end };
}
function createNullNode(start, end) {
  return { type: "null", value: null, start, end };
}
function createObjectNode(properties, start, end) {
  return { type: "object", start, end, properties };
}
function createArrayNode(items, start, end) {
  return { type: "array", start, end, items };
}
function isWhitespace(char) {
  return char === " " || char === "	";
}
function isValidNumber(value) {
  return /^-?\d*\.?\d+$/.test(value);
}
var YamlLexer = class {
  constructor(lines) {
    this.currentLine = 0;
    this.currentChar = 0;
    this.lines = lines;
  }
  getCurrentPosition() {
    return createPosition(this.currentLine, this.currentChar);
  }
  getCurrentLineNumber() {
    return this.currentLine;
  }
  getCurrentCharNumber() {
    return this.currentChar;
  }
  getCurrentLineText() {
    return this.currentLine < this.lines.length ? this.lines[this.currentLine] : "";
  }
  savePosition() {
    return { line: this.currentLine, char: this.currentChar };
  }
  restorePosition(pos) {
    this.currentLine = pos.line;
    this.currentChar = pos.char;
  }
  isAtEnd() {
    return this.currentLine >= this.lines.length;
  }
  getCurrentChar() {
    if (this.isAtEnd() || this.currentChar >= this.lines[this.currentLine].length) {
      return "";
    }
    return this.lines[this.currentLine][this.currentChar];
  }
  peek(offset = 1) {
    const newChar = this.currentChar + offset;
    if (this.currentLine >= this.lines.length || newChar >= this.lines[this.currentLine].length) {
      return "";
    }
    return this.lines[this.currentLine][newChar];
  }
  advance() {
    const char = this.getCurrentChar();
    if (this.currentChar >= this.lines[this.currentLine].length && this.currentLine < this.lines.length - 1) {
      this.currentLine++;
      this.currentChar = 0;
    } else {
      this.currentChar++;
    }
    return char;
  }
  advanceLine() {
    this.currentLine++;
    this.currentChar = 0;
  }
  skipWhitespace() {
    while (!this.isAtEnd() && this.currentChar < this.lines[this.currentLine].length && isWhitespace(this.getCurrentChar())) {
      this.advance();
    }
  }
  skipToEndOfLine() {
    this.currentChar = this.lines[this.currentLine].length;
  }
  getIndentation() {
    if (this.isAtEnd()) {
      return 0;
    }
    let indent = 0;
    for (let i = 0; i < this.lines[this.currentLine].length; i++) {
      if (this.lines[this.currentLine][i] === " ") {
        indent++;
      } else if (this.lines[this.currentLine][i] === "	") {
        indent += 4;
      } else {
        break;
      }
    }
    return indent;
  }
  moveToNextNonEmptyLine() {
    while (this.currentLine < this.lines.length) {
      if (this.currentChar < this.lines[this.currentLine].length) {
        const remainingLine = this.lines[this.currentLine].substring(this.currentChar).trim();
        if (remainingLine.length > 0 && !remainingLine.startsWith("#")) {
          this.skipWhitespace();
          return;
        }
      }
      this.currentLine++;
      this.currentChar = 0;
      if (this.currentLine < this.lines.length) {
        const line = this.lines[this.currentLine].trim();
        if (line.length > 0 && !line.startsWith("#")) {
          this.skipWhitespace();
          return;
        }
      }
    }
  }
};
var YamlParser = class {
  constructor(lines, errors2, options) {
    // Track nesting level of flow (inline) collections '[' ']' '{' '}'
    this.flowLevel = 0;
    this.lexer = new YamlLexer(lines);
    this.errors = errors2;
    this.options = options;
  }
  addError(message, code2, start, end) {
    this.errors.push({ message, code: code2, start, end });
  }
  parseValue(expectedIndent) {
    this.lexer.skipWhitespace();
    if (this.lexer.isAtEnd()) {
      const pos = this.lexer.getCurrentPosition();
      return createStringNode("", pos, pos);
    }
    const char = this.lexer.getCurrentChar();
    if (char === '"' || char === `'`) {
      return this.parseQuotedString(char);
    }
    if (char === "[") {
      return this.parseInlineArray();
    }
    if (char === "{") {
      return this.parseInlineObject();
    }
    return this.parseUnquotedValue();
  }
  parseQuotedString(quote) {
    const start = this.lexer.getCurrentPosition();
    this.lexer.advance();
    let value = "";
    while (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== "" && this.lexer.getCurrentChar() !== quote) {
      value += this.lexer.advance();
    }
    if (this.lexer.getCurrentChar() === quote) {
      this.lexer.advance();
    }
    const end = this.lexer.getCurrentPosition();
    return createStringNode(value, start, end);
  }
  parseUnquotedValue() {
    const start = this.lexer.getCurrentPosition();
    let value = "";
    let endPos = start;
    const isTerminator = (char) => {
      if (char === "#") {
        return true;
      }
      if (this.flowLevel > 0 && (char === "," || char === "]" || char === "}")) {
        return true;
      }
      return false;
    };
    const firstChar = this.lexer.getCurrentChar();
    if (firstChar === '"' || firstChar === `'`) {
      value += this.lexer.advance();
      endPos = this.lexer.getCurrentPosition();
      while (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== "") {
        const char = this.lexer.getCurrentChar();
        if (char === firstChar || isTerminator(char)) {
          break;
        }
        value += this.lexer.advance();
        endPos = this.lexer.getCurrentPosition();
      }
    } else {
      while (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== "") {
        const char = this.lexer.getCurrentChar();
        if (isTerminator(char)) {
          break;
        }
        value += this.lexer.advance();
        endPos = this.lexer.getCurrentPosition();
      }
    }
    const trimmed = value.trimEnd();
    const diff2 = value.length - trimmed.length;
    if (diff2) {
      endPos = createPosition(start.line, endPos.character - diff2);
    }
    const finalValue = firstChar === '"' || firstChar === `'` ? trimmed.substring(1) : trimmed;
    return this.createValueNode(finalValue, start, endPos);
  }
  createValueNode(value, start, end) {
    if (value === "") {
      return createStringNode("", start, start);
    }
    if (value === "true") {
      return createBooleanNode(true, start, end);
    }
    if (value === "false") {
      return createBooleanNode(false, start, end);
    }
    if (value === "null" || value === "~") {
      return createNullNode(start, end);
    }
    const numberValue = Number(value);
    if (!isNaN(numberValue) && isFinite(numberValue) && isValidNumber(value)) {
      return createNumberNode(numberValue, start, end);
    }
    return createStringNode(value, start, end);
  }
  parseInlineArray() {
    const start = this.lexer.getCurrentPosition();
    this.lexer.advance();
    this.flowLevel++;
    const items = [];
    while (!this.lexer.isAtEnd()) {
      this.lexer.skipWhitespace();
      if (this.lexer.getCurrentChar() === "]") {
        this.lexer.advance();
        break;
      }
      if (this.lexer.getCurrentChar() === "") {
        this.lexer.advanceLine();
        continue;
      }
      if (this.lexer.getCurrentChar() === "#") {
        this.lexer.skipToEndOfLine();
        this.lexer.advanceLine();
        continue;
      }
      const positionBefore = this.lexer.savePosition();
      const item = this.parseValue();
      if (!(item.type === "string" && item.value === "" && item.start.line === item.end.line && item.start.character === item.end.character)) {
        items.push(item);
      }
      const positionAfter = this.lexer.savePosition();
      if (positionBefore.line === positionAfter.line && positionBefore.char === positionAfter.char) {
        if (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== "") {
          this.lexer.advance();
        } else {
          break;
        }
      }
      this.lexer.skipWhitespace();
      if (this.lexer.getCurrentChar() === ",") {
        this.lexer.advance();
      }
    }
    const end = this.lexer.getCurrentPosition();
    this.flowLevel--;
    return createArrayNode(items, start, end);
  }
  parseInlineObject() {
    const start = this.lexer.getCurrentPosition();
    this.lexer.advance();
    this.flowLevel++;
    const properties = [];
    while (!this.lexer.isAtEnd()) {
      this.lexer.skipWhitespace();
      if (this.lexer.getCurrentChar() === "}") {
        this.lexer.advance();
        break;
      }
      if (this.lexer.getCurrentChar() === "#") {
        this.lexer.skipToEndOfLine();
        this.lexer.advanceLine();
        continue;
      }
      const positionBefore = this.lexer.savePosition();
      const keyStart = this.lexer.getCurrentPosition();
      let keyValue = "";
      if (this.lexer.getCurrentChar() === '"' || this.lexer.getCurrentChar() === `'`) {
        const quote = this.lexer.getCurrentChar();
        this.lexer.advance();
        while (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== "" && this.lexer.getCurrentChar() !== quote) {
          keyValue += this.lexer.advance();
        }
        if (this.lexer.getCurrentChar() === quote) {
          this.lexer.advance();
        }
      } else {
        while (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== "" && this.lexer.getCurrentChar() !== ":") {
          keyValue += this.lexer.advance();
        }
      }
      keyValue = keyValue.trim();
      const keyEnd = this.lexer.getCurrentPosition();
      const key = createStringNode(keyValue, keyStart, keyEnd);
      this.lexer.skipWhitespace();
      if (this.lexer.getCurrentChar() === ":") {
        this.lexer.advance();
      }
      this.lexer.skipWhitespace();
      const value = this.parseValue();
      properties.push({ key, value });
      const positionAfter = this.lexer.savePosition();
      if (positionBefore.line === positionAfter.line && positionBefore.char === positionAfter.char) {
        if (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== "") {
          this.lexer.advance();
        } else {
          break;
        }
      }
      this.lexer.skipWhitespace();
      if (this.lexer.getCurrentChar() === ",") {
        this.lexer.advance();
      }
    }
    const end = this.lexer.getCurrentPosition();
    this.flowLevel--;
    return createObjectNode(properties, start, end);
  }
  parseBlockArray(baseIndent) {
    const start = this.lexer.getCurrentPosition();
    const items = [];
    while (!this.lexer.isAtEnd()) {
      this.lexer.moveToNextNonEmptyLine();
      if (this.lexer.isAtEnd()) {
        break;
      }
      const currentIndent = this.lexer.getIndentation();
      if (currentIndent < baseIndent) {
        break;
      }
      this.lexer.skipWhitespace();
      if (this.lexer.getCurrentChar() === "-") {
        this.lexer.advance();
        this.lexer.skipWhitespace();
        const itemStart = this.lexer.getCurrentPosition();
        if (this.lexer.getCurrentChar() === "" || this.lexer.getCurrentChar() === "#") {
          this.lexer.advanceLine();
          if (!this.lexer.isAtEnd()) {
            const nextIndent = this.lexer.getIndentation();
            if (nextIndent > currentIndent) {
              this.lexer.skipWhitespace();
              if (this.lexer.getCurrentChar() === "-") {
                const nestedArray = this.parseBlockArray(nextIndent);
                items.push(nestedArray);
              } else {
                const currentLine = this.lexer.getCurrentLineText();
                const currentPos = this.lexer.getCurrentCharNumber();
                const remainingLine = currentLine.substring(currentPos);
                if (remainingLine.includes(":") && !remainingLine.trim().startsWith("#")) {
                  const nestedObject = this.parseBlockObject(nextIndent, this.lexer.getCurrentCharNumber());
                  items.push(nestedObject);
                } else {
                  items.push(createStringNode("", itemStart, itemStart));
                }
              }
            } else {
              items.push(createStringNode("", itemStart, itemStart));
            }
          } else {
            items.push(createStringNode("", itemStart, itemStart));
          }
        } else {
          const currentLine = this.lexer.getCurrentLineText();
          const currentPos = this.lexer.getCurrentCharNumber();
          const remainingLine = currentLine.substring(currentPos);
          const hasColon = remainingLine.includes(":");
          if (hasColon) {
            const item = this.parseBlockObject(itemStart.character, itemStart.character);
            items.push(item);
          } else {
            const item = this.parseValue();
            items.push(item);
            while (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== "" && this.lexer.getCurrentChar() !== "#") {
              this.lexer.advance();
            }
            this.lexer.advanceLine();
          }
        }
      } else {
        break;
      }
    }
    let end = start;
    if (items.length > 0) {
      const lastItem = items[items.length - 1];
      end = lastItem.end;
    } else {
      end = createPosition(start.line, start.character + 1);
    }
    return createArrayNode(items, start, end);
  }
  parseBlockObject(baseIndent, baseCharPosition) {
    const start = this.lexer.getCurrentPosition();
    const properties = [];
    const localKeysSeen = /* @__PURE__ */ new Set();
    const fromCurrentPosition = baseCharPosition !== void 0;
    let firstIteration = true;
    while (!this.lexer.isAtEnd()) {
      if (!firstIteration || !fromCurrentPosition) {
        this.lexer.moveToNextNonEmptyLine();
      }
      firstIteration = false;
      if (this.lexer.isAtEnd()) {
        break;
      }
      const currentIndent = this.lexer.getIndentation();
      if (fromCurrentPosition) {
        this.lexer.skipWhitespace();
        const currentCharPosition = this.lexer.getCurrentCharNumber();
        if (currentCharPosition < baseCharPosition) {
          break;
        }
      } else {
        if (currentIndent < baseIndent) {
          break;
        }
        if (currentIndent > baseIndent) {
          const lineStart = createPosition(this.lexer.getCurrentLineNumber(), 0);
          const lineEnd = createPosition(this.lexer.getCurrentLineNumber(), this.lexer.getCurrentLineText().length);
          this.addError("Unexpected indentation", "indentation", lineStart, lineEnd);
          this.lexer.skipWhitespace();
        } else {
          this.lexer.skipWhitespace();
        }
      }
      const keyStart = this.lexer.getCurrentPosition();
      let keyValue = "";
      while (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== "" && this.lexer.getCurrentChar() !== ":") {
        keyValue += this.lexer.advance();
      }
      keyValue = keyValue.trim();
      const keyEnd = this.lexer.getCurrentPosition();
      const key = createStringNode(keyValue, keyStart, keyEnd);
      if (!this.options.allowDuplicateKeys && localKeysSeen.has(keyValue)) {
        this.addError(`Duplicate key '${keyValue}'`, "duplicateKey", keyStart, keyEnd);
      }
      localKeysSeen.add(keyValue);
      if (this.lexer.getCurrentChar() === ":") {
        this.lexer.advance();
      }
      this.lexer.skipWhitespace();
      let value;
      const valueStart = this.lexer.getCurrentPosition();
      if (this.lexer.getCurrentChar() === "" || this.lexer.getCurrentChar() === "#") {
        this.lexer.advanceLine();
        if (!this.lexer.isAtEnd()) {
          const nextIndent = this.lexer.getIndentation();
          if (nextIndent > currentIndent) {
            this.lexer.skipWhitespace();
            if (this.lexer.getCurrentChar() === "-") {
              value = this.parseBlockArray(nextIndent);
            } else {
              const currentLine = this.lexer.getCurrentLineText();
              const currentPos = this.lexer.getCurrentCharNumber();
              const remainingLine = currentLine.substring(currentPos);
              if (remainingLine.includes(":") && !remainingLine.trim().startsWith("#")) {
                value = this.parseBlockObject(nextIndent);
              } else {
                value = this.parseValue();
              }
            }
          } else if (!fromCurrentPosition && nextIndent === currentIndent) {
            this.lexer.skipWhitespace();
            if (this.lexer.getCurrentChar() === "-") {
              value = this.parseBlockArray(currentIndent);
            } else {
              value = createStringNode("", valueStart, valueStart);
            }
          } else {
            value = createStringNode("", valueStart, valueStart);
          }
        } else {
          value = createStringNode("", valueStart, valueStart);
        }
      } else {
        value = this.parseValue();
        while (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== "" && this.lexer.getCurrentChar() !== "#") {
          if (isWhitespace(this.lexer.getCurrentChar())) {
            this.lexer.advance();
          } else {
            break;
          }
        }
        if (this.lexer.getCurrentChar() === "#") {
          this.lexer.skipToEndOfLine();
        }
        if (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() === "") {
          this.lexer.advanceLine();
        }
      }
      properties.push({ key, value });
    }
    let end = start;
    if (properties.length > 0) {
      const lastProperty = properties[properties.length - 1];
      end = lastProperty.value.end;
    }
    return createObjectNode(properties, start, end);
  }
  parse() {
    if (this.lexer.isAtEnd()) {
      return void 0;
    }
    this.lexer.moveToNextNonEmptyLine();
    if (this.lexer.isAtEnd()) {
      return void 0;
    }
    this.lexer.skipWhitespace();
    if (this.lexer.getCurrentChar() === "-") {
      const nextChar = this.lexer.peek();
      if (nextChar === " " || nextChar === "	" || nextChar === "" || nextChar === "#") {
        return this.parseBlockArray(0);
      } else {
        return this.parseValue();
      }
    } else if (this.lexer.getCurrentChar() === "[") {
      return this.parseInlineArray();
    } else if (this.lexer.getCurrentChar() === "{") {
      return this.parseInlineObject();
    } else {
      const currentLine = this.lexer.getCurrentLineText();
      const currentPos = this.lexer.getCurrentCharNumber();
      const remainingLine = currentLine.substring(currentPos);
      let hasColon = false;
      let inQuotes = false;
      let quoteChar = "";
      for (let i = 0; i < remainingLine.length; i++) {
        const char = remainingLine[i];
        if (!inQuotes && (char === '"' || char === `'`)) {
          inQuotes = true;
          quoteChar = char;
        } else if (inQuotes && char === quoteChar) {
          inQuotes = false;
          quoteChar = "";
        } else if (!inQuotes && char === ":") {
          hasColon = true;
          break;
        } else if (!inQuotes && char === "#") {
          break;
        }
      }
      if (hasColon) {
        return this.parseBlockObject(0);
      } else {
        return this.parseValue();
      }
    }
  }
};

// src/util/vs/workbench/contrib/chat/common/promptSyntax/promptFileParser.ts
init_range();
var PROMPT_NAME_REGEXP = /^[\p{L}\d_\-\.]+$/u;
var PromptFileParser = class {
  constructor() {
  }
  parse(uri, content) {
    const linesWithEOL = splitLinesIncludeSeparators(content);
    if (linesWithEOL.length === 0) {
      return new ParsedPromptFile(uri, void 0, void 0);
    }
    let header = void 0;
    let body = void 0;
    let bodyStartLine = 0;
    if (linesWithEOL[0].match(/^---[\s\r\n]*$/)) {
      let headerEndLine = linesWithEOL.findIndex((line, index) => index > 0 && line.match(/^---[\s\r\n]*$/));
      if (headerEndLine === -1) {
        headerEndLine = linesWithEOL.length;
        bodyStartLine = linesWithEOL.length;
      } else {
        bodyStartLine = headerEndLine + 1;
      }
      const range = new Range(2, 1, headerEndLine + 1, 1);
      header = new PromptHeader(range, linesWithEOL);
    }
    if (bodyStartLine < linesWithEOL.length) {
      const range = new Range(bodyStartLine + 1, 1, linesWithEOL.length + 1, 1);
      body = new PromptBody(range, linesWithEOL, uri);
    }
    return new ParsedPromptFile(uri, header, body);
  }
};
var ParsedPromptFile = class {
  constructor(uri, header, body) {
    this.uri = uri;
    this.header = header;
    this.body = body;
  }
};
var PromptHeaderAttributes;
((PromptHeaderAttributes2) => {
  PromptHeaderAttributes2.name = "name";
  PromptHeaderAttributes2.description = "description";
  PromptHeaderAttributes2.agent = "agent";
  PromptHeaderAttributes2.mode = "mode";
  PromptHeaderAttributes2.model = "model";
  PromptHeaderAttributes2.applyTo = "applyTo";
  PromptHeaderAttributes2.tools = "tools";
  PromptHeaderAttributes2.handOffs = "handoffs";
  PromptHeaderAttributes2.advancedOptions = "advancedOptions";
  PromptHeaderAttributes2.argumentHint = "argument-hint";
  PromptHeaderAttributes2.excludeAgent = "excludeAgent";
  PromptHeaderAttributes2.target = "target";
})(PromptHeaderAttributes || (PromptHeaderAttributes = {}));
var GithubPromptHeaderAttributes;
((GithubPromptHeaderAttributes2) => {
  GithubPromptHeaderAttributes2.mcpServers = "mcp-servers";
})(GithubPromptHeaderAttributes || (GithubPromptHeaderAttributes = {}));
var PromptHeader = class {
  constructor(range, linesWithEOL) {
    this.range = range;
    this.linesWithEOL = linesWithEOL;
  }
  get _parsedHeader() {
    if (this._parsed === void 0) {
      const yamlErrors = [];
      const lines = this.linesWithEOL.slice(this.range.startLineNumber - 1, this.range.endLineNumber - 1).join("");
      const node = parse5(lines, yamlErrors);
      const attributes = [];
      const errors2 = yamlErrors.map((err) => ({ message: err.message, range: this.asRange(err), code: err.code }));
      if (node) {
        if (node.type !== "object") {
          errors2.push({ message: "Invalid header, expecting <key: value> pairs", range: this.range, code: "INVALID_YAML" });
        } else {
          for (const property of node.properties) {
            attributes.push({
              key: property.key.value,
              range: this.asRange({ start: property.key.start, end: property.value.end }),
              value: this.asValue(property.value)
            });
          }
        }
      }
      this._parsed = { node, attributes, errors: errors2 };
    }
    return this._parsed;
  }
  asRange({ start, end }) {
    return new Range(this.range.startLineNumber + start.line, start.character + 1, this.range.startLineNumber + end.line, end.character + 1);
  }
  asValue(node) {
    switch (node.type) {
      case "string":
        return { type: "string", value: node.value, range: this.asRange(node) };
      case "number":
        return { type: "number", value: node.value, range: this.asRange(node) };
      case "boolean":
        return { type: "boolean", value: node.value, range: this.asRange(node) };
      case "null":
        return { type: "null", value: node.value, range: this.asRange(node) };
      case "array":
        return { type: "array", items: node.items.map((item) => this.asValue(item)), range: this.asRange(node) };
      case "object": {
        const properties = node.properties.map((property) => ({ key: this.asValue(property.key), value: this.asValue(property.value) }));
        return { type: "object", properties, range: this.asRange(node) };
      }
    }
  }
  get attributes() {
    return this._parsedHeader.attributes;
  }
  getAttribute(key) {
    return this._parsedHeader.attributes.find((attr) => attr.key === key);
  }
  get errors() {
    return this._parsedHeader.errors;
  }
  getStringAttribute(key) {
    const attribute2 = this._parsedHeader.attributes.find((attr) => attr.key === key);
    if (attribute2?.value.type === "string") {
      return attribute2.value.value;
    }
    return void 0;
  }
  get name() {
    const name = this.getStringAttribute(PromptHeaderAttributes.name);
    if (name && PROMPT_NAME_REGEXP.test(name)) {
      return name;
    }
    return void 0;
  }
  get description() {
    return this.getStringAttribute(PromptHeaderAttributes.description);
  }
  get agent() {
    return this.getStringAttribute(PromptHeaderAttributes.agent) ?? this.getStringAttribute(PromptHeaderAttributes.mode);
  }
  get model() {
    return this.getStringAttribute(PromptHeaderAttributes.model);
  }
  get applyTo() {
    return this.getStringAttribute(PromptHeaderAttributes.applyTo);
  }
  get argumentHint() {
    return this.getStringAttribute(PromptHeaderAttributes.argumentHint);
  }
  get target() {
    return this.getStringAttribute(PromptHeaderAttributes.target);
  }
  get tools() {
    const toolsAttribute = this._parsedHeader.attributes.find((attr) => attr.key === PromptHeaderAttributes.tools);
    if (!toolsAttribute) {
      return void 0;
    }
    if (toolsAttribute.value.type === "array") {
      const tools = [];
      for (const item of toolsAttribute.value.items) {
        if (item.type === "string" && item.value) {
          tools.push(item.value);
        }
      }
      return tools;
    } else if (toolsAttribute.value.type === "object") {
      const tools = [];
      const collectLeafs = ({ key, value }) => {
        if (value.type === "boolean") {
          tools.push(key.value);
        } else if (value.type === "object") {
          value.properties.forEach(collectLeafs);
        }
      };
      toolsAttribute.value.properties.forEach(collectLeafs);
      return tools;
    }
    return void 0;
  }
  get handOffs() {
    const handoffsAttribute = this._parsedHeader.attributes.find((attr) => attr.key === PromptHeaderAttributes.handOffs);
    if (!handoffsAttribute) {
      return void 0;
    }
    if (handoffsAttribute.value.type === "array") {
      const handoffs = [];
      for (const item of handoffsAttribute.value.items) {
        if (item.type === "object") {
          let agent;
          let label;
          let prompt;
          let send;
          for (const prop of item.properties) {
            if (prop.key.value === "agent" && prop.value.type === "string") {
              agent = prop.value.value;
            } else if (prop.key.value === "label" && prop.value.type === "string") {
              label = prop.value.value;
            } else if (prop.key.value === "prompt" && prop.value.type === "string") {
              prompt = prop.value.value;
            } else if (prop.key.value === "send" && prop.value.type === "boolean") {
              send = prop.value.value;
            }
          }
          if (agent && label && prompt !== void 0) {
            handoffs.push({ agent, label, prompt, send });
          }
        }
      }
      return handoffs;
    }
    return void 0;
  }
};
var PromptBody = class {
  constructor(range, linesWithEOL, uri) {
    this.range = range;
    this.linesWithEOL = linesWithEOL;
    this.uri = uri;
  }
  get fileReferences() {
    return this.getParsedBody().fileReferences;
  }
  get variableReferences() {
    return this.getParsedBody().variableReferences;
  }
  get offset() {
    return this.getParsedBody().bodyOffset;
  }
  getParsedBody() {
    if (this._parsed === void 0) {
      const markdownLinkRanges = [];
      const fileReferences = [];
      const variableReferences = [];
      const bodyOffset = Iterable.reduce(Iterable.slice(this.linesWithEOL, 0, this.range.startLineNumber - 1), (len, line) => line.length + len, 0);
      for (let i = this.range.startLineNumber - 1, lineStartOffset = bodyOffset; i < this.range.endLineNumber - 1; i++) {
        const line = this.linesWithEOL[i];
        const linkMatch = line.matchAll(/\[(.*?)\]\((.+?)\)/g);
        for (const match3 of linkMatch) {
          const linkEndOffset = match3.index + match3[0].length - 1;
          const linkStartOffset = match3.index + match3[0].length - match3[2].length - 1;
          const range = new Range(i + 1, linkStartOffset + 1, i + 1, linkEndOffset + 1);
          fileReferences.push({ content: match3[2], range, isMarkdownLink: true });
          markdownLinkRanges.push(new Range(i + 1, match3.index + 1, i + 1, match3.index + match3[0].length + 1));
        }
        const reg = /#file:(?<filePath>[^\s#]+)|#tool:(?<toolName>[\w_\-\.\/]+)/gi;
        const matches = line.matchAll(reg);
        for (const match3 of matches) {
          const fullMatch = match3[0];
          const fullRange = new Range(i + 1, match3.index + 1, i + 1, match3.index + fullMatch.length + 1);
          if (markdownLinkRanges.some((mdRange) => Range.areIntersectingOrTouching(mdRange, fullRange))) {
            continue;
          }
          const contentMatch = match3.groups?.["filePath"] || match3.groups?.["toolName"];
          if (!contentMatch) {
            continue;
          }
          const startOffset = match3.index + fullMatch.length - contentMatch.length;
          const endOffset = match3.index + fullMatch.length;
          const range = new Range(i + 1, startOffset + 1, i + 1, endOffset + 1);
          if (match3.groups?.["filePath"]) {
            fileReferences.push({ content: match3.groups?.["filePath"], range, isMarkdownLink: false });
          } else if (match3.groups?.["toolName"]) {
            variableReferences.push({ name: match3.groups?.["toolName"], range, offset: lineStartOffset + match3.index });
          }
        }
        lineStartOffset += line.length;
      }
      this._parsed = { fileReferences: fileReferences.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range)), variableReferences, bodyOffset };
    }
    return this._parsed;
  }
  getContent() {
    return this.linesWithEOL.slice(this.range.startLineNumber - 1, this.range.endLineNumber - 1).join("");
  }
  resolveFilePath(path) {
    try {
      if (path.startsWith("/")) {
        return this.uri.with({ path });
      } else if (path.match(/^[a-zA-Z]+:\//)) {
        return URI.parse(path);
      } else {
        const dirName = dirname2(this.uri);
        return joinPath(dirName, path);
      }
    } catch {
      return void 0;
    }
  }
};

// src/platform/promptFiles/common/promptsService.ts
var IPromptsService = createDecorator("IPromptsService");
var PromptFileLangageId;
((PromptFileLangageId2) => {
  PromptFileLangageId2.prompt = "prompt";
  PromptFileLangageId2.instructions = "instructions";
  PromptFileLangageId2.agent = "chatagent";
})(PromptFileLangageId || (PromptFileLangageId = {}));

// src/platform/promptFiles/common/promptsServiceImpl.ts
init_errors();
var PromptsServiceImpl = class {
  constructor(fileService) {
    this.fileService = fileService;
  }
  async parseFile(uri, token) {
    const fileContent = await this.fileService.readFile(uri);
    if (token.isCancellationRequested) {
      throw new CancellationError();
    }
    const text2 = new TextDecoder().decode(fileContent);
    return new PromptFileParser().parse(uri, text2);
  }
};
PromptsServiceImpl = __decorateClass([
  __decorateParam(0, IFileSystemService)
], PromptsServiceImpl);

// src/platform/releaseNotes/common/releaseNotesService.ts
var IReleaseNotesService = createDecorator("releaseNotesService");

// src/platform/releaseNotes/vscode/releaseNotesServiceImpl.ts
var ReleaseNotesService = class {
  constructor(envService, fetcherService) {
    this.envService = envService;
    this.fetcherService = fetcherService;
  }
  static {
    this.BASE_URL = "https://code.visualstudio.com/raw";
  }
  async fetchLatestReleaseNotes() {
    const url = this.getUrl();
    if (!url) {
      return;
    }
    const releaseNotes = await this.fetcherService.fetch(url, {
      method: "GET"
    });
    const releaseNotesText = await releaseNotes.text();
    return releaseNotesText;
  }
  async fetchReleaseNotesForVersion(version2) {
    const url = this.getUrl(version2);
    if (!url) {
      return;
    }
    const releaseNotes = await this.fetcherService.fetch(url, {
      method: "GET"
    });
    const releaseNotesText = await releaseNotes.text();
    return releaseNotesText;
  }
  getUrl(version2) {
    const sourceVersion = version2 && version2.trim().length > 0 ? version2.trim() : this.envService.getEditorInfo().version;
    let major;
    let minor;
    if (/^\d+\.\d+(?:\.\d+)?$/.test(sourceVersion)) {
      const sanitized = sanitizeVSCodeVersion(sourceVersion);
      const mm = /^(\d+)\.(\d+)$/.exec(sanitized);
      if (!mm) {
        return;
      }
      major = mm[1];
      minor = mm[2];
    } else {
      return;
    }
    return `${ReleaseNotesService.BASE_URL}/v${major}_${minor}.md`;
  }
};
ReleaseNotesService = __decorateClass([
  __decorateParam(0, IEnvService),
  __decorateParam(1, IFetcherService2)
], ReleaseNotesService);

// src/platform/remoteRepositories/vscode/remoteRepositories.ts
var import_vscode12 = require("vscode");
var IRemoteRepositoriesService = createDecorator("IRemoteRepositoriesService");
var RemoteRepositoriesService = class {
  async loadWorkspaceContents(workspaceUri) {
    const api = await this.getApi();
    return await api.loadWorkspaceContents?.(workspaceUri) ?? false;
  }
  getApi() {
    return this.getRemoteExtension().activate();
  }
  getRemoteExtension() {
    if (this._remoteHub !== void 0) {
      return this._remoteHub;
    }
    this._remoteHub = import_vscode12.extensions.getExtension("ms-vscode.remote-repositories") ?? import_vscode12.extensions.getExtension("GitHub.remoteHub") ?? import_vscode12.extensions.getExtension("GitHub.remoteHub-insiders");
    if (this._remoteHub === void 0) {
      throw new Error(`No Remote repository extension found.`);
    }
    return this._remoteHub;
  }
};

// src/platform/review/common/reviewService.ts
var IReviewService = createDecorator("IReviewService");

// src/platform/review/vscode/reviewServiceImpl.ts
var vscode14 = __toESM(require("vscode"));
var import_vscode13 = require("vscode");
init_lifecycle();
var reviewDiffContextKey = "puku.chat.reviewDiff.enabled";
var reviewDiffReposContextKey = "puku.chat.reviewDiff.enabledRootUris";
var numberOfReviewCommentsKey = "puku.chat.review.numberOfComments";
var ReviewServiceImpl = class {
  constructor(_configurationService, _authenticationService, _contextService, _gitExtensionService) {
    this._configurationService = _configurationService;
    this._authenticationService = _authenticationService;
    this._contextService = _contextService;
    this._gitExtensionService = _gitExtensionService;
    this._disposables = new DisposableStore();
    this._repositoryDisposables = new DisposableStore();
    this._commentController = vscode14.comments.createCommentController("github-copilot-review", "Code Review");
    this._comments = [];
    this._disposables.add(vscode14.workspace.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(ConfigKey.CodeFeedback.fullyQualifiedId)) {
        vscode14.commands.executeCommand("setContext", ConfigKey.CodeFeedback.fullyQualifiedId, this.isCodeFeedbackEnabled());
      }
      if (e.affectsConfiguration("puku.advanced") || e.affectsConfiguration("puku.advanced.review.intent")) {
        vscode14.commands.executeCommand("setContext", ConfigKey.AdvancedExperimental.ReviewIntent.fullyQualifiedId, this.isIntentEnabled());
      }
    }));
    this._disposables.add(this._authenticationService.onDidAuthenticationChange(() => {
      vscode14.commands.executeCommand("setContext", reviewDiffContextKey, this.isReviewDiffEnabled());
    }));
    this._disposables.add(this._repositoryDisposables);
    this._disposables.add(this._gitExtensionService.onDidChange(() => {
      this.updateRepositoryListeners();
    }));
    this.updateRepositoryListeners();
    this.updateContextValues();
    vscode14.commands.executeCommand("setContext", numberOfReviewCommentsKey, 0);
  }
  updateRepositoryListeners() {
    this._repositoryDisposables.clear();
    const api = this._gitExtensionService.getExtensionApi();
    if (api) {
      this._repositoryDisposables.add(api.onDidOpenRepository(() => {
        this.updateRepositoryListeners();
      }));
      this._repositoryDisposables.add(api.onDidCloseRepository(() => {
        this.updateRepositoryListeners();
      }));
      api.repositories.forEach((repo) => {
        this._repositoryDisposables.add(repo.state.onDidChange(() => {
          this.updateReviewDiffReposContext();
        }));
      });
    }
    this.updateReviewDiffReposContext();
  }
  updateReviewDiffReposContext() {
    const reviewDiffRepos = this.getRepositoriesWithUncommitedChanges();
    const reviewDiffReposString = reviewDiffRepos.map((uri) => uri.toString()).sort().join(",");
    if (reviewDiffReposString !== this._reviewDiffReposString) {
      this._reviewDiffReposString = reviewDiffReposString;
      vscode14.commands.executeCommand("setContext", reviewDiffReposContextKey, reviewDiffRepos);
    }
  }
  getRepositoriesWithUncommitedChanges() {
    const r = this._gitExtensionService.getExtensionApi()?.repositories.filter(({ state }) => state.workingTreeChanges.length || state.indexChanges.length || state.untrackedChanges.length || state.mergeChanges.length).map((repo) => repo.rootUri) || [];
    return r;
  }
  updateContextValues() {
    vscode14.commands.executeCommand("setContext", ConfigKey.CodeFeedback.fullyQualifiedId, this.isCodeFeedbackEnabled());
    vscode14.commands.executeCommand("setContext", reviewDiffContextKey, this.isReviewDiffEnabled());
    vscode14.commands.executeCommand("setContext", ConfigKey.AdvancedExperimental.ReviewIntent.fullyQualifiedId, this.isIntentEnabled());
  }
  isCodeFeedbackEnabled() {
    const inspect = this._configurationService.inspectConfig(ConfigKey.CodeFeedback);
    return inspect?.workspaceFolderValue ?? inspect?.workspaceValue ?? inspect?.globalValue ?? this._configurationService.getDefaultValue(ConfigKey.CodeFeedback);
  }
  isReviewDiffEnabled() {
    return this._configurationService.getConfig(ConfigKey.ReviewAgent) && this._authenticationService.copilotToken?.isCopilotCodeReviewEnabled || false;
  }
  isIntentEnabled() {
    return this._configurationService.getConfig(ConfigKey.AdvancedExperimental.ReviewIntent);
  }
  getDiagnosticCollection() {
    return this._diagnosticCollection || this._disposables.add(this._diagnosticCollection = vscode14.languages.createDiagnosticCollection("puku.chat.review"));
  }
  getReviewComments() {
    return this._comments.map(({ comment: comment2 }) => comment2);
  }
  addReviewComments(comments2) {
    for (const comment2 of comments2) {
      const thread = this._commentController.createCommentThread(comment2.uri, comment2.range, this.createUIComments(comment2));
      thread.contextValue = "hasNoSuggestion";
      thread.canReply = false;
      if (!this._comments.find((c) => c.comment.uri.toString() === comment2.uri.toString())) {
        thread.collapsibleState = vscode14.CommentThreadCollapsibleState.Expanded;
      }
      this._comments.push({ comment: comment2, thread });
      this.updateThreadLabels();
      if (this._comments.length === 1) {
        vscode14.commands.executeCommand("puku.chat.review.next");
        this._monitorActiveThread = setInterval(() => {
          const raw = this._commentController.activeCommentThread;
          const active = raw && this._comments.find((c) => c.thread.label === raw.label)?.thread;
          if (active !== this._activeThread) {
            this._activeThread = active;
            if (active) {
              vscode14.commands.executeCommand("puku.chat.review.current", active);
            }
          }
        }, 500);
      }
    }
    vscode14.commands.executeCommand("setContext", numberOfReviewCommentsKey, this._comments.length);
  }
  updateReviewComment(comment2) {
    const thread = this.findCommentThread(comment2);
    if (!thread) {
      return;
    }
    thread.comments = this.createUIComments(comment2);
  }
  createUIComments(comment2) {
    const appendText = "";
    const change = comment2.suggestion ? "edits" in comment2.suggestion ? comment2.suggestion.edits.length ? `

***
${import_vscode13.l10n.t("Suggested change:")}${comment2.suggestion.edits.map((e) => `
\`\`\`diff
${diff(e)}
\`\`\``).join("")}
***` : `

${import_vscode13.l10n.t("No change found to suggest.")}` : `

${import_vscode13.l10n.t("Looking up change to suggest...")}` : "";
    const comments2 = [
      {
        body: typeof comment2.body === "string" ? `${comment2.body}${change}${appendText}` : new vscode14.MarkdownString(`${comment2.body.value}${change}${appendText}`),
        mode: vscode14.CommentMode.Preview,
        author: {
          name: import_vscode13.l10n.t("Code Review"),
          iconPath: URI.joinPath(this._contextService.extensionUri, "assets", "copilot.png")
        }
      }
    ];
    return comments2;
  }
  collapseReviewComment(comment2) {
    const internalComment = this._comments.find((c) => c.comment === comment2);
    if (!internalComment) {
      return;
    }
    const oldThread = internalComment.thread;
    oldThread.dispose();
    const newThread = this._commentController.createCommentThread(comment2.uri, comment2.range, oldThread.comments);
    newThread.contextValue = oldThread.contextValue;
    newThread.canReply = false;
    newThread.label = oldThread.label;
    internalComment.thread = newThread;
  }
  removeReviewComments(comments2) {
    for (const comment2 of comments2) {
      const index = this._comments.findIndex((c) => c.comment === comment2);
      if (index !== -1) {
        this._comments[index].thread.dispose();
        this._comments.splice(index, 1);
      }
    }
    this.updateThreadLabels();
    if (this._comments.length === 0 && this._monitorActiveThread) {
      clearInterval(this._monitorActiveThread);
      this._monitorActiveThread = void 0;
    }
    vscode14.commands.executeCommand("setContext", numberOfReviewCommentsKey, this._comments.length);
  }
  updateThreadLabels() {
    this._comments.forEach((comment2, i) => {
      comment2.thread.label = import_vscode13.l10n.t("Comment {0} of {1}", i + 1, this._comments.length);
    });
  }
  findReviewComment(threadOrComment) {
    const internalComment = this._comments.find((c) => c.thread === threadOrComment || c.thread.comments[0] === threadOrComment);
    return internalComment?.comment;
  }
  findCommentThread(comment2) {
    const internalComment = this._comments.find((c) => c.comment === comment2);
    return internalComment?.thread;
  }
  dispose() {
    this._disposables.dispose();
  }
};
ReviewServiceImpl = __decorateClass([
  __decorateParam(0, IConfigurationService),
  __decorateParam(1, IAuthenticationService),
  __decorateParam(2, IVSCodeExtensionContext),
  __decorateParam(3, IGitExtensionService)
], ReviewServiceImpl);
function diff(change) {
  const oldText = change.oldText.split(/\r?\n/);
  const newText = change.newText.split(/\r?\n/);
  while (oldText.length && newText.length && oldText[0] === newText[0]) {
    oldText.shift();
    newText.shift();
  }
  while (oldText.length && newText.length && oldText[oldText.length - 1] === newText[newText.length - 1]) {
    oldText.pop();
    newText.pop();
  }
  return `${oldText.map((line) => `- ${line}`).join("\n")}
${newText.map((line) => `+ ${line}`).join("\n")}`;
}

// src/platform/simulationTestContext/common/simulationTestContext.ts
var ISimulationTestContext = createDecorator("ISimulationTestContext");
var NulSimulationTestContext = class {
  constructor() {
    this.isInSimulationTests = false;
  }
  async writeFile(filename, contents, tag) {
    return "";
  }
};

// src/platform/snippy/common/snippyService.ts
var ISnippyService = createDecorator("ISnippyService");

// src/platform/snippy/common/snippyServiceImpl.ts
init_cancellation();

// src/platform/snippy/common/snippyCompute.ts
var SnippyLexemeRegex = new RegExp("[_\\p{L}\\p{Nd}]+|====+|----+|####+|////+|\\*\\*\\*\\*+|[\\p{P}\\p{S}]", "gu");
var MinTokenLength = 65;
function lexemeLength(text2) {
  let i = 0;
  let m;
  SnippyLexemeRegex.lastIndex = 0;
  do {
    m = SnippyLexemeRegex.exec(text2);
    if (m) {
      i += 1;
    }
    if (i >= MinTokenLength) {
      break;
    }
  } while (m);
  return i;
}
function offsetFirstLexemes(text2, n) {
  let i = 0;
  let m;
  SnippyLexemeRegex.lastIndex = 0;
  do {
    m = SnippyLexemeRegex.exec(text2);
    if (m) {
      i += 1;
      if (i >= n) {
        return SnippyLexemeRegex.lastIndex;
      }
    }
  } while (m);
  return text2.length;
}
function offsetLastLexemes(text2, n) {
  const textRev = text2.split("").reverse().join("");
  const offsetRev = offsetFirstLexemes(textRev, n);
  return textRev.length - offsetRev;
}
function hasMinLexemeLength(text2) {
  return lexemeLength(text2) >= MinTokenLength;
}

// src/platform/snippy/common/snippyFetcher.ts
init_errors();

// src/util/common/result.ts
var Result;
((Result2) => {
  function ok(value) {
    return new ResultOk(value);
  }
  Result2.ok = ok;
  function error2(value) {
    return new ResultError(value);
  }
  Result2.error = error2;
  function fromString(errorMessage) {
    return Result2.error(new Error(errorMessage));
  }
  Result2.fromString = fromString;
})(Result || (Result = {}));
var ResultOk = class _ResultOk {
  constructor(val) {
    this.val = val;
  }
  map(f) {
    return new _ResultOk(f(this.val));
  }
  flatMap(f) {
    return f(this.val);
  }
  isOk() {
    return true;
  }
  isError() {
    return false;
  }
};
var ResultError = class {
  constructor(err) {
    this.err = err;
  }
  map(f) {
    return this;
  }
  flatMap(f) {
    return this;
  }
  isOk() {
    return false;
  }
  isError() {
    return true;
  }
};

// src/platform/snippy/common/snippyTypes.ts
var Snippet;
((Snippet2) => {
  function is(v) {
    return typeof v === "object" && v !== null && typeof v.matched_source === "string" && typeof v.occurrences === "string" && typeof v.capped === "boolean" && typeof v.cursor === "string" && typeof v.github_url === "string";
  }
  Snippet2.is = is;
})(Snippet || (Snippet = {}));
var MatchError;
((MatchError2) => {
  function is(v) {
    return typeof v === "object" && v !== null && typeof v.kind === "string" && typeof v.reason === "string" && typeof v.code === "number" && typeof v.msg === "string";
  }
  MatchError2.is = is;
})(MatchError || (MatchError = {}));
var MatchSuccess;
((MatchSuccess2) => {
  function is(v) {
    return typeof v === "object" && v !== null && "snippets" in v && Array.isArray(v.snippets) && v.snippets.every(Snippet.is);
  }
  MatchSuccess2.is = is;
})(MatchSuccess || (MatchSuccess = {}));
var MatchResponse;
((MatchResponse2) => {
  function to(v) {
    if (MatchError.is(v)) {
      return Result.error(v);
    }
    if (MatchSuccess.is(v)) {
      return Result.ok(v);
    }
    return void 0;
  }
  MatchResponse2.to = to;
})(MatchResponse || (MatchResponse = {}));
var FileMatch;
((FileMatch2) => {
  function is(v) {
    return typeof v === "object" && v !== null && typeof v.commit_id === "string" && typeof v.license === "string" && typeof v.nwo === "string" && typeof v.path === "string" && typeof v.url === "string";
  }
  FileMatch2.is = is;
})(FileMatch || (FileMatch = {}));
var PackageInformation;
((PackageInformation2) => {
  function is(v) {
    return typeof v === "object" && v !== null && typeof v.has_next_page === "boolean" && typeof v.cursor === "string";
  }
  PackageInformation2.is = is;
})(PackageInformation || (PackageInformation = {}));
var LicenseStats;
((LicenseStats2) => {
  function is(v) {
    return typeof v === "object" && v !== null && typeof v.count === "object" && Object.values(v.count).every((value) => typeof value === "string");
  }
  LicenseStats2.is = is;
})(LicenseStats || (LicenseStats = {}));
var FileMatchSuccess;
((FileMatchSuccess2) => {
  function is(v) {
    return typeof v === "object" && v !== null && "file_matches" in v && Array.isArray(v.file_matches) && v.file_matches.every(FileMatch.is) && "page_info" in v && PackageInformation.is(v.page_info) && "license_stats" in v && LicenseStats.is(v.license_stats);
  }
  FileMatchSuccess2.is = is;
})(FileMatchSuccess || (FileMatchSuccess = {}));
var FileMatchResponse;
((FileMatchResponse2) => {
  function to(v) {
    if (MatchError.is(v)) {
      return Result.error(v);
    }
    if (FileMatchSuccess.is(v)) {
      return Result.ok(v);
    }
    return void 0;
  }
  FileMatchResponse2.to = to;
})(FileMatchResponse || (FileMatchResponse = {}));

// src/platform/snippy/common/snippyFetcher.ts
var SnippyFetchService = class {
  constructor(fetcherService, capiClientService, authService) {
    this.fetcherService = fetcherService;
    this.capiClientService = capiClientService;
    this.authService = authService;
  }
  async fetchMatch(source, cancellationToken) {
    const body = {
      source
    };
    return this.fetch({ type: "SnippyMatch" /* SnippyMatch */ }, body, MatchResponse.to, cancellationToken);
  }
  async fetchFilesForMatch(cursor, cancellationToken) {
    const body = {
      cursor
    };
    return this.fetch({ type: "SnippyFlesForMatch" /* SnippyFilesForMatch */ }, body, FileMatchResponse.to, cancellationToken);
  }
  /**
   * @throws {CancellationError} if the request is cancelled
   * @throws {Error} if the request fails
   */
  async fetch(requestMetadata, requestBody, processResponse, cancellationToken) {
    const abortController = this.fetcherService.makeAbortController();
    const disposable = cancellationToken.onCancellationRequested(() => {
      abortController.abort();
    });
    const signal = abortController.signal;
    const headers = await this.getHeaders();
    const options = {
      method: "POST",
      headers,
      json: requestBody,
      signal
    };
    let fetchResponse;
    try {
      fetchResponse = await this.capiClientService.makeRequest(options, requestMetadata);
    } catch (e) {
      if (this.fetcherService.isAbortError(e)) {
        throw new CancellationError();
      }
      throw e;
    } finally {
      disposable.dispose();
    }
    if (fetchResponse.status !== 200) {
      throw new Error(`Failed with status ${fetchResponse.status} and body: ${await fetchResponse.text()}`);
    }
    const responseBody = await fetchResponse.json();
    return processResponse(responseBody);
  }
  async getHeaders() {
    const token = (await this.authService.getCopilotToken()).token;
    return {
      authorization: `Bearer ${token}`
    };
  }
};
SnippyFetchService = __decorateClass([
  __decorateParam(0, IFetcherService2),
  __decorateParam(1, ICAPIClientService),
  __decorateParam(2, IAuthenticationService)
], SnippyFetchService);

// src/platform/snippy/common/snippyNotifier.ts
var SnippyNotifier = class {
  constructor(notificationService, context, logService, envService) {
    this.notificationService = notificationService;
    this.context = context;
    this.logService = logService;
    this.envService = envService;
  }
  static {
    this.matchCodeMessage = "We found a reference to public code in a recent suggestion. To learn more about public code references, review the [documentation](https://aka.ms/github-copilot-match-public-code).";
  }
  static {
    this.MatchAction = "View Reference";
  }
  static {
    this.SettingAction = "Change Setting";
  }
  static {
    this.CodeReferenceKey = "copilot.chat.codeReference.notified";
  }
  notify() {
    const didNotify = this.context.globalState.get(SnippyNotifier.CodeReferenceKey);
    if (didNotify) {
      return;
    }
    const messageItems = [SnippyNotifier.MatchAction, SnippyNotifier.SettingAction];
    void this.notificationService.showInformationMessage(SnippyNotifier.matchCodeMessage, ...messageItems).then((action) => {
      switch (action) {
        case SnippyNotifier.MatchAction: {
          this.logService.show(true);
          break;
        }
        case SnippyNotifier.SettingAction: {
          this.envService.openExternal(URI.parse("https://aka.ms/github-copilot-settings"));
          break;
        }
        case void 0: {
          break;
        }
      }
    });
    this.context.globalState.update(SnippyNotifier.CodeReferenceKey, true);
  }
};
SnippyNotifier = __decorateClass([
  __decorateParam(0, INotificationService),
  __decorateParam(1, IVSCodeExtensionContext),
  __decorateParam(2, ILogService),
  __decorateParam(3, IEnvService)
], SnippyNotifier);

// src/platform/snippy/common/snippyServiceImpl.ts
var SnippyService = class {
  constructor(instantiationService, logService) {
    this.instantiationService = instantiationService;
    this.logService = logService;
    this.notifier = this.instantiationService.createInstance(SnippyNotifier);
    this.fetcher = this.instantiationService.createInstance(SnippyFetchService);
  }
  async handlePostInsertion(documentUri, documentBeforeEdits, singleEdit) {
    const sourceToCheck = this.computeSourceToCheck(documentBeforeEdits, singleEdit);
    if (!sourceToCheck) {
      return;
    }
    let matchResponse;
    try {
      matchResponse = await this.fetcher.fetchMatch(sourceToCheck.source, CancellationToken.None);
    } catch (e) {
      console.warn("[Snippy] Service unavailable, skipping match check");
      return;
    }
    if (!matchResponse) {
      throw new Error(`Failed to parse match response: ${matchResponse}`);
    }
    if (matchResponse.isError()) {
      throw new Error(`Failed to match: ${matchResponse.err}`);
    }
    if (matchResponse.val.snippets.length === 0) {
      return;
    }
    const { snippets } = matchResponse.val;
    const citationPromises = snippets.map(async (snippet) => {
      const response = await this.fetcher.fetchFilesForMatch(snippet.cursor, CancellationToken.None);
      if (!response || response.isError()) {
        return;
      }
      const { file_matches: files, license_stats: licenseStats } = response.val;
      return {
        match: snippet,
        files,
        licenseStats
      };
    });
    this.notifier.notify();
    const citations = await Promise.all(citationPromises);
    const filteredCitations = citations.filter((c) => !!c);
    if (filteredCitations.length === 0) {
      return;
    }
    for (const citation of filteredCitations) {
      const licensesSet = new Set(Object.keys(citation.licenseStats?.count ?? {}));
      if (licensesSet.delete("NOASSERTION")) {
        licensesSet.add("unknown");
      }
      const allLicenses = Array.from(licensesSet).sort();
      const matchLocation = `[Ln ${sourceToCheck.startPosition.lineNumber}, Col ${sourceToCheck.startPosition.column}]`;
      const shortenedMatchText = `${citation.match.matched_source.slice(0, 100).replace(/[\r\n\t]+|^[ \t]+/gm, " ").trim()}...`;
      this.logService.info([
        "[CODE REFERENCING]",
        documentUri,
        `Similar code with ${pluralize(allLicenses.length, "license type")}`,
        `[${allLicenses.join(", ")}]`,
        `${citation.match.github_url.replace(/,\s*$/, "")}&editor=vscode`,
        matchLocation,
        shortenedMatchText
      ].join(" "));
    }
  }
  computeSourceToCheck(documentBeforeEdits, singleEdit) {
    if (singleEdit.newText === "") {
      return;
    }
    const edit = StringEdit.single(singleEdit);
    const newRanges = edit.getNewRanges();
    const newTotalRange = newRanges.reduce((acc, range) => acc.join(range));
    const documentAfterEdits = edit.applyOnText(documentBeforeEdits);
    let startOffset = newTotalRange.start;
    let potentialMatchContext = documentAfterEdits.value.substring(newTotalRange.start, newTotalRange.endExclusive);
    if (!hasMinLexemeLength(potentialMatchContext)) {
      const textWithoutCompletion = documentAfterEdits.value.slice(0, newTotalRange.start);
      const minLexemeStartOffset = offsetLastLexemes(
        textWithoutCompletion,
        MinTokenLength
      );
      startOffset = minLexemeStartOffset;
      potentialMatchContext = documentAfterEdits.value.slice(minLexemeStartOffset, newTotalRange.start + singleEdit.newText.length);
    }
    if (!hasMinLexemeLength(potentialMatchContext)) {
      return;
    }
    const trans = documentAfterEdits.getTransformer();
    const startPosition = trans.getPosition(startOffset);
    return {
      source: potentialMatchContext,
      startPosition
    };
  }
};
SnippyService = __decorateClass([
  __decorateParam(0, IInstantiationService),
  __decorateParam(1, ILogService)
], SnippyService);
var pluralize = (count2, noun, suffix = "s") => `${count2} ${noun}${count2 !== 1 ? suffix : ""}`;

// src/platform/survey/common/surveyService.ts
var ISurveyService = createDecorator("ISurveyService");

// src/platform/survey/vscode/surveyServiceImpl.ts
var vscode15 = __toESM(require("vscode"));
var import_vscode14 = require("vscode");
var SURVEY_URI = "https://aka.ms/vscode-gh-copilot";
var USAGE_DATA_KEY = "survey.usage";
var NEXT_SURVEY_DATE_KEY = "survey.nextSurveyDate";
var DAYS_14 = 14 * 24 * 60 * 60 * 1e3;
var DAYS_LATER = 7;
var DAYS_COOLDOWN = 90;
var DEBOUNCE_TIME = 3 * 60 * 1e3;
var INACTIVE_TIMEOUT = 5 * 60 * 1e3;
var MIN_DAYS_USED = 2;
var DEFAULT_SESSION_PROBABILITY = 2;
var DEFAULT_NOTIFICATION_PROBABILITY = 20;
var DEFAULT_SESSION_PROBABILITY_INACTIVE = 1;
var SurveyService = class {
  constructor(telemetryService, vscodeExtensionContext, envService, experimentationService, authenticationService) {
    this.telemetryService = telemetryService;
    this.vscodeExtensionContext = vscodeExtensionContext;
    this.envService = envService;
    this.experimentationService = experimentationService;
    this.authenticationService = authenticationService;
    this.debounceTimeout = null;
    this.lastSource = null;
    this.lastLanguageId = null;
    this.surveyUri = Uri3.parse(SURVEY_URI);
    this.sessionSeed = Math.random();
    setTimeout(async () => {
      await this.updateUsageData(false);
      const eligible = await this.checkInactiveUserHeuristic();
      if (eligible) {
        this.promptSurvey("churn");
      }
    }, INACTIVE_TIMEOUT);
  }
  async signalUsage(source, languageId) {
    await this.updateUsageData(true);
    this.lastSource = source;
    if (languageId) {
      this.lastLanguageId = languageId;
    }
    if (!this.debounceTimeout) {
      this.debounceTimeout = setTimeout(async () => {
        const eligible = await this.checkEligibility();
        if (eligible) {
          this.promptSurvey("usage");
        }
        this.debounceTimeout = null;
      }, DEBOUNCE_TIME);
    }
  }
  async checkInactiveUserHeuristic() {
    const usageData = await this.getUsageData();
    const nextSurveyDate = await this.getNextSurveyDate();
    const now2 = Date.now();
    const daysUsedInLast14Days = usageData.activeDays.length;
    const isOldEnough = usageData.firstActive > 0 && usageData.firstActive < now2 - DAYS_14;
    const isCooldownOver = !nextSurveyDate || nextSurveyDate < now2;
    const hasNotBeenActiveInLast14Days = daysUsedInLast14Days === 0;
    const isEligible = hasNotBeenActiveInLast14Days && isOldEnough && isCooldownOver;
    if (isEligible) {
      const sessionProbability = this.experimentationService.getTreatmentVariable("copilotchat.feedback.sessionProbability.inactive") ?? DEFAULT_SESSION_PROBABILITY_INACTIVE;
      return this.sessionSeed < sessionProbability / 100;
    }
    return false;
  }
  async checkEligibility() {
    const usageData = await this.getUsageData();
    const nextSurveyDate = await this.getNextSurveyDate();
    const now2 = Date.now();
    const daysUsedInLast14Days = usageData.activeDays.length;
    const isOldEnough = usageData.firstActive < now2 - DAYS_14;
    const isCooldownOver = !nextSurveyDate || nextSurveyDate < now2;
    const hasEnoughUsage = daysUsedInLast14Days >= MIN_DAYS_USED;
    const isEligible = hasEnoughUsage && isOldEnough && isCooldownOver;
    if (isEligible) {
      const sessionProbability = this.experimentationService.getTreatmentVariable("copilotchat.feedback.sessionProbability") ?? DEFAULT_SESSION_PROBABILITY;
      if (this.sessionSeed < sessionProbability / 100) {
        const notificationProbability = this.experimentationService.getTreatmentVariable("copilotchat.feedback.notificationProbability") ?? DEFAULT_NOTIFICATION_PROBABILITY;
        const seed = Math.random();
        return seed < notificationProbability / 100;
      }
    }
    return false;
  }
  async getUsageData() {
    const usageData = this.vscodeExtensionContext.globalState.get(USAGE_DATA_KEY);
    if (usageData) {
      return usageData;
    }
    return { firstActive: 0, activeDays: [] };
  }
  async getNextSurveyDate() {
    return this.vscodeExtensionContext.globalState.get(NEXT_SURVEY_DATE_KEY) ?? null;
  }
  async updateUsageData(wasActive) {
    const usageData = await this.getUsageData();
    const now2 = Date.now();
    if (wasActive) {
      if (!usageData.firstActive) {
        usageData.firstActive = now2;
      }
      const today = (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
      if (!usageData.activeDays.includes(today)) {
        usageData.activeDays.push(today);
      }
    }
    usageData.activeDays = usageData.activeDays.filter((timestamp) => timestamp >= now2 - DAYS_14);
    await this.vscodeExtensionContext.globalState.update(USAGE_DATA_KEY, usageData);
  }
  async updateNextSurveyDate(days) {
    await this.vscodeExtensionContext.globalState.update(NEXT_SURVEY_DATE_KEY, Date.now() + days * 24 * 60 * 60 * 1e3);
  }
  async promptSurvey(surveyType) {
    const usage = await this.getUsageData();
    const source = this.lastSource || "";
    const language2 = this.lastLanguageId || "";
    const firstSeenInDays = Math.floor((Date.now() - usage.firstActive) / (1e3 * 60 * 60 * 24));
    this.telemetryService.sendMSFTTelemetryEvent("survey.show", {
      source,
      language: language2,
      surveyType
    }, {
      activeDays: usage.activeDays.length,
      firstActive: firstSeenInDays
    });
    await this.updateNextSurveyDate(DAYS_COOLDOWN);
    const confirmation = import_vscode14.l10n.t("Give Feedback");
    const later = import_vscode14.l10n.t("Later");
    const skip = import_vscode14.l10n.t("Skip");
    vscode15.window.showInformationMessage(import_vscode14.l10n.t("Got a minute? Help us make GitHub Copilot better."), confirmation, later, skip).then(async (selection) => {
      const accepted = selection === confirmation;
      const postponed = selection === later;
      this.telemetryService.sendMSFTTelemetryEvent("survey.action", {
        source,
        language: language2,
        selection: accepted ? "accepted" : postponed ? "postponed" : "skipped",
        surveyType
      });
      if (accepted) {
        const copilotToken = await this.authenticationService.getCopilotToken();
        const params = {
          m: this.envService.machineId,
          s: this.envService.sessionId,
          k: copilotToken.sku ?? "",
          d: usage.activeDays.length.toString(),
          f: firstSeenInDays.toString(),
          v: this.envService.getVersion(),
          l: language2,
          src: source,
          type: surveyType
        };
        const surveyUriWithParams = this.surveyUri.with({
          query: new URLSearchParams(params).toString()
        });
        vscode15.env.openExternal(surveyUriWithParams);
      } else if (postponed) {
        await this.updateNextSurveyDate(DAYS_LATER);
      }
    });
  }
};
SurveyService = __decorateClass([
  __decorateParam(0, ITelemetryService),
  __decorateParam(1, IVSCodeExtensionContext),
  __decorateParam(2, IEnvService),
  __decorateParam(3, IExperimentationService),
  __decorateParam(4, IAuthenticationService)
], SurveyService);

// src/platform/tabs/common/tabsAndEditorsService.ts
var ITabsAndEditorsService = createDecorator("ITabsAndEditorsService");

// src/platform/tabs/vscode/tabsAndEditorsServiceImpl.ts
var vscode16 = __toESM(require("vscode"));
init_event();
init_lifecycle();
init_map();
var TabsAndEditorsServiceImpl = class {
  constructor() {
    this._store = new DisposableStore();
    this._tabGroupsUseInfo = /* @__PURE__ */ new Map();
    this._tabClock = 0;
    this.onDidChangeActiveTextEditor = vscode16.window.onDidChangeActiveTextEditor;
    this._onDidChangeTabs = this._store.add(new Emitter());
    this.onDidChangeTabs = this._onDidChangeTabs.event;
    const updateActiveTabGroup = () => this._tabGroupsUseInfo.set(vscode16.window.tabGroups.activeTabGroup, this._tabClock++);
    updateActiveTabGroup();
    this._store.add(vscode16.window.tabGroups.onDidChangeTabGroups((e) => {
      e.closed.forEach((item) => this._tabGroupsUseInfo.delete(item));
      updateActiveTabGroup();
    }));
    this._store.add(vscode16.window.tabGroups.onDidChangeTabs((e) => {
      this._onDidChangeTabs.fire({
        changed: e.changed.map((t2) => this._asTabInfo(t2)),
        closed: e.closed.map((t2) => this._asTabInfo(t2)),
        opened: e.opened.map((t2) => this._asTabInfo(t2))
      });
    }));
  }
  dispose() {
    this._store.dispose();
  }
  /**
   * Returns the active text editor in the VS Code window.
   *
   * Uses vscode.window.activTextEditor but _ignores_ output editors. When no text editor is active,
   * the most recent tab group that shows a text editor is used.
   */
  get activeTextEditor() {
    const candidate = vscode16.window.activeTextEditor;
    if (candidate && candidate.document.uri.scheme !== "output") {
      return candidate;
    }
    const allEditors = new ResourceMap();
    vscode16.window.visibleTextEditors.forEach((e) => allEditors.set(e.document.uri, e));
    const groups = [...this._tabGroupsUseInfo];
    groups.sort((a, b) => b[1] - a[1]);
    for (const [group] of groups) {
      if (group.activeTab) {
        const info = this._asTabInfo(group.activeTab);
        if (info.uri && allEditors.has(info.uri)) {
          const candidate2 = allEditors.get(info.uri);
          return candidate2;
        }
      }
    }
    return void 0;
  }
  get visibleTextEditors() {
    return vscode16.window.visibleTextEditors;
  }
  get activeNotebookEditor() {
    return vscode16.window.activeNotebookEditor;
  }
  get visibleNotebookEditors() {
    return vscode16.window.visibleNotebookEditors;
  }
  get tabs() {
    return vscode16.window.tabGroups.all.flatMap((g) => g.tabs).map(this._asTabInfo, this);
  }
  _asTabInfo(tab) {
    let uri;
    if (tab.input instanceof vscode16.TabInputText || tab.input instanceof vscode16.TabInputNotebook) {
      uri = tab.input.uri;
    } else if (tab.input instanceof vscode16.TabInputTextDiff || tab.input instanceof vscode16.TabInputNotebookDiff) {
      uri = tab.input.modified;
    }
    return {
      tab,
      uri
    };
  }
};

// src/platform/tasks/common/tasksService.ts
var ITasksService = createDecorator("ITasksService");

// src/platform/tasks/vscode/tasksService.ts
var vscode17 = __toESM(require("vscode"));
init_errors();
init_lifecycle();
init_range();
var TasksService = class extends DisposableStore {
  constructor(workspaceService, fileSystemService, languageDiagnosticsService, logService) {
    super();
    this.workspaceService = workspaceService;
    this.fileSystemService = fileSystemService;
    this.languageDiagnosticsService = languageDiagnosticsService;
    this.logService = logService;
    this.latestTerminalForTaskDefinition = /* @__PURE__ */ new Map();
    this.add(vscode17.tasks.onDidStartTask((e) => {
      const terminal = e.execution.terminal;
      if (!terminal) {
        return;
      }
      this.latestTerminalForTaskDefinition.set(e.execution.task.definition, terminal);
      const closeListener = vscode17.window.onDidCloseTerminal((closedTerminal) => {
        if (closedTerminal === terminal && this.latestTerminalForTaskDefinition.has(e.execution.task.definition)) {
          this.latestTerminalForTaskDefinition.delete(e.execution.task.definition);
          closeListener.dispose();
        }
      });
      this.add(closeListener);
      const endListener = vscode17.tasks.onDidEndTask((ev) => {
        if (ev.execution.task.definition === e.execution.task.definition) {
          closeListener.dispose();
          endListener.dispose();
        }
      });
      this.add(endListener);
    }));
  }
  getTasksFromConfig(workspaceFolder) {
    const tasks2 = vscode17.workspace.getConfiguration("tasks", workspaceFolder);
    return tasks2.get("tasks") || [];
  }
  matchesTask(task, def) {
    return task.type === def.type && task.label === def.label;
  }
  hasTask(workspaceFolder, def) {
    const existingTasks = this.getTasksFromConfig(workspaceFolder);
    return existingTasks.some((t2) => this.matchesTask(t2, def));
  }
  /**
   * This is needed because when tasks exit, they're removed from the taskExecutions, but we might want to review the output of the task
   * after it has exited. This allows us to get the terminal for a task definition.
   * @param task
   */
  getTerminalForTask(taskDefinition) {
    for (const [key, terminal] of this.latestTerminalForTaskDefinition.entries()) {
      if (key.id) {
        const taskId = this._getTaskId(taskDefinition);
        if (taskId === key.id) {
          return terminal;
        }
      }
      if (taskDefinition.type === key.type && (key.label || key.script || key.command) && (!key.label || taskDefinition.label === key.label) && (!key.script || taskDefinition.script === key.script) && (!key.command || taskDefinition.command === key.command)) {
        return terminal;
      }
      this.logService.debug(`getTerminalForTask: no terminal found for task definition: ${JSON.stringify(taskDefinition)} matching ${JSON.stringify(key)}`);
      this.logService.debug(`getTerminalForTask: current stored terminals: ${[...this.latestTerminalForTaskDefinition.values()].map((t2) => t2.name).join(", ")}`);
    }
  }
  _getTaskId(taskDefinition) {
    if (!taskDefinition.type || taskDefinition.command === void 0 && taskDefinition.script === void 0) {
      return void 0;
    }
    return taskDefinition.type + "," + (taskDefinition.command ?? taskDefinition.script) + ",";
  }
  async getTaskConfigPosition(workspaceFolder, def) {
    const index = this.getTasksFromConfig(workspaceFolder).findIndex((t2) => this.matchesTask(t2, def));
    if (index === -1) {
      return void 0;
    }
    const uri = URI.joinPath(workspaceFolder, ".vscode", "tasks.json");
    let text2;
    try {
      const contents = await this.fileSystemService.readFile(uri);
      text2 = new TextDecoder().decode(contents);
    } catch {
      return void 0;
    }
    const root = parseTree2(text2);
    if (!root) {
      return void 0;
    }
    const node = findNodeAtLocation2(root, ["tasks", index]);
    if (!node) {
      return void 0;
    }
    const convert = new OffsetLineColumnConverter(text2);
    return {
      uri,
      range: Range.fromPositions(
        convert.offsetToPosition(node.offset),
        convert.offsetToPosition(node.offset + node.length)
      )
    };
  }
  async ensureTask(workspaceFolder, def, skipDefault) {
    const existingTasks = this.getTasksFromConfig(workspaceFolder);
    if (existingTasks.some((t2) => this.matchesTask(t2, def))) {
      return;
    }
    const tasks2 = vscode17.workspace.getConfiguration("tasks", workspaceFolder);
    await tasks2.update(
      "tasks",
      skipDefault ? [def] : [...existingTasks, def],
      vscode17.ConfigurationTarget.WorkspaceFolder
    );
  }
  isTaskActive(task) {
    const activeTasks = vscode17.tasks.taskExecutions;
    for (const a of activeTasks) {
      if (a.task.definition.type === task.type && a.task.name === task.label) {
        return true;
      }
    }
    return false;
  }
  getTasks(workspaceFolder) {
    if (workspaceFolder) {
      return this.getTasksFromConfig(workspaceFolder);
    }
    return this.workspaceService.getWorkspaceFolders().map((folder) => [folder, this.getTasksFromConfig(folder)]).filter(([, tasks2]) => tasks2.length > 0);
  }
  async getBestMatchingContributedTask(def) {
    const tasks2 = await vscode17.tasks.fetchTasks({ type: def?.type });
    let best;
    let bestOverlap = -1;
    tasks2.forEach((task) => {
      let currentOverlap = 0;
      for (const [key, value] of Object.entries(task.definition)) {
        if (!equals2(def[key], value)) {
          return;
        }
        currentOverlap++;
      }
      if (currentOverlap > bestOverlap) {
        best = task;
        bestOverlap = currentOverlap;
      }
    });
    return best;
  }
  async executeTask(def, token, workspaceFolder) {
    const disposables = new DisposableStore();
    try {
      let task = await this.getBestMatchingContributedTask(def);
      if (token.isCancellationRequested) {
        throw new CancellationError();
      }
      return await new Promise((resolve2) => {
        let processExitCode;
        disposables.add(vscode17.tasks.onDidEndTaskProcess((e) => {
          if (e.execution.task === task) {
            processExitCode = e.exitCode;
          }
        }));
        disposables.add(vscode17.tasks.onDidEndTask((e) => {
          if (e.execution.task === task) {
            if (processExitCode !== void 0 && processExitCode !== 0) {
              resolve2({ status: "error" /* Error */, error: new Error(`Task exited with code ${processExitCode}`) });
            } else {
              resolve2({ status: "finished" /* Finished */ });
            }
          }
        }));
        let adopted = false;
        let execution;
        function cancel() {
          resolve2({ status: "error" /* Error */, error: new CancellationError() });
          if (!adopted && execution) {
            execution.terminate();
          }
        }
        if (!def.isBackground) {
          disposables.add(token.onCancellationRequested(cancel));
        }
        if (task) {
          const existing = vscode17.tasks.taskExecutions.find((e) => equals2(e.task.definition, task.definition));
          adopted = !!existing;
          Promise.resolve(existing || vscode17.tasks.executeTask(task)).then((_execution) => {
            execution = _execution;
            if (token.isCancellationRequested) {
              cancel();
            } else if (task.isBackground) {
              let resolved = false;
              disposables.add(vscode17.tasks.onDidEndTaskProblemMatchers(async (e) => {
                resolved = true;
                if (e.execution.task === task) {
                  if (e.hasErrors) {
                    let diagnostics = [];
                    if (workspaceFolder) {
                      diagnostics = this.languageDiagnosticsService.getAllDiagnostics().map((d) => d[0] + " " + d[1].map((d2) => d2.message).join(", "));
                    }
                    resolve2({ status: "error" /* Error */, error: new Error("Task exited with errors in the following files: " + diagnostics.join(", ")) });
                  } else {
                    resolve2({ status: "finished" /* Finished */ });
                  }
                }
              }));
              setTimeout(() => {
                if (!resolved) {
                  resolve2({ status: "started" /* Started */ });
                }
              }, task?.isBackground && task.problemMatchers.length ? 1e4 : 0);
            } else {
              resolve2({ status: "started" /* Started */ });
            }
          }, (error2) => resolve2({ status: "error" /* Error */, error: error2 }));
        } else {
          vscode17.commands.executeCommand("workbench.action.tasks.runTask", def.label || def);
          disposables.add(vscode17.tasks.onDidStartTask((e) => {
            task = e.execution.task;
            resolve2({ status: "started" /* Started */ });
          }));
          disposables.add(vscode17.tasks.onDidEndTask((e) => {
            if (e.execution.task.name === def.label) {
              if (processExitCode !== void 0 && processExitCode !== 0) {
                resolve2({ status: "error" /* Error */, error: new Error(`Task exited with code ${processExitCode}`) });
              } else {
                resolve2({ status: "finished" /* Finished */ });
              }
            }
          }));
        }
      });
    } finally {
      disposables.dispose();
    }
  }
};
TasksService = __decorateClass([
  __decorateParam(0, IWorkspaceService),
  __decorateParam(1, IFileSystemService),
  __decorateParam(2, ILanguageDiagnosticsService),
  __decorateParam(3, ILogService)
], TasksService);

// src/platform/terminal/common/terminalService.ts
init_event();
init_lifecycle();
var ITerminalService = createDecorator("ITerminalService");
var NullTerminalService = class _NullTerminalService extends Disposable {
  constructor() {
    super(...arguments);
    this._onDidWriteTerminalData = this._register(new Emitter());
    this.onDidWriteTerminalData = this._onDidWriteTerminalData.event;
    this._onDidChangeTerminalShellIntegration = this._register(new Emitter());
    this.onDidChangeTerminalShellIntegration = this._onDidChangeTerminalShellIntegration.event;
    this._onDidEndTerminalShellExecution = this._register(new Emitter());
    this.onDidEndTerminalShellExecution = this._onDidEndTerminalShellExecution.event;
    this._onDidCloseTerminal = this._register(new Emitter());
    this.onDidCloseTerminal = this._onDidCloseTerminal.event;
  }
  static {
    this.Instance = new _NullTerminalService();
  }
  get terminalBuffer() {
    return "";
  }
  get terminalLastCommand() {
    return void 0;
  }
  get terminalSelection() {
    return "";
  }
  get terminalShellType() {
    return "";
  }
  async getCwdForSession(sessionId) {
    return Promise.resolve(void 0);
  }
  async getCopilotTerminals(sessionId) {
    return Promise.resolve([]);
  }
  getTerminalsWithSessionInfo() {
    throw new Error("Method not implemented.");
  }
  getToolTerminalForSession(sessionId) {
    throw new Error("Method not implemented.");
  }
  async associateTerminalWithSession(terminal, sessionId, shellIntegrationquality) {
    Promise.resolve();
  }
  createTerminal(name, shellPath, shellArgs) {
    return {};
  }
  get terminals() {
    return [];
  }
  getBufferForTerminal(terminal, maxLines) {
    return "";
  }
  getBufferWithPid(pid, maxChars) {
    return Promise.resolve("");
  }
  getLastCommandForTerminal(terminal) {
    return void 0;
  }
  contributePath(contributor, pathLocation, description, prepend) {
  }
  removePathContribution(contributor) {
  }
};

// src/platform/terminal/vscode/terminalServiceImpl.ts
var import_vscode16 = require("vscode");
init_arrays();
init_lifecycle();

// src/platform/terminal/vscode/terminalBufferListener.ts
var import_vscode15 = require("vscode");
init_strings();
var terminalBuffers = /* @__PURE__ */ new Map();
var terminalCommands = /* @__PURE__ */ new Map();
function getActiveTerminalBuffer() {
  const activeTerminal = import_vscode15.window.activeTerminal;
  if (activeTerminal === void 0) {
    return "";
  }
  return terminalBuffers.get(activeTerminal)?.join("") || "";
}
function getBufferForTerminal(terminal, maxChars = 16e3) {
  if (!terminal) {
    return "";
  }
  const buffer = terminalBuffers.get(terminal);
  if (!buffer) {
    return "";
  }
  const joined = buffer.join("");
  const start = Math.max(0, joined.length - maxChars);
  return joined.slice(start);
}
function getLastCommandForTerminal(terminal) {
  return terminalCommands.get(terminal)?.at(-1);
}
function getActiveTerminalLastCommand() {
  const activeTerminal = import_vscode15.window.activeTerminal;
  if (activeTerminal === void 0) {
    return void 0;
  }
  return terminalCommands.get(activeTerminal)?.at(-1);
}
function getActiveTerminalSelection() {
  try {
    return import_vscode15.window.activeTerminal?.selection ?? "";
  } catch {
    return "";
  }
}
var lastDetectedShellType;
function getActiveTerminalShellType() {
  const activeTerminal = import_vscode15.window.activeTerminal;
  if (activeTerminal?.state.shell) {
    return activeTerminal.state.shell;
  }
  if (activeTerminal && "shellPath" in activeTerminal.creationOptions) {
    const shellPath = activeTerminal.creationOptions.shellPath;
    if (shellPath) {
      let candidateShellType;
      const shellFile = basename(shellPath);
      if (shellFile === "bash.exe") {
        candidateShellType = "Git Bash";
      } else {
        const shellFileWithoutExtension = shellFile.replace(/\..+/, "");
        switch (shellFileWithoutExtension) {
          case "pwsh":
          case "powershell":
            candidateShellType = "powershell";
            break;
          case "":
            break;
          default:
            candidateShellType = shellFileWithoutExtension;
        }
      }
      if (candidateShellType) {
        lastDetectedShellType = candidateShellType;
        return candidateShellType;
      }
    }
  }
  if (lastDetectedShellType) {
    return lastDetectedShellType;
  }
  return platform2 === "win32" ? "powershell" : "bash";
}
function appendLimitedWindow2(target, data) {
  target.push(data);
  if (target.length > 40) {
    target.shift();
  }
}
function installTerminalBufferListeners() {
  return [
    import_vscode15.window.onDidChangeTerminalState((t2) => {
      if (import_vscode15.window.activeTerminal && t2.processId === import_vscode15.window.activeTerminal.processId) {
        const newShellType = t2.state.shell;
        if (newShellType && newShellType !== lastDetectedShellType) {
          lastDetectedShellType = newShellType;
        }
      }
    }),
    import_vscode15.window.onDidWriteTerminalData((e) => {
      let dataBuffer = terminalBuffers.get(e.terminal);
      if (!dataBuffer) {
        dataBuffer = [];
        terminalBuffers.set(e.terminal, dataBuffer);
      }
      appendLimitedWindow2(dataBuffer, removeAnsiEscapeCodes(e.data));
    }),
    import_vscode15.window.onDidExecuteTerminalCommand((e) => {
      let commands13 = terminalCommands.get(e.terminal);
      if (!commands13) {
        commands13 = [];
        terminalCommands.set(e.terminal, commands13);
      }
      appendLimitedWindow2(commands13, e);
    }),
    import_vscode15.window.onDidCloseTerminal((e) => {
      terminalBuffers.delete(e);
    })
  ];
}

// src/platform/terminal/vscode/terminalServiceImpl.ts
var TerminalServiceImpl = class extends Disposable {
  constructor(context) {
    super();
    this.context = context;
    this.pathContributions = /* @__PURE__ */ new Map();
    this.context.environmentVariableCollection.delete("GH_TOKEN");
    for (const l of installTerminalBufferListeners()) {
      this._register(l);
    }
  }
  get terminals() {
    return import_vscode16.window.terminals;
  }
  get onDidChangeTerminalShellIntegration() {
    return import_vscode16.window.onDidChangeTerminalShellIntegration;
  }
  get onDidEndTerminalShellExecution() {
    return import_vscode16.window.onDidEndTerminalShellExecution;
  }
  get onDidCloseTerminal() {
    return import_vscode16.window.onDidCloseTerminal;
  }
  get onDidWriteTerminalData() {
    return import_vscode16.window.onDidWriteTerminalData;
  }
  createTerminal(name, shellPath, shellArgs) {
    const terminal = import_vscode16.window.createTerminal(name, shellPath, shellArgs);
    return terminal;
  }
  getBufferForTerminal(terminal, maxChars) {
    return getBufferForTerminal(terminal, maxChars);
  }
  async getBufferWithPid(pid, maxChars) {
    let terminal;
    for (const t2 of this.terminals) {
      const tPid = await t2.processId;
      if (tPid === pid) {
        terminal = t2;
        break;
      }
    }
    if (terminal) {
      return this.getBufferForTerminal(terminal, maxChars);
    }
    return "";
  }
  getLastCommandForTerminal(terminal) {
    return getLastCommandForTerminal(terminal);
  }
  get terminalBuffer() {
    return getActiveTerminalBuffer();
  }
  get terminalLastCommand() {
    return getActiveTerminalLastCommand();
  }
  get terminalSelection() {
    return getActiveTerminalSelection();
  }
  get terminalShellType() {
    return getActiveTerminalShellType();
  }
  contributePath(contributor, pathLocation, description, prepend = false) {
    this.pathContributions.set(contributor, { path: pathLocation, description, prepend });
    this.updateEnvironmentPath();
  }
  removePathContribution(contributor) {
    this.pathContributions.delete(contributor);
    this.updateEnvironmentPath();
  }
  updateEnvironmentPath() {
    const pathVariable = "PATH";
    this.context.environmentVariableCollection.delete(pathVariable);
    if (this.pathContributions.size === 0) {
      return;
    }
    const allDescriptions = coalesce(Array.from(this.pathContributions.values()).map((c) => c.description && typeof c.description === "string" ? c.description : void 0).filter((d) => d));
    let descriptions = "";
    if (allDescriptions.length === 1) {
      descriptions = allDescriptions[0];
    } else if (allDescriptions.length > 1) {
      descriptions = `${allDescriptions.slice(0, -1).join(", ")} ${t("and")} ${allDescriptions[allDescriptions.length - 1]}`;
    }
    const allCommands = coalesce(Array.from(this.pathContributions.values()).map((c) => c.description && typeof c.description !== "string" ? `\`${c.description.command}\`` : void 0).filter((d) => d));
    let commandsDescription = "";
    if (allCommands.length === 1) {
      commandsDescription = t("Enables use of {0} command in the terminal", allCommands[0]);
    } else if (allCommands.length > 1) {
      const commands13 = `${allCommands.slice(0, -1).join(", ")} ${t("and")} ${allCommands[allCommands.length - 1]}`;
      commandsDescription = t("Enables use of {0} commands in the terminal", commands13);
    }
    const description = [descriptions, commandsDescription].filter((d) => d).join(" and ");
    this.context.environmentVariableCollection.description = description || "Enables additional commands in the terminal.";
    const allPaths = Array.from(this.pathContributions.values()).map((c) => c.path);
    if (Array.from(this.pathContributions.values()).some((c) => c.prepend)) {
      const pathVariableChange = allPaths.join(delimiter) + delimiter;
      this.context.environmentVariableCollection.prepend(pathVariable, pathVariableChange);
    } else {
      const pathVariableChange = delimiter + allPaths.join(delimiter);
      this.context.environmentVariableCollection.append(pathVariable, pathVariableChange);
    }
  }
};
TerminalServiceImpl = __decorateClass([
  __decorateParam(0, IVSCodeExtensionContext)
], TerminalServiceImpl);

// src/platform/testing/common/testProvider.ts
var ITestProvider = createDecorator("ITestProvider");

// src/platform/testing/vscode/testProviderImpl.ts
var vscode18 = __toESM(require("vscode"));
init_arraysFind();
init_iterator();
init_lifecycle();
init_map();
var TestProvider = class extends Disposable {
  constructor() {
    super();
    /** Position then status-ordered arrays of tests in the document for the last test result */
    this.resultsDocs = new ResourceMap();
    this._register(vscode18.tests.onDidChangeTestResults(() => this.setHasFailureContextKey()));
    this.setHasFailureContextKey();
  }
  setHasFailureContextKey() {
    vscode18.commands.executeCommand(
      "setContext",
      "puku.chat.fixTestFailures.hasFailure",
      !!Iterable.first(this.getAllFailures())
    );
  }
  get onDidChangeResults() {
    return vscode18.tests.onDidChangeTestResults;
  }
  get lastResultsFrom() {
    return vscode18.tests.testResults.find((r) => r.completedAt && r.results.length)?.completedAt;
  }
  /** @inheritdoc */
  getAllFailures() {
    const r = vscode18.tests.testResults.find((r2) => r2.results.length);
    if (!r) {
      return Iterable.empty();
    }
    return this.dfsFailures(r.results);
  }
  /** @inheritdoc */
  getLastFailureFor(testItem) {
    const chain = [];
    for (let i = testItem; i; i = i.parent) {
      chain.push(i.id);
    }
    chain.reverse();
    for (const testRun of vscode18.tests.testResults) {
      for (const _node of testRun.results) {
        let node = _node;
        for (const path of chain) {
          node = node.children.find((c) => c.id === path);
          if (!node) {
            break;
          }
        }
        const failingTask = node?.taskStates.find((t2) => t2.state === vscode18.TestResultState.Failed || t2.state === vscode18.TestResultState.Errored);
        if (failingTask && node) {
          return { snapshot: node, task: failingTask };
        }
      }
    }
  }
  /** @inheritdoc */
  getFailureAtPosition(uri, position) {
    const r = vscode18.tests.testResults.find((r2) => r2.results.length);
    if (this.resultsDocsAreForTestRun !== r) {
      this.makeResultsDocs(r);
    }
    if (!r) {
      return void 0;
    }
    const results = this.resultsDocs.get(uri) || [];
    const test2 = findLast(results, (i) => !!i.range && i.range.start.line <= position.line);
    if (!test2) {
      return void 0;
    }
    for (const task of test2.taskStates) {
      if (task.state === vscode18.TestResultState.Failed || task.state === vscode18.TestResultState.Errored) {
        return { snapshot: test2, task };
      }
    }
    return void 0;
  }
  /** @inheritdoc */
  async hasAnyTests() {
    return !!(await vscode18.commands.executeCommand("vscode.testing.getControllersWithTests")).length;
  }
  /** @inheritdoc */
  async hasTestsInUri(uri) {
    try {
      const r = await vscode18.commands.executeCommand("vscode.testing.getTestsInFile", uri);
      return !!r.length;
    } catch {
      return false;
    }
  }
  /**
   * DFS is important because we want to get the most-granular tests possible
   * rather then e.g. suites that would be less relevant.
   */
  *dfsFailures(tests2) {
    for (const test2 of tests2) {
      yield* this.dfsFailures(test2.children);
      for (const task of test2.taskStates) {
        if (task.state === vscode18.TestResultState.Failed || task.state === vscode18.TestResultState.Errored) {
          yield { snapshot: test2, task };
        }
      }
    }
  }
  makeResultsDocs(r) {
    this.resultsDocs.clear();
    this.resultsDocsAreForTestRun = r;
    if (!r) {
      return;
    }
    const queue = [r.results];
    while (queue.length) {
      for (const result of queue.pop()) {
        queue.push(result.children);
        if (!result.uri) {
          continue;
        }
        const arr = this.resultsDocs.get(result.uri);
        if (!arr) {
          this.resultsDocs.set(result.uri, [result]);
        } else {
          arr.push(result);
        }
      }
    }
    const zeroRange = new vscode18.Range(0, 0, 0, 0);
    for (const results of this.resultsDocs.values()) {
      results.sort(
        (a, b) => (
          // sort by location  (ascending)
          (a.range || zeroRange).start.compareTo((b.range || zeroRange).start) || compareTaskStates(a.taskStates, b.taskStates)
        )
      );
    }
  }
};
var compareTaskStates = (a, b) => {
  let maxA = 0;
  let maxB = 0;
  for (const ta of a) {
    maxA = Math.max(maxA, ta.state);
  }
  for (const tb of b) {
    maxB = Math.max(maxB, tb.state);
  }
  return maxA - maxB;
};

// src/platform/workbench/vscode/workbenchServiceImpt.ts
var vscode19 = __toESM(require("vscode"));
var WorkbenchServiceImpl = class {
  getAllExtensions() {
    return vscode19.extensions.all;
  }
  async getAllCommands(filterByPreCondition) {
    return vscode19.commands.executeCommand("_getAllCommands", filterByPreCondition);
  }
  async getAllSettings() {
    return vscode19.commands.executeCommand("_getAllSettings");
  }
};

// src/platform/workspace/vscode/workspaceServiceImpl.ts
var import_vscode17 = require("vscode");

// src/platform/remoteRepositories/common/utils.ts
function isGitHubRemoteRepository(uri) {
  return uri.scheme === "vscode-vfs" && uri.authority.startsWith("github");
}

// src/platform/workspace/vscode/workspaceServiceImpl.ts
var ExtensionTextDocumentManager = class extends AbstractWorkspaceService {
  constructor(_logService, _remoteRepositoriesService) {
    super();
    this._logService = _logService;
    this._remoteRepositoriesService = _remoteRepositoriesService;
    this.onDidOpenTextDocument = import_vscode17.workspace.onDidOpenTextDocument;
    this.onDidChangeTextDocument = import_vscode17.workspace.onDidChangeTextDocument;
    this.onDidOpenNotebookDocument = import_vscode17.workspace.onDidOpenNotebookDocument;
    this.onDidCloseNotebookDocument = import_vscode17.workspace.onDidCloseNotebookDocument;
    this.onDidCloseTextDocument = import_vscode17.workspace.onDidCloseTextDocument;
    this.onDidChangeWorkspaceFolders = import_vscode17.workspace.onDidChangeWorkspaceFolders;
    this.onDidChangeNotebookDocument = import_vscode17.workspace.onDidChangeNotebookDocument;
    this.onDidChangeTextEditorSelection = import_vscode17.window.onDidChangeTextEditorSelection;
  }
  get textDocuments() {
    return import_vscode17.workspace.textDocuments;
  }
  async openTextDocument(uri) {
    return await import_vscode17.workspace.openTextDocument(uri);
  }
  get fs() {
    return import_vscode17.workspace.fs;
  }
  async showTextDocument(document2) {
    await import_vscode17.window.showTextDocument(document2);
  }
  async openNotebookDocument(arg1, arg2) {
    if (typeof arg1 === "string") {
      return await import_vscode17.workspace.openNotebookDocument(arg1, arg2);
    } else {
      return findNotebook(arg1, import_vscode17.workspace.notebookDocuments) || await import_vscode17.workspace.openNotebookDocument(arg1);
    }
  }
  get notebookDocuments() {
    return import_vscode17.workspace.notebookDocuments;
  }
  getWorkspaceFolders() {
    return import_vscode17.workspace.workspaceFolders?.map((f) => f.uri) ?? [];
  }
  getWorkspaceFolderName(workspaceFolderUri) {
    const workspaceFolder = import_vscode17.workspace.getWorkspaceFolder(workspaceFolderUri);
    if (workspaceFolder) {
      return workspaceFolder.name;
    }
    return "";
  }
  asRelativePath(pathOrUri, includeWorkspaceFolder) {
    return import_vscode17.workspace.asRelativePath(pathOrUri, includeWorkspaceFolder);
  }
  applyEdit(edit) {
    return import_vscode17.workspace.applyEdit(edit);
  }
  // NOTE: I don't think it's possible to have a multi-root workspace with virtual workspaces
  // so we shouldn't need to handle when the workspace folders change... but something to be
  // aware of if we ever do support multi-root workspaces
  ensureWorkspaceIsFullyLoaded() {
    this._fullyLoadedPromise ??= (async () => {
      for (const uri of this.getWorkspaceFolders()) {
        if (isGitHubRemoteRepository(uri)) {
          this._logService.debug(`Preloading virtual workspace contents for ${uri}`);
          try {
            const result = await this._remoteRepositoriesService.loadWorkspaceContents(uri);
            this._logService.info(`loading virtual workspace contents resulted in ${result} for: ${uri}`);
          } catch (e) {
            this._logService.error(`Error loading virtual workspace contents for ${uri}: ${e}`);
          }
        }
      }
    })();
    return this._fullyLoadedPromise;
  }
  async showWorkspaceFolderPicker() {
    const workspaceFolders = this.getWorkspaceFolders();
    if (workspaceFolders) {
      return import_vscode17.window.showWorkspaceFolderPick();
    }
    return;
  }
};
ExtensionTextDocumentManager = __decorateClass([
  __decorateParam(0, ILogService),
  __decorateParam(1, IRemoteRepositoriesService)
], ExtensionTextDocumentManager);

// src/extension/git/common/mergeConflictService.ts
var IMergeConflictService = createDecorator("IMergeConflictService");

// src/extension/git/vscode/mergeConflictServiceImpl.ts
var vscode21 = __toESM(require("vscode"));
init_lifecycle();

// src/extension/git/vscode/mergeConflictParser.ts
var vscode20 = __toESM(require("vscode"));
var startHeaderMarker = "<<<<<<<";
var commonAncestorsMarker = "|||||||";
var splitterMarker = "=======";
var endFooterMarker = ">>>>>>>";
var MergeConflictParser = class _MergeConflictParser {
  static scanDocument(document2) {
    let currentConflict = null;
    const conflictDescriptors = [];
    for (let i = 0; i < document2.lineCount; i++) {
      const line = document2.lineAt(i);
      if (!line || line.isEmptyOrWhitespace) {
        continue;
      }
      if (line.text.startsWith(startHeaderMarker)) {
        if (currentConflict !== null) {
          currentConflict = null;
          break;
        }
        currentConflict = { startHeader: line, commonAncestors: [] };
      } else if (currentConflict && !currentConflict.splitter && line.text.startsWith(commonAncestorsMarker)) {
        currentConflict.commonAncestors.push(line);
      } else if (currentConflict && !currentConflict.splitter && line.text === splitterMarker) {
        currentConflict.splitter = line;
      } else if (currentConflict && line.text.startsWith(endFooterMarker)) {
        currentConflict.endFooter = line;
        const completeDescriptor = _MergeConflictParser.scanItemToMergeConflictDescriptor(document2, currentConflict);
        if (completeDescriptor !== null) {
          conflictDescriptors.push(completeDescriptor);
        }
        currentConflict = null;
      }
    }
    return conflictDescriptors.filter(Boolean);
  }
  static containsConflict(document2) {
    if (!document2) {
      return false;
    }
    const text2 = document2.getText();
    return text2.includes(startHeaderMarker) && text2.includes(endFooterMarker);
  }
  static scanItemToMergeConflictDescriptor(document2, scanned) {
    if (!scanned.startHeader || !scanned.splitter || !scanned.endFooter) {
      return null;
    }
    const tokenAfterCurrentBlock = scanned.commonAncestors[0] || scanned.splitter;
    return {
      current: {
        header: scanned.startHeader.range,
        decoratorContent: new vscode20.Range(
          scanned.startHeader.rangeIncludingLineBreak.end,
          _MergeConflictParser.shiftBackOneCharacter(document2, tokenAfterCurrentBlock.range.start, scanned.startHeader.rangeIncludingLineBreak.end)
        ),
        // Current content is range between header (shifted for linebreak) and splitter or common ancestors mark start
        content: new vscode20.Range(
          scanned.startHeader.rangeIncludingLineBreak.end,
          tokenAfterCurrentBlock.range.start
        ),
        name: scanned.startHeader.text.substring(startHeaderMarker.length + 1)
      },
      commonAncestors: scanned.commonAncestors.map((currentTokenLine, index, commonAncestors) => {
        const nextTokenLine = commonAncestors[index + 1] || scanned.splitter;
        return {
          header: currentTokenLine.range,
          decoratorContent: new vscode20.Range(
            currentTokenLine.rangeIncludingLineBreak.end,
            _MergeConflictParser.shiftBackOneCharacter(document2, nextTokenLine.range.start, currentTokenLine.rangeIncludingLineBreak.end)
          ),
          // Each common ancestors block is range between one common ancestors token
          // (shifted for linebreak) and start of next common ancestors token or splitter
          content: new vscode20.Range(
            currentTokenLine.rangeIncludingLineBreak.end,
            nextTokenLine.range.start
          ),
          name: currentTokenLine.text.substring(commonAncestorsMarker.length + 1)
        };
      }),
      splitter: scanned.splitter.range,
      incoming: {
        header: scanned.endFooter.range,
        decoratorContent: new vscode20.Range(
          scanned.splitter.rangeIncludingLineBreak.end,
          _MergeConflictParser.shiftBackOneCharacter(document2, scanned.endFooter.range.start, scanned.splitter.rangeIncludingLineBreak.end)
        ),
        // Incoming content is range between splitter (shifted for linebreak) and footer start
        content: new vscode20.Range(
          scanned.splitter.rangeIncludingLineBreak.end,
          scanned.endFooter.range.start
        ),
        name: scanned.endFooter.text.substring(endFooterMarker.length + 1)
      },
      // Entire range is between current header start and incoming header end (including line break)
      range: new vscode20.Range(scanned.startHeader.range.start, scanned.endFooter.rangeIncludingLineBreak.end)
    };
  }
  static shiftBackOneCharacter(document2, range, unlessEqual) {
    if (range.isEqual(unlessEqual)) {
      return range;
    }
    let line = range.line;
    let character = range.character - 1;
    if (character < 0) {
      line--;
      character = document2.lineAt(line).range.end.character;
    }
    return new vscode20.Position(line, character);
  }
};

// src/extension/git/vscode/mergeConflictServiceImpl.ts
var MergeConflictServiceImpl = class extends Disposable {
  constructor(gitService, ignoreService) {
    super();
    this.gitService = gitService;
    this.ignoreService = ignoreService;
  }
  async resolveMergeConflicts(resources, cancellationToken) {
    if (cancellationToken?.isCancellationRequested) {
      return;
    }
    const attachFiles = [];
    const attachHistoryItemChanges = [];
    const attachHistoryItemChangeRanges = [];
    for (const resource of resources) {
      if (await this.ignoreService.isPukuIgnored(resource, cancellationToken)) {
        continue;
      }
      const textDocument = await vscode21.workspace.openTextDocument(resource);
      if (!MergeConflictParser.containsConflict(textDocument)) {
        continue;
      }
      const conflicts = MergeConflictParser.scanDocument(textDocument);
      if (conflicts.length === 0) {
        continue;
      }
      attachFiles.push(resource);
      const currentName = conflicts[0].current.name;
      const incomingName = conflicts[0].incoming.name;
      const mergeBase = await this.gitService.getMergeBase(resource, currentName, incomingName);
      if (mergeBase) {
        attachHistoryItemChanges.push({
          uri: toGitUri(resource, mergeBase),
          historyItemId: mergeBase
        });
        attachHistoryItemChangeRanges.push({
          start: {
            uri: toGitUri(resource, mergeBase),
            historyItemId: mergeBase
          },
          end: {
            uri: toGitUri(resource, currentName),
            historyItemId: currentName
          }
        });
        attachHistoryItemChangeRanges.push({
          start: {
            uri: toGitUri(resource, mergeBase),
            historyItemId: mergeBase
          },
          end: {
            uri: toGitUri(resource, incomingName),
            historyItemId: incomingName
          }
        });
      }
    }
    if (cancellationToken?.isCancellationRequested) {
      return;
    }
    if (attachFiles.length > 0) {
      await vscode21.commands.executeCommand("workbench.action.chat.open", {
        mode: "agent",
        attachFiles,
        attachHistoryItemChanges,
        attachHistoryItemChangeRanges,
        query: "Resolve all merge conflicts"
      });
    }
  }
};
MergeConflictServiceImpl = __decorateClass([
  __decorateParam(0, IGitService),
  __decorateParam(1, IIgnoreService)
], MergeConflictServiceImpl);

// src/extension/onboardDebug/common/launchConfigService.ts
var ILaunchConfigService = createDecorator("ILaunchConfigService");

// src/extension/onboardDebug/vscode/launchConfigService.ts
var vscode22 = __toESM(require("vscode"));
var LaunchConfigService = class {
  /** @inheritdoc */
  async add(workspaceFolder, toAdd) {
    const config3 = vscode22.workspace.getConfiguration("launch", workspaceFolder);
    const existingConfigs = config3.get("configurations");
    if (toAdd.configurations.length) {
      await config3.update(
        "configurations",
        [...toAdd.configurations, ...existingConfigs || []],
        vscode22.ConfigurationTarget.WorkspaceFolder
      );
    }
    const existingInputs = config3.get("inputs");
    if (toAdd.inputs?.length) {
      await config3.update(
        "inputs",
        [...toAdd.inputs, ...existingInputs || []],
        vscode22.ConfigurationTarget.WorkspaceFolder
      );
    }
  }
  /** @inheritdoc */
  async show(workspaceFolder, showConfigName) {
    const fileUri = URI.joinPath(workspaceFolder, ".vscode", "launch.json");
    let document2;
    try {
      document2 = await vscode22.workspace.openTextDocument(fileUri);
    } catch {
      return;
    }
    let range;
    if (showConfigName) {
      try {
        const text2 = document2.getText();
        const objectOffsetStack = [];
        let didFind = false;
        visit2(text2, {
          onObjectBegin(offset) {
            objectOffsetStack.push(offset);
          },
          onObjectEnd(endOffset, length) {
            const startOffset = objectOffsetStack.pop();
            if (didFind) {
              didFind = false;
              const convert = new OffsetLineColumnConverter(text2);
              const start = convert.offsetToPosition(startOffset);
              const end = convert.offsetToPosition(endOffset + length);
              range = new vscode22.Range(start.lineNumber - 1, start.column - 1, end.lineNumber - 1, end.column - 1);
            }
          },
          onLiteralValue(value, _offset, _length, _startLine, _startCharacter, pathSupplier) {
            if (value === showConfigName) {
              const path = pathSupplier();
              if (path[path.length - 1] === "name") {
                didFind = true;
              }
            }
          }
        });
      } catch {
      }
    }
    await vscode22.window.showTextDocument(document2, { selection: range });
  }
  /** @inheritdoc */
  async launch(config3) {
    const debugConfig = "configurations" in config3 && config3.configurations.length ? config3.configurations[0] : config3;
    if (!debugConfig) {
      return;
    }
    await vscode22.debug.startDebugging(void 0, debugConfig);
  }
  async resolveConfigurationInputs(launchJson, defaults, interactor) {
    if (!interactor) {
      interactor = {
        isGenerating: () => {
        },
        ensureTask: () => Promise.resolve(true),
        prompt: async (text2, defaultValue) => {
          return await vscode22.window.showInputBox({
            prompt: text2,
            value: defaultValue,
            ignoreFocusOut: true
          });
        }
      };
    }
    const inputs = /* @__PURE__ */ new Map();
    for (const input of launchJson.inputs || []) {
      const key = `\${input:${input.id}}`;
      const value = await interactor.prompt(input.description, defaults?.get(key));
      if (value === void 0) {
        return void 0;
      }
      inputs.set(key, value);
    }
    const config3 = cloneAndChange(launchJson.configurations[0], (orig) => {
      if (typeof orig === "string") {
        for (const [key, value] of inputs) {
          orig = orig.replaceAll(key, value);
        }
        return orig;
      }
    });
    return { config: config3, inputs };
  }
};

// src/extension/tools/common/editToolLearningService.ts
init_map();
init_types();

// src/extension/tools/common/toolNames.ts
var ToolName = /* @__PURE__ */ ((ToolName3) => {
  ToolName3["ApplyPatch"] = "apply_patch";
  ToolName3["Codebase"] = "semantic_search";
  ToolName3["VSCodeAPI"] = "get_vscode_api";
  ToolName3["TestFailure"] = "test_failure";
  ToolName3["RunTests"] = "run_tests";
  ToolName3["FindFiles"] = "file_search";
  ToolName3["FindTextInFiles"] = "grep_search";
  ToolName3["ReadFile"] = "read_file";
  ToolName3["ListDirectory"] = "list_dir";
  ToolName3["GetErrors"] = "get_errors";
  ToolName3["GetScmChanges"] = "get_changed_files";
  ToolName3["UpdateUserPreferences"] = "update_user_preferences";
  ToolName3["ReadProjectStructure"] = "read_project_structure";
  ToolName3["CreateNewWorkspace"] = "create_new_workspace";
  ToolName3["CreateNewJupyterNotebook"] = "create_new_jupyter_notebook";
  ToolName3["SearchWorkspaceSymbols"] = "search_workspace_symbols";
  ToolName3["Usages"] = "list_code_usages";
  ToolName3["EditFile"] = "insert_edit_into_file";
  ToolName3["CreateFile"] = "create_file";
  ToolName3["ReplaceString"] = "replace_string_in_file";
  ToolName3["MultiReplaceString"] = "multi_replace_string_in_file";
  ToolName3["EditNotebook"] = "edit_notebook_file";
  ToolName3["RunNotebookCell"] = "run_notebook_cell";
  ToolName3["GetNotebookSummary"] = "puku_getNotebookSummary";
  ToolName3["ReadCellOutput"] = "read_notebook_cell_output";
  ToolName3["InstallExtension"] = "install_extension";
  ToolName3["FetchWebPage"] = "fetch_webpage";
  ToolName3["Memory"] = "memory";
  ToolName3["FindTestFiles"] = "test_search";
  ToolName3["GetProjectSetupInfo"] = "get_project_setup_info";
  ToolName3["SearchViewResults"] = "get_search_view_results";
  ToolName3["DocInfo"] = "get_doc_info";
  ToolName3["GithubRepo"] = "github_repo";
  ToolName3["SimpleBrowser"] = "open_simple_browser";
  ToolName3["CreateDirectory"] = "create_directory";
  ToolName3["RunVscodeCmd"] = "run_vscode_command";
  ToolName3["CoreManageTodoList"] = "manage_todo_list";
  ToolName3["CoreRunInTerminal"] = "run_in_terminal";
  ToolName3["CoreGetTerminalOutput"] = "get_terminal_output";
  ToolName3["CoreTerminalSelection"] = "terminal_selection";
  ToolName3["CoreTerminalLastCommand"] = "terminal_last_command";
  ToolName3["CoreCreateAndRunTask"] = "create_and_run_task";
  ToolName3["CoreRunTask"] = "run_task";
  ToolName3["CoreGetTaskOutput"] = "get_task_output";
  ToolName3["CoreRunTest"] = "runTests";
  ToolName3["ToolReplay"] = "tool_replay";
  ToolName3["EditFilesPlaceholder"] = "edit_files";
  ToolName3["CoreRunSubagent"] = "runSubagent";
  ToolName3["CoreConfirmationTool"] = "vscode_get_confirmation";
  ToolName3["CoreTerminalConfirmationTool"] = "vscode_get_terminal_confirmation";
  return ToolName3;
})(ToolName || {});
var ContributedToolName = /* @__PURE__ */ ((ContributedToolName2) => {
  ContributedToolName2["ApplyPatch"] = "puku_applyPatch";
  ContributedToolName2["Codebase"] = "puku_searchCodebase";
  ContributedToolName2["SearchWorkspaceSymbols"] = "puku_searchWorkspaceSymbols";
  ContributedToolName2["Usages"] = "puku_listCodeUsages";
  ContributedToolName2["UpdateUserPreferences"] = "puku_updateUserPreferences";
  ContributedToolName2["VSCodeAPI"] = "puku_getVSCodeAPI";
  ContributedToolName2["TestFailure"] = "puku_testFailure";
  ContributedToolName2["RunTests"] = "puku_runTests1";
  ContributedToolName2["FindFiles"] = "puku_findFiles";
  ContributedToolName2["FindTextInFiles"] = "puku_findTextInFiles";
  ContributedToolName2["ReadFile"] = "puku_readFile";
  ContributedToolName2["ListDirectory"] = "puku_listDirectory";
  ContributedToolName2["GetErrors"] = "puku_getErrors";
  ContributedToolName2["DocInfo"] = "puku_getDocInfo";
  ContributedToolName2["GetScmChanges"] = "puku_getChangedFiles";
  ContributedToolName2["ReadProjectStructure"] = "puku_readProjectStructure";
  ContributedToolName2["CreateNewWorkspace"] = "puku_createNewWorkspace";
  ContributedToolName2["CreateNewJupyterNotebook"] = "puku_createNewJupyterNotebook";
  ContributedToolName2["EditFile"] = "puku_insertEdit";
  ContributedToolName2["CreateFile"] = "puku_createFile";
  ContributedToolName2["ReplaceString"] = "puku_replaceString";
  ContributedToolName2["MultiReplaceString"] = "puku_multiReplaceString";
  ContributedToolName2["EditNotebook"] = "puku_editNotebook";
  ContributedToolName2["RunNotebookCell"] = "puku_runNotebookCell";
  ContributedToolName2["GetNotebookSummary"] = "puku_getNotebookSummary";
  ContributedToolName2["ReadCellOutput"] = "puku_readNotebookCellOutput";
  ContributedToolName2["InstallExtension"] = "puku_installExtension";
  ContributedToolName2["FetchWebPage"] = "puku_fetchWebPage";
  ContributedToolName2["Memory"] = "puku_memory";
  ContributedToolName2["FindTestFiles"] = "puku_findTestFiles";
  ContributedToolName2["GetProjectSetupInfo"] = "puku_getProjectSetupInfo";
  ContributedToolName2["SearchViewResults"] = "puku_getSearchResults";
  ContributedToolName2["GithubRepo"] = "puku_githubRepo";
  ContributedToolName2["CreateAndRunTask"] = "puku_createAndRunTask";
  ContributedToolName2["SimpleBrowser"] = "puku_openSimpleBrowser";
  ContributedToolName2["CreateDirectory"] = "puku_createDirectory";
  ContributedToolName2["RunVscodeCmd"] = "puku_runVscodeCommand";
  ContributedToolName2["ToolReplay"] = "puku_toolReplay";
  ContributedToolName2["EditFilesPlaceholder"] = "puku_editFiles";
  return ContributedToolName2;
})(ContributedToolName || {});
var byokEditToolNamesToToolNames = {
  "find-replace": "replace_string_in_file" /* ReplaceString */,
  "multi-find-replace": "multi_replace_string_in_file" /* MultiReplaceString */,
  "apply-patch": "apply_patch" /* ApplyPatch */,
  "code-rewrite": "insert_edit_into_file" /* EditFile */
};
var toolNameToContributedToolNames = /* @__PURE__ */ new Map();
var contributedToolNameToToolNames = /* @__PURE__ */ new Map();
for (const [contributedNameKey, contributedName] of Object.entries(ContributedToolName)) {
  const toolName = ToolName[contributedNameKey];
  if (toolName) {
    toolNameToContributedToolNames.set(toolName, contributedName);
    contributedToolNameToToolNames.set(contributedName, toolName);
  }
}
var toolCategories = {
  // Core tools (not grouped - expanded by default)
  ["semantic_search" /* Codebase */]: "Core" /* Core */,
  ["grep_search" /* FindTextInFiles */]: "Core" /* Core */,
  ["read_file" /* ReadFile */]: "Core" /* Core */,
  ["create_file" /* CreateFile */]: "Core" /* Core */,
  ["apply_patch" /* ApplyPatch */]: "Core" /* Core */,
  ["replace_string_in_file" /* ReplaceString */]: "Core" /* Core */,
  ["insert_edit_into_file" /* EditFile */]: "Core" /* Core */,
  ["run_in_terminal" /* CoreRunInTerminal */]: "Core" /* Core */,
  ["list_dir" /* ListDirectory */]: "Core" /* Core */,
  ["get_terminal_output" /* CoreGetTerminalOutput */]: "Core" /* Core */,
  ["manage_todo_list" /* CoreManageTodoList */]: "Core" /* Core */,
  ["multi_replace_string_in_file" /* MultiReplaceString */]: "Core" /* Core */,
  ["file_search" /* FindFiles */]: "Core" /* Core */,
  ["create_directory" /* CreateDirectory */]: "Core" /* Core */,
  ["read_project_structure" /* ReadProjectStructure */]: "Core" /* Core */,
  ["runSubagent" /* CoreRunSubagent */]: "Core" /* Core */,
  ["memory" /* Memory */]: "Core" /* Core */,
  // already enabled only when tasks are enabled
  ["run_task" /* CoreRunTask */]: "Core" /* Core */,
  ["get_task_output" /* CoreGetTaskOutput */]: "Core" /* Core */,
  // never enabled, so it doesn't matter where it's categorized
  ["edit_files" /* EditFilesPlaceholder */]: "Core" /* Core */,
  // Jupyter Notebook Tools
  ["create_new_jupyter_notebook" /* CreateNewJupyterNotebook */]: "Jupyter Notebook Tools" /* JupyterNotebook */,
  ["edit_notebook_file" /* EditNotebook */]: "Jupyter Notebook Tools" /* JupyterNotebook */,
  ["run_notebook_cell" /* RunNotebookCell */]: "Jupyter Notebook Tools" /* JupyterNotebook */,
  ["puku_getNotebookSummary" /* GetNotebookSummary */]: "Jupyter Notebook Tools" /* JupyterNotebook */,
  ["read_notebook_cell_output" /* ReadCellOutput */]: "Jupyter Notebook Tools" /* JupyterNotebook */,
  // Web Interaction
  ["fetch_webpage" /* FetchWebPage */]: "Web Interaction" /* WebInteraction */,
  ["open_simple_browser" /* SimpleBrowser */]: "Web Interaction" /* WebInteraction */,
  ["github_repo" /* GithubRepo */]: "Web Interaction" /* WebInteraction */,
  // VS Code Interaction
  ["search_workspace_symbols" /* SearchWorkspaceSymbols */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["list_code_usages" /* Usages */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["get_errors" /* GetErrors */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["get_vscode_api" /* VSCodeAPI */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["get_changed_files" /* GetScmChanges */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["create_new_workspace" /* CreateNewWorkspace */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["install_extension" /* InstallExtension */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["get_project_setup_info" /* GetProjectSetupInfo */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["create_and_run_task" /* CoreCreateAndRunTask */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["run_vscode_command" /* RunVscodeCmd */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["get_search_view_results" /* SearchViewResults */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["terminal_selection" /* CoreTerminalSelection */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["terminal_last_command" /* CoreTerminalLastCommand */]: "VS Code Interaction" /* VSCodeInteraction */,
  // Testing
  ["run_tests" /* RunTests */]: "Testing" /* Testing */,
  ["test_failure" /* TestFailure */]: "Testing" /* Testing */,
  ["test_search" /* FindTestFiles */]: "Testing" /* Testing */,
  ["runTests" /* CoreRunTest */]: "Testing" /* Testing */,
  // Redundant but Specific
  ["get_doc_info" /* DocInfo */]: "Redundant but Specific" /* RedundantButSpecific */,
  // Other tools - categorize appropriately
  ["update_user_preferences" /* UpdateUserPreferences */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["tool_replay" /* ToolReplay */]: "Redundant but Specific" /* RedundantButSpecific */,
  ["vscode_get_confirmation" /* CoreConfirmationTool */]: "VS Code Interaction" /* VSCodeInteraction */,
  ["vscode_get_terminal_confirmation" /* CoreTerminalConfirmationTool */]: "VS Code Interaction" /* VSCodeInteraction */
};
function getToolsForCategory(category) {
  const result = [];
  for (const [toolName, toolCategory] of Object.entries(toolCategories)) {
    if (toolCategory === category) {
      result.push(toolName);
    }
  }
  return result;
}

// src/extension/tools/common/editToolLearningStates.ts
function getSuccessRate(successBitset, totalAttempts) {
  if (totalAttempts === 0) {
    return 0;
  }
  const actualBits = Math.min(totalAttempts, 100 /* WINDOW_SIZE */);
  let successCount = 0;
  for (let i = 0; i < actualBits; i++) {
    if (successBitset >> BigInt(i) & 1n) {
      successCount++;
    }
  }
  return successCount / actualBits;
}
function sampleSize(data, tool) {
  return Math.min(data.tools[tool]?.attempts || 0, 100 /* WINDOW_SIZE */);
}
function successRate(data, tool) {
  const toolData = data.tools[tool];
  if (!toolData) {
    return 0;
  }
  return getSuccessRate(toolData.successBitset, toolData.attempts);
}
var EDIT_TOOL_LEARNING_STATES = {
  [0 /* Initial */]: {
    allowedTools: ["insert_edit_into_file" /* EditFile */, "replace_string_in_file" /* ReplaceString */],
    transitions: {
      [2 /* ReplaceStringMaybeMulti */]: (d) => sampleSize(d, "replace_string_in_file" /* ReplaceString */) > 66.66666666666666 /* MIN_SAMPLE_SIZE */ && successRate(d, "replace_string_in_file" /* ReplaceString */) > 0.8 /* SR_SUCCESS_THRESHOLD */,
      [3 /* EditFileOnly */]: (d) => sampleSize(d, "replace_string_in_file" /* ReplaceString */) > 66.66666666666666 /* MIN_SAMPLE_SIZE */ && successRate(d, "replace_string_in_file" /* ReplaceString */) < 0.3 /* SR_FAILURE_THRESHOLD */,
      [1 /* ReplaceStringForced */]: (d) => {
        const editFileAttempts = sampleSize(d, "insert_edit_into_file" /* EditFile */);
        const replaceStringAttempts = sampleSize(d, "replace_string_in_file" /* ReplaceString */);
        return editFileAttempts > 66.66666666666666 /* MIN_SAMPLE_SIZE */ && editFileAttempts / (editFileAttempts + replaceStringAttempts) > 0.7;
      }
    }
  },
  [1 /* ReplaceStringForced */]: {
    allowedTools: ["replace_string_in_file" /* ReplaceString */],
    transitions: {
      [2 /* ReplaceStringMaybeMulti */]: (d) => sampleSize(d, "replace_string_in_file" /* ReplaceString */) > 66.66666666666666 /* MIN_SAMPLE_SIZE */ && successRate(d, "replace_string_in_file" /* ReplaceString */) > 0.8 /* SR_SUCCESS_THRESHOLD */,
      [3 /* EditFileOnly */]: (d) => sampleSize(d, "replace_string_in_file" /* ReplaceString */) > 66.66666666666666 /* MIN_SAMPLE_SIZE */ && successRate(d, "replace_string_in_file" /* ReplaceString */) < 0.3 /* SR_FAILURE_THRESHOLD */
    }
  },
  [2 /* ReplaceStringMaybeMulti */]: {
    allowedTools: ["replace_string_in_file" /* ReplaceString */, "multi_replace_string_in_file" /* MultiReplaceString */],
    transitions: {
      [5 /* ReplaceStringWithMulti */]: (d) => sampleSize(d, "multi_replace_string_in_file" /* MultiReplaceString */) > 66.66666666666666 /* MIN_SAMPLE_SIZE */ && successRate(d, "multi_replace_string_in_file" /* MultiReplaceString */) > 0.7 /* MULTISR_SUCCESS_THRESHOLD */,
      [4 /* ReplaceStringOnly */]: (d) => sampleSize(d, "multi_replace_string_in_file" /* MultiReplaceString */) > 66.66666666666666 /* MIN_SAMPLE_SIZE */ && successRate(d, "multi_replace_string_in_file" /* MultiReplaceString */) < 0.4 /* MULTISR_FAILURE_THRESHOLD */
    }
  },
  // Terminal states have no transitions
  [3 /* EditFileOnly */]: {
    allowedTools: ["insert_edit_into_file" /* EditFile */]
  },
  [4 /* ReplaceStringOnly */]: {
    allowedTools: ["replace_string_in_file" /* ReplaceString */]
  },
  [5 /* ReplaceStringWithMulti */]: {
    allowedTools: ["replace_string_in_file" /* ReplaceString */, "multi_replace_string_in_file" /* MultiReplaceString */]
  }
};

// src/extension/tools/common/editToolLearningService.ts
var CACHE_STORAGE_KEY = "editToolLearning_cache";
function mapToolsRecord(record, fn) {
  return mapValues(record, (value, key) => fn(value, key));
}
var IEditToolLearningService = createDecorator("IEditToolLearningService");
function addToWindow(window14, bit) {
  const mask = (1n << BigInt(100 /* WINDOW_SIZE */)) - 1n;
  return (window14 << 1n | bit) & mask;
}
var EditToolLearningService = class {
  constructor(_context, _endpointProvider, _telemetryService) {
    this._context = _context;
    this._endpointProvider = _endpointProvider;
    this._telemetryService = _telemetryService;
  }
  async getPreferredEditTool(model) {
    const endpoint = await this._endpointProvider.getChatEndpoint(model);
    return this.getPreferredEndpointEditTool(endpoint);
  }
  getPreferredEndpointEditTool(endpoint) {
    if (!endpoint.isExtensionContributed) {
      return void 0;
    }
    const fromEndpoint = endpoint.supportedEditTools?.map((e) => byokEditToolNamesToToolNames.hasOwnProperty(e) ? byokEditToolNamesToToolNames[e] : void 0).filter(isDefined);
    if (fromEndpoint?.length) {
      return fromEndpoint;
    }
    const hardcoded = this._getHardcodedPreferences(endpoint.name);
    if (hardcoded) {
      return hardcoded;
    }
    const learningData = this._getModelLearningData(endpoint.model);
    return this._computePreferences(learningData);
  }
  async didMakeEdit(model, tool, success) {
    const endpoint = await this._endpointProvider.getChatEndpoint(model);
    if (!endpoint.isExtensionContributed || this._getHardcodedPreferences(endpoint.family)) {
      return;
    }
    const learningData = this._getModelLearningData(model.id);
    this._recordEdit(model.id, learningData, tool, success);
    await this._saveModelLearningData(model.id, learningData);
  }
  _getHardcodedPreferences(family) {
    const lowerFamily = family.toLowerCase();
    if (lowerFamily.includes("gpt") || lowerFamily.includes("openai")) {
      return ["apply_patch" /* ApplyPatch */];
    }
    if (lowerFamily.includes("sonnet")) {
      return ["replace_string_in_file" /* ReplaceString */, "multi_replace_string_in_file" /* MultiReplaceString */];
    }
    return void 0;
  }
  _computePreferences(data) {
    return EDIT_TOOL_LEARNING_STATES[data.state].allowedTools;
  }
  _checkStateTransitions(modelId, data) {
    const currentConfig = EDIT_TOOL_LEARNING_STATES[data.state];
    if (!currentConfig.transitions) {
      return data.state;
    }
    for (const [targetState, condition] of Object.entries(currentConfig.transitions)) {
      if (!condition(data)) {
        continue;
      }
      const target = Number(targetState);
      this._telemetryService.sendMSFTTelemetryEvent("editToolLearning.transition", { modelId }, {
        state: target
      });
      return target;
    }
    return data.state;
  }
  _recordEdit(modelId, data, tool, success) {
    const successBit = success ? 1n : 0n;
    const toolData = data.tools[tool] ??= { successBitset: 0n, attempts: 0 };
    toolData.successBitset = addToWindow(toolData.successBitset, successBit);
    toolData.attempts++;
    const newState = this._checkStateTransitions(modelId, data);
    if (newState !== data.state) {
      data.state = newState;
      data.tools = {};
    }
  }
  _getCache() {
    if (!this._cache) {
      this._cache = this._loadCacheFromStorage();
    }
    return this._cache;
  }
  _loadCacheFromStorage() {
    const cache = new LRUCache(50 /* CACHE_SIZE */);
    const storedCacheData = this._context.globalState.get(CACHE_STORAGE_KEY);
    if (!storedCacheData?.entries) {
      return cache;
    }
    for (const [modelId, storedData] of storedCacheData.entries) {
      const data = {
        state: storedData.state,
        tools: mapToolsRecord(storedData.tools, (r) => ({
          successBitset: BigInt(r.successBitset),
          attempts: r.attempts
        }))
      };
      cache.set(modelId, data);
    }
    return cache;
  }
  async _saveCacheToStorage() {
    if (!this._cache) {
      return;
    }
    const entries = Array.from(this._cache.entries(), ([modelId, data]) => {
      const storedData = {
        state: data.state,
        tools: mapToolsRecord(data.tools, (r) => ({
          successBitset: "0x" + r.successBitset.toString(16),
          attempts: r.attempts
        }))
      };
      return [modelId, storedData];
    });
    await this._context.globalState.update(CACHE_STORAGE_KEY, { entries });
  }
  async _saveModelLearningData(modelId, data) {
    const cache = this._getCache();
    cache.set(modelId, data);
    await this._saveCacheToStorage();
  }
  _getModelLearningData(modelId) {
    const cache = this._getCache();
    let data = cache.get(modelId);
    if (!data) {
      data = { state: 0 /* Initial */, tools: {} };
      cache.set(modelId, data);
    }
    return data;
  }
};
EditToolLearningService = __decorateClass([
  __decorateParam(0, IVSCodeExtensionContext),
  __decorateParam(1, IEndpointProvider),
  __decorateParam(2, ITelemetryService)
], EditToolLearningService);

// src/platform/embeddings/common/embeddingsGrouper.ts
var EmbeddingsGrouper = class {
  constructor(options) {
    this.nodes = [];
    this.clusters = [];
    this.nodeToClusterId = /* @__PURE__ */ new Map();
    this.clusterCounter = 0;
    this.normalizedEmbeddings = /* @__PURE__ */ new Map();
    this.lastUsedThreshold = 0.9;
    this.options = {
      eps: 0.9,
      // Higher similarity threshold for cosine similarity
      minClusterSize: 2,
      ...options
    };
  }
  /**
   * Add a node to the grouper. Will attempt to assign to existing cluster
   * or create a new singleton cluster.
   */
  addNode(node) {
    this.nodes.push(node);
    this.normalizedEmbeddings.set(node, this.normalizeVector(node.embedding.value));
    this.cachedSimilarities = void 0;
    if (this.clusters.length > 0) {
      const insertThreshold = this.options.insertThreshold ?? this.lastUsedThreshold;
      const bestCluster = this.findBestClusterForNode(node, insertThreshold);
      if (bestCluster) {
        this.addNodeToCluster(node, bestCluster);
        return;
      }
    }
    this.createSingletonCluster(node);
  }
  /**
   * Add multiple nodes efficiently in batch. This is much more efficient than
   * calling addNode() multiple times as it defers clustering until all nodes are added.
   *
   * @param nodes Array of nodes to add
   * @param reclusterAfter Whether to recluster after adding all nodes. Default: true
   */
  addNodes(nodes, reclusterAfter = true) {
    if (nodes.length === 0) {
      return;
    }
    for (const node of nodes) {
      this.nodes.push(node);
    }
    this.cachedSimilarities = void 0;
    if (reclusterAfter) {
      this.recluster();
    } else {
      for (const node of nodes) {
        this.createSingletonCluster(node);
      }
    }
  }
  /**
   * Remove a node from the grouper. May cause cluster splits or deletions.
   */
  removeNode(node) {
    const nodeIndex = this.nodes.indexOf(node);
    if (nodeIndex === -1) {
      return false;
    }
    this.nodes.splice(nodeIndex, 1);
    this.normalizedEmbeddings.delete(node);
    this.cachedSimilarities = void 0;
    const clusterId = this.nodeToClusterId.get(node);
    if (clusterId) {
      this.nodeToClusterId.delete(node);
      this.removeNodeFromCluster(node, clusterId);
    }
    return true;
  }
  /**
   * Perform full reclustering of all nodes using similarity-based clustering.
   */
  recluster() {
    if (this.nodes.length === 0) {
      this.clusters = [];
      this.nodeToClusterId.clear();
      return;
    }
    this.clusters = [];
    this.nodeToClusterId.clear();
    const clusterAssignments = this.runSimilarityBasedClustering(this.options.eps, this.options.minClusterSize);
    this.createClustersFromAssignments(clusterAssignments);
  }
  /**
   * Get all current clusters
   */
  getClusters() {
    return this.clusters;
  }
  /**
   * Get the cluster containing a specific node
   */
  getClusterForNode(node) {
    const clusterId = this.nodeToClusterId.get(node);
    return clusterId ? this.clusters.find((c) => c.id === clusterId) : void 0;
  }
  // Fallback default
  /**
   * Compute similarity threshold based on percentile.
   * Higher percentiles result in stricter clustering (higher similarity required).
   */
  computeEpsFromPercentile(percentile) {
    if (this.nodes.length < 2) {
      return 0.9;
    }
    const similarities = this.getSimilarities();
    if (similarities.length === 0) {
      return 0.9;
    }
    const index = Math.floor(percentile / 100 * similarities.length);
    const threshold = similarities[Math.min(index, similarities.length - 1)];
    this.lastUsedThreshold = threshold;
    return threshold;
  }
  /**
   * Run similarity-based clustering that avoids transitive clustering issues
   * @param threshold Minimum similarity for nodes to be clustered together
   * @param minClusterSize Minimum size for a valid cluster
   * @returns Array where each index corresponds to a node and value is cluster ID (-1 for unassigned)
   */
  runSimilarityBasedClustering(threshold, minClusterSize) {
    const assignments = new Array(this.nodes.length).fill(-1);
    const processed = new Array(this.nodes.length).fill(false);
    let clusterId = 0;
    const seeds = this.findClusterSeeds(threshold, minClusterSize);
    for (const seed of seeds) {
      if (processed[seed]) {
        continue;
      }
      const cluster = this.buildClusterAroundSeed(seed, threshold, processed);
      if (cluster.length >= minClusterSize) {
        for (const nodeIndex of cluster) {
          assignments[nodeIndex] = clusterId;
          processed[nodeIndex] = true;
        }
        clusterId++;
      }
    }
    return assignments;
  }
  /**
   * Find potential cluster seeds - nodes that are similar to many others
   */
  findClusterSeeds(threshold, minClusterSize) {
    const seeds = [];
    const similarityCounts = new Array(this.nodes.length).fill(0);
    for (let i = 0; i < this.nodes.length; i++) {
      for (let j = i + 1; j < this.nodes.length; j++) {
        const similarity = this.cachedCosineSimilarity(this.nodes[i], this.nodes[j]);
        if (similarity >= threshold) {
          similarityCounts[i]++;
          similarityCounts[j]++;
        }
      }
    }
    for (let i = 0; i < this.nodes.length; i++) {
      if (similarityCounts[i] >= minClusterSize - 1) {
        seeds.push(i);
      }
    }
    seeds.sort((a, b) => similarityCounts[b] - similarityCounts[a]);
    return seeds;
  }
  /**
   * Build a cluster around a seed node by finding all nodes similar to the seed
   */
  buildClusterAroundSeed(seed, threshold, processed) {
    const cluster = [seed];
    for (let i = 0; i < this.nodes.length; i++) {
      if (i === seed || processed[i]) {
        continue;
      }
      const similarity = this.cachedCosineSimilarity(this.nodes[seed], this.nodes[i]);
      if (similarity >= threshold) {
        cluster.push(i);
      }
    }
    return cluster;
  }
  /**
   * Create clusters from assignment results
   */
  createClustersFromAssignments(clusterAssignments) {
    const clusterMap = /* @__PURE__ */ new Map();
    const unassigned = [];
    for (let i = 0; i < clusterAssignments.length; i++) {
      const clusterId = clusterAssignments[i];
      const node = this.nodes[i];
      if (clusterId === -1) {
        unassigned.push(node);
      } else {
        if (!clusterMap.has(clusterId)) {
          clusterMap.set(clusterId, []);
        }
        clusterMap.get(clusterId).push(node);
      }
    }
    for (const [, nodes] of clusterMap) {
      if (nodes.length >= this.options.minClusterSize) {
        this.createCluster(nodes);
      } else {
        for (const node of nodes) {
          this.createSingletonCluster(node);
        }
      }
    }
    for (const node of unassigned) {
      this.createSingletonCluster(node);
    }
  }
  /**
   * Find the best existing cluster for a new node
   */
  findBestClusterForNode(node, threshold) {
    let bestCluster;
    let bestSimilarity = -1;
    for (const cluster of this.clusters) {
      const similarity = this.dotProduct(
        this.getNormalizedEmbedding(node),
        cluster.centroid
      );
      if (similarity >= threshold && similarity > bestSimilarity) {
        bestSimilarity = similarity;
        bestCluster = cluster;
      }
    }
    return bestCluster;
  }
  /**
   * Add node to existing cluster and update centroid
   */
  addNodeToCluster(node, cluster) {
    const updatedNodes = [...cluster.nodes, node];
    const updatedCentroid = this.computeCentroid(updatedNodes.map((n) => n.embedding.value));
    const updatedCluster = {
      ...cluster,
      nodes: updatedNodes,
      centroid: updatedCentroid
    };
    const clusterIndex = this.clusters.indexOf(cluster);
    this.clusters[clusterIndex] = updatedCluster;
    this.nodeToClusterId.set(node, cluster.id);
  }
  /**
   * Remove node from cluster and handle potential cluster deletion
   */
  removeNodeFromCluster(node, clusterId) {
    const clusterIndex = this.clusters.findIndex((c) => c.id === clusterId);
    if (clusterIndex === -1) {
      return;
    }
    const cluster = this.clusters[clusterIndex];
    const updatedNodes = cluster.nodes.filter((n) => n !== node);
    if (updatedNodes.length === 0) {
      this.clusters.splice(clusterIndex, 1);
    } else {
      const updatedCentroid = this.computeCentroid(updatedNodes.map((n) => n.embedding.value));
      const updatedCluster = {
        ...cluster,
        nodes: updatedNodes,
        centroid: updatedCentroid
      };
      this.clusters[clusterIndex] = updatedCluster;
      for (const remainingNode of updatedNodes) {
        this.nodeToClusterId.set(remainingNode, clusterId);
      }
    }
  }
  /**
   * Create a new cluster from nodes
   */
  createCluster(nodes) {
    const id2 = `cluster_${this.clusterCounter++}`;
    const centroid = this.computeCentroid(nodes.map((n) => n.embedding.value));
    const cluster = {
      id: id2,
      nodes,
      centroid
    };
    this.clusters.push(cluster);
    for (const node of nodes) {
      this.nodeToClusterId.set(node, id2);
    }
  }
  /**
   * Create a singleton cluster for a single node
   */
  createSingletonCluster(node) {
    this.createCluster([node]);
  }
  /**
   * Compute centroid (mean) of embedding vectors
   */
  computeCentroid(embeddings) {
    if (embeddings.length === 0) {
      return [];
    }
    if (embeddings.length === 1) {
      return [...embeddings[0]];
    }
    const dimensions = embeddings[0].length;
    const centroid = new Array(dimensions).fill(0);
    for (const embedding of embeddings) {
      for (let i = 0; i < dimensions; i++) {
        centroid[i] += embedding[i];
      }
    }
    for (let i = 0; i < dimensions; i++) {
      centroid[i] /= embeddings.length;
    }
    return this.normalizeVector(centroid);
  }
  /**
   * Gets the sorted list of pairwise similarities between all nodes.
   * The returned list is ordered by similarity, NOT in any particular node order.
   */
  getSimilarities() {
    if (this.cachedSimilarities) {
      return this.cachedSimilarities;
    }
    const similarities = [];
    for (let i = 0; i < this.nodes.length; i++) {
      for (let j = i + 1; j < this.nodes.length; j++) {
        const sim = this.cachedCosineSimilarity(this.nodes[i], this.nodes[j]);
        similarities.push(sim);
      }
    }
    similarities.sort((a, b) => a - b);
    this.cachedSimilarities = similarities;
    return this.cachedSimilarities;
  }
  /**
   * Optimize clustering by finding the best similarity threshold that results in
   * a target number of clusters or fewer, aiming for the highest cluster count
   * that doesn't exceed the maximum. Includes a "cliff effect" to avoid over-clustering.
   *
   * @param maxClusters Maximum desired number of clusters
   * @param minThreshold Minimum similarity threshold to try (default: 0.7 - loose clustering)
   * @param maxThreshold Maximum similarity threshold to try (default: 0.99 - very strict)
   * @param precision How precise the search should be (default: 0.02)
   * @param cliffThreshold Fraction of maxClusters that triggers cliff effect (default: 2/3)
   * @param cliffGain Minimum additional clusters needed to continue past cliff (default: 20% of maxClusters)
   * @returns The optimal threshold found and resulting cluster count
   */
  tuneThresholdForTargetClusters(maxClusters, minThreshold = 0.7, maxThreshold = 0.99, precision = 0.02, cliffThreshold = 2 / 3, cliffGain = 0.2) {
    if (this.nodes.length === 0) {
      return { percentile: 90, clusterCount: 0, threshold: 0.9 };
    }
    const cliffPoint = Math.floor(maxClusters * cliffThreshold);
    const minGainAfterCliff = Math.max(1, Math.floor(maxClusters * cliffGain));
    let bestThreshold = maxThreshold;
    let bestClusterCount = 1;
    let cliffReached = false;
    let low = minThreshold;
    let high = maxThreshold;
    while (high - low > precision) {
      const mid = (low + high) / 2;
      const clusterCount = this.countClustersForThreshold(mid, this.options.minClusterSize);
      if (clusterCount <= maxClusters) {
        let shouldUpdate = false;
        if (!cliffReached && clusterCount >= cliffPoint) {
          cliffReached = true;
          shouldUpdate = clusterCount > bestClusterCount;
        } else if (cliffReached) {
          shouldUpdate = clusterCount >= bestClusterCount + minGainAfterCliff;
        } else {
          shouldUpdate = clusterCount > bestClusterCount;
        }
        if (shouldUpdate) {
          bestThreshold = mid;
          bestClusterCount = clusterCount;
        }
        low = mid + precision;
      } else {
        high = mid - precision;
      }
    }
    const similarities = this.getSimilarities();
    let approximatePercentile = 90;
    if (similarities.length > 0) {
      const position = similarities.findIndex((s) => s >= bestThreshold);
      if (position >= 0) {
        approximatePercentile = Math.round(position / similarities.length * 100);
      }
    }
    return {
      percentile: approximatePercentile,
      clusterCount: bestClusterCount,
      threshold: bestThreshold
    };
  }
  /**
   * Apply a specific similarity threshold and recluster
   *
   * @param percentile The similarity percentile to convert to threshold
   */
  applyPercentileAndRecluster(percentile) {
    const eps = this.computeEpsFromPercentile(percentile);
    const originalEps = this.options.eps;
    this.options.eps = eps;
    try {
      this.recluster();
    } finally {
      this.options.eps = originalEps;
    }
  }
  /**
   * Count how many clusters would result from a given similarity threshold without actually clustering
   */
  countClustersForThreshold(threshold, minClusterSize) {
    if (this.nodes.length === 0) {
      return 0;
    }
    const clusterAssignments = this.runSimilarityBasedClustering(threshold, minClusterSize);
    const clusterIds = /* @__PURE__ */ new Set();
    for (const clusterId of clusterAssignments) {
      if (clusterId !== -1) {
        clusterIds.add(clusterId);
      }
    }
    const clusterSizes = /* @__PURE__ */ new Map();
    let unassignedCount = 0;
    for (const clusterId of clusterAssignments) {
      if (clusterId === -1) {
        unassignedCount++;
      } else {
        clusterSizes.set(clusterId, (clusterSizes.get(clusterId) || 0) + 1);
      }
    }
    let validClusters = 0;
    let singletons = unassignedCount;
    for (const [, size] of clusterSizes) {
      if (size >= minClusterSize) {
        validClusters++;
      } else {
        singletons += size;
      }
    }
    return validClusters + singletons;
  }
  /**
   * Get cached normalized embedding for a node
   */
  getNormalizedEmbedding(node) {
    let normalized = this.normalizedEmbeddings.get(node);
    if (!normalized) {
      normalized = this.normalizeVector(node.embedding.value);
      this.normalizedEmbeddings.set(node, normalized);
    }
    return normalized;
  }
  /**
   * Compute cosine similarity using cached normalized embeddings
   */
  cachedCosineSimilarity(nodeA, nodeB) {
    const normA = this.getNormalizedEmbedding(nodeA);
    const normB = this.getNormalizedEmbedding(nodeB);
    return this.dotProduct(normA, normB);
  }
  /**
   * Optimized dot product computation
   */
  dotProduct(a, b) {
    let dotProduct2 = 0;
    const len = Math.min(a.length, b.length);
    let i = 0;
    for (; i < len - 3; i += 4) {
      dotProduct2 += a[i] * b[i] + a[i + 1] * b[i + 1] + a[i + 2] * b[i + 2] + a[i + 3] * b[i + 3];
    }
    for (; i < len; i++) {
      dotProduct2 += a[i] * b[i];
    }
    return dotProduct2;
  }
  /**
   * L2 normalize a vector
   */
  normalizeVector(vector) {
    const magnitude = Math.sqrt(vector.reduce((sum2, val) => sum2 + val * val, 0));
    if (magnitude === 0) {
      return vector.slice();
    }
    return vector.map((val) => val / magnitude);
  }
};

// src/extension/tools/common/virtualTools/toolEmbeddingsComputer.ts
init_lazy();
init_stopwatch();
init_types();

// src/extension/tools/common/virtualTools/preComputedToolEmbeddingsCache.ts
var EMBEDDING_TYPE_FOR_TOOL_GROUPING = EmbeddingType.text3small_512;
var PreComputedToolEmbeddingsCache = class {
  constructor(_logService, instantiationService, envService) {
    this._logService = _logService;
    const cacheVersion = sanitizeVSCodeVersion(envService.getEditorInfo().version);
    this.cache = instantiationService.createInstance(RemoteEmbeddingsCache, 1 /* GLOBAL */, "toolEmbeddings", cacheVersion, EMBEDDING_TYPE_FOR_TOOL_GROUPING, "tools" /* Tools */);
  }
  get embeddingType() {
    return this.cache.embeddingType;
  }
  async initialize() {
    this.embeddingsMap = await this._loadEmbeddings();
  }
  get(tool) {
    return this.embeddingsMap?.get(tool.name);
  }
  set() {
  }
  async _loadEmbeddings() {
    try {
      const embeddingsData = await this.cache.getCache();
      const embeddingsMap = /* @__PURE__ */ new Map();
      if (embeddingsData) {
        for (const [key, embeddingVector] of Object.entries(embeddingsData)) {
          if (embeddingVector === void 0) {
            this._logService.warn(`Tool embedding missing for key: ${key}`);
            continue;
          }
          embeddingsMap.set(key, {
            type: this.embeddingType,
            value: embeddingVector.embedding
          });
        }
      }
      return embeddingsMap;
    } catch (e) {
      this._logService.error("Failed to load pre-computed tool embeddings", e);
      return /* @__PURE__ */ new Map();
    }
  }
};
PreComputedToolEmbeddingsCache = __decorateClass([
  __decorateParam(0, ILogService),
  __decorateParam(1, IInstantiationService),
  __decorateParam(2, IEnvService)
], PreComputedToolEmbeddingsCache);

// src/platform/embeddings/common/embeddingsStorage.ts
function packEmbedding(embedding) {
  const embeddingMetadata = getWellKnownEmbeddingTypeInfo(embedding.type);
  if (embeddingMetadata?.quantization.document === "binary") {
    if (embedding.value.length % 8 !== 0) {
      throw new Error(`Embedding value length must be a multiple of 8 for ${embedding.type.id}, got ${embedding.value.length}`);
    }
    const data2 = new Uint8Array(embedding.value.length / 8);
    for (let i = 0; i < embedding.value.length; i += 8) {
      let value = 0;
      for (let j = 0; j < 8; j++) {
        value |= (embedding.value[i + j] >= 0 ? 1 : 0) << j;
      }
      data2[i / 8] = value;
    }
    return data2;
  }
  const data = Float32Array.from(embedding.value);
  return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
}
function unpackEmbedding(type, data) {
  const embeddingMetadata = getWellKnownEmbeddingTypeInfo(type);
  if (embeddingMetadata?.quantization.document === "binary") {
    if (!(type.equals(EmbeddingType.metis_1024_I16_Binary) && data.length >= 1024)) {
      const values = new Array(data.length * 8);
      for (let i = 0; i < data.length; i++) {
        const byte = data[i];
        for (let j = 0; j < 8; j++) {
          values[i * 8 + j] = (byte & 1 << j) > 0 ? 0.03125 : -0.03125;
        }
      }
      return { type, value: values };
    }
  }
  const float32Array = new Float32Array(data.buffer, data.byteOffset, data.byteLength / 4);
  return { type, value: Array.from(float32Array) };
}

// src/util/common/variableLengthQuantity.ts
function readVariableLengthQuantity(buffer, offset) {
  let result = 0;
  let consumed = 0;
  let byte;
  do {
    byte = buffer.readUInt8(offset + consumed);
    result |= (byte & 127) << consumed * 7;
    consumed++;
  } while (byte & 128);
  return { value: result, consumed };
}
function writeVariableLengthQuantity(i) {
  if (i !== (i | 0)) {
    throw new Error(`${i} is not an int32.`);
  }
  const result = [];
  do {
    let byte = i & 127;
    i >>>= 7;
    if (i !== 0) {
      byte |= 128;
    }
    result.push(byte);
  } while (i !== 0);
  return VSBuffer.fromByteArray(result);
}

// src/extension/tools/common/virtualTools/toolEmbeddingsLocalCache.ts
init_lifecycle();
init_map();
var EMBEDDING_CACHE_FILE_NAME = "toolEmbeddingsCache.bin";
var CACHE_VERSION = 1;
var SHA1_DIGEST_LENGTH = 20;
var ToolEmbeddingLocalCache = class extends Disposable {
  constructor(embeddingType, _fileSystemService, _context) {
    super();
    this._fileSystemService = _fileSystemService;
    this._lru = new LRUCache(1e3);
    this._toolHashes = /* @__PURE__ */ new WeakMap();
    this._storageScheduler = this._register(new RunOnceScheduler(() => this.save(), 5e3));
    this._embeddingType = embeddingType;
    this._storageUri = URI.joinPath(_context.globalStorageUri, EMBEDDING_CACHE_FILE_NAME);
  }
  async initialize() {
    try {
      const buffer = VSBuffer.wrap(await this._fileSystemService.readFile(this._storageUri, true));
      let offset = 0;
      const versionResult = readVariableLengthQuantity(buffer, offset);
      offset += versionResult.consumed;
      if (versionResult.value !== CACHE_VERSION) {
        return;
      }
      const typeLengthResult = readVariableLengthQuantity(buffer, offset);
      offset += typeLengthResult.consumed;
      const typeLength = typeLengthResult.value;
      const typeBytes = buffer.slice(offset, offset + typeLength);
      offset += typeLength;
      const storedEmbeddingTypeId = new TextDecoder().decode(typeBytes.buffer);
      const storedEmbeddingType = new EmbeddingType(storedEmbeddingTypeId);
      if (!storedEmbeddingType.equals(this._embeddingType)) {
        return;
      }
      const entriesCountResult = readVariableLengthQuantity(buffer, offset);
      offset += entriesCountResult.consumed;
      const entriesCount = entriesCountResult.value;
      for (let i = 0; i < entriesCount; i++) {
        const keyBytes = buffer.slice(offset, offset + SHA1_DIGEST_LENGTH);
        offset += SHA1_DIGEST_LENGTH;
        const key = encodeHex(keyBytes);
        const embeddingLengthResult = readVariableLengthQuantity(buffer, offset);
        offset += embeddingLengthResult.consumed;
        const embeddingLength = embeddingLengthResult.value;
        const embeddingBytes = buffer.slice(offset, offset + embeddingLength);
        offset += embeddingLength;
        const embedding = unpackEmbedding(this._embeddingType, new Uint8Array(embeddingBytes.buffer));
        this._lru.set(key, embedding);
      }
    } catch {
    }
  }
  get(tool) {
    return this._lru.get(this._getKey(tool));
  }
  set(tool, embedding) {
    const key = this._getKey(tool);
    this._lru.set(key, embedding);
    this._storageScheduler.schedule();
  }
  _getKey(tool) {
    let hash = this._toolHashes.get(tool);
    if (!hash) {
      const sha = new StringSHA1();
      sha.update(tool.name);
      sha.update("\0");
      sha.update(tool.description);
      hash = sha.digest();
      this._toolHashes.set(tool, hash);
    }
    return hash;
  }
  async save() {
    this._storageScheduler.cancel();
    if (!this._lru.size) {
      return;
    }
    const entries = this._lru.toJSON();
    const buffers = [];
    buffers.push(writeVariableLengthQuantity(CACHE_VERSION));
    const typeBytes = new TextEncoder().encode(this._embeddingType.id);
    buffers.push(writeVariableLengthQuantity(typeBytes.length));
    buffers.push(VSBuffer.wrap(typeBytes));
    buffers.push(writeVariableLengthQuantity(entries.length));
    for (const [key, embedding] of entries) {
      const keyBinary = decodeHex(key);
      buffers.push(VSBuffer.wrap(keyBinary.buffer));
      const packedEmbedding = packEmbedding(embedding);
      buffers.push(writeVariableLengthQuantity(packedEmbedding.length));
      buffers.push(VSBuffer.wrap(packedEmbedding));
    }
    const totalBuffer = VSBuffer.concat(buffers);
    await this._fileSystemService.writeFile(this._storageUri, totalBuffer.buffer);
  }
};
ToolEmbeddingLocalCache = __decorateClass([
  __decorateParam(1, IFileSystemService),
  __decorateParam(2, IVSCodeExtensionContext)
], ToolEmbeddingLocalCache);

// src/extension/tools/common/virtualTools/virtualToolsConstants.ts
var START_GROUPING_AFTER_TOOL_COUNT = HARD_TOOL_LIMIT / 2;
var START_BUILTIN_GROUPING_AFTER_TOOL_COUNT = 20;
var TRIM_THRESHOLD = HARD_TOOL_LIMIT * 3 / 4;
var GROUP_WITHIN_TOOLSET = HARD_TOOL_LIMIT / 8;
var MIN_TOOLSET_SIZE_TO_GROUP = 2;
var NUM_EMBED_MATCHED_TOOLS = 10;
var TOOLS_AND_GROUPS_LIMIT = HARD_TOOL_LIMIT - NUM_EMBED_MATCHED_TOOLS - 30;
var MAX_GROUPS_PER_CHUNK = 16;

// src/extension/tools/common/virtualTools/toolEmbeddingsComputer.ts
var IToolEmbeddingsComputer = createDecorator("IToolEmbeddingsComputer");
var ToolEmbeddingsComputer = class {
  constructor(_embeddingsComputer, _logService, instantiationService) {
    this._embeddingsComputer = _embeddingsComputer;
    this._logService = _logService;
    this.embeddingsStore = /* @__PURE__ */ new Map();
    this._initialized = new Lazy(() => this.ensureInitialized());
    const { caches, embeddingType } = this.getCaches(instantiationService);
    this._caches = caches;
    this._embeddingType = embeddingType;
  }
  getCaches(instantiationService) {
    const precomputed = instantiationService.createInstance(PreComputedToolEmbeddingsCache);
    const embeddingType = precomputed.embeddingType;
    return {
      embeddingType,
      caches: [
        precomputed,
        instantiationService.createInstance(ToolEmbeddingLocalCache, embeddingType)
      ]
    };
  }
  /**
   * Legacy method name for backward compatibility
   */
  async retrieveSimilarEmbeddingsForAvailableTools(queryEmbedding, availableToolNames, count2, token) {
    await this._initialized.value;
    if (token.isCancellationRequested) {
      return [];
    }
    const availableEmbeddings = await this.getAvailableToolEmbeddings(availableToolNames, token);
    if (availableEmbeddings.length === 0) {
      return [];
    }
    const rankedEmbeddings = this.rankEmbeddings(queryEmbedding, availableEmbeddings, count2);
    const matched = rankedEmbeddings.map((x) => x.value);
    this._logService.trace(`[virtual-tools] Matched ${JSON.stringify(matched)} against the query.`);
    return matched;
  }
  rankEmbeddings(queryEmbedding, availableEmbeddings, count2) {
    return rankEmbeddings(queryEmbedding, availableEmbeddings, count2);
  }
  /**
   * Ensures pre-computed embeddings are loaded into the store
   */
  async ensureInitialized() {
    await Promise.all(this._caches.map((c) => c.initialize()));
  }
  /**
   * Computes embeddings for missing tools and stores them
   */
  computeMissingEmbeddings(missingTools, token) {
    if (token.isCancellationRequested || missingTools.length === 0) {
      return;
    }
    const computedEmbeddings = this.computeEmbeddingsForTools(missingTools, token).catch((e) => {
      this._logService.error("Failed to compute embeddings for tools", e);
      return void 0;
    });
    for (const tool of missingTools) {
      const promise = computedEmbeddings.then(async (c) => {
        const found = c?.find(([name]) => name === tool.name)?.[1];
        if (found === void 0) {
          this.embeddingsStore.delete(tool.name);
        } else {
          for (const cache of this._caches) {
            cache.set(tool, found);
          }
        }
        return found;
      });
      this.embeddingsStore.set(tool.name, promise);
    }
  }
  /**
   * Computes embeddings for a list of tool names
   */
  async computeEmbeddingsForTools(tools, token) {
    if (token.isCancellationRequested) {
      return void 0;
    }
    const toolNames = tools.map((t2) => t2.name + "\n\n" + t2.description);
    const start = new StopWatch();
    const embeddings = await this._embeddingsComputer.computeEmbeddings(this._embeddingType, toolNames, {}, new TelemetryCorrelationId("ToolEmbeddingsComputer::computeEmbeddingsForTools"), token);
    this._logService.trace(`[virtual-tools] Computed embeddings for ${toolNames.length} tools in ${start.elapsed()}ms`);
    if (embeddings?.values.length === 0 || embeddings?.values.length !== toolNames.length) {
      return void 0;
    }
    return toolNames.map((name, index) => [tools[index].name, embeddings.values[index]]);
  }
  /**
   * Gets embeddings for available tools as an array suitable for ranking
   */
  async getAvailableToolEmbeddings(tools, token) {
    const fromCaches = new Map(tools.map((t2) => {
      for (const cache of this._caches) {
        const embedding = cache.get(t2);
        if (embedding) {
          return [t2.name, embedding];
        }
      }
    }).filter(isDefined));
    const missingTools = tools.filter((t2) => !this.embeddingsStore.has(t2.name) && !fromCaches.has(t2.name));
    this.computeMissingEmbeddings(missingTools, token);
    const result = [];
    for (const { name } of tools) {
      if (token.isCancellationRequested) {
        return result;
      }
      const cached = fromCaches.get(name);
      if (cached) {
        result.push([name, cached]);
        continue;
      }
      const embedding = await this.embeddingsStore.get(name);
      if (embedding) {
        result.push([name, embedding]);
      }
    }
    return result;
  }
  /**
   * Groups tools using embedding-based clustering to optimize for target cluster count
   */
  async computeToolGroupings(tools, limit, token) {
    await this._initialized.value;
    if (token.isCancellationRequested || tools.length === 0) {
      return [];
    }
    const toolEmbeddings = await this.getAvailableToolEmbeddings(tools, token);
    if (toolEmbeddings.length === 0) {
      this._logService.trace("[virtual-tools] No embeddings available for tools, returning empty groups");
      return [];
    }
    const nodes = [];
    const toolMap = new Map(tools.map((tool) => [tool.name, tool]));
    for (const [toolName, embedding] of toolEmbeddings) {
      const tool = toolMap.get(toolName);
      if (tool) {
        nodes.push({
          value: tool,
          embedding
        });
      }
    }
    if (nodes.length === 0) {
      this._logService.trace("[virtual-tools] No valid nodes created for clustering");
      return [];
    }
    const grouper = new EmbeddingsGrouper();
    grouper.addNodes(nodes);
    const targetClusters = Math.min(limit, Math.ceil(nodes.length / 4));
    if (targetClusters >= nodes.length) {
      this._logService.trace(`[virtual-tools] Target clusters (${targetClusters}) >= tool count (${nodes.length}), returning individual tools`);
      return tools.map((tool) => [tool]);
    }
    const tuneResult = grouper.tuneThresholdForTargetClusters(targetClusters);
    this._logService.trace(`[virtual-tools] Tuned clustering: ${tuneResult.clusterCount} clusters with threshold ${tuneResult.threshold} (percentile ${tuneResult.percentile})`);
    grouper.applyPercentileAndRecluster(tuneResult.percentile);
    const clusters = grouper.getClusters();
    const groups = [];
    const singletons = [];
    for (const cluster of clusters) {
      const toolsInCluster = cluster.nodes.map((node) => node.value);
      if (toolsInCluster.length >= MIN_TOOLSET_SIZE_TO_GROUP) {
        groups.push(toolsInCluster);
      } else {
        singletons.push(...toolsInCluster);
      }
    }
    const totalGroupsAndSingletons = groups.length + singletons.length;
    if (totalGroupsAndSingletons <= limit) {
      for (const singleton of singletons) {
        groups.push([singleton]);
      }
    } else {
      const remainingSlots = limit - groups.length;
      for (let i = 0; i < Math.min(singletons.length, remainingSlots); i++) {
        groups.push([singletons[i]]);
      }
      if (singletons.length > remainingSlots) {
        this._logService.warn(`[virtual-tools] Had to drop ${singletons.length - remainingSlots} tools due to limit constraints`);
      }
    }
    this._logService.trace(`[virtual-tools] Created ${groups.length} groups from ${tools.length} tools`);
    return groups;
  }
};
ToolEmbeddingsComputer = __decorateClass([
  __decorateParam(0, IEmbeddingsComputer),
  __decorateParam(1, ILogService),
  __decorateParam(2, IInstantiationService)
], ToolEmbeddingsComputer);

// src/extension/tools/common/virtualTools/toolGroupingService.ts
init_map();

// src/extension/tools/common/virtualTools/toolGrouping.ts
init_arrays();
init_iterator();

// src/extension/tools/common/virtualTools/virtualTool.ts
var VIRTUAL_TOOL_NAME_PREFIX = "activate_";
var EMBEDDINGS_GROUP_NAME = VIRTUAL_TOOL_NAME_PREFIX + "embeddings";
var VirtualTool = class _VirtualTool {
  constructor(name, description, lastUsedOnTurn, metadata, contents = []) {
    this.name = name;
    this.description = description;
    this.lastUsedOnTurn = lastUsedOnTurn;
    this.metadata = metadata;
    this.contents = contents;
    this.isExpanded = false;
    if (!name.startsWith(VIRTUAL_TOOL_NAME_PREFIX)) {
      throw new Error(`Virtual tool name must start with '${VIRTUAL_TOOL_NAME_PREFIX}'`);
    }
  }
  cloneWithNewName(name) {
    const vt = new _VirtualTool(name, this.description, this.lastUsedOnTurn, { ...this.metadata }, this.contents);
    vt.isExpanded = this.isExpanded;
    return vt;
  }
  copyStateFrom(other) {
    this.isExpanded = other.isExpanded;
    this.metadata.wasExpandedByDefault = other.metadata.wasExpandedByDefault;
    this.metadata.canBeCollapsed = other.metadata.canBeCollapsed;
    this.metadata.wasEmbeddingsMatched = other.metadata.wasEmbeddingsMatched;
    this.lastUsedOnTurn = other.lastUsedOnTurn;
  }
  /**
   * Looks up a tool. Update the {@link lastUsedOnTurn} of all virtual tools
   * it touches.
   */
  find(name) {
    if (this.name === name) {
      return { tool: this, path: [] };
    }
    for (const content of this.contents) {
      if (content instanceof _VirtualTool) {
        const found = content.find(name);
        if (found) {
          found.path.unshift(this);
          return found;
        }
      } else {
        if (content.name === name) {
          return { tool: content, path: [this] };
        }
      }
    }
    return void 0;
  }
  /**
   * Gets the tool with the lowest {@link lastUsedOnTurn} that is expanded.
   */
  getLowestExpandedTool() {
    let lowest;
    for (const tool of this.all()) {
      if (tool instanceof _VirtualTool && tool.isExpanded) {
        if (!lowest || tool.lastUsedOnTurn < lowest.lastUsedOnTurn) {
          lowest = tool;
        }
      }
    }
    return lowest;
  }
  *all() {
    yield this;
    for (const content of this.contents) {
      if (content instanceof _VirtualTool) {
        yield* content.all();
      } else {
        yield content;
      }
    }
  }
  *tools() {
    if (!this.isExpanded) {
      yield {
        name: this.name,
        description: this.description,
        inputSchema: void 0,
        source: void 0,
        tags: []
      };
      return;
    }
    for (const content of this.contents) {
      if (content instanceof _VirtualTool) {
        yield* content.tools();
      } else {
        yield content;
      }
    }
  }
};

// src/extension/tools/common/virtualTools/virtualToolGrouper.ts
init_collections();
init_stopwatch();

// src/extension/tools/common/virtualTools/builtInToolGroupHandler.ts
init_assert();
init_collections();
var BUILT_IN_GROUP = "builtin";
var SUMMARY_PREFIX = "Call this tool when you need access to a new category of tools. The category of tools is described as follows:\n\n";
var SUMMARY_SUFFIX = "\n\nBe sure to call this tool if you need a capability related to the above.";
function getCategorySummary(category) {
  switch (category) {
    case "Jupyter Notebook Tools" /* JupyterNotebook */:
      return "Call tools from this group when you need to work with Jupyter notebooks - creating, editing, running cells, and managing notebook operations.";
    case "Web Interaction" /* WebInteraction */:
      return "Call tools from this group when you need to interact with web content, browse websites, or access external resources.";
    case "VS Code Interaction" /* VSCodeInteraction */:
      return "Call tools from this group when you need to interact with the VS Code workspace and access VS Code features.";
    case "Testing" /* Testing */:
      return "Call tools from this group when you need to run tests, analyze test failures, and manage test workflows.";
    case "Redundant but Specific" /* RedundantButSpecific */: {
      const toolNames = getToolsForCategory(category);
      return `These tools have overlapping functionalities but are highly specialized for certain tasks. Tools: ${toolNames.join(", ")}`;
    }
    case "Core" /* Core */:
      return "Core tools that should always be available without grouping.";
    default:
      return assertNever(category);
  }
}
var BuiltInToolGroupHandler = class {
  constructor() {
  }
  /** Creates groups for built-in tools based on the type-safe categorization system */
  createBuiltInToolGroups(tools) {
    if (tools.length <= MIN_TOOLSET_SIZE_TO_GROUP) {
      return tools;
    }
    const contributedTools = tools.filter((t2) => !toolCategories.hasOwnProperty(t2.name));
    const builtInTools = tools.filter((t2) => toolCategories.hasOwnProperty(t2.name));
    const toolsToGroup = builtInTools.filter((t2) => toolCategories[t2.name] !== "Core" /* Core */);
    const coreTools = builtInTools.filter((t2) => toolCategories[t2.name] === "Core" /* Core */);
    const categories = groupBy(toolsToGroup, (t2) => toolCategories[t2.name]);
    const virtualTools = Object.entries(categories).flatMap(([category, tools2]) => {
      if (tools2.length < MIN_TOOLSET_SIZE_TO_GROUP) {
        return tools2;
      }
      return new VirtualTool(
        VIRTUAL_TOOL_NAME_PREFIX + category.toLowerCase().replace(/\s+/g, "_"),
        SUMMARY_PREFIX + getCategorySummary(category) + SUMMARY_SUFFIX,
        0,
        {
          possiblePrefix: "builtin_",
          wasExpandedByDefault: false,
          canBeCollapsed: true
        },
        tools2
      );
    });
    return [...virtualTools, ...coreTools, ...contributedTools];
  }
  static get BUILT_IN_GROUP_KEY() {
    return BUILT_IN_GROUP;
  }
};

// src/extension/tools/common/virtualTools/virtualToolSummarizer.tsx
var import_prompt_tsx3 = __toESM(require_base());

// src/platform/chat/common/commonTypes.ts
var ChatLocation2 = /* @__PURE__ */ ((ChatLocation3) => {
  ChatLocation3[ChatLocation3["Panel"] = 1] = "Panel";
  ChatLocation3[ChatLocation3["Terminal"] = 2] = "Terminal";
  ChatLocation3[ChatLocation3["Notebook"] = 3] = "Notebook";
  ChatLocation3[ChatLocation3["Editor"] = 4] = "Editor";
  ChatLocation3[ChatLocation3["EditingSession"] = 5] = "EditingSession";
  ChatLocation3[ChatLocation3["Other"] = 6] = "Other";
  ChatLocation3[ChatLocation3["Agent"] = 7] = "Agent";
  ChatLocation3[ChatLocation3["ResponsesProxy"] = 8] = "ResponsesProxy";
  return ChatLocation3;
})(ChatLocation2 || {});
((ChatLocation3) => {
  function toString(chatLocation) {
    switch (chatLocation) {
      case 4 /* Editor */:
        return "conversationInline";
      case 1 /* Panel */:
        return "conversationPanel";
      case 5 /* EditingSession */:
        return "editingSession";
      case 7 /* Agent */:
        return "editingSessionAgent";
      default:
        return "none";
    }
  }
  ChatLocation3.toString = toString;
  function toStringShorter(chatLocation) {
    switch (chatLocation) {
      case 4 /* Editor */:
      case 3 /* Notebook */:
        return "inline";
      case 1 /* Panel */:
        return "panel";
      case 5 /* EditingSession */:
        return "editingSession";
      default:
        return "none";
    }
  }
  ChatLocation3.toStringShorter = toStringShorter;
})(ChatLocation2 || (ChatLocation2 = {}));

// node_modules/markdown-it/lib/common/utils.mjs
var utils_exports = {};
__export(utils_exports, {
  arrayReplaceAt: () => arrayReplaceAt,
  assign: () => assign,
  escapeHtml: () => escapeHtml,
  escapeRE: () => escapeRE,
  fromCodePoint: () => fromCodePoint2,
  has: () => has,
  isMdAsciiPunct: () => isMdAsciiPunct,
  isPunctChar: () => isPunctChar,
  isSpace: () => isSpace,
  isString: () => isString2,
  isValidEntityCode: () => isValidEntityCode,
  isWhiteSpace: () => isWhiteSpace2,
  lib: () => lib,
  normalizeReference: () => normalizeReference,
  unescapeAll: () => unescapeAll,
  unescapeMd: () => unescapeMd
});

// node_modules/mdurl/index.mjs
var mdurl_exports = {};
__export(mdurl_exports, {
  decode: () => decode_default,
  encode: () => encode_default,
  format: () => format5,
  parse: () => parse_default
});

// node_modules/mdurl/lib/decode.mjs
var decodeCache = {};
function getDecodeCache(exclude) {
  let cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (let i = 0; i < exclude.length; i++) {
    const ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode(string, exclude) {
  if (typeof exclude !== "string") {
    exclude = decode.defaultChars;
  }
  const cache = getDecodeCache(exclude);
  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    let result = "";
    for (let i = 0, l = seq.length; i < l; i += 3) {
      const b1 = parseInt(seq.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          const chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "\uFFFD\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        const b4 = parseInt(seq.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "\uFFFD\uFFFD\uFFFD\uFFFD";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "\uFFFD";
    }
    return result;
  });
}
decode.defaultChars = ";/?:@&=+$,#";
decode.componentChars = "";
var decode_default = decode;

// node_modules/mdurl/lib/encode.mjs
var encodeCache = {};
function getEncodeCache(exclude) {
  let cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (let i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode(string, exclude, keepEscaped) {
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  const cache = getEncodeCache(exclude);
  let result = "";
  for (let i = 0, l = string.length; i < l; i++) {
    const code2 = string.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
        const nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";
var encode_default = encode;

// node_modules/mdurl/lib/format.mjs
function format5(url) {
  let result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
}

// node_modules/mdurl/lib/parse.mjs
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i;
var portPattern = /:[0-9]*$/;
var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
var autoEscape = ["'"].concat(unwise);
var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
var hostEndingChars = ["/", "?", "#"];
var hostnameMaxLen = 255;
var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var hostlessProtocol = {
  javascript: true,
  "javascript:": true
};
var slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) return url;
  const u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  let lowerProto, hec, slashes;
  let rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    const simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  let proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    let hostEnd = -1;
    for (let i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    let auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (let i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    const host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./);
      for (let i = 0, l = hostparts.length; i < l; i++) {
        const part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          let newpart = "";
          for (let j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i);
            const notHost = hostparts.slice(i + 1);
            const bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  const hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  const qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  let port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse_default = urlParse;

// node_modules/uc.micro/index.mjs
var uc_exports = {};
__export(uc_exports, {
  Any: () => regex_default,
  Cc: () => regex_default2,
  Cf: () => regex_default3,
  P: () => regex_default4,
  S: () => regex_default5,
  Z: () => regex_default6
});

// node_modules/uc.micro/properties/Any/regex.mjs
var regex_default = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

// node_modules/uc.micro/categories/Cc/regex.mjs
var regex_default2 = /[\0-\x1F\x7F-\x9F]/;

// node_modules/uc.micro/categories/Cf/regex.mjs
var regex_default3 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

// node_modules/uc.micro/categories/P/regex.mjs
var regex_default4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

// node_modules/uc.micro/categories/S/regex.mjs
var regex_default5 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;

// node_modules/uc.micro/categories/Z/regex.mjs
var regex_default6 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a5;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a5 = String.fromCodePoint) !== null && _a5 !== void 0 ? _a5 : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a6;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a6 = decodeMap.get(codePoint)) !== null && _a6 !== void 0 ? _a6 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber2(code2) {
  return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber2(code2);
}
function isEntityInAttributeInvalidEnd(code2) {
  return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base2) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber2(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber2(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a6;
    if (this.consumed <= expectedLength) {
      (_a6 = this.errors) === null || _a6 === void 0 ? void 0 : _a6.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a6;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a6 = this.errors) === null || _a6 === void 0 ? void 0 : _a6.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a6;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a6 = this.errors) === null || _a6 === void 0 ? void 0 : _a6.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}

// node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/entities/lib/esm/escape.js
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index)
  )
);
function getEscaper(regex, map2) {
  return function escape4(data) {
    let match3;
    let lastIdx = 0;
    let result = "";
    while (match3 = regex.exec(data)) {
      if (lastIdx !== match3.index) {
        result += data.substring(lastIdx, match3.index);
      }
      result += map2.get(match3[0].charCodeAt(0));
      lastIdx = match3.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/markdown-it/lib/common/utils.mjs
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString2(obj) {
  return _class(obj) === "[object String]";
}
var _hasOwnProperty2 = Object.prototype.hasOwnProperty;
function has(object, key) {
  return _hasOwnProperty2.call(object, key);
}
function assign(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be object");
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}
function isValidEntityCode(c) {
  if (c >= 55296 && c <= 57343) {
    return false;
  }
  if (c >= 64976 && c <= 65007) {
    return false;
  }
  if ((c & 65535) === 65535 || (c & 65535) === 65534) {
    return false;
  }
  if (c >= 0 && c <= 8) {
    return false;
  }
  if (c === 11) {
    return false;
  }
  if (c >= 14 && c <= 31) {
    return false;
  }
  if (c >= 127 && c <= 159) {
    return false;
  }
  if (c > 1114111) {
    return false;
  }
  return true;
}
function fromCodePoint2(c) {
  if (c > 65535) {
    c -= 65536;
    const surrogate1 = 55296 + (c >> 10);
    const surrogate2 = 56320 + (c & 1023);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}
var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function replaceEntityPattern(match3, name) {
  if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
    const code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code2)) {
      return fromCodePoint2(code2);
    }
    return match3;
  }
  const decoded = decodeHTML(match3);
  if (decoded !== match3) {
    return decoded;
  }
  return match3;
}
function unescapeMd(str) {
  if (str.indexOf("\\") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, "$1");
}
function unescapeAll(str) {
  if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_ALL_RE, function(match3, escaped, entity2) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match3, entity2);
  });
}
var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}
var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, "\\$&");
}
function isSpace(code2) {
  switch (code2) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function isWhiteSpace2(code2) {
  if (code2 >= 8192 && code2 <= 8202) {
    return true;
  }
  switch (code2) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function isPunctChar(ch) {
  return regex_default4.test(ch) || regex_default5.test(ch);
}
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function normalizeReference(str) {
  str = str.trim().replace(/\s+/g, " ");
  if ("\u1E9E".toLowerCase() === "\u1E7E") {
    str = str.replace(//g, "\xDF");
  }
  return str.toLowerCase().toUpperCase();
}
var lib = { mdurl: mdurl_exports, ucmicro: uc_exports };

// node_modules/markdown-it/lib/helpers/index.mjs
var helpers_exports = {};
__export(helpers_exports, {
  parseLinkDestination: () => parseLinkDestination,
  parseLinkLabel: () => parseLinkLabel,
  parseLinkTitle: () => parseLinkTitle
});

// node_modules/markdown-it/lib/helpers/parse_link_label.mjs
function parseLinkLabel(state, start, disableNested) {
  let level, found, marker, prevPos;
  const max = state.posMax;
  const oldPos = state.pos;
  state.pos = start + 1;
  level = 1;
  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 91) {
      if (prevPos === state.pos - 1) {
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  let labelEnd = -1;
  if (found) {
    labelEnd = state.pos;
  }
  state.pos = oldPos;
  return labelEnd;
}

// node_modules/markdown-it/lib/helpers/parse_link_destination.mjs
function parseLinkDestination(str, start, max) {
  let code2;
  let pos = start;
  const result = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 === 10) {
        return result;
      }
      if (code2 === 60) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  let level = 0;
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str.slice(start, pos));
  result.pos = pos;
  result.ok = true;
  return result;
}

// node_modules/markdown-it/lib/helpers/parse_link_title.mjs
function parseLinkTitle(str, start, max, prev_state) {
  let code2;
  let pos = start;
  const state = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (prev_state) {
    state.str = prev_state.str;
    state.marker = prev_state.marker;
  } else {
    if (pos >= max) {
      return state;
    }
    let marker = str.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return state;
    }
    start++;
    pos++;
    if (marker === 40) {
      marker = 41;
    }
    state.marker = marker;
  }
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === state.marker) {
      state.pos = pos + 1;
      state.str += unescapeAll(str.slice(start, pos));
      state.ok = true;
      return state;
    } else if (code2 === 40 && state.marker === 41) {
      return state;
    } else if (code2 === 92 && pos + 1 < max) {
      pos++;
    }
    pos++;
  }
  state.can_continue = true;
  state.str += unescapeAll(str.slice(start, pos));
  return state;
}

// node_modules/markdown-it/lib/renderer.mjs
var default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env6, slf) {
  const token = tokens[idx];
  return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env6, slf) {
  const token = tokens[idx];
  return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env6, slf) {
  const token = tokens[idx];
  const info = token.info ? unescapeAll(token.info).trim() : "";
  let langName = "";
  let langAttrs = "";
  if (info) {
    const arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  let highlighted;
  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    const i = token.attrIndex("class");
    const tmpAttrs = token.attrs ? token.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    const tmpToken = {
      attrs: tmpAttrs
    };
    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
  }
  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`;
};
default_rules.image = function(tokens, idx, options, env6, slf) {
  const token = tokens[idx];
  token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env6);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer() {
  this.rules = assign({}, default_rules);
}
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  let i, l, result;
  if (!token.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }
  return result;
};
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  const token = tokens[idx];
  let result = "";
  if (token.hidden) {
    return "";
  }
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token.nesting === -1 ? "</" : "<") + token.tag;
  result += this.renderAttrs(token);
  if (token.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  let needLf = false;
  if (token.block) {
    needLf = true;
    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        const nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer.prototype.renderInline = function(tokens, options, env6) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env6, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};
Renderer.prototype.renderInlineAsText = function(tokens, options, env6) {
  let result = "";
  for (let i = 0, len = tokens.length; i < len; i++) {
    switch (tokens[i].type) {
      case "text":
        result += tokens[i].content;
        break;
      case "image":
        result += this.renderInlineAsText(tokens[i].children, options, env6);
        break;
      case "html_inline":
      case "html_block":
        result += tokens[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        result += "\n";
        break;
      default:
    }
  }
  return result;
};
Renderer.prototype.render = function(tokens, options, env6) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (type === "inline") {
      result += this.renderInline(tokens[i].children, options, env6);
    } else if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env6, this);
    } else {
      result += this.renderToken(tokens, i, options, env6);
    }
  }
  return result;
};
var renderer_default = Renderer;

// node_modules/markdown-it/lib/ruler.mjs
function Ruler() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name) {
  for (let i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};
Ruler.prototype.__compile__ = function() {
  const self = this;
  const chains = [""];
  self.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self.__cache__ = {};
  chains.forEach(function(chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler.prototype.at = function(name, fn, options) {
  const index = this.__find__(name);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + name);
  }
  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
  const index = this.__find__(beforeName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn, options) {
  const index = this.__find__(afterName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn, options) {
  const opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.enable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name) {
    const idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list2, ignoreInvalid);
};
Ruler.prototype.disable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name) {
    const idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler_default = Ruler;

// node_modules/markdown-it/lib/token.mjs
function Token(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token.prototype.attrIndex = function attrIndex(name) {
  if (!this.attrs) {
    return -1;
  }
  const attrs = this.attrs;
  for (let i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token.prototype.attrSet = function attrSet(name, value) {
  const idx = this.attrIndex(name);
  const attrData = [name, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token.prototype.attrGet = function attrGet(name) {
  const idx = this.attrIndex(name);
  let value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token.prototype.attrJoin = function attrJoin(name, value) {
  const idx = this.attrIndex(name);
  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
var token_default = Token;

// node_modules/markdown-it/lib/rules_core/state_core.mjs
function StateCore(src, md, env6) {
  this.src = src;
  this.env = env6;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
StateCore.prototype.Token = token_default;
var state_core_default = StateCore;

// node_modules/markdown-it/lib/rules_core/normalize.mjs
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
function normalize2(state) {
  let str;
  str = state.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "\uFFFD");
  state.src = str;
}

// node_modules/markdown-it/lib/rules_core/block.mjs
function block(state) {
  let token;
  if (state.inlineMode) {
    token = new state.Token("inline", "", 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
}

// node_modules/markdown-it/lib/rules_core/inline.mjs
function inline(state) {
  const tokens = state.tokens;
  for (let i = 0, l = tokens.length; i < l; i++) {
    const tok = tokens[i];
    if (tok.type === "inline") {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
}

// node_modules/markdown-it/lib/rules_core/linkify.mjs
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
function linkify(state) {
  const blockTokens = state.tokens;
  if (!state.md.options.linkify) {
    return;
  }
  for (let j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    let tokens = blockTokens[j].children;
    let htmlLinkLevel = 0;
    for (let i = tokens.length - 1; i >= 0; i--) {
      const currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
        const text2 = currentToken.content;
        let links = state.md.linkify.match(text2);
        const nodes = [];
        let level = currentToken.level;
        let lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (let ln = 0; ln < links.length; ln++) {
          const url = links[ln].url;
          const fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          let urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          const pos = links[ln].index;
          if (pos > lastPos) {
            const token = new state.Token("text", "", 0);
            token.content = text2.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }
          const token_o = new state.Token("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.level = level++;
          token_o.markup = "linkify";
          token_o.info = "auto";
          nodes.push(token_o);
          const token_t = new state.Token("text", "", 0);
          token_t.content = urlText;
          token_t.level = level;
          nodes.push(token_t);
          const token_c = new state.Token("link_close", "a", -1);
          token_c.level = --level;
          token_c.markup = "linkify";
          token_c.info = "auto";
          nodes.push(token_c);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text2.length) {
          const token = new state.Token("text", "", 0);
          token.content = text2.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
}

// node_modules/markdown-it/lib/rules_core/replacements.mjs
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
var SCOPED_ABBR = {
  c: "\xA9",
  r: "\xAE",
  tm: "\u2122"
};
function replaceFn(match3, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
      }
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace(state) {
  let blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
}

// node_modules/markdown-it/lib/rules_core/smartquotes.mjs
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = "\u2019";
function replaceAt(str, index, ch) {
  return str.slice(0, index) + ch + str.slice(index + 1);
}
function process_inlines(tokens, state) {
  let j;
  const stack = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    const thisLevel = tokens[i].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token.type !== "text") {
      continue;
    }
    let text2 = token.content;
    let pos = 0;
    let max = text2.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        const t2 = QUOTE_RE.exec(text2);
        if (!t2) {
          break;
        }
        let canOpen = true;
        let canClose = true;
        pos = t2.index + 1;
        const isSingle = t2[0] === "'";
        let lastChar = 32;
        if (t2.index - 1 >= 0) {
          lastChar = text2.charCodeAt(t2.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
            if (!tokens[j].content) continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        let nextChar = 32;
        if (pos < max) {
          nextChar = text2.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
            if (!tokens[j].content) continue;
            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
        const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
        const isLastWhiteSpace = isWhiteSpace2(lastChar);
        const isNextWhiteSpace = isWhiteSpace2(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t2[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token.content = replaceAt(token.content, t2.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j = stack.length - 1; j >= 0; j--) {
            let item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              let openQuote;
              let closeQuote;
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              token.content = replaceAt(token.content, t2.index, closeQuote);
              tokens[item.token].content = replaceAt(
                tokens[item.token].content,
                item.pos,
                openQuote
              );
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text2 = token.content;
              max = text2.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t2.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t2.index, APOSTROPHE);
        }
      }
  }
}
function smartquotes(state) {
  if (!state.md.options.typographer) {
    return;
  }
  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
}

// node_modules/markdown-it/lib/rules_core/text_join.mjs
function text_join(state) {
  let curr, last;
  const blockTokens = state.tokens;
  const l = blockTokens.length;
  for (let j = 0; j < l; j++) {
    if (blockTokens[j].type !== "inline") continue;
    const tokens = blockTokens[j].children;
    const max = tokens.length;
    for (curr = 0; curr < max; curr++) {
      if (tokens[curr].type === "text_special") {
        tokens[curr].type = "text";
      }
    }
    for (curr = last = 0; curr < max; curr++) {
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens.length = last;
    }
  }
}

// node_modules/markdown-it/lib/parser_core.mjs
var _rules = [
  ["normalize", normalize2],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify],
  ["replacements", replace],
  ["smartquotes", smartquotes],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", text_join]
];
function Core() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}
Core.prototype.process = function(state) {
  const rules = this.ruler.getRules("");
  for (let i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};
Core.prototype.State = state_core_default;
var parser_core_default = Core;

// node_modules/markdown-it/lib/rules_block/state_block.mjs
function StateBlock(src, md, env6, tokens) {
  this.src = src;
  this.md = md;
  this.env = env6;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  const s = this.src;
  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
    const ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type, tag, nesting) {
  const token = new token_default(type, tag, nesting);
  token.block = true;
  if (nesting < 0) this.level--;
  token.level = this.level;
  if (nesting > 0) this.level++;
  this.tokens.push(token);
  return token;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (let max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (let max = this.src.length; pos < max; pos++) {
    const ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (let max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  if (begin >= end) {
    return "";
  }
  const queue = new Array(end - begin);
  for (let i = 0, line = begin; line < end; line++, i++) {
    let lineIndent = 0;
    const lineStart = this.bMarks[line];
    let first = lineStart;
    let last;
    if (line + 1 < end || keepLastLF) {
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }
    while (first < last && lineIndent < indent) {
      const ch = this.src.charCodeAt(first);
      if (isSpace(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent) {
      queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = token_default;
var state_block_default = StateBlock;

// node_modules/markdown-it/lib/rules_block/table.mjs
var MAX_AUTOCOMPLETED_CELLS = 65536;
function getLine(state, line) {
  const pos = state.bMarks[line] + state.tShift[line];
  const max = state.eMarks[line];
  return state.src.slice(pos, max);
}
function escapedSplit(str) {
  const result = [];
  const max = str.length;
  let pos = 0;
  let ch = str.charCodeAt(pos);
  let isEscaped = false;
  let lastPos = 0;
  let current = "";
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
function table(state, startLine, endLine, silent) {
  if (startLine + 2 > endLine) {
    return false;
  }
  let nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    const ch = state.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
      return false;
    }
    pos++;
  }
  let lineText = getLine(state, startLine + 1);
  let columns = lineText.split("|");
  const aligns = [];
  for (let i = 0; i < columns.length; i++) {
    const t2 = columns[i].trim();
    if (!t2) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t2)) {
      return false;
    }
    if (t2.charCodeAt(t2.length - 1) === 58) {
      aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t2.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "") columns.shift();
  if (columns.length && columns[columns.length - 1] === "") columns.pop();
  const columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldParentType = state.parentType;
  state.parentType = "table";
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const token_to = state.push("table_open", "table", 1);
  const tableLines = [startLine, 0];
  token_to.map = tableLines;
  const token_tho = state.push("thead_open", "thead", 1);
  token_tho.map = [startLine, startLine + 1];
  const token_htro = state.push("tr_open", "tr", 1);
  token_htro.map = [startLine, startLine + 1];
  for (let i = 0; i < columns.length; i++) {
    const token_ho = state.push("th_open", "th", 1);
    if (aligns[i]) {
      token_ho.attrs = [["style", "text-align:" + aligns[i]]];
    }
    const token_il = state.push("inline", "", 0);
    token_il.content = columns[i].trim();
    token_il.children = [];
    state.push("th_close", "th", -1);
  }
  state.push("tr_close", "tr", -1);
  state.push("thead_close", "thead", -1);
  let tbodyLines;
  let autocompletedCells = 0;
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "") columns.shift();
    if (columns.length && columns[columns.length - 1] === "") columns.pop();
    autocompletedCells += columnCount - columns.length;
    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
      break;
    }
    if (nextLine === startLine + 2) {
      const token_tbo = state.push("tbody_open", "tbody", 1);
      token_tbo.map = tbodyLines = [startLine + 2, 0];
    }
    const token_tro = state.push("tr_open", "tr", 1);
    token_tro.map = [nextLine, nextLine + 1];
    for (let i = 0; i < columnCount; i++) {
      const token_tdo = state.push("td_open", "td", 1);
      if (aligns[i]) {
        token_tdo.attrs = [["style", "text-align:" + aligns[i]]];
      }
      const token_il = state.push("inline", "", 0);
      token_il.content = columns[i] ? columns[i].trim() : "";
      token_il.children = [];
      state.push("td_close", "td", -1);
    }
    state.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    state.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  state.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
}

// node_modules/markdown-it/lib/rules_block/code.mjs
function code(state, startLine, endLine) {
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  let nextLine = startLine + 1;
  let last = nextLine;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state.line = last;
  const token = state.push("code_block", "code", 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
  token.map = [startLine, state.line];
  return true;
}

// node_modules/markdown-it/lib/rules_block/fence.mjs
function fence(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  const marker = state.src.charCodeAt(pos);
  if (marker !== 126 && marker !== 96) {
    return false;
  }
  let mem = pos;
  pos = state.skipChars(pos, marker);
  let len = pos - mem;
  if (len < 3) {
    return false;
  }
  const markup = state.src.slice(mem, pos);
  const params = state.src.slice(pos, max);
  if (marker === 96) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  let nextLine = startLine;
  let haveEndMarker = false;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue;
    }
    pos = state.skipChars(pos, marker);
    if (pos - mem < len) {
      continue;
    }
    pos = state.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  const token = state.push("fence", "code", 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];
  return true;
}

// node_modules/markdown-it/lib/rules_block/blockquote.mjs
function blockquote(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  const oldLineMax = state.lineMax;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldBMarks = [];
  const oldBSCount = [];
  const oldSCount = [];
  const oldTShift = [];
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const oldParentType = state.parentType;
  state.parentType = "blockquote";
  let lastLineEmpty = false;
  let nextLine;
  for (nextLine = startLine; nextLine < endLine; nextLine++) {
    const isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      let initial = state.sCount[nextLine] + 1;
      let spaceAfterMarker;
      let adjustTab;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + initial) % 4 === 3) {
          pos++;
          initial++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      let offset = initial;
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max) {
        const ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);
    state.sCount[nextLine] = -1;
  }
  const oldIndent = state.blkIndent;
  state.blkIndent = 0;
  const token_o = state.push("blockquote_open", "blockquote", 1);
  token_o.markup = ">";
  const lines = [startLine, 0];
  token_o.map = lines;
  state.md.block.tokenize(state, startLine, nextLine);
  const token_c = state.push("blockquote_close", "blockquote", -1);
  token_c.markup = ">";
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;
  for (let i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;
  return true;
}

// node_modules/markdown-it/lib/rules_block/hr.mjs
function hr(state, startLine, endLine, silent) {
  const max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false;
  }
  let cnt = 1;
  while (pos < max) {
    const ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  const token = state.push("hr", "hr", 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
}

// node_modules/markdown-it/lib/rules_block/list.mjs
function skipBulletListMarker(state, startLine) {
  const max = state.eMarks[startLine];
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1;
  }
  if (pos < max) {
    const ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state, startLine) {
  const start = state.bMarks[startLine] + state.tShift[startLine];
  const max = state.eMarks[startLine];
  let pos = start;
  if (pos + 1 >= max) {
    return -1;
  }
  let ch = state.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  const level = state.level + 2;
  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}
function list(state, startLine, endLine, silent) {
  let max, pos, start, token;
  let nextLine = startLine;
  let tight = true;
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  let isTerminatingParagraph = false;
  if (silent && state.parentType === "paragraph") {
    if (state.sCount[nextLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  let isOrdered;
  let markerValue;
  let posAfterMarker;
  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[nextLine] + state.tShift[nextLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false;
  }
  if (silent) {
    return true;
  }
  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
  const listTokIdx = state.tokens.length;
  if (isOrdered) {
    token = state.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token.attrs = [["start", markerValue]];
    }
  } else {
    token = state.push("bullet_list_open", "ul", 1);
  }
  const listLines = [nextLine, 0];
  token.map = listLines;
  token.markup = String.fromCharCode(markerCharCode);
  let prevEmptyEnd = false;
  const terminatorRules = state.md.block.ruler.getRules("list");
  const oldParentType = state.parentType;
  state.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];
    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
    let offset = initial;
    while (pos < max) {
      const ch = state.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    const contentStart = pos;
    let indentAfterMarker;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    const indent = initial + indentAfterMarker;
    token = state.push("list_item_open", "li", 1);
    token.markup = String.fromCharCode(markerCharCode);
    const itemLines = [nextLine, 0];
    token.map = itemLines;
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1);
    }
    const oldTight = state.tight;
    const oldTShift = state.tShift[nextLine];
    const oldSCount = state.sCount[nextLine];
    const oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
    state.sCount[nextLine] = offset;
    if (contentStart >= max && state.isEmpty(nextLine + 1)) {
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, nextLine, endLine, true);
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[nextLine] = oldTShift;
    state.sCount[nextLine] = oldSCount;
    state.tight = oldTight;
    token = state.push("list_item_close", "li", -1);
    token.markup = String.fromCharCode(markerCharCode);
    nextLine = state.line;
    itemLines[1] = nextLine;
    if (nextLine >= endLine) {
      break;
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token = state.push("ordered_list_close", "ol", -1);
  } else {
    token = state.push("bullet_list_close", "ul", -1);
  }
  token.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
}

// node_modules/markdown-it/lib/rules_block/reference.mjs
function reference(state, startLine, _endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  let nextLine = startLine + 1;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false;
  }
  function getNextLine(nextLine2) {
    const endLine = state.lineMax;
    if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
      return null;
    }
    let isContinuation = false;
    if (state.sCount[nextLine2] - state.blkIndent > 3) {
      isContinuation = true;
    }
    if (state.sCount[nextLine2] < 0) {
      isContinuation = true;
    }
    if (!isContinuation) {
      const terminatorRules = state.md.block.ruler.getRules("reference");
      const oldParentType = state.parentType;
      state.parentType = "reference";
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine2, endLine, true)) {
          terminate = true;
          break;
        }
      }
      state.parentType = oldParentType;
      if (terminate) {
        return null;
      }
    }
    const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2];
    const max2 = state.eMarks[nextLine2];
    return state.src.slice(pos2, max2 + 1);
  }
  let str = state.src.slice(pos, max + 1);
  max = str.length;
  let labelEnd = -1;
  for (pos = 1; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (ch === 92) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max = str.length;
          nextLine++;
        }
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  const destRes = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!destRes.ok) {
    return false;
  }
  const href = state.md.normalizeLink(destRes.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = destRes.pos;
  const destEndPos = pos;
  const destEndLineNo = nextLine;
  const start = pos;
  for (; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max);
  while (titleRes.can_continue) {
    const lineContent = getNextLine(nextLine);
    if (lineContent === null) break;
    str += lineContent;
    pos = max;
    max = str.length;
    nextLine++;
    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes);
  }
  let title;
  if (pos < max && start !== pos && titleRes.ok) {
    title = titleRes.str;
    pos = titleRes.pos;
  } else {
    title = "";
    pos = destEndPos;
    nextLine = destEndLineNo;
  }
  while (pos < max) {
    const ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
      while (pos < max) {
        const ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false;
  }
  const label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state.env.references === "undefined") {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === "undefined") {
    state.env.references[label] = { title, href };
  }
  state.line = nextLine;
  return true;
}

// node_modules/markdown-it/lib/common/html_blocks.mjs
var html_blocks_default = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];

// node_modules/markdown-it/lib/common/html_re.mjs
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Za-z][^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");

// node_modules/markdown-it/lib/rules_block/html_block.mjs
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + html_blocks_default.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
function html_block(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  let lineText = state.src.slice(pos, max);
  let i = 0;
  for (; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  let nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  const token = state.push("html_block", "", 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
}

// node_modules/markdown-it/lib/rules_block/heading.mjs
function heading(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let ch = state.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max) {
    return false;
  }
  let level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 35 && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max = state.skipSpacesBack(max, pos);
  const tmp = state.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state.line = startLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = "########".slice(0, level);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = state.src.slice(pos, max).trim();
  token_i.map = [startLine, state.line];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = "########".slice(0, level);
  return true;
}

// node_modules/markdown-it/lib/rules_block/lheading.mjs
function lheading(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  const oldParentType = state.parentType;
  state.parentType = "paragraph";
  let level = 0;
  let marker;
  let nextLine = startLine + 1;
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      let pos = state.bMarks[nextLine] + state.tShift[nextLine];
      const max = state.eMarks[nextLine];
      if (pos < max) {
        marker = state.src.charCodeAt(pos);
        if (marker === 45 || marker === 61) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);
          if (pos >= max) {
            level = marker === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = String.fromCharCode(marker);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line - 1];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = String.fromCharCode(marker);
  state.parentType = oldParentType;
  return true;
}

// node_modules/markdown-it/lib/rules_block/paragraph.mjs
function paragraph(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  const oldParentType = state.parentType;
  let nextLine = startLine + 1;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  const token_o = state.push("paragraph_open", "p", 1);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line];
  token_i.children = [];
  state.push("paragraph_close", "p", -1);
  state.parentType = oldParentType;
  return true;
}

// node_modules/markdown-it/lib/parser_block.mjs
var _rules2 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", table, ["paragraph", "reference"]],
  ["code", code],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules2.length; i++) {
    this.ruler.push(_rules2[i][0], _rules2[i][1], { alt: (_rules2[i][2] || []).slice() });
  }
}
ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  let line = startLine;
  let hasEmptyLines = false;
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state.sCount[line] < state.blkIndent) {
      break;
    }
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }
    const prevLine = state.line;
    let ok = false;
    for (let i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        if (prevLine >= state.line) {
          throw new Error("block rule didn't increment state.line");
        }
        break;
      }
    }
    if (!ok) throw new Error("none of the block rules matched");
    state.tight = !hasEmptyLines;
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line = state.line;
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};
ParserBlock.prototype.parse = function(src, md, env6, outTokens) {
  if (!src) {
    return;
  }
  const state = new this.State(src, md, env6, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock.prototype.State = state_block_default;
var parser_block_default = ParserBlock;

// node_modules/markdown-it/lib/rules_inline/state_inline.mjs
function StateInline(src, md, env6, outTokens) {
  this.src = src;
  this.env = env6;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  const token = new token_default("text", "", 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = "";
  return token;
};
StateInline.prototype.push = function(type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  const token = new token_default(type, tag, nesting);
  let token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};
StateInline.prototype.scanDelims = function(start, canSplitWord) {
  const max = this.posMax;
  const marker = this.src.charCodeAt(start);
  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
  let pos = start;
  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }
  const count2 = pos - start;
  const nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  const isLastWhiteSpace = isWhiteSpace2(lastChar);
  const isNextWhiteSpace = isWhiteSpace2(nextChar);
  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
  return { can_open, can_close, length: count2 };
};
StateInline.prototype.Token = token_default;
var state_inline_default = StateInline;

// node_modules/markdown-it/lib/rules_inline/text.mjs
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function text(state, silent) {
  let pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/linkify.mjs
var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function linkify2(state, silent) {
  if (!state.md.options.linkify) return false;
  if (state.linkLevel > 0) return false;
  const pos = state.pos;
  const max = state.posMax;
  if (pos + 3 > max) return false;
  if (state.src.charCodeAt(pos) !== 58) return false;
  if (state.src.charCodeAt(pos + 1) !== 47) return false;
  if (state.src.charCodeAt(pos + 2) !== 47) return false;
  const match3 = state.pending.match(SCHEME_RE);
  if (!match3) return false;
  const proto = match3[1];
  const link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
  if (!link2) return false;
  let url = link2.url;
  if (url.length <= proto.length) return false;
  url = url.replace(/\*+$/, "");
  const fullUrl = state.md.normalizeLink(url);
  if (!state.md.validateLink(fullUrl)) return false;
  if (!silent) {
    state.pending = state.pending.slice(0, -proto.length);
    const token_o = state.push("link_open", "a", 1);
    token_o.attrs = [["href", fullUrl]];
    token_o.markup = "linkify";
    token_o.info = "auto";
    const token_t = state.push("text", "", 0);
    token_t.content = state.md.normalizeLinkText(url);
    const token_c = state.push("link_close", "a", -1);
    token_c.markup = "linkify";
    token_c.info = "auto";
  }
  state.pos += url.length - proto.length;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/newline.mjs
function newline(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  const pmax = state.pending.length - 1;
  const max = state.posMax;
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        let ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32) ws--;
        state.pending = state.pending.slice(0, ws);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/escape.mjs
var ESCAPED = [];
for (let i = 0; i < 256; i++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape3(state, silent) {
  let pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 92) return false;
  pos++;
  if (pos >= max) return false;
  let ch1 = state.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent) {
      state.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max) {
      ch1 = state.src.charCodeAt(pos);
      if (!isSpace(ch1)) break;
      pos++;
    }
    state.pos = pos;
    return true;
  }
  let escapedStr = state.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
    const ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state.src[pos + 1];
      pos++;
    }
  }
  const origStr = "\\" + escapedStr;
  if (!silent) {
    const token = state.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token.content = escapedStr;
    } else {
      token.content = origStr;
    }
    token.markup = origStr;
    token.info = "escape";
  }
  state.pos = pos + 1;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/backticks.mjs
function backtick(state, silent) {
  let pos = state.pos;
  const ch = state.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  const start = pos;
  pos++;
  const max = state.posMax;
  while (pos < max && state.src.charCodeAt(pos) === 96) {
    pos++;
  }
  const marker = state.src.slice(start, pos);
  const openerLength = marker.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent) state.pending += marker;
    state.pos += openerLength;
    return true;
  }
  let matchEnd = pos;
  let matchStart;
  while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    const closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        const token = state.push("code_inline", "code", 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state.pos = matchEnd;
      return true;
    }
    state.backticks[closerLength] = matchStart;
  }
  state.backticksScanned = true;
  if (!silent) state.pending += marker;
  state.pos += openerLength;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/strikethrough.mjs
function strikethrough_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 126) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, true);
  let len = scanned.length;
  const ch = String.fromCharCode(marker);
  if (len < 2) {
    return false;
  }
  let token;
  if (len % 2) {
    token = state.push("text", "", 0);
    token.content = ch;
    len--;
  }
  for (let i = 0; i < len; i += 2) {
    token = state.push("text", "", 0);
    token.content = ch + ch;
    state.delimiters.push({
      marker,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess(state, delimiters) {
  let token;
  const loneMarkers = [];
  const max = delimiters.length;
  for (let i = 0; i < max; i++) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    token = state.tokens[startDelim.token];
    token.type = "s_open";
    token.tag = "s";
    token.nesting = 1;
    token.markup = "~~";
    token.content = "";
    token = state.tokens[endDelim.token];
    token.type = "s_close";
    token.tag = "s";
    token.nesting = -1;
    token.markup = "~~";
    token.content = "";
    if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    const i = loneMarkers.pop();
    let j = i + 1;
    while (j < state.tokens.length && state.tokens[j].type === "s_close") {
      j++;
    }
    j--;
    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}
function strikethrough_postProcess(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
}
var strikethrough_default = {
  tokenize: strikethrough_tokenize,
  postProcess: strikethrough_postProcess
};

// node_modules/markdown-it/lib/rules_inline/emphasis.mjs
function emphasis_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 95 && marker !== 42) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, marker === 42);
  for (let i = 0; i < scanned.length; i++) {
    const token = state.push("text", "", 0);
    token.content = String.fromCharCode(marker);
    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess2(state, delimiters) {
  const max = delimiters.length;
  for (let i = max - 1; i >= 0; i--) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    const isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
    delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    delimiters[startDelim.end + 1].token === endDelim.token + 1;
    const ch = String.fromCharCode(startDelim.marker);
    const token_o = state.tokens[startDelim.token];
    token_o.type = isStrong ? "strong_open" : "em_open";
    token_o.tag = isStrong ? "strong" : "em";
    token_o.nesting = 1;
    token_o.markup = isStrong ? ch + ch : ch;
    token_o.content = "";
    const token_c = state.tokens[endDelim.token];
    token_c.type = isStrong ? "strong_close" : "em_close";
    token_c.tag = isStrong ? "strong" : "em";
    token_c.nesting = -1;
    token_c.markup = isStrong ? ch + ch : ch;
    token_c.content = "";
    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = "";
      state.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
function emphasis_post_process(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess2(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess2(state, tokens_meta[curr].delimiters);
    }
  }
}
var emphasis_default = {
  tokenize: emphasis_tokenize,
  postProcess: emphasis_post_process
};

// node_modules/markdown-it/lib/rules_inline/link.mjs
function link(state, silent) {
  let code2, label, res, ref;
  let href = "";
  let title = "";
  let start = state.pos;
  let parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false;
  }
  const oldPos = state.pos;
  const max = state.posMax;
  const labelStart = state.pos + 1;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  let pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    const token_o = state.push("link_open", "a", 1);
    const attrs = [["href", href]];
    token_o.attrs = attrs;
    if (title) {
      attrs.push(["title", title]);
    }
    state.linkLevel++;
    state.md.inline.tokenize(state);
    state.linkLevel--;
    state.push("link_close", "a", -1);
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/image.mjs
function image(state, silent) {
  let code2, content, label, pos, ref, res, title, start;
  let href = "";
  const oldPos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false;
  }
  const labelStart = state.pos + 2;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    const tokens = [];
    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens
    );
    const token = state.push("image", "img", 0);
    const attrs = [["src", href], ["alt", ""]];
    token.attrs = attrs;
    token.children = tokens;
    token.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/autolink.mjs
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function autolink(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  const start = state.pos;
  const max = state.posMax;
  for (; ; ) {
    if (++pos >= max) return false;
    const ch = state.src.charCodeAt(pos);
    if (ch === 60) return false;
    if (ch === 62) break;
  }
  const url = state.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    const fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    const fullUrl = state.md.normalizeLink("mailto:" + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
}

// node_modules/markdown-it/lib/rules_inline/html_inline.mjs
function isLinkOpen2(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose2(str) {
  return /^<\/a\s*>/i.test(str);
}
function isLetter(ch) {
  const lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function html_inline(state, silent) {
  if (!state.md.options.html) {
    return false;
  }
  const max = state.posMax;
  const pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  const ch = state.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  const match3 = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match3) {
    return false;
  }
  if (!silent) {
    const token = state.push("html_inline", "", 0);
    token.content = match3[0];
    if (isLinkOpen2(token.content)) state.linkLevel++;
    if (isLinkClose2(token.content)) state.linkLevel--;
  }
  state.pos += match3[0].length;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/entity.mjs
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state, silent) {
  const pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 38) return false;
  if (pos + 1 >= max) return false;
  const ch = state.src.charCodeAt(pos + 1);
  if (ch === 35) {
    const match3 = state.src.slice(pos).match(DIGITAL_RE);
    if (match3) {
      if (!silent) {
        const code2 = match3[1][0].toLowerCase() === "x" ? parseInt(match3[1].slice(1), 16) : parseInt(match3[1], 10);
        const token = state.push("text_special", "", 0);
        token.content = isValidEntityCode(code2) ? fromCodePoint2(code2) : fromCodePoint2(65533);
        token.markup = match3[0];
        token.info = "entity";
      }
      state.pos += match3[0].length;
      return true;
    }
  } else {
    const match3 = state.src.slice(pos).match(NAMED_RE);
    if (match3) {
      const decoded = decodeHTML(match3[0]);
      if (decoded !== match3[0]) {
        if (!silent) {
          const token = state.push("text_special", "", 0);
          token.content = decoded;
          token.markup = match3[0];
          token.info = "entity";
        }
        state.pos += match3[0].length;
        return true;
      }
    }
  }
  return false;
}

// node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs
function processDelimiters(delimiters) {
  const openersBottom = {};
  const max = delimiters.length;
  if (!max) return;
  let headerIdx = 0;
  let lastTokenIdx = -2;
  const jumps = [];
  for (let closerIdx = 0; closerIdx < max; closerIdx++) {
    const closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close) continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    let openerIdx = headerIdx - jumps[headerIdx] - 1;
    let newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      const opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker) continue;
      if (opener.open && opener.end < 0) {
        let isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
function link_pairs(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  processDelimiters(state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(tokens_meta[curr].delimiters);
    }
  }
}

// node_modules/markdown-it/lib/rules_inline/fragments_join.mjs
function fragments_join(state) {
  let curr, last;
  let level = 0;
  const tokens = state.tokens;
  const max = state.tokens.length;
  for (curr = last = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0) level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0) level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens.length = last;
  }
}

// node_modules/markdown-it/lib/parser_inline.mjs
var _rules3 = [
  ["text", text],
  ["linkify", linkify2],
  ["newline", newline],
  ["escape", escape3],
  ["backticks", backtick],
  ["strikethrough", strikethrough_default.tokenize],
  ["emphasis", emphasis_default.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules22 = [
  ["balance_pairs", link_pairs],
  ["strikethrough", strikethrough_default.postProcess],
  ["emphasis", emphasis_default.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", fragments_join]
];
function ParserInline() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules3.length; i++) {
    this.ruler.push(_rules3[i][0], _rules3[i][1]);
  }
  this.ruler2 = new ruler_default();
  for (let i = 0; i < _rules22.length; i++) {
    this.ruler2.push(_rules22[i][0], _rules22[i][1]);
  }
}
ParserInline.prototype.skipToken = function(state) {
  const pos = state.pos;
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  const cache = state.cache;
  if (typeof cache[pos] !== "undefined") {
    state.pos = cache[pos];
    return;
  }
  let ok = false;
  if (state.level < maxNesting) {
    for (let i = 0; i < len; i++) {
      state.level++;
      ok = rules[i](state, true);
      state.level--;
      if (ok) {
        if (pos >= state.pos) {
          throw new Error("inline rule didn't increment state.pos");
        }
        break;
      }
    }
  } else {
    state.pos = state.posMax;
  }
  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};
ParserInline.prototype.tokenize = function(state) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const end = state.posMax;
  const maxNesting = state.md.options.maxNesting;
  while (state.pos < end) {
    const prevPos = state.pos;
    let ok = false;
    if (state.level < maxNesting) {
      for (let i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          if (prevPos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    }
    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};
ParserInline.prototype.parse = function(str, md, env6, outTokens) {
  const state = new this.State(str, md, env6, outTokens);
  this.tokenize(state);
  const rules = this.ruler2.getRules("");
  const len = rules.length;
  for (let i = 0; i < len; i++) {
    rules[i](state);
  }
};
ParserInline.prototype.State = state_inline_default;
var parser_inline_default = ParserInline;

// node_modules/linkify-it/lib/re.mjs
function re_default(opts) {
  const re = {};
  opts = opts || {};
  re.src_Any = regex_default.source;
  re.src_Cc = regex_default2.source;
  re.src_Z = regex_default6.source;
  re.src_P = regex_default4.source;
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
  re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
  const text_separators = "[><\uFF5C]";
  re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
  re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
  re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
  re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
  re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
  re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
  re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
  re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
  re.src_host_strict = re.src_host + re.src_host_terminator;
  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
  re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
  re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
  re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
  return re;
}

// node_modules/linkify-it/index.mjs
function assign2(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class2(obj) {
  return Object.prototype.toString.call(obj);
}
function isString3(obj) {
  return _class2(obj) === "[object String]";
}
function isObject2(obj) {
  return _class2(obj) === "[object Object]";
}
function isRegExp(obj) {
  return _class2(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class2(obj) === "[object Function]";
}
function escapeRE2(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text2, pos, self) {
      const tail = text2.slice(pos);
      if (!self.re.http) {
        self.re.http = new RegExp(
          "^\\/\\/" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path,
          "i"
        );
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text2, pos, self) {
      const tail = text2.slice(pos);
      if (!self.re.no_http) {
        self.re.no_http = new RegExp(
          "^" + self.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          "(?:localhost|(?:(?:" + self.re.src_domain + ")\\.)+" + self.re.src_domain_root + ")" + self.re.src_port + self.re.src_host_terminator + self.re.src_path,
          "i"
        );
      }
      if (self.re.no_http.test(tail)) {
        if (pos >= 3 && text2[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text2[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text2, pos, self) {
      const tail = text2.slice(pos);
      if (!self.re.mailto) {
        self.re.mailto = new RegExp(
          "^" + self.re.src_email_name + "@" + self.re.src_host_strict,
          "i"
        );
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = "";
}
function createValidator(re) {
  return function(text2, pos) {
    const tail = text2.slice(pos);
    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match3, self) {
    self.normalize(match3);
  };
}
function compile(self) {
  const re = self.re = re_default(self.__opts__);
  const tlds2 = self.__tlds__.slice();
  self.onCompile();
  if (!self.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re.src_xn);
  re.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re.src_tlds);
  }
  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
  const aliases = [];
  self.__compiled__ = {};
  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }
  Object.keys(self.__schemas__).forEach(function(name) {
    const val = self.__schemas__[name];
    if (val === null) {
      return;
    }
    const compiled = { validate: null, link: null };
    self.__compiled__[name] = compiled;
    if (isObject2(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }
      return;
    }
    if (isString3(val)) {
      aliases.push(name);
      return;
    }
    schemaError(name, val);
  });
  aliases.forEach(function(alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      return;
    }
    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });
  self.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  const slist = Object.keys(self.__compiled__).filter(function(name) {
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE2).join("|");
  self.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
  self.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
  self.re.schema_at_start = RegExp("^" + self.re.schema_search.source, "i");
  self.re.pretest = RegExp(
    "(" + self.re.schema_test.source + ")|(" + self.re.host_fuzzy_test.source + ")|@",
    "i"
  );
  resetScanCache(self);
}
function Match(self, shift) {
  const start = self.__index__;
  const end = self.__last_index__;
  const text2 = self.__text_cache__.slice(start, end);
  this.schema = self.__schema__.toLowerCase();
  this.index = start + shift;
  this.lastIndex = end + shift;
  this.raw = text2;
  this.text = text2;
  this.url = text2;
}
function createMatch(self, shift) {
  const match3 = new Match(self, shift);
  self.__compiled__[match3.schema].normalize(match3, self);
  return match3;
}
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign2({}, defaultOptions, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign2({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign2(this.__opts__, options);
  return this;
};
LinkifyIt.prototype.test = function test(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) {
    return false;
  }
  let m, ml, me, len, shift, next, re, tld_pos, at_pos;
  if (this.re.schema_test.test(text2)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text2)) !== null) {
      len = this.testSchemaAt(text2, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text2.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text2.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text2.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt.prototype.pretest = function pretest(text2) {
  return this.re.pretest.test(text2);
};
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
};
LinkifyIt.prototype.match = function match2(text2) {
  const result = [];
  let shift = 0;
  if (this.__index__ >= 0 && this.__text_cache__ === text2) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  let tail = shift ? text2.slice(shift) : text2;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt.prototype.matchAtStart = function matchAtStart(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) return null;
  const m = this.re.schema_at_start.exec(text2);
  if (!m) return null;
  const len = this.testSchemaAt(text2, m[2], m[0].length);
  if (!len) return null;
  this.__schema__ = m[2];
  this.__index__ = m.index + m[1].length;
  this.__last_index__ = m.index + m[0].length + len;
  return createMatch(this, 0);
};
LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
  list2 = Array.isArray(list2) ? list2 : [list2];
  if (!keepOld) {
    this.__tlds__ = list2.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt.prototype.normalize = function normalize3(match3) {
  if (!match3.schema) {
    match3.url = "http://" + match3.url;
  }
  if (match3.schema === "mailto:" && !/^mailto:/i.test(match3.url)) {
    match3.url = "mailto:" + match3.url;
  }
};
LinkifyIt.prototype.onCompile = function onCompile() {
};
var linkify_it_default = LinkifyIt;

// node_modules/punycode.js/punycode.es6.js
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter2 = "-";
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7F]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
var basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
var digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
var adapt = function(delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
var decode2 = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter2);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    const oldi = i;
    for (let w = 1, k = base; ; k += base) {
      if (index >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base) {
        error("invalid-input");
      }
      if (digit > floor((maxInt - i) / w)) {
        error("overflow");
      }
      i += digit * w;
      const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t2) {
        break;
      }
      const baseMinusT = base - t2;
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
var encode2 = function(input) {
  const output = [];
  input = ucs2decode(input);
  const inputLength = input.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter2);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue === n) {
        let q = delta;
        for (let k = base; ; k += base) {
          const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t2) {
            break;
          }
          const qMinusT = q - t2;
          const baseMinusT = base - t2;
          output.push(
            stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
};
var toUnicode = function(input) {
  return mapDomain(input, function(string) {
    return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
  });
};
var toASCII = function(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
  });
};
var punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode2,
  "encode": encode2,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
var punycode_es6_default = punycode;

// node_modules/markdown-it/lib/presets/default.mjs
var default_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "\u201C\u201D\u2018\u2019",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};

// node_modules/markdown-it/lib/presets/zero.mjs
var zero_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "\u201C\u201D\u2018\u2019",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};

// node_modules/markdown-it/lib/presets/commonmark.mjs
var commonmark_default = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "\u201C\u201D\u2018\u2019",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};

// node_modules/markdown-it/lib/index.mjs
var config2 = {
  default: default_default,
  zero: zero_default,
  commonmark: commonmark_default
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  const str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true;
}
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return encode_default(format5(parsed));
}
function normalizeLinkText(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return decode_default(format5(parsed), decode_default.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!isString2(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new parser_inline_default();
  this.block = new parser_block_default();
  this.core = new parser_core_default();
  this.renderer = new renderer_default();
  this.linkify = new linkify_it_default();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils_exports;
  this.helpers = assign({}, helpers_exports);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  assign(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  const self = this;
  if (isString2(presets)) {
    const presetName = presets;
    presets = config2[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list2, true));
  const missed = list2.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list2, true));
  const missed = list2.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin) {
  const args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env6) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  const state = new this.core.State(src, this, env6);
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.render = function(src, env6) {
  env6 = env6 || {};
  return this.renderer.render(this.parse(src, env6), this.options, env6);
};
MarkdownIt.prototype.parseInline = function(src, env6) {
  const state = new this.core.State(src, this, env6);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env6) {
  env6 = env6 || {};
  return this.renderer.render(this.parseInline(src, env6), this.options, env6);
};
var lib_default = MarkdownIt;

// src/util/common/markdown.ts
init_lazy();
init_strings();
var mdLanguageIdToLanguageId = new Lazy(() => {
  const result = /* @__PURE__ */ new Map();
  wellKnownLanguages.forEach((language2, languageId) => {
    if (language2.markdownLanguageIds) {
      language2.markdownLanguageIds.forEach((mdLanguageId) => {
        result.set(mdLanguageId, languageId);
      });
    } else {
      result.set(languageId, languageId);
    }
  });
  return result;
});
function extractCodeBlocks(text2) {
  const out = [];
  const md = new lib_default();
  const tokens = md.parse(text2, {});
  for (const token of flattenTokensLists(tokens)) {
    if (token.map && token.type === "fence") {
      out.push({
        startMarkup: token.markup,
        // Trim trailing newline since this is always included
        code: token.content.replace(/\n$/, ""),
        language: token.info.trim(),
        startLine: token.map[0],
        endLine: token.map[1]
      });
    }
  }
  return out;
}
function* flattenTokensLists(tokensList) {
  for (const entry of tokensList) {
    if (entry.children) {
      yield* flattenTokensLists(entry.children);
    }
    yield entry;
  }
}

// src/extension/tools/common/virtualTools/virtualToolSummarizer.tsx
function normalizeGroupName(name) {
  return name.replace(/[^a-zA-Z0-9_]/g, "_").toLowerCase();
}
async function describeBulkToolGroups(endpoint, toolGroups, token) {
  const results = [];
  for (let i = 0; i < toolGroups.length; i += MAX_GROUPS_PER_CHUNK) {
    const chunk = toolGroups.slice(i, i + MAX_GROUPS_PER_CHUNK);
    const chunkResults = describeToolGroupsChunk(endpoint, chunk, token);
    results.push(chunkResults.catch(() => chunk.map(() => void 0)));
  }
  return (await Promise.all(results)).flat();
}
async function describeToolGroupsChunk(endpoint, toolGroups, token) {
  const renderer = new import_prompt_tsx3.PromptRenderer(endpoint, BulkGroupDescriptorPrompt, { toolGroups }, endpoint.acquireTokenizer());
  const result = await renderer.render(void 0, token);
  const json = await getJsonResponse(endpoint, result, token);
  const output = Array.from({ length: toolGroups.length }, () => void 0);
  if (!json || !Array.isArray(json)) {
    return output;
  }
  for (const item of json) {
    const index = Number(item.groupIndex) - 1;
    if (!isNaN(index) && toolGroups[index] && typeof item.groupName === "string" && typeof item.summary === "string") {
      output[index] = {
        name: normalizeGroupName(item.groupName),
        summary: item.summary,
        tools: toolGroups[index]
      };
    }
  }
  return output;
}
var ToolInformation = class extends import_prompt_tsx3.PromptElement {
  render() {
    const { tool } = this.props;
    return /* @__PURE__ */ vscpp(vscppf, null, `<tool name=${JSON.stringify(tool.name)}>${tool.description}</tool>`, /* @__PURE__ */ vscpp("br", null));
  }
};
var BulkGroupDescriptorPrompt = class extends import_prompt_tsx3.PromptElement {
  render() {
    return /* @__PURE__ */ vscpp(vscppf, null, /* @__PURE__ */ vscpp(import_prompt_tsx3.SystemMessage, null, "Context: You are given multiple groups of tools that have been clustered together based on semantic similarity. Your task is to provide a descriptive name and summary for each group that accurately reflects the common functionality and purpose of the tools within that group.", /* @__PURE__ */ vscpp("br", null), /* @__PURE__ */ vscpp("br", null), "For each group, analyze the tools and determine what they have in common, what domain or functionality they serve, and how they might be used together. Create a concise but descriptive name and a comprehensive summary for each group.", /* @__PURE__ */ vscpp("br", null)), /* @__PURE__ */ vscpp(import_prompt_tsx3.UserMessage, null, "You will be given ", this.props.toolGroups.length, " groups of tools. For each group, provide a name and summary that describes the group's purpose and capabilities.", /* @__PURE__ */ vscpp("br", null), /* @__PURE__ */ vscpp("br", null), this.props.toolGroups.map((group, index) => {
      const groupIndex = index + 1;
      return /* @__PURE__ */ vscpp(vscppf, null, `<group index="${groupIndex}">`, /* @__PURE__ */ vscpp("br", null), group.map((tool) => /* @__PURE__ */ vscpp(ToolInformation, { tool })), `</group>`, /* @__PURE__ */ vscpp("br", null));
    }), /* @__PURE__ */ vscpp("br", null), "Your response must follow the JSON schema:", /* @__PURE__ */ vscpp("br", null), /* @__PURE__ */ vscpp("br", null), "```", /* @__PURE__ */ vscpp("br", null), JSON.stringify({
      type: "array",
      items: {
        type: "object",
        required: ["groupIndex", "groupName", "summary"],
        properties: {
          groupIndex: {
            type: "integer",
            description: 'The index of the group as provided above (e.g., "1", "2", etc.)',
            example: 1
          },
          groupName: {
            type: "string",
            description: "A short, descriptive name for the group. It may only contain the characters a-z, A-Z, 0-9, and underscores.",
            example: "file_management_tools"
          },
          summary: {
            type: "string",
            description: "A comprehensive summary of the group capabilities, including what the tools do and how they can be used together. This may be up to five paragraphs long, be careful not to leave out important details.",
            example: "These tools provide comprehensive file management capabilities including reading, writing, searching, and organizing files and directories."
          }
        }
      }
    }, null, 2), /* @__PURE__ */ vscpp("br", null), "```", /* @__PURE__ */ vscpp("br", null), /* @__PURE__ */ vscpp("br", null), "Provide descriptions for the groups presented above. You must include the exact groupIndex as shown in the input. You must generate a description for every group and each groupName must be unique.", /* @__PURE__ */ vscpp("br", null)));
  }
};
async function getJsonResponse(endpoint, rendered, token) {
  const result = await endpoint.makeChatRequest(
    "summarizeVirtualTools",
    rendered.messages,
    void 0,
    token,
    6 /* Other */
  );
  if (result.type !== "success" /* Success */) {
    return void 0;
  }
  for (const block2 of extractCodeBlocks(result.value)) {
    try {
      return parse4(block2.code);
    } catch {
    }
  }
  const idx = result.value.indexOf("{");
  return parse4(result.value.slice(idx)) || void 0;
}

// src/extension/tools/common/virtualTools/virtualToolTypes.ts
var IToolGroupingService = createDecorator("IToolGroupingService");
var IToolGroupingCache = createDecorator("IToolGroupingCache");

// src/extension/tools/common/virtualTools/virtualToolGrouper.ts
var CATEGORIZATION_ENDPOINT = "copilot-fast";
var SUMMARY_PREFIX2 = "Call this tool when you need access to a new category of tools. The category of tools is described as follows:\n\n";
var SUMMARY_SUFFIX2 = "\n\nBe sure to call this tool if you need a capability related to the above.";
var VirtualToolGrouper = class {
  constructor(_endpointProvider, _cache, _telemetryService, _logService, embeddingsComputer, _configurationService, _expService, _toolEmbeddingsComputer, _instantiationService) {
    this._endpointProvider = _endpointProvider;
    this._cache = _cache;
    this._telemetryService = _telemetryService;
    this._logService = _logService;
    this.embeddingsComputer = embeddingsComputer;
    this._configurationService = _configurationService;
    this._expService = _expService;
    this._toolEmbeddingsComputer = _toolEmbeddingsComputer;
    this.builtInToolGroupHandler = new BuiltInToolGroupHandler();
  }
  /**
   * Determines if built-in tool grouping should be triggered based on configuration and tool count
   */
  shouldTriggerBuiltInGrouping(tools) {
    const defaultToolGroupingEnabled = this._configurationService.getExperimentBasedConfig(ConfigKey.AdvancedExperimentalExperiments.DefaultToolsGrouped, this._expService);
    return tools.length > START_BUILTIN_GROUPING_AFTER_TOOL_COUNT && defaultToolGroupingEnabled;
  }
  async addGroups(query, root, tools, token) {
    const shouldGroup = this.shouldTriggerBuiltInGrouping(tools);
    if (!shouldGroup && tools.length < START_GROUPING_AFTER_TOOL_COUNT) {
      root.contents = tools;
      return;
    }
    const byToolset = groupBy(tools, (t2) => {
      if (t2.source instanceof LanguageModelToolExtensionSource2) {
        return "ext_" + t2.source.id;
      } else if (t2.source instanceof LanguageModelToolMCPSource2) {
        return "mcp_" + t2.source.label;
      } else {
        return BuiltInToolGroupHandler.BUILT_IN_GROUP_KEY;
      }
    });
    const previousGroups = /* @__PURE__ */ new Map();
    for (const tool of root.all()) {
      if (tool instanceof VirtualTool) {
        previousGroups.set(tool.name, tool);
      }
    }
    const predictedToolsSw = new StopWatch();
    const predictedToolsPromise = this._getPredictedTools(query, tools, token).then((tools2) => ({ tools: tools2, durationMs: predictedToolsSw.elapsed() }));
    const builtinTools = byToolset[BuiltInToolGroupHandler.BUILT_IN_GROUP_KEY] || [];
    const toolsetEntries = Object.entries(byToolset).filter(([key]) => key !== BuiltInToolGroupHandler.BUILT_IN_GROUP_KEY);
    const groupedResults = [];
    const shouldGroupBuiltin = this.shouldTriggerBuiltInGrouping(builtinTools);
    if (shouldGroupBuiltin) {
      const builtinGroups = this.builtInToolGroupHandler.createBuiltInToolGroups(builtinTools);
      groupedResults.push(...builtinGroups);
    } else {
      groupedResults.push(...builtinTools);
    }
    if (toolsetEntries.length > 0) {
      const builtinSlotCount = groupedResults.length;
      const availableSlots = TOOLS_AND_GROUPS_LIMIT - builtinSlotCount;
      const slotAllocation = this._allocateSlots(toolsetEntries, availableSlots);
      const toolsetGrouped = await Promise.all([...toolsetEntries].map(async ([toolsetKey, tools2]) => {
        const allocatedSlots = slotAllocation.get(toolsetKey) || 0;
        return allocatedSlots > 0 ? await this._processToolset(tools2, allocatedSlots, token) : [];
      }));
      groupedResults.push(...toolsetGrouped.flat());
    }
    this._cache.flush();
    root.contents = VirtualToolGrouper.deduplicateGroups(groupedResults);
    if (toolsetEntries.length > 0) {
      const totalToolsToGroup = toolsetEntries.reduce((sum2, [, tools2]) => sum2 + tools2.length, 0);
      const totalGroupsCreated = groupedResults.filter((item) => item instanceof VirtualTool).length;
      this._telemetryService.sendMSFTTelemetryEvent("virtualTools.perToolsetGenerate", {}, {
        toolsetsProcessed: toolsetEntries.length,
        toolsBefore: totalToolsToGroup,
        groupsAfter: totalGroupsCreated,
        builtinTools: builtinTools.length
      });
    }
    for (const tool of root.all()) {
      if (tool instanceof VirtualTool) {
        const prev = previousGroups.get(tool.name);
        if (prev) {
          tool.copyStateFrom(prev);
        }
      }
    }
    await this._addEmbeddingMatchedTools(root, predictedToolsPromise);
  }
  /** Recomputes and updates the embedding-matched tools on the `root` based on the user query. */
  async recomputeEmbeddingRankings(query, root, token) {
    const predictedToolsSw = new StopWatch();
    const actualTools = [...root.all()].filter((t2) => !(t2 instanceof VirtualTool));
    const matchedTools = this._getPredictedTools(query, actualTools, token).then((tools) => ({
      tools,
      durationMs: predictedToolsSw.elapsed()
    }));
    await this._addEmbeddingMatchedTools(root, matchedTools);
  }
  _addPredictedToolsGroup(root, predictedTools) {
    const newGroup = new VirtualTool(EMBEDDINGS_GROUP_NAME, "Tools with high predicted relevancy for this query", Infinity, {
      wasEmbeddingsMatched: true,
      wasExpandedByDefault: true,
      canBeCollapsed: false
    });
    newGroup.isExpanded = true;
    for (const tool of predictedTools) {
      newGroup.contents.push(tool);
    }
    const idx = root.contents.findIndex((t2) => t2.name === EMBEDDINGS_GROUP_NAME);
    if (idx >= 0) {
      root.contents[idx] = newGroup;
    } else {
      root.contents.push(newGroup);
    }
  }
  async _addEmbeddingMatchedTools(root, predictedToolsPromise) {
    const sw = new StopWatch();
    let error2;
    let computeMs;
    try {
      const { tools, durationMs } = await predictedToolsPromise;
      computeMs = durationMs;
      this._addPredictedToolsGroup(root, tools);
    } catch (e) {
      error2 = e;
    } finally {
      this._telemetryService.sendMSFTTelemetryEvent("virtualTools.expandEmbedding", { error: error2 ? error2.message : void 0 }, {
        blockingMs: sw.elapsed(),
        computeMs,
        hadError: error2 ? 1 : 0
      });
    }
  }
  static deduplicateGroups(grouped) {
    const seen = /* @__PURE__ */ new Set();
    const result = [];
    for (const item of grouped) {
      let name = item.name;
      let counter = 1;
      while (seen.has(name)) {
        counter++;
        name = `${item.name}_${counter}`;
      }
      if (item instanceof VirtualTool && name !== item.name) {
        const renamedTool = item.cloneWithNewName(name);
        seen.add(name);
        result.push(renamedTool);
      } else {
        seen.add(name);
        result.push(item);
      }
    }
    return result;
  }
  /**
   * Allocate slots proportionally to each toolset based on tool count, ensuring every toolset gets at least one slot
   */
  _allocateSlots(toolsetEntries, availableSlots) {
    const allocation = /* @__PURE__ */ new Map();
    if (toolsetEntries.length >= availableSlots) {
      for (let i = 0; i < toolsetEntries.length; i++) {
        allocation.set(toolsetEntries[i][0], i < availableSlots ? 1 : 0);
      }
      return allocation;
    }
    const totalTools = toolsetEntries.reduce((sum2, [, tools]) => sum2 + tools.length, 0);
    let remainingSlots = availableSlots - toolsetEntries.length;
    for (const [toolsetKey] of toolsetEntries) {
      allocation.set(toolsetKey, 1);
    }
    if (remainingSlots > 0) {
      const proportions = toolsetEntries.map(([toolsetKey, tools]) => ({
        toolsetKey,
        proportion: tools.length / totalTools,
        toolCount: tools.length
      }));
      proportions.sort((a, b) => b.proportion - a.proportion);
      for (const { toolsetKey, proportion } of proportions) {
        const additionalSlots = Math.round(proportion * remainingSlots);
        const slotsToAdd = Math.min(additionalSlots, remainingSlots);
        allocation.set(toolsetKey, allocation.get(toolsetKey) + slotsToAdd);
        remainingSlots -= slotsToAdd;
      }
      while (remainingSlots > 0) {
        for (const { toolsetKey } of proportions) {
          if (remainingSlots <= 0) {
            break;
          }
          allocation.set(toolsetKey, allocation.get(toolsetKey) + 1);
          remainingSlots--;
        }
      }
    }
    return allocation;
  }
  /**
   * Process a single toolset based on allocated slots
   */
  async _processToolset(tools, allocatedSlots, token) {
    if (allocatedSlots >= tools.length) {
      return tools;
    }
    if (allocatedSlots === 1) {
      const groupDescriptions = await this._generateBulkGroupDescriptions([tools], token);
      const group = groupDescriptions.groups[0];
      return [new VirtualTool(VIRTUAL_TOOL_NAME_PREFIX + group.name, SUMMARY_PREFIX2 + group.summary + SUMMARY_SUFFIX2, 0, {}, group.tools)];
    }
    return await this._generateEmbeddingBasedGroups(tools, allocatedSlots, token);
  }
  async _getPredictedTools(query, tools, token) {
    if (!query) {
      return [];
    }
    const queryEmbedding = await this.embeddingsComputer.computeEmbeddings(EMBEDDING_TYPE_FOR_TOOL_GROUPING, [query], {}, new TelemetryCorrelationId("VirtualToolGrouper::_getPredictedTools"), token);
    if (!queryEmbedding || queryEmbedding.values.length === 0) {
      return [];
    }
    const queryEmbeddingVector = queryEmbedding.values[0];
    const nonBuiltInTools = tools.filter(
      (tool) => tool.source instanceof LanguageModelToolExtensionSource2 || tool.source instanceof LanguageModelToolMCPSource2
    );
    const toolEmbeddings = await this._toolEmbeddingsComputer.retrieveSimilarEmbeddingsForAvailableTools(queryEmbeddingVector, nonBuiltInTools, 10, token);
    if (!toolEmbeddings) {
      return [];
    }
    const toolNameToTool = new Map(tools.map((tool) => [tool.name, tool]));
    const predictedTools = toolEmbeddings.map((toolName) => toolNameToTool.get(toolName)).filter((tool) => tool !== void 0);
    return predictedTools;
  }
  /**
   * Generate embedding-based groups for tools with a specific limit
   */
  async _generateEmbeddingBasedGroups(tools, limit, token) {
    if (tools.length <= MIN_TOOLSET_SIZE_TO_GROUP) {
      return [];
    }
    let embeddingGroups = [];
    try {
      embeddingGroups = await this._toolEmbeddingsComputer.computeToolGroupings(tools, limit, token);
      this._logService.trace(`[virtual-tools] Embedding-based grouping created ${embeddingGroups.length} groups from ${tools.length} tools`);
    } catch (e) {
      this._logService.error(`Failed to create embedding-based groups: ${e}`);
      throw e;
    }
    const singles = embeddingGroups.filter((g) => g.length === 1).map((g) => g[0]);
    const grouped = embeddingGroups.filter((g) => g.length > 1);
    const groupDescriptions = await this._generateBulkGroupDescriptions(grouped, token);
    this._logService.trace(`[virtual-tools] Embedding-based grouping created ${groupDescriptions.groups.length} groups from ${tools.length} tools`);
    return groupDescriptions.groups.map((v) => new VirtualTool(VIRTUAL_TOOL_NAME_PREFIX + v.name, SUMMARY_PREFIX2 + v.summary + SUMMARY_SUFFIX2, 0, {}, v.tools)).concat(singles);
  }
  /**
   * Generate descriptions for embedding-based tool groups using LLM in bulk
   */
  async _generateBulkGroupDescriptions(embeddingGroups, token) {
    const cached = await Promise.all(embeddingGroups.map((group) => this._cache.getDescription(group)));
    const missing = [];
    const output = [];
    for (const entry of cached) {
      if (entry.category) {
        output.push(entry.category);
      } else {
        missing.push(entry);
      }
    }
    const endpoint = await this._endpointProvider.getChatEndpoint(CATEGORIZATION_ENDPOINT);
    const described = await describeBulkToolGroups(endpoint, missing.map((m) => m.tools), token);
    let missed = 0;
    for (let i = 0; i < described.length; i++) {
      const d = described[i];
      const m = missing[i];
      if (d) {
        m.update(d);
        output.push(d);
      } else {
        missed++;
        output.push({ name: `group_${i}`, summary: `Contains the tools: ${m.tools.map((t2) => t2.name).join(", ")}`, tools: m.tools });
      }
    }
    return { groups: output, missed };
  }
};
VirtualToolGrouper = __decorateClass([
  __decorateParam(0, IEndpointProvider),
  __decorateParam(1, IToolGroupingCache),
  __decorateParam(2, ITelemetryService),
  __decorateParam(3, ILogService),
  __decorateParam(4, IEmbeddingsComputer),
  __decorateParam(5, IConfigurationService),
  __decorateParam(6, IExperimentationService),
  __decorateParam(7, IToolEmbeddingsComputer),
  __decorateParam(8, IInstantiationService)
], VirtualToolGrouper);

// src/extension/tools/common/virtualTools/toolGrouping.ts
function computeToolGroupingMinThreshold(experimentationService, configurationService) {
  return configurationService.getExperimentBasedConfigObservable(ConfigKey.VirtualToolThreshold, experimentationService).map((configured) => {
    const value = configured ?? HARD_TOOL_LIMIT;
    return value <= 0 ? Infinity : value;
  });
}
var ToolGrouping = class {
  constructor(_tools, _instantiationService, _telemetryService) {
    this._tools = _tools;
    this._instantiationService = _instantiationService;
    this._telemetryService = _telemetryService;
    this._root = new VirtualTool(VIRTUAL_TOOL_NAME_PREFIX, "", Infinity, { wasExpandedByDefault: true });
    this._grouper = this._instantiationService.createInstance(VirtualToolGrouper);
    this._didToolsChange = true;
    this._turnNo = 0;
    this._trimOnNextCompute = false;
    this._root.isExpanded = true;
  }
  get tools() {
    return this._tools;
  }
  set tools(tools) {
    if (!equals(this._tools, tools, (a, b) => a.name === b.name)) {
      this._tools = tools;
      this._didToolsChange = true;
    }
  }
  didCall(localTurnNumber, toolCallName) {
    const result = this._root.find(toolCallName);
    if (!result) {
      return;
    }
    const { path, tool } = result;
    for (const part of path) {
      part.lastUsedOnTurn = this._turnNo;
    }
    if (path.length > 1) {
      this._telemetryService.sendMSFTTelemetryEvent("virtualTools.called", {
        callName: tool.name
      }, {
        turnNo: localTurnNumber,
        isVirtual: tool instanceof VirtualTool ? 1 : 0,
        depth: path.length - 1,
        preExpanded: path.every((p) => p.metadata.wasExpandedByDefault) ? 1 : 0,
        wasEmbedding: path.some((p) => p.name === EMBEDDINGS_GROUP_NAME) ? 1 : 0,
        totalTools: this._tools.length
      });
    }
    if (!(tool instanceof VirtualTool)) {
      return;
    }
    tool.isExpanded = true;
    return new LanguageModelToolResult3([
      new LanguageModelTextPart3(`Tools activated: ${[...tool.tools()].map((t2) => t2.name).join(", ")}`)
    ]);
  }
  getContainerFor(tool) {
    const result = this._root.find(tool);
    const last = result?.path.at(-1);
    return last === this._root ? void 0 : last;
  }
  didTakeTurn() {
    this._turnNo++;
  }
  didInvalidateCache() {
    this._trimOnNextCompute = true;
  }
  ensureExpanded(toolName) {
    this._expandOnNext ??= /* @__PURE__ */ new Set();
    this._expandOnNext.add(toolName);
  }
  async compute(query, token) {
    await this._doCompute(query, token);
    return [...this._root.tools()].filter(uniqueFilter((t2) => t2.name));
  }
  async computeAll(query, token) {
    await this._doCompute(query, token);
    return this._root.contents;
  }
  async _doCompute(query, token) {
    if (this._didToolsChange) {
      await this._grouper.addGroups(query, this._root, this._tools.slice(), token);
      this._didToolsChange = false;
    }
    if (this._expandOnNext) {
      for (const toolName of this._expandOnNext) {
        this._root.find(toolName)?.path.forEach((p) => {
          p.isExpanded = true;
          p.lastUsedOnTurn = this._turnNo;
        });
      }
      this._expandOnNext = void 0;
    }
    let trimDownTo = HARD_TOOL_LIMIT;
    if (this._trimOnNextCompute) {
      await this._grouper.recomputeEmbeddingRankings(query, this._root, token);
      trimDownTo = TRIM_THRESHOLD;
      this._trimOnNextCompute = false;
    }
    this._root.lastUsedOnTurn = Infinity;
    while (Iterable.length(this._root.tools()) > trimDownTo) {
      const lowest = this._root.getLowestExpandedTool();
      if (!lowest || !isFinite(lowest.lastUsedOnTurn)) {
        break;
      }
      if (lowest.metadata.canBeCollapsed === false) {
        lowest.lastUsedOnTurn = Infinity;
        continue;
      }
      lowest.isExpanded = false;
      lowest.metadata.wasExpandedByDefault = false;
    }
    this._trimOnNextCompute = false;
  }
};
ToolGrouping = __decorateClass([
  __decorateParam(1, IInstantiationService),
  __decorateParam(2, ITelemetryService)
], ToolGrouping);

// src/extension/tools/common/virtualTools/toolGroupingService.ts
var ToolGroupingService = class {
  constructor(_instantiationService, configurationService, experimentationService) {
    this._instantiationService = _instantiationService;
    this._groups = new LRUCache(3);
    this.threshold = computeToolGroupingMinThreshold(experimentationService, configurationService);
  }
  create(sessionId, tools) {
    const existing = this._groups.get(sessionId);
    if (existing) {
      existing.tools = tools;
      return existing;
    }
    const grouping = this._instantiationService.createInstance(ToolGrouping, tools);
    this._groups.set(sessionId, grouping);
    return grouping;
  }
};
ToolGroupingService = __decorateClass([
  __decorateParam(0, IInstantiationService),
  __decorateParam(1, IConfigurationService),
  __decorateParam(2, IExperimentationService)
], ToolGroupingService);

// src/extension/tools/common/virtualTools/virtualToolGroupCache.ts
init_map();
var GROUP_CACHE_SIZE = 128;
var GROUP_CACHE_NAME = "virtToolGroupCache";
var ToolGroupingCache = class {
  constructor(_extContext) {
    this._extContext = _extContext;
    this._value = new LRUCache(GROUP_CACHE_SIZE);
    this._changed = false;
    const cached = _extContext.globalState.get(GROUP_CACHE_NAME);
    if (cached?.version === 2) {
      try {
        cached.lru.forEach(([k, v]) => this._value.set(k, v));
      } catch (e) {
      }
    }
  }
  async clear() {
    this._changed = false;
    this._value.clear();
    await this._extContext.globalState.update(GROUP_CACHE_NAME, void 0);
  }
  async flush() {
    if (!this._changed) {
      return Promise.resolve();
    }
    this._changed = false;
    const value = {
      version: 2,
      lru: this._value.toJSON()
    };
    await this._extContext.globalState.update(GROUP_CACHE_NAME, value);
  }
  async getDescription(tools) {
    const key = await this.getKey(tools);
    const existing = this._value.get(key);
    return {
      category: existing ? this.hydrate(tools, existing) : void 0,
      tools,
      update: (r) => {
        this._changed = true;
        this._value.set(key, {
          summary: r.summary,
          name: r.name
        });
      }
    };
  }
  hydrate(tools, g) {
    return {
      summary: g.summary,
      name: g.name,
      tools
    };
  }
  async getKey(tools) {
    const str = tools.map((t2) => t2.name + "\0" + t2.description).sort().join(",");
    const hashBuf = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(str));
    return encodeBase64(VSBuffer.wrap(new Uint8Array(hashBuf)));
  }
};
ToolGroupingCache = __decorateClass([
  __decorateParam(0, IVSCodeExtensionContext)
], ToolGroupingCache);

// src/extension/extension/vscode/services.ts
function registerServices(builder, extensionContext) {
  const isTestMode = extensionContext.extensionMode === import_vscode18.ExtensionMode.Test;
  builder.define(IInteractionService, new SyncDescriptor(InteractionService));
  builder.define(ICopilotTokenStore, new CopilotTokenStore());
  builder.define(IDebugOutputService, new DebugOutputServiceImpl());
  builder.define(IDialogService, new DialogServiceImpl());
  builder.define(IEnvService, new EnvServiceImpl());
  builder.define(IFileSystemService, new VSCodeFileSystemService());
  builder.define(IHeaderContributors, new HeaderContributors());
  builder.define(INotebookService, new SyncDescriptor(NotebookService));
  builder.define(INotebookSummaryTracker, new SyncDescriptor(NotebookSummaryTrackerImpl));
  builder.define(IAlternativeNotebookContentService, new SyncDescriptor(AlternativeNotebookContentService));
  builder.define(IAlternativeNotebookContentEditGenerator, new SyncDescriptor(AlternativeNotebookContentEditGenerator));
  builder.define(IRemoteRepositoriesService, new RemoteRepositoriesService());
  builder.define(ITabsAndEditorsService, new TabsAndEditorsServiceImpl());
  builder.define(ITerminalService, new SyncDescriptor(TerminalServiceImpl));
  builder.define(ITestProvider, new SyncDescriptor(TestProvider));
  builder.define(IUrlOpener, isTestMode && !isScenarioAutomation ? new NullUrlOpener() : new RealUrlOpener());
  builder.define(INotificationService, isTestMode && !isScenarioAutomation ? new NullNotificationService() : new NotificationService());
  builder.define(
    IVSCodeExtensionContext,
    /*force _serviceBrand*/
    extensionContext
  );
  builder.define(IWorkbenchService, new WorkbenchServiceImpl());
  builder.define(IConversationOptions, {
    _serviceBrand: void 0,
    maxResponseTokens: void 0,
    temperature: 0.1,
    topP: 1,
    rejectionMessage: import_vscode18.l10n.t("Sorry, but I can only assist with programming related questions.")
  });
  builder.define(IChatSessionService, new SyncDescriptor(ChatSessionService));
  builder.define(IConfigurationService, new SyncDescriptor(ConfigurationServiceImpl));
  builder.define(ILogService, new SyncDescriptor(LogServiceImpl, [[new NewOutputChannelLogTarget(extensionContext)]]));
  builder.define(IChatQuotaService, new SyncDescriptor(ChatQuotaService));
  builder.define(ITasksService, new SyncDescriptor(TasksService));
  builder.define(IGitExtensionService, new SyncDescriptor(GitExtensionServiceImpl));
  builder.define(IGitService, new SyncDescriptor(GitServiceImpl));
  builder.define(IOctoKitService, isScenarioAutomation ? new SyncDescriptor(NullBaseOctoKitService) : new SyncDescriptor(OctoKitService));
  builder.define(IReviewService, new SyncDescriptor(ReviewServiceImpl));
  builder.define(ILanguageDiagnosticsService, new SyncDescriptor(LanguageDiagnosticsServiceImpl));
  builder.define(ILanguageFeaturesService, new SyncDescriptor(LanguageFeaturesServiceImpl));
  builder.define(IRunCommandExecutionService, new SyncDescriptor(RunCommandExecutionServiceImpl));
  builder.define(ISimulationTestContext, new SyncDescriptor(NulSimulationTestContext));
  builder.define(IWorkspaceService, new SyncDescriptor(ExtensionTextDocumentManager));
  builder.define(IExtensionsService, new SyncDescriptor(VSCodeExtensionsService));
  builder.define(ICombinedEmbeddingIndex, new SyncDescriptor(VSCodeCombinedIndexImpl, [
    /*useRemoteCache*/
    true
  ]));
  builder.define(IProjectTemplatesIndex, new SyncDescriptor(ProjectTemplatesIndex, [
    /*useRemoteCache*/
    true
  ]));
  builder.define(IBlockedExtensionService, new SyncDescriptor(BlockedExtensionService));
  builder.define(IEditLogService, new SyncDescriptor(EditLogService));
  builder.define(IMultiFileEditInternalTelemetryService, new SyncDescriptor(MultiFileEditInternalTelemetryService));
  builder.define(ICustomInstructionsService, new SyncDescriptor(CustomInstructionsService));
  builder.define(ILaunchConfigService, new SyncDescriptor(LaunchConfigService));
  builder.define(ISurveyService, new SyncDescriptor(SurveyService));
  builder.define(IEditSurvivalTrackerService, new SyncDescriptor(EditSurvivalTrackerService));
  builder.define(IPromptPathRepresentationService, new SyncDescriptor(PromptPathRepresentationService));
  builder.define(IPromptsService, new SyncDescriptor(PromptsServiceImpl));
  builder.define(IReleaseNotesService, new SyncDescriptor(ReleaseNotesService));
  builder.define(ISnippyService, new SyncDescriptor(SnippyService));
  builder.define(IInteractiveSessionService, new InteractiveSessionServiceImpl());
  builder.define(IAuthenticationChatUpgradeService, new SyncDescriptor(AuthenticationChatUpgradeService));
  builder.define(IEmbeddingsComputer, new SyncDescriptor(RemoteEmbeddingsComputer));
  builder.define(IToolGroupingService, new SyncDescriptor(ToolGroupingService));
  builder.define(IToolEmbeddingsComputer, new SyncDescriptor(ToolEmbeddingsComputer));
  builder.define(IToolGroupingCache, new SyncDescriptor(ToolGroupingCache));
  builder.define(IMergeConflictService, new SyncDescriptor(MergeConflictServiceImpl));
  builder.define(IEditToolLearningService, new SyncDescriptor(EditToolLearningService));
}

// src/extension/extension/vscode-worker/services.ts
function registerServices2(builder, extensionContext) {
  registerServices(builder, extensionContext);
}

// src/extension/extension/vscode-worker/extension.ts
function activate(context, forceActivation) {
  return baseActivate({
    context,
    registerServices: registerServices2,
    contributions: vscodeWebContributions,
    forceActivation
  });
}
//!!! DO NOT modify, this file was COPIED from 'microsoft/vscode'
/*! Bundled license information:

@vscode/prompt-tsx/dist/base/util/vs/nls.js:
@vscode/prompt-tsx/dist/base/util/vs/common/platform.js:
@vscode/prompt-tsx/dist/base/util/vs/common/process.js:
@vscode/prompt-tsx/dist/base/util/vs/common/path.js:
@vscode/prompt-tsx/dist/base/util/vs/common/uri.js:
  (*!!! DO NOT modify, this file was COPIED from 'microsoft/vscode' *)
*/
//# sourceMappingURL=web.js.map
