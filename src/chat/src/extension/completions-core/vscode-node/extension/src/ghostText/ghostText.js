"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GhostTextProvider = void 0;
exports.registerGhostTextDependencies = registerGhostTextDependencies;
const vscode_1 = require("vscode");
const instantiation_1 = require("../../../../../../util/vs/platform/instantiation/common/instantiation");
const last_1 = require("../../../lib/src/ghostText/last");
const inlineCompletion_1 = require("../../../lib/src/inlineCompletion");
const telemetry_1 = require("../../../lib/src/telemetry");
const textDocumentManager_1 = require("../textDocumentManager");
const postInsertCmdName = '_puku.ghostTextPostInsert2';
let GhostTextProvider = class GhostTextProvider {
    constructor(instantiationService) {
        this.instantiationService = instantiationService;
    }
    async provideInlineCompletionItems(vscodeDoc, position, context, token) {
        const textDocument = (0, textDocumentManager_1.wrapDoc)(vscodeDoc);
        if (!textDocument) {
            return;
        }
        // Opportunity ID is a unique ID generated by the client relating to a single "opportunity"
        // to provide some kind of suggestion to the user. Multiple requests might be made for a single
        // opportunity, for example requesting a completion as well as an edit suggestion. The single ID
        // allows us to correlate the different requests.
        const opportunityId = context.requestUuid;
        const formattingOptions = vscode_1.window.visibleTextEditors.find(e => e.document.uri === vscodeDoc.uri)?.options;
        const rawCompletions = await this.instantiationService.invokeFunction(inlineCompletion_1.getInlineCompletions, textDocument, position, token, {
            isCycling: context.triggerKind === vscode_1.InlineCompletionTriggerKind.Invoke,
            selectedCompletionInfo: context.selectedCompletionInfo,
            formattingOptions,
            opportunityId,
        });
        if (!rawCompletions) {
            return;
        }
        const items = rawCompletions.map(completion => {
            const { start, end } = completion.range;
            const newRange = new vscode_1.Range(start.line, start.character, end.line, end.character);
            return new vscode_1.InlineCompletionItem(completion.insertText, newRange, {
                title: 'Completion Accepted', // Unused
                command: postInsertCmdName,
                arguments: [completion],
            });
        });
        return { items };
    }
    handleDidShowCompletionItem(item) {
        const cmp = item.command.arguments[0];
        this.instantiationService.invokeFunction(last_1.handleGhostTextShown, cmp);
    }
    handleDidPartiallyAcceptCompletionItem(item, info) {
        if (typeof info === 'number') {
            return; // deprecated API
        }
        const cmp = item.command.arguments[0];
        this.instantiationService.invokeFunction(last_1.handlePartialGhostTextPostInsert, cmp, info.acceptedLength, info.kind);
    }
    handleEndOfLifetime(completionItem, reason) {
        // Send telemetry event when a completion is explicitly dismissed
        if (reason.kind !== vscode_1.InlineCompletionEndOfLifeReasonKind.Rejected) {
            return;
        }
        const cmp = completionItem.command?.arguments?.[0];
        if (!cmp) {
            return;
        }
        this.instantiationService.invokeFunction(telemetry_1.telemetry, 'ghostText.dismissed', cmp.telemetry);
    }
};
exports.GhostTextProvider = GhostTextProvider;
exports.GhostTextProvider = GhostTextProvider = __decorate([
    __param(0, instantiation_1.IInstantiationService)
], GhostTextProvider);
/** Registers the commands necessary to use GhostTextProvider (but not GhostTextProvider itself) */
function registerGhostTextDependencies(accessor) {
    const instantiationService = accessor.get(instantiation_1.IInstantiationService);
    const postCmdHandler = vscode_1.commands.registerCommand(postInsertCmdName, async (e) => {
        instantiationService.invokeFunction(last_1.handleGhostTextPostInsert, e);
        try {
            await vscode_1.commands.executeCommand('puku.survey.signalUsage', 'completions');
        }
        catch (e) {
            // Ignore errors from the survey command execution
        }
    });
    return postCmdHandler;
}
//# sourceMappingURL=ghostText.js.map