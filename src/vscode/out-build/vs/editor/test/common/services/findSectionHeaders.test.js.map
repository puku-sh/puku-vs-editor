{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/editor/test/common/services/findSectionHeaders.test.ts","vs/editor/test/common/services/findSectionHeaders.test.ts"],"names":[],"mappings":"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","file":"findSectionHeaders.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport { FindSectionHeaderOptions, ISectionHeaderFinderTarget, findSectionHeaders } from '../../../common/services/findSectionHeaders.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../base/test/common/utils.js';\n\nclass TestSectionHeaderFinderTarget implements ISectionHeaderFinderTarget {\n\tconstructor(private readonly lines: string[]) { }\n\n\tgetLineCount(): number {\n\t\treturn this.lines.length;\n\t}\n\n\tgetLineContent(lineNumber: number): string {\n\t\treturn this.lines[lineNumber - 1];\n\t}\n}\n\nsuite('FindSectionHeaders', () => {\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('finds simple section headers', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'regular line',\n\t\t\t'MARK: My Section',\n\t\t\t'another line',\n\t\t\t'MARK: Another Section',\n\t\t\t'last line'\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: 'MARK:\\\\s*(?<label>.*)$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'My Section');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 2);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 2);\n\n\t\tassert.strictEqual(headers[1].text, 'Another Section');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 4);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 4);\n\t});\n\n\ttest('finds section headers with separators', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'regular line',\n\t\t\t'MARK: -My Section',\n\t\t\t'another line',\n\t\t\t'MARK: - Another Section',\n\t\t\t'last line'\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: 'MARK:\\\\s*(?<separator>-?)\\\\s*(?<label>.*)$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'My Section');\n\t\tassert.strictEqual(headers[0].hasSeparatorLine, true);\n\n\t\tassert.strictEqual(headers[1].text, 'Another Section');\n\t\tassert.strictEqual(headers[1].hasSeparatorLine, true);\n\t});\n\n\ttest('finds multi-line section headers with separators', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'regular line',\n\t\t\t'// ==========',\n\t\t\t'// My Section',\n\t\t\t'// ==========',\n\t\t\t'code...',\n\t\t\t'// ==========',\n\t\t\t'// Another Section',\n\t\t\t'// ==========',\n\t\t\t'more code...'\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'My Section');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 2);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 4);\n\n\t\tassert.strictEqual(headers[1].text, 'Another Section');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 6);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 8);\n\t});\n\n\ttest('handles overlapping multi-line section headers correctly', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==========',\n\t\t\t'// Section 1',\n\t\t\t'// ==========',\n\t\t\t'// ==========', // This line starts another header\n\t\t\t'// Section 2',\n\t\t\t'// ==========',\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 1);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 3);\n\n\t\tassert.strictEqual(headers[1].text, 'Section 2');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 4);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 6);\n\t});\n\n\ttest('section headers must be in comments when specified', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==========',\n\t\t\t'// Section 1',  // This one is in a comment\n\t\t\t'// ==========',\n\t\t\t'==========',    // This one isn't\n\t\t\t'Section 2',\n\t\t\t'=========='\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^(?:\\/\\/ )?=+\\\\n^(?:\\/\\/ )?(?<label>[^\\\\n]+?)\\\\n^(?:\\/\\/ )?=+$'\n\t\t};\n\n\t\t// Both patterns match, but the second one should be filtered out by the token check\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers[0].shouldBeInComments, true);\n\t});\n\n\ttest('handles section headers at chunk boundaries', () => {\n\t\t// Create enough lines to ensure we cross chunk boundaries\n\t\tconst lines: string[] = [];\n\t\tfor (let i = 0; i < 150; i++) {\n\t\t\tlines.push('line ' + i);\n\t\t}\n\n\t\t// Add headers near the chunk boundary (chunk size is 100)\n\t\tlines[97] = '// ==========';\n\t\tlines[98] = '// Section 1';\n\t\tlines[99] = '// ==========';\n\t\tlines[100] = '// ==========';\n\t\tlines[101] = '// Section 2';\n\t\tlines[102] = '// ==========';\n\n\t\tconst model = new TestSectionHeaderFinderTarget(lines);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 98);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 100);\n\n\t\tassert.strictEqual(headers[1].text, 'Section 2');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 101);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 103);\n\t});\n\n\ttest('handles empty regex gracefully without infinite loop', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'line 1',\n\t\t\t'line 2',\n\t\t\t'line 3'\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '' // Empty string that would cause infinite loop\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 0, 'Should return no headers for empty regex');\n\t});\n\n\ttest('handles whitespace-only regex gracefully without infinite loop', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'line 1',\n\t\t\t'line 2',\n\t\t\t'line 3'\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '   ' // Whitespace that would cause infinite loop\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 0, 'Should return no headers for whitespace-only regex');\n\t});\n\n\ttest('correctly advances past matches without infinite loop', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==========',\n\t\t\t'// Section 1',\n\t\t\t'// ==========',\n\t\t\t'some code',\n\t\t\t'// ==========',\n\t\t\t'// Section 2',\n\t\t\t'// ==========',\n\t\t\t'more code',\n\t\t\t'// ==========',\n\t\t\t'// Section 3',\n\t\t\t'// ==========',\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 3, 'Should find all three section headers');\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[1].text, 'Section 2');\n\t\tassert.strictEqual(headers[2].text, 'Section 3');\n\t});\n\n\ttest('handles consecutive section headers correctly', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==========',\n\t\t\t'// Section 1',\n\t\t\t'// ==========',\n\t\t\t'// ==========', // This line is both the end of Section 1 and start of Section 2\n\t\t\t'// Section 2',\n\t\t\t'// ==========',\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2, 'Should find both section headers');\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[1].text, 'Section 2');\n\t});\n\n\ttest('handles nested separators correctly', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==============',\n\t\t\t'// Major Section',\n\t\t\t'// ==============',\n\t\t\t'',\n\t\t\t'// ----------',\n\t\t\t'// Subsection',\n\t\t\t'// ----------',\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ [-=]+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ [-=]+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2, 'Should find both section headers');\n\t\tassert.strictEqual(headers[0].text, 'Major Section');\n\t\tassert.strictEqual(headers[1].text, 'Subsection');\n\t});\n\n\ttest('handles section headers at chunk boundaries correctly', () => {\n\t\tconst lines: string[] = [];\n\t\t// Fill up to near the chunk boundary (chunk size is 100)\n\t\tfor (let i = 0; i < 97; i++) {\n\t\t\tlines.push(`line ${i}`);\n\t\t}\n\n\t\t// Add a section header that would cross the chunk boundary\n\t\tlines.push('// ==========');  // line 97\n\t\tlines.push('// Section 1'); // line 98\n\t\tlines.push('// =========='); // line 99\n\t\tlines.push('// =========='); // line 100 (chunk boundary)\n\t\tlines.push('// Section 2'); // line 101\n\t\tlines.push('// =========='); // line 102\n\n\t\t// Add more content after\n\t\tfor (let i = 103; i < 150; i++) {\n\t\t\tlines.push(`line ${i}`);\n\t\t}\n\n\t\tconst model = new TestSectionHeaderFinderTarget(lines);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2, 'Should find both section headers across chunk boundary');\n\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 98);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 100);\n\n\t\tassert.strictEqual(headers[1].text, 'Section 2');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 101);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 103);\n\t});\n\n\ttest('handles overlapping section headers without duplicates', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==========',  // Line 1\n\t\t\t'// Section 1',   // Line 2 - This is part of first header\n\t\t\t'// ==========',  // Line 3 - This is the end of first\n\t\t\t'// Section 2',   // Line 4 - This is not a header\n\t\t\t'// ==========',  // Line 5\n\t\t\t'// ==========',  // Line 6 - Start of second header\n\t\t\t'// Section 3',   // Line 7\n\t\t\t'// ==========='  // Line 8\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 1);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 3);\n\n\t\t// assert.strictEqual(headers[1].text, 'Section 2');\n\t\t// assert.strictEqual(headers[1].range.startLineNumber, 3);\n\t\t// assert.strictEqual(headers[1].range.endLineNumber, 5);\n\n\t\tassert.strictEqual(headers[1].text, 'Section 3');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 6);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 8);\n\t});\n\n\ttest('handles partially overlapping multiline section headers correctly', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ================',  // Line 1\n\t\t\t'// Major Section 1',   // Line 2\n\t\t\t'// ================',  // Line 3\n\t\t\t'// --------',         // Line 4 - Start of subsection that overlaps with end of major section\n\t\t\t'// Subsection 1.1',   // Line 5\n\t\t\t'// --------',         // Line 6\n\t\t\t'// ================',  // Line 7\n\t\t\t'// Major Section 2',   // Line 8\n\t\t\t'// ================',  // Line 9\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ [-=]+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ [-=]+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 3);\n\n\t\tassert.strictEqual(headers[0].text, 'Major Section 1');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 1);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 3);\n\n\t\tassert.strictEqual(headers[1].text, 'Subsection 1.1');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 4);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 6);\n\n\t\tassert.strictEqual(headers[2].text, 'Major Section 2');\n\t\tassert.strictEqual(headers[2].range.startLineNumber, 7);\n\t\tassert.strictEqual(headers[2].range.endLineNumber, 9);\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport { FindSectionHeaderOptions, ISectionHeaderFinderTarget, findSectionHeaders } from '../../../common/services/findSectionHeaders.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../base/test/common/utils.js';\n\nclass TestSectionHeaderFinderTarget implements ISectionHeaderFinderTarget {\n\tconstructor(private readonly lines: string[]) { }\n\n\tgetLineCount(): number {\n\t\treturn this.lines.length;\n\t}\n\n\tgetLineContent(lineNumber: number): string {\n\t\treturn this.lines[lineNumber - 1];\n\t}\n}\n\nsuite('FindSectionHeaders', () => {\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('finds simple section headers', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'regular line',\n\t\t\t'MARK: My Section',\n\t\t\t'another line',\n\t\t\t'MARK: Another Section',\n\t\t\t'last line'\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: 'MARK:\\\\s*(?<label>.*)$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'My Section');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 2);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 2);\n\n\t\tassert.strictEqual(headers[1].text, 'Another Section');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 4);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 4);\n\t});\n\n\ttest('finds section headers with separators', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'regular line',\n\t\t\t'MARK: -My Section',\n\t\t\t'another line',\n\t\t\t'MARK: - Another Section',\n\t\t\t'last line'\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: 'MARK:\\\\s*(?<separator>-?)\\\\s*(?<label>.*)$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'My Section');\n\t\tassert.strictEqual(headers[0].hasSeparatorLine, true);\n\n\t\tassert.strictEqual(headers[1].text, 'Another Section');\n\t\tassert.strictEqual(headers[1].hasSeparatorLine, true);\n\t});\n\n\ttest('finds multi-line section headers with separators', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'regular line',\n\t\t\t'// ==========',\n\t\t\t'// My Section',\n\t\t\t'// ==========',\n\t\t\t'code...',\n\t\t\t'// ==========',\n\t\t\t'// Another Section',\n\t\t\t'// ==========',\n\t\t\t'more code...'\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'My Section');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 2);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 4);\n\n\t\tassert.strictEqual(headers[1].text, 'Another Section');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 6);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 8);\n\t});\n\n\ttest('handles overlapping multi-line section headers correctly', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==========',\n\t\t\t'// Section 1',\n\t\t\t'// ==========',\n\t\t\t'// ==========', // This line starts another header\n\t\t\t'// Section 2',\n\t\t\t'// ==========',\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 1);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 3);\n\n\t\tassert.strictEqual(headers[1].text, 'Section 2');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 4);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 6);\n\t});\n\n\ttest('section headers must be in comments when specified', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==========',\n\t\t\t'// Section 1',  // This one is in a comment\n\t\t\t'// ==========',\n\t\t\t'==========',    // This one isn't\n\t\t\t'Section 2',\n\t\t\t'=========='\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^(?:\\/\\/ )?=+\\\\n^(?:\\/\\/ )?(?<label>[^\\\\n]+?)\\\\n^(?:\\/\\/ )?=+$'\n\t\t};\n\n\t\t// Both patterns match, but the second one should be filtered out by the token check\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers[0].shouldBeInComments, true);\n\t});\n\n\ttest('handles section headers at chunk boundaries', () => {\n\t\t// Create enough lines to ensure we cross chunk boundaries\n\t\tconst lines: string[] = [];\n\t\tfor (let i = 0; i < 150; i++) {\n\t\t\tlines.push('line ' + i);\n\t\t}\n\n\t\t// Add headers near the chunk boundary (chunk size is 100)\n\t\tlines[97] = '// ==========';\n\t\tlines[98] = '// Section 1';\n\t\tlines[99] = '// ==========';\n\t\tlines[100] = '// ==========';\n\t\tlines[101] = '// Section 2';\n\t\tlines[102] = '// ==========';\n\n\t\tconst model = new TestSectionHeaderFinderTarget(lines);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 98);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 100);\n\n\t\tassert.strictEqual(headers[1].text, 'Section 2');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 101);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 103);\n\t});\n\n\ttest('handles empty regex gracefully without infinite loop', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'line 1',\n\t\t\t'line 2',\n\t\t\t'line 3'\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '' // Empty string that would cause infinite loop\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 0, 'Should return no headers for empty regex');\n\t});\n\n\ttest('handles whitespace-only regex gracefully without infinite loop', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'line 1',\n\t\t\t'line 2',\n\t\t\t'line 3'\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '   ' // Whitespace that would cause infinite loop\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 0, 'Should return no headers for whitespace-only regex');\n\t});\n\n\ttest('correctly advances past matches without infinite loop', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==========',\n\t\t\t'// Section 1',\n\t\t\t'// ==========',\n\t\t\t'some code',\n\t\t\t'// ==========',\n\t\t\t'// Section 2',\n\t\t\t'// ==========',\n\t\t\t'more code',\n\t\t\t'// ==========',\n\t\t\t'// Section 3',\n\t\t\t'// ==========',\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 3, 'Should find all three section headers');\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[1].text, 'Section 2');\n\t\tassert.strictEqual(headers[2].text, 'Section 3');\n\t});\n\n\ttest('handles consecutive section headers correctly', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==========',\n\t\t\t'// Section 1',\n\t\t\t'// ==========',\n\t\t\t'// ==========', // This line is both the end of Section 1 and start of Section 2\n\t\t\t'// Section 2',\n\t\t\t'// ==========',\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2, 'Should find both section headers');\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[1].text, 'Section 2');\n\t});\n\n\ttest('handles nested separators correctly', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==============',\n\t\t\t'// Major Section',\n\t\t\t'// ==============',\n\t\t\t'',\n\t\t\t'// ----------',\n\t\t\t'// Subsection',\n\t\t\t'// ----------',\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ [-=]+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ [-=]+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2, 'Should find both section headers');\n\t\tassert.strictEqual(headers[0].text, 'Major Section');\n\t\tassert.strictEqual(headers[1].text, 'Subsection');\n\t});\n\n\ttest('handles section headers at chunk boundaries correctly', () => {\n\t\tconst lines: string[] = [];\n\t\t// Fill up to near the chunk boundary (chunk size is 100)\n\t\tfor (let i = 0; i < 97; i++) {\n\t\t\tlines.push(`line ${i}`);\n\t\t}\n\n\t\t// Add a section header that would cross the chunk boundary\n\t\tlines.push('// ==========');  // line 97\n\t\tlines.push('// Section 1'); // line 98\n\t\tlines.push('// =========='); // line 99\n\t\tlines.push('// =========='); // line 100 (chunk boundary)\n\t\tlines.push('// Section 2'); // line 101\n\t\tlines.push('// =========='); // line 102\n\n\t\t// Add more content after\n\t\tfor (let i = 103; i < 150; i++) {\n\t\t\tlines.push(`line ${i}`);\n\t\t}\n\n\t\tconst model = new TestSectionHeaderFinderTarget(lines);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2, 'Should find both section headers across chunk boundary');\n\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 98);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 100);\n\n\t\tassert.strictEqual(headers[1].text, 'Section 2');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 101);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 103);\n\t});\n\n\ttest('handles overlapping section headers without duplicates', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ==========',  // Line 1\n\t\t\t'// Section 1',   // Line 2 - This is part of first header\n\t\t\t'// ==========',  // Line 3 - This is the end of first\n\t\t\t'// Section 2',   // Line 4 - This is not a header\n\t\t\t'// ==========',  // Line 5\n\t\t\t'// ==========',  // Line 6 - Start of second header\n\t\t\t'// Section 3',   // Line 7\n\t\t\t'// ==========='  // Line 8\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ =+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ =+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 2);\n\n\t\tassert.strictEqual(headers[0].text, 'Section 1');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 1);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 3);\n\n\t\t// assert.strictEqual(headers[1].text, 'Section 2');\n\t\t// assert.strictEqual(headers[1].range.startLineNumber, 3);\n\t\t// assert.strictEqual(headers[1].range.endLineNumber, 5);\n\n\t\tassert.strictEqual(headers[1].text, 'Section 3');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 6);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 8);\n\t});\n\n\ttest('handles partially overlapping multiline section headers correctly', () => {\n\t\tconst model = new TestSectionHeaderFinderTarget([\n\t\t\t'// ================',  // Line 1\n\t\t\t'// Major Section 1',   // Line 2\n\t\t\t'// ================',  // Line 3\n\t\t\t'// --------',         // Line 4 - Start of subsection that overlaps with end of major section\n\t\t\t'// Subsection 1.1',   // Line 5\n\t\t\t'// --------',         // Line 6\n\t\t\t'// ================',  // Line 7\n\t\t\t'// Major Section 2',   // Line 8\n\t\t\t'// ================',  // Line 9\n\t\t]);\n\n\t\tconst options: FindSectionHeaderOptions = {\n\t\t\tfindRegionSectionHeaders: false,\n\t\t\tfindMarkSectionHeaders: true,\n\t\t\tmarkSectionHeaderRegex: '^\\/\\/ [-=]+\\\\n^\\/\\/ (?<label>[^\\\\n]+?)\\\\n^\\/\\/ [-=]+$'\n\t\t};\n\n\t\tconst headers = findSectionHeaders(model, options);\n\t\tassert.strictEqual(headers.length, 3);\n\n\t\tassert.strictEqual(headers[0].text, 'Major Section 1');\n\t\tassert.strictEqual(headers[0].range.startLineNumber, 1);\n\t\tassert.strictEqual(headers[0].range.endLineNumber, 3);\n\n\t\tassert.strictEqual(headers[1].text, 'Subsection 1.1');\n\t\tassert.strictEqual(headers[1].range.startLineNumber, 4);\n\t\tassert.strictEqual(headers[1].range.endLineNumber, 6);\n\n\t\tassert.strictEqual(headers[2].text, 'Major Section 2');\n\t\tassert.strictEqual(headers[2].range.startLineNumber, 7);\n\t\tassert.strictEqual(headers[2].range.endLineNumber, 9);\n\t});\n});\n"]}