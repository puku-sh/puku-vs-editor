{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/editor/test/browser/gpu/atlas/textureAtlas.test.ts","vs/editor/test/browser/gpu/atlas/textureAtlas.test.ts"],"names":[],"mappings":"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","file":"textureAtlas.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { strictEqual, throws } from 'assert';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport type { IGlyphRasterizer, IRasterizedGlyph } from '../../../../browser/gpu/raster/raster.js';\nimport { ensureNonNullable } from '../../../../browser/gpu/gpuUtils.js';\nimport type { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { TextureAtlas } from '../../../../browser/gpu/atlas/textureAtlas.js';\nimport { createCodeEditorServices } from '../../testCodeEditor.js';\nimport { assertIsValidGlyph } from './testUtil.js';\nimport { TextureAtlasSlabAllocator } from '../../../../browser/gpu/atlas/textureAtlasSlabAllocator.js';\nimport { DecorationStyleCache } from '../../../../browser/gpu/css/decorationStyleCache.js';\n\nconst blackInt = 0x000000FF;\nconst nullCharMetadata = 0x0;\n\nlet lastUniqueGlyph: string | undefined;\nfunction getUniqueGlyphId(): [chars: string, tokenMetadata: number, charMetadata: number, x: number] {\n\tif (!lastUniqueGlyph) {\n\t\tlastUniqueGlyph = 'a';\n\t} else {\n\t\tlastUniqueGlyph = String.fromCharCode(lastUniqueGlyph.charCodeAt(0) + 1);\n\t}\n\treturn [lastUniqueGlyph, blackInt, nullCharMetadata, 0];\n}\n\nclass TestGlyphRasterizer implements IGlyphRasterizer {\n\treadonly id = 0;\n\treadonly cacheKey = '';\n\tnextGlyphColor: [number, number, number, number] = [0, 0, 0, 0];\n\tnextGlyphDimensions: [number, number] = [0, 0];\n\trasterizeGlyph(chars: string, tokenMetadata: number, charMetadata: number, colorMap: string[]): Readonly<IRasterizedGlyph> {\n\t\tconst w = this.nextGlyphDimensions[0];\n\t\tconst h = this.nextGlyphDimensions[1];\n\t\tif (w === 0 || h === 0) {\n\t\t\tthrow new Error('TestGlyphRasterizer.nextGlyphDimensions must be set to a non-zero value before calling rasterizeGlyph');\n\t\t}\n\t\tconst imageData = new ImageData(w, h);\n\t\tlet i = 0;\n\t\tfor (let y = 0; y < h; y++) {\n\t\t\tfor (let x = 0; x < w; x++) {\n\t\t\t\tconst [r, g, b, a] = this.nextGlyphColor;\n\t\t\t\ti = (y * w + x) * 4;\n\t\t\t\timageData.data[i + 0] = r;\n\t\t\t\timageData.data[i + 1] = g;\n\t\t\t\timageData.data[i + 2] = b;\n\t\t\t\timageData.data[i + 3] = a;\n\t\t\t}\n\t\t}\n\t\tconst canvas = new OffscreenCanvas(w, h);\n\t\tconst ctx = ensureNonNullable(canvas.getContext('2d'));\n\t\tctx.putImageData(imageData, 0, 0);\n\t\treturn {\n\t\t\tsource: canvas,\n\t\t\tboundingBox: { top: 0, left: 0, bottom: h - 1, right: w - 1 },\n\t\t\toriginOffset: { x: 0, y: 0 },\n\t\t\tfontBoundingBoxAscent: 0,\n\t\t\tfontBoundingBoxDescent: 0,\n\t\t};\n\t}\n\tgetTextMetrics(text: string): TextMetrics {\n\t\treturn null!;\n\t}\n}\n\nsuite('TextureAtlas', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tsuiteSetup(() => {\n\t\tlastUniqueGlyph = undefined;\n\t});\n\n\tlet instantiationService: IInstantiationService;\n\n\tlet atlas: TextureAtlas;\n\tlet glyphRasterizer: TestGlyphRasterizer;\n\n\tsetup(() => {\n\t\tinstantiationService = createCodeEditorServices(store);\n\t\tatlas = store.add(instantiationService.createInstance(TextureAtlas, 2, undefined, new DecorationStyleCache()));\n\t\tglyphRasterizer = new TestGlyphRasterizer();\n\t\tglyphRasterizer.nextGlyphDimensions = [1, 1];\n\t\tglyphRasterizer.nextGlyphColor = [0, 0, 0, 0xFF];\n\t});\n\n\ttest('get single glyph', () => {\n\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t});\n\n\ttest('get multiple glyphs', () => {\n\t\tatlas = store.add(instantiationService.createInstance(TextureAtlas, 32, undefined, new DecorationStyleCache()));\n\t\tfor (let i = 0; i < 10; i++) {\n\t\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t\t}\n\t});\n\n\ttest('adding glyph to full page creates new page', () => {\n\t\tlet pageCount: number | undefined;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t\t\tif (pageCount === undefined) {\n\t\t\t\tpageCount = atlas.pages.length;\n\t\t\t} else {\n\t\t\t\tstrictEqual(atlas.pages.length, pageCount, 'the number of pages should not change when the page is being filled');\n\t\t\t}\n\t\t}\n\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t\tstrictEqual(atlas.pages.length, pageCount! + 1, 'the 5th glyph should overflow to a new page');\n\t});\n\n\ttest('adding a glyph larger than the atlas', () => {\n\t\tglyphRasterizer.nextGlyphDimensions = [3, 2];\n\t\tthrows(() => atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), 'should throw when the glyph is too large, this should not happen in practice');\n\t});\n\n\ttest('adding a glyph larger than the standard slab size', () => {\n\t\tglyphRasterizer.nextGlyphDimensions = [2, 2];\n\t\tatlas = store.add(instantiationService.createInstance(TextureAtlas, 32, {\n\t\t\tallocatorType: (canvas, textureIndex) => new TextureAtlasSlabAllocator(canvas, textureIndex, { slabW: 1, slabH: 1 })\n\t\t}, new DecorationStyleCache()));\n\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t});\n\n\ttest('adding a non-first glyph larger than the standard slab size, causing an overflow to a new page', () => {\n\t\tatlas = store.add(instantiationService.createInstance(TextureAtlas, 2, {\n\t\t\tallocatorType: (canvas, textureIndex) => new TextureAtlasSlabAllocator(canvas, textureIndex, { slabW: 1, slabH: 1 })\n\t\t}, new DecorationStyleCache()));\n\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t\tstrictEqual(atlas.pages.length, 1);\n\t\tglyphRasterizer.nextGlyphDimensions = [2, 2];\n\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t\tstrictEqual(atlas.pages.length, 2, 'the 2nd glyph should overflow to a new page with a larger slab size');\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { strictEqual, throws } from 'assert';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport type { IGlyphRasterizer, IRasterizedGlyph } from '../../../../browser/gpu/raster/raster.js';\nimport { ensureNonNullable } from '../../../../browser/gpu/gpuUtils.js';\nimport type { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { TextureAtlas } from '../../../../browser/gpu/atlas/textureAtlas.js';\nimport { createCodeEditorServices } from '../../testCodeEditor.js';\nimport { assertIsValidGlyph } from './testUtil.js';\nimport { TextureAtlasSlabAllocator } from '../../../../browser/gpu/atlas/textureAtlasSlabAllocator.js';\nimport { DecorationStyleCache } from '../../../../browser/gpu/css/decorationStyleCache.js';\n\nconst blackInt = 0x000000FF;\nconst nullCharMetadata = 0x0;\n\nlet lastUniqueGlyph: string | undefined;\nfunction getUniqueGlyphId(): [chars: string, tokenMetadata: number, charMetadata: number, x: number] {\n\tif (!lastUniqueGlyph) {\n\t\tlastUniqueGlyph = 'a';\n\t} else {\n\t\tlastUniqueGlyph = String.fromCharCode(lastUniqueGlyph.charCodeAt(0) + 1);\n\t}\n\treturn [lastUniqueGlyph, blackInt, nullCharMetadata, 0];\n}\n\nclass TestGlyphRasterizer implements IGlyphRasterizer {\n\treadonly id = 0;\n\treadonly cacheKey = '';\n\tnextGlyphColor: [number, number, number, number] = [0, 0, 0, 0];\n\tnextGlyphDimensions: [number, number] = [0, 0];\n\trasterizeGlyph(chars: string, tokenMetadata: number, charMetadata: number, colorMap: string[]): Readonly<IRasterizedGlyph> {\n\t\tconst w = this.nextGlyphDimensions[0];\n\t\tconst h = this.nextGlyphDimensions[1];\n\t\tif (w === 0 || h === 0) {\n\t\t\tthrow new Error('TestGlyphRasterizer.nextGlyphDimensions must be set to a non-zero value before calling rasterizeGlyph');\n\t\t}\n\t\tconst imageData = new ImageData(w, h);\n\t\tlet i = 0;\n\t\tfor (let y = 0; y < h; y++) {\n\t\t\tfor (let x = 0; x < w; x++) {\n\t\t\t\tconst [r, g, b, a] = this.nextGlyphColor;\n\t\t\t\ti = (y * w + x) * 4;\n\t\t\t\timageData.data[i + 0] = r;\n\t\t\t\timageData.data[i + 1] = g;\n\t\t\t\timageData.data[i + 2] = b;\n\t\t\t\timageData.data[i + 3] = a;\n\t\t\t}\n\t\t}\n\t\tconst canvas = new OffscreenCanvas(w, h);\n\t\tconst ctx = ensureNonNullable(canvas.getContext('2d'));\n\t\tctx.putImageData(imageData, 0, 0);\n\t\treturn {\n\t\t\tsource: canvas,\n\t\t\tboundingBox: { top: 0, left: 0, bottom: h - 1, right: w - 1 },\n\t\t\toriginOffset: { x: 0, y: 0 },\n\t\t\tfontBoundingBoxAscent: 0,\n\t\t\tfontBoundingBoxDescent: 0,\n\t\t};\n\t}\n\tgetTextMetrics(text: string): TextMetrics {\n\t\treturn null!;\n\t}\n}\n\nsuite('TextureAtlas', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tsuiteSetup(() => {\n\t\tlastUniqueGlyph = undefined;\n\t});\n\n\tlet instantiationService: IInstantiationService;\n\n\tlet atlas: TextureAtlas;\n\tlet glyphRasterizer: TestGlyphRasterizer;\n\n\tsetup(() => {\n\t\tinstantiationService = createCodeEditorServices(store);\n\t\tatlas = store.add(instantiationService.createInstance(TextureAtlas, 2, undefined, new DecorationStyleCache()));\n\t\tglyphRasterizer = new TestGlyphRasterizer();\n\t\tglyphRasterizer.nextGlyphDimensions = [1, 1];\n\t\tglyphRasterizer.nextGlyphColor = [0, 0, 0, 0xFF];\n\t});\n\n\ttest('get single glyph', () => {\n\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t});\n\n\ttest('get multiple glyphs', () => {\n\t\tatlas = store.add(instantiationService.createInstance(TextureAtlas, 32, undefined, new DecorationStyleCache()));\n\t\tfor (let i = 0; i < 10; i++) {\n\t\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t\t}\n\t});\n\n\ttest('adding glyph to full page creates new page', () => {\n\t\tlet pageCount: number | undefined;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t\t\tif (pageCount === undefined) {\n\t\t\t\tpageCount = atlas.pages.length;\n\t\t\t} else {\n\t\t\t\tstrictEqual(atlas.pages.length, pageCount, 'the number of pages should not change when the page is being filled');\n\t\t\t}\n\t\t}\n\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t\tstrictEqual(atlas.pages.length, pageCount! + 1, 'the 5th glyph should overflow to a new page');\n\t});\n\n\ttest('adding a glyph larger than the atlas', () => {\n\t\tglyphRasterizer.nextGlyphDimensions = [3, 2];\n\t\tthrows(() => atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), 'should throw when the glyph is too large, this should not happen in practice');\n\t});\n\n\ttest('adding a glyph larger than the standard slab size', () => {\n\t\tglyphRasterizer.nextGlyphDimensions = [2, 2];\n\t\tatlas = store.add(instantiationService.createInstance(TextureAtlas, 32, {\n\t\t\tallocatorType: (canvas, textureIndex) => new TextureAtlasSlabAllocator(canvas, textureIndex, { slabW: 1, slabH: 1 })\n\t\t}, new DecorationStyleCache()));\n\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t});\n\n\ttest('adding a non-first glyph larger than the standard slab size, causing an overflow to a new page', () => {\n\t\tatlas = store.add(instantiationService.createInstance(TextureAtlas, 2, {\n\t\t\tallocatorType: (canvas, textureIndex) => new TextureAtlasSlabAllocator(canvas, textureIndex, { slabW: 1, slabH: 1 })\n\t\t}, new DecorationStyleCache()));\n\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t\tstrictEqual(atlas.pages.length, 1);\n\t\tglyphRasterizer.nextGlyphDimensions = [2, 2];\n\t\tassertIsValidGlyph(atlas.getGlyph(glyphRasterizer, ...getUniqueGlyphId()), atlas);\n\t\tstrictEqual(atlas.pages.length, 2, 'the 2nd glyph should overflow to a new page with a larger slab size');\n\t});\n});\n"]}