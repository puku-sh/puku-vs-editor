{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/editor/common/core/edits/lineEdit.ts","vs/editor/common/core/edits/lineEdit.ts"],"names":[],"mappings":"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","file":"lineEdit.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, groupAdjacentBy, numberComparator } from '../../../../base/common/arrays.js';\nimport { assert, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { splitLines } from '../../../../base/common/strings.js';\nimport { LineRange } from '../ranges/lineRange.js';\nimport { BaseStringEdit, StringEdit, StringReplacement } from './stringEdit.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextReplacement, TextEdit } from './textEdit.js';\nimport { AbstractText } from '../text/abstractText.js';\n\nexport class LineEdit {\n\tpublic static readonly empty = new LineEdit([]);\n\n\tpublic static deserialize(data: SerializedLineEdit): LineEdit {\n\t\treturn new LineEdit(data.map(e => LineReplacement.deserialize(e)));\n\t}\n\n\tpublic static fromStringEdit(edit: BaseStringEdit, initialValue: AbstractText): LineEdit {\n\t\tconst textEdit = TextEdit.fromStringEdit(edit, initialValue);\n\t\treturn LineEdit.fromTextEdit(textEdit, initialValue);\n\t}\n\n\tpublic static fromTextEdit(edit: TextEdit, initialValue: AbstractText): LineEdit {\n\t\tconst edits = edit.replacements;\n\n\t\tconst result: LineReplacement[] = [];\n\n\t\tconst currentEdits: TextReplacement[] = [];\n\t\tfor (let i = 0; i < edits.length; i++) {\n\t\t\tconst edit = edits[i];\n\t\t\tconst nextEditRange = i + 1 < edits.length ? edits[i + 1] : undefined;\n\t\t\tcurrentEdits.push(edit);\n\t\t\tif (nextEditRange && nextEditRange.range.startLineNumber === edit.range.endLineNumber) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst singleEdit = TextReplacement.joinReplacements(currentEdits, initialValue);\n\t\t\tcurrentEdits.length = 0;\n\n\t\t\tconst singleLineEdit = LineReplacement.fromSingleTextEdit(singleEdit, initialValue);\n\t\t\tresult.push(singleLineEdit);\n\t\t}\n\n\t\treturn new LineEdit(result);\n\t}\n\n\tpublic static createFromUnsorted(edits: readonly LineReplacement[]): LineEdit {\n\t\tconst result = edits.slice();\n\t\tresult.sort(compareBy(i => i.lineRange.startLineNumber, numberComparator));\n\t\treturn new LineEdit(result);\n\t}\n\n\tconstructor(\n\t\t/**\n\t\t * Have to be sorted by start line number and non-intersecting.\n\t\t*/\n\t\tpublic readonly replacements: readonly LineReplacement[]\n\t) {\n\t\tassert(checkAdjacentItems(replacements, (i1, i2) => i1.lineRange.endLineNumberExclusive <= i2.lineRange.startLineNumber));\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this.replacements.length === 0;\n\t}\n\n\tpublic toEdit(initialValue: AbstractText): StringEdit {\n\t\tconst edits: StringReplacement[] = [];\n\t\tfor (const edit of this.replacements) {\n\t\t\tconst singleEdit = edit.toSingleEdit(initialValue);\n\t\t\tedits.push(singleEdit);\n\t\t}\n\t\treturn new StringEdit(edits);\n\t}\n\n\tpublic toString(): string {\n\t\treturn this.replacements.map(e => e.toString()).join(',');\n\t}\n\n\tpublic serialize(): SerializedLineEdit {\n\t\treturn this.replacements.map(e => e.serialize());\n\t}\n\n\tpublic getNewLineRanges(): LineRange[] {\n\t\tconst ranges: LineRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tranges.push(LineRange.ofLength(e.lineRange.startLineNumber + offset, e.newLines.length),);\n\t\t\toffset += e.newLines.length - e.lineRange.length;\n\t\t}\n\t\treturn ranges;\n\t}\n\n\tpublic mapLineNumber(lineNumber: number): number {\n\t\tlet lineDelta = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tif (e.lineRange.endLineNumberExclusive > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlineDelta += e.newLines.length - e.lineRange.length;\n\t\t}\n\t\treturn lineNumber + lineDelta;\n\t}\n\n\tpublic mapLineRange(lineRange: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.mapLineNumber(lineRange.startLineNumber),\n\t\t\tthis.mapLineNumber(lineRange.endLineNumberExclusive),\n\t\t);\n\t}\n\n\n\t/** TODO improve, dont require originalLines */\n\tpublic mapBackLineRange(lineRange: LineRange, originalLines: string[]): LineRange {\n\t\tconst i = this.inverse(originalLines);\n\t\treturn i.mapLineRange(lineRange);\n\t}\n\n\tpublic touches(other: LineEdit): boolean {\n\t\treturn this.replacements.some(e1 => other.replacements.some(e2 => e1.lineRange.intersect(e2.lineRange)));\n\t}\n\n\tpublic rebase(base: LineEdit): LineEdit {\n\t\treturn new LineEdit(\n\t\t\tthis.replacements.map(e => new LineReplacement(base.mapLineRange(e.lineRange), e.newLines)),\n\t\t);\n\t}\n\n\tpublic humanReadablePatch(originalLines: string[]): string {\n\t\tconst result: string[] = [];\n\n\t\tfunction pushLine(originalLineNumber: number, modifiedLineNumber: number, kind: 'unmodified' | 'deleted' | 'added', content: string | undefined) {\n\t\t\tconst specialChar = (kind === 'unmodified' ? ' ' : (kind === 'deleted' ? '-' : '+'));\n\n\t\t\tif (content === undefined) {\n\t\t\t\tcontent = '[[[[[ WARNING: LINE DOES NOT EXIST ]]]]]';\n\t\t\t}\n\n\t\t\tconst origLn = originalLineNumber === -1 ? '   ' : originalLineNumber.toString().padStart(3, ' ');\n\t\t\tconst modLn = modifiedLineNumber === -1 ? '   ' : modifiedLineNumber.toString().padStart(3, ' ');\n\n\t\t\tresult.push(`${specialChar} ${origLn} ${modLn} ${content}`);\n\t\t}\n\n\t\tfunction pushSeperator() {\n\t\t\tresult.push('---');\n\t\t}\n\n\t\tlet lineDelta = 0;\n\t\tlet first = true;\n\n\t\tfor (const edits of groupAdjacentBy(this.replacements, (e1, e2) => e1.lineRange.distanceToRange(e2.lineRange) <= 5)) {\n\t\t\tif (!first) {\n\t\t\t\tpushSeperator();\n\t\t\t} else {\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\tlet lastLineNumber = edits[0].lineRange.startLineNumber - 2;\n\n\t\t\tfor (const edit of edits) {\n\t\t\t\tfor (let i = Math.max(1, lastLineNumber); i < edit.lineRange.startLineNumber; i++) {\n\t\t\t\t\tpushLine(i, i + lineDelta, 'unmodified', originalLines[i - 1]);\n\t\t\t\t}\n\n\t\t\t\tconst range = edit.lineRange;\n\t\t\t\tconst newLines = edit.newLines;\n\t\t\t\tfor (const replaceLineNumber of range.mapToLineArray(n => n)) {\n\t\t\t\t\tconst line = originalLines[replaceLineNumber - 1];\n\t\t\t\t\tpushLine(replaceLineNumber, -1, 'deleted', line);\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < newLines.length; i++) {\n\t\t\t\t\tconst line = newLines[i];\n\t\t\t\t\tpushLine(-1, range.startLineNumber + lineDelta + i, 'added', line);\n\t\t\t\t}\n\n\t\t\t\tlastLineNumber = range.endLineNumberExclusive;\n\n\t\t\t\tlineDelta += edit.newLines.length - edit.lineRange.length;\n\t\t\t}\n\n\t\t\tfor (let i = lastLineNumber; i <= Math.min(lastLineNumber + 2, originalLines.length); i++) {\n\t\t\t\tpushLine(i, i + lineDelta, 'unmodified', originalLines[i - 1]);\n\t\t\t}\n\t\t}\n\n\t\treturn result.join('\\n');\n\t}\n\n\tpublic apply(lines: string[]): string[] {\n\t\tconst result: string[] = [];\n\n\t\tlet currentLineIndex = 0;\n\n\t\tfor (const edit of this.replacements) {\n\t\t\twhile (currentLineIndex < edit.lineRange.startLineNumber - 1) {\n\t\t\t\tresult.push(lines[currentLineIndex]);\n\t\t\t\tcurrentLineIndex++;\n\t\t\t}\n\n\t\t\tfor (const newLine of edit.newLines) {\n\t\t\t\tresult.push(newLine);\n\t\t\t}\n\n\t\t\tcurrentLineIndex = edit.lineRange.endLineNumberExclusive - 1;\n\t\t}\n\n\t\twhile (currentLineIndex < lines.length) {\n\t\t\tresult.push(lines[currentLineIndex]);\n\t\t\tcurrentLineIndex++;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic inverse(originalLines: string[]): LineEdit {\n\t\tconst newRanges = this.getNewLineRanges();\n\t\treturn new LineEdit(this.replacements.map((e, idx) => new LineReplacement(\n\t\t\tnewRanges[idx],\n\t\t\toriginalLines.slice(e.lineRange.startLineNumber - 1, e.lineRange.endLineNumberExclusive - 1),\n\t\t)));\n\t}\n}\n\nexport class LineReplacement {\n\tpublic static deserialize(e: SerializedLineReplacement): LineReplacement {\n\t\treturn new LineReplacement(\n\t\t\tLineRange.ofLength(e[0], e[1] - e[0]),\n\t\t\te[2],\n\t\t);\n\t}\n\n\tpublic static fromSingleTextEdit(edit: TextReplacement, initialValue: AbstractText): LineReplacement {\n\t\t// 1: ab[cde\n\t\t// 2: fghijk\n\t\t// 3: lmn]opq\n\n\t\t// replaced with\n\n\t\t// 1n: 123\n\t\t// 2n: 456\n\t\t// 3n: 789\n\n\t\t// simple solution: replace [1..4) with [1n..4n)\n\n\t\tconst newLines = splitLines(edit.text);\n\t\tlet startLineNumber = edit.range.startLineNumber;\n\t\tconst survivingFirstLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tnew Position(edit.range.startLineNumber, 1),\n\t\t\tedit.range.getStartPosition()\n\t\t));\n\t\tnewLines[0] = survivingFirstLineText + newLines[0];\n\n\t\tlet endLineNumberEx = edit.range.endLineNumber + 1;\n\t\tconst editEndLineNumberMaxColumn = initialValue.getTransformer().getLineLength(edit.range.endLineNumber) + 1;\n\t\tconst survivingEndLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tedit.range.getEndPosition(),\n\t\t\tnew Position(edit.range.endLineNumber, editEndLineNumberMaxColumn)\n\t\t));\n\t\tnewLines[newLines.length - 1] = newLines[newLines.length - 1] + survivingEndLineText;\n\n\t\t// Replacing [startLineNumber, endLineNumberEx) with newLines would be correct, however it might not be minimal.\n\n\t\tconst startBeforeNewLine = edit.range.startColumn === initialValue.getTransformer().getLineLength(edit.range.startLineNumber) + 1;\n\t\tconst endAfterNewLine = edit.range.endColumn === 1;\n\n\t\tif (startBeforeNewLine && newLines[0].length === survivingFirstLineText.length) {\n\t\t\t// the replacement would not delete any text on the first line\n\t\t\tstartLineNumber++;\n\t\t\tnewLines.shift();\n\t\t}\n\n\t\tif (newLines.length > 0 && startLineNumber < endLineNumberEx && endAfterNewLine && newLines[newLines.length - 1].length === survivingEndLineText.length) {\n\t\t\t// the replacement would not delete any text on the last line\n\t\t\tendLineNumberEx--;\n\t\t\tnewLines.pop();\n\t\t}\n\n\t\treturn new LineReplacement(new LineRange(startLineNumber, endLineNumberEx), newLines);\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineRange: LineRange,\n\t\tpublic readonly newLines: readonly string[],\n\t) { }\n\n\tpublic toSingleTextEdit(initialValue: AbstractText): TextReplacement {\n\t\tif (this.newLines.length === 0) {\n\t\t\t// Deletion\n\t\t\tconst textLen = initialValue.getTransformer().textLength;\n\t\t\tif (this.lineRange.endLineNumberExclusive === textLen.lineCount + 2) {\n\t\t\t\tlet startPos: Position;\n\t\t\t\tif (this.lineRange.startLineNumber > 1) {\n\t\t\t\t\tconst startLineNumber = this.lineRange.startLineNumber - 1;\n\t\t\t\t\tconst startColumn = initialValue.getTransformer().getLineLength(startLineNumber) + 1;\n\t\t\t\t\tstartPos = new Position(startLineNumber, startColumn);\n\t\t\t\t} else {\n\t\t\t\t\t// Delete everything.\n\t\t\t\t\t// In terms of lines, this would end up with 0 lines.\n\t\t\t\t\t// However, a string has always 1 line (which can be empty).\n\t\t\t\t\tstartPos = new Position(1, 1);\n\t\t\t\t}\n\n\t\t\t\tconst lastPosition = textLen.addToPosition(new Position(1, 1));\n\t\t\t\treturn new TextReplacement(Range.fromPositions(startPos, lastPosition), '');\n\t\t\t} else {\n\t\t\t\treturn new TextReplacement(new Range(this.lineRange.startLineNumber, 1, this.lineRange.endLineNumberExclusive, 1), '');\n\t\t\t}\n\n\t\t} else if (this.lineRange.isEmpty) {\n\t\t\t// Insertion\n\n\t\t\tlet endLineNumber: number;\n\t\t\tlet column: number;\n\t\t\tlet text: string;\n\t\t\tconst insertionLine = this.lineRange.startLineNumber;\n\t\t\tif (insertionLine === initialValue.getTransformer().textLength.lineCount + 2) {\n\t\t\t\tendLineNumber = insertionLine - 1;\n\t\t\t\tcolumn = initialValue.getTransformer().getLineLength(endLineNumber) + 1;\n\t\t\t\ttext = this.newLines.map(l => '\\n' + l).join('');\n\t\t\t} else {\n\t\t\t\tendLineNumber = insertionLine;\n\t\t\t\tcolumn = 1;\n\t\t\t\ttext = this.newLines.map(l => l + '\\n').join('');\n\t\t\t}\n\t\t\treturn new TextReplacement(Range.fromPositions(new Position(endLineNumber, column)), text);\n\t\t} else {\n\t\t\tconst endLineNumber = this.lineRange.endLineNumberExclusive - 1;\n\t\t\tconst endLineNumberMaxColumn = initialValue.getTransformer().getLineLength(endLineNumber) + 1;\n\t\t\tconst range = new Range(\n\t\t\t\tthis.lineRange.startLineNumber,\n\t\t\t\t1,\n\t\t\t\tendLineNumber,\n\t\t\t\tendLineNumberMaxColumn\n\t\t\t);\n\t\t\t// Don't add \\n to the last line. This is because we subtract one from lineRange.endLineNumberExclusive for endLineNumber.\n\t\t\tconst text = this.newLines.join('\\n');\n\t\t\treturn new TextReplacement(range, text);\n\t\t}\n\t}\n\n\tpublic toSingleEdit(initialValue: AbstractText): StringReplacement {\n\t\tconst textEdit = this.toSingleTextEdit(initialValue);\n\t\tconst range = initialValue.getTransformer().getOffsetRange(textEdit.range);\n\t\treturn new StringReplacement(range, textEdit.text);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.lineRange}->${JSON.stringify(this.newLines)}`;\n\t}\n\n\tpublic serialize(): SerializedLineReplacement {\n\t\treturn [\n\t\t\tthis.lineRange.startLineNumber,\n\t\t\tthis.lineRange.endLineNumberExclusive,\n\t\t\tthis.newLines,\n\t\t];\n\t}\n\n\tpublic removeCommonSuffixPrefixLines(initialValue: AbstractText): LineReplacement {\n\t\tlet startLineNumber = this.lineRange.startLineNumber;\n\t\tlet endLineNumberEx = this.lineRange.endLineNumberExclusive;\n\n\t\tlet trimStartCount = 0;\n\t\twhile (\n\t\t\tstartLineNumber < endLineNumberEx && trimStartCount < this.newLines.length\n\t\t\t&& this.newLines[trimStartCount] === initialValue.getLineAt(startLineNumber)\n\t\t) {\n\t\t\tstartLineNumber++;\n\t\t\ttrimStartCount++;\n\t\t}\n\n\t\tlet trimEndCount = 0;\n\t\twhile (\n\t\t\tstartLineNumber < endLineNumberEx && trimEndCount + trimStartCount < this.newLines.length\n\t\t\t&& this.newLines[this.newLines.length - 1 - trimEndCount] === initialValue.getLineAt(endLineNumberEx - 1)\n\t\t) {\n\t\t\tendLineNumberEx--;\n\t\t\ttrimEndCount++;\n\t\t}\n\n\t\tif (trimStartCount === 0 && trimEndCount === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new LineReplacement(new LineRange(startLineNumber, endLineNumberEx), this.newLines.slice(trimStartCount, this.newLines.length - trimEndCount));\n\t}\n\n\tpublic toLineEdit(): LineEdit {\n\t\treturn new LineEdit([this]);\n\t}\n}\n\nexport type SerializedLineEdit = SerializedLineReplacement[];\nexport type SerializedLineReplacement = [startLineNumber: number, endLineNumber: number, newLines: readonly string[]];\n\nexport namespace SerializedLineReplacement {\n\texport function is(thing: unknown): thing is SerializedLineReplacement {\n\t\treturn (\n\t\t\tArray.isArray(thing)\n\t\t\t&& thing.length === 3\n\t\t\t&& typeof thing[0] === 'number'\n\t\t\t&& typeof thing[1] === 'number'\n\t\t\t&& Array.isArray(thing[2])\n\t\t\t&& thing[2].every((e: unknown) => typeof e === 'string')\n\t\t);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, groupAdjacentBy, numberComparator } from '../../../../base/common/arrays.js';\nimport { assert, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { splitLines } from '../../../../base/common/strings.js';\nimport { LineRange } from '../ranges/lineRange.js';\nimport { BaseStringEdit, StringEdit, StringReplacement } from './stringEdit.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextReplacement, TextEdit } from './textEdit.js';\nimport { AbstractText } from '../text/abstractText.js';\n\nexport class LineEdit {\n\tpublic static readonly empty = new LineEdit([]);\n\n\tpublic static deserialize(data: SerializedLineEdit): LineEdit {\n\t\treturn new LineEdit(data.map(e => LineReplacement.deserialize(e)));\n\t}\n\n\tpublic static fromStringEdit(edit: BaseStringEdit, initialValue: AbstractText): LineEdit {\n\t\tconst textEdit = TextEdit.fromStringEdit(edit, initialValue);\n\t\treturn LineEdit.fromTextEdit(textEdit, initialValue);\n\t}\n\n\tpublic static fromTextEdit(edit: TextEdit, initialValue: AbstractText): LineEdit {\n\t\tconst edits = edit.replacements;\n\n\t\tconst result: LineReplacement[] = [];\n\n\t\tconst currentEdits: TextReplacement[] = [];\n\t\tfor (let i = 0; i < edits.length; i++) {\n\t\t\tconst edit = edits[i];\n\t\t\tconst nextEditRange = i + 1 < edits.length ? edits[i + 1] : undefined;\n\t\t\tcurrentEdits.push(edit);\n\t\t\tif (nextEditRange && nextEditRange.range.startLineNumber === edit.range.endLineNumber) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst singleEdit = TextReplacement.joinReplacements(currentEdits, initialValue);\n\t\t\tcurrentEdits.length = 0;\n\n\t\t\tconst singleLineEdit = LineReplacement.fromSingleTextEdit(singleEdit, initialValue);\n\t\t\tresult.push(singleLineEdit);\n\t\t}\n\n\t\treturn new LineEdit(result);\n\t}\n\n\tpublic static createFromUnsorted(edits: readonly LineReplacement[]): LineEdit {\n\t\tconst result = edits.slice();\n\t\tresult.sort(compareBy(i => i.lineRange.startLineNumber, numberComparator));\n\t\treturn new LineEdit(result);\n\t}\n\n\tconstructor(\n\t\t/**\n\t\t * Have to be sorted by start line number and non-intersecting.\n\t\t*/\n\t\tpublic readonly replacements: readonly LineReplacement[]\n\t) {\n\t\tassert(checkAdjacentItems(replacements, (i1, i2) => i1.lineRange.endLineNumberExclusive <= i2.lineRange.startLineNumber));\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this.replacements.length === 0;\n\t}\n\n\tpublic toEdit(initialValue: AbstractText): StringEdit {\n\t\tconst edits: StringReplacement[] = [];\n\t\tfor (const edit of this.replacements) {\n\t\t\tconst singleEdit = edit.toSingleEdit(initialValue);\n\t\t\tedits.push(singleEdit);\n\t\t}\n\t\treturn new StringEdit(edits);\n\t}\n\n\tpublic toString(): string {\n\t\treturn this.replacements.map(e => e.toString()).join(',');\n\t}\n\n\tpublic serialize(): SerializedLineEdit {\n\t\treturn this.replacements.map(e => e.serialize());\n\t}\n\n\tpublic getNewLineRanges(): LineRange[] {\n\t\tconst ranges: LineRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tranges.push(LineRange.ofLength(e.lineRange.startLineNumber + offset, e.newLines.length),);\n\t\t\toffset += e.newLines.length - e.lineRange.length;\n\t\t}\n\t\treturn ranges;\n\t}\n\n\tpublic mapLineNumber(lineNumber: number): number {\n\t\tlet lineDelta = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tif (e.lineRange.endLineNumberExclusive > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlineDelta += e.newLines.length - e.lineRange.length;\n\t\t}\n\t\treturn lineNumber + lineDelta;\n\t}\n\n\tpublic mapLineRange(lineRange: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.mapLineNumber(lineRange.startLineNumber),\n\t\t\tthis.mapLineNumber(lineRange.endLineNumberExclusive),\n\t\t);\n\t}\n\n\n\t/** TODO improve, dont require originalLines */\n\tpublic mapBackLineRange(lineRange: LineRange, originalLines: string[]): LineRange {\n\t\tconst i = this.inverse(originalLines);\n\t\treturn i.mapLineRange(lineRange);\n\t}\n\n\tpublic touches(other: LineEdit): boolean {\n\t\treturn this.replacements.some(e1 => other.replacements.some(e2 => e1.lineRange.intersect(e2.lineRange)));\n\t}\n\n\tpublic rebase(base: LineEdit): LineEdit {\n\t\treturn new LineEdit(\n\t\t\tthis.replacements.map(e => new LineReplacement(base.mapLineRange(e.lineRange), e.newLines)),\n\t\t);\n\t}\n\n\tpublic humanReadablePatch(originalLines: string[]): string {\n\t\tconst result: string[] = [];\n\n\t\tfunction pushLine(originalLineNumber: number, modifiedLineNumber: number, kind: 'unmodified' | 'deleted' | 'added', content: string | undefined) {\n\t\t\tconst specialChar = (kind === 'unmodified' ? ' ' : (kind === 'deleted' ? '-' : '+'));\n\n\t\t\tif (content === undefined) {\n\t\t\t\tcontent = '[[[[[ WARNING: LINE DOES NOT EXIST ]]]]]';\n\t\t\t}\n\n\t\t\tconst origLn = originalLineNumber === -1 ? '   ' : originalLineNumber.toString().padStart(3, ' ');\n\t\t\tconst modLn = modifiedLineNumber === -1 ? '   ' : modifiedLineNumber.toString().padStart(3, ' ');\n\n\t\t\tresult.push(`${specialChar} ${origLn} ${modLn} ${content}`);\n\t\t}\n\n\t\tfunction pushSeperator() {\n\t\t\tresult.push('---');\n\t\t}\n\n\t\tlet lineDelta = 0;\n\t\tlet first = true;\n\n\t\tfor (const edits of groupAdjacentBy(this.replacements, (e1, e2) => e1.lineRange.distanceToRange(e2.lineRange) <= 5)) {\n\t\t\tif (!first) {\n\t\t\t\tpushSeperator();\n\t\t\t} else {\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\tlet lastLineNumber = edits[0].lineRange.startLineNumber - 2;\n\n\t\t\tfor (const edit of edits) {\n\t\t\t\tfor (let i = Math.max(1, lastLineNumber); i < edit.lineRange.startLineNumber; i++) {\n\t\t\t\t\tpushLine(i, i + lineDelta, 'unmodified', originalLines[i - 1]);\n\t\t\t\t}\n\n\t\t\t\tconst range = edit.lineRange;\n\t\t\t\tconst newLines = edit.newLines;\n\t\t\t\tfor (const replaceLineNumber of range.mapToLineArray(n => n)) {\n\t\t\t\t\tconst line = originalLines[replaceLineNumber - 1];\n\t\t\t\t\tpushLine(replaceLineNumber, -1, 'deleted', line);\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < newLines.length; i++) {\n\t\t\t\t\tconst line = newLines[i];\n\t\t\t\t\tpushLine(-1, range.startLineNumber + lineDelta + i, 'added', line);\n\t\t\t\t}\n\n\t\t\t\tlastLineNumber = range.endLineNumberExclusive;\n\n\t\t\t\tlineDelta += edit.newLines.length - edit.lineRange.length;\n\t\t\t}\n\n\t\t\tfor (let i = lastLineNumber; i <= Math.min(lastLineNumber + 2, originalLines.length); i++) {\n\t\t\t\tpushLine(i, i + lineDelta, 'unmodified', originalLines[i - 1]);\n\t\t\t}\n\t\t}\n\n\t\treturn result.join('\\n');\n\t}\n\n\tpublic apply(lines: string[]): string[] {\n\t\tconst result: string[] = [];\n\n\t\tlet currentLineIndex = 0;\n\n\t\tfor (const edit of this.replacements) {\n\t\t\twhile (currentLineIndex < edit.lineRange.startLineNumber - 1) {\n\t\t\t\tresult.push(lines[currentLineIndex]);\n\t\t\t\tcurrentLineIndex++;\n\t\t\t}\n\n\t\t\tfor (const newLine of edit.newLines) {\n\t\t\t\tresult.push(newLine);\n\t\t\t}\n\n\t\t\tcurrentLineIndex = edit.lineRange.endLineNumberExclusive - 1;\n\t\t}\n\n\t\twhile (currentLineIndex < lines.length) {\n\t\t\tresult.push(lines[currentLineIndex]);\n\t\t\tcurrentLineIndex++;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic inverse(originalLines: string[]): LineEdit {\n\t\tconst newRanges = this.getNewLineRanges();\n\t\treturn new LineEdit(this.replacements.map((e, idx) => new LineReplacement(\n\t\t\tnewRanges[idx],\n\t\t\toriginalLines.slice(e.lineRange.startLineNumber - 1, e.lineRange.endLineNumberExclusive - 1),\n\t\t)));\n\t}\n}\n\nexport class LineReplacement {\n\tpublic static deserialize(e: SerializedLineReplacement): LineReplacement {\n\t\treturn new LineReplacement(\n\t\t\tLineRange.ofLength(e[0], e[1] - e[0]),\n\t\t\te[2],\n\t\t);\n\t}\n\n\tpublic static fromSingleTextEdit(edit: TextReplacement, initialValue: AbstractText): LineReplacement {\n\t\t// 1: ab[cde\n\t\t// 2: fghijk\n\t\t// 3: lmn]opq\n\n\t\t// replaced with\n\n\t\t// 1n: 123\n\t\t// 2n: 456\n\t\t// 3n: 789\n\n\t\t// simple solution: replace [1..4) with [1n..4n)\n\n\t\tconst newLines = splitLines(edit.text);\n\t\tlet startLineNumber = edit.range.startLineNumber;\n\t\tconst survivingFirstLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tnew Position(edit.range.startLineNumber, 1),\n\t\t\tedit.range.getStartPosition()\n\t\t));\n\t\tnewLines[0] = survivingFirstLineText + newLines[0];\n\n\t\tlet endLineNumberEx = edit.range.endLineNumber + 1;\n\t\tconst editEndLineNumberMaxColumn = initialValue.getTransformer().getLineLength(edit.range.endLineNumber) + 1;\n\t\tconst survivingEndLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tedit.range.getEndPosition(),\n\t\t\tnew Position(edit.range.endLineNumber, editEndLineNumberMaxColumn)\n\t\t));\n\t\tnewLines[newLines.length - 1] = newLines[newLines.length - 1] + survivingEndLineText;\n\n\t\t// Replacing [startLineNumber, endLineNumberEx) with newLines would be correct, however it might not be minimal.\n\n\t\tconst startBeforeNewLine = edit.range.startColumn === initialValue.getTransformer().getLineLength(edit.range.startLineNumber) + 1;\n\t\tconst endAfterNewLine = edit.range.endColumn === 1;\n\n\t\tif (startBeforeNewLine && newLines[0].length === survivingFirstLineText.length) {\n\t\t\t// the replacement would not delete any text on the first line\n\t\t\tstartLineNumber++;\n\t\t\tnewLines.shift();\n\t\t}\n\n\t\tif (newLines.length > 0 && startLineNumber < endLineNumberEx && endAfterNewLine && newLines[newLines.length - 1].length === survivingEndLineText.length) {\n\t\t\t// the replacement would not delete any text on the last line\n\t\t\tendLineNumberEx--;\n\t\t\tnewLines.pop();\n\t\t}\n\n\t\treturn new LineReplacement(new LineRange(startLineNumber, endLineNumberEx), newLines);\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineRange: LineRange,\n\t\tpublic readonly newLines: readonly string[],\n\t) { }\n\n\tpublic toSingleTextEdit(initialValue: AbstractText): TextReplacement {\n\t\tif (this.newLines.length === 0) {\n\t\t\t// Deletion\n\t\t\tconst textLen = initialValue.getTransformer().textLength;\n\t\t\tif (this.lineRange.endLineNumberExclusive === textLen.lineCount + 2) {\n\t\t\t\tlet startPos: Position;\n\t\t\t\tif (this.lineRange.startLineNumber > 1) {\n\t\t\t\t\tconst startLineNumber = this.lineRange.startLineNumber - 1;\n\t\t\t\t\tconst startColumn = initialValue.getTransformer().getLineLength(startLineNumber) + 1;\n\t\t\t\t\tstartPos = new Position(startLineNumber, startColumn);\n\t\t\t\t} else {\n\t\t\t\t\t// Delete everything.\n\t\t\t\t\t// In terms of lines, this would end up with 0 lines.\n\t\t\t\t\t// However, a string has always 1 line (which can be empty).\n\t\t\t\t\tstartPos = new Position(1, 1);\n\t\t\t\t}\n\n\t\t\t\tconst lastPosition = textLen.addToPosition(new Position(1, 1));\n\t\t\t\treturn new TextReplacement(Range.fromPositions(startPos, lastPosition), '');\n\t\t\t} else {\n\t\t\t\treturn new TextReplacement(new Range(this.lineRange.startLineNumber, 1, this.lineRange.endLineNumberExclusive, 1), '');\n\t\t\t}\n\n\t\t} else if (this.lineRange.isEmpty) {\n\t\t\t// Insertion\n\n\t\t\tlet endLineNumber: number;\n\t\t\tlet column: number;\n\t\t\tlet text: string;\n\t\t\tconst insertionLine = this.lineRange.startLineNumber;\n\t\t\tif (insertionLine === initialValue.getTransformer().textLength.lineCount + 2) {\n\t\t\t\tendLineNumber = insertionLine - 1;\n\t\t\t\tcolumn = initialValue.getTransformer().getLineLength(endLineNumber) + 1;\n\t\t\t\ttext = this.newLines.map(l => '\\n' + l).join('');\n\t\t\t} else {\n\t\t\t\tendLineNumber = insertionLine;\n\t\t\t\tcolumn = 1;\n\t\t\t\ttext = this.newLines.map(l => l + '\\n').join('');\n\t\t\t}\n\t\t\treturn new TextReplacement(Range.fromPositions(new Position(endLineNumber, column)), text);\n\t\t} else {\n\t\t\tconst endLineNumber = this.lineRange.endLineNumberExclusive - 1;\n\t\t\tconst endLineNumberMaxColumn = initialValue.getTransformer().getLineLength(endLineNumber) + 1;\n\t\t\tconst range = new Range(\n\t\t\t\tthis.lineRange.startLineNumber,\n\t\t\t\t1,\n\t\t\t\tendLineNumber,\n\t\t\t\tendLineNumberMaxColumn\n\t\t\t);\n\t\t\t// Don't add \\n to the last line. This is because we subtract one from lineRange.endLineNumberExclusive for endLineNumber.\n\t\t\tconst text = this.newLines.join('\\n');\n\t\t\treturn new TextReplacement(range, text);\n\t\t}\n\t}\n\n\tpublic toSingleEdit(initialValue: AbstractText): StringReplacement {\n\t\tconst textEdit = this.toSingleTextEdit(initialValue);\n\t\tconst range = initialValue.getTransformer().getOffsetRange(textEdit.range);\n\t\treturn new StringReplacement(range, textEdit.text);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.lineRange}->${JSON.stringify(this.newLines)}`;\n\t}\n\n\tpublic serialize(): SerializedLineReplacement {\n\t\treturn [\n\t\t\tthis.lineRange.startLineNumber,\n\t\t\tthis.lineRange.endLineNumberExclusive,\n\t\t\tthis.newLines,\n\t\t];\n\t}\n\n\tpublic removeCommonSuffixPrefixLines(initialValue: AbstractText): LineReplacement {\n\t\tlet startLineNumber = this.lineRange.startLineNumber;\n\t\tlet endLineNumberEx = this.lineRange.endLineNumberExclusive;\n\n\t\tlet trimStartCount = 0;\n\t\twhile (\n\t\t\tstartLineNumber < endLineNumberEx && trimStartCount < this.newLines.length\n\t\t\t&& this.newLines[trimStartCount] === initialValue.getLineAt(startLineNumber)\n\t\t) {\n\t\t\tstartLineNumber++;\n\t\t\ttrimStartCount++;\n\t\t}\n\n\t\tlet trimEndCount = 0;\n\t\twhile (\n\t\t\tstartLineNumber < endLineNumberEx && trimEndCount + trimStartCount < this.newLines.length\n\t\t\t&& this.newLines[this.newLines.length - 1 - trimEndCount] === initialValue.getLineAt(endLineNumberEx - 1)\n\t\t) {\n\t\t\tendLineNumberEx--;\n\t\t\ttrimEndCount++;\n\t\t}\n\n\t\tif (trimStartCount === 0 && trimEndCount === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new LineReplacement(new LineRange(startLineNumber, endLineNumberEx), this.newLines.slice(trimStartCount, this.newLines.length - trimEndCount));\n\t}\n\n\tpublic toLineEdit(): LineEdit {\n\t\treturn new LineEdit([this]);\n\t}\n}\n\nexport type SerializedLineEdit = SerializedLineReplacement[];\nexport type SerializedLineReplacement = [startLineNumber: number, endLineNumber: number, newLines: readonly string[]];\n\nexport namespace SerializedLineReplacement {\n\texport function is(thing: unknown): thing is SerializedLineReplacement {\n\t\treturn (\n\t\t\tArray.isArray(thing)\n\t\t\t&& thing.length === 3\n\t\t\t&& typeof thing[0] === 'number'\n\t\t\t&& typeof thing[1] === 'number'\n\t\t\t&& Array.isArray(thing[2])\n\t\t\t&& thing[2].every((e: unknown) => typeof e === 'string')\n\t\t);\n\t}\n}\n"]}