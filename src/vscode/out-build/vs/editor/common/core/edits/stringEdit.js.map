{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/editor/common/core/edits/stringEdit.ts","vs/editor/common/core/edits/stringEdit.ts"],"names":[],"mappings":"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","file":"stringEdit.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { StringText } from '../text/abstractText.js';\nimport { BaseEdit, BaseReplacement } from './edit.js';\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport abstract class BaseStringEdit<T extends BaseStringReplacement<T> = BaseStringReplacement<any>, TEdit extends BaseStringEdit<T, TEdit> = BaseStringEdit<any, any>> extends BaseEdit<T, TEdit> {\n\tget TReplacement(): T {\n\t\tthrow new Error('TReplacement is not defined for BaseStringEdit');\n\t}\n\n\tpublic static composeOrUndefined<T extends BaseStringEdit>(edits: readonly T[]): T | undefined {\n\t\tif (edits.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n\t\t\tresult = result.compose(edits[i]) as any;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * r := trySwap(e1, e2);\n\t * e1.compose(e2) === r.e1.compose(r.e2)\n\t*/\n\tpublic static trySwap(e1: BaseStringEdit, e2: BaseStringEdit): { e1: StringEdit; e2: StringEdit } | undefined {\n\t\t// TODO make this more efficient\n\t\tconst e1Inv = e1.inverseOnSlice((start, endEx) => ' '.repeat(endEx - start));\n\n\t\tconst e1_ = e2.tryRebase(e1Inv);\n\t\tif (!e1_) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst e2_ = e1.tryRebase(e1_);\n\t\tif (!e2_) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn { e1: e1_, e2: e2_ };\n\t}\n\n\tpublic apply(base: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tresultText.push(base.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(base.substring(pos));\n\t\treturn resultText.join('');\n\t}\n\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tpublic inverseOnSlice(getOriginalSlice: (start: number, endEx: number) => string): StringEdit {\n\t\tconst edits: StringReplacement[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tedits.push(StringReplacement.replace(\n\t\t\t\tOffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.newText.length),\n\t\t\t\tgetOriginalSlice(e.replaceRange.start, e.replaceRange.endExclusive)\n\t\t\t));\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn new StringEdit(edits);\n\t}\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tpublic inverse(original: string): StringEdit {\n\t\treturn this.inverseOnSlice((start, endEx) => original.substring(start, endEx));\n\t}\n\n\tpublic rebaseSkipConflicting(base: StringEdit): StringEdit {\n\t\treturn this._tryRebase(base, false)!;\n\t}\n\n\tpublic tryRebase(base: StringEdit): StringEdit | undefined {\n\t\treturn this._tryRebase(base, true);\n\t}\n\n\tprivate _tryRebase(base: StringEdit, noOverlap: boolean): StringEdit | undefined {\n\t\tconst newEdits: StringReplacement[] = [];\n\n\t\tlet baseIdx = 0;\n\t\tlet ourIdx = 0;\n\t\tlet offset = 0;\n\n\t\twhile (ourIdx < this.replacements.length || baseIdx < base.replacements.length) {\n\t\t\t// take the edit that starts first\n\t\t\tconst baseEdit = base.replacements[baseIdx];\n\t\t\tconst ourEdit = this.replacements[ourIdx];\n\n\t\t\tif (!ourEdit) {\n\t\t\t\t// We processed all our edits\n\t\t\t\tbreak;\n\t\t\t} else if (!baseEdit) {\n\t\t\t\t// no more edits from base\n\t\t\t\tnewEdits.push(new StringReplacement(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else if (ourEdit.replaceRange.intersectsOrTouches(baseEdit.replaceRange)) {\n\t\t\t\tourIdx++; // Don't take our edit, as it is conflicting -> skip\n\t\t\t\tif (noOverlap) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t} else if (ourEdit.replaceRange.start < baseEdit.replaceRange.start) {\n\t\t\t\t// Our edit starts first\n\t\t\t\tnewEdits.push(new StringReplacement(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else {\n\t\t\t\tbaseIdx++;\n\t\t\t\toffset += baseEdit.newText.length - baseEdit.replaceRange.length;\n\t\t\t}\n\t\t}\n\n\t\treturn new StringEdit(newEdits);\n\t}\n\n\tpublic toJson(): ISerializedStringEdit {\n\t\treturn this.replacements.map(e => e.toJson());\n\t}\n\n\tpublic isNeutralOn(text: string): boolean {\n\t\treturn this.replacements.every(e => e.isNeutralOn(text));\n\t}\n\n\tpublic removeCommonSuffixPrefix(originalText: string): StringEdit {\n\t\tconst edits: StringReplacement[] = [];\n\t\tfor (const e of this.replacements) {\n\t\t\tconst edit = e.removeCommonSuffixPrefix(originalText);\n\t\t\tif (!edit.isEmpty) {\n\t\t\t\tedits.push(edit);\n\t\t\t}\n\t\t}\n\t\treturn new StringEdit(edits);\n\t}\n\n\tpublic normalizeEOL(eol: '\\r\\n' | '\\n'): StringEdit {\n\t\treturn new StringEdit(this.replacements.map(edit => edit.normalizeEOL(eol)));\n\t}\n\n\t/**\n\t * If `e1.apply(source) === e2.apply(source)`, then `e1.normalizeOnSource(source).equals(e2.normalizeOnSource(source))`.\n\t*/\n\tpublic normalizeOnSource(source: string): StringEdit {\n\t\tconst result = this.apply(source);\n\n\t\tconst edit = StringReplacement.replace(OffsetRange.ofLength(source.length), result);\n\t\tconst e = edit.removeCommonSuffixAndPrefix(source);\n\t\tif (e.isEmpty) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\treturn e.toEdit();\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): TEdit {\n\t\treturn this._createNew(this.replacements.map(e => e.removeCommonSuffixAndPrefix(source))).normalize();\n\t}\n\n\tpublic applyOnText(docContents: StringText): StringText {\n\t\treturn new StringText(this.apply(docContents.value));\n\t}\n\n\tpublic mapData<TData extends IEditData<TData>>(f: (replacement: T) => TData): AnnotatedStringEdit<TData> {\n\t\treturn new AnnotatedStringEdit(\n\t\t\tthis.replacements.map(e => new AnnotatedStringReplacement(\n\t\t\t\te.replaceRange,\n\t\t\t\te.newText,\n\t\t\t\tf(e)\n\t\t\t))\n\t\t);\n\t}\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport abstract class BaseStringReplacement<T extends BaseStringReplacement<T> = BaseStringReplacement<any>> extends BaseReplacement<T> {\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tpublic readonly newText: string\n\t) {\n\t\tsuper(range);\n\t}\n\n\tgetNewLength(): number { return this.newText.length; }\n\n\toverride toString(): string {\n\t\treturn `${this.replaceRange} -> ${JSON.stringify(this.newText)}`;\n\t}\n\n\treplace(str: string): string {\n\t\treturn str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);\n\t}\n\n\t/**\n\t * Checks if the edit would produce no changes when applied to the given text.\n\t */\n\tisNeutralOn(text: string): boolean {\n\t\treturn this.newText === text.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\t}\n\n\tremoveCommonSuffixPrefix(originalText: string): StringReplacement {\n\t\tconst oldText = originalText.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tconst suffixLen = Math.min(\n\t\t\toldText.length - prefixLen,\n\t\t\tthis.newText.length - prefixLen,\n\t\t\tcommonSuffixLength(oldText, this.newText)\n\t\t);\n\n\t\tconst replaceRange = new OffsetRange(\n\t\t\tthis.replaceRange.start + prefixLen,\n\t\t\tthis.replaceRange.endExclusive - suffixLen,\n\t\t);\n\t\tconst newText = this.newText.substring(prefixLen, this.newText.length - suffixLen);\n\n\t\treturn new StringReplacement(replaceRange, newText);\n\t}\n\n\tnormalizeEOL(eol: '\\r\\n' | '\\n'): StringReplacement {\n\t\tconst newText = this.newText.replace(/\\r\\n|\\n/g, eol);\n\t\treturn new StringReplacement(this.replaceRange, newText);\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): T {\n\t\treturn this.removeCommonSuffix(source).removeCommonPrefix(source);\n\t}\n\n\tpublic removeCommonPrefix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tif (prefixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\n\t\treturn this.slice(this.replaceRange.deltaStart(prefixLen), new OffsetRange(prefixLen, this.newText.length));\n\t}\n\n\tpublic removeCommonSuffix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst suffixLen = commonSuffixLength(oldText, this.newText);\n\t\tif (suffixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\t\treturn this.slice(this.replaceRange.deltaEnd(-suffixLen), new OffsetRange(0, this.newText.length - suffixLen));\n\t}\n\n\tpublic toEdit(): StringEdit {\n\t\treturn new StringEdit([this]);\n\t}\n\n\tpublic toJson(): ISerializedStringReplacement {\n\t\treturn ({\n\t\t\ttxt: this.newText,\n\t\t\tpos: this.replaceRange.start,\n\t\t\tlen: this.replaceRange.length,\n\t\t});\n\t}\n}\n\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class StringEdit extends BaseStringEdit<StringReplacement, StringEdit> {\n\tpublic static readonly empty = new StringEdit([]);\n\n\tpublic static create(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n\n\tpublic static single(replacement: StringReplacement): StringEdit {\n\t\treturn new StringEdit([replacement]);\n\t}\n\n\tpublic static replace(range: OffsetRange, replacement: string): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(range, replacement)]);\n\t}\n\n\tpublic static insert(offset: number, replacement: string): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(OffsetRange.emptyAt(offset), replacement)]);\n\t}\n\n\tpublic static delete(range: OffsetRange): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(range, '')]);\n\t}\n\n\tpublic static fromJson(data: ISerializedStringEdit): StringEdit {\n\t\treturn new StringEdit(data.map(StringReplacement.fromJson));\n\t}\n\n\tpublic static compose(edits: readonly StringEdit[]): StringEdit {\n\t\tif (edits.length === 0) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The replacements are applied in order!\n\t * Equals `StringEdit.compose(replacements.map(r => r.toEdit()))`, but is much more performant.\n\t*/\n\tpublic static composeSequentialReplacements(replacements: readonly StringReplacement[]): StringEdit {\n\t\tlet edit = StringEdit.empty;\n\t\tlet curEditReplacements: StringReplacement[] = []; // These are reverse sorted\n\n\t\tfor (const r of replacements) {\n\t\t\tconst last = curEditReplacements.at(-1);\n\t\t\tif (!last || r.replaceRange.isBefore(last.replaceRange)) {\n\t\t\t\t// Detect subsequences of reverse sorted replacements\n\t\t\t\tcurEditReplacements.push(r);\n\t\t\t} else {\n\t\t\t\t// Once the subsequence is broken, compose the current replacements and look for a new subsequence.\n\t\t\t\tedit = edit.compose(StringEdit.create(curEditReplacements.reverse()));\n\t\t\t\tcurEditReplacements = [r];\n\t\t\t}\n\t\t}\n\n\t\tedit = edit.compose(StringEdit.create(curEditReplacements.reverse()));\n\t\treturn edit;\n\t}\n\n\tconstructor(replacements: readonly StringReplacement[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n}\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport type ISerializedStringEdit = ISerializedStringReplacement[];\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport interface ISerializedStringReplacement {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class StringReplacement extends BaseStringReplacement<StringReplacement> {\n\tpublic static insert(offset: number, text: string): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tpublic static replace(range: OffsetRange, text: string): StringReplacement {\n\t\treturn new StringReplacement(range, text);\n\t}\n\n\tpublic static delete(range: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, '');\n\t}\n\n\tpublic static fromJson(data: ISerializedStringReplacement): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.ofStartAndLength(data.pos, data.len), data.txt);\n\t}\n\n\toverride equals(other: StringReplacement): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText;\n\t}\n\n\toverride tryJoinTouching(other: StringReplacement): StringReplacement | undefined {\n\t\treturn new StringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText);\n\t}\n\n\toverride slice(range: OffsetRange, rangeInReplacement?: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText);\n\t}\n}\n\nexport function applyEditsToRanges(sortedRanges: OffsetRange[], edit: StringEdit): OffsetRange[] {\n\tsortedRanges = sortedRanges.slice();\n\n\t// treat edits as deletion of the replace range and then as insertion that extends the first range\n\tconst result: OffsetRange[] = [];\n\n\tlet offset = 0;\n\n\tfor (const e of edit.replacements) {\n\t\twhile (true) {\n\t\t\t// ranges before the current edit\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || r.endExclusive >= e.replaceRange.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tresult.push(r.delta(offset));\n\t\t}\n\n\t\tconst intersecting: OffsetRange[] = [];\n\t\twhile (true) {\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || !r.intersectsOrTouches(e.replaceRange)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tintersecting.push(r);\n\t\t}\n\n\t\tfor (let i = intersecting.length - 1; i >= 0; i--) {\n\t\t\tlet r = intersecting[i];\n\n\t\t\tconst overlap = r.intersect(e.replaceRange)!.length;\n\t\t\tr = r.deltaEnd(-overlap + (i === 0 ? e.newText.length : 0));\n\n\t\t\tconst rangeAheadOfReplaceRange = r.start - e.replaceRange.start;\n\t\t\tif (rangeAheadOfReplaceRange > 0) {\n\t\t\t\tr = r.delta(-rangeAheadOfReplaceRange);\n\t\t\t}\n\n\t\t\tif (i !== 0) {\n\t\t\t\tr = r.delta(e.newText.length);\n\t\t\t}\n\n\t\t\t// We already took our offset into account.\n\t\t\t// Because we add r back to the queue (which then adds offset again),\n\t\t\t// we have to remove it here.\n\t\t\tr = r.delta(-(e.newText.length - e.replaceRange.length));\n\n\t\t\tsortedRanges.unshift(r);\n\t\t}\n\n\t\toffset += e.newText.length - e.replaceRange.length;\n\t}\n\n\twhile (true) {\n\t\tconst r = sortedRanges[0];\n\t\tif (!r) {\n\t\t\tbreak;\n\t\t}\n\t\tsortedRanges.shift();\n\t\tresult.push(r.delta(offset));\n\t}\n\n\treturn result;\n}\n\n/**\n * Represents data associated to a single edit, which survives certain edit operations.\n*/\nexport interface IEditData<T> {\n\tjoin(other: T): T | undefined;\n}\n\nexport class VoidEditData implements IEditData<VoidEditData> {\n\tjoin(other: VoidEditData): VoidEditData | undefined {\n\t\treturn this;\n\t}\n}\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class AnnotatedStringEdit<T extends IEditData<T>> extends BaseStringEdit<AnnotatedStringReplacement<T>, AnnotatedStringEdit<T>> {\n\tpublic static readonly empty = new AnnotatedStringEdit<never>([]);\n\n\tpublic static create<T extends IEditData<T>>(replacements: readonly AnnotatedStringReplacement<T>[]): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit(replacements);\n\t}\n\n\tpublic static single<T extends IEditData<T>>(replacement: AnnotatedStringReplacement<T>): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([replacement]);\n\t}\n\n\tpublic static replace<T extends IEditData<T>>(range: OffsetRange, replacement: string, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(range, replacement, data)]);\n\t}\n\n\tpublic static insert<T extends IEditData<T>>(offset: number, replacement: string, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(OffsetRange.emptyAt(offset), replacement, data)]);\n\t}\n\n\tpublic static delete<T extends IEditData<T>>(range: OffsetRange, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(range, '', data)]);\n\t}\n\n\tpublic static compose<T extends IEditData<T>>(edits: readonly AnnotatedStringEdit<T>[]): AnnotatedStringEdit<T> {\n\t\tif (edits.length === 0) {\n\t\t\treturn AnnotatedStringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tconstructor(replacements: readonly AnnotatedStringReplacement<T>[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly AnnotatedStringReplacement<T>[]): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit<T>(replacements);\n\t}\n\n\tpublic toStringEdit(filter?: (replacement: AnnotatedStringReplacement<T>) => boolean): StringEdit {\n\t\tconst newReplacements: StringReplacement[] = [];\n\t\tfor (const r of this.replacements) {\n\t\t\tif (!filter || filter(r)) {\n\t\t\t\tnewReplacements.push(new StringReplacement(r.replaceRange, r.newText));\n\t\t\t}\n\t\t}\n\t\treturn new StringEdit(newReplacements);\n\t}\n}\n\nexport class AnnotatedStringReplacement<T extends IEditData<T>> extends BaseStringReplacement<AnnotatedStringReplacement<T>> {\n\tpublic static insert<T extends IEditData<T>>(offset: number, text: string, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(OffsetRange.emptyAt(offset), text, data);\n\t}\n\n\tpublic static replace<T extends IEditData<T>>(range: OffsetRange, text: string, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(range, text, data);\n\t}\n\n\tpublic static delete<T extends IEditData<T>>(range: OffsetRange, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(range, '', data);\n\t}\n\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tnewText: string,\n\t\tpublic readonly data: T\n\t) {\n\t\tsuper(range, newText);\n\t}\n\n\toverride equals(other: AnnotatedStringReplacement<T>): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText && this.data === other.data;\n\t}\n\n\ttryJoinTouching(other: AnnotatedStringReplacement<T>): AnnotatedStringReplacement<T> | undefined {\n\t\tconst joined = this.data.join(other.data);\n\t\tif (joined === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new AnnotatedStringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText, joined);\n\t}\n\n\tslice(range: OffsetRange, rangeInReplacement?: OffsetRange): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText, this.data);\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { StringText } from '../text/abstractText.js';\nimport { BaseEdit, BaseReplacement } from './edit.js';\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport abstract class BaseStringEdit<T extends BaseStringReplacement<T> = BaseStringReplacement<any>, TEdit extends BaseStringEdit<T, TEdit> = BaseStringEdit<any, any>> extends BaseEdit<T, TEdit> {\n\tget TReplacement(): T {\n\t\tthrow new Error('TReplacement is not defined for BaseStringEdit');\n\t}\n\n\tpublic static composeOrUndefined<T extends BaseStringEdit>(edits: readonly T[]): T | undefined {\n\t\tif (edits.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n\t\t\tresult = result.compose(edits[i]) as any;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * r := trySwap(e1, e2);\n\t * e1.compose(e2) === r.e1.compose(r.e2)\n\t*/\n\tpublic static trySwap(e1: BaseStringEdit, e2: BaseStringEdit): { e1: StringEdit; e2: StringEdit } | undefined {\n\t\t// TODO make this more efficient\n\t\tconst e1Inv = e1.inverseOnSlice((start, endEx) => ' '.repeat(endEx - start));\n\n\t\tconst e1_ = e2.tryRebase(e1Inv);\n\t\tif (!e1_) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst e2_ = e1.tryRebase(e1_);\n\t\tif (!e2_) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn { e1: e1_, e2: e2_ };\n\t}\n\n\tpublic apply(base: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tresultText.push(base.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(base.substring(pos));\n\t\treturn resultText.join('');\n\t}\n\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tpublic inverseOnSlice(getOriginalSlice: (start: number, endEx: number) => string): StringEdit {\n\t\tconst edits: StringReplacement[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tedits.push(StringReplacement.replace(\n\t\t\t\tOffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.newText.length),\n\t\t\t\tgetOriginalSlice(e.replaceRange.start, e.replaceRange.endExclusive)\n\t\t\t));\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn new StringEdit(edits);\n\t}\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tpublic inverse(original: string): StringEdit {\n\t\treturn this.inverseOnSlice((start, endEx) => original.substring(start, endEx));\n\t}\n\n\tpublic rebaseSkipConflicting(base: StringEdit): StringEdit {\n\t\treturn this._tryRebase(base, false)!;\n\t}\n\n\tpublic tryRebase(base: StringEdit): StringEdit | undefined {\n\t\treturn this._tryRebase(base, true);\n\t}\n\n\tprivate _tryRebase(base: StringEdit, noOverlap: boolean): StringEdit | undefined {\n\t\tconst newEdits: StringReplacement[] = [];\n\n\t\tlet baseIdx = 0;\n\t\tlet ourIdx = 0;\n\t\tlet offset = 0;\n\n\t\twhile (ourIdx < this.replacements.length || baseIdx < base.replacements.length) {\n\t\t\t// take the edit that starts first\n\t\t\tconst baseEdit = base.replacements[baseIdx];\n\t\t\tconst ourEdit = this.replacements[ourIdx];\n\n\t\t\tif (!ourEdit) {\n\t\t\t\t// We processed all our edits\n\t\t\t\tbreak;\n\t\t\t} else if (!baseEdit) {\n\t\t\t\t// no more edits from base\n\t\t\t\tnewEdits.push(new StringReplacement(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else if (ourEdit.replaceRange.intersectsOrTouches(baseEdit.replaceRange)) {\n\t\t\t\tourIdx++; // Don't take our edit, as it is conflicting -> skip\n\t\t\t\tif (noOverlap) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t} else if (ourEdit.replaceRange.start < baseEdit.replaceRange.start) {\n\t\t\t\t// Our edit starts first\n\t\t\t\tnewEdits.push(new StringReplacement(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else {\n\t\t\t\tbaseIdx++;\n\t\t\t\toffset += baseEdit.newText.length - baseEdit.replaceRange.length;\n\t\t\t}\n\t\t}\n\n\t\treturn new StringEdit(newEdits);\n\t}\n\n\tpublic toJson(): ISerializedStringEdit {\n\t\treturn this.replacements.map(e => e.toJson());\n\t}\n\n\tpublic isNeutralOn(text: string): boolean {\n\t\treturn this.replacements.every(e => e.isNeutralOn(text));\n\t}\n\n\tpublic removeCommonSuffixPrefix(originalText: string): StringEdit {\n\t\tconst edits: StringReplacement[] = [];\n\t\tfor (const e of this.replacements) {\n\t\t\tconst edit = e.removeCommonSuffixPrefix(originalText);\n\t\t\tif (!edit.isEmpty) {\n\t\t\t\tedits.push(edit);\n\t\t\t}\n\t\t}\n\t\treturn new StringEdit(edits);\n\t}\n\n\tpublic normalizeEOL(eol: '\\r\\n' | '\\n'): StringEdit {\n\t\treturn new StringEdit(this.replacements.map(edit => edit.normalizeEOL(eol)));\n\t}\n\n\t/**\n\t * If `e1.apply(source) === e2.apply(source)`, then `e1.normalizeOnSource(source).equals(e2.normalizeOnSource(source))`.\n\t*/\n\tpublic normalizeOnSource(source: string): StringEdit {\n\t\tconst result = this.apply(source);\n\n\t\tconst edit = StringReplacement.replace(OffsetRange.ofLength(source.length), result);\n\t\tconst e = edit.removeCommonSuffixAndPrefix(source);\n\t\tif (e.isEmpty) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\treturn e.toEdit();\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): TEdit {\n\t\treturn this._createNew(this.replacements.map(e => e.removeCommonSuffixAndPrefix(source))).normalize();\n\t}\n\n\tpublic applyOnText(docContents: StringText): StringText {\n\t\treturn new StringText(this.apply(docContents.value));\n\t}\n\n\tpublic mapData<TData extends IEditData<TData>>(f: (replacement: T) => TData): AnnotatedStringEdit<TData> {\n\t\treturn new AnnotatedStringEdit(\n\t\t\tthis.replacements.map(e => new AnnotatedStringReplacement(\n\t\t\t\te.replaceRange,\n\t\t\t\te.newText,\n\t\t\t\tf(e)\n\t\t\t))\n\t\t);\n\t}\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport abstract class BaseStringReplacement<T extends BaseStringReplacement<T> = BaseStringReplacement<any>> extends BaseReplacement<T> {\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tpublic readonly newText: string\n\t) {\n\t\tsuper(range);\n\t}\n\n\tgetNewLength(): number { return this.newText.length; }\n\n\toverride toString(): string {\n\t\treturn `${this.replaceRange} -> ${JSON.stringify(this.newText)}`;\n\t}\n\n\treplace(str: string): string {\n\t\treturn str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);\n\t}\n\n\t/**\n\t * Checks if the edit would produce no changes when applied to the given text.\n\t */\n\tisNeutralOn(text: string): boolean {\n\t\treturn this.newText === text.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\t}\n\n\tremoveCommonSuffixPrefix(originalText: string): StringReplacement {\n\t\tconst oldText = originalText.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tconst suffixLen = Math.min(\n\t\t\toldText.length - prefixLen,\n\t\t\tthis.newText.length - prefixLen,\n\t\t\tcommonSuffixLength(oldText, this.newText)\n\t\t);\n\n\t\tconst replaceRange = new OffsetRange(\n\t\t\tthis.replaceRange.start + prefixLen,\n\t\t\tthis.replaceRange.endExclusive - suffixLen,\n\t\t);\n\t\tconst newText = this.newText.substring(prefixLen, this.newText.length - suffixLen);\n\n\t\treturn new StringReplacement(replaceRange, newText);\n\t}\n\n\tnormalizeEOL(eol: '\\r\\n' | '\\n'): StringReplacement {\n\t\tconst newText = this.newText.replace(/\\r\\n|\\n/g, eol);\n\t\treturn new StringReplacement(this.replaceRange, newText);\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): T {\n\t\treturn this.removeCommonSuffix(source).removeCommonPrefix(source);\n\t}\n\n\tpublic removeCommonPrefix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tif (prefixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\n\t\treturn this.slice(this.replaceRange.deltaStart(prefixLen), new OffsetRange(prefixLen, this.newText.length));\n\t}\n\n\tpublic removeCommonSuffix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst suffixLen = commonSuffixLength(oldText, this.newText);\n\t\tif (suffixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\t\treturn this.slice(this.replaceRange.deltaEnd(-suffixLen), new OffsetRange(0, this.newText.length - suffixLen));\n\t}\n\n\tpublic toEdit(): StringEdit {\n\t\treturn new StringEdit([this]);\n\t}\n\n\tpublic toJson(): ISerializedStringReplacement {\n\t\treturn ({\n\t\t\ttxt: this.newText,\n\t\t\tpos: this.replaceRange.start,\n\t\t\tlen: this.replaceRange.length,\n\t\t});\n\t}\n}\n\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class StringEdit extends BaseStringEdit<StringReplacement, StringEdit> {\n\tpublic static readonly empty = new StringEdit([]);\n\n\tpublic static create(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n\n\tpublic static single(replacement: StringReplacement): StringEdit {\n\t\treturn new StringEdit([replacement]);\n\t}\n\n\tpublic static replace(range: OffsetRange, replacement: string): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(range, replacement)]);\n\t}\n\n\tpublic static insert(offset: number, replacement: string): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(OffsetRange.emptyAt(offset), replacement)]);\n\t}\n\n\tpublic static delete(range: OffsetRange): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(range, '')]);\n\t}\n\n\tpublic static fromJson(data: ISerializedStringEdit): StringEdit {\n\t\treturn new StringEdit(data.map(StringReplacement.fromJson));\n\t}\n\n\tpublic static compose(edits: readonly StringEdit[]): StringEdit {\n\t\tif (edits.length === 0) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The replacements are applied in order!\n\t * Equals `StringEdit.compose(replacements.map(r => r.toEdit()))`, but is much more performant.\n\t*/\n\tpublic static composeSequentialReplacements(replacements: readonly StringReplacement[]): StringEdit {\n\t\tlet edit = StringEdit.empty;\n\t\tlet curEditReplacements: StringReplacement[] = []; // These are reverse sorted\n\n\t\tfor (const r of replacements) {\n\t\t\tconst last = curEditReplacements.at(-1);\n\t\t\tif (!last || r.replaceRange.isBefore(last.replaceRange)) {\n\t\t\t\t// Detect subsequences of reverse sorted replacements\n\t\t\t\tcurEditReplacements.push(r);\n\t\t\t} else {\n\t\t\t\t// Once the subsequence is broken, compose the current replacements and look for a new subsequence.\n\t\t\t\tedit = edit.compose(StringEdit.create(curEditReplacements.reverse()));\n\t\t\t\tcurEditReplacements = [r];\n\t\t\t}\n\t\t}\n\n\t\tedit = edit.compose(StringEdit.create(curEditReplacements.reverse()));\n\t\treturn edit;\n\t}\n\n\tconstructor(replacements: readonly StringReplacement[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n}\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport type ISerializedStringEdit = ISerializedStringReplacement[];\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport interface ISerializedStringReplacement {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class StringReplacement extends BaseStringReplacement<StringReplacement> {\n\tpublic static insert(offset: number, text: string): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tpublic static replace(range: OffsetRange, text: string): StringReplacement {\n\t\treturn new StringReplacement(range, text);\n\t}\n\n\tpublic static delete(range: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, '');\n\t}\n\n\tpublic static fromJson(data: ISerializedStringReplacement): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.ofStartAndLength(data.pos, data.len), data.txt);\n\t}\n\n\toverride equals(other: StringReplacement): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText;\n\t}\n\n\toverride tryJoinTouching(other: StringReplacement): StringReplacement | undefined {\n\t\treturn new StringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText);\n\t}\n\n\toverride slice(range: OffsetRange, rangeInReplacement?: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText);\n\t}\n}\n\nexport function applyEditsToRanges(sortedRanges: OffsetRange[], edit: StringEdit): OffsetRange[] {\n\tsortedRanges = sortedRanges.slice();\n\n\t// treat edits as deletion of the replace range and then as insertion that extends the first range\n\tconst result: OffsetRange[] = [];\n\n\tlet offset = 0;\n\n\tfor (const e of edit.replacements) {\n\t\twhile (true) {\n\t\t\t// ranges before the current edit\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || r.endExclusive >= e.replaceRange.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tresult.push(r.delta(offset));\n\t\t}\n\n\t\tconst intersecting: OffsetRange[] = [];\n\t\twhile (true) {\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || !r.intersectsOrTouches(e.replaceRange)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tintersecting.push(r);\n\t\t}\n\n\t\tfor (let i = intersecting.length - 1; i >= 0; i--) {\n\t\t\tlet r = intersecting[i];\n\n\t\t\tconst overlap = r.intersect(e.replaceRange)!.length;\n\t\t\tr = r.deltaEnd(-overlap + (i === 0 ? e.newText.length : 0));\n\n\t\t\tconst rangeAheadOfReplaceRange = r.start - e.replaceRange.start;\n\t\t\tif (rangeAheadOfReplaceRange > 0) {\n\t\t\t\tr = r.delta(-rangeAheadOfReplaceRange);\n\t\t\t}\n\n\t\t\tif (i !== 0) {\n\t\t\t\tr = r.delta(e.newText.length);\n\t\t\t}\n\n\t\t\t// We already took our offset into account.\n\t\t\t// Because we add r back to the queue (which then adds offset again),\n\t\t\t// we have to remove it here.\n\t\t\tr = r.delta(-(e.newText.length - e.replaceRange.length));\n\n\t\t\tsortedRanges.unshift(r);\n\t\t}\n\n\t\toffset += e.newText.length - e.replaceRange.length;\n\t}\n\n\twhile (true) {\n\t\tconst r = sortedRanges[0];\n\t\tif (!r) {\n\t\t\tbreak;\n\t\t}\n\t\tsortedRanges.shift();\n\t\tresult.push(r.delta(offset));\n\t}\n\n\treturn result;\n}\n\n/**\n * Represents data associated to a single edit, which survives certain edit operations.\n*/\nexport interface IEditData<T> {\n\tjoin(other: T): T | undefined;\n}\n\nexport class VoidEditData implements IEditData<VoidEditData> {\n\tjoin(other: VoidEditData): VoidEditData | undefined {\n\t\treturn this;\n\t}\n}\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class AnnotatedStringEdit<T extends IEditData<T>> extends BaseStringEdit<AnnotatedStringReplacement<T>, AnnotatedStringEdit<T>> {\n\tpublic static readonly empty = new AnnotatedStringEdit<never>([]);\n\n\tpublic static create<T extends IEditData<T>>(replacements: readonly AnnotatedStringReplacement<T>[]): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit(replacements);\n\t}\n\n\tpublic static single<T extends IEditData<T>>(replacement: AnnotatedStringReplacement<T>): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([replacement]);\n\t}\n\n\tpublic static replace<T extends IEditData<T>>(range: OffsetRange, replacement: string, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(range, replacement, data)]);\n\t}\n\n\tpublic static insert<T extends IEditData<T>>(offset: number, replacement: string, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(OffsetRange.emptyAt(offset), replacement, data)]);\n\t}\n\n\tpublic static delete<T extends IEditData<T>>(range: OffsetRange, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(range, '', data)]);\n\t}\n\n\tpublic static compose<T extends IEditData<T>>(edits: readonly AnnotatedStringEdit<T>[]): AnnotatedStringEdit<T> {\n\t\tif (edits.length === 0) {\n\t\t\treturn AnnotatedStringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tconstructor(replacements: readonly AnnotatedStringReplacement<T>[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly AnnotatedStringReplacement<T>[]): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit<T>(replacements);\n\t}\n\n\tpublic toStringEdit(filter?: (replacement: AnnotatedStringReplacement<T>) => boolean): StringEdit {\n\t\tconst newReplacements: StringReplacement[] = [];\n\t\tfor (const r of this.replacements) {\n\t\t\tif (!filter || filter(r)) {\n\t\t\t\tnewReplacements.push(new StringReplacement(r.replaceRange, r.newText));\n\t\t\t}\n\t\t}\n\t\treturn new StringEdit(newReplacements);\n\t}\n}\n\nexport class AnnotatedStringReplacement<T extends IEditData<T>> extends BaseStringReplacement<AnnotatedStringReplacement<T>> {\n\tpublic static insert<T extends IEditData<T>>(offset: number, text: string, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(OffsetRange.emptyAt(offset), text, data);\n\t}\n\n\tpublic static replace<T extends IEditData<T>>(range: OffsetRange, text: string, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(range, text, data);\n\t}\n\n\tpublic static delete<T extends IEditData<T>>(range: OffsetRange, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(range, '', data);\n\t}\n\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tnewText: string,\n\t\tpublic readonly data: T\n\t) {\n\t\tsuper(range, newText);\n\t}\n\n\toverride equals(other: AnnotatedStringReplacement<T>): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText && this.data === other.data;\n\t}\n\n\ttryJoinTouching(other: AnnotatedStringReplacement<T>): AnnotatedStringReplacement<T> | undefined {\n\t\tconst joined = this.data.join(other.data);\n\t\tif (joined === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new AnnotatedStringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText, joined);\n\t}\n\n\tslice(range: OffsetRange, rangeInReplacement?: OffsetRange): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText, this.data);\n\t}\n}\n\n"]}