{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/editor/contrib/folding/test/browser/foldingRanges.test.ts","vs/editor/contrib/folding/test/browser/foldingRanges.test.ts"],"names":[],"mappings":"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","file":"foldingRanges.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { FoldingMarkers } from '../../../../common/languages/languageConfiguration.js';\nimport { MAX_FOLDING_REGIONS, FoldRange, FoldingRegions, FoldSource } from '../../browser/foldingRanges.js';\nimport { RangesCollector, computeRanges } from '../../browser/indentRangeProvider.js';\nimport { createTextModel } from '../../../../test/common/testTextModel.js';\n\nconst markers: FoldingMarkers = {\n\tstart: /^#region$/,\n\tend: /^#endregion$/\n};\n\nsuite('FoldingRanges', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\tconst foldRange = (from: number, to: number, collapsed: boolean | undefined = undefined, source: FoldSource = FoldSource.provider, type: string | undefined = undefined) =>\n\t\t<FoldRange>{\n\t\t\tstartLineNumber: from,\n\t\t\tendLineNumber: to,\n\t\t\ttype: type,\n\t\t\tisCollapsed: collapsed || false,\n\t\t\tsource\n\t\t};\n\tconst assertEqualRanges = (range1: FoldRange, range2: FoldRange, msg: string) => {\n\t\tassert.strictEqual(range1.startLineNumber, range2.startLineNumber, msg + ' start');\n\t\tassert.strictEqual(range1.endLineNumber, range2.endLineNumber, msg + ' end');\n\t\tassert.strictEqual(range1.type, range2.type, msg + ' type');\n\t\tassert.strictEqual(range1.isCollapsed, range2.isCollapsed, msg + ' collapsed');\n\t\tassert.strictEqual(range1.source, range2.source, msg + ' source');\n\t};\n\n\ttest('test max folding regions', () => {\n\t\tconst lines: string[] = [];\n\t\tconst nRegions = MAX_FOLDING_REGIONS;\n\t\tconst collector = new RangesCollector({ limit: MAX_FOLDING_REGIONS, update: () => { } });\n\t\tfor (let i = 0; i < nRegions; i++) {\n\t\t\tconst startLineNumber = lines.length;\n\t\t\tlines.push('#region');\n\t\t\tconst endLineNumber = lines.length;\n\t\t\tlines.push('#endregion');\n\t\t\tcollector.insertFirst(startLineNumber, endLineNumber, 0);\n\t\t}\n\t\tconst model = createTextModel(lines.join('\\n'));\n\t\tconst actual = collector.toIndentRanges(model);\n\t\tassert.strictEqual(actual.length, nRegions, 'len');\n\t\tmodel.dispose();\n\n\t});\n\n\ttest('findRange', () => {\n\t\tconst lines = [\n\t\t/* 1*/\t'#region',\n\t\t/* 2*/\t'#endregion',\n\t\t/* 3*/\t'class A {',\n\t\t/* 4*/\t'  void foo() {',\n\t\t/* 5*/\t'    if (true) {',\n\t\t/* 6*/\t'        return;',\n\t\t/* 7*/\t'    }',\n\t\t/* 8*/\t'',\n\t\t/* 9*/\t'    if (true) {',\n\t\t/* 10*/\t'      return;',\n\t\t/* 11*/\t'    }',\n\t\t/* 12*/\t'  }',\n\t\t/* 13*/\t'}'];\n\n\t\tconst textModel = createTextModel(lines.join('\\n'));\n\t\ttry {\n\t\t\tconst actual = computeRanges(textModel, false, markers);\n\t\t\t// let r0 = r(1, 2);\n\t\t\t// let r1 = r(3, 12);\n\t\t\t// let r2 = r(4, 11);\n\t\t\t// let r3 = r(5, 6);\n\t\t\t// let r4 = r(9, 10);\n\n\t\t\tassert.strictEqual(actual.findRange(1), 0, '1');\n\t\t\tassert.strictEqual(actual.findRange(2), 0, '2');\n\t\t\tassert.strictEqual(actual.findRange(3), 1, '3');\n\t\t\tassert.strictEqual(actual.findRange(4), 2, '4');\n\t\t\tassert.strictEqual(actual.findRange(5), 3, '5');\n\t\t\tassert.strictEqual(actual.findRange(6), 3, '6');\n\t\t\tassert.strictEqual(actual.findRange(7), 2, '7');\n\t\t\tassert.strictEqual(actual.findRange(8), 2, '8');\n\t\t\tassert.strictEqual(actual.findRange(9), 4, '9');\n\t\t\tassert.strictEqual(actual.findRange(10), 4, '10');\n\t\t\tassert.strictEqual(actual.findRange(11), 2, '11');\n\t\t\tassert.strictEqual(actual.findRange(12), 1, '12');\n\t\t\tassert.strictEqual(actual.findRange(13), -1, '13');\n\t\t} finally {\n\t\t\ttextModel.dispose();\n\t\t}\n\n\n\t});\n\n\ttest('setCollapsed', () => {\n\t\tconst lines: string[] = [];\n\t\tconst nRegions = 500;\n\t\tfor (let i = 0; i < nRegions; i++) {\n\t\t\tlines.push('#region');\n\t\t}\n\t\tfor (let i = 0; i < nRegions; i++) {\n\t\t\tlines.push('#endregion');\n\t\t}\n\t\tconst model = createTextModel(lines.join('\\n'));\n\t\tconst actual = computeRanges(model, false, markers);\n\t\tassert.strictEqual(actual.length, nRegions, 'len');\n\t\tfor (let i = 0; i < nRegions; i++) {\n\t\t\tactual.setCollapsed(i, i % 3 === 0);\n\t\t}\n\t\tfor (let i = 0; i < nRegions; i++) {\n\t\t\tassert.strictEqual(actual.isCollapsed(i), i % 3 === 0, 'line' + i);\n\t\t}\n\t\tmodel.dispose();\n\t});\n\n\ttest('sanitizeAndMerge1', () => {\n\t\tconst regionSet1: FoldRange[] = [\n\t\t\tfoldRange(0, 100),\t\t\t// invalid, should be removed\n\t\t\tfoldRange(1, 100, false, FoldSource.provider, 'A'),\t\t// valid\n\t\t\tfoldRange(1, 100, false, FoldSource.provider, 'Z'),\t\t// invalid, duplicate start\n\t\t\tfoldRange(10, 10, false),\t\t\t\t\t\t// invalid, should be removed\n\t\t\tfoldRange(20, 80, false, FoldSource.provider, 'C1'),\t\t// valid inside 'B'\n\t\t\tfoldRange(22, 80, true, FoldSource.provider, 'D1'),\t\t// valid inside 'C1'\n\t\t\tfoldRange(90, 101),\t\t\t\t\t\t\t\t// invalid, should be removed\n\t\t];\n\t\tconst regionSet2: FoldRange[] = [\n\t\t\tfoldRange(20, 80, true),\t\t\t    \t\t// should merge with C1\n\t\t\tfoldRange(18, 80, true),\t\t\t\t\t\t// invalid, out of order\n\t\t\tfoldRange(21, 81, true, FoldSource.provider, 'Z'),\t\t// invalid, overlapping\n\t\t\tfoldRange(22, 80, true, FoldSource.provider, 'D2'),\t\t// should merge with D1\n\t\t];\n\t\tconst result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);\n\t\tassert.strictEqual(result.length, 3, 'result length1');\n\t\tassertEqualRanges(result[0], foldRange(1, 100, false, FoldSource.provider, 'A'), 'A1');\n\t\tassertEqualRanges(result[1], foldRange(20, 80, true, FoldSource.provider, 'C1'), 'C1');\n\t\tassertEqualRanges(result[2], foldRange(22, 80, true, FoldSource.provider, 'D1'), 'D1');\n\t});\n\n\ttest('sanitizeAndMerge2', () => {\n\t\tconst regionSet1: FoldRange[] = [\n\t\t\tfoldRange(1, 100, false, FoldSource.provider, 'a1'),\t\t\t// valid\n\t\t\tfoldRange(2, 100, false, FoldSource.provider, 'a2'),\t\t\t// valid\n\t\t\tfoldRange(3, 19, false, FoldSource.provider, 'a3'),\t\t\t// valid\n\t\t\tfoldRange(20, 71, false, FoldSource.provider, 'a4'),\t\t\t// overlaps b3\n\t\t\tfoldRange(21, 29, false, FoldSource.provider, 'a5'),\t\t\t// valid\n\t\t\tfoldRange(81, 91, false, FoldSource.provider, 'a6'),\t\t\t// overlaps b4\n\t\t];\n\t\tconst regionSet2: FoldRange[] = [\n\t\t\tfoldRange(30, 39, true, FoldSource.provider, 'b1'),\t\t\t// valid, will be recovered\n\t\t\tfoldRange(40, 49, true, FoldSource.userDefined, 'b2'),\t// valid\n\t\t\tfoldRange(50, 100, true, FoldSource.userDefined, 'b3'),\t// overlaps a4\n\t\t\tfoldRange(80, 90, true, FoldSource.userDefined, 'b4'),\t// overlaps a6\n\t\t\tfoldRange(92, 100, true, FoldSource.userDefined, 'b5'),\t// valid\n\t\t];\n\t\tconst result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);\n\t\tassert.strictEqual(result.length, 9, 'result length1');\n\t\tassertEqualRanges(result[0], foldRange(1, 100, false, FoldSource.provider, 'a1'), 'P1');\n\t\tassertEqualRanges(result[1], foldRange(2, 100, false, FoldSource.provider, 'a2'), 'P2');\n\t\tassertEqualRanges(result[2], foldRange(3, 19, false, FoldSource.provider, 'a3'), 'P3');\n\t\tassertEqualRanges(result[3], foldRange(21, 29, false, FoldSource.provider, 'a5'), 'P4');\n\t\tassertEqualRanges(result[4], foldRange(30, 39, true, FoldSource.recovered, 'b1'), 'P5');\n\t\tassertEqualRanges(result[5], foldRange(40, 49, true, FoldSource.userDefined, 'b2'), 'P6');\n\t\tassertEqualRanges(result[6], foldRange(50, 100, true, FoldSource.userDefined, 'b3'), 'P7');\n\t\tassertEqualRanges(result[7], foldRange(80, 90, true, FoldSource.userDefined, 'b4'), 'P8');\n\t\tassertEqualRanges(result[8], foldRange(92, 100, true, FoldSource.userDefined, 'b5'), 'P9');\n\t});\n\n\ttest('sanitizeAndMerge3', () => {\n\t\tconst regionSet1: FoldRange[] = [\n\t\t\tfoldRange(1, 100, false, FoldSource.provider, 'a1'),\t\t\t// valid\n\t\t\tfoldRange(10, 29, false, FoldSource.provider, 'a2'),\t\t\t// matches manual hidden\n\t\t\tfoldRange(35, 39, true, FoldSource.recovered, 'a3'),\t\t// valid\n\t\t];\n\t\tconst regionSet2: FoldRange[] = [\n\t\t\tfoldRange(10, 29, true, FoldSource.recovered, 'b1'),\t\t// matches a\n\t\t\tfoldRange(20, 28, true, FoldSource.provider, 'b2'),\t\t\t// should remain\n\t\t\tfoldRange(30, 39, true, FoldSource.recovered, 'b3'),\t\t// should remain\n\t\t];\n\t\tconst result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);\n\t\tassert.strictEqual(result.length, 5, 'result length3');\n\t\tassertEqualRanges(result[0], foldRange(1, 100, false, FoldSource.provider, 'a1'), 'R1');\n\t\tassertEqualRanges(result[1], foldRange(10, 29, true, FoldSource.provider, 'a2'), 'R2');\n\t\tassertEqualRanges(result[2], foldRange(20, 28, true, FoldSource.recovered, 'b2'), 'R3');\n\t\tassertEqualRanges(result[3], foldRange(30, 39, true, FoldSource.recovered, 'b3'), 'R3');\n\t\tassertEqualRanges(result[4], foldRange(35, 39, true, FoldSource.recovered, 'a3'), 'R4');\n\t});\n\n\ttest('sanitizeAndMerge4', () => {\n\t\tconst regionSet1: FoldRange[] = [\n\t\t\tfoldRange(1, 100, false, FoldSource.provider, 'a1'),\t\t\t// valid\n\t\t];\n\t\tconst regionSet2: FoldRange[] = [\n\t\t\tfoldRange(20, 28, true, FoldSource.provider, 'b1'),\t\t\t// hidden\n\t\t\tfoldRange(30, 38, true, FoldSource.provider, 'b2'),\t\t\t// hidden\n\t\t];\n\t\tconst result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);\n\t\tassert.strictEqual(result.length, 3, 'result length4');\n\t\tassertEqualRanges(result[0], foldRange(1, 100, false, FoldSource.provider, 'a1'), 'R1');\n\t\tassertEqualRanges(result[1], foldRange(20, 28, true, FoldSource.recovered, 'b1'), 'R2');\n\t\tassertEqualRanges(result[2], foldRange(30, 38, true, FoldSource.recovered, 'b2'), 'R3');\n\t});\n\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { FoldingMarkers } from '../../../../common/languages/languageConfiguration.js';\nimport { MAX_FOLDING_REGIONS, FoldRange, FoldingRegions, FoldSource } from '../../browser/foldingRanges.js';\nimport { RangesCollector, computeRanges } from '../../browser/indentRangeProvider.js';\nimport { createTextModel } from '../../../../test/common/testTextModel.js';\n\nconst markers: FoldingMarkers = {\n\tstart: /^#region$/,\n\tend: /^#endregion$/\n};\n\nsuite('FoldingRanges', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\tconst foldRange = (from: number, to: number, collapsed: boolean | undefined = undefined, source: FoldSource = FoldSource.provider, type: string | undefined = undefined) =>\n\t\t<FoldRange>{\n\t\t\tstartLineNumber: from,\n\t\t\tendLineNumber: to,\n\t\t\ttype: type,\n\t\t\tisCollapsed: collapsed || false,\n\t\t\tsource\n\t\t};\n\tconst assertEqualRanges = (range1: FoldRange, range2: FoldRange, msg: string) => {\n\t\tassert.strictEqual(range1.startLineNumber, range2.startLineNumber, msg + ' start');\n\t\tassert.strictEqual(range1.endLineNumber, range2.endLineNumber, msg + ' end');\n\t\tassert.strictEqual(range1.type, range2.type, msg + ' type');\n\t\tassert.strictEqual(range1.isCollapsed, range2.isCollapsed, msg + ' collapsed');\n\t\tassert.strictEqual(range1.source, range2.source, msg + ' source');\n\t};\n\n\ttest('test max folding regions', () => {\n\t\tconst lines: string[] = [];\n\t\tconst nRegions = MAX_FOLDING_REGIONS;\n\t\tconst collector = new RangesCollector({ limit: MAX_FOLDING_REGIONS, update: () => { } });\n\t\tfor (let i = 0; i < nRegions; i++) {\n\t\t\tconst startLineNumber = lines.length;\n\t\t\tlines.push('#region');\n\t\t\tconst endLineNumber = lines.length;\n\t\t\tlines.push('#endregion');\n\t\t\tcollector.insertFirst(startLineNumber, endLineNumber, 0);\n\t\t}\n\t\tconst model = createTextModel(lines.join('\\n'));\n\t\tconst actual = collector.toIndentRanges(model);\n\t\tassert.strictEqual(actual.length, nRegions, 'len');\n\t\tmodel.dispose();\n\n\t});\n\n\ttest('findRange', () => {\n\t\tconst lines = [\n\t\t/* 1*/\t'#region',\n\t\t/* 2*/\t'#endregion',\n\t\t/* 3*/\t'class A {',\n\t\t/* 4*/\t'  void foo() {',\n\t\t/* 5*/\t'    if (true) {',\n\t\t/* 6*/\t'        return;',\n\t\t/* 7*/\t'    }',\n\t\t/* 8*/\t'',\n\t\t/* 9*/\t'    if (true) {',\n\t\t/* 10*/\t'      return;',\n\t\t/* 11*/\t'    }',\n\t\t/* 12*/\t'  }',\n\t\t/* 13*/\t'}'];\n\n\t\tconst textModel = createTextModel(lines.join('\\n'));\n\t\ttry {\n\t\t\tconst actual = computeRanges(textModel, false, markers);\n\t\t\t// let r0 = r(1, 2);\n\t\t\t// let r1 = r(3, 12);\n\t\t\t// let r2 = r(4, 11);\n\t\t\t// let r3 = r(5, 6);\n\t\t\t// let r4 = r(9, 10);\n\n\t\t\tassert.strictEqual(actual.findRange(1), 0, '1');\n\t\t\tassert.strictEqual(actual.findRange(2), 0, '2');\n\t\t\tassert.strictEqual(actual.findRange(3), 1, '3');\n\t\t\tassert.strictEqual(actual.findRange(4), 2, '4');\n\t\t\tassert.strictEqual(actual.findRange(5), 3, '5');\n\t\t\tassert.strictEqual(actual.findRange(6), 3, '6');\n\t\t\tassert.strictEqual(actual.findRange(7), 2, '7');\n\t\t\tassert.strictEqual(actual.findRange(8), 2, '8');\n\t\t\tassert.strictEqual(actual.findRange(9), 4, '9');\n\t\t\tassert.strictEqual(actual.findRange(10), 4, '10');\n\t\t\tassert.strictEqual(actual.findRange(11), 2, '11');\n\t\t\tassert.strictEqual(actual.findRange(12), 1, '12');\n\t\t\tassert.strictEqual(actual.findRange(13), -1, '13');\n\t\t} finally {\n\t\t\ttextModel.dispose();\n\t\t}\n\n\n\t});\n\n\ttest('setCollapsed', () => {\n\t\tconst lines: string[] = [];\n\t\tconst nRegions = 500;\n\t\tfor (let i = 0; i < nRegions; i++) {\n\t\t\tlines.push('#region');\n\t\t}\n\t\tfor (let i = 0; i < nRegions; i++) {\n\t\t\tlines.push('#endregion');\n\t\t}\n\t\tconst model = createTextModel(lines.join('\\n'));\n\t\tconst actual = computeRanges(model, false, markers);\n\t\tassert.strictEqual(actual.length, nRegions, 'len');\n\t\tfor (let i = 0; i < nRegions; i++) {\n\t\t\tactual.setCollapsed(i, i % 3 === 0);\n\t\t}\n\t\tfor (let i = 0; i < nRegions; i++) {\n\t\t\tassert.strictEqual(actual.isCollapsed(i), i % 3 === 0, 'line' + i);\n\t\t}\n\t\tmodel.dispose();\n\t});\n\n\ttest('sanitizeAndMerge1', () => {\n\t\tconst regionSet1: FoldRange[] = [\n\t\t\tfoldRange(0, 100),\t\t\t// invalid, should be removed\n\t\t\tfoldRange(1, 100, false, FoldSource.provider, 'A'),\t\t// valid\n\t\t\tfoldRange(1, 100, false, FoldSource.provider, 'Z'),\t\t// invalid, duplicate start\n\t\t\tfoldRange(10, 10, false),\t\t\t\t\t\t// invalid, should be removed\n\t\t\tfoldRange(20, 80, false, FoldSource.provider, 'C1'),\t\t// valid inside 'B'\n\t\t\tfoldRange(22, 80, true, FoldSource.provider, 'D1'),\t\t// valid inside 'C1'\n\t\t\tfoldRange(90, 101),\t\t\t\t\t\t\t\t// invalid, should be removed\n\t\t];\n\t\tconst regionSet2: FoldRange[] = [\n\t\t\tfoldRange(20, 80, true),\t\t\t    \t\t// should merge with C1\n\t\t\tfoldRange(18, 80, true),\t\t\t\t\t\t// invalid, out of order\n\t\t\tfoldRange(21, 81, true, FoldSource.provider, 'Z'),\t\t// invalid, overlapping\n\t\t\tfoldRange(22, 80, true, FoldSource.provider, 'D2'),\t\t// should merge with D1\n\t\t];\n\t\tconst result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);\n\t\tassert.strictEqual(result.length, 3, 'result length1');\n\t\tassertEqualRanges(result[0], foldRange(1, 100, false, FoldSource.provider, 'A'), 'A1');\n\t\tassertEqualRanges(result[1], foldRange(20, 80, true, FoldSource.provider, 'C1'), 'C1');\n\t\tassertEqualRanges(result[2], foldRange(22, 80, true, FoldSource.provider, 'D1'), 'D1');\n\t});\n\n\ttest('sanitizeAndMerge2', () => {\n\t\tconst regionSet1: FoldRange[] = [\n\t\t\tfoldRange(1, 100, false, FoldSource.provider, 'a1'),\t\t\t// valid\n\t\t\tfoldRange(2, 100, false, FoldSource.provider, 'a2'),\t\t\t// valid\n\t\t\tfoldRange(3, 19, false, FoldSource.provider, 'a3'),\t\t\t// valid\n\t\t\tfoldRange(20, 71, false, FoldSource.provider, 'a4'),\t\t\t// overlaps b3\n\t\t\tfoldRange(21, 29, false, FoldSource.provider, 'a5'),\t\t\t// valid\n\t\t\tfoldRange(81, 91, false, FoldSource.provider, 'a6'),\t\t\t// overlaps b4\n\t\t];\n\t\tconst regionSet2: FoldRange[] = [\n\t\t\tfoldRange(30, 39, true, FoldSource.provider, 'b1'),\t\t\t// valid, will be recovered\n\t\t\tfoldRange(40, 49, true, FoldSource.userDefined, 'b2'),\t// valid\n\t\t\tfoldRange(50, 100, true, FoldSource.userDefined, 'b3'),\t// overlaps a4\n\t\t\tfoldRange(80, 90, true, FoldSource.userDefined, 'b4'),\t// overlaps a6\n\t\t\tfoldRange(92, 100, true, FoldSource.userDefined, 'b5'),\t// valid\n\t\t];\n\t\tconst result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);\n\t\tassert.strictEqual(result.length, 9, 'result length1');\n\t\tassertEqualRanges(result[0], foldRange(1, 100, false, FoldSource.provider, 'a1'), 'P1');\n\t\tassertEqualRanges(result[1], foldRange(2, 100, false, FoldSource.provider, 'a2'), 'P2');\n\t\tassertEqualRanges(result[2], foldRange(3, 19, false, FoldSource.provider, 'a3'), 'P3');\n\t\tassertEqualRanges(result[3], foldRange(21, 29, false, FoldSource.provider, 'a5'), 'P4');\n\t\tassertEqualRanges(result[4], foldRange(30, 39, true, FoldSource.recovered, 'b1'), 'P5');\n\t\tassertEqualRanges(result[5], foldRange(40, 49, true, FoldSource.userDefined, 'b2'), 'P6');\n\t\tassertEqualRanges(result[6], foldRange(50, 100, true, FoldSource.userDefined, 'b3'), 'P7');\n\t\tassertEqualRanges(result[7], foldRange(80, 90, true, FoldSource.userDefined, 'b4'), 'P8');\n\t\tassertEqualRanges(result[8], foldRange(92, 100, true, FoldSource.userDefined, 'b5'), 'P9');\n\t});\n\n\ttest('sanitizeAndMerge3', () => {\n\t\tconst regionSet1: FoldRange[] = [\n\t\t\tfoldRange(1, 100, false, FoldSource.provider, 'a1'),\t\t\t// valid\n\t\t\tfoldRange(10, 29, false, FoldSource.provider, 'a2'),\t\t\t// matches manual hidden\n\t\t\tfoldRange(35, 39, true, FoldSource.recovered, 'a3'),\t\t// valid\n\t\t];\n\t\tconst regionSet2: FoldRange[] = [\n\t\t\tfoldRange(10, 29, true, FoldSource.recovered, 'b1'),\t\t// matches a\n\t\t\tfoldRange(20, 28, true, FoldSource.provider, 'b2'),\t\t\t// should remain\n\t\t\tfoldRange(30, 39, true, FoldSource.recovered, 'b3'),\t\t// should remain\n\t\t];\n\t\tconst result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);\n\t\tassert.strictEqual(result.length, 5, 'result length3');\n\t\tassertEqualRanges(result[0], foldRange(1, 100, false, FoldSource.provider, 'a1'), 'R1');\n\t\tassertEqualRanges(result[1], foldRange(10, 29, true, FoldSource.provider, 'a2'), 'R2');\n\t\tassertEqualRanges(result[2], foldRange(20, 28, true, FoldSource.recovered, 'b2'), 'R3');\n\t\tassertEqualRanges(result[3], foldRange(30, 39, true, FoldSource.recovered, 'b3'), 'R3');\n\t\tassertEqualRanges(result[4], foldRange(35, 39, true, FoldSource.recovered, 'a3'), 'R4');\n\t});\n\n\ttest('sanitizeAndMerge4', () => {\n\t\tconst regionSet1: FoldRange[] = [\n\t\t\tfoldRange(1, 100, false, FoldSource.provider, 'a1'),\t\t\t// valid\n\t\t];\n\t\tconst regionSet2: FoldRange[] = [\n\t\t\tfoldRange(20, 28, true, FoldSource.provider, 'b1'),\t\t\t// hidden\n\t\t\tfoldRange(30, 38, true, FoldSource.provider, 'b2'),\t\t\t// hidden\n\t\t];\n\t\tconst result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);\n\t\tassert.strictEqual(result.length, 3, 'result length4');\n\t\tassertEqualRanges(result[0], foldRange(1, 100, false, FoldSource.provider, 'a1'), 'R1');\n\t\tassertEqualRanges(result[1], foldRange(20, 28, true, FoldSource.recovered, 'b1'), 'R2');\n\t\tassertEqualRanges(result[2], foldRange(30, 38, true, FoldSource.recovered, 'b2'), 'R3');\n\t});\n\n});\n"]}