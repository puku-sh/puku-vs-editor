{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/editor/contrib/find/test/browser/replacePattern.test.ts","vs/editor/contrib/find/test/browser/replacePattern.test.ts"],"names":[],"mappings":"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","file":"replacePattern.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { buildReplaceStringWithCasePreserved } from '../../../../../base/common/search.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { parseReplaceString, ReplacePattern, ReplacePiece } from '../../browser/replacePattern.js';\n\nsuite('Replace Pattern test', () => {\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('parse replace string', () => {\n\t\tconst testParse = (input: string, expectedPieces: ReplacePiece[]) => {\n\t\t\tconst actual = parseReplaceString(input);\n\t\t\tconst expected = new ReplacePattern(expectedPieces);\n\t\t\tassert.deepStrictEqual(actual, expected, 'Parsing ' + input);\n\t\t};\n\n\t\t// no backslash => no treatment\n\t\ttestParse('hello', [ReplacePiece.staticValue('hello')]);\n\n\t\t// \\t => TAB\n\t\ttestParse('\\\\thello', [ReplacePiece.staticValue('\\thello')]);\n\t\ttestParse('h\\\\tello', [ReplacePiece.staticValue('h\\tello')]);\n\t\ttestParse('hello\\\\t', [ReplacePiece.staticValue('hello\\t')]);\n\n\t\t// \\n => LF\n\t\ttestParse('\\\\nhello', [ReplacePiece.staticValue('\\nhello')]);\n\n\t\t// \\\\t => \\t\n\t\ttestParse('\\\\\\\\thello', [ReplacePiece.staticValue('\\\\thello')]);\n\t\ttestParse('h\\\\\\\\tello', [ReplacePiece.staticValue('h\\\\tello')]);\n\t\ttestParse('hello\\\\\\\\t', [ReplacePiece.staticValue('hello\\\\t')]);\n\n\t\t// \\\\\\t => \\TAB\n\t\ttestParse('\\\\\\\\\\\\thello', [ReplacePiece.staticValue('\\\\\\thello')]);\n\n\t\t// \\\\\\\\t => \\\\t\n\t\ttestParse('\\\\\\\\\\\\\\\\thello', [ReplacePiece.staticValue('\\\\\\\\thello')]);\n\n\t\t// \\ at the end => no treatment\n\t\ttestParse('hello\\\\', [ReplacePiece.staticValue('hello\\\\')]);\n\n\t\t// \\ with unknown char => no treatment\n\t\ttestParse('hello\\\\x', [ReplacePiece.staticValue('hello\\\\x')]);\n\n\t\t// \\ with back reference => no treatment\n\t\ttestParse('hello\\\\0', [ReplacePiece.staticValue('hello\\\\0')]);\n\n\t\ttestParse('hello$&', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(0)]);\n\t\ttestParse('hello$0', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(0)]);\n\t\ttestParse('hello$02', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(0), ReplacePiece.staticValue('2')]);\n\t\ttestParse('hello$1', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(1)]);\n\t\ttestParse('hello$2', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(2)]);\n\t\ttestParse('hello$9', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(9)]);\n\t\ttestParse('$9hello', [ReplacePiece.matchIndex(9), ReplacePiece.staticValue('hello')]);\n\n\t\ttestParse('hello$12', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(12)]);\n\t\ttestParse('hello$99', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(99)]);\n\t\ttestParse('hello$99a', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(99), ReplacePiece.staticValue('a')]);\n\t\ttestParse('hello$1a', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(1), ReplacePiece.staticValue('a')]);\n\t\ttestParse('hello$100', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(10), ReplacePiece.staticValue('0')]);\n\t\ttestParse('hello$100a', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(10), ReplacePiece.staticValue('0a')]);\n\t\ttestParse('hello$10a0', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(10), ReplacePiece.staticValue('a0')]);\n\t\ttestParse('hello$$', [ReplacePiece.staticValue('hello$')]);\n\t\ttestParse('hello$$0', [ReplacePiece.staticValue('hello$0')]);\n\n\t\ttestParse('hello$`', [ReplacePiece.staticValue('hello$`')]);\n\t\ttestParse('hello$\\'', [ReplacePiece.staticValue('hello$\\'')]);\n\t});\n\n\ttest('parse replace string with case modifiers', () => {\n\t\tconst testParse = (input: string, expectedPieces: ReplacePiece[]) => {\n\t\t\tconst actual = parseReplaceString(input);\n\t\t\tconst expected = new ReplacePattern(expectedPieces);\n\t\t\tassert.deepStrictEqual(actual, expected, 'Parsing ' + input);\n\t\t};\n\t\tfunction assertReplace(target: string, search: RegExp, replaceString: string, expected: string): void {\n\t\t\tconst replacePattern = parseReplaceString(replaceString);\n\t\t\tconst m = search.exec(target);\n\t\t\tconst actual = replacePattern.buildReplaceString(m);\n\n\t\t\tassert.strictEqual(actual, expected, `${target}.replace(${search}, ${replaceString}) === ${expected}`);\n\t\t}\n\n\t\t// \\U, \\u => uppercase  \\L, \\l => lowercase  \\E => cancel\n\n\t\ttestParse('hello\\\\U$1', [ReplacePiece.staticValue('hello'), ReplacePiece.caseOps(1, ['U'])]);\n\t\tassertReplace('func privateFunc(', /func (\\w+)\\(/, 'func \\\\U$1(', 'func PRIVATEFUNC(');\n\n\t\ttestParse('hello\\\\u$1', [ReplacePiece.staticValue('hello'), ReplacePiece.caseOps(1, ['u'])]);\n\t\tassertReplace('func privateFunc(', /func (\\w+)\\(/, 'func \\\\u$1(', 'func PrivateFunc(');\n\n\t\ttestParse('hello\\\\L$1', [ReplacePiece.staticValue('hello'), ReplacePiece.caseOps(1, ['L'])]);\n\t\tassertReplace('func privateFunc(', /func (\\w+)\\(/, 'func \\\\L$1(', 'func privatefunc(');\n\n\t\ttestParse('hello\\\\l$1', [ReplacePiece.staticValue('hello'), ReplacePiece.caseOps(1, ['l'])]);\n\t\tassertReplace('func PrivateFunc(', /func (\\w+)\\(/, 'func \\\\l$1(', 'func privateFunc(');\n\n\t\ttestParse('hello$1\\\\u\\\\u\\\\U$4goodbye', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(1), ReplacePiece.caseOps(4, ['u', 'u', 'U']), ReplacePiece.staticValue('goodbye')]);\n\t\tassertReplace('hellogooDbye', /hello(\\w+)/, 'hello\\\\u\\\\u\\\\l\\\\l\\\\U$1', 'helloGOodBYE');\n\t});\n\n\ttest('replace has JavaScript semantics', () => {\n\t\tconst testJSReplaceSemantics = (target: string, search: RegExp, replaceString: string, expected: string) => {\n\t\t\tconst replacePattern = parseReplaceString(replaceString);\n\t\t\tconst m = search.exec(target);\n\t\t\tconst actual = replacePattern.buildReplaceString(m);\n\n\t\t\tassert.deepStrictEqual(actual, expected, `${target}.replace(${search}, ${replaceString})`);\n\t\t};\n\n\t\ttestJSReplaceSemantics('hi', /hi/, 'hello', 'hi'.replace(/hi/, 'hello'));\n\t\ttestJSReplaceSemantics('hi', /hi/, '\\\\t', 'hi'.replace(/hi/, '\\t'));\n\t\ttestJSReplaceSemantics('hi', /hi/, '\\\\n', 'hi'.replace(/hi/, '\\n'));\n\t\ttestJSReplaceSemantics('hi', /hi/, '\\\\\\\\t', 'hi'.replace(/hi/, '\\\\t'));\n\t\ttestJSReplaceSemantics('hi', /hi/, '\\\\\\\\n', 'hi'.replace(/hi/, '\\\\n'));\n\n\t\t// implicit capture group 0\n\t\ttestJSReplaceSemantics('hi', /hi/, 'hello$&', 'hi'.replace(/hi/, 'hello$&'));\n\t\ttestJSReplaceSemantics('hi', /hi/, 'hello$0', 'hi'.replace(/hi/, 'hello$&'));\n\t\ttestJSReplaceSemantics('hi', /hi/, 'hello$&1', 'hi'.replace(/hi/, 'hello$&1'));\n\t\ttestJSReplaceSemantics('hi', /hi/, 'hello$01', 'hi'.replace(/hi/, 'hello$&1'));\n\n\t\t// capture groups have funny semantics in replace strings\n\t\t// the replace string interprets $nn as a captured group only if it exists in the search regex\n\t\ttestJSReplaceSemantics('hi', /(hi)/, 'hello$10', 'hi'.replace(/(hi)/, 'hello$10'));\n\t\ttestJSReplaceSemantics('hi', /(hi)()()()()()()()()()/, 'hello$10', 'hi'.replace(/(hi)()()()()()()()()()/, 'hello$10'));\n\t\ttestJSReplaceSemantics('hi', /(hi)/, 'hello$100', 'hi'.replace(/(hi)/, 'hello$100'));\n\t\ttestJSReplaceSemantics('hi', /(hi)/, 'hello$20', 'hi'.replace(/(hi)/, 'hello$20'));\n\t});\n\n\ttest('get replace string if given text is a complete match', () => {\n\t\tfunction assertReplace(target: string, search: RegExp, replaceString: string, expected: string): void {\n\t\t\tconst replacePattern = parseReplaceString(replaceString);\n\t\t\tconst m = search.exec(target);\n\t\t\tconst actual = replacePattern.buildReplaceString(m);\n\n\t\t\tassert.strictEqual(actual, expected, `${target}.replace(${search}, ${replaceString}) === ${expected}`);\n\t\t}\n\n\t\tassertReplace('bla', /bla/, 'hello', 'hello');\n\t\tassertReplace('bla', /(bla)/, 'hello', 'hello');\n\t\tassertReplace('bla', /(bla)/, 'hello$0', 'hellobla');\n\n\t\tconst searchRegex = /let\\s+(\\w+)\\s*=\\s*require\\s*\\(\\s*['\"]([\\w\\.\\-/]+)\\s*['\"]\\s*\\)\\s*/;\n\t\tassertReplace('let fs = require(\\'fs\\')', searchRegex, 'import * as $1 from \\'$2\\';', 'import * as fs from \\'fs\\';');\n\t\tassertReplace('let something = require(\\'fs\\')', searchRegex, 'import * as $1 from \\'$2\\';', 'import * as something from \\'fs\\';');\n\t\tassertReplace('let something = require(\\'fs\\')', searchRegex, 'import * as $1 from \\'$1\\';', 'import * as something from \\'something\\';');\n\t\tassertReplace('let something = require(\\'fs\\')', searchRegex, 'import * as $2 from \\'$1\\';', 'import * as fs from \\'something\\';');\n\t\tassertReplace('let something = require(\\'fs\\')', searchRegex, 'import * as $0 from \\'$0\\';', 'import * as let something = require(\\'fs\\') from \\'let something = require(\\'fs\\')\\';');\n\t\tassertReplace('let fs = require(\\'fs\\')', searchRegex, 'import * as $1 from \\'$2\\';', 'import * as fs from \\'fs\\';');\n\t\tassertReplace('for ()', /for(.*)/, 'cat$1', 'cat ()');\n\n\t\t// issue #18111\n\t\tassertReplace('HRESULT OnAmbientPropertyChange(DISPID   dispid);', /\\b\\s{3}\\b/, ' ', ' ');\n\t});\n\n\ttest('get replace string if match is sub-string of the text', () => {\n\t\tfunction assertReplace(target: string, search: RegExp, replaceString: string, expected: string): void {\n\t\t\tconst replacePattern = parseReplaceString(replaceString);\n\t\t\tconst m = search.exec(target);\n\t\t\tconst actual = replacePattern.buildReplaceString(m);\n\n\t\t\tassert.strictEqual(actual, expected, `${target}.replace(${search}, ${replaceString}) === ${expected}`);\n\t\t}\n\t\tassertReplace('this is a bla text', /bla/, 'hello', 'hello');\n\t\tassertReplace('this is a bla text', /this(?=.*bla)/, 'that', 'that');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$1at', 'that');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$1e', 'the');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$1ere', 'there');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$1', 'th');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, 'ma$1', 'math');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, 'ma$1s', 'maths');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$0', 'this');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$0$1', 'thisth');\n\t\tassertReplace('this is a bla text', /bla(?=\\stext$)/, 'foo', 'foo');\n\t\tassertReplace('this is a bla text', /b(la)(?=\\stext$)/, 'f$1', 'fla');\n\t\tassertReplace('this is a bla text', /b(la)(?=\\stext$)/, 'f$0', 'fbla');\n\t\tassertReplace('this is a bla text', /b(la)(?=\\stext$)/, '$0ah', 'blaah');\n\t});\n\n\ttest('issue #19740 Find and replace capture group/backreference inserts `undefined` instead of empty string', () => {\n\t\tconst replacePattern = parseReplaceString('a{$1}');\n\t\tconst matches = /a(z)?/.exec('abcd');\n\t\tconst actual = replacePattern.buildReplaceString(matches);\n\t\tassert.strictEqual(actual, 'a{}');\n\t});\n\n\ttest('buildReplaceStringWithCasePreserved test', () => {\n\t\tfunction assertReplace(target: string[], replaceString: string, expected: string): void {\n\t\t\tlet actual: string = '';\n\t\t\tactual = buildReplaceStringWithCasePreserved(target, replaceString);\n\t\t\tassert.strictEqual(actual, expected);\n\t\t}\n\n\t\tassertReplace(['abc'], 'Def', 'def');\n\t\tassertReplace(['Abc'], 'Def', 'Def');\n\t\tassertReplace(['ABC'], 'Def', 'DEF');\n\t\tassertReplace(['abc', 'Abc'], 'Def', 'def');\n\t\tassertReplace(['Abc', 'abc'], 'Def', 'Def');\n\t\tassertReplace(['ABC', 'abc'], 'Def', 'DEF');\n\t\tassertReplace(['aBc', 'abc'], 'Def', 'def');\n\t\tassertReplace(['AbC'], 'Def', 'Def');\n\t\tassertReplace(['aBC'], 'Def', 'def');\n\t\tassertReplace(['aBc'], 'DeF', 'deF');\n\t\tassertReplace(['Foo-Bar'], 'newfoo-newbar', 'Newfoo-Newbar');\n\t\tassertReplace(['Foo-Bar-Abc'], 'newfoo-newbar-newabc', 'Newfoo-Newbar-Newabc');\n\t\tassertReplace(['Foo-Bar-abc'], 'newfoo-newbar', 'Newfoo-newbar');\n\t\tassertReplace(['foo-Bar'], 'newfoo-newbar', 'newfoo-Newbar');\n\t\tassertReplace(['foo-BAR'], 'newfoo-newbar', 'newfoo-NEWBAR');\n\t\tassertReplace(['foO-BAR'], 'NewFoo-NewBar', 'newFoo-NEWBAR');\n\t\tassertReplace(['Foo_Bar'], 'newfoo_newbar', 'Newfoo_Newbar');\n\t\tassertReplace(['Foo_Bar_Abc'], 'newfoo_newbar_newabc', 'Newfoo_Newbar_Newabc');\n\t\tassertReplace(['Foo_Bar_abc'], 'newfoo_newbar', 'Newfoo_newbar');\n\t\tassertReplace(['Foo_Bar-abc'], 'newfoo_newbar-abc', 'Newfoo_newbar-abc');\n\t\tassertReplace(['foo_Bar'], 'newfoo_newbar', 'newfoo_Newbar');\n\t\tassertReplace(['Foo_BAR'], 'newfoo_newbar', 'Newfoo_NEWBAR');\n\t});\n\n\ttest('preserve case', () => {\n\t\tfunction assertReplace(target: string[], replaceString: string, expected: string): void {\n\t\t\tconst replacePattern = parseReplaceString(replaceString);\n\t\t\tconst actual = replacePattern.buildReplaceString(target, true);\n\t\t\tassert.strictEqual(actual, expected);\n\t\t}\n\n\t\tassertReplace(['abc'], 'Def', 'def');\n\t\tassertReplace(['Abc'], 'Def', 'Def');\n\t\tassertReplace(['ABC'], 'Def', 'DEF');\n\t\tassertReplace(['abc', 'Abc'], 'Def', 'def');\n\t\tassertReplace(['Abc', 'abc'], 'Def', 'Def');\n\t\tassertReplace(['ABC', 'abc'], 'Def', 'DEF');\n\t\tassertReplace(['aBc', 'abc'], 'Def', 'def');\n\t\tassertReplace(['AbC'], 'Def', 'Def');\n\t\tassertReplace(['aBC'], 'Def', 'def');\n\t\tassertReplace(['aBc'], 'DeF', 'deF');\n\t\tassertReplace(['Foo-Bar'], 'newfoo-newbar', 'Newfoo-Newbar');\n\t\tassertReplace(['Foo-Bar-Abc'], 'newfoo-newbar-newabc', 'Newfoo-Newbar-Newabc');\n\t\tassertReplace(['Foo-Bar-abc'], 'newfoo-newbar', 'Newfoo-newbar');\n\t\tassertReplace(['foo-Bar'], 'newfoo-newbar', 'newfoo-Newbar');\n\t\tassertReplace(['foo-BAR'], 'newfoo-newbar', 'newfoo-NEWBAR');\n\t\tassertReplace(['foO-BAR'], 'NewFoo-NewBar', 'newFoo-NEWBAR');\n\t\tassertReplace(['Foo_Bar'], 'newfoo_newbar', 'Newfoo_Newbar');\n\t\tassertReplace(['Foo_Bar_Abc'], 'newfoo_newbar_newabc', 'Newfoo_Newbar_Newabc');\n\t\tassertReplace(['Foo_Bar_abc'], 'newfoo_newbar', 'Newfoo_newbar');\n\t\tassertReplace(['Foo_Bar-abc'], 'newfoo_newbar-abc', 'Newfoo_newbar-abc');\n\t\tassertReplace(['foo_Bar'], 'newfoo_newbar', 'newfoo_Newbar');\n\t\tassertReplace(['foo_BAR'], 'newfoo_newbar', 'newfoo_NEWBAR');\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { buildReplaceStringWithCasePreserved } from '../../../../../base/common/search.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { parseReplaceString, ReplacePattern, ReplacePiece } from '../../browser/replacePattern.js';\n\nsuite('Replace Pattern test', () => {\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('parse replace string', () => {\n\t\tconst testParse = (input: string, expectedPieces: ReplacePiece[]) => {\n\t\t\tconst actual = parseReplaceString(input);\n\t\t\tconst expected = new ReplacePattern(expectedPieces);\n\t\t\tassert.deepStrictEqual(actual, expected, 'Parsing ' + input);\n\t\t};\n\n\t\t// no backslash => no treatment\n\t\ttestParse('hello', [ReplacePiece.staticValue('hello')]);\n\n\t\t// \\t => TAB\n\t\ttestParse('\\\\thello', [ReplacePiece.staticValue('\\thello')]);\n\t\ttestParse('h\\\\tello', [ReplacePiece.staticValue('h\\tello')]);\n\t\ttestParse('hello\\\\t', [ReplacePiece.staticValue('hello\\t')]);\n\n\t\t// \\n => LF\n\t\ttestParse('\\\\nhello', [ReplacePiece.staticValue('\\nhello')]);\n\n\t\t// \\\\t => \\t\n\t\ttestParse('\\\\\\\\thello', [ReplacePiece.staticValue('\\\\thello')]);\n\t\ttestParse('h\\\\\\\\tello', [ReplacePiece.staticValue('h\\\\tello')]);\n\t\ttestParse('hello\\\\\\\\t', [ReplacePiece.staticValue('hello\\\\t')]);\n\n\t\t// \\\\\\t => \\TAB\n\t\ttestParse('\\\\\\\\\\\\thello', [ReplacePiece.staticValue('\\\\\\thello')]);\n\n\t\t// \\\\\\\\t => \\\\t\n\t\ttestParse('\\\\\\\\\\\\\\\\thello', [ReplacePiece.staticValue('\\\\\\\\thello')]);\n\n\t\t// \\ at the end => no treatment\n\t\ttestParse('hello\\\\', [ReplacePiece.staticValue('hello\\\\')]);\n\n\t\t// \\ with unknown char => no treatment\n\t\ttestParse('hello\\\\x', [ReplacePiece.staticValue('hello\\\\x')]);\n\n\t\t// \\ with back reference => no treatment\n\t\ttestParse('hello\\\\0', [ReplacePiece.staticValue('hello\\\\0')]);\n\n\t\ttestParse('hello$&', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(0)]);\n\t\ttestParse('hello$0', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(0)]);\n\t\ttestParse('hello$02', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(0), ReplacePiece.staticValue('2')]);\n\t\ttestParse('hello$1', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(1)]);\n\t\ttestParse('hello$2', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(2)]);\n\t\ttestParse('hello$9', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(9)]);\n\t\ttestParse('$9hello', [ReplacePiece.matchIndex(9), ReplacePiece.staticValue('hello')]);\n\n\t\ttestParse('hello$12', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(12)]);\n\t\ttestParse('hello$99', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(99)]);\n\t\ttestParse('hello$99a', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(99), ReplacePiece.staticValue('a')]);\n\t\ttestParse('hello$1a', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(1), ReplacePiece.staticValue('a')]);\n\t\ttestParse('hello$100', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(10), ReplacePiece.staticValue('0')]);\n\t\ttestParse('hello$100a', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(10), ReplacePiece.staticValue('0a')]);\n\t\ttestParse('hello$10a0', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(10), ReplacePiece.staticValue('a0')]);\n\t\ttestParse('hello$$', [ReplacePiece.staticValue('hello$')]);\n\t\ttestParse('hello$$0', [ReplacePiece.staticValue('hello$0')]);\n\n\t\ttestParse('hello$`', [ReplacePiece.staticValue('hello$`')]);\n\t\ttestParse('hello$\\'', [ReplacePiece.staticValue('hello$\\'')]);\n\t});\n\n\ttest('parse replace string with case modifiers', () => {\n\t\tconst testParse = (input: string, expectedPieces: ReplacePiece[]) => {\n\t\t\tconst actual = parseReplaceString(input);\n\t\t\tconst expected = new ReplacePattern(expectedPieces);\n\t\t\tassert.deepStrictEqual(actual, expected, 'Parsing ' + input);\n\t\t};\n\t\tfunction assertReplace(target: string, search: RegExp, replaceString: string, expected: string): void {\n\t\t\tconst replacePattern = parseReplaceString(replaceString);\n\t\t\tconst m = search.exec(target);\n\t\t\tconst actual = replacePattern.buildReplaceString(m);\n\n\t\t\tassert.strictEqual(actual, expected, `${target}.replace(${search}, ${replaceString}) === ${expected}`);\n\t\t}\n\n\t\t// \\U, \\u => uppercase  \\L, \\l => lowercase  \\E => cancel\n\n\t\ttestParse('hello\\\\U$1', [ReplacePiece.staticValue('hello'), ReplacePiece.caseOps(1, ['U'])]);\n\t\tassertReplace('func privateFunc(', /func (\\w+)\\(/, 'func \\\\U$1(', 'func PRIVATEFUNC(');\n\n\t\ttestParse('hello\\\\u$1', [ReplacePiece.staticValue('hello'), ReplacePiece.caseOps(1, ['u'])]);\n\t\tassertReplace('func privateFunc(', /func (\\w+)\\(/, 'func \\\\u$1(', 'func PrivateFunc(');\n\n\t\ttestParse('hello\\\\L$1', [ReplacePiece.staticValue('hello'), ReplacePiece.caseOps(1, ['L'])]);\n\t\tassertReplace('func privateFunc(', /func (\\w+)\\(/, 'func \\\\L$1(', 'func privatefunc(');\n\n\t\ttestParse('hello\\\\l$1', [ReplacePiece.staticValue('hello'), ReplacePiece.caseOps(1, ['l'])]);\n\t\tassertReplace('func PrivateFunc(', /func (\\w+)\\(/, 'func \\\\l$1(', 'func privateFunc(');\n\n\t\ttestParse('hello$1\\\\u\\\\u\\\\U$4goodbye', [ReplacePiece.staticValue('hello'), ReplacePiece.matchIndex(1), ReplacePiece.caseOps(4, ['u', 'u', 'U']), ReplacePiece.staticValue('goodbye')]);\n\t\tassertReplace('hellogooDbye', /hello(\\w+)/, 'hello\\\\u\\\\u\\\\l\\\\l\\\\U$1', 'helloGOodBYE');\n\t});\n\n\ttest('replace has JavaScript semantics', () => {\n\t\tconst testJSReplaceSemantics = (target: string, search: RegExp, replaceString: string, expected: string) => {\n\t\t\tconst replacePattern = parseReplaceString(replaceString);\n\t\t\tconst m = search.exec(target);\n\t\t\tconst actual = replacePattern.buildReplaceString(m);\n\n\t\t\tassert.deepStrictEqual(actual, expected, `${target}.replace(${search}, ${replaceString})`);\n\t\t};\n\n\t\ttestJSReplaceSemantics('hi', /hi/, 'hello', 'hi'.replace(/hi/, 'hello'));\n\t\ttestJSReplaceSemantics('hi', /hi/, '\\\\t', 'hi'.replace(/hi/, '\\t'));\n\t\ttestJSReplaceSemantics('hi', /hi/, '\\\\n', 'hi'.replace(/hi/, '\\n'));\n\t\ttestJSReplaceSemantics('hi', /hi/, '\\\\\\\\t', 'hi'.replace(/hi/, '\\\\t'));\n\t\ttestJSReplaceSemantics('hi', /hi/, '\\\\\\\\n', 'hi'.replace(/hi/, '\\\\n'));\n\n\t\t// implicit capture group 0\n\t\ttestJSReplaceSemantics('hi', /hi/, 'hello$&', 'hi'.replace(/hi/, 'hello$&'));\n\t\ttestJSReplaceSemantics('hi', /hi/, 'hello$0', 'hi'.replace(/hi/, 'hello$&'));\n\t\ttestJSReplaceSemantics('hi', /hi/, 'hello$&1', 'hi'.replace(/hi/, 'hello$&1'));\n\t\ttestJSReplaceSemantics('hi', /hi/, 'hello$01', 'hi'.replace(/hi/, 'hello$&1'));\n\n\t\t// capture groups have funny semantics in replace strings\n\t\t// the replace string interprets $nn as a captured group only if it exists in the search regex\n\t\ttestJSReplaceSemantics('hi', /(hi)/, 'hello$10', 'hi'.replace(/(hi)/, 'hello$10'));\n\t\ttestJSReplaceSemantics('hi', /(hi)()()()()()()()()()/, 'hello$10', 'hi'.replace(/(hi)()()()()()()()()()/, 'hello$10'));\n\t\ttestJSReplaceSemantics('hi', /(hi)/, 'hello$100', 'hi'.replace(/(hi)/, 'hello$100'));\n\t\ttestJSReplaceSemantics('hi', /(hi)/, 'hello$20', 'hi'.replace(/(hi)/, 'hello$20'));\n\t});\n\n\ttest('get replace string if given text is a complete match', () => {\n\t\tfunction assertReplace(target: string, search: RegExp, replaceString: string, expected: string): void {\n\t\t\tconst replacePattern = parseReplaceString(replaceString);\n\t\t\tconst m = search.exec(target);\n\t\t\tconst actual = replacePattern.buildReplaceString(m);\n\n\t\t\tassert.strictEqual(actual, expected, `${target}.replace(${search}, ${replaceString}) === ${expected}`);\n\t\t}\n\n\t\tassertReplace('bla', /bla/, 'hello', 'hello');\n\t\tassertReplace('bla', /(bla)/, 'hello', 'hello');\n\t\tassertReplace('bla', /(bla)/, 'hello$0', 'hellobla');\n\n\t\tconst searchRegex = /let\\s+(\\w+)\\s*=\\s*require\\s*\\(\\s*['\"]([\\w\\.\\-/]+)\\s*['\"]\\s*\\)\\s*/;\n\t\tassertReplace('let fs = require(\\'fs\\')', searchRegex, 'import * as $1 from \\'$2\\';', 'import * as fs from \\'fs\\';');\n\t\tassertReplace('let something = require(\\'fs\\')', searchRegex, 'import * as $1 from \\'$2\\';', 'import * as something from \\'fs\\';');\n\t\tassertReplace('let something = require(\\'fs\\')', searchRegex, 'import * as $1 from \\'$1\\';', 'import * as something from \\'something\\';');\n\t\tassertReplace('let something = require(\\'fs\\')', searchRegex, 'import * as $2 from \\'$1\\';', 'import * as fs from \\'something\\';');\n\t\tassertReplace('let something = require(\\'fs\\')', searchRegex, 'import * as $0 from \\'$0\\';', 'import * as let something = require(\\'fs\\') from \\'let something = require(\\'fs\\')\\';');\n\t\tassertReplace('let fs = require(\\'fs\\')', searchRegex, 'import * as $1 from \\'$2\\';', 'import * as fs from \\'fs\\';');\n\t\tassertReplace('for ()', /for(.*)/, 'cat$1', 'cat ()');\n\n\t\t// issue #18111\n\t\tassertReplace('HRESULT OnAmbientPropertyChange(DISPID   dispid);', /\\b\\s{3}\\b/, ' ', ' ');\n\t});\n\n\ttest('get replace string if match is sub-string of the text', () => {\n\t\tfunction assertReplace(target: string, search: RegExp, replaceString: string, expected: string): void {\n\t\t\tconst replacePattern = parseReplaceString(replaceString);\n\t\t\tconst m = search.exec(target);\n\t\t\tconst actual = replacePattern.buildReplaceString(m);\n\n\t\t\tassert.strictEqual(actual, expected, `${target}.replace(${search}, ${replaceString}) === ${expected}`);\n\t\t}\n\t\tassertReplace('this is a bla text', /bla/, 'hello', 'hello');\n\t\tassertReplace('this is a bla text', /this(?=.*bla)/, 'that', 'that');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$1at', 'that');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$1e', 'the');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$1ere', 'there');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$1', 'th');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, 'ma$1', 'math');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, 'ma$1s', 'maths');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$0', 'this');\n\t\tassertReplace('this is a bla text', /(th)is(?=.*bla)/, '$0$1', 'thisth');\n\t\tassertReplace('this is a bla text', /bla(?=\\stext$)/, 'foo', 'foo');\n\t\tassertReplace('this is a bla text', /b(la)(?=\\stext$)/, 'f$1', 'fla');\n\t\tassertReplace('this is a bla text', /b(la)(?=\\stext$)/, 'f$0', 'fbla');\n\t\tassertReplace('this is a bla text', /b(la)(?=\\stext$)/, '$0ah', 'blaah');\n\t});\n\n\ttest('issue #19740 Find and replace capture group/backreference inserts `undefined` instead of empty string', () => {\n\t\tconst replacePattern = parseReplaceString('a{$1}');\n\t\tconst matches = /a(z)?/.exec('abcd');\n\t\tconst actual = replacePattern.buildReplaceString(matches);\n\t\tassert.strictEqual(actual, 'a{}');\n\t});\n\n\ttest('buildReplaceStringWithCasePreserved test', () => {\n\t\tfunction assertReplace(target: string[], replaceString: string, expected: string): void {\n\t\t\tlet actual: string = '';\n\t\t\tactual = buildReplaceStringWithCasePreserved(target, replaceString);\n\t\t\tassert.strictEqual(actual, expected);\n\t\t}\n\n\t\tassertReplace(['abc'], 'Def', 'def');\n\t\tassertReplace(['Abc'], 'Def', 'Def');\n\t\tassertReplace(['ABC'], 'Def', 'DEF');\n\t\tassertReplace(['abc', 'Abc'], 'Def', 'def');\n\t\tassertReplace(['Abc', 'abc'], 'Def', 'Def');\n\t\tassertReplace(['ABC', 'abc'], 'Def', 'DEF');\n\t\tassertReplace(['aBc', 'abc'], 'Def', 'def');\n\t\tassertReplace(['AbC'], 'Def', 'Def');\n\t\tassertReplace(['aBC'], 'Def', 'def');\n\t\tassertReplace(['aBc'], 'DeF', 'deF');\n\t\tassertReplace(['Foo-Bar'], 'newfoo-newbar', 'Newfoo-Newbar');\n\t\tassertReplace(['Foo-Bar-Abc'], 'newfoo-newbar-newabc', 'Newfoo-Newbar-Newabc');\n\t\tassertReplace(['Foo-Bar-abc'], 'newfoo-newbar', 'Newfoo-newbar');\n\t\tassertReplace(['foo-Bar'], 'newfoo-newbar', 'newfoo-Newbar');\n\t\tassertReplace(['foo-BAR'], 'newfoo-newbar', 'newfoo-NEWBAR');\n\t\tassertReplace(['foO-BAR'], 'NewFoo-NewBar', 'newFoo-NEWBAR');\n\t\tassertReplace(['Foo_Bar'], 'newfoo_newbar', 'Newfoo_Newbar');\n\t\tassertReplace(['Foo_Bar_Abc'], 'newfoo_newbar_newabc', 'Newfoo_Newbar_Newabc');\n\t\tassertReplace(['Foo_Bar_abc'], 'newfoo_newbar', 'Newfoo_newbar');\n\t\tassertReplace(['Foo_Bar-abc'], 'newfoo_newbar-abc', 'Newfoo_newbar-abc');\n\t\tassertReplace(['foo_Bar'], 'newfoo_newbar', 'newfoo_Newbar');\n\t\tassertReplace(['Foo_BAR'], 'newfoo_newbar', 'Newfoo_NEWBAR');\n\t});\n\n\ttest('preserve case', () => {\n\t\tfunction assertReplace(target: string[], replaceString: string, expected: string): void {\n\t\t\tconst replacePattern = parseReplaceString(replaceString);\n\t\t\tconst actual = replacePattern.buildReplaceString(target, true);\n\t\t\tassert.strictEqual(actual, expected);\n\t\t}\n\n\t\tassertReplace(['abc'], 'Def', 'def');\n\t\tassertReplace(['Abc'], 'Def', 'Def');\n\t\tassertReplace(['ABC'], 'Def', 'DEF');\n\t\tassertReplace(['abc', 'Abc'], 'Def', 'def');\n\t\tassertReplace(['Abc', 'abc'], 'Def', 'Def');\n\t\tassertReplace(['ABC', 'abc'], 'Def', 'DEF');\n\t\tassertReplace(['aBc', 'abc'], 'Def', 'def');\n\t\tassertReplace(['AbC'], 'Def', 'Def');\n\t\tassertReplace(['aBC'], 'Def', 'def');\n\t\tassertReplace(['aBc'], 'DeF', 'deF');\n\t\tassertReplace(['Foo-Bar'], 'newfoo-newbar', 'Newfoo-Newbar');\n\t\tassertReplace(['Foo-Bar-Abc'], 'newfoo-newbar-newabc', 'Newfoo-Newbar-Newabc');\n\t\tassertReplace(['Foo-Bar-abc'], 'newfoo-newbar', 'Newfoo-newbar');\n\t\tassertReplace(['foo-Bar'], 'newfoo-newbar', 'newfoo-Newbar');\n\t\tassertReplace(['foo-BAR'], 'newfoo-newbar', 'newfoo-NEWBAR');\n\t\tassertReplace(['foO-BAR'], 'NewFoo-NewBar', 'newFoo-NEWBAR');\n\t\tassertReplace(['Foo_Bar'], 'newfoo_newbar', 'Newfoo_Newbar');\n\t\tassertReplace(['Foo_Bar_Abc'], 'newfoo_newbar_newabc', 'Newfoo_Newbar_Newabc');\n\t\tassertReplace(['Foo_Bar_abc'], 'newfoo_newbar', 'Newfoo_newbar');\n\t\tassertReplace(['Foo_Bar-abc'], 'newfoo_newbar-abc', 'Newfoo_newbar-abc');\n\t\tassertReplace(['foo_Bar'], 'newfoo_newbar', 'newfoo_Newbar');\n\t\tassertReplace(['foo_BAR'], 'newfoo_newbar', 'newfoo_NEWBAR');\n\t});\n});\n"]}