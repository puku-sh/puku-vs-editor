{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/editor/contrib/inlineCompletions/test/browser/scrollToReveal.test.ts","vs/editor/contrib/inlineCompletions/test/browser/scrollToReveal.test.ts"],"names":[],"mappings":"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","file":"scrollToReveal.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { OffsetRange } from '../../../../common/core/ranges/offsetRange.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { scrollToReveal } from '../../browser/view/inlineEdits/inlineEditsViews/longDistanceHint/inlineEditsLongDistanceHint.js';\n\nsuite('scrollToReveal', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('should not scroll when content is already visible', () => {\n\t\t// Content range [20, 30) is fully contained in window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(20, 30));\n\t\tassert.strictEqual(result.newScrollPosition, 10);\n\t});\n\n\ttest('should not scroll when content exactly fits the visible window', () => {\n\t\t// Content range [10, 50) exactly matches visible window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(10, 50));\n\t\tassert.strictEqual(result.newScrollPosition, 10);\n\t});\n\n\ttest('should scroll left when content starts before visible window', () => {\n\t\t// Content range [5, 15) starts before visible window [20, 60)\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(5, 15));\n\t\tassert.strictEqual(result.newScrollPosition, 5);\n\t});\n\n\ttest('should scroll right when content ends after visible window', () => {\n\t\t// Content range [50, 80) ends after visible window [10, 50)\n\t\t// New scroll position should be 80 - 40 = 40 so window becomes [40, 80)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(50, 80));\n\t\tassert.strictEqual(result.newScrollPosition, 40);\n\t});\n\n\ttest('should show start of content when content is larger than window', () => {\n\t\t// Content range [20, 100) is larger than window width 40\n\t\t// Should position at start of content\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(20, 100));\n\t\tassert.strictEqual(result.newScrollPosition, 20);\n\t});\n\n\ttest('should handle edge case with zero-width content', () => {\n\t\t// Empty content range [25, 25) in window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(25, 25));\n\t\tassert.strictEqual(result.newScrollPosition, 10);\n\t});\n\n\ttest('should handle edge case with zero window width', () => {\n\t\t// Any non-empty content with zero window width should position at content start\n\t\tconst result = scrollToReveal(10, 0, new OffsetRange(20, 30));\n\t\tassert.strictEqual(result.newScrollPosition, 20);\n\t});\n\n\ttest('should handle content at exact window boundaries - left edge', () => {\n\t\t// Content range [10, 20) starts exactly at visible window start [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(10, 20));\n\t\tassert.strictEqual(result.newScrollPosition, 10);\n\t});\n\n\ttest('should handle content at exact window boundaries - right edge', () => {\n\t\t// Content range [40, 50) ends exactly at visible window end [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(40, 50));\n\t\tassert.strictEqual(result.newScrollPosition, 10);\n\t});\n\n\ttest('should scroll right when content extends beyond right boundary', () => {\n\t\t// Content range [40, 60) extends beyond visible window [10, 50)\n\t\t// New scroll position should be 60 - 40 = 20 so window becomes [20, 60)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(40, 60));\n\t\tassert.strictEqual(result.newScrollPosition, 20);\n\t});\n\n\ttest('should scroll left when content extends beyond left boundary', () => {\n\t\t// Content range [5, 25) starts before visible window [20, 60)\n\t\t// Should position at start of content\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(5, 25));\n\t\tassert.strictEqual(result.newScrollPosition, 5);\n\t});\n\n\ttest('should handle content overlapping both boundaries', () => {\n\t\t// Content range [5, 70) overlaps both sides of visible window [20, 60)\n\t\t// Since content is larger than window, should position at start of content\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(5, 70));\n\t\tassert.strictEqual(result.newScrollPosition, 5);\n\t});\n\n\ttest('should handle negative scroll positions', () => {\n\t\t// Current scroll at -10, window width 40, so visible range [-10, 30)\n\t\t// Content [35, 45) is beyond the visible window\n\t\tconst result = scrollToReveal(-10, 40, new OffsetRange(35, 45));\n\t\tassert.strictEqual(result.newScrollPosition, 5); // 45 - 40 = 5\n\t});\n\n\ttest('should handle large numbers', () => {\n\t\t// Test with large numbers to ensure no overflow issues\n\t\tconst result = scrollToReveal(1000000, 500, new OffsetRange(1000600, 1000700));\n\t\tassert.strictEqual(result.newScrollPosition, 1000200); // 1000700 - 500 = 1000200\n\t});\n\n\ttest('should prioritize left scroll when content spans window but starts before', () => {\n\t\t// Content [5, 55) spans wider than window width 40, starting before visible [20, 60)\n\t\t// Should position at start of content\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(5, 55));\n\t\tassert.strictEqual(result.newScrollPosition, 5);\n\t});\n\n\ttest('should handle single character content requiring scroll', () => {\n\t\t// Single character at position [100, 101) with visible window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(100, 101));\n\t\tassert.strictEqual(result.newScrollPosition, 61); // 101 - 40 = 61\n\t});\n\n\ttest('should handle content just barely outside visible area - left', () => {\n\t\t// Content [9, 19) with one unit outside visible window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(9, 19));\n\t\tassert.strictEqual(result.newScrollPosition, 9);\n\t});\n\n\ttest('should handle content just barely outside visible area - right', () => {\n\t\t// Content [45, 51) with one unit outside visible window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(45, 51));\n\t\tassert.strictEqual(result.newScrollPosition, 11); // 51 - 40 = 11\n\t});\n\n\ttest('should handle fractional-like scenarios with minimum window', () => {\n\t\t// Minimum window width 1, content needs to be revealed\n\t\tconst result = scrollToReveal(50, 1, new OffsetRange(100, 105));\n\t\tassert.strictEqual(result.newScrollPosition, 100); // Content larger than window, show start\n\t});\n\n\ttest('should preserve scroll when content partially visible on left', () => {\n\t\t// Content [5, 25) partially visible in window [20, 60), overlaps [20, 25)\n\t\t// Since content starts before window, scroll to show start\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(5, 25));\n\t\tassert.strictEqual(result.newScrollPosition, 5);\n\t});\n\n\ttest('should preserve scroll when content partially visible on right', () => {\n\t\t// Content [45, 65) partially visible in window [20, 60), overlaps [45, 60)\n\t\t// Since content extends beyond window, scroll to show end\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(45, 65));\n\t\tassert.strictEqual(result.newScrollPosition, 25); // 65 - 40 = 25\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { OffsetRange } from '../../../../common/core/ranges/offsetRange.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { scrollToReveal } from '../../browser/view/inlineEdits/inlineEditsViews/longDistanceHint/inlineEditsLongDistanceHint.js';\n\nsuite('scrollToReveal', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('should not scroll when content is already visible', () => {\n\t\t// Content range [20, 30) is fully contained in window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(20, 30));\n\t\tassert.strictEqual(result.newScrollPosition, 10);\n\t});\n\n\ttest('should not scroll when content exactly fits the visible window', () => {\n\t\t// Content range [10, 50) exactly matches visible window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(10, 50));\n\t\tassert.strictEqual(result.newScrollPosition, 10);\n\t});\n\n\ttest('should scroll left when content starts before visible window', () => {\n\t\t// Content range [5, 15) starts before visible window [20, 60)\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(5, 15));\n\t\tassert.strictEqual(result.newScrollPosition, 5);\n\t});\n\n\ttest('should scroll right when content ends after visible window', () => {\n\t\t// Content range [50, 80) ends after visible window [10, 50)\n\t\t// New scroll position should be 80 - 40 = 40 so window becomes [40, 80)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(50, 80));\n\t\tassert.strictEqual(result.newScrollPosition, 40);\n\t});\n\n\ttest('should show start of content when content is larger than window', () => {\n\t\t// Content range [20, 100) is larger than window width 40\n\t\t// Should position at start of content\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(20, 100));\n\t\tassert.strictEqual(result.newScrollPosition, 20);\n\t});\n\n\ttest('should handle edge case with zero-width content', () => {\n\t\t// Empty content range [25, 25) in window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(25, 25));\n\t\tassert.strictEqual(result.newScrollPosition, 10);\n\t});\n\n\ttest('should handle edge case with zero window width', () => {\n\t\t// Any non-empty content with zero window width should position at content start\n\t\tconst result = scrollToReveal(10, 0, new OffsetRange(20, 30));\n\t\tassert.strictEqual(result.newScrollPosition, 20);\n\t});\n\n\ttest('should handle content at exact window boundaries - left edge', () => {\n\t\t// Content range [10, 20) starts exactly at visible window start [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(10, 20));\n\t\tassert.strictEqual(result.newScrollPosition, 10);\n\t});\n\n\ttest('should handle content at exact window boundaries - right edge', () => {\n\t\t// Content range [40, 50) ends exactly at visible window end [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(40, 50));\n\t\tassert.strictEqual(result.newScrollPosition, 10);\n\t});\n\n\ttest('should scroll right when content extends beyond right boundary', () => {\n\t\t// Content range [40, 60) extends beyond visible window [10, 50)\n\t\t// New scroll position should be 60 - 40 = 20 so window becomes [20, 60)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(40, 60));\n\t\tassert.strictEqual(result.newScrollPosition, 20);\n\t});\n\n\ttest('should scroll left when content extends beyond left boundary', () => {\n\t\t// Content range [5, 25) starts before visible window [20, 60)\n\t\t// Should position at start of content\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(5, 25));\n\t\tassert.strictEqual(result.newScrollPosition, 5);\n\t});\n\n\ttest('should handle content overlapping both boundaries', () => {\n\t\t// Content range [5, 70) overlaps both sides of visible window [20, 60)\n\t\t// Since content is larger than window, should position at start of content\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(5, 70));\n\t\tassert.strictEqual(result.newScrollPosition, 5);\n\t});\n\n\ttest('should handle negative scroll positions', () => {\n\t\t// Current scroll at -10, window width 40, so visible range [-10, 30)\n\t\t// Content [35, 45) is beyond the visible window\n\t\tconst result = scrollToReveal(-10, 40, new OffsetRange(35, 45));\n\t\tassert.strictEqual(result.newScrollPosition, 5); // 45 - 40 = 5\n\t});\n\n\ttest('should handle large numbers', () => {\n\t\t// Test with large numbers to ensure no overflow issues\n\t\tconst result = scrollToReveal(1000000, 500, new OffsetRange(1000600, 1000700));\n\t\tassert.strictEqual(result.newScrollPosition, 1000200); // 1000700 - 500 = 1000200\n\t});\n\n\ttest('should prioritize left scroll when content spans window but starts before', () => {\n\t\t// Content [5, 55) spans wider than window width 40, starting before visible [20, 60)\n\t\t// Should position at start of content\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(5, 55));\n\t\tassert.strictEqual(result.newScrollPosition, 5);\n\t});\n\n\ttest('should handle single character content requiring scroll', () => {\n\t\t// Single character at position [100, 101) with visible window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(100, 101));\n\t\tassert.strictEqual(result.newScrollPosition, 61); // 101 - 40 = 61\n\t});\n\n\ttest('should handle content just barely outside visible area - left', () => {\n\t\t// Content [9, 19) with one unit outside visible window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(9, 19));\n\t\tassert.strictEqual(result.newScrollPosition, 9);\n\t});\n\n\ttest('should handle content just barely outside visible area - right', () => {\n\t\t// Content [45, 51) with one unit outside visible window [10, 50)\n\t\tconst result = scrollToReveal(10, 40, new OffsetRange(45, 51));\n\t\tassert.strictEqual(result.newScrollPosition, 11); // 51 - 40 = 11\n\t});\n\n\ttest('should handle fractional-like scenarios with minimum window', () => {\n\t\t// Minimum window width 1, content needs to be revealed\n\t\tconst result = scrollToReveal(50, 1, new OffsetRange(100, 105));\n\t\tassert.strictEqual(result.newScrollPosition, 100); // Content larger than window, show start\n\t});\n\n\ttest('should preserve scroll when content partially visible on left', () => {\n\t\t// Content [5, 25) partially visible in window [20, 60), overlaps [20, 25)\n\t\t// Since content starts before window, scroll to show start\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(5, 25));\n\t\tassert.strictEqual(result.newScrollPosition, 5);\n\t});\n\n\ttest('should preserve scroll when content partially visible on right', () => {\n\t\t// Content [45, 65) partially visible in window [20, 60), overlaps [45, 60)\n\t\t// Since content extends beyond window, scroll to show end\n\t\tconst result = scrollToReveal(20, 40, new OffsetRange(45, 65));\n\t\tassert.strictEqual(result.newScrollPosition, 25); // 65 - 40 = 25\n\t});\n});\n"]}