{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/editor/contrib/inlineCompletions/test/browser/layout.test.ts","vs/editor/contrib/inlineCompletions/test/browser/layout.test.ts"],"names":[],"mappings":"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","file":"layout.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { Size2D } from '../../../../common/core/2d/size.js';\nimport { OffsetRange } from '../../../../common/core/ranges/offsetRange.js';\nimport { getMaxTowerHeightInAvailableArea } from '../../browser/view/inlineEdits/utils/towersLayout.js';\n\nsuite('Layout - getMaxTowerHeightInAvailableArea', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('tower fits within single available area', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(5, 15); // width of 10\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return the available height (30)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 30);\n\t});\n\n\ttest('max height available in area', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(5, 15); // width of 10\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return the available height (30), even if original tower was 40\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 30);\n\t});\n\n\ttest('tower extends beyond available width', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(0, 60); // width of 60\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return 0 because tower extends beyond available areas\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 0);\n\t});\n\n\ttest('tower fits across multiple available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(10, 40); // width of 30\n\t\tconst availableTowerAreas = [\n\t\t\tnew Size2D(20, 30),\n\t\t\tnew Size2D(20, 25),\n\t\t\tnew Size2D(20, 30)\n\t\t];\n\n\t\t// Should return the minimum height across overlapping areas (25)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 25);\n\t});\n\n\ttest('min height across overlapping areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(10, 40); // width of 30\n\t\tconst availableTowerAreas = [\n\t\t\tnew Size2D(20, 30),\n\t\t\tnew Size2D(20, 15), // Shortest area\n\t\t\tnew Size2D(20, 30)\n\t\t];\n\n\t\t// Should return the minimum height (15)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 15);\n\t});\n\n\ttest('tower at left edge of available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(0, 10); // width of 10\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return the available height (30)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 30);\n\t});\n\n\ttest('tower at right edge of available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(40, 50); // width of 10\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return the available height (30)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 30);\n\t});\n\n\ttest('tower exactly matches available area', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(0, 50); // width of 50\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return the available height (30)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 30);\n\t});\n\n\ttest('empty available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(0, 10); // width of 10\n\t\tconst availableTowerAreas: Size2D[] = [];\n\n\t\t// Should return 0 for empty areas\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 0);\n\t});\n\n\ttest('tower spans exactly two available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(10, 50); // width of 40\n\t\tconst availableTowerAreas = [\n\t\t\tnew Size2D(30, 25),\n\t\t\tnew Size2D(30, 25)\n\t\t];\n\n\t\t// Should return the minimum height across both areas (25)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 25);\n\t});\n\n\ttest('tower starts at boundary between two areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(30, 50); // width of 20\n\t\tconst availableTowerAreas = [\n\t\t\tnew Size2D(30, 25),\n\t\t\tnew Size2D(30, 25)\n\t\t];\n\n\t\t// Should return the height of the second area (25)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 25);\n\t});\n\n\ttest('tower with varying height available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(0, 50); // width of 50\n\t\tconst availableTowerAreas = [\n\t\t\tnew Size2D(10, 30),\n\t\t\tnew Size2D(10, 15), // Shortest area\n\t\t\tnew Size2D(10, 25),\n\t\t\tnew Size2D(10, 30),\n\t\t\tnew Size2D(10, 40)\n\t\t];\n\n\t\t// Should return the minimum height (15)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 15);\n\t});\n\n\ttest('tower beyond all available areas to the right', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(100, 110); // width of 10\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return 0 because tower is beyond available areas\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 0);\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { Size2D } from '../../../../common/core/2d/size.js';\nimport { OffsetRange } from '../../../../common/core/ranges/offsetRange.js';\nimport { getMaxTowerHeightInAvailableArea } from '../../browser/view/inlineEdits/utils/towersLayout.js';\n\nsuite('Layout - getMaxTowerHeightInAvailableArea', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('tower fits within single available area', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(5, 15); // width of 10\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return the available height (30)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 30);\n\t});\n\n\ttest('max height available in area', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(5, 15); // width of 10\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return the available height (30), even if original tower was 40\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 30);\n\t});\n\n\ttest('tower extends beyond available width', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(0, 60); // width of 60\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return 0 because tower extends beyond available areas\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 0);\n\t});\n\n\ttest('tower fits across multiple available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(10, 40); // width of 30\n\t\tconst availableTowerAreas = [\n\t\t\tnew Size2D(20, 30),\n\t\t\tnew Size2D(20, 25),\n\t\t\tnew Size2D(20, 30)\n\t\t];\n\n\t\t// Should return the minimum height across overlapping areas (25)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 25);\n\t});\n\n\ttest('min height across overlapping areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(10, 40); // width of 30\n\t\tconst availableTowerAreas = [\n\t\t\tnew Size2D(20, 30),\n\t\t\tnew Size2D(20, 15), // Shortest area\n\t\t\tnew Size2D(20, 30)\n\t\t];\n\n\t\t// Should return the minimum height (15)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 15);\n\t});\n\n\ttest('tower at left edge of available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(0, 10); // width of 10\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return the available height (30)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 30);\n\t});\n\n\ttest('tower at right edge of available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(40, 50); // width of 10\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return the available height (30)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 30);\n\t});\n\n\ttest('tower exactly matches available area', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(0, 50); // width of 50\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return the available height (30)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 30);\n\t});\n\n\ttest('empty available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(0, 10); // width of 10\n\t\tconst availableTowerAreas: Size2D[] = [];\n\n\t\t// Should return 0 for empty areas\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 0);\n\t});\n\n\ttest('tower spans exactly two available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(10, 50); // width of 40\n\t\tconst availableTowerAreas = [\n\t\t\tnew Size2D(30, 25),\n\t\t\tnew Size2D(30, 25)\n\t\t];\n\n\t\t// Should return the minimum height across both areas (25)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 25);\n\t});\n\n\ttest('tower starts at boundary between two areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(30, 50); // width of 20\n\t\tconst availableTowerAreas = [\n\t\t\tnew Size2D(30, 25),\n\t\t\tnew Size2D(30, 25)\n\t\t];\n\n\t\t// Should return the height of the second area (25)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 25);\n\t});\n\n\ttest('tower with varying height available areas', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(0, 50); // width of 50\n\t\tconst availableTowerAreas = [\n\t\t\tnew Size2D(10, 30),\n\t\t\tnew Size2D(10, 15), // Shortest area\n\t\t\tnew Size2D(10, 25),\n\t\t\tnew Size2D(10, 30),\n\t\t\tnew Size2D(10, 40)\n\t\t];\n\n\t\t// Should return the minimum height (15)\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 15);\n\t});\n\n\ttest('tower beyond all available areas to the right', () => {\n\t\tconst towerHorizontalRange = new OffsetRange(100, 110); // width of 10\n\t\tconst availableTowerAreas = [new Size2D(50, 30)];\n\n\t\t// Should return 0 because tower is beyond available areas\n\t\tassert.strictEqual(getMaxTowerHeightInAvailableArea(towerHorizontalRange, availableTowerAreas), 0);\n\t});\n});\n"]}