{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/editor/contrib/inlineCompletions/browser/model/inlineSuggestionItem.ts","vs/editor/contrib/inlineCompletions/browser/model/inlineSuggestionItem.ts"],"names":[],"mappings":"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","file":"inlineSuggestionItem.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { matchesSubString } from '../../../../../base/common/filters.js';\nimport { IObservable, ITransaction, observableSignal, observableValue } from '../../../../../base/common/observable.js';\nimport { commonPrefixLength, commonSuffixLength, splitLines } from '../../../../../base/common/strings.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { ICommandService } from '../../../../../platform/commands/common/commands.js';\nimport { ISingleEditOperation } from '../../../../common/core/editOperation.js';\nimport { applyEditsToRanges, StringEdit, StringReplacement } from '../../../../common/core/edits/stringEdit.js';\nimport { TextEdit, TextReplacement } from '../../../../common/core/edits/textEdit.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { OffsetRange } from '../../../../common/core/ranges/offsetRange.js';\nimport { StringText } from '../../../../common/core/text/abstractText.js';\nimport { getPositionOffsetTransformerFromTextModel } from '../../../../common/core/text/getPositionOffsetTransformerFromTextModel.js';\nimport { PositionOffsetTransformerBase } from '../../../../common/core/text/positionToOffset.js';\nimport { TextLength } from '../../../../common/core/text/textLength.js';\nimport { linesDiffComputers } from '../../../../common/diff/linesDiffComputers.js';\nimport { Command, InlineCompletion, InlineCompletionHintStyle, InlineCompletionEndOfLifeReason, InlineCompletionTriggerKind, InlineCompletionWarning, PartialAcceptInfo, InlineCompletionHint } from '../../../../common/languages.js';\nimport { EndOfLinePreference, ITextModel } from '../../../../common/model.js';\nimport { TextModelText } from '../../../../common/model/textModelText.js';\nimport { InlineCompletionViewData, InlineCompletionViewKind } from '../view/inlineEdits/inlineEditsViewInterface.js';\nimport { InlineSuggestData, InlineSuggestionList, PartialAcceptance, SnippetInfo } from './provideInlineCompletions.js';\nimport { singleTextRemoveCommonPrefix } from './singleTextEditHelpers.js';\n\nexport type InlineSuggestionItem = InlineEditItem | InlineCompletionItem;\n\nexport namespace InlineSuggestionItem {\n\texport function create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: ITextModel,\n\t): InlineSuggestionItem {\n\t\tif (!data.isInlineEdit && !data.uri) {\n\t\t\treturn InlineCompletionItem.create(data, textModel);\n\t\t} else {\n\t\t\treturn InlineEditItem.create(data, textModel);\n\t\t}\n\t}\n}\n\nabstract class InlineSuggestionItemBase {\n\tconstructor(\n\t\tprotected readonly _data: InlineSuggestData,\n\t\tpublic readonly identity: InlineSuggestionIdentity,\n\t\tpublic readonly hint: InlineSuggestHint | undefined\n\t) { }\n\n\t/**\n\t * A reference to the original inline completion list this inline completion has been constructed from.\n\t * Used for event data to ensure referential equality.\n\t*/\n\tpublic get source(): InlineSuggestionList { return this._data.source; }\n\n\tpublic get isFromExplicitRequest(): boolean { return this._data.context.triggerKind === InlineCompletionTriggerKind.Explicit; }\n\tpublic get forwardStable(): boolean { return this.source.inlineSuggestions.enableForwardStability ?? false; }\n\tpublic get editRange(): Range { return this.getSingleTextEdit().range; }\n\tpublic get targetRange(): Range { return this.hint?.range ?? this.editRange; }\n\tpublic get insertText(): string { return this.getSingleTextEdit().text; }\n\tpublic get semanticId(): string { return this.hash; }\n\tpublic get action(): Command | undefined { return this._sourceInlineCompletion.gutterMenuLinkAction; }\n\tpublic get command(): Command | undefined { return this._sourceInlineCompletion.command; }\n\tpublic get warning(): InlineCompletionWarning | undefined { return this._sourceInlineCompletion.warning; }\n\tpublic get showInlineEditMenu(): boolean { return !!this._sourceInlineCompletion.showInlineEditMenu; }\n\tpublic get hash() {\n\t\treturn JSON.stringify([\n\t\t\tthis.getSingleTextEdit().text,\n\t\t\tthis.getSingleTextEdit().range.getStartPosition().toString()\n\t\t]);\n\t}\n\t/** @deprecated */\n\tpublic get shownCommand(): Command | undefined { return this._sourceInlineCompletion.shownCommand; }\n\n\tpublic get requestUuid(): string { return this._data.context.requestUuid; }\n\n\tpublic get partialAccepts(): PartialAcceptance { return this._data.partialAccepts; }\n\n\t/**\n\t * A reference to the original inline completion this inline completion has been constructed from.\n\t * Used for event data to ensure referential equality.\n\t*/\n\tprivate get _sourceInlineCompletion(): InlineCompletion { return this._data.sourceInlineCompletion; }\n\n\n\tpublic abstract getSingleTextEdit(): TextReplacement;\n\n\tpublic abstract withEdit(userEdit: StringEdit, textModel: ITextModel): InlineSuggestionItem | undefined;\n\n\tpublic abstract withIdentity(identity: InlineSuggestionIdentity): InlineSuggestionItem;\n\tpublic abstract canBeReused(model: ITextModel, position: Position): boolean;\n\n\n\tpublic addRef(): void {\n\t\tthis.identity.addRef();\n\t\tthis.source.addRef();\n\t}\n\n\tpublic removeRef(): void {\n\t\tthis.identity.removeRef();\n\t\tthis.source.removeRef();\n\t}\n\n\tpublic reportInlineEditShown(commandService: ICommandService, viewKind: InlineCompletionViewKind, viewData: InlineCompletionViewData) {\n\t\tthis._data.reportInlineEditShown(commandService, this.insertText, viewKind, viewData);\n\t}\n\n\tpublic reportPartialAccept(acceptedCharacters: number, info: PartialAcceptInfo, partialAcceptance: PartialAcceptance) {\n\t\tthis._data.reportPartialAccept(acceptedCharacters, info, partialAcceptance);\n\t}\n\n\tpublic reportEndOfLife(reason: InlineCompletionEndOfLifeReason): void {\n\t\tthis._data.reportEndOfLife(reason);\n\t}\n\n\tpublic setEndOfLifeReason(reason: InlineCompletionEndOfLifeReason): void {\n\t\tthis._data.setEndOfLifeReason(reason);\n\t}\n\n\tpublic setIsPreceeded(item: InlineSuggestionItem): void {\n\t\tthis._data.setIsPreceeded(item.partialAccepts);\n\t}\n\n\tpublic setNotShownReasonIfNotSet(reason: string): void {\n\t\tthis._data.setNotShownReason(reason);\n\t}\n\n\t/**\n\t * Avoid using this method. Instead introduce getters for the needed properties.\n\t*/\n\tpublic getSourceCompletion(): InlineCompletion {\n\t\treturn this._sourceInlineCompletion;\n\t}\n}\n\nexport class InlineSuggestionIdentity {\n\tprivate static idCounter = 0;\n\tprivate readonly _onDispose = observableSignal(this);\n\tpublic readonly onDispose: IObservable<void> = this._onDispose;\n\n\tprivate readonly _jumpedTo = observableValue(this, false);\n\tpublic get jumpedTo(): IObservable<boolean> {\n\t\treturn this._jumpedTo;\n\t}\n\n\tprivate _refCount = 1;\n\tpublic readonly id = 'InlineCompletionIdentity' + InlineSuggestionIdentity.idCounter++;\n\n\taddRef() {\n\t\tthis._refCount++;\n\t}\n\n\tremoveRef() {\n\t\tthis._refCount--;\n\t\tif (this._refCount === 0) {\n\t\t\tthis._onDispose.trigger(undefined);\n\t\t}\n\t}\n\n\tsetJumpTo(tx: ITransaction | undefined): void {\n\t\tthis._jumpedTo.set(true, tx);\n\t}\n}\n\nexport class InlineSuggestHint {\n\n\tpublic static create(displayLocation: InlineCompletionHint) {\n\t\treturn new InlineSuggestHint(\n\t\t\tRange.lift(displayLocation.range),\n\t\t\tdisplayLocation.content,\n\t\t\tdisplayLocation.style,\n\t\t);\n\t}\n\n\tprivate constructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly content: string,\n\t\tpublic readonly style: InlineCompletionHintStyle,\n\t) { }\n\n\tpublic withEdit(edit: StringEdit, positionOffsetTransformer: PositionOffsetTransformerBase): InlineSuggestHint | undefined {\n\t\tconst offsetRange = new OffsetRange(\n\t\t\tpositionOffsetTransformer.getOffset(this.range.getStartPosition()),\n\t\t\tpositionOffsetTransformer.getOffset(this.range.getEndPosition())\n\t\t);\n\n\t\tconst newOffsetRange = applyEditsToRanges([offsetRange], edit)[0];\n\t\tif (!newOffsetRange) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst newRange = positionOffsetTransformer.getRange(newOffsetRange);\n\n\t\treturn new InlineSuggestHint(newRange, this.content, this.style);\n\t}\n}\n\nexport class InlineCompletionItem extends InlineSuggestionItemBase {\n\tpublic static create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: ITextModel,\n\t): InlineCompletionItem {\n\t\tconst identity = new InlineSuggestionIdentity();\n\t\tconst transformer = getPositionOffsetTransformerFromTextModel(textModel);\n\n\t\tconst insertText = data.insertText.replace(/\\r\\n|\\r|\\n/g, textModel.getEOL());\n\n\t\tconst edit = reshapeInlineCompletion(new StringReplacement(transformer.getOffsetRange(data.range), insertText), textModel);\n\t\tconst trimmedEdit = edit.removeCommonSuffixAndPrefix(textModel.getValue());\n\t\tconst textEdit = transformer.getTextReplacement(edit);\n\n\t\tconst displayLocation = data.hint ? InlineSuggestHint.create(data.hint) : undefined;\n\n\t\treturn new InlineCompletionItem(edit, trimmedEdit, textEdit, textEdit.range, data.snippetInfo, data.additionalTextEdits, data, identity, displayLocation);\n\t}\n\n\tpublic readonly isInlineEdit = false;\n\n\tprivate constructor(\n\t\tprivate readonly _edit: StringReplacement,\n\t\tprivate readonly _trimmedEdit: StringReplacement,\n\t\tprivate readonly _textEdit: TextReplacement,\n\t\tprivate readonly _originalRange: Range,\n\t\tpublic readonly snippetInfo: SnippetInfo | undefined,\n\t\tpublic readonly additionalTextEdits: readonly ISingleEditOperation[],\n\n\t\tdata: InlineSuggestData,\n\t\tidentity: InlineSuggestionIdentity,\n\t\tdisplayLocation: InlineSuggestHint | undefined,\n\t) {\n\t\tsuper(data, identity, displayLocation);\n\t}\n\n\toverride get hash(): string {\n\t\treturn JSON.stringify(this._trimmedEdit.toJson());\n\t}\n\n\toverride getSingleTextEdit(): TextReplacement { return this._textEdit; }\n\n\toverride withIdentity(identity: InlineSuggestionIdentity): InlineCompletionItem {\n\t\treturn new InlineCompletionItem(\n\t\t\tthis._edit,\n\t\t\tthis._trimmedEdit,\n\t\t\tthis._textEdit,\n\t\t\tthis._originalRange,\n\t\t\tthis.snippetInfo,\n\t\t\tthis.additionalTextEdits,\n\t\t\tthis._data,\n\t\t\tidentity,\n\t\t\tthis.hint\n\t\t);\n\t}\n\n\toverride withEdit(textModelEdit: StringEdit, textModel: ITextModel): InlineCompletionItem | undefined {\n\t\tconst newEditRange = applyEditsToRanges([this._edit.replaceRange], textModelEdit);\n\t\tif (newEditRange.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst newEdit = new StringReplacement(newEditRange[0], this._textEdit.text);\n\t\tconst positionOffsetTransformer = getPositionOffsetTransformerFromTextModel(textModel);\n\t\tconst newTextEdit = positionOffsetTransformer.getTextReplacement(newEdit);\n\n\t\tlet newDisplayLocation = this.hint;\n\t\tif (newDisplayLocation) {\n\t\t\tnewDisplayLocation = newDisplayLocation.withEdit(textModelEdit, positionOffsetTransformer);\n\t\t\tif (!newDisplayLocation) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\tconst trimmedEdit = newEdit.removeCommonSuffixAndPrefix(textModel.getValue());\n\n\t\treturn new InlineCompletionItem(\n\t\t\tnewEdit,\n\t\t\ttrimmedEdit,\n\t\t\tnewTextEdit,\n\t\t\tthis._originalRange,\n\t\t\tthis.snippetInfo,\n\t\t\tthis.additionalTextEdits,\n\t\t\tthis._data,\n\t\t\tthis.identity,\n\t\t\tnewDisplayLocation\n\t\t);\n\t}\n\n\toverride canBeReused(model: ITextModel, position: Position): boolean {\n\t\t// TODO@hediet I believe this can be simplified to `return true;`, as applying an edit should kick out this suggestion.\n\t\tconst updatedRange = this._textEdit.range;\n\t\tconst result = !!updatedRange\n\t\t\t&& updatedRange.containsPosition(position)\n\t\t\t&& this.isVisible(model, position)\n\t\t\t&& TextLength.ofRange(updatedRange).isGreaterThanOrEqualTo(TextLength.ofRange(this._originalRange));\n\t\treturn result;\n\t}\n\n\tpublic isVisible(model: ITextModel, cursorPosition: Position): boolean {\n\t\tconst singleTextEdit = this.getSingleTextEdit();\n\t\treturn inlineCompletionIsVisible(singleTextEdit, this._originalRange, model, cursorPosition);\n\t}\n}\n\nexport function inlineCompletionIsVisible(singleTextEdit: TextReplacement, originalRange: Range | undefined, model: ITextModel, cursorPosition: Position): boolean {\n\tconst minimizedReplacement = singleTextRemoveCommonPrefix(singleTextEdit, model);\n\tconst editRange = singleTextEdit.range;\n\tif (!editRange\n\t\t|| (originalRange && !originalRange.getStartPosition().equals(editRange.getStartPosition()))\n\t\t|| cursorPosition.lineNumber !== minimizedReplacement.range.startLineNumber\n\t\t|| minimizedReplacement.isEmpty // if the completion is empty after removing the common prefix of the completion and the model, the completion item would not be visible\n\t) {\n\t\treturn false;\n\t}\n\n\t// We might consider comparing by .toLowerText, but this requires GhostTextReplacement\n\tconst originalValue = model.getValueInRange(minimizedReplacement.range, EndOfLinePreference.LF);\n\tconst filterText = minimizedReplacement.text;\n\n\tconst cursorPosIndex = Math.max(0, cursorPosition.column - minimizedReplacement.range.startColumn);\n\n\tlet filterTextBefore = filterText.substring(0, cursorPosIndex);\n\tlet filterTextAfter = filterText.substring(cursorPosIndex);\n\n\tlet originalValueBefore = originalValue.substring(0, cursorPosIndex);\n\tlet originalValueAfter = originalValue.substring(cursorPosIndex);\n\n\tconst originalValueIndent = model.getLineIndentColumn(minimizedReplacement.range.startLineNumber);\n\tif (minimizedReplacement.range.startColumn <= originalValueIndent) {\n\t\t// Remove indentation\n\t\toriginalValueBefore = originalValueBefore.trimStart();\n\t\tif (originalValueBefore.length === 0) {\n\t\t\toriginalValueAfter = originalValueAfter.trimStart();\n\t\t}\n\t\tfilterTextBefore = filterTextBefore.trimStart();\n\t\tif (filterTextBefore.length === 0) {\n\t\t\tfilterTextAfter = filterTextAfter.trimStart();\n\t\t}\n\t}\n\n\treturn filterTextBefore.startsWith(originalValueBefore)\n\t\t&& !!matchesSubString(originalValueAfter, filterTextAfter);\n}\n\nexport class InlineEditItem extends InlineSuggestionItemBase {\n\tpublic static create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: ITextModel,\n\t): InlineEditItem {\n\t\tconst offsetEdit = getStringEdit(textModel, data.range, data.insertText); // TODO compute async\n\t\tconst text = new TextModelText(textModel);\n\t\tconst textEdit = TextEdit.fromStringEdit(offsetEdit, text);\n\t\tconst singleTextEdit = offsetEdit.isEmpty() ? new TextReplacement(new Range(1, 1, 1, 1), '') : textEdit.toReplacement(text); // FIXME: .toReplacement() can throw because offsetEdit is empty because we get an empty diff in getStringEdit after diffing\n\t\tconst identity = new InlineSuggestionIdentity();\n\n\t\tconst edits = offsetEdit.replacements.map(edit => {\n\t\t\tconst replacedRange = Range.fromPositions(textModel.getPositionAt(edit.replaceRange.start), textModel.getPositionAt(edit.replaceRange.endExclusive));\n\t\t\tconst replacedText = textModel.getValueInRange(replacedRange);\n\t\t\treturn SingleUpdatedNextEdit.create(edit, replacedText);\n\t\t});\n\t\tconst hint = data.hint ? InlineSuggestHint.create(data.hint) : undefined;\n\t\treturn new InlineEditItem(offsetEdit, singleTextEdit, data.uri, data, identity, edits, hint, false, textModel.getVersionId());\n\t}\n\n\tpublic readonly snippetInfo: SnippetInfo | undefined = undefined;\n\tpublic readonly additionalTextEdits: readonly ISingleEditOperation[] = [];\n\tpublic readonly isInlineEdit = true;\n\n\tprivate constructor(\n\t\tprivate readonly _edit: StringEdit, // TODO@hediet remove, compute & cache from _edits\n\t\tprivate readonly _textEdit: TextReplacement,\n\t\tpublic readonly uri: URI | undefined,\n\n\t\tdata: InlineSuggestData,\n\n\t\tidentity: InlineSuggestionIdentity,\n\t\tprivate readonly _edits: readonly SingleUpdatedNextEdit[],\n\t\thint: InlineSuggestHint | undefined,\n\t\tprivate readonly _lastChangePartOfInlineEdit = false,\n\t\tprivate readonly _inlineEditModelVersion: number,\n\t) {\n\t\tsuper(data, identity, hint);\n\t}\n\n\tpublic get updatedEditModelVersion(): number { return this._inlineEditModelVersion; }\n\tpublic get updatedEdit(): StringEdit { return this._edit; }\n\n\toverride getSingleTextEdit(): TextReplacement {\n\t\treturn this._textEdit;\n\t}\n\n\toverride withIdentity(identity: InlineSuggestionIdentity): InlineEditItem {\n\t\treturn new InlineEditItem(\n\t\t\tthis._edit,\n\t\t\tthis._textEdit,\n\t\t\tthis.uri,\n\t\t\tthis._data,\n\t\t\tidentity,\n\t\t\tthis._edits,\n\t\t\tthis.hint,\n\t\t\tthis._lastChangePartOfInlineEdit,\n\t\t\tthis._inlineEditModelVersion,\n\t\t);\n\t}\n\n\toverride canBeReused(model: ITextModel, position: Position): boolean {\n\t\t// TODO@hediet I believe this can be simplified to `return true;`, as applying an edit should kick out this suggestion.\n\t\treturn this._lastChangePartOfInlineEdit && this.updatedEditModelVersion === model.getVersionId();\n\t}\n\n\toverride withEdit(textModelChanges: StringEdit, textModel: ITextModel): InlineEditItem | undefined {\n\t\tconst edit = this._applyTextModelChanges(textModelChanges, this._edits, textModel);\n\t\treturn edit;\n\t}\n\n\tprivate _applyTextModelChanges(textModelChanges: StringEdit, edits: readonly SingleUpdatedNextEdit[], textModel: ITextModel): InlineEditItem | undefined {\n\t\tedits = edits.map(innerEdit => innerEdit.applyTextModelChanges(textModelChanges));\n\n\t\tif (edits.some(edit => edit.edit === undefined)) {\n\t\t\treturn undefined; // change is invalid, so we will have to drop the completion\n\t\t}\n\n\t\tconst newTextModelVersion = textModel.getVersionId();\n\n\t\tlet inlineEditModelVersion = this._inlineEditModelVersion;\n\t\tconst lastChangePartOfInlineEdit = edits.some(edit => edit.lastChangeUpdatedEdit);\n\t\tif (lastChangePartOfInlineEdit) {\n\t\t\tinlineEditModelVersion = newTextModelVersion ?? -1;\n\t\t}\n\n\t\tif (newTextModelVersion === null || inlineEditModelVersion + 20 < newTextModelVersion) {\n\t\t\treturn undefined; // the completion has been ignored for a while, remove it\n\t\t}\n\n\t\tedits = edits.filter(innerEdit => !innerEdit.edit!.isEmpty);\n\t\tif (edits.length === 0) {\n\t\t\treturn undefined; // the completion has been typed by the user\n\t\t}\n\n\t\tconst newEdit = new StringEdit(edits.map(edit => edit.edit!));\n\t\tconst positionOffsetTransformer = getPositionOffsetTransformerFromTextModel(textModel);\n\t\tconst newTextEdit = positionOffsetTransformer.getTextEdit(newEdit).toReplacement(new TextModelText(textModel));\n\n\t\tlet newDisplayLocation = this.hint;\n\t\tif (newDisplayLocation) {\n\t\t\tnewDisplayLocation = newDisplayLocation.withEdit(textModelChanges, positionOffsetTransformer);\n\t\t\tif (!newDisplayLocation) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\treturn new InlineEditItem(\n\t\t\tnewEdit,\n\t\t\tnewTextEdit,\n\t\t\tthis.uri,\n\t\t\tthis._data,\n\t\t\tthis.identity,\n\t\t\tedits,\n\t\t\tnewDisplayLocation,\n\t\t\tlastChangePartOfInlineEdit,\n\t\t\tinlineEditModelVersion,\n\t\t);\n\t}\n}\n\nfunction getStringEdit(textModel: ITextModel, editRange: Range, replaceText: string): StringEdit {\n\tconst eol = textModel.getEOL();\n\tconst editOriginalText = textModel.getValueInRange(editRange);\n\tconst editReplaceText = replaceText.replace(/\\r\\n|\\r|\\n/g, eol);\n\n\tconst diffAlgorithm = linesDiffComputers.getDefault();\n\tconst lineDiffs = diffAlgorithm.computeDiff(\n\t\tsplitLines(editOriginalText),\n\t\tsplitLines(editReplaceText),\n\t\t{\n\t\t\tignoreTrimWhitespace: false,\n\t\t\tcomputeMoves: false,\n\t\t\textendToSubwords: true,\n\t\t\tmaxComputationTimeMs: 500,\n\t\t}\n\t);\n\n\tconst innerChanges = lineDiffs.changes.flatMap(c => c.innerChanges ?? []);\n\n\tfunction addRangeToPos(pos: Position, range: Range): Range {\n\t\tconst start = TextLength.fromPosition(range.getStartPosition());\n\t\treturn TextLength.ofRange(range).createRange(start.addToPosition(pos));\n\t}\n\n\tconst modifiedText = new StringText(editReplaceText);\n\n\tconst offsetEdit = new StringEdit(\n\t\tinnerChanges.map(c => {\n\t\t\tconst rangeInModel = addRangeToPos(editRange.getStartPosition(), c.originalRange);\n\t\t\tconst originalRange = getPositionOffsetTransformerFromTextModel(textModel).getOffsetRange(rangeInModel);\n\n\t\t\tconst replaceText = modifiedText.getValueOfRange(c.modifiedRange);\n\t\t\tconst edit = new StringReplacement(originalRange, replaceText);\n\n\t\t\tconst originalText = textModel.getValueInRange(rangeInModel);\n\t\t\treturn reshapeInlineEdit(edit, originalText, innerChanges.length, textModel);\n\t\t})\n\t);\n\n\treturn offsetEdit;\n}\n\nclass SingleUpdatedNextEdit {\n\tpublic static create(\n\t\tedit: StringReplacement,\n\t\treplacedText: string,\n\t): SingleUpdatedNextEdit {\n\t\tconst prefixLength = commonPrefixLength(edit.newText, replacedText);\n\t\tconst suffixLength = commonSuffixLength(edit.newText, replacedText);\n\t\tconst trimmedNewText = edit.newText.substring(prefixLength, edit.newText.length - suffixLength);\n\t\treturn new SingleUpdatedNextEdit(edit, trimmedNewText, prefixLength, suffixLength);\n\t}\n\n\tpublic get edit() { return this._edit; }\n\tpublic get lastChangeUpdatedEdit() { return this._lastChangeUpdatedEdit; }\n\n\tconstructor(\n\t\tprivate _edit: StringReplacement | undefined,\n\t\tprivate _trimmedNewText: string,\n\t\tprivate _prefixLength: number,\n\t\tprivate _suffixLength: number,\n\t\tprivate _lastChangeUpdatedEdit: boolean = false,\n\t) {\n\t}\n\n\tpublic applyTextModelChanges(textModelChanges: StringEdit) {\n\t\tconst c = this._clone();\n\t\tc._applyTextModelChanges(textModelChanges);\n\t\treturn c;\n\t}\n\n\tprivate _clone(): SingleUpdatedNextEdit {\n\t\treturn new SingleUpdatedNextEdit(\n\t\t\tthis._edit,\n\t\t\tthis._trimmedNewText,\n\t\t\tthis._prefixLength,\n\t\t\tthis._suffixLength,\n\t\t\tthis._lastChangeUpdatedEdit,\n\t\t);\n\t}\n\n\tprivate _applyTextModelChanges(textModelChanges: StringEdit) {\n\t\tthis._lastChangeUpdatedEdit = false; // TODO @benibenj make immutable\n\n\t\tif (!this._edit) {\n\t\t\tthrow new BugIndicatingError('UpdatedInnerEdits: No edit to apply changes to');\n\t\t}\n\n\t\tconst result = this._applyChanges(this._edit, textModelChanges);\n\t\tif (!result) {\n\t\t\tthis._edit = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._edit = result.edit;\n\t\tthis._lastChangeUpdatedEdit = result.editHasChanged;\n\t}\n\n\tprivate _applyChanges(edit: StringReplacement, textModelChanges: StringEdit): { edit: StringReplacement; editHasChanged: boolean } | undefined {\n\t\tlet editStart = edit.replaceRange.start;\n\t\tlet editEnd = edit.replaceRange.endExclusive;\n\t\tlet editReplaceText = edit.newText;\n\t\tlet editHasChanged = false;\n\n\t\tconst shouldPreserveEditShape = this._prefixLength > 0 || this._suffixLength > 0;\n\n\t\tfor (let i = textModelChanges.replacements.length - 1; i >= 0; i--) {\n\t\t\tconst change = textModelChanges.replacements[i];\n\n\t\t\t// INSERTIONS (only support inserting at start of edit)\n\t\t\tconst isInsertion = change.newText.length > 0 && change.replaceRange.isEmpty;\n\n\t\t\tif (isInsertion && !shouldPreserveEditShape && change.replaceRange.start === editStart && editReplaceText.startsWith(change.newText)) {\n\t\t\t\teditStart += change.newText.length;\n\t\t\t\teditReplaceText = editReplaceText.substring(change.newText.length);\n\t\t\t\teditEnd = Math.max(editStart, editEnd);\n\t\t\t\teditHasChanged = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (isInsertion && shouldPreserveEditShape && change.replaceRange.start === editStart + this._prefixLength && this._trimmedNewText.startsWith(change.newText)) {\n\t\t\t\teditEnd += change.newText.length;\n\t\t\t\teditHasChanged = true;\n\t\t\t\tthis._prefixLength += change.newText.length;\n\t\t\t\tthis._trimmedNewText = this._trimmedNewText.substring(change.newText.length);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// DELETIONS\n\t\t\tconst isDeletion = change.newText.length === 0 && change.replaceRange.length > 0;\n\t\t\tif (isDeletion && change.replaceRange.start >= editStart + this._prefixLength && change.replaceRange.endExclusive <= editEnd - this._suffixLength) {\n\t\t\t\t// user deleted text IN-BETWEEN the deletion range\n\t\t\t\teditEnd -= change.replaceRange.length;\n\t\t\t\teditHasChanged = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// user did exactly the edit\n\t\t\tif (change.equals(edit)) {\n\t\t\t\teditHasChanged = true;\n\t\t\t\teditStart = change.replaceRange.endExclusive;\n\t\t\t\teditReplaceText = '';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// MOVE EDIT\n\t\t\tif (change.replaceRange.start > editEnd) {\n\t\t\t\t// the change happens after the completion range\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (change.replaceRange.endExclusive < editStart) {\n\t\t\t\t// the change happens before the completion range\n\t\t\t\teditStart += change.newText.length - change.replaceRange.length;\n\t\t\t\teditEnd += change.newText.length - change.replaceRange.length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The change intersects the completion, so we will have to drop the completion\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// the resulting edit is a noop as the original and new text are the same\n\t\tif (this._trimmedNewText.length === 0 && editStart + this._prefixLength === editEnd - this._suffixLength) {\n\t\t\treturn { edit: new StringReplacement(new OffsetRange(editStart + this._prefixLength, editStart + this._prefixLength), ''), editHasChanged: true };\n\t\t}\n\n\t\treturn { edit: new StringReplacement(new OffsetRange(editStart, editEnd), editReplaceText), editHasChanged };\n\t}\n}\n\nfunction reshapeInlineCompletion(edit: StringReplacement, textModel: ITextModel): StringReplacement {\n\t// If the insertion is a multi line insertion starting on the next line\n\t// Move it forwards so that the multi line insertion starts on the current line\n\tconst eol = textModel.getEOL();\n\tif (edit.replaceRange.isEmpty && edit.newText.includes(eol)) {\n\t\tedit = reshapeMultiLineInsertion(edit, textModel);\n\t}\n\n\treturn edit;\n}\n\nfunction reshapeInlineEdit(edit: StringReplacement, originalText: string, totalInnerEdits: number, textModel: ITextModel): StringReplacement {\n\t// TODO: EOL are not properly trimmed by the diffAlgorithm #12680\n\tconst eol = textModel.getEOL();\n\tif (edit.newText.endsWith(eol) && originalText.endsWith(eol)) {\n\t\tedit = new StringReplacement(edit.replaceRange.deltaEnd(-eol.length), edit.newText.slice(0, -eol.length));\n\t}\n\n\t// INSERTION\n\t// If the insertion ends with a new line and is inserted at the start of a line which has text,\n\t// we move the insertion to the end of the previous line if possible\n\tif (totalInnerEdits === 1 && edit.replaceRange.isEmpty && edit.newText.includes(eol)) {\n\t\tconst startPosition = textModel.getPositionAt(edit.replaceRange.start);\n\t\tconst hasTextOnInsertionLine = textModel.getLineLength(startPosition.lineNumber) !== 0;\n\t\tif (hasTextOnInsertionLine) {\n\t\t\tedit = reshapeMultiLineInsertion(edit, textModel);\n\t\t}\n\t}\n\n\t// The diff algorithm extended a simple edit to the entire word\n\t// shrink it back to a simple edit if it is deletion/insertion only\n\tif (totalInnerEdits === 1) {\n\t\tconst prefixLength = commonPrefixLength(originalText, edit.newText);\n\t\tconst suffixLength = commonSuffixLength(originalText.slice(prefixLength), edit.newText.slice(prefixLength));\n\n\t\t// reshape it back to an insertion\n\t\tif (prefixLength + suffixLength === originalText.length) {\n\t\t\treturn new StringReplacement(edit.replaceRange.deltaStart(prefixLength).deltaEnd(-suffixLength), edit.newText.substring(prefixLength, edit.newText.length - suffixLength));\n\t\t}\n\n\t\t// reshape it back to a deletion\n\t\tif (prefixLength + suffixLength === edit.newText.length) {\n\t\t\treturn new StringReplacement(edit.replaceRange.deltaStart(prefixLength).deltaEnd(-suffixLength), '');\n\t\t}\n\t}\n\n\treturn edit;\n}\n\nfunction reshapeMultiLineInsertion(edit: StringReplacement, textModel: ITextModel): StringReplacement {\n\tif (!edit.replaceRange.isEmpty) {\n\t\tthrow new BugIndicatingError('Unexpected original range');\n\t}\n\n\tif (edit.replaceRange.start === 0) {\n\t\treturn edit;\n\t}\n\n\tconst eol = textModel.getEOL();\n\tconst startPosition = textModel.getPositionAt(edit.replaceRange.start);\n\tconst startColumn = startPosition.column;\n\tconst startLineNumber = startPosition.lineNumber;\n\n\t// If the insertion ends with a new line and is inserted at the start of a line which has text,\n\t// we move the insertion to the end of the previous line if possible\n\tif (startColumn === 1 && startLineNumber > 1 && edit.newText.endsWith(eol) && !edit.newText.startsWith(eol)) {\n\t\treturn new StringReplacement(edit.replaceRange.delta(-1), eol + edit.newText.slice(0, -eol.length));\n\t}\n\n\treturn edit;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { matchesSubString } from '../../../../../base/common/filters.js';\nimport { IObservable, ITransaction, observableSignal, observableValue } from '../../../../../base/common/observable.js';\nimport { commonPrefixLength, commonSuffixLength, splitLines } from '../../../../../base/common/strings.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { ICommandService } from '../../../../../platform/commands/common/commands.js';\nimport { ISingleEditOperation } from '../../../../common/core/editOperation.js';\nimport { applyEditsToRanges, StringEdit, StringReplacement } from '../../../../common/core/edits/stringEdit.js';\nimport { TextEdit, TextReplacement } from '../../../../common/core/edits/textEdit.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { OffsetRange } from '../../../../common/core/ranges/offsetRange.js';\nimport { StringText } from '../../../../common/core/text/abstractText.js';\nimport { getPositionOffsetTransformerFromTextModel } from '../../../../common/core/text/getPositionOffsetTransformerFromTextModel.js';\nimport { PositionOffsetTransformerBase } from '../../../../common/core/text/positionToOffset.js';\nimport { TextLength } from '../../../../common/core/text/textLength.js';\nimport { linesDiffComputers } from '../../../../common/diff/linesDiffComputers.js';\nimport { Command, InlineCompletion, InlineCompletionHintStyle, InlineCompletionEndOfLifeReason, InlineCompletionTriggerKind, InlineCompletionWarning, PartialAcceptInfo, InlineCompletionHint } from '../../../../common/languages.js';\nimport { EndOfLinePreference, ITextModel } from '../../../../common/model.js';\nimport { TextModelText } from '../../../../common/model/textModelText.js';\nimport { InlineCompletionViewData, InlineCompletionViewKind } from '../view/inlineEdits/inlineEditsViewInterface.js';\nimport { InlineSuggestData, InlineSuggestionList, PartialAcceptance, SnippetInfo } from './provideInlineCompletions.js';\nimport { singleTextRemoveCommonPrefix } from './singleTextEditHelpers.js';\n\nexport type InlineSuggestionItem = InlineEditItem | InlineCompletionItem;\n\nexport namespace InlineSuggestionItem {\n\texport function create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: ITextModel,\n\t): InlineSuggestionItem {\n\t\tif (!data.isInlineEdit && !data.uri) {\n\t\t\treturn InlineCompletionItem.create(data, textModel);\n\t\t} else {\n\t\t\treturn InlineEditItem.create(data, textModel);\n\t\t}\n\t}\n}\n\nabstract class InlineSuggestionItemBase {\n\tconstructor(\n\t\tprotected readonly _data: InlineSuggestData,\n\t\tpublic readonly identity: InlineSuggestionIdentity,\n\t\tpublic readonly hint: InlineSuggestHint | undefined\n\t) { }\n\n\t/**\n\t * A reference to the original inline completion list this inline completion has been constructed from.\n\t * Used for event data to ensure referential equality.\n\t*/\n\tpublic get source(): InlineSuggestionList { return this._data.source; }\n\n\tpublic get isFromExplicitRequest(): boolean { return this._data.context.triggerKind === InlineCompletionTriggerKind.Explicit; }\n\tpublic get forwardStable(): boolean { return this.source.inlineSuggestions.enableForwardStability ?? false; }\n\tpublic get editRange(): Range { return this.getSingleTextEdit().range; }\n\tpublic get targetRange(): Range { return this.hint?.range ?? this.editRange; }\n\tpublic get insertText(): string { return this.getSingleTextEdit().text; }\n\tpublic get semanticId(): string { return this.hash; }\n\tpublic get action(): Command | undefined { return this._sourceInlineCompletion.gutterMenuLinkAction; }\n\tpublic get command(): Command | undefined { return this._sourceInlineCompletion.command; }\n\tpublic get warning(): InlineCompletionWarning | undefined { return this._sourceInlineCompletion.warning; }\n\tpublic get showInlineEditMenu(): boolean { return !!this._sourceInlineCompletion.showInlineEditMenu; }\n\tpublic get hash() {\n\t\treturn JSON.stringify([\n\t\t\tthis.getSingleTextEdit().text,\n\t\t\tthis.getSingleTextEdit().range.getStartPosition().toString()\n\t\t]);\n\t}\n\t/** @deprecated */\n\tpublic get shownCommand(): Command | undefined { return this._sourceInlineCompletion.shownCommand; }\n\n\tpublic get requestUuid(): string { return this._data.context.requestUuid; }\n\n\tpublic get partialAccepts(): PartialAcceptance { return this._data.partialAccepts; }\n\n\t/**\n\t * A reference to the original inline completion this inline completion has been constructed from.\n\t * Used for event data to ensure referential equality.\n\t*/\n\tprivate get _sourceInlineCompletion(): InlineCompletion { return this._data.sourceInlineCompletion; }\n\n\n\tpublic abstract getSingleTextEdit(): TextReplacement;\n\n\tpublic abstract withEdit(userEdit: StringEdit, textModel: ITextModel): InlineSuggestionItem | undefined;\n\n\tpublic abstract withIdentity(identity: InlineSuggestionIdentity): InlineSuggestionItem;\n\tpublic abstract canBeReused(model: ITextModel, position: Position): boolean;\n\n\n\tpublic addRef(): void {\n\t\tthis.identity.addRef();\n\t\tthis.source.addRef();\n\t}\n\n\tpublic removeRef(): void {\n\t\tthis.identity.removeRef();\n\t\tthis.source.removeRef();\n\t}\n\n\tpublic reportInlineEditShown(commandService: ICommandService, viewKind: InlineCompletionViewKind, viewData: InlineCompletionViewData) {\n\t\tthis._data.reportInlineEditShown(commandService, this.insertText, viewKind, viewData);\n\t}\n\n\tpublic reportPartialAccept(acceptedCharacters: number, info: PartialAcceptInfo, partialAcceptance: PartialAcceptance) {\n\t\tthis._data.reportPartialAccept(acceptedCharacters, info, partialAcceptance);\n\t}\n\n\tpublic reportEndOfLife(reason: InlineCompletionEndOfLifeReason): void {\n\t\tthis._data.reportEndOfLife(reason);\n\t}\n\n\tpublic setEndOfLifeReason(reason: InlineCompletionEndOfLifeReason): void {\n\t\tthis._data.setEndOfLifeReason(reason);\n\t}\n\n\tpublic setIsPreceeded(item: InlineSuggestionItem): void {\n\t\tthis._data.setIsPreceeded(item.partialAccepts);\n\t}\n\n\tpublic setNotShownReasonIfNotSet(reason: string): void {\n\t\tthis._data.setNotShownReason(reason);\n\t}\n\n\t/**\n\t * Avoid using this method. Instead introduce getters for the needed properties.\n\t*/\n\tpublic getSourceCompletion(): InlineCompletion {\n\t\treturn this._sourceInlineCompletion;\n\t}\n}\n\nexport class InlineSuggestionIdentity {\n\tprivate static idCounter = 0;\n\tprivate readonly _onDispose = observableSignal(this);\n\tpublic readonly onDispose: IObservable<void> = this._onDispose;\n\n\tprivate readonly _jumpedTo = observableValue(this, false);\n\tpublic get jumpedTo(): IObservable<boolean> {\n\t\treturn this._jumpedTo;\n\t}\n\n\tprivate _refCount = 1;\n\tpublic readonly id = 'InlineCompletionIdentity' + InlineSuggestionIdentity.idCounter++;\n\n\taddRef() {\n\t\tthis._refCount++;\n\t}\n\n\tremoveRef() {\n\t\tthis._refCount--;\n\t\tif (this._refCount === 0) {\n\t\t\tthis._onDispose.trigger(undefined);\n\t\t}\n\t}\n\n\tsetJumpTo(tx: ITransaction | undefined): void {\n\t\tthis._jumpedTo.set(true, tx);\n\t}\n}\n\nexport class InlineSuggestHint {\n\n\tpublic static create(displayLocation: InlineCompletionHint) {\n\t\treturn new InlineSuggestHint(\n\t\t\tRange.lift(displayLocation.range),\n\t\t\tdisplayLocation.content,\n\t\t\tdisplayLocation.style,\n\t\t);\n\t}\n\n\tprivate constructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly content: string,\n\t\tpublic readonly style: InlineCompletionHintStyle,\n\t) { }\n\n\tpublic withEdit(edit: StringEdit, positionOffsetTransformer: PositionOffsetTransformerBase): InlineSuggestHint | undefined {\n\t\tconst offsetRange = new OffsetRange(\n\t\t\tpositionOffsetTransformer.getOffset(this.range.getStartPosition()),\n\t\t\tpositionOffsetTransformer.getOffset(this.range.getEndPosition())\n\t\t);\n\n\t\tconst newOffsetRange = applyEditsToRanges([offsetRange], edit)[0];\n\t\tif (!newOffsetRange) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst newRange = positionOffsetTransformer.getRange(newOffsetRange);\n\n\t\treturn new InlineSuggestHint(newRange, this.content, this.style);\n\t}\n}\n\nexport class InlineCompletionItem extends InlineSuggestionItemBase {\n\tpublic static create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: ITextModel,\n\t): InlineCompletionItem {\n\t\tconst identity = new InlineSuggestionIdentity();\n\t\tconst transformer = getPositionOffsetTransformerFromTextModel(textModel);\n\n\t\tconst insertText = data.insertText.replace(/\\r\\n|\\r|\\n/g, textModel.getEOL());\n\n\t\tconst edit = reshapeInlineCompletion(new StringReplacement(transformer.getOffsetRange(data.range), insertText), textModel);\n\t\tconst trimmedEdit = edit.removeCommonSuffixAndPrefix(textModel.getValue());\n\t\tconst textEdit = transformer.getTextReplacement(edit);\n\n\t\tconst displayLocation = data.hint ? InlineSuggestHint.create(data.hint) : undefined;\n\n\t\treturn new InlineCompletionItem(edit, trimmedEdit, textEdit, textEdit.range, data.snippetInfo, data.additionalTextEdits, data, identity, displayLocation);\n\t}\n\n\tpublic readonly isInlineEdit = false;\n\n\tprivate constructor(\n\t\tprivate readonly _edit: StringReplacement,\n\t\tprivate readonly _trimmedEdit: StringReplacement,\n\t\tprivate readonly _textEdit: TextReplacement,\n\t\tprivate readonly _originalRange: Range,\n\t\tpublic readonly snippetInfo: SnippetInfo | undefined,\n\t\tpublic readonly additionalTextEdits: readonly ISingleEditOperation[],\n\n\t\tdata: InlineSuggestData,\n\t\tidentity: InlineSuggestionIdentity,\n\t\tdisplayLocation: InlineSuggestHint | undefined,\n\t) {\n\t\tsuper(data, identity, displayLocation);\n\t}\n\n\toverride get hash(): string {\n\t\treturn JSON.stringify(this._trimmedEdit.toJson());\n\t}\n\n\toverride getSingleTextEdit(): TextReplacement { return this._textEdit; }\n\n\toverride withIdentity(identity: InlineSuggestionIdentity): InlineCompletionItem {\n\t\treturn new InlineCompletionItem(\n\t\t\tthis._edit,\n\t\t\tthis._trimmedEdit,\n\t\t\tthis._textEdit,\n\t\t\tthis._originalRange,\n\t\t\tthis.snippetInfo,\n\t\t\tthis.additionalTextEdits,\n\t\t\tthis._data,\n\t\t\tidentity,\n\t\t\tthis.hint\n\t\t);\n\t}\n\n\toverride withEdit(textModelEdit: StringEdit, textModel: ITextModel): InlineCompletionItem | undefined {\n\t\tconst newEditRange = applyEditsToRanges([this._edit.replaceRange], textModelEdit);\n\t\tif (newEditRange.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst newEdit = new StringReplacement(newEditRange[0], this._textEdit.text);\n\t\tconst positionOffsetTransformer = getPositionOffsetTransformerFromTextModel(textModel);\n\t\tconst newTextEdit = positionOffsetTransformer.getTextReplacement(newEdit);\n\n\t\tlet newDisplayLocation = this.hint;\n\t\tif (newDisplayLocation) {\n\t\t\tnewDisplayLocation = newDisplayLocation.withEdit(textModelEdit, positionOffsetTransformer);\n\t\t\tif (!newDisplayLocation) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\tconst trimmedEdit = newEdit.removeCommonSuffixAndPrefix(textModel.getValue());\n\n\t\treturn new InlineCompletionItem(\n\t\t\tnewEdit,\n\t\t\ttrimmedEdit,\n\t\t\tnewTextEdit,\n\t\t\tthis._originalRange,\n\t\t\tthis.snippetInfo,\n\t\t\tthis.additionalTextEdits,\n\t\t\tthis._data,\n\t\t\tthis.identity,\n\t\t\tnewDisplayLocation\n\t\t);\n\t}\n\n\toverride canBeReused(model: ITextModel, position: Position): boolean {\n\t\t// TODO@hediet I believe this can be simplified to `return true;`, as applying an edit should kick out this suggestion.\n\t\tconst updatedRange = this._textEdit.range;\n\t\tconst result = !!updatedRange\n\t\t\t&& updatedRange.containsPosition(position)\n\t\t\t&& this.isVisible(model, position)\n\t\t\t&& TextLength.ofRange(updatedRange).isGreaterThanOrEqualTo(TextLength.ofRange(this._originalRange));\n\t\treturn result;\n\t}\n\n\tpublic isVisible(model: ITextModel, cursorPosition: Position): boolean {\n\t\tconst singleTextEdit = this.getSingleTextEdit();\n\t\treturn inlineCompletionIsVisible(singleTextEdit, this._originalRange, model, cursorPosition);\n\t}\n}\n\nexport function inlineCompletionIsVisible(singleTextEdit: TextReplacement, originalRange: Range | undefined, model: ITextModel, cursorPosition: Position): boolean {\n\tconst minimizedReplacement = singleTextRemoveCommonPrefix(singleTextEdit, model);\n\tconst editRange = singleTextEdit.range;\n\tif (!editRange\n\t\t|| (originalRange && !originalRange.getStartPosition().equals(editRange.getStartPosition()))\n\t\t|| cursorPosition.lineNumber !== minimizedReplacement.range.startLineNumber\n\t\t|| minimizedReplacement.isEmpty // if the completion is empty after removing the common prefix of the completion and the model, the completion item would not be visible\n\t) {\n\t\treturn false;\n\t}\n\n\t// We might consider comparing by .toLowerText, but this requires GhostTextReplacement\n\tconst originalValue = model.getValueInRange(minimizedReplacement.range, EndOfLinePreference.LF);\n\tconst filterText = minimizedReplacement.text;\n\n\tconst cursorPosIndex = Math.max(0, cursorPosition.column - minimizedReplacement.range.startColumn);\n\n\tlet filterTextBefore = filterText.substring(0, cursorPosIndex);\n\tlet filterTextAfter = filterText.substring(cursorPosIndex);\n\n\tlet originalValueBefore = originalValue.substring(0, cursorPosIndex);\n\tlet originalValueAfter = originalValue.substring(cursorPosIndex);\n\n\tconst originalValueIndent = model.getLineIndentColumn(minimizedReplacement.range.startLineNumber);\n\tif (minimizedReplacement.range.startColumn <= originalValueIndent) {\n\t\t// Remove indentation\n\t\toriginalValueBefore = originalValueBefore.trimStart();\n\t\tif (originalValueBefore.length === 0) {\n\t\t\toriginalValueAfter = originalValueAfter.trimStart();\n\t\t}\n\t\tfilterTextBefore = filterTextBefore.trimStart();\n\t\tif (filterTextBefore.length === 0) {\n\t\t\tfilterTextAfter = filterTextAfter.trimStart();\n\t\t}\n\t}\n\n\treturn filterTextBefore.startsWith(originalValueBefore)\n\t\t&& !!matchesSubString(originalValueAfter, filterTextAfter);\n}\n\nexport class InlineEditItem extends InlineSuggestionItemBase {\n\tpublic static create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: ITextModel,\n\t): InlineEditItem {\n\t\tconst offsetEdit = getStringEdit(textModel, data.range, data.insertText); // TODO compute async\n\t\tconst text = new TextModelText(textModel);\n\t\tconst textEdit = TextEdit.fromStringEdit(offsetEdit, text);\n\t\tconst singleTextEdit = offsetEdit.isEmpty() ? new TextReplacement(new Range(1, 1, 1, 1), '') : textEdit.toReplacement(text); // FIXME: .toReplacement() can throw because offsetEdit is empty because we get an empty diff in getStringEdit after diffing\n\t\tconst identity = new InlineSuggestionIdentity();\n\n\t\tconst edits = offsetEdit.replacements.map(edit => {\n\t\t\tconst replacedRange = Range.fromPositions(textModel.getPositionAt(edit.replaceRange.start), textModel.getPositionAt(edit.replaceRange.endExclusive));\n\t\t\tconst replacedText = textModel.getValueInRange(replacedRange);\n\t\t\treturn SingleUpdatedNextEdit.create(edit, replacedText);\n\t\t});\n\t\tconst hint = data.hint ? InlineSuggestHint.create(data.hint) : undefined;\n\t\treturn new InlineEditItem(offsetEdit, singleTextEdit, data.uri, data, identity, edits, hint, false, textModel.getVersionId());\n\t}\n\n\tpublic readonly snippetInfo: SnippetInfo | undefined = undefined;\n\tpublic readonly additionalTextEdits: readonly ISingleEditOperation[] = [];\n\tpublic readonly isInlineEdit = true;\n\n\tprivate constructor(\n\t\tprivate readonly _edit: StringEdit, // TODO@hediet remove, compute & cache from _edits\n\t\tprivate readonly _textEdit: TextReplacement,\n\t\tpublic readonly uri: URI | undefined,\n\n\t\tdata: InlineSuggestData,\n\n\t\tidentity: InlineSuggestionIdentity,\n\t\tprivate readonly _edits: readonly SingleUpdatedNextEdit[],\n\t\thint: InlineSuggestHint | undefined,\n\t\tprivate readonly _lastChangePartOfInlineEdit = false,\n\t\tprivate readonly _inlineEditModelVersion: number,\n\t) {\n\t\tsuper(data, identity, hint);\n\t}\n\n\tpublic get updatedEditModelVersion(): number { return this._inlineEditModelVersion; }\n\tpublic get updatedEdit(): StringEdit { return this._edit; }\n\n\toverride getSingleTextEdit(): TextReplacement {\n\t\treturn this._textEdit;\n\t}\n\n\toverride withIdentity(identity: InlineSuggestionIdentity): InlineEditItem {\n\t\treturn new InlineEditItem(\n\t\t\tthis._edit,\n\t\t\tthis._textEdit,\n\t\t\tthis.uri,\n\t\t\tthis._data,\n\t\t\tidentity,\n\t\t\tthis._edits,\n\t\t\tthis.hint,\n\t\t\tthis._lastChangePartOfInlineEdit,\n\t\t\tthis._inlineEditModelVersion,\n\t\t);\n\t}\n\n\toverride canBeReused(model: ITextModel, position: Position): boolean {\n\t\t// TODO@hediet I believe this can be simplified to `return true;`, as applying an edit should kick out this suggestion.\n\t\treturn this._lastChangePartOfInlineEdit && this.updatedEditModelVersion === model.getVersionId();\n\t}\n\n\toverride withEdit(textModelChanges: StringEdit, textModel: ITextModel): InlineEditItem | undefined {\n\t\tconst edit = this._applyTextModelChanges(textModelChanges, this._edits, textModel);\n\t\treturn edit;\n\t}\n\n\tprivate _applyTextModelChanges(textModelChanges: StringEdit, edits: readonly SingleUpdatedNextEdit[], textModel: ITextModel): InlineEditItem | undefined {\n\t\tedits = edits.map(innerEdit => innerEdit.applyTextModelChanges(textModelChanges));\n\n\t\tif (edits.some(edit => edit.edit === undefined)) {\n\t\t\treturn undefined; // change is invalid, so we will have to drop the completion\n\t\t}\n\n\t\tconst newTextModelVersion = textModel.getVersionId();\n\n\t\tlet inlineEditModelVersion = this._inlineEditModelVersion;\n\t\tconst lastChangePartOfInlineEdit = edits.some(edit => edit.lastChangeUpdatedEdit);\n\t\tif (lastChangePartOfInlineEdit) {\n\t\t\tinlineEditModelVersion = newTextModelVersion ?? -1;\n\t\t}\n\n\t\tif (newTextModelVersion === null || inlineEditModelVersion + 20 < newTextModelVersion) {\n\t\t\treturn undefined; // the completion has been ignored for a while, remove it\n\t\t}\n\n\t\tedits = edits.filter(innerEdit => !innerEdit.edit!.isEmpty);\n\t\tif (edits.length === 0) {\n\t\t\treturn undefined; // the completion has been typed by the user\n\t\t}\n\n\t\tconst newEdit = new StringEdit(edits.map(edit => edit.edit!));\n\t\tconst positionOffsetTransformer = getPositionOffsetTransformerFromTextModel(textModel);\n\t\tconst newTextEdit = positionOffsetTransformer.getTextEdit(newEdit).toReplacement(new TextModelText(textModel));\n\n\t\tlet newDisplayLocation = this.hint;\n\t\tif (newDisplayLocation) {\n\t\t\tnewDisplayLocation = newDisplayLocation.withEdit(textModelChanges, positionOffsetTransformer);\n\t\t\tif (!newDisplayLocation) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\treturn new InlineEditItem(\n\t\t\tnewEdit,\n\t\t\tnewTextEdit,\n\t\t\tthis.uri,\n\t\t\tthis._data,\n\t\t\tthis.identity,\n\t\t\tedits,\n\t\t\tnewDisplayLocation,\n\t\t\tlastChangePartOfInlineEdit,\n\t\t\tinlineEditModelVersion,\n\t\t);\n\t}\n}\n\nfunction getStringEdit(textModel: ITextModel, editRange: Range, replaceText: string): StringEdit {\n\tconst eol = textModel.getEOL();\n\tconst editOriginalText = textModel.getValueInRange(editRange);\n\tconst editReplaceText = replaceText.replace(/\\r\\n|\\r|\\n/g, eol);\n\n\tconst diffAlgorithm = linesDiffComputers.getDefault();\n\tconst lineDiffs = diffAlgorithm.computeDiff(\n\t\tsplitLines(editOriginalText),\n\t\tsplitLines(editReplaceText),\n\t\t{\n\t\t\tignoreTrimWhitespace: false,\n\t\t\tcomputeMoves: false,\n\t\t\textendToSubwords: true,\n\t\t\tmaxComputationTimeMs: 500,\n\t\t}\n\t);\n\n\tconst innerChanges = lineDiffs.changes.flatMap(c => c.innerChanges ?? []);\n\n\tfunction addRangeToPos(pos: Position, range: Range): Range {\n\t\tconst start = TextLength.fromPosition(range.getStartPosition());\n\t\treturn TextLength.ofRange(range).createRange(start.addToPosition(pos));\n\t}\n\n\tconst modifiedText = new StringText(editReplaceText);\n\n\tconst offsetEdit = new StringEdit(\n\t\tinnerChanges.map(c => {\n\t\t\tconst rangeInModel = addRangeToPos(editRange.getStartPosition(), c.originalRange);\n\t\t\tconst originalRange = getPositionOffsetTransformerFromTextModel(textModel).getOffsetRange(rangeInModel);\n\n\t\t\tconst replaceText = modifiedText.getValueOfRange(c.modifiedRange);\n\t\t\tconst edit = new StringReplacement(originalRange, replaceText);\n\n\t\t\tconst originalText = textModel.getValueInRange(rangeInModel);\n\t\t\treturn reshapeInlineEdit(edit, originalText, innerChanges.length, textModel);\n\t\t})\n\t);\n\n\treturn offsetEdit;\n}\n\nclass SingleUpdatedNextEdit {\n\tpublic static create(\n\t\tedit: StringReplacement,\n\t\treplacedText: string,\n\t): SingleUpdatedNextEdit {\n\t\tconst prefixLength = commonPrefixLength(edit.newText, replacedText);\n\t\tconst suffixLength = commonSuffixLength(edit.newText, replacedText);\n\t\tconst trimmedNewText = edit.newText.substring(prefixLength, edit.newText.length - suffixLength);\n\t\treturn new SingleUpdatedNextEdit(edit, trimmedNewText, prefixLength, suffixLength);\n\t}\n\n\tpublic get edit() { return this._edit; }\n\tpublic get lastChangeUpdatedEdit() { return this._lastChangeUpdatedEdit; }\n\n\tconstructor(\n\t\tprivate _edit: StringReplacement | undefined,\n\t\tprivate _trimmedNewText: string,\n\t\tprivate _prefixLength: number,\n\t\tprivate _suffixLength: number,\n\t\tprivate _lastChangeUpdatedEdit: boolean = false,\n\t) {\n\t}\n\n\tpublic applyTextModelChanges(textModelChanges: StringEdit) {\n\t\tconst c = this._clone();\n\t\tc._applyTextModelChanges(textModelChanges);\n\t\treturn c;\n\t}\n\n\tprivate _clone(): SingleUpdatedNextEdit {\n\t\treturn new SingleUpdatedNextEdit(\n\t\t\tthis._edit,\n\t\t\tthis._trimmedNewText,\n\t\t\tthis._prefixLength,\n\t\t\tthis._suffixLength,\n\t\t\tthis._lastChangeUpdatedEdit,\n\t\t);\n\t}\n\n\tprivate _applyTextModelChanges(textModelChanges: StringEdit) {\n\t\tthis._lastChangeUpdatedEdit = false; // TODO @benibenj make immutable\n\n\t\tif (!this._edit) {\n\t\t\tthrow new BugIndicatingError('UpdatedInnerEdits: No edit to apply changes to');\n\t\t}\n\n\t\tconst result = this._applyChanges(this._edit, textModelChanges);\n\t\tif (!result) {\n\t\t\tthis._edit = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._edit = result.edit;\n\t\tthis._lastChangeUpdatedEdit = result.editHasChanged;\n\t}\n\n\tprivate _applyChanges(edit: StringReplacement, textModelChanges: StringEdit): { edit: StringReplacement; editHasChanged: boolean } | undefined {\n\t\tlet editStart = edit.replaceRange.start;\n\t\tlet editEnd = edit.replaceRange.endExclusive;\n\t\tlet editReplaceText = edit.newText;\n\t\tlet editHasChanged = false;\n\n\t\tconst shouldPreserveEditShape = this._prefixLength > 0 || this._suffixLength > 0;\n\n\t\tfor (let i = textModelChanges.replacements.length - 1; i >= 0; i--) {\n\t\t\tconst change = textModelChanges.replacements[i];\n\n\t\t\t// INSERTIONS (only support inserting at start of edit)\n\t\t\tconst isInsertion = change.newText.length > 0 && change.replaceRange.isEmpty;\n\n\t\t\tif (isInsertion && !shouldPreserveEditShape && change.replaceRange.start === editStart && editReplaceText.startsWith(change.newText)) {\n\t\t\t\teditStart += change.newText.length;\n\t\t\t\teditReplaceText = editReplaceText.substring(change.newText.length);\n\t\t\t\teditEnd = Math.max(editStart, editEnd);\n\t\t\t\teditHasChanged = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (isInsertion && shouldPreserveEditShape && change.replaceRange.start === editStart + this._prefixLength && this._trimmedNewText.startsWith(change.newText)) {\n\t\t\t\teditEnd += change.newText.length;\n\t\t\t\teditHasChanged = true;\n\t\t\t\tthis._prefixLength += change.newText.length;\n\t\t\t\tthis._trimmedNewText = this._trimmedNewText.substring(change.newText.length);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// DELETIONS\n\t\t\tconst isDeletion = change.newText.length === 0 && change.replaceRange.length > 0;\n\t\t\tif (isDeletion && change.replaceRange.start >= editStart + this._prefixLength && change.replaceRange.endExclusive <= editEnd - this._suffixLength) {\n\t\t\t\t// user deleted text IN-BETWEEN the deletion range\n\t\t\t\teditEnd -= change.replaceRange.length;\n\t\t\t\teditHasChanged = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// user did exactly the edit\n\t\t\tif (change.equals(edit)) {\n\t\t\t\teditHasChanged = true;\n\t\t\t\teditStart = change.replaceRange.endExclusive;\n\t\t\t\teditReplaceText = '';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// MOVE EDIT\n\t\t\tif (change.replaceRange.start > editEnd) {\n\t\t\t\t// the change happens after the completion range\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (change.replaceRange.endExclusive < editStart) {\n\t\t\t\t// the change happens before the completion range\n\t\t\t\teditStart += change.newText.length - change.replaceRange.length;\n\t\t\t\teditEnd += change.newText.length - change.replaceRange.length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The change intersects the completion, so we will have to drop the completion\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// the resulting edit is a noop as the original and new text are the same\n\t\tif (this._trimmedNewText.length === 0 && editStart + this._prefixLength === editEnd - this._suffixLength) {\n\t\t\treturn { edit: new StringReplacement(new OffsetRange(editStart + this._prefixLength, editStart + this._prefixLength), ''), editHasChanged: true };\n\t\t}\n\n\t\treturn { edit: new StringReplacement(new OffsetRange(editStart, editEnd), editReplaceText), editHasChanged };\n\t}\n}\n\nfunction reshapeInlineCompletion(edit: StringReplacement, textModel: ITextModel): StringReplacement {\n\t// If the insertion is a multi line insertion starting on the next line\n\t// Move it forwards so that the multi line insertion starts on the current line\n\tconst eol = textModel.getEOL();\n\tif (edit.replaceRange.isEmpty && edit.newText.includes(eol)) {\n\t\tedit = reshapeMultiLineInsertion(edit, textModel);\n\t}\n\n\treturn edit;\n}\n\nfunction reshapeInlineEdit(edit: StringReplacement, originalText: string, totalInnerEdits: number, textModel: ITextModel): StringReplacement {\n\t// TODO: EOL are not properly trimmed by the diffAlgorithm #12680\n\tconst eol = textModel.getEOL();\n\tif (edit.newText.endsWith(eol) && originalText.endsWith(eol)) {\n\t\tedit = new StringReplacement(edit.replaceRange.deltaEnd(-eol.length), edit.newText.slice(0, -eol.length));\n\t}\n\n\t// INSERTION\n\t// If the insertion ends with a new line and is inserted at the start of a line which has text,\n\t// we move the insertion to the end of the previous line if possible\n\tif (totalInnerEdits === 1 && edit.replaceRange.isEmpty && edit.newText.includes(eol)) {\n\t\tconst startPosition = textModel.getPositionAt(edit.replaceRange.start);\n\t\tconst hasTextOnInsertionLine = textModel.getLineLength(startPosition.lineNumber) !== 0;\n\t\tif (hasTextOnInsertionLine) {\n\t\t\tedit = reshapeMultiLineInsertion(edit, textModel);\n\t\t}\n\t}\n\n\t// The diff algorithm extended a simple edit to the entire word\n\t// shrink it back to a simple edit if it is deletion/insertion only\n\tif (totalInnerEdits === 1) {\n\t\tconst prefixLength = commonPrefixLength(originalText, edit.newText);\n\t\tconst suffixLength = commonSuffixLength(originalText.slice(prefixLength), edit.newText.slice(prefixLength));\n\n\t\t// reshape it back to an insertion\n\t\tif (prefixLength + suffixLength === originalText.length) {\n\t\t\treturn new StringReplacement(edit.replaceRange.deltaStart(prefixLength).deltaEnd(-suffixLength), edit.newText.substring(prefixLength, edit.newText.length - suffixLength));\n\t\t}\n\n\t\t// reshape it back to a deletion\n\t\tif (prefixLength + suffixLength === edit.newText.length) {\n\t\t\treturn new StringReplacement(edit.replaceRange.deltaStart(prefixLength).deltaEnd(-suffixLength), '');\n\t\t}\n\t}\n\n\treturn edit;\n}\n\nfunction reshapeMultiLineInsertion(edit: StringReplacement, textModel: ITextModel): StringReplacement {\n\tif (!edit.replaceRange.isEmpty) {\n\t\tthrow new BugIndicatingError('Unexpected original range');\n\t}\n\n\tif (edit.replaceRange.start === 0) {\n\t\treturn edit;\n\t}\n\n\tconst eol = textModel.getEOL();\n\tconst startPosition = textModel.getPositionAt(edit.replaceRange.start);\n\tconst startColumn = startPosition.column;\n\tconst startLineNumber = startPosition.lineNumber;\n\n\t// If the insertion ends with a new line and is inserted at the start of a line which has text,\n\t// we move the insertion to the end of the previous line if possible\n\tif (startColumn === 1 && startLineNumber > 1 && edit.newText.endsWith(eol) && !edit.newText.startsWith(eol)) {\n\t\treturn new StringReplacement(edit.replaceRange.delta(-1), eol + edit.newText.slice(0, -eol.length));\n\t}\n\n\treturn edit;\n}\n"]}