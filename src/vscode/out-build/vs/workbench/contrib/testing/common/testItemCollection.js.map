{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/common/testItemCollection.ts","vs/workbench/contrib/testing/common/testItemCollection.ts"],"names":[],"mappings":"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","file":"testItemCollection.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Barrier, isThenable, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { assertNever } from '../../../../base/common/assert.js';\nimport { applyTestItemUpdate, ITestItem, ITestTag, namespaceTestTag, TestDiffOpType, TestItemExpandState, TestsDiff, TestsDiffOp } from './testTypes.js';\nimport { TestId } from './testId.js';\nimport { URI } from '../../../../base/common/uri.js';\n\n/**\n * @private\n */\ninterface CollectionItem<T> {\n\treadonly fullId: TestId;\n\tactual: T;\n\texpand: TestItemExpandState;\n\t/**\n\t * Number of levels of items below this one that are expanded. May be infinite.\n\t */\n\texpandLevels?: number;\n\tresolveBarrier?: Barrier;\n}\n\nexport const enum TestItemEventOp {\n\tUpsert,\n\tSetTags,\n\tUpdateCanResolveChildren,\n\tRemoveChild,\n\tSetProp,\n\tBulk,\n\tDocumentSynced,\n}\n\nexport interface ITestItemUpsertChild {\n\top: TestItemEventOp.Upsert;\n\titem: ITestItemLike;\n}\n\nexport interface ITestItemUpdateCanResolveChildren {\n\top: TestItemEventOp.UpdateCanResolveChildren;\n\tstate: boolean;\n}\n\nexport interface ITestItemSetTags {\n\top: TestItemEventOp.SetTags;\n\tnew: ITestTag[];\n\told: ITestTag[];\n}\n\nexport interface ITestItemRemoveChild {\n\top: TestItemEventOp.RemoveChild;\n\tid: string;\n}\n\nexport interface ITestItemSetProp {\n\top: TestItemEventOp.SetProp;\n\tupdate: Partial<ITestItem>;\n}\nexport interface ITestItemBulkReplace {\n\top: TestItemEventOp.Bulk;\n\tops: (ITestItemUpsertChild | ITestItemRemoveChild)[];\n}\n\nexport interface ITestItemDocumentSynced {\n\top: TestItemEventOp.DocumentSynced;\n}\n\nexport type ExtHostTestItemEvent =\n\t| ITestItemSetTags\n\t| ITestItemUpsertChild\n\t| ITestItemRemoveChild\n\t| ITestItemUpdateCanResolveChildren\n\t| ITestItemSetProp\n\t| ITestItemBulkReplace\n\t| ITestItemDocumentSynced;\n\nexport interface ITestItemApi<T> {\n\tcontrollerId: string;\n\tparent?: T;\n\tlistener?: (evt: ExtHostTestItemEvent) => void;\n}\n\nexport interface ITestItemCollectionOptions<T> {\n\t/** Controller ID to use to prefix these test items. */\n\tcontrollerId: string;\n\n\t/** Gets the document version at the given URI, if it's open */\n\tgetDocumentVersion(uri: URI | undefined): number | undefined;\n\n\t/** Gets API for the given test item, used to listen for events and set parents. */\n\tgetApiFor(item: T): ITestItemApi<T>;\n\n\t/** Converts the full test item to the common interface. */\n\ttoITestItem(item: T): ITestItem;\n\n\t/** Gets children for the item. */\n\tgetChildren(item: T): ITestChildrenLike<T>;\n\n\t/** Root to use for the new test collection. */\n\troot: T;\n}\n\nconst strictEqualComparator = <T>(a: T, b: T) => a === b;\nconst diffableProps: { [K in keyof ITestItem]?: (a: ITestItem[K], b: ITestItem[K]) => boolean } = {\n\trange: (a, b) => {\n\t\tif (a === b) { return true; }\n\t\tif (!a || !b) { return false; }\n\t\treturn a.equalsRange(b);\n\t},\n\tbusy: strictEqualComparator,\n\tlabel: strictEqualComparator,\n\tdescription: strictEqualComparator,\n\terror: strictEqualComparator,\n\tsortText: strictEqualComparator,\n\ttags: (a, b) => {\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (a.some(t1 => !b.includes(t1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n};\n\nconst diffableEntries = Object.entries(diffableProps) as readonly [keyof ITestItem, (a: any, b: any) => boolean][];\n\nconst diffTestItems = (a: ITestItem, b: ITestItem) => {\n\tlet output: Record<string, unknown> | undefined;\n\tfor (const [key, cmp] of diffableEntries) {\n\t\tif (!cmp(a[key], b[key])) {\n\t\t\tif (output) {\n\t\t\t\toutput[key] = b[key];\n\t\t\t} else {\n\t\t\t\toutput = { [key]: b[key] };\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output as Partial<ITestItem> | undefined;\n};\n\nexport interface ITestChildrenLike<T> extends Iterable<[string, T]> {\n\tget(id: string): T | undefined;\n\tdelete(id: string): void;\n}\n\nexport interface ITestItemLike {\n\tid: string;\n\ttags: readonly ITestTag[];\n\turi?: URI;\n\tcanResolveChildren: boolean;\n}\n\n/**\n * Maintains a collection of test items for a single controller.\n */\nexport class TestItemCollection<T extends ITestItemLike> extends Disposable {\n\tprivate readonly debounceSendDiff = this._register(new RunOnceScheduler(() => this.flushDiff(), 200));\n\tprivate readonly diffOpEmitter = this._register(new Emitter<TestsDiff>());\n\tprivate _resolveHandler?: (item: T | undefined) => Promise<void> | void;\n\n\tpublic get root() {\n\t\treturn this.options.root;\n\t}\n\n\tpublic readonly tree = new Map</* full test id */string, CollectionItem<T>>();\n\tprivate readonly tags = new Map<string, { label?: string; refCount: number }>();\n\n\tprotected diff: TestsDiff = [];\n\n\tconstructor(private readonly options: ITestItemCollectionOptions<T>) {\n\t\tsuper();\n\t\tthis.root.canResolveChildren = true;\n\t\tthis.upsertItem(this.root, undefined);\n\t}\n\n\t/**\n\t * Handler used for expanding test items.\n\t */\n\tpublic set resolveHandler(handler: undefined | ((item: T | undefined) => void)) {\n\t\tthis._resolveHandler = handler;\n\t\tfor (const test of this.tree.values()) {\n\t\t\tthis.updateExpandability(test);\n\t\t}\n\t}\n\n\tpublic get resolveHandler() {\n\t\treturn this._resolveHandler;\n\t}\n\n\t/**\n\t * Fires when an operation happens that should result in a diff.\n\t */\n\tpublic readonly onDidGenerateDiff = this.diffOpEmitter.event;\n\n\t/**\n\t * Gets a diff of all changes that have been made, and clears the diff queue.\n\t */\n\tpublic collectDiff() {\n\t\tconst diff = this.diff;\n\t\tthis.diff = [];\n\t\treturn diff;\n\t}\n\n\t/**\n\t * Pushes a new diff entry onto the collected diff list.\n\t */\n\tpublic pushDiff(diff: TestsDiffOp) {\n\t\tswitch (diff.op) {\n\t\t\tcase TestDiffOpType.DocumentSynced: {\n\t\t\t\tfor (const existing of this.diff) {\n\t\t\t\t\tif (existing.op === TestDiffOpType.DocumentSynced && existing.uri === diff.uri) {\n\t\t\t\t\t\texisting.docv = diff.docv;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase TestDiffOpType.Update: {\n\t\t\t\t// Try to merge updates, since they're invoked per-property\n\t\t\t\tconst last = this.diff[this.diff.length - 1];\n\t\t\t\tif (last) {\n\t\t\t\t\tif (last.op === TestDiffOpType.Update && last.item.extId === diff.item.extId) {\n\t\t\t\t\t\tapplyTestItemUpdate(last.item, diff.item);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (last.op === TestDiffOpType.Add && last.item.item.extId === diff.item.extId) {\n\t\t\t\t\t\tapplyTestItemUpdate(last.item, diff.item);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.diff.push(diff);\n\n\t\tif (!this.debounceSendDiff.isScheduled()) {\n\t\t\tthis.debounceSendDiff.schedule();\n\t\t}\n\t}\n\n\t/**\n\t * Expands the test and the given number of `levels` of children. If levels\n\t * is < 0, then all children will be expanded. If it's 0, then only this\n\t * item will be expanded.\n\t */\n\tpublic expand(testId: string, levels: number): Promise<void> | void {\n\t\tconst internal = this.tree.get(testId);\n\t\tif (!internal) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (internal.expandLevels === undefined || levels > internal.expandLevels) {\n\t\t\tinternal.expandLevels = levels;\n\t\t}\n\n\t\t// try to avoid awaiting things if the provider returns synchronously in\n\t\t// order to keep everything in a single diff and DOM update.\n\t\tif (internal.expand === TestItemExpandState.Expandable) {\n\t\t\tconst r = this.resolveChildren(internal);\n\t\t\treturn !r.isOpen()\n\t\t\t\t? r.wait().then(() => this.expandChildren(internal, levels - 1))\n\t\t\t\t: this.expandChildren(internal, levels - 1);\n\t\t} else if (internal.expand === TestItemExpandState.Expanded) {\n\t\t\treturn internal.resolveBarrier?.isOpen() === false\n\t\t\t\t? internal.resolveBarrier.wait().then(() => this.expandChildren(internal, levels - 1))\n\t\t\t\t: this.expandChildren(internal, levels - 1);\n\t\t}\n\t}\n\n\tpublic override dispose() {\n\t\tfor (const item of this.tree.values()) {\n\t\t\tthis.options.getApiFor(item.actual).listener = undefined;\n\t\t}\n\n\t\tthis.tree.clear();\n\t\tthis.diff = [];\n\t\tsuper.dispose();\n\t}\n\n\tprivate onTestItemEvent(internal: CollectionItem<T>, evt: ExtHostTestItemEvent) {\n\t\tswitch (evt.op) {\n\t\t\tcase TestItemEventOp.RemoveChild:\n\t\t\t\tthis.removeItem(TestId.joinToString(internal.fullId, evt.id));\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.Upsert:\n\t\t\t\tthis.upsertItem(evt.item as T, internal);\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.Bulk:\n\t\t\t\tfor (const op of evt.ops) {\n\t\t\t\t\tthis.onTestItemEvent(internal, op);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.SetTags:\n\t\t\t\tthis.diffTagRefs(evt.new, evt.old, internal.fullId.toString());\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.UpdateCanResolveChildren:\n\t\t\t\tthis.updateExpandability(internal);\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.SetProp:\n\t\t\t\tthis.pushDiff({\n\t\t\t\t\top: TestDiffOpType.Update,\n\t\t\t\t\titem: {\n\t\t\t\t\t\textId: internal.fullId.toString(),\n\t\t\t\t\t\titem: evt.update,\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.DocumentSynced:\n\t\t\t\tthis.documentSynced(internal.actual.uri);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tassertNever(evt);\n\t\t}\n\t}\n\n\tprivate documentSynced(uri: URI | undefined) {\n\t\tif (uri) {\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.DocumentSynced,\n\t\t\t\turi,\n\t\t\t\tdocv: this.options.getDocumentVersion(uri)\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate upsertItem(actual: T, parent: CollectionItem<T> | undefined): void {\n\t\tconst fullId = TestId.fromExtHostTestItem(actual, this.root.id, parent?.actual);\n\n\t\t// If this test item exists elsewhere in the tree already (exists at an\n\t\t// old ID with an existing parent), remove that old item.\n\t\tconst privateApi = this.options.getApiFor(actual);\n\t\tif (privateApi.parent && privateApi.parent !== parent?.actual) {\n\t\t\tthis.options.getChildren(privateApi.parent).delete(actual.id);\n\t\t}\n\n\t\tlet internal = this.tree.get(fullId.toString());\n\t\t// Case 1: a brand new item\n\t\tif (!internal) {\n\t\t\tinternal = {\n\t\t\t\tfullId,\n\t\t\t\tactual,\n\t\t\t\texpandLevels: parent?.expandLevels /* intentionally undefined or 0 */ ? parent.expandLevels - 1 : undefined,\n\t\t\t\texpand: TestItemExpandState.NotExpandable, // updated by `connectItemAndChildren`\n\t\t\t};\n\n\t\t\tactual.tags.forEach(this.incrementTagRefs, this);\n\t\t\tthis.tree.set(internal.fullId.toString(), internal);\n\t\t\tthis.setItemParent(actual, parent);\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.Add,\n\t\t\t\titem: {\n\t\t\t\t\tcontrollerId: this.options.controllerId,\n\t\t\t\t\texpand: internal.expand,\n\t\t\t\t\titem: this.options.toITestItem(actual),\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.connectItemAndChildren(actual, internal, parent);\n\t\t\treturn;\n\t\t}\n\n\t\t// Case 2: re-insertion of an existing item, no-op\n\t\tif (internal.actual === actual) {\n\t\t\tthis.connectItem(actual, internal, parent); // re-connect in case the parent changed\n\t\t\treturn; // no-op\n\t\t}\n\n\t\t// Case 3: upsert of an existing item by ID, with a new instance\n\t\tif (internal.actual.uri?.toString() !== actual.uri?.toString()) {\n\t\t\t// If the item has a new URI, re-insert it; we don't support updating\n\t\t\t// URIs on existing test items.\n\t\t\tthis.removeItem(fullId.toString());\n\t\t\treturn this.upsertItem(actual, parent);\n\t\t}\n\t\tconst oldChildren = this.options.getChildren(internal.actual);\n\t\tconst oldActual = internal.actual;\n\t\tconst update = diffTestItems(this.options.toITestItem(oldActual), this.options.toITestItem(actual));\n\t\tthis.options.getApiFor(oldActual).listener = undefined;\n\n\t\tinternal.actual = actual;\n\t\tinternal.resolveBarrier = undefined;\n\t\tinternal.expand = TestItemExpandState.NotExpandable; // updated by `connectItemAndChildren`\n\n\t\tif (update) {\n\t\t\t// tags are handled in a special way\n\t\t\tif (update.hasOwnProperty('tags')) {\n\t\t\t\tthis.diffTagRefs(actual.tags, oldActual.tags, fullId.toString());\n\t\t\t\tdelete update.tags;\n\t\t\t}\n\t\t\tthis.onTestItemEvent(internal, { op: TestItemEventOp.SetProp, update });\n\t\t}\n\n\t\tthis.connectItemAndChildren(actual, internal, parent);\n\n\t\t// Remove any orphaned children.\n\t\tfor (const [_, child] of oldChildren) {\n\t\t\tif (!this.options.getChildren(actual).get(child.id)) {\n\t\t\t\tthis.removeItem(TestId.joinToString(fullId, child.id));\n\t\t\t}\n\t\t}\n\n\t\t// Re-expand the element if it was previous expanded (#207574)\n\t\tconst expandLevels = internal.expandLevels;\n\t\tif (expandLevels !== undefined) {\n\t\t\t// Wait until a microtask to allow the extension to finish setting up\n\t\t\t// properties of the element and children before we ask it to expand.\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (internal.expand === TestItemExpandState.Expandable) {\n\t\t\t\t\tinternal.expandLevels = undefined;\n\t\t\t\t\tthis.expand(fullId.toString(), expandLevels);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Mark ranges in the document as synced (#161320)\n\t\tthis.documentSynced(internal.actual.uri);\n\t}\n\n\tprivate diffTagRefs(newTags: readonly ITestTag[], oldTags: readonly ITestTag[], extId: string) {\n\t\tconst toDelete = new Set(oldTags.map(t => t.id));\n\t\tfor (const tag of newTags) {\n\t\t\tif (!toDelete.delete(tag.id)) {\n\t\t\t\tthis.incrementTagRefs(tag);\n\t\t\t}\n\t\t}\n\n\t\tthis.pushDiff({\n\t\t\top: TestDiffOpType.Update,\n\t\t\titem: { extId, item: { tags: newTags.map(v => namespaceTestTag(this.options.controllerId, v.id)) } }\n\t\t});\n\n\t\ttoDelete.forEach(this.decrementTagRefs, this);\n\t}\n\n\tprivate incrementTagRefs(tag: ITestTag) {\n\t\tconst existing = this.tags.get(tag.id);\n\t\tif (existing) {\n\t\t\texisting.refCount++;\n\t\t} else {\n\t\t\tthis.tags.set(tag.id, { refCount: 1 });\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.AddTag, tag: {\n\t\t\t\t\tid: namespaceTestTag(this.options.controllerId, tag.id),\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate decrementTagRefs(tagId: string) {\n\t\tconst existing = this.tags.get(tagId);\n\t\tif (existing && !--existing.refCount) {\n\t\t\tthis.tags.delete(tagId);\n\t\t\tthis.pushDiff({ op: TestDiffOpType.RemoveTag, id: namespaceTestTag(this.options.controllerId, tagId) });\n\t\t}\n\t}\n\n\tprivate setItemParent(actual: T, parent: CollectionItem<T> | undefined) {\n\t\tthis.options.getApiFor(actual).parent = parent && parent.actual !== this.root ? parent.actual : undefined;\n\t}\n\n\tprivate connectItem(actual: T, internal: CollectionItem<T>, parent: CollectionItem<T> | undefined) {\n\t\tthis.setItemParent(actual, parent);\n\t\tconst api = this.options.getApiFor(actual);\n\t\tapi.parent = parent?.actual;\n\t\tapi.listener = evt => this.onTestItemEvent(internal, evt);\n\t\tthis.updateExpandability(internal);\n\t}\n\n\tprivate connectItemAndChildren(actual: T, internal: CollectionItem<T>, parent: CollectionItem<T> | undefined) {\n\t\tthis.connectItem(actual, internal, parent);\n\n\t\t// Discover any existing children that might have already been added\n\t\tfor (const [_, child] of this.options.getChildren(actual)) {\n\t\t\tthis.upsertItem(child, internal);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the `expand` state of the item. Should be called whenever the\n\t * resolved state of the item changes. Can automatically expand the item\n\t * if requested by a consumer.\n\t */\n\tprivate updateExpandability(internal: CollectionItem<T>) {\n\t\tlet newState: TestItemExpandState;\n\t\tif (!this._resolveHandler) {\n\t\t\tnewState = TestItemExpandState.NotExpandable;\n\t\t} else if (internal.resolveBarrier) {\n\t\t\tnewState = internal.resolveBarrier.isOpen()\n\t\t\t\t? TestItemExpandState.Expanded\n\t\t\t\t: TestItemExpandState.BusyExpanding;\n\t\t} else {\n\t\t\tnewState = internal.actual.canResolveChildren\n\t\t\t\t? TestItemExpandState.Expandable\n\t\t\t\t: TestItemExpandState.NotExpandable;\n\t\t}\n\n\t\tif (newState === internal.expand) {\n\t\t\treturn;\n\t\t}\n\n\t\tinternal.expand = newState;\n\t\tthis.pushDiff({ op: TestDiffOpType.Update, item: { extId: internal.fullId.toString(), expand: newState } });\n\n\t\tif (newState === TestItemExpandState.Expandable && internal.expandLevels !== undefined) {\n\t\t\tthis.resolveChildren(internal);\n\t\t}\n\t}\n\n\t/**\n\t * Expands all children of the item, \"levels\" deep. If levels is 0, only\n\t * the children will be expanded. If it's 1, the children and their children\n\t * will be expanded. If it's <0, it's a no-op.\n\t */\n\tprivate expandChildren(internal: CollectionItem<T>, levels: number): Promise<void> | void {\n\t\tif (levels < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst expandRequests: Promise<void>[] = [];\n\t\tfor (const [_, child] of this.options.getChildren(internal.actual)) {\n\t\t\tconst promise = this.expand(TestId.joinToString(internal.fullId, child.id), levels);\n\t\t\tif (isThenable(promise)) {\n\t\t\t\texpandRequests.push(promise);\n\t\t\t}\n\t\t}\n\n\t\tif (expandRequests.length) {\n\t\t\treturn Promise.all(expandRequests).then(() => { });\n\t\t}\n\t}\n\n\t/**\n\t * Calls `discoverChildren` on the item, refreshing all its tests.\n\t */\n\tprivate resolveChildren(internal: CollectionItem<T>) {\n\t\tif (internal.resolveBarrier) {\n\t\t\treturn internal.resolveBarrier;\n\t\t}\n\n\t\tif (!this._resolveHandler) {\n\t\t\tconst b = new Barrier();\n\t\t\tb.open();\n\t\t\treturn b;\n\t\t}\n\n\t\tinternal.expand = TestItemExpandState.BusyExpanding;\n\t\tthis.pushExpandStateUpdate(internal);\n\n\t\tconst barrier = internal.resolveBarrier = new Barrier();\n\t\tconst applyError = (err: Error) => {\n\t\t\tconsole.error(`Unhandled error in resolveHandler of test controller \"${this.options.controllerId}\"`, err);\n\t\t};\n\n\t\tlet r: Thenable<void> | undefined | void;\n\t\ttry {\n\t\t\tr = this._resolveHandler(internal.actual === this.root ? undefined : internal.actual);\n\t\t} catch (err) {\n\t\t\tapplyError(err);\n\t\t}\n\n\t\tif (isThenable(r)) {\n\t\t\tr.catch(applyError).then(() => {\n\t\t\t\tbarrier.open();\n\t\t\t\tthis.updateExpandability(internal);\n\t\t\t});\n\t\t} else {\n\t\t\tbarrier.open();\n\t\t\tthis.updateExpandability(internal);\n\t\t}\n\n\t\treturn internal.resolveBarrier;\n\t}\n\n\tprivate pushExpandStateUpdate(internal: CollectionItem<T>) {\n\t\tthis.pushDiff({ op: TestDiffOpType.Update, item: { extId: internal.fullId.toString(), expand: internal.expand } });\n\t}\n\n\tprivate removeItem(childId: string) {\n\t\tconst childItem = this.tree.get(childId);\n\t\tif (!childItem) {\n\t\t\tthrow new Error('attempting to remove non-existent child');\n\t\t}\n\n\t\tthis.pushDiff({ op: TestDiffOpType.Remove, itemId: childId });\n\n\t\tconst queue: (CollectionItem<T> | undefined)[] = [childItem];\n\t\twhile (queue.length) {\n\t\t\tconst item = queue.pop();\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.options.getApiFor(item.actual).listener = undefined;\n\n\t\t\tfor (const tag of item.actual.tags) {\n\t\t\t\tthis.decrementTagRefs(tag.id);\n\t\t\t}\n\n\t\t\tthis.tree.delete(item.fullId.toString());\n\t\t\tfor (const [_, child] of this.options.getChildren(item.actual)) {\n\t\t\t\tqueue.push(this.tree.get(TestId.joinToString(item.fullId, child.id)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Immediately emits any pending diffs on the collection.\n\t */\n\tpublic flushDiff() {\n\t\tconst diff = this.collectDiff();\n\t\tif (diff.length) {\n\t\t\tthis.diffOpEmitter.fire(diff);\n\t\t}\n\t}\n}\n\n/** Implementation of vscode.TestItemCollection */\nexport interface ITestItemChildren<T extends ITestItemLike> extends Iterable<[string, T]> {\n\treadonly size: number;\n\treplace(items: readonly T[]): void;\n\tforEach(callback: (item: T, collection: this) => unknown, thisArg?: unknown): void;\n\tadd(item: T): void;\n\tdelete(itemId: string): void;\n\tget(itemId: string): T | undefined;\n\n\ttoJSON(): readonly T[];\n}\n\nexport class DuplicateTestItemError extends Error {\n\tconstructor(id: string) {\n\t\tsuper(`Attempted to insert a duplicate test item ID ${id}`);\n\t}\n}\n\nexport class InvalidTestItemError extends Error {\n\tconstructor(id: string) {\n\t\tsuper(`TestItem with ID \"${id}\" is invalid. Make sure to create it from the createTestItem method.`);\n\t}\n}\n\nexport class MixedTestItemController extends Error {\n\tconstructor(id: string, ctrlA: string, ctrlB: string) {\n\t\tsuper(`TestItem with ID \"${id}\" is from controller \"${ctrlA}\" and cannot be added as a child of an item from controller \"${ctrlB}\".`);\n\t}\n}\n\nexport const createTestItemChildren = <T extends ITestItemLike>(api: ITestItemApi<T>, getApi: (item: T) => ITestItemApi<T>, checkCtor: Function): ITestItemChildren<T> => {\n\tlet mapped = new Map<string, T>();\n\n\treturn {\n\t\t/** @inheritdoc */\n\t\tget size() {\n\t\t\treturn mapped.size;\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tforEach(callback: (item: T, collection: ITestItemChildren<T>) => unknown, thisArg?: unknown) {\n\t\t\tfor (const item of mapped.values()) {\n\t\t\t\tcallback.call(thisArg, item, this);\n\t\t\t}\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\t[Symbol.iterator](): IterableIterator<[string, T]> {\n\t\t\treturn mapped.entries();\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\treplace(items: Iterable<T>) {\n\t\t\tconst newMapped = new Map<string, T>();\n\t\t\tconst toDelete = new Set(mapped.keys());\n\t\t\tconst bulk: ITestItemBulkReplace = { op: TestItemEventOp.Bulk, ops: [] };\n\n\t\t\tfor (const item of items) {\n\t\t\t\tif (!(item instanceof checkCtor)) {\n\t\t\t\t\tthrow new InvalidTestItemError((item as ITestItemLike).id);\n\t\t\t\t}\n\n\t\t\t\tconst itemController = getApi(item).controllerId;\n\t\t\t\tif (itemController !== api.controllerId) {\n\t\t\t\t\tthrow new MixedTestItemController(item.id, itemController, api.controllerId);\n\t\t\t\t}\n\n\t\t\t\tif (newMapped.has(item.id)) {\n\t\t\t\t\tthrow new DuplicateTestItemError(item.id);\n\t\t\t\t}\n\n\t\t\t\tnewMapped.set(item.id, item);\n\t\t\t\ttoDelete.delete(item.id);\n\t\t\t\tbulk.ops.push({ op: TestItemEventOp.Upsert, item });\n\t\t\t}\n\n\t\t\tfor (const id of toDelete.keys()) {\n\t\t\t\tbulk.ops.push({ op: TestItemEventOp.RemoveChild, id });\n\t\t\t}\n\n\t\t\tapi.listener?.(bulk);\n\n\t\t\t// important mutations come after firing, so if an error happens no\n\t\t\t// changes will be \"saved\":\n\t\t\tmapped = newMapped;\n\t\t},\n\n\n\t\t/** @inheritdoc */\n\t\tadd(item: T) {\n\t\t\tif (!(item instanceof checkCtor)) {\n\t\t\t\tthrow new InvalidTestItemError((item as ITestItemLike).id);\n\t\t\t}\n\n\t\t\tmapped.set(item.id, item);\n\t\t\tapi.listener?.({ op: TestItemEventOp.Upsert, item });\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tdelete(id: string) {\n\t\t\tif (mapped.delete(id)) {\n\t\t\t\tapi.listener?.({ op: TestItemEventOp.RemoveChild, id });\n\t\t\t}\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tget(itemId: string) {\n\t\t\treturn mapped.get(itemId);\n\t\t},\n\n\t\t/** JSON serialization function. */\n\t\ttoJSON() {\n\t\t\treturn Array.from(mapped.values());\n\t\t},\n\t};\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Barrier, isThenable, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { assertNever } from '../../../../base/common/assert.js';\nimport { applyTestItemUpdate, ITestItem, ITestTag, namespaceTestTag, TestDiffOpType, TestItemExpandState, TestsDiff, TestsDiffOp } from './testTypes.js';\nimport { TestId } from './testId.js';\nimport { URI } from '../../../../base/common/uri.js';\n\n/**\n * @private\n */\ninterface CollectionItem<T> {\n\treadonly fullId: TestId;\n\tactual: T;\n\texpand: TestItemExpandState;\n\t/**\n\t * Number of levels of items below this one that are expanded. May be infinite.\n\t */\n\texpandLevels?: number;\n\tresolveBarrier?: Barrier;\n}\n\nexport const enum TestItemEventOp {\n\tUpsert,\n\tSetTags,\n\tUpdateCanResolveChildren,\n\tRemoveChild,\n\tSetProp,\n\tBulk,\n\tDocumentSynced,\n}\n\nexport interface ITestItemUpsertChild {\n\top: TestItemEventOp.Upsert;\n\titem: ITestItemLike;\n}\n\nexport interface ITestItemUpdateCanResolveChildren {\n\top: TestItemEventOp.UpdateCanResolveChildren;\n\tstate: boolean;\n}\n\nexport interface ITestItemSetTags {\n\top: TestItemEventOp.SetTags;\n\tnew: ITestTag[];\n\told: ITestTag[];\n}\n\nexport interface ITestItemRemoveChild {\n\top: TestItemEventOp.RemoveChild;\n\tid: string;\n}\n\nexport interface ITestItemSetProp {\n\top: TestItemEventOp.SetProp;\n\tupdate: Partial<ITestItem>;\n}\nexport interface ITestItemBulkReplace {\n\top: TestItemEventOp.Bulk;\n\tops: (ITestItemUpsertChild | ITestItemRemoveChild)[];\n}\n\nexport interface ITestItemDocumentSynced {\n\top: TestItemEventOp.DocumentSynced;\n}\n\nexport type ExtHostTestItemEvent =\n\t| ITestItemSetTags\n\t| ITestItemUpsertChild\n\t| ITestItemRemoveChild\n\t| ITestItemUpdateCanResolveChildren\n\t| ITestItemSetProp\n\t| ITestItemBulkReplace\n\t| ITestItemDocumentSynced;\n\nexport interface ITestItemApi<T> {\n\tcontrollerId: string;\n\tparent?: T;\n\tlistener?: (evt: ExtHostTestItemEvent) => void;\n}\n\nexport interface ITestItemCollectionOptions<T> {\n\t/** Controller ID to use to prefix these test items. */\n\tcontrollerId: string;\n\n\t/** Gets the document version at the given URI, if it's open */\n\tgetDocumentVersion(uri: URI | undefined): number | undefined;\n\n\t/** Gets API for the given test item, used to listen for events and set parents. */\n\tgetApiFor(item: T): ITestItemApi<T>;\n\n\t/** Converts the full test item to the common interface. */\n\ttoITestItem(item: T): ITestItem;\n\n\t/** Gets children for the item. */\n\tgetChildren(item: T): ITestChildrenLike<T>;\n\n\t/** Root to use for the new test collection. */\n\troot: T;\n}\n\nconst strictEqualComparator = <T>(a: T, b: T) => a === b;\nconst diffableProps: { [K in keyof ITestItem]?: (a: ITestItem[K], b: ITestItem[K]) => boolean } = {\n\trange: (a, b) => {\n\t\tif (a === b) { return true; }\n\t\tif (!a || !b) { return false; }\n\t\treturn a.equalsRange(b);\n\t},\n\tbusy: strictEqualComparator,\n\tlabel: strictEqualComparator,\n\tdescription: strictEqualComparator,\n\terror: strictEqualComparator,\n\tsortText: strictEqualComparator,\n\ttags: (a, b) => {\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (a.some(t1 => !b.includes(t1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n};\n\nconst diffableEntries = Object.entries(diffableProps) as readonly [keyof ITestItem, (a: any, b: any) => boolean][];\n\nconst diffTestItems = (a: ITestItem, b: ITestItem) => {\n\tlet output: Record<string, unknown> | undefined;\n\tfor (const [key, cmp] of diffableEntries) {\n\t\tif (!cmp(a[key], b[key])) {\n\t\t\tif (output) {\n\t\t\t\toutput[key] = b[key];\n\t\t\t} else {\n\t\t\t\toutput = { [key]: b[key] };\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output as Partial<ITestItem> | undefined;\n};\n\nexport interface ITestChildrenLike<T> extends Iterable<[string, T]> {\n\tget(id: string): T | undefined;\n\tdelete(id: string): void;\n}\n\nexport interface ITestItemLike {\n\tid: string;\n\ttags: readonly ITestTag[];\n\turi?: URI;\n\tcanResolveChildren: boolean;\n}\n\n/**\n * Maintains a collection of test items for a single controller.\n */\nexport class TestItemCollection<T extends ITestItemLike> extends Disposable {\n\tprivate readonly debounceSendDiff = this._register(new RunOnceScheduler(() => this.flushDiff(), 200));\n\tprivate readonly diffOpEmitter = this._register(new Emitter<TestsDiff>());\n\tprivate _resolveHandler?: (item: T | undefined) => Promise<void> | void;\n\n\tpublic get root() {\n\t\treturn this.options.root;\n\t}\n\n\tpublic readonly tree = new Map</* full test id */string, CollectionItem<T>>();\n\tprivate readonly tags = new Map<string, { label?: string; refCount: number }>();\n\n\tprotected diff: TestsDiff = [];\n\n\tconstructor(private readonly options: ITestItemCollectionOptions<T>) {\n\t\tsuper();\n\t\tthis.root.canResolveChildren = true;\n\t\tthis.upsertItem(this.root, undefined);\n\t}\n\n\t/**\n\t * Handler used for expanding test items.\n\t */\n\tpublic set resolveHandler(handler: undefined | ((item: T | undefined) => void)) {\n\t\tthis._resolveHandler = handler;\n\t\tfor (const test of this.tree.values()) {\n\t\t\tthis.updateExpandability(test);\n\t\t}\n\t}\n\n\tpublic get resolveHandler() {\n\t\treturn this._resolveHandler;\n\t}\n\n\t/**\n\t * Fires when an operation happens that should result in a diff.\n\t */\n\tpublic readonly onDidGenerateDiff = this.diffOpEmitter.event;\n\n\t/**\n\t * Gets a diff of all changes that have been made, and clears the diff queue.\n\t */\n\tpublic collectDiff() {\n\t\tconst diff = this.diff;\n\t\tthis.diff = [];\n\t\treturn diff;\n\t}\n\n\t/**\n\t * Pushes a new diff entry onto the collected diff list.\n\t */\n\tpublic pushDiff(diff: TestsDiffOp) {\n\t\tswitch (diff.op) {\n\t\t\tcase TestDiffOpType.DocumentSynced: {\n\t\t\t\tfor (const existing of this.diff) {\n\t\t\t\t\tif (existing.op === TestDiffOpType.DocumentSynced && existing.uri === diff.uri) {\n\t\t\t\t\t\texisting.docv = diff.docv;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase TestDiffOpType.Update: {\n\t\t\t\t// Try to merge updates, since they're invoked per-property\n\t\t\t\tconst last = this.diff[this.diff.length - 1];\n\t\t\t\tif (last) {\n\t\t\t\t\tif (last.op === TestDiffOpType.Update && last.item.extId === diff.item.extId) {\n\t\t\t\t\t\tapplyTestItemUpdate(last.item, diff.item);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (last.op === TestDiffOpType.Add && last.item.item.extId === diff.item.extId) {\n\t\t\t\t\t\tapplyTestItemUpdate(last.item, diff.item);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.diff.push(diff);\n\n\t\tif (!this.debounceSendDiff.isScheduled()) {\n\t\t\tthis.debounceSendDiff.schedule();\n\t\t}\n\t}\n\n\t/**\n\t * Expands the test and the given number of `levels` of children. If levels\n\t * is < 0, then all children will be expanded. If it's 0, then only this\n\t * item will be expanded.\n\t */\n\tpublic expand(testId: string, levels: number): Promise<void> | void {\n\t\tconst internal = this.tree.get(testId);\n\t\tif (!internal) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (internal.expandLevels === undefined || levels > internal.expandLevels) {\n\t\t\tinternal.expandLevels = levels;\n\t\t}\n\n\t\t// try to avoid awaiting things if the provider returns synchronously in\n\t\t// order to keep everything in a single diff and DOM update.\n\t\tif (internal.expand === TestItemExpandState.Expandable) {\n\t\t\tconst r = this.resolveChildren(internal);\n\t\t\treturn !r.isOpen()\n\t\t\t\t? r.wait().then(() => this.expandChildren(internal, levels - 1))\n\t\t\t\t: this.expandChildren(internal, levels - 1);\n\t\t} else if (internal.expand === TestItemExpandState.Expanded) {\n\t\t\treturn internal.resolveBarrier?.isOpen() === false\n\t\t\t\t? internal.resolveBarrier.wait().then(() => this.expandChildren(internal, levels - 1))\n\t\t\t\t: this.expandChildren(internal, levels - 1);\n\t\t}\n\t}\n\n\tpublic override dispose() {\n\t\tfor (const item of this.tree.values()) {\n\t\t\tthis.options.getApiFor(item.actual).listener = undefined;\n\t\t}\n\n\t\tthis.tree.clear();\n\t\tthis.diff = [];\n\t\tsuper.dispose();\n\t}\n\n\tprivate onTestItemEvent(internal: CollectionItem<T>, evt: ExtHostTestItemEvent) {\n\t\tswitch (evt.op) {\n\t\t\tcase TestItemEventOp.RemoveChild:\n\t\t\t\tthis.removeItem(TestId.joinToString(internal.fullId, evt.id));\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.Upsert:\n\t\t\t\tthis.upsertItem(evt.item as T, internal);\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.Bulk:\n\t\t\t\tfor (const op of evt.ops) {\n\t\t\t\t\tthis.onTestItemEvent(internal, op);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.SetTags:\n\t\t\t\tthis.diffTagRefs(evt.new, evt.old, internal.fullId.toString());\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.UpdateCanResolveChildren:\n\t\t\t\tthis.updateExpandability(internal);\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.SetProp:\n\t\t\t\tthis.pushDiff({\n\t\t\t\t\top: TestDiffOpType.Update,\n\t\t\t\t\titem: {\n\t\t\t\t\t\textId: internal.fullId.toString(),\n\t\t\t\t\t\titem: evt.update,\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase TestItemEventOp.DocumentSynced:\n\t\t\t\tthis.documentSynced(internal.actual.uri);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tassertNever(evt);\n\t\t}\n\t}\n\n\tprivate documentSynced(uri: URI | undefined) {\n\t\tif (uri) {\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.DocumentSynced,\n\t\t\t\turi,\n\t\t\t\tdocv: this.options.getDocumentVersion(uri)\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate upsertItem(actual: T, parent: CollectionItem<T> | undefined): void {\n\t\tconst fullId = TestId.fromExtHostTestItem(actual, this.root.id, parent?.actual);\n\n\t\t// If this test item exists elsewhere in the tree already (exists at an\n\t\t// old ID with an existing parent), remove that old item.\n\t\tconst privateApi = this.options.getApiFor(actual);\n\t\tif (privateApi.parent && privateApi.parent !== parent?.actual) {\n\t\t\tthis.options.getChildren(privateApi.parent).delete(actual.id);\n\t\t}\n\n\t\tlet internal = this.tree.get(fullId.toString());\n\t\t// Case 1: a brand new item\n\t\tif (!internal) {\n\t\t\tinternal = {\n\t\t\t\tfullId,\n\t\t\t\tactual,\n\t\t\t\texpandLevels: parent?.expandLevels /* intentionally undefined or 0 */ ? parent.expandLevels - 1 : undefined,\n\t\t\t\texpand: TestItemExpandState.NotExpandable, // updated by `connectItemAndChildren`\n\t\t\t};\n\n\t\t\tactual.tags.forEach(this.incrementTagRefs, this);\n\t\t\tthis.tree.set(internal.fullId.toString(), internal);\n\t\t\tthis.setItemParent(actual, parent);\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.Add,\n\t\t\t\titem: {\n\t\t\t\t\tcontrollerId: this.options.controllerId,\n\t\t\t\t\texpand: internal.expand,\n\t\t\t\t\titem: this.options.toITestItem(actual),\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.connectItemAndChildren(actual, internal, parent);\n\t\t\treturn;\n\t\t}\n\n\t\t// Case 2: re-insertion of an existing item, no-op\n\t\tif (internal.actual === actual) {\n\t\t\tthis.connectItem(actual, internal, parent); // re-connect in case the parent changed\n\t\t\treturn; // no-op\n\t\t}\n\n\t\t// Case 3: upsert of an existing item by ID, with a new instance\n\t\tif (internal.actual.uri?.toString() !== actual.uri?.toString()) {\n\t\t\t// If the item has a new URI, re-insert it; we don't support updating\n\t\t\t// URIs on existing test items.\n\t\t\tthis.removeItem(fullId.toString());\n\t\t\treturn this.upsertItem(actual, parent);\n\t\t}\n\t\tconst oldChildren = this.options.getChildren(internal.actual);\n\t\tconst oldActual = internal.actual;\n\t\tconst update = diffTestItems(this.options.toITestItem(oldActual), this.options.toITestItem(actual));\n\t\tthis.options.getApiFor(oldActual).listener = undefined;\n\n\t\tinternal.actual = actual;\n\t\tinternal.resolveBarrier = undefined;\n\t\tinternal.expand = TestItemExpandState.NotExpandable; // updated by `connectItemAndChildren`\n\n\t\tif (update) {\n\t\t\t// tags are handled in a special way\n\t\t\tif (update.hasOwnProperty('tags')) {\n\t\t\t\tthis.diffTagRefs(actual.tags, oldActual.tags, fullId.toString());\n\t\t\t\tdelete update.tags;\n\t\t\t}\n\t\t\tthis.onTestItemEvent(internal, { op: TestItemEventOp.SetProp, update });\n\t\t}\n\n\t\tthis.connectItemAndChildren(actual, internal, parent);\n\n\t\t// Remove any orphaned children.\n\t\tfor (const [_, child] of oldChildren) {\n\t\t\tif (!this.options.getChildren(actual).get(child.id)) {\n\t\t\t\tthis.removeItem(TestId.joinToString(fullId, child.id));\n\t\t\t}\n\t\t}\n\n\t\t// Re-expand the element if it was previous expanded (#207574)\n\t\tconst expandLevels = internal.expandLevels;\n\t\tif (expandLevels !== undefined) {\n\t\t\t// Wait until a microtask to allow the extension to finish setting up\n\t\t\t// properties of the element and children before we ask it to expand.\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (internal.expand === TestItemExpandState.Expandable) {\n\t\t\t\t\tinternal.expandLevels = undefined;\n\t\t\t\t\tthis.expand(fullId.toString(), expandLevels);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Mark ranges in the document as synced (#161320)\n\t\tthis.documentSynced(internal.actual.uri);\n\t}\n\n\tprivate diffTagRefs(newTags: readonly ITestTag[], oldTags: readonly ITestTag[], extId: string) {\n\t\tconst toDelete = new Set(oldTags.map(t => t.id));\n\t\tfor (const tag of newTags) {\n\t\t\tif (!toDelete.delete(tag.id)) {\n\t\t\t\tthis.incrementTagRefs(tag);\n\t\t\t}\n\t\t}\n\n\t\tthis.pushDiff({\n\t\t\top: TestDiffOpType.Update,\n\t\t\titem: { extId, item: { tags: newTags.map(v => namespaceTestTag(this.options.controllerId, v.id)) } }\n\t\t});\n\n\t\ttoDelete.forEach(this.decrementTagRefs, this);\n\t}\n\n\tprivate incrementTagRefs(tag: ITestTag) {\n\t\tconst existing = this.tags.get(tag.id);\n\t\tif (existing) {\n\t\t\texisting.refCount++;\n\t\t} else {\n\t\t\tthis.tags.set(tag.id, { refCount: 1 });\n\t\t\tthis.pushDiff({\n\t\t\t\top: TestDiffOpType.AddTag, tag: {\n\t\t\t\t\tid: namespaceTestTag(this.options.controllerId, tag.id),\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate decrementTagRefs(tagId: string) {\n\t\tconst existing = this.tags.get(tagId);\n\t\tif (existing && !--existing.refCount) {\n\t\t\tthis.tags.delete(tagId);\n\t\t\tthis.pushDiff({ op: TestDiffOpType.RemoveTag, id: namespaceTestTag(this.options.controllerId, tagId) });\n\t\t}\n\t}\n\n\tprivate setItemParent(actual: T, parent: CollectionItem<T> | undefined) {\n\t\tthis.options.getApiFor(actual).parent = parent && parent.actual !== this.root ? parent.actual : undefined;\n\t}\n\n\tprivate connectItem(actual: T, internal: CollectionItem<T>, parent: CollectionItem<T> | undefined) {\n\t\tthis.setItemParent(actual, parent);\n\t\tconst api = this.options.getApiFor(actual);\n\t\tapi.parent = parent?.actual;\n\t\tapi.listener = evt => this.onTestItemEvent(internal, evt);\n\t\tthis.updateExpandability(internal);\n\t}\n\n\tprivate connectItemAndChildren(actual: T, internal: CollectionItem<T>, parent: CollectionItem<T> | undefined) {\n\t\tthis.connectItem(actual, internal, parent);\n\n\t\t// Discover any existing children that might have already been added\n\t\tfor (const [_, child] of this.options.getChildren(actual)) {\n\t\t\tthis.upsertItem(child, internal);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the `expand` state of the item. Should be called whenever the\n\t * resolved state of the item changes. Can automatically expand the item\n\t * if requested by a consumer.\n\t */\n\tprivate updateExpandability(internal: CollectionItem<T>) {\n\t\tlet newState: TestItemExpandState;\n\t\tif (!this._resolveHandler) {\n\t\t\tnewState = TestItemExpandState.NotExpandable;\n\t\t} else if (internal.resolveBarrier) {\n\t\t\tnewState = internal.resolveBarrier.isOpen()\n\t\t\t\t? TestItemExpandState.Expanded\n\t\t\t\t: TestItemExpandState.BusyExpanding;\n\t\t} else {\n\t\t\tnewState = internal.actual.canResolveChildren\n\t\t\t\t? TestItemExpandState.Expandable\n\t\t\t\t: TestItemExpandState.NotExpandable;\n\t\t}\n\n\t\tif (newState === internal.expand) {\n\t\t\treturn;\n\t\t}\n\n\t\tinternal.expand = newState;\n\t\tthis.pushDiff({ op: TestDiffOpType.Update, item: { extId: internal.fullId.toString(), expand: newState } });\n\n\t\tif (newState === TestItemExpandState.Expandable && internal.expandLevels !== undefined) {\n\t\t\tthis.resolveChildren(internal);\n\t\t}\n\t}\n\n\t/**\n\t * Expands all children of the item, \"levels\" deep. If levels is 0, only\n\t * the children will be expanded. If it's 1, the children and their children\n\t * will be expanded. If it's <0, it's a no-op.\n\t */\n\tprivate expandChildren(internal: CollectionItem<T>, levels: number): Promise<void> | void {\n\t\tif (levels < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst expandRequests: Promise<void>[] = [];\n\t\tfor (const [_, child] of this.options.getChildren(internal.actual)) {\n\t\t\tconst promise = this.expand(TestId.joinToString(internal.fullId, child.id), levels);\n\t\t\tif (isThenable(promise)) {\n\t\t\t\texpandRequests.push(promise);\n\t\t\t}\n\t\t}\n\n\t\tif (expandRequests.length) {\n\t\t\treturn Promise.all(expandRequests).then(() => { });\n\t\t}\n\t}\n\n\t/**\n\t * Calls `discoverChildren` on the item, refreshing all its tests.\n\t */\n\tprivate resolveChildren(internal: CollectionItem<T>) {\n\t\tif (internal.resolveBarrier) {\n\t\t\treturn internal.resolveBarrier;\n\t\t}\n\n\t\tif (!this._resolveHandler) {\n\t\t\tconst b = new Barrier();\n\t\t\tb.open();\n\t\t\treturn b;\n\t\t}\n\n\t\tinternal.expand = TestItemExpandState.BusyExpanding;\n\t\tthis.pushExpandStateUpdate(internal);\n\n\t\tconst barrier = internal.resolveBarrier = new Barrier();\n\t\tconst applyError = (err: Error) => {\n\t\t\tconsole.error(`Unhandled error in resolveHandler of test controller \"${this.options.controllerId}\"`, err);\n\t\t};\n\n\t\tlet r: Thenable<void> | undefined | void;\n\t\ttry {\n\t\t\tr = this._resolveHandler(internal.actual === this.root ? undefined : internal.actual);\n\t\t} catch (err) {\n\t\t\tapplyError(err);\n\t\t}\n\n\t\tif (isThenable(r)) {\n\t\t\tr.catch(applyError).then(() => {\n\t\t\t\tbarrier.open();\n\t\t\t\tthis.updateExpandability(internal);\n\t\t\t});\n\t\t} else {\n\t\t\tbarrier.open();\n\t\t\tthis.updateExpandability(internal);\n\t\t}\n\n\t\treturn internal.resolveBarrier;\n\t}\n\n\tprivate pushExpandStateUpdate(internal: CollectionItem<T>) {\n\t\tthis.pushDiff({ op: TestDiffOpType.Update, item: { extId: internal.fullId.toString(), expand: internal.expand } });\n\t}\n\n\tprivate removeItem(childId: string) {\n\t\tconst childItem = this.tree.get(childId);\n\t\tif (!childItem) {\n\t\t\tthrow new Error('attempting to remove non-existent child');\n\t\t}\n\n\t\tthis.pushDiff({ op: TestDiffOpType.Remove, itemId: childId });\n\n\t\tconst queue: (CollectionItem<T> | undefined)[] = [childItem];\n\t\twhile (queue.length) {\n\t\t\tconst item = queue.pop();\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.options.getApiFor(item.actual).listener = undefined;\n\n\t\t\tfor (const tag of item.actual.tags) {\n\t\t\t\tthis.decrementTagRefs(tag.id);\n\t\t\t}\n\n\t\t\tthis.tree.delete(item.fullId.toString());\n\t\t\tfor (const [_, child] of this.options.getChildren(item.actual)) {\n\t\t\t\tqueue.push(this.tree.get(TestId.joinToString(item.fullId, child.id)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Immediately emits any pending diffs on the collection.\n\t */\n\tpublic flushDiff() {\n\t\tconst diff = this.collectDiff();\n\t\tif (diff.length) {\n\t\t\tthis.diffOpEmitter.fire(diff);\n\t\t}\n\t}\n}\n\n/** Implementation of vscode.TestItemCollection */\nexport interface ITestItemChildren<T extends ITestItemLike> extends Iterable<[string, T]> {\n\treadonly size: number;\n\treplace(items: readonly T[]): void;\n\tforEach(callback: (item: T, collection: this) => unknown, thisArg?: unknown): void;\n\tadd(item: T): void;\n\tdelete(itemId: string): void;\n\tget(itemId: string): T | undefined;\n\n\ttoJSON(): readonly T[];\n}\n\nexport class DuplicateTestItemError extends Error {\n\tconstructor(id: string) {\n\t\tsuper(`Attempted to insert a duplicate test item ID ${id}`);\n\t}\n}\n\nexport class InvalidTestItemError extends Error {\n\tconstructor(id: string) {\n\t\tsuper(`TestItem with ID \"${id}\" is invalid. Make sure to create it from the createTestItem method.`);\n\t}\n}\n\nexport class MixedTestItemController extends Error {\n\tconstructor(id: string, ctrlA: string, ctrlB: string) {\n\t\tsuper(`TestItem with ID \"${id}\" is from controller \"${ctrlA}\" and cannot be added as a child of an item from controller \"${ctrlB}\".`);\n\t}\n}\n\nexport const createTestItemChildren = <T extends ITestItemLike>(api: ITestItemApi<T>, getApi: (item: T) => ITestItemApi<T>, checkCtor: Function): ITestItemChildren<T> => {\n\tlet mapped = new Map<string, T>();\n\n\treturn {\n\t\t/** @inheritdoc */\n\t\tget size() {\n\t\t\treturn mapped.size;\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tforEach(callback: (item: T, collection: ITestItemChildren<T>) => unknown, thisArg?: unknown) {\n\t\t\tfor (const item of mapped.values()) {\n\t\t\t\tcallback.call(thisArg, item, this);\n\t\t\t}\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\t[Symbol.iterator](): IterableIterator<[string, T]> {\n\t\t\treturn mapped.entries();\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\treplace(items: Iterable<T>) {\n\t\t\tconst newMapped = new Map<string, T>();\n\t\t\tconst toDelete = new Set(mapped.keys());\n\t\t\tconst bulk: ITestItemBulkReplace = { op: TestItemEventOp.Bulk, ops: [] };\n\n\t\t\tfor (const item of items) {\n\t\t\t\tif (!(item instanceof checkCtor)) {\n\t\t\t\t\tthrow new InvalidTestItemError((item as ITestItemLike).id);\n\t\t\t\t}\n\n\t\t\t\tconst itemController = getApi(item).controllerId;\n\t\t\t\tif (itemController !== api.controllerId) {\n\t\t\t\t\tthrow new MixedTestItemController(item.id, itemController, api.controllerId);\n\t\t\t\t}\n\n\t\t\t\tif (newMapped.has(item.id)) {\n\t\t\t\t\tthrow new DuplicateTestItemError(item.id);\n\t\t\t\t}\n\n\t\t\t\tnewMapped.set(item.id, item);\n\t\t\t\ttoDelete.delete(item.id);\n\t\t\t\tbulk.ops.push({ op: TestItemEventOp.Upsert, item });\n\t\t\t}\n\n\t\t\tfor (const id of toDelete.keys()) {\n\t\t\t\tbulk.ops.push({ op: TestItemEventOp.RemoveChild, id });\n\t\t\t}\n\n\t\t\tapi.listener?.(bulk);\n\n\t\t\t// important mutations come after firing, so if an error happens no\n\t\t\t// changes will be \"saved\":\n\t\t\tmapped = newMapped;\n\t\t},\n\n\n\t\t/** @inheritdoc */\n\t\tadd(item: T) {\n\t\t\tif (!(item instanceof checkCtor)) {\n\t\t\t\tthrow new InvalidTestItemError((item as ITestItemLike).id);\n\t\t\t}\n\n\t\t\tmapped.set(item.id, item);\n\t\t\tapi.listener?.({ op: TestItemEventOp.Upsert, item });\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tdelete(id: string) {\n\t\t\tif (mapped.delete(id)) {\n\t\t\t\tapi.listener?.({ op: TestItemEventOp.RemoveChild, id });\n\t\t\t}\n\t\t},\n\n\t\t/** @inheritdoc */\n\t\tget(itemId: string) {\n\t\t\treturn mapped.get(itemId);\n\t\t},\n\n\t\t/** JSON serialization function. */\n\t\ttoJSON() {\n\t\t\treturn Array.from(mapped.values());\n\t\t},\n\t};\n};\n"]}