{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/common/getComputedState.ts","vs/workbench/contrib/testing/common/getComputedState.ts"],"names":[],"mappings":"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","file":"getComputedState.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { TestResultState } from './testTypes.js';\nimport { makeEmptyCounts, maxPriority, statePriority } from './testingStates.js';\n\n/**\n * Accessor for nodes in get and refresh computed state.\n */\nexport interface IComputedStateAccessor<T> {\n\tgetOwnState(item: T): TestResultState | undefined;\n\tgetCurrentComputedState(item: T): TestResultState;\n\tsetComputedState(item: T, state: TestResultState): void;\n\tgetChildren(item: T): Iterable<T>;\n\tgetParents(item: T): Iterable<T>;\n}\n\nexport interface IComputedStateAndDurationAccessor<T> extends IComputedStateAccessor<T> {\n\tgetOwnDuration(item: T): number | undefined;\n\tgetCurrentComputedDuration(item: T): number | undefined;\n\tsetComputedDuration(item: T, duration: number | undefined): void;\n}\n\nconst isDurationAccessor = <T>(accessor: IComputedStateAccessor<T>): accessor is IComputedStateAndDurationAccessor<T> => 'getOwnDuration' in accessor;\n\n/**\n * Gets the computed state for the node.\n * @param force whether to refresh the computed state for this node, even\n * if it was previously set.\n */\n\nconst getComputedState = <T extends object>(accessor: IComputedStateAccessor<T>, node: T, force = false) => {\n\tlet computed = accessor.getCurrentComputedState(node);\n\tif (computed === undefined || force) {\n\t\tcomputed = accessor.getOwnState(node) ?? TestResultState.Unset;\n\n\t\tlet childrenCount = 0;\n\t\tconst stateMap = makeEmptyCounts();\n\n\t\tfor (const child of accessor.getChildren(node)) {\n\t\t\tconst childComputed = getComputedState(accessor, child);\n\t\t\tchildrenCount++;\n\t\t\tstateMap[childComputed]++;\n\n\t\t\t// If all children are skipped, make the current state skipped too if unset (#131537)\n\t\t\tcomputed = childComputed === TestResultState.Skipped && computed === TestResultState.Unset\n\t\t\t\t? TestResultState.Skipped : maxPriority(computed, childComputed);\n\t\t}\n\n\t\tif (childrenCount > LARGE_NODE_THRESHOLD) {\n\t\t\tlargeNodeChildrenStates.set(node, stateMap);\n\t\t}\n\n\t\taccessor.setComputedState(node, computed);\n\t}\n\n\treturn computed;\n};\n\nconst getComputedDuration = <T>(accessor: IComputedStateAndDurationAccessor<T>, node: T, force = false): number | undefined => {\n\tlet computed = accessor.getCurrentComputedDuration(node);\n\tif (computed === undefined || force) {\n\t\tconst own = accessor.getOwnDuration(node);\n\t\tif (own !== undefined) {\n\t\t\tcomputed = own;\n\t\t} else {\n\t\t\tcomputed = undefined;\n\t\t\tfor (const child of accessor.getChildren(node)) {\n\t\t\t\tconst d = getComputedDuration(accessor, child);\n\t\t\t\tif (d !== undefined) {\n\t\t\t\t\tcomputed = (computed || 0) + d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\taccessor.setComputedDuration(node, computed);\n\t}\n\n\treturn computed;\n};\n\nconst LARGE_NODE_THRESHOLD = 64;\n\n/**\n * Map of how many nodes have in each state. This is used to optimize state\n * computation in large nodes with children above the `LARGE_NODE_THRESHOLD`.\n */\nconst largeNodeChildrenStates = new WeakMap<object, { [K in TestResultState]: number }>();\n\n/**\n * Refreshes the computed state for the node and its parents. Any changes\n * elements cause `addUpdated` to be called.\n */\nexport const refreshComputedState = <T extends object>(\n\taccessor: IComputedStateAccessor<T>,\n\tnode: T,\n\texplicitNewComputedState?: TestResultState,\n\trefreshDuration = true,\n) => {\n\tconst oldState = accessor.getCurrentComputedState(node);\n\tconst oldPriority = statePriority[oldState];\n\tconst newState = explicitNewComputedState ?? getComputedState(accessor, node, true);\n\tconst newPriority = statePriority[newState];\n\tconst toUpdate = new Set<T>();\n\n\tif (newPriority !== oldPriority) {\n\t\taccessor.setComputedState(node, newState);\n\t\ttoUpdate.add(node);\n\n\t\tlet moveFromState = oldState;\n\t\tlet moveToState = newState;\n\n\t\tfor (const parent of accessor.getParents(node)) {\n\t\t\tconst lnm = largeNodeChildrenStates.get(parent);\n\t\t\tif (lnm) {\n\t\t\t\tlnm[moveFromState]--;\n\t\t\t\tlnm[moveToState]++;\n\t\t\t}\n\n\t\t\tconst prev = accessor.getCurrentComputedState(parent);\n\t\t\tif (newPriority > oldPriority) {\n\t\t\t\t// Update all parents to ensure they're at least this priority.\n\t\t\t\tif (prev !== undefined && statePriority[prev] >= newPriority) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (lnm && lnm[moveToState] > 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// moveToState remains the same, the new higher priority node state\n\t\t\t\taccessor.setComputedState(parent, newState);\n\t\t\t\ttoUpdate.add(parent);\n\t\t\t} else /* newProirity < oldPriority */ {\n\t\t\t\t// Update all parts whose statese might have been based on this one\n\t\t\t\tif (prev === undefined || statePriority[prev] > oldPriority) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (lnm && lnm[moveFromState] > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmoveToState = getComputedState(accessor, parent, true);\n\t\t\t\taccessor.setComputedState(parent, moveToState);\n\t\t\t\ttoUpdate.add(parent);\n\t\t\t}\n\n\t\t\tmoveFromState = prev;\n\t\t}\n\t}\n\n\tif (isDurationAccessor(accessor) && refreshDuration) {\n\t\tfor (const parent of Iterable.concat(Iterable.single(node), accessor.getParents(node))) {\n\t\t\tconst oldDuration = accessor.getCurrentComputedDuration(parent);\n\t\t\tconst newDuration = getComputedDuration(accessor, parent, true);\n\t\t\tif (oldDuration === newDuration) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taccessor.setComputedDuration(parent, newDuration);\n\t\t\ttoUpdate.add(parent);\n\t\t}\n\t}\n\n\treturn toUpdate;\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { TestResultState } from './testTypes.js';\nimport { makeEmptyCounts, maxPriority, statePriority } from './testingStates.js';\n\n/**\n * Accessor for nodes in get and refresh computed state.\n */\nexport interface IComputedStateAccessor<T> {\n\tgetOwnState(item: T): TestResultState | undefined;\n\tgetCurrentComputedState(item: T): TestResultState;\n\tsetComputedState(item: T, state: TestResultState): void;\n\tgetChildren(item: T): Iterable<T>;\n\tgetParents(item: T): Iterable<T>;\n}\n\nexport interface IComputedStateAndDurationAccessor<T> extends IComputedStateAccessor<T> {\n\tgetOwnDuration(item: T): number | undefined;\n\tgetCurrentComputedDuration(item: T): number | undefined;\n\tsetComputedDuration(item: T, duration: number | undefined): void;\n}\n\nconst isDurationAccessor = <T>(accessor: IComputedStateAccessor<T>): accessor is IComputedStateAndDurationAccessor<T> => 'getOwnDuration' in accessor;\n\n/**\n * Gets the computed state for the node.\n * @param force whether to refresh the computed state for this node, even\n * if it was previously set.\n */\n\nconst getComputedState = <T extends object>(accessor: IComputedStateAccessor<T>, node: T, force = false) => {\n\tlet computed = accessor.getCurrentComputedState(node);\n\tif (computed === undefined || force) {\n\t\tcomputed = accessor.getOwnState(node) ?? TestResultState.Unset;\n\n\t\tlet childrenCount = 0;\n\t\tconst stateMap = makeEmptyCounts();\n\n\t\tfor (const child of accessor.getChildren(node)) {\n\t\t\tconst childComputed = getComputedState(accessor, child);\n\t\t\tchildrenCount++;\n\t\t\tstateMap[childComputed]++;\n\n\t\t\t// If all children are skipped, make the current state skipped too if unset (#131537)\n\t\t\tcomputed = childComputed === TestResultState.Skipped && computed === TestResultState.Unset\n\t\t\t\t? TestResultState.Skipped : maxPriority(computed, childComputed);\n\t\t}\n\n\t\tif (childrenCount > LARGE_NODE_THRESHOLD) {\n\t\t\tlargeNodeChildrenStates.set(node, stateMap);\n\t\t}\n\n\t\taccessor.setComputedState(node, computed);\n\t}\n\n\treturn computed;\n};\n\nconst getComputedDuration = <T>(accessor: IComputedStateAndDurationAccessor<T>, node: T, force = false): number | undefined => {\n\tlet computed = accessor.getCurrentComputedDuration(node);\n\tif (computed === undefined || force) {\n\t\tconst own = accessor.getOwnDuration(node);\n\t\tif (own !== undefined) {\n\t\t\tcomputed = own;\n\t\t} else {\n\t\t\tcomputed = undefined;\n\t\t\tfor (const child of accessor.getChildren(node)) {\n\t\t\t\tconst d = getComputedDuration(accessor, child);\n\t\t\t\tif (d !== undefined) {\n\t\t\t\t\tcomputed = (computed || 0) + d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\taccessor.setComputedDuration(node, computed);\n\t}\n\n\treturn computed;\n};\n\nconst LARGE_NODE_THRESHOLD = 64;\n\n/**\n * Map of how many nodes have in each state. This is used to optimize state\n * computation in large nodes with children above the `LARGE_NODE_THRESHOLD`.\n */\nconst largeNodeChildrenStates = new WeakMap<object, { [K in TestResultState]: number }>();\n\n/**\n * Refreshes the computed state for the node and its parents. Any changes\n * elements cause `addUpdated` to be called.\n */\nexport const refreshComputedState = <T extends object>(\n\taccessor: IComputedStateAccessor<T>,\n\tnode: T,\n\texplicitNewComputedState?: TestResultState,\n\trefreshDuration = true,\n) => {\n\tconst oldState = accessor.getCurrentComputedState(node);\n\tconst oldPriority = statePriority[oldState];\n\tconst newState = explicitNewComputedState ?? getComputedState(accessor, node, true);\n\tconst newPriority = statePriority[newState];\n\tconst toUpdate = new Set<T>();\n\n\tif (newPriority !== oldPriority) {\n\t\taccessor.setComputedState(node, newState);\n\t\ttoUpdate.add(node);\n\n\t\tlet moveFromState = oldState;\n\t\tlet moveToState = newState;\n\n\t\tfor (const parent of accessor.getParents(node)) {\n\t\t\tconst lnm = largeNodeChildrenStates.get(parent);\n\t\t\tif (lnm) {\n\t\t\t\tlnm[moveFromState]--;\n\t\t\t\tlnm[moveToState]++;\n\t\t\t}\n\n\t\t\tconst prev = accessor.getCurrentComputedState(parent);\n\t\t\tif (newPriority > oldPriority) {\n\t\t\t\t// Update all parents to ensure they're at least this priority.\n\t\t\t\tif (prev !== undefined && statePriority[prev] >= newPriority) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (lnm && lnm[moveToState] > 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// moveToState remains the same, the new higher priority node state\n\t\t\t\taccessor.setComputedState(parent, newState);\n\t\t\t\ttoUpdate.add(parent);\n\t\t\t} else /* newProirity < oldPriority */ {\n\t\t\t\t// Update all parts whose statese might have been based on this one\n\t\t\t\tif (prev === undefined || statePriority[prev] > oldPriority) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (lnm && lnm[moveFromState] > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmoveToState = getComputedState(accessor, parent, true);\n\t\t\t\taccessor.setComputedState(parent, moveToState);\n\t\t\t\ttoUpdate.add(parent);\n\t\t\t}\n\n\t\t\tmoveFromState = prev;\n\t\t}\n\t}\n\n\tif (isDurationAccessor(accessor) && refreshDuration) {\n\t\tfor (const parent of Iterable.concat(Iterable.single(node), accessor.getParents(node))) {\n\t\t\tconst oldDuration = accessor.getCurrentComputedDuration(parent);\n\t\t\tconst newDuration = getComputedDuration(accessor, parent, true);\n\t\t\tif (oldDuration === newDuration) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taccessor.setComputedDuration(parent, newDuration);\n\t\t\ttoUpdate.add(parent);\n\t\t}\n\t}\n\n\treturn toUpdate;\n};\n"]}