{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/common/testId.ts","vs/workbench/contrib/testing/common/testId.ts"],"names":[],"mappings":"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","file":"testId.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum TestIdPathParts {\n\t/** Delimiter for path parts in test IDs */\n\tDelimiter = '\\0',\n}\n\n/**\n * Enum for describing relative positions of tests. Similar to\n * `node.compareDocumentPosition` in the DOM.\n */\nexport const enum TestPosition {\n\t/** a === b */\n\tIsSame,\n\t/** Neither a nor b are a child of one another. They may share a common parent, though. */\n\tDisconnected,\n\t/** b is a child of a */\n\tIsChild,\n\t/** b is a parent of a */\n\tIsParent,\n}\n\ntype TestItemLike = { id: string; parent?: TestItemLike; _isRoot?: boolean };\n\n/**\n * The test ID is a stringifiable client that\n */\nexport class TestId {\n\tprivate stringifed?: string;\n\n\t/**\n\t * Creates a test ID from an ext host test item.\n\t */\n\tpublic static fromExtHostTestItem(item: TestItemLike, rootId: string, parent = item.parent) {\n\t\tif (item._isRoot) {\n\t\t\treturn new TestId([rootId]);\n\t\t}\n\n\t\tconst path = [item.id];\n\t\tfor (let i = parent; i && i.id !== rootId; i = i.parent) {\n\t\t\tpath.push(i.id);\n\t\t}\n\t\tpath.push(rootId);\n\n\t\treturn new TestId(path.reverse());\n\t}\n\n\t/**\n\t * Cheaply ets whether the ID refers to the root .\n\t */\n\tpublic static isRoot(idString: string) {\n\t\treturn !idString.includes(TestIdPathParts.Delimiter);\n\t}\n\n\t/**\n\t * Cheaply gets whether the ID refers to the root .\n\t */\n\tpublic static root(idString: string) {\n\t\tconst idx = idString.indexOf(TestIdPathParts.Delimiter);\n\t\treturn idx === -1 ? idString : idString.slice(0, idx);\n\t}\n\n\t/**\n\t * Creates a test ID from a serialized TestId instance.\n\t */\n\tpublic static fromString(idString: string) {\n\t\treturn new TestId(idString.split(TestIdPathParts.Delimiter));\n\t}\n\n\t/**\n\t * Gets the ID resulting from adding b to the base ID.\n\t */\n\tpublic static join(base: TestId, b: string) {\n\t\treturn new TestId([...base.path, b]);\n\t}\n\n\t/**\n\t * Splits a test ID into its parts.\n\t */\n\tpublic static split(idString: string) {\n\t\treturn idString.split(TestIdPathParts.Delimiter);\n\t}\n\n\t/**\n\t * Gets the string ID resulting from adding b to the base ID.\n\t */\n\tpublic static joinToString(base: string | TestId, b: string) {\n\t\treturn base.toString() + TestIdPathParts.Delimiter + b;\n\t}\n\n\t/**\n\t * Cheaply gets the parent ID of a test identified with the string.\n\t */\n\tpublic static parentId(idString: string) {\n\t\tconst idx = idString.lastIndexOf(TestIdPathParts.Delimiter);\n\t\treturn idx === -1 ? undefined : idString.slice(0, idx);\n\t}\n\n\t/**\n\t * Cheaply gets the local ID of a test identified with the string.\n\t */\n\tpublic static localId(idString: string) {\n\t\tconst idx = idString.lastIndexOf(TestIdPathParts.Delimiter);\n\t\treturn idx === -1 ? idString : idString.slice(idx + TestIdPathParts.Delimiter.length);\n\t}\n\n\t/**\n\t * Gets whether maybeChild is a child of maybeParent.\n\t * todo@connor4312: review usages of this to see if using the WellDefinedPrefixTree is better\n\t */\n\tpublic static isChild(maybeParent: string, maybeChild: string) {\n\t\treturn maybeChild[maybeParent.length] === TestIdPathParts.Delimiter && maybeChild.startsWith(maybeParent);\n\t}\n\n\t/**\n\t * Compares the position of the two ID strings.\n\t * todo@connor4312: review usages of this to see if using the WellDefinedPrefixTree is better\n\t */\n\tpublic static compare(a: string, b: string) {\n\t\tif (a === b) {\n\t\t\treturn TestPosition.IsSame;\n\t\t}\n\n\t\tif (TestId.isChild(a, b)) {\n\t\t\treturn TestPosition.IsChild;\n\t\t}\n\n\t\tif (TestId.isChild(b, a)) {\n\t\t\treturn TestPosition.IsParent;\n\t\t}\n\n\t\treturn TestPosition.Disconnected;\n\t}\n\n\tpublic static getLengthOfCommonPrefix(length: number, getId: (i: number) => TestId): number {\n\t\tif (length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet commonPrefix = 0;\n\t\twhile (commonPrefix < length - 1) {\n\t\t\tfor (let i = 1; i < length; i++) {\n\t\t\t\tconst a = getId(i - 1);\n\t\t\t\tconst b = getId(i);\n\t\t\t\tif (a.path[commonPrefix] !== b.path[commonPrefix]) {\n\t\t\t\t\treturn commonPrefix;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcommonPrefix++;\n\t\t}\n\n\t\treturn commonPrefix;\n\t}\n\n\tconstructor(\n\t\tpublic readonly path: readonly string[],\n\t\tprivate readonly viewEnd = path.length,\n\t) {\n\t\tif (path.length === 0 || viewEnd < 1) {\n\t\t\tthrow new Error('cannot create test with empty path');\n\t\t}\n\t}\n\n\t/**\n\t * Gets the ID of the parent test.\n\t */\n\tpublic get rootId(): TestId {\n\t\treturn new TestId(this.path, 1);\n\t}\n\n\t/**\n\t * Gets the ID of the parent test.\n\t */\n\tpublic get parentId(): TestId | undefined {\n\t\treturn this.viewEnd > 1 ? new TestId(this.path, this.viewEnd - 1) : undefined;\n\t}\n\n\t/**\n\t * Gets the local ID of the current full test ID.\n\t */\n\tpublic get localId() {\n\t\treturn this.path[this.viewEnd - 1];\n\t}\n\n\t/**\n\t * Gets whether this ID refers to the root.\n\t */\n\tpublic get controllerId() {\n\t\treturn this.path[0];\n\t}\n\n\t/**\n\t * Gets whether this ID refers to the root.\n\t */\n\tpublic get isRoot() {\n\t\treturn this.viewEnd === 1;\n\t}\n\n\t/**\n\t * Returns an iterable that yields IDs of all parent items down to and\n\t * including the current item.\n\t */\n\tpublic *idsFromRoot() {\n\t\tfor (let i = 1; i <= this.viewEnd; i++) {\n\t\t\tyield new TestId(this.path, i);\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterable that yields IDs of the current item up to the root\n\t * item.\n\t */\n\tpublic *idsToRoot() {\n\t\tfor (let i = this.viewEnd; i > 0; i--) {\n\t\t\tyield new TestId(this.path, i);\n\t\t}\n\t}\n\n\t/**\n\t * Compares the other test ID with this one.\n\t */\n\tpublic compare(other: TestId | string) {\n\t\tif (typeof other === 'string') {\n\t\t\treturn TestId.compare(this.toString(), other);\n\t\t}\n\n\t\tfor (let i = 0; i < other.viewEnd && i < this.viewEnd; i++) {\n\t\t\tif (other.path[i] !== this.path[i]) {\n\t\t\t\treturn TestPosition.Disconnected;\n\t\t\t}\n\t\t}\n\n\t\tif (other.viewEnd > this.viewEnd) {\n\t\t\treturn TestPosition.IsChild;\n\t\t}\n\n\t\tif (other.viewEnd < this.viewEnd) {\n\t\t\treturn TestPosition.IsParent;\n\t\t}\n\n\t\treturn TestPosition.IsSame;\n\t}\n\n\t/**\n\t * Serializes the ID.\n\t */\n\tpublic toJSON() {\n\t\treturn this.toString();\n\t}\n\n\t/**\n\t * Serializes the ID to a string.\n\t */\n\tpublic toString() {\n\t\tif (!this.stringifed) {\n\t\t\tthis.stringifed = this.path[0];\n\t\t\tfor (let i = 1; i < this.viewEnd; i++) {\n\t\t\t\tthis.stringifed += TestIdPathParts.Delimiter;\n\t\t\t\tthis.stringifed += this.path[i];\n\t\t\t}\n\t\t}\n\n\t\treturn this.stringifed;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum TestIdPathParts {\n\t/** Delimiter for path parts in test IDs */\n\tDelimiter = '\\0',\n}\n\n/**\n * Enum for describing relative positions of tests. Similar to\n * `node.compareDocumentPosition` in the DOM.\n */\nexport const enum TestPosition {\n\t/** a === b */\n\tIsSame,\n\t/** Neither a nor b are a child of one another. They may share a common parent, though. */\n\tDisconnected,\n\t/** b is a child of a */\n\tIsChild,\n\t/** b is a parent of a */\n\tIsParent,\n}\n\ntype TestItemLike = { id: string; parent?: TestItemLike; _isRoot?: boolean };\n\n/**\n * The test ID is a stringifiable client that\n */\nexport class TestId {\n\tprivate stringifed?: string;\n\n\t/**\n\t * Creates a test ID from an ext host test item.\n\t */\n\tpublic static fromExtHostTestItem(item: TestItemLike, rootId: string, parent = item.parent) {\n\t\tif (item._isRoot) {\n\t\t\treturn new TestId([rootId]);\n\t\t}\n\n\t\tconst path = [item.id];\n\t\tfor (let i = parent; i && i.id !== rootId; i = i.parent) {\n\t\t\tpath.push(i.id);\n\t\t}\n\t\tpath.push(rootId);\n\n\t\treturn new TestId(path.reverse());\n\t}\n\n\t/**\n\t * Cheaply ets whether the ID refers to the root .\n\t */\n\tpublic static isRoot(idString: string) {\n\t\treturn !idString.includes(TestIdPathParts.Delimiter);\n\t}\n\n\t/**\n\t * Cheaply gets whether the ID refers to the root .\n\t */\n\tpublic static root(idString: string) {\n\t\tconst idx = idString.indexOf(TestIdPathParts.Delimiter);\n\t\treturn idx === -1 ? idString : idString.slice(0, idx);\n\t}\n\n\t/**\n\t * Creates a test ID from a serialized TestId instance.\n\t */\n\tpublic static fromString(idString: string) {\n\t\treturn new TestId(idString.split(TestIdPathParts.Delimiter));\n\t}\n\n\t/**\n\t * Gets the ID resulting from adding b to the base ID.\n\t */\n\tpublic static join(base: TestId, b: string) {\n\t\treturn new TestId([...base.path, b]);\n\t}\n\n\t/**\n\t * Splits a test ID into its parts.\n\t */\n\tpublic static split(idString: string) {\n\t\treturn idString.split(TestIdPathParts.Delimiter);\n\t}\n\n\t/**\n\t * Gets the string ID resulting from adding b to the base ID.\n\t */\n\tpublic static joinToString(base: string | TestId, b: string) {\n\t\treturn base.toString() + TestIdPathParts.Delimiter + b;\n\t}\n\n\t/**\n\t * Cheaply gets the parent ID of a test identified with the string.\n\t */\n\tpublic static parentId(idString: string) {\n\t\tconst idx = idString.lastIndexOf(TestIdPathParts.Delimiter);\n\t\treturn idx === -1 ? undefined : idString.slice(0, idx);\n\t}\n\n\t/**\n\t * Cheaply gets the local ID of a test identified with the string.\n\t */\n\tpublic static localId(idString: string) {\n\t\tconst idx = idString.lastIndexOf(TestIdPathParts.Delimiter);\n\t\treturn idx === -1 ? idString : idString.slice(idx + TestIdPathParts.Delimiter.length);\n\t}\n\n\t/**\n\t * Gets whether maybeChild is a child of maybeParent.\n\t * todo@connor4312: review usages of this to see if using the WellDefinedPrefixTree is better\n\t */\n\tpublic static isChild(maybeParent: string, maybeChild: string) {\n\t\treturn maybeChild[maybeParent.length] === TestIdPathParts.Delimiter && maybeChild.startsWith(maybeParent);\n\t}\n\n\t/**\n\t * Compares the position of the two ID strings.\n\t * todo@connor4312: review usages of this to see if using the WellDefinedPrefixTree is better\n\t */\n\tpublic static compare(a: string, b: string) {\n\t\tif (a === b) {\n\t\t\treturn TestPosition.IsSame;\n\t\t}\n\n\t\tif (TestId.isChild(a, b)) {\n\t\t\treturn TestPosition.IsChild;\n\t\t}\n\n\t\tif (TestId.isChild(b, a)) {\n\t\t\treturn TestPosition.IsParent;\n\t\t}\n\n\t\treturn TestPosition.Disconnected;\n\t}\n\n\tpublic static getLengthOfCommonPrefix(length: number, getId: (i: number) => TestId): number {\n\t\tif (length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet commonPrefix = 0;\n\t\twhile (commonPrefix < length - 1) {\n\t\t\tfor (let i = 1; i < length; i++) {\n\t\t\t\tconst a = getId(i - 1);\n\t\t\t\tconst b = getId(i);\n\t\t\t\tif (a.path[commonPrefix] !== b.path[commonPrefix]) {\n\t\t\t\t\treturn commonPrefix;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcommonPrefix++;\n\t\t}\n\n\t\treturn commonPrefix;\n\t}\n\n\tconstructor(\n\t\tpublic readonly path: readonly string[],\n\t\tprivate readonly viewEnd = path.length,\n\t) {\n\t\tif (path.length === 0 || viewEnd < 1) {\n\t\t\tthrow new Error('cannot create test with empty path');\n\t\t}\n\t}\n\n\t/**\n\t * Gets the ID of the parent test.\n\t */\n\tpublic get rootId(): TestId {\n\t\treturn new TestId(this.path, 1);\n\t}\n\n\t/**\n\t * Gets the ID of the parent test.\n\t */\n\tpublic get parentId(): TestId | undefined {\n\t\treturn this.viewEnd > 1 ? new TestId(this.path, this.viewEnd - 1) : undefined;\n\t}\n\n\t/**\n\t * Gets the local ID of the current full test ID.\n\t */\n\tpublic get localId() {\n\t\treturn this.path[this.viewEnd - 1];\n\t}\n\n\t/**\n\t * Gets whether this ID refers to the root.\n\t */\n\tpublic get controllerId() {\n\t\treturn this.path[0];\n\t}\n\n\t/**\n\t * Gets whether this ID refers to the root.\n\t */\n\tpublic get isRoot() {\n\t\treturn this.viewEnd === 1;\n\t}\n\n\t/**\n\t * Returns an iterable that yields IDs of all parent items down to and\n\t * including the current item.\n\t */\n\tpublic *idsFromRoot() {\n\t\tfor (let i = 1; i <= this.viewEnd; i++) {\n\t\t\tyield new TestId(this.path, i);\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterable that yields IDs of the current item up to the root\n\t * item.\n\t */\n\tpublic *idsToRoot() {\n\t\tfor (let i = this.viewEnd; i > 0; i--) {\n\t\t\tyield new TestId(this.path, i);\n\t\t}\n\t}\n\n\t/**\n\t * Compares the other test ID with this one.\n\t */\n\tpublic compare(other: TestId | string) {\n\t\tif (typeof other === 'string') {\n\t\t\treturn TestId.compare(this.toString(), other);\n\t\t}\n\n\t\tfor (let i = 0; i < other.viewEnd && i < this.viewEnd; i++) {\n\t\t\tif (other.path[i] !== this.path[i]) {\n\t\t\t\treturn TestPosition.Disconnected;\n\t\t\t}\n\t\t}\n\n\t\tif (other.viewEnd > this.viewEnd) {\n\t\t\treturn TestPosition.IsChild;\n\t\t}\n\n\t\tif (other.viewEnd < this.viewEnd) {\n\t\t\treturn TestPosition.IsParent;\n\t\t}\n\n\t\treturn TestPosition.IsSame;\n\t}\n\n\t/**\n\t * Serializes the ID.\n\t */\n\tpublic toJSON() {\n\t\treturn this.toString();\n\t}\n\n\t/**\n\t * Serializes the ID to a string.\n\t */\n\tpublic toString() {\n\t\tif (!this.stringifed) {\n\t\t\tthis.stringifed = this.path[0];\n\t\t\tfor (let i = 1; i < this.viewEnd; i++) {\n\t\t\t\tthis.stringifed += TestIdPathParts.Delimiter;\n\t\t\t\tthis.stringifed += this.path[i];\n\t\t\t}\n\t\t}\n\n\t\treturn this.stringifed;\n\t}\n}\n"]}