{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/common/testExplorerFilterState.ts","vs/workbench/contrib/testing/common/testExplorerFilterState.ts"],"names":[],"mappings":"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","file":"testExplorerFilterState.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { splitGlobAware } from '../../../../base/common/glob.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ISettableObservable, observableValue } from '../../../../base/common/observable.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { IObservableValue, MutableObservableValue } from './observableValue.js';\nimport { StoredValue } from './storedValue.js';\nimport { namespaceTestTag } from './testTypes.js';\n\nexport interface ITestExplorerFilterState {\n\t_serviceBrand: undefined;\n\n\t/** Current filter text */\n\treadonly text: IObservableValue<string>;\n\n\t/** Test ID the user wants to reveal in the explorer */\n\treadonly reveal: ISettableObservable<string | undefined>;\n\n\t/** A test was selected in the explorer. */\n\treadonly onDidSelectTestInExplorer: Event<string | undefined>;\n\n\t/** Event that fires when {@link focusInput} is invoked. */\n\treadonly onDidRequestInputFocus: Event<void>;\n\n\t/**\n\t * Glob list to filter for based on the {@link text}\n\t */\n\treadonly globList: readonly { include: boolean; text: string }[];\n\n\t/**\n\t * The user requested to filter including tags.\n\t */\n\treadonly includeTags: ReadonlySet<string>;\n\n\t/**\n\t * The user requested to filter excluding tags.\n\t */\n\treadonly excludeTags: ReadonlySet<string>;\n\n\t/**\n\t * Whether fuzzy searching is enabled.\n\t */\n\treadonly fuzzy: MutableObservableValue<boolean>;\n\n\t/**\n\t * Focuses the filter input in the test explorer view.\n\t */\n\tfocusInput(): void;\n\n\t/**\n\t * Replaces the filter {@link text}.\n\t */\n\tsetText(text: string): void;\n\n\t/**\n\t * Sets whether the {@link text} is filtering for a special term.\n\t */\n\tisFilteringFor(term: TestFilterTerm): boolean;\n\n\t/**\n\t * Sets whether the {@link text} includes a special filter term.\n\t */\n\ttoggleFilteringFor(term: TestFilterTerm, shouldFilter?: boolean): void;\n\n\t/**\n\t * Called when a test in the test explorer is selected.\n\t */\n\tdidSelectTestInExplorer(testId: string): void;\n}\n\nexport const ITestExplorerFilterState = createDecorator<ITestExplorerFilterState>('testingFilterState');\n\nconst tagRe = /!?@([^ ,:]+)/g;\nconst trimExtraWhitespace = (str: string) => str.replace(/\\s\\s+/g, ' ').trim();\n\nexport class TestExplorerFilterState extends Disposable implements ITestExplorerFilterState {\n\tdeclare _serviceBrand: undefined;\n\tprivate readonly focusEmitter = new Emitter<void>();\n\t/**\n\t * Mapping of terms to whether they're included in the text.\n\t */\n\tprivate termFilterState: { [K in TestFilterTerm]?: true } = {};\n\n\t/** @inheritdoc */\n\tpublic globList: { include: boolean; text: string }[] = [];\n\n\t/** @inheritdoc */\n\tpublic includeTags = new Set<string>();\n\n\t/** @inheritdoc */\n\tpublic excludeTags = new Set<string>();\n\n\t/** @inheritdoc */\n\tpublic readonly text = this._register(new MutableObservableValue(''));\n\n\t/** @inheritdoc */\n\tpublic readonly fuzzy: MutableObservableValue<boolean>;\n\n\tpublic readonly reveal: ISettableObservable<string | undefined> = observableValue('TestExplorerFilterState.reveal', undefined);\n\n\tpublic readonly onDidRequestInputFocus = this.focusEmitter.event;\n\n\tprivate selectTestInExplorerEmitter = this._register(new Emitter<string | undefined>());\n\tpublic readonly onDidSelectTestInExplorer = this.selectTestInExplorerEmitter.event;\n\n\tconstructor(\n\t\t@IStorageService storageService: IStorageService,\n\t) {\n\t\tsuper();\n\t\tthis.fuzzy = this._register(MutableObservableValue.stored(new StoredValue<boolean>({\n\t\t\tkey: 'testHistoryFuzzy',\n\t\t\tscope: StorageScope.PROFILE,\n\t\t\ttarget: StorageTarget.USER,\n\t\t}, storageService), false));\n\t}\n\n\t/** @inheritdoc */\n\tpublic didSelectTestInExplorer(testId: string) {\n\t\tthis.selectTestInExplorerEmitter.fire(testId);\n\t}\n\n\t/** @inheritdoc */\n\tpublic focusInput() {\n\t\tthis.focusEmitter.fire();\n\t}\n\n\t/** @inheritdoc */\n\tpublic setText(text: string) {\n\t\tif (text === this.text.value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.termFilterState = {};\n\t\tthis.globList = [];\n\t\tthis.includeTags.clear();\n\t\tthis.excludeTags.clear();\n\n\t\tlet globText = '';\n\t\tlet lastIndex = 0;\n\t\tfor (const match of text.matchAll(tagRe)) {\n\t\t\tlet nextIndex = match.index + match[0].length;\n\n\t\t\tconst tag = match[0];\n\t\t\tif (allTestFilterTerms.includes(tag as TestFilterTerm)) {\n\t\t\t\tthis.termFilterState[tag as TestFilterTerm] = true;\n\t\t\t}\n\n\t\t\t// recognize and parse @ctrlId:tagId or quoted like @ctrlId:\"tag \\\\\"id\"\n\t\t\tif (text[nextIndex] === ':') {\n\t\t\t\tnextIndex++;\n\n\t\t\t\tlet delimiter = text[nextIndex];\n\t\t\t\tif (delimiter !== `\"` && delimiter !== `'`) {\n\t\t\t\t\tdelimiter = ' ';\n\t\t\t\t} else {\n\t\t\t\t\tnextIndex++;\n\t\t\t\t}\n\n\t\t\t\tlet tagId = '';\n\t\t\t\twhile (nextIndex < text.length && text[nextIndex] !== delimiter) {\n\t\t\t\t\tif (text[nextIndex] === '\\\\') {\n\t\t\t\t\t\ttagId += text[nextIndex + 1];\n\t\t\t\t\t\tnextIndex += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttagId += text[nextIndex];\n\t\t\t\t\t\tnextIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (match[0].startsWith('!')) {\n\t\t\t\t\tthis.excludeTags.add(namespaceTestTag(match[1], tagId));\n\t\t\t\t} else {\n\t\t\t\t\tthis.includeTags.add(namespaceTestTag(match[1], tagId));\n\t\t\t\t}\n\t\t\t\tnextIndex++;\n\t\t\t}\n\n\t\t\tglobText += text.slice(lastIndex, match.index);\n\t\t\tlastIndex = nextIndex;\n\t\t}\n\n\t\tglobText += text.slice(lastIndex).trim();\n\n\t\tif (globText.length) {\n\t\t\tfor (const filter of splitGlobAware(globText, ',').map(s => s.trim()).filter(s => !!s.length)) {\n\t\t\t\tif (filter.startsWith('!')) {\n\t\t\t\t\tthis.globList.push({ include: false, text: filter.slice(1).toLowerCase() });\n\t\t\t\t} else {\n\t\t\t\t\tthis.globList.push({ include: true, text: filter.toLowerCase() });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.text.value = text; // purposely afterwards so everything is updated when the change event happen\n\t}\n\n\t/** @inheritdoc */\n\tpublic isFilteringFor(term: TestFilterTerm) {\n\t\treturn !!this.termFilterState[term];\n\t}\n\n\t/** @inheritdoc */\n\tpublic toggleFilteringFor(term: TestFilterTerm, shouldFilter?: boolean) {\n\t\tconst text = this.text.value.trim();\n\t\tif (shouldFilter !== false && !this.termFilterState[term]) {\n\t\t\tthis.setText(text ? `${text} ${term}` : term);\n\t\t} else if (shouldFilter !== true && this.termFilterState[term]) {\n\t\t\tthis.setText(trimExtraWhitespace(text.replace(term, '')));\n\t\t}\n\t}\n}\n\nexport const enum TestFilterTerm {\n\tFailed = '@failed',\n\tExecuted = '@executed',\n\tCurrentDoc = '@doc',\n\tOpenedFiles = '@openedFiles',\n\tHidden = '@hidden',\n}\n\nconst allTestFilterTerms: readonly TestFilterTerm[] = [\n\tTestFilterTerm.Failed,\n\tTestFilterTerm.Executed,\n\tTestFilterTerm.CurrentDoc,\n\tTestFilterTerm.OpenedFiles,\n\tTestFilterTerm.Hidden,\n];\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { splitGlobAware } from '../../../../base/common/glob.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ISettableObservable, observableValue } from '../../../../base/common/observable.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { IObservableValue, MutableObservableValue } from './observableValue.js';\nimport { StoredValue } from './storedValue.js';\nimport { namespaceTestTag } from './testTypes.js';\n\nexport interface ITestExplorerFilterState {\n\t_serviceBrand: undefined;\n\n\t/** Current filter text */\n\treadonly text: IObservableValue<string>;\n\n\t/** Test ID the user wants to reveal in the explorer */\n\treadonly reveal: ISettableObservable<string | undefined>;\n\n\t/** A test was selected in the explorer. */\n\treadonly onDidSelectTestInExplorer: Event<string | undefined>;\n\n\t/** Event that fires when {@link focusInput} is invoked. */\n\treadonly onDidRequestInputFocus: Event<void>;\n\n\t/**\n\t * Glob list to filter for based on the {@link text}\n\t */\n\treadonly globList: readonly { include: boolean; text: string }[];\n\n\t/**\n\t * The user requested to filter including tags.\n\t */\n\treadonly includeTags: ReadonlySet<string>;\n\n\t/**\n\t * The user requested to filter excluding tags.\n\t */\n\treadonly excludeTags: ReadonlySet<string>;\n\n\t/**\n\t * Whether fuzzy searching is enabled.\n\t */\n\treadonly fuzzy: MutableObservableValue<boolean>;\n\n\t/**\n\t * Focuses the filter input in the test explorer view.\n\t */\n\tfocusInput(): void;\n\n\t/**\n\t * Replaces the filter {@link text}.\n\t */\n\tsetText(text: string): void;\n\n\t/**\n\t * Sets whether the {@link text} is filtering for a special term.\n\t */\n\tisFilteringFor(term: TestFilterTerm): boolean;\n\n\t/**\n\t * Sets whether the {@link text} includes a special filter term.\n\t */\n\ttoggleFilteringFor(term: TestFilterTerm, shouldFilter?: boolean): void;\n\n\t/**\n\t * Called when a test in the test explorer is selected.\n\t */\n\tdidSelectTestInExplorer(testId: string): void;\n}\n\nexport const ITestExplorerFilterState = createDecorator<ITestExplorerFilterState>('testingFilterState');\n\nconst tagRe = /!?@([^ ,:]+)/g;\nconst trimExtraWhitespace = (str: string) => str.replace(/\\s\\s+/g, ' ').trim();\n\nexport class TestExplorerFilterState extends Disposable implements ITestExplorerFilterState {\n\tdeclare _serviceBrand: undefined;\n\tprivate readonly focusEmitter = new Emitter<void>();\n\t/**\n\t * Mapping of terms to whether they're included in the text.\n\t */\n\tprivate termFilterState: { [K in TestFilterTerm]?: true } = {};\n\n\t/** @inheritdoc */\n\tpublic globList: { include: boolean; text: string }[] = [];\n\n\t/** @inheritdoc */\n\tpublic includeTags = new Set<string>();\n\n\t/** @inheritdoc */\n\tpublic excludeTags = new Set<string>();\n\n\t/** @inheritdoc */\n\tpublic readonly text = this._register(new MutableObservableValue(''));\n\n\t/** @inheritdoc */\n\tpublic readonly fuzzy: MutableObservableValue<boolean>;\n\n\tpublic readonly reveal: ISettableObservable<string | undefined> = observableValue('TestExplorerFilterState.reveal', undefined);\n\n\tpublic readonly onDidRequestInputFocus = this.focusEmitter.event;\n\n\tprivate selectTestInExplorerEmitter = this._register(new Emitter<string | undefined>());\n\tpublic readonly onDidSelectTestInExplorer = this.selectTestInExplorerEmitter.event;\n\n\tconstructor(\n\t\t@IStorageService storageService: IStorageService,\n\t) {\n\t\tsuper();\n\t\tthis.fuzzy = this._register(MutableObservableValue.stored(new StoredValue<boolean>({\n\t\t\tkey: 'testHistoryFuzzy',\n\t\t\tscope: StorageScope.PROFILE,\n\t\t\ttarget: StorageTarget.USER,\n\t\t}, storageService), false));\n\t}\n\n\t/** @inheritdoc */\n\tpublic didSelectTestInExplorer(testId: string) {\n\t\tthis.selectTestInExplorerEmitter.fire(testId);\n\t}\n\n\t/** @inheritdoc */\n\tpublic focusInput() {\n\t\tthis.focusEmitter.fire();\n\t}\n\n\t/** @inheritdoc */\n\tpublic setText(text: string) {\n\t\tif (text === this.text.value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.termFilterState = {};\n\t\tthis.globList = [];\n\t\tthis.includeTags.clear();\n\t\tthis.excludeTags.clear();\n\n\t\tlet globText = '';\n\t\tlet lastIndex = 0;\n\t\tfor (const match of text.matchAll(tagRe)) {\n\t\t\tlet nextIndex = match.index + match[0].length;\n\n\t\t\tconst tag = match[0];\n\t\t\tif (allTestFilterTerms.includes(tag as TestFilterTerm)) {\n\t\t\t\tthis.termFilterState[tag as TestFilterTerm] = true;\n\t\t\t}\n\n\t\t\t// recognize and parse @ctrlId:tagId or quoted like @ctrlId:\"tag \\\\\"id\"\n\t\t\tif (text[nextIndex] === ':') {\n\t\t\t\tnextIndex++;\n\n\t\t\t\tlet delimiter = text[nextIndex];\n\t\t\t\tif (delimiter !== `\"` && delimiter !== `'`) {\n\t\t\t\t\tdelimiter = ' ';\n\t\t\t\t} else {\n\t\t\t\t\tnextIndex++;\n\t\t\t\t}\n\n\t\t\t\tlet tagId = '';\n\t\t\t\twhile (nextIndex < text.length && text[nextIndex] !== delimiter) {\n\t\t\t\t\tif (text[nextIndex] === '\\\\') {\n\t\t\t\t\t\ttagId += text[nextIndex + 1];\n\t\t\t\t\t\tnextIndex += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttagId += text[nextIndex];\n\t\t\t\t\t\tnextIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (match[0].startsWith('!')) {\n\t\t\t\t\tthis.excludeTags.add(namespaceTestTag(match[1], tagId));\n\t\t\t\t} else {\n\t\t\t\t\tthis.includeTags.add(namespaceTestTag(match[1], tagId));\n\t\t\t\t}\n\t\t\t\tnextIndex++;\n\t\t\t}\n\n\t\t\tglobText += text.slice(lastIndex, match.index);\n\t\t\tlastIndex = nextIndex;\n\t\t}\n\n\t\tglobText += text.slice(lastIndex).trim();\n\n\t\tif (globText.length) {\n\t\t\tfor (const filter of splitGlobAware(globText, ',').map(s => s.trim()).filter(s => !!s.length)) {\n\t\t\t\tif (filter.startsWith('!')) {\n\t\t\t\t\tthis.globList.push({ include: false, text: filter.slice(1).toLowerCase() });\n\t\t\t\t} else {\n\t\t\t\t\tthis.globList.push({ include: true, text: filter.toLowerCase() });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.text.value = text; // purposely afterwards so everything is updated when the change event happen\n\t}\n\n\t/** @inheritdoc */\n\tpublic isFilteringFor(term: TestFilterTerm) {\n\t\treturn !!this.termFilterState[term];\n\t}\n\n\t/** @inheritdoc */\n\tpublic toggleFilteringFor(term: TestFilterTerm, shouldFilter?: boolean) {\n\t\tconst text = this.text.value.trim();\n\t\tif (shouldFilter !== false && !this.termFilterState[term]) {\n\t\t\tthis.setText(text ? `${text} ${term}` : term);\n\t\t} else if (shouldFilter !== true && this.termFilterState[term]) {\n\t\t\tthis.setText(trimExtraWhitespace(text.replace(term, '')));\n\t\t}\n\t}\n}\n\nexport const enum TestFilterTerm {\n\tFailed = '@failed',\n\tExecuted = '@executed',\n\tCurrentDoc = '@doc',\n\tOpenedFiles = '@openedFiles',\n\tHidden = '@hidden',\n}\n\nconst allTestFilterTerms: readonly TestFilterTerm[] = [\n\tTestFilterTerm.Failed,\n\tTestFilterTerm.Executed,\n\tTestFilterTerm.CurrentDoc,\n\tTestFilterTerm.OpenedFiles,\n\tTestFilterTerm.Hidden,\n];\n"]}