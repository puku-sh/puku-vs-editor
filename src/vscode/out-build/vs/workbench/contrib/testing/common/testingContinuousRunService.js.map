{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/common/testingContinuousRunService.ts","vs/workbench/contrib/testing/common/testingContinuousRunService.ts"],"names":[],"mappings":"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","file":"testingContinuousRunService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable, DisposableMap, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { autorunIterableDelta, ISettableObservable, observableValue } from '../../../../base/common/observable.js';\nimport { WellDefinedPrefixTree } from '../../../../base/common/prefixTree.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { StoredValue } from './storedValue.js';\nimport { TestId } from './testId.js';\nimport { TestingContextKeys } from './testingContextKeys.js';\nimport { ITestProfileService } from './testProfileService.js';\nimport { ITestService } from './testService.js';\nimport { ITestRunProfile, TestRunProfileBitset } from './testTypes.js';\n\nexport const ITestingContinuousRunService = createDecorator<ITestingContinuousRunService>('testingContinuousRunService');\n\nexport interface ITestingContinuousRunService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Gets a list of the last test profiles that were continuously run in the workspace.\n\t */\n\treadonly lastRunProfileIds: ReadonlySet<number>;\n\n\t/**\n\t * Fired when a test is added or removed from continous run, or when\n\t * enablement is changed globally.\n\t */\n\treadonly onDidChange: Event<string | undefined>;\n\n\t/**\n\t * Gets whether continous run is specifically enabled for the given test ID.\n\t */\n\tisSpecificallyEnabledFor(testId: string): boolean;\n\n\t/**\n\t * Gets whether continous run is specifically enabled for\n\t * the given test ID, or any of its parents.\n\t */\n\tisEnabledForAParentOf(testId: string): boolean;\n\n\t/**\n\t * Gets whether continous run is specifically enabled for\n\t * the given test ID, or any of its parents.\n\t */\n\tisEnabledForAChildOf(testId: string): boolean;\n\n\t/**\n\t * Gets whether continuous run is turned on for the given profile.\n\t */\n\tisEnabledForProfile(profile: ITestRunProfile): boolean;\n\n\t/**\n\t * Gets whether it's enabled at all.\n\t */\n\tisEnabled(): boolean;\n\n\t/**\n\t * Starts a continuous auto run with a specific set of profiles, or all\n\t * default profiles in a group. Globally if no test is given,\n\t * for a specific test otherwise.\n\t */\n\tstart(profile: ITestRunProfile[] | TestRunProfileBitset, testId?: string): void;\n\n\t/**\n\t * Stops a continuous run for the given test profile.\n\t */\n\tstopProfile(profile: ITestRunProfile): void;\n\n\t/**\n\t * Stops any continuous run\n\t * Globally if no test is given, for a specific test otherwise.\n\t */\n\tstop(testId?: string): void;\n}\n\ntype RunningRef = { path: readonly string[]; profiles: ISettableObservable<ITestRunProfile[]>; autoSetDefault?: boolean; handle: DisposableStore };\n\nexport class TestingContinuousRunService extends Disposable implements ITestingContinuousRunService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly changeEmitter = new Emitter<string | undefined>();\n\tprivate readonly running = new WellDefinedPrefixTree<RunningRef>();\n\tprivate readonly lastRun: StoredValue<Set<number>>;\n\n\tpublic readonly onDidChange = this.changeEmitter.event;\n\n\tpublic get lastRunProfileIds() {\n\t\treturn this.lastRun.get(new Set());\n\t}\n\n\tconstructor(\n\t\t@ITestService private readonly testService: ITestService,\n\t\t@IStorageService storageService: IStorageService,\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@ITestProfileService private readonly testProfileService: ITestProfileService,\n\t) {\n\t\tsuper();\n\t\tconst isGloballyOn = TestingContextKeys.isContinuousModeOn.bindTo(contextKeyService);\n\t\tthis._register(this.onDidChange(() => {\n\t\t\tisGloballyOn.set(!!this.running.root.value);\n\t\t}));\n\t\tthis.lastRun = this._register(new StoredValue<Set<number>>({\n\t\t\tkey: 'lastContinuousRunProfileIds',\n\t\t\tscope: StorageScope.WORKSPACE,\n\t\t\ttarget: StorageTarget.MACHINE,\n\t\t\tserialization: {\n\t\t\t\tdeserialize: v => new Set(JSON.parse(v)),\n\t\t\t\tserialize: v => JSON.stringify([...v])\n\t\t\t},\n\t\t}, storageService));\n\n\t\tthis._register(toDisposable(() => {\n\t\t\tfor (const cts of this.running.values()) {\n\t\t\t\tcts.handle.dispose();\n\t\t\t}\n\t\t}));\n\t}\n\n\t/** @inheritdoc */\n\tpublic isSpecificallyEnabledFor(testId: string): boolean {\n\t\treturn this.running.size > 0 && this.running.hasKey(TestId.fromString(testId).path);\n\t}\n\n\t/** @inheritdoc */\n\tpublic isEnabledForAParentOf(testId: string): boolean {\n\t\treturn !!this.running.root.value || (this.running.size > 0 && this.running.hasKeyOrParent(TestId.fromString(testId).path));\n\t}\n\n\t/** @inheritdoc */\n\tpublic isEnabledForProfile({ profileId, controllerId }: ITestRunProfile): boolean {\n\t\tfor (const node of this.running.values()) {\n\t\t\tif (node.profiles.get().some(p => p.profileId === profileId && p.controllerId === controllerId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** @inheritdoc */\n\tpublic isEnabledForAChildOf(testId: string): boolean {\n\t\treturn !!this.running.root.value || (this.running.size > 0 && this.running.hasKeyOrChildren(TestId.fromString(testId).path));\n\t}\n\n\t/** @inheritdoc */\n\tpublic isEnabled(): boolean {\n\t\treturn !!this.running.root.value || this.running.size > 0;\n\t}\n\n\t/** @inheritdoc */\n\tpublic start(profiles: ITestRunProfile[] | TestRunProfileBitset, testId?: string): void {\n\t\tconst store = new DisposableStore();\n\n\t\tlet actualProfiles: ISettableObservable<ITestRunProfile[]>;\n\t\tif (profiles instanceof Array) {\n\t\t\tactualProfiles = observableValue('crProfiles', profiles);\n\t\t} else {\n\t\t\t// restart the continuous run when default profiles change, if we were\n\t\t\t// asked to run for a group\n\t\t\tconst getRelevant = () => this.testProfileService.getGroupDefaultProfiles(profiles)\n\t\t\t\t.filter(p => p.supportsContinuousRun && (!testId || TestId.root(testId) === p.controllerId));\n\t\t\tactualProfiles = observableValue('crProfiles', getRelevant());\n\t\t\tstore.add(this.testProfileService.onDidChange(() => {\n\t\t\t\tif (ref.autoSetDefault) {\n\t\t\t\t\tconst newRelevant = getRelevant();\n\t\t\t\t\tif (!arrays.equals(newRelevant, actualProfiles.get())) {\n\t\t\t\t\t\tactualProfiles.set(getRelevant(), undefined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\n\t\tconst path = testId ? TestId.fromString(testId).path : [];\n\t\tconst ref: RunningRef = { profiles: actualProfiles, handle: store, path, autoSetDefault: typeof profiles === 'number' };\n\n\t\t// If we're already running this specific test, then add the profile and turn\n\t\t// off the auto-addition of bitset-based profiles.\n\t\tconst existing = this.running.find(path);\n\t\tif (existing) {\n\t\t\tstore.dispose();\n\t\t\tref.autoSetDefault = existing.autoSetDefault = false;\n\t\t\texisting.profiles.set([...new Set([...actualProfiles.get(), ...existing.profiles.get()])], undefined);\n\t\t\tthis.changeEmitter.fire(testId);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.running.insert(path, ref);\n\n\t\tconst cancellationStores = new DisposableMap<ITestRunProfile, CancellationTokenSource>();\n\t\tstore.add(toDisposable(() => {\n\t\t\tfor (const cts of cancellationStores.values()) {\n\t\t\t\tcts.cancel();\n\t\t\t}\n\t\t\tcancellationStores.dispose();\n\t\t}));\n\t\tstore.add(autorunIterableDelta(reader => actualProfiles.read(reader), ({ addedValues, removedValues }) => {\n\t\t\tfor (const profile of addedValues) {\n\t\t\t\tconst cts = new CancellationTokenSource();\n\t\t\t\tthis.testService.startContinuousRun({\n\t\t\t\t\tcontinuous: true,\n\t\t\t\t\tgroup: profile.group,\n\t\t\t\t\ttargets: [{\n\t\t\t\t\t\ttestIds: [testId ?? profile.controllerId],\n\t\t\t\t\t\tcontrollerId: profile.controllerId,\n\t\t\t\t\t\tprofileId: profile.profileId\n\t\t\t\t\t}],\n\t\t\t\t}, cts.token);\n\t\t\t\tcancellationStores.set(profile, cts);\n\t\t\t}\n\n\t\t\tfor (const profile of removedValues) {\n\t\t\t\tcancellationStores.get(profile)?.cancel();\n\t\t\t\tcancellationStores.deleteAndDispose(profile);\n\t\t\t}\n\n\t\t\tthis.lastRun.store(new Set([...cancellationStores.keys()].map(p => p.profileId)));\n\t\t}));\n\n\t\tthis.changeEmitter.fire(testId);\n\t}\n\n\t/** Stops a continuous run for the profile across all test items that are running it. */\n\tstopProfile({ profileId, controllerId }: ITestRunProfile): void {\n\t\tconst toDelete: RunningRef[] = [];\n\t\tfor (const node of this.running.values()) {\n\t\t\tconst profs = node.profiles.get();\n\t\t\tconst filtered = profs.filter(p => p.profileId !== profileId || p.controllerId !== controllerId);\n\t\t\tif (filtered.length === profs.length) {\n\t\t\t\tcontinue;\n\t\t\t} else if (filtered.length === 0) {\n\t\t\t\ttoDelete.push(node);\n\t\t\t} else {\n\t\t\t\tnode.profiles.set(filtered, undefined);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = toDelete.length - 1; i >= 0; i--) {\n\t\t\ttoDelete[i].handle.dispose();\n\t\t\tthis.running.delete(toDelete[i].path);\n\t\t}\n\n\t\tthis.changeEmitter.fire(undefined);\n\t}\n\n\t/** @inheritdoc */\n\tpublic stop(testId?: string): void {\n\t\tconst cancellations = [...this.running.deleteRecursive(testId ? TestId.fromString(testId).path : [])];\n\t\t// deleteRecursive returns a BFS order, reverse it so children are cancelled before parents\n\t\tfor (let i = cancellations.length - 1; i >= 0; i--) {\n\t\t\tcancellations[i].handle.dispose();\n\t\t}\n\n\t\tthis.changeEmitter.fire(testId);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable, DisposableMap, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { autorunIterableDelta, ISettableObservable, observableValue } from '../../../../base/common/observable.js';\nimport { WellDefinedPrefixTree } from '../../../../base/common/prefixTree.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { StoredValue } from './storedValue.js';\nimport { TestId } from './testId.js';\nimport { TestingContextKeys } from './testingContextKeys.js';\nimport { ITestProfileService } from './testProfileService.js';\nimport { ITestService } from './testService.js';\nimport { ITestRunProfile, TestRunProfileBitset } from './testTypes.js';\n\nexport const ITestingContinuousRunService = createDecorator<ITestingContinuousRunService>('testingContinuousRunService');\n\nexport interface ITestingContinuousRunService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Gets a list of the last test profiles that were continuously run in the workspace.\n\t */\n\treadonly lastRunProfileIds: ReadonlySet<number>;\n\n\t/**\n\t * Fired when a test is added or removed from continous run, or when\n\t * enablement is changed globally.\n\t */\n\treadonly onDidChange: Event<string | undefined>;\n\n\t/**\n\t * Gets whether continous run is specifically enabled for the given test ID.\n\t */\n\tisSpecificallyEnabledFor(testId: string): boolean;\n\n\t/**\n\t * Gets whether continous run is specifically enabled for\n\t * the given test ID, or any of its parents.\n\t */\n\tisEnabledForAParentOf(testId: string): boolean;\n\n\t/**\n\t * Gets whether continous run is specifically enabled for\n\t * the given test ID, or any of its parents.\n\t */\n\tisEnabledForAChildOf(testId: string): boolean;\n\n\t/**\n\t * Gets whether continuous run is turned on for the given profile.\n\t */\n\tisEnabledForProfile(profile: ITestRunProfile): boolean;\n\n\t/**\n\t * Gets whether it's enabled at all.\n\t */\n\tisEnabled(): boolean;\n\n\t/**\n\t * Starts a continuous auto run with a specific set of profiles, or all\n\t * default profiles in a group. Globally if no test is given,\n\t * for a specific test otherwise.\n\t */\n\tstart(profile: ITestRunProfile[] | TestRunProfileBitset, testId?: string): void;\n\n\t/**\n\t * Stops a continuous run for the given test profile.\n\t */\n\tstopProfile(profile: ITestRunProfile): void;\n\n\t/**\n\t * Stops any continuous run\n\t * Globally if no test is given, for a specific test otherwise.\n\t */\n\tstop(testId?: string): void;\n}\n\ntype RunningRef = { path: readonly string[]; profiles: ISettableObservable<ITestRunProfile[]>; autoSetDefault?: boolean; handle: DisposableStore };\n\nexport class TestingContinuousRunService extends Disposable implements ITestingContinuousRunService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly changeEmitter = new Emitter<string | undefined>();\n\tprivate readonly running = new WellDefinedPrefixTree<RunningRef>();\n\tprivate readonly lastRun: StoredValue<Set<number>>;\n\n\tpublic readonly onDidChange = this.changeEmitter.event;\n\n\tpublic get lastRunProfileIds() {\n\t\treturn this.lastRun.get(new Set());\n\t}\n\n\tconstructor(\n\t\t@ITestService private readonly testService: ITestService,\n\t\t@IStorageService storageService: IStorageService,\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@ITestProfileService private readonly testProfileService: ITestProfileService,\n\t) {\n\t\tsuper();\n\t\tconst isGloballyOn = TestingContextKeys.isContinuousModeOn.bindTo(contextKeyService);\n\t\tthis._register(this.onDidChange(() => {\n\t\t\tisGloballyOn.set(!!this.running.root.value);\n\t\t}));\n\t\tthis.lastRun = this._register(new StoredValue<Set<number>>({\n\t\t\tkey: 'lastContinuousRunProfileIds',\n\t\t\tscope: StorageScope.WORKSPACE,\n\t\t\ttarget: StorageTarget.MACHINE,\n\t\t\tserialization: {\n\t\t\t\tdeserialize: v => new Set(JSON.parse(v)),\n\t\t\t\tserialize: v => JSON.stringify([...v])\n\t\t\t},\n\t\t}, storageService));\n\n\t\tthis._register(toDisposable(() => {\n\t\t\tfor (const cts of this.running.values()) {\n\t\t\t\tcts.handle.dispose();\n\t\t\t}\n\t\t}));\n\t}\n\n\t/** @inheritdoc */\n\tpublic isSpecificallyEnabledFor(testId: string): boolean {\n\t\treturn this.running.size > 0 && this.running.hasKey(TestId.fromString(testId).path);\n\t}\n\n\t/** @inheritdoc */\n\tpublic isEnabledForAParentOf(testId: string): boolean {\n\t\treturn !!this.running.root.value || (this.running.size > 0 && this.running.hasKeyOrParent(TestId.fromString(testId).path));\n\t}\n\n\t/** @inheritdoc */\n\tpublic isEnabledForProfile({ profileId, controllerId }: ITestRunProfile): boolean {\n\t\tfor (const node of this.running.values()) {\n\t\t\tif (node.profiles.get().some(p => p.profileId === profileId && p.controllerId === controllerId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** @inheritdoc */\n\tpublic isEnabledForAChildOf(testId: string): boolean {\n\t\treturn !!this.running.root.value || (this.running.size > 0 && this.running.hasKeyOrChildren(TestId.fromString(testId).path));\n\t}\n\n\t/** @inheritdoc */\n\tpublic isEnabled(): boolean {\n\t\treturn !!this.running.root.value || this.running.size > 0;\n\t}\n\n\t/** @inheritdoc */\n\tpublic start(profiles: ITestRunProfile[] | TestRunProfileBitset, testId?: string): void {\n\t\tconst store = new DisposableStore();\n\n\t\tlet actualProfiles: ISettableObservable<ITestRunProfile[]>;\n\t\tif (profiles instanceof Array) {\n\t\t\tactualProfiles = observableValue('crProfiles', profiles);\n\t\t} else {\n\t\t\t// restart the continuous run when default profiles change, if we were\n\t\t\t// asked to run for a group\n\t\t\tconst getRelevant = () => this.testProfileService.getGroupDefaultProfiles(profiles)\n\t\t\t\t.filter(p => p.supportsContinuousRun && (!testId || TestId.root(testId) === p.controllerId));\n\t\t\tactualProfiles = observableValue('crProfiles', getRelevant());\n\t\t\tstore.add(this.testProfileService.onDidChange(() => {\n\t\t\t\tif (ref.autoSetDefault) {\n\t\t\t\t\tconst newRelevant = getRelevant();\n\t\t\t\t\tif (!arrays.equals(newRelevant, actualProfiles.get())) {\n\t\t\t\t\t\tactualProfiles.set(getRelevant(), undefined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\n\t\tconst path = testId ? TestId.fromString(testId).path : [];\n\t\tconst ref: RunningRef = { profiles: actualProfiles, handle: store, path, autoSetDefault: typeof profiles === 'number' };\n\n\t\t// If we're already running this specific test, then add the profile and turn\n\t\t// off the auto-addition of bitset-based profiles.\n\t\tconst existing = this.running.find(path);\n\t\tif (existing) {\n\t\t\tstore.dispose();\n\t\t\tref.autoSetDefault = existing.autoSetDefault = false;\n\t\t\texisting.profiles.set([...new Set([...actualProfiles.get(), ...existing.profiles.get()])], undefined);\n\t\t\tthis.changeEmitter.fire(testId);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.running.insert(path, ref);\n\n\t\tconst cancellationStores = new DisposableMap<ITestRunProfile, CancellationTokenSource>();\n\t\tstore.add(toDisposable(() => {\n\t\t\tfor (const cts of cancellationStores.values()) {\n\t\t\t\tcts.cancel();\n\t\t\t}\n\t\t\tcancellationStores.dispose();\n\t\t}));\n\t\tstore.add(autorunIterableDelta(reader => actualProfiles.read(reader), ({ addedValues, removedValues }) => {\n\t\t\tfor (const profile of addedValues) {\n\t\t\t\tconst cts = new CancellationTokenSource();\n\t\t\t\tthis.testService.startContinuousRun({\n\t\t\t\t\tcontinuous: true,\n\t\t\t\t\tgroup: profile.group,\n\t\t\t\t\ttargets: [{\n\t\t\t\t\t\ttestIds: [testId ?? profile.controllerId],\n\t\t\t\t\t\tcontrollerId: profile.controllerId,\n\t\t\t\t\t\tprofileId: profile.profileId\n\t\t\t\t\t}],\n\t\t\t\t}, cts.token);\n\t\t\t\tcancellationStores.set(profile, cts);\n\t\t\t}\n\n\t\t\tfor (const profile of removedValues) {\n\t\t\t\tcancellationStores.get(profile)?.cancel();\n\t\t\t\tcancellationStores.deleteAndDispose(profile);\n\t\t\t}\n\n\t\t\tthis.lastRun.store(new Set([...cancellationStores.keys()].map(p => p.profileId)));\n\t\t}));\n\n\t\tthis.changeEmitter.fire(testId);\n\t}\n\n\t/** Stops a continuous run for the profile across all test items that are running it. */\n\tstopProfile({ profileId, controllerId }: ITestRunProfile): void {\n\t\tconst toDelete: RunningRef[] = [];\n\t\tfor (const node of this.running.values()) {\n\t\t\tconst profs = node.profiles.get();\n\t\t\tconst filtered = profs.filter(p => p.profileId !== profileId || p.controllerId !== controllerId);\n\t\t\tif (filtered.length === profs.length) {\n\t\t\t\tcontinue;\n\t\t\t} else if (filtered.length === 0) {\n\t\t\t\ttoDelete.push(node);\n\t\t\t} else {\n\t\t\t\tnode.profiles.set(filtered, undefined);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = toDelete.length - 1; i >= 0; i--) {\n\t\t\ttoDelete[i].handle.dispose();\n\t\t\tthis.running.delete(toDelete[i].path);\n\t\t}\n\n\t\tthis.changeEmitter.fire(undefined);\n\t}\n\n\t/** @inheritdoc */\n\tpublic stop(testId?: string): void {\n\t\tconst cancellations = [...this.running.deleteRecursive(testId ? TestId.fromString(testId).path : [])];\n\t\t// deleteRecursive returns a BFS order, reverse it so children are cancelled before parents\n\t\tfor (let i = cancellations.length - 1; i >= 0; i--) {\n\t\t\tcancellations[i].handle.dispose();\n\t\t}\n\n\t\tthis.changeEmitter.fire(testId);\n\t}\n}\n"]}