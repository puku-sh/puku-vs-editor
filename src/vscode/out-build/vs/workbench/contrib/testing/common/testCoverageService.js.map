{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/common/testCoverageService.ts","vs/workbench/contrib/testing/common/testCoverageService.ts"],"names":[],"mappings":"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","file":"testCoverageService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { IObservable, ISettableObservable, observableValue, transaction } from '../../../../base/common/observable.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { bindContextKey, observableConfigValue } from '../../../../platform/observable/common/platformObservableUtils.js';\nimport { TestingConfigKeys } from './configuration.js';\nimport { Testing } from './constants.js';\nimport { TestCoverage } from './testCoverage.js';\nimport { TestId } from './testId.js';\nimport { ITestRunTaskResults } from './testResult.js';\nimport { ITestResultService } from './testResultService.js';\nimport { TestingContextKeys } from './testingContextKeys.js';\nimport { IViewsService } from '../../../services/views/common/viewsService.js';\n\nexport const ITestCoverageService = createDecorator<ITestCoverageService>('testCoverageService');\n\nexport interface ITestCoverageService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Settable observable that can be used to show the test coverage instance\n\t * currently in the editor.\n\t */\n\treadonly selected: IObservable<TestCoverage | undefined>;\n\n\t/**\n\t * Filter to per-test coverage from the given test ID.\n\t */\n\treadonly filterToTest: ISettableObservable<TestId | undefined>;\n\n\t/**\n\t * Whether inline coverage is shown.\n\t */\n\treadonly showInline: ISettableObservable<boolean>;\n\n\t/**\n\t * Opens a test coverage report from a task, optionally focusing it in the editor.\n\t */\n\topenCoverage(task: ITestRunTaskResults, focus?: boolean): Promise<void>;\n\n\t/**\n\t * Closes any open coverage.\n\t */\n\tcloseCoverage(): void;\n}\n\nexport class TestCoverageService extends Disposable implements ITestCoverageService {\n\tdeclare readonly _serviceBrand: undefined;\n\tprivate readonly lastOpenCts = this._register(new MutableDisposable<CancellationTokenSource>());\n\n\tpublic readonly selected = observableValue<TestCoverage | undefined>('testCoverage', undefined);\n\tpublic readonly filterToTest = observableValue<TestId | undefined>('filterToTest', undefined);\n\tpublic readonly showInline = observableValue('inlineCoverage', false);\n\n\tconstructor(\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@ITestResultService resultService: ITestResultService,\n\t\t@IConfigurationService configService: IConfigurationService,\n\t\t@IViewsService private readonly viewsService: IViewsService,\n\t) {\n\t\tsuper();\n\n\t\tconst toolbarConfig = observableConfigValue(TestingConfigKeys.CoverageToolbarEnabled, true, configService);\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.coverageToolbarEnabled,\n\t\t\tcontextKeyService,\n\t\t\treader => toolbarConfig.read(reader),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.inlineCoverageEnabled,\n\t\t\tcontextKeyService,\n\t\t\treader => this.showInline.read(reader),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.isTestCoverageOpen,\n\t\t\tcontextKeyService,\n\t\t\treader => !!this.selected.read(reader),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.hasPerTestCoverage,\n\t\t\tcontextKeyService,\n\t\t\treader => !Iterable.isEmpty(this.selected.read(reader)?.allPerTestIDs()),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.isCoverageFilteredToTest,\n\t\t\tcontextKeyService,\n\t\t\treader => !!this.filterToTest.read(reader),\n\t\t));\n\n\t\tthis._register(resultService.onResultsChanged(evt => {\n\t\t\tif ('completed' in evt) {\n\t\t\t\tconst coverage = evt.completed.tasks.find(t => t.coverage.get());\n\t\t\t\tif (coverage) {\n\t\t\t\t\tthis.openCoverage(coverage, false);\n\t\t\t\t} else {\n\t\t\t\t\tthis.closeCoverage();\n\t\t\t\t}\n\t\t\t} else if ('removed' in evt && this.selected.get()) {\n\t\t\t\tconst taskId = this.selected.get()?.fromTaskId;\n\t\t\t\tif (evt.removed.some(e => e.tasks.some(t => t.id === taskId))) {\n\t\t\t\t\tthis.closeCoverage();\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\t/** @inheritdoc */\n\tpublic async openCoverage(task: ITestRunTaskResults, focus = true) {\n\t\tthis.lastOpenCts.value?.cancel();\n\t\tconst cts = this.lastOpenCts.value = new CancellationTokenSource();\n\t\tconst coverage = task.coverage.get();\n\t\tif (!coverage) {\n\t\t\treturn;\n\t\t}\n\n\t\ttransaction(tx => {\n\t\t\t// todo: may want to preserve this if coverage for that test in the new run?\n\t\t\tthis.filterToTest.set(undefined, tx);\n\t\t\tthis.selected.set(coverage, tx);\n\t\t});\n\n\t\tif (focus && !cts.token.isCancellationRequested) {\n\t\t\tthis.viewsService.openView(Testing.CoverageViewId, true);\n\t\t}\n\t}\n\n\t/** @inheritdoc */\n\tpublic closeCoverage() {\n\t\tthis.selected.set(undefined, undefined);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { IObservable, ISettableObservable, observableValue, transaction } from '../../../../base/common/observable.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { bindContextKey, observableConfigValue } from '../../../../platform/observable/common/platformObservableUtils.js';\nimport { TestingConfigKeys } from './configuration.js';\nimport { Testing } from './constants.js';\nimport { TestCoverage } from './testCoverage.js';\nimport { TestId } from './testId.js';\nimport { ITestRunTaskResults } from './testResult.js';\nimport { ITestResultService } from './testResultService.js';\nimport { TestingContextKeys } from './testingContextKeys.js';\nimport { IViewsService } from '../../../services/views/common/viewsService.js';\n\nexport const ITestCoverageService = createDecorator<ITestCoverageService>('testCoverageService');\n\nexport interface ITestCoverageService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Settable observable that can be used to show the test coverage instance\n\t * currently in the editor.\n\t */\n\treadonly selected: IObservable<TestCoverage | undefined>;\n\n\t/**\n\t * Filter to per-test coverage from the given test ID.\n\t */\n\treadonly filterToTest: ISettableObservable<TestId | undefined>;\n\n\t/**\n\t * Whether inline coverage is shown.\n\t */\n\treadonly showInline: ISettableObservable<boolean>;\n\n\t/**\n\t * Opens a test coverage report from a task, optionally focusing it in the editor.\n\t */\n\topenCoverage(task: ITestRunTaskResults, focus?: boolean): Promise<void>;\n\n\t/**\n\t * Closes any open coverage.\n\t */\n\tcloseCoverage(): void;\n}\n\nexport class TestCoverageService extends Disposable implements ITestCoverageService {\n\tdeclare readonly _serviceBrand: undefined;\n\tprivate readonly lastOpenCts = this._register(new MutableDisposable<CancellationTokenSource>());\n\n\tpublic readonly selected = observableValue<TestCoverage | undefined>('testCoverage', undefined);\n\tpublic readonly filterToTest = observableValue<TestId | undefined>('filterToTest', undefined);\n\tpublic readonly showInline = observableValue('inlineCoverage', false);\n\n\tconstructor(\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@ITestResultService resultService: ITestResultService,\n\t\t@IConfigurationService configService: IConfigurationService,\n\t\t@IViewsService private readonly viewsService: IViewsService,\n\t) {\n\t\tsuper();\n\n\t\tconst toolbarConfig = observableConfigValue(TestingConfigKeys.CoverageToolbarEnabled, true, configService);\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.coverageToolbarEnabled,\n\t\t\tcontextKeyService,\n\t\t\treader => toolbarConfig.read(reader),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.inlineCoverageEnabled,\n\t\t\tcontextKeyService,\n\t\t\treader => this.showInline.read(reader),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.isTestCoverageOpen,\n\t\t\tcontextKeyService,\n\t\t\treader => !!this.selected.read(reader),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.hasPerTestCoverage,\n\t\t\tcontextKeyService,\n\t\t\treader => !Iterable.isEmpty(this.selected.read(reader)?.allPerTestIDs()),\n\t\t));\n\n\t\tthis._register(bindContextKey(\n\t\t\tTestingContextKeys.isCoverageFilteredToTest,\n\t\t\tcontextKeyService,\n\t\t\treader => !!this.filterToTest.read(reader),\n\t\t));\n\n\t\tthis._register(resultService.onResultsChanged(evt => {\n\t\t\tif ('completed' in evt) {\n\t\t\t\tconst coverage = evt.completed.tasks.find(t => t.coverage.get());\n\t\t\t\tif (coverage) {\n\t\t\t\t\tthis.openCoverage(coverage, false);\n\t\t\t\t} else {\n\t\t\t\t\tthis.closeCoverage();\n\t\t\t\t}\n\t\t\t} else if ('removed' in evt && this.selected.get()) {\n\t\t\t\tconst taskId = this.selected.get()?.fromTaskId;\n\t\t\t\tif (evt.removed.some(e => e.tasks.some(t => t.id === taskId))) {\n\t\t\t\t\tthis.closeCoverage();\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\t/** @inheritdoc */\n\tpublic async openCoverage(task: ITestRunTaskResults, focus = true) {\n\t\tthis.lastOpenCts.value?.cancel();\n\t\tconst cts = this.lastOpenCts.value = new CancellationTokenSource();\n\t\tconst coverage = task.coverage.get();\n\t\tif (!coverage) {\n\t\t\treturn;\n\t\t}\n\n\t\ttransaction(tx => {\n\t\t\t// todo: may want to preserve this if coverage for that test in the new run?\n\t\t\tthis.filterToTest.set(undefined, tx);\n\t\t\tthis.selected.set(coverage, tx);\n\t\t});\n\n\t\tif (focus && !cts.token.isCancellationRequested) {\n\t\t\tthis.viewsService.openView(Testing.CoverageViewId, true);\n\t\t}\n\t}\n\n\t/** @inheritdoc */\n\tpublic closeCoverage() {\n\t\tthis.selected.set(undefined, undefined);\n\t}\n}\n"]}