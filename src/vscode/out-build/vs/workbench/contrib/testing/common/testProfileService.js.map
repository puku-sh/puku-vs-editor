{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/common/testProfileService.ts","vs/workbench/contrib/testing/common/testProfileService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;AAEhG,OAAO,EAAE,OAAO,EAAS,MAAM,kCAAkC,CAAC;AAClE,OAAO,EAAE,QAAQ,EAAE,MAAM,qCAAqC,CAAC;AAC/D,OAAO,EAAE,UAAU,EAAE,MAAM,sCAAsC,CAAC;AAClE,OAAO,EAAE,SAAS,EAAE,MAAM,oCAAoC,CAAC;AAC/D,OAAO,EAAe,kBAAkB,EAAE,MAAM,sDAAsD,CAAC;AACvG,OAAO,EAAE,eAAe,EAAE,MAAM,4DAA4D,CAAC;AAC7F,OAAO,EAAE,eAAe,EAA+B,MAAM,gDAAgD,CAAC;AAC9G,OAAO,EAAE,WAAW,EAAE,MAAM,kBAAkB,CAAC;AAC/C,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAC;AAErC,OAAO,EAAsE,wBAAwB,EAAE,MAAM,gBAAgB,CAAC;AAC9H,OAAO,EAAE,kBAAkB,EAAE,MAAM,yBAAyB,CAAC;AAE7D,MAAM,CAAC,MAAM,mBAAmB,GAAG,eAAe,CAAsB,oBAAoB,CAAC,CAAC;AAmE9F;;GAEG;AACH,MAAM,CAAC,MAAM,qBAAqB,GAAG,CAAC,OAAwB,EAAE,IAAsB,EAAE,EAAE,CACzF,OAAO,CAAC,YAAY,KAAK,IAAI,CAAC,YAAY,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;AAExI,MAAM,MAAM,GAAG,CAAC,CAAkB,EAAE,CAAkB,EAAE,EAAE;IACzD,IAAI,CAAC,CAAC,SAAS,KAAK,CAAC,CAAC,SAAS,EAAE,CAAC;QACjC,OAAO,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7B,CAAC;IAED,OAAO,CAAC,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AACvC,CAAC,CAAC;AAMF;;;GAGG;AACH,MAAM,CAAC,MAAM,qBAAqB,GAAG,CAAC,YAAoB,EAAmC,EAAE,CAAC;IAC/F,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,YAAY,mCAA2B,CAAC,KAAK,CAAC,CAAC;IAC1F,CAAC,kBAAkB,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC,YAAY,qCAA6B,CAAC,KAAK,CAAC,CAAC;IAC9F,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC,YAAY,wCAAgC,CAAC,KAAK,CAAC,CAAC;CAChG,CAAC;AAIK,IAAM,kBAAkB,GAAxB,MAAM,kBAAmB,SAAQ,UAAU;IAajD,YACqB,iBAAqC,EACxC,cAA+B;QAEhD,KAAK,EAAE,CAAC;QAbQ,kBAAa,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QACpD,uBAAkB,GAAG,IAAI,GAAG,EAGzC,CAAC;QAEL,kBAAkB;QACF,gBAAW,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC;QAQtD,cAAc,CAAC,MAAM,CAAC,0BAA0B,iCAAyB,CAAC,CAAC,qBAAqB;QAChG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,WAAW,CAAC;YAClD,GAAG,EAAE,2BAA2B;YAChC,KAAK,gCAAwB;YAC7B,MAAM,+BAAuB;SAC7B,EAAE,cAAc,CAAC,CAAC,CAAC;QAEpB,IAAI,CAAC,oBAAoB,GAAG;YAC3B,kCAA0B,EAAE,kBAAkB,CAAC,gBAAgB,CAAC,MAAM,CAAC,iBAAiB,CAAC;YACzF,oCAA4B,EAAE,kBAAkB,CAAC,kBAAkB,CAAC,MAAM,CAAC,iBAAiB,CAAC;YAC7F,uCAA+B,EAAE,kBAAkB,CAAC,iBAAiB,CAAC,MAAM,CAAC,iBAAiB,CAAC;YAC/F,oDAA2C,EAAE,kBAAkB,CAAC,oBAAoB,CAAC,MAAM,CAAC,iBAAiB,CAAC;YAC9G,+CAAsC,EAAE,kBAAkB,CAAC,sBAAsB,CAAC,MAAM,CAAC,iBAAiB,CAAC;YAC3G,qDAA4C,EAAE,kBAAkB,CAAC,qBAAqB,CAAC,MAAM,CAAC,iBAAiB,CAAC;SAChH,CAAC;QAEF,IAAI,CAAC,kBAAkB,EAAE,CAAC;IAC3B,CAAC;IAED,kBAAkB;IACX,UAAU,CAAC,UAAqC,EAAE,OAAwB;QAChF,MAAM,4BAA4B,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QACnG,MAAM,QAAQ,GAA4B;YACzC,GAAG,OAAO;YACV,SAAS,EAAE,4BAA4B,IAAI,OAAO,CAAC,SAAS;YAC5D,mBAAmB,EAAE,OAAO,CAAC,SAAS;SACtC,CAAC;QAEF,IAAI,MAAM,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QAC/D,IAAI,MAAM,EAAE,CAAC;YACZ,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC/B,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC9B,CAAC;aAAM,CAAC;YACP,MAAM,GAAG;gBACR,QAAQ,EAAE,CAAC,QAAQ,CAAC;gBACpB,UAAU;aACV,CAAC;YACF,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,OAAO,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;QAC3D,CAAC;QAED,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;IAC3B,CAAC;IAED,kBAAkB;IACX,aAAa,CAAC,YAAoB,EAAE,SAAiB,EAAE,MAAgC;QAC7F,MAAM,IAAI,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QACvD,IAAI,CAAC,IAAI,EAAE,CAAC;YACX,OAAO;QACR,CAAC;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,YAAY,KAAK,YAAY,IAAI,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,CAAC;QACtG,IAAI,CAAC,OAAO,EAAE,CAAC;YACd,OAAO;QACR,CAAC;QAED,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QAC/B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAE3B,yEAAyE;QACzE,8CAA8C;QAC9C,IAAI,MAAM,CAAC,SAAS,KAAK,SAAS,EAAE,CAAC;YACpC,MAAM,GAAG,GAAG,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;YACjD,YAAY,CAAC,GAAG,EAAE,OAAO,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC;YAC7C,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC9B,CAAC;QAED,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;IAC3B,CAAC;IAED,kBAAkB;IACX,SAAS,CAAC,YAAoB,EAAE,SAAiB;QACvD,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE,UAAU,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;IACtF,CAAC;IAED,kBAAkB;IACX,aAAa,CAAC,YAAoB,EAAE,SAAkB;QAC5D,MAAM,IAAI,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QACvD,IAAI,CAAC,IAAI,EAAE,CAAC;YACX,OAAO;QACR,CAAC;QAED,IAAI,CAAC,SAAS,EAAE,CAAC;YAChB,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;YAC7C,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;YAC1B,OAAO;QACR,CAAC;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,CAAC;QACtE,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE,CAAC;YAClB,OAAO;QACR,CAAC;QAED,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAC/B,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;IAC3B,CAAC;IAED,kBAAkB;IACX,mBAAmB,CAAC,IAAe;QACzC,MAAM,IAAI,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAClE,IAAI,CAAC,IAAI,EAAE,CAAC;YACX,OAAO,CAAC,CAAC;QACV,CAAC;QAED,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACrC,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;gBACrD,YAAY,IAAI,YAAY,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,oDAA2C,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC;YAC1G,CAAC;QACF,CAAC;QAED,OAAO,YAAY,CAAC;IACrB,CAAC;IAED,kBAAkB;IACX,GAAG;QACT,OAAO,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,CAAC;IACzC,CAAC;IAED,kBAAkB;IACX,qBAAqB,CAAC,SAAiB;QAC7C,OAAO,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,QAAQ,IAAI,EAAE,CAAC;IAC/D,CAAC;IAED,kBAAkB;IACX,uBAAuB,CAAC,KAA2B,EAAE,YAAqB;QAChF,MAAM,WAAW,GAAG,YAAY;YAC/B,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE,QAAQ,IAAI,EAAE,CAAC;YAC7D,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC5E,MAAM,QAAQ,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,IAAI,CAAC,CAAC,SAAS,CAAC,CAAC;QAE3E,+DAA+D;QAC/D,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC3B,MAAM,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC;YACvD,IAAI,KAAK,EAAE,CAAC;gBACX,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACtB,CAAC;QACF,CAAC;QAED,OAAO,QAAQ,CAAC;IACjB,CAAC;IAED,kBAAkB;IACX,uBAAuB,CAAC,KAA2B,EAAE,QAA2B;QACtF,MAAM,IAAI,GAAgB,EAAE,CAAC;QAC7B,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,EAAE,CAAC;YACrD,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC;YAC9B,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACrC,IAAI,OAAO,CAAC,KAAK,KAAK,KAAK,EAAE,CAAC;oBAC7B,SAAS;gBACV,CAAC;gBAED,YAAY,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,KAAK,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC;YACpF,CAAC;YAED,0EAA0E;YAC1E,oEAAoE;YACpE,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACrC,IAAI,OAAO,CAAC,KAAK,KAAK,KAAK,EAAE,CAAC;oBAC7B,SAAS;gBACV,CAAC;gBACD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,IAAI,CAAC,CAAC,KAAK,KAAK,OAAO,CAAC,KAAK,CAAC,CAAC;gBACzF,IAAI,QAAQ,EAAE,CAAC;oBACd,YAAY,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC;gBACjD,CAAC;YACF,CAAC;YAED,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC5B,CAAC;QAED,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC9B,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;IAC3B,CAAC;IAED,wBAAwB,CAAC,KAA2B,EAAE,IAAsB;QAC3E,OAAO,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,qBAAqB,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;IAC3H,CAAC;IAEO,kBAAkB;QACzB,IAAI,eAAe,GAAG,CAAC,CAAC;QACxB,KAAK,MAAM,EAAE,QAAQ,EAAE,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,EAAE,CAAC;YAC7D,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;gBAChC,eAAe,IAAI,eAAe,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,oDAA2C,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC;gBAC/G,eAAe,IAAI,OAAO,CAAC,qBAAqB,CAAC,CAAC,qDAA4C,CAAC,CAAC,CAAC,CAAC;YACnG,CAAC;QACF,CAAC;QAED,KAAK,MAAM,KAAK,IAAI,wBAAwB,EAAE,CAAC;YAC9C,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,eAAe,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;QACvE,CAAC;IACF,CAAC;CACD,CAAA;AAnNY,kBAAkB;IAc5B,WAAA,kBAAkB,CAAA;IAClB,WAAA,eAAe,CAAA;GAfL,kBAAkB,CAmN9B;;AAED,MAAM,YAAY,GAAG,CAAC,GAAgB,EAAE,OAAgC,EAAE,SAAkB,EAAE,EAAE;IAC/F,OAAO,CAAC,SAAS,GAAG,SAAS,CAAC;IAC9B,GAAG,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;IACjC,IAAI,OAAO,CAAC,SAAS,KAAK,OAAO,CAAC,mBAAmB,EAAE,CAAC;QACvD,GAAG,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC;IAClE,CAAC;SAAM,CAAC;QACP,OAAO,GAAG,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IACrD,CAAC;AACF,CAAC,CAAC","file":"testProfileService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { IContextKey, IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { StoredValue } from './storedValue.js';\nimport { TestId } from './testId.js';\nimport { IMainThreadTestController } from './testService.js';\nimport { ITestItem, ITestRunProfile, InternalTestItem, TestRunProfileBitset, testRunProfileBitsetList } from './testTypes.js';\nimport { TestingContextKeys } from './testingContextKeys.js';\n\nexport const ITestProfileService = createDecorator<ITestProfileService>('testProfileService');\n\nexport interface ITestProfileService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fired when any profile changes.\n\t */\n\treadonly onDidChange: Event<void>;\n\n\t/**\n\t * Publishes a new test profile.\n\t */\n\taddProfile(controller: IMainThreadTestController, profile: ITestRunProfile): void;\n\n\t/**\n\t * Updates an existing test run profile\n\t */\n\tupdateProfile(controllerId: string, profileId: number, update: Partial<ITestRunProfile>): void;\n\n\t/**\n\t * Removes a profile. If profileId is not given, all profiles\n\t * for the given controller will be removed.\n\t */\n\tremoveProfile(controllerId: string, profileId?: number): void;\n\n\t/**\n\t * Gets capabilities for the given test, indicating whether\n\t * there's any usable profiles available for those groups.\n\t * @returns a bitset to use with {@link TestRunProfileBitset}\n\t */\n\tcapabilitiesForTest(test: ITestItem): number;\n\n\t/**\n\t * Configures a test profile.\n\t */\n\tconfigure(controllerId: string, profileId: number): void;\n\n\t/**\n\t * Gets all registered controllers, grouping by controller.\n\t */\n\tall(): Iterable<Readonly<{\n\t\tcontroller: IMainThreadTestController;\n\t\tprofiles: ITestRunProfile[];\n\t}>>;\n\n\t/**\n\t * Gets the default profiles to be run for a given run group.\n\t */\n\tgetGroupDefaultProfiles(group: TestRunProfileBitset, controllerId?: string): ITestRunProfile[];\n\n\t/**\n\t * Sets the default profiles to be run for a given run group.\n\t */\n\tsetGroupDefaultProfiles(group: TestRunProfileBitset, profiles: ITestRunProfile[]): void;\n\n\t/**\n\t * Gets the profiles for a controller, in priority order.\n\t */\n\tgetControllerProfiles(controllerId: string): ITestRunProfile[];\n\n\t/**\n\t * Gets the preferred profile, if any, to run the test.\n\t */\n\tgetDefaultProfileForTest(group: TestRunProfileBitset, test: InternalTestItem): ITestRunProfile | undefined;\n}\n\n/**\n * Gets whether the given profile can be used to run the test.\n */\nexport const canUseProfileWithTest = (profile: ITestRunProfile, test: InternalTestItem) =>\n\tprofile.controllerId === test.controllerId && (TestId.isRoot(test.item.extId) || !profile.tag || test.item.tags.includes(profile.tag));\n\nconst sorter = (a: ITestRunProfile, b: ITestRunProfile) => {\n\tif (a.isDefault !== b.isDefault) {\n\t\treturn a.isDefault ? -1 : 1;\n\t}\n\n\treturn a.label.localeCompare(b.label);\n};\n\ninterface IExtendedTestRunProfile extends ITestRunProfile {\n\twasInitiallyDefault: boolean;\n}\n\n/**\n * Given a capabilities bitset, returns a map of context keys representing\n * them.\n */\nexport const capabilityContextKeys = (capabilities: number): [key: string, value: boolean][] => [\n\t[TestingContextKeys.hasRunnableTests.key, (capabilities & TestRunProfileBitset.Run) !== 0],\n\t[TestingContextKeys.hasDebuggableTests.key, (capabilities & TestRunProfileBitset.Debug) !== 0],\n\t[TestingContextKeys.hasCoverableTests.key, (capabilities & TestRunProfileBitset.Coverage) !== 0],\n];\n\ntype DefaultsMap = { [controllerId: string]: { [profileId: number]: /* isDefault */ boolean } };\n\nexport class TestProfileService extends Disposable implements ITestProfileService {\n\tdeclare readonly _serviceBrand: undefined;\n\tprivate readonly userDefaults: StoredValue<DefaultsMap>;\n\tprivate readonly capabilitiesContexts: { [K in TestRunProfileBitset]: IContextKey<boolean> };\n\tprivate readonly changeEmitter = this._register(new Emitter<void>());\n\tprivate readonly controllerProfiles = new Map</* controller ID */string, {\n\t\tprofiles: IExtendedTestRunProfile[];\n\t\tcontroller: IMainThreadTestController;\n\t}>();\n\n\t/** @inheritdoc */\n\tpublic readonly onDidChange = this.changeEmitter.event;\n\n\tconstructor(\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@IStorageService storageService: IStorageService,\n\t) {\n\t\tsuper();\n\n\t\tstorageService.remove('testingPreferredProfiles', StorageScope.WORKSPACE); // cleanup old format\n\t\tthis.userDefaults = this._register(new StoredValue({\n\t\t\tkey: 'testingPreferredProfiles2',\n\t\t\tscope: StorageScope.WORKSPACE,\n\t\t\ttarget: StorageTarget.MACHINE,\n\t\t}, storageService));\n\n\t\tthis.capabilitiesContexts = {\n\t\t\t[TestRunProfileBitset.Run]: TestingContextKeys.hasRunnableTests.bindTo(contextKeyService),\n\t\t\t[TestRunProfileBitset.Debug]: TestingContextKeys.hasDebuggableTests.bindTo(contextKeyService),\n\t\t\t[TestRunProfileBitset.Coverage]: TestingContextKeys.hasCoverableTests.bindTo(contextKeyService),\n\t\t\t[TestRunProfileBitset.HasNonDefaultProfile]: TestingContextKeys.hasNonDefaultProfile.bindTo(contextKeyService),\n\t\t\t[TestRunProfileBitset.HasConfigurable]: TestingContextKeys.hasConfigurableProfile.bindTo(contextKeyService),\n\t\t\t[TestRunProfileBitset.SupportsContinuousRun]: TestingContextKeys.supportsContinuousRun.bindTo(contextKeyService),\n\t\t};\n\n\t\tthis.refreshContextKeys();\n\t}\n\n\t/** @inheritdoc */\n\tpublic addProfile(controller: IMainThreadTestController, profile: ITestRunProfile): void {\n\t\tconst previousExplicitDefaultValue = this.userDefaults.get()?.[controller.id]?.[profile.profileId];\n\t\tconst extended: IExtendedTestRunProfile = {\n\t\t\t...profile,\n\t\t\tisDefault: previousExplicitDefaultValue ?? profile.isDefault,\n\t\t\twasInitiallyDefault: profile.isDefault,\n\t\t};\n\n\t\tlet record = this.controllerProfiles.get(profile.controllerId);\n\t\tif (record) {\n\t\t\trecord.profiles.push(extended);\n\t\t\trecord.profiles.sort(sorter);\n\t\t} else {\n\t\t\trecord = {\n\t\t\t\tprofiles: [extended],\n\t\t\t\tcontroller,\n\t\t\t};\n\t\t\tthis.controllerProfiles.set(profile.controllerId, record);\n\t\t}\n\n\t\tthis.refreshContextKeys();\n\t\tthis.changeEmitter.fire();\n\t}\n\n\t/** @inheritdoc */\n\tpublic updateProfile(controllerId: string, profileId: number, update: Partial<ITestRunProfile>): void {\n\t\tconst ctrl = this.controllerProfiles.get(controllerId);\n\t\tif (!ctrl) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst profile = ctrl.profiles.find(c => c.controllerId === controllerId && c.profileId === profileId);\n\t\tif (!profile) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject.assign(profile, update);\n\t\tctrl.profiles.sort(sorter);\n\n\t\t// store updates is isDefault as if the user changed it (which they might\n\t\t// have through some extension-contributed UI)\n\t\tif (update.isDefault !== undefined) {\n\t\t\tconst map = deepClone(this.userDefaults.get({}));\n\t\t\tsetIsDefault(map, profile, update.isDefault);\n\t\t\tthis.userDefaults.store(map);\n\t\t}\n\n\t\tthis.changeEmitter.fire();\n\t}\n\n\t/** @inheritdoc */\n\tpublic configure(controllerId: string, profileId: number) {\n\t\tthis.controllerProfiles.get(controllerId)?.controller.configureRunProfile(profileId);\n\t}\n\n\t/** @inheritdoc */\n\tpublic removeProfile(controllerId: string, profileId?: number): void {\n\t\tconst ctrl = this.controllerProfiles.get(controllerId);\n\t\tif (!ctrl) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!profileId) {\n\t\t\tthis.controllerProfiles.delete(controllerId);\n\t\t\tthis.changeEmitter.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst index = ctrl.profiles.findIndex(c => c.profileId === profileId);\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tctrl.profiles.splice(index, 1);\n\t\tthis.refreshContextKeys();\n\t\tthis.changeEmitter.fire();\n\t}\n\n\t/** @inheritdoc */\n\tpublic capabilitiesForTest(test: ITestItem) {\n\t\tconst ctrl = this.controllerProfiles.get(TestId.root(test.extId));\n\t\tif (!ctrl) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet capabilities = 0;\n\t\tfor (const profile of ctrl.profiles) {\n\t\t\tif (!profile.tag || test.tags.includes(profile.tag)) {\n\t\t\t\tcapabilities |= capabilities & profile.group ? TestRunProfileBitset.HasNonDefaultProfile : profile.group;\n\t\t\t}\n\t\t}\n\n\t\treturn capabilities;\n\t}\n\n\t/** @inheritdoc */\n\tpublic all() {\n\t\treturn this.controllerProfiles.values();\n\t}\n\n\t/** @inheritdoc */\n\tpublic getControllerProfiles(profileId: string) {\n\t\treturn this.controllerProfiles.get(profileId)?.profiles ?? [];\n\t}\n\n\t/** @inheritdoc */\n\tpublic getGroupDefaultProfiles(group: TestRunProfileBitset, controllerId?: string) {\n\t\tconst allProfiles = controllerId\n\t\t\t? (this.controllerProfiles.get(controllerId)?.profiles || [])\n\t\t\t: [...Iterable.flatMap(this.controllerProfiles.values(), c => c.profiles)];\n\t\tconst defaults = allProfiles.filter(c => c.group === group && c.isDefault);\n\n\t\t// have *some* default profile to run if none are set otherwise\n\t\tif (defaults.length === 0) {\n\t\t\tconst first = allProfiles.find(p => p.group === group);\n\t\t\tif (first) {\n\t\t\t\tdefaults.push(first);\n\t\t\t}\n\t\t}\n\n\t\treturn defaults;\n\t}\n\n\t/** @inheritdoc */\n\tpublic setGroupDefaultProfiles(group: TestRunProfileBitset, profiles: ITestRunProfile[]) {\n\t\tconst next: DefaultsMap = {};\n\t\tfor (const ctrl of this.controllerProfiles.values()) {\n\t\t\tnext[ctrl.controller.id] = {};\n\t\t\tfor (const profile of ctrl.profiles) {\n\t\t\t\tif (profile.group !== group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsetIsDefault(next, profile, profiles.some(p => p.profileId === profile.profileId));\n\t\t\t}\n\n\t\t\t// When switching a profile, if the controller has a same-named profile in\n\t\t\t// other groups, update those to match the enablement state as well.\n\t\t\tfor (const profile of ctrl.profiles) {\n\t\t\t\tif (profile.group === group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst matching = ctrl.profiles.find(p => p.group === group && p.label === profile.label);\n\t\t\t\tif (matching) {\n\t\t\t\t\tsetIsDefault(next, profile, matching.isDefault);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctrl.profiles.sort(sorter);\n\t\t}\n\n\t\tthis.userDefaults.store(next);\n\t\tthis.changeEmitter.fire();\n\t}\n\n\tgetDefaultProfileForTest(group: TestRunProfileBitset, test: InternalTestItem): ITestRunProfile | undefined {\n\t\treturn this.getControllerProfiles(test.controllerId).find(p => (p.group & group) !== 0 && canUseProfileWithTest(p, test));\n\t}\n\n\tprivate refreshContextKeys() {\n\t\tlet allCapabilities = 0;\n\t\tfor (const { profiles } of this.controllerProfiles.values()) {\n\t\t\tfor (const profile of profiles) {\n\t\t\t\tallCapabilities |= allCapabilities & profile.group ? TestRunProfileBitset.HasNonDefaultProfile : profile.group;\n\t\t\t\tallCapabilities |= profile.supportsContinuousRun ? TestRunProfileBitset.SupportsContinuousRun : 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (const group of testRunProfileBitsetList) {\n\t\t\tthis.capabilitiesContexts[group].set((allCapabilities & group) !== 0);\n\t\t}\n\t}\n}\n\nconst setIsDefault = (map: DefaultsMap, profile: IExtendedTestRunProfile, isDefault: boolean) => {\n\tprofile.isDefault = isDefault;\n\tmap[profile.controllerId] ??= {};\n\tif (profile.isDefault !== profile.wasInitiallyDefault) {\n\t\tmap[profile.controllerId][profile.profileId] = profile.isDefault;\n\t} else {\n\t\tdelete map[profile.controllerId][profile.profileId];\n\t}\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { IContextKey, IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { StoredValue } from './storedValue.js';\nimport { TestId } from './testId.js';\nimport { IMainThreadTestController } from './testService.js';\nimport { ITestItem, ITestRunProfile, InternalTestItem, TestRunProfileBitset, testRunProfileBitsetList } from './testTypes.js';\nimport { TestingContextKeys } from './testingContextKeys.js';\n\nexport const ITestProfileService = createDecorator<ITestProfileService>('testProfileService');\n\nexport interface ITestProfileService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fired when any profile changes.\n\t */\n\treadonly onDidChange: Event<void>;\n\n\t/**\n\t * Publishes a new test profile.\n\t */\n\taddProfile(controller: IMainThreadTestController, profile: ITestRunProfile): void;\n\n\t/**\n\t * Updates an existing test run profile\n\t */\n\tupdateProfile(controllerId: string, profileId: number, update: Partial<ITestRunProfile>): void;\n\n\t/**\n\t * Removes a profile. If profileId is not given, all profiles\n\t * for the given controller will be removed.\n\t */\n\tremoveProfile(controllerId: string, profileId?: number): void;\n\n\t/**\n\t * Gets capabilities for the given test, indicating whether\n\t * there's any usable profiles available for those groups.\n\t * @returns a bitset to use with {@link TestRunProfileBitset}\n\t */\n\tcapabilitiesForTest(test: ITestItem): number;\n\n\t/**\n\t * Configures a test profile.\n\t */\n\tconfigure(controllerId: string, profileId: number): void;\n\n\t/**\n\t * Gets all registered controllers, grouping by controller.\n\t */\n\tall(): Iterable<Readonly<{\n\t\tcontroller: IMainThreadTestController;\n\t\tprofiles: ITestRunProfile[];\n\t}>>;\n\n\t/**\n\t * Gets the default profiles to be run for a given run group.\n\t */\n\tgetGroupDefaultProfiles(group: TestRunProfileBitset, controllerId?: string): ITestRunProfile[];\n\n\t/**\n\t * Sets the default profiles to be run for a given run group.\n\t */\n\tsetGroupDefaultProfiles(group: TestRunProfileBitset, profiles: ITestRunProfile[]): void;\n\n\t/**\n\t * Gets the profiles for a controller, in priority order.\n\t */\n\tgetControllerProfiles(controllerId: string): ITestRunProfile[];\n\n\t/**\n\t * Gets the preferred profile, if any, to run the test.\n\t */\n\tgetDefaultProfileForTest(group: TestRunProfileBitset, test: InternalTestItem): ITestRunProfile | undefined;\n}\n\n/**\n * Gets whether the given profile can be used to run the test.\n */\nexport const canUseProfileWithTest = (profile: ITestRunProfile, test: InternalTestItem) =>\n\tprofile.controllerId === test.controllerId && (TestId.isRoot(test.item.extId) || !profile.tag || test.item.tags.includes(profile.tag));\n\nconst sorter = (a: ITestRunProfile, b: ITestRunProfile) => {\n\tif (a.isDefault !== b.isDefault) {\n\t\treturn a.isDefault ? -1 : 1;\n\t}\n\n\treturn a.label.localeCompare(b.label);\n};\n\ninterface IExtendedTestRunProfile extends ITestRunProfile {\n\twasInitiallyDefault: boolean;\n}\n\n/**\n * Given a capabilities bitset, returns a map of context keys representing\n * them.\n */\nexport const capabilityContextKeys = (capabilities: number): [key: string, value: boolean][] => [\n\t[TestingContextKeys.hasRunnableTests.key, (capabilities & TestRunProfileBitset.Run) !== 0],\n\t[TestingContextKeys.hasDebuggableTests.key, (capabilities & TestRunProfileBitset.Debug) !== 0],\n\t[TestingContextKeys.hasCoverableTests.key, (capabilities & TestRunProfileBitset.Coverage) !== 0],\n];\n\ntype DefaultsMap = { [controllerId: string]: { [profileId: number]: /* isDefault */ boolean } };\n\nexport class TestProfileService extends Disposable implements ITestProfileService {\n\tdeclare readonly _serviceBrand: undefined;\n\tprivate readonly userDefaults: StoredValue<DefaultsMap>;\n\tprivate readonly capabilitiesContexts: { [K in TestRunProfileBitset]: IContextKey<boolean> };\n\tprivate readonly changeEmitter = this._register(new Emitter<void>());\n\tprivate readonly controllerProfiles = new Map</* controller ID */string, {\n\t\tprofiles: IExtendedTestRunProfile[];\n\t\tcontroller: IMainThreadTestController;\n\t}>();\n\n\t/** @inheritdoc */\n\tpublic readonly onDidChange = this.changeEmitter.event;\n\n\tconstructor(\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@IStorageService storageService: IStorageService,\n\t) {\n\t\tsuper();\n\n\t\tstorageService.remove('testingPreferredProfiles', StorageScope.WORKSPACE); // cleanup old format\n\t\tthis.userDefaults = this._register(new StoredValue({\n\t\t\tkey: 'testingPreferredProfiles2',\n\t\t\tscope: StorageScope.WORKSPACE,\n\t\t\ttarget: StorageTarget.MACHINE,\n\t\t}, storageService));\n\n\t\tthis.capabilitiesContexts = {\n\t\t\t[TestRunProfileBitset.Run]: TestingContextKeys.hasRunnableTests.bindTo(contextKeyService),\n\t\t\t[TestRunProfileBitset.Debug]: TestingContextKeys.hasDebuggableTests.bindTo(contextKeyService),\n\t\t\t[TestRunProfileBitset.Coverage]: TestingContextKeys.hasCoverableTests.bindTo(contextKeyService),\n\t\t\t[TestRunProfileBitset.HasNonDefaultProfile]: TestingContextKeys.hasNonDefaultProfile.bindTo(contextKeyService),\n\t\t\t[TestRunProfileBitset.HasConfigurable]: TestingContextKeys.hasConfigurableProfile.bindTo(contextKeyService),\n\t\t\t[TestRunProfileBitset.SupportsContinuousRun]: TestingContextKeys.supportsContinuousRun.bindTo(contextKeyService),\n\t\t};\n\n\t\tthis.refreshContextKeys();\n\t}\n\n\t/** @inheritdoc */\n\tpublic addProfile(controller: IMainThreadTestController, profile: ITestRunProfile): void {\n\t\tconst previousExplicitDefaultValue = this.userDefaults.get()?.[controller.id]?.[profile.profileId];\n\t\tconst extended: IExtendedTestRunProfile = {\n\t\t\t...profile,\n\t\t\tisDefault: previousExplicitDefaultValue ?? profile.isDefault,\n\t\t\twasInitiallyDefault: profile.isDefault,\n\t\t};\n\n\t\tlet record = this.controllerProfiles.get(profile.controllerId);\n\t\tif (record) {\n\t\t\trecord.profiles.push(extended);\n\t\t\trecord.profiles.sort(sorter);\n\t\t} else {\n\t\t\trecord = {\n\t\t\t\tprofiles: [extended],\n\t\t\t\tcontroller,\n\t\t\t};\n\t\t\tthis.controllerProfiles.set(profile.controllerId, record);\n\t\t}\n\n\t\tthis.refreshContextKeys();\n\t\tthis.changeEmitter.fire();\n\t}\n\n\t/** @inheritdoc */\n\tpublic updateProfile(controllerId: string, profileId: number, update: Partial<ITestRunProfile>): void {\n\t\tconst ctrl = this.controllerProfiles.get(controllerId);\n\t\tif (!ctrl) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst profile = ctrl.profiles.find(c => c.controllerId === controllerId && c.profileId === profileId);\n\t\tif (!profile) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject.assign(profile, update);\n\t\tctrl.profiles.sort(sorter);\n\n\t\t// store updates is isDefault as if the user changed it (which they might\n\t\t// have through some extension-contributed UI)\n\t\tif (update.isDefault !== undefined) {\n\t\t\tconst map = deepClone(this.userDefaults.get({}));\n\t\t\tsetIsDefault(map, profile, update.isDefault);\n\t\t\tthis.userDefaults.store(map);\n\t\t}\n\n\t\tthis.changeEmitter.fire();\n\t}\n\n\t/** @inheritdoc */\n\tpublic configure(controllerId: string, profileId: number) {\n\t\tthis.controllerProfiles.get(controllerId)?.controller.configureRunProfile(profileId);\n\t}\n\n\t/** @inheritdoc */\n\tpublic removeProfile(controllerId: string, profileId?: number): void {\n\t\tconst ctrl = this.controllerProfiles.get(controllerId);\n\t\tif (!ctrl) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!profileId) {\n\t\t\tthis.controllerProfiles.delete(controllerId);\n\t\t\tthis.changeEmitter.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst index = ctrl.profiles.findIndex(c => c.profileId === profileId);\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tctrl.profiles.splice(index, 1);\n\t\tthis.refreshContextKeys();\n\t\tthis.changeEmitter.fire();\n\t}\n\n\t/** @inheritdoc */\n\tpublic capabilitiesForTest(test: ITestItem) {\n\t\tconst ctrl = this.controllerProfiles.get(TestId.root(test.extId));\n\t\tif (!ctrl) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet capabilities = 0;\n\t\tfor (const profile of ctrl.profiles) {\n\t\t\tif (!profile.tag || test.tags.includes(profile.tag)) {\n\t\t\t\tcapabilities |= capabilities & profile.group ? TestRunProfileBitset.HasNonDefaultProfile : profile.group;\n\t\t\t}\n\t\t}\n\n\t\treturn capabilities;\n\t}\n\n\t/** @inheritdoc */\n\tpublic all() {\n\t\treturn this.controllerProfiles.values();\n\t}\n\n\t/** @inheritdoc */\n\tpublic getControllerProfiles(profileId: string) {\n\t\treturn this.controllerProfiles.get(profileId)?.profiles ?? [];\n\t}\n\n\t/** @inheritdoc */\n\tpublic getGroupDefaultProfiles(group: TestRunProfileBitset, controllerId?: string) {\n\t\tconst allProfiles = controllerId\n\t\t\t? (this.controllerProfiles.get(controllerId)?.profiles || [])\n\t\t\t: [...Iterable.flatMap(this.controllerProfiles.values(), c => c.profiles)];\n\t\tconst defaults = allProfiles.filter(c => c.group === group && c.isDefault);\n\n\t\t// have *some* default profile to run if none are set otherwise\n\t\tif (defaults.length === 0) {\n\t\t\tconst first = allProfiles.find(p => p.group === group);\n\t\t\tif (first) {\n\t\t\t\tdefaults.push(first);\n\t\t\t}\n\t\t}\n\n\t\treturn defaults;\n\t}\n\n\t/** @inheritdoc */\n\tpublic setGroupDefaultProfiles(group: TestRunProfileBitset, profiles: ITestRunProfile[]) {\n\t\tconst next: DefaultsMap = {};\n\t\tfor (const ctrl of this.controllerProfiles.values()) {\n\t\t\tnext[ctrl.controller.id] = {};\n\t\t\tfor (const profile of ctrl.profiles) {\n\t\t\t\tif (profile.group !== group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsetIsDefault(next, profile, profiles.some(p => p.profileId === profile.profileId));\n\t\t\t}\n\n\t\t\t// When switching a profile, if the controller has a same-named profile in\n\t\t\t// other groups, update those to match the enablement state as well.\n\t\t\tfor (const profile of ctrl.profiles) {\n\t\t\t\tif (profile.group === group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst matching = ctrl.profiles.find(p => p.group === group && p.label === profile.label);\n\t\t\t\tif (matching) {\n\t\t\t\t\tsetIsDefault(next, profile, matching.isDefault);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctrl.profiles.sort(sorter);\n\t\t}\n\n\t\tthis.userDefaults.store(next);\n\t\tthis.changeEmitter.fire();\n\t}\n\n\tgetDefaultProfileForTest(group: TestRunProfileBitset, test: InternalTestItem): ITestRunProfile | undefined {\n\t\treturn this.getControllerProfiles(test.controllerId).find(p => (p.group & group) !== 0 && canUseProfileWithTest(p, test));\n\t}\n\n\tprivate refreshContextKeys() {\n\t\tlet allCapabilities = 0;\n\t\tfor (const { profiles } of this.controllerProfiles.values()) {\n\t\t\tfor (const profile of profiles) {\n\t\t\t\tallCapabilities |= allCapabilities & profile.group ? TestRunProfileBitset.HasNonDefaultProfile : profile.group;\n\t\t\t\tallCapabilities |= profile.supportsContinuousRun ? TestRunProfileBitset.SupportsContinuousRun : 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (const group of testRunProfileBitsetList) {\n\t\t\tthis.capabilitiesContexts[group].set((allCapabilities & group) !== 0);\n\t\t}\n\t}\n}\n\nconst setIsDefault = (map: DefaultsMap, profile: IExtendedTestRunProfile, isDefault: boolean) => {\n\tprofile.isDefault = isDefault;\n\tmap[profile.controllerId] ??= {};\n\tif (profile.isDefault !== profile.wasInitiallyDefault) {\n\t\tmap[profile.controllerId][profile.profileId] = profile.isDefault;\n\t} else {\n\t\tdelete map[profile.controllerId][profile.profileId];\n\t}\n};\n"]}