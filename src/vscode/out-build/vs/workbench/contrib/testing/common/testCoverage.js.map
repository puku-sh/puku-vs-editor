{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/common/testCoverage.ts","vs/workbench/contrib/testing/common/testCoverage.ts"],"names":[],"mappings":"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","file":"testCoverage.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { ITransaction, observableSignal } from '../../../../base/common/observable.js';\nimport { IPrefixTreeNode, WellDefinedPrefixTree } from '../../../../base/common/prefixTree.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { TestId } from './testId.js';\nimport { LiveTestResult } from './testResult.js';\nimport { CoverageDetails, DetailType, ICoverageCount, IFileCoverage } from './testTypes.js';\n\nexport interface ICoverageAccessor {\n\tgetCoverageDetails: (id: string, testId: string | undefined, token: CancellationToken) => Promise<CoverageDetails[]>;\n}\n\nlet incId = 0;\n\n/**\n * Class that exposese coverage information for a run.\n */\nexport class TestCoverage {\n\tprivate readonly fileCoverage = new ResourceMap<FileCoverage>();\n\tpublic readonly didAddCoverage = observableSignal<IPrefixTreeNode<AbstractFileCoverage>[]>(this);\n\tpublic readonly tree = new WellDefinedPrefixTree<AbstractFileCoverage>();\n\tpublic readonly associatedData = new Map<unknown, unknown>();\n\n\tconstructor(\n\t\tpublic readonly result: LiveTestResult,\n\t\tpublic readonly fromTaskId: string,\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t\tprivate readonly accessor: ICoverageAccessor,\n\t) { }\n\n\t/** Gets all test IDs that were included in this test run. */\n\tpublic *allPerTestIDs() {\n\t\tconst seen = new Set<string>();\n\t\tfor (const root of this.tree.nodes) {\n\t\t\tif (root.value && root.value.perTestData) {\n\t\t\t\tfor (const id of root.value.perTestData) {\n\t\t\t\t\tif (!seen.has(id)) {\n\t\t\t\t\t\tseen.add(id);\n\t\t\t\t\t\tyield id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic append(coverage: IFileCoverage, tx: ITransaction | undefined) {\n\t\tconst previous = this.getComputedForUri(coverage.uri);\n\t\tconst result = this.result;\n\t\tconst applyDelta = (kind: 'statement' | 'branch' | 'declaration', node: ComputedFileCoverage) => {\n\t\t\tif (!node[kind]) {\n\t\t\t\tif (coverage[kind]) {\n\t\t\t\t\tnode[kind] = { ...coverage[kind]! };\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode[kind]!.covered += (coverage[kind]?.covered || 0) - (previous?.[kind]?.covered || 0);\n\t\t\t\tnode[kind]!.total += (coverage[kind]?.total || 0) - (previous?.[kind]?.total || 0);\n\t\t\t}\n\t\t};\n\n\t\t// We insert using the non-canonical path to normalize for casing differences\n\t\t// between URIs, but when inserting an intermediate node always use 'a' canonical\n\t\t// version.\n\t\tconst canonical = [...this.treePathForUri(coverage.uri, /* canonical = */ true)];\n\t\tconst chain: IPrefixTreeNode<AbstractFileCoverage>[] = [];\n\n\t\tthis.tree.mutatePath(this.treePathForUri(coverage.uri, /* canonical = */ false), node => {\n\t\t\tchain.push(node);\n\n\t\t\tif (chain.length === canonical.length) {\n\t\t\t\t// we reached our destination node, apply the coverage as necessary:\n\t\t\t\tif (node.value) {\n\t\t\t\t\tconst v = node.value;\n\t\t\t\t\t// if ID was generated from a test-specific coverage, reassign it to get its real ID in the extension host.\n\t\t\t\t\tv.id = coverage.id;\n\t\t\t\t\tv.statement = coverage.statement;\n\t\t\t\t\tv.branch = coverage.branch;\n\t\t\t\t\tv.declaration = coverage.declaration;\n\t\t\t\t} else {\n\t\t\t\t\tconst v = node.value = new FileCoverage(coverage, result, this.accessor);\n\t\t\t\t\tthis.fileCoverage.set(coverage.uri, v);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Otherwise, if this is not a partial per-test coverage, merge the\n\t\t\t\t// coverage changes into the chain. Per-test coverages are not complete\n\t\t\t\t// and we don't want to consider them for computation.\n\t\t\t\tif (!node.value) {\n\t\t\t\t\t// clone because later intersertions can modify the counts:\n\t\t\t\t\tconst intermediate = deepClone(coverage);\n\t\t\t\t\tintermediate.id = String(incId++);\n\t\t\t\t\tintermediate.uri = this.treePathToUri(canonical.slice(0, chain.length));\n\t\t\t\t\tnode.value = new ComputedFileCoverage(intermediate, result);\n\t\t\t\t} else {\n\t\t\t\t\tapplyDelta('statement', node.value);\n\t\t\t\t\tapplyDelta('branch', node.value);\n\t\t\t\t\tapplyDelta('declaration', node.value);\n\t\t\t\t\tnode.value.didChange.trigger(tx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (coverage.testIds) {\n\t\t\t\tnode.value!.perTestData ??= new Set();\n\t\t\t\tfor (const id of coverage.testIds) {\n\t\t\t\t\tnode.value!.perTestData.add(id);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (chain) {\n\t\t\tthis.didAddCoverage.trigger(tx, chain);\n\t\t}\n\t}\n\n\t/**\n\t * Builds a new tree filtered to per-test coverage data for the given ID.\n\t */\n\tpublic filterTreeForTest(testId: TestId) {\n\t\tconst tree = new WellDefinedPrefixTree<AbstractFileCoverage>();\n\t\tfor (const node of this.tree.values()) {\n\t\t\tif (node instanceof FileCoverage) {\n\t\t\t\tif (!node.perTestData?.has(testId.toString())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst canonical = [...this.treePathForUri(node.uri, /* canonical = */ true)];\n\t\t\t\tconst chain: IPrefixTreeNode<AbstractFileCoverage>[] = [];\n\t\t\t\ttree.mutatePath(this.treePathForUri(node.uri, /* canonical = */ false), n => {\n\t\t\t\t\tchain.push(n);\n\t\t\t\t\tn.value ??= new BypassedFileCoverage(this.treePathToUri(canonical.slice(0, chain.length)), node.fromResult);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn tree;\n\t}\n\n\t/**\n\t * Gets coverage information for all files.\n\t */\n\tpublic getAllFiles() {\n\t\treturn this.fileCoverage;\n\t}\n\n\t/**\n\t * Gets coverage information for a specific file.\n\t */\n\tpublic getUri(uri: URI) {\n\t\treturn this.fileCoverage.get(uri);\n\t}\n\n\t/**\n\t * Gets computed information for a file, including DFS-computed information\n\t * from child tests.\n\t */\n\tpublic getComputedForUri(uri: URI) {\n\t\treturn this.tree.find(this.treePathForUri(uri, /* canonical = */ false));\n\t}\n\n\tprivate *treePathForUri(uri: URI, canconicalPath: boolean) {\n\t\tyield uri.scheme;\n\t\tyield uri.authority;\n\n\t\tconst path = !canconicalPath && this.uriIdentityService.extUri.ignorePathCasing(uri) ? uri.path.toLowerCase() : uri.path;\n\t\tyield* path.split('/');\n\t}\n\n\tprivate treePathToUri(path: string[]) {\n\t\treturn URI.from({ scheme: path[0], authority: path[1], path: path.slice(2).join('/') });\n\t}\n}\n\nexport const getTotalCoveragePercent = (statement: ICoverageCount, branch: ICoverageCount | undefined, function_: ICoverageCount | undefined) => {\n\tlet numerator = statement.covered;\n\tlet denominator = statement.total;\n\n\tif (branch) {\n\t\tnumerator += branch.covered;\n\t\tdenominator += branch.total;\n\t}\n\n\tif (function_) {\n\t\tnumerator += function_.covered;\n\t\tdenominator += function_.total;\n\t}\n\n\treturn denominator === 0 ? 1 : numerator / denominator;\n};\n\nexport abstract class AbstractFileCoverage {\n\tpublic id: string;\n\tpublic readonly uri: URI;\n\tpublic statement: ICoverageCount;\n\tpublic branch?: ICoverageCount;\n\tpublic declaration?: ICoverageCount;\n\tpublic readonly didChange = observableSignal(this);\n\n\t/**\n\t * Gets the total coverage percent based on information provided.\n\t * This is based on the Clover total coverage formula\n\t */\n\tpublic get tpc() {\n\t\treturn getTotalCoveragePercent(this.statement, this.branch, this.declaration);\n\t}\n\n\t/**\n\t * Per-test coverage data for this file, if available.\n\t */\n\tpublic perTestData?: Set<string>;\n\n\tconstructor(coverage: IFileCoverage, public readonly fromResult: LiveTestResult) {\n\t\tthis.id = coverage.id;\n\t\tthis.uri = coverage.uri;\n\t\tthis.statement = coverage.statement;\n\t\tthis.branch = coverage.branch;\n\t\tthis.declaration = coverage.declaration;\n\t}\n}\n\n/**\n * File coverage info computed from children in the tree, not provided by the\n * extension.\n */\nexport class ComputedFileCoverage extends AbstractFileCoverage { }\n\n/**\n * A virtual node that doesn't have any added coverage info.\n */\nexport class BypassedFileCoverage extends ComputedFileCoverage {\n\tconstructor(uri: URI, result: LiveTestResult) {\n\t\tsuper({ id: String(incId++), uri, statement: { covered: 0, total: 0 } }, result);\n\t}\n}\n\nexport class FileCoverage extends AbstractFileCoverage {\n\tprivate _details?: Promise<CoverageDetails[]>;\n\tprivate resolved?: boolean;\n\tprivate _detailsForTest?: Map<string, Promise<CoverageDetails[]>>;\n\n\t/** Gets whether details are synchronously available */\n\tpublic get hasSynchronousDetails() {\n\t\treturn this._details instanceof Array || this.resolved;\n\t}\n\n\tconstructor(coverage: IFileCoverage, fromResult: LiveTestResult, private readonly accessor: ICoverageAccessor) {\n\t\tsuper(coverage, fromResult);\n\t}\n\n\t/**\n\t * Gets per-line coverage details.\n\t */\n\tpublic async detailsForTest(_testId: TestId, token = CancellationToken.None) {\n\t\tthis._detailsForTest ??= new Map();\n\t\tconst testId = _testId.toString();\n\t\tconst prev = this._detailsForTest.get(testId);\n\t\tif (prev) {\n\t\t\treturn prev;\n\t\t}\n\n\t\tconst promise = (async () => {\n\t\t\ttry {\n\t\t\t\treturn await this.accessor.getCoverageDetails(this.id, testId, token);\n\t\t\t} catch (e) {\n\t\t\t\tthis._detailsForTest?.delete(testId);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t})();\n\n\t\tthis._detailsForTest.set(testId, promise);\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Gets per-line coverage details.\n\t */\n\tpublic async details(token = CancellationToken.None) {\n\t\tthis._details ??= this.accessor.getCoverageDetails(this.id, undefined, token);\n\n\t\ttry {\n\t\t\tconst d = await this._details;\n\t\t\tthis.resolved = true;\n\t\t\treturn d;\n\t\t} catch (e) {\n\t\t\tthis._details = undefined;\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n\nexport const totalFromCoverageDetails = (uri: URI, details: CoverageDetails[]): IFileCoverage => {\n\tconst fc: IFileCoverage = {\n\t\tid: '',\n\t\turi,\n\t\tstatement: ICoverageCount.empty(),\n\t};\n\n\tfor (const detail of details) {\n\t\tif (detail.type === DetailType.Statement) {\n\t\t\tfc.statement.total++;\n\t\t\tfc.statement.total += detail.count ? 1 : 0;\n\n\t\t\tfor (const branch of detail.branches || []) {\n\t\t\t\tfc.branch ??= ICoverageCount.empty();\n\t\t\t\tfc.branch.total++;\n\t\t\t\tfc.branch.covered += branch.count ? 1 : 0;\n\t\t\t}\n\t\t} else {\n\t\t\tfc.declaration ??= ICoverageCount.empty();\n\t\t\tfc.declaration.total++;\n\t\t\tfc.declaration.covered += detail.count ? 1 : 0;\n\t\t}\n\t}\n\n\treturn fc;\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { ITransaction, observableSignal } from '../../../../base/common/observable.js';\nimport { IPrefixTreeNode, WellDefinedPrefixTree } from '../../../../base/common/prefixTree.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { TestId } from './testId.js';\nimport { LiveTestResult } from './testResult.js';\nimport { CoverageDetails, DetailType, ICoverageCount, IFileCoverage } from './testTypes.js';\n\nexport interface ICoverageAccessor {\n\tgetCoverageDetails: (id: string, testId: string | undefined, token: CancellationToken) => Promise<CoverageDetails[]>;\n}\n\nlet incId = 0;\n\n/**\n * Class that exposese coverage information for a run.\n */\nexport class TestCoverage {\n\tprivate readonly fileCoverage = new ResourceMap<FileCoverage>();\n\tpublic readonly didAddCoverage = observableSignal<IPrefixTreeNode<AbstractFileCoverage>[]>(this);\n\tpublic readonly tree = new WellDefinedPrefixTree<AbstractFileCoverage>();\n\tpublic readonly associatedData = new Map<unknown, unknown>();\n\n\tconstructor(\n\t\tpublic readonly result: LiveTestResult,\n\t\tpublic readonly fromTaskId: string,\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t\tprivate readonly accessor: ICoverageAccessor,\n\t) { }\n\n\t/** Gets all test IDs that were included in this test run. */\n\tpublic *allPerTestIDs() {\n\t\tconst seen = new Set<string>();\n\t\tfor (const root of this.tree.nodes) {\n\t\t\tif (root.value && root.value.perTestData) {\n\t\t\t\tfor (const id of root.value.perTestData) {\n\t\t\t\t\tif (!seen.has(id)) {\n\t\t\t\t\t\tseen.add(id);\n\t\t\t\t\t\tyield id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic append(coverage: IFileCoverage, tx: ITransaction | undefined) {\n\t\tconst previous = this.getComputedForUri(coverage.uri);\n\t\tconst result = this.result;\n\t\tconst applyDelta = (kind: 'statement' | 'branch' | 'declaration', node: ComputedFileCoverage) => {\n\t\t\tif (!node[kind]) {\n\t\t\t\tif (coverage[kind]) {\n\t\t\t\t\tnode[kind] = { ...coverage[kind]! };\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode[kind]!.covered += (coverage[kind]?.covered || 0) - (previous?.[kind]?.covered || 0);\n\t\t\t\tnode[kind]!.total += (coverage[kind]?.total || 0) - (previous?.[kind]?.total || 0);\n\t\t\t}\n\t\t};\n\n\t\t// We insert using the non-canonical path to normalize for casing differences\n\t\t// between URIs, but when inserting an intermediate node always use 'a' canonical\n\t\t// version.\n\t\tconst canonical = [...this.treePathForUri(coverage.uri, /* canonical = */ true)];\n\t\tconst chain: IPrefixTreeNode<AbstractFileCoverage>[] = [];\n\n\t\tthis.tree.mutatePath(this.treePathForUri(coverage.uri, /* canonical = */ false), node => {\n\t\t\tchain.push(node);\n\n\t\t\tif (chain.length === canonical.length) {\n\t\t\t\t// we reached our destination node, apply the coverage as necessary:\n\t\t\t\tif (node.value) {\n\t\t\t\t\tconst v = node.value;\n\t\t\t\t\t// if ID was generated from a test-specific coverage, reassign it to get its real ID in the extension host.\n\t\t\t\t\tv.id = coverage.id;\n\t\t\t\t\tv.statement = coverage.statement;\n\t\t\t\t\tv.branch = coverage.branch;\n\t\t\t\t\tv.declaration = coverage.declaration;\n\t\t\t\t} else {\n\t\t\t\t\tconst v = node.value = new FileCoverage(coverage, result, this.accessor);\n\t\t\t\t\tthis.fileCoverage.set(coverage.uri, v);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Otherwise, if this is not a partial per-test coverage, merge the\n\t\t\t\t// coverage changes into the chain. Per-test coverages are not complete\n\t\t\t\t// and we don't want to consider them for computation.\n\t\t\t\tif (!node.value) {\n\t\t\t\t\t// clone because later intersertions can modify the counts:\n\t\t\t\t\tconst intermediate = deepClone(coverage);\n\t\t\t\t\tintermediate.id = String(incId++);\n\t\t\t\t\tintermediate.uri = this.treePathToUri(canonical.slice(0, chain.length));\n\t\t\t\t\tnode.value = new ComputedFileCoverage(intermediate, result);\n\t\t\t\t} else {\n\t\t\t\t\tapplyDelta('statement', node.value);\n\t\t\t\t\tapplyDelta('branch', node.value);\n\t\t\t\t\tapplyDelta('declaration', node.value);\n\t\t\t\t\tnode.value.didChange.trigger(tx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (coverage.testIds) {\n\t\t\t\tnode.value!.perTestData ??= new Set();\n\t\t\t\tfor (const id of coverage.testIds) {\n\t\t\t\t\tnode.value!.perTestData.add(id);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (chain) {\n\t\t\tthis.didAddCoverage.trigger(tx, chain);\n\t\t}\n\t}\n\n\t/**\n\t * Builds a new tree filtered to per-test coverage data for the given ID.\n\t */\n\tpublic filterTreeForTest(testId: TestId) {\n\t\tconst tree = new WellDefinedPrefixTree<AbstractFileCoverage>();\n\t\tfor (const node of this.tree.values()) {\n\t\t\tif (node instanceof FileCoverage) {\n\t\t\t\tif (!node.perTestData?.has(testId.toString())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst canonical = [...this.treePathForUri(node.uri, /* canonical = */ true)];\n\t\t\t\tconst chain: IPrefixTreeNode<AbstractFileCoverage>[] = [];\n\t\t\t\ttree.mutatePath(this.treePathForUri(node.uri, /* canonical = */ false), n => {\n\t\t\t\t\tchain.push(n);\n\t\t\t\t\tn.value ??= new BypassedFileCoverage(this.treePathToUri(canonical.slice(0, chain.length)), node.fromResult);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn tree;\n\t}\n\n\t/**\n\t * Gets coverage information for all files.\n\t */\n\tpublic getAllFiles() {\n\t\treturn this.fileCoverage;\n\t}\n\n\t/**\n\t * Gets coverage information for a specific file.\n\t */\n\tpublic getUri(uri: URI) {\n\t\treturn this.fileCoverage.get(uri);\n\t}\n\n\t/**\n\t * Gets computed information for a file, including DFS-computed information\n\t * from child tests.\n\t */\n\tpublic getComputedForUri(uri: URI) {\n\t\treturn this.tree.find(this.treePathForUri(uri, /* canonical = */ false));\n\t}\n\n\tprivate *treePathForUri(uri: URI, canconicalPath: boolean) {\n\t\tyield uri.scheme;\n\t\tyield uri.authority;\n\n\t\tconst path = !canconicalPath && this.uriIdentityService.extUri.ignorePathCasing(uri) ? uri.path.toLowerCase() : uri.path;\n\t\tyield* path.split('/');\n\t}\n\n\tprivate treePathToUri(path: string[]) {\n\t\treturn URI.from({ scheme: path[0], authority: path[1], path: path.slice(2).join('/') });\n\t}\n}\n\nexport const getTotalCoveragePercent = (statement: ICoverageCount, branch: ICoverageCount | undefined, function_: ICoverageCount | undefined) => {\n\tlet numerator = statement.covered;\n\tlet denominator = statement.total;\n\n\tif (branch) {\n\t\tnumerator += branch.covered;\n\t\tdenominator += branch.total;\n\t}\n\n\tif (function_) {\n\t\tnumerator += function_.covered;\n\t\tdenominator += function_.total;\n\t}\n\n\treturn denominator === 0 ? 1 : numerator / denominator;\n};\n\nexport abstract class AbstractFileCoverage {\n\tpublic id: string;\n\tpublic readonly uri: URI;\n\tpublic statement: ICoverageCount;\n\tpublic branch?: ICoverageCount;\n\tpublic declaration?: ICoverageCount;\n\tpublic readonly didChange = observableSignal(this);\n\n\t/**\n\t * Gets the total coverage percent based on information provided.\n\t * This is based on the Clover total coverage formula\n\t */\n\tpublic get tpc() {\n\t\treturn getTotalCoveragePercent(this.statement, this.branch, this.declaration);\n\t}\n\n\t/**\n\t * Per-test coverage data for this file, if available.\n\t */\n\tpublic perTestData?: Set<string>;\n\n\tconstructor(coverage: IFileCoverage, public readonly fromResult: LiveTestResult) {\n\t\tthis.id = coverage.id;\n\t\tthis.uri = coverage.uri;\n\t\tthis.statement = coverage.statement;\n\t\tthis.branch = coverage.branch;\n\t\tthis.declaration = coverage.declaration;\n\t}\n}\n\n/**\n * File coverage info computed from children in the tree, not provided by the\n * extension.\n */\nexport class ComputedFileCoverage extends AbstractFileCoverage { }\n\n/**\n * A virtual node that doesn't have any added coverage info.\n */\nexport class BypassedFileCoverage extends ComputedFileCoverage {\n\tconstructor(uri: URI, result: LiveTestResult) {\n\t\tsuper({ id: String(incId++), uri, statement: { covered: 0, total: 0 } }, result);\n\t}\n}\n\nexport class FileCoverage extends AbstractFileCoverage {\n\tprivate _details?: Promise<CoverageDetails[]>;\n\tprivate resolved?: boolean;\n\tprivate _detailsForTest?: Map<string, Promise<CoverageDetails[]>>;\n\n\t/** Gets whether details are synchronously available */\n\tpublic get hasSynchronousDetails() {\n\t\treturn this._details instanceof Array || this.resolved;\n\t}\n\n\tconstructor(coverage: IFileCoverage, fromResult: LiveTestResult, private readonly accessor: ICoverageAccessor) {\n\t\tsuper(coverage, fromResult);\n\t}\n\n\t/**\n\t * Gets per-line coverage details.\n\t */\n\tpublic async detailsForTest(_testId: TestId, token = CancellationToken.None) {\n\t\tthis._detailsForTest ??= new Map();\n\t\tconst testId = _testId.toString();\n\t\tconst prev = this._detailsForTest.get(testId);\n\t\tif (prev) {\n\t\t\treturn prev;\n\t\t}\n\n\t\tconst promise = (async () => {\n\t\t\ttry {\n\t\t\t\treturn await this.accessor.getCoverageDetails(this.id, testId, token);\n\t\t\t} catch (e) {\n\t\t\t\tthis._detailsForTest?.delete(testId);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t})();\n\n\t\tthis._detailsForTest.set(testId, promise);\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Gets per-line coverage details.\n\t */\n\tpublic async details(token = CancellationToken.None) {\n\t\tthis._details ??= this.accessor.getCoverageDetails(this.id, undefined, token);\n\n\t\ttry {\n\t\t\tconst d = await this._details;\n\t\t\tthis.resolved = true;\n\t\t\treturn d;\n\t\t} catch (e) {\n\t\t\tthis._details = undefined;\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n\nexport const totalFromCoverageDetails = (uri: URI, details: CoverageDetails[]): IFileCoverage => {\n\tconst fc: IFileCoverage = {\n\t\tid: '',\n\t\turi,\n\t\tstatement: ICoverageCount.empty(),\n\t};\n\n\tfor (const detail of details) {\n\t\tif (detail.type === DetailType.Statement) {\n\t\t\tfc.statement.total++;\n\t\t\tfc.statement.total += detail.count ? 1 : 0;\n\n\t\t\tfor (const branch of detail.branches || []) {\n\t\t\t\tfc.branch ??= ICoverageCount.empty();\n\t\t\t\tfc.branch.total++;\n\t\t\t\tfc.branch.covered += branch.count ? 1 : 0;\n\t\t\t}\n\t\t} else {\n\t\t\tfc.declaration ??= ICoverageCount.empty();\n\t\t\tfc.declaration.total++;\n\t\t\tfc.declaration.covered += detail.count ? 1 : 0;\n\t\t}\n\t}\n\n\treturn fc;\n};\n"]}