{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/common/mainThreadTestCollection.ts","vs/workbench/contrib/testing/common/mainThreadTestCollection.ts"],"names":[],"mappings":"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","file":"mainThreadTestCollection.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IMainThreadTestCollection } from './testService.js';\nimport { AbstractIncrementalTestCollection, ITestUriCanonicalizer, IncrementalChangeCollector, IncrementalTestCollectionItem, InternalTestItem, TestDiffOpType, TestsDiff } from './testTypes.js';\n\nexport class MainThreadTestCollection extends AbstractIncrementalTestCollection<IncrementalTestCollectionItem> implements IMainThreadTestCollection {\n\tprivate testsByUrl = new ResourceMap<Set<IncrementalTestCollectionItem>>();\n\n\tprivate busyProvidersChangeEmitter = new Emitter<number>();\n\tprivate expandPromises = new WeakMap<IncrementalTestCollectionItem, {\n\t\tpendingLvl: number;\n\t\tdoneLvl: number;\n\t\tprom: Promise<void>;\n\t}>();\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get busyProviders() {\n\t\treturn this.busyControllerCount;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get rootItems() {\n\t\treturn this.roots;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get all() {\n\t\treturn this.getIterator();\n\t}\n\n\tpublic get rootIds() {\n\t\treturn Iterable.map(this.roots.values(), r => r.item.extId);\n\t}\n\n\tpublic readonly onBusyProvidersChange = this.busyProvidersChangeEmitter.event;\n\n\tconstructor(uriIdentityService: ITestUriCanonicalizer, private readonly expandActual: (id: string, levels: number) => Promise<void>) {\n\t\tsuper(uriIdentityService);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic expand(testId: string, levels: number): Promise<void> {\n\t\tconst test = this.items.get(testId);\n\t\tif (!test) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\t// simple cache to avoid duplicate/unnecessary expansion calls\n\t\tconst existing = this.expandPromises.get(test);\n\t\tif (existing && existing.pendingLvl >= levels) {\n\t\t\treturn existing.prom;\n\t\t}\n\n\t\tconst prom = this.expandActual(test.item.extId, levels);\n\t\tconst record = { doneLvl: existing ? existing.doneLvl : -1, pendingLvl: levels, prom };\n\t\tthis.expandPromises.set(test, record);\n\n\t\treturn prom.then(() => {\n\t\t\trecord.doneLvl = levels;\n\t\t});\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getNodeById(id: string) {\n\t\treturn this.items.get(id);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getNodeByUrl(uri: URI): Iterable<IncrementalTestCollectionItem> {\n\t\treturn this.testsByUrl.get(uri) || Iterable.empty();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getReviverDiff() {\n\t\tconst ops: TestsDiff = [{ op: TestDiffOpType.IncrementPendingExtHosts, amount: this.pendingRootCount }];\n\n\t\tconst queue = [this.rootIds];\n\t\twhile (queue.length) {\n\t\t\tfor (const child of queue.pop()!) {\n\t\t\t\tconst item = this.items.get(child)!;\n\t\t\t\tops.push({\n\t\t\t\t\top: TestDiffOpType.Add,\n\t\t\t\t\titem: {\n\t\t\t\t\t\tcontrollerId: item.controllerId,\n\t\t\t\t\t\texpand: item.expand,\n\t\t\t\t\t\titem: item.item,\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tqueue.push(item.children);\n\t\t\t}\n\t\t}\n\n\t\treturn ops;\n\t}\n\n\t/**\n\t * Applies the diff to the collection.\n\t */\n\tpublic override apply(diff: TestsDiff) {\n\t\tconst prevBusy = this.busyControllerCount;\n\t\tsuper.apply(diff);\n\n\t\tif (prevBusy !== this.busyControllerCount) {\n\t\t\tthis.busyProvidersChangeEmitter.fire(this.busyControllerCount);\n\t\t}\n\t}\n\n\t/**\n\t * Clears everything from the collection, and returns a diff that applies\n\t * that action.\n\t */\n\tpublic clear() {\n\t\tconst ops: TestsDiff = [];\n\t\tfor (const root of this.roots) {\n\t\t\tops.push({ op: TestDiffOpType.Remove, itemId: root.item.extId });\n\t\t}\n\n\t\tthis.roots.clear();\n\t\tthis.items.clear();\n\n\t\treturn ops;\n\t}\n\n\t/**\n\t * @override\n\t */\n\tprotected createItem(internal: InternalTestItem): IncrementalTestCollectionItem {\n\t\treturn { ...internal, children: new Set() };\n\t}\n\n\tprivate readonly changeCollector: IncrementalChangeCollector<IncrementalTestCollectionItem> = {\n\t\tadd: node => {\n\t\t\tif (!node.item.uri) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst s = this.testsByUrl.get(node.item.uri);\n\t\t\tif (!s) {\n\t\t\t\tthis.testsByUrl.set(node.item.uri, new Set([node]));\n\t\t\t} else {\n\t\t\t\ts.add(node);\n\t\t\t}\n\t\t},\n\t\tremove: node => {\n\t\t\tif (!node.item.uri) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst s = this.testsByUrl.get(node.item.uri);\n\t\t\tif (!s) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ts.delete(node);\n\t\t\tif (s.size === 0) {\n\t\t\t\tthis.testsByUrl.delete(node.item.uri);\n\t\t\t}\n\t\t},\n\t};\n\n\tprotected override createChangeCollector(): IncrementalChangeCollector<IncrementalTestCollectionItem> {\n\t\treturn this.changeCollector;\n\t}\n\n\tprivate *getIterator() {\n\t\tconst queue = new LinkedList<Iterable<string>>();\n\t\tqueue.push(this.rootIds);\n\n\t\twhile (queue.size > 0) {\n\t\t\tfor (const id of queue.pop()!) {\n\t\t\t\tconst node = this.getNodeById(id)!;\n\t\t\t\tyield node;\n\t\t\t\tqueue.push(node.children);\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IMainThreadTestCollection } from './testService.js';\nimport { AbstractIncrementalTestCollection, ITestUriCanonicalizer, IncrementalChangeCollector, IncrementalTestCollectionItem, InternalTestItem, TestDiffOpType, TestsDiff } from './testTypes.js';\n\nexport class MainThreadTestCollection extends AbstractIncrementalTestCollection<IncrementalTestCollectionItem> implements IMainThreadTestCollection {\n\tprivate testsByUrl = new ResourceMap<Set<IncrementalTestCollectionItem>>();\n\n\tprivate busyProvidersChangeEmitter = new Emitter<number>();\n\tprivate expandPromises = new WeakMap<IncrementalTestCollectionItem, {\n\t\tpendingLvl: number;\n\t\tdoneLvl: number;\n\t\tprom: Promise<void>;\n\t}>();\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get busyProviders() {\n\t\treturn this.busyControllerCount;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get rootItems() {\n\t\treturn this.roots;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get all() {\n\t\treturn this.getIterator();\n\t}\n\n\tpublic get rootIds() {\n\t\treturn Iterable.map(this.roots.values(), r => r.item.extId);\n\t}\n\n\tpublic readonly onBusyProvidersChange = this.busyProvidersChangeEmitter.event;\n\n\tconstructor(uriIdentityService: ITestUriCanonicalizer, private readonly expandActual: (id: string, levels: number) => Promise<void>) {\n\t\tsuper(uriIdentityService);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic expand(testId: string, levels: number): Promise<void> {\n\t\tconst test = this.items.get(testId);\n\t\tif (!test) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\t// simple cache to avoid duplicate/unnecessary expansion calls\n\t\tconst existing = this.expandPromises.get(test);\n\t\tif (existing && existing.pendingLvl >= levels) {\n\t\t\treturn existing.prom;\n\t\t}\n\n\t\tconst prom = this.expandActual(test.item.extId, levels);\n\t\tconst record = { doneLvl: existing ? existing.doneLvl : -1, pendingLvl: levels, prom };\n\t\tthis.expandPromises.set(test, record);\n\n\t\treturn prom.then(() => {\n\t\t\trecord.doneLvl = levels;\n\t\t});\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getNodeById(id: string) {\n\t\treturn this.items.get(id);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getNodeByUrl(uri: URI): Iterable<IncrementalTestCollectionItem> {\n\t\treturn this.testsByUrl.get(uri) || Iterable.empty();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getReviverDiff() {\n\t\tconst ops: TestsDiff = [{ op: TestDiffOpType.IncrementPendingExtHosts, amount: this.pendingRootCount }];\n\n\t\tconst queue = [this.rootIds];\n\t\twhile (queue.length) {\n\t\t\tfor (const child of queue.pop()!) {\n\t\t\t\tconst item = this.items.get(child)!;\n\t\t\t\tops.push({\n\t\t\t\t\top: TestDiffOpType.Add,\n\t\t\t\t\titem: {\n\t\t\t\t\t\tcontrollerId: item.controllerId,\n\t\t\t\t\t\texpand: item.expand,\n\t\t\t\t\t\titem: item.item,\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tqueue.push(item.children);\n\t\t\t}\n\t\t}\n\n\t\treturn ops;\n\t}\n\n\t/**\n\t * Applies the diff to the collection.\n\t */\n\tpublic override apply(diff: TestsDiff) {\n\t\tconst prevBusy = this.busyControllerCount;\n\t\tsuper.apply(diff);\n\n\t\tif (prevBusy !== this.busyControllerCount) {\n\t\t\tthis.busyProvidersChangeEmitter.fire(this.busyControllerCount);\n\t\t}\n\t}\n\n\t/**\n\t * Clears everything from the collection, and returns a diff that applies\n\t * that action.\n\t */\n\tpublic clear() {\n\t\tconst ops: TestsDiff = [];\n\t\tfor (const root of this.roots) {\n\t\t\tops.push({ op: TestDiffOpType.Remove, itemId: root.item.extId });\n\t\t}\n\n\t\tthis.roots.clear();\n\t\tthis.items.clear();\n\n\t\treturn ops;\n\t}\n\n\t/**\n\t * @override\n\t */\n\tprotected createItem(internal: InternalTestItem): IncrementalTestCollectionItem {\n\t\treturn { ...internal, children: new Set() };\n\t}\n\n\tprivate readonly changeCollector: IncrementalChangeCollector<IncrementalTestCollectionItem> = {\n\t\tadd: node => {\n\t\t\tif (!node.item.uri) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst s = this.testsByUrl.get(node.item.uri);\n\t\t\tif (!s) {\n\t\t\t\tthis.testsByUrl.set(node.item.uri, new Set([node]));\n\t\t\t} else {\n\t\t\t\ts.add(node);\n\t\t\t}\n\t\t},\n\t\tremove: node => {\n\t\t\tif (!node.item.uri) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst s = this.testsByUrl.get(node.item.uri);\n\t\t\tif (!s) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ts.delete(node);\n\t\t\tif (s.size === 0) {\n\t\t\t\tthis.testsByUrl.delete(node.item.uri);\n\t\t\t}\n\t\t},\n\t};\n\n\tprotected override createChangeCollector(): IncrementalChangeCollector<IncrementalTestCollectionItem> {\n\t\treturn this.changeCollector;\n\t}\n\n\tprivate *getIterator() {\n\t\tconst queue = new LinkedList<Iterable<string>>();\n\t\tqueue.push(this.rootIds);\n\n\t\twhile (queue.size > 0) {\n\t\t\tfor (const id of queue.pop()!) {\n\t\t\t\tconst node = this.getNodeById(id)!;\n\t\t\t\tyield node;\n\t\t\t\tqueue.push(node.children);\n\t\t\t}\n\t\t}\n\t}\n}\n"]}