{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/common/testService.ts","vs/workbench/contrib/testing/common/testService.ts"],"names":[],"mappings":"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","file":"testService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from '../../../../base/common/assert.js';\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { MarshalledId } from '../../../../base/common/marshallingIds.js';\nimport { IObservable } from '../../../../base/common/observable.js';\nimport { IPrefixTreeNode, WellDefinedPrefixTree } from '../../../../base/common/prefixTree.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Position } from '../../../../editor/common/core/position.js';\nimport { Location } from '../../../../editor/common/languages.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { MutableObservableValue } from './observableValue.js';\nimport { TestExclusions } from './testExclusions.js';\nimport { TestId, TestIdPathParts } from './testId.js';\nimport { ITestResult } from './testResult.js';\nimport { AbstractIncrementalTestCollection, ICallProfileRunHandler, IncrementalTestCollectionItem, InternalTestItem, IStartControllerTests, IStartControllerTestsResult, ITestItemContext, ResolvedTestRunRequest, TestControllerCapability, TestItemExpandState, TestMessageFollowupRequest, TestMessageFollowupResponse, TestRunProfileBitset, TestsDiff } from './testTypes.js';\n\nexport const ITestService = createDecorator<ITestService>('testService');\n\nexport interface IMainThreadTestController {\n\treadonly id: string;\n\treadonly label: IObservable<string>;\n\treadonly capabilities: IObservable<TestControllerCapability>;\n\tsyncTests(token: CancellationToken): Promise<void>;\n\trefreshTests(token: CancellationToken): Promise<void>;\n\tconfigureRunProfile(profileId: number): void;\n\texpandTest(id: string, levels: number): Promise<void>;\n\tgetRelatedCode(testId: string, token: CancellationToken): Promise<Location[]>;\n\tstartContinuousRun(request: ICallProfileRunHandler[], token: CancellationToken): Promise<IStartControllerTestsResult[]>;\n\trunTests(request: IStartControllerTests[], token: CancellationToken): Promise<IStartControllerTestsResult[]>;\n}\n\nexport interface IMainThreadTestHostProxy {\n\tprovideTestFollowups(req: TestMessageFollowupRequest, token: CancellationToken): Promise<TestMessageFollowupResponse[]>;\n\tgetTestsRelatedToCode(uri: URI, position: Position, token: CancellationToken): Promise<string[]>;\n\texecuteTestFollowup(id: number): Promise<void>;\n\tdisposeTestFollowups(ids: number[]): void;\n}\n\nexport interface IMainThreadTestCollection extends AbstractIncrementalTestCollection<IncrementalTestCollectionItem> {\n\treadonly onBusyProvidersChange: Event<number>;\n\n\t/**\n\t * Number of providers working to discover tests.\n\t */\n\tbusyProviders: number;\n\n\t/**\n\t * Root item IDs.\n\t */\n\trootIds: Iterable<string>;\n\n\t/**\n\t * Root items, correspond to registered controllers.\n\t */\n\trootItems: Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Iterates over every test in the collection, in strictly descending\n\t * order of depth.\n\t */\n\tall: Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Gets a node in the collection by ID.\n\t */\n\tgetNodeById(id: string): IncrementalTestCollectionItem | undefined;\n\n\t/**\n\t * Gets all tests that have the given URL. Tests returned from this\n\t * method are *not* in any particular order.\n\t */\n\tgetNodeByUrl(uri: URI): Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Requests that children be revealed for the given test. \"Levels\" may\n\t * be infinite.\n\t */\n\texpand(testId: string, levels: number): Promise<void>;\n\n\t/**\n\t * Gets a diff that adds all items currently in the tree to a new collection,\n\t * allowing it to fully hydrate.\n\t */\n\tgetReviverDiff(): TestsDiff;\n}\n\nexport const testCollectionIsEmpty = (collection: IMainThreadTestCollection) =>\n\t!Iterable.some(collection.rootItems, r => r.children.size > 0);\n\nexport const getContextForTestItem = (collection: IMainThreadTestCollection, id: string | TestId) => {\n\tif (typeof id === 'string') {\n\t\tid = TestId.fromString(id);\n\t}\n\n\tif (id.isRoot) {\n\t\treturn { controller: id.toString() };\n\t}\n\n\tconst context: ITestItemContext = { $mid: MarshalledId.TestItemContext, tests: [] };\n\tfor (const i of id.idsFromRoot()) {\n\t\tif (!i.isRoot) {\n\t\t\tconst test = collection.getNodeById(i.toString());\n\t\t\tif (test) {\n\t\t\t\tcontext.tests.push(test);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn context;\n};\n\n/**\n * Ensures the test with the given ID exists in the collection, if possible.\n * If cancellation is requested, or the test cannot be found, it will return\n * undefined.\n */\nexport const expandAndGetTestById = async (collection: IMainThreadTestCollection, id: string, ct = CancellationToken.None) => {\n\tconst idPath = [...TestId.fromString(id).idsFromRoot()];\n\n\tlet expandToLevel = 0;\n\tfor (let i = idPath.length - 1; !ct.isCancellationRequested && i >= expandToLevel;) {\n\t\tconst id = idPath[i].toString();\n\t\tconst existing = collection.getNodeById(id);\n\t\tif (!existing) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i === idPath.length - 1) {\n\t\t\treturn existing;\n\t\t}\n\n\t\t// expand children only if it looks like it's necessary\n\t\tif (!existing.children.has(idPath[i + 1].toString())) {\n\t\t\tawait collection.expand(id, 0);\n\t\t}\n\n\t\texpandToLevel = i + 1; // avoid an infinite loop if the test does not exist\n\t\ti = idPath.length - 1;\n\t}\n\treturn undefined;\n};\n\n/**\n * Waits for the test to no longer be in the \"busy\" state.\n */\nexport const waitForTestToBeIdle = (testService: ITestService, test: IncrementalTestCollectionItem) => {\n\tif (!test.item.busy) {\n\t\treturn;\n\t}\n\n\treturn new Promise<void>(resolve => {\n\t\tconst l = testService.onDidProcessDiff(() => {\n\t\t\tif (testService.collection.getNodeById(test.item.extId)?.item.busy !== true) {\n\t\t\t\tresolve(); // removed, or no longer busy\n\t\t\t\tl.dispose();\n\t\t\t}\n\t\t});\n\t});\n};\n\n/**\n * Iterator that expands to and iterates through tests in the file. Iterates\n * in strictly descending order.\n */\nexport const testsInFile = async function* (testService: ITestService, ident: IUriIdentityService, uri: URI, waitForIdle = true, descendInFile = true): AsyncIterable<readonly IncrementalTestCollectionItem[]> {\n\t// In this function we go to a bit of effort to avoid awaiting unnecessarily\n\t// and bulking the test collections we do collect for consumers. This fixes\n\t// a performance issue (#235819) where a large number of tests in a file\n\t// would cause a long delay switching editors.\n\tconst queue = new LinkedList<Iterable<string> | DeferredPromise<Iterable<string>>>();\n\n\tconst existing = [...testService.collection.getNodeByUrl(uri)].sort((a, b) => a.item.extId.length - b.item.extId.length);\n\n\t// getNodeByUrl will return all known tests in the URI, but this can include\n\t// children of tests even when `descendInFile` is false. Remove those cases.\n\tfor (let i = 0; i < existing.length - 1; i++) {\n\t\tconst prefix = existing[i].item.extId + TestIdPathParts.Delimiter;\n\t\tfor (let k = i + 1; k < existing.length; k++) {\n\t\t\tif (existing[k].item.extId.startsWith(prefix)) {\n\t\t\t\texisting.splice(k--, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue.push(existing.length ? existing.map(e => e.item.extId) : testService.collection.rootIds);\n\n\tlet n = 0;\n\tlet gather: IncrementalTestCollectionItem[] = [];\n\twhile (queue.size > 0) {\n\t\tconst next = queue.pop()!;\n\t\tlet ids: Iterable<string>;\n\t\tif (!(next instanceof DeferredPromise)) {\n\t\t\tids = next;\n\t\t} else if (next.isSettled) {\n\t\t\tids = next.value || Iterable.empty();\n\t\t} else {\n\t\t\tif (gather.length) {\n\t\t\t\tyield gather;\n\t\t\t\tgather = [];\n\t\t\t}\n\t\t\tids = await next.p;\n\t\t}\n\n\t\tfor (const id of ids) {\n\t\t\tn++;\n\t\t\tconst test = testService.collection.getNodeById(id);\n\t\t\tif (!test) {\n\t\t\t\tcontinue; // possible because we expand async and things could delete\n\t\t\t}\n\n\t\t\tif (!test.item.uri) {\n\t\t\t\tqueue.push(test.children);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ident.extUri.isEqual(uri, test.item.uri)) {\n\t\t\t\tgather.push(test);\n\n\t\t\t\tif (!descendInFile) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ident.extUri.isEqualOrParent(uri, test.item.uri)) {\n\t\t\t\tlet prom: Promise<void> | undefined;\n\t\t\t\tif (test.expand === TestItemExpandState.Expandable) {\n\t\t\t\t\tprom = testService.collection.expand(test.item.extId, 1);\n\t\t\t\t}\n\t\t\t\tif (waitForIdle) {\n\t\t\t\t\tif (prom) {\n\t\t\t\t\t\tprom = prom.then(() => waitForTestToBeIdle(testService, test));\n\t\t\t\t\t} else if (test.item.busy) {\n\t\t\t\t\t\tprom = waitForTestToBeIdle(testService, test);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (prom) {\n\t\t\t\t\tqueue.push(DeferredPromise.fromPromise(prom.then(() => test.children)));\n\t\t\t\t} else if (test.children.size) {\n\t\t\t\t\tqueue.push(test.children);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (gather.length) {\n\t\tyield gather;\n\t}\n};\n\n/**\n * Iterator that iterates to the top-level children of tests under the given\n * the URI.\n */\nexport const testsUnderUri = async function* (testService: ITestService, ident: IUriIdentityService, uri: URI, waitForIdle = true): AsyncIterable<IncrementalTestCollectionItem> {\n\n\tconst queue = [testService.collection.rootIds];\n\twhile (queue.length) {\n\t\tfor (const testId of queue.pop()!) {\n\t\t\tconst test = testService.collection.getNodeById(testId);\n\n\t\t\t// Expand tests with URIs that are parent of the item, add tests\n\t\t\t// that are within the URI. Don't add their children, since those\n\t\t\t// tests already encompass their children.\n\t\t\tif (!test) {\n\t\t\t\t// no-op\n\t\t\t} else if (test.item.uri && ident.extUri.isEqualOrParent(test.item.uri, uri)) {\n\t\t\t\tyield test;\n\t\t\t} else if (!test.item.uri || ident.extUri.isEqualOrParent(uri, test.item.uri)) {\n\t\t\t\tif (test.expand === TestItemExpandState.Expandable) {\n\t\t\t\t\tawait testService.collection.expand(test.item.extId, 1);\n\t\t\t\t}\n\t\t\t\tif (waitForIdle) {\n\t\t\t\t\tawait waitForTestToBeIdle(testService, test);\n\t\t\t\t}\n\t\t\t\tqueue.push(test.children.values());\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Simplifies the array of tests by preferring test item parents if all of\n * their children are included.\n */\nexport const simplifyTestsToExecute = (collection: IMainThreadTestCollection, tests: IncrementalTestCollectionItem[]): IncrementalTestCollectionItem[] => {\n\tif (tests.length < 2) {\n\t\treturn tests;\n\t}\n\n\tconst tree = new WellDefinedPrefixTree<IncrementalTestCollectionItem>();\n\tfor (const test of tests) {\n\t\ttree.insert(TestId.fromString(test.item.extId).path, test);\n\t}\n\n\tconst out: IncrementalTestCollectionItem[] = [];\n\n\t// Returns the node if it and any children should be included. Otherwise\n\t// pushes into the `out` any individual children that should be included.\n\tconst process = (currentId: string[], node: IPrefixTreeNode<IncrementalTestCollectionItem>) => {\n\t\t// directly included, don't try to over-specify, and children should be ignored\n\t\tif (node.value) {\n\t\t\treturn node.value;\n\t\t}\n\n\t\tassert(!!node.children, 'expect to have children');\n\n\t\tconst thisChildren: IncrementalTestCollectionItem[] = [];\n\t\tfor (const [part, child] of node.children) {\n\t\t\tcurrentId.push(part);\n\t\t\tconst c = process(currentId, child);\n\t\t\tif (c) { thisChildren.push(c); }\n\t\t\tcurrentId.pop();\n\t\t}\n\n\t\tif (!thisChildren.length) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are multiple children and we have all of them, then tell the\n\t\t// parent this node should be included. Otherwise include children individually.\n\t\tconst id = new TestId(currentId);\n\t\tconst test = collection.getNodeById(id.toString());\n\t\tif (test?.children.size === thisChildren.length) {\n\t\t\treturn test;\n\t\t}\n\n\t\tout.push(...thisChildren);\n\t\treturn;\n\t};\n\n\tfor (const [id, node] of tree.entries) {\n\t\tconst n = process([id], node);\n\t\tif (n) { out.push(n); }\n\t}\n\n\treturn out;\n};\n\n/**\n * A run request that expresses the intent of the request and allows the\n * test service to resolve the specifics of the group.\n */\nexport interface AmbiguousRunTestsRequest {\n\t/** Group to run */\n\tgroup: TestRunProfileBitset;\n\t/** Tests to run. Allowed to be from different controllers */\n\ttests: readonly InternalTestItem[];\n\t/** Tests to exclude. If not given, the current UI excluded tests are used */\n\texclude?: InternalTestItem[];\n\t/** Whether this was triggered from an auto run. */\n\tcontinuous?: boolean;\n\t/** Whether this was trigged by a user action in UI. Default=true */\n\tpreserveFocus?: boolean;\n}\n\nexport interface ITestFollowup {\n\tmessage: string;\n\texecute(): Promise<void>;\n}\n\nexport interface ITestFollowups extends IDisposable {\n\tfollowups: ITestFollowup[];\n}\n\nexport interface ITestService {\n\treadonly _serviceBrand: undefined;\n\t/**\n\t * Fires when the user requests to cancel a test run -- or all runs, if no\n\t * runId is given.\n\t */\n\treadonly onDidCancelTestRun: Event<{ runId: string | undefined; taskId: string | undefined }>;\n\n\t/**\n\t * Event that fires when the excluded tests change.\n\t */\n\treadonly excluded: TestExclusions;\n\n\t/**\n\t * Test collection instance.\n\t */\n\treadonly collection: IMainThreadTestCollection;\n\n\t/**\n\t * Event that fires immediately before a diff is processed.\n\t */\n\treadonly onWillProcessDiff: Event<TestsDiff>;\n\n\t/**\n\t * Event that fires after a diff is processed.\n\t */\n\treadonly onDidProcessDiff: Event<TestsDiff>;\n\n\t/**\n\t * Whether inline editor decorations should be visible.\n\t */\n\treadonly showInlineOutput: MutableObservableValue<boolean>;\n\n\t/**\n\t * Registers an interface that represents an extension host..\n\t */\n\tregisterExtHost(controller: IMainThreadTestHostProxy): IDisposable;\n\n\t/**\n\t * Registers an interface that runs tests for the given provider ID.\n\t */\n\tregisterTestController(providerId: string, controller: IMainThreadTestController): IDisposable;\n\n\t/**\n\t * Gets a registered test controller by ID.\n\t */\n\tgetTestController(controllerId: string): IMainThreadTestController | undefined;\n\n\t/**\n\t * Refreshes tests for the controller, or all controllers if no ID is given.\n\t */\n\trefreshTests(controllerId?: string): Promise<void>;\n\n\t/**\n\t * Cancels any ongoing test refreshes.\n\t */\n\tcancelRefreshTests(): void;\n\n\t/**\n\t * Requests that tests be executed continuously, until the token is cancelled.\n\t */\n\tstartContinuousRun(req: ResolvedTestRunRequest, token: CancellationToken): Promise<void>;\n\n\t/**\n\t * Requests that tests be executed.\n\t */\n\trunTests(req: AmbiguousRunTestsRequest, token?: CancellationToken): Promise<ITestResult>;\n\n\t/**\n\t * Requests that tests be executed.\n\t */\n\trunResolvedTests(req: ResolvedTestRunRequest, token?: CancellationToken): Promise<ITestResult>;\n\n\t/**\n\t * Provides followup actions for a test run.\n\t */\n\tprovideTestFollowups(req: TestMessageFollowupRequest, token: CancellationToken): Promise<ITestFollowups>;\n\n\t/**\n\t * Ensures the test diff from the remote ext host is flushed and waits for\n\t * any \"busy\" tests to become idle before resolving.\n\t */\n\tsyncTests(): Promise<void>;\n\n\t/**\n\t * Cancels an ongoing test run by its ID, or all runs if no ID is given.\n\t */\n\tcancelTestRun(runId?: string, taskId?: string): void;\n\n\t/**\n\t * Publishes a test diff for a controller.\n\t */\n\tpublishDiff(controllerId: string, diff: TestsDiff): void;\n\n\t/**\n\t * Gets all tests related to the given code position.\n\t */\n\tgetTestsRelatedToCode(uri: URI, position: Position, token?: CancellationToken): Promise<InternalTestItem[]>;\n\n\t/**\n\t * Gets code related to the given test item.\n\t */\n\tgetCodeRelatedToTest(test: InternalTestItem, token?: CancellationToken): Promise<Location[]>;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from '../../../../base/common/assert.js';\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { MarshalledId } from '../../../../base/common/marshallingIds.js';\nimport { IObservable } from '../../../../base/common/observable.js';\nimport { IPrefixTreeNode, WellDefinedPrefixTree } from '../../../../base/common/prefixTree.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Position } from '../../../../editor/common/core/position.js';\nimport { Location } from '../../../../editor/common/languages.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { MutableObservableValue } from './observableValue.js';\nimport { TestExclusions } from './testExclusions.js';\nimport { TestId, TestIdPathParts } from './testId.js';\nimport { ITestResult } from './testResult.js';\nimport { AbstractIncrementalTestCollection, ICallProfileRunHandler, IncrementalTestCollectionItem, InternalTestItem, IStartControllerTests, IStartControllerTestsResult, ITestItemContext, ResolvedTestRunRequest, TestControllerCapability, TestItemExpandState, TestMessageFollowupRequest, TestMessageFollowupResponse, TestRunProfileBitset, TestsDiff } from './testTypes.js';\n\nexport const ITestService = createDecorator<ITestService>('testService');\n\nexport interface IMainThreadTestController {\n\treadonly id: string;\n\treadonly label: IObservable<string>;\n\treadonly capabilities: IObservable<TestControllerCapability>;\n\tsyncTests(token: CancellationToken): Promise<void>;\n\trefreshTests(token: CancellationToken): Promise<void>;\n\tconfigureRunProfile(profileId: number): void;\n\texpandTest(id: string, levels: number): Promise<void>;\n\tgetRelatedCode(testId: string, token: CancellationToken): Promise<Location[]>;\n\tstartContinuousRun(request: ICallProfileRunHandler[], token: CancellationToken): Promise<IStartControllerTestsResult[]>;\n\trunTests(request: IStartControllerTests[], token: CancellationToken): Promise<IStartControllerTestsResult[]>;\n}\n\nexport interface IMainThreadTestHostProxy {\n\tprovideTestFollowups(req: TestMessageFollowupRequest, token: CancellationToken): Promise<TestMessageFollowupResponse[]>;\n\tgetTestsRelatedToCode(uri: URI, position: Position, token: CancellationToken): Promise<string[]>;\n\texecuteTestFollowup(id: number): Promise<void>;\n\tdisposeTestFollowups(ids: number[]): void;\n}\n\nexport interface IMainThreadTestCollection extends AbstractIncrementalTestCollection<IncrementalTestCollectionItem> {\n\treadonly onBusyProvidersChange: Event<number>;\n\n\t/**\n\t * Number of providers working to discover tests.\n\t */\n\tbusyProviders: number;\n\n\t/**\n\t * Root item IDs.\n\t */\n\trootIds: Iterable<string>;\n\n\t/**\n\t * Root items, correspond to registered controllers.\n\t */\n\trootItems: Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Iterates over every test in the collection, in strictly descending\n\t * order of depth.\n\t */\n\tall: Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Gets a node in the collection by ID.\n\t */\n\tgetNodeById(id: string): IncrementalTestCollectionItem | undefined;\n\n\t/**\n\t * Gets all tests that have the given URL. Tests returned from this\n\t * method are *not* in any particular order.\n\t */\n\tgetNodeByUrl(uri: URI): Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Requests that children be revealed for the given test. \"Levels\" may\n\t * be infinite.\n\t */\n\texpand(testId: string, levels: number): Promise<void>;\n\n\t/**\n\t * Gets a diff that adds all items currently in the tree to a new collection,\n\t * allowing it to fully hydrate.\n\t */\n\tgetReviverDiff(): TestsDiff;\n}\n\nexport const testCollectionIsEmpty = (collection: IMainThreadTestCollection) =>\n\t!Iterable.some(collection.rootItems, r => r.children.size > 0);\n\nexport const getContextForTestItem = (collection: IMainThreadTestCollection, id: string | TestId) => {\n\tif (typeof id === 'string') {\n\t\tid = TestId.fromString(id);\n\t}\n\n\tif (id.isRoot) {\n\t\treturn { controller: id.toString() };\n\t}\n\n\tconst context: ITestItemContext = { $mid: MarshalledId.TestItemContext, tests: [] };\n\tfor (const i of id.idsFromRoot()) {\n\t\tif (!i.isRoot) {\n\t\t\tconst test = collection.getNodeById(i.toString());\n\t\t\tif (test) {\n\t\t\t\tcontext.tests.push(test);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn context;\n};\n\n/**\n * Ensures the test with the given ID exists in the collection, if possible.\n * If cancellation is requested, or the test cannot be found, it will return\n * undefined.\n */\nexport const expandAndGetTestById = async (collection: IMainThreadTestCollection, id: string, ct = CancellationToken.None) => {\n\tconst idPath = [...TestId.fromString(id).idsFromRoot()];\n\n\tlet expandToLevel = 0;\n\tfor (let i = idPath.length - 1; !ct.isCancellationRequested && i >= expandToLevel;) {\n\t\tconst id = idPath[i].toString();\n\t\tconst existing = collection.getNodeById(id);\n\t\tif (!existing) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i === idPath.length - 1) {\n\t\t\treturn existing;\n\t\t}\n\n\t\t// expand children only if it looks like it's necessary\n\t\tif (!existing.children.has(idPath[i + 1].toString())) {\n\t\t\tawait collection.expand(id, 0);\n\t\t}\n\n\t\texpandToLevel = i + 1; // avoid an infinite loop if the test does not exist\n\t\ti = idPath.length - 1;\n\t}\n\treturn undefined;\n};\n\n/**\n * Waits for the test to no longer be in the \"busy\" state.\n */\nexport const waitForTestToBeIdle = (testService: ITestService, test: IncrementalTestCollectionItem) => {\n\tif (!test.item.busy) {\n\t\treturn;\n\t}\n\n\treturn new Promise<void>(resolve => {\n\t\tconst l = testService.onDidProcessDiff(() => {\n\t\t\tif (testService.collection.getNodeById(test.item.extId)?.item.busy !== true) {\n\t\t\t\tresolve(); // removed, or no longer busy\n\t\t\t\tl.dispose();\n\t\t\t}\n\t\t});\n\t});\n};\n\n/**\n * Iterator that expands to and iterates through tests in the file. Iterates\n * in strictly descending order.\n */\nexport const testsInFile = async function* (testService: ITestService, ident: IUriIdentityService, uri: URI, waitForIdle = true, descendInFile = true): AsyncIterable<readonly IncrementalTestCollectionItem[]> {\n\t// In this function we go to a bit of effort to avoid awaiting unnecessarily\n\t// and bulking the test collections we do collect for consumers. This fixes\n\t// a performance issue (#235819) where a large number of tests in a file\n\t// would cause a long delay switching editors.\n\tconst queue = new LinkedList<Iterable<string> | DeferredPromise<Iterable<string>>>();\n\n\tconst existing = [...testService.collection.getNodeByUrl(uri)].sort((a, b) => a.item.extId.length - b.item.extId.length);\n\n\t// getNodeByUrl will return all known tests in the URI, but this can include\n\t// children of tests even when `descendInFile` is false. Remove those cases.\n\tfor (let i = 0; i < existing.length - 1; i++) {\n\t\tconst prefix = existing[i].item.extId + TestIdPathParts.Delimiter;\n\t\tfor (let k = i + 1; k < existing.length; k++) {\n\t\t\tif (existing[k].item.extId.startsWith(prefix)) {\n\t\t\t\texisting.splice(k--, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue.push(existing.length ? existing.map(e => e.item.extId) : testService.collection.rootIds);\n\n\tlet n = 0;\n\tlet gather: IncrementalTestCollectionItem[] = [];\n\twhile (queue.size > 0) {\n\t\tconst next = queue.pop()!;\n\t\tlet ids: Iterable<string>;\n\t\tif (!(next instanceof DeferredPromise)) {\n\t\t\tids = next;\n\t\t} else if (next.isSettled) {\n\t\t\tids = next.value || Iterable.empty();\n\t\t} else {\n\t\t\tif (gather.length) {\n\t\t\t\tyield gather;\n\t\t\t\tgather = [];\n\t\t\t}\n\t\t\tids = await next.p;\n\t\t}\n\n\t\tfor (const id of ids) {\n\t\t\tn++;\n\t\t\tconst test = testService.collection.getNodeById(id);\n\t\t\tif (!test) {\n\t\t\t\tcontinue; // possible because we expand async and things could delete\n\t\t\t}\n\n\t\t\tif (!test.item.uri) {\n\t\t\t\tqueue.push(test.children);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ident.extUri.isEqual(uri, test.item.uri)) {\n\t\t\t\tgather.push(test);\n\n\t\t\t\tif (!descendInFile) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ident.extUri.isEqualOrParent(uri, test.item.uri)) {\n\t\t\t\tlet prom: Promise<void> | undefined;\n\t\t\t\tif (test.expand === TestItemExpandState.Expandable) {\n\t\t\t\t\tprom = testService.collection.expand(test.item.extId, 1);\n\t\t\t\t}\n\t\t\t\tif (waitForIdle) {\n\t\t\t\t\tif (prom) {\n\t\t\t\t\t\tprom = prom.then(() => waitForTestToBeIdle(testService, test));\n\t\t\t\t\t} else if (test.item.busy) {\n\t\t\t\t\t\tprom = waitForTestToBeIdle(testService, test);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (prom) {\n\t\t\t\t\tqueue.push(DeferredPromise.fromPromise(prom.then(() => test.children)));\n\t\t\t\t} else if (test.children.size) {\n\t\t\t\t\tqueue.push(test.children);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (gather.length) {\n\t\tyield gather;\n\t}\n};\n\n/**\n * Iterator that iterates to the top-level children of tests under the given\n * the URI.\n */\nexport const testsUnderUri = async function* (testService: ITestService, ident: IUriIdentityService, uri: URI, waitForIdle = true): AsyncIterable<IncrementalTestCollectionItem> {\n\n\tconst queue = [testService.collection.rootIds];\n\twhile (queue.length) {\n\t\tfor (const testId of queue.pop()!) {\n\t\t\tconst test = testService.collection.getNodeById(testId);\n\n\t\t\t// Expand tests with URIs that are parent of the item, add tests\n\t\t\t// that are within the URI. Don't add their children, since those\n\t\t\t// tests already encompass their children.\n\t\t\tif (!test) {\n\t\t\t\t// no-op\n\t\t\t} else if (test.item.uri && ident.extUri.isEqualOrParent(test.item.uri, uri)) {\n\t\t\t\tyield test;\n\t\t\t} else if (!test.item.uri || ident.extUri.isEqualOrParent(uri, test.item.uri)) {\n\t\t\t\tif (test.expand === TestItemExpandState.Expandable) {\n\t\t\t\t\tawait testService.collection.expand(test.item.extId, 1);\n\t\t\t\t}\n\t\t\t\tif (waitForIdle) {\n\t\t\t\t\tawait waitForTestToBeIdle(testService, test);\n\t\t\t\t}\n\t\t\t\tqueue.push(test.children.values());\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Simplifies the array of tests by preferring test item parents if all of\n * their children are included.\n */\nexport const simplifyTestsToExecute = (collection: IMainThreadTestCollection, tests: IncrementalTestCollectionItem[]): IncrementalTestCollectionItem[] => {\n\tif (tests.length < 2) {\n\t\treturn tests;\n\t}\n\n\tconst tree = new WellDefinedPrefixTree<IncrementalTestCollectionItem>();\n\tfor (const test of tests) {\n\t\ttree.insert(TestId.fromString(test.item.extId).path, test);\n\t}\n\n\tconst out: IncrementalTestCollectionItem[] = [];\n\n\t// Returns the node if it and any children should be included. Otherwise\n\t// pushes into the `out` any individual children that should be included.\n\tconst process = (currentId: string[], node: IPrefixTreeNode<IncrementalTestCollectionItem>) => {\n\t\t// directly included, don't try to over-specify, and children should be ignored\n\t\tif (node.value) {\n\t\t\treturn node.value;\n\t\t}\n\n\t\tassert(!!node.children, 'expect to have children');\n\n\t\tconst thisChildren: IncrementalTestCollectionItem[] = [];\n\t\tfor (const [part, child] of node.children) {\n\t\t\tcurrentId.push(part);\n\t\t\tconst c = process(currentId, child);\n\t\t\tif (c) { thisChildren.push(c); }\n\t\t\tcurrentId.pop();\n\t\t}\n\n\t\tif (!thisChildren.length) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are multiple children and we have all of them, then tell the\n\t\t// parent this node should be included. Otherwise include children individually.\n\t\tconst id = new TestId(currentId);\n\t\tconst test = collection.getNodeById(id.toString());\n\t\tif (test?.children.size === thisChildren.length) {\n\t\t\treturn test;\n\t\t}\n\n\t\tout.push(...thisChildren);\n\t\treturn;\n\t};\n\n\tfor (const [id, node] of tree.entries) {\n\t\tconst n = process([id], node);\n\t\tif (n) { out.push(n); }\n\t}\n\n\treturn out;\n};\n\n/**\n * A run request that expresses the intent of the request and allows the\n * test service to resolve the specifics of the group.\n */\nexport interface AmbiguousRunTestsRequest {\n\t/** Group to run */\n\tgroup: TestRunProfileBitset;\n\t/** Tests to run. Allowed to be from different controllers */\n\ttests: readonly InternalTestItem[];\n\t/** Tests to exclude. If not given, the current UI excluded tests are used */\n\texclude?: InternalTestItem[];\n\t/** Whether this was triggered from an auto run. */\n\tcontinuous?: boolean;\n\t/** Whether this was trigged by a user action in UI. Default=true */\n\tpreserveFocus?: boolean;\n}\n\nexport interface ITestFollowup {\n\tmessage: string;\n\texecute(): Promise<void>;\n}\n\nexport interface ITestFollowups extends IDisposable {\n\tfollowups: ITestFollowup[];\n}\n\nexport interface ITestService {\n\treadonly _serviceBrand: undefined;\n\t/**\n\t * Fires when the user requests to cancel a test run -- or all runs, if no\n\t * runId is given.\n\t */\n\treadonly onDidCancelTestRun: Event<{ runId: string | undefined; taskId: string | undefined }>;\n\n\t/**\n\t * Event that fires when the excluded tests change.\n\t */\n\treadonly excluded: TestExclusions;\n\n\t/**\n\t * Test collection instance.\n\t */\n\treadonly collection: IMainThreadTestCollection;\n\n\t/**\n\t * Event that fires immediately before a diff is processed.\n\t */\n\treadonly onWillProcessDiff: Event<TestsDiff>;\n\n\t/**\n\t * Event that fires after a diff is processed.\n\t */\n\treadonly onDidProcessDiff: Event<TestsDiff>;\n\n\t/**\n\t * Whether inline editor decorations should be visible.\n\t */\n\treadonly showInlineOutput: MutableObservableValue<boolean>;\n\n\t/**\n\t * Registers an interface that represents an extension host..\n\t */\n\tregisterExtHost(controller: IMainThreadTestHostProxy): IDisposable;\n\n\t/**\n\t * Registers an interface that runs tests for the given provider ID.\n\t */\n\tregisterTestController(providerId: string, controller: IMainThreadTestController): IDisposable;\n\n\t/**\n\t * Gets a registered test controller by ID.\n\t */\n\tgetTestController(controllerId: string): IMainThreadTestController | undefined;\n\n\t/**\n\t * Refreshes tests for the controller, or all controllers if no ID is given.\n\t */\n\trefreshTests(controllerId?: string): Promise<void>;\n\n\t/**\n\t * Cancels any ongoing test refreshes.\n\t */\n\tcancelRefreshTests(): void;\n\n\t/**\n\t * Requests that tests be executed continuously, until the token is cancelled.\n\t */\n\tstartContinuousRun(req: ResolvedTestRunRequest, token: CancellationToken): Promise<void>;\n\n\t/**\n\t * Requests that tests be executed.\n\t */\n\trunTests(req: AmbiguousRunTestsRequest, token?: CancellationToken): Promise<ITestResult>;\n\n\t/**\n\t * Requests that tests be executed.\n\t */\n\trunResolvedTests(req: ResolvedTestRunRequest, token?: CancellationToken): Promise<ITestResult>;\n\n\t/**\n\t * Provides followup actions for a test run.\n\t */\n\tprovideTestFollowups(req: TestMessageFollowupRequest, token: CancellationToken): Promise<ITestFollowups>;\n\n\t/**\n\t * Ensures the test diff from the remote ext host is flushed and waits for\n\t * any \"busy\" tests to become idle before resolving.\n\t */\n\tsyncTests(): Promise<void>;\n\n\t/**\n\t * Cancels an ongoing test run by its ID, or all runs if no ID is given.\n\t */\n\tcancelTestRun(runId?: string, taskId?: string): void;\n\n\t/**\n\t * Publishes a test diff for a controller.\n\t */\n\tpublishDiff(controllerId: string, diff: TestsDiff): void;\n\n\t/**\n\t * Gets all tests related to the given code position.\n\t */\n\tgetTestsRelatedToCode(uri: URI, position: Position, token?: CancellationToken): Promise<InternalTestItem[]>;\n\n\t/**\n\t * Gets code related to the given test item.\n\t */\n\tgetCodeRelatedToTest(test: InternalTestItem, token?: CancellationToken): Promise<Location[]>;\n}\n"]}