{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/browser/explorerProjections/treeProjection.ts","vs/workbench/contrib/testing/browser/explorerProjections/treeProjection.ts"],"names":[],"mappings":"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","file":"treeProjection.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ObjectTree } from '../../../../../base/browser/ui/tree/objectTree.js';\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { FuzzyScore } from '../../../../../base/common/filters.js';\nimport { Iterable } from '../../../../../base/common/iterator.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { ITestTreeProjection, TestExplorerTreeElement, TestItemTreeElement, TestTreeErrorMessage, getChildrenForParent, testIdentityProvider } from './index.js';\nimport { ISerializedTestTreeCollapseState, isCollapsedInSerializedTestTree } from './testingViewState.js';\nimport { IComputedStateAndDurationAccessor, refreshComputedState } from '../../common/getComputedState.js';\nimport { TestId } from '../../common/testId.js';\nimport { TestResultItemChangeReason } from '../../common/testResult.js';\nimport { ITestResultService } from '../../common/testResultService.js';\nimport { ITestService } from '../../common/testService.js';\nimport { ITestItemUpdate, InternalTestItem, TestDiffOpType, TestItemExpandState, TestResultState, TestsDiff, applyTestItemUpdate } from '../../common/testTypes.js';\n\nconst computedStateAccessor: IComputedStateAndDurationAccessor<TreeTestItemElement> = {\n\tgetOwnState: i => i instanceof TestItemTreeElement ? i.ownState : TestResultState.Unset,\n\tgetCurrentComputedState: i => i.state,\n\tsetComputedState: (i, s) => i.state = s,\n\n\tgetCurrentComputedDuration: i => i.duration,\n\tgetOwnDuration: i => i instanceof TestItemTreeElement ? i.ownDuration : undefined,\n\tsetComputedDuration: (i, d) => i.duration = d,\n\n\tgetChildren: i => Iterable.filter(\n\t\ti.children.values(),\n\t\t(t): t is TreeTestItemElement => t instanceof TreeTestItemElement,\n\t),\n\t*getParents(i) {\n\t\tfor (let parent = i.parent; parent; parent = parent.parent) {\n\t\t\tyield parent as TreeTestItemElement;\n\t\t}\n\t},\n};\n\n/**\n * Test tree element element that groups be hierarchy.\n */\nclass TreeTestItemElement extends TestItemTreeElement {\n\t/**\n\t * Own, non-computed state.\n\t * @internal\n\t */\n\tpublic ownState = TestResultState.Unset;\n\n\t/**\n\t * Own, non-computed duration.\n\t * @internal\n\t */\n\tpublic ownDuration: number | undefined;\n\n\tpublic override get description() {\n\t\treturn this.test.item.description;\n\t}\n\n\tprivate errorChild?: TestTreeErrorMessage;\n\n\tconstructor(\n\t\ttest: InternalTestItem,\n\t\tparent: null | TreeTestItemElement,\n\t\tprotected readonly addedOrRemoved: (n: TestItemTreeElement) => void,\n\t) {\n\t\tsuper({ ...test, item: { ...test.item } }, parent);\n\t\tthis.updateErrorVisibility();\n\t}\n\n\tpublic update(patch: ITestItemUpdate) {\n\t\tapplyTestItemUpdate(this.test, patch);\n\t\tthis.updateErrorVisibility(patch);\n\t\tthis.fireChange();\n\t}\n\n\tpublic fireChange() {\n\t\tthis.changeEmitter.fire();\n\t}\n\n\tprivate updateErrorVisibility(patch?: ITestItemUpdate) {\n\t\tif (this.errorChild && (!this.test.item.error || patch?.item?.error)) {\n\t\t\tthis.addedOrRemoved(this);\n\t\t\tthis.children.delete(this.errorChild);\n\t\t\tthis.errorChild = undefined;\n\t\t}\n\t\tif (this.test.item.error && !this.errorChild) {\n\t\t\tthis.errorChild = new TestTreeErrorMessage(this.test.item.error, this);\n\t\t\tthis.children.add(this.errorChild);\n\t\t\tthis.addedOrRemoved(this);\n\t\t}\n\t}\n}\n\n/**\n * Projection that lists tests in their traditional tree view.\n */\nexport class TreeProjection extends Disposable implements ITestTreeProjection {\n\tprivate readonly updateEmitter = new Emitter<void>();\n\n\tprivate readonly changedParents = new Set<TestItemTreeElement | null>();\n\tprivate readonly resortedParents = new Set<TestItemTreeElement | null>();\n\n\tprivate readonly items = new Map<string, TreeTestItemElement>();\n\n\t/**\n\t * Gets root elements of the tree.\n\t */\n\tprivate get rootsWithChildren(): Iterable<TreeTestItemElement> {\n\t\tconst rootsIt = Iterable.map(this.testService.collection.rootItems, r => this.items.get(r.item.extId));\n\t\treturn Iterable.filter(rootsIt, (r): r is TreeTestItemElement => !!r?.children.size);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly onUpdate = this.updateEmitter.event;\n\n\tconstructor(\n\t\tpublic lastState: ISerializedTestTreeCollapseState,\n\t\t@ITestService private readonly testService: ITestService,\n\t\t@ITestResultService private readonly results: ITestResultService,\n\t) {\n\t\tsuper();\n\t\tthis._register(testService.onDidProcessDiff((diff) => this.applyDiff(diff)));\n\n\t\t// when test results are cleared, recalculate all state\n\t\tthis._register(results.onResultsChanged((evt) => {\n\t\t\tif (!('removed' in evt)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (const inTree of [...this.items.values()].sort((a, b) => b.depth - a.depth)) {\n\t\t\t\tconst lookup = this.results.getStateById(inTree.test.item.extId)?.[1];\n\t\t\t\tinTree.ownDuration = lookup?.ownDuration;\n\t\t\t\trefreshComputedState(computedStateAccessor, inTree, lookup?.ownComputedState ?? TestResultState.Unset).forEach(i => i.fireChange());\n\t\t\t}\n\t\t}));\n\n\t\t// when test states change, reflect in the tree\n\t\tthis._register(results.onTestChanged(ev => {\n\t\t\tif (ev.reason === TestResultItemChangeReason.NewMessage) {\n\t\t\t\treturn; // no effect in the tree\n\t\t\t}\n\n\t\t\tlet result = ev.item;\n\t\t\t// if the state is unset, or the latest run is not making the change,\n\t\t\t// double check that it's valid. Retire calls might cause previous\n\t\t\t// emit a state change for a test run that's already long completed.\n\t\t\tif (result.ownComputedState === TestResultState.Unset || ev.result !== results.results[0]) {\n\t\t\t\tconst fallback = results.getStateById(result.item.extId);\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresult = fallback[1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst item = this.items.get(result.item.extId);\n\t\t\tif (!item) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Skip refreshing the duration if we can trivially tell it didn't change.\n\t\t\tconst refreshDuration = ev.reason === TestResultItemChangeReason.OwnStateChange && ev.previousOwnDuration !== result.ownDuration;\n\t\t\t// For items without children, always use the computed state. They are\n\t\t\t// either leaves (for which it's fine) or nodes where we haven't expanded\n\t\t\t// children and should trust whatever the result service gives us.\n\t\t\tconst explicitComputed = item.children.size ? undefined : result.computedState;\n\n\t\t\titem.retired = !!result.retired;\n\t\t\titem.ownState = result.ownComputedState;\n\t\t\titem.ownDuration = result.ownDuration;\n\t\t\titem.fireChange();\n\n\t\t\trefreshComputedState(computedStateAccessor, item, explicitComputed, refreshDuration).forEach(i => i.fireChange());\n\t\t}));\n\n\t\tfor (const test of testService.collection.all) {\n\t\t\tthis.storeItem(this.createItem(test));\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getElementByTestId(testId: string): TestItemTreeElement | undefined {\n\t\treturn this.items.get(testId);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tprivate applyDiff(diff: TestsDiff) {\n\t\tfor (const op of diff) {\n\t\t\tswitch (op.op) {\n\t\t\t\tcase TestDiffOpType.Add: {\n\t\t\t\t\tconst item = this.createItem(op.item);\n\t\t\t\t\tthis.storeItem(item);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase TestDiffOpType.Update: {\n\t\t\t\t\tconst patch = op.item;\n\t\t\t\t\tconst existing = this.items.get(patch.extId);\n\t\t\t\t\tif (!existing) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// parent needs to be re-rendered on an expand update, so that its\n\t\t\t\t\t// children are rewritten.\n\t\t\t\t\tconst needsParentUpdate = existing.test.expand === TestItemExpandState.NotExpandable && patch.expand;\n\t\t\t\t\texisting.update(patch);\n\t\t\t\t\tif (needsParentUpdate) {\n\t\t\t\t\t\tthis.changedParents.add(existing.parent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.resortedParents.add(existing.parent);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase TestDiffOpType.Remove: {\n\t\t\t\t\tconst toRemove = this.items.get(op.itemId);\n\t\t\t\t\tif (!toRemove) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Removing the first element will cause the root to be hidden.\n\t\t\t\t\t// Changing first-level elements will need the root to re-render if\n\t\t\t\t\t// there are no other controllers with items.\n\t\t\t\t\tconst parent = toRemove.parent;\n\t\t\t\t\tconst affectsRootElement = toRemove.depth === 1 && (parent?.children.size === 1 || !Iterable.some(this.rootsWithChildren, (_, i) => i === 1));\n\t\t\t\t\tthis.changedParents.add(affectsRootElement ? null : parent);\n\n\t\t\t\t\tconst queue: Iterable<TestExplorerTreeElement>[] = [[toRemove]];\n\t\t\t\t\twhile (queue.length) {\n\t\t\t\t\t\tfor (const item of queue.pop()!) {\n\t\t\t\t\t\t\tif (item instanceof TreeTestItemElement) {\n\t\t\t\t\t\t\t\tqueue.push(this.unstoreItem(item));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parent instanceof TreeTestItemElement) {\n\t\t\t\t\t\trefreshComputedState(computedStateAccessor, parent, undefined, !!parent.duration).forEach(i => i.fireChange());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (diff.length !== 0) {\n\t\t\tthis.updateEmitter.fire();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic applyTo(tree: ObjectTree<TestExplorerTreeElement, FuzzyScore>) {\n\t\tfor (const parent of this.changedParents) {\n\t\t\tif (!parent || tree.hasElement(parent)) {\n\t\t\t\ttree.setChildren(parent, getChildrenForParent(this.lastState, this.rootsWithChildren, parent), { diffIdentityProvider: testIdentityProvider });\n\t\t\t}\n\t\t}\n\n\t\tfor (const parent of this.resortedParents) {\n\t\t\tif (!parent || tree.hasElement(parent)) {\n\t\t\t\ttree.resort(parent, false);\n\t\t\t}\n\t\t}\n\n\t\tthis.changedParents.clear();\n\t\tthis.resortedParents.clear();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic expandElement(element: TestItemTreeElement, depth: number): void {\n\t\tif (!(element instanceof TreeTestItemElement)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (element.test.expand === TestItemExpandState.NotExpandable) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.testService.collection.expand(element.test.item.extId, depth);\n\t}\n\n\tprivate createItem(item: InternalTestItem): TreeTestItemElement {\n\t\tconst parentId = TestId.parentId(item.item.extId);\n\t\tconst parent = parentId ? this.items.get(parentId)! : null;\n\t\treturn new TreeTestItemElement(item, parent, n => this.changedParents.add(n));\n\t}\n\n\tprivate unstoreItem(treeElement: TreeTestItemElement) {\n\t\tconst parent = treeElement.parent;\n\t\tparent?.children.delete(treeElement);\n\t\tthis.items.delete(treeElement.test.item.extId);\n\t\treturn treeElement.children;\n\t}\n\n\tprivate storeItem(treeElement: TreeTestItemElement) {\n\t\ttreeElement.parent?.children.add(treeElement);\n\t\tthis.items.set(treeElement.test.item.extId, treeElement);\n\n\t\t// The first element will cause the root to be shown. The first element of\n\t\t// a parent may need to re-render it for #204805.\n\t\tconst affectsParent = treeElement.parent?.children.size === 1;\n\t\tconst affectedParent = affectsParent ? treeElement.parent.parent : treeElement.parent;\n\t\tthis.changedParents.add(affectedParent);\n\t\tif (affectedParent?.depth === 0) {\n\t\t\tthis.changedParents.add(null);\n\t\t}\n\n\t\tif (treeElement.depth === 0 || isCollapsedInSerializedTestTree(this.lastState, treeElement.test.item.extId) === false) {\n\t\t\tthis.expandElement(treeElement, 0);\n\t\t}\n\n\t\tconst prevState = this.results.getStateById(treeElement.test.item.extId)?.[1];\n\t\tif (prevState) {\n\t\t\ttreeElement.retired = !!prevState.retired;\n\t\t\ttreeElement.ownState = prevState.computedState;\n\t\t\ttreeElement.ownDuration = prevState.ownDuration;\n\n\t\t\trefreshComputedState(computedStateAccessor, treeElement, undefined, !!treeElement.ownDuration).forEach(i => i.fireChange());\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ObjectTree } from '../../../../../base/browser/ui/tree/objectTree.js';\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { FuzzyScore } from '../../../../../base/common/filters.js';\nimport { Iterable } from '../../../../../base/common/iterator.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { ITestTreeProjection, TestExplorerTreeElement, TestItemTreeElement, TestTreeErrorMessage, getChildrenForParent, testIdentityProvider } from './index.js';\nimport { ISerializedTestTreeCollapseState, isCollapsedInSerializedTestTree } from './testingViewState.js';\nimport { IComputedStateAndDurationAccessor, refreshComputedState } from '../../common/getComputedState.js';\nimport { TestId } from '../../common/testId.js';\nimport { TestResultItemChangeReason } from '../../common/testResult.js';\nimport { ITestResultService } from '../../common/testResultService.js';\nimport { ITestService } from '../../common/testService.js';\nimport { ITestItemUpdate, InternalTestItem, TestDiffOpType, TestItemExpandState, TestResultState, TestsDiff, applyTestItemUpdate } from '../../common/testTypes.js';\n\nconst computedStateAccessor: IComputedStateAndDurationAccessor<TreeTestItemElement> = {\n\tgetOwnState: i => i instanceof TestItemTreeElement ? i.ownState : TestResultState.Unset,\n\tgetCurrentComputedState: i => i.state,\n\tsetComputedState: (i, s) => i.state = s,\n\n\tgetCurrentComputedDuration: i => i.duration,\n\tgetOwnDuration: i => i instanceof TestItemTreeElement ? i.ownDuration : undefined,\n\tsetComputedDuration: (i, d) => i.duration = d,\n\n\tgetChildren: i => Iterable.filter(\n\t\ti.children.values(),\n\t\t(t): t is TreeTestItemElement => t instanceof TreeTestItemElement,\n\t),\n\t*getParents(i) {\n\t\tfor (let parent = i.parent; parent; parent = parent.parent) {\n\t\t\tyield parent as TreeTestItemElement;\n\t\t}\n\t},\n};\n\n/**\n * Test tree element element that groups be hierarchy.\n */\nclass TreeTestItemElement extends TestItemTreeElement {\n\t/**\n\t * Own, non-computed state.\n\t * @internal\n\t */\n\tpublic ownState = TestResultState.Unset;\n\n\t/**\n\t * Own, non-computed duration.\n\t * @internal\n\t */\n\tpublic ownDuration: number | undefined;\n\n\tpublic override get description() {\n\t\treturn this.test.item.description;\n\t}\n\n\tprivate errorChild?: TestTreeErrorMessage;\n\n\tconstructor(\n\t\ttest: InternalTestItem,\n\t\tparent: null | TreeTestItemElement,\n\t\tprotected readonly addedOrRemoved: (n: TestItemTreeElement) => void,\n\t) {\n\t\tsuper({ ...test, item: { ...test.item } }, parent);\n\t\tthis.updateErrorVisibility();\n\t}\n\n\tpublic update(patch: ITestItemUpdate) {\n\t\tapplyTestItemUpdate(this.test, patch);\n\t\tthis.updateErrorVisibility(patch);\n\t\tthis.fireChange();\n\t}\n\n\tpublic fireChange() {\n\t\tthis.changeEmitter.fire();\n\t}\n\n\tprivate updateErrorVisibility(patch?: ITestItemUpdate) {\n\t\tif (this.errorChild && (!this.test.item.error || patch?.item?.error)) {\n\t\t\tthis.addedOrRemoved(this);\n\t\t\tthis.children.delete(this.errorChild);\n\t\t\tthis.errorChild = undefined;\n\t\t}\n\t\tif (this.test.item.error && !this.errorChild) {\n\t\t\tthis.errorChild = new TestTreeErrorMessage(this.test.item.error, this);\n\t\t\tthis.children.add(this.errorChild);\n\t\t\tthis.addedOrRemoved(this);\n\t\t}\n\t}\n}\n\n/**\n * Projection that lists tests in their traditional tree view.\n */\nexport class TreeProjection extends Disposable implements ITestTreeProjection {\n\tprivate readonly updateEmitter = new Emitter<void>();\n\n\tprivate readonly changedParents = new Set<TestItemTreeElement | null>();\n\tprivate readonly resortedParents = new Set<TestItemTreeElement | null>();\n\n\tprivate readonly items = new Map<string, TreeTestItemElement>();\n\n\t/**\n\t * Gets root elements of the tree.\n\t */\n\tprivate get rootsWithChildren(): Iterable<TreeTestItemElement> {\n\t\tconst rootsIt = Iterable.map(this.testService.collection.rootItems, r => this.items.get(r.item.extId));\n\t\treturn Iterable.filter(rootsIt, (r): r is TreeTestItemElement => !!r?.children.size);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly onUpdate = this.updateEmitter.event;\n\n\tconstructor(\n\t\tpublic lastState: ISerializedTestTreeCollapseState,\n\t\t@ITestService private readonly testService: ITestService,\n\t\t@ITestResultService private readonly results: ITestResultService,\n\t) {\n\t\tsuper();\n\t\tthis._register(testService.onDidProcessDiff((diff) => this.applyDiff(diff)));\n\n\t\t// when test results are cleared, recalculate all state\n\t\tthis._register(results.onResultsChanged((evt) => {\n\t\t\tif (!('removed' in evt)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (const inTree of [...this.items.values()].sort((a, b) => b.depth - a.depth)) {\n\t\t\t\tconst lookup = this.results.getStateById(inTree.test.item.extId)?.[1];\n\t\t\t\tinTree.ownDuration = lookup?.ownDuration;\n\t\t\t\trefreshComputedState(computedStateAccessor, inTree, lookup?.ownComputedState ?? TestResultState.Unset).forEach(i => i.fireChange());\n\t\t\t}\n\t\t}));\n\n\t\t// when test states change, reflect in the tree\n\t\tthis._register(results.onTestChanged(ev => {\n\t\t\tif (ev.reason === TestResultItemChangeReason.NewMessage) {\n\t\t\t\treturn; // no effect in the tree\n\t\t\t}\n\n\t\t\tlet result = ev.item;\n\t\t\t// if the state is unset, or the latest run is not making the change,\n\t\t\t// double check that it's valid. Retire calls might cause previous\n\t\t\t// emit a state change for a test run that's already long completed.\n\t\t\tif (result.ownComputedState === TestResultState.Unset || ev.result !== results.results[0]) {\n\t\t\t\tconst fallback = results.getStateById(result.item.extId);\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresult = fallback[1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst item = this.items.get(result.item.extId);\n\t\t\tif (!item) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Skip refreshing the duration if we can trivially tell it didn't change.\n\t\t\tconst refreshDuration = ev.reason === TestResultItemChangeReason.OwnStateChange && ev.previousOwnDuration !== result.ownDuration;\n\t\t\t// For items without children, always use the computed state. They are\n\t\t\t// either leaves (for which it's fine) or nodes where we haven't expanded\n\t\t\t// children and should trust whatever the result service gives us.\n\t\t\tconst explicitComputed = item.children.size ? undefined : result.computedState;\n\n\t\t\titem.retired = !!result.retired;\n\t\t\titem.ownState = result.ownComputedState;\n\t\t\titem.ownDuration = result.ownDuration;\n\t\t\titem.fireChange();\n\n\t\t\trefreshComputedState(computedStateAccessor, item, explicitComputed, refreshDuration).forEach(i => i.fireChange());\n\t\t}));\n\n\t\tfor (const test of testService.collection.all) {\n\t\t\tthis.storeItem(this.createItem(test));\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getElementByTestId(testId: string): TestItemTreeElement | undefined {\n\t\treturn this.items.get(testId);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tprivate applyDiff(diff: TestsDiff) {\n\t\tfor (const op of diff) {\n\t\t\tswitch (op.op) {\n\t\t\t\tcase TestDiffOpType.Add: {\n\t\t\t\t\tconst item = this.createItem(op.item);\n\t\t\t\t\tthis.storeItem(item);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase TestDiffOpType.Update: {\n\t\t\t\t\tconst patch = op.item;\n\t\t\t\t\tconst existing = this.items.get(patch.extId);\n\t\t\t\t\tif (!existing) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// parent needs to be re-rendered on an expand update, so that its\n\t\t\t\t\t// children are rewritten.\n\t\t\t\t\tconst needsParentUpdate = existing.test.expand === TestItemExpandState.NotExpandable && patch.expand;\n\t\t\t\t\texisting.update(patch);\n\t\t\t\t\tif (needsParentUpdate) {\n\t\t\t\t\t\tthis.changedParents.add(existing.parent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.resortedParents.add(existing.parent);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase TestDiffOpType.Remove: {\n\t\t\t\t\tconst toRemove = this.items.get(op.itemId);\n\t\t\t\t\tif (!toRemove) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Removing the first element will cause the root to be hidden.\n\t\t\t\t\t// Changing first-level elements will need the root to re-render if\n\t\t\t\t\t// there are no other controllers with items.\n\t\t\t\t\tconst parent = toRemove.parent;\n\t\t\t\t\tconst affectsRootElement = toRemove.depth === 1 && (parent?.children.size === 1 || !Iterable.some(this.rootsWithChildren, (_, i) => i === 1));\n\t\t\t\t\tthis.changedParents.add(affectsRootElement ? null : parent);\n\n\t\t\t\t\tconst queue: Iterable<TestExplorerTreeElement>[] = [[toRemove]];\n\t\t\t\t\twhile (queue.length) {\n\t\t\t\t\t\tfor (const item of queue.pop()!) {\n\t\t\t\t\t\t\tif (item instanceof TreeTestItemElement) {\n\t\t\t\t\t\t\t\tqueue.push(this.unstoreItem(item));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parent instanceof TreeTestItemElement) {\n\t\t\t\t\t\trefreshComputedState(computedStateAccessor, parent, undefined, !!parent.duration).forEach(i => i.fireChange());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (diff.length !== 0) {\n\t\t\tthis.updateEmitter.fire();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic applyTo(tree: ObjectTree<TestExplorerTreeElement, FuzzyScore>) {\n\t\tfor (const parent of this.changedParents) {\n\t\t\tif (!parent || tree.hasElement(parent)) {\n\t\t\t\ttree.setChildren(parent, getChildrenForParent(this.lastState, this.rootsWithChildren, parent), { diffIdentityProvider: testIdentityProvider });\n\t\t\t}\n\t\t}\n\n\t\tfor (const parent of this.resortedParents) {\n\t\t\tif (!parent || tree.hasElement(parent)) {\n\t\t\t\ttree.resort(parent, false);\n\t\t\t}\n\t\t}\n\n\t\tthis.changedParents.clear();\n\t\tthis.resortedParents.clear();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic expandElement(element: TestItemTreeElement, depth: number): void {\n\t\tif (!(element instanceof TreeTestItemElement)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (element.test.expand === TestItemExpandState.NotExpandable) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.testService.collection.expand(element.test.item.extId, depth);\n\t}\n\n\tprivate createItem(item: InternalTestItem): TreeTestItemElement {\n\t\tconst parentId = TestId.parentId(item.item.extId);\n\t\tconst parent = parentId ? this.items.get(parentId)! : null;\n\t\treturn new TreeTestItemElement(item, parent, n => this.changedParents.add(n));\n\t}\n\n\tprivate unstoreItem(treeElement: TreeTestItemElement) {\n\t\tconst parent = treeElement.parent;\n\t\tparent?.children.delete(treeElement);\n\t\tthis.items.delete(treeElement.test.item.extId);\n\t\treturn treeElement.children;\n\t}\n\n\tprivate storeItem(treeElement: TreeTestItemElement) {\n\t\ttreeElement.parent?.children.add(treeElement);\n\t\tthis.items.set(treeElement.test.item.extId, treeElement);\n\n\t\t// The first element will cause the root to be shown. The first element of\n\t\t// a parent may need to re-render it for #204805.\n\t\tconst affectsParent = treeElement.parent?.children.size === 1;\n\t\tconst affectedParent = affectsParent ? treeElement.parent.parent : treeElement.parent;\n\t\tthis.changedParents.add(affectedParent);\n\t\tif (affectedParent?.depth === 0) {\n\t\t\tthis.changedParents.add(null);\n\t\t}\n\n\t\tif (treeElement.depth === 0 || isCollapsedInSerializedTestTree(this.lastState, treeElement.test.item.extId) === false) {\n\t\t\tthis.expandElement(treeElement, 0);\n\t\t}\n\n\t\tconst prevState = this.results.getStateById(treeElement.test.item.extId)?.[1];\n\t\tif (prevState) {\n\t\t\ttreeElement.retired = !!prevState.retired;\n\t\t\ttreeElement.ownState = prevState.computedState;\n\t\t\ttreeElement.ownDuration = prevState.ownDuration;\n\n\t\t\trefreshComputedState(computedStateAccessor, treeElement, undefined, !!treeElement.ownDuration).forEach(i => i.fireChange());\n\t\t}\n\t}\n}\n"]}