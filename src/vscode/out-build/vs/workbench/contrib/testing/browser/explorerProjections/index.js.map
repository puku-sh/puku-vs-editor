{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/testing/browser/explorerProjections/index.ts","vs/workbench/contrib/testing/browser/explorerProjections/index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IIdentityProvider } from '../../../../../base/browser/ui/list/list.js';\nimport { ObjectTree } from '../../../../../base/browser/ui/tree/objectTree.js';\nimport { IObjectTreeElement, ObjectTreeElementCollapseState } from '../../../../../base/browser/ui/tree/tree.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { FuzzyScore } from '../../../../../base/common/filters.js';\nimport { IMarkdownString } from '../../../../../base/common/htmlContent.js';\nimport { Iterable } from '../../../../../base/common/iterator.js';\nimport { IDisposable } from '../../../../../base/common/lifecycle.js';\nimport { MarshalledId } from '../../../../../base/common/marshallingIds.js';\nimport { ISerializedTestTreeCollapseState, isCollapsedInSerializedTestTree } from './testingViewState.js';\nimport { ITestItemContext, InternalTestItem, TestItemExpandState, TestResultState } from '../../common/testTypes.js';\n\n/**\n * Describes a rendering of tests in the explorer view. Different\n * implementations of this are used for trees and lists, and groupings.\n * Originally this was implemented as inline logic within the ViewModel and\n * using a single IncrementalTestChangeCollector, but this became hairy\n * with status projections.\n */\nexport interface ITestTreeProjection extends IDisposable {\n\t/**\n\t * Event that fires when the projection changes.\n\t */\n\treadonly onUpdate: Event<void>;\n\n\t/**\n\t * State to use for applying default collapse state of items.\n\t */\n\tlastState: ISerializedTestTreeCollapseState;\n\n\t/**\n\t * Fired when an element in the tree is expanded.\n\t */\n\texpandElement(element: TestItemTreeElement, depth: number): void;\n\n\t/**\n\t * Gets an element by its extension-assigned ID.\n\t */\n\tgetElementByTestId(testId: string): TestItemTreeElement | undefined;\n\n\t/**\n\t * Applies pending update to the tree.\n\t */\n\tapplyTo(tree: ObjectTree<TestExplorerTreeElement, FuzzyScore>): void;\n}\n\nlet idCounter = 0;\n\nconst getId = () => String(idCounter++);\n\nexport abstract class TestItemTreeElement {\n\tprotected readonly changeEmitter = new Emitter<void>();\n\n\t/**\n\t * Fired whenever the element or test properties change.\n\t */\n\tpublic readonly onChange = this.changeEmitter.event;\n\n\t/**\n\t * Tree children of this item.\n\t */\n\tpublic readonly children = new Set<TestExplorerTreeElement>();\n\n\t/**\n\t * Unique ID of the element in the tree.\n\t */\n\tpublic readonly treeId = getId();\n\n\t/**\n\t * Depth of the element in the tree.\n\t */\n\tpublic depth: number;\n\n\t/**\n\t * Whether the node's test result is 'retired' -- from an outdated test run.\n\t */\n\tpublic retired = false;\n\n\t/**\n\t * State to show on the item. This is generally the item's computed state\n\t * from its children.\n\t */\n\tpublic state = TestResultState.Unset;\n\n\t/**\n\t * Time it took this test/item to run.\n\t */\n\tpublic duration: number | undefined;\n\n\t/**\n\t * Tree element description.\n\t */\n\tpublic abstract description: string | null;\n\n\tconstructor(\n\t\tpublic readonly test: InternalTestItem,\n\t\t/**\n\t\t * Parent tree item. May not actually be the test item who owns this one\n\t\t * in a 'flat' projection.\n\t\t */\n\t\tpublic readonly parent: TestItemTreeElement | null = null,\n\t) {\n\t\tthis.depth = parent ? parent.depth + 1 : 0;\n\t}\n\n\tpublic toJSON() {\n\t\tif (this.depth === 0) {\n\t\t\treturn { controllerId: this.test.controllerId };\n\t\t}\n\n\t\tconst context: ITestItemContext = {\n\t\t\t$mid: MarshalledId.TestItemContext,\n\t\t\ttests: [InternalTestItem.serialize(this.test)],\n\t\t};\n\n\t\tfor (let p = this.parent; p && p.depth > 0; p = p.parent) {\n\t\t\tcontext.tests.unshift(InternalTestItem.serialize(p.test));\n\t\t}\n\n\t\treturn context;\n\t}\n}\n\nexport class TestTreeErrorMessage {\n\tpublic readonly treeId = getId();\n\tpublic readonly children = new Set<never>();\n\n\tpublic get description() {\n\t\treturn typeof this.message === 'string' ? this.message : this.message.value;\n\t}\n\n\tconstructor(\n\t\tpublic readonly message: string | IMarkdownString,\n\t\tpublic readonly parent: TestExplorerTreeElement,\n\t) { }\n}\n\nexport type TestExplorerTreeElement = TestItemTreeElement | TestTreeErrorMessage;\n\nexport const testIdentityProvider: IIdentityProvider<TestExplorerTreeElement> = {\n\tgetId(element) {\n\t\t// For \"not expandable\" elements, whether they have children is part of the\n\t\t// ID so they're rerendered if that changes (#204805)\n\t\tconst expandComponent = element instanceof TestTreeErrorMessage\n\t\t\t? 'error'\n\t\t\t: element.test.expand === TestItemExpandState.NotExpandable\n\t\t\t\t? !!element.children.size\n\t\t\t\t: element.test.expand;\n\n\t\treturn element.treeId + '\\0' + expandComponent;\n\t}\n};\n\nexport const getChildrenForParent = (serialized: ISerializedTestTreeCollapseState, rootsWithChildren: Iterable<TestExplorerTreeElement>, node: TestExplorerTreeElement | null): Iterable<IObjectTreeElement<TestExplorerTreeElement>> => {\n\tlet it: Iterable<TestExplorerTreeElement>;\n\tif (node === null) { // roots\n\t\tconst rootsWithChildrenArr = [...rootsWithChildren];\n\t\tif (rootsWithChildrenArr.length === 1) {\n\t\t\treturn getChildrenForParent(serialized, rootsWithChildrenArr, rootsWithChildrenArr[0]);\n\t\t}\n\t\tit = rootsWithChildrenArr;\n\t} else {\n\t\tit = node.children;\n\t}\n\n\treturn Iterable.map(it, element => (\n\t\telement instanceof TestTreeErrorMessage\n\t\t\t? { element }\n\t\t\t: {\n\t\t\t\telement,\n\t\t\t\tcollapsible: element.test.expand !== TestItemExpandState.NotExpandable,\n\t\t\t\tcollapsed: element.test.item.error\n\t\t\t\t\t? ObjectTreeElementCollapseState.PreserveOrExpanded\n\t\t\t\t\t: (isCollapsedInSerializedTestTree(serialized, element.test.item.extId) ?? element.depth > 0\n\t\t\t\t\t\t? ObjectTreeElementCollapseState.PreserveOrCollapsed\n\t\t\t\t\t\t: ObjectTreeElementCollapseState.PreserveOrExpanded),\n\t\t\t\tchildren: getChildrenForParent(serialized, rootsWithChildren, element),\n\t\t\t}\n\t));\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IIdentityProvider } from '../../../../../base/browser/ui/list/list.js';\nimport { ObjectTree } from '../../../../../base/browser/ui/tree/objectTree.js';\nimport { IObjectTreeElement, ObjectTreeElementCollapseState } from '../../../../../base/browser/ui/tree/tree.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { FuzzyScore } from '../../../../../base/common/filters.js';\nimport { IMarkdownString } from '../../../../../base/common/htmlContent.js';\nimport { Iterable } from '../../../../../base/common/iterator.js';\nimport { IDisposable } from '../../../../../base/common/lifecycle.js';\nimport { MarshalledId } from '../../../../../base/common/marshallingIds.js';\nimport { ISerializedTestTreeCollapseState, isCollapsedInSerializedTestTree } from './testingViewState.js';\nimport { ITestItemContext, InternalTestItem, TestItemExpandState, TestResultState } from '../../common/testTypes.js';\n\n/**\n * Describes a rendering of tests in the explorer view. Different\n * implementations of this are used for trees and lists, and groupings.\n * Originally this was implemented as inline logic within the ViewModel and\n * using a single IncrementalTestChangeCollector, but this became hairy\n * with status projections.\n */\nexport interface ITestTreeProjection extends IDisposable {\n\t/**\n\t * Event that fires when the projection changes.\n\t */\n\treadonly onUpdate: Event<void>;\n\n\t/**\n\t * State to use for applying default collapse state of items.\n\t */\n\tlastState: ISerializedTestTreeCollapseState;\n\n\t/**\n\t * Fired when an element in the tree is expanded.\n\t */\n\texpandElement(element: TestItemTreeElement, depth: number): void;\n\n\t/**\n\t * Gets an element by its extension-assigned ID.\n\t */\n\tgetElementByTestId(testId: string): TestItemTreeElement | undefined;\n\n\t/**\n\t * Applies pending update to the tree.\n\t */\n\tapplyTo(tree: ObjectTree<TestExplorerTreeElement, FuzzyScore>): void;\n}\n\nlet idCounter = 0;\n\nconst getId = () => String(idCounter++);\n\nexport abstract class TestItemTreeElement {\n\tprotected readonly changeEmitter = new Emitter<void>();\n\n\t/**\n\t * Fired whenever the element or test properties change.\n\t */\n\tpublic readonly onChange = this.changeEmitter.event;\n\n\t/**\n\t * Tree children of this item.\n\t */\n\tpublic readonly children = new Set<TestExplorerTreeElement>();\n\n\t/**\n\t * Unique ID of the element in the tree.\n\t */\n\tpublic readonly treeId = getId();\n\n\t/**\n\t * Depth of the element in the tree.\n\t */\n\tpublic depth: number;\n\n\t/**\n\t * Whether the node's test result is 'retired' -- from an outdated test run.\n\t */\n\tpublic retired = false;\n\n\t/**\n\t * State to show on the item. This is generally the item's computed state\n\t * from its children.\n\t */\n\tpublic state = TestResultState.Unset;\n\n\t/**\n\t * Time it took this test/item to run.\n\t */\n\tpublic duration: number | undefined;\n\n\t/**\n\t * Tree element description.\n\t */\n\tpublic abstract description: string | null;\n\n\tconstructor(\n\t\tpublic readonly test: InternalTestItem,\n\t\t/**\n\t\t * Parent tree item. May not actually be the test item who owns this one\n\t\t * in a 'flat' projection.\n\t\t */\n\t\tpublic readonly parent: TestItemTreeElement | null = null,\n\t) {\n\t\tthis.depth = parent ? parent.depth + 1 : 0;\n\t}\n\n\tpublic toJSON() {\n\t\tif (this.depth === 0) {\n\t\t\treturn { controllerId: this.test.controllerId };\n\t\t}\n\n\t\tconst context: ITestItemContext = {\n\t\t\t$mid: MarshalledId.TestItemContext,\n\t\t\ttests: [InternalTestItem.serialize(this.test)],\n\t\t};\n\n\t\tfor (let p = this.parent; p && p.depth > 0; p = p.parent) {\n\t\t\tcontext.tests.unshift(InternalTestItem.serialize(p.test));\n\t\t}\n\n\t\treturn context;\n\t}\n}\n\nexport class TestTreeErrorMessage {\n\tpublic readonly treeId = getId();\n\tpublic readonly children = new Set<never>();\n\n\tpublic get description() {\n\t\treturn typeof this.message === 'string' ? this.message : this.message.value;\n\t}\n\n\tconstructor(\n\t\tpublic readonly message: string | IMarkdownString,\n\t\tpublic readonly parent: TestExplorerTreeElement,\n\t) { }\n}\n\nexport type TestExplorerTreeElement = TestItemTreeElement | TestTreeErrorMessage;\n\nexport const testIdentityProvider: IIdentityProvider<TestExplorerTreeElement> = {\n\tgetId(element) {\n\t\t// For \"not expandable\" elements, whether they have children is part of the\n\t\t// ID so they're rerendered if that changes (#204805)\n\t\tconst expandComponent = element instanceof TestTreeErrorMessage\n\t\t\t? 'error'\n\t\t\t: element.test.expand === TestItemExpandState.NotExpandable\n\t\t\t\t? !!element.children.size\n\t\t\t\t: element.test.expand;\n\n\t\treturn element.treeId + '\\0' + expandComponent;\n\t}\n};\n\nexport const getChildrenForParent = (serialized: ISerializedTestTreeCollapseState, rootsWithChildren: Iterable<TestExplorerTreeElement>, node: TestExplorerTreeElement | null): Iterable<IObjectTreeElement<TestExplorerTreeElement>> => {\n\tlet it: Iterable<TestExplorerTreeElement>;\n\tif (node === null) { // roots\n\t\tconst rootsWithChildrenArr = [...rootsWithChildren];\n\t\tif (rootsWithChildrenArr.length === 1) {\n\t\t\treturn getChildrenForParent(serialized, rootsWithChildrenArr, rootsWithChildrenArr[0]);\n\t\t}\n\t\tit = rootsWithChildrenArr;\n\t} else {\n\t\tit = node.children;\n\t}\n\n\treturn Iterable.map(it, element => (\n\t\telement instanceof TestTreeErrorMessage\n\t\t\t? { element }\n\t\t\t: {\n\t\t\t\telement,\n\t\t\t\tcollapsible: element.test.expand !== TestItemExpandState.NotExpandable,\n\t\t\t\tcollapsed: element.test.item.error\n\t\t\t\t\t? ObjectTreeElementCollapseState.PreserveOrExpanded\n\t\t\t\t\t: (isCollapsedInSerializedTestTree(serialized, element.test.item.extId) ?? element.depth > 0\n\t\t\t\t\t\t? ObjectTreeElementCollapseState.PreserveOrCollapsed\n\t\t\t\t\t\t: ObjectTreeElementCollapseState.PreserveOrExpanded),\n\t\t\t\tchildren: getChildrenForParent(serialized, rootsWithChildren, element),\n\t\t\t}\n\t));\n};\n"]}