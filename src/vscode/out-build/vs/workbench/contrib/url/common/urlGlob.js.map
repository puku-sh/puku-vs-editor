{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/url/common/urlGlob.ts","vs/workbench/contrib/url/common/urlGlob.ts"],"names":[],"mappings":"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","file":"urlGlob.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\n\n/**\n * Normalizes a URL by removing trailing slashes and query/fragment components.\n * @param url The URL to normalize.\n * @returns URI - The normalized URI object.\n */\nfunction normalizeURL(url: string | URI): URI {\n\tconst uri = typeof url === 'string' ? URI.parse(url) : url;\n\treturn uri.with({\n\t\t// Remove trailing slashes\n\t\tpath: uri.path.replace(/\\/+$/, ''),\n\t\t// Remove query and fragment\n\t\tquery: null,\n\t\tfragment: null,\n\t});\n}\n\n/**\n * Checks if a given URL matches a glob URL pattern.\n * The glob URL pattern can contain wildcards (*) and subdomain matching (*.)\n * @param uri The URL to check.\n * @param globUrl The glob URL pattern to match against.\n * @returns boolean - True if the URL matches the glob URL pattern, false otherwise.\n */\nexport function testUrlMatchesGlob(uri: string | URI, globUrl: string): boolean {\n\tconst normalizedUrl = normalizeURL(uri);\n\tlet normalizedGlobUrl: URI;\n\n\tconst globHasScheme = /^[^./:]*:\\/\\//.test(globUrl);\n\t// if the glob does not have a scheme we assume the scheme is http or https\n\t// so if the url doesn't have a scheme of http or https we return false\n\tif (!globHasScheme) {\n\t\tif (normalizedUrl.scheme !== 'http' && normalizedUrl.scheme !== 'https') {\n\t\t\treturn false;\n\t\t}\n\t\tnormalizedGlobUrl = normalizeURL(`${normalizedUrl.scheme}://${globUrl}`);\n\t} else {\n\t\tnormalizedGlobUrl = normalizeURL(globUrl);\n\t}\n\n\treturn (\n\t\tdoMemoUrlMatch(normalizedUrl.scheme, normalizedGlobUrl.scheme) &&\n\t\t// The authority is the only thing that should do port logic.\n\t\tdoMemoUrlMatch(normalizedUrl.authority, normalizedGlobUrl.authority, true) &&\n\t\t(\n\t\t\t//\n\t\t\tnormalizedGlobUrl.path === '/' ||\n\t\t\tdoMemoUrlMatch(normalizedUrl.path, normalizedGlobUrl.path)\n\t\t)\n\t);\n}\n\n/**\n * @param normalizedUrlPart The normalized URL part to match.\n * @param normalizedGlobUrlPart The normalized glob URL part to match against.\n * @param includePortLogic Whether to include port logic in the matching process.\n * @returns boolean - True if the URL part matches the glob URL part, false otherwise.\n */\nfunction doMemoUrlMatch(\n\tnormalizedUrlPart: string,\n\tnormalizedGlobUrlPart: string,\n\tincludePortLogic: boolean = false,\n) {\n\tconst memo = Array.from({ length: normalizedUrlPart.length + 1 }).map(() =>\n\t\tArray.from({ length: normalizedGlobUrlPart.length + 1 }).map(() => undefined),\n\t);\n\n\treturn doUrlPartMatch(memo, includePortLogic, normalizedUrlPart, normalizedGlobUrlPart, 0, 0);\n}\n\n/**\n * Recursively checks if a URL part matches a glob URL part.\n * This function uses memoization to avoid recomputing results for the same inputs.\n * It handles various cases such as exact matches, wildcard matches, and port logic.\n * @param memo A memoization table to avoid recomputing results for the same inputs.\n * @param includePortLogic Whether to include port logic in the matching process.\n * @param urlPart The URL part to match with.\n * @param globUrlPart The glob URL part to match against.\n * @param urlOffset The current offset in the URL part.\n * @param globUrlOffset The current offset in the glob URL part.\n * @returns boolean - True if the URL part matches the glob URL part, false otherwise.\n */\nfunction doUrlPartMatch(\n\tmemo: (boolean | undefined)[][],\n\tincludePortLogic: boolean,\n\turlPart: string,\n\tglobUrlPart: string,\n\turlOffset: number,\n\tglobUrlOffset: number\n): boolean {\n\tif (memo[urlOffset]?.[globUrlOffset] !== undefined) {\n\t\treturn memo[urlOffset][globUrlOffset]!;\n\t}\n\n\tconst options = [];\n\n\t// We've reached the end of the url.\n\tif (urlOffset === urlPart.length) {\n\t\t// We're also at the end of the glob url as well so we have an exact match.\n\t\tif (globUrlOffset === globUrlPart.length) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (includePortLogic && globUrlPart[globUrlOffset] + globUrlPart[globUrlOffset + 1] === ':*') {\n\t\t\t// any port match. Consume a port if it exists otherwise nothing. Always consume the base.\n\t\t\treturn globUrlOffset + 2 === globUrlPart.length;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// Some path remaining in url\n\tif (globUrlOffset === globUrlPart.length) {\n\t\tconst remaining = urlPart.slice(urlOffset);\n\t\treturn remaining[0] === '/';\n\t}\n\n\tif (urlPart[urlOffset] === globUrlPart[globUrlOffset]) {\n\t\t// Exact match.\n\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset + 1, globUrlOffset + 1));\n\t}\n\n\tif (globUrlPart[globUrlOffset] + globUrlPart[globUrlOffset + 1] === '*.') {\n\t\t// Any subdomain match. Either consume one thing that's not a / or : and don't advance base or consume nothing and do.\n\t\tif (!['/', ':'].includes(urlPart[urlOffset])) {\n\t\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset + 1, globUrlOffset));\n\t\t}\n\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset, globUrlOffset + 2));\n\t}\n\n\tif (globUrlPart[globUrlOffset] === '*') {\n\t\t// Any match. Either consume one thing and don't advance base or consume nothing and do.\n\t\tif (urlOffset + 1 === urlPart.length) {\n\t\t\t// If we're at the end of the input url consume one from both.\n\t\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset + 1, globUrlOffset + 1));\n\t\t} else {\n\t\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset + 1, globUrlOffset));\n\t\t}\n\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset, globUrlOffset + 1));\n\t}\n\n\tif (includePortLogic && globUrlPart[globUrlOffset] + globUrlPart[globUrlOffset + 1] === ':*') {\n\t\t// any port match. Consume a port if it exists otherwise nothing. Always consume the base.\n\t\tif (urlPart[urlOffset] === ':') {\n\t\t\tlet endPortIndex = urlOffset + 1;\n\t\t\tdo { endPortIndex++; } while (/[0-9]/.test(urlPart[endPortIndex]));\n\t\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, endPortIndex, globUrlOffset + 2));\n\t\t} else {\n\t\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset, globUrlOffset + 2));\n\t\t}\n\t}\n\n\treturn (memo[urlOffset][globUrlOffset] = options.some(a => a === true));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\n\n/**\n * Normalizes a URL by removing trailing slashes and query/fragment components.\n * @param url The URL to normalize.\n * @returns URI - The normalized URI object.\n */\nfunction normalizeURL(url: string | URI): URI {\n\tconst uri = typeof url === 'string' ? URI.parse(url) : url;\n\treturn uri.with({\n\t\t// Remove trailing slashes\n\t\tpath: uri.path.replace(/\\/+$/, ''),\n\t\t// Remove query and fragment\n\t\tquery: null,\n\t\tfragment: null,\n\t});\n}\n\n/**\n * Checks if a given URL matches a glob URL pattern.\n * The glob URL pattern can contain wildcards (*) and subdomain matching (*.)\n * @param uri The URL to check.\n * @param globUrl The glob URL pattern to match against.\n * @returns boolean - True if the URL matches the glob URL pattern, false otherwise.\n */\nexport function testUrlMatchesGlob(uri: string | URI, globUrl: string): boolean {\n\tconst normalizedUrl = normalizeURL(uri);\n\tlet normalizedGlobUrl: URI;\n\n\tconst globHasScheme = /^[^./:]*:\\/\\//.test(globUrl);\n\t// if the glob does not have a scheme we assume the scheme is http or https\n\t// so if the url doesn't have a scheme of http or https we return false\n\tif (!globHasScheme) {\n\t\tif (normalizedUrl.scheme !== 'http' && normalizedUrl.scheme !== 'https') {\n\t\t\treturn false;\n\t\t}\n\t\tnormalizedGlobUrl = normalizeURL(`${normalizedUrl.scheme}://${globUrl}`);\n\t} else {\n\t\tnormalizedGlobUrl = normalizeURL(globUrl);\n\t}\n\n\treturn (\n\t\tdoMemoUrlMatch(normalizedUrl.scheme, normalizedGlobUrl.scheme) &&\n\t\t// The authority is the only thing that should do port logic.\n\t\tdoMemoUrlMatch(normalizedUrl.authority, normalizedGlobUrl.authority, true) &&\n\t\t(\n\t\t\t//\n\t\t\tnormalizedGlobUrl.path === '/' ||\n\t\t\tdoMemoUrlMatch(normalizedUrl.path, normalizedGlobUrl.path)\n\t\t)\n\t);\n}\n\n/**\n * @param normalizedUrlPart The normalized URL part to match.\n * @param normalizedGlobUrlPart The normalized glob URL part to match against.\n * @param includePortLogic Whether to include port logic in the matching process.\n * @returns boolean - True if the URL part matches the glob URL part, false otherwise.\n */\nfunction doMemoUrlMatch(\n\tnormalizedUrlPart: string,\n\tnormalizedGlobUrlPart: string,\n\tincludePortLogic: boolean = false,\n) {\n\tconst memo = Array.from({ length: normalizedUrlPart.length + 1 }).map(() =>\n\t\tArray.from({ length: normalizedGlobUrlPart.length + 1 }).map(() => undefined),\n\t);\n\n\treturn doUrlPartMatch(memo, includePortLogic, normalizedUrlPart, normalizedGlobUrlPart, 0, 0);\n}\n\n/**\n * Recursively checks if a URL part matches a glob URL part.\n * This function uses memoization to avoid recomputing results for the same inputs.\n * It handles various cases such as exact matches, wildcard matches, and port logic.\n * @param memo A memoization table to avoid recomputing results for the same inputs.\n * @param includePortLogic Whether to include port logic in the matching process.\n * @param urlPart The URL part to match with.\n * @param globUrlPart The glob URL part to match against.\n * @param urlOffset The current offset in the URL part.\n * @param globUrlOffset The current offset in the glob URL part.\n * @returns boolean - True if the URL part matches the glob URL part, false otherwise.\n */\nfunction doUrlPartMatch(\n\tmemo: (boolean | undefined)[][],\n\tincludePortLogic: boolean,\n\turlPart: string,\n\tglobUrlPart: string,\n\turlOffset: number,\n\tglobUrlOffset: number\n): boolean {\n\tif (memo[urlOffset]?.[globUrlOffset] !== undefined) {\n\t\treturn memo[urlOffset][globUrlOffset]!;\n\t}\n\n\tconst options = [];\n\n\t// We've reached the end of the url.\n\tif (urlOffset === urlPart.length) {\n\t\t// We're also at the end of the glob url as well so we have an exact match.\n\t\tif (globUrlOffset === globUrlPart.length) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (includePortLogic && globUrlPart[globUrlOffset] + globUrlPart[globUrlOffset + 1] === ':*') {\n\t\t\t// any port match. Consume a port if it exists otherwise nothing. Always consume the base.\n\t\t\treturn globUrlOffset + 2 === globUrlPart.length;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// Some path remaining in url\n\tif (globUrlOffset === globUrlPart.length) {\n\t\tconst remaining = urlPart.slice(urlOffset);\n\t\treturn remaining[0] === '/';\n\t}\n\n\tif (urlPart[urlOffset] === globUrlPart[globUrlOffset]) {\n\t\t// Exact match.\n\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset + 1, globUrlOffset + 1));\n\t}\n\n\tif (globUrlPart[globUrlOffset] + globUrlPart[globUrlOffset + 1] === '*.') {\n\t\t// Any subdomain match. Either consume one thing that's not a / or : and don't advance base or consume nothing and do.\n\t\tif (!['/', ':'].includes(urlPart[urlOffset])) {\n\t\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset + 1, globUrlOffset));\n\t\t}\n\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset, globUrlOffset + 2));\n\t}\n\n\tif (globUrlPart[globUrlOffset] === '*') {\n\t\t// Any match. Either consume one thing and don't advance base or consume nothing and do.\n\t\tif (urlOffset + 1 === urlPart.length) {\n\t\t\t// If we're at the end of the input url consume one from both.\n\t\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset + 1, globUrlOffset + 1));\n\t\t} else {\n\t\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset + 1, globUrlOffset));\n\t\t}\n\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset, globUrlOffset + 1));\n\t}\n\n\tif (includePortLogic && globUrlPart[globUrlOffset] + globUrlPart[globUrlOffset + 1] === ':*') {\n\t\t// any port match. Consume a port if it exists otherwise nothing. Always consume the base.\n\t\tif (urlPart[urlOffset] === ':') {\n\t\t\tlet endPortIndex = urlOffset + 1;\n\t\t\tdo { endPortIndex++; } while (/[0-9]/.test(urlPart[endPortIndex]));\n\t\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, endPortIndex, globUrlOffset + 2));\n\t\t} else {\n\t\t\toptions.push(doUrlPartMatch(memo, includePortLogic, urlPart, globUrlPart, urlOffset, globUrlOffset + 2));\n\t\t}\n\t}\n\n\treturn (memo[urlOffset][globUrlOffset] = options.some(a => a === true));\n}\n"]}