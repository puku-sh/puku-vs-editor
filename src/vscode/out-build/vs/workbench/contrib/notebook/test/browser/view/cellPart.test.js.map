{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/notebook/test/browser/view/cellPart.test.ts","vs/workbench/contrib/notebook/test/browser/view/cellPart.test.ts"],"names":[],"mappings":"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","file":"cellPart.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../../base/test/common/utils.js';\nimport { CodeCellRenderTemplate } from '../../../browser/view/notebookRenderingCommon.js';\nimport { CodeCellViewModel } from '../../../browser/viewModel/codeCellViewModel.js';\nimport { CodeCellLayout } from '../../../browser/view/cellParts/codeCell.js';\nimport { ICodeEditor } from '../../../../../../editor/browser/editorBrowser.js';\nimport { CodeCellLayoutInfo, IActiveNotebookEditorDelegate } from '../../../browser/notebookBrowser.js';\n\nsuite('CellPart', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('CodeCellLayout editor visibility states', () => {\n\t\t/**\n\t\t * We construct a very small mock around the parts that `CodeCellLayout` touches. The goal\n\t\t * is to validate the branching logic that sets `_editorVisibility` without mutating any\n\t\t * production code. Each scenario sets up geometry & scroll values then invokes\n\t\t * `layoutEditor()` and asserts the resulting visibility classification.\n\t\t */\n\n\t\tinterface TestScenario {\n\t\t\tname: string;\n\t\t\tscrollTop: number;\n\t\t\tviewportHeight: number;\n\t\t\teditorContentHeight: number;\n\t\t\teditorHeight: number; // viewCell.layoutInfo.editorHeight\n\t\t\toutputContainerOffset: number; // elementTop + this offset => editorBottom\n\t\t\texpected: string; // CodeCellLayout.editorVisibility\n\t\t\tpostScrollTop?: number; // expected editor scrollTop written into stub editor\n\t\t\telementTop: number; // now scenario-specific for clarity\n\t\t\telementHeight: number; // scenario-specific container height\n\t\t\texpectedTop: number; // expected computed CSS top (numeric px)\n\t\t\texpectedEditorScrollTop: number; // expected argument passed to editor.setScrollTop\n\t\t}\n\n\t\tconst DEFAULT_ELEMENT_TOP = 100; // absolute top of the cell in notebook coordinates\n\t\tconst DEFAULT_ELEMENT_HEIGHT = 900; // arbitrary, large enough not to constrain\n\t\tconst STATUSBAR = 22;\n\t\tconst TOP_MARGIN = 6; // mirrors layoutInfo.topMargin usage\n\t\tconst OUTLINE = 1;\n\n\t\tconst scenarios: TestScenario[] = [\n\t\t\t{\n\t\t\t\tname: 'Full',\n\t\t\t\tscrollTop: 0,\n\t\t\t\tviewportHeight: 400,\n\t\t\t\teditorContentHeight: 300,\n\t\t\t\teditorHeight: 300,\n\t\t\t\toutputContainerOffset: 300, // editorBottom = 100 + 300 = 400, fully inside viewport (scrollBottom=400)\n\t\t\t\texpected: 'Full',\n\t\t\t\telementTop: DEFAULT_ELEMENT_TOP,\n\t\t\t\telementHeight: DEFAULT_ELEMENT_HEIGHT,\n\t\t\t\texpectedTop: 0,\n\t\t\t\texpectedEditorScrollTop: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Bottom Clipped',\n\t\t\t\tscrollTop: 0,\n\t\t\t\tviewportHeight: 350, // scrollBottom=350 < editorBottom(400)\n\t\t\t\teditorContentHeight: 300,\n\t\t\t\teditorHeight: 300,\n\t\t\t\toutputContainerOffset: 300,\n\t\t\t\texpected: 'Bottom Clipped',\n\t\t\t\telementTop: DEFAULT_ELEMENT_TOP,\n\t\t\t\telementHeight: DEFAULT_ELEMENT_HEIGHT,\n\t\t\t\texpectedTop: 0,\n\t\t\t\texpectedEditorScrollTop: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Full (Small Viewport)',\n\t\t\t\tscrollTop: DEFAULT_ELEMENT_TOP + TOP_MARGIN + 20, // scrolled into the cell body\n\t\t\t\tviewportHeight: 220, // small vs content\n\t\t\t\teditorContentHeight: 500, // larger than viewport so we clamp\n\t\t\t\teditorHeight: 500,\n\t\t\t\toutputContainerOffset: 600, // editorBottom=700 > scrollBottom\n\t\t\t\texpected: 'Full (Small Viewport)',\n\t\t\t\telementTop: DEFAULT_ELEMENT_TOP,\n\t\t\t\telementHeight: DEFAULT_ELEMENT_HEIGHT,\n\t\t\t\texpectedTop: 19, // (scrollTop - elementTop - topMargin - outlineWidth) = (100+6+20 -100 -6 -1)\n\t\t\t\texpectedEditorScrollTop: 19,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Top Clipped',\n\t\t\t\tscrollTop: DEFAULT_ELEMENT_TOP + TOP_MARGIN + 40, // scrolled further down but not past bottom\n\t\t\t\tviewportHeight: 600, // larger than content height below (forces branch for Top Clipped)\n\t\t\t\teditorContentHeight: 200,\n\t\t\t\teditorHeight: 200,\n\t\t\t\toutputContainerOffset: 450, // editorBottom=550; scrollBottom= scrollTop+viewportHeight = > 550?  (540+600=1140) but we only need scrollTop < editorBottom\n\t\t\t\texpected: 'Top Clipped',\n\t\t\t\telementTop: DEFAULT_ELEMENT_TOP,\n\t\t\t\telementHeight: DEFAULT_ELEMENT_HEIGHT,\n\t\t\t\texpectedTop: 39, // (100+6+40 -100 -6 -1)\n\t\t\t\texpectedEditorScrollTop: 40, // contentHeight(200) - computed height(160)\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Invisible',\n\t\t\t\tscrollTop: DEFAULT_ELEMENT_TOP + 1000, // well below editor bottom\n\t\t\t\tviewportHeight: 400,\n\t\t\t\teditorContentHeight: 300,\n\t\t\t\teditorHeight: 300,\n\t\t\t\toutputContainerOffset: 300, // editorBottom=400 < scrollTop\n\t\t\t\texpected: 'Invisible',\n\t\t\t\telementTop: DEFAULT_ELEMENT_TOP,\n\t\t\t\telementHeight: DEFAULT_ELEMENT_HEIGHT,\n\t\t\t\texpectedTop: 278, // adjusted after ensuring minimum line height when possibleEditorHeight < LINE_HEIGHT\n\t\t\t\texpectedEditorScrollTop: 279, // contentHeight(300) - clamped height(21)\n\t\t\t},\n\t\t];\n\n\t\tfor (const s of scenarios) {\n\t\t\t// Fresh stub objects per scenario\n\t\t\tconst editorScrollState: { scrollTop: number } = { scrollTop: 0 };\n\t\t\tconst stubEditor = {\n\t\t\t\tlayoutCalls: [] as { width: number; height: number }[],\n\t\t\t\t_lastScrollTopSet: -1,\n\t\t\t\tgetLayoutInfo: () => ({ width: 600, height: s.editorHeight }),\n\t\t\t\tgetContentHeight: () => s.editorContentHeight,\n\t\t\t\tlayout: (dim: { width: number; height: number }) => {\n\t\t\t\t\tstubEditor.layoutCalls.push(dim);\n\t\t\t\t},\n\t\t\t\tsetScrollTop: (v: number) => {\n\t\t\t\t\teditorScrollState.scrollTop = v;\n\t\t\t\t\tstubEditor._lastScrollTopSet = v;\n\t\t\t\t},\n\t\t\t\thasModel: () => true,\n\t\t\t};\n\n\t\t\tconst editorPart = { style: { top: '' } };\n\t\t\tconst template: Partial<CodeCellRenderTemplate> = {\n\t\t\t\teditor: stubEditor as unknown as ICodeEditor,\n\t\t\t\teditorPart: editorPart as unknown as HTMLElement,\n\t\t\t};\n\n\t\t\t// viewCell stub with only needed pieces\n\t\t\tconst viewCell: Partial<CodeCellViewModel> = {\n\t\t\t\tisInputCollapsed: false,\n\t\t\t\tlayoutInfo: {\n\t\t\t\t\t// values referenced in layout logic\n\t\t\t\t\tstatusBarHeight: STATUSBAR,\n\t\t\t\t\ttopMargin: TOP_MARGIN,\n\t\t\t\t\toutlineWidth: OUTLINE,\n\t\t\t\t\teditorHeight: s.editorHeight,\n\t\t\t\t\toutputContainerOffset: s.outputContainerOffset,\n\t\t\t\t} as unknown as CodeCellLayoutInfo,\n\t\t\t};\n\n\t\t\t// notebook editor stub\n\t\t\tlet scrollBottom = s.scrollTop + s.viewportHeight;\n\t\t\tconst notebookEditor = {\n\t\t\t\tscrollTop: s.scrollTop,\n\t\t\t\tget scrollBottom() {\n\t\t\t\t\treturn scrollBottom;\n\t\t\t\t},\n\t\t\t\tsetScrollTop: (v: number) => {\n\t\t\t\t\tnotebookEditor.scrollTop = v;\n\t\t\t\t\tscrollBottom = v + s.viewportHeight;\n\t\t\t\t},\n\t\t\t\tgetLayoutInfo: () => ({\n\t\t\t\t\tfontInfo: { lineHeight: 21 },\n\t\t\t\t\theight: s.viewportHeight,\n\t\t\t\t\tstickyHeight: 0,\n\t\t\t\t}),\n\t\t\t\tgetAbsoluteTopOfElement: () => s.elementTop,\n\t\t\t\tgetAbsoluteBottomOfElement: () =>\n\t\t\t\t\ts.elementTop + s.outputContainerOffset,\n\t\t\t\tgetHeightOfElement: () => s.elementHeight,\n\t\t\t\tnotebookOptions: {\n\t\t\t\t\tgetLayoutConfiguration: () => ({ editorTopPadding: 6 }),\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tconst layout = new CodeCellLayout(\n\t\t\t\t/* enabled */ true,\n\t\t\t\tnotebookEditor as unknown as IActiveNotebookEditorDelegate,\n\t\t\t\tviewCell as CodeCellViewModel,\n\t\t\t\ttemplate as CodeCellRenderTemplate,\n\t\t\t\t{\n\t\t\t\t\tdebug: () => {\n\t\t\t\t\t\t/* no-op */\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{ width: 600, height: s.editorHeight }\n\t\t\t);\n\n\t\t\tlayout.layoutEditor('init');\n\t\t\tassert.strictEqual(\n\t\t\t\tlayout.editorVisibility,\n\t\t\t\ts.expected,\n\t\t\t\t`Scenario '${s.name}' (scrollTop=${s.scrollTop}) expected visibility ${s.expected} but got ${layout.editorVisibility}`\n\t\t\t);\n\t\t\tconst actualTop = parseInt(\n\t\t\t\t(editorPart.style.top || '0').replace(/px$/, '')\n\t\t\t); // style.top always like 'NNNpx'\n\t\t\tassert.strictEqual(\n\t\t\t\tactualTop,\n\t\t\t\ts.expectedTop,\n\t\t\t\t`Scenario '${s.name}' (scrollTop=${s.scrollTop}) expected top ${s.expectedTop}px but got ${editorPart.style.top}`\n\t\t\t);\n\t\t\tassert.strictEqual(\n\t\t\t\tstubEditor._lastScrollTopSet,\n\t\t\t\ts.expectedEditorScrollTop,\n\t\t\t\t`Scenario '${s.name}' (scrollTop=${s.scrollTop}) expected editor.setScrollTop(${s.expectedEditorScrollTop}) but got ${stubEditor._lastScrollTopSet}`\n\t\t\t);\n\n\t\t\t// Basic sanity: style.top should always be set when visible states other than Full (handled) or Invisible.\n\t\t\tif (s.expected !== 'Invisible') {\n\t\t\t\tassert.notStrictEqual(\n\t\t\t\t\teditorPart.style.top,\n\t\t\t\t\t'',\n\t\t\t\t\t`Scenario '${s.name}' should set a top style value`\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// Invisible still sets a top; just ensure layout ran\n\t\t\t\tassert.ok(\n\t\t\t\t\teditorPart.style.top !== undefined,\n\t\t\t\t\t'Invisible scenario still performs a layout'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t});\n\n\ttest('Scrolling', () => {\n\t\t/**\n\t\t * Pixel-by-pixel scroll test to validate `CodeCellLayout` calculations for:\n\t\t *  - editorPart.style.top\n\t\t *  - editorVisibility classification\n\t\t *  - editor internal scrollTop passed to setScrollTop\n\t\t *\n\t\t * We intentionally mirror the production math in a helper (duplication acceptable in test) so\n\t\t * that any divergence is caught. Constants chosen to exercise all state transitions.\n\t\t */\n\t\tconst LINE_HEIGHT = 21; // from getLayoutInfo().fontInfo.lineHeight in stubs\n\t\tconst CELL_TOP_MARGIN = 6;\n\t\tconst CELL_OUTLINE_WIDTH = 1;\n\t\tconst STATUSBAR_HEIGHT = 22;\n\t\tconst VIEWPORT_HEIGHT = 300; // notebook viewport height\n\t\tconst ELEMENT_TOP = 100; // absolute top\n\t\tconst EDITOR_CONTENT_HEIGHT = 800; // tall content so we get clipping and small viewport states\n\t\tconst EDITOR_HEIGHT = EDITOR_CONTENT_HEIGHT; // initial layoutInfo.editorHeight\n\t\tconst OUTPUT_CONTAINER_OFFSET = 800; // bottom of editor region relative to elementTop\n\t\tconst ELEMENT_HEIGHT = 1200; // large container\n\n\t\tfunction clamp(v: number, min: number, max: number) {\n\t\t\treturn Math.min(Math.max(v, min), max);\n\t\t}\n\n\t\tfunction computeExpected(scrollTop: number) {\n\t\t\tconst scrollBottom = scrollTop + VIEWPORT_HEIGHT;\n\t\t\tconst viewportHeight = VIEWPORT_HEIGHT;\n\t\t\tconst editorBottom = ELEMENT_TOP + OUTPUT_CONTAINER_OFFSET;\n\t\t\tlet top = Math.max(\n\t\t\t\t0,\n\t\t\t\tscrollTop - ELEMENT_TOP - CELL_TOP_MARGIN - CELL_OUTLINE_WIDTH\n\t\t\t);\n\t\t\tconst possibleEditorHeight = EDITOR_HEIGHT - top;\n\t\t\tif (possibleEditorHeight < LINE_HEIGHT) {\n\t\t\t\ttop = top - (LINE_HEIGHT - possibleEditorHeight) - CELL_OUTLINE_WIDTH;\n\t\t\t}\n\t\t\tlet height = EDITOR_CONTENT_HEIGHT;\n\t\t\tlet visibility: string = 'Full';\n\t\t\tlet editorScrollTop = 0;\n\t\t\tif (scrollTop <= ELEMENT_TOP + CELL_TOP_MARGIN) {\n\t\t\t\tconst minimumEditorHeight = LINE_HEIGHT + 6; // editorTopPadding from configuration stub (6)\n\t\t\t\tif (scrollBottom >= editorBottom) {\n\t\t\t\t\theight = clamp(\n\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT,\n\t\t\t\t\t\tminimumEditorHeight,\n\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT\n\t\t\t\t\t);\n\t\t\t\t\tvisibility = 'Full';\n\t\t\t\t} else {\n\t\t\t\t\theight =\n\t\t\t\t\t\tclamp(\n\t\t\t\t\t\t\tscrollBottom - (ELEMENT_TOP + CELL_TOP_MARGIN) - STATUSBAR_HEIGHT,\n\t\t\t\t\t\t\tminimumEditorHeight,\n\t\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t2 * CELL_OUTLINE_WIDTH;\n\t\t\t\t\tvisibility = 'Bottom Clipped';\n\t\t\t\t\teditorScrollTop = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tviewportHeight <= EDITOR_CONTENT_HEIGHT &&\n\t\t\t\t\tscrollBottom <= editorBottom\n\t\t\t\t) {\n\t\t\t\t\tconst minimumEditorHeight = LINE_HEIGHT + 6; // editorTopPadding\n\t\t\t\t\theight =\n\t\t\t\t\t\tclamp(\n\t\t\t\t\t\t\tviewportHeight - STATUSBAR_HEIGHT,\n\t\t\t\t\t\t\tminimumEditorHeight,\n\t\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT - STATUSBAR_HEIGHT\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t2 * CELL_OUTLINE_WIDTH;\n\t\t\t\t\tvisibility = 'Full (Small Viewport)';\n\t\t\t\t\teditorScrollTop = top;\n\t\t\t\t} else {\n\t\t\t\t\tconst minimumEditorHeight = LINE_HEIGHT;\n\t\t\t\t\theight = clamp(\n\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT -\n\t\t\t\t\t\t(scrollTop - (ELEMENT_TOP + CELL_TOP_MARGIN)),\n\t\t\t\t\t\tminimumEditorHeight,\n\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT\n\t\t\t\t\t);\n\t\t\t\t\tif (scrollTop > editorBottom) {\n\t\t\t\t\t\tvisibility = 'Invisible';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvisibility = 'Top Clipped';\n\t\t\t\t\t}\n\t\t\t\t\teditorScrollTop = EDITOR_CONTENT_HEIGHT - height;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { top, visibility, editorScrollTop };\n\t\t}\n\n\t\t// Shared stubs (we'll mutate scrollTop each iteration) – we re-create layout each iteration to reset internal state changes\n\t\tfor (\n\t\t\tlet scrollTop = 0;\n\t\t\tscrollTop <= VIEWPORT_HEIGHT + OUTPUT_CONTAINER_OFFSET + 20;\n\t\t\tscrollTop++\n\t\t) {\n\t\t\tconst expected = computeExpected(scrollTop);\n\t\t\tconst scrollBottom = scrollTop + VIEWPORT_HEIGHT;\n\t\t\tconst stubEditor = {\n\t\t\t\t_lastScrollTopSet: -1,\n\t\t\t\tgetLayoutInfo: () => ({ width: 600, height: EDITOR_HEIGHT }),\n\t\t\t\tgetContentHeight: () => EDITOR_CONTENT_HEIGHT,\n\t\t\t\tlayout: () => {\n\t\t\t\t\t/* no-op */\n\t\t\t\t},\n\t\t\t\tsetScrollTop: (v: number) => {\n\t\t\t\t\tstubEditor._lastScrollTopSet = v;\n\t\t\t\t},\n\t\t\t\thasModel: () => true,\n\t\t\t};\n\t\t\tconst editorPart = { style: { top: '' } };\n\t\t\tconst template: Partial<CodeCellRenderTemplate> = {\n\t\t\t\teditor: stubEditor as unknown as ICodeEditor,\n\t\t\t\teditorPart: editorPart as unknown as HTMLElement,\n\t\t\t};\n\t\t\tconst viewCell: Partial<CodeCellViewModel> = {\n\t\t\t\tisInputCollapsed: false,\n\t\t\t\tlayoutInfo: {\n\t\t\t\t\tstatusBarHeight: STATUSBAR_HEIGHT,\n\t\t\t\t\ttopMargin: CELL_TOP_MARGIN,\n\t\t\t\t\toutlineWidth: CELL_OUTLINE_WIDTH,\n\t\t\t\t\teditorHeight: EDITOR_HEIGHT,\n\t\t\t\t\toutputContainerOffset: OUTPUT_CONTAINER_OFFSET,\n\t\t\t\t} as unknown as CodeCellLayoutInfo,\n\t\t\t};\n\t\t\tconst notebookEditor = {\n\t\t\t\tscrollTop,\n\t\t\t\tget scrollBottom() {\n\t\t\t\t\treturn scrollBottom;\n\t\t\t\t},\n\t\t\t\tsetScrollTop: (v: number) => {\n\t\t\t\t\t/* notebook scroll changes are not the focus here */\n\t\t\t\t},\n\t\t\t\tgetLayoutInfo: () => ({\n\t\t\t\t\tfontInfo: { lineHeight: LINE_HEIGHT },\n\t\t\t\t\theight: VIEWPORT_HEIGHT,\n\t\t\t\t\tstickyHeight: 0,\n\t\t\t\t}),\n\t\t\t\tgetAbsoluteTopOfElement: () => ELEMENT_TOP,\n\t\t\t\tgetAbsoluteBottomOfElement: () => ELEMENT_TOP + OUTPUT_CONTAINER_OFFSET,\n\t\t\t\tgetHeightOfElement: () => ELEMENT_HEIGHT,\n\t\t\t\tnotebookOptions: {\n\t\t\t\t\tgetLayoutConfiguration: () => ({ editorTopPadding: 6 }),\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst layout = new CodeCellLayout(\n\t\t\t\ttrue,\n\t\t\t\tnotebookEditor as unknown as IActiveNotebookEditorDelegate,\n\t\t\t\tviewCell as CodeCellViewModel,\n\t\t\t\ttemplate as CodeCellRenderTemplate,\n\t\t\t\t{ debug: () => { } },\n\t\t\t\t{ width: 600, height: EDITOR_HEIGHT }\n\t\t\t);\n\t\t\tlayout.layoutEditor('nbDidScroll');\n\t\t\tconst actualTop = parseInt(\n\t\t\t\t(editorPart.style.top || '0').replace(/px$/, '')\n\t\t\t);\n\t\t\tassert.strictEqual(\n\t\t\t\tactualTop,\n\t\t\t\texpected.top,\n\t\t\t\t`scrollTop=${scrollTop}: expected top ${expected.top}, got ${actualTop}`\n\t\t\t);\n\t\t\tassert.strictEqual(\n\t\t\t\tlayout.editorVisibility,\n\t\t\t\texpected.visibility,\n\t\t\t\t`scrollTop=${scrollTop}: expected visibility ${expected.visibility}, got ${layout.editorVisibility}`\n\t\t\t);\n\t\t\tassert.strictEqual(\n\t\t\t\tstubEditor._lastScrollTopSet,\n\t\t\t\texpected.editorScrollTop,\n\t\t\t\t`scrollTop=${scrollTop}: expected editorScrollTop ${expected.editorScrollTop}, got ${stubEditor._lastScrollTopSet}`\n\t\t\t);\n\t\t}\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../../base/test/common/utils.js';\nimport { CodeCellRenderTemplate } from '../../../browser/view/notebookRenderingCommon.js';\nimport { CodeCellViewModel } from '../../../browser/viewModel/codeCellViewModel.js';\nimport { CodeCellLayout } from '../../../browser/view/cellParts/codeCell.js';\nimport { ICodeEditor } from '../../../../../../editor/browser/editorBrowser.js';\nimport { CodeCellLayoutInfo, IActiveNotebookEditorDelegate } from '../../../browser/notebookBrowser.js';\n\nsuite('CellPart', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('CodeCellLayout editor visibility states', () => {\n\t\t/**\n\t\t * We construct a very small mock around the parts that `CodeCellLayout` touches. The goal\n\t\t * is to validate the branching logic that sets `_editorVisibility` without mutating any\n\t\t * production code. Each scenario sets up geometry & scroll values then invokes\n\t\t * `layoutEditor()` and asserts the resulting visibility classification.\n\t\t */\n\n\t\tinterface TestScenario {\n\t\t\tname: string;\n\t\t\tscrollTop: number;\n\t\t\tviewportHeight: number;\n\t\t\teditorContentHeight: number;\n\t\t\teditorHeight: number; // viewCell.layoutInfo.editorHeight\n\t\t\toutputContainerOffset: number; // elementTop + this offset => editorBottom\n\t\t\texpected: string; // CodeCellLayout.editorVisibility\n\t\t\tpostScrollTop?: number; // expected editor scrollTop written into stub editor\n\t\t\telementTop: number; // now scenario-specific for clarity\n\t\t\telementHeight: number; // scenario-specific container height\n\t\t\texpectedTop: number; // expected computed CSS top (numeric px)\n\t\t\texpectedEditorScrollTop: number; // expected argument passed to editor.setScrollTop\n\t\t}\n\n\t\tconst DEFAULT_ELEMENT_TOP = 100; // absolute top of the cell in notebook coordinates\n\t\tconst DEFAULT_ELEMENT_HEIGHT = 900; // arbitrary, large enough not to constrain\n\t\tconst STATUSBAR = 22;\n\t\tconst TOP_MARGIN = 6; // mirrors layoutInfo.topMargin usage\n\t\tconst OUTLINE = 1;\n\n\t\tconst scenarios: TestScenario[] = [\n\t\t\t{\n\t\t\t\tname: 'Full',\n\t\t\t\tscrollTop: 0,\n\t\t\t\tviewportHeight: 400,\n\t\t\t\teditorContentHeight: 300,\n\t\t\t\teditorHeight: 300,\n\t\t\t\toutputContainerOffset: 300, // editorBottom = 100 + 300 = 400, fully inside viewport (scrollBottom=400)\n\t\t\t\texpected: 'Full',\n\t\t\t\telementTop: DEFAULT_ELEMENT_TOP,\n\t\t\t\telementHeight: DEFAULT_ELEMENT_HEIGHT,\n\t\t\t\texpectedTop: 0,\n\t\t\t\texpectedEditorScrollTop: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Bottom Clipped',\n\t\t\t\tscrollTop: 0,\n\t\t\t\tviewportHeight: 350, // scrollBottom=350 < editorBottom(400)\n\t\t\t\teditorContentHeight: 300,\n\t\t\t\teditorHeight: 300,\n\t\t\t\toutputContainerOffset: 300,\n\t\t\t\texpected: 'Bottom Clipped',\n\t\t\t\telementTop: DEFAULT_ELEMENT_TOP,\n\t\t\t\telementHeight: DEFAULT_ELEMENT_HEIGHT,\n\t\t\t\texpectedTop: 0,\n\t\t\t\texpectedEditorScrollTop: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Full (Small Viewport)',\n\t\t\t\tscrollTop: DEFAULT_ELEMENT_TOP + TOP_MARGIN + 20, // scrolled into the cell body\n\t\t\t\tviewportHeight: 220, // small vs content\n\t\t\t\teditorContentHeight: 500, // larger than viewport so we clamp\n\t\t\t\teditorHeight: 500,\n\t\t\t\toutputContainerOffset: 600, // editorBottom=700 > scrollBottom\n\t\t\t\texpected: 'Full (Small Viewport)',\n\t\t\t\telementTop: DEFAULT_ELEMENT_TOP,\n\t\t\t\telementHeight: DEFAULT_ELEMENT_HEIGHT,\n\t\t\t\texpectedTop: 19, // (scrollTop - elementTop - topMargin - outlineWidth) = (100+6+20 -100 -6 -1)\n\t\t\t\texpectedEditorScrollTop: 19,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Top Clipped',\n\t\t\t\tscrollTop: DEFAULT_ELEMENT_TOP + TOP_MARGIN + 40, // scrolled further down but not past bottom\n\t\t\t\tviewportHeight: 600, // larger than content height below (forces branch for Top Clipped)\n\t\t\t\teditorContentHeight: 200,\n\t\t\t\teditorHeight: 200,\n\t\t\t\toutputContainerOffset: 450, // editorBottom=550; scrollBottom= scrollTop+viewportHeight = > 550?  (540+600=1140) but we only need scrollTop < editorBottom\n\t\t\t\texpected: 'Top Clipped',\n\t\t\t\telementTop: DEFAULT_ELEMENT_TOP,\n\t\t\t\telementHeight: DEFAULT_ELEMENT_HEIGHT,\n\t\t\t\texpectedTop: 39, // (100+6+40 -100 -6 -1)\n\t\t\t\texpectedEditorScrollTop: 40, // contentHeight(200) - computed height(160)\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Invisible',\n\t\t\t\tscrollTop: DEFAULT_ELEMENT_TOP + 1000, // well below editor bottom\n\t\t\t\tviewportHeight: 400,\n\t\t\t\teditorContentHeight: 300,\n\t\t\t\teditorHeight: 300,\n\t\t\t\toutputContainerOffset: 300, // editorBottom=400 < scrollTop\n\t\t\t\texpected: 'Invisible',\n\t\t\t\telementTop: DEFAULT_ELEMENT_TOP,\n\t\t\t\telementHeight: DEFAULT_ELEMENT_HEIGHT,\n\t\t\t\texpectedTop: 278, // adjusted after ensuring minimum line height when possibleEditorHeight < LINE_HEIGHT\n\t\t\t\texpectedEditorScrollTop: 279, // contentHeight(300) - clamped height(21)\n\t\t\t},\n\t\t];\n\n\t\tfor (const s of scenarios) {\n\t\t\t// Fresh stub objects per scenario\n\t\t\tconst editorScrollState: { scrollTop: number } = { scrollTop: 0 };\n\t\t\tconst stubEditor = {\n\t\t\t\tlayoutCalls: [] as { width: number; height: number }[],\n\t\t\t\t_lastScrollTopSet: -1,\n\t\t\t\tgetLayoutInfo: () => ({ width: 600, height: s.editorHeight }),\n\t\t\t\tgetContentHeight: () => s.editorContentHeight,\n\t\t\t\tlayout: (dim: { width: number; height: number }) => {\n\t\t\t\t\tstubEditor.layoutCalls.push(dim);\n\t\t\t\t},\n\t\t\t\tsetScrollTop: (v: number) => {\n\t\t\t\t\teditorScrollState.scrollTop = v;\n\t\t\t\t\tstubEditor._lastScrollTopSet = v;\n\t\t\t\t},\n\t\t\t\thasModel: () => true,\n\t\t\t};\n\n\t\t\tconst editorPart = { style: { top: '' } };\n\t\t\tconst template: Partial<CodeCellRenderTemplate> = {\n\t\t\t\teditor: stubEditor as unknown as ICodeEditor,\n\t\t\t\teditorPart: editorPart as unknown as HTMLElement,\n\t\t\t};\n\n\t\t\t// viewCell stub with only needed pieces\n\t\t\tconst viewCell: Partial<CodeCellViewModel> = {\n\t\t\t\tisInputCollapsed: false,\n\t\t\t\tlayoutInfo: {\n\t\t\t\t\t// values referenced in layout logic\n\t\t\t\t\tstatusBarHeight: STATUSBAR,\n\t\t\t\t\ttopMargin: TOP_MARGIN,\n\t\t\t\t\toutlineWidth: OUTLINE,\n\t\t\t\t\teditorHeight: s.editorHeight,\n\t\t\t\t\toutputContainerOffset: s.outputContainerOffset,\n\t\t\t\t} as unknown as CodeCellLayoutInfo,\n\t\t\t};\n\n\t\t\t// notebook editor stub\n\t\t\tlet scrollBottom = s.scrollTop + s.viewportHeight;\n\t\t\tconst notebookEditor = {\n\t\t\t\tscrollTop: s.scrollTop,\n\t\t\t\tget scrollBottom() {\n\t\t\t\t\treturn scrollBottom;\n\t\t\t\t},\n\t\t\t\tsetScrollTop: (v: number) => {\n\t\t\t\t\tnotebookEditor.scrollTop = v;\n\t\t\t\t\tscrollBottom = v + s.viewportHeight;\n\t\t\t\t},\n\t\t\t\tgetLayoutInfo: () => ({\n\t\t\t\t\tfontInfo: { lineHeight: 21 },\n\t\t\t\t\theight: s.viewportHeight,\n\t\t\t\t\tstickyHeight: 0,\n\t\t\t\t}),\n\t\t\t\tgetAbsoluteTopOfElement: () => s.elementTop,\n\t\t\t\tgetAbsoluteBottomOfElement: () =>\n\t\t\t\t\ts.elementTop + s.outputContainerOffset,\n\t\t\t\tgetHeightOfElement: () => s.elementHeight,\n\t\t\t\tnotebookOptions: {\n\t\t\t\t\tgetLayoutConfiguration: () => ({ editorTopPadding: 6 }),\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tconst layout = new CodeCellLayout(\n\t\t\t\t/* enabled */ true,\n\t\t\t\tnotebookEditor as unknown as IActiveNotebookEditorDelegate,\n\t\t\t\tviewCell as CodeCellViewModel,\n\t\t\t\ttemplate as CodeCellRenderTemplate,\n\t\t\t\t{\n\t\t\t\t\tdebug: () => {\n\t\t\t\t\t\t/* no-op */\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{ width: 600, height: s.editorHeight }\n\t\t\t);\n\n\t\t\tlayout.layoutEditor('init');\n\t\t\tassert.strictEqual(\n\t\t\t\tlayout.editorVisibility,\n\t\t\t\ts.expected,\n\t\t\t\t`Scenario '${s.name}' (scrollTop=${s.scrollTop}) expected visibility ${s.expected} but got ${layout.editorVisibility}`\n\t\t\t);\n\t\t\tconst actualTop = parseInt(\n\t\t\t\t(editorPart.style.top || '0').replace(/px$/, '')\n\t\t\t); // style.top always like 'NNNpx'\n\t\t\tassert.strictEqual(\n\t\t\t\tactualTop,\n\t\t\t\ts.expectedTop,\n\t\t\t\t`Scenario '${s.name}' (scrollTop=${s.scrollTop}) expected top ${s.expectedTop}px but got ${editorPart.style.top}`\n\t\t\t);\n\t\t\tassert.strictEqual(\n\t\t\t\tstubEditor._lastScrollTopSet,\n\t\t\t\ts.expectedEditorScrollTop,\n\t\t\t\t`Scenario '${s.name}' (scrollTop=${s.scrollTop}) expected editor.setScrollTop(${s.expectedEditorScrollTop}) but got ${stubEditor._lastScrollTopSet}`\n\t\t\t);\n\n\t\t\t// Basic sanity: style.top should always be set when visible states other than Full (handled) or Invisible.\n\t\t\tif (s.expected !== 'Invisible') {\n\t\t\t\tassert.notStrictEqual(\n\t\t\t\t\teditorPart.style.top,\n\t\t\t\t\t'',\n\t\t\t\t\t`Scenario '${s.name}' should set a top style value`\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// Invisible still sets a top; just ensure layout ran\n\t\t\t\tassert.ok(\n\t\t\t\t\teditorPart.style.top !== undefined,\n\t\t\t\t\t'Invisible scenario still performs a layout'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t});\n\n\ttest('Scrolling', () => {\n\t\t/**\n\t\t * Pixel-by-pixel scroll test to validate `CodeCellLayout` calculations for:\n\t\t *  - editorPart.style.top\n\t\t *  - editorVisibility classification\n\t\t *  - editor internal scrollTop passed to setScrollTop\n\t\t *\n\t\t * We intentionally mirror the production math in a helper (duplication acceptable in test) so\n\t\t * that any divergence is caught. Constants chosen to exercise all state transitions.\n\t\t */\n\t\tconst LINE_HEIGHT = 21; // from getLayoutInfo().fontInfo.lineHeight in stubs\n\t\tconst CELL_TOP_MARGIN = 6;\n\t\tconst CELL_OUTLINE_WIDTH = 1;\n\t\tconst STATUSBAR_HEIGHT = 22;\n\t\tconst VIEWPORT_HEIGHT = 300; // notebook viewport height\n\t\tconst ELEMENT_TOP = 100; // absolute top\n\t\tconst EDITOR_CONTENT_HEIGHT = 800; // tall content so we get clipping and small viewport states\n\t\tconst EDITOR_HEIGHT = EDITOR_CONTENT_HEIGHT; // initial layoutInfo.editorHeight\n\t\tconst OUTPUT_CONTAINER_OFFSET = 800; // bottom of editor region relative to elementTop\n\t\tconst ELEMENT_HEIGHT = 1200; // large container\n\n\t\tfunction clamp(v: number, min: number, max: number) {\n\t\t\treturn Math.min(Math.max(v, min), max);\n\t\t}\n\n\t\tfunction computeExpected(scrollTop: number) {\n\t\t\tconst scrollBottom = scrollTop + VIEWPORT_HEIGHT;\n\t\t\tconst viewportHeight = VIEWPORT_HEIGHT;\n\t\t\tconst editorBottom = ELEMENT_TOP + OUTPUT_CONTAINER_OFFSET;\n\t\t\tlet top = Math.max(\n\t\t\t\t0,\n\t\t\t\tscrollTop - ELEMENT_TOP - CELL_TOP_MARGIN - CELL_OUTLINE_WIDTH\n\t\t\t);\n\t\t\tconst possibleEditorHeight = EDITOR_HEIGHT - top;\n\t\t\tif (possibleEditorHeight < LINE_HEIGHT) {\n\t\t\t\ttop = top - (LINE_HEIGHT - possibleEditorHeight) - CELL_OUTLINE_WIDTH;\n\t\t\t}\n\t\t\tlet height = EDITOR_CONTENT_HEIGHT;\n\t\t\tlet visibility: string = 'Full';\n\t\t\tlet editorScrollTop = 0;\n\t\t\tif (scrollTop <= ELEMENT_TOP + CELL_TOP_MARGIN) {\n\t\t\t\tconst minimumEditorHeight = LINE_HEIGHT + 6; // editorTopPadding from configuration stub (6)\n\t\t\t\tif (scrollBottom >= editorBottom) {\n\t\t\t\t\theight = clamp(\n\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT,\n\t\t\t\t\t\tminimumEditorHeight,\n\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT\n\t\t\t\t\t);\n\t\t\t\t\tvisibility = 'Full';\n\t\t\t\t} else {\n\t\t\t\t\theight =\n\t\t\t\t\t\tclamp(\n\t\t\t\t\t\t\tscrollBottom - (ELEMENT_TOP + CELL_TOP_MARGIN) - STATUSBAR_HEIGHT,\n\t\t\t\t\t\t\tminimumEditorHeight,\n\t\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t2 * CELL_OUTLINE_WIDTH;\n\t\t\t\t\tvisibility = 'Bottom Clipped';\n\t\t\t\t\teditorScrollTop = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tviewportHeight <= EDITOR_CONTENT_HEIGHT &&\n\t\t\t\t\tscrollBottom <= editorBottom\n\t\t\t\t) {\n\t\t\t\t\tconst minimumEditorHeight = LINE_HEIGHT + 6; // editorTopPadding\n\t\t\t\t\theight =\n\t\t\t\t\t\tclamp(\n\t\t\t\t\t\t\tviewportHeight - STATUSBAR_HEIGHT,\n\t\t\t\t\t\t\tminimumEditorHeight,\n\t\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT - STATUSBAR_HEIGHT\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t2 * CELL_OUTLINE_WIDTH;\n\t\t\t\t\tvisibility = 'Full (Small Viewport)';\n\t\t\t\t\teditorScrollTop = top;\n\t\t\t\t} else {\n\t\t\t\t\tconst minimumEditorHeight = LINE_HEIGHT;\n\t\t\t\t\theight = clamp(\n\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT -\n\t\t\t\t\t\t(scrollTop - (ELEMENT_TOP + CELL_TOP_MARGIN)),\n\t\t\t\t\t\tminimumEditorHeight,\n\t\t\t\t\t\tEDITOR_CONTENT_HEIGHT\n\t\t\t\t\t);\n\t\t\t\t\tif (scrollTop > editorBottom) {\n\t\t\t\t\t\tvisibility = 'Invisible';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvisibility = 'Top Clipped';\n\t\t\t\t\t}\n\t\t\t\t\teditorScrollTop = EDITOR_CONTENT_HEIGHT - height;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { top, visibility, editorScrollTop };\n\t\t}\n\n\t\t// Shared stubs (we'll mutate scrollTop each iteration) – we re-create layout each iteration to reset internal state changes\n\t\tfor (\n\t\t\tlet scrollTop = 0;\n\t\t\tscrollTop <= VIEWPORT_HEIGHT + OUTPUT_CONTAINER_OFFSET + 20;\n\t\t\tscrollTop++\n\t\t) {\n\t\t\tconst expected = computeExpected(scrollTop);\n\t\t\tconst scrollBottom = scrollTop + VIEWPORT_HEIGHT;\n\t\t\tconst stubEditor = {\n\t\t\t\t_lastScrollTopSet: -1,\n\t\t\t\tgetLayoutInfo: () => ({ width: 600, height: EDITOR_HEIGHT }),\n\t\t\t\tgetContentHeight: () => EDITOR_CONTENT_HEIGHT,\n\t\t\t\tlayout: () => {\n\t\t\t\t\t/* no-op */\n\t\t\t\t},\n\t\t\t\tsetScrollTop: (v: number) => {\n\t\t\t\t\tstubEditor._lastScrollTopSet = v;\n\t\t\t\t},\n\t\t\t\thasModel: () => true,\n\t\t\t};\n\t\t\tconst editorPart = { style: { top: '' } };\n\t\t\tconst template: Partial<CodeCellRenderTemplate> = {\n\t\t\t\teditor: stubEditor as unknown as ICodeEditor,\n\t\t\t\teditorPart: editorPart as unknown as HTMLElement,\n\t\t\t};\n\t\t\tconst viewCell: Partial<CodeCellViewModel> = {\n\t\t\t\tisInputCollapsed: false,\n\t\t\t\tlayoutInfo: {\n\t\t\t\t\tstatusBarHeight: STATUSBAR_HEIGHT,\n\t\t\t\t\ttopMargin: CELL_TOP_MARGIN,\n\t\t\t\t\toutlineWidth: CELL_OUTLINE_WIDTH,\n\t\t\t\t\teditorHeight: EDITOR_HEIGHT,\n\t\t\t\t\toutputContainerOffset: OUTPUT_CONTAINER_OFFSET,\n\t\t\t\t} as unknown as CodeCellLayoutInfo,\n\t\t\t};\n\t\t\tconst notebookEditor = {\n\t\t\t\tscrollTop,\n\t\t\t\tget scrollBottom() {\n\t\t\t\t\treturn scrollBottom;\n\t\t\t\t},\n\t\t\t\tsetScrollTop: (v: number) => {\n\t\t\t\t\t/* notebook scroll changes are not the focus here */\n\t\t\t\t},\n\t\t\t\tgetLayoutInfo: () => ({\n\t\t\t\t\tfontInfo: { lineHeight: LINE_HEIGHT },\n\t\t\t\t\theight: VIEWPORT_HEIGHT,\n\t\t\t\t\tstickyHeight: 0,\n\t\t\t\t}),\n\t\t\t\tgetAbsoluteTopOfElement: () => ELEMENT_TOP,\n\t\t\t\tgetAbsoluteBottomOfElement: () => ELEMENT_TOP + OUTPUT_CONTAINER_OFFSET,\n\t\t\t\tgetHeightOfElement: () => ELEMENT_HEIGHT,\n\t\t\t\tnotebookOptions: {\n\t\t\t\t\tgetLayoutConfiguration: () => ({ editorTopPadding: 6 }),\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst layout = new CodeCellLayout(\n\t\t\t\ttrue,\n\t\t\t\tnotebookEditor as unknown as IActiveNotebookEditorDelegate,\n\t\t\t\tviewCell as CodeCellViewModel,\n\t\t\t\ttemplate as CodeCellRenderTemplate,\n\t\t\t\t{ debug: () => { } },\n\t\t\t\t{ width: 600, height: EDITOR_HEIGHT }\n\t\t\t);\n\t\t\tlayout.layoutEditor('nbDidScroll');\n\t\t\tconst actualTop = parseInt(\n\t\t\t\t(editorPart.style.top || '0').replace(/px$/, '')\n\t\t\t);\n\t\t\tassert.strictEqual(\n\t\t\t\tactualTop,\n\t\t\t\texpected.top,\n\t\t\t\t`scrollTop=${scrollTop}: expected top ${expected.top}, got ${actualTop}`\n\t\t\t);\n\t\t\tassert.strictEqual(\n\t\t\t\tlayout.editorVisibility,\n\t\t\t\texpected.visibility,\n\t\t\t\t`scrollTop=${scrollTop}: expected visibility ${expected.visibility}, got ${layout.editorVisibility}`\n\t\t\t);\n\t\t\tassert.strictEqual(\n\t\t\t\tstubEditor._lastScrollTopSet,\n\t\t\t\texpected.editorScrollTop,\n\t\t\t\t`scrollTop=${scrollTop}: expected editorScrollTop ${expected.editorScrollTop}, got ${stubEditor._lastScrollTopSet}`\n\t\t\t);\n\t\t}\n\t});\n});\n"]}