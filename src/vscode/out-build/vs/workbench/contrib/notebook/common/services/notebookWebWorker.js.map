{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/notebook/common/services/notebookWebWorker.ts","vs/workbench/contrib/notebook/common/services/notebookWebWorker.ts"],"names":[],"mappings":"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","file":"notebookWebWorker.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IDiffChange, ISequence, LcsDiff } from '../../../../../base/common/diff/diff.js';\nimport { doHash, hash, numberHash } from '../../../../../base/common/hash.js';\nimport { IDisposable } from '../../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IWebWorkerServerRequestHandler } from '../../../../../base/common/worker/webWorker.js';\nimport { PieceTreeTextBufferBuilder } from '../../../../../editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { CellKind, IMainCellDto, INotebookDiffResult, IOutputDto, NotebookCellInternalMetadata, NotebookCellMetadata, NotebookCellsChangedEventDto, NotebookCellsChangeType, NotebookCellTextModelSplice, NotebookDocumentMetadata, TransientDocumentMetadata } from '../notebookCommon.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { SearchParams } from '../../../../../editor/common/model/textModelSearch.js';\nimport { MirrorModel } from '../../../../../editor/common/services/textModelSync/textModelSync.impl.js';\nimport { DefaultEndOfLine } from '../../../../../editor/common/model.js';\nimport { IModelChangedEvent } from '../../../../../editor/common/model/mirrorTextModel.js';\nimport { filter } from '../../../../../base/common/objects.js';\nimport { matchCellBasedOnSimilarties } from './notebookCellMatching.js';\nimport { generateUuid } from '../../../../../base/common/uuid.js';\nimport { DiffChange } from '../../../../../base/common/diff/diffChange.js';\nimport { computeDiff } from '../notebookDiff.js';\n\nconst PREFIX_FOR_UNMATCHED_ORIGINAL_CELLS = `unmatchedOriginalCell`;\n\nclass MirrorCell {\n\tprivate readonly textModel: MirrorModel;\n\tprivate _hash?: number;\n\tpublic get eol() {\n\t\treturn this._eol === '\\r\\n' ? DefaultEndOfLine.CRLF : DefaultEndOfLine.LF;\n\t}\n\tconstructor(\n\t\tpublic readonly handle: number,\n\t\turi: URI,\n\t\tsource: string[],\n\t\tprivate readonly _eol: string,\n\t\tversionId: number,\n\t\tpublic language: string,\n\t\tpublic cellKind: CellKind,\n\t\tpublic outputs: IOutputDto[],\n\t\tpublic metadata?: NotebookCellMetadata,\n\t\tpublic internalMetadata?: NotebookCellInternalMetadata,\n\n\t) {\n\t\tthis.textModel = new MirrorModel(uri, source, _eol, versionId);\n\t}\n\n\tonEvents(e: IModelChangedEvent) {\n\t\tthis.textModel.onEvents(e);\n\t\tthis._hash = undefined;\n\t}\n\tgetValue(): string {\n\t\treturn this.textModel.getValue();\n\t}\n\n\tgetLinesContent(): string[] {\n\t\treturn this.textModel.getLinesContent();\n\t}\n\tgetComparisonValue(): number {\n\t\treturn this._hash ??= this._getHash();\n\t}\n\n\tprivate _getHash() {\n\t\tlet hashValue = numberHash(104579, 0);\n\n\t\thashValue = doHash(this.language, hashValue);\n\t\thashValue = doHash(this.getValue(), hashValue);\n\t\thashValue = doHash(this.metadata, hashValue);\n\t\t// For purpose of diffing only cellId matters, rest do not\n\t\thashValue = doHash(this.internalMetadata?.internalId || '', hashValue);\n\t\tfor (const op of this.outputs) {\n\t\t\thashValue = doHash(op.metadata, hashValue);\n\t\t\tfor (const output of op.outputs) {\n\t\t\t\thashValue = doHash(output.mime, hashValue);\n\t\t\t}\n\t\t}\n\n\t\tconst digests = this.outputs.flatMap(op =>\n\t\t\top.outputs.map(o => hash(Array.from(o.data.buffer)))\n\t\t);\n\t\tfor (const digest of digests) {\n\t\t\thashValue = numberHash(digest, hashValue);\n\t\t}\n\n\t\treturn hashValue;\n\t}\n}\n\nclass MirrorNotebookDocument {\n\tconstructor(\n\t\treadonly uri: URI,\n\t\tpublic cells: MirrorCell[],\n\t\tpublic metadata: NotebookDocumentMetadata,\n\t\tpublic transientDocumentMetadata: TransientDocumentMetadata,\n\t) {\n\t}\n\n\tacceptModelChanged(event: NotebookCellsChangedEventDto) {\n\t\t// note that the cell content change is not applied to the MirrorCell\n\t\t// but it's fine as if a cell content is modified after the first diff, its position will not change any more\n\t\t// TODO@rebornix, but it might lead to interesting bugs in the future.\n\t\tevent.rawEvents.forEach(e => {\n\t\t\tif (e.kind === NotebookCellsChangeType.ModelChange) {\n\t\t\t\tthis._spliceNotebookCells(e.changes);\n\t\t\t} else if (e.kind === NotebookCellsChangeType.Move) {\n\t\t\t\tconst cells = this.cells.splice(e.index, 1);\n\t\t\t\tthis.cells.splice(e.newIdx, 0, ...cells);\n\t\t\t} else if (e.kind === NotebookCellsChangeType.Output) {\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.outputs = e.outputs;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellLanguage) {\n\t\t\t\tthis._assertIndex(e.index);\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.language = e.language;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellMetadata) {\n\t\t\t\tthis._assertIndex(e.index);\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.metadata = e.metadata;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellInternalMetadata) {\n\t\t\t\tthis._assertIndex(e.index);\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.internalMetadata = e.internalMetadata;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeDocumentMetadata) {\n\t\t\t\tthis.metadata = e.metadata;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate _assertIndex(index: number): void {\n\t\tif (index < 0 || index >= this.cells.length) {\n\t\t\tthrow new Error(`Illegal index ${index}. Cells length: ${this.cells.length}`);\n\t\t}\n\t}\n\n\t_spliceNotebookCells(splices: NotebookCellTextModelSplice<IMainCellDto>[]) {\n\t\tsplices.reverse().forEach(splice => {\n\t\t\tconst cellDtos = splice[2];\n\t\t\tconst newCells = cellDtos.map(cell => {\n\t\t\t\treturn new MirrorCell(\n\t\t\t\t\tcell.handle,\n\t\t\t\t\tURI.parse(cell.url),\n\t\t\t\t\tcell.source,\n\t\t\t\t\tcell.eol,\n\t\t\t\t\tcell.versionId,\n\t\t\t\t\tcell.language,\n\t\t\t\t\tcell.cellKind,\n\t\t\t\t\tcell.outputs,\n\t\t\t\t\tcell.metadata,\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tthis.cells.splice(splice[0], splice[1], ...newCells);\n\t\t});\n\t}\n}\n\nclass CellSequence implements ISequence {\n\n\tstatic create(textModel: MirrorNotebookDocument) {\n\t\tconst hashValue = textModel.cells.map(c => c.getComparisonValue());\n\t\treturn new CellSequence(hashValue);\n\t}\n\tstatic createWithCellId(cells: MirrorCell[], includeCellContents?: boolean) {\n\t\tconst hashValue = cells.map((c) => {\n\t\t\tif (includeCellContents) {\n\t\t\t\treturn `${doHash(c.internalMetadata?.internalId, numberHash(104579, 0))}#${c.getComparisonValue()}`;\n\t\t\t} else {\n\t\t\t\treturn `${doHash(c.internalMetadata?.internalId, numberHash(104579, 0))}}`;\n\t\t\t}\n\t\t});\n\t\treturn new CellSequence(hashValue);\n\t}\n\n\tconstructor(readonly hashValue: number[] | string[]) { }\n\n\tgetElements(): string[] | number[] | Int32Array {\n\t\treturn this.hashValue;\n\t}\n}\n\nexport class NotebookWorker implements IWebWorkerServerRequestHandler, IDisposable {\n\t_requestHandlerBrand: void = undefined;\n\n\tprivate _models: { [uri: string]: MirrorNotebookDocument };\n\n\tconstructor() {\n\t\tthis._models = Object.create(null);\n\t}\n\tdispose(): void {\n\t}\n\n\tpublic $acceptNewModel(uri: string, metadata: NotebookDocumentMetadata, transientDocumentMetadata: TransientDocumentMetadata, cells: IMainCellDto[]): void {\n\t\tthis._models[uri] = new MirrorNotebookDocument(URI.parse(uri), cells.map(dto => new MirrorCell(\n\t\t\tdto.handle,\n\t\t\tURI.parse(dto.url),\n\t\t\tdto.source,\n\t\t\tdto.eol,\n\t\t\tdto.versionId,\n\t\t\tdto.language,\n\t\t\tdto.cellKind,\n\t\t\tdto.outputs,\n\t\t\tdto.metadata,\n\t\t\tdto.internalMetadata\n\t\t)), metadata, transientDocumentMetadata);\n\t}\n\n\tpublic $acceptModelChanged(strURL: string, event: NotebookCellsChangedEventDto) {\n\t\tconst model = this._models[strURL];\n\t\tmodel?.acceptModelChanged(event);\n\t}\n\n\tpublic $acceptCellModelChanged(strURL: string, handle: number, event: IModelChangedEvent) {\n\t\tconst model = this._models[strURL];\n\t\tmodel.cells.find(cell => cell.handle === handle)?.onEvents(event);\n\t}\n\n\tpublic $acceptRemovedModel(strURL: string): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tdelete this._models[strURL];\n\t}\n\n\tasync $computeDiff(originalUrl: string, modifiedUrl: string): Promise<INotebookDiffResult> {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\n\t\tconst originalModel = new NotebookTextModelFacade(original);\n\t\tconst modifiedModel = new NotebookTextModelFacade(modified);\n\n\t\tconst originalMetadata = filter(original.metadata, key => !original.transientDocumentMetadata[key]);\n\t\tconst modifiedMetadata = filter(modified.metadata, key => !modified.transientDocumentMetadata[key]);\n\t\tconst metadataChanged = JSON.stringify(originalMetadata) !== JSON.stringify(modifiedMetadata);\n\t\t// TODO@DonJayamanne\n\t\t// In the future we might want to avoid computing LCS of outputs\n\t\t// That will make this faster.\n\t\tconst originalDiff = new LcsDiff(CellSequence.create(original), CellSequence.create(modified)).ComputeDiff(false);\n\t\tif (originalDiff.changes.length === 0) {\n\t\t\treturn {\n\t\t\t\tmetadataChanged,\n\t\t\t\tcellsDiff: originalDiff\n\t\t\t};\n\t\t}\n\n\t\t// This will return the mapping of the cells and what cells were inserted/deleted.\n\t\t// We do not care much about accuracy of the diff, but care about the mapping of unmodified cells.\n\t\t// That can be used as anchor points to find the cells that have changed.\n\t\t// And on cells that have changed, we can use similarity algorithms to find the mapping.\n\t\t// Eg as mentioned earlier, its possible after similarity algorithms we find that cells weren't inserted/deleted but were just modified.\n\t\tconst cellMapping = computeDiff(originalModel, modifiedModel, { cellsDiff: { changes: originalDiff.changes, quitEarly: false }, metadataChanged: false, }).cellDiffInfo;\n\n\t\t// If we have no insertions/deletions, then this is a good diffing.\n\t\tif (cellMapping.every(c => c.type === 'modified' || c.type === 'unchanged')) {\n\t\t\treturn {\n\t\t\t\tmetadataChanged,\n\t\t\t\tcellsDiff: originalDiff\n\t\t\t};\n\t\t}\n\n\t\tlet diffUsingCellIds = this.canComputeDiffWithCellIds(original, modified);\n\t\tif (!diffUsingCellIds) {\n\t\t\t/**\n\t\t\t * Assume we have cells as follows\n\t\t\t * Original   Modified\n\t\t\t * A\t  \t\tA\n\t\t\t * B\t\t\tB\n\t\t\t * C\t\t\te\n\t\t\t * D\t\t\tF\n\t\t\t * E\n\t\t\t * F\n\t\t\t *\n\t\t\t * Using LCS we know easily that A, B cells match.\n\t\t\t * Using LCS it would look like C changed to e\n\t\t\t * Using LCS D & E were removed.\n\t\t\t *\n\t\t\t * A human would be able to tell that cell C, D were removed.\n\t\t\t * A human can tell that E changed to e because the code in the cells are very similar.\n\t\t\t * Note the words `similar`, humans try to match cells based on certain heuristics.\n\t\t\t * & the most obvious one is the similarity of the code in the cells.\n\t\t\t *\n\t\t\t * LCS has no notion of similarity, it only knows about equality.\n\t\t\t * We can use other algorithms to find similarity.\n\t\t\t * So if we eliminate A, B, we are left with C, D, E, F and we need to find what they map to in `e, F` in modifed document.\n\t\t\t * We can use a similarity algorithm to find that.\n\t\t\t *\n\t\t\t * The purpose of using LCS first is to find the cells that have not changed.\n\t\t\t * This avoids the need to use similarity algorithms on all cells.\n\t\t\t *\n\t\t\t * At the end of the day what we need is as follows\n\t\t\t * A <=> A\n\t\t\t * B <=> B\n\t\t\t * C => Deleted\n\t\t\t * D => Deleted\n\t\t\t * E => e\n\t\t\t * F => F\n\t\t\t */\n\n\n\n\t\t\t// Note, if cells are swapped, then this compilicates things\n\t\t\t// Trying to solve diff manually is not easy.\n\t\t\t// Lets instead use LCS find the cells that haven't changed,\n\t\t\t// & the cells that have.\n\t\t\t// For the range of cells that have change, lets see if we can get better results using similarity algorithms.\n\t\t\t// Assume we have\n\t\t\t// Code Cell = print(\"Hello World\")\n\t\t\t// Code Cell = print(\"Foo Bar\")\n\t\t\t// We now change this to\n\t\t\t// MD Cell = # Description\n\t\t\t// Code Cell = print(\"Hello WorldZ\")\n\t\t\t// Code Cell = print(\"Foo BarZ\")\n\t\t\t// LCS will tell us that everything changed.\n\t\t\t// But using similarity algorithms we can tell that the first cell is new and last 2 changed.\n\n\n\n\t\t\t// Lets try the similarity algorithms on all cells.\n\t\t\t// We might fare better.\n\t\t\tconst result = matchCellBasedOnSimilarties(modified.cells, original.cells);\n\t\t\t// If we have at least one match, then great.\n\t\t\tif (result.some(c => c.original !== -1)) {\n\t\t\t\t// We have managed to find similarities between cells.\n\t\t\t\t// Now we can definitely find what cell is new/removed.\n\t\t\t\tthis.updateCellIdsBasedOnMappings(result, original.cells, modified.cells);\n\t\t\t\tdiffUsingCellIds = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!diffUsingCellIds) {\n\t\t\treturn {\n\t\t\t\tmetadataChanged,\n\t\t\t\tcellsDiff: originalDiff\n\t\t\t};\n\t\t}\n\n\t\t// At this stage we can use internalMetadata.cellId for tracking changes.\n\t\t// I.e. we compute LCS diff and the hashes of some cells from original will be equal to that in modified as we're using cellId.\n\t\t// Thus we can find what cells are new/deleted.\n\t\t// After that we can find whether the contents of the cells changed.\n\t\tconst cellsInsertedOrDeletedDiff = new LcsDiff(CellSequence.createWithCellId(original.cells), CellSequence.createWithCellId(modified.cells)).ComputeDiff(false);\n\t\tconst cellDiffInfo = computeDiff(originalModel, modifiedModel, { cellsDiff: { changes: cellsInsertedOrDeletedDiff.changes, quitEarly: false }, metadataChanged: false, }).cellDiffInfo;\n\n\t\tlet processedIndex = 0;\n\t\tconst changes: IDiffChange[] = [];\n\t\tcellsInsertedOrDeletedDiff.changes.forEach(change => {\n\t\t\tif (!change.originalLength && change.modifiedLength) {\n\t\t\t\t// Inserted.\n\t\t\t\t// Find all modified cells before this.\n\t\t\t\tconst changeIndex = cellDiffInfo.findIndex(c => c.type === 'insert' && c.modifiedCellIndex === change.modifiedStart);\n\t\t\t\tcellDiffInfo.slice(processedIndex, changeIndex).forEach(c => {\n\t\t\t\t\tif (c.type === 'unchanged' || c.type === 'modified') {\n\t\t\t\t\t\tconst originalCell = original.cells[c.originalCellIndex];\n\t\t\t\t\t\tconst modifiedCell = modified.cells[c.modifiedCellIndex];\n\t\t\t\t\t\tconst changed = c.type === 'modified' || originalCell.getComparisonValue() !== modifiedCell.getComparisonValue();\n\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\tchanges.push(new DiffChange(c.originalCellIndex, 1, c.modifiedCellIndex, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchanges.push(change);\n\t\t\t\tprocessedIndex = changeIndex + 1;\n\t\t\t} else if (change.originalLength && !change.modifiedLength) {\n\t\t\t\t// Deleted.\n\t\t\t\t// Find all modified cells before this.\n\t\t\t\tconst changeIndex = cellDiffInfo.findIndex(c => c.type === 'delete' && c.originalCellIndex === change.originalStart);\n\t\t\t\tcellDiffInfo.slice(processedIndex, changeIndex).forEach(c => {\n\t\t\t\t\tif (c.type === 'unchanged' || c.type === 'modified') {\n\t\t\t\t\t\tconst originalCell = original.cells[c.originalCellIndex];\n\t\t\t\t\t\tconst modifiedCell = modified.cells[c.modifiedCellIndex];\n\t\t\t\t\t\tconst changed = c.type === 'modified' || originalCell.getComparisonValue() !== modifiedCell.getComparisonValue();\n\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\tchanges.push(new DiffChange(c.originalCellIndex, 1, c.modifiedCellIndex, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchanges.push(change);\n\t\t\t\tprocessedIndex = changeIndex + 1;\n\t\t\t} else {\n\t\t\t\t// This could be a situation where a cell has been deleted on left and inserted on the right.\n\t\t\t\t// E.g. markdown cell deleted and code cell inserted.\n\t\t\t\t// But LCS shows them as a modification.\n\t\t\t\tconst changeIndex = cellDiffInfo.findIndex(c => (c.type === 'delete' && c.originalCellIndex === change.originalStart) || (c.type === 'insert' && c.modifiedCellIndex === change.modifiedStart));\n\t\t\t\tcellDiffInfo.slice(processedIndex, changeIndex).forEach(c => {\n\t\t\t\t\tif (c.type === 'unchanged' || c.type === 'modified') {\n\t\t\t\t\t\tconst originalCell = original.cells[c.originalCellIndex];\n\t\t\t\t\t\tconst modifiedCell = modified.cells[c.modifiedCellIndex];\n\t\t\t\t\t\tconst changed = c.type === 'modified' || originalCell.getComparisonValue() !== modifiedCell.getComparisonValue();\n\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\tchanges.push(new DiffChange(c.originalCellIndex, 1, c.modifiedCellIndex, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchanges.push(change);\n\t\t\t\tprocessedIndex = changeIndex + 1;\n\t\t\t}\n\t\t});\n\t\tcellDiffInfo.slice(processedIndex).forEach(c => {\n\t\t\tif (c.type === 'unchanged' || c.type === 'modified') {\n\t\t\t\tconst originalCell = original.cells[c.originalCellIndex];\n\t\t\t\tconst modifiedCell = modified.cells[c.modifiedCellIndex];\n\t\t\t\tconst changed = c.type === 'modified' || originalCell.getComparisonValue() !== modifiedCell.getComparisonValue();\n\t\t\t\tif (changed) {\n\t\t\t\t\tchanges.push(new DiffChange(c.originalCellIndex, 1, c.modifiedCellIndex, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tmetadataChanged,\n\t\t\tcellsDiff: {\n\t\t\t\tchanges,\n\t\t\t\tquitEarly: false\n\t\t\t}\n\t\t};\n\t}\n\n\tcanComputeDiffWithCellIds(original: MirrorNotebookDocument, modified: MirrorNotebookDocument): boolean {\n\t\treturn this.canComputeDiffWithCellInternalIds(original, modified) || this.canComputeDiffWithCellMetadataIds(original, modified);\n\t}\n\n\tcanComputeDiffWithCellInternalIds(original: MirrorNotebookDocument, modified: MirrorNotebookDocument): boolean {\n\t\tconst originalCellIndexIds = original.cells.map((cell, index) => ({ index, id: (cell.internalMetadata?.internalId || '') as string }));\n\t\tconst modifiedCellIndexIds = modified.cells.map((cell, index) => ({ index, id: (cell.internalMetadata?.internalId || '') as string }));\n\t\t// If we have a cell without an id, do not use metadata.id for diffing.\n\t\tif (originalCellIndexIds.some(c => !c.id) || modifiedCellIndexIds.some(c => !c.id)) {\n\t\t\treturn false;\n\t\t}\n\t\t// If none of the ids in original can be found in modified, then we can't use metadata.id for diffing.\n\t\t// I.e. everything is new, no point trying.\n\t\treturn originalCellIndexIds.some(c => modifiedCellIndexIds.find(m => m.id === c.id));\n\t}\n\n\tcanComputeDiffWithCellMetadataIds(original: MirrorNotebookDocument, modified: MirrorNotebookDocument): boolean {\n\t\tconst originalCellIndexIds = original.cells.map((cell, index) => ({ index, id: (cell.metadata?.id || '') as string }));\n\t\tconst modifiedCellIndexIds = modified.cells.map((cell, index) => ({ index, id: (cell.metadata?.id || '') as string }));\n\t\t// If we have a cell without an id, do not use metadata.id for diffing.\n\t\tif (originalCellIndexIds.some(c => !c.id) || modifiedCellIndexIds.some(c => !c.id)) {\n\t\t\treturn false;\n\t\t}\n\t\t// If none of the ids in original can be found in modified, then we can't use metadata.id for diffing.\n\t\t// I.e. everything is new, no point trying.\n\t\tif (originalCellIndexIds.every(c => !modifiedCellIndexIds.find(m => m.id === c.id))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Internally we use internalMetadata.cellId for diffing, hence update the internalMetadata.cellId\n\t\toriginal.cells.map((cell, index) => {\n\t\t\tcell.internalMetadata = cell.internalMetadata || {};\n\t\t\tcell.internalMetadata.internalId = cell.metadata?.id as string || '';\n\t\t});\n\t\tmodified.cells.map((cell, index) => {\n\t\t\tcell.internalMetadata = cell.internalMetadata || {};\n\t\t\tcell.internalMetadata.internalId = cell.metadata?.id as string || '';\n\t\t});\n\t\treturn true;\n\t}\n\n\n\tisOriginalCellMatchedWithModifiedCell(originalCell: MirrorCell) {\n\t\treturn (originalCell.internalMetadata?.internalId as string || '').startsWith(PREFIX_FOR_UNMATCHED_ORIGINAL_CELLS);\n\t}\n\tupdateCellIdsBasedOnMappings(mappings: { modified: number; original: number }[], originalCells: MirrorCell[], modifiedCells: MirrorCell[]): boolean {\n\t\tconst uuids = new Map<number, string>();\n\t\toriginalCells.map((cell, index) => {\n\t\t\tcell.internalMetadata = cell.internalMetadata || { internalId: '' };\n\t\t\tcell.internalMetadata.internalId = `${PREFIX_FOR_UNMATCHED_ORIGINAL_CELLS}${generateUuid()}`;\n\t\t\tconst found = mappings.find(r => r.original === index);\n\t\t\tif (found) {\n\t\t\t\t// Do not use the indexes as ids.\n\t\t\t\t// If we do, then the hashes will be very similar except for last digit.\n\t\t\t\tcell.internalMetadata.internalId = generateUuid();\n\t\t\t\tuuids.set(found.modified, cell.internalMetadata.internalId as string);\n\t\t\t}\n\t\t});\n\t\tmodifiedCells.map((cell, index) => {\n\t\t\tcell.internalMetadata = cell.internalMetadata || { internalId: '' };\n\t\t\tcell.internalMetadata.internalId = uuids.get(index) ?? generateUuid();\n\t\t});\n\t\treturn true;\n\t}\n\n\t$canPromptRecommendation(modelUrl: string): boolean {\n\t\tconst model = this._getModel(modelUrl);\n\t\tconst cells = model.cells;\n\n\t\tfor (let i = 0; i < cells.length; i++) {\n\t\t\tconst cell = cells[i];\n\t\t\tif (cell.cellKind === CellKind.Markup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cell.language !== 'python') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst searchParams = new SearchParams('import\\\\s*pandas|from\\\\s*pandas', true, false, null);\n\t\t\tconst searchData = searchParams.parseSearchRequest();\n\n\t\t\tif (!searchData) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst builder = new PieceTreeTextBufferBuilder();\n\t\t\tbuilder.acceptChunk(cell.getValue());\n\t\t\tconst bufferFactory = builder.finish(true);\n\t\t\tconst textBuffer = bufferFactory.create(cell.eol).textBuffer;\n\n\t\t\tconst lineCount = textBuffer.getLineCount();\n\t\t\tconst maxLineCount = Math.min(lineCount, 20);\n\t\t\tconst range = new Range(1, 1, maxLineCount, textBuffer.getLineLength(maxLineCount) + 1);\n\t\t\tconst cellMatches = textBuffer.findMatchesLineByLine(range, searchData, true, 1);\n\t\t\tif (cellMatches.length > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprotected _getModel(uri: string): MirrorNotebookDocument {\n\t\treturn this._models[uri];\n\t}\n}\n\nexport function create(): IWebWorkerServerRequestHandler {\n\treturn new NotebookWorker();\n}\n\nexport type CellDiffInfo = {\n\toriginalCellIndex: number;\n\tmodifiedCellIndex: number;\n\ttype: 'unchanged' | 'modified';\n} |\n{\n\toriginalCellIndex: number;\n\ttype: 'delete';\n} |\n{\n\tmodifiedCellIndex: number;\n\ttype: 'insert';\n};\n\ninterface ICell {\n\tcellKind: CellKind;\n\tgetHashValue(): number;\n\tequal(cell: ICell): boolean;\n}\n\nclass NotebookTextModelFacade {\n\tpublic readonly cells: readonly ICell[];\n\tconstructor(\n\t\treadonly notebook: MirrorNotebookDocument\n\t) {\n\n\t\tthis.cells = notebook.cells.map(cell => new NotebookCellTextModelFacade(cell));\n\t}\n\n}\nclass NotebookCellTextModelFacade implements ICell {\n\tget cellKind(): CellKind {\n\t\treturn this.cell.cellKind;\n\t}\n\tconstructor(\n\t\tprivate readonly cell: MirrorCell\n\t) {\n\t}\n\tgetHashValue(): number {\n\t\treturn this.cell.getComparisonValue();\n\t}\n\tequal(cell: ICell): boolean {\n\t\tif (cell.cellKind !== this.cellKind) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getHashValue() === cell.getHashValue();\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IDiffChange, ISequence, LcsDiff } from '../../../../../base/common/diff/diff.js';\nimport { doHash, hash, numberHash } from '../../../../../base/common/hash.js';\nimport { IDisposable } from '../../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IWebWorkerServerRequestHandler } from '../../../../../base/common/worker/webWorker.js';\nimport { PieceTreeTextBufferBuilder } from '../../../../../editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { CellKind, IMainCellDto, INotebookDiffResult, IOutputDto, NotebookCellInternalMetadata, NotebookCellMetadata, NotebookCellsChangedEventDto, NotebookCellsChangeType, NotebookCellTextModelSplice, NotebookDocumentMetadata, TransientDocumentMetadata } from '../notebookCommon.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { SearchParams } from '../../../../../editor/common/model/textModelSearch.js';\nimport { MirrorModel } from '../../../../../editor/common/services/textModelSync/textModelSync.impl.js';\nimport { DefaultEndOfLine } from '../../../../../editor/common/model.js';\nimport { IModelChangedEvent } from '../../../../../editor/common/model/mirrorTextModel.js';\nimport { filter } from '../../../../../base/common/objects.js';\nimport { matchCellBasedOnSimilarties } from './notebookCellMatching.js';\nimport { generateUuid } from '../../../../../base/common/uuid.js';\nimport { DiffChange } from '../../../../../base/common/diff/diffChange.js';\nimport { computeDiff } from '../notebookDiff.js';\n\nconst PREFIX_FOR_UNMATCHED_ORIGINAL_CELLS = `unmatchedOriginalCell`;\n\nclass MirrorCell {\n\tprivate readonly textModel: MirrorModel;\n\tprivate _hash?: number;\n\tpublic get eol() {\n\t\treturn this._eol === '\\r\\n' ? DefaultEndOfLine.CRLF : DefaultEndOfLine.LF;\n\t}\n\tconstructor(\n\t\tpublic readonly handle: number,\n\t\turi: URI,\n\t\tsource: string[],\n\t\tprivate readonly _eol: string,\n\t\tversionId: number,\n\t\tpublic language: string,\n\t\tpublic cellKind: CellKind,\n\t\tpublic outputs: IOutputDto[],\n\t\tpublic metadata?: NotebookCellMetadata,\n\t\tpublic internalMetadata?: NotebookCellInternalMetadata,\n\n\t) {\n\t\tthis.textModel = new MirrorModel(uri, source, _eol, versionId);\n\t}\n\n\tonEvents(e: IModelChangedEvent) {\n\t\tthis.textModel.onEvents(e);\n\t\tthis._hash = undefined;\n\t}\n\tgetValue(): string {\n\t\treturn this.textModel.getValue();\n\t}\n\n\tgetLinesContent(): string[] {\n\t\treturn this.textModel.getLinesContent();\n\t}\n\tgetComparisonValue(): number {\n\t\treturn this._hash ??= this._getHash();\n\t}\n\n\tprivate _getHash() {\n\t\tlet hashValue = numberHash(104579, 0);\n\n\t\thashValue = doHash(this.language, hashValue);\n\t\thashValue = doHash(this.getValue(), hashValue);\n\t\thashValue = doHash(this.metadata, hashValue);\n\t\t// For purpose of diffing only cellId matters, rest do not\n\t\thashValue = doHash(this.internalMetadata?.internalId || '', hashValue);\n\t\tfor (const op of this.outputs) {\n\t\t\thashValue = doHash(op.metadata, hashValue);\n\t\t\tfor (const output of op.outputs) {\n\t\t\t\thashValue = doHash(output.mime, hashValue);\n\t\t\t}\n\t\t}\n\n\t\tconst digests = this.outputs.flatMap(op =>\n\t\t\top.outputs.map(o => hash(Array.from(o.data.buffer)))\n\t\t);\n\t\tfor (const digest of digests) {\n\t\t\thashValue = numberHash(digest, hashValue);\n\t\t}\n\n\t\treturn hashValue;\n\t}\n}\n\nclass MirrorNotebookDocument {\n\tconstructor(\n\t\treadonly uri: URI,\n\t\tpublic cells: MirrorCell[],\n\t\tpublic metadata: NotebookDocumentMetadata,\n\t\tpublic transientDocumentMetadata: TransientDocumentMetadata,\n\t) {\n\t}\n\n\tacceptModelChanged(event: NotebookCellsChangedEventDto) {\n\t\t// note that the cell content change is not applied to the MirrorCell\n\t\t// but it's fine as if a cell content is modified after the first diff, its position will not change any more\n\t\t// TODO@rebornix, but it might lead to interesting bugs in the future.\n\t\tevent.rawEvents.forEach(e => {\n\t\t\tif (e.kind === NotebookCellsChangeType.ModelChange) {\n\t\t\t\tthis._spliceNotebookCells(e.changes);\n\t\t\t} else if (e.kind === NotebookCellsChangeType.Move) {\n\t\t\t\tconst cells = this.cells.splice(e.index, 1);\n\t\t\t\tthis.cells.splice(e.newIdx, 0, ...cells);\n\t\t\t} else if (e.kind === NotebookCellsChangeType.Output) {\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.outputs = e.outputs;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellLanguage) {\n\t\t\t\tthis._assertIndex(e.index);\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.language = e.language;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellMetadata) {\n\t\t\t\tthis._assertIndex(e.index);\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.metadata = e.metadata;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellInternalMetadata) {\n\t\t\t\tthis._assertIndex(e.index);\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.internalMetadata = e.internalMetadata;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeDocumentMetadata) {\n\t\t\t\tthis.metadata = e.metadata;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate _assertIndex(index: number): void {\n\t\tif (index < 0 || index >= this.cells.length) {\n\t\t\tthrow new Error(`Illegal index ${index}. Cells length: ${this.cells.length}`);\n\t\t}\n\t}\n\n\t_spliceNotebookCells(splices: NotebookCellTextModelSplice<IMainCellDto>[]) {\n\t\tsplices.reverse().forEach(splice => {\n\t\t\tconst cellDtos = splice[2];\n\t\t\tconst newCells = cellDtos.map(cell => {\n\t\t\t\treturn new MirrorCell(\n\t\t\t\t\tcell.handle,\n\t\t\t\t\tURI.parse(cell.url),\n\t\t\t\t\tcell.source,\n\t\t\t\t\tcell.eol,\n\t\t\t\t\tcell.versionId,\n\t\t\t\t\tcell.language,\n\t\t\t\t\tcell.cellKind,\n\t\t\t\t\tcell.outputs,\n\t\t\t\t\tcell.metadata,\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tthis.cells.splice(splice[0], splice[1], ...newCells);\n\t\t});\n\t}\n}\n\nclass CellSequence implements ISequence {\n\n\tstatic create(textModel: MirrorNotebookDocument) {\n\t\tconst hashValue = textModel.cells.map(c => c.getComparisonValue());\n\t\treturn new CellSequence(hashValue);\n\t}\n\tstatic createWithCellId(cells: MirrorCell[], includeCellContents?: boolean) {\n\t\tconst hashValue = cells.map((c) => {\n\t\t\tif (includeCellContents) {\n\t\t\t\treturn `${doHash(c.internalMetadata?.internalId, numberHash(104579, 0))}#${c.getComparisonValue()}`;\n\t\t\t} else {\n\t\t\t\treturn `${doHash(c.internalMetadata?.internalId, numberHash(104579, 0))}}`;\n\t\t\t}\n\t\t});\n\t\treturn new CellSequence(hashValue);\n\t}\n\n\tconstructor(readonly hashValue: number[] | string[]) { }\n\n\tgetElements(): string[] | number[] | Int32Array {\n\t\treturn this.hashValue;\n\t}\n}\n\nexport class NotebookWorker implements IWebWorkerServerRequestHandler, IDisposable {\n\t_requestHandlerBrand: void = undefined;\n\n\tprivate _models: { [uri: string]: MirrorNotebookDocument };\n\n\tconstructor() {\n\t\tthis._models = Object.create(null);\n\t}\n\tdispose(): void {\n\t}\n\n\tpublic $acceptNewModel(uri: string, metadata: NotebookDocumentMetadata, transientDocumentMetadata: TransientDocumentMetadata, cells: IMainCellDto[]): void {\n\t\tthis._models[uri] = new MirrorNotebookDocument(URI.parse(uri), cells.map(dto => new MirrorCell(\n\t\t\tdto.handle,\n\t\t\tURI.parse(dto.url),\n\t\t\tdto.source,\n\t\t\tdto.eol,\n\t\t\tdto.versionId,\n\t\t\tdto.language,\n\t\t\tdto.cellKind,\n\t\t\tdto.outputs,\n\t\t\tdto.metadata,\n\t\t\tdto.internalMetadata\n\t\t)), metadata, transientDocumentMetadata);\n\t}\n\n\tpublic $acceptModelChanged(strURL: string, event: NotebookCellsChangedEventDto) {\n\t\tconst model = this._models[strURL];\n\t\tmodel?.acceptModelChanged(event);\n\t}\n\n\tpublic $acceptCellModelChanged(strURL: string, handle: number, event: IModelChangedEvent) {\n\t\tconst model = this._models[strURL];\n\t\tmodel.cells.find(cell => cell.handle === handle)?.onEvents(event);\n\t}\n\n\tpublic $acceptRemovedModel(strURL: string): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tdelete this._models[strURL];\n\t}\n\n\tasync $computeDiff(originalUrl: string, modifiedUrl: string): Promise<INotebookDiffResult> {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\n\t\tconst originalModel = new NotebookTextModelFacade(original);\n\t\tconst modifiedModel = new NotebookTextModelFacade(modified);\n\n\t\tconst originalMetadata = filter(original.metadata, key => !original.transientDocumentMetadata[key]);\n\t\tconst modifiedMetadata = filter(modified.metadata, key => !modified.transientDocumentMetadata[key]);\n\t\tconst metadataChanged = JSON.stringify(originalMetadata) !== JSON.stringify(modifiedMetadata);\n\t\t// TODO@DonJayamanne\n\t\t// In the future we might want to avoid computing LCS of outputs\n\t\t// That will make this faster.\n\t\tconst originalDiff = new LcsDiff(CellSequence.create(original), CellSequence.create(modified)).ComputeDiff(false);\n\t\tif (originalDiff.changes.length === 0) {\n\t\t\treturn {\n\t\t\t\tmetadataChanged,\n\t\t\t\tcellsDiff: originalDiff\n\t\t\t};\n\t\t}\n\n\t\t// This will return the mapping of the cells and what cells were inserted/deleted.\n\t\t// We do not care much about accuracy of the diff, but care about the mapping of unmodified cells.\n\t\t// That can be used as anchor points to find the cells that have changed.\n\t\t// And on cells that have changed, we can use similarity algorithms to find the mapping.\n\t\t// Eg as mentioned earlier, its possible after similarity algorithms we find that cells weren't inserted/deleted but were just modified.\n\t\tconst cellMapping = computeDiff(originalModel, modifiedModel, { cellsDiff: { changes: originalDiff.changes, quitEarly: false }, metadataChanged: false, }).cellDiffInfo;\n\n\t\t// If we have no insertions/deletions, then this is a good diffing.\n\t\tif (cellMapping.every(c => c.type === 'modified' || c.type === 'unchanged')) {\n\t\t\treturn {\n\t\t\t\tmetadataChanged,\n\t\t\t\tcellsDiff: originalDiff\n\t\t\t};\n\t\t}\n\n\t\tlet diffUsingCellIds = this.canComputeDiffWithCellIds(original, modified);\n\t\tif (!diffUsingCellIds) {\n\t\t\t/**\n\t\t\t * Assume we have cells as follows\n\t\t\t * Original   Modified\n\t\t\t * A\t  \t\tA\n\t\t\t * B\t\t\tB\n\t\t\t * C\t\t\te\n\t\t\t * D\t\t\tF\n\t\t\t * E\n\t\t\t * F\n\t\t\t *\n\t\t\t * Using LCS we know easily that A, B cells match.\n\t\t\t * Using LCS it would look like C changed to e\n\t\t\t * Using LCS D & E were removed.\n\t\t\t *\n\t\t\t * A human would be able to tell that cell C, D were removed.\n\t\t\t * A human can tell that E changed to e because the code in the cells are very similar.\n\t\t\t * Note the words `similar`, humans try to match cells based on certain heuristics.\n\t\t\t * & the most obvious one is the similarity of the code in the cells.\n\t\t\t *\n\t\t\t * LCS has no notion of similarity, it only knows about equality.\n\t\t\t * We can use other algorithms to find similarity.\n\t\t\t * So if we eliminate A, B, we are left with C, D, E, F and we need to find what they map to in `e, F` in modifed document.\n\t\t\t * We can use a similarity algorithm to find that.\n\t\t\t *\n\t\t\t * The purpose of using LCS first is to find the cells that have not changed.\n\t\t\t * This avoids the need to use similarity algorithms on all cells.\n\t\t\t *\n\t\t\t * At the end of the day what we need is as follows\n\t\t\t * A <=> A\n\t\t\t * B <=> B\n\t\t\t * C => Deleted\n\t\t\t * D => Deleted\n\t\t\t * E => e\n\t\t\t * F => F\n\t\t\t */\n\n\n\n\t\t\t// Note, if cells are swapped, then this compilicates things\n\t\t\t// Trying to solve diff manually is not easy.\n\t\t\t// Lets instead use LCS find the cells that haven't changed,\n\t\t\t// & the cells that have.\n\t\t\t// For the range of cells that have change, lets see if we can get better results using similarity algorithms.\n\t\t\t// Assume we have\n\t\t\t// Code Cell = print(\"Hello World\")\n\t\t\t// Code Cell = print(\"Foo Bar\")\n\t\t\t// We now change this to\n\t\t\t// MD Cell = # Description\n\t\t\t// Code Cell = print(\"Hello WorldZ\")\n\t\t\t// Code Cell = print(\"Foo BarZ\")\n\t\t\t// LCS will tell us that everything changed.\n\t\t\t// But using similarity algorithms we can tell that the first cell is new and last 2 changed.\n\n\n\n\t\t\t// Lets try the similarity algorithms on all cells.\n\t\t\t// We might fare better.\n\t\t\tconst result = matchCellBasedOnSimilarties(modified.cells, original.cells);\n\t\t\t// If we have at least one match, then great.\n\t\t\tif (result.some(c => c.original !== -1)) {\n\t\t\t\t// We have managed to find similarities between cells.\n\t\t\t\t// Now we can definitely find what cell is new/removed.\n\t\t\t\tthis.updateCellIdsBasedOnMappings(result, original.cells, modified.cells);\n\t\t\t\tdiffUsingCellIds = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!diffUsingCellIds) {\n\t\t\treturn {\n\t\t\t\tmetadataChanged,\n\t\t\t\tcellsDiff: originalDiff\n\t\t\t};\n\t\t}\n\n\t\t// At this stage we can use internalMetadata.cellId for tracking changes.\n\t\t// I.e. we compute LCS diff and the hashes of some cells from original will be equal to that in modified as we're using cellId.\n\t\t// Thus we can find what cells are new/deleted.\n\t\t// After that we can find whether the contents of the cells changed.\n\t\tconst cellsInsertedOrDeletedDiff = new LcsDiff(CellSequence.createWithCellId(original.cells), CellSequence.createWithCellId(modified.cells)).ComputeDiff(false);\n\t\tconst cellDiffInfo = computeDiff(originalModel, modifiedModel, { cellsDiff: { changes: cellsInsertedOrDeletedDiff.changes, quitEarly: false }, metadataChanged: false, }).cellDiffInfo;\n\n\t\tlet processedIndex = 0;\n\t\tconst changes: IDiffChange[] = [];\n\t\tcellsInsertedOrDeletedDiff.changes.forEach(change => {\n\t\t\tif (!change.originalLength && change.modifiedLength) {\n\t\t\t\t// Inserted.\n\t\t\t\t// Find all modified cells before this.\n\t\t\t\tconst changeIndex = cellDiffInfo.findIndex(c => c.type === 'insert' && c.modifiedCellIndex === change.modifiedStart);\n\t\t\t\tcellDiffInfo.slice(processedIndex, changeIndex).forEach(c => {\n\t\t\t\t\tif (c.type === 'unchanged' || c.type === 'modified') {\n\t\t\t\t\t\tconst originalCell = original.cells[c.originalCellIndex];\n\t\t\t\t\t\tconst modifiedCell = modified.cells[c.modifiedCellIndex];\n\t\t\t\t\t\tconst changed = c.type === 'modified' || originalCell.getComparisonValue() !== modifiedCell.getComparisonValue();\n\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\tchanges.push(new DiffChange(c.originalCellIndex, 1, c.modifiedCellIndex, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchanges.push(change);\n\t\t\t\tprocessedIndex = changeIndex + 1;\n\t\t\t} else if (change.originalLength && !change.modifiedLength) {\n\t\t\t\t// Deleted.\n\t\t\t\t// Find all modified cells before this.\n\t\t\t\tconst changeIndex = cellDiffInfo.findIndex(c => c.type === 'delete' && c.originalCellIndex === change.originalStart);\n\t\t\t\tcellDiffInfo.slice(processedIndex, changeIndex).forEach(c => {\n\t\t\t\t\tif (c.type === 'unchanged' || c.type === 'modified') {\n\t\t\t\t\t\tconst originalCell = original.cells[c.originalCellIndex];\n\t\t\t\t\t\tconst modifiedCell = modified.cells[c.modifiedCellIndex];\n\t\t\t\t\t\tconst changed = c.type === 'modified' || originalCell.getComparisonValue() !== modifiedCell.getComparisonValue();\n\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\tchanges.push(new DiffChange(c.originalCellIndex, 1, c.modifiedCellIndex, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchanges.push(change);\n\t\t\t\tprocessedIndex = changeIndex + 1;\n\t\t\t} else {\n\t\t\t\t// This could be a situation where a cell has been deleted on left and inserted on the right.\n\t\t\t\t// E.g. markdown cell deleted and code cell inserted.\n\t\t\t\t// But LCS shows them as a modification.\n\t\t\t\tconst changeIndex = cellDiffInfo.findIndex(c => (c.type === 'delete' && c.originalCellIndex === change.originalStart) || (c.type === 'insert' && c.modifiedCellIndex === change.modifiedStart));\n\t\t\t\tcellDiffInfo.slice(processedIndex, changeIndex).forEach(c => {\n\t\t\t\t\tif (c.type === 'unchanged' || c.type === 'modified') {\n\t\t\t\t\t\tconst originalCell = original.cells[c.originalCellIndex];\n\t\t\t\t\t\tconst modifiedCell = modified.cells[c.modifiedCellIndex];\n\t\t\t\t\t\tconst changed = c.type === 'modified' || originalCell.getComparisonValue() !== modifiedCell.getComparisonValue();\n\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\tchanges.push(new DiffChange(c.originalCellIndex, 1, c.modifiedCellIndex, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchanges.push(change);\n\t\t\t\tprocessedIndex = changeIndex + 1;\n\t\t\t}\n\t\t});\n\t\tcellDiffInfo.slice(processedIndex).forEach(c => {\n\t\t\tif (c.type === 'unchanged' || c.type === 'modified') {\n\t\t\t\tconst originalCell = original.cells[c.originalCellIndex];\n\t\t\t\tconst modifiedCell = modified.cells[c.modifiedCellIndex];\n\t\t\t\tconst changed = c.type === 'modified' || originalCell.getComparisonValue() !== modifiedCell.getComparisonValue();\n\t\t\t\tif (changed) {\n\t\t\t\t\tchanges.push(new DiffChange(c.originalCellIndex, 1, c.modifiedCellIndex, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tmetadataChanged,\n\t\t\tcellsDiff: {\n\t\t\t\tchanges,\n\t\t\t\tquitEarly: false\n\t\t\t}\n\t\t};\n\t}\n\n\tcanComputeDiffWithCellIds(original: MirrorNotebookDocument, modified: MirrorNotebookDocument): boolean {\n\t\treturn this.canComputeDiffWithCellInternalIds(original, modified) || this.canComputeDiffWithCellMetadataIds(original, modified);\n\t}\n\n\tcanComputeDiffWithCellInternalIds(original: MirrorNotebookDocument, modified: MirrorNotebookDocument): boolean {\n\t\tconst originalCellIndexIds = original.cells.map((cell, index) => ({ index, id: (cell.internalMetadata?.internalId || '') as string }));\n\t\tconst modifiedCellIndexIds = modified.cells.map((cell, index) => ({ index, id: (cell.internalMetadata?.internalId || '') as string }));\n\t\t// If we have a cell without an id, do not use metadata.id for diffing.\n\t\tif (originalCellIndexIds.some(c => !c.id) || modifiedCellIndexIds.some(c => !c.id)) {\n\t\t\treturn false;\n\t\t}\n\t\t// If none of the ids in original can be found in modified, then we can't use metadata.id for diffing.\n\t\t// I.e. everything is new, no point trying.\n\t\treturn originalCellIndexIds.some(c => modifiedCellIndexIds.find(m => m.id === c.id));\n\t}\n\n\tcanComputeDiffWithCellMetadataIds(original: MirrorNotebookDocument, modified: MirrorNotebookDocument): boolean {\n\t\tconst originalCellIndexIds = original.cells.map((cell, index) => ({ index, id: (cell.metadata?.id || '') as string }));\n\t\tconst modifiedCellIndexIds = modified.cells.map((cell, index) => ({ index, id: (cell.metadata?.id || '') as string }));\n\t\t// If we have a cell without an id, do not use metadata.id for diffing.\n\t\tif (originalCellIndexIds.some(c => !c.id) || modifiedCellIndexIds.some(c => !c.id)) {\n\t\t\treturn false;\n\t\t}\n\t\t// If none of the ids in original can be found in modified, then we can't use metadata.id for diffing.\n\t\t// I.e. everything is new, no point trying.\n\t\tif (originalCellIndexIds.every(c => !modifiedCellIndexIds.find(m => m.id === c.id))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Internally we use internalMetadata.cellId for diffing, hence update the internalMetadata.cellId\n\t\toriginal.cells.map((cell, index) => {\n\t\t\tcell.internalMetadata = cell.internalMetadata || {};\n\t\t\tcell.internalMetadata.internalId = cell.metadata?.id as string || '';\n\t\t});\n\t\tmodified.cells.map((cell, index) => {\n\t\t\tcell.internalMetadata = cell.internalMetadata || {};\n\t\t\tcell.internalMetadata.internalId = cell.metadata?.id as string || '';\n\t\t});\n\t\treturn true;\n\t}\n\n\n\tisOriginalCellMatchedWithModifiedCell(originalCell: MirrorCell) {\n\t\treturn (originalCell.internalMetadata?.internalId as string || '').startsWith(PREFIX_FOR_UNMATCHED_ORIGINAL_CELLS);\n\t}\n\tupdateCellIdsBasedOnMappings(mappings: { modified: number; original: number }[], originalCells: MirrorCell[], modifiedCells: MirrorCell[]): boolean {\n\t\tconst uuids = new Map<number, string>();\n\t\toriginalCells.map((cell, index) => {\n\t\t\tcell.internalMetadata = cell.internalMetadata || { internalId: '' };\n\t\t\tcell.internalMetadata.internalId = `${PREFIX_FOR_UNMATCHED_ORIGINAL_CELLS}${generateUuid()}`;\n\t\t\tconst found = mappings.find(r => r.original === index);\n\t\t\tif (found) {\n\t\t\t\t// Do not use the indexes as ids.\n\t\t\t\t// If we do, then the hashes will be very similar except for last digit.\n\t\t\t\tcell.internalMetadata.internalId = generateUuid();\n\t\t\t\tuuids.set(found.modified, cell.internalMetadata.internalId as string);\n\t\t\t}\n\t\t});\n\t\tmodifiedCells.map((cell, index) => {\n\t\t\tcell.internalMetadata = cell.internalMetadata || { internalId: '' };\n\t\t\tcell.internalMetadata.internalId = uuids.get(index) ?? generateUuid();\n\t\t});\n\t\treturn true;\n\t}\n\n\t$canPromptRecommendation(modelUrl: string): boolean {\n\t\tconst model = this._getModel(modelUrl);\n\t\tconst cells = model.cells;\n\n\t\tfor (let i = 0; i < cells.length; i++) {\n\t\t\tconst cell = cells[i];\n\t\t\tif (cell.cellKind === CellKind.Markup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cell.language !== 'python') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst searchParams = new SearchParams('import\\\\s*pandas|from\\\\s*pandas', true, false, null);\n\t\t\tconst searchData = searchParams.parseSearchRequest();\n\n\t\t\tif (!searchData) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst builder = new PieceTreeTextBufferBuilder();\n\t\t\tbuilder.acceptChunk(cell.getValue());\n\t\t\tconst bufferFactory = builder.finish(true);\n\t\t\tconst textBuffer = bufferFactory.create(cell.eol).textBuffer;\n\n\t\t\tconst lineCount = textBuffer.getLineCount();\n\t\t\tconst maxLineCount = Math.min(lineCount, 20);\n\t\t\tconst range = new Range(1, 1, maxLineCount, textBuffer.getLineLength(maxLineCount) + 1);\n\t\t\tconst cellMatches = textBuffer.findMatchesLineByLine(range, searchData, true, 1);\n\t\t\tif (cellMatches.length > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprotected _getModel(uri: string): MirrorNotebookDocument {\n\t\treturn this._models[uri];\n\t}\n}\n\nexport function create(): IWebWorkerServerRequestHandler {\n\treturn new NotebookWorker();\n}\n\nexport type CellDiffInfo = {\n\toriginalCellIndex: number;\n\tmodifiedCellIndex: number;\n\ttype: 'unchanged' | 'modified';\n} |\n{\n\toriginalCellIndex: number;\n\ttype: 'delete';\n} |\n{\n\tmodifiedCellIndex: number;\n\ttype: 'insert';\n};\n\ninterface ICell {\n\tcellKind: CellKind;\n\tgetHashValue(): number;\n\tequal(cell: ICell): boolean;\n}\n\nclass NotebookTextModelFacade {\n\tpublic readonly cells: readonly ICell[];\n\tconstructor(\n\t\treadonly notebook: MirrorNotebookDocument\n\t) {\n\n\t\tthis.cells = notebook.cells.map(cell => new NotebookCellTextModelFacade(cell));\n\t}\n\n}\nclass NotebookCellTextModelFacade implements ICell {\n\tget cellKind(): CellKind {\n\t\treturn this.cell.cellKind;\n\t}\n\tconstructor(\n\t\tprivate readonly cell: MirrorCell\n\t) {\n\t}\n\tgetHashValue(): number {\n\t\treturn this.cell.getComparisonValue();\n\t}\n\tequal(cell: ICell): boolean {\n\t\tif (cell.cellKind !== this.cellKind) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getHashValue() === cell.getHashValue();\n\t}\n\n}\n"]}