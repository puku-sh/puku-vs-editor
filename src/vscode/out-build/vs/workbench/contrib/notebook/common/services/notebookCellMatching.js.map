{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/notebook/common/services/notebookCellMatching.ts","vs/workbench/contrib/notebook/common/services/notebookCellMatching.ts"],"names":[],"mappings":"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","file":"notebookCellMatching.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { computeLevenshteinDistance } from '../../../../../base/common/diff/diff.js';\nimport { CellKind } from '../notebookCommon.js';\n\n\ntype EditCount = number;\ntype OriginalIndex = number;\ntype ModifiedIndex = number;\ntype CellEditCountCache = {\n\tmodifiedToOriginal: Map<ModifiedIndex, Map<OriginalIndex, { editCount: EditCount }>>;\n\toriginalToModified: Map<OriginalIndex, Map<ModifiedIndex, { editCount: EditCount }>>;\n};\n\ntype ICell = {\n\tinternalMetadata?: {\n\t\tinternalId?: string;\n\t};\n\tgetValue(): string;\n\tgetLinesContent(): string[];\n\tcellKind: CellKind;\n};\n\n/**\n * Given a set of modified cells and original cells, this function will attempt to match the modified cells with the original cells.\n * E.g. Assume you have (original on left and modified on right):\n * =================\n * Cell A  | Cell a\n * Cell B  | Cell b\n * Cell C  | Cell d\n * Cell D  | Cell e\n * =================\n * Here we know that `Cell C` has been removed and `Cell e` has been added.\n * The mapping from modified to original will be as follows:\n * Cell a => Cell A\n * Cell b => Cell B\n * Cell d => Cell D\n * Cell e => <Does not match anything in original, hence a new Cell>\n * Cell C in original was not matched, hence it was deleted.\n *\n * Thus the return value is as follows:\n * [\n * { modified: 0, original: 0 },\n * { modified: 1, original: 1 },\n * { modified: 2, original: 3 },\n * { modified: 3, original: -1 },\n * ]\n * @returns\n */\nexport function matchCellBasedOnSimilarties(modifiedCells: ICell[], originalCells: ICell[]): { modified: number; original: number; percentage: number }[] {\n\tconst cache: CellEditCountCache = {\n\t\tmodifiedToOriginal: new Map<ModifiedIndex, Map<OriginalIndex, { editCount: EditCount }>>(),\n\t\toriginalToModified: new Map<OriginalIndex, Map<ModifiedIndex, { editCount: EditCount }>>(),\n\t};\n\tconst results: { modified: number; original: number; dist: number; percentage: number; possibleOriginal: number }[] = [];\n\tconst mappedOriginalCellToModifiedCell = new Map<number, number>();\n\tconst mappedModifiedIndexes = new Set<number>();\n\tconst originalIndexWithMostEdits = new Map<number, { dist: number; modifiedIndex: number }>();\n\tconst canOriginalIndexBeMappedToModifiedIndex = (originalIndex: number, value: { editCount: EditCount }) => {\n\t\tif (mappedOriginalCellToModifiedCell.has(originalIndex)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst existingEdits = originalIndexWithMostEdits.get(originalIndex)?.dist ?? Number.MAX_SAFE_INTEGER;\n\t\treturn value.editCount < existingEdits;\n\t};\n\tconst trackMappedIndexes = (modifiedIndex: number, originalIndex: number) => {\n\t\tmappedOriginalCellToModifiedCell.set(originalIndex, modifiedIndex);\n\t\tmappedModifiedIndexes.add(modifiedIndex);\n\t};\n\n\tfor (let i = 0; i < modifiedCells.length; i++) {\n\t\tconst modifiedCell = modifiedCells[i];\n\t\tconst { index, editCount: dist, percentage } = computeClosestCell({ cell: modifiedCell, index: i }, originalCells, true, cache, canOriginalIndexBeMappedToModifiedIndex);\n\t\tif (index >= 0 && dist === 0) {\n\t\t\ttrackMappedIndexes(i, index);\n\t\t\tresults.push({ modified: i, original: index, dist, percentage, possibleOriginal: index });\n\t\t} else {\n\t\t\toriginalIndexWithMostEdits.set(index, { dist: dist, modifiedIndex: i });\n\t\t\tresults.push({ modified: i, original: -1, dist: dist, percentage, possibleOriginal: index });\n\t\t}\n\t}\n\n\tresults.forEach((result, i) => {\n\t\tif (result.original >= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * I.e. Assume you have the following\n\t\t * =================\n\t\t * A a (this has ben matched)\n\t\t * B b <not matched>\n\t\t * C c <not matched>\n\t\t * D d (these two have been matched)\n\t\t * e e\n\t\t * f f\n\t\t * =================\n\t\t * Just match A => a, B => b, C => c\n\t\t */\n\t\t// Find the next cell that has been matched.\n\t\tconst previousMatchedCell = i > 0 ? results.slice(0, i).reverse().find(r => r.original >= 0) : undefined;\n\t\tconst previousMatchedOriginalIndex = previousMatchedCell?.original ?? -1;\n\t\tconst previousMatchedModifiedIndex = previousMatchedCell?.modified ?? -1;\n\t\tconst matchedCell = results.slice(i + 1).find(r => r.original >= 0);\n\t\tconst unavailableIndexes = new Set<number>();\n\t\tconst nextMatchedModifiedIndex = results.findIndex((item, idx) => idx > i && item.original >= 0);\n\t\tconst nextMatchedOriginalIndex = nextMatchedModifiedIndex >= 0 ? results[nextMatchedModifiedIndex].original : -1;\n\t\t// Find the available indexes that we can match with.\n\t\t// We are only interested in b and c (anything after d is of no use).\n\t\toriginalCells.forEach((_, i) => {\n\t\t\tif (mappedOriginalCellToModifiedCell.has(i)) {\n\t\t\t\tunavailableIndexes.add(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (matchedCell && i >= matchedCell.original) {\n\t\t\t\tunavailableIndexes.add(i);\n\t\t\t}\n\t\t\tif (nextMatchedOriginalIndex >= 0 && i > nextMatchedOriginalIndex) {\n\t\t\t\tunavailableIndexes.add(i);\n\t\t\t}\n\t\t});\n\n\n\t\tconst modifiedCell = modifiedCells[i];\n\t\t/**\n\t\t * I.e. Assume you have the following\n\t\t * =================\n\t\t * A a (this has ben matched)\n\t\t * B b <not matched because the % of change is too high, but we do have a probable match>\n\t\t * C c <not matched>\n\t\t * D d (these two have been matched)\n\t\t * e e\n\t\t * f f\n\t\t * =================\n\t\t * Given that we have a probable match for B => b, we can match it.\n\t\t */\n\t\tif (result.original === -1 && result.possibleOriginal >= 0 && !unavailableIndexes.has(result.possibleOriginal) && canOriginalIndexBeMappedToModifiedIndex(result.possibleOriginal, { editCount: result.dist })) {\n\t\t\ttrackMappedIndexes(i, result.possibleOriginal);\n\t\t\tresult.original = result.possibleOriginal;\n\t\t\treturn;\n\t\t}\n\n\n\t\t/**\n\t\t * I.e. Assume you have the following\n\t\t * =================\n\t\t * A a (this has ben matched)\n\t\t * B b <not matched>\n\t\t * C c <not matched>\n\t\t * D d (these two have been matched)\n\t\t * =================\n\t\t * Its possible that B matches better with c and C matches better with b.\n\t\t * However given the fact that we have matched A => a and D => d.\n\t\t * & if the indexes are an exact match.\n\t\t * I.e. index of D in Modified === index of d in Original, and index of A in Modified === index of a in Original.\n\t\t * Then this means there are absolutely no modifications.\n\t\t * Hence we can just assign the indexes as is.\n\t\t *\n\t\t * NOTE: For this, we must ensure we have exactly the same number of items on either side.\n\t\t * I.e. we have B, C remaining in Modified, and b, c remaining in Original.\n\t\t * Thats 2 Modified items === 2 Original Items.\n\t\t * If its not the same, then this means something has been deleted/inserted, and we cannot blindly map the indexes.\n\t\t*/\n\t\tif (previousMatchedOriginalIndex > 0 && previousMatchedModifiedIndex > 0 && previousMatchedOriginalIndex === previousMatchedModifiedIndex) {\n\t\t\tif ((nextMatchedModifiedIndex >= 0 ? nextMatchedModifiedIndex : modifiedCells.length - 1) === (nextMatchedOriginalIndex >= 0 ? nextMatchedOriginalIndex : originalCells.length - 1) && !unavailableIndexes.has(i) && i < originalCells.length) {\n\t\t\t\tconst remainingModifiedItems = (nextMatchedModifiedIndex >= 0 ? nextMatchedModifiedIndex : modifiedCells.length) - previousMatchedModifiedIndex;\n\t\t\t\tconst remainingOriginalItems = (nextMatchedOriginalIndex >= 0 ? nextMatchedOriginalIndex : originalCells.length) - previousMatchedOriginalIndex;\n\t\t\t\tif (remainingModifiedItems === remainingOriginalItems && modifiedCell.cellKind === originalCells[i].cellKind) {\n\t\t\t\t\ttrackMappedIndexes(i, i);\n\t\t\t\t\tresult.original = i;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * I.e. Assume you have the following\n\t\t * =================\n\t\t * A a (this has ben matched)\n\t\t * B b <not matched>\n\t\t * C c <not matched>\n\t\t * D d (these two have been matched)\n\t\t * e e\n\t\t * f f\n\t\t * =================\n\t\t * We can now try to match B with b and c and figure out which is best.\n\t\t * RULE 1. Its possible that B will match best with c, howevber C matches better with c, meaning we should match B with b.\n\t\t * To do this, we need to see if c has a better match with something else.\n\t\t*/\n\t\t// RULE 1\n\t\t// Try to find the next best match, but exclucde items that have a better match.\n\t\tconst { index, percentage } = computeClosestCell({ cell: modifiedCell, index: i }, originalCells, false, cache, (originalIndex: number, originalValue: { editCount: EditCount }) => {\n\t\t\tif (unavailableIndexes.has(originalIndex)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (nextMatchedModifiedIndex > 0 || previousMatchedOriginalIndex > 0) {\n\t\t\t\t// See if we have a beter match for this.\n\t\t\t\tconst matchesForThisOriginalIndex = cache.originalToModified.get(originalIndex);\n\t\t\t\tif (matchesForThisOriginalIndex && previousMatchedOriginalIndex < originalIndex) {\n\t\t\t\t\tconst betterMatch = Array.from(matchesForThisOriginalIndex).find(([modifiedIndex, value]) => {\n\t\t\t\t\t\tif (modifiedIndex === i) {\n\t\t\t\t\t\t\t// This is the same modifeid entry.\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (modifiedIndex >= nextMatchedModifiedIndex) {\n\t\t\t\t\t\t\t// We're only interested in matches that are before the next matched index.\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mappedModifiedIndexes.has(i)) {\n\t\t\t\t\t\t\t// This has already been matched.\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value.editCount < originalValue.editCount;\n\t\t\t\t\t});\n\t\t\t\t\tif (betterMatch) {\n\t\t\t\t\t\t// We do have a better match for this, hence do not use this.\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !unavailableIndexes.has(originalIndex);\n\t\t});\n\n\t\t/**\n\t\t * I.e. Assume you have the following\n\t\t * =================\n\t\t * A a (this has ben matched)\n\t\t * B bbbbbbbbbbbbbb <not matched>\n\t\t * C cccccccccccccc <not matched>\n\t\t * D d (these two have been matched)\n\t\t * e e\n\t\t * f f\n\t\t * =================\n\t\t * RULE 1 . Now when attempting to match `bbbbbbbbbbbb` with B, the number of edits is very high and the percentage is also very high.\n\t\t * Basically majority of the text needs to be changed.\n\t\t * However if the indexes line up perfectly well, and this is the best match, then use it.\n\t\t*\n\t\t * Similarly its possible we're trying to match b with `BBBBBBBBBBBB` and the number of edits is very high, but the indexes line up perfectly well.\n\t\t*\n\t\t* RULE 2. However it is also possible that there's a better match with another cell\n\t\t* Assume we have\n\t\t * =================\n\t\t * AAAA     a (this has been matched)\n\t\t * bbbbbbbb b <not matched>\n\t\t * bbbb     c <not matched>\n\t\t * dddd     d (these two have been matched)\n\t\t * =================\n\t\t * In this case if we use the algorithm of (1) above, we'll end up matching bbbb with b, and bbbbbbbb with c.\n\t\t * But we're not really sure if this is the best match.\n\t\t * In such cases try to match with the same cell index.\n\t\t *\n\t\t*/\n\t\t// RULE 1 (got a match and the indexes line up perfectly well, use it regardless of the number of edits).\n\t\tif (index >= 0 && i > 0 && results[i - 1].original === index - 1) {\n\t\t\ttrackMappedIndexes(i, index);\n\t\t\tresults[i].original = index;\n\t\t\treturn;\n\t\t}\n\n\t\t// RULE 2\n\t\t// Here we know that `AAAA => a`\n\t\t// Check if the previous cell has been matched.\n\t\t// And if the next modified and next original cells are a match.\n\t\tconst nextOriginalCell = (i > 0 && originalCells.length > results[i - 1].original) ? results[i - 1].original + 1 : -1;\n\t\tconst nextOriginalCellValue = i > 0 && nextOriginalCell >= 0 && nextOriginalCell < originalCells.length ? originalCells[nextOriginalCell].getValue() : undefined;\n\t\tif (index >= 0 && i > 0 && typeof nextOriginalCellValue === 'string' && !mappedOriginalCellToModifiedCell.has(nextOriginalCell)) {\n\t\t\tif (modifiedCell.getValue().includes(nextOriginalCellValue) || nextOriginalCellValue.includes(modifiedCell.getValue())) {\n\t\t\t\ttrackMappedIndexes(i, nextOriginalCell);\n\t\t\t\tresults[i].original = nextOriginalCell;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (percentage < 90 || (i === 0 && results.length === 1)) {\n\t\t\ttrackMappedIndexes(i, index);\n\t\t\tresults[i].original = index;\n\t\t\treturn;\n\t\t}\n\t});\n\n\treturn results;\n}\n\nfunction computeClosestCell({ cell, index: cellIndex }: { cell: ICell; index: number }, arr: readonly ICell[], ignoreEmptyCells: boolean, cache: CellEditCountCache, canOriginalIndexBeMappedToModifiedIndex: (originalIndex: number, value: { editCount: EditCount }) => boolean): { index: number; editCount: number; percentage: number } {\n\tlet min_edits = Infinity;\n\tlet min_index = -1;\n\n\t// Always give preference to internal Cell Id if found.\n\tconst internalId = cell.internalMetadata?.internalId;\n\tif (internalId) {\n\t\tconst internalIdIndex = arr.findIndex(cell => cell.internalMetadata?.internalId === internalId);\n\t\tif (internalIdIndex >= 0) {\n\t\t\treturn { index: internalIdIndex, editCount: 0, percentage: Number.MAX_SAFE_INTEGER };\n\t\t}\n\t}\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\t// Skip cells that are not of the same kind.\n\t\tif (arr[i].cellKind !== cell.cellKind) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst str = arr[i].getValue();\n\t\tconst cacheEntry = cache.modifiedToOriginal.get(cellIndex) ?? new Map<OriginalIndex, { editCount: EditCount }>();\n\t\tconst value = cacheEntry.get(i) ?? { editCount: computeNumberOfEdits(cell, arr[i]), };\n\t\tcacheEntry.set(i, value);\n\t\tcache.modifiedToOriginal.set(cellIndex, cacheEntry);\n\n\t\tconst originalCacheEntry = cache.originalToModified.get(i) ?? new Map<ModifiedIndex, { editCount: EditCount }>();\n\t\toriginalCacheEntry.set(cellIndex, value);\n\t\tcache.originalToModified.set(i, originalCacheEntry);\n\n\t\tif (!canOriginalIndexBeMappedToModifiedIndex(i, value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (str.length === 0 && ignoreEmptyCells) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (str === cell.getValue() && cell.getValue().length > 0) {\n\t\t\treturn { index: i, editCount: 0, percentage: 0 };\n\t\t}\n\n\t\tif (value.editCount < min_edits) {\n\t\t\tmin_edits = value.editCount;\n\t\t\tmin_index = i;\n\t\t}\n\t}\n\n\tif (min_index === -1) {\n\t\treturn { index: -1, editCount: Number.MAX_SAFE_INTEGER, percentage: Number.MAX_SAFE_INTEGER };\n\t}\n\tconst percentage = !cell.getValue().length && !arr[min_index].getValue().length ? 0 : (cell.getValue().length ? (min_edits * 100 / cell.getValue().length) : Number.MAX_SAFE_INTEGER);\n\treturn { index: min_index, editCount: min_edits, percentage };\n}\n\nfunction computeNumberOfEdits(modified: ICell, original: ICell) {\n\tif (modified.getValue() === original.getValue()) {\n\t\treturn 0;\n\t}\n\n\treturn computeLevenshteinDistance(modified.getValue(), original.getValue());\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { computeLevenshteinDistance } from '../../../../../base/common/diff/diff.js';\nimport { CellKind } from '../notebookCommon.js';\n\n\ntype EditCount = number;\ntype OriginalIndex = number;\ntype ModifiedIndex = number;\ntype CellEditCountCache = {\n\tmodifiedToOriginal: Map<ModifiedIndex, Map<OriginalIndex, { editCount: EditCount }>>;\n\toriginalToModified: Map<OriginalIndex, Map<ModifiedIndex, { editCount: EditCount }>>;\n};\n\ntype ICell = {\n\tinternalMetadata?: {\n\t\tinternalId?: string;\n\t};\n\tgetValue(): string;\n\tgetLinesContent(): string[];\n\tcellKind: CellKind;\n};\n\n/**\n * Given a set of modified cells and original cells, this function will attempt to match the modified cells with the original cells.\n * E.g. Assume you have (original on left and modified on right):\n * =================\n * Cell A  | Cell a\n * Cell B  | Cell b\n * Cell C  | Cell d\n * Cell D  | Cell e\n * =================\n * Here we know that `Cell C` has been removed and `Cell e` has been added.\n * The mapping from modified to original will be as follows:\n * Cell a => Cell A\n * Cell b => Cell B\n * Cell d => Cell D\n * Cell e => <Does not match anything in original, hence a new Cell>\n * Cell C in original was not matched, hence it was deleted.\n *\n * Thus the return value is as follows:\n * [\n * { modified: 0, original: 0 },\n * { modified: 1, original: 1 },\n * { modified: 2, original: 3 },\n * { modified: 3, original: -1 },\n * ]\n * @returns\n */\nexport function matchCellBasedOnSimilarties(modifiedCells: ICell[], originalCells: ICell[]): { modified: number; original: number; percentage: number }[] {\n\tconst cache: CellEditCountCache = {\n\t\tmodifiedToOriginal: new Map<ModifiedIndex, Map<OriginalIndex, { editCount: EditCount }>>(),\n\t\toriginalToModified: new Map<OriginalIndex, Map<ModifiedIndex, { editCount: EditCount }>>(),\n\t};\n\tconst results: { modified: number; original: number; dist: number; percentage: number; possibleOriginal: number }[] = [];\n\tconst mappedOriginalCellToModifiedCell = new Map<number, number>();\n\tconst mappedModifiedIndexes = new Set<number>();\n\tconst originalIndexWithMostEdits = new Map<number, { dist: number; modifiedIndex: number }>();\n\tconst canOriginalIndexBeMappedToModifiedIndex = (originalIndex: number, value: { editCount: EditCount }) => {\n\t\tif (mappedOriginalCellToModifiedCell.has(originalIndex)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst existingEdits = originalIndexWithMostEdits.get(originalIndex)?.dist ?? Number.MAX_SAFE_INTEGER;\n\t\treturn value.editCount < existingEdits;\n\t};\n\tconst trackMappedIndexes = (modifiedIndex: number, originalIndex: number) => {\n\t\tmappedOriginalCellToModifiedCell.set(originalIndex, modifiedIndex);\n\t\tmappedModifiedIndexes.add(modifiedIndex);\n\t};\n\n\tfor (let i = 0; i < modifiedCells.length; i++) {\n\t\tconst modifiedCell = modifiedCells[i];\n\t\tconst { index, editCount: dist, percentage } = computeClosestCell({ cell: modifiedCell, index: i }, originalCells, true, cache, canOriginalIndexBeMappedToModifiedIndex);\n\t\tif (index >= 0 && dist === 0) {\n\t\t\ttrackMappedIndexes(i, index);\n\t\t\tresults.push({ modified: i, original: index, dist, percentage, possibleOriginal: index });\n\t\t} else {\n\t\t\toriginalIndexWithMostEdits.set(index, { dist: dist, modifiedIndex: i });\n\t\t\tresults.push({ modified: i, original: -1, dist: dist, percentage, possibleOriginal: index });\n\t\t}\n\t}\n\n\tresults.forEach((result, i) => {\n\t\tif (result.original >= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * I.e. Assume you have the following\n\t\t * =================\n\t\t * A a (this has ben matched)\n\t\t * B b <not matched>\n\t\t * C c <not matched>\n\t\t * D d (these two have been matched)\n\t\t * e e\n\t\t * f f\n\t\t * =================\n\t\t * Just match A => a, B => b, C => c\n\t\t */\n\t\t// Find the next cell that has been matched.\n\t\tconst previousMatchedCell = i > 0 ? results.slice(0, i).reverse().find(r => r.original >= 0) : undefined;\n\t\tconst previousMatchedOriginalIndex = previousMatchedCell?.original ?? -1;\n\t\tconst previousMatchedModifiedIndex = previousMatchedCell?.modified ?? -1;\n\t\tconst matchedCell = results.slice(i + 1).find(r => r.original >= 0);\n\t\tconst unavailableIndexes = new Set<number>();\n\t\tconst nextMatchedModifiedIndex = results.findIndex((item, idx) => idx > i && item.original >= 0);\n\t\tconst nextMatchedOriginalIndex = nextMatchedModifiedIndex >= 0 ? results[nextMatchedModifiedIndex].original : -1;\n\t\t// Find the available indexes that we can match with.\n\t\t// We are only interested in b and c (anything after d is of no use).\n\t\toriginalCells.forEach((_, i) => {\n\t\t\tif (mappedOriginalCellToModifiedCell.has(i)) {\n\t\t\t\tunavailableIndexes.add(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (matchedCell && i >= matchedCell.original) {\n\t\t\t\tunavailableIndexes.add(i);\n\t\t\t}\n\t\t\tif (nextMatchedOriginalIndex >= 0 && i > nextMatchedOriginalIndex) {\n\t\t\t\tunavailableIndexes.add(i);\n\t\t\t}\n\t\t});\n\n\n\t\tconst modifiedCell = modifiedCells[i];\n\t\t/**\n\t\t * I.e. Assume you have the following\n\t\t * =================\n\t\t * A a (this has ben matched)\n\t\t * B b <not matched because the % of change is too high, but we do have a probable match>\n\t\t * C c <not matched>\n\t\t * D d (these two have been matched)\n\t\t * e e\n\t\t * f f\n\t\t * =================\n\t\t * Given that we have a probable match for B => b, we can match it.\n\t\t */\n\t\tif (result.original === -1 && result.possibleOriginal >= 0 && !unavailableIndexes.has(result.possibleOriginal) && canOriginalIndexBeMappedToModifiedIndex(result.possibleOriginal, { editCount: result.dist })) {\n\t\t\ttrackMappedIndexes(i, result.possibleOriginal);\n\t\t\tresult.original = result.possibleOriginal;\n\t\t\treturn;\n\t\t}\n\n\n\t\t/**\n\t\t * I.e. Assume you have the following\n\t\t * =================\n\t\t * A a (this has ben matched)\n\t\t * B b <not matched>\n\t\t * C c <not matched>\n\t\t * D d (these two have been matched)\n\t\t * =================\n\t\t * Its possible that B matches better with c and C matches better with b.\n\t\t * However given the fact that we have matched A => a and D => d.\n\t\t * & if the indexes are an exact match.\n\t\t * I.e. index of D in Modified === index of d in Original, and index of A in Modified === index of a in Original.\n\t\t * Then this means there are absolutely no modifications.\n\t\t * Hence we can just assign the indexes as is.\n\t\t *\n\t\t * NOTE: For this, we must ensure we have exactly the same number of items on either side.\n\t\t * I.e. we have B, C remaining in Modified, and b, c remaining in Original.\n\t\t * Thats 2 Modified items === 2 Original Items.\n\t\t * If its not the same, then this means something has been deleted/inserted, and we cannot blindly map the indexes.\n\t\t*/\n\t\tif (previousMatchedOriginalIndex > 0 && previousMatchedModifiedIndex > 0 && previousMatchedOriginalIndex === previousMatchedModifiedIndex) {\n\t\t\tif ((nextMatchedModifiedIndex >= 0 ? nextMatchedModifiedIndex : modifiedCells.length - 1) === (nextMatchedOriginalIndex >= 0 ? nextMatchedOriginalIndex : originalCells.length - 1) && !unavailableIndexes.has(i) && i < originalCells.length) {\n\t\t\t\tconst remainingModifiedItems = (nextMatchedModifiedIndex >= 0 ? nextMatchedModifiedIndex : modifiedCells.length) - previousMatchedModifiedIndex;\n\t\t\t\tconst remainingOriginalItems = (nextMatchedOriginalIndex >= 0 ? nextMatchedOriginalIndex : originalCells.length) - previousMatchedOriginalIndex;\n\t\t\t\tif (remainingModifiedItems === remainingOriginalItems && modifiedCell.cellKind === originalCells[i].cellKind) {\n\t\t\t\t\ttrackMappedIndexes(i, i);\n\t\t\t\t\tresult.original = i;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * I.e. Assume you have the following\n\t\t * =================\n\t\t * A a (this has ben matched)\n\t\t * B b <not matched>\n\t\t * C c <not matched>\n\t\t * D d (these two have been matched)\n\t\t * e e\n\t\t * f f\n\t\t * =================\n\t\t * We can now try to match B with b and c and figure out which is best.\n\t\t * RULE 1. Its possible that B will match best with c, howevber C matches better with c, meaning we should match B with b.\n\t\t * To do this, we need to see if c has a better match with something else.\n\t\t*/\n\t\t// RULE 1\n\t\t// Try to find the next best match, but exclucde items that have a better match.\n\t\tconst { index, percentage } = computeClosestCell({ cell: modifiedCell, index: i }, originalCells, false, cache, (originalIndex: number, originalValue: { editCount: EditCount }) => {\n\t\t\tif (unavailableIndexes.has(originalIndex)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (nextMatchedModifiedIndex > 0 || previousMatchedOriginalIndex > 0) {\n\t\t\t\t// See if we have a beter match for this.\n\t\t\t\tconst matchesForThisOriginalIndex = cache.originalToModified.get(originalIndex);\n\t\t\t\tif (matchesForThisOriginalIndex && previousMatchedOriginalIndex < originalIndex) {\n\t\t\t\t\tconst betterMatch = Array.from(matchesForThisOriginalIndex).find(([modifiedIndex, value]) => {\n\t\t\t\t\t\tif (modifiedIndex === i) {\n\t\t\t\t\t\t\t// This is the same modifeid entry.\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (modifiedIndex >= nextMatchedModifiedIndex) {\n\t\t\t\t\t\t\t// We're only interested in matches that are before the next matched index.\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mappedModifiedIndexes.has(i)) {\n\t\t\t\t\t\t\t// This has already been matched.\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value.editCount < originalValue.editCount;\n\t\t\t\t\t});\n\t\t\t\t\tif (betterMatch) {\n\t\t\t\t\t\t// We do have a better match for this, hence do not use this.\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !unavailableIndexes.has(originalIndex);\n\t\t});\n\n\t\t/**\n\t\t * I.e. Assume you have the following\n\t\t * =================\n\t\t * A a (this has ben matched)\n\t\t * B bbbbbbbbbbbbbb <not matched>\n\t\t * C cccccccccccccc <not matched>\n\t\t * D d (these two have been matched)\n\t\t * e e\n\t\t * f f\n\t\t * =================\n\t\t * RULE 1 . Now when attempting to match `bbbbbbbbbbbb` with B, the number of edits is very high and the percentage is also very high.\n\t\t * Basically majority of the text needs to be changed.\n\t\t * However if the indexes line up perfectly well, and this is the best match, then use it.\n\t\t*\n\t\t * Similarly its possible we're trying to match b with `BBBBBBBBBBBB` and the number of edits is very high, but the indexes line up perfectly well.\n\t\t*\n\t\t* RULE 2. However it is also possible that there's a better match with another cell\n\t\t* Assume we have\n\t\t * =================\n\t\t * AAAA     a (this has been matched)\n\t\t * bbbbbbbb b <not matched>\n\t\t * bbbb     c <not matched>\n\t\t * dddd     d (these two have been matched)\n\t\t * =================\n\t\t * In this case if we use the algorithm of (1) above, we'll end up matching bbbb with b, and bbbbbbbb with c.\n\t\t * But we're not really sure if this is the best match.\n\t\t * In such cases try to match with the same cell index.\n\t\t *\n\t\t*/\n\t\t// RULE 1 (got a match and the indexes line up perfectly well, use it regardless of the number of edits).\n\t\tif (index >= 0 && i > 0 && results[i - 1].original === index - 1) {\n\t\t\ttrackMappedIndexes(i, index);\n\t\t\tresults[i].original = index;\n\t\t\treturn;\n\t\t}\n\n\t\t// RULE 2\n\t\t// Here we know that `AAAA => a`\n\t\t// Check if the previous cell has been matched.\n\t\t// And if the next modified and next original cells are a match.\n\t\tconst nextOriginalCell = (i > 0 && originalCells.length > results[i - 1].original) ? results[i - 1].original + 1 : -1;\n\t\tconst nextOriginalCellValue = i > 0 && nextOriginalCell >= 0 && nextOriginalCell < originalCells.length ? originalCells[nextOriginalCell].getValue() : undefined;\n\t\tif (index >= 0 && i > 0 && typeof nextOriginalCellValue === 'string' && !mappedOriginalCellToModifiedCell.has(nextOriginalCell)) {\n\t\t\tif (modifiedCell.getValue().includes(nextOriginalCellValue) || nextOriginalCellValue.includes(modifiedCell.getValue())) {\n\t\t\t\ttrackMappedIndexes(i, nextOriginalCell);\n\t\t\t\tresults[i].original = nextOriginalCell;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (percentage < 90 || (i === 0 && results.length === 1)) {\n\t\t\ttrackMappedIndexes(i, index);\n\t\t\tresults[i].original = index;\n\t\t\treturn;\n\t\t}\n\t});\n\n\treturn results;\n}\n\nfunction computeClosestCell({ cell, index: cellIndex }: { cell: ICell; index: number }, arr: readonly ICell[], ignoreEmptyCells: boolean, cache: CellEditCountCache, canOriginalIndexBeMappedToModifiedIndex: (originalIndex: number, value: { editCount: EditCount }) => boolean): { index: number; editCount: number; percentage: number } {\n\tlet min_edits = Infinity;\n\tlet min_index = -1;\n\n\t// Always give preference to internal Cell Id if found.\n\tconst internalId = cell.internalMetadata?.internalId;\n\tif (internalId) {\n\t\tconst internalIdIndex = arr.findIndex(cell => cell.internalMetadata?.internalId === internalId);\n\t\tif (internalIdIndex >= 0) {\n\t\t\treturn { index: internalIdIndex, editCount: 0, percentage: Number.MAX_SAFE_INTEGER };\n\t\t}\n\t}\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\t// Skip cells that are not of the same kind.\n\t\tif (arr[i].cellKind !== cell.cellKind) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst str = arr[i].getValue();\n\t\tconst cacheEntry = cache.modifiedToOriginal.get(cellIndex) ?? new Map<OriginalIndex, { editCount: EditCount }>();\n\t\tconst value = cacheEntry.get(i) ?? { editCount: computeNumberOfEdits(cell, arr[i]), };\n\t\tcacheEntry.set(i, value);\n\t\tcache.modifiedToOriginal.set(cellIndex, cacheEntry);\n\n\t\tconst originalCacheEntry = cache.originalToModified.get(i) ?? new Map<ModifiedIndex, { editCount: EditCount }>();\n\t\toriginalCacheEntry.set(cellIndex, value);\n\t\tcache.originalToModified.set(i, originalCacheEntry);\n\n\t\tif (!canOriginalIndexBeMappedToModifiedIndex(i, value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (str.length === 0 && ignoreEmptyCells) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (str === cell.getValue() && cell.getValue().length > 0) {\n\t\t\treturn { index: i, editCount: 0, percentage: 0 };\n\t\t}\n\n\t\tif (value.editCount < min_edits) {\n\t\t\tmin_edits = value.editCount;\n\t\t\tmin_index = i;\n\t\t}\n\t}\n\n\tif (min_index === -1) {\n\t\treturn { index: -1, editCount: Number.MAX_SAFE_INTEGER, percentage: Number.MAX_SAFE_INTEGER };\n\t}\n\tconst percentage = !cell.getValue().length && !arr[min_index].getValue().length ? 0 : (cell.getValue().length ? (min_edits * 100 / cell.getValue().length) : Number.MAX_SAFE_INTEGER);\n\treturn { index: min_index, editCount: min_edits, percentage };\n}\n\nfunction computeNumberOfEdits(modified: ICell, original: ICell) {\n\tif (modified.getValue() === original.getValue()) {\n\t\treturn 0;\n\t}\n\n\treturn computeLevenshteinDistance(modified.getValue(), original.getValue());\n}\n"]}