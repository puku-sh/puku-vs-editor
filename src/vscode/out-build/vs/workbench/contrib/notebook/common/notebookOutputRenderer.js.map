{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/notebook/common/notebookOutputRenderer.ts","vs/workbench/contrib/notebook/common/notebookOutputRenderer.ts"],"names":[],"mappings":"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","file":"notebookOutputRenderer.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from '../../../../base/common/glob.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { joinPath } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ExtensionIdentifier, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { INotebookRendererInfo, ContributedNotebookRendererEntrypoint, NotebookRendererMatch, RendererMessagingSpec, NotebookRendererEntrypoint, INotebookStaticPreloadInfo as INotebookStaticPreloadInfo } from './notebookCommon.js';\n\nclass DependencyList {\n\tprivate readonly value: ReadonlySet<string>;\n\tpublic readonly defined: boolean;\n\n\tconstructor(value: Iterable<string>) {\n\t\tthis.value = new Set(value);\n\t\tthis.defined = this.value.size > 0;\n\t}\n\n\t/** Gets whether any of the 'available' dependencies match the ones in this list */\n\tpublic matches(available: ReadonlyArray<string>) {\n\t\t// For now this is simple, but this may expand to support globs later\n\t\t// @see https://github.com/microsoft/vscode/issues/119899\n\t\treturn available.some(v => this.value.has(v));\n\t}\n}\n\nexport class NotebookOutputRendererInfo implements INotebookRendererInfo {\n\n\treadonly id: string;\n\treadonly entrypoint: NotebookRendererEntrypoint;\n\treadonly displayName: string;\n\treadonly extensionLocation: URI;\n\treadonly extensionId: ExtensionIdentifier;\n\treadonly hardDependencies: DependencyList;\n\treadonly optionalDependencies: DependencyList;\n\treadonly messaging: RendererMessagingSpec;\n\n\treadonly mimeTypes: readonly string[];\n\tprivate readonly mimeTypeGlobs: glob.ParsedPattern[];\n\n\treadonly isBuiltin: boolean;\n\n\tconstructor(descriptor: {\n\t\treadonly id: string;\n\t\treadonly displayName: string;\n\t\treadonly entrypoint: ContributedNotebookRendererEntrypoint;\n\t\treadonly mimeTypes: readonly string[];\n\t\treadonly extension: IExtensionDescription;\n\t\treadonly dependencies: readonly string[] | undefined;\n\t\treadonly optionalDependencies: readonly string[] | undefined;\n\t\treadonly requiresMessaging: RendererMessagingSpec | undefined;\n\t}) {\n\t\tthis.id = descriptor.id;\n\t\tthis.extensionId = descriptor.extension.identifier;\n\t\tthis.extensionLocation = descriptor.extension.extensionLocation;\n\t\tthis.isBuiltin = descriptor.extension.isBuiltin;\n\n\t\tif (typeof descriptor.entrypoint === 'string') {\n\t\t\tthis.entrypoint = {\n\t\t\t\textends: undefined,\n\t\t\t\tpath: joinPath(this.extensionLocation, descriptor.entrypoint)\n\t\t\t};\n\t\t} else {\n\t\t\tthis.entrypoint = {\n\t\t\t\textends: descriptor.entrypoint.extends,\n\t\t\t\tpath: joinPath(this.extensionLocation, descriptor.entrypoint.path)\n\t\t\t};\n\t\t}\n\n\t\tthis.displayName = descriptor.displayName;\n\t\tthis.mimeTypes = descriptor.mimeTypes;\n\t\tthis.mimeTypeGlobs = this.mimeTypes.map(pattern => glob.parse(pattern, { ignoreCase: true }));\n\t\tthis.hardDependencies = new DependencyList(descriptor.dependencies ?? Iterable.empty());\n\t\tthis.optionalDependencies = new DependencyList(descriptor.optionalDependencies ?? Iterable.empty());\n\t\tthis.messaging = descriptor.requiresMessaging ?? RendererMessagingSpec.Never;\n\t}\n\n\tpublic matchesWithoutKernel(mimeType: string) {\n\t\tif (!this.matchesMimeTypeOnly(mimeType)) {\n\t\t\treturn NotebookRendererMatch.Never;\n\t\t}\n\n\t\tif (this.hardDependencies.defined) {\n\t\t\treturn NotebookRendererMatch.WithHardKernelDependency;\n\t\t}\n\n\t\tif (this.optionalDependencies.defined) {\n\t\t\treturn NotebookRendererMatch.WithOptionalKernelDependency;\n\t\t}\n\n\t\treturn NotebookRendererMatch.Pure;\n\t}\n\n\tpublic matches(mimeType: string, kernelProvides: ReadonlyArray<string>) {\n\t\tif (!this.matchesMimeTypeOnly(mimeType)) {\n\t\t\treturn NotebookRendererMatch.Never;\n\t\t}\n\n\t\tif (this.hardDependencies.defined) {\n\t\t\treturn this.hardDependencies.matches(kernelProvides)\n\t\t\t\t? NotebookRendererMatch.WithHardKernelDependency\n\t\t\t\t: NotebookRendererMatch.Never;\n\t\t}\n\n\t\treturn this.optionalDependencies.matches(kernelProvides)\n\t\t\t? NotebookRendererMatch.WithOptionalKernelDependency\n\t\t\t: NotebookRendererMatch.Pure;\n\t}\n\n\tprivate matchesMimeTypeOnly(mimeType: string) {\n\t\tif (this.entrypoint.extends) { // We're extending another renderer\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.mimeTypeGlobs.some(pattern => pattern(mimeType)) || this.mimeTypes.some(pattern => pattern === mimeType);\n\t}\n}\n\nexport class NotebookStaticPreloadInfo implements INotebookStaticPreloadInfo {\n\n\treadonly type: string;\n\treadonly entrypoint: URI;\n\treadonly extensionLocation: URI;\n\treadonly localResourceRoots: readonly URI[];\n\n\tconstructor(descriptor: {\n\t\treadonly type: string;\n\t\treadonly entrypoint: string;\n\t\treadonly localResourceRoots: readonly string[];\n\t\treadonly extension: IExtensionDescription;\n\t}) {\n\t\tthis.type = descriptor.type;\n\n\t\tthis.entrypoint = joinPath(descriptor.extension.extensionLocation, descriptor.entrypoint);\n\t\tthis.extensionLocation = descriptor.extension.extensionLocation;\n\t\tthis.localResourceRoots = descriptor.localResourceRoots.map(root => joinPath(descriptor.extension.extensionLocation, root));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from '../../../../base/common/glob.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { joinPath } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ExtensionIdentifier, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { INotebookRendererInfo, ContributedNotebookRendererEntrypoint, NotebookRendererMatch, RendererMessagingSpec, NotebookRendererEntrypoint, INotebookStaticPreloadInfo as INotebookStaticPreloadInfo } from './notebookCommon.js';\n\nclass DependencyList {\n\tprivate readonly value: ReadonlySet<string>;\n\tpublic readonly defined: boolean;\n\n\tconstructor(value: Iterable<string>) {\n\t\tthis.value = new Set(value);\n\t\tthis.defined = this.value.size > 0;\n\t}\n\n\t/** Gets whether any of the 'available' dependencies match the ones in this list */\n\tpublic matches(available: ReadonlyArray<string>) {\n\t\t// For now this is simple, but this may expand to support globs later\n\t\t// @see https://github.com/microsoft/vscode/issues/119899\n\t\treturn available.some(v => this.value.has(v));\n\t}\n}\n\nexport class NotebookOutputRendererInfo implements INotebookRendererInfo {\n\n\treadonly id: string;\n\treadonly entrypoint: NotebookRendererEntrypoint;\n\treadonly displayName: string;\n\treadonly extensionLocation: URI;\n\treadonly extensionId: ExtensionIdentifier;\n\treadonly hardDependencies: DependencyList;\n\treadonly optionalDependencies: DependencyList;\n\treadonly messaging: RendererMessagingSpec;\n\n\treadonly mimeTypes: readonly string[];\n\tprivate readonly mimeTypeGlobs: glob.ParsedPattern[];\n\n\treadonly isBuiltin: boolean;\n\n\tconstructor(descriptor: {\n\t\treadonly id: string;\n\t\treadonly displayName: string;\n\t\treadonly entrypoint: ContributedNotebookRendererEntrypoint;\n\t\treadonly mimeTypes: readonly string[];\n\t\treadonly extension: IExtensionDescription;\n\t\treadonly dependencies: readonly string[] | undefined;\n\t\treadonly optionalDependencies: readonly string[] | undefined;\n\t\treadonly requiresMessaging: RendererMessagingSpec | undefined;\n\t}) {\n\t\tthis.id = descriptor.id;\n\t\tthis.extensionId = descriptor.extension.identifier;\n\t\tthis.extensionLocation = descriptor.extension.extensionLocation;\n\t\tthis.isBuiltin = descriptor.extension.isBuiltin;\n\n\t\tif (typeof descriptor.entrypoint === 'string') {\n\t\t\tthis.entrypoint = {\n\t\t\t\textends: undefined,\n\t\t\t\tpath: joinPath(this.extensionLocation, descriptor.entrypoint)\n\t\t\t};\n\t\t} else {\n\t\t\tthis.entrypoint = {\n\t\t\t\textends: descriptor.entrypoint.extends,\n\t\t\t\tpath: joinPath(this.extensionLocation, descriptor.entrypoint.path)\n\t\t\t};\n\t\t}\n\n\t\tthis.displayName = descriptor.displayName;\n\t\tthis.mimeTypes = descriptor.mimeTypes;\n\t\tthis.mimeTypeGlobs = this.mimeTypes.map(pattern => glob.parse(pattern, { ignoreCase: true }));\n\t\tthis.hardDependencies = new DependencyList(descriptor.dependencies ?? Iterable.empty());\n\t\tthis.optionalDependencies = new DependencyList(descriptor.optionalDependencies ?? Iterable.empty());\n\t\tthis.messaging = descriptor.requiresMessaging ?? RendererMessagingSpec.Never;\n\t}\n\n\tpublic matchesWithoutKernel(mimeType: string) {\n\t\tif (!this.matchesMimeTypeOnly(mimeType)) {\n\t\t\treturn NotebookRendererMatch.Never;\n\t\t}\n\n\t\tif (this.hardDependencies.defined) {\n\t\t\treturn NotebookRendererMatch.WithHardKernelDependency;\n\t\t}\n\n\t\tif (this.optionalDependencies.defined) {\n\t\t\treturn NotebookRendererMatch.WithOptionalKernelDependency;\n\t\t}\n\n\t\treturn NotebookRendererMatch.Pure;\n\t}\n\n\tpublic matches(mimeType: string, kernelProvides: ReadonlyArray<string>) {\n\t\tif (!this.matchesMimeTypeOnly(mimeType)) {\n\t\t\treturn NotebookRendererMatch.Never;\n\t\t}\n\n\t\tif (this.hardDependencies.defined) {\n\t\t\treturn this.hardDependencies.matches(kernelProvides)\n\t\t\t\t? NotebookRendererMatch.WithHardKernelDependency\n\t\t\t\t: NotebookRendererMatch.Never;\n\t\t}\n\n\t\treturn this.optionalDependencies.matches(kernelProvides)\n\t\t\t? NotebookRendererMatch.WithOptionalKernelDependency\n\t\t\t: NotebookRendererMatch.Pure;\n\t}\n\n\tprivate matchesMimeTypeOnly(mimeType: string) {\n\t\tif (this.entrypoint.extends) { // We're extending another renderer\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.mimeTypeGlobs.some(pattern => pattern(mimeType)) || this.mimeTypes.some(pattern => pattern === mimeType);\n\t}\n}\n\nexport class NotebookStaticPreloadInfo implements INotebookStaticPreloadInfo {\n\n\treadonly type: string;\n\treadonly entrypoint: URI;\n\treadonly extensionLocation: URI;\n\treadonly localResourceRoots: readonly URI[];\n\n\tconstructor(descriptor: {\n\t\treadonly type: string;\n\t\treadonly entrypoint: string;\n\t\treadonly localResourceRoots: readonly string[];\n\t\treadonly extension: IExtensionDescription;\n\t}) {\n\t\tthis.type = descriptor.type;\n\n\t\tthis.entrypoint = joinPath(descriptor.extension.extensionLocation, descriptor.entrypoint);\n\t\tthis.extensionLocation = descriptor.extension.extensionLocation;\n\t\tthis.localResourceRoots = descriptor.localResourceRoots.map(root => joinPath(descriptor.extension.extensionLocation, root));\n\t}\n}\n"]}