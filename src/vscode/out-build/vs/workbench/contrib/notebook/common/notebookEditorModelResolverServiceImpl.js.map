{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/notebook/common/notebookEditorModelResolverServiceImpl.ts","vs/workbench/contrib/notebook/common/notebookEditorModelResolverServiceImpl.ts"],"names":[],"mappings":"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","file":"notebookEditorModelResolverServiceImpl.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { CellUri, IResolvedNotebookEditorModel, NotebookEditorModelCreationOptions, NotebookSetting, NotebookWorkingCopyTypeIdentifier } from './notebookCommon.js';\nimport { NotebookFileWorkingCopyModel, NotebookFileWorkingCopyModelFactory, SimpleNotebookEditorModel } from './notebookEditorModel.js';\nimport { combinedDisposable, DisposableStore, dispose, IDisposable, IReference, ReferenceCollection, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { INotebookService } from './notebookService.js';\nimport { AsyncEmitter, Emitter, Event } from '../../../../base/common/event.js';\nimport { IExtensionService } from '../../../services/extensions/common/extensions.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { INotebookConflictEvent, INotebookEditorModelResolverService, IUntitledNotebookResource } from './notebookEditorModelResolverService.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { FileWorkingCopyManager, IFileWorkingCopyManager } from '../../../services/workingCopy/common/fileWorkingCopyManager.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { NotebookProviderInfo } from './notebookProvider.js';\nimport { assertReturnsDefined } from '../../../../base/common/types.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IFileReadLimits } from '../../../../platform/files/common/files.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { INotebookLoggingService } from './notebookLoggingService.js';\nimport { parse } from '../../../services/notebook/common/notebookDocumentService.js';\n\nclass NotebookModelReferenceCollection extends ReferenceCollection<Promise<IResolvedNotebookEditorModel>> {\n\n\tprivate readonly _disposables = new DisposableStore();\n\tprivate readonly _workingCopyManagers = new Map<string, IFileWorkingCopyManager<NotebookFileWorkingCopyModel, NotebookFileWorkingCopyModel>>();\n\tprivate readonly _modelListener = new Map<IResolvedNotebookEditorModel, IDisposable>();\n\n\tprivate readonly _onDidSaveNotebook = new Emitter<URI>();\n\treadonly onDidSaveNotebook: Event<URI> = this._onDidSaveNotebook.event;\n\n\tprivate readonly _onDidChangeDirty = new Emitter<IResolvedNotebookEditorModel>();\n\treadonly onDidChangeDirty: Event<IResolvedNotebookEditorModel> = this._onDidChangeDirty.event;\n\n\tprivate readonly _dirtyStates = new ResourceMap<boolean>();\n\n\tprivate readonly modelsToDispose = new Set<string>();\n\tconstructor(\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@INotebookService private readonly _notebookService: INotebookService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService,\n\t\t@INotebookLoggingService private readonly _notebookLoggingService: INotebookLoggingService,\n\t) {\n\t\tsuper();\n\t}\n\n\tdispose(): void {\n\t\tthis._disposables.dispose();\n\t\tthis._onDidSaveNotebook.dispose();\n\t\tthis._onDidChangeDirty.dispose();\n\t\tdispose(this._modelListener.values());\n\t\tdispose(this._workingCopyManagers.values());\n\t}\n\n\tisDirty(resource: URI): boolean {\n\t\treturn this._dirtyStates.get(resource) ?? false;\n\t}\n\n\tisListeningToModel(uri: URI): boolean {\n\t\tfor (const key of this._modelListener.keys()) {\n\t\t\tif (key.resource.toString() === uri.toString()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected async createReferencedObject(key: string, notebookType: string, hasAssociatedFilePath: boolean, limits?: IFileReadLimits, isScratchpad?: boolean, viewType?: string): Promise<IResolvedNotebookEditorModel> {\n\t\t// Untrack as being disposed\n\t\tthis.modelsToDispose.delete(key);\n\n\t\tconst uri = URI.parse(key);\n\n\t\tconst workingCopyTypeId = NotebookWorkingCopyTypeIdentifier.create(notebookType, viewType);\n\t\tlet workingCopyManager = this._workingCopyManagers.get(workingCopyTypeId);\n\t\tif (!workingCopyManager) {\n\t\t\tconst factory = new NotebookFileWorkingCopyModelFactory(notebookType, this._notebookService, this._configurationService, this._telemetryService, this._notebookLoggingService);\n\t\t\tworkingCopyManager = this._instantiationService.createInstance(\n\t\t\t\tFileWorkingCopyManager<NotebookFileWorkingCopyModel, NotebookFileWorkingCopyModel>,\n\t\t\t\tworkingCopyTypeId,\n\t\t\t\tfactory,\n\t\t\t\tfactory,\n\t\t\t);\n\t\t\tthis._workingCopyManagers.set(workingCopyTypeId, workingCopyManager);\n\t\t}\n\n\t\tconst isScratchpadView = isScratchpad || (notebookType === 'interactive' && this._configurationService.getValue<boolean>(NotebookSetting.InteractiveWindowPromptToSave) !== true);\n\t\tconst model = this._instantiationService.createInstance(SimpleNotebookEditorModel, uri, hasAssociatedFilePath, notebookType, workingCopyManager, isScratchpadView);\n\t\tconst result = await model.load({ limits });\n\n\n\t\t// Whenever a notebook model is dirty we automatically reference it so that\n\t\t// we can ensure that at least one reference exists. That guarantees that\n\t\t// a model with unsaved changes is never disposed.\n\t\tlet onDirtyAutoReference: IReference<any> | undefined;\n\n\t\tthis._modelListener.set(result, combinedDisposable(\n\t\t\tresult.onDidSave(() => this._onDidSaveNotebook.fire(result.resource)),\n\t\t\tresult.onDidChangeDirty(() => {\n\t\t\t\tconst isDirty = result.isDirty();\n\t\t\t\tthis._dirtyStates.set(result.resource, isDirty);\n\n\t\t\t\t// isDirty -> add reference\n\t\t\t\t// !isDirty -> free reference\n\t\t\t\tif (isDirty && !onDirtyAutoReference) {\n\t\t\t\t\tonDirtyAutoReference = this.acquire(key, notebookType);\n\t\t\t\t} else if (onDirtyAutoReference) {\n\t\t\t\t\tonDirtyAutoReference.dispose();\n\t\t\t\t\tonDirtyAutoReference = undefined;\n\t\t\t\t}\n\n\t\t\t\tthis._onDidChangeDirty.fire(result);\n\t\t\t}),\n\t\t\ttoDisposable(() => onDirtyAutoReference?.dispose()),\n\t\t));\n\t\treturn result;\n\t}\n\n\tprotected destroyReferencedObject(key: string, object: Promise<IResolvedNotebookEditorModel>): void {\n\t\tthis.modelsToDispose.add(key);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tconst model = await object;\n\n\t\t\t\tif (!this.modelsToDispose.has(key)) {\n\t\t\t\t\t// return if model has been acquired again meanwhile\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (model instanceof SimpleNotebookEditorModel) {\n\t\t\t\t\tawait model.canDispose();\n\t\t\t\t}\n\n\t\t\t\tif (!this.modelsToDispose.has(key)) {\n\t\t\t\t\t// return if model has been acquired again meanwhile\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Finally we can dispose the model\n\t\t\t\tthis._modelListener.get(model)?.dispose();\n\t\t\t\tthis._modelListener.delete(model);\n\t\t\t\tmodel.dispose();\n\t\t\t} catch (err) {\n\t\t\t\tthis._notebookLoggingService.error('NotebookModelCollection', 'FAILED to destory notebook - ' + err);\n\t\t\t} finally {\n\t\t\t\tthis.modelsToDispose.delete(key); // Untrack as being disposed\n\t\t\t}\n\t\t})();\n\t}\n}\n\nexport class NotebookModelResolverServiceImpl implements INotebookEditorModelResolverService {\n\n\treadonly _serviceBrand: undefined;\n\n\tprivate readonly _data: NotebookModelReferenceCollection;\n\n\treadonly onDidSaveNotebook: Event<URI>;\n\treadonly onDidChangeDirty: Event<IResolvedNotebookEditorModel>;\n\n\tprivate readonly _onWillFailWithConflict = new AsyncEmitter<INotebookConflictEvent>();\n\treadonly onWillFailWithConflict = this._onWillFailWithConflict.event;\n\n\tconstructor(\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@INotebookService private readonly _notebookService: INotebookService,\n\t\t@IExtensionService private readonly _extensionService: IExtensionService,\n\t\t@IUriIdentityService private readonly _uriIdentService: IUriIdentityService,\n\t) {\n\t\tthis._data = instantiationService.createInstance(NotebookModelReferenceCollection);\n\t\tthis.onDidSaveNotebook = this._data.onDidSaveNotebook;\n\t\tthis.onDidChangeDirty = this._data.onDidChangeDirty;\n\t}\n\n\tdispose() {\n\t\tthis._data.dispose();\n\t}\n\n\tisDirty(resource: URI): boolean {\n\t\treturn this._data.isDirty(resource);\n\t}\n\n\tprivate createUntitledUri(notebookType: string) {\n\t\tconst info = this._notebookService.getContributedNotebookType(assertReturnsDefined(notebookType));\n\t\tif (!info) {\n\t\t\tthrow new Error('UNKNOWN notebook type: ' + notebookType);\n\t\t}\n\n\t\tconst suffix = NotebookProviderInfo.possibleFileEnding(info.selectors) ?? '';\n\t\tfor (let counter = 1; ; counter++) {\n\t\t\tconst candidate = URI.from({ scheme: Schemas.untitled, path: `Untitled-${counter}${suffix}`, query: notebookType });\n\t\t\tif (!this._notebookService.getNotebookTextModel(candidate) && !this._data.isListeningToModel(candidate)) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async validateResourceViewType(uri: URI | undefined, viewType: string | undefined) {\n\t\tif (!uri && !viewType) {\n\t\t\tthrow new Error('Must provide at least one of resource or viewType');\n\t\t}\n\n\t\tif (uri?.scheme === CellUri.scheme) {\n\t\t\tconst originalUri = uri;\n\t\t\turi = parse(uri)?.notebook;\n\t\t\tif (!uri) {\n\t\t\t\tthrow new Error(`CANNOT open a cell-uri as notebook. Tried with ${originalUri.toString()}`);\n\t\t\t}\n\t\t}\n\n\t\tconst resource = this._uriIdentService.asCanonicalUri(uri ?? this.createUntitledUri(viewType!));\n\n\t\tconst existingNotebook = this._notebookService.getNotebookTextModel(resource);\n\t\tif (!viewType) {\n\t\t\tif (existingNotebook) {\n\t\t\t\tviewType = existingNotebook.viewType;\n\t\t\t} else {\n\t\t\t\tawait this._extensionService.whenInstalledExtensionsRegistered();\n\t\t\t\tconst providers = this._notebookService.getContributedNotebookTypes(resource);\n\t\t\t\tviewType = providers.find(provider => provider.priority === 'exclusive')?.id ??\n\t\t\t\t\tproviders.find(provider => provider.priority === 'default')?.id ??\n\t\t\t\t\tproviders[0]?.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!viewType) {\n\t\t\tthrow new Error(`Missing viewType for '${resource}'`);\n\t\t}\n\n\t\tif (existingNotebook && existingNotebook.viewType !== viewType) {\n\n\t\t\tawait this._onWillFailWithConflict.fireAsync({ resource: resource, viewType }, CancellationToken.None);\n\n\t\t\t// check again, listener should have done cleanup\n\t\t\tconst existingViewType2 = this._notebookService.getNotebookTextModel(resource)?.viewType;\n\t\t\tif (existingViewType2 && existingViewType2 !== viewType) {\n\t\t\t\tthrow new Error(`A notebook with view type '${existingViewType2}' already exists for '${resource}', CANNOT create another notebook with view type ${viewType}`);\n\t\t\t}\n\t\t}\n\t\treturn { resource, viewType };\n\t}\n\n\tpublic async createUntitledNotebookTextModel(viewType: string) {\n\t\tconst resource = this._uriIdentService.asCanonicalUri(this.createUntitledUri(viewType));\n\n\t\treturn (await this._notebookService.createNotebookTextModel(viewType, resource));\n\t}\n\n\tasync resolve(resource: URI, viewType?: string, options?: NotebookEditorModelCreationOptions): Promise<IReference<IResolvedNotebookEditorModel>>;\n\tasync resolve(resource: IUntitledNotebookResource, viewType: string, options: NotebookEditorModelCreationOptions): Promise<IReference<IResolvedNotebookEditorModel>>;\n\tasync resolve(arg0: URI | IUntitledNotebookResource, viewType?: string, options?: NotebookEditorModelCreationOptions): Promise<IReference<IResolvedNotebookEditorModel>> {\n\t\tlet resource: URI | undefined;\n\t\tlet hasAssociatedFilePath;\n\t\tif (URI.isUri(arg0)) {\n\t\t\tresource = arg0;\n\t\t} else if (arg0.untitledResource) {\n\t\t\tif (arg0.untitledResource.scheme === Schemas.untitled) {\n\t\t\t\tresource = arg0.untitledResource;\n\t\t\t} else {\n\t\t\t\tresource = arg0.untitledResource.with({ scheme: Schemas.untitled });\n\t\t\t\thasAssociatedFilePath = true;\n\t\t\t}\n\t\t}\n\n\t\tconst validated = await this.validateResourceViewType(resource, viewType);\n\n\t\tconst reference = this._data.acquire(validated.resource.toString(), validated.viewType, hasAssociatedFilePath, options?.limits, options?.scratchpad, options?.viewType);\n\t\ttry {\n\t\t\tconst model = await reference.object;\n\t\t\treturn {\n\t\t\t\tobject: model,\n\t\t\t\tdispose() { reference.dispose(); }\n\t\t\t};\n\t\t} catch (err) {\n\t\t\treference.dispose();\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { CellUri, IResolvedNotebookEditorModel, NotebookEditorModelCreationOptions, NotebookSetting, NotebookWorkingCopyTypeIdentifier } from './notebookCommon.js';\nimport { NotebookFileWorkingCopyModel, NotebookFileWorkingCopyModelFactory, SimpleNotebookEditorModel } from './notebookEditorModel.js';\nimport { combinedDisposable, DisposableStore, dispose, IDisposable, IReference, ReferenceCollection, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { INotebookService } from './notebookService.js';\nimport { AsyncEmitter, Emitter, Event } from '../../../../base/common/event.js';\nimport { IExtensionService } from '../../../services/extensions/common/extensions.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { INotebookConflictEvent, INotebookEditorModelResolverService, IUntitledNotebookResource } from './notebookEditorModelResolverService.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { FileWorkingCopyManager, IFileWorkingCopyManager } from '../../../services/workingCopy/common/fileWorkingCopyManager.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { NotebookProviderInfo } from './notebookProvider.js';\nimport { assertReturnsDefined } from '../../../../base/common/types.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IFileReadLimits } from '../../../../platform/files/common/files.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { INotebookLoggingService } from './notebookLoggingService.js';\nimport { parse } from '../../../services/notebook/common/notebookDocumentService.js';\n\nclass NotebookModelReferenceCollection extends ReferenceCollection<Promise<IResolvedNotebookEditorModel>> {\n\n\tprivate readonly _disposables = new DisposableStore();\n\tprivate readonly _workingCopyManagers = new Map<string, IFileWorkingCopyManager<NotebookFileWorkingCopyModel, NotebookFileWorkingCopyModel>>();\n\tprivate readonly _modelListener = new Map<IResolvedNotebookEditorModel, IDisposable>();\n\n\tprivate readonly _onDidSaveNotebook = new Emitter<URI>();\n\treadonly onDidSaveNotebook: Event<URI> = this._onDidSaveNotebook.event;\n\n\tprivate readonly _onDidChangeDirty = new Emitter<IResolvedNotebookEditorModel>();\n\treadonly onDidChangeDirty: Event<IResolvedNotebookEditorModel> = this._onDidChangeDirty.event;\n\n\tprivate readonly _dirtyStates = new ResourceMap<boolean>();\n\n\tprivate readonly modelsToDispose = new Set<string>();\n\tconstructor(\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@INotebookService private readonly _notebookService: INotebookService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService,\n\t\t@INotebookLoggingService private readonly _notebookLoggingService: INotebookLoggingService,\n\t) {\n\t\tsuper();\n\t}\n\n\tdispose(): void {\n\t\tthis._disposables.dispose();\n\t\tthis._onDidSaveNotebook.dispose();\n\t\tthis._onDidChangeDirty.dispose();\n\t\tdispose(this._modelListener.values());\n\t\tdispose(this._workingCopyManagers.values());\n\t}\n\n\tisDirty(resource: URI): boolean {\n\t\treturn this._dirtyStates.get(resource) ?? false;\n\t}\n\n\tisListeningToModel(uri: URI): boolean {\n\t\tfor (const key of this._modelListener.keys()) {\n\t\t\tif (key.resource.toString() === uri.toString()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected async createReferencedObject(key: string, notebookType: string, hasAssociatedFilePath: boolean, limits?: IFileReadLimits, isScratchpad?: boolean, viewType?: string): Promise<IResolvedNotebookEditorModel> {\n\t\t// Untrack as being disposed\n\t\tthis.modelsToDispose.delete(key);\n\n\t\tconst uri = URI.parse(key);\n\n\t\tconst workingCopyTypeId = NotebookWorkingCopyTypeIdentifier.create(notebookType, viewType);\n\t\tlet workingCopyManager = this._workingCopyManagers.get(workingCopyTypeId);\n\t\tif (!workingCopyManager) {\n\t\t\tconst factory = new NotebookFileWorkingCopyModelFactory(notebookType, this._notebookService, this._configurationService, this._telemetryService, this._notebookLoggingService);\n\t\t\tworkingCopyManager = this._instantiationService.createInstance(\n\t\t\t\tFileWorkingCopyManager<NotebookFileWorkingCopyModel, NotebookFileWorkingCopyModel>,\n\t\t\t\tworkingCopyTypeId,\n\t\t\t\tfactory,\n\t\t\t\tfactory,\n\t\t\t);\n\t\t\tthis._workingCopyManagers.set(workingCopyTypeId, workingCopyManager);\n\t\t}\n\n\t\tconst isScratchpadView = isScratchpad || (notebookType === 'interactive' && this._configurationService.getValue<boolean>(NotebookSetting.InteractiveWindowPromptToSave) !== true);\n\t\tconst model = this._instantiationService.createInstance(SimpleNotebookEditorModel, uri, hasAssociatedFilePath, notebookType, workingCopyManager, isScratchpadView);\n\t\tconst result = await model.load({ limits });\n\n\n\t\t// Whenever a notebook model is dirty we automatically reference it so that\n\t\t// we can ensure that at least one reference exists. That guarantees that\n\t\t// a model with unsaved changes is never disposed.\n\t\tlet onDirtyAutoReference: IReference<any> | undefined;\n\n\t\tthis._modelListener.set(result, combinedDisposable(\n\t\t\tresult.onDidSave(() => this._onDidSaveNotebook.fire(result.resource)),\n\t\t\tresult.onDidChangeDirty(() => {\n\t\t\t\tconst isDirty = result.isDirty();\n\t\t\t\tthis._dirtyStates.set(result.resource, isDirty);\n\n\t\t\t\t// isDirty -> add reference\n\t\t\t\t// !isDirty -> free reference\n\t\t\t\tif (isDirty && !onDirtyAutoReference) {\n\t\t\t\t\tonDirtyAutoReference = this.acquire(key, notebookType);\n\t\t\t\t} else if (onDirtyAutoReference) {\n\t\t\t\t\tonDirtyAutoReference.dispose();\n\t\t\t\t\tonDirtyAutoReference = undefined;\n\t\t\t\t}\n\n\t\t\t\tthis._onDidChangeDirty.fire(result);\n\t\t\t}),\n\t\t\ttoDisposable(() => onDirtyAutoReference?.dispose()),\n\t\t));\n\t\treturn result;\n\t}\n\n\tprotected destroyReferencedObject(key: string, object: Promise<IResolvedNotebookEditorModel>): void {\n\t\tthis.modelsToDispose.add(key);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tconst model = await object;\n\n\t\t\t\tif (!this.modelsToDispose.has(key)) {\n\t\t\t\t\t// return if model has been acquired again meanwhile\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (model instanceof SimpleNotebookEditorModel) {\n\t\t\t\t\tawait model.canDispose();\n\t\t\t\t}\n\n\t\t\t\tif (!this.modelsToDispose.has(key)) {\n\t\t\t\t\t// return if model has been acquired again meanwhile\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Finally we can dispose the model\n\t\t\t\tthis._modelListener.get(model)?.dispose();\n\t\t\t\tthis._modelListener.delete(model);\n\t\t\t\tmodel.dispose();\n\t\t\t} catch (err) {\n\t\t\t\tthis._notebookLoggingService.error('NotebookModelCollection', 'FAILED to destory notebook - ' + err);\n\t\t\t} finally {\n\t\t\t\tthis.modelsToDispose.delete(key); // Untrack as being disposed\n\t\t\t}\n\t\t})();\n\t}\n}\n\nexport class NotebookModelResolverServiceImpl implements INotebookEditorModelResolverService {\n\n\treadonly _serviceBrand: undefined;\n\n\tprivate readonly _data: NotebookModelReferenceCollection;\n\n\treadonly onDidSaveNotebook: Event<URI>;\n\treadonly onDidChangeDirty: Event<IResolvedNotebookEditorModel>;\n\n\tprivate readonly _onWillFailWithConflict = new AsyncEmitter<INotebookConflictEvent>();\n\treadonly onWillFailWithConflict = this._onWillFailWithConflict.event;\n\n\tconstructor(\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@INotebookService private readonly _notebookService: INotebookService,\n\t\t@IExtensionService private readonly _extensionService: IExtensionService,\n\t\t@IUriIdentityService private readonly _uriIdentService: IUriIdentityService,\n\t) {\n\t\tthis._data = instantiationService.createInstance(NotebookModelReferenceCollection);\n\t\tthis.onDidSaveNotebook = this._data.onDidSaveNotebook;\n\t\tthis.onDidChangeDirty = this._data.onDidChangeDirty;\n\t}\n\n\tdispose() {\n\t\tthis._data.dispose();\n\t}\n\n\tisDirty(resource: URI): boolean {\n\t\treturn this._data.isDirty(resource);\n\t}\n\n\tprivate createUntitledUri(notebookType: string) {\n\t\tconst info = this._notebookService.getContributedNotebookType(assertReturnsDefined(notebookType));\n\t\tif (!info) {\n\t\t\tthrow new Error('UNKNOWN notebook type: ' + notebookType);\n\t\t}\n\n\t\tconst suffix = NotebookProviderInfo.possibleFileEnding(info.selectors) ?? '';\n\t\tfor (let counter = 1; ; counter++) {\n\t\t\tconst candidate = URI.from({ scheme: Schemas.untitled, path: `Untitled-${counter}${suffix}`, query: notebookType });\n\t\t\tif (!this._notebookService.getNotebookTextModel(candidate) && !this._data.isListeningToModel(candidate)) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async validateResourceViewType(uri: URI | undefined, viewType: string | undefined) {\n\t\tif (!uri && !viewType) {\n\t\t\tthrow new Error('Must provide at least one of resource or viewType');\n\t\t}\n\n\t\tif (uri?.scheme === CellUri.scheme) {\n\t\t\tconst originalUri = uri;\n\t\t\turi = parse(uri)?.notebook;\n\t\t\tif (!uri) {\n\t\t\t\tthrow new Error(`CANNOT open a cell-uri as notebook. Tried with ${originalUri.toString()}`);\n\t\t\t}\n\t\t}\n\n\t\tconst resource = this._uriIdentService.asCanonicalUri(uri ?? this.createUntitledUri(viewType!));\n\n\t\tconst existingNotebook = this._notebookService.getNotebookTextModel(resource);\n\t\tif (!viewType) {\n\t\t\tif (existingNotebook) {\n\t\t\t\tviewType = existingNotebook.viewType;\n\t\t\t} else {\n\t\t\t\tawait this._extensionService.whenInstalledExtensionsRegistered();\n\t\t\t\tconst providers = this._notebookService.getContributedNotebookTypes(resource);\n\t\t\t\tviewType = providers.find(provider => provider.priority === 'exclusive')?.id ??\n\t\t\t\t\tproviders.find(provider => provider.priority === 'default')?.id ??\n\t\t\t\t\tproviders[0]?.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!viewType) {\n\t\t\tthrow new Error(`Missing viewType for '${resource}'`);\n\t\t}\n\n\t\tif (existingNotebook && existingNotebook.viewType !== viewType) {\n\n\t\t\tawait this._onWillFailWithConflict.fireAsync({ resource: resource, viewType }, CancellationToken.None);\n\n\t\t\t// check again, listener should have done cleanup\n\t\t\tconst existingViewType2 = this._notebookService.getNotebookTextModel(resource)?.viewType;\n\t\t\tif (existingViewType2 && existingViewType2 !== viewType) {\n\t\t\t\tthrow new Error(`A notebook with view type '${existingViewType2}' already exists for '${resource}', CANNOT create another notebook with view type ${viewType}`);\n\t\t\t}\n\t\t}\n\t\treturn { resource, viewType };\n\t}\n\n\tpublic async createUntitledNotebookTextModel(viewType: string) {\n\t\tconst resource = this._uriIdentService.asCanonicalUri(this.createUntitledUri(viewType));\n\n\t\treturn (await this._notebookService.createNotebookTextModel(viewType, resource));\n\t}\n\n\tasync resolve(resource: URI, viewType?: string, options?: NotebookEditorModelCreationOptions): Promise<IReference<IResolvedNotebookEditorModel>>;\n\tasync resolve(resource: IUntitledNotebookResource, viewType: string, options: NotebookEditorModelCreationOptions): Promise<IReference<IResolvedNotebookEditorModel>>;\n\tasync resolve(arg0: URI | IUntitledNotebookResource, viewType?: string, options?: NotebookEditorModelCreationOptions): Promise<IReference<IResolvedNotebookEditorModel>> {\n\t\tlet resource: URI | undefined;\n\t\tlet hasAssociatedFilePath;\n\t\tif (URI.isUri(arg0)) {\n\t\t\tresource = arg0;\n\t\t} else if (arg0.untitledResource) {\n\t\t\tif (arg0.untitledResource.scheme === Schemas.untitled) {\n\t\t\t\tresource = arg0.untitledResource;\n\t\t\t} else {\n\t\t\t\tresource = arg0.untitledResource.with({ scheme: Schemas.untitled });\n\t\t\t\thasAssociatedFilePath = true;\n\t\t\t}\n\t\t}\n\n\t\tconst validated = await this.validateResourceViewType(resource, viewType);\n\n\t\tconst reference = this._data.acquire(validated.resource.toString(), validated.viewType, hasAssociatedFilePath, options?.limits, options?.scratchpad, options?.viewType);\n\t\ttry {\n\t\t\tconst model = await reference.object;\n\t\t\treturn {\n\t\t\t\tobject: model,\n\t\t\t\tdispose() { reference.dispose(); }\n\t\t\t};\n\t\t} catch (err) {\n\t\t\treference.dispose();\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n"]}