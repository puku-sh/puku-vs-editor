{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/notebook/common/model/notebookCellOutputTextModel.ts","vs/workbench/contrib/notebook/common/model/notebookCellOutputTextModel.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAGhG,OAAO,EAAE,OAAO,EAAE,MAAM,qCAAqC,CAAC;AAC9D,OAAO,EAAE,UAAU,EAAE,MAAM,yCAAyC,CAAC;AACrE,OAAO,EAA2C,yBAAyB,EAAE,MAAM,sBAAsB,CAAC;AAC1G,OAAO,EAAE,gBAAgB,EAAE,MAAM,oCAAoC,CAAC;AAEtE,MAAM,OAAO,2BAA4B,SAAQ,UAAU;IAK1D,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,IAAI,EAAE,CAAC;IACtC,CAAC;IAED,IAAI,QAAQ;QACX,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC;IACjC,CAAC;IAED,IAAI,QAAQ;QACX,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC;IACjC,CAAC;IAOD,IAAI,mBAAmB;QACtB,OAAO,IAAI,CAAC,oBAAoB,CAAC;IAClC,CAAC;IAID,IAAI,SAAS;QACZ,OAAO,IAAI,CAAC,UAAU,CAAC;IACxB,CAAC;IAED,YACS,UAAsB;QAE9B,KAAK,EAAE,CAAC;QAFA,eAAU,GAAV,UAAU,CAAY;QA/BvB,qBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QAC/D,oBAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC;QAuBtC,eAAU,GAAG,CAAC,CAAC;QAyCvB,iCAAiC;QACzB,2BAAsB,GAA2C,EAAE,CAAC;QA/B3E,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC;IACtD,CAAC;IAED,WAAW,CAAC,OAAmB;QAC9B,IAAI,CAAC,sBAAsB,GAAG,EAAE,CAAC;QACjC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC;QAC1B,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;QACtC,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,CAAC;IAC9B,CAAC;IAED,UAAU,CAAC,KAAuB;QACjC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;QACvC,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;QACtC,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,CAAC;IAC9B,CAAC;IAEO,kBAAkB;QACzB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;YAC7B,IAAI,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC;gBACnC,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC;oBAC/C,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;gBAC/C,CAAC;gBACD,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACnF,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAKD,oBAAoB,CAAC,SAAiB,EAAE,IAAY;QACnD,MAAM,YAAY,GAAG,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC;QACpE,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;QACjE,IAAI,YAAY,IAAI,MAAM,EAAE,CAAC;YAC5B,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;QACxC,CAAC;QAED,OAAO,SAAS,CAAC;IAClB,CAAC;IAEO,mBAAmB;QAC1B,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;YACxF,kEAAkE;YAClE,yDAAyD;YACzD,MAAM,WAAW,GAAG,IAAI,GAAG,EAAwB,CAAC;YACpD,MAAM,SAAS,GAAa,EAAE,CAAC;YAC/B,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBAC3B,IAAI,KAAmB,CAAC;gBACxB,IAAI,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;oBAChC,KAAK,GAAG,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAE,CAAC;gBACrC,CAAC;qBAAM,CAAC;oBACP,KAAK,GAAG,EAAE,CAAC;oBACX,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;oBAClC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC3B,CAAC;gBACD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC9B,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;YACxB,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACxB,MAAM,iBAAiB,GAAG,yBAAyB,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAE,CAAC,CAAC;gBAC5E,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;oBACjB,IAAI;oBACJ,IAAI,EAAE,iBAAiB,CAAC,IAAI;iBAC5B,CAAC,CAAC;gBACH,IAAI,iBAAiB,CAAC,cAAc,EAAE,CAAC;oBACtC,yEAAyE;oBACzE,IAAI,CAAC,sBAAsB,GAAG,EAAE,CAAC;gBAClC,CAAC;YACF,CAAC,CAAC,CAAC;QACJ,CAAC;IACF,CAAC;IAED,KAAK;QACJ,OAAO;YACN,oBAAoB;YACpB,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,QAAQ;YAClC,OAAO,EAAE,IAAI,CAAC,UAAU,CAAC,OAAO;YAChC,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,QAAQ;SAClC,CAAC;IACH,CAAC;IAED,WAAW;QACV,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;IACvC,CAAC;CAED","file":"notebookCellOutputTextModel.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../../../base/common/buffer.js';\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { ICellOutput, IOutputDto, IOutputItemDto, compressOutputItemStreams } from '../notebookCommon.js';\nimport { isTextStreamMime } from '../../../../../base/common/mime.js';\n\nexport class NotebookCellOutputTextModel extends Disposable implements ICellOutput {\n\n\tprivate _onDidChangeData = this._register(new Emitter<void>());\n\tonDidChangeData = this._onDidChangeData.event;\n\n\tget outputs() {\n\t\treturn this._rawOutput.outputs || [];\n\t}\n\n\tget metadata(): Record<string, unknown> | undefined {\n\t\treturn this._rawOutput.metadata;\n\t}\n\n\tget outputId(): string {\n\t\treturn this._rawOutput.outputId;\n\t}\n\n\t/**\n\t * Alternative output id that's reused when the output is updated.\n\t */\n\tprivate _alternativeOutputId: string;\n\n\tget alternativeOutputId(): string {\n\t\treturn this._alternativeOutputId;\n\t}\n\n\tprivate _versionId = 0;\n\n\tget versionId() {\n\t\treturn this._versionId;\n\t}\n\n\tconstructor(\n\t\tprivate _rawOutput: IOutputDto\n\t) {\n\t\tsuper();\n\n\t\tthis._alternativeOutputId = this._rawOutput.outputId;\n\t}\n\n\treplaceData(rawData: IOutputDto) {\n\t\tthis.versionedBufferLengths = {};\n\t\tthis._rawOutput = rawData;\n\t\tthis.optimizeOutputItems();\n\t\tthis._versionId = this._versionId + 1;\n\t\tthis._onDidChangeData.fire();\n\t}\n\n\tappendData(items: IOutputItemDto[]) {\n\t\tthis.trackBufferLengths();\n\t\tthis._rawOutput.outputs.push(...items);\n\t\tthis.optimizeOutputItems();\n\t\tthis._versionId = this._versionId + 1;\n\t\tthis._onDidChangeData.fire();\n\t}\n\n\tprivate trackBufferLengths() {\n\t\tthis.outputs.forEach(output => {\n\t\t\tif (isTextStreamMime(output.mime)) {\n\t\t\t\tif (!this.versionedBufferLengths[output.mime]) {\n\t\t\t\t\tthis.versionedBufferLengths[output.mime] = {};\n\t\t\t\t}\n\t\t\t\tthis.versionedBufferLengths[output.mime][this.versionId] = output.data.byteLength;\n\t\t\t}\n\t\t});\n\t}\n\n\t// mime: versionId: buffer length\n\tprivate versionedBufferLengths: Record<string, Record<number, number>> = {};\n\n\tappendedSinceVersion(versionId: number, mime: string): VSBuffer | undefined {\n\t\tconst bufferLength = this.versionedBufferLengths[mime]?.[versionId];\n\t\tconst output = this.outputs.find(output => output.mime === mime);\n\t\tif (bufferLength && output) {\n\t\t\treturn output.data.slice(bufferLength);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate optimizeOutputItems() {\n\t\tif (this.outputs.length > 1 && this.outputs.every(item => isTextStreamMime(item.mime))) {\n\t\t\t// Look for the mimes in the items, and keep track of their order.\n\t\t\t// Merge the streams into one output item, per mime type.\n\t\t\tconst mimeOutputs = new Map<string, Uint8Array[]>();\n\t\t\tconst mimeTypes: string[] = [];\n\t\t\tthis.outputs.forEach(item => {\n\t\t\t\tlet items: Uint8Array[];\n\t\t\t\tif (mimeOutputs.has(item.mime)) {\n\t\t\t\t\titems = mimeOutputs.get(item.mime)!;\n\t\t\t\t} else {\n\t\t\t\t\titems = [];\n\t\t\t\t\tmimeOutputs.set(item.mime, items);\n\t\t\t\t\tmimeTypes.push(item.mime);\n\t\t\t\t}\n\t\t\t\titems.push(item.data.buffer);\n\t\t\t});\n\t\t\tthis.outputs.length = 0;\n\t\t\tmimeTypes.forEach(mime => {\n\t\t\t\tconst compressionResult = compressOutputItemStreams(mimeOutputs.get(mime)!);\n\t\t\t\tthis.outputs.push({\n\t\t\t\t\tmime,\n\t\t\t\t\tdata: compressionResult.data\n\t\t\t\t});\n\t\t\t\tif (compressionResult.didCompression) {\n\t\t\t\t\t// we can't rely on knowing buffer lengths if we've erased previous lines\n\t\t\t\t\tthis.versionedBufferLengths = {};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tasDto(): IOutputDto {\n\t\treturn {\n\t\t\t// data: this._data,\n\t\t\tmetadata: this._rawOutput.metadata,\n\t\t\toutputs: this._rawOutput.outputs,\n\t\t\toutputId: this._rawOutput.outputId\n\t\t};\n\t}\n\n\tbumpVersion() {\n\t\tthis._versionId = this._versionId + 1;\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../../../base/common/buffer.js';\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { ICellOutput, IOutputDto, IOutputItemDto, compressOutputItemStreams } from '../notebookCommon.js';\nimport { isTextStreamMime } from '../../../../../base/common/mime.js';\n\nexport class NotebookCellOutputTextModel extends Disposable implements ICellOutput {\n\n\tprivate _onDidChangeData = this._register(new Emitter<void>());\n\tonDidChangeData = this._onDidChangeData.event;\n\n\tget outputs() {\n\t\treturn this._rawOutput.outputs || [];\n\t}\n\n\tget metadata(): Record<string, unknown> | undefined {\n\t\treturn this._rawOutput.metadata;\n\t}\n\n\tget outputId(): string {\n\t\treturn this._rawOutput.outputId;\n\t}\n\n\t/**\n\t * Alternative output id that's reused when the output is updated.\n\t */\n\tprivate _alternativeOutputId: string;\n\n\tget alternativeOutputId(): string {\n\t\treturn this._alternativeOutputId;\n\t}\n\n\tprivate _versionId = 0;\n\n\tget versionId() {\n\t\treturn this._versionId;\n\t}\n\n\tconstructor(\n\t\tprivate _rawOutput: IOutputDto\n\t) {\n\t\tsuper();\n\n\t\tthis._alternativeOutputId = this._rawOutput.outputId;\n\t}\n\n\treplaceData(rawData: IOutputDto) {\n\t\tthis.versionedBufferLengths = {};\n\t\tthis._rawOutput = rawData;\n\t\tthis.optimizeOutputItems();\n\t\tthis._versionId = this._versionId + 1;\n\t\tthis._onDidChangeData.fire();\n\t}\n\n\tappendData(items: IOutputItemDto[]) {\n\t\tthis.trackBufferLengths();\n\t\tthis._rawOutput.outputs.push(...items);\n\t\tthis.optimizeOutputItems();\n\t\tthis._versionId = this._versionId + 1;\n\t\tthis._onDidChangeData.fire();\n\t}\n\n\tprivate trackBufferLengths() {\n\t\tthis.outputs.forEach(output => {\n\t\t\tif (isTextStreamMime(output.mime)) {\n\t\t\t\tif (!this.versionedBufferLengths[output.mime]) {\n\t\t\t\t\tthis.versionedBufferLengths[output.mime] = {};\n\t\t\t\t}\n\t\t\t\tthis.versionedBufferLengths[output.mime][this.versionId] = output.data.byteLength;\n\t\t\t}\n\t\t});\n\t}\n\n\t// mime: versionId: buffer length\n\tprivate versionedBufferLengths: Record<string, Record<number, number>> = {};\n\n\tappendedSinceVersion(versionId: number, mime: string): VSBuffer | undefined {\n\t\tconst bufferLength = this.versionedBufferLengths[mime]?.[versionId];\n\t\tconst output = this.outputs.find(output => output.mime === mime);\n\t\tif (bufferLength && output) {\n\t\t\treturn output.data.slice(bufferLength);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate optimizeOutputItems() {\n\t\tif (this.outputs.length > 1 && this.outputs.every(item => isTextStreamMime(item.mime))) {\n\t\t\t// Look for the mimes in the items, and keep track of their order.\n\t\t\t// Merge the streams into one output item, per mime type.\n\t\t\tconst mimeOutputs = new Map<string, Uint8Array[]>();\n\t\t\tconst mimeTypes: string[] = [];\n\t\t\tthis.outputs.forEach(item => {\n\t\t\t\tlet items: Uint8Array[];\n\t\t\t\tif (mimeOutputs.has(item.mime)) {\n\t\t\t\t\titems = mimeOutputs.get(item.mime)!;\n\t\t\t\t} else {\n\t\t\t\t\titems = [];\n\t\t\t\t\tmimeOutputs.set(item.mime, items);\n\t\t\t\t\tmimeTypes.push(item.mime);\n\t\t\t\t}\n\t\t\t\titems.push(item.data.buffer);\n\t\t\t});\n\t\t\tthis.outputs.length = 0;\n\t\t\tmimeTypes.forEach(mime => {\n\t\t\t\tconst compressionResult = compressOutputItemStreams(mimeOutputs.get(mime)!);\n\t\t\t\tthis.outputs.push({\n\t\t\t\t\tmime,\n\t\t\t\t\tdata: compressionResult.data\n\t\t\t\t});\n\t\t\t\tif (compressionResult.didCompression) {\n\t\t\t\t\t// we can't rely on knowing buffer lengths if we've erased previous lines\n\t\t\t\t\tthis.versionedBufferLengths = {};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tasDto(): IOutputDto {\n\t\treturn {\n\t\t\t// data: this._data,\n\t\t\tmetadata: this._rawOutput.metadata,\n\t\t\toutputs: this._rawOutput.outputs,\n\t\t\toutputId: this._rawOutput.outputId\n\t\t};\n\t}\n\n\tbumpVersion() {\n\t\tthis._versionId = this._versionId + 1;\n\t}\n\n}\n"]}