{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/notebook/common/notebookRange.ts","vs/workbench/contrib/notebook/common/notebookRange.ts"],"names":[],"mappings":"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","file":"notebookRange.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * [start, end]\n */\nexport interface ICellRange {\n\t/**\n\t * zero based index\n\t */\n\tstart: number;\n\n\t/**\n\t * zero based index\n\t */\n\tend: number;\n}\n\n\nexport function isICellRange(candidate: any): candidate is ICellRange {\n\tif (!candidate || typeof candidate !== 'object') {\n\t\treturn false;\n\t}\n\treturn typeof (<ICellRange>candidate).start === 'number'\n\t\t&& typeof (<ICellRange>candidate).end === 'number';\n}\n\nexport function cellIndexesToRanges(indexes: number[]) {\n\tindexes.sort((a, b) => a - b);\n\tconst first = indexes.shift();\n\n\tif (first === undefined) {\n\t\treturn [];\n\t}\n\n\treturn indexes.reduce(function (ranges, num) {\n\t\tif (num <= ranges[0][1]) {\n\t\t\tranges[0][1] = num + 1;\n\t\t} else {\n\t\t\tranges.unshift([num, num + 1]);\n\t\t}\n\t\treturn ranges;\n\t}, [[first, first + 1]]).reverse().map(val => ({ start: val[0], end: val[1] }));\n}\n\nexport function cellRangesToIndexes(ranges: ICellRange[]) {\n\tconst indexes = ranges.reduce((a, b) => {\n\t\tfor (let i = b.start; i < b.end; i++) {\n\t\t\ta.push(i);\n\t\t}\n\n\t\treturn a;\n\t}, [] as number[]);\n\n\treturn indexes;\n}\n\nexport function reduceCellRanges(ranges: ICellRange[]): ICellRange[] {\n\tconst sorted = ranges.sort((a, b) => a.start - b.start);\n\tconst first = sorted[0];\n\n\tif (!first) {\n\t\treturn [];\n\t}\n\n\tconst reduced = sorted.reduce((prev: ICellRange[], curr) => {\n\t\tconst last = prev[prev.length - 1];\n\t\tif (last.end >= curr.start) {\n\t\t\tlast.end = Math.max(last.end, curr.end);\n\t\t} else {\n\t\t\tprev.push(curr);\n\t\t}\n\t\treturn prev;\n\t}, [first] as ICellRange[]);\n\n\tif (reduced.length > 1) {\n\t\t// remove the (0, 0) range\n\t\treturn reduced.filter(range => !(range.start === range.end && range.start === 0));\n\t}\n\n\treturn reduced;\n}\n\nexport function cellRangesEqual(a: ICellRange[], b: ICellRange[]) {\n\ta = reduceCellRanges(a);\n\tb = reduceCellRanges(b);\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i].start !== b[i].start || a[i].end !== b[i].end) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * todo@rebornix test and sort\n * @param range\n * @param other\n * @returns\n */\n\nexport function cellRangeContains(range: ICellRange, other: ICellRange): boolean {\n\treturn other.start >= range.start && other.end <= range.end;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * [start, end]\n */\nexport interface ICellRange {\n\t/**\n\t * zero based index\n\t */\n\tstart: number;\n\n\t/**\n\t * zero based index\n\t */\n\tend: number;\n}\n\n\nexport function isICellRange(candidate: any): candidate is ICellRange {\n\tif (!candidate || typeof candidate !== 'object') {\n\t\treturn false;\n\t}\n\treturn typeof (<ICellRange>candidate).start === 'number'\n\t\t&& typeof (<ICellRange>candidate).end === 'number';\n}\n\nexport function cellIndexesToRanges(indexes: number[]) {\n\tindexes.sort((a, b) => a - b);\n\tconst first = indexes.shift();\n\n\tif (first === undefined) {\n\t\treturn [];\n\t}\n\n\treturn indexes.reduce(function (ranges, num) {\n\t\tif (num <= ranges[0][1]) {\n\t\t\tranges[0][1] = num + 1;\n\t\t} else {\n\t\t\tranges.unshift([num, num + 1]);\n\t\t}\n\t\treturn ranges;\n\t}, [[first, first + 1]]).reverse().map(val => ({ start: val[0], end: val[1] }));\n}\n\nexport function cellRangesToIndexes(ranges: ICellRange[]) {\n\tconst indexes = ranges.reduce((a, b) => {\n\t\tfor (let i = b.start; i < b.end; i++) {\n\t\t\ta.push(i);\n\t\t}\n\n\t\treturn a;\n\t}, [] as number[]);\n\n\treturn indexes;\n}\n\nexport function reduceCellRanges(ranges: ICellRange[]): ICellRange[] {\n\tconst sorted = ranges.sort((a, b) => a.start - b.start);\n\tconst first = sorted[0];\n\n\tif (!first) {\n\t\treturn [];\n\t}\n\n\tconst reduced = sorted.reduce((prev: ICellRange[], curr) => {\n\t\tconst last = prev[prev.length - 1];\n\t\tif (last.end >= curr.start) {\n\t\t\tlast.end = Math.max(last.end, curr.end);\n\t\t} else {\n\t\t\tprev.push(curr);\n\t\t}\n\t\treturn prev;\n\t}, [first] as ICellRange[]);\n\n\tif (reduced.length > 1) {\n\t\t// remove the (0, 0) range\n\t\treturn reduced.filter(range => !(range.start === range.end && range.start === 0));\n\t}\n\n\treturn reduced;\n}\n\nexport function cellRangesEqual(a: ICellRange[], b: ICellRange[]) {\n\ta = reduceCellRanges(a);\n\tb = reduceCellRanges(b);\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i].start !== b[i].start || a[i].end !== b[i].end) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * todo@rebornix test and sort\n * @param range\n * @param other\n * @returns\n */\n\nexport function cellRangeContains(range: ICellRange, other: ICellRange): boolean {\n\treturn other.start >= range.start && other.end <= range.end;\n}\n"]}