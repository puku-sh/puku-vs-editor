{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/notebook/browser/view/cellParts/cellDnd.ts","vs/workbench/contrib/notebook/browser/view/cellParts/cellDnd.ts"],"names":[],"mappings":"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","file":"cellDnd.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from '../../../../../../base/browser/dom.js';\nimport { Delayer } from '../../../../../../base/common/async.js';\nimport { Disposable, MutableDisposable } from '../../../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../../../base/common/platform.js';\nimport { expandCellRangesWithHiddenCells, ICellViewModel, INotebookEditorDelegate } from '../../notebookBrowser.js';\nimport { CellViewModelStateChangeEvent } from '../../notebookViewEvents.js';\nimport { CellContentPart } from '../cellPart.js';\nimport { BaseCellRenderTemplate, INotebookCellList } from '../notebookRenderingCommon.js';\nimport { cloneNotebookCellTextModel } from '../../../common/model/notebookCellTextModel.js';\nimport { CellEditType, ICellMoveEdit, SelectionStateType } from '../../../common/notebookCommon.js';\nimport { cellRangesToIndexes, ICellRange } from '../../../common/notebookRange.js';\n\nconst $ = DOM.$;\n\nconst DRAGGING_CLASS = 'cell-dragging';\nconst GLOBAL_DRAG_CLASS = 'global-drag-active';\n\ntype DragImageProvider = () => HTMLElement;\n\ninterface CellDragEvent {\n\tbrowserEvent: DragEvent;\n\tdraggedOverCell: ICellViewModel;\n\tcellTop: number;\n\tcellHeight: number;\n\tdragPosRatio: number;\n}\n\nexport class CellDragAndDropPart extends CellContentPart {\n\tconstructor(\n\t\tprivate readonly container: HTMLElement\n\t) {\n\t\tsuper();\n\t}\n\n\toverride didRenderCell(element: ICellViewModel): void {\n\t\tthis.update(element);\n\t}\n\n\toverride updateState(element: ICellViewModel, e: CellViewModelStateChangeEvent): void {\n\t\tif (e.dragStateChanged) {\n\t\t\tthis.update(element);\n\t\t}\n\t}\n\n\tprivate update(element: ICellViewModel) {\n\t\tthis.container.classList.toggle(DRAGGING_CLASS, element.dragging);\n\t}\n}\n\nexport class CellDragAndDropController extends Disposable {\n\t// TODO@roblourens - should probably use dataTransfer here, but any dataTransfer set makes the editor think I am dropping a file, need\n\t// to figure out how to prevent that\n\tprivate currentDraggedCell: ICellViewModel | undefined;\n\tprivate draggedCells: ICellViewModel[] = [];\n\n\tprivate listInsertionIndicator: HTMLElement;\n\n\tprivate list!: INotebookCellList;\n\n\tprivate isScrolling = false;\n\tprivate readonly scrollingDelayer: Delayer<void>;\n\n\tprivate readonly listOnWillScrollListener = this._register(new MutableDisposable());\n\n\tconstructor(\n\t\tprivate notebookEditor: INotebookEditorDelegate,\n\t\tprivate readonly notebookListContainer: HTMLElement\n\t) {\n\t\tsuper();\n\n\t\tthis.listInsertionIndicator = DOM.append(notebookListContainer, $('.cell-list-insertion-indicator'));\n\n\t\tthis._register(DOM.addDisposableListener(notebookListContainer.ownerDocument.body, DOM.EventType.DRAG_START, this.onGlobalDragStart.bind(this), true));\n\t\tthis._register(DOM.addDisposableListener(notebookListContainer.ownerDocument.body, DOM.EventType.DRAG_END, this.onGlobalDragEnd.bind(this), true));\n\n\t\tconst addCellDragListener = (eventType: string, handler: (e: CellDragEvent) => void, useCapture = false) => {\n\t\t\tthis._register(DOM.addDisposableListener(\n\t\t\t\tnotebookEditor.getDomNode(),\n\t\t\t\teventType,\n\t\t\t\te => {\n\t\t\t\t\tconst cellDragEvent = this.toCellDragEvent(e);\n\t\t\t\t\tif (cellDragEvent) {\n\t\t\t\t\t\thandler(cellDragEvent);\n\t\t\t\t\t}\n\t\t\t\t}, useCapture));\n\t\t};\n\n\t\taddCellDragListener(DOM.EventType.DRAG_OVER, event => {\n\t\t\tif (!this.currentDraggedCell) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tevent.browserEvent.preventDefault();\n\t\t\tthis.onCellDragover(event);\n\t\t}, true);\n\t\taddCellDragListener(DOM.EventType.DROP, event => {\n\t\t\tif (!this.currentDraggedCell) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tevent.browserEvent.preventDefault();\n\t\t\tthis.onCellDrop(event);\n\t\t});\n\t\taddCellDragListener(DOM.EventType.DRAG_LEAVE, event => {\n\t\t\tevent.browserEvent.preventDefault();\n\t\t\tthis.onCellDragLeave(event);\n\t\t});\n\n\t\tthis.scrollingDelayer = this._register(new Delayer(200));\n\t}\n\n\tsetList(value: INotebookCellList) {\n\t\tthis.list = value;\n\n\t\tthis.listOnWillScrollListener.value = this.list.onWillScroll(e => {\n\t\t\tif (!e.scrollTopChanged) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.setInsertIndicatorVisibility(false);\n\t\t\tthis.isScrolling = true;\n\t\t\tthis.scrollingDelayer.trigger(() => {\n\t\t\t\tthis.isScrolling = false;\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate setInsertIndicatorVisibility(visible: boolean) {\n\t\tthis.listInsertionIndicator.style.opacity = visible ? '1' : '0';\n\t}\n\n\tprivate toCellDragEvent(event: DragEvent): CellDragEvent | undefined {\n\t\tconst targetTop = this.notebookListContainer.getBoundingClientRect().top;\n\t\tconst dragOffset = this.list.scrollTop + event.clientY - targetTop;\n\t\tconst draggedOverCell = this.list.elementAt(dragOffset);\n\t\tif (!draggedOverCell) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst cellTop = this.list.getCellViewScrollTop(draggedOverCell);\n\t\tconst cellHeight = this.list.elementHeight(draggedOverCell);\n\n\t\tconst dragPosInElement = dragOffset - cellTop;\n\t\tconst dragPosRatio = dragPosInElement / cellHeight;\n\n\t\treturn {\n\t\t\tbrowserEvent: event,\n\t\t\tdraggedOverCell,\n\t\t\tcellTop,\n\t\t\tcellHeight,\n\t\t\tdragPosRatio\n\t\t};\n\t}\n\n\tclearGlobalDragState() {\n\t\tthis.notebookEditor.getDomNode().classList.remove(GLOBAL_DRAG_CLASS);\n\t}\n\n\tprivate onGlobalDragStart() {\n\t\tthis.notebookEditor.getDomNode().classList.add(GLOBAL_DRAG_CLASS);\n\t}\n\n\tprivate onGlobalDragEnd() {\n\t\tthis.notebookEditor.getDomNode().classList.remove(GLOBAL_DRAG_CLASS);\n\t}\n\n\tprivate onCellDragover(event: CellDragEvent): void {\n\t\tif (!event.browserEvent.dataTransfer) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.currentDraggedCell) {\n\t\t\tevent.browserEvent.dataTransfer.dropEffect = 'none';\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.isScrolling || this.currentDraggedCell === event.draggedOverCell) {\n\t\t\tthis.setInsertIndicatorVisibility(false);\n\t\t\treturn;\n\t\t}\n\n\t\tconst dropDirection = this.getDropInsertDirection(event.dragPosRatio);\n\t\tconst insertionIndicatorAbsolutePos = dropDirection === 'above' ? event.cellTop : event.cellTop + event.cellHeight;\n\t\tthis.updateInsertIndicator(dropDirection, insertionIndicatorAbsolutePos);\n\t}\n\n\tprivate updateInsertIndicator(dropDirection: string, insertionIndicatorAbsolutePos: number) {\n\t\tconst { bottomToolbarGap } = this.notebookEditor.notebookOptions.computeBottomToolbarDimensions(this.notebookEditor.textModel?.viewType);\n\t\tconst insertionIndicatorTop = insertionIndicatorAbsolutePos - this.list.scrollTop + bottomToolbarGap / 2;\n\t\tif (insertionIndicatorTop >= 0) {\n\t\t\tthis.listInsertionIndicator.style.top = `${insertionIndicatorTop}px`;\n\t\t\tthis.setInsertIndicatorVisibility(true);\n\t\t} else {\n\t\t\tthis.setInsertIndicatorVisibility(false);\n\t\t}\n\t}\n\n\tprivate getDropInsertDirection(dragPosRatio: number): 'above' | 'below' {\n\t\treturn dragPosRatio < 0.5 ? 'above' : 'below';\n\t}\n\n\tprivate onCellDrop(event: CellDragEvent): void {\n\t\tconst draggedCell = this.currentDraggedCell!;\n\n\t\tif (this.isScrolling || this.currentDraggedCell === event.draggedOverCell) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.dragCleanup();\n\n\t\tconst dropDirection = this.getDropInsertDirection(event.dragPosRatio);\n\t\tthis._dropImpl(draggedCell, dropDirection, event.browserEvent, event.draggedOverCell);\n\t}\n\n\tprivate getCellRangeAroundDragTarget(draggedCellIndex: number) {\n\t\tconst selections = this.notebookEditor.getSelections();\n\t\tconst modelRanges = expandCellRangesWithHiddenCells(this.notebookEditor, selections);\n\t\tconst nearestRange = modelRanges.find(range => range.start <= draggedCellIndex && draggedCellIndex < range.end);\n\n\t\tif (nearestRange) {\n\t\t\treturn nearestRange;\n\t\t} else {\n\t\t\treturn { start: draggedCellIndex, end: draggedCellIndex + 1 };\n\t\t}\n\t}\n\n\tprivate _dropImpl(draggedCell: ICellViewModel, dropDirection: 'above' | 'below', ctx: { ctrlKey: boolean; altKey: boolean }, draggedOverCell: ICellViewModel) {\n\t\tconst cellTop = this.list.getCellViewScrollTop(draggedOverCell);\n\t\tconst cellHeight = this.list.elementHeight(draggedOverCell);\n\t\tconst insertionIndicatorAbsolutePos = dropDirection === 'above' ? cellTop : cellTop + cellHeight;\n\t\tconst { bottomToolbarGap } = this.notebookEditor.notebookOptions.computeBottomToolbarDimensions(this.notebookEditor.textModel?.viewType);\n\t\tconst insertionIndicatorTop = insertionIndicatorAbsolutePos - this.list.scrollTop + bottomToolbarGap / 2;\n\t\tconst editorHeight = this.notebookEditor.getDomNode().getBoundingClientRect().height;\n\t\tif (insertionIndicatorTop < 0 || insertionIndicatorTop > editorHeight) {\n\t\t\t// Ignore drop, insertion point is off-screen\n\t\t\treturn;\n\t\t}\n\n\t\tconst isCopy = (ctx.ctrlKey && !platform.isMacintosh) || (ctx.altKey && platform.isMacintosh);\n\n\t\tif (!this.notebookEditor.hasModel()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst textModel = this.notebookEditor.textModel;\n\n\t\tif (isCopy) {\n\t\t\tconst draggedCellIndex = this.notebookEditor.getCellIndex(draggedCell);\n\t\t\tconst range = this.getCellRangeAroundDragTarget(draggedCellIndex);\n\n\t\t\tlet originalToIdx = this.notebookEditor.getCellIndex(draggedOverCell);\n\t\t\tif (dropDirection === 'below') {\n\t\t\t\tconst relativeToIndex = this.notebookEditor.getCellIndex(draggedOverCell);\n\t\t\t\tconst newIdx = this.notebookEditor.getNextVisibleCellIndex(relativeToIndex);\n\t\t\t\toriginalToIdx = newIdx;\n\t\t\t}\n\n\t\t\tlet finalSelection: ICellRange;\n\t\t\tlet finalFocus: ICellRange;\n\n\t\t\tif (originalToIdx <= range.start) {\n\t\t\t\tfinalSelection = { start: originalToIdx, end: originalToIdx + range.end - range.start };\n\t\t\t\tfinalFocus = { start: originalToIdx + draggedCellIndex - range.start, end: originalToIdx + draggedCellIndex - range.start + 1 };\n\t\t\t} else {\n\t\t\t\tconst delta = (originalToIdx - range.start);\n\t\t\t\tfinalSelection = { start: range.start + delta, end: range.end + delta };\n\t\t\t\tfinalFocus = { start: draggedCellIndex + delta, end: draggedCellIndex + delta + 1 };\n\t\t\t}\n\n\t\t\ttextModel.applyEdits([\n\t\t\t\t{\n\t\t\t\t\teditType: CellEditType.Replace,\n\t\t\t\t\tindex: originalToIdx,\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tcells: cellRangesToIndexes([range]).map(index => cloneNotebookCellTextModel(this.notebookEditor.cellAt(index)!.model))\n\t\t\t\t}\n\t\t\t], true, { kind: SelectionStateType.Index, focus: this.notebookEditor.getFocus(), selections: this.notebookEditor.getSelections() }, () => ({ kind: SelectionStateType.Index, focus: finalFocus, selections: [finalSelection] }), undefined, true);\n\t\t\tthis.notebookEditor.revealCellRangeInView(finalSelection);\n\t\t} else {\n\t\t\tperformCellDropEdits(this.notebookEditor, draggedCell, dropDirection, draggedOverCell);\n\t\t}\n\t}\n\n\tprivate onCellDragLeave(event: CellDragEvent): void {\n\t\tif (!event.browserEvent.relatedTarget || !DOM.isAncestor(event.browserEvent.relatedTarget as HTMLElement, this.notebookEditor.getDomNode())) {\n\t\t\tthis.setInsertIndicatorVisibility(false);\n\t\t}\n\t}\n\n\tprivate dragCleanup(): void {\n\t\tif (this.currentDraggedCell) {\n\t\t\tthis.draggedCells.forEach(cell => cell.dragging = false);\n\t\t\tthis.currentDraggedCell = undefined;\n\t\t\tthis.draggedCells = [];\n\t\t}\n\n\t\tthis.setInsertIndicatorVisibility(false);\n\t}\n\n\tregisterDragHandle(templateData: BaseCellRenderTemplate, cellRoot: HTMLElement, dragHandles: HTMLElement[], dragImageProvider: DragImageProvider): void {\n\t\tconst container = templateData.container;\n\t\tfor (const dragHandle of dragHandles) {\n\t\t\tdragHandle.setAttribute('draggable', 'true');\n\t\t}\n\n\t\tconst onDragEnd = () => {\n\t\t\tif (!this.notebookEditor.notebookOptions.getDisplayOptions().dragAndDropEnabled || !!this.notebookEditor.isReadOnly) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Note, templateData may have a different element rendered into it by now\n\t\t\tcontainer.classList.remove(DRAGGING_CLASS);\n\t\t\tthis.dragCleanup();\n\t\t};\n\t\tfor (const dragHandle of dragHandles) {\n\t\t\ttemplateData.templateDisposables.add(DOM.addDisposableListener(dragHandle, DOM.EventType.DRAG_END, onDragEnd));\n\t\t}\n\n\t\tconst onDragStart = (event: DragEvent) => {\n\t\t\tif (!event.dataTransfer) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!this.notebookEditor.notebookOptions.getDisplayOptions().dragAndDropEnabled || !!this.notebookEditor.isReadOnly) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.currentDraggedCell = templateData.currentRenderedCell!;\n\t\t\tthis.draggedCells = this.notebookEditor.getSelections().map(range => this.notebookEditor.getCellsInRange(range)).flat();\n\t\t\tthis.draggedCells.forEach(cell => cell.dragging = true);\n\n\t\t\tconst dragImage = dragImageProvider();\n\t\t\tcellRoot.parentElement!.appendChild(dragImage);\n\t\t\tevent.dataTransfer.setDragImage(dragImage, 0, 0);\n\t\t\tsetTimeout(() => dragImage.remove(), 0); // Comment this out to debug drag image layout\n\t\t};\n\t\tfor (const dragHandle of dragHandles) {\n\t\t\ttemplateData.templateDisposables.add(DOM.addDisposableListener(dragHandle, DOM.EventType.DRAG_START, onDragStart));\n\t\t}\n\t}\n\n\tpublic startExplicitDrag(cell: ICellViewModel, _dragOffsetY: number) {\n\t\tif (!this.notebookEditor.notebookOptions.getDisplayOptions().dragAndDropEnabled || !!this.notebookEditor.isReadOnly) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.currentDraggedCell = cell;\n\t\tthis.setInsertIndicatorVisibility(true);\n\t}\n\n\tpublic explicitDrag(cell: ICellViewModel, dragOffsetY: number) {\n\t\tif (!this.notebookEditor.notebookOptions.getDisplayOptions().dragAndDropEnabled || !!this.notebookEditor.isReadOnly) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst target = this.list.elementAt(dragOffsetY);\n\t\tif (target && target !== cell) {\n\t\t\tconst cellTop = this.list.getCellViewScrollTop(target);\n\t\t\tconst cellHeight = this.list.elementHeight(target);\n\n\t\t\tconst dropDirection = this.getExplicitDragDropDirection(dragOffsetY, cellTop, cellHeight);\n\t\t\tconst insertionIndicatorAbsolutePos = dropDirection === 'above' ? cellTop : cellTop + cellHeight;\n\t\t\tthis.updateInsertIndicator(dropDirection, insertionIndicatorAbsolutePos);\n\t\t}\n\n\t\t// Try scrolling list if needed\n\t\tif (this.currentDraggedCell !== cell) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst notebookViewRect = this.notebookEditor.getDomNode().getBoundingClientRect();\n\t\tconst eventPositionInView = dragOffsetY - this.list.scrollTop;\n\n\t\t// Percentage from the top/bottom of the screen where we start scrolling while dragging\n\t\tconst notebookViewScrollMargins = 0.2;\n\n\t\tconst maxScrollDeltaPerFrame = 20;\n\n\t\tconst eventPositionRatio = eventPositionInView / notebookViewRect.height;\n\t\tif (eventPositionRatio < notebookViewScrollMargins) {\n\t\t\tthis.list.scrollTop -= maxScrollDeltaPerFrame * (1 - eventPositionRatio / notebookViewScrollMargins);\n\t\t} else if (eventPositionRatio > 1 - notebookViewScrollMargins) {\n\t\t\tthis.list.scrollTop += maxScrollDeltaPerFrame * (1 - ((1 - eventPositionRatio) / notebookViewScrollMargins));\n\t\t}\n\t}\n\n\tpublic endExplicitDrag(_cell: ICellViewModel) {\n\t\tthis.setInsertIndicatorVisibility(false);\n\t}\n\n\tpublic explicitDrop(cell: ICellViewModel, ctx: { dragOffsetY: number; ctrlKey: boolean; altKey: boolean }) {\n\t\tthis.currentDraggedCell = undefined;\n\t\tthis.setInsertIndicatorVisibility(false);\n\n\t\tconst target = this.list.elementAt(ctx.dragOffsetY);\n\t\tif (!target || target === cell) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst cellTop = this.list.getCellViewScrollTop(target);\n\t\tconst cellHeight = this.list.elementHeight(target);\n\t\tconst dropDirection = this.getExplicitDragDropDirection(ctx.dragOffsetY, cellTop, cellHeight);\n\t\tthis._dropImpl(cell, dropDirection, ctx, target);\n\t}\n\n\tprivate getExplicitDragDropDirection(clientY: number, cellTop: number, cellHeight: number) {\n\t\tconst dragPosInElement = clientY - cellTop;\n\t\tconst dragPosRatio = dragPosInElement / cellHeight;\n\n\t\treturn this.getDropInsertDirection(dragPosRatio);\n\t}\n\n\toverride dispose() {\n\t\tthis.notebookEditor = null!;\n\t\tsuper.dispose();\n\t}\n}\n\nexport function performCellDropEdits(editor: INotebookEditorDelegate, draggedCell: ICellViewModel, dropDirection: 'above' | 'below', draggedOverCell: ICellViewModel): void {\n\tconst draggedCellIndex = editor.getCellIndex(draggedCell)!;\n\tlet originalToIdx = editor.getCellIndex(draggedOverCell)!;\n\n\tif (typeof draggedCellIndex !== 'number' || typeof originalToIdx !== 'number') {\n\t\treturn;\n\t}\n\n\t// If dropped on a folded markdown range, insert after the folding range\n\tif (dropDirection === 'below') {\n\t\tconst newIdx = editor.getNextVisibleCellIndex(originalToIdx) ?? originalToIdx;\n\t\toriginalToIdx = newIdx;\n\t}\n\n\tlet selections = editor.getSelections();\n\tif (!selections.length) {\n\t\tselections = [editor.getFocus()];\n\t}\n\n\tlet originalFocusIdx = editor.getFocus().start;\n\n\t// If the dragged cell is not focused/selected, ignore the current focus/selection and use the dragged idx\n\tif (!selections.some(s => s.start <= draggedCellIndex && s.end > draggedCellIndex)) {\n\t\tselections = [{ start: draggedCellIndex, end: draggedCellIndex + 1 }];\n\t\toriginalFocusIdx = draggedCellIndex;\n\t}\n\n\tconst droppedInSelection = selections.find(range => range.start <= originalToIdx && range.end > originalToIdx);\n\tif (droppedInSelection) {\n\t\toriginalToIdx = droppedInSelection.start;\n\t}\n\n\n\tlet numCells = 0;\n\tlet focusNewIdx = originalToIdx;\n\tlet newInsertionIdx = originalToIdx;\n\n\t// Compute a set of edits which will be applied in reverse order by the notebook text model.\n\t// `index`: the starting index of the range, after previous edits have been applied\n\t// `newIdx`: the destination index, after this edit's range has been removed\n\tselections.sort((a, b) => b.start - a.start);\n\tconst edits = selections.map(range => {\n\t\tconst length = range.end - range.start;\n\n\t\t// If this range is before the insertion point, subtract the cells in this range from the \"to\" index\n\t\tlet toIndexDelta = 0;\n\t\tif (range.end <= newInsertionIdx) {\n\t\t\ttoIndexDelta = -length;\n\t\t}\n\n\t\tconst newIdx = newInsertionIdx + toIndexDelta;\n\n\t\t// If this range contains the focused cell, set the new focus index to the new index of the cell\n\t\tif (originalFocusIdx >= range.start && originalFocusIdx <= range.end) {\n\t\t\tconst offset = originalFocusIdx - range.start;\n\t\t\tfocusNewIdx = newIdx + offset;\n\t\t}\n\n\t\t// If below the insertion point, the original index will have been shifted down\n\t\tconst fromIndexDelta = range.start >= originalToIdx ? numCells : 0;\n\n\t\tconst edit: ICellMoveEdit = {\n\t\t\teditType: CellEditType.Move,\n\t\t\tindex: range.start + fromIndexDelta,\n\t\t\tlength,\n\t\t\tnewIdx\n\t\t};\n\t\tnumCells += length;\n\n\t\t// If a range was moved down, the insertion index needs to be adjusted\n\t\tif (range.end < newInsertionIdx) {\n\t\t\tnewInsertionIdx -= length;\n\t\t}\n\n\t\treturn edit;\n\t});\n\n\tconst lastEdit = edits[edits.length - 1];\n\tconst finalSelection = { start: lastEdit.newIdx, end: lastEdit.newIdx + numCells };\n\tconst finalFocus = { start: focusNewIdx, end: focusNewIdx + 1 };\n\n\teditor.textModel!.applyEdits(\n\t\tedits,\n\t\ttrue,\n\t\t{ kind: SelectionStateType.Index, focus: editor.getFocus(), selections: editor.getSelections() },\n\t\t() => ({ kind: SelectionStateType.Index, focus: finalFocus, selections: [finalSelection] }),\n\t\tundefined, true);\n\teditor.revealCellRangeInView(finalSelection);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from '../../../../../../base/browser/dom.js';\nimport { Delayer } from '../../../../../../base/common/async.js';\nimport { Disposable, MutableDisposable } from '../../../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../../../base/common/platform.js';\nimport { expandCellRangesWithHiddenCells, ICellViewModel, INotebookEditorDelegate } from '../../notebookBrowser.js';\nimport { CellViewModelStateChangeEvent } from '../../notebookViewEvents.js';\nimport { CellContentPart } from '../cellPart.js';\nimport { BaseCellRenderTemplate, INotebookCellList } from '../notebookRenderingCommon.js';\nimport { cloneNotebookCellTextModel } from '../../../common/model/notebookCellTextModel.js';\nimport { CellEditType, ICellMoveEdit, SelectionStateType } from '../../../common/notebookCommon.js';\nimport { cellRangesToIndexes, ICellRange } from '../../../common/notebookRange.js';\n\nconst $ = DOM.$;\n\nconst DRAGGING_CLASS = 'cell-dragging';\nconst GLOBAL_DRAG_CLASS = 'global-drag-active';\n\ntype DragImageProvider = () => HTMLElement;\n\ninterface CellDragEvent {\n\tbrowserEvent: DragEvent;\n\tdraggedOverCell: ICellViewModel;\n\tcellTop: number;\n\tcellHeight: number;\n\tdragPosRatio: number;\n}\n\nexport class CellDragAndDropPart extends CellContentPart {\n\tconstructor(\n\t\tprivate readonly container: HTMLElement\n\t) {\n\t\tsuper();\n\t}\n\n\toverride didRenderCell(element: ICellViewModel): void {\n\t\tthis.update(element);\n\t}\n\n\toverride updateState(element: ICellViewModel, e: CellViewModelStateChangeEvent): void {\n\t\tif (e.dragStateChanged) {\n\t\t\tthis.update(element);\n\t\t}\n\t}\n\n\tprivate update(element: ICellViewModel) {\n\t\tthis.container.classList.toggle(DRAGGING_CLASS, element.dragging);\n\t}\n}\n\nexport class CellDragAndDropController extends Disposable {\n\t// TODO@roblourens - should probably use dataTransfer here, but any dataTransfer set makes the editor think I am dropping a file, need\n\t// to figure out how to prevent that\n\tprivate currentDraggedCell: ICellViewModel | undefined;\n\tprivate draggedCells: ICellViewModel[] = [];\n\n\tprivate listInsertionIndicator: HTMLElement;\n\n\tprivate list!: INotebookCellList;\n\n\tprivate isScrolling = false;\n\tprivate readonly scrollingDelayer: Delayer<void>;\n\n\tprivate readonly listOnWillScrollListener = this._register(new MutableDisposable());\n\n\tconstructor(\n\t\tprivate notebookEditor: INotebookEditorDelegate,\n\t\tprivate readonly notebookListContainer: HTMLElement\n\t) {\n\t\tsuper();\n\n\t\tthis.listInsertionIndicator = DOM.append(notebookListContainer, $('.cell-list-insertion-indicator'));\n\n\t\tthis._register(DOM.addDisposableListener(notebookListContainer.ownerDocument.body, DOM.EventType.DRAG_START, this.onGlobalDragStart.bind(this), true));\n\t\tthis._register(DOM.addDisposableListener(notebookListContainer.ownerDocument.body, DOM.EventType.DRAG_END, this.onGlobalDragEnd.bind(this), true));\n\n\t\tconst addCellDragListener = (eventType: string, handler: (e: CellDragEvent) => void, useCapture = false) => {\n\t\t\tthis._register(DOM.addDisposableListener(\n\t\t\t\tnotebookEditor.getDomNode(),\n\t\t\t\teventType,\n\t\t\t\te => {\n\t\t\t\t\tconst cellDragEvent = this.toCellDragEvent(e);\n\t\t\t\t\tif (cellDragEvent) {\n\t\t\t\t\t\thandler(cellDragEvent);\n\t\t\t\t\t}\n\t\t\t\t}, useCapture));\n\t\t};\n\n\t\taddCellDragListener(DOM.EventType.DRAG_OVER, event => {\n\t\t\tif (!this.currentDraggedCell) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tevent.browserEvent.preventDefault();\n\t\t\tthis.onCellDragover(event);\n\t\t}, true);\n\t\taddCellDragListener(DOM.EventType.DROP, event => {\n\t\t\tif (!this.currentDraggedCell) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tevent.browserEvent.preventDefault();\n\t\t\tthis.onCellDrop(event);\n\t\t});\n\t\taddCellDragListener(DOM.EventType.DRAG_LEAVE, event => {\n\t\t\tevent.browserEvent.preventDefault();\n\t\t\tthis.onCellDragLeave(event);\n\t\t});\n\n\t\tthis.scrollingDelayer = this._register(new Delayer(200));\n\t}\n\n\tsetList(value: INotebookCellList) {\n\t\tthis.list = value;\n\n\t\tthis.listOnWillScrollListener.value = this.list.onWillScroll(e => {\n\t\t\tif (!e.scrollTopChanged) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.setInsertIndicatorVisibility(false);\n\t\t\tthis.isScrolling = true;\n\t\t\tthis.scrollingDelayer.trigger(() => {\n\t\t\t\tthis.isScrolling = false;\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate setInsertIndicatorVisibility(visible: boolean) {\n\t\tthis.listInsertionIndicator.style.opacity = visible ? '1' : '0';\n\t}\n\n\tprivate toCellDragEvent(event: DragEvent): CellDragEvent | undefined {\n\t\tconst targetTop = this.notebookListContainer.getBoundingClientRect().top;\n\t\tconst dragOffset = this.list.scrollTop + event.clientY - targetTop;\n\t\tconst draggedOverCell = this.list.elementAt(dragOffset);\n\t\tif (!draggedOverCell) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst cellTop = this.list.getCellViewScrollTop(draggedOverCell);\n\t\tconst cellHeight = this.list.elementHeight(draggedOverCell);\n\n\t\tconst dragPosInElement = dragOffset - cellTop;\n\t\tconst dragPosRatio = dragPosInElement / cellHeight;\n\n\t\treturn {\n\t\t\tbrowserEvent: event,\n\t\t\tdraggedOverCell,\n\t\t\tcellTop,\n\t\t\tcellHeight,\n\t\t\tdragPosRatio\n\t\t};\n\t}\n\n\tclearGlobalDragState() {\n\t\tthis.notebookEditor.getDomNode().classList.remove(GLOBAL_DRAG_CLASS);\n\t}\n\n\tprivate onGlobalDragStart() {\n\t\tthis.notebookEditor.getDomNode().classList.add(GLOBAL_DRAG_CLASS);\n\t}\n\n\tprivate onGlobalDragEnd() {\n\t\tthis.notebookEditor.getDomNode().classList.remove(GLOBAL_DRAG_CLASS);\n\t}\n\n\tprivate onCellDragover(event: CellDragEvent): void {\n\t\tif (!event.browserEvent.dataTransfer) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.currentDraggedCell) {\n\t\t\tevent.browserEvent.dataTransfer.dropEffect = 'none';\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.isScrolling || this.currentDraggedCell === event.draggedOverCell) {\n\t\t\tthis.setInsertIndicatorVisibility(false);\n\t\t\treturn;\n\t\t}\n\n\t\tconst dropDirection = this.getDropInsertDirection(event.dragPosRatio);\n\t\tconst insertionIndicatorAbsolutePos = dropDirection === 'above' ? event.cellTop : event.cellTop + event.cellHeight;\n\t\tthis.updateInsertIndicator(dropDirection, insertionIndicatorAbsolutePos);\n\t}\n\n\tprivate updateInsertIndicator(dropDirection: string, insertionIndicatorAbsolutePos: number) {\n\t\tconst { bottomToolbarGap } = this.notebookEditor.notebookOptions.computeBottomToolbarDimensions(this.notebookEditor.textModel?.viewType);\n\t\tconst insertionIndicatorTop = insertionIndicatorAbsolutePos - this.list.scrollTop + bottomToolbarGap / 2;\n\t\tif (insertionIndicatorTop >= 0) {\n\t\t\tthis.listInsertionIndicator.style.top = `${insertionIndicatorTop}px`;\n\t\t\tthis.setInsertIndicatorVisibility(true);\n\t\t} else {\n\t\t\tthis.setInsertIndicatorVisibility(false);\n\t\t}\n\t}\n\n\tprivate getDropInsertDirection(dragPosRatio: number): 'above' | 'below' {\n\t\treturn dragPosRatio < 0.5 ? 'above' : 'below';\n\t}\n\n\tprivate onCellDrop(event: CellDragEvent): void {\n\t\tconst draggedCell = this.currentDraggedCell!;\n\n\t\tif (this.isScrolling || this.currentDraggedCell === event.draggedOverCell) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.dragCleanup();\n\n\t\tconst dropDirection = this.getDropInsertDirection(event.dragPosRatio);\n\t\tthis._dropImpl(draggedCell, dropDirection, event.browserEvent, event.draggedOverCell);\n\t}\n\n\tprivate getCellRangeAroundDragTarget(draggedCellIndex: number) {\n\t\tconst selections = this.notebookEditor.getSelections();\n\t\tconst modelRanges = expandCellRangesWithHiddenCells(this.notebookEditor, selections);\n\t\tconst nearestRange = modelRanges.find(range => range.start <= draggedCellIndex && draggedCellIndex < range.end);\n\n\t\tif (nearestRange) {\n\t\t\treturn nearestRange;\n\t\t} else {\n\t\t\treturn { start: draggedCellIndex, end: draggedCellIndex + 1 };\n\t\t}\n\t}\n\n\tprivate _dropImpl(draggedCell: ICellViewModel, dropDirection: 'above' | 'below', ctx: { ctrlKey: boolean; altKey: boolean }, draggedOverCell: ICellViewModel) {\n\t\tconst cellTop = this.list.getCellViewScrollTop(draggedOverCell);\n\t\tconst cellHeight = this.list.elementHeight(draggedOverCell);\n\t\tconst insertionIndicatorAbsolutePos = dropDirection === 'above' ? cellTop : cellTop + cellHeight;\n\t\tconst { bottomToolbarGap } = this.notebookEditor.notebookOptions.computeBottomToolbarDimensions(this.notebookEditor.textModel?.viewType);\n\t\tconst insertionIndicatorTop = insertionIndicatorAbsolutePos - this.list.scrollTop + bottomToolbarGap / 2;\n\t\tconst editorHeight = this.notebookEditor.getDomNode().getBoundingClientRect().height;\n\t\tif (insertionIndicatorTop < 0 || insertionIndicatorTop > editorHeight) {\n\t\t\t// Ignore drop, insertion point is off-screen\n\t\t\treturn;\n\t\t}\n\n\t\tconst isCopy = (ctx.ctrlKey && !platform.isMacintosh) || (ctx.altKey && platform.isMacintosh);\n\n\t\tif (!this.notebookEditor.hasModel()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst textModel = this.notebookEditor.textModel;\n\n\t\tif (isCopy) {\n\t\t\tconst draggedCellIndex = this.notebookEditor.getCellIndex(draggedCell);\n\t\t\tconst range = this.getCellRangeAroundDragTarget(draggedCellIndex);\n\n\t\t\tlet originalToIdx = this.notebookEditor.getCellIndex(draggedOverCell);\n\t\t\tif (dropDirection === 'below') {\n\t\t\t\tconst relativeToIndex = this.notebookEditor.getCellIndex(draggedOverCell);\n\t\t\t\tconst newIdx = this.notebookEditor.getNextVisibleCellIndex(relativeToIndex);\n\t\t\t\toriginalToIdx = newIdx;\n\t\t\t}\n\n\t\t\tlet finalSelection: ICellRange;\n\t\t\tlet finalFocus: ICellRange;\n\n\t\t\tif (originalToIdx <= range.start) {\n\t\t\t\tfinalSelection = { start: originalToIdx, end: originalToIdx + range.end - range.start };\n\t\t\t\tfinalFocus = { start: originalToIdx + draggedCellIndex - range.start, end: originalToIdx + draggedCellIndex - range.start + 1 };\n\t\t\t} else {\n\t\t\t\tconst delta = (originalToIdx - range.start);\n\t\t\t\tfinalSelection = { start: range.start + delta, end: range.end + delta };\n\t\t\t\tfinalFocus = { start: draggedCellIndex + delta, end: draggedCellIndex + delta + 1 };\n\t\t\t}\n\n\t\t\ttextModel.applyEdits([\n\t\t\t\t{\n\t\t\t\t\teditType: CellEditType.Replace,\n\t\t\t\t\tindex: originalToIdx,\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tcells: cellRangesToIndexes([range]).map(index => cloneNotebookCellTextModel(this.notebookEditor.cellAt(index)!.model))\n\t\t\t\t}\n\t\t\t], true, { kind: SelectionStateType.Index, focus: this.notebookEditor.getFocus(), selections: this.notebookEditor.getSelections() }, () => ({ kind: SelectionStateType.Index, focus: finalFocus, selections: [finalSelection] }), undefined, true);\n\t\t\tthis.notebookEditor.revealCellRangeInView(finalSelection);\n\t\t} else {\n\t\t\tperformCellDropEdits(this.notebookEditor, draggedCell, dropDirection, draggedOverCell);\n\t\t}\n\t}\n\n\tprivate onCellDragLeave(event: CellDragEvent): void {\n\t\tif (!event.browserEvent.relatedTarget || !DOM.isAncestor(event.browserEvent.relatedTarget as HTMLElement, this.notebookEditor.getDomNode())) {\n\t\t\tthis.setInsertIndicatorVisibility(false);\n\t\t}\n\t}\n\n\tprivate dragCleanup(): void {\n\t\tif (this.currentDraggedCell) {\n\t\t\tthis.draggedCells.forEach(cell => cell.dragging = false);\n\t\t\tthis.currentDraggedCell = undefined;\n\t\t\tthis.draggedCells = [];\n\t\t}\n\n\t\tthis.setInsertIndicatorVisibility(false);\n\t}\n\n\tregisterDragHandle(templateData: BaseCellRenderTemplate, cellRoot: HTMLElement, dragHandles: HTMLElement[], dragImageProvider: DragImageProvider): void {\n\t\tconst container = templateData.container;\n\t\tfor (const dragHandle of dragHandles) {\n\t\t\tdragHandle.setAttribute('draggable', 'true');\n\t\t}\n\n\t\tconst onDragEnd = () => {\n\t\t\tif (!this.notebookEditor.notebookOptions.getDisplayOptions().dragAndDropEnabled || !!this.notebookEditor.isReadOnly) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Note, templateData may have a different element rendered into it by now\n\t\t\tcontainer.classList.remove(DRAGGING_CLASS);\n\t\t\tthis.dragCleanup();\n\t\t};\n\t\tfor (const dragHandle of dragHandles) {\n\t\t\ttemplateData.templateDisposables.add(DOM.addDisposableListener(dragHandle, DOM.EventType.DRAG_END, onDragEnd));\n\t\t}\n\n\t\tconst onDragStart = (event: DragEvent) => {\n\t\t\tif (!event.dataTransfer) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!this.notebookEditor.notebookOptions.getDisplayOptions().dragAndDropEnabled || !!this.notebookEditor.isReadOnly) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.currentDraggedCell = templateData.currentRenderedCell!;\n\t\t\tthis.draggedCells = this.notebookEditor.getSelections().map(range => this.notebookEditor.getCellsInRange(range)).flat();\n\t\t\tthis.draggedCells.forEach(cell => cell.dragging = true);\n\n\t\t\tconst dragImage = dragImageProvider();\n\t\t\tcellRoot.parentElement!.appendChild(dragImage);\n\t\t\tevent.dataTransfer.setDragImage(dragImage, 0, 0);\n\t\t\tsetTimeout(() => dragImage.remove(), 0); // Comment this out to debug drag image layout\n\t\t};\n\t\tfor (const dragHandle of dragHandles) {\n\t\t\ttemplateData.templateDisposables.add(DOM.addDisposableListener(dragHandle, DOM.EventType.DRAG_START, onDragStart));\n\t\t}\n\t}\n\n\tpublic startExplicitDrag(cell: ICellViewModel, _dragOffsetY: number) {\n\t\tif (!this.notebookEditor.notebookOptions.getDisplayOptions().dragAndDropEnabled || !!this.notebookEditor.isReadOnly) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.currentDraggedCell = cell;\n\t\tthis.setInsertIndicatorVisibility(true);\n\t}\n\n\tpublic explicitDrag(cell: ICellViewModel, dragOffsetY: number) {\n\t\tif (!this.notebookEditor.notebookOptions.getDisplayOptions().dragAndDropEnabled || !!this.notebookEditor.isReadOnly) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst target = this.list.elementAt(dragOffsetY);\n\t\tif (target && target !== cell) {\n\t\t\tconst cellTop = this.list.getCellViewScrollTop(target);\n\t\t\tconst cellHeight = this.list.elementHeight(target);\n\n\t\t\tconst dropDirection = this.getExplicitDragDropDirection(dragOffsetY, cellTop, cellHeight);\n\t\t\tconst insertionIndicatorAbsolutePos = dropDirection === 'above' ? cellTop : cellTop + cellHeight;\n\t\t\tthis.updateInsertIndicator(dropDirection, insertionIndicatorAbsolutePos);\n\t\t}\n\n\t\t// Try scrolling list if needed\n\t\tif (this.currentDraggedCell !== cell) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst notebookViewRect = this.notebookEditor.getDomNode().getBoundingClientRect();\n\t\tconst eventPositionInView = dragOffsetY - this.list.scrollTop;\n\n\t\t// Percentage from the top/bottom of the screen where we start scrolling while dragging\n\t\tconst notebookViewScrollMargins = 0.2;\n\n\t\tconst maxScrollDeltaPerFrame = 20;\n\n\t\tconst eventPositionRatio = eventPositionInView / notebookViewRect.height;\n\t\tif (eventPositionRatio < notebookViewScrollMargins) {\n\t\t\tthis.list.scrollTop -= maxScrollDeltaPerFrame * (1 - eventPositionRatio / notebookViewScrollMargins);\n\t\t} else if (eventPositionRatio > 1 - notebookViewScrollMargins) {\n\t\t\tthis.list.scrollTop += maxScrollDeltaPerFrame * (1 - ((1 - eventPositionRatio) / notebookViewScrollMargins));\n\t\t}\n\t}\n\n\tpublic endExplicitDrag(_cell: ICellViewModel) {\n\t\tthis.setInsertIndicatorVisibility(false);\n\t}\n\n\tpublic explicitDrop(cell: ICellViewModel, ctx: { dragOffsetY: number; ctrlKey: boolean; altKey: boolean }) {\n\t\tthis.currentDraggedCell = undefined;\n\t\tthis.setInsertIndicatorVisibility(false);\n\n\t\tconst target = this.list.elementAt(ctx.dragOffsetY);\n\t\tif (!target || target === cell) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst cellTop = this.list.getCellViewScrollTop(target);\n\t\tconst cellHeight = this.list.elementHeight(target);\n\t\tconst dropDirection = this.getExplicitDragDropDirection(ctx.dragOffsetY, cellTop, cellHeight);\n\t\tthis._dropImpl(cell, dropDirection, ctx, target);\n\t}\n\n\tprivate getExplicitDragDropDirection(clientY: number, cellTop: number, cellHeight: number) {\n\t\tconst dragPosInElement = clientY - cellTop;\n\t\tconst dragPosRatio = dragPosInElement / cellHeight;\n\n\t\treturn this.getDropInsertDirection(dragPosRatio);\n\t}\n\n\toverride dispose() {\n\t\tthis.notebookEditor = null!;\n\t\tsuper.dispose();\n\t}\n}\n\nexport function performCellDropEdits(editor: INotebookEditorDelegate, draggedCell: ICellViewModel, dropDirection: 'above' | 'below', draggedOverCell: ICellViewModel): void {\n\tconst draggedCellIndex = editor.getCellIndex(draggedCell)!;\n\tlet originalToIdx = editor.getCellIndex(draggedOverCell)!;\n\n\tif (typeof draggedCellIndex !== 'number' || typeof originalToIdx !== 'number') {\n\t\treturn;\n\t}\n\n\t// If dropped on a folded markdown range, insert after the folding range\n\tif (dropDirection === 'below') {\n\t\tconst newIdx = editor.getNextVisibleCellIndex(originalToIdx) ?? originalToIdx;\n\t\toriginalToIdx = newIdx;\n\t}\n\n\tlet selections = editor.getSelections();\n\tif (!selections.length) {\n\t\tselections = [editor.getFocus()];\n\t}\n\n\tlet originalFocusIdx = editor.getFocus().start;\n\n\t// If the dragged cell is not focused/selected, ignore the current focus/selection and use the dragged idx\n\tif (!selections.some(s => s.start <= draggedCellIndex && s.end > draggedCellIndex)) {\n\t\tselections = [{ start: draggedCellIndex, end: draggedCellIndex + 1 }];\n\t\toriginalFocusIdx = draggedCellIndex;\n\t}\n\n\tconst droppedInSelection = selections.find(range => range.start <= originalToIdx && range.end > originalToIdx);\n\tif (droppedInSelection) {\n\t\toriginalToIdx = droppedInSelection.start;\n\t}\n\n\n\tlet numCells = 0;\n\tlet focusNewIdx = originalToIdx;\n\tlet newInsertionIdx = originalToIdx;\n\n\t// Compute a set of edits which will be applied in reverse order by the notebook text model.\n\t// `index`: the starting index of the range, after previous edits have been applied\n\t// `newIdx`: the destination index, after this edit's range has been removed\n\tselections.sort((a, b) => b.start - a.start);\n\tconst edits = selections.map(range => {\n\t\tconst length = range.end - range.start;\n\n\t\t// If this range is before the insertion point, subtract the cells in this range from the \"to\" index\n\t\tlet toIndexDelta = 0;\n\t\tif (range.end <= newInsertionIdx) {\n\t\t\ttoIndexDelta = -length;\n\t\t}\n\n\t\tconst newIdx = newInsertionIdx + toIndexDelta;\n\n\t\t// If this range contains the focused cell, set the new focus index to the new index of the cell\n\t\tif (originalFocusIdx >= range.start && originalFocusIdx <= range.end) {\n\t\t\tconst offset = originalFocusIdx - range.start;\n\t\t\tfocusNewIdx = newIdx + offset;\n\t\t}\n\n\t\t// If below the insertion point, the original index will have been shifted down\n\t\tconst fromIndexDelta = range.start >= originalToIdx ? numCells : 0;\n\n\t\tconst edit: ICellMoveEdit = {\n\t\t\teditType: CellEditType.Move,\n\t\t\tindex: range.start + fromIndexDelta,\n\t\t\tlength,\n\t\t\tnewIdx\n\t\t};\n\t\tnumCells += length;\n\n\t\t// If a range was moved down, the insertion index needs to be adjusted\n\t\tif (range.end < newInsertionIdx) {\n\t\t\tnewInsertionIdx -= length;\n\t\t}\n\n\t\treturn edit;\n\t});\n\n\tconst lastEdit = edits[edits.length - 1];\n\tconst finalSelection = { start: lastEdit.newIdx, end: lastEdit.newIdx + numCells };\n\tconst finalFocus = { start: focusNewIdx, end: focusNewIdx + 1 };\n\n\teditor.textModel!.applyEdits(\n\t\tedits,\n\t\ttrue,\n\t\t{ kind: SelectionStateType.Index, focus: editor.getFocus(), selections: editor.getSelections() },\n\t\t() => ({ kind: SelectionStateType.Index, focus: finalFocus, selections: [finalSelection] }),\n\t\tundefined, true);\n\teditor.revealCellRangeInView(finalSelection);\n}\n"]}