{"version":3,"sources":["vs/workbench/contrib/notebook/browser/viewModel/notebookOutlineEntryFactory.ts"],"names":[],"mappings":"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","file":"notebookOutlineEntryFactory.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { renderAsPlaintext } from '../../../../../base/browser/markdownRenderer.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { IOutlineModelService, OutlineModelService } from '../../../../../editor/contrib/documentSymbols/browser/outlineModel.js';\nimport { localize } from '../../../../../nls.js';\nimport { ICellViewModel } from '../notebookBrowser.js';\nimport { getMarkdownHeadersInCell } from './foldingModel.js';\nimport { OutlineEntry } from './OutlineEntry.js';\nimport { CellKind } from '../../common/notebookCommon.js';\nimport { INotebookExecutionStateService } from '../../common/notebookExecutionStateService.js';\nimport { IRange } from '../../../../../editor/common/core/range.js';\nimport { SymbolKind } from '../../../../../editor/common/languages.js';\nimport { createDecorator } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { ITextModelService } from '../../../../../editor/common/services/resolverService.js';\n\nexport const enum NotebookOutlineConstants {\n\tNonHeaderOutlineLevel = 7,\n}\n\ntype entryDesc = {\n\tname: string;\n\trange: IRange;\n\tlevel: number;\n\tkind: SymbolKind;\n};\n\nfunction getMarkdownHeadersInCellFallbackToHtmlTags(fullContent: string) {\n\tconst headers = Array.from(getMarkdownHeadersInCell(fullContent));\n\tif (headers.length) {\n\t\treturn headers;\n\t}\n\t// no markdown syntax headers, try to find html tags\n\tconst match = fullContent.match(/<h([1-6]).*>(.*)<\\/h\\1>/i);\n\tif (match) {\n\t\tconst level = parseInt(match[1]);\n\t\tconst text = match[2].trim();\n\t\theaders.push({ depth: level, text });\n\t}\n\treturn headers;\n}\n\nexport const INotebookOutlineEntryFactory = createDecorator<INotebookOutlineEntryFactory>('INotebookOutlineEntryFactory');\n\nexport interface INotebookOutlineEntryFactory {\n\treadonly _serviceBrand: undefined;\n\n\tgetOutlineEntries(cell: ICellViewModel, index: number): OutlineEntry[];\n\tcacheSymbols(cell: ICellViewModel, cancelToken: CancellationToken): Promise<void>;\n}\n\nexport class NotebookOutlineEntryFactory implements INotebookOutlineEntryFactory {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate cellOutlineEntryCache: Record<string, entryDesc[]> = {};\n\tprivate readonly cachedMarkdownOutlineEntries = new WeakMap<ICellViewModel, { alternativeId: number; headers: { depth: number; text: string }[] }>();\n\tconstructor(\n\t\t@INotebookExecutionStateService private readonly executionStateService: INotebookExecutionStateService,\n\t\t@IOutlineModelService private readonly outlineModelService: IOutlineModelService,\n\t\t@ITextModelService private readonly textModelService: ITextModelService\n\t) { }\n\n\tpublic getOutlineEntries(cell: ICellViewModel, index: number): OutlineEntry[] {\n\t\tconst entries: OutlineEntry[] = [];\n\n\t\tconst isMarkdown = cell.cellKind === CellKind.Markup;\n\n\t\t// cap the amount of characters that we look at and use the following logic\n\t\t// - for MD prefer headings (each header is an entry)\n\t\t// - otherwise use the first none-empty line of the cell (MD or code)\n\t\tlet content = getCellFirstNonEmptyLine(cell);\n\t\tlet hasHeader = false;\n\n\t\tif (isMarkdown) {\n\t\t\tconst fullContent = cell.getText().substring(0, 10000);\n\t\t\tconst cache = this.cachedMarkdownOutlineEntries.get(cell);\n\t\t\tconst headers = cache?.alternativeId === cell.getAlternativeId() ? cache.headers : Array.from(getMarkdownHeadersInCellFallbackToHtmlTags(fullContent));\n\t\t\tthis.cachedMarkdownOutlineEntries.set(cell, { alternativeId: cell.getAlternativeId(), headers });\n\n\t\t\tfor (const { depth, text } of headers) {\n\t\t\t\thasHeader = true;\n\t\t\t\tentries.push(new OutlineEntry(index++, depth, cell, text, false, false));\n\t\t\t}\n\n\t\t\tif (!hasHeader) {\n\t\t\t\tcontent = renderAsPlaintext({ value: content });\n\t\t\t}\n\t\t}\n\n\t\tif (!hasHeader) {\n\t\t\tconst exeState = !isMarkdown && this.executionStateService.getCellExecution(cell.uri);\n\t\t\tlet preview = content.trim();\n\n\t\t\tif (!isMarkdown) {\n\t\t\t\tconst cached = this.cellOutlineEntryCache[cell.id];\n\n\t\t\t\t// Gathering symbols from the model is an async operation, but this provider is syncronous.\n\t\t\t\t// So symbols need to be precached before this function is called to get the full list.\n\t\t\t\tif (cached) {\n\t\t\t\t\t// push code cell entry that is a parent of cached symbols, always necessary. filtering for quickpick done in that provider.\n\t\t\t\t\tentries.push(new OutlineEntry(index++, NotebookOutlineConstants.NonHeaderOutlineLevel, cell, preview, !!exeState, exeState ? exeState.isPaused : false));\n\t\t\t\t\tcached.forEach((entry) => {\n\t\t\t\t\t\tentries.push(new OutlineEntry(index++, entry.level, cell, entry.name, false, false, entry.range, entry.kind));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (entries.length === 0) { // if there are no cached entries, use the first line of the cell as a code cell\n\t\t\t\tif (preview.length === 0) {\n\t\t\t\t\t// empty or just whitespace\n\t\t\t\t\tpreview = localize('empty', \"empty cell\");\n\t\t\t\t}\n\t\t\t\tentries.push(new OutlineEntry(index++, NotebookOutlineConstants.NonHeaderOutlineLevel, cell, preview, !!exeState, exeState ? exeState.isPaused : false));\n\t\t\t}\n\t\t}\n\n\t\treturn entries;\n\t}\n\n\tpublic async cacheSymbols(cell: ICellViewModel, cancelToken: CancellationToken) {\n\t\tif (cell.cellKind === CellKind.Markup) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ref = await this.textModelService.createModelReference(cell.uri);\n\t\ttry {\n\t\t\tconst textModel = ref.object.textEditorModel;\n\t\t\tconst outlineModel = await this.outlineModelService.getOrCreate(textModel, cancelToken);\n\t\t\tconst entries = createOutlineEntries(outlineModel.getTopLevelSymbols(), 8);\n\t\t\tthis.cellOutlineEntryCache[cell.id] = entries;\n\t\t} finally {\n\t\t\tref.dispose();\n\t\t}\n\t}\n}\n\ntype outlineModel = Awaited<ReturnType<OutlineModelService['getOrCreate']>>;\ntype documentSymbol = ReturnType<outlineModel['getTopLevelSymbols']>[number];\n\nfunction createOutlineEntries(symbols: documentSymbol[], level: number): entryDesc[] {\n\tconst entries: entryDesc[] = [];\n\tsymbols.forEach(symbol => {\n\t\tentries.push({ name: symbol.name, range: symbol.range, level, kind: symbol.kind });\n\t\tif (symbol.children) {\n\t\t\tentries.push(...createOutlineEntries(symbol.children, level + 1));\n\t\t}\n\t});\n\treturn entries;\n}\n\nfunction getCellFirstNonEmptyLine(cell: ICellViewModel) {\n\tconst textBuffer = cell.textBuffer;\n\tfor (let i = 0; i < textBuffer.getLineCount(); i++) {\n\t\tconst firstNonWhitespace = textBuffer.getLineFirstNonWhitespaceColumn(i + 1);\n\t\tconst lineLength = textBuffer.getLineLength(i + 1);\n\t\tif (firstNonWhitespace < lineLength) {\n\t\t\treturn textBuffer.getLineContent(i + 1);\n\t\t}\n\t}\n\n\treturn cell.getText().substring(0, 100);\n}\n"]}