{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/notebook/browser/view/cellPart.ts","vs/workbench/contrib/notebook/browser/view/cellPart.ts"],"names":[],"mappings":"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","file":"cellPart.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from '../../../../../base/browser/dom.js';\nimport { onUnexpectedError } from '../../../../../base/common/errors.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../../base/common/lifecycle.js';\nimport { ICellViewModel } from '../notebookBrowser.js';\nimport { CellViewModelStateChangeEvent } from '../notebookViewEvents.js';\nimport { ICellExecutionStateChangedEvent } from '../../common/notebookExecutionStateService.js';\n\n/**\n * A content part is a non-floating element that is rendered inside a cell.\n * The rendering of the content part is synchronous to avoid flickering.\n */\nexport abstract class CellContentPart extends Disposable {\n\tprotected currentCell: ICellViewModel | undefined;\n\tprotected readonly cellDisposables = this._register(new DisposableStore());\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Prepare model for cell part rendering\n\t * No DOM operations recommended within this operation\n\t */\n\tprepareRenderCell(element: ICellViewModel): void { }\n\n\t/**\n\t * Update the DOM for the cell `element`\n\t */\n\trenderCell(element: ICellViewModel): void {\n\t\tthis.currentCell = element;\n\t\tsafeInvokeNoArg(() => this.didRenderCell(element));\n\t}\n\n\tdidRenderCell(element: ICellViewModel): void { }\n\n\t/**\n\t * Dispose any disposables generated from `didRenderCell`\n\t */\n\tunrenderCell(element: ICellViewModel): void {\n\t\tthis.currentCell = undefined;\n\t\tthis.cellDisposables.clear();\n\t}\n\n\t/**\n\t * Perform DOM read operations to prepare for the list/cell layout update.\n\t */\n\tprepareLayout(): void { }\n\n\t/**\n\t * Update internal DOM (top positions) per cell layout info change\n\t * Note that a cell part doesn't need to call `DOM.scheduleNextFrame`,\n\t * the list view will ensure that layout call is invoked in the right frame\n\t */\n\tupdateInternalLayoutNow(element: ICellViewModel): void { }\n\n\t/**\n\t * Update per cell state change\n\t */\n\tupdateState(element: ICellViewModel, e: CellViewModelStateChangeEvent): void { }\n\n\t/**\n\t * Update per execution state change.\n\t */\n\tupdateForExecutionState(element: ICellViewModel, e: ICellExecutionStateChangedEvent): void { }\n}\n\n/**\n * An overlay part renders on top of other components.\n * The rendering of the overlay part might be postponed to the next animation frame to avoid forced reflow.\n */\nexport abstract class CellOverlayPart extends Disposable {\n\tprotected currentCell: ICellViewModel | undefined;\n\tprotected readonly cellDisposables = this._register(new DisposableStore());\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Prepare model for cell part rendering\n\t * No DOM operations recommended within this operation\n\t */\n\tprepareRenderCell(element: ICellViewModel): void { }\n\n\t/**\n\t * Update the DOM for the cell `element`\n\t */\n\trenderCell(element: ICellViewModel): void {\n\t\tthis.currentCell = element;\n\t\tthis.didRenderCell(element);\n\t}\n\n\tdidRenderCell(element: ICellViewModel): void { }\n\n\t/**\n\t * Dispose any disposables generated from `didRenderCell`\n\t */\n\tunrenderCell(element: ICellViewModel): void {\n\t\tthis.currentCell = undefined;\n\t\tthis.cellDisposables.clear();\n\t}\n\n\t/**\n\t * Update internal DOM (top positions) per cell layout info change\n\t * Note that a cell part doesn't need to call `DOM.scheduleNextFrame`,\n\t * the list view will ensure that layout call is invoked in the right frame\n\t */\n\tupdateInternalLayoutNow(element: ICellViewModel): void { }\n\n\t/**\n\t * Update per cell state change\n\t */\n\tupdateState(element: ICellViewModel, e: CellViewModelStateChangeEvent): void { }\n\n\t/**\n\t * Update per execution state change.\n\t */\n\tupdateForExecutionState(element: ICellViewModel, e: ICellExecutionStateChangedEvent): void { }\n}\n\nfunction safeInvokeNoArg<T>(func: () => T): T | null {\n\ttry {\n\t\treturn func();\n\t} catch (e) {\n\t\tonUnexpectedError(e);\n\t\treturn null;\n\t}\n}\n\nexport class CellPartsCollection extends Disposable {\n\tprivate readonly _scheduledOverlayRendering = this._register(new MutableDisposable());\n\tprivate readonly _scheduledOverlayUpdateState = this._register(new MutableDisposable());\n\tprivate readonly _scheduledOverlayUpdateExecutionState = this._register(new MutableDisposable());\n\n\tconstructor(\n\t\tprivate readonly targetWindow: Window,\n\t\tprivate readonly contentParts: readonly CellContentPart[],\n\t\tprivate readonly overlayParts: readonly CellOverlayPart[]\n\t) {\n\t\tsuper();\n\t}\n\n\tconcatContentPart(other: readonly CellContentPart[], targetWindow: Window): CellPartsCollection {\n\t\treturn new CellPartsCollection(targetWindow, this.contentParts.concat(other), this.overlayParts);\n\t}\n\n\tconcatOverlayPart(other: readonly CellOverlayPart[], targetWindow: Window): CellPartsCollection {\n\t\treturn new CellPartsCollection(targetWindow, this.contentParts, this.overlayParts.concat(other));\n\t}\n\n\tscheduleRenderCell(element: ICellViewModel): void {\n\t\t// prepare model\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.prepareRenderCell(element));\n\t\t}\n\n\t\tfor (const part of this.overlayParts) {\n\t\t\tsafeInvokeNoArg(() => part.prepareRenderCell(element));\n\t\t}\n\n\t\t// render content parts\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.renderCell(element));\n\t\t}\n\n\t\tthis._scheduledOverlayRendering.value = DOM.modify(this.targetWindow, () => {\n\t\t\tfor (const part of this.overlayParts) {\n\t\t\t\tsafeInvokeNoArg(() => part.renderCell(element));\n\t\t\t}\n\t\t});\n\t}\n\n\tunrenderCell(element: ICellViewModel): void {\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.unrenderCell(element));\n\t\t}\n\n\t\tthis._scheduledOverlayRendering.value = undefined;\n\t\tthis._scheduledOverlayUpdateState.value = undefined;\n\t\tthis._scheduledOverlayUpdateExecutionState.value = undefined;\n\n\t\tfor (const part of this.overlayParts) {\n\t\t\tsafeInvokeNoArg(() => part.unrenderCell(element));\n\t\t}\n\t}\n\n\tupdateInternalLayoutNow(viewCell: ICellViewModel) {\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.updateInternalLayoutNow(viewCell));\n\t\t}\n\n\t\tfor (const part of this.overlayParts) {\n\t\t\tsafeInvokeNoArg(() => part.updateInternalLayoutNow(viewCell));\n\t\t}\n\t}\n\n\tprepareLayout() {\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.prepareLayout());\n\t\t}\n\t}\n\n\tupdateState(viewCell: ICellViewModel, e: CellViewModelStateChangeEvent) {\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.updateState(viewCell, e));\n\t\t}\n\n\t\tthis._scheduledOverlayUpdateState.value = DOM.modify(this.targetWindow, () => {\n\t\t\tfor (const part of this.overlayParts) {\n\t\t\t\tsafeInvokeNoArg(() => part.updateState(viewCell, e));\n\t\t\t}\n\t\t});\n\t}\n\n\tupdateForExecutionState(viewCell: ICellViewModel, e: ICellExecutionStateChangedEvent) {\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.updateForExecutionState(viewCell, e));\n\t\t}\n\n\t\tthis._scheduledOverlayUpdateExecutionState.value = DOM.modify(this.targetWindow, () => {\n\t\t\tfor (const part of this.overlayParts) {\n\t\t\t\tsafeInvokeNoArg(() => part.updateForExecutionState(viewCell, e));\n\t\t\t}\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from '../../../../../base/browser/dom.js';\nimport { onUnexpectedError } from '../../../../../base/common/errors.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../../base/common/lifecycle.js';\nimport { ICellViewModel } from '../notebookBrowser.js';\nimport { CellViewModelStateChangeEvent } from '../notebookViewEvents.js';\nimport { ICellExecutionStateChangedEvent } from '../../common/notebookExecutionStateService.js';\n\n/**\n * A content part is a non-floating element that is rendered inside a cell.\n * The rendering of the content part is synchronous to avoid flickering.\n */\nexport abstract class CellContentPart extends Disposable {\n\tprotected currentCell: ICellViewModel | undefined;\n\tprotected readonly cellDisposables = this._register(new DisposableStore());\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Prepare model for cell part rendering\n\t * No DOM operations recommended within this operation\n\t */\n\tprepareRenderCell(element: ICellViewModel): void { }\n\n\t/**\n\t * Update the DOM for the cell `element`\n\t */\n\trenderCell(element: ICellViewModel): void {\n\t\tthis.currentCell = element;\n\t\tsafeInvokeNoArg(() => this.didRenderCell(element));\n\t}\n\n\tdidRenderCell(element: ICellViewModel): void { }\n\n\t/**\n\t * Dispose any disposables generated from `didRenderCell`\n\t */\n\tunrenderCell(element: ICellViewModel): void {\n\t\tthis.currentCell = undefined;\n\t\tthis.cellDisposables.clear();\n\t}\n\n\t/**\n\t * Perform DOM read operations to prepare for the list/cell layout update.\n\t */\n\tprepareLayout(): void { }\n\n\t/**\n\t * Update internal DOM (top positions) per cell layout info change\n\t * Note that a cell part doesn't need to call `DOM.scheduleNextFrame`,\n\t * the list view will ensure that layout call is invoked in the right frame\n\t */\n\tupdateInternalLayoutNow(element: ICellViewModel): void { }\n\n\t/**\n\t * Update per cell state change\n\t */\n\tupdateState(element: ICellViewModel, e: CellViewModelStateChangeEvent): void { }\n\n\t/**\n\t * Update per execution state change.\n\t */\n\tupdateForExecutionState(element: ICellViewModel, e: ICellExecutionStateChangedEvent): void { }\n}\n\n/**\n * An overlay part renders on top of other components.\n * The rendering of the overlay part might be postponed to the next animation frame to avoid forced reflow.\n */\nexport abstract class CellOverlayPart extends Disposable {\n\tprotected currentCell: ICellViewModel | undefined;\n\tprotected readonly cellDisposables = this._register(new DisposableStore());\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Prepare model for cell part rendering\n\t * No DOM operations recommended within this operation\n\t */\n\tprepareRenderCell(element: ICellViewModel): void { }\n\n\t/**\n\t * Update the DOM for the cell `element`\n\t */\n\trenderCell(element: ICellViewModel): void {\n\t\tthis.currentCell = element;\n\t\tthis.didRenderCell(element);\n\t}\n\n\tdidRenderCell(element: ICellViewModel): void { }\n\n\t/**\n\t * Dispose any disposables generated from `didRenderCell`\n\t */\n\tunrenderCell(element: ICellViewModel): void {\n\t\tthis.currentCell = undefined;\n\t\tthis.cellDisposables.clear();\n\t}\n\n\t/**\n\t * Update internal DOM (top positions) per cell layout info change\n\t * Note that a cell part doesn't need to call `DOM.scheduleNextFrame`,\n\t * the list view will ensure that layout call is invoked in the right frame\n\t */\n\tupdateInternalLayoutNow(element: ICellViewModel): void { }\n\n\t/**\n\t * Update per cell state change\n\t */\n\tupdateState(element: ICellViewModel, e: CellViewModelStateChangeEvent): void { }\n\n\t/**\n\t * Update per execution state change.\n\t */\n\tupdateForExecutionState(element: ICellViewModel, e: ICellExecutionStateChangedEvent): void { }\n}\n\nfunction safeInvokeNoArg<T>(func: () => T): T | null {\n\ttry {\n\t\treturn func();\n\t} catch (e) {\n\t\tonUnexpectedError(e);\n\t\treturn null;\n\t}\n}\n\nexport class CellPartsCollection extends Disposable {\n\tprivate readonly _scheduledOverlayRendering = this._register(new MutableDisposable());\n\tprivate readonly _scheduledOverlayUpdateState = this._register(new MutableDisposable());\n\tprivate readonly _scheduledOverlayUpdateExecutionState = this._register(new MutableDisposable());\n\n\tconstructor(\n\t\tprivate readonly targetWindow: Window,\n\t\tprivate readonly contentParts: readonly CellContentPart[],\n\t\tprivate readonly overlayParts: readonly CellOverlayPart[]\n\t) {\n\t\tsuper();\n\t}\n\n\tconcatContentPart(other: readonly CellContentPart[], targetWindow: Window): CellPartsCollection {\n\t\treturn new CellPartsCollection(targetWindow, this.contentParts.concat(other), this.overlayParts);\n\t}\n\n\tconcatOverlayPart(other: readonly CellOverlayPart[], targetWindow: Window): CellPartsCollection {\n\t\treturn new CellPartsCollection(targetWindow, this.contentParts, this.overlayParts.concat(other));\n\t}\n\n\tscheduleRenderCell(element: ICellViewModel): void {\n\t\t// prepare model\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.prepareRenderCell(element));\n\t\t}\n\n\t\tfor (const part of this.overlayParts) {\n\t\t\tsafeInvokeNoArg(() => part.prepareRenderCell(element));\n\t\t}\n\n\t\t// render content parts\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.renderCell(element));\n\t\t}\n\n\t\tthis._scheduledOverlayRendering.value = DOM.modify(this.targetWindow, () => {\n\t\t\tfor (const part of this.overlayParts) {\n\t\t\t\tsafeInvokeNoArg(() => part.renderCell(element));\n\t\t\t}\n\t\t});\n\t}\n\n\tunrenderCell(element: ICellViewModel): void {\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.unrenderCell(element));\n\t\t}\n\n\t\tthis._scheduledOverlayRendering.value = undefined;\n\t\tthis._scheduledOverlayUpdateState.value = undefined;\n\t\tthis._scheduledOverlayUpdateExecutionState.value = undefined;\n\n\t\tfor (const part of this.overlayParts) {\n\t\t\tsafeInvokeNoArg(() => part.unrenderCell(element));\n\t\t}\n\t}\n\n\tupdateInternalLayoutNow(viewCell: ICellViewModel) {\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.updateInternalLayoutNow(viewCell));\n\t\t}\n\n\t\tfor (const part of this.overlayParts) {\n\t\t\tsafeInvokeNoArg(() => part.updateInternalLayoutNow(viewCell));\n\t\t}\n\t}\n\n\tprepareLayout() {\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.prepareLayout());\n\t\t}\n\t}\n\n\tupdateState(viewCell: ICellViewModel, e: CellViewModelStateChangeEvent) {\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.updateState(viewCell, e));\n\t\t}\n\n\t\tthis._scheduledOverlayUpdateState.value = DOM.modify(this.targetWindow, () => {\n\t\t\tfor (const part of this.overlayParts) {\n\t\t\t\tsafeInvokeNoArg(() => part.updateState(viewCell, e));\n\t\t\t}\n\t\t});\n\t}\n\n\tupdateForExecutionState(viewCell: ICellViewModel, e: ICellExecutionStateChangedEvent) {\n\t\tfor (const part of this.contentParts) {\n\t\t\tsafeInvokeNoArg(() => part.updateForExecutionState(viewCell, e));\n\t\t}\n\n\t\tthis._scheduledOverlayUpdateExecutionState.value = DOM.modify(this.targetWindow, () => {\n\t\t\tfor (const part of this.overlayParts) {\n\t\t\t\tsafeInvokeNoArg(() => part.updateForExecutionState(viewCell, e));\n\t\t\t}\n\t\t});\n\t}\n}\n"]}