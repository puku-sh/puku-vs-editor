{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/notebook/browser/viewParts/notebookEditorStickyScroll.ts","vs/workbench/contrib/notebook/browser/viewParts/notebookEditorStickyScroll.ts"],"names":[],"mappings":"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","file":"notebookEditorStickyScroll.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from '../../../../../base/browser/dom.js';\nimport { EventType as TouchEventType } from '../../../../../base/browser/touch.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { IMouseWheelEvent, StandardMouseEvent } from '../../../../../base/browser/mouseEvent.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { Disposable, DisposableStore, type IReference } from '../../../../../base/common/lifecycle.js';\nimport { MenuId } from '../../../../../platform/actions/common/actions.js';\nimport { IContextMenuService } from '../../../../../platform/contextview/browser/contextView.js';\nimport { CellFoldingState, INotebookEditor } from '../notebookBrowser.js';\nimport { INotebookCellList } from '../view/notebookRenderingCommon.js';\nimport { OutlineEntry } from '../viewModel/OutlineEntry.js';\nimport { NotebookCellOutlineDataSource } from '../viewModel/notebookOutlineDataSource.js';\nimport { CellKind } from '../../common/notebookCommon.js';\nimport { Delayer } from '../../../../../base/common/async.js';\nimport { ThemeIcon } from '../../../../../base/common/themables.js';\nimport { foldingCollapsedIcon, foldingExpandedIcon } from '../../../../../editor/contrib/folding/browser/foldingDecorations.js';\nimport { MarkupCellViewModel } from '../viewModel/markupCellViewModel.js';\nimport { FoldingController } from '../controller/foldingController.js';\nimport { NotebookOptionsChangeEvent } from '../notebookOptions.js';\nimport { NotebookOutlineEntryArgs } from '../controller/sectionActions.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { INotebookCellOutlineDataSourceFactory } from '../viewModel/notebookOutlineDataSourceFactory.js';\n\nexport class NotebookStickyLine extends Disposable {\n\tconstructor(\n\t\tpublic readonly element: HTMLElement,\n\t\tpublic readonly foldingIcon: StickyFoldingIcon,\n\t\tpublic readonly header: HTMLElement,\n\t\tpublic readonly entry: OutlineEntry,\n\t\tpublic readonly notebookEditor: INotebookEditor,\n\t) {\n\t\tsuper();\n\t\t// click the header to focus the cell\n\t\tthis._register(DOM.addDisposableListener(this.header, DOM.EventType.CLICK || TouchEventType.Tap, () => {\n\t\t\tthis.focusCell();\n\t\t}));\n\n\t\t// click the folding icon to fold the range covered by the header\n\t\tthis._register(DOM.addDisposableListener(this.foldingIcon.domNode, DOM.EventType.CLICK || TouchEventType.Tap, () => {\n\t\t\tif (this.entry.cell.cellKind === CellKind.Markup) {\n\t\t\t\tconst currentFoldingState = (this.entry.cell as MarkupCellViewModel).foldingState;\n\t\t\t\tthis.toggleFoldRange(currentFoldingState);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate toggleFoldRange(currentState: CellFoldingState) {\n\t\tconst foldingController = this.notebookEditor.getContribution<FoldingController>(FoldingController.id);\n\n\t\tconst index = this.entry.index;\n\t\tconst headerLevel = this.entry.level;\n\t\tconst newFoldingState = (currentState === CellFoldingState.Collapsed) ? CellFoldingState.Expanded : CellFoldingState.Collapsed;\n\n\t\tfoldingController.setFoldingStateDown(index, newFoldingState, headerLevel);\n\t\tthis.focusCell();\n\t}\n\n\tprivate focusCell() {\n\t\tthis.notebookEditor.focusNotebookCell(this.entry.cell, 'container');\n\t\tconst cellScrollTop = this.notebookEditor.getAbsoluteTopOfElement(this.entry.cell);\n\t\tconst parentCount = NotebookStickyLine.getParentCount(this.entry);\n\t\t// 1.1 addresses visible cell padding, to make sure we don't focus md cell and also render its sticky line\n\t\tthis.notebookEditor.setScrollTop(cellScrollTop - (parentCount + 1.1) * 22);\n\t}\n\n\tstatic getParentCount(entry: OutlineEntry) {\n\t\tlet count = 0;\n\t\twhile (entry.parent) {\n\t\t\tcount++;\n\t\t\tentry = entry.parent;\n\t\t}\n\t\treturn count;\n\t}\n}\n\nclass StickyFoldingIcon {\n\n\tpublic domNode: HTMLElement;\n\n\tconstructor(\n\t\tpublic isCollapsed: boolean,\n\t\tpublic dimension: number\n\t) {\n\t\tthis.domNode = document.createElement('div');\n\t\tthis.domNode.style.width = `${dimension}px`;\n\t\tthis.domNode.style.height = `${dimension}px`;\n\t\tthis.domNode.className = ThemeIcon.asClassName(isCollapsed ? foldingCollapsedIcon : foldingExpandedIcon);\n\t}\n\n\tpublic setVisible(visible: boolean) {\n\t\tthis.domNode.style.cursor = visible ? 'pointer' : 'default';\n\t\tthis.domNode.style.opacity = visible ? '1' : '0';\n\t}\n}\n\nexport class NotebookStickyScroll extends Disposable {\n\tprivate readonly _disposables = new DisposableStore();\n\tprivate currentStickyLines = new Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>();\n\n\tprivate readonly _onDidChangeNotebookStickyScroll = this._register(new Emitter<number>());\n\treadonly onDidChangeNotebookStickyScroll: Event<number> = this._onDidChangeNotebookStickyScroll.event;\n\tprivate notebookCellOutlineReference?: IReference<NotebookCellOutlineDataSource>;\n\n\tprivate readonly _layoutDisposableStore = this._register(new DisposableStore());\n\n\tgetDomNode(): HTMLElement {\n\t\treturn this.domNode;\n\t}\n\n\tgetCurrentStickyHeight() {\n\t\tlet height = 0;\n\t\tthis.currentStickyLines.forEach((value) => {\n\t\t\tif (value.rendered) {\n\t\t\t\theight += 22;\n\t\t\t}\n\t\t});\n\t\treturn height;\n\t}\n\n\tprivate setCurrentStickyLines(newStickyLines: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>) {\n\t\tthis.currentStickyLines = newStickyLines;\n\t}\n\n\tprivate compareStickyLineMaps(mapA: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>, mapB: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>): boolean {\n\t\tif (mapA.size !== mapB.size) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const [key, value] of mapA) {\n\t\t\tconst otherValue = mapB.get(key);\n\t\t\tif (!otherValue || value.rendered !== otherValue.rendered) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tconstructor(\n\t\tprivate readonly domNode: HTMLElement,\n\t\tprivate readonly notebookEditor: INotebookEditor,\n\t\tprivate readonly notebookCellList: INotebookCellList,\n\t\tprivate readonly layoutFn: (delta: number) => void,\n\t\t@IContextMenuService private readonly _contextMenuService: IContextMenuService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService\n\t) {\n\t\tsuper();\n\n\t\tif (this.notebookEditor.notebookOptions.getDisplayOptions().stickyScrollEnabled) {\n\t\t\tthis.init().catch(console.error);\n\t\t}\n\n\t\tthis._register(this.notebookEditor.notebookOptions.onDidChangeOptions((e) => {\n\t\t\tif (e.stickyScrollEnabled || e.stickyScrollMode) {\n\t\t\t\tthis.updateConfig(e);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(DOM.addDisposableListener(this.domNode, DOM.EventType.CONTEXT_MENU, async (event: MouseEvent) => {\n\t\t\tthis.onContextMenu(event);\n\t\t}));\n\n\t\t// Forward wheel events to the notebook editor to enable scrolling when hovering over sticky scroll\n\t\tthis._register(DOM.addDisposableListener(this.domNode, DOM.EventType.WHEEL, (event: WheelEvent) => {\n\t\t\tthis.notebookCellList.triggerScrollFromMouseWheelEvent(event as unknown as IMouseWheelEvent);\n\t\t}));\n\t}\n\n\tprivate onContextMenu(e: MouseEvent) {\n\t\tconst event = new StandardMouseEvent(DOM.getWindow(this.domNode), e);\n\n\t\tconst selectedElement = event.target.parentElement;\n\t\tconst selectedOutlineEntry = Array.from(this.currentStickyLines.values()).find(entry => entry.line.element.contains(selectedElement))?.line.entry;\n\t\tif (!selectedOutlineEntry) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst args: NotebookOutlineEntryArgs = {\n\t\t\toutlineEntry: selectedOutlineEntry,\n\t\t\tnotebookEditor: this.notebookEditor,\n\t\t};\n\n\t\tthis._contextMenuService.showContextMenu({\n\t\t\tmenuId: MenuId.NotebookStickyScrollContext,\n\t\t\tgetAnchor: () => event,\n\t\t\tmenuActionOptions: { shouldForwardArgs: true, arg: args },\n\t\t});\n\t}\n\n\tprivate updateConfig(e: NotebookOptionsChangeEvent) {\n\t\tif (e.stickyScrollEnabled) {\n\t\t\tif (this.notebookEditor.notebookOptions.getDisplayOptions().stickyScrollEnabled) {\n\t\t\t\tthis.init().catch(console.error);\n\t\t\t} else {\n\t\t\t\tthis._disposables.clear();\n\t\t\t\tthis.notebookCellOutlineReference?.dispose();\n\t\t\t\tthis.disposeCurrentStickyLines();\n\t\t\t\tDOM.clearNode(this.domNode);\n\t\t\t\tthis.updateDisplay();\n\t\t\t}\n\t\t} else if (e.stickyScrollMode && this.notebookEditor.notebookOptions.getDisplayOptions().stickyScrollEnabled && this.notebookCellOutlineReference?.object) {\n\t\t\tthis.updateContent(computeContent(this.notebookEditor, this.notebookCellList, this.notebookCellOutlineReference?.object?.entries, this.getCurrentStickyHeight()));\n\t\t}\n\t}\n\n\tprivate async init() {\n\t\tconst { object: notebookCellOutline } = this.notebookCellOutlineReference = this.instantiationService.invokeFunction((accessor) => accessor.get(INotebookCellOutlineDataSourceFactory).getOrCreate(this.notebookEditor));\n\t\tthis._register(this.notebookCellOutlineReference);\n\n\t\t// Ensure symbols are computed first\n\t\tawait notebookCellOutline.computeFullSymbols(CancellationToken.None);\n\n\t\t// Initial content update\n\t\tconst computed = computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight());\n\t\tthis.updateContent(computed);\n\n\t\t// Set up outline change listener\n\t\tthis._disposables.add(notebookCellOutline.onDidChange(() => {\n\t\t\tconst computed = computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight());\n\t\t\tif (!this.compareStickyLineMaps(computed, this.currentStickyLines)) {\n\t\t\t\tthis.updateContent(computed);\n\t\t\t} else {\n\t\t\t\t// if we don't end up updating the content, we need to avoid leaking the map\n\t\t\t\tthis.disposeStickyLineMap(computed);\n\t\t\t}\n\t\t}));\n\n\t\t// Handle view model changes\n\t\tthis._disposables.add(this.notebookEditor.onDidAttachViewModel(async () => {\n\t\t\t// ensure recompute symbols when view model changes -- could be missed if outline is closed\n\t\t\tawait notebookCellOutline.computeFullSymbols(CancellationToken.None);\n\n\t\t\tconst computed = computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight());\n\t\t\tthis.updateContent(computed);\n\t\t}));\n\n\t\tthis._disposables.add(this.notebookEditor.onDidScroll(() => {\n\t\t\tconst d = new Delayer(100);\n\t\t\td.trigger(() => {\n\t\t\t\td.dispose();\n\n\t\t\t\tconst computed = computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight());\n\t\t\t\tif (!this.compareStickyLineMaps(computed, this.currentStickyLines)) {\n\t\t\t\t\tthis.updateContent(computed);\n\t\t\t\t} else {\n\t\t\t\t\t// if we don't end up updating the content, we need to avoid leaking the map\n\t\t\t\t\tthis.disposeStickyLineMap(computed);\n\t\t\t\t}\n\t\t\t});\n\t\t}));\n\t}\n\n\t// Add helper method to dispose a map of sticky lines\n\tprivate disposeStickyLineMap(map: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>) {\n\t\tmap.forEach(value => {\n\t\t\tif (value.line) {\n\t\t\t\tvalue.line.dispose();\n\t\t\t}\n\t\t});\n\t}\n\n\t// take in an cell index, and get the corresponding outline entry\n\tstatic getVisibleOutlineEntry(visibleIndex: number, notebookOutlineEntries: OutlineEntry[]): OutlineEntry | undefined {\n\t\tlet left = 0;\n\t\tlet right = notebookOutlineEntries.length - 1;\n\n\t\twhile (left <= right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tif (notebookOutlineEntries[mid].index === visibleIndex) {\n\t\t\t\t// Exact match found\n\t\t\t\tconst rootEntry = notebookOutlineEntries[mid];\n\t\t\t\tconst flatList: OutlineEntry[] = [];\n\t\t\t\trootEntry.asFlatList(flatList);\n\t\t\t\treturn flatList.find(entry => entry.index === visibleIndex);\n\t\t\t} else if (notebookOutlineEntries[mid].index < visibleIndex) {\n\t\t\t\tleft = mid + 1;\n\t\t\t} else {\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\n\t\t// No exact match found - get the closest smaller entry\n\t\tif (right >= 0) {\n\t\t\tconst rootEntry = notebookOutlineEntries[right];\n\t\t\tconst flatList: OutlineEntry[] = [];\n\t\t\trootEntry.asFlatList(flatList);\n\t\t\treturn flatList.find(entry => entry.index === visibleIndex);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate updateContent(newMap: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>) {\n\t\tDOM.clearNode(this.domNode);\n\t\tthis.disposeCurrentStickyLines();\n\t\tthis.renderStickyLines(newMap, this.domNode);\n\n\t\tconst oldStickyHeight = this.getCurrentStickyHeight();\n\t\tthis.setCurrentStickyLines(newMap);\n\n\t\t// (+) = sticky height increased\n\t\t// (-) = sticky height decreased\n\t\tconst sizeDelta = this.getCurrentStickyHeight() - oldStickyHeight;\n\t\tif (sizeDelta !== 0) {\n\t\t\tthis._onDidChangeNotebookStickyScroll.fire(sizeDelta);\n\n\t\t\tconst d = this._layoutDisposableStore.add(DOM.scheduleAtNextAnimationFrame(DOM.getWindow(this.getDomNode()), () => {\n\t\t\t\tthis.layoutFn(sizeDelta);\n\t\t\t\tthis.updateDisplay();\n\n\t\t\t\tthis._layoutDisposableStore.delete(d);\n\t\t\t}));\n\t\t} else {\n\t\t\tthis.updateDisplay();\n\t\t}\n\t}\n\n\tprivate updateDisplay() {\n\t\tconst hasSticky = this.getCurrentStickyHeight() > 0;\n\t\tif (!hasSticky) {\n\t\t\tthis.domNode.style.display = 'none';\n\t\t} else {\n\t\t\tthis.domNode.style.display = 'block';\n\t\t}\n\t}\n\n\tstatic computeStickyHeight(entry: OutlineEntry) {\n\t\tlet height = 0;\n\t\tif (entry.cell.cellKind === CellKind.Markup && entry.level < 7) {\n\t\t\theight += 22;\n\t\t}\n\t\twhile (entry.parent) {\n\t\t\theight += 22;\n\t\t\tentry = entry.parent;\n\t\t}\n\t\treturn height;\n\t}\n\n\tstatic checkCollapsedStickyLines(entry: OutlineEntry | undefined, numLinesToRender: number, notebookEditor: INotebookEditor) {\n\t\tlet currentEntry = entry;\n\t\tconst newMap = new Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>();\n\n\t\tconst elementsToRender = [];\n\t\twhile (currentEntry) {\n\t\t\tif (currentEntry.level >= 7) {\n\t\t\t\t// level 7+ represents a non-header entry, which we don't want to render\n\t\t\t\tcurrentEntry = currentEntry.parent;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst lineToRender = NotebookStickyScroll.createStickyElement(currentEntry, notebookEditor);\n\t\t\tnewMap.set(currentEntry, { line: lineToRender, rendered: false });\n\t\t\telementsToRender.unshift(lineToRender);\n\t\t\tcurrentEntry = currentEntry.parent;\n\t\t}\n\n\t\t// iterate over elements to render, and append to container\n\t\t// break when we reach numLinesToRender\n\t\tfor (let i = 0; i < elementsToRender.length; i++) {\n\t\t\tif (i >= numLinesToRender) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnewMap.set(elementsToRender[i].entry, { line: elementsToRender[i], rendered: true });\n\t\t}\n\t\treturn newMap;\n\t}\n\n\tprivate renderStickyLines(stickyMap: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>, containerElement: HTMLElement) {\n\t\tconst reversedEntries = Array.from(stickyMap.entries()).reverse();\n\t\tfor (const [, value] of reversedEntries) {\n\t\t\tif (!value.rendered) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcontainerElement.append(value.line.element);\n\t\t}\n\t}\n\n\tstatic createStickyElement(entry: OutlineEntry, notebookEditor: INotebookEditor) {\n\t\tconst stickyElement = document.createElement('div');\n\t\tstickyElement.classList.add('notebook-sticky-scroll-element');\n\n\t\tconst indentMode = notebookEditor.notebookOptions.getLayoutConfiguration().stickyScrollMode;\n\t\tif (indentMode === 'indented') {\n\t\t\tstickyElement.style.paddingLeft = NotebookStickyLine.getParentCount(entry) * 10 + 'px';\n\t\t}\n\n\t\tlet isCollapsed = false;\n\t\tif (entry.cell.cellKind === CellKind.Markup) {\n\t\t\tisCollapsed = (entry.cell as MarkupCellViewModel).foldingState === CellFoldingState.Collapsed;\n\t\t}\n\n\t\tconst stickyFoldingIcon = new StickyFoldingIcon(isCollapsed, 16);\n\t\tstickyFoldingIcon.domNode.classList.add('notebook-sticky-scroll-folding-icon');\n\t\tstickyFoldingIcon.setVisible(true);\n\n\t\tconst stickyHeader = document.createElement('div');\n\t\tstickyHeader.classList.add('notebook-sticky-scroll-header');\n\t\tstickyHeader.innerText = entry.label;\n\n\t\tstickyElement.append(stickyFoldingIcon.domNode, stickyHeader);\n\n\t\treturn new NotebookStickyLine(stickyElement, stickyFoldingIcon, stickyHeader, entry, notebookEditor);\n\t}\n\n\tprivate disposeCurrentStickyLines() {\n\t\tthis.currentStickyLines.forEach((value) => {\n\t\t\tvalue.line.dispose();\n\t\t});\n\t}\n\n\toverride dispose() {\n\t\tthis._disposables.dispose();\n\t\tthis.disposeCurrentStickyLines();\n\t\tthis.notebookCellOutlineReference?.dispose();\n\t\tsuper.dispose();\n\t}\n}\n\nexport function computeContent(notebookEditor: INotebookEditor, notebookCellList: INotebookCellList, notebookOutlineEntries: OutlineEntry[], renderedStickyHeight: number): Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }> {\n\t// get data about the cell list within viewport ----------------------------------------------------------------------------------------\n\tconst editorScrollTop = notebookEditor.scrollTop - renderedStickyHeight;\n\tconst visibleRange = notebookEditor.visibleRanges[0];\n\tif (!visibleRange) {\n\t\treturn new Map();\n\t}\n\n\t// edge case for cell 0 in the notebook is a header ------------------------------------------------------------------------------------\n\tif (visibleRange.start === 0) {\n\t\tconst firstCell = notebookEditor.cellAt(0);\n\t\tconst firstCellEntry = NotebookStickyScroll.getVisibleOutlineEntry(0, notebookOutlineEntries);\n\t\tif (firstCell && firstCellEntry && firstCell.cellKind === CellKind.Markup && firstCellEntry.level < 7) {\n\t\t\tif (notebookEditor.scrollTop > 22) {\n\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(firstCellEntry, 100, notebookEditor);\n\t\t\t\treturn newMap;\n\t\t\t}\n\t\t}\n\t}\n\n\t// iterate over cells in viewport ------------------------------------------------------------------------------------------------------\n\tlet cell;\n\tlet cellEntry;\n\tconst startIndex = visibleRange.start - 1; // -1 to account for cells hidden \"under\" sticky lines.\n\tfor (let currentIndex = startIndex; currentIndex < visibleRange.end; currentIndex++) {\n\t\t// store data for current cell, and next cell\n\t\tcell = notebookEditor.cellAt(currentIndex);\n\t\tif (!cell) {\n\t\t\treturn new Map();\n\t\t}\n\t\tcellEntry = NotebookStickyScroll.getVisibleOutlineEntry(currentIndex, notebookOutlineEntries);\n\t\tif (!cellEntry) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst nextCell = notebookEditor.cellAt(currentIndex + 1);\n\t\tif (!nextCell) {\n\t\t\tconst sectionBottom = notebookEditor.getLayoutInfo().scrollHeight;\n\t\t\tconst linesToRender = Math.floor((sectionBottom) / 22);\n\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\t\t\treturn newMap;\n\t\t}\n\t\tconst nextCellEntry = NotebookStickyScroll.getVisibleOutlineEntry(currentIndex + 1, notebookOutlineEntries);\n\t\tif (!nextCellEntry) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// check next cell, if markdown with non level 7 entry, that means this is the end of the section (new header) ---------------------\n\t\tif (nextCell.cellKind === CellKind.Markup && nextCellEntry.level < 7) {\n\t\t\tconst sectionBottom = notebookCellList.getCellViewScrollTop(nextCell);\n\t\t\tconst currentSectionStickyHeight = NotebookStickyScroll.computeStickyHeight(cellEntry);\n\t\t\tconst nextSectionStickyHeight = NotebookStickyScroll.computeStickyHeight(nextCellEntry);\n\n\t\t\t// case: we can render the all sticky lines for the current section ------------------------------------------------------------\n\t\t\tif (editorScrollTop + currentSectionStickyHeight < sectionBottom) {\n\t\t\t\tconst linesToRender = Math.floor((sectionBottom - editorScrollTop) / 22);\n\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\t\t\t\treturn newMap;\n\t\t\t}\n\n\t\t\t// case: next section is the same size or bigger, render next entry -----------------------------------------------------------\n\t\t\telse if (nextSectionStickyHeight >= currentSectionStickyHeight) {\n\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(nextCellEntry, 100, notebookEditor);\n\t\t\t\treturn newMap;\n\t\t\t}\n\t\t\t// case: next section is the smaller, shrink until next section height is greater than the available space ---------------------\n\t\t\telse if (nextSectionStickyHeight < currentSectionStickyHeight) {\n\t\t\t\tconst availableSpace = sectionBottom - editorScrollTop;\n\n\t\t\t\tif (availableSpace >= nextSectionStickyHeight) {\n\t\t\t\t\tconst linesToRender = Math.floor((availableSpace) / 22);\n\t\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\t\t\t\t\treturn newMap;\n\t\t\t\t} else {\n\t\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(nextCellEntry, 100, notebookEditor);\n\t\t\t\t\treturn newMap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} // visible range loop close\n\n\t// case: all visible cells were non-header cells, so render any headers relevant to their section --------------------------------------\n\tconst sectionBottom = notebookEditor.getLayoutInfo().scrollHeight;\n\tconst linesToRender = Math.floor((sectionBottom - editorScrollTop) / 22);\n\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\treturn newMap;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from '../../../../../base/browser/dom.js';\nimport { EventType as TouchEventType } from '../../../../../base/browser/touch.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { IMouseWheelEvent, StandardMouseEvent } from '../../../../../base/browser/mouseEvent.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { Disposable, DisposableStore, type IReference } from '../../../../../base/common/lifecycle.js';\nimport { MenuId } from '../../../../../platform/actions/common/actions.js';\nimport { IContextMenuService } from '../../../../../platform/contextview/browser/contextView.js';\nimport { CellFoldingState, INotebookEditor } from '../notebookBrowser.js';\nimport { INotebookCellList } from '../view/notebookRenderingCommon.js';\nimport { OutlineEntry } from '../viewModel/OutlineEntry.js';\nimport { NotebookCellOutlineDataSource } from '../viewModel/notebookOutlineDataSource.js';\nimport { CellKind } from '../../common/notebookCommon.js';\nimport { Delayer } from '../../../../../base/common/async.js';\nimport { ThemeIcon } from '../../../../../base/common/themables.js';\nimport { foldingCollapsedIcon, foldingExpandedIcon } from '../../../../../editor/contrib/folding/browser/foldingDecorations.js';\nimport { MarkupCellViewModel } from '../viewModel/markupCellViewModel.js';\nimport { FoldingController } from '../controller/foldingController.js';\nimport { NotebookOptionsChangeEvent } from '../notebookOptions.js';\nimport { NotebookOutlineEntryArgs } from '../controller/sectionActions.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { INotebookCellOutlineDataSourceFactory } from '../viewModel/notebookOutlineDataSourceFactory.js';\n\nexport class NotebookStickyLine extends Disposable {\n\tconstructor(\n\t\tpublic readonly element: HTMLElement,\n\t\tpublic readonly foldingIcon: StickyFoldingIcon,\n\t\tpublic readonly header: HTMLElement,\n\t\tpublic readonly entry: OutlineEntry,\n\t\tpublic readonly notebookEditor: INotebookEditor,\n\t) {\n\t\tsuper();\n\t\t// click the header to focus the cell\n\t\tthis._register(DOM.addDisposableListener(this.header, DOM.EventType.CLICK || TouchEventType.Tap, () => {\n\t\t\tthis.focusCell();\n\t\t}));\n\n\t\t// click the folding icon to fold the range covered by the header\n\t\tthis._register(DOM.addDisposableListener(this.foldingIcon.domNode, DOM.EventType.CLICK || TouchEventType.Tap, () => {\n\t\t\tif (this.entry.cell.cellKind === CellKind.Markup) {\n\t\t\t\tconst currentFoldingState = (this.entry.cell as MarkupCellViewModel).foldingState;\n\t\t\t\tthis.toggleFoldRange(currentFoldingState);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate toggleFoldRange(currentState: CellFoldingState) {\n\t\tconst foldingController = this.notebookEditor.getContribution<FoldingController>(FoldingController.id);\n\n\t\tconst index = this.entry.index;\n\t\tconst headerLevel = this.entry.level;\n\t\tconst newFoldingState = (currentState === CellFoldingState.Collapsed) ? CellFoldingState.Expanded : CellFoldingState.Collapsed;\n\n\t\tfoldingController.setFoldingStateDown(index, newFoldingState, headerLevel);\n\t\tthis.focusCell();\n\t}\n\n\tprivate focusCell() {\n\t\tthis.notebookEditor.focusNotebookCell(this.entry.cell, 'container');\n\t\tconst cellScrollTop = this.notebookEditor.getAbsoluteTopOfElement(this.entry.cell);\n\t\tconst parentCount = NotebookStickyLine.getParentCount(this.entry);\n\t\t// 1.1 addresses visible cell padding, to make sure we don't focus md cell and also render its sticky line\n\t\tthis.notebookEditor.setScrollTop(cellScrollTop - (parentCount + 1.1) * 22);\n\t}\n\n\tstatic getParentCount(entry: OutlineEntry) {\n\t\tlet count = 0;\n\t\twhile (entry.parent) {\n\t\t\tcount++;\n\t\t\tentry = entry.parent;\n\t\t}\n\t\treturn count;\n\t}\n}\n\nclass StickyFoldingIcon {\n\n\tpublic domNode: HTMLElement;\n\n\tconstructor(\n\t\tpublic isCollapsed: boolean,\n\t\tpublic dimension: number\n\t) {\n\t\tthis.domNode = document.createElement('div');\n\t\tthis.domNode.style.width = `${dimension}px`;\n\t\tthis.domNode.style.height = `${dimension}px`;\n\t\tthis.domNode.className = ThemeIcon.asClassName(isCollapsed ? foldingCollapsedIcon : foldingExpandedIcon);\n\t}\n\n\tpublic setVisible(visible: boolean) {\n\t\tthis.domNode.style.cursor = visible ? 'pointer' : 'default';\n\t\tthis.domNode.style.opacity = visible ? '1' : '0';\n\t}\n}\n\nexport class NotebookStickyScroll extends Disposable {\n\tprivate readonly _disposables = new DisposableStore();\n\tprivate currentStickyLines = new Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>();\n\n\tprivate readonly _onDidChangeNotebookStickyScroll = this._register(new Emitter<number>());\n\treadonly onDidChangeNotebookStickyScroll: Event<number> = this._onDidChangeNotebookStickyScroll.event;\n\tprivate notebookCellOutlineReference?: IReference<NotebookCellOutlineDataSource>;\n\n\tprivate readonly _layoutDisposableStore = this._register(new DisposableStore());\n\n\tgetDomNode(): HTMLElement {\n\t\treturn this.domNode;\n\t}\n\n\tgetCurrentStickyHeight() {\n\t\tlet height = 0;\n\t\tthis.currentStickyLines.forEach((value) => {\n\t\t\tif (value.rendered) {\n\t\t\t\theight += 22;\n\t\t\t}\n\t\t});\n\t\treturn height;\n\t}\n\n\tprivate setCurrentStickyLines(newStickyLines: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>) {\n\t\tthis.currentStickyLines = newStickyLines;\n\t}\n\n\tprivate compareStickyLineMaps(mapA: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>, mapB: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>): boolean {\n\t\tif (mapA.size !== mapB.size) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const [key, value] of mapA) {\n\t\t\tconst otherValue = mapB.get(key);\n\t\t\tif (!otherValue || value.rendered !== otherValue.rendered) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tconstructor(\n\t\tprivate readonly domNode: HTMLElement,\n\t\tprivate readonly notebookEditor: INotebookEditor,\n\t\tprivate readonly notebookCellList: INotebookCellList,\n\t\tprivate readonly layoutFn: (delta: number) => void,\n\t\t@IContextMenuService private readonly _contextMenuService: IContextMenuService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService\n\t) {\n\t\tsuper();\n\n\t\tif (this.notebookEditor.notebookOptions.getDisplayOptions().stickyScrollEnabled) {\n\t\t\tthis.init().catch(console.error);\n\t\t}\n\n\t\tthis._register(this.notebookEditor.notebookOptions.onDidChangeOptions((e) => {\n\t\t\tif (e.stickyScrollEnabled || e.stickyScrollMode) {\n\t\t\t\tthis.updateConfig(e);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(DOM.addDisposableListener(this.domNode, DOM.EventType.CONTEXT_MENU, async (event: MouseEvent) => {\n\t\t\tthis.onContextMenu(event);\n\t\t}));\n\n\t\t// Forward wheel events to the notebook editor to enable scrolling when hovering over sticky scroll\n\t\tthis._register(DOM.addDisposableListener(this.domNode, DOM.EventType.WHEEL, (event: WheelEvent) => {\n\t\t\tthis.notebookCellList.triggerScrollFromMouseWheelEvent(event as unknown as IMouseWheelEvent);\n\t\t}));\n\t}\n\n\tprivate onContextMenu(e: MouseEvent) {\n\t\tconst event = new StandardMouseEvent(DOM.getWindow(this.domNode), e);\n\n\t\tconst selectedElement = event.target.parentElement;\n\t\tconst selectedOutlineEntry = Array.from(this.currentStickyLines.values()).find(entry => entry.line.element.contains(selectedElement))?.line.entry;\n\t\tif (!selectedOutlineEntry) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst args: NotebookOutlineEntryArgs = {\n\t\t\toutlineEntry: selectedOutlineEntry,\n\t\t\tnotebookEditor: this.notebookEditor,\n\t\t};\n\n\t\tthis._contextMenuService.showContextMenu({\n\t\t\tmenuId: MenuId.NotebookStickyScrollContext,\n\t\t\tgetAnchor: () => event,\n\t\t\tmenuActionOptions: { shouldForwardArgs: true, arg: args },\n\t\t});\n\t}\n\n\tprivate updateConfig(e: NotebookOptionsChangeEvent) {\n\t\tif (e.stickyScrollEnabled) {\n\t\t\tif (this.notebookEditor.notebookOptions.getDisplayOptions().stickyScrollEnabled) {\n\t\t\t\tthis.init().catch(console.error);\n\t\t\t} else {\n\t\t\t\tthis._disposables.clear();\n\t\t\t\tthis.notebookCellOutlineReference?.dispose();\n\t\t\t\tthis.disposeCurrentStickyLines();\n\t\t\t\tDOM.clearNode(this.domNode);\n\t\t\t\tthis.updateDisplay();\n\t\t\t}\n\t\t} else if (e.stickyScrollMode && this.notebookEditor.notebookOptions.getDisplayOptions().stickyScrollEnabled && this.notebookCellOutlineReference?.object) {\n\t\t\tthis.updateContent(computeContent(this.notebookEditor, this.notebookCellList, this.notebookCellOutlineReference?.object?.entries, this.getCurrentStickyHeight()));\n\t\t}\n\t}\n\n\tprivate async init() {\n\t\tconst { object: notebookCellOutline } = this.notebookCellOutlineReference = this.instantiationService.invokeFunction((accessor) => accessor.get(INotebookCellOutlineDataSourceFactory).getOrCreate(this.notebookEditor));\n\t\tthis._register(this.notebookCellOutlineReference);\n\n\t\t// Ensure symbols are computed first\n\t\tawait notebookCellOutline.computeFullSymbols(CancellationToken.None);\n\n\t\t// Initial content update\n\t\tconst computed = computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight());\n\t\tthis.updateContent(computed);\n\n\t\t// Set up outline change listener\n\t\tthis._disposables.add(notebookCellOutline.onDidChange(() => {\n\t\t\tconst computed = computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight());\n\t\t\tif (!this.compareStickyLineMaps(computed, this.currentStickyLines)) {\n\t\t\t\tthis.updateContent(computed);\n\t\t\t} else {\n\t\t\t\t// if we don't end up updating the content, we need to avoid leaking the map\n\t\t\t\tthis.disposeStickyLineMap(computed);\n\t\t\t}\n\t\t}));\n\n\t\t// Handle view model changes\n\t\tthis._disposables.add(this.notebookEditor.onDidAttachViewModel(async () => {\n\t\t\t// ensure recompute symbols when view model changes -- could be missed if outline is closed\n\t\t\tawait notebookCellOutline.computeFullSymbols(CancellationToken.None);\n\n\t\t\tconst computed = computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight());\n\t\t\tthis.updateContent(computed);\n\t\t}));\n\n\t\tthis._disposables.add(this.notebookEditor.onDidScroll(() => {\n\t\t\tconst d = new Delayer(100);\n\t\t\td.trigger(() => {\n\t\t\t\td.dispose();\n\n\t\t\t\tconst computed = computeContent(this.notebookEditor, this.notebookCellList, notebookCellOutline.entries, this.getCurrentStickyHeight());\n\t\t\t\tif (!this.compareStickyLineMaps(computed, this.currentStickyLines)) {\n\t\t\t\t\tthis.updateContent(computed);\n\t\t\t\t} else {\n\t\t\t\t\t// if we don't end up updating the content, we need to avoid leaking the map\n\t\t\t\t\tthis.disposeStickyLineMap(computed);\n\t\t\t\t}\n\t\t\t});\n\t\t}));\n\t}\n\n\t// Add helper method to dispose a map of sticky lines\n\tprivate disposeStickyLineMap(map: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>) {\n\t\tmap.forEach(value => {\n\t\t\tif (value.line) {\n\t\t\t\tvalue.line.dispose();\n\t\t\t}\n\t\t});\n\t}\n\n\t// take in an cell index, and get the corresponding outline entry\n\tstatic getVisibleOutlineEntry(visibleIndex: number, notebookOutlineEntries: OutlineEntry[]): OutlineEntry | undefined {\n\t\tlet left = 0;\n\t\tlet right = notebookOutlineEntries.length - 1;\n\n\t\twhile (left <= right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tif (notebookOutlineEntries[mid].index === visibleIndex) {\n\t\t\t\t// Exact match found\n\t\t\t\tconst rootEntry = notebookOutlineEntries[mid];\n\t\t\t\tconst flatList: OutlineEntry[] = [];\n\t\t\t\trootEntry.asFlatList(flatList);\n\t\t\t\treturn flatList.find(entry => entry.index === visibleIndex);\n\t\t\t} else if (notebookOutlineEntries[mid].index < visibleIndex) {\n\t\t\t\tleft = mid + 1;\n\t\t\t} else {\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\n\t\t// No exact match found - get the closest smaller entry\n\t\tif (right >= 0) {\n\t\t\tconst rootEntry = notebookOutlineEntries[right];\n\t\t\tconst flatList: OutlineEntry[] = [];\n\t\t\trootEntry.asFlatList(flatList);\n\t\t\treturn flatList.find(entry => entry.index === visibleIndex);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate updateContent(newMap: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>) {\n\t\tDOM.clearNode(this.domNode);\n\t\tthis.disposeCurrentStickyLines();\n\t\tthis.renderStickyLines(newMap, this.domNode);\n\n\t\tconst oldStickyHeight = this.getCurrentStickyHeight();\n\t\tthis.setCurrentStickyLines(newMap);\n\n\t\t// (+) = sticky height increased\n\t\t// (-) = sticky height decreased\n\t\tconst sizeDelta = this.getCurrentStickyHeight() - oldStickyHeight;\n\t\tif (sizeDelta !== 0) {\n\t\t\tthis._onDidChangeNotebookStickyScroll.fire(sizeDelta);\n\n\t\t\tconst d = this._layoutDisposableStore.add(DOM.scheduleAtNextAnimationFrame(DOM.getWindow(this.getDomNode()), () => {\n\t\t\t\tthis.layoutFn(sizeDelta);\n\t\t\t\tthis.updateDisplay();\n\n\t\t\t\tthis._layoutDisposableStore.delete(d);\n\t\t\t}));\n\t\t} else {\n\t\t\tthis.updateDisplay();\n\t\t}\n\t}\n\n\tprivate updateDisplay() {\n\t\tconst hasSticky = this.getCurrentStickyHeight() > 0;\n\t\tif (!hasSticky) {\n\t\t\tthis.domNode.style.display = 'none';\n\t\t} else {\n\t\t\tthis.domNode.style.display = 'block';\n\t\t}\n\t}\n\n\tstatic computeStickyHeight(entry: OutlineEntry) {\n\t\tlet height = 0;\n\t\tif (entry.cell.cellKind === CellKind.Markup && entry.level < 7) {\n\t\t\theight += 22;\n\t\t}\n\t\twhile (entry.parent) {\n\t\t\theight += 22;\n\t\t\tentry = entry.parent;\n\t\t}\n\t\treturn height;\n\t}\n\n\tstatic checkCollapsedStickyLines(entry: OutlineEntry | undefined, numLinesToRender: number, notebookEditor: INotebookEditor) {\n\t\tlet currentEntry = entry;\n\t\tconst newMap = new Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>();\n\n\t\tconst elementsToRender = [];\n\t\twhile (currentEntry) {\n\t\t\tif (currentEntry.level >= 7) {\n\t\t\t\t// level 7+ represents a non-header entry, which we don't want to render\n\t\t\t\tcurrentEntry = currentEntry.parent;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst lineToRender = NotebookStickyScroll.createStickyElement(currentEntry, notebookEditor);\n\t\t\tnewMap.set(currentEntry, { line: lineToRender, rendered: false });\n\t\t\telementsToRender.unshift(lineToRender);\n\t\t\tcurrentEntry = currentEntry.parent;\n\t\t}\n\n\t\t// iterate over elements to render, and append to container\n\t\t// break when we reach numLinesToRender\n\t\tfor (let i = 0; i < elementsToRender.length; i++) {\n\t\t\tif (i >= numLinesToRender) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnewMap.set(elementsToRender[i].entry, { line: elementsToRender[i], rendered: true });\n\t\t}\n\t\treturn newMap;\n\t}\n\n\tprivate renderStickyLines(stickyMap: Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }>, containerElement: HTMLElement) {\n\t\tconst reversedEntries = Array.from(stickyMap.entries()).reverse();\n\t\tfor (const [, value] of reversedEntries) {\n\t\t\tif (!value.rendered) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcontainerElement.append(value.line.element);\n\t\t}\n\t}\n\n\tstatic createStickyElement(entry: OutlineEntry, notebookEditor: INotebookEditor) {\n\t\tconst stickyElement = document.createElement('div');\n\t\tstickyElement.classList.add('notebook-sticky-scroll-element');\n\n\t\tconst indentMode = notebookEditor.notebookOptions.getLayoutConfiguration().stickyScrollMode;\n\t\tif (indentMode === 'indented') {\n\t\t\tstickyElement.style.paddingLeft = NotebookStickyLine.getParentCount(entry) * 10 + 'px';\n\t\t}\n\n\t\tlet isCollapsed = false;\n\t\tif (entry.cell.cellKind === CellKind.Markup) {\n\t\t\tisCollapsed = (entry.cell as MarkupCellViewModel).foldingState === CellFoldingState.Collapsed;\n\t\t}\n\n\t\tconst stickyFoldingIcon = new StickyFoldingIcon(isCollapsed, 16);\n\t\tstickyFoldingIcon.domNode.classList.add('notebook-sticky-scroll-folding-icon');\n\t\tstickyFoldingIcon.setVisible(true);\n\n\t\tconst stickyHeader = document.createElement('div');\n\t\tstickyHeader.classList.add('notebook-sticky-scroll-header');\n\t\tstickyHeader.innerText = entry.label;\n\n\t\tstickyElement.append(stickyFoldingIcon.domNode, stickyHeader);\n\n\t\treturn new NotebookStickyLine(stickyElement, stickyFoldingIcon, stickyHeader, entry, notebookEditor);\n\t}\n\n\tprivate disposeCurrentStickyLines() {\n\t\tthis.currentStickyLines.forEach((value) => {\n\t\t\tvalue.line.dispose();\n\t\t});\n\t}\n\n\toverride dispose() {\n\t\tthis._disposables.dispose();\n\t\tthis.disposeCurrentStickyLines();\n\t\tthis.notebookCellOutlineReference?.dispose();\n\t\tsuper.dispose();\n\t}\n}\n\nexport function computeContent(notebookEditor: INotebookEditor, notebookCellList: INotebookCellList, notebookOutlineEntries: OutlineEntry[], renderedStickyHeight: number): Map<OutlineEntry, { line: NotebookStickyLine; rendered: boolean }> {\n\t// get data about the cell list within viewport ----------------------------------------------------------------------------------------\n\tconst editorScrollTop = notebookEditor.scrollTop - renderedStickyHeight;\n\tconst visibleRange = notebookEditor.visibleRanges[0];\n\tif (!visibleRange) {\n\t\treturn new Map();\n\t}\n\n\t// edge case for cell 0 in the notebook is a header ------------------------------------------------------------------------------------\n\tif (visibleRange.start === 0) {\n\t\tconst firstCell = notebookEditor.cellAt(0);\n\t\tconst firstCellEntry = NotebookStickyScroll.getVisibleOutlineEntry(0, notebookOutlineEntries);\n\t\tif (firstCell && firstCellEntry && firstCell.cellKind === CellKind.Markup && firstCellEntry.level < 7) {\n\t\t\tif (notebookEditor.scrollTop > 22) {\n\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(firstCellEntry, 100, notebookEditor);\n\t\t\t\treturn newMap;\n\t\t\t}\n\t\t}\n\t}\n\n\t// iterate over cells in viewport ------------------------------------------------------------------------------------------------------\n\tlet cell;\n\tlet cellEntry;\n\tconst startIndex = visibleRange.start - 1; // -1 to account for cells hidden \"under\" sticky lines.\n\tfor (let currentIndex = startIndex; currentIndex < visibleRange.end; currentIndex++) {\n\t\t// store data for current cell, and next cell\n\t\tcell = notebookEditor.cellAt(currentIndex);\n\t\tif (!cell) {\n\t\t\treturn new Map();\n\t\t}\n\t\tcellEntry = NotebookStickyScroll.getVisibleOutlineEntry(currentIndex, notebookOutlineEntries);\n\t\tif (!cellEntry) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst nextCell = notebookEditor.cellAt(currentIndex + 1);\n\t\tif (!nextCell) {\n\t\t\tconst sectionBottom = notebookEditor.getLayoutInfo().scrollHeight;\n\t\t\tconst linesToRender = Math.floor((sectionBottom) / 22);\n\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\t\t\treturn newMap;\n\t\t}\n\t\tconst nextCellEntry = NotebookStickyScroll.getVisibleOutlineEntry(currentIndex + 1, notebookOutlineEntries);\n\t\tif (!nextCellEntry) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// check next cell, if markdown with non level 7 entry, that means this is the end of the section (new header) ---------------------\n\t\tif (nextCell.cellKind === CellKind.Markup && nextCellEntry.level < 7) {\n\t\t\tconst sectionBottom = notebookCellList.getCellViewScrollTop(nextCell);\n\t\t\tconst currentSectionStickyHeight = NotebookStickyScroll.computeStickyHeight(cellEntry);\n\t\t\tconst nextSectionStickyHeight = NotebookStickyScroll.computeStickyHeight(nextCellEntry);\n\n\t\t\t// case: we can render the all sticky lines for the current section ------------------------------------------------------------\n\t\t\tif (editorScrollTop + currentSectionStickyHeight < sectionBottom) {\n\t\t\t\tconst linesToRender = Math.floor((sectionBottom - editorScrollTop) / 22);\n\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\t\t\t\treturn newMap;\n\t\t\t}\n\n\t\t\t// case: next section is the same size or bigger, render next entry -----------------------------------------------------------\n\t\t\telse if (nextSectionStickyHeight >= currentSectionStickyHeight) {\n\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(nextCellEntry, 100, notebookEditor);\n\t\t\t\treturn newMap;\n\t\t\t}\n\t\t\t// case: next section is the smaller, shrink until next section height is greater than the available space ---------------------\n\t\t\telse if (nextSectionStickyHeight < currentSectionStickyHeight) {\n\t\t\t\tconst availableSpace = sectionBottom - editorScrollTop;\n\n\t\t\t\tif (availableSpace >= nextSectionStickyHeight) {\n\t\t\t\t\tconst linesToRender = Math.floor((availableSpace) / 22);\n\t\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\t\t\t\t\treturn newMap;\n\t\t\t\t} else {\n\t\t\t\t\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(nextCellEntry, 100, notebookEditor);\n\t\t\t\t\treturn newMap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} // visible range loop close\n\n\t// case: all visible cells were non-header cells, so render any headers relevant to their section --------------------------------------\n\tconst sectionBottom = notebookEditor.getLayoutInfo().scrollHeight;\n\tconst linesToRender = Math.floor((sectionBottom - editorScrollTop) / 22);\n\tconst newMap = NotebookStickyScroll.checkCollapsedStickyLines(cellEntry, linesToRender, notebookEditor);\n\treturn newMap;\n}\n"]}