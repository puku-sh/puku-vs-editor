{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/welcomeWalkthrough/common/walkThroughContentProvider.ts","vs/workbench/contrib/welcomeWalkthrough/common/walkThroughContentProvider.ts"],"names":[],"mappings":"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","file":"walkThroughContentProvider.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { ITextModelService, ITextModelContentProvider } from '../../../../editor/common/services/resolverService.js';\nimport { IModelService } from '../../../../editor/common/services/model.js';\nimport { ITextModel, DefaultEndOfLine, EndOfLinePreference, ITextBufferFactory } from '../../../../editor/common/model.js';\nimport { ILanguageService } from '../../../../editor/common/languages/language.js';\nimport { IWorkbenchContribution } from '../../../common/contributions.js';\nimport * as marked from '../../../../base/common/marked/marked.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { Range } from '../../../../editor/common/core/range.js';\nimport { createTextBufferFactory } from '../../../../editor/common/model/textModel.js';\nimport { assertReturnsDefined } from '../../../../base/common/types.js';\nimport { IInstantiationService, ServicesAccessor } from '../../../../platform/instantiation/common/instantiation.js';\n\ninterface IWalkThroughContentProvider {\n\t(accessor: ServicesAccessor): string;\n}\n\nclass WalkThroughContentProviderRegistry {\n\n\tprivate readonly providers = new Map<string, IWalkThroughContentProvider>();\n\n\tregisterProvider(moduleId: string, provider: IWalkThroughContentProvider): void {\n\t\tthis.providers.set(moduleId, provider);\n\t}\n\n\tgetProvider(moduleId: string): IWalkThroughContentProvider | undefined {\n\t\treturn this.providers.get(moduleId);\n\t}\n}\nexport const walkThroughContentRegistry = new WalkThroughContentProviderRegistry();\n\nexport async function moduleToContent(instantiationService: IInstantiationService, resource: URI): Promise<string> {\n\tif (!resource.query) {\n\t\tthrow new Error('Walkthrough: invalid resource');\n\t}\n\n\tconst query = JSON.parse(resource.query);\n\tif (!query.moduleId) {\n\t\tthrow new Error('Walkthrough: invalid resource');\n\t}\n\n\tconst provider = walkThroughContentRegistry.getProvider(query.moduleId);\n\tif (!provider) {\n\t\tthrow new Error(`Walkthrough: no provider registered for ${query.moduleId}`);\n\t}\n\n\treturn instantiationService.invokeFunction(provider);\n}\n\nexport class WalkThroughSnippetContentProvider implements ITextModelContentProvider, IWorkbenchContribution {\n\n\tstatic readonly ID = 'workbench.contrib.walkThroughSnippetContentProvider';\n\n\tprivate loads = new Map<string, Promise<ITextBufferFactory>>();\n\n\tconstructor(\n\t\t@ITextModelService private readonly textModelResolverService: ITextModelService,\n\t\t@ILanguageService private readonly languageService: ILanguageService,\n\t\t@IModelService private readonly modelService: IModelService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t) {\n\t\tthis.textModelResolverService.registerTextModelContentProvider(Schemas.walkThroughSnippet, this);\n\t}\n\n\tprivate async textBufferFactoryFromResource(resource: URI): Promise<ITextBufferFactory> {\n\t\tlet ongoing = this.loads.get(resource.toString());\n\t\tif (!ongoing) {\n\t\t\tongoing = moduleToContent(this.instantiationService, resource)\n\t\t\t\t.then(content => createTextBufferFactory(content))\n\t\t\t\t.finally(() => this.loads.delete(resource.toString()));\n\t\t\tthis.loads.set(resource.toString(), ongoing);\n\t\t}\n\t\treturn ongoing;\n\t}\n\n\tpublic async provideTextContent(resource: URI): Promise<ITextModel> {\n\t\tconst factory = await this.textBufferFactoryFromResource(resource.with({ fragment: '' }));\n\t\tlet codeEditorModel = this.modelService.getModel(resource);\n\t\tif (!codeEditorModel) {\n\t\t\tconst j = parseInt(resource.fragment);\n\t\t\tlet i = 0;\n\t\t\tconst renderer = new marked.marked.Renderer();\n\t\t\trenderer.code = ({ text, lang }: marked.Tokens.Code) => {\n\t\t\t\ti++;\n\t\t\t\tconst languageId = typeof lang === 'string' ? this.languageService.getLanguageIdByLanguageName(lang) || '' : '';\n\t\t\t\tconst languageSelection = this.languageService.createById(languageId);\n\t\t\t\t// Create all models for this resource in one go... we'll need them all and we don't want to re-parse markdown each time\n\t\t\t\tconst model = this.modelService.createModel(text, languageSelection, resource.with({ fragment: `${i}.${lang}` }));\n\t\t\t\tif (i === j) { codeEditorModel = model; }\n\t\t\t\treturn '';\n\t\t\t};\n\t\t\tconst textBuffer = factory.create(DefaultEndOfLine.LF).textBuffer;\n\t\t\tconst lineCount = textBuffer.getLineCount();\n\t\t\tconst range = new Range(1, 1, lineCount, textBuffer.getLineLength(lineCount) + 1);\n\t\t\tconst markdown = textBuffer.getValueInRange(range, EndOfLinePreference.TextDefined);\n\t\t\tmarked.marked(markdown, { renderer });\n\t\t}\n\t\treturn assertReturnsDefined(codeEditorModel);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { ITextModelService, ITextModelContentProvider } from '../../../../editor/common/services/resolverService.js';\nimport { IModelService } from '../../../../editor/common/services/model.js';\nimport { ITextModel, DefaultEndOfLine, EndOfLinePreference, ITextBufferFactory } from '../../../../editor/common/model.js';\nimport { ILanguageService } from '../../../../editor/common/languages/language.js';\nimport { IWorkbenchContribution } from '../../../common/contributions.js';\nimport * as marked from '../../../../base/common/marked/marked.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { Range } from '../../../../editor/common/core/range.js';\nimport { createTextBufferFactory } from '../../../../editor/common/model/textModel.js';\nimport { assertReturnsDefined } from '../../../../base/common/types.js';\nimport { IInstantiationService, ServicesAccessor } from '../../../../platform/instantiation/common/instantiation.js';\n\ninterface IWalkThroughContentProvider {\n\t(accessor: ServicesAccessor): string;\n}\n\nclass WalkThroughContentProviderRegistry {\n\n\tprivate readonly providers = new Map<string, IWalkThroughContentProvider>();\n\n\tregisterProvider(moduleId: string, provider: IWalkThroughContentProvider): void {\n\t\tthis.providers.set(moduleId, provider);\n\t}\n\n\tgetProvider(moduleId: string): IWalkThroughContentProvider | undefined {\n\t\treturn this.providers.get(moduleId);\n\t}\n}\nexport const walkThroughContentRegistry = new WalkThroughContentProviderRegistry();\n\nexport async function moduleToContent(instantiationService: IInstantiationService, resource: URI): Promise<string> {\n\tif (!resource.query) {\n\t\tthrow new Error('Walkthrough: invalid resource');\n\t}\n\n\tconst query = JSON.parse(resource.query);\n\tif (!query.moduleId) {\n\t\tthrow new Error('Walkthrough: invalid resource');\n\t}\n\n\tconst provider = walkThroughContentRegistry.getProvider(query.moduleId);\n\tif (!provider) {\n\t\tthrow new Error(`Walkthrough: no provider registered for ${query.moduleId}`);\n\t}\n\n\treturn instantiationService.invokeFunction(provider);\n}\n\nexport class WalkThroughSnippetContentProvider implements ITextModelContentProvider, IWorkbenchContribution {\n\n\tstatic readonly ID = 'workbench.contrib.walkThroughSnippetContentProvider';\n\n\tprivate loads = new Map<string, Promise<ITextBufferFactory>>();\n\n\tconstructor(\n\t\t@ITextModelService private readonly textModelResolverService: ITextModelService,\n\t\t@ILanguageService private readonly languageService: ILanguageService,\n\t\t@IModelService private readonly modelService: IModelService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t) {\n\t\tthis.textModelResolverService.registerTextModelContentProvider(Schemas.walkThroughSnippet, this);\n\t}\n\n\tprivate async textBufferFactoryFromResource(resource: URI): Promise<ITextBufferFactory> {\n\t\tlet ongoing = this.loads.get(resource.toString());\n\t\tif (!ongoing) {\n\t\t\tongoing = moduleToContent(this.instantiationService, resource)\n\t\t\t\t.then(content => createTextBufferFactory(content))\n\t\t\t\t.finally(() => this.loads.delete(resource.toString()));\n\t\t\tthis.loads.set(resource.toString(), ongoing);\n\t\t}\n\t\treturn ongoing;\n\t}\n\n\tpublic async provideTextContent(resource: URI): Promise<ITextModel> {\n\t\tconst factory = await this.textBufferFactoryFromResource(resource.with({ fragment: '' }));\n\t\tlet codeEditorModel = this.modelService.getModel(resource);\n\t\tif (!codeEditorModel) {\n\t\t\tconst j = parseInt(resource.fragment);\n\t\t\tlet i = 0;\n\t\t\tconst renderer = new marked.marked.Renderer();\n\t\t\trenderer.code = ({ text, lang }: marked.Tokens.Code) => {\n\t\t\t\ti++;\n\t\t\t\tconst languageId = typeof lang === 'string' ? this.languageService.getLanguageIdByLanguageName(lang) || '' : '';\n\t\t\t\tconst languageSelection = this.languageService.createById(languageId);\n\t\t\t\t// Create all models for this resource in one go... we'll need them all and we don't want to re-parse markdown each time\n\t\t\t\tconst model = this.modelService.createModel(text, languageSelection, resource.with({ fragment: `${i}.${lang}` }));\n\t\t\t\tif (i === j) { codeEditorModel = model; }\n\t\t\t\treturn '';\n\t\t\t};\n\t\t\tconst textBuffer = factory.create(DefaultEndOfLine.LF).textBuffer;\n\t\t\tconst lineCount = textBuffer.getLineCount();\n\t\t\tconst range = new Range(1, 1, lineCount, textBuffer.getLineLength(lineCount) + 1);\n\t\t\tconst markdown = textBuffer.getValueInRange(range, EndOfLinePreference.TextDefined);\n\t\t\tmarked.marked(markdown, { renderer });\n\t\t}\n\t\treturn assertReturnsDefined(codeEditorModel);\n\t}\n}\n"]}