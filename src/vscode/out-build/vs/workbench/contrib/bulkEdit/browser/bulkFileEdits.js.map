{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/bulkEdit/browser/bulkFileEdits.ts","vs/workbench/contrib/bulkEdit/browser/bulkFileEdits.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;AAIhG,OAAO,EAAE,YAAY,EAAuE,MAAM,4CAA4C,CAAC;AAE/I,OAAO,EAAE,qBAAqB,EAAE,MAAM,4DAA4D,CAAC;AACnG,OAAO,EAAE,uBAAuB,EAAwH,MAAM,gEAAgE,CAAC;AAC/N,OAAO,EAAkD,gBAAgB,EAAiC,MAAM,kDAAkD,CAAC;AAEnK,OAAO,EAAE,qBAAqB,EAAE,MAAM,4DAA4D,CAAC;AACnG,OAAO,EAAE,WAAW,EAAE,MAAM,wCAAwC,CAAC;AAGrE,OAAO,EAAE,iBAAiB,EAAE,MAAM,yCAAyC,CAAC;AAC5E,OAAO,EAAE,gBAAgB,EAAE,MAAM,gDAAgD,CAAC;AAClF,OAAO,EAAE,OAAO,EAAE,MAAM,oCAAoC,CAAC;AAO7D,MAAM,IAAI;IAAV;QACU,SAAI,GAAG,EAAE,CAAC;IAKpB,CAAC;IAJA,KAAK,CAAC,OAAO,KAAK,OAAO,IAAI,CAAC,CAAC,CAAC;IAChC,QAAQ;QACP,OAAO,QAAQ,CAAC;IACjB,CAAC;CACD;AAED,MAAM,UAAU;IAEf,YACU,MAAW,EACX,MAAW,EACX,OAAiC;QAFjC,WAAM,GAAN,MAAM,CAAK;QACX,WAAM,GAAN,MAAM,CAAK;QACX,YAAO,GAAP,OAAO,CAA0B;QAJlC,SAAI,GAAG,QAAQ,CAAC;IAKrB,CAAC;CACL;AAED,IAAM,eAAe,uBAArB,MAAM,eAAe;IAEpB,YACkB,MAAoB,EACpB,aAAyC,EAChB,uBAAgD,EAC3D,YAA0B;QAHxC,WAAM,GAAN,MAAM,CAAc;QACpB,kBAAa,GAAb,aAAa,CAA4B;QAChB,4BAAuB,GAAvB,uBAAuB,CAAyB;QAC3D,iBAAY,GAAZ,YAAY,CAAc;IACtD,CAAC;IAEL,IAAI,IAAI;QACP,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IAChE,CAAC;IAED,KAAK,CAAC,OAAO,CAAC,KAAwB;QAErC,MAAM,KAAK,GAAqB,EAAE,CAAC;QACnC,MAAM,MAAM,GAAiB,EAAE,CAAC;QAChC,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAChC,mEAAmE;YACnE,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,KAAK,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,IAAI,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAChI,IAAI,CAAC,IAAI,EAAE,CAAC;gBACX,KAAK,CAAC,IAAI,CAAC;oBACV,IAAI,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE;oBAClD,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS;iBACjC,CAAC,CAAC;gBAEH,eAAe;gBACf,MAAM,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;YACrE,CAAC;QACF,CAAC;QAED,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxB,OAAO,IAAI,IAAI,EAAE,CAAC;QACnB,CAAC;QAED,MAAM,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QAC1E,OAAO,IAAI,iBAAe,CAAC,MAAM,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,EAAE,IAAI,CAAC,uBAAuB,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;IAC1G,CAAC;IAED,QAAQ;QACP,OAAO,WAAW,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;IAC7F,CAAC;CACD,CAAA;AA1CK,eAAe;IAKlB,WAAA,uBAAuB,CAAA;IACvB,WAAA,YAAY,CAAA;GANT,eAAe,CA0CpB;AAED,MAAM,QAAQ;IAEb,YACU,MAAW,EACX,MAAW,EACX,OAAiC;QAFjC,WAAM,GAAN,MAAM,CAAK;QACX,WAAM,GAAN,MAAM,CAAK;QACX,YAAO,GAAP,OAAO,CAA0B;QAJlC,SAAI,GAAG,MAAM,CAAC;IAKnB,CAAC;CACL;AAED,IAAM,aAAa,GAAnB,MAAM,aAAa;IAElB,YACkB,MAAkB,EAClB,aAAyC,EAChB,uBAAgD,EAC3D,YAA0B,EACjB,aAAoC;QAJ3D,WAAM,GAAN,MAAM,CAAY;QAClB,kBAAa,GAAb,aAAa,CAA4B;QAChB,4BAAuB,GAAvB,uBAAuB,CAAyB;QAC3D,iBAAY,GAAZ,YAAY,CAAc;QACjB,kBAAa,GAAb,aAAa,CAAuB;IACzE,CAAC;IAEL,IAAI,IAAI;QACP,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IAChE,CAAC;IAED,KAAK,CAAC,OAAO,CAAC,KAAwB;QAErC,2CAA2C;QAC3C,MAAM,MAAM,GAAqB,EAAE,CAAC;QACpC,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAChC,kEAAkE;YAClE,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,KAAK,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,IAAI,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAChI,IAAI,CAAC,IAAI,EAAE,CAAC;gBACX,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC;YACxG,CAAC;QACF,CAAC;QAED,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACzB,OAAO,IAAI,IAAI,EAAE,CAAC;QACnB,CAAC;QAED,2EAA2E;QAC3E,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QACzF,MAAM,MAAM,GAAiB,EAAE,CAAC;QAEhC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACvC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC,OAAO,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC;QACpJ,CAAC;QAED,OAAO,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,eAAe,EAAE,MAAM,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IACxF,CAAC;IAED,QAAQ;QACP,OAAO,SAAS,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;IAC3F,CAAC;CACD,CAAA;AA9CK,aAAa;IAKhB,WAAA,uBAAuB,CAAA;IACvB,WAAA,YAAY,CAAA;IACZ,WAAA,qBAAqB,CAAA;GAPlB,aAAa,CA8ClB;AAED,MAAM,UAAU;IAEf,YACU,MAAW,EACX,OAAiC,EACjC,QAA8B;QAF9B,WAAM,GAAN,MAAM,CAAK;QACX,YAAO,GAAP,OAAO,CAA0B;QACjC,aAAQ,GAAR,QAAQ,CAAsB;QAJ/B,SAAI,GAAG,QAAQ,CAAC;IAKrB,CAAC;CACL;AAED,IAAM,eAAe,GAArB,MAAM,eAAe;IAEpB,YACkB,MAAoB,EACpB,aAAyC,EAC3B,YAA0B,EACf,uBAAgD,EAClD,aAAoC,EACzC,gBAAkC;QALpD,WAAM,GAAN,MAAM,CAAc;QACpB,kBAAa,GAAb,aAAa,CAA4B;QAC3B,iBAAY,GAAZ,YAAY,CAAc;QACf,4BAAuB,GAAvB,uBAAuB,CAAyB;QAClD,kBAAa,GAAb,aAAa,CAAuB;QACzC,qBAAgB,GAAhB,gBAAgB,CAAkB;IAClE,CAAC;IAEL,IAAI,IAAI;QACP,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC7C,CAAC;IAED,KAAK,CAAC,OAAO,CAAC,KAAwB;QAErC,MAAM,aAAa,GAAuB,EAAE,CAAC;QAC7C,MAAM,WAAW,GAA2B,EAAE,CAAC;QAC/C,MAAM,MAAM,GAAiB,EAAE,CAAC;QAEhC,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAChC,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,OAAO,CAAC,QAAQ,EAAE,CAAC;gBAC7C,SAAS,CAAC,0CAA0C;YACrD,CAAC;YACD,IAAI,IAAI,CAAC,OAAO,CAAC,SAAS,KAAK,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,IAAI,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;gBACxH,SAAS,CAAC,4DAA4D;YACvE,CAAC;YACD,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;gBACzB,aAAa,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;YAC/C,CAAC;iBAAM,CAAC;gBACP,kIAAkI;gBAClI,MAAM,eAAe,GAAG,OAAO,IAAI,CAAC,QAAQ,KAAK,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,gBAAgB,CAAC,kBAAkB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC3I,WAAW,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC;YAC3G,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QAChG,CAAC;QAED,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC5D,OAAO,IAAI,IAAI,EAAE,CAAC;QACnB,CAAC;QAED,MAAM,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAAC,aAAa,EAAE,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QAC1F,MAAM,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QAElF,OAAO,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,eAAe,EAAE,MAAM,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IACxF,CAAC;IAED,QAAQ;QACP,OAAO,WAAW,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,UAAU,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,MAAM,SAAS,IAAI,CAAC,QAAQ,EAAE,UAAU,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;IAC7K,CAAC;CACD,CAAA;AAnDK,eAAe;IAKlB,WAAA,YAAY,CAAA;IACZ,WAAA,uBAAuB,CAAA;IACvB,WAAA,qBAAqB,CAAA;IACrB,WAAA,gBAAgB,CAAA;GARb,eAAe,CAmDpB;AAED,MAAM,UAAU;IAEf,YACU,MAAW,EACX,OAAiC,EACjC,YAAqB;QAFrB,WAAM,GAAN,MAAM,CAAK;QACX,YAAO,GAAP,OAAO,CAA0B;QACjC,iBAAY,GAAZ,YAAY,CAAS;QAJtB,SAAI,GAAG,QAAQ,CAAC;IAKrB,CAAC;CACL;AAED,IAAM,eAAe,GAArB,MAAM,eAAe;IAEpB,YACS,MAAoB,EACX,aAAyC,EAChB,uBAAgD,EAC3D,YAA0B,EACjB,qBAA4C,EAC5C,aAAoC,EAC9C,WAAwB;QAN9C,WAAM,GAAN,MAAM,CAAc;QACX,kBAAa,GAAb,aAAa,CAA4B;QAChB,4BAAuB,GAAvB,uBAAuB,CAAyB;QAC3D,iBAAY,GAAZ,YAAY,CAAc;QACjB,0BAAqB,GAArB,qBAAqB,CAAuB;QAC5C,kBAAa,GAAb,aAAa,CAAuB;QAC9C,gBAAW,GAAX,WAAW,CAAa;IACnD,CAAC;IAEL,IAAI,IAAI;QACP,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC7C,CAAC;IAED,KAAK,CAAC,OAAO,CAAC,KAAwB;QACrC,cAAc;QAEd,MAAM,OAAO,GAAuB,EAAE,CAAC;QACvC,MAAM,MAAM,GAAiB,EAAE,CAAC;QAEhC,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAChC,IAAI,QAA2C,CAAC;YAChD,IAAI,CAAC;gBACJ,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,eAAe,EAAE,IAAI,EAAE,CAAC,CAAC;YACpF,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;gBACd,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,iBAAiB,EAAE,CAAC;oBACrC,MAAM,IAAI,KAAK,CAAC,GAAG,IAAI,CAAC,MAAM,wCAAwC,CAAC,CAAC;gBACzE,CAAC;gBACD,SAAS;YACV,CAAC;YAED,OAAO,CAAC,IAAI,CAAC;gBACZ,QAAQ,EAAE,IAAI,CAAC,MAAM;gBACrB,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS;gBACjC,QAAQ,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,YAAY,IAAI,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,kDAAuC,IAAI,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAU,mBAAmB,CAAC;aAC/L,CAAC,CAAC;YAGH,uFAAuF;YACvF,IAAI,WAAqC,CAAC;YAC1C,IAAI,yBAAyB,GAAG,KAAK,CAAC;YACtC,IAAI,CAAC,IAAI,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;gBAChD,yBAAyB,GAAG,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK,QAAQ,IAAI,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC;gBAC7G,IAAI,CAAC,yBAAyB,EAAE,CAAC;oBAChC,IAAI,CAAC;wBACJ,WAAW,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBAC7D,CAAC;oBAAC,OAAO,GAAG,EAAE,CAAC;wBACd,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBAC7B,CAAC;gBACF,CAAC;YACF,CAAC;YACD,IAAI,CAAC,yBAAyB,EAAE,CAAC;gBAChC,MAAM,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC;YAC5E,CAAC;QACF,CAAC;QAED,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC1B,OAAO,IAAI,IAAI,EAAE,CAAC;QACnB,CAAC;QAED,MAAM,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QAE9E,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACzB,OAAO,IAAI,IAAI,EAAE,CAAC;QACnB,CAAC;QACD,OAAO,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,eAAe,EAAE,MAAM,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IACxF,CAAC;IAED,QAAQ;QACP,OAAO,WAAW,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;IACtE,CAAC;CACD,CAAA;AAzEK,eAAe;IAKlB,WAAA,uBAAuB,CAAA;IACvB,WAAA,YAAY,CAAA;IACZ,WAAA,qBAAqB,CAAA;IACrB,WAAA,qBAAqB,CAAA;IACrB,WAAA,WAAW,CAAA;GATR,eAAe,CAyEpB;AAED,MAAM,mBAAmB;IAMxB,YACU,KAAa,EACb,IAAY,EACZ,UAA4B,EAC5B,iBAA0B;QAH1B,UAAK,GAAL,KAAK,CAAQ;QACb,SAAI,GAAJ,IAAI,CAAQ;QACZ,eAAU,GAAV,UAAU,CAAkB;QAC5B,sBAAiB,GAAjB,iBAAiB,CAAS;QAR3B,SAAI,yCAAiC;QAU7C,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;IACpD,CAAC;IAED,KAAK,CAAC,IAAI;QACT,MAAM,IAAI,CAAC,QAAQ,EAAE,CAAC;IACvB,CAAC;IAED,KAAK,CAAC,IAAI;QACT,MAAM,IAAI,CAAC,QAAQ,EAAE,CAAC;IACvB,CAAC;IAEO,KAAK,CAAC,QAAQ;QACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACjD,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAC9B,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;YACtD,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;QAC3B,CAAC;IACF,CAAC;IAED,QAAQ;QACP,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACzD,CAAC;CACD;AAEM,IAAM,aAAa,GAAnB,MAAM,aAAa;IAEzB,YACkB,MAAc,EACd,KAAa,EACb,cAA6B,EAC7B,eAA2C,EAC3C,kBAA2B,EAC3B,SAA0B,EAC1B,MAAyB,EACzB,MAA0B,EACH,aAAoC,EACzC,gBAAkC;QATpD,WAAM,GAAN,MAAM,CAAQ;QACd,UAAK,GAAL,KAAK,CAAQ;QACb,mBAAc,GAAd,cAAc,CAAe;QAC7B,oBAAe,GAAf,eAAe,CAA4B;QAC3C,uBAAkB,GAAlB,kBAAkB,CAAS;QAC3B,cAAS,GAAT,SAAS,CAAiB;QAC1B,WAAM,GAAN,MAAM,CAAmB;QACzB,WAAM,GAAN,MAAM,CAAoB;QACH,kBAAa,GAAb,aAAa,CAAuB;QACzC,qBAAgB,GAAhB,gBAAgB,CAAkB;IAClE,CAAC;IAEL,KAAK,CAAC,KAAK;QACV,MAAM,cAAc,GAAqB,EAAE,CAAC;QAC5C,MAAM,YAAY,GAAG,EAAE,eAAe,EAAE,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,CAAC;QAEjE,MAAM,KAAK,GAA2D,EAAE,CAAC;QACzE,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAChC,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,CAAC;gBACjE,KAAK,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC,CAAC;YACpF,CAAC;iBAAM,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,CAAC;gBACvE,KAAK,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC,CAAC;YAClF,CAAC;iBAAM,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;gBAClD,KAAK,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,IAAI,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC;YACzE,CAAC;iBAAM,IAAI,IAAI,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;gBAClD,KAAK,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,IAAI,EAAE,EAAE,MAAM,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;YAC/F,CAAC;QACF,CAAC;QAED,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxB,OAAO,EAAE,CAAC;QACX,CAAC;QAED,MAAM,MAAM,GAA6D,EAAE,CAAC;QAC5E,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QAEvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACvC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,SAAS,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YAChC,IAAI,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,EAAE,CAAC;gBACvC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACtB,CAAC;iBAAM,CAAC;gBACP,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACrB,CAAC;QACF,CAAC;QAED,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;YAE5B,IAAI,IAAI,CAAC,MAAM,CAAC,uBAAuB,EAAE,CAAC;gBACzC,MAAM;YACP,CAAC;YAED,IAAI,EAA8B,CAAC;YACnC,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;gBACvB,KAAK,QAAQ;oBACZ,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,eAAe,EAAgB,KAAK,EAAE,YAAY,CAAC,CAAC;oBAC3F,MAAM;gBACP,KAAK,MAAM;oBACV,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,aAAa,EAAc,KAAK,EAAE,YAAY,CAAC,CAAC;oBACvF,MAAM;gBACP,KAAK,QAAQ;oBACZ,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,eAAe,EAAgB,KAAK,EAAE,YAAY,CAAC,CAAC;oBAC3F,MAAM;gBACP,KAAK,QAAQ;oBACZ,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,eAAe,EAAgB,KAAK,EAAE,YAAY,CAAC,CAAC;oBAC3F,MAAM;YACR,CAAC;YAED,IAAI,EAAE,EAAE,CAAC;gBACR,MAAM,MAAM,GAAG,MAAM,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC7C,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC7B,CAAC;YACD,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAClC,CAAC;QAED,MAAM,eAAe,GAAG,IAAI,mBAAmB,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,EAAE,cAAc,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC;QAClH,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,eAAe,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;QAC9F,OAAO,eAAe,CAAC,SAAS,CAAC;IAClC,CAAC;CACD,CAAA;AAlFY,aAAa;IAWvB,WAAA,qBAAqB,CAAA;IACrB,WAAA,gBAAgB,CAAA;GAZN,aAAa,CAkFzB","file":"bulkFileEdits.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nimport { WorkspaceFileEditOptions } from '../../../../editor/common/languages.js';\nimport { IFileService, FileSystemProviderCapabilities, IFileContent, IFileStatWithMetadata } from '../../../../platform/files/common/files.js';\nimport { IProgress } from '../../../../platform/progress/common/progress.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IWorkingCopyFileService, IFileOperationUndoRedoInfo, IMoveOperation, ICopyOperation, IDeleteOperation, ICreateOperation, ICreateFileOperation } from '../../../services/workingCopy/common/workingCopyFileService.js';\nimport { IWorkspaceUndoRedoElement, UndoRedoElementType, IUndoRedoService, UndoRedoGroup, UndoRedoSource } from '../../../../platform/undoRedo/common/undoRedo.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { ResourceFileEdit } from '../../../../editor/browser/services/bulkEditService.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { ITextFileService } from '../../../services/textfile/common/textfiles.js';\nimport { Schemas } from '../../../../base/common/network.js';\n\ninterface IFileOperation {\n\turis: URI[];\n\tperform(token: CancellationToken): Promise<IFileOperation>;\n}\n\nclass Noop implements IFileOperation {\n\treadonly uris = [];\n\tasync perform() { return this; }\n\ttoString(): string {\n\t\treturn '(noop)';\n\t}\n}\n\nclass RenameEdit {\n\treadonly type = 'rename';\n\tconstructor(\n\t\treadonly newUri: URI,\n\t\treadonly oldUri: URI,\n\t\treadonly options: WorkspaceFileEditOptions\n\t) { }\n}\n\nclass RenameOperation implements IFileOperation {\n\n\tconstructor(\n\t\tprivate readonly _edits: RenameEdit[],\n\t\tprivate readonly _undoRedoInfo: IFileOperationUndoRedoInfo,\n\t\t@IWorkingCopyFileService private readonly _workingCopyFileService: IWorkingCopyFileService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t) { }\n\n\tget uris() {\n\t\treturn this._edits.flatMap(edit => [edit.newUri, edit.oldUri]);\n\t}\n\n\tasync perform(token: CancellationToken): Promise<IFileOperation> {\n\n\t\tconst moves: IMoveOperation[] = [];\n\t\tconst undoes: RenameEdit[] = [];\n\t\tfor (const edit of this._edits) {\n\t\t\t// check: not overwriting, but ignoring, and the target file exists\n\t\t\tconst skip = edit.options.overwrite === undefined && edit.options.ignoreIfExists && await this._fileService.exists(edit.newUri);\n\t\t\tif (!skip) {\n\t\t\t\tmoves.push({\n\t\t\t\t\tfile: { source: edit.oldUri, target: edit.newUri },\n\t\t\t\t\toverwrite: edit.options.overwrite\n\t\t\t\t});\n\n\t\t\t\t// reverse edit\n\t\t\t\tundoes.push(new RenameEdit(edit.oldUri, edit.newUri, edit.options));\n\t\t\t}\n\t\t}\n\n\t\tif (moves.length === 0) {\n\t\t\treturn new Noop();\n\t\t}\n\n\t\tawait this._workingCopyFileService.move(moves, token, this._undoRedoInfo);\n\t\treturn new RenameOperation(undoes, { isUndoing: true }, this._workingCopyFileService, this._fileService);\n\t}\n\n\ttoString(): string {\n\t\treturn `(rename ${this._edits.map(edit => `${edit.oldUri} to ${edit.newUri}`).join(', ')})`;\n\t}\n}\n\nclass CopyEdit {\n\treadonly type = 'copy';\n\tconstructor(\n\t\treadonly newUri: URI,\n\t\treadonly oldUri: URI,\n\t\treadonly options: WorkspaceFileEditOptions\n\t) { }\n}\n\nclass CopyOperation implements IFileOperation {\n\n\tconstructor(\n\t\tprivate readonly _edits: CopyEdit[],\n\t\tprivate readonly _undoRedoInfo: IFileOperationUndoRedoInfo,\n\t\t@IWorkingCopyFileService private readonly _workingCopyFileService: IWorkingCopyFileService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@IInstantiationService private readonly _instaService: IInstantiationService\n\t) { }\n\n\tget uris() {\n\t\treturn this._edits.flatMap(edit => [edit.newUri, edit.oldUri]);\n\t}\n\n\tasync perform(token: CancellationToken): Promise<IFileOperation> {\n\n\t\t// (1) create copy operations, remove noops\n\t\tconst copies: ICopyOperation[] = [];\n\t\tfor (const edit of this._edits) {\n\t\t\t//check: not overwriting, but ignoring, and the target file exists\n\t\t\tconst skip = edit.options.overwrite === undefined && edit.options.ignoreIfExists && await this._fileService.exists(edit.newUri);\n\t\t\tif (!skip) {\n\t\t\t\tcopies.push({ file: { source: edit.oldUri, target: edit.newUri }, overwrite: edit.options.overwrite });\n\t\t\t}\n\t\t}\n\n\t\tif (copies.length === 0) {\n\t\t\treturn new Noop();\n\t\t}\n\n\t\t// (2) perform the actual copy and use the return stats to build undo edits\n\t\tconst stats = await this._workingCopyFileService.copy(copies, token, this._undoRedoInfo);\n\t\tconst undoes: DeleteEdit[] = [];\n\n\t\tfor (let i = 0; i < stats.length; i++) {\n\t\t\tconst stat = stats[i];\n\t\t\tconst edit = this._edits[i];\n\t\t\tundoes.push(new DeleteEdit(stat.resource, { recursive: true, folder: this._edits[i].options.folder || stat.isDirectory, ...edit.options }, false));\n\t\t}\n\n\t\treturn this._instaService.createInstance(DeleteOperation, undoes, { isUndoing: true });\n\t}\n\n\ttoString(): string {\n\t\treturn `(copy ${this._edits.map(edit => `${edit.oldUri} to ${edit.newUri}`).join(', ')})`;\n\t}\n}\n\nclass CreateEdit {\n\treadonly type = 'create';\n\tconstructor(\n\t\treadonly newUri: URI,\n\t\treadonly options: WorkspaceFileEditOptions,\n\t\treadonly contents: VSBuffer | undefined,\n\t) { }\n}\n\nclass CreateOperation implements IFileOperation {\n\n\tconstructor(\n\t\tprivate readonly _edits: CreateEdit[],\n\t\tprivate readonly _undoRedoInfo: IFileOperationUndoRedoInfo,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@IWorkingCopyFileService private readonly _workingCopyFileService: IWorkingCopyFileService,\n\t\t@IInstantiationService private readonly _instaService: IInstantiationService,\n\t\t@ITextFileService private readonly _textFileService: ITextFileService\n\t) { }\n\n\tget uris() {\n\t\treturn this._edits.map(edit => edit.newUri);\n\t}\n\n\tasync perform(token: CancellationToken): Promise<IFileOperation> {\n\n\t\tconst folderCreates: ICreateOperation[] = [];\n\t\tconst fileCreates: ICreateFileOperation[] = [];\n\t\tconst undoes: DeleteEdit[] = [];\n\n\t\tfor (const edit of this._edits) {\n\t\t\tif (edit.newUri.scheme === Schemas.untitled) {\n\t\t\t\tcontinue; // ignore, will be handled by a later edit\n\t\t\t}\n\t\t\tif (edit.options.overwrite === undefined && edit.options.ignoreIfExists && await this._fileService.exists(edit.newUri)) {\n\t\t\t\tcontinue; // not overwriting, but ignoring, and the target file exists\n\t\t\t}\n\t\t\tif (edit.options.folder) {\n\t\t\t\tfolderCreates.push({ resource: edit.newUri });\n\t\t\t} else {\n\t\t\t\t// If the contents are part of the edit they include the encoding, thus use them. Otherwise get the encoding for a new empty file.\n\t\t\t\tconst encodedReadable = typeof edit.contents !== 'undefined' ? edit.contents : await this._textFileService.getEncodedReadable(edit.newUri);\n\t\t\t\tfileCreates.push({ resource: edit.newUri, contents: encodedReadable, overwrite: edit.options.overwrite });\n\t\t\t}\n\t\t\tundoes.push(new DeleteEdit(edit.newUri, edit.options, !edit.options.folder && !edit.contents));\n\t\t}\n\n\t\tif (folderCreates.length === 0 && fileCreates.length === 0) {\n\t\t\treturn new Noop();\n\t\t}\n\n\t\tawait this._workingCopyFileService.createFolder(folderCreates, token, this._undoRedoInfo);\n\t\tawait this._workingCopyFileService.create(fileCreates, token, this._undoRedoInfo);\n\n\t\treturn this._instaService.createInstance(DeleteOperation, undoes, { isUndoing: true });\n\t}\n\n\ttoString(): string {\n\t\treturn `(create ${this._edits.map(edit => edit.options.folder ? `folder ${edit.newUri}` : `file ${edit.newUri} with ${edit.contents?.byteLength || 0} bytes`).join(', ')})`;\n\t}\n}\n\nclass DeleteEdit {\n\treadonly type = 'delete';\n\tconstructor(\n\t\treadonly oldUri: URI,\n\t\treadonly options: WorkspaceFileEditOptions,\n\t\treadonly undoesCreate: boolean,\n\t) { }\n}\n\nclass DeleteOperation implements IFileOperation {\n\n\tconstructor(\n\t\tprivate _edits: DeleteEdit[],\n\t\tprivate readonly _undoRedoInfo: IFileOperationUndoRedoInfo,\n\t\t@IWorkingCopyFileService private readonly _workingCopyFileService: IWorkingCopyFileService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IInstantiationService private readonly _instaService: IInstantiationService,\n\t\t@ILogService private readonly _logService: ILogService\n\t) { }\n\n\tget uris() {\n\t\treturn this._edits.map(edit => edit.oldUri);\n\t}\n\n\tasync perform(token: CancellationToken): Promise<IFileOperation> {\n\t\t// delete file\n\n\t\tconst deletes: IDeleteOperation[] = [];\n\t\tconst undoes: CreateEdit[] = [];\n\n\t\tfor (const edit of this._edits) {\n\t\t\tlet fileStat: IFileStatWithMetadata | undefined;\n\t\t\ttry {\n\t\t\t\tfileStat = await this._fileService.resolve(edit.oldUri, { resolveMetadata: true });\n\t\t\t} catch (err) {\n\t\t\t\tif (!edit.options.ignoreIfNotExists) {\n\t\t\t\t\tthrow new Error(`${edit.oldUri} does not exist and can not be deleted`);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdeletes.push({\n\t\t\t\tresource: edit.oldUri,\n\t\t\t\trecursive: edit.options.recursive,\n\t\t\t\tuseTrash: !edit.options.skipTrashBin && this._fileService.hasCapability(edit.oldUri, FileSystemProviderCapabilities.Trash) && this._configurationService.getValue<boolean>('files.enableTrash')\n\t\t\t});\n\n\n\t\t\t// read file contents for undo operation. when a file is too large it won't be restored\n\t\t\tlet fileContent: IFileContent | undefined;\n\t\t\tlet fileContentExceedsMaxSize = false;\n\t\t\tif (!edit.undoesCreate && !edit.options.folder) {\n\t\t\t\tfileContentExceedsMaxSize = typeof edit.options.maxSize === 'number' && fileStat.size > edit.options.maxSize;\n\t\t\t\tif (!fileContentExceedsMaxSize) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfileContent = await this._fileService.readFile(edit.oldUri);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tthis._logService.error(err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!fileContentExceedsMaxSize) {\n\t\t\t\tundoes.push(new CreateEdit(edit.oldUri, edit.options, fileContent?.value));\n\t\t\t}\n\t\t}\n\n\t\tif (deletes.length === 0) {\n\t\t\treturn new Noop();\n\t\t}\n\n\t\tawait this._workingCopyFileService.delete(deletes, token, this._undoRedoInfo);\n\n\t\tif (undoes.length === 0) {\n\t\t\treturn new Noop();\n\t\t}\n\t\treturn this._instaService.createInstance(CreateOperation, undoes, { isUndoing: true });\n\t}\n\n\ttoString(): string {\n\t\treturn `(delete ${this._edits.map(edit => edit.oldUri).join(', ')})`;\n\t}\n}\n\nclass FileUndoRedoElement implements IWorkspaceUndoRedoElement {\n\n\treadonly type = UndoRedoElementType.Workspace;\n\n\treadonly resources: readonly URI[];\n\n\tconstructor(\n\t\treadonly label: string,\n\t\treadonly code: string,\n\t\treadonly operations: IFileOperation[],\n\t\treadonly confirmBeforeUndo: boolean\n\t) {\n\t\tthis.resources = operations.flatMap(op => op.uris);\n\t}\n\n\tasync undo(): Promise<void> {\n\t\tawait this._reverse();\n\t}\n\n\tasync redo(): Promise<void> {\n\t\tawait this._reverse();\n\t}\n\n\tprivate async _reverse() {\n\t\tfor (let i = 0; i < this.operations.length; i++) {\n\t\t\tconst op = this.operations[i];\n\t\t\tconst undo = await op.perform(CancellationToken.None);\n\t\t\tthis.operations[i] = undo;\n\t\t}\n\t}\n\n\ttoString(): string {\n\t\treturn this.operations.map(op => String(op)).join(', ');\n\t}\n}\n\nexport class BulkFileEdits {\n\n\tconstructor(\n\t\tprivate readonly _label: string,\n\t\tprivate readonly _code: string,\n\t\tprivate readonly _undoRedoGroup: UndoRedoGroup,\n\t\tprivate readonly _undoRedoSource: UndoRedoSource | undefined,\n\t\tprivate readonly _confirmBeforeUndo: boolean,\n\t\tprivate readonly _progress: IProgress<void>,\n\t\tprivate readonly _token: CancellationToken,\n\t\tprivate readonly _edits: ResourceFileEdit[],\n\t\t@IInstantiationService private readonly _instaService: IInstantiationService,\n\t\t@IUndoRedoService private readonly _undoRedoService: IUndoRedoService,\n\t) { }\n\n\tasync apply(): Promise<readonly URI[]> {\n\t\tconst undoOperations: IFileOperation[] = [];\n\t\tconst undoRedoInfo = { undoRedoGroupId: this._undoRedoGroup.id };\n\n\t\tconst edits: Array<RenameEdit | CopyEdit | DeleteEdit | CreateEdit> = [];\n\t\tfor (const edit of this._edits) {\n\t\t\tif (edit.newResource && edit.oldResource && !edit.options?.copy) {\n\t\t\t\tedits.push(new RenameEdit(edit.newResource, edit.oldResource, edit.options ?? {}));\n\t\t\t} else if (edit.newResource && edit.oldResource && edit.options?.copy) {\n\t\t\t\tedits.push(new CopyEdit(edit.newResource, edit.oldResource, edit.options ?? {}));\n\t\t\t} else if (!edit.newResource && edit.oldResource) {\n\t\t\t\tedits.push(new DeleteEdit(edit.oldResource, edit.options ?? {}, false));\n\t\t\t} else if (edit.newResource && !edit.oldResource) {\n\t\t\t\tedits.push(new CreateEdit(edit.newResource, edit.options ?? {}, await edit.options.contents));\n\t\t\t}\n\t\t}\n\n\t\tif (edits.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst groups: Array<RenameEdit | CopyEdit | DeleteEdit | CreateEdit>[] = [];\n\t\tgroups[0] = [edits[0]];\n\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tconst edit = edits[i];\n\t\t\tconst lastGroup = groups.at(-1);\n\t\t\tif (lastGroup?.[0].type === edit.type) {\n\t\t\t\tlastGroup.push(edit);\n\t\t\t} else {\n\t\t\t\tgroups.push([edit]);\n\t\t\t}\n\t\t}\n\n\t\tfor (const group of groups) {\n\n\t\t\tif (this._token.isCancellationRequested) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet op: IFileOperation | undefined;\n\t\t\tswitch (group[0].type) {\n\t\t\t\tcase 'rename':\n\t\t\t\t\top = this._instaService.createInstance(RenameOperation, <RenameEdit[]>group, undoRedoInfo);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'copy':\n\t\t\t\t\top = this._instaService.createInstance(CopyOperation, <CopyEdit[]>group, undoRedoInfo);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'delete':\n\t\t\t\t\top = this._instaService.createInstance(DeleteOperation, <DeleteEdit[]>group, undoRedoInfo);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'create':\n\t\t\t\t\top = this._instaService.createInstance(CreateOperation, <CreateEdit[]>group, undoRedoInfo);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (op) {\n\t\t\t\tconst undoOp = await op.perform(this._token);\n\t\t\t\tundoOperations.push(undoOp);\n\t\t\t}\n\t\t\tthis._progress.report(undefined);\n\t\t}\n\n\t\tconst undoRedoElement = new FileUndoRedoElement(this._label, this._code, undoOperations, this._confirmBeforeUndo);\n\t\tthis._undoRedoService.pushElement(undoRedoElement, this._undoRedoGroup, this._undoRedoSource);\n\t\treturn undoRedoElement.resources;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nimport { WorkspaceFileEditOptions } from '../../../../editor/common/languages.js';\nimport { IFileService, FileSystemProviderCapabilities, IFileContent, IFileStatWithMetadata } from '../../../../platform/files/common/files.js';\nimport { IProgress } from '../../../../platform/progress/common/progress.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IWorkingCopyFileService, IFileOperationUndoRedoInfo, IMoveOperation, ICopyOperation, IDeleteOperation, ICreateOperation, ICreateFileOperation } from '../../../services/workingCopy/common/workingCopyFileService.js';\nimport { IWorkspaceUndoRedoElement, UndoRedoElementType, IUndoRedoService, UndoRedoGroup, UndoRedoSource } from '../../../../platform/undoRedo/common/undoRedo.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { ResourceFileEdit } from '../../../../editor/browser/services/bulkEditService.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { ITextFileService } from '../../../services/textfile/common/textfiles.js';\nimport { Schemas } from '../../../../base/common/network.js';\n\ninterface IFileOperation {\n\turis: URI[];\n\tperform(token: CancellationToken): Promise<IFileOperation>;\n}\n\nclass Noop implements IFileOperation {\n\treadonly uris = [];\n\tasync perform() { return this; }\n\ttoString(): string {\n\t\treturn '(noop)';\n\t}\n}\n\nclass RenameEdit {\n\treadonly type = 'rename';\n\tconstructor(\n\t\treadonly newUri: URI,\n\t\treadonly oldUri: URI,\n\t\treadonly options: WorkspaceFileEditOptions\n\t) { }\n}\n\nclass RenameOperation implements IFileOperation {\n\n\tconstructor(\n\t\tprivate readonly _edits: RenameEdit[],\n\t\tprivate readonly _undoRedoInfo: IFileOperationUndoRedoInfo,\n\t\t@IWorkingCopyFileService private readonly _workingCopyFileService: IWorkingCopyFileService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t) { }\n\n\tget uris() {\n\t\treturn this._edits.flatMap(edit => [edit.newUri, edit.oldUri]);\n\t}\n\n\tasync perform(token: CancellationToken): Promise<IFileOperation> {\n\n\t\tconst moves: IMoveOperation[] = [];\n\t\tconst undoes: RenameEdit[] = [];\n\t\tfor (const edit of this._edits) {\n\t\t\t// check: not overwriting, but ignoring, and the target file exists\n\t\t\tconst skip = edit.options.overwrite === undefined && edit.options.ignoreIfExists && await this._fileService.exists(edit.newUri);\n\t\t\tif (!skip) {\n\t\t\t\tmoves.push({\n\t\t\t\t\tfile: { source: edit.oldUri, target: edit.newUri },\n\t\t\t\t\toverwrite: edit.options.overwrite\n\t\t\t\t});\n\n\t\t\t\t// reverse edit\n\t\t\t\tundoes.push(new RenameEdit(edit.oldUri, edit.newUri, edit.options));\n\t\t\t}\n\t\t}\n\n\t\tif (moves.length === 0) {\n\t\t\treturn new Noop();\n\t\t}\n\n\t\tawait this._workingCopyFileService.move(moves, token, this._undoRedoInfo);\n\t\treturn new RenameOperation(undoes, { isUndoing: true }, this._workingCopyFileService, this._fileService);\n\t}\n\n\ttoString(): string {\n\t\treturn `(rename ${this._edits.map(edit => `${edit.oldUri} to ${edit.newUri}`).join(', ')})`;\n\t}\n}\n\nclass CopyEdit {\n\treadonly type = 'copy';\n\tconstructor(\n\t\treadonly newUri: URI,\n\t\treadonly oldUri: URI,\n\t\treadonly options: WorkspaceFileEditOptions\n\t) { }\n}\n\nclass CopyOperation implements IFileOperation {\n\n\tconstructor(\n\t\tprivate readonly _edits: CopyEdit[],\n\t\tprivate readonly _undoRedoInfo: IFileOperationUndoRedoInfo,\n\t\t@IWorkingCopyFileService private readonly _workingCopyFileService: IWorkingCopyFileService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@IInstantiationService private readonly _instaService: IInstantiationService\n\t) { }\n\n\tget uris() {\n\t\treturn this._edits.flatMap(edit => [edit.newUri, edit.oldUri]);\n\t}\n\n\tasync perform(token: CancellationToken): Promise<IFileOperation> {\n\n\t\t// (1) create copy operations, remove noops\n\t\tconst copies: ICopyOperation[] = [];\n\t\tfor (const edit of this._edits) {\n\t\t\t//check: not overwriting, but ignoring, and the target file exists\n\t\t\tconst skip = edit.options.overwrite === undefined && edit.options.ignoreIfExists && await this._fileService.exists(edit.newUri);\n\t\t\tif (!skip) {\n\t\t\t\tcopies.push({ file: { source: edit.oldUri, target: edit.newUri }, overwrite: edit.options.overwrite });\n\t\t\t}\n\t\t}\n\n\t\tif (copies.length === 0) {\n\t\t\treturn new Noop();\n\t\t}\n\n\t\t// (2) perform the actual copy and use the return stats to build undo edits\n\t\tconst stats = await this._workingCopyFileService.copy(copies, token, this._undoRedoInfo);\n\t\tconst undoes: DeleteEdit[] = [];\n\n\t\tfor (let i = 0; i < stats.length; i++) {\n\t\t\tconst stat = stats[i];\n\t\t\tconst edit = this._edits[i];\n\t\t\tundoes.push(new DeleteEdit(stat.resource, { recursive: true, folder: this._edits[i].options.folder || stat.isDirectory, ...edit.options }, false));\n\t\t}\n\n\t\treturn this._instaService.createInstance(DeleteOperation, undoes, { isUndoing: true });\n\t}\n\n\ttoString(): string {\n\t\treturn `(copy ${this._edits.map(edit => `${edit.oldUri} to ${edit.newUri}`).join(', ')})`;\n\t}\n}\n\nclass CreateEdit {\n\treadonly type = 'create';\n\tconstructor(\n\t\treadonly newUri: URI,\n\t\treadonly options: WorkspaceFileEditOptions,\n\t\treadonly contents: VSBuffer | undefined,\n\t) { }\n}\n\nclass CreateOperation implements IFileOperation {\n\n\tconstructor(\n\t\tprivate readonly _edits: CreateEdit[],\n\t\tprivate readonly _undoRedoInfo: IFileOperationUndoRedoInfo,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@IWorkingCopyFileService private readonly _workingCopyFileService: IWorkingCopyFileService,\n\t\t@IInstantiationService private readonly _instaService: IInstantiationService,\n\t\t@ITextFileService private readonly _textFileService: ITextFileService\n\t) { }\n\n\tget uris() {\n\t\treturn this._edits.map(edit => edit.newUri);\n\t}\n\n\tasync perform(token: CancellationToken): Promise<IFileOperation> {\n\n\t\tconst folderCreates: ICreateOperation[] = [];\n\t\tconst fileCreates: ICreateFileOperation[] = [];\n\t\tconst undoes: DeleteEdit[] = [];\n\n\t\tfor (const edit of this._edits) {\n\t\t\tif (edit.newUri.scheme === Schemas.untitled) {\n\t\t\t\tcontinue; // ignore, will be handled by a later edit\n\t\t\t}\n\t\t\tif (edit.options.overwrite === undefined && edit.options.ignoreIfExists && await this._fileService.exists(edit.newUri)) {\n\t\t\t\tcontinue; // not overwriting, but ignoring, and the target file exists\n\t\t\t}\n\t\t\tif (edit.options.folder) {\n\t\t\t\tfolderCreates.push({ resource: edit.newUri });\n\t\t\t} else {\n\t\t\t\t// If the contents are part of the edit they include the encoding, thus use them. Otherwise get the encoding for a new empty file.\n\t\t\t\tconst encodedReadable = typeof edit.contents !== 'undefined' ? edit.contents : await this._textFileService.getEncodedReadable(edit.newUri);\n\t\t\t\tfileCreates.push({ resource: edit.newUri, contents: encodedReadable, overwrite: edit.options.overwrite });\n\t\t\t}\n\t\t\tundoes.push(new DeleteEdit(edit.newUri, edit.options, !edit.options.folder && !edit.contents));\n\t\t}\n\n\t\tif (folderCreates.length === 0 && fileCreates.length === 0) {\n\t\t\treturn new Noop();\n\t\t}\n\n\t\tawait this._workingCopyFileService.createFolder(folderCreates, token, this._undoRedoInfo);\n\t\tawait this._workingCopyFileService.create(fileCreates, token, this._undoRedoInfo);\n\n\t\treturn this._instaService.createInstance(DeleteOperation, undoes, { isUndoing: true });\n\t}\n\n\ttoString(): string {\n\t\treturn `(create ${this._edits.map(edit => edit.options.folder ? `folder ${edit.newUri}` : `file ${edit.newUri} with ${edit.contents?.byteLength || 0} bytes`).join(', ')})`;\n\t}\n}\n\nclass DeleteEdit {\n\treadonly type = 'delete';\n\tconstructor(\n\t\treadonly oldUri: URI,\n\t\treadonly options: WorkspaceFileEditOptions,\n\t\treadonly undoesCreate: boolean,\n\t) { }\n}\n\nclass DeleteOperation implements IFileOperation {\n\n\tconstructor(\n\t\tprivate _edits: DeleteEdit[],\n\t\tprivate readonly _undoRedoInfo: IFileOperationUndoRedoInfo,\n\t\t@IWorkingCopyFileService private readonly _workingCopyFileService: IWorkingCopyFileService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IInstantiationService private readonly _instaService: IInstantiationService,\n\t\t@ILogService private readonly _logService: ILogService\n\t) { }\n\n\tget uris() {\n\t\treturn this._edits.map(edit => edit.oldUri);\n\t}\n\n\tasync perform(token: CancellationToken): Promise<IFileOperation> {\n\t\t// delete file\n\n\t\tconst deletes: IDeleteOperation[] = [];\n\t\tconst undoes: CreateEdit[] = [];\n\n\t\tfor (const edit of this._edits) {\n\t\t\tlet fileStat: IFileStatWithMetadata | undefined;\n\t\t\ttry {\n\t\t\t\tfileStat = await this._fileService.resolve(edit.oldUri, { resolveMetadata: true });\n\t\t\t} catch (err) {\n\t\t\t\tif (!edit.options.ignoreIfNotExists) {\n\t\t\t\t\tthrow new Error(`${edit.oldUri} does not exist and can not be deleted`);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdeletes.push({\n\t\t\t\tresource: edit.oldUri,\n\t\t\t\trecursive: edit.options.recursive,\n\t\t\t\tuseTrash: !edit.options.skipTrashBin && this._fileService.hasCapability(edit.oldUri, FileSystemProviderCapabilities.Trash) && this._configurationService.getValue<boolean>('files.enableTrash')\n\t\t\t});\n\n\n\t\t\t// read file contents for undo operation. when a file is too large it won't be restored\n\t\t\tlet fileContent: IFileContent | undefined;\n\t\t\tlet fileContentExceedsMaxSize = false;\n\t\t\tif (!edit.undoesCreate && !edit.options.folder) {\n\t\t\t\tfileContentExceedsMaxSize = typeof edit.options.maxSize === 'number' && fileStat.size > edit.options.maxSize;\n\t\t\t\tif (!fileContentExceedsMaxSize) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfileContent = await this._fileService.readFile(edit.oldUri);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tthis._logService.error(err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!fileContentExceedsMaxSize) {\n\t\t\t\tundoes.push(new CreateEdit(edit.oldUri, edit.options, fileContent?.value));\n\t\t\t}\n\t\t}\n\n\t\tif (deletes.length === 0) {\n\t\t\treturn new Noop();\n\t\t}\n\n\t\tawait this._workingCopyFileService.delete(deletes, token, this._undoRedoInfo);\n\n\t\tif (undoes.length === 0) {\n\t\t\treturn new Noop();\n\t\t}\n\t\treturn this._instaService.createInstance(CreateOperation, undoes, { isUndoing: true });\n\t}\n\n\ttoString(): string {\n\t\treturn `(delete ${this._edits.map(edit => edit.oldUri).join(', ')})`;\n\t}\n}\n\nclass FileUndoRedoElement implements IWorkspaceUndoRedoElement {\n\n\treadonly type = UndoRedoElementType.Workspace;\n\n\treadonly resources: readonly URI[];\n\n\tconstructor(\n\t\treadonly label: string,\n\t\treadonly code: string,\n\t\treadonly operations: IFileOperation[],\n\t\treadonly confirmBeforeUndo: boolean\n\t) {\n\t\tthis.resources = operations.flatMap(op => op.uris);\n\t}\n\n\tasync undo(): Promise<void> {\n\t\tawait this._reverse();\n\t}\n\n\tasync redo(): Promise<void> {\n\t\tawait this._reverse();\n\t}\n\n\tprivate async _reverse() {\n\t\tfor (let i = 0; i < this.operations.length; i++) {\n\t\t\tconst op = this.operations[i];\n\t\t\tconst undo = await op.perform(CancellationToken.None);\n\t\t\tthis.operations[i] = undo;\n\t\t}\n\t}\n\n\ttoString(): string {\n\t\treturn this.operations.map(op => String(op)).join(', ');\n\t}\n}\n\nexport class BulkFileEdits {\n\n\tconstructor(\n\t\tprivate readonly _label: string,\n\t\tprivate readonly _code: string,\n\t\tprivate readonly _undoRedoGroup: UndoRedoGroup,\n\t\tprivate readonly _undoRedoSource: UndoRedoSource | undefined,\n\t\tprivate readonly _confirmBeforeUndo: boolean,\n\t\tprivate readonly _progress: IProgress<void>,\n\t\tprivate readonly _token: CancellationToken,\n\t\tprivate readonly _edits: ResourceFileEdit[],\n\t\t@IInstantiationService private readonly _instaService: IInstantiationService,\n\t\t@IUndoRedoService private readonly _undoRedoService: IUndoRedoService,\n\t) { }\n\n\tasync apply(): Promise<readonly URI[]> {\n\t\tconst undoOperations: IFileOperation[] = [];\n\t\tconst undoRedoInfo = { undoRedoGroupId: this._undoRedoGroup.id };\n\n\t\tconst edits: Array<RenameEdit | CopyEdit | DeleteEdit | CreateEdit> = [];\n\t\tfor (const edit of this._edits) {\n\t\t\tif (edit.newResource && edit.oldResource && !edit.options?.copy) {\n\t\t\t\tedits.push(new RenameEdit(edit.newResource, edit.oldResource, edit.options ?? {}));\n\t\t\t} else if (edit.newResource && edit.oldResource && edit.options?.copy) {\n\t\t\t\tedits.push(new CopyEdit(edit.newResource, edit.oldResource, edit.options ?? {}));\n\t\t\t} else if (!edit.newResource && edit.oldResource) {\n\t\t\t\tedits.push(new DeleteEdit(edit.oldResource, edit.options ?? {}, false));\n\t\t\t} else if (edit.newResource && !edit.oldResource) {\n\t\t\t\tedits.push(new CreateEdit(edit.newResource, edit.options ?? {}, await edit.options.contents));\n\t\t\t}\n\t\t}\n\n\t\tif (edits.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst groups: Array<RenameEdit | CopyEdit | DeleteEdit | CreateEdit>[] = [];\n\t\tgroups[0] = [edits[0]];\n\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tconst edit = edits[i];\n\t\t\tconst lastGroup = groups.at(-1);\n\t\t\tif (lastGroup?.[0].type === edit.type) {\n\t\t\t\tlastGroup.push(edit);\n\t\t\t} else {\n\t\t\t\tgroups.push([edit]);\n\t\t\t}\n\t\t}\n\n\t\tfor (const group of groups) {\n\n\t\t\tif (this._token.isCancellationRequested) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet op: IFileOperation | undefined;\n\t\t\tswitch (group[0].type) {\n\t\t\t\tcase 'rename':\n\t\t\t\t\top = this._instaService.createInstance(RenameOperation, <RenameEdit[]>group, undoRedoInfo);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'copy':\n\t\t\t\t\top = this._instaService.createInstance(CopyOperation, <CopyEdit[]>group, undoRedoInfo);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'delete':\n\t\t\t\t\top = this._instaService.createInstance(DeleteOperation, <DeleteEdit[]>group, undoRedoInfo);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'create':\n\t\t\t\t\top = this._instaService.createInstance(CreateOperation, <CreateEdit[]>group, undoRedoInfo);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (op) {\n\t\t\t\tconst undoOp = await op.perform(this._token);\n\t\t\t\tundoOperations.push(undoOp);\n\t\t\t}\n\t\t\tthis._progress.report(undefined);\n\t\t}\n\n\t\tconst undoRedoElement = new FileUndoRedoElement(this._label, this._code, undoOperations, this._confirmBeforeUndo);\n\t\tthis._undoRedoService.pushElement(undoRedoElement, this._undoRedoGroup, this._undoRedoSource);\n\t\treturn undoRedoElement.resources;\n\t}\n}\n"]}