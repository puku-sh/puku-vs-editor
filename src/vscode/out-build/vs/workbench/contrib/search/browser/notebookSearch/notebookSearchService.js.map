{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/search/browser/notebookSearch/notebookSearchService.ts","vs/workbench/contrib/search/browser/notebookSearch/notebookSearchService.ts"],"names":[],"mappings":"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","file":"notebookSearchService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport * as glob from '../../../../../base/common/glob.js';\nimport { ResourceSet, ResourceMap } from '../../../../../base/common/map.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { ILogService } from '../../../../../platform/log/common/log.js';\nimport { IUriIdentityService } from '../../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { NotebookEditorWidget } from '../../../notebook/browser/notebookEditorWidget.js';\nimport { INotebookService } from '../../../notebook/common/notebookService.js';\nimport { INotebookSearchService } from '../../common/notebookSearch.js';\nimport { INotebookCellMatchWithModel, INotebookFileMatchWithModel, contentMatchesToTextSearchMatches, webviewMatchesToTextSearchMatches } from './searchNotebookHelpers.js';\nimport { ITextQuery, QueryType, ISearchProgressItem, ISearchComplete, ISearchConfigurationProperties, pathIncludedInQuery, ISearchService, IFolderQuery, DEFAULT_MAX_SEARCH_RESULTS } from '../../../../services/search/common/search.js';\nimport * as arrays from '../../../../../base/common/arrays.js';\nimport { isNumber } from '../../../../../base/common/types.js';\nimport { IEditorResolverService } from '../../../../services/editor/common/editorResolverService.js';\nimport { INotebookFileMatchNoModel } from '../../common/searchNotebookHelpers.js';\nimport { INotebookEditorService } from '../../../notebook/browser/services/notebookEditorService.js';\nimport { NotebookPriorityInfo } from '../../common/search.js';\nimport { INotebookExclusiveDocumentFilter } from '../../../notebook/common/notebookCommon.js';\nimport { QueryBuilder } from '../../../../services/search/common/queryBuilder.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\n\ninterface IOpenNotebookSearchResults {\n\tresults: ResourceMap<INotebookFileMatchWithModel | null>;\n\tlimitHit: boolean;\n}\ninterface IClosedNotebookSearchResults {\n\tresults: ResourceMap<INotebookFileMatchNoModel<URI> | null>;\n\tlimitHit: boolean;\n}\nexport class NotebookSearchService implements INotebookSearchService {\n\tdeclare readonly _serviceBrand: undefined;\n\tprivate queryBuilder: QueryBuilder;\n\tconstructor(\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@INotebookEditorService private readonly notebookEditorService: INotebookEditorService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@INotebookService private readonly notebookService: INotebookService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IEditorResolverService private readonly editorResolverService: IEditorResolverService,\n\t\t@ISearchService private readonly searchService: ISearchService,\n\t\t@IInstantiationService instantiationService: IInstantiationService\n\t) {\n\t\tthis.queryBuilder = instantiationService.createInstance(QueryBuilder);\n\t}\n\n\tnotebookSearch(query: ITextQuery, token: CancellationToken | undefined, searchInstanceID: string, onProgress?: (result: ISearchProgressItem) => void): {\n\t\topenFilesToScan: ResourceSet;\n\t\tcompleteData: Promise<ISearchComplete>;\n\t\tallScannedFiles: Promise<ResourceSet>;\n\t} {\n\n\t\tif (query.type !== QueryType.Text) {\n\t\t\treturn {\n\t\t\t\topenFilesToScan: new ResourceSet(),\n\t\t\t\tcompleteData: Promise.resolve({\n\t\t\t\t\tmessages: [],\n\t\t\t\t\tlimitHit: false,\n\t\t\t\t\tresults: [],\n\t\t\t\t}),\n\t\t\t\tallScannedFiles: Promise.resolve(new ResourceSet()),\n\t\t\t};\n\t\t}\n\n\t\tconst localNotebookWidgets = this.getLocalNotebookWidgets();\n\t\tconst localNotebookFiles = localNotebookWidgets.map(widget => widget.viewModel!.uri);\n\t\tconst getAllResults = (): { completeData: Promise<ISearchComplete>; allScannedFiles: Promise<ResourceSet> } => {\n\t\t\tconst searchStart = Date.now();\n\n\t\t\tconst localResultPromise = this.getLocalNotebookResults(query, token ?? CancellationToken.None, localNotebookWidgets, searchInstanceID);\n\t\t\tconst searchLocalEnd = Date.now();\n\n\t\t\tconst experimentalNotebooksEnabled = this.configurationService.getValue<ISearchConfigurationProperties>('search').experimental?.closedNotebookRichContentResults ?? false;\n\n\t\t\tlet closedResultsPromise: Promise<IClosedNotebookSearchResults | undefined> = Promise.resolve(undefined);\n\t\t\tif (experimentalNotebooksEnabled) {\n\t\t\t\tclosedResultsPromise = this.getClosedNotebookResults(query, new ResourceSet(localNotebookFiles, uri => this.uriIdentityService.extUri.getComparisonKey(uri)), token ?? CancellationToken.None);\n\t\t\t}\n\n\t\t\tconst promise = Promise.all([localResultPromise, closedResultsPromise]);\n\t\t\treturn {\n\t\t\t\tcompleteData: promise.then((resolvedPromise): ISearchComplete => {\n\t\t\t\t\tconst openNotebookResult = resolvedPromise[0];\n\t\t\t\t\tconst closedNotebookResult = resolvedPromise[1];\n\n\t\t\t\t\tconst resolved = resolvedPromise.filter((e): e is IOpenNotebookSearchResults | IClosedNotebookSearchResults => !!e);\n\t\t\t\t\tconst resultArray = [...openNotebookResult.results.values(), ...closedNotebookResult?.results.values() ?? []];\n\t\t\t\t\tconst results = arrays.coalesce(resultArray);\n\t\t\t\t\tif (onProgress) {\n\t\t\t\t\t\tresults.forEach(onProgress);\n\t\t\t\t\t}\n\t\t\t\t\tthis.logService.trace(`local notebook search time | ${searchLocalEnd - searchStart}ms`);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmessages: [],\n\t\t\t\t\t\tlimitHit: resolved.reduce((prev, cur) => prev || cur.limitHit, false),\n\t\t\t\t\t\tresults,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t\tallScannedFiles: promise.then(resolvedPromise => {\n\t\t\t\t\tconst openNotebookResults = resolvedPromise[0];\n\t\t\t\t\tconst closedNotebookResults = resolvedPromise[1];\n\t\t\t\t\tconst results = arrays.coalesce([...openNotebookResults.results.keys(), ...closedNotebookResults?.results.keys() ?? []]);\n\t\t\t\t\treturn new ResourceSet(results, uri => this.uriIdentityService.extUri.getComparisonKey(uri));\n\t\t\t\t})\n\t\t\t};\n\t\t};\n\t\tconst promiseResults = getAllResults();\n\t\treturn {\n\t\t\topenFilesToScan: new ResourceSet(localNotebookFiles),\n\t\t\tcompleteData: promiseResults.completeData,\n\t\t\tallScannedFiles: promiseResults.allScannedFiles\n\t\t};\n\t}\n\n\tprivate async doesFileExist(includes: string[], folderQueries: IFolderQuery<URI>[], token: CancellationToken): Promise<boolean> {\n\t\tconst promises: Promise<boolean>[] = includes.map(async includePattern => {\n\t\t\tconst query = this.queryBuilder.file(folderQueries.map(e => e.folder), {\n\t\t\t\tincludePattern: includePattern.startsWith('/') ? includePattern : '**/' + includePattern, // todo: find cleaner way to ensure that globs match all appropriate filetypes\n\t\t\t\texists: true,\n\t\t\t\tonlyFileScheme: true,\n\t\t\t});\n\t\t\treturn this.searchService.fileSearch(\n\t\t\t\tquery,\n\t\t\t\ttoken\n\t\t\t).then((ret) => {\n\t\t\t\treturn !!ret.limitHit;\n\t\t\t});\n\t\t});\n\n\t\treturn Promise.any(promises);\n\t}\n\n\tprivate async getClosedNotebookResults(textQuery: ITextQuery, scannedFiles: ResourceSet, token: CancellationToken): Promise<IClosedNotebookSearchResults> {\n\n\t\tconst userAssociations = this.editorResolverService.getAllUserAssociations();\n\t\tconst allPriorityInfo: Map<string, NotebookPriorityInfo[]> = new Map();\n\t\tconst contributedNotebookTypes = this.notebookService.getContributedNotebookTypes();\n\n\n\t\tuserAssociations.forEach(association => {\n\n\t\t\t// we gather the editor associations here, but cannot check them until we actually have the files that the glob matches\n\t\t\t// this is because longer patterns take precedence over shorter ones, and even if there is a user association that\n\t\t\t// specifies the exact same glob as a contributed notebook type, there might be another user association that is longer/more specific\n\t\t\t// that still matches the path and should therefore take more precedence.\n\t\t\tif (!association.filenamePattern) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst info: NotebookPriorityInfo = {\n\t\t\t\tisFromSettings: true,\n\t\t\t\tfilenamePatterns: [association.filenamePattern]\n\t\t\t};\n\n\t\t\tconst existingEntry = allPriorityInfo.get(association.viewType);\n\t\t\tif (existingEntry) {\n\t\t\t\tallPriorityInfo.set(association.viewType, existingEntry.concat(info));\n\t\t\t} else {\n\t\t\t\tallPriorityInfo.set(association.viewType, [info]);\n\t\t\t}\n\t\t});\n\n\t\tconst promises: Promise<{\n\t\t\tresults: INotebookFileMatchNoModel<URI>[];\n\t\t\tlimitHit: boolean;\n\t\t} | undefined>[] = [];\n\n\t\tcontributedNotebookTypes.forEach((notebook) => {\n\t\t\tif (notebook.selectors.length > 0) {\n\t\t\t\tpromises.push((async () => {\n\t\t\t\t\tconst includes = notebook.selectors.map((selector) => {\n\t\t\t\t\t\tconst globPattern = (selector as INotebookExclusiveDocumentFilter).include || selector as glob.IRelativePattern | string;\n\t\t\t\t\t\treturn globPattern.toString();\n\t\t\t\t\t});\n\n\t\t\t\t\tconst isInWorkspace = await this.doesFileExist(includes, textQuery.folderQueries, token);\n\t\t\t\t\tif (isInWorkspace) {\n\t\t\t\t\t\tconst canResolve = await this.notebookService.canResolve(notebook.id);\n\t\t\t\t\t\tif (!canResolve) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst serializer = (await this.notebookService.withNotebookDataProvider(notebook.id)).serializer;\n\t\t\t\t\t\treturn await serializer.searchInNotebooks(textQuery, token, allPriorityInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t})());\n\t\t\t}\n\t\t});\n\n\t\tconst start = Date.now();\n\t\tconst searchComplete = arrays.coalesce(await Promise.all(promises));\n\t\tconst results = searchComplete.flatMap(e => e.results);\n\t\tlet limitHit = searchComplete.some(e => e.limitHit);\n\n\t\t// results are already sorted with high priority first, filter out duplicates.\n\t\tconst uniqueResults = new ResourceMap<INotebookFileMatchNoModel | null>(uri => this.uriIdentityService.extUri.getComparisonKey(uri));\n\n\t\tlet numResults = 0;\n\t\tfor (const result of results) {\n\t\t\tif (textQuery.maxResults && numResults >= textQuery.maxResults) {\n\t\t\t\tlimitHit = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!scannedFiles.has(result.resource) && !uniqueResults.has(result.resource)) {\n\t\t\t\tuniqueResults.set(result.resource, result.cellResults.length > 0 ? result : null);\n\t\t\t\tnumResults++;\n\t\t\t}\n\t\t}\n\n\t\tconst end = Date.now();\n\t\tthis.logService.trace(`query: ${textQuery.contentPattern.pattern}`);\n\t\tthis.logService.trace(`closed notebook search time | ${end - start}ms`);\n\n\t\treturn {\n\t\t\tresults: uniqueResults,\n\t\t\tlimitHit\n\t\t};\n\t}\n\n\tprivate async getLocalNotebookResults(query: ITextQuery, token: CancellationToken, widgets: Array<NotebookEditorWidget>, searchID: string): Promise<IOpenNotebookSearchResults> {\n\t\tconst localResults = new ResourceMap<INotebookFileMatchWithModel | null>(uri => this.uriIdentityService.extUri.getComparisonKey(uri));\n\t\tlet limitHit = false;\n\n\t\tfor (const widget of widgets) {\n\t\t\tif (!widget.hasModel()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst askMax = (isNumber(query.maxResults) ? query.maxResults : DEFAULT_MAX_SEARCH_RESULTS) + 1;\n\t\t\tconst uri = widget.viewModel!.uri;\n\n\t\t\tif (!pathIncludedInQuery(query, uri.fsPath)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet matches = await widget\n\t\t\t\t.find(query.contentPattern.pattern, {\n\t\t\t\t\tregex: query.contentPattern.isRegExp,\n\t\t\t\t\twholeWord: query.contentPattern.isWordMatch,\n\t\t\t\t\tcaseSensitive: query.contentPattern.isCaseSensitive,\n\t\t\t\t\tincludeMarkupInput: query.contentPattern.notebookInfo?.isInNotebookMarkdownInput ?? true,\n\t\t\t\t\tincludeMarkupPreview: query.contentPattern.notebookInfo?.isInNotebookMarkdownPreview ?? true,\n\t\t\t\t\tincludeCodeInput: query.contentPattern.notebookInfo?.isInNotebookCellInput ?? true,\n\t\t\t\t\tincludeOutput: query.contentPattern.notebookInfo?.isInNotebookCellOutput ?? true,\n\t\t\t\t}, token, false, true, searchID);\n\n\n\t\t\tif (matches.length) {\n\t\t\t\tif (askMax && matches.length >= askMax) {\n\t\t\t\t\tlimitHit = true;\n\t\t\t\t\tmatches = matches.slice(0, askMax - 1);\n\t\t\t\t}\n\t\t\t\tconst cellResults: INotebookCellMatchWithModel[] = matches.map(match => {\n\t\t\t\t\tconst contentResults = contentMatchesToTextSearchMatches(match.contentMatches, match.cell);\n\t\t\t\t\tconst webviewResults = webviewMatchesToTextSearchMatches(match.webviewMatches);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcell: match.cell,\n\t\t\t\t\t\tindex: match.index,\n\t\t\t\t\t\tcontentResults: contentResults,\n\t\t\t\t\t\twebviewResults: webviewResults,\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\tconst fileMatch: INotebookFileMatchWithModel = {\n\t\t\t\t\tresource: uri, cellResults: cellResults\n\t\t\t\t};\n\t\t\t\tlocalResults.set(uri, fileMatch);\n\t\t\t} else {\n\t\t\t\tlocalResults.set(uri, null);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tresults: localResults,\n\t\t\tlimitHit\n\t\t};\n\t}\n\n\n\tprivate getLocalNotebookWidgets(): Array<NotebookEditorWidget> {\n\t\tconst notebookWidgets = this.notebookEditorService.retrieveAllExistingWidgets();\n\t\treturn notebookWidgets\n\t\t\t.map(widget => widget.value)\n\t\t\t.filter((val): val is NotebookEditorWidget => !!val && val.hasModel());\n\t}\n}\n\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport * as glob from '../../../../../base/common/glob.js';\nimport { ResourceSet, ResourceMap } from '../../../../../base/common/map.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { ILogService } from '../../../../../platform/log/common/log.js';\nimport { IUriIdentityService } from '../../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { NotebookEditorWidget } from '../../../notebook/browser/notebookEditorWidget.js';\nimport { INotebookService } from '../../../notebook/common/notebookService.js';\nimport { INotebookSearchService } from '../../common/notebookSearch.js';\nimport { INotebookCellMatchWithModel, INotebookFileMatchWithModel, contentMatchesToTextSearchMatches, webviewMatchesToTextSearchMatches } from './searchNotebookHelpers.js';\nimport { ITextQuery, QueryType, ISearchProgressItem, ISearchComplete, ISearchConfigurationProperties, pathIncludedInQuery, ISearchService, IFolderQuery, DEFAULT_MAX_SEARCH_RESULTS } from '../../../../services/search/common/search.js';\nimport * as arrays from '../../../../../base/common/arrays.js';\nimport { isNumber } from '../../../../../base/common/types.js';\nimport { IEditorResolverService } from '../../../../services/editor/common/editorResolverService.js';\nimport { INotebookFileMatchNoModel } from '../../common/searchNotebookHelpers.js';\nimport { INotebookEditorService } from '../../../notebook/browser/services/notebookEditorService.js';\nimport { NotebookPriorityInfo } from '../../common/search.js';\nimport { INotebookExclusiveDocumentFilter } from '../../../notebook/common/notebookCommon.js';\nimport { QueryBuilder } from '../../../../services/search/common/queryBuilder.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\n\ninterface IOpenNotebookSearchResults {\n\tresults: ResourceMap<INotebookFileMatchWithModel | null>;\n\tlimitHit: boolean;\n}\ninterface IClosedNotebookSearchResults {\n\tresults: ResourceMap<INotebookFileMatchNoModel<URI> | null>;\n\tlimitHit: boolean;\n}\nexport class NotebookSearchService implements INotebookSearchService {\n\tdeclare readonly _serviceBrand: undefined;\n\tprivate queryBuilder: QueryBuilder;\n\tconstructor(\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@INotebookEditorService private readonly notebookEditorService: INotebookEditorService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@INotebookService private readonly notebookService: INotebookService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IEditorResolverService private readonly editorResolverService: IEditorResolverService,\n\t\t@ISearchService private readonly searchService: ISearchService,\n\t\t@IInstantiationService instantiationService: IInstantiationService\n\t) {\n\t\tthis.queryBuilder = instantiationService.createInstance(QueryBuilder);\n\t}\n\n\tnotebookSearch(query: ITextQuery, token: CancellationToken | undefined, searchInstanceID: string, onProgress?: (result: ISearchProgressItem) => void): {\n\t\topenFilesToScan: ResourceSet;\n\t\tcompleteData: Promise<ISearchComplete>;\n\t\tallScannedFiles: Promise<ResourceSet>;\n\t} {\n\n\t\tif (query.type !== QueryType.Text) {\n\t\t\treturn {\n\t\t\t\topenFilesToScan: new ResourceSet(),\n\t\t\t\tcompleteData: Promise.resolve({\n\t\t\t\t\tmessages: [],\n\t\t\t\t\tlimitHit: false,\n\t\t\t\t\tresults: [],\n\t\t\t\t}),\n\t\t\t\tallScannedFiles: Promise.resolve(new ResourceSet()),\n\t\t\t};\n\t\t}\n\n\t\tconst localNotebookWidgets = this.getLocalNotebookWidgets();\n\t\tconst localNotebookFiles = localNotebookWidgets.map(widget => widget.viewModel!.uri);\n\t\tconst getAllResults = (): { completeData: Promise<ISearchComplete>; allScannedFiles: Promise<ResourceSet> } => {\n\t\t\tconst searchStart = Date.now();\n\n\t\t\tconst localResultPromise = this.getLocalNotebookResults(query, token ?? CancellationToken.None, localNotebookWidgets, searchInstanceID);\n\t\t\tconst searchLocalEnd = Date.now();\n\n\t\t\tconst experimentalNotebooksEnabled = this.configurationService.getValue<ISearchConfigurationProperties>('search').experimental?.closedNotebookRichContentResults ?? false;\n\n\t\t\tlet closedResultsPromise: Promise<IClosedNotebookSearchResults | undefined> = Promise.resolve(undefined);\n\t\t\tif (experimentalNotebooksEnabled) {\n\t\t\t\tclosedResultsPromise = this.getClosedNotebookResults(query, new ResourceSet(localNotebookFiles, uri => this.uriIdentityService.extUri.getComparisonKey(uri)), token ?? CancellationToken.None);\n\t\t\t}\n\n\t\t\tconst promise = Promise.all([localResultPromise, closedResultsPromise]);\n\t\t\treturn {\n\t\t\t\tcompleteData: promise.then((resolvedPromise): ISearchComplete => {\n\t\t\t\t\tconst openNotebookResult = resolvedPromise[0];\n\t\t\t\t\tconst closedNotebookResult = resolvedPromise[1];\n\n\t\t\t\t\tconst resolved = resolvedPromise.filter((e): e is IOpenNotebookSearchResults | IClosedNotebookSearchResults => !!e);\n\t\t\t\t\tconst resultArray = [...openNotebookResult.results.values(), ...closedNotebookResult?.results.values() ?? []];\n\t\t\t\t\tconst results = arrays.coalesce(resultArray);\n\t\t\t\t\tif (onProgress) {\n\t\t\t\t\t\tresults.forEach(onProgress);\n\t\t\t\t\t}\n\t\t\t\t\tthis.logService.trace(`local notebook search time | ${searchLocalEnd - searchStart}ms`);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmessages: [],\n\t\t\t\t\t\tlimitHit: resolved.reduce((prev, cur) => prev || cur.limitHit, false),\n\t\t\t\t\t\tresults,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t\tallScannedFiles: promise.then(resolvedPromise => {\n\t\t\t\t\tconst openNotebookResults = resolvedPromise[0];\n\t\t\t\t\tconst closedNotebookResults = resolvedPromise[1];\n\t\t\t\t\tconst results = arrays.coalesce([...openNotebookResults.results.keys(), ...closedNotebookResults?.results.keys() ?? []]);\n\t\t\t\t\treturn new ResourceSet(results, uri => this.uriIdentityService.extUri.getComparisonKey(uri));\n\t\t\t\t})\n\t\t\t};\n\t\t};\n\t\tconst promiseResults = getAllResults();\n\t\treturn {\n\t\t\topenFilesToScan: new ResourceSet(localNotebookFiles),\n\t\t\tcompleteData: promiseResults.completeData,\n\t\t\tallScannedFiles: promiseResults.allScannedFiles\n\t\t};\n\t}\n\n\tprivate async doesFileExist(includes: string[], folderQueries: IFolderQuery<URI>[], token: CancellationToken): Promise<boolean> {\n\t\tconst promises: Promise<boolean>[] = includes.map(async includePattern => {\n\t\t\tconst query = this.queryBuilder.file(folderQueries.map(e => e.folder), {\n\t\t\t\tincludePattern: includePattern.startsWith('/') ? includePattern : '**/' + includePattern, // todo: find cleaner way to ensure that globs match all appropriate filetypes\n\t\t\t\texists: true,\n\t\t\t\tonlyFileScheme: true,\n\t\t\t});\n\t\t\treturn this.searchService.fileSearch(\n\t\t\t\tquery,\n\t\t\t\ttoken\n\t\t\t).then((ret) => {\n\t\t\t\treturn !!ret.limitHit;\n\t\t\t});\n\t\t});\n\n\t\treturn Promise.any(promises);\n\t}\n\n\tprivate async getClosedNotebookResults(textQuery: ITextQuery, scannedFiles: ResourceSet, token: CancellationToken): Promise<IClosedNotebookSearchResults> {\n\n\t\tconst userAssociations = this.editorResolverService.getAllUserAssociations();\n\t\tconst allPriorityInfo: Map<string, NotebookPriorityInfo[]> = new Map();\n\t\tconst contributedNotebookTypes = this.notebookService.getContributedNotebookTypes();\n\n\n\t\tuserAssociations.forEach(association => {\n\n\t\t\t// we gather the editor associations here, but cannot check them until we actually have the files that the glob matches\n\t\t\t// this is because longer patterns take precedence over shorter ones, and even if there is a user association that\n\t\t\t// specifies the exact same glob as a contributed notebook type, there might be another user association that is longer/more specific\n\t\t\t// that still matches the path and should therefore take more precedence.\n\t\t\tif (!association.filenamePattern) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst info: NotebookPriorityInfo = {\n\t\t\t\tisFromSettings: true,\n\t\t\t\tfilenamePatterns: [association.filenamePattern]\n\t\t\t};\n\n\t\t\tconst existingEntry = allPriorityInfo.get(association.viewType);\n\t\t\tif (existingEntry) {\n\t\t\t\tallPriorityInfo.set(association.viewType, existingEntry.concat(info));\n\t\t\t} else {\n\t\t\t\tallPriorityInfo.set(association.viewType, [info]);\n\t\t\t}\n\t\t});\n\n\t\tconst promises: Promise<{\n\t\t\tresults: INotebookFileMatchNoModel<URI>[];\n\t\t\tlimitHit: boolean;\n\t\t} | undefined>[] = [];\n\n\t\tcontributedNotebookTypes.forEach((notebook) => {\n\t\t\tif (notebook.selectors.length > 0) {\n\t\t\t\tpromises.push((async () => {\n\t\t\t\t\tconst includes = notebook.selectors.map((selector) => {\n\t\t\t\t\t\tconst globPattern = (selector as INotebookExclusiveDocumentFilter).include || selector as glob.IRelativePattern | string;\n\t\t\t\t\t\treturn globPattern.toString();\n\t\t\t\t\t});\n\n\t\t\t\t\tconst isInWorkspace = await this.doesFileExist(includes, textQuery.folderQueries, token);\n\t\t\t\t\tif (isInWorkspace) {\n\t\t\t\t\t\tconst canResolve = await this.notebookService.canResolve(notebook.id);\n\t\t\t\t\t\tif (!canResolve) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst serializer = (await this.notebookService.withNotebookDataProvider(notebook.id)).serializer;\n\t\t\t\t\t\treturn await serializer.searchInNotebooks(textQuery, token, allPriorityInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t})());\n\t\t\t}\n\t\t});\n\n\t\tconst start = Date.now();\n\t\tconst searchComplete = arrays.coalesce(await Promise.all(promises));\n\t\tconst results = searchComplete.flatMap(e => e.results);\n\t\tlet limitHit = searchComplete.some(e => e.limitHit);\n\n\t\t// results are already sorted with high priority first, filter out duplicates.\n\t\tconst uniqueResults = new ResourceMap<INotebookFileMatchNoModel | null>(uri => this.uriIdentityService.extUri.getComparisonKey(uri));\n\n\t\tlet numResults = 0;\n\t\tfor (const result of results) {\n\t\t\tif (textQuery.maxResults && numResults >= textQuery.maxResults) {\n\t\t\t\tlimitHit = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!scannedFiles.has(result.resource) && !uniqueResults.has(result.resource)) {\n\t\t\t\tuniqueResults.set(result.resource, result.cellResults.length > 0 ? result : null);\n\t\t\t\tnumResults++;\n\t\t\t}\n\t\t}\n\n\t\tconst end = Date.now();\n\t\tthis.logService.trace(`query: ${textQuery.contentPattern.pattern}`);\n\t\tthis.logService.trace(`closed notebook search time | ${end - start}ms`);\n\n\t\treturn {\n\t\t\tresults: uniqueResults,\n\t\t\tlimitHit\n\t\t};\n\t}\n\n\tprivate async getLocalNotebookResults(query: ITextQuery, token: CancellationToken, widgets: Array<NotebookEditorWidget>, searchID: string): Promise<IOpenNotebookSearchResults> {\n\t\tconst localResults = new ResourceMap<INotebookFileMatchWithModel | null>(uri => this.uriIdentityService.extUri.getComparisonKey(uri));\n\t\tlet limitHit = false;\n\n\t\tfor (const widget of widgets) {\n\t\t\tif (!widget.hasModel()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst askMax = (isNumber(query.maxResults) ? query.maxResults : DEFAULT_MAX_SEARCH_RESULTS) + 1;\n\t\t\tconst uri = widget.viewModel!.uri;\n\n\t\t\tif (!pathIncludedInQuery(query, uri.fsPath)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet matches = await widget\n\t\t\t\t.find(query.contentPattern.pattern, {\n\t\t\t\t\tregex: query.contentPattern.isRegExp,\n\t\t\t\t\twholeWord: query.contentPattern.isWordMatch,\n\t\t\t\t\tcaseSensitive: query.contentPattern.isCaseSensitive,\n\t\t\t\t\tincludeMarkupInput: query.contentPattern.notebookInfo?.isInNotebookMarkdownInput ?? true,\n\t\t\t\t\tincludeMarkupPreview: query.contentPattern.notebookInfo?.isInNotebookMarkdownPreview ?? true,\n\t\t\t\t\tincludeCodeInput: query.contentPattern.notebookInfo?.isInNotebookCellInput ?? true,\n\t\t\t\t\tincludeOutput: query.contentPattern.notebookInfo?.isInNotebookCellOutput ?? true,\n\t\t\t\t}, token, false, true, searchID);\n\n\n\t\t\tif (matches.length) {\n\t\t\t\tif (askMax && matches.length >= askMax) {\n\t\t\t\t\tlimitHit = true;\n\t\t\t\t\tmatches = matches.slice(0, askMax - 1);\n\t\t\t\t}\n\t\t\t\tconst cellResults: INotebookCellMatchWithModel[] = matches.map(match => {\n\t\t\t\t\tconst contentResults = contentMatchesToTextSearchMatches(match.contentMatches, match.cell);\n\t\t\t\t\tconst webviewResults = webviewMatchesToTextSearchMatches(match.webviewMatches);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcell: match.cell,\n\t\t\t\t\t\tindex: match.index,\n\t\t\t\t\t\tcontentResults: contentResults,\n\t\t\t\t\t\twebviewResults: webviewResults,\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\tconst fileMatch: INotebookFileMatchWithModel = {\n\t\t\t\t\tresource: uri, cellResults: cellResults\n\t\t\t\t};\n\t\t\t\tlocalResults.set(uri, fileMatch);\n\t\t\t} else {\n\t\t\t\tlocalResults.set(uri, null);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tresults: localResults,\n\t\t\tlimitHit\n\t\t};\n\t}\n\n\n\tprivate getLocalNotebookWidgets(): Array<NotebookEditorWidget> {\n\t\tconst notebookWidgets = this.notebookEditorService.retrieveAllExistingWidgets();\n\t\treturn notebookWidgets\n\t\t\t.map(widget => widget.value)\n\t\t\t.filter((val): val is NotebookEditorWidget => !!val && val.hasModel());\n\t}\n}\n\n\n"]}