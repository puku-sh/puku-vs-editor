{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/localHistory/browser/localHistoryFileSystemProvider.ts","vs/workbench/contrib/localHistory/browser/localHistoryFileSystemProvider.ts"],"names":[],"mappings":"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","file":"localHistoryFileSystemProvider.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { Disposable, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IFileDeleteOptions, IFileOverwriteOptions, FileSystemProviderCapabilities, FileType, IFileWriteOptions, hasReadWriteCapability, IFileService, IFileSystemProvider, IFileSystemProviderWithFileReadWriteCapability, IStat, IWatchOptions } from '../../../../platform/files/common/files.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\n\ninterface ILocalHistoryResource {\n\n\t/**\n\t * The location of the local history entry to read from.\n\t */\n\treadonly location: URI;\n\n\t/**\n\t * The associated resource the local history entry is about.\n\t */\n\treadonly associatedResource: URI;\n}\n\ninterface ISerializedLocalHistoryResource {\n\treadonly location: string;\n\treadonly associatedResource: string;\n}\n\n/**\n * A wrapper around a standard file system provider\n * that is entirely readonly.\n */\nexport class LocalHistoryFileSystemProvider implements IFileSystemProvider, IFileSystemProviderWithFileReadWriteCapability {\n\n\tstatic readonly SCHEMA = 'vscode-local-history';\n\n\tstatic toLocalHistoryFileSystem(resource: ILocalHistoryResource): URI {\n\t\tconst serializedLocalHistoryResource: ISerializedLocalHistoryResource = {\n\t\t\tlocation: resource.location.toString(true),\n\t\t\tassociatedResource: resource.associatedResource.toString(true)\n\t\t};\n\n\t\t// Try to preserve the associated resource as much as possible\n\t\t// and only keep the `query` part dynamic. This enables other\n\t\t// components (e.g. other timeline providers) to continue\n\t\t// providing timeline entries even when our resource is active.\n\t\treturn resource.associatedResource.with({\n\t\t\tscheme: LocalHistoryFileSystemProvider.SCHEMA,\n\t\t\tquery: JSON.stringify(serializedLocalHistoryResource)\n\t\t});\n\t}\n\n\tstatic fromLocalHistoryFileSystem(resource: URI): ILocalHistoryResource {\n\t\tconst serializedLocalHistoryResource: ISerializedLocalHistoryResource = JSON.parse(resource.query);\n\n\t\treturn {\n\t\t\tlocation: URI.parse(serializedLocalHistoryResource.location),\n\t\t\tassociatedResource: URI.parse(serializedLocalHistoryResource.associatedResource)\n\t\t};\n\t}\n\n\tprivate static readonly EMPTY_RESOURCE = URI.from({ scheme: LocalHistoryFileSystemProvider.SCHEMA, path: '/empty' });\n\n\tstatic readonly EMPTY: ILocalHistoryResource = {\n\t\tlocation: LocalHistoryFileSystemProvider.EMPTY_RESOURCE,\n\t\tassociatedResource: LocalHistoryFileSystemProvider.EMPTY_RESOURCE\n\t};\n\n\tget capabilities() {\n\t\treturn FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.Readonly;\n\t}\n\n\tconstructor(private readonly fileService: IFileService) { }\n\n\tprivate readonly mapSchemeToProvider = new Map<string, Promise<IFileSystemProvider>>();\n\n\tprivate async withProvider(resource: URI): Promise<IFileSystemProvider> {\n\t\tconst scheme = resource.scheme;\n\n\t\tlet providerPromise = this.mapSchemeToProvider.get(scheme);\n\t\tif (!providerPromise) {\n\n\t\t\t// Resolve early when provider already exists\n\t\t\tconst provider = this.fileService.getProvider(scheme);\n\t\t\tif (provider) {\n\t\t\t\tproviderPromise = Promise.resolve(provider);\n\t\t\t}\n\n\t\t\t// Otherwise wait for registration\n\t\t\telse {\n\t\t\t\tproviderPromise = new Promise<IFileSystemProvider>(resolve => {\n\t\t\t\t\tconst disposable = this.fileService.onDidChangeFileSystemProviderRegistrations(e => {\n\t\t\t\t\t\tif (e.added && e.provider && e.scheme === scheme) {\n\t\t\t\t\t\t\tdisposable.dispose();\n\n\t\t\t\t\t\t\tresolve(e.provider);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.mapSchemeToProvider.set(scheme, providerPromise);\n\t\t}\n\n\t\treturn providerPromise;\n\t}\n\n\t//#region Supported File Operations\n\n\tasync stat(resource: URI): Promise<IStat> {\n\t\tconst location = LocalHistoryFileSystemProvider.fromLocalHistoryFileSystem(resource).location;\n\n\t\t// Special case: empty resource\n\t\tif (isEqual(LocalHistoryFileSystemProvider.EMPTY_RESOURCE, location)) {\n\t\t\treturn { type: FileType.File, ctime: 0, mtime: 0, size: 0 };\n\t\t}\n\n\t\t// Otherwise delegate to provider\n\t\treturn (await this.withProvider(location)).stat(location);\n\t}\n\n\tasync readFile(resource: URI): Promise<Uint8Array> {\n\t\tconst location = LocalHistoryFileSystemProvider.fromLocalHistoryFileSystem(resource).location;\n\n\t\t// Special case: empty resource\n\t\tif (isEqual(LocalHistoryFileSystemProvider.EMPTY_RESOURCE, location)) {\n\t\t\treturn VSBuffer.fromString('').buffer;\n\t\t}\n\n\t\t// Otherwise delegate to provider\n\t\tconst provider = await this.withProvider(location);\n\t\tif (hasReadWriteCapability(provider)) {\n\t\t\treturn provider.readFile(location);\n\t\t}\n\n\t\tthrow new Error('Unsupported');\n\t}\n\n\t//#endregion\n\n\t//#region Unsupported File Operations\n\n\treadonly onDidChangeCapabilities = Event.None;\n\treadonly onDidChangeFile = Event.None;\n\n\tasync writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> { }\n\n\tasync mkdir(resource: URI): Promise<void> { }\n\tasync readdir(resource: URI): Promise<[string, FileType][]> { return []; }\n\n\tasync rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void> { }\n\tasync delete(resource: URI, opts: IFileDeleteOptions): Promise<void> { }\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable { return Disposable.None; }\n\n\t//#endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { Disposable, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IFileDeleteOptions, IFileOverwriteOptions, FileSystemProviderCapabilities, FileType, IFileWriteOptions, hasReadWriteCapability, IFileService, IFileSystemProvider, IFileSystemProviderWithFileReadWriteCapability, IStat, IWatchOptions } from '../../../../platform/files/common/files.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\n\ninterface ILocalHistoryResource {\n\n\t/**\n\t * The location of the local history entry to read from.\n\t */\n\treadonly location: URI;\n\n\t/**\n\t * The associated resource the local history entry is about.\n\t */\n\treadonly associatedResource: URI;\n}\n\ninterface ISerializedLocalHistoryResource {\n\treadonly location: string;\n\treadonly associatedResource: string;\n}\n\n/**\n * A wrapper around a standard file system provider\n * that is entirely readonly.\n */\nexport class LocalHistoryFileSystemProvider implements IFileSystemProvider, IFileSystemProviderWithFileReadWriteCapability {\n\n\tstatic readonly SCHEMA = 'vscode-local-history';\n\n\tstatic toLocalHistoryFileSystem(resource: ILocalHistoryResource): URI {\n\t\tconst serializedLocalHistoryResource: ISerializedLocalHistoryResource = {\n\t\t\tlocation: resource.location.toString(true),\n\t\t\tassociatedResource: resource.associatedResource.toString(true)\n\t\t};\n\n\t\t// Try to preserve the associated resource as much as possible\n\t\t// and only keep the `query` part dynamic. This enables other\n\t\t// components (e.g. other timeline providers) to continue\n\t\t// providing timeline entries even when our resource is active.\n\t\treturn resource.associatedResource.with({\n\t\t\tscheme: LocalHistoryFileSystemProvider.SCHEMA,\n\t\t\tquery: JSON.stringify(serializedLocalHistoryResource)\n\t\t});\n\t}\n\n\tstatic fromLocalHistoryFileSystem(resource: URI): ILocalHistoryResource {\n\t\tconst serializedLocalHistoryResource: ISerializedLocalHistoryResource = JSON.parse(resource.query);\n\n\t\treturn {\n\t\t\tlocation: URI.parse(serializedLocalHistoryResource.location),\n\t\t\tassociatedResource: URI.parse(serializedLocalHistoryResource.associatedResource)\n\t\t};\n\t}\n\n\tprivate static readonly EMPTY_RESOURCE = URI.from({ scheme: LocalHistoryFileSystemProvider.SCHEMA, path: '/empty' });\n\n\tstatic readonly EMPTY: ILocalHistoryResource = {\n\t\tlocation: LocalHistoryFileSystemProvider.EMPTY_RESOURCE,\n\t\tassociatedResource: LocalHistoryFileSystemProvider.EMPTY_RESOURCE\n\t};\n\n\tget capabilities() {\n\t\treturn FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.Readonly;\n\t}\n\n\tconstructor(private readonly fileService: IFileService) { }\n\n\tprivate readonly mapSchemeToProvider = new Map<string, Promise<IFileSystemProvider>>();\n\n\tprivate async withProvider(resource: URI): Promise<IFileSystemProvider> {\n\t\tconst scheme = resource.scheme;\n\n\t\tlet providerPromise = this.mapSchemeToProvider.get(scheme);\n\t\tif (!providerPromise) {\n\n\t\t\t// Resolve early when provider already exists\n\t\t\tconst provider = this.fileService.getProvider(scheme);\n\t\t\tif (provider) {\n\t\t\t\tproviderPromise = Promise.resolve(provider);\n\t\t\t}\n\n\t\t\t// Otherwise wait for registration\n\t\t\telse {\n\t\t\t\tproviderPromise = new Promise<IFileSystemProvider>(resolve => {\n\t\t\t\t\tconst disposable = this.fileService.onDidChangeFileSystemProviderRegistrations(e => {\n\t\t\t\t\t\tif (e.added && e.provider && e.scheme === scheme) {\n\t\t\t\t\t\t\tdisposable.dispose();\n\n\t\t\t\t\t\t\tresolve(e.provider);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.mapSchemeToProvider.set(scheme, providerPromise);\n\t\t}\n\n\t\treturn providerPromise;\n\t}\n\n\t//#region Supported File Operations\n\n\tasync stat(resource: URI): Promise<IStat> {\n\t\tconst location = LocalHistoryFileSystemProvider.fromLocalHistoryFileSystem(resource).location;\n\n\t\t// Special case: empty resource\n\t\tif (isEqual(LocalHistoryFileSystemProvider.EMPTY_RESOURCE, location)) {\n\t\t\treturn { type: FileType.File, ctime: 0, mtime: 0, size: 0 };\n\t\t}\n\n\t\t// Otherwise delegate to provider\n\t\treturn (await this.withProvider(location)).stat(location);\n\t}\n\n\tasync readFile(resource: URI): Promise<Uint8Array> {\n\t\tconst location = LocalHistoryFileSystemProvider.fromLocalHistoryFileSystem(resource).location;\n\n\t\t// Special case: empty resource\n\t\tif (isEqual(LocalHistoryFileSystemProvider.EMPTY_RESOURCE, location)) {\n\t\t\treturn VSBuffer.fromString('').buffer;\n\t\t}\n\n\t\t// Otherwise delegate to provider\n\t\tconst provider = await this.withProvider(location);\n\t\tif (hasReadWriteCapability(provider)) {\n\t\t\treturn provider.readFile(location);\n\t\t}\n\n\t\tthrow new Error('Unsupported');\n\t}\n\n\t//#endregion\n\n\t//#region Unsupported File Operations\n\n\treadonly onDidChangeCapabilities = Event.None;\n\treadonly onDidChangeFile = Event.None;\n\n\tasync writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> { }\n\n\tasync mkdir(resource: URI): Promise<void> { }\n\tasync readdir(resource: URI): Promise<[string, FileType][]> { return []; }\n\n\tasync rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void> { }\n\tasync delete(resource: URI, opts: IFileDeleteOptions): Promise<void> { }\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable { return Disposable.None; }\n\n\t//#endregion\n}\n"]}