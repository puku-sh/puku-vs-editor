{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminal/browser/xterm/lineDataEventAddon.ts","vs/workbench/contrib/terminal/browser/xterm/lineDataEventAddon.ts"],"names":[],"mappings":"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","file":"lineDataEventAddon.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { OperatingSystem } from '../../../../../base/common/platform.js';\nimport type { Terminal as XTermTerminal, IBuffer, ITerminalAddon } from '@xterm/xterm';\n\n/**\n * Provides extensions to the xterm object in a modular, testable way.\n */\nexport class LineDataEventAddon extends Disposable implements ITerminalAddon {\n\n\tprivate _xterm?: XTermTerminal;\n\tprivate _isOsSet = false;\n\n\tprivate readonly _onLineData = this._register(new Emitter<string>());\n\treadonly onLineData = this._onLineData.event;\n\n\tconstructor(private readonly _initializationPromise?: Promise<void>) {\n\t\tsuper();\n\t}\n\n\tasync activate(xterm: XTermTerminal) {\n\t\tthis._xterm = xterm;\n\n\t\t// IMPORTANT: Instantiate the buffer namespace object here before it's disposed.\n\t\tconst buffer = xterm.buffer;\n\n\t\t// If there is an initialization promise, wait for it before registering the event\n\t\tawait this._initializationPromise;\n\n\t\t// Fire onLineData when a line feed occurs, taking into account wrapped lines\n\t\tthis._register(xterm.onLineFeed(() => {\n\t\t\tconst newLine = buffer.active.getLine(buffer.active.baseY + buffer.active.cursorY);\n\t\t\tif (newLine && !newLine.isWrapped) {\n\t\t\t\tthis._sendLineData(buffer.active, buffer.active.baseY + buffer.active.cursorY - 1);\n\t\t\t}\n\t\t}));\n\n\t\t// Fire onLineData when disposing object to flush last line\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._sendLineData(buffer.active, buffer.active.baseY + buffer.active.cursorY);\n\t\t}));\n\t}\n\n\tsetOperatingSystem(os: OperatingSystem) {\n\t\tif (this._isOsSet || !this._xterm) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isOsSet = true;\n\n\t\t// Force line data to be sent when the cursor is moved, the main purpose for\n\t\t// this is because ConPTY will often not do a line feed but instead move the\n\t\t// cursor, in which case we still want to send the current line's data to tasks.\n\t\tif (os === OperatingSystem.Windows) {\n\t\t\tconst xterm = this._xterm;\n\t\t\tthis._register(xterm.parser.registerCsiHandler({ final: 'H' }, () => {\n\t\t\t\tconst buffer = xterm.buffer;\n\t\t\t\tthis._sendLineData(buffer.active, buffer.active.baseY + buffer.active.cursorY);\n\t\t\t\treturn false;\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate _sendLineData(buffer: IBuffer, lineIndex: number): void {\n\t\tlet line = buffer.getLine(lineIndex);\n\t\tif (!line) {\n\t\t\treturn;\n\t\t}\n\t\tlet lineData = line.translateToString(true);\n\t\twhile (lineIndex > 0 && line.isWrapped) {\n\t\t\tline = buffer.getLine(--lineIndex);\n\t\t\tif (!line) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlineData = line.translateToString(false) + lineData;\n\t\t}\n\t\tthis._onLineData.fire(lineData);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { OperatingSystem } from '../../../../../base/common/platform.js';\nimport type { Terminal as XTermTerminal, IBuffer, ITerminalAddon } from '@xterm/xterm';\n\n/**\n * Provides extensions to the xterm object in a modular, testable way.\n */\nexport class LineDataEventAddon extends Disposable implements ITerminalAddon {\n\n\tprivate _xterm?: XTermTerminal;\n\tprivate _isOsSet = false;\n\n\tprivate readonly _onLineData = this._register(new Emitter<string>());\n\treadonly onLineData = this._onLineData.event;\n\n\tconstructor(private readonly _initializationPromise?: Promise<void>) {\n\t\tsuper();\n\t}\n\n\tasync activate(xterm: XTermTerminal) {\n\t\tthis._xterm = xterm;\n\n\t\t// IMPORTANT: Instantiate the buffer namespace object here before it's disposed.\n\t\tconst buffer = xterm.buffer;\n\n\t\t// If there is an initialization promise, wait for it before registering the event\n\t\tawait this._initializationPromise;\n\n\t\t// Fire onLineData when a line feed occurs, taking into account wrapped lines\n\t\tthis._register(xterm.onLineFeed(() => {\n\t\t\tconst newLine = buffer.active.getLine(buffer.active.baseY + buffer.active.cursorY);\n\t\t\tif (newLine && !newLine.isWrapped) {\n\t\t\t\tthis._sendLineData(buffer.active, buffer.active.baseY + buffer.active.cursorY - 1);\n\t\t\t}\n\t\t}));\n\n\t\t// Fire onLineData when disposing object to flush last line\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._sendLineData(buffer.active, buffer.active.baseY + buffer.active.cursorY);\n\t\t}));\n\t}\n\n\tsetOperatingSystem(os: OperatingSystem) {\n\t\tif (this._isOsSet || !this._xterm) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isOsSet = true;\n\n\t\t// Force line data to be sent when the cursor is moved, the main purpose for\n\t\t// this is because ConPTY will often not do a line feed but instead move the\n\t\t// cursor, in which case we still want to send the current line's data to tasks.\n\t\tif (os === OperatingSystem.Windows) {\n\t\t\tconst xterm = this._xterm;\n\t\t\tthis._register(xterm.parser.registerCsiHandler({ final: 'H' }, () => {\n\t\t\t\tconst buffer = xterm.buffer;\n\t\t\t\tthis._sendLineData(buffer.active, buffer.active.baseY + buffer.active.cursorY);\n\t\t\t\treturn false;\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate _sendLineData(buffer: IBuffer, lineIndex: number): void {\n\t\tlet line = buffer.getLine(lineIndex);\n\t\tif (!line) {\n\t\t\treturn;\n\t\t}\n\t\tlet lineData = line.translateToString(true);\n\t\twhile (lineIndex > 0 && line.isWrapped) {\n\t\t\tline = buffer.getLine(--lineIndex);\n\t\t\tif (!line) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlineData = line.translateToString(false) + lineData;\n\t\t}\n\t\tthis._onLineData.fire(lineData);\n\t}\n}\n"]}