{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminal/browser/terminalTelemetry.ts","vs/workbench/contrib/terminal/browser/terminalTelemetry.ts"],"names":[],"mappings":"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","file":"terminalTelemetry.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getWindowById } from '../../../../base/browser/dom.js';\nimport { isAuxiliaryWindow } from '../../../../base/browser/window.js';\nimport { timeout } from '../../../../base/common/async.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { basename } from '../../../../base/common/path.js';\nimport { isString } from '../../../../base/common/types.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { TelemetryTrustedValue } from '../../../../platform/telemetry/common/telemetryUtils.js';\nimport { TerminalCapability } from '../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { TerminalLocation, type IShellLaunchConfig, type ShellIntegrationInjectionFailureReason } from '../../../../platform/terminal/common/terminal.js';\nimport type { IWorkbenchContribution } from '../../../common/contributions.js';\nimport { ILifecycleService } from '../../../services/lifecycle/common/lifecycle.js';\nimport { ITerminalEditorService, ITerminalService, type ITerminalInstance } from './terminal.js';\n\nexport class TerminalTelemetryContribution extends Disposable implements IWorkbenchContribution {\n\tstatic ID = 'terminalTelemetry';\n\n\tconstructor(\n\t\t@ILifecycleService lifecycleService: ILifecycleService,\n\t\t@ITerminalService terminalService: ITerminalService,\n\t\t@ITerminalEditorService terminalEditorService: ITerminalEditorService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(terminalService.onDidCreateInstance(async instance => {\n\t\t\tconst store = new DisposableStore();\n\t\t\tthis._store.add(store);\n\n\t\t\tawait Promise.race([\n\t\t\t\t// Wait for process ready so the shell launch config is fully resolved, then\n\t\t\t\t// allow another 10 seconds for the shell integration to be fully initialized\n\t\t\t\tinstance.processReady.then(() => {\n\t\t\t\t\treturn timeout(10000);\n\t\t\t\t}),\n\t\t\t\t// If the terminal is disposed, it's ready to report on immediately\n\t\t\t\tEvent.toPromise(instance.onDisposed, store),\n\t\t\t\t// If the app is shutting down, flush\n\t\t\t\tEvent.toPromise(lifecycleService.onWillShutdown, store),\n\t\t\t]);\n\n\t\t\t// Determine window status, this is done some time after the process is ready and could\n\t\t\t// reflect the terminal being moved.\n\t\t\tlet isInAuxWindow = false;\n\t\t\ttry {\n\t\t\t\tconst input = terminalEditorService.getInputFromResource(instance.resource);\n\t\t\t\tconst windowId = input.group?.windowId;\n\t\t\t\tisInAuxWindow = !!(windowId && isAuxiliaryWindow(getWindowById(windowId, true).window));\n\t\t\t} catch {\n\t\t\t}\n\n\t\t\tthis._logCreateInstance(instance, isInAuxWindow);\n\t\t\tthis._store.delete(store);\n\t\t}));\n\t}\n\n\tprivate _logCreateInstance(instance: ITerminalInstance, isInAuxWindow: boolean): void {\n\t\tconst slc = instance.shellLaunchConfig;\n\t\tconst commandDetection = instance.capabilities.get(TerminalCapability.CommandDetection);\n\n\t\ttype TerminalCreationTelemetryData = {\n\t\t\tlocation: string;\n\n\t\t\tshellType: TelemetryTrustedValue<string>;\n\t\t\tpromptType: TelemetryTrustedValue<string | undefined>;\n\n\t\t\tisCustomPtyImplementation: boolean;\n\t\t\tisExtensionOwnedTerminal: boolean;\n\t\t\tisLoginShell: boolean;\n\t\t\tisReconnect: boolean;\n\t\t\thasRemoteAuthority: boolean;\n\n\t\t\tshellIntegrationQuality: number;\n\t\t\tshellIntegrationInjected: boolean;\n\t\t\tshellIntegrationInjectionFailureReason: ShellIntegrationInjectionFailureReason | undefined;\n\n\t\t\tterminalSessionId: string;\n\t\t};\n\t\ttype TerminalCreationTelemetryClassification = {\n\t\t\towner: 'tyriar';\n\t\t\tcomment: 'Track details about terminal creation, such as the shell type';\n\n\t\t\tlocation: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The location of the terminal.' };\n\n\t\t\tshellType: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The detected shell type for the terminal.' };\n\t\t\tpromptType: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The detected prompt type for the terminal.' };\n\n\t\t\tisCustomPtyImplementation: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the terminal was using a custom PTY implementation.' };\n\t\t\tisExtensionOwnedTerminal: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the terminal was created by an extension.' };\n\t\t\tisLoginShell: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the arguments contain -l or --login.' };\n\t\t\tisReconnect: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the terminal is reconnecting to an existing instance.' };\n\t\t\thasRemoteAuthority: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the terminal has a remote authority, this is likely a connection terminal when undefined in a window with a remote authority.' };\n\n\t\t\tshellIntegrationQuality: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The shell integration quality (rich=2, basic=1 or none=0).' };\n\t\t\tshellIntegrationInjected: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the shell integration script was injected.' };\n\t\t\tshellIntegrationInjectionFailureReason: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Info about shell integration injection.' };\n\n\t\t\tterminalSessionId: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The session ID of the terminal instance.' };\n\t\t};\n\t\tthis._telemetryService.publicLog2<TerminalCreationTelemetryData, TerminalCreationTelemetryClassification>('terminal/createInstance', {\n\t\t\tlocation: (instance.target === TerminalLocation.Panel\n\t\t\t\t? 'view'\n\t\t\t\t: instance.target === TerminalLocation.Editor\n\t\t\t\t\t? (isInAuxWindow ? 'editor-auxwindow' : 'editor')\n\t\t\t\t\t: 'unknown'),\n\n\t\t\tshellType: new TelemetryTrustedValue(getSanitizedShellType(slc)),\n\t\t\tpromptType: new TelemetryTrustedValue(instance.capabilities.get(TerminalCapability.PromptTypeDetection)?.promptType),\n\n\t\t\tisCustomPtyImplementation: !!slc.customPtyImplementation,\n\t\t\tisExtensionOwnedTerminal: !!slc.isExtensionOwnedTerminal,\n\t\t\tisLoginShell: (isString(slc.args) ? slc.args.split(' ') : slc.args)?.some(arg => arg === '-l' || arg === '--login') ?? false,\n\t\t\tisReconnect: !!slc.attachPersistentProcess,\n\t\t\thasRemoteAuthority: instance.hasRemoteAuthority,\n\n\t\t\tshellIntegrationQuality: commandDetection?.hasRichCommandDetection ? 2 : commandDetection ? 1 : 0,\n\t\t\tshellIntegrationInjected: instance.usedShellIntegrationInjection,\n\t\t\tshellIntegrationInjectionFailureReason: instance.shellIntegrationInjectionFailureReason,\n\t\t\tterminalSessionId: instance.sessionId,\n\t\t});\n\t}\n}\n\n// #region Shell Type\n\nconst enum AllowedShellType {\n\tUnknown = 'unknown',\n\n\t// Windows only\n\tCommandPrompt = 'cmd',\n\tCygwin = 'cygwin-bash',\n\tGitBash = 'git-bash',\n\tMsys2 = 'msys2-bash',\n\tWindowsPowerShell = 'windows-powershell',\n\tWsl = 'wsl',\n\n\n\t// Common Unix shells\n\tBash = 'bash',\n\tFish = 'fish',\n\tPwsh = 'pwsh',\n\tPwshPreview = 'pwsh-preview',\n\tSh = 'sh',\n\tSsh = 'ssh',\n\tTmux = 'tmux',\n\tZsh = 'zsh',\n\n\t// More shells\n\tAmm = 'amm',\n\tAsh = 'ash',\n\tCsh = 'csh',\n\tDash = 'dash',\n\tElvish = 'elvish',\n\tIon = 'ion',\n\tKsh = 'ksh',\n\tMksh = 'mksh',\n\tMsh = 'msh',\n\tNuShell = 'nu',\n\tPlan9Shell = 'rc',\n\tSchemeShell = 'scsh',\n\tTcsh = 'tcsh',\n\tTermux = 'termux',\n\tXonsh = 'xonsh',\n\n\t// Lanugage REPLs\n\t// These are expected to be very low since they are not typically the default shell\n\tClojure = 'clj',\n\tCommonLispSbcl = 'sbcl',\n\tCrystal = 'crystal',\n\tDeno = 'deno',\n\tElixir = 'iex',\n\tErlang = 'erl',\n\tFSharp = 'fsi',\n\tGo = 'go',\n\tHaskellGhci = 'ghci',\n\tJava = 'jshell',\n\tJulia = 'julia',\n\tLua = 'lua',\n\tNode = 'node',\n\tOcaml = 'ocaml',\n\tPerl = 'perl',\n\tPhp = 'php',\n\tPrologSwipl = 'swipl',\n\tPython = 'python',\n\tR = 'R',\n\tRubyIrb = 'irb',\n\tScala = 'scala',\n\tSchemeRacket = 'racket',\n\tSmalltalkGnu = 'gst',\n\tSmalltalkPharo = 'pharo',\n\tTcl = 'tclsh',\n\tTsNode = 'ts-node',\n}\n\n// Types that match the executable name directly\nconst shellTypeExecutableAllowList: Set<string> = new Set([\n\t// Windows only\n\tAllowedShellType.CommandPrompt,\n\tAllowedShellType.Wsl,\n\n\t// Common Unix shells\n\tAllowedShellType.Bash,\n\tAllowedShellType.Fish,\n\tAllowedShellType.Pwsh,\n\tAllowedShellType.Sh,\n\tAllowedShellType.Ssh,\n\tAllowedShellType.Tmux,\n\tAllowedShellType.Zsh,\n\n\t// More shells\n\tAllowedShellType.Amm,\n\tAllowedShellType.Ash,\n\tAllowedShellType.Csh,\n\tAllowedShellType.Dash,\n\tAllowedShellType.Elvish,\n\tAllowedShellType.Ion,\n\tAllowedShellType.Ksh,\n\tAllowedShellType.Mksh,\n\tAllowedShellType.Msh,\n\tAllowedShellType.NuShell,\n\tAllowedShellType.Plan9Shell,\n\tAllowedShellType.SchemeShell,\n\tAllowedShellType.Tcsh,\n\tAllowedShellType.Termux,\n\tAllowedShellType.Xonsh,\n\n\t// Lanugage REPLs\n\tAllowedShellType.Clojure,\n\tAllowedShellType.CommonLispSbcl,\n\tAllowedShellType.Crystal,\n\tAllowedShellType.Deno,\n\tAllowedShellType.Elixir,\n\tAllowedShellType.Erlang,\n\tAllowedShellType.FSharp,\n\tAllowedShellType.Go,\n\tAllowedShellType.HaskellGhci,\n\tAllowedShellType.Java,\n\tAllowedShellType.Julia,\n\tAllowedShellType.Lua,\n\tAllowedShellType.Node,\n\tAllowedShellType.Ocaml,\n\tAllowedShellType.Perl,\n\tAllowedShellType.Php,\n\tAllowedShellType.PrologSwipl,\n\tAllowedShellType.Python,\n\tAllowedShellType.R,\n\tAllowedShellType.RubyIrb,\n\tAllowedShellType.Scala,\n\tAllowedShellType.SchemeRacket,\n\tAllowedShellType.SmalltalkGnu,\n\tAllowedShellType.SmalltalkPharo,\n\tAllowedShellType.Tcl,\n\tAllowedShellType.TsNode,\n]) satisfies Set<AllowedShellType>;\n\n// Dynamic executables that map to a single type\nconst shellTypeExecutableRegexAllowList: { regex: RegExp; type: AllowedShellType }[] = [\n\t{ regex: /^(?:pwsh|powershell)-preview$/i, type: AllowedShellType.PwshPreview },\n\t{ regex: /^python(?:\\d+(?:\\.\\d+)?)?$/i, type: AllowedShellType.Python },\n];\n\n// Path-based look ups\nconst shellTypePathRegexAllowList: { regex: RegExp; type: AllowedShellType }[] = [\n\t// Cygwin uses bash.exe, so look up based on the path\n\t{ regex: /\\\\Cygwin(?:64)?\\\\.+\\\\bash\\.exe$/i, type: AllowedShellType.Cygwin },\n\t// Git bash uses bash.exe, so look up based on the path\n\t{ regex: /\\\\Git\\\\.+\\\\bash\\.exe$/i, type: AllowedShellType.GitBash },\n\t// Msys2 uses bash.exe, so look up based on the path\n\t{ regex: /\\\\msys(?:32|64)\\\\.+\\\\(?:bash|msys2)\\.exe$/i, type: AllowedShellType.Msys2 },\n\t// WindowsPowerShell should always be installed on this path, we cannot just look at the\n\t// executable name since powershell is the CLI on other platforms sometimes (eg. snap package)\n\t{ regex: /\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe$/i, type: AllowedShellType.WindowsPowerShell },\n\t// WSL executables will represent some other shell in the end, but it's difficult to determine\n\t// when we log\n\t{ regex: /\\\\Windows\\\\(?:System32|SysWOW64|Sysnative)\\\\(?:bash|wsl)\\.exe$/i, type: AllowedShellType.Wsl },\n];\n\nfunction getSanitizedShellType(slc: IShellLaunchConfig): AllowedShellType {\n\tif (!slc.executable) {\n\t\treturn AllowedShellType.Unknown;\n\t}\n\tconst executableFile = basename(slc.executable);\n\tconst executableFileWithoutExt = executableFile.replace(/\\.[^\\.]+$/, '');\n\tfor (const entry of shellTypePathRegexAllowList) {\n\t\tif (entry.regex.test(slc.executable)) {\n\t\t\treturn entry.type;\n\t\t}\n\t}\n\tfor (const entry of shellTypeExecutableRegexAllowList) {\n\t\tif (entry.regex.test(executableFileWithoutExt)) {\n\t\t\treturn entry.type;\n\t\t}\n\t}\n\tif ((shellTypeExecutableAllowList).has(executableFileWithoutExt)) {\n\t\treturn executableFileWithoutExt as AllowedShellType;\n\t}\n\treturn AllowedShellType.Unknown;\n}\n\n// #endregion Shell Type\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getWindowById } from '../../../../base/browser/dom.js';\nimport { isAuxiliaryWindow } from '../../../../base/browser/window.js';\nimport { timeout } from '../../../../base/common/async.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { basename } from '../../../../base/common/path.js';\nimport { isString } from '../../../../base/common/types.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { TelemetryTrustedValue } from '../../../../platform/telemetry/common/telemetryUtils.js';\nimport { TerminalCapability } from '../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { TerminalLocation, type IShellLaunchConfig, type ShellIntegrationInjectionFailureReason } from '../../../../platform/terminal/common/terminal.js';\nimport type { IWorkbenchContribution } from '../../../common/contributions.js';\nimport { ILifecycleService } from '../../../services/lifecycle/common/lifecycle.js';\nimport { ITerminalEditorService, ITerminalService, type ITerminalInstance } from './terminal.js';\n\nexport class TerminalTelemetryContribution extends Disposable implements IWorkbenchContribution {\n\tstatic ID = 'terminalTelemetry';\n\n\tconstructor(\n\t\t@ILifecycleService lifecycleService: ILifecycleService,\n\t\t@ITerminalService terminalService: ITerminalService,\n\t\t@ITerminalEditorService terminalEditorService: ITerminalEditorService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(terminalService.onDidCreateInstance(async instance => {\n\t\t\tconst store = new DisposableStore();\n\t\t\tthis._store.add(store);\n\n\t\t\tawait Promise.race([\n\t\t\t\t// Wait for process ready so the shell launch config is fully resolved, then\n\t\t\t\t// allow another 10 seconds for the shell integration to be fully initialized\n\t\t\t\tinstance.processReady.then(() => {\n\t\t\t\t\treturn timeout(10000);\n\t\t\t\t}),\n\t\t\t\t// If the terminal is disposed, it's ready to report on immediately\n\t\t\t\tEvent.toPromise(instance.onDisposed, store),\n\t\t\t\t// If the app is shutting down, flush\n\t\t\t\tEvent.toPromise(lifecycleService.onWillShutdown, store),\n\t\t\t]);\n\n\t\t\t// Determine window status, this is done some time after the process is ready and could\n\t\t\t// reflect the terminal being moved.\n\t\t\tlet isInAuxWindow = false;\n\t\t\ttry {\n\t\t\t\tconst input = terminalEditorService.getInputFromResource(instance.resource);\n\t\t\t\tconst windowId = input.group?.windowId;\n\t\t\t\tisInAuxWindow = !!(windowId && isAuxiliaryWindow(getWindowById(windowId, true).window));\n\t\t\t} catch {\n\t\t\t}\n\n\t\t\tthis._logCreateInstance(instance, isInAuxWindow);\n\t\t\tthis._store.delete(store);\n\t\t}));\n\t}\n\n\tprivate _logCreateInstance(instance: ITerminalInstance, isInAuxWindow: boolean): void {\n\t\tconst slc = instance.shellLaunchConfig;\n\t\tconst commandDetection = instance.capabilities.get(TerminalCapability.CommandDetection);\n\n\t\ttype TerminalCreationTelemetryData = {\n\t\t\tlocation: string;\n\n\t\t\tshellType: TelemetryTrustedValue<string>;\n\t\t\tpromptType: TelemetryTrustedValue<string | undefined>;\n\n\t\t\tisCustomPtyImplementation: boolean;\n\t\t\tisExtensionOwnedTerminal: boolean;\n\t\t\tisLoginShell: boolean;\n\t\t\tisReconnect: boolean;\n\t\t\thasRemoteAuthority: boolean;\n\n\t\t\tshellIntegrationQuality: number;\n\t\t\tshellIntegrationInjected: boolean;\n\t\t\tshellIntegrationInjectionFailureReason: ShellIntegrationInjectionFailureReason | undefined;\n\n\t\t\tterminalSessionId: string;\n\t\t};\n\t\ttype TerminalCreationTelemetryClassification = {\n\t\t\towner: 'tyriar';\n\t\t\tcomment: 'Track details about terminal creation, such as the shell type';\n\n\t\t\tlocation: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The location of the terminal.' };\n\n\t\t\tshellType: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The detected shell type for the terminal.' };\n\t\t\tpromptType: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The detected prompt type for the terminal.' };\n\n\t\t\tisCustomPtyImplementation: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the terminal was using a custom PTY implementation.' };\n\t\t\tisExtensionOwnedTerminal: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the terminal was created by an extension.' };\n\t\t\tisLoginShell: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the arguments contain -l or --login.' };\n\t\t\tisReconnect: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the terminal is reconnecting to an existing instance.' };\n\t\t\thasRemoteAuthority: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the terminal has a remote authority, this is likely a connection terminal when undefined in a window with a remote authority.' };\n\n\t\t\tshellIntegrationQuality: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The shell integration quality (rich=2, basic=1 or none=0).' };\n\t\t\tshellIntegrationInjected: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Whether the shell integration script was injected.' };\n\t\t\tshellIntegrationInjectionFailureReason: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Info about shell integration injection.' };\n\n\t\t\tterminalSessionId: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The session ID of the terminal instance.' };\n\t\t};\n\t\tthis._telemetryService.publicLog2<TerminalCreationTelemetryData, TerminalCreationTelemetryClassification>('terminal/createInstance', {\n\t\t\tlocation: (instance.target === TerminalLocation.Panel\n\t\t\t\t? 'view'\n\t\t\t\t: instance.target === TerminalLocation.Editor\n\t\t\t\t\t? (isInAuxWindow ? 'editor-auxwindow' : 'editor')\n\t\t\t\t\t: 'unknown'),\n\n\t\t\tshellType: new TelemetryTrustedValue(getSanitizedShellType(slc)),\n\t\t\tpromptType: new TelemetryTrustedValue(instance.capabilities.get(TerminalCapability.PromptTypeDetection)?.promptType),\n\n\t\t\tisCustomPtyImplementation: !!slc.customPtyImplementation,\n\t\t\tisExtensionOwnedTerminal: !!slc.isExtensionOwnedTerminal,\n\t\t\tisLoginShell: (isString(slc.args) ? slc.args.split(' ') : slc.args)?.some(arg => arg === '-l' || arg === '--login') ?? false,\n\t\t\tisReconnect: !!slc.attachPersistentProcess,\n\t\t\thasRemoteAuthority: instance.hasRemoteAuthority,\n\n\t\t\tshellIntegrationQuality: commandDetection?.hasRichCommandDetection ? 2 : commandDetection ? 1 : 0,\n\t\t\tshellIntegrationInjected: instance.usedShellIntegrationInjection,\n\t\t\tshellIntegrationInjectionFailureReason: instance.shellIntegrationInjectionFailureReason,\n\t\t\tterminalSessionId: instance.sessionId,\n\t\t});\n\t}\n}\n\n// #region Shell Type\n\nconst enum AllowedShellType {\n\tUnknown = 'unknown',\n\n\t// Windows only\n\tCommandPrompt = 'cmd',\n\tCygwin = 'cygwin-bash',\n\tGitBash = 'git-bash',\n\tMsys2 = 'msys2-bash',\n\tWindowsPowerShell = 'windows-powershell',\n\tWsl = 'wsl',\n\n\n\t// Common Unix shells\n\tBash = 'bash',\n\tFish = 'fish',\n\tPwsh = 'pwsh',\n\tPwshPreview = 'pwsh-preview',\n\tSh = 'sh',\n\tSsh = 'ssh',\n\tTmux = 'tmux',\n\tZsh = 'zsh',\n\n\t// More shells\n\tAmm = 'amm',\n\tAsh = 'ash',\n\tCsh = 'csh',\n\tDash = 'dash',\n\tElvish = 'elvish',\n\tIon = 'ion',\n\tKsh = 'ksh',\n\tMksh = 'mksh',\n\tMsh = 'msh',\n\tNuShell = 'nu',\n\tPlan9Shell = 'rc',\n\tSchemeShell = 'scsh',\n\tTcsh = 'tcsh',\n\tTermux = 'termux',\n\tXonsh = 'xonsh',\n\n\t// Lanugage REPLs\n\t// These are expected to be very low since they are not typically the default shell\n\tClojure = 'clj',\n\tCommonLispSbcl = 'sbcl',\n\tCrystal = 'crystal',\n\tDeno = 'deno',\n\tElixir = 'iex',\n\tErlang = 'erl',\n\tFSharp = 'fsi',\n\tGo = 'go',\n\tHaskellGhci = 'ghci',\n\tJava = 'jshell',\n\tJulia = 'julia',\n\tLua = 'lua',\n\tNode = 'node',\n\tOcaml = 'ocaml',\n\tPerl = 'perl',\n\tPhp = 'php',\n\tPrologSwipl = 'swipl',\n\tPython = 'python',\n\tR = 'R',\n\tRubyIrb = 'irb',\n\tScala = 'scala',\n\tSchemeRacket = 'racket',\n\tSmalltalkGnu = 'gst',\n\tSmalltalkPharo = 'pharo',\n\tTcl = 'tclsh',\n\tTsNode = 'ts-node',\n}\n\n// Types that match the executable name directly\nconst shellTypeExecutableAllowList: Set<string> = new Set([\n\t// Windows only\n\tAllowedShellType.CommandPrompt,\n\tAllowedShellType.Wsl,\n\n\t// Common Unix shells\n\tAllowedShellType.Bash,\n\tAllowedShellType.Fish,\n\tAllowedShellType.Pwsh,\n\tAllowedShellType.Sh,\n\tAllowedShellType.Ssh,\n\tAllowedShellType.Tmux,\n\tAllowedShellType.Zsh,\n\n\t// More shells\n\tAllowedShellType.Amm,\n\tAllowedShellType.Ash,\n\tAllowedShellType.Csh,\n\tAllowedShellType.Dash,\n\tAllowedShellType.Elvish,\n\tAllowedShellType.Ion,\n\tAllowedShellType.Ksh,\n\tAllowedShellType.Mksh,\n\tAllowedShellType.Msh,\n\tAllowedShellType.NuShell,\n\tAllowedShellType.Plan9Shell,\n\tAllowedShellType.SchemeShell,\n\tAllowedShellType.Tcsh,\n\tAllowedShellType.Termux,\n\tAllowedShellType.Xonsh,\n\n\t// Lanugage REPLs\n\tAllowedShellType.Clojure,\n\tAllowedShellType.CommonLispSbcl,\n\tAllowedShellType.Crystal,\n\tAllowedShellType.Deno,\n\tAllowedShellType.Elixir,\n\tAllowedShellType.Erlang,\n\tAllowedShellType.FSharp,\n\tAllowedShellType.Go,\n\tAllowedShellType.HaskellGhci,\n\tAllowedShellType.Java,\n\tAllowedShellType.Julia,\n\tAllowedShellType.Lua,\n\tAllowedShellType.Node,\n\tAllowedShellType.Ocaml,\n\tAllowedShellType.Perl,\n\tAllowedShellType.Php,\n\tAllowedShellType.PrologSwipl,\n\tAllowedShellType.Python,\n\tAllowedShellType.R,\n\tAllowedShellType.RubyIrb,\n\tAllowedShellType.Scala,\n\tAllowedShellType.SchemeRacket,\n\tAllowedShellType.SmalltalkGnu,\n\tAllowedShellType.SmalltalkPharo,\n\tAllowedShellType.Tcl,\n\tAllowedShellType.TsNode,\n]) satisfies Set<AllowedShellType>;\n\n// Dynamic executables that map to a single type\nconst shellTypeExecutableRegexAllowList: { regex: RegExp; type: AllowedShellType }[] = [\n\t{ regex: /^(?:pwsh|powershell)-preview$/i, type: AllowedShellType.PwshPreview },\n\t{ regex: /^python(?:\\d+(?:\\.\\d+)?)?$/i, type: AllowedShellType.Python },\n];\n\n// Path-based look ups\nconst shellTypePathRegexAllowList: { regex: RegExp; type: AllowedShellType }[] = [\n\t// Cygwin uses bash.exe, so look up based on the path\n\t{ regex: /\\\\Cygwin(?:64)?\\\\.+\\\\bash\\.exe$/i, type: AllowedShellType.Cygwin },\n\t// Git bash uses bash.exe, so look up based on the path\n\t{ regex: /\\\\Git\\\\.+\\\\bash\\.exe$/i, type: AllowedShellType.GitBash },\n\t// Msys2 uses bash.exe, so look up based on the path\n\t{ regex: /\\\\msys(?:32|64)\\\\.+\\\\(?:bash|msys2)\\.exe$/i, type: AllowedShellType.Msys2 },\n\t// WindowsPowerShell should always be installed on this path, we cannot just look at the\n\t// executable name since powershell is the CLI on other platforms sometimes (eg. snap package)\n\t{ regex: /\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe$/i, type: AllowedShellType.WindowsPowerShell },\n\t// WSL executables will represent some other shell in the end, but it's difficult to determine\n\t// when we log\n\t{ regex: /\\\\Windows\\\\(?:System32|SysWOW64|Sysnative)\\\\(?:bash|wsl)\\.exe$/i, type: AllowedShellType.Wsl },\n];\n\nfunction getSanitizedShellType(slc: IShellLaunchConfig): AllowedShellType {\n\tif (!slc.executable) {\n\t\treturn AllowedShellType.Unknown;\n\t}\n\tconst executableFile = basename(slc.executable);\n\tconst executableFileWithoutExt = executableFile.replace(/\\.[^\\.]+$/, '');\n\tfor (const entry of shellTypePathRegexAllowList) {\n\t\tif (entry.regex.test(slc.executable)) {\n\t\t\treturn entry.type;\n\t\t}\n\t}\n\tfor (const entry of shellTypeExecutableRegexAllowList) {\n\t\tif (entry.regex.test(executableFileWithoutExt)) {\n\t\t\treturn entry.type;\n\t\t}\n\t}\n\tif ((shellTypeExecutableAllowList).has(executableFileWithoutExt)) {\n\t\treturn executableFileWithoutExt as AllowedShellType;\n\t}\n\treturn AllowedShellType.Unknown;\n}\n\n// #endregion Shell Type\n"]}