{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminal/browser/terminal.ts","vs/workbench/contrib/terminal/browser/terminal.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAShG,OAAO,EAAE,eAAe,EAAE,MAAM,4DAA4D,CAAC;AAwB7F,OAAO,EAAE,QAAQ,EAAqB,MAAM,kCAAkC,CAAC;AAE/E,MAAM,CAAC,MAAM,gBAAgB,GAAG,eAAe,CAAmB,iBAAiB,CAAC,CAAC;AACrF,MAAM,CAAC,MAAM,6BAA6B,GAAG,eAAe,CAAgC,8BAA8B,CAAC,CAAC;AAC5H,MAAM,CAAC,MAAM,sBAAsB,GAAG,eAAe,CAAyB,uBAAuB,CAAC,CAAC;AACvG,MAAM,CAAC,MAAM,uBAAuB,GAAG,eAAe,CAA0B,wBAAwB,CAAC,CAAC;AAC1G,MAAM,CAAC,MAAM,qBAAqB,GAAG,eAAe,CAAwB,sBAAsB,CAAC,CAAC;AACpG,MAAM,CAAC,MAAM,wBAAwB,GAAG,eAAe,CAA2B,yBAAyB,CAAC,CAAC;AAC7G,MAAM,CAAC,MAAM,oBAAoB,GAAG,eAAe,CAAuB,qBAAqB,CAAC,CAAC;AA2NjG,MAAM,CAAN,IAAkB,SAKjB;AALD,WAAkB,SAAS;IAC1B,yCAAQ,CAAA;IACR,2CAAS,CAAA;IACT,qCAAM,CAAA;IACN,yCAAQ,CAAA;AACT,CAAC,EALiB,SAAS,KAAT,SAAS,QAK1B;AAsDD,MAAM,CAAN,IAAkB,uBAGjB;AAHD,WAAkB,uBAAuB;IACxC,iFAAU,CAAA;IACV,+EAAS,CAAA;AACV,CAAC,EAHiB,uBAAuB,KAAvB,uBAAuB,QAGxC;AAmFD,MAAM,CAAC,MAAM,0BAA0B,GAAG,CAAC,CAAgD,EAAkC,EAAE,CAAC,CAAC,QAAQ,CAAE,CAAuB,CAAC,UAAU,CAAC,CAAC;AA8J/K,MAAM,OAAO,0BAA2B,SAAQ,UAAU;CAEzD;AAwBD,MAAM,CAAC,MAAM,gBAAgB,GAAG,gBAAgB,CAAC;AAwpBjD,MAAM,CAAN,IAAkB,sBAEjB;AAFD,WAAkB,sBAAsB;IACvC,uGAA4B,CAAA;AAC7B,CAAC,EAFiB,sBAAsB,KAAtB,sBAAsB,QAEvC;AA+MD,MAAM,CAAN,IAAkB,WAIjB;AAJD,WAAkB,WAAW;IAC5B,mDAAW,CAAA;IACX,iDAAU,CAAA;IACV,iDAAU,CAAA;AACX,CAAC,EAJiB,WAAW,KAAX,WAAW,QAI5B;AAED,MAAM,CAAN,IAAkB,qBAEjB;AAFD,WAAkB,qBAAqB;IACtC,gDAAuB,CAAA;AACxB,CAAC,EAFiB,qBAAqB,KAArB,qBAAqB,QAEtC","file":"terminal.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDimension } from '../../../../base/browser/dom.js';\nimport { Orientation } from '../../../../base/browser/ui/splitview/splitview.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { Event, IDynamicListEventMultiplexer, type DynamicListEventMultiplexer } from '../../../../base/common/event.js';\nimport { DisposableStore, IDisposable, type IReference } from '../../../../base/common/lifecycle.js';\nimport { OperatingSystem } from '../../../../base/common/platform.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IKeyMods } from '../../../../platform/quickinput/common/quickInput.js';\nimport { IMarkProperties, ITerminalCapabilityImplMap, ITerminalCapabilityStore, ITerminalCommand, TerminalCapability } from '../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { IMergedEnvironmentVariableCollection } from '../../../../platform/terminal/common/environmentVariable.js';\nimport { IExtensionTerminalProfile, IReconnectionProperties, IShellIntegration, IShellLaunchConfig, ITerminalBackend, ITerminalDimensions, ITerminalLaunchError, ITerminalProfile, ITerminalTabLayoutInfoById, TerminalExitReason, TerminalIcon, TerminalLocation, TerminalShellType, TerminalType, TitleEventSource, WaitOnExitValue, type IDecorationAddon, type ShellIntegrationInjectionFailureReason } from '../../../../platform/terminal/common/terminal.js';\nimport { IColorTheme } from '../../../../platform/theme/common/themeService.js';\nimport { IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditableData } from '../../../common/views.js';\nimport { ITerminalStatusList } from './terminalStatusList.js';\nimport { XtermTerminal } from './xterm/xtermTerminal.js';\nimport { IRegisterContributedProfileArgs, IRemoteTerminalAttachTarget, IStartExtensionTerminalRequest, ITerminalConfiguration, ITerminalFont, ITerminalProcessExtHostProxy, ITerminalProcessInfo } from '../common/terminal.js';\nimport type { IMarker, ITheme, Terminal as RawXtermTerminal, IBufferRange, IMarker as IXtermMarker } from '@xterm/xterm';\nimport { ScrollPosition } from './xterm/markNavigationAddon.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { GroupIdentifier } from '../../../common/editor.js';\nimport { ACTIVE_GROUP_TYPE, AUX_WINDOW_GROUP_TYPE, SIDE_GROUP_TYPE } from '../../../services/editor/common/editorService.js';\nimport type { ICurrentPartialCommand } from '../../../../platform/terminal/common/capabilities/commandDetection/terminalCommand.js';\nimport type { IXtermCore } from './xterm-private.js';\nimport type { IMenu } from '../../../../platform/actions/common/actions.js';\nimport type { IProgressState } from '@xterm/addon-progress';\nimport type { IEditorOptions } from '../../../../platform/editor/common/editor.js';\nimport type { TerminalEditorInput } from './terminalEditorInput.js';\nimport type { MaybePromise } from '../../../../base/common/async.js';\nimport { isNumber, type SingleOrMany } from '../../../../base/common/types.js';\n\nexport const ITerminalService = createDecorator<ITerminalService>('terminalService');\nexport const ITerminalConfigurationService = createDecorator<ITerminalConfigurationService>('terminalConfigurationService');\nexport const ITerminalEditorService = createDecorator<ITerminalEditorService>('terminalEditorService');\nexport const ITerminalEditingService = createDecorator<ITerminalEditingService>('terminalEditingService');\nexport const ITerminalGroupService = createDecorator<ITerminalGroupService>('terminalGroupService');\nexport const ITerminalInstanceService = createDecorator<ITerminalInstanceService>('terminalInstanceService');\nexport const ITerminalChatService = createDecorator<ITerminalChatService>('terminalChatService');\n\n/**\n * A terminal contribution that gets created whenever a terminal is created. A contribution has\n * access to the process manager through the constructor and provides a method for when xterm.js has\n * been initialized.\n */\nexport interface ITerminalContribution extends IDisposable {\n\tlayout?(xterm: IXtermTerminal & { raw: RawXtermTerminal }, dimension: IDimension): void;\n\txtermOpen?(xterm: IXtermTerminal & { raw: RawXtermTerminal }): void;\n\txtermReady?(xterm: IXtermTerminal & { raw: RawXtermTerminal }): void;\n\n\thandleMouseEvent?(event: MouseEvent): MaybePromise<{ handled: boolean } | void>;\n}\n\n/**\n * A service used to create instances or fetch backends, this services allows services that\n * ITerminalService depends on to also create instances.\n *\n * **This service is intended to only be used within the terminal contrib.**\n */\nexport interface ITerminalInstanceService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event that's fired when a terminal instance is created.\n\t */\n\treadonly onDidCreateInstance: Event<ITerminalInstance>;\n\n\t/**\n\t * An event that's fired when a new backend is registered.\n\t */\n\treadonly onDidRegisterBackend: Event<ITerminalBackend>;\n\n\t/**\n\t * Helper function to convert a shell launch config, a profile or undefined into its equivalent\n\t * shell launch config.\n\t * @param shellLaunchConfigOrProfile A shell launch config, a profile or undefined\n\t * @param cwd A cwd to override.\n\t */\n\tconvertProfileToShellLaunchConfig(shellLaunchConfigOrProfile?: IShellLaunchConfig | ITerminalProfile, cwd?: string | URI): IShellLaunchConfig;\n\n\t/**\n\t * Create a new terminal instance.\n\t * @param launchConfig The shell launch config.\n\t * @param target The target of the terminal.\n\t */\n\tcreateInstance(launchConfig: IShellLaunchConfig, target: TerminalLocation, editorOptions?: TerminalEditorLocation): ITerminalInstance;\n\n\t/**\n\t * Gets the registered backend for a remote authority (undefined = local). This is a convenience\n\t * method to avoid using the more verbose fetching from the registry.\n\t * @param remoteAuthority The remote authority of the backend.\n\t */\n\tgetBackend(remoteAuthority?: string): Promise<ITerminalBackend | undefined>;\n\n\tgetRegisteredBackends(): IterableIterator<ITerminalBackend>;\n\tdidRegisterBackend(backend: ITerminalBackend): void;\n}\n\n/**\n * Service enabling communication between the chat tool implementation in terminal contrib and workbench contribs.\n * Acts as a communication mechanism for chat-related terminal features.\n */\nexport interface IChatTerminalToolProgressPart {\n\treadonly elementIndex: number;\n\treadonly contentIndex: number;\n\tfocusTerminal(): Promise<void>;\n\ttoggleOutputFromKeyboard(): Promise<void>;\n\tfocusOutput(): void;\n\tgetCommandAndOutputAsText(): string | undefined;\n}\n\nexport interface ITerminalChatService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fired when a terminal instance is registered for a tool session id. This can happen after\n\t * the chat UI first renders, enabling late binding of the focus action.\n\t */\n\treadonly onDidRegisterTerminalInstanceWithToolSession: Event<ITerminalInstance>;\n\n\t/**\n\t * Associate a tool session id with a terminal instance. The association is automatically\n\t * cleared when the instance is disposed.\n\t */\n\tregisterTerminalInstanceWithToolSession(terminalToolSessionId: string | undefined, instance: ITerminalInstance): void;\n\n\t/**\n\t * Resolve a terminal instance by its tool session id.\n\t * @param terminalToolSessionId The tool session id provided in toolSpecificData.\n\t * If no tool session ID is provided, we do nothing.\n\t */\n\tgetTerminalInstanceByToolSessionId(terminalToolSessionId: string): Promise<ITerminalInstance | undefined>;\n\n\t/**\n\t * Returns the list of terminal instances that have been registered with a tool session id.\n\t * This is used for surfacing tool-driven/background terminals in UI (eg. quick picks).\n\t */\n\tgetToolSessionTerminalInstances(hiddenOnly?: boolean): readonly ITerminalInstance[];\n\n\t/**\n\t * Returns the tool session ID for a given terminal instance, if it has been registered.\n\t * @param instance The terminal instance to look up\n\t * @returns The tool session ID if found, undefined otherwise\n\t */\n\tgetToolSessionIdForInstance(instance: ITerminalInstance): string | undefined;\n\n\t/**\n\t * Associate a chat session ID with a terminal instance. This is used to retrieve the chat\n\t * session title for display purposes.\n\t * @param chatSessionId The chat session ID\n\t * @param instance The terminal instance\n\t */\n\tregisterTerminalInstanceWithChatSession(chatSessionId: string, instance: ITerminalInstance): void;\n\n\t/**\n\t * Returns the chat session ID for a given terminal instance, if it has been registered.\n\t * @param instance The terminal instance to look up\n\t * @returns The chat session ID if found, undefined otherwise\n\t */\n\tgetChatSessionIdForInstance(instance: ITerminalInstance): string | undefined;\n\n\t/**\n\t * Check if a terminal is a background terminal (tool-driven terminal that may be hidden from\n\t * normal UI).\n\t * @param terminalToolSessionId The tool session ID to check, if provided\n\t * @returns True if the terminal is a background terminal, false otherwise\n\t */\n\tisBackgroundTerminal(terminalToolSessionId?: string): boolean;\n\n\t/**\n\t * Register a chat terminal tool progress part for tracking and focus management.\n\t * @param part The progress part to register\n\t * @returns A disposable that unregisters the progress part when disposed\n\t */\n\tregisterProgressPart(part: IChatTerminalToolProgressPart): IDisposable;\n\n\t/**\n\t * Set the currently focused progress part.\n\t * @param part The progress part to focus\n\t */\n\tsetFocusedProgressPart(part: IChatTerminalToolProgressPart): void;\n\n\t/**\n\t * Clear the focused state from a progress part.\n\t * @param part The progress part to clear focus from\n\t */\n\tclearFocusedProgressPart(part: IChatTerminalToolProgressPart): void;\n\n\t/**\n\t * Get the currently focused progress part, if any.\n\t * @returns The focused progress part or undefined if none is focused\n\t */\n\tgetFocusedProgressPart(): IChatTerminalToolProgressPart | undefined;\n\n\t/**\n\t * Get the most recently registered progress part, if any.\n\t * @returns The most recent progress part or undefined if none exist\n\t */\n\tgetMostRecentProgressPart(): IChatTerminalToolProgressPart | undefined;\n\n\t/**\n\t * Enable or disable auto approval for all commands in a specific session.\n\t * @param chatSessionId The chat session ID\n\t * @param enabled Whether to enable or disable session auto approval\n\t */\n\tsetChatSessionAutoApproval(chatSessionId: string, enabled: boolean): void;\n\n\t/**\n\t * Check if a session has auto approval enabled for all commands.\n\t * @param chatSessionId The chat session ID\n\t * @returns True if the session has auto approval enabled\n\t */\n\thasChatSessionAutoApproval(chatSessionId: string): boolean;\n}\n\n/**\n * A service responsible for managing terminal editing state and functionality. This includes\n * tracking which terminal is currently being edited and managing editable data associated with\n * terminal instances.\n */\nexport interface ITerminalEditingService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Get the editable data for a terminal instance.\n\t * @param instance The terminal instance.\n\t * @returns The editable data if the instance is editable, undefined otherwise.\n\t */\n\tgetEditableData(instance: ITerminalInstance): IEditableData | undefined;\n\n\t/**\n\t * Set the editable data for a terminal instance.\n\t * @param instance The terminal instance.\n\t * @param data The editable data to set, or null to clear.\n\t */\n\tsetEditable(instance: ITerminalInstance, data: IEditableData | null): void;\n\n\t/**\n\t * Check if a terminal instance is currently editable.\n\t * @param instance The terminal instance to check.\n\t * @returns True if the instance is editable, false otherwise.\n\t */\n\tisEditable(instance: ITerminalInstance | undefined): boolean;\n\n\t/**\n\t * Get the terminal instance that is currently being edited.\n\t * @returns The terminal instance being edited, or undefined if none.\n\t */\n\tgetEditingTerminal(): ITerminalInstance | undefined;\n\n\t/**\n\t * Set the terminal instance that is currently being edited.\n\t * @param instance The terminal instance to set as editing, or undefined to clear.\n\t */\n\tsetEditingTerminal(instance: ITerminalInstance | undefined): void;\n}\n\nexport const enum Direction {\n\tLeft = 0,\n\tRight = 1,\n\tUp = 2,\n\tDown = 3\n}\n\nexport interface IQuickPickTerminalObject {\n\tconfig: IRegisterContributedProfileArgs | ITerminalProfile | { profile: IExtensionTerminalProfile; options: { icon?: string; color?: string } } | undefined;\n\tkeyMods: IKeyMods | undefined;\n}\n\nexport interface IMarkTracker {\n\tscrollToPreviousMark(scrollPosition?: ScrollPosition, retainSelection?: boolean, skipEmptyCommands?: boolean): void;\n\tscrollToNextMark(): void;\n\tselectToPreviousMark(): void;\n\tselectToNextMark(): void;\n\tselectToPreviousLine(): void;\n\tselectToNextLine(): void;\n\tclear(): void;\n\tscrollToClosestMarker(startMarkerId: string, endMarkerId?: string, highlight?: boolean | undefined): void;\n\n\tscrollToLine(line: number, position: ScrollPosition): void;\n\trevealCommand(command: ITerminalCommand | ICurrentPartialCommand | URI, position?: ScrollPosition): void;\n\trevealRange(range: IBufferRange): void;\n\tregisterTemporaryDecoration(marker: IMarker, endMarker: IMarker | undefined, showOutline: boolean): void;\n\tshowCommandGuide(command: ITerminalCommand | undefined): void;\n\n\tsaveScrollState(): void;\n\trestoreScrollState(): void;\n}\n\nexport interface ITerminalGroup {\n\tactiveInstance: ITerminalInstance | undefined;\n\tterminalInstances: ITerminalInstance[];\n\ttitle: string;\n\treadonly hadFocusOnExit: boolean;\n\n\treadonly onDidDisposeInstance: Event<ITerminalInstance>;\n\treadonly onDisposed: Event<ITerminalGroup>;\n\treadonly onInstancesChanged: Event<void>;\n\treadonly onPanelOrientationChanged: Event<Orientation>;\n\n\tfocusPreviousPane(): void;\n\tfocusNextPane(): void;\n\tresizePane(direction: Direction): void;\n\tresizePanes(relativeSizes: number[]): void;\n\tsetActiveInstanceByIndex(index: number, force?: boolean): void;\n\tattachToElement(element: HTMLElement): void;\n\taddInstance(instance: ITerminalInstance): void;\n\tremoveInstance(instance: ITerminalInstance): void;\n\tmoveInstance(instances: SingleOrMany<ITerminalInstance>, index: number, position: 'before' | 'after'): void;\n\tsetVisible(visible: boolean): void;\n\tlayout(width: number, height: number): void;\n\taddDisposable(disposable: IDisposable): void;\n\tsplit(shellLaunchConfig: IShellLaunchConfig): ITerminalInstance;\n\tgetLayoutInfo(isActive: boolean): ITerminalTabLayoutInfoById;\n}\n\nexport const enum TerminalConnectionState {\n\tConnecting,\n\tConnected\n}\n\nexport interface IDetachedXTermOptions {\n\tcols: number;\n\trows: number;\n\tcolorProvider: IXtermColorProvider;\n\tcapabilities?: ITerminalCapabilityStore;\n\treadonly?: boolean;\n\tprocessInfo: ITerminalProcessInfo;\n}\n\n/**\n * A generic interface implemented in both the {@link ITerminalInstance} (an\n * interface used for terminals attached to the terminal panel or editor) and\n * {@link IDetachedTerminalInstance} (a terminal used elsewhere in VS Code UI).\n */\nexport interface IBaseTerminalInstance {\n\treadonly capabilities: ITerminalCapabilityStore;\n\n\t/**\n\t * DOM element the terminal is mounted in.\n\t */\n\treadonly domElement?: HTMLElement;\n\n\t/**\n\t * Current selection in the terminal.\n\t */\n\treadonly selection: string | undefined;\n\n\t/**\n\t * Check if anything is selected in terminal.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Clear current selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Focuses the terminal instance if it's able to (the xterm.js instance must exist).\n\t *\n\t * @param force Force focus even if there is a selection.\n\t */\n\tfocus(force?: boolean): void;\n\n\t/**\n\t * Force the scroll bar to be visible until {@link resetScrollbarVisibility} is called.\n\t */\n\tforceScrollbarVisibility(): void;\n\n\t/**\n\t * Resets the scroll bar to only be visible when needed, this does nothing unless\n\t * {@link forceScrollbarVisibility} was called.\n\t */\n\tresetScrollbarVisibility(): void;\n\n\t/**\n\t * Gets a terminal contribution by its ID.\n\t */\n\tgetContribution<T extends ITerminalContribution>(id: string): T | null;\n}\n\n/**\n * A {@link ITerminalInstance}-like object that emulates a subset of\n * capabilities. This instance is returned from {@link ITerminalService.createDetachedTerminal}\n * to represent terminals that appear in other parts of the VS Code UI outside\n * of the \"Terminal\" view or editors.\n */\nexport interface IDetachedTerminalInstance extends IDisposable, IBaseTerminalInstance {\n\treadonly xterm: IDetachedXtermTerminal;\n\n\t/**\n\t * Attached the terminal to the given element. This should be preferred over\n\t * calling {@link IXtermTerminal.attachToElement} so that extra DOM elements\n\t * for contributions are initialized.\n\t *\n\t * @param container Container the terminal will be rendered in\n\t * @param options Additional options for mounting the terminal in an element\n\t */\n\tattachToElement(container: HTMLElement, options?: Partial<IXtermAttachToElementOptions>): void;\n}\n\nexport const isDetachedTerminalInstance = (t: ITerminalInstance | IDetachedTerminalInstance): t is IDetachedTerminalInstance => !isNumber((t as ITerminalInstance).instanceId);\n\nexport interface ITerminalService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all terminal instances, including editor, terminal view (group), and background instances. */\n\treadonly instances: readonly ITerminalInstance[];\n\n\treadonly foregroundInstances: readonly ITerminalInstance[];\n\n\t/** Gets detached terminal instances created via {@link createDetachedXterm}. */\n\treadonly detachedInstances: Iterable<IDetachedTerminalInstance>;\n\n\treadonly isProcessSupportRegistered: boolean;\n\treadonly connectionState: TerminalConnectionState;\n\treadonly whenConnected: Promise<void>;\n\t/** The number of restored terminal groups on startup. */\n\treadonly restoredGroupCount: number;\n\n\treadonly onDidCreateInstance: Event<ITerminalInstance>;\n\treadonly onDidChangeInstanceDimensions: Event<ITerminalInstance>;\n\treadonly onDidRequestStartExtensionTerminal: Event<IStartExtensionTerminalRequest>;\n\treadonly onDidRegisterProcessSupport: Event<void>;\n\treadonly onDidChangeConnectionState: Event<void>;\n\n\t// Group events\n\treadonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;\n\n\t// Multiplexed events\n\treadonly onAnyInstanceData: Event<{ instance: ITerminalInstance; data: string }>;\n\treadonly onAnyInstanceDataInput: Event<ITerminalInstance>;\n\treadonly onAnyInstanceIconChange: Event<{ instance: ITerminalInstance; userInitiated: boolean }>;\n\treadonly onAnyInstanceMaximumDimensionsChange: Event<ITerminalInstance>;\n\treadonly onAnyInstancePrimaryStatusChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceProcessIdReady: Event<ITerminalInstance>;\n\treadonly onAnyInstanceSelectionChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceTitleChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceShellTypeChanged: Event<ITerminalInstance>;\n\treadonly onAnyInstanceAddedCapabilityType: Event<TerminalCapability>;\n\n\t/**\n\t * Creates a terminal.\n\t * @param options The options to create the terminal with, when not specified the default\n\t * profile will be used at the default target.\n\t */\n\tcreateTerminal(options?: ICreateTerminalOptions): Promise<ITerminalInstance>;\n\n\t/**\n\t * Creates and focuses a terminal.\n\t * @param options The options to create the terminal with, when not specified the default\n\t * profile will be used at the default target.\n\t */\n\tcreateAndFocusTerminal(options?: ICreateTerminalOptions): Promise<ITerminalInstance>;\n\n\t/**\n\t * Creates a detached xterm instance which is not attached to the DOM or\n\t * tracked as a terminal instance.\n\t * @params options The options to create the terminal with\n\t */\n\tcreateDetachedTerminal(options: IDetachedXTermOptions): Promise<IDetachedTerminalInstance>;\n\n\t/**\n\t * Creates a raw terminal instance, this should not be used outside of the terminal part.\n\t */\n\tgetInstanceFromId(terminalId: number): ITerminalInstance | undefined;\n\n\t/**\n\t * An owner of terminals might be created after reconnection has occurred,\n\t * so store them to be requested/adopted later\n\t * @deprecated Use {@link onDidReconnectToSession}\n\t */\n\tgetReconnectedTerminals(reconnectionOwner: string): ITerminalInstance[] | undefined;\n\n\tgetActiveOrCreateInstance(options?: { acceptsInput?: boolean }): Promise<ITerminalInstance>;\n\trevealTerminal(source: ITerminalInstance, preserveFocus?: boolean): Promise<void>;\n\t/**\n\t * @param instance\n\t * @param suppressSetActive Do not set the active instance when there is only one terminal\n\t * @param forceSaveState Used when the window is shutting down and we need to reveal and save hideFromUser terminals\n\t */\n\tshowBackgroundTerminal(instance: ITerminalInstance, suppressSetActive?: boolean): Promise<void>;\n\trevealActiveTerminal(preserveFocus?: boolean): Promise<void>;\n\tmoveToEditor(source: ITerminalInstance, group?: GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE | AUX_WINDOW_GROUP_TYPE): void;\n\tmoveIntoNewEditor(source: ITerminalInstance): void;\n\tmoveToTerminalView(source: ITerminalInstance | URI): Promise<void>;\n\tgetPrimaryBackend(): ITerminalBackend | undefined;\n\tsetNextCommandId(id: number, commandLine: string, commandId: string): Promise<void>;\n\n\t/**\n\t * Fire the onActiveTabChanged event, this will trigger the terminal dropdown to be updated,\n\t * among other things.\n\t */\n\trefreshActiveGroup(): void;\n\n\tregisterProcessSupport(isSupported: boolean): void;\n\n\tshowProfileQuickPick(type: 'setDefault' | 'createInstance', cwd?: string | URI): Promise<ITerminalInstance | undefined>;\n\n\tsetContainers(panelContainer: HTMLElement, terminalContainer: HTMLElement): void;\n\n\trequestStartExtensionTerminal(proxy: ITerminalProcessExtHostProxy, cols: number, rows: number): Promise<ITerminalLaunchError | undefined>;\n\tisAttachedToTerminal(remoteTerm: IRemoteTerminalAttachTarget): boolean;\n\tsafeDisposeTerminal(instance: ITerminalInstance): Promise<void>;\n\n\tgetDefaultInstanceHost(): ITerminalInstanceHost;\n\tgetInstanceHost(target: ITerminalLocationOptions | undefined): Promise<ITerminalInstanceHost>;\n\n\tresolveLocation(location?: ITerminalLocationOptions): Promise<TerminalLocation | undefined>;\n\tsetNativeDelegate(nativeCalls: ITerminalServiceNativeDelegate): void;\n\n\t/**\n\t * Creates an instance event listener that listens to all instances, dynamically adding new\n\t * instances and removing old instances as needed.\n\t * @param getEvent Maps the instance to the event.\n\t */\n\tcreateOnInstanceEvent<T>(getEvent: (instance: ITerminalInstance) => Event<T>): DynamicListEventMultiplexer<ITerminalInstance, T>;\n\n\t/**\n\t * Creates a capability event listener that listens to capabilities on all instances,\n\t * dynamically adding and removing instances and capabilities as needed.\n\t * @param capabilityId The capability type to listen to an event on.\n\t * @param getEvent Maps the capability to the event.\n\t */\n\tcreateOnInstanceCapabilityEvent<T extends TerminalCapability, K>(capabilityId: T, getEvent: (capability: ITerminalCapabilityImplMap[T]) => Event<K>): IDynamicListEventMultiplexer<{ instance: ITerminalInstance; data: K }>;\n\n\t/**\n\t * Reveals the terminal and, if provided, scrolls to the command mark.\n\t * @param resource the terminal resource\n\t */\n\topenResource(resource: URI): void;\n}\n\n/**\n * A service that provides convenient access to the terminal configuration and derived values.\n */\nexport interface ITerminalConfigurationService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * A typed and partially validated representation of the terminal configuration.\n\t */\n\treadonly config: Readonly<ITerminalConfiguration>;\n\n\t/**\n\t * The default location for terminals.\n\t */\n\treadonly defaultLocation: TerminalLocation;\n\n\t/**\n\t * Fires when something within the terminal configuration changes.\n\t */\n\treadonly onConfigChanged: Event<void>;\n\n\tsetPanelContainer(panelContainer: HTMLElement): void;\n\tconfigFontIsMonospace(): boolean;\n\tgetFont(w: Window, xtermCore?: IXtermCore, excludeDimensions?: boolean): ITerminalFont;\n}\n\nexport class TerminalLinkQuickPickEvent extends MouseEvent {\n\n}\nexport interface ITerminalServiceNativeDelegate {\n\tgetWindowCount(): Promise<number>;\n}\n\n/**\n * This service is responsible for integrating with the editor service and managing terminal\n * editors.\n */\nexport interface ITerminalEditorService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all _terminal editor_ instances. */\n\treadonly instances: readonly ITerminalInstance[];\n\n\topenEditor(instance: ITerminalInstance, editorOptions?: TerminalEditorLocation): Promise<void>;\n\tdetachInstance(instance: ITerminalInstance): void;\n\tsplitInstance(instanceToSplit: ITerminalInstance, shellLaunchConfig?: IShellLaunchConfig): ITerminalInstance;\n\trevealActiveEditor(preserveFocus?: boolean): Promise<void>;\n\tresolveResource(instance: ITerminalInstance): URI;\n\treviveInput(deserializedInput: IDeserializedTerminalEditorInput): EditorInput;\n\tgetInputFromResource(resource: URI): TerminalEditorInput;\n}\n\nexport const terminalEditorId = 'terminalEditor';\n\ninterface ITerminalEditorInputObject {\n\treadonly id: number;\n\treadonly pid: number;\n\treadonly title: string;\n\treadonly titleSource: TitleEventSource;\n\treadonly cwd: string;\n\treadonly icon: TerminalIcon | undefined;\n\treadonly color: string | undefined;\n\treadonly hasChildProcesses?: boolean;\n\treadonly type?: TerminalType;\n\treadonly isFeatureTerminal?: boolean;\n\treadonly hideFromUser?: boolean;\n\treadonly reconnectionProperties?: IReconnectionProperties;\n\treadonly shellIntegrationNonce: string;\n}\n\nexport interface ISerializedTerminalEditorInput extends ITerminalEditorInputObject {\n}\n\nexport interface IDeserializedTerminalEditorInput extends ITerminalEditorInputObject {\n}\n\nexport type ITerminalLocationOptions = TerminalLocation | TerminalEditorLocation | { parentTerminal: MaybePromise<ITerminalInstance> } | { splitActiveTerminal: boolean };\n\nexport interface ICreateTerminalOptions {\n\t/**\n\t * The shell launch config or profile to launch with, when not specified the default terminal\n\t * profile will be used.\n\t */\n\tconfig?: IShellLaunchConfig | ITerminalProfile | IExtensionTerminalProfile;\n\t/**\n\t * The current working directory to start with, this will override IShellLaunchConfig.cwd if\n\t * specified.\n\t */\n\tcwd?: string | URI;\n\t/**\n\t * The terminal's resource, passed when the terminal has moved windows.\n\t */\n\tresource?: URI;\n\n\t/**\n\t * The terminal's location (editor or panel), it's terminal parent (split to the right), or editor group\n\t */\n\tlocation?: ITerminalLocationOptions;\n\n\t/**\n\t * This terminal will not wait for contributed profiles to resolve which means it will proceed\n\t * when the workbench is not yet loaded.\n\t */\n\tskipContributedProfileCheck?: boolean;\n}\n\nexport interface TerminalEditorLocation {\n\tviewColumn: GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE | AUX_WINDOW_GROUP_TYPE;\n\tpreserveFocus?: boolean;\n\tauxiliary?: IEditorOptions['auxiliary'];\n}\n\n/**\n * This service is responsible for managing terminal groups, that is the terminals that are hosted\n * within the terminal panel, not in an editor.\n */\nexport interface ITerminalGroupService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all _terminal view_ instances, ie. instances contained within terminal groups. */\n\treadonly instances: readonly ITerminalInstance[];\n\treadonly groups: readonly ITerminalGroup[];\n\tactiveGroup: ITerminalGroup | undefined;\n\treadonly activeGroupIndex: number;\n\t/**\n\t * Gets or sets the last accessed menu, this is used to select the instance(s) for menu actions.\n\t */\n\tlastAccessedMenu: 'inline-tab' | 'tab-list';\n\n\treadonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;\n\treadonly onDidDisposeGroup: Event<ITerminalGroup>;\n\t/** Fires when a group is created, disposed of, or shown (in the case of a background group). */\n\treadonly onDidChangeGroups: Event<void>;\n\t/** Fires when the panel has been shown and expanded, so has non-zero dimensions. */\n\treadonly onDidShow: Event<void>;\n\treadonly onDidChangePanelOrientation: Event<Orientation>;\n\n\tcreateGroup(shellLaunchConfig?: IShellLaunchConfig): ITerminalGroup;\n\tcreateGroup(instance?: ITerminalInstance): ITerminalGroup;\n\tgetGroupForInstance(instance: ITerminalInstance): ITerminalGroup | undefined;\n\n\t/**\n\t * Moves a terminal instance's group to the target instance group's position.\n\t * @param source The source instance to move.\n\t * @param target The target instance to move the source instance to.\n\t */\n\tmoveGroup(source: SingleOrMany<ITerminalInstance>, target: ITerminalInstance): void;\n\tmoveGroupToEnd(source: SingleOrMany<ITerminalInstance>): void;\n\n\tmoveInstance(source: ITerminalInstance, target: ITerminalInstance, side: 'before' | 'after'): void;\n\tunsplitInstance(instance: ITerminalInstance): void;\n\tjoinInstances(instances: ITerminalInstance[]): void;\n\tinstanceIsSplit(instance: ITerminalInstance): boolean;\n\n\tgetGroupLabels(): string[];\n\tsetActiveGroupByIndex(index: number): void;\n\tsetActiveGroupToNext(): void;\n\tsetActiveGroupToPrevious(): void;\n\n\tsetActiveInstanceByIndex(terminalIndex: number): void;\n\n\tsetContainer(container: HTMLElement): void;\n\n\tshowPanel(focus?: boolean): Promise<void>;\n\thidePanel(): void;\n\tfocusTabs(): void;\n\tfocusHover(): void;\n\tupdateVisibility(): void;\n}\n\n/**\n * An interface that indicates the implementer hosts terminal instances, exposing a common set of\n * properties and events.\n */\nexport interface ITerminalInstanceHost {\n\treadonly activeInstance: ITerminalInstance | undefined;\n\treadonly instances: readonly ITerminalInstance[];\n\n\treadonly onDidDisposeInstance: Event<ITerminalInstance>;\n\treadonly onDidFocusInstance: Event<ITerminalInstance>;\n\treadonly onDidChangeActiveInstance: Event<ITerminalInstance | undefined>;\n\treadonly onDidChangeInstances: Event<void>;\n\treadonly onDidChangeInstanceCapability: Event<ITerminalInstance>;\n\n\tsetActiveInstance(instance: ITerminalInstance): void;\n\t/**\n\t * Reveal and focus the instance, regardless of its location.\n\t */\n\tfocusInstance(instance: ITerminalInstance): void;\n\t/**\n\t * Reveal and focus the active instance, regardless of its location.\n\t */\n\tfocusActiveInstance(): Promise<void>;\n\t/**\n\t * Gets an instance from a resource if it exists. This MUST be used instead of getInstanceFromId\n\t * when you only know about a terminal's URI. (a URI's instance ID may not be this window's instance ID)\n\t */\n\tgetInstanceFromResource(resource: UriComponents | undefined): ITerminalInstance | undefined;\n}\n\n/**\n * Similar to xterm.js' ILinkProvider but using promises and hides xterm.js internals (like buffer\n * positions, decorations, etc.) from the rest of vscode. This is the interface to use for\n * workbench integrations.\n */\nexport interface ITerminalExternalLinkProvider {\n\tprovideLinks(instance: ITerminalInstance, line: string): Promise<ITerminalLink[] | undefined>;\n}\n\nexport interface ITerminalLink {\n\t/** The startIndex of the link in the line. */\n\tstartIndex: number;\n\t/** The length of the link in the line. */\n\tlength: number;\n\t/** The descriptive label for what the link does when activated. */\n\tlabel?: string;\n\t/**\n\t * Activates the link.\n\t * @param text The text of the link.\n\t */\n\tactivate(text: string): void;\n}\n\nexport interface ISearchOptions {\n\t/** Whether the find should be done as a regex. */\n\tregex?: boolean;\n\t/** Whether only whole words should match. */\n\twholeWord?: boolean;\n\t/** Whether find should pay attention to case. */\n\tcaseSensitive?: boolean;\n\t/** Whether the search should start at the current search position (not the next row). */\n\tincremental?: boolean;\n}\n\nexport interface ITerminalInstance extends IBaseTerminalInstance {\n\t/**\n\t * The ID of the terminal instance, this is an arbitrary number only used to uniquely identify\n\t * terminal instances within a window.\n\t */\n\treadonly instanceId: number;\n\t/**\n\t * A unique URI for this terminal instance with the following encoding:\n\t * path: /<workspace ID>/<instance ID>\n\t * fragment: Title\n\t * Note that when dragging terminals across windows, this will retain the original workspace ID /instance ID\n\t * from the other window.\n\t */\n\treadonly resource: URI;\n\n\treadonly cols: number;\n\treadonly rows: number;\n\treadonly maxCols: number;\n\treadonly maxRows: number;\n\treadonly fixedCols?: number;\n\treadonly fixedRows?: number;\n\treadonly domElement: HTMLElement;\n\treadonly icon?: TerminalIcon;\n\treadonly color?: string;\n\treadonly reconnectionProperties?: IReconnectionProperties;\n\treadonly processName: string;\n\treadonly sequence?: string;\n\treadonly staticTitle?: string;\n\treadonly progressState?: IProgressState;\n\treadonly workspaceFolder?: IWorkspaceFolder;\n\treadonly cwd?: string;\n\treadonly initialCwd?: string;\n\treadonly os?: OperatingSystem;\n\treadonly usedShellIntegrationInjection: boolean;\n\treadonly shellIntegrationInjectionFailureReason: ShellIntegrationInjectionFailureReason | undefined;\n\treadonly injectedArgs: string[] | undefined;\n\treadonly extEnvironmentVariableCollection: IMergedEnvironmentVariableCollection | undefined;\n\n\t/**\n\t * The underlying disposable store, allowing objects who share the same lifecycle as the\n\t * terminal instance but are created externally to be managed by the instance.\n\t */\n\treadonly store: DisposableStore;\n\n\treadonly statusList: ITerminalStatusList;\n\n\t/**\n\t * The process ID of the shell process, this is undefined when there is no process associated\n\t * with this terminal.\n\t */\n\tprocessId: number | undefined;\n\n\t/**\n\t * The position of the terminal.\n\t */\n\ttarget: TerminalLocation | undefined;\n\ttargetRef: IReference<TerminalLocation | undefined>;\n\n\t/**\n\t * The id of a persistent process. This is defined if this is a terminal created by a pty host\n\t * that supports reconnection.\n\t */\n\treadonly persistentProcessId: number | undefined;\n\n\t/**\n\t * Whether the process should be persisted across reloads.\n\t */\n\treadonly shouldPersist: boolean;\n\n\t/*\n\t * Whether this terminal has been disposed of\n\t */\n\treadonly isDisposed: boolean;\n\n\t/**\n\t * Whether the terminal's pty is hosted on a remote.\n\t */\n\treadonly hasRemoteAuthority: boolean;\n\n\t/**\n\t * The remote authority of the terminal's pty.\n\t */\n\treadonly remoteAuthority: string | undefined;\n\n\t/**\n\t * Whether an element within this terminal is focused.\n\t */\n\treadonly hasFocus: boolean;\n\n\t/**\n\t * The ID of the session that this terminal is connected to\n\t */\n\treadonly sessionId: string;\n\n\t/**\n\t * Get or set the behavior of the terminal when it closes. This was indented only to be called\n\t * after reconnecting to a terminal.\n\t */\n\twaitOnExit: WaitOnExitValue | undefined;\n\n\t/**\n\t * An event that fires when the terminal instance's title changes.\n\t */\n\treadonly onTitleChanged: Event<ITerminalInstance>;\n\n\t/**\n\t * An event that fires when the terminal instance's icon changes.\n\t */\n\treadonly onIconChanged: Event<{ instance: ITerminalInstance; userInitiated: boolean }>;\n\n\t/**\n\t * An event that fires when the terminal instance is disposed.\n\t */\n\treadonly onDisposed: Event<ITerminalInstance>;\n\n\treadonly onProcessIdReady: Event<ITerminalInstance>;\n\treadonly onProcessReplayComplete: Event<void>;\n\treadonly onRequestExtHostProcess: Event<ITerminalInstance>;\n\treadonly onDimensionsChanged: Event<void>;\n\treadonly onMaximumDimensionsChanged: Event<void>;\n\treadonly onDidChangeHasChildProcesses: Event<boolean>;\n\n\treadonly onDidFocus: Event<ITerminalInstance>;\n\treadonly onDidRequestFocus: Event<void>;\n\treadonly onDidBlur: Event<ITerminalInstance>;\n\treadonly onDidInputData: Event<string>;\n\treadonly onDidChangeSelection: Event<ITerminalInstance>;\n\treadonly onDidExecuteText: Event<void>;\n\treadonly onDidChangeTarget: Event<TerminalLocation | undefined>;\n\treadonly onDidSendText: Event<string>;\n\treadonly onDidChangeShellType: Event<TerminalShellType>;\n\treadonly onDidChangeVisibility: Event<boolean>;\n\n\t/**\n\t * An event that fires when a terminal is dropped on this instance via drag and drop.\n\t */\n\treadonly onRequestAddInstanceToGroup: Event<IRequestAddInstanceToGroupEvent>;\n\n\t/**\n\t * Attach a listener to the raw data stream coming from the pty, including ANSI escape\n\t * sequences.\n\t */\n\treadonly onData: Event<string>;\n\treadonly onWillData: Event<string>;\n\n\t/**\n\t * Attach a listener to the binary data stream coming from xterm and going to pty\n\t */\n\treadonly onBinary: Event<string>;\n\n\t/**\n\t * Attach a listener to listen for new lines added to this terminal instance.\n\t *\n\t * @param listener The listener function which takes new line strings added to the terminal,\n\t * excluding ANSI escape sequences. The line event will fire when an LF character is added to\n\t * the terminal (ie. the line is not wrapped). Note that this means that the line data will\n\t * not fire for the last line, until either the line is ended with a LF character of the process\n\t * is exited. The lineData string will contain the fully wrapped line, not containing any LF/CR\n\t * characters.\n\t */\n\treadonly onLineData: Event<string>;\n\n\t/**\n\t * Attach a listener that fires when the terminal's pty process exits. The number in the event\n\t * is the processes' exit code, an exit code of undefined means the process was killed as a result of\n\t * the ITerminalInstance being disposed.\n\t */\n\treadonly onExit: Event<number | ITerminalLaunchError | undefined>;\n\n\t/**\n\t * The exit code or undefined when the terminal process hasn't yet exited or\n\t * the process exit code could not be determined. Use {@link exitReason} to see\n\t * why the process has exited.\n\t */\n\treadonly exitCode: number | undefined;\n\n\t/**\n\t * The reason the terminal process exited, this will be undefined if the process is still\n\t * running.\n\t */\n\treadonly exitReason: TerminalExitReason | undefined;\n\n\t/**\n\t * The xterm.js instance for this terminal.\n\t */\n\treadonly xterm?: XtermTerminal;\n\n\t/**\n\t * Resolves when the xterm.js instance for this terminal is ready.\n\t */\n\treadonly xtermReadyPromise: Promise<XtermTerminal | undefined>;\n\n\t/**\n\t * Returns an array of data events that have fired within the first 10 seconds. If this is\n\t * called 10 seconds after the terminal has existed the result will be undefined. This is useful\n\t * when objects that depend on the data events have delayed initialization, like extension\n\t * hosts.\n\t */\n\treadonly initialDataEvents: string[] | undefined;\n\n\t/** A promise that resolves when the terminal's pty/process have been created. */\n\treadonly processReady: Promise<void>;\n\n\t/** Whether the terminal's process has child processes (ie. is dirty/busy). */\n\treadonly hasChildProcesses: boolean;\n\n\t/**\n\t * The title of the terminal. This is either title or the process currently running or an\n\t * explicit name given to the terminal instance through the extension API.\n\t */\n\treadonly title: string;\n\n\t/**\n\t * How the current title was set.\n\t */\n\treadonly titleSource: TitleEventSource;\n\n\t/**\n\t * The shell type of the terminal.\n\t */\n\treadonly shellType: TerminalShellType | undefined;\n\n\t/**\n\t * The focus state of the terminal before exiting.\n\t */\n\treadonly hadFocusOnExit: boolean;\n\n\t/**\n\t * False when the title is set by an API or the user. We check this to make sure we\n\t * do not override the title when the process title changes in the terminal.\n\t */\n\tisTitleSetByProcess: boolean;\n\n\t/**\n\t * The shell launch config used to launch the shell.\n\t */\n\treadonly shellLaunchConfig: IShellLaunchConfig;\n\n\t/**\n\t * Whether to disable layout for the terminal. This is useful when the size of the terminal is\n\t * being manipulating (e.g. adding a split pane) and we want the terminal to ignore particular\n\t * resize events.\n\t */\n\tdisableLayout: boolean;\n\n\t/**\n\t * The description of the terminal, this is typically displayed next to {@link title}.\n\t */\n\tdescription: string | undefined;\n\n\t/**\n\t * The remote-aware $HOME directory (or Windows equivalent) of the terminal.\n\t */\n\tuserHome: string | undefined;\n\n\t/**\n\t * The nonce used to verify commands coming from shell integration.\n\t */\n\tshellIntegrationNonce: string;\n\n\t/**\n\t * Registers and returns a marker\n\t * @param the y offset from the cursor\n\t */\n\tregisterMarker(offset?: number): IMarker | undefined;\n\n\t/**\n\t * Adds a marker to the buffer, mapping it to an ID if provided.\n\t */\n\taddBufferMarker(properties: IMarkProperties): void;\n\n\t/**\n\t *\n\t * @param startMarkId The ID for the start marker\n\t * @param endMarkId The ID for the end marker\n\t * @param highlight Whether the buffer from startMarker to endMarker\n\t * should be highlighted\n\t */\n\tscrollToMark(startMarkId: string, endMarkId?: string, highlight?: boolean): void;\n\n\t/**\n\t * Dispose the terminal instance, removing it from the panel/service and freeing up resources.\n\t *\n\t * @param reason The reason why the terminal is being disposed\n\t */\n\tdispose(reason?: TerminalExitReason): void;\n\n\t/**\n\t * Informs the process that the terminal is now detached and\n\t * then disposes the terminal.\n\t *\n\t * @param reason The reason why the terminal is being disposed\n\t */\n\tdetachProcessAndDispose(reason: TerminalExitReason): Promise<void>;\n\n\t/**\n\t * When the panel is hidden or a terminal in the editor area becomes inactive, reset the focus context key\n\t * to avoid issues like #147180.\n\t */\n\tresetFocusContextKey(): void;\n\n\t/**\n\t * Focuses the terminal instance when it's ready (the xterm.js instance much exist). This is the\n\t * best focus call when the terminal is being shown for example.\n\t * when the terminal is being shown.\n\t *\n\t * @param force Force focus even if there is a selection.\n\t */\n\tfocusWhenReady(force?: boolean): Promise<void>;\n\n\t/**\n\t * Send text to the terminal instance. The text is written to the stdin of the underlying pty\n\t * process (shell) of the terminal instance.\n\t *\n\t * @param text The text to send.\n\t * @param shouldExecute Indicates that the text being sent should be executed rather than just inserted in the terminal.\n\t * The character(s) added are \\n or \\r\\n, depending on the platform. This defaults to `true`.\n\t * @param bracketedPasteMode Whether to wrap the text in the bracketed paste mode sequence when\n\t * it's enabled. When true, the shell will treat the text as if it were pasted into the shell,\n\t * this may for example select the text and it will also ensure that the text will not be\n\t * interpreted as a shell keybinding.\n\t */\n\tsendText(text: string, shouldExecute: boolean, bracketedPasteMode?: boolean): Promise<void>;\n\n\t/**\n\t * Sends a signal to the terminal instance's process.\n\t *\n\t * @param signal The signal to send (e.g., 'SIGTERM', 'SIGINT', 'SIGKILL').\n\t */\n\tsendSignal(signal: string): Promise<void>;\n\n\t/**\n\t * Sends a path to the terminal instance, preparing it as needed based on the detected shell\n\t * running within the terminal. The text is written to the stdin of the underlying pty process\n\t * (shell) of the terminal instance.\n\t *\n\t * @param originalPath The path to send.\n\t * @param shouldExecute Indicates that the text being sent should be executed rather than just inserted in the terminal.\n\t * The character(s) added are \\n or \\r\\n, depending on the platform. This defaults to `true`.\n\t */\n\tsendPath(originalPath: string | URI, shouldExecute: boolean): Promise<void>;\n\n\trunCommand(command: string, shouldExecute?: boolean, commandId?: string): Promise<void>;\n\n\t/**\n\t * Takes a path and returns the properly escaped path to send to a given shell. On Windows, this\n\t * includes trying to prepare the path for WSL if needed.\n\t *\n\t * @param originalPath The path to be escaped and formatted.\n\t */\n\tpreparePathForShell(originalPath: string): Promise<string>;\n\n\t/**\n\t * Formats a file system URI for display in UI so that it appears in the terminal shell's format.\n\t * @param uri The URI to format.\n\t */\n\tgetUriLabelForShell(uri: URI): Promise<string>;\n\n\t/** Scroll the terminal buffer down 1 line. */   scrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page. */   scrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */ scrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line. */     scrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page. */     scrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top. */    scrollToTop(): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line and moving it to the top of the\n\t * viewport.\n\t */\n\tclearBuffer(): void;\n\n\t/**\n\t * Attaches the terminal instance to an element on the DOM, before this is called the terminal\n\t * instance process may run in the background but cannot be displayed on the UI.\n\t *\n\t * @param container The element to attach the terminal instance to.\n\t */\n\tattachToElement(container: HTMLElement): void;\n\n\t/**\n\t * Detaches the terminal instance from the terminal editor DOM element.\n\t */\n\tdetachFromElement(): void;\n\n\t/**\n\t * Layout the terminal instance.\n\t *\n\t * @param dimension The dimensions of the container.\n\t */\n\tlayout(dimension: { width: number; height: number }): void;\n\n\t/**\n\t * Sets whether the terminal instance's element is visible in the DOM.\n\t *\n\t * @param visible Whether the element is visible.\n\t */\n\tsetVisible(visible: boolean): void;\n\n\t/**\n\t * Immediately kills the terminal's current pty process and launches a new one to replace it.\n\t *\n\t * @param shell The new launch configuration.\n\t */\n\treuseTerminal(shell: IShellLaunchConfig): Promise<void>;\n\n\t/**\n\t * Relaunches the terminal, killing it and reusing the launch config used initially. Any\n\t * environment variable changes will be recalculated when this happens.\n\t */\n\trelaunch(): void;\n\n\t/**\n\t * Sets the terminal instance's dimensions to the values provided via the onDidOverrideDimensions event,\n\t * which allows overriding the regular dimensions (fit to the size of the panel).\n\t */\n\tsetOverrideDimensions(dimensions: ITerminalDimensions): void;\n\n\t/**\n\t * Sets the terminal instance's dimensions to the values provided via quick input.\n\t */\n\tsetFixedDimensions(): Promise<void>;\n\n\t/**\n\t * Toggles terminal line wrapping.\n\t */\n\ttoggleSizeToContentWidth(): Promise<void>;\n\n\t/**\n\t * Gets the initial current working directory, fetching it from the backend if required.\n\t */\n\tgetInitialCwd(): Promise<string>;\n\n\t/**\n\t * Gets the current working directory from cwd detection capabilities if available, otherwise\n\t * from the backend. This will return the initial cwd if cwd detection is not available (ie.\n\t * on Windows when shell integration is disabled).\n\t */\n\tgetSpeculativeCwd(): Promise<string>;\n\n\t/**\n\t * Gets the cwd as a URI that has been validated to exist.\n\t */\n\tgetCwdResource(): Promise<URI | undefined>;\n\n\t/**\n\t * Sets the title of the terminal to the provided string. If no title is provided, it will reset\n\t * to the terminal's title if it was not explicitly set by the user or API.\n\t * @param title The new title.\n\t */\n\trename(title?: string): Promise<void>;\n\n\t/**\n\t * Sets or triggers a quick pick to change the icon of this terminal.\n\t */\n\tchangeIcon(icon?: TerminalIcon): Promise<TerminalIcon | undefined>;\n\n\t/**\n\t * Sets or triggers a quick pick to change the color of the associated terminal tab icon.\n\t */\n\tchangeColor(color?: string, skipQuickPick?: boolean): Promise<string | undefined>;\n\n\t/**\n\t * Attempts to detect and kill the process listening on specified port.\n\t * If successful, places commandToRun on the command line\n\t */\n\tfreePortKillProcess(port: string, commandToRun: string): Promise<void>;\n\n\t/**\n\t * Update the parent context key service to use for this terminal instance.\n\t */\n\tsetParentContextKeyService(parentContextKeyService: IContextKeyService): void;\n\n\t/**\n\t * Handles a mouse event for the terminal, this may happen on an anscestor of the terminal\n\t * instance's element.\n\t * @param event The mouse event.\n\t * @param contextMenu The context menu to show if needed.\n\t * @returns Whether the context menu should be suppressed.\n\t */\n\thandleMouseEvent(event: MouseEvent, contextMenu: IMenu): Promise<{ cancelContextMenu: boolean } | void>;\n}\n\nexport const enum XtermTerminalConstants {\n\tSearchHighlightLimit = 20000\n}\n\nexport interface IXtermAttachToElementOptions {\n\t/**\n\t * Whether GPU rendering should be enabled for this element, defaults to true.\n\t */\n\tenableGpu: boolean;\n}\n\nexport interface IXtermTerminal extends IDisposable {\n\t/**\n\t * An object that tracks when commands are run and enables navigating and selecting between\n\t * them.\n\t */\n\treadonly markTracker: IMarkTracker;\n\n\t/**\n\t * Reports the status of shell integration and fires events relating to it.\n\t */\n\treadonly shellIntegration: IShellIntegration;\n\n\treadonly decorationAddon: IDecorationAddon;\n\n\treadonly onDidChangeSelection: Event<void>;\n\treadonly onDidChangeFindResults: Event<{ resultIndex: number; resultCount: number }>;\n\treadonly onDidRequestRunCommand: Event<{ command: ITerminalCommand; noNewLine?: boolean }>;\n\treadonly onDidRequestCopyAsHtml: Event<{ command: ITerminalCommand }>;\n\n\t/**\n\t * Event fired when focus enters (fires with true) or leaves (false) the terminal.\n\t */\n\treadonly onDidChangeFocus: Event<boolean>;\n\n\t/**\n\t * Gets a view of the current texture atlas used by the renderers.\n\t */\n\treadonly textureAtlas: Promise<ImageBitmap> | undefined;\n\n\t/**\n\t * Whether the `disableStdin` option in xterm.js is set.\n\t */\n\treadonly isStdinDisabled: boolean;\n\n\t/**\n\t * Whether the terminal is currently focused.\n\t */\n\treadonly isFocused: boolean;\n\n\t/**\n\t * Whether a canvas-based renderer is being used.\n\t */\n\treadonly isGpuAccelerated: boolean;\n\n\t/**\n\t * The last `onData` input event fired by {@link RawXtermTerminal.onData}.\n\t */\n\treadonly lastInputEvent: string | undefined;\n\n\t/**\n\t * Attached the terminal to the given element\n\t * @param container Container the terminal will be rendered in\n\t * @param options Additional options for mounting the terminal in an element\n\t */\n\tattachToElement(container: HTMLElement, options?: Partial<IXtermAttachToElementOptions>): void;\n\n\tfindResult?: { resultIndex: number; resultCount: number };\n\n\t/**\n\t * Find the next instance of the term\n\t*/\n\tfindNext(term: string, searchOptions: ISearchOptions): Promise<boolean>;\n\n\t/**\n\t * Find the previous instance of the term\n\t */\n\tfindPrevious(term: string, searchOptions: ISearchOptions): Promise<boolean>;\n\n\t/**\n\t * Forces the terminal to redraw its viewport.\n\t */\n\tforceRedraw(): void;\n\n\t/**\n\t * Gets the font metrics of this xterm.js instance.\n\t */\n\tgetFont(): ITerminalFont;\n\n\t/**\n\t * Gets whether there's any terminal selection.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Clears any terminal selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Selects all terminal contents/\n\t */\n\tselectAll(): void;\n\n\t/**\n\t * Selects the content between the two markers by their VS Code OSC `SetMarker`\n\t * ID. It's a no-op if either of the two markers are not found.\n\t *\n\t * @param fromMarkerId Start marker ID\n\t * @param toMarkerId End marker ID\n\t * @param scrollIntoView Whether the terminal should scroll to the start of\n\t * the range, defaults tof alse\n\t */\n\tselectMarkedRange(fromMarkerId: string, toMarkerId: string, scrollIntoView?: boolean): void;\n\n\t/**\n\t * Copies the terminal selection.\n\t * @param copyAsHtml Whether to copy selection as HTML, defaults to false.\n\t */\n\tcopySelection(copyAsHtml?: boolean, command?: ITerminalCommand): void;\n\t/**\n\t * Focuses the terminal. Warning: {@link ITerminalInstance.focus} should be\n\t * preferred when dealing with terminal instances in order to get\n\t * accessibility triggers.\n\t */\n\tfocus(): void;\n\n\t/** Scroll the terminal buffer down 1 line.   */ scrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page.   */ scrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */ scrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line.     */ scrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page.     */ scrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top.    */ scrollToTop(): void;\n\t/** Scroll the terminal buffer to a set line  */ scrollToLine(line: number, position?: ScrollPosition): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line and moving it to the top of the\n\t * viewport.\n\t */\n\tclearBuffer(): void;\n\n\t/**\n\t * Clears the search result decorations\n\t */\n\tclearSearchDecorations(): void;\n\n\t/**\n\t * Clears the active search result decorations\n\t */\n\tclearActiveSearchDecoration(): void;\n\n\t/**\n\t * Returns a reverse iterator of buffer lines as strings\n\t */\n\tgetBufferReverseIterator(): IterableIterator<string>;\n\n\t/**\n\t * Gets the contents of the buffer from a start marker (or line 0) to the end marker (or the\n\t * last line).\n\t */\n\tgetContentsAsText(startMarker?: IXtermMarker, endMarker?: IXtermMarker): string;\n\n\t/**\n\t * Gets the buffer contents as HTML.\n\t */\n\tgetContentsAsHtml(): Promise<string>;\n\n\t/**\n\t * Refreshes the terminal after it has been moved.\n\t */\n\trefresh(): void;\n\n\tgetXtermTheme(theme?: IColorTheme): ITheme;\n}\n\nexport interface IDetachedXtermTerminal extends IXtermTerminal {\n\t/**\n\t * Writes data to the terminal.\n\t * @param data data to write\n\t * @param callback Optional callback that fires when the data was processed\n\t * by the parser.\n\t */\n\twrite(data: string | Uint8Array, callback?: () => void): void;\n\n\t/**\n\t * Resizes the terminal.\n\t */\n\tresize(columns: number, rows: number): void;\n}\n\nexport interface IInternalXtermTerminal {\n\t/**\n\t * Writes text directly to the terminal, bypassing the process.\n\t *\n\t * **WARNING:** This should never be used outside of the terminal component and only for\n\t * developer purposed inside the terminal component.\n\t */\n\t_writeText(data: string): void; // eslint-disable-line @typescript-eslint/naming-convention\n}\n\nexport interface IXtermColorProvider {\n\tgetBackgroundColor(theme: IColorTheme): Color | undefined;\n}\n\nexport interface IRequestAddInstanceToGroupEvent {\n\turi: URI;\n\tside: 'before' | 'after';\n}\n\nexport const enum LinuxDistro {\n\tUnknown = 1,\n\tFedora = 2,\n\tUbuntu = 3,\n}\n\nexport const enum TerminalDataTransfers {\n\tTerminals = 'Terminals'\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDimension } from '../../../../base/browser/dom.js';\nimport { Orientation } from '../../../../base/browser/ui/splitview/splitview.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { Event, IDynamicListEventMultiplexer, type DynamicListEventMultiplexer } from '../../../../base/common/event.js';\nimport { DisposableStore, IDisposable, type IReference } from '../../../../base/common/lifecycle.js';\nimport { OperatingSystem } from '../../../../base/common/platform.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IKeyMods } from '../../../../platform/quickinput/common/quickInput.js';\nimport { IMarkProperties, ITerminalCapabilityImplMap, ITerminalCapabilityStore, ITerminalCommand, TerminalCapability } from '../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { IMergedEnvironmentVariableCollection } from '../../../../platform/terminal/common/environmentVariable.js';\nimport { IExtensionTerminalProfile, IReconnectionProperties, IShellIntegration, IShellLaunchConfig, ITerminalBackend, ITerminalDimensions, ITerminalLaunchError, ITerminalProfile, ITerminalTabLayoutInfoById, TerminalExitReason, TerminalIcon, TerminalLocation, TerminalShellType, TerminalType, TitleEventSource, WaitOnExitValue, type IDecorationAddon, type ShellIntegrationInjectionFailureReason } from '../../../../platform/terminal/common/terminal.js';\nimport { IColorTheme } from '../../../../platform/theme/common/themeService.js';\nimport { IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditableData } from '../../../common/views.js';\nimport { ITerminalStatusList } from './terminalStatusList.js';\nimport { XtermTerminal } from './xterm/xtermTerminal.js';\nimport { IRegisterContributedProfileArgs, IRemoteTerminalAttachTarget, IStartExtensionTerminalRequest, ITerminalConfiguration, ITerminalFont, ITerminalProcessExtHostProxy, ITerminalProcessInfo } from '../common/terminal.js';\nimport type { IMarker, ITheme, Terminal as RawXtermTerminal, IBufferRange, IMarker as IXtermMarker } from '@xterm/xterm';\nimport { ScrollPosition } from './xterm/markNavigationAddon.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { GroupIdentifier } from '../../../common/editor.js';\nimport { ACTIVE_GROUP_TYPE, AUX_WINDOW_GROUP_TYPE, SIDE_GROUP_TYPE } from '../../../services/editor/common/editorService.js';\nimport type { ICurrentPartialCommand } from '../../../../platform/terminal/common/capabilities/commandDetection/terminalCommand.js';\nimport type { IXtermCore } from './xterm-private.js';\nimport type { IMenu } from '../../../../platform/actions/common/actions.js';\nimport type { IProgressState } from '@xterm/addon-progress';\nimport type { IEditorOptions } from '../../../../platform/editor/common/editor.js';\nimport type { TerminalEditorInput } from './terminalEditorInput.js';\nimport type { MaybePromise } from '../../../../base/common/async.js';\nimport { isNumber, type SingleOrMany } from '../../../../base/common/types.js';\n\nexport const ITerminalService = createDecorator<ITerminalService>('terminalService');\nexport const ITerminalConfigurationService = createDecorator<ITerminalConfigurationService>('terminalConfigurationService');\nexport const ITerminalEditorService = createDecorator<ITerminalEditorService>('terminalEditorService');\nexport const ITerminalEditingService = createDecorator<ITerminalEditingService>('terminalEditingService');\nexport const ITerminalGroupService = createDecorator<ITerminalGroupService>('terminalGroupService');\nexport const ITerminalInstanceService = createDecorator<ITerminalInstanceService>('terminalInstanceService');\nexport const ITerminalChatService = createDecorator<ITerminalChatService>('terminalChatService');\n\n/**\n * A terminal contribution that gets created whenever a terminal is created. A contribution has\n * access to the process manager through the constructor and provides a method for when xterm.js has\n * been initialized.\n */\nexport interface ITerminalContribution extends IDisposable {\n\tlayout?(xterm: IXtermTerminal & { raw: RawXtermTerminal }, dimension: IDimension): void;\n\txtermOpen?(xterm: IXtermTerminal & { raw: RawXtermTerminal }): void;\n\txtermReady?(xterm: IXtermTerminal & { raw: RawXtermTerminal }): void;\n\n\thandleMouseEvent?(event: MouseEvent): MaybePromise<{ handled: boolean } | void>;\n}\n\n/**\n * A service used to create instances or fetch backends, this services allows services that\n * ITerminalService depends on to also create instances.\n *\n * **This service is intended to only be used within the terminal contrib.**\n */\nexport interface ITerminalInstanceService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event that's fired when a terminal instance is created.\n\t */\n\treadonly onDidCreateInstance: Event<ITerminalInstance>;\n\n\t/**\n\t * An event that's fired when a new backend is registered.\n\t */\n\treadonly onDidRegisterBackend: Event<ITerminalBackend>;\n\n\t/**\n\t * Helper function to convert a shell launch config, a profile or undefined into its equivalent\n\t * shell launch config.\n\t * @param shellLaunchConfigOrProfile A shell launch config, a profile or undefined\n\t * @param cwd A cwd to override.\n\t */\n\tconvertProfileToShellLaunchConfig(shellLaunchConfigOrProfile?: IShellLaunchConfig | ITerminalProfile, cwd?: string | URI): IShellLaunchConfig;\n\n\t/**\n\t * Create a new terminal instance.\n\t * @param launchConfig The shell launch config.\n\t * @param target The target of the terminal.\n\t */\n\tcreateInstance(launchConfig: IShellLaunchConfig, target: TerminalLocation, editorOptions?: TerminalEditorLocation): ITerminalInstance;\n\n\t/**\n\t * Gets the registered backend for a remote authority (undefined = local). This is a convenience\n\t * method to avoid using the more verbose fetching from the registry.\n\t * @param remoteAuthority The remote authority of the backend.\n\t */\n\tgetBackend(remoteAuthority?: string): Promise<ITerminalBackend | undefined>;\n\n\tgetRegisteredBackends(): IterableIterator<ITerminalBackend>;\n\tdidRegisterBackend(backend: ITerminalBackend): void;\n}\n\n/**\n * Service enabling communication between the chat tool implementation in terminal contrib and workbench contribs.\n * Acts as a communication mechanism for chat-related terminal features.\n */\nexport interface IChatTerminalToolProgressPart {\n\treadonly elementIndex: number;\n\treadonly contentIndex: number;\n\tfocusTerminal(): Promise<void>;\n\ttoggleOutputFromKeyboard(): Promise<void>;\n\tfocusOutput(): void;\n\tgetCommandAndOutputAsText(): string | undefined;\n}\n\nexport interface ITerminalChatService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fired when a terminal instance is registered for a tool session id. This can happen after\n\t * the chat UI first renders, enabling late binding of the focus action.\n\t */\n\treadonly onDidRegisterTerminalInstanceWithToolSession: Event<ITerminalInstance>;\n\n\t/**\n\t * Associate a tool session id with a terminal instance. The association is automatically\n\t * cleared when the instance is disposed.\n\t */\n\tregisterTerminalInstanceWithToolSession(terminalToolSessionId: string | undefined, instance: ITerminalInstance): void;\n\n\t/**\n\t * Resolve a terminal instance by its tool session id.\n\t * @param terminalToolSessionId The tool session id provided in toolSpecificData.\n\t * If no tool session ID is provided, we do nothing.\n\t */\n\tgetTerminalInstanceByToolSessionId(terminalToolSessionId: string): Promise<ITerminalInstance | undefined>;\n\n\t/**\n\t * Returns the list of terminal instances that have been registered with a tool session id.\n\t * This is used for surfacing tool-driven/background terminals in UI (eg. quick picks).\n\t */\n\tgetToolSessionTerminalInstances(hiddenOnly?: boolean): readonly ITerminalInstance[];\n\n\t/**\n\t * Returns the tool session ID for a given terminal instance, if it has been registered.\n\t * @param instance The terminal instance to look up\n\t * @returns The tool session ID if found, undefined otherwise\n\t */\n\tgetToolSessionIdForInstance(instance: ITerminalInstance): string | undefined;\n\n\t/**\n\t * Associate a chat session ID with a terminal instance. This is used to retrieve the chat\n\t * session title for display purposes.\n\t * @param chatSessionId The chat session ID\n\t * @param instance The terminal instance\n\t */\n\tregisterTerminalInstanceWithChatSession(chatSessionId: string, instance: ITerminalInstance): void;\n\n\t/**\n\t * Returns the chat session ID for a given terminal instance, if it has been registered.\n\t * @param instance The terminal instance to look up\n\t * @returns The chat session ID if found, undefined otherwise\n\t */\n\tgetChatSessionIdForInstance(instance: ITerminalInstance): string | undefined;\n\n\t/**\n\t * Check if a terminal is a background terminal (tool-driven terminal that may be hidden from\n\t * normal UI).\n\t * @param terminalToolSessionId The tool session ID to check, if provided\n\t * @returns True if the terminal is a background terminal, false otherwise\n\t */\n\tisBackgroundTerminal(terminalToolSessionId?: string): boolean;\n\n\t/**\n\t * Register a chat terminal tool progress part for tracking and focus management.\n\t * @param part The progress part to register\n\t * @returns A disposable that unregisters the progress part when disposed\n\t */\n\tregisterProgressPart(part: IChatTerminalToolProgressPart): IDisposable;\n\n\t/**\n\t * Set the currently focused progress part.\n\t * @param part The progress part to focus\n\t */\n\tsetFocusedProgressPart(part: IChatTerminalToolProgressPart): void;\n\n\t/**\n\t * Clear the focused state from a progress part.\n\t * @param part The progress part to clear focus from\n\t */\n\tclearFocusedProgressPart(part: IChatTerminalToolProgressPart): void;\n\n\t/**\n\t * Get the currently focused progress part, if any.\n\t * @returns The focused progress part or undefined if none is focused\n\t */\n\tgetFocusedProgressPart(): IChatTerminalToolProgressPart | undefined;\n\n\t/**\n\t * Get the most recently registered progress part, if any.\n\t * @returns The most recent progress part or undefined if none exist\n\t */\n\tgetMostRecentProgressPart(): IChatTerminalToolProgressPart | undefined;\n\n\t/**\n\t * Enable or disable auto approval for all commands in a specific session.\n\t * @param chatSessionId The chat session ID\n\t * @param enabled Whether to enable or disable session auto approval\n\t */\n\tsetChatSessionAutoApproval(chatSessionId: string, enabled: boolean): void;\n\n\t/**\n\t * Check if a session has auto approval enabled for all commands.\n\t * @param chatSessionId The chat session ID\n\t * @returns True if the session has auto approval enabled\n\t */\n\thasChatSessionAutoApproval(chatSessionId: string): boolean;\n}\n\n/**\n * A service responsible for managing terminal editing state and functionality. This includes\n * tracking which terminal is currently being edited and managing editable data associated with\n * terminal instances.\n */\nexport interface ITerminalEditingService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Get the editable data for a terminal instance.\n\t * @param instance The terminal instance.\n\t * @returns The editable data if the instance is editable, undefined otherwise.\n\t */\n\tgetEditableData(instance: ITerminalInstance): IEditableData | undefined;\n\n\t/**\n\t * Set the editable data for a terminal instance.\n\t * @param instance The terminal instance.\n\t * @param data The editable data to set, or null to clear.\n\t */\n\tsetEditable(instance: ITerminalInstance, data: IEditableData | null): void;\n\n\t/**\n\t * Check if a terminal instance is currently editable.\n\t * @param instance The terminal instance to check.\n\t * @returns True if the instance is editable, false otherwise.\n\t */\n\tisEditable(instance: ITerminalInstance | undefined): boolean;\n\n\t/**\n\t * Get the terminal instance that is currently being edited.\n\t * @returns The terminal instance being edited, or undefined if none.\n\t */\n\tgetEditingTerminal(): ITerminalInstance | undefined;\n\n\t/**\n\t * Set the terminal instance that is currently being edited.\n\t * @param instance The terminal instance to set as editing, or undefined to clear.\n\t */\n\tsetEditingTerminal(instance: ITerminalInstance | undefined): void;\n}\n\nexport const enum Direction {\n\tLeft = 0,\n\tRight = 1,\n\tUp = 2,\n\tDown = 3\n}\n\nexport interface IQuickPickTerminalObject {\n\tconfig: IRegisterContributedProfileArgs | ITerminalProfile | { profile: IExtensionTerminalProfile; options: { icon?: string; color?: string } } | undefined;\n\tkeyMods: IKeyMods | undefined;\n}\n\nexport interface IMarkTracker {\n\tscrollToPreviousMark(scrollPosition?: ScrollPosition, retainSelection?: boolean, skipEmptyCommands?: boolean): void;\n\tscrollToNextMark(): void;\n\tselectToPreviousMark(): void;\n\tselectToNextMark(): void;\n\tselectToPreviousLine(): void;\n\tselectToNextLine(): void;\n\tclear(): void;\n\tscrollToClosestMarker(startMarkerId: string, endMarkerId?: string, highlight?: boolean | undefined): void;\n\n\tscrollToLine(line: number, position: ScrollPosition): void;\n\trevealCommand(command: ITerminalCommand | ICurrentPartialCommand | URI, position?: ScrollPosition): void;\n\trevealRange(range: IBufferRange): void;\n\tregisterTemporaryDecoration(marker: IMarker, endMarker: IMarker | undefined, showOutline: boolean): void;\n\tshowCommandGuide(command: ITerminalCommand | undefined): void;\n\n\tsaveScrollState(): void;\n\trestoreScrollState(): void;\n}\n\nexport interface ITerminalGroup {\n\tactiveInstance: ITerminalInstance | undefined;\n\tterminalInstances: ITerminalInstance[];\n\ttitle: string;\n\treadonly hadFocusOnExit: boolean;\n\n\treadonly onDidDisposeInstance: Event<ITerminalInstance>;\n\treadonly onDisposed: Event<ITerminalGroup>;\n\treadonly onInstancesChanged: Event<void>;\n\treadonly onPanelOrientationChanged: Event<Orientation>;\n\n\tfocusPreviousPane(): void;\n\tfocusNextPane(): void;\n\tresizePane(direction: Direction): void;\n\tresizePanes(relativeSizes: number[]): void;\n\tsetActiveInstanceByIndex(index: number, force?: boolean): void;\n\tattachToElement(element: HTMLElement): void;\n\taddInstance(instance: ITerminalInstance): void;\n\tremoveInstance(instance: ITerminalInstance): void;\n\tmoveInstance(instances: SingleOrMany<ITerminalInstance>, index: number, position: 'before' | 'after'): void;\n\tsetVisible(visible: boolean): void;\n\tlayout(width: number, height: number): void;\n\taddDisposable(disposable: IDisposable): void;\n\tsplit(shellLaunchConfig: IShellLaunchConfig): ITerminalInstance;\n\tgetLayoutInfo(isActive: boolean): ITerminalTabLayoutInfoById;\n}\n\nexport const enum TerminalConnectionState {\n\tConnecting,\n\tConnected\n}\n\nexport interface IDetachedXTermOptions {\n\tcols: number;\n\trows: number;\n\tcolorProvider: IXtermColorProvider;\n\tcapabilities?: ITerminalCapabilityStore;\n\treadonly?: boolean;\n\tprocessInfo: ITerminalProcessInfo;\n}\n\n/**\n * A generic interface implemented in both the {@link ITerminalInstance} (an\n * interface used for terminals attached to the terminal panel or editor) and\n * {@link IDetachedTerminalInstance} (a terminal used elsewhere in VS Code UI).\n */\nexport interface IBaseTerminalInstance {\n\treadonly capabilities: ITerminalCapabilityStore;\n\n\t/**\n\t * DOM element the terminal is mounted in.\n\t */\n\treadonly domElement?: HTMLElement;\n\n\t/**\n\t * Current selection in the terminal.\n\t */\n\treadonly selection: string | undefined;\n\n\t/**\n\t * Check if anything is selected in terminal.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Clear current selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Focuses the terminal instance if it's able to (the xterm.js instance must exist).\n\t *\n\t * @param force Force focus even if there is a selection.\n\t */\n\tfocus(force?: boolean): void;\n\n\t/**\n\t * Force the scroll bar to be visible until {@link resetScrollbarVisibility} is called.\n\t */\n\tforceScrollbarVisibility(): void;\n\n\t/**\n\t * Resets the scroll bar to only be visible when needed, this does nothing unless\n\t * {@link forceScrollbarVisibility} was called.\n\t */\n\tresetScrollbarVisibility(): void;\n\n\t/**\n\t * Gets a terminal contribution by its ID.\n\t */\n\tgetContribution<T extends ITerminalContribution>(id: string): T | null;\n}\n\n/**\n * A {@link ITerminalInstance}-like object that emulates a subset of\n * capabilities. This instance is returned from {@link ITerminalService.createDetachedTerminal}\n * to represent terminals that appear in other parts of the VS Code UI outside\n * of the \"Terminal\" view or editors.\n */\nexport interface IDetachedTerminalInstance extends IDisposable, IBaseTerminalInstance {\n\treadonly xterm: IDetachedXtermTerminal;\n\n\t/**\n\t * Attached the terminal to the given element. This should be preferred over\n\t * calling {@link IXtermTerminal.attachToElement} so that extra DOM elements\n\t * for contributions are initialized.\n\t *\n\t * @param container Container the terminal will be rendered in\n\t * @param options Additional options for mounting the terminal in an element\n\t */\n\tattachToElement(container: HTMLElement, options?: Partial<IXtermAttachToElementOptions>): void;\n}\n\nexport const isDetachedTerminalInstance = (t: ITerminalInstance | IDetachedTerminalInstance): t is IDetachedTerminalInstance => !isNumber((t as ITerminalInstance).instanceId);\n\nexport interface ITerminalService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all terminal instances, including editor, terminal view (group), and background instances. */\n\treadonly instances: readonly ITerminalInstance[];\n\n\treadonly foregroundInstances: readonly ITerminalInstance[];\n\n\t/** Gets detached terminal instances created via {@link createDetachedXterm}. */\n\treadonly detachedInstances: Iterable<IDetachedTerminalInstance>;\n\n\treadonly isProcessSupportRegistered: boolean;\n\treadonly connectionState: TerminalConnectionState;\n\treadonly whenConnected: Promise<void>;\n\t/** The number of restored terminal groups on startup. */\n\treadonly restoredGroupCount: number;\n\n\treadonly onDidCreateInstance: Event<ITerminalInstance>;\n\treadonly onDidChangeInstanceDimensions: Event<ITerminalInstance>;\n\treadonly onDidRequestStartExtensionTerminal: Event<IStartExtensionTerminalRequest>;\n\treadonly onDidRegisterProcessSupport: Event<void>;\n\treadonly onDidChangeConnectionState: Event<void>;\n\n\t// Group events\n\treadonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;\n\n\t// Multiplexed events\n\treadonly onAnyInstanceData: Event<{ instance: ITerminalInstance; data: string }>;\n\treadonly onAnyInstanceDataInput: Event<ITerminalInstance>;\n\treadonly onAnyInstanceIconChange: Event<{ instance: ITerminalInstance; userInitiated: boolean }>;\n\treadonly onAnyInstanceMaximumDimensionsChange: Event<ITerminalInstance>;\n\treadonly onAnyInstancePrimaryStatusChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceProcessIdReady: Event<ITerminalInstance>;\n\treadonly onAnyInstanceSelectionChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceTitleChange: Event<ITerminalInstance>;\n\treadonly onAnyInstanceShellTypeChanged: Event<ITerminalInstance>;\n\treadonly onAnyInstanceAddedCapabilityType: Event<TerminalCapability>;\n\n\t/**\n\t * Creates a terminal.\n\t * @param options The options to create the terminal with, when not specified the default\n\t * profile will be used at the default target.\n\t */\n\tcreateTerminal(options?: ICreateTerminalOptions): Promise<ITerminalInstance>;\n\n\t/**\n\t * Creates and focuses a terminal.\n\t * @param options The options to create the terminal with, when not specified the default\n\t * profile will be used at the default target.\n\t */\n\tcreateAndFocusTerminal(options?: ICreateTerminalOptions): Promise<ITerminalInstance>;\n\n\t/**\n\t * Creates a detached xterm instance which is not attached to the DOM or\n\t * tracked as a terminal instance.\n\t * @params options The options to create the terminal with\n\t */\n\tcreateDetachedTerminal(options: IDetachedXTermOptions): Promise<IDetachedTerminalInstance>;\n\n\t/**\n\t * Creates a raw terminal instance, this should not be used outside of the terminal part.\n\t */\n\tgetInstanceFromId(terminalId: number): ITerminalInstance | undefined;\n\n\t/**\n\t * An owner of terminals might be created after reconnection has occurred,\n\t * so store them to be requested/adopted later\n\t * @deprecated Use {@link onDidReconnectToSession}\n\t */\n\tgetReconnectedTerminals(reconnectionOwner: string): ITerminalInstance[] | undefined;\n\n\tgetActiveOrCreateInstance(options?: { acceptsInput?: boolean }): Promise<ITerminalInstance>;\n\trevealTerminal(source: ITerminalInstance, preserveFocus?: boolean): Promise<void>;\n\t/**\n\t * @param instance\n\t * @param suppressSetActive Do not set the active instance when there is only one terminal\n\t * @param forceSaveState Used when the window is shutting down and we need to reveal and save hideFromUser terminals\n\t */\n\tshowBackgroundTerminal(instance: ITerminalInstance, suppressSetActive?: boolean): Promise<void>;\n\trevealActiveTerminal(preserveFocus?: boolean): Promise<void>;\n\tmoveToEditor(source: ITerminalInstance, group?: GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE | AUX_WINDOW_GROUP_TYPE): void;\n\tmoveIntoNewEditor(source: ITerminalInstance): void;\n\tmoveToTerminalView(source: ITerminalInstance | URI): Promise<void>;\n\tgetPrimaryBackend(): ITerminalBackend | undefined;\n\tsetNextCommandId(id: number, commandLine: string, commandId: string): Promise<void>;\n\n\t/**\n\t * Fire the onActiveTabChanged event, this will trigger the terminal dropdown to be updated,\n\t * among other things.\n\t */\n\trefreshActiveGroup(): void;\n\n\tregisterProcessSupport(isSupported: boolean): void;\n\n\tshowProfileQuickPick(type: 'setDefault' | 'createInstance', cwd?: string | URI): Promise<ITerminalInstance | undefined>;\n\n\tsetContainers(panelContainer: HTMLElement, terminalContainer: HTMLElement): void;\n\n\trequestStartExtensionTerminal(proxy: ITerminalProcessExtHostProxy, cols: number, rows: number): Promise<ITerminalLaunchError | undefined>;\n\tisAttachedToTerminal(remoteTerm: IRemoteTerminalAttachTarget): boolean;\n\tsafeDisposeTerminal(instance: ITerminalInstance): Promise<void>;\n\n\tgetDefaultInstanceHost(): ITerminalInstanceHost;\n\tgetInstanceHost(target: ITerminalLocationOptions | undefined): Promise<ITerminalInstanceHost>;\n\n\tresolveLocation(location?: ITerminalLocationOptions): Promise<TerminalLocation | undefined>;\n\tsetNativeDelegate(nativeCalls: ITerminalServiceNativeDelegate): void;\n\n\t/**\n\t * Creates an instance event listener that listens to all instances, dynamically adding new\n\t * instances and removing old instances as needed.\n\t * @param getEvent Maps the instance to the event.\n\t */\n\tcreateOnInstanceEvent<T>(getEvent: (instance: ITerminalInstance) => Event<T>): DynamicListEventMultiplexer<ITerminalInstance, T>;\n\n\t/**\n\t * Creates a capability event listener that listens to capabilities on all instances,\n\t * dynamically adding and removing instances and capabilities as needed.\n\t * @param capabilityId The capability type to listen to an event on.\n\t * @param getEvent Maps the capability to the event.\n\t */\n\tcreateOnInstanceCapabilityEvent<T extends TerminalCapability, K>(capabilityId: T, getEvent: (capability: ITerminalCapabilityImplMap[T]) => Event<K>): IDynamicListEventMultiplexer<{ instance: ITerminalInstance; data: K }>;\n\n\t/**\n\t * Reveals the terminal and, if provided, scrolls to the command mark.\n\t * @param resource the terminal resource\n\t */\n\topenResource(resource: URI): void;\n}\n\n/**\n * A service that provides convenient access to the terminal configuration and derived values.\n */\nexport interface ITerminalConfigurationService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * A typed and partially validated representation of the terminal configuration.\n\t */\n\treadonly config: Readonly<ITerminalConfiguration>;\n\n\t/**\n\t * The default location for terminals.\n\t */\n\treadonly defaultLocation: TerminalLocation;\n\n\t/**\n\t * Fires when something within the terminal configuration changes.\n\t */\n\treadonly onConfigChanged: Event<void>;\n\n\tsetPanelContainer(panelContainer: HTMLElement): void;\n\tconfigFontIsMonospace(): boolean;\n\tgetFont(w: Window, xtermCore?: IXtermCore, excludeDimensions?: boolean): ITerminalFont;\n}\n\nexport class TerminalLinkQuickPickEvent extends MouseEvent {\n\n}\nexport interface ITerminalServiceNativeDelegate {\n\tgetWindowCount(): Promise<number>;\n}\n\n/**\n * This service is responsible for integrating with the editor service and managing terminal\n * editors.\n */\nexport interface ITerminalEditorService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all _terminal editor_ instances. */\n\treadonly instances: readonly ITerminalInstance[];\n\n\topenEditor(instance: ITerminalInstance, editorOptions?: TerminalEditorLocation): Promise<void>;\n\tdetachInstance(instance: ITerminalInstance): void;\n\tsplitInstance(instanceToSplit: ITerminalInstance, shellLaunchConfig?: IShellLaunchConfig): ITerminalInstance;\n\trevealActiveEditor(preserveFocus?: boolean): Promise<void>;\n\tresolveResource(instance: ITerminalInstance): URI;\n\treviveInput(deserializedInput: IDeserializedTerminalEditorInput): EditorInput;\n\tgetInputFromResource(resource: URI): TerminalEditorInput;\n}\n\nexport const terminalEditorId = 'terminalEditor';\n\ninterface ITerminalEditorInputObject {\n\treadonly id: number;\n\treadonly pid: number;\n\treadonly title: string;\n\treadonly titleSource: TitleEventSource;\n\treadonly cwd: string;\n\treadonly icon: TerminalIcon | undefined;\n\treadonly color: string | undefined;\n\treadonly hasChildProcesses?: boolean;\n\treadonly type?: TerminalType;\n\treadonly isFeatureTerminal?: boolean;\n\treadonly hideFromUser?: boolean;\n\treadonly reconnectionProperties?: IReconnectionProperties;\n\treadonly shellIntegrationNonce: string;\n}\n\nexport interface ISerializedTerminalEditorInput extends ITerminalEditorInputObject {\n}\n\nexport interface IDeserializedTerminalEditorInput extends ITerminalEditorInputObject {\n}\n\nexport type ITerminalLocationOptions = TerminalLocation | TerminalEditorLocation | { parentTerminal: MaybePromise<ITerminalInstance> } | { splitActiveTerminal: boolean };\n\nexport interface ICreateTerminalOptions {\n\t/**\n\t * The shell launch config or profile to launch with, when not specified the default terminal\n\t * profile will be used.\n\t */\n\tconfig?: IShellLaunchConfig | ITerminalProfile | IExtensionTerminalProfile;\n\t/**\n\t * The current working directory to start with, this will override IShellLaunchConfig.cwd if\n\t * specified.\n\t */\n\tcwd?: string | URI;\n\t/**\n\t * The terminal's resource, passed when the terminal has moved windows.\n\t */\n\tresource?: URI;\n\n\t/**\n\t * The terminal's location (editor or panel), it's terminal parent (split to the right), or editor group\n\t */\n\tlocation?: ITerminalLocationOptions;\n\n\t/**\n\t * This terminal will not wait for contributed profiles to resolve which means it will proceed\n\t * when the workbench is not yet loaded.\n\t */\n\tskipContributedProfileCheck?: boolean;\n}\n\nexport interface TerminalEditorLocation {\n\tviewColumn: GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE | AUX_WINDOW_GROUP_TYPE;\n\tpreserveFocus?: boolean;\n\tauxiliary?: IEditorOptions['auxiliary'];\n}\n\n/**\n * This service is responsible for managing terminal groups, that is the terminals that are hosted\n * within the terminal panel, not in an editor.\n */\nexport interface ITerminalGroupService extends ITerminalInstanceHost {\n\treadonly _serviceBrand: undefined;\n\n\t/** Gets all _terminal view_ instances, ie. instances contained within terminal groups. */\n\treadonly instances: readonly ITerminalInstance[];\n\treadonly groups: readonly ITerminalGroup[];\n\tactiveGroup: ITerminalGroup | undefined;\n\treadonly activeGroupIndex: number;\n\t/**\n\t * Gets or sets the last accessed menu, this is used to select the instance(s) for menu actions.\n\t */\n\tlastAccessedMenu: 'inline-tab' | 'tab-list';\n\n\treadonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;\n\treadonly onDidDisposeGroup: Event<ITerminalGroup>;\n\t/** Fires when a group is created, disposed of, or shown (in the case of a background group). */\n\treadonly onDidChangeGroups: Event<void>;\n\t/** Fires when the panel has been shown and expanded, so has non-zero dimensions. */\n\treadonly onDidShow: Event<void>;\n\treadonly onDidChangePanelOrientation: Event<Orientation>;\n\n\tcreateGroup(shellLaunchConfig?: IShellLaunchConfig): ITerminalGroup;\n\tcreateGroup(instance?: ITerminalInstance): ITerminalGroup;\n\tgetGroupForInstance(instance: ITerminalInstance): ITerminalGroup | undefined;\n\n\t/**\n\t * Moves a terminal instance's group to the target instance group's position.\n\t * @param source The source instance to move.\n\t * @param target The target instance to move the source instance to.\n\t */\n\tmoveGroup(source: SingleOrMany<ITerminalInstance>, target: ITerminalInstance): void;\n\tmoveGroupToEnd(source: SingleOrMany<ITerminalInstance>): void;\n\n\tmoveInstance(source: ITerminalInstance, target: ITerminalInstance, side: 'before' | 'after'): void;\n\tunsplitInstance(instance: ITerminalInstance): void;\n\tjoinInstances(instances: ITerminalInstance[]): void;\n\tinstanceIsSplit(instance: ITerminalInstance): boolean;\n\n\tgetGroupLabels(): string[];\n\tsetActiveGroupByIndex(index: number): void;\n\tsetActiveGroupToNext(): void;\n\tsetActiveGroupToPrevious(): void;\n\n\tsetActiveInstanceByIndex(terminalIndex: number): void;\n\n\tsetContainer(container: HTMLElement): void;\n\n\tshowPanel(focus?: boolean): Promise<void>;\n\thidePanel(): void;\n\tfocusTabs(): void;\n\tfocusHover(): void;\n\tupdateVisibility(): void;\n}\n\n/**\n * An interface that indicates the implementer hosts terminal instances, exposing a common set of\n * properties and events.\n */\nexport interface ITerminalInstanceHost {\n\treadonly activeInstance: ITerminalInstance | undefined;\n\treadonly instances: readonly ITerminalInstance[];\n\n\treadonly onDidDisposeInstance: Event<ITerminalInstance>;\n\treadonly onDidFocusInstance: Event<ITerminalInstance>;\n\treadonly onDidChangeActiveInstance: Event<ITerminalInstance | undefined>;\n\treadonly onDidChangeInstances: Event<void>;\n\treadonly onDidChangeInstanceCapability: Event<ITerminalInstance>;\n\n\tsetActiveInstance(instance: ITerminalInstance): void;\n\t/**\n\t * Reveal and focus the instance, regardless of its location.\n\t */\n\tfocusInstance(instance: ITerminalInstance): void;\n\t/**\n\t * Reveal and focus the active instance, regardless of its location.\n\t */\n\tfocusActiveInstance(): Promise<void>;\n\t/**\n\t * Gets an instance from a resource if it exists. This MUST be used instead of getInstanceFromId\n\t * when you only know about a terminal's URI. (a URI's instance ID may not be this window's instance ID)\n\t */\n\tgetInstanceFromResource(resource: UriComponents | undefined): ITerminalInstance | undefined;\n}\n\n/**\n * Similar to xterm.js' ILinkProvider but using promises and hides xterm.js internals (like buffer\n * positions, decorations, etc.) from the rest of vscode. This is the interface to use for\n * workbench integrations.\n */\nexport interface ITerminalExternalLinkProvider {\n\tprovideLinks(instance: ITerminalInstance, line: string): Promise<ITerminalLink[] | undefined>;\n}\n\nexport interface ITerminalLink {\n\t/** The startIndex of the link in the line. */\n\tstartIndex: number;\n\t/** The length of the link in the line. */\n\tlength: number;\n\t/** The descriptive label for what the link does when activated. */\n\tlabel?: string;\n\t/**\n\t * Activates the link.\n\t * @param text The text of the link.\n\t */\n\tactivate(text: string): void;\n}\n\nexport interface ISearchOptions {\n\t/** Whether the find should be done as a regex. */\n\tregex?: boolean;\n\t/** Whether only whole words should match. */\n\twholeWord?: boolean;\n\t/** Whether find should pay attention to case. */\n\tcaseSensitive?: boolean;\n\t/** Whether the search should start at the current search position (not the next row). */\n\tincremental?: boolean;\n}\n\nexport interface ITerminalInstance extends IBaseTerminalInstance {\n\t/**\n\t * The ID of the terminal instance, this is an arbitrary number only used to uniquely identify\n\t * terminal instances within a window.\n\t */\n\treadonly instanceId: number;\n\t/**\n\t * A unique URI for this terminal instance with the following encoding:\n\t * path: /<workspace ID>/<instance ID>\n\t * fragment: Title\n\t * Note that when dragging terminals across windows, this will retain the original workspace ID /instance ID\n\t * from the other window.\n\t */\n\treadonly resource: URI;\n\n\treadonly cols: number;\n\treadonly rows: number;\n\treadonly maxCols: number;\n\treadonly maxRows: number;\n\treadonly fixedCols?: number;\n\treadonly fixedRows?: number;\n\treadonly domElement: HTMLElement;\n\treadonly icon?: TerminalIcon;\n\treadonly color?: string;\n\treadonly reconnectionProperties?: IReconnectionProperties;\n\treadonly processName: string;\n\treadonly sequence?: string;\n\treadonly staticTitle?: string;\n\treadonly progressState?: IProgressState;\n\treadonly workspaceFolder?: IWorkspaceFolder;\n\treadonly cwd?: string;\n\treadonly initialCwd?: string;\n\treadonly os?: OperatingSystem;\n\treadonly usedShellIntegrationInjection: boolean;\n\treadonly shellIntegrationInjectionFailureReason: ShellIntegrationInjectionFailureReason | undefined;\n\treadonly injectedArgs: string[] | undefined;\n\treadonly extEnvironmentVariableCollection: IMergedEnvironmentVariableCollection | undefined;\n\n\t/**\n\t * The underlying disposable store, allowing objects who share the same lifecycle as the\n\t * terminal instance but are created externally to be managed by the instance.\n\t */\n\treadonly store: DisposableStore;\n\n\treadonly statusList: ITerminalStatusList;\n\n\t/**\n\t * The process ID of the shell process, this is undefined when there is no process associated\n\t * with this terminal.\n\t */\n\tprocessId: number | undefined;\n\n\t/**\n\t * The position of the terminal.\n\t */\n\ttarget: TerminalLocation | undefined;\n\ttargetRef: IReference<TerminalLocation | undefined>;\n\n\t/**\n\t * The id of a persistent process. This is defined if this is a terminal created by a pty host\n\t * that supports reconnection.\n\t */\n\treadonly persistentProcessId: number | undefined;\n\n\t/**\n\t * Whether the process should be persisted across reloads.\n\t */\n\treadonly shouldPersist: boolean;\n\n\t/*\n\t * Whether this terminal has been disposed of\n\t */\n\treadonly isDisposed: boolean;\n\n\t/**\n\t * Whether the terminal's pty is hosted on a remote.\n\t */\n\treadonly hasRemoteAuthority: boolean;\n\n\t/**\n\t * The remote authority of the terminal's pty.\n\t */\n\treadonly remoteAuthority: string | undefined;\n\n\t/**\n\t * Whether an element within this terminal is focused.\n\t */\n\treadonly hasFocus: boolean;\n\n\t/**\n\t * The ID of the session that this terminal is connected to\n\t */\n\treadonly sessionId: string;\n\n\t/**\n\t * Get or set the behavior of the terminal when it closes. This was indented only to be called\n\t * after reconnecting to a terminal.\n\t */\n\twaitOnExit: WaitOnExitValue | undefined;\n\n\t/**\n\t * An event that fires when the terminal instance's title changes.\n\t */\n\treadonly onTitleChanged: Event<ITerminalInstance>;\n\n\t/**\n\t * An event that fires when the terminal instance's icon changes.\n\t */\n\treadonly onIconChanged: Event<{ instance: ITerminalInstance; userInitiated: boolean }>;\n\n\t/**\n\t * An event that fires when the terminal instance is disposed.\n\t */\n\treadonly onDisposed: Event<ITerminalInstance>;\n\n\treadonly onProcessIdReady: Event<ITerminalInstance>;\n\treadonly onProcessReplayComplete: Event<void>;\n\treadonly onRequestExtHostProcess: Event<ITerminalInstance>;\n\treadonly onDimensionsChanged: Event<void>;\n\treadonly onMaximumDimensionsChanged: Event<void>;\n\treadonly onDidChangeHasChildProcesses: Event<boolean>;\n\n\treadonly onDidFocus: Event<ITerminalInstance>;\n\treadonly onDidRequestFocus: Event<void>;\n\treadonly onDidBlur: Event<ITerminalInstance>;\n\treadonly onDidInputData: Event<string>;\n\treadonly onDidChangeSelection: Event<ITerminalInstance>;\n\treadonly onDidExecuteText: Event<void>;\n\treadonly onDidChangeTarget: Event<TerminalLocation | undefined>;\n\treadonly onDidSendText: Event<string>;\n\treadonly onDidChangeShellType: Event<TerminalShellType>;\n\treadonly onDidChangeVisibility: Event<boolean>;\n\n\t/**\n\t * An event that fires when a terminal is dropped on this instance via drag and drop.\n\t */\n\treadonly onRequestAddInstanceToGroup: Event<IRequestAddInstanceToGroupEvent>;\n\n\t/**\n\t * Attach a listener to the raw data stream coming from the pty, including ANSI escape\n\t * sequences.\n\t */\n\treadonly onData: Event<string>;\n\treadonly onWillData: Event<string>;\n\n\t/**\n\t * Attach a listener to the binary data stream coming from xterm and going to pty\n\t */\n\treadonly onBinary: Event<string>;\n\n\t/**\n\t * Attach a listener to listen for new lines added to this terminal instance.\n\t *\n\t * @param listener The listener function which takes new line strings added to the terminal,\n\t * excluding ANSI escape sequences. The line event will fire when an LF character is added to\n\t * the terminal (ie. the line is not wrapped). Note that this means that the line data will\n\t * not fire for the last line, until either the line is ended with a LF character of the process\n\t * is exited. The lineData string will contain the fully wrapped line, not containing any LF/CR\n\t * characters.\n\t */\n\treadonly onLineData: Event<string>;\n\n\t/**\n\t * Attach a listener that fires when the terminal's pty process exits. The number in the event\n\t * is the processes' exit code, an exit code of undefined means the process was killed as a result of\n\t * the ITerminalInstance being disposed.\n\t */\n\treadonly onExit: Event<number | ITerminalLaunchError | undefined>;\n\n\t/**\n\t * The exit code or undefined when the terminal process hasn't yet exited or\n\t * the process exit code could not be determined. Use {@link exitReason} to see\n\t * why the process has exited.\n\t */\n\treadonly exitCode: number | undefined;\n\n\t/**\n\t * The reason the terminal process exited, this will be undefined if the process is still\n\t * running.\n\t */\n\treadonly exitReason: TerminalExitReason | undefined;\n\n\t/**\n\t * The xterm.js instance for this terminal.\n\t */\n\treadonly xterm?: XtermTerminal;\n\n\t/**\n\t * Resolves when the xterm.js instance for this terminal is ready.\n\t */\n\treadonly xtermReadyPromise: Promise<XtermTerminal | undefined>;\n\n\t/**\n\t * Returns an array of data events that have fired within the first 10 seconds. If this is\n\t * called 10 seconds after the terminal has existed the result will be undefined. This is useful\n\t * when objects that depend on the data events have delayed initialization, like extension\n\t * hosts.\n\t */\n\treadonly initialDataEvents: string[] | undefined;\n\n\t/** A promise that resolves when the terminal's pty/process have been created. */\n\treadonly processReady: Promise<void>;\n\n\t/** Whether the terminal's process has child processes (ie. is dirty/busy). */\n\treadonly hasChildProcesses: boolean;\n\n\t/**\n\t * The title of the terminal. This is either title or the process currently running or an\n\t * explicit name given to the terminal instance through the extension API.\n\t */\n\treadonly title: string;\n\n\t/**\n\t * How the current title was set.\n\t */\n\treadonly titleSource: TitleEventSource;\n\n\t/**\n\t * The shell type of the terminal.\n\t */\n\treadonly shellType: TerminalShellType | undefined;\n\n\t/**\n\t * The focus state of the terminal before exiting.\n\t */\n\treadonly hadFocusOnExit: boolean;\n\n\t/**\n\t * False when the title is set by an API or the user. We check this to make sure we\n\t * do not override the title when the process title changes in the terminal.\n\t */\n\tisTitleSetByProcess: boolean;\n\n\t/**\n\t * The shell launch config used to launch the shell.\n\t */\n\treadonly shellLaunchConfig: IShellLaunchConfig;\n\n\t/**\n\t * Whether to disable layout for the terminal. This is useful when the size of the terminal is\n\t * being manipulating (e.g. adding a split pane) and we want the terminal to ignore particular\n\t * resize events.\n\t */\n\tdisableLayout: boolean;\n\n\t/**\n\t * The description of the terminal, this is typically displayed next to {@link title}.\n\t */\n\tdescription: string | undefined;\n\n\t/**\n\t * The remote-aware $HOME directory (or Windows equivalent) of the terminal.\n\t */\n\tuserHome: string | undefined;\n\n\t/**\n\t * The nonce used to verify commands coming from shell integration.\n\t */\n\tshellIntegrationNonce: string;\n\n\t/**\n\t * Registers and returns a marker\n\t * @param the y offset from the cursor\n\t */\n\tregisterMarker(offset?: number): IMarker | undefined;\n\n\t/**\n\t * Adds a marker to the buffer, mapping it to an ID if provided.\n\t */\n\taddBufferMarker(properties: IMarkProperties): void;\n\n\t/**\n\t *\n\t * @param startMarkId The ID for the start marker\n\t * @param endMarkId The ID for the end marker\n\t * @param highlight Whether the buffer from startMarker to endMarker\n\t * should be highlighted\n\t */\n\tscrollToMark(startMarkId: string, endMarkId?: string, highlight?: boolean): void;\n\n\t/**\n\t * Dispose the terminal instance, removing it from the panel/service and freeing up resources.\n\t *\n\t * @param reason The reason why the terminal is being disposed\n\t */\n\tdispose(reason?: TerminalExitReason): void;\n\n\t/**\n\t * Informs the process that the terminal is now detached and\n\t * then disposes the terminal.\n\t *\n\t * @param reason The reason why the terminal is being disposed\n\t */\n\tdetachProcessAndDispose(reason: TerminalExitReason): Promise<void>;\n\n\t/**\n\t * When the panel is hidden or a terminal in the editor area becomes inactive, reset the focus context key\n\t * to avoid issues like #147180.\n\t */\n\tresetFocusContextKey(): void;\n\n\t/**\n\t * Focuses the terminal instance when it's ready (the xterm.js instance much exist). This is the\n\t * best focus call when the terminal is being shown for example.\n\t * when the terminal is being shown.\n\t *\n\t * @param force Force focus even if there is a selection.\n\t */\n\tfocusWhenReady(force?: boolean): Promise<void>;\n\n\t/**\n\t * Send text to the terminal instance. The text is written to the stdin of the underlying pty\n\t * process (shell) of the terminal instance.\n\t *\n\t * @param text The text to send.\n\t * @param shouldExecute Indicates that the text being sent should be executed rather than just inserted in the terminal.\n\t * The character(s) added are \\n or \\r\\n, depending on the platform. This defaults to `true`.\n\t * @param bracketedPasteMode Whether to wrap the text in the bracketed paste mode sequence when\n\t * it's enabled. When true, the shell will treat the text as if it were pasted into the shell,\n\t * this may for example select the text and it will also ensure that the text will not be\n\t * interpreted as a shell keybinding.\n\t */\n\tsendText(text: string, shouldExecute: boolean, bracketedPasteMode?: boolean): Promise<void>;\n\n\t/**\n\t * Sends a signal to the terminal instance's process.\n\t *\n\t * @param signal The signal to send (e.g., 'SIGTERM', 'SIGINT', 'SIGKILL').\n\t */\n\tsendSignal(signal: string): Promise<void>;\n\n\t/**\n\t * Sends a path to the terminal instance, preparing it as needed based on the detected shell\n\t * running within the terminal. The text is written to the stdin of the underlying pty process\n\t * (shell) of the terminal instance.\n\t *\n\t * @param originalPath The path to send.\n\t * @param shouldExecute Indicates that the text being sent should be executed rather than just inserted in the terminal.\n\t * The character(s) added are \\n or \\r\\n, depending on the platform. This defaults to `true`.\n\t */\n\tsendPath(originalPath: string | URI, shouldExecute: boolean): Promise<void>;\n\n\trunCommand(command: string, shouldExecute?: boolean, commandId?: string): Promise<void>;\n\n\t/**\n\t * Takes a path and returns the properly escaped path to send to a given shell. On Windows, this\n\t * includes trying to prepare the path for WSL if needed.\n\t *\n\t * @param originalPath The path to be escaped and formatted.\n\t */\n\tpreparePathForShell(originalPath: string): Promise<string>;\n\n\t/**\n\t * Formats a file system URI for display in UI so that it appears in the terminal shell's format.\n\t * @param uri The URI to format.\n\t */\n\tgetUriLabelForShell(uri: URI): Promise<string>;\n\n\t/** Scroll the terminal buffer down 1 line. */   scrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page. */   scrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */ scrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line. */     scrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page. */     scrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top. */    scrollToTop(): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line and moving it to the top of the\n\t * viewport.\n\t */\n\tclearBuffer(): void;\n\n\t/**\n\t * Attaches the terminal instance to an element on the DOM, before this is called the terminal\n\t * instance process may run in the background but cannot be displayed on the UI.\n\t *\n\t * @param container The element to attach the terminal instance to.\n\t */\n\tattachToElement(container: HTMLElement): void;\n\n\t/**\n\t * Detaches the terminal instance from the terminal editor DOM element.\n\t */\n\tdetachFromElement(): void;\n\n\t/**\n\t * Layout the terminal instance.\n\t *\n\t * @param dimension The dimensions of the container.\n\t */\n\tlayout(dimension: { width: number; height: number }): void;\n\n\t/**\n\t * Sets whether the terminal instance's element is visible in the DOM.\n\t *\n\t * @param visible Whether the element is visible.\n\t */\n\tsetVisible(visible: boolean): void;\n\n\t/**\n\t * Immediately kills the terminal's current pty process and launches a new one to replace it.\n\t *\n\t * @param shell The new launch configuration.\n\t */\n\treuseTerminal(shell: IShellLaunchConfig): Promise<void>;\n\n\t/**\n\t * Relaunches the terminal, killing it and reusing the launch config used initially. Any\n\t * environment variable changes will be recalculated when this happens.\n\t */\n\trelaunch(): void;\n\n\t/**\n\t * Sets the terminal instance's dimensions to the values provided via the onDidOverrideDimensions event,\n\t * which allows overriding the regular dimensions (fit to the size of the panel).\n\t */\n\tsetOverrideDimensions(dimensions: ITerminalDimensions): void;\n\n\t/**\n\t * Sets the terminal instance's dimensions to the values provided via quick input.\n\t */\n\tsetFixedDimensions(): Promise<void>;\n\n\t/**\n\t * Toggles terminal line wrapping.\n\t */\n\ttoggleSizeToContentWidth(): Promise<void>;\n\n\t/**\n\t * Gets the initial current working directory, fetching it from the backend if required.\n\t */\n\tgetInitialCwd(): Promise<string>;\n\n\t/**\n\t * Gets the current working directory from cwd detection capabilities if available, otherwise\n\t * from the backend. This will return the initial cwd if cwd detection is not available (ie.\n\t * on Windows when shell integration is disabled).\n\t */\n\tgetSpeculativeCwd(): Promise<string>;\n\n\t/**\n\t * Gets the cwd as a URI that has been validated to exist.\n\t */\n\tgetCwdResource(): Promise<URI | undefined>;\n\n\t/**\n\t * Sets the title of the terminal to the provided string. If no title is provided, it will reset\n\t * to the terminal's title if it was not explicitly set by the user or API.\n\t * @param title The new title.\n\t */\n\trename(title?: string): Promise<void>;\n\n\t/**\n\t * Sets or triggers a quick pick to change the icon of this terminal.\n\t */\n\tchangeIcon(icon?: TerminalIcon): Promise<TerminalIcon | undefined>;\n\n\t/**\n\t * Sets or triggers a quick pick to change the color of the associated terminal tab icon.\n\t */\n\tchangeColor(color?: string, skipQuickPick?: boolean): Promise<string | undefined>;\n\n\t/**\n\t * Attempts to detect and kill the process listening on specified port.\n\t * If successful, places commandToRun on the command line\n\t */\n\tfreePortKillProcess(port: string, commandToRun: string): Promise<void>;\n\n\t/**\n\t * Update the parent context key service to use for this terminal instance.\n\t */\n\tsetParentContextKeyService(parentContextKeyService: IContextKeyService): void;\n\n\t/**\n\t * Handles a mouse event for the terminal, this may happen on an anscestor of the terminal\n\t * instance's element.\n\t * @param event The mouse event.\n\t * @param contextMenu The context menu to show if needed.\n\t * @returns Whether the context menu should be suppressed.\n\t */\n\thandleMouseEvent(event: MouseEvent, contextMenu: IMenu): Promise<{ cancelContextMenu: boolean } | void>;\n}\n\nexport const enum XtermTerminalConstants {\n\tSearchHighlightLimit = 20000\n}\n\nexport interface IXtermAttachToElementOptions {\n\t/**\n\t * Whether GPU rendering should be enabled for this element, defaults to true.\n\t */\n\tenableGpu: boolean;\n}\n\nexport interface IXtermTerminal extends IDisposable {\n\t/**\n\t * An object that tracks when commands are run and enables navigating and selecting between\n\t * them.\n\t */\n\treadonly markTracker: IMarkTracker;\n\n\t/**\n\t * Reports the status of shell integration and fires events relating to it.\n\t */\n\treadonly shellIntegration: IShellIntegration;\n\n\treadonly decorationAddon: IDecorationAddon;\n\n\treadonly onDidChangeSelection: Event<void>;\n\treadonly onDidChangeFindResults: Event<{ resultIndex: number; resultCount: number }>;\n\treadonly onDidRequestRunCommand: Event<{ command: ITerminalCommand; noNewLine?: boolean }>;\n\treadonly onDidRequestCopyAsHtml: Event<{ command: ITerminalCommand }>;\n\n\t/**\n\t * Event fired when focus enters (fires with true) or leaves (false) the terminal.\n\t */\n\treadonly onDidChangeFocus: Event<boolean>;\n\n\t/**\n\t * Gets a view of the current texture atlas used by the renderers.\n\t */\n\treadonly textureAtlas: Promise<ImageBitmap> | undefined;\n\n\t/**\n\t * Whether the `disableStdin` option in xterm.js is set.\n\t */\n\treadonly isStdinDisabled: boolean;\n\n\t/**\n\t * Whether the terminal is currently focused.\n\t */\n\treadonly isFocused: boolean;\n\n\t/**\n\t * Whether a canvas-based renderer is being used.\n\t */\n\treadonly isGpuAccelerated: boolean;\n\n\t/**\n\t * The last `onData` input event fired by {@link RawXtermTerminal.onData}.\n\t */\n\treadonly lastInputEvent: string | undefined;\n\n\t/**\n\t * Attached the terminal to the given element\n\t * @param container Container the terminal will be rendered in\n\t * @param options Additional options for mounting the terminal in an element\n\t */\n\tattachToElement(container: HTMLElement, options?: Partial<IXtermAttachToElementOptions>): void;\n\n\tfindResult?: { resultIndex: number; resultCount: number };\n\n\t/**\n\t * Find the next instance of the term\n\t*/\n\tfindNext(term: string, searchOptions: ISearchOptions): Promise<boolean>;\n\n\t/**\n\t * Find the previous instance of the term\n\t */\n\tfindPrevious(term: string, searchOptions: ISearchOptions): Promise<boolean>;\n\n\t/**\n\t * Forces the terminal to redraw its viewport.\n\t */\n\tforceRedraw(): void;\n\n\t/**\n\t * Gets the font metrics of this xterm.js instance.\n\t */\n\tgetFont(): ITerminalFont;\n\n\t/**\n\t * Gets whether there's any terminal selection.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Clears any terminal selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Selects all terminal contents/\n\t */\n\tselectAll(): void;\n\n\t/**\n\t * Selects the content between the two markers by their VS Code OSC `SetMarker`\n\t * ID. It's a no-op if either of the two markers are not found.\n\t *\n\t * @param fromMarkerId Start marker ID\n\t * @param toMarkerId End marker ID\n\t * @param scrollIntoView Whether the terminal should scroll to the start of\n\t * the range, defaults tof alse\n\t */\n\tselectMarkedRange(fromMarkerId: string, toMarkerId: string, scrollIntoView?: boolean): void;\n\n\t/**\n\t * Copies the terminal selection.\n\t * @param copyAsHtml Whether to copy selection as HTML, defaults to false.\n\t */\n\tcopySelection(copyAsHtml?: boolean, command?: ITerminalCommand): void;\n\t/**\n\t * Focuses the terminal. Warning: {@link ITerminalInstance.focus} should be\n\t * preferred when dealing with terminal instances in order to get\n\t * accessibility triggers.\n\t */\n\tfocus(): void;\n\n\t/** Scroll the terminal buffer down 1 line.   */ scrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page.   */ scrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */ scrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line.     */ scrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page.     */ scrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top.    */ scrollToTop(): void;\n\t/** Scroll the terminal buffer to a set line  */ scrollToLine(line: number, position?: ScrollPosition): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line and moving it to the top of the\n\t * viewport.\n\t */\n\tclearBuffer(): void;\n\n\t/**\n\t * Clears the search result decorations\n\t */\n\tclearSearchDecorations(): void;\n\n\t/**\n\t * Clears the active search result decorations\n\t */\n\tclearActiveSearchDecoration(): void;\n\n\t/**\n\t * Returns a reverse iterator of buffer lines as strings\n\t */\n\tgetBufferReverseIterator(): IterableIterator<string>;\n\n\t/**\n\t * Gets the contents of the buffer from a start marker (or line 0) to the end marker (or the\n\t * last line).\n\t */\n\tgetContentsAsText(startMarker?: IXtermMarker, endMarker?: IXtermMarker): string;\n\n\t/**\n\t * Gets the buffer contents as HTML.\n\t */\n\tgetContentsAsHtml(): Promise<string>;\n\n\t/**\n\t * Refreshes the terminal after it has been moved.\n\t */\n\trefresh(): void;\n\n\tgetXtermTheme(theme?: IColorTheme): ITheme;\n}\n\nexport interface IDetachedXtermTerminal extends IXtermTerminal {\n\t/**\n\t * Writes data to the terminal.\n\t * @param data data to write\n\t * @param callback Optional callback that fires when the data was processed\n\t * by the parser.\n\t */\n\twrite(data: string | Uint8Array, callback?: () => void): void;\n\n\t/**\n\t * Resizes the terminal.\n\t */\n\tresize(columns: number, rows: number): void;\n}\n\nexport interface IInternalXtermTerminal {\n\t/**\n\t * Writes text directly to the terminal, bypassing the process.\n\t *\n\t * **WARNING:** This should never be used outside of the terminal component and only for\n\t * developer purposed inside the terminal component.\n\t */\n\t_writeText(data: string): void; // eslint-disable-line @typescript-eslint/naming-convention\n}\n\nexport interface IXtermColorProvider {\n\tgetBackgroundColor(theme: IColorTheme): Color | undefined;\n}\n\nexport interface IRequestAddInstanceToGroupEvent {\n\turi: URI;\n\tside: 'before' | 'after';\n}\n\nexport const enum LinuxDistro {\n\tUnknown = 1,\n\tFedora = 2,\n\tUbuntu = 3,\n}\n\nexport const enum TerminalDataTransfers {\n\tTerminals = 'Terminals'\n}\n"]}