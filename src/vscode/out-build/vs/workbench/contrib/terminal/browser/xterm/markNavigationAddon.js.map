{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminal/browser/xterm/markNavigationAddon.ts","vs/workbench/contrib/terminal/browser/xterm/markNavigationAddon.ts"],"names":[],"mappings":"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","file":"markNavigationAddon.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from '../../../../../base/common/arrays.js';\nimport { Disposable, DisposableStore, MutableDisposable, dispose } from '../../../../../base/common/lifecycle.js';\nimport { IMarkTracker } from '../terminal.js';\nimport { ITerminalCapabilityStore, ITerminalCommand, TerminalCapability } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport type { Terminal, IMarker, ITerminalAddon, IDecoration, IBufferRange } from '@xterm/xterm';\nimport { timeout } from '../../../../../base/common/async.js';\nimport { IThemeService } from '../../../../../platform/theme/common/themeService.js';\nimport { TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR } from '../../common/terminalColorRegistry.js';\nimport { getWindow } from '../../../../../base/browser/dom.js';\nimport { ICurrentPartialCommand, isFullTerminalCommand } from '../../../../../platform/terminal/common/capabilities/commandDetection/terminalCommand.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { TerminalContribSettingId } from '../../terminalContribExports.js';\n\nenum Boundary {\n\tTop,\n\tBottom\n}\n\nexport const enum ScrollPosition {\n\tTop,\n\tMiddle\n}\n\ninterface IScrollToMarkerOptions {\n\thideDecoration?: boolean;\n\t/** Scroll even if the line is within the viewport */\n\tforceScroll?: boolean;\n\tbufferRange?: IBufferRange;\n}\n\nexport class MarkNavigationAddon extends Disposable implements IMarkTracker, ITerminalAddon {\n\tprivate _currentMarker: IMarker | Boundary = Boundary.Bottom;\n\tprivate _selectionStart: IMarker | Boundary | null = null;\n\tprivate _isDisposable: boolean = false;\n\tprotected _terminal: Terminal | undefined;\n\tprivate _navigationDecorations: IDecoration[] | undefined;\n\n\tprivate _activeCommandGuide?: ITerminalCommand;\n\tprivate readonly _commandGuideDecorations = this._register(new MutableDisposable<DisposableStore>());\n\n\tactivate(terminal: Terminal): void {\n\t\tthis._terminal = terminal;\n\t\tthis._register(this._terminal.onData(() => {\n\t\t\tthis._currentMarker = Boundary.Bottom;\n\t\t}));\n\t}\n\n\tconstructor(\n\t\tprivate readonly _capabilities: ITerminalCapabilityStore,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IThemeService private readonly _themeService: IThemeService\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate _getMarkers(skipEmptyCommands?: boolean): readonly IMarker[] {\n\t\tconst commandCapability = this._capabilities.get(TerminalCapability.CommandDetection);\n\t\tconst partialCommandCapability = this._capabilities.get(TerminalCapability.PartialCommandDetection);\n\t\tconst markCapability = this._capabilities.get(TerminalCapability.BufferMarkDetection);\n\t\tlet markers: IMarker[] = [];\n\t\tif (commandCapability) {\n\t\t\tmarkers = coalesce(commandCapability.commands.filter(e => skipEmptyCommands ? e.exitCode !== undefined : true).map(e => e.promptStartMarker ?? e.marker));\n\t\t\t// Allow navigating to the current command iff it has been executed, this ignores the\n\t\t\t// skipEmptyCommands flag intenionally as chances are it's not going to be empty if an\n\t\t\t// executed marker exists when this is requested.\n\t\t\tif (commandCapability.currentCommand?.promptStartMarker && commandCapability.currentCommand.commandExecutedMarker) {\n\t\t\t\tmarkers.push(commandCapability.currentCommand?.promptStartMarker);\n\t\t\t}\n\t\t} else if (partialCommandCapability) {\n\t\t\tmarkers.push(...partialCommandCapability.commands);\n\t\t}\n\n\t\tif (markCapability && !skipEmptyCommands) {\n\t\t\tlet next = markCapability.markers().next()?.value;\n\t\t\tconst arr: IMarker[] = [];\n\t\t\twhile (next) {\n\t\t\t\tarr.push(next);\n\t\t\t\tnext = markCapability.markers().next()?.value;\n\t\t\t}\n\t\t\tmarkers = arr;\n\t\t}\n\t\treturn markers;\n\t}\n\n\tprivate _findCommand(marker: IMarker): ITerminalCommand | ICurrentPartialCommand | undefined {\n\t\tconst commandCapability = this._capabilities.get(TerminalCapability.CommandDetection);\n\t\tif (commandCapability) {\n\t\t\tconst command = commandCapability.commands.find(e => e.marker?.line === marker.line || e.promptStartMarker?.line === marker.line);\n\t\t\tif (command) {\n\t\t\t\treturn command;\n\t\t\t}\n\t\t\tif (commandCapability.currentCommand) {\n\t\t\t\treturn commandCapability.currentCommand;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tclear(): void {\n\t\t// Clear the current marker so successive focus/selection actions are performed from the\n\t\t// bottom of the buffer\n\t\tthis._currentMarker = Boundary.Bottom;\n\t\tthis._resetNavigationDecorations();\n\t\tthis._selectionStart = null;\n\t}\n\n\tprivate _resetNavigationDecorations() {\n\t\tif (this._navigationDecorations) {\n\t\t\tdispose(this._navigationDecorations);\n\t\t}\n\t\tthis._navigationDecorations = [];\n\t}\n\n\tprivate _isEmptyCommand(marker: IMarker | Boundary) {\n\t\tif (marker === Boundary.Bottom) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (marker === Boundary.Top) {\n\t\t\treturn !this._getMarkers(true).map(e => e.line).includes(0);\n\t\t}\n\n\t\treturn !this._getMarkers(true).includes(marker);\n\t}\n\n\tscrollToPreviousMark(scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false, skipEmptyCommands: boolean = true): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tlet markerIndex;\n\t\tconst currentLineY = typeof this._currentMarker === 'object'\n\t\t\t? this.getTargetScrollLine(this._currentMarker.line, scrollPosition)\n\t\t\t: Math.min(getLine(this._terminal, this._currentMarker), this._terminal.buffer.active.baseY);\n\t\tconst viewportY = this._terminal.buffer.active.viewportY;\n\t\tif (typeof this._currentMarker === 'object' ? !this._isMarkerInViewport(this._terminal, this._currentMarker) : currentLineY !== viewportY) {\n\t\t\t// The user has scrolled, find the line based on the current scroll position. This only\n\t\t\t// works when not retaining selection\n\t\t\tconst markersBelowViewport = this._getMarkers(skipEmptyCommands).filter(e => e.line >= viewportY).length;\n\t\t\t// -1 will scroll to the top\n\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).length - markersBelowViewport - 1;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).length - 1;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\tmarkerIndex = -1;\n\t\t} else if (this._isDisposable) {\n\t\t\tmarkerIndex = this._findPreviousMarker(skipEmptyCommands);\n\t\t\tthis._currentMarker.dispose();\n\t\t\tthis._isDisposable = false;\n\t\t} else {\n\t\t\tif (skipEmptyCommands && this._isEmptyCommand(this._currentMarker)) {\n\t\t\t\tmarkerIndex = this._findPreviousMarker(true);\n\t\t\t} else {\n\t\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).indexOf(this._currentMarker) - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (markerIndex < 0) {\n\t\t\tthis._currentMarker = Boundary.Top;\n\t\t\tthis._terminal.scrollToTop();\n\t\t\tthis._resetNavigationDecorations();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentMarker = this._getMarkers(skipEmptyCommands)[markerIndex];\n\t\tthis._scrollToCommand(this._currentMarker, scrollPosition);\n\t}\n\n\tscrollToNextMark(scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false, skipEmptyCommands: boolean = true): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tlet markerIndex;\n\t\tconst currentLineY = typeof this._currentMarker === 'object'\n\t\t\t? this.getTargetScrollLine(this._currentMarker.line, scrollPosition)\n\t\t\t: Math.min(getLine(this._terminal, this._currentMarker), this._terminal.buffer.active.baseY);\n\t\tconst viewportY = this._terminal.buffer.active.viewportY;\n\t\tif (typeof this._currentMarker === 'object' ? !this._isMarkerInViewport(this._terminal, this._currentMarker) : currentLineY !== viewportY) {\n\t\t\t// The user has scrolled, find the line based on the current scroll position. This only\n\t\t\t// works when not retaining selection\n\t\t\tconst markersAboveViewport = this._getMarkers(skipEmptyCommands).filter(e => e.line <= viewportY).length;\n\t\t\t// markers.length will scroll to the bottom\n\t\t\tmarkerIndex = markersAboveViewport;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).length;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\tmarkerIndex = 0;\n\t\t} else if (this._isDisposable) {\n\t\t\tmarkerIndex = this._findNextMarker(skipEmptyCommands);\n\t\t\tthis._currentMarker.dispose();\n\t\t\tthis._isDisposable = false;\n\t\t} else {\n\t\t\tif (skipEmptyCommands && this._isEmptyCommand(this._currentMarker)) {\n\t\t\t\tmarkerIndex = this._findNextMarker(true);\n\t\t\t} else {\n\t\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).indexOf(this._currentMarker) + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (markerIndex >= this._getMarkers(skipEmptyCommands).length) {\n\t\t\tthis._currentMarker = Boundary.Bottom;\n\t\t\tthis._terminal.scrollToBottom();\n\t\t\tthis._resetNavigationDecorations();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentMarker = this._getMarkers(skipEmptyCommands)[markerIndex];\n\t\tthis._scrollToCommand(this._currentMarker, scrollPosition);\n\t}\n\n\tprivate _scrollToCommand(marker: IMarker, position: ScrollPosition): void {\n\t\tconst command = this._findCommand(marker);\n\t\tif (command) {\n\t\t\tthis.revealCommand(command, position);\n\t\t} else {\n\t\t\tthis._scrollToMarker(marker, position);\n\t\t}\n\t}\n\n\tprivate _scrollToMarker(start: IMarker | number, position: ScrollPosition, end?: IMarker | number, options?: IScrollToMarkerOptions): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._isMarkerInViewport(this._terminal, start) || options?.forceScroll) {\n\t\t\tconst line = this.getTargetScrollLine(toLineIndex(start), position);\n\t\t\tthis._terminal.scrollToLine(line);\n\t\t}\n\t\tif (!options?.hideDecoration) {\n\t\t\tif (options?.bufferRange) {\n\t\t\t\tthis._highlightBufferRange(options.bufferRange);\n\t\t\t} else {\n\t\t\t\tthis.registerTemporaryDecoration(start, end, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _createMarkerForOffset(marker: IMarker | number, offset: number): IMarker {\n\t\tif (offset === 0 && isMarker(marker)) {\n\t\t\treturn marker;\n\t\t} else {\n\t\t\tconst offsetMarker = this._terminal?.registerMarker(-this._terminal.buffer.active.cursorY + toLineIndex(marker) - this._terminal.buffer.active.baseY + offset);\n\t\t\tif (offsetMarker) {\n\t\t\t\treturn offsetMarker;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not register marker with offset ${toLineIndex(marker)}, ${offset}`);\n\t\t\t}\n\t\t}\n\t}\n\n\trevealCommand(command: ITerminalCommand | ICurrentPartialCommand, position: ScrollPosition = ScrollPosition.Middle): void {\n\t\tconst marker = isFullTerminalCommand(command) ? command.marker : command.commandStartMarker;\n\t\tif (!this._terminal || !marker) {\n\t\t\treturn;\n\t\t}\n\t\tconst line = toLineIndex(marker);\n\t\tconst promptRowCount = command.getPromptRowCount();\n\t\tconst commandRowCount = command.getCommandRowCount();\n\t\tthis._scrollToMarker(\n\t\t\tline - (promptRowCount - 1),\n\t\t\tposition,\n\t\t\tline + (commandRowCount - 1)\n\t\t);\n\t}\n\n\trevealRange(range: IBufferRange): void {\n\t\tthis._scrollToMarker(\n\t\t\trange.start.y - 1,\n\t\t\tScrollPosition.Middle,\n\t\t\trange.end.y - 1,\n\t\t\t{\n\t\t\t\tbufferRange: range,\n\t\t\t\t// Ensure scroll shows the line when sticky scroll is enabled\n\t\t\t\tforceScroll: !!this._configurationService.getValue(TerminalContribSettingId.StickyScrollEnabled)\n\t\t\t}\n\t\t);\n\t}\n\n\tshowCommandGuide(command: ITerminalCommand | undefined): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!command) {\n\t\t\tthis._commandGuideDecorations.clear();\n\t\t\tthis._activeCommandGuide = undefined;\n\t\t\treturn;\n\t\t}\n\t\tif (this._activeCommandGuide === command) {\n\t\t\treturn;\n\t\t}\n\t\tif (command.marker) {\n\t\t\tthis._activeCommandGuide = command;\n\n\t\t\t// Highlight output\n\t\t\tconst store = this._commandGuideDecorations.value = new DisposableStore();\n\t\t\tif (!command.executedMarker || !command.endMarker) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst startLine = command.marker.line - (command.getPromptRowCount() - 1);\n\t\t\tconst decorationCount = toLineIndex(command.endMarker) - startLine;\n\t\t\t// Abort if the command is excessively long to avoid performance on hover/leave\n\t\t\tif (decorationCount > 200) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\t\tmarker: this._createMarkerForOffset(startLine, i)\n\t\t\t\t});\n\t\t\t\tif (decoration) {\n\t\t\t\t\tstore.add(decoration);\n\t\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\t\t\t\t\tstore.add(decoration.onRender(element => {\n\t\t\t\t\t\tif (!renderedElement) {\n\t\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\t\telement.classList.add('terminal-command-guide');\n\t\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\t\telement.classList.add('top');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i === decorationCount - 1) {\n\t\t\t\t\t\t\t\telement.classList.add('bottom');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this._terminal?.element) {\n\t\t\t\t\t\t\telement.style.marginLeft = `-${getWindow(this._terminal.element).getComputedStyle(this._terminal.element).paddingLeft}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate _scrollState: { viewportY: number } | undefined;\n\n\tsaveScrollState(): void {\n\t\tthis._scrollState = { viewportY: this._terminal?.buffer.active.viewportY ?? 0 };\n\t}\n\n\trestoreScrollState(): void {\n\t\tif (this._scrollState && this._terminal) {\n\t\t\tthis._terminal.scrollToLine(this._scrollState.viewportY);\n\t\t\tthis._scrollState = undefined;\n\t\t}\n\t}\n\n\tprivate _highlightBufferRange(range: IBufferRange): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._resetNavigationDecorations();\n\t\tconst startLine = range.start.y;\n\t\tconst decorationCount = range.end.y - range.start.y + 1;\n\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\tmarker: this._createMarkerForOffset(startLine - 1, i),\n\t\t\t\tx: range.start.x - 1,\n\t\t\t\twidth: (range.end.x - 1) - (range.start.x - 1) + 1,\n\t\t\t\toverviewRulerOptions: undefined\n\t\t\t});\n\t\t\tif (decoration) {\n\t\t\t\tthis._navigationDecorations?.push(decoration);\n\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\n\t\t\t\tdecoration.onRender(element => {\n\t\t\t\t\tif (!renderedElement) {\n\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\telement.classList.add('terminal-range-highlight');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tdecoration.onDispose(() => { this._navigationDecorations = this._navigationDecorations?.filter(d => d !== decoration); });\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterTemporaryDecoration(marker: IMarker | number, endMarker: IMarker | number | undefined, showOutline: boolean): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tthis._resetNavigationDecorations();\n\t\tconst color = this._themeService.getColorTheme().getColor(TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR);\n\t\tconst startLine = toLineIndex(marker);\n\t\tconst decorationCount = endMarker ? toLineIndex(endMarker) - startLine + 1 : 1;\n\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\tmarker: this._createMarkerForOffset(marker, i),\n\t\t\t\twidth: this._terminal.cols,\n\t\t\t\toverviewRulerOptions: i === 0 ? {\n\t\t\t\t\tcolor: color?.toString() || '#a0a0a0cc'\n\t\t\t\t} : undefined\n\t\t\t});\n\t\t\tif (decoration) {\n\t\t\t\tthis._navigationDecorations?.push(decoration);\n\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\n\t\t\t\tdecoration.onRender(element => {\n\t\t\t\t\tif (!renderedElement) {\n\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\telement.classList.add('terminal-scroll-highlight');\n\t\t\t\t\t\tif (showOutline) {\n\t\t\t\t\t\t\telement.classList.add('terminal-scroll-highlight-outline');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\telement.classList.add('top');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === decorationCount - 1) {\n\t\t\t\t\t\t\telement.classList.add('bottom');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.classList.add('terminal-scroll-highlight');\n\t\t\t\t\t}\n\t\t\t\t\tif (this._terminal?.element) {\n\t\t\t\t\t\telement.style.marginLeft = `-${getWindow(this._terminal.element).getComputedStyle(this._terminal.element).paddingLeft}`;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// TODO: This is not efficient for a large decorationCount\n\t\t\t\tdecoration.onDispose(() => { this._navigationDecorations = this._navigationDecorations?.filter(d => d !== decoration); });\n\t\t\t\t// Number picked to align with symbol highlight in the editor\n\t\t\t\tif (showOutline) {\n\t\t\t\t\ttimeout(350).then(() => {\n\t\t\t\t\t\tif (renderedElement) {\n\t\t\t\t\t\t\trenderedElement.classList.remove('terminal-scroll-highlight-outline');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tscrollToLine(line: number, position: ScrollPosition): void {\n\t\tthis._terminal?.scrollToLine(this.getTargetScrollLine(line, position));\n\t}\n\n\tgetTargetScrollLine(line: number, position: ScrollPosition): number {\n\t\t// Middle is treated as 1/4 of the viewport's size because context below is almost always\n\t\t// more important than context above in the terminal.\n\t\tif (this._terminal && position === ScrollPosition.Middle) {\n\t\t\treturn Math.max(line - Math.floor(this._terminal.rows / 4), 0);\n\t\t}\n\t\treturn line;\n\t}\n\n\tprivate _isMarkerInViewport(terminal: Terminal, marker: IMarker | number) {\n\t\tconst viewportY = terminal.buffer.active.viewportY;\n\t\tconst line = toLineIndex(marker);\n\t\treturn line >= viewportY && line < viewportY + terminal.rows;\n\t}\n\n\tscrollToClosestMarker(startMarkerId: string, endMarkerId?: string, highlight?: boolean | undefined): void {\n\t\tconst detectionCapability = this._capabilities.get(TerminalCapability.BufferMarkDetection);\n\t\tif (!detectionCapability) {\n\t\t\treturn;\n\t\t}\n\t\tconst startMarker = detectionCapability.getMark(startMarkerId);\n\t\tif (!startMarker) {\n\t\t\treturn;\n\t\t}\n\t\tconst endMarker = endMarkerId ? detectionCapability.getMark(endMarkerId) : startMarker;\n\t\tthis._scrollToMarker(startMarker, ScrollPosition.Top, endMarker, { hideDecoration: !highlight });\n\t}\n\n\tselectToPreviousMark(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\tthis.scrollToPreviousMark(ScrollPosition.Middle, true, true);\n\t\t} else {\n\t\t\tthis.scrollToPreviousMark(ScrollPosition.Middle, true, false);\n\t\t}\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToNextMark(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\tthis.scrollToNextMark(ScrollPosition.Middle, true, true);\n\t\t} else {\n\t\t\tthis.scrollToNextMark(ScrollPosition.Middle, true, false);\n\t\t}\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToPreviousLine(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tthis.scrollToPreviousLine(this._terminal, ScrollPosition.Middle, true);\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToNextLine(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tthis.scrollToNextLine(this._terminal, ScrollPosition.Middle, true);\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tscrollToPreviousLine(xterm: Terminal, scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\txterm.scrollToTop();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, this._getOffset(xterm) - 1);\n\t\t} else {\n\t\t\tconst offset = this._getOffset(xterm);\n\t\t\tif (this._isDisposable) {\n\t\t\t\tthis._currentMarker.dispose();\n\t\t\t}\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, offset - 1);\n\t\t}\n\t\tthis._isDisposable = true;\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tscrollToNextLine(xterm: Terminal, scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\txterm.scrollToBottom();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, this._getOffset(xterm) + 1);\n\t\t} else {\n\t\t\tconst offset = this._getOffset(xterm);\n\t\t\tif (this._isDisposable) {\n\t\t\t\tthis._currentMarker.dispose();\n\t\t\t}\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, offset + 1);\n\t\t}\n\t\tthis._isDisposable = true;\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tprivate _registerMarkerOrThrow(xterm: Terminal, cursorYOffset: number): IMarker {\n\t\tconst marker = xterm.registerMarker(cursorYOffset);\n\t\tif (!marker) {\n\t\t\tthrow new Error(`Could not create marker for ${cursorYOffset}`);\n\t\t}\n\t\treturn marker;\n\t}\n\n\tprivate _getOffset(xterm: Terminal): number {\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0 - (xterm.buffer.active.baseY + xterm.buffer.active.cursorY);\n\t\t} else {\n\t\t\tlet offset = getLine(xterm, this._currentMarker);\n\t\t\toffset -= xterm.buffer.active.baseY + xterm.buffer.active.cursorY;\n\t\t\treturn offset;\n\t\t}\n\t}\n\n\tprivate _findPreviousMarker(skipEmptyCommands: boolean = false): number {\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn this._getMarkers(skipEmptyCommands).length - 1;\n\t\t}\n\n\t\tlet i;\n\t\tfor (i = this._getMarkers(skipEmptyCommands).length - 1; i >= 0; i--) {\n\t\t\tif (this._getMarkers(skipEmptyCommands)[i].line < this._currentMarker.line) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate _findNextMarker(skipEmptyCommands: boolean = false): number {\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn this._getMarkers(skipEmptyCommands).length - 1;\n\t\t}\n\n\t\tlet i;\n\t\tfor (i = 0; i < this._getMarkers(skipEmptyCommands).length; i++) {\n\t\t\tif (this._getMarkers(skipEmptyCommands)[i].line > this._currentMarker.line) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn this._getMarkers(skipEmptyCommands).length;\n\t}\n}\n\nexport function getLine(xterm: Terminal, marker: IMarker | Boundary): number {\n\t// Use the _second last_ row as the last row is likely the prompt\n\tif (marker === Boundary.Bottom) {\n\t\treturn xterm.buffer.active.baseY + xterm.rows - 1;\n\t}\n\n\tif (marker === Boundary.Top) {\n\t\treturn 0;\n\t}\n\n\treturn marker.line;\n}\n\nexport function selectLines(xterm: Terminal, start: IMarker | Boundary, end: IMarker | Boundary | null): void {\n\tif (end === null) {\n\t\tend = Boundary.Bottom;\n\t}\n\n\tlet startLine = getLine(xterm, start);\n\tlet endLine = getLine(xterm, end);\n\n\tif (startLine > endLine) {\n\t\tconst temp = startLine;\n\t\tstartLine = endLine;\n\t\tendLine = temp;\n\t}\n\n\t// Subtract a line as the marker is on the line the command run, we do not want the next\n\t// command in the selection for the current command\n\tendLine -= 1;\n\n\txterm.selectLines(startLine, endLine);\n}\n\nfunction isMarker(value: IMarker | number): value is IMarker {\n\treturn typeof value !== 'number';\n}\n\nfunction toLineIndex(line: IMarker | number): number {\n\treturn isMarker(line) ? line.line : line;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from '../../../../../base/common/arrays.js';\nimport { Disposable, DisposableStore, MutableDisposable, dispose } from '../../../../../base/common/lifecycle.js';\nimport { IMarkTracker } from '../terminal.js';\nimport { ITerminalCapabilityStore, ITerminalCommand, TerminalCapability } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport type { Terminal, IMarker, ITerminalAddon, IDecoration, IBufferRange } from '@xterm/xterm';\nimport { timeout } from '../../../../../base/common/async.js';\nimport { IThemeService } from '../../../../../platform/theme/common/themeService.js';\nimport { TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR } from '../../common/terminalColorRegistry.js';\nimport { getWindow } from '../../../../../base/browser/dom.js';\nimport { ICurrentPartialCommand, isFullTerminalCommand } from '../../../../../platform/terminal/common/capabilities/commandDetection/terminalCommand.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { TerminalContribSettingId } from '../../terminalContribExports.js';\n\nenum Boundary {\n\tTop,\n\tBottom\n}\n\nexport const enum ScrollPosition {\n\tTop,\n\tMiddle\n}\n\ninterface IScrollToMarkerOptions {\n\thideDecoration?: boolean;\n\t/** Scroll even if the line is within the viewport */\n\tforceScroll?: boolean;\n\tbufferRange?: IBufferRange;\n}\n\nexport class MarkNavigationAddon extends Disposable implements IMarkTracker, ITerminalAddon {\n\tprivate _currentMarker: IMarker | Boundary = Boundary.Bottom;\n\tprivate _selectionStart: IMarker | Boundary | null = null;\n\tprivate _isDisposable: boolean = false;\n\tprotected _terminal: Terminal | undefined;\n\tprivate _navigationDecorations: IDecoration[] | undefined;\n\n\tprivate _activeCommandGuide?: ITerminalCommand;\n\tprivate readonly _commandGuideDecorations = this._register(new MutableDisposable<DisposableStore>());\n\n\tactivate(terminal: Terminal): void {\n\t\tthis._terminal = terminal;\n\t\tthis._register(this._terminal.onData(() => {\n\t\t\tthis._currentMarker = Boundary.Bottom;\n\t\t}));\n\t}\n\n\tconstructor(\n\t\tprivate readonly _capabilities: ITerminalCapabilityStore,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IThemeService private readonly _themeService: IThemeService\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate _getMarkers(skipEmptyCommands?: boolean): readonly IMarker[] {\n\t\tconst commandCapability = this._capabilities.get(TerminalCapability.CommandDetection);\n\t\tconst partialCommandCapability = this._capabilities.get(TerminalCapability.PartialCommandDetection);\n\t\tconst markCapability = this._capabilities.get(TerminalCapability.BufferMarkDetection);\n\t\tlet markers: IMarker[] = [];\n\t\tif (commandCapability) {\n\t\t\tmarkers = coalesce(commandCapability.commands.filter(e => skipEmptyCommands ? e.exitCode !== undefined : true).map(e => e.promptStartMarker ?? e.marker));\n\t\t\t// Allow navigating to the current command iff it has been executed, this ignores the\n\t\t\t// skipEmptyCommands flag intenionally as chances are it's not going to be empty if an\n\t\t\t// executed marker exists when this is requested.\n\t\t\tif (commandCapability.currentCommand?.promptStartMarker && commandCapability.currentCommand.commandExecutedMarker) {\n\t\t\t\tmarkers.push(commandCapability.currentCommand?.promptStartMarker);\n\t\t\t}\n\t\t} else if (partialCommandCapability) {\n\t\t\tmarkers.push(...partialCommandCapability.commands);\n\t\t}\n\n\t\tif (markCapability && !skipEmptyCommands) {\n\t\t\tlet next = markCapability.markers().next()?.value;\n\t\t\tconst arr: IMarker[] = [];\n\t\t\twhile (next) {\n\t\t\t\tarr.push(next);\n\t\t\t\tnext = markCapability.markers().next()?.value;\n\t\t\t}\n\t\t\tmarkers = arr;\n\t\t}\n\t\treturn markers;\n\t}\n\n\tprivate _findCommand(marker: IMarker): ITerminalCommand | ICurrentPartialCommand | undefined {\n\t\tconst commandCapability = this._capabilities.get(TerminalCapability.CommandDetection);\n\t\tif (commandCapability) {\n\t\t\tconst command = commandCapability.commands.find(e => e.marker?.line === marker.line || e.promptStartMarker?.line === marker.line);\n\t\t\tif (command) {\n\t\t\t\treturn command;\n\t\t\t}\n\t\t\tif (commandCapability.currentCommand) {\n\t\t\t\treturn commandCapability.currentCommand;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tclear(): void {\n\t\t// Clear the current marker so successive focus/selection actions are performed from the\n\t\t// bottom of the buffer\n\t\tthis._currentMarker = Boundary.Bottom;\n\t\tthis._resetNavigationDecorations();\n\t\tthis._selectionStart = null;\n\t}\n\n\tprivate _resetNavigationDecorations() {\n\t\tif (this._navigationDecorations) {\n\t\t\tdispose(this._navigationDecorations);\n\t\t}\n\t\tthis._navigationDecorations = [];\n\t}\n\n\tprivate _isEmptyCommand(marker: IMarker | Boundary) {\n\t\tif (marker === Boundary.Bottom) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (marker === Boundary.Top) {\n\t\t\treturn !this._getMarkers(true).map(e => e.line).includes(0);\n\t\t}\n\n\t\treturn !this._getMarkers(true).includes(marker);\n\t}\n\n\tscrollToPreviousMark(scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false, skipEmptyCommands: boolean = true): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tlet markerIndex;\n\t\tconst currentLineY = typeof this._currentMarker === 'object'\n\t\t\t? this.getTargetScrollLine(this._currentMarker.line, scrollPosition)\n\t\t\t: Math.min(getLine(this._terminal, this._currentMarker), this._terminal.buffer.active.baseY);\n\t\tconst viewportY = this._terminal.buffer.active.viewportY;\n\t\tif (typeof this._currentMarker === 'object' ? !this._isMarkerInViewport(this._terminal, this._currentMarker) : currentLineY !== viewportY) {\n\t\t\t// The user has scrolled, find the line based on the current scroll position. This only\n\t\t\t// works when not retaining selection\n\t\t\tconst markersBelowViewport = this._getMarkers(skipEmptyCommands).filter(e => e.line >= viewportY).length;\n\t\t\t// -1 will scroll to the top\n\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).length - markersBelowViewport - 1;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).length - 1;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\tmarkerIndex = -1;\n\t\t} else if (this._isDisposable) {\n\t\t\tmarkerIndex = this._findPreviousMarker(skipEmptyCommands);\n\t\t\tthis._currentMarker.dispose();\n\t\t\tthis._isDisposable = false;\n\t\t} else {\n\t\t\tif (skipEmptyCommands && this._isEmptyCommand(this._currentMarker)) {\n\t\t\t\tmarkerIndex = this._findPreviousMarker(true);\n\t\t\t} else {\n\t\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).indexOf(this._currentMarker) - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (markerIndex < 0) {\n\t\t\tthis._currentMarker = Boundary.Top;\n\t\t\tthis._terminal.scrollToTop();\n\t\t\tthis._resetNavigationDecorations();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentMarker = this._getMarkers(skipEmptyCommands)[markerIndex];\n\t\tthis._scrollToCommand(this._currentMarker, scrollPosition);\n\t}\n\n\tscrollToNextMark(scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false, skipEmptyCommands: boolean = true): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tlet markerIndex;\n\t\tconst currentLineY = typeof this._currentMarker === 'object'\n\t\t\t? this.getTargetScrollLine(this._currentMarker.line, scrollPosition)\n\t\t\t: Math.min(getLine(this._terminal, this._currentMarker), this._terminal.buffer.active.baseY);\n\t\tconst viewportY = this._terminal.buffer.active.viewportY;\n\t\tif (typeof this._currentMarker === 'object' ? !this._isMarkerInViewport(this._terminal, this._currentMarker) : currentLineY !== viewportY) {\n\t\t\t// The user has scrolled, find the line based on the current scroll position. This only\n\t\t\t// works when not retaining selection\n\t\t\tconst markersAboveViewport = this._getMarkers(skipEmptyCommands).filter(e => e.line <= viewportY).length;\n\t\t\t// markers.length will scroll to the bottom\n\t\t\tmarkerIndex = markersAboveViewport;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).length;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\tmarkerIndex = 0;\n\t\t} else if (this._isDisposable) {\n\t\t\tmarkerIndex = this._findNextMarker(skipEmptyCommands);\n\t\t\tthis._currentMarker.dispose();\n\t\t\tthis._isDisposable = false;\n\t\t} else {\n\t\t\tif (skipEmptyCommands && this._isEmptyCommand(this._currentMarker)) {\n\t\t\t\tmarkerIndex = this._findNextMarker(true);\n\t\t\t} else {\n\t\t\t\tmarkerIndex = this._getMarkers(skipEmptyCommands).indexOf(this._currentMarker) + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (markerIndex >= this._getMarkers(skipEmptyCommands).length) {\n\t\t\tthis._currentMarker = Boundary.Bottom;\n\t\t\tthis._terminal.scrollToBottom();\n\t\t\tthis._resetNavigationDecorations();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentMarker = this._getMarkers(skipEmptyCommands)[markerIndex];\n\t\tthis._scrollToCommand(this._currentMarker, scrollPosition);\n\t}\n\n\tprivate _scrollToCommand(marker: IMarker, position: ScrollPosition): void {\n\t\tconst command = this._findCommand(marker);\n\t\tif (command) {\n\t\t\tthis.revealCommand(command, position);\n\t\t} else {\n\t\t\tthis._scrollToMarker(marker, position);\n\t\t}\n\t}\n\n\tprivate _scrollToMarker(start: IMarker | number, position: ScrollPosition, end?: IMarker | number, options?: IScrollToMarkerOptions): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._isMarkerInViewport(this._terminal, start) || options?.forceScroll) {\n\t\t\tconst line = this.getTargetScrollLine(toLineIndex(start), position);\n\t\t\tthis._terminal.scrollToLine(line);\n\t\t}\n\t\tif (!options?.hideDecoration) {\n\t\t\tif (options?.bufferRange) {\n\t\t\t\tthis._highlightBufferRange(options.bufferRange);\n\t\t\t} else {\n\t\t\t\tthis.registerTemporaryDecoration(start, end, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _createMarkerForOffset(marker: IMarker | number, offset: number): IMarker {\n\t\tif (offset === 0 && isMarker(marker)) {\n\t\t\treturn marker;\n\t\t} else {\n\t\t\tconst offsetMarker = this._terminal?.registerMarker(-this._terminal.buffer.active.cursorY + toLineIndex(marker) - this._terminal.buffer.active.baseY + offset);\n\t\t\tif (offsetMarker) {\n\t\t\t\treturn offsetMarker;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not register marker with offset ${toLineIndex(marker)}, ${offset}`);\n\t\t\t}\n\t\t}\n\t}\n\n\trevealCommand(command: ITerminalCommand | ICurrentPartialCommand, position: ScrollPosition = ScrollPosition.Middle): void {\n\t\tconst marker = isFullTerminalCommand(command) ? command.marker : command.commandStartMarker;\n\t\tif (!this._terminal || !marker) {\n\t\t\treturn;\n\t\t}\n\t\tconst line = toLineIndex(marker);\n\t\tconst promptRowCount = command.getPromptRowCount();\n\t\tconst commandRowCount = command.getCommandRowCount();\n\t\tthis._scrollToMarker(\n\t\t\tline - (promptRowCount - 1),\n\t\t\tposition,\n\t\t\tline + (commandRowCount - 1)\n\t\t);\n\t}\n\n\trevealRange(range: IBufferRange): void {\n\t\tthis._scrollToMarker(\n\t\t\trange.start.y - 1,\n\t\t\tScrollPosition.Middle,\n\t\t\trange.end.y - 1,\n\t\t\t{\n\t\t\t\tbufferRange: range,\n\t\t\t\t// Ensure scroll shows the line when sticky scroll is enabled\n\t\t\t\tforceScroll: !!this._configurationService.getValue(TerminalContribSettingId.StickyScrollEnabled)\n\t\t\t}\n\t\t);\n\t}\n\n\tshowCommandGuide(command: ITerminalCommand | undefined): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (!command) {\n\t\t\tthis._commandGuideDecorations.clear();\n\t\t\tthis._activeCommandGuide = undefined;\n\t\t\treturn;\n\t\t}\n\t\tif (this._activeCommandGuide === command) {\n\t\t\treturn;\n\t\t}\n\t\tif (command.marker) {\n\t\t\tthis._activeCommandGuide = command;\n\n\t\t\t// Highlight output\n\t\t\tconst store = this._commandGuideDecorations.value = new DisposableStore();\n\t\t\tif (!command.executedMarker || !command.endMarker) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst startLine = command.marker.line - (command.getPromptRowCount() - 1);\n\t\t\tconst decorationCount = toLineIndex(command.endMarker) - startLine;\n\t\t\t// Abort if the command is excessively long to avoid performance on hover/leave\n\t\t\tif (decorationCount > 200) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\t\tmarker: this._createMarkerForOffset(startLine, i)\n\t\t\t\t});\n\t\t\t\tif (decoration) {\n\t\t\t\t\tstore.add(decoration);\n\t\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\t\t\t\t\tstore.add(decoration.onRender(element => {\n\t\t\t\t\t\tif (!renderedElement) {\n\t\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\t\telement.classList.add('terminal-command-guide');\n\t\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\t\telement.classList.add('top');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i === decorationCount - 1) {\n\t\t\t\t\t\t\t\telement.classList.add('bottom');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this._terminal?.element) {\n\t\t\t\t\t\t\telement.style.marginLeft = `-${getWindow(this._terminal.element).getComputedStyle(this._terminal.element).paddingLeft}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate _scrollState: { viewportY: number } | undefined;\n\n\tsaveScrollState(): void {\n\t\tthis._scrollState = { viewportY: this._terminal?.buffer.active.viewportY ?? 0 };\n\t}\n\n\trestoreScrollState(): void {\n\t\tif (this._scrollState && this._terminal) {\n\t\t\tthis._terminal.scrollToLine(this._scrollState.viewportY);\n\t\t\tthis._scrollState = undefined;\n\t\t}\n\t}\n\n\tprivate _highlightBufferRange(range: IBufferRange): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._resetNavigationDecorations();\n\t\tconst startLine = range.start.y;\n\t\tconst decorationCount = range.end.y - range.start.y + 1;\n\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\tmarker: this._createMarkerForOffset(startLine - 1, i),\n\t\t\t\tx: range.start.x - 1,\n\t\t\t\twidth: (range.end.x - 1) - (range.start.x - 1) + 1,\n\t\t\t\toverviewRulerOptions: undefined\n\t\t\t});\n\t\t\tif (decoration) {\n\t\t\t\tthis._navigationDecorations?.push(decoration);\n\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\n\t\t\t\tdecoration.onRender(element => {\n\t\t\t\t\tif (!renderedElement) {\n\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\telement.classList.add('terminal-range-highlight');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tdecoration.onDispose(() => { this._navigationDecorations = this._navigationDecorations?.filter(d => d !== decoration); });\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterTemporaryDecoration(marker: IMarker | number, endMarker: IMarker | number | undefined, showOutline: boolean): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tthis._resetNavigationDecorations();\n\t\tconst color = this._themeService.getColorTheme().getColor(TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR);\n\t\tconst startLine = toLineIndex(marker);\n\t\tconst decorationCount = endMarker ? toLineIndex(endMarker) - startLine + 1 : 1;\n\t\tfor (let i = 0; i < decorationCount; i++) {\n\t\t\tconst decoration = this._terminal.registerDecoration({\n\t\t\t\tmarker: this._createMarkerForOffset(marker, i),\n\t\t\t\twidth: this._terminal.cols,\n\t\t\t\toverviewRulerOptions: i === 0 ? {\n\t\t\t\t\tcolor: color?.toString() || '#a0a0a0cc'\n\t\t\t\t} : undefined\n\t\t\t});\n\t\t\tif (decoration) {\n\t\t\t\tthis._navigationDecorations?.push(decoration);\n\t\t\t\tlet renderedElement: HTMLElement | undefined;\n\n\t\t\t\tdecoration.onRender(element => {\n\t\t\t\t\tif (!renderedElement) {\n\t\t\t\t\t\trenderedElement = element;\n\t\t\t\t\t\telement.classList.add('terminal-scroll-highlight');\n\t\t\t\t\t\tif (showOutline) {\n\t\t\t\t\t\t\telement.classList.add('terminal-scroll-highlight-outline');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\telement.classList.add('top');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === decorationCount - 1) {\n\t\t\t\t\t\t\telement.classList.add('bottom');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.classList.add('terminal-scroll-highlight');\n\t\t\t\t\t}\n\t\t\t\t\tif (this._terminal?.element) {\n\t\t\t\t\t\telement.style.marginLeft = `-${getWindow(this._terminal.element).getComputedStyle(this._terminal.element).paddingLeft}`;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// TODO: This is not efficient for a large decorationCount\n\t\t\t\tdecoration.onDispose(() => { this._navigationDecorations = this._navigationDecorations?.filter(d => d !== decoration); });\n\t\t\t\t// Number picked to align with symbol highlight in the editor\n\t\t\t\tif (showOutline) {\n\t\t\t\t\ttimeout(350).then(() => {\n\t\t\t\t\t\tif (renderedElement) {\n\t\t\t\t\t\t\trenderedElement.classList.remove('terminal-scroll-highlight-outline');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tscrollToLine(line: number, position: ScrollPosition): void {\n\t\tthis._terminal?.scrollToLine(this.getTargetScrollLine(line, position));\n\t}\n\n\tgetTargetScrollLine(line: number, position: ScrollPosition): number {\n\t\t// Middle is treated as 1/4 of the viewport's size because context below is almost always\n\t\t// more important than context above in the terminal.\n\t\tif (this._terminal && position === ScrollPosition.Middle) {\n\t\t\treturn Math.max(line - Math.floor(this._terminal.rows / 4), 0);\n\t\t}\n\t\treturn line;\n\t}\n\n\tprivate _isMarkerInViewport(terminal: Terminal, marker: IMarker | number) {\n\t\tconst viewportY = terminal.buffer.active.viewportY;\n\t\tconst line = toLineIndex(marker);\n\t\treturn line >= viewportY && line < viewportY + terminal.rows;\n\t}\n\n\tscrollToClosestMarker(startMarkerId: string, endMarkerId?: string, highlight?: boolean | undefined): void {\n\t\tconst detectionCapability = this._capabilities.get(TerminalCapability.BufferMarkDetection);\n\t\tif (!detectionCapability) {\n\t\t\treturn;\n\t\t}\n\t\tconst startMarker = detectionCapability.getMark(startMarkerId);\n\t\tif (!startMarker) {\n\t\t\treturn;\n\t\t}\n\t\tconst endMarker = endMarkerId ? detectionCapability.getMark(endMarkerId) : startMarker;\n\t\tthis._scrollToMarker(startMarker, ScrollPosition.Top, endMarker, { hideDecoration: !highlight });\n\t}\n\n\tselectToPreviousMark(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\tthis.scrollToPreviousMark(ScrollPosition.Middle, true, true);\n\t\t} else {\n\t\t\tthis.scrollToPreviousMark(ScrollPosition.Middle, true, false);\n\t\t}\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToNextMark(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\tthis.scrollToNextMark(ScrollPosition.Middle, true, true);\n\t\t} else {\n\t\t\tthis.scrollToNextMark(ScrollPosition.Middle, true, false);\n\t\t}\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToPreviousLine(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tthis.scrollToPreviousLine(this._terminal, ScrollPosition.Middle, true);\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tselectToNextLine(): void {\n\t\tif (!this._terminal) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tthis.scrollToNextLine(this._terminal, ScrollPosition.Middle, true);\n\t\tselectLines(this._terminal, this._currentMarker, this._selectionStart);\n\t}\n\n\tscrollToPreviousLine(xterm: Terminal, scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\txterm.scrollToTop();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, this._getOffset(xterm) - 1);\n\t\t} else {\n\t\t\tconst offset = this._getOffset(xterm);\n\t\t\tif (this._isDisposable) {\n\t\t\t\tthis._currentMarker.dispose();\n\t\t\t}\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, offset - 1);\n\t\t}\n\t\tthis._isDisposable = true;\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tscrollToNextLine(xterm: Terminal, scrollPosition: ScrollPosition = ScrollPosition.Middle, retainSelection: boolean = false): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\txterm.scrollToBottom();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, this._getOffset(xterm) + 1);\n\t\t} else {\n\t\t\tconst offset = this._getOffset(xterm);\n\t\t\tif (this._isDisposable) {\n\t\t\t\tthis._currentMarker.dispose();\n\t\t\t}\n\t\t\tthis._currentMarker = this._registerMarkerOrThrow(xterm, offset + 1);\n\t\t}\n\t\tthis._isDisposable = true;\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tprivate _registerMarkerOrThrow(xterm: Terminal, cursorYOffset: number): IMarker {\n\t\tconst marker = xterm.registerMarker(cursorYOffset);\n\t\tif (!marker) {\n\t\t\tthrow new Error(`Could not create marker for ${cursorYOffset}`);\n\t\t}\n\t\treturn marker;\n\t}\n\n\tprivate _getOffset(xterm: Terminal): number {\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0 - (xterm.buffer.active.baseY + xterm.buffer.active.cursorY);\n\t\t} else {\n\t\t\tlet offset = getLine(xterm, this._currentMarker);\n\t\t\toffset -= xterm.buffer.active.baseY + xterm.buffer.active.cursorY;\n\t\t\treturn offset;\n\t\t}\n\t}\n\n\tprivate _findPreviousMarker(skipEmptyCommands: boolean = false): number {\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn this._getMarkers(skipEmptyCommands).length - 1;\n\t\t}\n\n\t\tlet i;\n\t\tfor (i = this._getMarkers(skipEmptyCommands).length - 1; i >= 0; i--) {\n\t\t\tif (this._getMarkers(skipEmptyCommands)[i].line < this._currentMarker.line) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate _findNextMarker(skipEmptyCommands: boolean = false): number {\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn this._getMarkers(skipEmptyCommands).length - 1;\n\t\t}\n\n\t\tlet i;\n\t\tfor (i = 0; i < this._getMarkers(skipEmptyCommands).length; i++) {\n\t\t\tif (this._getMarkers(skipEmptyCommands)[i].line > this._currentMarker.line) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn this._getMarkers(skipEmptyCommands).length;\n\t}\n}\n\nexport function getLine(xterm: Terminal, marker: IMarker | Boundary): number {\n\t// Use the _second last_ row as the last row is likely the prompt\n\tif (marker === Boundary.Bottom) {\n\t\treturn xterm.buffer.active.baseY + xterm.rows - 1;\n\t}\n\n\tif (marker === Boundary.Top) {\n\t\treturn 0;\n\t}\n\n\treturn marker.line;\n}\n\nexport function selectLines(xterm: Terminal, start: IMarker | Boundary, end: IMarker | Boundary | null): void {\n\tif (end === null) {\n\t\tend = Boundary.Bottom;\n\t}\n\n\tlet startLine = getLine(xterm, start);\n\tlet endLine = getLine(xterm, end);\n\n\tif (startLine > endLine) {\n\t\tconst temp = startLine;\n\t\tstartLine = endLine;\n\t\tendLine = temp;\n\t}\n\n\t// Subtract a line as the marker is on the line the command run, we do not want the next\n\t// command in the selection for the current command\n\tendLine -= 1;\n\n\txterm.selectLines(startLine, endLine);\n}\n\nfunction isMarker(value: IMarker | number): value is IMarker {\n\treturn typeof value !== 'number';\n}\n\nfunction toLineIndex(line: IMarker | number): number {\n\treturn isMarker(line) ? line.line : line;\n}\n"]}