{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminal/browser/terminalGroupService.ts","vs/workbench/contrib/terminal/browser/terminalGroupService.ts"],"names":[],"mappings":"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","file":"terminalGroupService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Orientation } from '../../../../base/browser/ui/sash/sash.js';\nimport { timeout } from '../../../../base/common/async.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IShellLaunchConfig } from '../../../../platform/terminal/common/terminal.js';\nimport { IViewDescriptorService } from '../../../common/views.js';\nimport { IViewsService } from '../../../services/views/common/viewsService.js';\nimport { ITerminalGroup, ITerminalGroupService, ITerminalInstance } from './terminal.js';\nimport { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';\nimport { TerminalGroup } from './terminalGroup.js';\nimport { getInstanceFromResource } from './terminalUri.js';\nimport { TerminalViewPane } from './terminalView.js';\nimport { TERMINAL_VIEW_ID } from '../common/terminal.js';\nimport { TerminalContextKeys } from '../common/terminalContextKey.js';\nimport { asArray } from '../../../../base/common/arrays.js';\nimport type { SingleOrMany } from '../../../../base/common/types.js';\n\nexport class TerminalGroupService extends Disposable implements ITerminalGroupService {\n\tdeclare _serviceBrand: undefined;\n\n\tgroups: ITerminalGroup[] = [];\n\tactiveGroupIndex: number = -1;\n\tget instances(): ITerminalInstance[] {\n\t\treturn this.groups.reduce((p, c) => p.concat(c.terminalInstances), [] as ITerminalInstance[]);\n\t}\n\n\tlastAccessedMenu: 'inline-tab' | 'tab-list' = 'inline-tab';\n\n\tprivate _container: HTMLElement | undefined;\n\n\tprivate _isQuickInputOpened: boolean = false;\n\n\tprivate readonly _onDidChangeActiveGroup = this._register(new Emitter<ITerminalGroup | undefined>());\n\treadonly onDidChangeActiveGroup = this._onDidChangeActiveGroup.event;\n\tprivate readonly _onDidDisposeGroup = this._register(new Emitter<ITerminalGroup>());\n\treadonly onDidDisposeGroup = this._onDidDisposeGroup.event;\n\tprivate readonly _onDidChangeGroups = this._register(new Emitter<void>());\n\treadonly onDidChangeGroups = this._onDidChangeGroups.event;\n\tprivate readonly _onDidShow = this._register(new Emitter<void>());\n\treadonly onDidShow = this._onDidShow.event;\n\n\tprivate readonly _onDidDisposeInstance = this._register(new Emitter<ITerminalInstance>());\n\treadonly onDidDisposeInstance = this._onDidDisposeInstance.event;\n\tprivate readonly _onDidFocusInstance = this._register(new Emitter<ITerminalInstance>());\n\treadonly onDidFocusInstance = this._onDidFocusInstance.event;\n\tprivate readonly _onDidChangeActiveInstance = this._register(new Emitter<ITerminalInstance | undefined>());\n\treadonly onDidChangeActiveInstance = this._onDidChangeActiveInstance.event;\n\tprivate readonly _onDidChangeInstances = this._register(new Emitter<void>());\n\treadonly onDidChangeInstances = this._onDidChangeInstances.event;\n\tprivate readonly _onDidChangeInstanceCapability = this._register(new Emitter<ITerminalInstance>());\n\treadonly onDidChangeInstanceCapability = this._onDidChangeInstanceCapability.event;\n\n\tprivate readonly _onDidChangePanelOrientation = this._register(new Emitter<Orientation>());\n\treadonly onDidChangePanelOrientation = this._onDidChangePanelOrientation.event;\n\n\tconstructor(\n\t\t@IContextKeyService private _contextKeyService: IContextKeyService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IViewsService private readonly _viewsService: IViewsService,\n\t\t@IViewDescriptorService private readonly _viewDescriptorService: IViewDescriptorService,\n\t\t@IQuickInputService private readonly _quickInputService: IQuickInputService\n\t) {\n\t\tsuper();\n\n\t\tconst terminalGroupCountContextKey = TerminalContextKeys.groupCount.bindTo(this._contextKeyService);\n\t\tthis._register(Event.runAndSubscribe(this.onDidChangeGroups, () => terminalGroupCountContextKey.set(this.groups.length)));\n\n\t\tconst splitTerminalActiveContextKey = TerminalContextKeys.splitTerminalActive.bindTo(this._contextKeyService);\n\t\tthis._register(Event.runAndSubscribe(this.onDidFocusInstance, () => {\n\t\t\tconst activeInstance = this.activeInstance;\n\t\t\tsplitTerminalActiveContextKey.set(activeInstance ? this.instanceIsSplit(activeInstance) : false);\n\t\t}));\n\n\t\tthis._register(this.onDidDisposeGroup(group => this._removeGroup(group)));\n\t\tthis._register(Event.any(this.onDidChangeActiveGroup, this.onDidChangeInstances)(() => this.updateVisibility()));\n\t\tthis._register(this._quickInputService.onShow(() => this._isQuickInputOpened = true));\n\t\tthis._register(this._quickInputService.onHide(() => this._isQuickInputOpened = false));\n\t}\n\n\thidePanel(): void {\n\t\t// Hide the panel if the terminal is in the panel and it has no sibling views\n\t\tconst panel = this._viewDescriptorService.getViewContainerByViewId(TERMINAL_VIEW_ID);\n\t\tif (panel && this._viewDescriptorService.getViewContainerModel(panel).visibleViewDescriptors.length === 1) {\n\t\t\tthis._viewsService.closeView(TERMINAL_VIEW_ID);\n\t\t\tTerminalContextKeys.tabsMouse.bindTo(this._contextKeyService).set(false);\n\t\t}\n\t}\n\n\tget activeGroup(): ITerminalGroup | undefined {\n\t\tif (this.activeGroupIndex < 0 || this.activeGroupIndex >= this.groups.length) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.groups[this.activeGroupIndex];\n\t}\n\tset activeGroup(value: ITerminalGroup | undefined) {\n\t\tif (value === undefined) {\n\t\t\t// Setting to undefined is not possible, this can only be done when removing the last group\n\t\t\treturn;\n\t\t}\n\t\tconst index = this.groups.findIndex(e => e === value);\n\t\tthis.setActiveGroupByIndex(index);\n\t}\n\n\tget activeInstance(): ITerminalInstance | undefined {\n\t\treturn this.activeGroup?.activeInstance;\n\t}\n\n\tsetActiveInstance(instance: ITerminalInstance) {\n\t\tthis.setActiveInstanceByIndex(this._getIndexFromId(instance.instanceId));\n\t}\n\n\tprivate _getIndexFromId(terminalId: number): number {\n\t\tconst terminalIndex = this.instances.findIndex(e => e.instanceId === terminalId);\n\t\tif (terminalIndex === -1) {\n\t\t\tthrow new Error(`Terminal with ID ${terminalId} does not exist (has it already been disposed?)`);\n\t\t}\n\t\treturn terminalIndex;\n\t}\n\n\tsetContainer(container: HTMLElement) {\n\t\tthis._container = container;\n\t\tthis.groups.forEach(group => group.attachToElement(container));\n\t}\n\n\tasync focusTabs(): Promise<void> {\n\t\tif (this.instances.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tawait this.showPanel(true);\n\t\tconst pane = this._viewsService.getActiveViewWithId<TerminalViewPane>(TERMINAL_VIEW_ID);\n\t\tpane?.terminalTabbedView?.focusTabs();\n\t}\n\n\tasync focusHover(): Promise<void> {\n\t\tif (this.instances.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst pane = this._viewsService.getActiveViewWithId<TerminalViewPane>(TERMINAL_VIEW_ID);\n\t\tpane?.terminalTabbedView?.focusHover();\n\t}\n\n\tasync focusInstance(_: ITerminalInstance): Promise<void> {\n\t\treturn this.showPanel(true);\n\t}\n\n\tasync focusActiveInstance(): Promise<void> {\n\t\treturn this.showPanel(true);\n\t}\n\n\tcreateGroup(slcOrInstance?: IShellLaunchConfig | ITerminalInstance): ITerminalGroup {\n\t\tconst group = this._instantiationService.createInstance(TerminalGroup, this._container, slcOrInstance);\n\t\tthis.groups.push(group);\n\t\tgroup.addDisposable(Event.forward(group.onPanelOrientationChanged, this._onDidChangePanelOrientation));\n\t\tgroup.addDisposable(Event.forward(group.onDidDisposeInstance, this._onDidDisposeInstance));\n\t\tgroup.addDisposable(Event.forward(group.onDidFocusInstance, this._onDidFocusInstance));\n\t\tgroup.addDisposable(Event.forward(group.onDidChangeInstanceCapability, this._onDidChangeInstanceCapability));\n\t\tgroup.addDisposable(Event.forward(group.onInstancesChanged, this._onDidChangeInstances));\n\t\tgroup.addDisposable(Event.forward(group.onDisposed, this._onDidDisposeGroup));\n\t\tgroup.addDisposable(group.onDidChangeActiveInstance(e => {\n\t\t\tif (group === this.activeGroup) {\n\t\t\t\tthis._onDidChangeActiveInstance.fire(e);\n\t\t\t}\n\t\t}));\n\t\tif (group.terminalInstances.length > 0) {\n\t\t\tthis._onDidChangeInstances.fire();\n\t\t}\n\t\tif (this.instances.length === 1) {\n\t\t\t// It's the first instance so it should be made active automatically, this must fire\n\t\t\t// after onInstancesChanged so consumers can react to the instance being added first\n\t\t\tthis.setActiveInstanceByIndex(0);\n\t\t}\n\t\tthis._onDidChangeGroups.fire();\n\t\treturn group;\n\t}\n\n\tasync showPanel(focus?: boolean): Promise<void> {\n\t\tconst pane = this._viewsService.getActiveViewWithId(TERMINAL_VIEW_ID)\n\t\t\t?? await this._viewsService.openView(TERMINAL_VIEW_ID, focus);\n\t\tpane?.setExpanded(true);\n\n\t\tif (focus) {\n\t\t\t// Do the focus call asynchronously as going through the\n\t\t\t// command palette will force editor focus\n\t\t\tawait timeout(0);\n\t\t\tconst instance = this.activeInstance;\n\t\t\tif (instance) {\n\t\t\t\t// HACK: Ensure the panel is still visible at this point as there may have been\n\t\t\t\t// a request since it was opened to show a different panel\n\t\t\t\tif (pane && !pane.isVisible()) {\n\t\t\t\t\tawait this._viewsService.openView(TERMINAL_VIEW_ID, focus);\n\t\t\t\t}\n\t\t\t\tawait instance.focusWhenReady(true);\n\t\t\t}\n\t\t}\n\t\tthis._onDidShow.fire();\n\t}\n\n\tgetInstanceFromResource(resource: URI | undefined): ITerminalInstance | undefined {\n\t\treturn getInstanceFromResource(this.instances, resource);\n\t}\n\n\tprivate _removeGroup(group: ITerminalGroup) {\n\t\t// Get the index of the group and remove it from the list\n\t\tconst activeGroup = this.activeGroup;\n\t\tconst wasActiveGroup = group === activeGroup;\n\t\tconst index = this.groups.indexOf(group);\n\t\tif (index !== -1) {\n\t\t\tthis.groups.splice(index, 1);\n\t\t\tthis._onDidChangeGroups.fire();\n\t\t}\n\n\t\tif (wasActiveGroup) {\n\t\t\t// Adjust focus if the group was active\n\t\t\tif (this.groups.length > 0 && !this._isQuickInputOpened) {\n\t\t\t\tconst newIndex = index < this.groups.length ? index : this.groups.length - 1;\n\t\t\t\tthis.setActiveGroupByIndex(newIndex, true);\n\t\t\t\tif (group.hadFocusOnExit) {\n\t\t\t\t\tthis.activeInstance?.focus(true);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Adjust the active group if the removed group was above the active group\n\t\t\tif (this.activeGroupIndex > index) {\n\t\t\t\tthis.setActiveGroupByIndex(this.activeGroupIndex - 1);\n\t\t\t}\n\t\t}\n\t\t// Ensure the active group is still valid, this should set the activeGroupIndex to -1 if\n\t\t// there are no groups\n\t\tif (this.activeGroupIndex >= this.groups.length) {\n\t\t\tthis.setActiveGroupByIndex(this.groups.length - 1);\n\t\t}\n\n\t\tthis._onDidChangeInstances.fire();\n\t\tthis._onDidChangeGroups.fire();\n\t\tif (wasActiveGroup) {\n\t\t\tthis._onDidChangeActiveGroup.fire(this.activeGroup);\n\t\t\tthis._onDidChangeActiveInstance.fire(this.activeInstance);\n\t\t}\n\t}\n\n\t/**\n\t * @param force Whether to force the group change, this should be used when the previous active\n\t * group has been removed.\n\t */\n\tsetActiveGroupByIndex(index: number, force?: boolean) {\n\t\t// Unset active group when the last group is removed\n\t\tif (index === -1 && this.groups.length === 0) {\n\t\t\tif (this.activeGroupIndex !== -1) {\n\t\t\t\tthis.activeGroupIndex = -1;\n\t\t\t\tthis._onDidChangeActiveGroup.fire(this.activeGroup);\n\t\t\t\tthis._onDidChangeActiveInstance.fire(this.activeInstance);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Ensure index is valid\n\t\tif (index < 0 || index >= this.groups.length) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fire group/instance change if needed\n\t\tconst oldActiveGroup = this.activeGroup;\n\t\tthis.activeGroupIndex = index;\n\t\tif (force || oldActiveGroup !== this.activeGroup) {\n\t\t\tthis._onDidChangeActiveGroup.fire(this.activeGroup);\n\t\t\tthis._onDidChangeActiveInstance.fire(this.activeInstance);\n\t\t}\n\t}\n\n\tprivate _getInstanceLocation(index: number): IInstanceLocation | undefined {\n\t\tlet currentGroupIndex = 0;\n\t\twhile (index >= 0 && currentGroupIndex < this.groups.length) {\n\t\t\tconst group = this.groups[currentGroupIndex];\n\t\t\tconst count = group.terminalInstances.length;\n\t\t\tif (index < count) {\n\t\t\t\treturn {\n\t\t\t\t\tgroup,\n\t\t\t\t\tgroupIndex: currentGroupIndex,\n\t\t\t\t\tinstance: group.terminalInstances[index],\n\t\t\t\t\tinstanceIndex: index\n\t\t\t\t};\n\t\t\t}\n\t\t\tindex -= count;\n\t\t\tcurrentGroupIndex++;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tsetActiveInstanceByIndex(index: number) {\n\t\tconst activeInstance = this.activeInstance;\n\t\tconst instanceLocation = this._getInstanceLocation(index);\n\t\tconst newActiveInstance = instanceLocation?.group.terminalInstances[instanceLocation.instanceIndex];\n\t\tif (!instanceLocation || activeInstance === newActiveInstance) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst activeInstanceIndex = instanceLocation.instanceIndex;\n\n\t\tthis.activeGroupIndex = instanceLocation.groupIndex;\n\t\tthis._onDidChangeActiveGroup.fire(this.activeGroup);\n\t\tinstanceLocation.group.setActiveInstanceByIndex(activeInstanceIndex, true);\n\t}\n\n\tsetActiveGroupToNext() {\n\t\tif (this.groups.length <= 1) {\n\t\t\treturn;\n\t\t}\n\t\tlet newIndex = this.activeGroupIndex + 1;\n\t\tif (newIndex >= this.groups.length) {\n\t\t\tnewIndex = 0;\n\t\t}\n\t\tthis.setActiveGroupByIndex(newIndex);\n\t}\n\n\tsetActiveGroupToPrevious() {\n\t\tif (this.groups.length <= 1) {\n\t\t\treturn;\n\t\t}\n\t\tlet newIndex = this.activeGroupIndex - 1;\n\t\tif (newIndex < 0) {\n\t\t\tnewIndex = this.groups.length - 1;\n\t\t}\n\t\tthis.setActiveGroupByIndex(newIndex);\n\t}\n\n\tprivate _getValidTerminalGroups = (sources: ITerminalInstance[]): Set<ITerminalGroup> => {\n\t\treturn new Set(\n\t\t\tsources\n\t\t\t\t.map(source => this.getGroupForInstance(source))\n\t\t\t\t.filter((group) => group !== undefined)\n\t\t);\n\t};\n\n\tmoveGroup(source: SingleOrMany<ITerminalInstance>, target: ITerminalInstance) {\n\t\tsource = asArray(source);\n\t\tconst sourceGroups = this._getValidTerminalGroups(source);\n\t\tconst targetGroup = this.getGroupForInstance(target);\n\t\tif (!targetGroup || sourceGroups.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// The groups are the same, rearrange within the group\n\t\tif (sourceGroups.size === 1 && sourceGroups.has(targetGroup)) {\n\t\t\tconst targetIndex = targetGroup.terminalInstances.indexOf(target);\n\t\t\tconst sortedSources = source.sort((a, b) => {\n\t\t\t\treturn targetGroup.terminalInstances.indexOf(a) - targetGroup.terminalInstances.indexOf(b);\n\t\t\t});\n\t\t\tconst firstTargetIndex = targetGroup.terminalInstances.indexOf(sortedSources[0]);\n\t\t\tconst position: 'before' | 'after' = firstTargetIndex < targetIndex ? 'after' : 'before';\n\t\t\ttargetGroup.moveInstance(sortedSources, targetIndex, position);\n\t\t\tthis._onDidChangeInstances.fire();\n\t\t\treturn;\n\t\t}\n\n\t\t// The groups differ, rearrange groups\n\t\tconst targetGroupIndex = this.groups.indexOf(targetGroup);\n\t\tconst sortedSourceGroups = Array.from(sourceGroups).sort((a, b) => {\n\t\t\treturn this.groups.indexOf(a) - this.groups.indexOf(b);\n\t\t});\n\t\tconst firstSourceGroupIndex = this.groups.indexOf(sortedSourceGroups[0]);\n\t\tconst position: 'before' | 'after' = firstSourceGroupIndex < targetGroupIndex ? 'after' : 'before';\n\t\tconst insertIndex = position === 'after' ? targetGroupIndex + 1 : targetGroupIndex;\n\t\tthis.groups.splice(insertIndex, 0, ...sortedSourceGroups);\n\t\tfor (const sourceGroup of sortedSourceGroups) {\n\t\t\tconst originSourceGroupIndex = position === 'after' ? this.groups.indexOf(sourceGroup) : this.groups.lastIndexOf(sourceGroup);\n\t\t\tthis.groups.splice(originSourceGroupIndex, 1);\n\t\t}\n\t\tthis._onDidChangeInstances.fire();\n\t}\n\n\tmoveGroupToEnd(source: SingleOrMany<ITerminalInstance>): void {\n\t\tsource = asArray(source);\n\t\tconst sourceGroups = this._getValidTerminalGroups(source);\n\t\tif (sourceGroups.size === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst lastInstanceIndex = this.groups.length - 1;\n\t\tconst sortedSourceGroups = Array.from(sourceGroups).sort((a, b) => {\n\t\t\treturn this.groups.indexOf(a) - this.groups.indexOf(b);\n\t\t});\n\t\tthis.groups.splice(lastInstanceIndex + 1, 0, ...sortedSourceGroups);\n\t\tfor (const sourceGroup of sortedSourceGroups) {\n\t\t\tconst sourceGroupIndex = this.groups.indexOf(sourceGroup);\n\t\t\tthis.groups.splice(sourceGroupIndex, 1);\n\t\t}\n\t\tthis._onDidChangeInstances.fire();\n\t}\n\n\tmoveInstance(source: ITerminalInstance, target: ITerminalInstance, side: 'before' | 'after') {\n\t\tconst sourceGroup = this.getGroupForInstance(source);\n\t\tconst targetGroup = this.getGroupForInstance(target);\n\t\tif (!sourceGroup || !targetGroup) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Move from the source group to the target group\n\t\tif (sourceGroup !== targetGroup) {\n\t\t\t// Move groups\n\t\t\tsourceGroup.removeInstance(source);\n\t\t\ttargetGroup.addInstance(source);\n\t\t}\n\n\t\t// Rearrange within the target group\n\t\tconst index = targetGroup.terminalInstances.indexOf(target) + (side === 'after' ? 1 : 0);\n\t\ttargetGroup.moveInstance(source, index, side);\n\t}\n\n\tunsplitInstance(instance: ITerminalInstance) {\n\t\tconst oldGroup = this.getGroupForInstance(instance);\n\t\tif (!oldGroup || oldGroup.terminalInstances.length < 2) {\n\t\t\treturn;\n\t\t}\n\n\t\toldGroup.removeInstance(instance);\n\t\tthis.createGroup(instance);\n\t}\n\n\tjoinInstances(instances: ITerminalInstance[]) {\n\t\tconst group = this.getGroupForInstance(instances[0]);\n\t\tif (group) {\n\t\t\tlet differentGroups = true;\n\t\t\tfor (let i = 1; i < group.terminalInstances.length; i++) {\n\t\t\t\tif (group.terminalInstances.includes(instances[i])) {\n\t\t\t\t\tdifferentGroups = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!differentGroups && group.terminalInstances.length === instances.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Find the group of the first instance that is the only instance in the group, if one exists\n\t\tlet candidateInstance: ITerminalInstance | undefined = undefined;\n\t\tlet candidateGroup: ITerminalGroup | undefined = undefined;\n\t\tfor (const instance of instances) {\n\t\t\tconst group = this.getGroupForInstance(instance);\n\t\t\tif (group?.terminalInstances.length === 1) {\n\t\t\t\tcandidateInstance = instance;\n\t\t\t\tcandidateGroup = group;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Create a new group if needed\n\t\tif (!candidateGroup) {\n\t\t\tcandidateGroup = this.createGroup();\n\t\t}\n\n\t\tconst wasActiveGroup = this.activeGroup === candidateGroup;\n\n\t\t// Unsplit all other instances and add them to the new group\n\t\tfor (const instance of instances) {\n\t\t\tif (instance === candidateInstance) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst oldGroup = this.getGroupForInstance(instance);\n\t\t\tif (!oldGroup) {\n\t\t\t\t// Something went wrong, don't join this one\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toldGroup.removeInstance(instance);\n\t\t\tcandidateGroup.addInstance(instance);\n\t\t}\n\n\t\t// Set the active terminal\n\t\tthis.setActiveInstance(instances[0]);\n\n\t\t// Fire events\n\t\tthis._onDidChangeInstances.fire();\n\t\tif (!wasActiveGroup) {\n\t\t\tthis._onDidChangeActiveGroup.fire(this.activeGroup);\n\t\t}\n\t}\n\n\tinstanceIsSplit(instance: ITerminalInstance): boolean {\n\t\tconst group = this.getGroupForInstance(instance);\n\t\tif (!group) {\n\t\t\treturn false;\n\t\t}\n\t\treturn group.terminalInstances.length > 1;\n\t}\n\n\tgetGroupForInstance(instance: ITerminalInstance): ITerminalGroup | undefined {\n\t\treturn this.groups.find(group => group.terminalInstances.includes(instance));\n\t}\n\n\tgetGroupLabels(): string[] {\n\t\treturn this.groups.filter(group => group.terminalInstances.length > 0).map((group, index) => {\n\t\t\treturn `${index + 1}: ${group.title ? group.title : ''}`;\n\t\t});\n\t}\n\n\t/**\n\t * Visibility should be updated in the following cases:\n\t * 1. Toggle `TERMINAL_VIEW_ID` visibility\n\t * 2. Change active group\n\t * 3. Change instances in active group\n\t */\n\tupdateVisibility() {\n\t\tconst visible = this._viewsService.isViewVisible(TERMINAL_VIEW_ID);\n\t\tthis.groups.forEach((g, i) => g.setVisible(visible && i === this.activeGroupIndex));\n\t}\n}\n\ninterface IInstanceLocation {\n\tgroup: ITerminalGroup;\n\tgroupIndex: number;\n\tinstance: ITerminalInstance;\n\tinstanceIndex: number;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Orientation } from '../../../../base/browser/ui/sash/sash.js';\nimport { timeout } from '../../../../base/common/async.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IShellLaunchConfig } from '../../../../platform/terminal/common/terminal.js';\nimport { IViewDescriptorService } from '../../../common/views.js';\nimport { IViewsService } from '../../../services/views/common/viewsService.js';\nimport { ITerminalGroup, ITerminalGroupService, ITerminalInstance } from './terminal.js';\nimport { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';\nimport { TerminalGroup } from './terminalGroup.js';\nimport { getInstanceFromResource } from './terminalUri.js';\nimport { TerminalViewPane } from './terminalView.js';\nimport { TERMINAL_VIEW_ID } from '../common/terminal.js';\nimport { TerminalContextKeys } from '../common/terminalContextKey.js';\nimport { asArray } from '../../../../base/common/arrays.js';\nimport type { SingleOrMany } from '../../../../base/common/types.js';\n\nexport class TerminalGroupService extends Disposable implements ITerminalGroupService {\n\tdeclare _serviceBrand: undefined;\n\n\tgroups: ITerminalGroup[] = [];\n\tactiveGroupIndex: number = -1;\n\tget instances(): ITerminalInstance[] {\n\t\treturn this.groups.reduce((p, c) => p.concat(c.terminalInstances), [] as ITerminalInstance[]);\n\t}\n\n\tlastAccessedMenu: 'inline-tab' | 'tab-list' = 'inline-tab';\n\n\tprivate _container: HTMLElement | undefined;\n\n\tprivate _isQuickInputOpened: boolean = false;\n\n\tprivate readonly _onDidChangeActiveGroup = this._register(new Emitter<ITerminalGroup | undefined>());\n\treadonly onDidChangeActiveGroup = this._onDidChangeActiveGroup.event;\n\tprivate readonly _onDidDisposeGroup = this._register(new Emitter<ITerminalGroup>());\n\treadonly onDidDisposeGroup = this._onDidDisposeGroup.event;\n\tprivate readonly _onDidChangeGroups = this._register(new Emitter<void>());\n\treadonly onDidChangeGroups = this._onDidChangeGroups.event;\n\tprivate readonly _onDidShow = this._register(new Emitter<void>());\n\treadonly onDidShow = this._onDidShow.event;\n\n\tprivate readonly _onDidDisposeInstance = this._register(new Emitter<ITerminalInstance>());\n\treadonly onDidDisposeInstance = this._onDidDisposeInstance.event;\n\tprivate readonly _onDidFocusInstance = this._register(new Emitter<ITerminalInstance>());\n\treadonly onDidFocusInstance = this._onDidFocusInstance.event;\n\tprivate readonly _onDidChangeActiveInstance = this._register(new Emitter<ITerminalInstance | undefined>());\n\treadonly onDidChangeActiveInstance = this._onDidChangeActiveInstance.event;\n\tprivate readonly _onDidChangeInstances = this._register(new Emitter<void>());\n\treadonly onDidChangeInstances = this._onDidChangeInstances.event;\n\tprivate readonly _onDidChangeInstanceCapability = this._register(new Emitter<ITerminalInstance>());\n\treadonly onDidChangeInstanceCapability = this._onDidChangeInstanceCapability.event;\n\n\tprivate readonly _onDidChangePanelOrientation = this._register(new Emitter<Orientation>());\n\treadonly onDidChangePanelOrientation = this._onDidChangePanelOrientation.event;\n\n\tconstructor(\n\t\t@IContextKeyService private _contextKeyService: IContextKeyService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IViewsService private readonly _viewsService: IViewsService,\n\t\t@IViewDescriptorService private readonly _viewDescriptorService: IViewDescriptorService,\n\t\t@IQuickInputService private readonly _quickInputService: IQuickInputService\n\t) {\n\t\tsuper();\n\n\t\tconst terminalGroupCountContextKey = TerminalContextKeys.groupCount.bindTo(this._contextKeyService);\n\t\tthis._register(Event.runAndSubscribe(this.onDidChangeGroups, () => terminalGroupCountContextKey.set(this.groups.length)));\n\n\t\tconst splitTerminalActiveContextKey = TerminalContextKeys.splitTerminalActive.bindTo(this._contextKeyService);\n\t\tthis._register(Event.runAndSubscribe(this.onDidFocusInstance, () => {\n\t\t\tconst activeInstance = this.activeInstance;\n\t\t\tsplitTerminalActiveContextKey.set(activeInstance ? this.instanceIsSplit(activeInstance) : false);\n\t\t}));\n\n\t\tthis._register(this.onDidDisposeGroup(group => this._removeGroup(group)));\n\t\tthis._register(Event.any(this.onDidChangeActiveGroup, this.onDidChangeInstances)(() => this.updateVisibility()));\n\t\tthis._register(this._quickInputService.onShow(() => this._isQuickInputOpened = true));\n\t\tthis._register(this._quickInputService.onHide(() => this._isQuickInputOpened = false));\n\t}\n\n\thidePanel(): void {\n\t\t// Hide the panel if the terminal is in the panel and it has no sibling views\n\t\tconst panel = this._viewDescriptorService.getViewContainerByViewId(TERMINAL_VIEW_ID);\n\t\tif (panel && this._viewDescriptorService.getViewContainerModel(panel).visibleViewDescriptors.length === 1) {\n\t\t\tthis._viewsService.closeView(TERMINAL_VIEW_ID);\n\t\t\tTerminalContextKeys.tabsMouse.bindTo(this._contextKeyService).set(false);\n\t\t}\n\t}\n\n\tget activeGroup(): ITerminalGroup | undefined {\n\t\tif (this.activeGroupIndex < 0 || this.activeGroupIndex >= this.groups.length) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.groups[this.activeGroupIndex];\n\t}\n\tset activeGroup(value: ITerminalGroup | undefined) {\n\t\tif (value === undefined) {\n\t\t\t// Setting to undefined is not possible, this can only be done when removing the last group\n\t\t\treturn;\n\t\t}\n\t\tconst index = this.groups.findIndex(e => e === value);\n\t\tthis.setActiveGroupByIndex(index);\n\t}\n\n\tget activeInstance(): ITerminalInstance | undefined {\n\t\treturn this.activeGroup?.activeInstance;\n\t}\n\n\tsetActiveInstance(instance: ITerminalInstance) {\n\t\tthis.setActiveInstanceByIndex(this._getIndexFromId(instance.instanceId));\n\t}\n\n\tprivate _getIndexFromId(terminalId: number): number {\n\t\tconst terminalIndex = this.instances.findIndex(e => e.instanceId === terminalId);\n\t\tif (terminalIndex === -1) {\n\t\t\tthrow new Error(`Terminal with ID ${terminalId} does not exist (has it already been disposed?)`);\n\t\t}\n\t\treturn terminalIndex;\n\t}\n\n\tsetContainer(container: HTMLElement) {\n\t\tthis._container = container;\n\t\tthis.groups.forEach(group => group.attachToElement(container));\n\t}\n\n\tasync focusTabs(): Promise<void> {\n\t\tif (this.instances.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tawait this.showPanel(true);\n\t\tconst pane = this._viewsService.getActiveViewWithId<TerminalViewPane>(TERMINAL_VIEW_ID);\n\t\tpane?.terminalTabbedView?.focusTabs();\n\t}\n\n\tasync focusHover(): Promise<void> {\n\t\tif (this.instances.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst pane = this._viewsService.getActiveViewWithId<TerminalViewPane>(TERMINAL_VIEW_ID);\n\t\tpane?.terminalTabbedView?.focusHover();\n\t}\n\n\tasync focusInstance(_: ITerminalInstance): Promise<void> {\n\t\treturn this.showPanel(true);\n\t}\n\n\tasync focusActiveInstance(): Promise<void> {\n\t\treturn this.showPanel(true);\n\t}\n\n\tcreateGroup(slcOrInstance?: IShellLaunchConfig | ITerminalInstance): ITerminalGroup {\n\t\tconst group = this._instantiationService.createInstance(TerminalGroup, this._container, slcOrInstance);\n\t\tthis.groups.push(group);\n\t\tgroup.addDisposable(Event.forward(group.onPanelOrientationChanged, this._onDidChangePanelOrientation));\n\t\tgroup.addDisposable(Event.forward(group.onDidDisposeInstance, this._onDidDisposeInstance));\n\t\tgroup.addDisposable(Event.forward(group.onDidFocusInstance, this._onDidFocusInstance));\n\t\tgroup.addDisposable(Event.forward(group.onDidChangeInstanceCapability, this._onDidChangeInstanceCapability));\n\t\tgroup.addDisposable(Event.forward(group.onInstancesChanged, this._onDidChangeInstances));\n\t\tgroup.addDisposable(Event.forward(group.onDisposed, this._onDidDisposeGroup));\n\t\tgroup.addDisposable(group.onDidChangeActiveInstance(e => {\n\t\t\tif (group === this.activeGroup) {\n\t\t\t\tthis._onDidChangeActiveInstance.fire(e);\n\t\t\t}\n\t\t}));\n\t\tif (group.terminalInstances.length > 0) {\n\t\t\tthis._onDidChangeInstances.fire();\n\t\t}\n\t\tif (this.instances.length === 1) {\n\t\t\t// It's the first instance so it should be made active automatically, this must fire\n\t\t\t// after onInstancesChanged so consumers can react to the instance being added first\n\t\t\tthis.setActiveInstanceByIndex(0);\n\t\t}\n\t\tthis._onDidChangeGroups.fire();\n\t\treturn group;\n\t}\n\n\tasync showPanel(focus?: boolean): Promise<void> {\n\t\tconst pane = this._viewsService.getActiveViewWithId(TERMINAL_VIEW_ID)\n\t\t\t?? await this._viewsService.openView(TERMINAL_VIEW_ID, focus);\n\t\tpane?.setExpanded(true);\n\n\t\tif (focus) {\n\t\t\t// Do the focus call asynchronously as going through the\n\t\t\t// command palette will force editor focus\n\t\t\tawait timeout(0);\n\t\t\tconst instance = this.activeInstance;\n\t\t\tif (instance) {\n\t\t\t\t// HACK: Ensure the panel is still visible at this point as there may have been\n\t\t\t\t// a request since it was opened to show a different panel\n\t\t\t\tif (pane && !pane.isVisible()) {\n\t\t\t\t\tawait this._viewsService.openView(TERMINAL_VIEW_ID, focus);\n\t\t\t\t}\n\t\t\t\tawait instance.focusWhenReady(true);\n\t\t\t}\n\t\t}\n\t\tthis._onDidShow.fire();\n\t}\n\n\tgetInstanceFromResource(resource: URI | undefined): ITerminalInstance | undefined {\n\t\treturn getInstanceFromResource(this.instances, resource);\n\t}\n\n\tprivate _removeGroup(group: ITerminalGroup) {\n\t\t// Get the index of the group and remove it from the list\n\t\tconst activeGroup = this.activeGroup;\n\t\tconst wasActiveGroup = group === activeGroup;\n\t\tconst index = this.groups.indexOf(group);\n\t\tif (index !== -1) {\n\t\t\tthis.groups.splice(index, 1);\n\t\t\tthis._onDidChangeGroups.fire();\n\t\t}\n\n\t\tif (wasActiveGroup) {\n\t\t\t// Adjust focus if the group was active\n\t\t\tif (this.groups.length > 0 && !this._isQuickInputOpened) {\n\t\t\t\tconst newIndex = index < this.groups.length ? index : this.groups.length - 1;\n\t\t\t\tthis.setActiveGroupByIndex(newIndex, true);\n\t\t\t\tif (group.hadFocusOnExit) {\n\t\t\t\t\tthis.activeInstance?.focus(true);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Adjust the active group if the removed group was above the active group\n\t\t\tif (this.activeGroupIndex > index) {\n\t\t\t\tthis.setActiveGroupByIndex(this.activeGroupIndex - 1);\n\t\t\t}\n\t\t}\n\t\t// Ensure the active group is still valid, this should set the activeGroupIndex to -1 if\n\t\t// there are no groups\n\t\tif (this.activeGroupIndex >= this.groups.length) {\n\t\t\tthis.setActiveGroupByIndex(this.groups.length - 1);\n\t\t}\n\n\t\tthis._onDidChangeInstances.fire();\n\t\tthis._onDidChangeGroups.fire();\n\t\tif (wasActiveGroup) {\n\t\t\tthis._onDidChangeActiveGroup.fire(this.activeGroup);\n\t\t\tthis._onDidChangeActiveInstance.fire(this.activeInstance);\n\t\t}\n\t}\n\n\t/**\n\t * @param force Whether to force the group change, this should be used when the previous active\n\t * group has been removed.\n\t */\n\tsetActiveGroupByIndex(index: number, force?: boolean) {\n\t\t// Unset active group when the last group is removed\n\t\tif (index === -1 && this.groups.length === 0) {\n\t\t\tif (this.activeGroupIndex !== -1) {\n\t\t\t\tthis.activeGroupIndex = -1;\n\t\t\t\tthis._onDidChangeActiveGroup.fire(this.activeGroup);\n\t\t\t\tthis._onDidChangeActiveInstance.fire(this.activeInstance);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Ensure index is valid\n\t\tif (index < 0 || index >= this.groups.length) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fire group/instance change if needed\n\t\tconst oldActiveGroup = this.activeGroup;\n\t\tthis.activeGroupIndex = index;\n\t\tif (force || oldActiveGroup !== this.activeGroup) {\n\t\t\tthis._onDidChangeActiveGroup.fire(this.activeGroup);\n\t\t\tthis._onDidChangeActiveInstance.fire(this.activeInstance);\n\t\t}\n\t}\n\n\tprivate _getInstanceLocation(index: number): IInstanceLocation | undefined {\n\t\tlet currentGroupIndex = 0;\n\t\twhile (index >= 0 && currentGroupIndex < this.groups.length) {\n\t\t\tconst group = this.groups[currentGroupIndex];\n\t\t\tconst count = group.terminalInstances.length;\n\t\t\tif (index < count) {\n\t\t\t\treturn {\n\t\t\t\t\tgroup,\n\t\t\t\t\tgroupIndex: currentGroupIndex,\n\t\t\t\t\tinstance: group.terminalInstances[index],\n\t\t\t\t\tinstanceIndex: index\n\t\t\t\t};\n\t\t\t}\n\t\t\tindex -= count;\n\t\t\tcurrentGroupIndex++;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tsetActiveInstanceByIndex(index: number) {\n\t\tconst activeInstance = this.activeInstance;\n\t\tconst instanceLocation = this._getInstanceLocation(index);\n\t\tconst newActiveInstance = instanceLocation?.group.terminalInstances[instanceLocation.instanceIndex];\n\t\tif (!instanceLocation || activeInstance === newActiveInstance) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst activeInstanceIndex = instanceLocation.instanceIndex;\n\n\t\tthis.activeGroupIndex = instanceLocation.groupIndex;\n\t\tthis._onDidChangeActiveGroup.fire(this.activeGroup);\n\t\tinstanceLocation.group.setActiveInstanceByIndex(activeInstanceIndex, true);\n\t}\n\n\tsetActiveGroupToNext() {\n\t\tif (this.groups.length <= 1) {\n\t\t\treturn;\n\t\t}\n\t\tlet newIndex = this.activeGroupIndex + 1;\n\t\tif (newIndex >= this.groups.length) {\n\t\t\tnewIndex = 0;\n\t\t}\n\t\tthis.setActiveGroupByIndex(newIndex);\n\t}\n\n\tsetActiveGroupToPrevious() {\n\t\tif (this.groups.length <= 1) {\n\t\t\treturn;\n\t\t}\n\t\tlet newIndex = this.activeGroupIndex - 1;\n\t\tif (newIndex < 0) {\n\t\t\tnewIndex = this.groups.length - 1;\n\t\t}\n\t\tthis.setActiveGroupByIndex(newIndex);\n\t}\n\n\tprivate _getValidTerminalGroups = (sources: ITerminalInstance[]): Set<ITerminalGroup> => {\n\t\treturn new Set(\n\t\t\tsources\n\t\t\t\t.map(source => this.getGroupForInstance(source))\n\t\t\t\t.filter((group) => group !== undefined)\n\t\t);\n\t};\n\n\tmoveGroup(source: SingleOrMany<ITerminalInstance>, target: ITerminalInstance) {\n\t\tsource = asArray(source);\n\t\tconst sourceGroups = this._getValidTerminalGroups(source);\n\t\tconst targetGroup = this.getGroupForInstance(target);\n\t\tif (!targetGroup || sourceGroups.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// The groups are the same, rearrange within the group\n\t\tif (sourceGroups.size === 1 && sourceGroups.has(targetGroup)) {\n\t\t\tconst targetIndex = targetGroup.terminalInstances.indexOf(target);\n\t\t\tconst sortedSources = source.sort((a, b) => {\n\t\t\t\treturn targetGroup.terminalInstances.indexOf(a) - targetGroup.terminalInstances.indexOf(b);\n\t\t\t});\n\t\t\tconst firstTargetIndex = targetGroup.terminalInstances.indexOf(sortedSources[0]);\n\t\t\tconst position: 'before' | 'after' = firstTargetIndex < targetIndex ? 'after' : 'before';\n\t\t\ttargetGroup.moveInstance(sortedSources, targetIndex, position);\n\t\t\tthis._onDidChangeInstances.fire();\n\t\t\treturn;\n\t\t}\n\n\t\t// The groups differ, rearrange groups\n\t\tconst targetGroupIndex = this.groups.indexOf(targetGroup);\n\t\tconst sortedSourceGroups = Array.from(sourceGroups).sort((a, b) => {\n\t\t\treturn this.groups.indexOf(a) - this.groups.indexOf(b);\n\t\t});\n\t\tconst firstSourceGroupIndex = this.groups.indexOf(sortedSourceGroups[0]);\n\t\tconst position: 'before' | 'after' = firstSourceGroupIndex < targetGroupIndex ? 'after' : 'before';\n\t\tconst insertIndex = position === 'after' ? targetGroupIndex + 1 : targetGroupIndex;\n\t\tthis.groups.splice(insertIndex, 0, ...sortedSourceGroups);\n\t\tfor (const sourceGroup of sortedSourceGroups) {\n\t\t\tconst originSourceGroupIndex = position === 'after' ? this.groups.indexOf(sourceGroup) : this.groups.lastIndexOf(sourceGroup);\n\t\t\tthis.groups.splice(originSourceGroupIndex, 1);\n\t\t}\n\t\tthis._onDidChangeInstances.fire();\n\t}\n\n\tmoveGroupToEnd(source: SingleOrMany<ITerminalInstance>): void {\n\t\tsource = asArray(source);\n\t\tconst sourceGroups = this._getValidTerminalGroups(source);\n\t\tif (sourceGroups.size === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst lastInstanceIndex = this.groups.length - 1;\n\t\tconst sortedSourceGroups = Array.from(sourceGroups).sort((a, b) => {\n\t\t\treturn this.groups.indexOf(a) - this.groups.indexOf(b);\n\t\t});\n\t\tthis.groups.splice(lastInstanceIndex + 1, 0, ...sortedSourceGroups);\n\t\tfor (const sourceGroup of sortedSourceGroups) {\n\t\t\tconst sourceGroupIndex = this.groups.indexOf(sourceGroup);\n\t\t\tthis.groups.splice(sourceGroupIndex, 1);\n\t\t}\n\t\tthis._onDidChangeInstances.fire();\n\t}\n\n\tmoveInstance(source: ITerminalInstance, target: ITerminalInstance, side: 'before' | 'after') {\n\t\tconst sourceGroup = this.getGroupForInstance(source);\n\t\tconst targetGroup = this.getGroupForInstance(target);\n\t\tif (!sourceGroup || !targetGroup) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Move from the source group to the target group\n\t\tif (sourceGroup !== targetGroup) {\n\t\t\t// Move groups\n\t\t\tsourceGroup.removeInstance(source);\n\t\t\ttargetGroup.addInstance(source);\n\t\t}\n\n\t\t// Rearrange within the target group\n\t\tconst index = targetGroup.terminalInstances.indexOf(target) + (side === 'after' ? 1 : 0);\n\t\ttargetGroup.moveInstance(source, index, side);\n\t}\n\n\tunsplitInstance(instance: ITerminalInstance) {\n\t\tconst oldGroup = this.getGroupForInstance(instance);\n\t\tif (!oldGroup || oldGroup.terminalInstances.length < 2) {\n\t\t\treturn;\n\t\t}\n\n\t\toldGroup.removeInstance(instance);\n\t\tthis.createGroup(instance);\n\t}\n\n\tjoinInstances(instances: ITerminalInstance[]) {\n\t\tconst group = this.getGroupForInstance(instances[0]);\n\t\tif (group) {\n\t\t\tlet differentGroups = true;\n\t\t\tfor (let i = 1; i < group.terminalInstances.length; i++) {\n\t\t\t\tif (group.terminalInstances.includes(instances[i])) {\n\t\t\t\t\tdifferentGroups = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!differentGroups && group.terminalInstances.length === instances.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Find the group of the first instance that is the only instance in the group, if one exists\n\t\tlet candidateInstance: ITerminalInstance | undefined = undefined;\n\t\tlet candidateGroup: ITerminalGroup | undefined = undefined;\n\t\tfor (const instance of instances) {\n\t\t\tconst group = this.getGroupForInstance(instance);\n\t\t\tif (group?.terminalInstances.length === 1) {\n\t\t\t\tcandidateInstance = instance;\n\t\t\t\tcandidateGroup = group;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Create a new group if needed\n\t\tif (!candidateGroup) {\n\t\t\tcandidateGroup = this.createGroup();\n\t\t}\n\n\t\tconst wasActiveGroup = this.activeGroup === candidateGroup;\n\n\t\t// Unsplit all other instances and add them to the new group\n\t\tfor (const instance of instances) {\n\t\t\tif (instance === candidateInstance) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst oldGroup = this.getGroupForInstance(instance);\n\t\t\tif (!oldGroup) {\n\t\t\t\t// Something went wrong, don't join this one\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toldGroup.removeInstance(instance);\n\t\t\tcandidateGroup.addInstance(instance);\n\t\t}\n\n\t\t// Set the active terminal\n\t\tthis.setActiveInstance(instances[0]);\n\n\t\t// Fire events\n\t\tthis._onDidChangeInstances.fire();\n\t\tif (!wasActiveGroup) {\n\t\t\tthis._onDidChangeActiveGroup.fire(this.activeGroup);\n\t\t}\n\t}\n\n\tinstanceIsSplit(instance: ITerminalInstance): boolean {\n\t\tconst group = this.getGroupForInstance(instance);\n\t\tif (!group) {\n\t\t\treturn false;\n\t\t}\n\t\treturn group.terminalInstances.length > 1;\n\t}\n\n\tgetGroupForInstance(instance: ITerminalInstance): ITerminalGroup | undefined {\n\t\treturn this.groups.find(group => group.terminalInstances.includes(instance));\n\t}\n\n\tgetGroupLabels(): string[] {\n\t\treturn this.groups.filter(group => group.terminalInstances.length > 0).map((group, index) => {\n\t\t\treturn `${index + 1}: ${group.title ? group.title : ''}`;\n\t\t});\n\t}\n\n\t/**\n\t * Visibility should be updated in the following cases:\n\t * 1. Toggle `TERMINAL_VIEW_ID` visibility\n\t * 2. Change active group\n\t * 3. Change instances in active group\n\t */\n\tupdateVisibility() {\n\t\tconst visible = this._viewsService.isViewVisible(TERMINAL_VIEW_ID);\n\t\tthis.groups.forEach((g, i) => g.setVisible(visible && i === this.activeGroupIndex));\n\t}\n}\n\ninterface IInstanceLocation {\n\tgroup: ITerminalGroup;\n\tgroupIndex: number;\n\tinstance: ITerminalInstance;\n\tinstanceIndex: number;\n}\n"]}