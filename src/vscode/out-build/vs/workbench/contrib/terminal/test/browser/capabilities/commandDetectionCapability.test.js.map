{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminal/test/browser/capabilities/commandDetectionCapability.test.ts","vs/workbench/contrib/terminal/test/browser/capabilities/commandDetectionCapability.test.ts"],"names":[],"mappings":"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","file":"commandDetectionCapability.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { Terminal } from '@xterm/xterm';\nimport { deepStrictEqual, ok } from 'assert';\nimport { importAMDNodeModule } from '../../../../../../amdX.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../../base/test/common/utils.js';\nimport { ITerminalCommand } from '../../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { CommandDetectionCapability } from '../../../../../../platform/terminal/common/capabilities/commandDetectionCapability.js';\nimport { writeP } from '../../../browser/terminalTestHelpers.js';\nimport { workbenchInstantiationService } from '../../../../../test/browser/workbenchTestServices.js';\n\ntype TestTerminalCommandMatch = Pick<ITerminalCommand, 'command' | 'cwd' | 'exitCode'> & { marker: { line: number } };\n\nclass TestCommandDetectionCapability extends CommandDetectionCapability {\n\tclearCommands() {\n\t\tthis._commands.length = 0;\n\t}\n}\n\nsuite('CommandDetectionCapability', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tlet xterm: Terminal;\n\tlet capability: TestCommandDetectionCapability;\n\tlet addEvents: ITerminalCommand[];\n\n\tfunction assertCommands(expectedCommands: TestTerminalCommandMatch[]) {\n\t\tdeepStrictEqual(capability.commands.map(e => e.command), expectedCommands.map(e => e.command));\n\t\tdeepStrictEqual(capability.commands.map(e => e.cwd), expectedCommands.map(e => e.cwd));\n\t\tdeepStrictEqual(capability.commands.map(e => e.exitCode), expectedCommands.map(e => e.exitCode));\n\t\tdeepStrictEqual(capability.commands.map(e => e.marker?.line), expectedCommands.map(e => e.marker?.line));\n\t\t// Ensure timestamps are set and were captured recently\n\t\tfor (const command of capability.commands) {\n\t\t\tok(Math.abs(Date.now() - command.timestamp) < 2000);\n\t\t\tok(command.id, 'Expected command to have an assigned id');\n\t\t}\n\t\tdeepStrictEqual(addEvents, capability.commands);\n\t\t// Clear the commands to avoid re-asserting past commands\n\t\taddEvents.length = 0;\n\t\tcapability.clearCommands();\n\t}\n\n\tasync function printStandardCommand(prompt: string, command: string, output: string, cwd: string | undefined, exitCode: number) {\n\t\tif (cwd !== undefined) {\n\t\t\tcapability.setCwd(cwd);\n\t\t}\n\t\tcapability.handlePromptStart();\n\t\tawait writeP(xterm, `\\r${prompt}`);\n\t\tcapability.handleCommandStart();\n\t\tawait writeP(xterm, command);\n\t\tcapability.handleCommandExecuted();\n\t\tawait writeP(xterm, `\\r\\n${output}\\r\\n`);\n\t\tcapability.handleCommandFinished(exitCode);\n\t}\n\n\tasync function printCommandStart(prompt: string) {\n\t\tcapability.handlePromptStart();\n\t\tawait writeP(xterm, `\\r${prompt}`);\n\t\tcapability.handleCommandStart();\n\t}\n\n\n\tsetup(async () => {\n\t\tconst TerminalCtor = (await importAMDNodeModule<typeof import('@xterm/xterm')>('@xterm/xterm', 'lib/xterm.js')).Terminal;\n\n\t\txterm = store.add(new TerminalCtor({ allowProposedApi: true, cols: 80 }));\n\t\tconst instantiationService = workbenchInstantiationService(undefined, store);\n\t\tcapability = store.add(instantiationService.createInstance(TestCommandDetectionCapability, xterm));\n\t\taddEvents = [];\n\t\tstore.add(capability.onCommandFinished(e => addEvents.push(e)));\n\t\tassertCommands([]);\n\t});\n\n\ttest('should not add commands when no capability methods are triggered', async () => {\n\t\tawait writeP(xterm, 'foo\\r\\nbar\\r\\n');\n\t\tassertCommands([]);\n\t\tawait writeP(xterm, 'baz\\r\\n');\n\t\tassertCommands([]);\n\t});\n\n\ttest('should add commands for expected capability method calls', async () => {\n\t\tawait printStandardCommand('$ ', 'echo foo', 'foo', undefined, 0);\n\t\tawait printCommandStart('$ ');\n\t\tassertCommands([{\n\t\t\tcommand: 'echo foo',\n\t\t\texitCode: 0,\n\t\t\tcwd: undefined,\n\t\t\tmarker: { line: 0 }\n\t\t}]);\n\t});\n\n\ttest('should trim the command when command executed appears on the following line', async () => {\n\t\tawait printStandardCommand('$ ', 'echo foo\\r\\n', 'foo', undefined, 0);\n\t\tawait printCommandStart('$ ');\n\t\tassertCommands([{\n\t\t\tcommand: 'echo foo',\n\t\t\texitCode: 0,\n\t\t\tcwd: undefined,\n\t\t\tmarker: { line: 0 }\n\t\t}]);\n\t});\n\n\tsuite('cwd', () => {\n\t\ttest('should add cwd to commands when it\\'s set', async () => {\n\t\t\tawait printStandardCommand('$ ', 'echo foo', 'foo', '/home', 0);\n\t\t\tawait printStandardCommand('$ ', 'echo bar', 'bar', '/home/second', 0);\n\t\t\tawait printCommandStart('$ ');\n\t\t\tassertCommands([\n\t\t\t\t{ command: 'echo foo', exitCode: 0, cwd: '/home', marker: { line: 0 } },\n\t\t\t\t{ command: 'echo bar', exitCode: 0, cwd: '/home/second', marker: { line: 2 } }\n\t\t\t]);\n\t\t});\n\t\ttest('should add old cwd to commands if no cwd sequence is output', async () => {\n\t\t\tawait printStandardCommand('$ ', 'echo foo', 'foo', '/home', 0);\n\t\t\tawait printStandardCommand('$ ', 'echo bar', 'bar', undefined, 0);\n\t\t\tawait printCommandStart('$ ');\n\t\t\tassertCommands([\n\t\t\t\t{ command: 'echo foo', exitCode: 0, cwd: '/home', marker: { line: 0 } },\n\t\t\t\t{ command: 'echo bar', exitCode: 0, cwd: '/home', marker: { line: 2 } }\n\t\t\t]);\n\t\t});\n\t\ttest('should use an undefined cwd if it\\'s not set initially', async () => {\n\t\t\tawait printStandardCommand('$ ', 'echo foo', 'foo', undefined, 0);\n\t\t\tawait printStandardCommand('$ ', 'echo bar', 'bar', '/home', 0);\n\t\t\tawait printCommandStart('$ ');\n\t\t\tassertCommands([\n\t\t\t\t{ command: 'echo foo', exitCode: 0, cwd: undefined, marker: { line: 0 } },\n\t\t\t\t{ command: 'echo bar', exitCode: 0, cwd: '/home', marker: { line: 2 } }\n\t\t\t]);\n\t\t});\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { Terminal } from '@xterm/xterm';\nimport { deepStrictEqual, ok } from 'assert';\nimport { importAMDNodeModule } from '../../../../../../amdX.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../../base/test/common/utils.js';\nimport { ITerminalCommand } from '../../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { CommandDetectionCapability } from '../../../../../../platform/terminal/common/capabilities/commandDetectionCapability.js';\nimport { writeP } from '../../../browser/terminalTestHelpers.js';\nimport { workbenchInstantiationService } from '../../../../../test/browser/workbenchTestServices.js';\n\ntype TestTerminalCommandMatch = Pick<ITerminalCommand, 'command' | 'cwd' | 'exitCode'> & { marker: { line: number } };\n\nclass TestCommandDetectionCapability extends CommandDetectionCapability {\n\tclearCommands() {\n\t\tthis._commands.length = 0;\n\t}\n}\n\nsuite('CommandDetectionCapability', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tlet xterm: Terminal;\n\tlet capability: TestCommandDetectionCapability;\n\tlet addEvents: ITerminalCommand[];\n\n\tfunction assertCommands(expectedCommands: TestTerminalCommandMatch[]) {\n\t\tdeepStrictEqual(capability.commands.map(e => e.command), expectedCommands.map(e => e.command));\n\t\tdeepStrictEqual(capability.commands.map(e => e.cwd), expectedCommands.map(e => e.cwd));\n\t\tdeepStrictEqual(capability.commands.map(e => e.exitCode), expectedCommands.map(e => e.exitCode));\n\t\tdeepStrictEqual(capability.commands.map(e => e.marker?.line), expectedCommands.map(e => e.marker?.line));\n\t\t// Ensure timestamps are set and were captured recently\n\t\tfor (const command of capability.commands) {\n\t\t\tok(Math.abs(Date.now() - command.timestamp) < 2000);\n\t\t\tok(command.id, 'Expected command to have an assigned id');\n\t\t}\n\t\tdeepStrictEqual(addEvents, capability.commands);\n\t\t// Clear the commands to avoid re-asserting past commands\n\t\taddEvents.length = 0;\n\t\tcapability.clearCommands();\n\t}\n\n\tasync function printStandardCommand(prompt: string, command: string, output: string, cwd: string | undefined, exitCode: number) {\n\t\tif (cwd !== undefined) {\n\t\t\tcapability.setCwd(cwd);\n\t\t}\n\t\tcapability.handlePromptStart();\n\t\tawait writeP(xterm, `\\r${prompt}`);\n\t\tcapability.handleCommandStart();\n\t\tawait writeP(xterm, command);\n\t\tcapability.handleCommandExecuted();\n\t\tawait writeP(xterm, `\\r\\n${output}\\r\\n`);\n\t\tcapability.handleCommandFinished(exitCode);\n\t}\n\n\tasync function printCommandStart(prompt: string) {\n\t\tcapability.handlePromptStart();\n\t\tawait writeP(xterm, `\\r${prompt}`);\n\t\tcapability.handleCommandStart();\n\t}\n\n\n\tsetup(async () => {\n\t\tconst TerminalCtor = (await importAMDNodeModule<typeof import('@xterm/xterm')>('@xterm/xterm', 'lib/xterm.js')).Terminal;\n\n\t\txterm = store.add(new TerminalCtor({ allowProposedApi: true, cols: 80 }));\n\t\tconst instantiationService = workbenchInstantiationService(undefined, store);\n\t\tcapability = store.add(instantiationService.createInstance(TestCommandDetectionCapability, xterm));\n\t\taddEvents = [];\n\t\tstore.add(capability.onCommandFinished(e => addEvents.push(e)));\n\t\tassertCommands([]);\n\t});\n\n\ttest('should not add commands when no capability methods are triggered', async () => {\n\t\tawait writeP(xterm, 'foo\\r\\nbar\\r\\n');\n\t\tassertCommands([]);\n\t\tawait writeP(xterm, 'baz\\r\\n');\n\t\tassertCommands([]);\n\t});\n\n\ttest('should add commands for expected capability method calls', async () => {\n\t\tawait printStandardCommand('$ ', 'echo foo', 'foo', undefined, 0);\n\t\tawait printCommandStart('$ ');\n\t\tassertCommands([{\n\t\t\tcommand: 'echo foo',\n\t\t\texitCode: 0,\n\t\t\tcwd: undefined,\n\t\t\tmarker: { line: 0 }\n\t\t}]);\n\t});\n\n\ttest('should trim the command when command executed appears on the following line', async () => {\n\t\tawait printStandardCommand('$ ', 'echo foo\\r\\n', 'foo', undefined, 0);\n\t\tawait printCommandStart('$ ');\n\t\tassertCommands([{\n\t\t\tcommand: 'echo foo',\n\t\t\texitCode: 0,\n\t\t\tcwd: undefined,\n\t\t\tmarker: { line: 0 }\n\t\t}]);\n\t});\n\n\tsuite('cwd', () => {\n\t\ttest('should add cwd to commands when it\\'s set', async () => {\n\t\t\tawait printStandardCommand('$ ', 'echo foo', 'foo', '/home', 0);\n\t\t\tawait printStandardCommand('$ ', 'echo bar', 'bar', '/home/second', 0);\n\t\t\tawait printCommandStart('$ ');\n\t\t\tassertCommands([\n\t\t\t\t{ command: 'echo foo', exitCode: 0, cwd: '/home', marker: { line: 0 } },\n\t\t\t\t{ command: 'echo bar', exitCode: 0, cwd: '/home/second', marker: { line: 2 } }\n\t\t\t]);\n\t\t});\n\t\ttest('should add old cwd to commands if no cwd sequence is output', async () => {\n\t\t\tawait printStandardCommand('$ ', 'echo foo', 'foo', '/home', 0);\n\t\t\tawait printStandardCommand('$ ', 'echo bar', 'bar', undefined, 0);\n\t\t\tawait printCommandStart('$ ');\n\t\t\tassertCommands([\n\t\t\t\t{ command: 'echo foo', exitCode: 0, cwd: '/home', marker: { line: 0 } },\n\t\t\t\t{ command: 'echo bar', exitCode: 0, cwd: '/home', marker: { line: 2 } }\n\t\t\t]);\n\t\t});\n\t\ttest('should use an undefined cwd if it\\'s not set initially', async () => {\n\t\t\tawait printStandardCommand('$ ', 'echo foo', 'foo', undefined, 0);\n\t\t\tawait printStandardCommand('$ ', 'echo bar', 'bar', '/home', 0);\n\t\t\tawait printCommandStart('$ ');\n\t\t\tassertCommands([\n\t\t\t\t{ command: 'echo foo', exitCode: 0, cwd: undefined, marker: { line: 0 } },\n\t\t\t\t{ command: 'echo bar', exitCode: 0, cwd: '/home', marker: { line: 2 } }\n\t\t\t]);\n\t\t});\n\t});\n});\n"]}