{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminal/common/terminalEnvironment.ts","vs/workbench/contrib/terminal/common/terminalEnvironment.ts"],"names":[],"mappings":"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","file":"terminalEnvironment.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * This module contains utility functions related to the environment, cwd and paths.\n */\n\nimport * as path from '../../../../base/common/path.js';\nimport { URI, uriToFsPath } from '../../../../base/common/uri.js';\nimport { IWorkspaceContextService, IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { IConfigurationResolverService } from '../../../services/configurationResolver/common/configurationResolver.js';\nimport { sanitizeProcessEnvironment } from '../../../../base/common/processes.js';\nimport { IShellLaunchConfig, ITerminalBackend, ITerminalEnvironment, TerminalSettingId, TerminalShellType, WindowsShellType } from '../../../../platform/terminal/common/terminal.js';\nimport { IProcessEnvironment, isWindows, isMacintosh, language, OperatingSystem } from '../../../../base/common/platform.js';\nimport { escapeNonWindowsPath, sanitizeCwd } from '../../../../platform/terminal/common/terminalEnvironment.js';\nimport { isNumber, isString } from '../../../../base/common/types.js';\nimport { IHistoryService } from '../../../services/history/common/history.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport type { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\n\nexport function mergeEnvironments(parent: IProcessEnvironment, other: ITerminalEnvironment | undefined): void {\n\tif (!other) {\n\t\treturn;\n\t}\n\n\t// On Windows apply the new values ignoring case, while still retaining\n\t// the case of the original key.\n\tif (isWindows) {\n\t\tfor (const configKey in other) {\n\t\t\tlet actualKey = configKey;\n\t\t\tfor (const envKey in parent) {\n\t\t\t\tif (configKey.toLowerCase() === envKey.toLowerCase()) {\n\t\t\t\t\tactualKey = envKey;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst value = other[configKey];\n\t\t\tif (value !== undefined) {\n\t\t\t\t_mergeEnvironmentValue(parent, actualKey, value);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tObject.keys(other).forEach((key) => {\n\t\t\tconst value = other[key];\n\t\t\tif (value !== undefined) {\n\t\t\t\t_mergeEnvironmentValue(parent, key, value);\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction _mergeEnvironmentValue(env: ITerminalEnvironment, key: string, value: string | null): void {\n\tif (isString(value)) {\n\t\tenv[key] = value;\n\t} else {\n\t\tdelete env[key];\n\t}\n}\n\nexport function addTerminalEnvironmentKeys(env: IProcessEnvironment, version: string | undefined, locale: string | undefined, detectLocale: 'auto' | 'off' | 'on'): void {\n\tenv['TERM_PROGRAM'] = 'vscode';\n\tif (version) {\n\t\tenv['TERM_PROGRAM_VERSION'] = version;\n\t}\n\tif (shouldSetLangEnvVariable(env, detectLocale)) {\n\t\tenv['LANG'] = getLangEnvVariable(locale);\n\t}\n\tenv['COLORTERM'] = 'truecolor';\n}\n\nfunction mergeNonNullKeys(env: IProcessEnvironment, other: ITerminalEnvironment | undefined) {\n\tif (!other) {\n\t\treturn;\n\t}\n\tfor (const key of Object.keys(other)) {\n\t\tconst value = other[key];\n\t\tif (value !== undefined && value !== null) {\n\t\t\tenv[key] = value;\n\t\t}\n\t}\n}\n\nasync function resolveConfigurationVariables(variableResolver: VariableResolver, env: ITerminalEnvironment): Promise<ITerminalEnvironment> {\n\tawait Promise.all(Object.entries(env).map(async ([key, value]) => {\n\t\tif (isString(value)) {\n\t\t\ttry {\n\t\t\t\tenv[key] = await variableResolver(value);\n\t\t\t} catch (e) {\n\t\t\t\tenv[key] = value;\n\t\t\t}\n\t\t}\n\t}));\n\n\treturn env;\n}\n\nexport function shouldSetLangEnvVariable(env: IProcessEnvironment, detectLocale: 'auto' | 'off' | 'on'): boolean {\n\tif (detectLocale === 'on') {\n\t\treturn true;\n\t}\n\tif (detectLocale === 'auto') {\n\t\tconst lang = env['LANG'];\n\t\treturn !lang || (lang.search(/\\.UTF\\-8$/) === -1 && lang.search(/\\.utf8$/) === -1 && lang.search(/\\.euc.+/) === -1);\n\t}\n\treturn false; // 'off'\n}\n\nexport function getLangEnvVariable(locale?: string): string {\n\tconst parts = locale ? locale.split('-') : [];\n\tconst n = parts.length;\n\tif (n === 0) {\n\t\t// Fallback to en_US if the locale is unknown\n\t\treturn 'en_US.UTF-8';\n\t}\n\tif (n === 1) {\n\t\t// The local may only contain the language, not the variant, if this is the case guess the\n\t\t// variant such that it can be used as a valid $LANG variable. The language variant chosen\n\t\t// is the original and/or most prominent with help from\n\t\t// https://stackoverflow.com/a/2502675/1156119\n\t\t// The list of locales was generated by running `locale -a` on macOS\n\t\tconst languageVariants: { [key: string]: string } = {\n\t\t\taf: 'ZA',\n\t\t\tam: 'ET',\n\t\t\tbe: 'BY',\n\t\t\tbg: 'BG',\n\t\t\tca: 'ES',\n\t\t\tcs: 'CZ',\n\t\t\tda: 'DK',\n\t\t\t// de: 'AT',\n\t\t\t// de: 'CH',\n\t\t\tde: 'DE',\n\t\t\tel: 'GR',\n\t\t\t// en: 'AU',\n\t\t\t// en: 'CA',\n\t\t\t// en: 'GB',\n\t\t\t// en: 'IE',\n\t\t\t// en: 'NZ',\n\t\t\ten: 'US',\n\t\t\tes: 'ES',\n\t\t\tet: 'EE',\n\t\t\teu: 'ES',\n\t\t\tfi: 'FI',\n\t\t\t// fr: 'BE',\n\t\t\t// fr: 'CA',\n\t\t\t// fr: 'CH',\n\t\t\tfr: 'FR',\n\t\t\the: 'IL',\n\t\t\thr: 'HR',\n\t\t\thu: 'HU',\n\t\t\thy: 'AM',\n\t\t\tis: 'IS',\n\t\t\t// it: 'CH',\n\t\t\tit: 'IT',\n\t\t\tja: 'JP',\n\t\t\tkk: 'KZ',\n\t\t\tko: 'KR',\n\t\t\tlt: 'LT',\n\t\t\t// nl: 'BE',\n\t\t\tnl: 'NL',\n\t\t\tno: 'NO',\n\t\t\tpl: 'PL',\n\t\t\tpt: 'BR',\n\t\t\t// pt: 'PT',\n\t\t\tro: 'RO',\n\t\t\tru: 'RU',\n\t\t\tsk: 'SK',\n\t\t\tsl: 'SI',\n\t\t\tsr: 'YU',\n\t\t\tsv: 'SE',\n\t\t\ttr: 'TR',\n\t\t\tuk: 'UA',\n\t\t\tzh: 'CN',\n\t\t};\n\t\tif (Object.prototype.hasOwnProperty.call(languageVariants, parts[0])) {\n\t\t\tparts.push(languageVariants[parts[0]]);\n\t\t}\n\t} else {\n\t\t// Ensure the variant is uppercase to be a valid $LANG\n\t\tparts[1] = parts[1].toUpperCase();\n\t}\n\treturn parts.join('_') + '.UTF-8';\n}\n\nexport async function getCwd(\n\tshell: IShellLaunchConfig,\n\tuserHome: string | undefined,\n\tvariableResolver: VariableResolver | undefined,\n\troot: URI | undefined,\n\tcustomCwd: string | undefined,\n\tlogService?: ILogService\n): Promise<string> {\n\tif (shell.cwd) {\n\t\tconst unresolved = (typeof shell.cwd === 'object') ? shell.cwd.fsPath : shell.cwd;\n\t\tconst resolved = await _resolveCwd(unresolved, variableResolver);\n\t\treturn sanitizeCwd(resolved || unresolved);\n\t}\n\n\tlet cwd: string | undefined;\n\n\tif (!shell.ignoreConfigurationCwd && customCwd) {\n\t\tif (variableResolver) {\n\t\t\tcustomCwd = await _resolveCwd(customCwd, variableResolver, logService);\n\t\t}\n\t\tif (customCwd) {\n\t\t\tif (path.isAbsolute(customCwd)) {\n\t\t\t\tcwd = customCwd;\n\t\t\t} else if (root) {\n\t\t\t\tcwd = path.join(root.fsPath, customCwd);\n\t\t\t}\n\t\t}\n\t}\n\n\t// If there was no custom cwd or it was relative with no workspace\n\tif (!cwd) {\n\t\tcwd = root ? root.fsPath : userHome || '';\n\t}\n\n\treturn sanitizeCwd(cwd);\n}\n\nasync function _resolveCwd(cwd: string, variableResolver: VariableResolver | undefined, logService?: ILogService): Promise<string | undefined> {\n\tif (variableResolver) {\n\t\ttry {\n\t\t\treturn await variableResolver(cwd);\n\t\t} catch (e) {\n\t\t\tlogService?.error('Could not resolve terminal cwd', e);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\treturn cwd;\n}\n\nexport type VariableResolver = (str: string) => Promise<string>;\n\nexport function createVariableResolver(lastActiveWorkspace: IWorkspaceFolder | undefined, env: IProcessEnvironment, configurationResolverService: IConfigurationResolverService | undefined): VariableResolver | undefined {\n\tif (!configurationResolverService) {\n\t\treturn undefined;\n\t}\n\treturn (str) => configurationResolverService.resolveWithEnvironment(env, lastActiveWorkspace, str);\n}\n\nexport async function createTerminalEnvironment(\n\tshellLaunchConfig: IShellLaunchConfig,\n\tenvFromConfig: ITerminalEnvironment | undefined,\n\tvariableResolver: VariableResolver | undefined,\n\tversion: string | undefined,\n\tdetectLocale: 'auto' | 'off' | 'on',\n\tbaseEnv: IProcessEnvironment\n): Promise<IProcessEnvironment> {\n\t// Create a terminal environment based on settings, launch config and permissions\n\tconst env: IProcessEnvironment = {};\n\tif (shellLaunchConfig.strictEnv) {\n\t\t// strictEnv is true, only use the requested env (ignoring null entries)\n\t\tmergeNonNullKeys(env, shellLaunchConfig.env);\n\t} else {\n\t\t// Merge process env with the env from config and from shellLaunchConfig\n\t\tmergeNonNullKeys(env, baseEnv);\n\n\t\tconst allowedEnvFromConfig = { ...envFromConfig };\n\n\t\t// Resolve env vars from config and shell\n\t\tif (variableResolver) {\n\t\t\tif (allowedEnvFromConfig) {\n\t\t\t\tawait resolveConfigurationVariables(variableResolver, allowedEnvFromConfig);\n\t\t\t}\n\t\t\tif (shellLaunchConfig.env) {\n\t\t\t\tawait resolveConfigurationVariables(variableResolver, shellLaunchConfig.env);\n\t\t\t}\n\t\t}\n\n\t\t// Workaround for https://github.com/microsoft/vscode/issues/204005\n\t\t// We should restore the following environment variables when a user\n\t\t// launches the application using the CLI so that integrated terminal\n\t\t// can still inherit these variables.\n\t\t// We are not bypassing the restrictions implied in https://github.com/electron/electron/pull/40770\n\t\t// since this only affects integrated terminal and not the application itself.\n\t\tif (isMacintosh) {\n\t\t\t// Restore NODE_OPTIONS if it was set\n\t\t\tif (env['VSCODE_NODE_OPTIONS']) {\n\t\t\t\tenv['NODE_OPTIONS'] = env['VSCODE_NODE_OPTIONS'];\n\t\t\t\tdelete env['VSCODE_NODE_OPTIONS'];\n\t\t\t}\n\n\t\t\t// Restore NODE_REPL_EXTERNAL_MODULE if it was set\n\t\t\tif (env['VSCODE_NODE_REPL_EXTERNAL_MODULE']) {\n\t\t\t\tenv['NODE_REPL_EXTERNAL_MODULE'] = env['VSCODE_NODE_REPL_EXTERNAL_MODULE'];\n\t\t\t\tdelete env['VSCODE_NODE_REPL_EXTERNAL_MODULE'];\n\t\t\t}\n\t\t}\n\n\t\t// Sanitize the environment, removing any undesirable VS Code and Electron environment\n\t\t// variables\n\t\tsanitizeProcessEnvironment(env, 'VSCODE_IPC_HOOK_CLI');\n\n\t\t// Merge config (settings) and ShellLaunchConfig environments\n\t\tmergeEnvironments(env, allowedEnvFromConfig);\n\t\tmergeEnvironments(env, shellLaunchConfig.env);\n\n\t\t// Adding other env keys necessary to create the process\n\t\taddTerminalEnvironmentKeys(env, version, language, detectLocale);\n\t}\n\treturn env;\n}\n\n/**\n * Takes a path and returns the properly escaped path to send to a given shell. On Windows, this\n * included trying to prepare the path for WSL if needed.\n *\n * @param originalPath The path to be escaped and formatted.\n * @param executable The executable off the shellLaunchConfig.\n * @param title The terminal's title.\n * @param shellType The type of shell the path is being sent to.\n * @param backend The backend for the terminal.\n * @param isWindowsFrontend Whether the frontend is Windows, this is only exposed for injection via\n * tests.\n * @returns An escaped version of the path to be executed in the terminal.\n */\nexport async function preparePathForShell(resource: string | URI, executable: string | undefined, title: string, shellType: TerminalShellType | undefined, backend: Pick<ITerminalBackend, 'getWslPath'> | undefined, os: OperatingSystem | undefined, isWindowsFrontend: boolean = isWindows): Promise<string> {\n\tlet originalPath: string;\n\tif (isString(resource)) {\n\t\toriginalPath = resource;\n\t} else {\n\t\toriginalPath = resource.fsPath;\n\t\t// Apply backend OS-specific formatting to the path since URI.fsPath uses the frontend's OS\n\t\tif (isWindowsFrontend && os !== OperatingSystem.Windows) {\n\t\t\toriginalPath = originalPath.replace(/\\\\/g, '\\/');\n\t\t} else if (!isWindowsFrontend && os === OperatingSystem.Windows) {\n\t\t\toriginalPath = originalPath.replace(/\\//g, '\\\\');\n\t\t}\n\t}\n\n\tif (!executable) {\n\t\treturn originalPath;\n\t}\n\n\tconst hasSpace = originalPath.includes(' ');\n\tconst hasParens = originalPath.includes('(') || originalPath.includes(')');\n\n\tconst pathBasename = path.basename(executable, '.exe');\n\tconst isPowerShell = pathBasename === 'pwsh' ||\n\t\ttitle === 'pwsh' ||\n\t\tpathBasename === 'powershell' ||\n\t\ttitle === 'powershell';\n\n\tif (isPowerShell && (hasSpace || originalPath.includes('\\''))) {\n\t\treturn `& '${originalPath.replace(/'/g, '\\'\\'')}'`;\n\t}\n\n\tif (hasParens && isPowerShell) {\n\t\treturn `& '${originalPath}'`;\n\t}\n\n\tif (os === OperatingSystem.Windows) {\n\t\t// 17063 is the build number where wsl path was introduced.\n\t\t// Update Windows uriPath to be executed in WSL.\n\t\tif (shellType !== undefined) {\n\t\t\tif (shellType === WindowsShellType.GitBash) {\n\t\t\t\treturn escapeNonWindowsPath(originalPath.replace(/\\\\/g, '/'), shellType);\n\t\t\t}\n\t\t\telse if (shellType === WindowsShellType.Wsl) {\n\t\t\t\treturn backend?.getWslPath(originalPath, 'win-to-unix') || originalPath;\n\t\t\t}\n\t\t\telse if (hasSpace) {\n\t\t\t\treturn `\"${originalPath}\"`;\n\t\t\t}\n\t\t\treturn originalPath;\n\t\t}\n\t\tconst lowerExecutable = executable.toLowerCase();\n\t\tif (lowerExecutable.includes('wsl') || (lowerExecutable.includes('bash.exe') && !lowerExecutable.toLowerCase().includes('git'))) {\n\t\t\treturn backend?.getWslPath(originalPath, 'win-to-unix') || originalPath;\n\t\t} else if (hasSpace) {\n\t\t\treturn `\"${originalPath}\"`;\n\t\t}\n\t\treturn originalPath;\n\t}\n\n\treturn escapeNonWindowsPath(originalPath, shellType);\n}\n\nexport function getWorkspaceForTerminal(cwd: URI | string | undefined, workspaceContextService: IWorkspaceContextService, historyService: IHistoryService): IWorkspaceFolder | undefined {\n\tconst cwdUri = isString(cwd) ? URI.parse(cwd) : cwd;\n\tlet workspaceFolder = cwdUri ? workspaceContextService.getWorkspaceFolder(cwdUri) ?? undefined : undefined;\n\tif (!workspaceFolder) {\n\t\t// fallback to last active workspace if cwd is not available or it is not in workspace\n\t\t// TOOD: last active workspace is known to be unreliable, we should remove this fallback eventually\n\t\tconst activeWorkspaceRootUri = historyService.getLastActiveWorkspaceRoot();\n\t\tworkspaceFolder = activeWorkspaceRootUri ? workspaceContextService.getWorkspaceFolder(activeWorkspaceRootUri) ?? undefined : undefined;\n\t}\n\treturn workspaceFolder;\n}\n\nexport async function getUriLabelForShell(uri: URI | string, backend: Pick<ITerminalBackend, 'getWslPath'>, shellType?: TerminalShellType, os?: OperatingSystem, isWindowsFrontend: boolean = isWindows): Promise<string> {\n\tlet path = isString(uri) ? uri : uri.fsPath;\n\tif (os === OperatingSystem.Windows) {\n\t\tif (shellType === WindowsShellType.Wsl) {\n\t\t\treturn backend.getWslPath(path.replaceAll('/', '\\\\'), 'win-to-unix');\n\t\t} else if (shellType === WindowsShellType.GitBash) {\n\t\t\t// Convert \\ to / and replace 'c:\\' with '/c/'.\n\t\t\treturn path.replaceAll('\\\\', '/').replace(/^([a-zA-Z]):\\//, '/$1/');\n\t\t} else {\n\t\t\t// If the frontend is not Windows but the terminal is, convert / to \\.\n\t\t\tpath = isString(uri) ? path : uriToFsPath(uri, true);\n\t\t\treturn !isWindowsFrontend ? path.replaceAll('/', '\\\\') : path;\n\t\t}\n\t} else {\n\t\t// If the frontend is Windows but the terminal is not, convert \\ to /.\n\t\treturn isWindowsFrontend ? path.replaceAll('\\\\', '/') : path;\n\t}\n}\n\n/**\n * Gets the unified duration to wait for shell integration after the terminal launches before\n * declaring the terminal lacks shell integration.\n */\nexport function getShellIntegrationTimeout(\n\tconfigurationService: IConfigurationService,\n\tsiInjectionEnabled: boolean,\n\tisRemote: boolean,\n\tprocessReadyTimestamp?: number\n): number {\n\tconst timeoutValue = configurationService.getValue<unknown>(TerminalSettingId.ShellIntegrationTimeout);\n\tlet timeoutMs: number;\n\n\tif (!isNumber(timeoutValue) || timeoutValue < 0) {\n\t\ttimeoutMs = siInjectionEnabled ? 5000 : (isRemote ? 3000 : 2000);\n\t} else {\n\t\ttimeoutMs = Math.max(timeoutValue, 500);\n\t}\n\n\t// Adjust timeout based on how long the process has already been running\n\tif (processReadyTimestamp !== undefined) {\n\t\tconst elapsed = Date.now() - processReadyTimestamp;\n\t\ttimeoutMs = Math.max(0, timeoutMs - elapsed);\n\t}\n\n\treturn timeoutMs;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * This module contains utility functions related to the environment, cwd and paths.\n */\n\nimport * as path from '../../../../base/common/path.js';\nimport { URI, uriToFsPath } from '../../../../base/common/uri.js';\nimport { IWorkspaceContextService, IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { IConfigurationResolverService } from '../../../services/configurationResolver/common/configurationResolver.js';\nimport { sanitizeProcessEnvironment } from '../../../../base/common/processes.js';\nimport { IShellLaunchConfig, ITerminalBackend, ITerminalEnvironment, TerminalSettingId, TerminalShellType, WindowsShellType } from '../../../../platform/terminal/common/terminal.js';\nimport { IProcessEnvironment, isWindows, isMacintosh, language, OperatingSystem } from '../../../../base/common/platform.js';\nimport { escapeNonWindowsPath, sanitizeCwd } from '../../../../platform/terminal/common/terminalEnvironment.js';\nimport { isNumber, isString } from '../../../../base/common/types.js';\nimport { IHistoryService } from '../../../services/history/common/history.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport type { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\n\nexport function mergeEnvironments(parent: IProcessEnvironment, other: ITerminalEnvironment | undefined): void {\n\tif (!other) {\n\t\treturn;\n\t}\n\n\t// On Windows apply the new values ignoring case, while still retaining\n\t// the case of the original key.\n\tif (isWindows) {\n\t\tfor (const configKey in other) {\n\t\t\tlet actualKey = configKey;\n\t\t\tfor (const envKey in parent) {\n\t\t\t\tif (configKey.toLowerCase() === envKey.toLowerCase()) {\n\t\t\t\t\tactualKey = envKey;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst value = other[configKey];\n\t\t\tif (value !== undefined) {\n\t\t\t\t_mergeEnvironmentValue(parent, actualKey, value);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tObject.keys(other).forEach((key) => {\n\t\t\tconst value = other[key];\n\t\t\tif (value !== undefined) {\n\t\t\t\t_mergeEnvironmentValue(parent, key, value);\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction _mergeEnvironmentValue(env: ITerminalEnvironment, key: string, value: string | null): void {\n\tif (isString(value)) {\n\t\tenv[key] = value;\n\t} else {\n\t\tdelete env[key];\n\t}\n}\n\nexport function addTerminalEnvironmentKeys(env: IProcessEnvironment, version: string | undefined, locale: string | undefined, detectLocale: 'auto' | 'off' | 'on'): void {\n\tenv['TERM_PROGRAM'] = 'vscode';\n\tif (version) {\n\t\tenv['TERM_PROGRAM_VERSION'] = version;\n\t}\n\tif (shouldSetLangEnvVariable(env, detectLocale)) {\n\t\tenv['LANG'] = getLangEnvVariable(locale);\n\t}\n\tenv['COLORTERM'] = 'truecolor';\n}\n\nfunction mergeNonNullKeys(env: IProcessEnvironment, other: ITerminalEnvironment | undefined) {\n\tif (!other) {\n\t\treturn;\n\t}\n\tfor (const key of Object.keys(other)) {\n\t\tconst value = other[key];\n\t\tif (value !== undefined && value !== null) {\n\t\t\tenv[key] = value;\n\t\t}\n\t}\n}\n\nasync function resolveConfigurationVariables(variableResolver: VariableResolver, env: ITerminalEnvironment): Promise<ITerminalEnvironment> {\n\tawait Promise.all(Object.entries(env).map(async ([key, value]) => {\n\t\tif (isString(value)) {\n\t\t\ttry {\n\t\t\t\tenv[key] = await variableResolver(value);\n\t\t\t} catch (e) {\n\t\t\t\tenv[key] = value;\n\t\t\t}\n\t\t}\n\t}));\n\n\treturn env;\n}\n\nexport function shouldSetLangEnvVariable(env: IProcessEnvironment, detectLocale: 'auto' | 'off' | 'on'): boolean {\n\tif (detectLocale === 'on') {\n\t\treturn true;\n\t}\n\tif (detectLocale === 'auto') {\n\t\tconst lang = env['LANG'];\n\t\treturn !lang || (lang.search(/\\.UTF\\-8$/) === -1 && lang.search(/\\.utf8$/) === -1 && lang.search(/\\.euc.+/) === -1);\n\t}\n\treturn false; // 'off'\n}\n\nexport function getLangEnvVariable(locale?: string): string {\n\tconst parts = locale ? locale.split('-') : [];\n\tconst n = parts.length;\n\tif (n === 0) {\n\t\t// Fallback to en_US if the locale is unknown\n\t\treturn 'en_US.UTF-8';\n\t}\n\tif (n === 1) {\n\t\t// The local may only contain the language, not the variant, if this is the case guess the\n\t\t// variant such that it can be used as a valid $LANG variable. The language variant chosen\n\t\t// is the original and/or most prominent with help from\n\t\t// https://stackoverflow.com/a/2502675/1156119\n\t\t// The list of locales was generated by running `locale -a` on macOS\n\t\tconst languageVariants: { [key: string]: string } = {\n\t\t\taf: 'ZA',\n\t\t\tam: 'ET',\n\t\t\tbe: 'BY',\n\t\t\tbg: 'BG',\n\t\t\tca: 'ES',\n\t\t\tcs: 'CZ',\n\t\t\tda: 'DK',\n\t\t\t// de: 'AT',\n\t\t\t// de: 'CH',\n\t\t\tde: 'DE',\n\t\t\tel: 'GR',\n\t\t\t// en: 'AU',\n\t\t\t// en: 'CA',\n\t\t\t// en: 'GB',\n\t\t\t// en: 'IE',\n\t\t\t// en: 'NZ',\n\t\t\ten: 'US',\n\t\t\tes: 'ES',\n\t\t\tet: 'EE',\n\t\t\teu: 'ES',\n\t\t\tfi: 'FI',\n\t\t\t// fr: 'BE',\n\t\t\t// fr: 'CA',\n\t\t\t// fr: 'CH',\n\t\t\tfr: 'FR',\n\t\t\the: 'IL',\n\t\t\thr: 'HR',\n\t\t\thu: 'HU',\n\t\t\thy: 'AM',\n\t\t\tis: 'IS',\n\t\t\t// it: 'CH',\n\t\t\tit: 'IT',\n\t\t\tja: 'JP',\n\t\t\tkk: 'KZ',\n\t\t\tko: 'KR',\n\t\t\tlt: 'LT',\n\t\t\t// nl: 'BE',\n\t\t\tnl: 'NL',\n\t\t\tno: 'NO',\n\t\t\tpl: 'PL',\n\t\t\tpt: 'BR',\n\t\t\t// pt: 'PT',\n\t\t\tro: 'RO',\n\t\t\tru: 'RU',\n\t\t\tsk: 'SK',\n\t\t\tsl: 'SI',\n\t\t\tsr: 'YU',\n\t\t\tsv: 'SE',\n\t\t\ttr: 'TR',\n\t\t\tuk: 'UA',\n\t\t\tzh: 'CN',\n\t\t};\n\t\tif (Object.prototype.hasOwnProperty.call(languageVariants, parts[0])) {\n\t\t\tparts.push(languageVariants[parts[0]]);\n\t\t}\n\t} else {\n\t\t// Ensure the variant is uppercase to be a valid $LANG\n\t\tparts[1] = parts[1].toUpperCase();\n\t}\n\treturn parts.join('_') + '.UTF-8';\n}\n\nexport async function getCwd(\n\tshell: IShellLaunchConfig,\n\tuserHome: string | undefined,\n\tvariableResolver: VariableResolver | undefined,\n\troot: URI | undefined,\n\tcustomCwd: string | undefined,\n\tlogService?: ILogService\n): Promise<string> {\n\tif (shell.cwd) {\n\t\tconst unresolved = (typeof shell.cwd === 'object') ? shell.cwd.fsPath : shell.cwd;\n\t\tconst resolved = await _resolveCwd(unresolved, variableResolver);\n\t\treturn sanitizeCwd(resolved || unresolved);\n\t}\n\n\tlet cwd: string | undefined;\n\n\tif (!shell.ignoreConfigurationCwd && customCwd) {\n\t\tif (variableResolver) {\n\t\t\tcustomCwd = await _resolveCwd(customCwd, variableResolver, logService);\n\t\t}\n\t\tif (customCwd) {\n\t\t\tif (path.isAbsolute(customCwd)) {\n\t\t\t\tcwd = customCwd;\n\t\t\t} else if (root) {\n\t\t\t\tcwd = path.join(root.fsPath, customCwd);\n\t\t\t}\n\t\t}\n\t}\n\n\t// If there was no custom cwd or it was relative with no workspace\n\tif (!cwd) {\n\t\tcwd = root ? root.fsPath : userHome || '';\n\t}\n\n\treturn sanitizeCwd(cwd);\n}\n\nasync function _resolveCwd(cwd: string, variableResolver: VariableResolver | undefined, logService?: ILogService): Promise<string | undefined> {\n\tif (variableResolver) {\n\t\ttry {\n\t\t\treturn await variableResolver(cwd);\n\t\t} catch (e) {\n\t\t\tlogService?.error('Could not resolve terminal cwd', e);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\treturn cwd;\n}\n\nexport type VariableResolver = (str: string) => Promise<string>;\n\nexport function createVariableResolver(lastActiveWorkspace: IWorkspaceFolder | undefined, env: IProcessEnvironment, configurationResolverService: IConfigurationResolverService | undefined): VariableResolver | undefined {\n\tif (!configurationResolverService) {\n\t\treturn undefined;\n\t}\n\treturn (str) => configurationResolverService.resolveWithEnvironment(env, lastActiveWorkspace, str);\n}\n\nexport async function createTerminalEnvironment(\n\tshellLaunchConfig: IShellLaunchConfig,\n\tenvFromConfig: ITerminalEnvironment | undefined,\n\tvariableResolver: VariableResolver | undefined,\n\tversion: string | undefined,\n\tdetectLocale: 'auto' | 'off' | 'on',\n\tbaseEnv: IProcessEnvironment\n): Promise<IProcessEnvironment> {\n\t// Create a terminal environment based on settings, launch config and permissions\n\tconst env: IProcessEnvironment = {};\n\tif (shellLaunchConfig.strictEnv) {\n\t\t// strictEnv is true, only use the requested env (ignoring null entries)\n\t\tmergeNonNullKeys(env, shellLaunchConfig.env);\n\t} else {\n\t\t// Merge process env with the env from config and from shellLaunchConfig\n\t\tmergeNonNullKeys(env, baseEnv);\n\n\t\tconst allowedEnvFromConfig = { ...envFromConfig };\n\n\t\t// Resolve env vars from config and shell\n\t\tif (variableResolver) {\n\t\t\tif (allowedEnvFromConfig) {\n\t\t\t\tawait resolveConfigurationVariables(variableResolver, allowedEnvFromConfig);\n\t\t\t}\n\t\t\tif (shellLaunchConfig.env) {\n\t\t\t\tawait resolveConfigurationVariables(variableResolver, shellLaunchConfig.env);\n\t\t\t}\n\t\t}\n\n\t\t// Workaround for https://github.com/microsoft/vscode/issues/204005\n\t\t// We should restore the following environment variables when a user\n\t\t// launches the application using the CLI so that integrated terminal\n\t\t// can still inherit these variables.\n\t\t// We are not bypassing the restrictions implied in https://github.com/electron/electron/pull/40770\n\t\t// since this only affects integrated terminal and not the application itself.\n\t\tif (isMacintosh) {\n\t\t\t// Restore NODE_OPTIONS if it was set\n\t\t\tif (env['VSCODE_NODE_OPTIONS']) {\n\t\t\t\tenv['NODE_OPTIONS'] = env['VSCODE_NODE_OPTIONS'];\n\t\t\t\tdelete env['VSCODE_NODE_OPTIONS'];\n\t\t\t}\n\n\t\t\t// Restore NODE_REPL_EXTERNAL_MODULE if it was set\n\t\t\tif (env['VSCODE_NODE_REPL_EXTERNAL_MODULE']) {\n\t\t\t\tenv['NODE_REPL_EXTERNAL_MODULE'] = env['VSCODE_NODE_REPL_EXTERNAL_MODULE'];\n\t\t\t\tdelete env['VSCODE_NODE_REPL_EXTERNAL_MODULE'];\n\t\t\t}\n\t\t}\n\n\t\t// Sanitize the environment, removing any undesirable VS Code and Electron environment\n\t\t// variables\n\t\tsanitizeProcessEnvironment(env, 'VSCODE_IPC_HOOK_CLI');\n\n\t\t// Merge config (settings) and ShellLaunchConfig environments\n\t\tmergeEnvironments(env, allowedEnvFromConfig);\n\t\tmergeEnvironments(env, shellLaunchConfig.env);\n\n\t\t// Adding other env keys necessary to create the process\n\t\taddTerminalEnvironmentKeys(env, version, language, detectLocale);\n\t}\n\treturn env;\n}\n\n/**\n * Takes a path and returns the properly escaped path to send to a given shell. On Windows, this\n * included trying to prepare the path for WSL if needed.\n *\n * @param originalPath The path to be escaped and formatted.\n * @param executable The executable off the shellLaunchConfig.\n * @param title The terminal's title.\n * @param shellType The type of shell the path is being sent to.\n * @param backend The backend for the terminal.\n * @param isWindowsFrontend Whether the frontend is Windows, this is only exposed for injection via\n * tests.\n * @returns An escaped version of the path to be executed in the terminal.\n */\nexport async function preparePathForShell(resource: string | URI, executable: string | undefined, title: string, shellType: TerminalShellType | undefined, backend: Pick<ITerminalBackend, 'getWslPath'> | undefined, os: OperatingSystem | undefined, isWindowsFrontend: boolean = isWindows): Promise<string> {\n\tlet originalPath: string;\n\tif (isString(resource)) {\n\t\toriginalPath = resource;\n\t} else {\n\t\toriginalPath = resource.fsPath;\n\t\t// Apply backend OS-specific formatting to the path since URI.fsPath uses the frontend's OS\n\t\tif (isWindowsFrontend && os !== OperatingSystem.Windows) {\n\t\t\toriginalPath = originalPath.replace(/\\\\/g, '\\/');\n\t\t} else if (!isWindowsFrontend && os === OperatingSystem.Windows) {\n\t\t\toriginalPath = originalPath.replace(/\\//g, '\\\\');\n\t\t}\n\t}\n\n\tif (!executable) {\n\t\treturn originalPath;\n\t}\n\n\tconst hasSpace = originalPath.includes(' ');\n\tconst hasParens = originalPath.includes('(') || originalPath.includes(')');\n\n\tconst pathBasename = path.basename(executable, '.exe');\n\tconst isPowerShell = pathBasename === 'pwsh' ||\n\t\ttitle === 'pwsh' ||\n\t\tpathBasename === 'powershell' ||\n\t\ttitle === 'powershell';\n\n\tif (isPowerShell && (hasSpace || originalPath.includes('\\''))) {\n\t\treturn `& '${originalPath.replace(/'/g, '\\'\\'')}'`;\n\t}\n\n\tif (hasParens && isPowerShell) {\n\t\treturn `& '${originalPath}'`;\n\t}\n\n\tif (os === OperatingSystem.Windows) {\n\t\t// 17063 is the build number where wsl path was introduced.\n\t\t// Update Windows uriPath to be executed in WSL.\n\t\tif (shellType !== undefined) {\n\t\t\tif (shellType === WindowsShellType.GitBash) {\n\t\t\t\treturn escapeNonWindowsPath(originalPath.replace(/\\\\/g, '/'), shellType);\n\t\t\t}\n\t\t\telse if (shellType === WindowsShellType.Wsl) {\n\t\t\t\treturn backend?.getWslPath(originalPath, 'win-to-unix') || originalPath;\n\t\t\t}\n\t\t\telse if (hasSpace) {\n\t\t\t\treturn `\"${originalPath}\"`;\n\t\t\t}\n\t\t\treturn originalPath;\n\t\t}\n\t\tconst lowerExecutable = executable.toLowerCase();\n\t\tif (lowerExecutable.includes('wsl') || (lowerExecutable.includes('bash.exe') && !lowerExecutable.toLowerCase().includes('git'))) {\n\t\t\treturn backend?.getWslPath(originalPath, 'win-to-unix') || originalPath;\n\t\t} else if (hasSpace) {\n\t\t\treturn `\"${originalPath}\"`;\n\t\t}\n\t\treturn originalPath;\n\t}\n\n\treturn escapeNonWindowsPath(originalPath, shellType);\n}\n\nexport function getWorkspaceForTerminal(cwd: URI | string | undefined, workspaceContextService: IWorkspaceContextService, historyService: IHistoryService): IWorkspaceFolder | undefined {\n\tconst cwdUri = isString(cwd) ? URI.parse(cwd) : cwd;\n\tlet workspaceFolder = cwdUri ? workspaceContextService.getWorkspaceFolder(cwdUri) ?? undefined : undefined;\n\tif (!workspaceFolder) {\n\t\t// fallback to last active workspace if cwd is not available or it is not in workspace\n\t\t// TOOD: last active workspace is known to be unreliable, we should remove this fallback eventually\n\t\tconst activeWorkspaceRootUri = historyService.getLastActiveWorkspaceRoot();\n\t\tworkspaceFolder = activeWorkspaceRootUri ? workspaceContextService.getWorkspaceFolder(activeWorkspaceRootUri) ?? undefined : undefined;\n\t}\n\treturn workspaceFolder;\n}\n\nexport async function getUriLabelForShell(uri: URI | string, backend: Pick<ITerminalBackend, 'getWslPath'>, shellType?: TerminalShellType, os?: OperatingSystem, isWindowsFrontend: boolean = isWindows): Promise<string> {\n\tlet path = isString(uri) ? uri : uri.fsPath;\n\tif (os === OperatingSystem.Windows) {\n\t\tif (shellType === WindowsShellType.Wsl) {\n\t\t\treturn backend.getWslPath(path.replaceAll('/', '\\\\'), 'win-to-unix');\n\t\t} else if (shellType === WindowsShellType.GitBash) {\n\t\t\t// Convert \\ to / and replace 'c:\\' with '/c/'.\n\t\t\treturn path.replaceAll('\\\\', '/').replace(/^([a-zA-Z]):\\//, '/$1/');\n\t\t} else {\n\t\t\t// If the frontend is not Windows but the terminal is, convert / to \\.\n\t\t\tpath = isString(uri) ? path : uriToFsPath(uri, true);\n\t\t\treturn !isWindowsFrontend ? path.replaceAll('/', '\\\\') : path;\n\t\t}\n\t} else {\n\t\t// If the frontend is Windows but the terminal is not, convert \\ to /.\n\t\treturn isWindowsFrontend ? path.replaceAll('\\\\', '/') : path;\n\t}\n}\n\n/**\n * Gets the unified duration to wait for shell integration after the terminal launches before\n * declaring the terminal lacks shell integration.\n */\nexport function getShellIntegrationTimeout(\n\tconfigurationService: IConfigurationService,\n\tsiInjectionEnabled: boolean,\n\tisRemote: boolean,\n\tprocessReadyTimestamp?: number\n): number {\n\tconst timeoutValue = configurationService.getValue<unknown>(TerminalSettingId.ShellIntegrationTimeout);\n\tlet timeoutMs: number;\n\n\tif (!isNumber(timeoutValue) || timeoutValue < 0) {\n\t\ttimeoutMs = siInjectionEnabled ? 5000 : (isRemote ? 3000 : 2000);\n\t} else {\n\t\ttimeoutMs = Math.max(timeoutValue, 500);\n\t}\n\n\t// Adjust timeout based on how long the process has already been running\n\tif (processReadyTimestamp !== undefined) {\n\t\tconst elapsed = Date.now() - processReadyTimestamp;\n\t\ttimeoutMs = Math.max(0, timeoutMs - elapsed);\n\t}\n\n\treturn timeoutMs;\n}\n"]}