{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/history/common/history.ts","vs/workbench/contrib/terminalContrib/history/common/history.ts"],"names":[],"mappings":"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","file":"history.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { LRUCache } from '../../../../../base/common/map.js';\nimport { Schemas } from '../../../../../base/common/network.js';\nimport { join } from '../../../../../base/common/path.js';\nimport { isWindows, OperatingSystem } from '../../../../../base/common/platform.js';\nimport { env } from '../../../../../base/common/process.js';\nimport { isNumber } from '../../../../../base/common/types.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { FileOperationError, FileOperationResult, IFileContent, IFileService } from '../../../../../platform/files/common/files.js';\nimport { IInstantiationService, ServicesAccessor } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../../platform/storage/common/storage.js';\nimport { GeneralShellType, PosixShellType, TerminalShellType } from '../../../../../platform/terminal/common/terminal.js';\nimport { IRemoteAgentService } from '../../../../services/remote/common/remoteAgentService.js';\nimport { TerminalHistorySettingId } from './terminal.history.js';\n\n/**\n * Tracks a list of generic entries.\n */\nexport interface ITerminalPersistedHistory<T> {\n\t/**\n\t * The persisted entries.\n\t */\n\treadonly entries: IterableIterator<[string, T]>;\n\t/**\n\t * Adds an entry.\n\t */\n\tadd(key: string, value: T): void;\n\t/**\n\t * Removes an entry.\n\t */\n\tremove(key: string): void;\n\t/**\n\t * Clears all entries.\n\t */\n\tclear(): void;\n}\n\ninterface ISerializedCache<T> {\n\tentries: { key: string; value: T }[];\n}\n\nconst enum Constants {\n\tDefaultHistoryLimit = 100\n}\n\nconst enum StorageKeys {\n\tEntries = 'terminal.history.entries',\n\tTimestamp = 'terminal.history.timestamp'\n}\n\nlet directoryHistory: ITerminalPersistedHistory<{ remoteAuthority?: string }> | undefined = undefined;\nexport function getDirectoryHistory(accessor: ServicesAccessor): ITerminalPersistedHistory<{ remoteAuthority?: string }> {\n\tif (!directoryHistory) {\n\t\tdirectoryHistory = accessor.get(IInstantiationService).createInstance(TerminalPersistedHistory, 'dirs') as TerminalPersistedHistory<{ remoteAuthority?: string }>;\n\t}\n\treturn directoryHistory;\n}\n\nlet commandHistory: ITerminalPersistedHistory<{ shellType: TerminalShellType }> | undefined = undefined;\nexport function getCommandHistory(accessor: ServicesAccessor): ITerminalPersistedHistory<{ shellType: TerminalShellType | undefined }> {\n\tif (!commandHistory) {\n\t\tcommandHistory = accessor.get(IInstantiationService).createInstance(TerminalPersistedHistory, 'commands') as TerminalPersistedHistory<{ shellType: TerminalShellType }>;\n\t}\n\treturn commandHistory;\n}\n\nexport class TerminalPersistedHistory<T> extends Disposable implements ITerminalPersistedHistory<T> {\n\tprivate readonly _entries: LRUCache<string, T>;\n\tprivate _timestamp: number = 0;\n\tprivate _isReady = false;\n\tprivate _isStale = true;\n\n\tget entries(): IterableIterator<[string, T]> {\n\t\tthis._ensureUpToDate();\n\t\treturn this._entries.entries();\n\t}\n\n\tconstructor(\n\t\tprivate readonly _storageDataKey: string,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t) {\n\t\tsuper();\n\n\t\t// Init cache\n\t\tthis._entries = new LRUCache<string, T>(this._getHistoryLimit());\n\n\t\t// Listen for config changes to set history limit\n\t\tthis._register(this._configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration(TerminalHistorySettingId.ShellIntegrationCommandHistory)) {\n\t\t\t\tthis._entries.limit = this._getHistoryLimit();\n\t\t\t}\n\t\t}));\n\n\t\t// Listen to cache changes from other windows\n\t\tthis._register(this._storageService.onDidChangeValue(StorageScope.APPLICATION, this._getTimestampStorageKey(), this._store)(() => {\n\t\t\tif (!this._isStale) {\n\t\t\t\tthis._isStale = this._storageService.getNumber(this._getTimestampStorageKey(), StorageScope.APPLICATION, 0) !== this._timestamp;\n\t\t\t}\n\t\t}));\n\t}\n\n\tadd(key: string, value: T) {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.set(key, value);\n\t\tthis._saveState();\n\t}\n\n\tremove(key: string) {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.delete(key);\n\t\tthis._saveState();\n\t}\n\n\tclear() {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.clear();\n\t\tthis._saveState();\n\t}\n\n\tprivate _ensureUpToDate() {\n\t\t// Initial load\n\t\tif (!this._isReady) {\n\t\t\tthis._loadState();\n\t\t\tthis._isReady = true;\n\t\t}\n\n\t\t// React to stale cache caused by another window\n\t\tif (this._isStale) {\n\t\t\t// Since state is saved whenever the entries change, it's a safe assumption that no\n\t\t\t// merging of entries needs to happen, just loading the new state.\n\t\t\tthis._entries.clear();\n\t\t\tthis._loadState();\n\t\t\tthis._isStale = false;\n\t\t}\n\t}\n\n\tprivate _loadState() {\n\t\tthis._timestamp = this._storageService.getNumber(this._getTimestampStorageKey(), StorageScope.APPLICATION, 0);\n\n\t\t// Load global entries plus\n\t\tconst serialized = this._loadPersistedState();\n\t\tif (serialized) {\n\t\t\tfor (const entry of serialized.entries) {\n\t\t\t\tthis._entries.set(entry.key, entry.value);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _loadPersistedState(): ISerializedCache<T> | undefined {\n\t\tconst raw = this._storageService.get(this._getEntriesStorageKey(), StorageScope.APPLICATION);\n\t\tif (raw === undefined || raw.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet serialized: ISerializedCache<T> | undefined = undefined;\n\t\ttry {\n\t\t\tserialized = JSON.parse(raw);\n\t\t} catch {\n\t\t\t// Invalid data\n\t\t\treturn undefined;\n\t\t}\n\t\treturn serialized;\n\t}\n\n\tprivate _saveState() {\n\t\tconst serialized: ISerializedCache<T> = { entries: [] };\n\t\tthis._entries.forEach((value, key) => serialized.entries.push({ key, value }));\n\t\tthis._storageService.store(this._getEntriesStorageKey(), JSON.stringify(serialized), StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\tthis._timestamp = Date.now();\n\t\tthis._storageService.store(this._getTimestampStorageKey(), this._timestamp, StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t}\n\n\tprivate _getHistoryLimit() {\n\t\tconst historyLimit = this._configurationService.getValue(TerminalHistorySettingId.ShellIntegrationCommandHistory);\n\t\treturn isNumber(historyLimit) ? historyLimit : Constants.DefaultHistoryLimit;\n\t}\n\n\tprivate _getTimestampStorageKey() {\n\t\treturn `${StorageKeys.Timestamp}.${this._storageDataKey}`;\n\t}\n\n\tprivate _getEntriesStorageKey() {\n\t\treturn `${StorageKeys.Entries}.${this._storageDataKey}`;\n\t}\n}\n\n// Shell file history loads once per shell per window\ninterface IShellFileHistoryEntry {\n\tsourceLabel: string;\n\tsourceResource: URI;\n\tcommands: string[];\n}\nconst shellFileHistory: Map<TerminalShellType | undefined, IShellFileHistoryEntry | null> = new Map();\nexport async function getShellFileHistory(accessor: ServicesAccessor, shellType: TerminalShellType | undefined): Promise<IShellFileHistoryEntry | undefined> {\n\tconst cached = shellFileHistory.get(shellType);\n\tif (cached === null) {\n\t\treturn undefined;\n\t}\n\tif (cached !== undefined) {\n\t\treturn cached;\n\t}\n\tlet result: IShellFileHistoryEntry | undefined;\n\tswitch (shellType) {\n\t\tcase PosixShellType.Bash:\n\t\t\tresult = await fetchBashHistory(accessor);\n\t\t\tbreak;\n\t\tcase GeneralShellType.PowerShell:\n\t\t\tresult = await fetchPwshHistory(accessor);\n\t\t\tbreak;\n\t\tcase PosixShellType.Zsh:\n\t\t\tresult = await fetchZshHistory(accessor);\n\t\t\tbreak;\n\t\tcase PosixShellType.Fish:\n\t\t\tresult = await fetchFishHistory(accessor);\n\t\t\tbreak;\n\t\tcase GeneralShellType.Python:\n\t\t\tresult = await fetchPythonHistory(accessor);\n\t\t\tbreak;\n\t\tdefault: return undefined;\n\t}\n\tif (result === undefined) {\n\t\tshellFileHistory.set(shellType, null);\n\t\treturn undefined;\n\t}\n\tshellFileHistory.set(shellType, result);\n\treturn result;\n}\nexport function clearShellFileHistory() {\n\tshellFileHistory.clear();\n}\n\nexport async function fetchBashHistory(accessor: ServicesAccessor): Promise<IShellFileHistoryEntry | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows) {\n\t\treturn undefined;\n\t}\n\tconst sourceLabel = '~/.bash_history';\n\tconst resolvedFile = await fetchFileContents(env['HOME'], '.bash_history', false, fileService, remoteAgentService);\n\tif (resolvedFile === undefined) {\n\t\treturn undefined;\n\t}\n\t// .bash_history does not differentiate wrapped commands from multiple commands. Parse\n\t// the output to get the\n\tconst fileLines = resolvedFile.content.split('\\n');\n\tconst result: Set<string> = new Set();\n\tlet currentLine: string;\n\tlet currentCommand: string | undefined = undefined;\n\tlet wrapChar: string | undefined = undefined;\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tcurrentLine = fileLines[i];\n\t\tif (currentCommand === undefined) {\n\t\t\tcurrentCommand = currentLine;\n\t\t} else {\n\t\t\tcurrentCommand += `\\n${currentLine}`;\n\t\t}\n\t\tfor (let c = 0; c < currentLine.length; c++) {\n\t\t\tif (wrapChar) {\n\t\t\t\tif (currentLine[c] === wrapChar) {\n\t\t\t\t\twrapChar = undefined;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentLine[c].match(/['\"]/)) {\n\t\t\t\t\twrapChar = currentLine[c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (wrapChar === undefined) {\n\t\t\tif (currentCommand.length > 0) {\n\t\t\t\tresult.add(currentCommand.trim());\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t}\n\t}\n\n\treturn {\n\t\tsourceLabel,\n\t\tsourceResource: resolvedFile.resource,\n\t\tcommands: Array.from(result.values())\n\t};\n}\n\nexport async function fetchZshHistory(accessor: ServicesAccessor): Promise<IShellFileHistoryEntry | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows) {\n\t\treturn undefined;\n\t}\n\n\tconst sourceLabel = '~/.zsh_history';\n\tconst resolvedFile = await fetchFileContents(env['HOME'], '.zsh_history', false, fileService, remoteAgentService);\n\tif (resolvedFile === undefined) {\n\t\treturn undefined;\n\t}\n\tconst isExtendedHistory = /^:\\s\\d+:\\d+;/.test(resolvedFile.content);\n\tconst fileLines = resolvedFile.content.split(isExtendedHistory ? /\\:\\s\\d+\\:\\d+;/ : /(?<!\\\\)\\n/);\n\tconst result: Set<string> = new Set();\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tconst sanitized = fileLines[i].replace(/\\\\\\n/g, '\\n').trim();\n\t\tif (sanitized.length > 0) {\n\t\t\tresult.add(sanitized);\n\t\t}\n\t}\n\treturn {\n\t\tsourceLabel,\n\t\tsourceResource: resolvedFile.resource,\n\t\tcommands: Array.from(result.values())\n\t};\n}\n\n\nexport async function fetchPythonHistory(accessor: ServicesAccessor): Promise<IShellFileHistoryEntry | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\n\tconst sourceLabel = '~/.python_history';\n\tconst resolvedFile = await fetchFileContents(env['HOME'], '.python_history', false, fileService, remoteAgentService);\n\n\tif (resolvedFile === undefined) {\n\t\treturn undefined;\n\t}\n\n\t// Python history file is a simple text file with one command per line\n\tconst fileLines = resolvedFile.content.split('\\n');\n\tconst result: Set<string> = new Set();\n\n\tfileLines.forEach(line => {\n\t\tif (line.trim().length > 0) {\n\t\t\tresult.add(line.trim());\n\t\t}\n\t});\n\n\treturn {\n\t\tsourceLabel,\n\t\tsourceResource: resolvedFile.resource,\n\t\tcommands: Array.from(result.values())\n\t};\n}\n\nexport async function fetchPwshHistory(accessor: ServicesAccessor): Promise<IShellFileHistoryEntry | undefined> {\n\tconst fileService: Pick<IFileService, 'readFile'> = accessor.get(IFileService);\n\tconst remoteAgentService: Pick<IRemoteAgentService, 'getConnection' | 'getEnvironment'> = accessor.get(IRemoteAgentService);\n\tlet folderPrefix: string | undefined;\n\tlet filePath: string;\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tconst isFileWindows = remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows;\n\tlet sourceLabel: string;\n\tif (isFileWindows) {\n\t\tfolderPrefix = env['APPDATA'];\n\t\tfilePath = 'Microsoft\\\\Windows\\\\PowerShell\\\\PSReadLine\\\\ConsoleHost_history.txt';\n\t\tsourceLabel = `$APPDATA\\\\Microsoft\\\\Windows\\\\PowerShell\\\\PSReadLine\\\\ConsoleHost_history.txt`;\n\t} else {\n\t\tfolderPrefix = env['HOME'];\n\t\tfilePath = '.local/share/powershell/PSReadline/ConsoleHost_history.txt';\n\t\tsourceLabel = `~/${filePath}`;\n\t}\n\tconst resolvedFile = await fetchFileContents(folderPrefix, filePath, isFileWindows, fileService, remoteAgentService);\n\tif (resolvedFile === undefined) {\n\t\treturn undefined;\n\t}\n\tconst fileLines = resolvedFile.content.split('\\n');\n\tconst result: Set<string> = new Set();\n\tlet currentLine: string;\n\tlet currentCommand: string | undefined = undefined;\n\tlet wrapChar: string | undefined = undefined;\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tcurrentLine = fileLines[i];\n\t\tif (currentCommand === undefined) {\n\t\t\tcurrentCommand = currentLine;\n\t\t} else {\n\t\t\tcurrentCommand += `\\n${currentLine}`;\n\t\t}\n\t\tif (!currentLine.endsWith('`')) {\n\t\t\tconst sanitized = currentCommand.trim();\n\t\t\tif (sanitized.length > 0) {\n\t\t\t\tresult.add(sanitized);\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t\tcontinue;\n\t\t}\n\t\t// If the line ends with `, the line may be wrapped. Need to also test the case where ` is\n\t\t// the last character in the line\n\t\tfor (let c = 0; c < currentLine.length; c++) {\n\t\t\tif (wrapChar) {\n\t\t\t\tif (currentLine[c] === wrapChar) {\n\t\t\t\t\twrapChar = undefined;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentLine[c].match(/`/)) {\n\t\t\t\t\twrapChar = currentLine[c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Having an even number of backticks means the line is terminated\n\t\t// TODO: This doesn't cover more complicated cases where ` is within quotes\n\t\tif (!wrapChar) {\n\t\t\tconst sanitized = currentCommand.trim();\n\t\t\tif (sanitized.length > 0) {\n\t\t\t\tresult.add(sanitized);\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t} else {\n\t\t\t// Remove trailing backtick\n\t\t\tcurrentCommand = currentCommand.replace(/`$/, '');\n\t\t\twrapChar = undefined;\n\t\t}\n\t}\n\n\treturn {\n\t\tsourceLabel,\n\t\tsourceResource: resolvedFile.resource,\n\t\tcommands: Array.from(result.values())\n\t};\n}\n\nexport async function fetchFishHistory(accessor: ServicesAccessor): Promise<IShellFileHistoryEntry | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows) {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * From `fish` docs:\n\t * > The command history is stored in the file ~/.local/share/fish/fish_history\n\t *   (or $XDG_DATA_HOME/fish/fish_history if that variable is set) by default.\n\t *\n\t * (https://fishshell.com/docs/current/interactive.html#history-search)\n\t */\n\tconst overridenDataHome = env['XDG_DATA_HOME'];\n\n\t// TODO: Unchecked fish behavior:\n\t// What if XDG_DATA_HOME was defined but somehow $XDG_DATA_HOME/fish/fish_history\n\t// was not exist. Does fish fall back to ~/.local/share/fish/fish_history?\n\n\tlet folderPrefix: string | undefined;\n\tlet filePath: string;\n\tlet sourceLabel: string;\n\tif (overridenDataHome) {\n\t\tsourceLabel = '$XDG_DATA_HOME/fish/fish_history';\n\t\tfolderPrefix = env['XDG_DATA_HOME'];\n\t\tfilePath = 'fish/fish_history';\n\t} else {\n\t\tsourceLabel = '~/.local/share/fish/fish_history';\n\t\tfolderPrefix = env['HOME'];\n\t\tfilePath = '.local/share/fish/fish_history';\n\t}\n\tconst resolvedFile = await fetchFileContents(folderPrefix, filePath, false, fileService, remoteAgentService);\n\tif (resolvedFile === undefined) {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * These apply to `fish` v3.5.1:\n\t * - It looks like YAML but it's not. It's, quoting, *\"a broken psuedo-YAML\"*.\n\t *   See these discussions for more details:\n\t *   - https://github.com/fish-shell/fish-shell/pull/6493\n\t *   - https://github.com/fish-shell/fish-shell/issues/3341\n\t * - Every record should exactly start with `- cmd:` (the whitespace between `-` and `cmd` cannot be replaced with tab)\n\t * - Both `- cmd: echo 1` and `- cmd:echo 1` are valid entries.\n\t * - Backslashes are esacped as `\\\\`.\n\t * - Multiline commands are joined with a `\\n` sequence, hence they're read as single line commands.\n\t * - Property `when` is optional.\n\t * - History navigation respects the records order and ignore the actual `when` property values (chronological order).\n\t * - If `cmd` value is multiline , it just takes the first line. Also YAML operators like `>-` or `|-` are not supported.\n\t */\n\tconst result: Set<string> = new Set();\n\tconst cmds = resolvedFile.content.split('\\n')\n\t\t.filter(x => x.startsWith('- cmd:'))\n\t\t.map(x => x.substring(6).trimStart());\n\tfor (let i = 0; i < cmds.length; i++) {\n\t\tconst sanitized = sanitizeFishHistoryCmd(cmds[i]).trim();\n\t\tif (sanitized.length > 0) {\n\t\t\tresult.add(sanitized);\n\t\t}\n\t}\n\treturn {\n\t\tsourceLabel,\n\t\tsourceResource: resolvedFile.resource,\n\t\tcommands: Array.from(result.values())\n\t};\n}\n\nexport function sanitizeFishHistoryCmd(cmd: string): string {\n\t/**\n\t * NOTE\n\t * This repeatedReplace() call can be eliminated by using look-ahead\n\t * caluses in the original RegExp pattern:\n\t *\n\t * >>> ```ts\n\t * >>> cmds[i].replace(/(?<=^|[^\\\\])((?:\\\\\\\\)*)(\\\\n)/g, '$1\\n')\n\t * >>> ```\n\t *\n\t * But since not all browsers support look aheads we opted to a simple\n\t * pattern and repeatedly calling replace method.\n\t */\n\treturn repeatedReplace(/(^|[^\\\\])((?:\\\\\\\\)*)(\\\\n)/g, cmd, '$1$2\\n');\n}\n\nfunction repeatedReplace(pattern: RegExp, value: string, replaceValue: string): string {\n\tlet last;\n\tlet current = value;\n\twhile (true) {\n\t\tlast = current;\n\t\tcurrent = current.replace(pattern, replaceValue);\n\t\tif (current === last) {\n\t\t\treturn current;\n\t\t}\n\t}\n}\n\nasync function fetchFileContents(\n\tfolderPrefix: string | undefined,\n\tfilePath: string,\n\tisFileWindows: boolean,\n\tfileService: Pick<IFileService, 'readFile'>,\n\tremoteAgentService: Pick<IRemoteAgentService, 'getConnection'>,\n): Promise<{ resource: URI; content: string } | undefined> {\n\tif (!folderPrefix) {\n\t\treturn undefined;\n\t}\n\tconst connection = remoteAgentService.getConnection();\n\tconst isRemote = !!connection?.remoteAuthority;\n\tconst resource = URI.from({\n\t\tscheme: isRemote ? Schemas.vscodeRemote : Schemas.file,\n\t\tauthority: isRemote ? connection.remoteAuthority : undefined,\n\t\tpath: URI.file(join(folderPrefix, filePath)).path\n\t});\n\tlet content: IFileContent;\n\ttry {\n\t\tcontent = await fileService.readFile(resource);\n\t} catch (e: unknown) {\n\t\t// Handle file not found only\n\t\tif (e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_NOT_FOUND) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthrow e;\n\t}\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\treturn {\n\t\tresource,\n\t\tcontent: content.value.toString()\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { LRUCache } from '../../../../../base/common/map.js';\nimport { Schemas } from '../../../../../base/common/network.js';\nimport { join } from '../../../../../base/common/path.js';\nimport { isWindows, OperatingSystem } from '../../../../../base/common/platform.js';\nimport { env } from '../../../../../base/common/process.js';\nimport { isNumber } from '../../../../../base/common/types.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { FileOperationError, FileOperationResult, IFileContent, IFileService } from '../../../../../platform/files/common/files.js';\nimport { IInstantiationService, ServicesAccessor } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../../platform/storage/common/storage.js';\nimport { GeneralShellType, PosixShellType, TerminalShellType } from '../../../../../platform/terminal/common/terminal.js';\nimport { IRemoteAgentService } from '../../../../services/remote/common/remoteAgentService.js';\nimport { TerminalHistorySettingId } from './terminal.history.js';\n\n/**\n * Tracks a list of generic entries.\n */\nexport interface ITerminalPersistedHistory<T> {\n\t/**\n\t * The persisted entries.\n\t */\n\treadonly entries: IterableIterator<[string, T]>;\n\t/**\n\t * Adds an entry.\n\t */\n\tadd(key: string, value: T): void;\n\t/**\n\t * Removes an entry.\n\t */\n\tremove(key: string): void;\n\t/**\n\t * Clears all entries.\n\t */\n\tclear(): void;\n}\n\ninterface ISerializedCache<T> {\n\tentries: { key: string; value: T }[];\n}\n\nconst enum Constants {\n\tDefaultHistoryLimit = 100\n}\n\nconst enum StorageKeys {\n\tEntries = 'terminal.history.entries',\n\tTimestamp = 'terminal.history.timestamp'\n}\n\nlet directoryHistory: ITerminalPersistedHistory<{ remoteAuthority?: string }> | undefined = undefined;\nexport function getDirectoryHistory(accessor: ServicesAccessor): ITerminalPersistedHistory<{ remoteAuthority?: string }> {\n\tif (!directoryHistory) {\n\t\tdirectoryHistory = accessor.get(IInstantiationService).createInstance(TerminalPersistedHistory, 'dirs') as TerminalPersistedHistory<{ remoteAuthority?: string }>;\n\t}\n\treturn directoryHistory;\n}\n\nlet commandHistory: ITerminalPersistedHistory<{ shellType: TerminalShellType }> | undefined = undefined;\nexport function getCommandHistory(accessor: ServicesAccessor): ITerminalPersistedHistory<{ shellType: TerminalShellType | undefined }> {\n\tif (!commandHistory) {\n\t\tcommandHistory = accessor.get(IInstantiationService).createInstance(TerminalPersistedHistory, 'commands') as TerminalPersistedHistory<{ shellType: TerminalShellType }>;\n\t}\n\treturn commandHistory;\n}\n\nexport class TerminalPersistedHistory<T> extends Disposable implements ITerminalPersistedHistory<T> {\n\tprivate readonly _entries: LRUCache<string, T>;\n\tprivate _timestamp: number = 0;\n\tprivate _isReady = false;\n\tprivate _isStale = true;\n\n\tget entries(): IterableIterator<[string, T]> {\n\t\tthis._ensureUpToDate();\n\t\treturn this._entries.entries();\n\t}\n\n\tconstructor(\n\t\tprivate readonly _storageDataKey: string,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t) {\n\t\tsuper();\n\n\t\t// Init cache\n\t\tthis._entries = new LRUCache<string, T>(this._getHistoryLimit());\n\n\t\t// Listen for config changes to set history limit\n\t\tthis._register(this._configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration(TerminalHistorySettingId.ShellIntegrationCommandHistory)) {\n\t\t\t\tthis._entries.limit = this._getHistoryLimit();\n\t\t\t}\n\t\t}));\n\n\t\t// Listen to cache changes from other windows\n\t\tthis._register(this._storageService.onDidChangeValue(StorageScope.APPLICATION, this._getTimestampStorageKey(), this._store)(() => {\n\t\t\tif (!this._isStale) {\n\t\t\t\tthis._isStale = this._storageService.getNumber(this._getTimestampStorageKey(), StorageScope.APPLICATION, 0) !== this._timestamp;\n\t\t\t}\n\t\t}));\n\t}\n\n\tadd(key: string, value: T) {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.set(key, value);\n\t\tthis._saveState();\n\t}\n\n\tremove(key: string) {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.delete(key);\n\t\tthis._saveState();\n\t}\n\n\tclear() {\n\t\tthis._ensureUpToDate();\n\t\tthis._entries.clear();\n\t\tthis._saveState();\n\t}\n\n\tprivate _ensureUpToDate() {\n\t\t// Initial load\n\t\tif (!this._isReady) {\n\t\t\tthis._loadState();\n\t\t\tthis._isReady = true;\n\t\t}\n\n\t\t// React to stale cache caused by another window\n\t\tif (this._isStale) {\n\t\t\t// Since state is saved whenever the entries change, it's a safe assumption that no\n\t\t\t// merging of entries needs to happen, just loading the new state.\n\t\t\tthis._entries.clear();\n\t\t\tthis._loadState();\n\t\t\tthis._isStale = false;\n\t\t}\n\t}\n\n\tprivate _loadState() {\n\t\tthis._timestamp = this._storageService.getNumber(this._getTimestampStorageKey(), StorageScope.APPLICATION, 0);\n\n\t\t// Load global entries plus\n\t\tconst serialized = this._loadPersistedState();\n\t\tif (serialized) {\n\t\t\tfor (const entry of serialized.entries) {\n\t\t\t\tthis._entries.set(entry.key, entry.value);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _loadPersistedState(): ISerializedCache<T> | undefined {\n\t\tconst raw = this._storageService.get(this._getEntriesStorageKey(), StorageScope.APPLICATION);\n\t\tif (raw === undefined || raw.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet serialized: ISerializedCache<T> | undefined = undefined;\n\t\ttry {\n\t\t\tserialized = JSON.parse(raw);\n\t\t} catch {\n\t\t\t// Invalid data\n\t\t\treturn undefined;\n\t\t}\n\t\treturn serialized;\n\t}\n\n\tprivate _saveState() {\n\t\tconst serialized: ISerializedCache<T> = { entries: [] };\n\t\tthis._entries.forEach((value, key) => serialized.entries.push({ key, value }));\n\t\tthis._storageService.store(this._getEntriesStorageKey(), JSON.stringify(serialized), StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\tthis._timestamp = Date.now();\n\t\tthis._storageService.store(this._getTimestampStorageKey(), this._timestamp, StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t}\n\n\tprivate _getHistoryLimit() {\n\t\tconst historyLimit = this._configurationService.getValue(TerminalHistorySettingId.ShellIntegrationCommandHistory);\n\t\treturn isNumber(historyLimit) ? historyLimit : Constants.DefaultHistoryLimit;\n\t}\n\n\tprivate _getTimestampStorageKey() {\n\t\treturn `${StorageKeys.Timestamp}.${this._storageDataKey}`;\n\t}\n\n\tprivate _getEntriesStorageKey() {\n\t\treturn `${StorageKeys.Entries}.${this._storageDataKey}`;\n\t}\n}\n\n// Shell file history loads once per shell per window\ninterface IShellFileHistoryEntry {\n\tsourceLabel: string;\n\tsourceResource: URI;\n\tcommands: string[];\n}\nconst shellFileHistory: Map<TerminalShellType | undefined, IShellFileHistoryEntry | null> = new Map();\nexport async function getShellFileHistory(accessor: ServicesAccessor, shellType: TerminalShellType | undefined): Promise<IShellFileHistoryEntry | undefined> {\n\tconst cached = shellFileHistory.get(shellType);\n\tif (cached === null) {\n\t\treturn undefined;\n\t}\n\tif (cached !== undefined) {\n\t\treturn cached;\n\t}\n\tlet result: IShellFileHistoryEntry | undefined;\n\tswitch (shellType) {\n\t\tcase PosixShellType.Bash:\n\t\t\tresult = await fetchBashHistory(accessor);\n\t\t\tbreak;\n\t\tcase GeneralShellType.PowerShell:\n\t\t\tresult = await fetchPwshHistory(accessor);\n\t\t\tbreak;\n\t\tcase PosixShellType.Zsh:\n\t\t\tresult = await fetchZshHistory(accessor);\n\t\t\tbreak;\n\t\tcase PosixShellType.Fish:\n\t\t\tresult = await fetchFishHistory(accessor);\n\t\t\tbreak;\n\t\tcase GeneralShellType.Python:\n\t\t\tresult = await fetchPythonHistory(accessor);\n\t\t\tbreak;\n\t\tdefault: return undefined;\n\t}\n\tif (result === undefined) {\n\t\tshellFileHistory.set(shellType, null);\n\t\treturn undefined;\n\t}\n\tshellFileHistory.set(shellType, result);\n\treturn result;\n}\nexport function clearShellFileHistory() {\n\tshellFileHistory.clear();\n}\n\nexport async function fetchBashHistory(accessor: ServicesAccessor): Promise<IShellFileHistoryEntry | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows) {\n\t\treturn undefined;\n\t}\n\tconst sourceLabel = '~/.bash_history';\n\tconst resolvedFile = await fetchFileContents(env['HOME'], '.bash_history', false, fileService, remoteAgentService);\n\tif (resolvedFile === undefined) {\n\t\treturn undefined;\n\t}\n\t// .bash_history does not differentiate wrapped commands from multiple commands. Parse\n\t// the output to get the\n\tconst fileLines = resolvedFile.content.split('\\n');\n\tconst result: Set<string> = new Set();\n\tlet currentLine: string;\n\tlet currentCommand: string | undefined = undefined;\n\tlet wrapChar: string | undefined = undefined;\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tcurrentLine = fileLines[i];\n\t\tif (currentCommand === undefined) {\n\t\t\tcurrentCommand = currentLine;\n\t\t} else {\n\t\t\tcurrentCommand += `\\n${currentLine}`;\n\t\t}\n\t\tfor (let c = 0; c < currentLine.length; c++) {\n\t\t\tif (wrapChar) {\n\t\t\t\tif (currentLine[c] === wrapChar) {\n\t\t\t\t\twrapChar = undefined;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentLine[c].match(/['\"]/)) {\n\t\t\t\t\twrapChar = currentLine[c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (wrapChar === undefined) {\n\t\t\tif (currentCommand.length > 0) {\n\t\t\t\tresult.add(currentCommand.trim());\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t}\n\t}\n\n\treturn {\n\t\tsourceLabel,\n\t\tsourceResource: resolvedFile.resource,\n\t\tcommands: Array.from(result.values())\n\t};\n}\n\nexport async function fetchZshHistory(accessor: ServicesAccessor): Promise<IShellFileHistoryEntry | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows) {\n\t\treturn undefined;\n\t}\n\n\tconst sourceLabel = '~/.zsh_history';\n\tconst resolvedFile = await fetchFileContents(env['HOME'], '.zsh_history', false, fileService, remoteAgentService);\n\tif (resolvedFile === undefined) {\n\t\treturn undefined;\n\t}\n\tconst isExtendedHistory = /^:\\s\\d+:\\d+;/.test(resolvedFile.content);\n\tconst fileLines = resolvedFile.content.split(isExtendedHistory ? /\\:\\s\\d+\\:\\d+;/ : /(?<!\\\\)\\n/);\n\tconst result: Set<string> = new Set();\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tconst sanitized = fileLines[i].replace(/\\\\\\n/g, '\\n').trim();\n\t\tif (sanitized.length > 0) {\n\t\t\tresult.add(sanitized);\n\t\t}\n\t}\n\treturn {\n\t\tsourceLabel,\n\t\tsourceResource: resolvedFile.resource,\n\t\tcommands: Array.from(result.values())\n\t};\n}\n\n\nexport async function fetchPythonHistory(accessor: ServicesAccessor): Promise<IShellFileHistoryEntry | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\n\tconst sourceLabel = '~/.python_history';\n\tconst resolvedFile = await fetchFileContents(env['HOME'], '.python_history', false, fileService, remoteAgentService);\n\n\tif (resolvedFile === undefined) {\n\t\treturn undefined;\n\t}\n\n\t// Python history file is a simple text file with one command per line\n\tconst fileLines = resolvedFile.content.split('\\n');\n\tconst result: Set<string> = new Set();\n\n\tfileLines.forEach(line => {\n\t\tif (line.trim().length > 0) {\n\t\t\tresult.add(line.trim());\n\t\t}\n\t});\n\n\treturn {\n\t\tsourceLabel,\n\t\tsourceResource: resolvedFile.resource,\n\t\tcommands: Array.from(result.values())\n\t};\n}\n\nexport async function fetchPwshHistory(accessor: ServicesAccessor): Promise<IShellFileHistoryEntry | undefined> {\n\tconst fileService: Pick<IFileService, 'readFile'> = accessor.get(IFileService);\n\tconst remoteAgentService: Pick<IRemoteAgentService, 'getConnection' | 'getEnvironment'> = accessor.get(IRemoteAgentService);\n\tlet folderPrefix: string | undefined;\n\tlet filePath: string;\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tconst isFileWindows = remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows;\n\tlet sourceLabel: string;\n\tif (isFileWindows) {\n\t\tfolderPrefix = env['APPDATA'];\n\t\tfilePath = 'Microsoft\\\\Windows\\\\PowerShell\\\\PSReadLine\\\\ConsoleHost_history.txt';\n\t\tsourceLabel = `$APPDATA\\\\Microsoft\\\\Windows\\\\PowerShell\\\\PSReadLine\\\\ConsoleHost_history.txt`;\n\t} else {\n\t\tfolderPrefix = env['HOME'];\n\t\tfilePath = '.local/share/powershell/PSReadline/ConsoleHost_history.txt';\n\t\tsourceLabel = `~/${filePath}`;\n\t}\n\tconst resolvedFile = await fetchFileContents(folderPrefix, filePath, isFileWindows, fileService, remoteAgentService);\n\tif (resolvedFile === undefined) {\n\t\treturn undefined;\n\t}\n\tconst fileLines = resolvedFile.content.split('\\n');\n\tconst result: Set<string> = new Set();\n\tlet currentLine: string;\n\tlet currentCommand: string | undefined = undefined;\n\tlet wrapChar: string | undefined = undefined;\n\tfor (let i = 0; i < fileLines.length; i++) {\n\t\tcurrentLine = fileLines[i];\n\t\tif (currentCommand === undefined) {\n\t\t\tcurrentCommand = currentLine;\n\t\t} else {\n\t\t\tcurrentCommand += `\\n${currentLine}`;\n\t\t}\n\t\tif (!currentLine.endsWith('`')) {\n\t\t\tconst sanitized = currentCommand.trim();\n\t\t\tif (sanitized.length > 0) {\n\t\t\t\tresult.add(sanitized);\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t\tcontinue;\n\t\t}\n\t\t// If the line ends with `, the line may be wrapped. Need to also test the case where ` is\n\t\t// the last character in the line\n\t\tfor (let c = 0; c < currentLine.length; c++) {\n\t\t\tif (wrapChar) {\n\t\t\t\tif (currentLine[c] === wrapChar) {\n\t\t\t\t\twrapChar = undefined;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentLine[c].match(/`/)) {\n\t\t\t\t\twrapChar = currentLine[c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Having an even number of backticks means the line is terminated\n\t\t// TODO: This doesn't cover more complicated cases where ` is within quotes\n\t\tif (!wrapChar) {\n\t\t\tconst sanitized = currentCommand.trim();\n\t\t\tif (sanitized.length > 0) {\n\t\t\t\tresult.add(sanitized);\n\t\t\t}\n\t\t\tcurrentCommand = undefined;\n\t\t} else {\n\t\t\t// Remove trailing backtick\n\t\t\tcurrentCommand = currentCommand.replace(/`$/, '');\n\t\t\twrapChar = undefined;\n\t\t}\n\t}\n\n\treturn {\n\t\tsourceLabel,\n\t\tsourceResource: resolvedFile.resource,\n\t\tcommands: Array.from(result.values())\n\t};\n}\n\nexport async function fetchFishHistory(accessor: ServicesAccessor): Promise<IShellFileHistoryEntry | undefined> {\n\tconst fileService = accessor.get(IFileService);\n\tconst remoteAgentService = accessor.get(IRemoteAgentService);\n\tconst remoteEnvironment = await remoteAgentService.getEnvironment();\n\tif (remoteEnvironment?.os === OperatingSystem.Windows || !remoteEnvironment && isWindows) {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * From `fish` docs:\n\t * > The command history is stored in the file ~/.local/share/fish/fish_history\n\t *   (or $XDG_DATA_HOME/fish/fish_history if that variable is set) by default.\n\t *\n\t * (https://fishshell.com/docs/current/interactive.html#history-search)\n\t */\n\tconst overridenDataHome = env['XDG_DATA_HOME'];\n\n\t// TODO: Unchecked fish behavior:\n\t// What if XDG_DATA_HOME was defined but somehow $XDG_DATA_HOME/fish/fish_history\n\t// was not exist. Does fish fall back to ~/.local/share/fish/fish_history?\n\n\tlet folderPrefix: string | undefined;\n\tlet filePath: string;\n\tlet sourceLabel: string;\n\tif (overridenDataHome) {\n\t\tsourceLabel = '$XDG_DATA_HOME/fish/fish_history';\n\t\tfolderPrefix = env['XDG_DATA_HOME'];\n\t\tfilePath = 'fish/fish_history';\n\t} else {\n\t\tsourceLabel = '~/.local/share/fish/fish_history';\n\t\tfolderPrefix = env['HOME'];\n\t\tfilePath = '.local/share/fish/fish_history';\n\t}\n\tconst resolvedFile = await fetchFileContents(folderPrefix, filePath, false, fileService, remoteAgentService);\n\tif (resolvedFile === undefined) {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * These apply to `fish` v3.5.1:\n\t * - It looks like YAML but it's not. It's, quoting, *\"a broken psuedo-YAML\"*.\n\t *   See these discussions for more details:\n\t *   - https://github.com/fish-shell/fish-shell/pull/6493\n\t *   - https://github.com/fish-shell/fish-shell/issues/3341\n\t * - Every record should exactly start with `- cmd:` (the whitespace between `-` and `cmd` cannot be replaced with tab)\n\t * - Both `- cmd: echo 1` and `- cmd:echo 1` are valid entries.\n\t * - Backslashes are esacped as `\\\\`.\n\t * - Multiline commands are joined with a `\\n` sequence, hence they're read as single line commands.\n\t * - Property `when` is optional.\n\t * - History navigation respects the records order and ignore the actual `when` property values (chronological order).\n\t * - If `cmd` value is multiline , it just takes the first line. Also YAML operators like `>-` or `|-` are not supported.\n\t */\n\tconst result: Set<string> = new Set();\n\tconst cmds = resolvedFile.content.split('\\n')\n\t\t.filter(x => x.startsWith('- cmd:'))\n\t\t.map(x => x.substring(6).trimStart());\n\tfor (let i = 0; i < cmds.length; i++) {\n\t\tconst sanitized = sanitizeFishHistoryCmd(cmds[i]).trim();\n\t\tif (sanitized.length > 0) {\n\t\t\tresult.add(sanitized);\n\t\t}\n\t}\n\treturn {\n\t\tsourceLabel,\n\t\tsourceResource: resolvedFile.resource,\n\t\tcommands: Array.from(result.values())\n\t};\n}\n\nexport function sanitizeFishHistoryCmd(cmd: string): string {\n\t/**\n\t * NOTE\n\t * This repeatedReplace() call can be eliminated by using look-ahead\n\t * caluses in the original RegExp pattern:\n\t *\n\t * >>> ```ts\n\t * >>> cmds[i].replace(/(?<=^|[^\\\\])((?:\\\\\\\\)*)(\\\\n)/g, '$1\\n')\n\t * >>> ```\n\t *\n\t * But since not all browsers support look aheads we opted to a simple\n\t * pattern and repeatedly calling replace method.\n\t */\n\treturn repeatedReplace(/(^|[^\\\\])((?:\\\\\\\\)*)(\\\\n)/g, cmd, '$1$2\\n');\n}\n\nfunction repeatedReplace(pattern: RegExp, value: string, replaceValue: string): string {\n\tlet last;\n\tlet current = value;\n\twhile (true) {\n\t\tlast = current;\n\t\tcurrent = current.replace(pattern, replaceValue);\n\t\tif (current === last) {\n\t\t\treturn current;\n\t\t}\n\t}\n}\n\nasync function fetchFileContents(\n\tfolderPrefix: string | undefined,\n\tfilePath: string,\n\tisFileWindows: boolean,\n\tfileService: Pick<IFileService, 'readFile'>,\n\tremoteAgentService: Pick<IRemoteAgentService, 'getConnection'>,\n): Promise<{ resource: URI; content: string } | undefined> {\n\tif (!folderPrefix) {\n\t\treturn undefined;\n\t}\n\tconst connection = remoteAgentService.getConnection();\n\tconst isRemote = !!connection?.remoteAuthority;\n\tconst resource = URI.from({\n\t\tscheme: isRemote ? Schemas.vscodeRemote : Schemas.file,\n\t\tauthority: isRemote ? connection.remoteAuthority : undefined,\n\t\tpath: URI.file(join(folderPrefix, filePath)).path\n\t});\n\tlet content: IFileContent;\n\ttry {\n\t\tcontent = await fileService.readFile(resource);\n\t} catch (e: unknown) {\n\t\t// Handle file not found only\n\t\tif (e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_NOT_FOUND) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthrow e;\n\t}\n\tif (content === undefined) {\n\t\treturn undefined;\n\t}\n\treturn {\n\t\tresource,\n\t\tcontent: content.value.toString()\n\t};\n}\n"]}