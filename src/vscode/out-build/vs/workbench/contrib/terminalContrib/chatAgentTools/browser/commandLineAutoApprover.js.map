{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/chatAgentTools/browser/commandLineAutoApprover.ts","vs/workbench/contrib/terminalContrib/chatAgentTools/browser/commandLineAutoApprover.ts"],"names":[],"mappings":"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","file":"commandLineAutoApprover.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport type { OperatingSystem } from '../../../../../base/common/platform.js';\nimport { escapeRegExpCharacters, regExpLeadsToEndlessLoop } from '../../../../../base/common/strings.js';\nimport { isObject } from '../../../../../base/common/types.js';\nimport { structuralEquals } from '../../../../../base/common/equals.js';\nimport { ConfigurationTarget, IConfigurationService, type IConfigurationValue } from '../../../../../platform/configuration/common/configuration.js';\nimport { TerminalChatAgentToolsSettingId } from '../common/terminalChatAgentToolsConfiguration.js';\nimport { isPowerShell } from './runInTerminalHelpers.js';\n\nexport interface IAutoApproveRule {\n\tregex: RegExp;\n\tregexCaseInsensitive: RegExp;\n\tsourceText: string;\n\tsourceTarget: ConfigurationTarget;\n\tisDefaultRule: boolean;\n}\n\nexport interface ICommandApprovalResultWithReason {\n\tresult: ICommandApprovalResult;\n\treason: string;\n\trule?: IAutoApproveRule;\n}\n\nexport type ICommandApprovalResult = 'approved' | 'denied' | 'noMatch';\n\nconst neverMatchRegex = /(?!.*)/;\nconst transientEnvVarRegex = /^[A-Z_][A-Z0-9_]*=/i;\n\nexport class CommandLineAutoApprover extends Disposable {\n\tprivate _denyListRules: IAutoApproveRule[] = [];\n\tprivate _allowListRules: IAutoApproveRule[] = [];\n\tprivate _allowListCommandLineRules: IAutoApproveRule[] = [];\n\tprivate _denyListCommandLineRules: IAutoApproveRule[] = [];\n\n\tconstructor(\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t) {\n\t\tsuper();\n\t\tthis.updateConfiguration();\n\t\tthis._register(this._configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (\n\t\t\t\te.affectsConfiguration(TerminalChatAgentToolsSettingId.AutoApprove) ||\n\t\t\t\te.affectsConfiguration(TerminalChatAgentToolsSettingId.IgnoreDefaultAutoApproveRules) ||\n\t\t\t\te.affectsConfiguration(TerminalChatAgentToolsSettingId.DeprecatedAutoApproveCompatible)\n\t\t\t) {\n\t\t\t\tthis.updateConfiguration();\n\t\t\t}\n\t\t}));\n\t}\n\n\tupdateConfiguration() {\n\t\tlet configValue = this._configurationService.getValue(TerminalChatAgentToolsSettingId.AutoApprove);\n\t\tconst configInspectValue = this._configurationService.inspect(TerminalChatAgentToolsSettingId.AutoApprove);\n\t\tconst deprecatedValue = this._configurationService.getValue(TerminalChatAgentToolsSettingId.DeprecatedAutoApproveCompatible);\n\t\tif (deprecatedValue && typeof deprecatedValue === 'object' && configValue && typeof configValue === 'object') {\n\t\t\tconfigValue = {\n\t\t\t\t...configValue,\n\t\t\t\t...deprecatedValue\n\t\t\t};\n\t\t}\n\n\t\tconst {\n\t\t\tdenyListRules,\n\t\t\tallowListRules,\n\t\t\tallowListCommandLineRules,\n\t\t\tdenyListCommandLineRules\n\t\t} = this._mapAutoApproveConfigToRules(configValue, configInspectValue);\n\t\tthis._allowListRules = allowListRules;\n\t\tthis._denyListRules = denyListRules;\n\t\tthis._allowListCommandLineRules = allowListCommandLineRules;\n\t\tthis._denyListCommandLineRules = denyListCommandLineRules;\n\t}\n\n\tisCommandAutoApproved(command: string, shell: string, os: OperatingSystem): ICommandApprovalResultWithReason {\n\t\t// Check if the command has a transient environment variable assignment prefix which we\n\t\t// always deny for now as it can easily lead to execute other commands\n\t\tif (transientEnvVarRegex.test(command)) {\n\t\t\treturn {\n\t\t\t\tresult: 'denied',\n\t\t\t\treason: `Command '${command}' is denied because it contains transient environment variables`\n\t\t\t};\n\t\t}\n\n\t\t// Check the deny list to see if this command requires explicit approval\n\t\tfor (const rule of this._denyListRules) {\n\t\t\tif (this._commandMatchesRule(rule, command, shell, os)) {\n\t\t\t\treturn {\n\t\t\t\t\tresult: 'denied',\n\t\t\t\t\trule,\n\t\t\t\t\treason: `Command '${command}' is denied by deny list rule: ${rule.sourceText}`\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Check the allow list to see if the command is allowed to run without explicit approval\n\t\tfor (const rule of this._allowListRules) {\n\t\t\tif (this._commandMatchesRule(rule, command, shell, os)) {\n\t\t\t\treturn {\n\t\t\t\t\tresult: 'approved',\n\t\t\t\t\trule,\n\t\t\t\t\treason: `Command '${command}' is approved by allow list rule: ${rule.sourceText}`\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// TODO: LLM-based auto-approval https://github.com/microsoft/vscode/issues/253267\n\n\t\t// Fallback is always to require approval\n\t\treturn {\n\t\t\tresult: 'noMatch',\n\t\t\treason: `Command '${command}' has no matching auto approve entries`\n\t\t};\n\t}\n\n\tisCommandLineAutoApproved(commandLine: string): ICommandApprovalResultWithReason {\n\t\t// Check the deny list first to see if this command line requires explicit approval\n\t\tfor (const rule of this._denyListCommandLineRules) {\n\t\t\tif (rule.regex.test(commandLine)) {\n\t\t\t\treturn {\n\t\t\t\t\tresult: 'denied',\n\t\t\t\t\trule,\n\t\t\t\t\treason: `Command line '${commandLine}' is denied by deny list rule: ${rule.sourceText}`\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Check if the full command line matches any of the allow list command line regexes\n\t\tfor (const rule of this._allowListCommandLineRules) {\n\t\t\tif (rule.regex.test(commandLine)) {\n\t\t\t\treturn {\n\t\t\t\t\tresult: 'approved',\n\t\t\t\t\trule,\n\t\t\t\t\treason: `Command line '${commandLine}' is approved by allow list rule: ${rule.sourceText}`\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tresult: 'noMatch',\n\t\t\treason: `Command line '${commandLine}' has no matching auto approve entries`\n\t\t};\n\t}\n\n\tprivate _commandMatchesRule(rule: IAutoApproveRule, command: string, shell: string, os: OperatingSystem): boolean {\n\t\tconst isPwsh = isPowerShell(shell, os);\n\n\t\t// PowerShell is case insensitive regardless of platform\n\t\tif ((isPwsh ? rule.regexCaseInsensitive : rule.regex).test(command)) {\n\t\t\treturn true;\n\t\t} else if (isPwsh && command.startsWith('(')) {\n\t\t\t// Allow ignoring of the leading ( for PowerShell commands as it's a command pattern to\n\t\t\t// operate on the output of a command. For example `(Get-Content README.md) ...`\n\t\t\tif (rule.regexCaseInsensitive.test(command.slice(1))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _mapAutoApproveConfigToRules(config: unknown, configInspectValue: IConfigurationValue<Readonly<unknown>>): {\n\t\tdenyListRules: IAutoApproveRule[];\n\t\tallowListRules: IAutoApproveRule[];\n\t\tallowListCommandLineRules: IAutoApproveRule[];\n\t\tdenyListCommandLineRules: IAutoApproveRule[];\n\t} {\n\t\tif (!config || typeof config !== 'object') {\n\t\t\treturn {\n\t\t\t\tdenyListRules: [],\n\t\t\t\tallowListRules: [],\n\t\t\t\tallowListCommandLineRules: [],\n\t\t\t\tdenyListCommandLineRules: []\n\t\t\t};\n\t\t}\n\n\t\tconst denyListRules: IAutoApproveRule[] = [];\n\t\tconst allowListRules: IAutoApproveRule[] = [];\n\t\tconst allowListCommandLineRules: IAutoApproveRule[] = [];\n\t\tconst denyListCommandLineRules: IAutoApproveRule[] = [];\n\n\t\tconst ignoreDefaults = this._configurationService.getValue(TerminalChatAgentToolsSettingId.IgnoreDefaultAutoApproveRules) === true;\n\n\t\tfor (const [key, value] of Object.entries(config)) {\n\t\t\tconst defaultValue = configInspectValue?.default?.value;\n\t\t\tconst isDefaultRule = !!(\n\t\t\t\tisObject(defaultValue) &&\n\t\t\t\tObject.prototype.hasOwnProperty.call(defaultValue, key) &&\n\t\t\t\tstructuralEquals((defaultValue as Record<string, unknown>)[key], value)\n\t\t\t);\n\t\t\tfunction checkTarget(inspectValue: Readonly<unknown> | undefined): boolean {\n\t\t\t\treturn (\n\t\t\t\t\tisObject(inspectValue) &&\n\t\t\t\t\tObject.prototype.hasOwnProperty.call(inspectValue, key) &&\n\t\t\t\t\tstructuralEquals((inspectValue as Record<string, unknown>)[key], value)\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst sourceTarget = (\n\t\t\t\tcheckTarget(configInspectValue.workspaceFolder) ? ConfigurationTarget.WORKSPACE_FOLDER\n\t\t\t\t\t: checkTarget(configInspectValue.workspaceValue) ? ConfigurationTarget.WORKSPACE\n\t\t\t\t\t\t: checkTarget(configInspectValue.userRemoteValue) ? ConfigurationTarget.USER_REMOTE\n\t\t\t\t\t\t\t: checkTarget(configInspectValue.userLocalValue) ? ConfigurationTarget.USER_LOCAL\n\t\t\t\t\t\t\t\t: checkTarget(configInspectValue.userValue) ? ConfigurationTarget.USER\n\t\t\t\t\t\t\t\t\t: checkTarget(configInspectValue.applicationValue) ? ConfigurationTarget.APPLICATION\n\t\t\t\t\t\t\t\t\t\t: ConfigurationTarget.DEFAULT\n\t\t\t);\n\n\t\t\t// If default rules are disabled, ignore entries that come from the default config\n\t\t\tif (ignoreDefaults && isDefaultRule && sourceTarget === ConfigurationTarget.DEFAULT) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (typeof value === 'boolean') {\n\t\t\t\tconst { regex, regexCaseInsensitive } = this._convertAutoApproveEntryToRegex(key);\n\t\t\t\t// IMPORTANT: Only true and false are used, null entries need to be ignored\n\t\t\t\tif (value === true) {\n\t\t\t\t\tallowListRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t} else if (value === false) {\n\t\t\t\t\tdenyListRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t}\n\t\t\t} else if (typeof value === 'object' && value !== null) {\n\t\t\t\t// Handle object format like { approve: true/false, matchCommandLine: true/false }\n\t\t\t\tconst objectValue = value as { approve?: boolean; matchCommandLine?: boolean };\n\t\t\t\tif (typeof objectValue.approve === 'boolean') {\n\t\t\t\t\tconst { regex, regexCaseInsensitive } = this._convertAutoApproveEntryToRegex(key);\n\t\t\t\t\tif (objectValue.approve === true) {\n\t\t\t\t\t\tif (objectValue.matchCommandLine === true) {\n\t\t\t\t\t\t\tallowListCommandLineRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallowListRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (objectValue.approve === false) {\n\t\t\t\t\t\tif (objectValue.matchCommandLine === true) {\n\t\t\t\t\t\t\tdenyListCommandLineRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdenyListRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tdenyListRules,\n\t\t\tallowListRules,\n\t\t\tallowListCommandLineRules,\n\t\t\tdenyListCommandLineRules\n\t\t};\n\t}\n\n\tprivate _convertAutoApproveEntryToRegex(value: string): { regex: RegExp; regexCaseInsensitive: RegExp } {\n\t\tconst regex = this._doConvertAutoApproveEntryToRegex(value);\n\t\tif (regex.flags.includes('i')) {\n\t\t\treturn { regex, regexCaseInsensitive: regex };\n\t\t}\n\t\treturn { regex, regexCaseInsensitive: new RegExp(regex.source, regex.flags + 'i') };\n\t}\n\n\tprivate _doConvertAutoApproveEntryToRegex(value: string): RegExp {\n\t\t// If it's wrapped in `/`, it's in regex format and should be converted directly\n\t\t// Support all standard JavaScript regex flags: d, g, i, m, s, u, v, y\n\t\tconst regexMatch = value.match(/^\\/(?<pattern>.+)\\/(?<flags>[dgimsuvy]*)$/);\n\t\tconst regexPattern = regexMatch?.groups?.pattern;\n\t\tif (regexPattern) {\n\t\t\tlet flags = regexMatch.groups?.flags;\n\t\t\t// Remove global flag as it changes how the regex state works which we need to handle\n\t\t\t// internally\n\t\t\tif (flags) {\n\t\t\t\tflags = flags.replaceAll('g', '');\n\t\t\t}\n\n\t\t\t// Allow .* as users expect this would match everything\n\t\t\tif (regexPattern === '.*') {\n\t\t\t\treturn new RegExp(regexPattern);\n\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst regex = new RegExp(regexPattern, flags || undefined);\n\t\t\t\tif (regExpLeadsToEndlessLoop(regex)) {\n\t\t\t\t\treturn neverMatchRegex;\n\t\t\t\t}\n\n\t\t\t\treturn regex;\n\t\t\t} catch (error) {\n\t\t\t\treturn neverMatchRegex;\n\t\t\t}\n\t\t}\n\n\t\t// The empty string should be ignored, rather than approve everything\n\t\tif (value === '') {\n\t\t\treturn neverMatchRegex;\n\t\t}\n\n\t\tlet sanitizedValue: string;\n\n\t\t// Match both path separators it if looks like a path\n\t\tif (value.includes('/') || value.includes('\\\\')) {\n\t\t\t// Replace path separators with placeholders first, apply standard sanitization, then\n\t\t\t// apply special path handling\n\t\t\tlet pattern = value.replace(/[/\\\\]/g, '%%PATH_SEP%%');\n\t\t\tpattern = escapeRegExpCharacters(pattern);\n\t\t\tpattern = pattern.replace(/%%PATH_SEP%%*/g, '[/\\\\\\\\]');\n\t\t\tsanitizedValue = `^(?:\\\\.[/\\\\\\\\])?${pattern}`;\n\t\t}\n\n\t\t// Escape regex special characters for non-path strings\n\t\telse {\n\t\t\tsanitizedValue = escapeRegExpCharacters(value);\n\t\t}\n\n\t\t// Regular strings should match the start of the command line and be a word boundary\n\t\treturn new RegExp(`^${sanitizedValue}\\\\b`);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport type { OperatingSystem } from '../../../../../base/common/platform.js';\nimport { escapeRegExpCharacters, regExpLeadsToEndlessLoop } from '../../../../../base/common/strings.js';\nimport { isObject } from '../../../../../base/common/types.js';\nimport { structuralEquals } from '../../../../../base/common/equals.js';\nimport { ConfigurationTarget, IConfigurationService, type IConfigurationValue } from '../../../../../platform/configuration/common/configuration.js';\nimport { TerminalChatAgentToolsSettingId } from '../common/terminalChatAgentToolsConfiguration.js';\nimport { isPowerShell } from './runInTerminalHelpers.js';\n\nexport interface IAutoApproveRule {\n\tregex: RegExp;\n\tregexCaseInsensitive: RegExp;\n\tsourceText: string;\n\tsourceTarget: ConfigurationTarget;\n\tisDefaultRule: boolean;\n}\n\nexport interface ICommandApprovalResultWithReason {\n\tresult: ICommandApprovalResult;\n\treason: string;\n\trule?: IAutoApproveRule;\n}\n\nexport type ICommandApprovalResult = 'approved' | 'denied' | 'noMatch';\n\nconst neverMatchRegex = /(?!.*)/;\nconst transientEnvVarRegex = /^[A-Z_][A-Z0-9_]*=/i;\n\nexport class CommandLineAutoApprover extends Disposable {\n\tprivate _denyListRules: IAutoApproveRule[] = [];\n\tprivate _allowListRules: IAutoApproveRule[] = [];\n\tprivate _allowListCommandLineRules: IAutoApproveRule[] = [];\n\tprivate _denyListCommandLineRules: IAutoApproveRule[] = [];\n\n\tconstructor(\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t) {\n\t\tsuper();\n\t\tthis.updateConfiguration();\n\t\tthis._register(this._configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (\n\t\t\t\te.affectsConfiguration(TerminalChatAgentToolsSettingId.AutoApprove) ||\n\t\t\t\te.affectsConfiguration(TerminalChatAgentToolsSettingId.IgnoreDefaultAutoApproveRules) ||\n\t\t\t\te.affectsConfiguration(TerminalChatAgentToolsSettingId.DeprecatedAutoApproveCompatible)\n\t\t\t) {\n\t\t\t\tthis.updateConfiguration();\n\t\t\t}\n\t\t}));\n\t}\n\n\tupdateConfiguration() {\n\t\tlet configValue = this._configurationService.getValue(TerminalChatAgentToolsSettingId.AutoApprove);\n\t\tconst configInspectValue = this._configurationService.inspect(TerminalChatAgentToolsSettingId.AutoApprove);\n\t\tconst deprecatedValue = this._configurationService.getValue(TerminalChatAgentToolsSettingId.DeprecatedAutoApproveCompatible);\n\t\tif (deprecatedValue && typeof deprecatedValue === 'object' && configValue && typeof configValue === 'object') {\n\t\t\tconfigValue = {\n\t\t\t\t...configValue,\n\t\t\t\t...deprecatedValue\n\t\t\t};\n\t\t}\n\n\t\tconst {\n\t\t\tdenyListRules,\n\t\t\tallowListRules,\n\t\t\tallowListCommandLineRules,\n\t\t\tdenyListCommandLineRules\n\t\t} = this._mapAutoApproveConfigToRules(configValue, configInspectValue);\n\t\tthis._allowListRules = allowListRules;\n\t\tthis._denyListRules = denyListRules;\n\t\tthis._allowListCommandLineRules = allowListCommandLineRules;\n\t\tthis._denyListCommandLineRules = denyListCommandLineRules;\n\t}\n\n\tisCommandAutoApproved(command: string, shell: string, os: OperatingSystem): ICommandApprovalResultWithReason {\n\t\t// Check if the command has a transient environment variable assignment prefix which we\n\t\t// always deny for now as it can easily lead to execute other commands\n\t\tif (transientEnvVarRegex.test(command)) {\n\t\t\treturn {\n\t\t\t\tresult: 'denied',\n\t\t\t\treason: `Command '${command}' is denied because it contains transient environment variables`\n\t\t\t};\n\t\t}\n\n\t\t// Check the deny list to see if this command requires explicit approval\n\t\tfor (const rule of this._denyListRules) {\n\t\t\tif (this._commandMatchesRule(rule, command, shell, os)) {\n\t\t\t\treturn {\n\t\t\t\t\tresult: 'denied',\n\t\t\t\t\trule,\n\t\t\t\t\treason: `Command '${command}' is denied by deny list rule: ${rule.sourceText}`\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Check the allow list to see if the command is allowed to run without explicit approval\n\t\tfor (const rule of this._allowListRules) {\n\t\t\tif (this._commandMatchesRule(rule, command, shell, os)) {\n\t\t\t\treturn {\n\t\t\t\t\tresult: 'approved',\n\t\t\t\t\trule,\n\t\t\t\t\treason: `Command '${command}' is approved by allow list rule: ${rule.sourceText}`\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// TODO: LLM-based auto-approval https://github.com/microsoft/vscode/issues/253267\n\n\t\t// Fallback is always to require approval\n\t\treturn {\n\t\t\tresult: 'noMatch',\n\t\t\treason: `Command '${command}' has no matching auto approve entries`\n\t\t};\n\t}\n\n\tisCommandLineAutoApproved(commandLine: string): ICommandApprovalResultWithReason {\n\t\t// Check the deny list first to see if this command line requires explicit approval\n\t\tfor (const rule of this._denyListCommandLineRules) {\n\t\t\tif (rule.regex.test(commandLine)) {\n\t\t\t\treturn {\n\t\t\t\t\tresult: 'denied',\n\t\t\t\t\trule,\n\t\t\t\t\treason: `Command line '${commandLine}' is denied by deny list rule: ${rule.sourceText}`\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Check if the full command line matches any of the allow list command line regexes\n\t\tfor (const rule of this._allowListCommandLineRules) {\n\t\t\tif (rule.regex.test(commandLine)) {\n\t\t\t\treturn {\n\t\t\t\t\tresult: 'approved',\n\t\t\t\t\trule,\n\t\t\t\t\treason: `Command line '${commandLine}' is approved by allow list rule: ${rule.sourceText}`\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tresult: 'noMatch',\n\t\t\treason: `Command line '${commandLine}' has no matching auto approve entries`\n\t\t};\n\t}\n\n\tprivate _commandMatchesRule(rule: IAutoApproveRule, command: string, shell: string, os: OperatingSystem): boolean {\n\t\tconst isPwsh = isPowerShell(shell, os);\n\n\t\t// PowerShell is case insensitive regardless of platform\n\t\tif ((isPwsh ? rule.regexCaseInsensitive : rule.regex).test(command)) {\n\t\t\treturn true;\n\t\t} else if (isPwsh && command.startsWith('(')) {\n\t\t\t// Allow ignoring of the leading ( for PowerShell commands as it's a command pattern to\n\t\t\t// operate on the output of a command. For example `(Get-Content README.md) ...`\n\t\t\tif (rule.regexCaseInsensitive.test(command.slice(1))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _mapAutoApproveConfigToRules(config: unknown, configInspectValue: IConfigurationValue<Readonly<unknown>>): {\n\t\tdenyListRules: IAutoApproveRule[];\n\t\tallowListRules: IAutoApproveRule[];\n\t\tallowListCommandLineRules: IAutoApproveRule[];\n\t\tdenyListCommandLineRules: IAutoApproveRule[];\n\t} {\n\t\tif (!config || typeof config !== 'object') {\n\t\t\treturn {\n\t\t\t\tdenyListRules: [],\n\t\t\t\tallowListRules: [],\n\t\t\t\tallowListCommandLineRules: [],\n\t\t\t\tdenyListCommandLineRules: []\n\t\t\t};\n\t\t}\n\n\t\tconst denyListRules: IAutoApproveRule[] = [];\n\t\tconst allowListRules: IAutoApproveRule[] = [];\n\t\tconst allowListCommandLineRules: IAutoApproveRule[] = [];\n\t\tconst denyListCommandLineRules: IAutoApproveRule[] = [];\n\n\t\tconst ignoreDefaults = this._configurationService.getValue(TerminalChatAgentToolsSettingId.IgnoreDefaultAutoApproveRules) === true;\n\n\t\tfor (const [key, value] of Object.entries(config)) {\n\t\t\tconst defaultValue = configInspectValue?.default?.value;\n\t\t\tconst isDefaultRule = !!(\n\t\t\t\tisObject(defaultValue) &&\n\t\t\t\tObject.prototype.hasOwnProperty.call(defaultValue, key) &&\n\t\t\t\tstructuralEquals((defaultValue as Record<string, unknown>)[key], value)\n\t\t\t);\n\t\t\tfunction checkTarget(inspectValue: Readonly<unknown> | undefined): boolean {\n\t\t\t\treturn (\n\t\t\t\t\tisObject(inspectValue) &&\n\t\t\t\t\tObject.prototype.hasOwnProperty.call(inspectValue, key) &&\n\t\t\t\t\tstructuralEquals((inspectValue as Record<string, unknown>)[key], value)\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst sourceTarget = (\n\t\t\t\tcheckTarget(configInspectValue.workspaceFolder) ? ConfigurationTarget.WORKSPACE_FOLDER\n\t\t\t\t\t: checkTarget(configInspectValue.workspaceValue) ? ConfigurationTarget.WORKSPACE\n\t\t\t\t\t\t: checkTarget(configInspectValue.userRemoteValue) ? ConfigurationTarget.USER_REMOTE\n\t\t\t\t\t\t\t: checkTarget(configInspectValue.userLocalValue) ? ConfigurationTarget.USER_LOCAL\n\t\t\t\t\t\t\t\t: checkTarget(configInspectValue.userValue) ? ConfigurationTarget.USER\n\t\t\t\t\t\t\t\t\t: checkTarget(configInspectValue.applicationValue) ? ConfigurationTarget.APPLICATION\n\t\t\t\t\t\t\t\t\t\t: ConfigurationTarget.DEFAULT\n\t\t\t);\n\n\t\t\t// If default rules are disabled, ignore entries that come from the default config\n\t\t\tif (ignoreDefaults && isDefaultRule && sourceTarget === ConfigurationTarget.DEFAULT) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (typeof value === 'boolean') {\n\t\t\t\tconst { regex, regexCaseInsensitive } = this._convertAutoApproveEntryToRegex(key);\n\t\t\t\t// IMPORTANT: Only true and false are used, null entries need to be ignored\n\t\t\t\tif (value === true) {\n\t\t\t\t\tallowListRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t} else if (value === false) {\n\t\t\t\t\tdenyListRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t}\n\t\t\t} else if (typeof value === 'object' && value !== null) {\n\t\t\t\t// Handle object format like { approve: true/false, matchCommandLine: true/false }\n\t\t\t\tconst objectValue = value as { approve?: boolean; matchCommandLine?: boolean };\n\t\t\t\tif (typeof objectValue.approve === 'boolean') {\n\t\t\t\t\tconst { regex, regexCaseInsensitive } = this._convertAutoApproveEntryToRegex(key);\n\t\t\t\t\tif (objectValue.approve === true) {\n\t\t\t\t\t\tif (objectValue.matchCommandLine === true) {\n\t\t\t\t\t\t\tallowListCommandLineRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallowListRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (objectValue.approve === false) {\n\t\t\t\t\t\tif (objectValue.matchCommandLine === true) {\n\t\t\t\t\t\t\tdenyListCommandLineRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdenyListRules.push({ regex, regexCaseInsensitive, sourceText: key, sourceTarget, isDefaultRule });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tdenyListRules,\n\t\t\tallowListRules,\n\t\t\tallowListCommandLineRules,\n\t\t\tdenyListCommandLineRules\n\t\t};\n\t}\n\n\tprivate _convertAutoApproveEntryToRegex(value: string): { regex: RegExp; regexCaseInsensitive: RegExp } {\n\t\tconst regex = this._doConvertAutoApproveEntryToRegex(value);\n\t\tif (regex.flags.includes('i')) {\n\t\t\treturn { regex, regexCaseInsensitive: regex };\n\t\t}\n\t\treturn { regex, regexCaseInsensitive: new RegExp(regex.source, regex.flags + 'i') };\n\t}\n\n\tprivate _doConvertAutoApproveEntryToRegex(value: string): RegExp {\n\t\t// If it's wrapped in `/`, it's in regex format and should be converted directly\n\t\t// Support all standard JavaScript regex flags: d, g, i, m, s, u, v, y\n\t\tconst regexMatch = value.match(/^\\/(?<pattern>.+)\\/(?<flags>[dgimsuvy]*)$/);\n\t\tconst regexPattern = regexMatch?.groups?.pattern;\n\t\tif (regexPattern) {\n\t\t\tlet flags = regexMatch.groups?.flags;\n\t\t\t// Remove global flag as it changes how the regex state works which we need to handle\n\t\t\t// internally\n\t\t\tif (flags) {\n\t\t\t\tflags = flags.replaceAll('g', '');\n\t\t\t}\n\n\t\t\t// Allow .* as users expect this would match everything\n\t\t\tif (regexPattern === '.*') {\n\t\t\t\treturn new RegExp(regexPattern);\n\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst regex = new RegExp(regexPattern, flags || undefined);\n\t\t\t\tif (regExpLeadsToEndlessLoop(regex)) {\n\t\t\t\t\treturn neverMatchRegex;\n\t\t\t\t}\n\n\t\t\t\treturn regex;\n\t\t\t} catch (error) {\n\t\t\t\treturn neverMatchRegex;\n\t\t\t}\n\t\t}\n\n\t\t// The empty string should be ignored, rather than approve everything\n\t\tif (value === '') {\n\t\t\treturn neverMatchRegex;\n\t\t}\n\n\t\tlet sanitizedValue: string;\n\n\t\t// Match both path separators it if looks like a path\n\t\tif (value.includes('/') || value.includes('\\\\')) {\n\t\t\t// Replace path separators with placeholders first, apply standard sanitization, then\n\t\t\t// apply special path handling\n\t\t\tlet pattern = value.replace(/[/\\\\]/g, '%%PATH_SEP%%');\n\t\t\tpattern = escapeRegExpCharacters(pattern);\n\t\t\tpattern = pattern.replace(/%%PATH_SEP%%*/g, '[/\\\\\\\\]');\n\t\t\tsanitizedValue = `^(?:\\\\.[/\\\\\\\\])?${pattern}`;\n\t\t}\n\n\t\t// Escape regex special characters for non-path strings\n\t\telse {\n\t\t\tsanitizedValue = escapeRegExpCharacters(value);\n\t\t}\n\n\t\t// Regular strings should match the start of the command line and be a word boundary\n\t\treturn new RegExp(`^${sanitizedValue}\\\\b`);\n\t}\n}\n"]}