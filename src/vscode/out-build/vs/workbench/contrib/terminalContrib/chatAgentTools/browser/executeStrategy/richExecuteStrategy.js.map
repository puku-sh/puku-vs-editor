{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/chatAgentTools/browser/executeStrategy/richExecuteStrategy.ts","vs/workbench/contrib/terminalContrib/chatAgentTools/browser/executeStrategy/richExecuteStrategy.ts"],"names":[],"mappings":"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","file":"richExecuteStrategy.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CancellationToken } from '../../../../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../../../base/common/event.js';\nimport { DisposableStore, MutableDisposable } from '../../../../../../base/common/lifecycle.js';\nimport { isNumber } from '../../../../../../base/common/types.js';\nimport type { ICommandDetectionCapability } from '../../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { ITerminalLogService } from '../../../../../../platform/terminal/common/terminal.js';\nimport type { ITerminalInstance } from '../../../../terminal/browser/terminal.js';\nimport { trackIdleOnPrompt, type ITerminalExecuteStrategy, type ITerminalExecuteStrategyResult } from './executeStrategy.js';\nimport type { IMarker as IXtermMarker } from '@xterm/xterm';\nimport { setupRecreatingStartMarker } from './strategyHelpers.js';\n\n/**\n * This strategy is used when the terminal has rich shell integration/command detection is\n * available, meaning every sequence we rely upon should be exactly where we expect it to be. In\n * particular (`633;`) `A, B, E, C, D` all happen in exactly that order. While things still could go\n * wrong in this state, minimal verification is done in this mode since rich command detection is a\n * strong signal that it's behaving correctly.\n */\nexport class RichExecuteStrategy implements ITerminalExecuteStrategy {\n\treadonly type = 'rich';\n\tprivate readonly _startMarker = new MutableDisposable<IXtermMarker>();\n\n\tprivate readonly _onDidCreateStartMarker = new Emitter<IXtermMarker | undefined>;\n\tpublic onDidCreateStartMarker: Event<IXtermMarker | undefined> = this._onDidCreateStartMarker.event;\n\n\tconstructor(\n\t\tprivate readonly _instance: ITerminalInstance,\n\t\tprivate readonly _commandDetection: ICommandDetectionCapability,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t) {\n\t}\n\n\tasync execute(commandLine: string, token: CancellationToken, commandId?: string): Promise<ITerminalExecuteStrategyResult> {\n\t\tconst store = new DisposableStore();\n\t\ttry {\n\t\t\t// Ensure xterm is available\n\t\t\tthis._log('Waiting for xterm');\n\t\t\tconst xterm = await this._instance.xtermReadyPromise;\n\t\t\tif (!xterm) {\n\t\t\t\tthrow new Error('Xterm is not available');\n\t\t\t}\n\n\t\t\tconst onDone = Promise.race([\n\t\t\t\tEvent.toPromise(this._commandDetection.onCommandFinished, store).then(e => {\n\t\t\t\t\tthis._log('onDone via end event');\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'type': 'success',\n\t\t\t\t\t\tcommand: e\n\t\t\t\t\t} as const;\n\t\t\t\t}),\n\t\t\t\tEvent.toPromise(token.onCancellationRequested as Event<undefined>, store).then(() => {\n\t\t\t\t\tthis._log('onDone via cancellation');\n\t\t\t\t}),\n\t\t\t\tEvent.toPromise(this._instance.onDisposed, store).then(() => {\n\t\t\t\t\tthis._log('onDone via terminal disposal');\n\t\t\t\t\treturn { type: 'disposal' } as const;\n\t\t\t\t}),\n\t\t\t\ttrackIdleOnPrompt(this._instance, 1000, store).then(() => {\n\t\t\t\t\tthis._log('onDone via idle prompt');\n\t\t\t\t}),\n\t\t\t]);\n\n\t\t\tsetupRecreatingStartMarker(\n\t\t\t\txterm,\n\t\t\t\tthis._startMarker,\n\t\t\t\tm => this._onDidCreateStartMarker.fire(m),\n\t\t\t\tstore,\n\t\t\t\tthis._log.bind(this)\n\t\t\t);\n\n\t\t\t// Execute the command\n\t\t\tthis._log(`Executing command line \\`${commandLine}\\``);\n\t\t\tthis._instance.runCommand(commandLine, true, commandId);\n\n\t\t\t// Wait for the terminal to idle\n\t\t\tthis._log('Waiting for done event');\n\t\t\tconst onDoneResult = await onDone;\n\t\t\tif (onDoneResult && onDoneResult.type === 'disposal') {\n\t\t\t\tthrow new Error('The terminal was closed');\n\t\t\t}\n\t\t\tconst finishedCommand = onDoneResult && onDoneResult.type === 'success' ? onDoneResult.command : undefined;\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\t\t\tconst endMarker = store.add(xterm.raw.registerMarker());\n\n\t\t\t// Assemble final result\n\t\t\tlet output: string | undefined;\n\t\t\tconst additionalInformationLines: string[] = [];\n\t\t\tif (finishedCommand) {\n\t\t\t\tconst commandOutput = finishedCommand?.getOutput();\n\t\t\t\tif (commandOutput !== undefined) {\n\t\t\t\t\tthis._log('Fetched output via finished command');\n\t\t\t\t\toutput = commandOutput;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (output === undefined) {\n\t\t\t\ttry {\n\t\t\t\t\toutput = xterm.getContentsAsText(this._startMarker.value, endMarker);\n\t\t\t\t\tthis._log('Fetched output via markers');\n\t\t\t\t} catch {\n\t\t\t\t\tthis._log('Failed to fetch output via markers');\n\t\t\t\t\tadditionalInformationLines.push('Failed to retrieve command output');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (output !== undefined && output.trim().length === 0) {\n\t\t\t\tadditionalInformationLines.push('Command produced no output');\n\t\t\t}\n\n\t\t\tconst exitCode = finishedCommand?.exitCode;\n\t\t\tif (isNumber(exitCode) && exitCode > 0) {\n\t\t\t\tadditionalInformationLines.push(`Command exited with code ${exitCode}`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\toutput,\n\t\t\t\tadditionalInformation: additionalInformationLines.length > 0 ? additionalInformationLines.join('\\n') : undefined,\n\t\t\t\texitCode,\n\t\t\t};\n\t\t} finally {\n\t\t\tstore.dispose();\n\t\t}\n\t}\n\n\tprivate _log(message: string) {\n\t\tthis._logService.debug(`RunInTerminalTool#Rich: ${message}`);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CancellationToken } from '../../../../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../../../base/common/event.js';\nimport { DisposableStore, MutableDisposable } from '../../../../../../base/common/lifecycle.js';\nimport { isNumber } from '../../../../../../base/common/types.js';\nimport type { ICommandDetectionCapability } from '../../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { ITerminalLogService } from '../../../../../../platform/terminal/common/terminal.js';\nimport type { ITerminalInstance } from '../../../../terminal/browser/terminal.js';\nimport { trackIdleOnPrompt, type ITerminalExecuteStrategy, type ITerminalExecuteStrategyResult } from './executeStrategy.js';\nimport type { IMarker as IXtermMarker } from '@xterm/xterm';\nimport { setupRecreatingStartMarker } from './strategyHelpers.js';\n\n/**\n * This strategy is used when the terminal has rich shell integration/command detection is\n * available, meaning every sequence we rely upon should be exactly where we expect it to be. In\n * particular (`633;`) `A, B, E, C, D` all happen in exactly that order. While things still could go\n * wrong in this state, minimal verification is done in this mode since rich command detection is a\n * strong signal that it's behaving correctly.\n */\nexport class RichExecuteStrategy implements ITerminalExecuteStrategy {\n\treadonly type = 'rich';\n\tprivate readonly _startMarker = new MutableDisposable<IXtermMarker>();\n\n\tprivate readonly _onDidCreateStartMarker = new Emitter<IXtermMarker | undefined>;\n\tpublic onDidCreateStartMarker: Event<IXtermMarker | undefined> = this._onDidCreateStartMarker.event;\n\n\tconstructor(\n\t\tprivate readonly _instance: ITerminalInstance,\n\t\tprivate readonly _commandDetection: ICommandDetectionCapability,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t) {\n\t}\n\n\tasync execute(commandLine: string, token: CancellationToken, commandId?: string): Promise<ITerminalExecuteStrategyResult> {\n\t\tconst store = new DisposableStore();\n\t\ttry {\n\t\t\t// Ensure xterm is available\n\t\t\tthis._log('Waiting for xterm');\n\t\t\tconst xterm = await this._instance.xtermReadyPromise;\n\t\t\tif (!xterm) {\n\t\t\t\tthrow new Error('Xterm is not available');\n\t\t\t}\n\n\t\t\tconst onDone = Promise.race([\n\t\t\t\tEvent.toPromise(this._commandDetection.onCommandFinished, store).then(e => {\n\t\t\t\t\tthis._log('onDone via end event');\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'type': 'success',\n\t\t\t\t\t\tcommand: e\n\t\t\t\t\t} as const;\n\t\t\t\t}),\n\t\t\t\tEvent.toPromise(token.onCancellationRequested as Event<undefined>, store).then(() => {\n\t\t\t\t\tthis._log('onDone via cancellation');\n\t\t\t\t}),\n\t\t\t\tEvent.toPromise(this._instance.onDisposed, store).then(() => {\n\t\t\t\t\tthis._log('onDone via terminal disposal');\n\t\t\t\t\treturn { type: 'disposal' } as const;\n\t\t\t\t}),\n\t\t\t\ttrackIdleOnPrompt(this._instance, 1000, store).then(() => {\n\t\t\t\t\tthis._log('onDone via idle prompt');\n\t\t\t\t}),\n\t\t\t]);\n\n\t\t\tsetupRecreatingStartMarker(\n\t\t\t\txterm,\n\t\t\t\tthis._startMarker,\n\t\t\t\tm => this._onDidCreateStartMarker.fire(m),\n\t\t\t\tstore,\n\t\t\t\tthis._log.bind(this)\n\t\t\t);\n\n\t\t\t// Execute the command\n\t\t\tthis._log(`Executing command line \\`${commandLine}\\``);\n\t\t\tthis._instance.runCommand(commandLine, true, commandId);\n\n\t\t\t// Wait for the terminal to idle\n\t\t\tthis._log('Waiting for done event');\n\t\t\tconst onDoneResult = await onDone;\n\t\t\tif (onDoneResult && onDoneResult.type === 'disposal') {\n\t\t\t\tthrow new Error('The terminal was closed');\n\t\t\t}\n\t\t\tconst finishedCommand = onDoneResult && onDoneResult.type === 'success' ? onDoneResult.command : undefined;\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\t\t\tconst endMarker = store.add(xterm.raw.registerMarker());\n\n\t\t\t// Assemble final result\n\t\t\tlet output: string | undefined;\n\t\t\tconst additionalInformationLines: string[] = [];\n\t\t\tif (finishedCommand) {\n\t\t\t\tconst commandOutput = finishedCommand?.getOutput();\n\t\t\t\tif (commandOutput !== undefined) {\n\t\t\t\t\tthis._log('Fetched output via finished command');\n\t\t\t\t\toutput = commandOutput;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (output === undefined) {\n\t\t\t\ttry {\n\t\t\t\t\toutput = xterm.getContentsAsText(this._startMarker.value, endMarker);\n\t\t\t\t\tthis._log('Fetched output via markers');\n\t\t\t\t} catch {\n\t\t\t\t\tthis._log('Failed to fetch output via markers');\n\t\t\t\t\tadditionalInformationLines.push('Failed to retrieve command output');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (output !== undefined && output.trim().length === 0) {\n\t\t\t\tadditionalInformationLines.push('Command produced no output');\n\t\t\t}\n\n\t\t\tconst exitCode = finishedCommand?.exitCode;\n\t\t\tif (isNumber(exitCode) && exitCode > 0) {\n\t\t\t\tadditionalInformationLines.push(`Command exited with code ${exitCode}`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\toutput,\n\t\t\t\tadditionalInformation: additionalInformationLines.length > 0 ? additionalInformationLines.join('\\n') : undefined,\n\t\t\t\texitCode,\n\t\t\t};\n\t\t} finally {\n\t\t\tstore.dispose();\n\t\t}\n\t}\n\n\tprivate _log(message: string) {\n\t\tthis._logService.debug(`RunInTerminalTool#Rich: ${message}`);\n\t}\n}\n"]}