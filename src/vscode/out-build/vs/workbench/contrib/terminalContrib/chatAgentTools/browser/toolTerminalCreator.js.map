{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/chatAgentTools/browser/toolTerminalCreator.ts","vs/workbench/contrib/terminalContrib/chatAgentTools/browser/toolTerminalCreator.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;AAEhG,OAAO,EAAE,eAAe,EAAE,iBAAiB,EAAE,WAAW,EAAE,MAAM,qCAAqC,CAAC;AAEtG,OAAO,EAAE,OAAO,EAAE,MAAM,wCAAwC,CAAC;AACjE,OAAO,EAAE,iBAAiB,EAAE,MAAM,sCAAsC,CAAC;AACzE,OAAO,EAAE,KAAK,EAAE,MAAM,qCAAqC,CAAC;AAC5D,OAAO,EAAE,eAAe,EAAE,iBAAiB,EAAE,MAAM,yCAAyC,CAAC;AAC7F,OAAO,EAAE,SAAS,EAAE,MAAM,yCAAyC,CAAC;AACpE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,qCAAqC,CAAC;AAC3F,OAAO,EAAE,qBAAqB,EAAE,MAAM,+DAA+D,CAAC;AAGtG,OAAO,EAAE,mBAAmB,EAAgE,MAAM,qDAAqD,CAAC;AACxJ,OAAO,EAAE,gBAAgB,EAA0B,MAAM,uCAAuC,CAAC;AACjG,OAAO,EAAE,0BAA0B,EAAE,MAAM,iDAAiD,CAAC;AAE7F,IAAW,eAIV;AAJD,WAAW,eAAe;IACzB,2DAAW,CAAA;IACX,2DAAW,CAAA;IACX,6DAAY,CAAA;AACb,CAAC,EAJU,eAAe,KAAf,eAAe,QAIzB;AAED,MAAM,CAAN,IAAkB,uBAIjB;AAJD,WAAkB,uBAAuB;IACxC,wCAAa,CAAA;IACb,0CAAe,CAAA;IACf,wCAAa,CAAA;AACd,CAAC,EAJiB,uBAAuB,KAAvB,uBAAuB,QAIxC;AAQM,IAAM,mBAAmB,GAAzB,MAAM,mBAAmB;;IAC/B;;;OAGG;aACY,yBAAoB,kCAAA,CAA4C;IAE/E,YACyC,qBAA4C,EAC9C,WAAgC,EACnC,gBAAkC;QAF7B,0BAAqB,GAArB,qBAAqB,CAAuB;QAC9C,gBAAW,GAAX,WAAW,CAAqB;QACnC,qBAAgB,GAAhB,gBAAgB,CAAkB;IAEtE,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,cAAyC,EAAE,KAAwB;QACvF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,cAAc,CAAC,CAAC;QACnE,MAAM,YAAY,GAAkB;YACnC,QAAQ;YACR,uBAAuB,2CAA8B;SACrD,CAAC;QACF,IAAI,qBAAqB,GAAG,CAAC,CAAC;QAE9B,iDAAiD;QACjD,MAAM,UAAU,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;YACpC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,qBAAqB,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACpE,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC;SAChC,CAAC,CAAC;QACH,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,MAAM,CAAC,UAAU,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;YAC5F,MAAM,IAAI,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QACrC,CAAC;QAED,mFAAmF;QACnF,4FAA4F;QAC5F,0DAA0D;QAC1D,MAAM,kBAAkB,GAAG,IAAI,CAAC,qBAAqB,CAAC,QAAQ,gGAA2C,KAAK,IAAI,CAAC;QAEnH,6DAA6D;QAC7D,MAAM,QAAQ,GAAG,0BAA0B,CAC1C,IAAI,CAAC,qBAAqB,EAC1B,kBAAkB,EAClB,QAAQ,CAAC,kBAAkB,EAC3B,qBAAqB,CACrB,CAAC;QAEF,IACC,qBAAmB,CAAC,oBAAoB,qCAA6B;YACrE,kBAAkB,EACjB,CAAC;YACF,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,+CAA+C,QAAQ,0BAA0B,CAAC,CAAC;YACzG,MAAM,uBAAuB,GAAG,MAAM,IAAI,CAAC,wBAAwB,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YACxF,IAAI,KAAK,CAAC,uBAAuB,EAAE,CAAC;gBACnC,QAAQ,CAAC,OAAO,EAAE,CAAC;gBACnB,MAAM,IAAI,iBAAiB,EAAE,CAAC;YAC/B,CAAC;YAED,uFAAuF;YACvF,kFAAkF;YAClF,0BAA0B;YAC1B,IAAI,uBAAuB,8CAAiC,EAAE,CAAC;gBAC9D,MAAM,gBAAgB,GAAG,QAAQ,CAAC,YAAY,CAAC,GAAG,6CAAqC,CAAC;gBACxF,IAAI,gBAAgB,EAAE,gBAAgB,CAAC,KAAK,qCAA6B,EAAE,CAAC;oBAC3E,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,2FAA2F,CAAC,CAAC;oBACnH,MAAM,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,EAAE,IAAI,CAAC,CAAC;gBAC7E,CAAC;YACF,CAAC;YAED,IAAI,uBAAuB,8CAAiC,EAAE,CAAC;gBAC9D,qBAAmB,CAAC,oBAAoB,kCAA0B,CAAC;gBACnE,YAAY,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;gBAC/D,OAAO,YAAY,CAAC;YACrB,CAAC;QACF,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,yGAAyG,qBAAmB,CAAC,oBAAoB,EAAE,CAAC,CAAC;QAC5K,CAAC;QAED,yDAAyD;QACzD,qBAAmB,CAAC,oBAAoB,mCAA2B,CAAC;QACpE,OAAO,YAAY,CAAC;IACrB,CAAC;IAED;;;;;;OAMG;IACH,8BAA8B,CAAC,YAA2B;QACzD,MAAM,gBAAgB,GAAG,YAAY,CAAC,QAAQ,CAAC,YAAY,CAAC,GAAG,6CAAqC,CAAC;QACrG,IAAI,gBAAgB,EAAE,CAAC;YACtB,IACC,YAAY,CAAC,uBAAuB,8CAAiC;gBACrE,YAAY,CAAC,uBAAuB,gDAAkC,EACrE,CAAC;gBACF,YAAY,CAAC,uBAAuB,GAAG,gBAAgB,CAAC,uBAAuB,CAAC,CAAC,2CAA8B,CAAC,4CAA8B,CAAC;YAChJ,CAAC;QACF,CAAC;IACF,CAAC;IAEO,sBAAsB,CAAC,cAAyC;QACvE,MAAM,MAAM,GAAuB;YAClC,IAAI,EAAE,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE,CAAC;YAC9C,YAAY,EAAE,IAAI;YAClB,YAAY,EAAE,IAAI;YAClB,GAAG,EAAE;gBACJ,+DAA+D;gBAC/D,SAAS,EAAE,KAAK;aAChB;SACD,CAAC;QAEF,IAAI,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC;YAC9B,MAAM,CAAC,UAAU,GAAG,cAAc,CAAC;QACpC,CAAC;aAAM,CAAC;YACP,MAAM,CAAC,UAAU,GAAG,cAAc,CAAC,IAAI,CAAC;YACxC,MAAM,CAAC,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC;YAClC,MAAM,CAAC,IAAI,GAAG,cAAc,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC;YACjD,MAAM,CAAC,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC;YACpC,MAAM,CAAC,GAAG,GAAG;gBACZ,GAAG,MAAM,CAAC,GAAG;gBACb,GAAG,cAAc,CAAC,GAAG;aACrB,CAAC;QACH,CAAC;QAED,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC;IACzD,CAAC;IAEO,wBAAwB,CAC/B,QAA2B,EAC3B,SAAiB;QAEjB,MAAM,KAAK,GAAG,IAAI,eAAe,EAAE,CAAC;QACpC,MAAM,MAAM,GAAG,IAAI,eAAe,EAA2B,CAAC;QAE9D,MAAM,WAAW,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,iBAAiB,EAAE,CAAC,CAAC;QACvD,WAAW,CAAC,KAAK,GAAG,iBAAiB,CAAC,GAAG,EAAE;YAC1C,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,2DAA2D,SAAS,iBAAiB,CAAC,CAAC;YAC7G,MAAM,CAAC,QAAQ,2CAA8B,CAAC;QAC/C,CAAC,EAAE,SAAS,CAAC,CAAC;QAEd,IAAI,QAAQ,CAAC,YAAY,CAAC,GAAG,6CAAqC,EAAE,uBAAuB,EAAE,CAAC;YAC7F,mDAAmD;YACnD,WAAW,CAAC,KAAK,EAAE,CAAC;YACpB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,6EAA6E,CAAC,CAAC;YACrG,MAAM,CAAC,QAAQ,2CAA8B,CAAC;QAC/C,CAAC;aAAM,CAAC;YACP,MAAM,yBAAyB,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,+BAA+B,8CAAsC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,yBAAyB,CAAC,CAAC,CAAC;YAC1K,KAAK,CAAC,GAAG,CAAC,yBAAyB,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE;gBAC/C,IAAI,CAAC,CAAC,QAAQ,KAAK,QAAQ,EAAE,CAAC;oBAC7B,OAAO;gBACR,CAAC;gBACD,WAAW,CAAC,KAAK,EAAE,CAAC;gBACpB,oFAAoF;gBACpF,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,4EAA4E,CAAC,CAAC;gBACpG,MAAM,CAAC,QAAQ,2CAA8B,CAAC;YAC/C,CAAC,CAAC,CAAC,CAAC;YAEJ,MAAM,gBAAgB,GAAG,QAAQ,CAAC,YAAY,CAAC,GAAG,6CAAqC,CAAC;YACxF,IAAI,gBAAgB,EAAE,CAAC;gBACtB,WAAW,CAAC,KAAK,EAAE,CAAC;gBACpB,4DAA4D;gBAC5D,gFAAgF;gBAChF,KAAK,CAAC,GAAG,CAAC,iBAAiB,CAAC,GAAG,EAAE;oBAChC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,+EAA+E,CAAC,CAAC;oBACvG,MAAM,CAAC,QAAQ,6CAA+B,CAAC;gBAChD,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;YACV,CAAC;iBAAM,CAAC;gBACP,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,YAAY,CAAC,kCAAkC,CAAC,CAAC,CAAC,EAAE;oBACtE,WAAW,CAAC,KAAK,EAAE,CAAC;oBACpB,2EAA2E;oBAC3E,mEAAmE;oBACnE,eAAe;oBACf,KAAK,CAAC,GAAG,CAAC,iBAAiB,CAAC,GAAG,EAAE;wBAChC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,8FAA8F,CAAC,CAAC;wBACtH,MAAM,CAAC,QAAQ,6CAA+B,CAAC;oBAChD,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;gBACV,CAAC,CAAC,CAAC,CAAC;YACL,CAAC;QACF,CAAC;QAED,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE;YACrB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,iFAAiF,CAAC,CAAC;YACzG,KAAK,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC,CAAC,CAAC;QAEH,OAAO,MAAM,CAAC,CAAC,CAAC;IACjB,CAAC;;AAzLW,mBAAmB;IAQ7B,WAAA,qBAAqB,CAAA;IACrB,WAAA,mBAAmB,CAAA;IACnB,WAAA,gBAAgB,CAAA;GAVN,mBAAmB,CA0L/B","file":"toolTerminalCreator.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DeferredPromise, disposableTimeout, raceTimeout } from '../../../../../base/common/async.js';\nimport type { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../../base/common/codicons.js';\nimport { CancellationError } from '../../../../../base/common/errors.js';\nimport { Event } from '../../../../../base/common/event.js';\nimport { DisposableStore, MutableDisposable } from '../../../../../base/common/lifecycle.js';\nimport { ThemeIcon } from '../../../../../base/common/themables.js';\nimport { hasKey, isNumber, isObject, isString } from '../../../../../base/common/types.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { TerminalCapability } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { PromptInputState } from '../../../../../platform/terminal/common/capabilities/commandDetection/promptInputModel.js';\nimport { ITerminalLogService, ITerminalProfile, TerminalSettingId, type IShellLaunchConfig } from '../../../../../platform/terminal/common/terminal.js';\nimport { ITerminalService, type ITerminalInstance } from '../../../terminal/browser/terminal.js';\nimport { getShellIntegrationTimeout } from '../../../terminal/common/terminalEnvironment.js';\n\nconst enum ShellLaunchType {\n\tUnknown = 0,\n\tDefault = 1,\n\tFallback = 2,\n}\n\nexport const enum ShellIntegrationQuality {\n\tNone = 'none',\n\tBasic = 'basic',\n\tRich = 'rich',\n}\n\nexport interface IToolTerminal {\n\tinstance: ITerminalInstance;\n\tshellIntegrationQuality: ShellIntegrationQuality;\n\treceivedUserInput?: boolean;\n}\n\nexport class ToolTerminalCreator {\n\t/**\n\t * The shell preference cached for the lifetime of the window. This allows skipping previous\n\t * shell approaches that failed in previous runs to save time.\n\t */\n\tprivate static _lastSuccessfulShell: ShellLaunchType = ShellLaunchType.Unknown;\n\n\tconstructor(\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t\t@ITerminalService private readonly _terminalService: ITerminalService,\n\t) {\n\t}\n\n\tasync createTerminal(shellOrProfile: string | ITerminalProfile, token: CancellationToken): Promise<IToolTerminal> {\n\t\tconst instance = await this._createCopilotTerminal(shellOrProfile);\n\t\tconst toolTerminal: IToolTerminal = {\n\t\t\tinstance,\n\t\t\tshellIntegrationQuality: ShellIntegrationQuality.None,\n\t\t};\n\t\tlet processReadyTimestamp = 0;\n\n\t\t// Ensure the shell process launches successfully\n\t\tconst initResult = await Promise.any([\n\t\t\tinstance.processReady.then(() => processReadyTimestamp = Date.now()),\n\t\t\tEvent.toPromise(instance.onExit),\n\t\t]);\n\t\tif (!isNumber(initResult) && isObject(initResult) && hasKey(initResult, { message: true })) {\n\t\t\tthrow new Error(initResult.message);\n\t\t}\n\n\t\t// Wait for shell integration when the fallback case has not been hit or when shell\n\t\t// integration injection is enabled. Note that it's possible for the fallback case to happen\n\t\t// and then for SI to activate again later in the session.\n\t\tconst siInjectionEnabled = this._configurationService.getValue(TerminalSettingId.ShellIntegrationEnabled) === true;\n\n\t\t// Get the configurable timeout to wait for shell integration\n\t\tconst waitTime = getShellIntegrationTimeout(\n\t\t\tthis._configurationService,\n\t\t\tsiInjectionEnabled,\n\t\t\tinstance.hasRemoteAuthority,\n\t\t\tprocessReadyTimestamp\n\t\t);\n\n\t\tif (\n\t\t\tToolTerminalCreator._lastSuccessfulShell !== ShellLaunchType.Fallback ||\n\t\t\tsiInjectionEnabled\n\t\t) {\n\t\t\tthis._logService.info(`ToolTerminalCreator#createTerminal: Waiting ${waitTime}ms for shell integration`);\n\t\t\tconst shellIntegrationQuality = await this._waitForShellIntegration(instance, waitTime);\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tinstance.dispose();\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\n\t\t\t// If SI is rich, wait for the prompt state to change. This prevents an issue with pwsh\n\t\t\t// in particular where shell startup can swallow `\\r` input events, preventing the\n\t\t\t// command from executing.\n\t\t\tif (shellIntegrationQuality === ShellIntegrationQuality.Rich) {\n\t\t\t\tconst commandDetection = instance.capabilities.get(TerminalCapability.CommandDetection);\n\t\t\t\tif (commandDetection?.promptInputModel.state === PromptInputState.Unknown) {\n\t\t\t\t\tthis._logService.info(`ToolTerminalCreator#createTerminal: Waiting up to 2s for PromptInputModel state to change`);\n\t\t\t\t\tawait raceTimeout(Event.toPromise(commandDetection.onCommandStarted), 2000);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (shellIntegrationQuality !== ShellIntegrationQuality.None) {\n\t\t\t\tToolTerminalCreator._lastSuccessfulShell = ShellLaunchType.Default;\n\t\t\t\ttoolTerminal.shellIntegrationQuality = shellIntegrationQuality;\n\t\t\t\treturn toolTerminal;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._logService.info(`ToolTerminalCreator#createTerminal: Skipping wait for shell integration - last successful launch type ${ToolTerminalCreator._lastSuccessfulShell}`);\n\t\t}\n\n\t\t// Fallback case: No shell integration in default profile\n\t\tToolTerminalCreator._lastSuccessfulShell = ShellLaunchType.Fallback;\n\t\treturn toolTerminal;\n\t}\n\n\t/**\n\t * Synchronously update shell integration quality based on the terminal instance's current\n\t * capabilities. This is a defensive change to avoid no shell integration being sticky\n\t * https://github.com/microsoft/vscode/issues/260880\n\t *\n\t * Only upgrade quality just in case.\n\t */\n\trefreshShellIntegrationQuality(toolTerminal: IToolTerminal) {\n\t\tconst commandDetection = toolTerminal.instance.capabilities.get(TerminalCapability.CommandDetection);\n\t\tif (commandDetection) {\n\t\t\tif (\n\t\t\t\ttoolTerminal.shellIntegrationQuality === ShellIntegrationQuality.None ||\n\t\t\t\ttoolTerminal.shellIntegrationQuality === ShellIntegrationQuality.Basic\n\t\t\t) {\n\t\t\t\ttoolTerminal.shellIntegrationQuality = commandDetection.hasRichCommandDetection ? ShellIntegrationQuality.Rich : ShellIntegrationQuality.Basic;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _createCopilotTerminal(shellOrProfile: string | ITerminalProfile) {\n\t\tconst config: IShellLaunchConfig = {\n\t\t\ticon: ThemeIcon.fromId(Codicon.chatSparkle.id),\n\t\t\thideFromUser: true,\n\t\t\tforcePersist: true,\n\t\t\tenv: {\n\t\t\t\t// Avoid making `git diff` interactive when called from copilot\n\t\t\t\tGIT_PAGER: 'cat',\n\t\t\t}\n\t\t};\n\n\t\tif (isString(shellOrProfile)) {\n\t\t\tconfig.executable = shellOrProfile;\n\t\t} else {\n\t\t\tconfig.executable = shellOrProfile.path;\n\t\t\tconfig.args = shellOrProfile.args;\n\t\t\tconfig.icon = shellOrProfile.icon ?? config.icon;\n\t\t\tconfig.color = shellOrProfile.color;\n\t\t\tconfig.env = {\n\t\t\t\t...config.env,\n\t\t\t\t...shellOrProfile.env\n\t\t\t};\n\t\t}\n\n\t\treturn this._terminalService.createTerminal({ config });\n\t}\n\n\tprivate _waitForShellIntegration(\n\t\tinstance: ITerminalInstance,\n\t\ttimeoutMs: number\n\t): Promise<ShellIntegrationQuality> {\n\t\tconst store = new DisposableStore();\n\t\tconst result = new DeferredPromise<ShellIntegrationQuality>();\n\n\t\tconst siNoneTimer = store.add(new MutableDisposable());\n\t\tsiNoneTimer.value = disposableTimeout(() => {\n\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Timed out ${timeoutMs}ms, using no SI`);\n\t\t\tresult.complete(ShellIntegrationQuality.None);\n\t\t}, timeoutMs);\n\n\t\tif (instance.capabilities.get(TerminalCapability.CommandDetection)?.hasRichCommandDetection) {\n\t\t\t// Rich command detection is available immediately.\n\t\t\tsiNoneTimer.clear();\n\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Rich SI available immediately`);\n\t\t\tresult.complete(ShellIntegrationQuality.Rich);\n\t\t} else {\n\t\t\tconst onSetRichCommandDetection = store.add(this._terminalService.createOnInstanceCapabilityEvent(TerminalCapability.CommandDetection, e => e.onSetRichCommandDetection));\n\t\t\tstore.add(onSetRichCommandDetection.event((e) => {\n\t\t\t\tif (e.instance !== instance) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsiNoneTimer.clear();\n\t\t\t\t// Rich command detection becomes available some time after the terminal is created.\n\t\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Rich SI available eventually`);\n\t\t\t\tresult.complete(ShellIntegrationQuality.Rich);\n\t\t\t}));\n\n\t\t\tconst commandDetection = instance.capabilities.get(TerminalCapability.CommandDetection);\n\t\t\tif (commandDetection) {\n\t\t\t\tsiNoneTimer.clear();\n\t\t\t\t// When SI lights up, allow up to 200ms for the rich command\n\t\t\t\t// detection sequence to come in before declaring it as basic shell integration.\n\t\t\t\tstore.add(disposableTimeout(() => {\n\t\t\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Timed out 200ms, using basic SI`);\n\t\t\t\t\tresult.complete(ShellIntegrationQuality.Basic);\n\t\t\t\t}, 200));\n\t\t\t} else {\n\t\t\t\tstore.add(instance.capabilities.onDidAddCommandDetectionCapability(e => {\n\t\t\t\t\tsiNoneTimer.clear();\n\t\t\t\t\t// When command detection lights up, allow up to 200ms for the rich command\n\t\t\t\t\t// detection sequence to come in before declaring it as basic shell\n\t\t\t\t\t// integration.\n\t\t\t\t\tstore.add(disposableTimeout(() => {\n\t\t\t\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Timed out 200ms, using basic SI (via listener)`);\n\t\t\t\t\t\tresult.complete(ShellIntegrationQuality.Basic);\n\t\t\t\t\t}, 200));\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\tresult.p.finally(() => {\n\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Promise complete, disposing store`);\n\t\t\tstore.dispose();\n\t\t});\n\n\t\treturn result.p;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DeferredPromise, disposableTimeout, raceTimeout } from '../../../../../base/common/async.js';\nimport type { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../../base/common/codicons.js';\nimport { CancellationError } from '../../../../../base/common/errors.js';\nimport { Event } from '../../../../../base/common/event.js';\nimport { DisposableStore, MutableDisposable } from '../../../../../base/common/lifecycle.js';\nimport { ThemeIcon } from '../../../../../base/common/themables.js';\nimport { hasKey, isNumber, isObject, isString } from '../../../../../base/common/types.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { TerminalCapability } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { PromptInputState } from '../../../../../platform/terminal/common/capabilities/commandDetection/promptInputModel.js';\nimport { ITerminalLogService, ITerminalProfile, TerminalSettingId, type IShellLaunchConfig } from '../../../../../platform/terminal/common/terminal.js';\nimport { ITerminalService, type ITerminalInstance } from '../../../terminal/browser/terminal.js';\nimport { getShellIntegrationTimeout } from '../../../terminal/common/terminalEnvironment.js';\n\nconst enum ShellLaunchType {\n\tUnknown = 0,\n\tDefault = 1,\n\tFallback = 2,\n}\n\nexport const enum ShellIntegrationQuality {\n\tNone = 'none',\n\tBasic = 'basic',\n\tRich = 'rich',\n}\n\nexport interface IToolTerminal {\n\tinstance: ITerminalInstance;\n\tshellIntegrationQuality: ShellIntegrationQuality;\n\treceivedUserInput?: boolean;\n}\n\nexport class ToolTerminalCreator {\n\t/**\n\t * The shell preference cached for the lifetime of the window. This allows skipping previous\n\t * shell approaches that failed in previous runs to save time.\n\t */\n\tprivate static _lastSuccessfulShell: ShellLaunchType = ShellLaunchType.Unknown;\n\n\tconstructor(\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t\t@ITerminalService private readonly _terminalService: ITerminalService,\n\t) {\n\t}\n\n\tasync createTerminal(shellOrProfile: string | ITerminalProfile, token: CancellationToken): Promise<IToolTerminal> {\n\t\tconst instance = await this._createCopilotTerminal(shellOrProfile);\n\t\tconst toolTerminal: IToolTerminal = {\n\t\t\tinstance,\n\t\t\tshellIntegrationQuality: ShellIntegrationQuality.None,\n\t\t};\n\t\tlet processReadyTimestamp = 0;\n\n\t\t// Ensure the shell process launches successfully\n\t\tconst initResult = await Promise.any([\n\t\t\tinstance.processReady.then(() => processReadyTimestamp = Date.now()),\n\t\t\tEvent.toPromise(instance.onExit),\n\t\t]);\n\t\tif (!isNumber(initResult) && isObject(initResult) && hasKey(initResult, { message: true })) {\n\t\t\tthrow new Error(initResult.message);\n\t\t}\n\n\t\t// Wait for shell integration when the fallback case has not been hit or when shell\n\t\t// integration injection is enabled. Note that it's possible for the fallback case to happen\n\t\t// and then for SI to activate again later in the session.\n\t\tconst siInjectionEnabled = this._configurationService.getValue(TerminalSettingId.ShellIntegrationEnabled) === true;\n\n\t\t// Get the configurable timeout to wait for shell integration\n\t\tconst waitTime = getShellIntegrationTimeout(\n\t\t\tthis._configurationService,\n\t\t\tsiInjectionEnabled,\n\t\t\tinstance.hasRemoteAuthority,\n\t\t\tprocessReadyTimestamp\n\t\t);\n\n\t\tif (\n\t\t\tToolTerminalCreator._lastSuccessfulShell !== ShellLaunchType.Fallback ||\n\t\t\tsiInjectionEnabled\n\t\t) {\n\t\t\tthis._logService.info(`ToolTerminalCreator#createTerminal: Waiting ${waitTime}ms for shell integration`);\n\t\t\tconst shellIntegrationQuality = await this._waitForShellIntegration(instance, waitTime);\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tinstance.dispose();\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\n\t\t\t// If SI is rich, wait for the prompt state to change. This prevents an issue with pwsh\n\t\t\t// in particular where shell startup can swallow `\\r` input events, preventing the\n\t\t\t// command from executing.\n\t\t\tif (shellIntegrationQuality === ShellIntegrationQuality.Rich) {\n\t\t\t\tconst commandDetection = instance.capabilities.get(TerminalCapability.CommandDetection);\n\t\t\t\tif (commandDetection?.promptInputModel.state === PromptInputState.Unknown) {\n\t\t\t\t\tthis._logService.info(`ToolTerminalCreator#createTerminal: Waiting up to 2s for PromptInputModel state to change`);\n\t\t\t\t\tawait raceTimeout(Event.toPromise(commandDetection.onCommandStarted), 2000);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (shellIntegrationQuality !== ShellIntegrationQuality.None) {\n\t\t\t\tToolTerminalCreator._lastSuccessfulShell = ShellLaunchType.Default;\n\t\t\t\ttoolTerminal.shellIntegrationQuality = shellIntegrationQuality;\n\t\t\t\treturn toolTerminal;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._logService.info(`ToolTerminalCreator#createTerminal: Skipping wait for shell integration - last successful launch type ${ToolTerminalCreator._lastSuccessfulShell}`);\n\t\t}\n\n\t\t// Fallback case: No shell integration in default profile\n\t\tToolTerminalCreator._lastSuccessfulShell = ShellLaunchType.Fallback;\n\t\treturn toolTerminal;\n\t}\n\n\t/**\n\t * Synchronously update shell integration quality based on the terminal instance's current\n\t * capabilities. This is a defensive change to avoid no shell integration being sticky\n\t * https://github.com/microsoft/vscode/issues/260880\n\t *\n\t * Only upgrade quality just in case.\n\t */\n\trefreshShellIntegrationQuality(toolTerminal: IToolTerminal) {\n\t\tconst commandDetection = toolTerminal.instance.capabilities.get(TerminalCapability.CommandDetection);\n\t\tif (commandDetection) {\n\t\t\tif (\n\t\t\t\ttoolTerminal.shellIntegrationQuality === ShellIntegrationQuality.None ||\n\t\t\t\ttoolTerminal.shellIntegrationQuality === ShellIntegrationQuality.Basic\n\t\t\t) {\n\t\t\t\ttoolTerminal.shellIntegrationQuality = commandDetection.hasRichCommandDetection ? ShellIntegrationQuality.Rich : ShellIntegrationQuality.Basic;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _createCopilotTerminal(shellOrProfile: string | ITerminalProfile) {\n\t\tconst config: IShellLaunchConfig = {\n\t\t\ticon: ThemeIcon.fromId(Codicon.chatSparkle.id),\n\t\t\thideFromUser: true,\n\t\t\tforcePersist: true,\n\t\t\tenv: {\n\t\t\t\t// Avoid making `git diff` interactive when called from copilot\n\t\t\t\tGIT_PAGER: 'cat',\n\t\t\t}\n\t\t};\n\n\t\tif (isString(shellOrProfile)) {\n\t\t\tconfig.executable = shellOrProfile;\n\t\t} else {\n\t\t\tconfig.executable = shellOrProfile.path;\n\t\t\tconfig.args = shellOrProfile.args;\n\t\t\tconfig.icon = shellOrProfile.icon ?? config.icon;\n\t\t\tconfig.color = shellOrProfile.color;\n\t\t\tconfig.env = {\n\t\t\t\t...config.env,\n\t\t\t\t...shellOrProfile.env\n\t\t\t};\n\t\t}\n\n\t\treturn this._terminalService.createTerminal({ config });\n\t}\n\n\tprivate _waitForShellIntegration(\n\t\tinstance: ITerminalInstance,\n\t\ttimeoutMs: number\n\t): Promise<ShellIntegrationQuality> {\n\t\tconst store = new DisposableStore();\n\t\tconst result = new DeferredPromise<ShellIntegrationQuality>();\n\n\t\tconst siNoneTimer = store.add(new MutableDisposable());\n\t\tsiNoneTimer.value = disposableTimeout(() => {\n\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Timed out ${timeoutMs}ms, using no SI`);\n\t\t\tresult.complete(ShellIntegrationQuality.None);\n\t\t}, timeoutMs);\n\n\t\tif (instance.capabilities.get(TerminalCapability.CommandDetection)?.hasRichCommandDetection) {\n\t\t\t// Rich command detection is available immediately.\n\t\t\tsiNoneTimer.clear();\n\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Rich SI available immediately`);\n\t\t\tresult.complete(ShellIntegrationQuality.Rich);\n\t\t} else {\n\t\t\tconst onSetRichCommandDetection = store.add(this._terminalService.createOnInstanceCapabilityEvent(TerminalCapability.CommandDetection, e => e.onSetRichCommandDetection));\n\t\t\tstore.add(onSetRichCommandDetection.event((e) => {\n\t\t\t\tif (e.instance !== instance) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsiNoneTimer.clear();\n\t\t\t\t// Rich command detection becomes available some time after the terminal is created.\n\t\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Rich SI available eventually`);\n\t\t\t\tresult.complete(ShellIntegrationQuality.Rich);\n\t\t\t}));\n\n\t\t\tconst commandDetection = instance.capabilities.get(TerminalCapability.CommandDetection);\n\t\t\tif (commandDetection) {\n\t\t\t\tsiNoneTimer.clear();\n\t\t\t\t// When SI lights up, allow up to 200ms for the rich command\n\t\t\t\t// detection sequence to come in before declaring it as basic shell integration.\n\t\t\t\tstore.add(disposableTimeout(() => {\n\t\t\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Timed out 200ms, using basic SI`);\n\t\t\t\t\tresult.complete(ShellIntegrationQuality.Basic);\n\t\t\t\t}, 200));\n\t\t\t} else {\n\t\t\t\tstore.add(instance.capabilities.onDidAddCommandDetectionCapability(e => {\n\t\t\t\t\tsiNoneTimer.clear();\n\t\t\t\t\t// When command detection lights up, allow up to 200ms for the rich command\n\t\t\t\t\t// detection sequence to come in before declaring it as basic shell\n\t\t\t\t\t// integration.\n\t\t\t\t\tstore.add(disposableTimeout(() => {\n\t\t\t\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Timed out 200ms, using basic SI (via listener)`);\n\t\t\t\t\t\tresult.complete(ShellIntegrationQuality.Basic);\n\t\t\t\t\t}, 200));\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\tresult.p.finally(() => {\n\t\t\tthis._logService.info(`ToolTerminalCreator#_waitForShellIntegration: Promise complete, disposing store`);\n\t\t\tstore.dispose();\n\t\t});\n\n\t\treturn result.p;\n\t}\n}\n"]}