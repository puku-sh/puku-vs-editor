{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/chatAgentTools/browser/executeStrategy/basicExecuteStrategy.ts","vs/workbench/contrib/terminalContrib/chatAgentTools/browser/executeStrategy/basicExecuteStrategy.ts"],"names":[],"mappings":"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","file":"basicExecuteStrategy.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CancellationToken } from '../../../../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../../../base/common/event.js';\nimport { DisposableStore, MutableDisposable } from '../../../../../../base/common/lifecycle.js';\nimport { isNumber } from '../../../../../../base/common/types.js';\nimport type { ICommandDetectionCapability } from '../../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { ITerminalLogService } from '../../../../../../platform/terminal/common/terminal.js';\nimport { trackIdleOnPrompt, waitForIdle, type ITerminalExecuteStrategy, type ITerminalExecuteStrategyResult } from './executeStrategy.js';\nimport type { IMarker as IXtermMarker } from '@xterm/xterm';\nimport { ITerminalInstance } from '../../../../terminal/browser/terminal.js';\nimport { setupRecreatingStartMarker } from './strategyHelpers.js';\n\n/**\n * This strategy is used when shell integration is enabled, but rich command detection was not\n * declared by the shell script. This is the large spectrum between rich command detection and no\n * shell integration, here are some problems that are expected:\n *\n * - `133;C` command executed may not happen.\n * - `633;E` comamnd line reporting will likely not happen, so the command line contained in the\n *   execution start and end events will be of low confidence and chances are it will be wrong.\n * - Execution tracking may be incorrect, particularly when `executeCommand` calls are overlapped,\n *   such as Python activating the environment at the same time as Copilot executing a command. So\n *   the end event for the execution may actually correspond to a different command.\n *\n * This strategy focuses on trying to get the most accurate output given these limitations and\n * unknowns. Basically we cannot fully trust the extension APIs in this case, so polling of the data\n * stream is used to detect idling, and we listen to the terminal's data stream instead of the\n * execution's data stream.\n *\n * This is best effort with the goal being the output is accurate, though it may contain some\n * content above and below the command output, such as prompts or even possibly other command\n * output. We lean on the LLM to be able to differentiate the actual output from prompts and bad\n * output when it's not ideal.\n */\nexport class BasicExecuteStrategy implements ITerminalExecuteStrategy {\n\treadonly type = 'basic';\n\tprivate readonly _startMarker = new MutableDisposable<IXtermMarker>();\n\n\tprivate readonly _onDidCreateStartMarker = new Emitter<IXtermMarker | undefined>;\n\tpublic onDidCreateStartMarker: Event<IXtermMarker | undefined> = this._onDidCreateStartMarker.event;\n\n\n\tconstructor(\n\t\tprivate readonly _instance: ITerminalInstance,\n\t\tprivate readonly _hasReceivedUserInput: () => boolean,\n\t\tprivate readonly _commandDetection: ICommandDetectionCapability,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t) {\n\t}\n\n\tasync execute(commandLine: string, token: CancellationToken, commandId?: string): Promise<ITerminalExecuteStrategyResult> {\n\t\tconst store = new DisposableStore();\n\n\t\ttry {\n\t\t\tconst idlePromptPromise = trackIdleOnPrompt(this._instance, 1000, store);\n\t\t\tconst onDone = Promise.race([\n\t\t\t\tEvent.toPromise(this._commandDetection.onCommandFinished, store).then(e => {\n\t\t\t\t\t// When shell integration is basic, it means that the end execution event is\n\t\t\t\t\t// often misfired since we don't have command line verification. Because of this\n\t\t\t\t\t// we make sure the prompt is idle after the end execution event happens.\n\t\t\t\t\tthis._log('onDone 1 of 2 via end event, waiting for short idle prompt');\n\t\t\t\t\treturn idlePromptPromise.then(() => {\n\t\t\t\t\t\tthis._log('onDone 2 of 2 via short idle prompt');\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t'type': 'success',\n\t\t\t\t\t\t\tcommand: e\n\t\t\t\t\t\t} as const;\n\t\t\t\t\t});\n\t\t\t\t}),\n\t\t\t\tEvent.toPromise(token.onCancellationRequested as Event<undefined>, store).then(() => {\n\t\t\t\t\tthis._log('onDone via cancellation');\n\t\t\t\t}),\n\t\t\t\tEvent.toPromise(this._instance.onDisposed, store).then(() => {\n\t\t\t\t\tthis._log('onDone via terminal disposal');\n\t\t\t\t\treturn { type: 'disposal' } as const;\n\t\t\t\t}),\n\t\t\t\t// A longer idle prompt event is used here as a catch all for unexpected cases where\n\t\t\t\t// the end event doesn't fire for some reason.\n\t\t\t\ttrackIdleOnPrompt(this._instance, 3000, store).then(() => {\n\t\t\t\t\tthis._log('onDone long idle prompt');\n\t\t\t\t}),\n\t\t\t]);\n\n\t\t\t// Ensure xterm is available\n\t\t\tthis._log('Waiting for xterm');\n\t\t\tconst xterm = await this._instance.xtermReadyPromise;\n\t\t\tif (!xterm) {\n\t\t\t\tthrow new Error('Xterm is not available');\n\t\t\t}\n\n\t\t\t// Wait for the terminal to idle before executing the command\n\t\t\tthis._log('Waiting for idle');\n\t\t\tawait waitForIdle(this._instance.onData, 1000);\n\n\t\t\tsetupRecreatingStartMarker(\n\t\t\t\txterm,\n\t\t\t\tthis._startMarker,\n\t\t\t\tm => this._onDidCreateStartMarker.fire(m),\n\t\t\t\tstore,\n\t\t\t\tthis._log.bind(this)\n\t\t\t);\n\n\t\t\tif (this._hasReceivedUserInput()) {\n\t\t\t\tthis._log('Command timed out, sending SIGINT and retrying');\n\t\t\t\t// Send SIGINT (Ctrl+C)\n\t\t\t\tawait this._instance.sendText('\\x03', false);\n\t\t\t\tawait waitForIdle(this._instance.onData, 100);\n\t\t\t}\n\n\t\t\t// Execute the command\n\t\t\t// IMPORTANT: This uses `sendText` not `runCommand` since when basic shell integration\n\t\t\t// is used as it's more common to not recognize the prompt input which would result in\n\t\t\t// ^C being sent and also to return the exit code of 130 when from the shell when that\n\t\t\t// occurs.\n\t\t\tthis._log(`Executing command line \\`${commandLine}\\``);\n\t\t\tthis._instance.sendText(commandLine, true);\n\n\t\t\t// Wait for the next end execution event - note that this may not correspond to the actual\n\t\t\t// execution requested\n\t\t\tthis._log('Waiting for done event');\n\t\t\tconst onDoneResult = await onDone;\n\t\t\tif (onDoneResult && onDoneResult.type === 'disposal') {\n\t\t\t\tthrow new Error('The terminal was closed');\n\t\t\t}\n\t\t\tconst finishedCommand = onDoneResult && onDoneResult.type === 'success' ? onDoneResult.command : undefined;\n\n\t\t\t// Wait for the terminal to idle\n\t\t\tthis._log('Waiting for idle');\n\t\t\tawait waitForIdle(this._instance.onData, 1000);\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\t\t\tconst endMarker = store.add(xterm.raw.registerMarker());\n\n\t\t\t// Assemble final result\n\t\t\tlet output: string | undefined;\n\t\t\tconst additionalInformationLines: string[] = [];\n\t\t\tif (finishedCommand) {\n\t\t\t\tconst commandOutput = finishedCommand?.getOutput();\n\t\t\t\tif (commandOutput !== undefined) {\n\t\t\t\t\tthis._log('Fetched output via finished command');\n\t\t\t\t\toutput = commandOutput;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (output === undefined) {\n\t\t\t\ttry {\n\t\t\t\t\toutput = xterm.getContentsAsText(this._startMarker.value, endMarker);\n\t\t\t\t\tthis._log('Fetched output via markers');\n\t\t\t\t} catch {\n\t\t\t\t\tthis._log('Failed to fetch output via markers');\n\t\t\t\t\tadditionalInformationLines.push('Failed to retrieve command output');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (output !== undefined && output.trim().length === 0) {\n\t\t\t\tadditionalInformationLines.push('Command produced no output');\n\t\t\t}\n\n\t\t\tconst exitCode = finishedCommand?.exitCode;\n\t\t\tif (isNumber(exitCode) && exitCode > 0) {\n\t\t\t\tadditionalInformationLines.push(`Command exited with code ${exitCode}`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\toutput,\n\t\t\t\tadditionalInformation: additionalInformationLines.length > 0 ? additionalInformationLines.join('\\n') : undefined,\n\t\t\t\texitCode,\n\t\t\t};\n\t\t} finally {\n\t\t\tstore.dispose();\n\t\t}\n\t}\n\n\tprivate _log(message: string) {\n\t\tthis._logService.debug(`RunInTerminalTool#Basic: ${message}`);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CancellationToken } from '../../../../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../../../base/common/event.js';\nimport { DisposableStore, MutableDisposable } from '../../../../../../base/common/lifecycle.js';\nimport { isNumber } from '../../../../../../base/common/types.js';\nimport type { ICommandDetectionCapability } from '../../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { ITerminalLogService } from '../../../../../../platform/terminal/common/terminal.js';\nimport { trackIdleOnPrompt, waitForIdle, type ITerminalExecuteStrategy, type ITerminalExecuteStrategyResult } from './executeStrategy.js';\nimport type { IMarker as IXtermMarker } from '@xterm/xterm';\nimport { ITerminalInstance } from '../../../../terminal/browser/terminal.js';\nimport { setupRecreatingStartMarker } from './strategyHelpers.js';\n\n/**\n * This strategy is used when shell integration is enabled, but rich command detection was not\n * declared by the shell script. This is the large spectrum between rich command detection and no\n * shell integration, here are some problems that are expected:\n *\n * - `133;C` command executed may not happen.\n * - `633;E` comamnd line reporting will likely not happen, so the command line contained in the\n *   execution start and end events will be of low confidence and chances are it will be wrong.\n * - Execution tracking may be incorrect, particularly when `executeCommand` calls are overlapped,\n *   such as Python activating the environment at the same time as Copilot executing a command. So\n *   the end event for the execution may actually correspond to a different command.\n *\n * This strategy focuses on trying to get the most accurate output given these limitations and\n * unknowns. Basically we cannot fully trust the extension APIs in this case, so polling of the data\n * stream is used to detect idling, and we listen to the terminal's data stream instead of the\n * execution's data stream.\n *\n * This is best effort with the goal being the output is accurate, though it may contain some\n * content above and below the command output, such as prompts or even possibly other command\n * output. We lean on the LLM to be able to differentiate the actual output from prompts and bad\n * output when it's not ideal.\n */\nexport class BasicExecuteStrategy implements ITerminalExecuteStrategy {\n\treadonly type = 'basic';\n\tprivate readonly _startMarker = new MutableDisposable<IXtermMarker>();\n\n\tprivate readonly _onDidCreateStartMarker = new Emitter<IXtermMarker | undefined>;\n\tpublic onDidCreateStartMarker: Event<IXtermMarker | undefined> = this._onDidCreateStartMarker.event;\n\n\n\tconstructor(\n\t\tprivate readonly _instance: ITerminalInstance,\n\t\tprivate readonly _hasReceivedUserInput: () => boolean,\n\t\tprivate readonly _commandDetection: ICommandDetectionCapability,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t) {\n\t}\n\n\tasync execute(commandLine: string, token: CancellationToken, commandId?: string): Promise<ITerminalExecuteStrategyResult> {\n\t\tconst store = new DisposableStore();\n\n\t\ttry {\n\t\t\tconst idlePromptPromise = trackIdleOnPrompt(this._instance, 1000, store);\n\t\t\tconst onDone = Promise.race([\n\t\t\t\tEvent.toPromise(this._commandDetection.onCommandFinished, store).then(e => {\n\t\t\t\t\t// When shell integration is basic, it means that the end execution event is\n\t\t\t\t\t// often misfired since we don't have command line verification. Because of this\n\t\t\t\t\t// we make sure the prompt is idle after the end execution event happens.\n\t\t\t\t\tthis._log('onDone 1 of 2 via end event, waiting for short idle prompt');\n\t\t\t\t\treturn idlePromptPromise.then(() => {\n\t\t\t\t\t\tthis._log('onDone 2 of 2 via short idle prompt');\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t'type': 'success',\n\t\t\t\t\t\t\tcommand: e\n\t\t\t\t\t\t} as const;\n\t\t\t\t\t});\n\t\t\t\t}),\n\t\t\t\tEvent.toPromise(token.onCancellationRequested as Event<undefined>, store).then(() => {\n\t\t\t\t\tthis._log('onDone via cancellation');\n\t\t\t\t}),\n\t\t\t\tEvent.toPromise(this._instance.onDisposed, store).then(() => {\n\t\t\t\t\tthis._log('onDone via terminal disposal');\n\t\t\t\t\treturn { type: 'disposal' } as const;\n\t\t\t\t}),\n\t\t\t\t// A longer idle prompt event is used here as a catch all for unexpected cases where\n\t\t\t\t// the end event doesn't fire for some reason.\n\t\t\t\ttrackIdleOnPrompt(this._instance, 3000, store).then(() => {\n\t\t\t\t\tthis._log('onDone long idle prompt');\n\t\t\t\t}),\n\t\t\t]);\n\n\t\t\t// Ensure xterm is available\n\t\t\tthis._log('Waiting for xterm');\n\t\t\tconst xterm = await this._instance.xtermReadyPromise;\n\t\t\tif (!xterm) {\n\t\t\t\tthrow new Error('Xterm is not available');\n\t\t\t}\n\n\t\t\t// Wait for the terminal to idle before executing the command\n\t\t\tthis._log('Waiting for idle');\n\t\t\tawait waitForIdle(this._instance.onData, 1000);\n\n\t\t\tsetupRecreatingStartMarker(\n\t\t\t\txterm,\n\t\t\t\tthis._startMarker,\n\t\t\t\tm => this._onDidCreateStartMarker.fire(m),\n\t\t\t\tstore,\n\t\t\t\tthis._log.bind(this)\n\t\t\t);\n\n\t\t\tif (this._hasReceivedUserInput()) {\n\t\t\t\tthis._log('Command timed out, sending SIGINT and retrying');\n\t\t\t\t// Send SIGINT (Ctrl+C)\n\t\t\t\tawait this._instance.sendText('\\x03', false);\n\t\t\t\tawait waitForIdle(this._instance.onData, 100);\n\t\t\t}\n\n\t\t\t// Execute the command\n\t\t\t// IMPORTANT: This uses `sendText` not `runCommand` since when basic shell integration\n\t\t\t// is used as it's more common to not recognize the prompt input which would result in\n\t\t\t// ^C being sent and also to return the exit code of 130 when from the shell when that\n\t\t\t// occurs.\n\t\t\tthis._log(`Executing command line \\`${commandLine}\\``);\n\t\t\tthis._instance.sendText(commandLine, true);\n\n\t\t\t// Wait for the next end execution event - note that this may not correspond to the actual\n\t\t\t// execution requested\n\t\t\tthis._log('Waiting for done event');\n\t\t\tconst onDoneResult = await onDone;\n\t\t\tif (onDoneResult && onDoneResult.type === 'disposal') {\n\t\t\t\tthrow new Error('The terminal was closed');\n\t\t\t}\n\t\t\tconst finishedCommand = onDoneResult && onDoneResult.type === 'success' ? onDoneResult.command : undefined;\n\n\t\t\t// Wait for the terminal to idle\n\t\t\tthis._log('Waiting for idle');\n\t\t\tawait waitForIdle(this._instance.onData, 1000);\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\t\t\tconst endMarker = store.add(xterm.raw.registerMarker());\n\n\t\t\t// Assemble final result\n\t\t\tlet output: string | undefined;\n\t\t\tconst additionalInformationLines: string[] = [];\n\t\t\tif (finishedCommand) {\n\t\t\t\tconst commandOutput = finishedCommand?.getOutput();\n\t\t\t\tif (commandOutput !== undefined) {\n\t\t\t\t\tthis._log('Fetched output via finished command');\n\t\t\t\t\toutput = commandOutput;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (output === undefined) {\n\t\t\t\ttry {\n\t\t\t\t\toutput = xterm.getContentsAsText(this._startMarker.value, endMarker);\n\t\t\t\t\tthis._log('Fetched output via markers');\n\t\t\t\t} catch {\n\t\t\t\t\tthis._log('Failed to fetch output via markers');\n\t\t\t\t\tadditionalInformationLines.push('Failed to retrieve command output');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (output !== undefined && output.trim().length === 0) {\n\t\t\t\tadditionalInformationLines.push('Command produced no output');\n\t\t\t}\n\n\t\t\tconst exitCode = finishedCommand?.exitCode;\n\t\t\tif (isNumber(exitCode) && exitCode > 0) {\n\t\t\t\tadditionalInformationLines.push(`Command exited with code ${exitCode}`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\toutput,\n\t\t\t\tadditionalInformation: additionalInformationLines.length > 0 ? additionalInformationLines.join('\\n') : undefined,\n\t\t\t\texitCode,\n\t\t\t};\n\t\t} finally {\n\t\t\tstore.dispose();\n\t\t}\n\t}\n\n\tprivate _log(message: string) {\n\t\tthis._logService.debug(`RunInTerminalTool#Basic: ${message}`);\n\t}\n}\n"]}