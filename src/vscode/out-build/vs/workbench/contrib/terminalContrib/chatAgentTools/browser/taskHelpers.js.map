{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/chatAgentTools/browser/taskHelpers.ts","vs/workbench/contrib/terminalContrib/chatAgentTools/browser/taskHelpers.ts"],"names":[],"mappings":"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","file":"taskHelpers.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from '../../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { IStringDictionary } from '../../../../../base/common/collections.js';\nimport { MarkdownString } from '../../../../../base/common/htmlContent.js';\nimport { DisposableStore } from '../../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { IMarkerData } from '../../../../../platform/markers/common/markers.js';\nimport { IToolInvocationContext, ToolProgress } from '../../../chat/common/languageModelToolsService.js';\nimport { ConfiguringTask, ITaskDependency, Task } from '../../../tasks/common/tasks.js';\nimport { ITaskService } from '../../../tasks/common/taskService.js';\nimport { ITerminalInstance } from '../../../terminal/browser/terminal.js';\nimport { getOutput } from './outputHelpers.js';\nimport { OutputMonitor } from './tools/monitoring/outputMonitor.js';\nimport { IExecution, IPollingResult, OutputMonitorState } from './tools/monitoring/types.js';\nimport { Event } from '../../../../../base/common/event.js';\nimport { IReconnectionTaskData } from '../../../tasks/browser/terminalTaskSystem.js';\nimport { isString } from '../../../../../base/common/types.js';\n\n\nexport function getTaskDefinition(id: string) {\n\tconst idx = id.indexOf(': ');\n\tconst taskType = id.substring(0, idx);\n\tlet taskLabel = idx > 0 ? id.substring(idx + 2) : id;\n\n\tif (/^\\d+$/.test(taskLabel)) {\n\t\ttaskLabel = id;\n\t}\n\n\treturn { taskLabel, taskType };\n\n}\n\nexport function getTaskRepresentation(task: IConfiguredTask | Task): string {\n\tif ('label' in task && task.label) {\n\t\treturn task.label;\n\t} else if ('script' in task && task.script) {\n\t\treturn task.script;\n\t} else if ('command' in task && task.command) {\n\t\treturn isString(task.command) ? task.command : task.command.name?.toString() || '';\n\t}\n\treturn '';\n}\n\nexport function getTaskKey(task: Task): string {\n\treturn task.getKey() ?? task.getMapKey();\n}\n\nexport function tasksMatch(a: Task, b: Task): boolean {\n\tif (!a || !b) {\n\t\treturn false;\n\t}\n\n\tif (getTaskKey(a) === getTaskKey(b)) {\n\t\treturn true;\n\t}\n\n\tif (a.getCommonTaskId?.() === b.getCommonTaskId?.()) {\n\t\treturn true;\n\t}\n\n\treturn a._id === b._id;\n}\n\nexport async function getTaskForTool(id: string | undefined, taskDefinition: { taskLabel?: string; taskType?: string }, workspaceFolder: string, configurationService: IConfigurationService, taskService: ITaskService, allowParentTask?: boolean): Promise<Task | undefined> {\n\tlet index = 0;\n\tlet task: IConfiguredTask | undefined;\n\tconst workspaceFolderToTaskMap = await taskService.getWorkspaceTasks();\n\tlet configTasks: IConfiguredTask[] = [];\n\tfor (const folder of workspaceFolderToTaskMap.keys()) {\n\t\tconst tasksConfig = configurationService.getValue('tasks', { resource: URI.parse(folder) }) as { tasks: IConfiguredTask[] } | undefined;\n\t\tif (tasksConfig?.tasks) {\n\t\t\tconfigTasks = configTasks.concat(tasksConfig.tasks);\n\t\t}\n\t}\n\tfor (const configTask of configTasks) {\n\t\tif ((!allowParentTask && !configTask.type) || ('hide' in configTask && configTask.hide)) {\n\t\t\t// Skip these as they are not included in the agent prompt and we need to align with\n\t\t\t// the indices used there.\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((configTask.type && taskDefinition.taskType ? configTask.type === taskDefinition.taskType : true) &&\n\t\t\t((getTaskRepresentation(configTask) === taskDefinition?.taskLabel) || (id === configTask.label))) {\n\t\t\ttask = configTask;\n\t\t\tbreak;\n\t\t} else if (!configTask.label && id === `${configTask.type}: ${index}`) {\n\t\t\ttask = configTask;\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n\tif (!task) {\n\t\treturn;\n\t}\n\n\tlet tasksForWorkspace;\n\tconst workspaceFolderPath = URI.file(workspaceFolder).path;\n\tfor (const [folder, tasks] of workspaceFolderToTaskMap) {\n\t\tif (URI.parse(folder).path === workspaceFolderPath) {\n\t\t\ttasksForWorkspace = tasks;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!tasksForWorkspace) {\n\t\treturn;\n\t}\n\tconst configuringTasks: IStringDictionary<ConfiguringTask> | undefined = tasksForWorkspace.configurations?.byIdentifier;\n\tconst configuredTask: ConfiguringTask | undefined = Object.values(configuringTasks ?? {}).find(t => {\n\t\treturn t.type === task.type && (t._label === task.label || t._label === `${task.type}: ${getTaskRepresentation(task)}` || t._label === getTaskRepresentation(task));\n\t});\n\tlet resolvedTask: Task | undefined;\n\tif (configuredTask) {\n\t\tresolvedTask = await taskService.tryResolveTask(configuredTask);\n\t}\n\tif (!resolvedTask) {\n\t\tconst customTasks: Task[] | undefined = tasksForWorkspace.set?.tasks;\n\t\tresolvedTask = customTasks?.find(t => task.label === t._label || task.label === t._label);\n\t}\n\treturn resolvedTask;\n}\n\n/**\n * Represents a configured task in the system.\n *\n * This interface is used to define tasks that can be executed within the workspace.\n * It includes optional properties for identifying and describing the task.\n *\n * Properties:\n * - `type`: (optional) The type of the task, which categorizes it (e.g., \"build\", \"test\").\n * - `label`: (optional) A user-facing label for the task, typically used for display purposes.\n * - `script`: (optional) A script associated with the task, if applicable.\n * - `command`: (optional) A command associated with the task, if applicable.\n *\n */\nexport interface IConfiguredTask {\n\tlabel?: string;\n\ttype?: string;\n\tscript?: string;\n\tcommand?: string;\n\targs?: string[];\n\tisBackground?: boolean;\n\tproblemMatcher?: string[];\n\tgroup?: string;\n}\n\nexport async function resolveDependencyTasks(parentTask: Task, workspaceFolder: string, configurationService: IConfigurationService, taskService: ITaskService): Promise<Task[] | undefined> {\n\tif (!parentTask.configurationProperties?.dependsOn) {\n\t\treturn undefined;\n\t}\n\tconst dependencyTasks = await Promise.all(parentTask.configurationProperties.dependsOn.map(async (dep: ITaskDependency) => {\n\t\tconst depId: string | undefined = isString(dep.task) ? dep.task : dep.task?._key;\n\t\tif (!depId) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn await getTaskForTool(depId, { taskLabel: depId }, workspaceFolder, configurationService, taskService);\n\t}));\n\treturn dependencyTasks.filter((t: Task | undefined): t is Task => t !== undefined);\n}\n\n/**\n * Collects output, polling duration, and idle status for all terminals.\n */\nexport async function collectTerminalResults(\n\tterminals: ITerminalInstance[],\n\ttask: Task,\n\tinstantiationService: IInstantiationService,\n\tinvocationContext: IToolInvocationContext,\n\tprogress: ToolProgress,\n\ttoken: CancellationToken,\n\tdisposableStore: DisposableStore,\n\tisActive?: (task: Task) => Promise<boolean>,\n\tdependencyTasks?: Task[],\n\ttaskService?: ITaskService\n): Promise<Array<{\n\tname: string;\n\toutput: string;\n\tresources?: ILinkLocation[];\n\tpollDurationMs: number;\n\tstate: OutputMonitorState;\n\tinputToolManualAcceptCount: number;\n\tinputToolManualRejectCount: number;\n\tinputToolManualChars: number;\n\tinputToolManualShownCount: number;\n\tinputToolFreeFormInputShownCount: number;\n\tinputToolFreeFormInputCount: number;\n}>> {\n\tconst results: Array<{ state: OutputMonitorState; name: string; output: string; resources?: ILinkLocation[]; pollDurationMs: number; inputToolManualAcceptCount: number; inputToolManualRejectCount: number; inputToolManualChars: number; inputToolAutoAcceptCount: number; inputToolAutoChars: number; inputToolManualShownCount: number; inputToolFreeFormInputCount: number; inputToolFreeFormInputShownCount: number }> = [];\n\tif (token.isCancellationRequested) {\n\t\treturn results;\n\t}\n\n\tconst commonTaskIdToTaskMap: { [key: string]: Task } = {};\n\tconst taskIdToTaskMap: { [key: string]: Task } = {};\n\tconst taskLabelToTaskMap: { [key: string]: Task } = {};\n\n\tfor (const dependencyTask of dependencyTasks ?? []) {\n\t\tcommonTaskIdToTaskMap[dependencyTask.getCommonTaskId()] = dependencyTask;\n\t\ttaskIdToTaskMap[dependencyTask._id] = dependencyTask;\n\t\ttaskLabelToTaskMap[dependencyTask._label] = dependencyTask;\n\t}\n\n\tfor (const instance of terminals) {\n\t\tprogress.report({ message: new MarkdownString(`Checking output for \\`${instance.shellLaunchConfig.name ?? 'unknown'}\\``) });\n\n\t\tlet terminalTask = task;\n\n\t\t// For composite tasks, find the actual dependency task running in this terminal\n\t\tif (dependencyTasks?.length) {\n\t\t\t// Use reconnection data if possible to match, since the properties here are unique\n\t\t\tconst reconnectionData = instance.reconnectionProperties?.data as IReconnectionTaskData | undefined;\n\t\t\tif (reconnectionData) {\n\t\t\t\tif (reconnectionData.lastTask in commonTaskIdToTaskMap) {\n\t\t\t\t\tterminalTask = commonTaskIdToTaskMap[reconnectionData.lastTask];\n\t\t\t\t} else if (reconnectionData.id in taskIdToTaskMap) {\n\t\t\t\t\tterminalTask = taskIdToTaskMap[reconnectionData.id];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Otherwise, fallback to label matching\n\t\t\t\tif (instance.shellLaunchConfig.name && instance.shellLaunchConfig.name in taskLabelToTaskMap) {\n\t\t\t\t\tterminalTask = taskLabelToTaskMap[instance.shellLaunchConfig.name];\n\t\t\t\t} else if (instance.title in taskLabelToTaskMap) {\n\t\t\t\t\tterminalTask = taskLabelToTaskMap[instance.title];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst execution: IExecution = {\n\t\t\tgetOutput: () => getOutput(instance) ?? '',\n\t\t\ttask: terminalTask,\n\t\t\tisActive: isActive ? () => isActive(terminalTask) : undefined,\n\t\t\tinstance,\n\t\t\tdependencyTasks,\n\t\t\tsessionId: invocationContext.sessionId\n\t\t};\n\n\t\t// For tasks with problem matchers, wait until the task becomes busy before creating the output monitor\n\t\tif (terminalTask.configurationProperties.problemMatchers && terminalTask.configurationProperties.problemMatchers.length > 0 && taskService) {\n\t\t\tconst maxWaitTime = 1000; // Wait up to 1 second\n\t\t\tconst startTime = Date.now();\n\t\t\twhile (!token.isCancellationRequested && Date.now() - startTime < maxWaitTime) {\n\t\t\t\tconst busyTasks = await taskService.getBusyTasks();\n\t\t\t\tif (busyTasks.some(t => tasksMatch(t, terminalTask))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tawait timeout(100);\n\t\t\t}\n\t\t}\n\n\t\tconst outputMonitor = disposableStore.add(instantiationService.createInstance(OutputMonitor, execution, taskProblemPollFn, invocationContext, token, task._label));\n\t\tawait Event.toPromise(outputMonitor.onDidFinishCommand);\n\t\tconst pollingResult = outputMonitor.pollingResult;\n\t\tresults.push({\n\t\t\tname: instance.shellLaunchConfig.name ?? instance.title ?? 'unknown',\n\t\t\toutput: pollingResult?.output ?? '',\n\t\t\tpollDurationMs: pollingResult?.pollDurationMs ?? 0,\n\t\t\tresources: pollingResult?.resources,\n\t\t\tstate: pollingResult?.state || OutputMonitorState.Idle,\n\t\t\tinputToolManualAcceptCount: outputMonitor.outputMonitorTelemetryCounters.inputToolManualAcceptCount ?? 0,\n\t\t\tinputToolManualRejectCount: outputMonitor.outputMonitorTelemetryCounters.inputToolManualRejectCount ?? 0,\n\t\t\tinputToolManualChars: outputMonitor.outputMonitorTelemetryCounters.inputToolManualChars ?? 0,\n\t\t\tinputToolAutoAcceptCount: outputMonitor.outputMonitorTelemetryCounters.inputToolAutoAcceptCount ?? 0,\n\t\t\tinputToolAutoChars: outputMonitor.outputMonitorTelemetryCounters.inputToolAutoChars ?? 0,\n\t\t\tinputToolManualShownCount: outputMonitor.outputMonitorTelemetryCounters.inputToolManualShownCount ?? 0,\n\t\t\tinputToolFreeFormInputShownCount: outputMonitor.outputMonitorTelemetryCounters.inputToolFreeFormInputShownCount ?? 0,\n\t\t\tinputToolFreeFormInputCount: outputMonitor.outputMonitorTelemetryCounters.inputToolFreeFormInputCount ?? 0,\n\t\t});\n\t}\n\treturn results;\n}\n\nexport async function taskProblemPollFn(execution: IExecution, token: CancellationToken, taskService: ITaskService): Promise<IPollingResult | undefined> {\n\tif (token.isCancellationRequested) {\n\t\treturn;\n\t}\n\tif (execution.task) {\n\t\tconst data: Map<string, { resources: URI[]; markers: IMarkerData[] }> | undefined = taskService.getTaskProblems(execution.instance.instanceId);\n\t\tif (data) {\n\t\t\t// Problem matchers exist for this task\n\t\t\tconst problemList: string[] = [];\n\t\t\tconst resultResources: ILinkLocation[] = [];\n\t\t\tfor (const [owner, { resources, markers }] of data.entries()) {\n\t\t\t\tfor (let i = 0; i < markers.length; i++) {\n\t\t\t\t\tconst uri: URI | undefined = resources[i];\n\t\t\t\t\tconst marker = markers[i];\n\t\t\t\t\tresultResources.push({\n\t\t\t\t\t\turi,\n\t\t\t\t\t\trange: marker.startLineNumber !== undefined && marker.startColumn !== undefined && marker.endLineNumber !== undefined && marker.endColumn !== undefined\n\t\t\t\t\t\t\t? new Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn)\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t});\n\t\t\t\t\tconst message = marker.message ?? '';\n\t\t\t\t\tproblemList.push(`Problem: ${message} in ${uri.fsPath} coming from ${owner} starting on line ${marker.startLineNumber}${marker.startColumn ? `, column ${marker.startColumn} and ending on line ${marker.endLineNumber}${marker.endColumn ? `, column ${marker.endColumn}` : ''}` : ''}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (problemList.length === 0) {\n\t\t\t\tconst lastTenLines = execution.getOutput().split('\\n').filter(line => line !== '').slice(-10).join('\\n');\n\t\t\t\treturn {\n\t\t\t\t\tstate: OutputMonitorState.Idle,\n\t\t\t\t\toutput: `Task completed with output:\\n${lastTenLines}`,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: OutputMonitorState.Idle,\n\t\t\t\toutput: problemList.join('\\n'),\n\t\t\t\tresources: resultResources,\n\t\t\t};\n\t\t}\n\t}\n\tthrow new Error('Polling failed');\n}\n\nexport interface ILinkLocation { uri: URI; range?: Range }\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from '../../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { IStringDictionary } from '../../../../../base/common/collections.js';\nimport { MarkdownString } from '../../../../../base/common/htmlContent.js';\nimport { DisposableStore } from '../../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { IMarkerData } from '../../../../../platform/markers/common/markers.js';\nimport { IToolInvocationContext, ToolProgress } from '../../../chat/common/languageModelToolsService.js';\nimport { ConfiguringTask, ITaskDependency, Task } from '../../../tasks/common/tasks.js';\nimport { ITaskService } from '../../../tasks/common/taskService.js';\nimport { ITerminalInstance } from '../../../terminal/browser/terminal.js';\nimport { getOutput } from './outputHelpers.js';\nimport { OutputMonitor } from './tools/monitoring/outputMonitor.js';\nimport { IExecution, IPollingResult, OutputMonitorState } from './tools/monitoring/types.js';\nimport { Event } from '../../../../../base/common/event.js';\nimport { IReconnectionTaskData } from '../../../tasks/browser/terminalTaskSystem.js';\nimport { isString } from '../../../../../base/common/types.js';\n\n\nexport function getTaskDefinition(id: string) {\n\tconst idx = id.indexOf(': ');\n\tconst taskType = id.substring(0, idx);\n\tlet taskLabel = idx > 0 ? id.substring(idx + 2) : id;\n\n\tif (/^\\d+$/.test(taskLabel)) {\n\t\ttaskLabel = id;\n\t}\n\n\treturn { taskLabel, taskType };\n\n}\n\nexport function getTaskRepresentation(task: IConfiguredTask | Task): string {\n\tif ('label' in task && task.label) {\n\t\treturn task.label;\n\t} else if ('script' in task && task.script) {\n\t\treturn task.script;\n\t} else if ('command' in task && task.command) {\n\t\treturn isString(task.command) ? task.command : task.command.name?.toString() || '';\n\t}\n\treturn '';\n}\n\nexport function getTaskKey(task: Task): string {\n\treturn task.getKey() ?? task.getMapKey();\n}\n\nexport function tasksMatch(a: Task, b: Task): boolean {\n\tif (!a || !b) {\n\t\treturn false;\n\t}\n\n\tif (getTaskKey(a) === getTaskKey(b)) {\n\t\treturn true;\n\t}\n\n\tif (a.getCommonTaskId?.() === b.getCommonTaskId?.()) {\n\t\treturn true;\n\t}\n\n\treturn a._id === b._id;\n}\n\nexport async function getTaskForTool(id: string | undefined, taskDefinition: { taskLabel?: string; taskType?: string }, workspaceFolder: string, configurationService: IConfigurationService, taskService: ITaskService, allowParentTask?: boolean): Promise<Task | undefined> {\n\tlet index = 0;\n\tlet task: IConfiguredTask | undefined;\n\tconst workspaceFolderToTaskMap = await taskService.getWorkspaceTasks();\n\tlet configTasks: IConfiguredTask[] = [];\n\tfor (const folder of workspaceFolderToTaskMap.keys()) {\n\t\tconst tasksConfig = configurationService.getValue('tasks', { resource: URI.parse(folder) }) as { tasks: IConfiguredTask[] } | undefined;\n\t\tif (tasksConfig?.tasks) {\n\t\t\tconfigTasks = configTasks.concat(tasksConfig.tasks);\n\t\t}\n\t}\n\tfor (const configTask of configTasks) {\n\t\tif ((!allowParentTask && !configTask.type) || ('hide' in configTask && configTask.hide)) {\n\t\t\t// Skip these as they are not included in the agent prompt and we need to align with\n\t\t\t// the indices used there.\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((configTask.type && taskDefinition.taskType ? configTask.type === taskDefinition.taskType : true) &&\n\t\t\t((getTaskRepresentation(configTask) === taskDefinition?.taskLabel) || (id === configTask.label))) {\n\t\t\ttask = configTask;\n\t\t\tbreak;\n\t\t} else if (!configTask.label && id === `${configTask.type}: ${index}`) {\n\t\t\ttask = configTask;\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n\tif (!task) {\n\t\treturn;\n\t}\n\n\tlet tasksForWorkspace;\n\tconst workspaceFolderPath = URI.file(workspaceFolder).path;\n\tfor (const [folder, tasks] of workspaceFolderToTaskMap) {\n\t\tif (URI.parse(folder).path === workspaceFolderPath) {\n\t\t\ttasksForWorkspace = tasks;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!tasksForWorkspace) {\n\t\treturn;\n\t}\n\tconst configuringTasks: IStringDictionary<ConfiguringTask> | undefined = tasksForWorkspace.configurations?.byIdentifier;\n\tconst configuredTask: ConfiguringTask | undefined = Object.values(configuringTasks ?? {}).find(t => {\n\t\treturn t.type === task.type && (t._label === task.label || t._label === `${task.type}: ${getTaskRepresentation(task)}` || t._label === getTaskRepresentation(task));\n\t});\n\tlet resolvedTask: Task | undefined;\n\tif (configuredTask) {\n\t\tresolvedTask = await taskService.tryResolveTask(configuredTask);\n\t}\n\tif (!resolvedTask) {\n\t\tconst customTasks: Task[] | undefined = tasksForWorkspace.set?.tasks;\n\t\tresolvedTask = customTasks?.find(t => task.label === t._label || task.label === t._label);\n\t}\n\treturn resolvedTask;\n}\n\n/**\n * Represents a configured task in the system.\n *\n * This interface is used to define tasks that can be executed within the workspace.\n * It includes optional properties for identifying and describing the task.\n *\n * Properties:\n * - `type`: (optional) The type of the task, which categorizes it (e.g., \"build\", \"test\").\n * - `label`: (optional) A user-facing label for the task, typically used for display purposes.\n * - `script`: (optional) A script associated with the task, if applicable.\n * - `command`: (optional) A command associated with the task, if applicable.\n *\n */\nexport interface IConfiguredTask {\n\tlabel?: string;\n\ttype?: string;\n\tscript?: string;\n\tcommand?: string;\n\targs?: string[];\n\tisBackground?: boolean;\n\tproblemMatcher?: string[];\n\tgroup?: string;\n}\n\nexport async function resolveDependencyTasks(parentTask: Task, workspaceFolder: string, configurationService: IConfigurationService, taskService: ITaskService): Promise<Task[] | undefined> {\n\tif (!parentTask.configurationProperties?.dependsOn) {\n\t\treturn undefined;\n\t}\n\tconst dependencyTasks = await Promise.all(parentTask.configurationProperties.dependsOn.map(async (dep: ITaskDependency) => {\n\t\tconst depId: string | undefined = isString(dep.task) ? dep.task : dep.task?._key;\n\t\tif (!depId) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn await getTaskForTool(depId, { taskLabel: depId }, workspaceFolder, configurationService, taskService);\n\t}));\n\treturn dependencyTasks.filter((t: Task | undefined): t is Task => t !== undefined);\n}\n\n/**\n * Collects output, polling duration, and idle status for all terminals.\n */\nexport async function collectTerminalResults(\n\tterminals: ITerminalInstance[],\n\ttask: Task,\n\tinstantiationService: IInstantiationService,\n\tinvocationContext: IToolInvocationContext,\n\tprogress: ToolProgress,\n\ttoken: CancellationToken,\n\tdisposableStore: DisposableStore,\n\tisActive?: (task: Task) => Promise<boolean>,\n\tdependencyTasks?: Task[],\n\ttaskService?: ITaskService\n): Promise<Array<{\n\tname: string;\n\toutput: string;\n\tresources?: ILinkLocation[];\n\tpollDurationMs: number;\n\tstate: OutputMonitorState;\n\tinputToolManualAcceptCount: number;\n\tinputToolManualRejectCount: number;\n\tinputToolManualChars: number;\n\tinputToolManualShownCount: number;\n\tinputToolFreeFormInputShownCount: number;\n\tinputToolFreeFormInputCount: number;\n}>> {\n\tconst results: Array<{ state: OutputMonitorState; name: string; output: string; resources?: ILinkLocation[]; pollDurationMs: number; inputToolManualAcceptCount: number; inputToolManualRejectCount: number; inputToolManualChars: number; inputToolAutoAcceptCount: number; inputToolAutoChars: number; inputToolManualShownCount: number; inputToolFreeFormInputCount: number; inputToolFreeFormInputShownCount: number }> = [];\n\tif (token.isCancellationRequested) {\n\t\treturn results;\n\t}\n\n\tconst commonTaskIdToTaskMap: { [key: string]: Task } = {};\n\tconst taskIdToTaskMap: { [key: string]: Task } = {};\n\tconst taskLabelToTaskMap: { [key: string]: Task } = {};\n\n\tfor (const dependencyTask of dependencyTasks ?? []) {\n\t\tcommonTaskIdToTaskMap[dependencyTask.getCommonTaskId()] = dependencyTask;\n\t\ttaskIdToTaskMap[dependencyTask._id] = dependencyTask;\n\t\ttaskLabelToTaskMap[dependencyTask._label] = dependencyTask;\n\t}\n\n\tfor (const instance of terminals) {\n\t\tprogress.report({ message: new MarkdownString(`Checking output for \\`${instance.shellLaunchConfig.name ?? 'unknown'}\\``) });\n\n\t\tlet terminalTask = task;\n\n\t\t// For composite tasks, find the actual dependency task running in this terminal\n\t\tif (dependencyTasks?.length) {\n\t\t\t// Use reconnection data if possible to match, since the properties here are unique\n\t\t\tconst reconnectionData = instance.reconnectionProperties?.data as IReconnectionTaskData | undefined;\n\t\t\tif (reconnectionData) {\n\t\t\t\tif (reconnectionData.lastTask in commonTaskIdToTaskMap) {\n\t\t\t\t\tterminalTask = commonTaskIdToTaskMap[reconnectionData.lastTask];\n\t\t\t\t} else if (reconnectionData.id in taskIdToTaskMap) {\n\t\t\t\t\tterminalTask = taskIdToTaskMap[reconnectionData.id];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Otherwise, fallback to label matching\n\t\t\t\tif (instance.shellLaunchConfig.name && instance.shellLaunchConfig.name in taskLabelToTaskMap) {\n\t\t\t\t\tterminalTask = taskLabelToTaskMap[instance.shellLaunchConfig.name];\n\t\t\t\t} else if (instance.title in taskLabelToTaskMap) {\n\t\t\t\t\tterminalTask = taskLabelToTaskMap[instance.title];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst execution: IExecution = {\n\t\t\tgetOutput: () => getOutput(instance) ?? '',\n\t\t\ttask: terminalTask,\n\t\t\tisActive: isActive ? () => isActive(terminalTask) : undefined,\n\t\t\tinstance,\n\t\t\tdependencyTasks,\n\t\t\tsessionId: invocationContext.sessionId\n\t\t};\n\n\t\t// For tasks with problem matchers, wait until the task becomes busy before creating the output monitor\n\t\tif (terminalTask.configurationProperties.problemMatchers && terminalTask.configurationProperties.problemMatchers.length > 0 && taskService) {\n\t\t\tconst maxWaitTime = 1000; // Wait up to 1 second\n\t\t\tconst startTime = Date.now();\n\t\t\twhile (!token.isCancellationRequested && Date.now() - startTime < maxWaitTime) {\n\t\t\t\tconst busyTasks = await taskService.getBusyTasks();\n\t\t\t\tif (busyTasks.some(t => tasksMatch(t, terminalTask))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tawait timeout(100);\n\t\t\t}\n\t\t}\n\n\t\tconst outputMonitor = disposableStore.add(instantiationService.createInstance(OutputMonitor, execution, taskProblemPollFn, invocationContext, token, task._label));\n\t\tawait Event.toPromise(outputMonitor.onDidFinishCommand);\n\t\tconst pollingResult = outputMonitor.pollingResult;\n\t\tresults.push({\n\t\t\tname: instance.shellLaunchConfig.name ?? instance.title ?? 'unknown',\n\t\t\toutput: pollingResult?.output ?? '',\n\t\t\tpollDurationMs: pollingResult?.pollDurationMs ?? 0,\n\t\t\tresources: pollingResult?.resources,\n\t\t\tstate: pollingResult?.state || OutputMonitorState.Idle,\n\t\t\tinputToolManualAcceptCount: outputMonitor.outputMonitorTelemetryCounters.inputToolManualAcceptCount ?? 0,\n\t\t\tinputToolManualRejectCount: outputMonitor.outputMonitorTelemetryCounters.inputToolManualRejectCount ?? 0,\n\t\t\tinputToolManualChars: outputMonitor.outputMonitorTelemetryCounters.inputToolManualChars ?? 0,\n\t\t\tinputToolAutoAcceptCount: outputMonitor.outputMonitorTelemetryCounters.inputToolAutoAcceptCount ?? 0,\n\t\t\tinputToolAutoChars: outputMonitor.outputMonitorTelemetryCounters.inputToolAutoChars ?? 0,\n\t\t\tinputToolManualShownCount: outputMonitor.outputMonitorTelemetryCounters.inputToolManualShownCount ?? 0,\n\t\t\tinputToolFreeFormInputShownCount: outputMonitor.outputMonitorTelemetryCounters.inputToolFreeFormInputShownCount ?? 0,\n\t\t\tinputToolFreeFormInputCount: outputMonitor.outputMonitorTelemetryCounters.inputToolFreeFormInputCount ?? 0,\n\t\t});\n\t}\n\treturn results;\n}\n\nexport async function taskProblemPollFn(execution: IExecution, token: CancellationToken, taskService: ITaskService): Promise<IPollingResult | undefined> {\n\tif (token.isCancellationRequested) {\n\t\treturn;\n\t}\n\tif (execution.task) {\n\t\tconst data: Map<string, { resources: URI[]; markers: IMarkerData[] }> | undefined = taskService.getTaskProblems(execution.instance.instanceId);\n\t\tif (data) {\n\t\t\t// Problem matchers exist for this task\n\t\t\tconst problemList: string[] = [];\n\t\t\tconst resultResources: ILinkLocation[] = [];\n\t\t\tfor (const [owner, { resources, markers }] of data.entries()) {\n\t\t\t\tfor (let i = 0; i < markers.length; i++) {\n\t\t\t\t\tconst uri: URI | undefined = resources[i];\n\t\t\t\t\tconst marker = markers[i];\n\t\t\t\t\tresultResources.push({\n\t\t\t\t\t\turi,\n\t\t\t\t\t\trange: marker.startLineNumber !== undefined && marker.startColumn !== undefined && marker.endLineNumber !== undefined && marker.endColumn !== undefined\n\t\t\t\t\t\t\t? new Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn)\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t});\n\t\t\t\t\tconst message = marker.message ?? '';\n\t\t\t\t\tproblemList.push(`Problem: ${message} in ${uri.fsPath} coming from ${owner} starting on line ${marker.startLineNumber}${marker.startColumn ? `, column ${marker.startColumn} and ending on line ${marker.endLineNumber}${marker.endColumn ? `, column ${marker.endColumn}` : ''}` : ''}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (problemList.length === 0) {\n\t\t\t\tconst lastTenLines = execution.getOutput().split('\\n').filter(line => line !== '').slice(-10).join('\\n');\n\t\t\t\treturn {\n\t\t\t\t\tstate: OutputMonitorState.Idle,\n\t\t\t\t\toutput: `Task completed with output:\\n${lastTenLines}`,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: OutputMonitorState.Idle,\n\t\t\t\toutput: problemList.join('\\n'),\n\t\t\t\tresources: resultResources,\n\t\t\t};\n\t\t}\n\t}\n\tthrow new Error('Polling failed');\n}\n\nexport interface ILinkLocation { uri: URI; range?: Range }\n"]}