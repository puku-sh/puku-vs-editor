{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/chatAgentTools/browser/executeStrategy/noneExecuteStrategy.ts","vs/workbench/contrib/terminalContrib/chatAgentTools/browser/executeStrategy/noneExecuteStrategy.ts"],"names":[],"mappings":"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","file":"noneExecuteStrategy.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CancellationToken } from '../../../../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../../../base/common/event.js';\nimport { DisposableStore, MutableDisposable } from '../../../../../../base/common/lifecycle.js';\nimport { ITerminalLogService } from '../../../../../../platform/terminal/common/terminal.js';\nimport { waitForIdle, waitForIdleWithPromptHeuristics, type ITerminalExecuteStrategy, type ITerminalExecuteStrategyResult } from './executeStrategy.js';\nimport type { IMarker as IXtermMarker } from '@xterm/xterm';\nimport { ITerminalInstance } from '../../../../terminal/browser/terminal.js';\nimport { setupRecreatingStartMarker } from './strategyHelpers.js';\n\n/**\n * This strategy is used when no shell integration is available. There are very few extension APIs\n * available in this case. This uses similar strategies to the basic integration strategy, but\n * with `sendText` instead of `shellIntegration.executeCommand` and relying on idle events instead\n * of execution events.\n */\nexport class NoneExecuteStrategy implements ITerminalExecuteStrategy {\n\treadonly type = 'none';\n\tprivate readonly _startMarker = new MutableDisposable<IXtermMarker>();\n\n\n\tprivate readonly _onDidCreateStartMarker = new Emitter<IXtermMarker | undefined>;\n\tpublic onDidCreateStartMarker: Event<IXtermMarker | undefined> = this._onDidCreateStartMarker.event;\n\n\tconstructor(\n\t\tprivate readonly _instance: ITerminalInstance,\n\t\tprivate readonly _hasReceivedUserInput: () => boolean,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t) {\n\t}\n\n\tasync execute(commandLine: string, token: CancellationToken, commandId?: string): Promise<ITerminalExecuteStrategyResult> {\n\t\tconst store = new DisposableStore();\n\t\ttry {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\n\t\t\t// Ensure xterm is available\n\t\t\tthis._log('Waiting for xterm');\n\t\t\tconst xterm = await this._instance.xtermReadyPromise;\n\t\t\tif (!xterm) {\n\t\t\t\tthrow new Error('Xterm is not available');\n\t\t\t}\n\n\t\t\t// Wait for the terminal to idle before executing the command\n\t\t\tthis._log('Waiting for idle');\n\t\t\tawait waitForIdle(this._instance.onData, 1000);\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\n\t\t\tsetupRecreatingStartMarker(\n\t\t\t\txterm,\n\t\t\t\tthis._startMarker,\n\t\t\t\tm => this._onDidCreateStartMarker.fire(m),\n\t\t\t\tstore,\n\t\t\t\tthis._log.bind(this)\n\t\t\t);\n\n\t\t\tif (this._hasReceivedUserInput()) {\n\t\t\t\tthis._log('Command timed out, sending SIGINT and retrying');\n\t\t\t\t// Send SIGINT (Ctrl+C)\n\t\t\t\tawait this._instance.sendText('\\x03', false);\n\t\t\t\tawait waitForIdle(this._instance.onData, 100);\n\t\t\t}\n\n\t\t\t// Execute the command\n\t\t\t// IMPORTANT: This uses `sendText` not `runCommand` since when no shell integration\n\t\t\t// is used as sending ctrl+c before a shell is initialized (eg. PSReadLine) can result\n\t\t\t// in failure (https://github.com/microsoft/vscode/issues/258989)\n\t\t\tthis._log(`Executing command line \\`${commandLine}\\``);\n\t\t\tthis._instance.sendText(commandLine, true);\n\n\t\t\t// Assume the command is done when it's idle\n\t\t\tthis._log('Waiting for idle with prompt heuristics');\n\t\t\tconst promptResult = await waitForIdleWithPromptHeuristics(this._instance.onData, this._instance, 1000, 10000);\n\t\t\tthis._log(`Prompt detection result: ${promptResult.detected ? 'detected' : 'not detected'} - ${promptResult.reason}`);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\t\t\tconst endMarker = store.add(xterm.raw.registerMarker());\n\n\t\t\t// Assemble final result - exit code is not available without shell integration\n\t\t\tlet output: string | undefined;\n\t\t\tconst additionalInformationLines: string[] = [];\n\t\t\ttry {\n\t\t\t\toutput = xterm.getContentsAsText(this._startMarker.value, endMarker);\n\t\t\t\tthis._log('Fetched output via markers');\n\t\t\t} catch {\n\t\t\t\tthis._log('Failed to fetch output via markers');\n\t\t\t\tadditionalInformationLines.push('Failed to retrieve command output');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\toutput,\n\t\t\t\tadditionalInformation: additionalInformationLines.length > 0 ? additionalInformationLines.join('\\n') : undefined,\n\t\t\t\texitCode: undefined,\n\t\t\t};\n\t\t} finally {\n\t\t\tstore.dispose();\n\t\t}\n\t}\n\n\tprivate _log(message: string) {\n\t\tthis._logService.debug(`RunInTerminalTool#None: ${message}`);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CancellationToken } from '../../../../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../../../base/common/event.js';\nimport { DisposableStore, MutableDisposable } from '../../../../../../base/common/lifecycle.js';\nimport { ITerminalLogService } from '../../../../../../platform/terminal/common/terminal.js';\nimport { waitForIdle, waitForIdleWithPromptHeuristics, type ITerminalExecuteStrategy, type ITerminalExecuteStrategyResult } from './executeStrategy.js';\nimport type { IMarker as IXtermMarker } from '@xterm/xterm';\nimport { ITerminalInstance } from '../../../../terminal/browser/terminal.js';\nimport { setupRecreatingStartMarker } from './strategyHelpers.js';\n\n/**\n * This strategy is used when no shell integration is available. There are very few extension APIs\n * available in this case. This uses similar strategies to the basic integration strategy, but\n * with `sendText` instead of `shellIntegration.executeCommand` and relying on idle events instead\n * of execution events.\n */\nexport class NoneExecuteStrategy implements ITerminalExecuteStrategy {\n\treadonly type = 'none';\n\tprivate readonly _startMarker = new MutableDisposable<IXtermMarker>();\n\n\n\tprivate readonly _onDidCreateStartMarker = new Emitter<IXtermMarker | undefined>;\n\tpublic onDidCreateStartMarker: Event<IXtermMarker | undefined> = this._onDidCreateStartMarker.event;\n\n\tconstructor(\n\t\tprivate readonly _instance: ITerminalInstance,\n\t\tprivate readonly _hasReceivedUserInput: () => boolean,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t) {\n\t}\n\n\tasync execute(commandLine: string, token: CancellationToken, commandId?: string): Promise<ITerminalExecuteStrategyResult> {\n\t\tconst store = new DisposableStore();\n\t\ttry {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\n\t\t\t// Ensure xterm is available\n\t\t\tthis._log('Waiting for xterm');\n\t\t\tconst xterm = await this._instance.xtermReadyPromise;\n\t\t\tif (!xterm) {\n\t\t\t\tthrow new Error('Xterm is not available');\n\t\t\t}\n\n\t\t\t// Wait for the terminal to idle before executing the command\n\t\t\tthis._log('Waiting for idle');\n\t\t\tawait waitForIdle(this._instance.onData, 1000);\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\n\t\t\tsetupRecreatingStartMarker(\n\t\t\t\txterm,\n\t\t\t\tthis._startMarker,\n\t\t\t\tm => this._onDidCreateStartMarker.fire(m),\n\t\t\t\tstore,\n\t\t\t\tthis._log.bind(this)\n\t\t\t);\n\n\t\t\tif (this._hasReceivedUserInput()) {\n\t\t\t\tthis._log('Command timed out, sending SIGINT and retrying');\n\t\t\t\t// Send SIGINT (Ctrl+C)\n\t\t\t\tawait this._instance.sendText('\\x03', false);\n\t\t\t\tawait waitForIdle(this._instance.onData, 100);\n\t\t\t}\n\n\t\t\t// Execute the command\n\t\t\t// IMPORTANT: This uses `sendText` not `runCommand` since when no shell integration\n\t\t\t// is used as sending ctrl+c before a shell is initialized (eg. PSReadLine) can result\n\t\t\t// in failure (https://github.com/microsoft/vscode/issues/258989)\n\t\t\tthis._log(`Executing command line \\`${commandLine}\\``);\n\t\t\tthis._instance.sendText(commandLine, true);\n\n\t\t\t// Assume the command is done when it's idle\n\t\t\tthis._log('Waiting for idle with prompt heuristics');\n\t\t\tconst promptResult = await waitForIdleWithPromptHeuristics(this._instance.onData, this._instance, 1000, 10000);\n\t\t\tthis._log(`Prompt detection result: ${promptResult.detected ? 'detected' : 'not detected'} - ${promptResult.reason}`);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\tthrow new CancellationError();\n\t\t\t}\n\t\t\tconst endMarker = store.add(xterm.raw.registerMarker());\n\n\t\t\t// Assemble final result - exit code is not available without shell integration\n\t\t\tlet output: string | undefined;\n\t\t\tconst additionalInformationLines: string[] = [];\n\t\t\ttry {\n\t\t\t\toutput = xterm.getContentsAsText(this._startMarker.value, endMarker);\n\t\t\t\tthis._log('Fetched output via markers');\n\t\t\t} catch {\n\t\t\t\tthis._log('Failed to fetch output via markers');\n\t\t\t\tadditionalInformationLines.push('Failed to retrieve command output');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\toutput,\n\t\t\t\tadditionalInformation: additionalInformationLines.length > 0 ? additionalInformationLines.join('\\n') : undefined,\n\t\t\t\texitCode: undefined,\n\t\t\t};\n\t\t} finally {\n\t\t\tstore.dispose();\n\t\t}\n\t}\n\n\tprivate _log(message: string) {\n\t\tthis._logService.debug(`RunInTerminalTool#None: ${message}`);\n\t}\n}\n"]}