{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/chatAgentTools/browser/executeStrategy/executeStrategy.ts","vs/workbench/contrib/terminalContrib/chatAgentTools/browser/executeStrategy/executeStrategy.ts"],"names":[],"mappings":"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","file":"executeStrategy.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DeferredPromise, RunOnceScheduler } from '../../../../../../base/common/async.js';\nimport type { CancellationToken } from '../../../../../../base/common/cancellation.js';\nimport type { Event } from '../../../../../../base/common/event.js';\nimport { DisposableStore } from '../../../../../../base/common/lifecycle.js';\nimport type { ITerminalInstance } from '../../../../terminal/browser/terminal.js';\nimport type { IMarker as IXtermMarker } from '@xterm/xterm';\n\nexport interface ITerminalExecuteStrategy {\n\treadonly type: 'rich' | 'basic' | 'none';\n\t/**\n\t * Executes a command line and gets a result designed to be passed directly to an LLM. The\n\t * result will include information about the exit code.\n\t * @param commandLine The command line to execute\n\t * @param token Cancellation token\n\t * @param commandId Optional predefined command ID to link the command\n\t */\n\texecute(commandLine: string, token: CancellationToken, commandId?: string): Promise<ITerminalExecuteStrategyResult>;\n\n\treadonly onDidCreateStartMarker: Event<IXtermMarker | undefined>;\n}\n\nexport interface ITerminalExecuteStrategyResult {\n\toutput: string | undefined;\n\tadditionalInformation?: string;\n\texitCode?: number;\n\terror?: string;\n}\n\nexport async function waitForIdle(onData: Event<unknown>, idleDurationMs: number): Promise<void> {\n\t// This is basically Event.debounce but with an initial event to trigger the debounce\n\t// immediately\n\tconst store = new DisposableStore();\n\tconst deferred = new DeferredPromise<void>();\n\tconst scheduler = store.add(new RunOnceScheduler(() => deferred.complete(), idleDurationMs));\n\tstore.add(onData(() => scheduler.schedule()));\n\tscheduler.schedule();\n\treturn deferred.p.finally(() => store.dispose());\n}\n\nexport interface IPromptDetectionResult {\n\t/**\n\t * Whether a prompt was detected.\n\t */\n\tdetected: boolean;\n\t/**\n\t * The reason for logging.\n\t */\n\treason?: string;\n}\n\n/**\n * Detects if the given text content appears to end with a common prompt pattern.\n */\nexport function detectsCommonPromptPattern(cursorLine: string): IPromptDetectionResult {\n\tif (cursorLine.trim().length === 0) {\n\t\treturn { detected: false, reason: 'Content is empty or contains only whitespace' };\n\t}\n\n\t// PowerShell prompt: PS C:\\> or similar patterns\n\tif (/PS\\s+[A-Z]:\\\\.*>\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `PowerShell prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Command Prompt: C:\\path>\n\tif (/^[A-Z]:\\\\.*>\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Command Prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Bash-style prompts ending with $\n\tif (/\\$\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Bash-style prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Root prompts ending with #\n\tif (/#\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Root prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Python REPL prompt\n\tif (/^>>>\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Python REPL prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Custom prompts ending with the starship character (\\u276f)\n\tif (/\\u276f\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Starship prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Generic prompts ending with common prompt characters\n\tif (/[>%]\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Generic prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\treturn { detected: false, reason: `No common prompt pattern found in last line: \"${cursorLine}\"` };\n}\n\n/**\n * Enhanced version of {@link waitForIdle} that uses prompt detection heuristics. After the terminal\n * idles for the specified period, checks if the terminal's cursor line looks like a common prompt.\n * If not, extends the timeout to give the command more time to complete.\n */\nexport async function waitForIdleWithPromptHeuristics(\n\tonData: Event<unknown>,\n\tinstance: ITerminalInstance,\n\tidlePollIntervalMs: number,\n\textendedTimeoutMs: number,\n): Promise<IPromptDetectionResult> {\n\tawait waitForIdle(onData, idlePollIntervalMs);\n\n\tconst xterm = await instance.xtermReadyPromise;\n\tif (!xterm) {\n\t\treturn { detected: false, reason: `Xterm not available, using ${idlePollIntervalMs}ms timeout` };\n\t}\n\tconst startTime = Date.now();\n\n\t// Attempt to detect a prompt pattern after idle\n\twhile (Date.now() - startTime < extendedTimeoutMs) {\n\t\ttry {\n\t\t\tlet content = '';\n\t\t\tconst buffer = xterm.raw.buffer.active;\n\t\t\tconst line = buffer.getLine(buffer.baseY + buffer.cursorY);\n\t\t\tif (line) {\n\t\t\t\tcontent = line.translateToString(true);\n\t\t\t}\n\t\t\tconst promptResult = detectsCommonPromptPattern(content);\n\t\t\tif (promptResult.detected) {\n\t\t\t\treturn promptResult;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Continue polling even if there's an error reading terminal content\n\t\t}\n\t\tawait waitForIdle(onData, Math.min(idlePollIntervalMs, extendedTimeoutMs - (Date.now() - startTime)));\n\t}\n\n\t// Extended timeout reached without detecting a prompt\n\ttry {\n\t\tlet content = '';\n\t\tconst buffer = xterm.raw.buffer.active;\n\t\tconst line = buffer.getLine(buffer.baseY + buffer.cursorY);\n\t\tif (line) {\n\t\t\tcontent = line.translateToString(true) + '\\n';\n\t\t}\n\t\treturn { detected: false, reason: `Extended timeout reached without prompt detection. Last line: \"${content.trim()}\"` };\n\t} catch (error) {\n\t\treturn { detected: false, reason: `Extended timeout reached. Error reading terminal content: ${error}` };\n\t}\n}\n\n/**\n * Tracks the terminal for being idle on a prompt input. This must be called before `executeCommand`\n * is called.\n */\nexport async function trackIdleOnPrompt(\n\tinstance: ITerminalInstance,\n\tidleDurationMs: number,\n\tstore: DisposableStore,\n): Promise<void> {\n\tconst idleOnPrompt = new DeferredPromise<void>();\n\tconst onData = instance.onData;\n\tconst scheduler = store.add(new RunOnceScheduler(() => {\n\t\tidleOnPrompt.complete();\n\t}, idleDurationMs));\n\tlet state: TerminalState = TerminalState.Initial;\n\n\t// Fallback in case prompt sequences are not seen but the terminal goes idle.\n\tconst promptFallbackScheduler = store.add(new RunOnceScheduler(() => {\n\t\tif (state === TerminalState.Executing || state === TerminalState.PromptAfterExecuting) {\n\t\t\tpromptFallbackScheduler.cancel();\n\t\t\treturn;\n\t\t}\n\t\tstate = TerminalState.PromptAfterExecuting;\n\t\tscheduler.schedule();\n\t}, 1000));\n\t// Only schedule when a prompt sequence (A) is seen after an execute sequence (C). This prevents\n\t// cases where the command is executed before the prompt is written. While not perfect, sitting\n\t// on an A without a C following shortly after is a very good indicator that the command is done\n\t// and the terminal is idle. Note that D is treated as a signal for executed since shell\n\t// integration sometimes lacks the C sequence either due to limitations in the integation or the\n\t// required hooks aren't available.\n\tconst enum TerminalState {\n\t\tInitial,\n\t\tPrompt,\n\t\tExecuting,\n\t\tPromptAfterExecuting,\n\t}\n\tstore.add(onData(e => {\n\t\t// Update state\n\t\t// p10k fires C as `133;C;`\n\t\tconst matches = e.matchAll(/(?:\\x1b\\]|\\x9d)[16]33;(?<type>[ACD])(?:;.*)?(?:\\x1b\\\\|\\x07|\\x9c)/g);\n\t\tfor (const match of matches) {\n\t\t\tif (match.groups?.type === 'A') {\n\t\t\t\tif (state === TerminalState.Initial) {\n\t\t\t\t\tstate = TerminalState.Prompt;\n\t\t\t\t} else if (state === TerminalState.Executing) {\n\t\t\t\t\tstate = TerminalState.PromptAfterExecuting;\n\t\t\t\t}\n\t\t\t} else if (match.groups?.type === 'C' || match.groups?.type === 'D') {\n\t\t\t\tstate = TerminalState.Executing;\n\t\t\t}\n\t\t}\n\t\t// Re-schedule on every data event as we're tracking data idle\n\t\tif (state === TerminalState.PromptAfterExecuting) {\n\t\t\tpromptFallbackScheduler.cancel();\n\t\t\tscheduler.schedule();\n\t\t} else {\n\t\t\tscheduler.cancel();\n\t\t\tif (state === TerminalState.Initial || state === TerminalState.Prompt) {\n\t\t\t\tpromptFallbackScheduler.schedule();\n\t\t\t} else {\n\t\t\t\tpromptFallbackScheduler.cancel();\n\t\t\t}\n\t\t}\n\t}));\n\treturn idleOnPrompt.p;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DeferredPromise, RunOnceScheduler } from '../../../../../../base/common/async.js';\nimport type { CancellationToken } from '../../../../../../base/common/cancellation.js';\nimport type { Event } from '../../../../../../base/common/event.js';\nimport { DisposableStore } from '../../../../../../base/common/lifecycle.js';\nimport type { ITerminalInstance } from '../../../../terminal/browser/terminal.js';\nimport type { IMarker as IXtermMarker } from '@xterm/xterm';\n\nexport interface ITerminalExecuteStrategy {\n\treadonly type: 'rich' | 'basic' | 'none';\n\t/**\n\t * Executes a command line and gets a result designed to be passed directly to an LLM. The\n\t * result will include information about the exit code.\n\t * @param commandLine The command line to execute\n\t * @param token Cancellation token\n\t * @param commandId Optional predefined command ID to link the command\n\t */\n\texecute(commandLine: string, token: CancellationToken, commandId?: string): Promise<ITerminalExecuteStrategyResult>;\n\n\treadonly onDidCreateStartMarker: Event<IXtermMarker | undefined>;\n}\n\nexport interface ITerminalExecuteStrategyResult {\n\toutput: string | undefined;\n\tadditionalInformation?: string;\n\texitCode?: number;\n\terror?: string;\n}\n\nexport async function waitForIdle(onData: Event<unknown>, idleDurationMs: number): Promise<void> {\n\t// This is basically Event.debounce but with an initial event to trigger the debounce\n\t// immediately\n\tconst store = new DisposableStore();\n\tconst deferred = new DeferredPromise<void>();\n\tconst scheduler = store.add(new RunOnceScheduler(() => deferred.complete(), idleDurationMs));\n\tstore.add(onData(() => scheduler.schedule()));\n\tscheduler.schedule();\n\treturn deferred.p.finally(() => store.dispose());\n}\n\nexport interface IPromptDetectionResult {\n\t/**\n\t * Whether a prompt was detected.\n\t */\n\tdetected: boolean;\n\t/**\n\t * The reason for logging.\n\t */\n\treason?: string;\n}\n\n/**\n * Detects if the given text content appears to end with a common prompt pattern.\n */\nexport function detectsCommonPromptPattern(cursorLine: string): IPromptDetectionResult {\n\tif (cursorLine.trim().length === 0) {\n\t\treturn { detected: false, reason: 'Content is empty or contains only whitespace' };\n\t}\n\n\t// PowerShell prompt: PS C:\\> or similar patterns\n\tif (/PS\\s+[A-Z]:\\\\.*>\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `PowerShell prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Command Prompt: C:\\path>\n\tif (/^[A-Z]:\\\\.*>\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Command Prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Bash-style prompts ending with $\n\tif (/\\$\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Bash-style prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Root prompts ending with #\n\tif (/#\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Root prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Python REPL prompt\n\tif (/^>>>\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Python REPL prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Custom prompts ending with the starship character (\\u276f)\n\tif (/\\u276f\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Starship prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\t// Generic prompts ending with common prompt characters\n\tif (/[>%]\\s*$/.test(cursorLine)) {\n\t\treturn { detected: true, reason: `Generic prompt pattern detected: \"${cursorLine}\"` };\n\t}\n\n\treturn { detected: false, reason: `No common prompt pattern found in last line: \"${cursorLine}\"` };\n}\n\n/**\n * Enhanced version of {@link waitForIdle} that uses prompt detection heuristics. After the terminal\n * idles for the specified period, checks if the terminal's cursor line looks like a common prompt.\n * If not, extends the timeout to give the command more time to complete.\n */\nexport async function waitForIdleWithPromptHeuristics(\n\tonData: Event<unknown>,\n\tinstance: ITerminalInstance,\n\tidlePollIntervalMs: number,\n\textendedTimeoutMs: number,\n): Promise<IPromptDetectionResult> {\n\tawait waitForIdle(onData, idlePollIntervalMs);\n\n\tconst xterm = await instance.xtermReadyPromise;\n\tif (!xterm) {\n\t\treturn { detected: false, reason: `Xterm not available, using ${idlePollIntervalMs}ms timeout` };\n\t}\n\tconst startTime = Date.now();\n\n\t// Attempt to detect a prompt pattern after idle\n\twhile (Date.now() - startTime < extendedTimeoutMs) {\n\t\ttry {\n\t\t\tlet content = '';\n\t\t\tconst buffer = xterm.raw.buffer.active;\n\t\t\tconst line = buffer.getLine(buffer.baseY + buffer.cursorY);\n\t\t\tif (line) {\n\t\t\t\tcontent = line.translateToString(true);\n\t\t\t}\n\t\t\tconst promptResult = detectsCommonPromptPattern(content);\n\t\t\tif (promptResult.detected) {\n\t\t\t\treturn promptResult;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Continue polling even if there's an error reading terminal content\n\t\t}\n\t\tawait waitForIdle(onData, Math.min(idlePollIntervalMs, extendedTimeoutMs - (Date.now() - startTime)));\n\t}\n\n\t// Extended timeout reached without detecting a prompt\n\ttry {\n\t\tlet content = '';\n\t\tconst buffer = xterm.raw.buffer.active;\n\t\tconst line = buffer.getLine(buffer.baseY + buffer.cursorY);\n\t\tif (line) {\n\t\t\tcontent = line.translateToString(true) + '\\n';\n\t\t}\n\t\treturn { detected: false, reason: `Extended timeout reached without prompt detection. Last line: \"${content.trim()}\"` };\n\t} catch (error) {\n\t\treturn { detected: false, reason: `Extended timeout reached. Error reading terminal content: ${error}` };\n\t}\n}\n\n/**\n * Tracks the terminal for being idle on a prompt input. This must be called before `executeCommand`\n * is called.\n */\nexport async function trackIdleOnPrompt(\n\tinstance: ITerminalInstance,\n\tidleDurationMs: number,\n\tstore: DisposableStore,\n): Promise<void> {\n\tconst idleOnPrompt = new DeferredPromise<void>();\n\tconst onData = instance.onData;\n\tconst scheduler = store.add(new RunOnceScheduler(() => {\n\t\tidleOnPrompt.complete();\n\t}, idleDurationMs));\n\tlet state: TerminalState = TerminalState.Initial;\n\n\t// Fallback in case prompt sequences are not seen but the terminal goes idle.\n\tconst promptFallbackScheduler = store.add(new RunOnceScheduler(() => {\n\t\tif (state === TerminalState.Executing || state === TerminalState.PromptAfterExecuting) {\n\t\t\tpromptFallbackScheduler.cancel();\n\t\t\treturn;\n\t\t}\n\t\tstate = TerminalState.PromptAfterExecuting;\n\t\tscheduler.schedule();\n\t}, 1000));\n\t// Only schedule when a prompt sequence (A) is seen after an execute sequence (C). This prevents\n\t// cases where the command is executed before the prompt is written. While not perfect, sitting\n\t// on an A without a C following shortly after is a very good indicator that the command is done\n\t// and the terminal is idle. Note that D is treated as a signal for executed since shell\n\t// integration sometimes lacks the C sequence either due to limitations in the integation or the\n\t// required hooks aren't available.\n\tconst enum TerminalState {\n\t\tInitial,\n\t\tPrompt,\n\t\tExecuting,\n\t\tPromptAfterExecuting,\n\t}\n\tstore.add(onData(e => {\n\t\t// Update state\n\t\t// p10k fires C as `133;C;`\n\t\tconst matches = e.matchAll(/(?:\\x1b\\]|\\x9d)[16]33;(?<type>[ACD])(?:;.*)?(?:\\x1b\\\\|\\x07|\\x9c)/g);\n\t\tfor (const match of matches) {\n\t\t\tif (match.groups?.type === 'A') {\n\t\t\t\tif (state === TerminalState.Initial) {\n\t\t\t\t\tstate = TerminalState.Prompt;\n\t\t\t\t} else if (state === TerminalState.Executing) {\n\t\t\t\t\tstate = TerminalState.PromptAfterExecuting;\n\t\t\t\t}\n\t\t\t} else if (match.groups?.type === 'C' || match.groups?.type === 'D') {\n\t\t\t\tstate = TerminalState.Executing;\n\t\t\t}\n\t\t}\n\t\t// Re-schedule on every data event as we're tracking data idle\n\t\tif (state === TerminalState.PromptAfterExecuting) {\n\t\t\tpromptFallbackScheduler.cancel();\n\t\t\tscheduler.schedule();\n\t\t} else {\n\t\t\tscheduler.cancel();\n\t\t\tif (state === TerminalState.Initial || state === TerminalState.Prompt) {\n\t\t\t\tpromptFallbackScheduler.schedule();\n\t\t\t} else {\n\t\t\t\tpromptFallbackScheduler.cancel();\n\t\t\t}\n\t\t}\n\t}));\n\treturn idleOnPrompt.p;\n}\n"]}