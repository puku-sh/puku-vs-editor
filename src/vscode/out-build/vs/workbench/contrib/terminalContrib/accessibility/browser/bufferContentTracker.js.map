{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/accessibility/browser/bufferContentTracker.ts","vs/workbench/contrib/terminalContrib/accessibility/browser/bufferContentTracker.ts"],"names":[],"mappings":"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","file":"bufferContentTracker.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { ITerminalLogService, TerminalSettingId } from '../../../../../platform/terminal/common/terminal.js';\nimport { IXtermTerminal } from '../../../terminal/browser/terminal.js';\nimport type { IMarker, Terminal } from '@xterm/xterm';\n\nexport class BufferContentTracker extends Disposable {\n\t/**\n\t * Marks the last part of the buffer that was cached\n\t */\n\tprivate _lastCachedMarker: IMarker | undefined;\n\t/**\n\t * The number of wrapped lines in the viewport when the last cached marker was set\n\t */\n\tprivate _priorEditorViewportLineCount: number = 0;\n\n\tprivate _lines: string[] = [];\n\tget lines(): string[] { return this._lines; }\n\n\tbufferToEditorLineMapping: Map<number, number> = new Map();\n\n\tconstructor(\n\t\tprivate readonly _xterm: Pick<IXtermTerminal, 'getFont'> & { raw: Terminal },\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t) {\n\t\tsuper();\n\t}\n\n\treset(): void {\n\t\tthis._lines = [];\n\t\tthis._lastCachedMarker = undefined;\n\t\tthis.update();\n\t}\n\n\tupdate(): void {\n\t\tif (this._lastCachedMarker?.isDisposed) {\n\t\t\t// the terminal was cleared, reset the cache\n\t\t\tthis._lines = [];\n\t\t\tthis._lastCachedMarker = undefined;\n\t\t}\n\t\tthis._removeViewportContent();\n\t\tthis._updateCachedContent();\n\t\tthis._updateViewportContent();\n\t\tthis._lastCachedMarker = this._register(this._xterm.raw.registerMarker());\n\t\tthis._logService.debug('Buffer content tracker: set ', this._lines.length, ' lines');\n\t}\n\n\tprivate _updateCachedContent(): void {\n\t\tconst buffer = this._xterm.raw.buffer.active;\n\t\tconst start = this._lastCachedMarker?.line ? this._lastCachedMarker.line - this._xterm.raw.rows + 1 : 0;\n\t\tconst end = buffer.baseY;\n\t\tif (start < 0 || start > end) {\n\t\t\t// in the viewport, no need to cache\n\t\t\treturn;\n\t\t}\n\n\t\t// to keep the cache size down, remove any lines that are no longer in the scrollback\n\t\tconst scrollback: number = this._configurationService.getValue(TerminalSettingId.Scrollback);\n\t\tconst maxBufferSize = scrollback + this._xterm.raw.rows - 1;\n\t\tconst linesToAdd = end - start;\n\t\tif (linesToAdd + this._lines.length > maxBufferSize) {\n\t\t\tconst numToRemove = linesToAdd + this._lines.length - maxBufferSize;\n\t\t\tfor (let i = 0; i < numToRemove; i++) {\n\t\t\t\tthis._lines.shift();\n\t\t\t}\n\t\t\tthis._logService.debug('Buffer content tracker: removed ', numToRemove, ' lines from top of cached lines, now ', this._lines.length, ' lines');\n\t\t}\n\n\t\t// iterate through the buffer lines and add them to the editor line cache\n\t\tconst cachedLines = [];\n\t\tlet currentLine: string = '';\n\t\tfor (let i = start; i < end; i++) {\n\t\t\tconst line = buffer.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.bufferToEditorLineMapping.set(i, this._lines.length + cachedLines.length);\n\t\t\tconst isWrapped = buffer.getLine(i + 1)?.isWrapped;\n\t\t\tcurrentLine += line.translateToString(!isWrapped);\n\t\t\tif (currentLine && !isWrapped || i === (buffer.baseY + this._xterm.raw.rows - 1)) {\n\t\t\t\tif (line.length) {\n\t\t\t\t\tcachedLines.push(currentLine);\n\t\t\t\t\tcurrentLine = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._logService.debug('Buffer content tracker:', cachedLines.length, ' lines cached');\n\t\tthis._lines.push(...cachedLines);\n\t}\n\n\tprivate _removeViewportContent(): void {\n\t\tif (!this._lines.length) {\n\t\t\treturn;\n\t\t}\n\t\t// remove previous viewport content in case it has changed\n\t\tlet linesToRemove = this._priorEditorViewportLineCount;\n\t\tlet index = 1;\n\t\twhile (linesToRemove) {\n\t\t\tthis.bufferToEditorLineMapping.forEach((value, key) => { if (value === this._lines.length - index) { this.bufferToEditorLineMapping.delete(key); } });\n\t\t\tthis._lines.pop();\n\t\t\tindex++;\n\t\t\tlinesToRemove--;\n\t\t}\n\t\tthis._logService.debug('Buffer content tracker: removed lines from viewport, now ', this._lines.length, ' lines cached');\n\t}\n\n\tprivate _updateViewportContent(): void {\n\t\tconst buffer = this._xterm.raw.buffer.active;\n\t\tthis._priorEditorViewportLineCount = 0;\n\t\tlet currentLine: string = '';\n\t\tfor (let i = buffer.baseY; i < buffer.baseY + this._xterm.raw.rows; i++) {\n\t\t\tconst line = buffer.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.bufferToEditorLineMapping.set(i, this._lines.length);\n\t\t\tconst isWrapped = buffer.getLine(i + 1)?.isWrapped;\n\t\t\tcurrentLine += line.translateToString(!isWrapped);\n\t\t\tif (currentLine && !isWrapped || i === (buffer.baseY + this._xterm.raw.rows - 1)) {\n\t\t\t\tif (currentLine.length) {\n\t\t\t\t\tthis._priorEditorViewportLineCount++;\n\t\t\t\t\tthis._lines.push(currentLine);\n\t\t\t\t\tcurrentLine = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._logService.debug('Viewport content update complete, ', this._lines.length, ' lines in the viewport');\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { ITerminalLogService, TerminalSettingId } from '../../../../../platform/terminal/common/terminal.js';\nimport { IXtermTerminal } from '../../../terminal/browser/terminal.js';\nimport type { IMarker, Terminal } from '@xterm/xterm';\n\nexport class BufferContentTracker extends Disposable {\n\t/**\n\t * Marks the last part of the buffer that was cached\n\t */\n\tprivate _lastCachedMarker: IMarker | undefined;\n\t/**\n\t * The number of wrapped lines in the viewport when the last cached marker was set\n\t */\n\tprivate _priorEditorViewportLineCount: number = 0;\n\n\tprivate _lines: string[] = [];\n\tget lines(): string[] { return this._lines; }\n\n\tbufferToEditorLineMapping: Map<number, number> = new Map();\n\n\tconstructor(\n\t\tprivate readonly _xterm: Pick<IXtermTerminal, 'getFont'> & { raw: Terminal },\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t) {\n\t\tsuper();\n\t}\n\n\treset(): void {\n\t\tthis._lines = [];\n\t\tthis._lastCachedMarker = undefined;\n\t\tthis.update();\n\t}\n\n\tupdate(): void {\n\t\tif (this._lastCachedMarker?.isDisposed) {\n\t\t\t// the terminal was cleared, reset the cache\n\t\t\tthis._lines = [];\n\t\t\tthis._lastCachedMarker = undefined;\n\t\t}\n\t\tthis._removeViewportContent();\n\t\tthis._updateCachedContent();\n\t\tthis._updateViewportContent();\n\t\tthis._lastCachedMarker = this._register(this._xterm.raw.registerMarker());\n\t\tthis._logService.debug('Buffer content tracker: set ', this._lines.length, ' lines');\n\t}\n\n\tprivate _updateCachedContent(): void {\n\t\tconst buffer = this._xterm.raw.buffer.active;\n\t\tconst start = this._lastCachedMarker?.line ? this._lastCachedMarker.line - this._xterm.raw.rows + 1 : 0;\n\t\tconst end = buffer.baseY;\n\t\tif (start < 0 || start > end) {\n\t\t\t// in the viewport, no need to cache\n\t\t\treturn;\n\t\t}\n\n\t\t// to keep the cache size down, remove any lines that are no longer in the scrollback\n\t\tconst scrollback: number = this._configurationService.getValue(TerminalSettingId.Scrollback);\n\t\tconst maxBufferSize = scrollback + this._xterm.raw.rows - 1;\n\t\tconst linesToAdd = end - start;\n\t\tif (linesToAdd + this._lines.length > maxBufferSize) {\n\t\t\tconst numToRemove = linesToAdd + this._lines.length - maxBufferSize;\n\t\t\tfor (let i = 0; i < numToRemove; i++) {\n\t\t\t\tthis._lines.shift();\n\t\t\t}\n\t\t\tthis._logService.debug('Buffer content tracker: removed ', numToRemove, ' lines from top of cached lines, now ', this._lines.length, ' lines');\n\t\t}\n\n\t\t// iterate through the buffer lines and add them to the editor line cache\n\t\tconst cachedLines = [];\n\t\tlet currentLine: string = '';\n\t\tfor (let i = start; i < end; i++) {\n\t\t\tconst line = buffer.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.bufferToEditorLineMapping.set(i, this._lines.length + cachedLines.length);\n\t\t\tconst isWrapped = buffer.getLine(i + 1)?.isWrapped;\n\t\t\tcurrentLine += line.translateToString(!isWrapped);\n\t\t\tif (currentLine && !isWrapped || i === (buffer.baseY + this._xterm.raw.rows - 1)) {\n\t\t\t\tif (line.length) {\n\t\t\t\t\tcachedLines.push(currentLine);\n\t\t\t\t\tcurrentLine = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._logService.debug('Buffer content tracker:', cachedLines.length, ' lines cached');\n\t\tthis._lines.push(...cachedLines);\n\t}\n\n\tprivate _removeViewportContent(): void {\n\t\tif (!this._lines.length) {\n\t\t\treturn;\n\t\t}\n\t\t// remove previous viewport content in case it has changed\n\t\tlet linesToRemove = this._priorEditorViewportLineCount;\n\t\tlet index = 1;\n\t\twhile (linesToRemove) {\n\t\t\tthis.bufferToEditorLineMapping.forEach((value, key) => { if (value === this._lines.length - index) { this.bufferToEditorLineMapping.delete(key); } });\n\t\t\tthis._lines.pop();\n\t\t\tindex++;\n\t\t\tlinesToRemove--;\n\t\t}\n\t\tthis._logService.debug('Buffer content tracker: removed lines from viewport, now ', this._lines.length, ' lines cached');\n\t}\n\n\tprivate _updateViewportContent(): void {\n\t\tconst buffer = this._xterm.raw.buffer.active;\n\t\tthis._priorEditorViewportLineCount = 0;\n\t\tlet currentLine: string = '';\n\t\tfor (let i = buffer.baseY; i < buffer.baseY + this._xterm.raw.rows; i++) {\n\t\t\tconst line = buffer.getLine(i);\n\t\t\tif (!line) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.bufferToEditorLineMapping.set(i, this._lines.length);\n\t\t\tconst isWrapped = buffer.getLine(i + 1)?.isWrapped;\n\t\t\tcurrentLine += line.translateToString(!isWrapped);\n\t\t\tif (currentLine && !isWrapped || i === (buffer.baseY + this._xterm.raw.rows - 1)) {\n\t\t\t\tif (currentLine.length) {\n\t\t\t\t\tthis._priorEditorViewportLineCount++;\n\t\t\t\t\tthis._lines.push(currentLine);\n\t\t\t\t\tcurrentLine = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._logService.debug('Viewport content update complete, ', this._lines.length, ' lines in the viewport');\n\t}\n}\n"]}