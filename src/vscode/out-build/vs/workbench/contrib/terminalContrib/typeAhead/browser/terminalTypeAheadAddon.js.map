{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/typeAhead/browser/terminalTypeAheadAddon.ts","vs/workbench/contrib/terminalContrib/typeAhead/browser/terminalTypeAheadAddon.ts"],"names":[],"mappings":"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","file":"terminalTypeAheadAddon.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { disposableTimeout } from '../../../../../base/common/async.js';\nimport { Color, RGBA } from '../../../../../base/common/color.js';\nimport { debounce } from '../../../../../base/common/decorators.js';\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { ITelemetryService } from '../../../../../platform/telemetry/common/telemetry.js';\nimport { XtermAttributes, IXtermCore } from '../../../terminal/browser/xterm-private.js';\nimport { IBeforeProcessDataEvent, ITerminalProcessManager, TERMINAL_CONFIG_SECTION } from '../../../terminal/common/terminal.js';\nimport type { IBuffer, IBufferCell, IDisposable, ITerminalAddon, Terminal } from '@xterm/xterm';\nimport { DEFAULT_LOCAL_ECHO_EXCLUDE, type ITerminalTypeAheadConfiguration } from '../common/terminalTypeAheadConfiguration.js';\nimport { isNumber, type SingleOrMany } from '../../../../../base/common/types.js';\n\nconst enum VT {\n\tEsc = '\\x1b',\n\tCsi = `\\x1b[`,\n\tShowCursor = `\\x1b[?25h`,\n\tHideCursor = `\\x1b[?25l`,\n\tDeleteChar = `\\x1b[X`,\n\tDeleteRestOfLine = `\\x1b[K`,\n}\n\nconst CSI_STYLE_RE = /^\\x1b\\[[0-9;]*m/;\nconst CSI_MOVE_RE = /^\\x1b\\[?([0-9]*)(;[35])?O?([DC])/;\nconst NOT_WORD_RE = /[^a-z0-9]/i;\n\nconst enum StatsConstants {\n\tStatsBufferSize = 24,\n\tStatsSendTelemetryEvery = 1000 * 60 * 5, // how often to collect stats\n\tStatsMinSamplesToTurnOn = 5,\n\tStatsMinAccuracyToTurnOn = 0.3,\n\tStatsToggleOffThreshold = 0.5, // if latency is less than `threshold * this`, turn off\n}\n\n/**\n * Codes that should be omitted from sending to the prediction engine and instead omitted directly:\n * - Hide cursor (DECTCEM): We wrap the local echo sequence in hide and show\n *   CSI ? 2 5 l\n * - Show cursor (DECTCEM): We wrap the local echo sequence in hide and show\n *   CSI ? 2 5 h\n * - Device Status Report (DSR): These sequence fire report events from xterm which could cause\n *   double reporting and potentially a stack overflow (#119472)\n *   CSI Ps n\n *   CSI ? Ps n\n */\nconst PREDICTION_OMIT_RE = /^(\\x1b\\[(\\??25[hl]|\\??[0-9;]+n))+/;\n\nconst core = (terminal: Terminal): IXtermCore => {\n\tinterface XtermWithCore extends Terminal {\n\t\t_core: IXtermCore;\n\t}\n\treturn (terminal as XtermWithCore)._core;\n};\nconst flushOutput = (terminal: Terminal) => {\n\t// TODO: Flushing output is not possible anymore without async\n};\n\nconst enum CursorMoveDirection {\n\tBack = 'D',\n\tForwards = 'C',\n}\n\ninterface ICoordinate {\n\tx: number;\n\ty: number;\n\tbaseY: number;\n}\n\nclass Cursor implements ICoordinate {\n\tprivate _x = 0;\n\tprivate _y = 1;\n\tprivate _baseY = 1;\n\n\tget x() {\n\t\treturn this._x;\n\t}\n\n\tget y() {\n\t\treturn this._y;\n\t}\n\n\tget baseY() {\n\t\treturn this._baseY;\n\t}\n\n\tget coordinate(): ICoordinate {\n\t\treturn { x: this._x, y: this._y, baseY: this._baseY };\n\t}\n\n\tconstructor(\n\t\treadonly rows: number,\n\t\treadonly cols: number,\n\t\tprivate readonly _buffer: IBuffer\n\t) {\n\t\tthis._x = _buffer.cursorX;\n\t\tthis._y = _buffer.cursorY;\n\t\tthis._baseY = _buffer.baseY;\n\t}\n\n\tgetLine() {\n\t\treturn this._buffer.getLine(this._y + this._baseY);\n\t}\n\n\tgetCell(loadInto?: IBufferCell) {\n\t\treturn this.getLine()?.getCell(this._x, loadInto);\n\t}\n\n\tmoveTo(coordinate: ICoordinate) {\n\t\tthis._x = coordinate.x;\n\t\tthis._y = (coordinate.y + coordinate.baseY) - this._baseY;\n\t\treturn this.moveInstruction();\n\t}\n\n\tclone() {\n\t\tconst c = new Cursor(this.rows, this.cols, this._buffer);\n\t\tc.moveTo(this);\n\t\treturn c;\n\t}\n\n\tmove(x: number, y: number) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\treturn this.moveInstruction();\n\t}\n\n\tshift(x: number = 0, y: number = 0) {\n\t\tthis._x += x;\n\t\tthis._y += y;\n\t\treturn this.moveInstruction();\n\t}\n\n\tmoveInstruction() {\n\t\tif (this._y >= this.rows) {\n\t\t\tthis._baseY += this._y - (this.rows - 1);\n\t\t\tthis._y = this.rows - 1;\n\t\t} else if (this._y < 0) {\n\t\t\tthis._baseY -= this._y;\n\t\t\tthis._y = 0;\n\t\t}\n\n\t\treturn `${VT.Csi}${this._y + 1};${this._x + 1}H`;\n\t}\n}\n\nconst moveToWordBoundary = (b: IBuffer, cursor: Cursor, direction: -1 | 1) => {\n\tlet ateLeadingWhitespace = false;\n\tif (direction < 0) {\n\t\tcursor.shift(-1);\n\t}\n\n\tlet cell: IBufferCell | undefined;\n\twhile (cursor.x >= 0) {\n\t\tcell = cursor.getCell(cell);\n\t\tif (!cell?.getCode()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst chars = cell.getChars();\n\t\tif (NOT_WORD_RE.test(chars)) {\n\t\t\tif (ateLeadingWhitespace) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tateLeadingWhitespace = true;\n\t\t}\n\n\t\tcursor.shift(direction);\n\t}\n\n\tif (direction < 0) {\n\t\tcursor.shift(1); // we want to place the cursor after the whitespace starting the word\n\t}\n};\n\nconst enum MatchResult {\n\t/** matched successfully */\n\tSuccess,\n\t/** failed to match */\n\tFailure,\n\t/** buffer data, it might match in the future one more data comes in */\n\tBuffer,\n}\n\nexport interface IPrediction {\n\t/**\n\t * Whether applying this prediction can modify the style attributes of the\n\t * terminal. If so it means we need to reset the cursor style if it's\n\t * rolled back.\n\t */\n\treadonly affectsStyle?: boolean;\n\n\t/**\n\t * If set to false, the prediction will not be cleared if no input is\n\t * received from the server.\n\t */\n\treadonly clearAfterTimeout?: boolean;\n\n\t/**\n\t * Returns a sequence to apply the prediction.\n\t * @param buffer to write to\n\t * @param cursor position to write the data. Should advance the cursor.\n\t * @returns a string to be written to the user terminal, or optionally a\n\t * string for the user terminal and real pty.\n\t */\n\tapply(buffer: IBuffer, cursor: Cursor): string;\n\n\t/**\n\t * Returns a sequence to roll back a previous `apply()` call. If\n\t * `rollForwards` is not given, then this is also called if a prediction\n\t * is correct before show the user's data.\n\t */\n\trollback(cursor: Cursor): string;\n\n\t/**\n\t * If available, this will be called when the prediction is correct.\n\t */\n\trollForwards(cursor: Cursor, withInput: string): string;\n\n\t/**\n\t * Returns whether the given input is one expected by this prediction.\n\t * @param input reader for the input the PTY is giving\n\t * @param lookBehind the last successfully-made prediction, if any\n\t */\n\tmatches(input: StringReader, lookBehind?: IPrediction): MatchResult;\n}\n\nclass StringReader {\n\tindex = 0;\n\n\tget remaining() {\n\t\treturn this._input.length - this.index;\n\t}\n\n\tget eof() {\n\t\treturn this.index === this._input.length;\n\t}\n\n\tget rest() {\n\t\treturn this._input.slice(this.index);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _input: string\n\t) { }\n\n\t/**\n\t * Advances the reader and returns the character if it matches.\n\t */\n\teatChar(char: string) {\n\t\tif (this._input[this.index] !== char) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index++;\n\t\treturn char;\n\t}\n\n\t/**\n\t * Advances the reader and returns the string if it matches.\n\t */\n\teatStr(substr: string) {\n\t\tif (this._input.slice(this.index, substr.length) !== substr) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index += substr.length;\n\t\treturn substr;\n\t}\n\n\t/**\n\t * Matches and eats the substring character-by-character. If EOF is reached\n\t * before the substring is consumed, it will buffer. Index is not moved\n\t * if it's not a match.\n\t */\n\teatGradually(substr: string): MatchResult {\n\t\tconst prevIndex = this.index;\n\t\tfor (let i = 0; i < substr.length; i++) {\n\t\t\tif (i > 0 && this.eof) {\n\t\t\t\treturn MatchResult.Buffer;\n\t\t\t}\n\n\t\t\tif (!this.eatChar(substr[i])) {\n\t\t\t\tthis.index = prevIndex;\n\t\t\t\treturn MatchResult.Failure;\n\t\t\t}\n\t\t}\n\n\t\treturn MatchResult.Success;\n\t}\n\n\t/**\n\t * Advances the reader and returns the regex if it matches.\n\t */\n\teatRe(re: RegExp) {\n\t\tconst match = re.exec(this._input.slice(this.index));\n\t\tif (!match) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index += match[0].length;\n\t\treturn match;\n\t}\n\n\t/**\n\t * Advances the reader and returns the character if the code matches.\n\t */\n\teatCharCode(min = 0, max = min + 1) {\n\t\tconst code = this._input.charCodeAt(this.index);\n\t\tif (code < min || code >= max) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis.index++;\n\t\treturn code;\n\t}\n}\n\n/**\n * Preidction which never tests true. Will always discard predictions made\n * after it.\n */\nclass HardBoundary implements IPrediction {\n\treadonly clearAfterTimeout = false;\n\n\tapply() {\n\t\treturn '';\n\t}\n\n\trollback() {\n\t\treturn '';\n\t}\n\n\trollForwards() {\n\t\treturn '';\n\t}\n\n\tmatches() {\n\t\treturn MatchResult.Failure;\n\t}\n}\n\n/**\n * Wraps another prediction. Does not apply the prediction, but will pass\n * through its `matches` request.\n */\nclass TentativeBoundary implements IPrediction {\n\tprivate _appliedCursor?: Cursor;\n\n\tconstructor(readonly inner: IPrediction) { }\n\n\tapply(buffer: IBuffer, cursor: Cursor) {\n\t\tthis._appliedCursor = cursor.clone();\n\t\tthis.inner.apply(buffer, this._appliedCursor);\n\t\treturn '';\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tthis.inner.rollback(cursor.clone());\n\t\treturn '';\n\t}\n\n\trollForwards(cursor: Cursor, withInput: string) {\n\t\tif (this._appliedCursor) {\n\t\t\tcursor.moveTo(this._appliedCursor);\n\t\t}\n\n\t\treturn withInput;\n\t}\n\n\tmatches(input: StringReader) {\n\t\treturn this.inner.matches(input);\n\t}\n}\n\nconst isTenativeCharacterPrediction = (p: unknown): p is (TentativeBoundary & { inner: CharacterPrediction }) =>\n\tp instanceof TentativeBoundary && p.inner instanceof CharacterPrediction;\n\n/**\n * Prediction for a single alphanumeric character.\n */\nclass CharacterPrediction implements IPrediction {\n\treadonly affectsStyle = true;\n\n\tappliedAt?: {\n\t\tpos: ICoordinate;\n\t\toldAttributes: string;\n\t\toldChar: string;\n\t};\n\n\tconstructor(private readonly _style: TypeAheadStyle, private readonly _char: string) { }\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\tconst cell = cursor.getCell();\n\t\tthis.appliedAt = cell\n\t\t\t? { pos: cursor.coordinate, oldAttributes: attributesToSeq(cell), oldChar: cell.getChars() }\n\t\t\t: { pos: cursor.coordinate, oldAttributes: '', oldChar: '' };\n\n\t\tcursor.shift(1);\n\n\t\treturn this._style.apply + this._char + this._style.undo;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this.appliedAt) {\n\t\t\treturn ''; // not applied\n\t\t}\n\n\t\tconst { oldAttributes, oldChar, pos } = this.appliedAt;\n\t\tconst r = cursor.moveTo(pos) + (oldChar ? `${oldAttributes}${oldChar}${cursor.moveTo(pos)}` : VT.DeleteChar);\n\t\treturn r;\n\t}\n\n\trollForwards(cursor: Cursor, input: string) {\n\t\tif (!this.appliedAt) {\n\t\t\treturn ''; // not applied\n\t\t}\n\n\t\treturn cursor.clone().moveTo(this.appliedAt.pos) + input;\n\t}\n\n\tmatches(input: StringReader, lookBehind?: IPrediction) {\n\t\tconst startIndex = input.index;\n\n\t\t// remove any styling CSI before checking the char\n\t\twhile (input.eatRe(CSI_STYLE_RE)) { }\n\n\t\tif (input.eof) {\n\t\t\treturn MatchResult.Buffer;\n\t\t}\n\n\t\tif (input.eatChar(this._char)) {\n\t\t\treturn MatchResult.Success;\n\t\t}\n\n\t\tif (lookBehind instanceof CharacterPrediction) {\n\t\t\t// see #112842\n\t\t\tconst sillyZshOutcome = input.eatGradually(`\\b${lookBehind._char}${this._char}`);\n\t\t\tif (sillyZshOutcome !== MatchResult.Failure) {\n\t\t\t\treturn sillyZshOutcome;\n\t\t\t}\n\t\t}\n\n\t\tinput.index = startIndex;\n\t\treturn MatchResult.Failure;\n\t}\n}\n\nclass BackspacePrediction implements IPrediction {\n\tprotected _appliedAt?: {\n\t\tpos: ICoordinate;\n\t\toldAttributes: string;\n\t\toldChar: string;\n\t\tisLastChar: boolean;\n\t};\n\n\tconstructor(private readonly _terminal: Terminal) { }\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\t// at eol if everything to the right is whitespace (zsh will emit a \"clear line\" code in this case)\n\t\t// todo: can be optimized if `getTrimmedLength` is exposed from xterm\n\t\tconst isLastChar = !cursor.getLine()?.translateToString(undefined, cursor.x).trim();\n\t\tconst pos = cursor.coordinate;\n\t\tconst move = cursor.shift(-1);\n\t\tconst cell = cursor.getCell();\n\t\tthis._appliedAt = cell\n\t\t\t? { isLastChar, pos, oldAttributes: attributesToSeq(cell), oldChar: cell.getChars() }\n\t\t\t: { isLastChar, pos, oldAttributes: '', oldChar: '' };\n\n\t\treturn move + VT.DeleteChar;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this._appliedAt) {\n\t\t\treturn ''; // not applied\n\t\t}\n\n\t\tconst { oldAttributes, oldChar, pos } = this._appliedAt;\n\t\tif (!oldChar) {\n\t\t\treturn cursor.moveTo(pos) + VT.DeleteChar;\n\t\t}\n\n\t\treturn oldAttributes + oldChar + cursor.moveTo(pos) + attributesToSeq(core(this._terminal)._inputHandler._curAttrData);\n\t}\n\n\trollForwards() {\n\t\treturn '';\n\t}\n\n\tmatches(input: StringReader) {\n\t\tif (this._appliedAt?.isLastChar) {\n\t\t\tconst r1 = input.eatGradually(`\\b${VT.Csi}K`);\n\t\t\tif (r1 !== MatchResult.Failure) {\n\t\t\t\treturn r1;\n\t\t\t}\n\n\t\t\tconst r2 = input.eatGradually(`\\b \\b`);\n\t\t\tif (r2 !== MatchResult.Failure) {\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t}\n\n\t\treturn MatchResult.Failure;\n\t}\n}\n\nclass NewlinePrediction implements IPrediction {\n\tprotected _prevPosition?: ICoordinate;\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\tthis._prevPosition = cursor.coordinate;\n\t\tcursor.move(0, cursor.y + 1);\n\t\treturn '\\r\\n';\n\t}\n\n\trollback(cursor: Cursor) {\n\t\treturn this._prevPosition ? cursor.moveTo(this._prevPosition) : '';\n\t}\n\n\trollForwards() {\n\t\treturn ''; // does not need to rewrite\n\t}\n\n\tmatches(input: StringReader) {\n\t\treturn input.eatGradually('\\r\\n');\n\t}\n}\n\n/**\n * Prediction when the cursor reaches the end of the line. Similar to newline\n * prediction, but shells handle it slightly differently.\n */\nclass LinewrapPrediction extends NewlinePrediction implements IPrediction {\n\toverride apply(_: IBuffer, cursor: Cursor) {\n\t\tthis._prevPosition = cursor.coordinate;\n\t\tcursor.move(0, cursor.y + 1);\n\t\treturn ' \\r';\n\t}\n\n\toverride matches(input: StringReader) {\n\t\t// bash and zshell add a space which wraps in the terminal, then a CR\n\t\tconst r = input.eatGradually(' \\r');\n\t\tif (r !== MatchResult.Failure) {\n\t\t\t// zshell additionally adds a clear line after wrapping to be safe -- eat it\n\t\t\tconst r2 = input.eatGradually(VT.DeleteRestOfLine);\n\t\t\treturn r2 === MatchResult.Buffer ? MatchResult.Buffer : r;\n\t\t}\n\n\t\treturn input.eatGradually('\\r\\n');\n\t}\n}\n\nclass CursorMovePrediction implements IPrediction {\n\tprivate _applied?: {\n\t\trollForward: string;\n\t\tprevPosition: number;\n\t\tprevAttrs: string;\n\t\tamount: number;\n\t};\n\n\tconstructor(\n\t\tprivate readonly _direction: CursorMoveDirection,\n\t\tprivate readonly _moveByWords: boolean,\n\t\tprivate readonly _amount: number,\n\t) { }\n\n\tapply(buffer: IBuffer, cursor: Cursor) {\n\t\tconst prevPosition = cursor.x;\n\t\tconst currentCell = cursor.getCell();\n\t\tconst prevAttrs = currentCell ? attributesToSeq(currentCell) : '';\n\n\t\tconst { _amount: amount, _direction: direction, _moveByWords: moveByWords } = this;\n\t\tconst delta = direction === CursorMoveDirection.Back ? -1 : 1;\n\n\t\tconst target = cursor.clone();\n\t\tif (moveByWords) {\n\t\t\tfor (let i = 0; i < amount; i++) {\n\t\t\t\tmoveToWordBoundary(buffer, target, delta);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.shift(delta * amount);\n\t\t}\n\n\t\tthis._applied = {\n\t\t\tamount: Math.abs(cursor.x - target.x),\n\t\t\tprevPosition,\n\t\t\tprevAttrs,\n\t\t\trollForward: cursor.moveTo(target),\n\t\t};\n\n\t\treturn this._applied.rollForward;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this._applied) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn cursor.move(this._applied.prevPosition, cursor.y) + this._applied.prevAttrs;\n\t}\n\n\trollForwards() {\n\t\treturn ''; // does not need to rewrite\n\t}\n\n\tmatches(input: StringReader) {\n\t\tif (!this._applied) {\n\t\t\treturn MatchResult.Failure;\n\t\t}\n\n\t\tconst direction = this._direction;\n\t\tconst { amount, rollForward } = this._applied;\n\n\n\t\t// arg can be omitted to move one character. We don't eatGradually() here\n\t\t// or below moves that don't go as far as the cursor would be buffered\n\t\t// indefinitely\n\t\tif (input.eatStr(`${VT.Csi}${direction}`.repeat(amount))) {\n\t\t\treturn MatchResult.Success;\n\t\t}\n\n\t\t// \\b is the equivalent to moving one character back\n\t\tif (direction === CursorMoveDirection.Back) {\n\t\t\tif (input.eatStr(`\\b`.repeat(amount))) {\n\t\t\t\treturn MatchResult.Success;\n\t\t\t}\n\t\t}\n\n\t\t// check if the cursor position is set absolutely\n\t\tif (rollForward) {\n\t\t\tconst r = input.eatGradually(rollForward);\n\t\t\tif (r !== MatchResult.Failure) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\t// check for a relative move in the direction\n\t\treturn input.eatGradually(`${VT.Csi}${amount}${direction}`);\n\t}\n}\n\nexport class PredictionStats extends Disposable {\n\tprivate readonly _stats: [latency: number, correct: boolean][] = [];\n\tprivate _index = 0;\n\tprivate readonly _addedAtTime = new WeakMap<IPrediction, number>();\n\tprivate readonly _changeEmitter = new Emitter<void>();\n\treadonly onChange = this._changeEmitter.event;\n\n\t/**\n\t * Gets the percent (0-1) of predictions that were accurate.\n\t */\n\tget accuracy() {\n\t\tlet correctCount = 0;\n\t\tfor (const [, correct] of this._stats) {\n\t\t\tif (correct) {\n\t\t\t\tcorrectCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn correctCount / (this._stats.length || 1);\n\t}\n\n\t/**\n\t * Gets the number of recorded stats.\n\t */\n\tget sampleSize() {\n\t\treturn this._stats.length;\n\t}\n\n\t/**\n\t * Gets latency stats of successful predictions.\n\t */\n\tget latency() {\n\t\tconst latencies = this._stats.filter(([, correct]) => correct).map(([s]) => s).sort();\n\n\t\treturn {\n\t\t\tcount: latencies.length,\n\t\t\tmin: latencies[0],\n\t\t\tmedian: latencies[Math.floor(latencies.length / 2)],\n\t\t\tmax: latencies[latencies.length - 1],\n\t\t};\n\t}\n\n\t/**\n\t * Gets the maximum observed latency.\n\t */\n\tget maxLatency() {\n\t\tlet max = -Infinity;\n\t\tfor (const [latency, correct] of this._stats) {\n\t\t\tif (correct) {\n\t\t\t\tmax = Math.max(latency, max);\n\t\t\t}\n\t\t}\n\n\t\treturn max;\n\t}\n\n\tconstructor(timeline: PredictionTimeline) {\n\t\tsuper();\n\t\tthis._register(timeline.onPredictionAdded(p => this._addedAtTime.set(p, Date.now())));\n\t\tthis._register(timeline.onPredictionSucceeded(this._pushStat.bind(this, true)));\n\t\tthis._register(timeline.onPredictionFailed(this._pushStat.bind(this, false)));\n\t}\n\n\tprivate _pushStat(correct: boolean, prediction: IPrediction) {\n\t\tconst started = this._addedAtTime.get(prediction)!;\n\t\tthis._stats[this._index] = [Date.now() - started, correct];\n\t\tthis._index = (this._index + 1) % StatsConstants.StatsBufferSize;\n\t\tthis._changeEmitter.fire();\n\t}\n}\n\nexport class PredictionTimeline {\n\t/**\n\t * Expected queue of events. Only predictions for the lowest are\n\t * written into the terminal.\n\t */\n\tprivate _expected: ({ gen: number; p: IPrediction })[] = [];\n\n\t/**\n\t * Current prediction generation.\n\t */\n\tprivate _currentGen = 0;\n\n\t/**\n\t * Current cursor position -- kept outside the buffer since it can be ahead\n\t * if typing swiftly. The position of the cursor that the user is currently\n\t * looking at on their screen (or will be looking at after all pending writes\n\t * are flushed.)\n\t */\n\tprivate _physicalCursor: Cursor | undefined;\n\n\t/**\n\t * Cursor position taking into account all (possibly not-yet-applied)\n\t * predictions. A new prediction inserted, if applied, will be applied at\n\t * the position of the tentative cursor.\n\t */\n\tprivate _tenativeCursor: Cursor | undefined;\n\n\t/**\n\t * Previously sent data that was buffered and should be prepended to the\n\t * next input.\n\t */\n\tprivate _inputBuffer?: string;\n\n\t/**\n\t * Whether predictions are echoed to the terminal. If false, predictions\n\t * will still be computed internally for latency metrics, but input will\n\t * never be adjusted.\n\t */\n\tprivate _showPredictions = false;\n\n\t/**\n\t * The last successfully-made prediction.\n\t */\n\tprivate _lookBehind?: IPrediction;\n\n\tprivate readonly _addedEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionAdded = this._addedEmitter.event;\n\tprivate readonly _failedEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionFailed = this._failedEmitter.event;\n\tprivate readonly _succeededEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionSucceeded = this._succeededEmitter.event;\n\n\tprivate get _currentGenerationPredictions() {\n\t\treturn this._expected.filter(({ gen }) => gen === this._expected[0].gen).map(({ p }) => p);\n\t}\n\n\tget isShowingPredictions() {\n\t\treturn this._showPredictions;\n\t}\n\n\tget length() {\n\t\treturn this._expected.length;\n\t}\n\n\tconstructor(readonly terminal: Terminal, private readonly _style: TypeAheadStyle) { }\n\n\tsetShowPredictions(show: boolean) {\n\t\tif (show === this._showPredictions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('set predictions:', show);\n\t\tthis._showPredictions = show;\n\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (!buffer) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst toApply = this._currentGenerationPredictions;\n\t\tif (show) {\n\t\t\tthis.clearCursor();\n\t\t\tthis._style.expectIncomingStyle(toApply.reduce((count, p) => p.affectsStyle ? count + 1 : count, 0));\n\t\t\tthis.terminal.write(toApply.map(p => p.apply(buffer, this.physicalCursor(buffer))).join(''));\n\t\t} else {\n\t\t\tthis.terminal.write(toApply.reverse().map(p => p.rollback(this.physicalCursor(buffer))).join(''));\n\t\t}\n\t}\n\n\t/**\n\t * Undoes any predictions written and resets expectations.\n\t */\n\tundoAllPredictions() {\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (this._showPredictions && buffer) {\n\t\t\tthis.terminal.write(this._currentGenerationPredictions.reverse()\n\t\t\t\t.map(p => p.rollback(this.physicalCursor(buffer))).join(''));\n\t\t}\n\n\t\tthis._expected = [];\n\t}\n\n\t/**\n\t * Should be called when input is incoming to the temrinal.\n\t */\n\tbeforeServerInput(input: string): string {\n\t\tconst originalInput = input;\n\t\tif (this._inputBuffer) {\n\t\t\tinput = this._inputBuffer + input;\n\t\t\tthis._inputBuffer = undefined;\n\t\t}\n\n\t\tif (!this._expected.length) {\n\t\t\tthis._clearPredictionState();\n\t\t\treturn input;\n\t\t}\n\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (!buffer) {\n\t\t\tthis._clearPredictionState();\n\t\t\treturn input;\n\t\t}\n\n\t\tlet output = '';\n\n\t\tconst reader = new StringReader(input);\n\t\tconst startingGen = this._expected[0].gen;\n\t\tconst emitPredictionOmitted = () => {\n\t\t\tconst omit = reader.eatRe(PREDICTION_OMIT_RE);\n\t\t\tif (omit) {\n\t\t\t\toutput += omit[0];\n\t\t\t}\n\t\t};\n\n\t\tReadLoop: while (this._expected.length && reader.remaining > 0) {\n\t\t\temitPredictionOmitted();\n\n\t\t\tconst { p: prediction, gen } = this._expected[0];\n\t\t\tconst cursor = this.physicalCursor(buffer);\n\t\t\tconst beforeTestReaderIndex = reader.index;\n\t\t\tswitch (prediction.matches(reader, this._lookBehind)) {\n\t\t\t\tcase MatchResult.Success: {\n\t\t\t\t\t// if the input character matches what the next prediction expected, undo\n\t\t\t\t\t// the prediction and write the real character out.\n\t\t\t\t\tconst eaten = input.slice(beforeTestReaderIndex, reader.index);\n\t\t\t\t\tif (gen === startingGen) {\n\t\t\t\t\t\toutput += prediction.rollForwards?.(cursor, eaten);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprediction.apply(buffer, this.physicalCursor(buffer)); // move cursor for additional apply\n\t\t\t\t\t\toutput += eaten;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._succeededEmitter.fire(prediction);\n\t\t\t\t\tthis._lookBehind = prediction;\n\t\t\t\t\tthis._expected.shift();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase MatchResult.Buffer:\n\t\t\t\t\t// on a buffer, store the remaining data and completely read data\n\t\t\t\t\t// to be output as normal.\n\t\t\t\t\tthis._inputBuffer = input.slice(beforeTestReaderIndex);\n\t\t\t\t\treader.index = input.length;\n\t\t\t\t\tbreak ReadLoop;\n\t\t\t\tcase MatchResult.Failure: {\n\t\t\t\t\t// on a failure, roll back all remaining items in this generation\n\t\t\t\t\t// and clear predictions, since they are no longer valid\n\t\t\t\t\tconst rollback = this._expected.filter(p => p.gen === startingGen).reverse();\n\t\t\t\t\toutput += rollback.map(({ p }) => p.rollback(this.physicalCursor(buffer))).join('');\n\t\t\t\t\tif (rollback.some(r => r.p.affectsStyle)) {\n\t\t\t\t\t\t// reading the current style should generally be safe, since predictions\n\t\t\t\t\t\t// always restore the style if they modify it.\n\t\t\t\t\t\toutput += attributesToSeq(core(this.terminal)._inputHandler._curAttrData);\n\t\t\t\t\t}\n\t\t\t\t\tthis._clearPredictionState();\n\t\t\t\t\tthis._failedEmitter.fire(prediction);\n\t\t\t\t\tbreak ReadLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\temitPredictionOmitted();\n\n\t\t// Extra data (like the result of running a command) should cause us to\n\t\t// reset the cursor\n\t\tif (!reader.eof) {\n\t\t\toutput += reader.rest;\n\t\t\tthis._clearPredictionState();\n\t\t}\n\n\t\t// If we passed a generation boundary, apply the current generation's predictions\n\t\tif (this._expected.length && startingGen !== this._expected[0].gen) {\n\t\t\tfor (const { p, gen } of this._expected) {\n\t\t\t\tif (gen !== this._expected[0].gen) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (p.affectsStyle) {\n\t\t\t\t\tthis._style.expectIncomingStyle();\n\t\t\t\t}\n\n\t\t\t\toutput += p.apply(buffer, this.physicalCursor(buffer));\n\t\t\t}\n\t\t}\n\n\t\tif (!this._showPredictions) {\n\t\t\treturn originalInput;\n\t\t}\n\n\t\tif (output.length === 0 || output === input) {\n\t\t\treturn output;\n\t\t}\n\n\t\tif (this._physicalCursor) {\n\t\t\toutput += this._physicalCursor.moveInstruction();\n\t\t}\n\n\t\t// prevent cursor flickering while typing\n\t\toutput = VT.HideCursor + output + VT.ShowCursor;\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Clears any expected predictions and stored state. Should be called when\n\t * the pty gives us something we don't recognize.\n\t */\n\tprivate _clearPredictionState() {\n\t\tthis._expected = [];\n\t\tthis.clearCursor();\n\t\tthis._lookBehind = undefined;\n\t}\n\n\t/**\n\t * Appends a typeahead prediction.\n\t */\n\taddPrediction(buffer: IBuffer, prediction: IPrediction) {\n\t\tthis._expected.push({ gen: this._currentGen, p: prediction });\n\t\tthis._addedEmitter.fire(prediction);\n\n\t\tif (this._currentGen !== this._expected[0].gen) {\n\t\t\tprediction.apply(buffer, this.tentativeCursor(buffer));\n\t\t\treturn false;\n\t\t}\n\n\t\tconst text = prediction.apply(buffer, this.physicalCursor(buffer));\n\t\tthis._tenativeCursor = undefined; // next read will get or clone the physical cursor\n\n\t\tif (this._showPredictions && text) {\n\t\t\tif (prediction.affectsStyle) {\n\t\t\t\tthis._style.expectIncomingStyle();\n\t\t\t}\n\t\t\t// console.log('predict:', JSON.stringify(text));\n\t\t\tthis.terminal.write(text);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Appends a prediction followed by a boundary. The predictions applied\n\t * after this one will only be displayed after the give prediction matches\n\t * pty output/\n\t */\n\taddBoundary(): void;\n\taddBoundary(buffer: IBuffer, prediction: IPrediction): boolean;\n\taddBoundary(buffer?: IBuffer, prediction?: IPrediction) {\n\t\tlet applied = false;\n\t\tif (buffer && prediction) {\n\t\t\t// We apply the prediction so that it's matched against, but wrapped\n\t\t\t// in a tentativeboundary so that it doesn't affect the physical cursor.\n\t\t\t// Then we apply it specifically to the tentative cursor.\n\t\t\tapplied = this.addPrediction(buffer, new TentativeBoundary(prediction));\n\t\t\tprediction.apply(buffer, this.tentativeCursor(buffer));\n\t\t}\n\t\tthis._currentGen++;\n\t\treturn applied;\n\t}\n\n\t/**\n\t * Peeks the last prediction written.\n\t */\n\tpeekEnd(): IPrediction | undefined {\n\t\treturn this._expected[this._expected.length - 1]?.p;\n\t}\n\n\t/**\n\t * Peeks the first pending prediction.\n\t */\n\tpeekStart(): IPrediction | undefined {\n\t\treturn this._expected[0]?.p;\n\t}\n\n\t/**\n\t * Current position of the cursor in the terminal.\n\t */\n\tphysicalCursor(buffer: IBuffer) {\n\t\tif (!this._physicalCursor) {\n\t\t\tif (this._showPredictions) {\n\t\t\t\tflushOutput(this.terminal);\n\t\t\t}\n\t\t\tthis._physicalCursor = new Cursor(this.terminal.rows, this.terminal.cols, buffer);\n\t\t}\n\n\t\treturn this._physicalCursor;\n\t}\n\n\t/**\n\t * Cursor position if all predictions and boundaries that have been inserted\n\t * so far turn out to be successfully predicted.\n\t */\n\ttentativeCursor(buffer: IBuffer) {\n\t\tif (!this._tenativeCursor) {\n\t\t\tthis._tenativeCursor = this.physicalCursor(buffer).clone();\n\t\t}\n\n\t\treturn this._tenativeCursor;\n\t}\n\n\tclearCursor() {\n\t\tthis._physicalCursor = undefined;\n\t\tthis._tenativeCursor = undefined;\n\t}\n\n\tprivate _getActiveBuffer() {\n\t\tconst buffer = this.terminal.buffer.active;\n\t\treturn buffer.type === 'normal' ? buffer : undefined;\n\t}\n}\n\n/**\n * Gets the escape sequence args to restore state/appearance in the cell.\n */\nconst attributesToArgs = (cell: XtermAttributes) => {\n\tif (cell.isAttributeDefault()) { return [0]; }\n\n\tconst args = [];\n\tif (cell.isBold()) { args.push(1); }\n\tif (cell.isDim()) { args.push(2); }\n\tif (cell.isItalic()) { args.push(3); }\n\tif (cell.isUnderline()) { args.push(4); }\n\tif (cell.isBlink()) { args.push(5); }\n\tif (cell.isInverse()) { args.push(7); }\n\tif (cell.isInvisible()) { args.push(8); }\n\n\tif (cell.isFgRGB()) { args.push(38, 2, cell.getFgColor() >>> 24, (cell.getFgColor() >>> 16) & 0xFF, cell.getFgColor() & 0xFF); }\n\tif (cell.isFgPalette()) { args.push(38, 5, cell.getFgColor()); }\n\tif (cell.isFgDefault()) { args.push(39); }\n\n\tif (cell.isBgRGB()) { args.push(48, 2, cell.getBgColor() >>> 24, (cell.getBgColor() >>> 16) & 0xFF, cell.getBgColor() & 0xFF); }\n\tif (cell.isBgPalette()) { args.push(48, 5, cell.getBgColor()); }\n\tif (cell.isBgDefault()) { args.push(49); }\n\n\treturn args;\n};\n\n/**\n * Gets the escape sequence to restore state/appearance in the cell.\n */\nconst attributesToSeq = (cell: XtermAttributes) => `${VT.Csi}${attributesToArgs(cell).join(';')}m`;\n\nconst arrayHasPrefixAt = <T>(a: ReadonlyArray<T>, ai: number, b: ReadonlyArray<T>) => {\n\tif (a.length - ai > b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let bi = 0; bi < b.length; bi++, ai++) {\n\t\tif (b[ai] !== a[ai]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n/**\n * @see https://github.com/xtermjs/xterm.js/blob/065eb13a9d3145bea687239680ec9696d9112b8e/src/common/InputHandler.ts#L2127\n */\nconst getColorWidth = (params: SingleOrMany<number>[], pos: number) => {\n\tconst accu = [0, 0, -1, 0, 0, 0];\n\tlet cSpace = 0;\n\tlet advance = 0;\n\n\tdo {\n\t\tconst v = params[pos + advance];\n\t\taccu[advance + cSpace] = isNumber(v) ? v : v[0];\n\t\tif (!isNumber(v)) {\n\t\t\tlet i = 0;\n\t\t\tdo {\n\t\t\t\tif (accu[1] === 5) {\n\t\t\t\t\tcSpace = 1;\n\t\t\t\t}\n\t\t\t\taccu[advance + i + 1 + cSpace] = v[i];\n\t\t\t} while (++i < v.length && i + advance + 1 + cSpace < accu.length);\n\t\t\tbreak;\n\t\t}\n\t\t// exit early if can decide color mode with semicolons\n\t\tif ((accu[1] === 5 && advance + cSpace >= 2)\n\t\t\t|| (accu[1] === 2 && advance + cSpace >= 5)) {\n\t\t\tbreak;\n\t\t}\n\t\t// offset colorSpace slot for semicolon mode\n\t\tif (accu[1]) {\n\t\t\tcSpace = 1;\n\t\t}\n\t} while (++advance + pos < params.length && advance + cSpace < accu.length);\n\n\treturn advance;\n};\n\nclass TypeAheadStyle implements IDisposable {\n\tprivate static _compileArgs(args: ReadonlyArray<number>) {\n\t\treturn `${VT.Csi}${args.join(';')}m`;\n\t}\n\n\t/**\n\t * Number of typeahead style arguments we expect to read. If this is 0 and\n\t * we see a style coming in, we know that the PTY actually wanted to update.\n\t */\n\tprivate _expectedIncomingStyles = 0;\n\tprivate _applyArgs!: ReadonlyArray<number>;\n\tprivate _originalUndoArgs!: ReadonlyArray<number>;\n\tprivate _undoArgs!: ReadonlyArray<number>;\n\n\tapply!: string;\n\tundo!: string;\n\tprivate _csiHandler?: IDisposable;\n\n\tconstructor(value: ITerminalTypeAheadConfiguration['localEchoStyle'], private readonly _terminal: Terminal) {\n\t\tthis.onUpdate(value);\n\t}\n\n\t/**\n\t * Signals that a style was written to the terminal and we should watch\n\t * for it coming in.\n\t */\n\texpectIncomingStyle(n = 1) {\n\t\tthis._expectedIncomingStyles += n * 2;\n\t}\n\n\t/**\n\t * Starts tracking for CSI changes in the terminal.\n\t */\n\tstartTracking() {\n\t\tthis._expectedIncomingStyles = 0;\n\t\tthis._onDidWriteSGR(attributesToArgs(core(this._terminal)._inputHandler._curAttrData));\n\t\tthis._csiHandler = this._terminal.parser.registerCsiHandler({ final: 'm' }, args => {\n\t\t\tthis._onDidWriteSGR(args);\n\t\t\treturn false;\n\t\t});\n\t}\n\n\t/**\n\t * Stops tracking terminal CSI changes.\n\t */\n\t@debounce(2000)\n\tdebounceStopTracking() {\n\t\tthis._stopTracking();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tdispose() {\n\t\tthis._stopTracking();\n\t}\n\n\tprivate _stopTracking() {\n\t\tthis._csiHandler?.dispose();\n\t\tthis._csiHandler = undefined;\n\t}\n\n\tprivate _onDidWriteSGR(args: SingleOrMany<number>[]) {\n\t\tconst originalUndo = this._undoArgs;\n\t\tfor (let i = 0; i < args.length;) {\n\t\t\tconst px = args[i];\n\t\t\tconst p = isNumber(px) ? px : px[0];\n\n\t\t\tif (this._expectedIncomingStyles) {\n\t\t\t\tif (arrayHasPrefixAt(args, i, this._undoArgs)) {\n\t\t\t\t\tthis._expectedIncomingStyles--;\n\t\t\t\t\ti += this._undoArgs.length;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (arrayHasPrefixAt(args, i, this._applyArgs)) {\n\t\t\t\t\tthis._expectedIncomingStyles--;\n\t\t\t\t\ti += this._applyArgs.length;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst width = p === 38 || p === 48 || p === 58 ? getColorWidth(args, i) : 1;\n\t\t\tswitch (this._applyArgs[0]) {\n\t\t\t\tcase 1:\n\t\t\t\t\tif (p === 2) {\n\t\t\t\t\t\tthis._undoArgs = [22, 2];\n\t\t\t\t\t} else if (p === 22 || p === 0) {\n\t\t\t\t\t\tthis._undoArgs = [22];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (p === 1) {\n\t\t\t\t\t\tthis._undoArgs = [22, 1];\n\t\t\t\t\t} else if (p === 22 || p === 0) {\n\t\t\t\t\t\tthis._undoArgs = [22];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\tif (p === 0 || p === 39 || p === 100) {\n\t\t\t\t\t\tthis._undoArgs = [39];\n\t\t\t\t\t} else if ((p >= 30 && p <= 38) || (p >= 90 && p <= 97)) {\n\t\t\t\t\t\tthis._undoArgs = args.slice(i, i + width) as number[];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (p === this._applyArgs[0]) {\n\t\t\t\t\t\tthis._undoArgs = this._applyArgs;\n\t\t\t\t\t} else if (p === 0) {\n\t\t\t\t\t\tthis._undoArgs = this._originalUndoArgs;\n\t\t\t\t\t}\n\t\t\t\t// no-op\n\t\t\t}\n\n\t\t\ti += width;\n\t\t}\n\n\t\tif (originalUndo !== this._undoArgs) {\n\t\t\tthis.undo = TypeAheadStyle._compileArgs(this._undoArgs);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the current typeahead style.\n\t */\n\tonUpdate(style: ITerminalTypeAheadConfiguration['localEchoStyle']) {\n\t\tconst { applyArgs, undoArgs } = this._getArgs(style);\n\t\tthis._applyArgs = applyArgs;\n\t\tthis._undoArgs = this._originalUndoArgs = undoArgs;\n\t\tthis.apply = TypeAheadStyle._compileArgs(this._applyArgs);\n\t\tthis.undo = TypeAheadStyle._compileArgs(this._undoArgs);\n\t}\n\n\tprivate _getArgs(style: ITerminalTypeAheadConfiguration['localEchoStyle']) {\n\t\tswitch (style) {\n\t\t\tcase 'bold':\n\t\t\t\treturn { applyArgs: [1], undoArgs: [22] };\n\t\t\tcase 'dim':\n\t\t\t\treturn { applyArgs: [2], undoArgs: [22] };\n\t\t\tcase 'italic':\n\t\t\t\treturn { applyArgs: [3], undoArgs: [23] };\n\t\t\tcase 'underlined':\n\t\t\t\treturn { applyArgs: [4], undoArgs: [24] };\n\t\t\tcase 'inverted':\n\t\t\t\treturn { applyArgs: [7], undoArgs: [27] };\n\t\t\tdefault: {\n\t\t\t\tlet color: Color;\n\t\t\t\ttry {\n\t\t\t\t\tcolor = Color.fromHex(style);\n\t\t\t\t} catch {\n\t\t\t\t\tcolor = new Color(new RGBA(255, 0, 0, 1));\n\t\t\t\t}\n\n\t\t\t\tconst { r, g, b } = color.rgba;\n\t\t\t\treturn { applyArgs: [38, 2, r, g, b], undoArgs: [39] };\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst compileExcludeRegexp = (programs = DEFAULT_LOCAL_ECHO_EXCLUDE) =>\n\tnew RegExp(`\\\\b(${programs.map(escapeRegExpCharacters).join('|')})\\\\b`, 'i');\n\nexport const enum CharPredictState {\n\t/** No characters typed on this line yet */\n\tUnknown,\n\t/** Has a pending character prediction */\n\tHasPendingChar,\n\t/** Character validated on this line */\n\tValidated,\n}\n\nexport class TypeAheadAddon extends Disposable implements ITerminalAddon {\n\tprivate _typeaheadStyle?: TypeAheadStyle;\n\tprivate _typeaheadThreshold: number;\n\tprivate _excludeProgramRe: RegExp;\n\tprotected _lastRow?: { y: number; startingX: number; endingX: number; charState: CharPredictState };\n\tprotected _timeline?: PredictionTimeline;\n\tprivate _terminalTitle = '';\n\tstats?: PredictionStats;\n\n\t/**\n\t * Debounce that clears predictions after a timeout if the PTY doesn't apply them.\n\t */\n\tprivate _clearPredictionDebounce?: IDisposable;\n\n\tconstructor(\n\t\tprivate _processManager: ITerminalProcessManager,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService,\n\t) {\n\t\tsuper();\n\t\tthis._typeaheadThreshold = this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoLatencyThreshold;\n\t\tthis._excludeProgramRe = compileExcludeRegexp(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoExcludePrograms);\n\t\tthis._register(toDisposable(() => this._clearPredictionDebounce?.dispose()));\n\t}\n\n\tactivate(terminal: Terminal): void {\n\t\tconst style = this._typeaheadStyle = this._register(new TypeAheadStyle(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoStyle, terminal));\n\t\tconst timeline = this._timeline = new PredictionTimeline(terminal, this._typeaheadStyle);\n\t\tconst stats = this.stats = this._register(new PredictionStats(this._timeline));\n\n\t\ttimeline.setShowPredictions(this._typeaheadThreshold === 0);\n\t\tthis._register(terminal.onData(e => this._onUserData(e)));\n\t\tthis._register(terminal.onTitleChange(title => {\n\t\t\tthis._terminalTitle = title;\n\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t}));\n\t\tthis._register(terminal.onResize(() => {\n\t\t\ttimeline.setShowPredictions(false);\n\t\t\ttimeline.clearCursor();\n\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t}));\n\t\tthis._register(this._configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration(TERMINAL_CONFIG_SECTION)) {\n\t\t\t\tstyle.onUpdate(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoStyle);\n\t\t\t\tthis._typeaheadThreshold = this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoLatencyThreshold;\n\t\t\t\tthis._excludeProgramRe = compileExcludeRegexp(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoExcludePrograms);\n\t\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t\t}\n\t\t}));\n\t\tthis._register(this._timeline.onPredictionSucceeded(p => {\n\t\t\tif (this._lastRow?.charState === CharPredictState.HasPendingChar && isTenativeCharacterPrediction(p) && p.inner.appliedAt) {\n\t\t\t\tif (p.inner.appliedAt.pos.y + p.inner.appliedAt.pos.baseY === this._lastRow.y) {\n\t\t\t\t\tthis._lastRow.charState = CharPredictState.Validated;\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\tthis._register(this._processManager.onBeforeProcessData(e => this._onBeforeProcessData(e)));\n\n\t\tlet nextStatsSend: Timeout | undefined;\n\t\tthis._register(stats.onChange(() => {\n\t\t\tif (!nextStatsSend) {\n\t\t\t\tnextStatsSend = setTimeout(() => {\n\t\t\t\t\tthis._sendLatencyStats(stats);\n\t\t\t\t\tnextStatsSend = undefined;\n\t\t\t\t}, StatsConstants.StatsSendTelemetryEvery);\n\t\t\t}\n\n\t\t\tif (timeline.length === 0) {\n\t\t\t\tstyle.debounceStopTracking();\n\t\t\t}\n\n\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t}));\n\t}\n\n\treset() {\n\t\tthis._lastRow = undefined;\n\t}\n\n\tprivate _deferClearingPredictions() {\n\t\tif (!this.stats || !this._timeline) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clearPredictionDebounce?.dispose();\n\t\tif (this._timeline.length === 0 || this._timeline.peekStart()?.clearAfterTimeout === false) {\n\t\t\tthis._clearPredictionDebounce = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clearPredictionDebounce = disposableTimeout(\n\t\t\t() => {\n\t\t\t\tthis._timeline?.undoAllPredictions();\n\t\t\t\tif (this._lastRow?.charState === CharPredictState.HasPendingChar) {\n\t\t\t\t\tthis._lastRow.charState = CharPredictState.Unknown;\n\t\t\t\t}\n\t\t\t},\n\t\t\tMath.max(500, this.stats.maxLatency * 3 / 2),\n\t\t\tthis._store\n\t\t);\n\t}\n\n\t/**\n\t * Note on debounce:\n\t *\n\t * We want to toggle the state only when the user has a pause in their\n\t * typing. Otherwise, we could turn this on when the PTY sent data but the\n\t * terminal cursor is not updated, causes issues.\n\t */\n\t@debounce(100)\n\tprotected _reevaluatePredictorState(stats: PredictionStats, timeline: PredictionTimeline) {\n\t\tthis._reevaluatePredictorStateNow(stats, timeline);\n\t}\n\n\tprotected _reevaluatePredictorStateNow(stats: PredictionStats, timeline: PredictionTimeline) {\n\t\tif (this._excludeProgramRe.test(this._terminalTitle)) {\n\t\t\ttimeline.setShowPredictions(false);\n\t\t} else if (this._typeaheadThreshold < 0) {\n\t\t\ttimeline.setShowPredictions(false);\n\t\t} else if (this._typeaheadThreshold === 0) {\n\t\t\ttimeline.setShowPredictions(true);\n\t\t} else if (stats.sampleSize > StatsConstants.StatsMinSamplesToTurnOn && stats.accuracy > StatsConstants.StatsMinAccuracyToTurnOn) {\n\t\t\tconst latency = stats.latency.median;\n\t\t\tif (latency >= this._typeaheadThreshold) {\n\t\t\t\ttimeline.setShowPredictions(true);\n\t\t\t} else if (latency < this._typeaheadThreshold / StatsConstants.StatsToggleOffThreshold) {\n\t\t\t\ttimeline.setShowPredictions(false);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _sendLatencyStats(stats: PredictionStats) {\n\t\t/* __GDPR__\n\t\t\t\"terminalLatencyStats\" : {\n\t\t\t\t\"owner\": \"Tyriar\",\n\t\t\t\t\"min\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"max\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"median\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"count\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"predictionAccuracy\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true }\n\t\t\t}\n\t\t */\n\t\tthis._telemetryService.publicLog('terminalLatencyStats', {\n\t\t\t...stats.latency,\n\t\t\tpredictionAccuracy: stats.accuracy,\n\t\t});\n\t}\n\n\tprivate _onUserData(data: string): void {\n\t\tif (this._timeline?.terminal.buffer.active.type !== 'normal') {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('user data:', JSON.stringify(data));\n\n\t\tconst terminal = this._timeline.terminal;\n\t\tconst buffer = terminal.buffer.active;\n\n\t\t// Detect programs like git log/less that use the normal buffer but don't\n\t\t// take input by deafult (fixes #109541)\n\t\tif (buffer.cursorX === 1 && buffer.cursorY === terminal.rows - 1) {\n\t\t\tif (buffer.getLine(buffer.cursorY + buffer.baseY)?.getCell(0)?.getChars() === ':') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// the following code guards the terminal prompt to avoid being able to\n\t\t// arrow or backspace-into the prompt. Record the lowest X value at which\n\t\t// the user gave input, and mark all additions before that as tentative.\n\t\tconst actualY = buffer.baseY + buffer.cursorY;\n\t\tif (actualY !== this._lastRow?.y) {\n\t\t\tthis._lastRow = { y: actualY, startingX: buffer.cursorX, endingX: buffer.cursorX, charState: CharPredictState.Unknown };\n\t\t} else {\n\t\t\tthis._lastRow.startingX = Math.min(this._lastRow.startingX, buffer.cursorX);\n\t\t\tthis._lastRow.endingX = Math.max(this._lastRow.endingX, this._timeline.physicalCursor(buffer).x);\n\t\t}\n\n\t\tconst addLeftNavigating = (p: IPrediction) =>\n\t\t\tthis._timeline!.tentativeCursor(buffer).x <= this._lastRow!.startingX\n\t\t\t\t? this._timeline!.addBoundary(buffer, p)\n\t\t\t\t: this._timeline!.addPrediction(buffer, p);\n\n\t\tconst addRightNavigating = (p: IPrediction) =>\n\t\t\tthis._timeline!.tentativeCursor(buffer).x >= this._lastRow!.endingX - 1\n\t\t\t\t? this._timeline!.addBoundary(buffer, p)\n\t\t\t\t: this._timeline!.addPrediction(buffer, p);\n\n\t\t/** @see https://github.com/xtermjs/xterm.js/blob/1913e9512c048e3cf56bb5f5df51bfff6899c184/src/common/input/Keyboard.ts */\n\t\tconst reader = new StringReader(data);\n\t\twhile (reader.remaining > 0) {\n\t\t\tif (reader.eatCharCode(127)) { // backspace\n\t\t\t\tconst previous = this._timeline.peekEnd();\n\t\t\t\tif (previous && previous instanceof CharacterPrediction) {\n\t\t\t\t\tthis._timeline.addBoundary();\n\t\t\t\t}\n\n\t\t\t\t// backspace must be able to read the previously-written character in\n\t\t\t\t// the event that it needs to undo it\n\t\t\t\tif (this._timeline.isShowingPredictions) {\n\t\t\t\t\tflushOutput(this._timeline.terminal);\n\t\t\t\t}\n\n\t\t\t\tif (this._timeline.tentativeCursor(buffer).x <= this._lastRow.startingX) {\n\t\t\t\t\tthis._timeline.addBoundary(buffer, new BackspacePrediction(this._timeline.terminal));\n\t\t\t\t} else {\n\t\t\t\t\t// Backspace decrements our ability to go right.\n\t\t\t\t\tthis._lastRow.endingX--;\n\t\t\t\t\tthis._timeline.addPrediction(buffer, new BackspacePrediction(this._timeline.terminal));\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatCharCode(32, 126)) { // alphanum\n\t\t\t\tconst char = data[reader.index - 1];\n\t\t\t\tconst prediction = new CharacterPrediction(this._typeaheadStyle!, char);\n\t\t\t\tif (this._lastRow.charState === CharPredictState.Unknown) {\n\t\t\t\t\tthis._timeline.addBoundary(buffer, prediction);\n\t\t\t\t\tthis._lastRow.charState = CharPredictState.HasPendingChar;\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline.addPrediction(buffer, prediction);\n\t\t\t\t}\n\n\t\t\t\tif (this._timeline.tentativeCursor(buffer).x >= terminal.cols) {\n\t\t\t\t\tthis._timeline.addBoundary(buffer, new LinewrapPrediction());\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst cursorMv = reader.eatRe(CSI_MOVE_RE);\n\t\t\tif (cursorMv) {\n\t\t\t\tconst direction = cursorMv[3] as CursorMoveDirection;\n\t\t\t\tconst p = new CursorMovePrediction(direction, !!cursorMv[2], Number(cursorMv[1]) || 1);\n\t\t\t\tif (direction === CursorMoveDirection.Back) {\n\t\t\t\t\taddLeftNavigating(p);\n\t\t\t\t} else {\n\t\t\t\t\taddRightNavigating(p);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatStr(`${VT.Esc}f`)) {\n\t\t\t\taddRightNavigating(new CursorMovePrediction(CursorMoveDirection.Forwards, true, 1));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatStr(`${VT.Esc}b`)) {\n\t\t\t\taddLeftNavigating(new CursorMovePrediction(CursorMoveDirection.Back, true, 1));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatChar('\\r') && buffer.cursorY < terminal.rows - 1) {\n\t\t\t\tthis._timeline.addPrediction(buffer, new NewlinePrediction());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// something else\n\t\t\tthis._timeline.addBoundary(buffer, new HardBoundary());\n\t\t\tbreak;\n\t\t}\n\n\t\tif (this._timeline.length === 1) {\n\t\t\tthis._deferClearingPredictions();\n\t\t\tthis._typeaheadStyle!.startTracking();\n\t\t}\n\t}\n\n\tprivate _onBeforeProcessData(event: IBeforeProcessDataEvent): void {\n\t\tif (!this._timeline) {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('incoming data:', JSON.stringify(event.data));\n\t\tevent.data = this._timeline.beforeServerInput(event.data);\n\t\t// console.log('emitted data:', JSON.stringify(event.data));\n\n\t\tthis._deferClearingPredictions();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { disposableTimeout } from '../../../../../base/common/async.js';\nimport { Color, RGBA } from '../../../../../base/common/color.js';\nimport { debounce } from '../../../../../base/common/decorators.js';\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { ITelemetryService } from '../../../../../platform/telemetry/common/telemetry.js';\nimport { XtermAttributes, IXtermCore } from '../../../terminal/browser/xterm-private.js';\nimport { IBeforeProcessDataEvent, ITerminalProcessManager, TERMINAL_CONFIG_SECTION } from '../../../terminal/common/terminal.js';\nimport type { IBuffer, IBufferCell, IDisposable, ITerminalAddon, Terminal } from '@xterm/xterm';\nimport { DEFAULT_LOCAL_ECHO_EXCLUDE, type ITerminalTypeAheadConfiguration } from '../common/terminalTypeAheadConfiguration.js';\nimport { isNumber, type SingleOrMany } from '../../../../../base/common/types.js';\n\nconst enum VT {\n\tEsc = '\\x1b',\n\tCsi = `\\x1b[`,\n\tShowCursor = `\\x1b[?25h`,\n\tHideCursor = `\\x1b[?25l`,\n\tDeleteChar = `\\x1b[X`,\n\tDeleteRestOfLine = `\\x1b[K`,\n}\n\nconst CSI_STYLE_RE = /^\\x1b\\[[0-9;]*m/;\nconst CSI_MOVE_RE = /^\\x1b\\[?([0-9]*)(;[35])?O?([DC])/;\nconst NOT_WORD_RE = /[^a-z0-9]/i;\n\nconst enum StatsConstants {\n\tStatsBufferSize = 24,\n\tStatsSendTelemetryEvery = 1000 * 60 * 5, // how often to collect stats\n\tStatsMinSamplesToTurnOn = 5,\n\tStatsMinAccuracyToTurnOn = 0.3,\n\tStatsToggleOffThreshold = 0.5, // if latency is less than `threshold * this`, turn off\n}\n\n/**\n * Codes that should be omitted from sending to the prediction engine and instead omitted directly:\n * - Hide cursor (DECTCEM): We wrap the local echo sequence in hide and show\n *   CSI ? 2 5 l\n * - Show cursor (DECTCEM): We wrap the local echo sequence in hide and show\n *   CSI ? 2 5 h\n * - Device Status Report (DSR): These sequence fire report events from xterm which could cause\n *   double reporting and potentially a stack overflow (#119472)\n *   CSI Ps n\n *   CSI ? Ps n\n */\nconst PREDICTION_OMIT_RE = /^(\\x1b\\[(\\??25[hl]|\\??[0-9;]+n))+/;\n\nconst core = (terminal: Terminal): IXtermCore => {\n\tinterface XtermWithCore extends Terminal {\n\t\t_core: IXtermCore;\n\t}\n\treturn (terminal as XtermWithCore)._core;\n};\nconst flushOutput = (terminal: Terminal) => {\n\t// TODO: Flushing output is not possible anymore without async\n};\n\nconst enum CursorMoveDirection {\n\tBack = 'D',\n\tForwards = 'C',\n}\n\ninterface ICoordinate {\n\tx: number;\n\ty: number;\n\tbaseY: number;\n}\n\nclass Cursor implements ICoordinate {\n\tprivate _x = 0;\n\tprivate _y = 1;\n\tprivate _baseY = 1;\n\n\tget x() {\n\t\treturn this._x;\n\t}\n\n\tget y() {\n\t\treturn this._y;\n\t}\n\n\tget baseY() {\n\t\treturn this._baseY;\n\t}\n\n\tget coordinate(): ICoordinate {\n\t\treturn { x: this._x, y: this._y, baseY: this._baseY };\n\t}\n\n\tconstructor(\n\t\treadonly rows: number,\n\t\treadonly cols: number,\n\t\tprivate readonly _buffer: IBuffer\n\t) {\n\t\tthis._x = _buffer.cursorX;\n\t\tthis._y = _buffer.cursorY;\n\t\tthis._baseY = _buffer.baseY;\n\t}\n\n\tgetLine() {\n\t\treturn this._buffer.getLine(this._y + this._baseY);\n\t}\n\n\tgetCell(loadInto?: IBufferCell) {\n\t\treturn this.getLine()?.getCell(this._x, loadInto);\n\t}\n\n\tmoveTo(coordinate: ICoordinate) {\n\t\tthis._x = coordinate.x;\n\t\tthis._y = (coordinate.y + coordinate.baseY) - this._baseY;\n\t\treturn this.moveInstruction();\n\t}\n\n\tclone() {\n\t\tconst c = new Cursor(this.rows, this.cols, this._buffer);\n\t\tc.moveTo(this);\n\t\treturn c;\n\t}\n\n\tmove(x: number, y: number) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\treturn this.moveInstruction();\n\t}\n\n\tshift(x: number = 0, y: number = 0) {\n\t\tthis._x += x;\n\t\tthis._y += y;\n\t\treturn this.moveInstruction();\n\t}\n\n\tmoveInstruction() {\n\t\tif (this._y >= this.rows) {\n\t\t\tthis._baseY += this._y - (this.rows - 1);\n\t\t\tthis._y = this.rows - 1;\n\t\t} else if (this._y < 0) {\n\t\t\tthis._baseY -= this._y;\n\t\t\tthis._y = 0;\n\t\t}\n\n\t\treturn `${VT.Csi}${this._y + 1};${this._x + 1}H`;\n\t}\n}\n\nconst moveToWordBoundary = (b: IBuffer, cursor: Cursor, direction: -1 | 1) => {\n\tlet ateLeadingWhitespace = false;\n\tif (direction < 0) {\n\t\tcursor.shift(-1);\n\t}\n\n\tlet cell: IBufferCell | undefined;\n\twhile (cursor.x >= 0) {\n\t\tcell = cursor.getCell(cell);\n\t\tif (!cell?.getCode()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst chars = cell.getChars();\n\t\tif (NOT_WORD_RE.test(chars)) {\n\t\t\tif (ateLeadingWhitespace) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tateLeadingWhitespace = true;\n\t\t}\n\n\t\tcursor.shift(direction);\n\t}\n\n\tif (direction < 0) {\n\t\tcursor.shift(1); // we want to place the cursor after the whitespace starting the word\n\t}\n};\n\nconst enum MatchResult {\n\t/** matched successfully */\n\tSuccess,\n\t/** failed to match */\n\tFailure,\n\t/** buffer data, it might match in the future one more data comes in */\n\tBuffer,\n}\n\nexport interface IPrediction {\n\t/**\n\t * Whether applying this prediction can modify the style attributes of the\n\t * terminal. If so it means we need to reset the cursor style if it's\n\t * rolled back.\n\t */\n\treadonly affectsStyle?: boolean;\n\n\t/**\n\t * If set to false, the prediction will not be cleared if no input is\n\t * received from the server.\n\t */\n\treadonly clearAfterTimeout?: boolean;\n\n\t/**\n\t * Returns a sequence to apply the prediction.\n\t * @param buffer to write to\n\t * @param cursor position to write the data. Should advance the cursor.\n\t * @returns a string to be written to the user terminal, or optionally a\n\t * string for the user terminal and real pty.\n\t */\n\tapply(buffer: IBuffer, cursor: Cursor): string;\n\n\t/**\n\t * Returns a sequence to roll back a previous `apply()` call. If\n\t * `rollForwards` is not given, then this is also called if a prediction\n\t * is correct before show the user's data.\n\t */\n\trollback(cursor: Cursor): string;\n\n\t/**\n\t * If available, this will be called when the prediction is correct.\n\t */\n\trollForwards(cursor: Cursor, withInput: string): string;\n\n\t/**\n\t * Returns whether the given input is one expected by this prediction.\n\t * @param input reader for the input the PTY is giving\n\t * @param lookBehind the last successfully-made prediction, if any\n\t */\n\tmatches(input: StringReader, lookBehind?: IPrediction): MatchResult;\n}\n\nclass StringReader {\n\tindex = 0;\n\n\tget remaining() {\n\t\treturn this._input.length - this.index;\n\t}\n\n\tget eof() {\n\t\treturn this.index === this._input.length;\n\t}\n\n\tget rest() {\n\t\treturn this._input.slice(this.index);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _input: string\n\t) { }\n\n\t/**\n\t * Advances the reader and returns the character if it matches.\n\t */\n\teatChar(char: string) {\n\t\tif (this._input[this.index] !== char) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index++;\n\t\treturn char;\n\t}\n\n\t/**\n\t * Advances the reader and returns the string if it matches.\n\t */\n\teatStr(substr: string) {\n\t\tif (this._input.slice(this.index, substr.length) !== substr) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index += substr.length;\n\t\treturn substr;\n\t}\n\n\t/**\n\t * Matches and eats the substring character-by-character. If EOF is reached\n\t * before the substring is consumed, it will buffer. Index is not moved\n\t * if it's not a match.\n\t */\n\teatGradually(substr: string): MatchResult {\n\t\tconst prevIndex = this.index;\n\t\tfor (let i = 0; i < substr.length; i++) {\n\t\t\tif (i > 0 && this.eof) {\n\t\t\t\treturn MatchResult.Buffer;\n\t\t\t}\n\n\t\t\tif (!this.eatChar(substr[i])) {\n\t\t\t\tthis.index = prevIndex;\n\t\t\t\treturn MatchResult.Failure;\n\t\t\t}\n\t\t}\n\n\t\treturn MatchResult.Success;\n\t}\n\n\t/**\n\t * Advances the reader and returns the regex if it matches.\n\t */\n\teatRe(re: RegExp) {\n\t\tconst match = re.exec(this._input.slice(this.index));\n\t\tif (!match) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index += match[0].length;\n\t\treturn match;\n\t}\n\n\t/**\n\t * Advances the reader and returns the character if the code matches.\n\t */\n\teatCharCode(min = 0, max = min + 1) {\n\t\tconst code = this._input.charCodeAt(this.index);\n\t\tif (code < min || code >= max) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis.index++;\n\t\treturn code;\n\t}\n}\n\n/**\n * Preidction which never tests true. Will always discard predictions made\n * after it.\n */\nclass HardBoundary implements IPrediction {\n\treadonly clearAfterTimeout = false;\n\n\tapply() {\n\t\treturn '';\n\t}\n\n\trollback() {\n\t\treturn '';\n\t}\n\n\trollForwards() {\n\t\treturn '';\n\t}\n\n\tmatches() {\n\t\treturn MatchResult.Failure;\n\t}\n}\n\n/**\n * Wraps another prediction. Does not apply the prediction, but will pass\n * through its `matches` request.\n */\nclass TentativeBoundary implements IPrediction {\n\tprivate _appliedCursor?: Cursor;\n\n\tconstructor(readonly inner: IPrediction) { }\n\n\tapply(buffer: IBuffer, cursor: Cursor) {\n\t\tthis._appliedCursor = cursor.clone();\n\t\tthis.inner.apply(buffer, this._appliedCursor);\n\t\treturn '';\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tthis.inner.rollback(cursor.clone());\n\t\treturn '';\n\t}\n\n\trollForwards(cursor: Cursor, withInput: string) {\n\t\tif (this._appliedCursor) {\n\t\t\tcursor.moveTo(this._appliedCursor);\n\t\t}\n\n\t\treturn withInput;\n\t}\n\n\tmatches(input: StringReader) {\n\t\treturn this.inner.matches(input);\n\t}\n}\n\nconst isTenativeCharacterPrediction = (p: unknown): p is (TentativeBoundary & { inner: CharacterPrediction }) =>\n\tp instanceof TentativeBoundary && p.inner instanceof CharacterPrediction;\n\n/**\n * Prediction for a single alphanumeric character.\n */\nclass CharacterPrediction implements IPrediction {\n\treadonly affectsStyle = true;\n\n\tappliedAt?: {\n\t\tpos: ICoordinate;\n\t\toldAttributes: string;\n\t\toldChar: string;\n\t};\n\n\tconstructor(private readonly _style: TypeAheadStyle, private readonly _char: string) { }\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\tconst cell = cursor.getCell();\n\t\tthis.appliedAt = cell\n\t\t\t? { pos: cursor.coordinate, oldAttributes: attributesToSeq(cell), oldChar: cell.getChars() }\n\t\t\t: { pos: cursor.coordinate, oldAttributes: '', oldChar: '' };\n\n\t\tcursor.shift(1);\n\n\t\treturn this._style.apply + this._char + this._style.undo;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this.appliedAt) {\n\t\t\treturn ''; // not applied\n\t\t}\n\n\t\tconst { oldAttributes, oldChar, pos } = this.appliedAt;\n\t\tconst r = cursor.moveTo(pos) + (oldChar ? `${oldAttributes}${oldChar}${cursor.moveTo(pos)}` : VT.DeleteChar);\n\t\treturn r;\n\t}\n\n\trollForwards(cursor: Cursor, input: string) {\n\t\tif (!this.appliedAt) {\n\t\t\treturn ''; // not applied\n\t\t}\n\n\t\treturn cursor.clone().moveTo(this.appliedAt.pos) + input;\n\t}\n\n\tmatches(input: StringReader, lookBehind?: IPrediction) {\n\t\tconst startIndex = input.index;\n\n\t\t// remove any styling CSI before checking the char\n\t\twhile (input.eatRe(CSI_STYLE_RE)) { }\n\n\t\tif (input.eof) {\n\t\t\treturn MatchResult.Buffer;\n\t\t}\n\n\t\tif (input.eatChar(this._char)) {\n\t\t\treturn MatchResult.Success;\n\t\t}\n\n\t\tif (lookBehind instanceof CharacterPrediction) {\n\t\t\t// see #112842\n\t\t\tconst sillyZshOutcome = input.eatGradually(`\\b${lookBehind._char}${this._char}`);\n\t\t\tif (sillyZshOutcome !== MatchResult.Failure) {\n\t\t\t\treturn sillyZshOutcome;\n\t\t\t}\n\t\t}\n\n\t\tinput.index = startIndex;\n\t\treturn MatchResult.Failure;\n\t}\n}\n\nclass BackspacePrediction implements IPrediction {\n\tprotected _appliedAt?: {\n\t\tpos: ICoordinate;\n\t\toldAttributes: string;\n\t\toldChar: string;\n\t\tisLastChar: boolean;\n\t};\n\n\tconstructor(private readonly _terminal: Terminal) { }\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\t// at eol if everything to the right is whitespace (zsh will emit a \"clear line\" code in this case)\n\t\t// todo: can be optimized if `getTrimmedLength` is exposed from xterm\n\t\tconst isLastChar = !cursor.getLine()?.translateToString(undefined, cursor.x).trim();\n\t\tconst pos = cursor.coordinate;\n\t\tconst move = cursor.shift(-1);\n\t\tconst cell = cursor.getCell();\n\t\tthis._appliedAt = cell\n\t\t\t? { isLastChar, pos, oldAttributes: attributesToSeq(cell), oldChar: cell.getChars() }\n\t\t\t: { isLastChar, pos, oldAttributes: '', oldChar: '' };\n\n\t\treturn move + VT.DeleteChar;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this._appliedAt) {\n\t\t\treturn ''; // not applied\n\t\t}\n\n\t\tconst { oldAttributes, oldChar, pos } = this._appliedAt;\n\t\tif (!oldChar) {\n\t\t\treturn cursor.moveTo(pos) + VT.DeleteChar;\n\t\t}\n\n\t\treturn oldAttributes + oldChar + cursor.moveTo(pos) + attributesToSeq(core(this._terminal)._inputHandler._curAttrData);\n\t}\n\n\trollForwards() {\n\t\treturn '';\n\t}\n\n\tmatches(input: StringReader) {\n\t\tif (this._appliedAt?.isLastChar) {\n\t\t\tconst r1 = input.eatGradually(`\\b${VT.Csi}K`);\n\t\t\tif (r1 !== MatchResult.Failure) {\n\t\t\t\treturn r1;\n\t\t\t}\n\n\t\t\tconst r2 = input.eatGradually(`\\b \\b`);\n\t\t\tif (r2 !== MatchResult.Failure) {\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t}\n\n\t\treturn MatchResult.Failure;\n\t}\n}\n\nclass NewlinePrediction implements IPrediction {\n\tprotected _prevPosition?: ICoordinate;\n\n\tapply(_: IBuffer, cursor: Cursor) {\n\t\tthis._prevPosition = cursor.coordinate;\n\t\tcursor.move(0, cursor.y + 1);\n\t\treturn '\\r\\n';\n\t}\n\n\trollback(cursor: Cursor) {\n\t\treturn this._prevPosition ? cursor.moveTo(this._prevPosition) : '';\n\t}\n\n\trollForwards() {\n\t\treturn ''; // does not need to rewrite\n\t}\n\n\tmatches(input: StringReader) {\n\t\treturn input.eatGradually('\\r\\n');\n\t}\n}\n\n/**\n * Prediction when the cursor reaches the end of the line. Similar to newline\n * prediction, but shells handle it slightly differently.\n */\nclass LinewrapPrediction extends NewlinePrediction implements IPrediction {\n\toverride apply(_: IBuffer, cursor: Cursor) {\n\t\tthis._prevPosition = cursor.coordinate;\n\t\tcursor.move(0, cursor.y + 1);\n\t\treturn ' \\r';\n\t}\n\n\toverride matches(input: StringReader) {\n\t\t// bash and zshell add a space which wraps in the terminal, then a CR\n\t\tconst r = input.eatGradually(' \\r');\n\t\tif (r !== MatchResult.Failure) {\n\t\t\t// zshell additionally adds a clear line after wrapping to be safe -- eat it\n\t\t\tconst r2 = input.eatGradually(VT.DeleteRestOfLine);\n\t\t\treturn r2 === MatchResult.Buffer ? MatchResult.Buffer : r;\n\t\t}\n\n\t\treturn input.eatGradually('\\r\\n');\n\t}\n}\n\nclass CursorMovePrediction implements IPrediction {\n\tprivate _applied?: {\n\t\trollForward: string;\n\t\tprevPosition: number;\n\t\tprevAttrs: string;\n\t\tamount: number;\n\t};\n\n\tconstructor(\n\t\tprivate readonly _direction: CursorMoveDirection,\n\t\tprivate readonly _moveByWords: boolean,\n\t\tprivate readonly _amount: number,\n\t) { }\n\n\tapply(buffer: IBuffer, cursor: Cursor) {\n\t\tconst prevPosition = cursor.x;\n\t\tconst currentCell = cursor.getCell();\n\t\tconst prevAttrs = currentCell ? attributesToSeq(currentCell) : '';\n\n\t\tconst { _amount: amount, _direction: direction, _moveByWords: moveByWords } = this;\n\t\tconst delta = direction === CursorMoveDirection.Back ? -1 : 1;\n\n\t\tconst target = cursor.clone();\n\t\tif (moveByWords) {\n\t\t\tfor (let i = 0; i < amount; i++) {\n\t\t\t\tmoveToWordBoundary(buffer, target, delta);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.shift(delta * amount);\n\t\t}\n\n\t\tthis._applied = {\n\t\t\tamount: Math.abs(cursor.x - target.x),\n\t\t\tprevPosition,\n\t\t\tprevAttrs,\n\t\t\trollForward: cursor.moveTo(target),\n\t\t};\n\n\t\treturn this._applied.rollForward;\n\t}\n\n\trollback(cursor: Cursor) {\n\t\tif (!this._applied) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn cursor.move(this._applied.prevPosition, cursor.y) + this._applied.prevAttrs;\n\t}\n\n\trollForwards() {\n\t\treturn ''; // does not need to rewrite\n\t}\n\n\tmatches(input: StringReader) {\n\t\tif (!this._applied) {\n\t\t\treturn MatchResult.Failure;\n\t\t}\n\n\t\tconst direction = this._direction;\n\t\tconst { amount, rollForward } = this._applied;\n\n\n\t\t// arg can be omitted to move one character. We don't eatGradually() here\n\t\t// or below moves that don't go as far as the cursor would be buffered\n\t\t// indefinitely\n\t\tif (input.eatStr(`${VT.Csi}${direction}`.repeat(amount))) {\n\t\t\treturn MatchResult.Success;\n\t\t}\n\n\t\t// \\b is the equivalent to moving one character back\n\t\tif (direction === CursorMoveDirection.Back) {\n\t\t\tif (input.eatStr(`\\b`.repeat(amount))) {\n\t\t\t\treturn MatchResult.Success;\n\t\t\t}\n\t\t}\n\n\t\t// check if the cursor position is set absolutely\n\t\tif (rollForward) {\n\t\t\tconst r = input.eatGradually(rollForward);\n\t\t\tif (r !== MatchResult.Failure) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\t// check for a relative move in the direction\n\t\treturn input.eatGradually(`${VT.Csi}${amount}${direction}`);\n\t}\n}\n\nexport class PredictionStats extends Disposable {\n\tprivate readonly _stats: [latency: number, correct: boolean][] = [];\n\tprivate _index = 0;\n\tprivate readonly _addedAtTime = new WeakMap<IPrediction, number>();\n\tprivate readonly _changeEmitter = new Emitter<void>();\n\treadonly onChange = this._changeEmitter.event;\n\n\t/**\n\t * Gets the percent (0-1) of predictions that were accurate.\n\t */\n\tget accuracy() {\n\t\tlet correctCount = 0;\n\t\tfor (const [, correct] of this._stats) {\n\t\t\tif (correct) {\n\t\t\t\tcorrectCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn correctCount / (this._stats.length || 1);\n\t}\n\n\t/**\n\t * Gets the number of recorded stats.\n\t */\n\tget sampleSize() {\n\t\treturn this._stats.length;\n\t}\n\n\t/**\n\t * Gets latency stats of successful predictions.\n\t */\n\tget latency() {\n\t\tconst latencies = this._stats.filter(([, correct]) => correct).map(([s]) => s).sort();\n\n\t\treturn {\n\t\t\tcount: latencies.length,\n\t\t\tmin: latencies[0],\n\t\t\tmedian: latencies[Math.floor(latencies.length / 2)],\n\t\t\tmax: latencies[latencies.length - 1],\n\t\t};\n\t}\n\n\t/**\n\t * Gets the maximum observed latency.\n\t */\n\tget maxLatency() {\n\t\tlet max = -Infinity;\n\t\tfor (const [latency, correct] of this._stats) {\n\t\t\tif (correct) {\n\t\t\t\tmax = Math.max(latency, max);\n\t\t\t}\n\t\t}\n\n\t\treturn max;\n\t}\n\n\tconstructor(timeline: PredictionTimeline) {\n\t\tsuper();\n\t\tthis._register(timeline.onPredictionAdded(p => this._addedAtTime.set(p, Date.now())));\n\t\tthis._register(timeline.onPredictionSucceeded(this._pushStat.bind(this, true)));\n\t\tthis._register(timeline.onPredictionFailed(this._pushStat.bind(this, false)));\n\t}\n\n\tprivate _pushStat(correct: boolean, prediction: IPrediction) {\n\t\tconst started = this._addedAtTime.get(prediction)!;\n\t\tthis._stats[this._index] = [Date.now() - started, correct];\n\t\tthis._index = (this._index + 1) % StatsConstants.StatsBufferSize;\n\t\tthis._changeEmitter.fire();\n\t}\n}\n\nexport class PredictionTimeline {\n\t/**\n\t * Expected queue of events. Only predictions for the lowest are\n\t * written into the terminal.\n\t */\n\tprivate _expected: ({ gen: number; p: IPrediction })[] = [];\n\n\t/**\n\t * Current prediction generation.\n\t */\n\tprivate _currentGen = 0;\n\n\t/**\n\t * Current cursor position -- kept outside the buffer since it can be ahead\n\t * if typing swiftly. The position of the cursor that the user is currently\n\t * looking at on their screen (or will be looking at after all pending writes\n\t * are flushed.)\n\t */\n\tprivate _physicalCursor: Cursor | undefined;\n\n\t/**\n\t * Cursor position taking into account all (possibly not-yet-applied)\n\t * predictions. A new prediction inserted, if applied, will be applied at\n\t * the position of the tentative cursor.\n\t */\n\tprivate _tenativeCursor: Cursor | undefined;\n\n\t/**\n\t * Previously sent data that was buffered and should be prepended to the\n\t * next input.\n\t */\n\tprivate _inputBuffer?: string;\n\n\t/**\n\t * Whether predictions are echoed to the terminal. If false, predictions\n\t * will still be computed internally for latency metrics, but input will\n\t * never be adjusted.\n\t */\n\tprivate _showPredictions = false;\n\n\t/**\n\t * The last successfully-made prediction.\n\t */\n\tprivate _lookBehind?: IPrediction;\n\n\tprivate readonly _addedEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionAdded = this._addedEmitter.event;\n\tprivate readonly _failedEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionFailed = this._failedEmitter.event;\n\tprivate readonly _succeededEmitter = new Emitter<IPrediction>();\n\treadonly onPredictionSucceeded = this._succeededEmitter.event;\n\n\tprivate get _currentGenerationPredictions() {\n\t\treturn this._expected.filter(({ gen }) => gen === this._expected[0].gen).map(({ p }) => p);\n\t}\n\n\tget isShowingPredictions() {\n\t\treturn this._showPredictions;\n\t}\n\n\tget length() {\n\t\treturn this._expected.length;\n\t}\n\n\tconstructor(readonly terminal: Terminal, private readonly _style: TypeAheadStyle) { }\n\n\tsetShowPredictions(show: boolean) {\n\t\tif (show === this._showPredictions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('set predictions:', show);\n\t\tthis._showPredictions = show;\n\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (!buffer) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst toApply = this._currentGenerationPredictions;\n\t\tif (show) {\n\t\t\tthis.clearCursor();\n\t\t\tthis._style.expectIncomingStyle(toApply.reduce((count, p) => p.affectsStyle ? count + 1 : count, 0));\n\t\t\tthis.terminal.write(toApply.map(p => p.apply(buffer, this.physicalCursor(buffer))).join(''));\n\t\t} else {\n\t\t\tthis.terminal.write(toApply.reverse().map(p => p.rollback(this.physicalCursor(buffer))).join(''));\n\t\t}\n\t}\n\n\t/**\n\t * Undoes any predictions written and resets expectations.\n\t */\n\tundoAllPredictions() {\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (this._showPredictions && buffer) {\n\t\t\tthis.terminal.write(this._currentGenerationPredictions.reverse()\n\t\t\t\t.map(p => p.rollback(this.physicalCursor(buffer))).join(''));\n\t\t}\n\n\t\tthis._expected = [];\n\t}\n\n\t/**\n\t * Should be called when input is incoming to the temrinal.\n\t */\n\tbeforeServerInput(input: string): string {\n\t\tconst originalInput = input;\n\t\tif (this._inputBuffer) {\n\t\t\tinput = this._inputBuffer + input;\n\t\t\tthis._inputBuffer = undefined;\n\t\t}\n\n\t\tif (!this._expected.length) {\n\t\t\tthis._clearPredictionState();\n\t\t\treturn input;\n\t\t}\n\n\t\tconst buffer = this._getActiveBuffer();\n\t\tif (!buffer) {\n\t\t\tthis._clearPredictionState();\n\t\t\treturn input;\n\t\t}\n\n\t\tlet output = '';\n\n\t\tconst reader = new StringReader(input);\n\t\tconst startingGen = this._expected[0].gen;\n\t\tconst emitPredictionOmitted = () => {\n\t\t\tconst omit = reader.eatRe(PREDICTION_OMIT_RE);\n\t\t\tif (omit) {\n\t\t\t\toutput += omit[0];\n\t\t\t}\n\t\t};\n\n\t\tReadLoop: while (this._expected.length && reader.remaining > 0) {\n\t\t\temitPredictionOmitted();\n\n\t\t\tconst { p: prediction, gen } = this._expected[0];\n\t\t\tconst cursor = this.physicalCursor(buffer);\n\t\t\tconst beforeTestReaderIndex = reader.index;\n\t\t\tswitch (prediction.matches(reader, this._lookBehind)) {\n\t\t\t\tcase MatchResult.Success: {\n\t\t\t\t\t// if the input character matches what the next prediction expected, undo\n\t\t\t\t\t// the prediction and write the real character out.\n\t\t\t\t\tconst eaten = input.slice(beforeTestReaderIndex, reader.index);\n\t\t\t\t\tif (gen === startingGen) {\n\t\t\t\t\t\toutput += prediction.rollForwards?.(cursor, eaten);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprediction.apply(buffer, this.physicalCursor(buffer)); // move cursor for additional apply\n\t\t\t\t\t\toutput += eaten;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._succeededEmitter.fire(prediction);\n\t\t\t\t\tthis._lookBehind = prediction;\n\t\t\t\t\tthis._expected.shift();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase MatchResult.Buffer:\n\t\t\t\t\t// on a buffer, store the remaining data and completely read data\n\t\t\t\t\t// to be output as normal.\n\t\t\t\t\tthis._inputBuffer = input.slice(beforeTestReaderIndex);\n\t\t\t\t\treader.index = input.length;\n\t\t\t\t\tbreak ReadLoop;\n\t\t\t\tcase MatchResult.Failure: {\n\t\t\t\t\t// on a failure, roll back all remaining items in this generation\n\t\t\t\t\t// and clear predictions, since they are no longer valid\n\t\t\t\t\tconst rollback = this._expected.filter(p => p.gen === startingGen).reverse();\n\t\t\t\t\toutput += rollback.map(({ p }) => p.rollback(this.physicalCursor(buffer))).join('');\n\t\t\t\t\tif (rollback.some(r => r.p.affectsStyle)) {\n\t\t\t\t\t\t// reading the current style should generally be safe, since predictions\n\t\t\t\t\t\t// always restore the style if they modify it.\n\t\t\t\t\t\toutput += attributesToSeq(core(this.terminal)._inputHandler._curAttrData);\n\t\t\t\t\t}\n\t\t\t\t\tthis._clearPredictionState();\n\t\t\t\t\tthis._failedEmitter.fire(prediction);\n\t\t\t\t\tbreak ReadLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\temitPredictionOmitted();\n\n\t\t// Extra data (like the result of running a command) should cause us to\n\t\t// reset the cursor\n\t\tif (!reader.eof) {\n\t\t\toutput += reader.rest;\n\t\t\tthis._clearPredictionState();\n\t\t}\n\n\t\t// If we passed a generation boundary, apply the current generation's predictions\n\t\tif (this._expected.length && startingGen !== this._expected[0].gen) {\n\t\t\tfor (const { p, gen } of this._expected) {\n\t\t\t\tif (gen !== this._expected[0].gen) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (p.affectsStyle) {\n\t\t\t\t\tthis._style.expectIncomingStyle();\n\t\t\t\t}\n\n\t\t\t\toutput += p.apply(buffer, this.physicalCursor(buffer));\n\t\t\t}\n\t\t}\n\n\t\tif (!this._showPredictions) {\n\t\t\treturn originalInput;\n\t\t}\n\n\t\tif (output.length === 0 || output === input) {\n\t\t\treturn output;\n\t\t}\n\n\t\tif (this._physicalCursor) {\n\t\t\toutput += this._physicalCursor.moveInstruction();\n\t\t}\n\n\t\t// prevent cursor flickering while typing\n\t\toutput = VT.HideCursor + output + VT.ShowCursor;\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Clears any expected predictions and stored state. Should be called when\n\t * the pty gives us something we don't recognize.\n\t */\n\tprivate _clearPredictionState() {\n\t\tthis._expected = [];\n\t\tthis.clearCursor();\n\t\tthis._lookBehind = undefined;\n\t}\n\n\t/**\n\t * Appends a typeahead prediction.\n\t */\n\taddPrediction(buffer: IBuffer, prediction: IPrediction) {\n\t\tthis._expected.push({ gen: this._currentGen, p: prediction });\n\t\tthis._addedEmitter.fire(prediction);\n\n\t\tif (this._currentGen !== this._expected[0].gen) {\n\t\t\tprediction.apply(buffer, this.tentativeCursor(buffer));\n\t\t\treturn false;\n\t\t}\n\n\t\tconst text = prediction.apply(buffer, this.physicalCursor(buffer));\n\t\tthis._tenativeCursor = undefined; // next read will get or clone the physical cursor\n\n\t\tif (this._showPredictions && text) {\n\t\t\tif (prediction.affectsStyle) {\n\t\t\t\tthis._style.expectIncomingStyle();\n\t\t\t}\n\t\t\t// console.log('predict:', JSON.stringify(text));\n\t\t\tthis.terminal.write(text);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Appends a prediction followed by a boundary. The predictions applied\n\t * after this one will only be displayed after the give prediction matches\n\t * pty output/\n\t */\n\taddBoundary(): void;\n\taddBoundary(buffer: IBuffer, prediction: IPrediction): boolean;\n\taddBoundary(buffer?: IBuffer, prediction?: IPrediction) {\n\t\tlet applied = false;\n\t\tif (buffer && prediction) {\n\t\t\t// We apply the prediction so that it's matched against, but wrapped\n\t\t\t// in a tentativeboundary so that it doesn't affect the physical cursor.\n\t\t\t// Then we apply it specifically to the tentative cursor.\n\t\t\tapplied = this.addPrediction(buffer, new TentativeBoundary(prediction));\n\t\t\tprediction.apply(buffer, this.tentativeCursor(buffer));\n\t\t}\n\t\tthis._currentGen++;\n\t\treturn applied;\n\t}\n\n\t/**\n\t * Peeks the last prediction written.\n\t */\n\tpeekEnd(): IPrediction | undefined {\n\t\treturn this._expected[this._expected.length - 1]?.p;\n\t}\n\n\t/**\n\t * Peeks the first pending prediction.\n\t */\n\tpeekStart(): IPrediction | undefined {\n\t\treturn this._expected[0]?.p;\n\t}\n\n\t/**\n\t * Current position of the cursor in the terminal.\n\t */\n\tphysicalCursor(buffer: IBuffer) {\n\t\tif (!this._physicalCursor) {\n\t\t\tif (this._showPredictions) {\n\t\t\t\tflushOutput(this.terminal);\n\t\t\t}\n\t\t\tthis._physicalCursor = new Cursor(this.terminal.rows, this.terminal.cols, buffer);\n\t\t}\n\n\t\treturn this._physicalCursor;\n\t}\n\n\t/**\n\t * Cursor position if all predictions and boundaries that have been inserted\n\t * so far turn out to be successfully predicted.\n\t */\n\ttentativeCursor(buffer: IBuffer) {\n\t\tif (!this._tenativeCursor) {\n\t\t\tthis._tenativeCursor = this.physicalCursor(buffer).clone();\n\t\t}\n\n\t\treturn this._tenativeCursor;\n\t}\n\n\tclearCursor() {\n\t\tthis._physicalCursor = undefined;\n\t\tthis._tenativeCursor = undefined;\n\t}\n\n\tprivate _getActiveBuffer() {\n\t\tconst buffer = this.terminal.buffer.active;\n\t\treturn buffer.type === 'normal' ? buffer : undefined;\n\t}\n}\n\n/**\n * Gets the escape sequence args to restore state/appearance in the cell.\n */\nconst attributesToArgs = (cell: XtermAttributes) => {\n\tif (cell.isAttributeDefault()) { return [0]; }\n\n\tconst args = [];\n\tif (cell.isBold()) { args.push(1); }\n\tif (cell.isDim()) { args.push(2); }\n\tif (cell.isItalic()) { args.push(3); }\n\tif (cell.isUnderline()) { args.push(4); }\n\tif (cell.isBlink()) { args.push(5); }\n\tif (cell.isInverse()) { args.push(7); }\n\tif (cell.isInvisible()) { args.push(8); }\n\n\tif (cell.isFgRGB()) { args.push(38, 2, cell.getFgColor() >>> 24, (cell.getFgColor() >>> 16) & 0xFF, cell.getFgColor() & 0xFF); }\n\tif (cell.isFgPalette()) { args.push(38, 5, cell.getFgColor()); }\n\tif (cell.isFgDefault()) { args.push(39); }\n\n\tif (cell.isBgRGB()) { args.push(48, 2, cell.getBgColor() >>> 24, (cell.getBgColor() >>> 16) & 0xFF, cell.getBgColor() & 0xFF); }\n\tif (cell.isBgPalette()) { args.push(48, 5, cell.getBgColor()); }\n\tif (cell.isBgDefault()) { args.push(49); }\n\n\treturn args;\n};\n\n/**\n * Gets the escape sequence to restore state/appearance in the cell.\n */\nconst attributesToSeq = (cell: XtermAttributes) => `${VT.Csi}${attributesToArgs(cell).join(';')}m`;\n\nconst arrayHasPrefixAt = <T>(a: ReadonlyArray<T>, ai: number, b: ReadonlyArray<T>) => {\n\tif (a.length - ai > b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let bi = 0; bi < b.length; bi++, ai++) {\n\t\tif (b[ai] !== a[ai]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n/**\n * @see https://github.com/xtermjs/xterm.js/blob/065eb13a9d3145bea687239680ec9696d9112b8e/src/common/InputHandler.ts#L2127\n */\nconst getColorWidth = (params: SingleOrMany<number>[], pos: number) => {\n\tconst accu = [0, 0, -1, 0, 0, 0];\n\tlet cSpace = 0;\n\tlet advance = 0;\n\n\tdo {\n\t\tconst v = params[pos + advance];\n\t\taccu[advance + cSpace] = isNumber(v) ? v : v[0];\n\t\tif (!isNumber(v)) {\n\t\t\tlet i = 0;\n\t\t\tdo {\n\t\t\t\tif (accu[1] === 5) {\n\t\t\t\t\tcSpace = 1;\n\t\t\t\t}\n\t\t\t\taccu[advance + i + 1 + cSpace] = v[i];\n\t\t\t} while (++i < v.length && i + advance + 1 + cSpace < accu.length);\n\t\t\tbreak;\n\t\t}\n\t\t// exit early if can decide color mode with semicolons\n\t\tif ((accu[1] === 5 && advance + cSpace >= 2)\n\t\t\t|| (accu[1] === 2 && advance + cSpace >= 5)) {\n\t\t\tbreak;\n\t\t}\n\t\t// offset colorSpace slot for semicolon mode\n\t\tif (accu[1]) {\n\t\t\tcSpace = 1;\n\t\t}\n\t} while (++advance + pos < params.length && advance + cSpace < accu.length);\n\n\treturn advance;\n};\n\nclass TypeAheadStyle implements IDisposable {\n\tprivate static _compileArgs(args: ReadonlyArray<number>) {\n\t\treturn `${VT.Csi}${args.join(';')}m`;\n\t}\n\n\t/**\n\t * Number of typeahead style arguments we expect to read. If this is 0 and\n\t * we see a style coming in, we know that the PTY actually wanted to update.\n\t */\n\tprivate _expectedIncomingStyles = 0;\n\tprivate _applyArgs!: ReadonlyArray<number>;\n\tprivate _originalUndoArgs!: ReadonlyArray<number>;\n\tprivate _undoArgs!: ReadonlyArray<number>;\n\n\tapply!: string;\n\tundo!: string;\n\tprivate _csiHandler?: IDisposable;\n\n\tconstructor(value: ITerminalTypeAheadConfiguration['localEchoStyle'], private readonly _terminal: Terminal) {\n\t\tthis.onUpdate(value);\n\t}\n\n\t/**\n\t * Signals that a style was written to the terminal and we should watch\n\t * for it coming in.\n\t */\n\texpectIncomingStyle(n = 1) {\n\t\tthis._expectedIncomingStyles += n * 2;\n\t}\n\n\t/**\n\t * Starts tracking for CSI changes in the terminal.\n\t */\n\tstartTracking() {\n\t\tthis._expectedIncomingStyles = 0;\n\t\tthis._onDidWriteSGR(attributesToArgs(core(this._terminal)._inputHandler._curAttrData));\n\t\tthis._csiHandler = this._terminal.parser.registerCsiHandler({ final: 'm' }, args => {\n\t\t\tthis._onDidWriteSGR(args);\n\t\t\treturn false;\n\t\t});\n\t}\n\n\t/**\n\t * Stops tracking terminal CSI changes.\n\t */\n\t@debounce(2000)\n\tdebounceStopTracking() {\n\t\tthis._stopTracking();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tdispose() {\n\t\tthis._stopTracking();\n\t}\n\n\tprivate _stopTracking() {\n\t\tthis._csiHandler?.dispose();\n\t\tthis._csiHandler = undefined;\n\t}\n\n\tprivate _onDidWriteSGR(args: SingleOrMany<number>[]) {\n\t\tconst originalUndo = this._undoArgs;\n\t\tfor (let i = 0; i < args.length;) {\n\t\t\tconst px = args[i];\n\t\t\tconst p = isNumber(px) ? px : px[0];\n\n\t\t\tif (this._expectedIncomingStyles) {\n\t\t\t\tif (arrayHasPrefixAt(args, i, this._undoArgs)) {\n\t\t\t\t\tthis._expectedIncomingStyles--;\n\t\t\t\t\ti += this._undoArgs.length;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (arrayHasPrefixAt(args, i, this._applyArgs)) {\n\t\t\t\t\tthis._expectedIncomingStyles--;\n\t\t\t\t\ti += this._applyArgs.length;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst width = p === 38 || p === 48 || p === 58 ? getColorWidth(args, i) : 1;\n\t\t\tswitch (this._applyArgs[0]) {\n\t\t\t\tcase 1:\n\t\t\t\t\tif (p === 2) {\n\t\t\t\t\t\tthis._undoArgs = [22, 2];\n\t\t\t\t\t} else if (p === 22 || p === 0) {\n\t\t\t\t\t\tthis._undoArgs = [22];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (p === 1) {\n\t\t\t\t\t\tthis._undoArgs = [22, 1];\n\t\t\t\t\t} else if (p === 22 || p === 0) {\n\t\t\t\t\t\tthis._undoArgs = [22];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\tif (p === 0 || p === 39 || p === 100) {\n\t\t\t\t\t\tthis._undoArgs = [39];\n\t\t\t\t\t} else if ((p >= 30 && p <= 38) || (p >= 90 && p <= 97)) {\n\t\t\t\t\t\tthis._undoArgs = args.slice(i, i + width) as number[];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (p === this._applyArgs[0]) {\n\t\t\t\t\t\tthis._undoArgs = this._applyArgs;\n\t\t\t\t\t} else if (p === 0) {\n\t\t\t\t\t\tthis._undoArgs = this._originalUndoArgs;\n\t\t\t\t\t}\n\t\t\t\t// no-op\n\t\t\t}\n\n\t\t\ti += width;\n\t\t}\n\n\t\tif (originalUndo !== this._undoArgs) {\n\t\t\tthis.undo = TypeAheadStyle._compileArgs(this._undoArgs);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the current typeahead style.\n\t */\n\tonUpdate(style: ITerminalTypeAheadConfiguration['localEchoStyle']) {\n\t\tconst { applyArgs, undoArgs } = this._getArgs(style);\n\t\tthis._applyArgs = applyArgs;\n\t\tthis._undoArgs = this._originalUndoArgs = undoArgs;\n\t\tthis.apply = TypeAheadStyle._compileArgs(this._applyArgs);\n\t\tthis.undo = TypeAheadStyle._compileArgs(this._undoArgs);\n\t}\n\n\tprivate _getArgs(style: ITerminalTypeAheadConfiguration['localEchoStyle']) {\n\t\tswitch (style) {\n\t\t\tcase 'bold':\n\t\t\t\treturn { applyArgs: [1], undoArgs: [22] };\n\t\t\tcase 'dim':\n\t\t\t\treturn { applyArgs: [2], undoArgs: [22] };\n\t\t\tcase 'italic':\n\t\t\t\treturn { applyArgs: [3], undoArgs: [23] };\n\t\t\tcase 'underlined':\n\t\t\t\treturn { applyArgs: [4], undoArgs: [24] };\n\t\t\tcase 'inverted':\n\t\t\t\treturn { applyArgs: [7], undoArgs: [27] };\n\t\t\tdefault: {\n\t\t\t\tlet color: Color;\n\t\t\t\ttry {\n\t\t\t\t\tcolor = Color.fromHex(style);\n\t\t\t\t} catch {\n\t\t\t\t\tcolor = new Color(new RGBA(255, 0, 0, 1));\n\t\t\t\t}\n\n\t\t\t\tconst { r, g, b } = color.rgba;\n\t\t\t\treturn { applyArgs: [38, 2, r, g, b], undoArgs: [39] };\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst compileExcludeRegexp = (programs = DEFAULT_LOCAL_ECHO_EXCLUDE) =>\n\tnew RegExp(`\\\\b(${programs.map(escapeRegExpCharacters).join('|')})\\\\b`, 'i');\n\nexport const enum CharPredictState {\n\t/** No characters typed on this line yet */\n\tUnknown,\n\t/** Has a pending character prediction */\n\tHasPendingChar,\n\t/** Character validated on this line */\n\tValidated,\n}\n\nexport class TypeAheadAddon extends Disposable implements ITerminalAddon {\n\tprivate _typeaheadStyle?: TypeAheadStyle;\n\tprivate _typeaheadThreshold: number;\n\tprivate _excludeProgramRe: RegExp;\n\tprotected _lastRow?: { y: number; startingX: number; endingX: number; charState: CharPredictState };\n\tprotected _timeline?: PredictionTimeline;\n\tprivate _terminalTitle = '';\n\tstats?: PredictionStats;\n\n\t/**\n\t * Debounce that clears predictions after a timeout if the PTY doesn't apply them.\n\t */\n\tprivate _clearPredictionDebounce?: IDisposable;\n\n\tconstructor(\n\t\tprivate _processManager: ITerminalProcessManager,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService,\n\t) {\n\t\tsuper();\n\t\tthis._typeaheadThreshold = this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoLatencyThreshold;\n\t\tthis._excludeProgramRe = compileExcludeRegexp(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoExcludePrograms);\n\t\tthis._register(toDisposable(() => this._clearPredictionDebounce?.dispose()));\n\t}\n\n\tactivate(terminal: Terminal): void {\n\t\tconst style = this._typeaheadStyle = this._register(new TypeAheadStyle(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoStyle, terminal));\n\t\tconst timeline = this._timeline = new PredictionTimeline(terminal, this._typeaheadStyle);\n\t\tconst stats = this.stats = this._register(new PredictionStats(this._timeline));\n\n\t\ttimeline.setShowPredictions(this._typeaheadThreshold === 0);\n\t\tthis._register(terminal.onData(e => this._onUserData(e)));\n\t\tthis._register(terminal.onTitleChange(title => {\n\t\t\tthis._terminalTitle = title;\n\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t}));\n\t\tthis._register(terminal.onResize(() => {\n\t\t\ttimeline.setShowPredictions(false);\n\t\t\ttimeline.clearCursor();\n\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t}));\n\t\tthis._register(this._configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration(TERMINAL_CONFIG_SECTION)) {\n\t\t\t\tstyle.onUpdate(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoStyle);\n\t\t\t\tthis._typeaheadThreshold = this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoLatencyThreshold;\n\t\t\t\tthis._excludeProgramRe = compileExcludeRegexp(this._configurationService.getValue<ITerminalTypeAheadConfiguration>(TERMINAL_CONFIG_SECTION).localEchoExcludePrograms);\n\t\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t\t}\n\t\t}));\n\t\tthis._register(this._timeline.onPredictionSucceeded(p => {\n\t\t\tif (this._lastRow?.charState === CharPredictState.HasPendingChar && isTenativeCharacterPrediction(p) && p.inner.appliedAt) {\n\t\t\t\tif (p.inner.appliedAt.pos.y + p.inner.appliedAt.pos.baseY === this._lastRow.y) {\n\t\t\t\t\tthis._lastRow.charState = CharPredictState.Validated;\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\tthis._register(this._processManager.onBeforeProcessData(e => this._onBeforeProcessData(e)));\n\n\t\tlet nextStatsSend: Timeout | undefined;\n\t\tthis._register(stats.onChange(() => {\n\t\t\tif (!nextStatsSend) {\n\t\t\t\tnextStatsSend = setTimeout(() => {\n\t\t\t\t\tthis._sendLatencyStats(stats);\n\t\t\t\t\tnextStatsSend = undefined;\n\t\t\t\t}, StatsConstants.StatsSendTelemetryEvery);\n\t\t\t}\n\n\t\t\tif (timeline.length === 0) {\n\t\t\t\tstyle.debounceStopTracking();\n\t\t\t}\n\n\t\t\tthis._reevaluatePredictorState(stats, timeline);\n\t\t}));\n\t}\n\n\treset() {\n\t\tthis._lastRow = undefined;\n\t}\n\n\tprivate _deferClearingPredictions() {\n\t\tif (!this.stats || !this._timeline) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clearPredictionDebounce?.dispose();\n\t\tif (this._timeline.length === 0 || this._timeline.peekStart()?.clearAfterTimeout === false) {\n\t\t\tthis._clearPredictionDebounce = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clearPredictionDebounce = disposableTimeout(\n\t\t\t() => {\n\t\t\t\tthis._timeline?.undoAllPredictions();\n\t\t\t\tif (this._lastRow?.charState === CharPredictState.HasPendingChar) {\n\t\t\t\t\tthis._lastRow.charState = CharPredictState.Unknown;\n\t\t\t\t}\n\t\t\t},\n\t\t\tMath.max(500, this.stats.maxLatency * 3 / 2),\n\t\t\tthis._store\n\t\t);\n\t}\n\n\t/**\n\t * Note on debounce:\n\t *\n\t * We want to toggle the state only when the user has a pause in their\n\t * typing. Otherwise, we could turn this on when the PTY sent data but the\n\t * terminal cursor is not updated, causes issues.\n\t */\n\t@debounce(100)\n\tprotected _reevaluatePredictorState(stats: PredictionStats, timeline: PredictionTimeline) {\n\t\tthis._reevaluatePredictorStateNow(stats, timeline);\n\t}\n\n\tprotected _reevaluatePredictorStateNow(stats: PredictionStats, timeline: PredictionTimeline) {\n\t\tif (this._excludeProgramRe.test(this._terminalTitle)) {\n\t\t\ttimeline.setShowPredictions(false);\n\t\t} else if (this._typeaheadThreshold < 0) {\n\t\t\ttimeline.setShowPredictions(false);\n\t\t} else if (this._typeaheadThreshold === 0) {\n\t\t\ttimeline.setShowPredictions(true);\n\t\t} else if (stats.sampleSize > StatsConstants.StatsMinSamplesToTurnOn && stats.accuracy > StatsConstants.StatsMinAccuracyToTurnOn) {\n\t\t\tconst latency = stats.latency.median;\n\t\t\tif (latency >= this._typeaheadThreshold) {\n\t\t\t\ttimeline.setShowPredictions(true);\n\t\t\t} else if (latency < this._typeaheadThreshold / StatsConstants.StatsToggleOffThreshold) {\n\t\t\t\ttimeline.setShowPredictions(false);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _sendLatencyStats(stats: PredictionStats) {\n\t\t/* __GDPR__\n\t\t\t\"terminalLatencyStats\" : {\n\t\t\t\t\"owner\": \"Tyriar\",\n\t\t\t\t\"min\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"max\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"median\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"count\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"predictionAccuracy\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true }\n\t\t\t}\n\t\t */\n\t\tthis._telemetryService.publicLog('terminalLatencyStats', {\n\t\t\t...stats.latency,\n\t\t\tpredictionAccuracy: stats.accuracy,\n\t\t});\n\t}\n\n\tprivate _onUserData(data: string): void {\n\t\tif (this._timeline?.terminal.buffer.active.type !== 'normal') {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('user data:', JSON.stringify(data));\n\n\t\tconst terminal = this._timeline.terminal;\n\t\tconst buffer = terminal.buffer.active;\n\n\t\t// Detect programs like git log/less that use the normal buffer but don't\n\t\t// take input by deafult (fixes #109541)\n\t\tif (buffer.cursorX === 1 && buffer.cursorY === terminal.rows - 1) {\n\t\t\tif (buffer.getLine(buffer.cursorY + buffer.baseY)?.getCell(0)?.getChars() === ':') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// the following code guards the terminal prompt to avoid being able to\n\t\t// arrow or backspace-into the prompt. Record the lowest X value at which\n\t\t// the user gave input, and mark all additions before that as tentative.\n\t\tconst actualY = buffer.baseY + buffer.cursorY;\n\t\tif (actualY !== this._lastRow?.y) {\n\t\t\tthis._lastRow = { y: actualY, startingX: buffer.cursorX, endingX: buffer.cursorX, charState: CharPredictState.Unknown };\n\t\t} else {\n\t\t\tthis._lastRow.startingX = Math.min(this._lastRow.startingX, buffer.cursorX);\n\t\t\tthis._lastRow.endingX = Math.max(this._lastRow.endingX, this._timeline.physicalCursor(buffer).x);\n\t\t}\n\n\t\tconst addLeftNavigating = (p: IPrediction) =>\n\t\t\tthis._timeline!.tentativeCursor(buffer).x <= this._lastRow!.startingX\n\t\t\t\t? this._timeline!.addBoundary(buffer, p)\n\t\t\t\t: this._timeline!.addPrediction(buffer, p);\n\n\t\tconst addRightNavigating = (p: IPrediction) =>\n\t\t\tthis._timeline!.tentativeCursor(buffer).x >= this._lastRow!.endingX - 1\n\t\t\t\t? this._timeline!.addBoundary(buffer, p)\n\t\t\t\t: this._timeline!.addPrediction(buffer, p);\n\n\t\t/** @see https://github.com/xtermjs/xterm.js/blob/1913e9512c048e3cf56bb5f5df51bfff6899c184/src/common/input/Keyboard.ts */\n\t\tconst reader = new StringReader(data);\n\t\twhile (reader.remaining > 0) {\n\t\t\tif (reader.eatCharCode(127)) { // backspace\n\t\t\t\tconst previous = this._timeline.peekEnd();\n\t\t\t\tif (previous && previous instanceof CharacterPrediction) {\n\t\t\t\t\tthis._timeline.addBoundary();\n\t\t\t\t}\n\n\t\t\t\t// backspace must be able to read the previously-written character in\n\t\t\t\t// the event that it needs to undo it\n\t\t\t\tif (this._timeline.isShowingPredictions) {\n\t\t\t\t\tflushOutput(this._timeline.terminal);\n\t\t\t\t}\n\n\t\t\t\tif (this._timeline.tentativeCursor(buffer).x <= this._lastRow.startingX) {\n\t\t\t\t\tthis._timeline.addBoundary(buffer, new BackspacePrediction(this._timeline.terminal));\n\t\t\t\t} else {\n\t\t\t\t\t// Backspace decrements our ability to go right.\n\t\t\t\t\tthis._lastRow.endingX--;\n\t\t\t\t\tthis._timeline.addPrediction(buffer, new BackspacePrediction(this._timeline.terminal));\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatCharCode(32, 126)) { // alphanum\n\t\t\t\tconst char = data[reader.index - 1];\n\t\t\t\tconst prediction = new CharacterPrediction(this._typeaheadStyle!, char);\n\t\t\t\tif (this._lastRow.charState === CharPredictState.Unknown) {\n\t\t\t\t\tthis._timeline.addBoundary(buffer, prediction);\n\t\t\t\t\tthis._lastRow.charState = CharPredictState.HasPendingChar;\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline.addPrediction(buffer, prediction);\n\t\t\t\t}\n\n\t\t\t\tif (this._timeline.tentativeCursor(buffer).x >= terminal.cols) {\n\t\t\t\t\tthis._timeline.addBoundary(buffer, new LinewrapPrediction());\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst cursorMv = reader.eatRe(CSI_MOVE_RE);\n\t\t\tif (cursorMv) {\n\t\t\t\tconst direction = cursorMv[3] as CursorMoveDirection;\n\t\t\t\tconst p = new CursorMovePrediction(direction, !!cursorMv[2], Number(cursorMv[1]) || 1);\n\t\t\t\tif (direction === CursorMoveDirection.Back) {\n\t\t\t\t\taddLeftNavigating(p);\n\t\t\t\t} else {\n\t\t\t\t\taddRightNavigating(p);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatStr(`${VT.Esc}f`)) {\n\t\t\t\taddRightNavigating(new CursorMovePrediction(CursorMoveDirection.Forwards, true, 1));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatStr(`${VT.Esc}b`)) {\n\t\t\t\taddLeftNavigating(new CursorMovePrediction(CursorMoveDirection.Back, true, 1));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (reader.eatChar('\\r') && buffer.cursorY < terminal.rows - 1) {\n\t\t\t\tthis._timeline.addPrediction(buffer, new NewlinePrediction());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// something else\n\t\t\tthis._timeline.addBoundary(buffer, new HardBoundary());\n\t\t\tbreak;\n\t\t}\n\n\t\tif (this._timeline.length === 1) {\n\t\t\tthis._deferClearingPredictions();\n\t\t\tthis._typeaheadStyle!.startTracking();\n\t\t}\n\t}\n\n\tprivate _onBeforeProcessData(event: IBeforeProcessDataEvent): void {\n\t\tif (!this._timeline) {\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('incoming data:', JSON.stringify(event.data));\n\t\tevent.data = this._timeline.beforeServerInput(event.data);\n\t\t// console.log('emitted data:', JSON.stringify(event.data));\n\n\t\tthis._deferClearingPredictions();\n\t}\n}\n"]}