{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/links/browser/terminalLocalLinkDetector.ts","vs/workbench/contrib/terminalContrib/links/browser/terminalLocalLinkDetector.ts"],"names":[],"mappings":"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","file":"terminalLocalLinkDetector.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OS } from '../../../../../base/common/platform.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IUriIdentityService } from '../../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IWorkspaceContextService } from '../../../../../platform/workspace/common/workspace.js';\nimport { ITerminalLinkDetector, ITerminalLinkResolver, ITerminalSimpleLink, ResolvedLink, TerminalBuiltinLinkType } from './links.js';\nimport { convertLinkRangeToBuffer, getXtermLineContent, getXtermRangesByAttr, osPathModule, updateLinkWithRelativeCwd } from './terminalLinkHelpers.js';\nimport { ITerminalCapabilityStore, TerminalCapability } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport type { IBufferLine, IBufferRange, Terminal } from '@xterm/xterm';\nimport { ITerminalProcessManager } from '../../../terminal/common/terminal.js';\nimport { detectLinks } from './terminalLinkParsing.js';\nimport { ITerminalBackend, ITerminalLogService } from '../../../../../platform/terminal/common/terminal.js';\n\nconst enum Constants {\n\t/**\n\t * The max line length to try extract word links from.\n\t */\n\tMaxLineLength = 2000,\n\n\t/**\n\t * The maximum number of links in a line to resolve against the file system. This limit is put\n\t * in place to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinksInLine = 10,\n\n\t/**\n\t * The maximum length of a link to resolve against the file system. This limit is put in place\n\t * to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinkLength = 1024,\n}\n\nconst fallbackMatchers: RegExp[] = [\n\t// Python style error: File \"<path>\", line <line>\n\t/^ *File (?<link>\"(?<path>.+)\"(, line (?<line>\\d+))?)/,\n\t// Unknown tool #200166: FILE  <path>:<line>:<col>\n\t/^ +FILE +(?<link>(?<path>.+)(?::(?<line>\\d+)(?::(?<col>\\d+))?)?)/,\n\t// Some C++ compile error formats:\n\t// C:\\foo\\bar baz(339) : error ...\n\t// C:\\foo\\bar baz(339,12) : error ...\n\t// C:\\foo\\bar baz(339, 12) : error ...\n\t// C:\\foo\\bar baz(339): error ...       [#178584, Visual Studio CL/NVIDIA CUDA compiler]\n\t// C:\\foo\\bar baz(339,12): ...\n\t// C:\\foo\\bar baz(339, 12): ...\n\t/^(?<link>(?<path>.+)\\((?<line>\\d+)(?:, ?(?<col>\\d+))?\\)) ?:/,\n\t// C:\\foo/bar baz:339 : error ...\n\t// C:\\foo/bar baz:339:12 : error ...\n\t// C:\\foo/bar baz:339: error ...\n\t// C:\\foo/bar baz:339:12: error ...     [#178584, Clang]\n\t/^(?<link>(?<path>.+):(?<line>\\d+)(?::(?<col>\\d+))?) ?:/,\n\t// PowerShell and cmd prompt\n\t/^(?:PS\\s+)?(?<link>(?<path>[^>]+))>/,\n\t// The whole line is the path\n\t/^ *(?<link>(?<path>.+))/\n];\n\nexport class TerminalLocalLinkDetector implements ITerminalLinkDetector {\n\tstatic id = 'local';\n\n\t// This was chosen as a reasonable maximum line length given the tradeoff between performance\n\t// and how likely it is to encounter such a large line length. Some useful reference points:\n\t// - Window old max length: 260 ($MAX_PATH)\n\t// - Linux max length: 4096 ($PATH_MAX)\n\treadonly maxLinkLength = 500;\n\n\tconstructor(\n\t\treadonly xterm: Terminal,\n\t\tprivate readonly _capabilities: ITerminalCapabilityStore,\n\t\tprivate readonly _processManager: Pick<ITerminalProcessManager, 'initialCwd' | 'os' | 'remoteAuthority' | 'userHome'> & { backend?: Pick<ITerminalBackend, 'getWslPath'> },\n\t\tprivate readonly _linkResolver: ITerminalLinkResolver,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService,\n\t\t@IWorkspaceContextService private readonly _workspaceContextService: IWorkspaceContextService\n\t) {\n\t}\n\n\tasync detect(lines: IBufferLine[], startLine: number, endLine: number): Promise<ITerminalSimpleLink[]> {\n\t\tconst links: ITerminalSimpleLink[] = [];\n\n\t\t// Get the text representation of the wrapped line\n\t\tconst text = getXtermLineContent(this.xterm.buffer.active, startLine, endLine, this.xterm.cols);\n\t\tif (text === '' || text.length > Constants.MaxLineLength) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet stringIndex = -1;\n\t\tlet resolvedLinkCount = 0;\n\n\t\tconst os = this._processManager.os || OS;\n\t\tconst parsedLinks = detectLinks(text, os);\n\t\tthis._logService.trace('terminalLocalLinkDetector#detect text', text);\n\t\tthis._logService.trace('terminalLocalLinkDetector#detect parsedLinks', parsedLinks);\n\t\tfor (const parsedLink of parsedLinks) {\n\n\t\t\t// Don't try resolve any links of excessive length\n\t\t\tif (parsedLink.path.text.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Convert the link text's string index into a wrapped buffer range\n\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\tstartColumn: (parsedLink.prefix?.index ?? parsedLink.path.index) + 1,\n\t\t\t\tstartLineNumber: 1,\n\t\t\t\tendColumn: parsedLink.path.index + parsedLink.path.text.length + (parsedLink.suffix?.suffix.text.length ?? 0) + 1,\n\t\t\t\tendLineNumber: 1\n\t\t\t}, startLine);\n\n\t\t\t// Get a single link candidate if the cwd of the line is known\n\t\t\tconst linkCandidates: string[] = [];\n\t\t\tconst osPath = osPathModule(os);\n\t\t\tconst isUri = parsedLink.path.text.startsWith('file://');\n\t\t\tif (osPath.isAbsolute(parsedLink.path.text) || parsedLink.path.text.startsWith('~') || isUri) {\n\t\t\t\tlinkCandidates.push(parsedLink.path.text);\n\t\t\t} else {\n\t\t\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\t\t\tconst absolutePath = updateLinkWithRelativeCwd(this._capabilities, bufferRange.start.y, parsedLink.path.text, osPath, this._logService);\n\t\t\t\t\t// Only add a single exact link candidate if the cwd is available, this may cause\n\t\t\t\t\t// the link to not be resolved but that should only occur when the actual file does\n\t\t\t\t\t// not exist. Doing otherwise could cause unexpected results where handling via the\n\t\t\t\t\t// word link detector is preferable.\n\t\t\t\t\tif (absolutePath) {\n\t\t\t\t\t\tlinkCandidates.push(...absolutePath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Fallback to resolving against the initial cwd, removing any relative directory prefixes\n\t\t\t\tif (linkCandidates.length === 0) {\n\t\t\t\t\tlinkCandidates.push(parsedLink.path.text);\n\t\t\t\t\tif (parsedLink.path.text.match(/^(\\.\\.[\\/\\\\])+/)) {\n\t\t\t\t\t\tlinkCandidates.push(parsedLink.path.text.replace(/^(\\.\\.[\\/\\\\])+/, ''));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If any candidates end with special characters that are likely to not be part of the\n\t\t\t// link, add a candidate excluding them.\n\t\t\tconst specialEndCharRegex = /[\\[\\]\"'\\.]$/;\n\t\t\tconst trimRangeMap: Map<string, number> = new Map();\n\t\t\tconst specialEndLinkCandidates: string[] = [];\n\t\t\tfor (const candidate of linkCandidates) {\n\t\t\t\tlet previous = candidate;\n\t\t\t\tlet removed = previous.replace(specialEndCharRegex, '');\n\t\t\t\tlet trimRange = 0;\n\t\t\t\twhile (removed !== previous) {\n\t\t\t\t\t// Only trim the link if there is no suffix, otherwise the underline would be incorrect\n\t\t\t\t\tif (!parsedLink.suffix) {\n\t\t\t\t\t\ttrimRange++;\n\t\t\t\t\t}\n\t\t\t\t\tspecialEndLinkCandidates.push(removed);\n\t\t\t\t\ttrimRangeMap.set(removed, trimRange);\n\t\t\t\t\tprevious = removed;\n\t\t\t\t\tremoved = removed.replace(specialEndCharRegex, '');\n\t\t\t\t}\n\t\t\t}\n\t\t\tlinkCandidates.push(...specialEndLinkCandidates);\n\t\t\tthis._logService.trace('terminalLocalLinkDetector#detect linkCandidates', linkCandidates);\n\n\t\t\t// Validate the path and convert to the outgoing type\n\t\t\tconst simpleLink = await this._validateAndGetLink(undefined, bufferRange, linkCandidates, trimRangeMap);\n\t\t\tif (simpleLink) {\n\t\t\t\tsimpleLink.parsedLink = parsedLink;\n\t\t\t\tsimpleLink.text = text.substring(\n\t\t\t\t\tparsedLink.prefix?.index ?? parsedLink.path.index,\n\t\t\t\t\tparsedLink.suffix ? parsedLink.suffix.suffix.index + parsedLink.suffix.suffix.text.length : parsedLink.path.index + parsedLink.path.text.length\n\t\t\t\t);\n\t\t\t\tthis._logService.trace('terminalLocalLinkDetector#detect verified link', simpleLink);\n\t\t\t\tlinks.push(simpleLink);\n\t\t\t}\n\n\t\t\t// Stop early if too many links exist in the line\n\t\t\tif (++resolvedLinkCount >= Constants.MaxResolvedLinksInLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Match against the fallback matchers which are mainly designed to catch paths with spaces\n\t\t// that aren't possible using the regular mechanism.\n\t\tif (links.length === 0) {\n\t\t\tfor (const matcher of fallbackMatchers) {\n\t\t\t\tconst match = text.match(matcher);\n\t\t\t\tconst group = match?.groups;\n\t\t\t\tif (!group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst link = group?.link;\n\t\t\t\tconst path = group?.path;\n\t\t\t\tconst line = group?.line;\n\t\t\t\tconst col = group?.col;\n\t\t\t\tif (!link || !path) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Don't try resolve any links of excessive length\n\t\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Convert the link text's string index into a wrapped buffer range\n\t\t\t\tstringIndex = text.indexOf(link);\n\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\t\tstartColumn: stringIndex + 1,\n\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\tendColumn: stringIndex + link.length + 1,\n\t\t\t\t\tendLineNumber: 1\n\t\t\t\t}, startLine);\n\n\t\t\t\t// Validate and add link\n\t\t\t\tconst suffix = line ? `:${line}${col ? `:${col}` : ''}` : '';\n\t\t\t\tconst simpleLink = await this._validateAndGetLink(`${path}${suffix}`, bufferRange, [path]);\n\t\t\t\tif (simpleLink) {\n\t\t\t\t\tlinks.push(simpleLink);\n\t\t\t\t}\n\n\t\t\t\t// Only match a single fallback matcher\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Sometimes links are styled specially in the terminal like underlined or bolded, try split\n\t\t// the line by attributes and test whether it matches a path\n\t\tif (links.length === 0) {\n\t\t\tconst rangeCandidates = getXtermRangesByAttr(this.xterm.buffer.active, startLine, endLine, this.xterm.cols);\n\t\t\tfor (const rangeCandidate of rangeCandidates) {\n\t\t\t\tlet text = '';\n\t\t\t\tfor (let y = rangeCandidate.start.y; y <= rangeCandidate.end.y; y++) {\n\t\t\t\t\tconst line = this.xterm.buffer.active.getLine(y);\n\t\t\t\t\tif (!line) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst lineStartX = y === rangeCandidate.start.y ? rangeCandidate.start.x : 0;\n\t\t\t\t\tconst lineEndX = y === rangeCandidate.end.y ? rangeCandidate.end.x : this.xterm.cols - 1;\n\t\t\t\t\ttext += line.translateToString(false, lineStartX, lineEndX);\n\t\t\t\t}\n\n\t\t\t\t// HACK: Adjust to 1-based for link API\n\t\t\t\trangeCandidate.start.x++;\n\t\t\t\trangeCandidate.start.y++;\n\t\t\t\trangeCandidate.end.y++;\n\n\t\t\t\t// Validate and add link\n\t\t\t\tconst simpleLink = await this._validateAndGetLink(text, rangeCandidate, [text]);\n\t\t\t\tif (simpleLink) {\n\t\t\t\t\tlinks.push(simpleLink);\n\t\t\t\t}\n\n\t\t\t\t// Stop early if too many links exist in the line\n\t\t\t\tif (++resolvedLinkCount >= Constants.MaxResolvedLinksInLine) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\tprivate async _validateLinkCandidates(linkCandidates: string[]): Promise<ResolvedLink | undefined> {\n\t\tfor (const link of linkCandidates) {\n\t\t\tlet uri: URI | undefined;\n\t\t\tif (link.startsWith('file://')) {\n\t\t\t\turi = URI.parse(link);\n\t\t\t}\n\t\t\tconst result = await this._linkResolver.resolveLink(this._processManager, link, uri);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Validates a set of link candidates and returns a link if validated.\n\t * @param linkText The link text, this should be undefined to use the link stat value\n\t * @param trimRangeMap A map of link candidates to the amount of buffer range they need trimmed.\n\t */\n\tprivate async _validateAndGetLink(linkText: string | undefined, bufferRange: IBufferRange, linkCandidates: string[], trimRangeMap?: Map<string, number>): Promise<ITerminalSimpleLink | undefined> {\n\t\tconst linkStat = await this._validateLinkCandidates(linkCandidates);\n\t\tif (linkStat) {\n\t\t\tconst type = getTerminalLinkType(linkStat.uri, linkStat.isDirectory, this._uriIdentityService, this._workspaceContextService);\n\n\t\t\t// Offset the buffer range if the link range was trimmed\n\t\t\tconst trimRange = trimRangeMap?.get(linkStat.link);\n\t\t\tif (trimRange) {\n\t\t\t\tbufferRange.end.x -= trimRange;\n\t\t\t\tif (bufferRange.end.x < 0) {\n\t\t\t\t\tbufferRange.end.y--;\n\t\t\t\t\tbufferRange.end.x += this.xterm.cols;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttext: linkText ?? linkStat.link,\n\t\t\t\turi: linkStat.uri,\n\t\t\t\tbufferRange: bufferRange,\n\t\t\t\ttype\n\t\t\t};\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport function getTerminalLinkType(\n\turi: URI,\n\tisDirectory: boolean,\n\turiIdentityService: IUriIdentityService,\n\tworkspaceContextService: IWorkspaceContextService\n): TerminalBuiltinLinkType {\n\tif (isDirectory) {\n\t\t// Check if directory is inside workspace\n\t\tconst folders = workspaceContextService.getWorkspace().folders;\n\t\tfor (let i = 0; i < folders.length; i++) {\n\t\t\tif (uriIdentityService.extUri.isEqualOrParent(uri, folders[i].uri)) {\n\t\t\t\treturn TerminalBuiltinLinkType.LocalFolderInWorkspace;\n\t\t\t}\n\t\t}\n\t\treturn TerminalBuiltinLinkType.LocalFolderOutsideWorkspace;\n\t} else {\n\t\treturn TerminalBuiltinLinkType.LocalFile;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OS } from '../../../../../base/common/platform.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IUriIdentityService } from '../../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IWorkspaceContextService } from '../../../../../platform/workspace/common/workspace.js';\nimport { ITerminalLinkDetector, ITerminalLinkResolver, ITerminalSimpleLink, ResolvedLink, TerminalBuiltinLinkType } from './links.js';\nimport { convertLinkRangeToBuffer, getXtermLineContent, getXtermRangesByAttr, osPathModule, updateLinkWithRelativeCwd } from './terminalLinkHelpers.js';\nimport { ITerminalCapabilityStore, TerminalCapability } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport type { IBufferLine, IBufferRange, Terminal } from '@xterm/xterm';\nimport { ITerminalProcessManager } from '../../../terminal/common/terminal.js';\nimport { detectLinks } from './terminalLinkParsing.js';\nimport { ITerminalBackend, ITerminalLogService } from '../../../../../platform/terminal/common/terminal.js';\n\nconst enum Constants {\n\t/**\n\t * The max line length to try extract word links from.\n\t */\n\tMaxLineLength = 2000,\n\n\t/**\n\t * The maximum number of links in a line to resolve against the file system. This limit is put\n\t * in place to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinksInLine = 10,\n\n\t/**\n\t * The maximum length of a link to resolve against the file system. This limit is put in place\n\t * to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinkLength = 1024,\n}\n\nconst fallbackMatchers: RegExp[] = [\n\t// Python style error: File \"<path>\", line <line>\n\t/^ *File (?<link>\"(?<path>.+)\"(, line (?<line>\\d+))?)/,\n\t// Unknown tool #200166: FILE  <path>:<line>:<col>\n\t/^ +FILE +(?<link>(?<path>.+)(?::(?<line>\\d+)(?::(?<col>\\d+))?)?)/,\n\t// Some C++ compile error formats:\n\t// C:\\foo\\bar baz(339) : error ...\n\t// C:\\foo\\bar baz(339,12) : error ...\n\t// C:\\foo\\bar baz(339, 12) : error ...\n\t// C:\\foo\\bar baz(339): error ...       [#178584, Visual Studio CL/NVIDIA CUDA compiler]\n\t// C:\\foo\\bar baz(339,12): ...\n\t// C:\\foo\\bar baz(339, 12): ...\n\t/^(?<link>(?<path>.+)\\((?<line>\\d+)(?:, ?(?<col>\\d+))?\\)) ?:/,\n\t// C:\\foo/bar baz:339 : error ...\n\t// C:\\foo/bar baz:339:12 : error ...\n\t// C:\\foo/bar baz:339: error ...\n\t// C:\\foo/bar baz:339:12: error ...     [#178584, Clang]\n\t/^(?<link>(?<path>.+):(?<line>\\d+)(?::(?<col>\\d+))?) ?:/,\n\t// PowerShell and cmd prompt\n\t/^(?:PS\\s+)?(?<link>(?<path>[^>]+))>/,\n\t// The whole line is the path\n\t/^ *(?<link>(?<path>.+))/\n];\n\nexport class TerminalLocalLinkDetector implements ITerminalLinkDetector {\n\tstatic id = 'local';\n\n\t// This was chosen as a reasonable maximum line length given the tradeoff between performance\n\t// and how likely it is to encounter such a large line length. Some useful reference points:\n\t// - Window old max length: 260 ($MAX_PATH)\n\t// - Linux max length: 4096 ($PATH_MAX)\n\treadonly maxLinkLength = 500;\n\n\tconstructor(\n\t\treadonly xterm: Terminal,\n\t\tprivate readonly _capabilities: ITerminalCapabilityStore,\n\t\tprivate readonly _processManager: Pick<ITerminalProcessManager, 'initialCwd' | 'os' | 'remoteAuthority' | 'userHome'> & { backend?: Pick<ITerminalBackend, 'getWslPath'> },\n\t\tprivate readonly _linkResolver: ITerminalLinkResolver,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService,\n\t\t@IWorkspaceContextService private readonly _workspaceContextService: IWorkspaceContextService\n\t) {\n\t}\n\n\tasync detect(lines: IBufferLine[], startLine: number, endLine: number): Promise<ITerminalSimpleLink[]> {\n\t\tconst links: ITerminalSimpleLink[] = [];\n\n\t\t// Get the text representation of the wrapped line\n\t\tconst text = getXtermLineContent(this.xterm.buffer.active, startLine, endLine, this.xterm.cols);\n\t\tif (text === '' || text.length > Constants.MaxLineLength) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet stringIndex = -1;\n\t\tlet resolvedLinkCount = 0;\n\n\t\tconst os = this._processManager.os || OS;\n\t\tconst parsedLinks = detectLinks(text, os);\n\t\tthis._logService.trace('terminalLocalLinkDetector#detect text', text);\n\t\tthis._logService.trace('terminalLocalLinkDetector#detect parsedLinks', parsedLinks);\n\t\tfor (const parsedLink of parsedLinks) {\n\n\t\t\t// Don't try resolve any links of excessive length\n\t\t\tif (parsedLink.path.text.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Convert the link text's string index into a wrapped buffer range\n\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\tstartColumn: (parsedLink.prefix?.index ?? parsedLink.path.index) + 1,\n\t\t\t\tstartLineNumber: 1,\n\t\t\t\tendColumn: parsedLink.path.index + parsedLink.path.text.length + (parsedLink.suffix?.suffix.text.length ?? 0) + 1,\n\t\t\t\tendLineNumber: 1\n\t\t\t}, startLine);\n\n\t\t\t// Get a single link candidate if the cwd of the line is known\n\t\t\tconst linkCandidates: string[] = [];\n\t\t\tconst osPath = osPathModule(os);\n\t\t\tconst isUri = parsedLink.path.text.startsWith('file://');\n\t\t\tif (osPath.isAbsolute(parsedLink.path.text) || parsedLink.path.text.startsWith('~') || isUri) {\n\t\t\t\tlinkCandidates.push(parsedLink.path.text);\n\t\t\t} else {\n\t\t\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\t\t\tconst absolutePath = updateLinkWithRelativeCwd(this._capabilities, bufferRange.start.y, parsedLink.path.text, osPath, this._logService);\n\t\t\t\t\t// Only add a single exact link candidate if the cwd is available, this may cause\n\t\t\t\t\t// the link to not be resolved but that should only occur when the actual file does\n\t\t\t\t\t// not exist. Doing otherwise could cause unexpected results where handling via the\n\t\t\t\t\t// word link detector is preferable.\n\t\t\t\t\tif (absolutePath) {\n\t\t\t\t\t\tlinkCandidates.push(...absolutePath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Fallback to resolving against the initial cwd, removing any relative directory prefixes\n\t\t\t\tif (linkCandidates.length === 0) {\n\t\t\t\t\tlinkCandidates.push(parsedLink.path.text);\n\t\t\t\t\tif (parsedLink.path.text.match(/^(\\.\\.[\\/\\\\])+/)) {\n\t\t\t\t\t\tlinkCandidates.push(parsedLink.path.text.replace(/^(\\.\\.[\\/\\\\])+/, ''));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If any candidates end with special characters that are likely to not be part of the\n\t\t\t// link, add a candidate excluding them.\n\t\t\tconst specialEndCharRegex = /[\\[\\]\"'\\.]$/;\n\t\t\tconst trimRangeMap: Map<string, number> = new Map();\n\t\t\tconst specialEndLinkCandidates: string[] = [];\n\t\t\tfor (const candidate of linkCandidates) {\n\t\t\t\tlet previous = candidate;\n\t\t\t\tlet removed = previous.replace(specialEndCharRegex, '');\n\t\t\t\tlet trimRange = 0;\n\t\t\t\twhile (removed !== previous) {\n\t\t\t\t\t// Only trim the link if there is no suffix, otherwise the underline would be incorrect\n\t\t\t\t\tif (!parsedLink.suffix) {\n\t\t\t\t\t\ttrimRange++;\n\t\t\t\t\t}\n\t\t\t\t\tspecialEndLinkCandidates.push(removed);\n\t\t\t\t\ttrimRangeMap.set(removed, trimRange);\n\t\t\t\t\tprevious = removed;\n\t\t\t\t\tremoved = removed.replace(specialEndCharRegex, '');\n\t\t\t\t}\n\t\t\t}\n\t\t\tlinkCandidates.push(...specialEndLinkCandidates);\n\t\t\tthis._logService.trace('terminalLocalLinkDetector#detect linkCandidates', linkCandidates);\n\n\t\t\t// Validate the path and convert to the outgoing type\n\t\t\tconst simpleLink = await this._validateAndGetLink(undefined, bufferRange, linkCandidates, trimRangeMap);\n\t\t\tif (simpleLink) {\n\t\t\t\tsimpleLink.parsedLink = parsedLink;\n\t\t\t\tsimpleLink.text = text.substring(\n\t\t\t\t\tparsedLink.prefix?.index ?? parsedLink.path.index,\n\t\t\t\t\tparsedLink.suffix ? parsedLink.suffix.suffix.index + parsedLink.suffix.suffix.text.length : parsedLink.path.index + parsedLink.path.text.length\n\t\t\t\t);\n\t\t\t\tthis._logService.trace('terminalLocalLinkDetector#detect verified link', simpleLink);\n\t\t\t\tlinks.push(simpleLink);\n\t\t\t}\n\n\t\t\t// Stop early if too many links exist in the line\n\t\t\tif (++resolvedLinkCount >= Constants.MaxResolvedLinksInLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Match against the fallback matchers which are mainly designed to catch paths with spaces\n\t\t// that aren't possible using the regular mechanism.\n\t\tif (links.length === 0) {\n\t\t\tfor (const matcher of fallbackMatchers) {\n\t\t\t\tconst match = text.match(matcher);\n\t\t\t\tconst group = match?.groups;\n\t\t\t\tif (!group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst link = group?.link;\n\t\t\t\tconst path = group?.path;\n\t\t\t\tconst line = group?.line;\n\t\t\t\tconst col = group?.col;\n\t\t\t\tif (!link || !path) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Don't try resolve any links of excessive length\n\t\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Convert the link text's string index into a wrapped buffer range\n\t\t\t\tstringIndex = text.indexOf(link);\n\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\t\tstartColumn: stringIndex + 1,\n\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\tendColumn: stringIndex + link.length + 1,\n\t\t\t\t\tendLineNumber: 1\n\t\t\t\t}, startLine);\n\n\t\t\t\t// Validate and add link\n\t\t\t\tconst suffix = line ? `:${line}${col ? `:${col}` : ''}` : '';\n\t\t\t\tconst simpleLink = await this._validateAndGetLink(`${path}${suffix}`, bufferRange, [path]);\n\t\t\t\tif (simpleLink) {\n\t\t\t\t\tlinks.push(simpleLink);\n\t\t\t\t}\n\n\t\t\t\t// Only match a single fallback matcher\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Sometimes links are styled specially in the terminal like underlined or bolded, try split\n\t\t// the line by attributes and test whether it matches a path\n\t\tif (links.length === 0) {\n\t\t\tconst rangeCandidates = getXtermRangesByAttr(this.xterm.buffer.active, startLine, endLine, this.xterm.cols);\n\t\t\tfor (const rangeCandidate of rangeCandidates) {\n\t\t\t\tlet text = '';\n\t\t\t\tfor (let y = rangeCandidate.start.y; y <= rangeCandidate.end.y; y++) {\n\t\t\t\t\tconst line = this.xterm.buffer.active.getLine(y);\n\t\t\t\t\tif (!line) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst lineStartX = y === rangeCandidate.start.y ? rangeCandidate.start.x : 0;\n\t\t\t\t\tconst lineEndX = y === rangeCandidate.end.y ? rangeCandidate.end.x : this.xterm.cols - 1;\n\t\t\t\t\ttext += line.translateToString(false, lineStartX, lineEndX);\n\t\t\t\t}\n\n\t\t\t\t// HACK: Adjust to 1-based for link API\n\t\t\t\trangeCandidate.start.x++;\n\t\t\t\trangeCandidate.start.y++;\n\t\t\t\trangeCandidate.end.y++;\n\n\t\t\t\t// Validate and add link\n\t\t\t\tconst simpleLink = await this._validateAndGetLink(text, rangeCandidate, [text]);\n\t\t\t\tif (simpleLink) {\n\t\t\t\t\tlinks.push(simpleLink);\n\t\t\t\t}\n\n\t\t\t\t// Stop early if too many links exist in the line\n\t\t\t\tif (++resolvedLinkCount >= Constants.MaxResolvedLinksInLine) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\tprivate async _validateLinkCandidates(linkCandidates: string[]): Promise<ResolvedLink | undefined> {\n\t\tfor (const link of linkCandidates) {\n\t\t\tlet uri: URI | undefined;\n\t\t\tif (link.startsWith('file://')) {\n\t\t\t\turi = URI.parse(link);\n\t\t\t}\n\t\t\tconst result = await this._linkResolver.resolveLink(this._processManager, link, uri);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Validates a set of link candidates and returns a link if validated.\n\t * @param linkText The link text, this should be undefined to use the link stat value\n\t * @param trimRangeMap A map of link candidates to the amount of buffer range they need trimmed.\n\t */\n\tprivate async _validateAndGetLink(linkText: string | undefined, bufferRange: IBufferRange, linkCandidates: string[], trimRangeMap?: Map<string, number>): Promise<ITerminalSimpleLink | undefined> {\n\t\tconst linkStat = await this._validateLinkCandidates(linkCandidates);\n\t\tif (linkStat) {\n\t\t\tconst type = getTerminalLinkType(linkStat.uri, linkStat.isDirectory, this._uriIdentityService, this._workspaceContextService);\n\n\t\t\t// Offset the buffer range if the link range was trimmed\n\t\t\tconst trimRange = trimRangeMap?.get(linkStat.link);\n\t\t\tif (trimRange) {\n\t\t\t\tbufferRange.end.x -= trimRange;\n\t\t\t\tif (bufferRange.end.x < 0) {\n\t\t\t\t\tbufferRange.end.y--;\n\t\t\t\t\tbufferRange.end.x += this.xterm.cols;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttext: linkText ?? linkStat.link,\n\t\t\t\turi: linkStat.uri,\n\t\t\t\tbufferRange: bufferRange,\n\t\t\t\ttype\n\t\t\t};\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport function getTerminalLinkType(\n\turi: URI,\n\tisDirectory: boolean,\n\turiIdentityService: IUriIdentityService,\n\tworkspaceContextService: IWorkspaceContextService\n): TerminalBuiltinLinkType {\n\tif (isDirectory) {\n\t\t// Check if directory is inside workspace\n\t\tconst folders = workspaceContextService.getWorkspace().folders;\n\t\tfor (let i = 0; i < folders.length; i++) {\n\t\t\tif (uriIdentityService.extUri.isEqualOrParent(uri, folders[i].uri)) {\n\t\t\t\treturn TerminalBuiltinLinkType.LocalFolderInWorkspace;\n\t\t\t}\n\t\t}\n\t\treturn TerminalBuiltinLinkType.LocalFolderOutsideWorkspace;\n\t} else {\n\t\treturn TerminalBuiltinLinkType.LocalFile;\n\t}\n}\n"]}