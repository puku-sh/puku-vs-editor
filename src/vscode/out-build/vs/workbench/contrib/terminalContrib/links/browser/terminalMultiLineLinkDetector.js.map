{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/links/browser/terminalMultiLineLinkDetector.ts","vs/workbench/contrib/terminalContrib/links/browser/terminalMultiLineLinkDetector.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;AAEhG,OAAO,EAAE,mBAAmB,EAAE,MAAM,2DAA2D,CAAC;AAChG,OAAO,EAAE,wBAAwB,EAAE,MAAM,uDAAuD,CAAC;AAEjG,OAAO,EAAE,wBAAwB,EAAE,mBAAmB,EAAE,MAAM,0BAA0B,CAAC;AACzF,OAAO,EAAE,mBAAmB,EAAE,MAAM,gCAAgC,CAAC;AAGrE,OAAO,EAAoB,mBAAmB,EAAE,MAAM,qDAAqD,CAAC;AAE5G,IAAW,SAWV;AAXD,WAAW,SAAS;IACnB;;OAEG;IACH,8DAAoB,CAAA;IAEpB;;;OAGG;IACH,8EAA4B,CAAA;AAC7B,CAAC,EAXU,SAAS,KAAT,SAAS,QAWnB;AAED,MAAM,wBAAwB,GAAG;IAChC,WAAW;IACX,eAAe;IACf,oBAAoB;IACpB,wBAAwB;IACxB,UAAU;IACV,eAAe;IACf,sBAAsB;IACtB,uCAAuC;CACvC,CAAC;AAEF,MAAM,eAAe,GAAG;IACvB,kBAAkB;IAClB,kBAAkB;IAClB,oCAAoC;IACpC,6DAA6D;CAC7D,CAAC;AAEK,IAAM,6BAA6B,GAAnC,MAAM,6BAA6B;aAClC,OAAE,GAAG,WAAH,AAAc,CAAC;IAQxB,YACU,KAAe,EACP,eAAyJ,EACzJ,aAAoC,EAChC,WAAiD,EACjD,mBAAyD,EACpD,wBAAmE;QALpF,UAAK,GAAL,KAAK,CAAU;QACP,oBAAe,GAAf,eAAe,CAA0I;QACzJ,kBAAa,GAAb,aAAa,CAAuB;QACf,gBAAW,GAAX,WAAW,CAAqB;QAChC,wBAAmB,GAAnB,mBAAmB,CAAqB;QACnC,6BAAwB,GAAxB,wBAAwB,CAA0B;QAZ9F,6FAA6F;QAC7F,4FAA4F;QAC5F,2CAA2C;QAC3C,uCAAuC;QAC9B,kBAAa,GAAG,GAAG,CAAC;IAU7B,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,KAAoB,EAAE,SAAiB,EAAE,OAAe;QACpE,MAAM,KAAK,GAA0B,EAAE,CAAC;QAExC,kDAAkD;QAClD,MAAM,IAAI,GAAG,mBAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAChG,IAAI,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC,MAAM,qCAA0B,EAAE,CAAC;YAC1D,OAAO,EAAE,CAAC;QACX,CAAC;QAED,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,2CAA2C,EAAE,IAAI,CAAC,CAAC;QAE1E,2FAA2F;QAC3F,oDAAoD;QACpD,KAAK,MAAM,OAAO,IAAI,wBAAwB,EAAE,CAAC;YAChD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;YAClC,MAAM,KAAK,GAAG,KAAK,EAAE,MAAM,CAAC;YAC5B,IAAI,CAAC,KAAK,EAAE,CAAC;gBACZ,SAAS;YACV,CAAC;YACD,MAAM,IAAI,GAAG,KAAK,EAAE,IAAI,CAAC;YACzB,MAAM,IAAI,GAAG,KAAK,EAAE,IAAI,CAAC;YACzB,MAAM,GAAG,GAAG,KAAK,EAAE,GAAG,CAAC;YACvB,IAAI,CAAC,IAAI,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;gBACjC,SAAS;YACV,CAAC;YAED,kDAAkD;YAClD,IAAI,IAAI,CAAC,MAAM,6CAAkC,EAAE,CAAC;gBACnD,SAAS;YACV,CAAC;YAED,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,gDAAgD,EAAE,IAAI,CAAC,CAAC;YAE/E,0DAA0D;YAC1D,IAAI,YAAgC,CAAC;YACrC,KAAK,IAAI,KAAK,GAAG,SAAS,GAAG,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,KAAK,EAAE,EAAE,CAAC;gBACrD,8DAA8D;gBAC9D,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAE,CAAC,SAAS,EAAE,CAAC;oBACxD,SAAS;gBACV,CAAC;gBACD,MAAM,IAAI,GAAG,mBAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBAC1F,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC;oBAC3B,YAAY,GAAG,IAAI,CAAC;oBACpB,MAAM;gBACP,CAAC;YACF,CAAC;YACD,IAAI,CAAC,YAAY,EAAE,CAAC;gBACnB,SAAS;YACV,CAAC;YAED,uEAAuE;YACvE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,IAAI,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC;YAC1F,IAAI,QAAQ,EAAE,CAAC;gBACd,MAAM,IAAI,GAAG,mBAAmB,CAAC,QAAQ,CAAC,GAAG,EAAE,QAAQ,CAAC,WAAW,EAAE,IAAI,CAAC,mBAAmB,EAAE,IAAI,CAAC,wBAAwB,CAAC,CAAC;gBAE9H,0EAA0E;gBAC1E,MAAM,WAAW,GAAG,wBAAwB,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;oBACpE,WAAW,EAAE,CAAC;oBACd,eAAe,EAAE,CAAC;oBAClB,SAAS,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM;oBAC1B,aAAa,EAAE,CAAC;iBAChB,EAAE,SAAS,CAAC,CAAC;gBAEd,MAAM,UAAU,GAAwB;oBACvC,IAAI,EAAE,IAAI;oBACV,GAAG,EAAE,QAAQ,CAAC,GAAG;oBACjB,SAAS,EAAE;wBACV,eAAe,EAAE,QAAQ,CAAC,IAAI,CAAC;wBAC/B,WAAW,EAAE,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;qBACpC;oBACD,gBAAgB,EAAE,IAAI;oBACtB,WAAW,EAAE,WAAW;oBACxB,IAAI;iBACJ,CAAC;gBACF,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,oDAAoD,EAAE,UAAU,CAAC,CAAC;gBACzF,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBAEvB,2BAA2B;gBAC3B,MAAM;YACP,CAAC;QACF,CAAC;QAED,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxB,KAAK,MAAM,OAAO,IAAI,eAAe,EAAE,CAAC;gBACvC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;gBAClC,MAAM,KAAK,GAAG,KAAK,EAAE,MAAM,CAAC;gBAC5B,IAAI,CAAC,KAAK,EAAE,CAAC;oBACZ,SAAS;gBACV,CAAC;gBACD,MAAM,IAAI,GAAG,KAAK,EAAE,IAAI,CAAC;gBACzB,MAAM,UAAU,GAAG,KAAK,EAAE,UAAU,CAAC;gBACrC,MAAM,WAAW,GAAG,KAAK,EAAE,WAAW,CAAC;gBACvC,IAAI,CAAC,IAAI,IAAI,UAAU,KAAK,SAAS,EAAE,CAAC;oBACvC,SAAS;gBACV,CAAC;gBAED,kDAAkD;gBAClD,IAAI,IAAI,CAAC,MAAM,6CAAkC,EAAE,CAAC;oBACnD,SAAS;gBACV,CAAC;gBAED,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,gDAAgD,EAAE,IAAI,CAAC,CAAC;gBAG/E,0DAA0D;gBAC1D,IAAI,YAAgC,CAAC;gBACrC,KAAK,IAAI,KAAK,GAAG,SAAS,GAAG,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,KAAK,EAAE,EAAE,CAAC;oBACrD,8DAA8D;oBAC9D,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAE,CAAC,SAAS,EAAE,CAAC;wBACxD,SAAS;oBACV,CAAC;oBACD,MAAM,IAAI,GAAG,mBAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBAC1F,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAC;oBAClD,IAAI,KAAK,EAAE,CAAC;wBACX,YAAY,GAAG,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC;wBAClC,MAAM;oBACP,CAAC;gBACF,CAAC;gBACD,IAAI,CAAC,YAAY,EAAE,CAAC;oBACnB,SAAS;gBACV,CAAC;gBAED,uEAAuE;gBACvE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,IAAI,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC;gBAC1F,IAAI,QAAQ,EAAE,CAAC;oBACd,MAAM,IAAI,GAAG,mBAAmB,CAAC,QAAQ,CAAC,GAAG,EAAE,QAAQ,CAAC,WAAW,EAAE,IAAI,CAAC,mBAAmB,EAAE,IAAI,CAAC,wBAAwB,CAAC,CAAC;oBAE9H,uCAAuC;oBACvC,MAAM,WAAW,GAAG,wBAAwB,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;wBACpE,WAAW,EAAE,CAAC;wBACd,eAAe,EAAE,CAAC;wBAClB,SAAS,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM;wBAC1B,aAAa,EAAE,CAAC;qBAChB,EAAE,SAAS,CAAC,CAAC;oBAEd,MAAM,UAAU,GAAwB;wBACvC,IAAI,EAAE,IAAI;wBACV,GAAG,EAAE,QAAQ,CAAC,GAAG;wBACjB,SAAS,EAAE;4BACV,eAAe,EAAE,QAAQ,CAAC,UAAU,CAAC;4BACrC,WAAW,EAAE,CAAC;4BACd,aAAa,EAAE,QAAQ,CAAC,UAAU,CAAC,GAAG,QAAQ,CAAC,WAAW,CAAC;yBAC3D;wBACD,WAAW,EAAE,WAAW;wBACxB,IAAI;qBACJ,CAAC;oBACF,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,oDAAoD,EAAE,UAAU,CAAC,CAAC;oBACzF,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;oBAEvB,2BAA2B;oBAC3B,MAAM;gBACP,CAAC;YACF,CAAC;QACF,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC;;AA/KW,6BAA6B;IAavC,WAAA,mBAAmB,CAAA;IACnB,WAAA,mBAAmB,CAAA;IACnB,WAAA,wBAAwB,CAAA;GAfd,6BAA6B,CAgLzC","file":"terminalMultiLineLinkDetector.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IUriIdentityService } from '../../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IWorkspaceContextService } from '../../../../../platform/workspace/common/workspace.js';\nimport { ITerminalLinkDetector, ITerminalLinkResolver, ITerminalSimpleLink } from './links.js';\nimport { convertLinkRangeToBuffer, getXtermLineContent } from './terminalLinkHelpers.js';\nimport { getTerminalLinkType } from './terminalLocalLinkDetector.js';\nimport type { IBufferLine, Terminal } from '@xterm/xterm';\nimport { ITerminalProcessManager } from '../../../terminal/common/terminal.js';\nimport { ITerminalBackend, ITerminalLogService } from '../../../../../platform/terminal/common/terminal.js';\n\nconst enum Constants {\n\t/**\n\t * The max line length to try extract word links from.\n\t */\n\tMaxLineLength = 2000,\n\n\t/**\n\t * The maximum length of a link to resolve against the file system. This limit is put in place\n\t * to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinkLength = 1024,\n}\n\nconst lineNumberPrefixMatchers = [\n\t// Ripgrep:\n\t//   /some/file\n\t//   16:searchresult\n\t//   16:    searchresult\n\t// Eslint:\n\t//   /some/file\n\t//     16:5  error ...\n\t/^ *(?<link>(?<line>\\d+):(?<col>\\d+)?)/\n];\n\nconst gitDiffMatchers = [\n\t// --- a/some/file\n\t// +++ b/some/file\n\t// @@ -8,11 +8,11 @@ file content...\n\t/^(?<link>@@ .+ \\+(?<toFileLine>\\d+),(?<toFileCount>\\d+) @@)/\n];\n\nexport class TerminalMultiLineLinkDetector implements ITerminalLinkDetector {\n\tstatic id = 'multiline';\n\n\t// This was chosen as a reasonable maximum line length given the tradeoff between performance\n\t// and how likely it is to encounter such a large line length. Some useful reference points:\n\t// - Window old max length: 260 ($MAX_PATH)\n\t// - Linux max length: 4096 ($PATH_MAX)\n\treadonly maxLinkLength = 500;\n\n\tconstructor(\n\t\treadonly xterm: Terminal,\n\t\tprivate readonly _processManager: Pick<ITerminalProcessManager, 'initialCwd' | 'os' | 'remoteAuthority' | 'userHome'> & { backend?: Pick<ITerminalBackend, 'getWslPath'> },\n\t\tprivate readonly _linkResolver: ITerminalLinkResolver,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService,\n\t\t@IWorkspaceContextService private readonly _workspaceContextService: IWorkspaceContextService\n\t) {\n\t}\n\n\tasync detect(lines: IBufferLine[], startLine: number, endLine: number): Promise<ITerminalSimpleLink[]> {\n\t\tconst links: ITerminalSimpleLink[] = [];\n\n\t\t// Get the text representation of the wrapped line\n\t\tconst text = getXtermLineContent(this.xterm.buffer.active, startLine, endLine, this.xterm.cols);\n\t\tif (text === '' || text.length > Constants.MaxLineLength) {\n\t\t\treturn [];\n\t\t}\n\n\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect text', text);\n\n\t\t// Match against the fallback matchers which are mainly designed to catch paths with spaces\n\t\t// that aren't possible using the regular mechanism.\n\t\tfor (const matcher of lineNumberPrefixMatchers) {\n\t\t\tconst match = text.match(matcher);\n\t\t\tconst group = match?.groups;\n\t\t\tif (!group) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst link = group?.link;\n\t\t\tconst line = group?.line;\n\t\t\tconst col = group?.col;\n\t\t\tif (!link || line === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Don't try resolve any links of excessive length\n\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect candidate', link);\n\n\t\t\t// Scan up looking for the first line that could be a path\n\t\t\tlet possiblePath: string | undefined;\n\t\t\tfor (let index = startLine - 1; index >= 0; index--) {\n\t\t\t\t// Ignore lines that aren't at the beginning of a wrapped line\n\t\t\t\tif (this.xterm.buffer.active.getLine(index)!.isWrapped) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst text = getXtermLineContent(this.xterm.buffer.active, index, index, this.xterm.cols);\n\t\t\t\tif (!text.match(/^\\s*\\d/)) {\n\t\t\t\t\tpossiblePath = text;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possiblePath) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if the first non-matching line is an absolute or relative link\n\t\t\tconst linkStat = await this._linkResolver.resolveLink(this._processManager, possiblePath);\n\t\t\tif (linkStat) {\n\t\t\t\tconst type = getTerminalLinkType(linkStat.uri, linkStat.isDirectory, this._uriIdentityService, this._workspaceContextService);\n\n\t\t\t\t// Convert the entire line's text string index into a wrapped buffer range\n\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\tendColumn: 1 + text.length,\n\t\t\t\t\tendLineNumber: 1\n\t\t\t\t}, startLine);\n\n\t\t\t\tconst simpleLink: ITerminalSimpleLink = {\n\t\t\t\t\ttext: link,\n\t\t\t\t\turi: linkStat.uri,\n\t\t\t\t\tselection: {\n\t\t\t\t\t\tstartLineNumber: parseInt(line),\n\t\t\t\t\t\tstartColumn: col ? parseInt(col) : 1\n\t\t\t\t\t},\n\t\t\t\t\tdisableTrimColon: true,\n\t\t\t\t\tbufferRange: bufferRange,\n\t\t\t\t\ttype\n\t\t\t\t};\n\t\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect verified link', simpleLink);\n\t\t\t\tlinks.push(simpleLink);\n\n\t\t\t\t// Break on the first match\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (links.length === 0) {\n\t\t\tfor (const matcher of gitDiffMatchers) {\n\t\t\t\tconst match = text.match(matcher);\n\t\t\t\tconst group = match?.groups;\n\t\t\t\tif (!group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst link = group?.link;\n\t\t\t\tconst toFileLine = group?.toFileLine;\n\t\t\t\tconst toFileCount = group?.toFileCount;\n\t\t\t\tif (!link || toFileLine === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Don't try resolve any links of excessive length\n\t\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect candidate', link);\n\n\n\t\t\t\t// Scan up looking for the first line that could be a path\n\t\t\t\tlet possiblePath: string | undefined;\n\t\t\t\tfor (let index = startLine - 1; index >= 0; index--) {\n\t\t\t\t\t// Ignore lines that aren't at the beginning of a wrapped line\n\t\t\t\t\tif (this.xterm.buffer.active.getLine(index)!.isWrapped) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst text = getXtermLineContent(this.xterm.buffer.active, index, index, this.xterm.cols);\n\t\t\t\t\tconst match = text.match(/\\+\\+\\+ b\\/(?<path>.+)/);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tpossiblePath = match.groups?.path;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!possiblePath) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Check if the first non-matching line is an absolute or relative link\n\t\t\t\tconst linkStat = await this._linkResolver.resolveLink(this._processManager, possiblePath);\n\t\t\t\tif (linkStat) {\n\t\t\t\t\tconst type = getTerminalLinkType(linkStat.uri, linkStat.isDirectory, this._uriIdentityService, this._workspaceContextService);\n\n\t\t\t\t\t// Convert the link to the buffer range\n\t\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\t\tendColumn: 1 + link.length,\n\t\t\t\t\t\tendLineNumber: 1\n\t\t\t\t\t}, startLine);\n\n\t\t\t\t\tconst simpleLink: ITerminalSimpleLink = {\n\t\t\t\t\t\ttext: link,\n\t\t\t\t\t\turi: linkStat.uri,\n\t\t\t\t\t\tselection: {\n\t\t\t\t\t\t\tstartLineNumber: parseInt(toFileLine),\n\t\t\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\t\t\tendLineNumber: parseInt(toFileLine) + parseInt(toFileCount)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbufferRange: bufferRange,\n\t\t\t\t\t\ttype\n\t\t\t\t\t};\n\t\t\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect verified link', simpleLink);\n\t\t\t\t\tlinks.push(simpleLink);\n\n\t\t\t\t\t// Break on the first match\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IUriIdentityService } from '../../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IWorkspaceContextService } from '../../../../../platform/workspace/common/workspace.js';\nimport { ITerminalLinkDetector, ITerminalLinkResolver, ITerminalSimpleLink } from './links.js';\nimport { convertLinkRangeToBuffer, getXtermLineContent } from './terminalLinkHelpers.js';\nimport { getTerminalLinkType } from './terminalLocalLinkDetector.js';\nimport type { IBufferLine, Terminal } from '@xterm/xterm';\nimport { ITerminalProcessManager } from '../../../terminal/common/terminal.js';\nimport { ITerminalBackend, ITerminalLogService } from '../../../../../platform/terminal/common/terminal.js';\n\nconst enum Constants {\n\t/**\n\t * The max line length to try extract word links from.\n\t */\n\tMaxLineLength = 2000,\n\n\t/**\n\t * The maximum length of a link to resolve against the file system. This limit is put in place\n\t * to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinkLength = 1024,\n}\n\nconst lineNumberPrefixMatchers = [\n\t// Ripgrep:\n\t//   /some/file\n\t//   16:searchresult\n\t//   16:    searchresult\n\t// Eslint:\n\t//   /some/file\n\t//     16:5  error ...\n\t/^ *(?<link>(?<line>\\d+):(?<col>\\d+)?)/\n];\n\nconst gitDiffMatchers = [\n\t// --- a/some/file\n\t// +++ b/some/file\n\t// @@ -8,11 +8,11 @@ file content...\n\t/^(?<link>@@ .+ \\+(?<toFileLine>\\d+),(?<toFileCount>\\d+) @@)/\n];\n\nexport class TerminalMultiLineLinkDetector implements ITerminalLinkDetector {\n\tstatic id = 'multiline';\n\n\t// This was chosen as a reasonable maximum line length given the tradeoff between performance\n\t// and how likely it is to encounter such a large line length. Some useful reference points:\n\t// - Window old max length: 260 ($MAX_PATH)\n\t// - Linux max length: 4096 ($PATH_MAX)\n\treadonly maxLinkLength = 500;\n\n\tconstructor(\n\t\treadonly xterm: Terminal,\n\t\tprivate readonly _processManager: Pick<ITerminalProcessManager, 'initialCwd' | 'os' | 'remoteAuthority' | 'userHome'> & { backend?: Pick<ITerminalBackend, 'getWslPath'> },\n\t\tprivate readonly _linkResolver: ITerminalLinkResolver,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService,\n\t\t@IWorkspaceContextService private readonly _workspaceContextService: IWorkspaceContextService\n\t) {\n\t}\n\n\tasync detect(lines: IBufferLine[], startLine: number, endLine: number): Promise<ITerminalSimpleLink[]> {\n\t\tconst links: ITerminalSimpleLink[] = [];\n\n\t\t// Get the text representation of the wrapped line\n\t\tconst text = getXtermLineContent(this.xterm.buffer.active, startLine, endLine, this.xterm.cols);\n\t\tif (text === '' || text.length > Constants.MaxLineLength) {\n\t\t\treturn [];\n\t\t}\n\n\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect text', text);\n\n\t\t// Match against the fallback matchers which are mainly designed to catch paths with spaces\n\t\t// that aren't possible using the regular mechanism.\n\t\tfor (const matcher of lineNumberPrefixMatchers) {\n\t\t\tconst match = text.match(matcher);\n\t\t\tconst group = match?.groups;\n\t\t\tif (!group) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst link = group?.link;\n\t\t\tconst line = group?.line;\n\t\t\tconst col = group?.col;\n\t\t\tif (!link || line === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Don't try resolve any links of excessive length\n\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect candidate', link);\n\n\t\t\t// Scan up looking for the first line that could be a path\n\t\t\tlet possiblePath: string | undefined;\n\t\t\tfor (let index = startLine - 1; index >= 0; index--) {\n\t\t\t\t// Ignore lines that aren't at the beginning of a wrapped line\n\t\t\t\tif (this.xterm.buffer.active.getLine(index)!.isWrapped) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst text = getXtermLineContent(this.xterm.buffer.active, index, index, this.xterm.cols);\n\t\t\t\tif (!text.match(/^\\s*\\d/)) {\n\t\t\t\t\tpossiblePath = text;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possiblePath) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if the first non-matching line is an absolute or relative link\n\t\t\tconst linkStat = await this._linkResolver.resolveLink(this._processManager, possiblePath);\n\t\t\tif (linkStat) {\n\t\t\t\tconst type = getTerminalLinkType(linkStat.uri, linkStat.isDirectory, this._uriIdentityService, this._workspaceContextService);\n\n\t\t\t\t// Convert the entire line's text string index into a wrapped buffer range\n\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\tendColumn: 1 + text.length,\n\t\t\t\t\tendLineNumber: 1\n\t\t\t\t}, startLine);\n\n\t\t\t\tconst simpleLink: ITerminalSimpleLink = {\n\t\t\t\t\ttext: link,\n\t\t\t\t\turi: linkStat.uri,\n\t\t\t\t\tselection: {\n\t\t\t\t\t\tstartLineNumber: parseInt(line),\n\t\t\t\t\t\tstartColumn: col ? parseInt(col) : 1\n\t\t\t\t\t},\n\t\t\t\t\tdisableTrimColon: true,\n\t\t\t\t\tbufferRange: bufferRange,\n\t\t\t\t\ttype\n\t\t\t\t};\n\t\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect verified link', simpleLink);\n\t\t\t\tlinks.push(simpleLink);\n\n\t\t\t\t// Break on the first match\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (links.length === 0) {\n\t\t\tfor (const matcher of gitDiffMatchers) {\n\t\t\t\tconst match = text.match(matcher);\n\t\t\t\tconst group = match?.groups;\n\t\t\t\tif (!group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst link = group?.link;\n\t\t\t\tconst toFileLine = group?.toFileLine;\n\t\t\t\tconst toFileCount = group?.toFileCount;\n\t\t\t\tif (!link || toFileLine === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Don't try resolve any links of excessive length\n\t\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect candidate', link);\n\n\n\t\t\t\t// Scan up looking for the first line that could be a path\n\t\t\t\tlet possiblePath: string | undefined;\n\t\t\t\tfor (let index = startLine - 1; index >= 0; index--) {\n\t\t\t\t\t// Ignore lines that aren't at the beginning of a wrapped line\n\t\t\t\t\tif (this.xterm.buffer.active.getLine(index)!.isWrapped) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst text = getXtermLineContent(this.xterm.buffer.active, index, index, this.xterm.cols);\n\t\t\t\t\tconst match = text.match(/\\+\\+\\+ b\\/(?<path>.+)/);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tpossiblePath = match.groups?.path;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!possiblePath) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Check if the first non-matching line is an absolute or relative link\n\t\t\t\tconst linkStat = await this._linkResolver.resolveLink(this._processManager, possiblePath);\n\t\t\t\tif (linkStat) {\n\t\t\t\t\tconst type = getTerminalLinkType(linkStat.uri, linkStat.isDirectory, this._uriIdentityService, this._workspaceContextService);\n\n\t\t\t\t\t// Convert the link to the buffer range\n\t\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\t\tendColumn: 1 + link.length,\n\t\t\t\t\t\tendLineNumber: 1\n\t\t\t\t\t}, startLine);\n\n\t\t\t\t\tconst simpleLink: ITerminalSimpleLink = {\n\t\t\t\t\t\ttext: link,\n\t\t\t\t\t\turi: linkStat.uri,\n\t\t\t\t\t\tselection: {\n\t\t\t\t\t\t\tstartLineNumber: parseInt(toFileLine),\n\t\t\t\t\t\t\tstartColumn: 1,\n\t\t\t\t\t\t\tendLineNumber: parseInt(toFileLine) + parseInt(toFileCount)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbufferRange: bufferRange,\n\t\t\t\t\t\ttype\n\t\t\t\t\t};\n\t\t\t\t\tthis._logService.trace('terminalMultiLineLinkDetector#detect verified link', simpleLink);\n\t\t\t\t\tlinks.push(simpleLink);\n\n\t\t\t\t\t// Break on the first match\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n}\n"]}