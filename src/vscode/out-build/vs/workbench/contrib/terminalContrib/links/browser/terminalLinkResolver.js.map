{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/links/browser/terminalLinkResolver.ts","vs/workbench/contrib/terminalContrib/links/browser/terminalLinkResolver.ts"],"names":[],"mappings":"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","file":"terminalLinkResolver.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITerminalLinkResolver, ResolvedLink } from './links.js';\nimport { removeLinkSuffix, removeLinkQueryString, winDrivePrefix } from './terminalLinkParsing.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { ITerminalProcessManager } from '../../../terminal/common/terminal.js';\nimport { Schemas } from '../../../../../base/common/network.js';\nimport { isWindows, OperatingSystem, OS } from '../../../../../base/common/platform.js';\nimport { IFileService } from '../../../../../platform/files/common/files.js';\nimport { IPath, posix, win32 } from '../../../../../base/common/path.js';\nimport { ITerminalBackend } from '../../../../../platform/terminal/common/terminal.js';\nimport { mainWindow } from '../../../../../base/browser/window.js';\n\nexport class TerminalLinkResolver implements ITerminalLinkResolver {\n\t// Link cache could be shared across all terminals, but that could lead to weird results when\n\t// both local and remote terminals are present\n\tprivate readonly _resolvedLinkCaches: Map<string, LinkCache> = new Map();\n\n\tconstructor(\n\t\t@IFileService private readonly _fileService: IFileService,\n\t) {\n\t}\n\n\tasync resolveLink(processManager: Pick<ITerminalProcessManager, 'initialCwd' | 'os' | 'remoteAuthority' | 'userHome'> & { backend?: Pick<ITerminalBackend, 'getWslPath'> }, link: string, uri?: URI): Promise<ResolvedLink> {\n\t\t// Correct scheme and authority for remote terminals\n\t\tif (uri && uri.scheme === Schemas.file && processManager.remoteAuthority) {\n\t\t\turi = uri.with({\n\t\t\t\tscheme: Schemas.vscodeRemote,\n\t\t\t\tauthority: processManager.remoteAuthority\n\t\t\t});\n\t\t}\n\n\t\t// Get the link cache\n\t\tlet cache = this._resolvedLinkCaches.get(processManager.remoteAuthority ?? '');\n\t\tif (!cache) {\n\t\t\tcache = new LinkCache();\n\t\t\tthis._resolvedLinkCaches.set(processManager.remoteAuthority ?? '', cache);\n\t\t}\n\n\t\t// Check resolved link cache first\n\t\tconst cached = cache.get(uri || link);\n\t\tif (cached !== undefined) {\n\t\t\treturn cached;\n\t\t}\n\n\t\tif (uri) {\n\t\t\ttry {\n\t\t\t\tconst stat = await this._fileService.stat(uri);\n\t\t\t\tconst result = { uri, link, isDirectory: stat.isDirectory };\n\t\t\t\tcache.set(uri, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\t// Does not exist\n\t\t\t\tcache.set(uri, null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// Remove any line/col suffix\n\t\tlet linkUrl = removeLinkSuffix(link);\n\n\t\t// Remove any query string\n\t\tlinkUrl = removeLinkQueryString(linkUrl);\n\n\t\t// Exit early if the link is determines as not valid already\n\t\tif (linkUrl.length === 0) {\n\t\t\tcache.set(link, null);\n\t\t\treturn null;\n\t\t}\n\n\t\t// If the link looks like a /mnt/ WSL path and this is a Windows frontend, use the backend\n\t\t// to get the resolved path from the wslpath util.\n\t\tif (isWindows && link.match(/^\\/mnt\\/[a-z]/i) && processManager.backend) {\n\t\t\tlinkUrl = await processManager.backend.getWslPath(linkUrl, 'unix-to-win');\n\t\t}\n\t\t// Skip preprocessing if it looks like a special Windows -> WSL link\n\t\telse if (isWindows && link.match(/^(?:\\/\\/|\\\\\\\\)wsl(?:\\$|\\.localhost)(\\/|\\\\)/)) {\n\t\t\t// No-op, it's already the right format\n\t\t}\n\t\t// Handle all non-WSL links\n\t\telse {\n\t\t\tconst preprocessedLink = this._preprocessPath(linkUrl, processManager.initialCwd, processManager.os, processManager.userHome);\n\t\t\tif (!preprocessedLink) {\n\t\t\t\tcache.set(link, null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlinkUrl = preprocessedLink;\n\t\t}\n\n\t\ttry {\n\t\t\tlet uri: URI;\n\t\t\tif (processManager.remoteAuthority) {\n\t\t\t\turi = URI.from({\n\t\t\t\t\tscheme: Schemas.vscodeRemote,\n\t\t\t\t\tauthority: processManager.remoteAuthority,\n\t\t\t\t\tpath: linkUrl\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\turi = URI.file(linkUrl);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst stat = await this._fileService.stat(uri);\n\t\t\t\tconst result = { uri, link, isDirectory: stat.isDirectory };\n\t\t\t\tcache.set(link, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\t// Does not exist\n\t\t\t\tcache.set(link, null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch {\n\t\t\t// Errors in parsing the path\n\t\t\tcache.set(link, null);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprotected _preprocessPath(link: string, initialCwd: string, os: OperatingSystem | undefined, userHome: string | undefined): string | null {\n\t\tconst osPath = this._getOsPath(os);\n\t\tif (link.charAt(0) === '~') {\n\t\t\t// Resolve ~ -> userHome\n\t\t\tif (!userHome) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlink = osPath.join(userHome, link.substring(1));\n\t\t} else if (link.charAt(0) !== '/' && link.charAt(0) !== '~') {\n\t\t\t// Resolve workspace path . | .. | <relative_path> -> <path>/. | <path>/.. | <path>/<relative_path>\n\t\t\tif (os === OperatingSystem.Windows) {\n\t\t\t\tif (!link.match('^' + winDrivePrefix) && !link.startsWith('\\\\\\\\?\\\\')) {\n\t\t\t\t\tif (!initialCwd) {\n\t\t\t\t\t\t// Abort if no workspace is open\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tlink = osPath.join(initialCwd, link);\n\t\t\t\t} else {\n\t\t\t\t\t// Remove \\\\?\\ from paths so that they share the same underlying\n\t\t\t\t\t// uri and don't open multiple tabs for the same file\n\t\t\t\t\tlink = link.replace(/^\\\\\\\\\\?\\\\/, '');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!initialCwd) {\n\t\t\t\t\t// Abort if no workspace is open\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tlink = osPath.join(initialCwd, link);\n\t\t\t}\n\t\t}\n\t\tlink = osPath.normalize(link);\n\n\t\treturn link;\n\t}\n\n\tprivate _getOsPath(os: OperatingSystem | undefined): IPath {\n\t\treturn (os ?? OS) === OperatingSystem.Windows ? win32 : posix;\n\t}\n}\n\nconst enum LinkCacheConstants {\n\t/**\n\t * How long to cache links for in milliseconds, the TTL resets whenever a new value is set in\n\t * the cache.\n\t */\n\tTTL = 10000\n}\n\nclass LinkCache {\n\tprivate readonly _cache = new Map<string, ResolvedLink>();\n\tprivate _cacheTilTimeout = 0;\n\n\tset(link: string | URI, value: ResolvedLink) {\n\t\t// Reset cached link TTL on any set\n\t\tif (this._cacheTilTimeout) {\n\t\t\tmainWindow.clearTimeout(this._cacheTilTimeout);\n\t\t}\n\t\tthis._cacheTilTimeout = mainWindow.setTimeout(() => this._cache.clear(), LinkCacheConstants.TTL);\n\t\tthis._cache.set(this._getKey(link), value);\n\t}\n\n\tget(link: string | URI): ResolvedLink | undefined {\n\t\treturn this._cache.get(this._getKey(link));\n\t}\n\n\tprivate _getKey(link: string | URI): string {\n\t\tif (URI.isUri(link)) {\n\t\t\treturn link.toString();\n\t\t}\n\t\treturn link;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITerminalLinkResolver, ResolvedLink } from './links.js';\nimport { removeLinkSuffix, removeLinkQueryString, winDrivePrefix } from './terminalLinkParsing.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { ITerminalProcessManager } from '../../../terminal/common/terminal.js';\nimport { Schemas } from '../../../../../base/common/network.js';\nimport { isWindows, OperatingSystem, OS } from '../../../../../base/common/platform.js';\nimport { IFileService } from '../../../../../platform/files/common/files.js';\nimport { IPath, posix, win32 } from '../../../../../base/common/path.js';\nimport { ITerminalBackend } from '../../../../../platform/terminal/common/terminal.js';\nimport { mainWindow } from '../../../../../base/browser/window.js';\n\nexport class TerminalLinkResolver implements ITerminalLinkResolver {\n\t// Link cache could be shared across all terminals, but that could lead to weird results when\n\t// both local and remote terminals are present\n\tprivate readonly _resolvedLinkCaches: Map<string, LinkCache> = new Map();\n\n\tconstructor(\n\t\t@IFileService private readonly _fileService: IFileService,\n\t) {\n\t}\n\n\tasync resolveLink(processManager: Pick<ITerminalProcessManager, 'initialCwd' | 'os' | 'remoteAuthority' | 'userHome'> & { backend?: Pick<ITerminalBackend, 'getWslPath'> }, link: string, uri?: URI): Promise<ResolvedLink> {\n\t\t// Correct scheme and authority for remote terminals\n\t\tif (uri && uri.scheme === Schemas.file && processManager.remoteAuthority) {\n\t\t\turi = uri.with({\n\t\t\t\tscheme: Schemas.vscodeRemote,\n\t\t\t\tauthority: processManager.remoteAuthority\n\t\t\t});\n\t\t}\n\n\t\t// Get the link cache\n\t\tlet cache = this._resolvedLinkCaches.get(processManager.remoteAuthority ?? '');\n\t\tif (!cache) {\n\t\t\tcache = new LinkCache();\n\t\t\tthis._resolvedLinkCaches.set(processManager.remoteAuthority ?? '', cache);\n\t\t}\n\n\t\t// Check resolved link cache first\n\t\tconst cached = cache.get(uri || link);\n\t\tif (cached !== undefined) {\n\t\t\treturn cached;\n\t\t}\n\n\t\tif (uri) {\n\t\t\ttry {\n\t\t\t\tconst stat = await this._fileService.stat(uri);\n\t\t\t\tconst result = { uri, link, isDirectory: stat.isDirectory };\n\t\t\t\tcache.set(uri, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\t// Does not exist\n\t\t\t\tcache.set(uri, null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// Remove any line/col suffix\n\t\tlet linkUrl = removeLinkSuffix(link);\n\n\t\t// Remove any query string\n\t\tlinkUrl = removeLinkQueryString(linkUrl);\n\n\t\t// Exit early if the link is determines as not valid already\n\t\tif (linkUrl.length === 0) {\n\t\t\tcache.set(link, null);\n\t\t\treturn null;\n\t\t}\n\n\t\t// If the link looks like a /mnt/ WSL path and this is a Windows frontend, use the backend\n\t\t// to get the resolved path from the wslpath util.\n\t\tif (isWindows && link.match(/^\\/mnt\\/[a-z]/i) && processManager.backend) {\n\t\t\tlinkUrl = await processManager.backend.getWslPath(linkUrl, 'unix-to-win');\n\t\t}\n\t\t// Skip preprocessing if it looks like a special Windows -> WSL link\n\t\telse if (isWindows && link.match(/^(?:\\/\\/|\\\\\\\\)wsl(?:\\$|\\.localhost)(\\/|\\\\)/)) {\n\t\t\t// No-op, it's already the right format\n\t\t}\n\t\t// Handle all non-WSL links\n\t\telse {\n\t\t\tconst preprocessedLink = this._preprocessPath(linkUrl, processManager.initialCwd, processManager.os, processManager.userHome);\n\t\t\tif (!preprocessedLink) {\n\t\t\t\tcache.set(link, null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlinkUrl = preprocessedLink;\n\t\t}\n\n\t\ttry {\n\t\t\tlet uri: URI;\n\t\t\tif (processManager.remoteAuthority) {\n\t\t\t\turi = URI.from({\n\t\t\t\t\tscheme: Schemas.vscodeRemote,\n\t\t\t\t\tauthority: processManager.remoteAuthority,\n\t\t\t\t\tpath: linkUrl\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\turi = URI.file(linkUrl);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst stat = await this._fileService.stat(uri);\n\t\t\t\tconst result = { uri, link, isDirectory: stat.isDirectory };\n\t\t\t\tcache.set(link, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\t// Does not exist\n\t\t\t\tcache.set(link, null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch {\n\t\t\t// Errors in parsing the path\n\t\t\tcache.set(link, null);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprotected _preprocessPath(link: string, initialCwd: string, os: OperatingSystem | undefined, userHome: string | undefined): string | null {\n\t\tconst osPath = this._getOsPath(os);\n\t\tif (link.charAt(0) === '~') {\n\t\t\t// Resolve ~ -> userHome\n\t\t\tif (!userHome) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlink = osPath.join(userHome, link.substring(1));\n\t\t} else if (link.charAt(0) !== '/' && link.charAt(0) !== '~') {\n\t\t\t// Resolve workspace path . | .. | <relative_path> -> <path>/. | <path>/.. | <path>/<relative_path>\n\t\t\tif (os === OperatingSystem.Windows) {\n\t\t\t\tif (!link.match('^' + winDrivePrefix) && !link.startsWith('\\\\\\\\?\\\\')) {\n\t\t\t\t\tif (!initialCwd) {\n\t\t\t\t\t\t// Abort if no workspace is open\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tlink = osPath.join(initialCwd, link);\n\t\t\t\t} else {\n\t\t\t\t\t// Remove \\\\?\\ from paths so that they share the same underlying\n\t\t\t\t\t// uri and don't open multiple tabs for the same file\n\t\t\t\t\tlink = link.replace(/^\\\\\\\\\\?\\\\/, '');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!initialCwd) {\n\t\t\t\t\t// Abort if no workspace is open\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tlink = osPath.join(initialCwd, link);\n\t\t\t}\n\t\t}\n\t\tlink = osPath.normalize(link);\n\n\t\treturn link;\n\t}\n\n\tprivate _getOsPath(os: OperatingSystem | undefined): IPath {\n\t\treturn (os ?? OS) === OperatingSystem.Windows ? win32 : posix;\n\t}\n}\n\nconst enum LinkCacheConstants {\n\t/**\n\t * How long to cache links for in milliseconds, the TTL resets whenever a new value is set in\n\t * the cache.\n\t */\n\tTTL = 10000\n}\n\nclass LinkCache {\n\tprivate readonly _cache = new Map<string, ResolvedLink>();\n\tprivate _cacheTilTimeout = 0;\n\n\tset(link: string | URI, value: ResolvedLink) {\n\t\t// Reset cached link TTL on any set\n\t\tif (this._cacheTilTimeout) {\n\t\t\tmainWindow.clearTimeout(this._cacheTilTimeout);\n\t\t}\n\t\tthis._cacheTilTimeout = mainWindow.setTimeout(() => this._cache.clear(), LinkCacheConstants.TTL);\n\t\tthis._cache.set(this._getKey(link), value);\n\t}\n\n\tget(link: string | URI): ResolvedLink | undefined {\n\t\treturn this._cache.get(this._getKey(link));\n\t}\n\n\tprivate _getKey(link: string | URI): string {\n\t\tif (URI.isUri(link)) {\n\t\t\treturn link.toString();\n\t\t}\n\t\treturn link;\n\t}\n}\n"]}