{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/links/browser/terminalLinkParsing.ts","vs/workbench/contrib/terminalContrib/links/browser/terminalLinkParsing.ts"],"names":[],"mappings":"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","file":"terminalLinkParsing.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * This module is responsible for parsing possible links out of lines with only access to the line\n * text and the target operating system, ie. it does not do any validation that paths actually\n * exist.\n */\n\nimport { Lazy } from '../../../../../base/common/lazy.js';\nimport { OperatingSystem } from '../../../../../base/common/platform.js';\n\nexport interface IParsedLink {\n\tpath: ILinkPartialRange;\n\tprefix?: ILinkPartialRange;\n\tsuffix?: ILinkSuffix;\n}\n\nexport interface ILinkSuffix {\n\trow: number | undefined;\n\tcol: number | undefined;\n\trowEnd: number | undefined;\n\tcolEnd: number | undefined;\n\tsuffix: ILinkPartialRange;\n}\n\nexport interface ILinkPartialRange {\n\tindex: number;\n\ttext: string;\n}\n\n/**\n * A regex that extracts the link suffix which contains line and column information. The link suffix\n * must terminate at the end of line.\n */\nconst linkSuffixRegexEol = new Lazy<RegExp>(() => generateLinkSuffixRegex(true));\n/**\n * A regex that extracts the link suffix which contains line and column information.\n */\nconst linkSuffixRegex = new Lazy<RegExp>(() => generateLinkSuffixRegex(false));\n\nfunction generateLinkSuffixRegex(eolOnly: boolean) {\n\tlet ri = 0;\n\tlet ci = 0;\n\tlet rei = 0;\n\tlet cei = 0;\n\tfunction r(): string {\n\t\treturn `(?<row${ri++}>\\\\d+)`;\n\t}\n\tfunction c(): string {\n\t\treturn `(?<col${ci++}>\\\\d+)`;\n\t}\n\tfunction re(): string {\n\t\treturn `(?<rowEnd${rei++}>\\\\d+)`;\n\t}\n\tfunction ce(): string {\n\t\treturn `(?<colEnd${cei++}>\\\\d+)`;\n\t}\n\n\tconst eolSuffix = eolOnly ? '$' : '';\n\n\t// The comments in the regex below use real strings/numbers for better readability, here's\n\t// the legend:\n\t// - Path    = foo\n\t// - Row     = 339\n\t// - Col     = 12\n\t// - RowEnd  = 341\n\t// - ColEnd  = 789\n\t//\n\t// These all support single quote ' in the place of \" and [] in the place of ()\n\t//\n\t// See the tests for an exhaustive list of all supported formats\n\tconst lineAndColumnRegexClauses = [\n\t\t// foo:339\n\t\t// foo:339:12\n\t\t// foo:339:12-789\n\t\t// foo:339:12-341.789\n\t\t// foo:339.12\n\t\t// foo 339\n\t\t// foo 339:12                              [#140780]\n\t\t// foo 339.12\n\t\t// foo#339\n\t\t// foo#339:12                              [#190288]\n\t\t// foo#339.12\n\t\t// foo, 339                                [#217927]\n\t\t// \"foo\",339\n\t\t// \"foo\",339:12\n\t\t// \"foo\",339.12\n\t\t// \"foo\",339.12-789\n\t\t// \"foo\",339.12-341.789\n\t\t`(?::|#| |['\"],|, )${r()}([:.]${c()}(?:-(?:${re()}\\\\.)?${ce()})?)?` + eolSuffix,\n\t\t// The quotes below are optional           [#171652]\n\t\t// \"foo\", line 339                         [#40468]\n\t\t// \"foo\", line 339, col 12\n\t\t// \"foo\", line 339, column 12\n\t\t// \"foo\":line 339\n\t\t// \"foo\":line 339, col 12\n\t\t// \"foo\":line 339, column 12\n\t\t// \"foo\": line 339\n\t\t// \"foo\": line 339, col 12\n\t\t// \"foo\": line 339, column 12\n\t\t// \"foo\" on line 339\n\t\t// \"foo\" on line 339, col 12\n\t\t// \"foo\" on line 339, column 12\n\t\t// \"foo\" line 339 column 12\n\t\t// \"foo\", line 339, character 12           [#171880]\n\t\t// \"foo\", line 339, characters 12-789      [#171880]\n\t\t// \"foo\", lines 339-341                    [#171880]\n\t\t// \"foo\", lines 339-341, characters 12-789 [#178287]\n\t\t`['\"]?(?:,? |: ?| on )lines? ${r()}(?:-${re()})?(?:,? (?:col(?:umn)?|characters?) ${c()}(?:-${ce()})?)?` + eolSuffix,\n\t\t// () and [] are interchangeable\n\t\t// foo(339)\n\t\t// foo(339,12)\n\t\t// foo(339, 12)\n\t\t// foo (339)\n\t\t// foo (339,12)\n\t\t// foo (339, 12)\n\t\t// foo: (339)\n\t\t// foo: (339,12)\n\t\t// foo: (339, 12)\n\t\t// foo(339:12)                             [#229842]\n\t\t// foo (339:12)                            [#229842]\n\t\t`:? ?[\\\\[\\\\(]${r()}(?:(?:, ?|:)${c()})?[\\\\]\\\\)]` + eolSuffix,\n\t];\n\n\tconst suffixClause = lineAndColumnRegexClauses\n\t\t// Join all clauses together\n\t\t.join('|')\n\t\t// Convert spaces to allow the non-breaking space char (ascii 160)\n\t\t.replace(/ /g, `[${'\\u00A0'} ]`);\n\n\treturn new RegExp(`(${suffixClause})`, eolOnly ? undefined : 'g');\n}\n\n/**\n * Removes the optional link suffix which contains line and column information.\n * @param link The link to use.\n */\nexport function removeLinkSuffix(link: string): string {\n\tconst suffix = getLinkSuffix(link)?.suffix;\n\tif (!suffix) {\n\t\treturn link;\n\t}\n\treturn link.substring(0, suffix.index);\n}\n\n/**\n * Removes any query string from the link.\n * @param link The link to use.\n */\nexport function removeLinkQueryString(link: string): string {\n\t// Skip ? in UNC paths\n\tconst start = link.startsWith('\\\\\\\\?\\\\') ? 4 : 0;\n\tconst index = link.indexOf('?', start);\n\tif (index === -1) {\n\t\treturn link;\n\t}\n\treturn link.substring(0, index);\n}\n\nexport function detectLinkSuffixes(line: string): ILinkSuffix[] {\n\t// Find all suffixes on the line. Since the regex global flag is used, lastIndex will be updated\n\t// in place such that there are no overlapping matches.\n\tlet match: RegExpExecArray | null;\n\tconst results: ILinkSuffix[] = [];\n\tlinkSuffixRegex.value.lastIndex = 0;\n\twhile ((match = linkSuffixRegex.value.exec(line)) !== null) {\n\t\tconst suffix = toLinkSuffix(match);\n\t\tif (suffix === null) {\n\t\t\tbreak;\n\t\t}\n\t\tresults.push(suffix);\n\t}\n\treturn results;\n}\n\n/**\n * Returns the optional link suffix which contains line and column information.\n * @param link The link to parse.\n */\nexport function getLinkSuffix(link: string): ILinkSuffix | null {\n\treturn toLinkSuffix(linkSuffixRegexEol.value.exec(link));\n}\n\nexport function toLinkSuffix(match: RegExpExecArray | null): ILinkSuffix | null {\n\tconst groups = match?.groups;\n\tif (!groups || match.length < 1) {\n\t\treturn null;\n\t}\n\treturn {\n\t\trow: parseIntOptional(groups.row0 || groups.row1 || groups.row2),\n\t\tcol: parseIntOptional(groups.col0 || groups.col1 || groups.col2),\n\t\trowEnd: parseIntOptional(groups.rowEnd0 || groups.rowEnd1 || groups.rowEnd2),\n\t\tcolEnd: parseIntOptional(groups.colEnd0 || groups.colEnd1 || groups.colEnd2),\n\t\tsuffix: { index: match.index, text: match[0] }\n\t};\n}\n\nfunction parseIntOptional(value: string | undefined): number | undefined {\n\tif (value === undefined) {\n\t\treturn value;\n\t}\n\treturn parseInt(value);\n}\n\n// This defines valid path characters for a link with a suffix, the first `[]` of the regex includes\n// characters the path is not allowed to _start_ with, the second `[]` includes characters not\n// allowed at all in the path. If the characters show up in both regexes the link will stop at that\n// character, otherwise it will stop at a space character.\nconst linkWithSuffixPathCharacters = /(?<path>(?:file:\\/\\/\\/)?[^\\s\\|<>\\[\\({][^\\s\\|<>]*)$/;\n\nexport function detectLinks(line: string, os: OperatingSystem) {\n\t// 1: Detect all links on line via suffixes first\n\tconst results = detectLinksViaSuffix(line);\n\n\t// 2: Detect all links without suffixes and merge non-conflicting ranges into the results\n\tconst noSuffixPaths = detectPathsNoSuffix(line, os);\n\tbinaryInsertList(results, noSuffixPaths);\n\n\treturn results;\n}\n\nfunction binaryInsertList(list: IParsedLink[], newItems: IParsedLink[]) {\n\tif (list.length === 0) {\n\t\tlist.push(...newItems);\n\t}\n\tfor (const item of newItems) {\n\t\tbinaryInsert(list, item, 0, list.length);\n\t}\n}\n\nfunction binaryInsert(list: IParsedLink[], newItem: IParsedLink, low: number, high: number) {\n\tif (list.length === 0) {\n\t\tlist.push(newItem);\n\t\treturn;\n\t}\n\tif (low > high) {\n\t\treturn;\n\t}\n\t// Find the index where the newItem would be inserted\n\tconst mid = Math.floor((low + high) / 2);\n\tif (\n\t\tmid >= list.length ||\n\t\t(newItem.path.index < list[mid].path.index && (mid === 0 || newItem.path.index > list[mid - 1].path.index))\n\t) {\n\t\t// Check if it conflicts with an existing link before adding\n\t\tif (\n\t\t\tmid >= list.length ||\n\t\t\t(newItem.path.index + newItem.path.text.length < list[mid].path.index && (mid === 0 || newItem.path.index > list[mid - 1].path.index + list[mid - 1].path.text.length))\n\t\t) {\n\t\t\tlist.splice(mid, 0, newItem);\n\t\t}\n\t\treturn;\n\t}\n\tif (newItem.path.index > list[mid].path.index) {\n\t\tbinaryInsert(list, newItem, mid + 1, high);\n\t} else {\n\t\tbinaryInsert(list, newItem, low, mid - 1);\n\t}\n}\n\nfunction detectLinksViaSuffix(line: string): IParsedLink[] {\n\tconst results: IParsedLink[] = [];\n\n\t// 1: Detect link suffixes on the line\n\tconst suffixes = detectLinkSuffixes(line);\n\tfor (const suffix of suffixes) {\n\t\tconst beforeSuffix = line.substring(0, suffix.suffix.index);\n\t\tconst possiblePathMatch = beforeSuffix.match(linkWithSuffixPathCharacters);\n\t\tif (possiblePathMatch && possiblePathMatch.index !== undefined && possiblePathMatch.groups?.path) {\n\t\t\tlet linkStartIndex = possiblePathMatch.index;\n\t\t\tlet path = possiblePathMatch.groups.path;\n\t\t\t// Extract a path prefix if it exists (not part of the path, but part of the underlined\n\t\t\t// section)\n\t\t\tlet prefix: ILinkPartialRange | undefined = undefined;\n\t\t\tconst prefixMatch = path.match(/^(?<prefix>['\"]+)/);\n\t\t\tif (prefixMatch?.groups?.prefix) {\n\t\t\t\tprefix = {\n\t\t\t\t\tindex: linkStartIndex,\n\t\t\t\t\ttext: prefixMatch.groups.prefix\n\t\t\t\t};\n\t\t\t\tpath = path.substring(prefix.text.length);\n\n\t\t\t\t// Don't allow suffix links to be returned when the link itself is the empty string\n\t\t\t\tif (path.trim().length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If there are multiple characters in the prefix, trim the prefix if the _first_\n\t\t\t\t// suffix character is the same as the last prefix character. For example, for the\n\t\t\t\t// text `echo \"'foo' on line 1\"`:\n\t\t\t\t//\n\t\t\t\t// - Prefix='\n\t\t\t\t// - Path=foo\n\t\t\t\t// - Suffix=' on line 1\n\t\t\t\t//\n\t\t\t\t// If this fails on a multi-character prefix, just keep the original.\n\t\t\t\tif (prefixMatch.groups.prefix.length > 1) {\n\t\t\t\t\tif (suffix.suffix.text[0].match(/['\"]/) && prefixMatch.groups.prefix[prefixMatch.groups.prefix.length - 1] === suffix.suffix.text[0]) {\n\t\t\t\t\t\tconst trimPrefixAmount = prefixMatch.groups.prefix.length - 1;\n\t\t\t\t\t\tprefix.index += trimPrefixAmount;\n\t\t\t\t\t\tprefix.text = prefixMatch.groups.prefix[prefixMatch.groups.prefix.length - 1];\n\t\t\t\t\t\tlinkStartIndex += trimPrefixAmount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.push({\n\t\t\t\tpath: {\n\t\t\t\t\tindex: linkStartIndex + (prefix?.text.length || 0),\n\t\t\t\t\ttext: path\n\t\t\t\t},\n\t\t\t\tprefix,\n\t\t\t\tsuffix\n\t\t\t});\n\n\t\t\t// If the path contains an opening bracket, provide the path starting immediately after\n\t\t\t// the opening bracket as an additional result\n\t\t\tconst openingBracketMatch = path.matchAll(/(?<bracket>[\\[\\(])(?![\\]\\)])/g);\n\t\t\tfor (const match of openingBracketMatch) {\n\t\t\t\tconst bracket = match.groups?.bracket;\n\t\t\t\tif (bracket) {\n\t\t\t\t\tresults.push({\n\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\tindex: linkStartIndex + (prefix?.text.length || 0) + match.index + 1,\n\t\t\t\t\t\t\ttext: path.substring(match.index + bracket.length)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tprefix,\n\t\t\t\t\t\tsuffix\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results;\n}\n\nenum RegexPathConstants {\n\tPathPrefix = '(?:\\\\.\\\\.?|\\\\~|file:\\/\\/)',\n\tPathSeparatorClause = '\\\\/',\n\t// '\":; are allowed in paths but they are often separators so ignore them\n\t// Also disallow \\\\ to prevent a catastropic backtracking case #24795\n\tExcludedPathCharactersClause = '[^\\\\0<>\\\\?\\\\s!`&*()\\'\":;\\\\\\\\]',\n\tExcludedStartPathCharactersClause = '[^\\\\0<>\\\\?\\\\s!`&*()\\\\[\\\\]\\'\":;\\\\\\\\]',\n\n\tWinOtherPathPrefix = '\\\\.\\\\.?|\\\\~',\n\tWinPathSeparatorClause = '(?:\\\\\\\\|\\\\/)',\n\tWinExcludedPathCharactersClause = '[^\\\\0<>\\\\?\\\\|\\\\/\\\\s!`&*()\\'\":;]',\n\tWinExcludedStartPathCharactersClause = '[^\\\\0<>\\\\?\\\\|\\\\/\\\\s!`&*()\\\\[\\\\]\\'\":;]',\n}\n\n/**\n * A regex that matches non-Windows paths, such as `/foo`, `~/foo`, `./foo`, `../foo` and\n * `foo/bar`.\n */\nconst unixLocalLinkClause = '(?:(?:' + RegexPathConstants.PathPrefix + '|(?:' + RegexPathConstants.ExcludedStartPathCharactersClause + RegexPathConstants.ExcludedPathCharactersClause + '*))?(?:' + RegexPathConstants.PathSeparatorClause + '(?:' + RegexPathConstants.ExcludedPathCharactersClause + ')+)+)';\n\n/**\n * A regex clause that matches the start of an absolute path on Windows, such as: `C:`, `c:`,\n * `file:///c:` (uri) and `\\\\?\\C:` (UNC path).\n */\nexport const winDrivePrefix = '(?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\|file:\\\\/\\\\/\\\\/)?[a-zA-Z]:';\n\n/**\n * A regex that matches Windows paths, such as `\\\\?\\c:\\foo`, `c:\\foo`, `~\\foo`, `.\\foo`, `..\\foo`\n * and `foo\\bar`.\n */\nconst winLocalLinkClause = '(?:(?:' + `(?:${winDrivePrefix}|${RegexPathConstants.WinOtherPathPrefix})` + '|(?:' + RegexPathConstants.WinExcludedStartPathCharactersClause + RegexPathConstants.WinExcludedPathCharactersClause + '*))?(?:' + RegexPathConstants.WinPathSeparatorClause + '(?:' + RegexPathConstants.WinExcludedPathCharactersClause + ')+)+)';\n\nfunction detectPathsNoSuffix(line: string, os: OperatingSystem): IParsedLink[] {\n\tconst results: IParsedLink[] = [];\n\n\tconst regex = new RegExp(os === OperatingSystem.Windows ? winLocalLinkClause : unixLocalLinkClause, 'g');\n\tlet match;\n\twhile ((match = regex.exec(line)) !== null) {\n\t\tlet text = match[0];\n\t\tlet index = match.index;\n\t\tif (!text) {\n\t\t\t// Something matched but does not comply with the given match index, since this would\n\t\t\t// most likely a bug the regex itself we simply do nothing here\n\t\t\tbreak;\n\t\t}\n\n\t\t// Adjust the link range to exclude a/ and b/ if it looks like a git diff\n\t\tif (\n\t\t\t// --- a/foo/bar\n\t\t\t// +++ b/foo/bar\n\t\t\t((line.startsWith('--- a/') || line.startsWith('+++ b/')) && index === 4) ||\n\t\t\t// diff --git a/foo/bar b/foo/bar\n\t\t\t(line.startsWith('diff --git') && (text.startsWith('a/') || text.startsWith('b/')))\n\t\t) {\n\t\t\ttext = text.substring(2);\n\t\t\tindex += 2;\n\t\t}\n\n\t\tresults.push({\n\t\t\tpath: {\n\t\t\t\tindex,\n\t\t\t\ttext\n\t\t\t},\n\t\t\tprefix: undefined,\n\t\t\tsuffix: undefined\n\t\t});\n\t}\n\n\treturn results;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * This module is responsible for parsing possible links out of lines with only access to the line\n * text and the target operating system, ie. it does not do any validation that paths actually\n * exist.\n */\n\nimport { Lazy } from '../../../../../base/common/lazy.js';\nimport { OperatingSystem } from '../../../../../base/common/platform.js';\n\nexport interface IParsedLink {\n\tpath: ILinkPartialRange;\n\tprefix?: ILinkPartialRange;\n\tsuffix?: ILinkSuffix;\n}\n\nexport interface ILinkSuffix {\n\trow: number | undefined;\n\tcol: number | undefined;\n\trowEnd: number | undefined;\n\tcolEnd: number | undefined;\n\tsuffix: ILinkPartialRange;\n}\n\nexport interface ILinkPartialRange {\n\tindex: number;\n\ttext: string;\n}\n\n/**\n * A regex that extracts the link suffix which contains line and column information. The link suffix\n * must terminate at the end of line.\n */\nconst linkSuffixRegexEol = new Lazy<RegExp>(() => generateLinkSuffixRegex(true));\n/**\n * A regex that extracts the link suffix which contains line and column information.\n */\nconst linkSuffixRegex = new Lazy<RegExp>(() => generateLinkSuffixRegex(false));\n\nfunction generateLinkSuffixRegex(eolOnly: boolean) {\n\tlet ri = 0;\n\tlet ci = 0;\n\tlet rei = 0;\n\tlet cei = 0;\n\tfunction r(): string {\n\t\treturn `(?<row${ri++}>\\\\d+)`;\n\t}\n\tfunction c(): string {\n\t\treturn `(?<col${ci++}>\\\\d+)`;\n\t}\n\tfunction re(): string {\n\t\treturn `(?<rowEnd${rei++}>\\\\d+)`;\n\t}\n\tfunction ce(): string {\n\t\treturn `(?<colEnd${cei++}>\\\\d+)`;\n\t}\n\n\tconst eolSuffix = eolOnly ? '$' : '';\n\n\t// The comments in the regex below use real strings/numbers for better readability, here's\n\t// the legend:\n\t// - Path    = foo\n\t// - Row     = 339\n\t// - Col     = 12\n\t// - RowEnd  = 341\n\t// - ColEnd  = 789\n\t//\n\t// These all support single quote ' in the place of \" and [] in the place of ()\n\t//\n\t// See the tests for an exhaustive list of all supported formats\n\tconst lineAndColumnRegexClauses = [\n\t\t// foo:339\n\t\t// foo:339:12\n\t\t// foo:339:12-789\n\t\t// foo:339:12-341.789\n\t\t// foo:339.12\n\t\t// foo 339\n\t\t// foo 339:12                              [#140780]\n\t\t// foo 339.12\n\t\t// foo#339\n\t\t// foo#339:12                              [#190288]\n\t\t// foo#339.12\n\t\t// foo, 339                                [#217927]\n\t\t// \"foo\",339\n\t\t// \"foo\",339:12\n\t\t// \"foo\",339.12\n\t\t// \"foo\",339.12-789\n\t\t// \"foo\",339.12-341.789\n\t\t`(?::|#| |['\"],|, )${r()}([:.]${c()}(?:-(?:${re()}\\\\.)?${ce()})?)?` + eolSuffix,\n\t\t// The quotes below are optional           [#171652]\n\t\t// \"foo\", line 339                         [#40468]\n\t\t// \"foo\", line 339, col 12\n\t\t// \"foo\", line 339, column 12\n\t\t// \"foo\":line 339\n\t\t// \"foo\":line 339, col 12\n\t\t// \"foo\":line 339, column 12\n\t\t// \"foo\": line 339\n\t\t// \"foo\": line 339, col 12\n\t\t// \"foo\": line 339, column 12\n\t\t// \"foo\" on line 339\n\t\t// \"foo\" on line 339, col 12\n\t\t// \"foo\" on line 339, column 12\n\t\t// \"foo\" line 339 column 12\n\t\t// \"foo\", line 339, character 12           [#171880]\n\t\t// \"foo\", line 339, characters 12-789      [#171880]\n\t\t// \"foo\", lines 339-341                    [#171880]\n\t\t// \"foo\", lines 339-341, characters 12-789 [#178287]\n\t\t`['\"]?(?:,? |: ?| on )lines? ${r()}(?:-${re()})?(?:,? (?:col(?:umn)?|characters?) ${c()}(?:-${ce()})?)?` + eolSuffix,\n\t\t// () and [] are interchangeable\n\t\t// foo(339)\n\t\t// foo(339,12)\n\t\t// foo(339, 12)\n\t\t// foo (339)\n\t\t// foo (339,12)\n\t\t// foo (339, 12)\n\t\t// foo: (339)\n\t\t// foo: (339,12)\n\t\t// foo: (339, 12)\n\t\t// foo(339:12)                             [#229842]\n\t\t// foo (339:12)                            [#229842]\n\t\t`:? ?[\\\\[\\\\(]${r()}(?:(?:, ?|:)${c()})?[\\\\]\\\\)]` + eolSuffix,\n\t];\n\n\tconst suffixClause = lineAndColumnRegexClauses\n\t\t// Join all clauses together\n\t\t.join('|')\n\t\t// Convert spaces to allow the non-breaking space char (ascii 160)\n\t\t.replace(/ /g, `[${'\\u00A0'} ]`);\n\n\treturn new RegExp(`(${suffixClause})`, eolOnly ? undefined : 'g');\n}\n\n/**\n * Removes the optional link suffix which contains line and column information.\n * @param link The link to use.\n */\nexport function removeLinkSuffix(link: string): string {\n\tconst suffix = getLinkSuffix(link)?.suffix;\n\tif (!suffix) {\n\t\treturn link;\n\t}\n\treturn link.substring(0, suffix.index);\n}\n\n/**\n * Removes any query string from the link.\n * @param link The link to use.\n */\nexport function removeLinkQueryString(link: string): string {\n\t// Skip ? in UNC paths\n\tconst start = link.startsWith('\\\\\\\\?\\\\') ? 4 : 0;\n\tconst index = link.indexOf('?', start);\n\tif (index === -1) {\n\t\treturn link;\n\t}\n\treturn link.substring(0, index);\n}\n\nexport function detectLinkSuffixes(line: string): ILinkSuffix[] {\n\t// Find all suffixes on the line. Since the regex global flag is used, lastIndex will be updated\n\t// in place such that there are no overlapping matches.\n\tlet match: RegExpExecArray | null;\n\tconst results: ILinkSuffix[] = [];\n\tlinkSuffixRegex.value.lastIndex = 0;\n\twhile ((match = linkSuffixRegex.value.exec(line)) !== null) {\n\t\tconst suffix = toLinkSuffix(match);\n\t\tif (suffix === null) {\n\t\t\tbreak;\n\t\t}\n\t\tresults.push(suffix);\n\t}\n\treturn results;\n}\n\n/**\n * Returns the optional link suffix which contains line and column information.\n * @param link The link to parse.\n */\nexport function getLinkSuffix(link: string): ILinkSuffix | null {\n\treturn toLinkSuffix(linkSuffixRegexEol.value.exec(link));\n}\n\nexport function toLinkSuffix(match: RegExpExecArray | null): ILinkSuffix | null {\n\tconst groups = match?.groups;\n\tif (!groups || match.length < 1) {\n\t\treturn null;\n\t}\n\treturn {\n\t\trow: parseIntOptional(groups.row0 || groups.row1 || groups.row2),\n\t\tcol: parseIntOptional(groups.col0 || groups.col1 || groups.col2),\n\t\trowEnd: parseIntOptional(groups.rowEnd0 || groups.rowEnd1 || groups.rowEnd2),\n\t\tcolEnd: parseIntOptional(groups.colEnd0 || groups.colEnd1 || groups.colEnd2),\n\t\tsuffix: { index: match.index, text: match[0] }\n\t};\n}\n\nfunction parseIntOptional(value: string | undefined): number | undefined {\n\tif (value === undefined) {\n\t\treturn value;\n\t}\n\treturn parseInt(value);\n}\n\n// This defines valid path characters for a link with a suffix, the first `[]` of the regex includes\n// characters the path is not allowed to _start_ with, the second `[]` includes characters not\n// allowed at all in the path. If the characters show up in both regexes the link will stop at that\n// character, otherwise it will stop at a space character.\nconst linkWithSuffixPathCharacters = /(?<path>(?:file:\\/\\/\\/)?[^\\s\\|<>\\[\\({][^\\s\\|<>]*)$/;\n\nexport function detectLinks(line: string, os: OperatingSystem) {\n\t// 1: Detect all links on line via suffixes first\n\tconst results = detectLinksViaSuffix(line);\n\n\t// 2: Detect all links without suffixes and merge non-conflicting ranges into the results\n\tconst noSuffixPaths = detectPathsNoSuffix(line, os);\n\tbinaryInsertList(results, noSuffixPaths);\n\n\treturn results;\n}\n\nfunction binaryInsertList(list: IParsedLink[], newItems: IParsedLink[]) {\n\tif (list.length === 0) {\n\t\tlist.push(...newItems);\n\t}\n\tfor (const item of newItems) {\n\t\tbinaryInsert(list, item, 0, list.length);\n\t}\n}\n\nfunction binaryInsert(list: IParsedLink[], newItem: IParsedLink, low: number, high: number) {\n\tif (list.length === 0) {\n\t\tlist.push(newItem);\n\t\treturn;\n\t}\n\tif (low > high) {\n\t\treturn;\n\t}\n\t// Find the index where the newItem would be inserted\n\tconst mid = Math.floor((low + high) / 2);\n\tif (\n\t\tmid >= list.length ||\n\t\t(newItem.path.index < list[mid].path.index && (mid === 0 || newItem.path.index > list[mid - 1].path.index))\n\t) {\n\t\t// Check if it conflicts with an existing link before adding\n\t\tif (\n\t\t\tmid >= list.length ||\n\t\t\t(newItem.path.index + newItem.path.text.length < list[mid].path.index && (mid === 0 || newItem.path.index > list[mid - 1].path.index + list[mid - 1].path.text.length))\n\t\t) {\n\t\t\tlist.splice(mid, 0, newItem);\n\t\t}\n\t\treturn;\n\t}\n\tif (newItem.path.index > list[mid].path.index) {\n\t\tbinaryInsert(list, newItem, mid + 1, high);\n\t} else {\n\t\tbinaryInsert(list, newItem, low, mid - 1);\n\t}\n}\n\nfunction detectLinksViaSuffix(line: string): IParsedLink[] {\n\tconst results: IParsedLink[] = [];\n\n\t// 1: Detect link suffixes on the line\n\tconst suffixes = detectLinkSuffixes(line);\n\tfor (const suffix of suffixes) {\n\t\tconst beforeSuffix = line.substring(0, suffix.suffix.index);\n\t\tconst possiblePathMatch = beforeSuffix.match(linkWithSuffixPathCharacters);\n\t\tif (possiblePathMatch && possiblePathMatch.index !== undefined && possiblePathMatch.groups?.path) {\n\t\t\tlet linkStartIndex = possiblePathMatch.index;\n\t\t\tlet path = possiblePathMatch.groups.path;\n\t\t\t// Extract a path prefix if it exists (not part of the path, but part of the underlined\n\t\t\t// section)\n\t\t\tlet prefix: ILinkPartialRange | undefined = undefined;\n\t\t\tconst prefixMatch = path.match(/^(?<prefix>['\"]+)/);\n\t\t\tif (prefixMatch?.groups?.prefix) {\n\t\t\t\tprefix = {\n\t\t\t\t\tindex: linkStartIndex,\n\t\t\t\t\ttext: prefixMatch.groups.prefix\n\t\t\t\t};\n\t\t\t\tpath = path.substring(prefix.text.length);\n\n\t\t\t\t// Don't allow suffix links to be returned when the link itself is the empty string\n\t\t\t\tif (path.trim().length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If there are multiple characters in the prefix, trim the prefix if the _first_\n\t\t\t\t// suffix character is the same as the last prefix character. For example, for the\n\t\t\t\t// text `echo \"'foo' on line 1\"`:\n\t\t\t\t//\n\t\t\t\t// - Prefix='\n\t\t\t\t// - Path=foo\n\t\t\t\t// - Suffix=' on line 1\n\t\t\t\t//\n\t\t\t\t// If this fails on a multi-character prefix, just keep the original.\n\t\t\t\tif (prefixMatch.groups.prefix.length > 1) {\n\t\t\t\t\tif (suffix.suffix.text[0].match(/['\"]/) && prefixMatch.groups.prefix[prefixMatch.groups.prefix.length - 1] === suffix.suffix.text[0]) {\n\t\t\t\t\t\tconst trimPrefixAmount = prefixMatch.groups.prefix.length - 1;\n\t\t\t\t\t\tprefix.index += trimPrefixAmount;\n\t\t\t\t\t\tprefix.text = prefixMatch.groups.prefix[prefixMatch.groups.prefix.length - 1];\n\t\t\t\t\t\tlinkStartIndex += trimPrefixAmount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.push({\n\t\t\t\tpath: {\n\t\t\t\t\tindex: linkStartIndex + (prefix?.text.length || 0),\n\t\t\t\t\ttext: path\n\t\t\t\t},\n\t\t\t\tprefix,\n\t\t\t\tsuffix\n\t\t\t});\n\n\t\t\t// If the path contains an opening bracket, provide the path starting immediately after\n\t\t\t// the opening bracket as an additional result\n\t\t\tconst openingBracketMatch = path.matchAll(/(?<bracket>[\\[\\(])(?![\\]\\)])/g);\n\t\t\tfor (const match of openingBracketMatch) {\n\t\t\t\tconst bracket = match.groups?.bracket;\n\t\t\t\tif (bracket) {\n\t\t\t\t\tresults.push({\n\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\tindex: linkStartIndex + (prefix?.text.length || 0) + match.index + 1,\n\t\t\t\t\t\t\ttext: path.substring(match.index + bracket.length)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tprefix,\n\t\t\t\t\t\tsuffix\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results;\n}\n\nenum RegexPathConstants {\n\tPathPrefix = '(?:\\\\.\\\\.?|\\\\~|file:\\/\\/)',\n\tPathSeparatorClause = '\\\\/',\n\t// '\":; are allowed in paths but they are often separators so ignore them\n\t// Also disallow \\\\ to prevent a catastropic backtracking case #24795\n\tExcludedPathCharactersClause = '[^\\\\0<>\\\\?\\\\s!`&*()\\'\":;\\\\\\\\]',\n\tExcludedStartPathCharactersClause = '[^\\\\0<>\\\\?\\\\s!`&*()\\\\[\\\\]\\'\":;\\\\\\\\]',\n\n\tWinOtherPathPrefix = '\\\\.\\\\.?|\\\\~',\n\tWinPathSeparatorClause = '(?:\\\\\\\\|\\\\/)',\n\tWinExcludedPathCharactersClause = '[^\\\\0<>\\\\?\\\\|\\\\/\\\\s!`&*()\\'\":;]',\n\tWinExcludedStartPathCharactersClause = '[^\\\\0<>\\\\?\\\\|\\\\/\\\\s!`&*()\\\\[\\\\]\\'\":;]',\n}\n\n/**\n * A regex that matches non-Windows paths, such as `/foo`, `~/foo`, `./foo`, `../foo` and\n * `foo/bar`.\n */\nconst unixLocalLinkClause = '(?:(?:' + RegexPathConstants.PathPrefix + '|(?:' + RegexPathConstants.ExcludedStartPathCharactersClause + RegexPathConstants.ExcludedPathCharactersClause + '*))?(?:' + RegexPathConstants.PathSeparatorClause + '(?:' + RegexPathConstants.ExcludedPathCharactersClause + ')+)+)';\n\n/**\n * A regex clause that matches the start of an absolute path on Windows, such as: `C:`, `c:`,\n * `file:///c:` (uri) and `\\\\?\\C:` (UNC path).\n */\nexport const winDrivePrefix = '(?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\|file:\\\\/\\\\/\\\\/)?[a-zA-Z]:';\n\n/**\n * A regex that matches Windows paths, such as `\\\\?\\c:\\foo`, `c:\\foo`, `~\\foo`, `.\\foo`, `..\\foo`\n * and `foo\\bar`.\n */\nconst winLocalLinkClause = '(?:(?:' + `(?:${winDrivePrefix}|${RegexPathConstants.WinOtherPathPrefix})` + '|(?:' + RegexPathConstants.WinExcludedStartPathCharactersClause + RegexPathConstants.WinExcludedPathCharactersClause + '*))?(?:' + RegexPathConstants.WinPathSeparatorClause + '(?:' + RegexPathConstants.WinExcludedPathCharactersClause + ')+)+)';\n\nfunction detectPathsNoSuffix(line: string, os: OperatingSystem): IParsedLink[] {\n\tconst results: IParsedLink[] = [];\n\n\tconst regex = new RegExp(os === OperatingSystem.Windows ? winLocalLinkClause : unixLocalLinkClause, 'g');\n\tlet match;\n\twhile ((match = regex.exec(line)) !== null) {\n\t\tlet text = match[0];\n\t\tlet index = match.index;\n\t\tif (!text) {\n\t\t\t// Something matched but does not comply with the given match index, since this would\n\t\t\t// most likely a bug the regex itself we simply do nothing here\n\t\t\tbreak;\n\t\t}\n\n\t\t// Adjust the link range to exclude a/ and b/ if it looks like a git diff\n\t\tif (\n\t\t\t// --- a/foo/bar\n\t\t\t// +++ b/foo/bar\n\t\t\t((line.startsWith('--- a/') || line.startsWith('+++ b/')) && index === 4) ||\n\t\t\t// diff --git a/foo/bar b/foo/bar\n\t\t\t(line.startsWith('diff --git') && (text.startsWith('a/') || text.startsWith('b/')))\n\t\t) {\n\t\t\ttext = text.substring(2);\n\t\t\tindex += 2;\n\t\t}\n\n\t\tresults.push({\n\t\t\tpath: {\n\t\t\t\tindex,\n\t\t\t\ttext\n\t\t\t},\n\t\t\tprefix: undefined,\n\t\t\tsuffix: undefined\n\t\t});\n\t}\n\n\treturn results;\n}\n"]}