{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/links/browser/terminalLinkHelpers.ts","vs/workbench/contrib/terminalContrib/links/browser/terminalLinkHelpers.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAKhG,OAAO,EAAS,KAAK,EAAE,KAAK,EAAE,MAAM,oCAAoC,CAAC;AAIzE;;;;;;;GAOG;AACH,MAAM,UAAU,wBAAwB,CACvC,KAAoB,EACpB,WAAmB,EACnB,KAAa,EACb,SAAiB;IAEjB,MAAM,WAAW,GAAiB;QACjC,KAAK,EAAE;YACN,CAAC,EAAE,KAAK,CAAC,WAAW;YACpB,CAAC,EAAE,KAAK,CAAC,eAAe,GAAG,SAAS;SACpC;QACD,GAAG,EAAE;YACJ,CAAC,EAAE,KAAK,CAAC,SAAS,GAAG,CAAC;YACtB,CAAC,EAAE,KAAK,CAAC,aAAa,GAAG,SAAS;SAClC;KACD,CAAC;IAEF,kEAAkE;IAClE,IAAI,WAAW,GAAG,CAAC,CAAC;IACpB,MAAM,qBAAqB,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,WAAW,CAAC,CAAC;IACzE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,qBAAqB,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC1D,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,WAAW,CAAC,CAAC;QACpF,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,kFAAkF;QAClF,0FAA0F;QAC1F,8BAA8B;QAC9B,IAAI,CAAC,IAAI,EAAE,CAAC;YACX,MAAM;QACP,CAAC;QACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,UAAU,GAAG,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACzE,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC7B,sFAAsF;YACtF,aAAa;YACb,IAAI,CAAC,IAAI,EAAE,CAAC;gBACX,MAAM;YACP,CAAC;YACD,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC9B,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC;gBACjB,UAAU,EAAE,CAAC;YACd,CAAC;YACD,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC7B,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACrB,UAAU,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YAC/B,CAAC;QACF,CAAC;QACD,WAAW,IAAI,UAAU,CAAC;IAC3B,CAAC;IAED,gEAAgE;IAChE,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,MAAM,mBAAmB,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,WAAW,CAAC,CAAC;IACrE,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,qBAAqB,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,mBAAmB,EAAE,CAAC,EAAE,EAAE,CAAC;QACnF,MAAM,KAAK,GAAG,CAAC,CAAC,KAAK,qBAAqB,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,GAAG,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1G,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,KAAK,CAAC,SAAS,GAAG,WAAW,GAAG,CAAC,GAAG,WAAW,CAAC,CAAC;QAC1F,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,kFAAkF;QAClF,0FAA0F;QAC1F,8BAA8B;QAC9B,IAAI,CAAC,IAAI,EAAE,CAAC;YACX,MAAM;QACP,CAAC;QACD,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,UAAU,GAAG,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC7E,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC7B,sFAAsF;YACtF,aAAa;YACb,IAAI,CAAC,IAAI,EAAE,CAAC;gBACX,MAAM;YACP,CAAC;YACD,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC9B,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC9B,kDAAkD;YAClD,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC;gBACjB,UAAU,EAAE,CAAC;YACd,CAAC;YACD,0EAA0E;YAC1E,IAAI,CAAC,KAAK,WAAW,GAAG,CAAC,IAAI,KAAK,KAAK,EAAE,EAAE,CAAC;gBAC3C,UAAU,EAAE,CAAC;YACd,CAAC;YACD,0CAA0C;YAC1C,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACtB,UAAU,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;YAChC,CAAC;QACF,CAAC;QACD,SAAS,IAAI,UAAU,CAAC;IACzB,CAAC;IAED,kDAAkD;IAClD,WAAW,CAAC,KAAK,CAAC,CAAC,IAAI,WAAW,CAAC;IACnC,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI,WAAW,GAAG,SAAS,CAAC;IAE7C,gCAAgC;IAChC,OAAO,WAAW,CAAC,KAAK,CAAC,CAAC,GAAG,WAAW,EAAE,CAAC;QAC1C,WAAW,CAAC,KAAK,CAAC,CAAC,IAAI,WAAW,CAAC;QACnC,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;IACvB,CAAC;IACD,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,EAAE,CAAC;QACxC,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI,WAAW,CAAC;QACjC,WAAW,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC;IACrB,CAAC;IAED,OAAO,WAAW,CAAC;AACpB,CAAC;AAED,MAAM,UAAU,4BAA4B,CAAC,WAAyB,EAAE,SAAiB;IACxF,OAAO;QACN,KAAK,EAAE;YACN,CAAC,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC;YAC1B,CAAC,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC,GAAG,SAAS,GAAG,CAAC;SACtC;QACD,GAAG,EAAE;YACJ,CAAC,EAAE,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;YACxB,CAAC,EAAE,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS,GAAG,CAAC;SACpC;KACD,CAAC;AACH,CAAC;AAED,MAAM,UAAU,mBAAmB,CAAC,MAAe,EAAE,SAAiB,EAAE,OAAe,EAAE,IAAY;IACpG,+FAA+F;IAC/F,2FAA2F;IAC3F,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,GAAG,CAAC,CAAC,CAAC;IAC/C,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,SAAS,GAAG,aAAa,CAAC,CAAC;IACvD,IAAI,OAAO,GAAG,EAAE,CAAC;IACjB,KAAK,IAAI,CAAC,GAAG,SAAS,EAAE,CAAC,IAAI,OAAO,EAAE,CAAC,EAAE,EAAE,CAAC;QAC3C,wFAAwF;QACxF,0EAA0E;QAC1E,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAC/B,IAAI,IAAI,EAAE,CAAC;YACV,OAAO,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;QAClD,CAAC;IACF,CAAC;IACD,OAAO,OAAO,CAAC;AAChB,CAAC;AAED,MAAM,UAAU,oBAAoB,CAAC,MAAe,EAAE,SAAiB,EAAE,OAAe,EAAE,IAAY;IACrG,IAAI,gBAAgB,GAAoC,SAAS,CAAC;IAClE,IAAI,UAAU,GAAW,CAAC,CAAC,CAAC;IAC5B,IAAI,UAAU,GAAW,CAAC,CAAC,CAAC;IAC5B,MAAM,MAAM,GAAmB,EAAE,CAAC;IAClC,KAAK,IAAI,CAAC,GAAG,SAAS,EAAE,CAAC,IAAI,OAAO,EAAE,CAAC,EAAE,EAAE,CAAC;QAC3C,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAC/B,IAAI,CAAC,IAAI,EAAE,CAAC;YACX,SAAS;QACV,CAAC;QACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;YAC/B,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC7B,IAAI,CAAC,IAAI,EAAE,CAAC;gBACX,MAAM;YACP,CAAC;YACD,+EAA+E;YAC/E,sCAAsC;YACtC,MAAM,UAAU,GAAG,CAClB,IAAI,CAAC,MAAM,EAAE;gBACb,IAAI,CAAC,SAAS,EAAE;gBAChB,IAAI,CAAC,eAAe,EAAE;gBACtB,IAAI,CAAC,WAAW,EAAE,CAClB,CAAC;YACF,MAAM,UAAU,GAAG,CAClB,IAAI,CAAC,KAAK,EAAE;gBACZ,IAAI,CAAC,QAAQ,EAAE,CACf,CAAC;YACF,IAAI,UAAU,KAAK,CAAC,CAAC,IAAI,UAAU,KAAK,CAAC,CAAC,EAAE,CAAC;gBAC5C,gBAAgB,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;YAC7B,CAAC;iBAAM,CAAC;gBACP,IAAI,UAAU,KAAK,UAAU,IAAI,UAAU,KAAK,UAAU,EAAE,CAAC;oBAC5D,mBAAmB;oBACnB,MAAM,cAAc,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;oBAChC,MAAM,CAAC,IAAI,CAAC;wBACX,KAAK,EAAE,gBAAiB;wBACxB,GAAG,EAAE,cAAc;qBACnB,CAAC,CAAC;oBACH,gBAAgB,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;gBAC7B,CAAC;YACF,CAAC;YACD,UAAU,GAAG,UAAU,CAAC;YACxB,UAAU,GAAG,UAAU,CAAC;QACzB,CAAC;IACF,CAAC;IACD,OAAO,MAAM,CAAC;AACf,CAAC;AAGD,mGAAmG;AACnG,iEAAiE;AACjE,kBAAkB;AAClB,KAAK;AACL,qEAAqE;AACrE,kBAAkB;AAClB,KAAK;AACL,iEAAiE;AACjE,kBAAkB;AAClB,KAAK;AACL,gBAAgB;AAChB,IAAI;AAEJ;;;GAGG;AACH,MAAM,UAAU,yBAAyB,CAAC,YAAsC,EAAE,CAAS,EAAE,IAAY,EAAE,MAAa,EAAE,UAA+B;IACxJ,MAAM,GAAG,GAAG,YAAY,CAAC,GAAG,6CAAqC,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC;IACpF,UAAU,CAAC,KAAK,CAAC,mDAAmD,EAAE,GAAG,CAAC,CAAC;IAC3E,IAAI,CAAC,GAAG,EAAE,CAAC;QACV,OAAO,SAAS,CAAC;IAClB,CAAC;IACD,MAAM,MAAM,GAAa,EAAE,CAAC;IAC5B,MAAM,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC;IACvB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC;QACzB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC;IAC/C,CAAC;SAAM,CAAC;QACP,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,MAAM,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC;QACzC,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACjC,yFAAyF;QACzF,uFAAuF;QACvF,wFAAwF;QACxF,qCAAqC;QACrC,OAAO,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;YAC3B,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,GAAG,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAC9E,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;gBAChC,UAAU,EAAE,CAAC;YACd,CAAC;iBAAM,CAAC;gBACP,MAAM;YACP,CAAC;YACD,CAAC,EAAE,CAAC;QACL,CAAC;IACF,CAAC;IACD,OAAO,MAAM,CAAC;AACf,CAAC;AAED,MAAM,UAAU,YAAY,CAAC,EAAmB;IAC/C,OAAO,EAAE,oCAA4B,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC;AACvD,CAAC","file":"terminalLinkHelpers.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IViewportRange, IBufferRange, IBufferLine, IBuffer, IBufferCellPosition } from '@xterm/xterm';\nimport { IRange } from '../../../../../editor/common/core/range.js';\nimport { OperatingSystem } from '../../../../../base/common/platform.js';\nimport { IPath, posix, win32 } from '../../../../../base/common/path.js';\nimport { ITerminalCapabilityStore, TerminalCapability } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { ITerminalLogService } from '../../../../../platform/terminal/common/terminal.js';\n\n/**\n * Converts a possibly wrapped link's range (comprised of string indices) into a buffer range that plays nicely with xterm.js\n *\n * @param lines A single line (not the entire buffer)\n * @param bufferWidth The number of columns in the terminal\n * @param range The link range - string indices\n * @param startLine The absolute y position (on the buffer) of the line\n */\nexport function convertLinkRangeToBuffer(\n\tlines: IBufferLine[],\n\tbufferWidth: number,\n\trange: IRange,\n\tstartLine: number\n): IBufferRange {\n\tconst bufferRange: IBufferRange = {\n\t\tstart: {\n\t\t\tx: range.startColumn,\n\t\t\ty: range.startLineNumber + startLine\n\t\t},\n\t\tend: {\n\t\t\tx: range.endColumn - 1,\n\t\t\ty: range.endLineNumber + startLine\n\t\t}\n\t};\n\n\t// Shift start range right for each wide character before the link\n\tlet startOffset = 0;\n\tconst startWrappedLineCount = Math.ceil(range.startColumn / bufferWidth);\n\tfor (let y = 0; y < Math.min(startWrappedLineCount); y++) {\n\t\tconst lineLength = Math.min(bufferWidth, (range.startColumn - 1) - y * bufferWidth);\n\t\tlet lineOffset = 0;\n\t\tconst line = lines[y];\n\t\t// Sanity check for line, apparently this can happen but it's not clear under what\n\t\t// circumstances this happens. Continue on, skipping the remainder of start offset if this\n\t\t// happens to minimize impact.\n\t\tif (!line) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (let x = 0; x < Math.min(bufferWidth, lineLength + lineOffset); x++) {\n\t\t\tconst cell = line.getCell(x);\n\t\t\t// This is unexpected but it means the character doesn't exist, so we shouldn't add to\n\t\t\t// the offset\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst width = cell.getWidth();\n\t\t\tif (width === 2) {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t\tconst char = cell.getChars();\n\t\t\tif (char.length > 1) {\n\t\t\t\tlineOffset -= char.length - 1;\n\t\t\t}\n\t\t}\n\t\tstartOffset += lineOffset;\n\t}\n\n\t// Shift end range right for each wide character inside the link\n\tlet endOffset = 0;\n\tconst endWrappedLineCount = Math.ceil(range.endColumn / bufferWidth);\n\tfor (let y = Math.max(0, startWrappedLineCount - 1); y < endWrappedLineCount; y++) {\n\t\tconst start = (y === startWrappedLineCount - 1 ? (range.startColumn - 1 + startOffset) % bufferWidth : 0);\n\t\tconst lineLength = Math.min(bufferWidth, range.endColumn + startOffset - y * bufferWidth);\n\t\tlet lineOffset = 0;\n\t\tconst line = lines[y];\n\t\t// Sanity check for line, apparently this can happen but it's not clear under what\n\t\t// circumstances this happens. Continue on, skipping the remainder of start offset if this\n\t\t// happens to minimize impact.\n\t\tif (!line) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (let x = start; x < Math.min(bufferWidth, lineLength + lineOffset); x++) {\n\t\t\tconst cell = line.getCell(x);\n\t\t\t// This is unexpected but it means the character doesn't exist, so we shouldn't add to\n\t\t\t// the offset\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst width = cell.getWidth();\n\t\t\tconst chars = cell.getChars();\n\t\t\t// Offset for null cells following wide characters\n\t\t\tif (width === 2) {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t\t// Offset for early wrapping when the last cell in row is a wide character\n\t\t\tif (x === bufferWidth - 1 && chars === '') {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t\t// Offset multi-code characters like emoji\n\t\t\tif (chars.length > 1) {\n\t\t\t\tlineOffset -= chars.length - 1;\n\t\t\t}\n\t\t}\n\t\tendOffset += lineOffset;\n\t}\n\n\t// Apply the width character offsets to the result\n\tbufferRange.start.x += startOffset;\n\tbufferRange.end.x += startOffset + endOffset;\n\n\t// Convert back to wrapped lines\n\twhile (bufferRange.start.x > bufferWidth) {\n\t\tbufferRange.start.x -= bufferWidth;\n\t\tbufferRange.start.y++;\n\t}\n\twhile (bufferRange.end.x > bufferWidth) {\n\t\tbufferRange.end.x -= bufferWidth;\n\t\tbufferRange.end.y++;\n\t}\n\n\treturn bufferRange;\n}\n\nexport function convertBufferRangeToViewport(bufferRange: IBufferRange, viewportY: number): IViewportRange {\n\treturn {\n\t\tstart: {\n\t\t\tx: bufferRange.start.x - 1,\n\t\t\ty: bufferRange.start.y - viewportY - 1\n\t\t},\n\t\tend: {\n\t\t\tx: bufferRange.end.x - 1,\n\t\t\ty: bufferRange.end.y - viewportY - 1\n\t\t}\n\t};\n}\n\nexport function getXtermLineContent(buffer: IBuffer, lineStart: number, lineEnd: number, cols: number): string {\n\t// Cap the maximum number of lines generated to prevent potential performance problems. This is\n\t// more of a sanity check as the wrapped line should already be trimmed down at this point.\n\tconst maxLineLength = Math.max(2048, cols * 2);\n\tlineEnd = Math.min(lineEnd, lineStart + maxLineLength);\n\tlet content = '';\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nexport function getXtermRangesByAttr(buffer: IBuffer, lineStart: number, lineEnd: number, cols: number): IBufferRange[] {\n\tlet bufferRangeStart: IBufferCellPosition | undefined = undefined;\n\tlet lastFgAttr: number = -1;\n\tlet lastBgAttr: number = -1;\n\tconst ranges: IBufferRange[] = [];\n\tfor (let y = lineStart; y <= lineEnd; y++) {\n\t\tconst line = buffer.getLine(y);\n\t\tif (!line) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (let x = 0; x < cols; x++) {\n\t\t\tconst cell = line.getCell(x);\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// HACK: Re-construct the attributes from fg and bg, this is hacky as it relies\n\t\t\t// upon the internal buffer bit layout\n\t\t\tconst thisFgAttr = (\n\t\t\t\tcell.isBold() |\n\t\t\t\tcell.isInverse() |\n\t\t\t\tcell.isStrikethrough() |\n\t\t\t\tcell.isUnderline()\n\t\t\t);\n\t\t\tconst thisBgAttr = (\n\t\t\t\tcell.isDim() |\n\t\t\t\tcell.isItalic()\n\t\t\t);\n\t\t\tif (lastFgAttr === -1 || lastBgAttr === -1) {\n\t\t\t\tbufferRangeStart = { x, y };\n\t\t\t} else {\n\t\t\t\tif (lastFgAttr !== thisFgAttr || lastBgAttr !== thisBgAttr) {\n\t\t\t\t\t// TODO: x overflow\n\t\t\t\t\tconst bufferRangeEnd = { x, y };\n\t\t\t\t\tranges.push({\n\t\t\t\t\t\tstart: bufferRangeStart!,\n\t\t\t\t\t\tend: bufferRangeEnd\n\t\t\t\t\t});\n\t\t\t\t\tbufferRangeStart = { x, y };\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastFgAttr = thisFgAttr;\n\t\t\tlastBgAttr = thisBgAttr;\n\t\t}\n\t}\n\treturn ranges;\n}\n\n\n// export function positionIsInRange(position: IBufferCellPosition, range: IBufferRange): boolean {\n// \tif (position.y < range.start.y || position.y > range.end.y) {\n// \t\treturn false;\n// \t}\n// \tif (position.y === range.start.y && position.x < range.start.x) {\n// \t\treturn false;\n// \t}\n// \tif (position.y === range.end.y && position.x > range.end.x) {\n// \t\treturn false;\n// \t}\n// \treturn true;\n// }\n\n/**\n * For shells with the CommandDetection capability, the cwd for a command relative to the line of\n * the particular link can be used to narrow down the result for an exact file match.\n */\nexport function updateLinkWithRelativeCwd(capabilities: ITerminalCapabilityStore, y: number, text: string, osPath: IPath, logService: ITerminalLogService): string[] | undefined {\n\tconst cwd = capabilities.get(TerminalCapability.CommandDetection)?.getCwdForLine(y);\n\tlogService.trace('terminalLinkHelpers#updateLinkWithRelativeCwd cwd', cwd);\n\tif (!cwd) {\n\t\treturn undefined;\n\t}\n\tconst result: string[] = [];\n\tconst sep = osPath.sep;\n\tif (!text.includes(sep)) {\n\t\tresult.push(osPath.resolve(cwd + sep + text));\n\t} else {\n\t\tlet commonDirs = 0;\n\t\tlet i = 0;\n\t\tconst cwdPath = cwd.split(sep).reverse();\n\t\tconst linkPath = text.split(sep);\n\t\t// Get all results as candidates, prioritizing the link with the most common directories.\n\t\t// For example if in the directory /home/common and the link is common/file, the result\n\t\t// should be: `['/home/common/common/file', '/home/common/file']`. The first is the most\n\t\t// likely as cwd detection is active.\n\t\twhile (i < cwdPath.length) {\n\t\t\tresult.push(osPath.resolve(cwd + sep + linkPath.slice(commonDirs).join(sep)));\n\t\t\tif (cwdPath[i] === linkPath[i]) {\n\t\t\t\tcommonDirs++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function osPathModule(os: OperatingSystem): IPath {\n\treturn os === OperatingSystem.Windows ? win32 : posix;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IViewportRange, IBufferRange, IBufferLine, IBuffer, IBufferCellPosition } from '@xterm/xterm';\nimport { IRange } from '../../../../../editor/common/core/range.js';\nimport { OperatingSystem } from '../../../../../base/common/platform.js';\nimport { IPath, posix, win32 } from '../../../../../base/common/path.js';\nimport { ITerminalCapabilityStore, TerminalCapability } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { ITerminalLogService } from '../../../../../platform/terminal/common/terminal.js';\n\n/**\n * Converts a possibly wrapped link's range (comprised of string indices) into a buffer range that plays nicely with xterm.js\n *\n * @param lines A single line (not the entire buffer)\n * @param bufferWidth The number of columns in the terminal\n * @param range The link range - string indices\n * @param startLine The absolute y position (on the buffer) of the line\n */\nexport function convertLinkRangeToBuffer(\n\tlines: IBufferLine[],\n\tbufferWidth: number,\n\trange: IRange,\n\tstartLine: number\n): IBufferRange {\n\tconst bufferRange: IBufferRange = {\n\t\tstart: {\n\t\t\tx: range.startColumn,\n\t\t\ty: range.startLineNumber + startLine\n\t\t},\n\t\tend: {\n\t\t\tx: range.endColumn - 1,\n\t\t\ty: range.endLineNumber + startLine\n\t\t}\n\t};\n\n\t// Shift start range right for each wide character before the link\n\tlet startOffset = 0;\n\tconst startWrappedLineCount = Math.ceil(range.startColumn / bufferWidth);\n\tfor (let y = 0; y < Math.min(startWrappedLineCount); y++) {\n\t\tconst lineLength = Math.min(bufferWidth, (range.startColumn - 1) - y * bufferWidth);\n\t\tlet lineOffset = 0;\n\t\tconst line = lines[y];\n\t\t// Sanity check for line, apparently this can happen but it's not clear under what\n\t\t// circumstances this happens. Continue on, skipping the remainder of start offset if this\n\t\t// happens to minimize impact.\n\t\tif (!line) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (let x = 0; x < Math.min(bufferWidth, lineLength + lineOffset); x++) {\n\t\t\tconst cell = line.getCell(x);\n\t\t\t// This is unexpected but it means the character doesn't exist, so we shouldn't add to\n\t\t\t// the offset\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst width = cell.getWidth();\n\t\t\tif (width === 2) {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t\tconst char = cell.getChars();\n\t\t\tif (char.length > 1) {\n\t\t\t\tlineOffset -= char.length - 1;\n\t\t\t}\n\t\t}\n\t\tstartOffset += lineOffset;\n\t}\n\n\t// Shift end range right for each wide character inside the link\n\tlet endOffset = 0;\n\tconst endWrappedLineCount = Math.ceil(range.endColumn / bufferWidth);\n\tfor (let y = Math.max(0, startWrappedLineCount - 1); y < endWrappedLineCount; y++) {\n\t\tconst start = (y === startWrappedLineCount - 1 ? (range.startColumn - 1 + startOffset) % bufferWidth : 0);\n\t\tconst lineLength = Math.min(bufferWidth, range.endColumn + startOffset - y * bufferWidth);\n\t\tlet lineOffset = 0;\n\t\tconst line = lines[y];\n\t\t// Sanity check for line, apparently this can happen but it's not clear under what\n\t\t// circumstances this happens. Continue on, skipping the remainder of start offset if this\n\t\t// happens to minimize impact.\n\t\tif (!line) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (let x = start; x < Math.min(bufferWidth, lineLength + lineOffset); x++) {\n\t\t\tconst cell = line.getCell(x);\n\t\t\t// This is unexpected but it means the character doesn't exist, so we shouldn't add to\n\t\t\t// the offset\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst width = cell.getWidth();\n\t\t\tconst chars = cell.getChars();\n\t\t\t// Offset for null cells following wide characters\n\t\t\tif (width === 2) {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t\t// Offset for early wrapping when the last cell in row is a wide character\n\t\t\tif (x === bufferWidth - 1 && chars === '') {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t\t// Offset multi-code characters like emoji\n\t\t\tif (chars.length > 1) {\n\t\t\t\tlineOffset -= chars.length - 1;\n\t\t\t}\n\t\t}\n\t\tendOffset += lineOffset;\n\t}\n\n\t// Apply the width character offsets to the result\n\tbufferRange.start.x += startOffset;\n\tbufferRange.end.x += startOffset + endOffset;\n\n\t// Convert back to wrapped lines\n\twhile (bufferRange.start.x > bufferWidth) {\n\t\tbufferRange.start.x -= bufferWidth;\n\t\tbufferRange.start.y++;\n\t}\n\twhile (bufferRange.end.x > bufferWidth) {\n\t\tbufferRange.end.x -= bufferWidth;\n\t\tbufferRange.end.y++;\n\t}\n\n\treturn bufferRange;\n}\n\nexport function convertBufferRangeToViewport(bufferRange: IBufferRange, viewportY: number): IViewportRange {\n\treturn {\n\t\tstart: {\n\t\t\tx: bufferRange.start.x - 1,\n\t\t\ty: bufferRange.start.y - viewportY - 1\n\t\t},\n\t\tend: {\n\t\t\tx: bufferRange.end.x - 1,\n\t\t\ty: bufferRange.end.y - viewportY - 1\n\t\t}\n\t};\n}\n\nexport function getXtermLineContent(buffer: IBuffer, lineStart: number, lineEnd: number, cols: number): string {\n\t// Cap the maximum number of lines generated to prevent potential performance problems. This is\n\t// more of a sanity check as the wrapped line should already be trimmed down at this point.\n\tconst maxLineLength = Math.max(2048, cols * 2);\n\tlineEnd = Math.min(lineEnd, lineStart + maxLineLength);\n\tlet content = '';\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nexport function getXtermRangesByAttr(buffer: IBuffer, lineStart: number, lineEnd: number, cols: number): IBufferRange[] {\n\tlet bufferRangeStart: IBufferCellPosition | undefined = undefined;\n\tlet lastFgAttr: number = -1;\n\tlet lastBgAttr: number = -1;\n\tconst ranges: IBufferRange[] = [];\n\tfor (let y = lineStart; y <= lineEnd; y++) {\n\t\tconst line = buffer.getLine(y);\n\t\tif (!line) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (let x = 0; x < cols; x++) {\n\t\t\tconst cell = line.getCell(x);\n\t\t\tif (!cell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// HACK: Re-construct the attributes from fg and bg, this is hacky as it relies\n\t\t\t// upon the internal buffer bit layout\n\t\t\tconst thisFgAttr = (\n\t\t\t\tcell.isBold() |\n\t\t\t\tcell.isInverse() |\n\t\t\t\tcell.isStrikethrough() |\n\t\t\t\tcell.isUnderline()\n\t\t\t);\n\t\t\tconst thisBgAttr = (\n\t\t\t\tcell.isDim() |\n\t\t\t\tcell.isItalic()\n\t\t\t);\n\t\t\tif (lastFgAttr === -1 || lastBgAttr === -1) {\n\t\t\t\tbufferRangeStart = { x, y };\n\t\t\t} else {\n\t\t\t\tif (lastFgAttr !== thisFgAttr || lastBgAttr !== thisBgAttr) {\n\t\t\t\t\t// TODO: x overflow\n\t\t\t\t\tconst bufferRangeEnd = { x, y };\n\t\t\t\t\tranges.push({\n\t\t\t\t\t\tstart: bufferRangeStart!,\n\t\t\t\t\t\tend: bufferRangeEnd\n\t\t\t\t\t});\n\t\t\t\t\tbufferRangeStart = { x, y };\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastFgAttr = thisFgAttr;\n\t\t\tlastBgAttr = thisBgAttr;\n\t\t}\n\t}\n\treturn ranges;\n}\n\n\n// export function positionIsInRange(position: IBufferCellPosition, range: IBufferRange): boolean {\n// \tif (position.y < range.start.y || position.y > range.end.y) {\n// \t\treturn false;\n// \t}\n// \tif (position.y === range.start.y && position.x < range.start.x) {\n// \t\treturn false;\n// \t}\n// \tif (position.y === range.end.y && position.x > range.end.x) {\n// \t\treturn false;\n// \t}\n// \treturn true;\n// }\n\n/**\n * For shells with the CommandDetection capability, the cwd for a command relative to the line of\n * the particular link can be used to narrow down the result for an exact file match.\n */\nexport function updateLinkWithRelativeCwd(capabilities: ITerminalCapabilityStore, y: number, text: string, osPath: IPath, logService: ITerminalLogService): string[] | undefined {\n\tconst cwd = capabilities.get(TerminalCapability.CommandDetection)?.getCwdForLine(y);\n\tlogService.trace('terminalLinkHelpers#updateLinkWithRelativeCwd cwd', cwd);\n\tif (!cwd) {\n\t\treturn undefined;\n\t}\n\tconst result: string[] = [];\n\tconst sep = osPath.sep;\n\tif (!text.includes(sep)) {\n\t\tresult.push(osPath.resolve(cwd + sep + text));\n\t} else {\n\t\tlet commonDirs = 0;\n\t\tlet i = 0;\n\t\tconst cwdPath = cwd.split(sep).reverse();\n\t\tconst linkPath = text.split(sep);\n\t\t// Get all results as candidates, prioritizing the link with the most common directories.\n\t\t// For example if in the directory /home/common and the link is common/file, the result\n\t\t// should be: `['/home/common/common/file', '/home/common/file']`. The first is the most\n\t\t// likely as cwd detection is active.\n\t\twhile (i < cwdPath.length) {\n\t\t\tresult.push(osPath.resolve(cwd + sep + linkPath.slice(commonDirs).join(sep)));\n\t\t\tif (cwdPath[i] === linkPath[i]) {\n\t\t\t\tcommonDirs++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function osPathModule(os: OperatingSystem): IPath {\n\treturn os === OperatingSystem.Windows ? win32 : posix;\n}\n"]}