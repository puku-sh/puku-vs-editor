{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/suggest/browser/terminalCompletionService.ts","vs/workbench/contrib/terminalContrib/suggest/browser/terminalCompletionService.ts"],"names":[],"mappings":"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","file":"terminalCompletionService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { basename } from '../../../../../base/common/path.js';\nimport { URI, UriComponents } from '../../../../../base/common/uri.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { FileSystemProviderCapabilities, IFileService } from '../../../../../platform/files/common/files.js';\nimport { createDecorator } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { TerminalCapability, type ITerminalCapabilityStore } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { GeneralShellType, ITerminalLogService, TerminalShellType, WindowsShellType } from '../../../../../platform/terminal/common/terminal.js';\nimport { TerminalSuggestSettingId } from '../common/terminalSuggestConfiguration.js';\nimport { TerminalCompletionItemKind, type ITerminalCompletion } from './terminalCompletionItem.js';\nimport { env as processEnv } from '../../../../../base/common/process.js';\nimport type { IProcessEnvironment } from '../../../../../base/common/platform.js';\nimport { timeout } from '../../../../../base/common/async.js';\nimport { gitBashToWindowsPath, windowsToGitBashPath } from './terminalGitBashHelpers.js';\nimport { isEqual } from '../../../../../base/common/resources.js';\nimport { ILabelService } from '../../../../../platform/label/common/label.js';\nimport { IRelativePattern, match } from '../../../../../base/common/glob.js';\nimport { isString } from '../../../../../base/common/types.js';\n\nexport const ITerminalCompletionService = createDecorator<ITerminalCompletionService>('terminalCompletionService');\n\n/**\n * Represents a collection of {@link CompletionItem completion items} to be presented\n * in the terminal.\n */\nexport class TerminalCompletionList<ITerminalCompletion> {\n\n\t/**\n\t * Resources should be shown in the completions list\n\t */\n\tresourceOptions?: TerminalCompletionResourceOptions;\n\n\t/**\n\t * The completion items.\n\t */\n\titems?: ITerminalCompletion[];\n\n\t/**\n\t * Creates a new completion list.\n\t *\n\t * @param items The completion items.\n\t * @param isIncomplete The list is not complete.\n\t */\n\tconstructor(items?: ITerminalCompletion[], resourceOptions?: TerminalCompletionResourceOptions) {\n\t\tthis.items = items;\n\t\tthis.resourceOptions = resourceOptions;\n\t}\n}\n\nexport interface TerminalCompletionResourceOptions {\n\tshowFiles?: boolean;\n\tshowDirectories?: boolean;\n\tglobPattern?: string | IRelativePattern;\n\tcwd: UriComponents;\n\tpathSeparator: string;\n}\n\n\nexport interface ITerminalCompletionProvider {\n\tid: string;\n\tshellTypes?: TerminalShellType[];\n\tprovideCompletions(value: string, cursorPosition: number, token: CancellationToken): Promise<ITerminalCompletion[] | TerminalCompletionList<ITerminalCompletion> | undefined>;\n\ttriggerCharacters?: string[];\n\tisBuiltin?: boolean;\n}\n\nexport interface ITerminalCompletionService {\n\t_serviceBrand: undefined;\n\treadonly providers: IterableIterator<ITerminalCompletionProvider>;\n\treadonly onDidChangeProviders: Event<void>;\n\tregisterTerminalCompletionProvider(extensionIdentifier: string, id: string, provider: ITerminalCompletionProvider, ...triggerCharacters: string[]): IDisposable;\n\tprovideCompletions(promptValue: string, cursorPosition: number, allowFallbackCompletions: boolean, shellType: TerminalShellType | undefined, capabilities: ITerminalCapabilityStore, token: CancellationToken, triggerCharacter?: boolean, skipExtensionCompletions?: boolean, explicitlyInvoked?: boolean): Promise<ITerminalCompletion[] | undefined>;\n}\n\nexport class TerminalCompletionService extends Disposable implements ITerminalCompletionService {\n\tdeclare _serviceBrand: undefined;\n\tprivate readonly _providers: Map</*ext id*/string, Map</*provider id*/string, ITerminalCompletionProvider>> = new Map();\n\n\tprivate readonly _onDidChangeProviders = this._register(new Emitter<void>());\n\treadonly onDidChangeProviders = this._onDidChangeProviders.event;\n\n\tget providers(): IterableIterator<ITerminalCompletionProvider> {\n\t\treturn this._providersGenerator();\n\t}\n\n\tprivate *_providersGenerator(): IterableIterator<ITerminalCompletionProvider> {\n\t\tfor (const providerMap of this._providers.values()) {\n\t\t\tfor (const provider of providerMap.values()) {\n\t\t\t\tyield provider;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Overrides the environment for testing purposes. */\n\tset processEnv(env: IProcessEnvironment) { this._processEnv = env; }\n\tprivate _processEnv = processEnv;\n\n\tconstructor(\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@ILabelService private readonly _labelService: ILabelService,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService\n\t) {\n\t\tsuper();\n\t}\n\n\tregisterTerminalCompletionProvider(extensionIdentifier: string, id: string, provider: ITerminalCompletionProvider, ...triggerCharacters: string[]): IDisposable {\n\t\tlet extMap = this._providers.get(extensionIdentifier);\n\t\tif (!extMap) {\n\t\t\textMap = new Map();\n\t\t\tthis._providers.set(extensionIdentifier, extMap);\n\t\t}\n\t\tprovider.triggerCharacters = triggerCharacters;\n\t\tprovider.id = id;\n\t\textMap.set(id, provider);\n\t\tthis._onDidChangeProviders.fire();\n\t\treturn toDisposable(() => {\n\t\t\tconst extMap = this._providers.get(extensionIdentifier);\n\t\t\tif (extMap) {\n\t\t\t\textMap.delete(id);\n\t\t\t\tif (extMap.size === 0) {\n\t\t\t\t\tthis._providers.delete(extensionIdentifier);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._onDidChangeProviders.fire();\n\t\t});\n\t}\n\n\tasync provideCompletions(promptValue: string, cursorPosition: number, allowFallbackCompletions: boolean, shellType: TerminalShellType | undefined, capabilities: ITerminalCapabilityStore, token: CancellationToken, triggerCharacter?: boolean, skipExtensionCompletions?: boolean, explicitlyInvoked?: boolean): Promise<ITerminalCompletion[] | undefined> {\n\t\tthis._logService.trace('TerminalCompletionService#provideCompletions');\n\t\tif (!this._providers || !this._providers.values || cursorPosition < 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet providers;\n\t\tif (triggerCharacter) {\n\t\t\tconst providersToRequest: ITerminalCompletionProvider[] = [];\n\t\t\tfor (const provider of this.providers) {\n\t\t\t\tif (!provider.triggerCharacters) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (const char of provider.triggerCharacters) {\n\t\t\t\t\tif (promptValue.substring(0, cursorPosition)?.endsWith(char)) {\n\t\t\t\t\t\tprovidersToRequest.push(provider);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tproviders = providersToRequest;\n\t\t} else {\n\t\t\tproviders = [...this._providers.values()].flatMap(providerMap => [...providerMap.values()]);\n\t\t}\n\n\t\tif (skipExtensionCompletions) {\n\t\t\tproviders = providers.filter(p => p.isBuiltin);\n\t\t\treturn this._collectCompletions(providers, shellType, promptValue, cursorPosition, allowFallbackCompletions, capabilities, token, explicitlyInvoked);\n\t\t}\n\n\t\tproviders = this._getEnabledProviders(providers);\n\n\t\tif (!providers.length) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this._collectCompletions(providers, shellType, promptValue, cursorPosition, allowFallbackCompletions, capabilities, token, explicitlyInvoked);\n\t}\n\n\tprotected _getEnabledProviders(providers: ITerminalCompletionProvider[]): ITerminalCompletionProvider[] {\n\t\tconst providerConfig: { [key: string]: boolean } = this._configurationService.getValue(TerminalSuggestSettingId.Providers);\n\t\treturn providers.filter(p => {\n\t\t\tconst providerId = p.id;\n\t\t\treturn providerId && (!Object.prototype.hasOwnProperty.call(providerConfig, providerId) || providerConfig[providerId] !== false);\n\t\t});\n\t}\n\n\tprivate async _collectCompletions(providers: ITerminalCompletionProvider[], shellType: TerminalShellType | undefined, promptValue: string, cursorPosition: number, allowFallbackCompletions: boolean, capabilities: ITerminalCapabilityStore, token: CancellationToken, explicitlyInvoked?: boolean): Promise<ITerminalCompletion[] | undefined> {\n\t\tthis._logService.trace('TerminalCompletionService#_collectCompletions');\n\t\tconst completionPromises = providers.map(async provider => {\n\t\t\tif (provider.shellTypes && shellType && !provider.shellTypes.includes(shellType)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst timeoutMs = explicitlyInvoked ? 30000 : 5000;\n\t\t\tlet timedOut = false;\n\t\t\tlet completions;\n\t\t\ttry {\n\t\t\t\tcompletions = await Promise.race([\n\t\t\t\t\tprovider.provideCompletions(promptValue, cursorPosition, token).then(result => {\n\t\t\t\t\t\tthis._logService.trace(`TerminalCompletionService#_collectCompletions provider ${provider.id} finished`);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}),\n\t\t\t\t\t(async () => { await timeout(timeoutMs); timedOut = true; return undefined; })()\n\t\t\t\t]);\n\t\t\t} catch (e) {\n\t\t\t\tthis._logService.trace(`[TerminalCompletionService] Exception from provider '${provider.id}':`, e);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (timedOut) {\n\t\t\t\tthis._logService.trace(`[TerminalCompletionService] Provider '${provider.id}' timed out after ${timeoutMs}ms. promptValue='${promptValue}', cursorPosition=${cursorPosition}, explicitlyInvoked=${explicitlyInvoked}`);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (!completions) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst completionItems = Array.isArray(completions) ? completions : completions.items ?? [];\n\t\t\tthis._logService.trace(`TerminalCompletionService#_collectCompletions amend ${completionItems.length} completion items`);\n\t\t\tif (shellType === GeneralShellType.PowerShell) {\n\t\t\t\tfor (const completion of completionItems) {\n\t\t\t\t\tconst start = completion.replacementRange ? completion.replacementRange[0] : 0;\n\t\t\t\t\tcompletion.isFileOverride ??= completion.kind === TerminalCompletionItemKind.Method && start === 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (provider.isBuiltin) {\n\t\t\t\t//TODO: why is this needed?\n\t\t\t\tfor (const item of completionItems) {\n\t\t\t\t\titem.provider ??= provider.id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Array.isArray(completions)) {\n\t\t\t\treturn completionItems;\n\t\t\t}\n\t\t\tif (completions.resourceOptions) {\n\t\t\t\tconst resourceCompletions = await this.resolveResources(completions.resourceOptions, promptValue, cursorPosition, `core:path:ext:${provider.id}`, capabilities, shellType);\n\t\t\t\tthis._logService.trace(`TerminalCompletionService#_collectCompletions dedupe`);\n\t\t\t\tif (resourceCompletions) {\n\t\t\t\t\tconst labels = new Set(completionItems.map(c => c.label));\n\t\t\t\t\tfor (const item of resourceCompletions) {\n\t\t\t\t\t\t// Ensure no duplicates such as .\n\t\t\t\t\t\tif (!labels.has(item.label)) {\n\t\t\t\t\t\t\tcompletionItems.push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._logService.trace(`TerminalCompletionService#_collectCompletions dedupe done`);\n\t\t\t}\n\t\t\treturn completionItems;\n\t\t});\n\n\t\tconst results = await Promise.all(completionPromises);\n\t\tthis._logService.trace('TerminalCompletionService#_collectCompletions done');\n\t\treturn results.filter(result => !!result).flat();\n\t}\n\n\tasync resolveResources(resourceOptions: TerminalCompletionResourceOptions, promptValue: string, cursorPosition: number, provider: string, capabilities: ITerminalCapabilityStore, shellType?: TerminalShellType): Promise<ITerminalCompletion[] | undefined> {\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources`);\n\n\t\tconst useWindowsStylePath = resourceOptions.pathSeparator === '\\\\';\n\t\tif (useWindowsStylePath) {\n\t\t\t// for tests, make sure the right path separator is used\n\t\t\tpromptValue = promptValue.replaceAll(/[\\\\/]/g, resourceOptions.pathSeparator);\n\t\t}\n\n\t\t// Files requested implies folders requested since the file could be in any folder. We could\n\t\t// provide diagnostics when a folder is provided where a file is expected.\n\t\tconst showDirectories = (resourceOptions.showDirectories || resourceOptions.showFiles) ?? false;\n\t\tconst showFiles = resourceOptions.showFiles ?? false;\n\t\tconst globPattern = resourceOptions.globPattern ?? undefined;\n\n\t\tif (!showDirectories && !showFiles) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst resourceCompletions: ITerminalCompletion[] = [];\n\t\tconst cursorPrefix = promptValue.substring(0, cursorPosition);\n\n\t\t// TODO: Leverage Fig's tokens array here?\n\t\t// The last word (or argument). When the cursor is following a space it will be the empty\n\t\t// string\n\t\tlet lastWord = cursorPrefix.endsWith(' ') ? '' : cursorPrefix.split(/(?<!\\\\) /).at(-1) ?? '';\n\n\t\t// Ignore prefixes in the word that look like setting an environment variable\n\t\tconst matchEnvVarPrefix = lastWord.match(/^[a-zA-Z_]+=(?<rhs>.+)$/);\n\t\tif (matchEnvVarPrefix?.groups?.rhs) {\n\t\t\tlastWord = matchEnvVarPrefix.groups.rhs;\n\t\t}\n\n\t\t// Get the nearest folder path from the prefix. This ignores everything after the `/` as\n\t\t// they are what triggers changes in the directory.\n\t\tlet lastSlashIndex: number;\n\t\tif (useWindowsStylePath) {\n\t\t\t// TODO: Flesh out escaped path logic, it currently only partially works\n\t\t\tlet lastBackslashIndex = -1;\n\t\t\tfor (let i = lastWord.length - 1; i >= 0; i--) {\n\t\t\t\tif (lastWord[i] === '\\\\') {\n\t\t\t\t\tif (i === lastWord.length - 1 || lastWord[i + 1] !== ' ') {\n\t\t\t\t\t\tlastBackslashIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastSlashIndex = Math.max(lastBackslashIndex, lastWord.lastIndexOf('/'));\n\t\t} else {\n\t\t\tlastSlashIndex = lastWord.lastIndexOf(resourceOptions.pathSeparator);\n\t\t}\n\n\t\t// The _complete_ folder of the last word. For example if the last word is `./src/file`,\n\t\t// this will be `./src/`. This also always ends in the path separator if it is not the empty\n\t\t// string and path separators are normalized on Windows.\n\t\tlet lastWordFolder = lastSlashIndex === -1 ? '' : lastWord.slice(0, lastSlashIndex + 1);\n\t\tif (useWindowsStylePath) {\n\t\t\tlastWordFolder = lastWordFolder.replaceAll('/', '\\\\');\n\t\t}\n\n\n\t\t// Determine the current folder being shown\n\t\tlet lastWordFolderResource: URI | string | undefined;\n\t\tconst lastWordFolderHasDotPrefix = !!lastWordFolder.match(/^\\.\\.?[\\\\\\/]/);\n\t\tconst lastWordFolderHasTildePrefix = !!lastWordFolder.match(/^~[\\\\\\/]?/);\n\t\tconst isAbsolutePath = getIsAbsolutePath(shellType, resourceOptions.pathSeparator, lastWordFolder, useWindowsStylePath);\n\t\tconst type = lastWordFolderHasTildePrefix ? 'tilde' : isAbsolutePath ? 'absolute' : 'relative';\n\t\tconst cwd = URI.revive(resourceOptions.cwd);\n\n\t\tswitch (type) {\n\t\t\tcase 'tilde': {\n\t\t\t\tconst home = this._getHomeDir(useWindowsStylePath, capabilities);\n\t\t\t\tif (home) {\n\t\t\t\t\tlastWordFolderResource = URI.joinPath(URI.file(home), lastWordFolder.slice(1).replaceAll('\\\\ ', ' '));\n\t\t\t\t}\n\t\t\t\tif (!lastWordFolderResource) {\n\t\t\t\t\t// Use less strong wording here as it's not as strong of a concept on Windows\n\t\t\t\t\t// and could be misleading\n\t\t\t\t\tif (lastWord.match(/^~[\\\\\\/]$/)) {\n\t\t\t\t\t\tlastWordFolderResource = useWindowsStylePath ? 'Home directory' : '$HOME';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'absolute': {\n\t\t\t\tif (shellType === WindowsShellType.GitBash) {\n\t\t\t\t\tlastWordFolderResource = URI.file(gitBashToWindowsPath(lastWordFolder, this._processEnv.SystemDrive));\n\t\t\t\t} else {\n\t\t\t\t\tlastWordFolderResource = URI.file(lastWordFolder.replaceAll('\\\\ ', ' '));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'relative': {\n\t\t\t\tlastWordFolderResource = cwd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Assemble completions based on the resource of lastWordFolder. Note that on Windows the\n\t\t// path separators are normalized to `\\`.\n\t\tif (!lastWordFolderResource) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Early exit with basic completion if we don't know the resource\n\t\tif (isString(lastWordFolderResource)) {\n\t\t\tresourceCompletions.push({\n\t\t\t\tlabel: lastWordFolder,\n\t\t\t\tprovider,\n\t\t\t\tkind: TerminalCompletionItemKind.Folder,\n\t\t\t\tdetail: lastWordFolderResource,\n\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t});\n\t\t\treturn resourceCompletions;\n\t\t}\n\n\t\tconst stat = await this._fileService.resolve(lastWordFolderResource, { resolveSingleChildDescendants: true });\n\t\tif (!stat?.children) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Add current directory. This should be shown at the top because it will be an exact\n\t\t// match and therefore highlight the detail, plus it improves the experience when\n\t\t// runOnEnter is used.\n\t\t//\n\t\t// - (relative) `|`       -> `.`\n\t\t//   this does not have the trailing `/` intentionally as it's common to complete the\n\t\t//   current working directory and we do not want to complete `./` when `runOnEnter` is\n\t\t//   used.\n\t\t// - (relative) `./src/|` -> `./src/`\n\t\t// - (absolute) `/src/|`  -> `/src/`\n\t\t// - (tilde)    `~/|`     -> `~/`\n\t\t// - (tilde)    `~/src/|` -> `~/src/`\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources cwd`);\n\t\tif (showDirectories) {\n\t\t\tlet label: string;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'tilde': {\n\t\t\t\t\tlabel = lastWordFolder;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'absolute': {\n\t\t\t\t\tlabel = lastWordFolder;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'relative': {\n\t\t\t\t\tlabel = '.';\n\t\t\t\t\tif (lastWordFolder.length > 0) {\n\t\t\t\t\t\tlabel = addPathRelativePrefix(lastWordFolder, resourceOptions, lastWordFolderHasDotPrefix);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresourceCompletions.push({\n\t\t\t\tlabel,\n\t\t\t\tprovider,\n\t\t\t\tkind: TerminalCompletionItemKind.Folder,\n\t\t\t\tdetail: getFriendlyPath(this._labelService, lastWordFolderResource, resourceOptions.pathSeparator, TerminalCompletionItemKind.Folder, shellType),\n\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t});\n\t\t}\n\n\t\t// Add all direct children files or folders\n\t\t//\n\t\t// - (relative) `cd ./src/`  -> `cd ./src/folder1/`, ...\n\t\t// - (absolute) `cd c:/src/` -> `cd c:/src/folder1/`, ...\n\t\t// - (tilde)    `cd ~/src/`  -> `cd ~/src/folder1/`, ...\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources direct children`);\n\t\tawait Promise.all(stat.children.map(child => (async () => {\n\t\t\tlet kind: TerminalCompletionItemKind | undefined;\n\t\t\tlet detail: string | undefined = undefined;\n\t\t\tif (showDirectories && child.isDirectory) {\n\t\t\t\tif (child.isSymbolicLink) {\n\t\t\t\t\tkind = TerminalCompletionItemKind.SymbolicLinkFolder;\n\t\t\t\t} else {\n\t\t\t\t\tkind = TerminalCompletionItemKind.Folder;\n\t\t\t\t}\n\t\t\t} else if (showFiles && child.isFile) {\n\t\t\t\tif (child.isSymbolicLink) {\n\t\t\t\t\tkind = TerminalCompletionItemKind.SymbolicLinkFile;\n\t\t\t\t} else {\n\t\t\t\t\tkind = TerminalCompletionItemKind.File;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (kind === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet label = lastWordFolder;\n\t\t\tif (label.length > 0 && !label.endsWith(resourceOptions.pathSeparator)) {\n\t\t\t\tlabel += resourceOptions.pathSeparator;\n\t\t\t}\n\t\t\tlabel += child.name;\n\t\t\tif (type === 'relative') {\n\t\t\t\tlabel = addPathRelativePrefix(label, resourceOptions, lastWordFolderHasDotPrefix);\n\t\t\t}\n\t\t\tif (child.isDirectory && !label.endsWith(resourceOptions.pathSeparator)) {\n\t\t\t\tlabel += resourceOptions.pathSeparator;\n\t\t\t}\n\n\t\t\tlabel = escapeTerminalCompletionLabel(label, shellType, resourceOptions.pathSeparator);\n\n\t\t\tif (child.isFile && globPattern) {\n\t\t\t\tconst filePath = child.resource.fsPath;\n\t\t\t\tconst ignoreCase = !this._fileService.hasCapability(child.resource, FileSystemProviderCapabilities.PathCaseSensitive);\n\t\t\t\tconst matches = match(globPattern, filePath, { ignoreCase });\n\t\t\t\tif (!matches) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Try to resolve symlink target for symbolic links\n\t\t\tif (child.isSymbolicLink) {\n\t\t\t\ttry {\n\t\t\t\t\tconst realpath = await this._fileService.realpath(child.resource);\n\t\t\t\t\tif (realpath && !isEqual(child.resource, realpath)) {\n\t\t\t\t\t\tdetail = `${getFriendlyPath(this._labelService, child.resource, resourceOptions.pathSeparator, kind, shellType)} -> ${getFriendlyPath(this._labelService, realpath, resourceOptions.pathSeparator, kind, shellType)}`;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Ignore errors resolving symlink targets - they may be dangling links\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresourceCompletions.push({\n\t\t\t\tlabel,\n\t\t\t\tprovider,\n\t\t\t\tkind,\n\t\t\t\tdetail: detail ?? getFriendlyPath(this._labelService, child.resource, resourceOptions.pathSeparator, kind, shellType),\n\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t});\n\t\t})()));\n\n\t\t// Support $CDPATH specially for the `cd` command only\n\t\t//\n\t\t// - (relative) `|` -> `/foo/vscode` (CDPATH has /foo which contains vscode folder)\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources CDPATH`);\n\t\tif (type === 'relative' && showDirectories) {\n\t\t\tif (promptValue.startsWith('cd ')) {\n\t\t\t\tconst config = this._configurationService.getValue(TerminalSuggestSettingId.CdPath);\n\t\t\t\tif (config === 'absolute' || config === 'relative') {\n\t\t\t\t\tconst cdPath = this._getEnvVar('CDPATH', capabilities);\n\t\t\t\t\tif (cdPath) {\n\t\t\t\t\t\tconst cdPathEntries = cdPath.split(useWindowsStylePath ? ';' : ':');\n\t\t\t\t\t\tfor (const cdPathEntry of cdPathEntries) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconst fileStat = await this._fileService.resolve(URI.file(cdPathEntry), { resolveSingleChildDescendants: true });\n\t\t\t\t\t\t\t\tif (fileStat?.children) {\n\t\t\t\t\t\t\t\t\tfor (const child of fileStat.children) {\n\t\t\t\t\t\t\t\t\t\tif (!child.isDirectory) {\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst useRelative = config === 'relative';\n\t\t\t\t\t\t\t\t\t\tconst kind = TerminalCompletionItemKind.Folder;\n\t\t\t\t\t\t\t\t\t\tconst label = useRelative\n\t\t\t\t\t\t\t\t\t\t\t? basename(child.resource.fsPath)\n\t\t\t\t\t\t\t\t\t\t\t: shellType === WindowsShellType.GitBash\n\t\t\t\t\t\t\t\t\t\t\t\t? windowsToGitBashPath(child.resource.fsPath)\n\t\t\t\t\t\t\t\t\t\t\t\t: getFriendlyPath(this._labelService, child.resource, resourceOptions.pathSeparator, kind, shellType);\n\t\t\t\t\t\t\t\t\t\tconst detail = useRelative\n\t\t\t\t\t\t\t\t\t\t\t? `CDPATH ${getFriendlyPath(this._labelService, child.resource, resourceOptions.pathSeparator, kind, shellType)}`\n\t\t\t\t\t\t\t\t\t\t\t: `CDPATH`;\n\t\t\t\t\t\t\t\t\t\tresourceCompletions.push({\n\t\t\t\t\t\t\t\t\t\t\tlabel,\n\t\t\t\t\t\t\t\t\t\t\tprovider,\n\t\t\t\t\t\t\t\t\t\t\tkind,\n\t\t\t\t\t\t\t\t\t\t\tdetail,\n\t\t\t\t\t\t\t\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch { /* ignore */ }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add parent directory to the bottom of the list because it's not as useful as other suggestions\n\t\t//\n\t\t// - (relative) `|` -> `../`\n\t\t// - (relative) `./src/|` -> `./src/../`\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources parent dir`);\n\t\tif (type === 'relative' && showDirectories) {\n\t\t\tlet label = `..${resourceOptions.pathSeparator}`;\n\t\t\tif (lastWordFolder.length > 0) {\n\t\t\t\tlabel = addPathRelativePrefix(lastWordFolder + label, resourceOptions, lastWordFolderHasDotPrefix);\n\t\t\t}\n\t\t\tconst parentDir = URI.joinPath(cwd, '..' + resourceOptions.pathSeparator);\n\t\t\tresourceCompletions.push({\n\t\t\t\tlabel,\n\t\t\t\tprovider,\n\t\t\t\tkind: TerminalCompletionItemKind.Folder,\n\t\t\t\tdetail: getFriendlyPath(this._labelService, parentDir, resourceOptions.pathSeparator, TerminalCompletionItemKind.Folder, shellType),\n\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t});\n\t\t}\n\n\t\t// Add tilde for home directory for relative paths when there is no path separator in the\n\t\t// input.\n\t\t//\n\t\t// - (relative) `|` -> `~`\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources tilde`);\n\t\tif (type === 'relative' && !lastWordFolder.match(/[\\\\\\/]/)) {\n\t\t\tlet homeResource: URI | string | undefined;\n\t\t\tconst home = this._getHomeDir(useWindowsStylePath, capabilities);\n\t\t\tif (home) {\n\t\t\t\thomeResource = URI.joinPath(URI.file(home), lastWordFolder.slice(1).replaceAll('\\\\ ', ' '));\n\t\t\t}\n\t\t\tif (!homeResource) {\n\t\t\t\t// Use less strong wording here as it's not as strong of a concept on Windows\n\t\t\t\t// and could be misleading\n\t\t\t\thomeResource = useWindowsStylePath ? 'Home directory' : '$HOME';\n\t\t\t}\n\t\t\tresourceCompletions.push({\n\t\t\t\tlabel: '~',\n\t\t\t\tprovider,\n\t\t\t\tkind: TerminalCompletionItemKind.Folder,\n\t\t\t\tdetail: isString(homeResource) ? homeResource : getFriendlyPath(this._labelService, homeResource, resourceOptions.pathSeparator, TerminalCompletionItemKind.Folder, shellType),\n\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t});\n\t\t}\n\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources done`);\n\t\treturn resourceCompletions;\n\t}\n\n\tprivate _getEnvVar(key: string, capabilities: ITerminalCapabilityStore): string | undefined {\n\t\tconst env = capabilities.get(TerminalCapability.ShellEnvDetection)?.env?.value as { [key: string]: string | undefined };\n\t\tif (env) {\n\t\t\treturn env[key];\n\t\t}\n\t\treturn this._processEnv[key];\n\t}\n\n\tprivate _getHomeDir(useWindowsStylePath: boolean, capabilities: ITerminalCapabilityStore): string | undefined {\n\t\treturn useWindowsStylePath ? this._getEnvVar('USERPROFILE', capabilities) : this._getEnvVar('HOME', capabilities);\n\t}\n}\n\nfunction getFriendlyPath(labelService: ILabelService, uri: URI, pathSeparator: string, kind: TerminalCompletionItemKind, shellType?: TerminalShellType): string {\n\tlet path = labelService.getUriLabel(uri, { noPrefix: true });\n\t// Normalize line endings for folders\n\tconst sep = shellType === WindowsShellType.GitBash ? '\\\\' : pathSeparator;\n\tif (kind === TerminalCompletionItemKind.Folder && !path.endsWith(sep)) {\n\t\tpath += sep;\n\t}\n\treturn path;\n}\n\n/**\n * Normalize suggestion to add a ./ prefix to the start of the path if there isn't one already. We\n * may want to change this behavior in the future to go with whatever format the user has.\n */\nfunction addPathRelativePrefix(text: string, resourceOptions: Pick<TerminalCompletionResourceOptions, 'pathSeparator'>, lastWordFolderHasDotPrefix: boolean): string {\n\tif (!lastWordFolderHasDotPrefix) {\n\t\tif (text.startsWith(resourceOptions.pathSeparator)) {\n\t\t\treturn `.${text}`;\n\t\t}\n\t\treturn `.${resourceOptions.pathSeparator}${text}`;\n\t}\n\treturn text;\n}\n\n/**\n * Escapes special characters in a file/folder label for shell completion.\n * This ensures that characters like [, ], etc. are properly escaped.\n */\nexport function escapeTerminalCompletionLabel(label: string, shellType: TerminalShellType | undefined, pathSeparator: string): string {\n\t// Only escape for bash/zsh/fish; PowerShell and cmd have different rules\n\tif (shellType === undefined || shellType === GeneralShellType.PowerShell || shellType === WindowsShellType.CommandPrompt) {\n\t\treturn label;\n\t}\n\treturn label.replace(/[\\[\\]\\(\\)'\"\\\\\\`\\*\\?;|&<>]/g, '\\\\$&');\n}\n\nfunction getIsAbsolutePath(shellType: TerminalShellType | undefined, pathSeparator: string, lastWord: string, useWindowsStylePath: boolean): boolean {\n\tif (shellType === WindowsShellType.GitBash) {\n\t\treturn lastWord.startsWith(pathSeparator) || /^[a-zA-Z]:\\//.test(lastWord);\n\t}\n\treturn useWindowsStylePath ? /^[a-zA-Z]:[\\\\\\/]/.test(lastWord) : lastWord.startsWith(pathSeparator);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { basename } from '../../../../../base/common/path.js';\nimport { URI, UriComponents } from '../../../../../base/common/uri.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { FileSystemProviderCapabilities, IFileService } from '../../../../../platform/files/common/files.js';\nimport { createDecorator } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { TerminalCapability, type ITerminalCapabilityStore } from '../../../../../platform/terminal/common/capabilities/capabilities.js';\nimport { GeneralShellType, ITerminalLogService, TerminalShellType, WindowsShellType } from '../../../../../platform/terminal/common/terminal.js';\nimport { TerminalSuggestSettingId } from '../common/terminalSuggestConfiguration.js';\nimport { TerminalCompletionItemKind, type ITerminalCompletion } from './terminalCompletionItem.js';\nimport { env as processEnv } from '../../../../../base/common/process.js';\nimport type { IProcessEnvironment } from '../../../../../base/common/platform.js';\nimport { timeout } from '../../../../../base/common/async.js';\nimport { gitBashToWindowsPath, windowsToGitBashPath } from './terminalGitBashHelpers.js';\nimport { isEqual } from '../../../../../base/common/resources.js';\nimport { ILabelService } from '../../../../../platform/label/common/label.js';\nimport { IRelativePattern, match } from '../../../../../base/common/glob.js';\nimport { isString } from '../../../../../base/common/types.js';\n\nexport const ITerminalCompletionService = createDecorator<ITerminalCompletionService>('terminalCompletionService');\n\n/**\n * Represents a collection of {@link CompletionItem completion items} to be presented\n * in the terminal.\n */\nexport class TerminalCompletionList<ITerminalCompletion> {\n\n\t/**\n\t * Resources should be shown in the completions list\n\t */\n\tresourceOptions?: TerminalCompletionResourceOptions;\n\n\t/**\n\t * The completion items.\n\t */\n\titems?: ITerminalCompletion[];\n\n\t/**\n\t * Creates a new completion list.\n\t *\n\t * @param items The completion items.\n\t * @param isIncomplete The list is not complete.\n\t */\n\tconstructor(items?: ITerminalCompletion[], resourceOptions?: TerminalCompletionResourceOptions) {\n\t\tthis.items = items;\n\t\tthis.resourceOptions = resourceOptions;\n\t}\n}\n\nexport interface TerminalCompletionResourceOptions {\n\tshowFiles?: boolean;\n\tshowDirectories?: boolean;\n\tglobPattern?: string | IRelativePattern;\n\tcwd: UriComponents;\n\tpathSeparator: string;\n}\n\n\nexport interface ITerminalCompletionProvider {\n\tid: string;\n\tshellTypes?: TerminalShellType[];\n\tprovideCompletions(value: string, cursorPosition: number, token: CancellationToken): Promise<ITerminalCompletion[] | TerminalCompletionList<ITerminalCompletion> | undefined>;\n\ttriggerCharacters?: string[];\n\tisBuiltin?: boolean;\n}\n\nexport interface ITerminalCompletionService {\n\t_serviceBrand: undefined;\n\treadonly providers: IterableIterator<ITerminalCompletionProvider>;\n\treadonly onDidChangeProviders: Event<void>;\n\tregisterTerminalCompletionProvider(extensionIdentifier: string, id: string, provider: ITerminalCompletionProvider, ...triggerCharacters: string[]): IDisposable;\n\tprovideCompletions(promptValue: string, cursorPosition: number, allowFallbackCompletions: boolean, shellType: TerminalShellType | undefined, capabilities: ITerminalCapabilityStore, token: CancellationToken, triggerCharacter?: boolean, skipExtensionCompletions?: boolean, explicitlyInvoked?: boolean): Promise<ITerminalCompletion[] | undefined>;\n}\n\nexport class TerminalCompletionService extends Disposable implements ITerminalCompletionService {\n\tdeclare _serviceBrand: undefined;\n\tprivate readonly _providers: Map</*ext id*/string, Map</*provider id*/string, ITerminalCompletionProvider>> = new Map();\n\n\tprivate readonly _onDidChangeProviders = this._register(new Emitter<void>());\n\treadonly onDidChangeProviders = this._onDidChangeProviders.event;\n\n\tget providers(): IterableIterator<ITerminalCompletionProvider> {\n\t\treturn this._providersGenerator();\n\t}\n\n\tprivate *_providersGenerator(): IterableIterator<ITerminalCompletionProvider> {\n\t\tfor (const providerMap of this._providers.values()) {\n\t\t\tfor (const provider of providerMap.values()) {\n\t\t\t\tyield provider;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Overrides the environment for testing purposes. */\n\tset processEnv(env: IProcessEnvironment) { this._processEnv = env; }\n\tprivate _processEnv = processEnv;\n\n\tconstructor(\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@ILabelService private readonly _labelService: ILabelService,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService\n\t) {\n\t\tsuper();\n\t}\n\n\tregisterTerminalCompletionProvider(extensionIdentifier: string, id: string, provider: ITerminalCompletionProvider, ...triggerCharacters: string[]): IDisposable {\n\t\tlet extMap = this._providers.get(extensionIdentifier);\n\t\tif (!extMap) {\n\t\t\textMap = new Map();\n\t\t\tthis._providers.set(extensionIdentifier, extMap);\n\t\t}\n\t\tprovider.triggerCharacters = triggerCharacters;\n\t\tprovider.id = id;\n\t\textMap.set(id, provider);\n\t\tthis._onDidChangeProviders.fire();\n\t\treturn toDisposable(() => {\n\t\t\tconst extMap = this._providers.get(extensionIdentifier);\n\t\t\tif (extMap) {\n\t\t\t\textMap.delete(id);\n\t\t\t\tif (extMap.size === 0) {\n\t\t\t\t\tthis._providers.delete(extensionIdentifier);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._onDidChangeProviders.fire();\n\t\t});\n\t}\n\n\tasync provideCompletions(promptValue: string, cursorPosition: number, allowFallbackCompletions: boolean, shellType: TerminalShellType | undefined, capabilities: ITerminalCapabilityStore, token: CancellationToken, triggerCharacter?: boolean, skipExtensionCompletions?: boolean, explicitlyInvoked?: boolean): Promise<ITerminalCompletion[] | undefined> {\n\t\tthis._logService.trace('TerminalCompletionService#provideCompletions');\n\t\tif (!this._providers || !this._providers.values || cursorPosition < 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet providers;\n\t\tif (triggerCharacter) {\n\t\t\tconst providersToRequest: ITerminalCompletionProvider[] = [];\n\t\t\tfor (const provider of this.providers) {\n\t\t\t\tif (!provider.triggerCharacters) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (const char of provider.triggerCharacters) {\n\t\t\t\t\tif (promptValue.substring(0, cursorPosition)?.endsWith(char)) {\n\t\t\t\t\t\tprovidersToRequest.push(provider);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tproviders = providersToRequest;\n\t\t} else {\n\t\t\tproviders = [...this._providers.values()].flatMap(providerMap => [...providerMap.values()]);\n\t\t}\n\n\t\tif (skipExtensionCompletions) {\n\t\t\tproviders = providers.filter(p => p.isBuiltin);\n\t\t\treturn this._collectCompletions(providers, shellType, promptValue, cursorPosition, allowFallbackCompletions, capabilities, token, explicitlyInvoked);\n\t\t}\n\n\t\tproviders = this._getEnabledProviders(providers);\n\n\t\tif (!providers.length) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this._collectCompletions(providers, shellType, promptValue, cursorPosition, allowFallbackCompletions, capabilities, token, explicitlyInvoked);\n\t}\n\n\tprotected _getEnabledProviders(providers: ITerminalCompletionProvider[]): ITerminalCompletionProvider[] {\n\t\tconst providerConfig: { [key: string]: boolean } = this._configurationService.getValue(TerminalSuggestSettingId.Providers);\n\t\treturn providers.filter(p => {\n\t\t\tconst providerId = p.id;\n\t\t\treturn providerId && (!Object.prototype.hasOwnProperty.call(providerConfig, providerId) || providerConfig[providerId] !== false);\n\t\t});\n\t}\n\n\tprivate async _collectCompletions(providers: ITerminalCompletionProvider[], shellType: TerminalShellType | undefined, promptValue: string, cursorPosition: number, allowFallbackCompletions: boolean, capabilities: ITerminalCapabilityStore, token: CancellationToken, explicitlyInvoked?: boolean): Promise<ITerminalCompletion[] | undefined> {\n\t\tthis._logService.trace('TerminalCompletionService#_collectCompletions');\n\t\tconst completionPromises = providers.map(async provider => {\n\t\t\tif (provider.shellTypes && shellType && !provider.shellTypes.includes(shellType)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst timeoutMs = explicitlyInvoked ? 30000 : 5000;\n\t\t\tlet timedOut = false;\n\t\t\tlet completions;\n\t\t\ttry {\n\t\t\t\tcompletions = await Promise.race([\n\t\t\t\t\tprovider.provideCompletions(promptValue, cursorPosition, token).then(result => {\n\t\t\t\t\t\tthis._logService.trace(`TerminalCompletionService#_collectCompletions provider ${provider.id} finished`);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}),\n\t\t\t\t\t(async () => { await timeout(timeoutMs); timedOut = true; return undefined; })()\n\t\t\t\t]);\n\t\t\t} catch (e) {\n\t\t\t\tthis._logService.trace(`[TerminalCompletionService] Exception from provider '${provider.id}':`, e);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (timedOut) {\n\t\t\t\tthis._logService.trace(`[TerminalCompletionService] Provider '${provider.id}' timed out after ${timeoutMs}ms. promptValue='${promptValue}', cursorPosition=${cursorPosition}, explicitlyInvoked=${explicitlyInvoked}`);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (!completions) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst completionItems = Array.isArray(completions) ? completions : completions.items ?? [];\n\t\t\tthis._logService.trace(`TerminalCompletionService#_collectCompletions amend ${completionItems.length} completion items`);\n\t\t\tif (shellType === GeneralShellType.PowerShell) {\n\t\t\t\tfor (const completion of completionItems) {\n\t\t\t\t\tconst start = completion.replacementRange ? completion.replacementRange[0] : 0;\n\t\t\t\t\tcompletion.isFileOverride ??= completion.kind === TerminalCompletionItemKind.Method && start === 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (provider.isBuiltin) {\n\t\t\t\t//TODO: why is this needed?\n\t\t\t\tfor (const item of completionItems) {\n\t\t\t\t\titem.provider ??= provider.id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Array.isArray(completions)) {\n\t\t\t\treturn completionItems;\n\t\t\t}\n\t\t\tif (completions.resourceOptions) {\n\t\t\t\tconst resourceCompletions = await this.resolveResources(completions.resourceOptions, promptValue, cursorPosition, `core:path:ext:${provider.id}`, capabilities, shellType);\n\t\t\t\tthis._logService.trace(`TerminalCompletionService#_collectCompletions dedupe`);\n\t\t\t\tif (resourceCompletions) {\n\t\t\t\t\tconst labels = new Set(completionItems.map(c => c.label));\n\t\t\t\t\tfor (const item of resourceCompletions) {\n\t\t\t\t\t\t// Ensure no duplicates such as .\n\t\t\t\t\t\tif (!labels.has(item.label)) {\n\t\t\t\t\t\t\tcompletionItems.push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._logService.trace(`TerminalCompletionService#_collectCompletions dedupe done`);\n\t\t\t}\n\t\t\treturn completionItems;\n\t\t});\n\n\t\tconst results = await Promise.all(completionPromises);\n\t\tthis._logService.trace('TerminalCompletionService#_collectCompletions done');\n\t\treturn results.filter(result => !!result).flat();\n\t}\n\n\tasync resolveResources(resourceOptions: TerminalCompletionResourceOptions, promptValue: string, cursorPosition: number, provider: string, capabilities: ITerminalCapabilityStore, shellType?: TerminalShellType): Promise<ITerminalCompletion[] | undefined> {\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources`);\n\n\t\tconst useWindowsStylePath = resourceOptions.pathSeparator === '\\\\';\n\t\tif (useWindowsStylePath) {\n\t\t\t// for tests, make sure the right path separator is used\n\t\t\tpromptValue = promptValue.replaceAll(/[\\\\/]/g, resourceOptions.pathSeparator);\n\t\t}\n\n\t\t// Files requested implies folders requested since the file could be in any folder. We could\n\t\t// provide diagnostics when a folder is provided where a file is expected.\n\t\tconst showDirectories = (resourceOptions.showDirectories || resourceOptions.showFiles) ?? false;\n\t\tconst showFiles = resourceOptions.showFiles ?? false;\n\t\tconst globPattern = resourceOptions.globPattern ?? undefined;\n\n\t\tif (!showDirectories && !showFiles) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst resourceCompletions: ITerminalCompletion[] = [];\n\t\tconst cursorPrefix = promptValue.substring(0, cursorPosition);\n\n\t\t// TODO: Leverage Fig's tokens array here?\n\t\t// The last word (or argument). When the cursor is following a space it will be the empty\n\t\t// string\n\t\tlet lastWord = cursorPrefix.endsWith(' ') ? '' : cursorPrefix.split(/(?<!\\\\) /).at(-1) ?? '';\n\n\t\t// Ignore prefixes in the word that look like setting an environment variable\n\t\tconst matchEnvVarPrefix = lastWord.match(/^[a-zA-Z_]+=(?<rhs>.+)$/);\n\t\tif (matchEnvVarPrefix?.groups?.rhs) {\n\t\t\tlastWord = matchEnvVarPrefix.groups.rhs;\n\t\t}\n\n\t\t// Get the nearest folder path from the prefix. This ignores everything after the `/` as\n\t\t// they are what triggers changes in the directory.\n\t\tlet lastSlashIndex: number;\n\t\tif (useWindowsStylePath) {\n\t\t\t// TODO: Flesh out escaped path logic, it currently only partially works\n\t\t\tlet lastBackslashIndex = -1;\n\t\t\tfor (let i = lastWord.length - 1; i >= 0; i--) {\n\t\t\t\tif (lastWord[i] === '\\\\') {\n\t\t\t\t\tif (i === lastWord.length - 1 || lastWord[i + 1] !== ' ') {\n\t\t\t\t\t\tlastBackslashIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastSlashIndex = Math.max(lastBackslashIndex, lastWord.lastIndexOf('/'));\n\t\t} else {\n\t\t\tlastSlashIndex = lastWord.lastIndexOf(resourceOptions.pathSeparator);\n\t\t}\n\n\t\t// The _complete_ folder of the last word. For example if the last word is `./src/file`,\n\t\t// this will be `./src/`. This also always ends in the path separator if it is not the empty\n\t\t// string and path separators are normalized on Windows.\n\t\tlet lastWordFolder = lastSlashIndex === -1 ? '' : lastWord.slice(0, lastSlashIndex + 1);\n\t\tif (useWindowsStylePath) {\n\t\t\tlastWordFolder = lastWordFolder.replaceAll('/', '\\\\');\n\t\t}\n\n\n\t\t// Determine the current folder being shown\n\t\tlet lastWordFolderResource: URI | string | undefined;\n\t\tconst lastWordFolderHasDotPrefix = !!lastWordFolder.match(/^\\.\\.?[\\\\\\/]/);\n\t\tconst lastWordFolderHasTildePrefix = !!lastWordFolder.match(/^~[\\\\\\/]?/);\n\t\tconst isAbsolutePath = getIsAbsolutePath(shellType, resourceOptions.pathSeparator, lastWordFolder, useWindowsStylePath);\n\t\tconst type = lastWordFolderHasTildePrefix ? 'tilde' : isAbsolutePath ? 'absolute' : 'relative';\n\t\tconst cwd = URI.revive(resourceOptions.cwd);\n\n\t\tswitch (type) {\n\t\t\tcase 'tilde': {\n\t\t\t\tconst home = this._getHomeDir(useWindowsStylePath, capabilities);\n\t\t\t\tif (home) {\n\t\t\t\t\tlastWordFolderResource = URI.joinPath(URI.file(home), lastWordFolder.slice(1).replaceAll('\\\\ ', ' '));\n\t\t\t\t}\n\t\t\t\tif (!lastWordFolderResource) {\n\t\t\t\t\t// Use less strong wording here as it's not as strong of a concept on Windows\n\t\t\t\t\t// and could be misleading\n\t\t\t\t\tif (lastWord.match(/^~[\\\\\\/]$/)) {\n\t\t\t\t\t\tlastWordFolderResource = useWindowsStylePath ? 'Home directory' : '$HOME';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'absolute': {\n\t\t\t\tif (shellType === WindowsShellType.GitBash) {\n\t\t\t\t\tlastWordFolderResource = URI.file(gitBashToWindowsPath(lastWordFolder, this._processEnv.SystemDrive));\n\t\t\t\t} else {\n\t\t\t\t\tlastWordFolderResource = URI.file(lastWordFolder.replaceAll('\\\\ ', ' '));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'relative': {\n\t\t\t\tlastWordFolderResource = cwd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Assemble completions based on the resource of lastWordFolder. Note that on Windows the\n\t\t// path separators are normalized to `\\`.\n\t\tif (!lastWordFolderResource) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Early exit with basic completion if we don't know the resource\n\t\tif (isString(lastWordFolderResource)) {\n\t\t\tresourceCompletions.push({\n\t\t\t\tlabel: lastWordFolder,\n\t\t\t\tprovider,\n\t\t\t\tkind: TerminalCompletionItemKind.Folder,\n\t\t\t\tdetail: lastWordFolderResource,\n\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t});\n\t\t\treturn resourceCompletions;\n\t\t}\n\n\t\tconst stat = await this._fileService.resolve(lastWordFolderResource, { resolveSingleChildDescendants: true });\n\t\tif (!stat?.children) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Add current directory. This should be shown at the top because it will be an exact\n\t\t// match and therefore highlight the detail, plus it improves the experience when\n\t\t// runOnEnter is used.\n\t\t//\n\t\t// - (relative) `|`       -> `.`\n\t\t//   this does not have the trailing `/` intentionally as it's common to complete the\n\t\t//   current working directory and we do not want to complete `./` when `runOnEnter` is\n\t\t//   used.\n\t\t// - (relative) `./src/|` -> `./src/`\n\t\t// - (absolute) `/src/|`  -> `/src/`\n\t\t// - (tilde)    `~/|`     -> `~/`\n\t\t// - (tilde)    `~/src/|` -> `~/src/`\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources cwd`);\n\t\tif (showDirectories) {\n\t\t\tlet label: string;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'tilde': {\n\t\t\t\t\tlabel = lastWordFolder;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'absolute': {\n\t\t\t\t\tlabel = lastWordFolder;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'relative': {\n\t\t\t\t\tlabel = '.';\n\t\t\t\t\tif (lastWordFolder.length > 0) {\n\t\t\t\t\t\tlabel = addPathRelativePrefix(lastWordFolder, resourceOptions, lastWordFolderHasDotPrefix);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresourceCompletions.push({\n\t\t\t\tlabel,\n\t\t\t\tprovider,\n\t\t\t\tkind: TerminalCompletionItemKind.Folder,\n\t\t\t\tdetail: getFriendlyPath(this._labelService, lastWordFolderResource, resourceOptions.pathSeparator, TerminalCompletionItemKind.Folder, shellType),\n\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t});\n\t\t}\n\n\t\t// Add all direct children files or folders\n\t\t//\n\t\t// - (relative) `cd ./src/`  -> `cd ./src/folder1/`, ...\n\t\t// - (absolute) `cd c:/src/` -> `cd c:/src/folder1/`, ...\n\t\t// - (tilde)    `cd ~/src/`  -> `cd ~/src/folder1/`, ...\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources direct children`);\n\t\tawait Promise.all(stat.children.map(child => (async () => {\n\t\t\tlet kind: TerminalCompletionItemKind | undefined;\n\t\t\tlet detail: string | undefined = undefined;\n\t\t\tif (showDirectories && child.isDirectory) {\n\t\t\t\tif (child.isSymbolicLink) {\n\t\t\t\t\tkind = TerminalCompletionItemKind.SymbolicLinkFolder;\n\t\t\t\t} else {\n\t\t\t\t\tkind = TerminalCompletionItemKind.Folder;\n\t\t\t\t}\n\t\t\t} else if (showFiles && child.isFile) {\n\t\t\t\tif (child.isSymbolicLink) {\n\t\t\t\t\tkind = TerminalCompletionItemKind.SymbolicLinkFile;\n\t\t\t\t} else {\n\t\t\t\t\tkind = TerminalCompletionItemKind.File;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (kind === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet label = lastWordFolder;\n\t\t\tif (label.length > 0 && !label.endsWith(resourceOptions.pathSeparator)) {\n\t\t\t\tlabel += resourceOptions.pathSeparator;\n\t\t\t}\n\t\t\tlabel += child.name;\n\t\t\tif (type === 'relative') {\n\t\t\t\tlabel = addPathRelativePrefix(label, resourceOptions, lastWordFolderHasDotPrefix);\n\t\t\t}\n\t\t\tif (child.isDirectory && !label.endsWith(resourceOptions.pathSeparator)) {\n\t\t\t\tlabel += resourceOptions.pathSeparator;\n\t\t\t}\n\n\t\t\tlabel = escapeTerminalCompletionLabel(label, shellType, resourceOptions.pathSeparator);\n\n\t\t\tif (child.isFile && globPattern) {\n\t\t\t\tconst filePath = child.resource.fsPath;\n\t\t\t\tconst ignoreCase = !this._fileService.hasCapability(child.resource, FileSystemProviderCapabilities.PathCaseSensitive);\n\t\t\t\tconst matches = match(globPattern, filePath, { ignoreCase });\n\t\t\t\tif (!matches) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Try to resolve symlink target for symbolic links\n\t\t\tif (child.isSymbolicLink) {\n\t\t\t\ttry {\n\t\t\t\t\tconst realpath = await this._fileService.realpath(child.resource);\n\t\t\t\t\tif (realpath && !isEqual(child.resource, realpath)) {\n\t\t\t\t\t\tdetail = `${getFriendlyPath(this._labelService, child.resource, resourceOptions.pathSeparator, kind, shellType)} -> ${getFriendlyPath(this._labelService, realpath, resourceOptions.pathSeparator, kind, shellType)}`;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Ignore errors resolving symlink targets - they may be dangling links\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresourceCompletions.push({\n\t\t\t\tlabel,\n\t\t\t\tprovider,\n\t\t\t\tkind,\n\t\t\t\tdetail: detail ?? getFriendlyPath(this._labelService, child.resource, resourceOptions.pathSeparator, kind, shellType),\n\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t});\n\t\t})()));\n\n\t\t// Support $CDPATH specially for the `cd` command only\n\t\t//\n\t\t// - (relative) `|` -> `/foo/vscode` (CDPATH has /foo which contains vscode folder)\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources CDPATH`);\n\t\tif (type === 'relative' && showDirectories) {\n\t\t\tif (promptValue.startsWith('cd ')) {\n\t\t\t\tconst config = this._configurationService.getValue(TerminalSuggestSettingId.CdPath);\n\t\t\t\tif (config === 'absolute' || config === 'relative') {\n\t\t\t\t\tconst cdPath = this._getEnvVar('CDPATH', capabilities);\n\t\t\t\t\tif (cdPath) {\n\t\t\t\t\t\tconst cdPathEntries = cdPath.split(useWindowsStylePath ? ';' : ':');\n\t\t\t\t\t\tfor (const cdPathEntry of cdPathEntries) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconst fileStat = await this._fileService.resolve(URI.file(cdPathEntry), { resolveSingleChildDescendants: true });\n\t\t\t\t\t\t\t\tif (fileStat?.children) {\n\t\t\t\t\t\t\t\t\tfor (const child of fileStat.children) {\n\t\t\t\t\t\t\t\t\t\tif (!child.isDirectory) {\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst useRelative = config === 'relative';\n\t\t\t\t\t\t\t\t\t\tconst kind = TerminalCompletionItemKind.Folder;\n\t\t\t\t\t\t\t\t\t\tconst label = useRelative\n\t\t\t\t\t\t\t\t\t\t\t? basename(child.resource.fsPath)\n\t\t\t\t\t\t\t\t\t\t\t: shellType === WindowsShellType.GitBash\n\t\t\t\t\t\t\t\t\t\t\t\t? windowsToGitBashPath(child.resource.fsPath)\n\t\t\t\t\t\t\t\t\t\t\t\t: getFriendlyPath(this._labelService, child.resource, resourceOptions.pathSeparator, kind, shellType);\n\t\t\t\t\t\t\t\t\t\tconst detail = useRelative\n\t\t\t\t\t\t\t\t\t\t\t? `CDPATH ${getFriendlyPath(this._labelService, child.resource, resourceOptions.pathSeparator, kind, shellType)}`\n\t\t\t\t\t\t\t\t\t\t\t: `CDPATH`;\n\t\t\t\t\t\t\t\t\t\tresourceCompletions.push({\n\t\t\t\t\t\t\t\t\t\t\tlabel,\n\t\t\t\t\t\t\t\t\t\t\tprovider,\n\t\t\t\t\t\t\t\t\t\t\tkind,\n\t\t\t\t\t\t\t\t\t\t\tdetail,\n\t\t\t\t\t\t\t\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch { /* ignore */ }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add parent directory to the bottom of the list because it's not as useful as other suggestions\n\t\t//\n\t\t// - (relative) `|` -> `../`\n\t\t// - (relative) `./src/|` -> `./src/../`\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources parent dir`);\n\t\tif (type === 'relative' && showDirectories) {\n\t\t\tlet label = `..${resourceOptions.pathSeparator}`;\n\t\t\tif (lastWordFolder.length > 0) {\n\t\t\t\tlabel = addPathRelativePrefix(lastWordFolder + label, resourceOptions, lastWordFolderHasDotPrefix);\n\t\t\t}\n\t\t\tconst parentDir = URI.joinPath(cwd, '..' + resourceOptions.pathSeparator);\n\t\t\tresourceCompletions.push({\n\t\t\t\tlabel,\n\t\t\t\tprovider,\n\t\t\t\tkind: TerminalCompletionItemKind.Folder,\n\t\t\t\tdetail: getFriendlyPath(this._labelService, parentDir, resourceOptions.pathSeparator, TerminalCompletionItemKind.Folder, shellType),\n\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t});\n\t\t}\n\n\t\t// Add tilde for home directory for relative paths when there is no path separator in the\n\t\t// input.\n\t\t//\n\t\t// - (relative) `|` -> `~`\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources tilde`);\n\t\tif (type === 'relative' && !lastWordFolder.match(/[\\\\\\/]/)) {\n\t\t\tlet homeResource: URI | string | undefined;\n\t\t\tconst home = this._getHomeDir(useWindowsStylePath, capabilities);\n\t\t\tif (home) {\n\t\t\t\thomeResource = URI.joinPath(URI.file(home), lastWordFolder.slice(1).replaceAll('\\\\ ', ' '));\n\t\t\t}\n\t\t\tif (!homeResource) {\n\t\t\t\t// Use less strong wording here as it's not as strong of a concept on Windows\n\t\t\t\t// and could be misleading\n\t\t\t\thomeResource = useWindowsStylePath ? 'Home directory' : '$HOME';\n\t\t\t}\n\t\t\tresourceCompletions.push({\n\t\t\t\tlabel: '~',\n\t\t\t\tprovider,\n\t\t\t\tkind: TerminalCompletionItemKind.Folder,\n\t\t\t\tdetail: isString(homeResource) ? homeResource : getFriendlyPath(this._labelService, homeResource, resourceOptions.pathSeparator, TerminalCompletionItemKind.Folder, shellType),\n\t\t\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition]\n\t\t\t});\n\t\t}\n\n\t\tthis._logService.trace(`TerminalCompletionService#resolveResources done`);\n\t\treturn resourceCompletions;\n\t}\n\n\tprivate _getEnvVar(key: string, capabilities: ITerminalCapabilityStore): string | undefined {\n\t\tconst env = capabilities.get(TerminalCapability.ShellEnvDetection)?.env?.value as { [key: string]: string | undefined };\n\t\tif (env) {\n\t\t\treturn env[key];\n\t\t}\n\t\treturn this._processEnv[key];\n\t}\n\n\tprivate _getHomeDir(useWindowsStylePath: boolean, capabilities: ITerminalCapabilityStore): string | undefined {\n\t\treturn useWindowsStylePath ? this._getEnvVar('USERPROFILE', capabilities) : this._getEnvVar('HOME', capabilities);\n\t}\n}\n\nfunction getFriendlyPath(labelService: ILabelService, uri: URI, pathSeparator: string, kind: TerminalCompletionItemKind, shellType?: TerminalShellType): string {\n\tlet path = labelService.getUriLabel(uri, { noPrefix: true });\n\t// Normalize line endings for folders\n\tconst sep = shellType === WindowsShellType.GitBash ? '\\\\' : pathSeparator;\n\tif (kind === TerminalCompletionItemKind.Folder && !path.endsWith(sep)) {\n\t\tpath += sep;\n\t}\n\treturn path;\n}\n\n/**\n * Normalize suggestion to add a ./ prefix to the start of the path if there isn't one already. We\n * may want to change this behavior in the future to go with whatever format the user has.\n */\nfunction addPathRelativePrefix(text: string, resourceOptions: Pick<TerminalCompletionResourceOptions, 'pathSeparator'>, lastWordFolderHasDotPrefix: boolean): string {\n\tif (!lastWordFolderHasDotPrefix) {\n\t\tif (text.startsWith(resourceOptions.pathSeparator)) {\n\t\t\treturn `.${text}`;\n\t\t}\n\t\treturn `.${resourceOptions.pathSeparator}${text}`;\n\t}\n\treturn text;\n}\n\n/**\n * Escapes special characters in a file/folder label for shell completion.\n * This ensures that characters like [, ], etc. are properly escaped.\n */\nexport function escapeTerminalCompletionLabel(label: string, shellType: TerminalShellType | undefined, pathSeparator: string): string {\n\t// Only escape for bash/zsh/fish; PowerShell and cmd have different rules\n\tif (shellType === undefined || shellType === GeneralShellType.PowerShell || shellType === WindowsShellType.CommandPrompt) {\n\t\treturn label;\n\t}\n\treturn label.replace(/[\\[\\]\\(\\)'\"\\\\\\`\\*\\?;|&<>]/g, '\\\\$&');\n}\n\nfunction getIsAbsolutePath(shellType: TerminalShellType | undefined, pathSeparator: string, lastWord: string, useWindowsStylePath: boolean): boolean {\n\tif (shellType === WindowsShellType.GitBash) {\n\t\treturn lastWord.startsWith(pathSeparator) || /^[a-zA-Z]:\\//.test(lastWord);\n\t}\n\treturn useWindowsStylePath ? /^[a-zA-Z]:[\\\\\\/]/.test(lastWord) : lastWord.startsWith(pathSeparator);\n}\n"]}