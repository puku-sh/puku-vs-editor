{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/terminalContrib/suggest/browser/lspCompletionProviderAddon.ts","vs/workbench/contrib/terminalContrib/suggest/browser/lspCompletionProviderAddon.ts"],"names":[],"mappings":"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","file":"lspCompletionProviderAddon.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { ITerminalAddon, Terminal } from '@xterm/xterm';\nimport { Disposable, IReference } from '../../../../../base/common/lifecycle.js';\nimport { ITerminalCompletionProvider, type TerminalCompletionList } from './terminalCompletionService.js';\nimport type { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { ITerminalCompletion, mapLspKindToTerminalKind, TerminalCompletionItemKind } from './terminalCompletionItem.js';\nimport { IResolvedTextEditorModel } from '../../../../../editor/common/services/resolverService.js';\nimport { Position } from '../../../../../editor/common/core/position.js';\nimport { CompletionItemLabel, CompletionItemProvider, CompletionTriggerKind } from '../../../../../editor/common/languages.js';\nimport { LspTerminalModelContentProvider } from './lspTerminalModelContentProvider.js';\nimport { MarkdownString } from '../../../../../base/common/htmlContent.js';\n\nexport class LspCompletionProviderAddon extends Disposable implements ITerminalAddon, ITerminalCompletionProvider {\n\treadonly id = 'lsp';\n\treadonly isBuiltin = true;\n\treadonly triggerCharacters?: string[];\n\tprivate _provider: CompletionItemProvider;\n\tprivate _textVirtualModel: IReference<IResolvedTextEditorModel>;\n\tprivate _lspTerminalModelContentProvider: LspTerminalModelContentProvider;\n\n\tconstructor(\n\t\tprovider: CompletionItemProvider,\n\t\ttextVirtualModel: IReference<IResolvedTextEditorModel>,\n\t\tlspTerminalModelContentProvider: LspTerminalModelContentProvider,\n\t) {\n\t\tsuper();\n\t\tthis._provider = provider;\n\t\tthis._textVirtualModel = textVirtualModel;\n\t\tthis._lspTerminalModelContentProvider = lspTerminalModelContentProvider;\n\t\tthis.triggerCharacters = provider.triggerCharacters ? [...provider.triggerCharacters, ' ', '('] : [' ', '('];\n\t}\n\n\tactivate(terminal: Terminal): void {\n\t\t// console.log('activate');\n\t}\n\n\tasync provideCompletions(value: string, cursorPosition: number, token: CancellationToken): Promise<ITerminalCompletion[] | TerminalCompletionList<ITerminalCompletion> | undefined> {\n\n\t\t// Apply edit for non-executed current commandline --> Pretend we are typing in the real-document.\n\t\tthis._lspTerminalModelContentProvider.trackPromptInputToVirtualFile(value);\n\n\t\tconst textBeforeCursor = value.substring(0, cursorPosition);\n\t\tconst lines = textBeforeCursor.split('\\n');\n\t\tconst column = lines[lines.length - 1].length + 1;\n\n\t\t// Get line from virtualDocument, not from terminal\n\t\tconst lineNum = this._textVirtualModel.object.textEditorModel.getLineCount();\n\t\tconst positionVirtualDocument = new Position(lineNum, column);\n\n\t\tconst completions: ITerminalCompletion[] = [];\n\t\tif (this._provider && this._provider._debugDisplayName !== 'wordbasedCompletions') {\n\n\t\t\tconst result = await this._provider.provideCompletionItems(this._textVirtualModel.object.textEditorModel, positionVirtualDocument, { triggerKind: CompletionTriggerKind.TriggerCharacter }, token);\n\t\t\tfor (const item of (result?.suggestions || [])) {\n\t\t\t\t// TODO: Support more terminalCompletionItemKind for [different LSP providers](https://github.com/microsoft/vscode/issues/249479)\n\t\t\t\tconst convertedKind = item.kind ? mapLspKindToTerminalKind(item.kind) : TerminalCompletionItemKind.Method;\n\t\t\t\tconst completionItemTemp = createCompletionItemPython(cursorPosition, textBeforeCursor, convertedKind, 'lspCompletionItem', undefined);\n\t\t\t\tconst terminalCompletion: ITerminalCompletion = {\n\t\t\t\t\tlabel: item.label,\n\t\t\t\t\tprovider: `lsp:${item.extensionId?.value}`,\n\t\t\t\t\tdetail: item.detail,\n\t\t\t\t\tdocumentation: item.documentation,\n\t\t\t\t\tkind: convertedKind,\n\t\t\t\t\treplacementRange: completionItemTemp.replacementRange,\n\t\t\t\t};\n\n\t\t\t\t// Store unresolved item and provider for lazy resolution if needed\n\t\t\t\tif (this._provider.resolveCompletionItem && (!item.detail || !item.documentation)) {\n\t\t\t\t\tterminalCompletion._unresolvedItem = item;\n\t\t\t\t\tterminalCompletion._resolveProvider = this._provider;\n\t\t\t\t}\n\n\t\t\t\tcompletions.push(terminalCompletion);\n\t\t\t}\n\t\t}\n\n\t\treturn completions;\n\t}\n}\n\nexport function createCompletionItemPython(\n\tcursorPosition: number,\n\tprefix: string,\n\tkind: TerminalCompletionItemKind,\n\tlabel: string | CompletionItemLabel,\n\tdetail: string | undefined\n): TerminalCompletionItem {\n\tconst lastWord = getLastWord(prefix);\n\n\treturn {\n\t\tlabel,\n\t\tdetail: detail ?? '',\n\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition],\n\t\tkind: kind ?? TerminalCompletionItemKind.Method\n\t};\n}\n\nfunction getLastWord(prefix: string): string {\n\tif (prefix.endsWith(' ')) {\n\t\treturn '';\n\t}\n\n\tif (prefix.endsWith('.')) {\n\t\treturn '';\n\t}\n\n\tconst lastSpaceIndex = prefix.lastIndexOf(' ');\n\tconst lastDotIndex = prefix.lastIndexOf('.');\n\tconst lastParenIndex = prefix.lastIndexOf('(');\n\n\t// Get the maximum index (most recent delimiter)\n\tconst lastDelimiterIndex = Math.max(lastSpaceIndex, lastDotIndex, lastParenIndex);\n\n\t// If no delimiter found, return the entire prefix\n\tif (lastDelimiterIndex === -1) {\n\t\treturn prefix;\n\t}\n\n\t// Return the substring after the last delimiter\n\treturn prefix.substring(lastDelimiterIndex + 1);\n}\n\nexport interface TerminalCompletionItem {\n\t/**\n\t * The label of the completion.\n\t */\n\tlabel: string | CompletionItemLabel;\n\n\t/**\n\t * Selection range (inclusive start, exclusive end) to replace when this completion is applied.\n\t */\n\treplacementRange: readonly [number, number] | undefined;\n\n\t/**\n\t * The completion's detail which appears on the right of the list.\n\t */\n\tdetail?: string;\n\n\t/**\n\t * A human-readable string that represents a doc-comment.\n\t */\n\tdocumentation?: string | MarkdownString;\n\n\t/**\n\t * The completion's kind. Note that this will map to an icon.\n\t */\n\tkind?: TerminalCompletionItemKind;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { ITerminalAddon, Terminal } from '@xterm/xterm';\nimport { Disposable, IReference } from '../../../../../base/common/lifecycle.js';\nimport { ITerminalCompletionProvider, type TerminalCompletionList } from './terminalCompletionService.js';\nimport type { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { ITerminalCompletion, mapLspKindToTerminalKind, TerminalCompletionItemKind } from './terminalCompletionItem.js';\nimport { IResolvedTextEditorModel } from '../../../../../editor/common/services/resolverService.js';\nimport { Position } from '../../../../../editor/common/core/position.js';\nimport { CompletionItemLabel, CompletionItemProvider, CompletionTriggerKind } from '../../../../../editor/common/languages.js';\nimport { LspTerminalModelContentProvider } from './lspTerminalModelContentProvider.js';\nimport { MarkdownString } from '../../../../../base/common/htmlContent.js';\n\nexport class LspCompletionProviderAddon extends Disposable implements ITerminalAddon, ITerminalCompletionProvider {\n\treadonly id = 'lsp';\n\treadonly isBuiltin = true;\n\treadonly triggerCharacters?: string[];\n\tprivate _provider: CompletionItemProvider;\n\tprivate _textVirtualModel: IReference<IResolvedTextEditorModel>;\n\tprivate _lspTerminalModelContentProvider: LspTerminalModelContentProvider;\n\n\tconstructor(\n\t\tprovider: CompletionItemProvider,\n\t\ttextVirtualModel: IReference<IResolvedTextEditorModel>,\n\t\tlspTerminalModelContentProvider: LspTerminalModelContentProvider,\n\t) {\n\t\tsuper();\n\t\tthis._provider = provider;\n\t\tthis._textVirtualModel = textVirtualModel;\n\t\tthis._lspTerminalModelContentProvider = lspTerminalModelContentProvider;\n\t\tthis.triggerCharacters = provider.triggerCharacters ? [...provider.triggerCharacters, ' ', '('] : [' ', '('];\n\t}\n\n\tactivate(terminal: Terminal): void {\n\t\t// console.log('activate');\n\t}\n\n\tasync provideCompletions(value: string, cursorPosition: number, token: CancellationToken): Promise<ITerminalCompletion[] | TerminalCompletionList<ITerminalCompletion> | undefined> {\n\n\t\t// Apply edit for non-executed current commandline --> Pretend we are typing in the real-document.\n\t\tthis._lspTerminalModelContentProvider.trackPromptInputToVirtualFile(value);\n\n\t\tconst textBeforeCursor = value.substring(0, cursorPosition);\n\t\tconst lines = textBeforeCursor.split('\\n');\n\t\tconst column = lines[lines.length - 1].length + 1;\n\n\t\t// Get line from virtualDocument, not from terminal\n\t\tconst lineNum = this._textVirtualModel.object.textEditorModel.getLineCount();\n\t\tconst positionVirtualDocument = new Position(lineNum, column);\n\n\t\tconst completions: ITerminalCompletion[] = [];\n\t\tif (this._provider && this._provider._debugDisplayName !== 'wordbasedCompletions') {\n\n\t\t\tconst result = await this._provider.provideCompletionItems(this._textVirtualModel.object.textEditorModel, positionVirtualDocument, { triggerKind: CompletionTriggerKind.TriggerCharacter }, token);\n\t\t\tfor (const item of (result?.suggestions || [])) {\n\t\t\t\t// TODO: Support more terminalCompletionItemKind for [different LSP providers](https://github.com/microsoft/vscode/issues/249479)\n\t\t\t\tconst convertedKind = item.kind ? mapLspKindToTerminalKind(item.kind) : TerminalCompletionItemKind.Method;\n\t\t\t\tconst completionItemTemp = createCompletionItemPython(cursorPosition, textBeforeCursor, convertedKind, 'lspCompletionItem', undefined);\n\t\t\t\tconst terminalCompletion: ITerminalCompletion = {\n\t\t\t\t\tlabel: item.label,\n\t\t\t\t\tprovider: `lsp:${item.extensionId?.value}`,\n\t\t\t\t\tdetail: item.detail,\n\t\t\t\t\tdocumentation: item.documentation,\n\t\t\t\t\tkind: convertedKind,\n\t\t\t\t\treplacementRange: completionItemTemp.replacementRange,\n\t\t\t\t};\n\n\t\t\t\t// Store unresolved item and provider for lazy resolution if needed\n\t\t\t\tif (this._provider.resolveCompletionItem && (!item.detail || !item.documentation)) {\n\t\t\t\t\tterminalCompletion._unresolvedItem = item;\n\t\t\t\t\tterminalCompletion._resolveProvider = this._provider;\n\t\t\t\t}\n\n\t\t\t\tcompletions.push(terminalCompletion);\n\t\t\t}\n\t\t}\n\n\t\treturn completions;\n\t}\n}\n\nexport function createCompletionItemPython(\n\tcursorPosition: number,\n\tprefix: string,\n\tkind: TerminalCompletionItemKind,\n\tlabel: string | CompletionItemLabel,\n\tdetail: string | undefined\n): TerminalCompletionItem {\n\tconst lastWord = getLastWord(prefix);\n\n\treturn {\n\t\tlabel,\n\t\tdetail: detail ?? '',\n\t\treplacementRange: [cursorPosition - lastWord.length, cursorPosition],\n\t\tkind: kind ?? TerminalCompletionItemKind.Method\n\t};\n}\n\nfunction getLastWord(prefix: string): string {\n\tif (prefix.endsWith(' ')) {\n\t\treturn '';\n\t}\n\n\tif (prefix.endsWith('.')) {\n\t\treturn '';\n\t}\n\n\tconst lastSpaceIndex = prefix.lastIndexOf(' ');\n\tconst lastDotIndex = prefix.lastIndexOf('.');\n\tconst lastParenIndex = prefix.lastIndexOf('(');\n\n\t// Get the maximum index (most recent delimiter)\n\tconst lastDelimiterIndex = Math.max(lastSpaceIndex, lastDotIndex, lastParenIndex);\n\n\t// If no delimiter found, return the entire prefix\n\tif (lastDelimiterIndex === -1) {\n\t\treturn prefix;\n\t}\n\n\t// Return the substring after the last delimiter\n\treturn prefix.substring(lastDelimiterIndex + 1);\n}\n\nexport interface TerminalCompletionItem {\n\t/**\n\t * The label of the completion.\n\t */\n\tlabel: string | CompletionItemLabel;\n\n\t/**\n\t * Selection range (inclusive start, exclusive end) to replace when this completion is applied.\n\t */\n\treplacementRange: readonly [number, number] | undefined;\n\n\t/**\n\t * The completion's detail which appears on the right of the list.\n\t */\n\tdetail?: string;\n\n\t/**\n\t * A human-readable string that represents a doc-comment.\n\t */\n\tdocumentation?: string | MarkdownString;\n\n\t/**\n\t * The completion's kind. Note that this will map to an icon.\n\t */\n\tkind?: TerminalCompletionItemKind;\n}\n"]}