{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/inlineChat/browser/inlineChatSession.ts","vs/workbench/contrib/inlineChat/browser/inlineChatSession.ts"],"names":[],"mappings":"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","file":"inlineChatSession.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { IIdentifiedSingleEditOperation, IModelDecorationOptions, IModelDeltaDecoration, ITextModel, IValidEditOperation, TrackedRangeStickiness } from '../../../../editor/common/model.js';\nimport { CTX_INLINE_CHAT_HAS_STASHED_SESSION } from '../common/inlineChat.js';\nimport { IRange, Range } from '../../../../editor/common/core/range.js';\nimport { ModelDecorationOptions } from '../../../../editor/common/model/textModel.js';\nimport { EditOperation, ISingleEditOperation } from '../../../../editor/common/core/editOperation.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, RangeMapping } from '../../../../editor/common/diff/rangeMapping.js';\nimport { IInlineChatSessionService } from './inlineChatSessionService.js';\nimport { LineRange } from '../../../../editor/common/core/ranges/lineRange.js';\nimport { IEditorWorkerService } from '../../../../editor/common/services/editorWorker.js';\nimport { coalesceInPlace } from '../../../../base/common/arrays.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { IModelContentChangedEvent } from '../../../../editor/common/textModelEvents.js';\nimport { DisposableStore, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { ICodeEditor } from '../../../../editor/browser/editorBrowser.js';\nimport { IContextKey, IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { ChatModel, IChatRequestModel, IChatTextEditGroupState } from '../../chat/common/chatModel.js';\nimport { ExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { IChatAgent } from '../../chat/common/chatAgents.js';\nimport { IDocumentDiff } from '../../../../editor/common/diff/documentDiffProvider.js';\n\n\nexport type TelemetryData = {\n\textension: string;\n\trounds: string;\n\tundos: string;\n\tunstashed: number;\n\tedits: number;\n\tfinishedByEdit: boolean;\n\tstartTime: string;\n\tendTime: string;\n\tacceptedHunks: number;\n\tdiscardedHunks: number;\n\tresponseTypes: string;\n};\n\nexport type TelemetryDataClassification = {\n\towner: 'jrieken';\n\tcomment: 'Data about an interaction editor session';\n\textension: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The extension providing the data' };\n\trounds: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Number of request that were made' };\n\tundos: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Requests that have been undone' };\n\tedits: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Did edits happen while the session was active' };\n\tunstashed: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'How often did this session become stashed and resumed' };\n\tfinishedByEdit: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Did edits cause the session to terminate' };\n\tstartTime: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'When the session started' };\n\tendTime: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'When the session ended' };\n\tacceptedHunks: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Number of accepted hunks' };\n\tdiscardedHunks: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Number of discarded hunks' };\n\tresponseTypes: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Comma separated list of response types like edits, message, mixed' };\n};\n\n\nexport class SessionWholeRange {\n\n\tprivate static readonly _options: IModelDecorationOptions = ModelDecorationOptions.register({ description: 'inlineChat/session/wholeRange' });\n\n\tprivate readonly _onDidChange = new Emitter<this>();\n\treadonly onDidChange: Event<this> = this._onDidChange.event;\n\n\tprivate _decorationIds: string[] = [];\n\n\tconstructor(private readonly _textModel: ITextModel, wholeRange: IRange) {\n\t\tthis._decorationIds = _textModel.deltaDecorations([], [{ range: wholeRange, options: SessionWholeRange._options }]);\n\t}\n\n\tdispose() {\n\t\tthis._onDidChange.dispose();\n\t\tif (!this._textModel.isDisposed()) {\n\t\t\tthis._textModel.deltaDecorations(this._decorationIds, []);\n\t\t}\n\t}\n\n\tfixup(changes: readonly DetailedLineRangeMapping[]): void {\n\t\tconst newDeco: IModelDeltaDecoration[] = [];\n\t\tfor (const { modified } of changes) {\n\t\t\tconst modifiedRange = this._textModel.validateRange(modified.isEmpty\n\t\t\t\t? new Range(modified.startLineNumber, 1, modified.startLineNumber, Number.MAX_SAFE_INTEGER)\n\t\t\t\t: new Range(modified.startLineNumber, 1, modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n\n\t\t\tnewDeco.push({ range: modifiedRange, options: SessionWholeRange._options });\n\t\t}\n\t\tconst [first, ...rest] = this._decorationIds; // first is the original whole range\n\t\tconst newIds = this._textModel.deltaDecorations(rest, newDeco);\n\t\tthis._decorationIds = [first].concat(newIds);\n\t\tthis._onDidChange.fire(this);\n\t}\n\n\tget trackedInitialRange(): Range {\n\t\tconst [first] = this._decorationIds;\n\t\treturn this._textModel.getDecorationRange(first) ?? new Range(1, 1, 1, 1);\n\t}\n\n\tget value(): Range {\n\t\tlet result: Range | undefined;\n\t\tfor (const id of this._decorationIds) {\n\t\t\tconst range = this._textModel.getDecorationRange(id);\n\t\t\tif (range) {\n\t\t\t\tif (!result) {\n\t\t\t\t\tresult = range;\n\t\t\t\t} else {\n\t\t\t\t\tresult = Range.plusRange(result, range);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result!;\n\t}\n}\n\nexport class Session {\n\n\tprivate _isUnstashed: boolean = false;\n\tprivate readonly _startTime = new Date();\n\tprivate readonly _teldata: TelemetryData;\n\n\tprivate readonly _versionByRequest = new Map<string, number>();\n\n\tconstructor(\n\t\treadonly headless: boolean,\n\t\t/**\n\t\t * The URI of the document which is being EditorEdit\n\t\t */\n\t\treadonly targetUri: URI,\n\t\t/**\n\t\t * A copy of the document at the time the session was started\n\t\t */\n\t\treadonly textModel0: ITextModel,\n\t\t/**\n\t\t * The model of the editor\n\t\t */\n\t\treadonly textModelN: ITextModel,\n\t\treadonly agent: IChatAgent,\n\t\treadonly wholeRange: SessionWholeRange,\n\t\treadonly hunkData: HunkData,\n\t\treadonly chatModel: ChatModel,\n\t\tversionsByRequest?: [string, number][], // DEBT? this is needed when a chat model is \"reused\" for a new chat session\n\t) {\n\n\t\tthis._teldata = {\n\t\t\textension: ExtensionIdentifier.toKey(agent.extensionId),\n\t\t\tstartTime: this._startTime.toISOString(),\n\t\t\tendTime: this._startTime.toISOString(),\n\t\t\tedits: 0,\n\t\t\tfinishedByEdit: false,\n\t\t\trounds: '',\n\t\t\tundos: '',\n\t\t\tunstashed: 0,\n\t\t\tacceptedHunks: 0,\n\t\t\tdiscardedHunks: 0,\n\t\t\tresponseTypes: ''\n\t\t};\n\t\tif (versionsByRequest) {\n\t\t\tthis._versionByRequest = new Map(versionsByRequest);\n\t\t}\n\t}\n\n\tget isUnstashed(): boolean {\n\t\treturn this._isUnstashed;\n\t}\n\n\tmarkUnstashed() {\n\t\tthis._teldata.unstashed! += 1;\n\t\tthis._isUnstashed = true;\n\t}\n\n\tmarkModelVersion(request: IChatRequestModel) {\n\t\tthis._versionByRequest.set(request.id, this.textModelN.getAlternativeVersionId());\n\t}\n\n\tget versionsByRequest() {\n\t\treturn Array.from(this._versionByRequest);\n\t}\n\n\tasync undoChangesUntil(requestId: string): Promise<boolean> {\n\n\t\tconst targetAltVersion = this._versionByRequest.get(requestId);\n\t\tif (targetAltVersion === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\t// undo till this point\n\t\tthis.hunkData.ignoreTextModelNChanges = true;\n\t\ttry {\n\t\t\twhile (targetAltVersion < this.textModelN.getAlternativeVersionId() && this.textModelN.canUndo()) {\n\t\t\t\tawait this.textModelN.undo();\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.hunkData.ignoreTextModelNChanges = false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tget hasChangedText(): boolean {\n\t\treturn !this.textModel0.equalsTextBuffer(this.textModelN.getTextBuffer());\n\t}\n\n\tasChangedText(changes: readonly LineRangeMapping[]): string | undefined {\n\t\tif (changes.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet startLine = Number.MAX_VALUE;\n\t\tlet endLine = Number.MIN_VALUE;\n\t\tfor (const change of changes) {\n\t\t\tstartLine = Math.min(startLine, change.modified.startLineNumber);\n\t\t\tendLine = Math.max(endLine, change.modified.endLineNumberExclusive);\n\t\t}\n\n\t\treturn this.textModelN.getValueInRange(new Range(startLine, 1, endLine, Number.MAX_VALUE));\n\t}\n\n\trecordExternalEditOccurred(didFinish: boolean) {\n\t\tthis._teldata.edits += 1;\n\t\tthis._teldata.finishedByEdit = didFinish;\n\t}\n\n\tasTelemetryData(): TelemetryData {\n\n\t\tfor (const item of this.hunkData.getInfo()) {\n\t\t\tswitch (item.getState()) {\n\t\t\t\tcase HunkState.Accepted:\n\t\t\t\t\tthis._teldata.acceptedHunks += 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase HunkState.Rejected:\n\t\t\t\t\tthis._teldata.discardedHunks += 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis._teldata.endTime = new Date().toISOString();\n\t\treturn this._teldata;\n\t}\n}\n\n\nexport class StashedSession {\n\n\tprivate readonly _listener: IDisposable;\n\tprivate readonly _ctxHasStashedSession: IContextKey<boolean>;\n\tprivate _session: Session | undefined;\n\n\tconstructor(\n\t\teditor: ICodeEditor,\n\t\tsession: Session,\n\t\tprivate readonly _undoCancelEdits: IValidEditOperation[],\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@IInlineChatSessionService private readonly _sessionService: IInlineChatSessionService,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tthis._ctxHasStashedSession = CTX_INLINE_CHAT_HAS_STASHED_SESSION.bindTo(contextKeyService);\n\n\t\t// keep session for a little bit, only release when user continues to work (type, move cursor, etc.)\n\t\tthis._session = session;\n\t\tthis._ctxHasStashedSession.set(true);\n\t\tthis._listener = Event.once(Event.any(editor.onDidChangeCursorSelection, editor.onDidChangeModelContent, editor.onDidChangeModel, editor.onDidBlurEditorWidget))(() => {\n\t\t\tthis._session = undefined;\n\t\t\tthis._sessionService.releaseSession(session);\n\t\t\tthis._ctxHasStashedSession.reset();\n\t\t});\n\t}\n\n\tdispose() {\n\t\tthis._listener.dispose();\n\t\tthis._ctxHasStashedSession.reset();\n\t\tif (this._session) {\n\t\t\tthis._sessionService.releaseSession(this._session);\n\t\t}\n\t}\n\n\tunstash(): Session | undefined {\n\t\tif (!this._session) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._listener.dispose();\n\t\tconst result = this._session;\n\t\tresult.markUnstashed();\n\t\tresult.hunkData.ignoreTextModelNChanges = true;\n\t\tresult.textModelN.pushEditOperations(null, this._undoCancelEdits, () => null);\n\t\tresult.hunkData.ignoreTextModelNChanges = false;\n\t\tthis._session = undefined;\n\t\tthis._logService.debug('[IE] Unstashed session');\n\t\treturn result;\n\t}\n}\n\n// ---\n\nfunction lineRangeAsRange(lineRange: LineRange, model: ITextModel): Range {\n\treturn lineRange.isEmpty\n\t\t? new Range(lineRange.startLineNumber, 1, lineRange.startLineNumber, Number.MAX_SAFE_INTEGER)\n\t\t: new Range(lineRange.startLineNumber, 1, lineRange.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n}\n\nexport class HunkData {\n\n\tprivate static readonly _HUNK_TRACKED_RANGE = ModelDecorationOptions.register({\n\t\tdescription: 'inline-chat-hunk-tracked-range',\n\t\tstickiness: TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n\t});\n\n\tprivate static readonly _HUNK_THRESHOLD = 8;\n\n\tprivate readonly _store = new DisposableStore();\n\tprivate readonly _data = new Map<RawHunk, RawHunkData>();\n\tprivate _ignoreChanges: boolean = false;\n\n\tconstructor(\n\t\t@IEditorWorkerService private readonly _editorWorkerService: IEditorWorkerService,\n\t\tprivate readonly _textModel0: ITextModel,\n\t\tprivate readonly _textModelN: ITextModel,\n\t) {\n\n\t\tthis._store.add(_textModelN.onDidChangeContent(e => {\n\t\t\tif (!this._ignoreChanges) {\n\t\t\t\tthis._mirrorChanges(e);\n\t\t\t}\n\t\t}));\n\t}\n\n\tdispose(): void {\n\t\tif (!this._textModelN.isDisposed()) {\n\t\t\tthis._textModelN.changeDecorations(accessor => {\n\t\t\t\tfor (const { textModelNDecorations } of this._data.values()) {\n\t\t\t\t\ttextModelNDecorations.forEach(accessor.removeDecoration, accessor);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (!this._textModel0.isDisposed()) {\n\t\t\tthis._textModel0.changeDecorations(accessor => {\n\t\t\t\tfor (const { textModel0Decorations } of this._data.values()) {\n\t\t\t\t\ttextModel0Decorations.forEach(accessor.removeDecoration, accessor);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis._data.clear();\n\t\tthis._store.dispose();\n\t}\n\n\tset ignoreTextModelNChanges(value: boolean) {\n\t\tthis._ignoreChanges = value;\n\t}\n\n\tget ignoreTextModelNChanges(): boolean {\n\t\treturn this._ignoreChanges;\n\t}\n\n\tprivate _mirrorChanges(event: IModelContentChangedEvent) {\n\n\t\t// mirror textModelN changes to textModel0 execept for those that\n\t\t// overlap with a hunk\n\n\t\ttype HunkRangePair = { rangeN: Range; range0: Range; markAccepted: () => void };\n\t\tconst hunkRanges: HunkRangePair[] = [];\n\n\t\tconst ranges0: Range[] = [];\n\n\t\tfor (const entry of this._data.values()) {\n\n\t\t\tif (entry.state === HunkState.Pending) {\n\t\t\t\t// pending means the hunk's changes aren't \"sync'd\" yet\n\t\t\t\tfor (let i = 1; i < entry.textModelNDecorations.length; i++) {\n\t\t\t\t\tconst rangeN = this._textModelN.getDecorationRange(entry.textModelNDecorations[i]);\n\t\t\t\t\tconst range0 = this._textModel0.getDecorationRange(entry.textModel0Decorations[i]);\n\t\t\t\t\tif (rangeN && range0) {\n\t\t\t\t\t\thunkRanges.push({\n\t\t\t\t\t\t\trangeN, range0,\n\t\t\t\t\t\t\tmarkAccepted: () => entry.state = HunkState.Accepted\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (entry.state === HunkState.Accepted) {\n\t\t\t\t// accepted means the hunk's changes are also in textModel0\n\t\t\t\tfor (let i = 1; i < entry.textModel0Decorations.length; i++) {\n\t\t\t\t\tconst range = this._textModel0.getDecorationRange(entry.textModel0Decorations[i]);\n\t\t\t\t\tif (range) {\n\t\t\t\t\t\tranges0.push(range);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thunkRanges.sort((a, b) => Range.compareRangesUsingStarts(a.rangeN, b.rangeN));\n\t\tranges0.sort(Range.compareRangesUsingStarts);\n\n\t\tconst edits: IIdentifiedSingleEditOperation[] = [];\n\n\t\tfor (const change of event.changes) {\n\n\t\t\tlet isOverlapping = false;\n\n\t\t\tlet pendingChangesLen = 0;\n\n\t\t\tfor (const entry of hunkRanges) {\n\t\t\t\tif (entry.rangeN.getEndPosition().isBefore(Range.getStartPosition(change.range))) {\n\t\t\t\t\t// pending hunk _before_ this change. When projecting into textModel0 we need to\n\t\t\t\t\t// subtract that. Because diffing is relaxed it might include changes that are not\n\t\t\t\t\t// actual insertions/deletions. Therefore we need to take the length of the original\n\t\t\t\t\t// range into account.\n\t\t\t\t\tpendingChangesLen += this._textModelN.getValueLengthInRange(entry.rangeN);\n\t\t\t\t\tpendingChangesLen -= this._textModel0.getValueLengthInRange(entry.range0);\n\n\t\t\t\t} else if (Range.areIntersectingOrTouching(entry.rangeN, change.range)) {\n\t\t\t\t\t// an edit overlaps with a (pending) hunk. We take this as a signal\n\t\t\t\t\t// to mark the hunk as accepted and to ignore the edit. The range of the hunk\n\t\t\t\t\t// will be up-to-date because of decorations created for them\n\t\t\t\t\tentry.markAccepted();\n\t\t\t\t\tisOverlapping = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\t\t\t\t\t// hunks past this change aren't relevant\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isOverlapping) {\n\t\t\t\t// hunk overlaps, it grew\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst offset0 = change.rangeOffset - pendingChangesLen;\n\t\t\tconst start0 = this._textModel0.getPositionAt(offset0);\n\n\t\t\tlet acceptedChangesLen = 0;\n\t\t\tfor (const range of ranges0) {\n\t\t\t\tif (range.getEndPosition().isBefore(start0)) {\n\t\t\t\t\t// accepted hunk _before_ this projected change. When projecting into textModel0\n\t\t\t\t\t// we need to add that\n\t\t\t\t\tacceptedChangesLen += this._textModel0.getValueLengthInRange(range);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst start = this._textModel0.getPositionAt(offset0 + acceptedChangesLen);\n\t\t\tconst end = this._textModel0.getPositionAt(offset0 + acceptedChangesLen + change.rangeLength);\n\t\t\tedits.push(EditOperation.replace(Range.fromPositions(start, end), change.text));\n\t\t}\n\n\t\tthis._textModel0.pushEditOperations(null, edits, () => null);\n\t}\n\n\tasync recompute(editState: IChatTextEditGroupState, diff?: IDocumentDiff | null) {\n\n\t\tdiff ??= await this._editorWorkerService.computeDiff(this._textModel0.uri, this._textModelN.uri, { ignoreTrimWhitespace: false, maxComputationTimeMs: Number.MAX_SAFE_INTEGER, computeMoves: false }, 'advanced');\n\n\t\tlet mergedChanges: DetailedLineRangeMapping[] = [];\n\n\t\tif (diff && diff.changes.length > 0) {\n\t\t\t// merge changes neighboring changes\n\t\t\tmergedChanges = [diff.changes[0]];\n\t\t\tfor (let i = 1; i < diff.changes.length; i++) {\n\t\t\t\tconst lastChange = mergedChanges[mergedChanges.length - 1];\n\t\t\t\tconst thisChange = diff.changes[i];\n\t\t\t\tif (thisChange.modified.startLineNumber - lastChange.modified.endLineNumberExclusive <= HunkData._HUNK_THRESHOLD) {\n\t\t\t\t\tmergedChanges[mergedChanges.length - 1] = new DetailedLineRangeMapping(\n\t\t\t\t\t\tlastChange.original.join(thisChange.original),\n\t\t\t\t\t\tlastChange.modified.join(thisChange.modified),\n\t\t\t\t\t\t(lastChange.innerChanges ?? []).concat(thisChange.innerChanges ?? [])\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tmergedChanges.push(thisChange);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst hunks = mergedChanges.map(change => new RawHunk(change.original, change.modified, change.innerChanges ?? []));\n\n\t\teditState.applied = hunks.length;\n\n\t\tthis._textModelN.changeDecorations(accessorN => {\n\n\t\t\tthis._textModel0.changeDecorations(accessor0 => {\n\n\t\t\t\t// clean up old decorations\n\t\t\t\tfor (const { textModelNDecorations, textModel0Decorations } of this._data.values()) {\n\t\t\t\t\ttextModelNDecorations.forEach(accessorN.removeDecoration, accessorN);\n\t\t\t\t\ttextModel0Decorations.forEach(accessor0.removeDecoration, accessor0);\n\t\t\t\t}\n\n\t\t\t\tthis._data.clear();\n\n\t\t\t\t// add new decorations\n\t\t\t\tfor (const hunk of hunks) {\n\n\t\t\t\t\tconst textModelNDecorations: string[] = [];\n\t\t\t\t\tconst textModel0Decorations: string[] = [];\n\n\t\t\t\t\ttextModelNDecorations.push(accessorN.addDecoration(lineRangeAsRange(hunk.modified, this._textModelN), HunkData._HUNK_TRACKED_RANGE));\n\t\t\t\t\ttextModel0Decorations.push(accessor0.addDecoration(lineRangeAsRange(hunk.original, this._textModel0), HunkData._HUNK_TRACKED_RANGE));\n\n\t\t\t\t\tfor (const change of hunk.changes) {\n\t\t\t\t\t\ttextModelNDecorations.push(accessorN.addDecoration(change.modifiedRange, HunkData._HUNK_TRACKED_RANGE));\n\t\t\t\t\t\ttextModel0Decorations.push(accessor0.addDecoration(change.originalRange, HunkData._HUNK_TRACKED_RANGE));\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._data.set(hunk, {\n\t\t\t\t\t\teditState,\n\t\t\t\t\t\ttextModelNDecorations,\n\t\t\t\t\t\ttextModel0Decorations,\n\t\t\t\t\t\tstate: HunkState.Pending\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tget size(): number {\n\t\treturn this._data.size;\n\t}\n\n\tget pending(): number {\n\t\treturn Iterable.reduce(this._data.values(), (r, { state }) => r + (state === HunkState.Pending ? 1 : 0), 0);\n\t}\n\n\tprivate _discardEdits(item: HunkInformation): ISingleEditOperation[] {\n\t\tconst edits: ISingleEditOperation[] = [];\n\t\tconst rangesN = item.getRangesN();\n\t\tconst ranges0 = item.getRanges0();\n\t\tfor (let i = 1; i < rangesN.length; i++) {\n\t\t\tconst modifiedRange = rangesN[i];\n\n\t\t\tconst originalValue = this._textModel0.getValueInRange(ranges0[i]);\n\t\t\tedits.push(EditOperation.replace(modifiedRange, originalValue));\n\t\t}\n\t\treturn edits;\n\t}\n\n\tdiscardAll() {\n\t\tconst edits: ISingleEditOperation[][] = [];\n\t\tfor (const item of this.getInfo()) {\n\t\t\tif (item.getState() === HunkState.Pending) {\n\t\t\t\tedits.push(this._discardEdits(item));\n\t\t\t}\n\t\t}\n\t\tconst undoEdits: IValidEditOperation[][] = [];\n\t\tthis._textModelN.pushEditOperations(null, edits.flat(), (_undoEdits) => {\n\t\t\tundoEdits.push(_undoEdits);\n\t\t\treturn null;\n\t\t});\n\t\treturn undoEdits.flat();\n\t}\n\n\tgetInfo(): HunkInformation[] {\n\n\t\tconst result: HunkInformation[] = [];\n\n\t\tfor (const [hunk, data] of this._data.entries()) {\n\t\t\tconst item: HunkInformation = {\n\t\t\t\tgetState: () => {\n\t\t\t\t\treturn data.state;\n\t\t\t\t},\n\t\t\t\tisInsertion: () => {\n\t\t\t\t\treturn hunk.original.isEmpty;\n\t\t\t\t},\n\t\t\t\tgetRangesN: () => {\n\t\t\t\t\tconst ranges = data.textModelNDecorations.map(id => this._textModelN.getDecorationRange(id));\n\t\t\t\t\tcoalesceInPlace(ranges);\n\t\t\t\t\treturn ranges;\n\t\t\t\t},\n\t\t\t\tgetRanges0: () => {\n\t\t\t\t\tconst ranges = data.textModel0Decorations.map(id => this._textModel0.getDecorationRange(id));\n\t\t\t\t\tcoalesceInPlace(ranges);\n\t\t\t\t\treturn ranges;\n\t\t\t\t},\n\t\t\t\tdiscardChanges: () => {\n\t\t\t\t\t// DISCARD: replace modified range with original value. The modified range is retrieved from a decoration\n\t\t\t\t\t// which was created above so that typing in the editor keeps discard working.\n\t\t\t\t\tif (data.state === HunkState.Pending) {\n\t\t\t\t\t\tconst edits = this._discardEdits(item);\n\t\t\t\t\t\tthis._textModelN.pushEditOperations(null, edits, () => null);\n\t\t\t\t\t\tdata.state = HunkState.Rejected;\n\t\t\t\t\t\tif (data.editState.applied > 0) {\n\t\t\t\t\t\t\tdata.editState.applied -= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tacceptChanges: () => {\n\t\t\t\t\t// ACCEPT: replace original range with modified value. The modified value is retrieved from the model via\n\t\t\t\t\t// its decoration and the original range is retrieved from the hunk.\n\t\t\t\t\tif (data.state === HunkState.Pending) {\n\t\t\t\t\t\tconst edits: ISingleEditOperation[] = [];\n\t\t\t\t\t\tconst rangesN = item.getRangesN();\n\t\t\t\t\t\tconst ranges0 = item.getRanges0();\n\t\t\t\t\t\tfor (let i = 1; i < ranges0.length; i++) {\n\t\t\t\t\t\t\tconst originalRange = ranges0[i];\n\t\t\t\t\t\t\tconst modifiedValue = this._textModelN.getValueInRange(rangesN[i]);\n\t\t\t\t\t\t\tedits.push(EditOperation.replace(originalRange, modifiedValue));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._textModel0.pushEditOperations(null, edits, () => null);\n\t\t\t\t\t\tdata.state = HunkState.Accepted;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tresult.push(item);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nclass RawHunk {\n\tconstructor(\n\t\treadonly original: LineRange,\n\t\treadonly modified: LineRange,\n\t\treadonly changes: RangeMapping[]\n\t) { }\n}\n\ntype RawHunkData = {\n\ttextModelNDecorations: string[];\n\ttextModel0Decorations: string[];\n\tstate: HunkState;\n\teditState: IChatTextEditGroupState;\n};\n\nexport const enum HunkState {\n\tPending = 0,\n\tAccepted = 1,\n\tRejected = 2\n}\n\nexport interface HunkInformation {\n\t/**\n\t * The first element [0] is the whole modified range and subsequent elements are word-level changes\n\t */\n\tgetRangesN(): Range[];\n\n\tgetRanges0(): Range[];\n\n\tisInsertion(): boolean;\n\n\tdiscardChanges(): void;\n\n\t/**\n\t * Accept the hunk. Applies the corresponding edits into textModel0\n\t */\n\tacceptChanges(): void;\n\n\tgetState(): HunkState;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { IIdentifiedSingleEditOperation, IModelDecorationOptions, IModelDeltaDecoration, ITextModel, IValidEditOperation, TrackedRangeStickiness } from '../../../../editor/common/model.js';\nimport { CTX_INLINE_CHAT_HAS_STASHED_SESSION } from '../common/inlineChat.js';\nimport { IRange, Range } from '../../../../editor/common/core/range.js';\nimport { ModelDecorationOptions } from '../../../../editor/common/model/textModel.js';\nimport { EditOperation, ISingleEditOperation } from '../../../../editor/common/core/editOperation.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, RangeMapping } from '../../../../editor/common/diff/rangeMapping.js';\nimport { IInlineChatSessionService } from './inlineChatSessionService.js';\nimport { LineRange } from '../../../../editor/common/core/ranges/lineRange.js';\nimport { IEditorWorkerService } from '../../../../editor/common/services/editorWorker.js';\nimport { coalesceInPlace } from '../../../../base/common/arrays.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { IModelContentChangedEvent } from '../../../../editor/common/textModelEvents.js';\nimport { DisposableStore, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { ICodeEditor } from '../../../../editor/browser/editorBrowser.js';\nimport { IContextKey, IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { ChatModel, IChatRequestModel, IChatTextEditGroupState } from '../../chat/common/chatModel.js';\nimport { ExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { IChatAgent } from '../../chat/common/chatAgents.js';\nimport { IDocumentDiff } from '../../../../editor/common/diff/documentDiffProvider.js';\n\n\nexport type TelemetryData = {\n\textension: string;\n\trounds: string;\n\tundos: string;\n\tunstashed: number;\n\tedits: number;\n\tfinishedByEdit: boolean;\n\tstartTime: string;\n\tendTime: string;\n\tacceptedHunks: number;\n\tdiscardedHunks: number;\n\tresponseTypes: string;\n};\n\nexport type TelemetryDataClassification = {\n\towner: 'jrieken';\n\tcomment: 'Data about an interaction editor session';\n\textension: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The extension providing the data' };\n\trounds: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Number of request that were made' };\n\tundos: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Requests that have been undone' };\n\tedits: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Did edits happen while the session was active' };\n\tunstashed: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'How often did this session become stashed and resumed' };\n\tfinishedByEdit: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Did edits cause the session to terminate' };\n\tstartTime: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'When the session started' };\n\tendTime: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'When the session ended' };\n\tacceptedHunks: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Number of accepted hunks' };\n\tdiscardedHunks: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Number of discarded hunks' };\n\tresponseTypes: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'Comma separated list of response types like edits, message, mixed' };\n};\n\n\nexport class SessionWholeRange {\n\n\tprivate static readonly _options: IModelDecorationOptions = ModelDecorationOptions.register({ description: 'inlineChat/session/wholeRange' });\n\n\tprivate readonly _onDidChange = new Emitter<this>();\n\treadonly onDidChange: Event<this> = this._onDidChange.event;\n\n\tprivate _decorationIds: string[] = [];\n\n\tconstructor(private readonly _textModel: ITextModel, wholeRange: IRange) {\n\t\tthis._decorationIds = _textModel.deltaDecorations([], [{ range: wholeRange, options: SessionWholeRange._options }]);\n\t}\n\n\tdispose() {\n\t\tthis._onDidChange.dispose();\n\t\tif (!this._textModel.isDisposed()) {\n\t\t\tthis._textModel.deltaDecorations(this._decorationIds, []);\n\t\t}\n\t}\n\n\tfixup(changes: readonly DetailedLineRangeMapping[]): void {\n\t\tconst newDeco: IModelDeltaDecoration[] = [];\n\t\tfor (const { modified } of changes) {\n\t\t\tconst modifiedRange = this._textModel.validateRange(modified.isEmpty\n\t\t\t\t? new Range(modified.startLineNumber, 1, modified.startLineNumber, Number.MAX_SAFE_INTEGER)\n\t\t\t\t: new Range(modified.startLineNumber, 1, modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n\n\t\t\tnewDeco.push({ range: modifiedRange, options: SessionWholeRange._options });\n\t\t}\n\t\tconst [first, ...rest] = this._decorationIds; // first is the original whole range\n\t\tconst newIds = this._textModel.deltaDecorations(rest, newDeco);\n\t\tthis._decorationIds = [first].concat(newIds);\n\t\tthis._onDidChange.fire(this);\n\t}\n\n\tget trackedInitialRange(): Range {\n\t\tconst [first] = this._decorationIds;\n\t\treturn this._textModel.getDecorationRange(first) ?? new Range(1, 1, 1, 1);\n\t}\n\n\tget value(): Range {\n\t\tlet result: Range | undefined;\n\t\tfor (const id of this._decorationIds) {\n\t\t\tconst range = this._textModel.getDecorationRange(id);\n\t\t\tif (range) {\n\t\t\t\tif (!result) {\n\t\t\t\t\tresult = range;\n\t\t\t\t} else {\n\t\t\t\t\tresult = Range.plusRange(result, range);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result!;\n\t}\n}\n\nexport class Session {\n\n\tprivate _isUnstashed: boolean = false;\n\tprivate readonly _startTime = new Date();\n\tprivate readonly _teldata: TelemetryData;\n\n\tprivate readonly _versionByRequest = new Map<string, number>();\n\n\tconstructor(\n\t\treadonly headless: boolean,\n\t\t/**\n\t\t * The URI of the document which is being EditorEdit\n\t\t */\n\t\treadonly targetUri: URI,\n\t\t/**\n\t\t * A copy of the document at the time the session was started\n\t\t */\n\t\treadonly textModel0: ITextModel,\n\t\t/**\n\t\t * The model of the editor\n\t\t */\n\t\treadonly textModelN: ITextModel,\n\t\treadonly agent: IChatAgent,\n\t\treadonly wholeRange: SessionWholeRange,\n\t\treadonly hunkData: HunkData,\n\t\treadonly chatModel: ChatModel,\n\t\tversionsByRequest?: [string, number][], // DEBT? this is needed when a chat model is \"reused\" for a new chat session\n\t) {\n\n\t\tthis._teldata = {\n\t\t\textension: ExtensionIdentifier.toKey(agent.extensionId),\n\t\t\tstartTime: this._startTime.toISOString(),\n\t\t\tendTime: this._startTime.toISOString(),\n\t\t\tedits: 0,\n\t\t\tfinishedByEdit: false,\n\t\t\trounds: '',\n\t\t\tundos: '',\n\t\t\tunstashed: 0,\n\t\t\tacceptedHunks: 0,\n\t\t\tdiscardedHunks: 0,\n\t\t\tresponseTypes: ''\n\t\t};\n\t\tif (versionsByRequest) {\n\t\t\tthis._versionByRequest = new Map(versionsByRequest);\n\t\t}\n\t}\n\n\tget isUnstashed(): boolean {\n\t\treturn this._isUnstashed;\n\t}\n\n\tmarkUnstashed() {\n\t\tthis._teldata.unstashed! += 1;\n\t\tthis._isUnstashed = true;\n\t}\n\n\tmarkModelVersion(request: IChatRequestModel) {\n\t\tthis._versionByRequest.set(request.id, this.textModelN.getAlternativeVersionId());\n\t}\n\n\tget versionsByRequest() {\n\t\treturn Array.from(this._versionByRequest);\n\t}\n\n\tasync undoChangesUntil(requestId: string): Promise<boolean> {\n\n\t\tconst targetAltVersion = this._versionByRequest.get(requestId);\n\t\tif (targetAltVersion === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\t// undo till this point\n\t\tthis.hunkData.ignoreTextModelNChanges = true;\n\t\ttry {\n\t\t\twhile (targetAltVersion < this.textModelN.getAlternativeVersionId() && this.textModelN.canUndo()) {\n\t\t\t\tawait this.textModelN.undo();\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.hunkData.ignoreTextModelNChanges = false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tget hasChangedText(): boolean {\n\t\treturn !this.textModel0.equalsTextBuffer(this.textModelN.getTextBuffer());\n\t}\n\n\tasChangedText(changes: readonly LineRangeMapping[]): string | undefined {\n\t\tif (changes.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet startLine = Number.MAX_VALUE;\n\t\tlet endLine = Number.MIN_VALUE;\n\t\tfor (const change of changes) {\n\t\t\tstartLine = Math.min(startLine, change.modified.startLineNumber);\n\t\t\tendLine = Math.max(endLine, change.modified.endLineNumberExclusive);\n\t\t}\n\n\t\treturn this.textModelN.getValueInRange(new Range(startLine, 1, endLine, Number.MAX_VALUE));\n\t}\n\n\trecordExternalEditOccurred(didFinish: boolean) {\n\t\tthis._teldata.edits += 1;\n\t\tthis._teldata.finishedByEdit = didFinish;\n\t}\n\n\tasTelemetryData(): TelemetryData {\n\n\t\tfor (const item of this.hunkData.getInfo()) {\n\t\t\tswitch (item.getState()) {\n\t\t\t\tcase HunkState.Accepted:\n\t\t\t\t\tthis._teldata.acceptedHunks += 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase HunkState.Rejected:\n\t\t\t\t\tthis._teldata.discardedHunks += 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis._teldata.endTime = new Date().toISOString();\n\t\treturn this._teldata;\n\t}\n}\n\n\nexport class StashedSession {\n\n\tprivate readonly _listener: IDisposable;\n\tprivate readonly _ctxHasStashedSession: IContextKey<boolean>;\n\tprivate _session: Session | undefined;\n\n\tconstructor(\n\t\teditor: ICodeEditor,\n\t\tsession: Session,\n\t\tprivate readonly _undoCancelEdits: IValidEditOperation[],\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@IInlineChatSessionService private readonly _sessionService: IInlineChatSessionService,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tthis._ctxHasStashedSession = CTX_INLINE_CHAT_HAS_STASHED_SESSION.bindTo(contextKeyService);\n\n\t\t// keep session for a little bit, only release when user continues to work (type, move cursor, etc.)\n\t\tthis._session = session;\n\t\tthis._ctxHasStashedSession.set(true);\n\t\tthis._listener = Event.once(Event.any(editor.onDidChangeCursorSelection, editor.onDidChangeModelContent, editor.onDidChangeModel, editor.onDidBlurEditorWidget))(() => {\n\t\t\tthis._session = undefined;\n\t\t\tthis._sessionService.releaseSession(session);\n\t\t\tthis._ctxHasStashedSession.reset();\n\t\t});\n\t}\n\n\tdispose() {\n\t\tthis._listener.dispose();\n\t\tthis._ctxHasStashedSession.reset();\n\t\tif (this._session) {\n\t\t\tthis._sessionService.releaseSession(this._session);\n\t\t}\n\t}\n\n\tunstash(): Session | undefined {\n\t\tif (!this._session) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._listener.dispose();\n\t\tconst result = this._session;\n\t\tresult.markUnstashed();\n\t\tresult.hunkData.ignoreTextModelNChanges = true;\n\t\tresult.textModelN.pushEditOperations(null, this._undoCancelEdits, () => null);\n\t\tresult.hunkData.ignoreTextModelNChanges = false;\n\t\tthis._session = undefined;\n\t\tthis._logService.debug('[IE] Unstashed session');\n\t\treturn result;\n\t}\n}\n\n// ---\n\nfunction lineRangeAsRange(lineRange: LineRange, model: ITextModel): Range {\n\treturn lineRange.isEmpty\n\t\t? new Range(lineRange.startLineNumber, 1, lineRange.startLineNumber, Number.MAX_SAFE_INTEGER)\n\t\t: new Range(lineRange.startLineNumber, 1, lineRange.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n}\n\nexport class HunkData {\n\n\tprivate static readonly _HUNK_TRACKED_RANGE = ModelDecorationOptions.register({\n\t\tdescription: 'inline-chat-hunk-tracked-range',\n\t\tstickiness: TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n\t});\n\n\tprivate static readonly _HUNK_THRESHOLD = 8;\n\n\tprivate readonly _store = new DisposableStore();\n\tprivate readonly _data = new Map<RawHunk, RawHunkData>();\n\tprivate _ignoreChanges: boolean = false;\n\n\tconstructor(\n\t\t@IEditorWorkerService private readonly _editorWorkerService: IEditorWorkerService,\n\t\tprivate readonly _textModel0: ITextModel,\n\t\tprivate readonly _textModelN: ITextModel,\n\t) {\n\n\t\tthis._store.add(_textModelN.onDidChangeContent(e => {\n\t\t\tif (!this._ignoreChanges) {\n\t\t\t\tthis._mirrorChanges(e);\n\t\t\t}\n\t\t}));\n\t}\n\n\tdispose(): void {\n\t\tif (!this._textModelN.isDisposed()) {\n\t\t\tthis._textModelN.changeDecorations(accessor => {\n\t\t\t\tfor (const { textModelNDecorations } of this._data.values()) {\n\t\t\t\t\ttextModelNDecorations.forEach(accessor.removeDecoration, accessor);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (!this._textModel0.isDisposed()) {\n\t\t\tthis._textModel0.changeDecorations(accessor => {\n\t\t\t\tfor (const { textModel0Decorations } of this._data.values()) {\n\t\t\t\t\ttextModel0Decorations.forEach(accessor.removeDecoration, accessor);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis._data.clear();\n\t\tthis._store.dispose();\n\t}\n\n\tset ignoreTextModelNChanges(value: boolean) {\n\t\tthis._ignoreChanges = value;\n\t}\n\n\tget ignoreTextModelNChanges(): boolean {\n\t\treturn this._ignoreChanges;\n\t}\n\n\tprivate _mirrorChanges(event: IModelContentChangedEvent) {\n\n\t\t// mirror textModelN changes to textModel0 execept for those that\n\t\t// overlap with a hunk\n\n\t\ttype HunkRangePair = { rangeN: Range; range0: Range; markAccepted: () => void };\n\t\tconst hunkRanges: HunkRangePair[] = [];\n\n\t\tconst ranges0: Range[] = [];\n\n\t\tfor (const entry of this._data.values()) {\n\n\t\t\tif (entry.state === HunkState.Pending) {\n\t\t\t\t// pending means the hunk's changes aren't \"sync'd\" yet\n\t\t\t\tfor (let i = 1; i < entry.textModelNDecorations.length; i++) {\n\t\t\t\t\tconst rangeN = this._textModelN.getDecorationRange(entry.textModelNDecorations[i]);\n\t\t\t\t\tconst range0 = this._textModel0.getDecorationRange(entry.textModel0Decorations[i]);\n\t\t\t\t\tif (rangeN && range0) {\n\t\t\t\t\t\thunkRanges.push({\n\t\t\t\t\t\t\trangeN, range0,\n\t\t\t\t\t\t\tmarkAccepted: () => entry.state = HunkState.Accepted\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (entry.state === HunkState.Accepted) {\n\t\t\t\t// accepted means the hunk's changes are also in textModel0\n\t\t\t\tfor (let i = 1; i < entry.textModel0Decorations.length; i++) {\n\t\t\t\t\tconst range = this._textModel0.getDecorationRange(entry.textModel0Decorations[i]);\n\t\t\t\t\tif (range) {\n\t\t\t\t\t\tranges0.push(range);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thunkRanges.sort((a, b) => Range.compareRangesUsingStarts(a.rangeN, b.rangeN));\n\t\tranges0.sort(Range.compareRangesUsingStarts);\n\n\t\tconst edits: IIdentifiedSingleEditOperation[] = [];\n\n\t\tfor (const change of event.changes) {\n\n\t\t\tlet isOverlapping = false;\n\n\t\t\tlet pendingChangesLen = 0;\n\n\t\t\tfor (const entry of hunkRanges) {\n\t\t\t\tif (entry.rangeN.getEndPosition().isBefore(Range.getStartPosition(change.range))) {\n\t\t\t\t\t// pending hunk _before_ this change. When projecting into textModel0 we need to\n\t\t\t\t\t// subtract that. Because diffing is relaxed it might include changes that are not\n\t\t\t\t\t// actual insertions/deletions. Therefore we need to take the length of the original\n\t\t\t\t\t// range into account.\n\t\t\t\t\tpendingChangesLen += this._textModelN.getValueLengthInRange(entry.rangeN);\n\t\t\t\t\tpendingChangesLen -= this._textModel0.getValueLengthInRange(entry.range0);\n\n\t\t\t\t} else if (Range.areIntersectingOrTouching(entry.rangeN, change.range)) {\n\t\t\t\t\t// an edit overlaps with a (pending) hunk. We take this as a signal\n\t\t\t\t\t// to mark the hunk as accepted and to ignore the edit. The range of the hunk\n\t\t\t\t\t// will be up-to-date because of decorations created for them\n\t\t\t\t\tentry.markAccepted();\n\t\t\t\t\tisOverlapping = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\t\t\t\t\t// hunks past this change aren't relevant\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isOverlapping) {\n\t\t\t\t// hunk overlaps, it grew\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst offset0 = change.rangeOffset - pendingChangesLen;\n\t\t\tconst start0 = this._textModel0.getPositionAt(offset0);\n\n\t\t\tlet acceptedChangesLen = 0;\n\t\t\tfor (const range of ranges0) {\n\t\t\t\tif (range.getEndPosition().isBefore(start0)) {\n\t\t\t\t\t// accepted hunk _before_ this projected change. When projecting into textModel0\n\t\t\t\t\t// we need to add that\n\t\t\t\t\tacceptedChangesLen += this._textModel0.getValueLengthInRange(range);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst start = this._textModel0.getPositionAt(offset0 + acceptedChangesLen);\n\t\t\tconst end = this._textModel0.getPositionAt(offset0 + acceptedChangesLen + change.rangeLength);\n\t\t\tedits.push(EditOperation.replace(Range.fromPositions(start, end), change.text));\n\t\t}\n\n\t\tthis._textModel0.pushEditOperations(null, edits, () => null);\n\t}\n\n\tasync recompute(editState: IChatTextEditGroupState, diff?: IDocumentDiff | null) {\n\n\t\tdiff ??= await this._editorWorkerService.computeDiff(this._textModel0.uri, this._textModelN.uri, { ignoreTrimWhitespace: false, maxComputationTimeMs: Number.MAX_SAFE_INTEGER, computeMoves: false }, 'advanced');\n\n\t\tlet mergedChanges: DetailedLineRangeMapping[] = [];\n\n\t\tif (diff && diff.changes.length > 0) {\n\t\t\t// merge changes neighboring changes\n\t\t\tmergedChanges = [diff.changes[0]];\n\t\t\tfor (let i = 1; i < diff.changes.length; i++) {\n\t\t\t\tconst lastChange = mergedChanges[mergedChanges.length - 1];\n\t\t\t\tconst thisChange = diff.changes[i];\n\t\t\t\tif (thisChange.modified.startLineNumber - lastChange.modified.endLineNumberExclusive <= HunkData._HUNK_THRESHOLD) {\n\t\t\t\t\tmergedChanges[mergedChanges.length - 1] = new DetailedLineRangeMapping(\n\t\t\t\t\t\tlastChange.original.join(thisChange.original),\n\t\t\t\t\t\tlastChange.modified.join(thisChange.modified),\n\t\t\t\t\t\t(lastChange.innerChanges ?? []).concat(thisChange.innerChanges ?? [])\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tmergedChanges.push(thisChange);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst hunks = mergedChanges.map(change => new RawHunk(change.original, change.modified, change.innerChanges ?? []));\n\n\t\teditState.applied = hunks.length;\n\n\t\tthis._textModelN.changeDecorations(accessorN => {\n\n\t\t\tthis._textModel0.changeDecorations(accessor0 => {\n\n\t\t\t\t// clean up old decorations\n\t\t\t\tfor (const { textModelNDecorations, textModel0Decorations } of this._data.values()) {\n\t\t\t\t\ttextModelNDecorations.forEach(accessorN.removeDecoration, accessorN);\n\t\t\t\t\ttextModel0Decorations.forEach(accessor0.removeDecoration, accessor0);\n\t\t\t\t}\n\n\t\t\t\tthis._data.clear();\n\n\t\t\t\t// add new decorations\n\t\t\t\tfor (const hunk of hunks) {\n\n\t\t\t\t\tconst textModelNDecorations: string[] = [];\n\t\t\t\t\tconst textModel0Decorations: string[] = [];\n\n\t\t\t\t\ttextModelNDecorations.push(accessorN.addDecoration(lineRangeAsRange(hunk.modified, this._textModelN), HunkData._HUNK_TRACKED_RANGE));\n\t\t\t\t\ttextModel0Decorations.push(accessor0.addDecoration(lineRangeAsRange(hunk.original, this._textModel0), HunkData._HUNK_TRACKED_RANGE));\n\n\t\t\t\t\tfor (const change of hunk.changes) {\n\t\t\t\t\t\ttextModelNDecorations.push(accessorN.addDecoration(change.modifiedRange, HunkData._HUNK_TRACKED_RANGE));\n\t\t\t\t\t\ttextModel0Decorations.push(accessor0.addDecoration(change.originalRange, HunkData._HUNK_TRACKED_RANGE));\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._data.set(hunk, {\n\t\t\t\t\t\teditState,\n\t\t\t\t\t\ttextModelNDecorations,\n\t\t\t\t\t\ttextModel0Decorations,\n\t\t\t\t\t\tstate: HunkState.Pending\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tget size(): number {\n\t\treturn this._data.size;\n\t}\n\n\tget pending(): number {\n\t\treturn Iterable.reduce(this._data.values(), (r, { state }) => r + (state === HunkState.Pending ? 1 : 0), 0);\n\t}\n\n\tprivate _discardEdits(item: HunkInformation): ISingleEditOperation[] {\n\t\tconst edits: ISingleEditOperation[] = [];\n\t\tconst rangesN = item.getRangesN();\n\t\tconst ranges0 = item.getRanges0();\n\t\tfor (let i = 1; i < rangesN.length; i++) {\n\t\t\tconst modifiedRange = rangesN[i];\n\n\t\t\tconst originalValue = this._textModel0.getValueInRange(ranges0[i]);\n\t\t\tedits.push(EditOperation.replace(modifiedRange, originalValue));\n\t\t}\n\t\treturn edits;\n\t}\n\n\tdiscardAll() {\n\t\tconst edits: ISingleEditOperation[][] = [];\n\t\tfor (const item of this.getInfo()) {\n\t\t\tif (item.getState() === HunkState.Pending) {\n\t\t\t\tedits.push(this._discardEdits(item));\n\t\t\t}\n\t\t}\n\t\tconst undoEdits: IValidEditOperation[][] = [];\n\t\tthis._textModelN.pushEditOperations(null, edits.flat(), (_undoEdits) => {\n\t\t\tundoEdits.push(_undoEdits);\n\t\t\treturn null;\n\t\t});\n\t\treturn undoEdits.flat();\n\t}\n\n\tgetInfo(): HunkInformation[] {\n\n\t\tconst result: HunkInformation[] = [];\n\n\t\tfor (const [hunk, data] of this._data.entries()) {\n\t\t\tconst item: HunkInformation = {\n\t\t\t\tgetState: () => {\n\t\t\t\t\treturn data.state;\n\t\t\t\t},\n\t\t\t\tisInsertion: () => {\n\t\t\t\t\treturn hunk.original.isEmpty;\n\t\t\t\t},\n\t\t\t\tgetRangesN: () => {\n\t\t\t\t\tconst ranges = data.textModelNDecorations.map(id => this._textModelN.getDecorationRange(id));\n\t\t\t\t\tcoalesceInPlace(ranges);\n\t\t\t\t\treturn ranges;\n\t\t\t\t},\n\t\t\t\tgetRanges0: () => {\n\t\t\t\t\tconst ranges = data.textModel0Decorations.map(id => this._textModel0.getDecorationRange(id));\n\t\t\t\t\tcoalesceInPlace(ranges);\n\t\t\t\t\treturn ranges;\n\t\t\t\t},\n\t\t\t\tdiscardChanges: () => {\n\t\t\t\t\t// DISCARD: replace modified range with original value. The modified range is retrieved from a decoration\n\t\t\t\t\t// which was created above so that typing in the editor keeps discard working.\n\t\t\t\t\tif (data.state === HunkState.Pending) {\n\t\t\t\t\t\tconst edits = this._discardEdits(item);\n\t\t\t\t\t\tthis._textModelN.pushEditOperations(null, edits, () => null);\n\t\t\t\t\t\tdata.state = HunkState.Rejected;\n\t\t\t\t\t\tif (data.editState.applied > 0) {\n\t\t\t\t\t\t\tdata.editState.applied -= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tacceptChanges: () => {\n\t\t\t\t\t// ACCEPT: replace original range with modified value. The modified value is retrieved from the model via\n\t\t\t\t\t// its decoration and the original range is retrieved from the hunk.\n\t\t\t\t\tif (data.state === HunkState.Pending) {\n\t\t\t\t\t\tconst edits: ISingleEditOperation[] = [];\n\t\t\t\t\t\tconst rangesN = item.getRangesN();\n\t\t\t\t\t\tconst ranges0 = item.getRanges0();\n\t\t\t\t\t\tfor (let i = 1; i < ranges0.length; i++) {\n\t\t\t\t\t\t\tconst originalRange = ranges0[i];\n\t\t\t\t\t\t\tconst modifiedValue = this._textModelN.getValueInRange(rangesN[i]);\n\t\t\t\t\t\t\tedits.push(EditOperation.replace(originalRange, modifiedValue));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._textModel0.pushEditOperations(null, edits, () => null);\n\t\t\t\t\t\tdata.state = HunkState.Accepted;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tresult.push(item);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nclass RawHunk {\n\tconstructor(\n\t\treadonly original: LineRange,\n\t\treadonly modified: LineRange,\n\t\treadonly changes: RangeMapping[]\n\t) { }\n}\n\ntype RawHunkData = {\n\ttextModelNDecorations: string[];\n\ttextModel0Decorations: string[];\n\tstate: HunkState;\n\teditState: IChatTextEditGroupState;\n};\n\nexport const enum HunkState {\n\tPending = 0,\n\tAccepted = 1,\n\tRejected = 2\n}\n\nexport interface HunkInformation {\n\t/**\n\t * The first element [0] is the whole modified range and subsequent elements are word-level changes\n\t */\n\tgetRangesN(): Range[];\n\n\tgetRanges0(): Range[];\n\n\tisInsertion(): boolean;\n\n\tdiscardChanges(): void;\n\n\t/**\n\t * Accept the hunk. Applies the corresponding edits into textModel0\n\t */\n\tacceptChanges(): void;\n\n\tgetState(): HunkState;\n}\n"]}