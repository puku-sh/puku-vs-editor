{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/debug/common/debugUtils.ts","vs/workbench/contrib/debug/common/debugUtils.ts"],"names":[],"mappings":"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","file":"debugUtils.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equalsIgnoreCase } from '../../../../base/common/strings.js';\nimport { IDebuggerContribution, IDebugSession, IConfigPresentation, State } from './debug.js';\nimport { URI as uri } from '../../../../base/common/uri.js';\nimport { isAbsolute } from '../../../../base/common/path.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { ITextModel } from '../../../../editor/common/model.js';\nimport { Position } from '../../../../editor/common/core/position.js';\nimport { IRange, Range } from '../../../../editor/common/core/range.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { ILanguageFeaturesService } from '../../../../editor/common/services/languageFeatures.js';\n\nconst _formatPIIRegexp = /{([^}]+)}/g;\n\nexport function formatPII(value: string, excludePII: boolean, args: { [key: string]: string } | undefined): string {\n\treturn value.replace(_formatPIIRegexp, function (match, group) {\n\t\tif (excludePII && group.length > 0 && group[0] !== '_') {\n\t\t\treturn match;\n\t\t}\n\n\t\treturn args && args.hasOwnProperty(group) ?\n\t\t\targs[group] :\n\t\t\tmatch;\n\t});\n}\n\n/**\n * Filters exceptions (keys marked with \"!\") from the given object. Used to\n * ensure exception data is not sent on web remotes, see #97628.\n */\nexport function filterExceptionsFromTelemetry<T extends { [key: string]: unknown }>(data: T): Partial<T> {\n\tconst output: Partial<T> = {};\n\tfor (const key of Object.keys(data) as (keyof T & string)[]) {\n\t\tif (!key.startsWith('!')) {\n\t\t\toutput[key] = data[key];\n\t\t}\n\t}\n\n\treturn output;\n}\n\n\nexport function isSessionAttach(session: IDebugSession): boolean {\n\treturn session.configuration.request === 'attach' && !getExtensionHostDebugSession(session) && (!session.parentSession || isSessionAttach(session.parentSession));\n}\n\n/**\n * Returns the session or any parent which is an extension host debug session.\n * Returns undefined if there's none.\n */\nexport function getExtensionHostDebugSession(session: IDebugSession): IDebugSession | void {\n\tlet type = session.configuration.type;\n\tif (!type) {\n\t\treturn;\n\t}\n\n\tif (type === 'vslsShare') {\n\t\ttype = (session.configuration as { adapterProxy?: { configuration?: { type?: string } } }).adapterProxy?.configuration?.type || type;\n\t}\n\n\tif (equalsIgnoreCase(type, 'extensionhost') || equalsIgnoreCase(type, 'pwa-extensionhost')) {\n\t\treturn session;\n\t}\n\n\treturn session.parentSession ? getExtensionHostDebugSession(session.parentSession) : undefined;\n}\n\n// only a debugger contributions with a label, program, or runtime attribute is considered a \"defining\" or \"main\" debugger contribution\nexport function isDebuggerMainContribution(dbg: IDebuggerContribution) {\n\treturn dbg.type && (dbg.label || dbg.program || dbg.runtime);\n}\n\n/**\n * Note- uses 1-indexed numbers\n */\nexport function getExactExpressionStartAndEnd(lineContent: string, looseStart: number, looseEnd: number): { start: number; end: number } {\n\tlet matchingExpression: string | undefined = undefined;\n\tlet startOffset = 0;\n\n\t// Some example supported expressions: myVar.prop, a.b.c.d, myVar?.prop, myVar->prop, MyClass::StaticProp, *myVar, ...foo\n\t// Match any character except a set of characters which often break interesting sub-expressions\n\tconst expression: RegExp = /([^()\\[\\]{}<>\\s+\\-/%~#^;=|,`!]|\\->)+/g;\n\tlet result: RegExpExecArray | null = null;\n\n\t// First find the full expression under the cursor\n\twhile (result = expression.exec(lineContent)) {\n\t\tconst start = result.index + 1;\n\t\tconst end = start + result[0].length;\n\n\t\tif (start <= looseStart && end >= looseEnd) {\n\t\t\tmatchingExpression = result[0];\n\t\t\tstartOffset = start;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Handle spread syntax: if the expression starts with '...', extract just the identifier\n\tif (matchingExpression) {\n\t\tconst spreadMatch = matchingExpression.match(/^\\.\\.\\.(.+)/);\n\t\tif (spreadMatch) {\n\t\t\tmatchingExpression = spreadMatch[1];\n\t\t\tstartOffset += 3; // Skip the '...' prefix\n\t\t}\n\t}\n\n\t// If there are non-word characters after the cursor, we want to truncate the expression then.\n\t// For example in expression 'a.b.c.d', if the focus was under 'b', 'a.b' would be evaluated.\n\tif (matchingExpression) {\n\t\tconst subExpression: RegExp = /(\\w|\\p{L})+/gu;\n\t\tlet subExpressionResult: RegExpExecArray | null = null;\n\t\twhile (subExpressionResult = subExpression.exec(matchingExpression)) {\n\t\t\tconst subEnd = subExpressionResult.index + 1 + startOffset + subExpressionResult[0].length;\n\t\t\tif (subEnd >= looseEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (subExpressionResult) {\n\t\t\tmatchingExpression = matchingExpression.substring(0, subExpression.lastIndex);\n\t\t}\n\t}\n\n\treturn matchingExpression ?\n\t\t{ start: startOffset, end: startOffset + matchingExpression.length - 1 } :\n\t\t{ start: 0, end: 0 };\n}\n\nexport async function getEvaluatableExpressionAtPosition(languageFeaturesService: ILanguageFeaturesService, model: ITextModel, position: Position, token?: CancellationToken): Promise<{ range: IRange; matchingExpression: string } | null> {\n\tif (languageFeaturesService.evaluatableExpressionProvider.has(model)) {\n\t\tconst supports = languageFeaturesService.evaluatableExpressionProvider.ordered(model);\n\n\t\tconst results = coalesce(await Promise.all(supports.map(async support => {\n\t\t\ttry {\n\t\t\t\treturn await support.provideEvaluatableExpression(model, position, token ?? CancellationToken.None);\n\t\t\t} catch (err) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t})));\n\n\t\tif (results.length > 0) {\n\t\t\tlet matchingExpression = results[0].expression;\n\t\t\tconst range = results[0].range;\n\n\t\t\tif (!matchingExpression) {\n\t\t\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\t\t\tmatchingExpression = lineContent.substring(range.startColumn - 1, range.endColumn - 1);\n\t\t\t}\n\n\t\t\treturn { range, matchingExpression };\n\t\t}\n\t} else { // old one-size-fits-all strategy\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst { start, end } = getExactExpressionStartAndEnd(lineContent, position.column, position.column);\n\n\t\t// use regex to extract the sub-expression #9821\n\t\tconst matchingExpression = lineContent.substring(start - 1, end);\n\t\treturn {\n\t\t\tmatchingExpression,\n\t\t\trange: new Range(position.lineNumber, start, position.lineNumber, start + matchingExpression.length)\n\t\t};\n\t}\n\n\treturn null;\n}\n\n// RFC 2396, Appendix A: https://www.ietf.org/rfc/rfc2396.txt\nconst _schemePattern = /^[a-zA-Z][a-zA-Z0-9\\+\\-\\.]+:/;\n\nexport function isUriString(s: string | undefined): boolean {\n\t// heuristics: a valid uri starts with a scheme and\n\t// the scheme has at least 2 characters so that it doesn't look like a drive letter.\n\treturn !!(s && s.match(_schemePattern));\n}\n\nfunction stringToUri(source: PathContainer): string | undefined {\n\tif (typeof source.path === 'string') {\n\t\tif (typeof source.sourceReference === 'number' && source.sourceReference > 0) {\n\t\t\t// if there is a source reference, don't touch path\n\t\t} else {\n\t\t\tif (isUriString(source.path)) {\n\t\t\t\treturn <string><unknown>uri.parse(source.path);\n\t\t\t} else {\n\t\t\t\t// assume path\n\t\t\t\tif (isAbsolute(source.path)) {\n\t\t\t\t\treturn <string><unknown>uri.file(source.path);\n\t\t\t\t} else {\n\t\t\t\t\t// leave relative path as is\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn source.path;\n}\n\nfunction uriToString(source: PathContainer): string | undefined {\n\tif (typeof source.path === 'object') {\n\t\tconst u = uri.revive(source.path);\n\t\tif (u) {\n\t\t\tif (u.scheme === Schemas.file) {\n\t\t\t\treturn u.fsPath;\n\t\t\t} else {\n\t\t\t\treturn u.toString();\n\t\t\t}\n\t\t}\n\t}\n\treturn source.path;\n}\n\n// path hooks helpers\n\ninterface PathContainer {\n\tpath?: string;\n\tsourceReference?: number;\n}\n\nexport function convertToDAPaths(message: DebugProtocol.ProtocolMessage, toUri: boolean): DebugProtocol.ProtocolMessage {\n\n\tconst fixPath = toUri ? stringToUri : uriToString;\n\n\t// since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n\tconst msg = deepClone(message);\n\n\tconvertPaths(msg, (toDA: boolean, source: PathContainer | undefined) => {\n\t\tif (toDA && source) {\n\t\t\tsource.path = fixPath(source);\n\t\t}\n\t});\n\treturn msg;\n}\n\nexport function convertToVSCPaths(message: DebugProtocol.ProtocolMessage, toUri: boolean): DebugProtocol.ProtocolMessage {\n\n\tconst fixPath = toUri ? stringToUri : uriToString;\n\n\t// since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n\tconst msg = deepClone(message);\n\n\tconvertPaths(msg, (toDA: boolean, source: PathContainer | undefined) => {\n\t\tif (!toDA && source) {\n\t\t\tsource.path = fixPath(source);\n\t\t}\n\t});\n\treturn msg;\n}\n\nfunction convertPaths(msg: DebugProtocol.ProtocolMessage, fixSourcePath: (toDA: boolean, source: PathContainer | undefined) => void): void {\n\n\tswitch (msg.type) {\n\t\tcase 'event': {\n\t\t\tconst event = <DebugProtocol.Event>msg;\n\t\t\tswitch (event.event) {\n\t\t\t\tcase 'output':\n\t\t\t\t\tfixSourcePath(false, (<DebugProtocol.OutputEvent>event).body.source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'loadedSource':\n\t\t\t\t\tfixSourcePath(false, (<DebugProtocol.LoadedSourceEvent>event).body.source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'breakpoint':\n\t\t\t\t\tfixSourcePath(false, (<DebugProtocol.BreakpointEvent>event).body.breakpoint.source);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'request': {\n\t\t\tconst request = <DebugProtocol.Request>msg;\n\t\t\tswitch (request.command) {\n\t\t\t\tcase 'setBreakpoints':\n\t\t\t\t\tfixSourcePath(true, (<DebugProtocol.SetBreakpointsArguments>request.arguments).source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'breakpointLocations':\n\t\t\t\t\tfixSourcePath(true, (<DebugProtocol.BreakpointLocationsArguments>request.arguments).source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'source':\n\t\t\t\t\tfixSourcePath(true, (<DebugProtocol.SourceArguments>request.arguments).source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'gotoTargets':\n\t\t\t\t\tfixSourcePath(true, (<DebugProtocol.GotoTargetsArguments>request.arguments).source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'launchVSCode':\n\t\t\t\t\trequest.arguments.args.forEach((arg: PathContainer | undefined) => fixSourcePath(false, arg));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'response': {\n\t\t\tconst response = <DebugProtocol.Response>msg;\n\t\t\tif (response.success && response.body) {\n\t\t\t\tswitch (response.command) {\n\t\t\t\t\tcase 'stackTrace':\n\t\t\t\t\t\t(<DebugProtocol.StackTraceResponse>response).body.stackFrames.forEach(frame => fixSourcePath(false, frame.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'loadedSources':\n\t\t\t\t\t\t(<DebugProtocol.LoadedSourcesResponse>response).body.sources.forEach(source => fixSourcePath(false, source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'scopes':\n\t\t\t\t\t\t(<DebugProtocol.ScopesResponse>response).body.scopes.forEach(scope => fixSourcePath(false, scope.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'setFunctionBreakpoints':\n\t\t\t\t\t\t(<DebugProtocol.SetFunctionBreakpointsResponse>response).body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'setBreakpoints':\n\t\t\t\t\t\t(<DebugProtocol.SetBreakpointsResponse>response).body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'disassemble':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst di = <DebugProtocol.DisassembleResponse>response;\n\t\t\t\t\t\t\tdi.body?.instructions.forEach(di => fixSourcePath(false, di.location));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'locations':\n\t\t\t\t\t\tfixSourcePath(false, (<DebugProtocol.LocationsResponse>response).body?.source);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport function getVisibleAndSorted<T extends { presentation?: IConfigPresentation }>(array: T[]): T[] {\n\treturn array.filter(config => !config.presentation?.hidden).sort((first, second) => {\n\t\tif (!first.presentation) {\n\t\t\tif (!second.presentation) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (!second.presentation) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!first.presentation.group) {\n\t\t\tif (!second.presentation.group) {\n\t\t\t\treturn compareOrders(first.presentation.order, second.presentation.order);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (!second.presentation.group) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (first.presentation.group !== second.presentation.group) {\n\t\t\treturn first.presentation.group.localeCompare(second.presentation.group);\n\t\t}\n\n\t\treturn compareOrders(first.presentation.order, second.presentation.order);\n\t});\n}\n\nfunction compareOrders(first: number | undefined, second: number | undefined): number {\n\tif (typeof first !== 'number') {\n\t\tif (typeof second !== 'number') {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\tif (typeof second !== 'number') {\n\t\treturn -1;\n\t}\n\n\treturn first - second;\n}\n\nexport async function saveAllBeforeDebugStart(configurationService: IConfigurationService, editorService: IEditorService): Promise<void> {\n\tconst saveBeforeStartConfig: string = configurationService.getValue('debug.saveBeforeStart', { overrideIdentifier: editorService.activeTextEditorLanguageId });\n\tif (saveBeforeStartConfig !== 'none') {\n\t\tawait editorService.saveAll();\n\t\tif (saveBeforeStartConfig === 'allEditorsInActiveGroup') {\n\t\t\tconst activeEditor = editorService.activeEditorPane;\n\t\t\tif (activeEditor && activeEditor.input.resource?.scheme === Schemas.untitled) {\n\t\t\t\t// Make sure to save the active editor in case it is in untitled file it wont be saved as part of saveAll #111850\n\t\t\t\tawait editorService.save({ editor: activeEditor.input, groupId: activeEditor.group.id });\n\t\t\t}\n\t\t}\n\t}\n\tawait configurationService.reloadConfiguration();\n}\n\nexport const sourcesEqual = (a: DebugProtocol.Source | undefined, b: DebugProtocol.Source | undefined): boolean =>\n\t!a || !b ? a === b : a.name === b.name && a.path === b.path && a.sourceReference === b.sourceReference;\n\n/**\n * Resolves the best child session to focus when a parent session is selected.\n * Always prefer child sessions over parent wrapper sessions to ensure console responsiveness.\n * Fixes issue #152407: Using debug console picker when not paused leaves console unresponsive.\n */\nexport function resolveChildSession(session: IDebugSession, allSessions: readonly IDebugSession[]): IDebugSession {\n\t// Always focus child session instead of parent wrapper session #152407\n\tconst childSessions = allSessions.filter(s => s.parentSession === session);\n\tif (childSessions.length > 0) {\n\t\t// Prefer stopped child session if available #112595\n\t\tconst stoppedChildSession = childSessions.find(s => s.state === State.Stopped);\n\t\tif (stoppedChildSession) {\n\t\t\treturn stoppedChildSession;\n\t\t} else {\n\t\t\t// If no stopped child, focus the first available child session\n\t\t\treturn childSessions[0];\n\t\t}\n\t}\n\t// Return the original session if it has no children\n\treturn session;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equalsIgnoreCase } from '../../../../base/common/strings.js';\nimport { IDebuggerContribution, IDebugSession, IConfigPresentation, State } from './debug.js';\nimport { URI as uri } from '../../../../base/common/uri.js';\nimport { isAbsolute } from '../../../../base/common/path.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { ITextModel } from '../../../../editor/common/model.js';\nimport { Position } from '../../../../editor/common/core/position.js';\nimport { IRange, Range } from '../../../../editor/common/core/range.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { ILanguageFeaturesService } from '../../../../editor/common/services/languageFeatures.js';\n\nconst _formatPIIRegexp = /{([^}]+)}/g;\n\nexport function formatPII(value: string, excludePII: boolean, args: { [key: string]: string } | undefined): string {\n\treturn value.replace(_formatPIIRegexp, function (match, group) {\n\t\tif (excludePII && group.length > 0 && group[0] !== '_') {\n\t\t\treturn match;\n\t\t}\n\n\t\treturn args && args.hasOwnProperty(group) ?\n\t\t\targs[group] :\n\t\t\tmatch;\n\t});\n}\n\n/**\n * Filters exceptions (keys marked with \"!\") from the given object. Used to\n * ensure exception data is not sent on web remotes, see #97628.\n */\nexport function filterExceptionsFromTelemetry<T extends { [key: string]: unknown }>(data: T): Partial<T> {\n\tconst output: Partial<T> = {};\n\tfor (const key of Object.keys(data) as (keyof T & string)[]) {\n\t\tif (!key.startsWith('!')) {\n\t\t\toutput[key] = data[key];\n\t\t}\n\t}\n\n\treturn output;\n}\n\n\nexport function isSessionAttach(session: IDebugSession): boolean {\n\treturn session.configuration.request === 'attach' && !getExtensionHostDebugSession(session) && (!session.parentSession || isSessionAttach(session.parentSession));\n}\n\n/**\n * Returns the session or any parent which is an extension host debug session.\n * Returns undefined if there's none.\n */\nexport function getExtensionHostDebugSession(session: IDebugSession): IDebugSession | void {\n\tlet type = session.configuration.type;\n\tif (!type) {\n\t\treturn;\n\t}\n\n\tif (type === 'vslsShare') {\n\t\ttype = (session.configuration as { adapterProxy?: { configuration?: { type?: string } } }).adapterProxy?.configuration?.type || type;\n\t}\n\n\tif (equalsIgnoreCase(type, 'extensionhost') || equalsIgnoreCase(type, 'pwa-extensionhost')) {\n\t\treturn session;\n\t}\n\n\treturn session.parentSession ? getExtensionHostDebugSession(session.parentSession) : undefined;\n}\n\n// only a debugger contributions with a label, program, or runtime attribute is considered a \"defining\" or \"main\" debugger contribution\nexport function isDebuggerMainContribution(dbg: IDebuggerContribution) {\n\treturn dbg.type && (dbg.label || dbg.program || dbg.runtime);\n}\n\n/**\n * Note- uses 1-indexed numbers\n */\nexport function getExactExpressionStartAndEnd(lineContent: string, looseStart: number, looseEnd: number): { start: number; end: number } {\n\tlet matchingExpression: string | undefined = undefined;\n\tlet startOffset = 0;\n\n\t// Some example supported expressions: myVar.prop, a.b.c.d, myVar?.prop, myVar->prop, MyClass::StaticProp, *myVar, ...foo\n\t// Match any character except a set of characters which often break interesting sub-expressions\n\tconst expression: RegExp = /([^()\\[\\]{}<>\\s+\\-/%~#^;=|,`!]|\\->)+/g;\n\tlet result: RegExpExecArray | null = null;\n\n\t// First find the full expression under the cursor\n\twhile (result = expression.exec(lineContent)) {\n\t\tconst start = result.index + 1;\n\t\tconst end = start + result[0].length;\n\n\t\tif (start <= looseStart && end >= looseEnd) {\n\t\t\tmatchingExpression = result[0];\n\t\t\tstartOffset = start;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Handle spread syntax: if the expression starts with '...', extract just the identifier\n\tif (matchingExpression) {\n\t\tconst spreadMatch = matchingExpression.match(/^\\.\\.\\.(.+)/);\n\t\tif (spreadMatch) {\n\t\t\tmatchingExpression = spreadMatch[1];\n\t\t\tstartOffset += 3; // Skip the '...' prefix\n\t\t}\n\t}\n\n\t// If there are non-word characters after the cursor, we want to truncate the expression then.\n\t// For example in expression 'a.b.c.d', if the focus was under 'b', 'a.b' would be evaluated.\n\tif (matchingExpression) {\n\t\tconst subExpression: RegExp = /(\\w|\\p{L})+/gu;\n\t\tlet subExpressionResult: RegExpExecArray | null = null;\n\t\twhile (subExpressionResult = subExpression.exec(matchingExpression)) {\n\t\t\tconst subEnd = subExpressionResult.index + 1 + startOffset + subExpressionResult[0].length;\n\t\t\tif (subEnd >= looseEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (subExpressionResult) {\n\t\t\tmatchingExpression = matchingExpression.substring(0, subExpression.lastIndex);\n\t\t}\n\t}\n\n\treturn matchingExpression ?\n\t\t{ start: startOffset, end: startOffset + matchingExpression.length - 1 } :\n\t\t{ start: 0, end: 0 };\n}\n\nexport async function getEvaluatableExpressionAtPosition(languageFeaturesService: ILanguageFeaturesService, model: ITextModel, position: Position, token?: CancellationToken): Promise<{ range: IRange; matchingExpression: string } | null> {\n\tif (languageFeaturesService.evaluatableExpressionProvider.has(model)) {\n\t\tconst supports = languageFeaturesService.evaluatableExpressionProvider.ordered(model);\n\n\t\tconst results = coalesce(await Promise.all(supports.map(async support => {\n\t\t\ttry {\n\t\t\t\treturn await support.provideEvaluatableExpression(model, position, token ?? CancellationToken.None);\n\t\t\t} catch (err) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t})));\n\n\t\tif (results.length > 0) {\n\t\t\tlet matchingExpression = results[0].expression;\n\t\t\tconst range = results[0].range;\n\n\t\t\tif (!matchingExpression) {\n\t\t\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\t\t\tmatchingExpression = lineContent.substring(range.startColumn - 1, range.endColumn - 1);\n\t\t\t}\n\n\t\t\treturn { range, matchingExpression };\n\t\t}\n\t} else { // old one-size-fits-all strategy\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst { start, end } = getExactExpressionStartAndEnd(lineContent, position.column, position.column);\n\n\t\t// use regex to extract the sub-expression #9821\n\t\tconst matchingExpression = lineContent.substring(start - 1, end);\n\t\treturn {\n\t\t\tmatchingExpression,\n\t\t\trange: new Range(position.lineNumber, start, position.lineNumber, start + matchingExpression.length)\n\t\t};\n\t}\n\n\treturn null;\n}\n\n// RFC 2396, Appendix A: https://www.ietf.org/rfc/rfc2396.txt\nconst _schemePattern = /^[a-zA-Z][a-zA-Z0-9\\+\\-\\.]+:/;\n\nexport function isUriString(s: string | undefined): boolean {\n\t// heuristics: a valid uri starts with a scheme and\n\t// the scheme has at least 2 characters so that it doesn't look like a drive letter.\n\treturn !!(s && s.match(_schemePattern));\n}\n\nfunction stringToUri(source: PathContainer): string | undefined {\n\tif (typeof source.path === 'string') {\n\t\tif (typeof source.sourceReference === 'number' && source.sourceReference > 0) {\n\t\t\t// if there is a source reference, don't touch path\n\t\t} else {\n\t\t\tif (isUriString(source.path)) {\n\t\t\t\treturn <string><unknown>uri.parse(source.path);\n\t\t\t} else {\n\t\t\t\t// assume path\n\t\t\t\tif (isAbsolute(source.path)) {\n\t\t\t\t\treturn <string><unknown>uri.file(source.path);\n\t\t\t\t} else {\n\t\t\t\t\t// leave relative path as is\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn source.path;\n}\n\nfunction uriToString(source: PathContainer): string | undefined {\n\tif (typeof source.path === 'object') {\n\t\tconst u = uri.revive(source.path);\n\t\tif (u) {\n\t\t\tif (u.scheme === Schemas.file) {\n\t\t\t\treturn u.fsPath;\n\t\t\t} else {\n\t\t\t\treturn u.toString();\n\t\t\t}\n\t\t}\n\t}\n\treturn source.path;\n}\n\n// path hooks helpers\n\ninterface PathContainer {\n\tpath?: string;\n\tsourceReference?: number;\n}\n\nexport function convertToDAPaths(message: DebugProtocol.ProtocolMessage, toUri: boolean): DebugProtocol.ProtocolMessage {\n\n\tconst fixPath = toUri ? stringToUri : uriToString;\n\n\t// since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n\tconst msg = deepClone(message);\n\n\tconvertPaths(msg, (toDA: boolean, source: PathContainer | undefined) => {\n\t\tif (toDA && source) {\n\t\t\tsource.path = fixPath(source);\n\t\t}\n\t});\n\treturn msg;\n}\n\nexport function convertToVSCPaths(message: DebugProtocol.ProtocolMessage, toUri: boolean): DebugProtocol.ProtocolMessage {\n\n\tconst fixPath = toUri ? stringToUri : uriToString;\n\n\t// since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n\tconst msg = deepClone(message);\n\n\tconvertPaths(msg, (toDA: boolean, source: PathContainer | undefined) => {\n\t\tif (!toDA && source) {\n\t\t\tsource.path = fixPath(source);\n\t\t}\n\t});\n\treturn msg;\n}\n\nfunction convertPaths(msg: DebugProtocol.ProtocolMessage, fixSourcePath: (toDA: boolean, source: PathContainer | undefined) => void): void {\n\n\tswitch (msg.type) {\n\t\tcase 'event': {\n\t\t\tconst event = <DebugProtocol.Event>msg;\n\t\t\tswitch (event.event) {\n\t\t\t\tcase 'output':\n\t\t\t\t\tfixSourcePath(false, (<DebugProtocol.OutputEvent>event).body.source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'loadedSource':\n\t\t\t\t\tfixSourcePath(false, (<DebugProtocol.LoadedSourceEvent>event).body.source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'breakpoint':\n\t\t\t\t\tfixSourcePath(false, (<DebugProtocol.BreakpointEvent>event).body.breakpoint.source);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'request': {\n\t\t\tconst request = <DebugProtocol.Request>msg;\n\t\t\tswitch (request.command) {\n\t\t\t\tcase 'setBreakpoints':\n\t\t\t\t\tfixSourcePath(true, (<DebugProtocol.SetBreakpointsArguments>request.arguments).source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'breakpointLocations':\n\t\t\t\t\tfixSourcePath(true, (<DebugProtocol.BreakpointLocationsArguments>request.arguments).source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'source':\n\t\t\t\t\tfixSourcePath(true, (<DebugProtocol.SourceArguments>request.arguments).source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'gotoTargets':\n\t\t\t\t\tfixSourcePath(true, (<DebugProtocol.GotoTargetsArguments>request.arguments).source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'launchVSCode':\n\t\t\t\t\trequest.arguments.args.forEach((arg: PathContainer | undefined) => fixSourcePath(false, arg));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'response': {\n\t\t\tconst response = <DebugProtocol.Response>msg;\n\t\t\tif (response.success && response.body) {\n\t\t\t\tswitch (response.command) {\n\t\t\t\t\tcase 'stackTrace':\n\t\t\t\t\t\t(<DebugProtocol.StackTraceResponse>response).body.stackFrames.forEach(frame => fixSourcePath(false, frame.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'loadedSources':\n\t\t\t\t\t\t(<DebugProtocol.LoadedSourcesResponse>response).body.sources.forEach(source => fixSourcePath(false, source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'scopes':\n\t\t\t\t\t\t(<DebugProtocol.ScopesResponse>response).body.scopes.forEach(scope => fixSourcePath(false, scope.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'setFunctionBreakpoints':\n\t\t\t\t\t\t(<DebugProtocol.SetFunctionBreakpointsResponse>response).body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'setBreakpoints':\n\t\t\t\t\t\t(<DebugProtocol.SetBreakpointsResponse>response).body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'disassemble':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst di = <DebugProtocol.DisassembleResponse>response;\n\t\t\t\t\t\t\tdi.body?.instructions.forEach(di => fixSourcePath(false, di.location));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'locations':\n\t\t\t\t\t\tfixSourcePath(false, (<DebugProtocol.LocationsResponse>response).body?.source);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport function getVisibleAndSorted<T extends { presentation?: IConfigPresentation }>(array: T[]): T[] {\n\treturn array.filter(config => !config.presentation?.hidden).sort((first, second) => {\n\t\tif (!first.presentation) {\n\t\t\tif (!second.presentation) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (!second.presentation) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!first.presentation.group) {\n\t\t\tif (!second.presentation.group) {\n\t\t\t\treturn compareOrders(first.presentation.order, second.presentation.order);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (!second.presentation.group) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (first.presentation.group !== second.presentation.group) {\n\t\t\treturn first.presentation.group.localeCompare(second.presentation.group);\n\t\t}\n\n\t\treturn compareOrders(first.presentation.order, second.presentation.order);\n\t});\n}\n\nfunction compareOrders(first: number | undefined, second: number | undefined): number {\n\tif (typeof first !== 'number') {\n\t\tif (typeof second !== 'number') {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\tif (typeof second !== 'number') {\n\t\treturn -1;\n\t}\n\n\treturn first - second;\n}\n\nexport async function saveAllBeforeDebugStart(configurationService: IConfigurationService, editorService: IEditorService): Promise<void> {\n\tconst saveBeforeStartConfig: string = configurationService.getValue('debug.saveBeforeStart', { overrideIdentifier: editorService.activeTextEditorLanguageId });\n\tif (saveBeforeStartConfig !== 'none') {\n\t\tawait editorService.saveAll();\n\t\tif (saveBeforeStartConfig === 'allEditorsInActiveGroup') {\n\t\t\tconst activeEditor = editorService.activeEditorPane;\n\t\t\tif (activeEditor && activeEditor.input.resource?.scheme === Schemas.untitled) {\n\t\t\t\t// Make sure to save the active editor in case it is in untitled file it wont be saved as part of saveAll #111850\n\t\t\t\tawait editorService.save({ editor: activeEditor.input, groupId: activeEditor.group.id });\n\t\t\t}\n\t\t}\n\t}\n\tawait configurationService.reloadConfiguration();\n}\n\nexport const sourcesEqual = (a: DebugProtocol.Source | undefined, b: DebugProtocol.Source | undefined): boolean =>\n\t!a || !b ? a === b : a.name === b.name && a.path === b.path && a.sourceReference === b.sourceReference;\n\n/**\n * Resolves the best child session to focus when a parent session is selected.\n * Always prefer child sessions over parent wrapper sessions to ensure console responsiveness.\n * Fixes issue #152407: Using debug console picker when not paused leaves console unresponsive.\n */\nexport function resolveChildSession(session: IDebugSession, allSessions: readonly IDebugSession[]): IDebugSession {\n\t// Always focus child session instead of parent wrapper session #152407\n\tconst childSessions = allSessions.filter(s => s.parentSession === session);\n\tif (childSessions.length > 0) {\n\t\t// Prefer stopped child session if available #112595\n\t\tconst stoppedChildSession = childSessions.find(s => s.state === State.Stopped);\n\t\tif (stoppedChildSession) {\n\t\t\treturn stoppedChildSession;\n\t\t} else {\n\t\t\t// If no stopped child, focus the first available child session\n\t\t\treturn childSessions[0];\n\t\t}\n\t}\n\t// Return the original session if it has no children\n\treturn session;\n}\n"]}