{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/debug/common/debugVisualizers.ts","vs/workbench/contrib/debug/common/debugVisualizers.ts"],"names":[],"mappings":"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","file":"debugVisualizers.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IDisposable, IReference, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { isDefined } from '../../../../base/common/types.js';\nimport { ContextKeyExpr, ContextKeyExpression, IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ExtensionIdentifier, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { CONTEXT_VARIABLE_NAME, CONTEXT_VARIABLE_TYPE, CONTEXT_VARIABLE_VALUE, MainThreadDebugVisualization, IDebugVisualization, IDebugVisualizationContext, IExpression, IExpressionContainer, IDebugVisualizationTreeItem, IDebugSession } from './debug.js';\nimport { getContextForVariable } from './debugContext.js';\nimport { Scope, Variable, VisualizedExpression } from './debugModel.js';\nimport { IExtensionService } from '../../../services/extensions/common/extensions.js';\nimport { ExtensionsRegistry } from '../../../services/extensions/common/extensionsRegistry.js';\n\nexport const IDebugVisualizerService = createDecorator<IDebugVisualizerService>('debugVisualizerService');\n\ninterface VisualizerHandle {\n\tid: string;\n\textensionId: ExtensionIdentifier;\n\tprovideDebugVisualizers(context: IDebugVisualizationContext, token: CancellationToken): Promise<IDebugVisualization[]>;\n\tresolveDebugVisualizer(viz: IDebugVisualization, token: CancellationToken): Promise<MainThreadDebugVisualization>;\n\texecuteDebugVisualizerCommand(id: number): Promise<void>;\n\tdisposeDebugVisualizers(ids: number[]): void;\n}\n\ninterface VisualizerTreeHandle {\n\tgetTreeItem(element: IDebugVisualizationContext): Promise<IDebugVisualizationTreeItem | undefined>;\n\tgetChildren(element: number): Promise<IDebugVisualizationTreeItem[]>;\n\tdisposeItem(element: number): void;\n\teditItem?(item: number, value: string): Promise<IDebugVisualizationTreeItem | undefined>;\n}\n\nexport class DebugVisualizer {\n\tpublic get name() {\n\t\treturn this.viz.name;\n\t}\n\n\tpublic get iconPath() {\n\t\treturn this.viz.iconPath;\n\t}\n\n\tpublic get iconClass() {\n\t\treturn this.viz.iconClass;\n\t}\n\n\tconstructor(private readonly handle: VisualizerHandle, private readonly viz: IDebugVisualization) { }\n\n\tpublic async resolve(token: CancellationToken) {\n\t\treturn this.viz.visualization ??= await this.handle.resolveDebugVisualizer(this.viz, token);\n\t}\n\n\tpublic async execute() {\n\t\tawait this.handle.executeDebugVisualizerCommand(this.viz.id);\n\t}\n}\n\nexport interface IDebugVisualizerService {\n\t_serviceBrand: undefined;\n\n\t/**\n\t * Gets visualizers applicable for the given Expression.\n\t */\n\tgetApplicableFor(expression: IExpression, token: CancellationToken): Promise<IReference<DebugVisualizer[]>>;\n\n\t/**\n\t * Registers a new visualizer (called from the main thread debug service)\n\t */\n\tregister(handle: VisualizerHandle): IDisposable;\n\n\t/**\n\t * Registers a new visualizer tree.\n\t */\n\tregisterTree(treeId: string, handle: VisualizerTreeHandle): IDisposable;\n\n\t/**\n\t * Sets that a certa tree should be used for the visualized node\n\t */\n\tgetVisualizedNodeFor(treeId: string, expr: IExpression): Promise<VisualizedExpression | undefined>;\n\n\t/**\n\t * Gets children for a visualized tree node.\n\t */\n\tgetVisualizedChildren(session: IDebugSession | undefined, treeId: string, treeElementId: number): Promise<IExpression[]>;\n\n\t/**\n\t * Gets children for a visualized tree node.\n\t */\n\teditTreeItem(treeId: string, item: IDebugVisualizationTreeItem, newValue: string): Promise<void>;\n}\n\nconst emptyRef: IReference<DebugVisualizer[]> = { object: [], dispose: () => { } };\n\nexport class DebugVisualizerService implements IDebugVisualizerService {\n\tdeclare public readonly _serviceBrand: undefined;\n\n\tprivate readonly handles = new Map</* extId + \\0 + vizId */ string, VisualizerHandle>();\n\tprivate readonly trees = new Map</* extId + \\0 + treeId */ string, VisualizerTreeHandle>();\n\tprivate readonly didActivate = new Map<string, Promise<void>>();\n\tprivate registrations: { expr: ContextKeyExpression; id: string; extensionId: ExtensionIdentifier }[] = [];\n\n\tconstructor(\n\t\t@IContextKeyService private readonly contextKeyService: IContextKeyService,\n\t\t@IExtensionService private readonly extensionService: IExtensionService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tvisualizersExtensionPoint.setHandler((_, { added, removed }) => {\n\t\t\tthis.registrations = this.registrations.filter(r =>\n\t\t\t\t!removed.some(e => ExtensionIdentifier.equals(e.description.identifier, r.extensionId)));\n\t\t\tadded.forEach(e => this.processExtensionRegistration(e.description));\n\t\t});\n\t}\n\n\t/** @inheritdoc */\n\tpublic async getApplicableFor(variable: IExpression, token: CancellationToken): Promise<IReference<DebugVisualizer[]>> {\n\t\tif (!(variable instanceof Variable)) {\n\t\t\treturn emptyRef;\n\t\t}\n\t\tconst threadId = variable.getThreadId();\n\t\tif (threadId === undefined) { // an expression, not a variable\n\t\t\treturn emptyRef;\n\t\t}\n\n\t\tconst context = this.getVariableContext(threadId, variable);\n\t\tconst overlay = getContextForVariable(this.contextKeyService, variable, [\n\t\t\t[CONTEXT_VARIABLE_NAME.key, variable.name],\n\t\t\t[CONTEXT_VARIABLE_VALUE.key, variable.value],\n\t\t\t[CONTEXT_VARIABLE_TYPE.key, variable.type],\n\t\t]);\n\n\t\tconst maybeVisualizers = await Promise.all(this.registrations.map(async registration => {\n\t\t\tif (!overlay.contextMatchesRules(registration.expr)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet prom = this.didActivate.get(registration.id);\n\t\t\tif (!prom) {\n\t\t\t\tprom = this.extensionService.activateByEvent(`onDebugVisualizer:${registration.id}`);\n\t\t\t\tthis.didActivate.set(registration.id, prom);\n\t\t\t}\n\n\t\t\tawait prom;\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst handle = this.handles.get(toKey(registration.extensionId, registration.id));\n\t\t\treturn handle && { handle, result: await handle.provideDebugVisualizers(context, token) };\n\t\t}));\n\n\t\tconst ref = {\n\t\t\tobject: maybeVisualizers.filter(isDefined).flatMap(v => v.result.map(r => new DebugVisualizer(v.handle, r))),\n\t\t\tdispose: () => {\n\t\t\t\tfor (const viz of maybeVisualizers) {\n\t\t\t\t\tviz?.handle.disposeDebugVisualizers(viz.result.map(r => r.id));\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\n\t\tif (token.isCancellationRequested) {\n\t\t\tref.dispose();\n\t\t}\n\n\t\treturn ref;\n\t}\n\n\t/** @inheritdoc */\n\tpublic register(handle: VisualizerHandle): IDisposable {\n\t\tconst key = toKey(handle.extensionId, handle.id);\n\t\tthis.handles.set(key, handle);\n\t\treturn toDisposable(() => this.handles.delete(key));\n\t}\n\n\t/** @inheritdoc */\n\tpublic registerTree(treeId: string, handle: VisualizerTreeHandle): IDisposable {\n\t\tthis.trees.set(treeId, handle);\n\t\treturn toDisposable(() => this.trees.delete(treeId));\n\t}\n\n\t/** @inheritdoc */\n\tpublic async getVisualizedNodeFor(treeId: string, expr: IExpression): Promise<VisualizedExpression | undefined> {\n\t\tif (!(expr instanceof Variable)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst threadId = expr.getThreadId();\n\t\tif (threadId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tree = this.trees.get(treeId);\n\t\tif (!tree) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst treeItem = await tree.getTreeItem(this.getVariableContext(threadId, expr));\n\t\t\tif (!treeItem) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn new VisualizedExpression(expr.getSession(), this, treeId, treeItem, expr);\n\t\t} catch (e) {\n\t\t\tthis.logService.warn('Failed to get visualized node', e);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/** @inheritdoc */\n\tpublic async getVisualizedChildren(session: IDebugSession | undefined, treeId: string, treeElementId: number): Promise<IExpression[]> {\n\t\tconst node = this.trees.get(treeId);\n\t\tconst children = await node?.getChildren(treeElementId) || [];\n\t\treturn children.map(c => new VisualizedExpression(session, this, treeId, c, undefined));\n\t}\n\n\t/** @inheritdoc */\n\tpublic async editTreeItem(treeId: string, treeItem: IDebugVisualizationTreeItem, newValue: string): Promise<void> {\n\t\tconst newItem = await this.trees.get(treeId)?.editItem?.(treeItem.id, newValue);\n\t\tif (newItem) {\n\t\t\tObject.assign(treeItem, newItem); // replace in-place so rerenders work\n\t\t}\n\t}\n\n\tprivate getVariableContext(threadId: number, variable: Variable) {\n\t\tconst context: IDebugVisualizationContext = {\n\t\t\tsessionId: variable.getSession()?.getId() || '',\n\t\t\tcontainerId: (variable.parent instanceof Variable ? variable.reference : undefined),\n\t\t\tthreadId,\n\t\t\tvariable: {\n\t\t\t\tname: variable.name,\n\t\t\t\tvalue: variable.value,\n\t\t\t\ttype: variable.type,\n\t\t\t\tevaluateName: variable.evaluateName,\n\t\t\t\tvariablesReference: variable.reference || 0,\n\t\t\t\tindexedVariables: variable.indexedVariables,\n\t\t\t\tmemoryReference: variable.memoryReference,\n\t\t\t\tnamedVariables: variable.namedVariables,\n\t\t\t\tpresentationHint: variable.presentationHint,\n\t\t\t}\n\t\t};\n\n\t\tfor (let p: IExpressionContainer = variable; p instanceof Variable; p = p.parent) {\n\t\t\tif (p.parent instanceof Scope) {\n\t\t\t\tcontext.frameId = p.parent.stackFrame.frameId;\n\t\t\t}\n\t\t}\n\n\t\treturn context;\n\t}\n\n\tprivate processExtensionRegistration(ext: IExtensionDescription) {\n\t\tconst viz = ext.contributes?.debugVisualizers;\n\t\tif (!(viz instanceof Array)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const { when, id } of viz) {\n\t\t\ttry {\n\t\t\t\tconst expr = ContextKeyExpr.deserialize(when);\n\t\t\t\tif (expr) {\n\t\t\t\t\tthis.registrations.push({ expr, id, extensionId: ext.identifier });\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis.logService.error(`Error processing debug visualizer registration from extension '${ext.identifier.value}'`, e);\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst toKey = (extensionId: ExtensionIdentifier, id: string) => `${ExtensionIdentifier.toKey(extensionId)}\\0${id}`;\n\nconst visualizersExtensionPoint = ExtensionsRegistry.registerExtensionPoint<{ id: string; when: string }[]>({\n\textensionPoint: 'debugVisualizers',\n\tjsonSchema: {\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'object',\n\t\t\tproperties: {\n\t\t\t\tid: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'Name of the debug visualizer'\n\t\t\t\t},\n\t\t\t\twhen: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'Condition when the debug visualizer is applicable'\n\t\t\t\t}\n\t\t\t},\n\t\t\trequired: ['id', 'when']\n\t\t}\n\t},\n\tactivationEventsGenerator: function* (contribs) {\n\t\tfor (const contrib of contribs) {\n\t\t\tif (contrib.id) {\n\t\t\t\tyield `onDebugVisualizer:${contrib.id}`;\n\t\t\t}\n\t\t}\n\t}\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IDisposable, IReference, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { isDefined } from '../../../../base/common/types.js';\nimport { ContextKeyExpr, ContextKeyExpression, IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ExtensionIdentifier, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { CONTEXT_VARIABLE_NAME, CONTEXT_VARIABLE_TYPE, CONTEXT_VARIABLE_VALUE, MainThreadDebugVisualization, IDebugVisualization, IDebugVisualizationContext, IExpression, IExpressionContainer, IDebugVisualizationTreeItem, IDebugSession } from './debug.js';\nimport { getContextForVariable } from './debugContext.js';\nimport { Scope, Variable, VisualizedExpression } from './debugModel.js';\nimport { IExtensionService } from '../../../services/extensions/common/extensions.js';\nimport { ExtensionsRegistry } from '../../../services/extensions/common/extensionsRegistry.js';\n\nexport const IDebugVisualizerService = createDecorator<IDebugVisualizerService>('debugVisualizerService');\n\ninterface VisualizerHandle {\n\tid: string;\n\textensionId: ExtensionIdentifier;\n\tprovideDebugVisualizers(context: IDebugVisualizationContext, token: CancellationToken): Promise<IDebugVisualization[]>;\n\tresolveDebugVisualizer(viz: IDebugVisualization, token: CancellationToken): Promise<MainThreadDebugVisualization>;\n\texecuteDebugVisualizerCommand(id: number): Promise<void>;\n\tdisposeDebugVisualizers(ids: number[]): void;\n}\n\ninterface VisualizerTreeHandle {\n\tgetTreeItem(element: IDebugVisualizationContext): Promise<IDebugVisualizationTreeItem | undefined>;\n\tgetChildren(element: number): Promise<IDebugVisualizationTreeItem[]>;\n\tdisposeItem(element: number): void;\n\teditItem?(item: number, value: string): Promise<IDebugVisualizationTreeItem | undefined>;\n}\n\nexport class DebugVisualizer {\n\tpublic get name() {\n\t\treturn this.viz.name;\n\t}\n\n\tpublic get iconPath() {\n\t\treturn this.viz.iconPath;\n\t}\n\n\tpublic get iconClass() {\n\t\treturn this.viz.iconClass;\n\t}\n\n\tconstructor(private readonly handle: VisualizerHandle, private readonly viz: IDebugVisualization) { }\n\n\tpublic async resolve(token: CancellationToken) {\n\t\treturn this.viz.visualization ??= await this.handle.resolveDebugVisualizer(this.viz, token);\n\t}\n\n\tpublic async execute() {\n\t\tawait this.handle.executeDebugVisualizerCommand(this.viz.id);\n\t}\n}\n\nexport interface IDebugVisualizerService {\n\t_serviceBrand: undefined;\n\n\t/**\n\t * Gets visualizers applicable for the given Expression.\n\t */\n\tgetApplicableFor(expression: IExpression, token: CancellationToken): Promise<IReference<DebugVisualizer[]>>;\n\n\t/**\n\t * Registers a new visualizer (called from the main thread debug service)\n\t */\n\tregister(handle: VisualizerHandle): IDisposable;\n\n\t/**\n\t * Registers a new visualizer tree.\n\t */\n\tregisterTree(treeId: string, handle: VisualizerTreeHandle): IDisposable;\n\n\t/**\n\t * Sets that a certa tree should be used for the visualized node\n\t */\n\tgetVisualizedNodeFor(treeId: string, expr: IExpression): Promise<VisualizedExpression | undefined>;\n\n\t/**\n\t * Gets children for a visualized tree node.\n\t */\n\tgetVisualizedChildren(session: IDebugSession | undefined, treeId: string, treeElementId: number): Promise<IExpression[]>;\n\n\t/**\n\t * Gets children for a visualized tree node.\n\t */\n\teditTreeItem(treeId: string, item: IDebugVisualizationTreeItem, newValue: string): Promise<void>;\n}\n\nconst emptyRef: IReference<DebugVisualizer[]> = { object: [], dispose: () => { } };\n\nexport class DebugVisualizerService implements IDebugVisualizerService {\n\tdeclare public readonly _serviceBrand: undefined;\n\n\tprivate readonly handles = new Map</* extId + \\0 + vizId */ string, VisualizerHandle>();\n\tprivate readonly trees = new Map</* extId + \\0 + treeId */ string, VisualizerTreeHandle>();\n\tprivate readonly didActivate = new Map<string, Promise<void>>();\n\tprivate registrations: { expr: ContextKeyExpression; id: string; extensionId: ExtensionIdentifier }[] = [];\n\n\tconstructor(\n\t\t@IContextKeyService private readonly contextKeyService: IContextKeyService,\n\t\t@IExtensionService private readonly extensionService: IExtensionService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tvisualizersExtensionPoint.setHandler((_, { added, removed }) => {\n\t\t\tthis.registrations = this.registrations.filter(r =>\n\t\t\t\t!removed.some(e => ExtensionIdentifier.equals(e.description.identifier, r.extensionId)));\n\t\t\tadded.forEach(e => this.processExtensionRegistration(e.description));\n\t\t});\n\t}\n\n\t/** @inheritdoc */\n\tpublic async getApplicableFor(variable: IExpression, token: CancellationToken): Promise<IReference<DebugVisualizer[]>> {\n\t\tif (!(variable instanceof Variable)) {\n\t\t\treturn emptyRef;\n\t\t}\n\t\tconst threadId = variable.getThreadId();\n\t\tif (threadId === undefined) { // an expression, not a variable\n\t\t\treturn emptyRef;\n\t\t}\n\n\t\tconst context = this.getVariableContext(threadId, variable);\n\t\tconst overlay = getContextForVariable(this.contextKeyService, variable, [\n\t\t\t[CONTEXT_VARIABLE_NAME.key, variable.name],\n\t\t\t[CONTEXT_VARIABLE_VALUE.key, variable.value],\n\t\t\t[CONTEXT_VARIABLE_TYPE.key, variable.type],\n\t\t]);\n\n\t\tconst maybeVisualizers = await Promise.all(this.registrations.map(async registration => {\n\t\t\tif (!overlay.contextMatchesRules(registration.expr)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet prom = this.didActivate.get(registration.id);\n\t\t\tif (!prom) {\n\t\t\t\tprom = this.extensionService.activateByEvent(`onDebugVisualizer:${registration.id}`);\n\t\t\t\tthis.didActivate.set(registration.id, prom);\n\t\t\t}\n\n\t\t\tawait prom;\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst handle = this.handles.get(toKey(registration.extensionId, registration.id));\n\t\t\treturn handle && { handle, result: await handle.provideDebugVisualizers(context, token) };\n\t\t}));\n\n\t\tconst ref = {\n\t\t\tobject: maybeVisualizers.filter(isDefined).flatMap(v => v.result.map(r => new DebugVisualizer(v.handle, r))),\n\t\t\tdispose: () => {\n\t\t\t\tfor (const viz of maybeVisualizers) {\n\t\t\t\t\tviz?.handle.disposeDebugVisualizers(viz.result.map(r => r.id));\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\n\t\tif (token.isCancellationRequested) {\n\t\t\tref.dispose();\n\t\t}\n\n\t\treturn ref;\n\t}\n\n\t/** @inheritdoc */\n\tpublic register(handle: VisualizerHandle): IDisposable {\n\t\tconst key = toKey(handle.extensionId, handle.id);\n\t\tthis.handles.set(key, handle);\n\t\treturn toDisposable(() => this.handles.delete(key));\n\t}\n\n\t/** @inheritdoc */\n\tpublic registerTree(treeId: string, handle: VisualizerTreeHandle): IDisposable {\n\t\tthis.trees.set(treeId, handle);\n\t\treturn toDisposable(() => this.trees.delete(treeId));\n\t}\n\n\t/** @inheritdoc */\n\tpublic async getVisualizedNodeFor(treeId: string, expr: IExpression): Promise<VisualizedExpression | undefined> {\n\t\tif (!(expr instanceof Variable)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst threadId = expr.getThreadId();\n\t\tif (threadId === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tree = this.trees.get(treeId);\n\t\tif (!tree) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst treeItem = await tree.getTreeItem(this.getVariableContext(threadId, expr));\n\t\t\tif (!treeItem) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn new VisualizedExpression(expr.getSession(), this, treeId, treeItem, expr);\n\t\t} catch (e) {\n\t\t\tthis.logService.warn('Failed to get visualized node', e);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/** @inheritdoc */\n\tpublic async getVisualizedChildren(session: IDebugSession | undefined, treeId: string, treeElementId: number): Promise<IExpression[]> {\n\t\tconst node = this.trees.get(treeId);\n\t\tconst children = await node?.getChildren(treeElementId) || [];\n\t\treturn children.map(c => new VisualizedExpression(session, this, treeId, c, undefined));\n\t}\n\n\t/** @inheritdoc */\n\tpublic async editTreeItem(treeId: string, treeItem: IDebugVisualizationTreeItem, newValue: string): Promise<void> {\n\t\tconst newItem = await this.trees.get(treeId)?.editItem?.(treeItem.id, newValue);\n\t\tif (newItem) {\n\t\t\tObject.assign(treeItem, newItem); // replace in-place so rerenders work\n\t\t}\n\t}\n\n\tprivate getVariableContext(threadId: number, variable: Variable) {\n\t\tconst context: IDebugVisualizationContext = {\n\t\t\tsessionId: variable.getSession()?.getId() || '',\n\t\t\tcontainerId: (variable.parent instanceof Variable ? variable.reference : undefined),\n\t\t\tthreadId,\n\t\t\tvariable: {\n\t\t\t\tname: variable.name,\n\t\t\t\tvalue: variable.value,\n\t\t\t\ttype: variable.type,\n\t\t\t\tevaluateName: variable.evaluateName,\n\t\t\t\tvariablesReference: variable.reference || 0,\n\t\t\t\tindexedVariables: variable.indexedVariables,\n\t\t\t\tmemoryReference: variable.memoryReference,\n\t\t\t\tnamedVariables: variable.namedVariables,\n\t\t\t\tpresentationHint: variable.presentationHint,\n\t\t\t}\n\t\t};\n\n\t\tfor (let p: IExpressionContainer = variable; p instanceof Variable; p = p.parent) {\n\t\t\tif (p.parent instanceof Scope) {\n\t\t\t\tcontext.frameId = p.parent.stackFrame.frameId;\n\t\t\t}\n\t\t}\n\n\t\treturn context;\n\t}\n\n\tprivate processExtensionRegistration(ext: IExtensionDescription) {\n\t\tconst viz = ext.contributes?.debugVisualizers;\n\t\tif (!(viz instanceof Array)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const { when, id } of viz) {\n\t\t\ttry {\n\t\t\t\tconst expr = ContextKeyExpr.deserialize(when);\n\t\t\t\tif (expr) {\n\t\t\t\t\tthis.registrations.push({ expr, id, extensionId: ext.identifier });\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis.logService.error(`Error processing debug visualizer registration from extension '${ext.identifier.value}'`, e);\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst toKey = (extensionId: ExtensionIdentifier, id: string) => `${ExtensionIdentifier.toKey(extensionId)}\\0${id}`;\n\nconst visualizersExtensionPoint = ExtensionsRegistry.registerExtensionPoint<{ id: string; when: string }[]>({\n\textensionPoint: 'debugVisualizers',\n\tjsonSchema: {\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'object',\n\t\t\tproperties: {\n\t\t\t\tid: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'Name of the debug visualizer'\n\t\t\t\t},\n\t\t\t\twhen: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'Condition when the debug visualizer is applicable'\n\t\t\t\t}\n\t\t\t},\n\t\t\trequired: ['id', 'when']\n\t\t}\n\t},\n\tactivationEventsGenerator: function* (contribs) {\n\t\tfor (const contrib of contribs) {\n\t\t\tif (contrib.id) {\n\t\t\t\tyield `onDebugVisualizer:${contrib.id}`;\n\t\t\t}\n\t\t}\n\t}\n});\n"]}