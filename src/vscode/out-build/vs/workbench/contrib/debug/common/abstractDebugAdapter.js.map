{"version":3,"sources":["vs/workbench/contrib/debug/common/abstractDebugAdapter.ts"],"names":[],"mappings":"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","file":"abstractDebugAdapter.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { IDebugAdapter } from './debug.js';\nimport { timeout } from '../../../../base/common/async.js';\nimport { localize } from '../../../../nls.js';\n\n/**\n * Abstract implementation of the low level API for a debug adapter.\n * Missing is how this API communicates with the debug adapter.\n */\nexport abstract class AbstractDebugAdapter implements IDebugAdapter {\n\tprivate sequence: number;\n\tprivate pendingRequests = new Map<number, (e: DebugProtocol.Response) => void>();\n\tprivate requestCallback: ((request: DebugProtocol.Request) => void) | undefined;\n\tprivate eventCallback: ((request: DebugProtocol.Event) => void) | undefined;\n\tprivate messageCallback: ((message: DebugProtocol.ProtocolMessage) => void) | undefined;\n\tprivate queue: DebugProtocol.ProtocolMessage[] = [];\n\tprotected readonly _onError = new Emitter<Error>();\n\tprotected readonly _onExit = new Emitter<number | null>();\n\n\tconstructor() {\n\t\tthis.sequence = 1;\n\t}\n\n\tabstract startSession(): Promise<void>;\n\n\tabstract stopSession(): Promise<void>;\n\n\tabstract sendMessage(message: DebugProtocol.ProtocolMessage): void;\n\n\tget onError(): Event<Error> {\n\t\treturn this._onError.event;\n\t}\n\n\tget onExit(): Event<number | null> {\n\t\treturn this._onExit.event;\n\t}\n\n\tonMessage(callback: (message: DebugProtocol.ProtocolMessage) => void): void {\n\t\tif (this.messageCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Message' callback`));\n\t\t}\n\t\tthis.messageCallback = callback;\n\t}\n\n\tonEvent(callback: (event: DebugProtocol.Event) => void): void {\n\t\tif (this.eventCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Event' callback`));\n\t\t}\n\t\tthis.eventCallback = callback;\n\t}\n\n\tonRequest(callback: (request: DebugProtocol.Request) => void): void {\n\t\tif (this.requestCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Request' callback`));\n\t\t}\n\t\tthis.requestCallback = callback;\n\t}\n\n\tsendResponse(response: DebugProtocol.Response): void {\n\t\tif (response.seq > 0) {\n\t\t\tthis._onError.fire(new Error(`attempt to send more than one response for command ${response.command}`));\n\t\t} else {\n\t\t\tthis.internalSend('response', response);\n\t\t}\n\t}\n\n\tsendRequest(command: string, args: any, clb: (result: DebugProtocol.Response) => void, timeout?: number): number {\n\t\tconst request: any = {\n\t\t\tcommand: command\n\t\t};\n\t\tif (args && Object.keys(args).length > 0) {\n\t\t\trequest.arguments = args;\n\t\t}\n\t\tthis.internalSend('request', request);\n\t\tif (typeof timeout === 'number') {\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\tconst clb = this.pendingRequests.get(request.seq);\n\t\t\t\tif (clb) {\n\t\t\t\t\tthis.pendingRequests.delete(request.seq);\n\t\t\t\t\tconst err: DebugProtocol.Response = {\n\t\t\t\t\t\ttype: 'response',\n\t\t\t\t\t\tseq: 0,\n\t\t\t\t\t\trequest_seq: request.seq,\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tcommand,\n\t\t\t\t\t\tmessage: localize('timeout', \"Timeout after {0} ms for '{1}'\", timeout, command)\n\t\t\t\t\t};\n\t\t\t\t\tclb(err);\n\t\t\t\t}\n\t\t\t}, timeout);\n\t\t}\n\t\tif (clb) {\n\t\t\t// store callback for this request\n\t\t\tthis.pendingRequests.set(request.seq, clb);\n\t\t}\n\n\t\treturn request.seq;\n\t}\n\n\tacceptMessage(message: DebugProtocol.ProtocolMessage): void {\n\t\tif (this.messageCallback) {\n\t\t\tthis.messageCallback(message);\n\t\t} else {\n\t\t\tthis.queue.push(message);\n\t\t\tif (this.queue.length === 1) {\n\t\t\t\t// first item = need to start processing loop\n\t\t\t\tthis.processQueue();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether we should insert a timeout between processing messageA\n\t * and messageB. Artificially queueing protocol messages guarantees that any\n\t * microtasks for previous message finish before next message is processed.\n\t * This is essential ordering when using promises anywhere along the call path.\n\t *\n\t * For example, take the following, where `chooseAndSendGreeting` returns\n\t * a person name and then emits a greeting event:\n\t *\n\t * ```\n\t * let person: string;\n\t * adapter.onGreeting(() => console.log('hello', person));\n\t * person = await adapter.chooseAndSendGreeting();\n\t * ```\n\t *\n\t * Because the event is dispatched synchronously, it may fire before person\n\t * is assigned if they're processed in the same task. Inserting a task\n\t * boundary avoids this issue.\n\t */\n\tprotected needsTaskBoundaryBetween(messageA: DebugProtocol.ProtocolMessage, messageB: DebugProtocol.ProtocolMessage) {\n\t\treturn messageA.type !== 'event' || messageB.type !== 'event';\n\t}\n\n\t/**\n\t * Reads and dispatches items from the queue until it is empty.\n\t */\n\tprivate async processQueue() {\n\t\tlet message: DebugProtocol.ProtocolMessage | undefined;\n\t\twhile (this.queue.length) {\n\t\t\tif (!message || this.needsTaskBoundaryBetween(this.queue[0], message)) {\n\t\t\t\tawait timeout(0);\n\t\t\t}\n\n\t\t\tmessage = this.queue.shift();\n\t\t\tif (!message) {\n\t\t\t\treturn; // may have been disposed of\n\t\t\t}\n\n\t\t\tswitch (message.type) {\n\t\t\t\tcase 'event':\n\t\t\t\t\tthis.eventCallback?.(<DebugProtocol.Event>message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'request':\n\t\t\t\t\tthis.requestCallback?.(<DebugProtocol.Request>message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'response': {\n\t\t\t\t\tconst response = <DebugProtocol.Response>message;\n\t\t\t\t\tconst clb = this.pendingRequests.get(response.request_seq);\n\t\t\t\t\tif (clb) {\n\t\t\t\t\t\tthis.pendingRequests.delete(response.request_seq);\n\t\t\t\t\t\tclb(response);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate internalSend(typ: 'request' | 'response' | 'event', message: DebugProtocol.ProtocolMessage): void {\n\t\tmessage.type = typ;\n\t\tmessage.seq = this.sequence++;\n\t\tthis.sendMessage(message);\n\t}\n\n\tprotected async cancelPendingRequests(): Promise<void> {\n\t\tif (this.pendingRequests.size === 0) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tconst pending = new Map<number, (e: DebugProtocol.Response) => void>();\n\t\tthis.pendingRequests.forEach((value, key) => pending.set(key, value));\n\t\tawait timeout(500);\n\t\tpending.forEach((callback, request_seq) => {\n\t\t\tconst err: DebugProtocol.Response = {\n\t\t\t\ttype: 'response',\n\t\t\t\tseq: 0,\n\t\t\t\trequest_seq,\n\t\t\t\tsuccess: false,\n\t\t\t\tcommand: 'canceled',\n\t\t\t\tmessage: 'canceled'\n\t\t\t};\n\t\t\tcallback(err);\n\t\t\tthis.pendingRequests.delete(request_seq);\n\t\t});\n\t}\n\n\tgetPendingRequestIds(): number[] {\n\t\treturn Array.from(this.pendingRequests.keys());\n\t}\n\n\tdispose(): void {\n\t\tthis.queue = [];\n\t}\n}\n"]}