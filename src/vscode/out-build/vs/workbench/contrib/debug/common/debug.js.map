{"version":3,"sources":["vs/workbench/contrib/debug/common/debug.ts"],"names":[],"mappings":"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","file":"debug.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IAction } from '../../../../base/common/actions.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { IJSONSchema, IJSONSchemaSnippet } from '../../../../base/common/jsonSchema.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport severity from '../../../../base/common/severity.js';\nimport { URI, UriComponents, URI as uri } from '../../../../base/common/uri.js';\nimport { IPosition, Position } from '../../../../editor/common/core/position.js';\nimport { IRange } from '../../../../editor/common/core/range.js';\nimport * as editorCommon from '../../../../editor/common/editorCommon.js';\nimport { ITextModel as EditorIModel } from '../../../../editor/common/model.js';\nimport * as nls from '../../../../nls.js';\nimport { ConfigurationTarget } from '../../../../platform/configuration/common/configuration.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ITelemetryEndpoint } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { IEditorPane } from '../../../common/editor.js';\nimport { DebugCompoundRoot } from './debugCompoundRoot.js';\nimport { IDataBreakpointOptions, IFunctionBreakpointOptions, IInstructionBreakpointOptions } from './debugModel.js';\nimport { Source } from './debugSource.js';\nimport { ITaskIdentifier } from '../../tasks/common/tasks.js';\nimport { LiveTestResult } from '../../testing/common/testResult.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { IView } from '../../../common/views.js';\n\nexport const VIEWLET_ID = 'workbench.view.debug';\n\nexport const VARIABLES_VIEW_ID = 'workbench.debug.variablesView';\nexport const WATCH_VIEW_ID = 'workbench.debug.watchExpressionsView';\nexport const CALLSTACK_VIEW_ID = 'workbench.debug.callStackView';\nexport const LOADED_SCRIPTS_VIEW_ID = 'workbench.debug.loadedScriptsView';\nexport const BREAKPOINTS_VIEW_ID = 'workbench.debug.breakPointsView';\nexport const DISASSEMBLY_VIEW_ID = 'workbench.debug.disassemblyView';\nexport const DEBUG_PANEL_ID = 'workbench.panel.repl';\nexport const REPL_VIEW_ID = 'workbench.panel.repl.view';\nexport const CONTEXT_DEBUG_TYPE = new RawContextKey<string>('debugType', undefined, { type: 'string', description: nls.localize('debugType', \"Debug type of the active debug session. For example 'python'.\") });\nexport const CONTEXT_DEBUG_CONFIGURATION_TYPE = new RawContextKey<string>('debugConfigurationType', undefined, { type: 'string', description: nls.localize('debugConfigurationType', \"Debug type of the selected launch configuration. For example 'python'.\") });\nexport const CONTEXT_DEBUG_STATE = new RawContextKey<string>('debugState', 'inactive', { type: 'string', description: nls.localize('debugState', \"State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'.\") });\nexport const CONTEXT_DEBUG_UX_KEY = 'debugUx';\nexport const CONTEXT_DEBUG_UX = new RawContextKey<string>(CONTEXT_DEBUG_UX_KEY, 'default', { type: 'string', description: nls.localize('debugUX', \"Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet.\") });\nexport const CONTEXT_HAS_DEBUGGED = new RawContextKey<boolean>('hasDebugged', false, { type: 'boolean', description: nls.localize('hasDebugged', \"True when a debug session has been started at least once, false otherwise.\") });\nexport const CONTEXT_IN_DEBUG_MODE = new RawContextKey<boolean>('inDebugMode', false, { type: 'boolean', description: nls.localize('inDebugMode', \"True when debugging, false otherwise.\") });\nexport const CONTEXT_IN_DEBUG_REPL = new RawContextKey<boolean>('inDebugRepl', false, { type: 'boolean', description: nls.localize('inDebugRepl', \"True when focus is in the debug console, false otherwise.\") });\nexport const CONTEXT_BREAKPOINT_WIDGET_VISIBLE = new RawContextKey<boolean>('breakpointWidgetVisible', false, { type: 'boolean', description: nls.localize('breakpointWidgetVisibile', \"True when breakpoint editor zone widget is visible, false otherwise.\") });\nexport const CONTEXT_IN_BREAKPOINT_WIDGET = new RawContextKey<boolean>('inBreakpointWidget', false, { type: 'boolean', description: nls.localize('inBreakpointWidget', \"True when focus is in the breakpoint editor zone widget, false otherwise.\") });\nexport const CONTEXT_BREAKPOINTS_FOCUSED = new RawContextKey<boolean>('breakpointsFocused', true, { type: 'boolean', description: nls.localize('breakpointsFocused', \"True when the BREAKPOINTS view is focused, false otherwise.\") });\nexport const CONTEXT_WATCH_EXPRESSIONS_FOCUSED = new RawContextKey<boolean>('watchExpressionsFocused', true, { type: 'boolean', description: nls.localize('watchExpressionsFocused', \"True when the WATCH view is focused, false otherwise.\") });\nexport const CONTEXT_WATCH_EXPRESSIONS_EXIST = new RawContextKey<boolean>('watchExpressionsExist', false, { type: 'boolean', description: nls.localize('watchExpressionsExist', \"True when at least one watch expression exists, false otherwise.\") });\nexport const CONTEXT_VARIABLES_FOCUSED = new RawContextKey<boolean>('variablesFocused', true, { type: 'boolean', description: nls.localize('variablesFocused', \"True when the VARIABLES views is focused, false otherwise\") });\nexport const CONTEXT_EXPRESSION_SELECTED = new RawContextKey<boolean>('expressionSelected', false, { type: 'boolean', description: nls.localize('expressionSelected', \"True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise.\") });\nexport const CONTEXT_BREAKPOINT_INPUT_FOCUSED = new RawContextKey<boolean>('breakpointInputFocused', false, { type: 'boolean', description: nls.localize('breakpointInputFocused', \"True when the input box has focus in the BREAKPOINTS view.\") });\nexport const CONTEXT_CALLSTACK_ITEM_TYPE = new RawContextKey<string>('callStackItemType', undefined, { type: 'string', description: nls.localize('callStackItemType', \"Represents the item type of the focused element in the CALL STACK view. For example: 'session', 'thread', 'stackFrame'\") });\nexport const CONTEXT_CALLSTACK_SESSION_IS_ATTACH = new RawContextKey<boolean>('callStackSessionIsAttach', false, { type: 'boolean', description: nls.localize('callStackSessionIsAttach', \"True when the session in the CALL STACK view is attach, false otherwise. Used internally for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_CALLSTACK_ITEM_STOPPED = new RawContextKey<boolean>('callStackItemStopped', false, { type: 'boolean', description: nls.localize('callStackItemStopped', \"True when the focused item in the CALL STACK is stopped. Used internaly for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD = new RawContextKey<boolean>('callStackSessionHasOneThread', false, { type: 'boolean', description: nls.localize('callStackSessionHasOneThread', \"True when the focused session in the CALL STACK view has exactly one thread. Used internally for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_CALLSTACK_FOCUSED = new RawContextKey<boolean>('callStackFocused', true, { type: 'boolean', description: nls.localize('callStackFocused', \"True when the CALLSTACK view is focused, false otherwise.\") });\nexport const CONTEXT_WATCH_ITEM_TYPE = new RawContextKey<string>('watchItemType', undefined, { type: 'string', description: nls.localize('watchItemType', \"Represents the item type of the focused element in the WATCH view. For example: 'expression', 'variable'\") });\nexport const CONTEXT_CAN_VIEW_MEMORY = new RawContextKey<boolean>('canViewMemory', undefined, { type: 'boolean', description: nls.localize('canViewMemory', \"Indicates whether the item in the view has an associated memory refrence.\") });\nexport const CONTEXT_BREAKPOINT_ITEM_TYPE = new RawContextKey<string>('breakpointItemType', undefined, { type: 'string', description: nls.localize('breakpointItemType', \"Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'\") });\nexport const CONTEXT_BREAKPOINT_ITEM_IS_DATA_BYTES = new RawContextKey<boolean>('breakpointItemBytes', undefined, { type: 'boolean', description: nls.localize('breakpointItemIsDataBytes', \"Whether the breakpoint item is a data breakpoint on a byte range.\") });\nexport const CONTEXT_BREAKPOINT_HAS_MODES = new RawContextKey<boolean>('breakpointHasModes', false, { type: 'boolean', description: nls.localize('breakpointHasModes', \"Whether the breakpoint has multiple modes it can switch to.\") });\nexport const CONTEXT_BREAKPOINT_SUPPORTS_CONDITION = new RawContextKey<boolean>('breakpointSupportsCondition', false, { type: 'boolean', description: nls.localize('breakpointSupportsCondition', \"True when the focused breakpoint supports conditions.\") });\nexport const CONTEXT_LOADED_SCRIPTS_SUPPORTED = new RawContextKey<boolean>('loadedScriptsSupported', false, { type: 'boolean', description: nls.localize('loadedScriptsSupported', \"True when the focused sessions supports the LOADED SCRIPTS view\") });\nexport const CONTEXT_LOADED_SCRIPTS_ITEM_TYPE = new RawContextKey<string>('loadedScriptsItemType', undefined, { type: 'string', description: nls.localize('loadedScriptsItemType', \"Represents the item type of the focused element in the LOADED SCRIPTS view.\") });\nexport const CONTEXT_FOCUSED_SESSION_IS_ATTACH = new RawContextKey<boolean>('focusedSessionIsAttach', false, { type: 'boolean', description: nls.localize('focusedSessionIsAttach', \"True when the focused session is 'attach'.\") });\nexport const CONTEXT_FOCUSED_SESSION_IS_NO_DEBUG = new RawContextKey<boolean>('focusedSessionIsNoDebug', false, { type: 'boolean', description: nls.localize('focusedSessionIsNoDebug', \"True when the focused session is run without debugging.\") });\nexport const CONTEXT_STEP_BACK_SUPPORTED = new RawContextKey<boolean>('stepBackSupported', false, { type: 'boolean', description: nls.localize('stepBackSupported', \"True when the focused session supports 'stepBack' requests.\") });\nexport const CONTEXT_RESTART_FRAME_SUPPORTED = new RawContextKey<boolean>('restartFrameSupported', false, { type: 'boolean', description: nls.localize('restartFrameSupported', \"True when the focused session supports 'restartFrame' requests.\") });\nexport const CONTEXT_STACK_FRAME_SUPPORTS_RESTART = new RawContextKey<boolean>('stackFrameSupportsRestart', false, { type: 'boolean', description: nls.localize('stackFrameSupportsRestart', \"True when the focused stack frame supports 'restartFrame'.\") });\nexport const CONTEXT_JUMP_TO_CURSOR_SUPPORTED = new RawContextKey<boolean>('jumpToCursorSupported', false, { type: 'boolean', description: nls.localize('jumpToCursorSupported', \"True when the focused session supports 'jumpToCursor' request.\") });\nexport const CONTEXT_STEP_INTO_TARGETS_SUPPORTED = new RawContextKey<boolean>('stepIntoTargetsSupported', false, { type: 'boolean', description: nls.localize('stepIntoTargetsSupported', \"True when the focused session supports 'stepIntoTargets' request.\") });\nexport const CONTEXT_BREAKPOINTS_EXIST = new RawContextKey<boolean>('breakpointsExist', false, { type: 'boolean', description: nls.localize('breakpointsExist', \"True when at least one breakpoint exists.\") });\nexport const CONTEXT_DEBUGGERS_AVAILABLE = new RawContextKey<boolean>('debuggersAvailable', false, { type: 'boolean', description: nls.localize('debuggersAvailable', \"True when there is at least one debug extensions active.\") });\nexport const CONTEXT_DEBUG_EXTENSION_AVAILABLE = new RawContextKey<boolean>('debugExtensionAvailable', true, { type: 'boolean', description: nls.localize('debugExtensionsAvailable', \"True when there is at least one debug extension installed and enabled.\") });\nexport const CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT = new RawContextKey<string>('debugProtocolVariableMenuContext', undefined, { type: 'string', description: nls.localize('debugProtocolVariableMenuContext', \"Represents the context the debug adapter sets on the focused variable in the VARIABLES view.\") });\nexport const CONTEXT_SET_VARIABLE_SUPPORTED = new RawContextKey<boolean>('debugSetVariableSupported', false, { type: 'boolean', description: nls.localize('debugSetVariableSupported', \"True when the focused session supports 'setVariable' request.\") });\nexport const CONTEXT_SET_DATA_BREAKPOINT_BYTES_SUPPORTED = new RawContextKey<boolean>('debugSetDataBreakpointAddressSupported', false, { type: 'boolean', description: nls.localize('debugSetDataBreakpointAddressSupported', \"True when the focused session supports 'getBreakpointInfo' request on an address.\") });\nexport const CONTEXT_SET_EXPRESSION_SUPPORTED = new RawContextKey<boolean>('debugSetExpressionSupported', false, { type: 'boolean', description: nls.localize('debugSetExpressionSupported', \"True when the focused session supports 'setExpression' request.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED = new RawContextKey<boolean>('breakWhenValueChangesSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueChangesSupported', \"True when the focused session supports to break when value changes.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED = new RawContextKey<boolean>('breakWhenValueIsAccessedSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueIsAccessedSupported', \"True when the focused breakpoint supports to break when value is accessed.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED = new RawContextKey<boolean>('breakWhenValueIsReadSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueIsReadSupported', \"True when the focused breakpoint supports to break when value is read.\") });\nexport const CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED = new RawContextKey<boolean>('terminateDebuggeeSupported', false, { type: 'boolean', description: nls.localize('terminateDebuggeeSupported', \"True when the focused session supports the terminate debuggee capability.\") });\nexport const CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED = new RawContextKey<boolean>('suspendDebuggeeSupported', false, { type: 'boolean', description: nls.localize('suspendDebuggeeSupported', \"True when the focused session supports the suspend debuggee capability.\") });\nexport const CONTEXT_TERMINATE_THREADS_SUPPORTED = new RawContextKey<boolean>('terminateThreadsSupported', false, { type: 'boolean', description: nls.localize('terminateThreadsSupported', \"True when the focused session supports the terminate threads capability.\") });\nexport const CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT = new RawContextKey<boolean>('variableEvaluateNamePresent', false, { type: 'boolean', description: nls.localize('variableEvaluateNamePresent', \"True when the focused variable has an 'evalauteName' field set.\") });\nexport const CONTEXT_VARIABLE_IS_READONLY = new RawContextKey<boolean>('variableIsReadonly', false, { type: 'boolean', description: nls.localize('variableIsReadonly', \"True when the focused variable is read-only.\") });\nexport const CONTEXT_VARIABLE_VALUE = new RawContextKey<boolean>('variableValue', false, { type: 'string', description: nls.localize('variableValue', \"Value of the variable, present for debug visualization clauses.\") });\nexport const CONTEXT_VARIABLE_TYPE = new RawContextKey<boolean>('variableType', false, { type: 'string', description: nls.localize('variableType', \"Type of the variable, present for debug visualization clauses.\") });\nexport const CONTEXT_VARIABLE_INTERFACES = new RawContextKey<boolean>('variableInterfaces', false, { type: 'array', description: nls.localize('variableInterfaces', \"Any interfaces or contracts that the variable satisfies, present for debug visualization clauses.\") });\nexport const CONTEXT_VARIABLE_NAME = new RawContextKey<boolean>('variableName', false, { type: 'string', description: nls.localize('variableName', \"Name of the variable, present for debug visualization clauses.\") });\nexport const CONTEXT_VARIABLE_LANGUAGE = new RawContextKey<boolean>('variableLanguage', false, { type: 'string', description: nls.localize('variableLanguage', \"Language of the variable source, present for debug visualization clauses.\") });\nexport const CONTEXT_VARIABLE_EXTENSIONID = new RawContextKey<boolean>('variableExtensionId', false, { type: 'string', description: nls.localize('variableExtensionId', \"Extension ID of the variable source, present for debug visualization clauses.\") });\nexport const CONTEXT_EXCEPTION_WIDGET_VISIBLE = new RawContextKey<boolean>('exceptionWidgetVisible', false, { type: 'boolean', description: nls.localize('exceptionWidgetVisible', \"True when the exception widget is visible.\") });\nexport const CONTEXT_MULTI_SESSION_REPL = new RawContextKey<boolean>('multiSessionRepl', false, { type: 'boolean', description: nls.localize('multiSessionRepl', \"True when there is more than 1 debug console.\") });\nexport const CONTEXT_MULTI_SESSION_DEBUG = new RawContextKey<boolean>('multiSessionDebug', false, { type: 'boolean', description: nls.localize('multiSessionDebug', \"True when there is more than 1 active debug session.\") });\nexport const CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED = new RawContextKey<boolean>('disassembleRequestSupported', false, { type: 'boolean', description: nls.localize('disassembleRequestSupported', \"True when the focused sessions supports disassemble request.\") });\nexport const CONTEXT_DISASSEMBLY_VIEW_FOCUS = new RawContextKey<boolean>('disassemblyViewFocus', false, { type: 'boolean', description: nls.localize('disassemblyViewFocus', \"True when the Disassembly View is focused.\") });\nexport const CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST = new RawContextKey<boolean>('languageSupportsDisassembleRequest', false, { type: 'boolean', description: nls.localize('languageSupportsDisassembleRequest', \"True when the language in the current editor supports disassemble request.\") });\nexport const CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE = new RawContextKey<boolean>('focusedStackFrameHasInstructionReference', false, { type: 'boolean', description: nls.localize('focusedStackFrameHasInstructionReference', \"True when the focused stack frame has instruction pointer reference.\") });\n\nexport const debuggerDisabledMessage = (debugType: string) => nls.localize('debuggerDisabled', \"Configured debug type '{0}' is installed but not supported in this environment.\", debugType);\n\nexport const EDITOR_CONTRIBUTION_ID = 'editor.contrib.debug';\nexport const BREAKPOINT_EDITOR_CONTRIBUTION_ID = 'editor.contrib.breakpoint';\nexport const DEBUG_SCHEME = 'debug';\nexport const INTERNAL_CONSOLE_OPTIONS_SCHEMA = {\n\tenum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],\n\tdefault: 'openOnFirstSessionStart',\n\tdescription: nls.localize('internalConsoleOptions', \"Controls when the internal Debug Console should open.\")\n};\n\nexport interface IDebugViewWithVariables extends IView {\n\treadonly treeSelection: IExpression[];\n}\n\n// raw\n\nexport interface IRawModelUpdate {\n\tsessionId: string;\n\tthreads: DebugProtocol.Thread[];\n\tstoppedDetails?: IRawStoppedDetails;\n}\n\nexport interface IRawStoppedDetails {\n\treason?: string;\n\tdescription?: string;\n\tthreadId?: number;\n\ttext?: string;\n\ttotalFrames?: number;\n\tallThreadsStopped?: boolean;\n\tpreserveFocusHint?: boolean;\n\tframesErrorMessage?: string;\n\thitBreakpointIds?: number[];\n}\n\n// model\n\nexport interface ITreeElement {\n\tgetId(): string;\n}\n\nexport interface IReplElement extends ITreeElement {\n\ttoString(includeSource?: boolean): string;\n\treadonly sourceData?: IReplElementSource;\n}\n\nexport interface INestingReplElement extends IReplElement {\n\treadonly hasChildren: boolean;\n\tgetChildren(): Promise<IReplElement[]> | IReplElement[];\n}\n\nexport interface IReplElementSource {\n\treadonly source: Source;\n\treadonly lineNumber: number;\n\treadonly column: number;\n}\n\nexport interface IExpressionValue {\n\treadonly value: string;\n\treadonly type?: string;\n\tvalueChanged?: boolean;\n}\n\nexport interface IExpressionContainer extends ITreeElement, IExpressionValue {\n\treadonly hasChildren: boolean;\n\tgetSession(): IDebugSession | undefined;\n\tevaluateLazy(): Promise<void>;\n\tgetChildren(): Promise<IExpression[]>;\n\treadonly reference?: number;\n\treadonly memoryReference?: string;\n\treadonly presentationHint?: DebugProtocol.VariablePresentationHint | undefined;\n\treadonly valueLocationReference?: number;\n}\n\nexport interface IExpression extends IExpressionContainer {\n\tname: string;\n}\n\nexport interface IDebugger {\n\treadonly type: string;\n\tcreateDebugAdapter(session: IDebugSession): Promise<IDebugAdapter>;\n\trunInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n\tstartDebugging(args: IConfig, parentSessionId: string): Promise<boolean>;\n\tgetCustomTelemetryEndpoint(): ITelemetryEndpoint | undefined;\n\tgetInitialConfigurationContent(initialConfigs?: IConfig[]): Promise<string>;\n}\n\nexport interface IDebuggerMetadata {\n\tlabel: string;\n\ttype: string;\n\tstrings?: { [key in DebuggerString]: string };\n\tinterestedInLanguage(languageId: string): boolean;\n}\n\nexport const enum State {\n\tInactive,\n\tInitializing,\n\tStopped,\n\tRunning\n}\n\nexport function getStateLabel(state: State): string {\n\tswitch (state) {\n\t\tcase State.Initializing: return 'initializing';\n\t\tcase State.Stopped: return 'stopped';\n\t\tcase State.Running: return 'running';\n\t\tdefault: return 'inactive';\n\t}\n}\n\nexport interface AdapterEndEvent {\n\terror?: Error;\n\tsessionLengthInSeconds: number;\n\temittedStopped: boolean;\n}\n\nexport interface LoadedSourceEvent {\n\treason: 'new' | 'changed' | 'removed';\n\tsource: Source;\n}\n\nexport type IDebugSessionReplMode = 'separate' | 'mergeWithParent';\n\nexport interface IDebugTestRunReference {\n\trunId: string;\n\ttaskId: string;\n}\n\nexport interface IDebugSessionOptions {\n\tnoDebug?: boolean;\n\tparentSession?: IDebugSession;\n\tlifecycleManagedByParent?: boolean;\n\trepl?: IDebugSessionReplMode;\n\tcompoundRoot?: DebugCompoundRoot;\n\tcompact?: boolean;\n\tstartedByUser?: boolean;\n\tsaveBeforeRestart?: boolean;\n\tsuppressDebugToolbar?: boolean;\n\tsuppressDebugStatusbar?: boolean;\n\tsuppressDebugView?: boolean;\n\t/**\n\t * Set if the debug session is correlated with a test run. Stopping/restarting\n\t * the session will instead stop/restart the test run.\n\t */\n\ttestRun?: IDebugTestRunReference;\n}\n\nexport interface IDataBreakpointInfoResponse {\n\tdataId: string | null;\n\tdescription: string;\n\tcanPersist?: boolean;\n\taccessTypes?: DebugProtocol.DataBreakpointAccessType[];\n}\n\nexport interface IMemoryInvalidationEvent {\n\tfromOffset: number;\n\ttoOffset: number;\n}\n\nexport const enum MemoryRangeType {\n\tValid,\n\tUnreadable,\n\tError,\n}\n\nexport interface IMemoryRange {\n\ttype: MemoryRangeType;\n\toffset: number;\n\tlength: number;\n}\n\nexport interface IValidMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Valid;\n\toffset: number;\n\tlength: number;\n\tdata: VSBuffer;\n}\n\nexport interface IUnreadableMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Unreadable;\n}\n\nexport interface IErrorMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Error;\n\terror: string;\n}\n\n/**\n * Union type of memory that can be returned from read(). Since a read request\n * could encompass multiple previously-read ranges, multiple of these types\n * are possible to return.\n */\nexport type MemoryRange = IValidMemoryRange | IUnreadableMemoryRange | IErrorMemoryRange;\n\nexport const DEBUG_MEMORY_SCHEME = 'vscode-debug-memory';\n\n/**\n * An IMemoryRegion corresponds to a contiguous range of memory referred to\n * by a DAP `memoryReference`.\n */\nexport interface IMemoryRegion extends IDisposable {\n\t/**\n\t * Event that fires when memory changes. Can be a result of memory events or\n\t * `write` requests.\n\t */\n\treadonly onDidInvalidate: Event<IMemoryInvalidationEvent>;\n\n\t/**\n\t * Whether writes are supported on this memory region.\n\t */\n\treadonly writable: boolean;\n\n\t/**\n\t * Requests memory ranges from the debug adapter. It returns a list of memory\n\t * ranges that overlap (but may exceed!) the given offset. Use the `offset`\n\t * and `length` of each range for display.\n\t */\n\tread(fromOffset: number, toOffset: number): Promise<MemoryRange[]>;\n\n\t/**\n\t * Writes memory to the debug adapter at the given offset.\n\t */\n\twrite(offset: number, data: VSBuffer): Promise<number>;\n}\n\n/** Data that can be inserted in {@link IDebugSession.appendToRepl} */\nexport interface INewReplElementData {\n\t/**\n\t * Output string to display\n\t */\n\toutput: string;\n\n\t/**\n\t * Expression data to display. Will result in the item being expandable in\n\t * the REPL. Its value will be used if {@link output} is not provided.\n\t */\n\texpression?: IExpression;\n\n\t/**\n\t * Output severity.\n\t */\n\tsev: severity;\n\n\t/**\n\t * Originating location.\n\t */\n\tsource?: IReplElementSource;\n}\n\nexport interface IDebugEvaluatePosition {\n\tline: number;\n\tcolumn: number;\n\tsource: DebugProtocol.Source;\n}\n\nexport interface IDebugLocationReferenced {\n\tline: number;\n\tcolumn: number;\n\tendLine?: number;\n\tendColumn?: number;\n\tsource: Source;\n}\n\nexport interface IDebugSession extends ITreeElement, IDisposable {\n\n\treadonly configuration: IConfig;\n\treadonly unresolvedConfiguration: IConfig | undefined;\n\treadonly state: State;\n\treadonly root: IWorkspaceFolder | undefined;\n\treadonly parentSession: IDebugSession | undefined;\n\treadonly subId: string | undefined;\n\treadonly compact: boolean;\n\treadonly compoundRoot: DebugCompoundRoot | undefined;\n\treadonly saveBeforeRestart: boolean;\n\treadonly name: string;\n\treadonly autoExpandLazyVariables: boolean;\n\treadonly suppressDebugToolbar: boolean;\n\treadonly suppressDebugStatusbar: boolean;\n\treadonly suppressDebugView: boolean;\n\treadonly lifecycleManagedByParent: boolean;\n\t/** Test run this debug session was spawned by */\n\treadonly correlatedTestRun?: LiveTestResult;\n\n\tsetSubId(subId: string | undefined): void;\n\n\tgetMemory(memoryReference: string): IMemoryRegion;\n\n\tsetName(name: string): void;\n\treadonly onDidChangeName: Event<string>;\n\tgetLabel(): string;\n\n\tgetSourceForUri(modelUri: uri): Source | undefined;\n\tgetSource(raw?: DebugProtocol.Source): Source;\n\n\tsetConfiguration(configuration: { resolved: IConfig; unresolved: IConfig | undefined }): void;\n\trawUpdate(data: IRawModelUpdate): void;\n\n\tgetThread(threadId: number): IThread | undefined;\n\tgetAllThreads(): IThread[];\n\tclearThreads(removeThreads: boolean, reference?: number): void;\n\tgetStoppedDetails(): IRawStoppedDetails | undefined;\n\n\tgetReplElements(): IReplElement[];\n\thasSeparateRepl(): boolean;\n\tremoveReplExpressions(): void;\n\taddReplExpression(stackFrame: IStackFrame | undefined, name: string): Promise<void>;\n\tappendToRepl(data: INewReplElementData): void;\n\t/** Cancel any associated test run set through the DebugSessionOptions */\n\tcancelCorrelatedTestRun(): void;\n\n\t// session events\n\treadonly onDidEndAdapter: Event<AdapterEndEvent | undefined>;\n\treadonly onDidChangeState: Event<void>;\n\treadonly onDidChangeReplElements: Event<IReplElement | undefined>;\n\n\t/** DA capabilities. Set only when there is a running session available. */\n\treadonly capabilities: DebugProtocol.Capabilities;\n\t/** DA capabilities. These are retained on the session even after is implementation ends. */\n\treadonly rememberedCapabilities?: DebugProtocol.Capabilities;\n\n\t// DAP events\n\n\treadonly onDidLoadedSource: Event<LoadedSourceEvent>;\n\treadonly onDidCustomEvent: Event<DebugProtocol.Event>;\n\treadonly onDidProgressStart: Event<DebugProtocol.ProgressStartEvent>;\n\treadonly onDidProgressUpdate: Event<DebugProtocol.ProgressUpdateEvent>;\n\treadonly onDidProgressEnd: Event<DebugProtocol.ProgressEndEvent>;\n\treadonly onDidInvalidateMemory: Event<DebugProtocol.MemoryEvent>;\n\n\t// DAP request\n\n\tinitialize(dbgr: IDebugger): Promise<void>;\n\tlaunchOrAttach(config: IConfig): Promise<void>;\n\trestart(): Promise<void>;\n\tterminate(restart?: boolean /* false */): Promise<void>;\n\tdisconnect(restart?: boolean /* false */, suspend?: boolean): Promise<void>;\n\n\tsendBreakpoints(modelUri: uri, bpts: IBreakpoint[], sourceModified: boolean): Promise<void>;\n\tsendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void>;\n\tdataBreakpointInfo(name: string, variablesReference?: number, frameId?: number): Promise<IDataBreakpointInfoResponse | undefined>;\n\tdataBytesBreakpointInfo(address: string, bytes: number): Promise<IDataBreakpointInfoResponse | undefined>;\n\tsendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void>;\n\tsendInstructionBreakpoints(dbps: IInstructionBreakpoint[]): Promise<void>;\n\tsendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void>;\n\tbreakpointsLocations(uri: uri, lineNumber: number): Promise<IPosition[]>;\n\tgetDebugProtocolBreakpoint(breakpointId: string): DebugProtocol.Breakpoint | undefined;\n\tresolveLocationReference(locationReference: number): Promise<IDebugLocationReferenced>;\n\n\tstackTrace(threadId: number, startFrame: number, levels: number, token: CancellationToken): Promise<DebugProtocol.StackTraceResponse | undefined>;\n\texceptionInfo(threadId: number): Promise<IExceptionInfo | undefined>;\n\tscopes(frameId: number, threadId: number): Promise<DebugProtocol.ScopesResponse | undefined>;\n\tvariables(variablesReference: number, threadId: number | undefined, filter: 'indexed' | 'named' | undefined, start: number | undefined, count: number | undefined): Promise<DebugProtocol.VariablesResponse | undefined>;\n\tevaluate(expression: string, frameId?: number, context?: string, location?: IDebugEvaluatePosition): Promise<DebugProtocol.EvaluateResponse | undefined>;\n\tcustomRequest(request: string, args: unknown): Promise<DebugProtocol.Response | undefined>;\n\tcancel(progressId: string): Promise<DebugProtocol.CancelResponse | undefined>;\n\tdisassemble(memoryReference: string, offset: number, instructionOffset: number, instructionCount: number): Promise<DebugProtocol.DisassembledInstruction[] | undefined>;\n\treadMemory(memoryReference: string, offset: number, count: number): Promise<DebugProtocol.ReadMemoryResponse | undefined>;\n\twriteMemory(memoryReference: string, offset: number, data: string, allowPartial?: boolean): Promise<DebugProtocol.WriteMemoryResponse | undefined>;\n\n\trestartFrame(frameId: number, threadId: number): Promise<void>;\n\tnext(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepIn(threadId: number, targetId?: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepInTargets(frameId: number): Promise<DebugProtocol.StepInTarget[] | undefined>;\n\tstepOut(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepBack(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tcontinue(threadId: number): Promise<void>;\n\treverseContinue(threadId: number): Promise<void>;\n\tpause(threadId: number): Promise<void>;\n\tterminateThreads(threadIds: number[]): Promise<void>;\n\n\tcompletions(frameId: number | undefined, threadId: number, text: string, position: Position, token: CancellationToken): Promise<DebugProtocol.CompletionsResponse | undefined>;\n\tsetVariable(variablesReference: number | undefined, name: string, value: string): Promise<DebugProtocol.SetVariableResponse | undefined>;\n\tsetExpression(frameId: number, expression: string, value: string): Promise<DebugProtocol.SetExpressionResponse | undefined>;\n\tloadSource(resource: uri): Promise<DebugProtocol.SourceResponse | undefined>;\n\tgetLoadedSources(): Promise<Source[]>;\n\n\tgotoTargets(source: DebugProtocol.Source, line: number, column?: number): Promise<DebugProtocol.GotoTargetsResponse | undefined>;\n\tgoto(threadId: number, targetId: number): Promise<DebugProtocol.GotoResponse | undefined>;\n}\n\nexport interface IThread extends ITreeElement {\n\n\t/**\n\t * Process the thread belongs to\n\t */\n\treadonly session: IDebugSession;\n\n\t/**\n\t * Id of the thread generated by the debug adapter backend.\n\t */\n\treadonly threadId: number;\n\n\t/**\n\t * Name of the thread.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Information about the current thread stop event. Undefined if thread is not stopped.\n\t */\n\treadonly stoppedDetails: IRawStoppedDetails | undefined;\n\n\t/**\n\t * Information about the exception if an 'exception' stopped event raised and DA supports the 'exceptionInfo' request, otherwise undefined.\n\t */\n\treadonly exceptionInfo: Promise<IExceptionInfo | undefined>;\n\n\treadonly stateLabel: string;\n\n\t/**\n\t * Gets the callstack if it has already been received from the debug\n\t * adapter.\n\t */\n\tgetCallStack(): ReadonlyArray<IStackFrame>;\n\n\n\t/**\n\t * Gets the top stack frame that is not hidden if the callstack has already been received from the debug adapter\n\t */\n\tgetTopStackFrame(): IStackFrame | undefined;\n\n\t/**\n\t * Invalidates the callstack cache\n\t */\n\tclearCallStack(): void;\n\n\t/**\n\t * Indicates whether this thread is stopped. The callstack for stopped\n\t * threads can be retrieved from the debug adapter.\n\t */\n\treadonly stopped: boolean;\n\n\tnext(granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepIn(granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepOut(granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepBack(granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tcontinue(): Promise<void>;\n\tpause(): Promise<void>;\n\tterminate(): Promise<void>;\n\treverseContinue(): Promise<void>;\n}\n\nexport interface IScope extends IExpressionContainer {\n\treadonly name: string;\n\treadonly expensive: boolean;\n\treadonly range?: IRange;\n\treadonly hasChildren: boolean;\n}\n\nexport interface IStackFrame extends ITreeElement {\n\treadonly thread: IThread;\n\treadonly name: string;\n\treadonly presentationHint: string | undefined;\n\treadonly frameId: number;\n\treadonly range: IRange;\n\treadonly source: Source;\n\treadonly canRestart: boolean;\n\treadonly instructionPointerReference?: string;\n\tgetScopes(): Promise<IScope[]>;\n\tgetMostSpecificScopes(range: IRange): Promise<ReadonlyArray<IScope>>;\n\tforgetScopes(): void;\n\trestart(): Promise<void>;\n\ttoString(): string;\n\topenInEditor(editorService: IEditorService, preserveFocus?: boolean, sideBySide?: boolean, pinned?: boolean): Promise<IEditorPane | undefined>;\n\tequals(other: IStackFrame): boolean;\n}\n\nexport function isFrameDeemphasized(frame: IStackFrame): boolean {\n\tconst hint = frame.presentationHint ?? frame.source.presentationHint;\n\treturn hint === 'deemphasize' || hint === 'subtle';\n}\n\nexport interface IEnablement extends ITreeElement {\n\treadonly enabled: boolean;\n}\n\nexport interface IBreakpointData {\n\treadonly id?: string;\n\treadonly lineNumber: number;\n\treadonly column?: number;\n\treadonly enabled?: boolean;\n\treadonly condition?: string;\n\treadonly logMessage?: string;\n\treadonly hitCondition?: string;\n\treadonly triggeredBy?: string;\n\treadonly mode?: string;\n\treadonly modeLabel?: string;\n}\n\nexport interface IBreakpointUpdateData {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly lineNumber?: number;\n\treadonly column?: number;\n\treadonly triggeredBy?: string;\n\treadonly mode?: string;\n\treadonly modeLabel?: string;\n}\n\nexport interface IBaseBreakpoint extends IEnablement {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly verified: boolean;\n\treadonly supported: boolean;\n\treadonly message?: string;\n\t/** The preferred mode of the breakpoint from {@link DebugProtocol.BreakpointMode} */\n\treadonly mode?: string;\n\t/** The preferred mode label of the breakpoint from {@link DebugProtocol.BreakpointMode} */\n\treadonly modeLabel?: string;\n\treadonly sessionsThatVerified: string[];\n\tgetIdFromAdapter(sessionId: string): number | undefined;\n}\n\nexport interface IBreakpoint extends IBaseBreakpoint {\n\t/** URI where the breakpoint was first set by the user. */\n\treadonly originalUri: uri;\n\t/** URI where the breakpoint is currently shown; may be moved by debugger */\n\treadonly uri: uri;\n\treadonly lineNumber: number;\n\treadonly endLineNumber?: number;\n\treadonly column?: number;\n\treadonly endColumn?: number;\n\treadonly adapterData: unknown;\n\treadonly sessionAgnosticData: { lineNumber: number; column: number | undefined };\n\t/** An ID of the breakpoint that triggers this breakpoint. */\n\treadonly triggeredBy?: string;\n\t/** Pending on the trigger breakpoint, which means this breakpoint is not yet sent to DA */\n\treadonly pending: boolean;\n\n\t/** Marks that a session did trigger the breakpoint. */\n\tsetSessionDidTrigger(sessionId: string, didTrigger?: boolean): void;\n\t/** Gets whether the `triggeredBy` condition has been met in the given sesison ID. */\n\tgetSessionDidTrigger(sessionId: string): boolean;\n\n\ttoDAP(): DebugProtocol.SourceBreakpoint;\n}\n\nexport interface IFunctionBreakpoint extends IBaseBreakpoint {\n\treadonly name: string;\n\ttoDAP(): DebugProtocol.FunctionBreakpoint;\n}\n\nexport interface IExceptionBreakpoint extends IBaseBreakpoint {\n\treadonly filter: string;\n\treadonly label: string;\n\treadonly description: string | undefined;\n}\n\nexport const enum DataBreakpointSetType {\n\tVariable,\n\tAddress,\n}\n\n/**\n * Source for a data breakpoint. A data breakpoint on a variable always has a\n * `dataId` because it cannot reference that variable globally, but addresses\n * can request info repeated and use session-specific data.\n */\nexport type DataBreakpointSource =\n\t| { type: DataBreakpointSetType.Variable; dataId: string }\n\t| { type: DataBreakpointSetType.Address; address: string; bytes: number };\n\nexport interface IDataBreakpoint extends IBaseBreakpoint {\n\treadonly description: string;\n\treadonly canPersist: boolean;\n\treadonly src: DataBreakpointSource;\n\treadonly accessType: DebugProtocol.DataBreakpointAccessType;\n\ttoDAP(session: IDebugSession): Promise<DebugProtocol.DataBreakpoint | undefined>;\n}\n\nexport interface IInstructionBreakpoint extends IBaseBreakpoint {\n\treadonly instructionReference: string;\n\treadonly offset?: number;\n\t/** Original instruction memory address; display purposes only */\n\treadonly address: bigint;\n\ttoDAP(): DebugProtocol.InstructionBreakpoint;\n}\n\nexport interface IExceptionInfo {\n\treadonly id?: string;\n\treadonly description?: string;\n\treadonly breakMode: string | null;\n\treadonly details?: DebugProtocol.ExceptionDetails;\n}\n\n// model interfaces\n\nexport interface IViewModel extends ITreeElement {\n\t/**\n\t * Returns the focused debug session or undefined if no session is stopped.\n\t */\n\treadonly focusedSession: IDebugSession | undefined;\n\n\t/**\n\t * Returns the focused thread or undefined if no thread is stopped.\n\t */\n\treadonly focusedThread: IThread | undefined;\n\n\t/**\n\t * Returns the focused stack frame or undefined if there are no stack frames.\n\t */\n\treadonly focusedStackFrame: IStackFrame | undefined;\n\n\tsetVisualizedExpression(original: IExpression, visualized: IExpression & { treeId: string } | undefined): void;\n\t/** Returns the visualized expression if loaded, or a tree it should be visualized with, or undefined */\n\tgetVisualizedExpression(expression: IExpression): IExpression | string | undefined;\n\tgetSelectedExpression(): { expression: IExpression; settingWatch: boolean } | undefined;\n\tsetSelectedExpression(expression: IExpression | undefined, settingWatch: boolean): void;\n\tupdateViews(): void;\n\n\tisMultiSessionView(): boolean;\n\n\treadonly onDidFocusSession: Event<IDebugSession | undefined>;\n\treadonly onDidFocusThread: Event<{ thread: IThread | undefined; explicit: boolean; session: IDebugSession | undefined }>;\n\treadonly onDidFocusStackFrame: Event<{ stackFrame: IStackFrame | undefined; explicit: boolean; session: IDebugSession | undefined }>;\n\treadonly onDidSelectExpression: Event<{ expression: IExpression; settingWatch: boolean } | undefined>;\n\treadonly onDidEvaluateLazyExpression: Event<IExpressionContainer>;\n\t/**\n\t * Fired when `setVisualizedExpression`, to migrate elements currently\n\t * rendered as `original` to the `replacement`.\n\t */\n\treadonly onDidChangeVisualization: Event<{ original: IExpression; replacement: IExpression }>;\n\treadonly onWillUpdateViews: Event<void>;\n\n\tevaluateLazyExpression(expression: IExpressionContainer): void;\n}\n\nexport interface IEvaluate {\n\tevaluate(session: IDebugSession, stackFrame: IStackFrame, context: string): Promise<void>;\n}\n\nexport interface IDebugModel extends ITreeElement {\n\tgetSession(sessionId: string | undefined, includeInactive?: boolean): IDebugSession | undefined;\n\tgetSessions(includeInactive?: boolean): IDebugSession[];\n\tgetBreakpoints(filter?: { uri?: uri; originalUri?: uri; lineNumber?: number; column?: number; enabledOnly?: boolean; triggeredOnly?: boolean }): ReadonlyArray<IBreakpoint>;\n\tareBreakpointsActivated(): boolean;\n\tgetFunctionBreakpoints(): ReadonlyArray<IFunctionBreakpoint>;\n\tgetDataBreakpoints(): ReadonlyArray<IDataBreakpoint>;\n\n\t/**\n\t * Returns list of all exception breakpoints.\n\t */\n\tgetExceptionBreakpoints(): ReadonlyArray<IExceptionBreakpoint>;\n\n\t/**\n\t * Returns list of exception breakpoints for the given session\n\t * @param sessionId Session id. If falsy, returns the breakpoints from the last set fallback session.\n\t */\n\tgetExceptionBreakpointsForSession(sessionId?: string): ReadonlyArray<IExceptionBreakpoint>;\n\n\tgetInstructionBreakpoints(): ReadonlyArray<IInstructionBreakpoint>;\n\tgetWatchExpressions(): ReadonlyArray<IExpression & IEvaluate>;\n\tregisterBreakpointModes(debugType: string, modes: DebugProtocol.BreakpointMode[]): void;\n\tgetBreakpointModes(forBreakpointType: 'source' | 'exception' | 'data' | 'instruction'): DebugProtocol.BreakpointMode[];\n\treadonly onDidChangeBreakpoints: Event<IBreakpointsChangeEvent | undefined>;\n\treadonly onDidChangeCallStack: Event<void>;\n\t/**\n\t * The expression has been added, removed, or repositioned.\n\t */\n\treadonly onDidChangeWatchExpressions: Event<IExpression | undefined>;\n\t/**\n\t * The expression's value has changed.\n\t */\n\treadonly onDidChangeWatchExpressionValue: Event<IExpression | undefined>;\n\n\tfetchCallstack(thread: IThread, levels?: number): Promise<void>;\n}\n\n/**\n * An event describing a change to the set of [breakpoints](#debug.Breakpoint).\n */\nexport interface IBreakpointsChangeEvent {\n\tadded?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;\n\tremoved?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;\n\tchanged?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;\n\tsessionOnly: boolean;\n}\n\n// Debug configuration interfaces\n\nexport interface IDebugConfiguration {\n\tallowBreakpointsEverywhere: boolean;\n\tgutterMiddleClickAction: 'logpoint' | 'conditionalBreakpoint' | 'triggeredBreakpoint' | 'none';\n\topenDebug: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart' | 'openOnDebugBreak';\n\topenExplorerOnEnd: boolean;\n\tinlineValues: boolean | 'auto' | 'on' | 'off'; // boolean for back-compat\n\ttoolBarLocation: 'floating' | 'docked' | 'commandCenter' | 'hidden';\n\tshowInStatusBar: 'never' | 'always' | 'onFirstSessionStart';\n\tinternalConsoleOptions: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';\n\textensionHostDebugAdapter: boolean;\n\tenableAllHovers: boolean;\n\tshowSubSessionsInToolBar: boolean;\n\tcloseReadonlyTabsOnEnd: boolean;\n\tconsole: {\n\t\tfontSize: number;\n\t\tfontFamily: string;\n\t\tlineHeight: number;\n\t\twordWrap: boolean;\n\t\tcloseOnEnd: boolean;\n\t\tcollapseIdenticalLines: boolean;\n\t\thistorySuggestions: boolean;\n\t\tacceptSuggestionOnEnter: 'off' | 'on';\n\t\tmaximumLines: number;\n\t};\n\tfocusWindowOnBreak: boolean;\n\tfocusEditorOnBreak: boolean;\n\tonTaskErrors: 'debugAnyway' | 'showErrors' | 'prompt' | 'abort';\n\tshowBreakpointsInOverviewRuler: boolean;\n\tshowInlineBreakpointCandidates: boolean;\n\tconfirmOnExit: 'always' | 'never';\n\tdisassemblyView: {\n\t\tshowSourceCode: boolean;\n\t};\n\tautoExpandLazyVariables: 'auto' | 'off' | 'on';\n\tenableStatusBarColor: boolean;\n\tshowVariableTypes: boolean;\n\thideSlowPreLaunchWarning: boolean;\n}\n\nexport interface IGlobalConfig {\n\tversion: string;\n\tcompounds: ICompound[];\n\tconfigurations: IConfig[];\n}\n\ninterface IEnvConfig {\n\tinternalConsoleOptions?: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';\n\tpreRestartTask?: string | ITaskIdentifier;\n\tpostRestartTask?: string | ITaskIdentifier;\n\tpreLaunchTask?: string | ITaskIdentifier;\n\tpostDebugTask?: string | ITaskIdentifier;\n\tdebugServer?: number;\n\tnoDebug?: boolean;\n\tsuppressMultipleSessionWarning?: boolean;\n}\n\nexport interface IConfigPresentation {\n\thidden?: boolean;\n\tgroup?: string;\n\torder?: number;\n}\n\nexport interface IConfig extends IEnvConfig {\n\n\t// fundamental attributes\n\ttype: string;\n\trequest: string;\n\tname: string;\n\tpresentation?: IConfigPresentation;\n\t// platform specifics\n\twindows?: IEnvConfig;\n\tosx?: IEnvConfig;\n\tlinux?: IEnvConfig;\n\n\t// internals\n\t__configurationTarget?: ConfigurationTarget;\n\t__sessionId?: string;\n\t__restart?: unknown;\n\t__autoAttach?: boolean;\n\tport?: number; // TODO\n}\n\nexport interface ICompound {\n\tname: string;\n\tstopAll?: boolean;\n\tpreLaunchTask?: string | ITaskIdentifier;\n\tconfigurations: (string | { name: string; folder: string })[];\n\tpresentation?: IConfigPresentation;\n}\n\nexport interface IDebugAdapter extends IDisposable {\n\treadonly onError: Event<Error>;\n\treadonly onExit: Event<number | null>;\n\tonRequest(callback: (request: DebugProtocol.Request) => void): void;\n\tonEvent(callback: (event: DebugProtocol.Event) => void): void;\n\tstartSession(): Promise<void>;\n\tsendMessage(message: DebugProtocol.ProtocolMessage): void;\n\tsendResponse(response: DebugProtocol.Response): void;\n\tsendRequest(command: string, args: unknown, clb: (result: DebugProtocol.Response) => void, timeout?: number): number;\n\tstopSession(): Promise<void>;\n}\n\nexport interface IDebugAdapterFactory extends ITerminalLauncher {\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter;\n\tsubstituteVariables(folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;\n}\n\nexport interface IDebugAdapterExecutableOptions {\n\tcwd?: string;\n\tenv?: { [key: string]: string };\n}\n\nexport interface IDebugAdapterExecutable {\n\treadonly type: 'executable';\n\treadonly command: string;\n\treadonly args: string[];\n\treadonly options?: IDebugAdapterExecutableOptions;\n}\n\nexport interface IDebugAdapterServer {\n\treadonly type: 'server';\n\treadonly port: number;\n\treadonly host?: string;\n}\n\nexport interface IDebugAdapterNamedPipeServer {\n\treadonly type: 'pipeServer';\n\treadonly path: string;\n}\n\nexport interface IDebugAdapterInlineImpl extends IDisposable {\n\treadonly onDidSendMessage: Event<DebugProtocol.Message>;\n\thandleMessage(message: DebugProtocol.Message): void;\n}\n\nexport interface IDebugAdapterImpl {\n\treadonly type: 'implementation';\n}\n\nexport type IAdapterDescriptor = IDebugAdapterExecutable | IDebugAdapterServer | IDebugAdapterNamedPipeServer | IDebugAdapterImpl;\n\nexport interface IPlatformSpecificAdapterContribution {\n\tprogram?: string;\n\targs?: string[];\n\truntime?: string;\n\truntimeArgs?: string[];\n}\n\nexport interface IDebuggerContribution extends IPlatformSpecificAdapterContribution {\n\ttype: string;\n\tlabel?: string;\n\twin?: IPlatformSpecificAdapterContribution;\n\twinx86?: IPlatformSpecificAdapterContribution;\n\twindows?: IPlatformSpecificAdapterContribution;\n\tosx?: IPlatformSpecificAdapterContribution;\n\tlinux?: IPlatformSpecificAdapterContribution;\n\n\t// internal\n\taiKey?: string;\n\n\t// supported languages\n\tlanguages?: string[];\n\n\t// debug configuration support\n\tconfigurationAttributes?: Record<string, IJSONSchema>;\n\tinitialConfigurations?: unknown[];\n\tconfigurationSnippets?: IJSONSchemaSnippet[];\n\tvariables?: { [key: string]: string };\n\twhen?: string;\n\thiddenWhen?: string;\n\tdeprecated?: string;\n\tstrings?: { [key in DebuggerString]: string };\n\t/** @deprecated */\n\tuiMessages?: { [key in DebuggerString]: string };\n}\n\nexport interface IBreakpointContribution {\n\tlanguage: string;\n\twhen?: string;\n}\n\nexport enum DebugConfigurationProviderTriggerKind {\n\t/**\n\t *\t`DebugConfigurationProvider.provideDebugConfigurations` is called to provide the initial debug configurations for a newly created launch.json.\n\t */\n\tInitial = 1,\n\t/**\n\t * `DebugConfigurationProvider.provideDebugConfigurations` is called to provide dynamically generated debug configurations when the user asks for them through the UI (e.g. via the \"Select and Start Debugging\" command).\n\t */\n\tDynamic = 2\n}\n\nexport interface IDebugConfigurationProvider {\n\treadonly type: string;\n\treadonly triggerKind: DebugConfigurationProviderTriggerKind;\n\tresolveDebugConfiguration?(folderUri: uri | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;\n\tresolveDebugConfigurationWithSubstitutedVariables?(folderUri: uri | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;\n\tprovideDebugConfigurations?(folderUri: uri | undefined, token: CancellationToken): Promise<IConfig[]>;\n}\n\nexport interface IDebugAdapterDescriptorFactory {\n\treadonly type: string;\n\tcreateDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor>;\n}\n\ninterface ITerminalLauncher {\n\trunInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n}\n\nexport interface IConfigurationManager {\n\n\t/**\n\t * Returns an object containing the selected launch configuration and the selected configuration name. Both these fields can be null (no folder workspace).\n\t */\n\treadonly selectedConfiguration: {\n\t\tlaunch: ILaunch | undefined;\n\t\t// Potentially activates extensions\n\t\tgetConfig: () => Promise<IConfig | undefined>;\n\t\tname: string | undefined;\n\t\t// Type is used when matching dynamic configurations to their corresponding provider\n\t\ttype: string | undefined;\n\t};\n\n\tselectConfiguration(launch: ILaunch | undefined, name?: string, config?: IConfig, dynamicConfigOptions?: { type?: string }): Promise<void>;\n\n\tgetLaunches(): ReadonlyArray<ILaunch>;\n\tgetLaunch(workspaceUri: uri | undefined): ILaunch | undefined;\n\tgetAllConfigurations(): { launch: ILaunch; name: string; presentation?: IConfigPresentation }[];\n\tremoveRecentDynamicConfigurations(name: string, type: string): void;\n\tgetRecentDynamicConfigurations(): { name: string; type: string }[];\n\n\t/**\n\t * Allows to register on change of selected debug configuration.\n\t */\n\treadonly onDidSelectConfiguration: Event<void>;\n\n\t/**\n\t * Allows to register on change of selected debug configuration.\n\t */\n\treadonly onDidChangeConfigurationProviders: Event<void>;\n\n\thasDebugConfigurationProvider(debugType: string, triggerKind?: DebugConfigurationProviderTriggerKind): boolean;\n\tgetDynamicProviders(): Promise<{ label: string; type: string; pick: () => Promise<{ launch: ILaunch; config: IConfig; label: string } | undefined> }[]>;\n\tgetDynamicConfigurationsByType(type: string, token?: CancellationToken): Promise<{ launch: ILaunch; config: IConfig; label: string }[]>;\n\n\tregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): IDisposable;\n\tunregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): void;\n\n\tresolveConfigurationByProviders(folderUri: uri | undefined, type: string | undefined, debugConfiguration: unknown, token: CancellationToken): Promise<IConfig | null | undefined>;\n}\n\nexport enum DebuggerString {\n\tUnverifiedBreakpoints = 'unverifiedBreakpoints'\n}\n\nexport interface IAdapterManager {\n\n\treadonly onDidRegisterDebugger: Event<void>;\n\n\thasEnabledDebuggers(): boolean;\n\tgetDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor | undefined>;\n\tgetDebuggerLabel(type: string): string | undefined;\n\tsomeDebuggerInterestedInLanguage(language: string): boolean;\n\tgetDebugger(type: string): IDebuggerMetadata | undefined;\n\n\tactivateDebuggers(activationEvent: string, debugType?: string): Promise<void>;\n\tregisterDebugAdapterFactory(debugTypes: string[], debugAdapterFactory: IDebugAdapterFactory): IDisposable;\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter | undefined;\n\tregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): IDisposable;\n\tunregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): void;\n\n\tsubstituteVariables(debugType: string, folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;\n\trunInTerminal(debugType: string, args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n\tgetEnabledDebugger(type: string): (IDebugger & IDebuggerMetadata) | undefined;\n\tguessDebugger(gettingConfigurations: boolean): Promise<IGuessedDebugger | undefined>;\n\n\tget onDidDebuggersExtPointRead(): Event<void>;\n}\n\nexport interface IGuessedDebugger {\n\tdebugger: IDebugger;\n\twithConfig?: {\n\t\tlabel: string;\n\t\tlaunch: ILaunch;\n\t\tconfig: IConfig;\n\t};\n}\n\nexport interface ILaunch {\n\n\t/**\n\t * Resource pointing to the launch.json this object is wrapping.\n\t */\n\treadonly uri: uri;\n\n\t/**\n\t * Name of the launch.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Workspace of the launch. Can be undefined.\n\t */\n\treadonly workspace: IWorkspaceFolder | undefined;\n\n\t/**\n\t * Should this launch be shown in the debug dropdown.\n\t */\n\treadonly hidden: boolean;\n\n\t/**\n\t * Returns a configuration with the specified name.\n\t * Returns undefined if there is no configuration with the specified name.\n\t */\n\tgetConfiguration(name: string): IConfig | undefined;\n\n\t/**\n\t * Returns a compound with the specified name.\n\t * Returns undefined if there is no compound with the specified name.\n\t */\n\tgetCompound(name: string): ICompound | undefined;\n\n\t/**\n\t * Returns the names of all configurations and compounds.\n\t * Ignores configurations which are invalid.\n\t */\n\tgetConfigurationNames(ignoreCompoundsAndPresentation?: boolean): string[];\n\n\t/**\n\t * Opens the launch.json file. Creates if it does not exist.\n\t */\n\topenConfigFile(options: { preserveFocus: boolean; type?: string; suppressInitialConfigs?: boolean }, token?: CancellationToken): Promise<{ editor: IEditorPane | null; created: boolean }>;\n}\n\n// Debug service interfaces\n\nexport const IDebugService = createDecorator<IDebugService>('debugService');\n\nexport interface IDebugService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Gets the current debug state.\n\t */\n\treadonly state: State;\n\n\treadonly initializingOptions?: IDebugSessionOptions | undefined;\n\n\t/**\n\t * Allows to register on debug state changes.\n\t */\n\treadonly onDidChangeState: Event<State>;\n\n\t/**\n\t * Allows to register on sessions about to be created (not yet fully initialised).\n\t * This is fired exactly one time for any given session.\n\t */\n\treadonly onWillNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Fired when a new debug session is started. This may fire multiple times\n\t * for a single session due to restarts.\n\t */\n\treadonly onDidNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Allows to register on end session events.\n\t *\n\t * Contains a boolean indicating whether the session will restart. If restart\n\t * is true, the session should not considered to be dead yet.\n\t */\n\treadonly onDidEndSession: Event<{ session: IDebugSession; restart: boolean }>;\n\n\t/**\n\t * Gets the configuration manager.\n\t */\n\tgetConfigurationManager(): IConfigurationManager;\n\n\t/**\n\t * Gets the adapter manager.\n\t */\n\tgetAdapterManager(): IAdapterManager;\n\n\t/**\n\t * Sets the focused stack frame and evaluates all expressions against the newly focused stack frame,\n\t */\n\tfocusStackFrame(focusedStackFrame: IStackFrame | undefined, thread?: IThread, session?: IDebugSession, options?: { explicit?: boolean; preserveFocus?: boolean; sideBySide?: boolean; pinned?: boolean }): Promise<void>;\n\n\t/**\n\t * Returns true if breakpoints can be set for a given editor model. Depends on mode.\n\t */\n\tcanSetBreakpointsIn(model: EditorIModel): boolean;\n\n\t/**\n\t * Adds new breakpoints to the model for the file specified with the uri. Notifies debug adapter of breakpoint changes.\n\t */\n\taddBreakpoints(uri: uri, rawBreakpoints: IBreakpointData[], ariaAnnounce?: boolean): Promise<IBreakpoint[]>;\n\n\t/**\n\t * Updates the breakpoints.\n\t */\n\tupdateBreakpoints(originalUri: uri, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void>;\n\n\t/**\n\t * Enables or disables all breakpoints. If breakpoint is passed only enables or disables the passed breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tenableOrDisableBreakpoints(enable: boolean, breakpoint?: IEnablement): Promise<void>;\n\n\t/**\n\t * Sets the global activated property for all breakpoints.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tsetBreakpointsActivated(activated: boolean): Promise<void>;\n\n\t/**\n\t * Removes all breakpoints. If id is passed only removes the breakpoint associated with that id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Adds a new function breakpoint for the given name.\n\t */\n\taddFunctionBreakpoint(opts?: IFunctionBreakpointOptions, id?: string): void;\n\n\t/**\n\t * Updates an already existing function breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tupdateFunctionBreakpoint(id: string, update: { name?: string; hitCondition?: string; condition?: string }): Promise<void>;\n\n\t/**\n\t * Removes all function breakpoints. If id is passed only removes the function breakpoint with the passed id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveFunctionBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Adds a new data breakpoint.\n\t */\n\taddDataBreakpoint(opts: IDataBreakpointOptions): Promise<void>;\n\n\t/**\n\t * Updates an already existing data breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tupdateDataBreakpoint(id: string, update: { hitCondition?: string; condition?: string }): Promise<void>;\n\n\t/**\n\t * Removes all data breakpoints. If id is passed only removes the data breakpoint with the passed id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveDataBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Adds a new instruction breakpoint.\n\t */\n\taddInstructionBreakpoint(opts: IInstructionBreakpointOptions): Promise<void>;\n\n\t/**\n\t * Removes all instruction breakpoints. If address is passed only removes the instruction breakpoint with the passed address.\n\t * The address should be the address string supplied by the debugger from the \"Disassemble\" request.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveInstructionBreakpoints(instructionReference?: string, offset?: number): Promise<void>;\n\n\tsetExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string | undefined): Promise<void>;\n\n\t/**\n\t * Creates breakpoints based on the sesison filter options. This will create\n\t * disabled breakpoints (or enabled, if the filter indicates it's a default)\n\t * for each filter provided in the session.\n\t */\n\tsetExceptionBreakpointsForSession(session: IDebugSession, filters: DebugProtocol.ExceptionBreakpointsFilter[]): void;\n\n\t/**\n\t * Sends all breakpoints to the passed session.\n\t * If session is not passed, sends all breakpoints to each session.\n\t */\n\tsendAllBreakpoints(session?: IDebugSession): Promise<void>;\n\n\t/**\n\t * Sends breakpoints of the given source to the passed session.\n\t */\n\tsendBreakpoints(modelUri: uri, sourceModified?: boolean, session?: IDebugSession): Promise<void>;\n\n\t/**\n\t * Adds a new watch expression and evaluates it against the debug adapter.\n\t */\n\taddWatchExpression(name?: string): void;\n\n\t/**\n\t * Renames a watch expression and evaluates it against the debug adapter.\n\t */\n\trenameWatchExpression(id: string, newName: string): void;\n\n\t/**\n\t * Moves a watch expression to a new possition. Used for reordering watch expressions.\n\t */\n\tmoveWatchExpression(id: string, position: number): void;\n\n\t/**\n\t * Removes all watch expressions. If id is passed only removes the watch expression with the passed id.\n\t */\n\tremoveWatchExpressions(id?: string): void;\n\n\t/**\n\t * Starts debugging. If the configOrName is not passed uses the selected configuration in the debug dropdown.\n\t * Also saves all files, manages if compounds are present in the configuration\n\t * and resolveds configurations via DebugConfigurationProviders.\n\t *\n\t * Returns true if the start debugging was successful. For compound launches, all configurations have to start successfully for it to return success.\n\t * On errors the startDebugging will throw an error, however some error and cancelations are handled and in that case will simply return false.\n\t */\n\tstartDebugging(launch: ILaunch | undefined, configOrName?: IConfig | string, options?: IDebugSessionOptions, saveBeforeStart?: boolean): Promise<boolean>;\n\n\t/**\n\t * Restarts a session or creates a new one if there is no active session.\n\t */\n\trestartSession(session: IDebugSession, restartData?: unknown): Promise<void>;\n\n\t/**\n\t * Stops the session. If no session is specified then all sessions are stopped.\n\t */\n\tstopSession(session: IDebugSession | undefined, disconnect?: boolean, suspend?: boolean): Promise<void>;\n\n\t/**\n\t * Makes unavailable all sources with the passed uri. Source will appear as grayed out in callstack view.\n\t */\n\tsourceIsNotAvailable(uri: uri): void;\n\n\t/**\n\t * Gets the current debug model.\n\t */\n\tgetModel(): IDebugModel;\n\n\t/**\n\t * Gets the current view model.\n\t */\n\tgetViewModel(): IViewModel;\n\n\t/**\n\t * Resumes execution and pauses until the given position is reached.\n\t */\n\trunTo(uri: uri, lineNumber: number, column?: number): Promise<void>;\n}\n\n// Editor interfaces\nexport const enum BreakpointWidgetContext {\n\tCONDITION = 0,\n\tHIT_COUNT = 1,\n\tLOG_MESSAGE = 2,\n\tTRIGGER_POINT = 3\n}\n\nexport interface IDebugEditorContribution extends editorCommon.IEditorContribution {\n\tshowHover(range: Position, focus: boolean): Promise<void>;\n\taddLaunchConfiguration(): Promise<void>;\n\tcloseExceptionWidget(): void;\n}\n\nexport interface IBreakpointEditorContribution extends editorCommon.IEditorContribution {\n\tshowBreakpointWidget(lineNumber: number, column: number | undefined, context?: BreakpointWidgetContext): void;\n\tcloseBreakpointWidget(): void;\n\tgetContextMenuActionsAtPosition(lineNumber: number, model: EditorIModel): IAction[];\n}\n\nexport interface IReplConfiguration {\n\treadonly fontSize: number;\n\treadonly fontFamily: string;\n\treadonly lineHeight: number;\n\treadonly cssLineHeight: string;\n\treadonly backgroundColor: Color | undefined;\n\treadonly fontSizeForTwistie: number;\n}\n\nexport interface IReplOptions {\n\treadonly replConfiguration: IReplConfiguration;\n}\n\nexport interface IDebugVisualizationContext {\n\tvariable: DebugProtocol.Variable;\n\tcontainerId?: number;\n\tframeId?: number;\n\tthreadId: number;\n\tsessionId: string;\n}\n\nexport const enum DebugVisualizationType {\n\tCommand,\n\tTree,\n}\n\nexport type MainThreadDebugVisualization =\n\t| { type: DebugVisualizationType.Command }\n\t| { type: DebugVisualizationType.Tree; id: string };\n\n\nexport const enum DebugTreeItemCollapsibleState {\n\tNone = 0,\n\tCollapsed = 1,\n\tExpanded = 2\n}\n\nexport interface IDebugVisualizationTreeItem {\n\tid: number;\n\tlabel: string;\n\tdescription?: string;\n\tcollapsibleState: DebugTreeItemCollapsibleState;\n\tcontextValue?: string;\n\tcanEdit?: boolean;\n}\n\nexport namespace IDebugVisualizationTreeItem {\n\texport type Serialized = IDebugVisualizationTreeItem;\n\texport const deserialize = (v: Serialized): IDebugVisualizationTreeItem => v;\n\texport const serialize = (item: IDebugVisualizationTreeItem): Serialized => item;\n}\n\nexport interface IDebugVisualization {\n\tid: number;\n\tname: string;\n\ticonPath: { light?: URI; dark: URI } | undefined;\n\ticonClass: string | undefined;\n\tvisualization: MainThreadDebugVisualization | undefined;\n}\n\nexport namespace IDebugVisualization {\n\texport interface Serialized {\n\t\tid: number;\n\t\tname: string;\n\t\ticonPath?: { light?: UriComponents; dark: UriComponents };\n\t\ticonClass?: string;\n\t\tvisualization?: MainThreadDebugVisualization;\n\t}\n\n\texport const deserialize = (v: Serialized): IDebugVisualization => ({\n\t\tid: v.id,\n\t\tname: v.name,\n\t\ticonPath: v.iconPath && { light: URI.revive(v.iconPath.light), dark: URI.revive(v.iconPath.dark) },\n\t\ticonClass: v.iconClass,\n\t\tvisualization: v.visualization,\n\t});\n\n\texport const serialize = (visualizer: IDebugVisualization): Serialized => visualizer;\n}\n"]}