{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/debug/test/common/mockDebug.ts","vs/workbench/contrib/debug/test/common/mockDebug.ts"],"names":[],"mappings":"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","file":"mockDebug.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DeferredPromise } from '../../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { Event } from '../../../../../base/common/event.js';\nimport { URI as uri } from '../../../../../base/common/uri.js';\nimport { IPosition, Position } from '../../../../../editor/common/core/position.js';\nimport { ITextModel } from '../../../../../editor/common/model.js';\nimport { NullLogService } from '../../../../../platform/log/common/log.js';\nimport { IStorageService } from '../../../../../platform/storage/common/storage.js';\nimport { IWorkspaceFolder } from '../../../../../platform/workspace/common/workspace.js';\nimport { AbstractDebugAdapter } from '../../common/abstractDebugAdapter.js';\nimport { AdapterEndEvent, IAdapterManager, IBreakpoint, IBreakpointData, IBreakpointUpdateData, IConfig, IConfigurationManager, IDataBreakpoint, IDataBreakpointInfoResponse, IDebugLocationReferenced, IDebugModel, IDebugService, IDebugSession, IDebugSessionOptions, IDebugger, IExceptionBreakpoint, IExceptionInfo, IFunctionBreakpoint, IInstructionBreakpoint, ILaunch, IMemoryRegion, INewReplElementData, IRawModelUpdate, IRawStoppedDetails, IReplElement, IStackFrame, IThread, IViewModel, LoadedSourceEvent, State } from '../../common/debug.js';\nimport { DebugCompoundRoot } from '../../common/debugCompoundRoot.js';\nimport { IInstructionBreakpointOptions } from '../../common/debugModel.js';\nimport { Source } from '../../common/debugSource.js';\nimport { DebugStorage } from '../../common/debugStorage.js';\n\nexport class MockDebugService implements IDebugService {\n\t_serviceBrand: undefined;\n\n\tget state(): State {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onWillNewSession(): Event<IDebugSession> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidNewSession(): Event<IDebugSession> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidEndSession(): Event<{ session: IDebugSession; restart: boolean }> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidChangeState(): Event<State> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetConfigurationManager(): IConfigurationManager {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetAdapterManager(): IAdapterManager {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcanSetBreakpointsIn(model: ITextModel): boolean {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tfocusStackFrame(focusedStackFrame: IStackFrame): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsendAllBreakpoints(session?: IDebugSession): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsendBreakpoints(modelUri: uri, sourceModified?: boolean | undefined, session?: IDebugSession | undefined): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddBreakpoints(uri: uri, rawBreakpoints: IBreakpointData[]): Promise<IBreakpoint[]> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tupdateBreakpoints(uri: uri, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tenableOrDisableBreakpoints(enabled: boolean): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetBreakpointsActivated(): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveBreakpoints(): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddInstructionBreakpoint(opts: IInstructionBreakpointOptions): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tremoveInstructionBreakpoints(address?: string): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsetExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsetExceptionBreakpointsForSession(session: IDebugSession, data: DebugProtocol.ExceptionBreakpointsFilter[]): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\taddFunctionBreakpoint(): void { }\n\n\tmoveWatchExpression(id: string, position: number): void { }\n\n\tupdateFunctionBreakpoint(id: string, update: { name?: string; hitCondition?: string; condition?: string }): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveFunctionBreakpoints(id?: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddDataBreakpoint(): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tupdateDataBreakpoint(id: string, update: { hitCondition?: string; condition?: string }): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveDataBreakpoints(id?: string | undefined): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\taddReplExpression(name: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveReplExpressions(): void { }\n\n\taddWatchExpression(name?: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\trenameWatchExpression(id: string, newName: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveWatchExpressions(id?: string): void { }\n\n\tstartDebugging(launch: ILaunch, configOrName?: IConfig | string, options?: IDebugSessionOptions): Promise<boolean> {\n\t\treturn Promise.resolve(true);\n\t}\n\n\trestartSession(): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstopSession(): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetModel(): IDebugModel {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetViewModel(): IViewModel {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsourceIsNotAvailable(uri: uri): void { }\n\n\ttryToAutoFocusStackFrame(thread: IThread): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\trunTo(uri: uri, lineNumber: number, column?: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n}\n\nexport class MockSession implements IDebugSession {\n\treadonly suppressDebugToolbar = false;\n\treadonly suppressDebugStatusbar = false;\n\treadonly suppressDebugView = false;\n\treadonly autoExpandLazyVariables = false;\n\n\tdispose(): void {\n\n\t}\n\n\tgetMemory(memoryReference: string): IMemoryRegion {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tget onDidInvalidateMemory(): Event<DebugProtocol.MemoryEvent> {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\treadMemory(memoryReference: string, offset: number, count: number): Promise<DebugProtocol.ReadMemoryResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\twriteMemory(memoryReference: string, offset: number, data: string, allowPartial?: boolean): Promise<DebugProtocol.WriteMemoryResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcancelCorrelatedTestRun(): void {\n\n\t}\n\n\tget compoundRoot(): DebugCompoundRoot | undefined {\n\t\treturn undefined;\n\t}\n\n\tget saveBeforeRestart(): boolean {\n\t\treturn true;\n\t}\n\n\tget isSimpleUI(): boolean {\n\t\treturn false;\n\t}\n\n\tget lifecycleManagedByParent(): boolean {\n\t\treturn false;\n\t}\n\n\tstepInTargets(frameId: number): Promise<{ id: number; label: string }[]> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcancel(_progressId: string): Promise<DebugProtocol.CancelResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tbreakpointsLocations(uri: uri, lineNumber: number): Promise<IPosition[]> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tdataBytesBreakpointInfo(address: string, bytes: number): Promise<IDataBreakpointInfoResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tdataBreakpointInfo(name: string, variablesReference?: number | undefined, frameId?: number | undefined): Promise<{ dataId: string | null; description: string; canPersist?: boolean | undefined } | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsubId: string | undefined;\n\n\tget compact(): boolean {\n\t\treturn false;\n\t}\n\n\tsetSubId(subId: string | undefined): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tget parentSession(): IDebugSession | undefined {\n\t\treturn undefined;\n\t}\n\n\tgetReplElements(): IReplElement[] {\n\t\treturn [];\n\t}\n\n\thasSeparateRepl(): boolean {\n\t\treturn true;\n\t}\n\n\tremoveReplExpressions(): void { }\n\tget onDidChangeReplElements(): Event<IReplElement | undefined> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddReplExpression(stackFrame: IStackFrame, name: string): Promise<void> {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tappendToRepl(data: INewReplElementData): void { }\n\n\tconfiguration: IConfig = { type: 'mock', name: 'mock', request: 'launch' };\n\tunresolvedConfiguration: IConfig = { type: 'mock', name: 'mock', request: 'launch' };\n\tstate = State.Stopped;\n\troot!: IWorkspaceFolder;\n\tcapabilities: DebugProtocol.Capabilities = {};\n\n\tgetId(): string {\n\t\treturn 'mock';\n\t}\n\n\tgetLabel(): string {\n\t\treturn 'mockname';\n\t}\n\n\tget name(): string {\n\t\treturn 'mockname';\n\t}\n\n\tsetName(name: string): void {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetSourceForUri(modelUri: uri): Source {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetThread(threadId: number): IThread {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetStoppedDetails(): IRawStoppedDetails {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidCustomEvent(): Event<DebugProtocol.Event> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidLoadedSource(): Event<LoadedSourceEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidChangeState(): Event<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidEndAdapter(): Event<AdapterEndEvent | undefined> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidChangeName(): Event<string> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidProgressStart(): Event<DebugProtocol.ProgressStartEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidProgressUpdate(): Event<DebugProtocol.ProgressUpdateEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidProgressEnd(): Event<DebugProtocol.ProgressEndEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetConfiguration(configuration: { resolved: IConfig; unresolved: IConfig }) { }\n\n\tgetAllThreads(): IThread[] {\n\t\treturn [];\n\t}\n\n\tgetSource(raw: DebugProtocol.Source): Source {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetLoadedSources(): Promise<Source[]> {\n\t\treturn Promise.resolve([]);\n\t}\n\n\tcompletions(frameId: number, threadId: number, text: string, position: Position): Promise<DebugProtocol.CompletionsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tclearThreads(removeThreads: boolean, reference?: number): void { }\n\n\trawUpdate(data: IRawModelUpdate): void { }\n\n\tinitialize(dbgr: IDebugger): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tlaunchOrAttach(config: IConfig): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\trestart(): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendBreakpoints(modelUri: uri, bpts: IBreakpoint[], sourceModified: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendInstructionBreakpoints(dbps: IInstructionBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tgetDebugProtocolBreakpoint(breakpointId: string): DebugProtocol.Breakpoint | undefined {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tcustomRequest(request: string, args: any): Promise<DebugProtocol.Response> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstackTrace(threadId: number, startFrame: number, levels: number, token: CancellationToken): Promise<DebugProtocol.StackTraceResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\texceptionInfo(threadId: number): Promise<IExceptionInfo> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tscopes(frameId: number): Promise<DebugProtocol.ScopesResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tvariables(variablesReference: number, threadId: number | undefined, filter: 'indexed' | 'named', start: number, count: number): Promise<DebugProtocol.VariablesResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tevaluate(expression: string, frameId: number, context?: string): Promise<DebugProtocol.EvaluateResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\trestartFrame(frameId: number, threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tnext(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstepIn(threadId: number, targetId?: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstepOut(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstepBack(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tcontinue(threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\treverseContinue(threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tpause(threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tterminateThreads(threadIds: number[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsetVariable(variablesReference: number, name: string, value: string): Promise<DebugProtocol.SetVariableResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsetExpression(frameId: number, expression: string, value: string): Promise<DebugProtocol.SetExpressionResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tloadSource(resource: uri): Promise<DebugProtocol.SourceResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tdisassemble(memoryReference: string, offset: number, instructionOffset: number, instructionCount: number): Promise<DebugProtocol.DisassembledInstruction[] | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tterminate(restart = false): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tdisconnect(restart = false): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tgotoTargets(source: DebugProtocol.Source, line: number, column?: number | undefined): Promise<DebugProtocol.GotoTargetsResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tgoto(threadId: number, targetId: number): Promise<DebugProtocol.GotoResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tresolveLocationReference(locationReference: number): Promise<IDebugLocationReferenced> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n}\n\nexport class MockRawSession {\n\n\tcapabilities: DebugProtocol.Capabilities = {};\n\tdisconnected = false;\n\tsessionLengthInSeconds: number = 0;\n\n\treadyForBreakpoints = true;\n\temittedStopped = true;\n\n\tgetLengthInSeconds(): number {\n\t\treturn 100;\n\t}\n\n\tstackTrace(args: DebugProtocol.StackTraceArguments): Promise<DebugProtocol.StackTraceResponse> {\n\t\treturn Promise.resolve({\n\t\t\tseq: 1,\n\t\t\ttype: 'response',\n\t\t\trequest_seq: 1,\n\t\t\tsuccess: true,\n\t\t\tcommand: 'stackTrace',\n\t\t\tbody: {\n\t\t\t\tstackFrames: [{\n\t\t\t\t\tid: 1,\n\t\t\t\t\tname: 'mock',\n\t\t\t\t\tline: 5,\n\t\t\t\t\tcolumn: 6\n\t\t\t\t}]\n\t\t\t}\n\t\t});\n\t}\n\n\texceptionInfo(args: DebugProtocol.ExceptionInfoArguments): Promise<DebugProtocol.ExceptionInfoResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tlaunchOrAttach(args: IConfig): Promise<DebugProtocol.Response> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tscopes(args: DebugProtocol.ScopesArguments): Promise<DebugProtocol.ScopesResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tvariables(args: DebugProtocol.VariablesArguments): Promise<DebugProtocol.VariablesResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tevaluate(args: DebugProtocol.EvaluateArguments): Promise<DebugProtocol.EvaluateResponse> {\n\t\treturn Promise.resolve(null!);\n\t}\n\n\tcustom(request: string, args: any): Promise<DebugProtocol.Response> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tterminate(restart = false): Promise<DebugProtocol.TerminateResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tdisconnect(): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tthreads(): Promise<DebugProtocol.ThreadsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstepIn(args: DebugProtocol.StepInArguments): Promise<DebugProtocol.StepInResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstepOut(args: DebugProtocol.StepOutArguments): Promise<DebugProtocol.StepOutResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstepBack(args: DebugProtocol.StepBackArguments): Promise<DebugProtocol.StepBackResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tcontinue(args: DebugProtocol.ContinueArguments): Promise<DebugProtocol.ContinueResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\treverseContinue(args: DebugProtocol.ReverseContinueArguments): Promise<DebugProtocol.ReverseContinueResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tpause(args: DebugProtocol.PauseArguments): Promise<DebugProtocol.PauseResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tterminateThreads(args: DebugProtocol.TerminateThreadsArguments): Promise<DebugProtocol.TerminateThreadsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetVariable(args: DebugProtocol.SetVariableArguments): Promise<DebugProtocol.SetVariableResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\trestartFrame(args: DebugProtocol.RestartFrameArguments): Promise<DebugProtocol.RestartFrameResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tcompletions(args: DebugProtocol.CompletionsArguments): Promise<DebugProtocol.CompletionsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tnext(args: DebugProtocol.NextArguments): Promise<DebugProtocol.NextResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsource(args: DebugProtocol.SourceArguments): Promise<DebugProtocol.SourceResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tloadedSources(args: DebugProtocol.LoadedSourcesArguments): Promise<DebugProtocol.LoadedSourcesResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetBreakpoints(args: DebugProtocol.SetBreakpointsArguments): Promise<DebugProtocol.SetBreakpointsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetFunctionBreakpoints(args: DebugProtocol.SetFunctionBreakpointsArguments): Promise<DebugProtocol.SetFunctionBreakpointsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetExceptionBreakpoints(args: DebugProtocol.SetExceptionBreakpointsArguments): Promise<DebugProtocol.SetExceptionBreakpointsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\treadonly onDidStop: Event<DebugProtocol.StoppedEvent> = null!;\n}\n\nexport class MockDebugAdapter extends AbstractDebugAdapter {\n\tprivate seq = 0;\n\n\tprivate pendingResponses = new Map<string, DeferredPromise<DebugProtocol.Response>>();\n\n\tstartSession(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tstopSession(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tsendMessage(message: DebugProtocol.ProtocolMessage): void {\n\t\tif (message.type === 'request') {\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst request = message as DebugProtocol.Request;\n\t\t\t\tswitch (request.command) {\n\t\t\t\t\tcase 'evaluate':\n\t\t\t\t\t\tthis.evaluate(request, request.arguments);\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.sendResponseBody(request, {});\n\t\t\t\treturn;\n\t\t\t}, 0);\n\t\t} else if (message.type === 'response') {\n\t\t\tconst response = message as DebugProtocol.Response;\n\t\t\tif (this.pendingResponses.has(response.command)) {\n\t\t\t\tthis.pendingResponses.get(response.command)!.complete(response);\n\t\t\t}\n\t\t}\n\t}\n\n\tsendResponseBody(request: DebugProtocol.Request, body: any) {\n\t\tconst response: DebugProtocol.Response = {\n\t\t\tseq: ++this.seq,\n\t\t\ttype: 'response',\n\t\t\trequest_seq: request.seq,\n\t\t\tcommand: request.command,\n\t\t\tsuccess: true,\n\t\t\tbody\n\t\t};\n\t\tthis.acceptMessage(response);\n\t}\n\n\tsendEventBody(event: string, body: any) {\n\t\tconst response: DebugProtocol.Event = {\n\t\t\tseq: ++this.seq,\n\t\t\ttype: 'event',\n\t\t\tevent,\n\t\t\tbody\n\t\t};\n\t\tthis.acceptMessage(response);\n\t}\n\n\twaitForResponseFromClient(command: string): Promise<DebugProtocol.Response> {\n\t\tconst deferred = new DeferredPromise<DebugProtocol.Response>();\n\t\tif (this.pendingResponses.has(command)) {\n\t\t\treturn this.pendingResponses.get(command)!.p;\n\t\t}\n\n\t\tthis.pendingResponses.set(command, deferred);\n\t\treturn deferred.p;\n\t}\n\n\tsendRequestBody(command: string, args: any) {\n\t\tconst response: DebugProtocol.Request = {\n\t\t\tseq: ++this.seq,\n\t\t\ttype: 'request',\n\t\t\tcommand,\n\t\t\targuments: args\n\t\t};\n\t\tthis.acceptMessage(response);\n\t}\n\n\tevaluate(request: DebugProtocol.Request, args: DebugProtocol.EvaluateArguments) {\n\t\tif (args.expression.indexOf('before.') === 0) {\n\t\t\tthis.sendEventBody('output', { output: args.expression });\n\t\t}\n\n\t\tthis.sendResponseBody(request, {\n\t\t\tresult: '=' + args.expression,\n\t\t\tvariablesReference: 0\n\t\t});\n\n\t\tif (args.expression.indexOf('after.') === 0) {\n\t\t\tthis.sendEventBody('output', { output: args.expression });\n\t\t}\n\t}\n}\n\nexport class MockDebugStorage extends DebugStorage {\n\n\tconstructor(storageService: IStorageService) {\n\t\tsuper(storageService, undefined!, undefined!, new NullLogService());\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DeferredPromise } from '../../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { Event } from '../../../../../base/common/event.js';\nimport { URI as uri } from '../../../../../base/common/uri.js';\nimport { IPosition, Position } from '../../../../../editor/common/core/position.js';\nimport { ITextModel } from '../../../../../editor/common/model.js';\nimport { NullLogService } from '../../../../../platform/log/common/log.js';\nimport { IStorageService } from '../../../../../platform/storage/common/storage.js';\nimport { IWorkspaceFolder } from '../../../../../platform/workspace/common/workspace.js';\nimport { AbstractDebugAdapter } from '../../common/abstractDebugAdapter.js';\nimport { AdapterEndEvent, IAdapterManager, IBreakpoint, IBreakpointData, IBreakpointUpdateData, IConfig, IConfigurationManager, IDataBreakpoint, IDataBreakpointInfoResponse, IDebugLocationReferenced, IDebugModel, IDebugService, IDebugSession, IDebugSessionOptions, IDebugger, IExceptionBreakpoint, IExceptionInfo, IFunctionBreakpoint, IInstructionBreakpoint, ILaunch, IMemoryRegion, INewReplElementData, IRawModelUpdate, IRawStoppedDetails, IReplElement, IStackFrame, IThread, IViewModel, LoadedSourceEvent, State } from '../../common/debug.js';\nimport { DebugCompoundRoot } from '../../common/debugCompoundRoot.js';\nimport { IInstructionBreakpointOptions } from '../../common/debugModel.js';\nimport { Source } from '../../common/debugSource.js';\nimport { DebugStorage } from '../../common/debugStorage.js';\n\nexport class MockDebugService implements IDebugService {\n\t_serviceBrand: undefined;\n\n\tget state(): State {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onWillNewSession(): Event<IDebugSession> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidNewSession(): Event<IDebugSession> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidEndSession(): Event<{ session: IDebugSession; restart: boolean }> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidChangeState(): Event<State> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetConfigurationManager(): IConfigurationManager {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetAdapterManager(): IAdapterManager {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcanSetBreakpointsIn(model: ITextModel): boolean {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tfocusStackFrame(focusedStackFrame: IStackFrame): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsendAllBreakpoints(session?: IDebugSession): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsendBreakpoints(modelUri: uri, sourceModified?: boolean | undefined, session?: IDebugSession | undefined): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddBreakpoints(uri: uri, rawBreakpoints: IBreakpointData[]): Promise<IBreakpoint[]> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tupdateBreakpoints(uri: uri, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tenableOrDisableBreakpoints(enabled: boolean): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetBreakpointsActivated(): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveBreakpoints(): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddInstructionBreakpoint(opts: IInstructionBreakpointOptions): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tremoveInstructionBreakpoints(address?: string): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsetExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsetExceptionBreakpointsForSession(session: IDebugSession, data: DebugProtocol.ExceptionBreakpointsFilter[]): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\taddFunctionBreakpoint(): void { }\n\n\tmoveWatchExpression(id: string, position: number): void { }\n\n\tupdateFunctionBreakpoint(id: string, update: { name?: string; hitCondition?: string; condition?: string }): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveFunctionBreakpoints(id?: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddDataBreakpoint(): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tupdateDataBreakpoint(id: string, update: { hitCondition?: string; condition?: string }): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveDataBreakpoints(id?: string | undefined): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\taddReplExpression(name: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveReplExpressions(): void { }\n\n\taddWatchExpression(name?: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\trenameWatchExpression(id: string, newName: string): Promise<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tremoveWatchExpressions(id?: string): void { }\n\n\tstartDebugging(launch: ILaunch, configOrName?: IConfig | string, options?: IDebugSessionOptions): Promise<boolean> {\n\t\treturn Promise.resolve(true);\n\t}\n\n\trestartSession(): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstopSession(): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetModel(): IDebugModel {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetViewModel(): IViewModel {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsourceIsNotAvailable(uri: uri): void { }\n\n\ttryToAutoFocusStackFrame(thread: IThread): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\trunTo(uri: uri, lineNumber: number, column?: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n}\n\nexport class MockSession implements IDebugSession {\n\treadonly suppressDebugToolbar = false;\n\treadonly suppressDebugStatusbar = false;\n\treadonly suppressDebugView = false;\n\treadonly autoExpandLazyVariables = false;\n\n\tdispose(): void {\n\n\t}\n\n\tgetMemory(memoryReference: string): IMemoryRegion {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tget onDidInvalidateMemory(): Event<DebugProtocol.MemoryEvent> {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\treadMemory(memoryReference: string, offset: number, count: number): Promise<DebugProtocol.ReadMemoryResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\twriteMemory(memoryReference: string, offset: number, data: string, allowPartial?: boolean): Promise<DebugProtocol.WriteMemoryResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcancelCorrelatedTestRun(): void {\n\n\t}\n\n\tget compoundRoot(): DebugCompoundRoot | undefined {\n\t\treturn undefined;\n\t}\n\n\tget saveBeforeRestart(): boolean {\n\t\treturn true;\n\t}\n\n\tget isSimpleUI(): boolean {\n\t\treturn false;\n\t}\n\n\tget lifecycleManagedByParent(): boolean {\n\t\treturn false;\n\t}\n\n\tstepInTargets(frameId: number): Promise<{ id: number; label: string }[]> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcancel(_progressId: string): Promise<DebugProtocol.CancelResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tbreakpointsLocations(uri: uri, lineNumber: number): Promise<IPosition[]> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tdataBytesBreakpointInfo(address: string, bytes: number): Promise<IDataBreakpointInfoResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tdataBreakpointInfo(name: string, variablesReference?: number | undefined, frameId?: number | undefined): Promise<{ dataId: string | null; description: string; canPersist?: boolean | undefined } | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsubId: string | undefined;\n\n\tget compact(): boolean {\n\t\treturn false;\n\t}\n\n\tsetSubId(subId: string | undefined): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tget parentSession(): IDebugSession | undefined {\n\t\treturn undefined;\n\t}\n\n\tgetReplElements(): IReplElement[] {\n\t\treturn [];\n\t}\n\n\thasSeparateRepl(): boolean {\n\t\treturn true;\n\t}\n\n\tremoveReplExpressions(): void { }\n\tget onDidChangeReplElements(): Event<IReplElement | undefined> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\taddReplExpression(stackFrame: IStackFrame, name: string): Promise<void> {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tappendToRepl(data: INewReplElementData): void { }\n\n\tconfiguration: IConfig = { type: 'mock', name: 'mock', request: 'launch' };\n\tunresolvedConfiguration: IConfig = { type: 'mock', name: 'mock', request: 'launch' };\n\tstate = State.Stopped;\n\troot!: IWorkspaceFolder;\n\tcapabilities: DebugProtocol.Capabilities = {};\n\n\tgetId(): string {\n\t\treturn 'mock';\n\t}\n\n\tgetLabel(): string {\n\t\treturn 'mockname';\n\t}\n\n\tget name(): string {\n\t\treturn 'mockname';\n\t}\n\n\tsetName(name: string): void {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetSourceForUri(modelUri: uri): Source {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetThread(threadId: number): IThread {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetStoppedDetails(): IRawStoppedDetails {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidCustomEvent(): Event<DebugProtocol.Event> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidLoadedSource(): Event<LoadedSourceEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidChangeState(): Event<void> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidEndAdapter(): Event<AdapterEndEvent | undefined> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidChangeName(): Event<string> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidProgressStart(): Event<DebugProtocol.ProgressStartEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidProgressUpdate(): Event<DebugProtocol.ProgressUpdateEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tget onDidProgressEnd(): Event<DebugProtocol.ProgressEndEvent> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetConfiguration(configuration: { resolved: IConfig; unresolved: IConfig }) { }\n\n\tgetAllThreads(): IThread[] {\n\t\treturn [];\n\t}\n\n\tgetSource(raw: DebugProtocol.Source): Source {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tgetLoadedSources(): Promise<Source[]> {\n\t\treturn Promise.resolve([]);\n\t}\n\n\tcompletions(frameId: number, threadId: number, text: string, position: Position): Promise<DebugProtocol.CompletionsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tclearThreads(removeThreads: boolean, reference?: number): void { }\n\n\trawUpdate(data: IRawModelUpdate): void { }\n\n\tinitialize(dbgr: IDebugger): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tlaunchOrAttach(config: IConfig): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\trestart(): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendBreakpoints(modelUri: uri, bpts: IBreakpoint[], sourceModified: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsendInstructionBreakpoints(dbps: IInstructionBreakpoint[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tgetDebugProtocolBreakpoint(breakpointId: string): DebugProtocol.Breakpoint | undefined {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tcustomRequest(request: string, args: any): Promise<DebugProtocol.Response> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstackTrace(threadId: number, startFrame: number, levels: number, token: CancellationToken): Promise<DebugProtocol.StackTraceResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\texceptionInfo(threadId: number): Promise<IExceptionInfo> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tscopes(frameId: number): Promise<DebugProtocol.ScopesResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tvariables(variablesReference: number, threadId: number | undefined, filter: 'indexed' | 'named', start: number, count: number): Promise<DebugProtocol.VariablesResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tevaluate(expression: string, frameId: number, context?: string): Promise<DebugProtocol.EvaluateResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\trestartFrame(frameId: number, threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tnext(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstepIn(threadId: number, targetId?: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstepOut(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tstepBack(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tcontinue(threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\treverseContinue(threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tpause(threadId: number): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tterminateThreads(threadIds: number[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsetVariable(variablesReference: number, name: string, value: string): Promise<DebugProtocol.SetVariableResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsetExpression(frameId: number, expression: string, value: string): Promise<DebugProtocol.SetExpressionResponse | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tloadSource(resource: uri): Promise<DebugProtocol.SourceResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tdisassemble(memoryReference: string, offset: number, instructionOffset: number, instructionCount: number): Promise<DebugProtocol.DisassembledInstruction[] | undefined> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tterminate(restart = false): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tdisconnect(restart = false): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tgotoTargets(source: DebugProtocol.Source, line: number, column?: number | undefined): Promise<DebugProtocol.GotoTargetsResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tgoto(threadId: number, targetId: number): Promise<DebugProtocol.GotoResponse> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tresolveLocationReference(locationReference: number): Promise<IDebugLocationReferenced> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n}\n\nexport class MockRawSession {\n\n\tcapabilities: DebugProtocol.Capabilities = {};\n\tdisconnected = false;\n\tsessionLengthInSeconds: number = 0;\n\n\treadyForBreakpoints = true;\n\temittedStopped = true;\n\n\tgetLengthInSeconds(): number {\n\t\treturn 100;\n\t}\n\n\tstackTrace(args: DebugProtocol.StackTraceArguments): Promise<DebugProtocol.StackTraceResponse> {\n\t\treturn Promise.resolve({\n\t\t\tseq: 1,\n\t\t\ttype: 'response',\n\t\t\trequest_seq: 1,\n\t\t\tsuccess: true,\n\t\t\tcommand: 'stackTrace',\n\t\t\tbody: {\n\t\t\t\tstackFrames: [{\n\t\t\t\t\tid: 1,\n\t\t\t\t\tname: 'mock',\n\t\t\t\t\tline: 5,\n\t\t\t\t\tcolumn: 6\n\t\t\t\t}]\n\t\t\t}\n\t\t});\n\t}\n\n\texceptionInfo(args: DebugProtocol.ExceptionInfoArguments): Promise<DebugProtocol.ExceptionInfoResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tlaunchOrAttach(args: IConfig): Promise<DebugProtocol.Response> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tscopes(args: DebugProtocol.ScopesArguments): Promise<DebugProtocol.ScopesResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tvariables(args: DebugProtocol.VariablesArguments): Promise<DebugProtocol.VariablesResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tevaluate(args: DebugProtocol.EvaluateArguments): Promise<DebugProtocol.EvaluateResponse> {\n\t\treturn Promise.resolve(null!);\n\t}\n\n\tcustom(request: string, args: any): Promise<DebugProtocol.Response> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tterminate(restart = false): Promise<DebugProtocol.TerminateResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tdisconnect(): Promise<any> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tthreads(): Promise<DebugProtocol.ThreadsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstepIn(args: DebugProtocol.StepInArguments): Promise<DebugProtocol.StepInResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstepOut(args: DebugProtocol.StepOutArguments): Promise<DebugProtocol.StepOutResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tstepBack(args: DebugProtocol.StepBackArguments): Promise<DebugProtocol.StepBackResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tcontinue(args: DebugProtocol.ContinueArguments): Promise<DebugProtocol.ContinueResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\treverseContinue(args: DebugProtocol.ReverseContinueArguments): Promise<DebugProtocol.ReverseContinueResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tpause(args: DebugProtocol.PauseArguments): Promise<DebugProtocol.PauseResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tterminateThreads(args: DebugProtocol.TerminateThreadsArguments): Promise<DebugProtocol.TerminateThreadsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetVariable(args: DebugProtocol.SetVariableArguments): Promise<DebugProtocol.SetVariableResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\trestartFrame(args: DebugProtocol.RestartFrameArguments): Promise<DebugProtocol.RestartFrameResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tcompletions(args: DebugProtocol.CompletionsArguments): Promise<DebugProtocol.CompletionsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tnext(args: DebugProtocol.NextArguments): Promise<DebugProtocol.NextResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsource(args: DebugProtocol.SourceArguments): Promise<DebugProtocol.SourceResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tloadedSources(args: DebugProtocol.LoadedSourcesArguments): Promise<DebugProtocol.LoadedSourcesResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetBreakpoints(args: DebugProtocol.SetBreakpointsArguments): Promise<DebugProtocol.SetBreakpointsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetFunctionBreakpoints(args: DebugProtocol.SetFunctionBreakpointsArguments): Promise<DebugProtocol.SetFunctionBreakpointsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tsetExceptionBreakpoints(args: DebugProtocol.SetExceptionBreakpointsArguments): Promise<DebugProtocol.SetExceptionBreakpointsResponse> {\n\t\tthrow new Error('not implemented');\n\t}\n\n\treadonly onDidStop: Event<DebugProtocol.StoppedEvent> = null!;\n}\n\nexport class MockDebugAdapter extends AbstractDebugAdapter {\n\tprivate seq = 0;\n\n\tprivate pendingResponses = new Map<string, DeferredPromise<DebugProtocol.Response>>();\n\n\tstartSession(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tstopSession(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tsendMessage(message: DebugProtocol.ProtocolMessage): void {\n\t\tif (message.type === 'request') {\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst request = message as DebugProtocol.Request;\n\t\t\t\tswitch (request.command) {\n\t\t\t\t\tcase 'evaluate':\n\t\t\t\t\t\tthis.evaluate(request, request.arguments);\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.sendResponseBody(request, {});\n\t\t\t\treturn;\n\t\t\t}, 0);\n\t\t} else if (message.type === 'response') {\n\t\t\tconst response = message as DebugProtocol.Response;\n\t\t\tif (this.pendingResponses.has(response.command)) {\n\t\t\t\tthis.pendingResponses.get(response.command)!.complete(response);\n\t\t\t}\n\t\t}\n\t}\n\n\tsendResponseBody(request: DebugProtocol.Request, body: any) {\n\t\tconst response: DebugProtocol.Response = {\n\t\t\tseq: ++this.seq,\n\t\t\ttype: 'response',\n\t\t\trequest_seq: request.seq,\n\t\t\tcommand: request.command,\n\t\t\tsuccess: true,\n\t\t\tbody\n\t\t};\n\t\tthis.acceptMessage(response);\n\t}\n\n\tsendEventBody(event: string, body: any) {\n\t\tconst response: DebugProtocol.Event = {\n\t\t\tseq: ++this.seq,\n\t\t\ttype: 'event',\n\t\t\tevent,\n\t\t\tbody\n\t\t};\n\t\tthis.acceptMessage(response);\n\t}\n\n\twaitForResponseFromClient(command: string): Promise<DebugProtocol.Response> {\n\t\tconst deferred = new DeferredPromise<DebugProtocol.Response>();\n\t\tif (this.pendingResponses.has(command)) {\n\t\t\treturn this.pendingResponses.get(command)!.p;\n\t\t}\n\n\t\tthis.pendingResponses.set(command, deferred);\n\t\treturn deferred.p;\n\t}\n\n\tsendRequestBody(command: string, args: any) {\n\t\tconst response: DebugProtocol.Request = {\n\t\t\tseq: ++this.seq,\n\t\t\ttype: 'request',\n\t\t\tcommand,\n\t\t\targuments: args\n\t\t};\n\t\tthis.acceptMessage(response);\n\t}\n\n\tevaluate(request: DebugProtocol.Request, args: DebugProtocol.EvaluateArguments) {\n\t\tif (args.expression.indexOf('before.') === 0) {\n\t\t\tthis.sendEventBody('output', { output: args.expression });\n\t\t}\n\n\t\tthis.sendResponseBody(request, {\n\t\t\tresult: '=' + args.expression,\n\t\t\tvariablesReference: 0\n\t\t});\n\n\t\tif (args.expression.indexOf('after.') === 0) {\n\t\t\tthis.sendEventBody('output', { output: args.expression });\n\t\t}\n\t}\n}\n\nexport class MockDebugStorage extends DebugStorage {\n\n\tconstructor(storageService: IStorageService) {\n\t\tsuper(storageService, undefined!, undefined!, new NullLogService());\n\t}\n}\n"]}