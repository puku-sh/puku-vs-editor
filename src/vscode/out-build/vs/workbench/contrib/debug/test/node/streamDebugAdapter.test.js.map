{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/debug/test/node/streamDebugAdapter.test.ts","vs/workbench/contrib/debug/test/node/streamDebugAdapter.test.ts"],"names":[],"mappings":"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","file":"streamDebugAdapter.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport * as crypto from 'crypto';\nimport * as net from 'net';\nimport * as platform from '../../../../../base/common/platform.js';\nimport { tmpdir } from 'os';\nimport { join } from '../../../../../base/common/path.js';\nimport * as ports from '../../../../../base/node/ports.js';\nimport { SocketDebugAdapter, NamedPipeDebugAdapter, StreamDebugAdapter } from '../../node/debugAdapter.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\n\n\nfunction sendInitializeRequest(debugAdapter: StreamDebugAdapter): Promise<DebugProtocol.Response> {\n\treturn new Promise((resolve, reject) => {\n\t\tdebugAdapter.sendRequest('initialize', { adapterID: 'test' }, (result) => {\n\t\t\tresolve(result);\n\t\t}, 3000);\n\t});\n}\n\nfunction serverConnection(socket: net.Socket) {\n\tsocket.on('data', (data: Buffer) => {\n\t\tconst str = data.toString().split('\\r\\n')[2];\n\t\tconst request = JSON.parse(str);\n\t\tconst response: any = {\n\t\t\tseq: request.seq,\n\t\t\trequest_seq: request.seq,\n\t\t\ttype: 'response',\n\t\t\tcommand: request.command\n\t\t};\n\t\tif (request.arguments.adapterID === 'test') {\n\t\t\tresponse.success = true;\n\t\t} else {\n\t\t\tresponse.success = false;\n\t\t\tresponse.message = 'failed';\n\t\t}\n\n\t\tconst responsePayload = JSON.stringify(response);\n\t\tsocket.write(`Content-Length: ${responsePayload.length}\\r\\n\\r\\n${responsePayload}`);\n\t});\n}\n\nsuite('Debug - StreamDebugAdapter', () => {\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest(`StreamDebugAdapter (NamedPipeDebugAdapter) can initialize a connection`, async () => {\n\n\t\tconst pipeName = crypto.randomBytes(10).toString('hex');\n\t\tconst pipePath = platform.isWindows ? join('\\\\\\\\.\\\\pipe\\\\', pipeName) : join(tmpdir(), pipeName);\n\t\tconst server = await new Promise<net.Server>((resolve, reject) => {\n\t\t\tconst server = net.createServer(serverConnection);\n\t\t\tserver.once('listening', () => resolve(server));\n\t\t\tserver.once('error', reject);\n\t\t\tserver.listen(pipePath);\n\t\t});\n\n\t\tconst debugAdapter = new NamedPipeDebugAdapter({\n\t\t\ttype: 'pipeServer',\n\t\t\tpath: pipePath\n\t\t});\n\t\ttry {\n\t\t\tawait debugAdapter.startSession();\n\t\t\tconst response: DebugProtocol.Response = await sendInitializeRequest(debugAdapter);\n\t\t\tassert.strictEqual(response.command, 'initialize');\n\t\t\tassert.strictEqual(response.request_seq, 1);\n\t\t\tassert.strictEqual(response.success, true, response.message);\n\t\t} finally {\n\t\t\tawait debugAdapter.stopSession();\n\t\t\tserver.close();\n\t\t\tdebugAdapter.dispose();\n\t\t}\n\t});\n\n\ttest(`StreamDebugAdapter (SocketDebugAdapter) can initialize a connection`, async () => {\n\n\t\tconst rndPort = Math.floor(Math.random() * 1000 + 8000);\n\t\tconst port = await ports.findFreePort(rndPort, 10 /* try 10 ports */, 3000 /* try up to 3 seconds */, 87 /* skip 87 ports between attempts */);\n\t\tconst server = net.createServer(serverConnection).listen(port);\n\t\tconst debugAdapter = new SocketDebugAdapter({\n\t\t\ttype: 'server',\n\t\t\tport\n\t\t});\n\t\ttry {\n\t\t\tawait debugAdapter.startSession();\n\t\t\tconst response: DebugProtocol.Response = await sendInitializeRequest(debugAdapter);\n\t\t\tassert.strictEqual(response.command, 'initialize');\n\t\t\tassert.strictEqual(response.request_seq, 1);\n\t\t\tassert.strictEqual(response.success, true, response.message);\n\t\t} finally {\n\t\t\tawait debugAdapter.stopSession();\n\t\t\tserver.close();\n\t\t\tdebugAdapter.dispose();\n\t\t}\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport * as crypto from 'crypto';\nimport * as net from 'net';\nimport * as platform from '../../../../../base/common/platform.js';\nimport { tmpdir } from 'os';\nimport { join } from '../../../../../base/common/path.js';\nimport * as ports from '../../../../../base/node/ports.js';\nimport { SocketDebugAdapter, NamedPipeDebugAdapter, StreamDebugAdapter } from '../../node/debugAdapter.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\n\n\nfunction sendInitializeRequest(debugAdapter: StreamDebugAdapter): Promise<DebugProtocol.Response> {\n\treturn new Promise((resolve, reject) => {\n\t\tdebugAdapter.sendRequest('initialize', { adapterID: 'test' }, (result) => {\n\t\t\tresolve(result);\n\t\t}, 3000);\n\t});\n}\n\nfunction serverConnection(socket: net.Socket) {\n\tsocket.on('data', (data: Buffer) => {\n\t\tconst str = data.toString().split('\\r\\n')[2];\n\t\tconst request = JSON.parse(str);\n\t\tconst response: any = {\n\t\t\tseq: request.seq,\n\t\t\trequest_seq: request.seq,\n\t\t\ttype: 'response',\n\t\t\tcommand: request.command\n\t\t};\n\t\tif (request.arguments.adapterID === 'test') {\n\t\t\tresponse.success = true;\n\t\t} else {\n\t\t\tresponse.success = false;\n\t\t\tresponse.message = 'failed';\n\t\t}\n\n\t\tconst responsePayload = JSON.stringify(response);\n\t\tsocket.write(`Content-Length: ${responsePayload.length}\\r\\n\\r\\n${responsePayload}`);\n\t});\n}\n\nsuite('Debug - StreamDebugAdapter', () => {\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest(`StreamDebugAdapter (NamedPipeDebugAdapter) can initialize a connection`, async () => {\n\n\t\tconst pipeName = crypto.randomBytes(10).toString('hex');\n\t\tconst pipePath = platform.isWindows ? join('\\\\\\\\.\\\\pipe\\\\', pipeName) : join(tmpdir(), pipeName);\n\t\tconst server = await new Promise<net.Server>((resolve, reject) => {\n\t\t\tconst server = net.createServer(serverConnection);\n\t\t\tserver.once('listening', () => resolve(server));\n\t\t\tserver.once('error', reject);\n\t\t\tserver.listen(pipePath);\n\t\t});\n\n\t\tconst debugAdapter = new NamedPipeDebugAdapter({\n\t\t\ttype: 'pipeServer',\n\t\t\tpath: pipePath\n\t\t});\n\t\ttry {\n\t\t\tawait debugAdapter.startSession();\n\t\t\tconst response: DebugProtocol.Response = await sendInitializeRequest(debugAdapter);\n\t\t\tassert.strictEqual(response.command, 'initialize');\n\t\t\tassert.strictEqual(response.request_seq, 1);\n\t\t\tassert.strictEqual(response.success, true, response.message);\n\t\t} finally {\n\t\t\tawait debugAdapter.stopSession();\n\t\t\tserver.close();\n\t\t\tdebugAdapter.dispose();\n\t\t}\n\t});\n\n\ttest(`StreamDebugAdapter (SocketDebugAdapter) can initialize a connection`, async () => {\n\n\t\tconst rndPort = Math.floor(Math.random() * 1000 + 8000);\n\t\tconst port = await ports.findFreePort(rndPort, 10 /* try 10 ports */, 3000 /* try up to 3 seconds */, 87 /* skip 87 ports between attempts */);\n\t\tconst server = net.createServer(serverConnection).listen(port);\n\t\tconst debugAdapter = new SocketDebugAdapter({\n\t\t\ttype: 'server',\n\t\t\tport\n\t\t});\n\t\ttry {\n\t\t\tawait debugAdapter.startSession();\n\t\t\tconst response: DebugProtocol.Response = await sendInitializeRequest(debugAdapter);\n\t\t\tassert.strictEqual(response.command, 'initialize');\n\t\t\tassert.strictEqual(response.request_seq, 1);\n\t\t\tassert.strictEqual(response.success, true, response.message);\n\t\t} finally {\n\t\t\tawait debugAdapter.stopSession();\n\t\t\tserver.close();\n\t\t\tdebugAdapter.dispose();\n\t\t}\n\t});\n});\n"]}