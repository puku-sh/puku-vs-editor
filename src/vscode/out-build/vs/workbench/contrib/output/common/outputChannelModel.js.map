{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/output/common/outputChannelModel.ts","vs/workbench/contrib/output/common/outputChannelModel.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;AAEhG,OAAO,EAAE,qBAAqB,EAAE,MAAM,4DAA4D,CAAC;AACnG,OAAO,KAAK,SAAS,MAAM,sCAAsC,CAAC;AAElE,OAAO,EAAE,oBAAoB,EAAE,MAAM,oDAAoD,CAAC;AAC1F,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,kCAAkC,CAAC;AAElE,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AAC9E,OAAO,EAAuB,YAAY,EAAE,qBAAqB,EAAE,MAAM,4CAA4C,CAAC;AACtH,OAAO,EAAE,aAAa,EAAE,MAAM,6CAA6C,CAAC;AAE5E,OAAO,EAAE,UAAU,EAAE,YAAY,EAAe,iBAAiB,EAAE,eAAe,EAAE,MAAM,sCAAsC,CAAC;AACjI,OAAO,EAAE,QAAQ,EAAE,MAAM,kCAAkC,CAAC;AAC5D,OAAO,EAAE,aAAa,EAAwB,MAAM,iDAAiD,CAAC;AACtG,OAAO,EAAE,QAAQ,EAAE,MAAM,4CAA4C,CAAC;AACtE,OAAO,EAAE,KAAK,EAAE,MAAM,yCAAyC,CAAC;AAChE,OAAO,EAAE,QAAQ,EAAE,MAAM,mCAAmC,CAAC;AAC7D,OAAO,EAAW,cAAc,EAAE,WAAW,EAAE,QAAQ,EAAE,MAAM,wCAAwC,CAAC;AACxG,OAAO,EAAqB,uBAAuB,EAAE,MAAM,yCAAyC,CAAC;AACrG,OAAO,EAAmC,QAAQ,EAAE,uBAAuB,EAAE,MAAM,2CAA2C,CAAC;AAC/H,OAAO,EAAE,mBAAmB,EAAE,MAAM,mCAAmC,CAAC;AACxE,OAAO,EAAE,SAAS,EAAE,MAAM,8CAA8C,CAAC;AACzE,OAAO,EAAE,YAAY,EAAE,UAAU,EAAE,MAAM,mCAAmC,CAAC;AAE7E,MAAM,eAAe,GAAG,qGAAqG,CAAC;AAE9H,MAAM,UAAU,eAAe,CAAC,KAAiB,EAAE,UAAkB;IACpE,MAAM,WAAW,GAAG,KAAK,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;IACrD,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IAChD,IAAI,KAAK,EAAE,CAAC;QACX,MAAM,SAAS,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;QAC/C,MAAM,cAAc,GAAG,IAAI,KAAK,CAAC,UAAU,EAAE,CAAC,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QAC7E,MAAM,QAAQ,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACzC,MAAM,aAAa,GAAG,IAAI,KAAK,CAAC,UAAU,EAAE,cAAc,CAAC,SAAS,GAAG,CAAC,EAAE,UAAU,EAAE,cAAc,CAAC,SAAS,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACtI,MAAM,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAC1B,MAAM,SAAS,GAAG,UAAU,CAAC;QAC7B,IAAI,OAAO,GAAG,UAAU,CAAC;QAEzB,MAAM,SAAS,GAAG,KAAK,CAAC,YAAY,EAAE,CAAC;QACvC,OAAO,OAAO,GAAG,SAAS,EAAE,CAAC;YAC5B,MAAM,eAAe,GAAG,KAAK,CAAC,cAAc,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;YAC1D,MAAM,UAAU,GAAG,OAAO,GAAG,CAAC,KAAK,SAAS,IAAI,eAAe,KAAK,EAAE,CAAC,CAAC,iCAAiC;YACzG,IAAI,eAAe,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,UAAU,EAAE,CAAC;gBACzD,MAAM;YACP,CAAC;YACD,OAAO,EAAE,CAAC;QACX,CAAC;QACD,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC;QAChF,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,cAAc,EAAE,QAAQ,EAAE,aAAa,EAAE,QAAQ,EAAE,CAAC;IAChF,CAAC;IACD,OAAO,IAAI,CAAC;AACb,CAAC;AAED,QAAQ,CAAC,CAAC,gBAAgB,CAAI,KAAiB,EAAE,OAAmC;IACnF,KAAK,IAAI,UAAU,GAAG,CAAC,EAAE,UAAU,IAAI,KAAK,CAAC,YAAY,EAAE,EAAE,UAAU,EAAE,EAAE,CAAC;QAC3E,MAAM,QAAQ,GAAG,eAAe,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;QACpD,IAAI,QAAQ,EAAE,CAAC;YACd,MAAM,OAAO,CAAC,QAAQ,CAAC,CAAC;YACxB,UAAU,GAAG,QAAQ,CAAC,KAAK,CAAC,aAAa,CAAC;QAC3C,CAAC;IACF,CAAC;AACF,CAAC;AAED,SAAS,qBAAqB,CAAC,QAAmB,EAAE,UAAkB;IACrE,OAAO;QACN,GAAG,QAAQ;QACX,KAAK,EAAE,IAAI,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,UAAU,GAAG,QAAQ,CAAC,KAAK,CAAC,aAAa,GAAG,QAAQ,CAAC,KAAK,CAAC,eAAe,EAAE,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC;QAC9J,cAAc,EAAE,IAAI,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,cAAc,CAAC,WAAW,EAAE,UAAU,EAAE,QAAQ,CAAC,cAAc,CAAC,SAAS,CAAC;QACzH,aAAa,EAAE,IAAI,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,aAAa,CAAC,WAAW,EAAE,UAAU,EAAE,QAAQ,CAAC,aAAa,CAAC,SAAS,CAAC;KACtH,CAAC;AACH,CAAC;AAED,SAAS,aAAa,CAAC,KAAa;IACnC,QAAQ,KAAK,CAAC,WAAW,EAAE,EAAE,CAAC;QAC7B,KAAK,OAAO;YACX,OAAO,QAAQ,CAAC,KAAK,CAAC;QACvB,KAAK,OAAO;YACX,OAAO,QAAQ,CAAC,KAAK,CAAC;QACvB,KAAK,MAAM;YACV,OAAO,QAAQ,CAAC,IAAI,CAAC;QACtB,KAAK,SAAS;YACb,OAAO,QAAQ,CAAC,OAAO,CAAC;QACzB,KAAK,OAAO;YACX,OAAO,QAAQ,CAAC,KAAK,CAAC;QACvB;YACC,MAAM,IAAI,KAAK,CAAC,sBAAsB,KAAK,EAAE,CAAC,CAAC;IACjD,CAAC;AACF,CAAC;AAwBD,IAAM,mBAAmB,GAAzB,MAAM,mBAAoB,SAAQ,UAAU;IAG3C,IAAI,WAAW,KAAK,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;IAGrD,IAAI,UAAU,KAAK,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;IAanD,YACC,EAAE,IAAI,EAAE,QAAQ,EAAwB,EAC1B,WAA0C,EACjC,oBAA4D,EACtE,UAAwC;QAErD,KAAK,EAAE,CAAC;QAJuB,gBAAW,GAAX,WAAW,CAAc;QAChB,yBAAoB,GAApB,oBAAoB,CAAuB;QACrD,eAAU,GAAV,UAAU,CAAa;QArBrC,iBAAY,GAAG,IAAI,OAAO,EAAQ,CAAC;QAGnC,gBAAW,GAAG,IAAI,OAAO,EAAQ,CAAC;QAG3C,aAAQ,GAAY,KAAK,CAAC;QAE1B,SAAI,GAAuB,EAAE,CAAC;QAE9B,eAAU,GAAgB,EAAE,CAAC;QAC7B,gBAAW,GAAW,CAAC,CAAC;QACxB,cAAS,GAAW,CAAC,CAAC;QAa7B,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,WAAW,GAAG,IAAI,gBAAgB,CAAO,GAAG,CAAC,CAAC;QACnD,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;IACpD,CAAC;IAED,KAAK,CAAC,MAAe;QACpB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,WAAW,GAAG,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC;QAC/D,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;IACtB,CAAC;IAED,UAAU;QACT,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC;QAClC,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;IACtB,CAAC;IAED,KAAK;QACJ,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YACpB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,iBAAiB,EAAE,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;YACnE,IAAI,CAAC,IAAI,EAAE,CAAC;YACZ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACtB,CAAC;IACF,CAAC;IAED,OAAO;QACN,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACnB,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC;YAC1B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;YACtB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,iBAAiB,EAAE,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;QACpE,CAAC;IACF,CAAC;IAEO,IAAI;QACX,MAAM,IAAI,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QAC1D,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;YAC5C,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE,CAAC;gBACjC,MAAM,KAAK,CAAC;YACb,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAEO,KAAK,CAAC,OAAO;QACpB,IAAI,CAAC;YACJ,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAClD,OAAO;YACR,CAAC;YACD,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACxD,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,EAAE,CAAC;gBAC7B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;gBACtB,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;oBACvD,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBACd,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;gBACzB,CAAC;qBAAM,CAAC;oBACP,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;gBAC1B,CAAC;YACF,CAAC;QACF,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,qBAAqB,CAAC,KAAK,CAAC,+CAAuC,EAAE,CAAC;gBACzE,MAAM,KAAK,CAAC;YACb,CAAC;QACF,CAAC;IACF,CAAC;IAED,aAAa;QACZ,OAAO,IAAI,CAAC,UAAU,CAAC;IACxB,CAAC;IAED,KAAK,CAAC,UAAU,CAAC,sBAAgC;QAChD,IAAI,CAAC;YACJ,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAClD,OAAO;oBACN,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,OAAO,EAAE,EAAE;oBACX,OAAO,EAAE,GAAG,EAAE,GAAe,CAAC;iBAC9B,CAAC;YACH,CAAC;YACD,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;YACjG,MAAM,OAAO,GAAG,WAAW,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;YAC7C,MAAM,UAAU,GAAG,sBAAsB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC5H,IAAI,QAAQ,GAAG,KAAK,CAAC;YACrB,OAAO;gBACN,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,OAAO;gBACP,OAAO,EAAE,GAAG,EAAE;oBACb,IAAI,CAAC,QAAQ,EAAE,CAAC;wBACf,QAAQ,GAAG,IAAI,CAAC;wBAChB,IAAI,CAAC,SAAS,IAAI,WAAW,CAAC,KAAK,CAAC,UAAU,CAAC;wBAC/C,IAAI,CAAC,IAAI,GAAG,WAAW,CAAC,IAAI,CAAC;wBAC7B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,CAAC;oBACrC,CAAC;gBACF,CAAC;aACD,CAAC;QACH,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,qBAAqB,CAAC,KAAK,CAAC,+CAAuC,EAAE,CAAC;gBACzE,MAAM,KAAK,CAAC;YACb,CAAC;YACD,OAAO;gBACN,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,OAAO,EAAE,EAAE;gBACX,OAAO,EAAE,GAAG,EAAE,GAAe,CAAC;aAC9B,CAAC;QACH,CAAC;IACF,CAAC;IAEO,eAAe,CAAC,OAAe,EAAE,YAAmC;QAC3E,MAAM,KAAK,GAAG,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,SAAS,EAAE,OAAO,EAAE,QAAQ,EAAE,SAAS,CAAC,wBAAwB,EAAE,IAAI,CAAC,CAAC;QAC/H,IAAI,CAAC;YACJ,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC;gBAChC,OAAO,EAAE,CAAC;YACX,CAAC;YACD,MAAM,UAAU,GAAgB,EAAE,CAAC;YACnC,IAAI,uBAAuB,GAAG,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACtF,KAAK,MAAM,KAAK,IAAI,gBAAgB,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,qBAAqB,CAAC,CAAC,EAAE,uBAAuB,CAAC,CAAC,EAAE,CAAC;gBACvG,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACvB,uBAAuB,GAAG,KAAK,CAAC,KAAK,CAAC,aAAa,GAAG,CAAC,CAAC;YACzD,CAAC;YACD,OAAO,UAAU,CAAC;QACnB,CAAC;gBAAS,CAAC;YACV,KAAK,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC;IACF,CAAC;CACD,CAAA;AApJK,mBAAmB;IAqBtB,WAAA,YAAY,CAAA;IACZ,WAAA,qBAAqB,CAAA;IACrB,WAAA,WAAW,CAAA;GAvBR,mBAAmB,CAoJxB;AAED,IAAM,wBAAwB,GAA9B,MAAM,wBAAyB,SAAQ,UAAU;IAWhD,YACC,UAAkC,EACX,oBAA4D,EACrE,WAA0C,EAC3C,UAAwC;QAErD,KAAK,EAAE,CAAC;QAJgC,yBAAoB,GAApB,oBAAoB,CAAuB;QACpD,gBAAW,GAAX,WAAW,CAAc;QAC1B,eAAU,GAAV,UAAU,CAAa;QAbrC,iBAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QAC3D,gBAAW,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;QACtC,eAAU,GAAG,KAAK,CAAC,IAAI,CAAC;QAEzB,eAAU,GAAgB,EAAE,CAAC;QACpB,6BAAwB,GAA6C,EAAE,CAAC;QAEjF,aAAQ,GAAY,KAAK,CAAC;QASjC,KAAK,MAAM,IAAI,IAAI,UAAU,EAAE,CAAC;YAC/B,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC,CAAC;QAC1E,CAAC;QACD,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE;YAChC,KAAK,MAAM,CAAC,EAAE,WAAW,CAAC,IAAI,IAAI,CAAC,wBAAwB,EAAE,CAAC;gBAC7D,WAAW,CAAC,OAAO,EAAE,CAAC;YACvB,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,yBAAyB,CAAC,IAA0B;QAC3D,MAAM,WAAW,GAAG,IAAI,eAAe,EAAE,CAAC;QAC1C,MAAM,UAAU,GAAG,WAAW,CAAC,GAAG,CAAC,IAAI,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;QAChI,WAAW,CAAC,GAAG,CAAC,UAAU,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QACxE,OAAO,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;IAClC,CAAC;IAED,KAAK;QACJ,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YACpB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACrB,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,wBAAwB,EAAE,CAAC;gBACtD,MAAM,CAAC,KAAK,EAAE,CAAC;YAChB,CAAC;QACF,CAAC;IACF,CAAC;IAED,OAAO;QACN,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACnB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;YACtB,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,wBAAwB,EAAE,CAAC;gBACtD,MAAM,CAAC,OAAO,EAAE,CAAC;YAClB,CAAC;QACF,CAAC;IACF,CAAC;IAED,WAAW,CAAC,KAA6B;QACxC,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC;QAClC,IAAI,WAAW,EAAE,CAAC;YACjB,IAAI,CAAC,OAAO,EAAE,CAAC;QAChB,CAAC;QAED,MAAM,MAAM,GAAG,UAAU,CAAC,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;QACtJ,KAAK,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,IAAI,MAAM,EAAE,CAAC;YACvD,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC,CAAC;YAC3E,MAAM,eAAe,GAAG,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,KAAK,EAAE,WAAW,EAAE,GAAG,OAAO,CAAC,CAAC;YAC7F,KAAK,MAAM,CAAC,EAAE,WAAW,CAAC,IAAI,eAAe,EAAE,CAAC;gBAC/C,WAAW,CAAC,OAAO,EAAE,CAAC;YACvB,CAAC;QACF,CAAC;QAED,IAAI,WAAW,EAAE,CAAC;YACjB,IAAI,CAAC,KAAK,EAAE,CAAC;QACd,CAAC;IACF,CAAC;IAED,KAAK;QACJ,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,wBAAwB,EAAE,CAAC;YACtD,MAAM,CAAC,KAAK,EAAE,CAAC;QAChB,CAAC;QACD,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;IACtB,CAAC;IAED,UAAU;QACT,KAAK,MAAM,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,wBAAwB,EAAE,CAAC;YACtD,MAAM,CAAC,UAAU,EAAE,CAAC;QACrB,CAAC;QACD,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;IACtB,CAAC;IAED,aAAa;QACZ,OAAO,IAAI,CAAC,UAAU,CAAC;IACxB,CAAC;IAED,KAAK,CAAC,UAAU;QACf,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC5G,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAC7G,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,OAAO;YACN,OAAO;YACP,OAAO,EAAE,GAAG,EAAE;gBACb,IAAI,CAAC,QAAQ,EAAE,CAAC;oBACf,QAAQ,GAAG,IAAI,CAAC;oBAChB,OAAO,CAAC,OAAO,CAAC,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC;oBAC5C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,CAAC;gBACrC,CAAC;YACF,CAAC;SACD,CAAC;IACH,CAAC;IAEO,iBAAiB,CAAC,OAA4C,EAAE,SAAgC;QAEvG,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QAErD,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC1B,OAAO,EAAE,UAAU,EAAE,EAAE,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC;QACxC,CAAC;QAED,MAAM,UAAU,GAAgB,EAAE,CAAC;QACnC,MAAM,QAAQ,GAAa,EAAE,CAAC;QAC9B,MAAM,OAAO,GAAG,CAAC,KAAiB,EAAE,QAAmB,EAAE,IAAY,EAAuB,EAAE;YAC7F,MAAM,WAAW,GAAG,KAAK,CAAC,eAAe,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YAC1D,MAAM,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,aAAa,CAAC,SAAS,CAAC,KAAK,IAAI,IAAI,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC;YACzK,OAAO,CAAC;oBACP,GAAG,QAAQ;oBACX,QAAQ,EAAE,IAAI;oBACd,KAAK,EAAE,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,eAAe,EAAE,QAAQ,CAAC,aAAa,CAAC,WAAW,EAAE,QAAQ,CAAC,KAAK,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC;iBAChM,EAAE,OAAO,CAAC,CAAC;QACb,CAAC,CAAC;QAEF,MAAM,KAAK,GAAG,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,QAAQ,EAAE,SAAS,CAAC,wBAAwB,EAAE,IAAI,CAAC,CAAC;QAC1I,IAAI,CAAC;YACJ,KAAK,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,IAAI,gBAAgB,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;gBACtG,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC1B,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACxB,CAAC;QACF,CAAC;gBAAS,CAAC;YACV,KAAK,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC;QAED,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC;YACrD,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;YACzC,MAAM,KAAK,GAAG,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,SAAS,EAAE,OAAO,EAAE,QAAQ,EAAE,SAAS,CAAC,wBAAwB,EAAE,IAAI,CAAC,CAAC;YAC/H,IAAI,CAAC;gBACJ,MAAM,QAAQ,GAAG,gBAAgB,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;gBACzE,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;gBAC3B,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;oBACnB,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;oBACvC,MAAM,eAAe,GAAG,CAAC,QAAQ,CAAC,CAAC;oBACnC,MAAM,aAAa,GAAG,CAAC,OAAO,CAAC,CAAC;oBAEhC,IAAI,cAAc,CAAC;oBAEnB,mEAAmE;oBACnE,gDAAgD;oBAChD,IAAI,QAAQ,CAAC,SAAS,IAAI,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC;wBACvE,cAAc,GAAG,UAAU,CAAC,MAAM,CAAC;wBACnC,KAAK,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC;4BACjE,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;4BACpC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;wBACnC,CAAC;oBACF,CAAC;yBACI,CAAC;wBACL,IAAI,QAAQ,CAAC,SAAS,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC;4BACnD,gEAAgE;4BAChE,+BAA+B;4BAC/B,cAAc,GAAG,CAAC,CAAC;wBACpB,CAAC;6BAAM,CAAC;4BACP,sCAAsC;4BACtC,MAAM,GAAG,GAAG,YAAY,CAAC,UAAU,EAAE,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,SAAS,CAAC,CAAC;4BACpF,cAAc,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;wBACvC,CAAC;wBAED,uGAAuG;wBACvG,KAAK,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,IAAI,UAAU,CAAC,cAAc,CAAC,CAAC,SAAS,EAAE,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC;4BACpI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;4BACpC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;wBACnC,CAAC;oBACF,CAAC;oBAED,QAAQ,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC,EAAE,GAAG,aAAa,CAAC,CAAC;oBACrD,UAAU,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC,EAAE,GAAG,eAAe,CAAC,CAAC;gBAC1D,CAAC;YACF,CAAC;oBAAS,CAAC;gBACV,KAAK,CAAC,OAAO,EAAE,CAAC;YACjB,CAAC;QACF,CAAC;QAED,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,MAAM,iBAAiB,GAAgB,EAAE,CAAC;QAC1C,IAAI,uBAAuB,GAAG,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAChF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC5C,OAAO,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;YAC9B,MAAM,eAAe,GAAG,qBAAqB,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,uBAAuB,CAAC,CAAC;YACtF,iBAAiB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YACxC,uBAAuB,GAAG,eAAe,CAAC,KAAK,CAAC,aAAa,GAAG,CAAC,CAAC;QACnE,CAAC;QAED,OAAO,EAAE,UAAU,EAAE,iBAAiB,EAAE,OAAO,EAAE,CAAC;IACnD,CAAC;CAED,CAAA;AAtMK,wBAAwB;IAa3B,WAAA,qBAAqB,CAAA;IACrB,WAAA,YAAY,CAAA;IACZ,WAAA,WAAW,CAAA;GAfR,wBAAwB,CAsM7B;AAEM,IAAe,8BAA8B,GAA7C,MAAe,8BAA+B,SAAQ,UAAU;IAgBtE,YACkB,QAAa,EACb,QAA4B,EAC5B,qBAAuC,EACzC,YAA8C,EACvC,mBAA0D;QAEhF,KAAK,EAAE,CAAC;QANS,aAAQ,GAAR,QAAQ,CAAK;QACb,aAAQ,GAAR,QAAQ,CAAoB;QAC5B,0BAAqB,GAArB,qBAAqB,CAAkB;QACtB,iBAAY,GAAZ,YAAY,CAAe;QACtB,wBAAmB,GAAnB,mBAAmB,CAAsB;QAnBhE,eAAU,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QACzD,cAAS,GAAgB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;QAE9C,qBAAgB,GAA+B,IAAI,CAAC;QAE7C,oBAAe,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,iBAAiB,EAAmB,CAAC,CAAC;QAClF,UAAK,GAAsB,IAAI,CAAC;QAClC,0BAAqB,GAAY,KAAK,CAAC;QAC9B,kCAA6B,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,iBAAiB,EAA2B,CAAC,CAAC;QACjG,oBAAe,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,gBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC;IAa7E,CAAC;IAED,KAAK,CAAC,SAAS;QACd,IAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC,aAAa,CAAa,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE;YACzE,IAAI,CAAC;gBACJ,IAAI,CAAC,eAAe,CAAC,KAAK,GAAG,IAAI,eAAe,EAAE,CAAC;gBACnD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,EAAE,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC7E,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,MAAM,IAAI,CAAC,qBAAqB,CAAC,UAAU,EAAE,CAAC;gBAC3E,OAAO,EAAE,CAAC;gBACV,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;gBAC1C,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,qBAAqB,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;gBACjH,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;gBACpH,IAAI,CAAC,qBAAqB,CAAC,KAAK,EAAE,CAAC;gBACnC,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;gBACzF,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,EAAE;oBAC5D,IAAI,CAAC,qBAAqB,CAAC,KAAK,EAAE,CAAC;oBACnC,IAAI,CAAC,eAAe,CAAC,KAAK,GAAG,SAAS,CAAC;oBACvC,IAAI,CAAC,iBAAiB,EAAE,CAAC;oBACzB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;gBACnB,CAAC,CAAC,CAAC,CAAC;gBACJ,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACf,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBAChB,CAAC,CAAC,KAAK,CAAC,CAAC;YACV,CAAC;QACF,CAAC,CAAC,CAAC;QACH,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC9B,CAAC;IAED,aAAa;QACZ,OAAO,IAAI,CAAC,qBAAqB,CAAC,aAAa,EAAE,CAAC;IACnD,CAAC;IAEO,kBAAkB,CAAC,KAAc,EAAE,iBAA0B;QACpE,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE,CAAC;YAC1C,IAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QACpD,CAAC;QACD,IAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC,MAAM,EAAE,iBAAiB,CAAC,CAAC;IAClE,CAAC;IAES,QAAQ,CAAC,IAA6B,EAAE,SAAkB;QACnE,IAAI,IAAI,KAAK,uBAAuB,CAAC,KAAK,IAAI,IAAI,KAAK,uBAAuB,CAAC,OAAO,EAAE,CAAC;YACxF,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC1B,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;YACjB,OAAO;QACR,CAAC;QAED,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;QAClC,IAAI,CAAC,IAAI,CAAC,6BAA6B,CAAC,KAAK,EAAE,CAAC;YAC/C,IAAI,CAAC,6BAA6B,CAAC,KAAK,GAAG,IAAI,uBAAuB,EAAE,CAAC;QAC1E,CAAC;QACD,MAAM,KAAK,GAAG,IAAI,CAAC,6BAA6B,CAAC,KAAK,CAAC,KAAK,CAAC;QAE7D,IAAI,IAAI,KAAK,uBAAuB,CAAC,KAAK,EAAE,CAAC;YAC5C,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC/B,CAAC;aAEI,IAAI,IAAI,KAAK,uBAAuB,CAAC,OAAO,EAAE,CAAC;YACnD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC,CAAC;QAC7G,CAAC;aAEI,CAAC;YACL,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;QAClD,CAAC;IACF,CAAC;IAEO,YAAY,CAAC,KAAiB;QACrC,KAAK,CAAC,UAAU,CAAC,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC,CAAC;QACpE,IAAI,CAAC,qBAAqB,GAAG,KAAK,CAAC;IACpC,CAAC;IAEO,aAAa,CAAC,KAAiB,EAAE,SAAkB,EAAE,KAAwB;QACpF,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE;YACvC,qCAAqC;YACrC,IAAI,KAAK,CAAC,uBAAuB,EAAE,CAAC;gBACnC,OAAO;YACR,CAAC;YAED,gCAAgC;YAChC,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;gBACzB,IAAI,CAAC;oBAAC,MAAM,IAAI,CAAC,cAAc,CAAC;gBAAC,CAAC;gBAAC,OAAO,CAAC,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC;gBAC7D,qCAAqC;gBACrC,IAAI,KAAK,CAAC,uBAAuB,EAAE,CAAC;oBACnC,OAAO;gBACR,CAAC;YACF,CAAC;YAED,2BAA2B;YAC3B,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,MAAM,IAAI,CAAC,qBAAqB,CAAC,UAAU,EAAE,CAAC;YAC3E,qCAAqC;YACrC,IAAI,KAAK,CAAC,uBAAuB,EAAE,CAAC;gBACnC,OAAO;YACR,CAAC;YAED,oBAAoB;YACpB,OAAO,EAAE,CAAC;YACV,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YACrC,IAAI,CAAC,qBAAqB,GAAG,KAAK,CAAC;QACpC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;YAC3C,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE,CAAC;gBACjC,MAAM,KAAK,CAAC;YACb,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAEO,eAAe,CAAC,KAAiB,EAAE,OAAe;QACzD,MAAM,QAAQ,GAAG,KAAK,CAAC,YAAY,EAAE,CAAC;QACtC,MAAM,iBAAiB,GAAG,KAAK,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAC3D,KAAK,CAAC,UAAU,CAAC,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,QAAQ,CAAC,QAAQ,EAAE,iBAAiB,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;IAC9F,CAAC;IAEO,KAAK,CAAC,cAAc,CAAC,KAAiB,EAAE,KAAwB;QACvE,4BAA4B;QAC5B,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,MAAM,IAAI,CAAC,qBAAqB,CAAC,UAAU,EAAE,CAAC;QAC3E,qCAAqC;QACrC,IAAI,KAAK,CAAC,uBAAuB,EAAE,CAAC;YACnC,OAAO;QACR,CAAC;QAED,mBAAmB;QACnB,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC;QACpE,qCAAqC;QACrC,IAAI,KAAK,CAAC,uBAAuB,EAAE,CAAC;YACnC,OAAO;QACR,CAAC;QAED,OAAO,EAAE,CAAC;QACV,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC;YAClB,iBAAiB;YACjB,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QACzB,CAAC;QACD,IAAI,CAAC,qBAAqB,GAAG,KAAK,CAAC;IACpC,CAAC;IAEO,KAAK,CAAC,eAAe,CAAC,KAAiB,EAAE,gBAAwB;QACxE,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACvB,OAAO,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC;QAC1D,CAAC;QACD,IAAI,gBAAgB,KAAK,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC;YAC3C,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,uBAAuB,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,gBAAgB,CAAC,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,CAAC,iBAAiB,EAAE,EAAE,CAAC,CAAC,CAAC;YAC3J,IAAI,KAAK,EAAE,MAAM,EAAE,CAAC;gBACnB,OAAO,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACpF,CAAC;QACF,CAAC;QACD,OAAO,EAAE,CAAC;IACX,CAAC;IAES,iBAAiB;QAC1B,IAAI,CAAC,6BAA6B,CAAC,KAAK,EAAE,MAAM,EAAE,CAAC;QACnD,IAAI,CAAC,6BAA6B,CAAC,KAAK,GAAG,SAAS,CAAC;QACrD,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;QAC9B,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC;QAChC,IAAI,CAAC,qBAAqB,GAAG,KAAK,CAAC;IACpC,CAAC;IAES,SAAS;QAClB,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;IACrB,CAAC;IAEQ,OAAO;QACf,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;QACvB,KAAK,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;IAED,MAAM,CAAC,OAAe,IAAU,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;IACnE,OAAO,CAAC,OAAe,IAAU,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;CAKpE,CAAA;AAlMqB,8BAA8B;IAoBjD,WAAA,aAAa,CAAA;IACb,WAAA,oBAAoB,CAAA;GArBD,8BAA8B,CAkMnD;;AAEM,IAAM,sBAAsB,GAA5B,MAAM,sBAAuB,SAAQ,8BAA8B;IAIzE,YACC,QAAa,EACb,QAA4B,EACnB,MAA4B,EACvB,WAAyB,EACxB,YAA2B,EACnB,oBAA2C,EACrD,UAAuB,EACd,mBAAyC;QAE/D,MAAM,UAAU,GAAG,IAAI,mBAAmB,CAAC,MAAM,EAAE,WAAW,EAAE,oBAAoB,EAAE,UAAU,CAAC,CAAC;QAClG,KAAK,CAAC,QAAQ,EAAE,QAAQ,EAAE,UAAU,EAAE,YAAY,EAAE,mBAAmB,CAAC,CAAC;QARhE,WAAM,GAAN,MAAM,CAAsB;QASrC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;IAC9C,CAAC;IAEQ,KAAK;QACb,IAAI,CAAC,MAAM,CAAC,uBAAuB,CAAC,KAAK,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;IAC7D,CAAC;IAEQ,MAAM,CAAC,IAA6B,EAAE,IAAwB,EAAE,SAAkB;QAC1F,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QAC3F,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE;YAC1B,IAAI,IAAI,KAAK,uBAAuB,CAAC,KAAK,IAAI,IAAI,KAAK,uBAAuB,CAAC,OAAO,EAAE,CAAC;gBACxF,IAAI,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;oBACpB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBAC7B,CAAC;qBAAM,CAAC;oBACP,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,CAAC;gBAC9B,CAAC;YACF,CAAC;YACD,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;IACJ,CAAC;IAEQ,oBAAoB,CAAC,KAA6B,IAAU,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;CACxG,CAAA;AAtCY,sBAAsB;IAQhC,WAAA,YAAY,CAAA;IACZ,WAAA,aAAa,CAAA;IACb,WAAA,qBAAqB,CAAA;IACrB,WAAA,WAAW,CAAA;IACX,WAAA,oBAAoB,CAAA;GAZV,sBAAsB,CAsClC;;AAEM,IAAM,2BAA2B,GAAjC,MAAM,2BAA4B,SAAQ,8BAA8B;IAI9E,YACC,QAAa,EACb,QAA4B,EACnB,MAA8B,EACzB,WAAyB,EACxB,YAA2B,EAC7B,UAAuB,EACd,mBAAyC,EACxC,oBAA2C;QAElE,MAAM,eAAe,GAAG,IAAI,wBAAwB,CAAC,MAAM,EAAE,oBAAoB,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;QAC5G,KAAK,CAAC,QAAQ,EAAE,QAAQ,EAAE,eAAe,EAAE,YAAY,EAAE,mBAAmB,CAAC,CAAC;QARrE,WAAM,GAAN,MAAM,CAAwB;QASvC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;IACxD,CAAC;IAEQ,oBAAoB,CAAC,KAA6B;QAC1D,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC;QAC/B,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QACxC,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;QAC7B,IAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACrD,IAAI,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC;YACtB,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;QAC9B,CAAC;IACF,CAAC;IAEQ,KAAK;QACb,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QAC3F,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE;YAC1B,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,CAAC;YAClC,IAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QACpD,CAAC,CAAC,CAAC;IACJ,CAAC;IAEQ,MAAM,CAAC,IAA6B,EAAE,IAAwB,EAAE,SAAkB,IAAU,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;CACxI,CAAA;AAtCY,2BAA2B;IAQrC,WAAA,YAAY,CAAA;IACZ,WAAA,aAAa,CAAA;IACb,WAAA,WAAW,CAAA;IACX,WAAA,oBAAoB,CAAA;IACpB,WAAA,qBAAqB,CAAA;GAZX,2BAA2B,CAsCvC;;AAED,IAAM,yBAAyB,GAA/B,MAAM,yBAA0B,SAAQ,sBAAsB;IAK7D,YACC,EAAU,EACV,QAAa,EACb,QAA4B,EAC5B,IAAS,EACK,WAAyB,EACxB,YAA2B,EAC1B,aAA6B,EACtB,oBAA2C,EACrD,UAAuB,EACd,mBAAyC;QAE/D,KAAK,CAAC,QAAQ,EAAE,QAAQ,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,WAAW,EAAE,YAAY,EAAE,oBAAoB,EAAE,UAAU,EAAE,mBAAmB,CAAC,CAAC;QAE1I,2CAA2C;QAC3C,IAAI,CAAC,MAAM,GAAG,aAAa,CAAC,YAAY,CAAC,IAAI,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE,WAAW,EAAE,IAAI,EAAE,kBAAkB,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;QAClI,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;IAClB,CAAC;IAEQ,MAAM,CAAC,OAAe;QAC9B,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QACpB,IAAI,CAAC,MAAM,CAAC,uBAAuB,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;IAC1E,CAAC;IAEQ,OAAO,CAAC,OAAe;QAC/B,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC;QAC1B,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QACpB,IAAI,CAAC,MAAM,CAAC,uBAAuB,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IAC1D,CAAC;IAEO,KAAK,CAAC,OAAe;QAC5B,IAAI,CAAC,OAAO,IAAI,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,UAAU,CAAC;QACxD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC1B,IAAI,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC;YACtB,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;QACrB,CAAC;IACF,CAAC;CAED,CAAA;AA3CK,yBAAyB;IAU5B,WAAA,YAAY,CAAA;IACZ,WAAA,aAAa,CAAA;IACb,WAAA,cAAc,CAAA;IACd,WAAA,qBAAqB,CAAA;IACrB,WAAA,WAAW,CAAA;IACX,WAAA,oBAAoB,CAAA;GAfjB,yBAAyB,CA2C9B;AAEM,IAAM,2BAA2B,GAAjC,MAAM,2BAA4B,SAAQ,UAAU;IAQ1D,YACC,EAAU,EACV,QAAa,EACb,QAA4B,EAC5B,SAAc,EACd,wBAAuC,EAChB,oBAA4D,EACrE,WAA0C;QAExD,KAAK,EAAE,CAAC;QAHgC,yBAAoB,GAApB,oBAAoB,CAAuB;QACpD,gBAAW,GAAX,WAAW,CAAc;QAbxC,eAAU,GAAkB,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QACxE,cAAS,GAAgB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;QAevD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,wBAAwB,CAAC,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE,wBAAwB,CAAC,CAAC;QACrH,MAAM,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAC,SAAS,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,kBAAkB,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC;QAC5F,IAAI,CAAC,MAAM,GAAG,EAAE,QAAQ,EAAE,CAAC;IAC5B,CAAC;IAEO,KAAK,CAAC,wBAAwB,CAAC,EAAU,EAAE,QAAa,EAAE,QAA4B,EAAE,SAAc,EAAE,gBAA+B;QAC9I,MAAM,gBAAgB,CAAC;QACvB,MAAM,IAAI,GAAG,SAAS,CAAC,QAAQ,CAAC,SAAS,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,kBAAkB,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC;QACxF,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACxC,MAAM,kBAAkB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,yBAAyB,EAAE,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;QAC7I,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QAC3E,OAAO,kBAAkB,CAAC;IAC3B,CAAC;IAED,aAAa;QACZ,OAAO,EAAE,CAAC;IACX,CAAC;IAED,MAAM,CAAC,MAAc;QACpB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,kBAAkB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IACvF,CAAC;IAED,MAAM,CAAC,IAA6B,EAAE,IAAwB,EAAE,SAAkB;QACjF,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC;IACtG,CAAC;IAED,SAAS;QACR,OAAO,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,kBAAkB,CAAC,SAAS,EAAE,CAAC,CAAC;IAC3F,CAAC;IAED,KAAK;QACJ,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC,CAAC;IAChF,CAAC;IAED,OAAO,CAAC,KAAa;QACpB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,kBAAkB,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;IACvF,CAAC;IAED,oBAAoB,CAAC,KAA6B;QACjD,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,kBAAkB,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC;IACpG,CAAC;CACD,CAAA;AA3DY,2BAA2B;IAcrC,WAAA,qBAAqB,CAAA;IACrB,WAAA,YAAY,CAAA;GAfF,2BAA2B,CA2DvC","file":"outputChannelModel.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport * as resources from '../../../../base/common/resources.js';\nimport { ITextModel } from '../../../../editor/common/model.js';\nimport { IEditorWorkerService } from '../../../../editor/common/services/editorWorker.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Promises, ThrottledDelayer } from '../../../../base/common/async.js';\nimport { FileOperationResult, IFileService, toFileOperationResult } from '../../../../platform/files/common/files.js';\nimport { IModelService } from '../../../../editor/common/services/model.js';\nimport { ILanguageSelection } from '../../../../editor/common/languages/language.js';\nimport { Disposable, toDisposable, IDisposable, MutableDisposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { isNumber } from '../../../../base/common/types.js';\nimport { EditOperation, ISingleEditOperation } from '../../../../editor/common/core/editOperation.js';\nimport { Position } from '../../../../editor/common/core/position.js';\nimport { Range } from '../../../../editor/common/core/range.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { ILogger, ILoggerService, ILogService, LogLevel } from '../../../../platform/log/common/log.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { ILogEntry, IOutputContentSource, LOG_MIME, OutputChannelUpdateMode } from '../../../services/output/common/output.js';\nimport { isCancellationError } from '../../../../base/common/errors.js';\nimport { TextModel } from '../../../../editor/common/model/textModel.js';\nimport { binarySearch, sortedDiff } from '../../../../base/common/arrays.js';\n\nconst LOG_ENTRY_REGEX = /^(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\s(\\[(info|trace|debug|error|warning)\\])\\s(\\[(.*?)\\])?/;\n\nexport function parseLogEntryAt(model: ITextModel, lineNumber: number): ILogEntry | null {\n\tconst lineContent = model.getLineContent(lineNumber);\n\tconst match = LOG_ENTRY_REGEX.exec(lineContent);\n\tif (match) {\n\t\tconst timestamp = new Date(match[1]).getTime();\n\t\tconst timestampRange = new Range(lineNumber, 1, lineNumber, match[1].length);\n\t\tconst logLevel = parseLogLevel(match[3]);\n\t\tconst logLevelRange = new Range(lineNumber, timestampRange.endColumn + 1, lineNumber, timestampRange.endColumn + 1 + match[2].length);\n\t\tconst category = match[5];\n\t\tconst startLine = lineNumber;\n\t\tlet endLine = lineNumber;\n\n\t\tconst lineCount = model.getLineCount();\n\t\twhile (endLine < lineCount) {\n\t\t\tconst nextLineContent = model.getLineContent(endLine + 1);\n\t\t\tconst isLastLine = endLine + 1 === lineCount && nextLineContent === ''; // Last line will be always empty\n\t\t\tif (LOG_ENTRY_REGEX.test(nextLineContent) || isLastLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tendLine++;\n\t\t}\n\t\tconst range = new Range(startLine, 1, endLine, model.getLineMaxColumn(endLine));\n\t\treturn { range, timestamp, timestampRange, logLevel, logLevelRange, category };\n\t}\n\treturn null;\n}\n\nfunction* logEntryIterator<T>(model: ITextModel, process: (logEntry: ILogEntry) => T): IterableIterator<T> {\n\tfor (let lineNumber = 1; lineNumber <= model.getLineCount(); lineNumber++) {\n\t\tconst logEntry = parseLogEntryAt(model, lineNumber);\n\t\tif (logEntry) {\n\t\t\tyield process(logEntry);\n\t\t\tlineNumber = logEntry.range.endLineNumber;\n\t\t}\n\t}\n}\n\nfunction changeStartLineNumber(logEntry: ILogEntry, lineNumber: number): ILogEntry {\n\treturn {\n\t\t...logEntry,\n\t\trange: new Range(lineNumber, logEntry.range.startColumn, lineNumber + logEntry.range.endLineNumber - logEntry.range.startLineNumber, logEntry.range.endColumn),\n\t\ttimestampRange: new Range(lineNumber, logEntry.timestampRange.startColumn, lineNumber, logEntry.timestampRange.endColumn),\n\t\tlogLevelRange: new Range(lineNumber, logEntry.logLevelRange.startColumn, lineNumber, logEntry.logLevelRange.endColumn),\n\t};\n}\n\nfunction parseLogLevel(level: string): LogLevel {\n\tswitch (level.toLowerCase()) {\n\t\tcase 'trace':\n\t\t\treturn LogLevel.Trace;\n\t\tcase 'debug':\n\t\t\treturn LogLevel.Debug;\n\t\tcase 'info':\n\t\t\treturn LogLevel.Info;\n\t\tcase 'warning':\n\t\t\treturn LogLevel.Warning;\n\t\tcase 'error':\n\t\t\treturn LogLevel.Error;\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown log level: ${level}`);\n\t}\n}\n\nexport interface IOutputChannelModel extends IDisposable {\n\treadonly onDispose: Event<void>;\n\treadonly source: IOutputContentSource | ReadonlyArray<IOutputContentSource>;\n\tgetLogEntries(): ReadonlyArray<ILogEntry>;\n\tappend(output: string): void;\n\tupdate(mode: OutputChannelUpdateMode, till: number | undefined, immediate: boolean): void;\n\tupdateChannelSources(sources: ReadonlyArray<IOutputContentSource>): void;\n\tloadModel(): Promise<ITextModel>;\n\tclear(): void;\n\treplace(value: string): void;\n}\n\ninterface IContentProvider {\n\treadonly onDidAppend: Event<void>;\n\treadonly onDidReset: Event<void>;\n\treset(): void;\n\twatch(): void;\n\tunwatch(): void;\n\tgetContent(): Promise<{ readonly content: string; readonly consume: () => void }>;\n\tgetLogEntries(): ReadonlyArray<ILogEntry>;\n}\n\nclass FileContentProvider extends Disposable implements IContentProvider {\n\n\tprivate readonly _onDidAppend = new Emitter<void>();\n\tget onDidAppend() { return this._onDidAppend.event; }\n\n\tprivate readonly _onDidReset = new Emitter<void>();\n\tget onDidReset() { return this._onDidReset.event; }\n\n\tprivate watching: boolean = false;\n\tprivate syncDelayer: ThrottledDelayer<void>;\n\tprivate etag: string | undefined = '';\n\n\tprivate logEntries: ILogEntry[] = [];\n\tprivate startOffset: number = 0;\n\tprivate endOffset: number = 0;\n\n\treadonly resource: URI;\n\treadonly name: string;\n\n\tconstructor(\n\t\t{ name, resource }: IOutputContentSource,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper();\n\n\t\tthis.name = name ?? '';\n\t\tthis.resource = resource;\n\t\tthis.syncDelayer = new ThrottledDelayer<void>(500);\n\t\tthis._register(toDisposable(() => this.unwatch()));\n\t}\n\n\treset(offset?: number): void {\n\t\tthis.endOffset = this.startOffset = offset ?? this.startOffset;\n\t\tthis.logEntries = [];\n\t}\n\n\tresetToEnd(): void {\n\t\tthis.startOffset = this.endOffset;\n\t\tthis.logEntries = [];\n\t}\n\n\twatch(): void {\n\t\tif (!this.watching) {\n\t\t\tthis.logService.trace('Started polling', this.resource.toString());\n\t\t\tthis.poll();\n\t\t\tthis.watching = true;\n\t\t}\n\t}\n\n\tunwatch(): void {\n\t\tif (this.watching) {\n\t\t\tthis.syncDelayer.cancel();\n\t\t\tthis.watching = false;\n\t\t\tthis.logService.trace('Stopped polling', this.resource.toString());\n\t\t}\n\t}\n\n\tprivate poll(): void {\n\t\tconst loop = () => this.doWatch().then(() => this.poll());\n\t\tthis.syncDelayer.trigger(loop).catch(error => {\n\t\t\tif (!isCancellationError(error)) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async doWatch(): Promise<void> {\n\t\ttry {\n\t\t\tif (!this.fileService.hasProvider(this.resource)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst stat = await this.fileService.stat(this.resource);\n\t\t\tif (stat.etag !== this.etag) {\n\t\t\t\tthis.etag = stat.etag;\n\t\t\t\tif (isNumber(stat.size) && this.endOffset > stat.size) {\n\t\t\t\t\tthis.reset(0);\n\t\t\t\t\tthis._onDidReset.fire();\n\t\t\t\t} else {\n\t\t\t\t\tthis._onDidAppend.fire();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (toFileOperationResult(error) !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetLogEntries(): ReadonlyArray<ILogEntry> {\n\t\treturn this.logEntries;\n\t}\n\n\tasync getContent(donotConsumeLogEntries?: boolean): Promise<{ readonly name: string; readonly content: string; readonly consume: () => void }> {\n\t\ttry {\n\t\t\tif (!this.fileService.hasProvider(this.resource)) {\n\t\t\t\treturn {\n\t\t\t\t\tname: this.name,\n\t\t\t\t\tcontent: '',\n\t\t\t\t\tconsume: () => { /* No Op */ }\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst fileContent = await this.fileService.readFile(this.resource, { position: this.endOffset });\n\t\t\tconst content = fileContent.value.toString();\n\t\t\tconst logEntries = donotConsumeLogEntries ? [] : this.parseLogEntries(content, this.logEntries[this.logEntries.length - 1]);\n\t\t\tlet consumed = false;\n\t\t\treturn {\n\t\t\t\tname: this.name,\n\t\t\t\tcontent,\n\t\t\t\tconsume: () => {\n\t\t\t\t\tif (!consumed) {\n\t\t\t\t\t\tconsumed = true;\n\t\t\t\t\t\tthis.endOffset += fileContent.value.byteLength;\n\t\t\t\t\t\tthis.etag = fileContent.etag;\n\t\t\t\t\t\tthis.logEntries.push(...logEntries);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (toFileOperationResult(error) !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tname: this.name,\n\t\t\t\tcontent: '',\n\t\t\t\tconsume: () => { /* No Op */ }\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate parseLogEntries(content: string, lastLogEntry: ILogEntry | undefined): ILogEntry[] {\n\t\tconst model = this.instantiationService.createInstance(TextModel, content, LOG_MIME, TextModel.DEFAULT_CREATION_OPTIONS, null);\n\t\ttry {\n\t\t\tif (!parseLogEntryAt(model, 1)) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tconst logEntries: ILogEntry[] = [];\n\t\t\tlet logEntryStartLineNumber = lastLogEntry ? lastLogEntry.range.endLineNumber + 1 : 1;\n\t\t\tfor (const entry of logEntryIterator(model, (e) => changeStartLineNumber(e, logEntryStartLineNumber))) {\n\t\t\t\tlogEntries.push(entry);\n\t\t\t\tlogEntryStartLineNumber = entry.range.endLineNumber + 1;\n\t\t\t}\n\t\t\treturn logEntries;\n\t\t} finally {\n\t\t\tmodel.dispose();\n\t\t}\n\t}\n}\n\nclass MultiFileContentProvider extends Disposable implements IContentProvider {\n\n\tprivate readonly _onDidAppend = this._register(new Emitter<void>());\n\treadonly onDidAppend = this._onDidAppend.event;\n\treadonly onDidReset = Event.None;\n\n\tprivate logEntries: ILogEntry[] = [];\n\tprivate readonly fileContentProviderItems: [FileContentProvider, DisposableStore][] = [];\n\n\tprivate watching: boolean = false;\n\n\tconstructor(\n\t\tfilesInfos: IOutputContentSource[],\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper();\n\t\tfor (const file of filesInfos) {\n\t\t\tthis.fileContentProviderItems.push(this.createFileContentProvider(file));\n\t\t}\n\t\tthis._register(toDisposable(() => {\n\t\t\tfor (const [, disposables] of this.fileContentProviderItems) {\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate createFileContentProvider(file: IOutputContentSource): [FileContentProvider, DisposableStore] {\n\t\tconst disposables = new DisposableStore();\n\t\tconst fileOutput = disposables.add(new FileContentProvider(file, this.fileService, this.instantiationService, this.logService));\n\t\tdisposables.add(fileOutput.onDidAppend(() => this._onDidAppend.fire()));\n\t\treturn [fileOutput, disposables];\n\t}\n\n\twatch(): void {\n\t\tif (!this.watching) {\n\t\t\tthis.watching = true;\n\t\t\tfor (const [output] of this.fileContentProviderItems) {\n\t\t\t\toutput.watch();\n\t\t\t}\n\t\t}\n\t}\n\n\tunwatch(): void {\n\t\tif (this.watching) {\n\t\t\tthis.watching = false;\n\t\t\tfor (const [output] of this.fileContentProviderItems) {\n\t\t\t\toutput.unwatch();\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateFiles(files: IOutputContentSource[]): void {\n\t\tconst wasWatching = this.watching;\n\t\tif (wasWatching) {\n\t\t\tthis.unwatch();\n\t\t}\n\n\t\tconst result = sortedDiff(this.fileContentProviderItems.map(([output]) => output), files, (a, b) => resources.extUri.compare(a.resource, b.resource));\n\t\tfor (const { start, deleteCount, toInsert } of result) {\n\t\t\tconst outputs = toInsert.map(file => this.createFileContentProvider(file));\n\t\t\tconst outputsToRemove = this.fileContentProviderItems.splice(start, deleteCount, ...outputs);\n\t\t\tfor (const [, disposables] of outputsToRemove) {\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\t\t}\n\n\t\tif (wasWatching) {\n\t\t\tthis.watch();\n\t\t}\n\t}\n\n\treset(): void {\n\t\tfor (const [output] of this.fileContentProviderItems) {\n\t\t\toutput.reset();\n\t\t}\n\t\tthis.logEntries = [];\n\t}\n\n\tresetToEnd(): void {\n\t\tfor (const [output] of this.fileContentProviderItems) {\n\t\t\toutput.resetToEnd();\n\t\t}\n\t\tthis.logEntries = [];\n\t}\n\n\tgetLogEntries(): ReadonlyArray<ILogEntry> {\n\t\treturn this.logEntries;\n\t}\n\n\tasync getContent(): Promise<{ readonly content: string; readonly consume: () => void }> {\n\t\tconst outputs = await Promise.all(this.fileContentProviderItems.map(([output]) => output.getContent(true)));\n\t\tconst { content, logEntries } = this.combineLogEntries(outputs, this.logEntries[this.logEntries.length - 1]);\n\t\tlet consumed = false;\n\t\treturn {\n\t\t\tcontent,\n\t\t\tconsume: () => {\n\t\t\t\tif (!consumed) {\n\t\t\t\t\tconsumed = true;\n\t\t\t\t\toutputs.forEach(({ consume }) => consume());\n\t\t\t\t\tthis.logEntries.push(...logEntries);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate combineLogEntries(outputs: { content: string; name: string }[], lastEntry: ILogEntry | undefined): { logEntries: ILogEntry[]; content: string } {\n\n\t\toutputs = outputs.filter(output => !!output.content);\n\n\t\tif (outputs.length === 0) {\n\t\t\treturn { logEntries: [], content: '' };\n\t\t}\n\n\t\tconst logEntries: ILogEntry[] = [];\n\t\tconst contents: string[] = [];\n\t\tconst process = (model: ITextModel, logEntry: ILogEntry, name: string): [ILogEntry, string] => {\n\t\t\tconst lineContent = model.getValueInRange(logEntry.range);\n\t\t\tconst content = name ? `${lineContent.substring(0, logEntry.logLevelRange.endColumn)} [${name}]${lineContent.substring(logEntry.logLevelRange.endColumn)}` : lineContent;\n\t\t\treturn [{\n\t\t\t\t...logEntry,\n\t\t\t\tcategory: name,\n\t\t\t\trange: new Range(logEntry.range.startLineNumber, logEntry.logLevelRange.startColumn, logEntry.range.endLineNumber, name ? logEntry.range.endColumn + name.length + 3 : logEntry.range.endColumn),\n\t\t\t}, content];\n\t\t};\n\n\t\tconst model = this.instantiationService.createInstance(TextModel, outputs[0].content, LOG_MIME, TextModel.DEFAULT_CREATION_OPTIONS, null);\n\t\ttry {\n\t\t\tfor (const [logEntry, content] of logEntryIterator(model, (e) => process(model, e, outputs[0].name))) {\n\t\t\t\tlogEntries.push(logEntry);\n\t\t\t\tcontents.push(content);\n\t\t\t}\n\t\t} finally {\n\t\t\tmodel.dispose();\n\t\t}\n\n\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\tconst { content, name } = outputs[index];\n\t\t\tconst model = this.instantiationService.createInstance(TextModel, content, LOG_MIME, TextModel.DEFAULT_CREATION_OPTIONS, null);\n\t\t\ttry {\n\t\t\t\tconst iterator = logEntryIterator(model, (e) => process(model, e, name));\n\t\t\t\tlet next = iterator.next();\n\t\t\t\twhile (!next.done) {\n\t\t\t\t\tconst [logEntry, content] = next.value;\n\t\t\t\t\tconst logEntriesToAdd = [logEntry];\n\t\t\t\t\tconst contentsToAdd = [content];\n\n\t\t\t\t\tlet insertionIndex;\n\n\t\t\t\t\t// If the timestamp is greater than or equal to the last timestamp,\n\t\t\t\t\t// we can just append all the entries at the end\n\t\t\t\t\tif (logEntry.timestamp >= logEntries[logEntries.length - 1].timestamp) {\n\t\t\t\t\t\tinsertionIndex = logEntries.length;\n\t\t\t\t\t\tfor (next = iterator.next(); !next.done; next = iterator.next()) {\n\t\t\t\t\t\t\tlogEntriesToAdd.push(next.value[0]);\n\t\t\t\t\t\t\tcontentsToAdd.push(next.value[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (logEntry.timestamp <= logEntries[0].timestamp) {\n\t\t\t\t\t\t\t// If the timestamp is less than or equal to the first timestamp\n\t\t\t\t\t\t\t// then insert at the beginning\n\t\t\t\t\t\t\tinsertionIndex = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise, find the insertion index\n\t\t\t\t\t\t\tconst idx = binarySearch(logEntries, logEntry, (a, b) => a.timestamp - b.timestamp);\n\t\t\t\t\t\t\tinsertionIndex = idx < 0 ? ~idx : idx;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Collect all entries that have a timestamp less than or equal to the timestamp at the insertion index\n\t\t\t\t\t\tfor (next = iterator.next(); !next.done && next.value[0].timestamp <= logEntries[insertionIndex].timestamp; next = iterator.next()) {\n\t\t\t\t\t\t\tlogEntriesToAdd.push(next.value[0]);\n\t\t\t\t\t\t\tcontentsToAdd.push(next.value[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcontents.splice(insertionIndex, 0, ...contentsToAdd);\n\t\t\t\t\tlogEntries.splice(insertionIndex, 0, ...logEntriesToAdd);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tmodel.dispose();\n\t\t\t}\n\t\t}\n\n\t\tlet content = '';\n\t\tconst updatedLogEntries: ILogEntry[] = [];\n\t\tlet logEntryStartLineNumber = lastEntry ? lastEntry.range.endLineNumber + 1 : 1;\n\t\tfor (let i = 0; i < logEntries.length; i++) {\n\t\t\tcontent += contents[i] + '\\n';\n\t\t\tconst updatedLogEntry = changeStartLineNumber(logEntries[i], logEntryStartLineNumber);\n\t\t\tupdatedLogEntries.push(updatedLogEntry);\n\t\t\tlogEntryStartLineNumber = updatedLogEntry.range.endLineNumber + 1;\n\t\t}\n\n\t\treturn { logEntries: updatedLogEntries, content };\n\t}\n\n}\n\nexport abstract class AbstractFileOutputChannelModel extends Disposable implements IOutputChannelModel {\n\n\tprivate readonly _onDispose = this._register(new Emitter<void>());\n\treadonly onDispose: Event<void> = this._onDispose.event;\n\n\tprotected loadModelPromise: Promise<ITextModel> | null = null;\n\n\tprivate readonly modelDisposable = this._register(new MutableDisposable<DisposableStore>());\n\tprotected model: ITextModel | null = null;\n\tprivate modelUpdateInProgress: boolean = false;\n\tprivate readonly modelUpdateCancellationSource = this._register(new MutableDisposable<CancellationTokenSource>());\n\tprivate readonly appendThrottler = this._register(new ThrottledDelayer(300));\n\tprivate replacePromise: Promise<void> | undefined;\n\n\tabstract readonly source: IOutputContentSource | ReadonlyArray<IOutputContentSource>;\n\n\tconstructor(\n\t\tprivate readonly modelUri: URI,\n\t\tprivate readonly language: ILanguageSelection,\n\t\tprivate readonly outputContentProvider: IContentProvider,\n\t\t@IModelService protected readonly modelService: IModelService,\n\t\t@IEditorWorkerService private readonly editorWorkerService: IEditorWorkerService,\n\t) {\n\t\tsuper();\n\t}\n\n\tasync loadModel(): Promise<ITextModel> {\n\t\tthis.loadModelPromise = Promises.withAsyncBody<ITextModel>(async (c, e) => {\n\t\t\ttry {\n\t\t\t\tthis.modelDisposable.value = new DisposableStore();\n\t\t\t\tthis.model = this.modelService.createModel('', this.language, this.modelUri);\n\t\t\t\tconst { content, consume } = await this.outputContentProvider.getContent();\n\t\t\t\tconsume();\n\t\t\t\tthis.doAppendContent(this.model, content);\n\t\t\t\tthis.modelDisposable.value.add(this.outputContentProvider.onDidReset(() => this.onDidContentChange(true, true)));\n\t\t\t\tthis.modelDisposable.value.add(this.outputContentProvider.onDidAppend(() => this.onDidContentChange(false, false)));\n\t\t\t\tthis.outputContentProvider.watch();\n\t\t\t\tthis.modelDisposable.value.add(toDisposable(() => this.outputContentProvider.unwatch()));\n\t\t\t\tthis.modelDisposable.value.add(this.model.onWillDispose(() => {\n\t\t\t\t\tthis.outputContentProvider.reset();\n\t\t\t\t\tthis.modelDisposable.value = undefined;\n\t\t\t\t\tthis.cancelModelUpdate();\n\t\t\t\t\tthis.model = null;\n\t\t\t\t}));\n\t\t\t\tc(this.model);\n\t\t\t} catch (error) {\n\t\t\t\te(error);\n\t\t\t}\n\t\t});\n\t\treturn this.loadModelPromise;\n\t}\n\n\tgetLogEntries(): readonly ILogEntry[] {\n\t\treturn this.outputContentProvider.getLogEntries();\n\t}\n\n\tprivate onDidContentChange(reset: boolean, appendImmediately: boolean): void {\n\t\tif (reset && !this.modelUpdateInProgress) {\n\t\t\tthis.doUpdate(OutputChannelUpdateMode.Clear, true);\n\t\t}\n\t\tthis.doUpdate(OutputChannelUpdateMode.Append, appendImmediately);\n\t}\n\n\tprotected doUpdate(mode: OutputChannelUpdateMode, immediate: boolean): void {\n\t\tif (mode === OutputChannelUpdateMode.Clear || mode === OutputChannelUpdateMode.Replace) {\n\t\t\tthis.cancelModelUpdate();\n\t\t}\n\t\tif (!this.model) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.modelUpdateInProgress = true;\n\t\tif (!this.modelUpdateCancellationSource.value) {\n\t\t\tthis.modelUpdateCancellationSource.value = new CancellationTokenSource();\n\t\t}\n\t\tconst token = this.modelUpdateCancellationSource.value.token;\n\n\t\tif (mode === OutputChannelUpdateMode.Clear) {\n\t\t\tthis.clearContent(this.model);\n\t\t}\n\n\t\telse if (mode === OutputChannelUpdateMode.Replace) {\n\t\t\tthis.replacePromise = this.replaceContent(this.model, token).finally(() => this.replacePromise = undefined);\n\t\t}\n\n\t\telse {\n\t\t\tthis.appendContent(this.model, immediate, token);\n\t\t}\n\t}\n\n\tprivate clearContent(model: ITextModel): void {\n\t\tmodel.applyEdits([EditOperation.delete(model.getFullModelRange())]);\n\t\tthis.modelUpdateInProgress = false;\n\t}\n\n\tprivate appendContent(model: ITextModel, immediate: boolean, token: CancellationToken): void {\n\t\tthis.appendThrottler.trigger(async () => {\n\t\t\t/* Abort if operation is cancelled */\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Wait for replace to finish */\n\t\t\tif (this.replacePromise) {\n\t\t\t\ttry { await this.replacePromise; } catch (e) { /* Ignore */ }\n\t\t\t\t/* Abort if operation is cancelled */\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Get content to append */\n\t\t\tconst { content, consume } = await this.outputContentProvider.getContent();\n\t\t\t/* Abort if operation is cancelled */\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Appned Content */\n\t\t\tconsume();\n\t\t\tthis.doAppendContent(model, content);\n\t\t\tthis.modelUpdateInProgress = false;\n\t\t}, immediate ? 0 : undefined).catch(error => {\n\t\t\tif (!isCancellationError(error)) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate doAppendContent(model: ITextModel, content: string): void {\n\t\tconst lastLine = model.getLineCount();\n\t\tconst lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n\t\tmodel.applyEdits([EditOperation.insert(new Position(lastLine, lastLineMaxColumn), content)]);\n\t}\n\n\tprivate async replaceContent(model: ITextModel, token: CancellationToken): Promise<void> {\n\t\t/* Get content to replace */\n\t\tconst { content, consume } = await this.outputContentProvider.getContent();\n\t\t/* Abort if operation is cancelled */\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* Compute Edits */\n\t\tconst edits = await this.getReplaceEdits(model, content.toString());\n\t\t/* Abort if operation is cancelled */\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsume();\n\t\tif (edits.length) {\n\t\t\t/* Apply Edits */\n\t\t\tmodel.applyEdits(edits);\n\t\t}\n\t\tthis.modelUpdateInProgress = false;\n\t}\n\n\tprivate async getReplaceEdits(model: ITextModel, contentToReplace: string): Promise<ISingleEditOperation[]> {\n\t\tif (!contentToReplace) {\n\t\t\treturn [EditOperation.delete(model.getFullModelRange())];\n\t\t}\n\t\tif (contentToReplace !== model.getValue()) {\n\t\t\tconst edits = await this.editorWorkerService.computeMoreMinimalEdits(model.uri, [{ text: contentToReplace.toString(), range: model.getFullModelRange() }]);\n\t\t\tif (edits?.length) {\n\t\t\t\treturn edits.map(edit => EditOperation.replace(Range.lift(edit.range), edit.text));\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t}\n\n\tprotected cancelModelUpdate(): void {\n\t\tthis.modelUpdateCancellationSource.value?.cancel();\n\t\tthis.modelUpdateCancellationSource.value = undefined;\n\t\tthis.appendThrottler.cancel();\n\t\tthis.replacePromise = undefined;\n\t\tthis.modelUpdateInProgress = false;\n\t}\n\n\tprotected isVisible(): boolean {\n\t\treturn !!this.model;\n\t}\n\n\toverride dispose(): void {\n\t\tthis._onDispose.fire();\n\t\tsuper.dispose();\n\t}\n\n\tappend(message: string): void { throw new Error('Not supported'); }\n\treplace(message: string): void { throw new Error('Not supported'); }\n\n\tabstract clear(): void;\n\tabstract update(mode: OutputChannelUpdateMode, till: number | undefined, immediate: boolean): void;\n\tabstract updateChannelSources(files: IOutputContentSource[]): void;\n}\n\nexport class FileOutputChannelModel extends AbstractFileOutputChannelModel implements IOutputChannelModel {\n\n\tprivate readonly fileOutput: FileContentProvider;\n\n\tconstructor(\n\t\tmodelUri: URI,\n\t\tlanguage: ILanguageSelection,\n\t\treadonly source: IOutputContentSource,\n\t\t@IFileService fileService: IFileService,\n\t\t@IModelService modelService: IModelService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@ILogService logService: ILogService,\n\t\t@IEditorWorkerService editorWorkerService: IEditorWorkerService,\n\t) {\n\t\tconst fileOutput = new FileContentProvider(source, fileService, instantiationService, logService);\n\t\tsuper(modelUri, language, fileOutput, modelService, editorWorkerService);\n\t\tthis.fileOutput = this._register(fileOutput);\n\t}\n\n\toverride clear(): void {\n\t\tthis.update(OutputChannelUpdateMode.Clear, undefined, true);\n\t}\n\n\toverride update(mode: OutputChannelUpdateMode, till: number | undefined, immediate: boolean): void {\n\t\tconst loadModelPromise = this.loadModelPromise ? this.loadModelPromise : Promise.resolve();\n\t\tloadModelPromise.then(() => {\n\t\t\tif (mode === OutputChannelUpdateMode.Clear || mode === OutputChannelUpdateMode.Replace) {\n\t\t\t\tif (isNumber(till)) {\n\t\t\t\t\tthis.fileOutput.reset(till);\n\t\t\t\t} else {\n\t\t\t\t\tthis.fileOutput.resetToEnd();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.doUpdate(mode, immediate);\n\t\t});\n\t}\n\n\toverride updateChannelSources(files: IOutputContentSource[]): void { throw new Error('Not supported'); }\n}\n\nexport class MultiFileOutputChannelModel extends AbstractFileOutputChannelModel implements IOutputChannelModel {\n\n\tprivate readonly multifileOutput: MultiFileContentProvider;\n\n\tconstructor(\n\t\tmodelUri: URI,\n\t\tlanguage: ILanguageSelection,\n\t\treadonly source: IOutputContentSource[],\n\t\t@IFileService fileService: IFileService,\n\t\t@IModelService modelService: IModelService,\n\t\t@ILogService logService: ILogService,\n\t\t@IEditorWorkerService editorWorkerService: IEditorWorkerService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t) {\n\t\tconst multifileOutput = new MultiFileContentProvider(source, instantiationService, fileService, logService);\n\t\tsuper(modelUri, language, multifileOutput, modelService, editorWorkerService);\n\t\tthis.multifileOutput = this._register(multifileOutput);\n\t}\n\n\toverride updateChannelSources(files: IOutputContentSource[]): void {\n\t\tthis.multifileOutput.unwatch();\n\t\tthis.multifileOutput.updateFiles(files);\n\t\tthis.multifileOutput.reset();\n\t\tthis.doUpdate(OutputChannelUpdateMode.Replace, true);\n\t\tif (this.isVisible()) {\n\t\t\tthis.multifileOutput.watch();\n\t\t}\n\t}\n\n\toverride clear(): void {\n\t\tconst loadModelPromise = this.loadModelPromise ? this.loadModelPromise : Promise.resolve();\n\t\tloadModelPromise.then(() => {\n\t\t\tthis.multifileOutput.resetToEnd();\n\t\t\tthis.doUpdate(OutputChannelUpdateMode.Clear, true);\n\t\t});\n\t}\n\n\toverride update(mode: OutputChannelUpdateMode, till: number | undefined, immediate: boolean): void { throw new Error('Not supported'); }\n}\n\nclass OutputChannelBackedByFile extends FileOutputChannelModel implements IOutputChannelModel {\n\n\tprivate logger: ILogger;\n\tprivate _offset: number;\n\n\tconstructor(\n\t\tid: string,\n\t\tmodelUri: URI,\n\t\tlanguage: ILanguageSelection,\n\t\tfile: URI,\n\t\t@IFileService fileService: IFileService,\n\t\t@IModelService modelService: IModelService,\n\t\t@ILoggerService loggerService: ILoggerService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@ILogService logService: ILogService,\n\t\t@IEditorWorkerService editorWorkerService: IEditorWorkerService\n\t) {\n\t\tsuper(modelUri, language, { resource: file, name: '' }, fileService, modelService, instantiationService, logService, editorWorkerService);\n\n\t\t// Donot rotate to check for the file reset\n\t\tthis.logger = loggerService.createLogger(file, { logLevel: 'always', donotRotate: true, donotUseFormatters: true, hidden: true });\n\t\tthis._offset = 0;\n\t}\n\n\toverride append(message: string): void {\n\t\tthis.write(message);\n\t\tthis.update(OutputChannelUpdateMode.Append, undefined, this.isVisible());\n\t}\n\n\toverride replace(message: string): void {\n\t\tconst till = this._offset;\n\t\tthis.write(message);\n\t\tthis.update(OutputChannelUpdateMode.Replace, till, true);\n\t}\n\n\tprivate write(content: string): void {\n\t\tthis._offset += VSBuffer.fromString(content).byteLength;\n\t\tthis.logger.info(content);\n\t\tif (this.isVisible()) {\n\t\t\tthis.logger.flush();\n\t\t}\n\t}\n\n}\n\nexport class DelegatedOutputChannelModel extends Disposable implements IOutputChannelModel {\n\n\tprivate readonly _onDispose: Emitter<void> = this._register(new Emitter<void>());\n\treadonly onDispose: Event<void> = this._onDispose.event;\n\n\tprivate readonly outputChannelModel: Promise<IOutputChannelModel>;\n\treadonly source: IOutputContentSource;\n\n\tconstructor(\n\t\tid: string,\n\t\tmodelUri: URI,\n\t\tlanguage: ILanguageSelection,\n\t\toutputDir: URI,\n\t\toutputDirCreationPromise: Promise<void>,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t) {\n\t\tsuper();\n\t\tthis.outputChannelModel = this.createOutputChannelModel(id, modelUri, language, outputDir, outputDirCreationPromise);\n\t\tconst resource = resources.joinPath(outputDir, `${id.replace(/[\\\\/:\\*\\?\"<>\\|]/g, '')}.log`);\n\t\tthis.source = { resource };\n\t}\n\n\tprivate async createOutputChannelModel(id: string, modelUri: URI, language: ILanguageSelection, outputDir: URI, outputDirPromise: Promise<void>): Promise<IOutputChannelModel> {\n\t\tawait outputDirPromise;\n\t\tconst file = resources.joinPath(outputDir, `${id.replace(/[\\\\/:\\*\\?\"<>\\|]/g, '')}.log`);\n\t\tawait this.fileService.createFile(file);\n\t\tconst outputChannelModel = this._register(this.instantiationService.createInstance(OutputChannelBackedByFile, id, modelUri, language, file));\n\t\tthis._register(outputChannelModel.onDispose(() => this._onDispose.fire()));\n\t\treturn outputChannelModel;\n\t}\n\n\tgetLogEntries(): readonly ILogEntry[] {\n\t\treturn [];\n\t}\n\n\tappend(output: string): void {\n\t\tthis.outputChannelModel.then(outputChannelModel => outputChannelModel.append(output));\n\t}\n\n\tupdate(mode: OutputChannelUpdateMode, till: number | undefined, immediate: boolean): void {\n\t\tthis.outputChannelModel.then(outputChannelModel => outputChannelModel.update(mode, till, immediate));\n\t}\n\n\tloadModel(): Promise<ITextModel> {\n\t\treturn this.outputChannelModel.then(outputChannelModel => outputChannelModel.loadModel());\n\t}\n\n\tclear(): void {\n\t\tthis.outputChannelModel.then(outputChannelModel => outputChannelModel.clear());\n\t}\n\n\treplace(value: string): void {\n\t\tthis.outputChannelModel.then(outputChannelModel => outputChannelModel.replace(value));\n\t}\n\n\tupdateChannelSources(files: IOutputContentSource[]): void {\n\t\tthis.outputChannelModel.then(outputChannelModel => outputChannelModel.updateChannelSources(files));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport * as resources from '../../../../base/common/resources.js';\nimport { ITextModel } from '../../../../editor/common/model.js';\nimport { IEditorWorkerService } from '../../../../editor/common/services/editorWorker.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Promises, ThrottledDelayer } from '../../../../base/common/async.js';\nimport { FileOperationResult, IFileService, toFileOperationResult } from '../../../../platform/files/common/files.js';\nimport { IModelService } from '../../../../editor/common/services/model.js';\nimport { ILanguageSelection } from '../../../../editor/common/languages/language.js';\nimport { Disposable, toDisposable, IDisposable, MutableDisposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { isNumber } from '../../../../base/common/types.js';\nimport { EditOperation, ISingleEditOperation } from '../../../../editor/common/core/editOperation.js';\nimport { Position } from '../../../../editor/common/core/position.js';\nimport { Range } from '../../../../editor/common/core/range.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { ILogger, ILoggerService, ILogService, LogLevel } from '../../../../platform/log/common/log.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { ILogEntry, IOutputContentSource, LOG_MIME, OutputChannelUpdateMode } from '../../../services/output/common/output.js';\nimport { isCancellationError } from '../../../../base/common/errors.js';\nimport { TextModel } from '../../../../editor/common/model/textModel.js';\nimport { binarySearch, sortedDiff } from '../../../../base/common/arrays.js';\n\nconst LOG_ENTRY_REGEX = /^(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\s(\\[(info|trace|debug|error|warning)\\])\\s(\\[(.*?)\\])?/;\n\nexport function parseLogEntryAt(model: ITextModel, lineNumber: number): ILogEntry | null {\n\tconst lineContent = model.getLineContent(lineNumber);\n\tconst match = LOG_ENTRY_REGEX.exec(lineContent);\n\tif (match) {\n\t\tconst timestamp = new Date(match[1]).getTime();\n\t\tconst timestampRange = new Range(lineNumber, 1, lineNumber, match[1].length);\n\t\tconst logLevel = parseLogLevel(match[3]);\n\t\tconst logLevelRange = new Range(lineNumber, timestampRange.endColumn + 1, lineNumber, timestampRange.endColumn + 1 + match[2].length);\n\t\tconst category = match[5];\n\t\tconst startLine = lineNumber;\n\t\tlet endLine = lineNumber;\n\n\t\tconst lineCount = model.getLineCount();\n\t\twhile (endLine < lineCount) {\n\t\t\tconst nextLineContent = model.getLineContent(endLine + 1);\n\t\t\tconst isLastLine = endLine + 1 === lineCount && nextLineContent === ''; // Last line will be always empty\n\t\t\tif (LOG_ENTRY_REGEX.test(nextLineContent) || isLastLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tendLine++;\n\t\t}\n\t\tconst range = new Range(startLine, 1, endLine, model.getLineMaxColumn(endLine));\n\t\treturn { range, timestamp, timestampRange, logLevel, logLevelRange, category };\n\t}\n\treturn null;\n}\n\nfunction* logEntryIterator<T>(model: ITextModel, process: (logEntry: ILogEntry) => T): IterableIterator<T> {\n\tfor (let lineNumber = 1; lineNumber <= model.getLineCount(); lineNumber++) {\n\t\tconst logEntry = parseLogEntryAt(model, lineNumber);\n\t\tif (logEntry) {\n\t\t\tyield process(logEntry);\n\t\t\tlineNumber = logEntry.range.endLineNumber;\n\t\t}\n\t}\n}\n\nfunction changeStartLineNumber(logEntry: ILogEntry, lineNumber: number): ILogEntry {\n\treturn {\n\t\t...logEntry,\n\t\trange: new Range(lineNumber, logEntry.range.startColumn, lineNumber + logEntry.range.endLineNumber - logEntry.range.startLineNumber, logEntry.range.endColumn),\n\t\ttimestampRange: new Range(lineNumber, logEntry.timestampRange.startColumn, lineNumber, logEntry.timestampRange.endColumn),\n\t\tlogLevelRange: new Range(lineNumber, logEntry.logLevelRange.startColumn, lineNumber, logEntry.logLevelRange.endColumn),\n\t};\n}\n\nfunction parseLogLevel(level: string): LogLevel {\n\tswitch (level.toLowerCase()) {\n\t\tcase 'trace':\n\t\t\treturn LogLevel.Trace;\n\t\tcase 'debug':\n\t\t\treturn LogLevel.Debug;\n\t\tcase 'info':\n\t\t\treturn LogLevel.Info;\n\t\tcase 'warning':\n\t\t\treturn LogLevel.Warning;\n\t\tcase 'error':\n\t\t\treturn LogLevel.Error;\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown log level: ${level}`);\n\t}\n}\n\nexport interface IOutputChannelModel extends IDisposable {\n\treadonly onDispose: Event<void>;\n\treadonly source: IOutputContentSource | ReadonlyArray<IOutputContentSource>;\n\tgetLogEntries(): ReadonlyArray<ILogEntry>;\n\tappend(output: string): void;\n\tupdate(mode: OutputChannelUpdateMode, till: number | undefined, immediate: boolean): void;\n\tupdateChannelSources(sources: ReadonlyArray<IOutputContentSource>): void;\n\tloadModel(): Promise<ITextModel>;\n\tclear(): void;\n\treplace(value: string): void;\n}\n\ninterface IContentProvider {\n\treadonly onDidAppend: Event<void>;\n\treadonly onDidReset: Event<void>;\n\treset(): void;\n\twatch(): void;\n\tunwatch(): void;\n\tgetContent(): Promise<{ readonly content: string; readonly consume: () => void }>;\n\tgetLogEntries(): ReadonlyArray<ILogEntry>;\n}\n\nclass FileContentProvider extends Disposable implements IContentProvider {\n\n\tprivate readonly _onDidAppend = new Emitter<void>();\n\tget onDidAppend() { return this._onDidAppend.event; }\n\n\tprivate readonly _onDidReset = new Emitter<void>();\n\tget onDidReset() { return this._onDidReset.event; }\n\n\tprivate watching: boolean = false;\n\tprivate syncDelayer: ThrottledDelayer<void>;\n\tprivate etag: string | undefined = '';\n\n\tprivate logEntries: ILogEntry[] = [];\n\tprivate startOffset: number = 0;\n\tprivate endOffset: number = 0;\n\n\treadonly resource: URI;\n\treadonly name: string;\n\n\tconstructor(\n\t\t{ name, resource }: IOutputContentSource,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper();\n\n\t\tthis.name = name ?? '';\n\t\tthis.resource = resource;\n\t\tthis.syncDelayer = new ThrottledDelayer<void>(500);\n\t\tthis._register(toDisposable(() => this.unwatch()));\n\t}\n\n\treset(offset?: number): void {\n\t\tthis.endOffset = this.startOffset = offset ?? this.startOffset;\n\t\tthis.logEntries = [];\n\t}\n\n\tresetToEnd(): void {\n\t\tthis.startOffset = this.endOffset;\n\t\tthis.logEntries = [];\n\t}\n\n\twatch(): void {\n\t\tif (!this.watching) {\n\t\t\tthis.logService.trace('Started polling', this.resource.toString());\n\t\t\tthis.poll();\n\t\t\tthis.watching = true;\n\t\t}\n\t}\n\n\tunwatch(): void {\n\t\tif (this.watching) {\n\t\t\tthis.syncDelayer.cancel();\n\t\t\tthis.watching = false;\n\t\t\tthis.logService.trace('Stopped polling', this.resource.toString());\n\t\t}\n\t}\n\n\tprivate poll(): void {\n\t\tconst loop = () => this.doWatch().then(() => this.poll());\n\t\tthis.syncDelayer.trigger(loop).catch(error => {\n\t\t\tif (!isCancellationError(error)) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async doWatch(): Promise<void> {\n\t\ttry {\n\t\t\tif (!this.fileService.hasProvider(this.resource)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst stat = await this.fileService.stat(this.resource);\n\t\t\tif (stat.etag !== this.etag) {\n\t\t\t\tthis.etag = stat.etag;\n\t\t\t\tif (isNumber(stat.size) && this.endOffset > stat.size) {\n\t\t\t\t\tthis.reset(0);\n\t\t\t\t\tthis._onDidReset.fire();\n\t\t\t\t} else {\n\t\t\t\t\tthis._onDidAppend.fire();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (toFileOperationResult(error) !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetLogEntries(): ReadonlyArray<ILogEntry> {\n\t\treturn this.logEntries;\n\t}\n\n\tasync getContent(donotConsumeLogEntries?: boolean): Promise<{ readonly name: string; readonly content: string; readonly consume: () => void }> {\n\t\ttry {\n\t\t\tif (!this.fileService.hasProvider(this.resource)) {\n\t\t\t\treturn {\n\t\t\t\t\tname: this.name,\n\t\t\t\t\tcontent: '',\n\t\t\t\t\tconsume: () => { /* No Op */ }\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst fileContent = await this.fileService.readFile(this.resource, { position: this.endOffset });\n\t\t\tconst content = fileContent.value.toString();\n\t\t\tconst logEntries = donotConsumeLogEntries ? [] : this.parseLogEntries(content, this.logEntries[this.logEntries.length - 1]);\n\t\t\tlet consumed = false;\n\t\t\treturn {\n\t\t\t\tname: this.name,\n\t\t\t\tcontent,\n\t\t\t\tconsume: () => {\n\t\t\t\t\tif (!consumed) {\n\t\t\t\t\t\tconsumed = true;\n\t\t\t\t\t\tthis.endOffset += fileContent.value.byteLength;\n\t\t\t\t\t\tthis.etag = fileContent.etag;\n\t\t\t\t\t\tthis.logEntries.push(...logEntries);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (toFileOperationResult(error) !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tname: this.name,\n\t\t\t\tcontent: '',\n\t\t\t\tconsume: () => { /* No Op */ }\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate parseLogEntries(content: string, lastLogEntry: ILogEntry | undefined): ILogEntry[] {\n\t\tconst model = this.instantiationService.createInstance(TextModel, content, LOG_MIME, TextModel.DEFAULT_CREATION_OPTIONS, null);\n\t\ttry {\n\t\t\tif (!parseLogEntryAt(model, 1)) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tconst logEntries: ILogEntry[] = [];\n\t\t\tlet logEntryStartLineNumber = lastLogEntry ? lastLogEntry.range.endLineNumber + 1 : 1;\n\t\t\tfor (const entry of logEntryIterator(model, (e) => changeStartLineNumber(e, logEntryStartLineNumber))) {\n\t\t\t\tlogEntries.push(entry);\n\t\t\t\tlogEntryStartLineNumber = entry.range.endLineNumber + 1;\n\t\t\t}\n\t\t\treturn logEntries;\n\t\t} finally {\n\t\t\tmodel.dispose();\n\t\t}\n\t}\n}\n\nclass MultiFileContentProvider extends Disposable implements IContentProvider {\n\n\tprivate readonly _onDidAppend = this._register(new Emitter<void>());\n\treadonly onDidAppend = this._onDidAppend.event;\n\treadonly onDidReset = Event.None;\n\n\tprivate logEntries: ILogEntry[] = [];\n\tprivate readonly fileContentProviderItems: [FileContentProvider, DisposableStore][] = [];\n\n\tprivate watching: boolean = false;\n\n\tconstructor(\n\t\tfilesInfos: IOutputContentSource[],\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper();\n\t\tfor (const file of filesInfos) {\n\t\t\tthis.fileContentProviderItems.push(this.createFileContentProvider(file));\n\t\t}\n\t\tthis._register(toDisposable(() => {\n\t\t\tfor (const [, disposables] of this.fileContentProviderItems) {\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate createFileContentProvider(file: IOutputContentSource): [FileContentProvider, DisposableStore] {\n\t\tconst disposables = new DisposableStore();\n\t\tconst fileOutput = disposables.add(new FileContentProvider(file, this.fileService, this.instantiationService, this.logService));\n\t\tdisposables.add(fileOutput.onDidAppend(() => this._onDidAppend.fire()));\n\t\treturn [fileOutput, disposables];\n\t}\n\n\twatch(): void {\n\t\tif (!this.watching) {\n\t\t\tthis.watching = true;\n\t\t\tfor (const [output] of this.fileContentProviderItems) {\n\t\t\t\toutput.watch();\n\t\t\t}\n\t\t}\n\t}\n\n\tunwatch(): void {\n\t\tif (this.watching) {\n\t\t\tthis.watching = false;\n\t\t\tfor (const [output] of this.fileContentProviderItems) {\n\t\t\t\toutput.unwatch();\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateFiles(files: IOutputContentSource[]): void {\n\t\tconst wasWatching = this.watching;\n\t\tif (wasWatching) {\n\t\t\tthis.unwatch();\n\t\t}\n\n\t\tconst result = sortedDiff(this.fileContentProviderItems.map(([output]) => output), files, (a, b) => resources.extUri.compare(a.resource, b.resource));\n\t\tfor (const { start, deleteCount, toInsert } of result) {\n\t\t\tconst outputs = toInsert.map(file => this.createFileContentProvider(file));\n\t\t\tconst outputsToRemove = this.fileContentProviderItems.splice(start, deleteCount, ...outputs);\n\t\t\tfor (const [, disposables] of outputsToRemove) {\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\t\t}\n\n\t\tif (wasWatching) {\n\t\t\tthis.watch();\n\t\t}\n\t}\n\n\treset(): void {\n\t\tfor (const [output] of this.fileContentProviderItems) {\n\t\t\toutput.reset();\n\t\t}\n\t\tthis.logEntries = [];\n\t}\n\n\tresetToEnd(): void {\n\t\tfor (const [output] of this.fileContentProviderItems) {\n\t\t\toutput.resetToEnd();\n\t\t}\n\t\tthis.logEntries = [];\n\t}\n\n\tgetLogEntries(): ReadonlyArray<ILogEntry> {\n\t\treturn this.logEntries;\n\t}\n\n\tasync getContent(): Promise<{ readonly content: string; readonly consume: () => void }> {\n\t\tconst outputs = await Promise.all(this.fileContentProviderItems.map(([output]) => output.getContent(true)));\n\t\tconst { content, logEntries } = this.combineLogEntries(outputs, this.logEntries[this.logEntries.length - 1]);\n\t\tlet consumed = false;\n\t\treturn {\n\t\t\tcontent,\n\t\t\tconsume: () => {\n\t\t\t\tif (!consumed) {\n\t\t\t\t\tconsumed = true;\n\t\t\t\t\toutputs.forEach(({ consume }) => consume());\n\t\t\t\t\tthis.logEntries.push(...logEntries);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate combineLogEntries(outputs: { content: string; name: string }[], lastEntry: ILogEntry | undefined): { logEntries: ILogEntry[]; content: string } {\n\n\t\toutputs = outputs.filter(output => !!output.content);\n\n\t\tif (outputs.length === 0) {\n\t\t\treturn { logEntries: [], content: '' };\n\t\t}\n\n\t\tconst logEntries: ILogEntry[] = [];\n\t\tconst contents: string[] = [];\n\t\tconst process = (model: ITextModel, logEntry: ILogEntry, name: string): [ILogEntry, string] => {\n\t\t\tconst lineContent = model.getValueInRange(logEntry.range);\n\t\t\tconst content = name ? `${lineContent.substring(0, logEntry.logLevelRange.endColumn)} [${name}]${lineContent.substring(logEntry.logLevelRange.endColumn)}` : lineContent;\n\t\t\treturn [{\n\t\t\t\t...logEntry,\n\t\t\t\tcategory: name,\n\t\t\t\trange: new Range(logEntry.range.startLineNumber, logEntry.logLevelRange.startColumn, logEntry.range.endLineNumber, name ? logEntry.range.endColumn + name.length + 3 : logEntry.range.endColumn),\n\t\t\t}, content];\n\t\t};\n\n\t\tconst model = this.instantiationService.createInstance(TextModel, outputs[0].content, LOG_MIME, TextModel.DEFAULT_CREATION_OPTIONS, null);\n\t\ttry {\n\t\t\tfor (const [logEntry, content] of logEntryIterator(model, (e) => process(model, e, outputs[0].name))) {\n\t\t\t\tlogEntries.push(logEntry);\n\t\t\t\tcontents.push(content);\n\t\t\t}\n\t\t} finally {\n\t\t\tmodel.dispose();\n\t\t}\n\n\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\tconst { content, name } = outputs[index];\n\t\t\tconst model = this.instantiationService.createInstance(TextModel, content, LOG_MIME, TextModel.DEFAULT_CREATION_OPTIONS, null);\n\t\t\ttry {\n\t\t\t\tconst iterator = logEntryIterator(model, (e) => process(model, e, name));\n\t\t\t\tlet next = iterator.next();\n\t\t\t\twhile (!next.done) {\n\t\t\t\t\tconst [logEntry, content] = next.value;\n\t\t\t\t\tconst logEntriesToAdd = [logEntry];\n\t\t\t\t\tconst contentsToAdd = [content];\n\n\t\t\t\t\tlet insertionIndex;\n\n\t\t\t\t\t// If the timestamp is greater than or equal to the last timestamp,\n\t\t\t\t\t// we can just append all the entries at the end\n\t\t\t\t\tif (logEntry.timestamp >= logEntries[logEntries.length - 1].timestamp) {\n\t\t\t\t\t\tinsertionIndex = logEntries.length;\n\t\t\t\t\t\tfor (next = iterator.next(); !next.done; next = iterator.next()) {\n\t\t\t\t\t\t\tlogEntriesToAdd.push(next.value[0]);\n\t\t\t\t\t\t\tcontentsToAdd.push(next.value[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (logEntry.timestamp <= logEntries[0].timestamp) {\n\t\t\t\t\t\t\t// If the timestamp is less than or equal to the first timestamp\n\t\t\t\t\t\t\t// then insert at the beginning\n\t\t\t\t\t\t\tinsertionIndex = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise, find the insertion index\n\t\t\t\t\t\t\tconst idx = binarySearch(logEntries, logEntry, (a, b) => a.timestamp - b.timestamp);\n\t\t\t\t\t\t\tinsertionIndex = idx < 0 ? ~idx : idx;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Collect all entries that have a timestamp less than or equal to the timestamp at the insertion index\n\t\t\t\t\t\tfor (next = iterator.next(); !next.done && next.value[0].timestamp <= logEntries[insertionIndex].timestamp; next = iterator.next()) {\n\t\t\t\t\t\t\tlogEntriesToAdd.push(next.value[0]);\n\t\t\t\t\t\t\tcontentsToAdd.push(next.value[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcontents.splice(insertionIndex, 0, ...contentsToAdd);\n\t\t\t\t\tlogEntries.splice(insertionIndex, 0, ...logEntriesToAdd);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tmodel.dispose();\n\t\t\t}\n\t\t}\n\n\t\tlet content = '';\n\t\tconst updatedLogEntries: ILogEntry[] = [];\n\t\tlet logEntryStartLineNumber = lastEntry ? lastEntry.range.endLineNumber + 1 : 1;\n\t\tfor (let i = 0; i < logEntries.length; i++) {\n\t\t\tcontent += contents[i] + '\\n';\n\t\t\tconst updatedLogEntry = changeStartLineNumber(logEntries[i], logEntryStartLineNumber);\n\t\t\tupdatedLogEntries.push(updatedLogEntry);\n\t\t\tlogEntryStartLineNumber = updatedLogEntry.range.endLineNumber + 1;\n\t\t}\n\n\t\treturn { logEntries: updatedLogEntries, content };\n\t}\n\n}\n\nexport abstract class AbstractFileOutputChannelModel extends Disposable implements IOutputChannelModel {\n\n\tprivate readonly _onDispose = this._register(new Emitter<void>());\n\treadonly onDispose: Event<void> = this._onDispose.event;\n\n\tprotected loadModelPromise: Promise<ITextModel> | null = null;\n\n\tprivate readonly modelDisposable = this._register(new MutableDisposable<DisposableStore>());\n\tprotected model: ITextModel | null = null;\n\tprivate modelUpdateInProgress: boolean = false;\n\tprivate readonly modelUpdateCancellationSource = this._register(new MutableDisposable<CancellationTokenSource>());\n\tprivate readonly appendThrottler = this._register(new ThrottledDelayer(300));\n\tprivate replacePromise: Promise<void> | undefined;\n\n\tabstract readonly source: IOutputContentSource | ReadonlyArray<IOutputContentSource>;\n\n\tconstructor(\n\t\tprivate readonly modelUri: URI,\n\t\tprivate readonly language: ILanguageSelection,\n\t\tprivate readonly outputContentProvider: IContentProvider,\n\t\t@IModelService protected readonly modelService: IModelService,\n\t\t@IEditorWorkerService private readonly editorWorkerService: IEditorWorkerService,\n\t) {\n\t\tsuper();\n\t}\n\n\tasync loadModel(): Promise<ITextModel> {\n\t\tthis.loadModelPromise = Promises.withAsyncBody<ITextModel>(async (c, e) => {\n\t\t\ttry {\n\t\t\t\tthis.modelDisposable.value = new DisposableStore();\n\t\t\t\tthis.model = this.modelService.createModel('', this.language, this.modelUri);\n\t\t\t\tconst { content, consume } = await this.outputContentProvider.getContent();\n\t\t\t\tconsume();\n\t\t\t\tthis.doAppendContent(this.model, content);\n\t\t\t\tthis.modelDisposable.value.add(this.outputContentProvider.onDidReset(() => this.onDidContentChange(true, true)));\n\t\t\t\tthis.modelDisposable.value.add(this.outputContentProvider.onDidAppend(() => this.onDidContentChange(false, false)));\n\t\t\t\tthis.outputContentProvider.watch();\n\t\t\t\tthis.modelDisposable.value.add(toDisposable(() => this.outputContentProvider.unwatch()));\n\t\t\t\tthis.modelDisposable.value.add(this.model.onWillDispose(() => {\n\t\t\t\t\tthis.outputContentProvider.reset();\n\t\t\t\t\tthis.modelDisposable.value = undefined;\n\t\t\t\t\tthis.cancelModelUpdate();\n\t\t\t\t\tthis.model = null;\n\t\t\t\t}));\n\t\t\t\tc(this.model);\n\t\t\t} catch (error) {\n\t\t\t\te(error);\n\t\t\t}\n\t\t});\n\t\treturn this.loadModelPromise;\n\t}\n\n\tgetLogEntries(): readonly ILogEntry[] {\n\t\treturn this.outputContentProvider.getLogEntries();\n\t}\n\n\tprivate onDidContentChange(reset: boolean, appendImmediately: boolean): void {\n\t\tif (reset && !this.modelUpdateInProgress) {\n\t\t\tthis.doUpdate(OutputChannelUpdateMode.Clear, true);\n\t\t}\n\t\tthis.doUpdate(OutputChannelUpdateMode.Append, appendImmediately);\n\t}\n\n\tprotected doUpdate(mode: OutputChannelUpdateMode, immediate: boolean): void {\n\t\tif (mode === OutputChannelUpdateMode.Clear || mode === OutputChannelUpdateMode.Replace) {\n\t\t\tthis.cancelModelUpdate();\n\t\t}\n\t\tif (!this.model) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.modelUpdateInProgress = true;\n\t\tif (!this.modelUpdateCancellationSource.value) {\n\t\t\tthis.modelUpdateCancellationSource.value = new CancellationTokenSource();\n\t\t}\n\t\tconst token = this.modelUpdateCancellationSource.value.token;\n\n\t\tif (mode === OutputChannelUpdateMode.Clear) {\n\t\t\tthis.clearContent(this.model);\n\t\t}\n\n\t\telse if (mode === OutputChannelUpdateMode.Replace) {\n\t\t\tthis.replacePromise = this.replaceContent(this.model, token).finally(() => this.replacePromise = undefined);\n\t\t}\n\n\t\telse {\n\t\t\tthis.appendContent(this.model, immediate, token);\n\t\t}\n\t}\n\n\tprivate clearContent(model: ITextModel): void {\n\t\tmodel.applyEdits([EditOperation.delete(model.getFullModelRange())]);\n\t\tthis.modelUpdateInProgress = false;\n\t}\n\n\tprivate appendContent(model: ITextModel, immediate: boolean, token: CancellationToken): void {\n\t\tthis.appendThrottler.trigger(async () => {\n\t\t\t/* Abort if operation is cancelled */\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Wait for replace to finish */\n\t\t\tif (this.replacePromise) {\n\t\t\t\ttry { await this.replacePromise; } catch (e) { /* Ignore */ }\n\t\t\t\t/* Abort if operation is cancelled */\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Get content to append */\n\t\t\tconst { content, consume } = await this.outputContentProvider.getContent();\n\t\t\t/* Abort if operation is cancelled */\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Appned Content */\n\t\t\tconsume();\n\t\t\tthis.doAppendContent(model, content);\n\t\t\tthis.modelUpdateInProgress = false;\n\t\t}, immediate ? 0 : undefined).catch(error => {\n\t\t\tif (!isCancellationError(error)) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate doAppendContent(model: ITextModel, content: string): void {\n\t\tconst lastLine = model.getLineCount();\n\t\tconst lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n\t\tmodel.applyEdits([EditOperation.insert(new Position(lastLine, lastLineMaxColumn), content)]);\n\t}\n\n\tprivate async replaceContent(model: ITextModel, token: CancellationToken): Promise<void> {\n\t\t/* Get content to replace */\n\t\tconst { content, consume } = await this.outputContentProvider.getContent();\n\t\t/* Abort if operation is cancelled */\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* Compute Edits */\n\t\tconst edits = await this.getReplaceEdits(model, content.toString());\n\t\t/* Abort if operation is cancelled */\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsume();\n\t\tif (edits.length) {\n\t\t\t/* Apply Edits */\n\t\t\tmodel.applyEdits(edits);\n\t\t}\n\t\tthis.modelUpdateInProgress = false;\n\t}\n\n\tprivate async getReplaceEdits(model: ITextModel, contentToReplace: string): Promise<ISingleEditOperation[]> {\n\t\tif (!contentToReplace) {\n\t\t\treturn [EditOperation.delete(model.getFullModelRange())];\n\t\t}\n\t\tif (contentToReplace !== model.getValue()) {\n\t\t\tconst edits = await this.editorWorkerService.computeMoreMinimalEdits(model.uri, [{ text: contentToReplace.toString(), range: model.getFullModelRange() }]);\n\t\t\tif (edits?.length) {\n\t\t\t\treturn edits.map(edit => EditOperation.replace(Range.lift(edit.range), edit.text));\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t}\n\n\tprotected cancelModelUpdate(): void {\n\t\tthis.modelUpdateCancellationSource.value?.cancel();\n\t\tthis.modelUpdateCancellationSource.value = undefined;\n\t\tthis.appendThrottler.cancel();\n\t\tthis.replacePromise = undefined;\n\t\tthis.modelUpdateInProgress = false;\n\t}\n\n\tprotected isVisible(): boolean {\n\t\treturn !!this.model;\n\t}\n\n\toverride dispose(): void {\n\t\tthis._onDispose.fire();\n\t\tsuper.dispose();\n\t}\n\n\tappend(message: string): void { throw new Error('Not supported'); }\n\treplace(message: string): void { throw new Error('Not supported'); }\n\n\tabstract clear(): void;\n\tabstract update(mode: OutputChannelUpdateMode, till: number | undefined, immediate: boolean): void;\n\tabstract updateChannelSources(files: IOutputContentSource[]): void;\n}\n\nexport class FileOutputChannelModel extends AbstractFileOutputChannelModel implements IOutputChannelModel {\n\n\tprivate readonly fileOutput: FileContentProvider;\n\n\tconstructor(\n\t\tmodelUri: URI,\n\t\tlanguage: ILanguageSelection,\n\t\treadonly source: IOutputContentSource,\n\t\t@IFileService fileService: IFileService,\n\t\t@IModelService modelService: IModelService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@ILogService logService: ILogService,\n\t\t@IEditorWorkerService editorWorkerService: IEditorWorkerService,\n\t) {\n\t\tconst fileOutput = new FileContentProvider(source, fileService, instantiationService, logService);\n\t\tsuper(modelUri, language, fileOutput, modelService, editorWorkerService);\n\t\tthis.fileOutput = this._register(fileOutput);\n\t}\n\n\toverride clear(): void {\n\t\tthis.update(OutputChannelUpdateMode.Clear, undefined, true);\n\t}\n\n\toverride update(mode: OutputChannelUpdateMode, till: number | undefined, immediate: boolean): void {\n\t\tconst loadModelPromise = this.loadModelPromise ? this.loadModelPromise : Promise.resolve();\n\t\tloadModelPromise.then(() => {\n\t\t\tif (mode === OutputChannelUpdateMode.Clear || mode === OutputChannelUpdateMode.Replace) {\n\t\t\t\tif (isNumber(till)) {\n\t\t\t\t\tthis.fileOutput.reset(till);\n\t\t\t\t} else {\n\t\t\t\t\tthis.fileOutput.resetToEnd();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.doUpdate(mode, immediate);\n\t\t});\n\t}\n\n\toverride updateChannelSources(files: IOutputContentSource[]): void { throw new Error('Not supported'); }\n}\n\nexport class MultiFileOutputChannelModel extends AbstractFileOutputChannelModel implements IOutputChannelModel {\n\n\tprivate readonly multifileOutput: MultiFileContentProvider;\n\n\tconstructor(\n\t\tmodelUri: URI,\n\t\tlanguage: ILanguageSelection,\n\t\treadonly source: IOutputContentSource[],\n\t\t@IFileService fileService: IFileService,\n\t\t@IModelService modelService: IModelService,\n\t\t@ILogService logService: ILogService,\n\t\t@IEditorWorkerService editorWorkerService: IEditorWorkerService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t) {\n\t\tconst multifileOutput = new MultiFileContentProvider(source, instantiationService, fileService, logService);\n\t\tsuper(modelUri, language, multifileOutput, modelService, editorWorkerService);\n\t\tthis.multifileOutput = this._register(multifileOutput);\n\t}\n\n\toverride updateChannelSources(files: IOutputContentSource[]): void {\n\t\tthis.multifileOutput.unwatch();\n\t\tthis.multifileOutput.updateFiles(files);\n\t\tthis.multifileOutput.reset();\n\t\tthis.doUpdate(OutputChannelUpdateMode.Replace, true);\n\t\tif (this.isVisible()) {\n\t\t\tthis.multifileOutput.watch();\n\t\t}\n\t}\n\n\toverride clear(): void {\n\t\tconst loadModelPromise = this.loadModelPromise ? this.loadModelPromise : Promise.resolve();\n\t\tloadModelPromise.then(() => {\n\t\t\tthis.multifileOutput.resetToEnd();\n\t\t\tthis.doUpdate(OutputChannelUpdateMode.Clear, true);\n\t\t});\n\t}\n\n\toverride update(mode: OutputChannelUpdateMode, till: number | undefined, immediate: boolean): void { throw new Error('Not supported'); }\n}\n\nclass OutputChannelBackedByFile extends FileOutputChannelModel implements IOutputChannelModel {\n\n\tprivate logger: ILogger;\n\tprivate _offset: number;\n\n\tconstructor(\n\t\tid: string,\n\t\tmodelUri: URI,\n\t\tlanguage: ILanguageSelection,\n\t\tfile: URI,\n\t\t@IFileService fileService: IFileService,\n\t\t@IModelService modelService: IModelService,\n\t\t@ILoggerService loggerService: ILoggerService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@ILogService logService: ILogService,\n\t\t@IEditorWorkerService editorWorkerService: IEditorWorkerService\n\t) {\n\t\tsuper(modelUri, language, { resource: file, name: '' }, fileService, modelService, instantiationService, logService, editorWorkerService);\n\n\t\t// Donot rotate to check for the file reset\n\t\tthis.logger = loggerService.createLogger(file, { logLevel: 'always', donotRotate: true, donotUseFormatters: true, hidden: true });\n\t\tthis._offset = 0;\n\t}\n\n\toverride append(message: string): void {\n\t\tthis.write(message);\n\t\tthis.update(OutputChannelUpdateMode.Append, undefined, this.isVisible());\n\t}\n\n\toverride replace(message: string): void {\n\t\tconst till = this._offset;\n\t\tthis.write(message);\n\t\tthis.update(OutputChannelUpdateMode.Replace, till, true);\n\t}\n\n\tprivate write(content: string): void {\n\t\tthis._offset += VSBuffer.fromString(content).byteLength;\n\t\tthis.logger.info(content);\n\t\tif (this.isVisible()) {\n\t\t\tthis.logger.flush();\n\t\t}\n\t}\n\n}\n\nexport class DelegatedOutputChannelModel extends Disposable implements IOutputChannelModel {\n\n\tprivate readonly _onDispose: Emitter<void> = this._register(new Emitter<void>());\n\treadonly onDispose: Event<void> = this._onDispose.event;\n\n\tprivate readonly outputChannelModel: Promise<IOutputChannelModel>;\n\treadonly source: IOutputContentSource;\n\n\tconstructor(\n\t\tid: string,\n\t\tmodelUri: URI,\n\t\tlanguage: ILanguageSelection,\n\t\toutputDir: URI,\n\t\toutputDirCreationPromise: Promise<void>,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t) {\n\t\tsuper();\n\t\tthis.outputChannelModel = this.createOutputChannelModel(id, modelUri, language, outputDir, outputDirCreationPromise);\n\t\tconst resource = resources.joinPath(outputDir, `${id.replace(/[\\\\/:\\*\\?\"<>\\|]/g, '')}.log`);\n\t\tthis.source = { resource };\n\t}\n\n\tprivate async createOutputChannelModel(id: string, modelUri: URI, language: ILanguageSelection, outputDir: URI, outputDirPromise: Promise<void>): Promise<IOutputChannelModel> {\n\t\tawait outputDirPromise;\n\t\tconst file = resources.joinPath(outputDir, `${id.replace(/[\\\\/:\\*\\?\"<>\\|]/g, '')}.log`);\n\t\tawait this.fileService.createFile(file);\n\t\tconst outputChannelModel = this._register(this.instantiationService.createInstance(OutputChannelBackedByFile, id, modelUri, language, file));\n\t\tthis._register(outputChannelModel.onDispose(() => this._onDispose.fire()));\n\t\treturn outputChannelModel;\n\t}\n\n\tgetLogEntries(): readonly ILogEntry[] {\n\t\treturn [];\n\t}\n\n\tappend(output: string): void {\n\t\tthis.outputChannelModel.then(outputChannelModel => outputChannelModel.append(output));\n\t}\n\n\tupdate(mode: OutputChannelUpdateMode, till: number | undefined, immediate: boolean): void {\n\t\tthis.outputChannelModel.then(outputChannelModel => outputChannelModel.update(mode, till, immediate));\n\t}\n\n\tloadModel(): Promise<ITextModel> {\n\t\treturn this.outputChannelModel.then(outputChannelModel => outputChannelModel.loadModel());\n\t}\n\n\tclear(): void {\n\t\tthis.outputChannelModel.then(outputChannelModel => outputChannelModel.clear());\n\t}\n\n\treplace(value: string): void {\n\t\tthis.outputChannelModel.then(outputChannelModel => outputChannelModel.replace(value));\n\t}\n\n\tupdateChannelSources(files: IOutputContentSource[]): void {\n\t\tthis.outputChannelModel.then(outputChannelModel => outputChannelModel.updateChannelSources(files));\n\t}\n}\n"]}