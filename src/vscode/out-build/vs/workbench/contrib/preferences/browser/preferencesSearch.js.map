{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/preferences/browser/preferencesSearch.ts","vs/workbench/contrib/preferences/browser/preferencesSearch.ts"],"names":[],"mappings":"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","file":"preferencesSearch.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IStringDictionary } from '../../../../base/common/collections.js';\nimport { IMatch, matchesBaseContiguousSubString, matchesContiguousSubString, matchesSubString, matchesWords } from '../../../../base/common/filters.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { TfIdfCalculator, TfIdfDocument } from '../../../../base/common/tfIdf.js';\nimport { IRange } from '../../../../editor/common/core/range.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IExtensionManagementService, ILocalExtension } from '../../../../platform/extensionManagement/common/extensionManagement.js';\nimport { ExtensionType } from '../../../../platform/extensions/common/extensions.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IAiSettingsSearchService } from '../../../services/aiSettingsSearch/common/aiSettingsSearch.js';\nimport { IWorkbenchExtensionEnablementService } from '../../../services/extensionManagement/common/extensionManagement.js';\nimport { IGroupFilter, ISearchResult, ISetting, ISettingMatch, ISettingMatcher, ISettingsEditorModel, ISettingsGroup, SettingKeyMatchTypes, SettingMatchType } from '../../../services/preferences/common/preferences.js';\nimport { nullRange } from '../../../services/preferences/common/preferencesModels.js';\nimport { EMBEDDINGS_ONLY_SEARCH_PROVIDER_NAME, EMBEDDINGS_SEARCH_PROVIDER_NAME, IAiSearchProvider, IPreferencesSearchService, IRemoteSearchProvider, ISearchProvider, IWorkbenchSettingsConfiguration, LLM_RANKED_SEARCH_PROVIDER_NAME, STRING_MATCH_SEARCH_PROVIDER_NAME, TF_IDF_SEARCH_PROVIDER_NAME } from '../common/preferences.js';\n\nexport interface IEndpointDetails {\n\turlBase?: string;\n\tkey?: string;\n}\n\nexport class PreferencesSearchService extends Disposable implements IPreferencesSearchService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\t// @ts-expect-error disable remote search for now, ref https://github.com/microsoft/vscode/issues/172411\n\tprivate _installedExtensions: Promise<ILocalExtension[]>;\n\tprivate _remoteSearchProvider: IRemoteSearchProvider | undefined;\n\tprivate _aiSearchProvider: IAiSearchProvider | undefined;\n\n\tconstructor(\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IExtensionManagementService private readonly extensionManagementService: IExtensionManagementService,\n\t\t@IWorkbenchExtensionEnablementService private readonly extensionEnablementService: IWorkbenchExtensionEnablementService\n\t) {\n\t\tsuper();\n\n\t\t// This request goes to the shared process but results won't change during a window's lifetime, so cache the results.\n\t\tthis._installedExtensions = this.extensionManagementService.getInstalled(ExtensionType.User).then(exts => {\n\t\t\t// Filter to enabled extensions that have settings\n\t\t\treturn exts\n\t\t\t\t.filter(ext => this.extensionEnablementService.isEnabled(ext))\n\t\t\t\t.filter(ext => ext.manifest && ext.manifest.contributes && ext.manifest.contributes.configuration)\n\t\t\t\t.filter(ext => !!ext.identifier.uuid);\n\t\t});\n\t}\n\n\tgetLocalSearchProvider(filter: string): LocalSearchProvider {\n\t\treturn this.instantiationService.createInstance(LocalSearchProvider, filter);\n\t}\n\n\tprivate get remoteSearchAllowed(): boolean {\n\t\tconst workbenchSettings = this.configurationService.getValue<IWorkbenchSettingsConfiguration>().workbench.settings;\n\t\treturn workbenchSettings.enableNaturalLanguageSearch;\n\t}\n\n\tgetRemoteSearchProvider(filter: string): IRemoteSearchProvider | undefined {\n\t\tif (!this.remoteSearchAllowed) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._remoteSearchProvider ??= this.instantiationService.createInstance(RemoteSearchProvider);\n\t\tthis._remoteSearchProvider.setFilter(filter);\n\t\treturn this._remoteSearchProvider;\n\t}\n\n\tgetAiSearchProvider(filter: string): IAiSearchProvider | undefined {\n\t\tif (!this.remoteSearchAllowed) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._aiSearchProvider ??= this.instantiationService.createInstance(AiSearchProvider);\n\t\tthis._aiSearchProvider.setFilter(filter);\n\t\treturn this._aiSearchProvider;\n\t}\n}\n\nfunction cleanFilter(filter: string): string {\n\t// Remove \" and : which are likely to be copypasted as part of a setting name.\n\t// Leave other special characters which the user might want to search for.\n\treturn filter\n\t\t.replace(/[\":]/g, ' ')\n\t\t.replace(/  /g, ' ')\n\t\t.trim();\n}\n\nexport class LocalSearchProvider implements ISearchProvider {\n\tconstructor(\n\t\tprivate _filter: string,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tthis._filter = cleanFilter(this._filter);\n\t}\n\n\tsearchModel(preferencesModel: ISettingsEditorModel, token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter) {\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\tconst settingMatcher: ISettingMatcher = (setting: ISetting) => {\n\t\t\tlet { matches, matchType, keyMatchScore } = new SettingMatches(\n\t\t\t\tthis._filter,\n\t\t\t\tsetting,\n\t\t\t\ttrue,\n\t\t\t\tthis.configurationService\n\t\t\t);\n\t\t\tif (matchType === SettingMatchType.None || matches.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (strings.equalsIgnoreCase(this._filter, setting.key)) {\n\t\t\t\tmatchType = SettingMatchType.ExactMatch;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tmatches,\n\t\t\t\tmatchType,\n\t\t\t\tkeyMatchScore,\n\t\t\t\tscore: 0 // only used for RemoteSearchProvider matches.\n\t\t\t};\n\t\t};\n\n\t\tconst filterMatches = preferencesModel.filterSettings(this._filter, this.getGroupFilter(this._filter), settingMatcher);\n\n\t\t// Check the top key match type.\n\t\tconst topKeyMatchType = Math.max(...filterMatches.map(m => (m.matchType & SettingKeyMatchTypes)));\n\t\t// Always allow description matches as part of https://github.com/microsoft/vscode/issues/239936.\n\t\tconst alwaysAllowedMatchTypes = SettingMatchType.DescriptionOrValueMatch | SettingMatchType.LanguageTagSettingMatch;\n\t\tconst filteredMatches = filterMatches\n\t\t\t.filter(m => (m.matchType & topKeyMatchType) || (m.matchType & alwaysAllowedMatchTypes) || m.matchType === SettingMatchType.ExactMatch)\n\t\t\t.map(m => ({ ...m, providerName: STRING_MATCH_SEARCH_PROVIDER_NAME }));\n\t\treturn Promise.resolve({\n\t\t\tfilterMatches: filteredMatches,\n\t\t\texactMatch: filteredMatches.some(m => m.matchType === SettingMatchType.ExactMatch)\n\t\t});\n\t}\n\n\tprivate getGroupFilter(filter: string): IGroupFilter {\n\t\tconst regex = strings.createRegExp(filter, false, { global: true });\n\t\treturn (group: ISettingsGroup) => {\n\t\t\treturn group.id !== 'defaultOverrides' && regex.test(group.title);\n\t\t};\n\t}\n}\n\nexport class SettingMatches {\n\treadonly matches: IRange[];\n\tmatchType: SettingMatchType = SettingMatchType.None;\n\t/**\n\t * A match score for key matches to allow comparing key matches against each other.\n\t * Otherwise, all key matches are treated the same, and sorting is done by ToC order.\n\t */\n\tkeyMatchScore: number = 0;\n\n\tconstructor(\n\t\tsearchString: string,\n\t\tsetting: ISetting,\n\t\tprivate searchDescription: boolean,\n\t\tprivate readonly configurationService: IConfigurationService\n\t) {\n\t\tthis.matches = distinct(this._findMatchesInSetting(searchString, setting), (match) => `${match.startLineNumber}_${match.startColumn}_${match.endLineNumber}_${match.endColumn}_`);\n\t}\n\n\tprivate _findMatchesInSetting(searchString: string, setting: ISetting): IRange[] {\n\t\tconst result = this._doFindMatchesInSetting(searchString, setting);\n\t\treturn result;\n\t}\n\n\tprivate _keyToLabel(settingId: string): string {\n\t\tconst label = settingId\n\t\t\t.replace(/[-._]/g, ' ')\n\t\t\t.replace(/([a-z]+)([A-Z])/g, '$1 $2')\n\t\t\t.replace(/([A-Za-z]+)(\\d+)/g, '$1 $2')\n\t\t\t.replace(/(\\d+)([A-Za-z]+)/g, '$1 $2')\n\t\t\t.toLowerCase();\n\t\treturn label;\n\t}\n\n\tprivate _toAlphaNumeric(s: string): string {\n\t\treturn s.replace(/[^\\p{L}\\p{N}]+/gu, '');\n\t}\n\n\tprivate _doFindMatchesInSetting(searchString: string, setting: ISetting): IRange[] {\n\t\tconst descriptionMatchingWords: Map<string, IRange[]> = new Map<string, IRange[]>();\n\t\tconst keyMatchingWords: Map<string, IRange[]> = new Map<string, IRange[]>();\n\t\tconst valueMatchingWords: Map<string, IRange[]> = new Map<string, IRange[]>();\n\n\t\t// Key (ID) search\n\t\t// First, search by the setting's ID and label.\n\t\tconst settingKeyAsWords: string = this._keyToLabel(setting.key);\n\t\tconst queryWords = new Set<string>(searchString.split(' '));\n\t\tfor (const word of queryWords) {\n\t\t\t// Check if the key contains the word. Use contiguous search.\n\t\t\tconst keyMatches = matchesWords(word, settingKeyAsWords, true);\n\t\t\tif (keyMatches?.length) {\n\t\t\t\tkeyMatchingWords.set(word, keyMatches.map(match => this.toKeyRange(setting, match)));\n\t\t\t}\n\t\t}\n\t\tif (keyMatchingWords.size === queryWords.size) {\n\t\t\t// All words in the query matched with something in the setting key.\n\t\t\t// Matches \"edit format on paste\" to \"editor.formatOnPaste\".\n\t\t\tthis.matchType |= SettingMatchType.AllWordsInSettingsLabel;\n\t\t} else if (keyMatchingWords.size >= 2) {\n\t\t\t// Matches \"edit paste\" to \"editor.formatOnPaste\".\n\t\t\t// The if statement reduces noise by preventing \"editor formatonpast\" from matching all editor settings.\n\t\t\tthis.matchType |= SettingMatchType.ContiguousWordsInSettingsLabel;\n\t\t\tthis.keyMatchScore = keyMatchingWords.size;\n\t\t}\n\t\tconst searchStringAlphaNumeric = this._toAlphaNumeric(searchString);\n\t\tconst keyAlphaNumeric = this._toAlphaNumeric(setting.key);\n\t\tconst keyIdMatches = matchesContiguousSubString(searchStringAlphaNumeric, keyAlphaNumeric);\n\t\tif (keyIdMatches?.length) {\n\t\t\t// Matches \"editorformatonp\" to \"editor.formatonpaste\".\n\t\t\tkeyMatchingWords.set(setting.key, keyIdMatches.map(match => this.toKeyRange(setting, match)));\n\t\t\tthis.matchType |= SettingMatchType.ContiguousQueryInSettingId;\n\t\t}\n\n\t\t// Fall back to non-contiguous key (ID) searches if nothing matched yet.\n\t\tif (this.matchType === SettingMatchType.None) {\n\t\t\tkeyMatchingWords.clear();\n\t\t\tfor (const word of queryWords) {\n\t\t\t\tconst keyMatches = matchesWords(word, settingKeyAsWords, false);\n\t\t\t\tif (keyMatches?.length) {\n\t\t\t\t\tkeyMatchingWords.set(word, keyMatches.map(match => this.toKeyRange(setting, match)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (keyMatchingWords.size >= 2 || (keyMatchingWords.size === 1 && queryWords.size === 1)) {\n\t\t\t\t// Matches \"edforonpas\" to \"editor.formatOnPaste\".\n\t\t\t\t// The if statement reduces noise by preventing \"editor fomonpast\" from matching all editor settings.\n\t\t\t\tthis.matchType |= SettingMatchType.NonContiguousWordsInSettingsLabel;\n\t\t\t\tthis.keyMatchScore = keyMatchingWords.size;\n\t\t\t} else {\n\t\t\t\tconst keyIdMatches = matchesSubString(searchStringAlphaNumeric, keyAlphaNumeric);\n\t\t\t\tif (keyIdMatches?.length) {\n\t\t\t\t\t// Matches \"edfmonpas\" to \"editor.formatOnPaste\".\n\t\t\t\t\tkeyMatchingWords.set(setting.key, keyIdMatches.map(match => this.toKeyRange(setting, match)));\n\t\t\t\t\tthis.matchType |= SettingMatchType.NonContiguousQueryInSettingId;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check if the match was for a language tag group setting such as [markdown].\n\t\t// In such a case, move that setting to be last.\n\t\tif (setting.overrides?.length && (this.matchType !== SettingMatchType.None)) {\n\t\t\tthis.matchType = SettingMatchType.LanguageTagSettingMatch;\n\t\t\tconst keyRanges = keyMatchingWords.size ?\n\t\t\t\tArray.from(keyMatchingWords.values()).flat() : [];\n\t\t\treturn [...keyRanges];\n\t\t}\n\n\t\t// Description search\n\t\t// Search the description if we found non-contiguous key matches at best.\n\t\tconst hasContiguousKeyMatchTypes = this.matchType >= SettingMatchType.ContiguousWordsInSettingsLabel;\n\t\tif (this.searchDescription && !hasContiguousKeyMatchTypes) {\n\t\t\tfor (const word of queryWords) {\n\t\t\t\t// Search the description lines.\n\t\t\t\tfor (let lineIndex = 0; lineIndex < setting.description.length; lineIndex++) {\n\t\t\t\t\tconst descriptionMatches = matchesBaseContiguousSubString(word, setting.description[lineIndex]);\n\t\t\t\t\tif (descriptionMatches?.length) {\n\t\t\t\t\t\tdescriptionMatchingWords.set(word, descriptionMatches.map(match => this.toDescriptionRange(setting, match, lineIndex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (descriptionMatchingWords.size === queryWords.size) {\n\t\t\t\tthis.matchType |= SettingMatchType.DescriptionOrValueMatch;\n\t\t\t} else {\n\t\t\t\t// Clear out the match for now. We want to require all words to match in the description.\n\t\t\t\tdescriptionMatchingWords.clear();\n\t\t\t}\n\t\t}\n\n\t\t// Value search\n\t\t// Check if the value contains all the words.\n\t\t// Search the values if we found non-contiguous key matches at best.\n\t\tif (!hasContiguousKeyMatchTypes) {\n\t\t\tif (setting.enum?.length) {\n\t\t\t\t// Search all string values of enums.\n\t\t\t\tfor (const option of setting.enum) {\n\t\t\t\t\tif (typeof option !== 'string') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvalueMatchingWords.clear();\n\t\t\t\t\tfor (const word of queryWords) {\n\t\t\t\t\t\tconst valueMatches = matchesContiguousSubString(word, option);\n\t\t\t\t\t\tif (valueMatches?.length) {\n\t\t\t\t\t\t\tvalueMatchingWords.set(word, valueMatches.map(match => this.toValueRange(setting, match)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueMatchingWords.size === queryWords.size) {\n\t\t\t\t\t\tthis.matchType |= SettingMatchType.DescriptionOrValueMatch;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Clear out the match for now. We want to require all words to match in the value.\n\t\t\t\t\t\tvalueMatchingWords.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Search single string value.\n\t\t\t\tconst settingValue = this.configurationService.getValue(setting.key);\n\t\t\t\tif (typeof settingValue === 'string') {\n\t\t\t\t\tfor (const word of queryWords) {\n\t\t\t\t\t\tconst valueMatches = matchesContiguousSubString(word, settingValue);\n\t\t\t\t\t\tif (valueMatches?.length) {\n\t\t\t\t\t\t\tvalueMatchingWords.set(word, valueMatches.map(match => this.toValueRange(setting, match)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueMatchingWords.size === queryWords.size) {\n\t\t\t\t\t\tthis.matchType |= SettingMatchType.DescriptionOrValueMatch;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Clear out the match for now. We want to require all words to match in the value.\n\t\t\t\t\t\tvalueMatchingWords.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst descriptionRanges = descriptionMatchingWords.size ?\n\t\t\tArray.from(descriptionMatchingWords.values()).flat() : [];\n\t\tconst keyRanges = keyMatchingWords.size ?\n\t\t\tArray.from(keyMatchingWords.values()).flat() : [];\n\t\tconst valueRanges = valueMatchingWords.size ?\n\t\t\tArray.from(valueMatchingWords.values()).flat() : [];\n\t\treturn [...descriptionRanges, ...keyRanges, ...valueRanges];\n\t}\n\n\tprivate toKeyRange(setting: ISetting, match: IMatch): IRange {\n\t\treturn {\n\t\t\tstartLineNumber: setting.keyRange.startLineNumber,\n\t\t\tstartColumn: setting.keyRange.startColumn + match.start,\n\t\t\tendLineNumber: setting.keyRange.startLineNumber,\n\t\t\tendColumn: setting.keyRange.startColumn + match.end\n\t\t};\n\t}\n\n\tprivate toDescriptionRange(setting: ISetting, match: IMatch, lineIndex: number): IRange {\n\t\tconst descriptionRange = setting.descriptionRanges[lineIndex];\n\t\tif (!descriptionRange) {\n\t\t\t// This case occurs with added settings such as the\n\t\t\t// manage extension setting.\n\t\t\treturn nullRange;\n\t\t}\n\t\treturn {\n\t\t\tstartLineNumber: descriptionRange.startLineNumber,\n\t\t\tstartColumn: descriptionRange.startColumn + match.start,\n\t\t\tendLineNumber: descriptionRange.endLineNumber,\n\t\t\tendColumn: descriptionRange.startColumn + match.end\n\t\t};\n\t}\n\n\tprivate toValueRange(setting: ISetting, match: IMatch): IRange {\n\t\treturn {\n\t\t\tstartLineNumber: setting.valueRange.startLineNumber,\n\t\t\tstartColumn: setting.valueRange.startColumn + match.start + 1,\n\t\t\tendLineNumber: setting.valueRange.startLineNumber,\n\t\t\tendColumn: setting.valueRange.startColumn + match.end + 1\n\t\t};\n\t}\n}\n\nclass SettingsRecordProvider {\n\tprivate _settingsRecord: IStringDictionary<ISetting> = {};\n\tprivate _currentPreferencesModel: ISettingsEditorModel | undefined;\n\n\tconstructor() { }\n\n\tupdateModel(preferencesModel: ISettingsEditorModel) {\n\t\tif (preferencesModel === this._currentPreferencesModel) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentPreferencesModel = preferencesModel;\n\t\tthis.refresh();\n\t}\n\n\tprivate refresh() {\n\t\tthis._settingsRecord = {};\n\n\t\tif (!this._currentPreferencesModel) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const group of this._currentPreferencesModel.settingsGroups) {\n\t\t\tif (group.id === 'mostCommonlyUsed') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (const section of group.sections) {\n\t\t\t\tfor (const setting of section.settings) {\n\t\t\t\t\tthis._settingsRecord[setting.key] = setting;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetSettingsRecord(): IStringDictionary<ISetting> {\n\t\treturn this._settingsRecord;\n\t}\n}\n\nclass EmbeddingsSearchProvider implements IRemoteSearchProvider {\n\tprivate static readonly EMBEDDINGS_SETTINGS_SEARCH_MAX_PICKS = 10;\n\n\tprivate readonly _recordProvider: SettingsRecordProvider;\n\tprivate _filter: string = '';\n\n\tconstructor(\n\t\tprivate readonly _aiSettingsSearchService: IAiSettingsSearchService,\n\t\tprivate readonly _excludeSelectionStep: boolean\n\t) {\n\t\tthis._recordProvider = new SettingsRecordProvider();\n\t}\n\n\tsetFilter(filter: string) {\n\t\tthis._filter = cleanFilter(filter);\n\t}\n\n\tasync searchModel(preferencesModel: ISettingsEditorModel, token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter || !this._aiSettingsSearchService.isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis._recordProvider.updateModel(preferencesModel);\n\t\tthis._aiSettingsSearchService.startSearch(this._filter, this._excludeSelectionStep, token);\n\n\t\treturn {\n\t\t\tfilterMatches: await this.getEmbeddingsItems(token),\n\t\t\texactMatch: false\n\t\t};\n\t}\n\n\tprivate async getEmbeddingsItems(token: CancellationToken): Promise<ISettingMatch[]> {\n\t\tconst settingsRecord = this._recordProvider.getSettingsRecord();\n\t\tconst filterMatches: ISettingMatch[] = [];\n\t\tconst settings = await this._aiSettingsSearchService.getEmbeddingsResults(this._filter, token);\n\t\tif (!settings) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst providerName = this._excludeSelectionStep ? EMBEDDINGS_ONLY_SEARCH_PROVIDER_NAME : EMBEDDINGS_SEARCH_PROVIDER_NAME;\n\t\tfor (const settingKey of settings) {\n\t\t\tif (filterMatches.length === EmbeddingsSearchProvider.EMBEDDINGS_SETTINGS_SEARCH_MAX_PICKS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfilterMatches.push({\n\t\t\t\tsetting: settingsRecord[settingKey],\n\t\t\t\tmatches: [settingsRecord[settingKey].range],\n\t\t\t\tmatchType: SettingMatchType.RemoteMatch,\n\t\t\t\tkeyMatchScore: 0,\n\t\t\t\tscore: 0, // the results are sorted upstream.\n\t\t\t\tproviderName\n\t\t\t});\n\t\t}\n\n\t\treturn filterMatches;\n\t}\n}\n\nclass TfIdfSearchProvider implements IRemoteSearchProvider {\n\tprivate static readonly TF_IDF_PRE_NORMALIZE_THRESHOLD = 50;\n\tprivate static readonly TF_IDF_POST_NORMALIZE_THRESHOLD = 0.7;\n\tprivate static readonly TF_IDF_MAX_PICKS = 5;\n\n\tprivate _currentPreferencesModel: ISettingsEditorModel | undefined;\n\tprivate _filter: string = '';\n\tprivate _documents: TfIdfDocument[] = [];\n\tprivate _settingsRecord: IStringDictionary<ISetting> = {};\n\n\tconstructor() {\n\t}\n\n\tsetFilter(filter: string) {\n\t\tthis._filter = cleanFilter(filter);\n\t}\n\n\tkeyToLabel(settingId: string): string {\n\t\tconst label = settingId\n\t\t\t.replace(/[-._]/g, ' ')\n\t\t\t.replace(/([a-z]+)([A-Z])/g, '$1 $2')\n\t\t\t.replace(/([A-Za-z]+)(\\d+)/g, '$1 $2')\n\t\t\t.replace(/(\\d+)([A-Za-z]+)/g, '$1 $2')\n\t\t\t.toLowerCase();\n\t\treturn label;\n\t}\n\n\tsettingItemToEmbeddingString(item: ISetting): string {\n\t\tlet result = `Setting Id: ${item.key}\\n`;\n\t\tresult += `Label: ${this.keyToLabel(item.key)}\\n`;\n\t\tresult += `Description: ${item.description}\\n`;\n\t\treturn result;\n\t}\n\n\tasync searchModel(preferencesModel: ISettingsEditorModel, token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this._currentPreferencesModel !== preferencesModel) {\n\t\t\t// Refresh the documents and settings record\n\t\t\tthis._currentPreferencesModel = preferencesModel;\n\t\t\tthis._documents = [];\n\t\t\tthis._settingsRecord = {};\n\t\t\tfor (const group of preferencesModel.settingsGroups) {\n\t\t\t\tif (group.id === 'mostCommonlyUsed') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (const section of group.sections) {\n\t\t\t\t\tfor (const setting of section.settings) {\n\t\t\t\t\t\tthis._documents.push({\n\t\t\t\t\t\t\tkey: setting.key,\n\t\t\t\t\t\t\ttextChunks: [this.settingItemToEmbeddingString(setting)]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._settingsRecord[setting.key] = setting;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tfilterMatches: await this.getTfIdfItems(token),\n\t\t\texactMatch: false\n\t\t};\n\t}\n\n\tprivate async getTfIdfItems(token: CancellationToken): Promise<ISettingMatch[]> {\n\t\tconst filterMatches: ISettingMatch[] = [];\n\t\tconst tfIdfCalculator = new TfIdfCalculator();\n\t\ttfIdfCalculator.updateDocuments(this._documents);\n\t\tconst tfIdfRankings = tfIdfCalculator.calculateScores(this._filter, token);\n\t\ttfIdfRankings.sort((a, b) => b.score - a.score);\n\t\tconst maxScore = tfIdfRankings[0].score;\n\n\t\tif (maxScore < TfIdfSearchProvider.TF_IDF_PRE_NORMALIZE_THRESHOLD) {\n\t\t\t// Reject all the matches.\n\t\t\treturn [];\n\t\t}\n\n\t\tfor (const info of tfIdfRankings) {\n\t\t\tif (info.score / maxScore < TfIdfSearchProvider.TF_IDF_POST_NORMALIZE_THRESHOLD || filterMatches.length === TfIdfSearchProvider.TF_IDF_MAX_PICKS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst pick = info.key;\n\t\t\tfilterMatches.push({\n\t\t\t\tsetting: this._settingsRecord[pick],\n\t\t\t\tmatches: [this._settingsRecord[pick].range],\n\t\t\t\tmatchType: SettingMatchType.RemoteMatch,\n\t\t\t\tkeyMatchScore: 0,\n\t\t\t\tscore: info.score,\n\t\t\t\tproviderName: TF_IDF_SEARCH_PROVIDER_NAME\n\t\t\t});\n\t\t}\n\n\t\treturn filterMatches;\n\t}\n}\n\nclass RemoteSearchProvider implements IRemoteSearchProvider {\n\tprivate _tfIdfSearchProvider: TfIdfSearchProvider;\n\tprivate _filter: string = '';\n\n\tconstructor() {\n\t\tthis._tfIdfSearchProvider = new TfIdfSearchProvider();\n\t}\n\n\tsetFilter(filter: string): void {\n\t\tthis._filter = filter;\n\t\tthis._tfIdfSearchProvider.setFilter(filter);\n\t}\n\n\tasync searchModel(preferencesModel: ISettingsEditorModel, token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst results = await this._tfIdfSearchProvider.searchModel(preferencesModel, token);\n\t\treturn results;\n\t}\n}\n\nclass AiSearchProvider implements IAiSearchProvider {\n\tprivate readonly _embeddingsSearchProvider: EmbeddingsSearchProvider;\n\tprivate readonly _recordProvider: SettingsRecordProvider;\n\tprivate _filter: string = '';\n\n\tconstructor(\n\t\t@IAiSettingsSearchService private readonly aiSettingsSearchService: IAiSettingsSearchService\n\t) {\n\t\tthis._embeddingsSearchProvider = new EmbeddingsSearchProvider(this.aiSettingsSearchService, false);\n\t\tthis._recordProvider = new SettingsRecordProvider();\n\t}\n\n\tsetFilter(filter: string): void {\n\t\tthis._filter = filter;\n\t\tthis._embeddingsSearchProvider.setFilter(filter);\n\t}\n\n\tasync searchModel(preferencesModel: ISettingsEditorModel, token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter || !this.aiSettingsSearchService.isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis._recordProvider.updateModel(preferencesModel);\n\t\tconst results = await this._embeddingsSearchProvider.searchModel(preferencesModel, token);\n\t\treturn results;\n\t}\n\n\tasync getLLMRankedResults(token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter || !this.aiSettingsSearchService.isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst items = await this.getLLMRankedItems(token);\n\t\treturn {\n\t\t\tfilterMatches: items,\n\t\t\texactMatch: false\n\t\t};\n\t}\n\n\tprivate async getLLMRankedItems(token: CancellationToken): Promise<ISettingMatch[]> {\n\t\tconst settingsRecord = this._recordProvider.getSettingsRecord();\n\t\tconst filterMatches: ISettingMatch[] = [];\n\t\tconst settings = await this.aiSettingsSearchService.getLLMRankedResults(this._filter, token);\n\t\tif (!settings) {\n\t\t\treturn [];\n\t\t}\n\n\t\tfor (const settingKey of settings) {\n\t\t\tif (!settingsRecord[settingKey]) {\n\t\t\t\t// Non-existent setting.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfilterMatches.push({\n\t\t\t\tsetting: settingsRecord[settingKey],\n\t\t\t\tmatches: [settingsRecord[settingKey].range],\n\t\t\t\tmatchType: SettingMatchType.RemoteMatch,\n\t\t\t\tkeyMatchScore: 0,\n\t\t\t\tscore: 0, // the results are sorted upstream.\n\t\t\t\tproviderName: LLM_RANKED_SEARCH_PROVIDER_NAME\n\t\t\t});\n\t\t}\n\n\t\treturn filterMatches;\n\t}\n}\n\nregisterSingleton(IPreferencesSearchService, PreferencesSearchService, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IStringDictionary } from '../../../../base/common/collections.js';\nimport { IMatch, matchesBaseContiguousSubString, matchesContiguousSubString, matchesSubString, matchesWords } from '../../../../base/common/filters.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { TfIdfCalculator, TfIdfDocument } from '../../../../base/common/tfIdf.js';\nimport { IRange } from '../../../../editor/common/core/range.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IExtensionManagementService, ILocalExtension } from '../../../../platform/extensionManagement/common/extensionManagement.js';\nimport { ExtensionType } from '../../../../platform/extensions/common/extensions.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IAiSettingsSearchService } from '../../../services/aiSettingsSearch/common/aiSettingsSearch.js';\nimport { IWorkbenchExtensionEnablementService } from '../../../services/extensionManagement/common/extensionManagement.js';\nimport { IGroupFilter, ISearchResult, ISetting, ISettingMatch, ISettingMatcher, ISettingsEditorModel, ISettingsGroup, SettingKeyMatchTypes, SettingMatchType } from '../../../services/preferences/common/preferences.js';\nimport { nullRange } from '../../../services/preferences/common/preferencesModels.js';\nimport { EMBEDDINGS_ONLY_SEARCH_PROVIDER_NAME, EMBEDDINGS_SEARCH_PROVIDER_NAME, IAiSearchProvider, IPreferencesSearchService, IRemoteSearchProvider, ISearchProvider, IWorkbenchSettingsConfiguration, LLM_RANKED_SEARCH_PROVIDER_NAME, STRING_MATCH_SEARCH_PROVIDER_NAME, TF_IDF_SEARCH_PROVIDER_NAME } from '../common/preferences.js';\n\nexport interface IEndpointDetails {\n\turlBase?: string;\n\tkey?: string;\n}\n\nexport class PreferencesSearchService extends Disposable implements IPreferencesSearchService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\t// @ts-expect-error disable remote search for now, ref https://github.com/microsoft/vscode/issues/172411\n\tprivate _installedExtensions: Promise<ILocalExtension[]>;\n\tprivate _remoteSearchProvider: IRemoteSearchProvider | undefined;\n\tprivate _aiSearchProvider: IAiSearchProvider | undefined;\n\n\tconstructor(\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IExtensionManagementService private readonly extensionManagementService: IExtensionManagementService,\n\t\t@IWorkbenchExtensionEnablementService private readonly extensionEnablementService: IWorkbenchExtensionEnablementService\n\t) {\n\t\tsuper();\n\n\t\t// This request goes to the shared process but results won't change during a window's lifetime, so cache the results.\n\t\tthis._installedExtensions = this.extensionManagementService.getInstalled(ExtensionType.User).then(exts => {\n\t\t\t// Filter to enabled extensions that have settings\n\t\t\treturn exts\n\t\t\t\t.filter(ext => this.extensionEnablementService.isEnabled(ext))\n\t\t\t\t.filter(ext => ext.manifest && ext.manifest.contributes && ext.manifest.contributes.configuration)\n\t\t\t\t.filter(ext => !!ext.identifier.uuid);\n\t\t});\n\t}\n\n\tgetLocalSearchProvider(filter: string): LocalSearchProvider {\n\t\treturn this.instantiationService.createInstance(LocalSearchProvider, filter);\n\t}\n\n\tprivate get remoteSearchAllowed(): boolean {\n\t\tconst workbenchSettings = this.configurationService.getValue<IWorkbenchSettingsConfiguration>().workbench.settings;\n\t\treturn workbenchSettings.enableNaturalLanguageSearch;\n\t}\n\n\tgetRemoteSearchProvider(filter: string): IRemoteSearchProvider | undefined {\n\t\tif (!this.remoteSearchAllowed) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._remoteSearchProvider ??= this.instantiationService.createInstance(RemoteSearchProvider);\n\t\tthis._remoteSearchProvider.setFilter(filter);\n\t\treturn this._remoteSearchProvider;\n\t}\n\n\tgetAiSearchProvider(filter: string): IAiSearchProvider | undefined {\n\t\tif (!this.remoteSearchAllowed) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._aiSearchProvider ??= this.instantiationService.createInstance(AiSearchProvider);\n\t\tthis._aiSearchProvider.setFilter(filter);\n\t\treturn this._aiSearchProvider;\n\t}\n}\n\nfunction cleanFilter(filter: string): string {\n\t// Remove \" and : which are likely to be copypasted as part of a setting name.\n\t// Leave other special characters which the user might want to search for.\n\treturn filter\n\t\t.replace(/[\":]/g, ' ')\n\t\t.replace(/  /g, ' ')\n\t\t.trim();\n}\n\nexport class LocalSearchProvider implements ISearchProvider {\n\tconstructor(\n\t\tprivate _filter: string,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tthis._filter = cleanFilter(this._filter);\n\t}\n\n\tsearchModel(preferencesModel: ISettingsEditorModel, token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter) {\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\tconst settingMatcher: ISettingMatcher = (setting: ISetting) => {\n\t\t\tlet { matches, matchType, keyMatchScore } = new SettingMatches(\n\t\t\t\tthis._filter,\n\t\t\t\tsetting,\n\t\t\t\ttrue,\n\t\t\t\tthis.configurationService\n\t\t\t);\n\t\t\tif (matchType === SettingMatchType.None || matches.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (strings.equalsIgnoreCase(this._filter, setting.key)) {\n\t\t\t\tmatchType = SettingMatchType.ExactMatch;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tmatches,\n\t\t\t\tmatchType,\n\t\t\t\tkeyMatchScore,\n\t\t\t\tscore: 0 // only used for RemoteSearchProvider matches.\n\t\t\t};\n\t\t};\n\n\t\tconst filterMatches = preferencesModel.filterSettings(this._filter, this.getGroupFilter(this._filter), settingMatcher);\n\n\t\t// Check the top key match type.\n\t\tconst topKeyMatchType = Math.max(...filterMatches.map(m => (m.matchType & SettingKeyMatchTypes)));\n\t\t// Always allow description matches as part of https://github.com/microsoft/vscode/issues/239936.\n\t\tconst alwaysAllowedMatchTypes = SettingMatchType.DescriptionOrValueMatch | SettingMatchType.LanguageTagSettingMatch;\n\t\tconst filteredMatches = filterMatches\n\t\t\t.filter(m => (m.matchType & topKeyMatchType) || (m.matchType & alwaysAllowedMatchTypes) || m.matchType === SettingMatchType.ExactMatch)\n\t\t\t.map(m => ({ ...m, providerName: STRING_MATCH_SEARCH_PROVIDER_NAME }));\n\t\treturn Promise.resolve({\n\t\t\tfilterMatches: filteredMatches,\n\t\t\texactMatch: filteredMatches.some(m => m.matchType === SettingMatchType.ExactMatch)\n\t\t});\n\t}\n\n\tprivate getGroupFilter(filter: string): IGroupFilter {\n\t\tconst regex = strings.createRegExp(filter, false, { global: true });\n\t\treturn (group: ISettingsGroup) => {\n\t\t\treturn group.id !== 'defaultOverrides' && regex.test(group.title);\n\t\t};\n\t}\n}\n\nexport class SettingMatches {\n\treadonly matches: IRange[];\n\tmatchType: SettingMatchType = SettingMatchType.None;\n\t/**\n\t * A match score for key matches to allow comparing key matches against each other.\n\t * Otherwise, all key matches are treated the same, and sorting is done by ToC order.\n\t */\n\tkeyMatchScore: number = 0;\n\n\tconstructor(\n\t\tsearchString: string,\n\t\tsetting: ISetting,\n\t\tprivate searchDescription: boolean,\n\t\tprivate readonly configurationService: IConfigurationService\n\t) {\n\t\tthis.matches = distinct(this._findMatchesInSetting(searchString, setting), (match) => `${match.startLineNumber}_${match.startColumn}_${match.endLineNumber}_${match.endColumn}_`);\n\t}\n\n\tprivate _findMatchesInSetting(searchString: string, setting: ISetting): IRange[] {\n\t\tconst result = this._doFindMatchesInSetting(searchString, setting);\n\t\treturn result;\n\t}\n\n\tprivate _keyToLabel(settingId: string): string {\n\t\tconst label = settingId\n\t\t\t.replace(/[-._]/g, ' ')\n\t\t\t.replace(/([a-z]+)([A-Z])/g, '$1 $2')\n\t\t\t.replace(/([A-Za-z]+)(\\d+)/g, '$1 $2')\n\t\t\t.replace(/(\\d+)([A-Za-z]+)/g, '$1 $2')\n\t\t\t.toLowerCase();\n\t\treturn label;\n\t}\n\n\tprivate _toAlphaNumeric(s: string): string {\n\t\treturn s.replace(/[^\\p{L}\\p{N}]+/gu, '');\n\t}\n\n\tprivate _doFindMatchesInSetting(searchString: string, setting: ISetting): IRange[] {\n\t\tconst descriptionMatchingWords: Map<string, IRange[]> = new Map<string, IRange[]>();\n\t\tconst keyMatchingWords: Map<string, IRange[]> = new Map<string, IRange[]>();\n\t\tconst valueMatchingWords: Map<string, IRange[]> = new Map<string, IRange[]>();\n\n\t\t// Key (ID) search\n\t\t// First, search by the setting's ID and label.\n\t\tconst settingKeyAsWords: string = this._keyToLabel(setting.key);\n\t\tconst queryWords = new Set<string>(searchString.split(' '));\n\t\tfor (const word of queryWords) {\n\t\t\t// Check if the key contains the word. Use contiguous search.\n\t\t\tconst keyMatches = matchesWords(word, settingKeyAsWords, true);\n\t\t\tif (keyMatches?.length) {\n\t\t\t\tkeyMatchingWords.set(word, keyMatches.map(match => this.toKeyRange(setting, match)));\n\t\t\t}\n\t\t}\n\t\tif (keyMatchingWords.size === queryWords.size) {\n\t\t\t// All words in the query matched with something in the setting key.\n\t\t\t// Matches \"edit format on paste\" to \"editor.formatOnPaste\".\n\t\t\tthis.matchType |= SettingMatchType.AllWordsInSettingsLabel;\n\t\t} else if (keyMatchingWords.size >= 2) {\n\t\t\t// Matches \"edit paste\" to \"editor.formatOnPaste\".\n\t\t\t// The if statement reduces noise by preventing \"editor formatonpast\" from matching all editor settings.\n\t\t\tthis.matchType |= SettingMatchType.ContiguousWordsInSettingsLabel;\n\t\t\tthis.keyMatchScore = keyMatchingWords.size;\n\t\t}\n\t\tconst searchStringAlphaNumeric = this._toAlphaNumeric(searchString);\n\t\tconst keyAlphaNumeric = this._toAlphaNumeric(setting.key);\n\t\tconst keyIdMatches = matchesContiguousSubString(searchStringAlphaNumeric, keyAlphaNumeric);\n\t\tif (keyIdMatches?.length) {\n\t\t\t// Matches \"editorformatonp\" to \"editor.formatonpaste\".\n\t\t\tkeyMatchingWords.set(setting.key, keyIdMatches.map(match => this.toKeyRange(setting, match)));\n\t\t\tthis.matchType |= SettingMatchType.ContiguousQueryInSettingId;\n\t\t}\n\n\t\t// Fall back to non-contiguous key (ID) searches if nothing matched yet.\n\t\tif (this.matchType === SettingMatchType.None) {\n\t\t\tkeyMatchingWords.clear();\n\t\t\tfor (const word of queryWords) {\n\t\t\t\tconst keyMatches = matchesWords(word, settingKeyAsWords, false);\n\t\t\t\tif (keyMatches?.length) {\n\t\t\t\t\tkeyMatchingWords.set(word, keyMatches.map(match => this.toKeyRange(setting, match)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (keyMatchingWords.size >= 2 || (keyMatchingWords.size === 1 && queryWords.size === 1)) {\n\t\t\t\t// Matches \"edforonpas\" to \"editor.formatOnPaste\".\n\t\t\t\t// The if statement reduces noise by preventing \"editor fomonpast\" from matching all editor settings.\n\t\t\t\tthis.matchType |= SettingMatchType.NonContiguousWordsInSettingsLabel;\n\t\t\t\tthis.keyMatchScore = keyMatchingWords.size;\n\t\t\t} else {\n\t\t\t\tconst keyIdMatches = matchesSubString(searchStringAlphaNumeric, keyAlphaNumeric);\n\t\t\t\tif (keyIdMatches?.length) {\n\t\t\t\t\t// Matches \"edfmonpas\" to \"editor.formatOnPaste\".\n\t\t\t\t\tkeyMatchingWords.set(setting.key, keyIdMatches.map(match => this.toKeyRange(setting, match)));\n\t\t\t\t\tthis.matchType |= SettingMatchType.NonContiguousQueryInSettingId;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check if the match was for a language tag group setting such as [markdown].\n\t\t// In such a case, move that setting to be last.\n\t\tif (setting.overrides?.length && (this.matchType !== SettingMatchType.None)) {\n\t\t\tthis.matchType = SettingMatchType.LanguageTagSettingMatch;\n\t\t\tconst keyRanges = keyMatchingWords.size ?\n\t\t\t\tArray.from(keyMatchingWords.values()).flat() : [];\n\t\t\treturn [...keyRanges];\n\t\t}\n\n\t\t// Description search\n\t\t// Search the description if we found non-contiguous key matches at best.\n\t\tconst hasContiguousKeyMatchTypes = this.matchType >= SettingMatchType.ContiguousWordsInSettingsLabel;\n\t\tif (this.searchDescription && !hasContiguousKeyMatchTypes) {\n\t\t\tfor (const word of queryWords) {\n\t\t\t\t// Search the description lines.\n\t\t\t\tfor (let lineIndex = 0; lineIndex < setting.description.length; lineIndex++) {\n\t\t\t\t\tconst descriptionMatches = matchesBaseContiguousSubString(word, setting.description[lineIndex]);\n\t\t\t\t\tif (descriptionMatches?.length) {\n\t\t\t\t\t\tdescriptionMatchingWords.set(word, descriptionMatches.map(match => this.toDescriptionRange(setting, match, lineIndex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (descriptionMatchingWords.size === queryWords.size) {\n\t\t\t\tthis.matchType |= SettingMatchType.DescriptionOrValueMatch;\n\t\t\t} else {\n\t\t\t\t// Clear out the match for now. We want to require all words to match in the description.\n\t\t\t\tdescriptionMatchingWords.clear();\n\t\t\t}\n\t\t}\n\n\t\t// Value search\n\t\t// Check if the value contains all the words.\n\t\t// Search the values if we found non-contiguous key matches at best.\n\t\tif (!hasContiguousKeyMatchTypes) {\n\t\t\tif (setting.enum?.length) {\n\t\t\t\t// Search all string values of enums.\n\t\t\t\tfor (const option of setting.enum) {\n\t\t\t\t\tif (typeof option !== 'string') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvalueMatchingWords.clear();\n\t\t\t\t\tfor (const word of queryWords) {\n\t\t\t\t\t\tconst valueMatches = matchesContiguousSubString(word, option);\n\t\t\t\t\t\tif (valueMatches?.length) {\n\t\t\t\t\t\t\tvalueMatchingWords.set(word, valueMatches.map(match => this.toValueRange(setting, match)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueMatchingWords.size === queryWords.size) {\n\t\t\t\t\t\tthis.matchType |= SettingMatchType.DescriptionOrValueMatch;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Clear out the match for now. We want to require all words to match in the value.\n\t\t\t\t\t\tvalueMatchingWords.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Search single string value.\n\t\t\t\tconst settingValue = this.configurationService.getValue(setting.key);\n\t\t\t\tif (typeof settingValue === 'string') {\n\t\t\t\t\tfor (const word of queryWords) {\n\t\t\t\t\t\tconst valueMatches = matchesContiguousSubString(word, settingValue);\n\t\t\t\t\t\tif (valueMatches?.length) {\n\t\t\t\t\t\t\tvalueMatchingWords.set(word, valueMatches.map(match => this.toValueRange(setting, match)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueMatchingWords.size === queryWords.size) {\n\t\t\t\t\t\tthis.matchType |= SettingMatchType.DescriptionOrValueMatch;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Clear out the match for now. We want to require all words to match in the value.\n\t\t\t\t\t\tvalueMatchingWords.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst descriptionRanges = descriptionMatchingWords.size ?\n\t\t\tArray.from(descriptionMatchingWords.values()).flat() : [];\n\t\tconst keyRanges = keyMatchingWords.size ?\n\t\t\tArray.from(keyMatchingWords.values()).flat() : [];\n\t\tconst valueRanges = valueMatchingWords.size ?\n\t\t\tArray.from(valueMatchingWords.values()).flat() : [];\n\t\treturn [...descriptionRanges, ...keyRanges, ...valueRanges];\n\t}\n\n\tprivate toKeyRange(setting: ISetting, match: IMatch): IRange {\n\t\treturn {\n\t\t\tstartLineNumber: setting.keyRange.startLineNumber,\n\t\t\tstartColumn: setting.keyRange.startColumn + match.start,\n\t\t\tendLineNumber: setting.keyRange.startLineNumber,\n\t\t\tendColumn: setting.keyRange.startColumn + match.end\n\t\t};\n\t}\n\n\tprivate toDescriptionRange(setting: ISetting, match: IMatch, lineIndex: number): IRange {\n\t\tconst descriptionRange = setting.descriptionRanges[lineIndex];\n\t\tif (!descriptionRange) {\n\t\t\t// This case occurs with added settings such as the\n\t\t\t// manage extension setting.\n\t\t\treturn nullRange;\n\t\t}\n\t\treturn {\n\t\t\tstartLineNumber: descriptionRange.startLineNumber,\n\t\t\tstartColumn: descriptionRange.startColumn + match.start,\n\t\t\tendLineNumber: descriptionRange.endLineNumber,\n\t\t\tendColumn: descriptionRange.startColumn + match.end\n\t\t};\n\t}\n\n\tprivate toValueRange(setting: ISetting, match: IMatch): IRange {\n\t\treturn {\n\t\t\tstartLineNumber: setting.valueRange.startLineNumber,\n\t\t\tstartColumn: setting.valueRange.startColumn + match.start + 1,\n\t\t\tendLineNumber: setting.valueRange.startLineNumber,\n\t\t\tendColumn: setting.valueRange.startColumn + match.end + 1\n\t\t};\n\t}\n}\n\nclass SettingsRecordProvider {\n\tprivate _settingsRecord: IStringDictionary<ISetting> = {};\n\tprivate _currentPreferencesModel: ISettingsEditorModel | undefined;\n\n\tconstructor() { }\n\n\tupdateModel(preferencesModel: ISettingsEditorModel) {\n\t\tif (preferencesModel === this._currentPreferencesModel) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentPreferencesModel = preferencesModel;\n\t\tthis.refresh();\n\t}\n\n\tprivate refresh() {\n\t\tthis._settingsRecord = {};\n\n\t\tif (!this._currentPreferencesModel) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const group of this._currentPreferencesModel.settingsGroups) {\n\t\t\tif (group.id === 'mostCommonlyUsed') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (const section of group.sections) {\n\t\t\t\tfor (const setting of section.settings) {\n\t\t\t\t\tthis._settingsRecord[setting.key] = setting;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetSettingsRecord(): IStringDictionary<ISetting> {\n\t\treturn this._settingsRecord;\n\t}\n}\n\nclass EmbeddingsSearchProvider implements IRemoteSearchProvider {\n\tprivate static readonly EMBEDDINGS_SETTINGS_SEARCH_MAX_PICKS = 10;\n\n\tprivate readonly _recordProvider: SettingsRecordProvider;\n\tprivate _filter: string = '';\n\n\tconstructor(\n\t\tprivate readonly _aiSettingsSearchService: IAiSettingsSearchService,\n\t\tprivate readonly _excludeSelectionStep: boolean\n\t) {\n\t\tthis._recordProvider = new SettingsRecordProvider();\n\t}\n\n\tsetFilter(filter: string) {\n\t\tthis._filter = cleanFilter(filter);\n\t}\n\n\tasync searchModel(preferencesModel: ISettingsEditorModel, token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter || !this._aiSettingsSearchService.isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis._recordProvider.updateModel(preferencesModel);\n\t\tthis._aiSettingsSearchService.startSearch(this._filter, this._excludeSelectionStep, token);\n\n\t\treturn {\n\t\t\tfilterMatches: await this.getEmbeddingsItems(token),\n\t\t\texactMatch: false\n\t\t};\n\t}\n\n\tprivate async getEmbeddingsItems(token: CancellationToken): Promise<ISettingMatch[]> {\n\t\tconst settingsRecord = this._recordProvider.getSettingsRecord();\n\t\tconst filterMatches: ISettingMatch[] = [];\n\t\tconst settings = await this._aiSettingsSearchService.getEmbeddingsResults(this._filter, token);\n\t\tif (!settings) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst providerName = this._excludeSelectionStep ? EMBEDDINGS_ONLY_SEARCH_PROVIDER_NAME : EMBEDDINGS_SEARCH_PROVIDER_NAME;\n\t\tfor (const settingKey of settings) {\n\t\t\tif (filterMatches.length === EmbeddingsSearchProvider.EMBEDDINGS_SETTINGS_SEARCH_MAX_PICKS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfilterMatches.push({\n\t\t\t\tsetting: settingsRecord[settingKey],\n\t\t\t\tmatches: [settingsRecord[settingKey].range],\n\t\t\t\tmatchType: SettingMatchType.RemoteMatch,\n\t\t\t\tkeyMatchScore: 0,\n\t\t\t\tscore: 0, // the results are sorted upstream.\n\t\t\t\tproviderName\n\t\t\t});\n\t\t}\n\n\t\treturn filterMatches;\n\t}\n}\n\nclass TfIdfSearchProvider implements IRemoteSearchProvider {\n\tprivate static readonly TF_IDF_PRE_NORMALIZE_THRESHOLD = 50;\n\tprivate static readonly TF_IDF_POST_NORMALIZE_THRESHOLD = 0.7;\n\tprivate static readonly TF_IDF_MAX_PICKS = 5;\n\n\tprivate _currentPreferencesModel: ISettingsEditorModel | undefined;\n\tprivate _filter: string = '';\n\tprivate _documents: TfIdfDocument[] = [];\n\tprivate _settingsRecord: IStringDictionary<ISetting> = {};\n\n\tconstructor() {\n\t}\n\n\tsetFilter(filter: string) {\n\t\tthis._filter = cleanFilter(filter);\n\t}\n\n\tkeyToLabel(settingId: string): string {\n\t\tconst label = settingId\n\t\t\t.replace(/[-._]/g, ' ')\n\t\t\t.replace(/([a-z]+)([A-Z])/g, '$1 $2')\n\t\t\t.replace(/([A-Za-z]+)(\\d+)/g, '$1 $2')\n\t\t\t.replace(/(\\d+)([A-Za-z]+)/g, '$1 $2')\n\t\t\t.toLowerCase();\n\t\treturn label;\n\t}\n\n\tsettingItemToEmbeddingString(item: ISetting): string {\n\t\tlet result = `Setting Id: ${item.key}\\n`;\n\t\tresult += `Label: ${this.keyToLabel(item.key)}\\n`;\n\t\tresult += `Description: ${item.description}\\n`;\n\t\treturn result;\n\t}\n\n\tasync searchModel(preferencesModel: ISettingsEditorModel, token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this._currentPreferencesModel !== preferencesModel) {\n\t\t\t// Refresh the documents and settings record\n\t\t\tthis._currentPreferencesModel = preferencesModel;\n\t\t\tthis._documents = [];\n\t\t\tthis._settingsRecord = {};\n\t\t\tfor (const group of preferencesModel.settingsGroups) {\n\t\t\t\tif (group.id === 'mostCommonlyUsed') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (const section of group.sections) {\n\t\t\t\t\tfor (const setting of section.settings) {\n\t\t\t\t\t\tthis._documents.push({\n\t\t\t\t\t\t\tkey: setting.key,\n\t\t\t\t\t\t\ttextChunks: [this.settingItemToEmbeddingString(setting)]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._settingsRecord[setting.key] = setting;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tfilterMatches: await this.getTfIdfItems(token),\n\t\t\texactMatch: false\n\t\t};\n\t}\n\n\tprivate async getTfIdfItems(token: CancellationToken): Promise<ISettingMatch[]> {\n\t\tconst filterMatches: ISettingMatch[] = [];\n\t\tconst tfIdfCalculator = new TfIdfCalculator();\n\t\ttfIdfCalculator.updateDocuments(this._documents);\n\t\tconst tfIdfRankings = tfIdfCalculator.calculateScores(this._filter, token);\n\t\ttfIdfRankings.sort((a, b) => b.score - a.score);\n\t\tconst maxScore = tfIdfRankings[0].score;\n\n\t\tif (maxScore < TfIdfSearchProvider.TF_IDF_PRE_NORMALIZE_THRESHOLD) {\n\t\t\t// Reject all the matches.\n\t\t\treturn [];\n\t\t}\n\n\t\tfor (const info of tfIdfRankings) {\n\t\t\tif (info.score / maxScore < TfIdfSearchProvider.TF_IDF_POST_NORMALIZE_THRESHOLD || filterMatches.length === TfIdfSearchProvider.TF_IDF_MAX_PICKS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst pick = info.key;\n\t\t\tfilterMatches.push({\n\t\t\t\tsetting: this._settingsRecord[pick],\n\t\t\t\tmatches: [this._settingsRecord[pick].range],\n\t\t\t\tmatchType: SettingMatchType.RemoteMatch,\n\t\t\t\tkeyMatchScore: 0,\n\t\t\t\tscore: info.score,\n\t\t\t\tproviderName: TF_IDF_SEARCH_PROVIDER_NAME\n\t\t\t});\n\t\t}\n\n\t\treturn filterMatches;\n\t}\n}\n\nclass RemoteSearchProvider implements IRemoteSearchProvider {\n\tprivate _tfIdfSearchProvider: TfIdfSearchProvider;\n\tprivate _filter: string = '';\n\n\tconstructor() {\n\t\tthis._tfIdfSearchProvider = new TfIdfSearchProvider();\n\t}\n\n\tsetFilter(filter: string): void {\n\t\tthis._filter = filter;\n\t\tthis._tfIdfSearchProvider.setFilter(filter);\n\t}\n\n\tasync searchModel(preferencesModel: ISettingsEditorModel, token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst results = await this._tfIdfSearchProvider.searchModel(preferencesModel, token);\n\t\treturn results;\n\t}\n}\n\nclass AiSearchProvider implements IAiSearchProvider {\n\tprivate readonly _embeddingsSearchProvider: EmbeddingsSearchProvider;\n\tprivate readonly _recordProvider: SettingsRecordProvider;\n\tprivate _filter: string = '';\n\n\tconstructor(\n\t\t@IAiSettingsSearchService private readonly aiSettingsSearchService: IAiSettingsSearchService\n\t) {\n\t\tthis._embeddingsSearchProvider = new EmbeddingsSearchProvider(this.aiSettingsSearchService, false);\n\t\tthis._recordProvider = new SettingsRecordProvider();\n\t}\n\n\tsetFilter(filter: string): void {\n\t\tthis._filter = filter;\n\t\tthis._embeddingsSearchProvider.setFilter(filter);\n\t}\n\n\tasync searchModel(preferencesModel: ISettingsEditorModel, token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter || !this.aiSettingsSearchService.isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis._recordProvider.updateModel(preferencesModel);\n\t\tconst results = await this._embeddingsSearchProvider.searchModel(preferencesModel, token);\n\t\treturn results;\n\t}\n\n\tasync getLLMRankedResults(token: CancellationToken): Promise<ISearchResult | null> {\n\t\tif (!this._filter || !this.aiSettingsSearchService.isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst items = await this.getLLMRankedItems(token);\n\t\treturn {\n\t\t\tfilterMatches: items,\n\t\t\texactMatch: false\n\t\t};\n\t}\n\n\tprivate async getLLMRankedItems(token: CancellationToken): Promise<ISettingMatch[]> {\n\t\tconst settingsRecord = this._recordProvider.getSettingsRecord();\n\t\tconst filterMatches: ISettingMatch[] = [];\n\t\tconst settings = await this.aiSettingsSearchService.getLLMRankedResults(this._filter, token);\n\t\tif (!settings) {\n\t\t\treturn [];\n\t\t}\n\n\t\tfor (const settingKey of settings) {\n\t\t\tif (!settingsRecord[settingKey]) {\n\t\t\t\t// Non-existent setting.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfilterMatches.push({\n\t\t\t\tsetting: settingsRecord[settingKey],\n\t\t\t\tmatches: [settingsRecord[settingKey].range],\n\t\t\t\tmatchType: SettingMatchType.RemoteMatch,\n\t\t\t\tkeyMatchScore: 0,\n\t\t\t\tscore: 0, // the results are sorted upstream.\n\t\t\t\tproviderName: LLM_RANKED_SEARCH_PROVIDER_NAME\n\t\t\t});\n\t\t}\n\n\t\treturn filterMatches;\n\t}\n}\n\nregisterSingleton(IPreferencesSearchService, PreferencesSearchService, InstantiationType.Delayed);\n"]}