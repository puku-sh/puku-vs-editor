{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/common/promptSyntax/promptFileParser.ts","vs/workbench/contrib/chat/common/promptSyntax/promptFileParser.ts"],"names":[],"mappings":"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","file":"promptFileParser.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../../../base/common/iterator.js';\nimport { dirname, joinPath } from '../../../../../base/common/resources.js';\nimport { splitLinesIncludeSeparators } from '../../../../../base/common/strings.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { parse, YamlNode, YamlParseError, Position as YamlPosition } from '../../../../../base/common/yaml.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\n\nexport class PromptFileParser {\n\tconstructor() {\n\t}\n\n\tpublic parse(uri: URI, content: string): ParsedPromptFile {\n\t\tconst linesWithEOL = splitLinesIncludeSeparators(content);\n\t\tif (linesWithEOL.length === 0) {\n\t\t\treturn new ParsedPromptFile(uri, undefined, undefined);\n\t\t}\n\t\tlet header: PromptHeader | undefined = undefined;\n\t\tlet body: PromptBody | undefined = undefined;\n\t\tlet bodyStartLine = 0;\n\t\tif (linesWithEOL[0].match(/^---[\\s\\r\\n]*$/)) {\n\t\t\tlet headerEndLine = linesWithEOL.findIndex((line, index) => index > 0 && line.match(/^---[\\s\\r\\n]*$/));\n\t\t\tif (headerEndLine === -1) {\n\t\t\t\theaderEndLine = linesWithEOL.length;\n\t\t\t\tbodyStartLine = linesWithEOL.length;\n\t\t\t} else {\n\t\t\t\tbodyStartLine = headerEndLine + 1;\n\t\t\t}\n\t\t\t// range starts on the line after the ---, and ends at the beginning of the line that has the closing ---\n\t\t\tconst range = new Range(2, 1, headerEndLine + 1, 1);\n\t\t\theader = new PromptHeader(range, linesWithEOL);\n\t\t}\n\t\tif (bodyStartLine < linesWithEOL.length) {\n\t\t\t// range starts  on the line after the ---, and ends at the beginning of line after the last line\n\t\t\tconst range = new Range(bodyStartLine + 1, 1, linesWithEOL.length + 1, 1);\n\t\t\tbody = new PromptBody(range, linesWithEOL, uri);\n\t\t}\n\t\treturn new ParsedPromptFile(uri, header, body);\n\t}\n}\n\n\nexport class ParsedPromptFile {\n\tconstructor(public readonly uri: URI, public readonly header?: PromptHeader, public readonly body?: PromptBody) {\n\t}\n}\n\nexport interface ParseError {\n\treadonly message: string;\n\treadonly range: Range;\n\treadonly code: string;\n}\n\ninterface ParsedHeader {\n\treadonly node: YamlNode | undefined;\n\treadonly errors: ParseError[];\n\treadonly attributes: IHeaderAttribute[];\n}\n\nexport namespace PromptHeaderAttributes {\n\texport const name = 'name';\n\texport const description = 'description';\n\texport const agent = 'agent';\n\texport const mode = 'mode';\n\texport const model = 'model';\n\texport const applyTo = 'applyTo';\n\texport const tools = 'tools';\n\texport const handOffs = 'handoffs';\n\texport const advancedOptions = 'advancedOptions';\n\texport const argumentHint = 'argument-hint';\n\texport const excludeAgent = 'excludeAgent';\n\texport const target = 'target';\n}\n\nexport namespace GithubPromptHeaderAttributes {\n\texport const mcpServers = 'mcp-servers';\n}\n\nexport enum Target {\n\tVSCode = 'vscode',\n\tGitHubCopilot = 'github-copilot'\n}\n\nexport class PromptHeader {\n\tprivate _parsed: ParsedHeader | undefined;\n\n\tconstructor(public readonly range: Range, private readonly linesWithEOL: string[]) {\n\t}\n\n\tprivate get _parsedHeader(): ParsedHeader {\n\t\tif (this._parsed === undefined) {\n\t\t\tconst yamlErrors: YamlParseError[] = [];\n\t\t\tconst lines = this.linesWithEOL.slice(this.range.startLineNumber - 1, this.range.endLineNumber - 1).join('');\n\t\t\tconst node = parse(lines, yamlErrors);\n\t\t\tconst attributes = [];\n\t\t\tconst errors: ParseError[] = yamlErrors.map(err => ({ message: err.message, range: this.asRange(err), code: err.code }));\n\t\t\tif (node) {\n\t\t\t\tif (node.type !== 'object') {\n\t\t\t\t\terrors.push({ message: 'Invalid header, expecting <key: value> pairs', range: this.range, code: 'INVALID_YAML' });\n\t\t\t\t} else {\n\t\t\t\t\tfor (const property of node.properties) {\n\t\t\t\t\t\tattributes.push({\n\t\t\t\t\t\t\tkey: property.key.value,\n\t\t\t\t\t\t\trange: this.asRange({ start: property.key.start, end: property.value.end }),\n\t\t\t\t\t\t\tvalue: this.asValue(property.value)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._parsed = { node, attributes, errors };\n\t\t}\n\t\treturn this._parsed;\n\t}\n\n\tprivate asRange({ start, end }: { start: YamlPosition; end: YamlPosition }): Range {\n\t\treturn new Range(this.range.startLineNumber + start.line, start.character + 1, this.range.startLineNumber + end.line, end.character + 1);\n\t}\n\n\tprivate asValue(node: YamlNode): IValue {\n\t\tswitch (node.type) {\n\t\t\tcase 'string':\n\t\t\t\treturn { type: 'string', value: node.value, range: this.asRange(node) };\n\t\t\tcase 'number':\n\t\t\t\treturn { type: 'number', value: node.value, range: this.asRange(node) };\n\t\t\tcase 'boolean':\n\t\t\t\treturn { type: 'boolean', value: node.value, range: this.asRange(node) };\n\t\t\tcase 'null':\n\t\t\t\treturn { type: 'null', value: node.value, range: this.asRange(node) };\n\t\t\tcase 'array':\n\t\t\t\treturn { type: 'array', items: node.items.map(item => this.asValue(item)), range: this.asRange(node) };\n\t\t\tcase 'object': {\n\t\t\t\tconst properties = node.properties.map(property => ({ key: this.asValue(property.key) as IStringValue, value: this.asValue(property.value) }));\n\t\t\t\treturn { type: 'object', properties, range: this.asRange(node) };\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic get attributes(): IHeaderAttribute[] {\n\t\treturn this._parsedHeader.attributes;\n\t}\n\n\tpublic getAttribute(key: string): IHeaderAttribute | undefined {\n\t\treturn this._parsedHeader.attributes.find(attr => attr.key === key);\n\t}\n\n\tpublic get errors(): ParseError[] {\n\t\treturn this._parsedHeader.errors;\n\t}\n\n\tprivate getStringAttribute(key: string): string | undefined {\n\t\tconst attribute = this._parsedHeader.attributes.find(attr => attr.key === key);\n\t\tif (attribute?.value.type === 'string') {\n\t\t\treturn attribute.value.value;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic get name(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.name);\n\t}\n\n\tpublic get description(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.description);\n\t}\n\n\tpublic get agent(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.agent) ?? this.getStringAttribute(PromptHeaderAttributes.mode);\n\t}\n\n\tpublic get model(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.model);\n\t}\n\n\tpublic get applyTo(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.applyTo);\n\t}\n\n\tpublic get argumentHint(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.argumentHint);\n\t}\n\n\tpublic get target(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.target);\n\t}\n\n\tpublic get tools(): string[] | undefined {\n\t\tconst toolsAttribute = this._parsedHeader.attributes.find(attr => attr.key === PromptHeaderAttributes.tools);\n\t\tif (!toolsAttribute) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (toolsAttribute.value.type === 'array') {\n\t\t\tconst tools: string[] = [];\n\t\t\tfor (const item of toolsAttribute.value.items) {\n\t\t\t\tif (item.type === 'string' && item.value) {\n\t\t\t\t\ttools.push(item.value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tools;\n\t\t} else if (toolsAttribute.value.type === 'object') {\n\t\t\tconst tools: string[] = [];\n\t\t\tconst collectLeafs = ({ key, value }: { key: IStringValue; value: IValue }) => {\n\t\t\t\tif (value.type === 'boolean') {\n\t\t\t\t\ttools.push(key.value);\n\t\t\t\t} else if (value.type === 'object') {\n\t\t\t\t\tvalue.properties.forEach(collectLeafs);\n\t\t\t\t}\n\t\t\t};\n\t\t\ttoolsAttribute.value.properties.forEach(collectLeafs);\n\t\t\treturn tools;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic get handOffs(): IHandOff[] | undefined {\n\t\tconst handoffsAttribute = this._parsedHeader.attributes.find(attr => attr.key === PromptHeaderAttributes.handOffs);\n\t\tif (!handoffsAttribute) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (handoffsAttribute.value.type === 'array') {\n\t\t\t// Array format: list of objects: { agent, label, prompt, send? }\n\t\t\tconst handoffs: IHandOff[] = [];\n\t\t\tfor (const item of handoffsAttribute.value.items) {\n\t\t\t\tif (item.type === 'object') {\n\t\t\t\t\tlet agent: string | undefined;\n\t\t\t\t\tlet label: string | undefined;\n\t\t\t\t\tlet prompt: string | undefined;\n\t\t\t\t\tlet send: boolean | undefined;\n\t\t\t\t\tfor (const prop of item.properties) {\n\t\t\t\t\t\tif (prop.key.value === 'agent' && prop.value.type === 'string') {\n\t\t\t\t\t\t\tagent = prop.value.value;\n\t\t\t\t\t\t} else if (prop.key.value === 'label' && prop.value.type === 'string') {\n\t\t\t\t\t\t\tlabel = prop.value.value;\n\t\t\t\t\t\t} else if (prop.key.value === 'prompt' && prop.value.type === 'string') {\n\t\t\t\t\t\t\tprompt = prop.value.value;\n\t\t\t\t\t\t} else if (prop.key.value === 'send' && prop.value.type === 'boolean') {\n\t\t\t\t\t\t\tsend = prop.value.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (agent && label && prompt !== undefined) {\n\t\t\t\t\t\thandoffs.push({ agent, label, prompt, send });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn handoffs;\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport interface IHandOff { readonly agent: string; readonly label: string; readonly prompt: string; readonly send?: boolean }\n\nexport interface IHeaderAttribute {\n\treadonly range: Range;\n\treadonly key: string;\n\treadonly value: IValue;\n}\n\nexport interface IStringValue { readonly type: 'string'; readonly value: string; readonly range: Range }\nexport interface INumberValue { readonly type: 'number'; readonly value: number; readonly range: Range }\nexport interface INullValue { readonly type: 'null'; readonly value: null; readonly range: Range }\nexport interface IBooleanValue { readonly type: 'boolean'; readonly value: boolean; readonly range: Range }\n\nexport interface IArrayValue {\n\treadonly type: 'array';\n\treadonly items: readonly IValue[];\n\treadonly range: Range;\n}\n\nexport interface IObjectValue {\n\treadonly type: 'object';\n\treadonly properties: { key: IStringValue; value: IValue }[];\n\treadonly range: Range;\n}\n\nexport type IValue = IStringValue | INumberValue | IBooleanValue | IArrayValue | IObjectValue | INullValue;\n\n\ninterface ParsedBody {\n\treadonly fileReferences: readonly IBodyFileReference[];\n\treadonly variableReferences: readonly IBodyVariableReference[];\n\treadonly bodyOffset: number;\n}\n\nexport class PromptBody {\n\tprivate _parsed: ParsedBody | undefined;\n\n\tconstructor(public readonly range: Range, private readonly linesWithEOL: string[], public readonly uri: URI) {\n\t}\n\n\tpublic get fileReferences(): readonly IBodyFileReference[] {\n\t\treturn this.getParsedBody().fileReferences;\n\t}\n\n\tpublic get variableReferences(): readonly IBodyVariableReference[] {\n\t\treturn this.getParsedBody().variableReferences;\n\t}\n\n\tpublic get offset(): number {\n\t\treturn this.getParsedBody().bodyOffset;\n\t}\n\n\tprivate getParsedBody(): ParsedBody {\n\t\tif (this._parsed === undefined) {\n\t\t\tconst markdownLinkRanges: Range[] = [];\n\t\t\tconst fileReferences: IBodyFileReference[] = [];\n\t\t\tconst variableReferences: IBodyVariableReference[] = [];\n\t\t\tconst bodyOffset = Iterable.reduce(Iterable.slice(this.linesWithEOL, 0, this.range.startLineNumber - 1), (len, line) => line.length + len, 0);\n\t\t\tfor (let i = this.range.startLineNumber - 1, lineStartOffset = bodyOffset; i < this.range.endLineNumber - 1; i++) {\n\t\t\t\tconst line = this.linesWithEOL[i];\n\t\t\t\t// Match markdown links: [text](link)\n\t\t\t\tconst linkMatch = line.matchAll(/\\[(.*?)\\]\\((.+?)\\)/g);\n\t\t\t\tfor (const match of linkMatch) {\n\t\t\t\t\tconst linkEndOffset = match.index + match[0].length - 1; // before the parenthesis\n\t\t\t\t\tconst linkStartOffset = match.index + match[0].length - match[2].length - 1;\n\t\t\t\t\tconst range = new Range(i + 1, linkStartOffset + 1, i + 1, linkEndOffset + 1);\n\t\t\t\t\tfileReferences.push({ content: match[2], range, isMarkdownLink: true });\n\t\t\t\t\tmarkdownLinkRanges.push(new Range(i + 1, match.index + 1, i + 1, match.index + match[0].length + 1));\n\t\t\t\t}\n\t\t\t\t// Match #file:<filePath> and #tool:<toolName>\n\t\t\t\t// Regarding the <toolName> pattern below, see also the variableReg regex in chatRequestParser.ts.\n\t\t\t\tconst reg = /#file:(?<filePath>[^\\s#]+)|#tool:(?<toolName>[\\w_\\-\\.\\/]+)/gi;\n\t\t\t\tconst matches = line.matchAll(reg);\n\t\t\t\tfor (const match of matches) {\n\t\t\t\t\tconst fullMatch = match[0];\n\t\t\t\t\tconst fullRange = new Range(i + 1, match.index + 1, i + 1, match.index + fullMatch.length + 1);\n\t\t\t\t\tif (markdownLinkRanges.some(mdRange => Range.areIntersectingOrTouching(mdRange, fullRange))) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst contentMatch = match.groups?.['filePath'] || match.groups?.['toolName'];\n\t\t\t\t\tif (!contentMatch) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst startOffset = match.index + fullMatch.length - contentMatch.length;\n\t\t\t\t\tconst endOffset = match.index + fullMatch.length;\n\t\t\t\t\tconst range = new Range(i + 1, startOffset + 1, i + 1, endOffset + 1);\n\t\t\t\t\tif (match.groups?.['filePath']) {\n\t\t\t\t\t\tfileReferences.push({ content: match.groups?.['filePath'], range, isMarkdownLink: false });\n\t\t\t\t\t} else if (match.groups?.['toolName']) {\n\t\t\t\t\t\tvariableReferences.push({ name: match.groups?.['toolName'], range, offset: lineStartOffset + match.index });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlineStartOffset += line.length;\n\t\t\t}\n\t\t\tthis._parsed = { fileReferences: fileReferences.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range)), variableReferences, bodyOffset };\n\t\t}\n\t\treturn this._parsed;\n\t}\n\n\tpublic getContent(): string {\n\t\treturn this.linesWithEOL.slice(this.range.startLineNumber - 1, this.range.endLineNumber - 1).join('');\n\t}\n\n\tpublic resolveFilePath(path: string): URI | undefined {\n\t\ttry {\n\t\t\tif (path.startsWith('/')) {\n\t\t\t\treturn this.uri.with({ path });\n\t\t\t} else if (path.match(/^[a-zA-Z]+:\\//)) {\n\t\t\t\treturn URI.parse(path);\n\t\t\t} else {\n\t\t\t\tconst dirName = dirname(this.uri);\n\t\t\t\treturn joinPath(dirName, path);\n\t\t\t}\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nexport interface IBodyFileReference {\n\treadonly content: string;\n\treadonly range: Range;\n\treadonly isMarkdownLink: boolean;\n}\n\nexport interface IBodyVariableReference {\n\treadonly name: string;\n\treadonly range: Range;\n\treadonly offset: number;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../../../base/common/iterator.js';\nimport { dirname, joinPath } from '../../../../../base/common/resources.js';\nimport { splitLinesIncludeSeparators } from '../../../../../base/common/strings.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { parse, YamlNode, YamlParseError, Position as YamlPosition } from '../../../../../base/common/yaml.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\n\nexport class PromptFileParser {\n\tconstructor() {\n\t}\n\n\tpublic parse(uri: URI, content: string): ParsedPromptFile {\n\t\tconst linesWithEOL = splitLinesIncludeSeparators(content);\n\t\tif (linesWithEOL.length === 0) {\n\t\t\treturn new ParsedPromptFile(uri, undefined, undefined);\n\t\t}\n\t\tlet header: PromptHeader | undefined = undefined;\n\t\tlet body: PromptBody | undefined = undefined;\n\t\tlet bodyStartLine = 0;\n\t\tif (linesWithEOL[0].match(/^---[\\s\\r\\n]*$/)) {\n\t\t\tlet headerEndLine = linesWithEOL.findIndex((line, index) => index > 0 && line.match(/^---[\\s\\r\\n]*$/));\n\t\t\tif (headerEndLine === -1) {\n\t\t\t\theaderEndLine = linesWithEOL.length;\n\t\t\t\tbodyStartLine = linesWithEOL.length;\n\t\t\t} else {\n\t\t\t\tbodyStartLine = headerEndLine + 1;\n\t\t\t}\n\t\t\t// range starts on the line after the ---, and ends at the beginning of the line that has the closing ---\n\t\t\tconst range = new Range(2, 1, headerEndLine + 1, 1);\n\t\t\theader = new PromptHeader(range, linesWithEOL);\n\t\t}\n\t\tif (bodyStartLine < linesWithEOL.length) {\n\t\t\t// range starts  on the line after the ---, and ends at the beginning of line after the last line\n\t\t\tconst range = new Range(bodyStartLine + 1, 1, linesWithEOL.length + 1, 1);\n\t\t\tbody = new PromptBody(range, linesWithEOL, uri);\n\t\t}\n\t\treturn new ParsedPromptFile(uri, header, body);\n\t}\n}\n\n\nexport class ParsedPromptFile {\n\tconstructor(public readonly uri: URI, public readonly header?: PromptHeader, public readonly body?: PromptBody) {\n\t}\n}\n\nexport interface ParseError {\n\treadonly message: string;\n\treadonly range: Range;\n\treadonly code: string;\n}\n\ninterface ParsedHeader {\n\treadonly node: YamlNode | undefined;\n\treadonly errors: ParseError[];\n\treadonly attributes: IHeaderAttribute[];\n}\n\nexport namespace PromptHeaderAttributes {\n\texport const name = 'name';\n\texport const description = 'description';\n\texport const agent = 'agent';\n\texport const mode = 'mode';\n\texport const model = 'model';\n\texport const applyTo = 'applyTo';\n\texport const tools = 'tools';\n\texport const handOffs = 'handoffs';\n\texport const advancedOptions = 'advancedOptions';\n\texport const argumentHint = 'argument-hint';\n\texport const excludeAgent = 'excludeAgent';\n\texport const target = 'target';\n}\n\nexport namespace GithubPromptHeaderAttributes {\n\texport const mcpServers = 'mcp-servers';\n}\n\nexport enum Target {\n\tVSCode = 'vscode',\n\tGitHubCopilot = 'github-copilot'\n}\n\nexport class PromptHeader {\n\tprivate _parsed: ParsedHeader | undefined;\n\n\tconstructor(public readonly range: Range, private readonly linesWithEOL: string[]) {\n\t}\n\n\tprivate get _parsedHeader(): ParsedHeader {\n\t\tif (this._parsed === undefined) {\n\t\t\tconst yamlErrors: YamlParseError[] = [];\n\t\t\tconst lines = this.linesWithEOL.slice(this.range.startLineNumber - 1, this.range.endLineNumber - 1).join('');\n\t\t\tconst node = parse(lines, yamlErrors);\n\t\t\tconst attributes = [];\n\t\t\tconst errors: ParseError[] = yamlErrors.map(err => ({ message: err.message, range: this.asRange(err), code: err.code }));\n\t\t\tif (node) {\n\t\t\t\tif (node.type !== 'object') {\n\t\t\t\t\terrors.push({ message: 'Invalid header, expecting <key: value> pairs', range: this.range, code: 'INVALID_YAML' });\n\t\t\t\t} else {\n\t\t\t\t\tfor (const property of node.properties) {\n\t\t\t\t\t\tattributes.push({\n\t\t\t\t\t\t\tkey: property.key.value,\n\t\t\t\t\t\t\trange: this.asRange({ start: property.key.start, end: property.value.end }),\n\t\t\t\t\t\t\tvalue: this.asValue(property.value)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._parsed = { node, attributes, errors };\n\t\t}\n\t\treturn this._parsed;\n\t}\n\n\tprivate asRange({ start, end }: { start: YamlPosition; end: YamlPosition }): Range {\n\t\treturn new Range(this.range.startLineNumber + start.line, start.character + 1, this.range.startLineNumber + end.line, end.character + 1);\n\t}\n\n\tprivate asValue(node: YamlNode): IValue {\n\t\tswitch (node.type) {\n\t\t\tcase 'string':\n\t\t\t\treturn { type: 'string', value: node.value, range: this.asRange(node) };\n\t\t\tcase 'number':\n\t\t\t\treturn { type: 'number', value: node.value, range: this.asRange(node) };\n\t\t\tcase 'boolean':\n\t\t\t\treturn { type: 'boolean', value: node.value, range: this.asRange(node) };\n\t\t\tcase 'null':\n\t\t\t\treturn { type: 'null', value: node.value, range: this.asRange(node) };\n\t\t\tcase 'array':\n\t\t\t\treturn { type: 'array', items: node.items.map(item => this.asValue(item)), range: this.asRange(node) };\n\t\t\tcase 'object': {\n\t\t\t\tconst properties = node.properties.map(property => ({ key: this.asValue(property.key) as IStringValue, value: this.asValue(property.value) }));\n\t\t\t\treturn { type: 'object', properties, range: this.asRange(node) };\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic get attributes(): IHeaderAttribute[] {\n\t\treturn this._parsedHeader.attributes;\n\t}\n\n\tpublic getAttribute(key: string): IHeaderAttribute | undefined {\n\t\treturn this._parsedHeader.attributes.find(attr => attr.key === key);\n\t}\n\n\tpublic get errors(): ParseError[] {\n\t\treturn this._parsedHeader.errors;\n\t}\n\n\tprivate getStringAttribute(key: string): string | undefined {\n\t\tconst attribute = this._parsedHeader.attributes.find(attr => attr.key === key);\n\t\tif (attribute?.value.type === 'string') {\n\t\t\treturn attribute.value.value;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic get name(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.name);\n\t}\n\n\tpublic get description(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.description);\n\t}\n\n\tpublic get agent(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.agent) ?? this.getStringAttribute(PromptHeaderAttributes.mode);\n\t}\n\n\tpublic get model(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.model);\n\t}\n\n\tpublic get applyTo(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.applyTo);\n\t}\n\n\tpublic get argumentHint(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.argumentHint);\n\t}\n\n\tpublic get target(): string | undefined {\n\t\treturn this.getStringAttribute(PromptHeaderAttributes.target);\n\t}\n\n\tpublic get tools(): string[] | undefined {\n\t\tconst toolsAttribute = this._parsedHeader.attributes.find(attr => attr.key === PromptHeaderAttributes.tools);\n\t\tif (!toolsAttribute) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (toolsAttribute.value.type === 'array') {\n\t\t\tconst tools: string[] = [];\n\t\t\tfor (const item of toolsAttribute.value.items) {\n\t\t\t\tif (item.type === 'string' && item.value) {\n\t\t\t\t\ttools.push(item.value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tools;\n\t\t} else if (toolsAttribute.value.type === 'object') {\n\t\t\tconst tools: string[] = [];\n\t\t\tconst collectLeafs = ({ key, value }: { key: IStringValue; value: IValue }) => {\n\t\t\t\tif (value.type === 'boolean') {\n\t\t\t\t\ttools.push(key.value);\n\t\t\t\t} else if (value.type === 'object') {\n\t\t\t\t\tvalue.properties.forEach(collectLeafs);\n\t\t\t\t}\n\t\t\t};\n\t\t\ttoolsAttribute.value.properties.forEach(collectLeafs);\n\t\t\treturn tools;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic get handOffs(): IHandOff[] | undefined {\n\t\tconst handoffsAttribute = this._parsedHeader.attributes.find(attr => attr.key === PromptHeaderAttributes.handOffs);\n\t\tif (!handoffsAttribute) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (handoffsAttribute.value.type === 'array') {\n\t\t\t// Array format: list of objects: { agent, label, prompt, send? }\n\t\t\tconst handoffs: IHandOff[] = [];\n\t\t\tfor (const item of handoffsAttribute.value.items) {\n\t\t\t\tif (item.type === 'object') {\n\t\t\t\t\tlet agent: string | undefined;\n\t\t\t\t\tlet label: string | undefined;\n\t\t\t\t\tlet prompt: string | undefined;\n\t\t\t\t\tlet send: boolean | undefined;\n\t\t\t\t\tfor (const prop of item.properties) {\n\t\t\t\t\t\tif (prop.key.value === 'agent' && prop.value.type === 'string') {\n\t\t\t\t\t\t\tagent = prop.value.value;\n\t\t\t\t\t\t} else if (prop.key.value === 'label' && prop.value.type === 'string') {\n\t\t\t\t\t\t\tlabel = prop.value.value;\n\t\t\t\t\t\t} else if (prop.key.value === 'prompt' && prop.value.type === 'string') {\n\t\t\t\t\t\t\tprompt = prop.value.value;\n\t\t\t\t\t\t} else if (prop.key.value === 'send' && prop.value.type === 'boolean') {\n\t\t\t\t\t\t\tsend = prop.value.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (agent && label && prompt !== undefined) {\n\t\t\t\t\t\thandoffs.push({ agent, label, prompt, send });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn handoffs;\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport interface IHandOff { readonly agent: string; readonly label: string; readonly prompt: string; readonly send?: boolean }\n\nexport interface IHeaderAttribute {\n\treadonly range: Range;\n\treadonly key: string;\n\treadonly value: IValue;\n}\n\nexport interface IStringValue { readonly type: 'string'; readonly value: string; readonly range: Range }\nexport interface INumberValue { readonly type: 'number'; readonly value: number; readonly range: Range }\nexport interface INullValue { readonly type: 'null'; readonly value: null; readonly range: Range }\nexport interface IBooleanValue { readonly type: 'boolean'; readonly value: boolean; readonly range: Range }\n\nexport interface IArrayValue {\n\treadonly type: 'array';\n\treadonly items: readonly IValue[];\n\treadonly range: Range;\n}\n\nexport interface IObjectValue {\n\treadonly type: 'object';\n\treadonly properties: { key: IStringValue; value: IValue }[];\n\treadonly range: Range;\n}\n\nexport type IValue = IStringValue | INumberValue | IBooleanValue | IArrayValue | IObjectValue | INullValue;\n\n\ninterface ParsedBody {\n\treadonly fileReferences: readonly IBodyFileReference[];\n\treadonly variableReferences: readonly IBodyVariableReference[];\n\treadonly bodyOffset: number;\n}\n\nexport class PromptBody {\n\tprivate _parsed: ParsedBody | undefined;\n\n\tconstructor(public readonly range: Range, private readonly linesWithEOL: string[], public readonly uri: URI) {\n\t}\n\n\tpublic get fileReferences(): readonly IBodyFileReference[] {\n\t\treturn this.getParsedBody().fileReferences;\n\t}\n\n\tpublic get variableReferences(): readonly IBodyVariableReference[] {\n\t\treturn this.getParsedBody().variableReferences;\n\t}\n\n\tpublic get offset(): number {\n\t\treturn this.getParsedBody().bodyOffset;\n\t}\n\n\tprivate getParsedBody(): ParsedBody {\n\t\tif (this._parsed === undefined) {\n\t\t\tconst markdownLinkRanges: Range[] = [];\n\t\t\tconst fileReferences: IBodyFileReference[] = [];\n\t\t\tconst variableReferences: IBodyVariableReference[] = [];\n\t\t\tconst bodyOffset = Iterable.reduce(Iterable.slice(this.linesWithEOL, 0, this.range.startLineNumber - 1), (len, line) => line.length + len, 0);\n\t\t\tfor (let i = this.range.startLineNumber - 1, lineStartOffset = bodyOffset; i < this.range.endLineNumber - 1; i++) {\n\t\t\t\tconst line = this.linesWithEOL[i];\n\t\t\t\t// Match markdown links: [text](link)\n\t\t\t\tconst linkMatch = line.matchAll(/\\[(.*?)\\]\\((.+?)\\)/g);\n\t\t\t\tfor (const match of linkMatch) {\n\t\t\t\t\tconst linkEndOffset = match.index + match[0].length - 1; // before the parenthesis\n\t\t\t\t\tconst linkStartOffset = match.index + match[0].length - match[2].length - 1;\n\t\t\t\t\tconst range = new Range(i + 1, linkStartOffset + 1, i + 1, linkEndOffset + 1);\n\t\t\t\t\tfileReferences.push({ content: match[2], range, isMarkdownLink: true });\n\t\t\t\t\tmarkdownLinkRanges.push(new Range(i + 1, match.index + 1, i + 1, match.index + match[0].length + 1));\n\t\t\t\t}\n\t\t\t\t// Match #file:<filePath> and #tool:<toolName>\n\t\t\t\t// Regarding the <toolName> pattern below, see also the variableReg regex in chatRequestParser.ts.\n\t\t\t\tconst reg = /#file:(?<filePath>[^\\s#]+)|#tool:(?<toolName>[\\w_\\-\\.\\/]+)/gi;\n\t\t\t\tconst matches = line.matchAll(reg);\n\t\t\t\tfor (const match of matches) {\n\t\t\t\t\tconst fullMatch = match[0];\n\t\t\t\t\tconst fullRange = new Range(i + 1, match.index + 1, i + 1, match.index + fullMatch.length + 1);\n\t\t\t\t\tif (markdownLinkRanges.some(mdRange => Range.areIntersectingOrTouching(mdRange, fullRange))) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst contentMatch = match.groups?.['filePath'] || match.groups?.['toolName'];\n\t\t\t\t\tif (!contentMatch) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst startOffset = match.index + fullMatch.length - contentMatch.length;\n\t\t\t\t\tconst endOffset = match.index + fullMatch.length;\n\t\t\t\t\tconst range = new Range(i + 1, startOffset + 1, i + 1, endOffset + 1);\n\t\t\t\t\tif (match.groups?.['filePath']) {\n\t\t\t\t\t\tfileReferences.push({ content: match.groups?.['filePath'], range, isMarkdownLink: false });\n\t\t\t\t\t} else if (match.groups?.['toolName']) {\n\t\t\t\t\t\tvariableReferences.push({ name: match.groups?.['toolName'], range, offset: lineStartOffset + match.index });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlineStartOffset += line.length;\n\t\t\t}\n\t\t\tthis._parsed = { fileReferences: fileReferences.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range)), variableReferences, bodyOffset };\n\t\t}\n\t\treturn this._parsed;\n\t}\n\n\tpublic getContent(): string {\n\t\treturn this.linesWithEOL.slice(this.range.startLineNumber - 1, this.range.endLineNumber - 1).join('');\n\t}\n\n\tpublic resolveFilePath(path: string): URI | undefined {\n\t\ttry {\n\t\t\tif (path.startsWith('/')) {\n\t\t\t\treturn this.uri.with({ path });\n\t\t\t} else if (path.match(/^[a-zA-Z]+:\\//)) {\n\t\t\t\treturn URI.parse(path);\n\t\t\t} else {\n\t\t\t\tconst dirName = dirname(this.uri);\n\t\t\t\treturn joinPath(dirName, path);\n\t\t\t}\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nexport interface IBodyFileReference {\n\treadonly content: string;\n\treadonly range: Range;\n\treadonly isMarkdownLink: boolean;\n}\n\nexport interface IBodyVariableReference {\n\treadonly name: string;\n\treadonly range: Range;\n\treadonly offset: number;\n}\n"]}