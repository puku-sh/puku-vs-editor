{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/common/tools/promptTsxTypes.ts","vs/workbench/contrib/chat/common/tools/promptTsxTypes.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AA+ChG,MAAM,UAAU,0BAA0B,CAAC,OAA0B;IACpE,MAAM,IAAI,GAAa,EAAE,CAAC;IAC1B,uBAAuB,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IAC5C,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACtB,CAAC;AAED,SAAS,uBAAuB,CAAC,IAAoB,EAAE,IAAc;IACpE,IAAI,IAAI,CAAC,IAAI,gCAAwB,EAAE,CAAC;QACvC,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;YAC1B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACjB,CAAC;QAED,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;YACnC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtB,CAAC;IACF,CAAC;SAAM,IAAI,IAAI,CAAC,IAAI,2CAAmC,EAAE,CAAC;QACzD,iDAAiD;QACjD,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IACtB,CAAC;SAAM,IAAI,IAAI,CAAC,IAAI,0CAAkC,IAAI,IAAI,CAAC,IAAI,gCAAwB,EAAE,CAAC;QAC7F,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACnC,uBAAuB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QACtC,CAAC;IACF,CAAC;AACF,CAAC","file":"promptTsxTypes.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * This is a subset of the types export from jsonTypes.d.ts in @vscode/prompt-tsx.\n * It's just the types needed to stringify prompt-tsx tool results.\n * It should be kept in sync with the types in that file.\n */\n\nexport declare const enum PromptNodeType {\n\tPiece = 1,\n\tText = 2\n}\nexport interface TextJSON {\n\ttype: PromptNodeType.Text;\n\ttext: string;\n\tlineBreakBefore: boolean | undefined;\n}\n/**\n * Constructor kind of the node represented by {@link PieceJSON}. This is\n * less descriptive than the actual constructor, as we only care to preserve\n * the element data that the renderer cares about.\n */\nexport declare const enum PieceCtorKind {\n\tBaseChatMessage = 1,\n\tOther = 2,\n\tImageChatMessage = 3\n}\nexport interface BasePieceJSON {\n\ttype: PromptNodeType.Piece;\n\tctor: PieceCtorKind.BaseChatMessage | PieceCtorKind.Other;\n\tchildren: PromptNodeJSON[];\n}\nexport interface ImageChatMessagePieceJSON {\n\ttype: PromptNodeType.Piece;\n\tctor: PieceCtorKind.ImageChatMessage;\n\tchildren: PromptNodeJSON[];\n\tprops: {\n\t\tsrc: string;\n\t\tdetail?: 'low' | 'high';\n\t};\n}\nexport type PieceJSON = BasePieceJSON | ImageChatMessagePieceJSON;\nexport type PromptNodeJSON = PieceJSON | TextJSON;\nexport interface PromptElementJSON {\n\tnode: PieceJSON;\n}\n\nexport function stringifyPromptElementJSON(element: PromptElementJSON): string {\n\tconst strs: string[] = [];\n\tstringifyPromptNodeJSON(element.node, strs);\n\treturn strs.join('');\n}\n\nfunction stringifyPromptNodeJSON(node: PromptNodeJSON, strs: string[]): void {\n\tif (node.type === PromptNodeType.Text) {\n\t\tif (node.lineBreakBefore) {\n\t\t\tstrs.push('\\n');\n\t\t}\n\n\t\tif (typeof node.text === 'string') {\n\t\t\tstrs.push(node.text);\n\t\t}\n\t} else if (node.ctor === PieceCtorKind.ImageChatMessage) {\n\t\t// This case currently can't be hit by prompt-tsx\n\t\tstrs.push('<image>');\n\t} else if (node.ctor === PieceCtorKind.BaseChatMessage || node.ctor === PieceCtorKind.Other) {\n\t\tfor (const child of node.children) {\n\t\t\tstringifyPromptNodeJSON(child, strs);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * This is a subset of the types export from jsonTypes.d.ts in @vscode/prompt-tsx.\n * It's just the types needed to stringify prompt-tsx tool results.\n * It should be kept in sync with the types in that file.\n */\n\nexport declare const enum PromptNodeType {\n\tPiece = 1,\n\tText = 2\n}\nexport interface TextJSON {\n\ttype: PromptNodeType.Text;\n\ttext: string;\n\tlineBreakBefore: boolean | undefined;\n}\n/**\n * Constructor kind of the node represented by {@link PieceJSON}. This is\n * less descriptive than the actual constructor, as we only care to preserve\n * the element data that the renderer cares about.\n */\nexport declare const enum PieceCtorKind {\n\tBaseChatMessage = 1,\n\tOther = 2,\n\tImageChatMessage = 3\n}\nexport interface BasePieceJSON {\n\ttype: PromptNodeType.Piece;\n\tctor: PieceCtorKind.BaseChatMessage | PieceCtorKind.Other;\n\tchildren: PromptNodeJSON[];\n}\nexport interface ImageChatMessagePieceJSON {\n\ttype: PromptNodeType.Piece;\n\tctor: PieceCtorKind.ImageChatMessage;\n\tchildren: PromptNodeJSON[];\n\tprops: {\n\t\tsrc: string;\n\t\tdetail?: 'low' | 'high';\n\t};\n}\nexport type PieceJSON = BasePieceJSON | ImageChatMessagePieceJSON;\nexport type PromptNodeJSON = PieceJSON | TextJSON;\nexport interface PromptElementJSON {\n\tnode: PieceJSON;\n}\n\nexport function stringifyPromptElementJSON(element: PromptElementJSON): string {\n\tconst strs: string[] = [];\n\tstringifyPromptNodeJSON(element.node, strs);\n\treturn strs.join('');\n}\n\nfunction stringifyPromptNodeJSON(node: PromptNodeJSON, strs: string[]): void {\n\tif (node.type === PromptNodeType.Text) {\n\t\tif (node.lineBreakBefore) {\n\t\t\tstrs.push('\\n');\n\t\t}\n\n\t\tif (typeof node.text === 'string') {\n\t\t\tstrs.push(node.text);\n\t\t}\n\t} else if (node.ctor === PieceCtorKind.ImageChatMessage) {\n\t\t// This case currently can't be hit by prompt-tsx\n\t\tstrs.push('<image>');\n\t} else if (node.ctor === PieceCtorKind.BaseChatMessage || node.ctor === PieceCtorKind.Other) {\n\t\tfor (const child of node.children) {\n\t\t\tstringifyPromptNodeJSON(child, strs);\n\t\t}\n\t}\n}\n"]}