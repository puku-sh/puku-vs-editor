{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/common/chatAgents.ts","vs/workbench/contrib/chat/common/chatAgents.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;AAEhG,OAAO,EAAE,QAAQ,EAAE,MAAM,uCAAuC,CAAC;AACjE,OAAO,EAAE,OAAO,EAAE,MAAM,kCAAkC,CAAC;AAC3D,OAAO,EAAE,iBAAiB,EAAE,MAAM,yCAAyC,CAAC;AAC5E,OAAO,EAAE,OAAO,EAAS,MAAM,kCAAkC,CAAC;AAElE,OAAO,EAAE,QAAQ,EAAE,MAAM,qCAAqC,CAAC;AAC/D,OAAO,EAAE,UAAU,EAAe,YAAY,EAAE,MAAM,sCAAsC,CAAC;AAC7F,OAAO,EAAE,MAAM,EAAW,MAAM,wCAAwC,CAAC;AACzE,OAAO,EAAe,eAAe,EAAE,MAAM,uCAAuC,CAAC;AACrF,OAAO,EAAE,gBAAgB,EAAE,MAAM,oCAAoC,CAAC;AAItE,OAAO,EAAE,qBAAqB,EAAE,MAAM,4DAA4D,CAAC;AACnG,OAAO,EAAE,cAAc,EAAe,kBAAkB,EAAE,MAAM,sDAAsD,CAAC;AACvH,OAAO,EAAE,mBAAmB,EAAE,MAAM,sDAAsD,CAAC;AAC3F,OAAO,EAAE,eAAe,EAAE,MAAM,4DAA4D,CAAC;AAC7F,OAAO,EAAE,WAAW,EAAE,MAAM,wCAAwC,CAAC;AACrE,OAAO,EAAE,eAAe,EAAE,MAAM,uDAAuD,CAAC;AACxF,OAAO,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM,gDAAgD,CAAC;AACzF,OAAO,EAAE,eAAe,EAA+B,MAAM,gDAAgD,CAAC;AAC9G,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAC;AAIvD,OAAO,EAAE,iBAAiB,EAAE,iBAAiB,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAmJpF,MAAM,CAAC,MAAM,iBAAiB,GAAG,eAAe,CAAoB,kBAAkB,CAAC,CAAC;AAuDjF,IAAM,gBAAgB,GAAtB,MAAM,gBAAiB,SAAQ,UAAU;aAExB,iBAAY,GAAG,GAAH,AAAM,CAAC;IAiB1C,YACqB,iBAAsD,EACnD,oBAA4D;QAEnF,KAAK,EAAE,CAAC;QAH6B,sBAAiB,GAAjB,iBAAiB,CAAoB;QAClC,yBAAoB,GAApB,oBAAoB,CAAuB;QAf5E,YAAO,GAAG,IAAI,GAAG,EAA2B,CAAC;QAEpC,uBAAkB,GAAG,IAAI,OAAO,EAA0B,CAAC;QACnE,sBAAiB,GAAkC,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC;QAEzE,uBAAkB,GAAG,IAAI,GAAG,EAAU,CAAC;QAIhD,mBAAc,GAAG,KAAK,CAAC;QAEvB,uCAAkC,GAAG,IAAI,GAAG,EAA6C,CAAC;QA0H1F,8BAAyB,GAAG,IAAI,GAAG,EAA4F,CAAC;QAnHvI,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAC/E,IAAI,CAAC,yBAAyB,GAAG,eAAe,CAAC,8BAA8B,CAAC,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAC/G,IAAI,CAAC,uBAAuB,GAAG,eAAe,CAAC,0BAA0B,CAAC,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QACzG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,CAAC,CAAC,EAAE,EAAE;YACzD,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC;gBAC5C,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC3B,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,aAAa,CAAC,EAAU,EAAE,IAAoB;QAC7C,MAAM,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QACxC,IAAI,aAAa,EAAE,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,6BAA6B,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACpE,CAAC;QAED,MAAM,IAAI,GAAG,IAAI,CAAC;QAClB,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC;QACpC,IAAI,GAAG;YACN,GAAG,IAAI;YACP,IAAI,aAAa;gBAChB,OAAO,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACxH,CAAC;SACD,CAAC;QACF,MAAM,KAAK,GAAG,EAAE,IAAI,EAAE,CAAC;QACvB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;QAC5B,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAExC,OAAO,YAAY,CAAC,GAAG,EAAE;YACxB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YACxB,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAChC,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;IACJ,CAAC;IAEO,wBAAwB;QAC/B,oDAAoD;QACpD,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;QAChC,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;YAC3C,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;gBACrB,MAAM,IAAI,GAAG,cAAc,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACzD,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC;oBACtC,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBAClC,CAAC;YACF,CAAC;QACF,CAAC;IACF,CAAC;IAEO,kBAAkB;QACzB,IAAI,wBAAwB,GAAG,KAAK,CAAC;QACrC,IAAI,sBAAsB,GAAG,KAAK,CAAC;QACnC,IAAI,oBAAoB,GAAG,KAAK,CAAC;QACjC,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC;YACtC,IAAI,KAAK,CAAC,SAAS,EAAE,CAAC;gBACrB,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;oBACnB,wBAAwB,GAAG,IAAI,CAAC;gBACjC,CAAC;gBACD,IAAI,KAAK,CAAC,EAAE,KAAK,YAAY,IAAI,KAAK,CAAC,EAAE,KAAK,2BAA2B,EAAE,CAAC;oBAC3E,6FAA6F;oBAC7F,oBAAoB,GAAG,IAAI,CAAC;gBAC7B,CAAC;qBAAM,CAAC;oBACP,sBAAsB,GAAG,IAAI,CAAC;gBAC/B,CAAC;YACF,CAAC;QACF,CAAC;QACD,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAC;QACzD,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAC;QAC7D,IAAI,oBAAoB,KAAK,IAAI,CAAC,cAAc,EAAE,CAAC;YAClD,IAAI,CAAC,cAAc,GAAG,oBAAoB,CAAC;YAC3C,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,IAAI,EAAE,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;QAChG,CAAC;IACF,CAAC;IAED,2BAA2B,CAAC,EAAU,EAAE,SAAmC;QAC1E,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,EAAE,CAAC;YACZ,MAAM,IAAI,KAAK,CAAC,kBAAkB,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACzD,CAAC;QAED,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC;YAChB,MAAM,IAAI,KAAK,CAAC,qCAAqC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAC5E,CAAC;QAED,IAAI,KAAK,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YAC1B,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACjC,CAAC;QAED,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC;QACvB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC;QAEzE,OAAO,YAAY,CAAC,GAAG,EAAE;YACxB,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC;YACvB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAExC,IAAI,KAAK,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;gBAC1B,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;YAChG,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,oBAAoB,CAAC,IAAoB,EAAE,SAAmC;QAC7E,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,MAAM,KAAK,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC;QACxC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;QACjC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC;QAEnE,OAAO,YAAY,CAAC,GAAG,EAAE;YACxB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YAC7B,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;IACJ,CAAC;IAID,+BAA+B,CAAC,EAAU,EAAE,QAA0F;QACrI,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;QACjD,OAAO;YACN,OAAO,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,yBAAyB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;SAC7D,CAAC;IACH,CAAC;IAED,KAAK,CAAC,uBAAuB,CAAC,EAAU,EAAE,KAAa,EAAE,KAAwB;QAChF,OAAO,MAAM,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,EAAE,CAAC;IAC3E,CAAC;IAED,WAAW,CAAC,EAAU,EAAE,cAAkC;QACzD,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,CAAC;YAClB,MAAM,IAAI,KAAK,CAAC,8BAA8B,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,aAAa,CAAC,CAAC;QAChF,CAAC;QACD,KAAK,CAAC,IAAI,CAAC,QAAQ,GAAG,EAAE,GAAG,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,cAAc,EAAE,CAAC;QACpE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;IAC3E,CAAC;IAED,eAAe,CAAC,QAA2B,EAAE,OAAqB,YAAY,CAAC,GAAG;QACjF,OAAO,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,kBAAkB,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;YACtE,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;gBACrC,OAAO,KAAK,CAAC;YACd,CAAC;YAED,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACxD,CAAC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,IAAW,aAAa;QACvB,4GAA4G;QAC5G,OAAO,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;IAC7E,CAAC;IAED,0BAA0B,CAAC,QAA2B;QACrD,OAAO,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IAClH,CAAC;IAEO,qBAAqB,CAA2B,MAAW;QAClE,4DAA4D;QAC5D,6CAA6C;QAC7C,6DAA6D;QAC7D,sEAAsE;QACtE,OAAO,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAClE,CAAC;IAED,QAAQ,CAAC,EAAU,EAAE,eAAe,GAAG,KAAK;QAC3C,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;YACnD,OAAO;QACR,CAAC;QAED,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC;IACnC,CAAC;IAEO,eAAe,CAAC,SAAmC;QAC1D,MAAM,KAAK,GAAG,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACtF,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,cAAc,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACrH,CAAC;IAED,0BAA0B,CAAC,EAAU;QACpC,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,mBAAmB,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,EAAE,IAAI,CAAC;QAClG,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC;YAC9C,OAAO;QACR,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAED;;OAEG;IACH,SAAS;QACR,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;aACtC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC;aACxB,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC3C,CAAC;IAED,kBAAkB;QACjB,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;aACtC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;aACrB,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aAC5C,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,IAAK,CAAC,CAAC,CAAC;IAClD,CAAC;IAED,eAAe,CAAC,IAAY;QAC3B,OAAO,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC;IACnF,CAAC;IAEO,sBAAsB,CAA2B,MAAW;QACnE,4DAA4D;QAC5D,6CAA6C;QAC7C,yDAAyD;QACzD,sEAAsE;QACtE,MAAM,eAAe,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACtD,OAAO,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,MAAM,CAAC;IAC9D,CAAC;IAED,gBAAgB,CAAC,EAAU;QAC1B,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QAChC,IAAI,CAAC,KAAK,EAAE,CAAC;YACZ,OAAO,KAAK,CAAC;QACd,CAAC;QAED,OAAO,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC;aACrC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,KAAK,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;IAC3E,CAAC;IAED,KAAK,CAAC,WAAW,CAAC,EAAU,EAAE,OAA0B,EAAE,QAA0C,EAAE,OAAiC,EAAE,KAAwB;QAChK,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAClC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC;YACjB,MAAM,IAAI,KAAK,CAAC,+BAA+B,EAAE,GAAG,CAAC,CAAC;QACvD,CAAC;QAED,OAAO,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;IAClE,CAAC;IAED,eAAe,CAAC,EAAU,EAAE,SAAiB,EAAE,KAAwB;QACtE,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAClC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC;YACjB,MAAM,IAAI,KAAK,CAAC,+BAA+B,EAAE,GAAG,CAAC,CAAC;QACvD,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;IAC/C,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,EAAU,EAAE,OAA0B,EAAE,MAAwB,EAAE,OAAiC,EAAE,KAAwB;QAC/I,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAClC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,gBAAgB,EAAE,CAAC;YACnC,OAAO,EAAE,CAAC;QACX,CAAC;QAED,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;IACpE,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,EAAU,EAAE,OAAiC,EAAE,KAAwB;QACzF,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAClC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,gBAAgB,EAAE,CAAC;YACnC,OAAO,SAAS,CAAC;QAClB,CAAC;QAED,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACnD,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,EAAU,EAAE,OAAiC,EAAE,KAAwB;QAC3F,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAClC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,kBAAkB,EAAE,CAAC;YACrC,OAAO,SAAS,CAAC;QAClB,CAAC;QAED,OAAO,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACrD,CAAC;IAED,wCAAwC,CAAC,MAAc,EAAE,QAA2C;QACnG,IAAI,CAAC,kCAAkC,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;QAC9D,OAAO,YAAY,CAAC,GAAG,EAAE;YACxB,IAAI,CAAC,kCAAkC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACxD,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,oCAAoC;QACnC,OAAO,IAAI,CAAC,kCAAkC,CAAC,IAAI,GAAG,CAAC,CAAC;IACzD,CAAC;IAED,KAAK,CAAC,oBAAoB,CAAC,OAA0B,EAAE,OAAiC,EAAE,OAAwC,EAAE,KAAwB;QAC3J,2FAA2F;QAC3F,MAAM,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,kCAAkC,CAAC,MAAM,EAAE,CAAC,CAAC;QAClF,IAAI,CAAC,QAAQ,EAAE,CAAC;YACf,OAAO;QACR,CAAC;QAED,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC,MAAM,CAA6B,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE;YACnF,IAAI,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAC5C,GAAG,CAAC,IAAI,CAAC,EAAE,WAAW,EAAE,CAAC,CAAC,EAAE,EAAE,cAAc,EAAE,CAAC,CAAC,cAAc,IAAI,EAAE,EAAE,CAAC,CAAC;gBACxE,KAAK,MAAM,OAAO,IAAI,CAAC,CAAC,aAAa,EAAE,CAAC;oBACvC,GAAG,CAAC,IAAI,CAAC,EAAE,WAAW,EAAE,CAAC,CAAC,EAAE,EAAE,OAAO,EAAE,OAAO,CAAC,IAAI,EAAE,cAAc,EAAE,OAAO,CAAC,cAAc,IAAI,EAAE,EAAE,CAAC,CAAC;gBACtG,CAAC;YACF,CAAC;YACD,OAAO,GAAG,CAAC;QACZ,CAAC,EAAE,EAAE,CAAC,CAAC;QAEP,MAAM,MAAM,GAAG,MAAM,QAAQ,CAAC,2BAA2B,CAAC,OAAO,EAAE,OAAO,EAAE,EAAE,GAAG,OAAO,EAAE,YAAY,EAAE,EAAE,KAAK,CAAC,CAAC;QACjH,IAAI,CAAC,MAAM,EAAE,CAAC;YACb,OAAO;QACR,CAAC;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QAChD,IAAI,CAAC,KAAK,EAAE,CAAC;YACZ,wEAAwE;YACxE,OAAO;QACR,CAAC;QAED,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;YACrB,OAAO,EAAE,KAAK,EAAE,CAAC;QAClB,CAAC;QAED,MAAM,OAAO,GAAG,KAAK,EAAE,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC,OAAO,CAAC,CAAC;QAC1E,IAAI,CAAC,OAAO,EAAE,CAAC;YACd,0EAA0E;YAC1E,OAAO;QACR,CAAC;QAED,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC;IAC3B,CAAC;;AAxVW,gBAAgB;IAoB1B,WAAA,kBAAkB,CAAA;IAClB,WAAA,qBAAqB,CAAA;GArBX,gBAAgB,CAyV5B;;AAED,MAAM,OAAO,eAAe;IAC3B,YACkB,IAAoB,EACpB,IAA8B;QAD9B,SAAI,GAAJ,IAAI,CAAgB;QACpB,SAAI,GAAJ,IAAI,CAA0B;IAC5C,CAAC;IAKL,IAAI,EAAE,KAAa,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;IACzC,IAAI,IAAI,KAAa,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC;IACnD,IAAI,QAAQ,KAAa,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC,CAAC;IAC3D,IAAI,WAAW,KAAa,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI,EAAE,CAAC,CAAC,CAAC;IACjE,IAAI,WAAW,KAA0B,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;IACxE,IAAI,gBAAgB,KAAyB,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC;IACjF,IAAI,oBAAoB,KAAa,OAAO,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC;IAC7E,IAAI,6BAA6B,KAAK,OAAO,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC;IAC9E,IAAI,oBAAoB,KAAa,OAAO,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC;IAC7E,IAAI,SAAS,KAA0B,OAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;IACpE,IAAI,MAAM,KAA0B,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IAC9D,IAAI,QAAQ,KAAyB,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;IACjE,IAAI,aAAa,KAA0B,OAAO,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;IAC5E,IAAI,SAAS,KAA0B,OAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;IACpE,IAAI,KAAK,KAAqB,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IACvD,IAAI,cAAc,KAAsE,OAAO,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;IAE1H,KAAK,CAAC,MAAM,CAAC,OAA0B,EAAE,QAA0C,EAAE,OAAiC,EAAE,KAAwB;QAC/I,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;IAC5D,CAAC;IAED,eAAe,CAAC,SAAiB,EAAE,KAAwB;QAC1D,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;IAC/C,CAAC;IAED,KAAK,CAAC,gBAAgB,CAAC,OAA0B,EAAE,MAAwB,EAAE,OAAiC,EAAE,KAAwB;QACvI,IAAI,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAChC,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QACpE,CAAC;QAED,OAAO,EAAE,CAAC;IACX,CAAC;IAED,MAAM;QACL,OAAO,IAAI,CAAC,IAAI,CAAC;IAClB,CAAC;CACD;AAED,MAAM,CAAC,MAAM,qBAAqB,GAAG,eAAe,CAAwB,sBAAsB,CAAC,CAAC;AAc7F,IAAM,oBAAoB,GAA1B,MAAM,oBAAoB;;aAER,eAAU,GAAG,8BAAH,AAAiC,CAAC;IAQpE,YACkB,cAA+B,EAC/B,cAAgD,EACpD,UAAwC,EACpC,cAAgD;QAF/B,mBAAc,GAAd,cAAc,CAAiB;QACnC,eAAU,GAAV,UAAU,CAAa;QACnB,mBAAc,GAAd,cAAc,CAAiB;QAP1D,aAAQ,GAAG,eAAe,CAA2B,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;QAChF,aAAQ,GAAG,KAAK,CAAC;QAQxB,IAAI,CAAC,cAAc,CAAC,uBAAuB,EAAE,CAAC;YAC7C,OAAO;QACR,CAAC;QAED,IAAI,CAAC,GAAG,GAAG,cAAc,CAAC,uBAAuB,CAAC;QAElD,MAAM,GAAG,GAAG,cAAc,CAAC,GAAG,CAAC,sBAAoB,CAAC,UAAU,oCAA2B,CAAC;QAE1F,IAAI,CAAC;YACJ,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,IAAI,CAAC,EAAE,SAAS,CAAC,CAAC;QACvD,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACd,cAAc,CAAC,MAAM,CAAC,sBAAoB,CAAC,UAAU,oCAA2B,CAAC;QAClF,CAAC;QAED,IAAI,CAAC,OAAO,EAAE,CAAC;IAChB,CAAC;IAEO,OAAO;QACd,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACnB,OAAO;QACR,CAAC;QAED,IAAI,CAAC,MAAM,EAAE;aACX,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,2CAA2C,EAAE,GAAG,CAAC,CAAC;aACpF,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC,kBAAkB;aACrD,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;IAC9B,CAAC;IAEO,KAAK,CAAC,MAAM;QACnB,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,EAAE,iBAAiB,CAAC,IAAI,CAAC,CAAC;QAE1G,IAAI,OAAO,CAAC,GAAG,CAAC,UAAU,KAAK,GAAG,EAAE,CAAC;YACpC,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;QACrD,CAAC;QAED,MAAM,MAAM,GAAG,MAAM,MAAM,CAAmC,OAAO,CAAC,CAAC;QAEvE,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,KAAK,CAAC,EAAE,CAAC;YACrC,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;QACnE,CAAC;QAED,MAAM,QAAQ,GAAG,MAAM,CAAC,0BAA0B,CAAC;QACnD,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;QACvC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,sBAAoB,CAAC,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,mEAAkD,CAAC;IACvI,CAAC;IAED;;OAEG;IACH,uBAAuB,CAAC,aAA6B;QACpD,IAAI,aAAa,CAAC,MAAM,EAAE,CAAC;YAC1B,OAAO,IAAI,CAAC,CAAC,iDAAiD;QAC/D,CAAC;QAED,mHAAmH;QACnH,MAAM,WAAW,GAAG,IAAI,CAAC,yBAAyB,CAAC,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC,GAAG,EAAE,CAAC;QAC5F,MAAM,eAAe,GAAG,CAAC,aAAa,CAAC,QAAQ,IAAI,IAAI,CAAC,yBAAyB,CAAC,aAAa,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE,aAAa,CAAC,CAAC,GAAG,EAAE,CAAC;QAClJ,OAAO,WAAW,IAAI,eAAe,CAAC;IACvC,CAAC;IAEO,yBAAyB,CAAC,IAAY,EAAE,aAA6B;QAC5E,gHAAgH;QAChH,mEAAmE;QACnE,MAAM,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAuB,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;QACpG,OAAO,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;YAChC,IAAI,CAAC,SAAS,EAAE,CAAC;gBAChB,OAAO,IAAI,CAAC;YACb,CAAC;YAED,OAAO,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,gBAAgB,CAAC,EAAE,EAAE,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAC,oBAAoB,CAAC,CAAC,CAAC;QAC5I,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,OAAO;QACN,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACtB,CAAC;;AA3FW,oBAAoB;IAW9B,WAAA,eAAe,CAAA;IACf,WAAA,eAAe,CAAA;IACf,WAAA,WAAW,CAAA;IACX,WAAA,eAAe,CAAA;GAdL,oBAAoB,CA4FhC;;AAED,MAAM,UAAU,mBAAmB,CAAC,aAA6B;IAChE,OAAO,GAAG,aAAa,CAAC,WAAW,CAAC,KAAK,IAAI,aAAa,CAAC,EAAE,EAAE,CAAC;AACjE,CAAC;AAWD,MAAM,UAAU,qBAAqB,CAAC,GAA6D;IAClG,MAAM,UAAU,GAA+B,MAAM,IAAI,GAAG,CAAC,CAAC;QAC7D,GAAG,CAAC,CAAC;QACL;YACC,GAAG,GAAG;YACN,IAAI,EAAE,GAAG,CAAC,EAAE;SACZ,CAAC;IAEH,4DAA4D;IAC5D,IAAI,CAAC,UAAU,CAAC,oBAAoB,EAAE,CAAC;QACtC,UAAU,CAAC,oBAAoB,GAAI,GAAmC,CAAC,kBAAkB,IAAI,EAAE,CAAC;IACjG,CAAC;IAED,IAAI,CAAC,UAAU,CAAC,oBAAoB,EAAE,CAAC;QACtC,UAAU,CAAC,oBAAoB,GAAG,EAAE,CAAC;IACtC,CAAC;IAED,IAAI,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC;QAC7B,UAAU,CAAC,WAAW,GAAG,IAAI,mBAAmB,CAAC,EAAE,CAAC,CAAC;IACtD,CAAC;IAED,OAAO,MAAM,CAAC,UAAU,CAAC,CAAC;AAC3B,CAAC","file":"chatAgents.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLast } from '../../../../base/common/arraysFind.js';\nimport { timeout } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { revive, Revived } from '../../../../base/common/marshalling.js';\nimport { IObservable, observableValue } from '../../../../base/common/observable.js';\nimport { equalsIgnoreCase } from '../../../../base/common/strings.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Command } from '../../../../editor/common/languages.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { ContextKeyExpr, IContextKey, IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { asJson, IRequestService } from '../../../../platform/request/common/request.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { ChatContextKeys } from './chatContextKeys.js';\nimport { IChatAgentEditedFileEvent, IChatProgressHistoryResponseContent, IChatRequestModeInstructions, IChatRequestVariableData, ISerializableChatAgentData } from './chatModel.js';\nimport { IRawChatCommandContribution } from './chatParticipantContribTypes.js';\nimport { IChatFollowup, IChatLocationData, IChatProgress, IChatResponseErrorDetails, IChatTaskDto } from './chatService.js';\nimport { ChatAgentLocation, ChatConfiguration, ChatModeKind } from './constants.js';\n\n//#region agent service, commands etc\n\nexport interface IChatAgentHistoryEntry {\n\trequest: IChatAgentRequest;\n\tresponse: ReadonlyArray<IChatProgressHistoryResponseContent | IChatTaskDto>;\n\tresult: IChatAgentResult;\n}\n\nexport interface IChatAgentAttachmentCapabilities {\n\tsupportsFileAttachments?: boolean;\n\tsupportsToolAttachments?: boolean;\n\tsupportsMCPAttachments?: boolean;\n\tsupportsImageAttachments?: boolean;\n\tsupportsSearchResultAttachments?: boolean;\n\tsupportsInstructionAttachments?: boolean;\n\tsupportsSourceControlAttachments?: boolean;\n\tsupportsProblemAttachments?: boolean;\n\tsupportsSymbolAttachments?: boolean;\n\tsupportsTerminalAttachments?: boolean;\n}\n\nexport interface IChatAgentData {\n\tid: string;\n\tname: string;\n\tfullName?: string;\n\tdescription?: string;\n\t/** This is string, not ContextKeyExpression, because dealing with serializing/deserializing is hard and need a better pattern for this */\n\twhen?: string;\n\textensionId: ExtensionIdentifier;\n\textensionVersion: string | undefined;\n\textensionPublisherId: string;\n\t/** This is the extension publisher id, or, in the case of a dynamically registered participant (remote agent), whatever publisher name we have for it */\n\tpublisherDisplayName?: string;\n\textensionDisplayName: string;\n\t/** The agent invoked when no agent is specified */\n\tisDefault?: boolean;\n\t/** This agent is not contributed in package.json, but is registered dynamically */\n\tisDynamic?: boolean;\n\t/** This agent is contributed from core and not from an extension */\n\tisCore?: boolean;\n\tcanAccessPreviousChatHistory?: boolean;\n\tmetadata: IChatAgentMetadata;\n\tslashCommands: IChatAgentCommand[];\n\tlocations: ChatAgentLocation[];\n\t/** This is only relevant for isDefault agents. Others should have all modes available. */\n\tmodes: ChatModeKind[];\n\tdisambiguation: { category: string; description: string; examples: string[] }[];\n\tcapabilities?: IChatAgentAttachmentCapabilities;\n}\n\nexport interface IChatWelcomeMessageContent {\n\ticon: ThemeIcon;\n\ttitle: string;\n\tmessage: IMarkdownString;\n}\n\nexport interface IChatAgentImplementation {\n\tinvoke(request: IChatAgentRequest, progress: (parts: IChatProgress[]) => void, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatAgentResult>;\n\tsetRequestTools?(requestId: string, tools: UserSelectedTools): void;\n\tprovideFollowups?(request: IChatAgentRequest, result: IChatAgentResult, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatFollowup[]>;\n\tprovideChatTitle?: (history: IChatAgentHistoryEntry[], token: CancellationToken) => Promise<string | undefined>;\n\tprovideChatSummary?: (history: IChatAgentHistoryEntry[], token: CancellationToken) => Promise<string | undefined>;\n}\n\nexport interface IChatParticipantDetectionResult {\n\tparticipant: string;\n\tcommand?: string;\n}\n\nexport interface IChatParticipantMetadata {\n\tparticipant: string;\n\tcommand?: string;\n\tdisambiguation: { category: string; description: string; examples: string[] }[];\n}\n\nexport interface IChatParticipantDetectionProvider {\n\tprovideParticipantDetection(request: IChatAgentRequest, history: IChatAgentHistoryEntry[], options: { location: ChatAgentLocation; participants: IChatParticipantMetadata[] }, token: CancellationToken): Promise<IChatParticipantDetectionResult | null | undefined>;\n}\n\nexport type IChatAgent = IChatAgentData & IChatAgentImplementation;\n\nexport interface IChatAgentCommand extends IRawChatCommandContribution {\n\tfollowupPlaceholder?: string;\n}\n\nexport interface IChatAgentMetadata {\n\thelpTextPrefix?: string | IMarkdownString;\n\thelpTextPostfix?: string | IMarkdownString;\n\ticon?: URI;\n\ticonDark?: URI;\n\tthemeIcon?: ThemeIcon;\n\tsampleRequest?: string;\n\tsupportIssueReporting?: boolean;\n\tfollowupPlaceholder?: string;\n\tisSticky?: boolean;\n\tadditionalWelcomeMessage?: string | IMarkdownString;\n}\n\nexport type UserSelectedTools = Record<string, boolean>;\n\n\nexport interface IChatAgentRequest {\n\t/** @deprecated Use {@linkcode sessionResource} instead */\n\tsessionId: string;\n\tsessionResource: URI;\n\trequestId: string;\n\tagentId: string;\n\tcommand?: string;\n\tmessage: string;\n\tattempt?: number;\n\tenableCommandDetection?: boolean;\n\tisParticipantDetected?: boolean;\n\tvariables: IChatRequestVariableData;\n\tlocation: ChatAgentLocation;\n\tlocationData?: Revived<IChatLocationData>;\n\tacceptedConfirmationData?: unknown[];\n\trejectedConfirmationData?: unknown[];\n\tuserSelectedModelId?: string;\n\tuserSelectedTools?: UserSelectedTools;\n\tmodeInstructions?: IChatRequestModeInstructions;\n\teditedFileEvents?: IChatAgentEditedFileEvent[];\n\tisSubagent?: boolean;\n\n}\n\nexport interface IChatQuestion {\n\treadonly prompt: string;\n\treadonly participant?: string;\n\treadonly command?: string;\n}\n\nexport interface IChatAgentResultTimings {\n\tfirstProgress?: number;\n\ttotalElapsed: number;\n}\n\nexport interface IChatAgentResult {\n\terrorDetails?: IChatResponseErrorDetails;\n\ttimings?: IChatAgentResultTimings;\n\t/** Extra properties that the agent can use to identify a result */\n\treadonly metadata?: { readonly [key: string]: unknown };\n\treadonly details?: string;\n\tnextQuestion?: IChatQuestion;\n}\n\nexport const IChatAgentService = createDecorator<IChatAgentService>('chatAgentService');\n\ninterface IChatAgentEntry {\n\tdata: IChatAgentData;\n\timpl?: IChatAgentImplementation;\n}\n\nexport interface IChatAgentCompletionItem {\n\tid: string;\n\tname?: string;\n\tfullName?: string;\n\ticon?: ThemeIcon;\n\tvalue: unknown;\n\tcommand?: Command;\n}\n\nexport interface IChatAgentService {\n\t_serviceBrand: undefined;\n\t/**\n\t * undefined when an agent was removed\n\t */\n\treadonly onDidChangeAgents: Event<IChatAgent | undefined>;\n\treadonly hasToolsAgent: boolean;\n\tregisterAgent(id: string, data: IChatAgentData): IDisposable;\n\tregisterAgentImplementation(id: string, agent: IChatAgentImplementation): IDisposable;\n\tregisterDynamicAgent(data: IChatAgentData, agentImpl: IChatAgentImplementation): IDisposable;\n\tregisterAgentCompletionProvider(id: string, provider: (query: string, token: CancellationToken) => Promise<IChatAgentCompletionItem[]>): IDisposable;\n\tgetAgentCompletionItems(id: string, query: string, token: CancellationToken): Promise<IChatAgentCompletionItem[]>;\n\tregisterChatParticipantDetectionProvider(handle: number, provider: IChatParticipantDetectionProvider): IDisposable;\n\tdetectAgentOrCommand(request: IChatAgentRequest, history: IChatAgentHistoryEntry[], options: { location: ChatAgentLocation }, token: CancellationToken): Promise<{ agent: IChatAgentData; command?: IChatAgentCommand } | undefined>;\n\thasChatParticipantDetectionProviders(): boolean;\n\tinvokeAgent(agent: string, request: IChatAgentRequest, progress: (parts: IChatProgress[]) => void, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatAgentResult>;\n\tsetRequestTools(agent: string, requestId: string, tools: UserSelectedTools): void;\n\tgetFollowups(id: string, request: IChatAgentRequest, result: IChatAgentResult, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatFollowup[]>;\n\tgetChatTitle(id: string, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<string | undefined>;\n\tgetChatSummary(id: string, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<string | undefined>;\n\tgetAgent(id: string, includeDisabled?: boolean): IChatAgentData | undefined;\n\tgetAgentByFullyQualifiedId(id: string): IChatAgentData | undefined;\n\tgetAgents(): IChatAgentData[];\n\tgetActivatedAgents(): Array<IChatAgent>;\n\tgetAgentsByName(name: string): IChatAgentData[];\n\tagentHasDupeName(id: string): boolean;\n\n\t/**\n\t * Get the default agent (only if activated)\n\t */\n\tgetDefaultAgent(location: ChatAgentLocation, mode?: ChatModeKind): IChatAgent | undefined;\n\n\t/**\n\t * Get the default agent data that has been contributed (may not be activated yet)\n\t */\n\tgetContributedDefaultAgent(location: ChatAgentLocation): IChatAgentData | undefined;\n\tupdateAgent(id: string, updateMetadata: IChatAgentMetadata): void;\n}\n\nexport class ChatAgentService extends Disposable implements IChatAgentService {\n\n\tpublic static readonly AGENT_LEADER = '@';\n\n\tdeclare _serviceBrand: undefined;\n\n\tprivate _agents = new Map<string, IChatAgentEntry>();\n\n\tprivate readonly _onDidChangeAgents = new Emitter<IChatAgent | undefined>();\n\treadonly onDidChangeAgents: Event<IChatAgent | undefined> = this._onDidChangeAgents.event;\n\n\tprivate readonly _agentsContextKeys = new Set<string>();\n\tprivate readonly _hasDefaultAgent: IContextKey<boolean>;\n\tprivate readonly _extensionAgentRegistered: IContextKey<boolean>;\n\tprivate readonly _defaultAgentRegistered: IContextKey<boolean>;\n\tprivate _hasToolsAgent = false;\n\n\tprivate _chatParticipantDetectionProviders = new Map<number, IChatParticipantDetectionProvider>();\n\n\tconstructor(\n\t\t@IContextKeyService private readonly contextKeyService: IContextKeyService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t) {\n\t\tsuper();\n\t\tthis._hasDefaultAgent = ChatContextKeys.enabled.bindTo(this.contextKeyService);\n\t\tthis._extensionAgentRegistered = ChatContextKeys.extensionParticipantRegistered.bindTo(this.contextKeyService);\n\t\tthis._defaultAgentRegistered = ChatContextKeys.panelParticipantRegistered.bindTo(this.contextKeyService);\n\t\tthis._register(contextKeyService.onDidChangeContext((e) => {\n\t\t\tif (e.affectsSome(this._agentsContextKeys)) {\n\t\t\t\tthis._updateContextKeys();\n\t\t\t}\n\t\t}));\n\t}\n\n\tregisterAgent(id: string, data: IChatAgentData): IDisposable {\n\t\tconst existingAgent = this.getAgent(id);\n\t\tif (existingAgent) {\n\t\t\tthrow new Error(`Agent already registered: ${JSON.stringify(id)}`);\n\t\t}\n\n\t\tconst that = this;\n\t\tconst commands = data.slashCommands;\n\t\tdata = {\n\t\t\t...data,\n\t\t\tget slashCommands() {\n\t\t\t\treturn commands.filter(c => !c.when || that.contextKeyService.contextMatchesRules(ContextKeyExpr.deserialize(c.when)));\n\t\t\t}\n\t\t};\n\t\tconst entry = { data };\n\t\tthis._agents.set(id, entry);\n\t\tthis._updateAgentsContextKeys();\n\t\tthis._updateContextKeys();\n\t\tthis._onDidChangeAgents.fire(undefined);\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._agents.delete(id);\n\t\t\tthis._updateAgentsContextKeys();\n\t\t\tthis._updateContextKeys();\n\t\t\tthis._onDidChangeAgents.fire(undefined);\n\t\t});\n\t}\n\n\tprivate _updateAgentsContextKeys(): void {\n\t\t// Update the set of context keys used by all agents\n\t\tthis._agentsContextKeys.clear();\n\t\tfor (const agent of this._agents.values()) {\n\t\t\tif (agent.data.when) {\n\t\t\t\tconst expr = ContextKeyExpr.deserialize(agent.data.when);\n\t\t\t\tfor (const key of expr?.keys() || []) {\n\t\t\t\t\tthis._agentsContextKeys.add(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _updateContextKeys(): void {\n\t\tlet extensionAgentRegistered = false;\n\t\tlet defaultAgentRegistered = false;\n\t\tlet toolsAgentRegistered = false;\n\t\tfor (const agent of this.getAgents()) {\n\t\t\tif (agent.isDefault) {\n\t\t\t\tif (!agent.isCore) {\n\t\t\t\t\textensionAgentRegistered = true;\n\t\t\t\t}\n\t\t\t\tif (agent.id === 'chat.setup' || agent.id === 'github.copilot.editsAgent') {\n\t\t\t\t\t// TODO@roblourens firing the event below probably isn't necessary but leave it alone for now\n\t\t\t\t\ttoolsAgentRegistered = true;\n\t\t\t\t} else {\n\t\t\t\t\tdefaultAgentRegistered = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._defaultAgentRegistered.set(defaultAgentRegistered);\n\t\tthis._extensionAgentRegistered.set(extensionAgentRegistered);\n\t\tif (toolsAgentRegistered !== this._hasToolsAgent) {\n\t\t\tthis._hasToolsAgent = toolsAgentRegistered;\n\t\t\tthis._onDidChangeAgents.fire(this.getDefaultAgent(ChatAgentLocation.Chat, ChatModeKind.Agent));\n\t\t}\n\t}\n\n\tregisterAgentImplementation(id: string, agentImpl: IChatAgentImplementation): IDisposable {\n\t\tconst entry = this._agents.get(id);\n\t\tif (!entry) {\n\t\t\tthrow new Error(`Unknown agent: ${JSON.stringify(id)}`);\n\t\t}\n\n\t\tif (entry.impl) {\n\t\t\tthrow new Error(`Agent already has implementation: ${JSON.stringify(id)}`);\n\t\t}\n\n\t\tif (entry.data.isDefault) {\n\t\t\tthis._hasDefaultAgent.set(true);\n\t\t}\n\n\t\tentry.impl = agentImpl;\n\t\tthis._onDidChangeAgents.fire(new MergedChatAgent(entry.data, agentImpl));\n\n\t\treturn toDisposable(() => {\n\t\t\tentry.impl = undefined;\n\t\t\tthis._onDidChangeAgents.fire(undefined);\n\n\t\t\tif (entry.data.isDefault) {\n\t\t\t\tthis._hasDefaultAgent.set(Iterable.some(this._agents.values(), agent => agent.data.isDefault));\n\t\t\t}\n\t\t});\n\t}\n\n\tregisterDynamicAgent(data: IChatAgentData, agentImpl: IChatAgentImplementation): IDisposable {\n\t\tdata.isDynamic = true;\n\t\tconst agent = { data, impl: agentImpl };\n\t\tthis._agents.set(data.id, agent);\n\t\tthis._onDidChangeAgents.fire(new MergedChatAgent(data, agentImpl));\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._agents.delete(data.id);\n\t\t\tthis._onDidChangeAgents.fire(undefined);\n\t\t});\n\t}\n\n\tprivate _agentCompletionProviders = new Map<string, (query: string, token: CancellationToken) => Promise<IChatAgentCompletionItem[]>>();\n\n\tregisterAgentCompletionProvider(id: string, provider: (query: string, token: CancellationToken) => Promise<IChatAgentCompletionItem[]>) {\n\t\tthis._agentCompletionProviders.set(id, provider);\n\t\treturn {\n\t\t\tdispose: () => { this._agentCompletionProviders.delete(id); }\n\t\t};\n\t}\n\n\tasync getAgentCompletionItems(id: string, query: string, token: CancellationToken) {\n\t\treturn await this._agentCompletionProviders.get(id)?.(query, token) ?? [];\n\t}\n\n\tupdateAgent(id: string, updateMetadata: IChatAgentMetadata): void {\n\t\tconst agent = this._agents.get(id);\n\t\tif (!agent?.impl) {\n\t\t\tthrow new Error(`No activated agent with id ${JSON.stringify(id)} registered`);\n\t\t}\n\t\tagent.data.metadata = { ...agent.data.metadata, ...updateMetadata };\n\t\tthis._onDidChangeAgents.fire(new MergedChatAgent(agent.data, agent.impl));\n\t}\n\n\tgetDefaultAgent(location: ChatAgentLocation, mode: ChatModeKind = ChatModeKind.Ask): IChatAgent | undefined {\n\t\treturn this._preferExtensionAgent(this.getActivatedAgents().filter(a => {\n\t\t\tif (mode && !a.modes.includes(mode)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn !!a.isDefault && a.locations.includes(location);\n\t\t}));\n\t}\n\n\tpublic get hasToolsAgent(): boolean {\n\t\t// The chat participant enablement is just based on this setting. Don't wait for the extension to be loaded.\n\t\treturn !!this.configurationService.getValue(ChatConfiguration.AgentEnabled);\n\t}\n\n\tgetContributedDefaultAgent(location: ChatAgentLocation): IChatAgentData | undefined {\n\t\treturn this._preferExtensionAgent(this.getAgents().filter(a => !!a.isDefault && a.locations.includes(location)));\n\t}\n\n\tprivate _preferExtensionAgent<T extends IChatAgentData>(agents: T[]): T | undefined {\n\t\t// We potentially have multiple agents on the same location,\n\t\t// contributed from core and from extensions.\n\t\t// This method will prefer the last extensions provided agent\n\t\t// falling back to the last core agent if no extension agent is found.\n\t\treturn findLast(agents, agent => !agent.isCore) ?? agents.at(-1);\n\t}\n\n\tgetAgent(id: string, includeDisabled = false): IChatAgentData | undefined {\n\t\tif (!this._agentIsEnabled(id) && !includeDisabled) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this._agents.get(id)?.data;\n\t}\n\n\tprivate _agentIsEnabled(idOrAgent: string | IChatAgentEntry): boolean {\n\t\tconst entry = typeof idOrAgent === 'string' ? this._agents.get(idOrAgent) : idOrAgent;\n\t\treturn !entry?.data.when || this.contextKeyService.contextMatchesRules(ContextKeyExpr.deserialize(entry.data.when));\n\t}\n\n\tgetAgentByFullyQualifiedId(id: string): IChatAgentData | undefined {\n\t\tconst agent = Iterable.find(this._agents.values(), a => getFullyQualifiedId(a.data) === id)?.data;\n\t\tif (agent && !this._agentIsEnabled(agent.id)) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn agent;\n\t}\n\n\t/**\n\t * Returns all agent datas that exist- static registered and dynamic ones.\n\t */\n\tgetAgents(): IChatAgentData[] {\n\t\treturn Array.from(this._agents.values())\n\t\t\t.map(entry => entry.data)\n\t\t\t.filter(a => this._agentIsEnabled(a.id));\n\t}\n\n\tgetActivatedAgents(): IChatAgent[] {\n\t\treturn Array.from(this._agents.values())\n\t\t\t.filter(a => !!a.impl)\n\t\t\t.filter(a => this._agentIsEnabled(a.data.id))\n\t\t\t.map(a => new MergedChatAgent(a.data, a.impl!));\n\t}\n\n\tgetAgentsByName(name: string): IChatAgentData[] {\n\t\treturn this._preferExtensionAgents(this.getAgents().filter(a => a.name === name));\n\t}\n\n\tprivate _preferExtensionAgents<T extends IChatAgentData>(agents: T[]): T[] {\n\t\t// We potentially have multiple agents on the same location,\n\t\t// contributed from core and from extensions.\n\t\t// This method will prefer the extensions provided agents\n\t\t// falling back to the original agents array extension agent is found.\n\t\tconst extensionAgents = agents.filter(a => !a.isCore);\n\t\treturn extensionAgents.length > 0 ? extensionAgents : agents;\n\t}\n\n\tagentHasDupeName(id: string): boolean {\n\t\tconst agent = this.getAgent(id);\n\t\tif (!agent) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.getAgentsByName(agent.name)\n\t\t\t.filter(a => a.extensionId.value !== agent.extensionId.value).length > 0;\n\t}\n\n\tasync invokeAgent(id: string, request: IChatAgentRequest, progress: (parts: IChatProgress[]) => void, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatAgentResult> {\n\t\tconst data = this._agents.get(id);\n\t\tif (!data?.impl) {\n\t\t\tthrow new Error(`No activated agent with id \"${id}\"`);\n\t\t}\n\n\t\treturn await data.impl.invoke(request, progress, history, token);\n\t}\n\n\tsetRequestTools(id: string, requestId: string, tools: UserSelectedTools): void {\n\t\tconst data = this._agents.get(id);\n\t\tif (!data?.impl) {\n\t\t\tthrow new Error(`No activated agent with id \"${id}\"`);\n\t\t}\n\n\t\tdata.impl.setRequestTools?.(requestId, tools);\n\t}\n\n\tasync getFollowups(id: string, request: IChatAgentRequest, result: IChatAgentResult, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatFollowup[]> {\n\t\tconst data = this._agents.get(id);\n\t\tif (!data?.impl?.provideFollowups) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn data.impl.provideFollowups(request, result, history, token);\n\t}\n\n\tasync getChatTitle(id: string, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<string | undefined> {\n\t\tconst data = this._agents.get(id);\n\t\tif (!data?.impl?.provideChatTitle) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn data.impl.provideChatTitle(history, token);\n\t}\n\n\tasync getChatSummary(id: string, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<string | undefined> {\n\t\tconst data = this._agents.get(id);\n\t\tif (!data?.impl?.provideChatSummary) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn data.impl.provideChatSummary(history, token);\n\t}\n\n\tregisterChatParticipantDetectionProvider(handle: number, provider: IChatParticipantDetectionProvider) {\n\t\tthis._chatParticipantDetectionProviders.set(handle, provider);\n\t\treturn toDisposable(() => {\n\t\t\tthis._chatParticipantDetectionProviders.delete(handle);\n\t\t});\n\t}\n\n\thasChatParticipantDetectionProviders() {\n\t\treturn this._chatParticipantDetectionProviders.size > 0;\n\t}\n\n\tasync detectAgentOrCommand(request: IChatAgentRequest, history: IChatAgentHistoryEntry[], options: { location: ChatAgentLocation }, token: CancellationToken): Promise<{ agent: IChatAgentData; command?: IChatAgentCommand } | undefined> {\n\t\t// TODO@joyceerhl should we have a selector to be able to narrow down which provider to use\n\t\tconst provider = Iterable.first(this._chatParticipantDetectionProviders.values());\n\t\tif (!provider) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst participants = this.getAgents().reduce<IChatParticipantMetadata[]>((acc, a) => {\n\t\t\tif (a.locations.includes(options.location)) {\n\t\t\t\tacc.push({ participant: a.id, disambiguation: a.disambiguation ?? [] });\n\t\t\t\tfor (const command of a.slashCommands) {\n\t\t\t\t\tacc.push({ participant: a.id, command: command.name, disambiguation: command.disambiguation ?? [] });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst result = await provider.provideParticipantDetection(request, history, { ...options, participants }, token);\n\t\tif (!result) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst agent = this.getAgent(result.participant);\n\t\tif (!agent) {\n\t\t\t// Couldn't find a participant matching the participant detection result\n\t\t\treturn;\n\t\t}\n\n\t\tif (!result.command) {\n\t\t\treturn { agent };\n\t\t}\n\n\t\tconst command = agent?.slashCommands.find(c => c.name === result.command);\n\t\tif (!command) {\n\t\t\t// Couldn't find a slash command matching the participant detection result\n\t\t\treturn;\n\t\t}\n\n\t\treturn { agent, command };\n\t}\n}\n\nexport class MergedChatAgent implements IChatAgent {\n\tconstructor(\n\t\tprivate readonly data: IChatAgentData,\n\t\tprivate readonly impl: IChatAgentImplementation\n\t) { }\n\twhen?: string | undefined;\n\tpublisherDisplayName?: string | undefined;\n\tisDynamic?: boolean | undefined;\n\n\tget id(): string { return this.data.id; }\n\tget name(): string { return this.data.name ?? ''; }\n\tget fullName(): string { return this.data.fullName ?? ''; }\n\tget description(): string { return this.data.description ?? ''; }\n\tget extensionId(): ExtensionIdentifier { return this.data.extensionId; }\n\tget extensionVersion(): string | undefined { return this.data.extensionVersion; }\n\tget extensionPublisherId(): string { return this.data.extensionPublisherId; }\n\tget extensionPublisherDisplayName() { return this.data.publisherDisplayName; }\n\tget extensionDisplayName(): string { return this.data.extensionDisplayName; }\n\tget isDefault(): boolean | undefined { return this.data.isDefault; }\n\tget isCore(): boolean | undefined { return this.data.isCore; }\n\tget metadata(): IChatAgentMetadata { return this.data.metadata; }\n\tget slashCommands(): IChatAgentCommand[] { return this.data.slashCommands; }\n\tget locations(): ChatAgentLocation[] { return this.data.locations; }\n\tget modes(): ChatModeKind[] { return this.data.modes; }\n\tget disambiguation(): { category: string; description: string; examples: string[] }[] { return this.data.disambiguation; }\n\n\tasync invoke(request: IChatAgentRequest, progress: (parts: IChatProgress[]) => void, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatAgentResult> {\n\t\treturn this.impl.invoke(request, progress, history, token);\n\t}\n\n\tsetRequestTools(requestId: string, tools: UserSelectedTools): void {\n\t\tthis.impl.setRequestTools?.(requestId, tools);\n\t}\n\n\tasync provideFollowups(request: IChatAgentRequest, result: IChatAgentResult, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatFollowup[]> {\n\t\tif (this.impl.provideFollowups) {\n\t\t\treturn this.impl.provideFollowups(request, result, history, token);\n\t\t}\n\n\t\treturn [];\n\t}\n\n\ttoJSON(): IChatAgentData {\n\t\treturn this.data;\n\t}\n}\n\nexport const IChatAgentNameService = createDecorator<IChatAgentNameService>('chatAgentNameService');\n\ntype IChatParticipantRegistry = { [name: string]: string[] };\n\ninterface IChatParticipantRegistryResponse {\n\treadonly version: number;\n\treadonly restrictedChatParticipants: IChatParticipantRegistry;\n}\n\nexport interface IChatAgentNameService {\n\t_serviceBrand: undefined;\n\tgetAgentNameRestriction(chatAgentData: IChatAgentData): boolean;\n}\n\nexport class ChatAgentNameService implements IChatAgentNameService {\n\n\tprivate static readonly StorageKey = 'chat.participantNameRegistry';\n\n\tdeclare _serviceBrand: undefined;\n\n\tprivate readonly url!: string;\n\tprivate registry = observableValue<IChatParticipantRegistry>(this, Object.create(null));\n\tprivate disposed = false;\n\n\tconstructor(\n\t\t@IProductService productService: IProductService,\n\t\t@IRequestService private readonly requestService: IRequestService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStorageService private readonly storageService: IStorageService\n\t) {\n\t\tif (!productService.chatParticipantRegistry) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.url = productService.chatParticipantRegistry;\n\n\t\tconst raw = storageService.get(ChatAgentNameService.StorageKey, StorageScope.APPLICATION);\n\n\t\ttry {\n\t\t\tthis.registry.set(JSON.parse(raw ?? '{}'), undefined);\n\t\t} catch (err) {\n\t\t\tstorageService.remove(ChatAgentNameService.StorageKey, StorageScope.APPLICATION);\n\t\t}\n\n\t\tthis.refresh();\n\t}\n\n\tprivate refresh(): void {\n\t\tif (this.disposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.update()\n\t\t\t.catch(err => this.logService.warn('Failed to fetch chat participant registry', err))\n\t\t\t.then(() => timeout(5 * 60 * 1000)) // every 5 minutes\n\t\t\t.then(() => this.refresh());\n\t}\n\n\tprivate async update(): Promise<void> {\n\t\tconst context = await this.requestService.request({ type: 'GET', url: this.url }, CancellationToken.None);\n\n\t\tif (context.res.statusCode !== 200) {\n\t\t\tthrow new Error('Could not get extensions report.');\n\t\t}\n\n\t\tconst result = await asJson<IChatParticipantRegistryResponse>(context);\n\n\t\tif (!result || result.version !== 1) {\n\t\t\tthrow new Error('Unexpected chat participant registry response.');\n\t\t}\n\n\t\tconst registry = result.restrictedChatParticipants;\n\t\tthis.registry.set(registry, undefined);\n\t\tthis.storageService.store(ChatAgentNameService.StorageKey, JSON.stringify(registry), StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t}\n\n\t/**\n\t * Returns true if the agent is allowed to use this name\n\t */\n\tgetAgentNameRestriction(chatAgentData: IChatAgentData): boolean {\n\t\tif (chatAgentData.isCore) {\n\t\t\treturn true; // core agents are always allowed to use any name\n\t\t}\n\n\t\t// TODO would like to use observables here but nothing uses it downstream and I'm not sure how to combine these two\n\t\tconst nameAllowed = this.checkAgentNameRestriction(chatAgentData.name, chatAgentData).get();\n\t\tconst fullNameAllowed = !chatAgentData.fullName || this.checkAgentNameRestriction(chatAgentData.fullName.replace(/\\s/g, ''), chatAgentData).get();\n\t\treturn nameAllowed && fullNameAllowed;\n\t}\n\n\tprivate checkAgentNameRestriction(name: string, chatAgentData: IChatAgentData): IObservable<boolean> {\n\t\t// Registry is a map of name to an array of extension publisher IDs or extension IDs that are allowed to use it.\n\t\t// Look up the list of extensions that are allowed to use this name\n\t\tconst allowList = this.registry.map<string[] | undefined>(registry => registry[name.toLowerCase()]);\n\t\treturn allowList.map(allowList => {\n\t\t\tif (!allowList) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn allowList.some(id => equalsIgnoreCase(id, id.includes('.') ? chatAgentData.extensionId.value : chatAgentData.extensionPublisherId));\n\t\t});\n\t}\n\n\tdispose() {\n\t\tthis.disposed = true;\n\t}\n}\n\nexport function getFullyQualifiedId(chatAgentData: IChatAgentData): string {\n\treturn `${chatAgentData.extensionId.value}.${chatAgentData.id}`;\n}\n\n/**\n * There was a period where serialized chat agent data used 'id' instead of 'name'.\n * Don't copy this pattern, serialized data going forward should be versioned with strict interfaces.\n */\ninterface IOldSerializedChatAgentData extends Omit<ISerializableChatAgentData, 'name'> {\n\tid: string;\n\textensionPublisher?: string;\n}\n\nexport function reviveSerializedAgent(raw: ISerializableChatAgentData | IOldSerializedChatAgentData): IChatAgentData {\n\tconst normalized: ISerializableChatAgentData = 'name' in raw ?\n\t\traw :\n\t\t{\n\t\t\t...raw,\n\t\t\tname: raw.id,\n\t\t};\n\n\t// Fill in required fields that may be missing from old data\n\tif (!normalized.extensionPublisherId) {\n\t\tnormalized.extensionPublisherId = (raw as IOldSerializedChatAgentData).extensionPublisher ?? '';\n\t}\n\n\tif (!normalized.extensionDisplayName) {\n\t\tnormalized.extensionDisplayName = '';\n\t}\n\n\tif (!normalized.extensionId) {\n\t\tnormalized.extensionId = new ExtensionIdentifier('');\n\t}\n\n\treturn revive(normalized);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLast } from '../../../../base/common/arraysFind.js';\nimport { timeout } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { revive, Revived } from '../../../../base/common/marshalling.js';\nimport { IObservable, observableValue } from '../../../../base/common/observable.js';\nimport { equalsIgnoreCase } from '../../../../base/common/strings.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Command } from '../../../../editor/common/languages.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { ContextKeyExpr, IContextKey, IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { asJson, IRequestService } from '../../../../platform/request/common/request.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { ChatContextKeys } from './chatContextKeys.js';\nimport { IChatAgentEditedFileEvent, IChatProgressHistoryResponseContent, IChatRequestModeInstructions, IChatRequestVariableData, ISerializableChatAgentData } from './chatModel.js';\nimport { IRawChatCommandContribution } from './chatParticipantContribTypes.js';\nimport { IChatFollowup, IChatLocationData, IChatProgress, IChatResponseErrorDetails, IChatTaskDto } from './chatService.js';\nimport { ChatAgentLocation, ChatConfiguration, ChatModeKind } from './constants.js';\n\n//#region agent service, commands etc\n\nexport interface IChatAgentHistoryEntry {\n\trequest: IChatAgentRequest;\n\tresponse: ReadonlyArray<IChatProgressHistoryResponseContent | IChatTaskDto>;\n\tresult: IChatAgentResult;\n}\n\nexport interface IChatAgentAttachmentCapabilities {\n\tsupportsFileAttachments?: boolean;\n\tsupportsToolAttachments?: boolean;\n\tsupportsMCPAttachments?: boolean;\n\tsupportsImageAttachments?: boolean;\n\tsupportsSearchResultAttachments?: boolean;\n\tsupportsInstructionAttachments?: boolean;\n\tsupportsSourceControlAttachments?: boolean;\n\tsupportsProblemAttachments?: boolean;\n\tsupportsSymbolAttachments?: boolean;\n\tsupportsTerminalAttachments?: boolean;\n}\n\nexport interface IChatAgentData {\n\tid: string;\n\tname: string;\n\tfullName?: string;\n\tdescription?: string;\n\t/** This is string, not ContextKeyExpression, because dealing with serializing/deserializing is hard and need a better pattern for this */\n\twhen?: string;\n\textensionId: ExtensionIdentifier;\n\textensionVersion: string | undefined;\n\textensionPublisherId: string;\n\t/** This is the extension publisher id, or, in the case of a dynamically registered participant (remote agent), whatever publisher name we have for it */\n\tpublisherDisplayName?: string;\n\textensionDisplayName: string;\n\t/** The agent invoked when no agent is specified */\n\tisDefault?: boolean;\n\t/** This agent is not contributed in package.json, but is registered dynamically */\n\tisDynamic?: boolean;\n\t/** This agent is contributed from core and not from an extension */\n\tisCore?: boolean;\n\tcanAccessPreviousChatHistory?: boolean;\n\tmetadata: IChatAgentMetadata;\n\tslashCommands: IChatAgentCommand[];\n\tlocations: ChatAgentLocation[];\n\t/** This is only relevant for isDefault agents. Others should have all modes available. */\n\tmodes: ChatModeKind[];\n\tdisambiguation: { category: string; description: string; examples: string[] }[];\n\tcapabilities?: IChatAgentAttachmentCapabilities;\n}\n\nexport interface IChatWelcomeMessageContent {\n\ticon: ThemeIcon;\n\ttitle: string;\n\tmessage: IMarkdownString;\n}\n\nexport interface IChatAgentImplementation {\n\tinvoke(request: IChatAgentRequest, progress: (parts: IChatProgress[]) => void, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatAgentResult>;\n\tsetRequestTools?(requestId: string, tools: UserSelectedTools): void;\n\tprovideFollowups?(request: IChatAgentRequest, result: IChatAgentResult, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatFollowup[]>;\n\tprovideChatTitle?: (history: IChatAgentHistoryEntry[], token: CancellationToken) => Promise<string | undefined>;\n\tprovideChatSummary?: (history: IChatAgentHistoryEntry[], token: CancellationToken) => Promise<string | undefined>;\n}\n\nexport interface IChatParticipantDetectionResult {\n\tparticipant: string;\n\tcommand?: string;\n}\n\nexport interface IChatParticipantMetadata {\n\tparticipant: string;\n\tcommand?: string;\n\tdisambiguation: { category: string; description: string; examples: string[] }[];\n}\n\nexport interface IChatParticipantDetectionProvider {\n\tprovideParticipantDetection(request: IChatAgentRequest, history: IChatAgentHistoryEntry[], options: { location: ChatAgentLocation; participants: IChatParticipantMetadata[] }, token: CancellationToken): Promise<IChatParticipantDetectionResult | null | undefined>;\n}\n\nexport type IChatAgent = IChatAgentData & IChatAgentImplementation;\n\nexport interface IChatAgentCommand extends IRawChatCommandContribution {\n\tfollowupPlaceholder?: string;\n}\n\nexport interface IChatAgentMetadata {\n\thelpTextPrefix?: string | IMarkdownString;\n\thelpTextPostfix?: string | IMarkdownString;\n\ticon?: URI;\n\ticonDark?: URI;\n\tthemeIcon?: ThemeIcon;\n\tsampleRequest?: string;\n\tsupportIssueReporting?: boolean;\n\tfollowupPlaceholder?: string;\n\tisSticky?: boolean;\n\tadditionalWelcomeMessage?: string | IMarkdownString;\n}\n\nexport type UserSelectedTools = Record<string, boolean>;\n\n\nexport interface IChatAgentRequest {\n\t/** @deprecated Use {@linkcode sessionResource} instead */\n\tsessionId: string;\n\tsessionResource: URI;\n\trequestId: string;\n\tagentId: string;\n\tcommand?: string;\n\tmessage: string;\n\tattempt?: number;\n\tenableCommandDetection?: boolean;\n\tisParticipantDetected?: boolean;\n\tvariables: IChatRequestVariableData;\n\tlocation: ChatAgentLocation;\n\tlocationData?: Revived<IChatLocationData>;\n\tacceptedConfirmationData?: unknown[];\n\trejectedConfirmationData?: unknown[];\n\tuserSelectedModelId?: string;\n\tuserSelectedTools?: UserSelectedTools;\n\tmodeInstructions?: IChatRequestModeInstructions;\n\teditedFileEvents?: IChatAgentEditedFileEvent[];\n\tisSubagent?: boolean;\n\n}\n\nexport interface IChatQuestion {\n\treadonly prompt: string;\n\treadonly participant?: string;\n\treadonly command?: string;\n}\n\nexport interface IChatAgentResultTimings {\n\tfirstProgress?: number;\n\ttotalElapsed: number;\n}\n\nexport interface IChatAgentResult {\n\terrorDetails?: IChatResponseErrorDetails;\n\ttimings?: IChatAgentResultTimings;\n\t/** Extra properties that the agent can use to identify a result */\n\treadonly metadata?: { readonly [key: string]: unknown };\n\treadonly details?: string;\n\tnextQuestion?: IChatQuestion;\n}\n\nexport const IChatAgentService = createDecorator<IChatAgentService>('chatAgentService');\n\ninterface IChatAgentEntry {\n\tdata: IChatAgentData;\n\timpl?: IChatAgentImplementation;\n}\n\nexport interface IChatAgentCompletionItem {\n\tid: string;\n\tname?: string;\n\tfullName?: string;\n\ticon?: ThemeIcon;\n\tvalue: unknown;\n\tcommand?: Command;\n}\n\nexport interface IChatAgentService {\n\t_serviceBrand: undefined;\n\t/**\n\t * undefined when an agent was removed\n\t */\n\treadonly onDidChangeAgents: Event<IChatAgent | undefined>;\n\treadonly hasToolsAgent: boolean;\n\tregisterAgent(id: string, data: IChatAgentData): IDisposable;\n\tregisterAgentImplementation(id: string, agent: IChatAgentImplementation): IDisposable;\n\tregisterDynamicAgent(data: IChatAgentData, agentImpl: IChatAgentImplementation): IDisposable;\n\tregisterAgentCompletionProvider(id: string, provider: (query: string, token: CancellationToken) => Promise<IChatAgentCompletionItem[]>): IDisposable;\n\tgetAgentCompletionItems(id: string, query: string, token: CancellationToken): Promise<IChatAgentCompletionItem[]>;\n\tregisterChatParticipantDetectionProvider(handle: number, provider: IChatParticipantDetectionProvider): IDisposable;\n\tdetectAgentOrCommand(request: IChatAgentRequest, history: IChatAgentHistoryEntry[], options: { location: ChatAgentLocation }, token: CancellationToken): Promise<{ agent: IChatAgentData; command?: IChatAgentCommand } | undefined>;\n\thasChatParticipantDetectionProviders(): boolean;\n\tinvokeAgent(agent: string, request: IChatAgentRequest, progress: (parts: IChatProgress[]) => void, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatAgentResult>;\n\tsetRequestTools(agent: string, requestId: string, tools: UserSelectedTools): void;\n\tgetFollowups(id: string, request: IChatAgentRequest, result: IChatAgentResult, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatFollowup[]>;\n\tgetChatTitle(id: string, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<string | undefined>;\n\tgetChatSummary(id: string, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<string | undefined>;\n\tgetAgent(id: string, includeDisabled?: boolean): IChatAgentData | undefined;\n\tgetAgentByFullyQualifiedId(id: string): IChatAgentData | undefined;\n\tgetAgents(): IChatAgentData[];\n\tgetActivatedAgents(): Array<IChatAgent>;\n\tgetAgentsByName(name: string): IChatAgentData[];\n\tagentHasDupeName(id: string): boolean;\n\n\t/**\n\t * Get the default agent (only if activated)\n\t */\n\tgetDefaultAgent(location: ChatAgentLocation, mode?: ChatModeKind): IChatAgent | undefined;\n\n\t/**\n\t * Get the default agent data that has been contributed (may not be activated yet)\n\t */\n\tgetContributedDefaultAgent(location: ChatAgentLocation): IChatAgentData | undefined;\n\tupdateAgent(id: string, updateMetadata: IChatAgentMetadata): void;\n}\n\nexport class ChatAgentService extends Disposable implements IChatAgentService {\n\n\tpublic static readonly AGENT_LEADER = '@';\n\n\tdeclare _serviceBrand: undefined;\n\n\tprivate _agents = new Map<string, IChatAgentEntry>();\n\n\tprivate readonly _onDidChangeAgents = new Emitter<IChatAgent | undefined>();\n\treadonly onDidChangeAgents: Event<IChatAgent | undefined> = this._onDidChangeAgents.event;\n\n\tprivate readonly _agentsContextKeys = new Set<string>();\n\tprivate readonly _hasDefaultAgent: IContextKey<boolean>;\n\tprivate readonly _extensionAgentRegistered: IContextKey<boolean>;\n\tprivate readonly _defaultAgentRegistered: IContextKey<boolean>;\n\tprivate _hasToolsAgent = false;\n\n\tprivate _chatParticipantDetectionProviders = new Map<number, IChatParticipantDetectionProvider>();\n\n\tconstructor(\n\t\t@IContextKeyService private readonly contextKeyService: IContextKeyService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t) {\n\t\tsuper();\n\t\tthis._hasDefaultAgent = ChatContextKeys.enabled.bindTo(this.contextKeyService);\n\t\tthis._extensionAgentRegistered = ChatContextKeys.extensionParticipantRegistered.bindTo(this.contextKeyService);\n\t\tthis._defaultAgentRegistered = ChatContextKeys.panelParticipantRegistered.bindTo(this.contextKeyService);\n\t\tthis._register(contextKeyService.onDidChangeContext((e) => {\n\t\t\tif (e.affectsSome(this._agentsContextKeys)) {\n\t\t\t\tthis._updateContextKeys();\n\t\t\t}\n\t\t}));\n\t}\n\n\tregisterAgent(id: string, data: IChatAgentData): IDisposable {\n\t\tconst existingAgent = this.getAgent(id);\n\t\tif (existingAgent) {\n\t\t\tthrow new Error(`Agent already registered: ${JSON.stringify(id)}`);\n\t\t}\n\n\t\tconst that = this;\n\t\tconst commands = data.slashCommands;\n\t\tdata = {\n\t\t\t...data,\n\t\t\tget slashCommands() {\n\t\t\t\treturn commands.filter(c => !c.when || that.contextKeyService.contextMatchesRules(ContextKeyExpr.deserialize(c.when)));\n\t\t\t}\n\t\t};\n\t\tconst entry = { data };\n\t\tthis._agents.set(id, entry);\n\t\tthis._updateAgentsContextKeys();\n\t\tthis._updateContextKeys();\n\t\tthis._onDidChangeAgents.fire(undefined);\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._agents.delete(id);\n\t\t\tthis._updateAgentsContextKeys();\n\t\t\tthis._updateContextKeys();\n\t\t\tthis._onDidChangeAgents.fire(undefined);\n\t\t});\n\t}\n\n\tprivate _updateAgentsContextKeys(): void {\n\t\t// Update the set of context keys used by all agents\n\t\tthis._agentsContextKeys.clear();\n\t\tfor (const agent of this._agents.values()) {\n\t\t\tif (agent.data.when) {\n\t\t\t\tconst expr = ContextKeyExpr.deserialize(agent.data.when);\n\t\t\t\tfor (const key of expr?.keys() || []) {\n\t\t\t\t\tthis._agentsContextKeys.add(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _updateContextKeys(): void {\n\t\tlet extensionAgentRegistered = false;\n\t\tlet defaultAgentRegistered = false;\n\t\tlet toolsAgentRegistered = false;\n\t\tfor (const agent of this.getAgents()) {\n\t\t\tif (agent.isDefault) {\n\t\t\t\tif (!agent.isCore) {\n\t\t\t\t\textensionAgentRegistered = true;\n\t\t\t\t}\n\t\t\t\tif (agent.id === 'chat.setup' || agent.id === 'github.copilot.editsAgent') {\n\t\t\t\t\t// TODO@roblourens firing the event below probably isn't necessary but leave it alone for now\n\t\t\t\t\ttoolsAgentRegistered = true;\n\t\t\t\t} else {\n\t\t\t\t\tdefaultAgentRegistered = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._defaultAgentRegistered.set(defaultAgentRegistered);\n\t\tthis._extensionAgentRegistered.set(extensionAgentRegistered);\n\t\tif (toolsAgentRegistered !== this._hasToolsAgent) {\n\t\t\tthis._hasToolsAgent = toolsAgentRegistered;\n\t\t\tthis._onDidChangeAgents.fire(this.getDefaultAgent(ChatAgentLocation.Chat, ChatModeKind.Agent));\n\t\t}\n\t}\n\n\tregisterAgentImplementation(id: string, agentImpl: IChatAgentImplementation): IDisposable {\n\t\tconst entry = this._agents.get(id);\n\t\tif (!entry) {\n\t\t\tthrow new Error(`Unknown agent: ${JSON.stringify(id)}`);\n\t\t}\n\n\t\tif (entry.impl) {\n\t\t\tthrow new Error(`Agent already has implementation: ${JSON.stringify(id)}`);\n\t\t}\n\n\t\tif (entry.data.isDefault) {\n\t\t\tthis._hasDefaultAgent.set(true);\n\t\t}\n\n\t\tentry.impl = agentImpl;\n\t\tthis._onDidChangeAgents.fire(new MergedChatAgent(entry.data, agentImpl));\n\n\t\treturn toDisposable(() => {\n\t\t\tentry.impl = undefined;\n\t\t\tthis._onDidChangeAgents.fire(undefined);\n\n\t\t\tif (entry.data.isDefault) {\n\t\t\t\tthis._hasDefaultAgent.set(Iterable.some(this._agents.values(), agent => agent.data.isDefault));\n\t\t\t}\n\t\t});\n\t}\n\n\tregisterDynamicAgent(data: IChatAgentData, agentImpl: IChatAgentImplementation): IDisposable {\n\t\tdata.isDynamic = true;\n\t\tconst agent = { data, impl: agentImpl };\n\t\tthis._agents.set(data.id, agent);\n\t\tthis._onDidChangeAgents.fire(new MergedChatAgent(data, agentImpl));\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._agents.delete(data.id);\n\t\t\tthis._onDidChangeAgents.fire(undefined);\n\t\t});\n\t}\n\n\tprivate _agentCompletionProviders = new Map<string, (query: string, token: CancellationToken) => Promise<IChatAgentCompletionItem[]>>();\n\n\tregisterAgentCompletionProvider(id: string, provider: (query: string, token: CancellationToken) => Promise<IChatAgentCompletionItem[]>) {\n\t\tthis._agentCompletionProviders.set(id, provider);\n\t\treturn {\n\t\t\tdispose: () => { this._agentCompletionProviders.delete(id); }\n\t\t};\n\t}\n\n\tasync getAgentCompletionItems(id: string, query: string, token: CancellationToken) {\n\t\treturn await this._agentCompletionProviders.get(id)?.(query, token) ?? [];\n\t}\n\n\tupdateAgent(id: string, updateMetadata: IChatAgentMetadata): void {\n\t\tconst agent = this._agents.get(id);\n\t\tif (!agent?.impl) {\n\t\t\tthrow new Error(`No activated agent with id ${JSON.stringify(id)} registered`);\n\t\t}\n\t\tagent.data.metadata = { ...agent.data.metadata, ...updateMetadata };\n\t\tthis._onDidChangeAgents.fire(new MergedChatAgent(agent.data, agent.impl));\n\t}\n\n\tgetDefaultAgent(location: ChatAgentLocation, mode: ChatModeKind = ChatModeKind.Ask): IChatAgent | undefined {\n\t\treturn this._preferExtensionAgent(this.getActivatedAgents().filter(a => {\n\t\t\tif (mode && !a.modes.includes(mode)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn !!a.isDefault && a.locations.includes(location);\n\t\t}));\n\t}\n\n\tpublic get hasToolsAgent(): boolean {\n\t\t// The chat participant enablement is just based on this setting. Don't wait for the extension to be loaded.\n\t\treturn !!this.configurationService.getValue(ChatConfiguration.AgentEnabled);\n\t}\n\n\tgetContributedDefaultAgent(location: ChatAgentLocation): IChatAgentData | undefined {\n\t\treturn this._preferExtensionAgent(this.getAgents().filter(a => !!a.isDefault && a.locations.includes(location)));\n\t}\n\n\tprivate _preferExtensionAgent<T extends IChatAgentData>(agents: T[]): T | undefined {\n\t\t// We potentially have multiple agents on the same location,\n\t\t// contributed from core and from extensions.\n\t\t// This method will prefer the last extensions provided agent\n\t\t// falling back to the last core agent if no extension agent is found.\n\t\treturn findLast(agents, agent => !agent.isCore) ?? agents.at(-1);\n\t}\n\n\tgetAgent(id: string, includeDisabled = false): IChatAgentData | undefined {\n\t\tif (!this._agentIsEnabled(id) && !includeDisabled) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this._agents.get(id)?.data;\n\t}\n\n\tprivate _agentIsEnabled(idOrAgent: string | IChatAgentEntry): boolean {\n\t\tconst entry = typeof idOrAgent === 'string' ? this._agents.get(idOrAgent) : idOrAgent;\n\t\treturn !entry?.data.when || this.contextKeyService.contextMatchesRules(ContextKeyExpr.deserialize(entry.data.when));\n\t}\n\n\tgetAgentByFullyQualifiedId(id: string): IChatAgentData | undefined {\n\t\tconst agent = Iterable.find(this._agents.values(), a => getFullyQualifiedId(a.data) === id)?.data;\n\t\tif (agent && !this._agentIsEnabled(agent.id)) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn agent;\n\t}\n\n\t/**\n\t * Returns all agent datas that exist- static registered and dynamic ones.\n\t */\n\tgetAgents(): IChatAgentData[] {\n\t\treturn Array.from(this._agents.values())\n\t\t\t.map(entry => entry.data)\n\t\t\t.filter(a => this._agentIsEnabled(a.id));\n\t}\n\n\tgetActivatedAgents(): IChatAgent[] {\n\t\treturn Array.from(this._agents.values())\n\t\t\t.filter(a => !!a.impl)\n\t\t\t.filter(a => this._agentIsEnabled(a.data.id))\n\t\t\t.map(a => new MergedChatAgent(a.data, a.impl!));\n\t}\n\n\tgetAgentsByName(name: string): IChatAgentData[] {\n\t\treturn this._preferExtensionAgents(this.getAgents().filter(a => a.name === name));\n\t}\n\n\tprivate _preferExtensionAgents<T extends IChatAgentData>(agents: T[]): T[] {\n\t\t// We potentially have multiple agents on the same location,\n\t\t// contributed from core and from extensions.\n\t\t// This method will prefer the extensions provided agents\n\t\t// falling back to the original agents array extension agent is found.\n\t\tconst extensionAgents = agents.filter(a => !a.isCore);\n\t\treturn extensionAgents.length > 0 ? extensionAgents : agents;\n\t}\n\n\tagentHasDupeName(id: string): boolean {\n\t\tconst agent = this.getAgent(id);\n\t\tif (!agent) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.getAgentsByName(agent.name)\n\t\t\t.filter(a => a.extensionId.value !== agent.extensionId.value).length > 0;\n\t}\n\n\tasync invokeAgent(id: string, request: IChatAgentRequest, progress: (parts: IChatProgress[]) => void, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatAgentResult> {\n\t\tconst data = this._agents.get(id);\n\t\tif (!data?.impl) {\n\t\t\tthrow new Error(`No activated agent with id \"${id}\"`);\n\t\t}\n\n\t\treturn await data.impl.invoke(request, progress, history, token);\n\t}\n\n\tsetRequestTools(id: string, requestId: string, tools: UserSelectedTools): void {\n\t\tconst data = this._agents.get(id);\n\t\tif (!data?.impl) {\n\t\t\tthrow new Error(`No activated agent with id \"${id}\"`);\n\t\t}\n\n\t\tdata.impl.setRequestTools?.(requestId, tools);\n\t}\n\n\tasync getFollowups(id: string, request: IChatAgentRequest, result: IChatAgentResult, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatFollowup[]> {\n\t\tconst data = this._agents.get(id);\n\t\tif (!data?.impl?.provideFollowups) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn data.impl.provideFollowups(request, result, history, token);\n\t}\n\n\tasync getChatTitle(id: string, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<string | undefined> {\n\t\tconst data = this._agents.get(id);\n\t\tif (!data?.impl?.provideChatTitle) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn data.impl.provideChatTitle(history, token);\n\t}\n\n\tasync getChatSummary(id: string, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<string | undefined> {\n\t\tconst data = this._agents.get(id);\n\t\tif (!data?.impl?.provideChatSummary) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn data.impl.provideChatSummary(history, token);\n\t}\n\n\tregisterChatParticipantDetectionProvider(handle: number, provider: IChatParticipantDetectionProvider) {\n\t\tthis._chatParticipantDetectionProviders.set(handle, provider);\n\t\treturn toDisposable(() => {\n\t\t\tthis._chatParticipantDetectionProviders.delete(handle);\n\t\t});\n\t}\n\n\thasChatParticipantDetectionProviders() {\n\t\treturn this._chatParticipantDetectionProviders.size > 0;\n\t}\n\n\tasync detectAgentOrCommand(request: IChatAgentRequest, history: IChatAgentHistoryEntry[], options: { location: ChatAgentLocation }, token: CancellationToken): Promise<{ agent: IChatAgentData; command?: IChatAgentCommand } | undefined> {\n\t\t// TODO@joyceerhl should we have a selector to be able to narrow down which provider to use\n\t\tconst provider = Iterable.first(this._chatParticipantDetectionProviders.values());\n\t\tif (!provider) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst participants = this.getAgents().reduce<IChatParticipantMetadata[]>((acc, a) => {\n\t\t\tif (a.locations.includes(options.location)) {\n\t\t\t\tacc.push({ participant: a.id, disambiguation: a.disambiguation ?? [] });\n\t\t\t\tfor (const command of a.slashCommands) {\n\t\t\t\t\tacc.push({ participant: a.id, command: command.name, disambiguation: command.disambiguation ?? [] });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst result = await provider.provideParticipantDetection(request, history, { ...options, participants }, token);\n\t\tif (!result) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst agent = this.getAgent(result.participant);\n\t\tif (!agent) {\n\t\t\t// Couldn't find a participant matching the participant detection result\n\t\t\treturn;\n\t\t}\n\n\t\tif (!result.command) {\n\t\t\treturn { agent };\n\t\t}\n\n\t\tconst command = agent?.slashCommands.find(c => c.name === result.command);\n\t\tif (!command) {\n\t\t\t// Couldn't find a slash command matching the participant detection result\n\t\t\treturn;\n\t\t}\n\n\t\treturn { agent, command };\n\t}\n}\n\nexport class MergedChatAgent implements IChatAgent {\n\tconstructor(\n\t\tprivate readonly data: IChatAgentData,\n\t\tprivate readonly impl: IChatAgentImplementation\n\t) { }\n\twhen?: string | undefined;\n\tpublisherDisplayName?: string | undefined;\n\tisDynamic?: boolean | undefined;\n\n\tget id(): string { return this.data.id; }\n\tget name(): string { return this.data.name ?? ''; }\n\tget fullName(): string { return this.data.fullName ?? ''; }\n\tget description(): string { return this.data.description ?? ''; }\n\tget extensionId(): ExtensionIdentifier { return this.data.extensionId; }\n\tget extensionVersion(): string | undefined { return this.data.extensionVersion; }\n\tget extensionPublisherId(): string { return this.data.extensionPublisherId; }\n\tget extensionPublisherDisplayName() { return this.data.publisherDisplayName; }\n\tget extensionDisplayName(): string { return this.data.extensionDisplayName; }\n\tget isDefault(): boolean | undefined { return this.data.isDefault; }\n\tget isCore(): boolean | undefined { return this.data.isCore; }\n\tget metadata(): IChatAgentMetadata { return this.data.metadata; }\n\tget slashCommands(): IChatAgentCommand[] { return this.data.slashCommands; }\n\tget locations(): ChatAgentLocation[] { return this.data.locations; }\n\tget modes(): ChatModeKind[] { return this.data.modes; }\n\tget disambiguation(): { category: string; description: string; examples: string[] }[] { return this.data.disambiguation; }\n\n\tasync invoke(request: IChatAgentRequest, progress: (parts: IChatProgress[]) => void, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatAgentResult> {\n\t\treturn this.impl.invoke(request, progress, history, token);\n\t}\n\n\tsetRequestTools(requestId: string, tools: UserSelectedTools): void {\n\t\tthis.impl.setRequestTools?.(requestId, tools);\n\t}\n\n\tasync provideFollowups(request: IChatAgentRequest, result: IChatAgentResult, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatFollowup[]> {\n\t\tif (this.impl.provideFollowups) {\n\t\t\treturn this.impl.provideFollowups(request, result, history, token);\n\t\t}\n\n\t\treturn [];\n\t}\n\n\ttoJSON(): IChatAgentData {\n\t\treturn this.data;\n\t}\n}\n\nexport const IChatAgentNameService = createDecorator<IChatAgentNameService>('chatAgentNameService');\n\ntype IChatParticipantRegistry = { [name: string]: string[] };\n\ninterface IChatParticipantRegistryResponse {\n\treadonly version: number;\n\treadonly restrictedChatParticipants: IChatParticipantRegistry;\n}\n\nexport interface IChatAgentNameService {\n\t_serviceBrand: undefined;\n\tgetAgentNameRestriction(chatAgentData: IChatAgentData): boolean;\n}\n\nexport class ChatAgentNameService implements IChatAgentNameService {\n\n\tprivate static readonly StorageKey = 'chat.participantNameRegistry';\n\n\tdeclare _serviceBrand: undefined;\n\n\tprivate readonly url!: string;\n\tprivate registry = observableValue<IChatParticipantRegistry>(this, Object.create(null));\n\tprivate disposed = false;\n\n\tconstructor(\n\t\t@IProductService productService: IProductService,\n\t\t@IRequestService private readonly requestService: IRequestService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStorageService private readonly storageService: IStorageService\n\t) {\n\t\tif (!productService.chatParticipantRegistry) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.url = productService.chatParticipantRegistry;\n\n\t\tconst raw = storageService.get(ChatAgentNameService.StorageKey, StorageScope.APPLICATION);\n\n\t\ttry {\n\t\t\tthis.registry.set(JSON.parse(raw ?? '{}'), undefined);\n\t\t} catch (err) {\n\t\t\tstorageService.remove(ChatAgentNameService.StorageKey, StorageScope.APPLICATION);\n\t\t}\n\n\t\tthis.refresh();\n\t}\n\n\tprivate refresh(): void {\n\t\tif (this.disposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.update()\n\t\t\t.catch(err => this.logService.warn('Failed to fetch chat participant registry', err))\n\t\t\t.then(() => timeout(5 * 60 * 1000)) // every 5 minutes\n\t\t\t.then(() => this.refresh());\n\t}\n\n\tprivate async update(): Promise<void> {\n\t\tconst context = await this.requestService.request({ type: 'GET', url: this.url }, CancellationToken.None);\n\n\t\tif (context.res.statusCode !== 200) {\n\t\t\tthrow new Error('Could not get extensions report.');\n\t\t}\n\n\t\tconst result = await asJson<IChatParticipantRegistryResponse>(context);\n\n\t\tif (!result || result.version !== 1) {\n\t\t\tthrow new Error('Unexpected chat participant registry response.');\n\t\t}\n\n\t\tconst registry = result.restrictedChatParticipants;\n\t\tthis.registry.set(registry, undefined);\n\t\tthis.storageService.store(ChatAgentNameService.StorageKey, JSON.stringify(registry), StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t}\n\n\t/**\n\t * Returns true if the agent is allowed to use this name\n\t */\n\tgetAgentNameRestriction(chatAgentData: IChatAgentData): boolean {\n\t\tif (chatAgentData.isCore) {\n\t\t\treturn true; // core agents are always allowed to use any name\n\t\t}\n\n\t\t// TODO would like to use observables here but nothing uses it downstream and I'm not sure how to combine these two\n\t\tconst nameAllowed = this.checkAgentNameRestriction(chatAgentData.name, chatAgentData).get();\n\t\tconst fullNameAllowed = !chatAgentData.fullName || this.checkAgentNameRestriction(chatAgentData.fullName.replace(/\\s/g, ''), chatAgentData).get();\n\t\treturn nameAllowed && fullNameAllowed;\n\t}\n\n\tprivate checkAgentNameRestriction(name: string, chatAgentData: IChatAgentData): IObservable<boolean> {\n\t\t// Registry is a map of name to an array of extension publisher IDs or extension IDs that are allowed to use it.\n\t\t// Look up the list of extensions that are allowed to use this name\n\t\tconst allowList = this.registry.map<string[] | undefined>(registry => registry[name.toLowerCase()]);\n\t\treturn allowList.map(allowList => {\n\t\t\tif (!allowList) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn allowList.some(id => equalsIgnoreCase(id, id.includes('.') ? chatAgentData.extensionId.value : chatAgentData.extensionPublisherId));\n\t\t});\n\t}\n\n\tdispose() {\n\t\tthis.disposed = true;\n\t}\n}\n\nexport function getFullyQualifiedId(chatAgentData: IChatAgentData): string {\n\treturn `${chatAgentData.extensionId.value}.${chatAgentData.id}`;\n}\n\n/**\n * There was a period where serialized chat agent data used 'id' instead of 'name'.\n * Don't copy this pattern, serialized data going forward should be versioned with strict interfaces.\n */\ninterface IOldSerializedChatAgentData extends Omit<ISerializableChatAgentData, 'name'> {\n\tid: string;\n\textensionPublisher?: string;\n}\n\nexport function reviveSerializedAgent(raw: ISerializableChatAgentData | IOldSerializedChatAgentData): IChatAgentData {\n\tconst normalized: ISerializableChatAgentData = 'name' in raw ?\n\t\traw :\n\t\t{\n\t\t\t...raw,\n\t\t\tname: raw.id,\n\t\t};\n\n\t// Fill in required fields that may be missing from old data\n\tif (!normalized.extensionPublisherId) {\n\t\tnormalized.extensionPublisherId = (raw as IOldSerializedChatAgentData).extensionPublisher ?? '';\n\t}\n\n\tif (!normalized.extensionDisplayName) {\n\t\tnormalized.extensionDisplayName = '';\n\t}\n\n\tif (!normalized.extensionId) {\n\t\tnormalized.extensionId = new ExtensionIdentifier('');\n\t}\n\n\treturn revive(normalized);\n}\n"]}