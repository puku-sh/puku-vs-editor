{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/common/chatUrlFetchingPatterns.ts","vs/workbench/contrib/chat/common/chatUrlFetchingPatterns.ts"],"names":[],"mappings":"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","file":"chatUrlFetchingPatterns.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { normalizeURL } from '../../url/common/trustedDomains.js';\nimport { testUrlMatchesGlob } from '../../url/common/urlGlob.js';\n\n/**\n * Approval settings for a URL pattern\n */\nexport interface IUrlApprovalSettings {\n\tapproveRequest?: boolean;\n\tapproveResponse?: boolean;\n}\n\n/**\n * Extracts domain patterns from a URL for use in approval actions\n * @param url The URL to extract patterns from\n * @returns An array of patterns in order of specificity (most specific first)\n */\nexport function extractUrlPatterns(url: URI): string[] {\n\tconst normalizedStr = normalizeURL(url);\n\tconst normalized = URI.parse(normalizedStr);\n\tconst patterns = new Set<string>();\n\n\t// Full URL (most specific)\n\tconst fullUrl = normalized.toString(true);\n\tpatterns.add(fullUrl);\n\n\t// Domain-only pattern (without trailing slash)\n\tconst domainOnly = normalized.with({ path: '', query: '', fragment: '' }).toString(true);\n\tpatterns.add(domainOnly);\n\n\t// Wildcard subdomain pattern (*.example.com)\n\tconst authority = normalized.authority;\n\tconst domainParts = authority.split('.');\n\n\t// Only add wildcard subdomain if there are at least 2 parts and it's not an IP\n\tconst isIPv4 = domainParts.length === 4 && domainParts.every((segment: string) =>\n\t\tNumber.isInteger(+segment));\n\tconst isIPv6 = authority.includes(':') && authority.match(/^(\\[)?[0-9a-fA-F:]+(\\])?(?::\\d+)?$/);\n\tconst isIP = isIPv4 || isIPv6;\n\n\t// Only emit subdomain patterns if there are actually subdomains (more than 2 parts)\n\tif (!isIP && domainParts.length > 2) {\n\t\t// Create patterns by replacing each subdomain segment with *\n\t\t// For example, foo.bar.example.com -> *.bar.example.com, *.example.com\n\t\tfor (let i = 0; i < domainParts.length - 2; i++) {\n\t\t\tconst wildcardAuthority = '*.' + domainParts.slice(i + 1).join('.');\n\t\t\tconst wildcardPattern = normalized.with({\n\t\t\t\tauthority: wildcardAuthority,\n\t\t\t\tpath: '',\n\t\t\t\tquery: '',\n\t\t\t\tfragment: ''\n\t\t\t}).toString(true);\n\t\t\tpatterns.add(wildcardPattern);\n\t\t}\n\t}\n\n\t// Path patterns (if there's a non-trivial path)\n\tconst pathSegments = normalized.path.split('/').filter((s: string) => s.length > 0);\n\tif (pathSegments.length > 0) {\n\t\t// Add patterns for each path level with wildcard\n\t\tfor (let i = pathSegments.length - 1; i >= 0; i--) {\n\t\t\tconst pathPattern = pathSegments.slice(0, i).join('/');\n\t\t\tconst urlWithPathPattern = normalized.with({\n\t\t\t\tpath: (i > 0 ? '/' : '') + pathPattern,\n\t\t\t\tquery: '',\n\t\t\t\tfragment: ''\n\t\t\t}).toString(true);\n\t\t\tpatterns.add(urlWithPathPattern);\n\t\t}\n\t}\n\n\treturn [...patterns].map(p => p.replace(/\\/+$/, ''));\n}\n\n/**\n * Generates user-friendly labels for URL patterns to show in quick pick\n * @param url The original URL\n * @param pattern The pattern to generate a label for\n * @returns A user-friendly label describing what the pattern matches (without protocol)\n */\nexport function getPatternLabel(url: URI, pattern: string): string {\n\tlet displayPattern = pattern;\n\n\tif (displayPattern.startsWith('https://')) {\n\t\tdisplayPattern = displayPattern.substring(8);\n\t} else if (displayPattern.startsWith('http://')) {\n\t\tdisplayPattern = displayPattern.substring(7);\n\t}\n\n\treturn displayPattern.replace(/\\/+$/, ''); // Remove trailing slashes\n}\n\n/**\n * Checks if a URL matches any approved pattern\n * @param url The URL to check\n * @param approvedUrls Map of approved URL patterns to their settings\n * @param checkRequest Whether to check request approval (true) or response approval (false)\n * @returns true if the URL is approved for the specified action\n */\nexport function isUrlApproved(\n\turl: URI,\n\tapprovedUrls: Record<string, boolean | IUrlApprovalSettings>,\n\tcheckRequest: boolean\n): boolean {\n\tconst normalizedUrlStr = normalizeURL(url);\n\tconst normalizedUrl = URI.parse(normalizedUrlStr);\n\n\tfor (const [pattern, settings] of Object.entries(approvedUrls)) {\n\t\t// Check if URL matches this pattern\n\t\tif (testUrlMatchesGlob(normalizedUrl, pattern)) {\n\t\t\t// Handle boolean settings\n\t\t\tif (typeof settings === 'boolean') {\n\t\t\t\treturn settings;\n\t\t\t}\n\n\t\t\t// Handle granular settings\n\t\t\tif (checkRequest && settings.approveRequest !== undefined) {\n\t\t\t\treturn settings.approveRequest;\n\t\t\t}\n\n\t\t\tif (!checkRequest && settings.approveResponse !== undefined) {\n\t\t\t\treturn settings.approveResponse;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Gets the most specific matching pattern for a URL\n * @param url The URL to find a matching pattern for\n * @param approvedUrls Map of approved URL patterns\n * @returns The most specific matching pattern, or undefined if none match\n */\nexport function getMatchingPattern(\n\turl: URI,\n\tapprovedUrls: Record<string, boolean | IUrlApprovalSettings>\n): string | undefined {\n\tconst normalizedUrlStr = normalizeURL(url);\n\tconst normalizedUrl = URI.parse(normalizedUrlStr);\n\tconst patterns = extractUrlPatterns(url);\n\n\t// Check patterns in order of specificity (most specific first)\n\tfor (const pattern of patterns) {\n\t\tfor (const approvedPattern of Object.keys(approvedUrls)) {\n\t\t\tif (testUrlMatchesGlob(normalizedUrl, approvedPattern) && testUrlMatchesGlob(URI.parse(pattern), approvedPattern)) {\n\t\t\t\treturn approvedPattern;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { normalizeURL } from '../../url/common/trustedDomains.js';\nimport { testUrlMatchesGlob } from '../../url/common/urlGlob.js';\n\n/**\n * Approval settings for a URL pattern\n */\nexport interface IUrlApprovalSettings {\n\tapproveRequest?: boolean;\n\tapproveResponse?: boolean;\n}\n\n/**\n * Extracts domain patterns from a URL for use in approval actions\n * @param url The URL to extract patterns from\n * @returns An array of patterns in order of specificity (most specific first)\n */\nexport function extractUrlPatterns(url: URI): string[] {\n\tconst normalizedStr = normalizeURL(url);\n\tconst normalized = URI.parse(normalizedStr);\n\tconst patterns = new Set<string>();\n\n\t// Full URL (most specific)\n\tconst fullUrl = normalized.toString(true);\n\tpatterns.add(fullUrl);\n\n\t// Domain-only pattern (without trailing slash)\n\tconst domainOnly = normalized.with({ path: '', query: '', fragment: '' }).toString(true);\n\tpatterns.add(domainOnly);\n\n\t// Wildcard subdomain pattern (*.example.com)\n\tconst authority = normalized.authority;\n\tconst domainParts = authority.split('.');\n\n\t// Only add wildcard subdomain if there are at least 2 parts and it's not an IP\n\tconst isIPv4 = domainParts.length === 4 && domainParts.every((segment: string) =>\n\t\tNumber.isInteger(+segment));\n\tconst isIPv6 = authority.includes(':') && authority.match(/^(\\[)?[0-9a-fA-F:]+(\\])?(?::\\d+)?$/);\n\tconst isIP = isIPv4 || isIPv6;\n\n\t// Only emit subdomain patterns if there are actually subdomains (more than 2 parts)\n\tif (!isIP && domainParts.length > 2) {\n\t\t// Create patterns by replacing each subdomain segment with *\n\t\t// For example, foo.bar.example.com -> *.bar.example.com, *.example.com\n\t\tfor (let i = 0; i < domainParts.length - 2; i++) {\n\t\t\tconst wildcardAuthority = '*.' + domainParts.slice(i + 1).join('.');\n\t\t\tconst wildcardPattern = normalized.with({\n\t\t\t\tauthority: wildcardAuthority,\n\t\t\t\tpath: '',\n\t\t\t\tquery: '',\n\t\t\t\tfragment: ''\n\t\t\t}).toString(true);\n\t\t\tpatterns.add(wildcardPattern);\n\t\t}\n\t}\n\n\t// Path patterns (if there's a non-trivial path)\n\tconst pathSegments = normalized.path.split('/').filter((s: string) => s.length > 0);\n\tif (pathSegments.length > 0) {\n\t\t// Add patterns for each path level with wildcard\n\t\tfor (let i = pathSegments.length - 1; i >= 0; i--) {\n\t\t\tconst pathPattern = pathSegments.slice(0, i).join('/');\n\t\t\tconst urlWithPathPattern = normalized.with({\n\t\t\t\tpath: (i > 0 ? '/' : '') + pathPattern,\n\t\t\t\tquery: '',\n\t\t\t\tfragment: ''\n\t\t\t}).toString(true);\n\t\t\tpatterns.add(urlWithPathPattern);\n\t\t}\n\t}\n\n\treturn [...patterns].map(p => p.replace(/\\/+$/, ''));\n}\n\n/**\n * Generates user-friendly labels for URL patterns to show in quick pick\n * @param url The original URL\n * @param pattern The pattern to generate a label for\n * @returns A user-friendly label describing what the pattern matches (without protocol)\n */\nexport function getPatternLabel(url: URI, pattern: string): string {\n\tlet displayPattern = pattern;\n\n\tif (displayPattern.startsWith('https://')) {\n\t\tdisplayPattern = displayPattern.substring(8);\n\t} else if (displayPattern.startsWith('http://')) {\n\t\tdisplayPattern = displayPattern.substring(7);\n\t}\n\n\treturn displayPattern.replace(/\\/+$/, ''); // Remove trailing slashes\n}\n\n/**\n * Checks if a URL matches any approved pattern\n * @param url The URL to check\n * @param approvedUrls Map of approved URL patterns to their settings\n * @param checkRequest Whether to check request approval (true) or response approval (false)\n * @returns true if the URL is approved for the specified action\n */\nexport function isUrlApproved(\n\turl: URI,\n\tapprovedUrls: Record<string, boolean | IUrlApprovalSettings>,\n\tcheckRequest: boolean\n): boolean {\n\tconst normalizedUrlStr = normalizeURL(url);\n\tconst normalizedUrl = URI.parse(normalizedUrlStr);\n\n\tfor (const [pattern, settings] of Object.entries(approvedUrls)) {\n\t\t// Check if URL matches this pattern\n\t\tif (testUrlMatchesGlob(normalizedUrl, pattern)) {\n\t\t\t// Handle boolean settings\n\t\t\tif (typeof settings === 'boolean') {\n\t\t\t\treturn settings;\n\t\t\t}\n\n\t\t\t// Handle granular settings\n\t\t\tif (checkRequest && settings.approveRequest !== undefined) {\n\t\t\t\treturn settings.approveRequest;\n\t\t\t}\n\n\t\t\tif (!checkRequest && settings.approveResponse !== undefined) {\n\t\t\t\treturn settings.approveResponse;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Gets the most specific matching pattern for a URL\n * @param url The URL to find a matching pattern for\n * @param approvedUrls Map of approved URL patterns\n * @returns The most specific matching pattern, or undefined if none match\n */\nexport function getMatchingPattern(\n\turl: URI,\n\tapprovedUrls: Record<string, boolean | IUrlApprovalSettings>\n): string | undefined {\n\tconst normalizedUrlStr = normalizeURL(url);\n\tconst normalizedUrl = URI.parse(normalizedUrlStr);\n\tconst patterns = extractUrlPatterns(url);\n\n\t// Check patterns in order of specificity (most specific first)\n\tfor (const pattern of patterns) {\n\t\tfor (const approvedPattern of Object.keys(approvedUrls)) {\n\t\t\tif (testUrlMatchesGlob(normalizedUrl, approvedPattern) && testUrlMatchesGlob(URI.parse(pattern), approvedPattern)) {\n\t\t\t\treturn approvedPattern;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n"]}