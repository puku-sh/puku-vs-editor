{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/test/browser/languageModelToolsService.test.ts","vs/workbench/contrib/chat/test/browser/languageModelToolsService.test.ts"],"names":[],"mappings":"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","file":"languageModelToolsService.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport { Barrier } from '../../../../../base/common/async.js';\nimport { VSBuffer } from '../../../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { CancellationError, isCancellationError } from '../../../../../base/common/errors.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { IAccessibilityService } from '../../../../../platform/accessibility/common/accessibility.js';\nimport { TestAccessibilityService } from '../../../../../platform/accessibility/test/common/testAccessibilityService.js';\nimport { AccessibilitySignal, IAccessibilitySignalService } from '../../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js';\nimport { ConfigurationTarget, IConfigurationChangeEvent } from '../../../../../platform/configuration/common/configuration.js';\nimport { TestConfigurationService } from '../../../../../platform/configuration/test/common/testConfigurationService.js';\nimport { ContextKeyService } from '../../../../../platform/contextkey/browser/contextKeyService.js';\nimport { ContextKeyEqualsExpr, IContextKeyService } from '../../../../../platform/contextkey/common/contextkey.js';\nimport { ExtensionIdentifier } from '../../../../../platform/extensions/common/extensions.js';\nimport { ITelemetryService } from '../../../../../platform/telemetry/common/telemetry.js';\nimport { workbenchInstantiationService } from '../../../../test/browser/workbenchTestServices.js';\nimport { LanguageModelToolsService } from '../../browser/languageModelToolsService.js';\nimport { ChatModel, IChatModel } from '../../common/chatModel.js';\nimport { IChatService, IChatToolInputInvocationData, IChatToolInvocation, ToolConfirmKind } from '../../common/chatService.js';\nimport { ChatConfiguration } from '../../common/constants.js';\nimport { GithubCopilotToolReference, isToolResultInputOutputDetails, IToolData, IToolImpl, IToolInvocation, ToolDataSource, ToolSet, VSCodeToolReference } from '../../common/languageModelToolsService.js';\nimport { MockChatService } from '../common/mockChatService.js';\nimport { ChatToolInvocation } from '../../common/chatProgressTypes/chatToolInvocation.js';\nimport { LocalChatSessionUri } from '../../common/chatUri.js';\nimport { ILanguageModelToolsConfirmationService } from '../../common/languageModelToolsConfirmationService.js';\nimport { MockLanguageModelToolsConfirmationService } from '../common/mockLanguageModelToolsConfirmationService.js';\nimport { runWithFakedTimers } from '../../../../../base/test/common/timeTravelScheduler.js';\n\n// --- Test helpers to reduce repetition and improve readability ---\n\nclass TestAccessibilitySignalService implements Partial<IAccessibilitySignalService> {\n\tpublic signalPlayedCalls: { signal: AccessibilitySignal; options?: any }[] = [];\n\n\tasync playSignal(signal: AccessibilitySignal, options?: any): Promise<void> {\n\t\tthis.signalPlayedCalls.push({ signal, options });\n\t}\n\n\treset() {\n\t\tthis.signalPlayedCalls = [];\n\t}\n}\n\nclass TestTelemetryService implements Partial<ITelemetryService> {\n\tpublic events: Array<{ eventName: string; data: any }> = [];\n\n\tpublicLog2<E extends Record<string, any>, T extends Record<string, any>>(eventName: string, data?: E): void {\n\t\tthis.events.push({ eventName, data });\n\t}\n\n\treset() {\n\t\tthis.events = [];\n\t}\n}\n\nfunction registerToolForTest(service: LanguageModelToolsService, store: any, id: string, impl: IToolImpl, data?: Partial<IToolData>) {\n\tconst toolData: IToolData = {\n\t\tid,\n\t\tmodelDescription: data?.modelDescription ?? 'Test Tool',\n\t\tdisplayName: data?.displayName ?? 'Test Tool',\n\t\tsource: ToolDataSource.Internal,\n\t\t...data,\n\t};\n\tstore.add(service.registerTool(toolData, impl));\n\treturn {\n\t\tid,\n\t\tmakeDto: (parameters: any, context?: { sessionId: string }, callId: string = '1'): IToolInvocation => ({\n\t\t\tcallId,\n\t\t\ttoolId: id,\n\t\t\ttokenBudget: 100,\n\t\t\tparameters,\n\t\t\tcontext: context ? {\n\t\t\t\tsessionId: context.sessionId,\n\t\t\t\tsessionResource: LocalChatSessionUri.forSession(context.sessionId),\n\t\t\t} : undefined,\n\t\t}),\n\t};\n}\n\nfunction stubGetSession(chatService: MockChatService, sessionId: string, options?: { requestId?: string; capture?: { invocation?: any } }): IChatModel {\n\tconst requestId = options?.requestId ?? 'requestId';\n\tconst capture = options?.capture;\n\tconst fakeModel = {\n\t\tsessionId,\n\t\tsessionResource: LocalChatSessionUri.forSession(sessionId),\n\t\tgetRequests: () => [{ id: requestId, modelId: 'test-model' }],\n\t} as ChatModel;\n\tchatService.addSession(fakeModel);\n\tchatService.appendProgress = (request, progress) => {\n\t\tif (capture) { capture.invocation = progress; }\n\t};\n\n\treturn fakeModel;\n}\n\nasync function waitForPublishedInvocation(capture: { invocation?: any }, tries = 5): Promise<ChatToolInvocation> {\n\tfor (let i = 0; i < tries && !capture.invocation; i++) {\n\t\tawait Promise.resolve();\n\t}\n\treturn capture.invocation;\n}\n\nsuite('LanguageModelToolsService', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tlet contextKeyService: IContextKeyService;\n\tlet service: LanguageModelToolsService;\n\tlet chatService: MockChatService;\n\tlet configurationService: TestConfigurationService;\n\n\tsetup(() => {\n\t\tconfigurationService = new TestConfigurationService();\n\t\tconfigurationService.setUserConfiguration(ChatConfiguration.ExtensionToolsEnabled, true);\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(configurationService)),\n\t\t\tconfigurationService: () => configurationService\n\t\t}, store);\n\t\tcontextKeyService = instaService.get(IContextKeyService);\n\t\tchatService = new MockChatService();\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tservice = store.add(instaService.createInstance(LanguageModelToolsService));\n\t});\n\n\tfunction setupToolsForTest(service: LanguageModelToolsService, store: any) {\n\n\t\t// Create a variety of tools and tool sets for testing\n\t\t// Some with toolReferenceName, some without, some from extensions, mcp and user defined\n\n\t\tconst tool1: IToolData = {\n\t\t\tid: 'tool1',\n\t\t\ttoolReferenceName: 'tool1RefName',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\tdisplayName: 'Tool1 Display Name',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(tool1));\n\n\t\tconst tool2: IToolData = {\n\t\t\tid: 'tool2',\n\t\t\tmodelDescription: 'Test Tool 2',\n\t\t\tdisplayName: 'Tool2 Display Name',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(tool2));\n\n\t\t/** Extension Tool 1 */\n\n\t\tconst extTool1: IToolData = {\n\t\t\tid: 'extTool1',\n\t\t\ttoolReferenceName: 'extTool1RefName',\n\t\t\tmodelDescription: 'Test Extension Tool 1',\n\t\t\tdisplayName: 'ExtTool1 Display Name',\n\t\t\tsource: { type: 'extension', label: 'My Extension', extensionId: new ExtensionIdentifier('my.extension') },\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(extTool1));\n\n\t\t/** Internal Tool Set with internalToolSetTool1 */\n\n\t\tconst internalToolSetTool1: IToolData = {\n\t\t\tid: 'internalToolSetTool1',\n\t\t\ttoolReferenceName: 'internalToolSetTool1RefName',\n\t\t\tmodelDescription: 'Test Internal Tool Set 1',\n\t\t\tdisplayName: 'InternalToolSet1 Display Name',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\t\tstore.add(service.registerToolData(internalToolSetTool1));\n\n\t\tconst internalToolSet = store.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'internalToolSet',\n\t\t\t'internalToolSetRefName',\n\t\t\t{ description: 'Test Set' }\n\t\t));\n\t\tstore.add(internalToolSet.addTool(internalToolSetTool1));\n\n\t\t/** User Tool Set with tool1 */\n\n\t\tconst userToolSet = store.add(service.createToolSet(\n\t\t\t{ type: 'user', label: 'User', file: URI.file('/test/userToolSet.json') },\n\t\t\t'userToolSet',\n\t\t\t'userToolSetRefName',\n\t\t\t{ description: 'Test Set' }\n\t\t));\n\t\tstore.add(userToolSet.addTool(tool2));\n\n\t\t/** MCP tool in a MCP tool set */\n\n\t\tconst mcpDataSource: ToolDataSource = { type: 'mcp', label: 'My MCP Server', serverLabel: 'MCP Server', instructions: undefined, collectionId: 'testMCPCollection', definitionId: 'testMCPDefId' };\n\t\tconst mcpTool1: IToolData = {\n\t\t\tid: 'mcpTool1',\n\t\t\ttoolReferenceName: 'mcpTool1RefName',\n\t\t\tmodelDescription: 'Test MCP Tool 1',\n\t\t\tdisplayName: 'McpTool1 Display Name',\n\t\t\tsource: mcpDataSource,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(mcpTool1));\n\n\t\tconst mcpToolSet = store.add(service.createToolSet(\n\t\t\tmcpDataSource,\n\t\t\t'mcpToolSet',\n\t\t\t'mcpToolSetRefName',\n\t\t\t{ description: 'MCP Test ToolSet' }\n\t\t));\n\t\tstore.add(mcpToolSet.addTool(mcpTool1));\n\t}\n\n\n\ttest('registerToolData', () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testTool',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst disposable = service.registerToolData(toolData);\n\t\tassert.strictEqual(service.getTool('testTool')?.id, 'testTool');\n\t\tdisposable.dispose();\n\t\tassert.strictEqual(service.getTool('testTool'), undefined);\n\t});\n\n\ttest('registerToolImplementation', () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testTool',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\tconst toolImpl: IToolImpl = {\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'result' }] }),\n\t\t};\n\n\t\tstore.add(service.registerToolImplementation('testTool', toolImpl));\n\t\tassert.strictEqual(service.getTool('testTool')?.id, 'testTool');\n\t});\n\n\ttest('getTools', () => {\n\t\tcontextKeyService.createKey('testKey', true);\n\t\tconst toolData1: IToolData = {\n\t\t\tid: 'testTool1',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\twhen: ContextKeyEqualsExpr.create('testKey', false),\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolData2: IToolData = {\n\t\t\tid: 'testTool2',\n\t\t\tmodelDescription: 'Test Tool 2',\n\t\t\twhen: ContextKeyEqualsExpr.create('testKey', true),\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolData3: IToolData = {\n\t\t\tid: 'testTool3',\n\t\t\tmodelDescription: 'Test Tool 3',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData1));\n\t\tstore.add(service.registerToolData(toolData2));\n\t\tstore.add(service.registerToolData(toolData3));\n\n\t\tconst tools = Array.from(service.getTools());\n\t\tassert.strictEqual(tools.length, 2);\n\t\tassert.strictEqual(tools[0].id, 'testTool2');\n\t\tassert.strictEqual(tools[1].id, 'testTool3');\n\t});\n\n\ttest('getToolByName', () => {\n\t\tcontextKeyService.createKey('testKey', true);\n\t\tconst toolData1: IToolData = {\n\t\t\tid: 'testTool1',\n\t\t\ttoolReferenceName: 'testTool1',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\twhen: ContextKeyEqualsExpr.create('testKey', false),\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolData2: IToolData = {\n\t\t\tid: 'testTool2',\n\t\t\ttoolReferenceName: 'testTool2',\n\t\t\tmodelDescription: 'Test Tool 2',\n\t\t\twhen: ContextKeyEqualsExpr.create('testKey', true),\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolData3: IToolData = {\n\t\t\tid: 'testTool3',\n\t\t\ttoolReferenceName: 'testTool3',\n\t\t\tmodelDescription: 'Test Tool 3',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData1));\n\t\tstore.add(service.registerToolData(toolData2));\n\t\tstore.add(service.registerToolData(toolData3));\n\n\t\tassert.strictEqual(service.getToolByName('testTool1'), undefined);\n\t\tassert.strictEqual(service.getToolByName('testTool1', true)?.id, 'testTool1');\n\t\tassert.strictEqual(service.getToolByName('testTool2')?.id, 'testTool2');\n\t\tassert.strictEqual(service.getToolByName('testTool3')?.id, 'testTool3');\n\t});\n\n\ttest('invokeTool', async () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testTool',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\tconst toolImpl: IToolImpl = {\n\t\t\tinvoke: async (invocation) => {\n\t\t\t\tassert.strictEqual(invocation.callId, '1');\n\t\t\t\tassert.strictEqual(invocation.toolId, 'testTool');\n\t\t\t\tassert.deepStrictEqual(invocation.parameters, { a: 1 });\n\t\t\t\treturn { content: [{ kind: 'text', value: 'result' }] };\n\t\t\t}\n\t\t};\n\n\t\tstore.add(service.registerToolImplementation('testTool', toolImpl));\n\n\t\tconst dto: IToolInvocation = {\n\t\t\tcallId: '1',\n\t\t\ttoolId: 'testTool',\n\t\t\ttokenBudget: 100,\n\t\t\tparameters: {\n\t\t\t\ta: 1\n\t\t\t},\n\t\t\tcontext: undefined,\n\t\t};\n\n\t\tconst result = await service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tassert.strictEqual(result.content[0].value, 'result');\n\t});\n\n\ttest('invocation parameters are overridden by input toolSpecificData', async () => {\n\t\tconst rawInput = { b: 2 };\n\t\tconst tool = registerToolForTest(service, store, 'testToolInputOverride', {\n\t\t\tprepareToolInvocation: async () => ({\n\t\t\t\ttoolSpecificData: { kind: 'input', rawInput } satisfies IChatToolInputInvocationData,\n\t\t\t\tconfirmationMessages: {\n\t\t\t\t\ttitle: 'a',\n\t\t\t\t\tmessage: 'b',\n\t\t\t\t}\n\t\t\t}),\n\t\t\tinvoke: async (invocation) => {\n\t\t\t\t// The service should replace parameters with rawInput and strip toolSpecificData\n\t\t\t\tassert.deepStrictEqual(invocation.parameters, rawInput);\n\t\t\t\tassert.strictEqual(invocation.toolSpecificData, undefined);\n\t\t\t\treturn { content: [{ kind: 'text', value: 'ok' }] };\n\t\t\t},\n\t\t});\n\n\t\tconst sessionId = 'sessionId';\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId, { requestId: 'requestId-io', capture });\n\t\tconst dto = tool.makeDto({ a: 1 }, { sessionId });\n\n\t\tconst invokeP = service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst result = await invokeP;\n\t\tassert.strictEqual(result.content[0].value, 'ok');\n\t});\n\n\ttest('chat invocation injects input toolSpecificData for confirmation when alwaysDisplayInputOutput', async () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testToolDisplayIO',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\talwaysDisplayInputOutput: true,\n\t\t};\n\n\t\tconst tool = registerToolForTest(service, store, 'testToolDisplayIO', {\n\t\t\tprepareToolInvocation: async () => ({\n\t\t\t\tconfirmationMessages: { title: 'Confirm', message: 'Proceed?' }\n\t\t\t}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'done' }] }),\n\t\t}, toolData);\n\n\t\tconst sessionId = 'sessionId-io';\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId, { requestId: 'requestId-io', capture });\n\n\t\tconst dto = tool.makeDto({ a: 1 }, { sessionId });\n\n\t\tconst invokeP = service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tassert.ok(published, 'expected ChatToolInvocation to be published');\n\t\tassert.strictEqual(published.toolId, tool.id);\n\t\t// The service should have injected input toolSpecificData with the raw parameters\n\t\tassert.strictEqual(published.toolSpecificData?.kind, 'input');\n\t\tassert.deepStrictEqual(published.toolSpecificData?.rawInput, dto.parameters);\n\n\t\t// Confirm to let invoke proceed\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst result = await invokeP;\n\t\tassert.strictEqual(result.content[0].value, 'done');\n\t});\n\n\ttest('chat invocation waits for user confirmation before invoking', async () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testToolConfirm',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tlet invoked = false;\n\t\tconst tool = registerToolForTest(service, store, toolData.id, {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Confirm', message: 'Go?' } }),\n\t\t\tinvoke: async () => {\n\t\t\t\tinvoked = true;\n\t\t\t\treturn { content: [{ kind: 'text', value: 'ran' }] };\n\t\t\t},\n\t\t}, toolData);\n\n\t\tconst sessionId = 'sessionId-confirm';\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId, { requestId: 'requestId-confirm', capture });\n\n\t\tconst dto = tool.makeDto({ x: 1 }, { sessionId });\n\n\t\tconst promise = service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tassert.ok(published, 'expected ChatToolInvocation to be published');\n\t\tassert.strictEqual(invoked, false, 'invoke should not run before confirmation');\n\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst result = await promise;\n\t\tassert.strictEqual(invoked, true, 'invoke should have run after confirmation');\n\t\tassert.strictEqual(result.content[0].value, 'ran');\n\t});\n\n\ttest('cancel tool call', async () => {\n\t\tconst toolBarrier = new Barrier();\n\t\tconst tool = registerToolForTest(service, store, 'testTool', {\n\t\t\tinvoke: async (invocation, countTokens, progress, cancelToken) => {\n\t\t\t\tassert.strictEqual(invocation.callId, '1');\n\t\t\t\tassert.strictEqual(invocation.toolId, 'testTool');\n\t\t\t\tassert.deepStrictEqual(invocation.parameters, { a: 1 });\n\t\t\t\tawait toolBarrier.wait();\n\t\t\t\tif (cancelToken.isCancellationRequested) {\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Tool call should be cancelled');\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst sessionId = 'sessionId';\n\t\tconst requestId = 'requestId';\n\t\tconst dto = tool.makeDto({ a: 1 }, { sessionId });\n\t\tstubGetSession(chatService, sessionId, { requestId });\n\t\tconst toolPromise = service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tservice.cancelToolCallsForRequest(requestId);\n\t\ttoolBarrier.open();\n\t\tawait assert.rejects(toolPromise, err => {\n\t\t\treturn isCancellationError(err);\n\t\t}, 'Expected tool call to be cancelled');\n\t});\n\n\ttest('toQualifiedToolNames', () => {\n\t\tsetupToolsForTest(service, store);\n\n\t\tconst tool1 = service.getToolByQualifiedName('tool1RefName');\n\t\tconst extTool1 = service.getToolByQualifiedName('my.extension/extTool1RefName');\n\t\tconst mcpToolSet = service.getToolByQualifiedName('mcpToolSetRefName/*');\n\t\tconst mcpTool1 = service.getToolByQualifiedName('mcpToolSetRefName/mcpTool1RefName');\n\t\tconst internalToolSet = service.getToolByQualifiedName('internalToolSetRefName');\n\t\tconst internalTool = service.getToolByQualifiedName('internalToolSetRefName/internalToolSetTool1RefName');\n\t\tconst userToolSet = service.getToolSet('userToolSet');\n\t\tconst unknownTool = { id: 'unregisteredTool', toolReferenceName: 'unregisteredToolRefName', modelDescription: 'Unregistered Tool', displayName: 'Unregistered Tool', source: ToolDataSource.Internal, canBeReferencedInPrompt: true } satisfies IToolData;\n\t\tconst unknownToolSet = service.createToolSet(ToolDataSource.Internal, 'unknownToolSet', 'unknownToolSetRefName', { description: 'Unknown Test Set' });\n\t\tunknownToolSet.dispose(); // unregister the set\n\t\tassert.ok(tool1);\n\t\tassert.ok(extTool1);\n\t\tassert.ok(mcpTool1);\n\t\tassert.ok(mcpToolSet);\n\t\tassert.ok(internalToolSet);\n\t\tassert.ok(internalTool);\n\t\tassert.ok(userToolSet);\n\n\t\t// Test with some enabled tool\n\t\t{\n\t\t\t// creating a map by hand is a no-go, we just do it for this test\n\t\t\tconst map = new Map<IToolData | ToolSet, boolean>([[tool1, true], [extTool1, true], [mcpToolSet, true], [mcpTool1, true]]);\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(map);\n\t\t\tconst expectedQualifiedNames = ['tool1RefName', 'my.extension/extTool1RefName', 'mcpToolSetRefName/*'];\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), expectedQualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Test with user data\n\t\t{\n\t\t\t// creating a map by hand is a no-go, we just do it for this test\n\t\t\tconst map = new Map<IToolData | ToolSet, boolean>([[tool1, true], [userToolSet, true], [internalToolSet, false], [internalTool, true]]);\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(map);\n\t\t\tconst expectedQualifiedNames = ['tool1RefName', 'internalToolSetRefName/internalToolSetTool1RefName'];\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), expectedQualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Test with unknown tool and tool set\n\t\t{\n\t\t\t// creating a map by hand is a no-go, we just do it for this test\n\t\t\tconst map = new Map<IToolData | ToolSet, boolean>([[unknownTool, true], [unknownToolSet, true], [internalToolSet, true], [internalTool, true]]);\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(map);\n\t\t\tconst expectedQualifiedNames = ['internalToolSetRefName'];\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), expectedQualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t});\n\n\ttest('toToolAndToolSetEnablementMap', () => {\n\t\tsetupToolsForTest(service, store);\n\n\t\tconst allQualifiedNames = [\n\t\t\t'tool1RefName',\n\t\t\t'Tool2 Display Name',\n\t\t\t'my.extension/extTool1RefName',\n\t\t\t'mcpToolSetRefName/*',\n\t\t\t'mcpToolSetRefName/mcpTool1RefName',\n\t\t\t'internalToolSetRefName',\n\t\t\t'internalToolSetRefName/internalToolSetTool1RefName',\n\t\t\t'vscode',\n\t\t\t'launch'\n\t\t];\n\t\tconst numOfTools = allQualifiedNames.length + 1; // +1 for userToolSet which has no qualified name but is a tool set\n\n\t\tconst tool1 = service.getToolByQualifiedName('tool1RefName');\n\t\tconst tool2 = service.getToolByQualifiedName('Tool2 Display Name');\n\t\tconst extTool1 = service.getToolByQualifiedName('my.extension/extTool1RefName');\n\t\tconst mcpToolSet = service.getToolByQualifiedName('mcpToolSetRefName/*');\n\t\tconst mcpTool1 = service.getToolByQualifiedName('mcpToolSetRefName/mcpTool1RefName');\n\t\tconst internalToolSet = service.getToolByQualifiedName('internalToolSetRefName');\n\t\tconst internalTool = service.getToolByQualifiedName('internalToolSetRefName/internalToolSetTool1RefName');\n\t\tconst userToolSet = service.getToolSet('userToolSet');\n\t\tconst vscodeToolSet = service.getToolSet('vscode');\n\t\tconst launchToolSet = service.getToolSet('launch');\n\t\tassert.ok(tool1);\n\t\tassert.ok(tool2);\n\t\tassert.ok(extTool1);\n\t\tassert.ok(mcpTool1);\n\t\tassert.ok(mcpToolSet);\n\t\tassert.ok(internalToolSet);\n\t\tassert.ok(internalTool);\n\t\tassert.ok(userToolSet);\n\t\tassert.ok(vscodeToolSet);\n\t\tassert.ok(launchToolSet);\n\t\t// Test with enabled tool\n\t\t{\n\t\t\tconst qualifiedNames = ['tool1RefName'];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 1, 'Expected 1 tool to be enabled');\n\t\t\tassert.strictEqual(result1.get(tool1), true, 'tool1 should be enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), qualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\n\t\t}\n\t\t// Test with multiple enabled tools\n\t\t{\n\t\t\tconst qualifiedNames = ['my.extension/extTool1RefName', 'mcpToolSetRefName/*', 'internalToolSetRefName/internalToolSetTool1RefName'];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 4, 'Expected 4 tools to be enabled');\n\t\t\tassert.strictEqual(result1.get(extTool1), true, 'extTool1 should be enabled');\n\t\t\tassert.strictEqual(result1.get(mcpToolSet), true, 'mcpToolSet should be enabled');\n\t\t\tassert.strictEqual(result1.get(mcpTool1), true, 'mcpTool1 should be enabled because the set is enabled');\n\t\t\tassert.strictEqual(result1.get(internalTool), true, 'internalTool should be enabled because the set is enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), qualifiedNames.sort(), 'toQualifiedToolNames should return the expected names');\n\t\t}\n\t\t// Test with all enabled tools, redundant names\n\t\t{\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(allQualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 10, 'Expected 10 tools to be enabled'); // +2 including the vscode, launch toolsets\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tconst expectedQualifiedNames = ['tool1RefName', 'Tool2 Display Name', 'my.extension/extTool1RefName', 'mcpToolSetRefName/*', 'internalToolSetRefName', 'vscode', 'launch'];\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), expectedQualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Test with no enabled tools\n\t\t{\n\t\t\tconst qualifiedNames: string[] = [];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 0, 'Expected 0 tools to be enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), qualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Test with unknown tool\n\t\t{\n\t\t\tconst qualifiedNames: string[] = ['unknownToolRefName'];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 0, 'Expected 0 tools to be enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), [], 'toQualifiedToolNames should return no enabled names');\n\t\t}\n\t\t// Test with legacy tool names\n\t\t{\n\t\t\tconst qualifiedNames: string[] = ['extTool1RefName', 'mcpToolSetRefName', 'internalToolSetTool1RefName'];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 4, 'Expected 4 tools to be enabled');\n\t\t\tassert.strictEqual(result1.get(extTool1), true, 'extTool1 should be enabled');\n\t\t\tassert.strictEqual(result1.get(mcpToolSet), true, 'mcpToolSet should be enabled');\n\t\t\tassert.strictEqual(result1.get(mcpTool1), true, 'mcpTool1 should be enabled because the set is enabled');\n\t\t\tassert.strictEqual(result1.get(internalTool), true, 'internalTool should be enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tconst expectedQualifiedNames: string[] = ['my.extension/extTool1RefName', 'mcpToolSetRefName/*', 'internalToolSetRefName/internalToolSetTool1RefName'];\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), expectedQualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Test with tool in user tool set\n\t\t{\n\t\t\tconst qualifiedNames = ['Tool2 Display Name'];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 2, 'Expected 1 tool and user tool set to be enabled');\n\t\t\tassert.strictEqual(result1.get(tool2), true, 'tool2 should be enabled');\n\t\t\tassert.strictEqual(result1.get(userToolSet), true, 'userToolSet should be enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), qualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\n\t\t}\n\t});\n\n\ttest('toToolAndToolSetEnablementMap with extension tool', () => {\n\t\t// Register individual tools\n\t\tconst toolData1: IToolData = {\n\t\t\tid: 'tool1',\n\t\t\ttoolReferenceName: 'refTool1',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\tdisplayName: 'Test Tool 1',\n\t\t\tsource: { type: 'extension', label: 'My Extension', extensionId: new ExtensionIdentifier('My.extension') },\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData1));\n\n\t\t// Test enabling the tool set\n\t\tconst enabledNames = [toolData1].map(t => service.getQualifiedToolName(t));\n\t\tconst result = service.toToolAndToolSetEnablementMap(enabledNames, undefined);\n\n\t\tassert.strictEqual(result.get(toolData1), true, 'individual tool should be enabled');\n\n\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\tassert.deepStrictEqual(qualifiedNames.sort(), enabledNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t});\n\n\ttest('toToolAndToolSetEnablementMap with tool sets', () => {\n\t\t// Register individual tools\n\t\tconst toolData1: IToolData = {\n\t\t\tid: 'tool1',\n\t\t\ttoolReferenceName: 'refTool1',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\tdisplayName: 'Test Tool 1',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\tconst toolData2: IToolData = {\n\t\t\tid: 'tool2',\n\t\t\tmodelDescription: 'Test Tool 2',\n\t\t\tdisplayName: 'Test Tool 2',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData1));\n\t\tstore.add(service.registerToolData(toolData2));\n\n\t\t// Create a tool set\n\t\tconst toolSet = store.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'testToolSet',\n\t\t\t'refToolSet',\n\t\t\t{ description: 'Test Tool Set' }\n\t\t));\n\n\t\t// Add tools to the tool set\n\t\tconst toolSetTool1: IToolData = {\n\t\t\tid: 'toolSetTool1',\n\t\t\tmodelDescription: 'Tool Set Tool 1',\n\t\t\tdisplayName: 'Tool Set Tool 1',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolSetTool2: IToolData = {\n\t\t\tid: 'toolSetTool2',\n\t\t\tmodelDescription: 'Tool Set Tool 2',\n\t\t\tdisplayName: 'Tool Set Tool 2',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolSetTool1));\n\t\tstore.add(service.registerToolData(toolSetTool2));\n\t\tstore.add(toolSet.addTool(toolSetTool1));\n\t\tstore.add(toolSet.addTool(toolSetTool2));\n\n\t\t// Test enabling the tool set\n\t\tconst enabledNames = [toolSet, toolData1].map(t => service.getQualifiedToolName(t));\n\t\tconst result = service.toToolAndToolSetEnablementMap(enabledNames, undefined);\n\n\t\tassert.strictEqual(result.get(toolData1), true, 'individual tool should be enabled');\n\t\tassert.strictEqual(result.get(toolData2), false);\n\t\tassert.strictEqual(result.get(toolSet), true, 'tool set should be enabled');\n\t\tassert.strictEqual(result.get(toolSetTool1), true, 'tool set tool 1 should be enabled');\n\t\tassert.strictEqual(result.get(toolSetTool2), true, 'tool set tool 2 should be enabled');\n\n\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\tassert.deepStrictEqual(qualifiedNames.sort(), enabledNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t});\n\n\ttest('toToolAndToolSetEnablementMap with non-existent tool names', () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'tool1',\n\t\t\ttoolReferenceName: 'refTool1',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\tdisplayName: 'Test Tool 1',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\tconst unregisteredToolData: IToolData = {\n\t\t\tid: 'toolX',\n\t\t\ttoolReferenceName: 'refToolX',\n\t\t\tmodelDescription: 'Test Tool X',\n\t\t\tdisplayName: 'Test Tool X',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\t// Test with non-existent tool names\n\t\tconst enabledNames = [toolData, unregisteredToolData].map(t => service.getQualifiedToolName(t));\n\t\tconst result = service.toToolAndToolSetEnablementMap(enabledNames, undefined);\n\n\t\tassert.strictEqual(result.get(toolData), true, 'existing tool should be enabled');\n\t\t// Non-existent tools should not appear in the result map\n\t\tassert.strictEqual(result.get(unregisteredToolData), undefined, 'non-existent tool should not be in result');\n\n\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\tconst expectedNames = [service.getQualifiedToolName(toolData)]; // Only the existing tool\n\t\tassert.deepStrictEqual(qualifiedNames.sort(), expectedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\n\t});\n\n\n\ttest('toToolAndToolSetEnablementMap with legacy names', () => {\n\t\t// Test that legacy tool reference names and legacy toolset names work correctly\n\n\t\t// Create a tool with legacy reference names\n\t\tconst toolWithLegacy: IToolData = {\n\t\t\tid: 'newTool',\n\t\t\ttoolReferenceName: 'newToolRef',\n\t\t\tmodelDescription: 'New Tool',\n\t\t\tdisplayName: 'New Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t\tlegacyToolReferenceFullNames: ['oldToolName', 'deprecatedToolName']\n\t\t};\n\t\tstore.add(service.registerToolData(toolWithLegacy));\n\n\t\t// Create a tool set with legacy names\n\t\tconst toolSetWithLegacy = store.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'newToolSet',\n\t\t\t'newToolSetRef',\n\t\t\t{ description: 'New Tool Set', legacyFullNames: ['oldToolSet', 'deprecatedToolSet'] }\n\t\t));\n\n\t\t// Create a tool in the toolset\n\t\tconst toolInSet: IToolData = {\n\t\t\tid: 'toolInSet',\n\t\t\ttoolReferenceName: 'toolInSetRef',\n\t\t\tmodelDescription: 'Tool In Set',\n\t\t\tdisplayName: 'Tool In Set',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\t\tstore.add(service.registerToolData(toolInSet));\n\t\tstore.add(toolSetWithLegacy.addTool(toolInSet));\n\n\t\t// Test 1: Using legacy tool reference name should enable the tool\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolName'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithLegacy), true, 'tool should be enabled via legacy name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolRef'], 'should return current qualified name, not legacy');\n\t\t}\n\n\t\t// Test 2: Using another legacy tool reference name should also work\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['deprecatedToolName'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithLegacy), true, 'tool should be enabled via another legacy name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolRef'], 'should return current qualified name, not legacy');\n\t\t}\n\n\t\t// Test 3: Using legacy toolset name should enable the entire toolset\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolSetWithLegacy), true, 'toolset should be enabled via legacy name');\n\t\t\tassert.strictEqual(result.get(toolInSet), true, 'tool in set should be enabled when set is enabled via legacy name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolSetRef'], 'should return current qualified name, not legacy');\n\t\t}\n\n\t\t// Test 4: Using deprecated toolset name should also work\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['deprecatedToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolSetWithLegacy), true, 'toolset should be enabled via another legacy name');\n\t\t\tassert.strictEqual(result.get(toolInSet), true, 'tool in set should be enabled when set is enabled via legacy name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolSetRef'], 'should return current qualified name, not legacy');\n\t\t}\n\n\t\t// Test 5: Mix of current and legacy names\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['newToolRef', 'oldToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithLegacy), true, 'tool should be enabled via current name');\n\t\t\tassert.strictEqual(result.get(toolSetWithLegacy), true, 'toolset should be enabled via legacy name');\n\t\t\tassert.strictEqual(result.get(toolInSet), true, 'tool in set should be enabled');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), ['newToolRef', 'newToolSetRef'].sort(), 'should return current qualified names');\n\t\t}\n\n\t\t// Test 6: Using legacy names and current names together (redundant but should work)\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['newToolRef', 'oldToolName', 'deprecatedToolName'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithLegacy), true, 'tool should be enabled (redundant legacy names should not cause issues)');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolRef'], 'should return single current qualified name');\n\t\t}\n\t});\n\n\ttest('toToolAndToolSetEnablementMap with orphaned toolset in legacy names', () => {\n\t\t// Test that when a tool has a legacy name with a toolset prefix, but that toolset no longer exists,\n\t\t// we can enable the tool by either the full legacy name OR just the orphaned toolset name\n\n\t\t// Create a tool that used to be in 'oldToolSet/oldToolName' but now is just 'newToolRef'\n\t\tconst toolWithOrphanedToolSet: IToolData = {\n\t\t\tid: 'migratedTool',\n\t\t\ttoolReferenceName: 'newToolRef',\n\t\t\tmodelDescription: 'Migrated Tool',\n\t\t\tdisplayName: 'Migrated Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t\tlegacyToolReferenceFullNames: ['oldToolSet/oldToolName']\n\t\t};\n\t\tstore.add(service.registerToolData(toolWithOrphanedToolSet));\n\n\t\t// Test 1: Using the full legacy name should enable the tool\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet/oldToolName'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithOrphanedToolSet), true, 'tool should be enabled via full legacy name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolRef'], 'should return current qualified name');\n\t\t}\n\n\t\t// Test 2: Using just the orphaned toolset name should also enable the tool\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithOrphanedToolSet), true, 'tool should be enabled via orphaned toolset name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolRef'], 'should return current qualified name');\n\t\t}\n\n\t\t// Test 3: Multiple tools from the same orphaned toolset\n\t\tconst anotherToolFromOrphanedSet: IToolData = {\n\t\t\tid: 'anotherMigratedTool',\n\t\t\ttoolReferenceName: 'anotherNewToolRef',\n\t\t\tmodelDescription: 'Another Migrated Tool',\n\t\t\tdisplayName: 'Another Migrated Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t\tlegacyToolReferenceFullNames: ['oldToolSet/anotherOldToolName']\n\t\t};\n\t\tstore.add(service.registerToolData(anotherToolFromOrphanedSet));\n\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithOrphanedToolSet), true, 'first tool should be enabled via orphaned toolset name');\n\t\t\tassert.strictEqual(result.get(anotherToolFromOrphanedSet), true, 'second tool should also be enabled via orphaned toolset name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), ['newToolRef', 'anotherNewToolRef'].sort(), 'should return both current qualified names');\n\t\t}\n\n\t\t// Test 4: Orphaned toolset name should NOT enable tools that weren't in that toolset\n\t\tconst unrelatedTool: IToolData = {\n\t\t\tid: 'unrelatedTool',\n\t\t\ttoolReferenceName: 'unrelatedToolRef',\n\t\t\tmodelDescription: 'Unrelated Tool',\n\t\t\tdisplayName: 'Unrelated Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t\tlegacyToolReferenceFullNames: ['differentToolSet/oldName']\n\t\t};\n\t\tstore.add(service.registerToolData(unrelatedTool));\n\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithOrphanedToolSet), true, 'tool from oldToolSet should be enabled');\n\t\t\tassert.strictEqual(result.get(anotherToolFromOrphanedSet), true, 'another tool from oldToolSet should be enabled');\n\t\t\tassert.strictEqual(result.get(unrelatedTool), false, 'tool from different toolset should NOT be enabled');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), ['newToolRef', 'anotherNewToolRef'].sort(), 'should only return tools from oldToolSet');\n\t\t}\n\n\t\t// Test 5: If a toolset with the same name exists, it should take precedence over orphaned toolset mapping\n\t\tconst newToolSetWithSameName = store.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'recreatedToolSet',\n\t\t\t'oldToolSet',  // Same name as the orphaned toolset\n\t\t\t{ description: 'Recreated Tool Set' }\n\t\t));\n\n\t\tconst toolInRecreatedSet: IToolData = {\n\t\t\tid: 'toolInRecreatedSet',\n\t\t\ttoolReferenceName: 'toolInRecreatedSetRef',\n\t\t\tmodelDescription: 'Tool In Recreated Set',\n\t\t\tdisplayName: 'Tool In Recreated Set',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\t\tstore.add(service.registerToolData(toolInRecreatedSet));\n\t\tstore.add(newToolSetWithSameName.addTool(toolInRecreatedSet));\n\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet'], undefined);\n\t\t\t// Now 'oldToolSet' should enable BOTH the recreated toolset AND the tools with legacy names pointing to oldToolSet\n\t\t\tassert.strictEqual(result.get(newToolSetWithSameName), true, 'recreated toolset should be enabled');\n\t\t\tassert.strictEqual(result.get(toolInRecreatedSet), true, 'tool in recreated set should be enabled');\n\t\t\t// The tools with legacy toolset names should ALSO be enabled because their legacy names match\n\t\t\tassert.strictEqual(result.get(toolWithOrphanedToolSet), true, 'tool with legacy toolset should still be enabled');\n\t\t\tassert.strictEqual(result.get(anotherToolFromOrphanedSet), true, 'another tool with legacy toolset should still be enabled');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\t// Should return the toolset name plus the individual tools that were enabled via legacy names\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), ['oldToolSet', 'newToolRef', 'anotherNewToolRef'].sort(), 'should return toolset and individual tools');\n\t\t}\n\t});\n\n\ttest('toToolAndToolSetEnablementMap map Github to VSCode tools', () => {\n\t\tconst runCommandsToolData: IToolData = {\n\t\t\tid: VSCodeToolReference.shell,\n\t\t\ttoolReferenceName: VSCodeToolReference.shell,\n\t\t\tmodelDescription: 'runCommands',\n\t\t\tdisplayName: 'runCommands',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\tstore.add(service.registerToolData(runCommandsToolData));\n\t\tconst runSubagentToolData: IToolData = {\n\t\t\tid: VSCodeToolReference.runSubagent,\n\t\t\ttoolReferenceName: VSCodeToolReference.runSubagent,\n\t\t\tmodelDescription: 'runSubagent',\n\t\t\tdisplayName: 'runSubagent',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(runSubagentToolData));\n\n\t\tconst githubMcpDataSource: ToolDataSource = { type: 'mcp', label: 'Github', serverLabel: 'Github MCP Server', instructions: undefined, collectionId: 'githubMCPCollection', definitionId: 'githubMCPDefId' };\n\t\tconst githubMcpTool1: IToolData = {\n\t\t\tid: 'create_branch',\n\t\t\ttoolReferenceName: 'create_branch',\n\t\t\tmodelDescription: 'Test Github MCP Tool 1',\n\t\t\tdisplayName: 'Create Branch',\n\t\t\tsource: githubMcpDataSource,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(githubMcpTool1));\n\n\t\tconst githubMcpToolSet = store.add(service.createToolSet(\n\t\t\tgithubMcpDataSource,\n\t\t\t'githubMcpToolSet',\n\t\t\t'github/github-mcp-server',\n\t\t\t{ description: 'Github MCP Test ToolSet' }\n\t\t));\n\t\tstore.add(githubMcpToolSet.addTool(githubMcpTool1));\n\n\t\tconst playwrightMcpDataSource: ToolDataSource = { type: 'mcp', label: 'playwright', serverLabel: 'playwright MCP Server', instructions: undefined, collectionId: 'playwrightMCPCollection', definitionId: 'playwrightMCPDefId' };\n\t\tconst playwrightMcpTool1: IToolData = {\n\t\t\tid: 'browser_click',\n\t\t\ttoolReferenceName: 'browser_click',\n\t\t\tmodelDescription: 'Test playwright MCP Tool 1',\n\t\t\tdisplayName: 'Create Branch',\n\t\t\tsource: playwrightMcpDataSource,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(playwrightMcpTool1));\n\n\t\tconst playwrightMcpToolSet = store.add(service.createToolSet(\n\t\t\tplaywrightMcpDataSource,\n\t\t\t'playwrightMcpToolSet',\n\t\t\t'microsoft/playwright-mcp',\n\t\t\t{ description: 'playwright MCP Test ToolSet' }\n\t\t));\n\t\tstore.add(playwrightMcpToolSet.addTool(playwrightMcpTool1));\n\t\t{\n\t\t\tconst toolNames = [GithubCopilotToolReference.customAgent, GithubCopilotToolReference.shell];\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(toolNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(runSubagentToolData), true, 'runSubagentToolData should be enabled');\n\t\t\tassert.strictEqual(result.get(runCommandsToolData), true, 'runCommandsToolData should be enabled');\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result).sort();\n\t\t\tassert.deepStrictEqual(qualifiedNames, [VSCodeToolReference.runSubagent, VSCodeToolReference.shell].sort(), 'toQualifiedToolNames should return the VS Code tool names');\n\t\t}\n\t\t{\n\t\t\tconst toolNames = ['github/*', 'playwright/*'];\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(toolNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(githubMcpToolSet), true, 'githubMcpToolSet should be enabled');\n\t\t\tassert.strictEqual(result.get(playwrightMcpToolSet), true, 'playwrightMcpToolSet should be enabled');\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result).sort();\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['github/github-mcp-server/*', 'microsoft/playwright-mcp/*'], 'toQualifiedToolNames should return the VS Code tool names');\n\t\t}\n\n\t\t{\n\t\t\t// map the qualified tool names for github and playwright MCP tools\n\t\t\tconst toolNames = ['github/create_branch', 'playwright/browser_click'];\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(toolNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(githubMcpTool1), true, 'githubMcpTool1 should be enabled');\n\t\t\tassert.strictEqual(result.get(playwrightMcpTool1), true, 'playwrightMcpTool1 should be enabled');\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result).sort();\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['github/github-mcp-server/create_branch', 'microsoft/playwright-mcp/browser_click'], 'toQualifiedToolNames should return the VS Code tool names');\n\t\t}\n\n\t\t{\n\t\t\t// test that already qualified names are not altered\n\t\t\tconst toolNames = ['github/github-mcp-server/create_branch', 'microsoft/playwright-mcp/browser_click'];\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(toolNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(githubMcpTool1), true, 'githubMcpTool1 should be enabled');\n\t\t\tassert.strictEqual(result.get(playwrightMcpTool1), true, 'playwrightMcpTool1 should be enabled');\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result).sort();\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['github/github-mcp-server/create_branch', 'microsoft/playwright-mcp/browser_click'], 'toQualifiedToolNames should return the VS Code tool names');\n\t\t}\n\n\t});\n\n\ttest('accessibility signal for tool confirmation', async () => {\n\t\t// Create a test configuration service with proper settings\n\t\tconst testConfigService = new TestConfigurationService();\n\t\ttestConfigService.setUserConfiguration('chat.tools.global.autoApprove', false);\n\t\ttestConfigService.setUserConfiguration('accessibility.signals.chatUserActionRequired', { sound: 'auto', announcement: 'auto' });\n\n\t\t// Create a test accessibility service that simulates screen reader being enabled\n\t\tconst testAccessibilityService = new class extends TestAccessibilityService {\n\t\t\toverride isScreenReaderOptimized(): boolean { return true; }\n\t\t}();\n\n\t\t// Create a test accessibility signal service that tracks calls\n\t\tconst testAccessibilitySignalService = new TestAccessibilitySignalService();\n\n\t\t// Create a new service instance with the test services\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(IAccessibilityService, testAccessibilityService);\n\t\tinstaService.stub(IAccessibilitySignalService, testAccessibilitySignalService as unknown as IAccessibilitySignalService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testAccessibilityTool',\n\t\t\tmodelDescription: 'Test Accessibility Tool',\n\t\t\tdisplayName: 'Test Accessibility Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst tool = registerToolForTest(testService, store, toolData.id, {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Accessibility Test', message: 'Testing accessibility signal' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'executed' }] }),\n\t\t}, toolData);\n\n\t\tconst sessionId = 'sessionId-accessibility';\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId, { requestId: 'requestId-accessibility', capture });\n\n\t\tconst dto = tool.makeDto({ param: 'value' }, { sessionId });\n\n\t\tconst promise = testService.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\n\t\tassert.ok(published, 'expected ChatToolInvocation to be published');\n\t\tassert.ok(published.confirmationMessages, 'should have confirmation messages');\n\n\t\t// The accessibility signal should have been played\n\t\tassert.strictEqual(testAccessibilitySignalService.signalPlayedCalls.length, 1, 'accessibility signal should have been played once');\n\t\tconst signalCall = testAccessibilitySignalService.signalPlayedCalls[0];\n\t\tassert.strictEqual(signalCall.signal, AccessibilitySignal.chatUserActionRequired, 'correct signal should be played');\n\t\tassert.ok(signalCall.options?.customAlertMessage.includes('Accessibility Test'), 'alert message should include tool title');\n\t\tassert.ok(signalCall.options?.customAlertMessage.includes('Chat confirmation required'), 'alert message should include confirmation text');\n\n\t\t// Complete the invocation\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst result = await promise;\n\t\tassert.strictEqual(result.content[0].value, 'executed');\n\t});\n\n\ttest('accessibility signal respects autoApprove configuration', async () => {\n\t\t// Create a test configuration service with auto-approve enabled\n\t\tconst testConfigService = new TestConfigurationService();\n\t\ttestConfigService.setUserConfiguration('chat.tools.global.autoApprove', true);\n\t\ttestConfigService.setUserConfiguration('accessibility.signals.chatUserActionRequired', { sound: 'auto', announcement: 'auto' });\n\n\t\t// Create a test accessibility service that simulates screen reader being enabled\n\t\tconst testAccessibilityService = new class extends TestAccessibilityService {\n\t\t\toverride isScreenReaderOptimized(): boolean { return true; }\n\t\t}();\n\n\t\t// Create a test accessibility signal service that tracks calls\n\t\tconst testAccessibilitySignalService = new TestAccessibilitySignalService();\n\n\t\t// Create a new service instance with the test services\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(IAccessibilityService, testAccessibilityService);\n\t\tinstaService.stub(IAccessibilitySignalService, testAccessibilitySignalService as unknown as IAccessibilitySignalService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testAutoApproveTool',\n\t\t\tmodelDescription: 'Test Auto Approve Tool',\n\t\t\tdisplayName: 'Test Auto Approve Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst tool = registerToolForTest(testService, store, toolData.id, {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Auto Approve Test', message: 'Testing auto approve' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'auto approved' }] }),\n\t\t}, toolData);\n\n\t\tconst sessionId = 'sessionId-auto-approve';\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId, { requestId: 'requestId-auto-approve', capture });\n\n\t\tconst dto = tool.makeDto({ config: 'test' }, { sessionId });\n\n\t\t// When auto-approve is enabled, tool should complete without user intervention\n\t\tconst result = await testService.invokeTool(dto, async () => 0, CancellationToken.None);\n\n\t\t// Verify the tool completed and no accessibility signal was played\n\t\tassert.strictEqual(result.content[0].value, 'auto approved');\n\t\tassert.strictEqual(testAccessibilitySignalService.signalPlayedCalls.length, 0, 'accessibility signal should not be played when auto-approve is enabled');\n\t});\n\n\ttest('shouldAutoConfirm with basic configuration', async () => {\n\t\t// Test basic shouldAutoConfirm behavior with simple configuration\n\t\tconst testConfigService = new TestConfigurationService();\n\t\ttestConfigService.setUserConfiguration('chat.tools.global.autoApprove', true); // Global enabled\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\t// Register a tool that should be auto-approved\n\t\tconst autoTool = registerToolForTest(testService, store, 'autoTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Test', message: 'Should auto-approve' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'auto approved' }] })\n\t\t});\n\n\t\tconst sessionId = 'test-basic-config';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\t// Tool should be auto-approved (global config = true)\n\t\tconst result = await testService.invokeTool(\n\t\t\tautoTool.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(result.content[0].value, 'auto approved');\n\t});\n\n\ttest('shouldAutoConfirm with per-tool configuration object', async () => {\n\t\t// Test per-tool configuration: { toolId: true/false }\n\t\tconst testConfigService = new TestConfigurationService();\n\t\ttestConfigService.setUserConfiguration('chat.tools.global.autoApprove', {\n\t\t\t'approvedTool': true,\n\t\t\t'deniedTool': false\n\t\t});\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\t// Tool explicitly approved\n\t\tconst approvedTool = registerToolForTest(testService, store, 'approvedTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Test', message: 'Should auto-approve' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'approved' }] })\n\t\t});\n\n\t\tconst sessionId = 'test-per-tool';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\t// Approved tool should auto-approve\n\t\tconst approvedResult = await testService.invokeTool(\n\t\t\tapprovedTool.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(approvedResult.content[0].value, 'approved');\n\n\t\t// Test that non-specified tools require confirmation (default behavior)\n\t\tconst unspecifiedTool = registerToolForTest(testService, store, 'unspecifiedTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Test', message: 'Should require confirmation' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'unspecified' }] })\n\t\t});\n\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId + '2', { requestId: 'req2', capture });\n\t\tconst unspecifiedPromise = testService.invokeTool(\n\t\t\tunspecifiedTool.makeDto({ test: 2 }, { sessionId: sessionId + '2' }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tassert.ok(published?.confirmationMessages, 'unspecified tool should require confirmation');\n\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst unspecifiedResult = await unspecifiedPromise;\n\t\tassert.strictEqual(unspecifiedResult.content[0].value, 'unspecified');\n\t});\n\n\ttest('eligibleForAutoApproval setting controls tool eligibility', async () => {\n\t\t// Test the new eligibleForAutoApproval setting\n\t\tconst testConfigService = new TestConfigurationService();\n\t\ttestConfigService.setUserConfiguration('chat.tools.eligibleForAutoApproval', {\n\t\t\t'eligibleToolRef': true,\n\t\t\t'ineligibleToolRef': false\n\t\t});\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\t// Tool explicitly marked as eligible (using toolReferenceName) - no confirmation needed\n\t\tconst eligibleTool = registerToolForTest(testService, store, 'eligibleTool', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'eligible tool ran' }] })\n\t\t}, {\n\t\t\ttoolReferenceName: 'eligibleToolRef'\n\t\t});\n\n\t\tconst sessionId = 'test-eligible';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\t// Eligible tool should not get default confirmation messages injected\n\t\tconst eligibleResult = await testService.invokeTool(\n\t\t\teligibleTool.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(eligibleResult.content[0].value, 'eligible tool ran');\n\n\t\t// Tool explicitly marked as ineligible (using toolReferenceName) - must require confirmation\n\t\tconst ineligibleTool = registerToolForTest(testService, store, 'ineligibleTool', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'ineligible requires confirmation' }] })\n\t\t}, {\n\t\t\ttoolReferenceName: 'ineligibleToolRef'\n\t\t});\n\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId + '2', { requestId: 'req2', capture });\n\t\tconst ineligiblePromise = testService.invokeTool(\n\t\t\tineligibleTool.makeDto({ test: 2 }, { sessionId: sessionId + '2' }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tassert.ok(published?.confirmationMessages, 'ineligible tool should require confirmation');\n\t\tassert.ok(published?.confirmationMessages?.title, 'should have default confirmation title');\n\t\tassert.strictEqual(published?.confirmationMessages?.allowAutoConfirm, false, 'should not allow auto confirm');\n\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst ineligibleResult = await ineligiblePromise;\n\t\tassert.strictEqual(ineligibleResult.content[0].value, 'ineligible requires confirmation');\n\n\t\t// Tool not specified should default to eligible - no confirmation needed\n\t\tconst unspecifiedTool = registerToolForTest(testService, store, 'unspecifiedTool', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'unspecified defaults to eligible' }] })\n\t\t}, {\n\t\t\ttoolReferenceName: 'unspecifiedToolRef'\n\t\t});\n\n\t\tconst unspecifiedResult = await testService.invokeTool(\n\t\t\tunspecifiedTool.makeDto({ test: 3 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(unspecifiedResult.content[0].value, 'unspecified defaults to eligible');\n\t});\n\n\ttest('tool content formatting with alwaysDisplayInputOutput', async () => {\n\t\t// Test ensureToolDetails, formatToolInput, and toolResultToIO\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'formatTool',\n\t\t\tmodelDescription: 'Format Test Tool',\n\t\t\tdisplayName: 'Format Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\talwaysDisplayInputOutput: true\n\t\t};\n\n\t\tconst tool = registerToolForTest(service, store, toolData.id, {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async (invocation) => ({\n\t\t\t\tcontent: [\n\t\t\t\t\t{ kind: 'text', value: 'Text result' },\n\t\t\t\t\t{ kind: 'data', value: { data: VSBuffer.fromByteArray([1, 2, 3]), mimeType: 'application/octet-stream' } }\n\t\t\t\t]\n\t\t\t})\n\t\t}, toolData);\n\n\t\tconst input = { a: 1, b: 'test', c: [1, 2, 3] };\n\t\tconst result = await service.invokeTool(\n\t\t\ttool.makeDto(input),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Should have tool result details because alwaysDisplayInputOutput = true\n\t\tassert.ok(result.toolResultDetails, 'should have toolResultDetails');\n\t\tconst details = result.toolResultDetails;\n\t\tassert.ok(isToolResultInputOutputDetails(details));\n\n\t\t// Test formatToolInput - should be formatted JSON\n\t\tconst expectedInputJson = JSON.stringify(input, undefined, 2);\n\t\tassert.strictEqual(details.input, expectedInputJson, 'input should be formatted JSON');\n\n\t\t// Test toolResultToIO - should convert different content types\n\t\tassert.strictEqual(details.output.length, 2, 'should have 2 output items');\n\n\t\t// Text content\n\t\tconst textOutput = details.output[0];\n\t\tassert.strictEqual(textOutput.type, 'embed');\n\t\tassert.strictEqual(textOutput.isText, true);\n\t\tassert.strictEqual(textOutput.value, 'Text result');\n\n\t\t// Data content (base64 encoded)\n\t\tconst dataOutput = details.output[1];\n\t\tassert.strictEqual(dataOutput.type, 'embed');\n\t\tassert.strictEqual(dataOutput.mimeType, 'application/octet-stream');\n\t\tassert.strictEqual(dataOutput.value, 'AQID'); // base64 of [1,2,3]\n\t});\n\n\ttest('tool error handling and telemetry', async () => {\n\t\tconst testTelemetryService = new TestTelemetryService();\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(configurationService)),\n\t\t\tconfigurationService: () => configurationService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ITelemetryService, testTelemetryService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\t// Test successful invocation telemetry\n\t\tconst successTool = registerToolForTest(testService, store, 'successTool', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'success' }] })\n\t\t});\n\n\t\tconst sessionId = 'telemetry-test';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\tawait testService.invokeTool(\n\t\t\tsuccessTool.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Check success telemetry\n\t\tconst successEvents = testTelemetryService.events.filter(e => e.eventName === 'languageModelToolInvoked');\n\t\tassert.strictEqual(successEvents.length, 1, 'should have success telemetry event');\n\t\tassert.strictEqual(successEvents[0].data.result, 'success');\n\t\tassert.strictEqual(successEvents[0].data.toolId, 'successTool');\n\t\tassert.strictEqual(successEvents[0].data.chatSessionId, sessionId);\n\n\t\ttestTelemetryService.reset();\n\n\t\t// Test error telemetry\n\t\tconst errorTool = registerToolForTest(testService, store, 'errorTool', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => { throw new Error('Tool error'); }\n\t\t});\n\n\t\tstubGetSession(chatService, sessionId + '2', { requestId: 'req2' });\n\n\t\ttry {\n\t\t\tawait testService.invokeTool(\n\t\t\t\terrorTool.makeDto({ test: 2 }, { sessionId: sessionId + '2' }),\n\t\t\t\tasync () => 0,\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\t\t\tassert.fail('Should have thrown');\n\t\t} catch (err) {\n\t\t\t// Expected\n\t\t}\n\n\t\t// Check error telemetry\n\t\tconst errorEvents = testTelemetryService.events.filter(e => e.eventName === 'languageModelToolInvoked');\n\t\tassert.strictEqual(errorEvents.length, 1, 'should have error telemetry event');\n\t\tassert.strictEqual(errorEvents[0].data.result, 'error');\n\t\tassert.strictEqual(errorEvents[0].data.toolId, 'errorTool');\n\t});\n\n\ttest('call tracking and cleanup', async () => {\n\t\t// Test that cancelToolCallsForRequest method exists and can be called\n\t\t// (The detailed cancellation behavior is already tested in \"cancel tool call\" test)\n\t\tconst sessionId = 'tracking-session';\n\t\tconst requestId = 'tracking-request';\n\t\tstubGetSession(chatService, sessionId, { requestId });\n\n\t\t// Just verify the method exists and doesn't throw\n\t\tassert.doesNotThrow(() => {\n\t\t\tservice.cancelToolCallsForRequest(requestId);\n\t\t}, 'cancelToolCallsForRequest should not throw');\n\n\t\t// Verify calling with non-existent request ID doesn't throw\n\t\tassert.doesNotThrow(() => {\n\t\t\tservice.cancelToolCallsForRequest('non-existent-request');\n\t\t}, 'cancelToolCallsForRequest with non-existent ID should not throw');\n\t});\n\n\ttest('accessibility signal with different settings combinations', async () => {\n\t\tconst testAccessibilitySignalService = new TestAccessibilitySignalService();\n\n\t\t// Test case 1: Sound enabled, announcement disabled, screen reader off\n\t\tconst testConfigService1 = new TestConfigurationService();\n\t\ttestConfigService1.setUserConfiguration('chat.tools.global.autoApprove', false);\n\t\ttestConfigService1.setUserConfiguration('accessibility.signals.chatUserActionRequired', { sound: 'on', announcement: 'off' });\n\n\t\tconst testAccessibilityService1 = new class extends TestAccessibilityService {\n\t\t\toverride isScreenReaderOptimized(): boolean { return false; }\n\t\t}();\n\n\t\tconst instaService1 = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService1)),\n\t\t\tconfigurationService: () => testConfigService1\n\t\t}, store);\n\t\tinstaService1.stub(IChatService, chatService);\n\t\tinstaService1.stub(IAccessibilityService, testAccessibilityService1);\n\t\tinstaService1.stub(IAccessibilitySignalService, testAccessibilitySignalService as unknown as IAccessibilitySignalService);\n\t\tinstaService1.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService1 = store.add(instaService1.createInstance(LanguageModelToolsService));\n\n\t\tconst tool1 = registerToolForTest(testService1, store, 'soundOnlyTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Sound Test', message: 'Testing sound only' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'executed' }] })\n\t\t});\n\n\t\tconst sessionId1 = 'sound-test';\n\t\tconst capture1: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId1, { requestId: 'req1', capture: capture1 });\n\n\t\tconst promise1 = testService1.invokeTool(tool1.makeDto({ test: 1 }, { sessionId: sessionId1 }), async () => 0, CancellationToken.None);\n\t\tconst published1 = await waitForPublishedInvocation(capture1);\n\n\t\t// Signal should be played (sound=on, no screen reader requirement)\n\t\tassert.strictEqual(testAccessibilitySignalService.signalPlayedCalls.length, 1, 'sound should be played when sound=on');\n\t\tconst call1 = testAccessibilitySignalService.signalPlayedCalls[0];\n\t\tassert.strictEqual(call1.options?.modality, undefined, 'should use default modality for sound');\n\n\t\tIChatToolInvocation.confirmWith(published1, { type: ToolConfirmKind.UserAction });\n\t\tawait promise1;\n\n\t\ttestAccessibilitySignalService.reset();\n\n\t\t// Test case 2: Sound auto, announcement auto, screen reader on\n\t\tconst testConfigService2 = new TestConfigurationService();\n\t\ttestConfigService2.setUserConfiguration('chat.tools.global.autoApprove', false);\n\t\ttestConfigService2.setUserConfiguration('accessibility.signals.chatUserActionRequired', { sound: 'auto', announcement: 'auto' });\n\n\t\tconst testAccessibilityService2 = new class extends TestAccessibilityService {\n\t\t\toverride isScreenReaderOptimized(): boolean { return true; }\n\t\t}();\n\n\t\tconst instaService2 = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService2)),\n\t\t\tconfigurationService: () => testConfigService2\n\t\t}, store);\n\t\tinstaService2.stub(IChatService, chatService);\n\t\tinstaService2.stub(IAccessibilityService, testAccessibilityService2);\n\t\tinstaService2.stub(IAccessibilitySignalService, testAccessibilitySignalService as unknown as IAccessibilitySignalService);\n\t\tinstaService2.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService2 = store.add(instaService2.createInstance(LanguageModelToolsService));\n\n\t\tconst tool2 = registerToolForTest(testService2, store, 'autoScreenReaderTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Auto Test', message: 'Testing auto with screen reader' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'executed' }] })\n\t\t});\n\n\t\tconst sessionId2 = 'auto-sr-test';\n\t\tconst capture2: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId2, { requestId: 'req2', capture: capture2 });\n\n\t\tconst promise2 = testService2.invokeTool(tool2.makeDto({ test: 2 }, { sessionId: sessionId2 }), async () => 0, CancellationToken.None);\n\t\tconst published2 = await waitForPublishedInvocation(capture2);\n\n\t\t// Signal should be played (both sound and announcement enabled for screen reader)\n\t\tassert.strictEqual(testAccessibilitySignalService.signalPlayedCalls.length, 1, 'signal should be played with screen reader optimization');\n\t\tconst call2 = testAccessibilitySignalService.signalPlayedCalls[0];\n\t\tassert.ok(call2.options?.customAlertMessage, 'should have custom alert message');\n\t\tassert.strictEqual(call2.options?.userGesture, true, 'should mark as user gesture');\n\n\t\tIChatToolInvocation.confirmWith(published2, { type: ToolConfirmKind.UserAction });\n\t\tawait promise2;\n\n\t\ttestAccessibilitySignalService.reset();\n\n\t\t// Test case 3: Sound off, announcement off - no signal\n\t\tconst testConfigService3 = new TestConfigurationService();\n\t\ttestConfigService3.setUserConfiguration('chat.tools.global.autoApprove', false);\n\t\ttestConfigService3.setUserConfiguration('accessibility.signals.chatUserActionRequired', { sound: 'off', announcement: 'off' });\n\n\t\tconst testAccessibilityService3 = new class extends TestAccessibilityService {\n\t\t\toverride isScreenReaderOptimized(): boolean { return true; }\n\t\t}();\n\n\t\tconst instaService3 = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService3)),\n\t\t\tconfigurationService: () => testConfigService3\n\t\t}, store);\n\t\tinstaService3.stub(IChatService, chatService);\n\t\tinstaService3.stub(IAccessibilityService, testAccessibilityService3);\n\t\tinstaService3.stub(IAccessibilitySignalService, testAccessibilitySignalService as unknown as IAccessibilitySignalService);\n\t\tinstaService3.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService3 = store.add(instaService3.createInstance(LanguageModelToolsService));\n\n\t\tconst tool3 = registerToolForTest(testService3, store, 'offTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Off Test', message: 'Testing off settings' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'executed' }] })\n\t\t});\n\n\t\tconst sessionId3 = 'off-test';\n\t\tconst capture3: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId3, { requestId: 'req3', capture: capture3 });\n\n\t\tconst promise3 = testService3.invokeTool(tool3.makeDto({ test: 3 }, { sessionId: sessionId3 }), async () => 0, CancellationToken.None);\n\t\tconst published3 = await waitForPublishedInvocation(capture3);\n\n\t\t// No signal should be played\n\t\tassert.strictEqual(testAccessibilitySignalService.signalPlayedCalls.length, 0, 'no signal should be played when both sound and announcement are off');\n\n\t\tIChatToolInvocation.confirmWith(published3, { type: ToolConfirmKind.UserAction });\n\t\tawait promise3;\n\t});\n\n\ttest('createToolSet and getToolSet', () => {\n\t\tconst toolSet = store.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'testToolSetId',\n\t\t\t'testToolSetName',\n\t\t\t{ icon: undefined, description: 'Test tool set' }\n\t\t));\n\n\t\t// Should be able to retrieve by ID\n\t\tconst retrieved = service.getToolSet('testToolSetId');\n\t\tassert.ok(retrieved);\n\t\tassert.strictEqual(retrieved.id, 'testToolSetId');\n\t\tassert.strictEqual(retrieved.referenceName, 'testToolSetName');\n\n\t\t// Should not find non-existent tool set\n\t\tassert.strictEqual(service.getToolSet('nonExistentId'), undefined);\n\n\t\t// Dispose should remove it\n\t\ttoolSet.dispose();\n\t\tassert.strictEqual(service.getToolSet('testToolSetId'), undefined);\n\t});\n\n\ttest('getToolSetByName', () => {\n\t\tstore.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'toolSet1',\n\t\t\t'refName1'\n\t\t));\n\n\t\tstore.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'toolSet2',\n\t\t\t'refName2'\n\t\t));\n\n\t\t// Should find by reference name\n\t\tassert.strictEqual(service.getToolSetByName('refName1')?.id, 'toolSet1');\n\t\tassert.strictEqual(service.getToolSetByName('refName2')?.id, 'toolSet2');\n\n\t\t// Should not find non-existent name\n\t\tassert.strictEqual(service.getToolSetByName('nonExistentName'), undefined);\n\t});\n\n\ttest('getTools with includeDisabled parameter', () => {\n\t\t// Test the includeDisabled parameter behavior with context keys\n\t\tcontextKeyService.createKey('testKey', false);\n\t\tconst disabledTool: IToolData = {\n\t\t\tid: 'disabledTool',\n\t\t\tmodelDescription: 'Disabled Tool',\n\t\t\tdisplayName: 'Disabled Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\twhen: ContextKeyEqualsExpr.create('testKey', true), // Will be disabled since testKey is false\n\t\t};\n\n\t\tconst enabledTool: IToolData = {\n\t\t\tid: 'enabledTool',\n\t\t\tmodelDescription: 'Enabled Tool',\n\t\t\tdisplayName: 'Enabled Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(disabledTool));\n\t\tstore.add(service.registerToolData(enabledTool));\n\n\t\tconst enabledTools = Array.from(service.getTools());\n\t\tassert.strictEqual(enabledTools.length, 1, 'Should only return enabled tools');\n\t\tassert.strictEqual(enabledTools[0].id, 'enabledTool');\n\n\t\tconst allTools = Array.from(service.getTools(true));\n\t\tassert.strictEqual(allTools.length, 2, 'includeDisabled should return all tools');\n\t});\n\n\ttest('tool registration duplicate error', () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'duplicateTool',\n\t\t\tmodelDescription: 'Duplicate Tool',\n\t\t\tdisplayName: 'Duplicate Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\t// First registration should succeed\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\t// Second registration should throw\n\t\tassert.throws(() => {\n\t\t\tservice.registerToolData(toolData);\n\t\t}, /Tool \"duplicateTool\" is already registered/);\n\t});\n\n\ttest('tool implementation registration without data throws', () => {\n\t\tconst toolImpl: IToolImpl = {\n\t\t\tinvoke: async () => ({ content: [] }),\n\t\t};\n\n\t\t// Should throw when registering implementation for non-existent tool\n\t\tassert.throws(() => {\n\t\t\tservice.registerToolImplementation('nonExistentTool', toolImpl);\n\t\t}, /Tool \"nonExistentTool\" was not contributed/);\n\t});\n\n\ttest('tool implementation duplicate registration throws', () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testTool',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolImpl1: IToolImpl = {\n\t\t\tinvoke: async () => ({ content: [] }),\n\t\t};\n\n\t\tconst toolImpl2: IToolImpl = {\n\t\t\tinvoke: async () => ({ content: [] }),\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\t\tstore.add(service.registerToolImplementation('testTool', toolImpl1));\n\n\t\t// Second implementation should throw\n\t\tassert.throws(() => {\n\t\t\tservice.registerToolImplementation('testTool', toolImpl2);\n\t\t}, /Tool \"testTool\" already has an implementation/);\n\t});\n\n\ttest('invokeTool with unknown tool throws', async () => {\n\t\tconst dto: IToolInvocation = {\n\t\t\tcallId: '1',\n\t\t\ttoolId: 'unknownTool',\n\t\t\ttokenBudget: 100,\n\t\t\tparameters: {},\n\t\t\tcontext: undefined,\n\t\t};\n\n\t\tawait assert.rejects(\n\t\t\tservice.invokeTool(dto, async () => 0, CancellationToken.None),\n\t\t\t/Tool unknownTool was not contributed/\n\t\t);\n\t});\n\n\ttest('invokeTool without implementation activates extension and throws if still not found', async () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'extensionActivationTool',\n\t\t\tmodelDescription: 'Extension Tool',\n\t\t\tdisplayName: 'Extension Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\tconst dto: IToolInvocation = {\n\t\t\tcallId: '1',\n\t\t\ttoolId: 'extensionActivationTool',\n\t\t\ttokenBudget: 100,\n\t\t\tparameters: {},\n\t\t\tcontext: undefined,\n\t\t};\n\n\t\t// Should throw after attempting extension activation\n\t\tawait assert.rejects(\n\t\t\tservice.invokeTool(dto, async () => 0, CancellationToken.None),\n\t\t\t/Tool extensionActivationTool does not have an implementation registered/\n\t\t);\n\t});\n\n\ttest('invokeTool without context (non-chat scenario)', async () => {\n\t\tconst tool = registerToolForTest(service, store, 'nonChatTool', {\n\t\t\tinvoke: async (invocation) => {\n\t\t\t\tassert.strictEqual(invocation.context, undefined);\n\t\t\t\treturn { content: [{ kind: 'text', value: 'non-chat result' }] };\n\t\t\t}\n\t\t});\n\n\t\tconst dto = tool.makeDto({ test: 1 }); // No context\n\n\t\tconst result = await service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tassert.strictEqual(result.content[0].value, 'non-chat result');\n\t});\n\n\ttest('invokeTool with unknown chat session throws', async () => {\n\t\tconst tool = registerToolForTest(service, store, 'unknownSessionTool', {\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'should not reach' }] })\n\t\t});\n\n\t\tconst dto = tool.makeDto({ test: 1 }, { sessionId: 'unknownSession' });\n\n\t\t// Test that it throws, regardless of exact error message\n\t\tlet threwError = false;\n\t\ttry {\n\t\t\tawait service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\t} catch (err) {\n\t\t\tthrewError = true;\n\t\t\t// Verify it's one of the expected error types\n\t\t\tassert.ok(\n\t\t\t\terr instanceof Error && (\n\t\t\t\t\terr.message.includes('Tool called for unknown chat session') ||\n\t\t\t\t\terr.message.includes('getRequests is not a function')\n\t\t\t\t),\n\t\t\t\t`Unexpected error: ${err.message}`\n\t\t\t);\n\t\t}\n\t\tassert.strictEqual(threwError, true, 'Should have thrown an error');\n\t});\n\n\ttest('tool error with alwaysDisplayInputOutput includes details', async () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'errorToolWithIO',\n\t\t\tmodelDescription: 'Error Tool With IO',\n\t\t\tdisplayName: 'Error Tool With IO',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\talwaysDisplayInputOutput: true\n\t\t};\n\n\t\tconst tool = registerToolForTest(service, store, toolData.id, {\n\t\t\tinvoke: async () => { throw new Error('Tool execution failed'); }\n\t\t}, toolData);\n\n\t\tconst input = { param: 'testValue' };\n\n\t\ttry {\n\t\t\tawait service.invokeTool(\n\t\t\t\ttool.makeDto(input),\n\t\t\t\tasync () => 0,\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\t\t\tassert.fail('Should have thrown');\n\t\t} catch (err: any) {\n\t\t\t// The error should bubble up, but we need to check if toolResultError is set\n\t\t\t// This tests the internal error handling path\n\t\t\tassert.strictEqual(err.message, 'Tool execution failed');\n\t\t}\n\t});\n\n\ttest('context key changes trigger tool updates', async () => {\n\t\tlet changeEventFired = false;\n\t\tconst disposable = service.onDidChangeTools(() => {\n\t\t\tchangeEventFired = true;\n\t\t});\n\t\tstore.add(disposable);\n\n\t\t// Create a tool with a context key dependency\n\t\tcontextKeyService.createKey('dynamicKey', false);\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'contextTool',\n\t\t\tmodelDescription: 'Context Tool',\n\t\t\tdisplayName: 'Context Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\twhen: ContextKeyEqualsExpr.create('dynamicKey', true),\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\t// Change the context key value\n\t\tcontextKeyService.createKey('dynamicKey', true);\n\n\t\t// Wait a bit for the scheduler\n\t\tawait new Promise(resolve => setTimeout(resolve, 800));\n\n\t\tassert.strictEqual(changeEventFired, true, 'onDidChangeTools should fire when context keys change');\n\t});\n\n\ttest('configuration changes trigger tool updates', async () => {\n\t\treturn runWithFakedTimers({}, async () => {\n\t\t\tlet changeEventFired = false;\n\t\t\tconst disposable = service.onDidChangeTools(() => {\n\t\t\t\tchangeEventFired = true;\n\t\t\t});\n\t\t\tstore.add(disposable);\n\n\t\t\t// Change the correct configuration key\n\t\t\tconfigurationService.setUserConfiguration('chat.extensionTools.enabled', false);\n\t\t\t// Fire the configuration change event manually\n\t\t\tconfigurationService.onDidChangeConfigurationEmitter.fire({\n\t\t\t\taffectsConfiguration: () => true,\n\t\t\t\taffectedKeys: new Set(['chat.extensionTools.enabled']),\n\t\t\t\tchange: null!,\n\t\t\t\tsource: ConfigurationTarget.USER\n\t\t\t} satisfies IConfigurationChangeEvent);\n\n\t\t\t// Wait a bit for the scheduler\n\t\t\tawait new Promise(resolve => setTimeout(resolve, 800));\n\n\t\t\tassert.strictEqual(changeEventFired, true, 'onDidChangeTools should fire when configuration changes');\n\t\t});\n\t});\n\n\ttest('toToolAndToolSetEnablementMap with MCP toolset enables contained tools', () => {\n\t\t// Create MCP toolset\n\t\tconst mcpToolSet = store.add(service.createToolSet(\n\t\t\t{ type: 'mcp', label: 'testServer', serverLabel: 'testServer', instructions: undefined, collectionId: 'testCollection', definitionId: 'testDef' },\n\t\t\t'mcpSet',\n\t\t\t'mcpSetRef'\n\t\t));\n\n\t\tconst mcpTool: IToolData = {\n\t\t\tid: 'mcpTool',\n\t\t\tmodelDescription: 'MCP Tool',\n\t\t\tdisplayName: 'MCP Tool',\n\t\t\tsource: { type: 'mcp', label: 'testServer', serverLabel: 'testServer', instructions: undefined, collectionId: 'testCollection', definitionId: 'testDef' },\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t\ttoolReferenceName: 'mcpToolRef'\n\t\t};\n\n\t\tstore.add(service.registerToolData(mcpTool));\n\t\tstore.add(mcpToolSet.addTool(mcpTool));\n\n\t\t// Enable the MCP toolset\n\t\t{\n\t\t\tconst enabledNames = [mcpToolSet].map(t => service.getQualifiedToolName(t));\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(enabledNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(mcpToolSet), true, 'MCP toolset should be enabled'); // Ensure the toolset is in the map\n\t\t\tassert.strictEqual(result.get(mcpTool), true, 'MCP tool should be enabled when its toolset is enabled'); // Ensure the tool is in the map\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), enabledNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Enable a tool from the MCP toolset\n\t\t{\n\t\t\tconst enabledNames = [mcpTool].map(t => service.getQualifiedToolName(t, mcpToolSet));\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(enabledNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(mcpToolSet), false, 'MCP toolset should be disabled'); // Ensure the toolset is in the map\n\t\t\tassert.strictEqual(result.get(mcpTool), true, 'MCP tool should be enabled'); // Ensure the tool is in the map\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), enabledNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\n\t});\n\n\ttest('shouldAutoConfirm with workspace-specific tool configuration', async () => {\n\t\tconst testConfigService = new TestConfigurationService();\n\t\t// Configure per-tool settings at different scopes\n\t\ttestConfigService.setUserConfiguration('chat.tools.global.autoApprove', { 'workspaceTool': true });\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\tconst workspaceTool = registerToolForTest(testService, store, 'workspaceTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Test', message: 'Workspace tool' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'workspace result' }] })\n\t\t}, { runsInWorkspace: true });\n\n\t\tconst sessionId = 'workspace-test';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\t// Should auto-approve based on user configuration\n\t\tconst result = await testService.invokeTool(\n\t\t\tworkspaceTool.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(result.content[0].value, 'workspace result');\n\t});\n\n\ttest('getQualifiedToolNames', () => {\n\t\tsetupToolsForTest(service, store);\n\n\t\tconst qualifiedNames = Array.from(service.getQualifiedToolNames()).sort();\n\n\t\tconst expectedNames = [\n\t\t\t'tool1RefName',\n\t\t\t'Tool2 Display Name',\n\t\t\t'my.extension/extTool1RefName',\n\t\t\t'mcpToolSetRefName/*',\n\t\t\t'mcpToolSetRefName/mcpTool1RefName',\n\t\t\t'internalToolSetRefName',\n\t\t\t'internalToolSetRefName/internalToolSetTool1RefName',\n\t\t\t'vscode',\n\t\t\t'launch'\n\t\t].sort();\n\n\t\tassert.deepStrictEqual(qualifiedNames, expectedNames, 'getQualifiedToolNames should return correct qualified names');\n\t});\n\n\ttest('getDeprecatedQualifiedToolNames', () => {\n\t\tsetupToolsForTest(service, store);\n\n\t\tconst deprecatedNames = service.getDeprecatedQualifiedToolNames();\n\n\t\t// Tools in internal tool sets should have their qualified names with toolset prefix, tools sets keep their name\n\t\tassert.deepStrictEqual(deprecatedNames.get('internalToolSetTool1RefName'), new Set(['internalToolSetRefName/internalToolSetTool1RefName']));\n\t\tassert.strictEqual(deprecatedNames.get('internalToolSetRefName'), undefined);\n\n\t\t// For extension tools, the qualified name includes the extension ID\n\t\tassert.deepStrictEqual(deprecatedNames.get('extTool1RefName'), new Set(['my.extension/extTool1RefName']));\n\n\t\t// For MCP tool sets, the qualified name includes the /* suffix\n\t\tassert.deepStrictEqual(deprecatedNames.get('mcpToolSetRefName'), new Set(['mcpToolSetRefName/*']));\n\t\tassert.deepStrictEqual(deprecatedNames.get('mcpTool1RefName'), new Set(['mcpToolSetRefName/mcpTool1RefName']));\n\n\t\t// Internal tool sets and user tools sets and tools without namespace changes should not appear\n\t\tassert.strictEqual(deprecatedNames.get('Tool2 Display Name'), undefined);\n\t\tassert.strictEqual(deprecatedNames.get('tool1RefName'), undefined);\n\t\tassert.strictEqual(deprecatedNames.get('userToolSetRefName'), undefined);\n\t});\n\n\ttest('getToolByQualifiedName', () => {\n\t\tsetupToolsForTest(service, store);\n\n\t\t// Test finding tools by their qualified names\n\t\tconst tool1 = service.getToolByQualifiedName('tool1RefName');\n\t\tassert.ok(tool1);\n\t\tassert.strictEqual(tool1.id, 'tool1');\n\n\t\tconst tool2 = service.getToolByQualifiedName('Tool2 Display Name');\n\t\tassert.ok(tool2);\n\t\tassert.strictEqual(tool2.id, 'tool2');\n\n\t\tconst extTool = service.getToolByQualifiedName('my.extension/extTool1RefName');\n\t\tassert.ok(extTool);\n\t\tassert.strictEqual(extTool.id, 'extTool1');\n\n\t\tconst mcpTool = service.getToolByQualifiedName('mcpToolSetRefName/mcpTool1RefName');\n\t\tassert.ok(mcpTool);\n\t\tassert.strictEqual(mcpTool.id, 'mcpTool1');\n\n\n\t\tconst mcpToolSet = service.getToolByQualifiedName('mcpToolSetRefName/*');\n\t\tassert.ok(mcpToolSet);\n\t\tassert.strictEqual(mcpToolSet.id, 'mcpToolSet');\n\n\t\tconst internalToolSet = service.getToolByQualifiedName('internalToolSetRefName/internalToolSetTool1RefName');\n\t\tassert.ok(internalToolSet);\n\t\tassert.strictEqual(internalToolSet.id, 'internalToolSetTool1');\n\n\t\t// Test finding tools within tool sets\n\t\tconst toolInSet = service.getToolByQualifiedName('internalToolSetRefName');\n\t\tassert.ok(toolInSet);\n\t\tassert.strictEqual(toolInSet!.id, 'internalToolSet');\n\n\t});\n\n\ttest('eligibleForAutoApproval setting can be configured via policy', async () => {\n\t\t// Test that policy configuration works for eligibleForAutoApproval\n\t\t// Policy values should be JSON strings for object-type settings\n\t\tconst testConfigService = new TestConfigurationService();\n\n\t\t// Simulate policy configuration (would come from policy file)\n\t\tconst policyValue = {\n\t\t\t'toolA': true,\n\t\t\t'toolB': false\n\t\t};\n\t\ttestConfigService.setUserConfiguration('chat.tools.eligibleForAutoApproval', policyValue);\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\t// Tool A is eligible (true in policy)\n\t\tconst toolA = registerToolForTest(testService, store, 'toolA', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'toolA executed' }] })\n\t\t}, {\n\t\t\ttoolReferenceName: 'toolA'\n\t\t});\n\n\t\t// Tool B is ineligible (false in policy)\n\t\tconst toolB = registerToolForTest(testService, store, 'toolB', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'toolB executed' }] })\n\t\t}, {\n\t\t\ttoolReferenceName: 'toolB'\n\t\t});\n\n\t\tconst sessionId = 'test-policy';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\t// Tool A should execute without confirmation (eligible)\n\t\tconst resultA = await testService.invokeTool(\n\t\t\ttoolA.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(resultA.content[0].value, 'toolA executed');\n\n\t\t// Tool B should require confirmation (ineligible)\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId + '2', { requestId: 'req2', capture });\n\t\tconst promiseB = testService.invokeTool(\n\t\t\ttoolB.makeDto({ test: 2 }, { sessionId: sessionId + '2' }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tassert.ok(published?.confirmationMessages, 'toolB should require confirmation due to policy');\n\t\tassert.strictEqual(published?.confirmationMessages?.allowAutoConfirm, false, 'should not allow auto confirm');\n\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst resultB = await promiseB;\n\t\tassert.strictEqual(resultB.content[0].value, 'toolB executed');\n\t});\n\n\n\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport { Barrier } from '../../../../../base/common/async.js';\nimport { VSBuffer } from '../../../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { CancellationError, isCancellationError } from '../../../../../base/common/errors.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { IAccessibilityService } from '../../../../../platform/accessibility/common/accessibility.js';\nimport { TestAccessibilityService } from '../../../../../platform/accessibility/test/common/testAccessibilityService.js';\nimport { AccessibilitySignal, IAccessibilitySignalService } from '../../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js';\nimport { ConfigurationTarget, IConfigurationChangeEvent } from '../../../../../platform/configuration/common/configuration.js';\nimport { TestConfigurationService } from '../../../../../platform/configuration/test/common/testConfigurationService.js';\nimport { ContextKeyService } from '../../../../../platform/contextkey/browser/contextKeyService.js';\nimport { ContextKeyEqualsExpr, IContextKeyService } from '../../../../../platform/contextkey/common/contextkey.js';\nimport { ExtensionIdentifier } from '../../../../../platform/extensions/common/extensions.js';\nimport { ITelemetryService } from '../../../../../platform/telemetry/common/telemetry.js';\nimport { workbenchInstantiationService } from '../../../../test/browser/workbenchTestServices.js';\nimport { LanguageModelToolsService } from '../../browser/languageModelToolsService.js';\nimport { ChatModel, IChatModel } from '../../common/chatModel.js';\nimport { IChatService, IChatToolInputInvocationData, IChatToolInvocation, ToolConfirmKind } from '../../common/chatService.js';\nimport { ChatConfiguration } from '../../common/constants.js';\nimport { GithubCopilotToolReference, isToolResultInputOutputDetails, IToolData, IToolImpl, IToolInvocation, ToolDataSource, ToolSet, VSCodeToolReference } from '../../common/languageModelToolsService.js';\nimport { MockChatService } from '../common/mockChatService.js';\nimport { ChatToolInvocation } from '../../common/chatProgressTypes/chatToolInvocation.js';\nimport { LocalChatSessionUri } from '../../common/chatUri.js';\nimport { ILanguageModelToolsConfirmationService } from '../../common/languageModelToolsConfirmationService.js';\nimport { MockLanguageModelToolsConfirmationService } from '../common/mockLanguageModelToolsConfirmationService.js';\nimport { runWithFakedTimers } from '../../../../../base/test/common/timeTravelScheduler.js';\n\n// --- Test helpers to reduce repetition and improve readability ---\n\nclass TestAccessibilitySignalService implements Partial<IAccessibilitySignalService> {\n\tpublic signalPlayedCalls: { signal: AccessibilitySignal; options?: any }[] = [];\n\n\tasync playSignal(signal: AccessibilitySignal, options?: any): Promise<void> {\n\t\tthis.signalPlayedCalls.push({ signal, options });\n\t}\n\n\treset() {\n\t\tthis.signalPlayedCalls = [];\n\t}\n}\n\nclass TestTelemetryService implements Partial<ITelemetryService> {\n\tpublic events: Array<{ eventName: string; data: any }> = [];\n\n\tpublicLog2<E extends Record<string, any>, T extends Record<string, any>>(eventName: string, data?: E): void {\n\t\tthis.events.push({ eventName, data });\n\t}\n\n\treset() {\n\t\tthis.events = [];\n\t}\n}\n\nfunction registerToolForTest(service: LanguageModelToolsService, store: any, id: string, impl: IToolImpl, data?: Partial<IToolData>) {\n\tconst toolData: IToolData = {\n\t\tid,\n\t\tmodelDescription: data?.modelDescription ?? 'Test Tool',\n\t\tdisplayName: data?.displayName ?? 'Test Tool',\n\t\tsource: ToolDataSource.Internal,\n\t\t...data,\n\t};\n\tstore.add(service.registerTool(toolData, impl));\n\treturn {\n\t\tid,\n\t\tmakeDto: (parameters: any, context?: { sessionId: string }, callId: string = '1'): IToolInvocation => ({\n\t\t\tcallId,\n\t\t\ttoolId: id,\n\t\t\ttokenBudget: 100,\n\t\t\tparameters,\n\t\t\tcontext: context ? {\n\t\t\t\tsessionId: context.sessionId,\n\t\t\t\tsessionResource: LocalChatSessionUri.forSession(context.sessionId),\n\t\t\t} : undefined,\n\t\t}),\n\t};\n}\n\nfunction stubGetSession(chatService: MockChatService, sessionId: string, options?: { requestId?: string; capture?: { invocation?: any } }): IChatModel {\n\tconst requestId = options?.requestId ?? 'requestId';\n\tconst capture = options?.capture;\n\tconst fakeModel = {\n\t\tsessionId,\n\t\tsessionResource: LocalChatSessionUri.forSession(sessionId),\n\t\tgetRequests: () => [{ id: requestId, modelId: 'test-model' }],\n\t} as ChatModel;\n\tchatService.addSession(fakeModel);\n\tchatService.appendProgress = (request, progress) => {\n\t\tif (capture) { capture.invocation = progress; }\n\t};\n\n\treturn fakeModel;\n}\n\nasync function waitForPublishedInvocation(capture: { invocation?: any }, tries = 5): Promise<ChatToolInvocation> {\n\tfor (let i = 0; i < tries && !capture.invocation; i++) {\n\t\tawait Promise.resolve();\n\t}\n\treturn capture.invocation;\n}\n\nsuite('LanguageModelToolsService', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tlet contextKeyService: IContextKeyService;\n\tlet service: LanguageModelToolsService;\n\tlet chatService: MockChatService;\n\tlet configurationService: TestConfigurationService;\n\n\tsetup(() => {\n\t\tconfigurationService = new TestConfigurationService();\n\t\tconfigurationService.setUserConfiguration(ChatConfiguration.ExtensionToolsEnabled, true);\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(configurationService)),\n\t\t\tconfigurationService: () => configurationService\n\t\t}, store);\n\t\tcontextKeyService = instaService.get(IContextKeyService);\n\t\tchatService = new MockChatService();\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tservice = store.add(instaService.createInstance(LanguageModelToolsService));\n\t});\n\n\tfunction setupToolsForTest(service: LanguageModelToolsService, store: any) {\n\n\t\t// Create a variety of tools and tool sets for testing\n\t\t// Some with toolReferenceName, some without, some from extensions, mcp and user defined\n\n\t\tconst tool1: IToolData = {\n\t\t\tid: 'tool1',\n\t\t\ttoolReferenceName: 'tool1RefName',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\tdisplayName: 'Tool1 Display Name',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(tool1));\n\n\t\tconst tool2: IToolData = {\n\t\t\tid: 'tool2',\n\t\t\tmodelDescription: 'Test Tool 2',\n\t\t\tdisplayName: 'Tool2 Display Name',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(tool2));\n\n\t\t/** Extension Tool 1 */\n\n\t\tconst extTool1: IToolData = {\n\t\t\tid: 'extTool1',\n\t\t\ttoolReferenceName: 'extTool1RefName',\n\t\t\tmodelDescription: 'Test Extension Tool 1',\n\t\t\tdisplayName: 'ExtTool1 Display Name',\n\t\t\tsource: { type: 'extension', label: 'My Extension', extensionId: new ExtensionIdentifier('my.extension') },\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(extTool1));\n\n\t\t/** Internal Tool Set with internalToolSetTool1 */\n\n\t\tconst internalToolSetTool1: IToolData = {\n\t\t\tid: 'internalToolSetTool1',\n\t\t\ttoolReferenceName: 'internalToolSetTool1RefName',\n\t\t\tmodelDescription: 'Test Internal Tool Set 1',\n\t\t\tdisplayName: 'InternalToolSet1 Display Name',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\t\tstore.add(service.registerToolData(internalToolSetTool1));\n\n\t\tconst internalToolSet = store.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'internalToolSet',\n\t\t\t'internalToolSetRefName',\n\t\t\t{ description: 'Test Set' }\n\t\t));\n\t\tstore.add(internalToolSet.addTool(internalToolSetTool1));\n\n\t\t/** User Tool Set with tool1 */\n\n\t\tconst userToolSet = store.add(service.createToolSet(\n\t\t\t{ type: 'user', label: 'User', file: URI.file('/test/userToolSet.json') },\n\t\t\t'userToolSet',\n\t\t\t'userToolSetRefName',\n\t\t\t{ description: 'Test Set' }\n\t\t));\n\t\tstore.add(userToolSet.addTool(tool2));\n\n\t\t/** MCP tool in a MCP tool set */\n\n\t\tconst mcpDataSource: ToolDataSource = { type: 'mcp', label: 'My MCP Server', serverLabel: 'MCP Server', instructions: undefined, collectionId: 'testMCPCollection', definitionId: 'testMCPDefId' };\n\t\tconst mcpTool1: IToolData = {\n\t\t\tid: 'mcpTool1',\n\t\t\ttoolReferenceName: 'mcpTool1RefName',\n\t\t\tmodelDescription: 'Test MCP Tool 1',\n\t\t\tdisplayName: 'McpTool1 Display Name',\n\t\t\tsource: mcpDataSource,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(mcpTool1));\n\n\t\tconst mcpToolSet = store.add(service.createToolSet(\n\t\t\tmcpDataSource,\n\t\t\t'mcpToolSet',\n\t\t\t'mcpToolSetRefName',\n\t\t\t{ description: 'MCP Test ToolSet' }\n\t\t));\n\t\tstore.add(mcpToolSet.addTool(mcpTool1));\n\t}\n\n\n\ttest('registerToolData', () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testTool',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst disposable = service.registerToolData(toolData);\n\t\tassert.strictEqual(service.getTool('testTool')?.id, 'testTool');\n\t\tdisposable.dispose();\n\t\tassert.strictEqual(service.getTool('testTool'), undefined);\n\t});\n\n\ttest('registerToolImplementation', () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testTool',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\tconst toolImpl: IToolImpl = {\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'result' }] }),\n\t\t};\n\n\t\tstore.add(service.registerToolImplementation('testTool', toolImpl));\n\t\tassert.strictEqual(service.getTool('testTool')?.id, 'testTool');\n\t});\n\n\ttest('getTools', () => {\n\t\tcontextKeyService.createKey('testKey', true);\n\t\tconst toolData1: IToolData = {\n\t\t\tid: 'testTool1',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\twhen: ContextKeyEqualsExpr.create('testKey', false),\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolData2: IToolData = {\n\t\t\tid: 'testTool2',\n\t\t\tmodelDescription: 'Test Tool 2',\n\t\t\twhen: ContextKeyEqualsExpr.create('testKey', true),\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolData3: IToolData = {\n\t\t\tid: 'testTool3',\n\t\t\tmodelDescription: 'Test Tool 3',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData1));\n\t\tstore.add(service.registerToolData(toolData2));\n\t\tstore.add(service.registerToolData(toolData3));\n\n\t\tconst tools = Array.from(service.getTools());\n\t\tassert.strictEqual(tools.length, 2);\n\t\tassert.strictEqual(tools[0].id, 'testTool2');\n\t\tassert.strictEqual(tools[1].id, 'testTool3');\n\t});\n\n\ttest('getToolByName', () => {\n\t\tcontextKeyService.createKey('testKey', true);\n\t\tconst toolData1: IToolData = {\n\t\t\tid: 'testTool1',\n\t\t\ttoolReferenceName: 'testTool1',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\twhen: ContextKeyEqualsExpr.create('testKey', false),\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolData2: IToolData = {\n\t\t\tid: 'testTool2',\n\t\t\ttoolReferenceName: 'testTool2',\n\t\t\tmodelDescription: 'Test Tool 2',\n\t\t\twhen: ContextKeyEqualsExpr.create('testKey', true),\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolData3: IToolData = {\n\t\t\tid: 'testTool3',\n\t\t\ttoolReferenceName: 'testTool3',\n\t\t\tmodelDescription: 'Test Tool 3',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData1));\n\t\tstore.add(service.registerToolData(toolData2));\n\t\tstore.add(service.registerToolData(toolData3));\n\n\t\tassert.strictEqual(service.getToolByName('testTool1'), undefined);\n\t\tassert.strictEqual(service.getToolByName('testTool1', true)?.id, 'testTool1');\n\t\tassert.strictEqual(service.getToolByName('testTool2')?.id, 'testTool2');\n\t\tassert.strictEqual(service.getToolByName('testTool3')?.id, 'testTool3');\n\t});\n\n\ttest('invokeTool', async () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testTool',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\tconst toolImpl: IToolImpl = {\n\t\t\tinvoke: async (invocation) => {\n\t\t\t\tassert.strictEqual(invocation.callId, '1');\n\t\t\t\tassert.strictEqual(invocation.toolId, 'testTool');\n\t\t\t\tassert.deepStrictEqual(invocation.parameters, { a: 1 });\n\t\t\t\treturn { content: [{ kind: 'text', value: 'result' }] };\n\t\t\t}\n\t\t};\n\n\t\tstore.add(service.registerToolImplementation('testTool', toolImpl));\n\n\t\tconst dto: IToolInvocation = {\n\t\t\tcallId: '1',\n\t\t\ttoolId: 'testTool',\n\t\t\ttokenBudget: 100,\n\t\t\tparameters: {\n\t\t\t\ta: 1\n\t\t\t},\n\t\t\tcontext: undefined,\n\t\t};\n\n\t\tconst result = await service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tassert.strictEqual(result.content[0].value, 'result');\n\t});\n\n\ttest('invocation parameters are overridden by input toolSpecificData', async () => {\n\t\tconst rawInput = { b: 2 };\n\t\tconst tool = registerToolForTest(service, store, 'testToolInputOverride', {\n\t\t\tprepareToolInvocation: async () => ({\n\t\t\t\ttoolSpecificData: { kind: 'input', rawInput } satisfies IChatToolInputInvocationData,\n\t\t\t\tconfirmationMessages: {\n\t\t\t\t\ttitle: 'a',\n\t\t\t\t\tmessage: 'b',\n\t\t\t\t}\n\t\t\t}),\n\t\t\tinvoke: async (invocation) => {\n\t\t\t\t// The service should replace parameters with rawInput and strip toolSpecificData\n\t\t\t\tassert.deepStrictEqual(invocation.parameters, rawInput);\n\t\t\t\tassert.strictEqual(invocation.toolSpecificData, undefined);\n\t\t\t\treturn { content: [{ kind: 'text', value: 'ok' }] };\n\t\t\t},\n\t\t});\n\n\t\tconst sessionId = 'sessionId';\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId, { requestId: 'requestId-io', capture });\n\t\tconst dto = tool.makeDto({ a: 1 }, { sessionId });\n\n\t\tconst invokeP = service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst result = await invokeP;\n\t\tassert.strictEqual(result.content[0].value, 'ok');\n\t});\n\n\ttest('chat invocation injects input toolSpecificData for confirmation when alwaysDisplayInputOutput', async () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testToolDisplayIO',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\talwaysDisplayInputOutput: true,\n\t\t};\n\n\t\tconst tool = registerToolForTest(service, store, 'testToolDisplayIO', {\n\t\t\tprepareToolInvocation: async () => ({\n\t\t\t\tconfirmationMessages: { title: 'Confirm', message: 'Proceed?' }\n\t\t\t}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'done' }] }),\n\t\t}, toolData);\n\n\t\tconst sessionId = 'sessionId-io';\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId, { requestId: 'requestId-io', capture });\n\n\t\tconst dto = tool.makeDto({ a: 1 }, { sessionId });\n\n\t\tconst invokeP = service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tassert.ok(published, 'expected ChatToolInvocation to be published');\n\t\tassert.strictEqual(published.toolId, tool.id);\n\t\t// The service should have injected input toolSpecificData with the raw parameters\n\t\tassert.strictEqual(published.toolSpecificData?.kind, 'input');\n\t\tassert.deepStrictEqual(published.toolSpecificData?.rawInput, dto.parameters);\n\n\t\t// Confirm to let invoke proceed\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst result = await invokeP;\n\t\tassert.strictEqual(result.content[0].value, 'done');\n\t});\n\n\ttest('chat invocation waits for user confirmation before invoking', async () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testToolConfirm',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tlet invoked = false;\n\t\tconst tool = registerToolForTest(service, store, toolData.id, {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Confirm', message: 'Go?' } }),\n\t\t\tinvoke: async () => {\n\t\t\t\tinvoked = true;\n\t\t\t\treturn { content: [{ kind: 'text', value: 'ran' }] };\n\t\t\t},\n\t\t}, toolData);\n\n\t\tconst sessionId = 'sessionId-confirm';\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId, { requestId: 'requestId-confirm', capture });\n\n\t\tconst dto = tool.makeDto({ x: 1 }, { sessionId });\n\n\t\tconst promise = service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tassert.ok(published, 'expected ChatToolInvocation to be published');\n\t\tassert.strictEqual(invoked, false, 'invoke should not run before confirmation');\n\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst result = await promise;\n\t\tassert.strictEqual(invoked, true, 'invoke should have run after confirmation');\n\t\tassert.strictEqual(result.content[0].value, 'ran');\n\t});\n\n\ttest('cancel tool call', async () => {\n\t\tconst toolBarrier = new Barrier();\n\t\tconst tool = registerToolForTest(service, store, 'testTool', {\n\t\t\tinvoke: async (invocation, countTokens, progress, cancelToken) => {\n\t\t\t\tassert.strictEqual(invocation.callId, '1');\n\t\t\t\tassert.strictEqual(invocation.toolId, 'testTool');\n\t\t\t\tassert.deepStrictEqual(invocation.parameters, { a: 1 });\n\t\t\t\tawait toolBarrier.wait();\n\t\t\t\tif (cancelToken.isCancellationRequested) {\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Tool call should be cancelled');\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst sessionId = 'sessionId';\n\t\tconst requestId = 'requestId';\n\t\tconst dto = tool.makeDto({ a: 1 }, { sessionId });\n\t\tstubGetSession(chatService, sessionId, { requestId });\n\t\tconst toolPromise = service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tservice.cancelToolCallsForRequest(requestId);\n\t\ttoolBarrier.open();\n\t\tawait assert.rejects(toolPromise, err => {\n\t\t\treturn isCancellationError(err);\n\t\t}, 'Expected tool call to be cancelled');\n\t});\n\n\ttest('toQualifiedToolNames', () => {\n\t\tsetupToolsForTest(service, store);\n\n\t\tconst tool1 = service.getToolByQualifiedName('tool1RefName');\n\t\tconst extTool1 = service.getToolByQualifiedName('my.extension/extTool1RefName');\n\t\tconst mcpToolSet = service.getToolByQualifiedName('mcpToolSetRefName/*');\n\t\tconst mcpTool1 = service.getToolByQualifiedName('mcpToolSetRefName/mcpTool1RefName');\n\t\tconst internalToolSet = service.getToolByQualifiedName('internalToolSetRefName');\n\t\tconst internalTool = service.getToolByQualifiedName('internalToolSetRefName/internalToolSetTool1RefName');\n\t\tconst userToolSet = service.getToolSet('userToolSet');\n\t\tconst unknownTool = { id: 'unregisteredTool', toolReferenceName: 'unregisteredToolRefName', modelDescription: 'Unregistered Tool', displayName: 'Unregistered Tool', source: ToolDataSource.Internal, canBeReferencedInPrompt: true } satisfies IToolData;\n\t\tconst unknownToolSet = service.createToolSet(ToolDataSource.Internal, 'unknownToolSet', 'unknownToolSetRefName', { description: 'Unknown Test Set' });\n\t\tunknownToolSet.dispose(); // unregister the set\n\t\tassert.ok(tool1);\n\t\tassert.ok(extTool1);\n\t\tassert.ok(mcpTool1);\n\t\tassert.ok(mcpToolSet);\n\t\tassert.ok(internalToolSet);\n\t\tassert.ok(internalTool);\n\t\tassert.ok(userToolSet);\n\n\t\t// Test with some enabled tool\n\t\t{\n\t\t\t// creating a map by hand is a no-go, we just do it for this test\n\t\t\tconst map = new Map<IToolData | ToolSet, boolean>([[tool1, true], [extTool1, true], [mcpToolSet, true], [mcpTool1, true]]);\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(map);\n\t\t\tconst expectedQualifiedNames = ['tool1RefName', 'my.extension/extTool1RefName', 'mcpToolSetRefName/*'];\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), expectedQualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Test with user data\n\t\t{\n\t\t\t// creating a map by hand is a no-go, we just do it for this test\n\t\t\tconst map = new Map<IToolData | ToolSet, boolean>([[tool1, true], [userToolSet, true], [internalToolSet, false], [internalTool, true]]);\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(map);\n\t\t\tconst expectedQualifiedNames = ['tool1RefName', 'internalToolSetRefName/internalToolSetTool1RefName'];\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), expectedQualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Test with unknown tool and tool set\n\t\t{\n\t\t\t// creating a map by hand is a no-go, we just do it for this test\n\t\t\tconst map = new Map<IToolData | ToolSet, boolean>([[unknownTool, true], [unknownToolSet, true], [internalToolSet, true], [internalTool, true]]);\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(map);\n\t\t\tconst expectedQualifiedNames = ['internalToolSetRefName'];\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), expectedQualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t});\n\n\ttest('toToolAndToolSetEnablementMap', () => {\n\t\tsetupToolsForTest(service, store);\n\n\t\tconst allQualifiedNames = [\n\t\t\t'tool1RefName',\n\t\t\t'Tool2 Display Name',\n\t\t\t'my.extension/extTool1RefName',\n\t\t\t'mcpToolSetRefName/*',\n\t\t\t'mcpToolSetRefName/mcpTool1RefName',\n\t\t\t'internalToolSetRefName',\n\t\t\t'internalToolSetRefName/internalToolSetTool1RefName',\n\t\t\t'vscode',\n\t\t\t'launch'\n\t\t];\n\t\tconst numOfTools = allQualifiedNames.length + 1; // +1 for userToolSet which has no qualified name but is a tool set\n\n\t\tconst tool1 = service.getToolByQualifiedName('tool1RefName');\n\t\tconst tool2 = service.getToolByQualifiedName('Tool2 Display Name');\n\t\tconst extTool1 = service.getToolByQualifiedName('my.extension/extTool1RefName');\n\t\tconst mcpToolSet = service.getToolByQualifiedName('mcpToolSetRefName/*');\n\t\tconst mcpTool1 = service.getToolByQualifiedName('mcpToolSetRefName/mcpTool1RefName');\n\t\tconst internalToolSet = service.getToolByQualifiedName('internalToolSetRefName');\n\t\tconst internalTool = service.getToolByQualifiedName('internalToolSetRefName/internalToolSetTool1RefName');\n\t\tconst userToolSet = service.getToolSet('userToolSet');\n\t\tconst vscodeToolSet = service.getToolSet('vscode');\n\t\tconst launchToolSet = service.getToolSet('launch');\n\t\tassert.ok(tool1);\n\t\tassert.ok(tool2);\n\t\tassert.ok(extTool1);\n\t\tassert.ok(mcpTool1);\n\t\tassert.ok(mcpToolSet);\n\t\tassert.ok(internalToolSet);\n\t\tassert.ok(internalTool);\n\t\tassert.ok(userToolSet);\n\t\tassert.ok(vscodeToolSet);\n\t\tassert.ok(launchToolSet);\n\t\t// Test with enabled tool\n\t\t{\n\t\t\tconst qualifiedNames = ['tool1RefName'];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 1, 'Expected 1 tool to be enabled');\n\t\t\tassert.strictEqual(result1.get(tool1), true, 'tool1 should be enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), qualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\n\t\t}\n\t\t// Test with multiple enabled tools\n\t\t{\n\t\t\tconst qualifiedNames = ['my.extension/extTool1RefName', 'mcpToolSetRefName/*', 'internalToolSetRefName/internalToolSetTool1RefName'];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 4, 'Expected 4 tools to be enabled');\n\t\t\tassert.strictEqual(result1.get(extTool1), true, 'extTool1 should be enabled');\n\t\t\tassert.strictEqual(result1.get(mcpToolSet), true, 'mcpToolSet should be enabled');\n\t\t\tassert.strictEqual(result1.get(mcpTool1), true, 'mcpTool1 should be enabled because the set is enabled');\n\t\t\tassert.strictEqual(result1.get(internalTool), true, 'internalTool should be enabled because the set is enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), qualifiedNames.sort(), 'toQualifiedToolNames should return the expected names');\n\t\t}\n\t\t// Test with all enabled tools, redundant names\n\t\t{\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(allQualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 10, 'Expected 10 tools to be enabled'); // +2 including the vscode, launch toolsets\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tconst expectedQualifiedNames = ['tool1RefName', 'Tool2 Display Name', 'my.extension/extTool1RefName', 'mcpToolSetRefName/*', 'internalToolSetRefName', 'vscode', 'launch'];\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), expectedQualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Test with no enabled tools\n\t\t{\n\t\t\tconst qualifiedNames: string[] = [];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 0, 'Expected 0 tools to be enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), qualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Test with unknown tool\n\t\t{\n\t\t\tconst qualifiedNames: string[] = ['unknownToolRefName'];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 0, 'Expected 0 tools to be enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), [], 'toQualifiedToolNames should return no enabled names');\n\t\t}\n\t\t// Test with legacy tool names\n\t\t{\n\t\t\tconst qualifiedNames: string[] = ['extTool1RefName', 'mcpToolSetRefName', 'internalToolSetTool1RefName'];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 4, 'Expected 4 tools to be enabled');\n\t\t\tassert.strictEqual(result1.get(extTool1), true, 'extTool1 should be enabled');\n\t\t\tassert.strictEqual(result1.get(mcpToolSet), true, 'mcpToolSet should be enabled');\n\t\t\tassert.strictEqual(result1.get(mcpTool1), true, 'mcpTool1 should be enabled because the set is enabled');\n\t\t\tassert.strictEqual(result1.get(internalTool), true, 'internalTool should be enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tconst expectedQualifiedNames: string[] = ['my.extension/extTool1RefName', 'mcpToolSetRefName/*', 'internalToolSetRefName/internalToolSetTool1RefName'];\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), expectedQualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Test with tool in user tool set\n\t\t{\n\t\t\tconst qualifiedNames = ['Tool2 Display Name'];\n\t\t\tconst result1 = service.toToolAndToolSetEnablementMap(qualifiedNames, undefined);\n\t\t\tassert.strictEqual(result1.size, numOfTools, `Expected ${numOfTools} tools and tool sets`);\n\t\t\tassert.strictEqual([...result1.entries()].filter(([_, enabled]) => enabled).length, 2, 'Expected 1 tool and user tool set to be enabled');\n\t\t\tassert.strictEqual(result1.get(tool2), true, 'tool2 should be enabled');\n\t\t\tassert.strictEqual(result1.get(userToolSet), true, 'userToolSet should be enabled');\n\n\t\t\tconst qualifiedNames1 = service.toQualifiedToolNames(result1);\n\t\t\tassert.deepStrictEqual(qualifiedNames1.sort(), qualifiedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\n\t\t}\n\t});\n\n\ttest('toToolAndToolSetEnablementMap with extension tool', () => {\n\t\t// Register individual tools\n\t\tconst toolData1: IToolData = {\n\t\t\tid: 'tool1',\n\t\t\ttoolReferenceName: 'refTool1',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\tdisplayName: 'Test Tool 1',\n\t\t\tsource: { type: 'extension', label: 'My Extension', extensionId: new ExtensionIdentifier('My.extension') },\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData1));\n\n\t\t// Test enabling the tool set\n\t\tconst enabledNames = [toolData1].map(t => service.getQualifiedToolName(t));\n\t\tconst result = service.toToolAndToolSetEnablementMap(enabledNames, undefined);\n\n\t\tassert.strictEqual(result.get(toolData1), true, 'individual tool should be enabled');\n\n\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\tassert.deepStrictEqual(qualifiedNames.sort(), enabledNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t});\n\n\ttest('toToolAndToolSetEnablementMap with tool sets', () => {\n\t\t// Register individual tools\n\t\tconst toolData1: IToolData = {\n\t\t\tid: 'tool1',\n\t\t\ttoolReferenceName: 'refTool1',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\tdisplayName: 'Test Tool 1',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\tconst toolData2: IToolData = {\n\t\t\tid: 'tool2',\n\t\t\tmodelDescription: 'Test Tool 2',\n\t\t\tdisplayName: 'Test Tool 2',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData1));\n\t\tstore.add(service.registerToolData(toolData2));\n\n\t\t// Create a tool set\n\t\tconst toolSet = store.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'testToolSet',\n\t\t\t'refToolSet',\n\t\t\t{ description: 'Test Tool Set' }\n\t\t));\n\n\t\t// Add tools to the tool set\n\t\tconst toolSetTool1: IToolData = {\n\t\t\tid: 'toolSetTool1',\n\t\t\tmodelDescription: 'Tool Set Tool 1',\n\t\t\tdisplayName: 'Tool Set Tool 1',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolSetTool2: IToolData = {\n\t\t\tid: 'toolSetTool2',\n\t\t\tmodelDescription: 'Tool Set Tool 2',\n\t\t\tdisplayName: 'Tool Set Tool 2',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolSetTool1));\n\t\tstore.add(service.registerToolData(toolSetTool2));\n\t\tstore.add(toolSet.addTool(toolSetTool1));\n\t\tstore.add(toolSet.addTool(toolSetTool2));\n\n\t\t// Test enabling the tool set\n\t\tconst enabledNames = [toolSet, toolData1].map(t => service.getQualifiedToolName(t));\n\t\tconst result = service.toToolAndToolSetEnablementMap(enabledNames, undefined);\n\n\t\tassert.strictEqual(result.get(toolData1), true, 'individual tool should be enabled');\n\t\tassert.strictEqual(result.get(toolData2), false);\n\t\tassert.strictEqual(result.get(toolSet), true, 'tool set should be enabled');\n\t\tassert.strictEqual(result.get(toolSetTool1), true, 'tool set tool 1 should be enabled');\n\t\tassert.strictEqual(result.get(toolSetTool2), true, 'tool set tool 2 should be enabled');\n\n\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\tassert.deepStrictEqual(qualifiedNames.sort(), enabledNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t});\n\n\ttest('toToolAndToolSetEnablementMap with non-existent tool names', () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'tool1',\n\t\t\ttoolReferenceName: 'refTool1',\n\t\t\tmodelDescription: 'Test Tool 1',\n\t\t\tdisplayName: 'Test Tool 1',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\tconst unregisteredToolData: IToolData = {\n\t\t\tid: 'toolX',\n\t\t\ttoolReferenceName: 'refToolX',\n\t\t\tmodelDescription: 'Test Tool X',\n\t\t\tdisplayName: 'Test Tool X',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\t// Test with non-existent tool names\n\t\tconst enabledNames = [toolData, unregisteredToolData].map(t => service.getQualifiedToolName(t));\n\t\tconst result = service.toToolAndToolSetEnablementMap(enabledNames, undefined);\n\n\t\tassert.strictEqual(result.get(toolData), true, 'existing tool should be enabled');\n\t\t// Non-existent tools should not appear in the result map\n\t\tassert.strictEqual(result.get(unregisteredToolData), undefined, 'non-existent tool should not be in result');\n\n\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\tconst expectedNames = [service.getQualifiedToolName(toolData)]; // Only the existing tool\n\t\tassert.deepStrictEqual(qualifiedNames.sort(), expectedNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\n\t});\n\n\n\ttest('toToolAndToolSetEnablementMap with legacy names', () => {\n\t\t// Test that legacy tool reference names and legacy toolset names work correctly\n\n\t\t// Create a tool with legacy reference names\n\t\tconst toolWithLegacy: IToolData = {\n\t\t\tid: 'newTool',\n\t\t\ttoolReferenceName: 'newToolRef',\n\t\t\tmodelDescription: 'New Tool',\n\t\t\tdisplayName: 'New Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t\tlegacyToolReferenceFullNames: ['oldToolName', 'deprecatedToolName']\n\t\t};\n\t\tstore.add(service.registerToolData(toolWithLegacy));\n\n\t\t// Create a tool set with legacy names\n\t\tconst toolSetWithLegacy = store.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'newToolSet',\n\t\t\t'newToolSetRef',\n\t\t\t{ description: 'New Tool Set', legacyFullNames: ['oldToolSet', 'deprecatedToolSet'] }\n\t\t));\n\n\t\t// Create a tool in the toolset\n\t\tconst toolInSet: IToolData = {\n\t\t\tid: 'toolInSet',\n\t\t\ttoolReferenceName: 'toolInSetRef',\n\t\t\tmodelDescription: 'Tool In Set',\n\t\t\tdisplayName: 'Tool In Set',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\t\tstore.add(service.registerToolData(toolInSet));\n\t\tstore.add(toolSetWithLegacy.addTool(toolInSet));\n\n\t\t// Test 1: Using legacy tool reference name should enable the tool\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolName'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithLegacy), true, 'tool should be enabled via legacy name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolRef'], 'should return current qualified name, not legacy');\n\t\t}\n\n\t\t// Test 2: Using another legacy tool reference name should also work\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['deprecatedToolName'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithLegacy), true, 'tool should be enabled via another legacy name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolRef'], 'should return current qualified name, not legacy');\n\t\t}\n\n\t\t// Test 3: Using legacy toolset name should enable the entire toolset\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolSetWithLegacy), true, 'toolset should be enabled via legacy name');\n\t\t\tassert.strictEqual(result.get(toolInSet), true, 'tool in set should be enabled when set is enabled via legacy name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolSetRef'], 'should return current qualified name, not legacy');\n\t\t}\n\n\t\t// Test 4: Using deprecated toolset name should also work\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['deprecatedToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolSetWithLegacy), true, 'toolset should be enabled via another legacy name');\n\t\t\tassert.strictEqual(result.get(toolInSet), true, 'tool in set should be enabled when set is enabled via legacy name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolSetRef'], 'should return current qualified name, not legacy');\n\t\t}\n\n\t\t// Test 5: Mix of current and legacy names\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['newToolRef', 'oldToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithLegacy), true, 'tool should be enabled via current name');\n\t\t\tassert.strictEqual(result.get(toolSetWithLegacy), true, 'toolset should be enabled via legacy name');\n\t\t\tassert.strictEqual(result.get(toolInSet), true, 'tool in set should be enabled');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), ['newToolRef', 'newToolSetRef'].sort(), 'should return current qualified names');\n\t\t}\n\n\t\t// Test 6: Using legacy names and current names together (redundant but should work)\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['newToolRef', 'oldToolName', 'deprecatedToolName'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithLegacy), true, 'tool should be enabled (redundant legacy names should not cause issues)');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolRef'], 'should return single current qualified name');\n\t\t}\n\t});\n\n\ttest('toToolAndToolSetEnablementMap with orphaned toolset in legacy names', () => {\n\t\t// Test that when a tool has a legacy name with a toolset prefix, but that toolset no longer exists,\n\t\t// we can enable the tool by either the full legacy name OR just the orphaned toolset name\n\n\t\t// Create a tool that used to be in 'oldToolSet/oldToolName' but now is just 'newToolRef'\n\t\tconst toolWithOrphanedToolSet: IToolData = {\n\t\t\tid: 'migratedTool',\n\t\t\ttoolReferenceName: 'newToolRef',\n\t\t\tmodelDescription: 'Migrated Tool',\n\t\t\tdisplayName: 'Migrated Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t\tlegacyToolReferenceFullNames: ['oldToolSet/oldToolName']\n\t\t};\n\t\tstore.add(service.registerToolData(toolWithOrphanedToolSet));\n\n\t\t// Test 1: Using the full legacy name should enable the tool\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet/oldToolName'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithOrphanedToolSet), true, 'tool should be enabled via full legacy name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolRef'], 'should return current qualified name');\n\t\t}\n\n\t\t// Test 2: Using just the orphaned toolset name should also enable the tool\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithOrphanedToolSet), true, 'tool should be enabled via orphaned toolset name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['newToolRef'], 'should return current qualified name');\n\t\t}\n\n\t\t// Test 3: Multiple tools from the same orphaned toolset\n\t\tconst anotherToolFromOrphanedSet: IToolData = {\n\t\t\tid: 'anotherMigratedTool',\n\t\t\ttoolReferenceName: 'anotherNewToolRef',\n\t\t\tmodelDescription: 'Another Migrated Tool',\n\t\t\tdisplayName: 'Another Migrated Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t\tlegacyToolReferenceFullNames: ['oldToolSet/anotherOldToolName']\n\t\t};\n\t\tstore.add(service.registerToolData(anotherToolFromOrphanedSet));\n\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithOrphanedToolSet), true, 'first tool should be enabled via orphaned toolset name');\n\t\t\tassert.strictEqual(result.get(anotherToolFromOrphanedSet), true, 'second tool should also be enabled via orphaned toolset name');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), ['newToolRef', 'anotherNewToolRef'].sort(), 'should return both current qualified names');\n\t\t}\n\n\t\t// Test 4: Orphaned toolset name should NOT enable tools that weren't in that toolset\n\t\tconst unrelatedTool: IToolData = {\n\t\t\tid: 'unrelatedTool',\n\t\t\ttoolReferenceName: 'unrelatedToolRef',\n\t\t\tmodelDescription: 'Unrelated Tool',\n\t\t\tdisplayName: 'Unrelated Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t\tlegacyToolReferenceFullNames: ['differentToolSet/oldName']\n\t\t};\n\t\tstore.add(service.registerToolData(unrelatedTool));\n\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet'], undefined);\n\t\t\tassert.strictEqual(result.get(toolWithOrphanedToolSet), true, 'tool from oldToolSet should be enabled');\n\t\t\tassert.strictEqual(result.get(anotherToolFromOrphanedSet), true, 'another tool from oldToolSet should be enabled');\n\t\t\tassert.strictEqual(result.get(unrelatedTool), false, 'tool from different toolset should NOT be enabled');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), ['newToolRef', 'anotherNewToolRef'].sort(), 'should only return tools from oldToolSet');\n\t\t}\n\n\t\t// Test 5: If a toolset with the same name exists, it should take precedence over orphaned toolset mapping\n\t\tconst newToolSetWithSameName = store.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'recreatedToolSet',\n\t\t\t'oldToolSet',  // Same name as the orphaned toolset\n\t\t\t{ description: 'Recreated Tool Set' }\n\t\t));\n\n\t\tconst toolInRecreatedSet: IToolData = {\n\t\t\tid: 'toolInRecreatedSet',\n\t\t\ttoolReferenceName: 'toolInRecreatedSetRef',\n\t\t\tmodelDescription: 'Tool In Recreated Set',\n\t\t\tdisplayName: 'Tool In Recreated Set',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\t\tstore.add(service.registerToolData(toolInRecreatedSet));\n\t\tstore.add(newToolSetWithSameName.addTool(toolInRecreatedSet));\n\n\t\t{\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(['oldToolSet'], undefined);\n\t\t\t// Now 'oldToolSet' should enable BOTH the recreated toolset AND the tools with legacy names pointing to oldToolSet\n\t\t\tassert.strictEqual(result.get(newToolSetWithSameName), true, 'recreated toolset should be enabled');\n\t\t\tassert.strictEqual(result.get(toolInRecreatedSet), true, 'tool in recreated set should be enabled');\n\t\t\t// The tools with legacy toolset names should ALSO be enabled because their legacy names match\n\t\t\tassert.strictEqual(result.get(toolWithOrphanedToolSet), true, 'tool with legacy toolset should still be enabled');\n\t\t\tassert.strictEqual(result.get(anotherToolFromOrphanedSet), true, 'another tool with legacy toolset should still be enabled');\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\t// Should return the toolset name plus the individual tools that were enabled via legacy names\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), ['oldToolSet', 'newToolRef', 'anotherNewToolRef'].sort(), 'should return toolset and individual tools');\n\t\t}\n\t});\n\n\ttest('toToolAndToolSetEnablementMap map Github to VSCode tools', () => {\n\t\tconst runCommandsToolData: IToolData = {\n\t\t\tid: VSCodeToolReference.shell,\n\t\t\ttoolReferenceName: VSCodeToolReference.shell,\n\t\t\tmodelDescription: 'runCommands',\n\t\t\tdisplayName: 'runCommands',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\n\t\tstore.add(service.registerToolData(runCommandsToolData));\n\t\tconst runSubagentToolData: IToolData = {\n\t\t\tid: VSCodeToolReference.runSubagent,\n\t\t\ttoolReferenceName: VSCodeToolReference.runSubagent,\n\t\t\tmodelDescription: 'runSubagent',\n\t\t\tdisplayName: 'runSubagent',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(runSubagentToolData));\n\n\t\tconst githubMcpDataSource: ToolDataSource = { type: 'mcp', label: 'Github', serverLabel: 'Github MCP Server', instructions: undefined, collectionId: 'githubMCPCollection', definitionId: 'githubMCPDefId' };\n\t\tconst githubMcpTool1: IToolData = {\n\t\t\tid: 'create_branch',\n\t\t\ttoolReferenceName: 'create_branch',\n\t\t\tmodelDescription: 'Test Github MCP Tool 1',\n\t\t\tdisplayName: 'Create Branch',\n\t\t\tsource: githubMcpDataSource,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(githubMcpTool1));\n\n\t\tconst githubMcpToolSet = store.add(service.createToolSet(\n\t\t\tgithubMcpDataSource,\n\t\t\t'githubMcpToolSet',\n\t\t\t'github/github-mcp-server',\n\t\t\t{ description: 'Github MCP Test ToolSet' }\n\t\t));\n\t\tstore.add(githubMcpToolSet.addTool(githubMcpTool1));\n\n\t\tconst playwrightMcpDataSource: ToolDataSource = { type: 'mcp', label: 'playwright', serverLabel: 'playwright MCP Server', instructions: undefined, collectionId: 'playwrightMCPCollection', definitionId: 'playwrightMCPDefId' };\n\t\tconst playwrightMcpTool1: IToolData = {\n\t\t\tid: 'browser_click',\n\t\t\ttoolReferenceName: 'browser_click',\n\t\t\tmodelDescription: 'Test playwright MCP Tool 1',\n\t\t\tdisplayName: 'Create Branch',\n\t\t\tsource: playwrightMcpDataSource,\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t};\n\t\tstore.add(service.registerToolData(playwrightMcpTool1));\n\n\t\tconst playwrightMcpToolSet = store.add(service.createToolSet(\n\t\t\tplaywrightMcpDataSource,\n\t\t\t'playwrightMcpToolSet',\n\t\t\t'microsoft/playwright-mcp',\n\t\t\t{ description: 'playwright MCP Test ToolSet' }\n\t\t));\n\t\tstore.add(playwrightMcpToolSet.addTool(playwrightMcpTool1));\n\t\t{\n\t\t\tconst toolNames = [GithubCopilotToolReference.customAgent, GithubCopilotToolReference.shell];\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(toolNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(runSubagentToolData), true, 'runSubagentToolData should be enabled');\n\t\t\tassert.strictEqual(result.get(runCommandsToolData), true, 'runCommandsToolData should be enabled');\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result).sort();\n\t\t\tassert.deepStrictEqual(qualifiedNames, [VSCodeToolReference.runSubagent, VSCodeToolReference.shell].sort(), 'toQualifiedToolNames should return the VS Code tool names');\n\t\t}\n\t\t{\n\t\t\tconst toolNames = ['github/*', 'playwright/*'];\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(toolNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(githubMcpToolSet), true, 'githubMcpToolSet should be enabled');\n\t\t\tassert.strictEqual(result.get(playwrightMcpToolSet), true, 'playwrightMcpToolSet should be enabled');\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result).sort();\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['github/github-mcp-server/*', 'microsoft/playwright-mcp/*'], 'toQualifiedToolNames should return the VS Code tool names');\n\t\t}\n\n\t\t{\n\t\t\t// map the qualified tool names for github and playwright MCP tools\n\t\t\tconst toolNames = ['github/create_branch', 'playwright/browser_click'];\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(toolNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(githubMcpTool1), true, 'githubMcpTool1 should be enabled');\n\t\t\tassert.strictEqual(result.get(playwrightMcpTool1), true, 'playwrightMcpTool1 should be enabled');\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result).sort();\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['github/github-mcp-server/create_branch', 'microsoft/playwright-mcp/browser_click'], 'toQualifiedToolNames should return the VS Code tool names');\n\t\t}\n\n\t\t{\n\t\t\t// test that already qualified names are not altered\n\t\t\tconst toolNames = ['github/github-mcp-server/create_branch', 'microsoft/playwright-mcp/browser_click'];\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(toolNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(githubMcpTool1), true, 'githubMcpTool1 should be enabled');\n\t\t\tassert.strictEqual(result.get(playwrightMcpTool1), true, 'playwrightMcpTool1 should be enabled');\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result).sort();\n\t\t\tassert.deepStrictEqual(qualifiedNames, ['github/github-mcp-server/create_branch', 'microsoft/playwright-mcp/browser_click'], 'toQualifiedToolNames should return the VS Code tool names');\n\t\t}\n\n\t});\n\n\ttest('accessibility signal for tool confirmation', async () => {\n\t\t// Create a test configuration service with proper settings\n\t\tconst testConfigService = new TestConfigurationService();\n\t\ttestConfigService.setUserConfiguration('chat.tools.global.autoApprove', false);\n\t\ttestConfigService.setUserConfiguration('accessibility.signals.chatUserActionRequired', { sound: 'auto', announcement: 'auto' });\n\n\t\t// Create a test accessibility service that simulates screen reader being enabled\n\t\tconst testAccessibilityService = new class extends TestAccessibilityService {\n\t\t\toverride isScreenReaderOptimized(): boolean { return true; }\n\t\t}();\n\n\t\t// Create a test accessibility signal service that tracks calls\n\t\tconst testAccessibilitySignalService = new TestAccessibilitySignalService();\n\n\t\t// Create a new service instance with the test services\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(IAccessibilityService, testAccessibilityService);\n\t\tinstaService.stub(IAccessibilitySignalService, testAccessibilitySignalService as unknown as IAccessibilitySignalService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testAccessibilityTool',\n\t\t\tmodelDescription: 'Test Accessibility Tool',\n\t\t\tdisplayName: 'Test Accessibility Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst tool = registerToolForTest(testService, store, toolData.id, {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Accessibility Test', message: 'Testing accessibility signal' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'executed' }] }),\n\t\t}, toolData);\n\n\t\tconst sessionId = 'sessionId-accessibility';\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId, { requestId: 'requestId-accessibility', capture });\n\n\t\tconst dto = tool.makeDto({ param: 'value' }, { sessionId });\n\n\t\tconst promise = testService.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\n\t\tassert.ok(published, 'expected ChatToolInvocation to be published');\n\t\tassert.ok(published.confirmationMessages, 'should have confirmation messages');\n\n\t\t// The accessibility signal should have been played\n\t\tassert.strictEqual(testAccessibilitySignalService.signalPlayedCalls.length, 1, 'accessibility signal should have been played once');\n\t\tconst signalCall = testAccessibilitySignalService.signalPlayedCalls[0];\n\t\tassert.strictEqual(signalCall.signal, AccessibilitySignal.chatUserActionRequired, 'correct signal should be played');\n\t\tassert.ok(signalCall.options?.customAlertMessage.includes('Accessibility Test'), 'alert message should include tool title');\n\t\tassert.ok(signalCall.options?.customAlertMessage.includes('Chat confirmation required'), 'alert message should include confirmation text');\n\n\t\t// Complete the invocation\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst result = await promise;\n\t\tassert.strictEqual(result.content[0].value, 'executed');\n\t});\n\n\ttest('accessibility signal respects autoApprove configuration', async () => {\n\t\t// Create a test configuration service with auto-approve enabled\n\t\tconst testConfigService = new TestConfigurationService();\n\t\ttestConfigService.setUserConfiguration('chat.tools.global.autoApprove', true);\n\t\ttestConfigService.setUserConfiguration('accessibility.signals.chatUserActionRequired', { sound: 'auto', announcement: 'auto' });\n\n\t\t// Create a test accessibility service that simulates screen reader being enabled\n\t\tconst testAccessibilityService = new class extends TestAccessibilityService {\n\t\t\toverride isScreenReaderOptimized(): boolean { return true; }\n\t\t}();\n\n\t\t// Create a test accessibility signal service that tracks calls\n\t\tconst testAccessibilitySignalService = new TestAccessibilitySignalService();\n\n\t\t// Create a new service instance with the test services\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(IAccessibilityService, testAccessibilityService);\n\t\tinstaService.stub(IAccessibilitySignalService, testAccessibilitySignalService as unknown as IAccessibilitySignalService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testAutoApproveTool',\n\t\t\tmodelDescription: 'Test Auto Approve Tool',\n\t\t\tdisplayName: 'Test Auto Approve Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst tool = registerToolForTest(testService, store, toolData.id, {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Auto Approve Test', message: 'Testing auto approve' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'auto approved' }] }),\n\t\t}, toolData);\n\n\t\tconst sessionId = 'sessionId-auto-approve';\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId, { requestId: 'requestId-auto-approve', capture });\n\n\t\tconst dto = tool.makeDto({ config: 'test' }, { sessionId });\n\n\t\t// When auto-approve is enabled, tool should complete without user intervention\n\t\tconst result = await testService.invokeTool(dto, async () => 0, CancellationToken.None);\n\n\t\t// Verify the tool completed and no accessibility signal was played\n\t\tassert.strictEqual(result.content[0].value, 'auto approved');\n\t\tassert.strictEqual(testAccessibilitySignalService.signalPlayedCalls.length, 0, 'accessibility signal should not be played when auto-approve is enabled');\n\t});\n\n\ttest('shouldAutoConfirm with basic configuration', async () => {\n\t\t// Test basic shouldAutoConfirm behavior with simple configuration\n\t\tconst testConfigService = new TestConfigurationService();\n\t\ttestConfigService.setUserConfiguration('chat.tools.global.autoApprove', true); // Global enabled\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\t// Register a tool that should be auto-approved\n\t\tconst autoTool = registerToolForTest(testService, store, 'autoTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Test', message: 'Should auto-approve' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'auto approved' }] })\n\t\t});\n\n\t\tconst sessionId = 'test-basic-config';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\t// Tool should be auto-approved (global config = true)\n\t\tconst result = await testService.invokeTool(\n\t\t\tautoTool.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(result.content[0].value, 'auto approved');\n\t});\n\n\ttest('shouldAutoConfirm with per-tool configuration object', async () => {\n\t\t// Test per-tool configuration: { toolId: true/false }\n\t\tconst testConfigService = new TestConfigurationService();\n\t\ttestConfigService.setUserConfiguration('chat.tools.global.autoApprove', {\n\t\t\t'approvedTool': true,\n\t\t\t'deniedTool': false\n\t\t});\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\t// Tool explicitly approved\n\t\tconst approvedTool = registerToolForTest(testService, store, 'approvedTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Test', message: 'Should auto-approve' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'approved' }] })\n\t\t});\n\n\t\tconst sessionId = 'test-per-tool';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\t// Approved tool should auto-approve\n\t\tconst approvedResult = await testService.invokeTool(\n\t\t\tapprovedTool.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(approvedResult.content[0].value, 'approved');\n\n\t\t// Test that non-specified tools require confirmation (default behavior)\n\t\tconst unspecifiedTool = registerToolForTest(testService, store, 'unspecifiedTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Test', message: 'Should require confirmation' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'unspecified' }] })\n\t\t});\n\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId + '2', { requestId: 'req2', capture });\n\t\tconst unspecifiedPromise = testService.invokeTool(\n\t\t\tunspecifiedTool.makeDto({ test: 2 }, { sessionId: sessionId + '2' }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tassert.ok(published?.confirmationMessages, 'unspecified tool should require confirmation');\n\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst unspecifiedResult = await unspecifiedPromise;\n\t\tassert.strictEqual(unspecifiedResult.content[0].value, 'unspecified');\n\t});\n\n\ttest('eligibleForAutoApproval setting controls tool eligibility', async () => {\n\t\t// Test the new eligibleForAutoApproval setting\n\t\tconst testConfigService = new TestConfigurationService();\n\t\ttestConfigService.setUserConfiguration('chat.tools.eligibleForAutoApproval', {\n\t\t\t'eligibleToolRef': true,\n\t\t\t'ineligibleToolRef': false\n\t\t});\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\t// Tool explicitly marked as eligible (using toolReferenceName) - no confirmation needed\n\t\tconst eligibleTool = registerToolForTest(testService, store, 'eligibleTool', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'eligible tool ran' }] })\n\t\t}, {\n\t\t\ttoolReferenceName: 'eligibleToolRef'\n\t\t});\n\n\t\tconst sessionId = 'test-eligible';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\t// Eligible tool should not get default confirmation messages injected\n\t\tconst eligibleResult = await testService.invokeTool(\n\t\t\teligibleTool.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(eligibleResult.content[0].value, 'eligible tool ran');\n\n\t\t// Tool explicitly marked as ineligible (using toolReferenceName) - must require confirmation\n\t\tconst ineligibleTool = registerToolForTest(testService, store, 'ineligibleTool', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'ineligible requires confirmation' }] })\n\t\t}, {\n\t\t\ttoolReferenceName: 'ineligibleToolRef'\n\t\t});\n\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId + '2', { requestId: 'req2', capture });\n\t\tconst ineligiblePromise = testService.invokeTool(\n\t\t\tineligibleTool.makeDto({ test: 2 }, { sessionId: sessionId + '2' }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tassert.ok(published?.confirmationMessages, 'ineligible tool should require confirmation');\n\t\tassert.ok(published?.confirmationMessages?.title, 'should have default confirmation title');\n\t\tassert.strictEqual(published?.confirmationMessages?.allowAutoConfirm, false, 'should not allow auto confirm');\n\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst ineligibleResult = await ineligiblePromise;\n\t\tassert.strictEqual(ineligibleResult.content[0].value, 'ineligible requires confirmation');\n\n\t\t// Tool not specified should default to eligible - no confirmation needed\n\t\tconst unspecifiedTool = registerToolForTest(testService, store, 'unspecifiedTool', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'unspecified defaults to eligible' }] })\n\t\t}, {\n\t\t\ttoolReferenceName: 'unspecifiedToolRef'\n\t\t});\n\n\t\tconst unspecifiedResult = await testService.invokeTool(\n\t\t\tunspecifiedTool.makeDto({ test: 3 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(unspecifiedResult.content[0].value, 'unspecified defaults to eligible');\n\t});\n\n\ttest('tool content formatting with alwaysDisplayInputOutput', async () => {\n\t\t// Test ensureToolDetails, formatToolInput, and toolResultToIO\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'formatTool',\n\t\t\tmodelDescription: 'Format Test Tool',\n\t\t\tdisplayName: 'Format Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\talwaysDisplayInputOutput: true\n\t\t};\n\n\t\tconst tool = registerToolForTest(service, store, toolData.id, {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async (invocation) => ({\n\t\t\t\tcontent: [\n\t\t\t\t\t{ kind: 'text', value: 'Text result' },\n\t\t\t\t\t{ kind: 'data', value: { data: VSBuffer.fromByteArray([1, 2, 3]), mimeType: 'application/octet-stream' } }\n\t\t\t\t]\n\t\t\t})\n\t\t}, toolData);\n\n\t\tconst input = { a: 1, b: 'test', c: [1, 2, 3] };\n\t\tconst result = await service.invokeTool(\n\t\t\ttool.makeDto(input),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Should have tool result details because alwaysDisplayInputOutput = true\n\t\tassert.ok(result.toolResultDetails, 'should have toolResultDetails');\n\t\tconst details = result.toolResultDetails;\n\t\tassert.ok(isToolResultInputOutputDetails(details));\n\n\t\t// Test formatToolInput - should be formatted JSON\n\t\tconst expectedInputJson = JSON.stringify(input, undefined, 2);\n\t\tassert.strictEqual(details.input, expectedInputJson, 'input should be formatted JSON');\n\n\t\t// Test toolResultToIO - should convert different content types\n\t\tassert.strictEqual(details.output.length, 2, 'should have 2 output items');\n\n\t\t// Text content\n\t\tconst textOutput = details.output[0];\n\t\tassert.strictEqual(textOutput.type, 'embed');\n\t\tassert.strictEqual(textOutput.isText, true);\n\t\tassert.strictEqual(textOutput.value, 'Text result');\n\n\t\t// Data content (base64 encoded)\n\t\tconst dataOutput = details.output[1];\n\t\tassert.strictEqual(dataOutput.type, 'embed');\n\t\tassert.strictEqual(dataOutput.mimeType, 'application/octet-stream');\n\t\tassert.strictEqual(dataOutput.value, 'AQID'); // base64 of [1,2,3]\n\t});\n\n\ttest('tool error handling and telemetry', async () => {\n\t\tconst testTelemetryService = new TestTelemetryService();\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(configurationService)),\n\t\t\tconfigurationService: () => configurationService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ITelemetryService, testTelemetryService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\t// Test successful invocation telemetry\n\t\tconst successTool = registerToolForTest(testService, store, 'successTool', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'success' }] })\n\t\t});\n\n\t\tconst sessionId = 'telemetry-test';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\tawait testService.invokeTool(\n\t\t\tsuccessTool.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Check success telemetry\n\t\tconst successEvents = testTelemetryService.events.filter(e => e.eventName === 'languageModelToolInvoked');\n\t\tassert.strictEqual(successEvents.length, 1, 'should have success telemetry event');\n\t\tassert.strictEqual(successEvents[0].data.result, 'success');\n\t\tassert.strictEqual(successEvents[0].data.toolId, 'successTool');\n\t\tassert.strictEqual(successEvents[0].data.chatSessionId, sessionId);\n\n\t\ttestTelemetryService.reset();\n\n\t\t// Test error telemetry\n\t\tconst errorTool = registerToolForTest(testService, store, 'errorTool', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => { throw new Error('Tool error'); }\n\t\t});\n\n\t\tstubGetSession(chatService, sessionId + '2', { requestId: 'req2' });\n\n\t\ttry {\n\t\t\tawait testService.invokeTool(\n\t\t\t\terrorTool.makeDto({ test: 2 }, { sessionId: sessionId + '2' }),\n\t\t\t\tasync () => 0,\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\t\t\tassert.fail('Should have thrown');\n\t\t} catch (err) {\n\t\t\t// Expected\n\t\t}\n\n\t\t// Check error telemetry\n\t\tconst errorEvents = testTelemetryService.events.filter(e => e.eventName === 'languageModelToolInvoked');\n\t\tassert.strictEqual(errorEvents.length, 1, 'should have error telemetry event');\n\t\tassert.strictEqual(errorEvents[0].data.result, 'error');\n\t\tassert.strictEqual(errorEvents[0].data.toolId, 'errorTool');\n\t});\n\n\ttest('call tracking and cleanup', async () => {\n\t\t// Test that cancelToolCallsForRequest method exists and can be called\n\t\t// (The detailed cancellation behavior is already tested in \"cancel tool call\" test)\n\t\tconst sessionId = 'tracking-session';\n\t\tconst requestId = 'tracking-request';\n\t\tstubGetSession(chatService, sessionId, { requestId });\n\n\t\t// Just verify the method exists and doesn't throw\n\t\tassert.doesNotThrow(() => {\n\t\t\tservice.cancelToolCallsForRequest(requestId);\n\t\t}, 'cancelToolCallsForRequest should not throw');\n\n\t\t// Verify calling with non-existent request ID doesn't throw\n\t\tassert.doesNotThrow(() => {\n\t\t\tservice.cancelToolCallsForRequest('non-existent-request');\n\t\t}, 'cancelToolCallsForRequest with non-existent ID should not throw');\n\t});\n\n\ttest('accessibility signal with different settings combinations', async () => {\n\t\tconst testAccessibilitySignalService = new TestAccessibilitySignalService();\n\n\t\t// Test case 1: Sound enabled, announcement disabled, screen reader off\n\t\tconst testConfigService1 = new TestConfigurationService();\n\t\ttestConfigService1.setUserConfiguration('chat.tools.global.autoApprove', false);\n\t\ttestConfigService1.setUserConfiguration('accessibility.signals.chatUserActionRequired', { sound: 'on', announcement: 'off' });\n\n\t\tconst testAccessibilityService1 = new class extends TestAccessibilityService {\n\t\t\toverride isScreenReaderOptimized(): boolean { return false; }\n\t\t}();\n\n\t\tconst instaService1 = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService1)),\n\t\t\tconfigurationService: () => testConfigService1\n\t\t}, store);\n\t\tinstaService1.stub(IChatService, chatService);\n\t\tinstaService1.stub(IAccessibilityService, testAccessibilityService1);\n\t\tinstaService1.stub(IAccessibilitySignalService, testAccessibilitySignalService as unknown as IAccessibilitySignalService);\n\t\tinstaService1.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService1 = store.add(instaService1.createInstance(LanguageModelToolsService));\n\n\t\tconst tool1 = registerToolForTest(testService1, store, 'soundOnlyTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Sound Test', message: 'Testing sound only' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'executed' }] })\n\t\t});\n\n\t\tconst sessionId1 = 'sound-test';\n\t\tconst capture1: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId1, { requestId: 'req1', capture: capture1 });\n\n\t\tconst promise1 = testService1.invokeTool(tool1.makeDto({ test: 1 }, { sessionId: sessionId1 }), async () => 0, CancellationToken.None);\n\t\tconst published1 = await waitForPublishedInvocation(capture1);\n\n\t\t// Signal should be played (sound=on, no screen reader requirement)\n\t\tassert.strictEqual(testAccessibilitySignalService.signalPlayedCalls.length, 1, 'sound should be played when sound=on');\n\t\tconst call1 = testAccessibilitySignalService.signalPlayedCalls[0];\n\t\tassert.strictEqual(call1.options?.modality, undefined, 'should use default modality for sound');\n\n\t\tIChatToolInvocation.confirmWith(published1, { type: ToolConfirmKind.UserAction });\n\t\tawait promise1;\n\n\t\ttestAccessibilitySignalService.reset();\n\n\t\t// Test case 2: Sound auto, announcement auto, screen reader on\n\t\tconst testConfigService2 = new TestConfigurationService();\n\t\ttestConfigService2.setUserConfiguration('chat.tools.global.autoApprove', false);\n\t\ttestConfigService2.setUserConfiguration('accessibility.signals.chatUserActionRequired', { sound: 'auto', announcement: 'auto' });\n\n\t\tconst testAccessibilityService2 = new class extends TestAccessibilityService {\n\t\t\toverride isScreenReaderOptimized(): boolean { return true; }\n\t\t}();\n\n\t\tconst instaService2 = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService2)),\n\t\t\tconfigurationService: () => testConfigService2\n\t\t}, store);\n\t\tinstaService2.stub(IChatService, chatService);\n\t\tinstaService2.stub(IAccessibilityService, testAccessibilityService2);\n\t\tinstaService2.stub(IAccessibilitySignalService, testAccessibilitySignalService as unknown as IAccessibilitySignalService);\n\t\tinstaService2.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService2 = store.add(instaService2.createInstance(LanguageModelToolsService));\n\n\t\tconst tool2 = registerToolForTest(testService2, store, 'autoScreenReaderTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Auto Test', message: 'Testing auto with screen reader' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'executed' }] })\n\t\t});\n\n\t\tconst sessionId2 = 'auto-sr-test';\n\t\tconst capture2: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId2, { requestId: 'req2', capture: capture2 });\n\n\t\tconst promise2 = testService2.invokeTool(tool2.makeDto({ test: 2 }, { sessionId: sessionId2 }), async () => 0, CancellationToken.None);\n\t\tconst published2 = await waitForPublishedInvocation(capture2);\n\n\t\t// Signal should be played (both sound and announcement enabled for screen reader)\n\t\tassert.strictEqual(testAccessibilitySignalService.signalPlayedCalls.length, 1, 'signal should be played with screen reader optimization');\n\t\tconst call2 = testAccessibilitySignalService.signalPlayedCalls[0];\n\t\tassert.ok(call2.options?.customAlertMessage, 'should have custom alert message');\n\t\tassert.strictEqual(call2.options?.userGesture, true, 'should mark as user gesture');\n\n\t\tIChatToolInvocation.confirmWith(published2, { type: ToolConfirmKind.UserAction });\n\t\tawait promise2;\n\n\t\ttestAccessibilitySignalService.reset();\n\n\t\t// Test case 3: Sound off, announcement off - no signal\n\t\tconst testConfigService3 = new TestConfigurationService();\n\t\ttestConfigService3.setUserConfiguration('chat.tools.global.autoApprove', false);\n\t\ttestConfigService3.setUserConfiguration('accessibility.signals.chatUserActionRequired', { sound: 'off', announcement: 'off' });\n\n\t\tconst testAccessibilityService3 = new class extends TestAccessibilityService {\n\t\t\toverride isScreenReaderOptimized(): boolean { return true; }\n\t\t}();\n\n\t\tconst instaService3 = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService3)),\n\t\t\tconfigurationService: () => testConfigService3\n\t\t}, store);\n\t\tinstaService3.stub(IChatService, chatService);\n\t\tinstaService3.stub(IAccessibilityService, testAccessibilityService3);\n\t\tinstaService3.stub(IAccessibilitySignalService, testAccessibilitySignalService as unknown as IAccessibilitySignalService);\n\t\tinstaService3.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService3 = store.add(instaService3.createInstance(LanguageModelToolsService));\n\n\t\tconst tool3 = registerToolForTest(testService3, store, 'offTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Off Test', message: 'Testing off settings' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'executed' }] })\n\t\t});\n\n\t\tconst sessionId3 = 'off-test';\n\t\tconst capture3: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId3, { requestId: 'req3', capture: capture3 });\n\n\t\tconst promise3 = testService3.invokeTool(tool3.makeDto({ test: 3 }, { sessionId: sessionId3 }), async () => 0, CancellationToken.None);\n\t\tconst published3 = await waitForPublishedInvocation(capture3);\n\n\t\t// No signal should be played\n\t\tassert.strictEqual(testAccessibilitySignalService.signalPlayedCalls.length, 0, 'no signal should be played when both sound and announcement are off');\n\n\t\tIChatToolInvocation.confirmWith(published3, { type: ToolConfirmKind.UserAction });\n\t\tawait promise3;\n\t});\n\n\ttest('createToolSet and getToolSet', () => {\n\t\tconst toolSet = store.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'testToolSetId',\n\t\t\t'testToolSetName',\n\t\t\t{ icon: undefined, description: 'Test tool set' }\n\t\t));\n\n\t\t// Should be able to retrieve by ID\n\t\tconst retrieved = service.getToolSet('testToolSetId');\n\t\tassert.ok(retrieved);\n\t\tassert.strictEqual(retrieved.id, 'testToolSetId');\n\t\tassert.strictEqual(retrieved.referenceName, 'testToolSetName');\n\n\t\t// Should not find non-existent tool set\n\t\tassert.strictEqual(service.getToolSet('nonExistentId'), undefined);\n\n\t\t// Dispose should remove it\n\t\ttoolSet.dispose();\n\t\tassert.strictEqual(service.getToolSet('testToolSetId'), undefined);\n\t});\n\n\ttest('getToolSetByName', () => {\n\t\tstore.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'toolSet1',\n\t\t\t'refName1'\n\t\t));\n\n\t\tstore.add(service.createToolSet(\n\t\t\tToolDataSource.Internal,\n\t\t\t'toolSet2',\n\t\t\t'refName2'\n\t\t));\n\n\t\t// Should find by reference name\n\t\tassert.strictEqual(service.getToolSetByName('refName1')?.id, 'toolSet1');\n\t\tassert.strictEqual(service.getToolSetByName('refName2')?.id, 'toolSet2');\n\n\t\t// Should not find non-existent name\n\t\tassert.strictEqual(service.getToolSetByName('nonExistentName'), undefined);\n\t});\n\n\ttest('getTools with includeDisabled parameter', () => {\n\t\t// Test the includeDisabled parameter behavior with context keys\n\t\tcontextKeyService.createKey('testKey', false);\n\t\tconst disabledTool: IToolData = {\n\t\t\tid: 'disabledTool',\n\t\t\tmodelDescription: 'Disabled Tool',\n\t\t\tdisplayName: 'Disabled Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\twhen: ContextKeyEqualsExpr.create('testKey', true), // Will be disabled since testKey is false\n\t\t};\n\n\t\tconst enabledTool: IToolData = {\n\t\t\tid: 'enabledTool',\n\t\t\tmodelDescription: 'Enabled Tool',\n\t\t\tdisplayName: 'Enabled Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(disabledTool));\n\t\tstore.add(service.registerToolData(enabledTool));\n\n\t\tconst enabledTools = Array.from(service.getTools());\n\t\tassert.strictEqual(enabledTools.length, 1, 'Should only return enabled tools');\n\t\tassert.strictEqual(enabledTools[0].id, 'enabledTool');\n\n\t\tconst allTools = Array.from(service.getTools(true));\n\t\tassert.strictEqual(allTools.length, 2, 'includeDisabled should return all tools');\n\t});\n\n\ttest('tool registration duplicate error', () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'duplicateTool',\n\t\t\tmodelDescription: 'Duplicate Tool',\n\t\t\tdisplayName: 'Duplicate Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\t// First registration should succeed\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\t// Second registration should throw\n\t\tassert.throws(() => {\n\t\t\tservice.registerToolData(toolData);\n\t\t}, /Tool \"duplicateTool\" is already registered/);\n\t});\n\n\ttest('tool implementation registration without data throws', () => {\n\t\tconst toolImpl: IToolImpl = {\n\t\t\tinvoke: async () => ({ content: [] }),\n\t\t};\n\n\t\t// Should throw when registering implementation for non-existent tool\n\t\tassert.throws(() => {\n\t\t\tservice.registerToolImplementation('nonExistentTool', toolImpl);\n\t\t}, /Tool \"nonExistentTool\" was not contributed/);\n\t});\n\n\ttest('tool implementation duplicate registration throws', () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'testTool',\n\t\t\tmodelDescription: 'Test Tool',\n\t\t\tdisplayName: 'Test Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tconst toolImpl1: IToolImpl = {\n\t\t\tinvoke: async () => ({ content: [] }),\n\t\t};\n\n\t\tconst toolImpl2: IToolImpl = {\n\t\t\tinvoke: async () => ({ content: [] }),\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\t\tstore.add(service.registerToolImplementation('testTool', toolImpl1));\n\n\t\t// Second implementation should throw\n\t\tassert.throws(() => {\n\t\t\tservice.registerToolImplementation('testTool', toolImpl2);\n\t\t}, /Tool \"testTool\" already has an implementation/);\n\t});\n\n\ttest('invokeTool with unknown tool throws', async () => {\n\t\tconst dto: IToolInvocation = {\n\t\t\tcallId: '1',\n\t\t\ttoolId: 'unknownTool',\n\t\t\ttokenBudget: 100,\n\t\t\tparameters: {},\n\t\t\tcontext: undefined,\n\t\t};\n\n\t\tawait assert.rejects(\n\t\t\tservice.invokeTool(dto, async () => 0, CancellationToken.None),\n\t\t\t/Tool unknownTool was not contributed/\n\t\t);\n\t});\n\n\ttest('invokeTool without implementation activates extension and throws if still not found', async () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'extensionActivationTool',\n\t\t\tmodelDescription: 'Extension Tool',\n\t\t\tdisplayName: 'Extension Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\tconst dto: IToolInvocation = {\n\t\t\tcallId: '1',\n\t\t\ttoolId: 'extensionActivationTool',\n\t\t\ttokenBudget: 100,\n\t\t\tparameters: {},\n\t\t\tcontext: undefined,\n\t\t};\n\n\t\t// Should throw after attempting extension activation\n\t\tawait assert.rejects(\n\t\t\tservice.invokeTool(dto, async () => 0, CancellationToken.None),\n\t\t\t/Tool extensionActivationTool does not have an implementation registered/\n\t\t);\n\t});\n\n\ttest('invokeTool without context (non-chat scenario)', async () => {\n\t\tconst tool = registerToolForTest(service, store, 'nonChatTool', {\n\t\t\tinvoke: async (invocation) => {\n\t\t\t\tassert.strictEqual(invocation.context, undefined);\n\t\t\t\treturn { content: [{ kind: 'text', value: 'non-chat result' }] };\n\t\t\t}\n\t\t});\n\n\t\tconst dto = tool.makeDto({ test: 1 }); // No context\n\n\t\tconst result = await service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\tassert.strictEqual(result.content[0].value, 'non-chat result');\n\t});\n\n\ttest('invokeTool with unknown chat session throws', async () => {\n\t\tconst tool = registerToolForTest(service, store, 'unknownSessionTool', {\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'should not reach' }] })\n\t\t});\n\n\t\tconst dto = tool.makeDto({ test: 1 }, { sessionId: 'unknownSession' });\n\n\t\t// Test that it throws, regardless of exact error message\n\t\tlet threwError = false;\n\t\ttry {\n\t\t\tawait service.invokeTool(dto, async () => 0, CancellationToken.None);\n\t\t} catch (err) {\n\t\t\tthrewError = true;\n\t\t\t// Verify it's one of the expected error types\n\t\t\tassert.ok(\n\t\t\t\terr instanceof Error && (\n\t\t\t\t\terr.message.includes('Tool called for unknown chat session') ||\n\t\t\t\t\terr.message.includes('getRequests is not a function')\n\t\t\t\t),\n\t\t\t\t`Unexpected error: ${err.message}`\n\t\t\t);\n\t\t}\n\t\tassert.strictEqual(threwError, true, 'Should have thrown an error');\n\t});\n\n\ttest('tool error with alwaysDisplayInputOutput includes details', async () => {\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'errorToolWithIO',\n\t\t\tmodelDescription: 'Error Tool With IO',\n\t\t\tdisplayName: 'Error Tool With IO',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\talwaysDisplayInputOutput: true\n\t\t};\n\n\t\tconst tool = registerToolForTest(service, store, toolData.id, {\n\t\t\tinvoke: async () => { throw new Error('Tool execution failed'); }\n\t\t}, toolData);\n\n\t\tconst input = { param: 'testValue' };\n\n\t\ttry {\n\t\t\tawait service.invokeTool(\n\t\t\t\ttool.makeDto(input),\n\t\t\t\tasync () => 0,\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\t\t\tassert.fail('Should have thrown');\n\t\t} catch (err: any) {\n\t\t\t// The error should bubble up, but we need to check if toolResultError is set\n\t\t\t// This tests the internal error handling path\n\t\t\tassert.strictEqual(err.message, 'Tool execution failed');\n\t\t}\n\t});\n\n\ttest('context key changes trigger tool updates', async () => {\n\t\tlet changeEventFired = false;\n\t\tconst disposable = service.onDidChangeTools(() => {\n\t\t\tchangeEventFired = true;\n\t\t});\n\t\tstore.add(disposable);\n\n\t\t// Create a tool with a context key dependency\n\t\tcontextKeyService.createKey('dynamicKey', false);\n\t\tconst toolData: IToolData = {\n\t\t\tid: 'contextTool',\n\t\t\tmodelDescription: 'Context Tool',\n\t\t\tdisplayName: 'Context Tool',\n\t\t\tsource: ToolDataSource.Internal,\n\t\t\twhen: ContextKeyEqualsExpr.create('dynamicKey', true),\n\t\t};\n\n\t\tstore.add(service.registerToolData(toolData));\n\n\t\t// Change the context key value\n\t\tcontextKeyService.createKey('dynamicKey', true);\n\n\t\t// Wait a bit for the scheduler\n\t\tawait new Promise(resolve => setTimeout(resolve, 800));\n\n\t\tassert.strictEqual(changeEventFired, true, 'onDidChangeTools should fire when context keys change');\n\t});\n\n\ttest('configuration changes trigger tool updates', async () => {\n\t\treturn runWithFakedTimers({}, async () => {\n\t\t\tlet changeEventFired = false;\n\t\t\tconst disposable = service.onDidChangeTools(() => {\n\t\t\t\tchangeEventFired = true;\n\t\t\t});\n\t\t\tstore.add(disposable);\n\n\t\t\t// Change the correct configuration key\n\t\t\tconfigurationService.setUserConfiguration('chat.extensionTools.enabled', false);\n\t\t\t// Fire the configuration change event manually\n\t\t\tconfigurationService.onDidChangeConfigurationEmitter.fire({\n\t\t\t\taffectsConfiguration: () => true,\n\t\t\t\taffectedKeys: new Set(['chat.extensionTools.enabled']),\n\t\t\t\tchange: null!,\n\t\t\t\tsource: ConfigurationTarget.USER\n\t\t\t} satisfies IConfigurationChangeEvent);\n\n\t\t\t// Wait a bit for the scheduler\n\t\t\tawait new Promise(resolve => setTimeout(resolve, 800));\n\n\t\t\tassert.strictEqual(changeEventFired, true, 'onDidChangeTools should fire when configuration changes');\n\t\t});\n\t});\n\n\ttest('toToolAndToolSetEnablementMap with MCP toolset enables contained tools', () => {\n\t\t// Create MCP toolset\n\t\tconst mcpToolSet = store.add(service.createToolSet(\n\t\t\t{ type: 'mcp', label: 'testServer', serverLabel: 'testServer', instructions: undefined, collectionId: 'testCollection', definitionId: 'testDef' },\n\t\t\t'mcpSet',\n\t\t\t'mcpSetRef'\n\t\t));\n\n\t\tconst mcpTool: IToolData = {\n\t\t\tid: 'mcpTool',\n\t\t\tmodelDescription: 'MCP Tool',\n\t\t\tdisplayName: 'MCP Tool',\n\t\t\tsource: { type: 'mcp', label: 'testServer', serverLabel: 'testServer', instructions: undefined, collectionId: 'testCollection', definitionId: 'testDef' },\n\t\t\tcanBeReferencedInPrompt: true,\n\t\t\ttoolReferenceName: 'mcpToolRef'\n\t\t};\n\n\t\tstore.add(service.registerToolData(mcpTool));\n\t\tstore.add(mcpToolSet.addTool(mcpTool));\n\n\t\t// Enable the MCP toolset\n\t\t{\n\t\t\tconst enabledNames = [mcpToolSet].map(t => service.getQualifiedToolName(t));\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(enabledNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(mcpToolSet), true, 'MCP toolset should be enabled'); // Ensure the toolset is in the map\n\t\t\tassert.strictEqual(result.get(mcpTool), true, 'MCP tool should be enabled when its toolset is enabled'); // Ensure the tool is in the map\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), enabledNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\t\t// Enable a tool from the MCP toolset\n\t\t{\n\t\t\tconst enabledNames = [mcpTool].map(t => service.getQualifiedToolName(t, mcpToolSet));\n\t\t\tconst result = service.toToolAndToolSetEnablementMap(enabledNames, undefined);\n\n\t\t\tassert.strictEqual(result.get(mcpToolSet), false, 'MCP toolset should be disabled'); // Ensure the toolset is in the map\n\t\t\tassert.strictEqual(result.get(mcpTool), true, 'MCP tool should be enabled'); // Ensure the tool is in the map\n\n\t\t\tconst qualifiedNames = service.toQualifiedToolNames(result);\n\t\t\tassert.deepStrictEqual(qualifiedNames.sort(), enabledNames.sort(), 'toQualifiedToolNames should return the original enabled names');\n\t\t}\n\n\t});\n\n\ttest('shouldAutoConfirm with workspace-specific tool configuration', async () => {\n\t\tconst testConfigService = new TestConfigurationService();\n\t\t// Configure per-tool settings at different scopes\n\t\ttestConfigService.setUserConfiguration('chat.tools.global.autoApprove', { 'workspaceTool': true });\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\tconst workspaceTool = registerToolForTest(testService, store, 'workspaceTool', {\n\t\t\tprepareToolInvocation: async () => ({ confirmationMessages: { title: 'Test', message: 'Workspace tool' } }),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'workspace result' }] })\n\t\t}, { runsInWorkspace: true });\n\n\t\tconst sessionId = 'workspace-test';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\t// Should auto-approve based on user configuration\n\t\tconst result = await testService.invokeTool(\n\t\t\tworkspaceTool.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(result.content[0].value, 'workspace result');\n\t});\n\n\ttest('getQualifiedToolNames', () => {\n\t\tsetupToolsForTest(service, store);\n\n\t\tconst qualifiedNames = Array.from(service.getQualifiedToolNames()).sort();\n\n\t\tconst expectedNames = [\n\t\t\t'tool1RefName',\n\t\t\t'Tool2 Display Name',\n\t\t\t'my.extension/extTool1RefName',\n\t\t\t'mcpToolSetRefName/*',\n\t\t\t'mcpToolSetRefName/mcpTool1RefName',\n\t\t\t'internalToolSetRefName',\n\t\t\t'internalToolSetRefName/internalToolSetTool1RefName',\n\t\t\t'vscode',\n\t\t\t'launch'\n\t\t].sort();\n\n\t\tassert.deepStrictEqual(qualifiedNames, expectedNames, 'getQualifiedToolNames should return correct qualified names');\n\t});\n\n\ttest('getDeprecatedQualifiedToolNames', () => {\n\t\tsetupToolsForTest(service, store);\n\n\t\tconst deprecatedNames = service.getDeprecatedQualifiedToolNames();\n\n\t\t// Tools in internal tool sets should have their qualified names with toolset prefix, tools sets keep their name\n\t\tassert.deepStrictEqual(deprecatedNames.get('internalToolSetTool1RefName'), new Set(['internalToolSetRefName/internalToolSetTool1RefName']));\n\t\tassert.strictEqual(deprecatedNames.get('internalToolSetRefName'), undefined);\n\n\t\t// For extension tools, the qualified name includes the extension ID\n\t\tassert.deepStrictEqual(deprecatedNames.get('extTool1RefName'), new Set(['my.extension/extTool1RefName']));\n\n\t\t// For MCP tool sets, the qualified name includes the /* suffix\n\t\tassert.deepStrictEqual(deprecatedNames.get('mcpToolSetRefName'), new Set(['mcpToolSetRefName/*']));\n\t\tassert.deepStrictEqual(deprecatedNames.get('mcpTool1RefName'), new Set(['mcpToolSetRefName/mcpTool1RefName']));\n\n\t\t// Internal tool sets and user tools sets and tools without namespace changes should not appear\n\t\tassert.strictEqual(deprecatedNames.get('Tool2 Display Name'), undefined);\n\t\tassert.strictEqual(deprecatedNames.get('tool1RefName'), undefined);\n\t\tassert.strictEqual(deprecatedNames.get('userToolSetRefName'), undefined);\n\t});\n\n\ttest('getToolByQualifiedName', () => {\n\t\tsetupToolsForTest(service, store);\n\n\t\t// Test finding tools by their qualified names\n\t\tconst tool1 = service.getToolByQualifiedName('tool1RefName');\n\t\tassert.ok(tool1);\n\t\tassert.strictEqual(tool1.id, 'tool1');\n\n\t\tconst tool2 = service.getToolByQualifiedName('Tool2 Display Name');\n\t\tassert.ok(tool2);\n\t\tassert.strictEqual(tool2.id, 'tool2');\n\n\t\tconst extTool = service.getToolByQualifiedName('my.extension/extTool1RefName');\n\t\tassert.ok(extTool);\n\t\tassert.strictEqual(extTool.id, 'extTool1');\n\n\t\tconst mcpTool = service.getToolByQualifiedName('mcpToolSetRefName/mcpTool1RefName');\n\t\tassert.ok(mcpTool);\n\t\tassert.strictEqual(mcpTool.id, 'mcpTool1');\n\n\n\t\tconst mcpToolSet = service.getToolByQualifiedName('mcpToolSetRefName/*');\n\t\tassert.ok(mcpToolSet);\n\t\tassert.strictEqual(mcpToolSet.id, 'mcpToolSet');\n\n\t\tconst internalToolSet = service.getToolByQualifiedName('internalToolSetRefName/internalToolSetTool1RefName');\n\t\tassert.ok(internalToolSet);\n\t\tassert.strictEqual(internalToolSet.id, 'internalToolSetTool1');\n\n\t\t// Test finding tools within tool sets\n\t\tconst toolInSet = service.getToolByQualifiedName('internalToolSetRefName');\n\t\tassert.ok(toolInSet);\n\t\tassert.strictEqual(toolInSet!.id, 'internalToolSet');\n\n\t});\n\n\ttest('eligibleForAutoApproval setting can be configured via policy', async () => {\n\t\t// Test that policy configuration works for eligibleForAutoApproval\n\t\t// Policy values should be JSON strings for object-type settings\n\t\tconst testConfigService = new TestConfigurationService();\n\n\t\t// Simulate policy configuration (would come from policy file)\n\t\tconst policyValue = {\n\t\t\t'toolA': true,\n\t\t\t'toolB': false\n\t\t};\n\t\ttestConfigService.setUserConfiguration('chat.tools.eligibleForAutoApproval', policyValue);\n\n\t\tconst instaService = workbenchInstantiationService({\n\t\t\tcontextKeyService: () => store.add(new ContextKeyService(testConfigService)),\n\t\t\tconfigurationService: () => testConfigService\n\t\t}, store);\n\t\tinstaService.stub(IChatService, chatService);\n\t\tinstaService.stub(ILanguageModelToolsConfirmationService, new MockLanguageModelToolsConfirmationService());\n\t\tconst testService = store.add(instaService.createInstance(LanguageModelToolsService));\n\n\t\t// Tool A is eligible (true in policy)\n\t\tconst toolA = registerToolForTest(testService, store, 'toolA', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'toolA executed' }] })\n\t\t}, {\n\t\t\ttoolReferenceName: 'toolA'\n\t\t});\n\n\t\t// Tool B is ineligible (false in policy)\n\t\tconst toolB = registerToolForTest(testService, store, 'toolB', {\n\t\t\tprepareToolInvocation: async () => ({}),\n\t\t\tinvoke: async () => ({ content: [{ kind: 'text', value: 'toolB executed' }] })\n\t\t}, {\n\t\t\ttoolReferenceName: 'toolB'\n\t\t});\n\n\t\tconst sessionId = 'test-policy';\n\t\tstubGetSession(chatService, sessionId, { requestId: 'req1' });\n\n\t\t// Tool A should execute without confirmation (eligible)\n\t\tconst resultA = await testService.invokeTool(\n\t\t\ttoolA.makeDto({ test: 1 }, { sessionId }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(resultA.content[0].value, 'toolA executed');\n\n\t\t// Tool B should require confirmation (ineligible)\n\t\tconst capture: { invocation?: any } = {};\n\t\tstubGetSession(chatService, sessionId + '2', { requestId: 'req2', capture });\n\t\tconst promiseB = testService.invokeTool(\n\t\t\ttoolB.makeDto({ test: 2 }, { sessionId: sessionId + '2' }),\n\t\t\tasync () => 0,\n\t\t\tCancellationToken.None\n\t\t);\n\t\tconst published = await waitForPublishedInvocation(capture);\n\t\tassert.ok(published?.confirmationMessages, 'toolB should require confirmation due to policy');\n\t\tassert.strictEqual(published?.confirmationMessages?.allowAutoConfirm, false, 'should not allow auto confirm');\n\n\t\tIChatToolInvocation.confirmWith(published, { type: ToolConfirmKind.UserAction });\n\t\tconst resultB = await promiseB;\n\t\tassert.strictEqual(resultB.content[0].value, 'toolB executed');\n\t});\n\n\n\n});\n"]}