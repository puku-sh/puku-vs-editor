{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/test/common/promptSyntax/testUtils/mockFilesystem.ts","vs/workbench/contrib/chat/test/common/promptSyntax/testUtils/mockFilesystem.ts"],"names":[],"mappings":"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","file":"mockFilesystem.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../../../../base/common/uri.js';\nimport { VSBuffer } from '../../../../../../../base/common/buffer.js';\nimport { IFileService } from '../../../../../../../platform/files/common/files.js';\nimport { dirname } from '../../../../../../../base/common/resources.js';\n\n/**\n * Represents a generic file system node.\n */\ninterface IMockFilesystemNode {\n\tname: string;\n}\n\n/**\n * Represents a `file` node.\n */\nexport interface IMockFile extends IMockFilesystemNode {\n\tcontents: string | readonly string[];\n}\n\n/**\n * Represents a `folder` node.\n */\nexport interface IMockFolder extends IMockFilesystemNode {\n\tchildren: (IMockFolder | IMockFile)[];\n}\n\n\n/**\n * Represents a file entry for simplified initialization.\n */\nexport interface IMockFileEntry {\n\tpath: string;\n\tcontents: string[];\n}\n\n/**\n * Creates mock filesystem from provided file entries.\n * @param fileService File service instance\n * @param files Array of file entries with path and contents\n */\nexport function mockFiles(fileService: IFileService, files: IMockFileEntry[], parentFolder?: URI): Promise<void> {\n\treturn new MockFilesystem(files, fileService).mock(parentFolder);\n}\n\n/**\n * Utility to recursively creates provided filesystem structure.\n */\nexport class MockFilesystem {\n\n\tprivate createdFiles: URI[] = [];\n\tprivate createdFolders: URI[] = [];\n\tprivate createdRootFolders: URI[] = [];\n\n\tconstructor(\n\t\tprivate readonly input: IMockFolder[] | IMockFileEntry[],\n\t\t@IFileService private readonly fileService: IFileService,\n\t) { }\n\n\n\n\t/**\n\t * Starts the mock process.\n\t */\n\tpublic async mock(parentFolder?: URI): Promise<void> {\n\t\t// Check if input is the new simplified format\n\t\tif (this.input.length > 0 && 'path' in this.input[0]) {\n\t\t\treturn this.mockFromFileEntries(this.input as IMockFileEntry[]);\n\t\t}\n\n\t\t// Use the old format\n\t\treturn this.mockFromFolders(this.input as IMockFolder[], parentFolder);\n\t}\n\n\t/**\n\t * Mock using the new simplified file entry format.\n\t */\n\tprivate async mockFromFileEntries(fileEntries: IMockFileEntry[]): Promise<void> {\n\t\t// Create all files and their parent directories\n\t\tfor (const fileEntry of fileEntries) {\n\t\t\tconst fileUri = URI.file(fileEntry.path);\n\n\t\t\t// Ensure parent directories exist\n\t\t\tawait this.ensureParentDirectories(dirname(fileUri));\n\n\t\t\t// Create the file\n\t\t\tconst contents = fileEntry.contents.join('\\n');\n\t\t\tawait this.fileService.writeFile(fileUri, VSBuffer.fromString(contents));\n\n\t\t\tthis.createdFiles.push(fileUri);\n\t\t}\n\t}\n\n\t/**\n\t * Mock using the old nested folder format.\n\t */\n\tprivate async mockFromFolders(folders: IMockFolder[], parentFolder?: URI): Promise<void> {\n\t\tconst result = await Promise.all(folders.map((folder) => this.mockFolder(folder, parentFolder)));\n\t\tthis.createdRootFolders.push(...result);\n\t}\n\n\tpublic async delete(): Promise<void> {\n\t\t// Delete files created by the new format\n\t\tfor (const fileUri of this.createdFiles) {\n\t\t\tif (await this.fileService.exists(fileUri)) {\n\t\t\t\tawait this.fileService.del(fileUri, { useTrash: false });\n\t\t\t}\n\t\t}\n\n\t\tfor (const folderUri of this.createdFolders.reverse()) { // reverse to delete children first\n\t\t\tif (await this.fileService.exists(folderUri)) {\n\t\t\t\tawait this.fileService.del(folderUri, { recursive: true, useTrash: false });\n\t\t\t}\n\t\t}\n\n\t\t// Delete root folders created by the old format\n\t\tfor (const folder of this.createdRootFolders) {\n\t\t\tawait this.fileService.del(folder, { recursive: true, useTrash: false });\n\t\t}\n\t}\n\n\t/**\n\t * The internal implementation of the filesystem mocking process for the old format.\n\t */\n\tprivate async mockFolder(folder: IMockFolder, parentFolder?: URI): Promise<URI> {\n\t\tconst folderUri = parentFolder\n\t\t\t? URI.joinPath(parentFolder, folder.name)\n\t\t\t: URI.file(folder.name);\n\n\t\tif (!(await this.fileService.exists(folderUri))) {\n\t\t\ttry {\n\t\t\t\tawait this.fileService.createFolder(folderUri);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(`Failed to create folder '${folderUri.fsPath}': ${error}.`);\n\t\t\t}\n\t\t}\n\n\t\tconst resolvedChildren: URI[] = [];\n\t\tfor (const child of folder.children) {\n\t\t\tconst childUri = URI.joinPath(folderUri, child.name);\n\t\t\t// create child file\n\t\t\tif ('contents' in child) {\n\t\t\t\tconst contents: string = (typeof child.contents === 'string')\n\t\t\t\t\t? child.contents\n\t\t\t\t\t: child.contents.join('\\n');\n\n\t\t\t\tawait this.fileService.writeFile(childUri, VSBuffer.fromString(contents));\n\n\t\t\t\tresolvedChildren.push(childUri);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// recursively create child filesystem structure\n\t\t\tresolvedChildren.push(await this.mockFolder(child, folderUri));\n\t\t}\n\n\t\treturn folderUri;\n\t}\n\n\t/**\n\t * Ensures that all parent directories of the given file URI exist.\n\t */\n\tprivate async ensureParentDirectories(dirUri: URI): Promise<void> {\n\t\tif (!await this.fileService.exists(dirUri)) {\n\t\t\tif (dirUri.path === '/') {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.fileService.createFolder(dirUri);\n\t\t\t\t\tthis.createdFolders.push(dirUri);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new Error(`Failed to create directory '${dirUri.toString()}': ${error}.`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tawait this.ensureParentDirectories(dirname(dirUri));\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../../../../base/common/uri.js';\nimport { VSBuffer } from '../../../../../../../base/common/buffer.js';\nimport { IFileService } from '../../../../../../../platform/files/common/files.js';\nimport { dirname } from '../../../../../../../base/common/resources.js';\n\n/**\n * Represents a generic file system node.\n */\ninterface IMockFilesystemNode {\n\tname: string;\n}\n\n/**\n * Represents a `file` node.\n */\nexport interface IMockFile extends IMockFilesystemNode {\n\tcontents: string | readonly string[];\n}\n\n/**\n * Represents a `folder` node.\n */\nexport interface IMockFolder extends IMockFilesystemNode {\n\tchildren: (IMockFolder | IMockFile)[];\n}\n\n\n/**\n * Represents a file entry for simplified initialization.\n */\nexport interface IMockFileEntry {\n\tpath: string;\n\tcontents: string[];\n}\n\n/**\n * Creates mock filesystem from provided file entries.\n * @param fileService File service instance\n * @param files Array of file entries with path and contents\n */\nexport function mockFiles(fileService: IFileService, files: IMockFileEntry[], parentFolder?: URI): Promise<void> {\n\treturn new MockFilesystem(files, fileService).mock(parentFolder);\n}\n\n/**\n * Utility to recursively creates provided filesystem structure.\n */\nexport class MockFilesystem {\n\n\tprivate createdFiles: URI[] = [];\n\tprivate createdFolders: URI[] = [];\n\tprivate createdRootFolders: URI[] = [];\n\n\tconstructor(\n\t\tprivate readonly input: IMockFolder[] | IMockFileEntry[],\n\t\t@IFileService private readonly fileService: IFileService,\n\t) { }\n\n\n\n\t/**\n\t * Starts the mock process.\n\t */\n\tpublic async mock(parentFolder?: URI): Promise<void> {\n\t\t// Check if input is the new simplified format\n\t\tif (this.input.length > 0 && 'path' in this.input[0]) {\n\t\t\treturn this.mockFromFileEntries(this.input as IMockFileEntry[]);\n\t\t}\n\n\t\t// Use the old format\n\t\treturn this.mockFromFolders(this.input as IMockFolder[], parentFolder);\n\t}\n\n\t/**\n\t * Mock using the new simplified file entry format.\n\t */\n\tprivate async mockFromFileEntries(fileEntries: IMockFileEntry[]): Promise<void> {\n\t\t// Create all files and their parent directories\n\t\tfor (const fileEntry of fileEntries) {\n\t\t\tconst fileUri = URI.file(fileEntry.path);\n\n\t\t\t// Ensure parent directories exist\n\t\t\tawait this.ensureParentDirectories(dirname(fileUri));\n\n\t\t\t// Create the file\n\t\t\tconst contents = fileEntry.contents.join('\\n');\n\t\t\tawait this.fileService.writeFile(fileUri, VSBuffer.fromString(contents));\n\n\t\t\tthis.createdFiles.push(fileUri);\n\t\t}\n\t}\n\n\t/**\n\t * Mock using the old nested folder format.\n\t */\n\tprivate async mockFromFolders(folders: IMockFolder[], parentFolder?: URI): Promise<void> {\n\t\tconst result = await Promise.all(folders.map((folder) => this.mockFolder(folder, parentFolder)));\n\t\tthis.createdRootFolders.push(...result);\n\t}\n\n\tpublic async delete(): Promise<void> {\n\t\t// Delete files created by the new format\n\t\tfor (const fileUri of this.createdFiles) {\n\t\t\tif (await this.fileService.exists(fileUri)) {\n\t\t\t\tawait this.fileService.del(fileUri, { useTrash: false });\n\t\t\t}\n\t\t}\n\n\t\tfor (const folderUri of this.createdFolders.reverse()) { // reverse to delete children first\n\t\t\tif (await this.fileService.exists(folderUri)) {\n\t\t\t\tawait this.fileService.del(folderUri, { recursive: true, useTrash: false });\n\t\t\t}\n\t\t}\n\n\t\t// Delete root folders created by the old format\n\t\tfor (const folder of this.createdRootFolders) {\n\t\t\tawait this.fileService.del(folder, { recursive: true, useTrash: false });\n\t\t}\n\t}\n\n\t/**\n\t * The internal implementation of the filesystem mocking process for the old format.\n\t */\n\tprivate async mockFolder(folder: IMockFolder, parentFolder?: URI): Promise<URI> {\n\t\tconst folderUri = parentFolder\n\t\t\t? URI.joinPath(parentFolder, folder.name)\n\t\t\t: URI.file(folder.name);\n\n\t\tif (!(await this.fileService.exists(folderUri))) {\n\t\t\ttry {\n\t\t\t\tawait this.fileService.createFolder(folderUri);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(`Failed to create folder '${folderUri.fsPath}': ${error}.`);\n\t\t\t}\n\t\t}\n\n\t\tconst resolvedChildren: URI[] = [];\n\t\tfor (const child of folder.children) {\n\t\t\tconst childUri = URI.joinPath(folderUri, child.name);\n\t\t\t// create child file\n\t\t\tif ('contents' in child) {\n\t\t\t\tconst contents: string = (typeof child.contents === 'string')\n\t\t\t\t\t? child.contents\n\t\t\t\t\t: child.contents.join('\\n');\n\n\t\t\t\tawait this.fileService.writeFile(childUri, VSBuffer.fromString(contents));\n\n\t\t\t\tresolvedChildren.push(childUri);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// recursively create child filesystem structure\n\t\t\tresolvedChildren.push(await this.mockFolder(child, folderUri));\n\t\t}\n\n\t\treturn folderUri;\n\t}\n\n\t/**\n\t * Ensures that all parent directories of the given file URI exist.\n\t */\n\tprivate async ensureParentDirectories(dirUri: URI): Promise<void> {\n\t\tif (!await this.fileService.exists(dirUri)) {\n\t\t\tif (dirUri.path === '/') {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.fileService.createFolder(dirUri);\n\t\t\t\t\tthis.createdFolders.push(dirUri);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new Error(`Failed to create directory '${dirUri.toString()}': ${error}.`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tawait this.ensureParentDirectories(dirname(dirUri));\n\t\t\t}\n\t\t}\n\t}\n}\n"]}