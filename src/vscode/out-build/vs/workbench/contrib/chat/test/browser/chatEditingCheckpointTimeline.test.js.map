{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/test/browser/chatEditingCheckpointTimeline.test.ts","vs/workbench/contrib/chat/test/browser/chatEditingCheckpointTimeline.test.ts"],"names":[],"mappings":"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","file":"chatEditingCheckpointTimeline.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { DisposableStore } from '../../../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../../../base/common/map.js';\nimport { transaction } from '../../../../../base/common/observable.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { upcastPartial } from '../../../../../base/test/common/mock.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { SyncDescriptor } from '../../../../../platform/instantiation/common/descriptors.js';\nimport { ServiceCollection } from '../../../../../platform/instantiation/common/serviceCollection.js';\nimport { workbenchInstantiationService } from '../../../../test/browser/workbenchTestServices.js';\nimport { INotebookService } from '../../../notebook/common/notebookService.js';\nimport { ChatEditingCheckpointTimelineImpl, IChatEditingTimelineFsDelegate } from '../../browser/chatEditing/chatEditingCheckpointTimelineImpl.js';\nimport { FileOperation, FileOperationType } from '../../browser/chatEditing/chatEditingOperations.js';\nimport { IModifiedEntryTelemetryInfo } from '../../common/chatEditingService.js';\n\nsuite('ChatEditingCheckpointTimeline', function () {\n\n\tconst store = new DisposableStore();\n\tlet timeline: ChatEditingCheckpointTimelineImpl;\n\tlet fileContents: ResourceMap<string>;\n\tlet fileDelegate: IChatEditingTimelineFsDelegate;\n\n\tconst DEFAULT_TELEMETRY_INFO: IModifiedEntryTelemetryInfo = upcastPartial({\n\t\tagentId: 'testAgent',\n\t\tcommand: undefined,\n\t\tsessionResource: URI.parse('chat://test-session'),\n\t\trequestId: 'test-request',\n\t\tresult: undefined,\n\t\tmodelId: undefined,\n\t\tmodeId: undefined,\n\t\tapplyCodeBlockSuggestionId: undefined,\n\t\tfeature: undefined,\n\t});\n\n\tfunction createTextEditOperation(uri: URI, requestId: string, epoch: number, edits: { range: Range; text: string }[]): FileOperation {\n\t\treturn upcastPartial<FileOperation>({\n\t\t\ttype: FileOperationType.TextEdit,\n\t\t\turi,\n\t\t\trequestId,\n\t\t\tepoch,\n\t\t\tedits\n\t\t});\n\t}\n\n\tfunction createFileCreateOperation(uri: URI, requestId: string, epoch: number, initialContent: string): FileOperation {\n\t\treturn upcastPartial<FileOperation>({\n\t\t\ttype: FileOperationType.Create,\n\t\t\turi,\n\t\t\trequestId,\n\t\t\tepoch,\n\t\t\tinitialContent\n\t\t});\n\t}\n\n\tfunction createFileDeleteOperation(uri: URI, requestId: string, epoch: number, finalContent: string): FileOperation {\n\t\treturn upcastPartial<FileOperation>({\n\t\t\ttype: FileOperationType.Delete,\n\t\t\turi,\n\t\t\trequestId,\n\t\t\tepoch,\n\t\t\tfinalContent\n\t\t});\n\t}\n\n\tfunction createFileRenameOperation(oldUri: URI, newUri: URI, requestId: string, epoch: number): FileOperation {\n\t\treturn upcastPartial<FileOperation>({\n\t\t\ttype: FileOperationType.Rename,\n\t\t\turi: newUri,\n\t\t\trequestId,\n\t\t\tepoch,\n\t\t\toldUri,\n\t\t\tnewUri\n\t\t});\n\t}\n\n\tsetup(function () {\n\t\tfileContents = new ResourceMap<string>();\n\n\t\tfileDelegate = {\n\t\t\tcreateFile: async (uri: URI, initialContent: string) => {\n\t\t\t\tfileContents.set(uri, initialContent);\n\t\t\t},\n\t\t\tdeleteFile: async (uri: URI) => {\n\t\t\t\tfileContents.delete(uri);\n\t\t\t},\n\t\t\trenameFile: async (fromUri: URI, toUri: URI) => {\n\t\t\t\tconst content = fileContents.get(fromUri);\n\t\t\t\tif (content !== undefined) {\n\t\t\t\t\tfileContents.set(toUri, content);\n\t\t\t\t\tfileContents.delete(fromUri);\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetContents: async (uri: URI, content: string) => {\n\t\t\t\tfileContents.set(uri, content);\n\t\t\t}\n\t\t};\n\n\t\tconst collection = new ServiceCollection();\n\t\tcollection.set(INotebookService, new SyncDescriptor(TestNotebookService));\n\t\tconst insta = store.add(workbenchInstantiationService(undefined, store).createChild(collection));\n\n\t\ttimeline = insta.createInstance(ChatEditingCheckpointTimelineImpl, URI.parse('chat://test-session'), fileDelegate);\n\t});\n\n\tteardown(() => {\n\t\tstore.clear();\n\t});\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('creates initial checkpoint on construction', function () {\n\t\tconst checkpoints = timeline.getStateForPersistence().checkpoints;\n\t\tassert.strictEqual(checkpoints.length, 1);\n\t\tassert.strictEqual(checkpoints[0].requestId, undefined);\n\t\tassert.strictEqual(checkpoints[0].label, 'Initial State');\n\t});\n\n\ttest('canUndo and canRedo are initially false', function () {\n\t\tassert.strictEqual(timeline.canUndo.get(), false);\n\t\tassert.strictEqual(timeline.canRedo.get(), false);\n\t});\n\n\ttest('createCheckpoint increments epoch and creates checkpoint', function () {\n\t\tconst initialEpoch = timeline.getStateForPersistence().epochCounter;\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Checkpoint 1');\n\n\t\tconst state = timeline.getStateForPersistence();\n\t\tassert.strictEqual(state.checkpoints.length, 2); // Initial + new checkpoint\n\t\tassert.strictEqual(state.checkpoints[1].requestId, 'req1');\n\t\tassert.strictEqual(state.checkpoints[1].undoStopId, 'stop1');\n\t\tassert.strictEqual(state.checkpoints[1].label, 'Checkpoint 1');\n\t\tassert.strictEqual(state.epochCounter, initialEpoch + 1);\n\t});\n\n\ttest('createCheckpoint does not create duplicate checkpoints', function () {\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Checkpoint 1');\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Checkpoint 1 Duplicate');\n\n\t\tconst checkpoints = timeline.getStateForPersistence().checkpoints;\n\t\tassert.strictEqual(checkpoints.length, 2); // Only initial + first checkpoint\n\t\tassert.strictEqual(checkpoints[1].label, 'Checkpoint 1'); // Original label preserved\n\t});\n\n\ttest('incrementEpoch increases epoch counter', function () {\n\t\tconst initialEpoch = timeline.getStateForPersistence().epochCounter;\n\n\t\tconst epoch1 = timeline.incrementEpoch();\n\t\tconst epoch2 = timeline.incrementEpoch();\n\n\t\tassert.strictEqual(epoch1, initialEpoch);\n\t\tassert.strictEqual(epoch2, initialEpoch + 1);\n\t\tassert.strictEqual(timeline.getStateForPersistence().epochCounter, initialEpoch + 2);\n\t});\n\n\ttest('recordFileBaseline stores baseline', function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\t\tconst baseline = upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial content',\n\t\t\tepoch: 1,\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t});\n\n\t\ttimeline.recordFileBaseline(baseline);\n\n\t\tassert.strictEqual(timeline.hasFileBaseline(uri, 'req1'), true);\n\t\tassert.strictEqual(timeline.hasFileBaseline(uri, 'req2'), false);\n\t});\n\n\ttest('recordFileOperation stores operation', function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\t\tconst operation = createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 1), text: 'hello' }]\n\t\t);\n\n\t\ttimeline.recordFileOperation(operation);\n\n\t\tconst state = timeline.getStateForPersistence();\n\t\tassert.strictEqual(state.operations.length, 1);\n\t\tassert.strictEqual(state.operations[0].type, FileOperationType.TextEdit);\n\t\tassert.strictEqual(state.operations[0].requestId, 'req1');\n\t});\n\n\ttest('basic undo/redo with text edits', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Record baseline\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'hello',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\t// Create checkpoint before edit - marks state with baseline\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start of Request');\n\n\t\t// Record edit at a new epoch\n\t\tconst editEpoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\teditEpoch,\n\t\t\t[{ range: new Range(1, 1, 1, 6), text: 'goodbye' }]\n\t\t));\n\n\t\t// Create checkpoint after edit - marks state with edit applied\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'After Edit');\n\n\t\t// canUndo and canRedo are based on checkpoint positions, not delegate state\n\t\t// We have: Initial, Start of Request, After Edit\n\t\t// Current epoch is after 'After Edit', so we can undo but not redo\n\t\tassert.strictEqual(timeline.canUndo.get(), true);\n\t\tassert.strictEqual(timeline.canRedo.get(), false);\n\n\t\t// Undo (goes to start of request)\n\t\tawait timeline.undoToLastCheckpoint();\n\n\t\t// After undoing to start of request, we can't undo within this request anymore\n\t\t// but we can redo to the 'stop1' checkpoint\n\t\tassert.strictEqual(timeline.canUndo.get(), false); // No more undo stops in req1 before this\n\t\tassert.strictEqual(timeline.canRedo.get(), true); // Can redo to 'stop1'\n\n\t\t// Redo\n\t\tawait timeline.redoToNextCheckpoint();\n\n\t\t// After redo to 'stop1', we can undo again\n\t\tassert.strictEqual(timeline.canUndo.get(), true);\n\t\t// canRedo might still be true if currentEpoch is less than the max epoch\n\t\t// This is because checkpoints are created with incrementEpoch, so there are epochs after them\n\t});\n\n\ttest('file creation and deletion operations', async function () {\n\t\tconst uri = URI.parse('file:///new.txt');\n\n\t\t// Create file\n\t\tconst createEpoch = timeline.incrementEpoch();\n\n\t\t// Record baseline for the created file\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'new file content',\n\t\t\tepoch: createEpoch,\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createFileCreateOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tcreateEpoch,\n\t\t\t'new file content'\n\t\t));\n\n\t\t// Checkpoint marks state after file creation\n\t\ttimeline.createCheckpoint('req1', 'created', 'File Created');\n\n\t\t// Navigate to initial to sync delegate, then to created\n\t\tawait timeline.navigateToCheckpoint(timeline.getStateForPersistence().checkpoints[0].checkpointId);\n\t\tassert.strictEqual(fileContents.has(uri), false);\n\n\t\t// Navigate to created checkpoint\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'created')!);\n\t\tassert.strictEqual(fileContents.get(uri), 'new file content');\n\n\t\t// Delete file\n\t\tconst deleteEpoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createFileDeleteOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tdeleteEpoch,\n\t\t\t'new file content'\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'deleted', 'File Deleted');\n\n\t\t// Navigate back to initial, then to deleted to properly apply operations\n\t\tawait timeline.navigateToCheckpoint(timeline.getStateForPersistence().checkpoints[0].checkpointId);\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'deleted')!);\n\t\tassert.strictEqual(fileContents.has(uri), false);\n\n\t\t// Undo deletion - goes back to 'created' checkpoint\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'new file content');\n\n\t\t// Undo creation - goes back to initial state\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.has(uri), false);\n\t});\n\n\ttest('file rename operations', async function () {\n\t\tconst oldUri = URI.parse('file:///old.txt');\n\t\tconst newUri = URI.parse('file:///new.txt');\n\n\t\t// Create initial file\n\t\tconst createEpoch = timeline.incrementEpoch();\n\n\t\t// Record baseline for the created file\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi: oldUri,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'content',\n\t\t\tepoch: createEpoch,\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createFileCreateOperation(\n\t\t\toldUri,\n\t\t\t'req1',\n\t\t\tcreateEpoch,\n\t\t\t'content'\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'created', 'File Created');\n\n\t\t// Navigate to initial, then to created to apply create operation\n\t\tawait timeline.navigateToCheckpoint(timeline.getStateForPersistence().checkpoints[0].checkpointId);\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'created')!);\n\t\tassert.strictEqual(fileContents.get(oldUri), 'content');\n\n\t\t// Rename file\n\t\tconst renameEpoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createFileRenameOperation(\n\t\t\toldUri,\n\t\t\tnewUri,\n\t\t\t'req1',\n\t\t\trenameEpoch\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'renamed', 'File Renamed');\n\n\t\t// Navigate back to initial, then to renamed to properly apply operations\n\t\tawait timeline.navigateToCheckpoint(timeline.getStateForPersistence().checkpoints[0].checkpointId);\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'renamed')!);\n\t\tassert.strictEqual(fileContents.has(oldUri), false);\n\t\tassert.strictEqual(fileContents.get(newUri), 'content');\n\n\t\t// Undo rename - goes back to 'created' checkpoint\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.get(oldUri), 'content');\n\t\tassert.strictEqual(fileContents.has(newUri), false);\n\t});\n\n\ttest('multiple sequential edits to same file', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Record baseline\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'line1\\nline2\\nline3',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\t// First edit\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 6), text: 'LINE1' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'edit1', 'Edit 1');\n\n\t\t// Second edit\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(2, 1, 2, 6), text: 'LINE2' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'edit2', 'Edit 2');\n\n\t\t// Navigate to first edit\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'edit1')!);\n\t\tassert.strictEqual(fileContents.get(uri), 'LINE1\\nline2\\nline3');\n\n\t\t// Navigate to second edit\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'edit2')!);\n\t\tassert.strictEqual(fileContents.get(uri), 'LINE1\\nLINE2\\nline3');\n\n\t\t// Navigate back to start\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', undefined)!);\n\t\tassert.strictEqual(fileContents.get(uri), 'line1\\nline2\\nline3');\n\t});\n\n\ttest('getCheckpointIdForRequest returns correct checkpoint', function () {\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start of req1');\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Stop 1');\n\t\ttimeline.createCheckpoint('req2', undefined, 'Start of req2');\n\n\t\tconst req1Start = timeline.getCheckpointIdForRequest('req1', undefined);\n\t\tconst req1Stop = timeline.getCheckpointIdForRequest('req1', 'stop1');\n\t\tconst req2Start = timeline.getCheckpointIdForRequest('req2', undefined);\n\n\t\tassert.ok(req1Start);\n\t\tassert.ok(req1Stop);\n\t\tassert.ok(req2Start);\n\t\tassert.notStrictEqual(req1Start, req1Stop);\n\t\tassert.notStrictEqual(req1Start, req2Start);\n\t});\n\n\ttest('getCheckpointIdForRequest returns undefined for non-existent checkpoint', function () {\n\t\tconst checkpoint = timeline.getCheckpointIdForRequest('nonexistent', 'stop1');\n\t\tassert.strictEqual(checkpoint, undefined);\n\t});\n\n\ttest('requestDisablement tracks disabled requests', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start req1');\n\t\ttimeline.recordFileOperation(createFileCreateOperation(uri, 'req1', timeline.incrementEpoch(), 'a'));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Stop req1');\n\t\ttimeline.recordFileOperation(createTextEditOperation(uri, 'req1', timeline.incrementEpoch(), [{ range: new Range(1, 1, 1, 2), text: 'b' }]));\n\n\t\ttimeline.createCheckpoint('req2', undefined, 'Start req2');\n\t\ttimeline.recordFileOperation(createTextEditOperation(uri, 'req2', timeline.incrementEpoch(), [{ range: new Range(1, 1, 1, 2), text: 'c' }]));\n\n\t\t// Undo sequence:\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), []);\n\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'b');\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), [\n\t\t\t{ requestId: 'req2', afterUndoStop: undefined },\n\t\t]);\n\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'a');\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), [\n\t\t\t{ requestId: 'req2', afterUndoStop: undefined },\n\t\t\t{ requestId: 'req1', afterUndoStop: 'stop1' },\n\t\t]);\n\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), undefined);\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), [\n\t\t\t{ requestId: 'req2', afterUndoStop: undefined },\n\t\t\t{ requestId: 'req1', afterUndoStop: undefined },\n\t\t]);\n\n\t\t// Redo sequence:\n\t\tawait timeline.redoToNextCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'a');\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), [\n\t\t\t{ requestId: 'req2', afterUndoStop: undefined },\n\t\t\t{ requestId: 'req1', afterUndoStop: 'stop1' },\n\t\t]);\n\n\t\tawait timeline.redoToNextCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'b');\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), [\n\t\t\t{ requestId: 'req2', afterUndoStop: undefined },\n\t\t]);\n\n\t\tawait timeline.redoToNextCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'c');\n\t});\n\n\ttest('persistence - save and restore state', function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Setup some state\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'modified' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Edit Complete');\n\n\t\t// Save state\n\t\tconst savedState = timeline.getStateForPersistence();\n\n\t\t// Create new timeline and restore\n\t\tconst collection = new ServiceCollection();\n\t\tcollection.set(INotebookService, new SyncDescriptor(TestNotebookService));\n\t\tconst insta = store.add(workbenchInstantiationService(undefined, store).createChild(collection));\n\n\t\tconst newTimeline = insta.createInstance(\n\t\t\tChatEditingCheckpointTimelineImpl,\n\t\t\tURI.parse('chat://test-session-2'),\n\t\t\tfileDelegate\n\t\t);\n\n\t\ttransaction(tx => {\n\t\t\tnewTimeline.restoreFromState(savedState, tx);\n\t\t});\n\n\t\t// Verify state was restored\n\t\tconst restoredState = newTimeline.getStateForPersistence();\n\t\tassert.strictEqual(restoredState.checkpoints.length, savedState.checkpoints.length);\n\t\tassert.strictEqual(restoredState.operations.length, savedState.operations.length);\n\t\tassert.strictEqual(restoredState.currentEpoch, savedState.currentEpoch);\n\t\tassert.strictEqual(restoredState.epochCounter, savedState.epochCounter);\n\t});\n\n\ttest('navigating between multiple requests', async function () {\n\t\tconst uri1 = URI.parse('file:///file1.txt');\n\t\tconst uri2 = URI.parse('file:///file2.txt');\n\n\t\t// Request 1 - create file\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start req1');\n\n\t\tconst create1Epoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi: uri1,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'file1 modified',\n\t\t\tepoch: create1Epoch,\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createFileCreateOperation(\n\t\t\turi1,\n\t\t\t'req1',\n\t\t\tcreate1Epoch,\n\t\t\t'file1 modified'\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Req1 complete');\n\n\t\t// Request 2 - create another file\n\t\ttimeline.createCheckpoint('req2', undefined, 'Start req2');\n\n\t\tconst create2Epoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi: uri2,\n\t\t\trequestId: 'req2',\n\t\t\tcontent: 'file2 modified',\n\t\t\tepoch: create2Epoch,\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createFileCreateOperation(\n\t\t\turi2,\n\t\t\t'req2',\n\t\t\tcreate2Epoch,\n\t\t\t'file2 modified'\n\t\t));\n\n\t\ttimeline.createCheckpoint('req2', 'stop1', 'Req2 complete');\n\n\t\t// Navigate to initial, then to req1 completion to apply its operations\n\t\tawait timeline.navigateToCheckpoint(timeline.getStateForPersistence().checkpoints[0].checkpointId);\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'stop1')!);\n\t\tassert.strictEqual(fileContents.get(uri1), 'file1 modified');\n\t\tassert.strictEqual(fileContents.has(uri2), false); // req2 hasn't happened yet\n\n\t\t// Navigate to req2 completion\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req2', 'stop1')!);\n\t\tassert.strictEqual(fileContents.get(uri1), 'file1 modified');\n\t\tassert.strictEqual(fileContents.get(uri2), 'file2 modified');\n\n\t\t// Navigate back to initial state by getting the first checkpoint\n\t\tconst initialCheckpoint = timeline.getStateForPersistence().checkpoints[0];\n\t\tawait timeline.navigateToCheckpoint(initialCheckpoint.checkpointId);\n\t\tassert.strictEqual(fileContents.has(uri1), false);\n\t\tassert.strictEqual(fileContents.has(uri2), false);\n\t});\n\n\ttest('getContentURIAtStop returns snapshot URI', function () {\n\t\tconst fileUri = URI.parse('file:///test.txt');\n\t\tconst snapshotUri = timeline.getContentURIAtStop('req1', fileUri, 'stop1');\n\n\t\tassert.ok(snapshotUri);\n\t\tassert.notStrictEqual(snapshotUri.toString(), fileUri.toString());\n\t\tassert.ok(snapshotUri.toString().includes('req1'));\n\t});\n\n\ttest('undoing entire request when appropriate', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Create initial baseline and checkpoint\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start req1');\n\n\t\t// Single edit with checkpoint\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'modified' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Edit complete');\n\n\t\t// Should be able to undo\n\t\tassert.strictEqual(timeline.canUndo.get(), true);\n\n\t\t// Undo should go back to start of request, not just previous checkpoint\n\t\tawait timeline.undoToLastCheckpoint();\n\n\t\t// Verify we're at the start of req1, which has epoch 2 (0 = initial, 1 = baseline, 2 = start checkpoint)\n\t\tconst state = timeline.getStateForPersistence();\n\t\tassert.strictEqual(state.currentEpoch, 2); // Should be at the \"Start req1\" checkpoint epoch\n\t});\n\n\ttest('operations use incrementing epochs', function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\tconst epoch1 = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tepoch1,\n\t\t\t[{ range: new Range(1, 1, 1, 1), text: 'edit1' }]\n\t\t));\n\n\t\tconst epoch2 = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tepoch2,\n\t\t\t[{ range: new Range(2, 1, 2, 1), text: 'edit2' }]\n\t\t));\n\n\t\t// Both operations should be recorded\n\t\tconst operations = timeline.getStateForPersistence().operations;\n\t\tassert.strictEqual(operations.length, 2);\n\t\tassert.strictEqual(operations[0].epoch, epoch1);\n\t\tassert.strictEqual(operations[1].epoch, epoch2);\n\t});\n\n\ttest('navigateToCheckpoint throws error for invalid checkpoint ID', async function () {\n\t\tlet errorThrown = false;\n\t\ttry {\n\t\t\tawait timeline.navigateToCheckpoint('invalid-checkpoint-id');\n\t\t} catch (error) {\n\t\t\terrorThrown = true;\n\t\t\tassert.ok(error instanceof Error);\n\t\t\tassert.ok((error as Error).message.includes('not found'));\n\t\t}\n\t\tassert.ok(errorThrown, 'Expected error to be thrown');\n\t});\n\n\ttest('navigateToCheckpoint does nothing when already at target epoch', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Record baseline and operation\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\tconst createEpoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tcreateEpoch,\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'modified' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Checkpoint');\n\n\t\t// Navigate to checkpoint\n\t\tconst checkpointId = timeline.getCheckpointIdForRequest('req1', 'stop1')!;\n\t\tawait timeline.navigateToCheckpoint(checkpointId);\n\n\t\t// Navigate again to same checkpoint - should be a no-op\n\t\tconst stateBefore = timeline.getStateForPersistence();\n\t\tawait timeline.navigateToCheckpoint(checkpointId);\n\t\tconst stateAfter = timeline.getStateForPersistence();\n\n\t\tassert.strictEqual(stateBefore.currentEpoch, stateAfter.currentEpoch);\n\t});\n\n\ttest('recording operation after undo truncates future history', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Setup initial operations\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'edit1' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Edit 1');\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 6), text: 'edit2' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop2', 'Edit 2');\n\n\t\tconst stateWithTwoEdits = timeline.getStateForPersistence();\n\t\tassert.strictEqual(stateWithTwoEdits.operations.length, 2);\n\n\t\t// Undo to stop1\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'stop1')!);\n\n\t\t// Record new operation - this should truncate the second edit\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 6), text: 'edit3' }]\n\t\t));\n\n\t\tconst stateAfterNewEdit = timeline.getStateForPersistence();\n\t\tassert.strictEqual(stateAfterNewEdit.operations.length, 2);\n\t\tassert.strictEqual(stateAfterNewEdit.operations[1].type, FileOperationType.TextEdit);\n\t\t// The second operation should be the new edit3, not edit2\n\t});\n\n\ttest('redo after recording new operation should work', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'edit1' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Edit 1');\n\n\t\t// Undo\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(timeline.canRedo.get(), true);\n\n\t\t// Redo\n\t\tawait timeline.redoToNextCheckpoint();\n\n\t\t// After redo, canRedo depends on whether we're at the latest epoch\n\t\t// Since we created a checkpoint after the operation, currentEpoch is ahead\n\t\t// of the checkpoint epoch, so canRedo may still be true\n\t\tassert.strictEqual(timeline.canUndo.get(), true);\n\t});\n\n\ttest('redo when there is no checkpoint after operation', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\t// Record operation but don't create checkpoint after it\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'edit1' }]\n\t\t));\n\n\t\t// Undo to start\n\t\tconst startCheckpoint = timeline.getCheckpointIdForRequest('req1', undefined)!;\n\t\tawait timeline.navigateToCheckpoint(startCheckpoint);\n\n\t\t// Should be able to redo even without a checkpoint after the operation\n\t\tassert.strictEqual(timeline.canRedo.get(), true);\n\n\t\tawait timeline.redoToNextCheckpoint();\n\t\t// After redo, we should be at the operation's epoch + 1\n\t\tconst state = timeline.getStateForPersistence();\n\t\tassert.ok(state.currentEpoch > 1);\n\t});\n\n\ttest('getContentAtStop returns empty for non-existent file', async function () {\n\t\tconst uri = URI.parse('file:///nonexistent.txt');\n\t\tconst content = await timeline.getContentAtStop('req1', uri, 'stop1');\n\n\t\tassert.strictEqual(content, '');\n\t});\n\n\ttest('getContentAtStop with epoch-based stopId', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\tconst editEpoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\teditEpoch,\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'modified' }]\n\t\t));\n\n\t\t// Use epoch-based stop ID\n\t\tconst content = await timeline.getContentAtStop('req1', uri, `__epoch_${editEpoch + 1}`);\n\n\t\tassert.ok(content);\n\t\tassert.strictEqual(content, 'modified');\n\t});\n\n\ttest('hasFileBaseline correctly reports baseline existence', function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\tassert.strictEqual(timeline.hasFileBaseline(uri, 'req1'), false);\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\tassert.strictEqual(timeline.hasFileBaseline(uri, 'req1'), true);\n\t\tassert.strictEqual(timeline.hasFileBaseline(uri, 'req2'), false);\n\t});\n\n\ttest('multiple text edits to same file are properly replayed', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'line1\\nline2\\nline3',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\t// First edit - uppercase line 1\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 6), text: 'LINE1' }]\n\t\t));\n\n\t\t// Second edit - uppercase line 2\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(2, 1, 2, 6), text: 'LINE2' }]\n\t\t));\n\n\t\t// Third edit - uppercase line 3\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(3, 1, 3, 6), text: 'LINE3' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'all-edits', 'All edits');\n\n\t\t// Navigate to see all edits applied\n\t\tconst initialCheckpoint = timeline.getStateForPersistence().checkpoints[0];\n\t\tawait timeline.navigateToCheckpoint(initialCheckpoint.checkpointId);\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'all-edits')!);\n\n\t\tassert.strictEqual(fileContents.get(uri), 'LINE1\\nLINE2\\nLINE3');\n\t});\n\n\ttest('checkpoint with same requestId and undoStopId is not duplicated', function () {\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'First');\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Second'); // Should be ignored\n\n\t\tconst checkpoints = timeline.getStateForPersistence().checkpoints;\n\t\tconst req1Stop1Checkpoints = checkpoints.filter(c => c.requestId === 'req1' && c.undoStopId === 'stop1');\n\n\t\tassert.strictEqual(req1Stop1Checkpoints.length, 1);\n\t\tassert.strictEqual(req1Stop1Checkpoints[0].label, 'First');\n\t});\n\n\ttest('finding baseline after file rename operation', async function () {\n\t\tconst oldUri = URI.parse('file:///old.txt');\n\t\tconst newUri = URI.parse('file:///new.txt');\n\n\t\t// Create baseline for old URI\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi: oldUri,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial content',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\t// Edit the file before rename (replace entire content)\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\toldUri,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 16), text: 'modified content' }]\n\t\t));\n\n\t\t// Rename operation\n\t\ttimeline.recordFileOperation(createFileRenameOperation(\n\t\t\toldUri,\n\t\t\tnewUri,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch()\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'renamed', 'After rename');\n\n\t\t// Get content at the renamed URI - should find the baseline through rename chain\n\t\tconst content = await timeline.getContentAtStop('req1', newUri, 'renamed');\n\t\tassert.strictEqual(content, 'modified content');\n\t});\n\n\ttest('baseline lookup across different request IDs', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// First request baseline\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'req1 content',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 13), text: 'req1 modified' }]\n\t\t));\n\n\t\t// Second request baseline\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req2',\n\t\t\tcontent: 'req2 content',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req2',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 13), text: 'req2 modified' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req2', 'stop1', 'Req2 checkpoint');\n\n\t\t// Getting content should use req2 baseline\n\t\tconst content = await timeline.getContentAtStop('req2', uri, 'stop1');\n\t\tassert.strictEqual(content, 'req2 modified');\n\t});\n\n\ttest('getContentAtStop with file that does not exist in operations', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'content',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Checkpoint');\n\n\t\t// Try to get content for a different URI that doesn't have any operations\n\t\tconst differentUri = URI.parse('file:///different.txt');\n\t\tconst content = await timeline.getContentAtStop('req1', differentUri, 'stop1');\n\n\t\tassert.strictEqual(content, '');\n\t});\n\n\ttest('undoToLastCheckpoint when canUndo is false does nothing', async function () {\n\t\t// At initial state, canUndo should be false\n\t\tassert.strictEqual(timeline.canUndo.get(), false);\n\n\t\tconst stateBefore = timeline.getStateForPersistence();\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tconst stateAfter = timeline.getStateForPersistence();\n\n\t\t// Should not have changed\n\t\tassert.strictEqual(stateBefore.currentEpoch, stateAfter.currentEpoch);\n\t});\n\n\ttest('redoToNextCheckpoint when canRedo is false does nothing', async function () {\n\t\t// At initial state with no future operations, canRedo should be false\n\t\tassert.strictEqual(timeline.canRedo.get(), false);\n\n\t\tconst stateBefore = timeline.getStateForPersistence();\n\t\tawait timeline.redoToNextCheckpoint();\n\t\tconst stateAfter = timeline.getStateForPersistence();\n\n\t\t// Should not have changed\n\t\tassert.strictEqual(stateBefore.currentEpoch, stateAfter.currentEpoch);\n\t});\n\n\ttest('orphaned operations and checkpoints are removed after undo and new changes', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Create the file first\n\t\tconst createEpoch = timeline.incrementEpoch();\n\n\t\ttimeline.recordFileOperation(createFileCreateOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tcreateEpoch,\n\t\t\t'initial content'\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start req1');\n\n\t\t// First set of changes\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 16), text: 'first edit' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'First Edit');\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 11), text: 'second edit' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop2', 'Second Edit');\n\n\t\t// Verify we have 3 operations (create + 2 edits) and 4 checkpoints (initial, start, stop1, stop2)\n\t\tlet state = timeline.getStateForPersistence();\n\t\tassert.strictEqual(state.operations.length, 3);\n\t\tassert.strictEqual(state.checkpoints.length, 4);\n\n\t\t// Undo to stop1 (before second edit)\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'stop1')!);\n\n\t\t// Record a new operation - this should truncate the \"second edit\" operation\n\t\t// and remove the stop2 checkpoint\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 11), text: 'replacement edit' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop2-new', 'Replacement Edit');\n\n\t\t// Verify the orphaned operation and checkpoint are gone\n\t\tstate = timeline.getStateForPersistence();\n\t\tassert.strictEqual(state.operations.length, 3, 'Should still have 3 operations (create + first + replacement)');\n\t\tassert.strictEqual(state.checkpoints.length, 4, 'Should have 4 checkpoints (initial, start, stop1, stop2-new)');\n\n\t\t// Verify the third operation is the replacement, not the original second edit\n\t\tconst thirdOp = state.operations[2];\n\t\tassert.strictEqual(thirdOp.type, FileOperationType.TextEdit);\n\t\tif (thirdOp.type === FileOperationType.TextEdit) {\n\t\t\tassert.strictEqual(thirdOp.edits[0].text, 'replacement edit');\n\t\t}\n\n\t\t// Verify the stop2-new checkpoint exists, not stop2\n\t\tconst stop2NewCheckpoint = timeline.getCheckpointIdForRequest('req1', 'stop2-new');\n\t\tconst stop2OldCheckpoint = timeline.getCheckpointIdForRequest('req1', 'stop2');\n\t\tassert.ok(stop2NewCheckpoint, 'New checkpoint should exist');\n\t\tassert.strictEqual(stop2OldCheckpoint, undefined, 'Old orphaned checkpoint should be removed');\n\n\t\t// Now navigate through the entire timeline to verify consistency\n\t\tconst initialCheckpoint = state.checkpoints[0];\n\t\tconst startCheckpoint = timeline.getCheckpointIdForRequest('req1', undefined)!;\n\t\tconst stop1Checkpoint = timeline.getCheckpointIdForRequest('req1', 'stop1')!;\n\t\tconst stop2NewCheckpointId = timeline.getCheckpointIdForRequest('req1', 'stop2-new')!;\n\n\t\t// Navigate to initial to clear everything\n\t\tawait timeline.navigateToCheckpoint(initialCheckpoint.checkpointId);\n\t\tassert.strictEqual(fileContents.has(uri), false);\n\n\t\t// Navigate to start - file should be created\n\t\tawait timeline.navigateToCheckpoint(startCheckpoint);\n\t\tassert.strictEqual(fileContents.get(uri), 'initial content');\n\n\t\t// Navigate to stop1 - first edit should be applied\n\t\tawait timeline.navigateToCheckpoint(stop1Checkpoint);\n\t\tassert.strictEqual(fileContents.get(uri), 'first edit');\n\n\t\t// Navigate to stop2-new - replacement edit should be applied, NOT the orphaned \"second edit\"\n\t\tawait timeline.navigateToCheckpoint(stop2NewCheckpointId);\n\t\tassert.strictEqual(fileContents.get(uri), 'replacement edit');\n\n\t\t// Navigate back to start\n\t\tawait timeline.navigateToCheckpoint(startCheckpoint);\n\t\tassert.strictEqual(fileContents.get(uri), 'initial content');\n\n\t\t// Navigate forward through all checkpoints again to ensure redo works correctly\n\t\tawait timeline.navigateToCheckpoint(stop1Checkpoint);\n\t\tassert.strictEqual(fileContents.get(uri), 'first edit');\n\n\t\tawait timeline.navigateToCheckpoint(stop2NewCheckpointId);\n\t\tassert.strictEqual(fileContents.get(uri), 'replacement edit', 'Orphaned edit should never reappear');\n\n\t\t// Go back to initial and forward again to thoroughly test\n\t\tawait timeline.navigateToCheckpoint(initialCheckpoint.checkpointId);\n\t\tawait timeline.navigateToCheckpoint(stop2NewCheckpointId);\n\t\tassert.strictEqual(fileContents.get(uri), 'replacement edit', 'Content should still be correct after full timeline traversal');\n\t});\n});\n\n// Mock notebook service for tests that don't need notebook functionality\nclass TestNotebookService {\n\tgetNotebookTextModel() { return undefined; }\n\thasSupportedNotebooks() { return false; }\n}\n\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { DisposableStore } from '../../../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../../../base/common/map.js';\nimport { transaction } from '../../../../../base/common/observable.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { upcastPartial } from '../../../../../base/test/common/mock.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { SyncDescriptor } from '../../../../../platform/instantiation/common/descriptors.js';\nimport { ServiceCollection } from '../../../../../platform/instantiation/common/serviceCollection.js';\nimport { workbenchInstantiationService } from '../../../../test/browser/workbenchTestServices.js';\nimport { INotebookService } from '../../../notebook/common/notebookService.js';\nimport { ChatEditingCheckpointTimelineImpl, IChatEditingTimelineFsDelegate } from '../../browser/chatEditing/chatEditingCheckpointTimelineImpl.js';\nimport { FileOperation, FileOperationType } from '../../browser/chatEditing/chatEditingOperations.js';\nimport { IModifiedEntryTelemetryInfo } from '../../common/chatEditingService.js';\n\nsuite('ChatEditingCheckpointTimeline', function () {\n\n\tconst store = new DisposableStore();\n\tlet timeline: ChatEditingCheckpointTimelineImpl;\n\tlet fileContents: ResourceMap<string>;\n\tlet fileDelegate: IChatEditingTimelineFsDelegate;\n\n\tconst DEFAULT_TELEMETRY_INFO: IModifiedEntryTelemetryInfo = upcastPartial({\n\t\tagentId: 'testAgent',\n\t\tcommand: undefined,\n\t\tsessionResource: URI.parse('chat://test-session'),\n\t\trequestId: 'test-request',\n\t\tresult: undefined,\n\t\tmodelId: undefined,\n\t\tmodeId: undefined,\n\t\tapplyCodeBlockSuggestionId: undefined,\n\t\tfeature: undefined,\n\t});\n\n\tfunction createTextEditOperation(uri: URI, requestId: string, epoch: number, edits: { range: Range; text: string }[]): FileOperation {\n\t\treturn upcastPartial<FileOperation>({\n\t\t\ttype: FileOperationType.TextEdit,\n\t\t\turi,\n\t\t\trequestId,\n\t\t\tepoch,\n\t\t\tedits\n\t\t});\n\t}\n\n\tfunction createFileCreateOperation(uri: URI, requestId: string, epoch: number, initialContent: string): FileOperation {\n\t\treturn upcastPartial<FileOperation>({\n\t\t\ttype: FileOperationType.Create,\n\t\t\turi,\n\t\t\trequestId,\n\t\t\tepoch,\n\t\t\tinitialContent\n\t\t});\n\t}\n\n\tfunction createFileDeleteOperation(uri: URI, requestId: string, epoch: number, finalContent: string): FileOperation {\n\t\treturn upcastPartial<FileOperation>({\n\t\t\ttype: FileOperationType.Delete,\n\t\t\turi,\n\t\t\trequestId,\n\t\t\tepoch,\n\t\t\tfinalContent\n\t\t});\n\t}\n\n\tfunction createFileRenameOperation(oldUri: URI, newUri: URI, requestId: string, epoch: number): FileOperation {\n\t\treturn upcastPartial<FileOperation>({\n\t\t\ttype: FileOperationType.Rename,\n\t\t\turi: newUri,\n\t\t\trequestId,\n\t\t\tepoch,\n\t\t\toldUri,\n\t\t\tnewUri\n\t\t});\n\t}\n\n\tsetup(function () {\n\t\tfileContents = new ResourceMap<string>();\n\n\t\tfileDelegate = {\n\t\t\tcreateFile: async (uri: URI, initialContent: string) => {\n\t\t\t\tfileContents.set(uri, initialContent);\n\t\t\t},\n\t\t\tdeleteFile: async (uri: URI) => {\n\t\t\t\tfileContents.delete(uri);\n\t\t\t},\n\t\t\trenameFile: async (fromUri: URI, toUri: URI) => {\n\t\t\t\tconst content = fileContents.get(fromUri);\n\t\t\t\tif (content !== undefined) {\n\t\t\t\t\tfileContents.set(toUri, content);\n\t\t\t\t\tfileContents.delete(fromUri);\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetContents: async (uri: URI, content: string) => {\n\t\t\t\tfileContents.set(uri, content);\n\t\t\t}\n\t\t};\n\n\t\tconst collection = new ServiceCollection();\n\t\tcollection.set(INotebookService, new SyncDescriptor(TestNotebookService));\n\t\tconst insta = store.add(workbenchInstantiationService(undefined, store).createChild(collection));\n\n\t\ttimeline = insta.createInstance(ChatEditingCheckpointTimelineImpl, URI.parse('chat://test-session'), fileDelegate);\n\t});\n\n\tteardown(() => {\n\t\tstore.clear();\n\t});\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('creates initial checkpoint on construction', function () {\n\t\tconst checkpoints = timeline.getStateForPersistence().checkpoints;\n\t\tassert.strictEqual(checkpoints.length, 1);\n\t\tassert.strictEqual(checkpoints[0].requestId, undefined);\n\t\tassert.strictEqual(checkpoints[0].label, 'Initial State');\n\t});\n\n\ttest('canUndo and canRedo are initially false', function () {\n\t\tassert.strictEqual(timeline.canUndo.get(), false);\n\t\tassert.strictEqual(timeline.canRedo.get(), false);\n\t});\n\n\ttest('createCheckpoint increments epoch and creates checkpoint', function () {\n\t\tconst initialEpoch = timeline.getStateForPersistence().epochCounter;\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Checkpoint 1');\n\n\t\tconst state = timeline.getStateForPersistence();\n\t\tassert.strictEqual(state.checkpoints.length, 2); // Initial + new checkpoint\n\t\tassert.strictEqual(state.checkpoints[1].requestId, 'req1');\n\t\tassert.strictEqual(state.checkpoints[1].undoStopId, 'stop1');\n\t\tassert.strictEqual(state.checkpoints[1].label, 'Checkpoint 1');\n\t\tassert.strictEqual(state.epochCounter, initialEpoch + 1);\n\t});\n\n\ttest('createCheckpoint does not create duplicate checkpoints', function () {\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Checkpoint 1');\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Checkpoint 1 Duplicate');\n\n\t\tconst checkpoints = timeline.getStateForPersistence().checkpoints;\n\t\tassert.strictEqual(checkpoints.length, 2); // Only initial + first checkpoint\n\t\tassert.strictEqual(checkpoints[1].label, 'Checkpoint 1'); // Original label preserved\n\t});\n\n\ttest('incrementEpoch increases epoch counter', function () {\n\t\tconst initialEpoch = timeline.getStateForPersistence().epochCounter;\n\n\t\tconst epoch1 = timeline.incrementEpoch();\n\t\tconst epoch2 = timeline.incrementEpoch();\n\n\t\tassert.strictEqual(epoch1, initialEpoch);\n\t\tassert.strictEqual(epoch2, initialEpoch + 1);\n\t\tassert.strictEqual(timeline.getStateForPersistence().epochCounter, initialEpoch + 2);\n\t});\n\n\ttest('recordFileBaseline stores baseline', function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\t\tconst baseline = upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial content',\n\t\t\tepoch: 1,\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t});\n\n\t\ttimeline.recordFileBaseline(baseline);\n\n\t\tassert.strictEqual(timeline.hasFileBaseline(uri, 'req1'), true);\n\t\tassert.strictEqual(timeline.hasFileBaseline(uri, 'req2'), false);\n\t});\n\n\ttest('recordFileOperation stores operation', function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\t\tconst operation = createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 1), text: 'hello' }]\n\t\t);\n\n\t\ttimeline.recordFileOperation(operation);\n\n\t\tconst state = timeline.getStateForPersistence();\n\t\tassert.strictEqual(state.operations.length, 1);\n\t\tassert.strictEqual(state.operations[0].type, FileOperationType.TextEdit);\n\t\tassert.strictEqual(state.operations[0].requestId, 'req1');\n\t});\n\n\ttest('basic undo/redo with text edits', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Record baseline\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'hello',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\t// Create checkpoint before edit - marks state with baseline\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start of Request');\n\n\t\t// Record edit at a new epoch\n\t\tconst editEpoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\teditEpoch,\n\t\t\t[{ range: new Range(1, 1, 1, 6), text: 'goodbye' }]\n\t\t));\n\n\t\t// Create checkpoint after edit - marks state with edit applied\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'After Edit');\n\n\t\t// canUndo and canRedo are based on checkpoint positions, not delegate state\n\t\t// We have: Initial, Start of Request, After Edit\n\t\t// Current epoch is after 'After Edit', so we can undo but not redo\n\t\tassert.strictEqual(timeline.canUndo.get(), true);\n\t\tassert.strictEqual(timeline.canRedo.get(), false);\n\n\t\t// Undo (goes to start of request)\n\t\tawait timeline.undoToLastCheckpoint();\n\n\t\t// After undoing to start of request, we can't undo within this request anymore\n\t\t// but we can redo to the 'stop1' checkpoint\n\t\tassert.strictEqual(timeline.canUndo.get(), false); // No more undo stops in req1 before this\n\t\tassert.strictEqual(timeline.canRedo.get(), true); // Can redo to 'stop1'\n\n\t\t// Redo\n\t\tawait timeline.redoToNextCheckpoint();\n\n\t\t// After redo to 'stop1', we can undo again\n\t\tassert.strictEqual(timeline.canUndo.get(), true);\n\t\t// canRedo might still be true if currentEpoch is less than the max epoch\n\t\t// This is because checkpoints are created with incrementEpoch, so there are epochs after them\n\t});\n\n\ttest('file creation and deletion operations', async function () {\n\t\tconst uri = URI.parse('file:///new.txt');\n\n\t\t// Create file\n\t\tconst createEpoch = timeline.incrementEpoch();\n\n\t\t// Record baseline for the created file\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'new file content',\n\t\t\tepoch: createEpoch,\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createFileCreateOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tcreateEpoch,\n\t\t\t'new file content'\n\t\t));\n\n\t\t// Checkpoint marks state after file creation\n\t\ttimeline.createCheckpoint('req1', 'created', 'File Created');\n\n\t\t// Navigate to initial to sync delegate, then to created\n\t\tawait timeline.navigateToCheckpoint(timeline.getStateForPersistence().checkpoints[0].checkpointId);\n\t\tassert.strictEqual(fileContents.has(uri), false);\n\n\t\t// Navigate to created checkpoint\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'created')!);\n\t\tassert.strictEqual(fileContents.get(uri), 'new file content');\n\n\t\t// Delete file\n\t\tconst deleteEpoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createFileDeleteOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tdeleteEpoch,\n\t\t\t'new file content'\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'deleted', 'File Deleted');\n\n\t\t// Navigate back to initial, then to deleted to properly apply operations\n\t\tawait timeline.navigateToCheckpoint(timeline.getStateForPersistence().checkpoints[0].checkpointId);\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'deleted')!);\n\t\tassert.strictEqual(fileContents.has(uri), false);\n\n\t\t// Undo deletion - goes back to 'created' checkpoint\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'new file content');\n\n\t\t// Undo creation - goes back to initial state\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.has(uri), false);\n\t});\n\n\ttest('file rename operations', async function () {\n\t\tconst oldUri = URI.parse('file:///old.txt');\n\t\tconst newUri = URI.parse('file:///new.txt');\n\n\t\t// Create initial file\n\t\tconst createEpoch = timeline.incrementEpoch();\n\n\t\t// Record baseline for the created file\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi: oldUri,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'content',\n\t\t\tepoch: createEpoch,\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createFileCreateOperation(\n\t\t\toldUri,\n\t\t\t'req1',\n\t\t\tcreateEpoch,\n\t\t\t'content'\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'created', 'File Created');\n\n\t\t// Navigate to initial, then to created to apply create operation\n\t\tawait timeline.navigateToCheckpoint(timeline.getStateForPersistence().checkpoints[0].checkpointId);\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'created')!);\n\t\tassert.strictEqual(fileContents.get(oldUri), 'content');\n\n\t\t// Rename file\n\t\tconst renameEpoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createFileRenameOperation(\n\t\t\toldUri,\n\t\t\tnewUri,\n\t\t\t'req1',\n\t\t\trenameEpoch\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'renamed', 'File Renamed');\n\n\t\t// Navigate back to initial, then to renamed to properly apply operations\n\t\tawait timeline.navigateToCheckpoint(timeline.getStateForPersistence().checkpoints[0].checkpointId);\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'renamed')!);\n\t\tassert.strictEqual(fileContents.has(oldUri), false);\n\t\tassert.strictEqual(fileContents.get(newUri), 'content');\n\n\t\t// Undo rename - goes back to 'created' checkpoint\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.get(oldUri), 'content');\n\t\tassert.strictEqual(fileContents.has(newUri), false);\n\t});\n\n\ttest('multiple sequential edits to same file', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Record baseline\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'line1\\nline2\\nline3',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\t// First edit\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 6), text: 'LINE1' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'edit1', 'Edit 1');\n\n\t\t// Second edit\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(2, 1, 2, 6), text: 'LINE2' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'edit2', 'Edit 2');\n\n\t\t// Navigate to first edit\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'edit1')!);\n\t\tassert.strictEqual(fileContents.get(uri), 'LINE1\\nline2\\nline3');\n\n\t\t// Navigate to second edit\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'edit2')!);\n\t\tassert.strictEqual(fileContents.get(uri), 'LINE1\\nLINE2\\nline3');\n\n\t\t// Navigate back to start\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', undefined)!);\n\t\tassert.strictEqual(fileContents.get(uri), 'line1\\nline2\\nline3');\n\t});\n\n\ttest('getCheckpointIdForRequest returns correct checkpoint', function () {\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start of req1');\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Stop 1');\n\t\ttimeline.createCheckpoint('req2', undefined, 'Start of req2');\n\n\t\tconst req1Start = timeline.getCheckpointIdForRequest('req1', undefined);\n\t\tconst req1Stop = timeline.getCheckpointIdForRequest('req1', 'stop1');\n\t\tconst req2Start = timeline.getCheckpointIdForRequest('req2', undefined);\n\n\t\tassert.ok(req1Start);\n\t\tassert.ok(req1Stop);\n\t\tassert.ok(req2Start);\n\t\tassert.notStrictEqual(req1Start, req1Stop);\n\t\tassert.notStrictEqual(req1Start, req2Start);\n\t});\n\n\ttest('getCheckpointIdForRequest returns undefined for non-existent checkpoint', function () {\n\t\tconst checkpoint = timeline.getCheckpointIdForRequest('nonexistent', 'stop1');\n\t\tassert.strictEqual(checkpoint, undefined);\n\t});\n\n\ttest('requestDisablement tracks disabled requests', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start req1');\n\t\ttimeline.recordFileOperation(createFileCreateOperation(uri, 'req1', timeline.incrementEpoch(), 'a'));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Stop req1');\n\t\ttimeline.recordFileOperation(createTextEditOperation(uri, 'req1', timeline.incrementEpoch(), [{ range: new Range(1, 1, 1, 2), text: 'b' }]));\n\n\t\ttimeline.createCheckpoint('req2', undefined, 'Start req2');\n\t\ttimeline.recordFileOperation(createTextEditOperation(uri, 'req2', timeline.incrementEpoch(), [{ range: new Range(1, 1, 1, 2), text: 'c' }]));\n\n\t\t// Undo sequence:\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), []);\n\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'b');\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), [\n\t\t\t{ requestId: 'req2', afterUndoStop: undefined },\n\t\t]);\n\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'a');\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), [\n\t\t\t{ requestId: 'req2', afterUndoStop: undefined },\n\t\t\t{ requestId: 'req1', afterUndoStop: 'stop1' },\n\t\t]);\n\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), undefined);\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), [\n\t\t\t{ requestId: 'req2', afterUndoStop: undefined },\n\t\t\t{ requestId: 'req1', afterUndoStop: undefined },\n\t\t]);\n\n\t\t// Redo sequence:\n\t\tawait timeline.redoToNextCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'a');\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), [\n\t\t\t{ requestId: 'req2', afterUndoStop: undefined },\n\t\t\t{ requestId: 'req1', afterUndoStop: 'stop1' },\n\t\t]);\n\n\t\tawait timeline.redoToNextCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'b');\n\t\tassert.deepStrictEqual(timeline.requestDisablement.get(), [\n\t\t\t{ requestId: 'req2', afterUndoStop: undefined },\n\t\t]);\n\n\t\tawait timeline.redoToNextCheckpoint();\n\t\tassert.strictEqual(fileContents.get(uri), 'c');\n\t});\n\n\ttest('persistence - save and restore state', function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Setup some state\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'modified' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Edit Complete');\n\n\t\t// Save state\n\t\tconst savedState = timeline.getStateForPersistence();\n\n\t\t// Create new timeline and restore\n\t\tconst collection = new ServiceCollection();\n\t\tcollection.set(INotebookService, new SyncDescriptor(TestNotebookService));\n\t\tconst insta = store.add(workbenchInstantiationService(undefined, store).createChild(collection));\n\n\t\tconst newTimeline = insta.createInstance(\n\t\t\tChatEditingCheckpointTimelineImpl,\n\t\t\tURI.parse('chat://test-session-2'),\n\t\t\tfileDelegate\n\t\t);\n\n\t\ttransaction(tx => {\n\t\t\tnewTimeline.restoreFromState(savedState, tx);\n\t\t});\n\n\t\t// Verify state was restored\n\t\tconst restoredState = newTimeline.getStateForPersistence();\n\t\tassert.strictEqual(restoredState.checkpoints.length, savedState.checkpoints.length);\n\t\tassert.strictEqual(restoredState.operations.length, savedState.operations.length);\n\t\tassert.strictEqual(restoredState.currentEpoch, savedState.currentEpoch);\n\t\tassert.strictEqual(restoredState.epochCounter, savedState.epochCounter);\n\t});\n\n\ttest('navigating between multiple requests', async function () {\n\t\tconst uri1 = URI.parse('file:///file1.txt');\n\t\tconst uri2 = URI.parse('file:///file2.txt');\n\n\t\t// Request 1 - create file\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start req1');\n\n\t\tconst create1Epoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi: uri1,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'file1 modified',\n\t\t\tepoch: create1Epoch,\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createFileCreateOperation(\n\t\t\turi1,\n\t\t\t'req1',\n\t\t\tcreate1Epoch,\n\t\t\t'file1 modified'\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Req1 complete');\n\n\t\t// Request 2 - create another file\n\t\ttimeline.createCheckpoint('req2', undefined, 'Start req2');\n\n\t\tconst create2Epoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi: uri2,\n\t\t\trequestId: 'req2',\n\t\t\tcontent: 'file2 modified',\n\t\t\tepoch: create2Epoch,\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createFileCreateOperation(\n\t\t\turi2,\n\t\t\t'req2',\n\t\t\tcreate2Epoch,\n\t\t\t'file2 modified'\n\t\t));\n\n\t\ttimeline.createCheckpoint('req2', 'stop1', 'Req2 complete');\n\n\t\t// Navigate to initial, then to req1 completion to apply its operations\n\t\tawait timeline.navigateToCheckpoint(timeline.getStateForPersistence().checkpoints[0].checkpointId);\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'stop1')!);\n\t\tassert.strictEqual(fileContents.get(uri1), 'file1 modified');\n\t\tassert.strictEqual(fileContents.has(uri2), false); // req2 hasn't happened yet\n\n\t\t// Navigate to req2 completion\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req2', 'stop1')!);\n\t\tassert.strictEqual(fileContents.get(uri1), 'file1 modified');\n\t\tassert.strictEqual(fileContents.get(uri2), 'file2 modified');\n\n\t\t// Navigate back to initial state by getting the first checkpoint\n\t\tconst initialCheckpoint = timeline.getStateForPersistence().checkpoints[0];\n\t\tawait timeline.navigateToCheckpoint(initialCheckpoint.checkpointId);\n\t\tassert.strictEqual(fileContents.has(uri1), false);\n\t\tassert.strictEqual(fileContents.has(uri2), false);\n\t});\n\n\ttest('getContentURIAtStop returns snapshot URI', function () {\n\t\tconst fileUri = URI.parse('file:///test.txt');\n\t\tconst snapshotUri = timeline.getContentURIAtStop('req1', fileUri, 'stop1');\n\n\t\tassert.ok(snapshotUri);\n\t\tassert.notStrictEqual(snapshotUri.toString(), fileUri.toString());\n\t\tassert.ok(snapshotUri.toString().includes('req1'));\n\t});\n\n\ttest('undoing entire request when appropriate', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Create initial baseline and checkpoint\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start req1');\n\n\t\t// Single edit with checkpoint\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'modified' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Edit complete');\n\n\t\t// Should be able to undo\n\t\tassert.strictEqual(timeline.canUndo.get(), true);\n\n\t\t// Undo should go back to start of request, not just previous checkpoint\n\t\tawait timeline.undoToLastCheckpoint();\n\n\t\t// Verify we're at the start of req1, which has epoch 2 (0 = initial, 1 = baseline, 2 = start checkpoint)\n\t\tconst state = timeline.getStateForPersistence();\n\t\tassert.strictEqual(state.currentEpoch, 2); // Should be at the \"Start req1\" checkpoint epoch\n\t});\n\n\ttest('operations use incrementing epochs', function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\tconst epoch1 = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tepoch1,\n\t\t\t[{ range: new Range(1, 1, 1, 1), text: 'edit1' }]\n\t\t));\n\n\t\tconst epoch2 = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tepoch2,\n\t\t\t[{ range: new Range(2, 1, 2, 1), text: 'edit2' }]\n\t\t));\n\n\t\t// Both operations should be recorded\n\t\tconst operations = timeline.getStateForPersistence().operations;\n\t\tassert.strictEqual(operations.length, 2);\n\t\tassert.strictEqual(operations[0].epoch, epoch1);\n\t\tassert.strictEqual(operations[1].epoch, epoch2);\n\t});\n\n\ttest('navigateToCheckpoint throws error for invalid checkpoint ID', async function () {\n\t\tlet errorThrown = false;\n\t\ttry {\n\t\t\tawait timeline.navigateToCheckpoint('invalid-checkpoint-id');\n\t\t} catch (error) {\n\t\t\terrorThrown = true;\n\t\t\tassert.ok(error instanceof Error);\n\t\t\tassert.ok((error as Error).message.includes('not found'));\n\t\t}\n\t\tassert.ok(errorThrown, 'Expected error to be thrown');\n\t});\n\n\ttest('navigateToCheckpoint does nothing when already at target epoch', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Record baseline and operation\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\tconst createEpoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tcreateEpoch,\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'modified' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Checkpoint');\n\n\t\t// Navigate to checkpoint\n\t\tconst checkpointId = timeline.getCheckpointIdForRequest('req1', 'stop1')!;\n\t\tawait timeline.navigateToCheckpoint(checkpointId);\n\n\t\t// Navigate again to same checkpoint - should be a no-op\n\t\tconst stateBefore = timeline.getStateForPersistence();\n\t\tawait timeline.navigateToCheckpoint(checkpointId);\n\t\tconst stateAfter = timeline.getStateForPersistence();\n\n\t\tassert.strictEqual(stateBefore.currentEpoch, stateAfter.currentEpoch);\n\t});\n\n\ttest('recording operation after undo truncates future history', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Setup initial operations\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'edit1' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Edit 1');\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 6), text: 'edit2' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop2', 'Edit 2');\n\n\t\tconst stateWithTwoEdits = timeline.getStateForPersistence();\n\t\tassert.strictEqual(stateWithTwoEdits.operations.length, 2);\n\n\t\t// Undo to stop1\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'stop1')!);\n\n\t\t// Record new operation - this should truncate the second edit\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 6), text: 'edit3' }]\n\t\t));\n\n\t\tconst stateAfterNewEdit = timeline.getStateForPersistence();\n\t\tassert.strictEqual(stateAfterNewEdit.operations.length, 2);\n\t\tassert.strictEqual(stateAfterNewEdit.operations[1].type, FileOperationType.TextEdit);\n\t\t// The second operation should be the new edit3, not edit2\n\t});\n\n\ttest('redo after recording new operation should work', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'edit1' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Edit 1');\n\n\t\t// Undo\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tassert.strictEqual(timeline.canRedo.get(), true);\n\n\t\t// Redo\n\t\tawait timeline.redoToNextCheckpoint();\n\n\t\t// After redo, canRedo depends on whether we're at the latest epoch\n\t\t// Since we created a checkpoint after the operation, currentEpoch is ahead\n\t\t// of the checkpoint epoch, so canRedo may still be true\n\t\tassert.strictEqual(timeline.canUndo.get(), true);\n\t});\n\n\ttest('redo when there is no checkpoint after operation', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\t// Record operation but don't create checkpoint after it\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'edit1' }]\n\t\t));\n\n\t\t// Undo to start\n\t\tconst startCheckpoint = timeline.getCheckpointIdForRequest('req1', undefined)!;\n\t\tawait timeline.navigateToCheckpoint(startCheckpoint);\n\n\t\t// Should be able to redo even without a checkpoint after the operation\n\t\tassert.strictEqual(timeline.canRedo.get(), true);\n\n\t\tawait timeline.redoToNextCheckpoint();\n\t\t// After redo, we should be at the operation's epoch + 1\n\t\tconst state = timeline.getStateForPersistence();\n\t\tassert.ok(state.currentEpoch > 1);\n\t});\n\n\ttest('getContentAtStop returns empty for non-existent file', async function () {\n\t\tconst uri = URI.parse('file:///nonexistent.txt');\n\t\tconst content = await timeline.getContentAtStop('req1', uri, 'stop1');\n\n\t\tassert.strictEqual(content, '');\n\t});\n\n\ttest('getContentAtStop with epoch-based stopId', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\tconst editEpoch = timeline.incrementEpoch();\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\teditEpoch,\n\t\t\t[{ range: new Range(1, 1, 1, 8), text: 'modified' }]\n\t\t));\n\n\t\t// Use epoch-based stop ID\n\t\tconst content = await timeline.getContentAtStop('req1', uri, `__epoch_${editEpoch + 1}`);\n\n\t\tassert.ok(content);\n\t\tassert.strictEqual(content, 'modified');\n\t});\n\n\ttest('hasFileBaseline correctly reports baseline existence', function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\tassert.strictEqual(timeline.hasFileBaseline(uri, 'req1'), false);\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\tassert.strictEqual(timeline.hasFileBaseline(uri, 'req1'), true);\n\t\tassert.strictEqual(timeline.hasFileBaseline(uri, 'req2'), false);\n\t});\n\n\ttest('multiple text edits to same file are properly replayed', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'line1\\nline2\\nline3',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start');\n\n\t\t// First edit - uppercase line 1\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 6), text: 'LINE1' }]\n\t\t));\n\n\t\t// Second edit - uppercase line 2\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(2, 1, 2, 6), text: 'LINE2' }]\n\t\t));\n\n\t\t// Third edit - uppercase line 3\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(3, 1, 3, 6), text: 'LINE3' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'all-edits', 'All edits');\n\n\t\t// Navigate to see all edits applied\n\t\tconst initialCheckpoint = timeline.getStateForPersistence().checkpoints[0];\n\t\tawait timeline.navigateToCheckpoint(initialCheckpoint.checkpointId);\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'all-edits')!);\n\n\t\tassert.strictEqual(fileContents.get(uri), 'LINE1\\nLINE2\\nLINE3');\n\t});\n\n\ttest('checkpoint with same requestId and undoStopId is not duplicated', function () {\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'First');\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Second'); // Should be ignored\n\n\t\tconst checkpoints = timeline.getStateForPersistence().checkpoints;\n\t\tconst req1Stop1Checkpoints = checkpoints.filter(c => c.requestId === 'req1' && c.undoStopId === 'stop1');\n\n\t\tassert.strictEqual(req1Stop1Checkpoints.length, 1);\n\t\tassert.strictEqual(req1Stop1Checkpoints[0].label, 'First');\n\t});\n\n\ttest('finding baseline after file rename operation', async function () {\n\t\tconst oldUri = URI.parse('file:///old.txt');\n\t\tconst newUri = URI.parse('file:///new.txt');\n\n\t\t// Create baseline for old URI\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi: oldUri,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'initial content',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\t// Edit the file before rename (replace entire content)\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\toldUri,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 16), text: 'modified content' }]\n\t\t));\n\n\t\t// Rename operation\n\t\ttimeline.recordFileOperation(createFileRenameOperation(\n\t\t\toldUri,\n\t\t\tnewUri,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch()\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'renamed', 'After rename');\n\n\t\t// Get content at the renamed URI - should find the baseline through rename chain\n\t\tconst content = await timeline.getContentAtStop('req1', newUri, 'renamed');\n\t\tassert.strictEqual(content, 'modified content');\n\t});\n\n\ttest('baseline lookup across different request IDs', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// First request baseline\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'req1 content',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 13), text: 'req1 modified' }]\n\t\t));\n\n\t\t// Second request baseline\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req2',\n\t\t\tcontent: 'req2 content',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req2',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 13), text: 'req2 modified' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req2', 'stop1', 'Req2 checkpoint');\n\n\t\t// Getting content should use req2 baseline\n\t\tconst content = await timeline.getContentAtStop('req2', uri, 'stop1');\n\t\tassert.strictEqual(content, 'req2 modified');\n\t});\n\n\ttest('getContentAtStop with file that does not exist in operations', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\ttimeline.recordFileBaseline(upcastPartial({\n\t\t\turi,\n\t\t\trequestId: 'req1',\n\t\t\tcontent: 'content',\n\t\t\tepoch: timeline.incrementEpoch(),\n\t\t\ttelemetryInfo: DEFAULT_TELEMETRY_INFO\n\t\t}));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'Checkpoint');\n\n\t\t// Try to get content for a different URI that doesn't have any operations\n\t\tconst differentUri = URI.parse('file:///different.txt');\n\t\tconst content = await timeline.getContentAtStop('req1', differentUri, 'stop1');\n\n\t\tassert.strictEqual(content, '');\n\t});\n\n\ttest('undoToLastCheckpoint when canUndo is false does nothing', async function () {\n\t\t// At initial state, canUndo should be false\n\t\tassert.strictEqual(timeline.canUndo.get(), false);\n\n\t\tconst stateBefore = timeline.getStateForPersistence();\n\t\tawait timeline.undoToLastCheckpoint();\n\t\tconst stateAfter = timeline.getStateForPersistence();\n\n\t\t// Should not have changed\n\t\tassert.strictEqual(stateBefore.currentEpoch, stateAfter.currentEpoch);\n\t});\n\n\ttest('redoToNextCheckpoint when canRedo is false does nothing', async function () {\n\t\t// At initial state with no future operations, canRedo should be false\n\t\tassert.strictEqual(timeline.canRedo.get(), false);\n\n\t\tconst stateBefore = timeline.getStateForPersistence();\n\t\tawait timeline.redoToNextCheckpoint();\n\t\tconst stateAfter = timeline.getStateForPersistence();\n\n\t\t// Should not have changed\n\t\tassert.strictEqual(stateBefore.currentEpoch, stateAfter.currentEpoch);\n\t});\n\n\ttest('orphaned operations and checkpoints are removed after undo and new changes', async function () {\n\t\tconst uri = URI.parse('file:///test.txt');\n\n\t\t// Create the file first\n\t\tconst createEpoch = timeline.incrementEpoch();\n\n\t\ttimeline.recordFileOperation(createFileCreateOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\tcreateEpoch,\n\t\t\t'initial content'\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', undefined, 'Start req1');\n\n\t\t// First set of changes\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 16), text: 'first edit' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop1', 'First Edit');\n\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 11), text: 'second edit' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop2', 'Second Edit');\n\n\t\t// Verify we have 3 operations (create + 2 edits) and 4 checkpoints (initial, start, stop1, stop2)\n\t\tlet state = timeline.getStateForPersistence();\n\t\tassert.strictEqual(state.operations.length, 3);\n\t\tassert.strictEqual(state.checkpoints.length, 4);\n\n\t\t// Undo to stop1 (before second edit)\n\t\tawait timeline.navigateToCheckpoint(timeline.getCheckpointIdForRequest('req1', 'stop1')!);\n\n\t\t// Record a new operation - this should truncate the \"second edit\" operation\n\t\t// and remove the stop2 checkpoint\n\t\ttimeline.recordFileOperation(createTextEditOperation(\n\t\t\turi,\n\t\t\t'req1',\n\t\t\ttimeline.incrementEpoch(),\n\t\t\t[{ range: new Range(1, 1, 1, 11), text: 'replacement edit' }]\n\t\t));\n\n\t\ttimeline.createCheckpoint('req1', 'stop2-new', 'Replacement Edit');\n\n\t\t// Verify the orphaned operation and checkpoint are gone\n\t\tstate = timeline.getStateForPersistence();\n\t\tassert.strictEqual(state.operations.length, 3, 'Should still have 3 operations (create + first + replacement)');\n\t\tassert.strictEqual(state.checkpoints.length, 4, 'Should have 4 checkpoints (initial, start, stop1, stop2-new)');\n\n\t\t// Verify the third operation is the replacement, not the original second edit\n\t\tconst thirdOp = state.operations[2];\n\t\tassert.strictEqual(thirdOp.type, FileOperationType.TextEdit);\n\t\tif (thirdOp.type === FileOperationType.TextEdit) {\n\t\t\tassert.strictEqual(thirdOp.edits[0].text, 'replacement edit');\n\t\t}\n\n\t\t// Verify the stop2-new checkpoint exists, not stop2\n\t\tconst stop2NewCheckpoint = timeline.getCheckpointIdForRequest('req1', 'stop2-new');\n\t\tconst stop2OldCheckpoint = timeline.getCheckpointIdForRequest('req1', 'stop2');\n\t\tassert.ok(stop2NewCheckpoint, 'New checkpoint should exist');\n\t\tassert.strictEqual(stop2OldCheckpoint, undefined, 'Old orphaned checkpoint should be removed');\n\n\t\t// Now navigate through the entire timeline to verify consistency\n\t\tconst initialCheckpoint = state.checkpoints[0];\n\t\tconst startCheckpoint = timeline.getCheckpointIdForRequest('req1', undefined)!;\n\t\tconst stop1Checkpoint = timeline.getCheckpointIdForRequest('req1', 'stop1')!;\n\t\tconst stop2NewCheckpointId = timeline.getCheckpointIdForRequest('req1', 'stop2-new')!;\n\n\t\t// Navigate to initial to clear everything\n\t\tawait timeline.navigateToCheckpoint(initialCheckpoint.checkpointId);\n\t\tassert.strictEqual(fileContents.has(uri), false);\n\n\t\t// Navigate to start - file should be created\n\t\tawait timeline.navigateToCheckpoint(startCheckpoint);\n\t\tassert.strictEqual(fileContents.get(uri), 'initial content');\n\n\t\t// Navigate to stop1 - first edit should be applied\n\t\tawait timeline.navigateToCheckpoint(stop1Checkpoint);\n\t\tassert.strictEqual(fileContents.get(uri), 'first edit');\n\n\t\t// Navigate to stop2-new - replacement edit should be applied, NOT the orphaned \"second edit\"\n\t\tawait timeline.navigateToCheckpoint(stop2NewCheckpointId);\n\t\tassert.strictEqual(fileContents.get(uri), 'replacement edit');\n\n\t\t// Navigate back to start\n\t\tawait timeline.navigateToCheckpoint(startCheckpoint);\n\t\tassert.strictEqual(fileContents.get(uri), 'initial content');\n\n\t\t// Navigate forward through all checkpoints again to ensure redo works correctly\n\t\tawait timeline.navigateToCheckpoint(stop1Checkpoint);\n\t\tassert.strictEqual(fileContents.get(uri), 'first edit');\n\n\t\tawait timeline.navigateToCheckpoint(stop2NewCheckpointId);\n\t\tassert.strictEqual(fileContents.get(uri), 'replacement edit', 'Orphaned edit should never reappear');\n\n\t\t// Go back to initial and forward again to thoroughly test\n\t\tawait timeline.navigateToCheckpoint(initialCheckpoint.checkpointId);\n\t\tawait timeline.navigateToCheckpoint(stop2NewCheckpointId);\n\t\tassert.strictEqual(fileContents.get(uri), 'replacement edit', 'Content should still be correct after full timeline traversal');\n\t});\n});\n\n// Mock notebook service for tests that don't need notebook functionality\nclass TestNotebookService {\n\tgetNotebookTextModel() { return undefined; }\n\thasSupportedNotebooks() { return false; }\n}\n\n\n"]}