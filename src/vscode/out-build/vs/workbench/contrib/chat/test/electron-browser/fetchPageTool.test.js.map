{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/test/electron-browser/fetchPageTool.test.ts","vs/workbench/contrib/chat/test/electron-browser/fetchPageTool.test.ts"],"names":[],"mappings":"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","file":"fetchPageTool.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { VSBuffer } from '../../../../../base/common/buffer.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { ResourceMap } from '../../../../../base/common/map.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { IFileContent, IReadFileOptions } from '../../../../../platform/files/common/files.js';\nimport { IWebContentExtractorService, WebContentExtractResult } from '../../../../../platform/webContentExtractor/common/webContentExtractor.js';\nimport { FetchWebPageTool } from '../../electron-browser/tools/fetchPageTool.js';\nimport { TestFileService } from '../../../../test/common/workbenchTestServices.js';\nimport { MockTrustedDomainService } from '../../../url/test/browser/mockTrustedDomainService.js';\nimport { InternalFetchWebPageToolId } from '../../common/tools/tools.js';\nimport { MockChatService } from '../common/mockChatService.js';\nimport { upcastDeepPartial } from '../../../../../base/test/common/mock.js';\nimport { IChatService } from '../../common/chatService.js';\n\nclass TestWebContentExtractorService implements IWebContentExtractorService {\n\t_serviceBrand: undefined;\n\n\tconstructor(private uriToContentMap: ResourceMap<string>) { }\n\n\tasync extract(uris: URI[]): Promise<WebContentExtractResult[]> {\n\t\treturn uris.map(uri => {\n\t\t\tconst content = this.uriToContentMap.get(uri);\n\t\t\tif (content === undefined) {\n\t\t\t\tthrow new Error(`No content configured for URI: ${uri.toString()}`);\n\t\t\t}\n\t\t\treturn { status: 'ok', result: content };\n\t\t});\n\t}\n}\n\nclass ExtendedTestFileService extends TestFileService {\n\tconstructor(private uriToContentMap: ResourceMap<string | VSBuffer>) {\n\t\tsuper();\n\t}\n\n\toverride async readFile(resource: URI, options?: IReadFileOptions | undefined): Promise<IFileContent> {\n\t\tconst content = this.uriToContentMap.get(resource);\n\t\tif (content === undefined) {\n\t\t\tthrow new Error(`File not found: ${resource.toString()}`);\n\t\t}\n\n\t\tconst buffer = typeof content === 'string' ? VSBuffer.fromString(content) : content;\n\t\treturn {\n\t\t\tresource,\n\t\t\tvalue: buffer,\n\t\t\tname: '',\n\t\t\tsize: buffer.byteLength,\n\t\t\tetag: '',\n\t\t\tmtime: 0,\n\t\t\tctime: 0,\n\t\t\treadonly: false,\n\t\t\tlocked: false\n\t\t};\n\t}\n\n\toverride async stat(resource: URI) {\n\t\t// Check if the resource exists in our map\n\t\tif (!this.uriToContentMap.has(resource)) {\n\t\t\tthrow new Error(`File not found: ${resource.toString()}`);\n\t\t}\n\n\t\treturn super.stat(resource);\n\t}\n}\n\nsuite('FetchWebPageTool', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('should handle http/https via web content extractor and other schemes via file service', async () => {\n\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t[URI.parse('https://example.com'), 'HTTPS content'],\n\t\t\t[URI.parse('http://example.com'), 'HTTP content']\n\t\t]);\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('test://static/resource/50'), 'MCP resource content'],\n\t\t\t[URI.parse('mcp-resource://746573742D736572766572/custom/hello/world.txt'), 'Custom MCP content']\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst testUrls = [\n\t\t\t'https://example.com',\n\t\t\t'http://example.com',\n\t\t\t'test://static/resource/50',\n\t\t\t'mcp-resource://746573742D736572766572/custom/hello/world.txt',\n\t\t\t'file:///path/to/nonexistent',\n\t\t\t'ftp://example.com',\n\t\t\t'invalid-url'\n\t\t];\n\n\t\tconst result = await tool.invoke(\n\t\t\t{ callId: 'test-call-1', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Should have 7 results (one for each input URL)\n\t\tassert.strictEqual(result.content.length, 7, 'Should have result for each input URL');\n\n\t\t// HTTP and HTTPS URLs should have their content from web extractor\n\t\tassert.strictEqual(result.content[0].value, 'HTTPS content', 'HTTPS URL should return content');\n\t\tassert.strictEqual(result.content[1].value, 'HTTP content', 'HTTP URL should return content');\n\n\t\t// MCP resources should have their content from file service\n\t\tassert.strictEqual(result.content[2].value, 'MCP resource content', 'test:// URL should return content from file service');\n\t\tassert.strictEqual(result.content[3].value, 'Custom MCP content', 'mcp-resource:// URL should return content from file service');\n\n\t\t// Nonexistent file should be marked as invalid\n\t\tassert.strictEqual(result.content[4].value, 'Invalid URL', 'Nonexistent file should be invalid');\n\n\t\t// Unsupported scheme (ftp) should be marked as invalid since file service can't handle it\n\t\tassert.strictEqual(result.content[5].value, 'Invalid URL', 'ftp:// URL should be invalid');\n\n\t\t// Invalid URL should be marked as invalid\n\t\tassert.strictEqual(result.content[6].value, 'Invalid URL', 'Invalid URL should be invalid');\n\n\t\t// All successfully fetched URLs should be in toolResultDetails\n\t\tassert.strictEqual(Array.isArray(result.toolResultDetails) ? result.toolResultDetails.length : 0, 4, 'Should have 4 valid URLs in toolResultDetails');\n\t});\n\n\ttest('should handle empty and undefined URLs', async () => {\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\tnew MockTrustedDomainService([]),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\t// Test empty array\n\t\tconst emptyResult = await tool.invoke(\n\t\t\t{ callId: 'test-call-2', toolId: 'fetch-page', parameters: { urls: [] }, context: undefined },\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(emptyResult.content.length, 1, 'Empty array should return single message');\n\t\tassert.strictEqual(emptyResult.content[0].value, 'No valid URLs provided.', 'Should indicate no valid URLs');\n\n\t\t// Test undefined\n\t\tconst undefinedResult = await tool.invoke(\n\t\t\t{ callId: 'test-call-3', toolId: 'fetch-page', parameters: {}, context: undefined },\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(undefinedResult.content.length, 1, 'Undefined URLs should return single message');\n\t\tassert.strictEqual(undefinedResult.content[0].value, 'No valid URLs provided.', 'Should indicate no valid URLs');\n\n\t\t// Test array with invalid URLs\n\t\tconst invalidResult = await tool.invoke(\n\t\t\t{ callId: 'test-call-4', toolId: 'fetch-page', parameters: { urls: ['', ' ', 'invalid-scheme-that-fileservice-cannot-handle://test'] }, context: undefined },\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(invalidResult.content.length, 3, 'Should have result for each invalid URL');\n\t\tassert.strictEqual(invalidResult.content[0].value, 'Invalid URL', 'Empty string should be invalid');\n\t\tassert.strictEqual(invalidResult.content[1].value, 'Invalid URL', 'Space-only string should be invalid');\n\t\tassert.strictEqual(invalidResult.content[2].value, 'Invalid URL', 'Unhandleable scheme should be invalid');\n\t});\n\n\ttest('should provide correct past tense messages for mixed valid/invalid URLs', async () => {\n\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t[URI.parse('https://valid.com'), 'Valid content']\n\t\t]);\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('test://valid/resource'), 'Valid MCP content']\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst preparation = await tool.prepareToolInvocation(\n\t\t\t{ parameters: { urls: ['https://valid.com', 'test://valid/resource', 'invalid://invalid'] } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\tassert.ok(preparation, 'Should return prepared invocation');\n\t\tassert.ok(preparation.pastTenseMessage, 'Should have past tense message');\n\t\tconst messageText = typeof preparation.pastTenseMessage === 'string' ? preparation.pastTenseMessage : preparation.pastTenseMessage!.value;\n\t\tassert.ok(messageText.includes('Fetched'), 'Should mention fetched resources');\n\t\tassert.ok(messageText.includes('invalid://invalid'), 'Should mention invalid URL');\n\t});\n\n\ttest('should approve when all URLs were mentioned in chat', async () => {\n\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t[URI.parse('https://valid.com'), 'Valid content']\n\t\t]);\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('test://valid/resource'), 'Valid MCP content']\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tupcastDeepPartial<IChatService>({\n\t\t\t\tgetSession: () => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tgetRequests: () => [{\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttext: 'fetch https://example.com'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}],\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\n\t\tconst preparation1 = await tool.prepareToolInvocation(\n\t\t\t{ parameters: { urls: ['https://example.com'] }, chatSessionId: 'a' },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\tassert.ok(preparation1, 'Should return prepared invocation');\n\t\tassert.strictEqual(preparation1.confirmationMessages?.title, undefined);\n\n\t\tconst preparation2 = await tool.prepareToolInvocation(\n\t\t\t{ parameters: { urls: ['https://other.com'] }, chatSessionId: 'a' },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\tassert.ok(preparation2, 'Should return prepared invocation');\n\t\tassert.ok(preparation2.confirmationMessages?.title);\n\t});\n\n\ttest('should return message for binary files indicating they are not supported', async () => {\n\t\t// Create binary content (a simple PNG-like header with null bytes)\n\t\tconst binaryContent = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D]);\n\t\tconst binaryBuffer = VSBuffer.wrap(binaryContent);\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('file:///path/to/binary.dat'), binaryBuffer],\n\t\t\t[URI.parse('file:///path/to/text.txt'), 'This is text content']\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-call-binary',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///path/to/binary.dat', 'file:///path/to/text.txt'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Should have 2 results\n\t\tassert.strictEqual(result.content.length, 2, 'Should have 2 results');\n\n\t\t// First result should be a text part with binary not supported message\n\t\tassert.strictEqual(result.content[0].kind, 'text', 'Binary file should return text part');\n\t\tif (result.content[0].kind === 'text') {\n\t\t\tassert.strictEqual(result.content[0].value, 'Binary files are not supported at the moment.', 'Should return not supported message');\n\t\t}\n\n\t\t// Second result should be a text part for the text file\n\t\tassert.strictEqual(result.content[1].kind, 'text', 'Text file should return text part');\n\t\tif (result.content[1].kind === 'text') {\n\t\t\tassert.strictEqual(result.content[1].value, 'This is text content', 'Should return text content');\n\t\t}\n\n\t\t// Both files should be in toolResultDetails since they were successfully fetched\n\t\tassert.strictEqual(Array.isArray(result.toolResultDetails) ? result.toolResultDetails.length : 0, 2, 'Should have 2 valid URLs in toolResultDetails');\n\t});\n\n\ttest('PNG files are now supported as image data parts (regression test)', async () => {\n\t\t// This test ensures that PNG files that previously returned \"not supported\"\n\t\t// messages now return proper image data parts\n\t\tconst binaryContent = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D]);\n\t\tconst binaryBuffer = VSBuffer.wrap(binaryContent);\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('file:///path/to/image.png'), binaryBuffer]\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-png-support',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///path/to/image.png'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Should have 1 result\n\t\tassert.strictEqual(result.content.length, 1, 'Should have 1 result');\n\n\t\t// PNG file should now be returned as a data part, not a \"not supported\" message\n\t\tassert.strictEqual(result.content[0].kind, 'data', 'PNG file should return data part');\n\t\tif (result.content[0].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[0].value.mimeType, 'image/png', 'Should have PNG MIME type');\n\t\t\tassert.strictEqual(result.content[0].value.data, binaryBuffer, 'Should have correct binary data');\n\t\t}\n\t});\n\n\ttest('should correctly distinguish between binary and text content', async () => {\n\t\t// Create content that might be ambiguous\n\t\tconst jsonData = '{\"name\": \"test\", \"value\": 123}';\n\t\t// Create definitely binary data - some random bytes with null bytes that don't follow UTF-16 pattern\n\t\tconst realBinaryData = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x00, 0x00, 0x00, 0x0D, 0xFF, 0x00, 0xAB]); // More clearly binary\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('file:///data.json'), jsonData], // Should be detected as text\n\t\t\t[URI.parse('file:///binary.dat'), VSBuffer.wrap(realBinaryData)] // Should be detected as binary\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-distinguish',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///data.json', 'file:///binary.dat'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// JSON should be returned as text\n\t\tassert.strictEqual(result.content[0].kind, 'text', 'JSON should be detected as text');\n\t\tif (result.content[0].kind === 'text') {\n\t\t\tassert.strictEqual(result.content[0].value, jsonData, 'Should return JSON as text');\n\t\t}\n\n\t\t// Binary data should be returned as not supported message\n\t\tassert.strictEqual(result.content[1].kind, 'text', 'Binary content should return text part with message');\n\t\tif (result.content[1].kind === 'text') {\n\t\t\tassert.strictEqual(result.content[1].value, 'Binary files are not supported at the moment.', 'Should return not supported message');\n\t\t}\n\t});\n\n\ttest('Supported image files are returned as data parts', async () => {\n\t\t// Test data for different supported image formats\n\t\tconst pngData = VSBuffer.fromString('fake PNG data');\n\t\tconst jpegData = VSBuffer.fromString('fake JPEG data');\n\t\tconst gifData = VSBuffer.fromString('fake GIF data');\n\t\tconst webpData = VSBuffer.fromString('fake WebP data');\n\t\tconst bmpData = VSBuffer.fromString('fake BMP data');\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>();\n\t\tfileContentMap.set(URI.parse('file:///image.png'), pngData);\n\t\tfileContentMap.set(URI.parse('file:///photo.jpg'), jpegData);\n\t\tfileContentMap.set(URI.parse('file:///animation.gif'), gifData);\n\t\tfileContentMap.set(URI.parse('file:///modern.webp'), webpData);\n\t\tfileContentMap.set(URI.parse('file:///bitmap.bmp'), bmpData);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-images',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///image.png', 'file:///photo.jpg', 'file:///animation.gif', 'file:///modern.webp', 'file:///bitmap.bmp'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// All images should be returned as data parts\n\t\tassert.strictEqual(result.content.length, 5, 'Should have 5 results');\n\n\t\t// Check PNG\n\t\tassert.strictEqual(result.content[0].kind, 'data', 'PNG should be data part');\n\t\tif (result.content[0].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[0].value.mimeType, 'image/png', 'PNG should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[0].value.data, pngData, 'PNG should have correct data');\n\t\t}\n\n\t\t// Check JPEG\n\t\tassert.strictEqual(result.content[1].kind, 'data', 'JPEG should be data part');\n\t\tif (result.content[1].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[1].value.mimeType, 'image/jpeg', 'JPEG should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[1].value.data, jpegData, 'JPEG should have correct data');\n\t\t}\n\n\t\t// Check GIF\n\t\tassert.strictEqual(result.content[2].kind, 'data', 'GIF should be data part');\n\t\tif (result.content[2].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[2].value.mimeType, 'image/gif', 'GIF should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[2].value.data, gifData, 'GIF should have correct data');\n\t\t}\n\n\t\t// Check WebP\n\t\tassert.strictEqual(result.content[3].kind, 'data', 'WebP should be data part');\n\t\tif (result.content[3].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[3].value.mimeType, 'image/webp', 'WebP should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[3].value.data, webpData, 'WebP should have correct data');\n\t\t}\n\n\t\t// Check BMP\n\t\tassert.strictEqual(result.content[4].kind, 'data', 'BMP should be data part');\n\t\tif (result.content[4].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[4].value.mimeType, 'image/bmp', 'BMP should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[4].value.data, bmpData, 'BMP should have correct data');\n\t\t}\n\t});\n\n\ttest('Mixed image and text files work correctly', async () => {\n\t\tconst textData = 'This is some text content';\n\t\tconst imageData = VSBuffer.fromString('fake image data');\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>();\n\t\tfileContentMap.set(URI.parse('file:///text.txt'), textData);\n\t\tfileContentMap.set(URI.parse('file:///image.png'), imageData);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-mixed',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///text.txt', 'file:///image.png'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Text should be returned as text part\n\t\tassert.strictEqual(result.content[0].kind, 'text', 'Text file should be text part');\n\t\tif (result.content[0].kind === 'text') {\n\t\t\tassert.strictEqual(result.content[0].value, textData, 'Text should have correct content');\n\t\t}\n\n\t\t// Image should be returned as data part\n\t\tassert.strictEqual(result.content[1].kind, 'data', 'Image file should be data part');\n\t\tif (result.content[1].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[1].value.mimeType, 'image/png', 'Image should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[1].value.data, imageData, 'Image should have correct data');\n\t\t}\n\t});\n\n\ttest('Case insensitive image extensions work', async () => {\n\t\tconst imageData = VSBuffer.fromString('fake image data');\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>();\n\t\tfileContentMap.set(URI.parse('file:///image.PNG'), imageData);\n\t\tfileContentMap.set(URI.parse('file:///photo.JPEG'), imageData);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-case',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///image.PNG', 'file:///photo.JPEG'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Both should be returned as data parts despite uppercase extensions\n\t\tassert.strictEqual(result.content[0].kind, 'data', 'PNG with uppercase extension should be data part');\n\t\tif (result.content[0].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[0].value.mimeType, 'image/png', 'Should have correct MIME type');\n\t\t}\n\n\t\tassert.strictEqual(result.content[1].kind, 'data', 'JPEG with uppercase extension should be data part');\n\t\tif (result.content[1].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[1].value.mimeType, 'image/jpeg', 'Should have correct MIME type');\n\t\t}\n\t});\n\n\t// Comprehensive tests for toolResultDetails\n\tsuite('toolResultDetails', () => {\n\t\ttest('should include only successfully fetched URIs in correct order', async () => {\n\t\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t\t[URI.parse('https://success1.com'), 'Content 1'],\n\t\t\t\t[URI.parse('https://success2.com'), 'Content 2']\n\t\t\t]);\n\n\t\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t\t[URI.parse('file:///success.txt'), 'File content'],\n\t\t\t\t[URI.parse('mcp-resource://server/file.txt'), 'MCP content']\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst testUrls = [\n\t\t\t\t'https://success1.com',       // index 0 - should be in toolResultDetails\n\t\t\t\t'invalid-url',                // index 1 - should NOT be in toolResultDetails\n\t\t\t\t'file:///success.txt',        // index 2 - should be in toolResultDetails\n\t\t\t\t'https://success2.com',       // index 3 - should be in toolResultDetails\n\t\t\t\t'file:///nonexistent.txt',    // index 4 - should NOT be in toolResultDetails\n\t\t\t\t'mcp-resource://server/file.txt' // index 5 - should be in toolResultDetails\n\t\t\t];\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-details', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\t// Verify toolResultDetails contains exactly the successful URIs\n\t\t\tassert.ok(Array.isArray(result.toolResultDetails), 'toolResultDetails should be an array');\n\t\t\tassert.strictEqual(result.toolResultDetails.length, 4, 'Should have 4 successful URIs');\n\n\t\t\t// Check that all entries are URI objects\n\t\t\tconst uriDetails = result.toolResultDetails as URI[];\n\t\t\tassert.ok(uriDetails.every(uri => uri instanceof URI), 'All toolResultDetails entries should be URI objects');\n\n\t\t\t// Check specific URIs are included (web URIs first, then successful file URIs)\n\t\t\tconst expectedUris = [\n\t\t\t\t'https://success1.com/',\n\t\t\t\t'https://success2.com/',\n\t\t\t\t'file:///success.txt',\n\t\t\t\t'mcp-resource://server/file.txt'\n\t\t\t];\n\n\t\t\tconst actualUriStrings = uriDetails.map(uri => uri.toString());\n\t\t\tassert.deepStrictEqual(actualUriStrings.sort(), expectedUris.sort(), 'Should contain exactly the expected successful URIs');\n\n\t\t\t// Verify content array matches input order (including failures)\n\t\t\tassert.strictEqual(result.content.length, 6, 'Content should have result for each input URL');\n\t\t\tassert.strictEqual(result.content[0].value, 'Content 1', 'First web URI content');\n\t\t\tassert.strictEqual(result.content[1].value, 'Invalid URL', 'Invalid URL marked as invalid');\n\t\t\tassert.strictEqual(result.content[2].value, 'File content', 'File URI content');\n\t\t\tassert.strictEqual(result.content[3].value, 'Content 2', 'Second web URI content');\n\t\t\tassert.strictEqual(result.content[4].value, 'Invalid URL', 'Nonexistent file marked as invalid');\n\t\t\tassert.strictEqual(result.content[5].value, 'MCP content', 'MCP resource content');\n\t\t});\n\n\t\ttest('should exclude failed web requests from toolResultDetails', async () => {\n\t\t\t// Set up web content extractor that will throw for some URIs\n\t\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t\t[URI.parse('https://success.com'), 'Success content']\n\t\t\t\t// https://failure.com not in map - will throw error\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService([]),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst testUrls = [\n\t\t\t\t'https://success.com',  // Should succeed\n\t\t\t\t'https://failure.com'   // Should fail (not in content map)\n\t\t\t];\n\n\t\t\ttry {\n\t\t\t\tawait tool.invoke(\n\t\t\t\t\t{ callId: 'test-web-failure', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t\t{ report: () => { } },\n\t\t\t\t\tCancellationToken.None\n\t\t\t\t);\n\n\t\t\t\t// If the web extractor throws, it should be handled gracefully\n\t\t\t\t// But in this test setup, the TestWebContentExtractorService throws for missing content\n\t\t\t\tassert.fail('Expected test web content extractor to throw for missing URI');\n\t\t\t} catch (error) {\n\t\t\t\t// This is expected behavior with the current test setup\n\t\t\t\t// The TestWebContentExtractorService throws when content is not found\n\t\t\t\tassert.ok(error.message.includes('No content configured for URI'), 'Should throw for unconfigured URI');\n\t\t\t}\n\t\t});\n\n\t\ttest('should exclude failed file reads from toolResultDetails', async () => {\n\t\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t\t[URI.parse('file:///existing.txt'), 'File exists']\n\t\t\t\t// file:///missing.txt not in map - will throw error\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst testUrls = [\n\t\t\t\t'file:///existing.txt',  // Should succeed\n\t\t\t\t'file:///missing.txt'    // Should fail (not in file map)\n\t\t\t];\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-file-failure', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\t// Verify only successful file URI is in toolResultDetails\n\t\t\tassert.ok(Array.isArray(result.toolResultDetails), 'toolResultDetails should be an array');\n\t\t\tassert.strictEqual(result.toolResultDetails.length, 1, 'Should have only 1 successful URI');\n\n\t\t\tconst uriDetails = result.toolResultDetails as URI[];\n\t\t\tassert.strictEqual(uriDetails[0].toString(), 'file:///existing.txt', 'Should contain only the successful file URI');\n\n\t\t\t// Verify content reflects both attempts\n\t\t\tassert.strictEqual(result.content.length, 2, 'Should have results for both input URLs');\n\t\t\tassert.strictEqual(result.content[0].value, 'File exists', 'First file should have content');\n\t\t\tassert.strictEqual(result.content[1].value, 'Invalid URL', 'Second file should be marked invalid');\n\t\t});\n\n\t\ttest('should handle mixed success and failure scenarios', async () => {\n\t\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t\t[URI.parse('https://web-success.com'), 'Web success']\n\t\t\t]);\n\n\t\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t\t[URI.parse('file:///file-success.txt'), 'File success'],\n\t\t\t\t[URI.parse('mcp-resource://good/file.txt'), VSBuffer.fromString('MCP binary content')]\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst testUrls = [\n\t\t\t\t'invalid-scheme://bad',      // Invalid URI\n\t\t\t\t'https://web-success.com',   // Web success\n\t\t\t\t'file:///file-missing.txt',  // File failure\n\t\t\t\t'file:///file-success.txt',  // File success\n\t\t\t\t'completely-invalid-url',    // Invalid URL format\n\t\t\t\t'mcp-resource://good/file.txt' // MCP success\n\t\t\t];\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-mixed', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\t// Should have 3 successful URIs: web-success, file-success, mcp-success\n\t\t\tassert.ok(Array.isArray(result.toolResultDetails), 'toolResultDetails should be an array');\n\t\t\tassert.strictEqual((result.toolResultDetails as URI[]).length, 3, 'Should have 3 successful URIs');\n\n\t\t\tconst uriDetails = result.toolResultDetails as URI[];\n\t\t\tconst actualUriStrings = uriDetails.map(uri => uri.toString());\n\t\t\tconst expectedSuccessful = [\n\t\t\t\t'https://web-success.com/',\n\t\t\t\t'file:///file-success.txt',\n\t\t\t\t'mcp-resource://good/file.txt'\n\t\t\t];\n\n\t\t\tassert.deepStrictEqual(actualUriStrings.sort(), expectedSuccessful.sort(), 'Should contain exactly the successful URIs');\n\n\t\t\t// Verify content array reflects all inputs in original order\n\t\t\tassert.strictEqual(result.content.length, 6, 'Should have results for all input URLs');\n\t\t\tassert.strictEqual(result.content[0].value, 'Invalid URL', 'Invalid scheme marked as invalid');\n\t\t\tassert.strictEqual(result.content[1].value, 'Web success', 'Web success content');\n\t\t\tassert.strictEqual(result.content[2].value, 'Invalid URL', 'Missing file marked as invalid');\n\t\t\tassert.strictEqual(result.content[3].value, 'File success', 'File success content');\n\t\t\tassert.strictEqual(result.content[4].value, 'Invalid URL', 'Invalid URL marked as invalid');\n\t\t\tassert.strictEqual(result.content[5].value, 'MCP binary content', 'MCP success content');\n\t\t});\n\n\t\ttest('should return empty toolResultDetails when all requests fail', async () => {\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()), // Empty - all web requests fail\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()), // Empty - all file ,\n\t\t\t\tnew MockTrustedDomainService([]),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst testUrls = [\n\t\t\t\t'https://nonexistent.com',\n\t\t\t\t'file:///missing.txt',\n\t\t\t\t'invalid-url',\n\t\t\t\t'bad://scheme'\n\t\t\t];\n\n\t\t\ttry {\n\t\t\t\tconst result = await tool.invoke(\n\t\t\t\t\t{ callId: 'test-all-fail', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t\t{ report: () => { } },\n\t\t\t\t\tCancellationToken.None\n\t\t\t\t);\n\n\t\t\t\t// If web extractor doesn't throw, check the results\n\t\t\t\tassert.ok(Array.isArray(result.toolResultDetails), 'toolResultDetails should be an array');\n\t\t\t\tassert.strictEqual((result.toolResultDetails as URI[]).length, 0, 'Should have no successful URIs');\n\t\t\t\tassert.strictEqual(result.content.length, 4, 'Should have results for all input URLs');\n\t\t\t\tassert.ok(result.content.every(content => content.value === 'Invalid URL'), 'All content should be marked as invalid');\n\t\t\t} catch (error) {\n\t\t\t\t// Expected with TestWebContentExtractorService when no content is configured\n\t\t\t\tassert.ok(error.message.includes('No content configured for URI'), 'Should throw for unconfigured URI');\n\t\t\t}\n\t\t});\n\n\t\ttest('should handle empty URL array', async () => {\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService([]),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-empty', toolId: 'fetch-page', parameters: { urls: [] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\tassert.strictEqual(result.content.length, 1, 'Should have one content item for empty URLs');\n\t\t\tassert.strictEqual(result.content[0].value, 'No valid URLs provided.', 'Should indicate no valid URLs');\n\t\t\tassert.ok(!result.toolResultDetails, 'toolResultDetails should not be present for empty URLs');\n\t\t});\n\n\t\ttest('should handle image files in toolResultDetails', async () => {\n\t\t\tconst imageBuffer = VSBuffer.fromString('fake-png-data');\n\t\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t\t[URI.parse('file:///image.png'), imageBuffer],\n\t\t\t\t[URI.parse('file:///document.txt'), 'Text content']\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-images', toolId: 'fetch-page', parameters: { urls: ['file:///image.png', 'file:///document.txt'] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\t// Both files should be successful and in toolResultDetails\n\t\t\tassert.ok(Array.isArray(result.toolResultDetails), 'toolResultDetails should be an array');\n\t\t\tassert.strictEqual((result.toolResultDetails as URI[]).length, 2, 'Should have 2 successful file URIs');\n\n\t\t\tconst uriDetails = result.toolResultDetails as URI[];\n\t\t\tassert.strictEqual(uriDetails[0].toString(), 'file:///image.png', 'Should include image file');\n\t\t\tassert.strictEqual(uriDetails[1].toString(), 'file:///document.txt', 'Should include text file');\n\n\t\t\t// Check content types\n\t\t\tassert.strictEqual(result.content[0].kind, 'data', 'Image should be data part');\n\t\t\tassert.strictEqual(result.content[1].kind, 'text', 'Text file should be text part');\n\t\t});\n\n\t\ttest('confirmResults is false when all web contents are errors or redirects', async () => {\n\t\t\tconst webContentMap = new ResourceMap<string>();\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew class extends TestWebContentExtractorService {\n\t\t\t\t\tconstructor() {\n\t\t\t\t\t\tsuper(webContentMap);\n\t\t\t\t\t}\n\t\t\t\t\toverride async extract(uris: URI[]): Promise<WebContentExtractResult[]> {\n\t\t\t\t\t\treturn uris.map(() => ({ status: 'error', error: 'Failed to fetch' }));\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-call', toolId: 'fetch-page', parameters: { urls: ['https://example.com'] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\tassert.strictEqual(result.confirmResults, false, 'confirmResults should be false when all results are errors');\n\t\t});\n\n\t\ttest('confirmResults is false when all web contents are redirects', async () => {\n\t\t\tconst webContentMap = new ResourceMap<string>();\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew class extends TestWebContentExtractorService {\n\t\t\t\t\tconstructor() {\n\t\t\t\t\t\tsuper(webContentMap);\n\t\t\t\t\t}\n\t\t\t\t\toverride async extract(uris: URI[]): Promise<WebContentExtractResult[]> {\n\t\t\t\t\t\treturn uris.map(() => ({ status: 'redirect', toURI: URI.parse('https://redirected.com') }));\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-call', toolId: 'fetch-page', parameters: { urls: ['https://example.com'] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\tassert.strictEqual(result.confirmResults, false, 'confirmResults should be false when all results are redirects');\n\t\t});\n\n\t\ttest('confirmResults is undefined when at least one web content succeeds', async () => {\n\t\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t\t[URI.parse('https://success.com'), 'Success content']\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew class extends TestWebContentExtractorService {\n\t\t\t\t\tconstructor() {\n\t\t\t\t\t\tsuper(webContentMap);\n\t\t\t\t\t}\n\t\t\t\t\toverride async extract(uris: URI[]): Promise<WebContentExtractResult[]> {\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{ status: 'ok', result: 'Success content' },\n\t\t\t\t\t\t\t{ status: 'error', error: 'Failed' }\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-call', toolId: 'fetch-page', parameters: { urls: ['https://success.com', 'https://error.com'] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\tassert.strictEqual(result.confirmResults, undefined, 'confirmResults should be undefined when at least one result succeeds');\n\t\t});\n\n\t\ttest('redirect result provides correct message with new URL', async () => {\n\t\t\tconst redirectURI = URI.parse('https://redirected.com/page');\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew class extends TestWebContentExtractorService {\n\t\t\t\t\tconstructor() {\n\t\t\t\t\t\tsuper(new ResourceMap<string>());\n\t\t\t\t\t}\n\t\t\t\t\toverride async extract(uris: URI[]): Promise<WebContentExtractResult[]> {\n\t\t\t\t\t\treturn [{ status: 'redirect', toURI: redirectURI }];\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-call', toolId: 'fetch-page', parameters: { urls: ['https://example.com'] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\tassert.strictEqual(result.content.length, 1);\n\t\t\tassert.strictEqual(result.content[0].kind, 'text');\n\t\t\tif (result.content[0].kind === 'text') {\n\t\t\t\tassert.ok(result.content[0].value.includes(redirectURI.toString(true)), 'Redirect message should include target URL');\n\t\t\t\tassert.ok(result.content[0].value.includes(InternalFetchWebPageToolId), 'Redirect message should suggest using tool again');\n\t\t\t}\n\t\t});\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { VSBuffer } from '../../../../../base/common/buffer.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { ResourceMap } from '../../../../../base/common/map.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { IFileContent, IReadFileOptions } from '../../../../../platform/files/common/files.js';\nimport { IWebContentExtractorService, WebContentExtractResult } from '../../../../../platform/webContentExtractor/common/webContentExtractor.js';\nimport { FetchWebPageTool } from '../../electron-browser/tools/fetchPageTool.js';\nimport { TestFileService } from '../../../../test/common/workbenchTestServices.js';\nimport { MockTrustedDomainService } from '../../../url/test/browser/mockTrustedDomainService.js';\nimport { InternalFetchWebPageToolId } from '../../common/tools/tools.js';\nimport { MockChatService } from '../common/mockChatService.js';\nimport { upcastDeepPartial } from '../../../../../base/test/common/mock.js';\nimport { IChatService } from '../../common/chatService.js';\n\nclass TestWebContentExtractorService implements IWebContentExtractorService {\n\t_serviceBrand: undefined;\n\n\tconstructor(private uriToContentMap: ResourceMap<string>) { }\n\n\tasync extract(uris: URI[]): Promise<WebContentExtractResult[]> {\n\t\treturn uris.map(uri => {\n\t\t\tconst content = this.uriToContentMap.get(uri);\n\t\t\tif (content === undefined) {\n\t\t\t\tthrow new Error(`No content configured for URI: ${uri.toString()}`);\n\t\t\t}\n\t\t\treturn { status: 'ok', result: content };\n\t\t});\n\t}\n}\n\nclass ExtendedTestFileService extends TestFileService {\n\tconstructor(private uriToContentMap: ResourceMap<string | VSBuffer>) {\n\t\tsuper();\n\t}\n\n\toverride async readFile(resource: URI, options?: IReadFileOptions | undefined): Promise<IFileContent> {\n\t\tconst content = this.uriToContentMap.get(resource);\n\t\tif (content === undefined) {\n\t\t\tthrow new Error(`File not found: ${resource.toString()}`);\n\t\t}\n\n\t\tconst buffer = typeof content === 'string' ? VSBuffer.fromString(content) : content;\n\t\treturn {\n\t\t\tresource,\n\t\t\tvalue: buffer,\n\t\t\tname: '',\n\t\t\tsize: buffer.byteLength,\n\t\t\tetag: '',\n\t\t\tmtime: 0,\n\t\t\tctime: 0,\n\t\t\treadonly: false,\n\t\t\tlocked: false\n\t\t};\n\t}\n\n\toverride async stat(resource: URI) {\n\t\t// Check if the resource exists in our map\n\t\tif (!this.uriToContentMap.has(resource)) {\n\t\t\tthrow new Error(`File not found: ${resource.toString()}`);\n\t\t}\n\n\t\treturn super.stat(resource);\n\t}\n}\n\nsuite('FetchWebPageTool', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('should handle http/https via web content extractor and other schemes via file service', async () => {\n\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t[URI.parse('https://example.com'), 'HTTPS content'],\n\t\t\t[URI.parse('http://example.com'), 'HTTP content']\n\t\t]);\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('test://static/resource/50'), 'MCP resource content'],\n\t\t\t[URI.parse('mcp-resource://746573742D736572766572/custom/hello/world.txt'), 'Custom MCP content']\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst testUrls = [\n\t\t\t'https://example.com',\n\t\t\t'http://example.com',\n\t\t\t'test://static/resource/50',\n\t\t\t'mcp-resource://746573742D736572766572/custom/hello/world.txt',\n\t\t\t'file:///path/to/nonexistent',\n\t\t\t'ftp://example.com',\n\t\t\t'invalid-url'\n\t\t];\n\n\t\tconst result = await tool.invoke(\n\t\t\t{ callId: 'test-call-1', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Should have 7 results (one for each input URL)\n\t\tassert.strictEqual(result.content.length, 7, 'Should have result for each input URL');\n\n\t\t// HTTP and HTTPS URLs should have their content from web extractor\n\t\tassert.strictEqual(result.content[0].value, 'HTTPS content', 'HTTPS URL should return content');\n\t\tassert.strictEqual(result.content[1].value, 'HTTP content', 'HTTP URL should return content');\n\n\t\t// MCP resources should have their content from file service\n\t\tassert.strictEqual(result.content[2].value, 'MCP resource content', 'test:// URL should return content from file service');\n\t\tassert.strictEqual(result.content[3].value, 'Custom MCP content', 'mcp-resource:// URL should return content from file service');\n\n\t\t// Nonexistent file should be marked as invalid\n\t\tassert.strictEqual(result.content[4].value, 'Invalid URL', 'Nonexistent file should be invalid');\n\n\t\t// Unsupported scheme (ftp) should be marked as invalid since file service can't handle it\n\t\tassert.strictEqual(result.content[5].value, 'Invalid URL', 'ftp:// URL should be invalid');\n\n\t\t// Invalid URL should be marked as invalid\n\t\tassert.strictEqual(result.content[6].value, 'Invalid URL', 'Invalid URL should be invalid');\n\n\t\t// All successfully fetched URLs should be in toolResultDetails\n\t\tassert.strictEqual(Array.isArray(result.toolResultDetails) ? result.toolResultDetails.length : 0, 4, 'Should have 4 valid URLs in toolResultDetails');\n\t});\n\n\ttest('should handle empty and undefined URLs', async () => {\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\tnew MockTrustedDomainService([]),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\t// Test empty array\n\t\tconst emptyResult = await tool.invoke(\n\t\t\t{ callId: 'test-call-2', toolId: 'fetch-page', parameters: { urls: [] }, context: undefined },\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(emptyResult.content.length, 1, 'Empty array should return single message');\n\t\tassert.strictEqual(emptyResult.content[0].value, 'No valid URLs provided.', 'Should indicate no valid URLs');\n\n\t\t// Test undefined\n\t\tconst undefinedResult = await tool.invoke(\n\t\t\t{ callId: 'test-call-3', toolId: 'fetch-page', parameters: {}, context: undefined },\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(undefinedResult.content.length, 1, 'Undefined URLs should return single message');\n\t\tassert.strictEqual(undefinedResult.content[0].value, 'No valid URLs provided.', 'Should indicate no valid URLs');\n\n\t\t// Test array with invalid URLs\n\t\tconst invalidResult = await tool.invoke(\n\t\t\t{ callId: 'test-call-4', toolId: 'fetch-page', parameters: { urls: ['', ' ', 'invalid-scheme-that-fileservice-cannot-handle://test'] }, context: undefined },\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\t\tassert.strictEqual(invalidResult.content.length, 3, 'Should have result for each invalid URL');\n\t\tassert.strictEqual(invalidResult.content[0].value, 'Invalid URL', 'Empty string should be invalid');\n\t\tassert.strictEqual(invalidResult.content[1].value, 'Invalid URL', 'Space-only string should be invalid');\n\t\tassert.strictEqual(invalidResult.content[2].value, 'Invalid URL', 'Unhandleable scheme should be invalid');\n\t});\n\n\ttest('should provide correct past tense messages for mixed valid/invalid URLs', async () => {\n\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t[URI.parse('https://valid.com'), 'Valid content']\n\t\t]);\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('test://valid/resource'), 'Valid MCP content']\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst preparation = await tool.prepareToolInvocation(\n\t\t\t{ parameters: { urls: ['https://valid.com', 'test://valid/resource', 'invalid://invalid'] } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\tassert.ok(preparation, 'Should return prepared invocation');\n\t\tassert.ok(preparation.pastTenseMessage, 'Should have past tense message');\n\t\tconst messageText = typeof preparation.pastTenseMessage === 'string' ? preparation.pastTenseMessage : preparation.pastTenseMessage!.value;\n\t\tassert.ok(messageText.includes('Fetched'), 'Should mention fetched resources');\n\t\tassert.ok(messageText.includes('invalid://invalid'), 'Should mention invalid URL');\n\t});\n\n\ttest('should approve when all URLs were mentioned in chat', async () => {\n\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t[URI.parse('https://valid.com'), 'Valid content']\n\t\t]);\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('test://valid/resource'), 'Valid MCP content']\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tupcastDeepPartial<IChatService>({\n\t\t\t\tgetSession: () => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tgetRequests: () => [{\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttext: 'fetch https://example.com'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}],\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\n\t\tconst preparation1 = await tool.prepareToolInvocation(\n\t\t\t{ parameters: { urls: ['https://example.com'] }, chatSessionId: 'a' },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\tassert.ok(preparation1, 'Should return prepared invocation');\n\t\tassert.strictEqual(preparation1.confirmationMessages?.title, undefined);\n\n\t\tconst preparation2 = await tool.prepareToolInvocation(\n\t\t\t{ parameters: { urls: ['https://other.com'] }, chatSessionId: 'a' },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\tassert.ok(preparation2, 'Should return prepared invocation');\n\t\tassert.ok(preparation2.confirmationMessages?.title);\n\t});\n\n\ttest('should return message for binary files indicating they are not supported', async () => {\n\t\t// Create binary content (a simple PNG-like header with null bytes)\n\t\tconst binaryContent = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D]);\n\t\tconst binaryBuffer = VSBuffer.wrap(binaryContent);\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('file:///path/to/binary.dat'), binaryBuffer],\n\t\t\t[URI.parse('file:///path/to/text.txt'), 'This is text content']\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-call-binary',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///path/to/binary.dat', 'file:///path/to/text.txt'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Should have 2 results\n\t\tassert.strictEqual(result.content.length, 2, 'Should have 2 results');\n\n\t\t// First result should be a text part with binary not supported message\n\t\tassert.strictEqual(result.content[0].kind, 'text', 'Binary file should return text part');\n\t\tif (result.content[0].kind === 'text') {\n\t\t\tassert.strictEqual(result.content[0].value, 'Binary files are not supported at the moment.', 'Should return not supported message');\n\t\t}\n\n\t\t// Second result should be a text part for the text file\n\t\tassert.strictEqual(result.content[1].kind, 'text', 'Text file should return text part');\n\t\tif (result.content[1].kind === 'text') {\n\t\t\tassert.strictEqual(result.content[1].value, 'This is text content', 'Should return text content');\n\t\t}\n\n\t\t// Both files should be in toolResultDetails since they were successfully fetched\n\t\tassert.strictEqual(Array.isArray(result.toolResultDetails) ? result.toolResultDetails.length : 0, 2, 'Should have 2 valid URLs in toolResultDetails');\n\t});\n\n\ttest('PNG files are now supported as image data parts (regression test)', async () => {\n\t\t// This test ensures that PNG files that previously returned \"not supported\"\n\t\t// messages now return proper image data parts\n\t\tconst binaryContent = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D]);\n\t\tconst binaryBuffer = VSBuffer.wrap(binaryContent);\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('file:///path/to/image.png'), binaryBuffer]\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-png-support',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///path/to/image.png'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Should have 1 result\n\t\tassert.strictEqual(result.content.length, 1, 'Should have 1 result');\n\n\t\t// PNG file should now be returned as a data part, not a \"not supported\" message\n\t\tassert.strictEqual(result.content[0].kind, 'data', 'PNG file should return data part');\n\t\tif (result.content[0].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[0].value.mimeType, 'image/png', 'Should have PNG MIME type');\n\t\t\tassert.strictEqual(result.content[0].value.data, binaryBuffer, 'Should have correct binary data');\n\t\t}\n\t});\n\n\ttest('should correctly distinguish between binary and text content', async () => {\n\t\t// Create content that might be ambiguous\n\t\tconst jsonData = '{\"name\": \"test\", \"value\": 123}';\n\t\t// Create definitely binary data - some random bytes with null bytes that don't follow UTF-16 pattern\n\t\tconst realBinaryData = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x00, 0x00, 0x00, 0x0D, 0xFF, 0x00, 0xAB]); // More clearly binary\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t[URI.parse('file:///data.json'), jsonData], // Should be detected as text\n\t\t\t[URI.parse('file:///binary.dat'), VSBuffer.wrap(realBinaryData)] // Should be detected as binary\n\t\t]);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-distinguish',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///data.json', 'file:///binary.dat'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// JSON should be returned as text\n\t\tassert.strictEqual(result.content[0].kind, 'text', 'JSON should be detected as text');\n\t\tif (result.content[0].kind === 'text') {\n\t\t\tassert.strictEqual(result.content[0].value, jsonData, 'Should return JSON as text');\n\t\t}\n\n\t\t// Binary data should be returned as not supported message\n\t\tassert.strictEqual(result.content[1].kind, 'text', 'Binary content should return text part with message');\n\t\tif (result.content[1].kind === 'text') {\n\t\t\tassert.strictEqual(result.content[1].value, 'Binary files are not supported at the moment.', 'Should return not supported message');\n\t\t}\n\t});\n\n\ttest('Supported image files are returned as data parts', async () => {\n\t\t// Test data for different supported image formats\n\t\tconst pngData = VSBuffer.fromString('fake PNG data');\n\t\tconst jpegData = VSBuffer.fromString('fake JPEG data');\n\t\tconst gifData = VSBuffer.fromString('fake GIF data');\n\t\tconst webpData = VSBuffer.fromString('fake WebP data');\n\t\tconst bmpData = VSBuffer.fromString('fake BMP data');\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>();\n\t\tfileContentMap.set(URI.parse('file:///image.png'), pngData);\n\t\tfileContentMap.set(URI.parse('file:///photo.jpg'), jpegData);\n\t\tfileContentMap.set(URI.parse('file:///animation.gif'), gifData);\n\t\tfileContentMap.set(URI.parse('file:///modern.webp'), webpData);\n\t\tfileContentMap.set(URI.parse('file:///bitmap.bmp'), bmpData);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-images',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///image.png', 'file:///photo.jpg', 'file:///animation.gif', 'file:///modern.webp', 'file:///bitmap.bmp'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// All images should be returned as data parts\n\t\tassert.strictEqual(result.content.length, 5, 'Should have 5 results');\n\n\t\t// Check PNG\n\t\tassert.strictEqual(result.content[0].kind, 'data', 'PNG should be data part');\n\t\tif (result.content[0].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[0].value.mimeType, 'image/png', 'PNG should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[0].value.data, pngData, 'PNG should have correct data');\n\t\t}\n\n\t\t// Check JPEG\n\t\tassert.strictEqual(result.content[1].kind, 'data', 'JPEG should be data part');\n\t\tif (result.content[1].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[1].value.mimeType, 'image/jpeg', 'JPEG should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[1].value.data, jpegData, 'JPEG should have correct data');\n\t\t}\n\n\t\t// Check GIF\n\t\tassert.strictEqual(result.content[2].kind, 'data', 'GIF should be data part');\n\t\tif (result.content[2].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[2].value.mimeType, 'image/gif', 'GIF should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[2].value.data, gifData, 'GIF should have correct data');\n\t\t}\n\n\t\t// Check WebP\n\t\tassert.strictEqual(result.content[3].kind, 'data', 'WebP should be data part');\n\t\tif (result.content[3].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[3].value.mimeType, 'image/webp', 'WebP should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[3].value.data, webpData, 'WebP should have correct data');\n\t\t}\n\n\t\t// Check BMP\n\t\tassert.strictEqual(result.content[4].kind, 'data', 'BMP should be data part');\n\t\tif (result.content[4].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[4].value.mimeType, 'image/bmp', 'BMP should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[4].value.data, bmpData, 'BMP should have correct data');\n\t\t}\n\t});\n\n\ttest('Mixed image and text files work correctly', async () => {\n\t\tconst textData = 'This is some text content';\n\t\tconst imageData = VSBuffer.fromString('fake image data');\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>();\n\t\tfileContentMap.set(URI.parse('file:///text.txt'), textData);\n\t\tfileContentMap.set(URI.parse('file:///image.png'), imageData);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-mixed',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///text.txt', 'file:///image.png'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Text should be returned as text part\n\t\tassert.strictEqual(result.content[0].kind, 'text', 'Text file should be text part');\n\t\tif (result.content[0].kind === 'text') {\n\t\t\tassert.strictEqual(result.content[0].value, textData, 'Text should have correct content');\n\t\t}\n\n\t\t// Image should be returned as data part\n\t\tassert.strictEqual(result.content[1].kind, 'data', 'Image file should be data part');\n\t\tif (result.content[1].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[1].value.mimeType, 'image/png', 'Image should have correct MIME type');\n\t\t\tassert.strictEqual(result.content[1].value.data, imageData, 'Image should have correct data');\n\t\t}\n\t});\n\n\ttest('Case insensitive image extensions work', async () => {\n\t\tconst imageData = VSBuffer.fromString('fake image data');\n\n\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>();\n\t\tfileContentMap.set(URI.parse('file:///image.PNG'), imageData);\n\t\tfileContentMap.set(URI.parse('file:///photo.JPEG'), imageData);\n\n\t\tconst tool = new FetchWebPageTool(\n\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\tnew MockTrustedDomainService(),\n\t\t\tnew MockChatService(),\n\t\t);\n\n\t\tconst result = await tool.invoke(\n\t\t\t{\n\t\t\t\tcallId: 'test-case',\n\t\t\t\ttoolId: 'fetch-page',\n\t\t\t\tparameters: { urls: ['file:///image.PNG', 'file:///photo.JPEG'] },\n\t\t\t\tcontext: undefined\n\t\t\t},\n\t\t\t() => Promise.resolve(0),\n\t\t\t{ report: () => { } },\n\t\t\tCancellationToken.None\n\t\t);\n\n\t\t// Both should be returned as data parts despite uppercase extensions\n\t\tassert.strictEqual(result.content[0].kind, 'data', 'PNG with uppercase extension should be data part');\n\t\tif (result.content[0].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[0].value.mimeType, 'image/png', 'Should have correct MIME type');\n\t\t}\n\n\t\tassert.strictEqual(result.content[1].kind, 'data', 'JPEG with uppercase extension should be data part');\n\t\tif (result.content[1].kind === 'data') {\n\t\t\tassert.strictEqual(result.content[1].value.mimeType, 'image/jpeg', 'Should have correct MIME type');\n\t\t}\n\t});\n\n\t// Comprehensive tests for toolResultDetails\n\tsuite('toolResultDetails', () => {\n\t\ttest('should include only successfully fetched URIs in correct order', async () => {\n\t\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t\t[URI.parse('https://success1.com'), 'Content 1'],\n\t\t\t\t[URI.parse('https://success2.com'), 'Content 2']\n\t\t\t]);\n\n\t\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t\t[URI.parse('file:///success.txt'), 'File content'],\n\t\t\t\t[URI.parse('mcp-resource://server/file.txt'), 'MCP content']\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst testUrls = [\n\t\t\t\t'https://success1.com',       // index 0 - should be in toolResultDetails\n\t\t\t\t'invalid-url',                // index 1 - should NOT be in toolResultDetails\n\t\t\t\t'file:///success.txt',        // index 2 - should be in toolResultDetails\n\t\t\t\t'https://success2.com',       // index 3 - should be in toolResultDetails\n\t\t\t\t'file:///nonexistent.txt',    // index 4 - should NOT be in toolResultDetails\n\t\t\t\t'mcp-resource://server/file.txt' // index 5 - should be in toolResultDetails\n\t\t\t];\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-details', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\t// Verify toolResultDetails contains exactly the successful URIs\n\t\t\tassert.ok(Array.isArray(result.toolResultDetails), 'toolResultDetails should be an array');\n\t\t\tassert.strictEqual(result.toolResultDetails.length, 4, 'Should have 4 successful URIs');\n\n\t\t\t// Check that all entries are URI objects\n\t\t\tconst uriDetails = result.toolResultDetails as URI[];\n\t\t\tassert.ok(uriDetails.every(uri => uri instanceof URI), 'All toolResultDetails entries should be URI objects');\n\n\t\t\t// Check specific URIs are included (web URIs first, then successful file URIs)\n\t\t\tconst expectedUris = [\n\t\t\t\t'https://success1.com/',\n\t\t\t\t'https://success2.com/',\n\t\t\t\t'file:///success.txt',\n\t\t\t\t'mcp-resource://server/file.txt'\n\t\t\t];\n\n\t\t\tconst actualUriStrings = uriDetails.map(uri => uri.toString());\n\t\t\tassert.deepStrictEqual(actualUriStrings.sort(), expectedUris.sort(), 'Should contain exactly the expected successful URIs');\n\n\t\t\t// Verify content array matches input order (including failures)\n\t\t\tassert.strictEqual(result.content.length, 6, 'Content should have result for each input URL');\n\t\t\tassert.strictEqual(result.content[0].value, 'Content 1', 'First web URI content');\n\t\t\tassert.strictEqual(result.content[1].value, 'Invalid URL', 'Invalid URL marked as invalid');\n\t\t\tassert.strictEqual(result.content[2].value, 'File content', 'File URI content');\n\t\t\tassert.strictEqual(result.content[3].value, 'Content 2', 'Second web URI content');\n\t\t\tassert.strictEqual(result.content[4].value, 'Invalid URL', 'Nonexistent file marked as invalid');\n\t\t\tassert.strictEqual(result.content[5].value, 'MCP content', 'MCP resource content');\n\t\t});\n\n\t\ttest('should exclude failed web requests from toolResultDetails', async () => {\n\t\t\t// Set up web content extractor that will throw for some URIs\n\t\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t\t[URI.parse('https://success.com'), 'Success content']\n\t\t\t\t// https://failure.com not in map - will throw error\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService([]),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst testUrls = [\n\t\t\t\t'https://success.com',  // Should succeed\n\t\t\t\t'https://failure.com'   // Should fail (not in content map)\n\t\t\t];\n\n\t\t\ttry {\n\t\t\t\tawait tool.invoke(\n\t\t\t\t\t{ callId: 'test-web-failure', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t\t{ report: () => { } },\n\t\t\t\t\tCancellationToken.None\n\t\t\t\t);\n\n\t\t\t\t// If the web extractor throws, it should be handled gracefully\n\t\t\t\t// But in this test setup, the TestWebContentExtractorService throws for missing content\n\t\t\t\tassert.fail('Expected test web content extractor to throw for missing URI');\n\t\t\t} catch (error) {\n\t\t\t\t// This is expected behavior with the current test setup\n\t\t\t\t// The TestWebContentExtractorService throws when content is not found\n\t\t\t\tassert.ok(error.message.includes('No content configured for URI'), 'Should throw for unconfigured URI');\n\t\t\t}\n\t\t});\n\n\t\ttest('should exclude failed file reads from toolResultDetails', async () => {\n\t\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t\t[URI.parse('file:///existing.txt'), 'File exists']\n\t\t\t\t// file:///missing.txt not in map - will throw error\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst testUrls = [\n\t\t\t\t'file:///existing.txt',  // Should succeed\n\t\t\t\t'file:///missing.txt'    // Should fail (not in file map)\n\t\t\t];\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-file-failure', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\t// Verify only successful file URI is in toolResultDetails\n\t\t\tassert.ok(Array.isArray(result.toolResultDetails), 'toolResultDetails should be an array');\n\t\t\tassert.strictEqual(result.toolResultDetails.length, 1, 'Should have only 1 successful URI');\n\n\t\t\tconst uriDetails = result.toolResultDetails as URI[];\n\t\t\tassert.strictEqual(uriDetails[0].toString(), 'file:///existing.txt', 'Should contain only the successful file URI');\n\n\t\t\t// Verify content reflects both attempts\n\t\t\tassert.strictEqual(result.content.length, 2, 'Should have results for both input URLs');\n\t\t\tassert.strictEqual(result.content[0].value, 'File exists', 'First file should have content');\n\t\t\tassert.strictEqual(result.content[1].value, 'Invalid URL', 'Second file should be marked invalid');\n\t\t});\n\n\t\ttest('should handle mixed success and failure scenarios', async () => {\n\t\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t\t[URI.parse('https://web-success.com'), 'Web success']\n\t\t\t]);\n\n\t\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t\t[URI.parse('file:///file-success.txt'), 'File success'],\n\t\t\t\t[URI.parse('mcp-resource://good/file.txt'), VSBuffer.fromString('MCP binary content')]\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(webContentMap),\n\t\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst testUrls = [\n\t\t\t\t'invalid-scheme://bad',      // Invalid URI\n\t\t\t\t'https://web-success.com',   // Web success\n\t\t\t\t'file:///file-missing.txt',  // File failure\n\t\t\t\t'file:///file-success.txt',  // File success\n\t\t\t\t'completely-invalid-url',    // Invalid URL format\n\t\t\t\t'mcp-resource://good/file.txt' // MCP success\n\t\t\t];\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-mixed', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\t// Should have 3 successful URIs: web-success, file-success, mcp-success\n\t\t\tassert.ok(Array.isArray(result.toolResultDetails), 'toolResultDetails should be an array');\n\t\t\tassert.strictEqual((result.toolResultDetails as URI[]).length, 3, 'Should have 3 successful URIs');\n\n\t\t\tconst uriDetails = result.toolResultDetails as URI[];\n\t\t\tconst actualUriStrings = uriDetails.map(uri => uri.toString());\n\t\t\tconst expectedSuccessful = [\n\t\t\t\t'https://web-success.com/',\n\t\t\t\t'file:///file-success.txt',\n\t\t\t\t'mcp-resource://good/file.txt'\n\t\t\t];\n\n\t\t\tassert.deepStrictEqual(actualUriStrings.sort(), expectedSuccessful.sort(), 'Should contain exactly the successful URIs');\n\n\t\t\t// Verify content array reflects all inputs in original order\n\t\t\tassert.strictEqual(result.content.length, 6, 'Should have results for all input URLs');\n\t\t\tassert.strictEqual(result.content[0].value, 'Invalid URL', 'Invalid scheme marked as invalid');\n\t\t\tassert.strictEqual(result.content[1].value, 'Web success', 'Web success content');\n\t\t\tassert.strictEqual(result.content[2].value, 'Invalid URL', 'Missing file marked as invalid');\n\t\t\tassert.strictEqual(result.content[3].value, 'File success', 'File success content');\n\t\t\tassert.strictEqual(result.content[4].value, 'Invalid URL', 'Invalid URL marked as invalid');\n\t\t\tassert.strictEqual(result.content[5].value, 'MCP binary content', 'MCP success content');\n\t\t});\n\n\t\ttest('should return empty toolResultDetails when all requests fail', async () => {\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()), // Empty - all web requests fail\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()), // Empty - all file ,\n\t\t\t\tnew MockTrustedDomainService([]),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst testUrls = [\n\t\t\t\t'https://nonexistent.com',\n\t\t\t\t'file:///missing.txt',\n\t\t\t\t'invalid-url',\n\t\t\t\t'bad://scheme'\n\t\t\t];\n\n\t\t\ttry {\n\t\t\t\tconst result = await tool.invoke(\n\t\t\t\t\t{ callId: 'test-all-fail', toolId: 'fetch-page', parameters: { urls: testUrls }, context: undefined },\n\t\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t\t{ report: () => { } },\n\t\t\t\t\tCancellationToken.None\n\t\t\t\t);\n\n\t\t\t\t// If web extractor doesn't throw, check the results\n\t\t\t\tassert.ok(Array.isArray(result.toolResultDetails), 'toolResultDetails should be an array');\n\t\t\t\tassert.strictEqual((result.toolResultDetails as URI[]).length, 0, 'Should have no successful URIs');\n\t\t\t\tassert.strictEqual(result.content.length, 4, 'Should have results for all input URLs');\n\t\t\t\tassert.ok(result.content.every(content => content.value === 'Invalid URL'), 'All content should be marked as invalid');\n\t\t\t} catch (error) {\n\t\t\t\t// Expected with TestWebContentExtractorService when no content is configured\n\t\t\t\tassert.ok(error.message.includes('No content configured for URI'), 'Should throw for unconfigured URI');\n\t\t\t}\n\t\t});\n\n\t\ttest('should handle empty URL array', async () => {\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService([]),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-empty', toolId: 'fetch-page', parameters: { urls: [] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\tassert.strictEqual(result.content.length, 1, 'Should have one content item for empty URLs');\n\t\t\tassert.strictEqual(result.content[0].value, 'No valid URLs provided.', 'Should indicate no valid URLs');\n\t\t\tassert.ok(!result.toolResultDetails, 'toolResultDetails should not be present for empty URLs');\n\t\t});\n\n\t\ttest('should handle image files in toolResultDetails', async () => {\n\t\t\tconst imageBuffer = VSBuffer.fromString('fake-png-data');\n\t\t\tconst fileContentMap = new ResourceMap<string | VSBuffer>([\n\t\t\t\t[URI.parse('file:///image.png'), imageBuffer],\n\t\t\t\t[URI.parse('file:///document.txt'), 'Text content']\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew TestWebContentExtractorService(new ResourceMap<string>()),\n\t\t\t\tnew ExtendedTestFileService(fileContentMap),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-images', toolId: 'fetch-page', parameters: { urls: ['file:///image.png', 'file:///document.txt'] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\t// Both files should be successful and in toolResultDetails\n\t\t\tassert.ok(Array.isArray(result.toolResultDetails), 'toolResultDetails should be an array');\n\t\t\tassert.strictEqual((result.toolResultDetails as URI[]).length, 2, 'Should have 2 successful file URIs');\n\n\t\t\tconst uriDetails = result.toolResultDetails as URI[];\n\t\t\tassert.strictEqual(uriDetails[0].toString(), 'file:///image.png', 'Should include image file');\n\t\t\tassert.strictEqual(uriDetails[1].toString(), 'file:///document.txt', 'Should include text file');\n\n\t\t\t// Check content types\n\t\t\tassert.strictEqual(result.content[0].kind, 'data', 'Image should be data part');\n\t\t\tassert.strictEqual(result.content[1].kind, 'text', 'Text file should be text part');\n\t\t});\n\n\t\ttest('confirmResults is false when all web contents are errors or redirects', async () => {\n\t\t\tconst webContentMap = new ResourceMap<string>();\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew class extends TestWebContentExtractorService {\n\t\t\t\t\tconstructor() {\n\t\t\t\t\t\tsuper(webContentMap);\n\t\t\t\t\t}\n\t\t\t\t\toverride async extract(uris: URI[]): Promise<WebContentExtractResult[]> {\n\t\t\t\t\t\treturn uris.map(() => ({ status: 'error', error: 'Failed to fetch' }));\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-call', toolId: 'fetch-page', parameters: { urls: ['https://example.com'] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\tassert.strictEqual(result.confirmResults, false, 'confirmResults should be false when all results are errors');\n\t\t});\n\n\t\ttest('confirmResults is false when all web contents are redirects', async () => {\n\t\t\tconst webContentMap = new ResourceMap<string>();\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew class extends TestWebContentExtractorService {\n\t\t\t\t\tconstructor() {\n\t\t\t\t\t\tsuper(webContentMap);\n\t\t\t\t\t}\n\t\t\t\t\toverride async extract(uris: URI[]): Promise<WebContentExtractResult[]> {\n\t\t\t\t\t\treturn uris.map(() => ({ status: 'redirect', toURI: URI.parse('https://redirected.com') }));\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-call', toolId: 'fetch-page', parameters: { urls: ['https://example.com'] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\tassert.strictEqual(result.confirmResults, false, 'confirmResults should be false when all results are redirects');\n\t\t});\n\n\t\ttest('confirmResults is undefined when at least one web content succeeds', async () => {\n\t\t\tconst webContentMap = new ResourceMap<string>([\n\t\t\t\t[URI.parse('https://success.com'), 'Success content']\n\t\t\t]);\n\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew class extends TestWebContentExtractorService {\n\t\t\t\t\tconstructor() {\n\t\t\t\t\t\tsuper(webContentMap);\n\t\t\t\t\t}\n\t\t\t\t\toverride async extract(uris: URI[]): Promise<WebContentExtractResult[]> {\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{ status: 'ok', result: 'Success content' },\n\t\t\t\t\t\t\t{ status: 'error', error: 'Failed' }\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-call', toolId: 'fetch-page', parameters: { urls: ['https://success.com', 'https://error.com'] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\tassert.strictEqual(result.confirmResults, undefined, 'confirmResults should be undefined when at least one result succeeds');\n\t\t});\n\n\t\ttest('redirect result provides correct message with new URL', async () => {\n\t\t\tconst redirectURI = URI.parse('https://redirected.com/page');\n\t\t\tconst tool = new FetchWebPageTool(\n\t\t\t\tnew class extends TestWebContentExtractorService {\n\t\t\t\t\tconstructor() {\n\t\t\t\t\t\tsuper(new ResourceMap<string>());\n\t\t\t\t\t}\n\t\t\t\t\toverride async extract(uris: URI[]): Promise<WebContentExtractResult[]> {\n\t\t\t\t\t\treturn [{ status: 'redirect', toURI: redirectURI }];\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tnew ExtendedTestFileService(new ResourceMap<string | VSBuffer>()),\n\t\t\t\tnew MockTrustedDomainService(),\n\t\t\t\tnew MockChatService(),\n\t\t\t);\n\n\t\t\tconst result = await tool.invoke(\n\t\t\t\t{ callId: 'test-call', toolId: 'fetch-page', parameters: { urls: ['https://example.com'] }, context: undefined },\n\t\t\t\t() => Promise.resolve(0),\n\t\t\t\t{ report: () => { } },\n\t\t\t\tCancellationToken.None\n\t\t\t);\n\n\t\t\tassert.strictEqual(result.content.length, 1);\n\t\t\tassert.strictEqual(result.content[0].kind, 'text');\n\t\t\tif (result.content[0].kind === 'text') {\n\t\t\t\tassert.ok(result.content[0].value.includes(redirectURI.toString(true)), 'Redirect message should include target URL');\n\t\t\t\tassert.ok(result.content[0].value.includes(InternalFetchWebPageToolId), 'Redirect message should suggest using tool again');\n\t\t\t}\n\t\t});\n\t});\n});\n"]}