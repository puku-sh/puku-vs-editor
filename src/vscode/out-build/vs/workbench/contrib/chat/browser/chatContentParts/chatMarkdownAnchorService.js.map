{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/browser/chatContentParts/chatMarkdownAnchorService.ts","vs/workbench/contrib/chat/browser/chatContentParts/chatMarkdownAnchorService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,qBAAqB,EAAE,eAAe,EAAE,MAAM,oCAAoC,CAAC;AAC5F,OAAO,EAAE,UAAU,EAAe,kBAAkB,EAAE,YAAY,EAAE,MAAM,yCAAyC,CAAC;AACpH,OAAO,EAAE,eAAe,EAAE,MAAM,+DAA+D,CAAC;AAIhG,MAAM,CAAC,MAAM,0BAA0B,GAAG,eAAe,CAA6B,2BAA2B,CAAC,CAAC;AAcnH,MAAM,OAAO,yBAA0B,SAAQ,UAAU;IAAzD;;QAIS,aAAQ,GAAyB,EAAE,CAAC;QACpC,uBAAkB,GAAmC,SAAS,CAAC;IAmCxE,CAAC;IAjCA,IAAI,iBAAiB;QACpB,OAAO,IAAI,CAAC,kBAAkB,CAAC;IAChC,CAAC;IAEO,kBAAkB,CAAC,MAAsC;QAChE,IAAI,CAAC,kBAAkB,GAAG,MAAM,CAAC;IAClC,CAAC;IAED,QAAQ,CAAC,MAA0B;QAClC,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,KAAK,MAAM,CAAC,EAAE,CAAC;YACnD,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;QACnE,CAAC;QAED,yBAAyB;QACzB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAE3B,MAAM,OAAO,GAAG,MAAM,CAAC,cAAc,EAAE,CAAC;QAExC,oCAAoC;QACpC,IAAI,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC;YAC9B,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;QACjC,CAAC;QAED,OAAO,kBAAkB,CACxB,qBAAqB,CAAC,OAAO,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC,EAC9E,YAAY,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,EAC1E,qBAAqB,CAAC,OAAO,EAAE,MAAM,EAAE,GAAG,EAAE;YAC3C,IAAI,IAAI,CAAC,kBAAkB,KAAK,MAAM,EAAE,CAAC;gBACxC,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;YACpC,CAAC;QACF,CAAC,CAAC,CACF,CAAC;IACH,CAAC;CACD","file":"chatMarkdownAnchorService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { addDisposableListener, isActiveElement } from '../../../../../base/browser/dom.js';\nimport { Disposable, IDisposable, combinedDisposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { createDecorator } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { InlineAnchorWidget } from '../chatInlineAnchorWidget.js';\n\n\nexport const IChatMarkdownAnchorService = createDecorator<IChatMarkdownAnchorService>('chatMarkdownAnchorService');\n\nexport interface IChatMarkdownAnchorService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Returns the currently focused anchor if any\n\t */\n\treadonly lastFocusedAnchor: InlineAnchorWidget | undefined;\n\n\tregister(widget: InlineAnchorWidget): IDisposable;\n}\n\nexport class ChatMarkdownAnchorService extends Disposable implements IChatMarkdownAnchorService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _widgets: InlineAnchorWidget[] = [];\n\tprivate _lastFocusedWidget: InlineAnchorWidget | undefined = undefined;\n\n\tget lastFocusedAnchor(): InlineAnchorWidget | undefined {\n\t\treturn this._lastFocusedWidget;\n\t}\n\n\tprivate setLastFocusedList(widget: InlineAnchorWidget | undefined): void {\n\t\tthis._lastFocusedWidget = widget;\n\t}\n\n\tregister(widget: InlineAnchorWidget): IDisposable {\n\t\tif (this._widgets.some(other => other === widget)) {\n\t\t\tthrow new Error('Cannot register the same widget multiple times');\n\t\t}\n\n\t\t// Keep in our lists list\n\t\tthis._widgets.push(widget);\n\n\t\tconst element = widget.getHTMLElement();\n\n\t\t// Check for currently being focused\n\t\tif (isActiveElement(element)) {\n\t\t\tthis.setLastFocusedList(widget);\n\t\t}\n\n\t\treturn combinedDisposable(\n\t\t\taddDisposableListener(element, 'focus', () => this.setLastFocusedList(widget)),\n\t\t\ttoDisposable(() => this._widgets.splice(this._widgets.indexOf(widget), 1)),\n\t\t\taddDisposableListener(element, 'blur', () => {\n\t\t\t\tif (this._lastFocusedWidget === widget) {\n\t\t\t\t\tthis.setLastFocusedList(undefined);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { addDisposableListener, isActiveElement } from '../../../../../base/browser/dom.js';\nimport { Disposable, IDisposable, combinedDisposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { createDecorator } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { InlineAnchorWidget } from '../chatInlineAnchorWidget.js';\n\n\nexport const IChatMarkdownAnchorService = createDecorator<IChatMarkdownAnchorService>('chatMarkdownAnchorService');\n\nexport interface IChatMarkdownAnchorService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Returns the currently focused anchor if any\n\t */\n\treadonly lastFocusedAnchor: InlineAnchorWidget | undefined;\n\n\tregister(widget: InlineAnchorWidget): IDisposable;\n}\n\nexport class ChatMarkdownAnchorService extends Disposable implements IChatMarkdownAnchorService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _widgets: InlineAnchorWidget[] = [];\n\tprivate _lastFocusedWidget: InlineAnchorWidget | undefined = undefined;\n\n\tget lastFocusedAnchor(): InlineAnchorWidget | undefined {\n\t\treturn this._lastFocusedWidget;\n\t}\n\n\tprivate setLastFocusedList(widget: InlineAnchorWidget | undefined): void {\n\t\tthis._lastFocusedWidget = widget;\n\t}\n\n\tregister(widget: InlineAnchorWidget): IDisposable {\n\t\tif (this._widgets.some(other => other === widget)) {\n\t\t\tthrow new Error('Cannot register the same widget multiple times');\n\t\t}\n\n\t\t// Keep in our lists list\n\t\tthis._widgets.push(widget);\n\n\t\tconst element = widget.getHTMLElement();\n\n\t\t// Check for currently being focused\n\t\tif (isActiveElement(element)) {\n\t\t\tthis.setLastFocusedList(widget);\n\t\t}\n\n\t\treturn combinedDisposable(\n\t\t\taddDisposableListener(element, 'focus', () => this.setLastFocusedList(widget)),\n\t\t\ttoDisposable(() => this._widgets.splice(this._widgets.indexOf(widget), 1)),\n\t\t\taddDisposableListener(element, 'blur', () => {\n\t\t\t\tif (this._lastFocusedWidget === widget) {\n\t\t\t\t\tthis.setLastFocusedList(undefined);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t}\n}\n"]}