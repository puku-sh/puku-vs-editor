{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/browser/chatEditing/notebook/helpers.ts","vs/workbench/contrib/chat/browser/chatEditing/notebook/helpers.ts"],"names":[],"mappings":"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","file":"helpers.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { NotebookTextModel } from '../../../../notebook/common/model/notebookTextModel.js';\nimport { CellEditType, ICell, ICellDto2, ICellEditOperation, ICellReplaceEdit, NotebookCellsChangeType, NotebookCellsModelMoveEvent, NotebookCellTextModelSplice, NotebookTextModelChangedEvent } from '../../../../notebook/common/notebookCommon.js';\nimport { ICellDiffInfo, sortCellChanges } from './notebookCellChanges.js';\n\n\nexport function adjustCellDiffForKeepingADeletedCell(originalCellIndex: number,\n\tcellDiffInfo: ICellDiffInfo[],\n\tapplyEdits: typeof NotebookTextModel.prototype.applyEdits,\n): ICellDiffInfo[] {\n\t// Delete this cell from original as well.\n\tconst edit: ICellReplaceEdit = { cells: [], count: 1, editType: CellEditType.Replace, index: originalCellIndex, };\n\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\tconst diffs = sortCellChanges(cellDiffInfo)\n\t\t.filter(d => !(d.type === 'delete' && d.originalCellIndex === originalCellIndex))\n\t\t.map(diff => {\n\t\t\tif (diff.type !== 'insert' && diff.originalCellIndex > originalCellIndex) {\n\t\t\t\treturn {\n\t\t\t\t\t...diff,\n\t\t\t\t\toriginalCellIndex: diff.originalCellIndex - 1,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn diff;\n\t\t});\n\treturn diffs;\n}\n\nexport function adjustCellDiffForRevertingADeletedCell(originalCellIndex: number,\n\tcellDiffInfo: ICellDiffInfo[],\n\tcellToInsert: ICellDto2,\n\tapplyEdits: typeof NotebookTextModel.prototype.applyEdits,\n\tcreateModifiedCellDiffInfo: (modifiedCellIndex: number, originalCellIndex: number) => ICellDiffInfo,\n): ICellDiffInfo[] {\n\tcellDiffInfo = sortCellChanges(cellDiffInfo);\n\tconst indexOfEntry = cellDiffInfo.findIndex(d => d.originalCellIndex === originalCellIndex);\n\tif (indexOfEntry === -1) {\n\t\t// Not possible.\n\t\treturn cellDiffInfo;\n\t}\n\n\tlet modifiedCellIndex = -1;\n\tfor (let i = 0; i < cellDiffInfo.length; i++) {\n\t\tconst diff = cellDiffInfo[i];\n\t\tif (i < indexOfEntry) {\n\t\t\tmodifiedCellIndex = Math.max(modifiedCellIndex, diff.modifiedCellIndex ?? modifiedCellIndex);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i === indexOfEntry) {\n\t\t\tconst edit: ICellReplaceEdit = { cells: [cellToInsert], count: 0, editType: CellEditType.Replace, index: modifiedCellIndex + 1, };\n\t\t\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\t\t\tcellDiffInfo[i] = createModifiedCellDiffInfo(modifiedCellIndex + 1, originalCellIndex);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t// Increase the original index for all entries after this.\n\t\t\tif (typeof diff.modifiedCellIndex === 'number') {\n\t\t\t\tdiff.modifiedCellIndex++;\n\t\t\t\tcellDiffInfo[i] = { ...diff };\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cellDiffInfo;\n}\n\nexport function adjustCellDiffForRevertingAnInsertedCell(modifiedCellIndex: number,\n\tcellDiffInfo: ICellDiffInfo[],\n\tapplyEdits: typeof NotebookTextModel.prototype.applyEdits,\n): ICellDiffInfo[] {\n\tif (modifiedCellIndex === -1) {\n\t\t// Not possible.\n\t\treturn cellDiffInfo;\n\t}\n\tcellDiffInfo = sortCellChanges(cellDiffInfo)\n\t\t.filter(d => !(d.type === 'insert' && d.modifiedCellIndex === modifiedCellIndex))\n\t\t.map(d => {\n\t\t\tif (d.type === 'insert' && d.modifiedCellIndex === modifiedCellIndex) {\n\t\t\t\treturn d;\n\t\t\t}\n\t\t\tif (d.type !== 'delete' && d.modifiedCellIndex > modifiedCellIndex) {\n\t\t\t\treturn {\n\t\t\t\t\t...d,\n\t\t\t\t\tmodifiedCellIndex: d.modifiedCellIndex - 1,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn d;\n\t\t});\n\tconst edit: ICellReplaceEdit = { cells: [], count: 1, editType: CellEditType.Replace, index: modifiedCellIndex, };\n\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\treturn cellDiffInfo;\n}\n\nexport function adjustCellDiffForKeepingAnInsertedCell(modifiedCellIndex: number,\n\tcellDiffInfo: ICellDiffInfo[],\n\tcellToInsert: ICellDto2,\n\tapplyEdits: typeof NotebookTextModel.prototype.applyEdits,\n\tcreateModifiedCellDiffInfo: (modifiedCellIndex: number, originalCellIndex: number) => ICellDiffInfo,\n): ICellDiffInfo[] {\n\tcellDiffInfo = sortCellChanges(cellDiffInfo);\n\tif (modifiedCellIndex === -1) {\n\t\t// Not possible.\n\t\treturn cellDiffInfo;\n\t}\n\tconst indexOfEntry = cellDiffInfo.findIndex(d => d.modifiedCellIndex === modifiedCellIndex);\n\tif (indexOfEntry === -1) {\n\t\t// Not possible.\n\t\treturn cellDiffInfo;\n\t}\n\tlet originalCellIndex = -1;\n\tfor (let i = 0; i < cellDiffInfo.length; i++) {\n\t\tconst diff = cellDiffInfo[i];\n\t\tif (i < indexOfEntry) {\n\t\t\toriginalCellIndex = Math.max(originalCellIndex, diff.originalCellIndex ?? originalCellIndex);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i === indexOfEntry) {\n\t\t\tconst edit: ICellReplaceEdit = { cells: [cellToInsert], count: 0, editType: CellEditType.Replace, index: originalCellIndex + 1 };\n\t\t\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\t\t\tcellDiffInfo[i] = createModifiedCellDiffInfo(modifiedCellIndex, originalCellIndex + 1);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t// Increase the original index for all entries after this.\n\t\t\tif (typeof diff.originalCellIndex === 'number') {\n\t\t\t\tdiff.originalCellIndex++;\n\t\t\t\tcellDiffInfo[i] = { ...diff };\n\t\t\t}\n\t\t}\n\t}\n\treturn cellDiffInfo;\n}\n\nexport function adjustCellDiffAndOriginalModelBasedOnCellAddDelete(change: NotebookCellTextModelSplice<ICell>,\n\tcellDiffInfo: ICellDiffInfo[],\n\tmodifiedModelCellCount: number,\n\toriginalModelCellCount: number,\n\tapplyEdits: typeof NotebookTextModel.prototype.applyEdits,\n\tcreateModifiedCellDiffInfo: (modifiedCellIndex: number, originalCellIndex: number) => ICellDiffInfo,\n): ICellDiffInfo[] {\n\tcellDiffInfo = sortCellChanges(cellDiffInfo);\n\tconst numberOfCellsInserted = change[2].length;\n\tconst numberOfCellsDeleted = change[1];\n\tconst cells = change[2].map(cell => {\n\t\treturn {\n\t\t\tcellKind: cell.cellKind,\n\t\t\tlanguage: cell.language,\n\t\t\tmetadata: cell.metadata,\n\t\t\toutputs: cell.outputs,\n\t\t\tsource: cell.getValue(),\n\t\t\tmime: undefined,\n\t\t\tinternalMetadata: cell.internalMetadata\n\t\t} satisfies ICellDto2;\n\t});\n\tlet diffEntryIndex = -1;\n\tlet indexToInsertInOriginalModel: number | undefined = undefined;\n\tif (cells.length) {\n\t\tfor (let i = 0; i < cellDiffInfo.length; i++) {\n\t\t\tconst diff = cellDiffInfo[i];\n\t\t\tif (typeof diff.modifiedCellIndex === 'number' && diff.modifiedCellIndex === change[0]) {\n\t\t\t\tdiffEntryIndex = i;\n\n\t\t\t\tif (typeof diff.originalCellIndex === 'number') {\n\t\t\t\t\tindexToInsertInOriginalModel = diff.originalCellIndex;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (typeof diff.originalCellIndex === 'number') {\n\t\t\t\tindexToInsertInOriginalModel = diff.originalCellIndex + 1;\n\t\t\t}\n\t\t}\n\n\t\tconst edit: ICellEditOperation = {\n\t\t\teditType: CellEditType.Replace,\n\t\t\tcells,\n\t\t\tindex: indexToInsertInOriginalModel ?? 0,\n\t\t\tcount: change[1]\n\t\t};\n\t\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\t}\n\t// If cells were deleted we handled that with this.disposeDeletedCellEntries();\n\tif (numberOfCellsDeleted) {\n\t\t// Adjust the indexes.\n\t\tlet numberOfOriginalCellsRemovedSoFar = 0;\n\t\tlet numberOfModifiedCellsRemovedSoFar = 0;\n\t\tconst modifiedIndexesToRemove = new Set<number>();\n\t\tfor (let i = 0; i < numberOfCellsDeleted; i++) {\n\t\t\tmodifiedIndexesToRemove.add(change[0] + i);\n\t\t}\n\t\tconst itemsToRemove = new Set<ICellDiffInfo>();\n\t\tfor (let i = 0; i < cellDiffInfo.length; i++) {\n\t\t\tconst diff = cellDiffInfo[i];\n\t\t\tif (i < diffEntryIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet changed = false;\n\t\t\tif (typeof diff.modifiedCellIndex === 'number' && modifiedIndexesToRemove.has(diff.modifiedCellIndex)) {\n\t\t\t\t// This will be removed.\n\t\t\t\tnumberOfModifiedCellsRemovedSoFar++;\n\t\t\t\tif (typeof diff.originalCellIndex === 'number') {\n\t\t\t\t\tnumberOfOriginalCellsRemovedSoFar++;\n\t\t\t\t}\n\t\t\t\titemsToRemove.add(diff);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof diff.modifiedCellIndex === 'number' && numberOfModifiedCellsRemovedSoFar) {\n\t\t\t\tdiff.modifiedCellIndex -= numberOfModifiedCellsRemovedSoFar;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (typeof diff.originalCellIndex === 'number' && numberOfOriginalCellsRemovedSoFar) {\n\t\t\t\tdiff.originalCellIndex -= numberOfOriginalCellsRemovedSoFar;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (changed) {\n\t\t\t\tcellDiffInfo[i] = { ...diff };\n\t\t\t}\n\t\t}\n\t\tif (itemsToRemove.size) {\n\t\t\tArray.from(itemsToRemove)\n\t\t\t\t.filter(diff => typeof diff.originalCellIndex === 'number')\n\t\t\t\t.forEach(diff => {\n\t\t\t\t\tconst edit: ICellEditOperation = {\n\t\t\t\t\t\teditType: CellEditType.Replace,\n\t\t\t\t\t\tcells: [],\n\t\t\t\t\t\tindex: diff.originalCellIndex,\n\t\t\t\t\t\tcount: 1\n\t\t\t\t\t};\n\t\t\t\t\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\t\t\t\t});\n\t\t}\n\t\tcellDiffInfo = cellDiffInfo.filter(d => !itemsToRemove.has(d));\n\t}\n\n\tif (numberOfCellsInserted && diffEntryIndex >= 0) {\n\t\tfor (let i = 0; i < cellDiffInfo.length; i++) {\n\t\t\tconst diff = cellDiffInfo[i];\n\t\t\tif (i < diffEntryIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet changed = false;\n\t\t\tif (typeof diff.modifiedCellIndex === 'number') {\n\t\t\t\tdiff.modifiedCellIndex += numberOfCellsInserted;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (typeof diff.originalCellIndex === 'number') {\n\t\t\t\tdiff.originalCellIndex += numberOfCellsInserted;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (changed) {\n\t\t\t\tcellDiffInfo[i] = { ...diff };\n\t\t\t}\n\t\t}\n\t}\n\n\t// For inserted cells, we need to ensure that we create a corresponding CellEntry.\n\t// So that any edits to the inserted cell is handled and mirrored over to the corresponding cell in original model.\n\tcells.forEach((_, i) => {\n\t\tconst originalCellIndex = i + (indexToInsertInOriginalModel ?? 0);\n\t\tconst modifiedCellIndex = change[0] + i;\n\t\tconst unchangedCell = createModifiedCellDiffInfo(modifiedCellIndex, originalCellIndex);\n\t\tcellDiffInfo.splice((diffEntryIndex === -1 ? cellDiffInfo.length : diffEntryIndex) + i, 0, unchangedCell);\n\t});\n\treturn cellDiffInfo;\n}\n\n/**\n * Given the movements of cells in modified notebook, adjust the ICellDiffInfo[] array\n * and generate edits for the old notebook (if required).\n * TODO@DonJayamanne Handle bulk moves (movements of more than 1 cell).\n */\nexport function adjustCellDiffAndOriginalModelBasedOnCellMovements(event: NotebookCellsModelMoveEvent<ICell>, cellDiffInfo: ICellDiffInfo[]): [ICellDiffInfo[], ICellEditOperation[]] | undefined {\n\tconst minimumIndex = Math.min(event.index, event.newIdx);\n\tconst maximumIndex = Math.max(event.index, event.newIdx);\n\tconst cellDiffs = cellDiffInfo.slice();\n\tconst indexOfEntry = cellDiffs.findIndex(d => d.modifiedCellIndex === event.index);\n\tconst indexOfEntryToPlaceBelow = cellDiffs.findIndex(d => d.modifiedCellIndex === event.newIdx);\n\tif (indexOfEntry === -1 || indexOfEntryToPlaceBelow === -1) {\n\t\treturn undefined;\n\t}\n\t// Create a new object so that the observable value is triggered.\n\t// Besides we'll be updating the values of this object in place.\n\tconst entryToBeMoved = { ...cellDiffs[indexOfEntry] };\n\tconst moveDirection = event.newIdx > event.index ? 'down' : 'up';\n\n\n\tconst startIndex = cellDiffs.findIndex(d => d.modifiedCellIndex === minimumIndex);\n\tconst endIndex = cellDiffs.findIndex(d => d.modifiedCellIndex === maximumIndex);\n\tconst movingExistingCell = typeof entryToBeMoved.originalCellIndex === 'number';\n\tlet originalCellsWereEffected = false;\n\tfor (let i = 0; i < cellDiffs.length; i++) {\n\t\tconst diff = cellDiffs[i];\n\t\tlet changed = false;\n\t\tif (moveDirection === 'down') {\n\t\t\tif (i > startIndex && i <= endIndex) {\n\t\t\t\tif (typeof diff.modifiedCellIndex === 'number') {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tdiff.modifiedCellIndex = diff.modifiedCellIndex - 1;\n\t\t\t\t}\n\t\t\t\tif (typeof diff.originalCellIndex === 'number' && movingExistingCell) {\n\t\t\t\t\tdiff.originalCellIndex = diff.originalCellIndex - 1;\n\t\t\t\t\toriginalCellsWereEffected = true;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (i >= startIndex && i < endIndex) {\n\t\t\t\tif (typeof diff.modifiedCellIndex === 'number') {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tdiff.modifiedCellIndex = diff.modifiedCellIndex + 1;\n\t\t\t\t}\n\t\t\t\tif (typeof diff.originalCellIndex === 'number' && movingExistingCell) {\n\t\t\t\t\tdiff.originalCellIndex = diff.originalCellIndex + 1;\n\t\t\t\t\toriginalCellsWereEffected = true;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Create a new object so that the observable value is triggered.\n\t\t// Do only if there's a change.\n\t\tif (changed) {\n\t\t\tcellDiffs[i] = { ...diff };\n\t\t}\n\t}\n\tentryToBeMoved.modifiedCellIndex = event.newIdx;\n\tconst originalCellIndex = entryToBeMoved.originalCellIndex;\n\tif (moveDirection === 'down') {\n\t\tcellDiffs.splice(endIndex + 1, 0, entryToBeMoved);\n\t\tcellDiffs.splice(startIndex, 1);\n\t\t// If we're moving a new cell up/down, then we need just adjust just the modified indexes of the cells in between.\n\t\t// If we're moving an existing up/down, then we need to adjust the original indexes as well.\n\t\tif (typeof entryToBeMoved.originalCellIndex === 'number') {\n\t\t\tentryToBeMoved.originalCellIndex = cellDiffs.slice(0, endIndex).reduce((lastOriginalIndex, diff) => typeof diff.originalCellIndex === 'number' ? Math.max(lastOriginalIndex, diff.originalCellIndex) : lastOriginalIndex, -1) + 1;\n\t\t}\n\t} else {\n\t\tcellDiffs.splice(endIndex, 1);\n\t\tcellDiffs.splice(startIndex, 0, entryToBeMoved);\n\t\t// If we're moving a new cell up/down, then we need just adjust just the modified indexes of the cells in between.\n\t\t// If we're moving an existing up/down, then we need to adjust the original indexes as well.\n\t\tif (typeof entryToBeMoved.originalCellIndex === 'number') {\n\t\t\tentryToBeMoved.originalCellIndex = cellDiffs.slice(0, startIndex).reduce((lastOriginalIndex, diff) => typeof diff.originalCellIndex === 'number' ? Math.max(lastOriginalIndex, diff.originalCellIndex) : lastOriginalIndex, -1) + 1;\n\t\t}\n\t}\n\n\t// If this is a new cell that we're moving, and there are no existing cells in between, then we can just move the new cell.\n\t// I.e. no need to update the original notebook model.\n\tif (typeof entryToBeMoved.originalCellIndex === 'number' && originalCellsWereEffected && typeof originalCellIndex === 'number' && entryToBeMoved.originalCellIndex !== originalCellIndex) {\n\t\tconst edit: ICellEditOperation = {\n\t\t\teditType: CellEditType.Move,\n\t\t\tindex: originalCellIndex,\n\t\t\tlength: event.length,\n\t\t\tnewIdx: entryToBeMoved.originalCellIndex\n\t\t};\n\n\t\treturn [cellDiffs, [edit]];\n\t}\n\n\treturn [cellDiffs, []];\n}\n\nexport function getCorrespondingOriginalCellIndex(modifiedCellIndex: number, cellDiffInfo: ICellDiffInfo[]): number | undefined {\n\tconst entry = cellDiffInfo.find(d => d.modifiedCellIndex === modifiedCellIndex);\n\treturn entry?.originalCellIndex;\n}\n\n/**\n *\n * This isn't great, but necessary.\n * ipynb extension updates metadata when new cells are inserted (to ensure the metadata is correct)\n * Details of why thats required is in ipynb extension, but its necessary.\n * However as a result of this, those edits appear here and are assumed to be user edits.\n * As a result `_allEditsAreFromUs` is set to false.\n */\nexport function isTransientIPyNbExtensionEvent(notebookKind: string, e: NotebookTextModelChangedEvent) {\n\tif (notebookKind !== 'jupyter-notebook') {\n\t\treturn false;\n\t}\n\tif (e.rawEvents.every(event => {\n\t\tif (event.kind !== NotebookCellsChangeType.ChangeCellMetadata) {\n\t\t\treturn false;\n\t\t}\n\t\tif (JSON.stringify(event.metadata || {}) === JSON.stringify({ execution_count: null, metadata: {} })) {\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\n\t})) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nexport function calculateNotebookRewriteRatio(cellsDiff: ICellDiffInfo[], originalModel: NotebookTextModel, modifiedModel: NotebookTextModel): number {\n\tconst totalNumberOfUpdatedLines = cellsDiff.reduce((totalUpdatedLines, value) => {\n\t\tconst getUpadtedLineCount = () => {\n\t\t\tif (value.type === 'unchanged') {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (value.type === 'delete') {\n\t\t\t\treturn originalModel.cells[value.originalCellIndex].textModel?.getLineCount() ?? 0;\n\t\t\t}\n\t\t\tif (value.type === 'insert') {\n\t\t\t\treturn modifiedModel.cells[value.modifiedCellIndex].textModel?.getLineCount() ?? 0;\n\t\t\t}\n\t\t\treturn value.diff.get().changes.reduce((maxLineNumber, change) => {\n\t\t\t\treturn Math.max(maxLineNumber, change.modified.endLineNumberExclusive);\n\t\t\t}, 0);\n\t\t};\n\n\t\treturn totalUpdatedLines + getUpadtedLineCount();\n\t}, 0);\n\n\tconst totalNumberOfLines = modifiedModel.cells.reduce((totalLines, cell) => totalLines + (cell.textModel?.getLineCount() ?? 0), 0);\n\treturn totalNumberOfLines === 0 ? 0 : Math.min(1, totalNumberOfUpdatedLines / totalNumberOfLines);\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { NotebookTextModel } from '../../../../notebook/common/model/notebookTextModel.js';\nimport { CellEditType, ICell, ICellDto2, ICellEditOperation, ICellReplaceEdit, NotebookCellsChangeType, NotebookCellsModelMoveEvent, NotebookCellTextModelSplice, NotebookTextModelChangedEvent } from '../../../../notebook/common/notebookCommon.js';\nimport { ICellDiffInfo, sortCellChanges } from './notebookCellChanges.js';\n\n\nexport function adjustCellDiffForKeepingADeletedCell(originalCellIndex: number,\n\tcellDiffInfo: ICellDiffInfo[],\n\tapplyEdits: typeof NotebookTextModel.prototype.applyEdits,\n): ICellDiffInfo[] {\n\t// Delete this cell from original as well.\n\tconst edit: ICellReplaceEdit = { cells: [], count: 1, editType: CellEditType.Replace, index: originalCellIndex, };\n\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\tconst diffs = sortCellChanges(cellDiffInfo)\n\t\t.filter(d => !(d.type === 'delete' && d.originalCellIndex === originalCellIndex))\n\t\t.map(diff => {\n\t\t\tif (diff.type !== 'insert' && diff.originalCellIndex > originalCellIndex) {\n\t\t\t\treturn {\n\t\t\t\t\t...diff,\n\t\t\t\t\toriginalCellIndex: diff.originalCellIndex - 1,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn diff;\n\t\t});\n\treturn diffs;\n}\n\nexport function adjustCellDiffForRevertingADeletedCell(originalCellIndex: number,\n\tcellDiffInfo: ICellDiffInfo[],\n\tcellToInsert: ICellDto2,\n\tapplyEdits: typeof NotebookTextModel.prototype.applyEdits,\n\tcreateModifiedCellDiffInfo: (modifiedCellIndex: number, originalCellIndex: number) => ICellDiffInfo,\n): ICellDiffInfo[] {\n\tcellDiffInfo = sortCellChanges(cellDiffInfo);\n\tconst indexOfEntry = cellDiffInfo.findIndex(d => d.originalCellIndex === originalCellIndex);\n\tif (indexOfEntry === -1) {\n\t\t// Not possible.\n\t\treturn cellDiffInfo;\n\t}\n\n\tlet modifiedCellIndex = -1;\n\tfor (let i = 0; i < cellDiffInfo.length; i++) {\n\t\tconst diff = cellDiffInfo[i];\n\t\tif (i < indexOfEntry) {\n\t\t\tmodifiedCellIndex = Math.max(modifiedCellIndex, diff.modifiedCellIndex ?? modifiedCellIndex);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i === indexOfEntry) {\n\t\t\tconst edit: ICellReplaceEdit = { cells: [cellToInsert], count: 0, editType: CellEditType.Replace, index: modifiedCellIndex + 1, };\n\t\t\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\t\t\tcellDiffInfo[i] = createModifiedCellDiffInfo(modifiedCellIndex + 1, originalCellIndex);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t// Increase the original index for all entries after this.\n\t\t\tif (typeof diff.modifiedCellIndex === 'number') {\n\t\t\t\tdiff.modifiedCellIndex++;\n\t\t\t\tcellDiffInfo[i] = { ...diff };\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cellDiffInfo;\n}\n\nexport function adjustCellDiffForRevertingAnInsertedCell(modifiedCellIndex: number,\n\tcellDiffInfo: ICellDiffInfo[],\n\tapplyEdits: typeof NotebookTextModel.prototype.applyEdits,\n): ICellDiffInfo[] {\n\tif (modifiedCellIndex === -1) {\n\t\t// Not possible.\n\t\treturn cellDiffInfo;\n\t}\n\tcellDiffInfo = sortCellChanges(cellDiffInfo)\n\t\t.filter(d => !(d.type === 'insert' && d.modifiedCellIndex === modifiedCellIndex))\n\t\t.map(d => {\n\t\t\tif (d.type === 'insert' && d.modifiedCellIndex === modifiedCellIndex) {\n\t\t\t\treturn d;\n\t\t\t}\n\t\t\tif (d.type !== 'delete' && d.modifiedCellIndex > modifiedCellIndex) {\n\t\t\t\treturn {\n\t\t\t\t\t...d,\n\t\t\t\t\tmodifiedCellIndex: d.modifiedCellIndex - 1,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn d;\n\t\t});\n\tconst edit: ICellReplaceEdit = { cells: [], count: 1, editType: CellEditType.Replace, index: modifiedCellIndex, };\n\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\treturn cellDiffInfo;\n}\n\nexport function adjustCellDiffForKeepingAnInsertedCell(modifiedCellIndex: number,\n\tcellDiffInfo: ICellDiffInfo[],\n\tcellToInsert: ICellDto2,\n\tapplyEdits: typeof NotebookTextModel.prototype.applyEdits,\n\tcreateModifiedCellDiffInfo: (modifiedCellIndex: number, originalCellIndex: number) => ICellDiffInfo,\n): ICellDiffInfo[] {\n\tcellDiffInfo = sortCellChanges(cellDiffInfo);\n\tif (modifiedCellIndex === -1) {\n\t\t// Not possible.\n\t\treturn cellDiffInfo;\n\t}\n\tconst indexOfEntry = cellDiffInfo.findIndex(d => d.modifiedCellIndex === modifiedCellIndex);\n\tif (indexOfEntry === -1) {\n\t\t// Not possible.\n\t\treturn cellDiffInfo;\n\t}\n\tlet originalCellIndex = -1;\n\tfor (let i = 0; i < cellDiffInfo.length; i++) {\n\t\tconst diff = cellDiffInfo[i];\n\t\tif (i < indexOfEntry) {\n\t\t\toriginalCellIndex = Math.max(originalCellIndex, diff.originalCellIndex ?? originalCellIndex);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i === indexOfEntry) {\n\t\t\tconst edit: ICellReplaceEdit = { cells: [cellToInsert], count: 0, editType: CellEditType.Replace, index: originalCellIndex + 1 };\n\t\t\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\t\t\tcellDiffInfo[i] = createModifiedCellDiffInfo(modifiedCellIndex, originalCellIndex + 1);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t// Increase the original index for all entries after this.\n\t\t\tif (typeof diff.originalCellIndex === 'number') {\n\t\t\t\tdiff.originalCellIndex++;\n\t\t\t\tcellDiffInfo[i] = { ...diff };\n\t\t\t}\n\t\t}\n\t}\n\treturn cellDiffInfo;\n}\n\nexport function adjustCellDiffAndOriginalModelBasedOnCellAddDelete(change: NotebookCellTextModelSplice<ICell>,\n\tcellDiffInfo: ICellDiffInfo[],\n\tmodifiedModelCellCount: number,\n\toriginalModelCellCount: number,\n\tapplyEdits: typeof NotebookTextModel.prototype.applyEdits,\n\tcreateModifiedCellDiffInfo: (modifiedCellIndex: number, originalCellIndex: number) => ICellDiffInfo,\n): ICellDiffInfo[] {\n\tcellDiffInfo = sortCellChanges(cellDiffInfo);\n\tconst numberOfCellsInserted = change[2].length;\n\tconst numberOfCellsDeleted = change[1];\n\tconst cells = change[2].map(cell => {\n\t\treturn {\n\t\t\tcellKind: cell.cellKind,\n\t\t\tlanguage: cell.language,\n\t\t\tmetadata: cell.metadata,\n\t\t\toutputs: cell.outputs,\n\t\t\tsource: cell.getValue(),\n\t\t\tmime: undefined,\n\t\t\tinternalMetadata: cell.internalMetadata\n\t\t} satisfies ICellDto2;\n\t});\n\tlet diffEntryIndex = -1;\n\tlet indexToInsertInOriginalModel: number | undefined = undefined;\n\tif (cells.length) {\n\t\tfor (let i = 0; i < cellDiffInfo.length; i++) {\n\t\t\tconst diff = cellDiffInfo[i];\n\t\t\tif (typeof diff.modifiedCellIndex === 'number' && diff.modifiedCellIndex === change[0]) {\n\t\t\t\tdiffEntryIndex = i;\n\n\t\t\t\tif (typeof diff.originalCellIndex === 'number') {\n\t\t\t\t\tindexToInsertInOriginalModel = diff.originalCellIndex;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (typeof diff.originalCellIndex === 'number') {\n\t\t\t\tindexToInsertInOriginalModel = diff.originalCellIndex + 1;\n\t\t\t}\n\t\t}\n\n\t\tconst edit: ICellEditOperation = {\n\t\t\teditType: CellEditType.Replace,\n\t\t\tcells,\n\t\t\tindex: indexToInsertInOriginalModel ?? 0,\n\t\t\tcount: change[1]\n\t\t};\n\t\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\t}\n\t// If cells were deleted we handled that with this.disposeDeletedCellEntries();\n\tif (numberOfCellsDeleted) {\n\t\t// Adjust the indexes.\n\t\tlet numberOfOriginalCellsRemovedSoFar = 0;\n\t\tlet numberOfModifiedCellsRemovedSoFar = 0;\n\t\tconst modifiedIndexesToRemove = new Set<number>();\n\t\tfor (let i = 0; i < numberOfCellsDeleted; i++) {\n\t\t\tmodifiedIndexesToRemove.add(change[0] + i);\n\t\t}\n\t\tconst itemsToRemove = new Set<ICellDiffInfo>();\n\t\tfor (let i = 0; i < cellDiffInfo.length; i++) {\n\t\t\tconst diff = cellDiffInfo[i];\n\t\t\tif (i < diffEntryIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet changed = false;\n\t\t\tif (typeof diff.modifiedCellIndex === 'number' && modifiedIndexesToRemove.has(diff.modifiedCellIndex)) {\n\t\t\t\t// This will be removed.\n\t\t\t\tnumberOfModifiedCellsRemovedSoFar++;\n\t\t\t\tif (typeof diff.originalCellIndex === 'number') {\n\t\t\t\t\tnumberOfOriginalCellsRemovedSoFar++;\n\t\t\t\t}\n\t\t\t\titemsToRemove.add(diff);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof diff.modifiedCellIndex === 'number' && numberOfModifiedCellsRemovedSoFar) {\n\t\t\t\tdiff.modifiedCellIndex -= numberOfModifiedCellsRemovedSoFar;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (typeof diff.originalCellIndex === 'number' && numberOfOriginalCellsRemovedSoFar) {\n\t\t\t\tdiff.originalCellIndex -= numberOfOriginalCellsRemovedSoFar;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (changed) {\n\t\t\t\tcellDiffInfo[i] = { ...diff };\n\t\t\t}\n\t\t}\n\t\tif (itemsToRemove.size) {\n\t\t\tArray.from(itemsToRemove)\n\t\t\t\t.filter(diff => typeof diff.originalCellIndex === 'number')\n\t\t\t\t.forEach(diff => {\n\t\t\t\t\tconst edit: ICellEditOperation = {\n\t\t\t\t\t\teditType: CellEditType.Replace,\n\t\t\t\t\t\tcells: [],\n\t\t\t\t\t\tindex: diff.originalCellIndex,\n\t\t\t\t\t\tcount: 1\n\t\t\t\t\t};\n\t\t\t\t\tapplyEdits([edit], true, undefined, () => undefined, undefined, true);\n\t\t\t\t});\n\t\t}\n\t\tcellDiffInfo = cellDiffInfo.filter(d => !itemsToRemove.has(d));\n\t}\n\n\tif (numberOfCellsInserted && diffEntryIndex >= 0) {\n\t\tfor (let i = 0; i < cellDiffInfo.length; i++) {\n\t\t\tconst diff = cellDiffInfo[i];\n\t\t\tif (i < diffEntryIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet changed = false;\n\t\t\tif (typeof diff.modifiedCellIndex === 'number') {\n\t\t\t\tdiff.modifiedCellIndex += numberOfCellsInserted;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (typeof diff.originalCellIndex === 'number') {\n\t\t\t\tdiff.originalCellIndex += numberOfCellsInserted;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (changed) {\n\t\t\t\tcellDiffInfo[i] = { ...diff };\n\t\t\t}\n\t\t}\n\t}\n\n\t// For inserted cells, we need to ensure that we create a corresponding CellEntry.\n\t// So that any edits to the inserted cell is handled and mirrored over to the corresponding cell in original model.\n\tcells.forEach((_, i) => {\n\t\tconst originalCellIndex = i + (indexToInsertInOriginalModel ?? 0);\n\t\tconst modifiedCellIndex = change[0] + i;\n\t\tconst unchangedCell = createModifiedCellDiffInfo(modifiedCellIndex, originalCellIndex);\n\t\tcellDiffInfo.splice((diffEntryIndex === -1 ? cellDiffInfo.length : diffEntryIndex) + i, 0, unchangedCell);\n\t});\n\treturn cellDiffInfo;\n}\n\n/**\n * Given the movements of cells in modified notebook, adjust the ICellDiffInfo[] array\n * and generate edits for the old notebook (if required).\n * TODO@DonJayamanne Handle bulk moves (movements of more than 1 cell).\n */\nexport function adjustCellDiffAndOriginalModelBasedOnCellMovements(event: NotebookCellsModelMoveEvent<ICell>, cellDiffInfo: ICellDiffInfo[]): [ICellDiffInfo[], ICellEditOperation[]] | undefined {\n\tconst minimumIndex = Math.min(event.index, event.newIdx);\n\tconst maximumIndex = Math.max(event.index, event.newIdx);\n\tconst cellDiffs = cellDiffInfo.slice();\n\tconst indexOfEntry = cellDiffs.findIndex(d => d.modifiedCellIndex === event.index);\n\tconst indexOfEntryToPlaceBelow = cellDiffs.findIndex(d => d.modifiedCellIndex === event.newIdx);\n\tif (indexOfEntry === -1 || indexOfEntryToPlaceBelow === -1) {\n\t\treturn undefined;\n\t}\n\t// Create a new object so that the observable value is triggered.\n\t// Besides we'll be updating the values of this object in place.\n\tconst entryToBeMoved = { ...cellDiffs[indexOfEntry] };\n\tconst moveDirection = event.newIdx > event.index ? 'down' : 'up';\n\n\n\tconst startIndex = cellDiffs.findIndex(d => d.modifiedCellIndex === minimumIndex);\n\tconst endIndex = cellDiffs.findIndex(d => d.modifiedCellIndex === maximumIndex);\n\tconst movingExistingCell = typeof entryToBeMoved.originalCellIndex === 'number';\n\tlet originalCellsWereEffected = false;\n\tfor (let i = 0; i < cellDiffs.length; i++) {\n\t\tconst diff = cellDiffs[i];\n\t\tlet changed = false;\n\t\tif (moveDirection === 'down') {\n\t\t\tif (i > startIndex && i <= endIndex) {\n\t\t\t\tif (typeof diff.modifiedCellIndex === 'number') {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tdiff.modifiedCellIndex = diff.modifiedCellIndex - 1;\n\t\t\t\t}\n\t\t\t\tif (typeof diff.originalCellIndex === 'number' && movingExistingCell) {\n\t\t\t\t\tdiff.originalCellIndex = diff.originalCellIndex - 1;\n\t\t\t\t\toriginalCellsWereEffected = true;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (i >= startIndex && i < endIndex) {\n\t\t\t\tif (typeof diff.modifiedCellIndex === 'number') {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tdiff.modifiedCellIndex = diff.modifiedCellIndex + 1;\n\t\t\t\t}\n\t\t\t\tif (typeof diff.originalCellIndex === 'number' && movingExistingCell) {\n\t\t\t\t\tdiff.originalCellIndex = diff.originalCellIndex + 1;\n\t\t\t\t\toriginalCellsWereEffected = true;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Create a new object so that the observable value is triggered.\n\t\t// Do only if there's a change.\n\t\tif (changed) {\n\t\t\tcellDiffs[i] = { ...diff };\n\t\t}\n\t}\n\tentryToBeMoved.modifiedCellIndex = event.newIdx;\n\tconst originalCellIndex = entryToBeMoved.originalCellIndex;\n\tif (moveDirection === 'down') {\n\t\tcellDiffs.splice(endIndex + 1, 0, entryToBeMoved);\n\t\tcellDiffs.splice(startIndex, 1);\n\t\t// If we're moving a new cell up/down, then we need just adjust just the modified indexes of the cells in between.\n\t\t// If we're moving an existing up/down, then we need to adjust the original indexes as well.\n\t\tif (typeof entryToBeMoved.originalCellIndex === 'number') {\n\t\t\tentryToBeMoved.originalCellIndex = cellDiffs.slice(0, endIndex).reduce((lastOriginalIndex, diff) => typeof diff.originalCellIndex === 'number' ? Math.max(lastOriginalIndex, diff.originalCellIndex) : lastOriginalIndex, -1) + 1;\n\t\t}\n\t} else {\n\t\tcellDiffs.splice(endIndex, 1);\n\t\tcellDiffs.splice(startIndex, 0, entryToBeMoved);\n\t\t// If we're moving a new cell up/down, then we need just adjust just the modified indexes of the cells in between.\n\t\t// If we're moving an existing up/down, then we need to adjust the original indexes as well.\n\t\tif (typeof entryToBeMoved.originalCellIndex === 'number') {\n\t\t\tentryToBeMoved.originalCellIndex = cellDiffs.slice(0, startIndex).reduce((lastOriginalIndex, diff) => typeof diff.originalCellIndex === 'number' ? Math.max(lastOriginalIndex, diff.originalCellIndex) : lastOriginalIndex, -1) + 1;\n\t\t}\n\t}\n\n\t// If this is a new cell that we're moving, and there are no existing cells in between, then we can just move the new cell.\n\t// I.e. no need to update the original notebook model.\n\tif (typeof entryToBeMoved.originalCellIndex === 'number' && originalCellsWereEffected && typeof originalCellIndex === 'number' && entryToBeMoved.originalCellIndex !== originalCellIndex) {\n\t\tconst edit: ICellEditOperation = {\n\t\t\teditType: CellEditType.Move,\n\t\t\tindex: originalCellIndex,\n\t\t\tlength: event.length,\n\t\t\tnewIdx: entryToBeMoved.originalCellIndex\n\t\t};\n\n\t\treturn [cellDiffs, [edit]];\n\t}\n\n\treturn [cellDiffs, []];\n}\n\nexport function getCorrespondingOriginalCellIndex(modifiedCellIndex: number, cellDiffInfo: ICellDiffInfo[]): number | undefined {\n\tconst entry = cellDiffInfo.find(d => d.modifiedCellIndex === modifiedCellIndex);\n\treturn entry?.originalCellIndex;\n}\n\n/**\n *\n * This isn't great, but necessary.\n * ipynb extension updates metadata when new cells are inserted (to ensure the metadata is correct)\n * Details of why thats required is in ipynb extension, but its necessary.\n * However as a result of this, those edits appear here and are assumed to be user edits.\n * As a result `_allEditsAreFromUs` is set to false.\n */\nexport function isTransientIPyNbExtensionEvent(notebookKind: string, e: NotebookTextModelChangedEvent) {\n\tif (notebookKind !== 'jupyter-notebook') {\n\t\treturn false;\n\t}\n\tif (e.rawEvents.every(event => {\n\t\tif (event.kind !== NotebookCellsChangeType.ChangeCellMetadata) {\n\t\t\treturn false;\n\t\t}\n\t\tif (JSON.stringify(event.metadata || {}) === JSON.stringify({ execution_count: null, metadata: {} })) {\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\n\t})) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nexport function calculateNotebookRewriteRatio(cellsDiff: ICellDiffInfo[], originalModel: NotebookTextModel, modifiedModel: NotebookTextModel): number {\n\tconst totalNumberOfUpdatedLines = cellsDiff.reduce((totalUpdatedLines, value) => {\n\t\tconst getUpadtedLineCount = () => {\n\t\t\tif (value.type === 'unchanged') {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (value.type === 'delete') {\n\t\t\t\treturn originalModel.cells[value.originalCellIndex].textModel?.getLineCount() ?? 0;\n\t\t\t}\n\t\t\tif (value.type === 'insert') {\n\t\t\t\treturn modifiedModel.cells[value.modifiedCellIndex].textModel?.getLineCount() ?? 0;\n\t\t\t}\n\t\t\treturn value.diff.get().changes.reduce((maxLineNumber, change) => {\n\t\t\t\treturn Math.max(maxLineNumber, change.modified.endLineNumberExclusive);\n\t\t\t}, 0);\n\t\t};\n\n\t\treturn totalUpdatedLines + getUpadtedLineCount();\n\t}, 0);\n\n\tconst totalNumberOfLines = modifiedModel.cells.reduce((totalLines, cell) => totalLines + (cell.textModel?.getLineCount() ?? 0), 0);\n\treturn totalNumberOfLines === 0 ? 0 : Math.min(1, totalNumberOfUpdatedLines / totalNumberOfLines);\n\n}\n"]}