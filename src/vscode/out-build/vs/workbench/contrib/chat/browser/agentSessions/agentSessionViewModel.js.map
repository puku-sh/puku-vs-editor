{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/browser/agentSessions/agentSessionViewModel.ts","vs/workbench/contrib/chat/browser/agentSessions/agentSessionViewModel.ts"],"names":[],"mappings":"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","file":"agentSessionViewModel.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ThrottledDelayer } from '../../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../../base/common/codicons.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { IMarkdownString } from '../../../../../base/common/htmlContent.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../../../base/common/map.js';\nimport { ThemeIcon } from '../../../../../base/common/themables.js';\nimport { URI, UriComponents } from '../../../../../base/common/uri.js';\nimport { MenuId } from '../../../../../platform/actions/common/actions.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../../platform/storage/common/storage.js';\nimport { ILifecycleService } from '../../../../services/lifecycle/common/lifecycle.js';\nimport { ChatSessionStatus, IChatSessionsExtensionPoint, IChatSessionsService, localChatSessionType } from '../../common/chatSessionsService.js';\nimport { AgentSessionProviders, getAgentSessionProviderIcon, getAgentSessionProviderName } from './agentSessions.js';\nimport { AgentSessionsViewFilter } from './agentSessionsViewFilter.js';\n\n//#region Interfaces, Types\n\nexport interface IAgentSessionsViewModel {\n\n\treadonly onWillResolve: Event<void>;\n\treadonly onDidResolve: Event<void>;\n\n\treadonly onDidChangeSessions: Event<void>;\n\n\treadonly sessions: IAgentSessionViewModel[];\n\n\tresolve(provider: string | string[] | undefined): Promise<void>;\n}\n\nexport interface IAgentSessionViewModel {\n\n\treadonly providerType: string;\n\treadonly providerLabel: string;\n\n\treadonly resource: URI;\n\n\treadonly status: ChatSessionStatus;\n\treadonly archived: boolean;\n\n\treadonly tooltip?: string | IMarkdownString;\n\n\treadonly label: string;\n\treadonly description?: string | IMarkdownString;\n\treadonly icon: ThemeIcon;\n\n\treadonly timing: {\n\t\treadonly startTime: number;\n\t\treadonly endTime?: number;\n\n\t\treadonly inProgressTime?: number;\n\t\treadonly finishedOrFailedTime?: number;\n\t};\n\n\treadonly statistics?: {\n\t\treadonly files: number;\n\t\treadonly insertions: number;\n\t\treadonly deletions: number;\n\t};\n}\n\nexport function isLocalAgentSessionItem(session: IAgentSessionViewModel): boolean {\n\treturn session.providerType === localChatSessionType;\n}\n\nexport function isAgentSession(obj: IAgentSessionsViewModel | IAgentSessionViewModel): obj is IAgentSessionViewModel {\n\tconst session = obj as IAgentSessionViewModel | undefined;\n\n\treturn URI.isUri(session?.resource);\n}\n\nexport function isAgentSessionsViewModel(obj: IAgentSessionsViewModel | IAgentSessionViewModel): obj is IAgentSessionsViewModel {\n\tconst sessionsViewModel = obj as IAgentSessionsViewModel | undefined;\n\n\treturn Array.isArray(sessionsViewModel?.sessions);\n}\n\n//#endregion\n\nexport interface IAgentSessionsViewModelOptions {\n\treadonly filterMenuId: MenuId;\n}\n\nexport class AgentSessionsViewModel extends Disposable implements IAgentSessionsViewModel {\n\n\tprivate readonly _onWillResolve = this._register(new Emitter<void>());\n\treadonly onWillResolve = this._onWillResolve.event;\n\n\tprivate readonly _onDidResolve = this._register(new Emitter<void>());\n\treadonly onDidResolve = this._onDidResolve.event;\n\n\tprivate readonly _onDidChangeSessions = this._register(new Emitter<void>());\n\treadonly onDidChangeSessions = this._onDidChangeSessions.event;\n\n\tprivate _sessions: IAgentSessionViewModel[] = [];\n\n\tget sessions(): IAgentSessionViewModel[] {\n\t\treturn this._sessions.filter(session => !this.filter.exclude(session));\n\t}\n\n\tprivate readonly resolver = this._register(new ThrottledDelayer<void>(100));\n\tprivate readonly providersToResolve = new Set<string | undefined>();\n\n\tprivate readonly mapSessionToState = new ResourceMap<{\n\t\tstatus: ChatSessionStatus;\n\n\t\tinProgressTime?: number;\n\t\tfinishedOrFailedTime?: number;\n\t}>();\n\n\tprivate readonly filter: AgentSessionsViewFilter;\n\tprivate readonly cache: AgentSessionsCache;\n\n\tconstructor(\n\t\toptions: IAgentSessionsViewModelOptions,\n\t\t@IChatSessionsService private readonly chatSessionsService: IChatSessionsService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t) {\n\t\tsuper();\n\n\t\tthis.filter = this._register(this.instantiationService.createInstance(AgentSessionsViewFilter, { filterMenuId: options.filterMenuId }));\n\n\t\tthis.cache = this.instantiationService.createInstance(AgentSessionsCache);\n\t\tthis._sessions = this.cache.loadCachedSessions();\n\n\t\tthis.resolve(undefined);\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.chatSessionsService.onDidChangeItemsProviders(({ chatSessionType: provider }) => this.resolve(provider)));\n\t\tthis._register(this.chatSessionsService.onDidChangeAvailability(() => this.resolve(undefined)));\n\t\tthis._register(this.chatSessionsService.onDidChangeSessionItems(provider => this.resolve(provider)));\n\t\tthis._register(this.filter.onDidChange(() => this._onDidChangeSessions.fire()));\n\t\tthis._register(this.storageService.onWillSaveState(() => this.cache.saveCachedSessions(this._sessions)));\n\t}\n\n\tasync resolve(provider: string | string[] | undefined): Promise<void> {\n\t\tif (Array.isArray(provider)) {\n\t\t\tfor (const p of provider) {\n\t\t\t\tthis.providersToResolve.add(p);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.providersToResolve.add(provider);\n\t\t}\n\n\t\treturn this.resolver.trigger(async token => {\n\t\t\tif (token.isCancellationRequested || this.lifecycleService.willShutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis._onWillResolve.fire();\n\t\t\t\treturn await this.doResolve(token);\n\t\t\t} finally {\n\t\t\t\tthis._onDidResolve.fire();\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async doResolve(token: CancellationToken): Promise<void> {\n\t\tconst providersToResolve = Array.from(this.providersToResolve);\n\t\tthis.providersToResolve.clear();\n\n\t\tconst mapSessionContributionToType = new Map<string, IChatSessionsExtensionPoint>();\n\t\tfor (const contribution of this.chatSessionsService.getAllChatSessionContributions()) {\n\t\t\tmapSessionContributionToType.set(contribution.type, contribution);\n\t\t}\n\n\t\tconst resolvedProviders = new Set<string>();\n\t\tconst sessions = new ResourceMap<IAgentSessionViewModel>();\n\t\tfor (const provider of this.chatSessionsService.getAllChatSessionItemProviders()) {\n\t\t\tif (!providersToResolve.includes(undefined) && !providersToResolve.includes(provider.chatSessionType)) {\n\t\t\t\tcontinue; // skip: not considered for resolving\n\t\t\t}\n\n\t\t\tconst providerSessions = await provider.provideChatSessionItems(token);\n\t\t\tresolvedProviders.add(provider.chatSessionType);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (const session of providerSessions) {\n\n\t\t\t\t// Icon + Label\n\t\t\t\tlet icon: ThemeIcon;\n\t\t\t\tlet providerLabel: string;\n\t\t\t\tswitch ((provider.chatSessionType)) {\n\t\t\t\t\tcase AgentSessionProviders.Local:\n\t\t\t\t\t\tproviderLabel = getAgentSessionProviderName(AgentSessionProviders.Local);\n\t\t\t\t\t\ticon = getAgentSessionProviderIcon(AgentSessionProviders.Local);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AgentSessionProviders.Background:\n\t\t\t\t\t\tproviderLabel = getAgentSessionProviderName(AgentSessionProviders.Background);\n\t\t\t\t\t\ticon = getAgentSessionProviderIcon(AgentSessionProviders.Background);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AgentSessionProviders.Cloud:\n\t\t\t\t\t\tproviderLabel = getAgentSessionProviderName(AgentSessionProviders.Cloud);\n\t\t\t\t\t\ticon = getAgentSessionProviderIcon(AgentSessionProviders.Cloud);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tproviderLabel = mapSessionContributionToType.get(provider.chatSessionType)?.name ?? provider.chatSessionType;\n\t\t\t\t\t\ticon = session.iconPath ?? Codicon.terminal;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// State + Timings\n\t\t\t\t// TODO@bpasero this is a workaround for not having precise timing info in sessions\n\t\t\t\t// yet: we only track the time when a transition changes because then we can say with\n\t\t\t\t// confidence that the time is correct by assuming `Date.now()`. A better approach would\n\t\t\t\t// be to get all this information directly from the session.\n\t\t\t\tconst status = session.status ?? ChatSessionStatus.Completed;\n\t\t\t\tconst state = this.mapSessionToState.get(session.resource);\n\t\t\t\tlet inProgressTime = state?.inProgressTime;\n\t\t\t\tlet finishedOrFailedTime = state?.finishedOrFailedTime;\n\n\t\t\t\t// No previous state, just add it\n\t\t\t\tif (!state) {\n\t\t\t\t\tthis.mapSessionToState.set(session.resource, {\n\t\t\t\t\t\tstatus\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// State changed, update it\n\t\t\t\telse if (status !== state.status) {\n\t\t\t\t\tinProgressTime = status === ChatSessionStatus.InProgress ? Date.now() : state.inProgressTime;\n\t\t\t\t\tfinishedOrFailedTime = (status !== ChatSessionStatus.InProgress) ? Date.now() : state.finishedOrFailedTime;\n\n\t\t\t\t\tthis.mapSessionToState.set(session.resource, {\n\t\t\t\t\t\tstatus,\n\t\t\t\t\t\tinProgressTime,\n\t\t\t\t\t\tfinishedOrFailedTime\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tsessions.set(session.resource, {\n\t\t\t\t\tproviderType: provider.chatSessionType,\n\t\t\t\t\tproviderLabel,\n\t\t\t\t\tresource: session.resource,\n\t\t\t\t\tlabel: session.label,\n\t\t\t\t\tdescription: session.description,\n\t\t\t\t\ticon,\n\t\t\t\t\ttooltip: session.tooltip,\n\t\t\t\t\tstatus,\n\t\t\t\t\tarchived: session.archived ?? false,\n\t\t\t\t\ttiming: {\n\t\t\t\t\t\tstartTime: session.timing.startTime,\n\t\t\t\t\t\tendTime: session.timing.endTime,\n\t\t\t\t\t\tinProgressTime,\n\t\t\t\t\t\tfinishedOrFailedTime\n\t\t\t\t\t},\n\t\t\t\t\tstatistics: session.statistics,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (const session of this._sessions) {\n\t\t\tif (!resolvedProviders.has(session.providerType)) {\n\t\t\t\tsessions.set(session.resource, session); // fill in existing sessions for providers that did not resolve\n\t\t\t}\n\t\t}\n\n\t\tthis._sessions.length = 0;\n\t\tthis._sessions.push(...sessions.values());\n\n\t\tfor (const [resource] of this.mapSessionToState) {\n\t\t\tif (!sessions.has(resource)) {\n\t\t\t\tthis.mapSessionToState.delete(resource); // clean up tracking for removed sessions\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeSessions.fire();\n\t}\n}\n\n//#region Sessions Cache\n\ninterface ISerializedAgentSessionViewModel {\n\n\treadonly providerType: string;\n\treadonly providerLabel: string;\n\n\treadonly resource: UriComponents;\n\n\treadonly icon: string;\n\n\treadonly label: string;\n\n\treadonly description?: string | IMarkdownString;\n\treadonly tooltip?: string | IMarkdownString;\n\n\treadonly status: ChatSessionStatus;\n\treadonly archived: boolean;\n\n\treadonly timing: {\n\t\treadonly startTime: number;\n\t\treadonly endTime?: number;\n\t};\n\n\treadonly statistics?: {\n\t\treadonly files: number;\n\t\treadonly insertions: number;\n\t\treadonly deletions: number;\n\t};\n}\n\nclass AgentSessionsCache {\n\n\tprivate static readonly STORAGE_KEY = 'agentSessions.cache';\n\n\tconstructor(@IStorageService private readonly storageService: IStorageService) { }\n\n\tsaveCachedSessions(sessions: IAgentSessionViewModel[]): void {\n\t\tconst serialized: ISerializedAgentSessionViewModel[] = sessions\n\t\t\t.filter(session =>\n\t\t\t\t// Only consider providers that we own where we know that\n\t\t\t\t// we can also invalidate the data after startup\n\t\t\t\t// Other providers are bound to a different lifecycle (extensions)\n\t\t\t\tsession.providerType === AgentSessionProviders.Local ||\n\t\t\t\tsession.providerType === AgentSessionProviders.Background ||\n\t\t\t\tsession.providerType === AgentSessionProviders.Cloud\n\t\t\t)\n\t\t\t.map(session => ({\n\t\t\t\tproviderType: session.providerType,\n\t\t\t\tproviderLabel: session.providerLabel,\n\n\t\t\t\tresource: session.resource.toJSON(),\n\n\t\t\t\ticon: session.icon.id,\n\t\t\t\tlabel: session.label,\n\t\t\t\tdescription: session.description,\n\t\t\t\ttooltip: session.tooltip,\n\n\t\t\t\tstatus: session.status,\n\t\t\t\tarchived: session.archived,\n\n\t\t\t\ttiming: {\n\t\t\t\t\tstartTime: session.timing.startTime,\n\t\t\t\t\tendTime: session.timing.endTime,\n\t\t\t\t},\n\n\t\t\t\tstatistics: session.statistics,\n\t\t\t}));\n\t\tthis.storageService.store(AgentSessionsCache.STORAGE_KEY, JSON.stringify(serialized), StorageScope.WORKSPACE, StorageTarget.MACHINE);\n\t}\n\n\tloadCachedSessions(): IAgentSessionViewModel[] {\n\t\tconst sessionsCache = this.storageService.get(AgentSessionsCache.STORAGE_KEY, StorageScope.WORKSPACE);\n\t\tif (!sessionsCache) {\n\t\t\treturn [];\n\t\t}\n\n\t\ttry {\n\t\t\tconst cached = JSON.parse(sessionsCache) as ISerializedAgentSessionViewModel[];\n\t\t\treturn cached.map(session => ({\n\t\t\t\tproviderType: session.providerType,\n\t\t\t\tproviderLabel: session.providerLabel,\n\n\t\t\t\tresource: URI.revive(session.resource),\n\n\t\t\t\ticon: ThemeIcon.fromId(session.icon),\n\t\t\t\tlabel: session.label,\n\t\t\t\tdescription: session.description,\n\t\t\t\ttooltip: session.tooltip,\n\n\t\t\t\tstatus: session.status,\n\t\t\t\tarchived: session.archived,\n\n\t\t\t\ttiming: {\n\t\t\t\t\tstartTime: session.timing.startTime,\n\t\t\t\t\tendTime: session.timing.endTime,\n\t\t\t\t},\n\n\t\t\t\tstatistics: session.statistics,\n\t\t\t}));\n\t\t} catch {\n\t\t\treturn []; // invalid data in storage, fallback to empty sessions list\n\t\t}\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ThrottledDelayer } from '../../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../../base/common/codicons.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { IMarkdownString } from '../../../../../base/common/htmlContent.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../../../base/common/map.js';\nimport { ThemeIcon } from '../../../../../base/common/themables.js';\nimport { URI, UriComponents } from '../../../../../base/common/uri.js';\nimport { MenuId } from '../../../../../platform/actions/common/actions.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../../platform/storage/common/storage.js';\nimport { ILifecycleService } from '../../../../services/lifecycle/common/lifecycle.js';\nimport { ChatSessionStatus, IChatSessionsExtensionPoint, IChatSessionsService, localChatSessionType } from '../../common/chatSessionsService.js';\nimport { AgentSessionProviders, getAgentSessionProviderIcon, getAgentSessionProviderName } from './agentSessions.js';\nimport { AgentSessionsViewFilter } from './agentSessionsViewFilter.js';\n\n//#region Interfaces, Types\n\nexport interface IAgentSessionsViewModel {\n\n\treadonly onWillResolve: Event<void>;\n\treadonly onDidResolve: Event<void>;\n\n\treadonly onDidChangeSessions: Event<void>;\n\n\treadonly sessions: IAgentSessionViewModel[];\n\n\tresolve(provider: string | string[] | undefined): Promise<void>;\n}\n\nexport interface IAgentSessionViewModel {\n\n\treadonly providerType: string;\n\treadonly providerLabel: string;\n\n\treadonly resource: URI;\n\n\treadonly status: ChatSessionStatus;\n\treadonly archived: boolean;\n\n\treadonly tooltip?: string | IMarkdownString;\n\n\treadonly label: string;\n\treadonly description?: string | IMarkdownString;\n\treadonly icon: ThemeIcon;\n\n\treadonly timing: {\n\t\treadonly startTime: number;\n\t\treadonly endTime?: number;\n\n\t\treadonly inProgressTime?: number;\n\t\treadonly finishedOrFailedTime?: number;\n\t};\n\n\treadonly statistics?: {\n\t\treadonly files: number;\n\t\treadonly insertions: number;\n\t\treadonly deletions: number;\n\t};\n}\n\nexport function isLocalAgentSessionItem(session: IAgentSessionViewModel): boolean {\n\treturn session.providerType === localChatSessionType;\n}\n\nexport function isAgentSession(obj: IAgentSessionsViewModel | IAgentSessionViewModel): obj is IAgentSessionViewModel {\n\tconst session = obj as IAgentSessionViewModel | undefined;\n\n\treturn URI.isUri(session?.resource);\n}\n\nexport function isAgentSessionsViewModel(obj: IAgentSessionsViewModel | IAgentSessionViewModel): obj is IAgentSessionsViewModel {\n\tconst sessionsViewModel = obj as IAgentSessionsViewModel | undefined;\n\n\treturn Array.isArray(sessionsViewModel?.sessions);\n}\n\n//#endregion\n\nexport interface IAgentSessionsViewModelOptions {\n\treadonly filterMenuId: MenuId;\n}\n\nexport class AgentSessionsViewModel extends Disposable implements IAgentSessionsViewModel {\n\n\tprivate readonly _onWillResolve = this._register(new Emitter<void>());\n\treadonly onWillResolve = this._onWillResolve.event;\n\n\tprivate readonly _onDidResolve = this._register(new Emitter<void>());\n\treadonly onDidResolve = this._onDidResolve.event;\n\n\tprivate readonly _onDidChangeSessions = this._register(new Emitter<void>());\n\treadonly onDidChangeSessions = this._onDidChangeSessions.event;\n\n\tprivate _sessions: IAgentSessionViewModel[] = [];\n\n\tget sessions(): IAgentSessionViewModel[] {\n\t\treturn this._sessions.filter(session => !this.filter.exclude(session));\n\t}\n\n\tprivate readonly resolver = this._register(new ThrottledDelayer<void>(100));\n\tprivate readonly providersToResolve = new Set<string | undefined>();\n\n\tprivate readonly mapSessionToState = new ResourceMap<{\n\t\tstatus: ChatSessionStatus;\n\n\t\tinProgressTime?: number;\n\t\tfinishedOrFailedTime?: number;\n\t}>();\n\n\tprivate readonly filter: AgentSessionsViewFilter;\n\tprivate readonly cache: AgentSessionsCache;\n\n\tconstructor(\n\t\toptions: IAgentSessionsViewModelOptions,\n\t\t@IChatSessionsService private readonly chatSessionsService: IChatSessionsService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t) {\n\t\tsuper();\n\n\t\tthis.filter = this._register(this.instantiationService.createInstance(AgentSessionsViewFilter, { filterMenuId: options.filterMenuId }));\n\n\t\tthis.cache = this.instantiationService.createInstance(AgentSessionsCache);\n\t\tthis._sessions = this.cache.loadCachedSessions();\n\n\t\tthis.resolve(undefined);\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.chatSessionsService.onDidChangeItemsProviders(({ chatSessionType: provider }) => this.resolve(provider)));\n\t\tthis._register(this.chatSessionsService.onDidChangeAvailability(() => this.resolve(undefined)));\n\t\tthis._register(this.chatSessionsService.onDidChangeSessionItems(provider => this.resolve(provider)));\n\t\tthis._register(this.filter.onDidChange(() => this._onDidChangeSessions.fire()));\n\t\tthis._register(this.storageService.onWillSaveState(() => this.cache.saveCachedSessions(this._sessions)));\n\t}\n\n\tasync resolve(provider: string | string[] | undefined): Promise<void> {\n\t\tif (Array.isArray(provider)) {\n\t\t\tfor (const p of provider) {\n\t\t\t\tthis.providersToResolve.add(p);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.providersToResolve.add(provider);\n\t\t}\n\n\t\treturn this.resolver.trigger(async token => {\n\t\t\tif (token.isCancellationRequested || this.lifecycleService.willShutdown) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis._onWillResolve.fire();\n\t\t\t\treturn await this.doResolve(token);\n\t\t\t} finally {\n\t\t\t\tthis._onDidResolve.fire();\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async doResolve(token: CancellationToken): Promise<void> {\n\t\tconst providersToResolve = Array.from(this.providersToResolve);\n\t\tthis.providersToResolve.clear();\n\n\t\tconst mapSessionContributionToType = new Map<string, IChatSessionsExtensionPoint>();\n\t\tfor (const contribution of this.chatSessionsService.getAllChatSessionContributions()) {\n\t\t\tmapSessionContributionToType.set(contribution.type, contribution);\n\t\t}\n\n\t\tconst resolvedProviders = new Set<string>();\n\t\tconst sessions = new ResourceMap<IAgentSessionViewModel>();\n\t\tfor (const provider of this.chatSessionsService.getAllChatSessionItemProviders()) {\n\t\t\tif (!providersToResolve.includes(undefined) && !providersToResolve.includes(provider.chatSessionType)) {\n\t\t\t\tcontinue; // skip: not considered for resolving\n\t\t\t}\n\n\t\t\tconst providerSessions = await provider.provideChatSessionItems(token);\n\t\t\tresolvedProviders.add(provider.chatSessionType);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (const session of providerSessions) {\n\n\t\t\t\t// Icon + Label\n\t\t\t\tlet icon: ThemeIcon;\n\t\t\t\tlet providerLabel: string;\n\t\t\t\tswitch ((provider.chatSessionType)) {\n\t\t\t\t\tcase AgentSessionProviders.Local:\n\t\t\t\t\t\tproviderLabel = getAgentSessionProviderName(AgentSessionProviders.Local);\n\t\t\t\t\t\ticon = getAgentSessionProviderIcon(AgentSessionProviders.Local);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AgentSessionProviders.Background:\n\t\t\t\t\t\tproviderLabel = getAgentSessionProviderName(AgentSessionProviders.Background);\n\t\t\t\t\t\ticon = getAgentSessionProviderIcon(AgentSessionProviders.Background);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AgentSessionProviders.Cloud:\n\t\t\t\t\t\tproviderLabel = getAgentSessionProviderName(AgentSessionProviders.Cloud);\n\t\t\t\t\t\ticon = getAgentSessionProviderIcon(AgentSessionProviders.Cloud);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tproviderLabel = mapSessionContributionToType.get(provider.chatSessionType)?.name ?? provider.chatSessionType;\n\t\t\t\t\t\ticon = session.iconPath ?? Codicon.terminal;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// State + Timings\n\t\t\t\t// TODO@bpasero this is a workaround for not having precise timing info in sessions\n\t\t\t\t// yet: we only track the time when a transition changes because then we can say with\n\t\t\t\t// confidence that the time is correct by assuming `Date.now()`. A better approach would\n\t\t\t\t// be to get all this information directly from the session.\n\t\t\t\tconst status = session.status ?? ChatSessionStatus.Completed;\n\t\t\t\tconst state = this.mapSessionToState.get(session.resource);\n\t\t\t\tlet inProgressTime = state?.inProgressTime;\n\t\t\t\tlet finishedOrFailedTime = state?.finishedOrFailedTime;\n\n\t\t\t\t// No previous state, just add it\n\t\t\t\tif (!state) {\n\t\t\t\t\tthis.mapSessionToState.set(session.resource, {\n\t\t\t\t\t\tstatus\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// State changed, update it\n\t\t\t\telse if (status !== state.status) {\n\t\t\t\t\tinProgressTime = status === ChatSessionStatus.InProgress ? Date.now() : state.inProgressTime;\n\t\t\t\t\tfinishedOrFailedTime = (status !== ChatSessionStatus.InProgress) ? Date.now() : state.finishedOrFailedTime;\n\n\t\t\t\t\tthis.mapSessionToState.set(session.resource, {\n\t\t\t\t\t\tstatus,\n\t\t\t\t\t\tinProgressTime,\n\t\t\t\t\t\tfinishedOrFailedTime\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tsessions.set(session.resource, {\n\t\t\t\t\tproviderType: provider.chatSessionType,\n\t\t\t\t\tproviderLabel,\n\t\t\t\t\tresource: session.resource,\n\t\t\t\t\tlabel: session.label,\n\t\t\t\t\tdescription: session.description,\n\t\t\t\t\ticon,\n\t\t\t\t\ttooltip: session.tooltip,\n\t\t\t\t\tstatus,\n\t\t\t\t\tarchived: session.archived ?? false,\n\t\t\t\t\ttiming: {\n\t\t\t\t\t\tstartTime: session.timing.startTime,\n\t\t\t\t\t\tendTime: session.timing.endTime,\n\t\t\t\t\t\tinProgressTime,\n\t\t\t\t\t\tfinishedOrFailedTime\n\t\t\t\t\t},\n\t\t\t\t\tstatistics: session.statistics,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (const session of this._sessions) {\n\t\t\tif (!resolvedProviders.has(session.providerType)) {\n\t\t\t\tsessions.set(session.resource, session); // fill in existing sessions for providers that did not resolve\n\t\t\t}\n\t\t}\n\n\t\tthis._sessions.length = 0;\n\t\tthis._sessions.push(...sessions.values());\n\n\t\tfor (const [resource] of this.mapSessionToState) {\n\t\t\tif (!sessions.has(resource)) {\n\t\t\t\tthis.mapSessionToState.delete(resource); // clean up tracking for removed sessions\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeSessions.fire();\n\t}\n}\n\n//#region Sessions Cache\n\ninterface ISerializedAgentSessionViewModel {\n\n\treadonly providerType: string;\n\treadonly providerLabel: string;\n\n\treadonly resource: UriComponents;\n\n\treadonly icon: string;\n\n\treadonly label: string;\n\n\treadonly description?: string | IMarkdownString;\n\treadonly tooltip?: string | IMarkdownString;\n\n\treadonly status: ChatSessionStatus;\n\treadonly archived: boolean;\n\n\treadonly timing: {\n\t\treadonly startTime: number;\n\t\treadonly endTime?: number;\n\t};\n\n\treadonly statistics?: {\n\t\treadonly files: number;\n\t\treadonly insertions: number;\n\t\treadonly deletions: number;\n\t};\n}\n\nclass AgentSessionsCache {\n\n\tprivate static readonly STORAGE_KEY = 'agentSessions.cache';\n\n\tconstructor(@IStorageService private readonly storageService: IStorageService) { }\n\n\tsaveCachedSessions(sessions: IAgentSessionViewModel[]): void {\n\t\tconst serialized: ISerializedAgentSessionViewModel[] = sessions\n\t\t\t.filter(session =>\n\t\t\t\t// Only consider providers that we own where we know that\n\t\t\t\t// we can also invalidate the data after startup\n\t\t\t\t// Other providers are bound to a different lifecycle (extensions)\n\t\t\t\tsession.providerType === AgentSessionProviders.Local ||\n\t\t\t\tsession.providerType === AgentSessionProviders.Background ||\n\t\t\t\tsession.providerType === AgentSessionProviders.Cloud\n\t\t\t)\n\t\t\t.map(session => ({\n\t\t\t\tproviderType: session.providerType,\n\t\t\t\tproviderLabel: session.providerLabel,\n\n\t\t\t\tresource: session.resource.toJSON(),\n\n\t\t\t\ticon: session.icon.id,\n\t\t\t\tlabel: session.label,\n\t\t\t\tdescription: session.description,\n\t\t\t\ttooltip: session.tooltip,\n\n\t\t\t\tstatus: session.status,\n\t\t\t\tarchived: session.archived,\n\n\t\t\t\ttiming: {\n\t\t\t\t\tstartTime: session.timing.startTime,\n\t\t\t\t\tendTime: session.timing.endTime,\n\t\t\t\t},\n\n\t\t\t\tstatistics: session.statistics,\n\t\t\t}));\n\t\tthis.storageService.store(AgentSessionsCache.STORAGE_KEY, JSON.stringify(serialized), StorageScope.WORKSPACE, StorageTarget.MACHINE);\n\t}\n\n\tloadCachedSessions(): IAgentSessionViewModel[] {\n\t\tconst sessionsCache = this.storageService.get(AgentSessionsCache.STORAGE_KEY, StorageScope.WORKSPACE);\n\t\tif (!sessionsCache) {\n\t\t\treturn [];\n\t\t}\n\n\t\ttry {\n\t\t\tconst cached = JSON.parse(sessionsCache) as ISerializedAgentSessionViewModel[];\n\t\t\treturn cached.map(session => ({\n\t\t\t\tproviderType: session.providerType,\n\t\t\t\tproviderLabel: session.providerLabel,\n\n\t\t\t\tresource: URI.revive(session.resource),\n\n\t\t\t\ticon: ThemeIcon.fromId(session.icon),\n\t\t\t\tlabel: session.label,\n\t\t\t\tdescription: session.description,\n\t\t\t\ttooltip: session.tooltip,\n\n\t\t\t\tstatus: session.status,\n\t\t\t\tarchived: session.archived,\n\n\t\t\t\ttiming: {\n\t\t\t\t\tstartTime: session.timing.startTime,\n\t\t\t\t\tendTime: session.timing.endTime,\n\t\t\t\t},\n\n\t\t\t\tstatistics: session.statistics,\n\t\t\t}));\n\t\t} catch {\n\t\t\treturn []; // invalid data in storage, fallback to empty sessions list\n\t\t}\n\t}\n}\n\n//#endregion\n"]}