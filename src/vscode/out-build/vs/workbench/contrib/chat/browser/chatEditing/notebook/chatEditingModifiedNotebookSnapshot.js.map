{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/browser/chatEditing/notebook/chatEditingModifiedNotebookSnapshot.ts","vs/workbench/contrib/chat/browser/chatEditing/notebook/chatEditingModifiedNotebookSnapshot.ts"],"names":[],"mappings":"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","file":"chatEditingModifiedNotebookSnapshot.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { decodeBase64, encodeBase64, VSBuffer } from '../../../../../../base/common/buffer.js';\nimport { filter } from '../../../../../../base/common/objects.js';\nimport { URI, UriComponents } from '../../../../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../../../../platform/configuration/common/configuration.js';\nimport { SnapshotContext } from '../../../../../services/workingCopy/common/fileWorkingCopy.js';\nimport { NotebookCellTextModel } from '../../../../notebook/common/model/notebookCellTextModel.js';\nimport { NotebookTextModel } from '../../../../notebook/common/model/notebookTextModel.js';\nimport { CellEditType, ICellDto2, ICellEditOperation, INotebookTextModel, IOutputItemDto, NotebookData, NotebookSetting, TransientOptions } from '../../../../notebook/common/notebookCommon.js';\n\nconst BufferMarker = 'ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d';\n\ntype ChatEditingSnapshotNotebookContentQueryData = { session: UriComponents; requestId: string | undefined; undoStop: string | undefined; viewType: string };\nexport const ChatEditingNotebookSnapshotScheme = 'chat-editing-notebook-snapshot-model';\n\nexport function getNotebookSnapshotFileURI(chatSessionResource: URI, requestId: string | undefined, undoStop: string | undefined, path: string, viewType: string): URI {\n\treturn URI.from({\n\t\tscheme: ChatEditingNotebookSnapshotScheme,\n\t\tpath,\n\t\tquery: JSON.stringify({ session: chatSessionResource, requestId: requestId ?? '', undoStop: undoStop ?? '', viewType } satisfies ChatEditingSnapshotNotebookContentQueryData),\n\t});\n}\n\nexport function parseNotebookSnapshotFileURI(resource: URI): ChatEditingSnapshotNotebookContentQueryData {\n\tconst data: ChatEditingSnapshotNotebookContentQueryData = JSON.parse(resource.query);\n\treturn { session: data.session, requestId: data.requestId ?? '', undoStop: data.undoStop ?? '', viewType: data.viewType };\n}\n\nexport function createSnapshot(notebook: INotebookTextModel, transientOptions: TransientOptions | undefined, outputSizeConfig: IConfigurationService | number): string {\n\tconst outputSizeLimit = (typeof outputSizeConfig === 'number' ? outputSizeConfig : outputSizeConfig.getValue<number>(NotebookSetting.outputBackupSizeLimit)) * 1024;\n\treturn serializeSnapshot(notebook.createSnapshot({ context: SnapshotContext.Backup, outputSizeLimit, transientOptions }), transientOptions);\n}\n\nexport function restoreSnapshot(notebook: INotebookTextModel, snapshot: string): void {\n\ttry {\n\t\tconst { transientOptions, data } = deserializeSnapshot(snapshot);\n\t\tnotebook.restoreSnapshot(data, transientOptions);\n\t\tconst edits: ICellEditOperation[] = [];\n\t\tdata.cells.forEach((cell, index) => {\n\t\t\tconst internalId = cell.internalMetadata?.internalId;\n\t\t\tif (internalId) {\n\t\t\t\tedits.push({ editType: CellEditType.PartialInternalMetadata, index, internalMetadata: { internalId } });\n\t\t\t}\n\t\t});\n\t\tnotebook.applyEdits(edits, true, undefined, () => undefined, undefined, false);\n\t}\n\tcatch (ex) {\n\t\tconsole.error('Error restoring Notebook snapshot', ex);\n\t}\n}\n\nexport class SnapshotComparer {\n\tprivate readonly data: NotebookData;\n\tprivate readonly transientOptions: TransientOptions | undefined;\n\tconstructor(initialCotent: string) {\n\t\tconst { transientOptions, data } = deserializeSnapshot(initialCotent);\n\t\tthis.transientOptions = transientOptions;\n\t\tthis.data = data;\n\t}\n\n\tisEqual(notebook: NotebookData | NotebookTextModel): boolean {\n\t\tif (notebook.cells.length !== this.data.cells.length) {\n\t\t\treturn false;\n\t\t}\n\t\tconst transientDocumentMetadata = this.transientOptions?.transientDocumentMetadata || {};\n\t\tconst notebookMetadata = filter(notebook.metadata || {}, key => !transientDocumentMetadata[key]);\n\t\tconst comparerMetadata = filter(this.data.metadata || {}, key => !transientDocumentMetadata[key]);\n\t\t// When comparing ignore transient items.\n\t\tif (JSON.stringify(notebookMetadata) !== JSON.stringify(comparerMetadata)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst transientCellMetadata = this.transientOptions?.transientCellMetadata || {};\n\t\tfor (let i = 0; i < notebook.cells.length; i++) {\n\t\t\tconst notebookCell = notebook.cells[i];\n\t\t\tconst comparerCell = this.data.cells[i];\n\t\t\tif (notebookCell instanceof NotebookCellTextModel) {\n\t\t\t\tif (!notebookCell.fastEqual(comparerCell, true)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (notebookCell.cellKind !== comparerCell.cellKind) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (notebookCell.language !== comparerCell.language) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (notebookCell.mime !== comparerCell.mime) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (notebookCell.source !== comparerCell.source) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!this.transientOptions?.transientOutputs && notebookCell.outputs.length !== comparerCell.outputs.length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// When comparing ignore transient items.\n\t\t\t\tconst cellMetadata = filter(notebookCell.metadata || {}, key => !transientCellMetadata[key]);\n\t\t\t\tconst comparerCellMetadata = filter(comparerCell.metadata || {}, key => !transientCellMetadata[key]);\n\t\t\t\tif (JSON.stringify(cellMetadata) !== JSON.stringify(comparerCellMetadata)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// When comparing ignore transient items.\n\t\t\t\tif (JSON.stringify(sanitizeCellDto2(notebookCell, true, this.transientOptions)) !== JSON.stringify(sanitizeCellDto2(comparerCell, true, this.transientOptions))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\nfunction sanitizeCellDto2(cell: ICellDto2, ignoreInternalMetadata?: boolean, transientOptions?: TransientOptions): ICellDto2 {\n\tconst transientCellMetadata = transientOptions?.transientCellMetadata || {};\n\tconst outputs = transientOptions?.transientOutputs ? [] : cell.outputs.map(output => {\n\t\t// Ensure we're in full control of the data being stored.\n\t\t// Possible we have classes instead of plain objects.\n\t\treturn {\n\t\t\toutputId: output.outputId,\n\t\t\tmetadata: output.metadata,\n\t\t\toutputs: output.outputs.map(item => {\n\t\t\t\treturn {\n\t\t\t\t\tdata: item.data,\n\t\t\t\t\tmime: item.mime,\n\t\t\t\t} satisfies IOutputItemDto;\n\t\t\t}),\n\t\t};\n\t});\n\t// Ensure we're in full control of the data being stored.\n\t// Possible we have classes instead of plain objects.\n\treturn {\n\t\tcellKind: cell.cellKind,\n\t\tlanguage: cell.language,\n\t\tmetadata: cell.metadata ? filter(cell.metadata, key => !transientCellMetadata[key]) : cell.metadata,\n\t\toutputs,\n\t\tmime: cell.mime,\n\t\tsource: cell.source,\n\t\tcollapseState: cell.collapseState,\n\t\tinternalMetadata: ignoreInternalMetadata ? undefined : cell.internalMetadata\n\t} satisfies ICellDto2;\n}\n\nfunction serializeSnapshot(data: NotebookData, transientOptions: TransientOptions | undefined): string {\n\tconst dataDto: NotebookData = {\n\t\t// Never pass transient options, as we're after a backup here.\n\t\t// Else we end up stripping outputs from backups.\n\t\t// Whether its persisted or not is up to the serializer.\n\t\t// However when reloading/restoring we need to preserve outputs.\n\t\tcells: data.cells.map(cell => sanitizeCellDto2(cell)),\n\t\tmetadata: data.metadata,\n\t};\n\treturn JSON.stringify([\n\t\tJSON.stringify(transientOptions)\n\t\t, JSON.stringify(dataDto, (_key, value) => {\n\t\t\tif (value instanceof VSBuffer) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: BufferMarker,\n\t\t\t\t\tdata: encodeBase64(value)\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn value;\n\t\t})\n\t]);\n}\n\nexport function deserializeSnapshot(snapshot: string): { transientOptions: TransientOptions | undefined; data: NotebookData } {\n\tconst [transientOptionsStr, dataStr] = JSON.parse(snapshot);\n\tconst transientOptions = transientOptionsStr ? JSON.parse(transientOptionsStr) as TransientOptions : undefined;\n\n\tconst data: NotebookData = JSON.parse(dataStr, (_key, value) => {\n\t\tif (value && value.type === BufferMarker) {\n\t\t\treturn decodeBase64(value.data);\n\t\t}\n\t\treturn value;\n\t});\n\n\treturn { transientOptions, data };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { decodeBase64, encodeBase64, VSBuffer } from '../../../../../../base/common/buffer.js';\nimport { filter } from '../../../../../../base/common/objects.js';\nimport { URI, UriComponents } from '../../../../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../../../../platform/configuration/common/configuration.js';\nimport { SnapshotContext } from '../../../../../services/workingCopy/common/fileWorkingCopy.js';\nimport { NotebookCellTextModel } from '../../../../notebook/common/model/notebookCellTextModel.js';\nimport { NotebookTextModel } from '../../../../notebook/common/model/notebookTextModel.js';\nimport { CellEditType, ICellDto2, ICellEditOperation, INotebookTextModel, IOutputItemDto, NotebookData, NotebookSetting, TransientOptions } from '../../../../notebook/common/notebookCommon.js';\n\nconst BufferMarker = 'ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d';\n\ntype ChatEditingSnapshotNotebookContentQueryData = { session: UriComponents; requestId: string | undefined; undoStop: string | undefined; viewType: string };\nexport const ChatEditingNotebookSnapshotScheme = 'chat-editing-notebook-snapshot-model';\n\nexport function getNotebookSnapshotFileURI(chatSessionResource: URI, requestId: string | undefined, undoStop: string | undefined, path: string, viewType: string): URI {\n\treturn URI.from({\n\t\tscheme: ChatEditingNotebookSnapshotScheme,\n\t\tpath,\n\t\tquery: JSON.stringify({ session: chatSessionResource, requestId: requestId ?? '', undoStop: undoStop ?? '', viewType } satisfies ChatEditingSnapshotNotebookContentQueryData),\n\t});\n}\n\nexport function parseNotebookSnapshotFileURI(resource: URI): ChatEditingSnapshotNotebookContentQueryData {\n\tconst data: ChatEditingSnapshotNotebookContentQueryData = JSON.parse(resource.query);\n\treturn { session: data.session, requestId: data.requestId ?? '', undoStop: data.undoStop ?? '', viewType: data.viewType };\n}\n\nexport function createSnapshot(notebook: INotebookTextModel, transientOptions: TransientOptions | undefined, outputSizeConfig: IConfigurationService | number): string {\n\tconst outputSizeLimit = (typeof outputSizeConfig === 'number' ? outputSizeConfig : outputSizeConfig.getValue<number>(NotebookSetting.outputBackupSizeLimit)) * 1024;\n\treturn serializeSnapshot(notebook.createSnapshot({ context: SnapshotContext.Backup, outputSizeLimit, transientOptions }), transientOptions);\n}\n\nexport function restoreSnapshot(notebook: INotebookTextModel, snapshot: string): void {\n\ttry {\n\t\tconst { transientOptions, data } = deserializeSnapshot(snapshot);\n\t\tnotebook.restoreSnapshot(data, transientOptions);\n\t\tconst edits: ICellEditOperation[] = [];\n\t\tdata.cells.forEach((cell, index) => {\n\t\t\tconst internalId = cell.internalMetadata?.internalId;\n\t\t\tif (internalId) {\n\t\t\t\tedits.push({ editType: CellEditType.PartialInternalMetadata, index, internalMetadata: { internalId } });\n\t\t\t}\n\t\t});\n\t\tnotebook.applyEdits(edits, true, undefined, () => undefined, undefined, false);\n\t}\n\tcatch (ex) {\n\t\tconsole.error('Error restoring Notebook snapshot', ex);\n\t}\n}\n\nexport class SnapshotComparer {\n\tprivate readonly data: NotebookData;\n\tprivate readonly transientOptions: TransientOptions | undefined;\n\tconstructor(initialCotent: string) {\n\t\tconst { transientOptions, data } = deserializeSnapshot(initialCotent);\n\t\tthis.transientOptions = transientOptions;\n\t\tthis.data = data;\n\t}\n\n\tisEqual(notebook: NotebookData | NotebookTextModel): boolean {\n\t\tif (notebook.cells.length !== this.data.cells.length) {\n\t\t\treturn false;\n\t\t}\n\t\tconst transientDocumentMetadata = this.transientOptions?.transientDocumentMetadata || {};\n\t\tconst notebookMetadata = filter(notebook.metadata || {}, key => !transientDocumentMetadata[key]);\n\t\tconst comparerMetadata = filter(this.data.metadata || {}, key => !transientDocumentMetadata[key]);\n\t\t// When comparing ignore transient items.\n\t\tif (JSON.stringify(notebookMetadata) !== JSON.stringify(comparerMetadata)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst transientCellMetadata = this.transientOptions?.transientCellMetadata || {};\n\t\tfor (let i = 0; i < notebook.cells.length; i++) {\n\t\t\tconst notebookCell = notebook.cells[i];\n\t\t\tconst comparerCell = this.data.cells[i];\n\t\t\tif (notebookCell instanceof NotebookCellTextModel) {\n\t\t\t\tif (!notebookCell.fastEqual(comparerCell, true)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (notebookCell.cellKind !== comparerCell.cellKind) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (notebookCell.language !== comparerCell.language) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (notebookCell.mime !== comparerCell.mime) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (notebookCell.source !== comparerCell.source) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!this.transientOptions?.transientOutputs && notebookCell.outputs.length !== comparerCell.outputs.length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// When comparing ignore transient items.\n\t\t\t\tconst cellMetadata = filter(notebookCell.metadata || {}, key => !transientCellMetadata[key]);\n\t\t\t\tconst comparerCellMetadata = filter(comparerCell.metadata || {}, key => !transientCellMetadata[key]);\n\t\t\t\tif (JSON.stringify(cellMetadata) !== JSON.stringify(comparerCellMetadata)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// When comparing ignore transient items.\n\t\t\t\tif (JSON.stringify(sanitizeCellDto2(notebookCell, true, this.transientOptions)) !== JSON.stringify(sanitizeCellDto2(comparerCell, true, this.transientOptions))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\nfunction sanitizeCellDto2(cell: ICellDto2, ignoreInternalMetadata?: boolean, transientOptions?: TransientOptions): ICellDto2 {\n\tconst transientCellMetadata = transientOptions?.transientCellMetadata || {};\n\tconst outputs = transientOptions?.transientOutputs ? [] : cell.outputs.map(output => {\n\t\t// Ensure we're in full control of the data being stored.\n\t\t// Possible we have classes instead of plain objects.\n\t\treturn {\n\t\t\toutputId: output.outputId,\n\t\t\tmetadata: output.metadata,\n\t\t\toutputs: output.outputs.map(item => {\n\t\t\t\treturn {\n\t\t\t\t\tdata: item.data,\n\t\t\t\t\tmime: item.mime,\n\t\t\t\t} satisfies IOutputItemDto;\n\t\t\t}),\n\t\t};\n\t});\n\t// Ensure we're in full control of the data being stored.\n\t// Possible we have classes instead of plain objects.\n\treturn {\n\t\tcellKind: cell.cellKind,\n\t\tlanguage: cell.language,\n\t\tmetadata: cell.metadata ? filter(cell.metadata, key => !transientCellMetadata[key]) : cell.metadata,\n\t\toutputs,\n\t\tmime: cell.mime,\n\t\tsource: cell.source,\n\t\tcollapseState: cell.collapseState,\n\t\tinternalMetadata: ignoreInternalMetadata ? undefined : cell.internalMetadata\n\t} satisfies ICellDto2;\n}\n\nfunction serializeSnapshot(data: NotebookData, transientOptions: TransientOptions | undefined): string {\n\tconst dataDto: NotebookData = {\n\t\t// Never pass transient options, as we're after a backup here.\n\t\t// Else we end up stripping outputs from backups.\n\t\t// Whether its persisted or not is up to the serializer.\n\t\t// However when reloading/restoring we need to preserve outputs.\n\t\tcells: data.cells.map(cell => sanitizeCellDto2(cell)),\n\t\tmetadata: data.metadata,\n\t};\n\treturn JSON.stringify([\n\t\tJSON.stringify(transientOptions)\n\t\t, JSON.stringify(dataDto, (_key, value) => {\n\t\t\tif (value instanceof VSBuffer) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: BufferMarker,\n\t\t\t\t\tdata: encodeBase64(value)\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn value;\n\t\t})\n\t]);\n}\n\nexport function deserializeSnapshot(snapshot: string): { transientOptions: TransientOptions | undefined; data: NotebookData } {\n\tconst [transientOptionsStr, dataStr] = JSON.parse(snapshot);\n\tconst transientOptions = transientOptionsStr ? JSON.parse(transientOptionsStr) as TransientOptions : undefined;\n\n\tconst data: NotebookData = JSON.parse(dataStr, (_key, value) => {\n\t\tif (value && value.type === BufferMarker) {\n\t\t\treturn decodeBase64(value.data);\n\t\t}\n\t\treturn value;\n\t});\n\n\treturn { transientOptions, data };\n}\n"]}