{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/browser/chatEditing/chatEditingCheckpointTimelineImpl.ts","vs/workbench/contrib/chat/browser/chatEditing/chatEditingCheckpointTimelineImpl.ts"],"names":[],"mappings":"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","file":"chatEditingCheckpointTimelineImpl.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals as arraysEqual } from '../../../../../base/common/arrays.js';\nimport { findFirst, findLast, findLastIdx } from '../../../../../base/common/arraysFind.js';\nimport { assertNever } from '../../../../../base/common/assert.js';\nimport { ThrottledDelayer } from '../../../../../base/common/async.js';\nimport { Event } from '../../../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable } from '../../../../../base/common/lifecycle.js';\nimport { ResourceSet } from '../../../../../base/common/map.js';\nimport { equals as objectsEqual } from '../../../../../base/common/objects.js';\nimport { derived, derivedOpts, IObservable, IReader, ITransaction, ObservablePromise, observableSignalFromEvent, observableValue, observableValueOpts, transaction } from '../../../../../base/common/observable.js';\nimport { isEqual } from '../../../../../base/common/resources.js';\nimport { Mutable } from '../../../../../base/common/types.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { generateUuid } from '../../../../../base/common/uuid.js';\nimport { TextEdit } from '../../../../../editor/common/languages.js';\nimport { TextModel } from '../../../../../editor/common/model/textModel.js';\nimport { IEditorWorkerService } from '../../../../../editor/common/services/editorWorker.js';\nimport { IModelService } from '../../../../../editor/common/services/model.js';\nimport { ITextModelService } from '../../../../../editor/common/services/resolverService.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { CellEditType, CellUri, INotebookTextModel } from '../../../notebook/common/notebookCommon.js';\nimport { INotebookEditorModelResolverService } from '../../../notebook/common/notebookEditorModelResolverService.js';\nimport { INotebookService } from '../../../notebook/common/notebookService.js';\nimport { IEditSessionEntryDiff, IModifiedEntryTelemetryInfo } from '../../common/chatEditingService.js';\nimport { IChatRequestDisablement } from '../../common/chatModel.js';\nimport { IChatEditingCheckpointTimeline } from './chatEditingCheckpointTimeline.js';\nimport { FileOperation, FileOperationType, IChatEditingTimelineState, ICheckpoint, IFileBaseline, IReconstructedFileExistsState, IReconstructedFileNotExistsState, IReconstructedFileState } from './chatEditingOperations.js';\nimport { ChatEditingSnapshotTextModelContentProvider } from './chatEditingTextModelContentProviders.js';\nimport { createSnapshot as createNotebookSnapshot, restoreSnapshot as restoreNotebookSnapshot } from './notebook/chatEditingModifiedNotebookSnapshot.js';\n\nconst START_REQUEST_EPOCH = '$$start';\nconst STOP_ID_EPOCH_PREFIX = '__epoch_';\n\ntype IReconstructedFileStateWithNotebook = IReconstructedFileNotExistsState | (Mutable<IReconstructedFileExistsState> & { notebook?: INotebookTextModel });\n\n/**\n * A filesystem delegate used by the checkpointing timeline such that\n * navigating in the timeline tracks the changes as agent-initiated.\n */\nexport interface IChatEditingTimelineFsDelegate {\n\t/** Creates a file with initial content. */\n\tcreateFile: (uri: URI, initialContent: string) => Promise<unknown>;\n\t/** Delete a URI */\n\tdeleteFile: (uri: URI) => Promise<void>;\n\t/** Rename a URI, retaining contents */\n\trenameFile: (fromUri: URI, toUri: URI) => Promise<void>;\n\t/** Set a URI contents, should create it if it does not already exist */\n\tsetContents(uri: URI, content: string, telemetryInfo: IModifiedEntryTelemetryInfo): Promise<void>;\n}\n\n/**\n * Implementation of the checkpoint-based timeline system.\n *\n * Invariants:\n * - There is at most one checkpoint or operation per epoch\n * - _checkpoints and _operations are always sorted in ascending order by epoch\n * - _currentEpoch being equal to the epoch of an operation means that\n *   operation is _not_ currently applied\n */\nexport class ChatEditingCheckpointTimelineImpl implements IChatEditingCheckpointTimeline {\n\n\tprivate _epochCounter = 0;\n\tprivate readonly _checkpoints = observableValue<readonly ICheckpoint[]>(this, []);\n\tprivate readonly _currentEpoch = observableValue<number>(this, 0);\n\tprivate readonly _operations = observableValueOpts<FileOperation[]>({ equalsFn: () => false }, []); // mutable\n\tprivate readonly _fileBaselines = new Map<string, IFileBaseline>(); // key: `${uri}::${requestId}`\n\n\t/** Gets the checkpoint, if any, we can 'undo' to. */\n\tprivate readonly _willUndoToCheckpoint = derived(reader => {\n\t\tconst currentEpoch = this._currentEpoch.read(reader);\n\t\tconst checkpoints = this._checkpoints.read(reader);\n\t\tif (checkpoints.length < 2 || currentEpoch <= checkpoints[1].epoch) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst operations = this._operations.read(reader);\n\n\t\t// Undo either to right before the current request...\n\t\tconst currentCheckpointIdx = findLastIdx(checkpoints, cp => cp.epoch < currentEpoch);\n\t\tconst startOfRequest = currentCheckpointIdx === -1 ? undefined : findLast(checkpoints, cp => cp.undoStopId === undefined, currentCheckpointIdx);\n\n\t\t// Or to the checkpoint before the last operation in this request\n\t\tconst previousOperation = findLast(operations, op => op.epoch < currentEpoch);\n\t\tconst previousCheckpoint = previousOperation && findLast(checkpoints, cp => cp.epoch < previousOperation.epoch);\n\n\t\tif (!startOfRequest) {\n\t\t\treturn previousCheckpoint;\n\t\t}\n\t\tif (!previousCheckpoint) {\n\t\t\treturn startOfRequest;\n\t\t}\n\n\t\t// Special case: if we're undoing the first edit operation, undo the entire request\n\t\tif (!operations.some(op => op.epoch > startOfRequest.epoch && op.epoch < previousCheckpoint!.epoch)) {\n\t\t\treturn startOfRequest;\n\t\t}\n\n\t\treturn previousCheckpoint.epoch > startOfRequest.epoch ? previousCheckpoint : startOfRequest;\n\t});\n\n\tpublic readonly canUndo: IObservable<boolean> = this._willUndoToCheckpoint.map(cp => !!cp);\n\n\n\t/**\n\t * Gets the epoch we'll redo this. Unlike undo this doesn't only use checkpoints\n\t * because we could potentially redo to a 'tip' operation that's not checkpointed yet.\n\t */\n\tprivate readonly _willRedoToEpoch = derived(reader => {\n\t\tconst currentEpoch = this._currentEpoch.read(reader);\n\t\tconst operations = this._operations.read(reader);\n\t\tconst checkpoints = this._checkpoints.read(reader);\n\t\tconst maxEncounteredEpoch = Math.max(operations.at(-1)?.epoch || 0, checkpoints.at(-1)?.epoch || 0);\n\t\tif (currentEpoch > maxEncounteredEpoch) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Find the next edit operation that would be applied...\n\t\tconst nextOperation = operations.find(op => op.epoch >= currentEpoch);\n\t\tconst nextCheckpoint = nextOperation && checkpoints.find(op => op.epoch > nextOperation.epoch);\n\n\t\t// And figure out where we're going if we're navigating across request\n\t\t// 1. If there is no next request or if the next target checkpoint is in\n\t\t//    the next request, navigate there.\n\t\t// 2. Otherwise, navigate to the end of the next request.\n\t\tconst currentCheckpoint = findLast(checkpoints, cp => cp.epoch < currentEpoch);\n\t\tif (currentCheckpoint && nextOperation && currentCheckpoint.requestId !== nextOperation.requestId) {\n\t\t\tconst startOfNextRequestIdx = findLastIdx(checkpoints, (cp, i) =>\n\t\t\t\tcp.undoStopId === undefined && (checkpoints[i - 1]?.requestId === currentCheckpoint.requestId));\n\t\t\tconst startOfNextRequest = startOfNextRequestIdx === -1 ? undefined : checkpoints[startOfNextRequestIdx];\n\n\t\t\tif (startOfNextRequest && nextOperation.requestId !== startOfNextRequest.requestId) {\n\t\t\t\tconst requestAfterTheNext = findFirst(checkpoints, op => op.undoStopId === undefined, startOfNextRequestIdx + 1);\n\t\t\t\tif (requestAfterTheNext) {\n\t\t\t\t\treturn requestAfterTheNext.epoch;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(\n\t\t\tnextCheckpoint?.epoch || Infinity,\n\t\t\t(maxEncounteredEpoch + 1),\n\t\t);\n\t});\n\n\tpublic readonly canRedo: IObservable<boolean> = this._willRedoToEpoch.map(e => !!e);\n\n\tpublic readonly requestDisablement: IObservable<IChatRequestDisablement[]> = derivedOpts(\n\t\t{ equalsFn: (a, b) => arraysEqual(a, b, objectsEqual) },\n\t\treader => {\n\t\t\tconst currentEpoch = this._currentEpoch.read(reader);\n\t\t\tconst operations = this._operations.read(reader);\n\t\t\tconst checkpoints = this._checkpoints.read(reader);\n\n\t\t\tconst maxEncounteredEpoch = Math.max(operations.at(-1)?.epoch || 0, checkpoints.at(-1)?.epoch || 0);\n\t\t\tif (currentEpoch > maxEncounteredEpoch) {\n\t\t\t\treturn []; // common case -- nothing undone\n\t\t\t}\n\n\t\t\tconst lastAppliedOperation = findLast(operations, op => op.epoch < currentEpoch)?.epoch || 0;\n\t\t\tconst lastAppliedRequest = findLast(checkpoints, cp => cp.epoch < currentEpoch && cp.undoStopId === undefined)?.epoch || 0;\n\t\t\tconst stopDisablingAtEpoch = Math.max(lastAppliedOperation, lastAppliedRequest);\n\n\t\t\tconst disablement = new Map<string, string | undefined>();\n\n\t\t\t// Go through the checkpoints and disable any until the one that contains the last applied operation.\n\t\t\t// Subtle: the request will first make a checkpoint with an 'undefined' undo\n\t\t\t// stop, and in this loop we'll \"automatically\" disable the entire request when\n\t\t\t// we reach that checkpoint.\n\t\t\tfor (let i = checkpoints.length - 1; i >= 0; i--) {\n\t\t\t\tconst { undoStopId, requestId, epoch } = checkpoints[i];\n\t\t\t\tif (epoch <= stopDisablingAtEpoch) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (requestId) {\n\t\t\t\t\tdisablement.set(requestId, undoStopId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [...disablement].map(([requestId, afterUndoStop]): IChatRequestDisablement => ({ requestId, afterUndoStop }));\n\t\t});\n\n\tconstructor(\n\t\tprivate readonly chatSessionResource: URI,\n\t\tprivate readonly _delegate: IChatEditingTimelineFsDelegate,\n\t\t@INotebookEditorModelResolverService private readonly _notebookEditorModelResolverService: INotebookEditorModelResolverService,\n\t\t@INotebookService private readonly _notebookService: INotebookService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IModelService private readonly _modelService: IModelService,\n\t\t@ITextModelService private readonly _textModelService: ITextModelService,\n\t\t@IEditorWorkerService private readonly _editorWorkerService: IEditorWorkerService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService\n\t) {\n\t\tthis.createCheckpoint(undefined, undefined, 'Initial State', 'Starting point before any edits');\n\t}\n\n\tpublic createCheckpoint(requestId: string | undefined, undoStopId: string | undefined, label: string, description?: string): string {\n\t\tconst existingCheckpoints = this._checkpoints.get();\n\t\tconst existing = existingCheckpoints.find(c => c.undoStopId === undoStopId && c.requestId === requestId);\n\t\tif (existing) {\n\t\t\treturn existing.checkpointId;\n\t\t}\n\n\t\tconst { checkpoints, operations } = this._getVisibleOperationsAndCheckpoints();\n\t\tconst checkpointId = generateUuid();\n\t\tconst epoch = this.incrementEpoch();\n\n\t\tcheckpoints.push({\n\t\t\tcheckpointId,\n\t\t\trequestId,\n\t\t\tundoStopId,\n\t\t\tepoch,\n\t\t\tlabel,\n\t\t\tdescription\n\t\t});\n\n\t\ttransaction(tx => {\n\t\t\tthis._checkpoints.set(checkpoints, tx);\n\t\t\tthis._operations.set(operations, tx);\n\t\t\tthis._currentEpoch.set(epoch + 1, tx);\n\t\t});\n\n\t\treturn checkpointId;\n\t}\n\n\tpublic async undoToLastCheckpoint(): Promise<void> {\n\t\tconst checkpoint = this._willUndoToCheckpoint.get();\n\t\tif (checkpoint) {\n\t\t\tawait this.navigateToCheckpoint(checkpoint.checkpointId);\n\t\t}\n\t}\n\n\tpublic async redoToNextCheckpoint(): Promise<void> {\n\t\tconst targetEpoch = this._willRedoToEpoch.get();\n\t\tif (targetEpoch) {\n\t\t\tawait this._navigateToEpoch(targetEpoch);\n\t\t}\n\t}\n\n\tpublic navigateToCheckpoint(checkpointId: string): Promise<void> {\n\t\tconst targetCheckpoint = this._getCheckpoint(checkpointId);\n\t\tif (!targetCheckpoint) {\n\t\t\tthrow new Error(`Checkpoint ${checkpointId} not found`);\n\t\t}\n\n\t\tif (targetCheckpoint.undoStopId === undefined) {\n\t\t\t// If we're navigating to the start of a request, we want to restore the file\n\t\t\t// to whatever baseline we captured, _not_ the result state from the prior request\n\t\t\t// because there may have been user changes in the meantime. But we still want\n\t\t\t// to set the epoch marking that checkpoint as having been undone (the second\n\t\t\t// arg below) so that disablement works and so it's discarded if appropriate later.\n\t\t\treturn this._navigateToEpoch(targetCheckpoint.epoch + 1, targetCheckpoint.epoch);\n\t\t} else {\n\t\t\treturn this._navigateToEpoch(targetCheckpoint.epoch + 1);\n\t\t}\n\n\t}\n\n\tpublic getContentURIAtStop(requestId: string, fileURI: URI, stopId: string | undefined): URI {\n\t\treturn ChatEditingSnapshotTextModelContentProvider.getSnapshotFileURI(this.chatSessionResource, requestId, stopId, fileURI.path);\n\t}\n\n\tprivate async _navigateToEpoch(restoreToEpoch: number, navigateToEpoch = restoreToEpoch): Promise<void> {\n\t\tconst currentEpoch = this._currentEpoch.get();\n\t\tif (currentEpoch !== restoreToEpoch) {\n\t\t\tconst urisToRestore = await this._applyFileSystemOperations(currentEpoch, restoreToEpoch);\n\n\t\t\t// Reconstruct content for files affected by operations in the range\n\t\t\tawait this._reconstructAllFileContents(restoreToEpoch, urisToRestore);\n\t\t}\n\n\t\t// Update current epoch\n\t\tthis._currentEpoch.set(navigateToEpoch, undefined);\n\t}\n\n\tprivate _getCheckpoint(checkpointId: string): ICheckpoint | undefined {\n\t\treturn this._checkpoints.get().find(c => c.checkpointId === checkpointId);\n\t}\n\n\tpublic incrementEpoch() {\n\t\treturn this._epochCounter++;\n\t}\n\n\tpublic recordFileOperation(operation: FileOperation): void {\n\t\tconst { currentEpoch, checkpoints, operations } = this._getVisibleOperationsAndCheckpoints();\n\t\tif (operation.epoch < currentEpoch) {\n\t\t\tthrow new Error(`Cannot record operation at epoch ${operation.epoch} when current epoch is ${currentEpoch}`);\n\t\t}\n\n\t\toperations.push(operation);\n\t\ttransaction(tx => {\n\t\t\tthis._checkpoints.set(checkpoints, tx);\n\t\t\tthis._operations.set(operations, tx);\n\t\t\tthis._currentEpoch.set(operation.epoch + 1, tx);\n\t\t});\n\t}\n\n\tprivate _getVisibleOperationsAndCheckpoints() {\n\t\tconst currentEpoch = this._currentEpoch.get();\n\t\tconst checkpoints = this._checkpoints.get();\n\t\tconst operations = this._operations.get();\n\n\t\treturn {\n\t\t\tcurrentEpoch,\n\t\t\tcheckpoints: checkpoints.filter(c => c.epoch < currentEpoch),\n\t\t\toperations: operations.filter(op => op.epoch < currentEpoch)\n\t\t};\n\t}\n\n\tpublic recordFileBaseline(baseline: IFileBaseline): void {\n\t\tconst key = this._getBaselineKey(baseline.uri, baseline.requestId);\n\t\tthis._fileBaselines.set(key, baseline);\n\t}\n\n\tprivate _getFileBaseline(uri: URI, requestId: string): IFileBaseline | undefined {\n\t\tconst key = this._getBaselineKey(uri, requestId);\n\t\treturn this._fileBaselines.get(key);\n\t}\n\n\tpublic hasFileBaseline(uri: URI, requestId: string): boolean {\n\t\tconst key = this._getBaselineKey(uri, requestId);\n\t\treturn this._fileBaselines.has(key);\n\t}\n\n\tpublic async getContentAtStop(requestId: string, contentURI: URI, stopId: string | undefined) {\n\t\tlet toEpoch: number | undefined;\n\t\tif (stopId?.startsWith(STOP_ID_EPOCH_PREFIX)) {\n\t\t\ttoEpoch = Number(stopId.slice(STOP_ID_EPOCH_PREFIX.length));\n\t\t} else {\n\t\t\ttoEpoch = this._checkpoints.get().find(c => c.requestId === requestId && c.undoStopId === stopId)?.epoch;\n\t\t}\n\n\t\t// The content URI doesn't preserve the original scheme or authority. Look through\n\t\t// to find the operation that touched that path to get its actual URI\n\t\tconst fileURI = this._getTimelineCanonicalUriForPath(contentURI);\n\n\t\tif (!toEpoch || !fileURI) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst baseline = await this._findBestBaselineForFile(fileURI, toEpoch, requestId);\n\t\tif (!baseline) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst operations = this._getFileOperationsInRange(fileURI, baseline.epoch, toEpoch);\n\t\tconst replayed = await this._replayOperations(baseline, operations);\n\t\treturn replayed.exists ? replayed.content : undefined;\n\t}\n\n\tprivate _getTimelineCanonicalUriForPath(contentURI: URI) {\n\t\tfor (const it of [this._fileBaselines.values(), this._operations.get()]) {\n\t\t\tfor (const thing of it) {\n\t\t\t\tif (thing.uri.path === contentURI.path) {\n\t\t\t\t\treturn thing.uri;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Creates a callback that is invoked when data at the stop changes. This\n\t * will not fire initially and may be debounced internally.\n\t */\n\tpublic onDidChangeContentsAtStop(requestId: string, contentURI: URI, stopId: string | undefined, callback: (data: string) => void): IDisposable {\n\t\t// The only case where we have data that updates is if we have an epoch pointer that's\n\t\t// after our know epochs (e.g. pointing to the end file state after all operations).\n\t\t// If this isn't the case, abort.\n\t\tif (!stopId || !stopId.startsWith(STOP_ID_EPOCH_PREFIX)) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tconst target = Number(stopId.slice(STOP_ID_EPOCH_PREFIX.length));\n\t\tif (target <= this._epochCounter) {\n\t\t\treturn Disposable.None; // already finalized\n\t\t}\n\n\t\tconst store = new DisposableStore();\n\t\tconst scheduler = store.add(new ThrottledDelayer(500));\n\n\t\tstore.add(Event.fromObservableLight(this._operations)(() => {\n\t\t\tscheduler.trigger(async () => {\n\t\t\t\tif (this._operations.get().at(-1)?.epoch! >= target) {\n\t\t\t\t\tstore.dispose();\n\t\t\t\t}\n\n\t\t\t\tconst content = await this.getContentAtStop(requestId, contentURI, stopId);\n\t\t\t\tif (content !== undefined) {\n\t\t\t\t\tcallback(content);\n\t\t\t\t}\n\t\t\t});\n\t\t}));\n\n\t\treturn store;\n\t}\n\n\tprivate _getCheckpointBeforeEpoch(epoch: number, reader?: IReader) {\n\t\treturn findLast(this._checkpoints.read(reader), c => c.epoch <= epoch);\n\t}\n\n\tprivate async _reconstructFileState(uri: URI, targetEpoch: number): Promise<IReconstructedFileState> {\n\t\tconst targetCheckpoint = this._getCheckpointBeforeEpoch(targetEpoch);\n\t\tif (!targetCheckpoint) {\n\t\t\tthrow new Error(`Checkpoint for epoch ${targetEpoch} not found`);\n\t\t}\n\n\t\t// Find the most appropriate baseline for this file\n\t\tconst baseline = await this._findBestBaselineForFile(uri, targetEpoch, targetCheckpoint.requestId || '');\n\t\tif (!baseline) {\n\t\t\t// File doesn't exist at this checkpoint\n\t\t\treturn {\n\t\t\t\texists: false,\n\t\t\t\turi,\n\t\t\t};\n\t\t}\n\n\t\t// Get operations that affect this file from baseline to target checkpoint\n\t\tconst operations = this._getFileOperationsInRange(uri, baseline.epoch, targetEpoch);\n\n\t\t// Replay operations to reconstruct state\n\t\treturn this._replayOperations(baseline, operations);\n\t}\n\n\tpublic getStateForPersistence(): IChatEditingTimelineState {\n\t\treturn {\n\t\t\tcheckpoints: this._checkpoints.get(),\n\t\t\tcurrentEpoch: this._currentEpoch.get(),\n\t\t\tfileBaselines: [...this._fileBaselines],\n\t\t\toperations: this._operations.get(),\n\t\t\tepochCounter: this._epochCounter,\n\t\t};\n\t}\n\n\tpublic restoreFromState(state: IChatEditingTimelineState, tx: ITransaction): void {\n\t\tthis._checkpoints.set(state.checkpoints, tx);\n\t\tthis._currentEpoch.set(state.currentEpoch, tx);\n\t\tthis._operations.set(state.operations.slice(), tx);\n\t\tthis._epochCounter = state.epochCounter;\n\n\t\tthis._fileBaselines.clear();\n\t\tfor (const [key, baseline] of state.fileBaselines) {\n\t\t\tthis._fileBaselines.set(key, baseline);\n\t\t}\n\t}\n\n\tpublic getCheckpointIdForRequest(requestId: string, undoStopId?: string): string | undefined {\n\t\tconst checkpoints = this._checkpoints.get();\n\t\treturn checkpoints.find(c => c.requestId === requestId && c.undoStopId === undoStopId)?.checkpointId;\n\t}\n\n\tprivate async _reconstructAllFileContents(targetEpoch: number, filesToReconstruct: ResourceSet): Promise<void> {\n\t\tawait Promise.all(Array.from(filesToReconstruct).map(async uri => {\n\t\t\tconst reconstructedState = await this._reconstructFileState(uri, targetEpoch);\n\t\t\tif (reconstructedState.exists) {\n\t\t\t\tawait this._delegate.setContents(reconstructedState.uri, reconstructedState.content, reconstructedState.telemetryInfo);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate _getBaselineKey(uri: URI, requestId: string): string {\n\t\treturn `${uri.toString()}::${requestId}`;\n\t}\n\n\tprivate async _findBestBaselineForFile(uri: URI, epoch: number, requestId: string): Promise<IFileBaseline | undefined> {\n\t\t// First, iterate backwards through operations before the target checkpoint\n\t\t// to see if the file was created/re-created more recently than any baseline\n\n\t\tlet currentRequestId = requestId;\n\t\tconst operations = this._operations.get();\n\t\tfor (let i = operations.length - 1; i >= 0; i--) {\n\t\t\tconst operation = operations[i];\n\t\t\tif (operation.epoch > epoch) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If the file was just created, use that as its updated baseline\n\t\t\tif (operation.type === FileOperationType.Create && isEqual(operation.uri, uri)) {\n\t\t\t\treturn {\n\t\t\t\t\turi: operation.uri,\n\t\t\t\t\trequestId: operation.requestId,\n\t\t\t\t\tcontent: operation.initialContent,\n\t\t\t\t\tepoch: operation.epoch,\n\t\t\t\t\ttelemetryInfo: operation.telemetryInfo,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If the file was renamed to this URI, use its old contents as the baseline\n\t\t\tif (operation.type === FileOperationType.Rename && isEqual(operation.newUri, uri)) {\n\t\t\t\tconst prev = await this._findBestBaselineForFile(operation.oldUri, operation.epoch, operation.requestId);\n\t\t\t\tif (!prev) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\n\t\t\t\tconst operations = this._getFileOperationsInRange(operation.oldUri, prev.epoch, operation.epoch);\n\t\t\t\tconst replayed = await this._replayOperations(prev, operations);\n\t\t\t\treturn {\n\t\t\t\t\turi: uri,\n\t\t\t\t\tepoch: operation.epoch,\n\t\t\t\t\tcontent: replayed.exists ? replayed.content : '',\n\t\t\t\t\trequestId: operation.requestId,\n\t\t\t\t\ttelemetryInfo: prev.telemetryInfo,\n\t\t\t\t\tnotebookViewType: replayed.exists ? replayed.notebookViewType : undefined,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// When the request ID changes, check if we have a baseline for the current request\n\t\t\tif (currentRequestId && operation.requestId !== currentRequestId) {\n\t\t\t\tconst baseline = this._getFileBaseline(uri, currentRequestId);\n\t\t\t\tif (baseline) {\n\t\t\t\t\treturn baseline;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentRequestId = operation.requestId;\n\t\t}\n\n\t\t// Check the final request ID for a baseline\n\t\treturn this._getFileBaseline(uri, currentRequestId);\n\t}\n\n\tprivate _getFileOperationsInRange(uri: URI, fromEpoch: number, toEpoch: number): readonly FileOperation[] {\n\t\treturn this._operations.get().filter(op => {\n\t\t\tconst cellUri = CellUri.parse(op.uri);\n\t\t\treturn op.epoch >= fromEpoch &&\n\t\t\t\top.epoch < toEpoch &&\n\t\t\t\t(isEqual(op.uri, uri) || (cellUri && isEqual(cellUri.notebook, uri)));\n\t\t}).sort((a, b) => a.epoch - b.epoch);\n\t}\n\n\tprivate async _replayOperations(baseline: IFileBaseline, operations: readonly FileOperation[]): Promise<IReconstructedFileState> {\n\t\tlet currentState: IReconstructedFileStateWithNotebook = {\n\t\t\texists: true,\n\t\t\tcontent: baseline.content,\n\t\t\turi: baseline.uri,\n\t\t\ttelemetryInfo: baseline.telemetryInfo,\n\t\t};\n\n\t\tif (baseline.notebookViewType) {\n\t\t\tcurrentState.notebook = await this._notebookEditorModelResolverService.createUntitledNotebookTextModel(baseline.notebookViewType);\n\t\t\tif (baseline.content) {\n\t\t\t\trestoreNotebookSnapshot(currentState.notebook, baseline.content);\n\t\t\t}\n\t\t}\n\n\t\tfor (const operation of operations) {\n\t\t\tcurrentState = await this._applyOperationToState(currentState, operation, baseline.telemetryInfo);\n\t\t}\n\n\t\tif (currentState.exists && currentState.notebook) {\n\t\t\tconst info = await this._notebookService.withNotebookDataProvider(currentState.notebook.viewType);\n\t\t\tcurrentState.content = createNotebookSnapshot(currentState.notebook, info.serializer.options, this._configurationService);\n\t\t\tcurrentState.notebook.dispose();\n\t\t}\n\n\t\treturn currentState;\n\t}\n\n\tprivate async _applyOperationToState(state: IReconstructedFileStateWithNotebook, operation: FileOperation, telemetryInfo: IModifiedEntryTelemetryInfo): Promise<IReconstructedFileStateWithNotebook> {\n\t\tswitch (operation.type) {\n\t\t\tcase FileOperationType.Create: {\n\t\t\t\tif (state.exists && state.notebook) {\n\t\t\t\t\tstate.notebook.dispose();\n\t\t\t\t}\n\n\t\t\t\tlet notebook: INotebookTextModel | undefined;\n\t\t\t\tif (operation.notebookViewType) {\n\t\t\t\t\tnotebook = await this._notebookEditorModelResolverService.createUntitledNotebookTextModel(operation.notebookViewType);\n\t\t\t\t\tif (operation.initialContent) {\n\t\t\t\t\t\trestoreNotebookSnapshot(notebook, operation.initialContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\texists: true,\n\t\t\t\t\tcontent: operation.initialContent,\n\t\t\t\t\turi: operation.uri,\n\t\t\t\t\ttelemetryInfo,\n\t\t\t\t\tnotebookViewType: operation.notebookViewType,\n\t\t\t\t\tnotebook,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcase FileOperationType.Delete:\n\t\t\t\tif (state.exists && state.notebook) {\n\t\t\t\t\tstate.notebook.dispose();\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\texists: false,\n\t\t\t\t\turi: operation.uri\n\t\t\t\t};\n\n\t\t\tcase FileOperationType.Rename:\n\t\t\t\treturn {\n\t\t\t\t\t...state,\n\t\t\t\t\turi: operation.newUri\n\t\t\t\t};\n\n\t\t\tcase FileOperationType.TextEdit: {\n\t\t\t\tif (!state.exists) {\n\t\t\t\t\tthrow new Error('Cannot apply text edits to non-existent file');\n\t\t\t\t}\n\n\t\t\t\tconst nbCell = operation.cellIndex !== undefined && state.notebook?.cells.at(operation.cellIndex);\n\t\t\t\tif (nbCell) {\n\t\t\t\t\tconst newContent = this._applyTextEditsToContent(nbCell.getValue(), operation.edits);\n\t\t\t\t\tstate.notebook!.applyEdits([{\n\t\t\t\t\t\teditType: CellEditType.Replace,\n\t\t\t\t\t\tindex: operation.cellIndex,\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\tcells: [{ cellKind: nbCell.cellKind, language: nbCell.language, mime: nbCell.language, source: newContent, outputs: nbCell.outputs }]\n\t\t\t\t\t}], true, undefined, () => undefined, undefined);\n\t\t\t\t\treturn state;\n\t\t\t\t}\n\n\t\t\t\t// Apply text edits using a temporary text model\n\t\t\t\treturn {\n\t\t\t\t\t...state,\n\t\t\t\t\tcontent: this._applyTextEditsToContent(state.content, operation.edits)\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase FileOperationType.NotebookEdit:\n\t\t\t\tif (!state.exists) {\n\t\t\t\t\tthrow new Error('Cannot apply notebook edits to non-existent file');\n\t\t\t\t}\n\t\t\t\tif (!state.notebook) {\n\t\t\t\t\tthrow new Error('Cannot apply notebook edits to non-notebook file');\n\t\t\t\t}\n\n\t\t\t\tstate.notebook.applyEdits(operation.cellEdits.slice(), true, undefined, () => undefined, undefined);\n\t\t\t\treturn state;\n\n\t\t\tdefault:\n\t\t\t\tassertNever(operation);\n\t\t}\n\t}\n\n\tprivate async _applyFileSystemOperations(fromEpoch: number, toEpoch: number): Promise<ResourceSet> {\n\t\tconst isMovingForward = toEpoch > fromEpoch;\n\t\tconst operations = this._operations.get().filter(op => {\n\t\t\tif (isMovingForward) {\n\t\t\t\treturn op.epoch >= fromEpoch && op.epoch < toEpoch;\n\t\t\t} else {\n\t\t\t\treturn op.epoch < fromEpoch && op.epoch >= toEpoch;\n\t\t\t}\n\t\t}).sort((a, b) => isMovingForward ? a.epoch - b.epoch : b.epoch - a.epoch);\n\n\t\t// Apply file system operations in the correct direction\n\t\tconst urisToRestore = new ResourceSet();\n\t\tfor (const operation of operations) {\n\t\t\tawait this._applyFileSystemOperation(operation, isMovingForward, urisToRestore);\n\t\t}\n\n\t\treturn urisToRestore;\n\t}\n\n\tprivate async _applyFileSystemOperation(operation: FileOperation, isMovingForward: boolean, urisToRestore: ResourceSet): Promise<void> {\n\t\tswitch (operation.type) {\n\t\t\tcase FileOperationType.Create:\n\t\t\t\tif (isMovingForward) {\n\t\t\t\t\tawait this._delegate.createFile(operation.uri, operation.initialContent);\n\t\t\t\t\turisToRestore.add(operation.uri);\n\t\t\t\t} else {\n\t\t\t\t\tawait this._delegate.deleteFile(operation.uri);\n\t\t\t\t\turisToRestore.delete(operation.uri);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase FileOperationType.Delete:\n\t\t\t\tif (isMovingForward) {\n\t\t\t\t\tawait this._delegate.deleteFile(operation.uri);\n\t\t\t\t\turisToRestore.delete(operation.uri);\n\t\t\t\t} else {\n\t\t\t\t\tawait this._delegate.createFile(operation.uri, operation.finalContent);\n\t\t\t\t\turisToRestore.add(operation.uri);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase FileOperationType.Rename:\n\t\t\t\tif (isMovingForward) {\n\t\t\t\t\tawait this._delegate.renameFile(operation.oldUri, operation.newUri);\n\t\t\t\t\turisToRestore.delete(operation.oldUri);\n\t\t\t\t\turisToRestore.add(operation.newUri);\n\t\t\t\t} else {\n\t\t\t\t\tawait this._delegate.renameFile(operation.newUri, operation.oldUri);\n\t\t\t\t\turisToRestore.delete(operation.newUri);\n\t\t\t\t\turisToRestore.add(operation.oldUri);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Text and notebook edits don't affect file system structure\n\t\t\tcase FileOperationType.TextEdit:\n\t\t\tcase FileOperationType.NotebookEdit:\n\t\t\t\turisToRestore.add(CellUri.parse(operation.uri)?.notebook ?? operation.uri);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tassertNever(operation);\n\t\t}\n\t}\n\n\tprivate _applyTextEditsToContent(content: string, edits: readonly TextEdit[]): string {\n\t\t// Use the example pattern provided by the user\n\t\tconst makeModel = (uri: URI, contents: string) => this._instantiationService.createInstance(TextModel, contents, '', this._modelService.getCreationOptions('', uri, true), uri);\n\n\t\t// Create a temporary URI for the model\n\t\tconst tempUri = URI.from({ scheme: 'temp', path: `/temp-${Date.now()}.txt` });\n\t\tconst model = makeModel(tempUri, content);\n\n\t\ttry {\n\t\t\t// Apply edits\n\t\t\tmodel.applyEdits(edits.map(edit => ({\n\t\t\t\trange: {\n\t\t\t\t\tstartLineNumber: edit.range.startLineNumber,\n\t\t\t\t\tstartColumn: edit.range.startColumn,\n\t\t\t\t\tendLineNumber: edit.range.endLineNumber,\n\t\t\t\t\tendColumn: edit.range.endColumn\n\t\t\t\t},\n\t\t\t\ttext: edit.text\n\t\t\t})));\n\n\t\t\treturn model.getValue();\n\t\t} finally {\n\t\t\tmodel.dispose();\n\t\t}\n\t}\n\n\tpublic getEntryDiffBetweenStops(uri: URI, requestId: string | undefined, stopId: string | undefined): IObservable<IEditSessionEntryDiff | undefined> {\n\t\tconst epochs = derivedOpts<{ start: ICheckpoint; end: ICheckpoint | undefined }>({ equalsFn: (a, b) => a.start === b.start && a.end === b.end }, reader => {\n\t\t\tconst checkpoints = this._checkpoints.read(reader);\n\t\t\tconst startIndex = checkpoints.findIndex(c => c.requestId === requestId && c.undoStopId === stopId);\n\t\t\treturn { start: checkpoints[startIndex], end: checkpoints[startIndex + 1] };\n\t\t});\n\n\t\treturn this._getEntryDiffBetweenEpochs(uri, epochs);\n\t}\n\n\tpublic getEntryDiffBetweenRequests(uri: URI, startRequestId: string, stopRequestId: string): IObservable<IEditSessionEntryDiff | undefined> {\n\t\tconst epochs = derivedOpts<{ start: ICheckpoint; end: ICheckpoint | undefined }>({ equalsFn: (a, b) => a.start === b.start && a.end === b.end }, reader => {\n\t\t\tconst checkpoints = this._checkpoints.read(reader);\n\t\t\tconst startIndex = checkpoints.findIndex(c => c.requestId === startRequestId);\n\t\t\tconst start = startIndex === -1 ? checkpoints[0] : checkpoints[startIndex];\n\t\t\tconst end = checkpoints.find(c => c.requestId === stopRequestId) || findFirst(checkpoints, c => c.requestId !== startRequestId, startIndex) || checkpoints[checkpoints.length - 1];\n\t\t\treturn { start, end };\n\t\t});\n\n\t\treturn this._getEntryDiffBetweenEpochs(uri, epochs);\n\t}\n\n\tprivate _getEntryDiffBetweenEpochs(uri: URI, epochs: IObservable<{ start: ICheckpoint | undefined; end: ICheckpoint | undefined }>): IObservable<IEditSessionEntryDiff | undefined> {\n\t\tconst modelRefsPromise = derived(this, (reader) => {\n\t\t\tconst { start, end } = epochs.read(reader);\n\t\t\tif (!start) { return undefined; }\n\n\t\t\tconst store = reader.store.add(new DisposableStore());\n\t\t\tconst promise = Promise.all([\n\t\t\t\tthis._textModelService.createModelReference(this.getContentURIAtStop(start.requestId || START_REQUEST_EPOCH, uri, STOP_ID_EPOCH_PREFIX + start.epoch)),\n\t\t\t\tthis._textModelService.createModelReference(this.getContentURIAtStop(end?.requestId || start.requestId || START_REQUEST_EPOCH, uri, STOP_ID_EPOCH_PREFIX + (end?.epoch || Number.MAX_SAFE_INTEGER))),\n\t\t\t]).then(refs => {\n\t\t\t\tif (store.isDisposed) {\n\t\t\t\t\trefs.forEach(r => r.dispose());\n\t\t\t\t} else {\n\t\t\t\t\trefs.forEach(r => store.add(r));\n\t\t\t\t}\n\n\t\t\t\treturn { refs, isFinal: !!end };\n\t\t\t});\n\n\t\t\treturn new ObservablePromise(promise);\n\t\t});\n\n\t\tconst resolvedModels = derived(reader => {\n\t\t\tconst refs2 = modelRefsPromise.read(reader)?.promiseResult.read(reader);\n\t\t\treturn refs2?.data && {\n\t\t\t\tisFinal: refs2.data.isFinal,\n\t\t\t\trefs: refs2.data.refs.map(r => ({\n\t\t\t\t\tmodel: r.object.textEditorModel,\n\t\t\t\t\tonChange: observableSignalFromEvent(this, r.object.textEditorModel.onDidChangeContent.bind(r.object.textEditorModel)),\n\t\t\t\t})),\n\t\t\t};\n\t\t});\n\n\t\tconst diff = derived((reader): ObservablePromise<IEditSessionEntryDiff> | undefined => {\n\t\t\tconst modelsData = resolvedModels.read(reader);\n\t\t\tif (!modelsData) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { refs, isFinal } = modelsData;\n\n\t\t\trefs.forEach(m => m.onChange.read(reader)); // re-read when contents change\n\n\t\t\tconst promise = this._computeDiff(refs[0].model.uri, refs[1].model.uri, isFinal);\n\t\t\treturn new ObservablePromise(promise);\n\t\t});\n\n\t\treturn derived(reader => {\n\t\t\treturn diff.read(reader)?.promiseResult.read(reader)?.data || undefined;\n\t\t});\n\t}\n\n\tprivate _computeDiff(originalUri: URI, modifiedUri: URI, isFinal: boolean): Promise<IEditSessionEntryDiff> {\n\t\treturn this._editorWorkerService.computeDiff(\n\t\t\toriginalUri,\n\t\t\tmodifiedUri,\n\t\t\t{ ignoreTrimWhitespace: false, computeMoves: false, maxComputationTimeMs: 3000 },\n\t\t\t'advanced'\n\t\t).then((diff): IEditSessionEntryDiff => {\n\t\t\tconst entryDiff: IEditSessionEntryDiff = {\n\t\t\t\toriginalURI: originalUri,\n\t\t\t\tmodifiedURI: modifiedUri,\n\t\t\t\tidentical: !!diff?.identical,\n\t\t\t\tisFinal,\n\t\t\t\tquitEarly: !diff || diff.quitEarly,\n\t\t\t\tadded: 0,\n\t\t\t\tremoved: 0,\n\t\t\t};\n\t\t\tif (diff) {\n\t\t\t\tfor (const change of diff.changes) {\n\t\t\t\t\tentryDiff.removed += change.original.endLineNumberExclusive - change.original.startLineNumber;\n\t\t\t\t\tentryDiff.added += change.modified.endLineNumberExclusive - change.modified.startLineNumber;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn entryDiff;\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals as arraysEqual } from '../../../../../base/common/arrays.js';\nimport { findFirst, findLast, findLastIdx } from '../../../../../base/common/arraysFind.js';\nimport { assertNever } from '../../../../../base/common/assert.js';\nimport { ThrottledDelayer } from '../../../../../base/common/async.js';\nimport { Event } from '../../../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable } from '../../../../../base/common/lifecycle.js';\nimport { ResourceSet } from '../../../../../base/common/map.js';\nimport { equals as objectsEqual } from '../../../../../base/common/objects.js';\nimport { derived, derivedOpts, IObservable, IReader, ITransaction, ObservablePromise, observableSignalFromEvent, observableValue, observableValueOpts, transaction } from '../../../../../base/common/observable.js';\nimport { isEqual } from '../../../../../base/common/resources.js';\nimport { Mutable } from '../../../../../base/common/types.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { generateUuid } from '../../../../../base/common/uuid.js';\nimport { TextEdit } from '../../../../../editor/common/languages.js';\nimport { TextModel } from '../../../../../editor/common/model/textModel.js';\nimport { IEditorWorkerService } from '../../../../../editor/common/services/editorWorker.js';\nimport { IModelService } from '../../../../../editor/common/services/model.js';\nimport { ITextModelService } from '../../../../../editor/common/services/resolverService.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { CellEditType, CellUri, INotebookTextModel } from '../../../notebook/common/notebookCommon.js';\nimport { INotebookEditorModelResolverService } from '../../../notebook/common/notebookEditorModelResolverService.js';\nimport { INotebookService } from '../../../notebook/common/notebookService.js';\nimport { IEditSessionEntryDiff, IModifiedEntryTelemetryInfo } from '../../common/chatEditingService.js';\nimport { IChatRequestDisablement } from '../../common/chatModel.js';\nimport { IChatEditingCheckpointTimeline } from './chatEditingCheckpointTimeline.js';\nimport { FileOperation, FileOperationType, IChatEditingTimelineState, ICheckpoint, IFileBaseline, IReconstructedFileExistsState, IReconstructedFileNotExistsState, IReconstructedFileState } from './chatEditingOperations.js';\nimport { ChatEditingSnapshotTextModelContentProvider } from './chatEditingTextModelContentProviders.js';\nimport { createSnapshot as createNotebookSnapshot, restoreSnapshot as restoreNotebookSnapshot } from './notebook/chatEditingModifiedNotebookSnapshot.js';\n\nconst START_REQUEST_EPOCH = '$$start';\nconst STOP_ID_EPOCH_PREFIX = '__epoch_';\n\ntype IReconstructedFileStateWithNotebook = IReconstructedFileNotExistsState | (Mutable<IReconstructedFileExistsState> & { notebook?: INotebookTextModel });\n\n/**\n * A filesystem delegate used by the checkpointing timeline such that\n * navigating in the timeline tracks the changes as agent-initiated.\n */\nexport interface IChatEditingTimelineFsDelegate {\n\t/** Creates a file with initial content. */\n\tcreateFile: (uri: URI, initialContent: string) => Promise<unknown>;\n\t/** Delete a URI */\n\tdeleteFile: (uri: URI) => Promise<void>;\n\t/** Rename a URI, retaining contents */\n\trenameFile: (fromUri: URI, toUri: URI) => Promise<void>;\n\t/** Set a URI contents, should create it if it does not already exist */\n\tsetContents(uri: URI, content: string, telemetryInfo: IModifiedEntryTelemetryInfo): Promise<void>;\n}\n\n/**\n * Implementation of the checkpoint-based timeline system.\n *\n * Invariants:\n * - There is at most one checkpoint or operation per epoch\n * - _checkpoints and _operations are always sorted in ascending order by epoch\n * - _currentEpoch being equal to the epoch of an operation means that\n *   operation is _not_ currently applied\n */\nexport class ChatEditingCheckpointTimelineImpl implements IChatEditingCheckpointTimeline {\n\n\tprivate _epochCounter = 0;\n\tprivate readonly _checkpoints = observableValue<readonly ICheckpoint[]>(this, []);\n\tprivate readonly _currentEpoch = observableValue<number>(this, 0);\n\tprivate readonly _operations = observableValueOpts<FileOperation[]>({ equalsFn: () => false }, []); // mutable\n\tprivate readonly _fileBaselines = new Map<string, IFileBaseline>(); // key: `${uri}::${requestId}`\n\n\t/** Gets the checkpoint, if any, we can 'undo' to. */\n\tprivate readonly _willUndoToCheckpoint = derived(reader => {\n\t\tconst currentEpoch = this._currentEpoch.read(reader);\n\t\tconst checkpoints = this._checkpoints.read(reader);\n\t\tif (checkpoints.length < 2 || currentEpoch <= checkpoints[1].epoch) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst operations = this._operations.read(reader);\n\n\t\t// Undo either to right before the current request...\n\t\tconst currentCheckpointIdx = findLastIdx(checkpoints, cp => cp.epoch < currentEpoch);\n\t\tconst startOfRequest = currentCheckpointIdx === -1 ? undefined : findLast(checkpoints, cp => cp.undoStopId === undefined, currentCheckpointIdx);\n\n\t\t// Or to the checkpoint before the last operation in this request\n\t\tconst previousOperation = findLast(operations, op => op.epoch < currentEpoch);\n\t\tconst previousCheckpoint = previousOperation && findLast(checkpoints, cp => cp.epoch < previousOperation.epoch);\n\n\t\tif (!startOfRequest) {\n\t\t\treturn previousCheckpoint;\n\t\t}\n\t\tif (!previousCheckpoint) {\n\t\t\treturn startOfRequest;\n\t\t}\n\n\t\t// Special case: if we're undoing the first edit operation, undo the entire request\n\t\tif (!operations.some(op => op.epoch > startOfRequest.epoch && op.epoch < previousCheckpoint!.epoch)) {\n\t\t\treturn startOfRequest;\n\t\t}\n\n\t\treturn previousCheckpoint.epoch > startOfRequest.epoch ? previousCheckpoint : startOfRequest;\n\t});\n\n\tpublic readonly canUndo: IObservable<boolean> = this._willUndoToCheckpoint.map(cp => !!cp);\n\n\n\t/**\n\t * Gets the epoch we'll redo this. Unlike undo this doesn't only use checkpoints\n\t * because we could potentially redo to a 'tip' operation that's not checkpointed yet.\n\t */\n\tprivate readonly _willRedoToEpoch = derived(reader => {\n\t\tconst currentEpoch = this._currentEpoch.read(reader);\n\t\tconst operations = this._operations.read(reader);\n\t\tconst checkpoints = this._checkpoints.read(reader);\n\t\tconst maxEncounteredEpoch = Math.max(operations.at(-1)?.epoch || 0, checkpoints.at(-1)?.epoch || 0);\n\t\tif (currentEpoch > maxEncounteredEpoch) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Find the next edit operation that would be applied...\n\t\tconst nextOperation = operations.find(op => op.epoch >= currentEpoch);\n\t\tconst nextCheckpoint = nextOperation && checkpoints.find(op => op.epoch > nextOperation.epoch);\n\n\t\t// And figure out where we're going if we're navigating across request\n\t\t// 1. If there is no next request or if the next target checkpoint is in\n\t\t//    the next request, navigate there.\n\t\t// 2. Otherwise, navigate to the end of the next request.\n\t\tconst currentCheckpoint = findLast(checkpoints, cp => cp.epoch < currentEpoch);\n\t\tif (currentCheckpoint && nextOperation && currentCheckpoint.requestId !== nextOperation.requestId) {\n\t\t\tconst startOfNextRequestIdx = findLastIdx(checkpoints, (cp, i) =>\n\t\t\t\tcp.undoStopId === undefined && (checkpoints[i - 1]?.requestId === currentCheckpoint.requestId));\n\t\t\tconst startOfNextRequest = startOfNextRequestIdx === -1 ? undefined : checkpoints[startOfNextRequestIdx];\n\n\t\t\tif (startOfNextRequest && nextOperation.requestId !== startOfNextRequest.requestId) {\n\t\t\t\tconst requestAfterTheNext = findFirst(checkpoints, op => op.undoStopId === undefined, startOfNextRequestIdx + 1);\n\t\t\t\tif (requestAfterTheNext) {\n\t\t\t\t\treturn requestAfterTheNext.epoch;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(\n\t\t\tnextCheckpoint?.epoch || Infinity,\n\t\t\t(maxEncounteredEpoch + 1),\n\t\t);\n\t});\n\n\tpublic readonly canRedo: IObservable<boolean> = this._willRedoToEpoch.map(e => !!e);\n\n\tpublic readonly requestDisablement: IObservable<IChatRequestDisablement[]> = derivedOpts(\n\t\t{ equalsFn: (a, b) => arraysEqual(a, b, objectsEqual) },\n\t\treader => {\n\t\t\tconst currentEpoch = this._currentEpoch.read(reader);\n\t\t\tconst operations = this._operations.read(reader);\n\t\t\tconst checkpoints = this._checkpoints.read(reader);\n\n\t\t\tconst maxEncounteredEpoch = Math.max(operations.at(-1)?.epoch || 0, checkpoints.at(-1)?.epoch || 0);\n\t\t\tif (currentEpoch > maxEncounteredEpoch) {\n\t\t\t\treturn []; // common case -- nothing undone\n\t\t\t}\n\n\t\t\tconst lastAppliedOperation = findLast(operations, op => op.epoch < currentEpoch)?.epoch || 0;\n\t\t\tconst lastAppliedRequest = findLast(checkpoints, cp => cp.epoch < currentEpoch && cp.undoStopId === undefined)?.epoch || 0;\n\t\t\tconst stopDisablingAtEpoch = Math.max(lastAppliedOperation, lastAppliedRequest);\n\n\t\t\tconst disablement = new Map<string, string | undefined>();\n\n\t\t\t// Go through the checkpoints and disable any until the one that contains the last applied operation.\n\t\t\t// Subtle: the request will first make a checkpoint with an 'undefined' undo\n\t\t\t// stop, and in this loop we'll \"automatically\" disable the entire request when\n\t\t\t// we reach that checkpoint.\n\t\t\tfor (let i = checkpoints.length - 1; i >= 0; i--) {\n\t\t\t\tconst { undoStopId, requestId, epoch } = checkpoints[i];\n\t\t\t\tif (epoch <= stopDisablingAtEpoch) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (requestId) {\n\t\t\t\t\tdisablement.set(requestId, undoStopId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [...disablement].map(([requestId, afterUndoStop]): IChatRequestDisablement => ({ requestId, afterUndoStop }));\n\t\t});\n\n\tconstructor(\n\t\tprivate readonly chatSessionResource: URI,\n\t\tprivate readonly _delegate: IChatEditingTimelineFsDelegate,\n\t\t@INotebookEditorModelResolverService private readonly _notebookEditorModelResolverService: INotebookEditorModelResolverService,\n\t\t@INotebookService private readonly _notebookService: INotebookService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IModelService private readonly _modelService: IModelService,\n\t\t@ITextModelService private readonly _textModelService: ITextModelService,\n\t\t@IEditorWorkerService private readonly _editorWorkerService: IEditorWorkerService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService\n\t) {\n\t\tthis.createCheckpoint(undefined, undefined, 'Initial State', 'Starting point before any edits');\n\t}\n\n\tpublic createCheckpoint(requestId: string | undefined, undoStopId: string | undefined, label: string, description?: string): string {\n\t\tconst existingCheckpoints = this._checkpoints.get();\n\t\tconst existing = existingCheckpoints.find(c => c.undoStopId === undoStopId && c.requestId === requestId);\n\t\tif (existing) {\n\t\t\treturn existing.checkpointId;\n\t\t}\n\n\t\tconst { checkpoints, operations } = this._getVisibleOperationsAndCheckpoints();\n\t\tconst checkpointId = generateUuid();\n\t\tconst epoch = this.incrementEpoch();\n\n\t\tcheckpoints.push({\n\t\t\tcheckpointId,\n\t\t\trequestId,\n\t\t\tundoStopId,\n\t\t\tepoch,\n\t\t\tlabel,\n\t\t\tdescription\n\t\t});\n\n\t\ttransaction(tx => {\n\t\t\tthis._checkpoints.set(checkpoints, tx);\n\t\t\tthis._operations.set(operations, tx);\n\t\t\tthis._currentEpoch.set(epoch + 1, tx);\n\t\t});\n\n\t\treturn checkpointId;\n\t}\n\n\tpublic async undoToLastCheckpoint(): Promise<void> {\n\t\tconst checkpoint = this._willUndoToCheckpoint.get();\n\t\tif (checkpoint) {\n\t\t\tawait this.navigateToCheckpoint(checkpoint.checkpointId);\n\t\t}\n\t}\n\n\tpublic async redoToNextCheckpoint(): Promise<void> {\n\t\tconst targetEpoch = this._willRedoToEpoch.get();\n\t\tif (targetEpoch) {\n\t\t\tawait this._navigateToEpoch(targetEpoch);\n\t\t}\n\t}\n\n\tpublic navigateToCheckpoint(checkpointId: string): Promise<void> {\n\t\tconst targetCheckpoint = this._getCheckpoint(checkpointId);\n\t\tif (!targetCheckpoint) {\n\t\t\tthrow new Error(`Checkpoint ${checkpointId} not found`);\n\t\t}\n\n\t\tif (targetCheckpoint.undoStopId === undefined) {\n\t\t\t// If we're navigating to the start of a request, we want to restore the file\n\t\t\t// to whatever baseline we captured, _not_ the result state from the prior request\n\t\t\t// because there may have been user changes in the meantime. But we still want\n\t\t\t// to set the epoch marking that checkpoint as having been undone (the second\n\t\t\t// arg below) so that disablement works and so it's discarded if appropriate later.\n\t\t\treturn this._navigateToEpoch(targetCheckpoint.epoch + 1, targetCheckpoint.epoch);\n\t\t} else {\n\t\t\treturn this._navigateToEpoch(targetCheckpoint.epoch + 1);\n\t\t}\n\n\t}\n\n\tpublic getContentURIAtStop(requestId: string, fileURI: URI, stopId: string | undefined): URI {\n\t\treturn ChatEditingSnapshotTextModelContentProvider.getSnapshotFileURI(this.chatSessionResource, requestId, stopId, fileURI.path);\n\t}\n\n\tprivate async _navigateToEpoch(restoreToEpoch: number, navigateToEpoch = restoreToEpoch): Promise<void> {\n\t\tconst currentEpoch = this._currentEpoch.get();\n\t\tif (currentEpoch !== restoreToEpoch) {\n\t\t\tconst urisToRestore = await this._applyFileSystemOperations(currentEpoch, restoreToEpoch);\n\n\t\t\t// Reconstruct content for files affected by operations in the range\n\t\t\tawait this._reconstructAllFileContents(restoreToEpoch, urisToRestore);\n\t\t}\n\n\t\t// Update current epoch\n\t\tthis._currentEpoch.set(navigateToEpoch, undefined);\n\t}\n\n\tprivate _getCheckpoint(checkpointId: string): ICheckpoint | undefined {\n\t\treturn this._checkpoints.get().find(c => c.checkpointId === checkpointId);\n\t}\n\n\tpublic incrementEpoch() {\n\t\treturn this._epochCounter++;\n\t}\n\n\tpublic recordFileOperation(operation: FileOperation): void {\n\t\tconst { currentEpoch, checkpoints, operations } = this._getVisibleOperationsAndCheckpoints();\n\t\tif (operation.epoch < currentEpoch) {\n\t\t\tthrow new Error(`Cannot record operation at epoch ${operation.epoch} when current epoch is ${currentEpoch}`);\n\t\t}\n\n\t\toperations.push(operation);\n\t\ttransaction(tx => {\n\t\t\tthis._checkpoints.set(checkpoints, tx);\n\t\t\tthis._operations.set(operations, tx);\n\t\t\tthis._currentEpoch.set(operation.epoch + 1, tx);\n\t\t});\n\t}\n\n\tprivate _getVisibleOperationsAndCheckpoints() {\n\t\tconst currentEpoch = this._currentEpoch.get();\n\t\tconst checkpoints = this._checkpoints.get();\n\t\tconst operations = this._operations.get();\n\n\t\treturn {\n\t\t\tcurrentEpoch,\n\t\t\tcheckpoints: checkpoints.filter(c => c.epoch < currentEpoch),\n\t\t\toperations: operations.filter(op => op.epoch < currentEpoch)\n\t\t};\n\t}\n\n\tpublic recordFileBaseline(baseline: IFileBaseline): void {\n\t\tconst key = this._getBaselineKey(baseline.uri, baseline.requestId);\n\t\tthis._fileBaselines.set(key, baseline);\n\t}\n\n\tprivate _getFileBaseline(uri: URI, requestId: string): IFileBaseline | undefined {\n\t\tconst key = this._getBaselineKey(uri, requestId);\n\t\treturn this._fileBaselines.get(key);\n\t}\n\n\tpublic hasFileBaseline(uri: URI, requestId: string): boolean {\n\t\tconst key = this._getBaselineKey(uri, requestId);\n\t\treturn this._fileBaselines.has(key);\n\t}\n\n\tpublic async getContentAtStop(requestId: string, contentURI: URI, stopId: string | undefined) {\n\t\tlet toEpoch: number | undefined;\n\t\tif (stopId?.startsWith(STOP_ID_EPOCH_PREFIX)) {\n\t\t\ttoEpoch = Number(stopId.slice(STOP_ID_EPOCH_PREFIX.length));\n\t\t} else {\n\t\t\ttoEpoch = this._checkpoints.get().find(c => c.requestId === requestId && c.undoStopId === stopId)?.epoch;\n\t\t}\n\n\t\t// The content URI doesn't preserve the original scheme or authority. Look through\n\t\t// to find the operation that touched that path to get its actual URI\n\t\tconst fileURI = this._getTimelineCanonicalUriForPath(contentURI);\n\n\t\tif (!toEpoch || !fileURI) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst baseline = await this._findBestBaselineForFile(fileURI, toEpoch, requestId);\n\t\tif (!baseline) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst operations = this._getFileOperationsInRange(fileURI, baseline.epoch, toEpoch);\n\t\tconst replayed = await this._replayOperations(baseline, operations);\n\t\treturn replayed.exists ? replayed.content : undefined;\n\t}\n\n\tprivate _getTimelineCanonicalUriForPath(contentURI: URI) {\n\t\tfor (const it of [this._fileBaselines.values(), this._operations.get()]) {\n\t\t\tfor (const thing of it) {\n\t\t\t\tif (thing.uri.path === contentURI.path) {\n\t\t\t\t\treturn thing.uri;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Creates a callback that is invoked when data at the stop changes. This\n\t * will not fire initially and may be debounced internally.\n\t */\n\tpublic onDidChangeContentsAtStop(requestId: string, contentURI: URI, stopId: string | undefined, callback: (data: string) => void): IDisposable {\n\t\t// The only case where we have data that updates is if we have an epoch pointer that's\n\t\t// after our know epochs (e.g. pointing to the end file state after all operations).\n\t\t// If this isn't the case, abort.\n\t\tif (!stopId || !stopId.startsWith(STOP_ID_EPOCH_PREFIX)) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tconst target = Number(stopId.slice(STOP_ID_EPOCH_PREFIX.length));\n\t\tif (target <= this._epochCounter) {\n\t\t\treturn Disposable.None; // already finalized\n\t\t}\n\n\t\tconst store = new DisposableStore();\n\t\tconst scheduler = store.add(new ThrottledDelayer(500));\n\n\t\tstore.add(Event.fromObservableLight(this._operations)(() => {\n\t\t\tscheduler.trigger(async () => {\n\t\t\t\tif (this._operations.get().at(-1)?.epoch! >= target) {\n\t\t\t\t\tstore.dispose();\n\t\t\t\t}\n\n\t\t\t\tconst content = await this.getContentAtStop(requestId, contentURI, stopId);\n\t\t\t\tif (content !== undefined) {\n\t\t\t\t\tcallback(content);\n\t\t\t\t}\n\t\t\t});\n\t\t}));\n\n\t\treturn store;\n\t}\n\n\tprivate _getCheckpointBeforeEpoch(epoch: number, reader?: IReader) {\n\t\treturn findLast(this._checkpoints.read(reader), c => c.epoch <= epoch);\n\t}\n\n\tprivate async _reconstructFileState(uri: URI, targetEpoch: number): Promise<IReconstructedFileState> {\n\t\tconst targetCheckpoint = this._getCheckpointBeforeEpoch(targetEpoch);\n\t\tif (!targetCheckpoint) {\n\t\t\tthrow new Error(`Checkpoint for epoch ${targetEpoch} not found`);\n\t\t}\n\n\t\t// Find the most appropriate baseline for this file\n\t\tconst baseline = await this._findBestBaselineForFile(uri, targetEpoch, targetCheckpoint.requestId || '');\n\t\tif (!baseline) {\n\t\t\t// File doesn't exist at this checkpoint\n\t\t\treturn {\n\t\t\t\texists: false,\n\t\t\t\turi,\n\t\t\t};\n\t\t}\n\n\t\t// Get operations that affect this file from baseline to target checkpoint\n\t\tconst operations = this._getFileOperationsInRange(uri, baseline.epoch, targetEpoch);\n\n\t\t// Replay operations to reconstruct state\n\t\treturn this._replayOperations(baseline, operations);\n\t}\n\n\tpublic getStateForPersistence(): IChatEditingTimelineState {\n\t\treturn {\n\t\t\tcheckpoints: this._checkpoints.get(),\n\t\t\tcurrentEpoch: this._currentEpoch.get(),\n\t\t\tfileBaselines: [...this._fileBaselines],\n\t\t\toperations: this._operations.get(),\n\t\t\tepochCounter: this._epochCounter,\n\t\t};\n\t}\n\n\tpublic restoreFromState(state: IChatEditingTimelineState, tx: ITransaction): void {\n\t\tthis._checkpoints.set(state.checkpoints, tx);\n\t\tthis._currentEpoch.set(state.currentEpoch, tx);\n\t\tthis._operations.set(state.operations.slice(), tx);\n\t\tthis._epochCounter = state.epochCounter;\n\n\t\tthis._fileBaselines.clear();\n\t\tfor (const [key, baseline] of state.fileBaselines) {\n\t\t\tthis._fileBaselines.set(key, baseline);\n\t\t}\n\t}\n\n\tpublic getCheckpointIdForRequest(requestId: string, undoStopId?: string): string | undefined {\n\t\tconst checkpoints = this._checkpoints.get();\n\t\treturn checkpoints.find(c => c.requestId === requestId && c.undoStopId === undoStopId)?.checkpointId;\n\t}\n\n\tprivate async _reconstructAllFileContents(targetEpoch: number, filesToReconstruct: ResourceSet): Promise<void> {\n\t\tawait Promise.all(Array.from(filesToReconstruct).map(async uri => {\n\t\t\tconst reconstructedState = await this._reconstructFileState(uri, targetEpoch);\n\t\t\tif (reconstructedState.exists) {\n\t\t\t\tawait this._delegate.setContents(reconstructedState.uri, reconstructedState.content, reconstructedState.telemetryInfo);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate _getBaselineKey(uri: URI, requestId: string): string {\n\t\treturn `${uri.toString()}::${requestId}`;\n\t}\n\n\tprivate async _findBestBaselineForFile(uri: URI, epoch: number, requestId: string): Promise<IFileBaseline | undefined> {\n\t\t// First, iterate backwards through operations before the target checkpoint\n\t\t// to see if the file was created/re-created more recently than any baseline\n\n\t\tlet currentRequestId = requestId;\n\t\tconst operations = this._operations.get();\n\t\tfor (let i = operations.length - 1; i >= 0; i--) {\n\t\t\tconst operation = operations[i];\n\t\t\tif (operation.epoch > epoch) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If the file was just created, use that as its updated baseline\n\t\t\tif (operation.type === FileOperationType.Create && isEqual(operation.uri, uri)) {\n\t\t\t\treturn {\n\t\t\t\t\turi: operation.uri,\n\t\t\t\t\trequestId: operation.requestId,\n\t\t\t\t\tcontent: operation.initialContent,\n\t\t\t\t\tepoch: operation.epoch,\n\t\t\t\t\ttelemetryInfo: operation.telemetryInfo,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If the file was renamed to this URI, use its old contents as the baseline\n\t\t\tif (operation.type === FileOperationType.Rename && isEqual(operation.newUri, uri)) {\n\t\t\t\tconst prev = await this._findBestBaselineForFile(operation.oldUri, operation.epoch, operation.requestId);\n\t\t\t\tif (!prev) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\n\t\t\t\tconst operations = this._getFileOperationsInRange(operation.oldUri, prev.epoch, operation.epoch);\n\t\t\t\tconst replayed = await this._replayOperations(prev, operations);\n\t\t\t\treturn {\n\t\t\t\t\turi: uri,\n\t\t\t\t\tepoch: operation.epoch,\n\t\t\t\t\tcontent: replayed.exists ? replayed.content : '',\n\t\t\t\t\trequestId: operation.requestId,\n\t\t\t\t\ttelemetryInfo: prev.telemetryInfo,\n\t\t\t\t\tnotebookViewType: replayed.exists ? replayed.notebookViewType : undefined,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// When the request ID changes, check if we have a baseline for the current request\n\t\t\tif (currentRequestId && operation.requestId !== currentRequestId) {\n\t\t\t\tconst baseline = this._getFileBaseline(uri, currentRequestId);\n\t\t\t\tif (baseline) {\n\t\t\t\t\treturn baseline;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentRequestId = operation.requestId;\n\t\t}\n\n\t\t// Check the final request ID for a baseline\n\t\treturn this._getFileBaseline(uri, currentRequestId);\n\t}\n\n\tprivate _getFileOperationsInRange(uri: URI, fromEpoch: number, toEpoch: number): readonly FileOperation[] {\n\t\treturn this._operations.get().filter(op => {\n\t\t\tconst cellUri = CellUri.parse(op.uri);\n\t\t\treturn op.epoch >= fromEpoch &&\n\t\t\t\top.epoch < toEpoch &&\n\t\t\t\t(isEqual(op.uri, uri) || (cellUri && isEqual(cellUri.notebook, uri)));\n\t\t}).sort((a, b) => a.epoch - b.epoch);\n\t}\n\n\tprivate async _replayOperations(baseline: IFileBaseline, operations: readonly FileOperation[]): Promise<IReconstructedFileState> {\n\t\tlet currentState: IReconstructedFileStateWithNotebook = {\n\t\t\texists: true,\n\t\t\tcontent: baseline.content,\n\t\t\turi: baseline.uri,\n\t\t\ttelemetryInfo: baseline.telemetryInfo,\n\t\t};\n\n\t\tif (baseline.notebookViewType) {\n\t\t\tcurrentState.notebook = await this._notebookEditorModelResolverService.createUntitledNotebookTextModel(baseline.notebookViewType);\n\t\t\tif (baseline.content) {\n\t\t\t\trestoreNotebookSnapshot(currentState.notebook, baseline.content);\n\t\t\t}\n\t\t}\n\n\t\tfor (const operation of operations) {\n\t\t\tcurrentState = await this._applyOperationToState(currentState, operation, baseline.telemetryInfo);\n\t\t}\n\n\t\tif (currentState.exists && currentState.notebook) {\n\t\t\tconst info = await this._notebookService.withNotebookDataProvider(currentState.notebook.viewType);\n\t\t\tcurrentState.content = createNotebookSnapshot(currentState.notebook, info.serializer.options, this._configurationService);\n\t\t\tcurrentState.notebook.dispose();\n\t\t}\n\n\t\treturn currentState;\n\t}\n\n\tprivate async _applyOperationToState(state: IReconstructedFileStateWithNotebook, operation: FileOperation, telemetryInfo: IModifiedEntryTelemetryInfo): Promise<IReconstructedFileStateWithNotebook> {\n\t\tswitch (operation.type) {\n\t\t\tcase FileOperationType.Create: {\n\t\t\t\tif (state.exists && state.notebook) {\n\t\t\t\t\tstate.notebook.dispose();\n\t\t\t\t}\n\n\t\t\t\tlet notebook: INotebookTextModel | undefined;\n\t\t\t\tif (operation.notebookViewType) {\n\t\t\t\t\tnotebook = await this._notebookEditorModelResolverService.createUntitledNotebookTextModel(operation.notebookViewType);\n\t\t\t\t\tif (operation.initialContent) {\n\t\t\t\t\t\trestoreNotebookSnapshot(notebook, operation.initialContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\texists: true,\n\t\t\t\t\tcontent: operation.initialContent,\n\t\t\t\t\turi: operation.uri,\n\t\t\t\t\ttelemetryInfo,\n\t\t\t\t\tnotebookViewType: operation.notebookViewType,\n\t\t\t\t\tnotebook,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcase FileOperationType.Delete:\n\t\t\t\tif (state.exists && state.notebook) {\n\t\t\t\t\tstate.notebook.dispose();\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\texists: false,\n\t\t\t\t\turi: operation.uri\n\t\t\t\t};\n\n\t\t\tcase FileOperationType.Rename:\n\t\t\t\treturn {\n\t\t\t\t\t...state,\n\t\t\t\t\turi: operation.newUri\n\t\t\t\t};\n\n\t\t\tcase FileOperationType.TextEdit: {\n\t\t\t\tif (!state.exists) {\n\t\t\t\t\tthrow new Error('Cannot apply text edits to non-existent file');\n\t\t\t\t}\n\n\t\t\t\tconst nbCell = operation.cellIndex !== undefined && state.notebook?.cells.at(operation.cellIndex);\n\t\t\t\tif (nbCell) {\n\t\t\t\t\tconst newContent = this._applyTextEditsToContent(nbCell.getValue(), operation.edits);\n\t\t\t\t\tstate.notebook!.applyEdits([{\n\t\t\t\t\t\teditType: CellEditType.Replace,\n\t\t\t\t\t\tindex: operation.cellIndex,\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\tcells: [{ cellKind: nbCell.cellKind, language: nbCell.language, mime: nbCell.language, source: newContent, outputs: nbCell.outputs }]\n\t\t\t\t\t}], true, undefined, () => undefined, undefined);\n\t\t\t\t\treturn state;\n\t\t\t\t}\n\n\t\t\t\t// Apply text edits using a temporary text model\n\t\t\t\treturn {\n\t\t\t\t\t...state,\n\t\t\t\t\tcontent: this._applyTextEditsToContent(state.content, operation.edits)\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase FileOperationType.NotebookEdit:\n\t\t\t\tif (!state.exists) {\n\t\t\t\t\tthrow new Error('Cannot apply notebook edits to non-existent file');\n\t\t\t\t}\n\t\t\t\tif (!state.notebook) {\n\t\t\t\t\tthrow new Error('Cannot apply notebook edits to non-notebook file');\n\t\t\t\t}\n\n\t\t\t\tstate.notebook.applyEdits(operation.cellEdits.slice(), true, undefined, () => undefined, undefined);\n\t\t\t\treturn state;\n\n\t\t\tdefault:\n\t\t\t\tassertNever(operation);\n\t\t}\n\t}\n\n\tprivate async _applyFileSystemOperations(fromEpoch: number, toEpoch: number): Promise<ResourceSet> {\n\t\tconst isMovingForward = toEpoch > fromEpoch;\n\t\tconst operations = this._operations.get().filter(op => {\n\t\t\tif (isMovingForward) {\n\t\t\t\treturn op.epoch >= fromEpoch && op.epoch < toEpoch;\n\t\t\t} else {\n\t\t\t\treturn op.epoch < fromEpoch && op.epoch >= toEpoch;\n\t\t\t}\n\t\t}).sort((a, b) => isMovingForward ? a.epoch - b.epoch : b.epoch - a.epoch);\n\n\t\t// Apply file system operations in the correct direction\n\t\tconst urisToRestore = new ResourceSet();\n\t\tfor (const operation of operations) {\n\t\t\tawait this._applyFileSystemOperation(operation, isMovingForward, urisToRestore);\n\t\t}\n\n\t\treturn urisToRestore;\n\t}\n\n\tprivate async _applyFileSystemOperation(operation: FileOperation, isMovingForward: boolean, urisToRestore: ResourceSet): Promise<void> {\n\t\tswitch (operation.type) {\n\t\t\tcase FileOperationType.Create:\n\t\t\t\tif (isMovingForward) {\n\t\t\t\t\tawait this._delegate.createFile(operation.uri, operation.initialContent);\n\t\t\t\t\turisToRestore.add(operation.uri);\n\t\t\t\t} else {\n\t\t\t\t\tawait this._delegate.deleteFile(operation.uri);\n\t\t\t\t\turisToRestore.delete(operation.uri);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase FileOperationType.Delete:\n\t\t\t\tif (isMovingForward) {\n\t\t\t\t\tawait this._delegate.deleteFile(operation.uri);\n\t\t\t\t\turisToRestore.delete(operation.uri);\n\t\t\t\t} else {\n\t\t\t\t\tawait this._delegate.createFile(operation.uri, operation.finalContent);\n\t\t\t\t\turisToRestore.add(operation.uri);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase FileOperationType.Rename:\n\t\t\t\tif (isMovingForward) {\n\t\t\t\t\tawait this._delegate.renameFile(operation.oldUri, operation.newUri);\n\t\t\t\t\turisToRestore.delete(operation.oldUri);\n\t\t\t\t\turisToRestore.add(operation.newUri);\n\t\t\t\t} else {\n\t\t\t\t\tawait this._delegate.renameFile(operation.newUri, operation.oldUri);\n\t\t\t\t\turisToRestore.delete(operation.newUri);\n\t\t\t\t\turisToRestore.add(operation.oldUri);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Text and notebook edits don't affect file system structure\n\t\t\tcase FileOperationType.TextEdit:\n\t\t\tcase FileOperationType.NotebookEdit:\n\t\t\t\turisToRestore.add(CellUri.parse(operation.uri)?.notebook ?? operation.uri);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tassertNever(operation);\n\t\t}\n\t}\n\n\tprivate _applyTextEditsToContent(content: string, edits: readonly TextEdit[]): string {\n\t\t// Use the example pattern provided by the user\n\t\tconst makeModel = (uri: URI, contents: string) => this._instantiationService.createInstance(TextModel, contents, '', this._modelService.getCreationOptions('', uri, true), uri);\n\n\t\t// Create a temporary URI for the model\n\t\tconst tempUri = URI.from({ scheme: 'temp', path: `/temp-${Date.now()}.txt` });\n\t\tconst model = makeModel(tempUri, content);\n\n\t\ttry {\n\t\t\t// Apply edits\n\t\t\tmodel.applyEdits(edits.map(edit => ({\n\t\t\t\trange: {\n\t\t\t\t\tstartLineNumber: edit.range.startLineNumber,\n\t\t\t\t\tstartColumn: edit.range.startColumn,\n\t\t\t\t\tendLineNumber: edit.range.endLineNumber,\n\t\t\t\t\tendColumn: edit.range.endColumn\n\t\t\t\t},\n\t\t\t\ttext: edit.text\n\t\t\t})));\n\n\t\t\treturn model.getValue();\n\t\t} finally {\n\t\t\tmodel.dispose();\n\t\t}\n\t}\n\n\tpublic getEntryDiffBetweenStops(uri: URI, requestId: string | undefined, stopId: string | undefined): IObservable<IEditSessionEntryDiff | undefined> {\n\t\tconst epochs = derivedOpts<{ start: ICheckpoint; end: ICheckpoint | undefined }>({ equalsFn: (a, b) => a.start === b.start && a.end === b.end }, reader => {\n\t\t\tconst checkpoints = this._checkpoints.read(reader);\n\t\t\tconst startIndex = checkpoints.findIndex(c => c.requestId === requestId && c.undoStopId === stopId);\n\t\t\treturn { start: checkpoints[startIndex], end: checkpoints[startIndex + 1] };\n\t\t});\n\n\t\treturn this._getEntryDiffBetweenEpochs(uri, epochs);\n\t}\n\n\tpublic getEntryDiffBetweenRequests(uri: URI, startRequestId: string, stopRequestId: string): IObservable<IEditSessionEntryDiff | undefined> {\n\t\tconst epochs = derivedOpts<{ start: ICheckpoint; end: ICheckpoint | undefined }>({ equalsFn: (a, b) => a.start === b.start && a.end === b.end }, reader => {\n\t\t\tconst checkpoints = this._checkpoints.read(reader);\n\t\t\tconst startIndex = checkpoints.findIndex(c => c.requestId === startRequestId);\n\t\t\tconst start = startIndex === -1 ? checkpoints[0] : checkpoints[startIndex];\n\t\t\tconst end = checkpoints.find(c => c.requestId === stopRequestId) || findFirst(checkpoints, c => c.requestId !== startRequestId, startIndex) || checkpoints[checkpoints.length - 1];\n\t\t\treturn { start, end };\n\t\t});\n\n\t\treturn this._getEntryDiffBetweenEpochs(uri, epochs);\n\t}\n\n\tprivate _getEntryDiffBetweenEpochs(uri: URI, epochs: IObservable<{ start: ICheckpoint | undefined; end: ICheckpoint | undefined }>): IObservable<IEditSessionEntryDiff | undefined> {\n\t\tconst modelRefsPromise = derived(this, (reader) => {\n\t\t\tconst { start, end } = epochs.read(reader);\n\t\t\tif (!start) { return undefined; }\n\n\t\t\tconst store = reader.store.add(new DisposableStore());\n\t\t\tconst promise = Promise.all([\n\t\t\t\tthis._textModelService.createModelReference(this.getContentURIAtStop(start.requestId || START_REQUEST_EPOCH, uri, STOP_ID_EPOCH_PREFIX + start.epoch)),\n\t\t\t\tthis._textModelService.createModelReference(this.getContentURIAtStop(end?.requestId || start.requestId || START_REQUEST_EPOCH, uri, STOP_ID_EPOCH_PREFIX + (end?.epoch || Number.MAX_SAFE_INTEGER))),\n\t\t\t]).then(refs => {\n\t\t\t\tif (store.isDisposed) {\n\t\t\t\t\trefs.forEach(r => r.dispose());\n\t\t\t\t} else {\n\t\t\t\t\trefs.forEach(r => store.add(r));\n\t\t\t\t}\n\n\t\t\t\treturn { refs, isFinal: !!end };\n\t\t\t});\n\n\t\t\treturn new ObservablePromise(promise);\n\t\t});\n\n\t\tconst resolvedModels = derived(reader => {\n\t\t\tconst refs2 = modelRefsPromise.read(reader)?.promiseResult.read(reader);\n\t\t\treturn refs2?.data && {\n\t\t\t\tisFinal: refs2.data.isFinal,\n\t\t\t\trefs: refs2.data.refs.map(r => ({\n\t\t\t\t\tmodel: r.object.textEditorModel,\n\t\t\t\t\tonChange: observableSignalFromEvent(this, r.object.textEditorModel.onDidChangeContent.bind(r.object.textEditorModel)),\n\t\t\t\t})),\n\t\t\t};\n\t\t});\n\n\t\tconst diff = derived((reader): ObservablePromise<IEditSessionEntryDiff> | undefined => {\n\t\t\tconst modelsData = resolvedModels.read(reader);\n\t\t\tif (!modelsData) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { refs, isFinal } = modelsData;\n\n\t\t\trefs.forEach(m => m.onChange.read(reader)); // re-read when contents change\n\n\t\t\tconst promise = this._computeDiff(refs[0].model.uri, refs[1].model.uri, isFinal);\n\t\t\treturn new ObservablePromise(promise);\n\t\t});\n\n\t\treturn derived(reader => {\n\t\t\treturn diff.read(reader)?.promiseResult.read(reader)?.data || undefined;\n\t\t});\n\t}\n\n\tprivate _computeDiff(originalUri: URI, modifiedUri: URI, isFinal: boolean): Promise<IEditSessionEntryDiff> {\n\t\treturn this._editorWorkerService.computeDiff(\n\t\t\toriginalUri,\n\t\t\tmodifiedUri,\n\t\t\t{ ignoreTrimWhitespace: false, computeMoves: false, maxComputationTimeMs: 3000 },\n\t\t\t'advanced'\n\t\t).then((diff): IEditSessionEntryDiff => {\n\t\t\tconst entryDiff: IEditSessionEntryDiff = {\n\t\t\t\toriginalURI: originalUri,\n\t\t\t\tmodifiedURI: modifiedUri,\n\t\t\t\tidentical: !!diff?.identical,\n\t\t\t\tisFinal,\n\t\t\t\tquitEarly: !diff || diff.quitEarly,\n\t\t\t\tadded: 0,\n\t\t\t\tremoved: 0,\n\t\t\t};\n\t\t\tif (diff) {\n\t\t\t\tfor (const change of diff.changes) {\n\t\t\t\t\tentryDiff.removed += change.original.endLineNumberExclusive - change.original.startLineNumber;\n\t\t\t\t\tentryDiff.added += change.modified.endLineNumberExclusive - change.modified.startLineNumber;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn entryDiff;\n\t\t});\n\t}\n}\n"]}