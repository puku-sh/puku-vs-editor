{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/browser/chatEditing/notebook/notebookCellChanges.ts","vs/workbench/contrib/chat/browser/chatEditing/notebook/notebookCellChanges.ts"],"names":[],"mappings":"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","file":"notebookCellChanges.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ISettableObservable, ObservablePromise } from '../../../../../../base/common/observable.js';\nimport { IDocumentDiff } from '../../../../../../editor/common/diff/documentDiffProvider.js';\nimport { DetailedLineRangeMapping } from '../../../../../../editor/common/diff/rangeMapping.js';\nimport { ITextModel } from '../../../../../../editor/common/model.js';\n\n\n/**\n * This structure is used to represent the state of a Notebook document compared to the original.\n * Its similar to the IDocumentDiff object, that tells us what cells are unmodified, modified, inserted or deleted.\n *\n * All entries will contain a IDocumentDiff\n * Even when there are no changes, diff will contain the number of lines in the document.\n * This way we can always calculate the total number of lines in the document.\n */\nexport type ICellDiffInfo = |\n\t{\n\t\toriginalCellIndex: number;\n\t\tmodifiedCellIndex: number;\n\t\ttype: 'unchanged';\n\t} & IDocumentDiffWithModelsAndActions |\n\t{\n\t\toriginalCellIndex: number;\n\t\tmodifiedCellIndex: number;\n\t\ttype: 'modified';\n\t} & IDocumentDiffWithModelsAndActions |\n\t{\n\t\tmodifiedCellIndex: undefined;\n\t\toriginalCellIndex: number;\n\t\ttype: 'delete';\n\t} & IDocumentDiffWithModelsAndActions |\n\t{\n\t\tmodifiedCellIndex: number;\n\t\toriginalCellIndex: undefined;\n\t\ttype: 'insert';\n\t} & IDocumentDiffWithModelsAndActions;\n\n\n\ninterface IDocumentDiffWithModelsAndActions {\n\t/**\n\t * The changes between the original and modified document.\n\t */\n\tdiff: ISettableObservable<IDocumentDiff>;\n\t/**\n\t * The original model.\n\t * Cell text models load asynchronously, so this is an observable promise.\n\t */\n\toriginalModel: ObservablePromise<ITextModel>;\n\t/**\n\t * The modified model.\n\t * Cell text models load asynchronously, so this is an observable promise.\n\t */\n\tmodifiedModel: ObservablePromise<ITextModel>;\n\tkeep(changes: DetailedLineRangeMapping): Promise<boolean>;\n\tundo(changes: DetailedLineRangeMapping): Promise<boolean>;\n}\n\n\nexport function countChanges(changes: ICellDiffInfo[]): number {\n\treturn changes.reduce((count, change) => {\n\t\tconst diff = change.diff.get();\n\t\t// When we accept some of the cell insert/delete the items might still be in the list.\n\t\tif (diff.identical) {\n\t\t\treturn count;\n\t\t}\n\t\tswitch (change.type) {\n\t\t\tcase 'delete':\n\t\t\t\treturn count + 1; // We want to see 1 deleted entry in the pill for navigation\n\t\t\tcase 'insert':\n\t\t\t\treturn count + 1; // We want to see 1 new entry in the pill for navigation\n\t\t\tcase 'modified':\n\t\t\t\treturn count + diff.changes.length;\n\t\t\tdefault:\n\t\t\t\treturn count;\n\t\t}\n\t}, 0);\n\n}\n\nexport function sortCellChanges(changes: ICellDiffInfo[]): ICellDiffInfo[] {\n\tconst indexes = new Map<ICellDiffInfo, number>();\n\tchanges.forEach((c, i) => indexes.set(c, i));\n\treturn [...changes].sort((a, b) => {\n\t\t// For unchanged and modified, use modifiedCellIndex\n\t\tif ((a.type === 'unchanged' || a.type === 'modified') &&\n\t\t\t(b.type === 'unchanged' || b.type === 'modified')) {\n\t\t\treturn a.modifiedCellIndex - b.modifiedCellIndex;\n\t\t}\n\n\t\t// For delete entries, use originalCellIndex\n\t\tif (a.type === 'delete' && b.type === 'delete') {\n\t\t\treturn a.originalCellIndex - b.originalCellIndex;\n\t\t}\n\n\t\t// For insert entries, use modifiedCellIndex\n\t\tif (a.type === 'insert' && b.type === 'insert') {\n\t\t\treturn a.modifiedCellIndex - b.modifiedCellIndex;\n\t\t}\n\n\t\tif (a.type === 'delete' && b.type === 'insert') {\n\t\t\t// If the deleted cell comes before the inserted cell, we want the delete to come first\n\t\t\t// As this means the cell was deleted before it was inserted\n\t\t\t// We would like to see the deleted cell first in the list\n\t\t\t// Else in the UI it would look weird to see an inserted cell before a deleted cell,\n\t\t\t// When the users operation was to first delete the cell and then insert a new one\n\t\t\t// I.e. this is merely just a simple way to ensure we have a stable sort.\n\t\t\treturn indexes.get(a)! - indexes.get(b)!;\n\t\t}\n\t\tif (a.type === 'insert' && b.type === 'delete') {\n\t\t\t// If the deleted cell comes before the inserted cell, we want the delete to come first\n\t\t\t// As this means the cell was deleted before it was inserted\n\t\t\t// We would like to see the deleted cell first in the list\n\t\t\t// Else in the UI it would look weird to see an inserted cell before a deleted cell,\n\t\t\t// When the users operation was to first delete the cell and then insert a new one\n\t\t\t// I.e. this is merely just a simple way to ensure we have a stable sort.\n\t\t\treturn indexes.get(a)! - indexes.get(b)!;\n\t\t}\n\n\t\tif ((a.type === 'delete' && b.type !== 'insert') || (a.type !== 'insert' && b.type === 'delete')) {\n\t\t\treturn a.originalCellIndex - b.originalCellIndex;\n\t\t}\n\n\t\t// Mixed types: compare based on available indices\n\t\tconst aIndex = a.type === 'delete' ? a.originalCellIndex :\n\t\t\t(a.type === 'insert' ? a.modifiedCellIndex : a.modifiedCellIndex);\n\t\tconst bIndex = b.type === 'delete' ? b.originalCellIndex :\n\t\t\t(b.type === 'insert' ? b.modifiedCellIndex : b.modifiedCellIndex);\n\n\t\treturn aIndex - bIndex;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ISettableObservable, ObservablePromise } from '../../../../../../base/common/observable.js';\nimport { IDocumentDiff } from '../../../../../../editor/common/diff/documentDiffProvider.js';\nimport { DetailedLineRangeMapping } from '../../../../../../editor/common/diff/rangeMapping.js';\nimport { ITextModel } from '../../../../../../editor/common/model.js';\n\n\n/**\n * This structure is used to represent the state of a Notebook document compared to the original.\n * Its similar to the IDocumentDiff object, that tells us what cells are unmodified, modified, inserted or deleted.\n *\n * All entries will contain a IDocumentDiff\n * Even when there are no changes, diff will contain the number of lines in the document.\n * This way we can always calculate the total number of lines in the document.\n */\nexport type ICellDiffInfo = |\n\t{\n\t\toriginalCellIndex: number;\n\t\tmodifiedCellIndex: number;\n\t\ttype: 'unchanged';\n\t} & IDocumentDiffWithModelsAndActions |\n\t{\n\t\toriginalCellIndex: number;\n\t\tmodifiedCellIndex: number;\n\t\ttype: 'modified';\n\t} & IDocumentDiffWithModelsAndActions |\n\t{\n\t\tmodifiedCellIndex: undefined;\n\t\toriginalCellIndex: number;\n\t\ttype: 'delete';\n\t} & IDocumentDiffWithModelsAndActions |\n\t{\n\t\tmodifiedCellIndex: number;\n\t\toriginalCellIndex: undefined;\n\t\ttype: 'insert';\n\t} & IDocumentDiffWithModelsAndActions;\n\n\n\ninterface IDocumentDiffWithModelsAndActions {\n\t/**\n\t * The changes between the original and modified document.\n\t */\n\tdiff: ISettableObservable<IDocumentDiff>;\n\t/**\n\t * The original model.\n\t * Cell text models load asynchronously, so this is an observable promise.\n\t */\n\toriginalModel: ObservablePromise<ITextModel>;\n\t/**\n\t * The modified model.\n\t * Cell text models load asynchronously, so this is an observable promise.\n\t */\n\tmodifiedModel: ObservablePromise<ITextModel>;\n\tkeep(changes: DetailedLineRangeMapping): Promise<boolean>;\n\tundo(changes: DetailedLineRangeMapping): Promise<boolean>;\n}\n\n\nexport function countChanges(changes: ICellDiffInfo[]): number {\n\treturn changes.reduce((count, change) => {\n\t\tconst diff = change.diff.get();\n\t\t// When we accept some of the cell insert/delete the items might still be in the list.\n\t\tif (diff.identical) {\n\t\t\treturn count;\n\t\t}\n\t\tswitch (change.type) {\n\t\t\tcase 'delete':\n\t\t\t\treturn count + 1; // We want to see 1 deleted entry in the pill for navigation\n\t\t\tcase 'insert':\n\t\t\t\treturn count + 1; // We want to see 1 new entry in the pill for navigation\n\t\t\tcase 'modified':\n\t\t\t\treturn count + diff.changes.length;\n\t\t\tdefault:\n\t\t\t\treturn count;\n\t\t}\n\t}, 0);\n\n}\n\nexport function sortCellChanges(changes: ICellDiffInfo[]): ICellDiffInfo[] {\n\tconst indexes = new Map<ICellDiffInfo, number>();\n\tchanges.forEach((c, i) => indexes.set(c, i));\n\treturn [...changes].sort((a, b) => {\n\t\t// For unchanged and modified, use modifiedCellIndex\n\t\tif ((a.type === 'unchanged' || a.type === 'modified') &&\n\t\t\t(b.type === 'unchanged' || b.type === 'modified')) {\n\t\t\treturn a.modifiedCellIndex - b.modifiedCellIndex;\n\t\t}\n\n\t\t// For delete entries, use originalCellIndex\n\t\tif (a.type === 'delete' && b.type === 'delete') {\n\t\t\treturn a.originalCellIndex - b.originalCellIndex;\n\t\t}\n\n\t\t// For insert entries, use modifiedCellIndex\n\t\tif (a.type === 'insert' && b.type === 'insert') {\n\t\t\treturn a.modifiedCellIndex - b.modifiedCellIndex;\n\t\t}\n\n\t\tif (a.type === 'delete' && b.type === 'insert') {\n\t\t\t// If the deleted cell comes before the inserted cell, we want the delete to come first\n\t\t\t// As this means the cell was deleted before it was inserted\n\t\t\t// We would like to see the deleted cell first in the list\n\t\t\t// Else in the UI it would look weird to see an inserted cell before a deleted cell,\n\t\t\t// When the users operation was to first delete the cell and then insert a new one\n\t\t\t// I.e. this is merely just a simple way to ensure we have a stable sort.\n\t\t\treturn indexes.get(a)! - indexes.get(b)!;\n\t\t}\n\t\tif (a.type === 'insert' && b.type === 'delete') {\n\t\t\t// If the deleted cell comes before the inserted cell, we want the delete to come first\n\t\t\t// As this means the cell was deleted before it was inserted\n\t\t\t// We would like to see the deleted cell first in the list\n\t\t\t// Else in the UI it would look weird to see an inserted cell before a deleted cell,\n\t\t\t// When the users operation was to first delete the cell and then insert a new one\n\t\t\t// I.e. this is merely just a simple way to ensure we have a stable sort.\n\t\t\treturn indexes.get(a)! - indexes.get(b)!;\n\t\t}\n\n\t\tif ((a.type === 'delete' && b.type !== 'insert') || (a.type !== 'insert' && b.type === 'delete')) {\n\t\t\treturn a.originalCellIndex - b.originalCellIndex;\n\t\t}\n\n\t\t// Mixed types: compare based on available indices\n\t\tconst aIndex = a.type === 'delete' ? a.originalCellIndex :\n\t\t\t(a.type === 'insert' ? a.modifiedCellIndex : a.modifiedCellIndex);\n\t\tconst bIndex = b.type === 'delete' ? b.originalCellIndex :\n\t\t\t(b.type === 'insert' ? b.modifiedCellIndex : b.modifiedCellIndex);\n\n\t\treturn aIndex - bIndex;\n\t});\n}\n"]}