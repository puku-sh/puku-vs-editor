{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/chat/browser/chatWidgetService.ts","vs/workbench/contrib/chat/browser/chatWidgetService.ts"],"names":[],"mappings":"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","file":"chatWidgetService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as dom from '../../../../base/browser/dom.js';\nimport { raceCancellablePromises, timeout } from '../../../../base/common/async.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { combinedDisposable, Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ILayoutService } from '../../../../platform/layout/browser/layoutService.js';\nimport { IEditorService, PreferredGroup } from '../../../../workbench/services/editor/common/editorService.js';\nimport { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';\nimport { IViewsService } from '../../../services/views/common/viewsService.js';\nimport { ChatAgentLocation } from '../common/constants.js';\nimport { ChatViewId, ChatViewPaneTarget, IChatWidget, IChatWidgetService, IQuickChatService, isIChatViewViewContext } from './chat.js';\nimport { ChatEditor, IChatEditorOptions } from './chatEditor.js';\nimport { findExistingChatEditorByUri } from './chatSessions/common.js';\nimport { ChatViewPane } from './chatViewPane.js';\n\nexport class ChatWidgetService extends Disposable implements IChatWidgetService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _widgets: IChatWidget[] = [];\n\tprivate _lastFocusedWidget: IChatWidget | undefined = undefined;\n\n\tprivate readonly _onDidAddWidget = this._register(new Emitter<IChatWidget>());\n\treadonly onDidAddWidget: Event<IChatWidget> = this._onDidAddWidget.event;\n\n\tconstructor(\n\t\t@IEditorGroupsService private readonly editorGroupsService: IEditorGroupsService,\n\t\t@IViewsService private readonly viewsService: IViewsService,\n\t\t@IQuickChatService private readonly quickChatService: IQuickChatService,\n\t\t@ILayoutService private readonly layoutService: ILayoutService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t) {\n\t\tsuper();\n\t}\n\n\tget lastFocusedWidget(): IChatWidget | undefined {\n\t\treturn this._lastFocusedWidget;\n\t}\n\n\tgetAllWidgets(): ReadonlyArray<IChatWidget> {\n\t\treturn this._widgets;\n\t}\n\n\tgetWidgetsByLocations(location: ChatAgentLocation): ReadonlyArray<IChatWidget> {\n\t\treturn this._widgets.filter(w => w.location === location);\n\t}\n\n\tgetWidgetByInputUri(uri: URI): IChatWidget | undefined {\n\t\treturn this._widgets.find(w => isEqual(w.input.inputUri, uri));\n\t}\n\n\tgetWidgetBySessionResource(sessionResource: URI): IChatWidget | undefined {\n\t\treturn this._widgets.find(w => isEqual(w.viewModel?.sessionResource, sessionResource));\n\t}\n\n\n\tasync revealWidget(preserveFocus?: boolean): Promise<IChatWidget | undefined> {\n\t\tconst last = this.lastFocusedWidget;\n\t\tif (last && await this.reveal(last, preserveFocus)) {\n\t\t\treturn last;\n\t\t}\n\n\t\treturn (await this.viewsService.openView<ChatViewPane>(ChatViewId, !preserveFocus))?.widget;\n\t}\n\n\tasync reveal(widget: IChatWidget, preserveFocus?: boolean): Promise<boolean> {\n\t\tif (widget.viewModel?.sessionResource) {\n\t\t\tconst alreadyOpenWidget = await this.revealSessionIfAlreadyOpen(widget.viewModel.sessionResource, preserveFocus);\n\t\t\tif (alreadyOpenWidget) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (isIChatViewViewContext(widget.viewContext)) {\n\t\t\tconst view = await this.viewsService.openView(widget.viewContext.viewId, !preserveFocus);\n\t\t\tif (!preserveFocus) {\n\t\t\t\tview?.focus();\n\t\t\t}\n\t\t\treturn !!view;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Reveal the session if already open, otherwise open it.\n\t */\n\topenSession(sessionResource: URI, target?: typeof ChatViewPaneTarget): Promise<IChatWidget | undefined>;\n\topenSession(sessionResource: URI, target?: PreferredGroup, options?: IChatEditorOptions): Promise<IChatWidget | undefined>;\n\tasync openSession(sessionResource: URI, target?: typeof ChatViewPaneTarget | PreferredGroup, options?: IChatEditorOptions): Promise<IChatWidget | undefined> {\n\t\tconst alreadyOpenWidget = await this.revealSessionIfAlreadyOpen(sessionResource);\n\t\tif (alreadyOpenWidget) {\n\t\t\treturn alreadyOpenWidget;\n\t\t}\n\n\t\t// Load this session in chat view\n\t\tif (target === ChatViewPaneTarget) {\n\t\t\tconst chatViewPane = await this.viewsService.openView<ChatViewPane>(ChatViewId, true);\n\t\t\tif (chatViewPane) {\n\t\t\t\tawait chatViewPane.loadSession(sessionResource);\n\t\t\t\tchatViewPane.focusInput();\n\t\t\t}\n\t\t\treturn chatViewPane?.widget;\n\t\t}\n\n\t\t// Open in chat editor\n\t\tconst pane = await this.editorService.openEditor({ resource: sessionResource, options }, target);\n\t\treturn pane instanceof ChatEditor ? pane.widget : undefined;\n\t}\n\n\tprivate async revealSessionIfAlreadyOpen(sessionResource: URI, preserveFocus?: boolean): Promise<IChatWidget | undefined> {\n\t\t// Already open in chat view?\n\t\tconst chatView = this.viewsService.getViewWithId<ChatViewPane>(ChatViewId);\n\t\tif (chatView?.widget.viewModel?.sessionResource && isEqual(chatView.widget.viewModel.sessionResource, sessionResource)) {\n\t\t\tconst view = await this.viewsService.openView(ChatViewId, true);\n\t\t\tif (!preserveFocus) {\n\t\t\t\tview?.focus();\n\t\t\t}\n\t\t\treturn chatView.widget;\n\t\t}\n\n\t\t// Already open in an editor?\n\t\tconst existingEditor = findExistingChatEditorByUri(sessionResource, this.editorGroupsService);\n\t\tif (existingEditor) {\n\t\t\t// focus transfer to other documents is async. If we depend on the focus\n\t\t\t// being synchronously transferred in consuming code, this can fail, so\n\t\t\t// wait for it to propagate\n\t\t\tconst isGroupActive = () => dom.getWindowId(dom.getWindow(this.layoutService.activeContainer)) === existingEditor.group.windowId;\n\n\t\t\tlet ensureFocusTransfer: Promise<void> | undefined;\n\t\t\tif (!isGroupActive()) {\n\t\t\t\tensureFocusTransfer = raceCancellablePromises([\n\t\t\t\t\ttimeout(500),\n\t\t\t\t\tEvent.toPromise(Event.once(Event.filter(this.layoutService.onDidChangeActiveContainer, isGroupActive))),\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\tconst pane = await this.editorService.openEditor(existingEditor.editor, existingEditor.group);\n\t\t\tawait ensureFocusTransfer;\n\t\t\treturn pane instanceof ChatEditor ? pane.widget : undefined;\n\t\t}\n\n\t\t// Already open in quick chat?\n\t\tif (isEqual(sessionResource, this.quickChatService.sessionResource)) {\n\t\t\tthis.quickChatService.focus();\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate setLastFocusedWidget(widget: IChatWidget | undefined): void {\n\t\tif (widget === this._lastFocusedWidget) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lastFocusedWidget = widget;\n\t}\n\n\tregister(newWidget: IChatWidget): IDisposable {\n\t\tif (this._widgets.some(widget => widget === newWidget)) {\n\t\t\tthrow new Error('Cannot register the same widget multiple times');\n\t\t}\n\n\t\tthis._widgets.push(newWidget);\n\t\tthis._onDidAddWidget.fire(newWidget);\n\n\t\treturn combinedDisposable(\n\t\t\tnewWidget.onDidFocus(() => this.setLastFocusedWidget(newWidget)),\n\t\t\ttoDisposable(() => this._widgets.splice(this._widgets.indexOf(newWidget), 1))\n\t\t);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as dom from '../../../../base/browser/dom.js';\nimport { raceCancellablePromises, timeout } from '../../../../base/common/async.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { combinedDisposable, Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ILayoutService } from '../../../../platform/layout/browser/layoutService.js';\nimport { IEditorService, PreferredGroup } from '../../../../workbench/services/editor/common/editorService.js';\nimport { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';\nimport { IViewsService } from '../../../services/views/common/viewsService.js';\nimport { ChatAgentLocation } from '../common/constants.js';\nimport { ChatViewId, ChatViewPaneTarget, IChatWidget, IChatWidgetService, IQuickChatService, isIChatViewViewContext } from './chat.js';\nimport { ChatEditor, IChatEditorOptions } from './chatEditor.js';\nimport { findExistingChatEditorByUri } from './chatSessions/common.js';\nimport { ChatViewPane } from './chatViewPane.js';\n\nexport class ChatWidgetService extends Disposable implements IChatWidgetService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _widgets: IChatWidget[] = [];\n\tprivate _lastFocusedWidget: IChatWidget | undefined = undefined;\n\n\tprivate readonly _onDidAddWidget = this._register(new Emitter<IChatWidget>());\n\treadonly onDidAddWidget: Event<IChatWidget> = this._onDidAddWidget.event;\n\n\tconstructor(\n\t\t@IEditorGroupsService private readonly editorGroupsService: IEditorGroupsService,\n\t\t@IViewsService private readonly viewsService: IViewsService,\n\t\t@IQuickChatService private readonly quickChatService: IQuickChatService,\n\t\t@ILayoutService private readonly layoutService: ILayoutService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t) {\n\t\tsuper();\n\t}\n\n\tget lastFocusedWidget(): IChatWidget | undefined {\n\t\treturn this._lastFocusedWidget;\n\t}\n\n\tgetAllWidgets(): ReadonlyArray<IChatWidget> {\n\t\treturn this._widgets;\n\t}\n\n\tgetWidgetsByLocations(location: ChatAgentLocation): ReadonlyArray<IChatWidget> {\n\t\treturn this._widgets.filter(w => w.location === location);\n\t}\n\n\tgetWidgetByInputUri(uri: URI): IChatWidget | undefined {\n\t\treturn this._widgets.find(w => isEqual(w.input.inputUri, uri));\n\t}\n\n\tgetWidgetBySessionResource(sessionResource: URI): IChatWidget | undefined {\n\t\treturn this._widgets.find(w => isEqual(w.viewModel?.sessionResource, sessionResource));\n\t}\n\n\n\tasync revealWidget(preserveFocus?: boolean): Promise<IChatWidget | undefined> {\n\t\tconst last = this.lastFocusedWidget;\n\t\tif (last && await this.reveal(last, preserveFocus)) {\n\t\t\treturn last;\n\t\t}\n\n\t\treturn (await this.viewsService.openView<ChatViewPane>(ChatViewId, !preserveFocus))?.widget;\n\t}\n\n\tasync reveal(widget: IChatWidget, preserveFocus?: boolean): Promise<boolean> {\n\t\tif (widget.viewModel?.sessionResource) {\n\t\t\tconst alreadyOpenWidget = await this.revealSessionIfAlreadyOpen(widget.viewModel.sessionResource, preserveFocus);\n\t\t\tif (alreadyOpenWidget) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (isIChatViewViewContext(widget.viewContext)) {\n\t\t\tconst view = await this.viewsService.openView(widget.viewContext.viewId, !preserveFocus);\n\t\t\tif (!preserveFocus) {\n\t\t\t\tview?.focus();\n\t\t\t}\n\t\t\treturn !!view;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Reveal the session if already open, otherwise open it.\n\t */\n\topenSession(sessionResource: URI, target?: typeof ChatViewPaneTarget): Promise<IChatWidget | undefined>;\n\topenSession(sessionResource: URI, target?: PreferredGroup, options?: IChatEditorOptions): Promise<IChatWidget | undefined>;\n\tasync openSession(sessionResource: URI, target?: typeof ChatViewPaneTarget | PreferredGroup, options?: IChatEditorOptions): Promise<IChatWidget | undefined> {\n\t\tconst alreadyOpenWidget = await this.revealSessionIfAlreadyOpen(sessionResource);\n\t\tif (alreadyOpenWidget) {\n\t\t\treturn alreadyOpenWidget;\n\t\t}\n\n\t\t// Load this session in chat view\n\t\tif (target === ChatViewPaneTarget) {\n\t\t\tconst chatViewPane = await this.viewsService.openView<ChatViewPane>(ChatViewId, true);\n\t\t\tif (chatViewPane) {\n\t\t\t\tawait chatViewPane.loadSession(sessionResource);\n\t\t\t\tchatViewPane.focusInput();\n\t\t\t}\n\t\t\treturn chatViewPane?.widget;\n\t\t}\n\n\t\t// Open in chat editor\n\t\tconst pane = await this.editorService.openEditor({ resource: sessionResource, options }, target);\n\t\treturn pane instanceof ChatEditor ? pane.widget : undefined;\n\t}\n\n\tprivate async revealSessionIfAlreadyOpen(sessionResource: URI, preserveFocus?: boolean): Promise<IChatWidget | undefined> {\n\t\t// Already open in chat view?\n\t\tconst chatView = this.viewsService.getViewWithId<ChatViewPane>(ChatViewId);\n\t\tif (chatView?.widget.viewModel?.sessionResource && isEqual(chatView.widget.viewModel.sessionResource, sessionResource)) {\n\t\t\tconst view = await this.viewsService.openView(ChatViewId, true);\n\t\t\tif (!preserveFocus) {\n\t\t\t\tview?.focus();\n\t\t\t}\n\t\t\treturn chatView.widget;\n\t\t}\n\n\t\t// Already open in an editor?\n\t\tconst existingEditor = findExistingChatEditorByUri(sessionResource, this.editorGroupsService);\n\t\tif (existingEditor) {\n\t\t\t// focus transfer to other documents is async. If we depend on the focus\n\t\t\t// being synchronously transferred in consuming code, this can fail, so\n\t\t\t// wait for it to propagate\n\t\t\tconst isGroupActive = () => dom.getWindowId(dom.getWindow(this.layoutService.activeContainer)) === existingEditor.group.windowId;\n\n\t\t\tlet ensureFocusTransfer: Promise<void> | undefined;\n\t\t\tif (!isGroupActive()) {\n\t\t\t\tensureFocusTransfer = raceCancellablePromises([\n\t\t\t\t\ttimeout(500),\n\t\t\t\t\tEvent.toPromise(Event.once(Event.filter(this.layoutService.onDidChangeActiveContainer, isGroupActive))),\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\tconst pane = await this.editorService.openEditor(existingEditor.editor, existingEditor.group);\n\t\t\tawait ensureFocusTransfer;\n\t\t\treturn pane instanceof ChatEditor ? pane.widget : undefined;\n\t\t}\n\n\t\t// Already open in quick chat?\n\t\tif (isEqual(sessionResource, this.quickChatService.sessionResource)) {\n\t\t\tthis.quickChatService.focus();\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate setLastFocusedWidget(widget: IChatWidget | undefined): void {\n\t\tif (widget === this._lastFocusedWidget) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lastFocusedWidget = widget;\n\t}\n\n\tregister(newWidget: IChatWidget): IDisposable {\n\t\tif (this._widgets.some(widget => widget === newWidget)) {\n\t\t\tthrow new Error('Cannot register the same widget multiple times');\n\t\t}\n\n\t\tthis._widgets.push(newWidget);\n\t\tthis._onDidAddWidget.fire(newWidget);\n\n\t\treturn combinedDisposable(\n\t\t\tnewWidget.onDidFocus(() => this.setLastFocusedWidget(newWidget)),\n\t\t\ttoDisposable(() => this._widgets.splice(this._widgets.indexOf(newWidget), 1))\n\t\t);\n\t}\n}\n"]}