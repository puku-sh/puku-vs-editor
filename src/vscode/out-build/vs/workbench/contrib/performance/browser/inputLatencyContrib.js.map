{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/performance/browser/inputLatencyContrib.ts","vs/workbench/contrib/performance/browser/inputLatencyContrib.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;AAEhG,OAAO,EAAE,YAAY,EAAE,MAAM,yCAAyC,CAAC;AACvE,OAAO,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AACpE,OAAO,EAAE,KAAK,EAAE,MAAM,kCAAkC,CAAC;AACzD,OAAO,EAAE,UAAU,EAAE,iBAAiB,EAAE,MAAM,sCAAsC,CAAC;AACrF,OAAO,EAAE,qBAAqB,EAAE,MAAM,4DAA4D,CAAC;AACnG,OAAO,EAAE,iBAAiB,EAAE,MAAM,oDAAoD,CAAC;AAEvF,OAAO,EAAE,cAAc,EAAE,MAAM,kDAAkD,CAAC;AAE3E,IAAM,mBAAmB,GAAzB,MAAM,mBAAoB,SAAQ,UAAU;IAIlD,YACwB,qBAA6D,EACpE,cAA+C,EAC5C,iBAAqD;QAExE,KAAK,EAAE,CAAC;QAJgC,0BAAqB,GAArB,qBAAqB,CAAuB;QACnD,mBAAc,GAAd,cAAc,CAAgB;QAC3B,sBAAiB,GAAjB,iBAAiB,CAAmB;QANxD,cAAS,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,iBAAiB,EAAE,CAAC,CAAC;QAUpE,sFAAsF;QACtF,qFAAqF;QACrF,uFAAuF;QACvF,2BAA2B;QAC3B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,gBAAgB,CAAC,GAAG,EAAE;YAC1D,IAAI,CAAC,WAAW,EAAE,CAAC;YACnB,IAAI,CAAC,cAAc,EAAE,CAAC;QACvB,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;QAGX,sEAAsE;QACtE,IAAI,IAAI,CAAC,MAAM,EAAE,IAAI,IAAI,EAAE,CAAC;YAC3B,IAAI,CAAC,cAAc,EAAE,CAAC;QACvB,CAAC;IAEF,CAAC;IAEO,cAAc;QACrB,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,uBAAuB,CAAC,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC,CAAC;IAClH,CAAC;IAEO,WAAW;QAClB,MAAM,YAAY,GAAG,YAAY,CAAC,uBAAuB,EAAE,CAAC;QAC5D,IAAI,CAAC,YAAY,EAAE,CAAC;YACnB,OAAO;QACR,CAAC;QAyBD,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAsE,0BAA0B,EAAE;YAClI,OAAO,EAAE,YAAY,CAAC,OAAO;YAC7B,KAAK,EAAE,YAAY,CAAC,KAAK;YACzB,MAAM,EAAE,YAAY,CAAC,MAAM;YAC3B,KAAK,EAAE,YAAY,CAAC,KAAK;YACzB,WAAW,EAAE,YAAY,CAAC,WAAW;YACrC,eAAe,EAAE,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,oCAAoC,CAAC,KAAK,IAAI;SACnG,CAAC,CAAC;IACJ,CAAC;CACD,CAAA;AAtEY,mBAAmB;IAK7B,WAAA,qBAAqB,CAAA;IACrB,WAAA,cAAc,CAAA;IACd,WAAA,iBAAiB,CAAA;GAPP,mBAAmB,CAsE/B","file":"inputLatencyContrib.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { inputLatency } from '../../../../base/browser/performance.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IWorkbenchContribution } from '../../../common/contributions.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\n\nexport class InputLatencyContrib extends Disposable implements IWorkbenchContribution {\n\tprivate readonly _listener = this._register(new MutableDisposable());\n\tprivate readonly _scheduler: RunOnceScheduler;\n\n\tconstructor(\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IEditorService private readonly _editorService: IEditorService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService\n\t) {\n\t\tsuper();\n\n\t\t// The current sampling strategy is when the active editor changes, start sampling and\n\t\t// report the results after 60 seconds. It's done this way as we don't want to sample\n\t\t// everything, just somewhat randomly, and using an interval would utilize CPU when the\n\t\t// application is inactive.\n\t\tthis._scheduler = this._register(new RunOnceScheduler(() => {\n\t\t\tthis._logSamples();\n\t\t\tthis._setupListener();\n\t\t}, 60000));\n\n\n\t\t// Only log 1% of users selected randomly to reduce the volume of data\n\t\tif (Math.random() <= 0.01) {\n\t\t\tthis._setupListener();\n\t\t}\n\n\t}\n\n\tprivate _setupListener(): void {\n\t\tthis._listener.value = Event.once(this._editorService.onDidActiveEditorChange)(() => this._scheduler.schedule());\n\t}\n\n\tprivate _logSamples(): void {\n\t\tconst measurements = inputLatency.getAndClearMeasurements();\n\t\tif (!measurements) {\n\t\t\treturn;\n\t\t}\n\n\t\ttype InputLatencyStatisticFragment = {\n\t\t\towner: 'tyriar';\n\t\t\tcomment: 'Represents a set of statistics collected about input latencies';\n\t\t\taverage: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'The average time it took to execute.' };\n\t\t\tmax: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'The maximum time it took to execute.' };\n\t\t\tmin: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'The minimum time it took to execute.' };\n\t\t};\n\n\t\ttype PerformanceInputLatencyClassification = {\n\t\t\towner: 'tyriar';\n\t\t\tcomment: 'This is a set of samples of the time (in milliseconds) that various events took when typing in the editor';\n\t\t\tkeydown: InputLatencyStatisticFragment;\n\t\t\tinput: InputLatencyStatisticFragment;\n\t\t\trender: InputLatencyStatisticFragment;\n\t\t\ttotal: InputLatencyStatisticFragment;\n\t\t\tsampleCount: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'The number of samples measured.' };\n\t\t\tgpuAcceleration: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'Whether GPU acceleration was enabled at the time the event was reported.' };\n\t\t};\n\n\t\ttype PerformanceInputLatencyEvent = inputLatency.IInputLatencyMeasurements & {\n\t\t\tgpuAcceleration: boolean;\n\t\t};\n\n\t\tthis._telemetryService.publicLog2<PerformanceInputLatencyEvent, PerformanceInputLatencyClassification>('performance.inputLatency', {\n\t\t\tkeydown: measurements.keydown,\n\t\t\tinput: measurements.input,\n\t\t\trender: measurements.render,\n\t\t\ttotal: measurements.total,\n\t\t\tsampleCount: measurements.sampleCount,\n\t\t\tgpuAcceleration: this._configurationService.getValue('editor.experimentalGpuAcceleration') === 'on'\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { inputLatency } from '../../../../base/browser/performance.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IWorkbenchContribution } from '../../../common/contributions.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\n\nexport class InputLatencyContrib extends Disposable implements IWorkbenchContribution {\n\tprivate readonly _listener = this._register(new MutableDisposable());\n\tprivate readonly _scheduler: RunOnceScheduler;\n\n\tconstructor(\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IEditorService private readonly _editorService: IEditorService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService\n\t) {\n\t\tsuper();\n\n\t\t// The current sampling strategy is when the active editor changes, start sampling and\n\t\t// report the results after 60 seconds. It's done this way as we don't want to sample\n\t\t// everything, just somewhat randomly, and using an interval would utilize CPU when the\n\t\t// application is inactive.\n\t\tthis._scheduler = this._register(new RunOnceScheduler(() => {\n\t\t\tthis._logSamples();\n\t\t\tthis._setupListener();\n\t\t}, 60000));\n\n\n\t\t// Only log 1% of users selected randomly to reduce the volume of data\n\t\tif (Math.random() <= 0.01) {\n\t\t\tthis._setupListener();\n\t\t}\n\n\t}\n\n\tprivate _setupListener(): void {\n\t\tthis._listener.value = Event.once(this._editorService.onDidActiveEditorChange)(() => this._scheduler.schedule());\n\t}\n\n\tprivate _logSamples(): void {\n\t\tconst measurements = inputLatency.getAndClearMeasurements();\n\t\tif (!measurements) {\n\t\t\treturn;\n\t\t}\n\n\t\ttype InputLatencyStatisticFragment = {\n\t\t\towner: 'tyriar';\n\t\t\tcomment: 'Represents a set of statistics collected about input latencies';\n\t\t\taverage: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'The average time it took to execute.' };\n\t\t\tmax: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'The maximum time it took to execute.' };\n\t\t\tmin: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'The minimum time it took to execute.' };\n\t\t};\n\n\t\ttype PerformanceInputLatencyClassification = {\n\t\t\towner: 'tyriar';\n\t\t\tcomment: 'This is a set of samples of the time (in milliseconds) that various events took when typing in the editor';\n\t\t\tkeydown: InputLatencyStatisticFragment;\n\t\t\tinput: InputLatencyStatisticFragment;\n\t\t\trender: InputLatencyStatisticFragment;\n\t\t\ttotal: InputLatencyStatisticFragment;\n\t\t\tsampleCount: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'The number of samples measured.' };\n\t\t\tgpuAcceleration: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'Whether GPU acceleration was enabled at the time the event was reported.' };\n\t\t};\n\n\t\ttype PerformanceInputLatencyEvent = inputLatency.IInputLatencyMeasurements & {\n\t\t\tgpuAcceleration: boolean;\n\t\t};\n\n\t\tthis._telemetryService.publicLog2<PerformanceInputLatencyEvent, PerformanceInputLatencyClassification>('performance.inputLatency', {\n\t\t\tkeydown: measurements.keydown,\n\t\t\tinput: measurements.input,\n\t\t\trender: measurements.render,\n\t\t\ttotal: measurements.total,\n\t\t\tsampleCount: measurements.sampleCount,\n\t\t\tgpuAcceleration: this._configurationService.getValue('editor.experimentalGpuAcceleration') === 'on'\n\t\t});\n\t}\n}\n"]}