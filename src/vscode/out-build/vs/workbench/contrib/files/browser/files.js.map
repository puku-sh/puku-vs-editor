{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/files/browser/files.ts","vs/workbench/contrib/files/browser/files.ts"],"names":[],"mappings":"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","file":"files.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { IListService } from '../../../../platform/list/browser/listService.js';\nimport { OpenEditor, ISortOrderConfiguration } from '../common/files.js';\nimport { EditorResourceAccessor, SideBySideEditor, IEditorIdentifier } from '../../../common/editor.js';\nimport { List } from '../../../../base/browser/ui/list/listWidget.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { ExplorerItem } from '../common/explorerModel.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { AsyncDataTree } from '../../../../base/browser/ui/tree/asyncDataTree.js';\nimport { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';\nimport { IEditableData } from '../../../common/views.js';\nimport { createDecorator, ServicesAccessor } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ResourceFileEdit } from '../../../../editor/browser/services/bulkEditService.js';\nimport { ProgressLocation } from '../../../../platform/progress/common/progress.js';\nimport { isActiveElement } from '../../../../base/browser/dom.js';\n\nexport interface IExplorerService {\n\treadonly _serviceBrand: undefined;\n\treadonly roots: ExplorerItem[];\n\treadonly sortOrderConfiguration: ISortOrderConfiguration;\n\n\tgetContext(respectMultiSelection: boolean, ignoreNestedChildren?: boolean): ExplorerItem[];\n\thasViewFocus(): boolean;\n\tsetEditable(stat: ExplorerItem, data: IEditableData | null): Promise<void>;\n\tgetEditable(): { stat: ExplorerItem; data: IEditableData } | undefined;\n\tgetEditableData(stat: ExplorerItem): IEditableData | undefined;\n\t// If undefined is passed checks if any element is currently being edited.\n\tisEditable(stat: ExplorerItem | undefined): boolean;\n\tfindClosest(resource: URI): ExplorerItem | null;\n\tfindClosestRoot(resource: URI): ExplorerItem | null;\n\trefresh(): Promise<void>;\n\tsetToCopy(stats: ExplorerItem[], cut: boolean): Promise<void>;\n\tisCut(stat: ExplorerItem): boolean;\n\tapplyBulkEdit(edit: ResourceFileEdit[], options: { undoLabel: string; progressLabel: string; confirmBeforeUndo?: boolean; progressLocation?: ProgressLocation.Explorer | ProgressLocation.Window }): Promise<void>;\n\n\t/**\n\t * Selects and reveal the file element provided by the given resource if its found in the explorer.\n\t * Will try to resolve the path in case the explorer is not yet expanded to the file yet.\n\t */\n\tselect(resource: URI, reveal?: boolean | string): Promise<void>;\n\n\tregisterView(contextAndRefreshProvider: IExplorerView): void;\n}\n\nexport const IExplorerService = createDecorator<IExplorerService>('explorerService');\n\nexport interface IExplorerView {\n\tautoReveal: boolean | 'force' | 'focusNoScroll';\n\tgetContext(respectMultiSelection: boolean): ExplorerItem[];\n\trefresh(recursive: boolean, item?: ExplorerItem, cancelEditing?: boolean): Promise<void>;\n\tselectResource(resource: URI | undefined, reveal?: boolean | string, retry?: number): Promise<void>;\n\tsetTreeInput(): Promise<void>;\n\titemsCopied(tats: ExplorerItem[], cut: boolean, previousCut: ExplorerItem[] | undefined): void;\n\tsetEditable(stat: ExplorerItem, isEditing: boolean): Promise<void>;\n\tisItemVisible(item: ExplorerItem): boolean;\n\tisItemCollapsed(item: ExplorerItem): boolean;\n\thasFocus(): boolean;\n\tgetFocus(): ExplorerItem[];\n\tfocusNext(): void;\n\tfocusLast(): void;\n\thasPhantomElements(): boolean;\n}\n\nfunction getFocus(listService: IListService): unknown | undefined {\n\tconst list = listService.lastFocusedList;\n\tconst element = list?.getHTMLElement();\n\tif (element && isActiveElement(element)) {\n\t\tlet focus: unknown;\n\t\tif (list instanceof List) {\n\t\t\tconst focused = list.getFocusedElements();\n\t\t\tif (focused.length) {\n\t\t\t\tfocus = focused[0];\n\t\t\t}\n\t\t} else if (list instanceof AsyncDataTree) {\n\t\t\tconst focused = list.getFocus();\n\t\t\tif (focused.length) {\n\t\t\t\tfocus = focused[0];\n\t\t\t}\n\t\t}\n\n\t\treturn focus;\n\t}\n\n\treturn undefined;\n}\n\n// Commands can get executed from a command palette, from a context menu or from some list using a keybinding\n// To cover all these cases we need to properly compute the resource on which the command is being executed\nexport function getResourceForCommand(commandArg: unknown, editorService: IEditorService, listService: IListService): URI | undefined {\n\tif (URI.isUri(commandArg)) {\n\t\treturn commandArg;\n\t}\n\n\tconst focus = getFocus(listService);\n\tif (focus instanceof ExplorerItem) {\n\t\treturn focus.resource;\n\t} else if (focus instanceof OpenEditor) {\n\t\treturn focus.getResource();\n\t}\n\n\treturn EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });\n}\n\nexport function getMultiSelectedResources(commandArg: unknown, listService: IListService, editorSerice: IEditorService, editorGroupService: IEditorGroupsService, explorerService: IExplorerService): Array<URI> {\n\tconst list = listService.lastFocusedList;\n\tconst element = list?.getHTMLElement();\n\tif (element && isActiveElement(element)) {\n\t\t// Explorer\n\t\tif (list instanceof AsyncDataTree && list.getFocus().every(item => item instanceof ExplorerItem)) {\n\t\t\t// Explorer\n\t\t\tconst context = explorerService.getContext(true, true);\n\t\t\tif (context.length) {\n\t\t\t\treturn context.map(c => c.resource);\n\t\t\t}\n\t\t}\n\n\t\t// Open editors view\n\t\tif (list instanceof List) {\n\t\t\tconst selection = coalesce(list.getSelectedElements().filter(s => s instanceof OpenEditor).map((oe: OpenEditor) => oe.getResource()));\n\t\t\tconst focusedElements = list.getFocusedElements();\n\t\t\tconst focus = focusedElements.length ? focusedElements[0] : undefined;\n\t\t\tlet mainUriStr: string | undefined = undefined;\n\t\t\tif (URI.isUri(commandArg)) {\n\t\t\t\tmainUriStr = commandArg.toString();\n\t\t\t} else if (focus instanceof OpenEditor) {\n\t\t\t\tconst focusedResource = focus.getResource();\n\t\t\t\tmainUriStr = focusedResource ? focusedResource.toString() : undefined;\n\t\t\t}\n\t\t\t// We only respect the selection if it contains the main element.\n\t\t\tconst mainIndex = selection.findIndex(s => s.toString() === mainUriStr);\n\t\t\tif (mainIndex !== -1) {\n\t\t\t\t// Move the main resource to the front of the selection.\n\t\t\t\tconst mainResource = selection[mainIndex];\n\t\t\t\tselection.splice(mainIndex, 1);\n\t\t\t\tselection.unshift(mainResource);\n\t\t\t\treturn selection;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check for tabs multiselect\n\tconst activeGroup = editorGroupService.activeGroup;\n\tconst selection = activeGroup.selectedEditors;\n\tif (selection.length > 1 && URI.isUri(commandArg)) {\n\t\t// If the resource is part of the tabs selection, return all selected tabs/resources.\n\t\t// It's possible that multiple tabs are selected but the action was applied to a resource that is not part of the selection.\n\t\tconst mainEditorSelectionIndex = selection.findIndex(e => e.matches({ resource: commandArg }));\n\t\tif (mainEditorSelectionIndex !== -1) {\n\t\t\tconst mainEditor = selection[mainEditorSelectionIndex];\n\t\t\tselection.splice(mainEditorSelectionIndex, 1);\n\t\t\tselection.unshift(mainEditor);\n\t\t\treturn selection.map(editor => EditorResourceAccessor.getOriginalUri(editor)).filter(uri => !!uri);\n\t\t}\n\t}\n\n\tconst result = getResourceForCommand(commandArg, editorSerice, listService);\n\treturn result ? [result] : [];\n}\n\nexport function getOpenEditorsViewMultiSelection(accessor: ServicesAccessor): Array<IEditorIdentifier> | undefined {\n\tconst list = accessor.get(IListService).lastFocusedList;\n\tconst element = list?.getHTMLElement();\n\tif (element && isActiveElement(element)) {\n\t\t// Open editors view\n\t\tif (list instanceof List) {\n\t\t\tconst selection = coalesce(list.getSelectedElements().filter(s => s instanceof OpenEditor));\n\t\t\tconst focusedElements = list.getFocusedElements();\n\t\t\tconst focus = focusedElements.length ? focusedElements[0] : undefined;\n\t\t\tlet mainEditor: IEditorIdentifier | undefined = undefined;\n\t\t\tif (focus instanceof OpenEditor) {\n\t\t\t\tmainEditor = focus;\n\t\t\t}\n\t\t\t// We only respect the selection if it contains the main element.\n\t\t\tif (selection.some(s => s === mainEditor)) {\n\t\t\t\treturn selection;\n\t\t\t}\n\t\t\treturn mainEditor ? [mainEditor] : undefined;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { IListService } from '../../../../platform/list/browser/listService.js';\nimport { OpenEditor, ISortOrderConfiguration } from '../common/files.js';\nimport { EditorResourceAccessor, SideBySideEditor, IEditorIdentifier } from '../../../common/editor.js';\nimport { List } from '../../../../base/browser/ui/list/listWidget.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { ExplorerItem } from '../common/explorerModel.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { AsyncDataTree } from '../../../../base/browser/ui/tree/asyncDataTree.js';\nimport { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';\nimport { IEditableData } from '../../../common/views.js';\nimport { createDecorator, ServicesAccessor } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ResourceFileEdit } from '../../../../editor/browser/services/bulkEditService.js';\nimport { ProgressLocation } from '../../../../platform/progress/common/progress.js';\nimport { isActiveElement } from '../../../../base/browser/dom.js';\n\nexport interface IExplorerService {\n\treadonly _serviceBrand: undefined;\n\treadonly roots: ExplorerItem[];\n\treadonly sortOrderConfiguration: ISortOrderConfiguration;\n\n\tgetContext(respectMultiSelection: boolean, ignoreNestedChildren?: boolean): ExplorerItem[];\n\thasViewFocus(): boolean;\n\tsetEditable(stat: ExplorerItem, data: IEditableData | null): Promise<void>;\n\tgetEditable(): { stat: ExplorerItem; data: IEditableData } | undefined;\n\tgetEditableData(stat: ExplorerItem): IEditableData | undefined;\n\t// If undefined is passed checks if any element is currently being edited.\n\tisEditable(stat: ExplorerItem | undefined): boolean;\n\tfindClosest(resource: URI): ExplorerItem | null;\n\tfindClosestRoot(resource: URI): ExplorerItem | null;\n\trefresh(): Promise<void>;\n\tsetToCopy(stats: ExplorerItem[], cut: boolean): Promise<void>;\n\tisCut(stat: ExplorerItem): boolean;\n\tapplyBulkEdit(edit: ResourceFileEdit[], options: { undoLabel: string; progressLabel: string; confirmBeforeUndo?: boolean; progressLocation?: ProgressLocation.Explorer | ProgressLocation.Window }): Promise<void>;\n\n\t/**\n\t * Selects and reveal the file element provided by the given resource if its found in the explorer.\n\t * Will try to resolve the path in case the explorer is not yet expanded to the file yet.\n\t */\n\tselect(resource: URI, reveal?: boolean | string): Promise<void>;\n\n\tregisterView(contextAndRefreshProvider: IExplorerView): void;\n}\n\nexport const IExplorerService = createDecorator<IExplorerService>('explorerService');\n\nexport interface IExplorerView {\n\tautoReveal: boolean | 'force' | 'focusNoScroll';\n\tgetContext(respectMultiSelection: boolean): ExplorerItem[];\n\trefresh(recursive: boolean, item?: ExplorerItem, cancelEditing?: boolean): Promise<void>;\n\tselectResource(resource: URI | undefined, reveal?: boolean | string, retry?: number): Promise<void>;\n\tsetTreeInput(): Promise<void>;\n\titemsCopied(tats: ExplorerItem[], cut: boolean, previousCut: ExplorerItem[] | undefined): void;\n\tsetEditable(stat: ExplorerItem, isEditing: boolean): Promise<void>;\n\tisItemVisible(item: ExplorerItem): boolean;\n\tisItemCollapsed(item: ExplorerItem): boolean;\n\thasFocus(): boolean;\n\tgetFocus(): ExplorerItem[];\n\tfocusNext(): void;\n\tfocusLast(): void;\n\thasPhantomElements(): boolean;\n}\n\nfunction getFocus(listService: IListService): unknown | undefined {\n\tconst list = listService.lastFocusedList;\n\tconst element = list?.getHTMLElement();\n\tif (element && isActiveElement(element)) {\n\t\tlet focus: unknown;\n\t\tif (list instanceof List) {\n\t\t\tconst focused = list.getFocusedElements();\n\t\t\tif (focused.length) {\n\t\t\t\tfocus = focused[0];\n\t\t\t}\n\t\t} else if (list instanceof AsyncDataTree) {\n\t\t\tconst focused = list.getFocus();\n\t\t\tif (focused.length) {\n\t\t\t\tfocus = focused[0];\n\t\t\t}\n\t\t}\n\n\t\treturn focus;\n\t}\n\n\treturn undefined;\n}\n\n// Commands can get executed from a command palette, from a context menu or from some list using a keybinding\n// To cover all these cases we need to properly compute the resource on which the command is being executed\nexport function getResourceForCommand(commandArg: unknown, editorService: IEditorService, listService: IListService): URI | undefined {\n\tif (URI.isUri(commandArg)) {\n\t\treturn commandArg;\n\t}\n\n\tconst focus = getFocus(listService);\n\tif (focus instanceof ExplorerItem) {\n\t\treturn focus.resource;\n\t} else if (focus instanceof OpenEditor) {\n\t\treturn focus.getResource();\n\t}\n\n\treturn EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });\n}\n\nexport function getMultiSelectedResources(commandArg: unknown, listService: IListService, editorSerice: IEditorService, editorGroupService: IEditorGroupsService, explorerService: IExplorerService): Array<URI> {\n\tconst list = listService.lastFocusedList;\n\tconst element = list?.getHTMLElement();\n\tif (element && isActiveElement(element)) {\n\t\t// Explorer\n\t\tif (list instanceof AsyncDataTree && list.getFocus().every(item => item instanceof ExplorerItem)) {\n\t\t\t// Explorer\n\t\t\tconst context = explorerService.getContext(true, true);\n\t\t\tif (context.length) {\n\t\t\t\treturn context.map(c => c.resource);\n\t\t\t}\n\t\t}\n\n\t\t// Open editors view\n\t\tif (list instanceof List) {\n\t\t\tconst selection = coalesce(list.getSelectedElements().filter(s => s instanceof OpenEditor).map((oe: OpenEditor) => oe.getResource()));\n\t\t\tconst focusedElements = list.getFocusedElements();\n\t\t\tconst focus = focusedElements.length ? focusedElements[0] : undefined;\n\t\t\tlet mainUriStr: string | undefined = undefined;\n\t\t\tif (URI.isUri(commandArg)) {\n\t\t\t\tmainUriStr = commandArg.toString();\n\t\t\t} else if (focus instanceof OpenEditor) {\n\t\t\t\tconst focusedResource = focus.getResource();\n\t\t\t\tmainUriStr = focusedResource ? focusedResource.toString() : undefined;\n\t\t\t}\n\t\t\t// We only respect the selection if it contains the main element.\n\t\t\tconst mainIndex = selection.findIndex(s => s.toString() === mainUriStr);\n\t\t\tif (mainIndex !== -1) {\n\t\t\t\t// Move the main resource to the front of the selection.\n\t\t\t\tconst mainResource = selection[mainIndex];\n\t\t\t\tselection.splice(mainIndex, 1);\n\t\t\t\tselection.unshift(mainResource);\n\t\t\t\treturn selection;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check for tabs multiselect\n\tconst activeGroup = editorGroupService.activeGroup;\n\tconst selection = activeGroup.selectedEditors;\n\tif (selection.length > 1 && URI.isUri(commandArg)) {\n\t\t// If the resource is part of the tabs selection, return all selected tabs/resources.\n\t\t// It's possible that multiple tabs are selected but the action was applied to a resource that is not part of the selection.\n\t\tconst mainEditorSelectionIndex = selection.findIndex(e => e.matches({ resource: commandArg }));\n\t\tif (mainEditorSelectionIndex !== -1) {\n\t\t\tconst mainEditor = selection[mainEditorSelectionIndex];\n\t\t\tselection.splice(mainEditorSelectionIndex, 1);\n\t\t\tselection.unshift(mainEditor);\n\t\t\treturn selection.map(editor => EditorResourceAccessor.getOriginalUri(editor)).filter(uri => !!uri);\n\t\t}\n\t}\n\n\tconst result = getResourceForCommand(commandArg, editorSerice, listService);\n\treturn result ? [result] : [];\n}\n\nexport function getOpenEditorsViewMultiSelection(accessor: ServicesAccessor): Array<IEditorIdentifier> | undefined {\n\tconst list = accessor.get(IListService).lastFocusedList;\n\tconst element = list?.getHTMLElement();\n\tif (element && isActiveElement(element)) {\n\t\t// Open editors view\n\t\tif (list instanceof List) {\n\t\t\tconst selection = coalesce(list.getSelectedElements().filter(s => s instanceof OpenEditor));\n\t\t\tconst focusedElements = list.getFocusedElements();\n\t\t\tconst focus = focusedElements.length ? focusedElements[0] : undefined;\n\t\t\tlet mainEditor: IEditorIdentifier | undefined = undefined;\n\t\t\tif (focus instanceof OpenEditor) {\n\t\t\t\tmainEditor = focus;\n\t\t\t}\n\t\t\t// We only respect the selection if it contains the main element.\n\t\t\tif (selection.some(s => s === mainEditor)) {\n\t\t\t\treturn selection;\n\t\t\t}\n\t\t\treturn mainEditor ? [mainEditor] : undefined;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n"]}