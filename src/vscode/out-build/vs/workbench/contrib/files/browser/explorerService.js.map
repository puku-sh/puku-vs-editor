{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/files/browser/explorerService.ts","vs/workbench/contrib/files/browser/explorerService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;AAEhG,OAAO,EAAE,KAAK,EAAE,MAAM,kCAAkC,CAAC;AACzD,OAAO,EAAE,wBAAwB,EAAE,MAAM,oDAAoD,CAAC;AAC9F,OAAO,EAAE,eAAe,EAAE,MAAM,sCAAsC,CAAC;AAEvE,OAAO,EAAE,YAAY,EAAE,aAAa,EAAE,MAAM,4BAA4B,CAAC;AAEzE,OAAO,EAAqC,YAAY,EAAyD,MAAM,4CAA4C,CAAC;AACpK,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,sCAAsC,CAAC;AACzE,OAAO,EAAE,qBAAqB,EAA6B,MAAM,4DAA4D,CAAC;AAC9H,OAAO,EAAE,iBAAiB,EAAE,MAAM,2DAA2D,CAAC;AAC9F,OAAO,EAAE,cAAc,EAAE,MAAM,kDAAkD,CAAC;AAElF,OAAO,EAAE,mBAAmB,EAAE,MAAM,wDAAwD,CAAC;AAC7F,OAAO,EAAE,gBAAgB,EAAoB,MAAM,wDAAwD,CAAC;AAC5G,OAAO,EAAE,cAAc,EAAE,MAAM,kDAAkD,CAAC;AAElF,OAAO,EAAE,gBAAgB,EAAiE,MAAM,kDAAkD,CAAC;AACnJ,OAAO,EAAE,uBAAuB,EAAE,MAAM,yCAAyC,CAAC;AAClF,OAAO,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AACpE,OAAO,EAAE,YAAY,EAAE,MAAM,wCAAwC,CAAC;AAEtE,OAAO,EAAE,mBAAmB,EAAE,MAAM,8BAA8B,CAAC;AACnE,OAAO,EAAE,0BAA0B,EAAE,MAAM,0EAA0E,CAAC;AAEtH,MAAM,CAAC,MAAM,gBAAgB,GAAG,IAAI,cAAc,EAAE,CAAC;AAE9C,IAAM,eAAe,GAArB,MAAM,eAAe;;aAGH,sCAAiC,GAAG,GAAH,AAAM,CAAC,GAAC,2FAA2F;IAY5J,YACe,WAAiC,EACxB,oBAAmD,EAChD,cAAgD,EACvD,gBAA2C,EAC9C,aAAqC,EAChC,kBAAwD,EAC3D,eAAkD,EAClD,eAAkD,EACtD,WAAyB,EACX,yBAAsE;QAT5E,gBAAW,GAAX,WAAW,CAAc;QAChB,yBAAoB,GAApB,oBAAoB,CAAuB;QACxC,mBAAc,GAAd,cAAc,CAA0B;QAC/C,qBAAgB,GAAhB,gBAAgB,CAAmB;QACtC,kBAAa,GAAb,aAAa,CAAgB;QACf,uBAAkB,GAAlB,kBAAkB,CAAqB;QAC1C,oBAAe,GAAf,eAAe,CAAkB;QACjC,oBAAe,GAAf,eAAe,CAAkB;QAEvB,8BAAyB,GAAzB,yBAAyB,CAA4B;QApBlF,gBAAW,GAAG,IAAI,eAAe,EAAE,CAAC;QAO7C,qBAAgB,GAAuB,EAAE,CAAC;QAejD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAE7D,IAAI,CAAC,KAAK,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,yBAAyB,CAAC,CAAC;QAC1J,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAEzF,IAAI,CAAC,sBAAsB,GAAG,IAAI,gBAAgB,CAAC,KAAK,IAAI,EAAE;YAC7D,MAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC;YACrC,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;YAE3B,6BAA6B;YAC7B,MAAM,KAAK,GAAG,gCAAwB,CAAC;YACvC,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,wCAAuB,EAAE,CAAC;gBAClD,KAAK,CAAC,IAAI,gCAAwB,CAAC;YACpC,CAAC;YAED,IAAI,aAAa,GAAG,KAAK,CAAC;YAC1B,0GAA0G;YAC1G,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;gBACtB,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;oBACjC,aAAa,GAAG,mBAAmB,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;gBAClE,CAAC;YACF,CAAC,CAAC,CAAC;YACH,mHAAmH;YACnH,qGAAqG;YACrG,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;gBAClB,IAAI,CAAC,aAAa,EAAE,CAAC;oBACpB,KAAK,MAAM,QAAQ,IAAI,CAAC,CAAC,QAAQ,EAAE,CAAC;wBACnC,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;wBACzD,0HAA0H;wBAC1H,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC;4BACpD,aAAa,GAAG,IAAI,CAAC;4BACrB,MAAM;wBACP,CAAC;oBACF,CAAC;gBACF,CAAC;YACF,CAAC,CAAC,CAAC;YAEH,IAAI,aAAa,EAAE,CAAC;gBACnB,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAC3B,CAAC;QAEF,CAAC,EAAE,iBAAe,CAAC,iCAAiC,CAAC,CAAC;QAEtD,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE;YAC1D,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC9B,yEAAyE;YACzE,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACnB,OAAO;YACR,CAAC;YACD,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,WAAW,EAAE,EAAE,CAAC;gBAChD,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,CAAC;YACxC,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;QACJ,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,oBAAoB,CAAC,wBAAwB,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9G,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAqB,IAAI,CAAC,WAAW,CAAC,0CAA0C,EAAE,IAAI,CAAC,WAAW,CAAC,yCAAyC,CAAC,CAAC,KAAK,EAAC,CAAC,EAAC,EAAE;YACrL,IAAI,QAAQ,GAAG,KAAK,CAAC;YACrB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;gBAC5B,IAAI,CAAC,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,EAAE,CAAC;oBACpC,QAAQ,GAAG,IAAI,CAAC;oBAChB,CAAC,CAAC,cAAc,EAAE,CAAC;gBACpB,CAAC;YACF,CAAC,CAAC,CAAC;YACH,IAAI,QAAQ,EAAE,CAAC;gBACd,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;oBACf,MAAM,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC;gBAChC,CAAC;YACF,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;QACJ,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,GAAG,EAAE;YACrD,IAAI,CAAC,IAAI,EAAE,YAAY,EAAE,CAAC;QAC3B,CAAC,CAAC,CAAC,CAAC;QAEJ,wFAAwF;QACxF,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAAE;YAC5D,IAAI,QAAQ,EAAE,CAAC;gBACd,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YACrB,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;QACJ,IAAI,CAAC,oBAAoB,GAAG,IAAI,mBAAmB,CAClD,CAAC,GAAG,EAAE,EAAE,CAAC,iBAAiB,CAAC,oBAAoB,CAAC,QAAQ,CAAsB,EAAE,QAAQ,EAAE,GAAG,EAAE,CAAC,CAAC,EACjG,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,oBAAoB,CAAC,4BAA4B,CAAC,EACnE,cAAc,EAAE,oBAAoB,CAAC,CAAC;QACvC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;IACjD,CAAC;IAED,IAAI,KAAK;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;IACzB,CAAC;IAED,IAAI,sBAAsB;QACzB,OAAO;YACN,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS;YAChC,oBAAoB,EAAE,IAAI,CAAC,MAAM,CAAC,6BAA6B;YAC/D,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,gBAAgB;SACrC,CAAC;IACH,CAAC;IAED,YAAY,CAAC,eAA8B;QAC1C,IAAI,CAAC,IAAI,GAAG,eAAe,CAAC;IAC7B,CAAC;IAED,UAAU,CAAC,qBAA8B,EAAE,uBAAgC,KAAK;QAC/E,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;YAChB,OAAO,EAAE,CAAC;QACX,CAAC;QAED,MAAM,KAAK,GAAG,IAAI,GAAG,CAAe,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,qBAAqB,CAAC,CAAC,CAAC;QACjF,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YACpB,IAAI,CAAC;gBACJ,IAAI,qBAAqB,IAAI,CAAC,oBAAoB,IAAI,IAAI,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;oBAC/G,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;wBACzC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;oBAClB,CAAC;gBACF,CAAC;YACF,CAAC;YAAC,MAAM,CAAC;gBACR,uFAAuF;gBACvF,yDAAyD;gBACzD,OAAO;YACR,CAAC;QACF,CAAC,CAAC,CAAC;QAEH,OAAO,CAAC,GAAG,KAAK,CAAC,CAAC;IACnB,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,IAAwB,EAAE,OAA0J;QACvM,MAAM,uBAAuB,GAAG,IAAI,uBAAuB,EAAE,CAAC;QAC9D,MAAM,QAAQ,GAAG,OAAO,CAAC,gBAAgB,oCAA2B,CAAC;QACrE,IAAI,eAAe,CAAC;QACpB,IAAI,QAAQ,qCAA4B,EAAE,CAAC;YAC1C,eAAe,GAAG;gBACjB,QAAQ,EAAE,QAAQ;gBAClB,KAAK,EAAE,OAAO,CAAC,aAAa;gBAC5B,WAAW,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC;aACD,CAAC;QAC9B,CAAC;aAAM,CAAC;YACP,eAAe,GAAG;gBACjB,QAAQ,EAAE,QAAQ;gBAClB,KAAK,EAAE,OAAO,CAAC,aAAa;gBAC5B,WAAW,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC;gBAC5B,KAAK,EAAE,GAAG;aAC0B,CAAC;QACvC,CAAC;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,eAAe,EAAE,KAAK,EAAC,QAAQ,EAAC,EAAE;YACnF,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,EAAE;gBACtC,cAAc,EAAE,gBAAgB;gBAChC,KAAK,EAAE,OAAO,CAAC,SAAS;gBACxB,IAAI,EAAE,4BAA4B;gBAClC,QAAQ;gBACR,KAAK,EAAE,uBAAuB,CAAC,KAAK;gBACpC,iBAAiB,EAAE,OAAO,CAAC,iBAAiB;aAC5C,CAAC,CAAC;QACJ,CAAC,EAAE,GAAG,EAAE,CAAC,uBAAuB,CAAC,MAAM,EAAE,CAAC,CAAC;QAC3C,MAAM,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,EAAE,QAAQ,mCAA2B,EAAE,KAAK,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,CAAC;QAC5G,uBAAuB,CAAC,OAAO,EAAE,CAAC;IACnC,CAAC;IAED,YAAY;QACX,OAAO,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;IAC5C,CAAC;IAED,2BAA2B;IAE3B,WAAW,CAAC,QAAa;QACxB,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IACzC,CAAC;IAED,eAAe,CAAC,QAAa;QAC5B,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,eAAe,CAAC,QAAQ,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC;aACpH,IAAI,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACpF,OAAO,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IACnD,CAAC;IAED,KAAK,CAAC,WAAW,CAAC,IAAkB,EAAE,IAA0B;QAC/D,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;YAChB,OAAO;QACR,CAAC;QAED,IAAI,CAAC,IAAI,EAAE,CAAC;YACX,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;QAC3B,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,QAAQ,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;QAChC,CAAC;QACD,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACxC,IAAI,CAAC;YACJ,MAAM,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QAC9C,CAAC;QAAC,MAAM,CAAC;YACR,OAAO;QACR,CAAC;QAGD,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,gBAAgB,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,WAAW,EAAE,EAAE,CAAC;YAClG,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,CAAC;QACxC,CAAC;IACF,CAAC;IAED,KAAK,CAAC,SAAS,CAAC,KAAqB,EAAE,GAAY;QAClD,MAAM,kBAAkB,GAAG,IAAI,CAAC,QAAQ,CAAC;QACzC,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC;QACxC,MAAM,IAAI,CAAC,gBAAgB,CAAC,cAAc,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;QAEvE,IAAI,CAAC,IAAI,EAAE,WAAW,CAAC,KAAK,EAAE,GAAG,EAAE,kBAAkB,CAAC,CAAC;IACxD,CAAC;IAED,KAAK,CAAC,IAAkB;QACvB,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;IACtH,CAAC;IAED,WAAW;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC;IACtB,CAAC;IAED,eAAe,CAAC,IAAkB;QACjC,OAAO,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC;IACtF,CAAC;IAED,UAAU,CAAC,IAA8B;QACxC,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC;IAClE,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,QAAa,EAAE,MAAyB;QACpD,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;YAChB,OAAO;QACR,CAAC;QAED,8FAA8F;QAC9F,MAAM,oBAAoB,GAAG,MAAM,KAAK,OAAO,CAAC;QAEhD,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QAC5C,IAAI,QAAQ,EAAE,CAAC;YACd,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAE,oBAAoB,CAAC,EAAE,CAAC;gBAChE,OAAO;YACR,CAAC;YACD,MAAM,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;YAC1D,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QACnC,CAAC;QAED,oDAAoD;QACpD,MAAM,OAAO,GAAwB,EAAE,SAAS,EAAE,CAAC,QAAQ,CAAC,EAAE,eAAe,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,wCAAuB,EAAE,CAAC;QAC9H,MAAM,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;QAC5C,IAAI,CAAC,IAAI,EAAE,CAAC;YACX,OAAO,SAAS,CAAC;QAClB,CAAC;QAED,IAAI,CAAC;YACJ,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YAEpE,mBAAmB;YACnB,MAAM,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,yBAAyB,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;YACvJ,8BAA8B;YAC9B,YAAY,CAAC,kBAAkB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;YACjD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACjC,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YAEpC,kEAAkE;YAClE,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,oBAAoB,CAAC,EAAE,CAAC;gBACpE,OAAO;YACR,CAAC;YACD,MAAM,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;QAC1E,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;YACnB,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QACtC,CAAC;IACF,CAAC;IAED,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,IAAI;QAC1B,gFAAgF;QAChF,IAAI,IAAI,CAAC,IAAI,EAAE,kBAAkB,EAAE,EAAE,CAAC;YACrC,OAAO;QACR,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,cAAc,EAAE,CAAC,CAAC;QAClD,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;YACf,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC9B,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE,QAAQ,CAAC;YAC3D,MAAM,UAAU,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAuB,CAAC,QAAQ,CAAC,UAAU,CAAC;YAEjG,IAAI,MAAM,IAAI,QAAQ,IAAI,UAAU,EAAE,CAAC;gBACtC,4DAA4D;gBAC5D,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;YACnC,CAAC;QACF,CAAC;IACF,CAAC;IAED,cAAc;IAEN,KAAK,CAAC,iBAAiB,CAAC,CAAqB;QACpD,kFAAkF;QAClF,8EAA8E;QAC9E,mGAAmG;QACnG,MAAM,iBAAiB,GAAG,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC;QAE1D,MAAM;QACN,IAAI,CAAC,CAAC,WAAW,8BAAsB,IAAI,CAAC,CAAC,WAAW,4BAAoB,EAAE,CAAC;YAC9E,MAAM,YAAY,GAAG,CAAC,CAAC,MAAM,CAAC;YAC9B,MAAM,cAAc,GAAG,OAAO,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;YACtD,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;YAEnD,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;gBAEpB,yCAAyC;gBACzC,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAC,CAAC,EAAC,EAAE;oBACvC,oDAAoD;oBACpD,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,KAAK,UAAU,CAAC;oBAC7D,IAAI,CAAC,CAAC,CAAC,mBAAmB,EAAE,CAAC;wBAC5B,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,EAAE,EAAE,eAAe,EAAE,CAAC,CAAC;wBAC7E,IAAI,IAAI,EAAE,CAAC;4BACV,MAAM,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,yBAAyB,EAAE,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;4BACnI,YAAY,CAAC,kBAAkB,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;wBAC/C,CAAC;oBACF,CAAC;oBAED,MAAM,YAAY,GAAG,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,yBAAyB,EAAE,YAAY,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;oBAC9I,8DAA8D;oBAC9D,CAAC,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;oBAC5B,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;oBACzB,4BAA4B;oBAC5B,MAAM,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC;gBAChD,CAAC,CAAC,CAAC,CAAC;YACL,CAAC;QACF,CAAC;QAED,0BAA0B;aACrB,IAAI,CAAC,CAAC,WAAW,4BAAoB,EAAE,CAAC;YAC5C,MAAM,WAAW,GAAG,CAAC,CAAC,QAAQ,CAAC;YAC/B,MAAM,UAAU,GAAG,CAAC,CAAC,MAAM,CAAC;YAC5B,MAAM,iBAAiB,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC;YAC/C,MAAM,iBAAiB,GAAG,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YACvD,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YACtD,MAAM,cAAc,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,OAAO,CAAC,iBAAiB,EAAE,iBAAiB,CAAC,CAAC;YAEjJ,gBAAgB;YAChB,IAAI,cAAc,EAAE,CAAC;gBACpB,MAAM,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAC,YAAY,EAAC,EAAE;oBACxD,sBAAsB;oBACtB,YAAY,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;oBAChC,MAAM,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,iBAAiB,EAAE,YAAY,CAAC,MAAM,CAAC,CAAC;gBAClE,CAAC,CAAC,CAAC,CAAC;YACL,CAAC;YAED,cAAc;iBACT,CAAC;gBACL,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;gBACzD,IAAI,UAAU,CAAC,MAAM,IAAI,aAAa,CAAC,MAAM,EAAE,CAAC;oBAC/C,gBAAgB;oBAChB,MAAM,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,EAAE;wBACjE,MAAM,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC;wBACtC,MAAM,eAAe,GAAG,YAAY,CAAC,YAAY,CAAC;wBAClD,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;wBACrC,IAAI,eAAe,EAAE,CAAC;4BACrB,MAAM,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;wBAClD,CAAC;wBACD,MAAM,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;wBAC3C,MAAM,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,iBAAiB,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;oBAChE,CAAC,CAAC,CAAC,CAAC;gBACL,CAAC;YACF,CAAC;QACF,CAAC;QAED,SAAS;aACJ,IAAI,CAAC,CAAC,WAAW,8BAAsB,EAAE,CAAC;YAC9C,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;YACrD,MAAM,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAC,YAAY,EAAC,EAAE;gBACxD,IAAI,YAAY,CAAC,MAAM,EAAE,CAAC;oBACzB,qCAAqC;oBACrC,MAAM,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC;oBACnC,MAAM,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;oBACjC,IAAI,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC;oBAEvB,MAAM,eAAe,GAAG,YAAY,CAAC,YAAY,CAAC;oBAClD,IAAI,eAAe,EAAE,CAAC;wBACrB,eAAe,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;wBAC1C,MAAM,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;oBAClD,CAAC;oBACD,wBAAwB;oBACxB,MAAM,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,iBAAiB,EAAE,MAAM,CAAC,CAAC;oBAEpD,IAAI,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;wBACxC,IAAI,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC;oBACxB,CAAC;gBACF,CAAC;YACF,CAAC,CAAC,CAAC,CAAC;QACL,CAAC;IACF,CAAC;IAED,gEAAgE;IACxD,oBAAoB,CAAC,IAA8B,EAAE,MAAe;QAC3E,IAAI,IAAI,KAAK,SAAS,IAAI,MAAM,EAAE,CAAC;YAClC,OAAO,IAAI,CAAC;QACb,CAAC;QACD,IAAI,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC;YAC/F,OAAO,KAAK,CAAC;QACd,CAAC;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC;QAC9B,OAAO,WAAW,KAAK,IAAI,EAAE,CAAC;YAC7B,IAAI,WAAW,KAAK,SAAS,EAAE,CAAC;gBAC/B,OAAO,IAAI,CAAC;YACb,CAAC;YACD,IAAI,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAC7D,OAAO,KAAK,CAAC;YACd,CAAC;YACD,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC;QAClC,CAAC;QACD,OAAO,IAAI,CAAC;IACb,CAAC;IAEO,KAAK,CAAC,sBAAsB,CAAC,KAAgC;QACpE,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,UAAU,CAAC,EAAE,CAAC;YAC7C,OAAO;QACR,CAAC;QAED,IAAI,aAAa,GAAG,KAAK,CAAC;QAE1B,IAAI,KAAK,CAAC,oBAAoB,CAAC,sBAAsB,CAAC,EAAE,CAAC;YACxD,aAAa,GAAG,IAAI,CAAC;QACtB,CAAC;QAED,MAAM,aAAa,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAuB,CAAC;QAEhF,MAAM,eAAe,GAAG,aAAa,EAAE,QAAQ,EAAE,SAAS,qCAAqB,CAAC;QAChF,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,KAAK,eAAe,EAAE,CAAC;YAC/C,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,KAAK,SAAS,CAAC;QACrD,CAAC;QAED,MAAM,0BAA0B,GAAG,aAAa,EAAE,QAAQ,EAAE,6BAA6B,gDAAgC,CAAC;QAC1H,IAAI,IAAI,CAAC,MAAM,CAAC,6BAA6B,KAAK,0BAA0B,EAAE,CAAC;YAC9E,aAAa,GAAG,aAAa,IAAI,IAAI,CAAC,MAAM,CAAC,6BAA6B,KAAK,SAAS,CAAC;QAC1F,CAAC;QACD,MAAM,gBAAgB,GAAG,aAAa,EAAE,QAAQ,EAAE,gBAAgB,IAAI,KAAK,CAAC;QAE5E,IAAI,IAAI,CAAC,MAAM,CAAC,gBAAgB,KAAK,gBAAgB,EAAE,CAAC;YACvD,aAAa,GAAG,aAAa,IAAI,IAAI,CAAC,MAAM,CAAC,gBAAgB,KAAK,SAAS,CAAC;QAC7E,CAAC;QAED,IAAI,CAAC,MAAM,GAAG,aAAa,CAAC,QAAQ,CAAC;QAErC,IAAI,aAAa,EAAE,CAAC;YACnB,MAAM,IAAI,CAAC,OAAO,EAAE,CAAC;QACtB,CAAC;IACF,CAAC;IAED,OAAO;QACN,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;IAC5B,CAAC;;AAvdW,eAAe;IAgBzB,WAAA,YAAY,CAAA;IACZ,WAAA,qBAAqB,CAAA;IACrB,WAAA,wBAAwB,CAAA;IACxB,WAAA,iBAAiB,CAAA;IACjB,WAAA,cAAc,CAAA;IACd,WAAA,mBAAmB,CAAA;IACnB,WAAA,gBAAgB,CAAA;IAChB,WAAA,gBAAgB,CAAA;IAChB,WAAA,YAAY,CAAA;IACZ,WAAA,0BAA0B,CAAA;GAzBhB,eAAe,CAwd3B;;AAED,SAAS,mBAAmB,CAAC,IAAkB,EAAE,IAAmB,EAAE,MAA0B,EAAE,KAAuB;IACxH,KAAK,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;QAC5C,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,CAAC;YAC/B,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,KAAK,CAAC,CAAC,EAAE,CAAC;gBAC5D,OAAO,IAAI,CAAC;YACb,CAAC;YACD,IAAI,KAAK,CAAC,WAAW,IAAI,KAAK,CAAC,mBAAmB,EAAE,CAAC;gBACpD,IAAI,mBAAmB,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,CAAC;oBACrD,OAAO,IAAI,CAAC;gBACb,CAAC;YACF,CAAC;QACF,CAAC;IACF,CAAC;IAED,OAAO,KAAK,CAAC;AACd,CAAC;AAED,SAAS,iBAAiB,CAAC,aAAkC;IAC5D,MAAM,cAAc,GAAG,aAAa,EAAE,QAAQ,EAAE,iBAAiB,CAAC;IAElE,IAAI,CAAC,cAAc,EAAE,CAAC;QACrB,OAAO,EAAE,CAAC;IACX,CAAC;IAED,OAAO,cAAc,CAAC;AACvB,CAAC","file":"explorerService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { IFilesConfiguration, ISortOrderConfiguration, SortOrder, LexicographicOptions } from '../common/files.js';\nimport { ExplorerItem, ExplorerModel } from '../common/explorerModel.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { FileOperationEvent, FileOperation, IFileService, FileChangesEvent, FileChangeType, IResolveFileOptions } from '../../../../platform/files/common/files.js';\nimport { dirname, basename } from '../../../../base/common/resources.js';\nimport { IConfigurationService, IConfigurationChangeEvent } from '../../../../platform/configuration/common/configuration.js';\nimport { IClipboardService } from '../../../../platform/clipboard/common/clipboardService.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { IEditableData } from '../../../common/views.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IBulkEditService, ResourceFileEdit } from '../../../../editor/browser/services/bulkEditService.js';\nimport { UndoRedoSource } from '../../../../platform/undoRedo/common/undoRedo.js';\nimport { IExplorerView, IExplorerService } from './files.js';\nimport { IProgressService, ProgressLocation, IProgressCompositeOptions, IProgressOptions } from '../../../../platform/progress/common/progress.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { IHostService } from '../../../services/host/browser/host.js';\nimport { IExpression } from '../../../../base/common/glob.js';\nimport { ResourceGlobMatcher } from '../../../common/resources.js';\nimport { IFilesConfigurationService } from '../../../services/filesConfiguration/common/filesConfigurationService.js';\n\nexport const UNDO_REDO_SOURCE = new UndoRedoSource();\n\nexport class ExplorerService implements IExplorerService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly EXPLORER_FILE_CHANGES_REACT_DELAY = 500; // delay in ms to react to file changes to give our internal events a chance to react first\n\n\tprivate readonly disposables = new DisposableStore();\n\tprivate editable: { stat: ExplorerItem; data: IEditableData } | undefined;\n\tprivate config: IFilesConfiguration['explorer'];\n\tprivate cutItems: ExplorerItem[] | undefined;\n\tprivate view: IExplorerView | undefined;\n\tprivate model: ExplorerModel;\n\tprivate onFileChangesScheduler: RunOnceScheduler;\n\tprivate fileChangeEvents: FileChangesEvent[] = [];\n\tprivate revealExcludeMatcher: ResourceGlobMatcher;\n\n\tconstructor(\n\t\t@IFileService private fileService: IFileService,\n\t\t@IConfigurationService private configurationService: IConfigurationService,\n\t\t@IWorkspaceContextService private contextService: IWorkspaceContextService,\n\t\t@IClipboardService private clipboardService: IClipboardService,\n\t\t@IEditorService private editorService: IEditorService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@IBulkEditService private readonly bulkEditService: IBulkEditService,\n\t\t@IProgressService private readonly progressService: IProgressService,\n\t\t@IHostService hostService: IHostService,\n\t\t@IFilesConfigurationService private readonly filesConfigurationService: IFilesConfigurationService\n\t) {\n\t\tthis.config = this.configurationService.getValue('explorer');\n\n\t\tthis.model = new ExplorerModel(this.contextService, this.uriIdentityService, this.fileService, this.configurationService, this.filesConfigurationService);\n\t\tthis.disposables.add(this.model);\n\t\tthis.disposables.add(this.fileService.onDidRunOperation(e => this.onDidRunOperation(e)));\n\n\t\tthis.onFileChangesScheduler = new RunOnceScheduler(async () => {\n\t\t\tconst events = this.fileChangeEvents;\n\t\t\tthis.fileChangeEvents = [];\n\n\t\t\t// Filter to the ones we care\n\t\t\tconst types = [FileChangeType.DELETED];\n\t\t\tif (this.config.sortOrder === SortOrder.Modified) {\n\t\t\t\ttypes.push(FileChangeType.UPDATED);\n\t\t\t}\n\n\t\t\tlet shouldRefresh = false;\n\t\t\t// For DELETED and UPDATED events go through the explorer model and check if any of the items got affected\n\t\t\tthis.roots.forEach(r => {\n\t\t\t\tif (this.view && !shouldRefresh) {\n\t\t\t\t\tshouldRefresh = doesFileEventAffect(r, this.view, events, types);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// For ADDED events we need to go through all the events and check if the explorer is already aware of some of them\n\t\t\t// Or if they affect not yet resolved parts of the explorer. If that is the case we will not refresh.\n\t\t\tevents.forEach(e => {\n\t\t\t\tif (!shouldRefresh) {\n\t\t\t\t\tfor (const resource of e.rawAdded) {\n\t\t\t\t\t\tconst parent = this.model.findClosest(dirname(resource));\n\t\t\t\t\t\t// Parent of the added resource is resolved and the explorer model is not aware of the added resource - we need to refresh\n\t\t\t\t\t\tif (parent && !parent.getChild(basename(resource))) {\n\t\t\t\t\t\t\tshouldRefresh = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (shouldRefresh) {\n\t\t\t\tawait this.refresh(false);\n\t\t\t}\n\n\t\t}, ExplorerService.EXPLORER_FILE_CHANGES_REACT_DELAY);\n\n\t\tthis.disposables.add(this.fileService.onDidFilesChange(e => {\n\t\t\tthis.fileChangeEvents.push(e);\n\t\t\t// Don't mess with the file tree while in the process of editing. #112293\n\t\t\tif (this.editable) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!this.onFileChangesScheduler.isScheduled()) {\n\t\t\t\tthis.onFileChangesScheduler.schedule();\n\t\t\t}\n\t\t}));\n\t\tthis.disposables.add(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(e)));\n\t\tthis.disposables.add(Event.any<{ scheme: string }>(this.fileService.onDidChangeFileSystemProviderRegistrations, this.fileService.onDidChangeFileSystemProviderCapabilities)(async e => {\n\t\t\tlet affected = false;\n\t\t\tthis.model.roots.forEach(r => {\n\t\t\t\tif (r.resource.scheme === e.scheme) {\n\t\t\t\t\taffected = true;\n\t\t\t\t\tr.forgetChildren();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (affected) {\n\t\t\t\tif (this.view) {\n\t\t\t\t\tawait this.view.setTreeInput();\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\tthis.disposables.add(this.model.onDidChangeRoots(() => {\n\t\t\tthis.view?.setTreeInput();\n\t\t}));\n\n\t\t// Refresh explorer when window gets focus to compensate for missing file events #126817\n\t\tthis.disposables.add(hostService.onDidChangeFocus(hasFocus => {\n\t\t\tif (hasFocus) {\n\t\t\t\tthis.refresh(false);\n\t\t\t}\n\t\t}));\n\t\tthis.revealExcludeMatcher = new ResourceGlobMatcher(\n\t\t\t(uri) => getRevealExcludes(configurationService.getValue<IFilesConfiguration>({ resource: uri })),\n\t\t\t(event) => event.affectsConfiguration('explorer.autoRevealExclude'),\n\t\t\tcontextService, configurationService);\n\t\tthis.disposables.add(this.revealExcludeMatcher);\n\t}\n\n\tget roots(): ExplorerItem[] {\n\t\treturn this.model.roots;\n\t}\n\n\tget sortOrderConfiguration(): ISortOrderConfiguration {\n\t\treturn {\n\t\t\tsortOrder: this.config.sortOrder,\n\t\t\tlexicographicOptions: this.config.sortOrderLexicographicOptions,\n\t\t\treverse: this.config.sortOrderReverse,\n\t\t};\n\t}\n\n\tregisterView(contextProvider: IExplorerView): void {\n\t\tthis.view = contextProvider;\n\t}\n\n\tgetContext(respectMultiSelection: boolean, ignoreNestedChildren: boolean = false): ExplorerItem[] {\n\t\tif (!this.view) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst items = new Set<ExplorerItem>(this.view.getContext(respectMultiSelection));\n\t\titems.forEach(item => {\n\t\t\ttry {\n\t\t\t\tif (respectMultiSelection && !ignoreNestedChildren && this.view?.isItemCollapsed(item) && item.nestedChildren) {\n\t\t\t\t\tfor (const child of item.nestedChildren) {\n\t\t\t\t\t\titems.add(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// We will error out trying to resolve collapsed nodes that have not yet been resolved.\n\t\t\t\t// So we catch and ignore them in the multiSelect context\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\n\t\treturn [...items];\n\t}\n\n\tasync applyBulkEdit(edit: ResourceFileEdit[], options: { undoLabel: string; progressLabel: string; confirmBeforeUndo?: boolean; progressLocation?: ProgressLocation.Explorer | ProgressLocation.Window }): Promise<void> {\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tconst location = options.progressLocation ?? ProgressLocation.Window;\n\t\tlet progressOptions;\n\t\tif (location === ProgressLocation.Window) {\n\t\t\tprogressOptions = {\n\t\t\t\tlocation: location,\n\t\t\t\ttitle: options.progressLabel,\n\t\t\t\tcancellable: edit.length > 1,\n\t\t\t} satisfies IProgressOptions;\n\t\t} else {\n\t\t\tprogressOptions = {\n\t\t\t\tlocation: location,\n\t\t\t\ttitle: options.progressLabel,\n\t\t\t\tcancellable: edit.length > 1,\n\t\t\t\tdelay: 500,\n\t\t\t} satisfies IProgressCompositeOptions;\n\t\t}\n\t\tconst promise = this.progressService.withProgress(progressOptions, async progress => {\n\t\t\tawait this.bulkEditService.apply(edit, {\n\t\t\t\tundoRedoSource: UNDO_REDO_SOURCE,\n\t\t\t\tlabel: options.undoLabel,\n\t\t\t\tcode: 'undoredo.explorerOperation',\n\t\t\t\tprogress,\n\t\t\t\ttoken: cancellationTokenSource.token,\n\t\t\t\tconfirmBeforeUndo: options.confirmBeforeUndo\n\t\t\t});\n\t\t}, () => cancellationTokenSource.cancel());\n\t\tawait this.progressService.withProgress({ location: ProgressLocation.Explorer, delay: 500 }, () => promise);\n\t\tcancellationTokenSource.dispose();\n\t}\n\n\thasViewFocus(): boolean {\n\t\treturn !!this.view && this.view.hasFocus();\n\t}\n\n\t// IExplorerService methods\n\n\tfindClosest(resource: URI): ExplorerItem | null {\n\t\treturn this.model.findClosest(resource);\n\t}\n\n\tfindClosestRoot(resource: URI): ExplorerItem | null {\n\t\tconst parentRoots = this.model.roots.filter(r => this.uriIdentityService.extUri.isEqualOrParent(resource, r.resource))\n\t\t\t.sort((first, second) => second.resource.path.length - first.resource.path.length);\n\t\treturn parentRoots.length ? parentRoots[0] : null;\n\t}\n\n\tasync setEditable(stat: ExplorerItem, data: IEditableData | null): Promise<void> {\n\t\tif (!this.view) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!data) {\n\t\t\tthis.editable = undefined;\n\t\t} else {\n\t\t\tthis.editable = { stat, data };\n\t\t}\n\t\tconst isEditing = this.isEditable(stat);\n\t\ttry {\n\t\t\tawait this.view.setEditable(stat, isEditing);\n\t\t} catch {\n\t\t\treturn;\n\t\t}\n\n\n\t\tif (!this.editable && this.fileChangeEvents.length && !this.onFileChangesScheduler.isScheduled()) {\n\t\t\tthis.onFileChangesScheduler.schedule();\n\t\t}\n\t}\n\n\tasync setToCopy(items: ExplorerItem[], cut: boolean): Promise<void> {\n\t\tconst previouslyCutItems = this.cutItems;\n\t\tthis.cutItems = cut ? items : undefined;\n\t\tawait this.clipboardService.writeResources(items.map(s => s.resource));\n\n\t\tthis.view?.itemsCopied(items, cut, previouslyCutItems);\n\t}\n\n\tisCut(item: ExplorerItem): boolean {\n\t\treturn !!this.cutItems && this.cutItems.some(i => this.uriIdentityService.extUri.isEqual(i.resource, item.resource));\n\t}\n\n\tgetEditable(): { stat: ExplorerItem; data: IEditableData } | undefined {\n\t\treturn this.editable;\n\t}\n\n\tgetEditableData(stat: ExplorerItem): IEditableData | undefined {\n\t\treturn this.editable && this.editable.stat === stat ? this.editable.data : undefined;\n\t}\n\n\tisEditable(stat: ExplorerItem | undefined): boolean {\n\t\treturn !!this.editable && (this.editable.stat === stat || !stat);\n\t}\n\n\tasync select(resource: URI, reveal?: boolean | string): Promise<void> {\n\t\tif (!this.view) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If file or parent matches exclude patterns, do not reveal unless reveal argument is 'force'\n\t\tconst ignoreRevealExcludes = reveal === 'force';\n\n\t\tconst fileStat = this.findClosest(resource);\n\t\tif (fileStat) {\n\t\t\tif (!this.shouldAutoRevealItem(fileStat, ignoreRevealExcludes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tawait this.view.selectResource(fileStat.resource, reveal);\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\t// Stat needs to be resolved first and then revealed\n\t\tconst options: IResolveFileOptions = { resolveTo: [resource], resolveMetadata: this.config.sortOrder === SortOrder.Modified };\n\t\tconst root = this.findClosestRoot(resource);\n\t\tif (!root) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\ttry {\n\t\t\tconst stat = await this.fileService.resolve(root.resource, options);\n\n\t\t\t// Convert to model\n\t\t\tconst modelStat = ExplorerItem.create(this.fileService, this.configurationService, this.filesConfigurationService, stat, undefined, options.resolveTo);\n\t\t\t// Update Input with disk Stat\n\t\t\tExplorerItem.mergeLocalWithDisk(modelStat, root);\n\t\t\tconst item = root.find(resource);\n\t\t\tawait this.view.refresh(true, root);\n\n\t\t\t// Once item is resolved, check again if folder should be expanded\n\t\t\tif (item && !this.shouldAutoRevealItem(item, ignoreRevealExcludes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tawait this.view.selectResource(item ? item.resource : undefined, reveal);\n\t\t} catch (error) {\n\t\t\troot.error = error;\n\t\t\tawait this.view.refresh(false, root);\n\t\t}\n\t}\n\n\tasync refresh(reveal = true): Promise<void> {\n\t\t// Do not refresh the tree when it is showing temporary nodes (phantom elements)\n\t\tif (this.view?.hasPhantomElements()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.model.roots.forEach(r => r.forgetChildren());\n\t\tif (this.view) {\n\t\t\tawait this.view.refresh(true);\n\t\t\tconst resource = this.editorService.activeEditor?.resource;\n\t\t\tconst autoReveal = this.configurationService.getValue<IFilesConfiguration>().explorer.autoReveal;\n\n\t\t\tif (reveal && resource && autoReveal) {\n\t\t\t\t// We did a top level refresh, reveal the active file #67118\n\t\t\t\tthis.select(resource, autoReveal);\n\t\t\t}\n\t\t}\n\t}\n\n\t// File events\n\n\tprivate async onDidRunOperation(e: FileOperationEvent): Promise<void> {\n\t\t// When nesting, changes to one file in a folder may impact the rendered structure\n\t\t// of all the folder's immediate children, thus a recursive refresh is needed.\n\t\t// Ideally the tree would be able to recusively refresh just one level but that does not yet exist.\n\t\tconst shouldDeepRefresh = this.config.fileNesting.enabled;\n\n\t\t// Add\n\t\tif (e.isOperation(FileOperation.CREATE) || e.isOperation(FileOperation.COPY)) {\n\t\t\tconst addedElement = e.target;\n\t\t\tconst parentResource = dirname(addedElement.resource);\n\t\t\tconst parents = this.model.findAll(parentResource);\n\n\t\t\tif (parents.length) {\n\n\t\t\t\t// Add the new file to its parent (Model)\n\t\t\t\tawait Promise.all(parents.map(async p => {\n\t\t\t\t\t// We have to check if the parent is resolved #29177\n\t\t\t\t\tconst resolveMetadata = this.config.sortOrder === `modified`;\n\t\t\t\t\tif (!p.isDirectoryResolved) {\n\t\t\t\t\t\tconst stat = await this.fileService.resolve(p.resource, { resolveMetadata });\n\t\t\t\t\t\tif (stat) {\n\t\t\t\t\t\t\tconst modelStat = ExplorerItem.create(this.fileService, this.configurationService, this.filesConfigurationService, stat, p.parent);\n\t\t\t\t\t\t\tExplorerItem.mergeLocalWithDisk(modelStat, p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst childElement = ExplorerItem.create(this.fileService, this.configurationService, this.filesConfigurationService, addedElement, p.parent);\n\t\t\t\t\t// Make sure to remove any previous version of the file if any\n\t\t\t\t\tp.removeChild(childElement);\n\t\t\t\t\tp.addChild(childElement);\n\t\t\t\t\t// Refresh the Parent (View)\n\t\t\t\t\tawait this.view?.refresh(shouldDeepRefresh, p);\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\t// Move (including Rename)\n\t\telse if (e.isOperation(FileOperation.MOVE)) {\n\t\t\tconst oldResource = e.resource;\n\t\t\tconst newElement = e.target;\n\t\t\tconst oldParentResource = dirname(oldResource);\n\t\t\tconst newParentResource = dirname(newElement.resource);\n\t\t\tconst modelElements = this.model.findAll(oldResource);\n\t\t\tconst sameParentMove = modelElements.every(e => !e.nestedParent) && this.uriIdentityService.extUri.isEqual(oldParentResource, newParentResource);\n\n\t\t\t// Handle Rename\n\t\t\tif (sameParentMove) {\n\t\t\t\tawait Promise.all(modelElements.map(async modelElement => {\n\t\t\t\t\t// Rename File (Model)\n\t\t\t\t\tmodelElement.rename(newElement);\n\t\t\t\t\tawait this.view?.refresh(shouldDeepRefresh, modelElement.parent);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// Handle Move\n\t\t\telse {\n\t\t\t\tconst newParents = this.model.findAll(newParentResource);\n\t\t\t\tif (newParents.length && modelElements.length) {\n\t\t\t\t\t// Move in Model\n\t\t\t\t\tawait Promise.all(modelElements.map(async (modelElement, index) => {\n\t\t\t\t\t\tconst oldParent = modelElement.parent;\n\t\t\t\t\t\tconst oldNestedParent = modelElement.nestedParent;\n\t\t\t\t\t\tmodelElement.move(newParents[index]);\n\t\t\t\t\t\tif (oldNestedParent) {\n\t\t\t\t\t\t\tawait this.view?.refresh(false, oldNestedParent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait this.view?.refresh(false, oldParent);\n\t\t\t\t\t\tawait this.view?.refresh(shouldDeepRefresh, newParents[index]);\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Delete\n\t\telse if (e.isOperation(FileOperation.DELETE)) {\n\t\t\tconst modelElements = this.model.findAll(e.resource);\n\t\t\tawait Promise.all(modelElements.map(async modelElement => {\n\t\t\t\tif (modelElement.parent) {\n\t\t\t\t\t// Remove Element from Parent (Model)\n\t\t\t\t\tconst parent = modelElement.parent;\n\t\t\t\t\tparent.removeChild(modelElement);\n\t\t\t\t\tthis.view?.focusNext();\n\n\t\t\t\t\tconst oldNestedParent = modelElement.nestedParent;\n\t\t\t\t\tif (oldNestedParent) {\n\t\t\t\t\t\toldNestedParent.removeChild(modelElement);\n\t\t\t\t\t\tawait this.view?.refresh(false, oldNestedParent);\n\t\t\t\t\t}\n\t\t\t\t\t// Refresh Parent (View)\n\t\t\t\t\tawait this.view?.refresh(shouldDeepRefresh, parent);\n\n\t\t\t\t\tif (this.view?.getFocus().length === 0) {\n\t\t\t\t\t\tthis.view?.focusLast();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\t// Check if an item matches a explorer.autoRevealExclude pattern\n\tprivate shouldAutoRevealItem(item: ExplorerItem | undefined, ignore: boolean): boolean {\n\t\tif (item === undefined || ignore) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.revealExcludeMatcher.matches(item.resource, name => !!(item.parent?.getChild(name)))) {\n\t\t\treturn false;\n\t\t}\n\t\tconst root = item.root;\n\t\tlet currentItem = item.parent;\n\t\twhile (currentItem !== root) {\n\t\t\tif (currentItem === undefined) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.revealExcludeMatcher.matches(currentItem.resource)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcurrentItem = currentItem.parent;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate async onConfigurationUpdated(event: IConfigurationChangeEvent): Promise<void> {\n\t\tif (!event.affectsConfiguration('explorer')) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet shouldRefresh = false;\n\n\t\tif (event.affectsConfiguration('explorer.fileNesting')) {\n\t\t\tshouldRefresh = true;\n\t\t}\n\n\t\tconst configuration = this.configurationService.getValue<IFilesConfiguration>();\n\n\t\tconst configSortOrder = configuration?.explorer?.sortOrder || SortOrder.Default;\n\t\tif (this.config.sortOrder !== configSortOrder) {\n\t\t\tshouldRefresh = this.config.sortOrder !== undefined;\n\t\t}\n\n\t\tconst configLexicographicOptions = configuration?.explorer?.sortOrderLexicographicOptions || LexicographicOptions.Default;\n\t\tif (this.config.sortOrderLexicographicOptions !== configLexicographicOptions) {\n\t\t\tshouldRefresh = shouldRefresh || this.config.sortOrderLexicographicOptions !== undefined;\n\t\t}\n\t\tconst sortOrderReverse = configuration?.explorer?.sortOrderReverse || false;\n\n\t\tif (this.config.sortOrderReverse !== sortOrderReverse) {\n\t\t\tshouldRefresh = shouldRefresh || this.config.sortOrderReverse !== undefined;\n\t\t}\n\n\t\tthis.config = configuration.explorer;\n\n\t\tif (shouldRefresh) {\n\t\t\tawait this.refresh();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\t}\n}\n\nfunction doesFileEventAffect(item: ExplorerItem, view: IExplorerView, events: FileChangesEvent[], types: FileChangeType[]): boolean {\n\tfor (const [_name, child] of item.children) {\n\t\tif (view.isItemVisible(child)) {\n\t\t\tif (events.some(e => e.contains(child.resource, ...types))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (child.isDirectory && child.isDirectoryResolved) {\n\t\t\t\tif (doesFileEventAffect(child, view, events, types)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction getRevealExcludes(configuration: IFilesConfiguration): IExpression {\n\tconst revealExcludes = configuration?.explorer?.autoRevealExclude;\n\n\tif (!revealExcludes) {\n\t\treturn {};\n\t}\n\n\treturn revealExcludes;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { IFilesConfiguration, ISortOrderConfiguration, SortOrder, LexicographicOptions } from '../common/files.js';\nimport { ExplorerItem, ExplorerModel } from '../common/explorerModel.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { FileOperationEvent, FileOperation, IFileService, FileChangesEvent, FileChangeType, IResolveFileOptions } from '../../../../platform/files/common/files.js';\nimport { dirname, basename } from '../../../../base/common/resources.js';\nimport { IConfigurationService, IConfigurationChangeEvent } from '../../../../platform/configuration/common/configuration.js';\nimport { IClipboardService } from '../../../../platform/clipboard/common/clipboardService.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { IEditableData } from '../../../common/views.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IBulkEditService, ResourceFileEdit } from '../../../../editor/browser/services/bulkEditService.js';\nimport { UndoRedoSource } from '../../../../platform/undoRedo/common/undoRedo.js';\nimport { IExplorerView, IExplorerService } from './files.js';\nimport { IProgressService, ProgressLocation, IProgressCompositeOptions, IProgressOptions } from '../../../../platform/progress/common/progress.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { IHostService } from '../../../services/host/browser/host.js';\nimport { IExpression } from '../../../../base/common/glob.js';\nimport { ResourceGlobMatcher } from '../../../common/resources.js';\nimport { IFilesConfigurationService } from '../../../services/filesConfiguration/common/filesConfigurationService.js';\n\nexport const UNDO_REDO_SOURCE = new UndoRedoSource();\n\nexport class ExplorerService implements IExplorerService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly EXPLORER_FILE_CHANGES_REACT_DELAY = 500; // delay in ms to react to file changes to give our internal events a chance to react first\n\n\tprivate readonly disposables = new DisposableStore();\n\tprivate editable: { stat: ExplorerItem; data: IEditableData } | undefined;\n\tprivate config: IFilesConfiguration['explorer'];\n\tprivate cutItems: ExplorerItem[] | undefined;\n\tprivate view: IExplorerView | undefined;\n\tprivate model: ExplorerModel;\n\tprivate onFileChangesScheduler: RunOnceScheduler;\n\tprivate fileChangeEvents: FileChangesEvent[] = [];\n\tprivate revealExcludeMatcher: ResourceGlobMatcher;\n\n\tconstructor(\n\t\t@IFileService private fileService: IFileService,\n\t\t@IConfigurationService private configurationService: IConfigurationService,\n\t\t@IWorkspaceContextService private contextService: IWorkspaceContextService,\n\t\t@IClipboardService private clipboardService: IClipboardService,\n\t\t@IEditorService private editorService: IEditorService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@IBulkEditService private readonly bulkEditService: IBulkEditService,\n\t\t@IProgressService private readonly progressService: IProgressService,\n\t\t@IHostService hostService: IHostService,\n\t\t@IFilesConfigurationService private readonly filesConfigurationService: IFilesConfigurationService\n\t) {\n\t\tthis.config = this.configurationService.getValue('explorer');\n\n\t\tthis.model = new ExplorerModel(this.contextService, this.uriIdentityService, this.fileService, this.configurationService, this.filesConfigurationService);\n\t\tthis.disposables.add(this.model);\n\t\tthis.disposables.add(this.fileService.onDidRunOperation(e => this.onDidRunOperation(e)));\n\n\t\tthis.onFileChangesScheduler = new RunOnceScheduler(async () => {\n\t\t\tconst events = this.fileChangeEvents;\n\t\t\tthis.fileChangeEvents = [];\n\n\t\t\t// Filter to the ones we care\n\t\t\tconst types = [FileChangeType.DELETED];\n\t\t\tif (this.config.sortOrder === SortOrder.Modified) {\n\t\t\t\ttypes.push(FileChangeType.UPDATED);\n\t\t\t}\n\n\t\t\tlet shouldRefresh = false;\n\t\t\t// For DELETED and UPDATED events go through the explorer model and check if any of the items got affected\n\t\t\tthis.roots.forEach(r => {\n\t\t\t\tif (this.view && !shouldRefresh) {\n\t\t\t\t\tshouldRefresh = doesFileEventAffect(r, this.view, events, types);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// For ADDED events we need to go through all the events and check if the explorer is already aware of some of them\n\t\t\t// Or if they affect not yet resolved parts of the explorer. If that is the case we will not refresh.\n\t\t\tevents.forEach(e => {\n\t\t\t\tif (!shouldRefresh) {\n\t\t\t\t\tfor (const resource of e.rawAdded) {\n\t\t\t\t\t\tconst parent = this.model.findClosest(dirname(resource));\n\t\t\t\t\t\t// Parent of the added resource is resolved and the explorer model is not aware of the added resource - we need to refresh\n\t\t\t\t\t\tif (parent && !parent.getChild(basename(resource))) {\n\t\t\t\t\t\t\tshouldRefresh = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (shouldRefresh) {\n\t\t\t\tawait this.refresh(false);\n\t\t\t}\n\n\t\t}, ExplorerService.EXPLORER_FILE_CHANGES_REACT_DELAY);\n\n\t\tthis.disposables.add(this.fileService.onDidFilesChange(e => {\n\t\t\tthis.fileChangeEvents.push(e);\n\t\t\t// Don't mess with the file tree while in the process of editing. #112293\n\t\t\tif (this.editable) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!this.onFileChangesScheduler.isScheduled()) {\n\t\t\t\tthis.onFileChangesScheduler.schedule();\n\t\t\t}\n\t\t}));\n\t\tthis.disposables.add(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(e)));\n\t\tthis.disposables.add(Event.any<{ scheme: string }>(this.fileService.onDidChangeFileSystemProviderRegistrations, this.fileService.onDidChangeFileSystemProviderCapabilities)(async e => {\n\t\t\tlet affected = false;\n\t\t\tthis.model.roots.forEach(r => {\n\t\t\t\tif (r.resource.scheme === e.scheme) {\n\t\t\t\t\taffected = true;\n\t\t\t\t\tr.forgetChildren();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (affected) {\n\t\t\t\tif (this.view) {\n\t\t\t\t\tawait this.view.setTreeInput();\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\tthis.disposables.add(this.model.onDidChangeRoots(() => {\n\t\t\tthis.view?.setTreeInput();\n\t\t}));\n\n\t\t// Refresh explorer when window gets focus to compensate for missing file events #126817\n\t\tthis.disposables.add(hostService.onDidChangeFocus(hasFocus => {\n\t\t\tif (hasFocus) {\n\t\t\t\tthis.refresh(false);\n\t\t\t}\n\t\t}));\n\t\tthis.revealExcludeMatcher = new ResourceGlobMatcher(\n\t\t\t(uri) => getRevealExcludes(configurationService.getValue<IFilesConfiguration>({ resource: uri })),\n\t\t\t(event) => event.affectsConfiguration('explorer.autoRevealExclude'),\n\t\t\tcontextService, configurationService);\n\t\tthis.disposables.add(this.revealExcludeMatcher);\n\t}\n\n\tget roots(): ExplorerItem[] {\n\t\treturn this.model.roots;\n\t}\n\n\tget sortOrderConfiguration(): ISortOrderConfiguration {\n\t\treturn {\n\t\t\tsortOrder: this.config.sortOrder,\n\t\t\tlexicographicOptions: this.config.sortOrderLexicographicOptions,\n\t\t\treverse: this.config.sortOrderReverse,\n\t\t};\n\t}\n\n\tregisterView(contextProvider: IExplorerView): void {\n\t\tthis.view = contextProvider;\n\t}\n\n\tgetContext(respectMultiSelection: boolean, ignoreNestedChildren: boolean = false): ExplorerItem[] {\n\t\tif (!this.view) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst items = new Set<ExplorerItem>(this.view.getContext(respectMultiSelection));\n\t\titems.forEach(item => {\n\t\t\ttry {\n\t\t\t\tif (respectMultiSelection && !ignoreNestedChildren && this.view?.isItemCollapsed(item) && item.nestedChildren) {\n\t\t\t\t\tfor (const child of item.nestedChildren) {\n\t\t\t\t\t\titems.add(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// We will error out trying to resolve collapsed nodes that have not yet been resolved.\n\t\t\t\t// So we catch and ignore them in the multiSelect context\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\n\t\treturn [...items];\n\t}\n\n\tasync applyBulkEdit(edit: ResourceFileEdit[], options: { undoLabel: string; progressLabel: string; confirmBeforeUndo?: boolean; progressLocation?: ProgressLocation.Explorer | ProgressLocation.Window }): Promise<void> {\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tconst location = options.progressLocation ?? ProgressLocation.Window;\n\t\tlet progressOptions;\n\t\tif (location === ProgressLocation.Window) {\n\t\t\tprogressOptions = {\n\t\t\t\tlocation: location,\n\t\t\t\ttitle: options.progressLabel,\n\t\t\t\tcancellable: edit.length > 1,\n\t\t\t} satisfies IProgressOptions;\n\t\t} else {\n\t\t\tprogressOptions = {\n\t\t\t\tlocation: location,\n\t\t\t\ttitle: options.progressLabel,\n\t\t\t\tcancellable: edit.length > 1,\n\t\t\t\tdelay: 500,\n\t\t\t} satisfies IProgressCompositeOptions;\n\t\t}\n\t\tconst promise = this.progressService.withProgress(progressOptions, async progress => {\n\t\t\tawait this.bulkEditService.apply(edit, {\n\t\t\t\tundoRedoSource: UNDO_REDO_SOURCE,\n\t\t\t\tlabel: options.undoLabel,\n\t\t\t\tcode: 'undoredo.explorerOperation',\n\t\t\t\tprogress,\n\t\t\t\ttoken: cancellationTokenSource.token,\n\t\t\t\tconfirmBeforeUndo: options.confirmBeforeUndo\n\t\t\t});\n\t\t}, () => cancellationTokenSource.cancel());\n\t\tawait this.progressService.withProgress({ location: ProgressLocation.Explorer, delay: 500 }, () => promise);\n\t\tcancellationTokenSource.dispose();\n\t}\n\n\thasViewFocus(): boolean {\n\t\treturn !!this.view && this.view.hasFocus();\n\t}\n\n\t// IExplorerService methods\n\n\tfindClosest(resource: URI): ExplorerItem | null {\n\t\treturn this.model.findClosest(resource);\n\t}\n\n\tfindClosestRoot(resource: URI): ExplorerItem | null {\n\t\tconst parentRoots = this.model.roots.filter(r => this.uriIdentityService.extUri.isEqualOrParent(resource, r.resource))\n\t\t\t.sort((first, second) => second.resource.path.length - first.resource.path.length);\n\t\treturn parentRoots.length ? parentRoots[0] : null;\n\t}\n\n\tasync setEditable(stat: ExplorerItem, data: IEditableData | null): Promise<void> {\n\t\tif (!this.view) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!data) {\n\t\t\tthis.editable = undefined;\n\t\t} else {\n\t\t\tthis.editable = { stat, data };\n\t\t}\n\t\tconst isEditing = this.isEditable(stat);\n\t\ttry {\n\t\t\tawait this.view.setEditable(stat, isEditing);\n\t\t} catch {\n\t\t\treturn;\n\t\t}\n\n\n\t\tif (!this.editable && this.fileChangeEvents.length && !this.onFileChangesScheduler.isScheduled()) {\n\t\t\tthis.onFileChangesScheduler.schedule();\n\t\t}\n\t}\n\n\tasync setToCopy(items: ExplorerItem[], cut: boolean): Promise<void> {\n\t\tconst previouslyCutItems = this.cutItems;\n\t\tthis.cutItems = cut ? items : undefined;\n\t\tawait this.clipboardService.writeResources(items.map(s => s.resource));\n\n\t\tthis.view?.itemsCopied(items, cut, previouslyCutItems);\n\t}\n\n\tisCut(item: ExplorerItem): boolean {\n\t\treturn !!this.cutItems && this.cutItems.some(i => this.uriIdentityService.extUri.isEqual(i.resource, item.resource));\n\t}\n\n\tgetEditable(): { stat: ExplorerItem; data: IEditableData } | undefined {\n\t\treturn this.editable;\n\t}\n\n\tgetEditableData(stat: ExplorerItem): IEditableData | undefined {\n\t\treturn this.editable && this.editable.stat === stat ? this.editable.data : undefined;\n\t}\n\n\tisEditable(stat: ExplorerItem | undefined): boolean {\n\t\treturn !!this.editable && (this.editable.stat === stat || !stat);\n\t}\n\n\tasync select(resource: URI, reveal?: boolean | string): Promise<void> {\n\t\tif (!this.view) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If file or parent matches exclude patterns, do not reveal unless reveal argument is 'force'\n\t\tconst ignoreRevealExcludes = reveal === 'force';\n\n\t\tconst fileStat = this.findClosest(resource);\n\t\tif (fileStat) {\n\t\t\tif (!this.shouldAutoRevealItem(fileStat, ignoreRevealExcludes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tawait this.view.selectResource(fileStat.resource, reveal);\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\t// Stat needs to be resolved first and then revealed\n\t\tconst options: IResolveFileOptions = { resolveTo: [resource], resolveMetadata: this.config.sortOrder === SortOrder.Modified };\n\t\tconst root = this.findClosestRoot(resource);\n\t\tif (!root) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\ttry {\n\t\t\tconst stat = await this.fileService.resolve(root.resource, options);\n\n\t\t\t// Convert to model\n\t\t\tconst modelStat = ExplorerItem.create(this.fileService, this.configurationService, this.filesConfigurationService, stat, undefined, options.resolveTo);\n\t\t\t// Update Input with disk Stat\n\t\t\tExplorerItem.mergeLocalWithDisk(modelStat, root);\n\t\t\tconst item = root.find(resource);\n\t\t\tawait this.view.refresh(true, root);\n\n\t\t\t// Once item is resolved, check again if folder should be expanded\n\t\t\tif (item && !this.shouldAutoRevealItem(item, ignoreRevealExcludes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tawait this.view.selectResource(item ? item.resource : undefined, reveal);\n\t\t} catch (error) {\n\t\t\troot.error = error;\n\t\t\tawait this.view.refresh(false, root);\n\t\t}\n\t}\n\n\tasync refresh(reveal = true): Promise<void> {\n\t\t// Do not refresh the tree when it is showing temporary nodes (phantom elements)\n\t\tif (this.view?.hasPhantomElements()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.model.roots.forEach(r => r.forgetChildren());\n\t\tif (this.view) {\n\t\t\tawait this.view.refresh(true);\n\t\t\tconst resource = this.editorService.activeEditor?.resource;\n\t\t\tconst autoReveal = this.configurationService.getValue<IFilesConfiguration>().explorer.autoReveal;\n\n\t\t\tif (reveal && resource && autoReveal) {\n\t\t\t\t// We did a top level refresh, reveal the active file #67118\n\t\t\t\tthis.select(resource, autoReveal);\n\t\t\t}\n\t\t}\n\t}\n\n\t// File events\n\n\tprivate async onDidRunOperation(e: FileOperationEvent): Promise<void> {\n\t\t// When nesting, changes to one file in a folder may impact the rendered structure\n\t\t// of all the folder's immediate children, thus a recursive refresh is needed.\n\t\t// Ideally the tree would be able to recusively refresh just one level but that does not yet exist.\n\t\tconst shouldDeepRefresh = this.config.fileNesting.enabled;\n\n\t\t// Add\n\t\tif (e.isOperation(FileOperation.CREATE) || e.isOperation(FileOperation.COPY)) {\n\t\t\tconst addedElement = e.target;\n\t\t\tconst parentResource = dirname(addedElement.resource);\n\t\t\tconst parents = this.model.findAll(parentResource);\n\n\t\t\tif (parents.length) {\n\n\t\t\t\t// Add the new file to its parent (Model)\n\t\t\t\tawait Promise.all(parents.map(async p => {\n\t\t\t\t\t// We have to check if the parent is resolved #29177\n\t\t\t\t\tconst resolveMetadata = this.config.sortOrder === `modified`;\n\t\t\t\t\tif (!p.isDirectoryResolved) {\n\t\t\t\t\t\tconst stat = await this.fileService.resolve(p.resource, { resolveMetadata });\n\t\t\t\t\t\tif (stat) {\n\t\t\t\t\t\t\tconst modelStat = ExplorerItem.create(this.fileService, this.configurationService, this.filesConfigurationService, stat, p.parent);\n\t\t\t\t\t\t\tExplorerItem.mergeLocalWithDisk(modelStat, p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst childElement = ExplorerItem.create(this.fileService, this.configurationService, this.filesConfigurationService, addedElement, p.parent);\n\t\t\t\t\t// Make sure to remove any previous version of the file if any\n\t\t\t\t\tp.removeChild(childElement);\n\t\t\t\t\tp.addChild(childElement);\n\t\t\t\t\t// Refresh the Parent (View)\n\t\t\t\t\tawait this.view?.refresh(shouldDeepRefresh, p);\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\t// Move (including Rename)\n\t\telse if (e.isOperation(FileOperation.MOVE)) {\n\t\t\tconst oldResource = e.resource;\n\t\t\tconst newElement = e.target;\n\t\t\tconst oldParentResource = dirname(oldResource);\n\t\t\tconst newParentResource = dirname(newElement.resource);\n\t\t\tconst modelElements = this.model.findAll(oldResource);\n\t\t\tconst sameParentMove = modelElements.every(e => !e.nestedParent) && this.uriIdentityService.extUri.isEqual(oldParentResource, newParentResource);\n\n\t\t\t// Handle Rename\n\t\t\tif (sameParentMove) {\n\t\t\t\tawait Promise.all(modelElements.map(async modelElement => {\n\t\t\t\t\t// Rename File (Model)\n\t\t\t\t\tmodelElement.rename(newElement);\n\t\t\t\t\tawait this.view?.refresh(shouldDeepRefresh, modelElement.parent);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// Handle Move\n\t\t\telse {\n\t\t\t\tconst newParents = this.model.findAll(newParentResource);\n\t\t\t\tif (newParents.length && modelElements.length) {\n\t\t\t\t\t// Move in Model\n\t\t\t\t\tawait Promise.all(modelElements.map(async (modelElement, index) => {\n\t\t\t\t\t\tconst oldParent = modelElement.parent;\n\t\t\t\t\t\tconst oldNestedParent = modelElement.nestedParent;\n\t\t\t\t\t\tmodelElement.move(newParents[index]);\n\t\t\t\t\t\tif (oldNestedParent) {\n\t\t\t\t\t\t\tawait this.view?.refresh(false, oldNestedParent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait this.view?.refresh(false, oldParent);\n\t\t\t\t\t\tawait this.view?.refresh(shouldDeepRefresh, newParents[index]);\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Delete\n\t\telse if (e.isOperation(FileOperation.DELETE)) {\n\t\t\tconst modelElements = this.model.findAll(e.resource);\n\t\t\tawait Promise.all(modelElements.map(async modelElement => {\n\t\t\t\tif (modelElement.parent) {\n\t\t\t\t\t// Remove Element from Parent (Model)\n\t\t\t\t\tconst parent = modelElement.parent;\n\t\t\t\t\tparent.removeChild(modelElement);\n\t\t\t\t\tthis.view?.focusNext();\n\n\t\t\t\t\tconst oldNestedParent = modelElement.nestedParent;\n\t\t\t\t\tif (oldNestedParent) {\n\t\t\t\t\t\toldNestedParent.removeChild(modelElement);\n\t\t\t\t\t\tawait this.view?.refresh(false, oldNestedParent);\n\t\t\t\t\t}\n\t\t\t\t\t// Refresh Parent (View)\n\t\t\t\t\tawait this.view?.refresh(shouldDeepRefresh, parent);\n\n\t\t\t\t\tif (this.view?.getFocus().length === 0) {\n\t\t\t\t\t\tthis.view?.focusLast();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\t// Check if an item matches a explorer.autoRevealExclude pattern\n\tprivate shouldAutoRevealItem(item: ExplorerItem | undefined, ignore: boolean): boolean {\n\t\tif (item === undefined || ignore) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.revealExcludeMatcher.matches(item.resource, name => !!(item.parent?.getChild(name)))) {\n\t\t\treturn false;\n\t\t}\n\t\tconst root = item.root;\n\t\tlet currentItem = item.parent;\n\t\twhile (currentItem !== root) {\n\t\t\tif (currentItem === undefined) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.revealExcludeMatcher.matches(currentItem.resource)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcurrentItem = currentItem.parent;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate async onConfigurationUpdated(event: IConfigurationChangeEvent): Promise<void> {\n\t\tif (!event.affectsConfiguration('explorer')) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet shouldRefresh = false;\n\n\t\tif (event.affectsConfiguration('explorer.fileNesting')) {\n\t\t\tshouldRefresh = true;\n\t\t}\n\n\t\tconst configuration = this.configurationService.getValue<IFilesConfiguration>();\n\n\t\tconst configSortOrder = configuration?.explorer?.sortOrder || SortOrder.Default;\n\t\tif (this.config.sortOrder !== configSortOrder) {\n\t\t\tshouldRefresh = this.config.sortOrder !== undefined;\n\t\t}\n\n\t\tconst configLexicographicOptions = configuration?.explorer?.sortOrderLexicographicOptions || LexicographicOptions.Default;\n\t\tif (this.config.sortOrderLexicographicOptions !== configLexicographicOptions) {\n\t\t\tshouldRefresh = shouldRefresh || this.config.sortOrderLexicographicOptions !== undefined;\n\t\t}\n\t\tconst sortOrderReverse = configuration?.explorer?.sortOrderReverse || false;\n\n\t\tif (this.config.sortOrderReverse !== sortOrderReverse) {\n\t\t\tshouldRefresh = shouldRefresh || this.config.sortOrderReverse !== undefined;\n\t\t}\n\n\t\tthis.config = configuration.explorer;\n\n\t\tif (shouldRefresh) {\n\t\t\tawait this.refresh();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\t}\n}\n\nfunction doesFileEventAffect(item: ExplorerItem, view: IExplorerView, events: FileChangesEvent[], types: FileChangeType[]): boolean {\n\tfor (const [_name, child] of item.children) {\n\t\tif (view.isItemVisible(child)) {\n\t\t\tif (events.some(e => e.contains(child.resource, ...types))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (child.isDirectory && child.isDirectoryResolved) {\n\t\t\t\tif (doesFileEventAffect(child, view, events, types)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction getRevealExcludes(configuration: IFilesConfiguration): IExpression {\n\tconst revealExcludes = configuration?.explorer?.autoRevealExclude;\n\n\tif (!revealExcludes) {\n\t\treturn {};\n\t}\n\n\treturn revealExcludes;\n}\n"]}