{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/files/common/explorerModel.ts","vs/workbench/contrib/files/common/explorerModel.ts"],"names":[],"mappings":"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","file":"explorerModel.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { isEqual } from '../../../../base/common/extpath.js';\nimport { posix } from '../../../../base/common/path.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IFileStat, IFileService, FileSystemProviderCapabilities } from '../../../../platform/files/common/files.js';\nimport { rtrim, startsWithIgnoreCase, equalsIgnoreCase } from '../../../../base/common/strings.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { IDisposable, dispose } from '../../../../base/common/lifecycle.js';\nimport { memoize } from '../../../../base/common/decorators.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { joinPath, isEqualOrParent, basenameOrAuthority } from '../../../../base/common/resources.js';\nimport { IFilesConfiguration, SortOrder } from './files.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { ExplorerFileNestingTrie } from './explorerFileNestingTrie.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { assertReturnsDefined } from '../../../../base/common/types.js';\nimport { IFilesConfigurationService } from '../../../services/filesConfiguration/common/filesConfigurationService.js';\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\n\nexport class ExplorerModel implements IDisposable {\n\n\tprivate _roots!: ExplorerItem[];\n\tprivate _listener: IDisposable;\n\tprivate readonly _onDidChangeRoots = new Emitter<void>();\n\n\tconstructor(\n\t\tprivate readonly contextService: IWorkspaceContextService,\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t\tfileService: IFileService,\n\t\tconfigService: IConfigurationService,\n\t\tfilesConfigService: IFilesConfigurationService,\n\t) {\n\t\tconst setRoots = () => this._roots = this.contextService.getWorkspace().folders\n\t\t\t.map(folder => new ExplorerItem(folder.uri, fileService, configService, filesConfigService, undefined, true, false, false, false, folder.name));\n\t\tsetRoots();\n\n\t\tthis._listener = this.contextService.onDidChangeWorkspaceFolders(() => {\n\t\t\tsetRoots();\n\t\t\tthis._onDidChangeRoots.fire();\n\t\t});\n\t}\n\n\tget roots(): ExplorerItem[] {\n\t\treturn this._roots;\n\t}\n\n\tget onDidChangeRoots(): Event<void> {\n\t\treturn this._onDidChangeRoots.event;\n\t}\n\n\t/**\n\t * Returns an array of child stat from this stat that matches with the provided path.\n\t * Starts matching from the first root.\n\t * Will return empty array in case the FileStat does not exist.\n\t */\n\tfindAll(resource: URI): ExplorerItem[] {\n\t\treturn coalesce(this.roots.map(root => root.find(resource)));\n\t}\n\n\t/**\n\t * Returns a FileStat that matches the passed resource.\n\t * In case multiple FileStat are matching the resource (same folder opened multiple times) returns the FileStat that has the closest root.\n\t * Will return undefined in case the FileStat does not exist.\n\t */\n\tfindClosest(resource: URI): ExplorerItem | null {\n\t\tconst folder = this.contextService.getWorkspaceFolder(resource);\n\t\tif (folder) {\n\t\t\tconst root = this.roots.find(r => this.uriIdentityService.extUri.isEqual(r.resource, folder.uri));\n\t\t\tif (root) {\n\t\t\t\treturn root.find(resource);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tdispose(): void {\n\t\tdispose(this._listener);\n\t}\n}\n\nexport class ExplorerItem {\n\t_isDirectoryResolved: boolean; // used in tests\n\tpublic error: Error | undefined = undefined;\n\tprivate _isExcluded = false;\n\n\tpublic nestedParent: ExplorerItem | undefined;\n\tpublic nestedChildren: ExplorerItem[] | undefined;\n\n\tconstructor(\n\t\tpublic resource: URI,\n\t\tprivate readonly fileService: IFileService,\n\t\tprivate readonly configService: IConfigurationService,\n\t\tprivate readonly filesConfigService: IFilesConfigurationService,\n\t\tprivate _parent: ExplorerItem | undefined,\n\t\tprivate _isDirectory?: boolean,\n\t\tprivate _isSymbolicLink?: boolean,\n\t\tprivate _readonly?: boolean,\n\t\tprivate _locked?: boolean,\n\t\tprivate _name: string = basenameOrAuthority(resource),\n\t\tprivate _mtime?: number,\n\t\tprivate _unknown = false\n\t) {\n\t\tthis._isDirectoryResolved = false;\n\t}\n\n\tget isExcluded(): boolean {\n\t\tif (this._isExcluded) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!this._parent) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._parent.isExcluded;\n\t}\n\n\tset isExcluded(value: boolean) {\n\t\tthis._isExcluded = value;\n\t}\n\n\thasChildren(filter: (stat: ExplorerItem) => boolean): boolean {\n\t\tif (this.hasNests) {\n\t\t\treturn this.nestedChildren?.some(c => filter(c)) ?? false;\n\t\t} else {\n\t\t\treturn this.isDirectory;\n\t\t}\n\t}\n\n\tget hasNests() {\n\t\treturn !!(this.nestedChildren?.length);\n\t}\n\n\tget isDirectoryResolved(): boolean {\n\t\treturn this._isDirectoryResolved;\n\t}\n\n\tget isSymbolicLink(): boolean {\n\t\treturn !!this._isSymbolicLink;\n\t}\n\n\tget isDirectory(): boolean {\n\t\treturn !!this._isDirectory;\n\t}\n\n\tget isReadonly(): boolean | IMarkdownString {\n\t\treturn this.filesConfigService.isReadonly(this.resource, { resource: this.resource, name: this.name, readonly: this._readonly, locked: this._locked });\n\t}\n\n\tget mtime(): number | undefined {\n\t\treturn this._mtime;\n\t}\n\n\tget name(): string {\n\t\treturn this._name;\n\t}\n\n\tget isUnknown(): boolean {\n\t\treturn this._unknown;\n\t}\n\n\tget parent(): ExplorerItem | undefined {\n\t\treturn this._parent;\n\t}\n\n\tget root(): ExplorerItem {\n\t\tif (!this._parent) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this._parent.root;\n\t}\n\n\t@memoize get children(): Map<string, ExplorerItem> {\n\t\treturn new Map<string, ExplorerItem>();\n\t}\n\n\tprivate updateName(value: string): void {\n\t\t// Re-add to parent since the parent has a name map to children and the name might have changed\n\t\tthis._parent?.removeChild(this);\n\t\tthis._name = value;\n\t\tthis._parent?.addChild(this);\n\t}\n\n\tgetId(): string {\n\t\tlet id = this.root.resource.toString() + '::' + this.resource.toString();\n\n\t\tif (this.isMarkedAsFiltered()) {\n\t\t\tid += '::findFilterResult';\n\t\t}\n\n\t\treturn id;\n\t}\n\n\ttoString(): string {\n\t\treturn `ExplorerItem: ${this.name}`;\n\t}\n\n\tget isRoot(): boolean {\n\t\treturn this === this.root;\n\t}\n\n\tstatic create(fileService: IFileService, configService: IConfigurationService, filesConfigService: IFilesConfigurationService, raw: IFileStat, parent: ExplorerItem | undefined, resolveTo?: readonly URI[]): ExplorerItem {\n\t\tconst stat = new ExplorerItem(raw.resource, fileService, configService, filesConfigService, parent, raw.isDirectory, raw.isSymbolicLink, raw.readonly, raw.locked, raw.name, raw.mtime, !raw.isFile && !raw.isDirectory);\n\n\t\t// Recursively add children if present\n\t\tif (stat.isDirectory) {\n\n\t\t\t// isDirectoryResolved is a very important indicator in the stat model that tells if the folder was fully resolved\n\t\t\t// the folder is fully resolved if either it has a list of children or the client requested this by using the resolveTo\n\t\t\t// array of resource path to resolve.\n\t\t\tstat._isDirectoryResolved = !!raw.children || (!!resolveTo && resolveTo.some((r) => {\n\t\t\t\treturn isEqualOrParent(r, stat.resource);\n\t\t\t}));\n\n\t\t\t// Recurse into children\n\t\t\tif (raw.children) {\n\t\t\t\tfor (let i = 0, len = raw.children.length; i < len; i++) {\n\t\t\t\t\tconst child = ExplorerItem.create(fileService, configService, filesConfigService, raw.children[i], stat, resolveTo);\n\t\t\t\t\tstat.addChild(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn stat;\n\t}\n\n\t/**\n\t * Merges the stat which was resolved from the disk with the local stat by copying over properties\n\t * and children. The merge will only consider resolved stat elements to avoid overwriting data which\n\t * exists locally.\n\t */\n\tstatic mergeLocalWithDisk(disk: ExplorerItem, local: ExplorerItem): void {\n\t\tif (disk.resource.toString() !== local.resource.toString()) {\n\t\t\treturn; // Merging only supported for stats with the same resource\n\t\t}\n\n\t\t// Stop merging when a folder is not resolved to avoid loosing local data\n\t\tconst mergingDirectories = disk.isDirectory || local.isDirectory;\n\t\tif (mergingDirectories && local._isDirectoryResolved && !disk._isDirectoryResolved) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Properties\n\t\tlocal.resource = disk.resource;\n\t\tif (!local.isRoot) {\n\t\t\tlocal.updateName(disk.name);\n\t\t}\n\t\tlocal._isDirectory = disk.isDirectory;\n\t\tlocal._mtime = disk.mtime;\n\t\tlocal._isDirectoryResolved = disk._isDirectoryResolved;\n\t\tlocal._isSymbolicLink = disk.isSymbolicLink;\n\t\tlocal.error = disk.error;\n\n\t\t// Merge Children if resolved\n\t\tif (mergingDirectories && disk._isDirectoryResolved) {\n\n\t\t\t// Map resource => stat\n\t\t\tconst oldLocalChildren = new ResourceMap<ExplorerItem>();\n\t\t\tlocal.children.forEach(child => {\n\t\t\t\toldLocalChildren.set(child.resource, child);\n\t\t\t});\n\n\t\t\t// Clear current children\n\t\t\tlocal.children.clear();\n\n\t\t\t// Merge received children\n\t\t\tdisk.children.forEach(diskChild => {\n\t\t\t\tconst formerLocalChild = oldLocalChildren.get(diskChild.resource);\n\t\t\t\t// Existing child: merge\n\t\t\t\tif (formerLocalChild) {\n\t\t\t\t\tExplorerItem.mergeLocalWithDisk(diskChild, formerLocalChild);\n\t\t\t\t\tlocal.addChild(formerLocalChild);\n\t\t\t\t\toldLocalChildren.delete(diskChild.resource);\n\t\t\t\t}\n\n\t\t\t\t// New child: add\n\t\t\t\telse {\n\t\t\t\t\tlocal.addChild(diskChild);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\toldLocalChildren.forEach(oldChild => {\n\t\t\t\tif (oldChild instanceof NewExplorerItem) {\n\t\t\t\t\tlocal.addChild(oldChild);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Adds a child element to this folder.\n\t */\n\taddChild(child: ExplorerItem): void {\n\t\t// Inherit some parent properties to child\n\t\tchild._parent = this;\n\t\tchild.updateResource(false);\n\t\tthis.children.set(this.getPlatformAwareName(child.name), child);\n\t}\n\n\tgetChild(name: string): ExplorerItem | undefined {\n\t\treturn this.children.get(this.getPlatformAwareName(name));\n\t}\n\n\tfetchChildren(sortOrder: SortOrder): ExplorerItem[] | Promise<ExplorerItem[]> {\n\t\tconst nestingConfig = this.configService.getValue<IFilesConfiguration>({ resource: this.root.resource }).explorer.fileNesting;\n\n\t\t// fast path when the children can be resolved sync\n\t\tif (nestingConfig.enabled && this.nestedChildren) {\n\t\t\treturn this.nestedChildren;\n\t\t}\n\n\t\treturn (async () => {\n\t\t\tif (!this._isDirectoryResolved) {\n\t\t\t\t// Resolve metadata only when the mtime is needed since this can be expensive\n\t\t\t\t// Mtime is only used when the sort order is 'modified'\n\t\t\t\tconst resolveMetadata = sortOrder === SortOrder.Modified;\n\t\t\t\tthis.error = undefined;\n\t\t\t\ttry {\n\t\t\t\t\tconst stat = await this.fileService.resolve(this.resource, { resolveSingleChildDescendants: true, resolveMetadata });\n\t\t\t\t\tconst resolved = ExplorerItem.create(this.fileService, this.configService, this.filesConfigService, stat, this);\n\t\t\t\t\tExplorerItem.mergeLocalWithDisk(resolved, this);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.error = e;\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tthis._isDirectoryResolved = true;\n\t\t\t}\n\n\t\t\tconst items: ExplorerItem[] = [];\n\t\t\tif (nestingConfig.enabled) {\n\t\t\t\tconst fileChildren: [string, ExplorerItem][] = [];\n\t\t\t\tconst dirChildren: [string, ExplorerItem][] = [];\n\t\t\t\tfor (const child of this.children.entries()) {\n\t\t\t\t\tchild[1].nestedParent = undefined;\n\t\t\t\t\tif (child[1].isDirectory) {\n\t\t\t\t\t\tdirChildren.push(child);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileChildren.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst nested = this.fileNester.nest(\n\t\t\t\t\tfileChildren.map(([name]) => name),\n\t\t\t\t\tthis.getPlatformAwareName(this.name));\n\n\t\t\t\tfor (const [fileEntryName, fileEntryItem] of fileChildren) {\n\t\t\t\t\tconst nestedItems = nested.get(fileEntryName);\n\t\t\t\t\tif (nestedItems !== undefined) {\n\t\t\t\t\t\tfileEntryItem.nestedChildren = [];\n\t\t\t\t\t\tfor (const name of nestedItems.keys()) {\n\t\t\t\t\t\t\tconst child = assertReturnsDefined(this.children.get(name));\n\t\t\t\t\t\t\tfileEntryItem.nestedChildren.push(child);\n\t\t\t\t\t\t\tchild.nestedParent = fileEntryItem;\n\t\t\t\t\t\t}\n\t\t\t\t\t\titems.push(fileEntryItem);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileEntryItem.nestedChildren = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const [_, dirEntryItem] of dirChildren.values()) {\n\t\t\t\t\titems.push(dirEntryItem);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.children.forEach(child => {\n\t\t\t\t\titems.push(child);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn items;\n\t\t})();\n\t}\n\n\tprivate _fileNester: ExplorerFileNestingTrie | undefined;\n\tprivate get fileNester(): ExplorerFileNestingTrie {\n\t\tif (!this.root._fileNester) {\n\t\t\tconst nestingConfig = this.configService.getValue<IFilesConfiguration>({ resource: this.root.resource }).explorer.fileNesting;\n\t\t\tconst patterns = Object.entries(nestingConfig.patterns)\n\t\t\t\t.filter(entry =>\n\t\t\t\t\ttypeof (entry[0]) === 'string' && typeof (entry[1]) === 'string' && entry[0] && entry[1])\n\t\t\t\t.map(([parentPattern, childrenPatterns]) =>\n\t\t\t\t\t[\n\t\t\t\t\t\tthis.getPlatformAwareName(parentPattern.trim()),\n\t\t\t\t\t\tchildrenPatterns.split(',').map(p => this.getPlatformAwareName(p.trim().replace(/\\u200b/g, '').trim()))\n\t\t\t\t\t\t\t.filter(p => p !== '')\n\t\t\t\t\t] as [string, string[]]);\n\n\t\t\tthis.root._fileNester = new ExplorerFileNestingTrie(patterns);\n\t\t}\n\t\treturn this.root._fileNester;\n\t}\n\n\t/**\n\t * Removes a child element from this folder.\n\t */\n\tremoveChild(child: ExplorerItem): void {\n\t\tthis.nestedChildren = undefined;\n\t\tthis.children.delete(this.getPlatformAwareName(child.name));\n\t}\n\n\tforgetChildren(): void {\n\t\tthis.children.clear();\n\t\tthis.nestedChildren = undefined;\n\t\tthis._isDirectoryResolved = false;\n\t\tthis._fileNester = undefined;\n\t}\n\n\tprivate getPlatformAwareName(name: string): string {\n\t\treturn this.fileService.hasCapability(this.resource, FileSystemProviderCapabilities.PathCaseSensitive) ? name : name.toLowerCase();\n\t}\n\n\t/**\n\t * Moves this element under a new parent element.\n\t */\n\tmove(newParent: ExplorerItem): void {\n\t\tthis.nestedParent?.removeChild(this);\n\t\tthis._parent?.removeChild(this);\n\t\tnewParent.removeChild(this); // make sure to remove any previous version of the file if any\n\t\tnewParent.addChild(this);\n\t\tthis.updateResource(true);\n\t}\n\n\tprivate updateResource(recursive: boolean): void {\n\t\tif (this._parent) {\n\t\t\tthis.resource = joinPath(this._parent.resource, this.name);\n\t\t}\n\n\t\tif (recursive) {\n\t\t\tif (this.isDirectory) {\n\t\t\t\tthis.children.forEach(child => {\n\t\t\t\t\tchild.updateResource(true);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tells this stat that it was renamed. This requires changes to all children of this stat (if any)\n\t * so that the path property can be updated properly.\n\t */\n\trename(renamedStat: { name: string; mtime?: number }): void {\n\n\t\t// Merge a subset of Properties that can change on rename\n\t\tthis.updateName(renamedStat.name);\n\t\tthis._mtime = renamedStat.mtime;\n\n\t\t// Update Paths including children\n\t\tthis.updateResource(true);\n\t}\n\n\t/**\n\t * Returns a child stat from this stat that matches with the provided path.\n\t * Will return \"null\" in case the child does not exist.\n\t */\n\tfind(resource: URI): ExplorerItem | null {\n\t\t// Return if path found\n\t\t// For performance reasons try to do the comparison as fast as possible\n\t\tconst ignoreCase = !this.fileService.hasCapability(resource, FileSystemProviderCapabilities.PathCaseSensitive);\n\t\tif (resource && this.resource.scheme === resource.scheme && equalsIgnoreCase(this.resource.authority, resource.authority) &&\n\t\t\t(ignoreCase ? startsWithIgnoreCase(resource.path, this.resource.path) : resource.path.startsWith(this.resource.path))) {\n\t\t\treturn this.findByPath(rtrim(resource.path, posix.sep), this.resource.path.length, ignoreCase);\n\t\t}\n\n\t\treturn null; //Unable to find\n\t}\n\n\tprivate findByPath(path: string, index: number, ignoreCase: boolean): ExplorerItem | null {\n\t\tif (isEqual(rtrim(this.resource.path, posix.sep), path, ignoreCase)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.isDirectory) {\n\t\t\t// Ignore separtor to more easily deduct the next name to search\n\t\t\twhile (index < path.length && path[index] === posix.sep) {\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tlet indexOfNextSep = path.indexOf(posix.sep, index);\n\t\t\tif (indexOfNextSep === -1) {\n\t\t\t\t// If there is no separator take the remainder of the path\n\t\t\t\tindexOfNextSep = path.length;\n\t\t\t}\n\t\t\t// The name to search is between two separators\n\t\t\tconst name = path.substring(index, indexOfNextSep);\n\n\t\t\tconst child = this.children.get(this.getPlatformAwareName(name));\n\n\t\t\tif (child) {\n\t\t\t\t// We found a child with the given name, search inside it\n\t\t\t\treturn child.findByPath(path, indexOfNextSep, ignoreCase);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// Find\n\tprivate markedAsFindResult = false;\n\tisMarkedAsFiltered(): boolean {\n\t\treturn this.markedAsFindResult;\n\t}\n\n\tmarkItemAndParentsAsFiltered(): void {\n\t\tthis.markedAsFindResult = true;\n\t\tthis.parent?.markItemAndParentsAsFiltered();\n\t}\n\n\tunmarkItemAndChildren(): void {\n\t\tthis.markedAsFindResult = false;\n\t\tthis.children.forEach(child => child.unmarkItemAndChildren());\n\t}\n}\n\nexport class NewExplorerItem extends ExplorerItem {\n\tconstructor(fileService: IFileService, configService: IConfigurationService, filesConfigService: IFilesConfigurationService, parent: ExplorerItem, isDirectory: boolean) {\n\t\tsuper(URI.file(''), fileService, configService, filesConfigService, parent, isDirectory);\n\t\tthis._isDirectoryResolved = true;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { isEqual } from '../../../../base/common/extpath.js';\nimport { posix } from '../../../../base/common/path.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IFileStat, IFileService, FileSystemProviderCapabilities } from '../../../../platform/files/common/files.js';\nimport { rtrim, startsWithIgnoreCase, equalsIgnoreCase } from '../../../../base/common/strings.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { IDisposable, dispose } from '../../../../base/common/lifecycle.js';\nimport { memoize } from '../../../../base/common/decorators.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { joinPath, isEqualOrParent, basenameOrAuthority } from '../../../../base/common/resources.js';\nimport { IFilesConfiguration, SortOrder } from './files.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { ExplorerFileNestingTrie } from './explorerFileNestingTrie.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { assertReturnsDefined } from '../../../../base/common/types.js';\nimport { IFilesConfigurationService } from '../../../services/filesConfiguration/common/filesConfigurationService.js';\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\n\nexport class ExplorerModel implements IDisposable {\n\n\tprivate _roots!: ExplorerItem[];\n\tprivate _listener: IDisposable;\n\tprivate readonly _onDidChangeRoots = new Emitter<void>();\n\n\tconstructor(\n\t\tprivate readonly contextService: IWorkspaceContextService,\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t\tfileService: IFileService,\n\t\tconfigService: IConfigurationService,\n\t\tfilesConfigService: IFilesConfigurationService,\n\t) {\n\t\tconst setRoots = () => this._roots = this.contextService.getWorkspace().folders\n\t\t\t.map(folder => new ExplorerItem(folder.uri, fileService, configService, filesConfigService, undefined, true, false, false, false, folder.name));\n\t\tsetRoots();\n\n\t\tthis._listener = this.contextService.onDidChangeWorkspaceFolders(() => {\n\t\t\tsetRoots();\n\t\t\tthis._onDidChangeRoots.fire();\n\t\t});\n\t}\n\n\tget roots(): ExplorerItem[] {\n\t\treturn this._roots;\n\t}\n\n\tget onDidChangeRoots(): Event<void> {\n\t\treturn this._onDidChangeRoots.event;\n\t}\n\n\t/**\n\t * Returns an array of child stat from this stat that matches with the provided path.\n\t * Starts matching from the first root.\n\t * Will return empty array in case the FileStat does not exist.\n\t */\n\tfindAll(resource: URI): ExplorerItem[] {\n\t\treturn coalesce(this.roots.map(root => root.find(resource)));\n\t}\n\n\t/**\n\t * Returns a FileStat that matches the passed resource.\n\t * In case multiple FileStat are matching the resource (same folder opened multiple times) returns the FileStat that has the closest root.\n\t * Will return undefined in case the FileStat does not exist.\n\t */\n\tfindClosest(resource: URI): ExplorerItem | null {\n\t\tconst folder = this.contextService.getWorkspaceFolder(resource);\n\t\tif (folder) {\n\t\t\tconst root = this.roots.find(r => this.uriIdentityService.extUri.isEqual(r.resource, folder.uri));\n\t\t\tif (root) {\n\t\t\t\treturn root.find(resource);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tdispose(): void {\n\t\tdispose(this._listener);\n\t}\n}\n\nexport class ExplorerItem {\n\t_isDirectoryResolved: boolean; // used in tests\n\tpublic error: Error | undefined = undefined;\n\tprivate _isExcluded = false;\n\n\tpublic nestedParent: ExplorerItem | undefined;\n\tpublic nestedChildren: ExplorerItem[] | undefined;\n\n\tconstructor(\n\t\tpublic resource: URI,\n\t\tprivate readonly fileService: IFileService,\n\t\tprivate readonly configService: IConfigurationService,\n\t\tprivate readonly filesConfigService: IFilesConfigurationService,\n\t\tprivate _parent: ExplorerItem | undefined,\n\t\tprivate _isDirectory?: boolean,\n\t\tprivate _isSymbolicLink?: boolean,\n\t\tprivate _readonly?: boolean,\n\t\tprivate _locked?: boolean,\n\t\tprivate _name: string = basenameOrAuthority(resource),\n\t\tprivate _mtime?: number,\n\t\tprivate _unknown = false\n\t) {\n\t\tthis._isDirectoryResolved = false;\n\t}\n\n\tget isExcluded(): boolean {\n\t\tif (this._isExcluded) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!this._parent) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._parent.isExcluded;\n\t}\n\n\tset isExcluded(value: boolean) {\n\t\tthis._isExcluded = value;\n\t}\n\n\thasChildren(filter: (stat: ExplorerItem) => boolean): boolean {\n\t\tif (this.hasNests) {\n\t\t\treturn this.nestedChildren?.some(c => filter(c)) ?? false;\n\t\t} else {\n\t\t\treturn this.isDirectory;\n\t\t}\n\t}\n\n\tget hasNests() {\n\t\treturn !!(this.nestedChildren?.length);\n\t}\n\n\tget isDirectoryResolved(): boolean {\n\t\treturn this._isDirectoryResolved;\n\t}\n\n\tget isSymbolicLink(): boolean {\n\t\treturn !!this._isSymbolicLink;\n\t}\n\n\tget isDirectory(): boolean {\n\t\treturn !!this._isDirectory;\n\t}\n\n\tget isReadonly(): boolean | IMarkdownString {\n\t\treturn this.filesConfigService.isReadonly(this.resource, { resource: this.resource, name: this.name, readonly: this._readonly, locked: this._locked });\n\t}\n\n\tget mtime(): number | undefined {\n\t\treturn this._mtime;\n\t}\n\n\tget name(): string {\n\t\treturn this._name;\n\t}\n\n\tget isUnknown(): boolean {\n\t\treturn this._unknown;\n\t}\n\n\tget parent(): ExplorerItem | undefined {\n\t\treturn this._parent;\n\t}\n\n\tget root(): ExplorerItem {\n\t\tif (!this._parent) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this._parent.root;\n\t}\n\n\t@memoize get children(): Map<string, ExplorerItem> {\n\t\treturn new Map<string, ExplorerItem>();\n\t}\n\n\tprivate updateName(value: string): void {\n\t\t// Re-add to parent since the parent has a name map to children and the name might have changed\n\t\tthis._parent?.removeChild(this);\n\t\tthis._name = value;\n\t\tthis._parent?.addChild(this);\n\t}\n\n\tgetId(): string {\n\t\tlet id = this.root.resource.toString() + '::' + this.resource.toString();\n\n\t\tif (this.isMarkedAsFiltered()) {\n\t\t\tid += '::findFilterResult';\n\t\t}\n\n\t\treturn id;\n\t}\n\n\ttoString(): string {\n\t\treturn `ExplorerItem: ${this.name}`;\n\t}\n\n\tget isRoot(): boolean {\n\t\treturn this === this.root;\n\t}\n\n\tstatic create(fileService: IFileService, configService: IConfigurationService, filesConfigService: IFilesConfigurationService, raw: IFileStat, parent: ExplorerItem | undefined, resolveTo?: readonly URI[]): ExplorerItem {\n\t\tconst stat = new ExplorerItem(raw.resource, fileService, configService, filesConfigService, parent, raw.isDirectory, raw.isSymbolicLink, raw.readonly, raw.locked, raw.name, raw.mtime, !raw.isFile && !raw.isDirectory);\n\n\t\t// Recursively add children if present\n\t\tif (stat.isDirectory) {\n\n\t\t\t// isDirectoryResolved is a very important indicator in the stat model that tells if the folder was fully resolved\n\t\t\t// the folder is fully resolved if either it has a list of children or the client requested this by using the resolveTo\n\t\t\t// array of resource path to resolve.\n\t\t\tstat._isDirectoryResolved = !!raw.children || (!!resolveTo && resolveTo.some((r) => {\n\t\t\t\treturn isEqualOrParent(r, stat.resource);\n\t\t\t}));\n\n\t\t\t// Recurse into children\n\t\t\tif (raw.children) {\n\t\t\t\tfor (let i = 0, len = raw.children.length; i < len; i++) {\n\t\t\t\t\tconst child = ExplorerItem.create(fileService, configService, filesConfigService, raw.children[i], stat, resolveTo);\n\t\t\t\t\tstat.addChild(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn stat;\n\t}\n\n\t/**\n\t * Merges the stat which was resolved from the disk with the local stat by copying over properties\n\t * and children. The merge will only consider resolved stat elements to avoid overwriting data which\n\t * exists locally.\n\t */\n\tstatic mergeLocalWithDisk(disk: ExplorerItem, local: ExplorerItem): void {\n\t\tif (disk.resource.toString() !== local.resource.toString()) {\n\t\t\treturn; // Merging only supported for stats with the same resource\n\t\t}\n\n\t\t// Stop merging when a folder is not resolved to avoid loosing local data\n\t\tconst mergingDirectories = disk.isDirectory || local.isDirectory;\n\t\tif (mergingDirectories && local._isDirectoryResolved && !disk._isDirectoryResolved) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Properties\n\t\tlocal.resource = disk.resource;\n\t\tif (!local.isRoot) {\n\t\t\tlocal.updateName(disk.name);\n\t\t}\n\t\tlocal._isDirectory = disk.isDirectory;\n\t\tlocal._mtime = disk.mtime;\n\t\tlocal._isDirectoryResolved = disk._isDirectoryResolved;\n\t\tlocal._isSymbolicLink = disk.isSymbolicLink;\n\t\tlocal.error = disk.error;\n\n\t\t// Merge Children if resolved\n\t\tif (mergingDirectories && disk._isDirectoryResolved) {\n\n\t\t\t// Map resource => stat\n\t\t\tconst oldLocalChildren = new ResourceMap<ExplorerItem>();\n\t\t\tlocal.children.forEach(child => {\n\t\t\t\toldLocalChildren.set(child.resource, child);\n\t\t\t});\n\n\t\t\t// Clear current children\n\t\t\tlocal.children.clear();\n\n\t\t\t// Merge received children\n\t\t\tdisk.children.forEach(diskChild => {\n\t\t\t\tconst formerLocalChild = oldLocalChildren.get(diskChild.resource);\n\t\t\t\t// Existing child: merge\n\t\t\t\tif (formerLocalChild) {\n\t\t\t\t\tExplorerItem.mergeLocalWithDisk(diskChild, formerLocalChild);\n\t\t\t\t\tlocal.addChild(formerLocalChild);\n\t\t\t\t\toldLocalChildren.delete(diskChild.resource);\n\t\t\t\t}\n\n\t\t\t\t// New child: add\n\t\t\t\telse {\n\t\t\t\t\tlocal.addChild(diskChild);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\toldLocalChildren.forEach(oldChild => {\n\t\t\t\tif (oldChild instanceof NewExplorerItem) {\n\t\t\t\t\tlocal.addChild(oldChild);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Adds a child element to this folder.\n\t */\n\taddChild(child: ExplorerItem): void {\n\t\t// Inherit some parent properties to child\n\t\tchild._parent = this;\n\t\tchild.updateResource(false);\n\t\tthis.children.set(this.getPlatformAwareName(child.name), child);\n\t}\n\n\tgetChild(name: string): ExplorerItem | undefined {\n\t\treturn this.children.get(this.getPlatformAwareName(name));\n\t}\n\n\tfetchChildren(sortOrder: SortOrder): ExplorerItem[] | Promise<ExplorerItem[]> {\n\t\tconst nestingConfig = this.configService.getValue<IFilesConfiguration>({ resource: this.root.resource }).explorer.fileNesting;\n\n\t\t// fast path when the children can be resolved sync\n\t\tif (nestingConfig.enabled && this.nestedChildren) {\n\t\t\treturn this.nestedChildren;\n\t\t}\n\n\t\treturn (async () => {\n\t\t\tif (!this._isDirectoryResolved) {\n\t\t\t\t// Resolve metadata only when the mtime is needed since this can be expensive\n\t\t\t\t// Mtime is only used when the sort order is 'modified'\n\t\t\t\tconst resolveMetadata = sortOrder === SortOrder.Modified;\n\t\t\t\tthis.error = undefined;\n\t\t\t\ttry {\n\t\t\t\t\tconst stat = await this.fileService.resolve(this.resource, { resolveSingleChildDescendants: true, resolveMetadata });\n\t\t\t\t\tconst resolved = ExplorerItem.create(this.fileService, this.configService, this.filesConfigService, stat, this);\n\t\t\t\t\tExplorerItem.mergeLocalWithDisk(resolved, this);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.error = e;\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tthis._isDirectoryResolved = true;\n\t\t\t}\n\n\t\t\tconst items: ExplorerItem[] = [];\n\t\t\tif (nestingConfig.enabled) {\n\t\t\t\tconst fileChildren: [string, ExplorerItem][] = [];\n\t\t\t\tconst dirChildren: [string, ExplorerItem][] = [];\n\t\t\t\tfor (const child of this.children.entries()) {\n\t\t\t\t\tchild[1].nestedParent = undefined;\n\t\t\t\t\tif (child[1].isDirectory) {\n\t\t\t\t\t\tdirChildren.push(child);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileChildren.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst nested = this.fileNester.nest(\n\t\t\t\t\tfileChildren.map(([name]) => name),\n\t\t\t\t\tthis.getPlatformAwareName(this.name));\n\n\t\t\t\tfor (const [fileEntryName, fileEntryItem] of fileChildren) {\n\t\t\t\t\tconst nestedItems = nested.get(fileEntryName);\n\t\t\t\t\tif (nestedItems !== undefined) {\n\t\t\t\t\t\tfileEntryItem.nestedChildren = [];\n\t\t\t\t\t\tfor (const name of nestedItems.keys()) {\n\t\t\t\t\t\t\tconst child = assertReturnsDefined(this.children.get(name));\n\t\t\t\t\t\t\tfileEntryItem.nestedChildren.push(child);\n\t\t\t\t\t\t\tchild.nestedParent = fileEntryItem;\n\t\t\t\t\t\t}\n\t\t\t\t\t\titems.push(fileEntryItem);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfileEntryItem.nestedChildren = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const [_, dirEntryItem] of dirChildren.values()) {\n\t\t\t\t\titems.push(dirEntryItem);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.children.forEach(child => {\n\t\t\t\t\titems.push(child);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn items;\n\t\t})();\n\t}\n\n\tprivate _fileNester: ExplorerFileNestingTrie | undefined;\n\tprivate get fileNester(): ExplorerFileNestingTrie {\n\t\tif (!this.root._fileNester) {\n\t\t\tconst nestingConfig = this.configService.getValue<IFilesConfiguration>({ resource: this.root.resource }).explorer.fileNesting;\n\t\t\tconst patterns = Object.entries(nestingConfig.patterns)\n\t\t\t\t.filter(entry =>\n\t\t\t\t\ttypeof (entry[0]) === 'string' && typeof (entry[1]) === 'string' && entry[0] && entry[1])\n\t\t\t\t.map(([parentPattern, childrenPatterns]) =>\n\t\t\t\t\t[\n\t\t\t\t\t\tthis.getPlatformAwareName(parentPattern.trim()),\n\t\t\t\t\t\tchildrenPatterns.split(',').map(p => this.getPlatformAwareName(p.trim().replace(/\\u200b/g, '').trim()))\n\t\t\t\t\t\t\t.filter(p => p !== '')\n\t\t\t\t\t] as [string, string[]]);\n\n\t\t\tthis.root._fileNester = new ExplorerFileNestingTrie(patterns);\n\t\t}\n\t\treturn this.root._fileNester;\n\t}\n\n\t/**\n\t * Removes a child element from this folder.\n\t */\n\tremoveChild(child: ExplorerItem): void {\n\t\tthis.nestedChildren = undefined;\n\t\tthis.children.delete(this.getPlatformAwareName(child.name));\n\t}\n\n\tforgetChildren(): void {\n\t\tthis.children.clear();\n\t\tthis.nestedChildren = undefined;\n\t\tthis._isDirectoryResolved = false;\n\t\tthis._fileNester = undefined;\n\t}\n\n\tprivate getPlatformAwareName(name: string): string {\n\t\treturn this.fileService.hasCapability(this.resource, FileSystemProviderCapabilities.PathCaseSensitive) ? name : name.toLowerCase();\n\t}\n\n\t/**\n\t * Moves this element under a new parent element.\n\t */\n\tmove(newParent: ExplorerItem): void {\n\t\tthis.nestedParent?.removeChild(this);\n\t\tthis._parent?.removeChild(this);\n\t\tnewParent.removeChild(this); // make sure to remove any previous version of the file if any\n\t\tnewParent.addChild(this);\n\t\tthis.updateResource(true);\n\t}\n\n\tprivate updateResource(recursive: boolean): void {\n\t\tif (this._parent) {\n\t\t\tthis.resource = joinPath(this._parent.resource, this.name);\n\t\t}\n\n\t\tif (recursive) {\n\t\t\tif (this.isDirectory) {\n\t\t\t\tthis.children.forEach(child => {\n\t\t\t\t\tchild.updateResource(true);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tells this stat that it was renamed. This requires changes to all children of this stat (if any)\n\t * so that the path property can be updated properly.\n\t */\n\trename(renamedStat: { name: string; mtime?: number }): void {\n\n\t\t// Merge a subset of Properties that can change on rename\n\t\tthis.updateName(renamedStat.name);\n\t\tthis._mtime = renamedStat.mtime;\n\n\t\t// Update Paths including children\n\t\tthis.updateResource(true);\n\t}\n\n\t/**\n\t * Returns a child stat from this stat that matches with the provided path.\n\t * Will return \"null\" in case the child does not exist.\n\t */\n\tfind(resource: URI): ExplorerItem | null {\n\t\t// Return if path found\n\t\t// For performance reasons try to do the comparison as fast as possible\n\t\tconst ignoreCase = !this.fileService.hasCapability(resource, FileSystemProviderCapabilities.PathCaseSensitive);\n\t\tif (resource && this.resource.scheme === resource.scheme && equalsIgnoreCase(this.resource.authority, resource.authority) &&\n\t\t\t(ignoreCase ? startsWithIgnoreCase(resource.path, this.resource.path) : resource.path.startsWith(this.resource.path))) {\n\t\t\treturn this.findByPath(rtrim(resource.path, posix.sep), this.resource.path.length, ignoreCase);\n\t\t}\n\n\t\treturn null; //Unable to find\n\t}\n\n\tprivate findByPath(path: string, index: number, ignoreCase: boolean): ExplorerItem | null {\n\t\tif (isEqual(rtrim(this.resource.path, posix.sep), path, ignoreCase)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.isDirectory) {\n\t\t\t// Ignore separtor to more easily deduct the next name to search\n\t\t\twhile (index < path.length && path[index] === posix.sep) {\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tlet indexOfNextSep = path.indexOf(posix.sep, index);\n\t\t\tif (indexOfNextSep === -1) {\n\t\t\t\t// If there is no separator take the remainder of the path\n\t\t\t\tindexOfNextSep = path.length;\n\t\t\t}\n\t\t\t// The name to search is between two separators\n\t\t\tconst name = path.substring(index, indexOfNextSep);\n\n\t\t\tconst child = this.children.get(this.getPlatformAwareName(name));\n\n\t\t\tif (child) {\n\t\t\t\t// We found a child with the given name, search inside it\n\t\t\t\treturn child.findByPath(path, indexOfNextSep, ignoreCase);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// Find\n\tprivate markedAsFindResult = false;\n\tisMarkedAsFiltered(): boolean {\n\t\treturn this.markedAsFindResult;\n\t}\n\n\tmarkItemAndParentsAsFiltered(): void {\n\t\tthis.markedAsFindResult = true;\n\t\tthis.parent?.markItemAndParentsAsFiltered();\n\t}\n\n\tunmarkItemAndChildren(): void {\n\t\tthis.markedAsFindResult = false;\n\t\tthis.children.forEach(child => child.unmarkItemAndChildren());\n\t}\n}\n\nexport class NewExplorerItem extends ExplorerItem {\n\tconstructor(fileService: IFileService, configService: IConfigurationService, filesConfigService: IFilesConfigurationService, parent: ExplorerItem, isDirectory: boolean) {\n\t\tsuper(URI.file(''), fileService, configService, filesConfigService, parent, isDirectory);\n\t\tthis._isDirectoryResolved = true;\n\t}\n}\n"]}