{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/markdown/common/markedKatexExtension.ts","vs/workbench/contrib/markdown/common/markedKatexExtension.ts"],"names":[],"mappings":"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","file":"markedKatexExtension.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport type * as marked from '../../../../base/common/marked/marked.js';\nimport { htmlAttributeEncodeValue } from '../../../../base/common/strings.js';\n\nexport const mathInlineRegExp = /(?<![a-zA-Z0-9])(?<dollars>\\${1,2})(?!\\.)(?!\\()(?![\"'#])((?:\\\\.|[^\\\\\\n])*?(?:\\\\.|[^\\\\\\n\\$]))\\k<dollars>(?![a-zA-Z0-9])/; // Non-standard, but ensure opening $ is not preceded and closing $ is not followed by word/number characters, opening $ not followed by ., (, \", ', or #\nexport const katexContainerClassName = 'vscode-katex-container';\nexport const katexContainerLatexAttributeName = 'data-latex';\n\nconst inlineRule = new RegExp('^' + mathInlineRegExp.source);\n\nexport namespace MarkedKatexExtension {\n\ttype KatexOptions = import('katex').KatexOptions;\n\n\t// From https://github.com/UziTech/marked-katex-extension/blob/main/src/index.js\n\t// From https://github.com/UziTech/marked-katex-extension/blob/main/src/index.js\n\texport interface MarkedKatexOptions extends KatexOptions { }\n\n\tconst blockRule = /^(\\${1,2})\\n((?:\\\\[^]|[^\\\\])+?)\\n\\1(?:\\n|$)/;\n\n\texport function extension(katex: typeof import('katex').default, options: MarkedKatexOptions = {}): marked.MarkedExtension {\n\t\treturn {\n\t\t\textensions: [\n\t\t\t\tinlineKatex(options, createRenderer(katex, options, false)),\n\t\t\t\tblockKatex(options, createRenderer(katex, options, true)),\n\t\t\t],\n\t\t};\n\t}\n\n\tfunction createRenderer(katex: typeof import('katex').default, options: MarkedKatexOptions, isBlock: boolean): marked.RendererExtensionFunction {\n\t\treturn (token: marked.Tokens.Generic) => {\n\t\t\tlet out: string;\n\t\t\ttry {\n\t\t\t\tconst html = katex.renderToString(token.text, {\n\t\t\t\t\t...options,\n\t\t\t\t\tthrowOnError: true,\n\t\t\t\t\tdisplayMode: token.displayMode,\n\t\t\t\t});\n\n\t\t\t\t// Wrap in a container with attribute as a fallback for extracting the original LaTeX source\n\t\t\t\t// This ensures we can always retrieve the source even if the annotation element is not present\n\t\t\t\tout = `<span class=\"${katexContainerClassName}\" ${katexContainerLatexAttributeName}=\"${htmlAttributeEncodeValue(token.text)}\">${html}</span>`;\n\t\t\t} catch {\n\t\t\t\t// On failure, just use the original text including the wrapping $ or $$\n\t\t\t\tout = token.raw;\n\t\t\t}\n\t\t\treturn out + (isBlock ? '\\n' : '');\n\t\t};\n\t}\n\n\tfunction inlineKatex(options: MarkedKatexOptions, renderer: marked.RendererExtensionFunction): marked.TokenizerAndRendererExtension {\n\t\tconst ruleReg = inlineRule;\n\t\treturn {\n\t\t\tname: 'inlineKatex',\n\t\t\tlevel: 'inline',\n\t\t\tstart(src: string) {\n\t\t\t\tlet index;\n\t\t\t\tlet indexSrc = src;\n\n\t\t\t\twhile (indexSrc) {\n\t\t\t\t\tindex = indexSrc.indexOf('$');\n\t\t\t\t\tif (index === -1) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst possibleKatex = indexSrc.substring(index);\n\t\t\t\t\tif (possibleKatex.match(ruleReg)) {\n\t\t\t\t\t\treturn index;\n\t\t\t\t\t}\n\n\t\t\t\t\tindexSrc = indexSrc.substring(index + 1).replace(/^\\$+/, '');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t},\n\t\t\ttokenizer(src: string, tokens: marked.Token[]) {\n\t\t\t\tconst match = src.match(ruleReg);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'inlineKatex',\n\t\t\t\t\t\traw: match[0],\n\t\t\t\t\t\ttext: match[2].trim(),\n\t\t\t\t\t\tdisplayMode: match[1].length === 2,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t},\n\t\t\trenderer,\n\t\t};\n\t}\n\n\tfunction blockKatex(options: MarkedKatexOptions, renderer: marked.RendererExtensionFunction): marked.TokenizerAndRendererExtension {\n\t\treturn {\n\t\t\tname: 'blockKatex',\n\t\t\tlevel: 'block',\n\t\t\tstart(src: string) {\n\t\t\t\treturn src.match(new RegExp(blockRule.source, 'm'))?.index;\n\t\t\t},\n\t\t\ttokenizer(src: string, tokens: marked.Token[]) {\n\t\t\t\tconst match = src.match(blockRule);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'blockKatex',\n\t\t\t\t\t\traw: match[0],\n\t\t\t\t\t\ttext: match[2].trim(),\n\t\t\t\t\t\tdisplayMode: match[1].length === 2,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t},\n\t\t\trenderer,\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport type * as marked from '../../../../base/common/marked/marked.js';\nimport { htmlAttributeEncodeValue } from '../../../../base/common/strings.js';\n\nexport const mathInlineRegExp = /(?<![a-zA-Z0-9])(?<dollars>\\${1,2})(?!\\.)(?!\\()(?![\"'#])((?:\\\\.|[^\\\\\\n])*?(?:\\\\.|[^\\\\\\n\\$]))\\k<dollars>(?![a-zA-Z0-9])/; // Non-standard, but ensure opening $ is not preceded and closing $ is not followed by word/number characters, opening $ not followed by ., (, \", ', or #\nexport const katexContainerClassName = 'vscode-katex-container';\nexport const katexContainerLatexAttributeName = 'data-latex';\n\nconst inlineRule = new RegExp('^' + mathInlineRegExp.source);\n\nexport namespace MarkedKatexExtension {\n\ttype KatexOptions = import('katex').KatexOptions;\n\n\t// From https://github.com/UziTech/marked-katex-extension/blob/main/src/index.js\n\t// From https://github.com/UziTech/marked-katex-extension/blob/main/src/index.js\n\texport interface MarkedKatexOptions extends KatexOptions { }\n\n\tconst blockRule = /^(\\${1,2})\\n((?:\\\\[^]|[^\\\\])+?)\\n\\1(?:\\n|$)/;\n\n\texport function extension(katex: typeof import('katex').default, options: MarkedKatexOptions = {}): marked.MarkedExtension {\n\t\treturn {\n\t\t\textensions: [\n\t\t\t\tinlineKatex(options, createRenderer(katex, options, false)),\n\t\t\t\tblockKatex(options, createRenderer(katex, options, true)),\n\t\t\t],\n\t\t};\n\t}\n\n\tfunction createRenderer(katex: typeof import('katex').default, options: MarkedKatexOptions, isBlock: boolean): marked.RendererExtensionFunction {\n\t\treturn (token: marked.Tokens.Generic) => {\n\t\t\tlet out: string;\n\t\t\ttry {\n\t\t\t\tconst html = katex.renderToString(token.text, {\n\t\t\t\t\t...options,\n\t\t\t\t\tthrowOnError: true,\n\t\t\t\t\tdisplayMode: token.displayMode,\n\t\t\t\t});\n\n\t\t\t\t// Wrap in a container with attribute as a fallback for extracting the original LaTeX source\n\t\t\t\t// This ensures we can always retrieve the source even if the annotation element is not present\n\t\t\t\tout = `<span class=\"${katexContainerClassName}\" ${katexContainerLatexAttributeName}=\"${htmlAttributeEncodeValue(token.text)}\">${html}</span>`;\n\t\t\t} catch {\n\t\t\t\t// On failure, just use the original text including the wrapping $ or $$\n\t\t\t\tout = token.raw;\n\t\t\t}\n\t\t\treturn out + (isBlock ? '\\n' : '');\n\t\t};\n\t}\n\n\tfunction inlineKatex(options: MarkedKatexOptions, renderer: marked.RendererExtensionFunction): marked.TokenizerAndRendererExtension {\n\t\tconst ruleReg = inlineRule;\n\t\treturn {\n\t\t\tname: 'inlineKatex',\n\t\t\tlevel: 'inline',\n\t\t\tstart(src: string) {\n\t\t\t\tlet index;\n\t\t\t\tlet indexSrc = src;\n\n\t\t\t\twhile (indexSrc) {\n\t\t\t\t\tindex = indexSrc.indexOf('$');\n\t\t\t\t\tif (index === -1) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst possibleKatex = indexSrc.substring(index);\n\t\t\t\t\tif (possibleKatex.match(ruleReg)) {\n\t\t\t\t\t\treturn index;\n\t\t\t\t\t}\n\n\t\t\t\t\tindexSrc = indexSrc.substring(index + 1).replace(/^\\$+/, '');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t},\n\t\t\ttokenizer(src: string, tokens: marked.Token[]) {\n\t\t\t\tconst match = src.match(ruleReg);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'inlineKatex',\n\t\t\t\t\t\traw: match[0],\n\t\t\t\t\t\ttext: match[2].trim(),\n\t\t\t\t\t\tdisplayMode: match[1].length === 2,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t},\n\t\t\trenderer,\n\t\t};\n\t}\n\n\tfunction blockKatex(options: MarkedKatexOptions, renderer: marked.RendererExtensionFunction): marked.TokenizerAndRendererExtension {\n\t\treturn {\n\t\t\tname: 'blockKatex',\n\t\t\tlevel: 'block',\n\t\t\tstart(src: string) {\n\t\t\t\treturn src.match(new RegExp(blockRule.source, 'm'))?.index;\n\t\t\t},\n\t\t\ttokenizer(src: string, tokens: marked.Token[]) {\n\t\t\t\tconst match = src.match(blockRule);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'blockKatex',\n\t\t\t\t\t\traw: match[0],\n\t\t\t\t\t\ttext: match[2].trim(),\n\t\t\t\t\t\tdisplayMode: match[1].length === 2,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t},\n\t\t\trenderer,\n\t\t};\n\t}\n}\n"]}