{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mergeEditor/browser/view/lineAlignment.ts","vs/workbench/contrib/mergeEditor/browser/view/lineAlignment.ts"],"names":[],"mappings":"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","file":"lineAlignment.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy } from '../../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../../base/common/assert.js';\nimport { isDefined } from '../../../../../base/common/types.js';\nimport { Position } from '../../../../../editor/common/core/position.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { TextLength } from '../../../../../editor/common/core/text/textLength.js';\nimport { RangeMapping } from '../model/mapping.js';\nimport { ModifiedBaseRange } from '../model/modifiedBaseRange.js';\nimport { addLength, lengthBetweenPositions, lengthOfRange } from '../model/rangeUtils.js';\n\nexport type LineAlignment = [input1LineNumber: number | undefined, baseLineNumber: number, input2LineNumber: number | undefined];\n\nexport function getAlignments(m: ModifiedBaseRange): LineAlignment[] {\n\tconst equalRanges1 = toEqualRangeMappings(m.input1Diffs.flatMap(d => d.rangeMappings), m.baseRange.toExclusiveRange(), m.input1Range.toExclusiveRange());\n\tconst equalRanges2 = toEqualRangeMappings(m.input2Diffs.flatMap(d => d.rangeMappings), m.baseRange.toExclusiveRange(), m.input2Range.toExclusiveRange());\n\n\tconst commonRanges = splitUpCommonEqualRangeMappings(equalRanges1, equalRanges2);\n\n\tlet result: LineAlignment[] = [];\n\tresult.push([m.input1Range.startLineNumber - 1, m.baseRange.startLineNumber - 1, m.input2Range.startLineNumber - 1]);\n\n\tfunction isFullSync(lineAlignment: LineAlignment) {\n\t\treturn lineAlignment.every((i) => i !== undefined);\n\t}\n\n\t// One base line has either up to one full sync or up to two half syncs.\n\tfor (const m of commonRanges) {\n\t\tconst lineAlignment: LineAlignment = [m.output1Pos?.lineNumber, m.inputPos.lineNumber, m.output2Pos?.lineNumber];\n\t\tconst alignmentIsFullSync = isFullSync(lineAlignment);\n\n\t\tlet shouldAdd = true;\n\t\tif (alignmentIsFullSync) {\n\t\t\tconst isNewFullSyncAlignment = !result.some(r => isFullSync(r) && r.some((v, idx) => v !== undefined && v === lineAlignment[idx]));\n\t\t\tif (isNewFullSyncAlignment) {\n\t\t\t\t// Remove half syncs\n\t\t\t\tresult = result.filter(r => !r.some((v, idx) => v !== undefined && v === lineAlignment[idx]));\n\t\t\t}\n\t\t\tshouldAdd = isNewFullSyncAlignment;\n\t\t} else {\n\t\t\tconst isNew = !result.some(r => r.some((v, idx) => v !== undefined && v === lineAlignment[idx]));\n\t\t\tshouldAdd = isNew;\n\t\t}\n\n\t\tif (shouldAdd) {\n\t\t\tresult.push(lineAlignment);\n\t\t} else {\n\t\t\tif (m.length.isGreaterThan(new TextLength(1, 0))) {\n\t\t\t\tresult.push([\n\t\t\t\t\tm.output1Pos ? m.output1Pos.lineNumber + 1 : undefined,\n\t\t\t\t\tm.inputPos.lineNumber + 1,\n\t\t\t\t\tm.output2Pos ? m.output2Pos.lineNumber + 1 : undefined\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst finalLineAlignment: LineAlignment = [m.input1Range.endLineNumberExclusive, m.baseRange.endLineNumberExclusive, m.input2Range.endLineNumberExclusive];\n\tresult = result.filter(r => r.every((v, idx) => v !== finalLineAlignment[idx]));\n\tresult.push(finalLineAlignment);\n\n\tassertFn(() => checkAdjacentItems(result.map(r => r[0]).filter(isDefined), (a, b) => a < b)\n\t\t&& checkAdjacentItems(result.map(r => r[1]).filter(isDefined), (a, b) => a <= b)\n\t\t&& checkAdjacentItems(result.map(r => r[2]).filter(isDefined), (a, b) => a < b)\n\t\t&& result.every(alignment => alignment.filter(isDefined).length >= 2)\n\t);\n\n\treturn result;\n}\ninterface CommonRangeMapping {\n\toutput1Pos: Position | undefined;\n\toutput2Pos: Position | undefined;\n\tinputPos: Position;\n\tlength: TextLength;\n}\n\nfunction toEqualRangeMappings(diffs: RangeMapping[], inputRange: Range, outputRange: Range): RangeMapping[] {\n\tconst result: RangeMapping[] = [];\n\n\tlet equalRangeInputStart = inputRange.getStartPosition();\n\tlet equalRangeOutputStart = outputRange.getStartPosition();\n\n\tfor (const d of diffs) {\n\t\tconst equalRangeMapping = new RangeMapping(\n\t\t\tRange.fromPositions(equalRangeInputStart, d.inputRange.getStartPosition()),\n\t\t\tRange.fromPositions(equalRangeOutputStart, d.outputRange.getStartPosition())\n\t\t);\n\t\tassertFn(() => lengthOfRange(equalRangeMapping.inputRange).equals(\n\t\t\tlengthOfRange(equalRangeMapping.outputRange)\n\t\t)\n\t\t);\n\t\tif (!equalRangeMapping.inputRange.isEmpty()) {\n\t\t\tresult.push(equalRangeMapping);\n\t\t}\n\n\t\tequalRangeInputStart = d.inputRange.getEndPosition();\n\t\tequalRangeOutputStart = d.outputRange.getEndPosition();\n\t}\n\n\tconst equalRangeMapping = new RangeMapping(\n\t\tRange.fromPositions(equalRangeInputStart, inputRange.getEndPosition()),\n\t\tRange.fromPositions(equalRangeOutputStart, outputRange.getEndPosition())\n\t);\n\tassertFn(() => lengthOfRange(equalRangeMapping.inputRange).equals(\n\t\tlengthOfRange(equalRangeMapping.outputRange)\n\t)\n\t);\n\tif (!equalRangeMapping.inputRange.isEmpty()) {\n\t\tresult.push(equalRangeMapping);\n\t}\n\n\treturn result;\n}\n\n/**\n * It is `result[i][0].inputRange.equals(result[i][1].inputRange)`.\n*/\nfunction splitUpCommonEqualRangeMappings(\n\tequalRangeMappings1: RangeMapping[],\n\tequalRangeMappings2: RangeMapping[]\n): CommonRangeMapping[] {\n\tconst result: CommonRangeMapping[] = [];\n\n\tconst events: { input: 0 | 1; start: boolean; inputPos: Position; outputPos: Position }[] = [];\n\tfor (const [input, rangeMappings] of [[0, equalRangeMappings1], [1, equalRangeMappings2]] as const) {\n\t\tfor (const rangeMapping of rangeMappings) {\n\t\t\tevents.push({\n\t\t\t\tinput: input,\n\t\t\t\tstart: true,\n\t\t\t\tinputPos: rangeMapping.inputRange.getStartPosition(),\n\t\t\t\toutputPos: rangeMapping.outputRange.getStartPosition()\n\t\t\t});\n\t\t\tevents.push({\n\t\t\t\tinput: input,\n\t\t\t\tstart: false,\n\t\t\t\tinputPos: rangeMapping.inputRange.getEndPosition(),\n\t\t\t\toutputPos: rangeMapping.outputRange.getEndPosition()\n\t\t\t});\n\t\t}\n\t}\n\n\tevents.sort(compareBy((m) => m.inputPos, Position.compare));\n\n\tconst starts: [Position | undefined, Position | undefined] = [undefined, undefined];\n\tlet lastInputPos: Position | undefined;\n\n\tfor (const event of events) {\n\t\tif (lastInputPos && starts.some(s => !!s)) {\n\t\t\tconst length = lengthBetweenPositions(lastInputPos, event.inputPos);\n\t\t\tif (!length.isZero()) {\n\t\t\t\tresult.push({\n\t\t\t\t\tinputPos: lastInputPos,\n\t\t\t\t\tlength,\n\t\t\t\t\toutput1Pos: starts[0],\n\t\t\t\t\toutput2Pos: starts[1]\n\t\t\t\t});\n\t\t\t\tif (starts[0]) {\n\t\t\t\t\tstarts[0] = addLength(starts[0], length);\n\t\t\t\t}\n\t\t\t\tif (starts[1]) {\n\t\t\t\t\tstarts[1] = addLength(starts[1], length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstarts[event.input] = event.start ? event.outputPos : undefined;\n\t\tlastInputPos = event.inputPos;\n\t}\n\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy } from '../../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../../base/common/assert.js';\nimport { isDefined } from '../../../../../base/common/types.js';\nimport { Position } from '../../../../../editor/common/core/position.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { TextLength } from '../../../../../editor/common/core/text/textLength.js';\nimport { RangeMapping } from '../model/mapping.js';\nimport { ModifiedBaseRange } from '../model/modifiedBaseRange.js';\nimport { addLength, lengthBetweenPositions, lengthOfRange } from '../model/rangeUtils.js';\n\nexport type LineAlignment = [input1LineNumber: number | undefined, baseLineNumber: number, input2LineNumber: number | undefined];\n\nexport function getAlignments(m: ModifiedBaseRange): LineAlignment[] {\n\tconst equalRanges1 = toEqualRangeMappings(m.input1Diffs.flatMap(d => d.rangeMappings), m.baseRange.toExclusiveRange(), m.input1Range.toExclusiveRange());\n\tconst equalRanges2 = toEqualRangeMappings(m.input2Diffs.flatMap(d => d.rangeMappings), m.baseRange.toExclusiveRange(), m.input2Range.toExclusiveRange());\n\n\tconst commonRanges = splitUpCommonEqualRangeMappings(equalRanges1, equalRanges2);\n\n\tlet result: LineAlignment[] = [];\n\tresult.push([m.input1Range.startLineNumber - 1, m.baseRange.startLineNumber - 1, m.input2Range.startLineNumber - 1]);\n\n\tfunction isFullSync(lineAlignment: LineAlignment) {\n\t\treturn lineAlignment.every((i) => i !== undefined);\n\t}\n\n\t// One base line has either up to one full sync or up to two half syncs.\n\tfor (const m of commonRanges) {\n\t\tconst lineAlignment: LineAlignment = [m.output1Pos?.lineNumber, m.inputPos.lineNumber, m.output2Pos?.lineNumber];\n\t\tconst alignmentIsFullSync = isFullSync(lineAlignment);\n\n\t\tlet shouldAdd = true;\n\t\tif (alignmentIsFullSync) {\n\t\t\tconst isNewFullSyncAlignment = !result.some(r => isFullSync(r) && r.some((v, idx) => v !== undefined && v === lineAlignment[idx]));\n\t\t\tif (isNewFullSyncAlignment) {\n\t\t\t\t// Remove half syncs\n\t\t\t\tresult = result.filter(r => !r.some((v, idx) => v !== undefined && v === lineAlignment[idx]));\n\t\t\t}\n\t\t\tshouldAdd = isNewFullSyncAlignment;\n\t\t} else {\n\t\t\tconst isNew = !result.some(r => r.some((v, idx) => v !== undefined && v === lineAlignment[idx]));\n\t\t\tshouldAdd = isNew;\n\t\t}\n\n\t\tif (shouldAdd) {\n\t\t\tresult.push(lineAlignment);\n\t\t} else {\n\t\t\tif (m.length.isGreaterThan(new TextLength(1, 0))) {\n\t\t\t\tresult.push([\n\t\t\t\t\tm.output1Pos ? m.output1Pos.lineNumber + 1 : undefined,\n\t\t\t\t\tm.inputPos.lineNumber + 1,\n\t\t\t\t\tm.output2Pos ? m.output2Pos.lineNumber + 1 : undefined\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst finalLineAlignment: LineAlignment = [m.input1Range.endLineNumberExclusive, m.baseRange.endLineNumberExclusive, m.input2Range.endLineNumberExclusive];\n\tresult = result.filter(r => r.every((v, idx) => v !== finalLineAlignment[idx]));\n\tresult.push(finalLineAlignment);\n\n\tassertFn(() => checkAdjacentItems(result.map(r => r[0]).filter(isDefined), (a, b) => a < b)\n\t\t&& checkAdjacentItems(result.map(r => r[1]).filter(isDefined), (a, b) => a <= b)\n\t\t&& checkAdjacentItems(result.map(r => r[2]).filter(isDefined), (a, b) => a < b)\n\t\t&& result.every(alignment => alignment.filter(isDefined).length >= 2)\n\t);\n\n\treturn result;\n}\ninterface CommonRangeMapping {\n\toutput1Pos: Position | undefined;\n\toutput2Pos: Position | undefined;\n\tinputPos: Position;\n\tlength: TextLength;\n}\n\nfunction toEqualRangeMappings(diffs: RangeMapping[], inputRange: Range, outputRange: Range): RangeMapping[] {\n\tconst result: RangeMapping[] = [];\n\n\tlet equalRangeInputStart = inputRange.getStartPosition();\n\tlet equalRangeOutputStart = outputRange.getStartPosition();\n\n\tfor (const d of diffs) {\n\t\tconst equalRangeMapping = new RangeMapping(\n\t\t\tRange.fromPositions(equalRangeInputStart, d.inputRange.getStartPosition()),\n\t\t\tRange.fromPositions(equalRangeOutputStart, d.outputRange.getStartPosition())\n\t\t);\n\t\tassertFn(() => lengthOfRange(equalRangeMapping.inputRange).equals(\n\t\t\tlengthOfRange(equalRangeMapping.outputRange)\n\t\t)\n\t\t);\n\t\tif (!equalRangeMapping.inputRange.isEmpty()) {\n\t\t\tresult.push(equalRangeMapping);\n\t\t}\n\n\t\tequalRangeInputStart = d.inputRange.getEndPosition();\n\t\tequalRangeOutputStart = d.outputRange.getEndPosition();\n\t}\n\n\tconst equalRangeMapping = new RangeMapping(\n\t\tRange.fromPositions(equalRangeInputStart, inputRange.getEndPosition()),\n\t\tRange.fromPositions(equalRangeOutputStart, outputRange.getEndPosition())\n\t);\n\tassertFn(() => lengthOfRange(equalRangeMapping.inputRange).equals(\n\t\tlengthOfRange(equalRangeMapping.outputRange)\n\t)\n\t);\n\tif (!equalRangeMapping.inputRange.isEmpty()) {\n\t\tresult.push(equalRangeMapping);\n\t}\n\n\treturn result;\n}\n\n/**\n * It is `result[i][0].inputRange.equals(result[i][1].inputRange)`.\n*/\nfunction splitUpCommonEqualRangeMappings(\n\tequalRangeMappings1: RangeMapping[],\n\tequalRangeMappings2: RangeMapping[]\n): CommonRangeMapping[] {\n\tconst result: CommonRangeMapping[] = [];\n\n\tconst events: { input: 0 | 1; start: boolean; inputPos: Position; outputPos: Position }[] = [];\n\tfor (const [input, rangeMappings] of [[0, equalRangeMappings1], [1, equalRangeMappings2]] as const) {\n\t\tfor (const rangeMapping of rangeMappings) {\n\t\t\tevents.push({\n\t\t\t\tinput: input,\n\t\t\t\tstart: true,\n\t\t\t\tinputPos: rangeMapping.inputRange.getStartPosition(),\n\t\t\t\toutputPos: rangeMapping.outputRange.getStartPosition()\n\t\t\t});\n\t\t\tevents.push({\n\t\t\t\tinput: input,\n\t\t\t\tstart: false,\n\t\t\t\tinputPos: rangeMapping.inputRange.getEndPosition(),\n\t\t\t\toutputPos: rangeMapping.outputRange.getEndPosition()\n\t\t\t});\n\t\t}\n\t}\n\n\tevents.sort(compareBy((m) => m.inputPos, Position.compare));\n\n\tconst starts: [Position | undefined, Position | undefined] = [undefined, undefined];\n\tlet lastInputPos: Position | undefined;\n\n\tfor (const event of events) {\n\t\tif (lastInputPos && starts.some(s => !!s)) {\n\t\t\tconst length = lengthBetweenPositions(lastInputPos, event.inputPos);\n\t\t\tif (!length.isZero()) {\n\t\t\t\tresult.push({\n\t\t\t\t\tinputPos: lastInputPos,\n\t\t\t\t\tlength,\n\t\t\t\t\toutput1Pos: starts[0],\n\t\t\t\t\toutput2Pos: starts[1]\n\t\t\t\t});\n\t\t\t\tif (starts[0]) {\n\t\t\t\t\tstarts[0] = addLength(starts[0], length);\n\t\t\t\t}\n\t\t\t\tif (starts[1]) {\n\t\t\t\t\tstarts[1] = addLength(starts[1], length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstarts[event.input] = event.start ? event.outputPos : undefined;\n\t\tlastInputPos = event.inputPos;\n\t}\n\n\treturn result;\n}\n"]}