{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/mapping.ts","vs/workbench/contrib/mergeEditor/browser/model/mapping.ts"],"names":[],"mappings":"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","file":"mapping.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, concatArrays, numberComparator } from '../../../../../base/common/arrays.js';\nimport { findLast } from '../../../../../base/common/arraysFind.js';\nimport { assertFn, checkAdjacentItems } from '../../../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { Position } from '../../../../../editor/common/core/position.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { ITextModel } from '../../../../../editor/common/model.js';\nimport { LineRangeEdit } from './editing.js';\nimport { MergeEditorLineRange } from './lineRange.js';\nimport { addLength, lengthBetweenPositions, rangeContainsPosition, rangeIsBeforeOrTouching } from './rangeUtils.js';\n\n/**\n * Represents a mapping of an input line range to an output line range.\n*/\nexport class LineRangeMapping {\n\tpublic static join(mappings: readonly LineRangeMapping[]): LineRangeMapping | undefined {\n\t\treturn mappings.reduce<undefined | LineRangeMapping>((acc, cur) => acc ? acc.join(cur) : cur, undefined);\n\t}\n\tconstructor(\n\t\tpublic readonly inputRange: MergeEditorLineRange,\n\t\tpublic readonly outputRange: MergeEditorLineRange\n\t) { }\n\n\tpublic extendInputRange(extendedInputRange: MergeEditorLineRange): LineRangeMapping {\n\t\tif (!extendedInputRange.containsRange(this.inputRange)) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tconst startDelta = extendedInputRange.startLineNumber - this.inputRange.startLineNumber;\n\t\tconst endDelta = extendedInputRange.endLineNumberExclusive - this.inputRange.endLineNumberExclusive;\n\t\treturn new LineRangeMapping(\n\t\t\textendedInputRange,\n\t\t\tMergeEditorLineRange.fromLength(\n\t\t\t\tthis.outputRange.startLineNumber + startDelta,\n\t\t\t\tthis.outputRange.length - startDelta + endDelta\n\t\t\t)\n\t\t);\n\t}\n\n\tpublic join(other: LineRangeMapping): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.inputRange.join(other.inputRange),\n\t\t\tthis.outputRange.join(other.outputRange)\n\t\t);\n\t}\n\n\tpublic get resultingDeltaFromOriginalToModified(): number {\n\t\treturn this.outputRange.endLineNumberExclusive - this.inputRange.endLineNumberExclusive;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.inputRange.toString()} -> ${this.outputRange.toString()}`;\n\t}\n\n\tpublic addOutputLineDelta(delta: number): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.inputRange,\n\t\t\tthis.outputRange.delta(delta)\n\t\t);\n\t}\n\n\tpublic addInputLineDelta(delta: number): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.inputRange.delta(delta),\n\t\t\tthis.outputRange\n\t\t);\n\t}\n\n\tpublic reverse(): LineRangeMapping {\n\t\treturn new LineRangeMapping(this.outputRange, this.inputRange);\n\t}\n}\n\n/**\n* Represents a total monotonous mapping of line ranges in one document to another document.\n*/\nexport class DocumentLineRangeMap {\n\tpublic static betweenOutputs(\n\t\tinputToOutput1: readonly LineRangeMapping[],\n\t\tinputToOutput2: readonly LineRangeMapping[],\n\t\tinputLineCount: number\n\t): DocumentLineRangeMap {\n\t\tconst alignments = MappingAlignment.compute(inputToOutput1, inputToOutput2);\n\t\tconst mappings = alignments.map((m) => new LineRangeMapping(m.output1Range, m.output2Range));\n\t\treturn new DocumentLineRangeMap(mappings, inputLineCount);\n\t}\n\n\tconstructor(\n\t\t/**\n\t\t * The line range mappings that define this document mapping.\n\t\t * The space between two input ranges must equal the space between two output ranges.\n\t\t * These holes act as dense sequence of 1:1 line mappings.\n\t\t*/\n\t\tpublic readonly lineRangeMappings: LineRangeMapping[],\n\t\tpublic readonly inputLineCount: number\n\t) {\n\t\tassertFn(() => {\n\t\t\treturn checkAdjacentItems(lineRangeMappings,\n\t\t\t\t(m1, m2) => m1.inputRange.isBefore(m2.inputRange) && m1.outputRange.isBefore(m2.outputRange) &&\n\t\t\t\t\tm2.inputRange.startLineNumber - m1.inputRange.endLineNumberExclusive === m2.outputRange.startLineNumber - m1.outputRange.endLineNumberExclusive,\n\t\t\t);\n\t\t});\n\t}\n\n\tpublic project(lineNumber: number): LineRangeMapping {\n\t\tconst lastBefore = findLast(this.lineRangeMappings, r => r.inputRange.startLineNumber <= lineNumber);\n\t\tif (!lastBefore) {\n\t\t\treturn new LineRangeMapping(\n\t\t\t\tMergeEditorLineRange.fromLength(lineNumber, 1),\n\t\t\t\tMergeEditorLineRange.fromLength(lineNumber, 1)\n\t\t\t);\n\t\t}\n\n\t\tif (lastBefore.inputRange.contains(lineNumber)) {\n\t\t\treturn lastBefore;\n\t\t}\n\t\tconst containingRange = MergeEditorLineRange.fromLength(lineNumber, 1);\n\t\tconst mappedRange = MergeEditorLineRange.fromLength(\n\t\t\tlineNumber +\n\t\t\tlastBefore.outputRange.endLineNumberExclusive -\n\t\t\tlastBefore.inputRange.endLineNumberExclusive,\n\t\t\t1\n\t\t);\n\t\treturn new LineRangeMapping(containingRange, mappedRange);\n\t}\n\n\tpublic get outputLineCount(): number {\n\t\tconst last = this.lineRangeMappings.at(-1);\n\t\tconst diff = last ? last.outputRange.endLineNumberExclusive - last.inputRange.endLineNumberExclusive : 0;\n\t\treturn this.inputLineCount + diff;\n\t}\n\n\tpublic reverse(): DocumentLineRangeMap {\n\t\treturn new DocumentLineRangeMap(\n\t\t\tthis.lineRangeMappings.map(r => r.reverse()),\n\t\t\tthis.outputLineCount\n\t\t);\n\t}\n}\n\n/**\n * Aligns two mappings with a common input range.\n */\nexport class MappingAlignment<T extends LineRangeMapping> {\n\tpublic static compute<T extends LineRangeMapping>(\n\t\tfromInputToOutput1: readonly T[],\n\t\tfromInputToOutput2: readonly T[]\n\t): MappingAlignment<T>[] {\n\t\tconst compareByStartLineNumber = compareBy<LineRangeMapping, number>(\n\t\t\t(d) => d.inputRange.startLineNumber,\n\t\t\tnumberComparator\n\t\t);\n\n\t\tconst combinedDiffs = concatArrays(\n\t\t\tfromInputToOutput1.map((diff) => ({ source: 0 as const, diff })),\n\t\t\tfromInputToOutput2.map((diff) => ({ source: 1 as const, diff }))\n\t\t).sort(compareBy((d) => d.diff, compareByStartLineNumber));\n\n\t\tconst currentDiffs = [new Array<T>(), new Array<T>()];\n\t\tconst deltaFromBaseToInput = [0, 0];\n\n\t\tconst alignments = new Array<MappingAlignment<T>>();\n\n\t\tfunction pushAndReset(inputRange: MergeEditorLineRange) {\n\t\t\tconst mapping1 = LineRangeMapping.join(currentDiffs[0]) || new LineRangeMapping(inputRange, inputRange.delta(deltaFromBaseToInput[0]));\n\t\t\tconst mapping2 = LineRangeMapping.join(currentDiffs[1]) || new LineRangeMapping(inputRange, inputRange.delta(deltaFromBaseToInput[1]));\n\n\t\t\talignments.push(\n\t\t\t\tnew MappingAlignment(\n\t\t\t\t\tcurrentInputRange!,\n\t\t\t\t\tmapping1.extendInputRange(currentInputRange!).outputRange,\n\t\t\t\t\tcurrentDiffs[0],\n\t\t\t\t\tmapping2.extendInputRange(currentInputRange!).outputRange,\n\t\t\t\t\tcurrentDiffs[1]\n\t\t\t\t)\n\t\t\t);\n\t\t\tcurrentDiffs[0] = [];\n\t\t\tcurrentDiffs[1] = [];\n\t\t}\n\n\t\tlet currentInputRange: MergeEditorLineRange | undefined;\n\n\t\tfor (const diff of combinedDiffs) {\n\t\t\tconst range = diff.diff.inputRange;\n\t\t\tif (currentInputRange && !currentInputRange.intersectsOrTouches(range)) {\n\t\t\t\tpushAndReset(currentInputRange);\n\t\t\t\tcurrentInputRange = undefined;\n\t\t\t}\n\t\t\tdeltaFromBaseToInput[diff.source] =\n\t\t\t\tdiff.diff.resultingDeltaFromOriginalToModified;\n\t\t\tcurrentInputRange = currentInputRange ? currentInputRange.join(range) : range;\n\t\t\tcurrentDiffs[diff.source].push(diff.diff);\n\t\t}\n\t\tif (currentInputRange) {\n\t\t\tpushAndReset(currentInputRange);\n\t\t}\n\n\t\treturn alignments;\n\t}\n\n\tconstructor(\n\t\tpublic readonly inputRange: MergeEditorLineRange,\n\t\tpublic readonly output1Range: MergeEditorLineRange,\n\t\tpublic readonly output1LineMappings: T[],\n\t\tpublic readonly output2Range: MergeEditorLineRange,\n\t\tpublic readonly output2LineMappings: T[],\n\t) {\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.output1Range} <- ${this.inputRange} -> ${this.output2Range}`;\n\t}\n}\n\n/**\n * A line range mapping with inner range mappings.\n*/\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n\tpublic static override join(mappings: readonly DetailedLineRangeMapping[]): DetailedLineRangeMapping | undefined {\n\t\treturn mappings.reduce<undefined | DetailedLineRangeMapping>((acc, cur) => acc ? acc.join(cur) : cur, undefined);\n\t}\n\n\tpublic readonly rangeMappings: readonly RangeMapping[];\n\n\tconstructor(\n\t\tinputRange: MergeEditorLineRange,\n\t\tpublic readonly inputTextModel: ITextModel,\n\t\toutputRange: MergeEditorLineRange,\n\t\tpublic readonly outputTextModel: ITextModel,\n\t\trangeMappings?: readonly RangeMapping[],\n\t) {\n\t\tsuper(inputRange, outputRange);\n\n\t\tthis.rangeMappings = rangeMappings || [new RangeMapping(this.inputRange.toExclusiveRange(), this.outputRange.toExclusiveRange())];\n\t}\n\n\tpublic override addOutputLineDelta(delta: number): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(\n\t\t\tthis.inputRange,\n\t\t\tthis.inputTextModel,\n\t\t\tthis.outputRange.delta(delta),\n\t\t\tthis.outputTextModel,\n\t\t\tthis.rangeMappings.map(d => d.addOutputLineDelta(delta))\n\t\t);\n\t}\n\n\tpublic override addInputLineDelta(delta: number): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(\n\t\t\tthis.inputRange.delta(delta),\n\t\t\tthis.inputTextModel,\n\t\t\tthis.outputRange,\n\t\t\tthis.outputTextModel,\n\t\t\tthis.rangeMappings.map(d => d.addInputLineDelta(delta))\n\t\t);\n\t}\n\n\tpublic override join(other: DetailedLineRangeMapping): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(\n\t\t\tthis.inputRange.join(other.inputRange),\n\t\t\tthis.inputTextModel,\n\t\t\tthis.outputRange.join(other.outputRange),\n\t\t\tthis.outputTextModel,\n\t\t);\n\t}\n\n\tpublic getLineEdit(): LineRangeEdit {\n\t\treturn new LineRangeEdit(this.inputRange, this.getOutputLines());\n\t}\n\n\tpublic getReverseLineEdit(): LineRangeEdit {\n\t\treturn new LineRangeEdit(this.outputRange, this.getInputLines());\n\t}\n\n\tprivate getOutputLines(): string[] {\n\t\treturn this.outputRange.getLines(this.outputTextModel);\n\t}\n\n\tprivate getInputLines(): string[] {\n\t\treturn this.inputRange.getLines(this.inputTextModel);\n\t}\n}\n\n/**\n * Represents a mapping of an input range to an output range.\n*/\nexport class RangeMapping {\n\tconstructor(public readonly inputRange: Range, public readonly outputRange: Range) {\n\t}\n\ttoString(): string {\n\t\tfunction rangeToString(range: Range) {\n\t\t\t// TODO@hediet make this the default Range.toString\n\t\t\treturn `[${range.startLineNumber}:${range.startColumn}, ${range.endLineNumber}:${range.endColumn})`;\n\t\t}\n\n\t\treturn `${rangeToString(this.inputRange)} -> ${rangeToString(this.outputRange)}`;\n\t}\n\n\taddOutputLineDelta(deltaLines: number): RangeMapping {\n\t\treturn new RangeMapping(\n\t\t\tthis.inputRange,\n\t\t\tnew Range(\n\t\t\t\tthis.outputRange.startLineNumber + deltaLines,\n\t\t\t\tthis.outputRange.startColumn,\n\t\t\t\tthis.outputRange.endLineNumber + deltaLines,\n\t\t\t\tthis.outputRange.endColumn\n\t\t\t)\n\t\t);\n\t}\n\n\taddInputLineDelta(deltaLines: number): RangeMapping {\n\t\treturn new RangeMapping(\n\t\t\tnew Range(\n\t\t\t\tthis.inputRange.startLineNumber + deltaLines,\n\t\t\t\tthis.inputRange.startColumn,\n\t\t\t\tthis.inputRange.endLineNumber + deltaLines,\n\t\t\t\tthis.inputRange.endColumn\n\t\t\t),\n\t\t\tthis.outputRange,\n\t\t);\n\t}\n\n\treverse(): RangeMapping {\n\t\treturn new RangeMapping(this.outputRange, this.inputRange);\n\t}\n}\n\n/**\n* Represents a total monotonous mapping of ranges in one document to another document.\n*/\nexport class DocumentRangeMap {\n\tconstructor(\n\t\t/**\n\t\t * The line range mappings that define this document mapping.\n\t\t * Can have holes.\n\t\t*/\n\t\tpublic readonly rangeMappings: RangeMapping[],\n\t\tpublic readonly inputLineCount: number\n\t) {\n\t\tassertFn(() => checkAdjacentItems(\n\t\t\trangeMappings,\n\t\t\t(m1, m2) =>\n\t\t\t\trangeIsBeforeOrTouching(m1.inputRange, m2.inputRange) &&\n\t\t\t\trangeIsBeforeOrTouching(m1.outputRange, m2.outputRange) /*&&\n\t\t\t\tlengthBetweenPositions(m1.inputRange.getEndPosition(), m2.inputRange.getStartPosition()).equals(\n\t\t\t\t\tlengthBetweenPositions(m1.outputRange.getEndPosition(), m2.outputRange.getStartPosition())\n\t\t\t\t)*/\n\t\t));\n\t}\n\n\tpublic project(position: Position): RangeMapping {\n\t\tconst lastBefore = findLast(this.rangeMappings, r => r.inputRange.getStartPosition().isBeforeOrEqual(position));\n\t\tif (!lastBefore) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(position, position),\n\t\t\t\tRange.fromPositions(position, position)\n\t\t\t);\n\t\t}\n\n\t\tif (rangeContainsPosition(lastBefore.inputRange, position)) {\n\t\t\treturn lastBefore;\n\t\t}\n\n\t\tconst dist = lengthBetweenPositions(lastBefore.inputRange.getEndPosition(), position);\n\t\tconst outputPos = addLength(lastBefore.outputRange.getEndPosition(), dist);\n\n\t\treturn new RangeMapping(\n\t\t\tRange.fromPositions(position),\n\t\t\tRange.fromPositions(outputPos)\n\t\t);\n\t}\n\n\tpublic projectRange(range: Range): RangeMapping {\n\t\tconst start = this.project(range.getStartPosition());\n\t\tconst end = this.project(range.getEndPosition());\n\t\treturn new RangeMapping(\n\t\t\tstart.inputRange.plusRange(end.inputRange),\n\t\t\tstart.outputRange.plusRange(end.outputRange)\n\t\t);\n\t}\n\n\tpublic get outputLineCount(): number {\n\t\tconst last = this.rangeMappings.at(-1);\n\t\tconst diff = last ? last.outputRange.endLineNumber - last.inputRange.endLineNumber : 0;\n\t\treturn this.inputLineCount + diff;\n\t}\n\n\tpublic reverse(): DocumentRangeMap {\n\t\treturn new DocumentRangeMap(\n\t\t\tthis.rangeMappings.map(m => m.reverse()),\n\t\t\tthis.outputLineCount\n\t\t);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, concatArrays, numberComparator } from '../../../../../base/common/arrays.js';\nimport { findLast } from '../../../../../base/common/arraysFind.js';\nimport { assertFn, checkAdjacentItems } from '../../../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { Position } from '../../../../../editor/common/core/position.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { ITextModel } from '../../../../../editor/common/model.js';\nimport { LineRangeEdit } from './editing.js';\nimport { MergeEditorLineRange } from './lineRange.js';\nimport { addLength, lengthBetweenPositions, rangeContainsPosition, rangeIsBeforeOrTouching } from './rangeUtils.js';\n\n/**\n * Represents a mapping of an input line range to an output line range.\n*/\nexport class LineRangeMapping {\n\tpublic static join(mappings: readonly LineRangeMapping[]): LineRangeMapping | undefined {\n\t\treturn mappings.reduce<undefined | LineRangeMapping>((acc, cur) => acc ? acc.join(cur) : cur, undefined);\n\t}\n\tconstructor(\n\t\tpublic readonly inputRange: MergeEditorLineRange,\n\t\tpublic readonly outputRange: MergeEditorLineRange\n\t) { }\n\n\tpublic extendInputRange(extendedInputRange: MergeEditorLineRange): LineRangeMapping {\n\t\tif (!extendedInputRange.containsRange(this.inputRange)) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tconst startDelta = extendedInputRange.startLineNumber - this.inputRange.startLineNumber;\n\t\tconst endDelta = extendedInputRange.endLineNumberExclusive - this.inputRange.endLineNumberExclusive;\n\t\treturn new LineRangeMapping(\n\t\t\textendedInputRange,\n\t\t\tMergeEditorLineRange.fromLength(\n\t\t\t\tthis.outputRange.startLineNumber + startDelta,\n\t\t\t\tthis.outputRange.length - startDelta + endDelta\n\t\t\t)\n\t\t);\n\t}\n\n\tpublic join(other: LineRangeMapping): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.inputRange.join(other.inputRange),\n\t\t\tthis.outputRange.join(other.outputRange)\n\t\t);\n\t}\n\n\tpublic get resultingDeltaFromOriginalToModified(): number {\n\t\treturn this.outputRange.endLineNumberExclusive - this.inputRange.endLineNumberExclusive;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.inputRange.toString()} -> ${this.outputRange.toString()}`;\n\t}\n\n\tpublic addOutputLineDelta(delta: number): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.inputRange,\n\t\t\tthis.outputRange.delta(delta)\n\t\t);\n\t}\n\n\tpublic addInputLineDelta(delta: number): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.inputRange.delta(delta),\n\t\t\tthis.outputRange\n\t\t);\n\t}\n\n\tpublic reverse(): LineRangeMapping {\n\t\treturn new LineRangeMapping(this.outputRange, this.inputRange);\n\t}\n}\n\n/**\n* Represents a total monotonous mapping of line ranges in one document to another document.\n*/\nexport class DocumentLineRangeMap {\n\tpublic static betweenOutputs(\n\t\tinputToOutput1: readonly LineRangeMapping[],\n\t\tinputToOutput2: readonly LineRangeMapping[],\n\t\tinputLineCount: number\n\t): DocumentLineRangeMap {\n\t\tconst alignments = MappingAlignment.compute(inputToOutput1, inputToOutput2);\n\t\tconst mappings = alignments.map((m) => new LineRangeMapping(m.output1Range, m.output2Range));\n\t\treturn new DocumentLineRangeMap(mappings, inputLineCount);\n\t}\n\n\tconstructor(\n\t\t/**\n\t\t * The line range mappings that define this document mapping.\n\t\t * The space between two input ranges must equal the space between two output ranges.\n\t\t * These holes act as dense sequence of 1:1 line mappings.\n\t\t*/\n\t\tpublic readonly lineRangeMappings: LineRangeMapping[],\n\t\tpublic readonly inputLineCount: number\n\t) {\n\t\tassertFn(() => {\n\t\t\treturn checkAdjacentItems(lineRangeMappings,\n\t\t\t\t(m1, m2) => m1.inputRange.isBefore(m2.inputRange) && m1.outputRange.isBefore(m2.outputRange) &&\n\t\t\t\t\tm2.inputRange.startLineNumber - m1.inputRange.endLineNumberExclusive === m2.outputRange.startLineNumber - m1.outputRange.endLineNumberExclusive,\n\t\t\t);\n\t\t});\n\t}\n\n\tpublic project(lineNumber: number): LineRangeMapping {\n\t\tconst lastBefore = findLast(this.lineRangeMappings, r => r.inputRange.startLineNumber <= lineNumber);\n\t\tif (!lastBefore) {\n\t\t\treturn new LineRangeMapping(\n\t\t\t\tMergeEditorLineRange.fromLength(lineNumber, 1),\n\t\t\t\tMergeEditorLineRange.fromLength(lineNumber, 1)\n\t\t\t);\n\t\t}\n\n\t\tif (lastBefore.inputRange.contains(lineNumber)) {\n\t\t\treturn lastBefore;\n\t\t}\n\t\tconst containingRange = MergeEditorLineRange.fromLength(lineNumber, 1);\n\t\tconst mappedRange = MergeEditorLineRange.fromLength(\n\t\t\tlineNumber +\n\t\t\tlastBefore.outputRange.endLineNumberExclusive -\n\t\t\tlastBefore.inputRange.endLineNumberExclusive,\n\t\t\t1\n\t\t);\n\t\treturn new LineRangeMapping(containingRange, mappedRange);\n\t}\n\n\tpublic get outputLineCount(): number {\n\t\tconst last = this.lineRangeMappings.at(-1);\n\t\tconst diff = last ? last.outputRange.endLineNumberExclusive - last.inputRange.endLineNumberExclusive : 0;\n\t\treturn this.inputLineCount + diff;\n\t}\n\n\tpublic reverse(): DocumentLineRangeMap {\n\t\treturn new DocumentLineRangeMap(\n\t\t\tthis.lineRangeMappings.map(r => r.reverse()),\n\t\t\tthis.outputLineCount\n\t\t);\n\t}\n}\n\n/**\n * Aligns two mappings with a common input range.\n */\nexport class MappingAlignment<T extends LineRangeMapping> {\n\tpublic static compute<T extends LineRangeMapping>(\n\t\tfromInputToOutput1: readonly T[],\n\t\tfromInputToOutput2: readonly T[]\n\t): MappingAlignment<T>[] {\n\t\tconst compareByStartLineNumber = compareBy<LineRangeMapping, number>(\n\t\t\t(d) => d.inputRange.startLineNumber,\n\t\t\tnumberComparator\n\t\t);\n\n\t\tconst combinedDiffs = concatArrays(\n\t\t\tfromInputToOutput1.map((diff) => ({ source: 0 as const, diff })),\n\t\t\tfromInputToOutput2.map((diff) => ({ source: 1 as const, diff }))\n\t\t).sort(compareBy((d) => d.diff, compareByStartLineNumber));\n\n\t\tconst currentDiffs = [new Array<T>(), new Array<T>()];\n\t\tconst deltaFromBaseToInput = [0, 0];\n\n\t\tconst alignments = new Array<MappingAlignment<T>>();\n\n\t\tfunction pushAndReset(inputRange: MergeEditorLineRange) {\n\t\t\tconst mapping1 = LineRangeMapping.join(currentDiffs[0]) || new LineRangeMapping(inputRange, inputRange.delta(deltaFromBaseToInput[0]));\n\t\t\tconst mapping2 = LineRangeMapping.join(currentDiffs[1]) || new LineRangeMapping(inputRange, inputRange.delta(deltaFromBaseToInput[1]));\n\n\t\t\talignments.push(\n\t\t\t\tnew MappingAlignment(\n\t\t\t\t\tcurrentInputRange!,\n\t\t\t\t\tmapping1.extendInputRange(currentInputRange!).outputRange,\n\t\t\t\t\tcurrentDiffs[0],\n\t\t\t\t\tmapping2.extendInputRange(currentInputRange!).outputRange,\n\t\t\t\t\tcurrentDiffs[1]\n\t\t\t\t)\n\t\t\t);\n\t\t\tcurrentDiffs[0] = [];\n\t\t\tcurrentDiffs[1] = [];\n\t\t}\n\n\t\tlet currentInputRange: MergeEditorLineRange | undefined;\n\n\t\tfor (const diff of combinedDiffs) {\n\t\t\tconst range = diff.diff.inputRange;\n\t\t\tif (currentInputRange && !currentInputRange.intersectsOrTouches(range)) {\n\t\t\t\tpushAndReset(currentInputRange);\n\t\t\t\tcurrentInputRange = undefined;\n\t\t\t}\n\t\t\tdeltaFromBaseToInput[diff.source] =\n\t\t\t\tdiff.diff.resultingDeltaFromOriginalToModified;\n\t\t\tcurrentInputRange = currentInputRange ? currentInputRange.join(range) : range;\n\t\t\tcurrentDiffs[diff.source].push(diff.diff);\n\t\t}\n\t\tif (currentInputRange) {\n\t\t\tpushAndReset(currentInputRange);\n\t\t}\n\n\t\treturn alignments;\n\t}\n\n\tconstructor(\n\t\tpublic readonly inputRange: MergeEditorLineRange,\n\t\tpublic readonly output1Range: MergeEditorLineRange,\n\t\tpublic readonly output1LineMappings: T[],\n\t\tpublic readonly output2Range: MergeEditorLineRange,\n\t\tpublic readonly output2LineMappings: T[],\n\t) {\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.output1Range} <- ${this.inputRange} -> ${this.output2Range}`;\n\t}\n}\n\n/**\n * A line range mapping with inner range mappings.\n*/\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n\tpublic static override join(mappings: readonly DetailedLineRangeMapping[]): DetailedLineRangeMapping | undefined {\n\t\treturn mappings.reduce<undefined | DetailedLineRangeMapping>((acc, cur) => acc ? acc.join(cur) : cur, undefined);\n\t}\n\n\tpublic readonly rangeMappings: readonly RangeMapping[];\n\n\tconstructor(\n\t\tinputRange: MergeEditorLineRange,\n\t\tpublic readonly inputTextModel: ITextModel,\n\t\toutputRange: MergeEditorLineRange,\n\t\tpublic readonly outputTextModel: ITextModel,\n\t\trangeMappings?: readonly RangeMapping[],\n\t) {\n\t\tsuper(inputRange, outputRange);\n\n\t\tthis.rangeMappings = rangeMappings || [new RangeMapping(this.inputRange.toExclusiveRange(), this.outputRange.toExclusiveRange())];\n\t}\n\n\tpublic override addOutputLineDelta(delta: number): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(\n\t\t\tthis.inputRange,\n\t\t\tthis.inputTextModel,\n\t\t\tthis.outputRange.delta(delta),\n\t\t\tthis.outputTextModel,\n\t\t\tthis.rangeMappings.map(d => d.addOutputLineDelta(delta))\n\t\t);\n\t}\n\n\tpublic override addInputLineDelta(delta: number): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(\n\t\t\tthis.inputRange.delta(delta),\n\t\t\tthis.inputTextModel,\n\t\t\tthis.outputRange,\n\t\t\tthis.outputTextModel,\n\t\t\tthis.rangeMappings.map(d => d.addInputLineDelta(delta))\n\t\t);\n\t}\n\n\tpublic override join(other: DetailedLineRangeMapping): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(\n\t\t\tthis.inputRange.join(other.inputRange),\n\t\t\tthis.inputTextModel,\n\t\t\tthis.outputRange.join(other.outputRange),\n\t\t\tthis.outputTextModel,\n\t\t);\n\t}\n\n\tpublic getLineEdit(): LineRangeEdit {\n\t\treturn new LineRangeEdit(this.inputRange, this.getOutputLines());\n\t}\n\n\tpublic getReverseLineEdit(): LineRangeEdit {\n\t\treturn new LineRangeEdit(this.outputRange, this.getInputLines());\n\t}\n\n\tprivate getOutputLines(): string[] {\n\t\treturn this.outputRange.getLines(this.outputTextModel);\n\t}\n\n\tprivate getInputLines(): string[] {\n\t\treturn this.inputRange.getLines(this.inputTextModel);\n\t}\n}\n\n/**\n * Represents a mapping of an input range to an output range.\n*/\nexport class RangeMapping {\n\tconstructor(public readonly inputRange: Range, public readonly outputRange: Range) {\n\t}\n\ttoString(): string {\n\t\tfunction rangeToString(range: Range) {\n\t\t\t// TODO@hediet make this the default Range.toString\n\t\t\treturn `[${range.startLineNumber}:${range.startColumn}, ${range.endLineNumber}:${range.endColumn})`;\n\t\t}\n\n\t\treturn `${rangeToString(this.inputRange)} -> ${rangeToString(this.outputRange)}`;\n\t}\n\n\taddOutputLineDelta(deltaLines: number): RangeMapping {\n\t\treturn new RangeMapping(\n\t\t\tthis.inputRange,\n\t\t\tnew Range(\n\t\t\t\tthis.outputRange.startLineNumber + deltaLines,\n\t\t\t\tthis.outputRange.startColumn,\n\t\t\t\tthis.outputRange.endLineNumber + deltaLines,\n\t\t\t\tthis.outputRange.endColumn\n\t\t\t)\n\t\t);\n\t}\n\n\taddInputLineDelta(deltaLines: number): RangeMapping {\n\t\treturn new RangeMapping(\n\t\t\tnew Range(\n\t\t\t\tthis.inputRange.startLineNumber + deltaLines,\n\t\t\t\tthis.inputRange.startColumn,\n\t\t\t\tthis.inputRange.endLineNumber + deltaLines,\n\t\t\t\tthis.inputRange.endColumn\n\t\t\t),\n\t\t\tthis.outputRange,\n\t\t);\n\t}\n\n\treverse(): RangeMapping {\n\t\treturn new RangeMapping(this.outputRange, this.inputRange);\n\t}\n}\n\n/**\n* Represents a total monotonous mapping of ranges in one document to another document.\n*/\nexport class DocumentRangeMap {\n\tconstructor(\n\t\t/**\n\t\t * The line range mappings that define this document mapping.\n\t\t * Can have holes.\n\t\t*/\n\t\tpublic readonly rangeMappings: RangeMapping[],\n\t\tpublic readonly inputLineCount: number\n\t) {\n\t\tassertFn(() => checkAdjacentItems(\n\t\t\trangeMappings,\n\t\t\t(m1, m2) =>\n\t\t\t\trangeIsBeforeOrTouching(m1.inputRange, m2.inputRange) &&\n\t\t\t\trangeIsBeforeOrTouching(m1.outputRange, m2.outputRange) /*&&\n\t\t\t\tlengthBetweenPositions(m1.inputRange.getEndPosition(), m2.inputRange.getStartPosition()).equals(\n\t\t\t\t\tlengthBetweenPositions(m1.outputRange.getEndPosition(), m2.outputRange.getStartPosition())\n\t\t\t\t)*/\n\t\t));\n\t}\n\n\tpublic project(position: Position): RangeMapping {\n\t\tconst lastBefore = findLast(this.rangeMappings, r => r.inputRange.getStartPosition().isBeforeOrEqual(position));\n\t\tif (!lastBefore) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(position, position),\n\t\t\t\tRange.fromPositions(position, position)\n\t\t\t);\n\t\t}\n\n\t\tif (rangeContainsPosition(lastBefore.inputRange, position)) {\n\t\t\treturn lastBefore;\n\t\t}\n\n\t\tconst dist = lengthBetweenPositions(lastBefore.inputRange.getEndPosition(), position);\n\t\tconst outputPos = addLength(lastBefore.outputRange.getEndPosition(), dist);\n\n\t\treturn new RangeMapping(\n\t\t\tRange.fromPositions(position),\n\t\t\tRange.fromPositions(outputPos)\n\t\t);\n\t}\n\n\tpublic projectRange(range: Range): RangeMapping {\n\t\tconst start = this.project(range.getStartPosition());\n\t\tconst end = this.project(range.getEndPosition());\n\t\treturn new RangeMapping(\n\t\t\tstart.inputRange.plusRange(end.inputRange),\n\t\t\tstart.outputRange.plusRange(end.outputRange)\n\t\t);\n\t}\n\n\tpublic get outputLineCount(): number {\n\t\tconst last = this.rangeMappings.at(-1);\n\t\tconst diff = last ? last.outputRange.endLineNumber - last.inputRange.endLineNumber : 0;\n\t\treturn this.inputLineCount + diff;\n\t}\n\n\tpublic reverse(): DocumentRangeMap {\n\t\treturn new DocumentRangeMap(\n\t\t\tthis.rangeMappings.map(m => m.reverse()),\n\t\t\tthis.outputLineCount\n\t\t);\n\t}\n}\n"]}