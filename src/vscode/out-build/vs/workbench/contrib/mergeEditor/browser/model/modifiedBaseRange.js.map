{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mergeEditor/browser/model/modifiedBaseRange.ts","vs/workbench/contrib/mergeEditor/browser/model/modifiedBaseRange.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,SAAS,EAAE,YAAY,EAAE,MAAM,EAAE,gBAAgB,EAAE,mBAAmB,EAAE,MAAM,sCAAsC,CAAC;AAC9H,OAAO,EAAE,kBAAkB,EAAE,MAAM,sCAAsC,CAAC;AAC1E,OAAO,EAAE,UAAU,EAAE,MAAM,uCAAuC,CAAC;AAEnE,OAAO,EAAE,QAAQ,EAAE,MAAM,+CAA+C,CAAC;AACzE,OAAO,EAAE,KAAK,EAAE,MAAM,4CAA4C,CAAC;AAEnE,OAAO,EAAE,aAAa,EAAE,SAAS,EAAE,MAAM,cAAc,CAAC;AAExD,OAAO,EAAE,wBAAwB,EAAE,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAE1E;;;;;;EAME;AACF,MAAM,OAAO,iBAAiB;IACtB,MAAM,CAAC,SAAS,CACtB,MAA2C,EAC3C,MAA2C,EAC3C,aAAyB,EACzB,eAA2B,EAC3B,eAA2B;QAE3B,MAAM,UAAU,GAAG,gBAAgB,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QAC5D,OAAO,UAAU,CAAC,GAAG,CACpB,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,iBAAiB,CAC3B,CAAC,CAAC,UAAU,EACZ,aAAa,EACb,CAAC,CAAC,YAAY,EACd,eAAe,EACf,CAAC,CAAC,mBAAmB,EACrB,CAAC,CAAC,YAAY,EACd,eAAe,EACf,CAAC,CAAC,mBAAmB,CACrB,CACD,CAAC;IACH,CAAC;IAMD,YACiB,SAA+B,EAC/B,aAAyB,EACzB,WAAiC,EACjC,eAA2B;IAE3C;;MAEE;IACc,WAAgD,EAChD,WAAiC,EACjC,eAA2B;IAE3C;;MAEE;IACc,WAAgD;QAfhD,cAAS,GAAT,SAAS,CAAsB;QAC/B,kBAAa,GAAb,aAAa,CAAY;QACzB,gBAAW,GAAX,WAAW,CAAsB;QACjC,oBAAe,GAAf,eAAe,CAAY;QAK3B,gBAAW,GAAX,WAAW,CAAqC;QAChD,gBAAW,GAAX,WAAW,CAAsB;QACjC,oBAAe,GAAf,eAAe,CAAY;QAK3B,gBAAW,GAAX,WAAW,CAAqC;QAEhE,IAAI,CAAC,kBAAkB,GAAG,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC1E,IAAI,CAAC,kBAAkB,GAAG,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC1E,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;QACnH,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC;QACrC,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC;QACrC,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC;QACpC,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC;QACpC,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACpE,MAAM,IAAI,kBAAkB,CAAC,6BAA6B,CAAC,CAAC;QAC7D,CAAC;IACF,CAAC;IAEM,aAAa,CAAC,WAAkB;QACtC,OAAO,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC;IAChE,CAAC;IAEM,oBAAoB,CAAC,WAAkB;QAC7C,OAAO,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC;IAC9E,CAAC;IAEM,aAAa,CAAC,WAAkB;QACtC,OAAO,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC;IAChE,CAAC;IAED,IAAW,aAAa;QACvB,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;IACnE,CAAC;IAED,IAAW,aAAa;QACvB,OAAO,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC;IACjD,CAAC;IAED,IAAW,eAAe;QACzB,MAAM,MAAM,GAAG,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC;QAC1C,MAAM,MAAM,GAAG,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC;QAC1C,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,EAAE,CAAC;YACxB,OAAO,KAAK,CAAC;QACd,CAAC;QACD,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAC/B,CAAC;IAEM,cAAc,CAAC,KAA6B;QAClD,MAAM,KAAK,GAAmE,EAAE,CAAC;QACjF,IAAI,KAAK,CAAC,cAAc,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;YACrD,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,kBAAkB,EAAE,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;QAC/D,CAAC;QACD,IAAI,KAAK,CAAC,cAAc,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;YACrD,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,kBAAkB,EAAE,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;QAC/D,CAAC;QAED,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxB,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,cAAc,EAAE,sBAAsB,CAAC,IAAI,EAAE,CAAC;QACzE,CAAC;QACD,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxB,OAAO,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,cAAc,EAAE,sBAAsB,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,CAAC,EAAE,CAAC;QAC7I,CAAC;QAED,IAAI,KAAK,CAAC,IAAI,KAAK,0BAA0B,CAAC,IAAI,EAAE,CAAC;YACpD,MAAM,IAAI,kBAAkB,EAAE,CAAC;QAChC,CAAC;QAED,MAAM,iBAAiB,GAAG,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;QACxI,IAAI,iBAAiB,EAAE,CAAC;YACvB,OAAO,EAAE,IAAI,EAAE,iBAAiB,EAAE,cAAc,EAAE,KAAK,EAAE,CAAC;QAC3D,CAAC;QAED,OAAO;YACN,IAAI,EAAE,KAAK,CAAC,mBAAmB,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE;YACzE,cAAc,EAAE,sBAAsB,CAAC,IAAI,CAAC,cAAc,CACzD,mBAAmB,CAAC,KAAK,CAAC,UAAU,CAAC,EACrC,IAAI,EACJ,KAAK,CACL;SACD,CAAC;IACH,CAAC;IAKO,kBAAkB,CAAC,UAAiB;QAC3C,IAAI,UAAU,KAAK,CAAC,IAAI,IAAI,CAAC,wBAAwB,KAAK,IAAI,EAAE,CAAC;YAChE,OAAO,IAAI,CAAC,wBAAwB,CAAC;QACtC,CAAC;aAAM,IAAI,UAAU,KAAK,CAAC,IAAI,IAAI,CAAC,wBAAwB,KAAK,IAAI,EAAE,CAAC;YACvE,OAAO,IAAI,CAAC,wBAAwB,CAAC;QACtC,CAAC;QAED,MAAM,aAAa,GAAG,YAAY,CACjC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAClC,KAAK,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAU,EAAE,CAAC,CAAC,CAChE,EACD,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAClC,KAAK,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAU,EAAE,CAAC,CAAC,CAChE,CACD,CAAC,IAAI,CACL,mBAAmB,CAClB,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,wBAAwB,CAAC,EACnE,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,gBAAgB,CAAC,CACpE,CACD,CAAC;QAEF,MAAM,WAAW,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;YACzC,MAAM,eAAe,GAAG,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC;YACpF,OAAO,IAAI,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,EAAE,eAAe,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;QAC9F,CAAC,CAAC,CAAC;QAEH,MAAM,MAAM,GAAG,oBAAoB,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QACrF,IAAI,UAAU,KAAK,CAAC,EAAE,CAAC;YACtB,IAAI,CAAC,wBAAwB,GAAG,MAAM,CAAC;QACxC,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,wBAAwB,GAAG,MAAM,CAAC;QACxC,CAAC;QACD,OAAO,MAAM,CAAC;IACf,CAAC;IAKO,iBAAiB,CAAC,UAAiB;QAC1C,IAAI,UAAU,KAAK,CAAC,IAAI,IAAI,CAAC,uBAAuB,KAAK,IAAI,EAAE,CAAC;YAC/D,OAAO,IAAI,CAAC,uBAAuB,CAAC;QACrC,CAAC;aAAM,IAAI,UAAU,KAAK,CAAC,IAAI,IAAI,CAAC,uBAAuB,KAAK,IAAI,EAAE,CAAC;YACtE,OAAO,IAAI,CAAC,uBAAuB,CAAC;QACrC,CAAC;QAED,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAClE,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAClE,IAAI,UAAU,KAAK,CAAC,EAAE,CAAC;YACtB,CAAC,WAAW,EAAE,WAAW,CAAC,GAAG,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;QACzD,CAAC;QAED,MAAM,MAAM,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC;QAClF,IAAI,UAAU,KAAK,CAAC,EAAE,CAAC;YACtB,IAAI,CAAC,uBAAuB,GAAG,MAAM,CAAC;QACvC,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,uBAAuB,GAAG,MAAM,CAAC;QACvC,CAAC;QACD,OAAO,MAAM,CAAC;IACf,CAAC;CACD;AAED,SAAS,oBAAoB,CAAC,KAA2B,EAAE,WAAwB,EAAE,SAAqB;IACzG,IAAI,IAAI,GAAG,EAAE,CAAC;IACd,MAAM,gBAAgB,GAAG,KAAK,CAAC,eAAe,GAAG,CAAC,CAAC;IACnD,IAAI,eAAe,GAAG,gBAAgB;QACrC,CAAC,CAAC,IAAI,QAAQ,CACb,KAAK,CAAC,eAAe,GAAG,CAAC,EACzB,SAAS,CAAC,gBAAgB,CAAC,KAAK,CAAC,eAAe,GAAG,CAAC,CAAC,CACrD;QACD,CAAC,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC;IAE1C,KAAK,MAAM,IAAI,IAAI,WAAW,EAAE,CAAC;QAChC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,CAAC;QAChD,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,SAAS,CAAC,EAAE,CAAC;YACjD,OAAO,SAAS,CAAC;QAClB,CAAC;QACD,IAAI,YAAY,GAAG,SAAS,CAAC,eAAe,CAAC,KAAK,CAAC,aAAa,CAAC,eAAe,EAAE,SAAS,CAAC,CAAC,CAAC;QAC9F,IAAI,SAAS,CAAC,UAAU,GAAG,SAAS,CAAC,YAAY,EAAE,EAAE,CAAC;YACrD,+DAA+D;YAC/D,iGAAiG;YACjG,+BAA+B;YAC/B,YAAY,IAAI,IAAI,CAAC;QACtB,CAAC;QACD,IAAI,IAAI,YAAY,CAAC;QACrB,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC;QACrB,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC;IAC/C,CAAC;IAED,MAAM,aAAa,GAAG,KAAK,CAAC,sBAAsB,IAAI,SAAS,CAAC,YAAY,EAAE,CAAC;IAC/E,MAAM,GAAG,GAAG,aAAa,CAAC,CAAC,CAAC,IAAI,QAAQ,CACvC,KAAK,CAAC,sBAAsB,EAC5B,CAAC,CACD,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,sBAAsB,GAAG,CAAC,oDAAmC,CAAC;IAErF,MAAM,YAAY,GAAG,SAAS,CAAC,eAAe,CAC7C,KAAK,CAAC,aAAa,CAAC,eAAe,EAAE,GAAG,CAAC,CACzC,CAAC;IACF,IAAI,IAAI,YAAY,CAAC;IAErB,MAAM,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;IAC/B,IAAI,gBAAgB,EAAE,CAAC;QACtB,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC;YACrB,OAAO,SAAS,CAAC;QAClB,CAAC;QACD,KAAK,CAAC,KAAK,EAAE,CAAC;IACf,CAAC;IACD,IAAI,aAAa,EAAE,CAAC;QACnB,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC;YACpC,OAAO,SAAS,CAAC;QAClB,CAAC;QACD,KAAK,CAAC,GAAG,EAAE,CAAC;IACb,CAAC;IACD,OAAO,IAAI,aAAa,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AACxC,CAAC;AAED,MAAM,CAAN,IAAY,0BAMX;AAND,WAAY,0BAA0B;IACrC,2EAAI,CAAA;IACJ,+EAAM,CAAA;IACN,+EAAM,CAAA;IACN,2EAAI,CAAA;IACJ,2FAAY,CAAA;AACb,CAAC,EANW,0BAA0B,KAA1B,0BAA0B,QAMrC;AAID,MAAM,UAAU,mBAAmB,CAAC,WAAwB;IAC3D,OAAO,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC;AAED,MAAM,OAAgB,8BAA8B;IACnD,gBAAgB,CAAC;IAIjB,IAAW,cAAc,KAAc,OAAO,KAAK,CAAC,CAAC,CAAC;IACtD,IAAW,cAAc,KAAc,OAAO,KAAK,CAAC,CAAC,CAAC;IAE/C,aAAa,CAAC,WAAwB;QAC5C,OAAO,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC;IACtE,CAAC;IAEM,eAAe,CAAC,WAAwB;QAC9C,OAAO,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC;IACtE,CAAC;IAUM,MAAM,CAAC,WAAwB;QACrC,OAAO,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,CAAC;IACjF,CAAC;IAEM,QAAQ,CAAC,WAAkB;QACjC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,EAAE,CAAC;YACxC,mCAA2B;QAC5B,CAAC;QACD,gCAAwB;IACzB,CAAC;CACD;AAED,MAAM,OAAO,0BAA2B,SAAQ,8BAA8B;IAC7E,IAAa,IAAI,KAAsC,OAAO,0BAA0B,CAAC,IAAI,CAAC,CAAC,CAAC;IAChF,QAAQ,KAAa,OAAO,MAAM,CAAC,CAAC,CAAC;IACrC,IAAI,KAA6B,OAAO,IAAI,CAAC,CAAC,CAAC;IAE/C,cAAc,CAAC,WAAwB,EAAE,KAAc,EAAE,mBAA4B,KAAK;QACzG,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC;YACvB,OAAO,KAAK,CAAC,CAAC,CAAC,IAAI,4BAA4B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;QAC1D,CAAC;aAAM,CAAC;YACP,OAAO,KAAK,CAAC,CAAC,CAAC,IAAI,4BAA4B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;QAC1D,CAAC;IACF,CAAC;IAEe,MAAM,CAAC,KAA6B;QACnD,OAAO,KAAK,CAAC,IAAI,KAAK,0BAA0B,CAAC,IAAI,CAAC;IACvD,CAAC;CACD;AAED,MAAM,OAAO,4BAA6B,SAAQ,8BAA8B;IAC/E,IAAa,IAAI,KAAwC,OAAO,0BAA0B,CAAC,MAAM,CAAC,CAAC,CAAC;IACpG,IAAa,cAAc,KAAc,OAAO,IAAI,CAAC,CAAC,CAAC;IAChD,QAAQ,KAAa,OAAO,IAAI,CAAC,CAAC,CAAC;IAC1B,IAAI,KAA6B,OAAO,IAAI,4BAA4B,EAAE,CAAC,CAAC,CAAC;IAE7E,cAAc,CAAC,WAAwB,EAAE,KAAc,EAAE,mBAA4B,KAAK;QACzG,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC;YACvB,OAAO,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,0BAA0B,EAAE,CAAC;QACxD,CAAC;aAAM,CAAC;YACP,OAAO,KAAK,CAAC,CAAC,CAAC,IAAI,0BAA0B,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC,CAAC,CAAC,IAAI,4BAA4B,EAAE,CAAC;QACzG,CAAC;IACF,CAAC;IAEe,MAAM,CAAC,KAA6B;QACnD,OAAO,KAAK,CAAC,IAAI,KAAK,0BAA0B,CAAC,MAAM,CAAC;IACzD,CAAC;CACD;AAED,MAAM,OAAO,4BAA6B,SAAQ,8BAA8B;IAC/E,IAAa,IAAI,KAAwC,OAAO,0BAA0B,CAAC,MAAM,CAAC,CAAC,CAAC;IACpG,IAAa,cAAc,KAAc,OAAO,IAAI,CAAC,CAAC,CAAC;IAChD,QAAQ,KAAa,OAAO,IAAI,CAAC,CAAC,CAAC;IAC1B,IAAI,KAA6B,OAAO,IAAI,4BAA4B,EAAE,CAAC,CAAC,CAAC;IAEtF,cAAc,CAAC,WAAwB,EAAE,KAAc,EAAE,mBAA4B,KAAK;QAChG,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC;YACvB,OAAO,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,0BAA0B,EAAE,CAAC;QACxD,CAAC;aAAM,CAAC;YACP,OAAO,KAAK,CAAC,CAAC,CAAC,IAAI,0BAA0B,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC,CAAC,CAAC,IAAI,4BAA4B,EAAE,CAAC;QACzG,CAAC;IACF,CAAC;IAEe,MAAM,CAAC,KAA6B;QACnD,OAAO,KAAK,CAAC,IAAI,KAAK,0BAA0B,CAAC,MAAM,CAAC;IACzD,CAAC;CACD;AAED,MAAM,OAAO,0BAA2B,SAAQ,8BAA8B;IAC7E,YACiB,UAAuB,EACvB,gBAAyB;QAEzC,KAAK,EAAE,CAAC;QAHQ,eAAU,GAAV,UAAU,CAAa;QACvB,qBAAgB,GAAhB,gBAAgB,CAAS;IAG1C,CAAC;IAED,IAAa,IAAI,KAAsC,OAAO,0BAA0B,CAAC,IAAI,CAAC,CAAC,CAAC;IAChG,IAAa,cAAc,KAAc,OAAO,IAAI,CAAC,CAAC,CAAC;IACvD,IAAa,cAAc,KAAc,OAAO,IAAI,CAAC,CAAC,CAAC;IAEhD,QAAQ;QACd,OAAO,IAAI,CAAC;IACb,CAAC;IAEe,IAAI,KAA6B,OAAO,IAAI,0BAA0B,CAAC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;IAE/I,cAAc,CAAC,WAAwB,EAAE,KAAc,EAAE,mBAA4B,KAAK;QAChG,IAAI,KAAK,EAAE,CAAC;YACX,OAAO,IAAI,CAAC;QACb,CAAC;QACD,OAAO,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,4BAA4B,EAAE,CAAC,CAAC,CAAC,IAAI,4BAA4B,EAAE,CAAC;IACpG,CAAC;IAEe,MAAM,CAAC,KAA6B;QACnD,OAAO,KAAK,CAAC,IAAI,KAAK,0BAA0B,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,KAAK,KAAK,CAAC,UAAU,IAAI,IAAI,CAAC,gBAAgB,KAAK,KAAK,CAAC,gBAAgB,CAAC;IACnJ,CAAC;IAEe,QAAQ,CAAC,WAAkB;QAC1C,OAAO,WAAW,KAAK,IAAI,CAAC,UAAU,CAAC,CAAC,0BAAkB,CAAC,0BAAkB,CAAC;IAC/E,CAAC;CACD;AAED,MAAM,OAAO,kCAAmC,SAAQ,8BAA8B;IACrF,IAAa,IAAI,KAA8C,OAAO,0BAA0B,CAAC,YAAY,CAAC,CAAC,CAAC;IAChG,QAAQ,KAAa,OAAO,cAAc,CAAC,CAAC,CAAC;IAC7C,IAAI,KAA6B,OAAO,IAAI,CAAC,CAAC,CAAC;IAExD,cAAc,CAAC,WAAwB,EAAE,KAAc,EAAE,mBAA4B,KAAK;QAChG,IAAI,CAAC,KAAK,EAAE,CAAC;YACZ,OAAO,IAAI,CAAC;QACb,CAAC;QACD,OAAO,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,4BAA4B,EAAE,CAAC,CAAC,CAAC,IAAI,4BAA4B,EAAE,CAAC;IACpG,CAAC;IAEe,MAAM,CAAC,KAA6B;QACnD,OAAO,KAAK,CAAC,IAAI,KAAK,0BAA0B,CAAC,YAAY,CAAC;IAC/D,CAAC;CACD;AAID,MAAM,KAAW,sBAAsB,CAGtC;AAHD,WAAiB,sBAAsB;IACzB,2BAAI,GAAG,IAAI,0BAA0B,EAAE,CAAC;IACxC,mCAAY,GAAG,IAAI,kCAAkC,EAAE,CAAC;AACtE,CAAC,EAHgB,sBAAsB,KAAtB,sBAAsB,QAGtC;AAED,MAAM,CAAN,IAAkB,UAKjB;AALD,WAAkB,UAAU;IAC3B,mDAAY,CAAA;IACZ,6CAAS,CAAA;IACT,+CAAU,CAAA;IACV,2DAAgB,CAAA;AACjB,CAAC,EALiB,UAAU,KAAV,UAAU,QAK3B","file":"modifiedBaseRange.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, concatArrays, equals, numberComparator, tieBreakComparators } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Constants } from '../../../../../base/common/uint.js';\nimport { Position } from '../../../../../editor/common/core/position.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { ITextModel } from '../../../../../editor/common/model.js';\nimport { LineRangeEdit, RangeEdit } from './editing.js';\nimport { MergeEditorLineRange } from './lineRange.js';\nimport { DetailedLineRangeMapping, MappingAlignment } from './mapping.js';\n\n/**\n * Describes modifications in input 1 and input 2 for a specific range in base.\n *\n * The UI offers a mechanism to either apply all changes from input 1 or input 2 or both.\n *\n * Immutable.\n*/\nexport class ModifiedBaseRange {\n\tpublic static fromDiffs(\n\t\tdiffs1: readonly DetailedLineRangeMapping[],\n\t\tdiffs2: readonly DetailedLineRangeMapping[],\n\t\tbaseTextModel: ITextModel,\n\t\tinput1TextModel: ITextModel,\n\t\tinput2TextModel: ITextModel\n\t): ModifiedBaseRange[] {\n\t\tconst alignments = MappingAlignment.compute(diffs1, diffs2);\n\t\treturn alignments.map(\n\t\t\t(a) => new ModifiedBaseRange(\n\t\t\t\ta.inputRange,\n\t\t\t\tbaseTextModel,\n\t\t\t\ta.output1Range,\n\t\t\t\tinput1TextModel,\n\t\t\t\ta.output1LineMappings,\n\t\t\t\ta.output2Range,\n\t\t\t\tinput2TextModel,\n\t\t\t\ta.output2LineMappings\n\t\t\t)\n\t\t);\n\t}\n\n\tpublic readonly input1CombinedDiff;\n\tpublic readonly input2CombinedDiff;\n\tpublic readonly isEqualChange;\n\n\tconstructor(\n\t\tpublic readonly baseRange: MergeEditorLineRange,\n\t\tpublic readonly baseTextModel: ITextModel,\n\t\tpublic readonly input1Range: MergeEditorLineRange,\n\t\tpublic readonly input1TextModel: ITextModel,\n\n\t\t/**\n\t\t * From base to input1\n\t\t*/\n\t\tpublic readonly input1Diffs: readonly DetailedLineRangeMapping[],\n\t\tpublic readonly input2Range: MergeEditorLineRange,\n\t\tpublic readonly input2TextModel: ITextModel,\n\n\t\t/**\n\t\t * From base to input2\n\t\t*/\n\t\tpublic readonly input2Diffs: readonly DetailedLineRangeMapping[]\n\t) {\n\t\tthis.input1CombinedDiff = DetailedLineRangeMapping.join(this.input1Diffs);\n\t\tthis.input2CombinedDiff = DetailedLineRangeMapping.join(this.input2Diffs);\n\t\tthis.isEqualChange = equals(this.input1Diffs, this.input2Diffs, (a, b) => a.getLineEdit().equals(b.getLineEdit()));\n\t\tthis.smartInput1LineRangeEdit = null;\n\t\tthis.smartInput2LineRangeEdit = null;\n\t\tthis.dumbInput1LineRangeEdit = null;\n\t\tthis.dumbInput2LineRangeEdit = null;\n\t\tif (this.input1Diffs.length === 0 && this.input2Diffs.length === 0) {\n\t\t\tthrow new BugIndicatingError('must have at least one diff');\n\t\t}\n\t}\n\n\tpublic getInputRange(inputNumber: 1 | 2): MergeEditorLineRange {\n\t\treturn inputNumber === 1 ? this.input1Range : this.input2Range;\n\t}\n\n\tpublic getInputCombinedDiff(inputNumber: 1 | 2): DetailedLineRangeMapping | undefined {\n\t\treturn inputNumber === 1 ? this.input1CombinedDiff : this.input2CombinedDiff;\n\t}\n\n\tpublic getInputDiffs(inputNumber: 1 | 2): readonly DetailedLineRangeMapping[] {\n\t\treturn inputNumber === 1 ? this.input1Diffs : this.input2Diffs;\n\t}\n\n\tpublic get isConflicting(): boolean {\n\t\treturn this.input1Diffs.length > 0 && this.input2Diffs.length > 0;\n\t}\n\n\tpublic get canBeCombined(): boolean {\n\t\treturn this.smartCombineInputs(1) !== undefined;\n\t}\n\n\tpublic get isOrderRelevant(): boolean {\n\t\tconst input1 = this.smartCombineInputs(1);\n\t\tconst input2 = this.smartCombineInputs(2);\n\t\tif (!input1 || !input2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !input1.equals(input2);\n\t}\n\n\tpublic getEditForBase(state: ModifiedBaseRangeState): { edit: LineRangeEdit | undefined; effectiveState: ModifiedBaseRangeState } {\n\t\tconst diffs: { diff: DetailedLineRangeMapping; inputNumber: InputNumber }[] = [];\n\t\tif (state.includesInput1 && this.input1CombinedDiff) {\n\t\t\tdiffs.push({ diff: this.input1CombinedDiff, inputNumber: 1 });\n\t\t}\n\t\tif (state.includesInput2 && this.input2CombinedDiff) {\n\t\t\tdiffs.push({ diff: this.input2CombinedDiff, inputNumber: 2 });\n\t\t}\n\n\t\tif (diffs.length === 0) {\n\t\t\treturn { edit: undefined, effectiveState: ModifiedBaseRangeState.base };\n\t\t}\n\t\tif (diffs.length === 1) {\n\t\t\treturn { edit: diffs[0].diff.getLineEdit(), effectiveState: ModifiedBaseRangeState.base.withInputValue(diffs[0].inputNumber, true, false) };\n\t\t}\n\n\t\tif (state.kind !== ModifiedBaseRangeStateKind.both) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tconst smartCombinedEdit = state.smartCombination ? this.smartCombineInputs(state.firstInput) : this.dumbCombineInputs(state.firstInput);\n\t\tif (smartCombinedEdit) {\n\t\t\treturn { edit: smartCombinedEdit, effectiveState: state };\n\t\t}\n\n\t\treturn {\n\t\t\tedit: diffs[getOtherInputNumber(state.firstInput) - 1].diff.getLineEdit(),\n\t\t\teffectiveState: ModifiedBaseRangeState.base.withInputValue(\n\t\t\t\tgetOtherInputNumber(state.firstInput),\n\t\t\t\ttrue,\n\t\t\t\tfalse\n\t\t\t),\n\t\t};\n\t}\n\n\tprivate smartInput1LineRangeEdit: LineRangeEdit | undefined | null;\n\tprivate smartInput2LineRangeEdit: LineRangeEdit | undefined | null;\n\n\tprivate smartCombineInputs(firstInput: 1 | 2): LineRangeEdit | undefined {\n\t\tif (firstInput === 1 && this.smartInput1LineRangeEdit !== null) {\n\t\t\treturn this.smartInput1LineRangeEdit;\n\t\t} else if (firstInput === 2 && this.smartInput2LineRangeEdit !== null) {\n\t\t\treturn this.smartInput2LineRangeEdit;\n\t\t}\n\n\t\tconst combinedDiffs = concatArrays(\n\t\t\tthis.input1Diffs.flatMap((diffs) =>\n\t\t\t\tdiffs.rangeMappings.map((diff) => ({ diff, input: 1 as const }))\n\t\t\t),\n\t\t\tthis.input2Diffs.flatMap((diffs) =>\n\t\t\t\tdiffs.rangeMappings.map((diff) => ({ diff, input: 2 as const }))\n\t\t\t)\n\t\t).sort(\n\t\t\ttieBreakComparators(\n\t\t\t\tcompareBy((d) => d.diff.inputRange, Range.compareRangesUsingStarts),\n\t\t\t\tcompareBy((d) => (d.input === firstInput ? 1 : 2), numberComparator)\n\t\t\t)\n\t\t);\n\n\t\tconst sortedEdits = combinedDiffs.map(d => {\n\t\t\tconst sourceTextModel = d.input === 1 ? this.input1TextModel : this.input2TextModel;\n\t\t\treturn new RangeEdit(d.diff.inputRange, sourceTextModel.getValueInRange(d.diff.outputRange));\n\t\t});\n\n\t\tconst result = editsToLineRangeEdit(this.baseRange, sortedEdits, this.baseTextModel);\n\t\tif (firstInput === 1) {\n\t\t\tthis.smartInput1LineRangeEdit = result;\n\t\t} else {\n\t\t\tthis.smartInput2LineRangeEdit = result;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate dumbInput1LineRangeEdit: LineRangeEdit | undefined | null;\n\tprivate dumbInput2LineRangeEdit: LineRangeEdit | undefined | null;\n\n\tprivate dumbCombineInputs(firstInput: 1 | 2): LineRangeEdit | undefined {\n\t\tif (firstInput === 1 && this.dumbInput1LineRangeEdit !== null) {\n\t\t\treturn this.dumbInput1LineRangeEdit;\n\t\t} else if (firstInput === 2 && this.dumbInput2LineRangeEdit !== null) {\n\t\t\treturn this.dumbInput2LineRangeEdit;\n\t\t}\n\n\t\tlet input1Lines = this.input1Range.getLines(this.input1TextModel);\n\t\tlet input2Lines = this.input2Range.getLines(this.input2TextModel);\n\t\tif (firstInput === 2) {\n\t\t\t[input1Lines, input2Lines] = [input2Lines, input1Lines];\n\t\t}\n\n\t\tconst result = new LineRangeEdit(this.baseRange, input1Lines.concat(input2Lines));\n\t\tif (firstInput === 1) {\n\t\t\tthis.dumbInput1LineRangeEdit = result;\n\t\t} else {\n\t\t\tthis.dumbInput2LineRangeEdit = result;\n\t\t}\n\t\treturn result;\n\t}\n}\n\nfunction editsToLineRangeEdit(range: MergeEditorLineRange, sortedEdits: RangeEdit[], textModel: ITextModel): LineRangeEdit | undefined {\n\tlet text = '';\n\tconst startsLineBefore = range.startLineNumber > 1;\n\tlet currentPosition = startsLineBefore\n\t\t? new Position(\n\t\t\trange.startLineNumber - 1,\n\t\t\ttextModel.getLineMaxColumn(range.startLineNumber - 1)\n\t\t)\n\t\t: new Position(range.startLineNumber, 1);\n\n\tfor (const edit of sortedEdits) {\n\t\tconst diffStart = edit.range.getStartPosition();\n\t\tif (!currentPosition.isBeforeOrEqual(diffStart)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet originalText = textModel.getValueInRange(Range.fromPositions(currentPosition, diffStart));\n\t\tif (diffStart.lineNumber > textModel.getLineCount()) {\n\t\t\t// assert diffStart.lineNumber === textModel.getLineCount() + 1\n\t\t\t// getValueInRange doesn't include this virtual line break, as the document ends the line before.\n\t\t\t// endsLineAfter will be false.\n\t\t\toriginalText += '\\n';\n\t\t}\n\t\ttext += originalText;\n\t\ttext += edit.newText;\n\t\tcurrentPosition = edit.range.getEndPosition();\n\t}\n\n\tconst endsLineAfter = range.endLineNumberExclusive <= textModel.getLineCount();\n\tconst end = endsLineAfter ? new Position(\n\t\trange.endLineNumberExclusive,\n\t\t1\n\t) : new Position(range.endLineNumberExclusive - 1, Constants.MAX_SAFE_SMALL_INTEGER);\n\n\tconst originalText = textModel.getValueInRange(\n\t\tRange.fromPositions(currentPosition, end)\n\t);\n\ttext += originalText;\n\n\tconst lines = splitLines(text);\n\tif (startsLineBefore) {\n\t\tif (lines[0] !== '') {\n\t\t\treturn undefined;\n\t\t}\n\t\tlines.shift();\n\t}\n\tif (endsLineAfter) {\n\t\tif (lines[lines.length - 1] !== '') {\n\t\t\treturn undefined;\n\t\t}\n\t\tlines.pop();\n\t}\n\treturn new LineRangeEdit(range, lines);\n}\n\nexport enum ModifiedBaseRangeStateKind {\n\tbase,\n\tinput1,\n\tinput2,\n\tboth,\n\tunrecognized,\n}\n\nexport type InputNumber = 1 | 2;\n\nexport function getOtherInputNumber(inputNumber: InputNumber): InputNumber {\n\treturn inputNumber === 1 ? 2 : 1;\n}\n\nexport abstract class AbstractModifiedBaseRangeState {\n\tconstructor() { }\n\n\tabstract get kind(): ModifiedBaseRangeStateKind;\n\n\tpublic get includesInput1(): boolean { return false; }\n\tpublic get includesInput2(): boolean { return false; }\n\n\tpublic includesInput(inputNumber: InputNumber): boolean {\n\t\treturn inputNumber === 1 ? this.includesInput1 : this.includesInput2;\n\t}\n\n\tpublic isInputIncluded(inputNumber: InputNumber): boolean {\n\t\treturn inputNumber === 1 ? this.includesInput1 : this.includesInput2;\n\t}\n\n\tpublic abstract toString(): string;\n\n\tpublic abstract swap(): ModifiedBaseRangeState;\n\n\tpublic abstract withInputValue(inputNumber: InputNumber, value: boolean, smartCombination?: boolean): ModifiedBaseRangeState;\n\n\tpublic abstract equals(other: ModifiedBaseRangeState): boolean;\n\n\tpublic toggle(inputNumber: InputNumber) {\n\t\treturn this.withInputValue(inputNumber, !this.includesInput(inputNumber), true);\n\t}\n\n\tpublic getInput(inputNumber: 1 | 2): InputState {\n\t\tif (!this.isInputIncluded(inputNumber)) {\n\t\t\treturn InputState.excluded;\n\t\t}\n\t\treturn InputState.first;\n\t}\n}\n\nexport class ModifiedBaseRangeStateBase extends AbstractModifiedBaseRangeState {\n\toverride get kind(): ModifiedBaseRangeStateKind.base { return ModifiedBaseRangeStateKind.base; }\n\tpublic override toString(): string { return 'base'; }\n\tpublic override swap(): ModifiedBaseRangeState { return this; }\n\n\tpublic override withInputValue(inputNumber: InputNumber, value: boolean, smartCombination: boolean = false): ModifiedBaseRangeState {\n\t\tif (inputNumber === 1) {\n\t\t\treturn value ? new ModifiedBaseRangeStateInput1() : this;\n\t\t} else {\n\t\t\treturn value ? new ModifiedBaseRangeStateInput2() : this;\n\t\t}\n\t}\n\n\tpublic override equals(other: ModifiedBaseRangeState): boolean {\n\t\treturn other.kind === ModifiedBaseRangeStateKind.base;\n\t}\n}\n\nexport class ModifiedBaseRangeStateInput1 extends AbstractModifiedBaseRangeState {\n\toverride get kind(): ModifiedBaseRangeStateKind.input1 { return ModifiedBaseRangeStateKind.input1; }\n\toverride get includesInput1(): boolean { return true; }\n\tpublic toString(): string { return '1✓'; }\n\tpublic override swap(): ModifiedBaseRangeState { return new ModifiedBaseRangeStateInput2(); }\n\n\tpublic override withInputValue(inputNumber: InputNumber, value: boolean, smartCombination: boolean = false): ModifiedBaseRangeState {\n\t\tif (inputNumber === 1) {\n\t\t\treturn value ? this : new ModifiedBaseRangeStateBase();\n\t\t} else {\n\t\t\treturn value ? new ModifiedBaseRangeStateBoth(1, smartCombination) : new ModifiedBaseRangeStateInput2();\n\t\t}\n\t}\n\n\tpublic override equals(other: ModifiedBaseRangeState): boolean {\n\t\treturn other.kind === ModifiedBaseRangeStateKind.input1;\n\t}\n}\n\nexport class ModifiedBaseRangeStateInput2 extends AbstractModifiedBaseRangeState {\n\toverride get kind(): ModifiedBaseRangeStateKind.input2 { return ModifiedBaseRangeStateKind.input2; }\n\toverride get includesInput2(): boolean { return true; }\n\tpublic toString(): string { return '2✓'; }\n\tpublic override swap(): ModifiedBaseRangeState { return new ModifiedBaseRangeStateInput1(); }\n\n\tpublic withInputValue(inputNumber: InputNumber, value: boolean, smartCombination: boolean = false): ModifiedBaseRangeState {\n\t\tif (inputNumber === 2) {\n\t\t\treturn value ? this : new ModifiedBaseRangeStateBase();\n\t\t} else {\n\t\t\treturn value ? new ModifiedBaseRangeStateBoth(2, smartCombination) : new ModifiedBaseRangeStateInput2();\n\t\t}\n\t}\n\n\tpublic override equals(other: ModifiedBaseRangeState): boolean {\n\t\treturn other.kind === ModifiedBaseRangeStateKind.input2;\n\t}\n}\n\nexport class ModifiedBaseRangeStateBoth extends AbstractModifiedBaseRangeState {\n\tconstructor(\n\t\tpublic readonly firstInput: InputNumber,\n\t\tpublic readonly smartCombination: boolean\n\t) {\n\t\tsuper();\n\t}\n\n\toverride get kind(): ModifiedBaseRangeStateKind.both { return ModifiedBaseRangeStateKind.both; }\n\toverride get includesInput1(): boolean { return true; }\n\toverride get includesInput2(): boolean { return true; }\n\n\tpublic toString(): string {\n\t\treturn '2✓';\n\t}\n\n\tpublic override swap(): ModifiedBaseRangeState { return new ModifiedBaseRangeStateBoth(getOtherInputNumber(this.firstInput), this.smartCombination); }\n\n\tpublic withInputValue(inputNumber: InputNumber, value: boolean, smartCombination: boolean = false): ModifiedBaseRangeState {\n\t\tif (value) {\n\t\t\treturn this;\n\t\t}\n\t\treturn inputNumber === 1 ? new ModifiedBaseRangeStateInput2() : new ModifiedBaseRangeStateInput1();\n\t}\n\n\tpublic override equals(other: ModifiedBaseRangeState): boolean {\n\t\treturn other.kind === ModifiedBaseRangeStateKind.both && this.firstInput === other.firstInput && this.smartCombination === other.smartCombination;\n\t}\n\n\tpublic override getInput(inputNumber: 1 | 2): InputState {\n\t\treturn inputNumber === this.firstInput ? InputState.first : InputState.second;\n\t}\n}\n\nexport class ModifiedBaseRangeStateUnrecognized extends AbstractModifiedBaseRangeState {\n\toverride get kind(): ModifiedBaseRangeStateKind.unrecognized { return ModifiedBaseRangeStateKind.unrecognized; }\n\tpublic override toString(): string { return 'unrecognized'; }\n\tpublic override swap(): ModifiedBaseRangeState { return this; }\n\n\tpublic withInputValue(inputNumber: InputNumber, value: boolean, smartCombination: boolean = false): ModifiedBaseRangeState {\n\t\tif (!value) {\n\t\t\treturn this;\n\t\t}\n\t\treturn inputNumber === 1 ? new ModifiedBaseRangeStateInput1() : new ModifiedBaseRangeStateInput2();\n\t}\n\n\tpublic override equals(other: ModifiedBaseRangeState): boolean {\n\t\treturn other.kind === ModifiedBaseRangeStateKind.unrecognized;\n\t}\n}\n\nexport type ModifiedBaseRangeState = ModifiedBaseRangeStateBase | ModifiedBaseRangeStateInput1 | ModifiedBaseRangeStateInput2 | ModifiedBaseRangeStateInput2 | ModifiedBaseRangeStateBoth | ModifiedBaseRangeStateUnrecognized;\n\nexport namespace ModifiedBaseRangeState {\n\texport const base = new ModifiedBaseRangeStateBase();\n\texport const unrecognized = new ModifiedBaseRangeStateUnrecognized();\n}\n\nexport const enum InputState {\n\texcluded = 0,\n\tfirst = 1,\n\tsecond = 2,\n\tunrecognized = 3\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, concatArrays, equals, numberComparator, tieBreakComparators } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Constants } from '../../../../../base/common/uint.js';\nimport { Position } from '../../../../../editor/common/core/position.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { ITextModel } from '../../../../../editor/common/model.js';\nimport { LineRangeEdit, RangeEdit } from './editing.js';\nimport { MergeEditorLineRange } from './lineRange.js';\nimport { DetailedLineRangeMapping, MappingAlignment } from './mapping.js';\n\n/**\n * Describes modifications in input 1 and input 2 for a specific range in base.\n *\n * The UI offers a mechanism to either apply all changes from input 1 or input 2 or both.\n *\n * Immutable.\n*/\nexport class ModifiedBaseRange {\n\tpublic static fromDiffs(\n\t\tdiffs1: readonly DetailedLineRangeMapping[],\n\t\tdiffs2: readonly DetailedLineRangeMapping[],\n\t\tbaseTextModel: ITextModel,\n\t\tinput1TextModel: ITextModel,\n\t\tinput2TextModel: ITextModel\n\t): ModifiedBaseRange[] {\n\t\tconst alignments = MappingAlignment.compute(diffs1, diffs2);\n\t\treturn alignments.map(\n\t\t\t(a) => new ModifiedBaseRange(\n\t\t\t\ta.inputRange,\n\t\t\t\tbaseTextModel,\n\t\t\t\ta.output1Range,\n\t\t\t\tinput1TextModel,\n\t\t\t\ta.output1LineMappings,\n\t\t\t\ta.output2Range,\n\t\t\t\tinput2TextModel,\n\t\t\t\ta.output2LineMappings\n\t\t\t)\n\t\t);\n\t}\n\n\tpublic readonly input1CombinedDiff;\n\tpublic readonly input2CombinedDiff;\n\tpublic readonly isEqualChange;\n\n\tconstructor(\n\t\tpublic readonly baseRange: MergeEditorLineRange,\n\t\tpublic readonly baseTextModel: ITextModel,\n\t\tpublic readonly input1Range: MergeEditorLineRange,\n\t\tpublic readonly input1TextModel: ITextModel,\n\n\t\t/**\n\t\t * From base to input1\n\t\t*/\n\t\tpublic readonly input1Diffs: readonly DetailedLineRangeMapping[],\n\t\tpublic readonly input2Range: MergeEditorLineRange,\n\t\tpublic readonly input2TextModel: ITextModel,\n\n\t\t/**\n\t\t * From base to input2\n\t\t*/\n\t\tpublic readonly input2Diffs: readonly DetailedLineRangeMapping[]\n\t) {\n\t\tthis.input1CombinedDiff = DetailedLineRangeMapping.join(this.input1Diffs);\n\t\tthis.input2CombinedDiff = DetailedLineRangeMapping.join(this.input2Diffs);\n\t\tthis.isEqualChange = equals(this.input1Diffs, this.input2Diffs, (a, b) => a.getLineEdit().equals(b.getLineEdit()));\n\t\tthis.smartInput1LineRangeEdit = null;\n\t\tthis.smartInput2LineRangeEdit = null;\n\t\tthis.dumbInput1LineRangeEdit = null;\n\t\tthis.dumbInput2LineRangeEdit = null;\n\t\tif (this.input1Diffs.length === 0 && this.input2Diffs.length === 0) {\n\t\t\tthrow new BugIndicatingError('must have at least one diff');\n\t\t}\n\t}\n\n\tpublic getInputRange(inputNumber: 1 | 2): MergeEditorLineRange {\n\t\treturn inputNumber === 1 ? this.input1Range : this.input2Range;\n\t}\n\n\tpublic getInputCombinedDiff(inputNumber: 1 | 2): DetailedLineRangeMapping | undefined {\n\t\treturn inputNumber === 1 ? this.input1CombinedDiff : this.input2CombinedDiff;\n\t}\n\n\tpublic getInputDiffs(inputNumber: 1 | 2): readonly DetailedLineRangeMapping[] {\n\t\treturn inputNumber === 1 ? this.input1Diffs : this.input2Diffs;\n\t}\n\n\tpublic get isConflicting(): boolean {\n\t\treturn this.input1Diffs.length > 0 && this.input2Diffs.length > 0;\n\t}\n\n\tpublic get canBeCombined(): boolean {\n\t\treturn this.smartCombineInputs(1) !== undefined;\n\t}\n\n\tpublic get isOrderRelevant(): boolean {\n\t\tconst input1 = this.smartCombineInputs(1);\n\t\tconst input2 = this.smartCombineInputs(2);\n\t\tif (!input1 || !input2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !input1.equals(input2);\n\t}\n\n\tpublic getEditForBase(state: ModifiedBaseRangeState): { edit: LineRangeEdit | undefined; effectiveState: ModifiedBaseRangeState } {\n\t\tconst diffs: { diff: DetailedLineRangeMapping; inputNumber: InputNumber }[] = [];\n\t\tif (state.includesInput1 && this.input1CombinedDiff) {\n\t\t\tdiffs.push({ diff: this.input1CombinedDiff, inputNumber: 1 });\n\t\t}\n\t\tif (state.includesInput2 && this.input2CombinedDiff) {\n\t\t\tdiffs.push({ diff: this.input2CombinedDiff, inputNumber: 2 });\n\t\t}\n\n\t\tif (diffs.length === 0) {\n\t\t\treturn { edit: undefined, effectiveState: ModifiedBaseRangeState.base };\n\t\t}\n\t\tif (diffs.length === 1) {\n\t\t\treturn { edit: diffs[0].diff.getLineEdit(), effectiveState: ModifiedBaseRangeState.base.withInputValue(diffs[0].inputNumber, true, false) };\n\t\t}\n\n\t\tif (state.kind !== ModifiedBaseRangeStateKind.both) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tconst smartCombinedEdit = state.smartCombination ? this.smartCombineInputs(state.firstInput) : this.dumbCombineInputs(state.firstInput);\n\t\tif (smartCombinedEdit) {\n\t\t\treturn { edit: smartCombinedEdit, effectiveState: state };\n\t\t}\n\n\t\treturn {\n\t\t\tedit: diffs[getOtherInputNumber(state.firstInput) - 1].diff.getLineEdit(),\n\t\t\teffectiveState: ModifiedBaseRangeState.base.withInputValue(\n\t\t\t\tgetOtherInputNumber(state.firstInput),\n\t\t\t\ttrue,\n\t\t\t\tfalse\n\t\t\t),\n\t\t};\n\t}\n\n\tprivate smartInput1LineRangeEdit: LineRangeEdit | undefined | null;\n\tprivate smartInput2LineRangeEdit: LineRangeEdit | undefined | null;\n\n\tprivate smartCombineInputs(firstInput: 1 | 2): LineRangeEdit | undefined {\n\t\tif (firstInput === 1 && this.smartInput1LineRangeEdit !== null) {\n\t\t\treturn this.smartInput1LineRangeEdit;\n\t\t} else if (firstInput === 2 && this.smartInput2LineRangeEdit !== null) {\n\t\t\treturn this.smartInput2LineRangeEdit;\n\t\t}\n\n\t\tconst combinedDiffs = concatArrays(\n\t\t\tthis.input1Diffs.flatMap((diffs) =>\n\t\t\t\tdiffs.rangeMappings.map((diff) => ({ diff, input: 1 as const }))\n\t\t\t),\n\t\t\tthis.input2Diffs.flatMap((diffs) =>\n\t\t\t\tdiffs.rangeMappings.map((diff) => ({ diff, input: 2 as const }))\n\t\t\t)\n\t\t).sort(\n\t\t\ttieBreakComparators(\n\t\t\t\tcompareBy((d) => d.diff.inputRange, Range.compareRangesUsingStarts),\n\t\t\t\tcompareBy((d) => (d.input === firstInput ? 1 : 2), numberComparator)\n\t\t\t)\n\t\t);\n\n\t\tconst sortedEdits = combinedDiffs.map(d => {\n\t\t\tconst sourceTextModel = d.input === 1 ? this.input1TextModel : this.input2TextModel;\n\t\t\treturn new RangeEdit(d.diff.inputRange, sourceTextModel.getValueInRange(d.diff.outputRange));\n\t\t});\n\n\t\tconst result = editsToLineRangeEdit(this.baseRange, sortedEdits, this.baseTextModel);\n\t\tif (firstInput === 1) {\n\t\t\tthis.smartInput1LineRangeEdit = result;\n\t\t} else {\n\t\t\tthis.smartInput2LineRangeEdit = result;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate dumbInput1LineRangeEdit: LineRangeEdit | undefined | null;\n\tprivate dumbInput2LineRangeEdit: LineRangeEdit | undefined | null;\n\n\tprivate dumbCombineInputs(firstInput: 1 | 2): LineRangeEdit | undefined {\n\t\tif (firstInput === 1 && this.dumbInput1LineRangeEdit !== null) {\n\t\t\treturn this.dumbInput1LineRangeEdit;\n\t\t} else if (firstInput === 2 && this.dumbInput2LineRangeEdit !== null) {\n\t\t\treturn this.dumbInput2LineRangeEdit;\n\t\t}\n\n\t\tlet input1Lines = this.input1Range.getLines(this.input1TextModel);\n\t\tlet input2Lines = this.input2Range.getLines(this.input2TextModel);\n\t\tif (firstInput === 2) {\n\t\t\t[input1Lines, input2Lines] = [input2Lines, input1Lines];\n\t\t}\n\n\t\tconst result = new LineRangeEdit(this.baseRange, input1Lines.concat(input2Lines));\n\t\tif (firstInput === 1) {\n\t\t\tthis.dumbInput1LineRangeEdit = result;\n\t\t} else {\n\t\t\tthis.dumbInput2LineRangeEdit = result;\n\t\t}\n\t\treturn result;\n\t}\n}\n\nfunction editsToLineRangeEdit(range: MergeEditorLineRange, sortedEdits: RangeEdit[], textModel: ITextModel): LineRangeEdit | undefined {\n\tlet text = '';\n\tconst startsLineBefore = range.startLineNumber > 1;\n\tlet currentPosition = startsLineBefore\n\t\t? new Position(\n\t\t\trange.startLineNumber - 1,\n\t\t\ttextModel.getLineMaxColumn(range.startLineNumber - 1)\n\t\t)\n\t\t: new Position(range.startLineNumber, 1);\n\n\tfor (const edit of sortedEdits) {\n\t\tconst diffStart = edit.range.getStartPosition();\n\t\tif (!currentPosition.isBeforeOrEqual(diffStart)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet originalText = textModel.getValueInRange(Range.fromPositions(currentPosition, diffStart));\n\t\tif (diffStart.lineNumber > textModel.getLineCount()) {\n\t\t\t// assert diffStart.lineNumber === textModel.getLineCount() + 1\n\t\t\t// getValueInRange doesn't include this virtual line break, as the document ends the line before.\n\t\t\t// endsLineAfter will be false.\n\t\t\toriginalText += '\\n';\n\t\t}\n\t\ttext += originalText;\n\t\ttext += edit.newText;\n\t\tcurrentPosition = edit.range.getEndPosition();\n\t}\n\n\tconst endsLineAfter = range.endLineNumberExclusive <= textModel.getLineCount();\n\tconst end = endsLineAfter ? new Position(\n\t\trange.endLineNumberExclusive,\n\t\t1\n\t) : new Position(range.endLineNumberExclusive - 1, Constants.MAX_SAFE_SMALL_INTEGER);\n\n\tconst originalText = textModel.getValueInRange(\n\t\tRange.fromPositions(currentPosition, end)\n\t);\n\ttext += originalText;\n\n\tconst lines = splitLines(text);\n\tif (startsLineBefore) {\n\t\tif (lines[0] !== '') {\n\t\t\treturn undefined;\n\t\t}\n\t\tlines.shift();\n\t}\n\tif (endsLineAfter) {\n\t\tif (lines[lines.length - 1] !== '') {\n\t\t\treturn undefined;\n\t\t}\n\t\tlines.pop();\n\t}\n\treturn new LineRangeEdit(range, lines);\n}\n\nexport enum ModifiedBaseRangeStateKind {\n\tbase,\n\tinput1,\n\tinput2,\n\tboth,\n\tunrecognized,\n}\n\nexport type InputNumber = 1 | 2;\n\nexport function getOtherInputNumber(inputNumber: InputNumber): InputNumber {\n\treturn inputNumber === 1 ? 2 : 1;\n}\n\nexport abstract class AbstractModifiedBaseRangeState {\n\tconstructor() { }\n\n\tabstract get kind(): ModifiedBaseRangeStateKind;\n\n\tpublic get includesInput1(): boolean { return false; }\n\tpublic get includesInput2(): boolean { return false; }\n\n\tpublic includesInput(inputNumber: InputNumber): boolean {\n\t\treturn inputNumber === 1 ? this.includesInput1 : this.includesInput2;\n\t}\n\n\tpublic isInputIncluded(inputNumber: InputNumber): boolean {\n\t\treturn inputNumber === 1 ? this.includesInput1 : this.includesInput2;\n\t}\n\n\tpublic abstract toString(): string;\n\n\tpublic abstract swap(): ModifiedBaseRangeState;\n\n\tpublic abstract withInputValue(inputNumber: InputNumber, value: boolean, smartCombination?: boolean): ModifiedBaseRangeState;\n\n\tpublic abstract equals(other: ModifiedBaseRangeState): boolean;\n\n\tpublic toggle(inputNumber: InputNumber) {\n\t\treturn this.withInputValue(inputNumber, !this.includesInput(inputNumber), true);\n\t}\n\n\tpublic getInput(inputNumber: 1 | 2): InputState {\n\t\tif (!this.isInputIncluded(inputNumber)) {\n\t\t\treturn InputState.excluded;\n\t\t}\n\t\treturn InputState.first;\n\t}\n}\n\nexport class ModifiedBaseRangeStateBase extends AbstractModifiedBaseRangeState {\n\toverride get kind(): ModifiedBaseRangeStateKind.base { return ModifiedBaseRangeStateKind.base; }\n\tpublic override toString(): string { return 'base'; }\n\tpublic override swap(): ModifiedBaseRangeState { return this; }\n\n\tpublic override withInputValue(inputNumber: InputNumber, value: boolean, smartCombination: boolean = false): ModifiedBaseRangeState {\n\t\tif (inputNumber === 1) {\n\t\t\treturn value ? new ModifiedBaseRangeStateInput1() : this;\n\t\t} else {\n\t\t\treturn value ? new ModifiedBaseRangeStateInput2() : this;\n\t\t}\n\t}\n\n\tpublic override equals(other: ModifiedBaseRangeState): boolean {\n\t\treturn other.kind === ModifiedBaseRangeStateKind.base;\n\t}\n}\n\nexport class ModifiedBaseRangeStateInput1 extends AbstractModifiedBaseRangeState {\n\toverride get kind(): ModifiedBaseRangeStateKind.input1 { return ModifiedBaseRangeStateKind.input1; }\n\toverride get includesInput1(): boolean { return true; }\n\tpublic toString(): string { return '1✓'; }\n\tpublic override swap(): ModifiedBaseRangeState { return new ModifiedBaseRangeStateInput2(); }\n\n\tpublic override withInputValue(inputNumber: InputNumber, value: boolean, smartCombination: boolean = false): ModifiedBaseRangeState {\n\t\tif (inputNumber === 1) {\n\t\t\treturn value ? this : new ModifiedBaseRangeStateBase();\n\t\t} else {\n\t\t\treturn value ? new ModifiedBaseRangeStateBoth(1, smartCombination) : new ModifiedBaseRangeStateInput2();\n\t\t}\n\t}\n\n\tpublic override equals(other: ModifiedBaseRangeState): boolean {\n\t\treturn other.kind === ModifiedBaseRangeStateKind.input1;\n\t}\n}\n\nexport class ModifiedBaseRangeStateInput2 extends AbstractModifiedBaseRangeState {\n\toverride get kind(): ModifiedBaseRangeStateKind.input2 { return ModifiedBaseRangeStateKind.input2; }\n\toverride get includesInput2(): boolean { return true; }\n\tpublic toString(): string { return '2✓'; }\n\tpublic override swap(): ModifiedBaseRangeState { return new ModifiedBaseRangeStateInput1(); }\n\n\tpublic withInputValue(inputNumber: InputNumber, value: boolean, smartCombination: boolean = false): ModifiedBaseRangeState {\n\t\tif (inputNumber === 2) {\n\t\t\treturn value ? this : new ModifiedBaseRangeStateBase();\n\t\t} else {\n\t\t\treturn value ? new ModifiedBaseRangeStateBoth(2, smartCombination) : new ModifiedBaseRangeStateInput2();\n\t\t}\n\t}\n\n\tpublic override equals(other: ModifiedBaseRangeState): boolean {\n\t\treturn other.kind === ModifiedBaseRangeStateKind.input2;\n\t}\n}\n\nexport class ModifiedBaseRangeStateBoth extends AbstractModifiedBaseRangeState {\n\tconstructor(\n\t\tpublic readonly firstInput: InputNumber,\n\t\tpublic readonly smartCombination: boolean\n\t) {\n\t\tsuper();\n\t}\n\n\toverride get kind(): ModifiedBaseRangeStateKind.both { return ModifiedBaseRangeStateKind.both; }\n\toverride get includesInput1(): boolean { return true; }\n\toverride get includesInput2(): boolean { return true; }\n\n\tpublic toString(): string {\n\t\treturn '2✓';\n\t}\n\n\tpublic override swap(): ModifiedBaseRangeState { return new ModifiedBaseRangeStateBoth(getOtherInputNumber(this.firstInput), this.smartCombination); }\n\n\tpublic withInputValue(inputNumber: InputNumber, value: boolean, smartCombination: boolean = false): ModifiedBaseRangeState {\n\t\tif (value) {\n\t\t\treturn this;\n\t\t}\n\t\treturn inputNumber === 1 ? new ModifiedBaseRangeStateInput2() : new ModifiedBaseRangeStateInput1();\n\t}\n\n\tpublic override equals(other: ModifiedBaseRangeState): boolean {\n\t\treturn other.kind === ModifiedBaseRangeStateKind.both && this.firstInput === other.firstInput && this.smartCombination === other.smartCombination;\n\t}\n\n\tpublic override getInput(inputNumber: 1 | 2): InputState {\n\t\treturn inputNumber === this.firstInput ? InputState.first : InputState.second;\n\t}\n}\n\nexport class ModifiedBaseRangeStateUnrecognized extends AbstractModifiedBaseRangeState {\n\toverride get kind(): ModifiedBaseRangeStateKind.unrecognized { return ModifiedBaseRangeStateKind.unrecognized; }\n\tpublic override toString(): string { return 'unrecognized'; }\n\tpublic override swap(): ModifiedBaseRangeState { return this; }\n\n\tpublic withInputValue(inputNumber: InputNumber, value: boolean, smartCombination: boolean = false): ModifiedBaseRangeState {\n\t\tif (!value) {\n\t\t\treturn this;\n\t\t}\n\t\treturn inputNumber === 1 ? new ModifiedBaseRangeStateInput1() : new ModifiedBaseRangeStateInput2();\n\t}\n\n\tpublic override equals(other: ModifiedBaseRangeState): boolean {\n\t\treturn other.kind === ModifiedBaseRangeStateKind.unrecognized;\n\t}\n}\n\nexport type ModifiedBaseRangeState = ModifiedBaseRangeStateBase | ModifiedBaseRangeStateInput1 | ModifiedBaseRangeStateInput2 | ModifiedBaseRangeStateInput2 | ModifiedBaseRangeStateBoth | ModifiedBaseRangeStateUnrecognized;\n\nexport namespace ModifiedBaseRangeState {\n\texport const base = new ModifiedBaseRangeStateBase();\n\texport const unrecognized = new ModifiedBaseRangeStateUnrecognized();\n}\n\nexport const enum InputState {\n\texcluded = 0,\n\tfirst = 1,\n\tsecond = 2,\n\tunrecognized = 3\n}\n"]}