{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/tasks/browser/taskProblemMonitor.ts","vs/workbench/contrib/tasks/browser/taskProblemMonitor.ts"],"names":[],"mappings":"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","file":"taskProblemMonitor.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { AbstractProblemCollector } from '../common/problemCollectors.js';\nimport { ITerminalInstance } from '../../terminal/browser/terminal.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IMarkerData, MarkerSeverity, IMarker as ITaskMarker } from '../../../../platform/markers/common/markers.js';\n\ninterface ITerminalMarkerData {\n\treadonly resources: Map<string, URI>;\n\treadonly markers: Map<string, Map<string, IMarkerData>>;\n}\n\nexport class TaskProblemMonitor extends Disposable {\n\n\tprivate readonly terminalMarkerMap: Map<number, ITerminalMarkerData> = new Map();\n\tprivate readonly terminalDisposables: Map<number, DisposableStore> = new Map();\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\taddTerminal(terminal: ITerminalInstance, problemMatcher: AbstractProblemCollector) {\n\t\tthis.terminalMarkerMap.set(terminal.instanceId, {\n\t\t\tresources: new Map<string, URI>(),\n\t\t\tmarkers: new Map<string, Map<string, IMarkerData>>()\n\t\t});\n\n\t\tconst store = new DisposableStore();\n\t\tthis.terminalDisposables.set(terminal.instanceId, store);\n\n\t\tstore.add(terminal.onDisposed(() => {\n\t\t\tthis.terminalMarkerMap.delete(terminal.instanceId);\n\t\t\tthis.terminalDisposables.get(terminal.instanceId)?.dispose();\n\t\t\tthis.terminalDisposables.delete(terminal.instanceId);\n\t\t}));\n\n\t\tstore.add(problemMatcher.onDidFindErrors((markers: ITaskMarker[]) => {\n\t\t\tconst markerData = this.terminalMarkerMap.get(terminal.instanceId);\n\t\t\tif (markerData) {\n\t\t\t\t// Clear existing markers for a new set, otherwise older compilation\n\t\t\t\t// issues will be included\n\t\t\t\tmarkerData.markers.clear();\n\t\t\t\tmarkerData.resources.clear();\n\n\t\t\t\tfor (const marker of markers) {\n\t\t\t\t\tif (marker.severity === MarkerSeverity.Error) {\n\t\t\t\t\t\tmarkerData.resources.set(marker.resource.toString(), marker.resource);\n\t\t\t\t\t\tconst markersForOwner = markerData.markers.get(marker.owner);\n\t\t\t\t\t\tlet markerMap = markersForOwner;\n\t\t\t\t\t\tif (!markerMap) {\n\t\t\t\t\t\t\tmarkerMap = new Map();\n\t\t\t\t\t\t\tmarkerData.markers.set(marker.owner, markerMap);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmarkerMap.set(marker.resource.toString(), marker);\n\t\t\t\t\t\tthis.terminalMarkerMap.set(terminal.instanceId, markerData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\tstore.add(problemMatcher.onDidRequestInvalidateLastMarker(() => {\n\t\t\tconst markerData = this.terminalMarkerMap.get(terminal.instanceId);\n\t\t\tmarkerData?.markers.clear();\n\t\t\tmarkerData?.resources.clear();\n\t\t\tthis.terminalMarkerMap.set(terminal.instanceId, {\n\t\t\t\tresources: new Map<string, URI>(),\n\t\t\t\tmarkers: new Map<string, Map<string, IMarkerData>>()\n\t\t\t});\n\t\t}));\n\t}\n\n\t/**\n\t * Gets the task problems for a specific terminal instance\n\t * @param instanceId The terminal instance ID\n\t * @returns Map of problem matchers to their resources and marker data, or undefined if no problems found\n\t */\n\tpublic getTaskProblems(instanceId: number): Map<string, { resources: URI[]; markers: IMarkerData[] }> | undefined {\n\t\tconst markerData = this.terminalMarkerMap.get(instanceId);\n\t\tif (!markerData) {\n\t\t\treturn undefined;\n\t\t} else if (markerData.markers.size === 0) {\n\t\t\treturn new Map();\n\t\t}\n\n\t\tconst result = new Map<string, { resources: URI[]; markers: IMarkerData[] }>();\n\t\tfor (const [owner, markersMap] of markerData.markers) {\n\t\t\tconst resources: URI[] = [];\n\t\t\tconst markers: IMarkerData[] = [];\n\t\t\tfor (const [resource, marker] of markersMap) {\n\t\t\t\tresources.push(markerData.resources.get(resource)!);\n\t\t\t\tmarkers.push(marker);\n\t\t\t}\n\t\t\tresult.set(owner, { resources, markers });\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { AbstractProblemCollector } from '../common/problemCollectors.js';\nimport { ITerminalInstance } from '../../terminal/browser/terminal.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IMarkerData, MarkerSeverity, IMarker as ITaskMarker } from '../../../../platform/markers/common/markers.js';\n\ninterface ITerminalMarkerData {\n\treadonly resources: Map<string, URI>;\n\treadonly markers: Map<string, Map<string, IMarkerData>>;\n}\n\nexport class TaskProblemMonitor extends Disposable {\n\n\tprivate readonly terminalMarkerMap: Map<number, ITerminalMarkerData> = new Map();\n\tprivate readonly terminalDisposables: Map<number, DisposableStore> = new Map();\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\taddTerminal(terminal: ITerminalInstance, problemMatcher: AbstractProblemCollector) {\n\t\tthis.terminalMarkerMap.set(terminal.instanceId, {\n\t\t\tresources: new Map<string, URI>(),\n\t\t\tmarkers: new Map<string, Map<string, IMarkerData>>()\n\t\t});\n\n\t\tconst store = new DisposableStore();\n\t\tthis.terminalDisposables.set(terminal.instanceId, store);\n\n\t\tstore.add(terminal.onDisposed(() => {\n\t\t\tthis.terminalMarkerMap.delete(terminal.instanceId);\n\t\t\tthis.terminalDisposables.get(terminal.instanceId)?.dispose();\n\t\t\tthis.terminalDisposables.delete(terminal.instanceId);\n\t\t}));\n\n\t\tstore.add(problemMatcher.onDidFindErrors((markers: ITaskMarker[]) => {\n\t\t\tconst markerData = this.terminalMarkerMap.get(terminal.instanceId);\n\t\t\tif (markerData) {\n\t\t\t\t// Clear existing markers for a new set, otherwise older compilation\n\t\t\t\t// issues will be included\n\t\t\t\tmarkerData.markers.clear();\n\t\t\t\tmarkerData.resources.clear();\n\n\t\t\t\tfor (const marker of markers) {\n\t\t\t\t\tif (marker.severity === MarkerSeverity.Error) {\n\t\t\t\t\t\tmarkerData.resources.set(marker.resource.toString(), marker.resource);\n\t\t\t\t\t\tconst markersForOwner = markerData.markers.get(marker.owner);\n\t\t\t\t\t\tlet markerMap = markersForOwner;\n\t\t\t\t\t\tif (!markerMap) {\n\t\t\t\t\t\t\tmarkerMap = new Map();\n\t\t\t\t\t\t\tmarkerData.markers.set(marker.owner, markerMap);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmarkerMap.set(marker.resource.toString(), marker);\n\t\t\t\t\t\tthis.terminalMarkerMap.set(terminal.instanceId, markerData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\tstore.add(problemMatcher.onDidRequestInvalidateLastMarker(() => {\n\t\t\tconst markerData = this.terminalMarkerMap.get(terminal.instanceId);\n\t\t\tmarkerData?.markers.clear();\n\t\t\tmarkerData?.resources.clear();\n\t\t\tthis.terminalMarkerMap.set(terminal.instanceId, {\n\t\t\t\tresources: new Map<string, URI>(),\n\t\t\t\tmarkers: new Map<string, Map<string, IMarkerData>>()\n\t\t\t});\n\t\t}));\n\t}\n\n\t/**\n\t * Gets the task problems for a specific terminal instance\n\t * @param instanceId The terminal instance ID\n\t * @returns Map of problem matchers to their resources and marker data, or undefined if no problems found\n\t */\n\tpublic getTaskProblems(instanceId: number): Map<string, { resources: URI[]; markers: IMarkerData[] }> | undefined {\n\t\tconst markerData = this.terminalMarkerMap.get(instanceId);\n\t\tif (!markerData) {\n\t\t\treturn undefined;\n\t\t} else if (markerData.markers.size === 0) {\n\t\t\treturn new Map();\n\t\t}\n\n\t\tconst result = new Map<string, { resources: URI[]; markers: IMarkerData[] }>();\n\t\tfor (const [owner, markersMap] of markerData.markers) {\n\t\t\tconst resources: URI[] = [];\n\t\t\tconst markers: IMarkerData[] = [];\n\t\t\tfor (const [resource, marker] of markersMap) {\n\t\t\t\tresources.push(markerData.resources.get(resource)!);\n\t\t\t\tmarkers.push(marker);\n\t\t\t}\n\t\t\tresult.set(owner, { resources, markers });\n\t\t}\n\t\treturn result;\n\t}\n}\n"]}