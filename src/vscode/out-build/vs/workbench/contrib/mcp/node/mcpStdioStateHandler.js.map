{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/node/mcpStdioStateHandler.ts","vs/workbench/contrib/mcp/node/mcpStdioStateHandler.ts"],"names":[],"mappings":"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","file":"mcpStdioStateHandler.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcessWithoutNullStreams } from 'child_process';\nimport { TimeoutTimer } from '../../../../base/common/async.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { killTree } from '../../../../base/node/processes.js';\nimport { isWindows } from '../../../../base/common/platform.js';\n\nconst enum McpProcessState {\n\tRunning,\n\tStdinEnded,\n\tKilledPolite,\n\tKilledForceful,\n}\n\n/**\n * Manages graceful shutdown of MCP stdio connections following the MCP specification.\n *\n * Per spec, shutdown should:\n * 1. Close the input stream to the child process\n * 2. Wait for the server to exit, or send SIGTERM if it doesn't exit within 10 seconds\n * 3. Send SIGKILL if the server doesn't exit within 10 seconds after SIGTERM\n * 4. Allow forceful killing if called twice\n */\nexport class McpStdioStateHandler implements IDisposable {\n\tprivate static readonly GRACE_TIME_MS = 10_000;\n\n\tprivate _procState = McpProcessState.Running;\n\tprivate _nextTimeout?: IDisposable;\n\n\tpublic get stopped() {\n\t\treturn this._procState !== McpProcessState.Running;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _child: ChildProcessWithoutNullStreams,\n\t\tprivate readonly _graceTimeMs: number = McpStdioStateHandler.GRACE_TIME_MS\n\t) { }\n\n\t/**\n\t * Initiates graceful shutdown. If called while shutdown is already in progress,\n\t * forces immediate termination.\n\t */\n\tpublic stop(): void {\n\t\tif (this._procState === McpProcessState.Running) {\n\t\t\tlet graceTime = this._graceTimeMs;\n\t\t\ttry {\n\t\t\t\tthis._child.stdin.end();\n\t\t\t} catch (error) {\n\t\t\t\t// If stdin.end() fails, continue with termination sequence\n\t\t\t\t// This can happen if the stream is already in an error state\n\t\t\t\tgraceTime = 1;\n\t\t\t}\n\t\t\tthis._procState = McpProcessState.StdinEnded;\n\t\t\tthis._nextTimeout = new TimeoutTimer(() => this.killPolite(), graceTime);\n\t\t} else {\n\t\t\tthis._nextTimeout?.dispose();\n\t\t\tthis.killForceful();\n\t\t}\n\t}\n\n\tprivate async killPolite() {\n\t\tthis._procState = McpProcessState.KilledPolite;\n\t\tthis._nextTimeout = new TimeoutTimer(() => this.killForceful(), this._graceTimeMs);\n\n\t\tif (this._child.pid) {\n\t\t\tif (!isWindows) {\n\t\t\t\tawait killTree(this._child.pid, false).catch(() => {\n\t\t\t\t\tthis._child.kill('SIGTERM');\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis._child.kill('SIGTERM');\n\t\t}\n\t}\n\n\tprivate async killForceful() {\n\t\tthis._procState = McpProcessState.KilledForceful;\n\n\t\tif (this._child.pid) {\n\t\t\tawait killTree(this._child.pid, true).catch(() => {\n\t\t\t\tthis._child.kill('SIGKILL');\n\t\t\t});\n\t\t} else {\n\t\t\tthis._child.kill();\n\t\t}\n\t}\n\n\tpublic write(message: string): void {\n\t\tif (!this.stopped) {\n\t\t\tthis._child.stdin.write(message + '\\n');\n\t\t}\n\t}\n\n\tpublic dispose() {\n\t\tthis._nextTimeout?.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcessWithoutNullStreams } from 'child_process';\nimport { TimeoutTimer } from '../../../../base/common/async.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { killTree } from '../../../../base/node/processes.js';\nimport { isWindows } from '../../../../base/common/platform.js';\n\nconst enum McpProcessState {\n\tRunning,\n\tStdinEnded,\n\tKilledPolite,\n\tKilledForceful,\n}\n\n/**\n * Manages graceful shutdown of MCP stdio connections following the MCP specification.\n *\n * Per spec, shutdown should:\n * 1. Close the input stream to the child process\n * 2. Wait for the server to exit, or send SIGTERM if it doesn't exit within 10 seconds\n * 3. Send SIGKILL if the server doesn't exit within 10 seconds after SIGTERM\n * 4. Allow forceful killing if called twice\n */\nexport class McpStdioStateHandler implements IDisposable {\n\tprivate static readonly GRACE_TIME_MS = 10_000;\n\n\tprivate _procState = McpProcessState.Running;\n\tprivate _nextTimeout?: IDisposable;\n\n\tpublic get stopped() {\n\t\treturn this._procState !== McpProcessState.Running;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _child: ChildProcessWithoutNullStreams,\n\t\tprivate readonly _graceTimeMs: number = McpStdioStateHandler.GRACE_TIME_MS\n\t) { }\n\n\t/**\n\t * Initiates graceful shutdown. If called while shutdown is already in progress,\n\t * forces immediate termination.\n\t */\n\tpublic stop(): void {\n\t\tif (this._procState === McpProcessState.Running) {\n\t\t\tlet graceTime = this._graceTimeMs;\n\t\t\ttry {\n\t\t\t\tthis._child.stdin.end();\n\t\t\t} catch (error) {\n\t\t\t\t// If stdin.end() fails, continue with termination sequence\n\t\t\t\t// This can happen if the stream is already in an error state\n\t\t\t\tgraceTime = 1;\n\t\t\t}\n\t\t\tthis._procState = McpProcessState.StdinEnded;\n\t\t\tthis._nextTimeout = new TimeoutTimer(() => this.killPolite(), graceTime);\n\t\t} else {\n\t\t\tthis._nextTimeout?.dispose();\n\t\t\tthis.killForceful();\n\t\t}\n\t}\n\n\tprivate async killPolite() {\n\t\tthis._procState = McpProcessState.KilledPolite;\n\t\tthis._nextTimeout = new TimeoutTimer(() => this.killForceful(), this._graceTimeMs);\n\n\t\tif (this._child.pid) {\n\t\t\tif (!isWindows) {\n\t\t\t\tawait killTree(this._child.pid, false).catch(() => {\n\t\t\t\t\tthis._child.kill('SIGTERM');\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis._child.kill('SIGTERM');\n\t\t}\n\t}\n\n\tprivate async killForceful() {\n\t\tthis._procState = McpProcessState.KilledForceful;\n\n\t\tif (this._child.pid) {\n\t\t\tawait killTree(this._child.pid, true).catch(() => {\n\t\t\t\tthis._child.kill('SIGKILL');\n\t\t\t});\n\t\t} else {\n\t\t\tthis._child.kill();\n\t\t}\n\t}\n\n\tpublic write(message: string): void {\n\t\tif (!this.stopped) {\n\t\t\tthis._child.stdin.write(message + '\\n');\n\t\t}\n\t}\n\n\tpublic dispose() {\n\t\tthis._nextTimeout?.dispose();\n\t}\n}\n"]}