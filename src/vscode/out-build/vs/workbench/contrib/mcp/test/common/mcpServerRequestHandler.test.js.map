{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/test/common/mcpServerRequestHandler.test.ts","vs/workbench/contrib/mcp/test/common/mcpServerRequestHandler.test.ts"],"names":[],"mappings":"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","file":"mcpServerRequestHandler.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport { upcast } from '../../../../../base/common/types.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { ServiceCollection } from '../../../../../platform/instantiation/common/serviceCollection.js';\nimport { TestInstantiationService } from '../../../../../platform/instantiation/test/common/instantiationServiceMock.js';\nimport { ILoggerService } from '../../../../../platform/log/common/log.js';\nimport { IProductService } from '../../../../../platform/product/common/productService.js';\nimport { IStorageService } from '../../../../../platform/storage/common/storage.js';\nimport { TestLoggerService, TestProductService, TestStorageService } from '../../../../test/common/workbenchTestServices.js';\nimport { IMcpHostDelegate } from '../../common/mcpRegistryTypes.js';\nimport { McpServerRequestHandler } from '../../common/mcpServerRequestHandler.js';\nimport { McpConnectionState, McpServerDefinition, McpServerLaunch } from '../../common/mcpTypes.js';\nimport { MCP } from '../../common/modelContextProtocol.js';\nimport { TestMcpMessageTransport } from './mcpRegistryTypes.js';\nimport { IOutputService } from '../../../../services/output/common/output.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { CancellationTokenSource } from '../../../../../base/common/cancellation.js';\n\nclass TestMcpHostDelegate extends Disposable implements IMcpHostDelegate {\n\tprivate readonly _transport: TestMcpMessageTransport;\n\n\tpriority = 0;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._transport = this._register(new TestMcpMessageTransport());\n\t}\n\n\n\tsubstituteVariables(serverDefinition: McpServerDefinition, launch: McpServerLaunch): Promise<McpServerLaunch> {\n\t\treturn Promise.resolve(launch);\n\t}\n\n\tcanStart(): boolean {\n\t\treturn true;\n\t}\n\n\tstart(): TestMcpMessageTransport {\n\t\treturn this._transport;\n\t}\n\n\tgetTransport(): TestMcpMessageTransport {\n\t\treturn this._transport;\n\t}\n\n\twaitForInitialProviderPromises(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n\nsuite('Workbench - MCP - ServerRequestHandler', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tlet instantiationService: TestInstantiationService;\n\tlet delegate: TestMcpHostDelegate;\n\tlet transport: TestMcpMessageTransport;\n\tlet handler: McpServerRequestHandler;\n\tlet cts: CancellationTokenSource;\n\n\tsetup(async () => {\n\t\tdelegate = store.add(new TestMcpHostDelegate());\n\t\ttransport = delegate.getTransport();\n\t\tcts = store.add(new CancellationTokenSource());\n\n\t\t// Setup test services\n\t\tconst services = new ServiceCollection(\n\t\t\t[ILoggerService, store.add(new TestLoggerService())],\n\t\t\t[IOutputService, upcast({ showChannel: () => { } })],\n\t\t\t[IStorageService, store.add(new TestStorageService())],\n\t\t\t[IProductService, TestProductService],\n\t\t);\n\n\t\tinstantiationService = store.add(new TestInstantiationService(services));\n\n\t\ttransport.setConnectionState({ state: McpConnectionState.Kind.Running });\n\n\t\t// Manually create the handler since we need the transport already set up\n\t\tconst logger = store.add((instantiationService.get(ILoggerService) as TestLoggerService)\n\t\t\t.createLogger('mcpServerTest', { hidden: true, name: 'MCP Test' }));\n\n\t\t// Start the handler creation\n\t\tconst handlerPromise = McpServerRequestHandler.create(instantiationService, { logger, launch: transport }, cts.token);\n\n\t\thandler = await handlerPromise;\n\t\tstore.add(handler);\n\t});\n\n\ttest('should send and receive JSON-RPC requests', async () => {\n\t\t// Setup request\n\t\tconst requestPromise = handler.listResources();\n\n\t\t// Get the sent message and verify it\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tassert.strictEqual(sentMessages.length, 3); // initialize + listResources\n\n\t\t// Verify listResources request format\n\t\tconst listResourcesRequest = sentMessages[2] as MCP.JSONRPCRequest;\n\t\tassert.strictEqual(listResourcesRequest.method, 'resources/list');\n\t\tassert.strictEqual(listResourcesRequest.jsonrpc, MCP.JSONRPC_VERSION);\n\t\tassert.ok(typeof listResourcesRequest.id === 'number');\n\n\t\t// Simulate server response with mock resources that match the expected Resource interface\n\t\ttransport.simulateReceiveMessage({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: listResourcesRequest.id,\n\t\t\tresult: {\n\t\t\t\tresources: [\n\t\t\t\t\t{ uri: 'resource1', type: 'text/plain', name: 'Test Resource 1' },\n\t\t\t\t\t{ uri: 'resource2', type: 'text/plain', name: 'Test Resource 2' }\n\t\t\t\t]\n\t\t\t}\n\t\t});\n\n\t\t// Verify the result\n\t\tconst resources = await requestPromise;\n\t\tassert.strictEqual(resources.length, 2);\n\t\tassert.strictEqual(resources[0].uri, 'resource1');\n\t\tassert.strictEqual(resources[1].name, 'Test Resource 2');\n\t});\n\n\ttest('should handle paginated requests', async () => {\n\t\t// Setup request\n\t\tconst requestPromise = handler.listResources();\n\n\t\t// Get the first request and respond with pagination\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst listResourcesRequest = sentMessages[2] as MCP.JSONRPCRequest;\n\n\t\t// Send first page with nextCursor\n\t\ttransport.simulateReceiveMessage({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: listResourcesRequest.id,\n\t\t\tresult: {\n\t\t\t\tresources: [\n\t\t\t\t\t{ uri: 'resource1', type: 'text/plain', name: 'Test Resource 1' }\n\t\t\t\t],\n\t\t\t\tnextCursor: 'page2'\n\t\t\t}\n\t\t});\n\n\t\t// Clear the sent messages to only capture the next page request\n\t\ttransport.clearSentMessages();\n\n\t\t// Wait a bit to allow the handler to process and send the next request\n\t\tawait new Promise(resolve => setTimeout(resolve, 0));\n\n\t\t// Get the second request and verify cursor is included\n\t\tconst sentMessages2 = transport.getSentMessages();\n\t\tassert.strictEqual(sentMessages2.length, 1);\n\n\t\tconst listResourcesRequest2 = sentMessages2[0] as MCP.JSONRPCRequest;\n\t\tassert.strictEqual(listResourcesRequest2.method, 'resources/list');\n\t\tassert.deepStrictEqual(listResourcesRequest2.params, { cursor: 'page2' });\n\n\t\t// Send final page with no nextCursor\n\t\ttransport.simulateReceiveMessage({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: listResourcesRequest2.id,\n\t\t\tresult: {\n\t\t\t\tresources: [\n\t\t\t\t\t{ uri: 'resource2', type: 'text/plain', name: 'Test Resource 2' }\n\t\t\t\t]\n\t\t\t}\n\t\t});\n\n\t\t// Verify the combined result\n\t\tconst resources = await requestPromise;\n\t\tassert.strictEqual(resources.length, 2);\n\t\tassert.strictEqual(resources[0].uri, 'resource1');\n\t\tassert.strictEqual(resources[1].uri, 'resource2');\n\t});\n\n\ttest('should handle error responses', async () => {\n\t\t// Setup request\n\t\tconst requestPromise = handler.readResource({ uri: 'non-existent' });\n\n\t\t// Get the sent message\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst readResourceRequest = sentMessages[2] as MCP.JSONRPCRequest; // [0] is initialize\n\n\t\t// Simulate error response\n\t\ttransport.simulateReceiveMessage({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: readResourceRequest.id,\n\t\t\terror: {\n\t\t\t\tcode: MCP.METHOD_NOT_FOUND,\n\t\t\t\tmessage: 'Resource not found'\n\t\t\t}\n\t\t});\n\n\t\t// Verify the error is thrown correctly\n\t\ttry {\n\t\t\tawait requestPromise;\n\t\t\tassert.fail('Expected error was not thrown');\n\t\t} catch (e: unknown) {\n\t\t\tassert.strictEqual((e as Error).message, 'MPC -32601: Resource not found');\n\t\t\tassert.strictEqual((e as { code: number }).code, MCP.METHOD_NOT_FOUND);\n\t\t}\n\t});\n\n\ttest('should handle server requests', async () => {\n\t\t// Simulate ping request from server\n\t\tconst pingRequest: MCP.JSONRPCRequest & MCP.PingRequest = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: 100,\n\t\t\tmethod: 'ping'\n\t\t};\n\n\t\ttransport.simulateReceiveMessage(pingRequest);\n\n\t\t// The handler should have sent a response\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst pingResponse = sentMessages.find(m =>\n\t\t\t'id' in m && m.id === pingRequest.id && 'result' in m\n\t\t) as MCP.JSONRPCResponse;\n\n\t\tassert.ok(pingResponse, 'No ping response was sent');\n\t\tassert.deepStrictEqual(pingResponse.result, {});\n\t});\n\n\ttest('should handle roots list requests', async () => {\n\t\t// Set roots\n\t\thandler.roots = [\n\t\t\t{ uri: 'file:///test/root1', name: 'Root 1' },\n\t\t\t{ uri: 'file:///test/root2', name: 'Root 2' }\n\t\t];\n\n\t\t// Simulate roots/list request from server\n\t\tconst rootsRequest: MCP.JSONRPCRequest & MCP.ListRootsRequest = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: 101,\n\t\t\tmethod: 'roots/list'\n\t\t};\n\n\t\ttransport.simulateReceiveMessage(rootsRequest);\n\n\t\t// The handler should have sent a response\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst rootsResponse = sentMessages.find(m =>\n\t\t\t'id' in m && m.id === rootsRequest.id && 'result' in m\n\t\t) as MCP.JSONRPCResponse;\n\n\t\tassert.ok(rootsResponse, 'No roots/list response was sent');\n\t\tassert.strictEqual((rootsResponse.result as MCP.ListRootsResult).roots.length, 2);\n\t\tassert.strictEqual((rootsResponse.result as MCP.ListRootsResult).roots[0].uri, 'file:///test/root1');\n\t});\n\n\ttest('should handle server notifications', async () => {\n\t\tlet progressNotificationReceived = false;\n\t\tstore.add(handler.onDidReceiveProgressNotification(notification => {\n\t\t\tprogressNotificationReceived = true;\n\t\t\tassert.strictEqual(notification.method, 'notifications/progress');\n\t\t\tassert.strictEqual(notification.params.progressToken, 'token1');\n\t\t\tassert.strictEqual(notification.params.progress, 50);\n\t\t}));\n\n\t\t// Simulate progress notification with correct format\n\t\tconst progressNotification: MCP.JSONRPCNotification & MCP.ProgressNotification = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tmethod: 'notifications/progress',\n\t\t\tparams: {\n\t\t\t\tprogressToken: 'token1',\n\t\t\t\tprogress: 50,\n\t\t\t\ttotal: 100\n\t\t\t}\n\t\t};\n\n\t\ttransport.simulateReceiveMessage(progressNotification);\n\t\tassert.strictEqual(progressNotificationReceived, true);\n\t});\n\n\ttest('should handle cancellation', async () => {\n\t\t// Setup a new cancellation token source for this specific test\n\t\tconst testCts = store.add(new CancellationTokenSource());\n\t\tconst requestPromise = handler.listResources(undefined, testCts.token);\n\n\t\t// Get the request ID\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst listResourcesRequest = sentMessages[2] as MCP.JSONRPCRequest;\n\t\tconst requestId = listResourcesRequest.id;\n\n\t\t// Cancel the request\n\t\ttestCts.cancel();\n\n\t\t// Check that a cancellation notification was sent\n\t\tconst cancelNotification = transport.getSentMessages().find(m =>\n\t\t\t!('id' in m) &&\n\t\t\t'method' in m &&\n\t\t\tm.method === 'notifications/cancelled' &&\n\t\t\t'params' in m &&\n\t\t\tm.params && m.params.requestId === requestId\n\t\t);\n\n\t\tassert.ok(cancelNotification, 'No cancellation notification was sent');\n\n\t\t// Verify the promise was cancelled\n\t\ttry {\n\t\t\tawait requestPromise;\n\t\t\tassert.fail('Promise should have been cancelled');\n\t\t} catch (e) {\n\t\t\tassert.strictEqual(e.name, 'Canceled');\n\t\t}\n\t});\n\n\ttest('should handle cancelled notification from server', async () => {\n\t\t// Setup request\n\t\tconst requestPromise = handler.listResources();\n\n\t\t// Get the request ID\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst listResourcesRequest = sentMessages[2] as MCP.JSONRPCRequest;\n\t\tconst requestId = listResourcesRequest.id;\n\n\t\t// Simulate cancelled notification from server\n\t\tconst cancelledNotification: MCP.JSONRPCNotification & MCP.CancelledNotification = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tmethod: 'notifications/cancelled',\n\t\t\tparams: {\n\t\t\t\trequestId\n\t\t\t}\n\t\t};\n\n\t\ttransport.simulateReceiveMessage(cancelledNotification);\n\n\t\t// Verify the promise was cancelled\n\t\ttry {\n\t\t\tawait requestPromise;\n\t\t\tassert.fail('Promise should have been cancelled');\n\t\t} catch (e) {\n\t\t\tassert.strictEqual(e.name, 'Canceled');\n\t\t}\n\t});\n\n\ttest('should dispose properly and cancel pending requests', async () => {\n\t\t// Setup multiple requests\n\t\tconst request1 = handler.listResources();\n\t\tconst request2 = handler.listTools();\n\n\t\t// Dispose the handler\n\t\thandler.dispose();\n\n\t\t// Verify all promises were cancelled\n\t\ttry {\n\t\t\tawait request1;\n\t\t\tassert.fail('Promise 1 should have been cancelled');\n\t\t} catch (e) {\n\t\t\tassert.strictEqual(e.name, 'Canceled');\n\t\t}\n\n\t\ttry {\n\t\t\tawait request2;\n\t\t\tassert.fail('Promise 2 should have been cancelled');\n\t\t} catch (e) {\n\t\t\tassert.strictEqual(e.name, 'Canceled');\n\t\t}\n\t});\n\n\ttest('should handle connection error by cancelling requests', async () => {\n\t\t// Setup request\n\t\tconst requestPromise = handler.listResources();\n\n\t\t// Simulate connection error\n\t\ttransport.setConnectionState({\n\t\t\tstate: McpConnectionState.Kind.Error,\n\t\t\tmessage: 'Connection lost'\n\t\t});\n\n\t\t// Verify the promise was cancelled\n\t\ttry {\n\t\t\tawait requestPromise;\n\t\t\tassert.fail('Promise should have been cancelled');\n\t\t} catch (e) {\n\t\t\tassert.strictEqual(e.name, 'Canceled');\n\t\t}\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport { upcast } from '../../../../../base/common/types.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { ServiceCollection } from '../../../../../platform/instantiation/common/serviceCollection.js';\nimport { TestInstantiationService } from '../../../../../platform/instantiation/test/common/instantiationServiceMock.js';\nimport { ILoggerService } from '../../../../../platform/log/common/log.js';\nimport { IProductService } from '../../../../../platform/product/common/productService.js';\nimport { IStorageService } from '../../../../../platform/storage/common/storage.js';\nimport { TestLoggerService, TestProductService, TestStorageService } from '../../../../test/common/workbenchTestServices.js';\nimport { IMcpHostDelegate } from '../../common/mcpRegistryTypes.js';\nimport { McpServerRequestHandler } from '../../common/mcpServerRequestHandler.js';\nimport { McpConnectionState, McpServerDefinition, McpServerLaunch } from '../../common/mcpTypes.js';\nimport { MCP } from '../../common/modelContextProtocol.js';\nimport { TestMcpMessageTransport } from './mcpRegistryTypes.js';\nimport { IOutputService } from '../../../../services/output/common/output.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { CancellationTokenSource } from '../../../../../base/common/cancellation.js';\n\nclass TestMcpHostDelegate extends Disposable implements IMcpHostDelegate {\n\tprivate readonly _transport: TestMcpMessageTransport;\n\n\tpriority = 0;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._transport = this._register(new TestMcpMessageTransport());\n\t}\n\n\n\tsubstituteVariables(serverDefinition: McpServerDefinition, launch: McpServerLaunch): Promise<McpServerLaunch> {\n\t\treturn Promise.resolve(launch);\n\t}\n\n\tcanStart(): boolean {\n\t\treturn true;\n\t}\n\n\tstart(): TestMcpMessageTransport {\n\t\treturn this._transport;\n\t}\n\n\tgetTransport(): TestMcpMessageTransport {\n\t\treturn this._transport;\n\t}\n\n\twaitForInitialProviderPromises(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n\nsuite('Workbench - MCP - ServerRequestHandler', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tlet instantiationService: TestInstantiationService;\n\tlet delegate: TestMcpHostDelegate;\n\tlet transport: TestMcpMessageTransport;\n\tlet handler: McpServerRequestHandler;\n\tlet cts: CancellationTokenSource;\n\n\tsetup(async () => {\n\t\tdelegate = store.add(new TestMcpHostDelegate());\n\t\ttransport = delegate.getTransport();\n\t\tcts = store.add(new CancellationTokenSource());\n\n\t\t// Setup test services\n\t\tconst services = new ServiceCollection(\n\t\t\t[ILoggerService, store.add(new TestLoggerService())],\n\t\t\t[IOutputService, upcast({ showChannel: () => { } })],\n\t\t\t[IStorageService, store.add(new TestStorageService())],\n\t\t\t[IProductService, TestProductService],\n\t\t);\n\n\t\tinstantiationService = store.add(new TestInstantiationService(services));\n\n\t\ttransport.setConnectionState({ state: McpConnectionState.Kind.Running });\n\n\t\t// Manually create the handler since we need the transport already set up\n\t\tconst logger = store.add((instantiationService.get(ILoggerService) as TestLoggerService)\n\t\t\t.createLogger('mcpServerTest', { hidden: true, name: 'MCP Test' }));\n\n\t\t// Start the handler creation\n\t\tconst handlerPromise = McpServerRequestHandler.create(instantiationService, { logger, launch: transport }, cts.token);\n\n\t\thandler = await handlerPromise;\n\t\tstore.add(handler);\n\t});\n\n\ttest('should send and receive JSON-RPC requests', async () => {\n\t\t// Setup request\n\t\tconst requestPromise = handler.listResources();\n\n\t\t// Get the sent message and verify it\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tassert.strictEqual(sentMessages.length, 3); // initialize + listResources\n\n\t\t// Verify listResources request format\n\t\tconst listResourcesRequest = sentMessages[2] as MCP.JSONRPCRequest;\n\t\tassert.strictEqual(listResourcesRequest.method, 'resources/list');\n\t\tassert.strictEqual(listResourcesRequest.jsonrpc, MCP.JSONRPC_VERSION);\n\t\tassert.ok(typeof listResourcesRequest.id === 'number');\n\n\t\t// Simulate server response with mock resources that match the expected Resource interface\n\t\ttransport.simulateReceiveMessage({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: listResourcesRequest.id,\n\t\t\tresult: {\n\t\t\t\tresources: [\n\t\t\t\t\t{ uri: 'resource1', type: 'text/plain', name: 'Test Resource 1' },\n\t\t\t\t\t{ uri: 'resource2', type: 'text/plain', name: 'Test Resource 2' }\n\t\t\t\t]\n\t\t\t}\n\t\t});\n\n\t\t// Verify the result\n\t\tconst resources = await requestPromise;\n\t\tassert.strictEqual(resources.length, 2);\n\t\tassert.strictEqual(resources[0].uri, 'resource1');\n\t\tassert.strictEqual(resources[1].name, 'Test Resource 2');\n\t});\n\n\ttest('should handle paginated requests', async () => {\n\t\t// Setup request\n\t\tconst requestPromise = handler.listResources();\n\n\t\t// Get the first request and respond with pagination\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst listResourcesRequest = sentMessages[2] as MCP.JSONRPCRequest;\n\n\t\t// Send first page with nextCursor\n\t\ttransport.simulateReceiveMessage({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: listResourcesRequest.id,\n\t\t\tresult: {\n\t\t\t\tresources: [\n\t\t\t\t\t{ uri: 'resource1', type: 'text/plain', name: 'Test Resource 1' }\n\t\t\t\t],\n\t\t\t\tnextCursor: 'page2'\n\t\t\t}\n\t\t});\n\n\t\t// Clear the sent messages to only capture the next page request\n\t\ttransport.clearSentMessages();\n\n\t\t// Wait a bit to allow the handler to process and send the next request\n\t\tawait new Promise(resolve => setTimeout(resolve, 0));\n\n\t\t// Get the second request and verify cursor is included\n\t\tconst sentMessages2 = transport.getSentMessages();\n\t\tassert.strictEqual(sentMessages2.length, 1);\n\n\t\tconst listResourcesRequest2 = sentMessages2[0] as MCP.JSONRPCRequest;\n\t\tassert.strictEqual(listResourcesRequest2.method, 'resources/list');\n\t\tassert.deepStrictEqual(listResourcesRequest2.params, { cursor: 'page2' });\n\n\t\t// Send final page with no nextCursor\n\t\ttransport.simulateReceiveMessage({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: listResourcesRequest2.id,\n\t\t\tresult: {\n\t\t\t\tresources: [\n\t\t\t\t\t{ uri: 'resource2', type: 'text/plain', name: 'Test Resource 2' }\n\t\t\t\t]\n\t\t\t}\n\t\t});\n\n\t\t// Verify the combined result\n\t\tconst resources = await requestPromise;\n\t\tassert.strictEqual(resources.length, 2);\n\t\tassert.strictEqual(resources[0].uri, 'resource1');\n\t\tassert.strictEqual(resources[1].uri, 'resource2');\n\t});\n\n\ttest('should handle error responses', async () => {\n\t\t// Setup request\n\t\tconst requestPromise = handler.readResource({ uri: 'non-existent' });\n\n\t\t// Get the sent message\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst readResourceRequest = sentMessages[2] as MCP.JSONRPCRequest; // [0] is initialize\n\n\t\t// Simulate error response\n\t\ttransport.simulateReceiveMessage({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: readResourceRequest.id,\n\t\t\terror: {\n\t\t\t\tcode: MCP.METHOD_NOT_FOUND,\n\t\t\t\tmessage: 'Resource not found'\n\t\t\t}\n\t\t});\n\n\t\t// Verify the error is thrown correctly\n\t\ttry {\n\t\t\tawait requestPromise;\n\t\t\tassert.fail('Expected error was not thrown');\n\t\t} catch (e: unknown) {\n\t\t\tassert.strictEqual((e as Error).message, 'MPC -32601: Resource not found');\n\t\t\tassert.strictEqual((e as { code: number }).code, MCP.METHOD_NOT_FOUND);\n\t\t}\n\t});\n\n\ttest('should handle server requests', async () => {\n\t\t// Simulate ping request from server\n\t\tconst pingRequest: MCP.JSONRPCRequest & MCP.PingRequest = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: 100,\n\t\t\tmethod: 'ping'\n\t\t};\n\n\t\ttransport.simulateReceiveMessage(pingRequest);\n\n\t\t// The handler should have sent a response\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst pingResponse = sentMessages.find(m =>\n\t\t\t'id' in m && m.id === pingRequest.id && 'result' in m\n\t\t) as MCP.JSONRPCResponse;\n\n\t\tassert.ok(pingResponse, 'No ping response was sent');\n\t\tassert.deepStrictEqual(pingResponse.result, {});\n\t});\n\n\ttest('should handle roots list requests', async () => {\n\t\t// Set roots\n\t\thandler.roots = [\n\t\t\t{ uri: 'file:///test/root1', name: 'Root 1' },\n\t\t\t{ uri: 'file:///test/root2', name: 'Root 2' }\n\t\t];\n\n\t\t// Simulate roots/list request from server\n\t\tconst rootsRequest: MCP.JSONRPCRequest & MCP.ListRootsRequest = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: 101,\n\t\t\tmethod: 'roots/list'\n\t\t};\n\n\t\ttransport.simulateReceiveMessage(rootsRequest);\n\n\t\t// The handler should have sent a response\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst rootsResponse = sentMessages.find(m =>\n\t\t\t'id' in m && m.id === rootsRequest.id && 'result' in m\n\t\t) as MCP.JSONRPCResponse;\n\n\t\tassert.ok(rootsResponse, 'No roots/list response was sent');\n\t\tassert.strictEqual((rootsResponse.result as MCP.ListRootsResult).roots.length, 2);\n\t\tassert.strictEqual((rootsResponse.result as MCP.ListRootsResult).roots[0].uri, 'file:///test/root1');\n\t});\n\n\ttest('should handle server notifications', async () => {\n\t\tlet progressNotificationReceived = false;\n\t\tstore.add(handler.onDidReceiveProgressNotification(notification => {\n\t\t\tprogressNotificationReceived = true;\n\t\t\tassert.strictEqual(notification.method, 'notifications/progress');\n\t\t\tassert.strictEqual(notification.params.progressToken, 'token1');\n\t\t\tassert.strictEqual(notification.params.progress, 50);\n\t\t}));\n\n\t\t// Simulate progress notification with correct format\n\t\tconst progressNotification: MCP.JSONRPCNotification & MCP.ProgressNotification = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tmethod: 'notifications/progress',\n\t\t\tparams: {\n\t\t\t\tprogressToken: 'token1',\n\t\t\t\tprogress: 50,\n\t\t\t\ttotal: 100\n\t\t\t}\n\t\t};\n\n\t\ttransport.simulateReceiveMessage(progressNotification);\n\t\tassert.strictEqual(progressNotificationReceived, true);\n\t});\n\n\ttest('should handle cancellation', async () => {\n\t\t// Setup a new cancellation token source for this specific test\n\t\tconst testCts = store.add(new CancellationTokenSource());\n\t\tconst requestPromise = handler.listResources(undefined, testCts.token);\n\n\t\t// Get the request ID\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst listResourcesRequest = sentMessages[2] as MCP.JSONRPCRequest;\n\t\tconst requestId = listResourcesRequest.id;\n\n\t\t// Cancel the request\n\t\ttestCts.cancel();\n\n\t\t// Check that a cancellation notification was sent\n\t\tconst cancelNotification = transport.getSentMessages().find(m =>\n\t\t\t!('id' in m) &&\n\t\t\t'method' in m &&\n\t\t\tm.method === 'notifications/cancelled' &&\n\t\t\t'params' in m &&\n\t\t\tm.params && m.params.requestId === requestId\n\t\t);\n\n\t\tassert.ok(cancelNotification, 'No cancellation notification was sent');\n\n\t\t// Verify the promise was cancelled\n\t\ttry {\n\t\t\tawait requestPromise;\n\t\t\tassert.fail('Promise should have been cancelled');\n\t\t} catch (e) {\n\t\t\tassert.strictEqual(e.name, 'Canceled');\n\t\t}\n\t});\n\n\ttest('should handle cancelled notification from server', async () => {\n\t\t// Setup request\n\t\tconst requestPromise = handler.listResources();\n\n\t\t// Get the request ID\n\t\tconst sentMessages = transport.getSentMessages();\n\t\tconst listResourcesRequest = sentMessages[2] as MCP.JSONRPCRequest;\n\t\tconst requestId = listResourcesRequest.id;\n\n\t\t// Simulate cancelled notification from server\n\t\tconst cancelledNotification: MCP.JSONRPCNotification & MCP.CancelledNotification = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tmethod: 'notifications/cancelled',\n\t\t\tparams: {\n\t\t\t\trequestId\n\t\t\t}\n\t\t};\n\n\t\ttransport.simulateReceiveMessage(cancelledNotification);\n\n\t\t// Verify the promise was cancelled\n\t\ttry {\n\t\t\tawait requestPromise;\n\t\t\tassert.fail('Promise should have been cancelled');\n\t\t} catch (e) {\n\t\t\tassert.strictEqual(e.name, 'Canceled');\n\t\t}\n\t});\n\n\ttest('should dispose properly and cancel pending requests', async () => {\n\t\t// Setup multiple requests\n\t\tconst request1 = handler.listResources();\n\t\tconst request2 = handler.listTools();\n\n\t\t// Dispose the handler\n\t\thandler.dispose();\n\n\t\t// Verify all promises were cancelled\n\t\ttry {\n\t\t\tawait request1;\n\t\t\tassert.fail('Promise 1 should have been cancelled');\n\t\t} catch (e) {\n\t\t\tassert.strictEqual(e.name, 'Canceled');\n\t\t}\n\n\t\ttry {\n\t\t\tawait request2;\n\t\t\tassert.fail('Promise 2 should have been cancelled');\n\t\t} catch (e) {\n\t\t\tassert.strictEqual(e.name, 'Canceled');\n\t\t}\n\t});\n\n\ttest('should handle connection error by cancelling requests', async () => {\n\t\t// Setup request\n\t\tconst requestPromise = handler.listResources();\n\n\t\t// Simulate connection error\n\t\ttransport.setConnectionState({\n\t\t\tstate: McpConnectionState.Kind.Error,\n\t\t\tmessage: 'Connection lost'\n\t\t});\n\n\t\t// Verify the promise was cancelled\n\t\ttry {\n\t\t\tawait requestPromise;\n\t\t\tassert.fail('Promise should have been cancelled');\n\t\t} catch (e) {\n\t\t\tassert.strictEqual(e.name, 'Canceled');\n\t\t}\n\t});\n});\n"]}