{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/test/common/mcpRegistryTypes.ts","vs/workbench/contrib/mcp/test/common/mcpRegistryTypes.ts"],"names":[],"mappings":"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","file":"mcpRegistryTypes.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { Disposable, IDisposable } from '../../../../../base/common/lifecycle.js';\nimport { IObservable, observableValue } from '../../../../../base/common/observable.js';\nimport { ConfigurationTarget } from '../../../../../platform/configuration/common/configuration.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { LogLevel, NullLogger } from '../../../../../platform/log/common/log.js';\nimport { StorageScope } from '../../../../../platform/storage/common/storage.js';\nimport { IWorkspaceFolderData } from '../../../../../platform/workspace/common/workspace.js';\nimport { IResolvedValue } from '../../../../services/configurationResolver/common/configurationResolverExpression.js';\nimport { IMcpHostDelegate, IMcpMessageTransport, IMcpRegistry, IMcpResolveConnectionOptions } from '../../common/mcpRegistryTypes.js';\nimport { McpServerConnection } from '../../common/mcpServerConnection.js';\nimport { IMcpServerConnection, LazyCollectionState, McpCollectionDefinition, McpCollectionReference, McpConnectionState, McpDefinitionReference, McpServerDefinition, McpServerTransportType, McpServerTrust } from '../../common/mcpTypes.js';\nimport { MCP } from '../../common/modelContextProtocol.js';\n\n/**\n * Implementation of IMcpMessageTransport for testing purposes.\n * Allows tests to easily send/receive messages and control the connection state.\n */\nexport class TestMcpMessageTransport extends Disposable implements IMcpMessageTransport {\n\tprivate readonly _onDidLog = this._register(new Emitter<{ level: LogLevel; message: string }>());\n\tpublic readonly onDidLog = this._onDidLog.event;\n\n\tprivate readonly _onDidReceiveMessage = this._register(new Emitter<MCP.JSONRPCMessage>());\n\tpublic readonly onDidReceiveMessage = this._onDidReceiveMessage.event;\n\n\tprivate readonly _stateValue = observableValue<McpConnectionState>('testTransportState', { state: McpConnectionState.Kind.Starting });\n\tpublic readonly state = this._stateValue;\n\n\tprivate readonly _sentMessages: MCP.JSONRPCMessage[] = [];\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.setResponder('initialize', () => ({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: 1, // The handler uses 1 for the first request\n\t\t\tresult: {\n\t\t\t\tprotocolVersion: MCP.LATEST_PROTOCOL_VERSION,\n\t\t\t\tserverInfo: {\n\t\t\t\t\tname: 'Test MCP Server',\n\t\t\t\t\tversion: '1.0.0',\n\t\t\t\t},\n\t\t\t\tcapabilities: {\n\t\t\t\t\tresources: {\n\t\t\t\t\t\tsupportedTypes: ['text/plain'],\n\t\t\t\t\t},\n\t\t\t\t\ttools: {\n\t\t\t\t\t\tsupportsCancellation: true,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\t/**\n\t * Set a responder function for a specific method.\n\t * The responder receives the sent message and should return a response object,\n\t * which will be simulated as a server response.\n\t */\n\tpublic setResponder(method: string, responder: (message: unknown) => MCP.JSONRPCMessage | undefined): void {\n\t\tif (!this._responders) {\n\t\t\tthis._responders = new Map();\n\t\t}\n\t\tthis._responders.set(method, responder);\n\t}\n\n\tprivate _responders?: Map<string, (message: MCP.JSONRPCMessage) => MCP.JSONRPCMessage | undefined>;\n\n\t/**\n\t * Send a message through the transport.\n\t */\n\tpublic send(message: MCP.JSONRPCMessage): void {\n\t\tthis._sentMessages.push(message);\n\t\tif (this._responders && 'method' in message && typeof message.method === 'string') {\n\t\t\tconst responder = this._responders.get(message.method);\n\t\t\tif (responder) {\n\t\t\t\tconst response = responder(message);\n\t\t\t\tif (response) {\n\t\t\t\t\tsetTimeout(() => this.simulateReceiveMessage(response));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stop the transport.\n\t */\n\tpublic stop(): void {\n\t\tthis._stateValue.set({ state: McpConnectionState.Kind.Stopped }, undefined);\n\t}\n\n\t// Test Helper Methods\n\n\t/**\n\t * Simulate receiving a message from the server.\n\t */\n\tpublic simulateReceiveMessage(message: MCP.JSONRPCMessage): void {\n\t\tthis._onDidReceiveMessage.fire(message);\n\t}\n\n\t/**\n\t * Simulates a reply to an 'initialized' request.\n\t */\n\tpublic simulateInitialized() {\n\t\tif (!this._sentMessages.length) {\n\t\t\tthrow new Error('initialize was not called yet');\n\t\t}\n\n\t\tthis.simulateReceiveMessage({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: (this.getSentMessages()[0] as MCP.JSONRPCRequest).id,\n\t\t\tresult: {\n\t\t\t\tprotocolVersion: MCP.LATEST_PROTOCOL_VERSION,\n\t\t\t\tcapabilities: {\n\t\t\t\t\ttools: {},\n\t\t\t\t},\n\t\t\t\tserverInfo: {\n\t\t\t\t\tname: 'Test Server',\n\t\t\t\t\tversion: '1.0.0'\n\t\t\t\t},\n\t\t\t} satisfies MCP.InitializeResult\n\t\t});\n\t}\n\n\t/**\n\t * Simulate a log event.\n\t */\n\tpublic simulateLog(message: string): void {\n\t\tthis._onDidLog.fire({ level: LogLevel.Info, message });\n\t}\n\n\t/**\n\t * Set the connection state.\n\t */\n\tpublic setConnectionState(state: McpConnectionState): void {\n\t\tthis._stateValue.set(state, undefined);\n\t}\n\n\t/**\n\t * Get all messages that have been sent.\n\t */\n\tpublic getSentMessages(): readonly MCP.JSONRPCMessage[] {\n\t\treturn [...this._sentMessages];\n\t}\n\n\t/**\n\t * Clear the sent messages history.\n\t */\n\tpublic clearSentMessages(): void {\n\t\tthis._sentMessages.length = 0;\n\t}\n}\n\nexport class TestMcpRegistry implements IMcpRegistry {\n\tpublic makeTestTransport = () => new TestMcpMessageTransport();\n\n\tconstructor(@IInstantiationService private readonly _instantiationService: IInstantiationService) { }\n\n\t_serviceBrand: undefined;\n\tonDidChangeInputs = Event.None;\n\tcollections = observableValue<readonly McpCollectionDefinition[]>(this, [{\n\t\tid: 'test-collection',\n\t\tremoteAuthority: null,\n\t\tlabel: 'Test Collection',\n\t\tconfigTarget: ConfigurationTarget.USER,\n\t\tserverDefinitions: observableValue(this, [{\n\t\t\tid: 'test-server',\n\t\t\tlabel: 'Test Server',\n\t\t\tlaunch: { type: McpServerTransportType.Stdio, command: 'echo', args: ['Hello MCP'], env: {}, envFile: undefined, cwd: undefined },\n\t\t\tcacheNonce: 'a',\n\t\t} satisfies McpServerDefinition]),\n\t\ttrustBehavior: McpServerTrust.Kind.Trusted,\n\t\tscope: StorageScope.APPLICATION,\n\t}]);\n\tdelegates = observableValue<readonly IMcpHostDelegate[]>(this, [{\n\t\tpriority: 0,\n\t\tcanStart: () => true,\n\t\tsubstituteVariables(serverDefinition, launch) {\n\t\t\treturn Promise.resolve(launch);\n\t\t},\n\t\tstart: () => {\n\t\t\tconst t = this.makeTestTransport();\n\t\t\tsetTimeout(() => t.setConnectionState({ state: McpConnectionState.Kind.Running }));\n\t\t\treturn t;\n\t\t},\n\t\twaitForInitialProviderPromises: () => Promise.resolve(),\n\t}]);\n\tlazyCollectionState = observableValue(this, { state: LazyCollectionState.AllKnown, collections: [] });\n\tcollectionToolPrefix(collection: McpCollectionReference): IObservable<string> {\n\t\treturn observableValue<string>(this, `mcp-${collection.id}-`);\n\t}\n\tgetServerDefinition(collectionRef: McpDefinitionReference, definitionRef: McpDefinitionReference): IObservable<{ server: McpServerDefinition | undefined; collection: McpCollectionDefinition | undefined }> {\n\t\tconst collectionObs = this.collections.map(cols => cols.find(c => c.id === collectionRef.id));\n\t\treturn collectionObs.map((collection, reader) => {\n\t\t\tconst server = collection?.serverDefinitions.read(reader).find(s => s.id === definitionRef.id);\n\t\t\treturn { collection, server };\n\t\t});\n\t}\n\tdiscoverCollections(): Promise<McpCollectionDefinition[]> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tregisterDelegate(delegate: IMcpHostDelegate): IDisposable {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tregisterCollection(collection: McpCollectionDefinition): IDisposable {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tresetTrust(): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tclearSavedInputs(scope: StorageScope, inputId?: string): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\teditSavedInput(inputId: string, folderData: IWorkspaceFolderData | undefined, configSection: string, target: ConfigurationTarget): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsetSavedInput(inputId: string, target: ConfigurationTarget, value: string): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tgetSavedInputs(scope: StorageScope): Promise<{ [id: string]: IResolvedValue }> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tresolveConnection(options: IMcpResolveConnectionOptions): Promise<IMcpServerConnection | undefined> {\n\t\tconst collection = this.collections.get().find(c => c.id === options.collectionRef.id);\n\t\tconst definition = collection?.serverDefinitions.get().find(d => d.id === options.definitionRef.id);\n\t\tif (!collection || !definition) {\n\t\t\tthrow new Error(`Collection or definition not found: ${options.collectionRef.id}, ${options.definitionRef.id}`);\n\t\t}\n\t\tconst del = this.delegates.get()[0];\n\t\treturn Promise.resolve(new McpServerConnection(\n\t\t\tcollection,\n\t\t\tdefinition,\n\t\t\tdel,\n\t\t\tdefinition.launch,\n\t\t\tnew NullLogger(),\n\t\t\tfalse,\n\t\t\tthis._instantiationService,\n\t\t));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { Disposable, IDisposable } from '../../../../../base/common/lifecycle.js';\nimport { IObservable, observableValue } from '../../../../../base/common/observable.js';\nimport { ConfigurationTarget } from '../../../../../platform/configuration/common/configuration.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { LogLevel, NullLogger } from '../../../../../platform/log/common/log.js';\nimport { StorageScope } from '../../../../../platform/storage/common/storage.js';\nimport { IWorkspaceFolderData } from '../../../../../platform/workspace/common/workspace.js';\nimport { IResolvedValue } from '../../../../services/configurationResolver/common/configurationResolverExpression.js';\nimport { IMcpHostDelegate, IMcpMessageTransport, IMcpRegistry, IMcpResolveConnectionOptions } from '../../common/mcpRegistryTypes.js';\nimport { McpServerConnection } from '../../common/mcpServerConnection.js';\nimport { IMcpServerConnection, LazyCollectionState, McpCollectionDefinition, McpCollectionReference, McpConnectionState, McpDefinitionReference, McpServerDefinition, McpServerTransportType, McpServerTrust } from '../../common/mcpTypes.js';\nimport { MCP } from '../../common/modelContextProtocol.js';\n\n/**\n * Implementation of IMcpMessageTransport for testing purposes.\n * Allows tests to easily send/receive messages and control the connection state.\n */\nexport class TestMcpMessageTransport extends Disposable implements IMcpMessageTransport {\n\tprivate readonly _onDidLog = this._register(new Emitter<{ level: LogLevel; message: string }>());\n\tpublic readonly onDidLog = this._onDidLog.event;\n\n\tprivate readonly _onDidReceiveMessage = this._register(new Emitter<MCP.JSONRPCMessage>());\n\tpublic readonly onDidReceiveMessage = this._onDidReceiveMessage.event;\n\n\tprivate readonly _stateValue = observableValue<McpConnectionState>('testTransportState', { state: McpConnectionState.Kind.Starting });\n\tpublic readonly state = this._stateValue;\n\n\tprivate readonly _sentMessages: MCP.JSONRPCMessage[] = [];\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.setResponder('initialize', () => ({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: 1, // The handler uses 1 for the first request\n\t\t\tresult: {\n\t\t\t\tprotocolVersion: MCP.LATEST_PROTOCOL_VERSION,\n\t\t\t\tserverInfo: {\n\t\t\t\t\tname: 'Test MCP Server',\n\t\t\t\t\tversion: '1.0.0',\n\t\t\t\t},\n\t\t\t\tcapabilities: {\n\t\t\t\t\tresources: {\n\t\t\t\t\t\tsupportedTypes: ['text/plain'],\n\t\t\t\t\t},\n\t\t\t\t\ttools: {\n\t\t\t\t\t\tsupportsCancellation: true,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\t/**\n\t * Set a responder function for a specific method.\n\t * The responder receives the sent message and should return a response object,\n\t * which will be simulated as a server response.\n\t */\n\tpublic setResponder(method: string, responder: (message: unknown) => MCP.JSONRPCMessage | undefined): void {\n\t\tif (!this._responders) {\n\t\t\tthis._responders = new Map();\n\t\t}\n\t\tthis._responders.set(method, responder);\n\t}\n\n\tprivate _responders?: Map<string, (message: MCP.JSONRPCMessage) => MCP.JSONRPCMessage | undefined>;\n\n\t/**\n\t * Send a message through the transport.\n\t */\n\tpublic send(message: MCP.JSONRPCMessage): void {\n\t\tthis._sentMessages.push(message);\n\t\tif (this._responders && 'method' in message && typeof message.method === 'string') {\n\t\t\tconst responder = this._responders.get(message.method);\n\t\t\tif (responder) {\n\t\t\t\tconst response = responder(message);\n\t\t\t\tif (response) {\n\t\t\t\t\tsetTimeout(() => this.simulateReceiveMessage(response));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stop the transport.\n\t */\n\tpublic stop(): void {\n\t\tthis._stateValue.set({ state: McpConnectionState.Kind.Stopped }, undefined);\n\t}\n\n\t// Test Helper Methods\n\n\t/**\n\t * Simulate receiving a message from the server.\n\t */\n\tpublic simulateReceiveMessage(message: MCP.JSONRPCMessage): void {\n\t\tthis._onDidReceiveMessage.fire(message);\n\t}\n\n\t/**\n\t * Simulates a reply to an 'initialized' request.\n\t */\n\tpublic simulateInitialized() {\n\t\tif (!this._sentMessages.length) {\n\t\t\tthrow new Error('initialize was not called yet');\n\t\t}\n\n\t\tthis.simulateReceiveMessage({\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: (this.getSentMessages()[0] as MCP.JSONRPCRequest).id,\n\t\t\tresult: {\n\t\t\t\tprotocolVersion: MCP.LATEST_PROTOCOL_VERSION,\n\t\t\t\tcapabilities: {\n\t\t\t\t\ttools: {},\n\t\t\t\t},\n\t\t\t\tserverInfo: {\n\t\t\t\t\tname: 'Test Server',\n\t\t\t\t\tversion: '1.0.0'\n\t\t\t\t},\n\t\t\t} satisfies MCP.InitializeResult\n\t\t});\n\t}\n\n\t/**\n\t * Simulate a log event.\n\t */\n\tpublic simulateLog(message: string): void {\n\t\tthis._onDidLog.fire({ level: LogLevel.Info, message });\n\t}\n\n\t/**\n\t * Set the connection state.\n\t */\n\tpublic setConnectionState(state: McpConnectionState): void {\n\t\tthis._stateValue.set(state, undefined);\n\t}\n\n\t/**\n\t * Get all messages that have been sent.\n\t */\n\tpublic getSentMessages(): readonly MCP.JSONRPCMessage[] {\n\t\treturn [...this._sentMessages];\n\t}\n\n\t/**\n\t * Clear the sent messages history.\n\t */\n\tpublic clearSentMessages(): void {\n\t\tthis._sentMessages.length = 0;\n\t}\n}\n\nexport class TestMcpRegistry implements IMcpRegistry {\n\tpublic makeTestTransport = () => new TestMcpMessageTransport();\n\n\tconstructor(@IInstantiationService private readonly _instantiationService: IInstantiationService) { }\n\n\t_serviceBrand: undefined;\n\tonDidChangeInputs = Event.None;\n\tcollections = observableValue<readonly McpCollectionDefinition[]>(this, [{\n\t\tid: 'test-collection',\n\t\tremoteAuthority: null,\n\t\tlabel: 'Test Collection',\n\t\tconfigTarget: ConfigurationTarget.USER,\n\t\tserverDefinitions: observableValue(this, [{\n\t\t\tid: 'test-server',\n\t\t\tlabel: 'Test Server',\n\t\t\tlaunch: { type: McpServerTransportType.Stdio, command: 'echo', args: ['Hello MCP'], env: {}, envFile: undefined, cwd: undefined },\n\t\t\tcacheNonce: 'a',\n\t\t} satisfies McpServerDefinition]),\n\t\ttrustBehavior: McpServerTrust.Kind.Trusted,\n\t\tscope: StorageScope.APPLICATION,\n\t}]);\n\tdelegates = observableValue<readonly IMcpHostDelegate[]>(this, [{\n\t\tpriority: 0,\n\t\tcanStart: () => true,\n\t\tsubstituteVariables(serverDefinition, launch) {\n\t\t\treturn Promise.resolve(launch);\n\t\t},\n\t\tstart: () => {\n\t\t\tconst t = this.makeTestTransport();\n\t\t\tsetTimeout(() => t.setConnectionState({ state: McpConnectionState.Kind.Running }));\n\t\t\treturn t;\n\t\t},\n\t\twaitForInitialProviderPromises: () => Promise.resolve(),\n\t}]);\n\tlazyCollectionState = observableValue(this, { state: LazyCollectionState.AllKnown, collections: [] });\n\tcollectionToolPrefix(collection: McpCollectionReference): IObservable<string> {\n\t\treturn observableValue<string>(this, `mcp-${collection.id}-`);\n\t}\n\tgetServerDefinition(collectionRef: McpDefinitionReference, definitionRef: McpDefinitionReference): IObservable<{ server: McpServerDefinition | undefined; collection: McpCollectionDefinition | undefined }> {\n\t\tconst collectionObs = this.collections.map(cols => cols.find(c => c.id === collectionRef.id));\n\t\treturn collectionObs.map((collection, reader) => {\n\t\t\tconst server = collection?.serverDefinitions.read(reader).find(s => s.id === definitionRef.id);\n\t\t\treturn { collection, server };\n\t\t});\n\t}\n\tdiscoverCollections(): Promise<McpCollectionDefinition[]> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tregisterDelegate(delegate: IMcpHostDelegate): IDisposable {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tregisterCollection(collection: McpCollectionDefinition): IDisposable {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tresetTrust(): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tclearSavedInputs(scope: StorageScope, inputId?: string): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\teditSavedInput(inputId: string, folderData: IWorkspaceFolderData | undefined, configSection: string, target: ConfigurationTarget): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tsetSavedInput(inputId: string, target: ConfigurationTarget, value: string): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tgetSavedInputs(scope: StorageScope): Promise<{ [id: string]: IResolvedValue }> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tresolveConnection(options: IMcpResolveConnectionOptions): Promise<IMcpServerConnection | undefined> {\n\t\tconst collection = this.collections.get().find(c => c.id === options.collectionRef.id);\n\t\tconst definition = collection?.serverDefinitions.get().find(d => d.id === options.definitionRef.id);\n\t\tif (!collection || !definition) {\n\t\t\tthrow new Error(`Collection or definition not found: ${options.collectionRef.id}, ${options.definitionRef.id}`);\n\t\t}\n\t\tconst del = this.delegates.get()[0];\n\t\treturn Promise.resolve(new McpServerConnection(\n\t\t\tcollection,\n\t\t\tdefinition,\n\t\t\tdel,\n\t\t\tdefinition.launch,\n\t\t\tnew NullLogger(),\n\t\t\tfalse,\n\t\t\tthis._instantiationService,\n\t\t));\n\t}\n}\n"]}