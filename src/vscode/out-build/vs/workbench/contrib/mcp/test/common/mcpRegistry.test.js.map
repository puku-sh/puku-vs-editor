{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/test/common/mcpRegistry.test.ts","vs/workbench/contrib/mcp/test/common/mcpRegistry.test.ts"],"names":[],"mappings":"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","file":"mcpRegistry.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport * as sinon from 'sinon';\nimport { timeout } from '../../../../../base/common/async.js';\nimport { ISettableObservable, observableValue } from '../../../../../base/common/observable.js';\nimport { upcast } from '../../../../../base/common/types.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { ConfigurationTarget, IConfigurationChangeEvent, IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { TestConfigurationService } from '../../../../../platform/configuration/test/common/testConfigurationService.js';\nimport { IDialogService, IPrompt } from '../../../../../platform/dialogs/common/dialogs.js';\nimport { ServiceCollection } from '../../../../../platform/instantiation/common/serviceCollection.js';\nimport { TestInstantiationService } from '../../../../../platform/instantiation/test/common/instantiationServiceMock.js';\nimport { ILogger, ILoggerService, ILogService, NullLogger, NullLogService } from '../../../../../platform/log/common/log.js';\nimport { mcpAccessConfig, McpAccessValue } from '../../../../../platform/mcp/common/mcpManagement.js';\nimport { IProductService } from '../../../../../platform/product/common/productService.js';\nimport { ISecretStorageService } from '../../../../../platform/secrets/common/secrets.js';\nimport { TestSecretStorageService } from '../../../../../platform/secrets/test/common/testSecretStorageService.js';\nimport { IStorageService, StorageScope } from '../../../../../platform/storage/common/storage.js';\nimport { IWorkspaceFolderData } from '../../../../../platform/workspace/common/workspace.js';\nimport { IConfigurationResolverService } from '../../../../services/configurationResolver/common/configurationResolver.js';\nimport { ConfigurationResolverExpression, Replacement } from '../../../../services/configurationResolver/common/configurationResolverExpression.js';\nimport { IOutputService } from '../../../../services/output/common/output.js';\nimport { TestLoggerService, TestStorageService } from '../../../../test/common/workbenchTestServices.js';\nimport { McpRegistry } from '../../common/mcpRegistry.js';\nimport { IMcpHostDelegate, IMcpMessageTransport } from '../../common/mcpRegistryTypes.js';\nimport { McpServerConnection } from '../../common/mcpServerConnection.js';\nimport { LazyCollectionState, McpCollectionDefinition, McpServerDefinition, McpServerLaunch, McpServerTransportStdio, McpServerTransportType, McpServerTrust, McpStartServerInteraction } from '../../common/mcpTypes.js';\nimport { TestMcpMessageTransport } from './mcpRegistryTypes.js';\n\nclass TestConfigurationResolverService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate interactiveCounter = 0;\n\n\t// Used to simulate stored/resolved variables\n\tprivate readonly resolvedVariables = new Map<string, string>();\n\n\tconstructor() {\n\t\t// Add some test variables\n\t\tthis.resolvedVariables.set('workspaceFolder', '/test/workspace');\n\t\tthis.resolvedVariables.set('fileBasename', 'test.txt');\n\t}\n\n\tresolveAsync<T>(folder: IWorkspaceFolderData | undefined, value: T): Promise<unknown> {\n\t\tconst parsed = ConfigurationResolverExpression.parse(value);\n\t\tfor (const variable of parsed.unresolved()) {\n\t\t\tconst resolved = this.resolvedVariables.get(variable.inner);\n\t\t\tif (resolved) {\n\t\t\t\tparsed.resolve(variable, resolved);\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.resolve(parsed.toObject());\n\t}\n\n\tresolveWithInteraction(folder: IWorkspaceFolderData | undefined, config: unknown, section?: string, variables?: Record<string, string>, target?: ConfigurationTarget): Promise<Map<string, string> | undefined> {\n\t\tconst parsed = ConfigurationResolverExpression.parse(config);\n\t\t// For testing, we simulate interaction by returning a map with some variables\n\t\tconst result = new Map<string, string>();\n\t\tresult.set('input:testInteractive', `interactiveValue${this.interactiveCounter++}`);\n\t\tresult.set('command:testCommand', `commandOutput${this.interactiveCounter++}}`);\n\n\t\t// If variables are provided, include those too\n\t\tfor (const [k, v] of result.entries()) {\n\t\t\tconst replacement: Replacement = {\n\t\t\t\tid: '${' + k + '}',\n\t\t\t\tinner: k,\n\t\t\t\tname: k.split(':')[0] || k,\n\t\t\t\targ: k.split(':')[1]\n\t\t\t};\n\t\t\tparsed.resolve(replacement, v);\n\t\t}\n\n\t\treturn Promise.resolve(result);\n\t}\n}\n\nclass TestMcpHostDelegate implements IMcpHostDelegate {\n\tpriority = 0;\n\n\tsubstituteVariables(serverDefinition: McpServerDefinition, launch: McpServerLaunch): Promise<McpServerLaunch> {\n\t\treturn Promise.resolve(launch);\n\t}\n\n\tcanStart(): boolean {\n\t\treturn true;\n\t}\n\n\tstart(): IMcpMessageTransport {\n\t\treturn new TestMcpMessageTransport();\n\t}\n\n\twaitForInitialProviderPromises(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n\nclass TestDialogService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _promptResult: boolean | undefined = true;\n\tprivate _promptSpy: sinon.SinonStub;\n\n\tconstructor() {\n\t\tthis._promptSpy = sinon.stub();\n\t\tthis._promptSpy.callsFake(() => {\n\t\t\treturn Promise.resolve({ result: this._promptResult });\n\t\t});\n\t}\n\n\tsetPromptResult(result: boolean | undefined): void {\n\t\tthis._promptResult = result;\n\t}\n\n\tget promptSpy(): sinon.SinonStub {\n\t\treturn this._promptSpy;\n\t}\n\n\tprompt<T>(options: IPrompt<T>): Promise<{ result?: T }> {\n\t\treturn this._promptSpy(options);\n\t}\n}\n\nclass TestMcpRegistry extends McpRegistry {\n\tpublic nextDefinitionIdsToTrust: string[] | undefined;\n\n\tprotected override _promptForTrustOpenDialog(): Promise<string[] | undefined> {\n\t\treturn Promise.resolve(this.nextDefinitionIdsToTrust);\n\t}\n}\n\nsuite('Workbench - MCP - Registry', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tlet registry: TestMcpRegistry;\n\tlet testStorageService: TestStorageService;\n\tlet testConfigResolverService: TestConfigurationResolverService;\n\tlet testDialogService: TestDialogService;\n\tlet testCollection: McpCollectionDefinition & { serverDefinitions: ISettableObservable<McpServerDefinition[]> };\n\tlet baseDefinition: McpServerDefinition;\n\tlet configurationService: TestConfigurationService;\n\tlet logger: ILogger;\n\tlet trustNonceBearer: { trustedAtNonce: string | undefined };\n\n\tsetup(() => {\n\t\ttestConfigResolverService = new TestConfigurationResolverService();\n\t\ttestStorageService = store.add(new TestStorageService());\n\t\ttestDialogService = new TestDialogService();\n\t\tconfigurationService = new TestConfigurationService({ [mcpAccessConfig]: McpAccessValue.All });\n\t\ttrustNonceBearer = { trustedAtNonce: undefined };\n\n\t\tconst services = new ServiceCollection(\n\t\t\t[IConfigurationService, configurationService],\n\t\t\t[IConfigurationResolverService, testConfigResolverService],\n\t\t\t[IStorageService, testStorageService],\n\t\t\t[ISecretStorageService, new TestSecretStorageService()],\n\t\t\t[ILoggerService, store.add(new TestLoggerService())],\n\t\t\t[ILogService, store.add(new NullLogService())],\n\t\t\t[IOutputService, upcast({ showChannel: () => { } })],\n\t\t\t[IDialogService, testDialogService],\n\t\t\t[IProductService, {}],\n\t\t);\n\n\t\tlogger = new NullLogger();\n\n\t\tconst instaService = store.add(new TestInstantiationService(services));\n\t\tregistry = store.add(instaService.createInstance(TestMcpRegistry));\n\n\t\t// Create test collection that can be reused\n\t\ttestCollection = {\n\t\t\tid: 'test-collection',\n\t\t\tlabel: 'Test Collection',\n\t\t\tremoteAuthority: null,\n\t\t\tserverDefinitions: observableValue('serverDefs', []),\n\t\t\ttrustBehavior: McpServerTrust.Kind.Trusted,\n\t\t\tscope: StorageScope.APPLICATION,\n\t\t\tconfigTarget: ConfigurationTarget.USER,\n\t\t};\n\n\t\t// Create base definition that can be reused\n\t\tbaseDefinition = {\n\t\t\tid: 'test-server',\n\t\t\tlabel: 'Test Server',\n\t\t\tcacheNonce: 'a',\n\t\t\tlaunch: {\n\t\t\t\ttype: McpServerTransportType.Stdio,\n\t\t\t\tcommand: 'test-command',\n\t\t\t\targs: [],\n\t\t\t\tenv: {},\n\t\t\t\tenvFile: undefined,\n\t\t\t\tcwd: '/test',\n\t\t\t}\n\t\t};\n\t});\n\n\ttest('registerCollection adds collection to registry', () => {\n\t\tconst disposable = registry.registerCollection(testCollection);\n\t\tstore.add(disposable);\n\n\t\tassert.strictEqual(registry.collections.get().length, 1);\n\t\tassert.strictEqual(registry.collections.get()[0], testCollection);\n\n\t\tdisposable.dispose();\n\t\tassert.strictEqual(registry.collections.get().length, 0);\n\t});\n\n\ttest('collections are not visible when not enabled', () => {\n\t\tconst disposable = registry.registerCollection(testCollection);\n\t\tstore.add(disposable);\n\n\t\tassert.strictEqual(registry.collections.get().length, 1);\n\n\t\tconfigurationService.setUserConfiguration(mcpAccessConfig, McpAccessValue.None);\n\t\tconfigurationService.onDidChangeConfigurationEmitter.fire({\n\t\t\taffectsConfiguration: () => true,\n\t\t\taffectedKeys: new Set([mcpAccessConfig]),\n\t\t\tchange: { keys: [mcpAccessConfig], overrides: [] },\n\t\t\tsource: ConfigurationTarget.USER\n\t\t} as IConfigurationChangeEvent); assert.strictEqual(registry.collections.get().length, 0);\n\n\t\tconfigurationService.setUserConfiguration(mcpAccessConfig, McpAccessValue.All);\n\t\tconfigurationService.onDidChangeConfigurationEmitter.fire({\n\t\t\taffectsConfiguration: () => true,\n\t\t\taffectedKeys: new Set([mcpAccessConfig]),\n\t\t\tchange: { keys: [mcpAccessConfig], overrides: [] },\n\t\t\tsource: ConfigurationTarget.USER\n\t\t} as IConfigurationChangeEvent);\n\t});\n\n\ttest('registerDelegate adds delegate to registry', () => {\n\t\tconst delegate = new TestMcpHostDelegate();\n\t\tconst disposable = registry.registerDelegate(delegate);\n\t\tstore.add(disposable);\n\n\t\tassert.strictEqual(registry.delegates.get().length, 1);\n\t\tassert.strictEqual(registry.delegates.get()[0], delegate);\n\n\t\tdisposable.dispose();\n\t\tassert.strictEqual(registry.delegates.get().length, 0);\n\t});\n\n\ttest('resolveConnection creates connection with resolved variables and memorizes them until cleared', async () => {\n\t\tconst definition: McpServerDefinition = {\n\t\t\t...baseDefinition,\n\t\t\tlaunch: {\n\t\t\t\ttype: McpServerTransportType.Stdio,\n\t\t\t\tcommand: '${workspaceFolder}/cmd',\n\t\t\t\targs: ['--file', '${fileBasename}'],\n\t\t\t\tenv: {\n\t\t\t\t\tPATH: '${input:testInteractive}'\n\t\t\t\t},\n\t\t\t\tenvFile: undefined,\n\t\t\t\tcwd: '/test',\n\t\t\t},\n\t\t\tvariableReplacement: {\n\t\t\t\tsection: 'mcp',\n\t\t\t\ttarget: ConfigurationTarget.WORKSPACE,\n\t\t\t}\n\t\t};\n\n\t\tconst delegate = new TestMcpHostDelegate();\n\t\tstore.add(registry.registerDelegate(delegate));\n\t\ttestCollection.serverDefinitions.set([definition], undefined);\n\t\tstore.add(registry.registerCollection(testCollection));\n\n\t\tconst connection = await registry.resolveConnection({ collectionRef: testCollection, definitionRef: definition, logger, trustNonceBearer }) as McpServerConnection;\n\n\t\tassert.ok(connection);\n\t\tassert.strictEqual(connection.definition, definition);\n\t\tassert.strictEqual((connection.launchDefinition as unknown as { command: string }).command, '/test/workspace/cmd');\n\t\tassert.strictEqual((connection.launchDefinition as unknown as { env: { PATH: string } }).env.PATH, 'interactiveValue0');\n\t\tconnection.dispose();\n\n\t\tconst connection2 = await registry.resolveConnection({ collectionRef: testCollection, definitionRef: definition, logger, trustNonceBearer }) as McpServerConnection;\n\n\t\tassert.ok(connection2);\n\t\tassert.strictEqual((connection2.launchDefinition as unknown as { env: { PATH: string } }).env.PATH, 'interactiveValue0');\n\t\tconnection2.dispose();\n\n\t\tregistry.clearSavedInputs(StorageScope.WORKSPACE);\n\n\t\tconst connection3 = await registry.resolveConnection({ collectionRef: testCollection, definitionRef: definition, logger, trustNonceBearer }) as McpServerConnection;\n\n\t\tassert.ok(connection3);\n\t\tassert.strictEqual((connection3.launchDefinition as unknown as { env: { PATH: string } }).env.PATH, 'interactiveValue4');\n\t\tconnection3.dispose();\n\t});\n\n\ttest('resolveConnection uses user-provided launch configuration', async () => {\n\t\t// Create a collection with custom launch resolver\n\t\tconst customCollection: McpCollectionDefinition = {\n\t\t\t...testCollection,\n\t\t\tresolveServerLanch: async (def) => {\n\t\t\t\treturn {\n\t\t\t\t\t...(def.launch as McpServerTransportStdio),\n\t\t\t\t\tenv: { CUSTOM_ENV: 'value' },\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\t// Create a definition with variable replacement\n\t\tconst definition: McpServerDefinition = {\n\t\t\t...baseDefinition,\n\t\t\tvariableReplacement: {\n\t\t\t\tsection: 'mcp',\n\t\t\t\ttarget: ConfigurationTarget.WORKSPACE,\n\t\t\t}\n\t\t};\n\n\t\tconst delegate = new TestMcpHostDelegate();\n\t\tstore.add(registry.registerDelegate(delegate));\n\t\ttestCollection.serverDefinitions.set([definition], undefined);\n\t\tstore.add(registry.registerCollection(customCollection));\n\n\t\t// Resolve connection should use the custom launch configuration\n\t\tconst connection = await registry.resolveConnection({\n\t\t\tcollectionRef: customCollection,\n\t\t\tdefinitionRef: definition,\n\t\t\tlogger,\n\t\t\ttrustNonceBearer,\n\t\t}) as McpServerConnection;\n\n\t\tassert.ok(connection);\n\n\t\t// Verify the launch configuration passed to _replaceVariablesInLaunch was the custom one\n\t\tassert.deepStrictEqual((connection.launchDefinition as McpServerTransportStdio).env, { CUSTOM_ENV: 'value' });\n\n\t\tconnection.dispose();\n\t});\n\n\tsuite('Lazy Collections', () => {\n\t\tlet lazyCollection: McpCollectionDefinition;\n\t\tlet normalCollection: McpCollectionDefinition;\n\t\tlet removedCalled: boolean;\n\n\t\tsetup(() => {\n\t\t\tremovedCalled = false;\n\t\t\tlazyCollection = {\n\t\t\t\t...testCollection,\n\t\t\t\tid: 'lazy-collection',\n\t\t\t\tlazy: {\n\t\t\t\t\tisCached: false,\n\t\t\t\t\tload: () => Promise.resolve(),\n\t\t\t\t\tremoved: () => { removedCalled = true; }\n\t\t\t\t}\n\t\t\t};\n\t\t\tnormalCollection = {\n\t\t\t\t...testCollection,\n\t\t\t\tid: 'lazy-collection',\n\t\t\t\tserverDefinitions: observableValue('serverDefs', [baseDefinition])\n\t\t\t};\n\t\t});\n\n\t\ttest('registers lazy collection', () => {\n\t\t\tconst disposable = registry.registerCollection(lazyCollection);\n\t\t\tstore.add(disposable);\n\n\t\t\tassert.strictEqual(registry.collections.get().length, 1);\n\t\t\tassert.strictEqual(registry.collections.get()[0], lazyCollection);\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.HasUnknown);\n\t\t});\n\n\t\ttest('lazy collection is replaced by normal collection', () => {\n\t\t\tstore.add(registry.registerCollection(lazyCollection));\n\t\t\tstore.add(registry.registerCollection(normalCollection));\n\n\t\t\tconst collections = registry.collections.get();\n\t\t\tassert.strictEqual(collections.length, 1);\n\t\t\tassert.strictEqual(collections[0], normalCollection);\n\t\t\tassert.strictEqual(collections[0].lazy, undefined);\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.AllKnown);\n\t\t});\n\n\t\ttest('lazyCollectionState updates correctly during loading', async () => {\n\t\t\tlazyCollection = {\n\t\t\t\t...lazyCollection,\n\t\t\t\tlazy: {\n\t\t\t\t\t...lazyCollection.lazy!,\n\t\t\t\t\tload: async () => {\n\t\t\t\t\t\tawait timeout(0);\n\t\t\t\t\t\tstore.add(registry.registerCollection(normalCollection));\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tstore.add(registry.registerCollection(lazyCollection));\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.HasUnknown);\n\n\t\t\tconst loadingPromise = registry.discoverCollections();\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.LoadingUnknown);\n\n\t\t\tawait loadingPromise;\n\n\t\t\t// The collection wasn't replaced, so it should be removed\n\t\t\tassert.strictEqual(registry.collections.get().length, 1);\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.AllKnown);\n\t\t\tassert.strictEqual(removedCalled, false);\n\t\t});\n\n\t\ttest('removed callback is called when lazy collection is not replaced', async () => {\n\t\t\tstore.add(registry.registerCollection(lazyCollection));\n\t\t\tawait registry.discoverCollections();\n\n\t\t\tassert.strictEqual(removedCalled, true);\n\t\t});\n\n\t\ttest('cached lazy collections are tracked correctly', () => {\n\t\t\tlazyCollection.lazy!.isCached = true;\n\t\t\tstore.add(registry.registerCollection(lazyCollection));\n\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.AllKnown);\n\n\t\t\t// Adding an uncached lazy collection changes the state\n\t\t\tconst uncachedLazy = {\n\t\t\t\t...lazyCollection,\n\t\t\t\tid: 'uncached-lazy',\n\t\t\t\tlazy: {\n\t\t\t\t\t...lazyCollection.lazy!,\n\t\t\t\t\tisCached: false\n\t\t\t\t}\n\t\t\t};\n\t\t\tstore.add(registry.registerCollection(uncachedLazy));\n\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.HasUnknown);\n\t\t});\n\t});\n\n\tsuite('Trust Flow', () => {\n\t\t/**\n\t\t * Helper to create a test MCP collection with a specific trust behavior\n\t\t */\n\t\tfunction createTestCollection(trustBehavior: McpServerTrust.Kind.Trusted | McpServerTrust.Kind.TrustedOnNonce, id = 'test-collection'): McpCollectionDefinition & { serverDefinitions: ISettableObservable<McpServerDefinition[]> } {\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tlabel: 'Test Collection',\n\t\t\t\tremoteAuthority: null,\n\t\t\t\tserverDefinitions: observableValue('serverDefs', []),\n\t\t\t\ttrustBehavior,\n\t\t\t\tscope: StorageScope.APPLICATION,\n\t\t\t\tconfigTarget: ConfigurationTarget.USER,\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Helper to create a test server definition with a specific cache nonce\n\t\t */\n\t\tfunction createTestDefinition(id = 'test-server', cacheNonce = 'nonce-a'): McpServerDefinition {\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tlabel: 'Test Server',\n\t\t\t\tcacheNonce,\n\t\t\t\tlaunch: {\n\t\t\t\t\ttype: McpServerTransportType.Stdio,\n\t\t\t\t\tcommand: 'test-command',\n\t\t\t\t\targs: [],\n\t\t\t\t\tenv: {},\n\t\t\t\t\tenvFile: undefined,\n\t\t\t\t\tcwd: '/test',\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Helper to set up a basic registry with delegate and collection\n\t\t */\n\t\tfunction setupRegistry(trustBehavior: McpServerTrust.Kind.Trusted | McpServerTrust.Kind.TrustedOnNonce = McpServerTrust.Kind.TrustedOnNonce, cacheNonce = 'nonce-a') {\n\t\t\tconst delegate = new TestMcpHostDelegate();\n\t\t\tstore.add(registry.registerDelegate(delegate));\n\n\t\t\tconst collection = createTestCollection(trustBehavior);\n\t\t\tconst definition = createTestDefinition('test-server', cacheNonce);\n\t\t\tcollection.serverDefinitions.set([definition], undefined);\n\t\t\tstore.add(registry.registerCollection(collection));\n\n\t\t\treturn { collection, definition, delegate };\n\t\t}\n\n\t\ttest('trusted collection allows connection without prompting', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.Trusted);\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t});\n\n\t\t\tassert.ok(connection, 'Connection should be created for trusted collection');\n\t\t\tassert.strictEqual(registry.nextDefinitionIdsToTrust, undefined, 'Trust dialog should not have been called');\n\t\t\tconnection!.dispose();\n\t\t});\n\n\t\ttest('nonce-based trust allows connection when nonce matches', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-a');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a';\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t});\n\n\t\t\tassert.ok(connection, 'Connection should be created when nonce matches');\n\t\t\tassert.strictEqual(registry.nextDefinitionIdsToTrust, undefined, 'Trust dialog should not have been called');\n\t\t\tconnection!.dispose();\n\t\t});\n\n\t\ttest('nonce-based trust prompts when nonce changes', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\t\t\tregistry.nextDefinitionIdsToTrust = [definition.id]; // User trusts the server\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t});\n\n\t\t\tassert.ok(connection, 'Connection should be created when user trusts');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, 'nonce-b', 'Nonce should be updated');\n\t\t\tconnection!.dispose();\n\t\t});\n\n\t\ttest('nonce-based trust denies connection when user rejects', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\t\t\tregistry.nextDefinitionIdsToTrust = []; // User does not trust the server\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t});\n\n\t\t\tassert.strictEqual(connection, undefined, 'Connection should not be created when user rejects');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, '__vscode_not_trusted', 'Should mark as explicitly not trusted');\n\t\t});\n\n\t\ttest('autoTrustChanges bypasses prompt when nonce changes', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t\tautoTrustChanges: true,\n\t\t\t});\n\n\t\t\tassert.ok(connection, 'Connection should be created with autoTrustChanges');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, 'nonce-b', 'Nonce should be updated');\n\t\t\tassert.strictEqual(registry.nextDefinitionIdsToTrust, undefined, 'Trust dialog should not have been called');\n\t\t\tconnection!.dispose();\n\t\t});\n\n\t\ttest('promptType \"never\" skips prompt and fails silently', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t\tpromptType: 'never',\n\t\t\t});\n\n\t\t\tassert.strictEqual(connection, undefined, 'Connection should not be created with promptType \"never\"');\n\t\t\tassert.strictEqual(registry.nextDefinitionIdsToTrust, undefined, 'Trust dialog should not have been called');\n\t\t});\n\n\t\ttest('promptType \"only-new\" skips previously untrusted servers', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = '__vscode_not_trusted'; // Previously explicitly denied\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t\tpromptType: 'only-new',\n\t\t\t});\n\n\t\t\tassert.strictEqual(connection, undefined, 'Connection should not be created for previously untrusted server');\n\t\t\tassert.strictEqual(registry.nextDefinitionIdsToTrust, undefined, 'Trust dialog should not have been called');\n\t\t});\n\n\t\ttest('promptType \"all-untrusted\" prompts for previously untrusted servers', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = '__vscode_not_trusted'; // Previously explicitly denied\n\t\t\tregistry.nextDefinitionIdsToTrust = [definition.id]; // User now trusts the server\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t\tpromptType: 'all-untrusted',\n\t\t\t});\n\n\t\t\tassert.ok(connection, 'Connection should be created when user trusts previously untrusted server');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, 'nonce-b', 'Nonce should be updated');\n\t\t\tconnection!.dispose();\n\t\t});\n\n\t\ttest('concurrent resolveConnection calls with same interaction are grouped', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\n\t\t\t// Create a second definition that also needs trust\n\t\t\tconst definition2 = createTestDefinition('test-server-2', 'nonce-c');\n\t\t\tcollection.serverDefinitions.set([definition, definition2], undefined);\n\n\t\t\t// Create shared interaction\n\t\t\tconst interaction = new McpStartServerInteraction();\n\n\t\t\t// Manually set participants as mentioned in the requirements\n\t\t\tinteraction.participants.set(definition.id, { s: 'unknown' });\n\t\t\tinteraction.participants.set(definition2.id, { s: 'unknown' });\n\n\t\t\tconst trustNonceBearer2 = { trustedAtNonce: 'nonce-b' }; // Different nonce for second server\n\n\t\t\t// Trust both servers\n\t\t\tregistry.nextDefinitionIdsToTrust = [definition.id, definition2.id];\n\n\t\t\t// Start both connections concurrently with the same interaction\n\t\t\tconst [connection1, connection2] = await Promise.all([\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer,\n\t\t\t\t\tinteraction,\n\t\t\t\t}),\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition2,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer: trustNonceBearer2,\n\t\t\t\t\tinteraction,\n\t\t\t\t})\n\t\t\t]);\n\n\t\t\tassert.ok(connection1, 'First connection should be created');\n\t\t\tassert.ok(connection2, 'Second connection should be created');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, 'nonce-b', 'First nonce should be updated');\n\t\t\tassert.strictEqual(trustNonceBearer2.trustedAtNonce, 'nonce-c', 'Second nonce should be updated');\n\n\t\t\tconnection1!.dispose();\n\t\t\tconnection2!.dispose();\n\t\t});\n\n\t\ttest('user cancelling trust dialog returns undefined for all pending connections', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\n\t\t\t// Create a second definition that also needs trust\n\t\t\tconst definition2 = createTestDefinition('test-server-2', 'nonce-c');\n\t\t\tcollection.serverDefinitions.set([definition, definition2], undefined);\n\n\t\t\t// Create shared interaction\n\t\t\tconst interaction = new McpStartServerInteraction();\n\n\t\t\t// Manually set participants as mentioned in the requirements\n\t\t\tinteraction.participants.set(definition.id, { s: 'unknown' });\n\t\t\tinteraction.participants.set(definition2.id, { s: 'unknown' });\n\n\t\t\tconst trustNonceBearer2 = { trustedAtNonce: 'nonce-b' }; // Different nonce for second server\n\n\t\t\t// User cancels the dialog\n\t\t\tregistry.nextDefinitionIdsToTrust = undefined;\n\n\t\t\t// Start both connections concurrently with the same interaction\n\t\t\tconst [connection1, connection2] = await Promise.all([\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer,\n\t\t\t\t\tinteraction,\n\t\t\t\t}),\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition2,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer: trustNonceBearer2,\n\t\t\t\t\tinteraction,\n\t\t\t\t})\n\t\t\t]);\n\n\t\t\tassert.strictEqual(connection1, undefined, 'First connection should not be created when user cancels');\n\t\t\tassert.strictEqual(connection2, undefined, 'Second connection should not be created when user cancels');\n\t\t});\n\n\t\ttest('partial trust selection in grouped interaction', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\n\t\t\t// Create a second definition that also needs trust\n\t\t\tconst definition2 = createTestDefinition('test-server-2', 'nonce-c');\n\t\t\tcollection.serverDefinitions.set([definition, definition2], undefined);\n\n\t\t\t// Create shared interaction\n\t\t\tconst interaction = new McpStartServerInteraction();\n\n\t\t\t// Manually set participants as mentioned in the requirements\n\t\t\tinteraction.participants.set(definition.id, { s: 'unknown' });\n\t\t\tinteraction.participants.set(definition2.id, { s: 'unknown' });\n\n\t\t\tconst trustNonceBearer2 = { trustedAtNonce: 'nonce-b' }; // Different nonce for second server\n\n\t\t\t// User trusts only the first server\n\t\t\tregistry.nextDefinitionIdsToTrust = [definition.id];\n\n\t\t\t// Start both connections concurrently with the same interaction\n\t\t\tconst [connection1, connection2] = await Promise.all([\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer,\n\t\t\t\t\tinteraction,\n\t\t\t\t}),\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition2,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer: trustNonceBearer2,\n\t\t\t\t\tinteraction,\n\t\t\t\t})\n\t\t\t]);\n\n\t\t\tassert.ok(connection1, 'First connection should be created when trusted');\n\t\t\tassert.strictEqual(connection2, undefined, 'Second connection should not be created when not trusted');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, 'nonce-b', 'First nonce should be updated');\n\t\t\tassert.strictEqual(trustNonceBearer2.trustedAtNonce, '__vscode_not_trusted', 'Second nonce should be marked as not trusted');\n\n\t\t\tconnection1!.dispose();\n\t\t});\n\t});\n\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport * as sinon from 'sinon';\nimport { timeout } from '../../../../../base/common/async.js';\nimport { ISettableObservable, observableValue } from '../../../../../base/common/observable.js';\nimport { upcast } from '../../../../../base/common/types.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { ConfigurationTarget, IConfigurationChangeEvent, IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { TestConfigurationService } from '../../../../../platform/configuration/test/common/testConfigurationService.js';\nimport { IDialogService, IPrompt } from '../../../../../platform/dialogs/common/dialogs.js';\nimport { ServiceCollection } from '../../../../../platform/instantiation/common/serviceCollection.js';\nimport { TestInstantiationService } from '../../../../../platform/instantiation/test/common/instantiationServiceMock.js';\nimport { ILogger, ILoggerService, ILogService, NullLogger, NullLogService } from '../../../../../platform/log/common/log.js';\nimport { mcpAccessConfig, McpAccessValue } from '../../../../../platform/mcp/common/mcpManagement.js';\nimport { IProductService } from '../../../../../platform/product/common/productService.js';\nimport { ISecretStorageService } from '../../../../../platform/secrets/common/secrets.js';\nimport { TestSecretStorageService } from '../../../../../platform/secrets/test/common/testSecretStorageService.js';\nimport { IStorageService, StorageScope } from '../../../../../platform/storage/common/storage.js';\nimport { IWorkspaceFolderData } from '../../../../../platform/workspace/common/workspace.js';\nimport { IConfigurationResolverService } from '../../../../services/configurationResolver/common/configurationResolver.js';\nimport { ConfigurationResolverExpression, Replacement } from '../../../../services/configurationResolver/common/configurationResolverExpression.js';\nimport { IOutputService } from '../../../../services/output/common/output.js';\nimport { TestLoggerService, TestStorageService } from '../../../../test/common/workbenchTestServices.js';\nimport { McpRegistry } from '../../common/mcpRegistry.js';\nimport { IMcpHostDelegate, IMcpMessageTransport } from '../../common/mcpRegistryTypes.js';\nimport { McpServerConnection } from '../../common/mcpServerConnection.js';\nimport { LazyCollectionState, McpCollectionDefinition, McpServerDefinition, McpServerLaunch, McpServerTransportStdio, McpServerTransportType, McpServerTrust, McpStartServerInteraction } from '../../common/mcpTypes.js';\nimport { TestMcpMessageTransport } from './mcpRegistryTypes.js';\n\nclass TestConfigurationResolverService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate interactiveCounter = 0;\n\n\t// Used to simulate stored/resolved variables\n\tprivate readonly resolvedVariables = new Map<string, string>();\n\n\tconstructor() {\n\t\t// Add some test variables\n\t\tthis.resolvedVariables.set('workspaceFolder', '/test/workspace');\n\t\tthis.resolvedVariables.set('fileBasename', 'test.txt');\n\t}\n\n\tresolveAsync<T>(folder: IWorkspaceFolderData | undefined, value: T): Promise<unknown> {\n\t\tconst parsed = ConfigurationResolverExpression.parse(value);\n\t\tfor (const variable of parsed.unresolved()) {\n\t\t\tconst resolved = this.resolvedVariables.get(variable.inner);\n\t\t\tif (resolved) {\n\t\t\t\tparsed.resolve(variable, resolved);\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.resolve(parsed.toObject());\n\t}\n\n\tresolveWithInteraction(folder: IWorkspaceFolderData | undefined, config: unknown, section?: string, variables?: Record<string, string>, target?: ConfigurationTarget): Promise<Map<string, string> | undefined> {\n\t\tconst parsed = ConfigurationResolverExpression.parse(config);\n\t\t// For testing, we simulate interaction by returning a map with some variables\n\t\tconst result = new Map<string, string>();\n\t\tresult.set('input:testInteractive', `interactiveValue${this.interactiveCounter++}`);\n\t\tresult.set('command:testCommand', `commandOutput${this.interactiveCounter++}}`);\n\n\t\t// If variables are provided, include those too\n\t\tfor (const [k, v] of result.entries()) {\n\t\t\tconst replacement: Replacement = {\n\t\t\t\tid: '${' + k + '}',\n\t\t\t\tinner: k,\n\t\t\t\tname: k.split(':')[0] || k,\n\t\t\t\targ: k.split(':')[1]\n\t\t\t};\n\t\t\tparsed.resolve(replacement, v);\n\t\t}\n\n\t\treturn Promise.resolve(result);\n\t}\n}\n\nclass TestMcpHostDelegate implements IMcpHostDelegate {\n\tpriority = 0;\n\n\tsubstituteVariables(serverDefinition: McpServerDefinition, launch: McpServerLaunch): Promise<McpServerLaunch> {\n\t\treturn Promise.resolve(launch);\n\t}\n\n\tcanStart(): boolean {\n\t\treturn true;\n\t}\n\n\tstart(): IMcpMessageTransport {\n\t\treturn new TestMcpMessageTransport();\n\t}\n\n\twaitForInitialProviderPromises(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n\nclass TestDialogService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _promptResult: boolean | undefined = true;\n\tprivate _promptSpy: sinon.SinonStub;\n\n\tconstructor() {\n\t\tthis._promptSpy = sinon.stub();\n\t\tthis._promptSpy.callsFake(() => {\n\t\t\treturn Promise.resolve({ result: this._promptResult });\n\t\t});\n\t}\n\n\tsetPromptResult(result: boolean | undefined): void {\n\t\tthis._promptResult = result;\n\t}\n\n\tget promptSpy(): sinon.SinonStub {\n\t\treturn this._promptSpy;\n\t}\n\n\tprompt<T>(options: IPrompt<T>): Promise<{ result?: T }> {\n\t\treturn this._promptSpy(options);\n\t}\n}\n\nclass TestMcpRegistry extends McpRegistry {\n\tpublic nextDefinitionIdsToTrust: string[] | undefined;\n\n\tprotected override _promptForTrustOpenDialog(): Promise<string[] | undefined> {\n\t\treturn Promise.resolve(this.nextDefinitionIdsToTrust);\n\t}\n}\n\nsuite('Workbench - MCP - Registry', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tlet registry: TestMcpRegistry;\n\tlet testStorageService: TestStorageService;\n\tlet testConfigResolverService: TestConfigurationResolverService;\n\tlet testDialogService: TestDialogService;\n\tlet testCollection: McpCollectionDefinition & { serverDefinitions: ISettableObservable<McpServerDefinition[]> };\n\tlet baseDefinition: McpServerDefinition;\n\tlet configurationService: TestConfigurationService;\n\tlet logger: ILogger;\n\tlet trustNonceBearer: { trustedAtNonce: string | undefined };\n\n\tsetup(() => {\n\t\ttestConfigResolverService = new TestConfigurationResolverService();\n\t\ttestStorageService = store.add(new TestStorageService());\n\t\ttestDialogService = new TestDialogService();\n\t\tconfigurationService = new TestConfigurationService({ [mcpAccessConfig]: McpAccessValue.All });\n\t\ttrustNonceBearer = { trustedAtNonce: undefined };\n\n\t\tconst services = new ServiceCollection(\n\t\t\t[IConfigurationService, configurationService],\n\t\t\t[IConfigurationResolverService, testConfigResolverService],\n\t\t\t[IStorageService, testStorageService],\n\t\t\t[ISecretStorageService, new TestSecretStorageService()],\n\t\t\t[ILoggerService, store.add(new TestLoggerService())],\n\t\t\t[ILogService, store.add(new NullLogService())],\n\t\t\t[IOutputService, upcast({ showChannel: () => { } })],\n\t\t\t[IDialogService, testDialogService],\n\t\t\t[IProductService, {}],\n\t\t);\n\n\t\tlogger = new NullLogger();\n\n\t\tconst instaService = store.add(new TestInstantiationService(services));\n\t\tregistry = store.add(instaService.createInstance(TestMcpRegistry));\n\n\t\t// Create test collection that can be reused\n\t\ttestCollection = {\n\t\t\tid: 'test-collection',\n\t\t\tlabel: 'Test Collection',\n\t\t\tremoteAuthority: null,\n\t\t\tserverDefinitions: observableValue('serverDefs', []),\n\t\t\ttrustBehavior: McpServerTrust.Kind.Trusted,\n\t\t\tscope: StorageScope.APPLICATION,\n\t\t\tconfigTarget: ConfigurationTarget.USER,\n\t\t};\n\n\t\t// Create base definition that can be reused\n\t\tbaseDefinition = {\n\t\t\tid: 'test-server',\n\t\t\tlabel: 'Test Server',\n\t\t\tcacheNonce: 'a',\n\t\t\tlaunch: {\n\t\t\t\ttype: McpServerTransportType.Stdio,\n\t\t\t\tcommand: 'test-command',\n\t\t\t\targs: [],\n\t\t\t\tenv: {},\n\t\t\t\tenvFile: undefined,\n\t\t\t\tcwd: '/test',\n\t\t\t}\n\t\t};\n\t});\n\n\ttest('registerCollection adds collection to registry', () => {\n\t\tconst disposable = registry.registerCollection(testCollection);\n\t\tstore.add(disposable);\n\n\t\tassert.strictEqual(registry.collections.get().length, 1);\n\t\tassert.strictEqual(registry.collections.get()[0], testCollection);\n\n\t\tdisposable.dispose();\n\t\tassert.strictEqual(registry.collections.get().length, 0);\n\t});\n\n\ttest('collections are not visible when not enabled', () => {\n\t\tconst disposable = registry.registerCollection(testCollection);\n\t\tstore.add(disposable);\n\n\t\tassert.strictEqual(registry.collections.get().length, 1);\n\n\t\tconfigurationService.setUserConfiguration(mcpAccessConfig, McpAccessValue.None);\n\t\tconfigurationService.onDidChangeConfigurationEmitter.fire({\n\t\t\taffectsConfiguration: () => true,\n\t\t\taffectedKeys: new Set([mcpAccessConfig]),\n\t\t\tchange: { keys: [mcpAccessConfig], overrides: [] },\n\t\t\tsource: ConfigurationTarget.USER\n\t\t} as IConfigurationChangeEvent); assert.strictEqual(registry.collections.get().length, 0);\n\n\t\tconfigurationService.setUserConfiguration(mcpAccessConfig, McpAccessValue.All);\n\t\tconfigurationService.onDidChangeConfigurationEmitter.fire({\n\t\t\taffectsConfiguration: () => true,\n\t\t\taffectedKeys: new Set([mcpAccessConfig]),\n\t\t\tchange: { keys: [mcpAccessConfig], overrides: [] },\n\t\t\tsource: ConfigurationTarget.USER\n\t\t} as IConfigurationChangeEvent);\n\t});\n\n\ttest('registerDelegate adds delegate to registry', () => {\n\t\tconst delegate = new TestMcpHostDelegate();\n\t\tconst disposable = registry.registerDelegate(delegate);\n\t\tstore.add(disposable);\n\n\t\tassert.strictEqual(registry.delegates.get().length, 1);\n\t\tassert.strictEqual(registry.delegates.get()[0], delegate);\n\n\t\tdisposable.dispose();\n\t\tassert.strictEqual(registry.delegates.get().length, 0);\n\t});\n\n\ttest('resolveConnection creates connection with resolved variables and memorizes them until cleared', async () => {\n\t\tconst definition: McpServerDefinition = {\n\t\t\t...baseDefinition,\n\t\t\tlaunch: {\n\t\t\t\ttype: McpServerTransportType.Stdio,\n\t\t\t\tcommand: '${workspaceFolder}/cmd',\n\t\t\t\targs: ['--file', '${fileBasename}'],\n\t\t\t\tenv: {\n\t\t\t\t\tPATH: '${input:testInteractive}'\n\t\t\t\t},\n\t\t\t\tenvFile: undefined,\n\t\t\t\tcwd: '/test',\n\t\t\t},\n\t\t\tvariableReplacement: {\n\t\t\t\tsection: 'mcp',\n\t\t\t\ttarget: ConfigurationTarget.WORKSPACE,\n\t\t\t}\n\t\t};\n\n\t\tconst delegate = new TestMcpHostDelegate();\n\t\tstore.add(registry.registerDelegate(delegate));\n\t\ttestCollection.serverDefinitions.set([definition], undefined);\n\t\tstore.add(registry.registerCollection(testCollection));\n\n\t\tconst connection = await registry.resolveConnection({ collectionRef: testCollection, definitionRef: definition, logger, trustNonceBearer }) as McpServerConnection;\n\n\t\tassert.ok(connection);\n\t\tassert.strictEqual(connection.definition, definition);\n\t\tassert.strictEqual((connection.launchDefinition as unknown as { command: string }).command, '/test/workspace/cmd');\n\t\tassert.strictEqual((connection.launchDefinition as unknown as { env: { PATH: string } }).env.PATH, 'interactiveValue0');\n\t\tconnection.dispose();\n\n\t\tconst connection2 = await registry.resolveConnection({ collectionRef: testCollection, definitionRef: definition, logger, trustNonceBearer }) as McpServerConnection;\n\n\t\tassert.ok(connection2);\n\t\tassert.strictEqual((connection2.launchDefinition as unknown as { env: { PATH: string } }).env.PATH, 'interactiveValue0');\n\t\tconnection2.dispose();\n\n\t\tregistry.clearSavedInputs(StorageScope.WORKSPACE);\n\n\t\tconst connection3 = await registry.resolveConnection({ collectionRef: testCollection, definitionRef: definition, logger, trustNonceBearer }) as McpServerConnection;\n\n\t\tassert.ok(connection3);\n\t\tassert.strictEqual((connection3.launchDefinition as unknown as { env: { PATH: string } }).env.PATH, 'interactiveValue4');\n\t\tconnection3.dispose();\n\t});\n\n\ttest('resolveConnection uses user-provided launch configuration', async () => {\n\t\t// Create a collection with custom launch resolver\n\t\tconst customCollection: McpCollectionDefinition = {\n\t\t\t...testCollection,\n\t\t\tresolveServerLanch: async (def) => {\n\t\t\t\treturn {\n\t\t\t\t\t...(def.launch as McpServerTransportStdio),\n\t\t\t\t\tenv: { CUSTOM_ENV: 'value' },\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\t// Create a definition with variable replacement\n\t\tconst definition: McpServerDefinition = {\n\t\t\t...baseDefinition,\n\t\t\tvariableReplacement: {\n\t\t\t\tsection: 'mcp',\n\t\t\t\ttarget: ConfigurationTarget.WORKSPACE,\n\t\t\t}\n\t\t};\n\n\t\tconst delegate = new TestMcpHostDelegate();\n\t\tstore.add(registry.registerDelegate(delegate));\n\t\ttestCollection.serverDefinitions.set([definition], undefined);\n\t\tstore.add(registry.registerCollection(customCollection));\n\n\t\t// Resolve connection should use the custom launch configuration\n\t\tconst connection = await registry.resolveConnection({\n\t\t\tcollectionRef: customCollection,\n\t\t\tdefinitionRef: definition,\n\t\t\tlogger,\n\t\t\ttrustNonceBearer,\n\t\t}) as McpServerConnection;\n\n\t\tassert.ok(connection);\n\n\t\t// Verify the launch configuration passed to _replaceVariablesInLaunch was the custom one\n\t\tassert.deepStrictEqual((connection.launchDefinition as McpServerTransportStdio).env, { CUSTOM_ENV: 'value' });\n\n\t\tconnection.dispose();\n\t});\n\n\tsuite('Lazy Collections', () => {\n\t\tlet lazyCollection: McpCollectionDefinition;\n\t\tlet normalCollection: McpCollectionDefinition;\n\t\tlet removedCalled: boolean;\n\n\t\tsetup(() => {\n\t\t\tremovedCalled = false;\n\t\t\tlazyCollection = {\n\t\t\t\t...testCollection,\n\t\t\t\tid: 'lazy-collection',\n\t\t\t\tlazy: {\n\t\t\t\t\tisCached: false,\n\t\t\t\t\tload: () => Promise.resolve(),\n\t\t\t\t\tremoved: () => { removedCalled = true; }\n\t\t\t\t}\n\t\t\t};\n\t\t\tnormalCollection = {\n\t\t\t\t...testCollection,\n\t\t\t\tid: 'lazy-collection',\n\t\t\t\tserverDefinitions: observableValue('serverDefs', [baseDefinition])\n\t\t\t};\n\t\t});\n\n\t\ttest('registers lazy collection', () => {\n\t\t\tconst disposable = registry.registerCollection(lazyCollection);\n\t\t\tstore.add(disposable);\n\n\t\t\tassert.strictEqual(registry.collections.get().length, 1);\n\t\t\tassert.strictEqual(registry.collections.get()[0], lazyCollection);\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.HasUnknown);\n\t\t});\n\n\t\ttest('lazy collection is replaced by normal collection', () => {\n\t\t\tstore.add(registry.registerCollection(lazyCollection));\n\t\t\tstore.add(registry.registerCollection(normalCollection));\n\n\t\t\tconst collections = registry.collections.get();\n\t\t\tassert.strictEqual(collections.length, 1);\n\t\t\tassert.strictEqual(collections[0], normalCollection);\n\t\t\tassert.strictEqual(collections[0].lazy, undefined);\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.AllKnown);\n\t\t});\n\n\t\ttest('lazyCollectionState updates correctly during loading', async () => {\n\t\t\tlazyCollection = {\n\t\t\t\t...lazyCollection,\n\t\t\t\tlazy: {\n\t\t\t\t\t...lazyCollection.lazy!,\n\t\t\t\t\tload: async () => {\n\t\t\t\t\t\tawait timeout(0);\n\t\t\t\t\t\tstore.add(registry.registerCollection(normalCollection));\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tstore.add(registry.registerCollection(lazyCollection));\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.HasUnknown);\n\n\t\t\tconst loadingPromise = registry.discoverCollections();\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.LoadingUnknown);\n\n\t\t\tawait loadingPromise;\n\n\t\t\t// The collection wasn't replaced, so it should be removed\n\t\t\tassert.strictEqual(registry.collections.get().length, 1);\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.AllKnown);\n\t\t\tassert.strictEqual(removedCalled, false);\n\t\t});\n\n\t\ttest('removed callback is called when lazy collection is not replaced', async () => {\n\t\t\tstore.add(registry.registerCollection(lazyCollection));\n\t\t\tawait registry.discoverCollections();\n\n\t\t\tassert.strictEqual(removedCalled, true);\n\t\t});\n\n\t\ttest('cached lazy collections are tracked correctly', () => {\n\t\t\tlazyCollection.lazy!.isCached = true;\n\t\t\tstore.add(registry.registerCollection(lazyCollection));\n\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.AllKnown);\n\n\t\t\t// Adding an uncached lazy collection changes the state\n\t\t\tconst uncachedLazy = {\n\t\t\t\t...lazyCollection,\n\t\t\t\tid: 'uncached-lazy',\n\t\t\t\tlazy: {\n\t\t\t\t\t...lazyCollection.lazy!,\n\t\t\t\t\tisCached: false\n\t\t\t\t}\n\t\t\t};\n\t\t\tstore.add(registry.registerCollection(uncachedLazy));\n\n\t\t\tassert.strictEqual(registry.lazyCollectionState.get().state, LazyCollectionState.HasUnknown);\n\t\t});\n\t});\n\n\tsuite('Trust Flow', () => {\n\t\t/**\n\t\t * Helper to create a test MCP collection with a specific trust behavior\n\t\t */\n\t\tfunction createTestCollection(trustBehavior: McpServerTrust.Kind.Trusted | McpServerTrust.Kind.TrustedOnNonce, id = 'test-collection'): McpCollectionDefinition & { serverDefinitions: ISettableObservable<McpServerDefinition[]> } {\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tlabel: 'Test Collection',\n\t\t\t\tremoteAuthority: null,\n\t\t\t\tserverDefinitions: observableValue('serverDefs', []),\n\t\t\t\ttrustBehavior,\n\t\t\t\tscope: StorageScope.APPLICATION,\n\t\t\t\tconfigTarget: ConfigurationTarget.USER,\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Helper to create a test server definition with a specific cache nonce\n\t\t */\n\t\tfunction createTestDefinition(id = 'test-server', cacheNonce = 'nonce-a'): McpServerDefinition {\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tlabel: 'Test Server',\n\t\t\t\tcacheNonce,\n\t\t\t\tlaunch: {\n\t\t\t\t\ttype: McpServerTransportType.Stdio,\n\t\t\t\t\tcommand: 'test-command',\n\t\t\t\t\targs: [],\n\t\t\t\t\tenv: {},\n\t\t\t\t\tenvFile: undefined,\n\t\t\t\t\tcwd: '/test',\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Helper to set up a basic registry with delegate and collection\n\t\t */\n\t\tfunction setupRegistry(trustBehavior: McpServerTrust.Kind.Trusted | McpServerTrust.Kind.TrustedOnNonce = McpServerTrust.Kind.TrustedOnNonce, cacheNonce = 'nonce-a') {\n\t\t\tconst delegate = new TestMcpHostDelegate();\n\t\t\tstore.add(registry.registerDelegate(delegate));\n\n\t\t\tconst collection = createTestCollection(trustBehavior);\n\t\t\tconst definition = createTestDefinition('test-server', cacheNonce);\n\t\t\tcollection.serverDefinitions.set([definition], undefined);\n\t\t\tstore.add(registry.registerCollection(collection));\n\n\t\t\treturn { collection, definition, delegate };\n\t\t}\n\n\t\ttest('trusted collection allows connection without prompting', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.Trusted);\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t});\n\n\t\t\tassert.ok(connection, 'Connection should be created for trusted collection');\n\t\t\tassert.strictEqual(registry.nextDefinitionIdsToTrust, undefined, 'Trust dialog should not have been called');\n\t\t\tconnection!.dispose();\n\t\t});\n\n\t\ttest('nonce-based trust allows connection when nonce matches', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-a');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a';\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t});\n\n\t\t\tassert.ok(connection, 'Connection should be created when nonce matches');\n\t\t\tassert.strictEqual(registry.nextDefinitionIdsToTrust, undefined, 'Trust dialog should not have been called');\n\t\t\tconnection!.dispose();\n\t\t});\n\n\t\ttest('nonce-based trust prompts when nonce changes', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\t\t\tregistry.nextDefinitionIdsToTrust = [definition.id]; // User trusts the server\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t});\n\n\t\t\tassert.ok(connection, 'Connection should be created when user trusts');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, 'nonce-b', 'Nonce should be updated');\n\t\t\tconnection!.dispose();\n\t\t});\n\n\t\ttest('nonce-based trust denies connection when user rejects', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\t\t\tregistry.nextDefinitionIdsToTrust = []; // User does not trust the server\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t});\n\n\t\t\tassert.strictEqual(connection, undefined, 'Connection should not be created when user rejects');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, '__vscode_not_trusted', 'Should mark as explicitly not trusted');\n\t\t});\n\n\t\ttest('autoTrustChanges bypasses prompt when nonce changes', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t\tautoTrustChanges: true,\n\t\t\t});\n\n\t\t\tassert.ok(connection, 'Connection should be created with autoTrustChanges');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, 'nonce-b', 'Nonce should be updated');\n\t\t\tassert.strictEqual(registry.nextDefinitionIdsToTrust, undefined, 'Trust dialog should not have been called');\n\t\t\tconnection!.dispose();\n\t\t});\n\n\t\ttest('promptType \"never\" skips prompt and fails silently', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t\tpromptType: 'never',\n\t\t\t});\n\n\t\t\tassert.strictEqual(connection, undefined, 'Connection should not be created with promptType \"never\"');\n\t\t\tassert.strictEqual(registry.nextDefinitionIdsToTrust, undefined, 'Trust dialog should not have been called');\n\t\t});\n\n\t\ttest('promptType \"only-new\" skips previously untrusted servers', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = '__vscode_not_trusted'; // Previously explicitly denied\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t\tpromptType: 'only-new',\n\t\t\t});\n\n\t\t\tassert.strictEqual(connection, undefined, 'Connection should not be created for previously untrusted server');\n\t\t\tassert.strictEqual(registry.nextDefinitionIdsToTrust, undefined, 'Trust dialog should not have been called');\n\t\t});\n\n\t\ttest('promptType \"all-untrusted\" prompts for previously untrusted servers', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = '__vscode_not_trusted'; // Previously explicitly denied\n\t\t\tregistry.nextDefinitionIdsToTrust = [definition.id]; // User now trusts the server\n\n\t\t\tconst connection = await registry.resolveConnection({\n\t\t\t\tcollectionRef: collection,\n\t\t\t\tdefinitionRef: definition,\n\t\t\t\tlogger,\n\t\t\t\ttrustNonceBearer,\n\t\t\t\tpromptType: 'all-untrusted',\n\t\t\t});\n\n\t\t\tassert.ok(connection, 'Connection should be created when user trusts previously untrusted server');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, 'nonce-b', 'Nonce should be updated');\n\t\t\tconnection!.dispose();\n\t\t});\n\n\t\ttest('concurrent resolveConnection calls with same interaction are grouped', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\n\t\t\t// Create a second definition that also needs trust\n\t\t\tconst definition2 = createTestDefinition('test-server-2', 'nonce-c');\n\t\t\tcollection.serverDefinitions.set([definition, definition2], undefined);\n\n\t\t\t// Create shared interaction\n\t\t\tconst interaction = new McpStartServerInteraction();\n\n\t\t\t// Manually set participants as mentioned in the requirements\n\t\t\tinteraction.participants.set(definition.id, { s: 'unknown' });\n\t\t\tinteraction.participants.set(definition2.id, { s: 'unknown' });\n\n\t\t\tconst trustNonceBearer2 = { trustedAtNonce: 'nonce-b' }; // Different nonce for second server\n\n\t\t\t// Trust both servers\n\t\t\tregistry.nextDefinitionIdsToTrust = [definition.id, definition2.id];\n\n\t\t\t// Start both connections concurrently with the same interaction\n\t\t\tconst [connection1, connection2] = await Promise.all([\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer,\n\t\t\t\t\tinteraction,\n\t\t\t\t}),\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition2,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer: trustNonceBearer2,\n\t\t\t\t\tinteraction,\n\t\t\t\t})\n\t\t\t]);\n\n\t\t\tassert.ok(connection1, 'First connection should be created');\n\t\t\tassert.ok(connection2, 'Second connection should be created');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, 'nonce-b', 'First nonce should be updated');\n\t\t\tassert.strictEqual(trustNonceBearer2.trustedAtNonce, 'nonce-c', 'Second nonce should be updated');\n\n\t\t\tconnection1!.dispose();\n\t\t\tconnection2!.dispose();\n\t\t});\n\n\t\ttest('user cancelling trust dialog returns undefined for all pending connections', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\n\t\t\t// Create a second definition that also needs trust\n\t\t\tconst definition2 = createTestDefinition('test-server-2', 'nonce-c');\n\t\t\tcollection.serverDefinitions.set([definition, definition2], undefined);\n\n\t\t\t// Create shared interaction\n\t\t\tconst interaction = new McpStartServerInteraction();\n\n\t\t\t// Manually set participants as mentioned in the requirements\n\t\t\tinteraction.participants.set(definition.id, { s: 'unknown' });\n\t\t\tinteraction.participants.set(definition2.id, { s: 'unknown' });\n\n\t\t\tconst trustNonceBearer2 = { trustedAtNonce: 'nonce-b' }; // Different nonce for second server\n\n\t\t\t// User cancels the dialog\n\t\t\tregistry.nextDefinitionIdsToTrust = undefined;\n\n\t\t\t// Start both connections concurrently with the same interaction\n\t\t\tconst [connection1, connection2] = await Promise.all([\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer,\n\t\t\t\t\tinteraction,\n\t\t\t\t}),\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition2,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer: trustNonceBearer2,\n\t\t\t\t\tinteraction,\n\t\t\t\t})\n\t\t\t]);\n\n\t\t\tassert.strictEqual(connection1, undefined, 'First connection should not be created when user cancels');\n\t\t\tassert.strictEqual(connection2, undefined, 'Second connection should not be created when user cancels');\n\t\t});\n\n\t\ttest('partial trust selection in grouped interaction', async () => {\n\t\t\tconst { collection, definition } = setupRegistry(McpServerTrust.Kind.TrustedOnNonce, 'nonce-b');\n\t\t\ttrustNonceBearer.trustedAtNonce = 'nonce-a'; // Different nonce\n\n\t\t\t// Create a second definition that also needs trust\n\t\t\tconst definition2 = createTestDefinition('test-server-2', 'nonce-c');\n\t\t\tcollection.serverDefinitions.set([definition, definition2], undefined);\n\n\t\t\t// Create shared interaction\n\t\t\tconst interaction = new McpStartServerInteraction();\n\n\t\t\t// Manually set participants as mentioned in the requirements\n\t\t\tinteraction.participants.set(definition.id, { s: 'unknown' });\n\t\t\tinteraction.participants.set(definition2.id, { s: 'unknown' });\n\n\t\t\tconst trustNonceBearer2 = { trustedAtNonce: 'nonce-b' }; // Different nonce for second server\n\n\t\t\t// User trusts only the first server\n\t\t\tregistry.nextDefinitionIdsToTrust = [definition.id];\n\n\t\t\t// Start both connections concurrently with the same interaction\n\t\t\tconst [connection1, connection2] = await Promise.all([\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer,\n\t\t\t\t\tinteraction,\n\t\t\t\t}),\n\t\t\t\tregistry.resolveConnection({\n\t\t\t\t\tcollectionRef: collection,\n\t\t\t\t\tdefinitionRef: definition2,\n\t\t\t\t\tlogger,\n\t\t\t\t\ttrustNonceBearer: trustNonceBearer2,\n\t\t\t\t\tinteraction,\n\t\t\t\t})\n\t\t\t]);\n\n\t\t\tassert.ok(connection1, 'First connection should be created when trusted');\n\t\t\tassert.strictEqual(connection2, undefined, 'Second connection should not be created when not trusted');\n\t\t\tassert.strictEqual(trustNonceBearer.trustedAtNonce, 'nonce-b', 'First nonce should be updated');\n\t\t\tassert.strictEqual(trustNonceBearer2.trustedAtNonce, '__vscode_not_trusted', 'Second nonce should be marked as not trusted');\n\n\t\t\tconnection1!.dispose();\n\t\t});\n\t});\n\n});\n"]}