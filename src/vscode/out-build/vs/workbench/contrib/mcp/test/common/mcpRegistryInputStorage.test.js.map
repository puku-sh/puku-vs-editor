{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/test/common/mcpRegistryInputStorage.test.ts","vs/workbench/contrib/mcp/test/common/mcpRegistryInputStorage.test.ts"],"names":[],"mappings":"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","file":"mcpRegistryInputStorage.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { ILogService, NullLogService } from '../../../../../platform/log/common/log.js';\nimport { TestSecretStorageService } from '../../../../../platform/secrets/test/common/testSecretStorageService.js';\nimport { StorageScope, StorageTarget } from '../../../../../platform/storage/common/storage.js';\nimport { TestStorageService } from '../../../../test/common/workbenchTestServices.js';\nimport { McpRegistryInputStorage } from '../../common/mcpRegistryInputStorage.js';\n\nsuite('Workbench - MCP - RegistryInputStorage', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tlet testStorageService: TestStorageService;\n\tlet testSecretStorageService: TestSecretStorageService;\n\tlet testLogService: ILogService;\n\tlet mcpInputStorage: McpRegistryInputStorage;\n\n\tsetup(() => {\n\t\ttestStorageService = store.add(new TestStorageService());\n\t\ttestSecretStorageService = new TestSecretStorageService();\n\t\ttestLogService = store.add(new NullLogService());\n\n\t\t// Create the input storage with APPLICATION scope\n\t\tmcpInputStorage = store.add(new McpRegistryInputStorage(\n\t\t\tStorageScope.APPLICATION,\n\t\t\tStorageTarget.MACHINE,\n\t\t\ttestStorageService,\n\t\t\ttestSecretStorageService,\n\t\t\ttestLogService\n\t\t));\n\t});\n\n\ttest('setPlainText stores values that can be retrieved with getMap', async () => {\n\t\tconst values = {\n\t\t\t'key1': { value: 'value1' },\n\t\t\t'key2': { value: 'value2' }\n\t\t};\n\n\t\tawait mcpInputStorage.setPlainText(values);\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.key1.value, 'value1');\n\t\tassert.strictEqual(result.key2.value, 'value2');\n\t});\n\n\ttest('setSecrets stores encrypted values that can be retrieved with getMap', async () => {\n\t\tconst secrets = {\n\t\t\t'secretKey1': { value: 'secretValue1' },\n\t\t\t'secretKey2': { value: 'secretValue2' }\n\t\t};\n\n\t\tawait mcpInputStorage.setSecrets(secrets);\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.secretKey1.value, 'secretValue1');\n\t\tassert.strictEqual(result.secretKey2.value, 'secretValue2');\n\t});\n\n\ttest('getMap returns combined plain text and secret values', async () => {\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'plainKey': { value: 'plainValue' }\n\t\t});\n\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey': { value: 'secretValue' }\n\t\t});\n\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.plainKey.value, 'plainValue');\n\t\tassert.strictEqual(result.secretKey.value, 'secretValue');\n\t});\n\n\ttest('clear removes specific values', async () => {\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'key1': { value: 'value1' },\n\t\t\t'key2': { value: 'value2' }\n\t\t});\n\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey1': { value: 'secretValue1' },\n\t\t\t'secretKey2': { value: 'secretValue2' }\n\t\t});\n\n\t\t// Clear one plain and one secret value\n\t\tawait mcpInputStorage.clear('key1');\n\t\tawait mcpInputStorage.clear('secretKey1');\n\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.key1, undefined);\n\t\tassert.strictEqual(result.key2.value, 'value2');\n\t\tassert.strictEqual(result.secretKey1, undefined);\n\t\tassert.strictEqual(result.secretKey2.value, 'secretValue2');\n\t});\n\n\ttest('clearAll removes all values', async () => {\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'key1': { value: 'value1' }\n\t\t});\n\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey1': { value: 'secretValue1' }\n\t\t});\n\n\t\tmcpInputStorage.clearAll();\n\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.deepStrictEqual(result, {});\n\t});\n\n\ttest('updates to plain text values overwrite existing values', async () => {\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'key1': { value: 'value1' },\n\t\t\t'key2': { value: 'value2' }\n\t\t});\n\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'key1': { value: 'updatedValue1' }\n\t\t});\n\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.key1.value, 'updatedValue1');\n\t\tassert.strictEqual(result.key2.value, 'value2');\n\t});\n\n\ttest('updates to secret values overwrite existing values', async () => {\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey1': { value: 'secretValue1' },\n\t\t\t'secretKey2': { value: 'secretValue2' }\n\t\t});\n\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey1': { value: 'updatedSecretValue1' }\n\t\t});\n\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.secretKey1.value, 'updatedSecretValue1');\n\t\tassert.strictEqual(result.secretKey2.value, 'secretValue2');\n\t});\n\n\ttest('storage persists values across instances', async () => {\n\t\t// Set values on first instance\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'key1': { value: 'value1' }\n\t\t});\n\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey1': { value: 'secretValue1' }\n\t\t});\n\n\t\tawait testStorageService.flush();\n\n\t\t// Create a second instance that should have access to the same storage\n\t\tconst secondInstance = store.add(new McpRegistryInputStorage(\n\t\t\tStorageScope.APPLICATION,\n\t\t\tStorageTarget.MACHINE,\n\t\t\ttestStorageService,\n\t\t\ttestSecretStorageService,\n\t\t\ttestLogService\n\t\t));\n\n\t\tconst result = await secondInstance.getMap();\n\n\t\tassert.strictEqual(result.key1.value, 'value1');\n\t\tassert.strictEqual(result.secretKey1.value, 'secretValue1');\n\n\t\tassert.ok(!testStorageService.get('mcpInputs', StorageScope.APPLICATION)?.includes('secretValue1'));\n\t});\n});\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { ILogService, NullLogService } from '../../../../../platform/log/common/log.js';\nimport { TestSecretStorageService } from '../../../../../platform/secrets/test/common/testSecretStorageService.js';\nimport { StorageScope, StorageTarget } from '../../../../../platform/storage/common/storage.js';\nimport { TestStorageService } from '../../../../test/common/workbenchTestServices.js';\nimport { McpRegistryInputStorage } from '../../common/mcpRegistryInputStorage.js';\n\nsuite('Workbench - MCP - RegistryInputStorage', () => {\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tlet testStorageService: TestStorageService;\n\tlet testSecretStorageService: TestSecretStorageService;\n\tlet testLogService: ILogService;\n\tlet mcpInputStorage: McpRegistryInputStorage;\n\n\tsetup(() => {\n\t\ttestStorageService = store.add(new TestStorageService());\n\t\ttestSecretStorageService = new TestSecretStorageService();\n\t\ttestLogService = store.add(new NullLogService());\n\n\t\t// Create the input storage with APPLICATION scope\n\t\tmcpInputStorage = store.add(new McpRegistryInputStorage(\n\t\t\tStorageScope.APPLICATION,\n\t\t\tStorageTarget.MACHINE,\n\t\t\ttestStorageService,\n\t\t\ttestSecretStorageService,\n\t\t\ttestLogService\n\t\t));\n\t});\n\n\ttest('setPlainText stores values that can be retrieved with getMap', async () => {\n\t\tconst values = {\n\t\t\t'key1': { value: 'value1' },\n\t\t\t'key2': { value: 'value2' }\n\t\t};\n\n\t\tawait mcpInputStorage.setPlainText(values);\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.key1.value, 'value1');\n\t\tassert.strictEqual(result.key2.value, 'value2');\n\t});\n\n\ttest('setSecrets stores encrypted values that can be retrieved with getMap', async () => {\n\t\tconst secrets = {\n\t\t\t'secretKey1': { value: 'secretValue1' },\n\t\t\t'secretKey2': { value: 'secretValue2' }\n\t\t};\n\n\t\tawait mcpInputStorage.setSecrets(secrets);\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.secretKey1.value, 'secretValue1');\n\t\tassert.strictEqual(result.secretKey2.value, 'secretValue2');\n\t});\n\n\ttest('getMap returns combined plain text and secret values', async () => {\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'plainKey': { value: 'plainValue' }\n\t\t});\n\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey': { value: 'secretValue' }\n\t\t});\n\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.plainKey.value, 'plainValue');\n\t\tassert.strictEqual(result.secretKey.value, 'secretValue');\n\t});\n\n\ttest('clear removes specific values', async () => {\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'key1': { value: 'value1' },\n\t\t\t'key2': { value: 'value2' }\n\t\t});\n\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey1': { value: 'secretValue1' },\n\t\t\t'secretKey2': { value: 'secretValue2' }\n\t\t});\n\n\t\t// Clear one plain and one secret value\n\t\tawait mcpInputStorage.clear('key1');\n\t\tawait mcpInputStorage.clear('secretKey1');\n\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.key1, undefined);\n\t\tassert.strictEqual(result.key2.value, 'value2');\n\t\tassert.strictEqual(result.secretKey1, undefined);\n\t\tassert.strictEqual(result.secretKey2.value, 'secretValue2');\n\t});\n\n\ttest('clearAll removes all values', async () => {\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'key1': { value: 'value1' }\n\t\t});\n\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey1': { value: 'secretValue1' }\n\t\t});\n\n\t\tmcpInputStorage.clearAll();\n\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.deepStrictEqual(result, {});\n\t});\n\n\ttest('updates to plain text values overwrite existing values', async () => {\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'key1': { value: 'value1' },\n\t\t\t'key2': { value: 'value2' }\n\t\t});\n\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'key1': { value: 'updatedValue1' }\n\t\t});\n\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.key1.value, 'updatedValue1');\n\t\tassert.strictEqual(result.key2.value, 'value2');\n\t});\n\n\ttest('updates to secret values overwrite existing values', async () => {\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey1': { value: 'secretValue1' },\n\t\t\t'secretKey2': { value: 'secretValue2' }\n\t\t});\n\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey1': { value: 'updatedSecretValue1' }\n\t\t});\n\n\t\tconst result = await mcpInputStorage.getMap();\n\n\t\tassert.strictEqual(result.secretKey1.value, 'updatedSecretValue1');\n\t\tassert.strictEqual(result.secretKey2.value, 'secretValue2');\n\t});\n\n\ttest('storage persists values across instances', async () => {\n\t\t// Set values on first instance\n\t\tawait mcpInputStorage.setPlainText({\n\t\t\t'key1': { value: 'value1' }\n\t\t});\n\n\t\tawait mcpInputStorage.setSecrets({\n\t\t\t'secretKey1': { value: 'secretValue1' }\n\t\t});\n\n\t\tawait testStorageService.flush();\n\n\t\t// Create a second instance that should have access to the same storage\n\t\tconst secondInstance = store.add(new McpRegistryInputStorage(\n\t\t\tStorageScope.APPLICATION,\n\t\t\tStorageTarget.MACHINE,\n\t\t\ttestStorageService,\n\t\t\ttestSecretStorageService,\n\t\t\ttestLogService\n\t\t));\n\n\t\tconst result = await secondInstance.getMap();\n\n\t\tassert.strictEqual(result.key1.value, 'value1');\n\t\tassert.strictEqual(result.secretKey1.value, 'secretValue1');\n\n\t\tassert.ok(!testStorageService.get('mcpInputs', StorageScope.APPLICATION)?.includes('secretValue1'));\n\t});\n});\n\n"]}