{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/common/mcpService.ts","vs/workbench/contrib/mcp/common/mcpService.ts"],"names":[],"mappings":"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","file":"mcpService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { autorun, IObservable, ISettableObservable, observableValue, transaction } from '../../../../base/common/observable.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { mcpAutoStartConfig, McpAutoStartValue } from '../../../../platform/mcp/common/mcpManagement.js';\nimport { StorageScope } from '../../../../platform/storage/common/storage.js';\nimport { IMcpRegistry } from './mcpRegistryTypes.js';\nimport { McpServer, McpServerMetadataCache } from './mcpServer.js';\nimport { IAutostartResult, IMcpServer, IMcpService, McpCollectionDefinition, McpConnectionState, McpDefinitionReference, McpServerCacheState, McpServerDefinition, McpStartServerInteraction, McpToolName, UserInteractionRequiredError } from './mcpTypes.js';\nimport { startServerAndWaitForLiveTools } from './mcpTypesUtils.js';\n\ntype IMcpServerRec = { object: IMcpServer; toolPrefix: string };\n\nexport class McpService extends Disposable implements IMcpService {\n\n\tdeclare _serviceBrand: undefined;\n\n\tprivate readonly _currentAutoStarts = new Set<CancellationTokenSource>();\n\tprivate readonly _servers = observableValue<readonly IMcpServerRec[]>(this, []);\n\tpublic readonly servers: IObservable<readonly IMcpServer[]> = this._servers.map(servers => servers.map(s => s.object));\n\n\tpublic get lazyCollectionState() { return this._mcpRegistry.lazyCollectionState; }\n\n\tprotected readonly userCache: McpServerMetadataCache;\n\tprotected readonly workspaceCache: McpServerMetadataCache;\n\n\tconstructor(\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IMcpRegistry private readonly _mcpRegistry: IMcpRegistry,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tthis.userCache = this._register(_instantiationService.createInstance(McpServerMetadataCache, StorageScope.PROFILE));\n\t\tthis.workspaceCache = this._register(_instantiationService.createInstance(McpServerMetadataCache, StorageScope.WORKSPACE));\n\n\t\tconst updateThrottle = this._store.add(new RunOnceScheduler(() => this.updateCollectedServers(), 500));\n\n\t\t// Throttle changes so that if a collection is changed, or a server is\n\t\t// unregistered/registered, we don't stop servers unnecessarily.\n\t\tthis._register(autorun(reader => {\n\t\t\tfor (const collection of this._mcpRegistry.collections.read(reader)) {\n\t\t\t\tcollection.serverDefinitions.read(reader);\n\t\t\t}\n\t\t\tupdateThrottle.schedule(500);\n\t\t}));\n\t}\n\n\tpublic cancelAutostart(): void {\n\t\tfor (const cts of this._currentAutoStarts) {\n\t\t\tcts.cancel();\n\t\t}\n\t}\n\n\tpublic autostart(_token?: CancellationToken): IObservable<IAutostartResult> {\n\t\tconst autoStartConfig = this.configurationService.getValue<McpAutoStartValue>(mcpAutoStartConfig);\n\t\tif (autoStartConfig === McpAutoStartValue.Never) {\n\t\t\treturn observableValue<IAutostartResult>(this, IAutostartResult.Empty);\n\t\t}\n\n\t\tconst state = observableValue<IAutostartResult>(this, { working: true, starting: [], serversRequiringInteraction: [] });\n\t\tconst store = new DisposableStore();\n\n\t\tconst cts = store.add(new CancellationTokenSource(_token));\n\t\tthis._currentAutoStarts.add(cts);\n\t\tstore.add(toDisposable(() => {\n\t\t\tthis._currentAutoStarts.delete(cts);\n\t\t}));\n\t\tstore.add(cts.token.onCancellationRequested(() => {\n\t\t\tstate.set(IAutostartResult.Empty, undefined);\n\t\t}));\n\n\t\tthis._autostart(autoStartConfig, state, cts.token)\n\t\t\t.catch(err => {\n\t\t\t\tthis._logService.error('Error during MCP autostart:', err);\n\t\t\t\tstate.set(IAutostartResult.Empty, undefined);\n\t\t\t})\n\t\t\t.finally(() => store.dispose());\n\n\t\treturn state;\n\t}\n\n\tprivate async _autostart(autoStartConfig: McpAutoStartValue, state: ISettableObservable<IAutostartResult>, token: CancellationToken) {\n\t\tawait this._activateCollections();\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// don't try re-running errored servers, let the user choose if they want that\n\t\tconst candidates = this.servers.get().filter(s => s.connectionState.get().state !== McpConnectionState.Kind.Error);\n\n\t\tlet todo = new Set<IMcpServer>();\n\t\tif (autoStartConfig === McpAutoStartValue.OnlyNew) {\n\t\t\ttodo = new Set(candidates.filter(s => s.cacheState.get() === McpServerCacheState.Unknown));\n\t\t} else if (autoStartConfig === McpAutoStartValue.NewAndOutdated) {\n\t\t\ttodo = new Set(candidates.filter(s => {\n\t\t\t\tconst c = s.cacheState.get();\n\t\t\t\treturn c === McpServerCacheState.Unknown || c === McpServerCacheState.Outdated;\n\t\t\t}));\n\t\t}\n\n\t\tif (!todo.size) {\n\t\t\tstate.set(IAutostartResult.Empty, undefined);\n\t\t\treturn;\n\t\t}\n\n\t\tconst interaction = new McpStartServerInteraction();\n\t\tconst requiringInteraction: (McpDefinitionReference & { errorMessage?: string })[] = [];\n\n\t\tconst update = () => state.set({\n\t\t\tworking: todo.size > 0,\n\t\t\tstarting: [...todo].map(t => t.definition),\n\t\t\tserversRequiringInteraction: requiringInteraction,\n\t\t}, undefined);\n\n\t\tupdate();\n\n\t\tawait Promise.all([...todo].map(async (server, i) => {\n\t\t\ttry {\n\t\t\t\tawait startServerAndWaitForLiveTools(server, { interaction, errorOnUserInteraction: true }, token);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof UserInteractionRequiredError) {\n\t\t\t\t\trequiringInteraction.push({ id: server.definition.id, label: server.definition.label, errorMessage: error.message });\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\ttodo.delete(server);\n\t\t\t\tif (!token.isCancellationRequested) {\n\t\t\t\t\tupdate();\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic resetCaches(): void {\n\t\tthis.userCache.reset();\n\t\tthis.workspaceCache.reset();\n\t}\n\n\tpublic resetTrust(): void {\n\t\tthis.resetCaches(); // same difference now\n\t}\n\n\tpublic async activateCollections(): Promise<void> {\n\t\tawait this._activateCollections();\n\t}\n\n\tprivate async _activateCollections() {\n\t\tconst collections = await this._mcpRegistry.discoverCollections();\n\t\tthis.updateCollectedServers();\n\t\treturn new Set(collections.map(c => c.id));\n\t}\n\n\tpublic updateCollectedServers() {\n\t\tconst prefixGenerator = new McpPrefixGenerator();\n\t\tconst definitions = this._mcpRegistry.collections.get().flatMap(collectionDefinition =>\n\t\t\tcollectionDefinition.serverDefinitions.get().map(serverDefinition => {\n\t\t\t\tconst toolPrefix = prefixGenerator.generate(serverDefinition.label);\n\t\t\t\treturn { serverDefinition, collectionDefinition, toolPrefix };\n\t\t\t})\n\t\t);\n\n\t\tconst nextDefinitions = new Set(definitions);\n\t\tconst currentServers = this._servers.get();\n\t\tconst nextServers: IMcpServerRec[] = [];\n\t\tconst pushMatch = (match: (typeof definitions)[0], rec: IMcpServerRec) => {\n\t\t\tnextDefinitions.delete(match);\n\t\t\tnextServers.push(rec);\n\t\t\tconst connection = rec.object.connection.get();\n\t\t\t// if the definition was modified, stop the server; it'll be restarted again on-demand\n\t\t\tif (connection && !McpServerDefinition.equals(connection.definition, match.serverDefinition)) {\n\t\t\t\trec.object.stop();\n\t\t\t\tthis._logService.debug(`MCP server ${rec.object.definition.id} stopped because the definition changed`);\n\t\t\t}\n\t\t};\n\n\t\t// Transfer over any servers that are still valid.\n\t\tfor (const server of currentServers) {\n\t\t\tconst match = definitions.find(d => defsEqual(server.object, d) && server.toolPrefix === d.toolPrefix);\n\t\t\tif (match) {\n\t\t\t\tpushMatch(match, server);\n\t\t\t} else {\n\t\t\t\tserver.object.dispose();\n\t\t\t}\n\t\t}\n\n\t\t// Create any new servers that are needed.\n\t\tfor (const def of nextDefinitions) {\n\t\t\tconst object = this._instantiationService.createInstance(\n\t\t\t\tMcpServer,\n\t\t\t\tdef.collectionDefinition,\n\t\t\t\tdef.serverDefinition,\n\t\t\t\tdef.serverDefinition.roots,\n\t\t\t\t!!def.collectionDefinition.lazy,\n\t\t\t\tdef.collectionDefinition.scope === StorageScope.WORKSPACE ? this.workspaceCache : this.userCache,\n\t\t\t\tdef.toolPrefix,\n\t\t\t);\n\n\t\t\tnextServers.push({ object, toolPrefix: def.toolPrefix });\n\t\t}\n\n\t\ttransaction(tx => {\n\t\t\tthis._servers.set(nextServers, tx);\n\t\t});\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._servers.get().forEach(s => s.object.dispose());\n\t\tsuper.dispose();\n\t}\n}\n\nfunction defsEqual(server: IMcpServer, def: { serverDefinition: McpServerDefinition; collectionDefinition: McpCollectionDefinition }) {\n\treturn server.collection.id === def.collectionDefinition.id && server.definition.id === def.serverDefinition.id;\n}\n\n// Helper class for generating unique MCP tool prefixes\nclass McpPrefixGenerator {\n\tprivate readonly seenPrefixes = new Set<string>();\n\n\tgenerate(label: string): string {\n\t\tconst baseToolPrefix = McpToolName.Prefix + label.toLowerCase().replace(/[^a-z0-9_.-]+/g, '_').slice(0, McpToolName.MaxPrefixLen - McpToolName.Prefix.length - 1);\n\t\tlet toolPrefix = baseToolPrefix + '_';\n\t\tfor (let i = 2; this.seenPrefixes.has(toolPrefix); i++) {\n\t\t\ttoolPrefix = baseToolPrefix + i + '_';\n\t\t}\n\t\tthis.seenPrefixes.add(toolPrefix);\n\t\treturn toolPrefix;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { autorun, IObservable, ISettableObservable, observableValue, transaction } from '../../../../base/common/observable.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { mcpAutoStartConfig, McpAutoStartValue } from '../../../../platform/mcp/common/mcpManagement.js';\nimport { StorageScope } from '../../../../platform/storage/common/storage.js';\nimport { IMcpRegistry } from './mcpRegistryTypes.js';\nimport { McpServer, McpServerMetadataCache } from './mcpServer.js';\nimport { IAutostartResult, IMcpServer, IMcpService, McpCollectionDefinition, McpConnectionState, McpDefinitionReference, McpServerCacheState, McpServerDefinition, McpStartServerInteraction, McpToolName, UserInteractionRequiredError } from './mcpTypes.js';\nimport { startServerAndWaitForLiveTools } from './mcpTypesUtils.js';\n\ntype IMcpServerRec = { object: IMcpServer; toolPrefix: string };\n\nexport class McpService extends Disposable implements IMcpService {\n\n\tdeclare _serviceBrand: undefined;\n\n\tprivate readonly _currentAutoStarts = new Set<CancellationTokenSource>();\n\tprivate readonly _servers = observableValue<readonly IMcpServerRec[]>(this, []);\n\tpublic readonly servers: IObservable<readonly IMcpServer[]> = this._servers.map(servers => servers.map(s => s.object));\n\n\tpublic get lazyCollectionState() { return this._mcpRegistry.lazyCollectionState; }\n\n\tprotected readonly userCache: McpServerMetadataCache;\n\tprotected readonly workspaceCache: McpServerMetadataCache;\n\n\tconstructor(\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IMcpRegistry private readonly _mcpRegistry: IMcpRegistry,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tthis.userCache = this._register(_instantiationService.createInstance(McpServerMetadataCache, StorageScope.PROFILE));\n\t\tthis.workspaceCache = this._register(_instantiationService.createInstance(McpServerMetadataCache, StorageScope.WORKSPACE));\n\n\t\tconst updateThrottle = this._store.add(new RunOnceScheduler(() => this.updateCollectedServers(), 500));\n\n\t\t// Throttle changes so that if a collection is changed, or a server is\n\t\t// unregistered/registered, we don't stop servers unnecessarily.\n\t\tthis._register(autorun(reader => {\n\t\t\tfor (const collection of this._mcpRegistry.collections.read(reader)) {\n\t\t\t\tcollection.serverDefinitions.read(reader);\n\t\t\t}\n\t\t\tupdateThrottle.schedule(500);\n\t\t}));\n\t}\n\n\tpublic cancelAutostart(): void {\n\t\tfor (const cts of this._currentAutoStarts) {\n\t\t\tcts.cancel();\n\t\t}\n\t}\n\n\tpublic autostart(_token?: CancellationToken): IObservable<IAutostartResult> {\n\t\tconst autoStartConfig = this.configurationService.getValue<McpAutoStartValue>(mcpAutoStartConfig);\n\t\tif (autoStartConfig === McpAutoStartValue.Never) {\n\t\t\treturn observableValue<IAutostartResult>(this, IAutostartResult.Empty);\n\t\t}\n\n\t\tconst state = observableValue<IAutostartResult>(this, { working: true, starting: [], serversRequiringInteraction: [] });\n\t\tconst store = new DisposableStore();\n\n\t\tconst cts = store.add(new CancellationTokenSource(_token));\n\t\tthis._currentAutoStarts.add(cts);\n\t\tstore.add(toDisposable(() => {\n\t\t\tthis._currentAutoStarts.delete(cts);\n\t\t}));\n\t\tstore.add(cts.token.onCancellationRequested(() => {\n\t\t\tstate.set(IAutostartResult.Empty, undefined);\n\t\t}));\n\n\t\tthis._autostart(autoStartConfig, state, cts.token)\n\t\t\t.catch(err => {\n\t\t\t\tthis._logService.error('Error during MCP autostart:', err);\n\t\t\t\tstate.set(IAutostartResult.Empty, undefined);\n\t\t\t})\n\t\t\t.finally(() => store.dispose());\n\n\t\treturn state;\n\t}\n\n\tprivate async _autostart(autoStartConfig: McpAutoStartValue, state: ISettableObservable<IAutostartResult>, token: CancellationToken) {\n\t\tawait this._activateCollections();\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// don't try re-running errored servers, let the user choose if they want that\n\t\tconst candidates = this.servers.get().filter(s => s.connectionState.get().state !== McpConnectionState.Kind.Error);\n\n\t\tlet todo = new Set<IMcpServer>();\n\t\tif (autoStartConfig === McpAutoStartValue.OnlyNew) {\n\t\t\ttodo = new Set(candidates.filter(s => s.cacheState.get() === McpServerCacheState.Unknown));\n\t\t} else if (autoStartConfig === McpAutoStartValue.NewAndOutdated) {\n\t\t\ttodo = new Set(candidates.filter(s => {\n\t\t\t\tconst c = s.cacheState.get();\n\t\t\t\treturn c === McpServerCacheState.Unknown || c === McpServerCacheState.Outdated;\n\t\t\t}));\n\t\t}\n\n\t\tif (!todo.size) {\n\t\t\tstate.set(IAutostartResult.Empty, undefined);\n\t\t\treturn;\n\t\t}\n\n\t\tconst interaction = new McpStartServerInteraction();\n\t\tconst requiringInteraction: (McpDefinitionReference & { errorMessage?: string })[] = [];\n\n\t\tconst update = () => state.set({\n\t\t\tworking: todo.size > 0,\n\t\t\tstarting: [...todo].map(t => t.definition),\n\t\t\tserversRequiringInteraction: requiringInteraction,\n\t\t}, undefined);\n\n\t\tupdate();\n\n\t\tawait Promise.all([...todo].map(async (server, i) => {\n\t\t\ttry {\n\t\t\t\tawait startServerAndWaitForLiveTools(server, { interaction, errorOnUserInteraction: true }, token);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof UserInteractionRequiredError) {\n\t\t\t\t\trequiringInteraction.push({ id: server.definition.id, label: server.definition.label, errorMessage: error.message });\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\ttodo.delete(server);\n\t\t\t\tif (!token.isCancellationRequested) {\n\t\t\t\t\tupdate();\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic resetCaches(): void {\n\t\tthis.userCache.reset();\n\t\tthis.workspaceCache.reset();\n\t}\n\n\tpublic resetTrust(): void {\n\t\tthis.resetCaches(); // same difference now\n\t}\n\n\tpublic async activateCollections(): Promise<void> {\n\t\tawait this._activateCollections();\n\t}\n\n\tprivate async _activateCollections() {\n\t\tconst collections = await this._mcpRegistry.discoverCollections();\n\t\tthis.updateCollectedServers();\n\t\treturn new Set(collections.map(c => c.id));\n\t}\n\n\tpublic updateCollectedServers() {\n\t\tconst prefixGenerator = new McpPrefixGenerator();\n\t\tconst definitions = this._mcpRegistry.collections.get().flatMap(collectionDefinition =>\n\t\t\tcollectionDefinition.serverDefinitions.get().map(serverDefinition => {\n\t\t\t\tconst toolPrefix = prefixGenerator.generate(serverDefinition.label);\n\t\t\t\treturn { serverDefinition, collectionDefinition, toolPrefix };\n\t\t\t})\n\t\t);\n\n\t\tconst nextDefinitions = new Set(definitions);\n\t\tconst currentServers = this._servers.get();\n\t\tconst nextServers: IMcpServerRec[] = [];\n\t\tconst pushMatch = (match: (typeof definitions)[0], rec: IMcpServerRec) => {\n\t\t\tnextDefinitions.delete(match);\n\t\t\tnextServers.push(rec);\n\t\t\tconst connection = rec.object.connection.get();\n\t\t\t// if the definition was modified, stop the server; it'll be restarted again on-demand\n\t\t\tif (connection && !McpServerDefinition.equals(connection.definition, match.serverDefinition)) {\n\t\t\t\trec.object.stop();\n\t\t\t\tthis._logService.debug(`MCP server ${rec.object.definition.id} stopped because the definition changed`);\n\t\t\t}\n\t\t};\n\n\t\t// Transfer over any servers that are still valid.\n\t\tfor (const server of currentServers) {\n\t\t\tconst match = definitions.find(d => defsEqual(server.object, d) && server.toolPrefix === d.toolPrefix);\n\t\t\tif (match) {\n\t\t\t\tpushMatch(match, server);\n\t\t\t} else {\n\t\t\t\tserver.object.dispose();\n\t\t\t}\n\t\t}\n\n\t\t// Create any new servers that are needed.\n\t\tfor (const def of nextDefinitions) {\n\t\t\tconst object = this._instantiationService.createInstance(\n\t\t\t\tMcpServer,\n\t\t\t\tdef.collectionDefinition,\n\t\t\t\tdef.serverDefinition,\n\t\t\t\tdef.serverDefinition.roots,\n\t\t\t\t!!def.collectionDefinition.lazy,\n\t\t\t\tdef.collectionDefinition.scope === StorageScope.WORKSPACE ? this.workspaceCache : this.userCache,\n\t\t\t\tdef.toolPrefix,\n\t\t\t);\n\n\t\t\tnextServers.push({ object, toolPrefix: def.toolPrefix });\n\t\t}\n\n\t\ttransaction(tx => {\n\t\t\tthis._servers.set(nextServers, tx);\n\t\t});\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._servers.get().forEach(s => s.object.dispose());\n\t\tsuper.dispose();\n\t}\n}\n\nfunction defsEqual(server: IMcpServer, def: { serverDefinition: McpServerDefinition; collectionDefinition: McpCollectionDefinition }) {\n\treturn server.collection.id === def.collectionDefinition.id && server.definition.id === def.serverDefinition.id;\n}\n\n// Helper class for generating unique MCP tool prefixes\nclass McpPrefixGenerator {\n\tprivate readonly seenPrefixes = new Set<string>();\n\n\tgenerate(label: string): string {\n\t\tconst baseToolPrefix = McpToolName.Prefix + label.toLowerCase().replace(/[^a-z0-9_.-]+/g, '_').slice(0, McpToolName.MaxPrefixLen - McpToolName.Prefix.length - 1);\n\t\tlet toolPrefix = baseToolPrefix + '_';\n\t\tfor (let i = 2; this.seenPrefixes.has(toolPrefix); i++) {\n\t\t\ttoolPrefix = baseToolPrefix + i + '_';\n\t\t}\n\t\tthis.seenPrefixes.add(toolPrefix);\n\t\treturn toolPrefix;\n\t}\n}\n"]}