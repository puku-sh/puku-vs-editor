{"version":3,"sources":["vs/workbench/contrib/mcp/common/mcpTypes.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;AAEhG,OAAO,EAAE,MAAM,IAAI,WAAW,EAAE,MAAM,mCAAmC,CAAC;AAC1E,OAAO,EAAE,WAAW,EAAE,MAAM,mCAAmC,CAAC;AAChE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,QAAQ,EAAE,MAAM,mCAAmC,CAAC;AAInF,OAAO,EAAE,UAAU,EAAe,MAAM,sCAAsC,CAAC;AAC/E,OAAO,EAAE,MAAM,IAAI,YAAY,EAAE,MAAM,oCAAoC,CAAC;AAC5E,OAAO,EAAe,aAAa,EAAE,MAAM,uCAAuC,CAAC;AAGnF,OAAO,EAAE,GAAG,EAAiB,MAAM,gCAAgC,CAAC;AAEpE,OAAO,EAAE,QAAQ,EAAE,MAAM,oBAAoB,CAAC;AAE9C,OAAO,EAAE,aAAa,EAAE,MAAM,sDAAsD,CAAC;AAErF,OAAO,EAAE,mBAAmB,EAAE,MAAM,sDAAsD,CAAC;AAC3F,OAAO,EAAE,eAAe,EAAE,MAAM,4DAA4D,CAAC;AAU7F,OAAO,EAAE,GAAG,EAAE,MAAM,2BAA2B,CAAC;AAGhD,MAAM,CAAC,MAAM,4BAA4B,GAAG,MAAM,CAAC;AAEnD,MAAM,UAAU,2BAA2B,CAAC,UAA+B,EAAE,EAAU;IACtF,OAAO,mBAAmB,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC;AACzD,CAAC;AAgDD,MAAM,CAAN,IAAkB,sBAQjB;AARD,WAAkB,sBAAsB;IACvC,yFAAmB,CAAA;IACnB,+EAAe,CAAA;IACf,qEAAU,CAAA;IACV,+EAAe,CAAA;IACf,iFAAgB,CAAA;IAEhB,mFAAiB,CAAA;AAClB,CAAC,EARiB,sBAAsB,KAAtB,sBAAsB,QAQvC;AAED,MAAM,KAAW,uBAAuB,CAiBvC;AAjBD,WAAiB,uBAAuB;IAWvC,SAAgB,MAAM,CAAC,CAA0B,EAAE,CAA0B;QAC5E,OAAO,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,EAAE;eAChB,CAAC,CAAC,eAAe,KAAK,CAAC,CAAC,eAAe;eACvC,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,KAAK;eACnB,CAAC,CAAC,aAAa,KAAK,CAAC,CAAC,aAAa,CAAC;IACzC,CAAC;IALe,8BAAM,SAKrB,CAAA;AACF,CAAC,EAjBgB,uBAAuB,KAAvB,uBAAuB,QAiBvC;AA6BD,MAAM,CAAN,IAAkB,+BAKjB;AALD,WAAkB,+BAA+B;IAChD,uEAAuE;IACvE,2FAAO,CAAA;IACP,iCAAiC;IACjC,2FAAO,CAAA;AACR,CAAC,EALiB,+BAA+B,KAA/B,+BAA+B,QAKhD;AASD,MAAM,KAAW,mBAAmB,CAkCnC;AAlCD,WAAiB,mBAAmB;IAUnC,SAAgB,YAAY,CAAC,GAAwB;QACpD,OAAO,GAAG,CAAC;IACZ,CAAC;IAFe,gCAAY,eAE3B,CAAA;IAED,SAAgB,cAAc,CAAC,GAAmC;QACjE,OAAO;YACN,EAAE,EAAE,GAAG,CAAC,EAAE;YACV,KAAK,EAAE,GAAG,CAAC,KAAK;YAChB,UAAU,EAAE,GAAG,CAAC,UAAU;YAC1B,cAAc,EAAE,GAAG,CAAC,cAAc;YAClC,MAAM,EAAE,eAAe,CAAC,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC;YAClD,mBAAmB,EAAE,GAAG,CAAC,mBAAmB,CAAC,CAAC,CAAC,sCAAsC,CAAC,cAAc,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC,SAAS;SACzI,CAAC;IACH,CAAC;IATe,kCAAc,iBAS7B,CAAA;IAED,SAAgB,MAAM,CAAC,CAAsB,EAAE,CAAsB;QACpE,OAAO,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,EAAE;eAChB,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,KAAK;eACnB,WAAW,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,QAAQ,EAAE,CAAC;eACtE,YAAY,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC;eAChC,YAAY,CAAC,CAAC,CAAC,YAAY,EAAE,CAAC,CAAC,YAAY,CAAC;eAC5C,YAAY,CAAC,CAAC,CAAC,mBAAmB,EAAE,CAAC,CAAC,mBAAmB,CAAC;eAC1D,YAAY,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC;IACxC,CAAC;IARe,0BAAM,SAQrB,CAAA;AACF,CAAC,EAlCgB,mBAAmB,KAAnB,mBAAmB,QAkCnC;AASD,MAAM,KAAW,sCAAsC,CAkBtD;AAlBD,WAAiB,sCAAsC;IAOtD,SAAgB,YAAY,CAAC,GAA2C;QACvE,OAAO,GAAG,CAAC;IACZ,CAAC;IAFe,mDAAY,eAE3B,CAAA;IAED,SAAgB,cAAc,CAAC,GAAsD;QACpF,OAAO;YACN,OAAO,EAAE,GAAG,CAAC,OAAO;YACpB,MAAM,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS;YACnF,MAAM,EAAE,GAAG,CAAC,MAAM;SAClB,CAAC;IACH,CAAC;IANe,qDAAc,iBAM7B,CAAA;AACF,CAAC,EAlBgB,sCAAsC,KAAtC,sCAAsC,QAkBtD;AASD,MAAM,KAAW,gBAAgB,CAEhC;AAFD,WAAiB,gBAAgB;IACnB,sBAAK,GAAqB,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE,EAAE,2BAA2B,EAAE,EAAE,EAAE,CAAC;AAC1G,CAAC,EAFgB,gBAAgB,KAAhB,gBAAgB,QAEhC;AAyBD,MAAM,CAAN,IAAkB,mBAIjB;AAJD,WAAkB,mBAAmB;IACpC,yEAAU,CAAA;IACV,iFAAc,CAAA;IACd,qEAAQ,CAAA;AACT,CAAC,EAJiB,mBAAmB,KAAnB,mBAAmB,QAIpC;AAED,MAAM,CAAC,MAAM,WAAW,GAAG,eAAe,CAAc,aAAa,CAAC,CAAC;AAavE,MAAM,OAAO,yBAAyB;IAAtC;QACC,gBAAgB;QACA,iBAAY,GAAG,IAAI,aAAa,EAA6J,CAAC;IAE/M,CAAC;CAAA;AA0BD,MAAM,KAAW,cAAc,CAW9B;AAXD,WAAiB,cAAc;IAC9B,IAAkB,IASjB;IATD,WAAkB,IAAI;QACrB,4BAA4B;QAC5B,qCAAO,CAAA;QACP,yDAAyD;QACzD,mDAAc,CAAA;QACd,mCAAmC;QACnC,yCAAS,CAAA;QACT,kDAAkD;QAClD,qCAAO,CAAA;IACR,CAAC,EATiB,IAAI,GAAJ,mBAAI,KAAJ,mBAAI,QASrB;AACF,CAAC,EAXgB,cAAc,KAAd,cAAc,QAW9B;AA6ED,MAAM,CAAC,MAAM,qBAAqB,GAAG,CAAC,GAAwC,EAA+B,EAAE;IAC9G,OAAQ,GAA4B,CAAC,QAAQ,KAAK,SAAS,CAAC;AAC7D,CAAC,CAAC;AACF,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,GAAwC,EAAuB,EAAE;IAC9F,OAAQ,GAAoB,CAAC,MAAM,KAAK,SAAS,CAAC;AACnD,CAAC,CAAC;AAEF,MAAM,CAAN,IAAkB,mBAajB;AAbD,WAAkB,mBAAmB;IACpC,sCAAsC;IACtC,mEAAO,CAAA;IACP,qCAAqC;IACrC,iEAAM,CAAA;IACN,wEAAwE;IACxE,qEAAQ,CAAA;IACR,8CAA8C;IAC9C,+FAAqB,CAAA;IACrB,4DAA4D;IAC5D,6FAAoB,CAAA;IACpB,8CAA8C;IAC9C,6DAAI,CAAA;AACL,CAAC,EAbiB,mBAAmB,KAAnB,mBAAmB,QAapC;AAeD,MAAM,CAAC,MAAM,4BAA4B,GAAG,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,gBAAgB,EAAE,GAAG,CAAC,CAAC;AAE5F,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,UAAkC,EAAE,EAAE,CACrE,OAAO,GAAG,4BAA4B,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AA8B1D,MAAM,CAAN,IAAkB,sBAKjB;AALD,WAAkB,sBAAsB;IACvC,mEAAmE;IACnE,qEAAc,CAAA;IACd,iDAAiD;IACjD,mEAAa,CAAA;AACd,CAAC,EALiB,sBAAsB,KAAtB,sBAAsB,QAKvC;AA0CD,MAAM,KAAW,eAAe,CA6B/B;AA7BD,WAAiB,eAAe;IAK/B,SAAgB,YAAY,CAAC,MAAuB;QACnD,OAAO,MAAM,CAAC;IACf,CAAC;IAFe,4BAAY,eAE3B,CAAA;IAED,SAAgB,cAAc,CAAC,MAAkC;QAChE,QAAQ,MAAM,CAAC,IAAI,EAAE,CAAC;YACrB;gBACC,OAAO,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,OAAO,EAAE,MAAM,CAAC,OAAO,EAAE,cAAc,EAAE,MAAM,CAAC,cAAc,EAAE,CAAC;YAC3H;gBACC,OAAO;oBACN,IAAI,EAAE,MAAM,CAAC,IAAI;oBACjB,GAAG,EAAE,MAAM,CAAC,GAAG;oBACf,OAAO,EAAE,MAAM,CAAC,OAAO;oBACvB,IAAI,EAAE,MAAM,CAAC,IAAI;oBACjB,GAAG,EAAE,MAAM,CAAC,GAAG;oBACf,OAAO,EAAE,MAAM,CAAC,OAAO;iBACvB,CAAC;QACJ,CAAC;IACF,CAAC;IAde,8BAAc,iBAc7B,CAAA;IAEM,KAAK,UAAU,IAAI,CAAC,MAAuB;QACjD,MAAM,KAAK,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACtG,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACxD,CAAC;IAHqB,oBAAI,OAGzB,CAAA;AACF,CAAC,EA7BgB,eAAe,KAAf,eAAe,QA6B/B;AAsCD;;;GAGG;AACH,MAAM,KAAW,kBAAkB,CA+DlC;AA/DD,WAAiB,kBAAkB;IAClC,IAAkB,IAKjB;IALD,WAAkB,IAAI;QACrB,qCAAO,CAAA;QACP,uCAAQ,CAAA;QACR,qCAAO,CAAA;QACP,iCAAK,CAAA;IACN,CAAC,EALiB,IAAI,GAAJ,uBAAI,KAAJ,uBAAI,QAKrB;IAEY,2BAAQ,GAAG,CAAC,CAAqB,EAAU,EAAE;QACzD,QAAQ,CAAC,CAAC,KAAK,EAAE,CAAC;YACjB;gBACC,OAAO,QAAQ,CAAC,IAAkB,EAAE,IAAS,CAAC,CAAC;YAChD;gBACC,OAAO,QAAQ,CAAC,IAAmB,EAAE,IAAU,CAAC,CAAC;YAClD;gBACC,OAAO,QAAQ,CAAC,IAAkB,EAAE,IAAS,CAAC,CAAC;YAChD;gBACC,OAAO,QAAQ,CAAC,IAAgB,EAAE,IAAW,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC;YAC3D;gBACC,WAAW,CAAC,CAAC,CAAC,CAAC;QACjB,CAAC;IACF,CAAC,CAAC;IAEW,+BAAY,GAAG,CAAC,CAA0B,EAAU,EAAE;QAClE,QAAQ,CAAC,EAAE,CAAC;YACX;gBACC,OAAO,SAAS,CAAC;YAClB;gBACC,OAAO,UAAU,CAAC;YACnB;gBACC,OAAO,SAAS,CAAC;YAClB;gBACC,OAAO,OAAO,CAAC;YAChB;gBACC,WAAW,CAAC,CAAC,CAAC,CAAC;QACjB,CAAC;IACF,CAAC,CAAC;IAEF,2EAA2E;IAC9D,+BAAY,GAAG,CAAC,CAAO,EAAE,EAAE,CAAC,CAAC,uBAAe,IAAI,CAAC,yBAAiB,CAAC;IAEhF,iDAAiD;IACpC,4BAAS,GAAG,CAAC,CAAqB,EAAE,EAAE,CAAC,CAAC,mBAAA,YAAY,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AAqB5E,CAAC,EA/DgB,kBAAkB,KAAlB,kBAAkB,QA+DlC;AAQD,MAAM,OAAO,gBAAiB,SAAQ,KAAK;IAC1C,YAAY,OAAe,EAAkB,IAAY,EAAkB,IAAa;QACvF,KAAK,CAAC,OAAO,IAAI,KAAK,OAAO,EAAE,CAAC,CAAC;QADW,SAAI,GAAJ,IAAI,CAAQ;QAAkB,SAAI,GAAJ,IAAI,CAAS;IAExF,CAAC;CACD;AAED,MAAM,OAAO,wBAAyB,SAAQ,KAAK;CAAI;AAEvD,MAAM,OAAO,4BAA6B,SAAQ,KAAK;aAC9B,WAAM,GAAG,6BAA6B,CAAC;IAExD,MAAM,CAAC,EAAE,CAAC,KAAY;QAC5B,OAAO,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC9C,CAAC;IAED,YAA4B,MAAc;QACzC,KAAK,CAAC,GAAG,4BAA4B,CAAC,MAAM,GAAG,MAAM,EAAE,CAAC,CAAC;QAD9B,WAAM,GAAN,MAAM,CAAQ;IAE1C,CAAC;;AA0BF,MAAM,CAAN,IAAkB,wBAIjB;AAJD,WAAkB,wBAAwB;IACzC,+EAAQ,CAAA;IACR,+FAAgB,CAAA;IAChB,6EAAO,CAAA;AACR,CAAC,EAJiB,wBAAwB,KAAxB,wBAAwB,QAIzC;AAED,MAAM,CAAN,IAAkB,qBAKjB;AALD,WAAkB,qBAAqB;IACtC,6EAAU,CAAA;IACV,2EAAS,CAAA;IACT,iFAAY,CAAA;IACZ,+EAAW,CAAA;AACZ,CAAC,EALiB,qBAAqB,KAArB,qBAAqB,QAKtC;AAED,MAAM,CAAN,IAAkB,kBAIjB;AAJD,WAAkB,kBAAkB;IACnC,uCAAiB,CAAA;IACjB,2CAAqB,CAAA;IACrB,qDAA+B,CAAA;AAChC,CAAC,EAJiB,kBAAkB,KAAlB,kBAAkB,QAInC;AAoCD,MAAM,CAAC,MAAM,oBAAoB,GAAG,eAAe,CAAuB,sBAAsB,CAAC,CAAC;AAkB3F,IAAM,mBAAmB,GAAzB,MAAM,mBAAoB,SAAQ,UAAU;IAClD,YACkB,UAAiC,EAC5B,mBAAyC;QAE/D,KAAK,EAAE,CAAC;QAHS,eAAU,GAAV,UAAU,CAAuB;QAIlD,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;IACjE,CAAC;IAED,IAAI,SAAS,CAAC,SAAqC;QAClD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,GAAG,SAAS,CAAC,CAAC;IACvD,CAAC;IAED,MAAM,CAAC,MAAuC;QAC7C,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACzC,IAAI,MAAM,IAAI,SAAS,CAAC,SAAS,EAAE,CAAC;gBACnC,IAAI,MAAM,CAAC,EAAE,KAAK,SAAS,CAAC,SAAS,CAAC,EAAE,EAAE,CAAC;oBAC1C,SAAS,CAAC,SAAS,GAAG,MAAM,CAAC;gBAC9B,CAAC;YACF,CAAC;iBAAM,CAAC;gBACP,SAAS,CAAC,MAAM,EAAE,CAAC;YACpB,CAAC;QACF,CAAC;IACF,CAAC;CACD,CAAA;AAxBY,mBAAmB;IAG7B,WAAA,oBAAoB,CAAA;GAHV,mBAAmB,CAwB/B;;AAED,MAAM,CAAC,MAAM,8BAA8B,GAAG,IAAI,aAAa,CAAS,yBAAyB,2DAAuC,CAAC;AACzI,MAAM,CAAC,MAAM,6BAA6B,GAAG,IAAI,aAAa,CAAU,wBAAwB,EAAE,IAAI,CAAC,CAAC;AACxG,MAAM,CAAC,MAAM,yBAAyB,GAAG,+BAA+B,CAAC;AAEzE,MAAM,KAAW,cAAc,CA2C9B;AA3CD,WAAiB,cAAc;IACjB,qBAAM,GAAG,cAAc,CAAC;IAErC,4EAA4E;IAC5E,mFAAmF;IACnF,MAAM,yBAAyB,GAAG,WAAW,CAAC,CAAC,uDAAuD;IAEtG,SAAgB,UAAU,CAAC,GAA2B,EAAE,WAAyB;QAChF,IAAI,OAAO,WAAW,KAAK,QAAQ,EAAE,CAAC;YACrC,WAAW,GAAG,GAAG,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QACtC,CAAC;QACD,OAAO,WAAW,CAAC,IAAI,CAAC;YACvB,MAAM,EAAN,eAAA,MAAM;YACN,SAAS,EAAE,SAAS,CAAC,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;YACjD,IAAI,EAAE,CAAC,EAAE,EAAE,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,SAAS,IAAI,yBAAyB,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,WAAW,CAAC,IAAI;SAC/G,CAAC,CAAC;IACJ,CAAC;IATe,yBAAU,aASzB,CAAA;IAED,SAAgB,QAAQ,CAAC,GAAiB;QACzC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,CAAC;YAC7B,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACtB,CAAC;QACD,IAAI,GAAG,CAAC,MAAM,KAAK,eAAA,MAAM,EAAE,CAAC;YAC3B,MAAM,IAAI,KAAK,CAAC,6BAA6B,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;QAChE,CAAC;QACD,MAAM,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAClC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACtB,MAAM,IAAI,KAAK,CAAC,6BAA6B,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;QAChE,CAAC;QACD,MAAM,CAAC,EAAE,YAAY,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,GAAG,KAAK,CAAC;QAEnD,gGAAgG;QAChG,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,YAAY,MAAM,SAAS,CAAC,WAAW,EAAE,KAAK,yBAAyB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC;QACnH,GAAG,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QACzD,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,KAAK,CAAC;QACvB,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,QAAQ,CAAC;QAExB,OAAO;YACN,YAAY,EAAE,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,QAAQ,EAAE;YACjD,WAAW,EAAE,GAAG;SAChB,CAAC;IACH,CAAC;IAvBe,uBAAQ,WAuBvB,CAAA;AAEF,CAAC,EA3CgB,cAAc,KAAd,cAAc,QA2C9B;AAED,4FAA4F;AAC5F,MAAM,CAAN,IAAkB,aAUjB;AAVD,WAAkB,aAAa;IAC9B,uDAAgB,CAAA;IAChB,+DAAoB,CAAA;IACpB,uDAAgB,CAAA;IAChB,6EAA2B,CAAA;IAC3B,4DAAkB,CAAA;IAClB,8EAA2B,CAAA;IAC3B,kFAA6B,CAAA;IAC7B,qDAAc,CAAA;IACd,2EAAyB,CAAA;AAC1B,CAAC,EAViB,aAAa,KAAb,aAAa,QAU9B;AA0BD,MAAM,CAAC,MAAM,mBAAmB,GAAG,eAAe,CAAsB,oBAAoB,CAAC,CAAC;AAE9F,MAAM,OAAO,QAAS,SAAQ,KAAK;IAC3B,MAAM,CAAC,cAAc,CAAC,MAAc;QAC1C,OAAO,IAAI,QAAQ,CAAC,GAAG,CAAC,gBAAgB,EAAE,qBAAqB,MAAM,EAAE,CAAC,CAAC;IAC1E,CAAC;IAEM,MAAM,CAAC,UAAU;QACvB,OAAO,IAAI,QAAQ,CAAC,CAAC,KAAK,EAAE,qDAAqD,CAAC,CAAC;IACpF,CAAC;IAEM,MAAM,CAAC,OAAO,CAAC,CAAQ;QAC7B,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,GAAG,CAAC,cAAc,EAAE,kBAAkB,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;QAC/E,QAAQ,CAAC,KAAK,GAAG,CAAC,CAAC;QACnB,OAAO,QAAQ,CAAC;IACjB,CAAC;IAED,YACiB,IAAY,EAC5B,OAAe,EACC,IAAc;QAE9B,KAAK,CAAC,OAAO,CAAC,CAAC;QAJC,SAAI,GAAJ,IAAI,CAAQ;QAEZ,SAAI,GAAJ,IAAI,CAAU;IAG/B,CAAC;CACD;AAED,MAAM,CAAN,IAAkB,WAIjB;AAJD,WAAkB,WAAW;IAC5B,8BAAe,CAAA;IACf,8DAAiB,CAAA;IACjB,wDAAc,CAAA;AACf,CAAC,EAJiB,WAAW,KAAX,WAAW,QAI5B;AAiBD,MAAM,CAAN,IAAkB,eAGjB;AAHD,WAAkB,eAAe;IAChC,qDAAI,CAAA;IACJ,mDAAG,CAAA;AACJ,CAAC,EAHiB,eAAe,KAAf,eAAe,QAGhC;AAoBD,MAAM,CAAC,MAAM,sBAAsB,GAAG,eAAe,CAAyB,wBAAwB,CAAC,CAAC;AAExG,MAAM,CAAC,MAAM,2BAA2B,GAAG,oCAAoC,CAAC","file":"mcpTypes.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals as arraysEqual } from '../../../../base/common/arrays.js';\nimport { assertNever } from '../../../../base/common/assert.js';\nimport { decodeHex, encodeHex, VSBuffer } from '../../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\nimport { Disposable, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { equals as objectsEqual } from '../../../../base/common/objects.js';\nimport { IObservable, ObservableMap } from '../../../../base/common/observable.js';\nimport { IIterativePager } from '../../../../base/common/paging.js';\nimport Severity from '../../../../base/common/severity.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { Location } from '../../../../editor/common/languages.js';\nimport { localize } from '../../../../nls.js';\nimport { ConfigurationTarget } from '../../../../platform/configuration/common/configuration.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IEditorOptions } from '../../../../platform/editor/common/editor.js';\nimport { ExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { McpGalleryManifestStatus } from '../../../../platform/mcp/common/mcpGalleryManifest.js';\nimport { IGalleryMcpServer, IInstallableMcpServer, IGalleryMcpServerConfiguration, IQueryOptions } from '../../../../platform/mcp/common/mcpManagement.js';\nimport { IMcpDevModeConfig, IMcpServerConfiguration } from '../../../../platform/mcp/common/mcpPlatformTypes.js';\nimport { StorageScope } from '../../../../platform/storage/common/storage.js';\nimport { IWorkspaceFolder, IWorkspaceFolderData } from '../../../../platform/workspace/common/workspace.js';\nimport { IWorkbenchLocalMcpServer, IWorkbencMcpServerInstallOptions } from '../../../services/mcp/common/mcpWorkbenchManagementService.js';\nimport { ToolProgress } from '../../chat/common/languageModelToolsService.js';\nimport { IMcpServerSamplingConfiguration } from './mcpConfiguration.js';\nimport { McpServerRequestHandler } from './mcpServerRequestHandler.js';\nimport { MCP } from './modelContextProtocol.js';\nimport { UriTemplate } from './uriTemplate.js';\n\nexport const extensionMcpCollectionPrefix = 'ext.';\n\nexport function extensionPrefixedIdentifier(identifier: ExtensionIdentifier, id: string): string {\n\treturn ExtensionIdentifier.toKey(identifier) + '/' + id;\n}\n\n/**\n * An McpCollection contains McpServers. There may be multiple collections for\n * different locations servers are discovered.\n */\nexport interface McpCollectionDefinition {\n\t/** Origin authority from which this collection was discovered. */\n\treadonly remoteAuthority: string | null;\n\t/** Globally-unique, stable ID for this definition */\n\treadonly id: string;\n\t/** Human-readable label for the definition */\n\treadonly label: string;\n\t/** Definitions this collection contains. */\n\treadonly serverDefinitions: IObservable<readonly McpServerDefinition[]>;\n\t/**\n\t * Trust behavior of the servers. `Trusted` means it will run without a prompt, always.\n\t * `TrustedOnNonce` means it will run without a prompt as long as the nonce matches.\n\t */\n\treadonly trustBehavior: McpServerTrust.Kind.Trusted | McpServerTrust.Kind.TrustedOnNonce;\n\t/** Scope where associated collection info should be stored. */\n\treadonly scope: StorageScope;\n\t/** Configuration target where configuration related to this server should be stored. */\n\treadonly configTarget: ConfigurationTarget;\n\n\t/** Resolves a server definition. If present, always called before a server starts. */\n\tresolveServerLanch?(definition: McpServerDefinition): Promise<McpServerLaunch | undefined>;\n\n\t/** For lazy-loaded collections only: */\n\treadonly lazy?: {\n\t\t/** True if `serverDefinitions` were loaded from the cache */\n\t\tisCached: boolean;\n\t\t/** Triggers a load of the real server definition, which should be pushed to the IMcpRegistry. If not this definition will be removed. */\n\t\tload(): Promise<void>;\n\t\t/** Called after `load()` if the extension is not found. */\n\t\tremoved?(): void;\n\t};\n\n\treadonly source?: IWorkbenchMcpServer | ExtensionIdentifier;\n\n\treadonly presentation?: {\n\t\t/** Sort order of the collection. */\n\t\treadonly order?: number;\n\t\t/** Place where this collection is configured, used in workspace trust prompts and \"show config\" */\n\t\treadonly origin?: URI;\n\t};\n}\n\nexport const enum McpCollectionSortOrder {\n\tWorkspaceFolder = 0,\n\tWorkspace = 100,\n\tUser = 200,\n\tExtension = 300,\n\tFilesystem = 400,\n\n\tRemoteBoost = -50,\n}\n\nexport namespace McpCollectionDefinition {\n\texport interface FromExtHost {\n\t\treadonly id: string;\n\t\treadonly label: string;\n\t\treadonly isTrustedByDefault: boolean;\n\t\treadonly scope: StorageScope;\n\t\treadonly canResolveLaunch: boolean;\n\t\treadonly extensionId: string;\n\t\treadonly configTarget: ConfigurationTarget;\n\t}\n\n\texport function equals(a: McpCollectionDefinition, b: McpCollectionDefinition): boolean {\n\t\treturn a.id === b.id\n\t\t\t&& a.remoteAuthority === b.remoteAuthority\n\t\t\t&& a.label === b.label\n\t\t\t&& a.trustBehavior === b.trustBehavior;\n\t}\n}\n\nexport interface McpServerDefinition {\n\t/** Globally-unique, stable ID for this definition */\n\treadonly id: string;\n\t/** Human-readable label for the definition */\n\treadonly label: string;\n\t/** Descriptor defining how the configuration should be launched. */\n\treadonly launch: McpServerLaunch;\n\t/** Explicit roots. If undefined, all workspace folders. */\n\treadonly roots?: URI[] | undefined;\n\t/** If set, allows configuration variables to be resolved in the {@link launch} with the given context */\n\treadonly variableReplacement?: McpServerDefinitionVariableReplacement;\n\t/** Nonce used for caching the server. Changing the nonce will indicate that tools need to be refreshed. */\n\treadonly cacheNonce: string;\n\t/** Dev mode configuration for the server */\n\treadonly devMode?: IMcpDevModeConfig;\n\t/** Static description of server tools/data, used to hydrate the cache. */\n\treadonly staticMetadata?: McpServerStaticMetadata;\n\n\n\treadonly presentation?: {\n\t\t/** Sort order of the definition. */\n\t\treadonly order?: number;\n\t\t/** Place where this server is configured, used in workspace trust prompts and \"show config\" */\n\t\treadonly origin?: Location;\n\t};\n}\n\nexport const enum McpServerStaticToolAvailability {\n\t/** Tool is expected to be present as soon as the server is started. */\n\tInitial,\n\t/** Tool may be present later. */\n\tDynamic,\n}\n\nexport interface McpServerStaticMetadata {\n\ttools?: { availability: McpServerStaticToolAvailability; definition: MCP.Tool }[];\n\tinstructions?: string;\n\tcapabilities?: MCP.ServerCapabilities;\n\tserverInfo?: MCP.Implementation;\n}\n\nexport namespace McpServerDefinition {\n\texport interface Serialized {\n\t\treadonly id: string;\n\t\treadonly label: string;\n\t\treadonly cacheNonce: string;\n\t\treadonly launch: McpServerLaunch.Serialized;\n\t\treadonly variableReplacement?: McpServerDefinitionVariableReplacement.Serialized;\n\t\treadonly staticMetadata?: McpServerStaticMetadata;\n\t}\n\n\texport function toSerialized(def: McpServerDefinition): McpServerDefinition.Serialized {\n\t\treturn def;\n\t}\n\n\texport function fromSerialized(def: McpServerDefinition.Serialized): McpServerDefinition {\n\t\treturn {\n\t\t\tid: def.id,\n\t\t\tlabel: def.label,\n\t\t\tcacheNonce: def.cacheNonce,\n\t\t\tstaticMetadata: def.staticMetadata,\n\t\t\tlaunch: McpServerLaunch.fromSerialized(def.launch),\n\t\t\tvariableReplacement: def.variableReplacement ? McpServerDefinitionVariableReplacement.fromSerialized(def.variableReplacement) : undefined,\n\t\t};\n\t}\n\n\texport function equals(a: McpServerDefinition, b: McpServerDefinition): boolean {\n\t\treturn a.id === b.id\n\t\t\t&& a.label === b.label\n\t\t\t&& arraysEqual(a.roots, b.roots, (a, b) => a.toString() === b.toString())\n\t\t\t&& objectsEqual(a.launch, b.launch)\n\t\t\t&& objectsEqual(a.presentation, b.presentation)\n\t\t\t&& objectsEqual(a.variableReplacement, b.variableReplacement)\n\t\t\t&& objectsEqual(a.devMode, b.devMode);\n\t}\n}\n\n\nexport interface McpServerDefinitionVariableReplacement {\n\tsection?: string; // e.g. 'mcp'\n\tfolder?: IWorkspaceFolderData;\n\ttarget: ConfigurationTarget;\n}\n\nexport namespace McpServerDefinitionVariableReplacement {\n\texport interface Serialized {\n\t\ttarget: ConfigurationTarget;\n\t\tsection?: string;\n\t\tfolder?: { name: string; index: number; uri: UriComponents };\n\t}\n\n\texport function toSerialized(def: McpServerDefinitionVariableReplacement): McpServerDefinitionVariableReplacement.Serialized {\n\t\treturn def;\n\t}\n\n\texport function fromSerialized(def: McpServerDefinitionVariableReplacement.Serialized): McpServerDefinitionVariableReplacement {\n\t\treturn {\n\t\t\tsection: def.section,\n\t\t\tfolder: def.folder ? { ...def.folder, uri: URI.revive(def.folder.uri) } : undefined,\n\t\t\ttarget: def.target,\n\t\t};\n\t}\n}\n\n/** An observable of the auto-starting servers. When 'starting' is empty, the operation is complete. */\nexport interface IAutostartResult {\n\tworking: boolean;\n\tstarting: McpDefinitionReference[];\n\tserversRequiringInteraction: Array<McpDefinitionReference & { errorMessage?: string }>;\n}\n\nexport namespace IAutostartResult {\n\texport const Empty: IAutostartResult = { working: false, starting: [], serversRequiringInteraction: [] };\n}\n\nexport interface IMcpService {\n\t_serviceBrand: undefined;\n\treadonly servers: IObservable<readonly IMcpServer[]>;\n\n\t/** Resets the cached tools. */\n\tresetCaches(): void;\n\n\t/** Resets trusted MCP servers. */\n\tresetTrust(): void;\n\n\t/** Set if there are extensions that register MCP servers that have never been activated. */\n\treadonly lazyCollectionState: IObservable<{ state: LazyCollectionState; collections: McpCollectionDefinition[] }>;\n\n\t/** Auto-starts pending servers based on user settings. */\n\tautostart(token?: CancellationToken): IObservable<IAutostartResult>;\n\n\t/** Cancels any current autostart @internal */\n\tcancelAutostart(): void;\n\n\t/** Activates extension-providing MCP servers that have not yet been discovered. */\n\tactivateCollections(): Promise<void>;\n}\n\nexport const enum LazyCollectionState {\n\tHasUnknown,\n\tLoadingUnknown,\n\tAllKnown,\n}\n\nexport const IMcpService = createDecorator<IMcpService>('IMcpService');\n\nexport interface McpCollectionReference {\n\tid: string;\n\tlabel: string;\n\tpresentation?: McpCollectionDefinition['presentation'];\n}\n\nexport interface McpDefinitionReference {\n\tid: string;\n\tlabel: string;\n}\n\nexport class McpStartServerInteraction {\n\t/** @internal */\n\tpublic readonly participants = new ObservableMap</* server definition ID */ string, { s: 'unknown' | 'resolved' } | { s: 'waiting'; definition: McpServerDefinition; collection: McpCollectionDefinition }>();\n\tchoice?: Promise<string[] | undefined>;\n}\n\nexport interface IMcpServerStartOpts {\n\t/**\n\t * Automatically trust if changed. This should ONLY be set for afforances that\n\t * ensure the user sees the config before it gets started (e.g. code lenses)\n\t */\n\tautoTrustChanges?: boolean;\n\t/**\n\t * When to trigger the trust prompt.\n\t * - only-new: only prompt for servers that are not previously explicitly untrusted (default)\n\t * - all-untrusted: prompt for all servers that are not trusted\n\t * - never: don't prompt, fail silently when trying to start an untrusted server\n\t */\n\tpromptType?: 'only-new' | 'all-untrusted' | 'never';\n\t/** True if th servre should be launched with debugging. */\n\tdebug?: boolean;\n\t/** Correlate multiple interactions such that any trust prompts are presented in combination. */\n\tinteraction?: McpStartServerInteraction;\n\t/**\n\t * If true, throw an error if any user interaction would be required during startup.\n\t * This includes variable resolution, trust prompts, and authentication prompts.\n\t */\n\terrorOnUserInteraction?: boolean;\n}\n\nexport namespace McpServerTrust {\n\texport const enum Kind {\n\t\t/** The server is trusted */\n\t\tTrusted,\n\t\t/** The server is trusted as long as its nonce matches */\n\t\tTrustedOnNonce,\n\t\t/** The server trust was denied. */\n\t\tUntrusted,\n\t\t/** The server is not yet trusted or untrusted. */\n\t\tUnknown,\n\t}\n}\n\nexport interface IMcpServer extends IDisposable {\n\treadonly collection: McpCollectionReference;\n\treadonly definition: McpDefinitionReference;\n\treadonly connection: IObservable<IMcpServerConnection | undefined>;\n\treadonly connectionState: IObservable<McpConnectionState>;\n\treadonly serverMetadata: IObservable<{\n\t\tserverName?: string;\n\t\tserverInstructions?: string;\n\t\ticons: IMcpIcons;\n\t} | undefined>;\n\n\t/**\n\t * Full definition as it exists in the MCP registry. Unlike the references\n\t * in `collection` and `definition`, this may change over time.\n\t */\n\treadDefinitions(): IObservable<{ server: McpServerDefinition | undefined; collection: McpCollectionDefinition | undefined }>;\n\n\tshowOutput(preserveFocus?: boolean): Promise<void>;\n\t/**\n\t * Starts the server and returns its resulting state. One of:\n\t * - Running, if all good\n\t * - Error, if the server failed to start\n\t * - Stopped, if the server was disposed or the user cancelled the launch\n\t */\n\tstart(opts?: IMcpServerStartOpts): Promise<McpConnectionState>;\n\tstop(): Promise<void>;\n\n\treadonly cacheState: IObservable<McpServerCacheState>;\n\treadonly tools: IObservable<readonly IMcpTool[]>;\n\treadonly prompts: IObservable<readonly IMcpPrompt[]>;\n\treadonly capabilities: IObservable<McpCapability | undefined>;\n\n\t/**\n\t * Lists all resources on the server.\n\t */\n\tresources(token?: CancellationToken): AsyncIterable<IMcpResource[]>;\n\n\t/**\n\t * List resource templates on the server.\n\t */\n\tresourceTemplates(token?: CancellationToken): Promise<IMcpResourceTemplate[]>;\n}\n\n/**\n * A representation of an MCP resource. The `uri` is namespaced to VS Code and\n * can be used in filesystem APIs.\n */\nexport interface IMcpResource {\n\t/** Identifier for the file in VS Code and operable with filesystem API */\n\treadonly uri: URI;\n\t/** Identifier of the file as given from the MCP server. */\n\treadonly mcpUri: string;\n\treadonly name: string;\n\treadonly title?: string;\n\treadonly description?: string;\n\treadonly mimeType?: string;\n\treadonly sizeInBytes?: number;\n\treadonly icons: IMcpIcons;\n}\n\nexport interface IMcpResourceTemplate {\n\treadonly name: string;\n\treadonly title?: string;\n\treadonly description?: string;\n\treadonly mimeType?: string;\n\treadonly template: UriTemplate;\n\treadonly icons: IMcpIcons;\n\n\t/** Gets string completions for the given template part. */\n\tcomplete(templatePart: string, prefix: string, alreadyResolved: Record<string, string | string[]>, token: CancellationToken): Promise<string[]>;\n\n\t/** Gets the resolved URI from template parts. */\n\tresolveURI(vars: Record<string, unknown>): URI;\n}\n\nexport const isMcpResourceTemplate = (obj: IMcpResource | IMcpResourceTemplate): obj is IMcpResourceTemplate => {\n\treturn (obj as IMcpResourceTemplate).template !== undefined;\n};\nexport const isMcpResource = (obj: IMcpResource | IMcpResourceTemplate): obj is IMcpResource => {\n\treturn (obj as IMcpResource).mcpUri !== undefined;\n};\n\nexport const enum McpServerCacheState {\n\t/** Tools have not been read before */\n\tUnknown,\n\t/** Tools were read from the cache */\n\tCached,\n\t/** Tools were read from the cache or live, but they may be outdated. */\n\tOutdated,\n\t/** Tools are refreshing for the first time */\n\tRefreshingFromUnknown,\n\t/** Tools are refreshing and the current tools are cached */\n\tRefreshingFromCached,\n\t/** Tool state is live, server is connected */\n\tLive,\n}\n\nexport interface IMcpPrompt {\n\treadonly id: string;\n\treadonly name: string;\n\treadonly title?: string;\n\treadonly description?: string;\n\treadonly arguments: readonly MCP.PromptArgument[];\n\n\t/** Gets string completions for the given prompt part. */\n\tcomplete(argument: string, prefix: string, alreadyResolved: Record<string, string>, token: CancellationToken): Promise<string[]>;\n\n\tresolve(args: Record<string, string | undefined>, token?: CancellationToken): Promise<IMcpPromptMessage[]>;\n}\n\nexport const mcpPromptReplaceSpecialChars = (s: string) => s.replace(/[^a-z0-9_.-]/gi, '_');\n\nexport const mcpPromptPrefix = (definition: McpDefinitionReference) =>\n\t`/mcp.` + mcpPromptReplaceSpecialChars(definition.label);\n\nexport interface IMcpPromptMessage extends MCP.PromptMessage { }\n\nexport interface IMcpToolCallContext {\n\tchatSessionId?: string;\n\tchatRequestId?: string;\n}\n\nexport interface IMcpTool {\n\n\treadonly id: string;\n\t/** Name for #referencing in chat */\n\treadonly referenceName: string;\n\treadonly icons: IMcpIcons;\n\treadonly definition: MCP.Tool;\n\n\t/**\n\t * Calls a tool\n\t * @throws {@link MpcResponseError} if the tool fails to execute\n\t * @throws {@link McpConnectionFailedError} if the connection to the server fails\n\t */\n\tcall(params: Record<string, unknown>, context?: IMcpToolCallContext, token?: CancellationToken): Promise<MCP.CallToolResult>;\n\n\t/**\n\t * Identical to {@link call}, but reports progress.\n\t */\n\tcallWithProgress(params: Record<string, unknown>, progress: ToolProgress, context?: IMcpToolCallContext, token?: CancellationToken): Promise<MCP.CallToolResult>;\n}\n\nexport const enum McpServerTransportType {\n\t/** A command-line MCP server communicating over standard in/out */\n\tStdio = 1 << 0,\n\t/** An MCP server that uses Server-Sent Events */\n\tHTTP = 1 << 1,\n}\n\n/**\n * MCP server launched on the command line which communicated over stdio.\n * https://spec.modelcontextprotocol.io/specification/2024-11-05/basic/transports/#stdio\n */\nexport interface McpServerTransportStdio {\n\treadonly type: McpServerTransportType.Stdio;\n\treadonly cwd: string | undefined;\n\treadonly command: string;\n\treadonly args: readonly string[];\n\treadonly env: Record<string, string | number | null>;\n\treadonly envFile: string | undefined;\n}\n\nexport interface McpServerTransportHTTPAuthentication {\n\t/**\n\t * Authentication provider ID to use to get a session for the initial MCP server connection.\n\t */\n\treadonly providerId: string;\n\t/**\n\t * Scopes to use to get a session for the initial MCP server connection.\n\t */\n\treadonly scopes: string[];\n}\n\n/**\n * MCP server launched on the command line which communicated over SSE or Streamable HTTP.\n * https://spec.modelcontextprotocol.io/specification/2024-11-05/basic/transports/#http-with-sse\n * https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#streamable-http\n */\nexport interface McpServerTransportHTTP {\n\treadonly type: McpServerTransportType.HTTP;\n\treadonly uri: URI;\n\treadonly headers: [string, string][];\n\treadonly authentication?: McpServerTransportHTTPAuthentication;\n}\n\nexport type McpServerLaunch =\n\t| McpServerTransportStdio\n\t| McpServerTransportHTTP;\n\nexport namespace McpServerLaunch {\n\texport type Serialized =\n\t\t| { type: McpServerTransportType.HTTP; uri: UriComponents; headers: [string, string][]; authentication?: McpServerTransportHTTPAuthentication }\n\t\t| { type: McpServerTransportType.Stdio; cwd: string | undefined; command: string; args: readonly string[]; env: Record<string, string | number | null>; envFile: string | undefined };\n\n\texport function toSerialized(launch: McpServerLaunch): McpServerLaunch.Serialized {\n\t\treturn launch;\n\t}\n\n\texport function fromSerialized(launch: McpServerLaunch.Serialized): McpServerLaunch {\n\t\tswitch (launch.type) {\n\t\t\tcase McpServerTransportType.HTTP:\n\t\t\t\treturn { type: launch.type, uri: URI.revive(launch.uri), headers: launch.headers, authentication: launch.authentication };\n\t\t\tcase McpServerTransportType.Stdio:\n\t\t\t\treturn {\n\t\t\t\t\ttype: launch.type,\n\t\t\t\t\tcwd: launch.cwd,\n\t\t\t\t\tcommand: launch.command,\n\t\t\t\t\targs: launch.args,\n\t\t\t\t\tenv: launch.env,\n\t\t\t\t\tenvFile: launch.envFile,\n\t\t\t\t};\n\t\t}\n\t}\n\n\texport async function hash(launch: McpServerLaunch): Promise<string> {\n\t\tconst nonce = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(JSON.stringify(launch)));\n\t\treturn encodeHex(VSBuffer.wrap(new Uint8Array(nonce)));\n\t}\n}\n\n/**\n * An instance that manages a connection to an MCP server. It can be started,\n * stopped, and restarted. Once started and in a running state, it will\n * eventually build a {@link IMcpServerConnection.handler}.\n */\nexport interface IMcpServerConnection extends IDisposable {\n\treadonly definition: McpServerDefinition;\n\treadonly state: IObservable<McpConnectionState>;\n\treadonly handler: IObservable<McpServerRequestHandler | undefined>;\n\n\t/**\n\t * Resolved launch definition. Might not match the `definition.launch` due to\n\t * resolution logic in extension-provided MCPs.\n\t */\n\treadonly launchDefinition: McpServerLaunch;\n\n\t/**\n\t * Starts the server if it's stopped. Returns a promise that resolves once\n\t * server exits a 'starting' state.\n\t */\n\tstart(methods: IMcpClientMethods): Promise<McpConnectionState>;\n\n\t/**\n\t * Stops the server.\n\t */\n\tstop(): Promise<void>;\n}\n\n/** Client methods whose implementations are passed through the server connection. */\nexport interface IMcpClientMethods {\n\t/** Handler for `sampling/createMessage` */\n\tcreateMessageRequestHandler?(req: MCP.CreateMessageRequest['params']): Promise<MCP.CreateMessageResult>;\n\t/** Handler for `elicitation/create` */\n\telicitationRequestHandler?(req: MCP.ElicitRequest['params']): Promise<MCP.ElicitResult>;\n}\n\n/**\n * McpConnectionState is the state of the underlying connection and is\n * communicated e.g. from the extension host to the renderer.\n */\nexport namespace McpConnectionState {\n\texport const enum Kind {\n\t\tStopped,\n\t\tStarting,\n\t\tRunning,\n\t\tError,\n\t}\n\n\texport const toString = (s: McpConnectionState): string => {\n\t\tswitch (s.state) {\n\t\t\tcase Kind.Stopped:\n\t\t\t\treturn localize('mcpstate.stopped', 'Stopped');\n\t\t\tcase Kind.Starting:\n\t\t\t\treturn localize('mcpstate.starting', 'Starting');\n\t\t\tcase Kind.Running:\n\t\t\t\treturn localize('mcpstate.running', 'Running');\n\t\t\tcase Kind.Error:\n\t\t\t\treturn localize('mcpstate.error', 'Error {0}', s.message);\n\t\t\tdefault:\n\t\t\t\tassertNever(s);\n\t\t}\n\t};\n\n\texport const toKindString = (s: McpConnectionState.Kind): string => {\n\t\tswitch (s) {\n\t\t\tcase Kind.Stopped:\n\t\t\t\treturn 'stopped';\n\t\t\tcase Kind.Starting:\n\t\t\t\treturn 'starting';\n\t\t\tcase Kind.Running:\n\t\t\t\treturn 'running';\n\t\t\tcase Kind.Error:\n\t\t\t\treturn 'error';\n\t\t\tdefault:\n\t\t\t\tassertNever(s);\n\t\t}\n\t};\n\n\t/** Returns if the MCP state is one where starting a new server is valid */\n\texport const canBeStarted = (s: Kind) => s === Kind.Error || s === Kind.Stopped;\n\n\t/** Gets whether the state is a running state. */\n\texport const isRunning = (s: McpConnectionState) => !canBeStarted(s.state);\n\n\texport interface Stopped {\n\t\treadonly state: Kind.Stopped;\n\t\treadonly reason?: 'needs-user-interaction';\n\t}\n\n\texport interface Starting {\n\t\treadonly state: Kind.Starting;\n\t}\n\n\texport interface Running {\n\t\treadonly state: Kind.Running;\n\t}\n\n\texport interface Error {\n\t\treadonly state: Kind.Error;\n\t\treadonly code?: string;\n\t\treadonly shouldRetry?: boolean;\n\t\treadonly message: string;\n\t}\n}\n\nexport type McpConnectionState =\n\t| McpConnectionState.Stopped\n\t| McpConnectionState.Starting\n\t| McpConnectionState.Running\n\t| McpConnectionState.Error;\n\nexport class MpcResponseError extends Error {\n\tconstructor(message: string, public readonly code: number, public readonly data: unknown) {\n\t\tsuper(`MPC ${code}: ${message}`);\n\t}\n}\n\nexport class McpConnectionFailedError extends Error { }\n\nexport class UserInteractionRequiredError extends Error {\n\tprivate static readonly prefix = 'User interaction required: ';\n\n\tpublic static is(error: Error): boolean {\n\t\treturn error.message.startsWith(this.prefix);\n\t}\n\n\tconstructor(public readonly reason: string) {\n\t\tsuper(`${UserInteractionRequiredError.prefix}${reason}`);\n\t}\n}\n\nexport interface IMcpConfigPath {\n\tid: string;\n\tkey: 'userLocalValue' | 'userRemoteValue' | 'workspaceValue' | 'workspaceFolderValue';\n\tlabel: string;\n\tscope: StorageScope;\n\ttarget: ConfigurationTarget;\n\torder: number;\n\tremoteAuthority?: string;\n\turi: URI | undefined;\n\tsection?: string[];\n\tworkspaceFolder?: IWorkspaceFolder;\n}\n\nexport interface IMcpServerContainer extends IDisposable {\n\tmcpServer: IWorkbenchMcpServer | null;\n\tupdate(): void;\n}\n\nexport interface IMcpServerEditorOptions extends IEditorOptions {\n\ttab?: McpServerEditorTab;\n\tsideByside?: boolean;\n}\n\nexport const enum McpServerEnablementState {\n\tDisabled,\n\tDisabledByAccess,\n\tEnabled,\n}\n\nexport const enum McpServerInstallState {\n\tInstalling,\n\tInstalled,\n\tUninstalling,\n\tUninstalled\n}\n\nexport const enum McpServerEditorTab {\n\tReadme = 'readme',\n\tManifest = 'manifest',\n\tConfiguration = 'configuration',\n}\n\nexport type McpServerEnablementStatus = {\n\treadonly state: McpServerEnablementState;\n\treadonly message?: {\n\t\treadonly severity: Severity;\n\t\treadonly text: IMarkdownString;\n\t};\n};\n\nexport interface IWorkbenchMcpServer {\n\treadonly gallery: IGalleryMcpServer | undefined;\n\treadonly local: IWorkbenchLocalMcpServer | undefined;\n\treadonly installable: IInstallableMcpServer | undefined;\n\treadonly installState: McpServerInstallState;\n\treadonly runtimeStatus: McpServerEnablementStatus | undefined;\n\treadonly id: string;\n\treadonly name: string;\n\treadonly label: string;\n\treadonly description: string;\n\treadonly icon?: {\n\t\treadonly dark: string;\n\t\treadonly light: string;\n\t};\n\treadonly codicon?: string;\n\treadonly publisherUrl?: string;\n\treadonly publisherDisplayName?: string;\n\treadonly starsCount?: number;\n\treadonly license?: string;\n\treadonly repository?: string;\n\treadonly config?: IMcpServerConfiguration | undefined;\n\treadonly readmeUrl?: URI;\n\tgetReadme(token: CancellationToken): Promise<string>;\n\tgetManifest(token: CancellationToken): Promise<IGalleryMcpServerConfiguration>;\n}\n\nexport const IMcpWorkbenchService = createDecorator<IMcpWorkbenchService>('IMcpWorkbenchService');\nexport interface IMcpWorkbenchService {\n\treadonly _serviceBrand: undefined;\n\treadonly onChange: Event<IWorkbenchMcpServer | undefined>;\n\treadonly onReset: Event<void>;\n\treadonly local: readonly IWorkbenchMcpServer[];\n\tgetEnabledLocalMcpServers(): IWorkbenchLocalMcpServer[];\n\tqueryLocal(): Promise<IWorkbenchMcpServer[]>;\n\tqueryGallery(options?: IQueryOptions, token?: CancellationToken): Promise<IIterativePager<IWorkbenchMcpServer>>;\n\tcanInstall(mcpServer: IWorkbenchMcpServer): true | IMarkdownString;\n\tinstall(server: IWorkbenchMcpServer, installOptions?: IWorkbencMcpServerInstallOptions): Promise<IWorkbenchMcpServer>;\n\tuninstall(mcpServer: IWorkbenchMcpServer): Promise<void>;\n\tgetMcpConfigPath(arg: IWorkbenchLocalMcpServer): IMcpConfigPath | undefined;\n\tgetMcpConfigPath(arg: URI): Promise<IMcpConfigPath | undefined>;\n\topenSearch(searchValue: string, preserveFoucs?: boolean): Promise<void>;\n\topen(extension: IWorkbenchMcpServer | string, options?: IMcpServerEditorOptions): Promise<void>;\n}\n\nexport class McpServerContainers extends Disposable {\n\tconstructor(\n\t\tprivate readonly containers: IMcpServerContainer[],\n\t\t@IMcpWorkbenchService mcpWorkbenchService: IMcpWorkbenchService\n\t) {\n\t\tsuper();\n\t\tthis._register(mcpWorkbenchService.onChange(this.update, this));\n\t}\n\n\tset mcpServer(extension: IWorkbenchMcpServer | null) {\n\t\tthis.containers.forEach(c => c.mcpServer = extension);\n\t}\n\n\tupdate(server: IWorkbenchMcpServer | undefined): void {\n\t\tfor (const container of this.containers) {\n\t\t\tif (server && container.mcpServer) {\n\t\t\t\tif (server.id === container.mcpServer.id) {\n\t\t\t\t\tcontainer.mcpServer = server;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontainer.update();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport const McpServersGalleryStatusContext = new RawContextKey<string>('mcpServersGalleryStatus', McpGalleryManifestStatus.Unavailable);\nexport const HasInstalledMcpServersContext = new RawContextKey<boolean>('hasInstalledMcpServers', true);\nexport const InstalledMcpServersViewId = 'workbench.views.mcp.installed';\n\nexport namespace McpResourceURI {\n\texport const scheme = 'mcp-resource';\n\n\t// Random placeholder for empty authorities, otherwise they're represente as\n\t// `scheme//path/here` in the URI which would get normalized to `scheme/path/here`.\n\tconst emptyAuthorityPlaceholder = 'dylo78gyp'; // chosen by a fair dice roll. Guaranteed to be random.\n\n\texport function fromServer(def: McpDefinitionReference, resourceURI: URI | string): URI {\n\t\tif (typeof resourceURI === 'string') {\n\t\t\tresourceURI = URI.parse(resourceURI);\n\t\t}\n\t\treturn resourceURI.with({\n\t\t\tscheme,\n\t\t\tauthority: encodeHex(VSBuffer.fromString(def.id)),\n\t\t\tpath: ['', resourceURI.scheme, resourceURI.authority || emptyAuthorityPlaceholder].join('/') + resourceURI.path,\n\t\t});\n\t}\n\n\texport function toServer(uri: URI | string): { definitionId: string; resourceURL: URL } {\n\t\tif (typeof uri === 'string') {\n\t\t\turi = URI.parse(uri);\n\t\t}\n\t\tif (uri.scheme !== scheme) {\n\t\t\tthrow new Error(`Invalid MCP resource URI: ${uri.toString()}`);\n\t\t}\n\t\tconst parts = uri.path.split('/');\n\t\tif (parts.length < 3) {\n\t\t\tthrow new Error(`Invalid MCP resource URI: ${uri.toString()}`);\n\t\t}\n\t\tconst [, serverScheme, authority, ...path] = parts;\n\n\t\t// URI cannot correctly stringify empty authorities (#250905) so we use URL instead to construct\n\t\tconst url = new URL(`${serverScheme}://${authority.toLowerCase() === emptyAuthorityPlaceholder ? '' : authority}`);\n\t\turl.pathname = path.length ? ('/' + path.join('/')) : '';\n\t\turl.search = uri.query;\n\t\turl.hash = uri.fragment;\n\n\t\treturn {\n\t\t\tdefinitionId: decodeHex(uri.authority).toString(),\n\t\t\tresourceURL: url,\n\t\t};\n\t}\n\n}\n\n/** Warning: this enum is cached in `mcpServer.ts` and all changes MUST only be additive. */\nexport const enum McpCapability {\n\tLogging = 1 << 0,\n\tCompletions = 1 << 1,\n\tPrompts = 1 << 2,\n\tPromptsListChanged = 1 << 3,\n\tResources = 1 << 4,\n\tResourcesSubscribe = 1 << 5,\n\tResourcesListChanged = 1 << 6,\n\tTools = 1 << 7,\n\tToolsListChanged = 1 << 8,\n}\n\nexport interface ISamplingOptions {\n\tserver: IMcpServer;\n\tisDuringToolCall: boolean;\n\tparams: MCP.CreateMessageRequest['params'];\n}\n\nexport interface ISamplingResult {\n\tsample: MCP.CreateMessageResult;\n}\n\nexport interface IMcpSamplingService {\n\t_serviceBrand: undefined;\n\n\tsample(opts: ISamplingOptions): Promise<ISamplingResult>;\n\n\t/** Whether MCP sampling logs are available for this server */\n\thasLogs(server: IMcpServer): boolean;\n\t/** Gets a text report of the MCP server's sampling usage */\n\tgetLogText(server: IMcpServer): string;\n\n\tgetConfig(server: IMcpServer): IMcpServerSamplingConfiguration;\n\tupdateConfig(server: IMcpServer, mutate: (r: IMcpServerSamplingConfiguration) => unknown): Promise<IMcpServerSamplingConfiguration>;\n}\n\nexport const IMcpSamplingService = createDecorator<IMcpSamplingService>('IMcpServerSampling');\n\nexport class McpError extends Error {\n\tpublic static methodNotFound(method: string) {\n\t\treturn new McpError(MCP.METHOD_NOT_FOUND, `Method not found: ${method}`);\n\t}\n\n\tpublic static notAllowed() {\n\t\treturn new McpError(-32000, 'The user has denied permission to call this method.');\n\t}\n\n\tpublic static unknown(e: Error) {\n\t\tconst mcpError = new McpError(MCP.INTERNAL_ERROR, `Unknown error: ${e.stack}`);\n\t\tmcpError.cause = e;\n\t\treturn mcpError;\n\t}\n\n\tconstructor(\n\t\tpublic readonly code: number,\n\t\tmessage: string,\n\t\tpublic readonly data?: unknown\n\t) {\n\t\tsuper(message);\n\t}\n}\n\nexport const enum McpToolName {\n\tPrefix = 'mcp_',\n\tMaxPrefixLen = 18,\n\tMaxLength = 64,\n}\n\n\nexport interface IMcpElicitationService {\n\t_serviceBrand: undefined;\n\n\t/**\n\t * Elicits a response from the user. The `context` is optional and can be used\n\t * to provide additional information about the request.\n\t *\n\t * @param context Context for the elicitation, e.g. chat session ID.\n\t * @param elicitation Request to elicit a response.\n\t * @returns A promise that resolves to an {@link ElicitationResult}.\n\t */\n\telicit(server: IMcpServer, context: IMcpToolCallContext | undefined, elicitation: MCP.ElicitRequest['params'], token: CancellationToken): Promise<ElicitResult>;\n}\n\nexport const enum ElicitationKind {\n\tForm,\n\tURL,\n}\n\nexport interface IUrlModeElicitResult extends IDisposable {\n\tkind: ElicitationKind.URL;\n\tvalue: MCP.ElicitResult;\n\t/**\n\t * Waits until the server tells us the elicitation is completed before resolving.\n\t * Rejects with a CancellationError if the server stops before elicitation is\n\t * complete, or if the token is cancelled.\n\t */\n\twait: Promise<void>;\n}\n\nexport interface IFormModeElicitResult extends IDisposable {\n\tkind: ElicitationKind.Form;\n\tvalue: MCP.ElicitResult;\n}\n\nexport type ElicitResult = IUrlModeElicitResult | IFormModeElicitResult;\n\nexport const IMcpElicitationService = createDecorator<IMcpElicitationService>('IMcpElicitationService');\n\nexport const McpToolResourceLinkMimeType = 'application/vnd.code.resource-link';\n\nexport interface IMcpToolResourceLinkContents {\n\turi: UriComponents;\n\tunderlyingMimeType?: string;\n}\n\nexport interface IMcpIcons {\n\t/** Gets the image URI appropriate to the approximate display size */\n\tgetUrl(size: number): { dark: URI; light?: URI } | undefined;\n}\n"]}