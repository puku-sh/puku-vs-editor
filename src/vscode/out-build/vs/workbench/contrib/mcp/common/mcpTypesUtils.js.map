{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/common/mcpTypesUtils.ts","vs/workbench/contrib/mcp/common/mcpTypesUtils.ts"],"names":[],"mappings":"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","file":"mcpTypesUtils.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { disposableTimeout, timeout } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { autorun, IReader } from '../../../../base/common/observable.js';\nimport { ToolDataSource } from '../../chat/common/languageModelToolsService.js';\nimport { IMcpServer, IMcpServerStartOpts, IMcpService, McpConnectionState, McpServerCacheState, McpServerTransportType } from './mcpTypes.js';\n\n\n/**\n * Waits up to `timeout` for a server passing the filter to be discovered,\n * and then starts it.\n */\nexport function startServerByFilter(mcpService: IMcpService, filter: (s: IMcpServer) => boolean, timeout = 5000) {\n\treturn new Promise<void>((resolve, reject) => {\n\t\tconst store = new DisposableStore();\n\t\tstore.add(autorun(reader => {\n\t\t\tconst servers = mcpService.servers.read(reader);\n\t\t\tconst server = servers.find(filter);\n\n\t\t\tif (server) {\n\t\t\t\tserver.start({ promptType: 'all-untrusted' }).then(state => {\n\t\t\t\t\tif (state.state === McpConnectionState.Kind.Error) {\n\t\t\t\t\t\tserver.showOutput();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tresolve();\n\t\t\t\tstore.dispose();\n\t\t\t}\n\t\t}));\n\n\t\tstore.add(disposableTimeout(() => {\n\t\t\tstore.dispose();\n\t\t\treject(new CancellationError());\n\t\t}, timeout));\n\t});\n}\n\n/**\n * Starts a server (if needed) and waits for its tools to be live. Returns\n * true/false whether this happened successfully.\n */\nexport async function startServerAndWaitForLiveTools(server: IMcpServer, opts?: IMcpServerStartOpts, token?: CancellationToken): Promise<boolean> {\n\tconst r = await server.start(opts);\n\n\tconst store = new DisposableStore();\n\tconst ok = await new Promise<boolean>(resolve => {\n\t\tif (token?.isCancellationRequested || r.state === McpConnectionState.Kind.Error || r.state === McpConnectionState.Kind.Stopped) {\n\t\t\treturn resolve(false);\n\t\t}\n\n\t\tif (token) {\n\t\t\tstore.add(token.onCancellationRequested(() => {\n\t\t\t\tresolve(false);\n\t\t\t}));\n\t\t}\n\n\t\tstore.add(autorun(reader => {\n\t\t\tconst connState = server.connectionState.read(reader).state;\n\t\t\tif (connState === McpConnectionState.Kind.Error || connState === McpConnectionState.Kind.Stopped) {\n\t\t\t\tresolve(false); // some error, don't block the request\n\t\t\t}\n\n\t\t\tconst toolState = server.cacheState.read(reader);\n\t\t\tif (toolState === McpServerCacheState.Live) {\n\t\t\t\tresolve(true); // got tools, all done\n\t\t\t}\n\t\t}));\n\t});\n\n\tif (ok) {\n\t\tawait timeout(0); // let the tools register in the language model contribution\n\t}\n\n\treturn ok;\n}\n\nexport function mcpServerToSourceData(server: IMcpServer, reader?: IReader): ToolDataSource {\n\tconst metadata = server.serverMetadata.read(reader);\n\treturn {\n\t\ttype: 'mcp',\n\t\tserverLabel: metadata?.serverName,\n\t\tinstructions: metadata?.serverInstructions,\n\t\tlabel: server.definition.label,\n\t\tcollectionId: server.collection.id,\n\t\tdefinitionId: server.definition.id\n\t};\n}\n\n\n/**\n * Validates whether the given HTTP or HTTPS resource is allowed for the specified MCP server.\n *\n * @param resource The URI of the resource to validate.\n * @param server The MCP server instance to validate against, or undefined.\n * @returns True if the resource request is valid for the server, false otherwise.\n */\nexport function canLoadMcpNetworkResourceDirectly(resource: URL, server: IMcpServer | undefined) {\n\tlet isResourceRequestValid = false;\n\tif (resource.protocol === 'http:') {\n\t\tconst launch = server?.connection.get()?.launchDefinition;\n\t\tif (launch && launch.type === McpServerTransportType.HTTP && launch.uri.authority.toLowerCase() === resource.hostname.toLowerCase()) {\n\t\t\tisResourceRequestValid = true;\n\t\t}\n\t} else if (resource.protocol === 'https:') {\n\t\tisResourceRequestValid = true;\n\t}\n\treturn isResourceRequestValid;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { disposableTimeout, timeout } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { autorun, IReader } from '../../../../base/common/observable.js';\nimport { ToolDataSource } from '../../chat/common/languageModelToolsService.js';\nimport { IMcpServer, IMcpServerStartOpts, IMcpService, McpConnectionState, McpServerCacheState, McpServerTransportType } from './mcpTypes.js';\n\n\n/**\n * Waits up to `timeout` for a server passing the filter to be discovered,\n * and then starts it.\n */\nexport function startServerByFilter(mcpService: IMcpService, filter: (s: IMcpServer) => boolean, timeout = 5000) {\n\treturn new Promise<void>((resolve, reject) => {\n\t\tconst store = new DisposableStore();\n\t\tstore.add(autorun(reader => {\n\t\t\tconst servers = mcpService.servers.read(reader);\n\t\t\tconst server = servers.find(filter);\n\n\t\t\tif (server) {\n\t\t\t\tserver.start({ promptType: 'all-untrusted' }).then(state => {\n\t\t\t\t\tif (state.state === McpConnectionState.Kind.Error) {\n\t\t\t\t\t\tserver.showOutput();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tresolve();\n\t\t\t\tstore.dispose();\n\t\t\t}\n\t\t}));\n\n\t\tstore.add(disposableTimeout(() => {\n\t\t\tstore.dispose();\n\t\t\treject(new CancellationError());\n\t\t}, timeout));\n\t});\n}\n\n/**\n * Starts a server (if needed) and waits for its tools to be live. Returns\n * true/false whether this happened successfully.\n */\nexport async function startServerAndWaitForLiveTools(server: IMcpServer, opts?: IMcpServerStartOpts, token?: CancellationToken): Promise<boolean> {\n\tconst r = await server.start(opts);\n\n\tconst store = new DisposableStore();\n\tconst ok = await new Promise<boolean>(resolve => {\n\t\tif (token?.isCancellationRequested || r.state === McpConnectionState.Kind.Error || r.state === McpConnectionState.Kind.Stopped) {\n\t\t\treturn resolve(false);\n\t\t}\n\n\t\tif (token) {\n\t\t\tstore.add(token.onCancellationRequested(() => {\n\t\t\t\tresolve(false);\n\t\t\t}));\n\t\t}\n\n\t\tstore.add(autorun(reader => {\n\t\t\tconst connState = server.connectionState.read(reader).state;\n\t\t\tif (connState === McpConnectionState.Kind.Error || connState === McpConnectionState.Kind.Stopped) {\n\t\t\t\tresolve(false); // some error, don't block the request\n\t\t\t}\n\n\t\t\tconst toolState = server.cacheState.read(reader);\n\t\t\tif (toolState === McpServerCacheState.Live) {\n\t\t\t\tresolve(true); // got tools, all done\n\t\t\t}\n\t\t}));\n\t});\n\n\tif (ok) {\n\t\tawait timeout(0); // let the tools register in the language model contribution\n\t}\n\n\treturn ok;\n}\n\nexport function mcpServerToSourceData(server: IMcpServer, reader?: IReader): ToolDataSource {\n\tconst metadata = server.serverMetadata.read(reader);\n\treturn {\n\t\ttype: 'mcp',\n\t\tserverLabel: metadata?.serverName,\n\t\tinstructions: metadata?.serverInstructions,\n\t\tlabel: server.definition.label,\n\t\tcollectionId: server.collection.id,\n\t\tdefinitionId: server.definition.id\n\t};\n}\n\n\n/**\n * Validates whether the given HTTP or HTTPS resource is allowed for the specified MCP server.\n *\n * @param resource The URI of the resource to validate.\n * @param server The MCP server instance to validate against, or undefined.\n * @returns True if the resource request is valid for the server, false otherwise.\n */\nexport function canLoadMcpNetworkResourceDirectly(resource: URL, server: IMcpServer | undefined) {\n\tlet isResourceRequestValid = false;\n\tif (resource.protocol === 'http:') {\n\t\tconst launch = server?.connection.get()?.launchDefinition;\n\t\tif (launch && launch.type === McpServerTransportType.HTTP && launch.uri.authority.toLowerCase() === resource.hostname.toLowerCase()) {\n\t\t\tisResourceRequestValid = true;\n\t\t}\n\t} else if (resource.protocol === 'https:') {\n\t\tisResourceRequestValid = true;\n\t}\n\treturn isResourceRequestValid;\n}\n"]}