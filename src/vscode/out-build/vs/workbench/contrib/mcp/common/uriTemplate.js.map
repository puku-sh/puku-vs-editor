{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/common/uriTemplate.ts","vs/workbench/contrib/mcp/common/uriTemplate.ts"],"names":[],"mappings":"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","file":"uriTemplate.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IUriTemplateVariable {\n\treadonly explodable: boolean;\n\treadonly name: string;\n\treadonly optional: boolean;\n\treadonly prefixLength?: number;\n\treadonly repeatable: boolean;\n}\n\ninterface IUriTemplateComponent {\n\treadonly expression: string;\n\treadonly operator: string;\n\treadonly variables: readonly IUriTemplateVariable[];\n}\n\n/**\n * Represents an RFC 6570 URI Template.\n */\nexport class UriTemplate {\n\t/**\n\t * The parsed template components (expressions).\n\t */\n\tpublic readonly components: ReadonlyArray<IUriTemplateComponent | string>;\n\n\tprivate constructor(\n\t\tpublic readonly template: string,\n\t\tcomponents: ReadonlyArray<IUriTemplateComponent | string>\n\t) {\n\t\tthis.template = template;\n\t\tthis.components = components;\n\t}\n\n\t/**\n\t * Parses a URI template string into a UriTemplate instance.\n\t */\n\tpublic static parse(template: string): UriTemplate {\n\t\tconst components: Array<IUriTemplateComponent | string> = [];\n\t\tconst regex = /\\{([^{}]+)\\}/g;\n\t\tlet match: RegExpExecArray | null;\n\t\tlet lastPos = 0;\n\t\twhile ((match = regex.exec(template))) {\n\t\t\tconst [expression, inner] = match;\n\t\t\tcomponents.push(template.slice(lastPos, match.index));\n\t\t\tlastPos = match.index + expression.length;\n\n\t\t\t// Handle escaped braces: treat '{{' and '}}' as literals, not expressions\n\t\t\tif (template[match.index - 1] === '{' || template[lastPos] === '}') {\n\t\t\t\tcomponents.push(inner);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet operator = '';\n\t\t\tlet rest = inner;\n\t\t\tif (rest.length > 0 && UriTemplate._isOperator(rest[0])) {\n\t\t\t\toperator = rest[0];\n\t\t\t\trest = rest.slice(1);\n\t\t\t}\n\t\t\tconst variables = rest.split(',').map((v): IUriTemplateVariable => {\n\t\t\t\tlet name = v;\n\t\t\t\tlet explodable = false;\n\t\t\t\tlet repeatable = false;\n\t\t\t\tlet prefixLength: number | undefined = undefined;\n\t\t\t\tlet optional = false;\n\t\t\t\tif (name.endsWith('*')) {\n\t\t\t\t\texplodable = true;\n\t\t\t\t\trepeatable = true;\n\t\t\t\t\tname = name.slice(0, -1);\n\t\t\t\t}\n\t\t\t\tconst prefixMatch = name.match(/^(.*?):(\\d+)$/);\n\t\t\t\tif (prefixMatch) {\n\t\t\t\t\tname = prefixMatch[1];\n\t\t\t\t\tprefixLength = parseInt(prefixMatch[2], 10);\n\t\t\t\t}\n\t\t\t\tif (name.endsWith('?')) {\n\t\t\t\t\toptional = true;\n\t\t\t\t\tname = name.slice(0, -1);\n\t\t\t\t}\n\t\t\t\treturn { explodable, name, optional, prefixLength, repeatable };\n\t\t\t});\n\t\t\tcomponents.push({ expression, operator, variables });\n\t\t}\n\t\tcomponents.push(template.slice(lastPos));\n\n\t\treturn new UriTemplate(template, components);\n\t}\n\n\tprivate static _operators = ['+', '#', '.', '/', ';', '?', '&'] as const;\n\tprivate static _isOperator(ch: string): boolean {\n\t\treturn (UriTemplate._operators as readonly string[]).includes(ch);\n\t}\n\n\t/**\n\t * Resolves the template with the given variables.\n\t */\n\tpublic resolve(variables: Record<string, unknown>): string {\n\t\tlet result = '';\n\t\tfor (const comp of this.components) {\n\t\t\tif (typeof comp === 'string') {\n\t\t\t\tresult += comp;\n\t\t\t} else {\n\t\t\t\tresult += this._expand(comp, variables);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _expand(comp: IUriTemplateComponent, variables: Record<string, unknown>): string {\n\t\tconst op = comp.operator;\n\t\tconst varSpecs = comp.variables;\n\t\tif (varSpecs.length === 0) {\n\t\t\treturn comp.expression;\n\t\t}\n\t\tconst vals: string[] = [];\n\t\tconst isNamed = op === ';' || op === '?' || op === '&';\n\t\tconst isReserved = op === '+' || op === '#';\n\t\tconst isFragment = op === '#';\n\t\tconst isLabel = op === '.';\n\t\tconst isPath = op === '/';\n\t\tconst isForm = op === '?';\n\t\tconst isFormCont = op === '&';\n\t\tconst isParam = op === ';';\n\n\t\tlet prefix = '';\n\t\tif (op === '+') { prefix = ''; }\n\t\telse if (op === '#') { prefix = '#'; }\n\t\telse if (op === '.') { prefix = '.'; }\n\t\telse if (op === '/') { prefix = ''; }\n\t\telse if (op === ';') { prefix = ';'; }\n\t\telse if (op === '?') { prefix = '?'; }\n\t\telse if (op === '&') { prefix = '&'; }\n\n\t\tfor (const v of varSpecs) {\n\t\t\tconst value = variables[v.name];\n\t\t\tconst defined = Object.prototype.hasOwnProperty.call(variables, v.name);\n\t\t\tif (value === undefined || value === null || (Array.isArray(value) && value.length === 0)) {\n\t\t\t\tif (isParam) {\n\t\t\t\t\tif (defined && (value === null || value === undefined)) {\n\t\t\t\t\t\tvals.push(v.name);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isForm || isFormCont) {\n\t\t\t\t\tif (defined) {\n\t\t\t\t\t\tvals.push(UriTemplate._formPair(v.name, '', isNamed));\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t\tif (v.explodable) {\n\t\t\t\t\tconst pairs: string[] = [];\n\t\t\t\t\tfor (const k in value) {\n\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\tconst thisVal = String((value as Record<string, unknown>)[k]);\n\t\t\t\t\t\t\tif (isParam) {\n\t\t\t\t\t\t\t\tpairs.push(k + '=' + thisVal);\n\t\t\t\t\t\t\t} else if (isForm || isFormCont) {\n\t\t\t\t\t\t\t\tpairs.push(k + '=' + thisVal);\n\t\t\t\t\t\t\t} else if (isLabel) {\n\t\t\t\t\t\t\t\tpairs.push(k + '=' + thisVal);\n\t\t\t\t\t\t\t} else if (isPath) {\n\t\t\t\t\t\t\t\tpairs.push('/' + k + '=' + UriTemplate._encode(thisVal, isReserved));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpairs.push(k + '=' + UriTemplate._encode(thisVal, isReserved));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isLabel) {\n\t\t\t\t\t\tvals.push(pairs.join('.'));\n\t\t\t\t\t} else if (isPath) {\n\t\t\t\t\t\tvals.push(pairs.join(''));\n\t\t\t\t\t} else if (isParam) {\n\t\t\t\t\t\tvals.push(pairs.join(';'));\n\t\t\t\t\t} else if (isForm || isFormCont) {\n\t\t\t\t\t\tvals.push(pairs.join('&'));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvals.push(pairs.join(','));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Not explodable: join as k1,v1,k2,v2,... and assign to variable name\n\t\t\t\t\tconst pairs: string[] = [];\n\t\t\t\t\tfor (const k in value) {\n\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\tpairs.push(k);\n\t\t\t\t\t\t\tpairs.push(String((value as Record<string, unknown>)[k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// For label, param, form, join as keys=semi,;,dot,.,comma,, (no encoding of , or ;)\n\t\t\t\t\tconst joined = pairs.join(',');\n\t\t\t\t\tif (isLabel) {\n\t\t\t\t\t\tvals.push(joined);\n\t\t\t\t\t} else if (isParam || isForm || isFormCont) {\n\t\t\t\t\t\tvals.push(v.name + '=' + joined);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvals.push(joined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tif (v.explodable) {\n\t\t\t\t\tif (isLabel) {\n\t\t\t\t\t\tvals.push(value.join('.'));\n\t\t\t\t\t} else if (isPath) {\n\t\t\t\t\t\tvals.push(value.map(x => '/' + UriTemplate._encode(x, isReserved)).join(''));\n\t\t\t\t\t} else if (isParam) {\n\t\t\t\t\t\tvals.push(value.map(x => v.name + '=' + String(x)).join(';'));\n\t\t\t\t\t} else if (isForm || isFormCont) {\n\t\t\t\t\t\tvals.push(value.map(x => v.name + '=' + String(x)).join('&'));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvals.push(value.map(x => UriTemplate._encode(x, isReserved)).join(','));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isLabel) {\n\t\t\t\t\t\tvals.push(value.join(','));\n\t\t\t\t\t} else if (isParam) {\n\t\t\t\t\t\tvals.push(v.name + '=' + value.join(','));\n\t\t\t\t\t} else if (isForm || isFormCont) {\n\t\t\t\t\t\tvals.push(v.name + '=' + value.join(','));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvals.push(value.map(x => UriTemplate._encode(x, isReserved)).join(','));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet str = String(value);\n\t\t\tif (v.prefixLength !== undefined) {\n\t\t\t\tstr = str.substring(0, v.prefixLength);\n\t\t\t}\n\t\t\t// For simple expansion, encode ! as well (not reserved)\n\t\t\t// Only + and # are reserved\n\t\t\tconst enc = UriTemplate._encode(str, op === '+' || op === '#');\n\t\t\tif (isParam) {\n\t\t\t\tvals.push(v.name + '=' + enc);\n\t\t\t} else if (isForm || isFormCont) {\n\t\t\t\tvals.push(v.name + '=' + enc);\n\t\t\t} else if (isLabel) {\n\t\t\t\tvals.push(enc);\n\t\t\t} else if (isPath) {\n\t\t\t\tvals.push('/' + enc);\n\t\t\t} else {\n\t\t\t\tvals.push(enc);\n\t\t\t}\n\t\t}\n\n\t\tlet joined = '';\n\t\tif (isLabel) {\n\t\t\t// Remove trailing dot for missing values\n\t\t\tconst filtered = vals.filter(v => v !== '');\n\t\t\tjoined = filtered.length ? prefix + filtered.join('.') : '';\n\t\t} else if (isPath) {\n\t\t\t// Remove empty segments for undefined/null\n\t\t\tconst filtered = vals.filter(v => v !== '');\n\t\t\tjoined = filtered.length ? filtered.join('') : '';\n\t\t\tif (joined && !joined.startsWith('/')) {\n\t\t\t\tjoined = '/' + joined;\n\t\t\t}\n\t\t} else if (isParam) {\n\t\t\t// For param, if value is empty string, just append ;name\n\t\t\tjoined = vals.length ? prefix + vals.map(v => v.replace(/=\\s*$/, '')).join(';') : '';\n\t\t} else if (isForm) {\n\t\t\tjoined = vals.length ? prefix + vals.join('&') : '';\n\t\t} else if (isFormCont) {\n\t\t\tjoined = vals.length ? prefix + vals.join('&') : '';\n\t\t} else if (isFragment) {\n\t\t\tjoined = prefix + vals.join(',');\n\t\t} else if (isReserved) {\n\t\t\tjoined = vals.join(',');\n\t\t} else {\n\t\t\tjoined = vals.join(',');\n\t\t}\n\t\treturn joined;\n\t}\n\n\tprivate static _encode(str: string, reserved: boolean): string {\n\t\treturn reserved ? encodeURI(str) : pctEncode(str);\n\t}\n\n\tprivate static _formPair(k: string, v: unknown, named: boolean): string {\n\t\treturn named ? k + '=' + encodeURIComponent(String(v)) : encodeURIComponent(String(v));\n\t}\n}\n\nfunction pctEncode(str: string): string {\n\tlet out = '';\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\t\tif (\n\t\t\t// alphanum ranges:\n\t\t\t(chr >= 0x30 && chr <= 0x39 || chr >= 0x41 && chr <= 0x5a || chr >= 0x61 && chr <= 0x7a) ||\n\t\t\t// unreserved characters:\n\t\t\t(chr === 0x2d || chr === 0x2e || chr === 0x5f || chr === 0x7e)\n\t\t) {\n\t\t\tout += str[i];\n\t\t} else {\n\t\t\tout += '%' + chr.toString(16).toUpperCase();\n\t\t}\n\t}\n\treturn out;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IUriTemplateVariable {\n\treadonly explodable: boolean;\n\treadonly name: string;\n\treadonly optional: boolean;\n\treadonly prefixLength?: number;\n\treadonly repeatable: boolean;\n}\n\ninterface IUriTemplateComponent {\n\treadonly expression: string;\n\treadonly operator: string;\n\treadonly variables: readonly IUriTemplateVariable[];\n}\n\n/**\n * Represents an RFC 6570 URI Template.\n */\nexport class UriTemplate {\n\t/**\n\t * The parsed template components (expressions).\n\t */\n\tpublic readonly components: ReadonlyArray<IUriTemplateComponent | string>;\n\n\tprivate constructor(\n\t\tpublic readonly template: string,\n\t\tcomponents: ReadonlyArray<IUriTemplateComponent | string>\n\t) {\n\t\tthis.template = template;\n\t\tthis.components = components;\n\t}\n\n\t/**\n\t * Parses a URI template string into a UriTemplate instance.\n\t */\n\tpublic static parse(template: string): UriTemplate {\n\t\tconst components: Array<IUriTemplateComponent | string> = [];\n\t\tconst regex = /\\{([^{}]+)\\}/g;\n\t\tlet match: RegExpExecArray | null;\n\t\tlet lastPos = 0;\n\t\twhile ((match = regex.exec(template))) {\n\t\t\tconst [expression, inner] = match;\n\t\t\tcomponents.push(template.slice(lastPos, match.index));\n\t\t\tlastPos = match.index + expression.length;\n\n\t\t\t// Handle escaped braces: treat '{{' and '}}' as literals, not expressions\n\t\t\tif (template[match.index - 1] === '{' || template[lastPos] === '}') {\n\t\t\t\tcomponents.push(inner);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet operator = '';\n\t\t\tlet rest = inner;\n\t\t\tif (rest.length > 0 && UriTemplate._isOperator(rest[0])) {\n\t\t\t\toperator = rest[0];\n\t\t\t\trest = rest.slice(1);\n\t\t\t}\n\t\t\tconst variables = rest.split(',').map((v): IUriTemplateVariable => {\n\t\t\t\tlet name = v;\n\t\t\t\tlet explodable = false;\n\t\t\t\tlet repeatable = false;\n\t\t\t\tlet prefixLength: number | undefined = undefined;\n\t\t\t\tlet optional = false;\n\t\t\t\tif (name.endsWith('*')) {\n\t\t\t\t\texplodable = true;\n\t\t\t\t\trepeatable = true;\n\t\t\t\t\tname = name.slice(0, -1);\n\t\t\t\t}\n\t\t\t\tconst prefixMatch = name.match(/^(.*?):(\\d+)$/);\n\t\t\t\tif (prefixMatch) {\n\t\t\t\t\tname = prefixMatch[1];\n\t\t\t\t\tprefixLength = parseInt(prefixMatch[2], 10);\n\t\t\t\t}\n\t\t\t\tif (name.endsWith('?')) {\n\t\t\t\t\toptional = true;\n\t\t\t\t\tname = name.slice(0, -1);\n\t\t\t\t}\n\t\t\t\treturn { explodable, name, optional, prefixLength, repeatable };\n\t\t\t});\n\t\t\tcomponents.push({ expression, operator, variables });\n\t\t}\n\t\tcomponents.push(template.slice(lastPos));\n\n\t\treturn new UriTemplate(template, components);\n\t}\n\n\tprivate static _operators = ['+', '#', '.', '/', ';', '?', '&'] as const;\n\tprivate static _isOperator(ch: string): boolean {\n\t\treturn (UriTemplate._operators as readonly string[]).includes(ch);\n\t}\n\n\t/**\n\t * Resolves the template with the given variables.\n\t */\n\tpublic resolve(variables: Record<string, unknown>): string {\n\t\tlet result = '';\n\t\tfor (const comp of this.components) {\n\t\t\tif (typeof comp === 'string') {\n\t\t\t\tresult += comp;\n\t\t\t} else {\n\t\t\t\tresult += this._expand(comp, variables);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _expand(comp: IUriTemplateComponent, variables: Record<string, unknown>): string {\n\t\tconst op = comp.operator;\n\t\tconst varSpecs = comp.variables;\n\t\tif (varSpecs.length === 0) {\n\t\t\treturn comp.expression;\n\t\t}\n\t\tconst vals: string[] = [];\n\t\tconst isNamed = op === ';' || op === '?' || op === '&';\n\t\tconst isReserved = op === '+' || op === '#';\n\t\tconst isFragment = op === '#';\n\t\tconst isLabel = op === '.';\n\t\tconst isPath = op === '/';\n\t\tconst isForm = op === '?';\n\t\tconst isFormCont = op === '&';\n\t\tconst isParam = op === ';';\n\n\t\tlet prefix = '';\n\t\tif (op === '+') { prefix = ''; }\n\t\telse if (op === '#') { prefix = '#'; }\n\t\telse if (op === '.') { prefix = '.'; }\n\t\telse if (op === '/') { prefix = ''; }\n\t\telse if (op === ';') { prefix = ';'; }\n\t\telse if (op === '?') { prefix = '?'; }\n\t\telse if (op === '&') { prefix = '&'; }\n\n\t\tfor (const v of varSpecs) {\n\t\t\tconst value = variables[v.name];\n\t\t\tconst defined = Object.prototype.hasOwnProperty.call(variables, v.name);\n\t\t\tif (value === undefined || value === null || (Array.isArray(value) && value.length === 0)) {\n\t\t\t\tif (isParam) {\n\t\t\t\t\tif (defined && (value === null || value === undefined)) {\n\t\t\t\t\t\tvals.push(v.name);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isForm || isFormCont) {\n\t\t\t\t\tif (defined) {\n\t\t\t\t\t\tvals.push(UriTemplate._formPair(v.name, '', isNamed));\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t\tif (v.explodable) {\n\t\t\t\t\tconst pairs: string[] = [];\n\t\t\t\t\tfor (const k in value) {\n\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\tconst thisVal = String((value as Record<string, unknown>)[k]);\n\t\t\t\t\t\t\tif (isParam) {\n\t\t\t\t\t\t\t\tpairs.push(k + '=' + thisVal);\n\t\t\t\t\t\t\t} else if (isForm || isFormCont) {\n\t\t\t\t\t\t\t\tpairs.push(k + '=' + thisVal);\n\t\t\t\t\t\t\t} else if (isLabel) {\n\t\t\t\t\t\t\t\tpairs.push(k + '=' + thisVal);\n\t\t\t\t\t\t\t} else if (isPath) {\n\t\t\t\t\t\t\t\tpairs.push('/' + k + '=' + UriTemplate._encode(thisVal, isReserved));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpairs.push(k + '=' + UriTemplate._encode(thisVal, isReserved));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isLabel) {\n\t\t\t\t\t\tvals.push(pairs.join('.'));\n\t\t\t\t\t} else if (isPath) {\n\t\t\t\t\t\tvals.push(pairs.join(''));\n\t\t\t\t\t} else if (isParam) {\n\t\t\t\t\t\tvals.push(pairs.join(';'));\n\t\t\t\t\t} else if (isForm || isFormCont) {\n\t\t\t\t\t\tvals.push(pairs.join('&'));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvals.push(pairs.join(','));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Not explodable: join as k1,v1,k2,v2,... and assign to variable name\n\t\t\t\t\tconst pairs: string[] = [];\n\t\t\t\t\tfor (const k in value) {\n\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\tpairs.push(k);\n\t\t\t\t\t\t\tpairs.push(String((value as Record<string, unknown>)[k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// For label, param, form, join as keys=semi,;,dot,.,comma,, (no encoding of , or ;)\n\t\t\t\t\tconst joined = pairs.join(',');\n\t\t\t\t\tif (isLabel) {\n\t\t\t\t\t\tvals.push(joined);\n\t\t\t\t\t} else if (isParam || isForm || isFormCont) {\n\t\t\t\t\t\tvals.push(v.name + '=' + joined);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvals.push(joined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tif (v.explodable) {\n\t\t\t\t\tif (isLabel) {\n\t\t\t\t\t\tvals.push(value.join('.'));\n\t\t\t\t\t} else if (isPath) {\n\t\t\t\t\t\tvals.push(value.map(x => '/' + UriTemplate._encode(x, isReserved)).join(''));\n\t\t\t\t\t} else if (isParam) {\n\t\t\t\t\t\tvals.push(value.map(x => v.name + '=' + String(x)).join(';'));\n\t\t\t\t\t} else if (isForm || isFormCont) {\n\t\t\t\t\t\tvals.push(value.map(x => v.name + '=' + String(x)).join('&'));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvals.push(value.map(x => UriTemplate._encode(x, isReserved)).join(','));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isLabel) {\n\t\t\t\t\t\tvals.push(value.join(','));\n\t\t\t\t\t} else if (isParam) {\n\t\t\t\t\t\tvals.push(v.name + '=' + value.join(','));\n\t\t\t\t\t} else if (isForm || isFormCont) {\n\t\t\t\t\t\tvals.push(v.name + '=' + value.join(','));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvals.push(value.map(x => UriTemplate._encode(x, isReserved)).join(','));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet str = String(value);\n\t\t\tif (v.prefixLength !== undefined) {\n\t\t\t\tstr = str.substring(0, v.prefixLength);\n\t\t\t}\n\t\t\t// For simple expansion, encode ! as well (not reserved)\n\t\t\t// Only + and # are reserved\n\t\t\tconst enc = UriTemplate._encode(str, op === '+' || op === '#');\n\t\t\tif (isParam) {\n\t\t\t\tvals.push(v.name + '=' + enc);\n\t\t\t} else if (isForm || isFormCont) {\n\t\t\t\tvals.push(v.name + '=' + enc);\n\t\t\t} else if (isLabel) {\n\t\t\t\tvals.push(enc);\n\t\t\t} else if (isPath) {\n\t\t\t\tvals.push('/' + enc);\n\t\t\t} else {\n\t\t\t\tvals.push(enc);\n\t\t\t}\n\t\t}\n\n\t\tlet joined = '';\n\t\tif (isLabel) {\n\t\t\t// Remove trailing dot for missing values\n\t\t\tconst filtered = vals.filter(v => v !== '');\n\t\t\tjoined = filtered.length ? prefix + filtered.join('.') : '';\n\t\t} else if (isPath) {\n\t\t\t// Remove empty segments for undefined/null\n\t\t\tconst filtered = vals.filter(v => v !== '');\n\t\t\tjoined = filtered.length ? filtered.join('') : '';\n\t\t\tif (joined && !joined.startsWith('/')) {\n\t\t\t\tjoined = '/' + joined;\n\t\t\t}\n\t\t} else if (isParam) {\n\t\t\t// For param, if value is empty string, just append ;name\n\t\t\tjoined = vals.length ? prefix + vals.map(v => v.replace(/=\\s*$/, '')).join(';') : '';\n\t\t} else if (isForm) {\n\t\t\tjoined = vals.length ? prefix + vals.join('&') : '';\n\t\t} else if (isFormCont) {\n\t\t\tjoined = vals.length ? prefix + vals.join('&') : '';\n\t\t} else if (isFragment) {\n\t\t\tjoined = prefix + vals.join(',');\n\t\t} else if (isReserved) {\n\t\t\tjoined = vals.join(',');\n\t\t} else {\n\t\t\tjoined = vals.join(',');\n\t\t}\n\t\treturn joined;\n\t}\n\n\tprivate static _encode(str: string, reserved: boolean): string {\n\t\treturn reserved ? encodeURI(str) : pctEncode(str);\n\t}\n\n\tprivate static _formPair(k: string, v: unknown, named: boolean): string {\n\t\treturn named ? k + '=' + encodeURIComponent(String(v)) : encodeURIComponent(String(v));\n\t}\n}\n\nfunction pctEncode(str: string): string {\n\tlet out = '';\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\t\tif (\n\t\t\t// alphanum ranges:\n\t\t\t(chr >= 0x30 && chr <= 0x39 || chr >= 0x41 && chr <= 0x5a || chr >= 0x61 && chr <= 0x7a) ||\n\t\t\t// unreserved characters:\n\t\t\t(chr === 0x2d || chr === 0x2e || chr === 0x5f || chr === 0x7e)\n\t\t) {\n\t\t\tout += str[i];\n\t\t} else {\n\t\t\tout += '%' + chr.toString(16).toUpperCase();\n\t\t}\n\t}\n\treturn out;\n}\n"]}