{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/common/mcpServerRequestHandler.ts","vs/workbench/contrib/mcp/common/mcpServerRequestHandler.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,MAAM,EAAE,MAAM,mCAAmC,CAAC;AAC3D,OAAO,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,mCAAmC,CAAC;AACjF,OAAO,EAAE,eAAe,EAAE,aAAa,EAAE,MAAM,kCAAkC,CAAC;AAClF,OAAO,EAAE,iBAAiB,EAAE,MAAM,yCAAyC,CAAC;AAC5E,OAAO,EAAE,iBAAiB,EAAE,MAAM,mCAAmC,CAAC;AACtE,OAAO,EAAE,OAAO,EAAE,MAAM,kCAAkC,CAAC;AAC3D,OAAO,EAAE,QAAQ,EAAE,MAAM,qCAAqC,CAAC;AAC/D,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,sCAAsC,CAAC;AACnF,OAAO,EAAE,OAAO,EAAE,MAAM,uCAAuC,CAAC;AAEhE,OAAO,EAAE,MAAM,EAAW,GAAG,EAAE,QAAQ,EAAE,MAAM,wCAAwC,CAAC;AACxF,OAAO,EAAE,eAAe,EAAE,MAAM,uDAAuD,CAAC;AAExF,OAAO,EAAyC,QAAQ,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAClG,OAAO,EAAE,GAAG,EAAE,MAAM,2BAA2B,CAAC;AAuBhD;;;;;GAKG;AACH,MAAM,OAAO,uBAAwB,SAAQ,UAAU;IAOtD,IAAW,KAAK,CAAC,KAAiB;QACjC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,CAAC;YACjC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YACpB,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;gBAC7B,IAAI,CAAC,gBAAgB,CAAC,EAAE,MAAM,EAAE,kCAAkC,EAAE,CAAC,CAAC;gBACtE,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;YACjC,CAAC;QACF,CAAC;IACF,CAAC;IAGD,IAAW,YAAY;QACtB,OAAO,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC;IACtC,CAAC;IAED,IAAW,UAAU;QACpB,OAAO,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC;IACpC,CAAC;IAED,IAAW,kBAAkB;QAC5B,OAAO,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC;IACtC,CAAC;IAwBD;;;OAGG;IACI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,YAAmC,EAAE,IAAqC,EAAE,KAAyB;QAC/H,MAAM,GAAG,GAAG,IAAI,uBAAuB,CAAC,IAAI,CAAC,CAAC;QAC9C,MAAM,KAAK,GAAG,IAAI,eAAe,EAAE,CAAC;QACpC,IAAI,CAAC;YACJ,MAAM,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,aAAa,EAAE,CAAC,CAAC;YAC7C,KAAK,CAAC,YAAY,CAAC,GAAG,EAAE;gBACvB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,0DAA0D,CAAC,CAAC;YAC9E,CAAC,EAAE,IAAI,CAAC,CAAC;YAET,MAAM,YAAY,CAAC,cAAc,CAAC,KAAK,EAAC,QAAQ,EAAC,EAAE;gBAClD,MAAM,cAAc,GAAG,QAAQ,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;gBACrD,MAAM,WAAW,GAAG,MAAM,GAAG,CAAC,WAAW,CAA8C;oBACtF,MAAM,EAAE,YAAY;oBACpB,MAAM,EAAE;wBACP,eAAe,EAAE,GAAG,CAAC,uBAAuB;wBAC5C,YAAY,EAAE;4BACb,KAAK,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE;4BAC5B,QAAQ,EAAE,IAAI,CAAC,2BAA2B,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS;4BAC3D,WAAW,EAAE,IAAI,CAAC,yBAAyB,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,SAAS;yBAC/E;wBACD,UAAU,EAAE;4BACX,IAAI,EAAE,cAAc,CAAC,QAAQ;4BAC7B,OAAO,EAAE,cAAc,CAAC,OAAO;yBAC/B;qBACD;iBACD,EAAE,KAAK,CAAC,CAAC;gBAEV,GAAG,CAAC,WAAW,GAAG,WAAW,CAAC;gBAC9B,GAAG,CAAC,qBAAqB,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;gBAElD,GAAG,CAAC,gBAAgB,CAA8B;oBACjD,MAAM,EAAE,2BAA2B;iBACnC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;YAEH,OAAO,GAAG,CAAC;QACZ,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,GAAG,CAAC,OAAO,EAAE,CAAC;YACd,MAAM,CAAC,CAAC;QACT,CAAC;gBAAS,CAAC;YACV,KAAK,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC;IACF,CAAC;IAQD,YAAsB,EACrB,MAAM,EACN,MAAM,EACN,2BAA2B,EAC3B,yBAAyB,EACzB,eAAe,GAAG,QAAQ,CAAC,KAAK,GACC;QACjC,KAAK,EAAE,CAAC;QAhHD,mBAAc,GAAG,CAAC,CAAC;QACV,qBAAgB,GAAG,IAAI,GAAG,EAAiC,CAAC;QAErE,uBAAkB,GAAG,KAAK,CAAC;QAC3B,WAAM,GAAe,EAAE,CAAC;QAyBhC,0CAA0C;QACzB,uCAAkC,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAA6B,CAAC,CAAC;QACtG,sCAAiC,GAAG,IAAI,CAAC,kCAAkC,CAAC,KAAK,CAAC;QAE1E,sCAAiC,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAA4B,CAAC,CAAC;QACpG,qCAAgC,GAAG,IAAI,CAAC,iCAAiC,CAAC,KAAK,CAAC;QAExE,iDAA4C,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAuC,CAAC,CAAC;QAC1H,gDAA2C,GAAG,IAAI,CAAC,4CAA4C,CAAC,KAAK,CAAC;QAE9F,6BAAwB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QACvE,4BAAuB,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC;QAEtD,yBAAoB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAmC,CAAC,CAAC;QAC9F,wBAAmB,GAAG,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC;QAE9C,yBAAoB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QACnE,wBAAmB,GAAG,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC;QAE9C,2BAAsB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QACrE,0BAAqB,GAAG,IAAI,CAAC,sBAAsB,CAAC,KAAK,CAAC;QAgElE,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;QACxC,IAAI,CAAC,4BAA4B,GAAG,2BAA2B,CAAC;QAChE,IAAI,CAAC,0BAA0B,GAAG,yBAAyB,CAAC;QAE5D,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,mBAAmB,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACnF,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;YAC/B,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC;YAC9C,0EAA0E;YAC1E,sEAAsE;YACtE,IAAI,KAAK,0CAAkC,IAAI,KAAK,4CAAoC,EAAE,CAAC;gBAC1F,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC1B,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;QAEJ,kEAAkE;QAClE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,mBAAmB,CAAC,CAAC,QAAQ,EAAE,EAAE;YACtD,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;OAOG;IACK,KAAK,CAAC,WAAW,CACxB,OAAqC,EACrC,QAA2B,iBAAiB,CAAC,IAAI;QAEjD,IAAI,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC;YAC5B,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,iBAAiB,EAAE,CAAC,CAAC;QAChD,CAAC;QAED,MAAM,EAAE,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QAEjC,mCAAmC;QACnC,MAAM,cAAc,GAAuB;YAC1C,OAAO,EAAE,GAAG,CAAC,eAAe;YAC5B,EAAE;YACF,GAAG,OAAO;SACV,CAAC;QAEF,MAAM,OAAO,GAAG,IAAI,eAAe,EAAoB,CAAC;QACxD,4BAA4B;QAC5B,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,OAAO,EAAE,CAAC,CAAC;QAC3C,sBAAsB;QACtB,MAAM,cAAc,GAAG,KAAK,CAAC,uBAAuB,CAAC,GAAG,EAAE;YACzD,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC;gBACxB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;gBACjC,IAAI,CAAC,gBAAgB,CAAC,EAAE,MAAM,EAAE,yBAAyB,EAAE,MAAM,EAAE,EAAE,SAAS,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;gBACxF,OAAO,CAAC,MAAM,EAAE,CAAC;YAClB,CAAC;YACD,cAAc,CAAC,OAAO,EAAE,CAAC;QAC1B,CAAC,CAAC,CAAC;QAEH,mBAAmB;QACnB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC1B,MAAM,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE;YAClC,cAAc,CAAC,OAAO,EAAE,CAAC;YACzB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAClC,CAAC,CAAC,CAAC;QAEH,OAAO,GAAiB,CAAC;IAC1B,CAAC;IAEO,IAAI,CAAC,GAAuB;QACnC,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC,gDAAgD;YAC5G,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,gBAAgB,EAAE,sBAAsB,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACtF,CAAC;QAED,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACxB,CAAC;IAED;;;;;;;;OAQG;IACK,KAAK,CAAC,CAAC,oBAAoB,CAAuF,MAAmB,EAAE,QAA4B,EAAE,aAAmD,EAAE,QAA2B,iBAAiB,CAAC,IAAI;QAClR,IAAI,UAAU,GAA2B,SAAS,CAAC;QAEnD,GAAG,CAAC;YACH,MAAM,MAAM,GAAgB;gBAC3B,GAAG,aAAa;gBAChB,MAAM,EAAE,UAAU;aAClB,CAAC;YAEF,MAAM,MAAM,GAAM,MAAM,IAAI,CAAC,WAAW,CAAO,EAAE,MAAM,EAAE,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC;YAC1E,MAAM,QAAQ,CAAC,MAAM,CAAC,CAAC;YACvB,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC;QAChC,CAAC,QAAQ,UAAU,KAAK,SAAS,IAAI,CAAC,KAAK,CAAC,uBAAuB,EAAE;IACtE,CAAC;IAEO,gBAAgB,CAAmC,YAAgC;QAC1F,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,YAAY,EAAE,OAAO,EAAE,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC;IAC9D,CAAC;IAED;;OAEG;IACK,aAAa,CAAC,OAA2B;QAChD,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC,gDAAgD;YAC5G,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,gBAAgB,EAAE,sBAAsB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QAC1F,CAAC;QAED,mCAAmC;QACnC,IAAI,IAAI,IAAI,OAAO,EAAE,CAAC;YACrB,IAAI,QAAQ,IAAI,OAAO,EAAE,CAAC;gBACzB,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;YAC5B,CAAC;iBAAM,IAAI,OAAO,IAAI,OAAO,EAAE,CAAC;gBAC/B,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YAC3B,CAAC;QACF,CAAC;QAED,kCAAkC;QAClC,IAAI,QAAQ,IAAI,OAAO,EAAE,CAAC;YACzB,IAAI,IAAI,IAAI,OAAO,EAAE,CAAC;gBACrB,IAAI,CAAC,mBAAmB,CAAC,OAAiD,CAAC,CAAC;YAC7E,CAAC;iBAAM,CAAC;gBACP,IAAI,CAAC,wBAAwB,CAAC,OAA2D,CAAC,CAAC;YAC5F,CAAC;QACF,CAAC;IACF,CAAC;IAED;;OAEG;IACK,YAAY,CAAC,QAA6B;QACjD,MAAM,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QACvD,IAAI,OAAO,EAAE,CAAC;YACb,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;YAC1C,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAC3C,CAAC;IACF,CAAC;IAED;;OAEG;IACK,WAAW,CAAC,QAA0B;QAC7C,MAAM,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QACvD,IAAI,OAAO,EAAE,CAAC;YACb,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;YAC1C,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,gBAAgB,CAAC,QAAQ,CAAC,KAAK,CAAC,OAAO,EAAE,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;QAC/G,CAAC;IACF,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,mBAAmB,CAAC,OAA+C;QAChF,IAAI,CAAC;YACJ,IAAI,QAAgC,CAAC;YACrC,IAAI,OAAO,CAAC,MAAM,KAAK,MAAM,EAAE,CAAC;gBAC/B,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;YACrC,CAAC;iBAAM,IAAI,OAAO,CAAC,MAAM,KAAK,YAAY,EAAE,CAAC;gBAC5C,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;YAC1C,CAAC;iBAAM,IAAI,OAAO,CAAC,MAAM,KAAK,wBAAwB,IAAI,IAAI,CAAC,4BAA4B,EAAE,CAAC;gBAC7F,QAAQ,GAAG,MAAM,IAAI,CAAC,4BAA4B,CAAC,OAAO,CAAC,MAA4C,CAAC,CAAC;YAC1G,CAAC;iBAAM,IAAI,OAAO,CAAC,MAAM,KAAK,oBAAoB,IAAI,IAAI,CAAC,0BAA0B,EAAE,CAAC;gBACvF,QAAQ,GAAG,MAAM,IAAI,CAAC,0BAA0B,CAAC,OAAO,CAAC,MAAqC,CAAC,CAAC;YACjG,CAAC;iBAAM,CAAC;gBACP,MAAM,QAAQ,CAAC,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YAC/C,CAAC;YACD,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC1C,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,IAAI,CAAC,CAAC,CAAC,YAAY,QAAQ,CAAC,EAAE,CAAC;gBAC9B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,0BAA0B,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC,CAAC,CAAC;gBAClE,CAAC,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACzB,CAAC;YAED,MAAM,aAAa,GAAqB;gBACvC,OAAO,EAAE,GAAG,CAAC,eAAe;gBAC5B,EAAE,EAAE,OAAO,CAAC,EAAE;gBACd,KAAK,EAAE;oBACN,IAAI,EAAE,CAAC,CAAC,IAAI;oBACZ,OAAO,EAAE,CAAC,CAAC,OAAO;oBAClB,IAAI,EAAE,CAAC,CAAC,IAAI;iBACZ;aACD,CAAC;YAEF,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QAC1B,CAAC;IACF,CAAC;IACD;;OAEG;IACK,wBAAwB,CAAC,OAAyD;QACzF,QAAQ,OAAO,CAAC,MAAM,EAAE,CAAC;YACxB,KAAK,uBAAuB;gBAC3B,OAAO,IAAI,CAAC,yBAAyB,CAAC,OAAO,CAAC,CAAC;YAChD,KAAK,yBAAyB;gBAC7B,IAAI,CAAC,kCAAkC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBACtD,OAAO,IAAI,CAAC,2BAA2B,CAAC,OAAO,CAAC,CAAC;YAClD,KAAK,wBAAwB;gBAC5B,IAAI,CAAC,iCAAiC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBACrD,OAAO;YACR,KAAK,sCAAsC;gBAC1C,IAAI,CAAC,wBAAwB,CAAC,IAAI,EAAE,CAAC;gBACrC,OAAO;YACR,KAAK,iCAAiC;gBACrC,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBACxC,OAAO;YACR,KAAK,kCAAkC;gBACtC,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,CAAC;gBACjC,OAAO;YACR,KAAK,oCAAoC;gBACxC,IAAI,CAAC,sBAAsB,CAAC,IAAI,EAAE,CAAC;gBACnC,OAAO;YACR,KAAK,oCAAoC;gBACxC,IAAI,CAAC,4CAA4C,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAChE,OAAO;YACR;gBACC,eAAe,CAAC,OAAO,CAAC,CAAC;QAC3B,CAAC;IACF,CAAC;IAEO,2BAA2B,CAAC,OAAkC;QACrE,MAAM,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAC3E,IAAI,cAAc,EAAE,CAAC;YACpB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACvD,cAAc,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;QACjC,CAAC;IACF,CAAC;IAEO,yBAAyB,CAAC,OAAuC;QACxE,IAAI,QAAQ,GAAG,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACnH,IAAI,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;YAC3B,QAAQ,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,KAAK,QAAQ,EAAE,CAAC;QACpD,CAAC;QAED,QAAQ,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC;YAC/B,KAAK,OAAO;gBACX,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;gBAC5B,MAAM;YACP,KAAK,MAAM,CAAC;YACZ,KAAK,QAAQ;gBACZ,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC3B,MAAM;YACP,KAAK,SAAS;gBACb,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC3B,MAAM;YACP,KAAK,OAAO,CAAC;YACb,KAAK,UAAU,CAAC;YAChB,KAAK,OAAO,CAAC;YACb,KAAK,WAAW;gBACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;gBAC5B,MAAM;YACP;gBACC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC3B,MAAM;QACR,CAAC;IACF,CAAC;IAED;;OAEG;IACK,gBAAgB,CAAC,OAA2B,EAAE,MAAkB;QACvE,MAAM,QAAQ,GAAwB;YACrC,OAAO,EAAE,GAAG,CAAC,eAAe;YAC5B,EAAE,EAAE,OAAO,CAAC,EAAE;YACd,MAAM;SACN,CAAC;QACF,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACrB,CAAC;IAED;;OAEG;IACK,UAAU,CAAC,QAAyB;QAC3C,OAAO,EAAE,CAAC;IACX,CAAC;IAED;;OAEG;IACK,eAAe,CAAC,QAA8B;QACrD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;QAC/B,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC;IAC/B,CAAC;IAEO,iBAAiB;QACxB,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC;QACnE,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC;IAC/B,CAAC;IAEe,OAAO;QACtB,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACzB,KAAK,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,qBAAqB,CAAC,QAAkB;QACrD,IAAI,CAAC;YACJ,wDAAwD;YACxD,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;gBAChC,OAAO;YACR,CAAC;YAED,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,KAAK,EAAE,gBAAgB,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QAC5D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,uCAAuC,KAAK,EAAE,CAAC,CAAC;QACnE,CAAC;IACF,CAAC;IAED;;OAEG;IACH,UAAU,CAAC,MAAuC,EAAE,KAAyB;QAC5E,OAAO,IAAI,CAAC,WAAW,CAA8C,EAAE,MAAM,EAAE,YAAY,EAAE,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC;IAC/G,CAAC;IAED;;OAEG;IACH,aAAa,CAAC,MAA2C,EAAE,KAAyB;QACnF,OAAO,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,qBAAqB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;IAC7E,CAAC;IAED;;OAEG;IACH,qBAAqB,CAAC,MAA2C,EAAE,KAAyB;QAC3F,OAAO,IAAI,CAAC,oBAAoB,CAAkE,gBAAgB,EAAE,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;IAChK,CAAC;IAED;;OAEG;IACH,YAAY,CAAC,MAAyC,EAAE,KAAyB;QAChF,OAAO,IAAI,CAAC,WAAW,CAAkD,EAAE,MAAM,EAAE,gBAAgB,EAAE,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC;IACvH,CAAC;IAED;;OAEG;IACH,qBAAqB,CAAC,MAAmD,EAAE,KAAyB;QACnG,OAAO,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,oBAAoB,CAA0F,0BAA0B,EAAE,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,iBAAiB,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;IACrO,CAAC;IAED;;OAEG;IACH,SAAS,CAAC,MAAsC,EAAE,KAAyB;QAC1E,OAAO,IAAI,CAAC,WAAW,CAAwC,EAAE,MAAM,EAAE,qBAAqB,EAAE,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC;IAClH,CAAC;IAED;;OAEG;IACH,WAAW,CAAC,MAAwC,EAAE,KAAyB;QAC9E,OAAO,IAAI,CAAC,WAAW,CAA0C,EAAE,MAAM,EAAE,uBAAuB,EAAE,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC;IACtH,CAAC;IAED;;OAEG;IACH,WAAW,CAAC,MAAyC,EAAE,KAAyB;QAC/E,OAAO,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,oBAAoB,CAA4D,cAAc,EAAE,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;IACjL,CAAC;IAED;;OAEG;IACH,SAAS,CAAC,MAAsC,EAAE,KAAyB;QAC1E,OAAO,IAAI,CAAC,WAAW,CAA4C,EAAE,MAAM,EAAE,aAAa,EAAE,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC;IAC9G,CAAC;IAED;;OAEG;IACH,SAAS,CAAC,MAAuC,EAAE,KAAyB;QAC3E,OAAO,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,oBAAoB,CAAsD,YAAY,EAAE,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;IACvK,CAAC;IAED;;OAEG;IACH,QAAQ,CAAC,MAA6D,EAAE,KAAyB;QAChG,OAAO,IAAI,CAAC,WAAW,CAA0C,EAAE,MAAM,EAAE,YAAY,EAAE,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC;IAC3G,CAAC;IAED;;OAEG;IACH,QAAQ,CAAC,MAAqC,EAAE,KAAyB;QACxE,OAAO,IAAI,CAAC,WAAW,CAAuC,EAAE,MAAM,EAAE,kBAAkB,EAAE,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC;IAC9G,CAAC;IAED;;OAEG;IACH,QAAQ,CAAC,MAAqC,EAAE,KAAyB;QACxE,OAAO,IAAI,CAAC,WAAW,CAA0C,EAAE,MAAM,EAAE,qBAAqB,EAAE,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC;IACpH,CAAC;CACD;AAGD;;GAEG;AACH,SAAS,gBAAgB,CAAC,QAAkB;IAC3C,QAAQ,QAAQ,EAAE,CAAC;QAClB,KAAK,QAAQ,CAAC,KAAK;YAClB,OAAO,OAAO,CAAC,CAAC,oCAAoC;QACrD,KAAK,QAAQ,CAAC,KAAK;YAClB,OAAO,OAAO,CAAC;QAChB,KAAK,QAAQ,CAAC,IAAI;YACjB,OAAO,MAAM,CAAC;QACf,KAAK,QAAQ,CAAC,OAAO;YACpB,OAAO,SAAS,CAAC;QAClB,KAAK,QAAQ,CAAC,KAAK;YAClB,OAAO,OAAO,CAAC;QAChB,KAAK,QAAQ,CAAC,GAAG;YAChB,OAAO,WAAW,CAAC,CAAC,sCAAsC;QAC3D;YACC,OAAO,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,yCAAyC;IACzE,CAAC;AACF,CAAC","file":"mcpServerRequestHandler.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from '../../../../base/common/arrays.js';\nimport { assertNever, softAssertNever } from '../../../../base/common/assert.js';\nimport { DeferredPromise, IntervalTimer } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { autorun } from '../../../../base/common/observable.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { canLog, ILogger, log, LogLevel } from '../../../../platform/log/common/log.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { IMcpMessageTransport } from './mcpRegistryTypes.js';\nimport { IMcpClientMethods, McpConnectionState, McpError, MpcResponseError } from './mcpTypes.js';\nimport { MCP } from './modelContextProtocol.js';\n\n/**\n * Maps request IDs to handlers.\n */\ninterface PendingRequest {\n\tpromise: DeferredPromise<MCP.Result>;\n}\n\nexport interface McpRoot {\n\turi: string;\n\tname?: string;\n}\n\nexport interface IMcpServerRequestHandlerOptions extends IMcpClientMethods {\n\t/** MCP message transport */\n\tlaunch: IMcpMessageTransport;\n\t/** Logger instance. */\n\tlogger: ILogger;\n\t/** Log level MCP messages is logged at */\n\trequestLogLevel?: LogLevel;\n}\n\n/**\n * Request handler for communicating with an MCP server.\n *\n * Handles sending requests and receiving responses, with automatic\n * handling of ping requests and typed client request methods.\n */\nexport class McpServerRequestHandler extends Disposable {\n\tprivate _nextRequestId = 1;\n\tprivate readonly _pendingRequests = new Map<MCP.RequestId, PendingRequest>();\n\n\tprivate _hasAnnouncedRoots = false;\n\tprivate _roots: MCP.Root[] = [];\n\n\tpublic set roots(roots: MCP.Root[]) {\n\t\tif (!equals(this._roots, roots)) {\n\t\t\tthis._roots = roots;\n\t\t\tif (this._hasAnnouncedRoots) {\n\t\t\t\tthis.sendNotification({ method: 'notifications/roots/list_changed' });\n\t\t\t\tthis._hasAnnouncedRoots = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _serverInit!: MCP.InitializeResult;\n\tpublic get capabilities(): MCP.ServerCapabilities {\n\t\treturn this._serverInit.capabilities;\n\t}\n\n\tpublic get serverInfo(): MCP.Implementation {\n\t\treturn this._serverInit.serverInfo;\n\t}\n\n\tpublic get serverInstructions(): string | undefined {\n\t\treturn this._serverInit.instructions;\n\t}\n\n\t// Event emitters for server notifications\n\tprivate readonly _onDidReceiveCancelledNotification = this._register(new Emitter<MCP.CancelledNotification>());\n\treadonly onDidReceiveCancelledNotification = this._onDidReceiveCancelledNotification.event;\n\n\tprivate readonly _onDidReceiveProgressNotification = this._register(new Emitter<MCP.ProgressNotification>());\n\treadonly onDidReceiveProgressNotification = this._onDidReceiveProgressNotification.event;\n\n\tprivate readonly _onDidReceiveElicitationCompleteNotification = this._register(new Emitter<MCP.ElicitationCompleteNotification>());\n\treadonly onDidReceiveElicitationCompleteNotification = this._onDidReceiveElicitationCompleteNotification.event;\n\n\tprivate readonly _onDidChangeResourceList = this._register(new Emitter<void>());\n\treadonly onDidChangeResourceList = this._onDidChangeResourceList.event;\n\n\tprivate readonly _onDidUpdateResource = this._register(new Emitter<MCP.ResourceUpdatedNotification>());\n\treadonly onDidUpdateResource = this._onDidUpdateResource.event;\n\n\tprivate readonly _onDidChangeToolList = this._register(new Emitter<void>());\n\treadonly onDidChangeToolList = this._onDidChangeToolList.event;\n\n\tprivate readonly _onDidChangePromptList = this._register(new Emitter<void>());\n\treadonly onDidChangePromptList = this._onDidChangePromptList.event;\n\n\t/**\n\t * Connects to the MCP server and does the initialization handshake.\n\t * @throws MpcResponseError if the server fails to initialize.\n\t */\n\tpublic static async create(instaService: IInstantiationService, opts: IMcpServerRequestHandlerOptions, token?: CancellationToken) {\n\t\tconst mcp = new McpServerRequestHandler(opts);\n\t\tconst store = new DisposableStore();\n\t\ttry {\n\t\t\tconst timer = store.add(new IntervalTimer());\n\t\t\ttimer.cancelAndSet(() => {\n\t\t\t\topts.logger.info('Waiting for server to respond to `initialize` request...');\n\t\t\t}, 5000);\n\n\t\t\tawait instaService.invokeFunction(async accessor => {\n\t\t\t\tconst productService = accessor.get(IProductService);\n\t\t\t\tconst initialized = await mcp.sendRequest<MCP.InitializeRequest, MCP.InitializeResult>({\n\t\t\t\t\tmethod: 'initialize',\n\t\t\t\t\tparams: {\n\t\t\t\t\t\tprotocolVersion: MCP.LATEST_PROTOCOL_VERSION,\n\t\t\t\t\t\tcapabilities: {\n\t\t\t\t\t\t\troots: { listChanged: true },\n\t\t\t\t\t\t\tsampling: opts.createMessageRequestHandler ? {} : undefined,\n\t\t\t\t\t\t\telicitation: opts.elicitationRequestHandler ? { form: {}, url: {} } : undefined,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclientInfo: {\n\t\t\t\t\t\t\tname: productService.nameLong,\n\t\t\t\t\t\t\tversion: productService.version,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, token);\n\n\t\t\t\tmcp._serverInit = initialized;\n\t\t\t\tmcp._sendLogLevelToServer(opts.logger.getLevel());\n\n\t\t\t\tmcp.sendNotification<MCP.InitializedNotification>({\n\t\t\t\t\tmethod: 'notifications/initialized'\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn mcp;\n\t\t} catch (e) {\n\t\t\tmcp.dispose();\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tstore.dispose();\n\t\t}\n\t}\n\n\tpublic readonly logger: ILogger;\n\tprivate readonly _launch: IMcpMessageTransport;\n\tprivate readonly _requestLogLevel: LogLevel;\n\tprivate readonly _createMessageRequestHandler: IMcpServerRequestHandlerOptions['createMessageRequestHandler'];\n\tprivate readonly _elicitationRequestHandler: IMcpServerRequestHandlerOptions['elicitationRequestHandler'];\n\n\tprotected constructor({\n\t\tlaunch,\n\t\tlogger,\n\t\tcreateMessageRequestHandler,\n\t\telicitationRequestHandler,\n\t\trequestLogLevel = LogLevel.Debug,\n\t}: IMcpServerRequestHandlerOptions) {\n\t\tsuper();\n\t\tthis._launch = launch;\n\t\tthis.logger = logger;\n\t\tthis._requestLogLevel = requestLogLevel;\n\t\tthis._createMessageRequestHandler = createMessageRequestHandler;\n\t\tthis._elicitationRequestHandler = elicitationRequestHandler;\n\n\t\tthis._register(launch.onDidReceiveMessage(message => this.handleMessage(message)));\n\t\tthis._register(autorun(reader => {\n\t\t\tconst state = launch.state.read(reader).state;\n\t\t\t// the handler will get disposed when the launch stops, but if we're still\n\t\t\t// create()'ing we need to make sure to cancel the initialize request.\n\t\t\tif (state === McpConnectionState.Kind.Error || state === McpConnectionState.Kind.Stopped) {\n\t\t\t\tthis.cancelAllRequests();\n\t\t\t}\n\t\t}));\n\n\t\t// Listen for log level changes and forward them to the MCP server\n\t\tthis._register(logger.onDidChangeLogLevel((logLevel) => {\n\t\t\tthis._sendLogLevelToServer(logLevel);\n\t\t}));\n\t}\n\n\t/**\n\t * Send a client request to the server and return the response.\n\t *\n\t * @param request The request to send\n\t * @param token Cancellation token\n\t * @param timeoutMs Optional timeout in milliseconds\n\t * @returns A promise that resolves with the response\n\t */\n\tprivate async sendRequest<T extends MCP.ClientRequest, R extends MCP.ServerResult>(\n\t\trequest: Pick<T, 'params' | 'method'>,\n\t\ttoken: CancellationToken = CancellationToken.None\n\t): Promise<R> {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn Promise.reject(new CancellationError());\n\t\t}\n\n\t\tconst id = this._nextRequestId++;\n\n\t\t// Create the full JSON-RPC request\n\t\tconst jsonRpcRequest: MCP.JSONRPCRequest = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid,\n\t\t\t...request\n\t\t};\n\n\t\tconst promise = new DeferredPromise<MCP.ServerResult>();\n\t\t// Store the pending request\n\t\tthis._pendingRequests.set(id, { promise });\n\t\t// Set up cancellation\n\t\tconst cancelListener = token.onCancellationRequested(() => {\n\t\t\tif (!promise.isSettled) {\n\t\t\t\tthis._pendingRequests.delete(id);\n\t\t\t\tthis.sendNotification({ method: 'notifications/cancelled', params: { requestId: id } });\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t\tcancelListener.dispose();\n\t\t});\n\n\t\t// Send the request\n\t\tthis.send(jsonRpcRequest);\n\t\tconst ret = promise.p.finally(() => {\n\t\t\tcancelListener.dispose();\n\t\t\tthis._pendingRequests.delete(id);\n\t\t});\n\n\t\treturn ret as Promise<R>;\n\t}\n\n\tprivate send(mcp: MCP.JSONRPCMessage) {\n\t\tif (canLog(this.logger.getLevel(), this._requestLogLevel)) { // avoid building the string if we don't need to\n\t\t\tlog(this.logger, this._requestLogLevel, `[editor -> server] ${JSON.stringify(mcp)}`);\n\t\t}\n\n\t\tthis._launch.send(mcp);\n\t}\n\n\t/**\n\t * Handles paginated requests by making multiple requests until all items are retrieved.\n\t *\n\t * @param method The method name to call\n\t * @param getItems Function to extract the array of items from a result\n\t * @param initialParams Initial parameters\n\t * @param token Cancellation token\n\t * @returns Promise with all items combined\n\t */\n\tprivate async *sendRequestPaginated<T extends MCP.PaginatedRequest & MCP.ClientRequest, R extends MCP.PaginatedResult, I>(method: T['method'], getItems: (result: R) => I[], initialParams?: Omit<T['params'], 'jsonrpc' | 'id'>, token: CancellationToken = CancellationToken.None): AsyncIterable<I[]> {\n\t\tlet nextCursor: MCP.Cursor | undefined = undefined;\n\n\t\tdo {\n\t\t\tconst params: T['params'] = {\n\t\t\t\t...initialParams,\n\t\t\t\tcursor: nextCursor\n\t\t\t};\n\n\t\t\tconst result: R = await this.sendRequest<T, R>({ method, params }, token);\n\t\t\tyield getItems(result);\n\t\t\tnextCursor = result.nextCursor;\n\t\t} while (nextCursor !== undefined && !token.isCancellationRequested);\n\t}\n\n\tprivate sendNotification<N extends MCP.ClientNotification>(notification: Omit<N, 'jsonrpc'>): void {\n\t\tthis.send({ ...notification, jsonrpc: MCP.JSONRPC_VERSION });\n\t}\n\n\t/**\n\t * Handle incoming messages from the server\n\t */\n\tprivate handleMessage(message: MCP.JSONRPCMessage): void {\n\t\tif (canLog(this.logger.getLevel(), this._requestLogLevel)) { // avoid building the string if we don't need to\n\t\t\tlog(this.logger, this._requestLogLevel, `[server -> editor] ${JSON.stringify(message)}`);\n\t\t}\n\n\t\t// Handle responses to our requests\n\t\tif ('id' in message) {\n\t\t\tif ('result' in message) {\n\t\t\t\tthis.handleResult(message);\n\t\t\t} else if ('error' in message) {\n\t\t\t\tthis.handleError(message);\n\t\t\t}\n\t\t}\n\n\t\t// Handle requests from the server\n\t\tif ('method' in message) {\n\t\t\tif ('id' in message) {\n\t\t\t\tthis.handleServerRequest(message as MCP.JSONRPCRequest & MCP.ServerRequest);\n\t\t\t} else {\n\t\t\t\tthis.handleServerNotification(message as MCP.JSONRPCNotification & MCP.ServerNotification);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handle successful responses\n\t */\n\tprivate handleResult(response: MCP.JSONRPCResponse): void {\n\t\tconst request = this._pendingRequests.get(response.id);\n\t\tif (request) {\n\t\t\tthis._pendingRequests.delete(response.id);\n\t\t\trequest.promise.complete(response.result);\n\t\t}\n\t}\n\n\t/**\n\t * Handle error responses\n\t */\n\tprivate handleError(response: MCP.JSONRPCError): void {\n\t\tconst request = this._pendingRequests.get(response.id);\n\t\tif (request) {\n\t\t\tthis._pendingRequests.delete(response.id);\n\t\t\trequest.promise.error(new MpcResponseError(response.error.message, response.error.code, response.error.data));\n\t\t}\n\t}\n\n\t/**\n\t * Handle incoming server requests\n\t */\n\tprivate async handleServerRequest(request: MCP.JSONRPCRequest & MCP.ServerRequest): Promise<void> {\n\t\ttry {\n\t\t\tlet response: MCP.Result | undefined;\n\t\t\tif (request.method === 'ping') {\n\t\t\t\tresponse = this.handlePing(request);\n\t\t\t} else if (request.method === 'roots/list') {\n\t\t\t\tresponse = this.handleRootsList(request);\n\t\t\t} else if (request.method === 'sampling/createMessage' && this._createMessageRequestHandler) {\n\t\t\t\tresponse = await this._createMessageRequestHandler(request.params as MCP.CreateMessageRequest['params']);\n\t\t\t} else if (request.method === 'elicitation/create' && this._elicitationRequestHandler) {\n\t\t\t\tresponse = await this._elicitationRequestHandler(request.params as MCP.ElicitRequest['params']);\n\t\t\t} else {\n\t\t\t\tthrow McpError.methodNotFound(request.method);\n\t\t\t}\n\t\t\tthis.respondToRequest(request, response);\n\t\t} catch (e) {\n\t\t\tif (!(e instanceof McpError)) {\n\t\t\t\tthis.logger.error(`Error handling request ${request.method}:`, e);\n\t\t\t\te = McpError.unknown(e);\n\t\t\t}\n\n\t\t\tconst errorResponse: MCP.JSONRPCError = {\n\t\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\t\tid: request.id,\n\t\t\t\terror: {\n\t\t\t\t\tcode: e.code,\n\t\t\t\t\tmessage: e.message,\n\t\t\t\t\tdata: e.data,\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.send(errorResponse);\n\t\t}\n\t}\n\t/**\n\t * Handle incoming server notifications\n\t */\n\tprivate handleServerNotification(request: MCP.JSONRPCNotification & MCP.ServerNotification): void {\n\t\tswitch (request.method) {\n\t\t\tcase 'notifications/message':\n\t\t\t\treturn this.handleLoggingNotification(request);\n\t\t\tcase 'notifications/cancelled':\n\t\t\t\tthis._onDidReceiveCancelledNotification.fire(request);\n\t\t\t\treturn this.handleCancelledNotification(request);\n\t\t\tcase 'notifications/progress':\n\t\t\t\tthis._onDidReceiveProgressNotification.fire(request);\n\t\t\t\treturn;\n\t\t\tcase 'notifications/resources/list_changed':\n\t\t\t\tthis._onDidChangeResourceList.fire();\n\t\t\t\treturn;\n\t\t\tcase 'notifications/resources/updated':\n\t\t\t\tthis._onDidUpdateResource.fire(request);\n\t\t\t\treturn;\n\t\t\tcase 'notifications/tools/list_changed':\n\t\t\t\tthis._onDidChangeToolList.fire();\n\t\t\t\treturn;\n\t\t\tcase 'notifications/prompts/list_changed':\n\t\t\t\tthis._onDidChangePromptList.fire();\n\t\t\t\treturn;\n\t\t\tcase 'notifications/elicitation/complete':\n\t\t\t\tthis._onDidReceiveElicitationCompleteNotification.fire(request);\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tsoftAssertNever(request);\n\t\t}\n\t}\n\n\tprivate handleCancelledNotification(request: MCP.CancelledNotification): void {\n\t\tconst pendingRequest = this._pendingRequests.get(request.params.requestId);\n\t\tif (pendingRequest) {\n\t\t\tthis._pendingRequests.delete(request.params.requestId);\n\t\t\tpendingRequest.promise.cancel();\n\t\t}\n\t}\n\n\tprivate handleLoggingNotification(request: MCP.LoggingMessageNotification): void {\n\t\tlet contents = typeof request.params.data === 'string' ? request.params.data : JSON.stringify(request.params.data);\n\t\tif (request.params.logger) {\n\t\t\tcontents = `${request.params.logger}: ${contents}`;\n\t\t}\n\n\t\tswitch (request.params?.level) {\n\t\t\tcase 'debug':\n\t\t\t\tthis.logger.debug(contents);\n\t\t\t\tbreak;\n\t\t\tcase 'info':\n\t\t\tcase 'notice':\n\t\t\t\tthis.logger.info(contents);\n\t\t\t\tbreak;\n\t\t\tcase 'warning':\n\t\t\t\tthis.logger.warn(contents);\n\t\t\t\tbreak;\n\t\t\tcase 'error':\n\t\t\tcase 'critical':\n\t\t\tcase 'alert':\n\t\t\tcase 'emergency':\n\t\t\t\tthis.logger.error(contents);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.logger.info(contents);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Send a generic response to a request\n\t */\n\tprivate respondToRequest(request: MCP.JSONRPCRequest, result: MCP.Result): void {\n\t\tconst response: MCP.JSONRPCResponse = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: request.id,\n\t\t\tresult\n\t\t};\n\t\tthis.send(response);\n\t}\n\n\t/**\n\t * Send a response to a ping request\n\t */\n\tprivate handlePing(_request: MCP.PingRequest): {} {\n\t\treturn {};\n\t}\n\n\t/**\n\t * Send a response to a roots/list request\n\t */\n\tprivate handleRootsList(_request: MCP.ListRootsRequest): MCP.ListRootsResult {\n\t\tthis._hasAnnouncedRoots = true;\n\t\treturn { roots: this._roots };\n\t}\n\n\tprivate cancelAllRequests() {\n\t\tthis._pendingRequests.forEach(pending => pending.promise.cancel());\n\t\tthis._pendingRequests.clear();\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis.cancelAllRequests();\n\t\tsuper.dispose();\n\t}\n\n\t/**\n\t * Forwards log level changes to the MCP server if it supports logging\n\t */\n\tprivate async _sendLogLevelToServer(logLevel: LogLevel): Promise<void> {\n\t\ttry {\n\t\t\t// Only send if the server supports logging capabilities\n\t\t\tif (!this.capabilities.logging) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait this.setLevel({ level: mapLogLevelToMcp(logLevel) });\n\t\t} catch (error) {\n\t\t\tthis.logger.error(`Failed to set MCP server log level: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Send an initialize request\n\t */\n\tinitialize(params: MCP.InitializeRequest['params'], token?: CancellationToken): Promise<MCP.InitializeResult> {\n\t\treturn this.sendRequest<MCP.InitializeRequest, MCP.InitializeResult>({ method: 'initialize', params }, token);\n\t}\n\n\t/**\n\t * List available resources\n\t */\n\tlistResources(params?: MCP.ListResourcesRequest['params'], token?: CancellationToken): Promise<MCP.Resource[]> {\n\t\treturn Iterable.asyncToArrayFlat(this.listResourcesIterable(params, token));\n\t}\n\n\t/**\n\t * List available resources (iterable)\n\t */\n\tlistResourcesIterable(params?: MCP.ListResourcesRequest['params'], token?: CancellationToken): AsyncIterable<MCP.Resource[]> {\n\t\treturn this.sendRequestPaginated<MCP.ListResourcesRequest, MCP.ListResourcesResult, MCP.Resource>('resources/list', result => result.resources, params, token);\n\t}\n\n\t/**\n\t * Read a specific resource\n\t */\n\treadResource(params: MCP.ReadResourceRequest['params'], token?: CancellationToken): Promise<MCP.ReadResourceResult> {\n\t\treturn this.sendRequest<MCP.ReadResourceRequest, MCP.ReadResourceResult>({ method: 'resources/read', params }, token);\n\t}\n\n\t/**\n\t * List available resource templates\n\t */\n\tlistResourceTemplates(params?: MCP.ListResourceTemplatesRequest['params'], token?: CancellationToken): Promise<MCP.ResourceTemplate[]> {\n\t\treturn Iterable.asyncToArrayFlat(this.sendRequestPaginated<MCP.ListResourceTemplatesRequest, MCP.ListResourceTemplatesResult, MCP.ResourceTemplate>('resources/templates/list', result => result.resourceTemplates, params, token));\n\t}\n\n\t/**\n\t * Subscribe to resource updates\n\t */\n\tsubscribe(params: MCP.SubscribeRequest['params'], token?: CancellationToken): Promise<MCP.EmptyResult> {\n\t\treturn this.sendRequest<MCP.SubscribeRequest, MCP.EmptyResult>({ method: 'resources/subscribe', params }, token);\n\t}\n\n\t/**\n\t * Unsubscribe from resource updates\n\t */\n\tunsubscribe(params: MCP.UnsubscribeRequest['params'], token?: CancellationToken): Promise<MCP.EmptyResult> {\n\t\treturn this.sendRequest<MCP.UnsubscribeRequest, MCP.EmptyResult>({ method: 'resources/unsubscribe', params }, token);\n\t}\n\n\t/**\n\t * List available prompts\n\t */\n\tlistPrompts(params?: MCP.ListPromptsRequest['params'], token?: CancellationToken): Promise<MCP.Prompt[]> {\n\t\treturn Iterable.asyncToArrayFlat(this.sendRequestPaginated<MCP.ListPromptsRequest, MCP.ListPromptsResult, MCP.Prompt>('prompts/list', result => result.prompts, params, token));\n\t}\n\n\t/**\n\t * Get a specific prompt\n\t */\n\tgetPrompt(params: MCP.GetPromptRequest['params'], token?: CancellationToken): Promise<MCP.GetPromptResult> {\n\t\treturn this.sendRequest<MCP.GetPromptRequest, MCP.GetPromptResult>({ method: 'prompts/get', params }, token);\n\t}\n\n\t/**\n\t * List available tools\n\t */\n\tlistTools(params?: MCP.ListToolsRequest['params'], token?: CancellationToken): Promise<MCP.Tool[]> {\n\t\treturn Iterable.asyncToArrayFlat(this.sendRequestPaginated<MCP.ListToolsRequest, MCP.ListToolsResult, MCP.Tool>('tools/list', result => result.tools, params, token));\n\t}\n\n\t/**\n\t * Call a specific tool\n\t */\n\tcallTool(params: MCP.CallToolRequest['params'] & MCP.Request['params'], token?: CancellationToken): Promise<MCP.CallToolResult> {\n\t\treturn this.sendRequest<MCP.CallToolRequest, MCP.CallToolResult>({ method: 'tools/call', params }, token);\n\t}\n\n\t/**\n\t * Set the logging level\n\t */\n\tsetLevel(params: MCP.SetLevelRequest['params'], token?: CancellationToken): Promise<MCP.EmptyResult> {\n\t\treturn this.sendRequest<MCP.SetLevelRequest, MCP.EmptyResult>({ method: 'logging/setLevel', params }, token);\n\t}\n\n\t/**\n\t * Find completions for an argument\n\t */\n\tcomplete(params: MCP.CompleteRequest['params'], token?: CancellationToken): Promise<MCP.CompleteResult> {\n\t\treturn this.sendRequest<MCP.CompleteRequest, MCP.CompleteResult>({ method: 'completion/complete', params }, token);\n\t}\n}\n\n\n/**\n * Maps VSCode LogLevel to MCP LoggingLevel\n */\nfunction mapLogLevelToMcp(logLevel: LogLevel): MCP.LoggingLevel {\n\tswitch (logLevel) {\n\t\tcase LogLevel.Trace:\n\t\t\treturn 'debug'; // MCP doesn't have trace, use debug\n\t\tcase LogLevel.Debug:\n\t\t\treturn 'debug';\n\t\tcase LogLevel.Info:\n\t\t\treturn 'info';\n\t\tcase LogLevel.Warning:\n\t\t\treturn 'warning';\n\t\tcase LogLevel.Error:\n\t\t\treturn 'error';\n\t\tcase LogLevel.Off:\n\t\t\treturn 'emergency'; // MCP doesn't have off, use emergency\n\t\tdefault:\n\t\t\treturn assertNever(logLevel); // Off and other levels are not supported\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from '../../../../base/common/arrays.js';\nimport { assertNever, softAssertNever } from '../../../../base/common/assert.js';\nimport { DeferredPromise, IntervalTimer } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { autorun } from '../../../../base/common/observable.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { canLog, ILogger, log, LogLevel } from '../../../../platform/log/common/log.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { IMcpMessageTransport } from './mcpRegistryTypes.js';\nimport { IMcpClientMethods, McpConnectionState, McpError, MpcResponseError } from './mcpTypes.js';\nimport { MCP } from './modelContextProtocol.js';\n\n/**\n * Maps request IDs to handlers.\n */\ninterface PendingRequest {\n\tpromise: DeferredPromise<MCP.Result>;\n}\n\nexport interface McpRoot {\n\turi: string;\n\tname?: string;\n}\n\nexport interface IMcpServerRequestHandlerOptions extends IMcpClientMethods {\n\t/** MCP message transport */\n\tlaunch: IMcpMessageTransport;\n\t/** Logger instance. */\n\tlogger: ILogger;\n\t/** Log level MCP messages is logged at */\n\trequestLogLevel?: LogLevel;\n}\n\n/**\n * Request handler for communicating with an MCP server.\n *\n * Handles sending requests and receiving responses, with automatic\n * handling of ping requests and typed client request methods.\n */\nexport class McpServerRequestHandler extends Disposable {\n\tprivate _nextRequestId = 1;\n\tprivate readonly _pendingRequests = new Map<MCP.RequestId, PendingRequest>();\n\n\tprivate _hasAnnouncedRoots = false;\n\tprivate _roots: MCP.Root[] = [];\n\n\tpublic set roots(roots: MCP.Root[]) {\n\t\tif (!equals(this._roots, roots)) {\n\t\t\tthis._roots = roots;\n\t\t\tif (this._hasAnnouncedRoots) {\n\t\t\t\tthis.sendNotification({ method: 'notifications/roots/list_changed' });\n\t\t\t\tthis._hasAnnouncedRoots = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _serverInit!: MCP.InitializeResult;\n\tpublic get capabilities(): MCP.ServerCapabilities {\n\t\treturn this._serverInit.capabilities;\n\t}\n\n\tpublic get serverInfo(): MCP.Implementation {\n\t\treturn this._serverInit.serverInfo;\n\t}\n\n\tpublic get serverInstructions(): string | undefined {\n\t\treturn this._serverInit.instructions;\n\t}\n\n\t// Event emitters for server notifications\n\tprivate readonly _onDidReceiveCancelledNotification = this._register(new Emitter<MCP.CancelledNotification>());\n\treadonly onDidReceiveCancelledNotification = this._onDidReceiveCancelledNotification.event;\n\n\tprivate readonly _onDidReceiveProgressNotification = this._register(new Emitter<MCP.ProgressNotification>());\n\treadonly onDidReceiveProgressNotification = this._onDidReceiveProgressNotification.event;\n\n\tprivate readonly _onDidReceiveElicitationCompleteNotification = this._register(new Emitter<MCP.ElicitationCompleteNotification>());\n\treadonly onDidReceiveElicitationCompleteNotification = this._onDidReceiveElicitationCompleteNotification.event;\n\n\tprivate readonly _onDidChangeResourceList = this._register(new Emitter<void>());\n\treadonly onDidChangeResourceList = this._onDidChangeResourceList.event;\n\n\tprivate readonly _onDidUpdateResource = this._register(new Emitter<MCP.ResourceUpdatedNotification>());\n\treadonly onDidUpdateResource = this._onDidUpdateResource.event;\n\n\tprivate readonly _onDidChangeToolList = this._register(new Emitter<void>());\n\treadonly onDidChangeToolList = this._onDidChangeToolList.event;\n\n\tprivate readonly _onDidChangePromptList = this._register(new Emitter<void>());\n\treadonly onDidChangePromptList = this._onDidChangePromptList.event;\n\n\t/**\n\t * Connects to the MCP server and does the initialization handshake.\n\t * @throws MpcResponseError if the server fails to initialize.\n\t */\n\tpublic static async create(instaService: IInstantiationService, opts: IMcpServerRequestHandlerOptions, token?: CancellationToken) {\n\t\tconst mcp = new McpServerRequestHandler(opts);\n\t\tconst store = new DisposableStore();\n\t\ttry {\n\t\t\tconst timer = store.add(new IntervalTimer());\n\t\t\ttimer.cancelAndSet(() => {\n\t\t\t\topts.logger.info('Waiting for server to respond to `initialize` request...');\n\t\t\t}, 5000);\n\n\t\t\tawait instaService.invokeFunction(async accessor => {\n\t\t\t\tconst productService = accessor.get(IProductService);\n\t\t\t\tconst initialized = await mcp.sendRequest<MCP.InitializeRequest, MCP.InitializeResult>({\n\t\t\t\t\tmethod: 'initialize',\n\t\t\t\t\tparams: {\n\t\t\t\t\t\tprotocolVersion: MCP.LATEST_PROTOCOL_VERSION,\n\t\t\t\t\t\tcapabilities: {\n\t\t\t\t\t\t\troots: { listChanged: true },\n\t\t\t\t\t\t\tsampling: opts.createMessageRequestHandler ? {} : undefined,\n\t\t\t\t\t\t\telicitation: opts.elicitationRequestHandler ? { form: {}, url: {} } : undefined,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclientInfo: {\n\t\t\t\t\t\t\tname: productService.nameLong,\n\t\t\t\t\t\t\tversion: productService.version,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, token);\n\n\t\t\t\tmcp._serverInit = initialized;\n\t\t\t\tmcp._sendLogLevelToServer(opts.logger.getLevel());\n\n\t\t\t\tmcp.sendNotification<MCP.InitializedNotification>({\n\t\t\t\t\tmethod: 'notifications/initialized'\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn mcp;\n\t\t} catch (e) {\n\t\t\tmcp.dispose();\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tstore.dispose();\n\t\t}\n\t}\n\n\tpublic readonly logger: ILogger;\n\tprivate readonly _launch: IMcpMessageTransport;\n\tprivate readonly _requestLogLevel: LogLevel;\n\tprivate readonly _createMessageRequestHandler: IMcpServerRequestHandlerOptions['createMessageRequestHandler'];\n\tprivate readonly _elicitationRequestHandler: IMcpServerRequestHandlerOptions['elicitationRequestHandler'];\n\n\tprotected constructor({\n\t\tlaunch,\n\t\tlogger,\n\t\tcreateMessageRequestHandler,\n\t\telicitationRequestHandler,\n\t\trequestLogLevel = LogLevel.Debug,\n\t}: IMcpServerRequestHandlerOptions) {\n\t\tsuper();\n\t\tthis._launch = launch;\n\t\tthis.logger = logger;\n\t\tthis._requestLogLevel = requestLogLevel;\n\t\tthis._createMessageRequestHandler = createMessageRequestHandler;\n\t\tthis._elicitationRequestHandler = elicitationRequestHandler;\n\n\t\tthis._register(launch.onDidReceiveMessage(message => this.handleMessage(message)));\n\t\tthis._register(autorun(reader => {\n\t\t\tconst state = launch.state.read(reader).state;\n\t\t\t// the handler will get disposed when the launch stops, but if we're still\n\t\t\t// create()'ing we need to make sure to cancel the initialize request.\n\t\t\tif (state === McpConnectionState.Kind.Error || state === McpConnectionState.Kind.Stopped) {\n\t\t\t\tthis.cancelAllRequests();\n\t\t\t}\n\t\t}));\n\n\t\t// Listen for log level changes and forward them to the MCP server\n\t\tthis._register(logger.onDidChangeLogLevel((logLevel) => {\n\t\t\tthis._sendLogLevelToServer(logLevel);\n\t\t}));\n\t}\n\n\t/**\n\t * Send a client request to the server and return the response.\n\t *\n\t * @param request The request to send\n\t * @param token Cancellation token\n\t * @param timeoutMs Optional timeout in milliseconds\n\t * @returns A promise that resolves with the response\n\t */\n\tprivate async sendRequest<T extends MCP.ClientRequest, R extends MCP.ServerResult>(\n\t\trequest: Pick<T, 'params' | 'method'>,\n\t\ttoken: CancellationToken = CancellationToken.None\n\t): Promise<R> {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn Promise.reject(new CancellationError());\n\t\t}\n\n\t\tconst id = this._nextRequestId++;\n\n\t\t// Create the full JSON-RPC request\n\t\tconst jsonRpcRequest: MCP.JSONRPCRequest = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid,\n\t\t\t...request\n\t\t};\n\n\t\tconst promise = new DeferredPromise<MCP.ServerResult>();\n\t\t// Store the pending request\n\t\tthis._pendingRequests.set(id, { promise });\n\t\t// Set up cancellation\n\t\tconst cancelListener = token.onCancellationRequested(() => {\n\t\t\tif (!promise.isSettled) {\n\t\t\t\tthis._pendingRequests.delete(id);\n\t\t\t\tthis.sendNotification({ method: 'notifications/cancelled', params: { requestId: id } });\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t\tcancelListener.dispose();\n\t\t});\n\n\t\t// Send the request\n\t\tthis.send(jsonRpcRequest);\n\t\tconst ret = promise.p.finally(() => {\n\t\t\tcancelListener.dispose();\n\t\t\tthis._pendingRequests.delete(id);\n\t\t});\n\n\t\treturn ret as Promise<R>;\n\t}\n\n\tprivate send(mcp: MCP.JSONRPCMessage) {\n\t\tif (canLog(this.logger.getLevel(), this._requestLogLevel)) { // avoid building the string if we don't need to\n\t\t\tlog(this.logger, this._requestLogLevel, `[editor -> server] ${JSON.stringify(mcp)}`);\n\t\t}\n\n\t\tthis._launch.send(mcp);\n\t}\n\n\t/**\n\t * Handles paginated requests by making multiple requests until all items are retrieved.\n\t *\n\t * @param method The method name to call\n\t * @param getItems Function to extract the array of items from a result\n\t * @param initialParams Initial parameters\n\t * @param token Cancellation token\n\t * @returns Promise with all items combined\n\t */\n\tprivate async *sendRequestPaginated<T extends MCP.PaginatedRequest & MCP.ClientRequest, R extends MCP.PaginatedResult, I>(method: T['method'], getItems: (result: R) => I[], initialParams?: Omit<T['params'], 'jsonrpc' | 'id'>, token: CancellationToken = CancellationToken.None): AsyncIterable<I[]> {\n\t\tlet nextCursor: MCP.Cursor | undefined = undefined;\n\n\t\tdo {\n\t\t\tconst params: T['params'] = {\n\t\t\t\t...initialParams,\n\t\t\t\tcursor: nextCursor\n\t\t\t};\n\n\t\t\tconst result: R = await this.sendRequest<T, R>({ method, params }, token);\n\t\t\tyield getItems(result);\n\t\t\tnextCursor = result.nextCursor;\n\t\t} while (nextCursor !== undefined && !token.isCancellationRequested);\n\t}\n\n\tprivate sendNotification<N extends MCP.ClientNotification>(notification: Omit<N, 'jsonrpc'>): void {\n\t\tthis.send({ ...notification, jsonrpc: MCP.JSONRPC_VERSION });\n\t}\n\n\t/**\n\t * Handle incoming messages from the server\n\t */\n\tprivate handleMessage(message: MCP.JSONRPCMessage): void {\n\t\tif (canLog(this.logger.getLevel(), this._requestLogLevel)) { // avoid building the string if we don't need to\n\t\t\tlog(this.logger, this._requestLogLevel, `[server -> editor] ${JSON.stringify(message)}`);\n\t\t}\n\n\t\t// Handle responses to our requests\n\t\tif ('id' in message) {\n\t\t\tif ('result' in message) {\n\t\t\t\tthis.handleResult(message);\n\t\t\t} else if ('error' in message) {\n\t\t\t\tthis.handleError(message);\n\t\t\t}\n\t\t}\n\n\t\t// Handle requests from the server\n\t\tif ('method' in message) {\n\t\t\tif ('id' in message) {\n\t\t\t\tthis.handleServerRequest(message as MCP.JSONRPCRequest & MCP.ServerRequest);\n\t\t\t} else {\n\t\t\t\tthis.handleServerNotification(message as MCP.JSONRPCNotification & MCP.ServerNotification);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handle successful responses\n\t */\n\tprivate handleResult(response: MCP.JSONRPCResponse): void {\n\t\tconst request = this._pendingRequests.get(response.id);\n\t\tif (request) {\n\t\t\tthis._pendingRequests.delete(response.id);\n\t\t\trequest.promise.complete(response.result);\n\t\t}\n\t}\n\n\t/**\n\t * Handle error responses\n\t */\n\tprivate handleError(response: MCP.JSONRPCError): void {\n\t\tconst request = this._pendingRequests.get(response.id);\n\t\tif (request) {\n\t\t\tthis._pendingRequests.delete(response.id);\n\t\t\trequest.promise.error(new MpcResponseError(response.error.message, response.error.code, response.error.data));\n\t\t}\n\t}\n\n\t/**\n\t * Handle incoming server requests\n\t */\n\tprivate async handleServerRequest(request: MCP.JSONRPCRequest & MCP.ServerRequest): Promise<void> {\n\t\ttry {\n\t\t\tlet response: MCP.Result | undefined;\n\t\t\tif (request.method === 'ping') {\n\t\t\t\tresponse = this.handlePing(request);\n\t\t\t} else if (request.method === 'roots/list') {\n\t\t\t\tresponse = this.handleRootsList(request);\n\t\t\t} else if (request.method === 'sampling/createMessage' && this._createMessageRequestHandler) {\n\t\t\t\tresponse = await this._createMessageRequestHandler(request.params as MCP.CreateMessageRequest['params']);\n\t\t\t} else if (request.method === 'elicitation/create' && this._elicitationRequestHandler) {\n\t\t\t\tresponse = await this._elicitationRequestHandler(request.params as MCP.ElicitRequest['params']);\n\t\t\t} else {\n\t\t\t\tthrow McpError.methodNotFound(request.method);\n\t\t\t}\n\t\t\tthis.respondToRequest(request, response);\n\t\t} catch (e) {\n\t\t\tif (!(e instanceof McpError)) {\n\t\t\t\tthis.logger.error(`Error handling request ${request.method}:`, e);\n\t\t\t\te = McpError.unknown(e);\n\t\t\t}\n\n\t\t\tconst errorResponse: MCP.JSONRPCError = {\n\t\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\t\tid: request.id,\n\t\t\t\terror: {\n\t\t\t\t\tcode: e.code,\n\t\t\t\t\tmessage: e.message,\n\t\t\t\t\tdata: e.data,\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.send(errorResponse);\n\t\t}\n\t}\n\t/**\n\t * Handle incoming server notifications\n\t */\n\tprivate handleServerNotification(request: MCP.JSONRPCNotification & MCP.ServerNotification): void {\n\t\tswitch (request.method) {\n\t\t\tcase 'notifications/message':\n\t\t\t\treturn this.handleLoggingNotification(request);\n\t\t\tcase 'notifications/cancelled':\n\t\t\t\tthis._onDidReceiveCancelledNotification.fire(request);\n\t\t\t\treturn this.handleCancelledNotification(request);\n\t\t\tcase 'notifications/progress':\n\t\t\t\tthis._onDidReceiveProgressNotification.fire(request);\n\t\t\t\treturn;\n\t\t\tcase 'notifications/resources/list_changed':\n\t\t\t\tthis._onDidChangeResourceList.fire();\n\t\t\t\treturn;\n\t\t\tcase 'notifications/resources/updated':\n\t\t\t\tthis._onDidUpdateResource.fire(request);\n\t\t\t\treturn;\n\t\t\tcase 'notifications/tools/list_changed':\n\t\t\t\tthis._onDidChangeToolList.fire();\n\t\t\t\treturn;\n\t\t\tcase 'notifications/prompts/list_changed':\n\t\t\t\tthis._onDidChangePromptList.fire();\n\t\t\t\treturn;\n\t\t\tcase 'notifications/elicitation/complete':\n\t\t\t\tthis._onDidReceiveElicitationCompleteNotification.fire(request);\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tsoftAssertNever(request);\n\t\t}\n\t}\n\n\tprivate handleCancelledNotification(request: MCP.CancelledNotification): void {\n\t\tconst pendingRequest = this._pendingRequests.get(request.params.requestId);\n\t\tif (pendingRequest) {\n\t\t\tthis._pendingRequests.delete(request.params.requestId);\n\t\t\tpendingRequest.promise.cancel();\n\t\t}\n\t}\n\n\tprivate handleLoggingNotification(request: MCP.LoggingMessageNotification): void {\n\t\tlet contents = typeof request.params.data === 'string' ? request.params.data : JSON.stringify(request.params.data);\n\t\tif (request.params.logger) {\n\t\t\tcontents = `${request.params.logger}: ${contents}`;\n\t\t}\n\n\t\tswitch (request.params?.level) {\n\t\t\tcase 'debug':\n\t\t\t\tthis.logger.debug(contents);\n\t\t\t\tbreak;\n\t\t\tcase 'info':\n\t\t\tcase 'notice':\n\t\t\t\tthis.logger.info(contents);\n\t\t\t\tbreak;\n\t\t\tcase 'warning':\n\t\t\t\tthis.logger.warn(contents);\n\t\t\t\tbreak;\n\t\t\tcase 'error':\n\t\t\tcase 'critical':\n\t\t\tcase 'alert':\n\t\t\tcase 'emergency':\n\t\t\t\tthis.logger.error(contents);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.logger.info(contents);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Send a generic response to a request\n\t */\n\tprivate respondToRequest(request: MCP.JSONRPCRequest, result: MCP.Result): void {\n\t\tconst response: MCP.JSONRPCResponse = {\n\t\t\tjsonrpc: MCP.JSONRPC_VERSION,\n\t\t\tid: request.id,\n\t\t\tresult\n\t\t};\n\t\tthis.send(response);\n\t}\n\n\t/**\n\t * Send a response to a ping request\n\t */\n\tprivate handlePing(_request: MCP.PingRequest): {} {\n\t\treturn {};\n\t}\n\n\t/**\n\t * Send a response to a roots/list request\n\t */\n\tprivate handleRootsList(_request: MCP.ListRootsRequest): MCP.ListRootsResult {\n\t\tthis._hasAnnouncedRoots = true;\n\t\treturn { roots: this._roots };\n\t}\n\n\tprivate cancelAllRequests() {\n\t\tthis._pendingRequests.forEach(pending => pending.promise.cancel());\n\t\tthis._pendingRequests.clear();\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis.cancelAllRequests();\n\t\tsuper.dispose();\n\t}\n\n\t/**\n\t * Forwards log level changes to the MCP server if it supports logging\n\t */\n\tprivate async _sendLogLevelToServer(logLevel: LogLevel): Promise<void> {\n\t\ttry {\n\t\t\t// Only send if the server supports logging capabilities\n\t\t\tif (!this.capabilities.logging) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait this.setLevel({ level: mapLogLevelToMcp(logLevel) });\n\t\t} catch (error) {\n\t\t\tthis.logger.error(`Failed to set MCP server log level: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Send an initialize request\n\t */\n\tinitialize(params: MCP.InitializeRequest['params'], token?: CancellationToken): Promise<MCP.InitializeResult> {\n\t\treturn this.sendRequest<MCP.InitializeRequest, MCP.InitializeResult>({ method: 'initialize', params }, token);\n\t}\n\n\t/**\n\t * List available resources\n\t */\n\tlistResources(params?: MCP.ListResourcesRequest['params'], token?: CancellationToken): Promise<MCP.Resource[]> {\n\t\treturn Iterable.asyncToArrayFlat(this.listResourcesIterable(params, token));\n\t}\n\n\t/**\n\t * List available resources (iterable)\n\t */\n\tlistResourcesIterable(params?: MCP.ListResourcesRequest['params'], token?: CancellationToken): AsyncIterable<MCP.Resource[]> {\n\t\treturn this.sendRequestPaginated<MCP.ListResourcesRequest, MCP.ListResourcesResult, MCP.Resource>('resources/list', result => result.resources, params, token);\n\t}\n\n\t/**\n\t * Read a specific resource\n\t */\n\treadResource(params: MCP.ReadResourceRequest['params'], token?: CancellationToken): Promise<MCP.ReadResourceResult> {\n\t\treturn this.sendRequest<MCP.ReadResourceRequest, MCP.ReadResourceResult>({ method: 'resources/read', params }, token);\n\t}\n\n\t/**\n\t * List available resource templates\n\t */\n\tlistResourceTemplates(params?: MCP.ListResourceTemplatesRequest['params'], token?: CancellationToken): Promise<MCP.ResourceTemplate[]> {\n\t\treturn Iterable.asyncToArrayFlat(this.sendRequestPaginated<MCP.ListResourceTemplatesRequest, MCP.ListResourceTemplatesResult, MCP.ResourceTemplate>('resources/templates/list', result => result.resourceTemplates, params, token));\n\t}\n\n\t/**\n\t * Subscribe to resource updates\n\t */\n\tsubscribe(params: MCP.SubscribeRequest['params'], token?: CancellationToken): Promise<MCP.EmptyResult> {\n\t\treturn this.sendRequest<MCP.SubscribeRequest, MCP.EmptyResult>({ method: 'resources/subscribe', params }, token);\n\t}\n\n\t/**\n\t * Unsubscribe from resource updates\n\t */\n\tunsubscribe(params: MCP.UnsubscribeRequest['params'], token?: CancellationToken): Promise<MCP.EmptyResult> {\n\t\treturn this.sendRequest<MCP.UnsubscribeRequest, MCP.EmptyResult>({ method: 'resources/unsubscribe', params }, token);\n\t}\n\n\t/**\n\t * List available prompts\n\t */\n\tlistPrompts(params?: MCP.ListPromptsRequest['params'], token?: CancellationToken): Promise<MCP.Prompt[]> {\n\t\treturn Iterable.asyncToArrayFlat(this.sendRequestPaginated<MCP.ListPromptsRequest, MCP.ListPromptsResult, MCP.Prompt>('prompts/list', result => result.prompts, params, token));\n\t}\n\n\t/**\n\t * Get a specific prompt\n\t */\n\tgetPrompt(params: MCP.GetPromptRequest['params'], token?: CancellationToken): Promise<MCP.GetPromptResult> {\n\t\treturn this.sendRequest<MCP.GetPromptRequest, MCP.GetPromptResult>({ method: 'prompts/get', params }, token);\n\t}\n\n\t/**\n\t * List available tools\n\t */\n\tlistTools(params?: MCP.ListToolsRequest['params'], token?: CancellationToken): Promise<MCP.Tool[]> {\n\t\treturn Iterable.asyncToArrayFlat(this.sendRequestPaginated<MCP.ListToolsRequest, MCP.ListToolsResult, MCP.Tool>('tools/list', result => result.tools, params, token));\n\t}\n\n\t/**\n\t * Call a specific tool\n\t */\n\tcallTool(params: MCP.CallToolRequest['params'] & MCP.Request['params'], token?: CancellationToken): Promise<MCP.CallToolResult> {\n\t\treturn this.sendRequest<MCP.CallToolRequest, MCP.CallToolResult>({ method: 'tools/call', params }, token);\n\t}\n\n\t/**\n\t * Set the logging level\n\t */\n\tsetLevel(params: MCP.SetLevelRequest['params'], token?: CancellationToken): Promise<MCP.EmptyResult> {\n\t\treturn this.sendRequest<MCP.SetLevelRequest, MCP.EmptyResult>({ method: 'logging/setLevel', params }, token);\n\t}\n\n\t/**\n\t * Find completions for an argument\n\t */\n\tcomplete(params: MCP.CompleteRequest['params'], token?: CancellationToken): Promise<MCP.CompleteResult> {\n\t\treturn this.sendRequest<MCP.CompleteRequest, MCP.CompleteResult>({ method: 'completion/complete', params }, token);\n\t}\n}\n\n\n/**\n * Maps VSCode LogLevel to MCP LoggingLevel\n */\nfunction mapLogLevelToMcp(logLevel: LogLevel): MCP.LoggingLevel {\n\tswitch (logLevel) {\n\t\tcase LogLevel.Trace:\n\t\t\treturn 'debug'; // MCP doesn't have trace, use debug\n\t\tcase LogLevel.Debug:\n\t\t\treturn 'debug';\n\t\tcase LogLevel.Info:\n\t\t\treturn 'info';\n\t\tcase LogLevel.Warning:\n\t\t\treturn 'warning';\n\t\tcase LogLevel.Error:\n\t\t\treturn 'error';\n\t\tcase LogLevel.Off:\n\t\t\treturn 'emergency'; // MCP doesn't have off, use emergency\n\t\tdefault:\n\t\t\treturn assertNever(logLevel); // Off and other levels are not supported\n\t}\n}\n"]}