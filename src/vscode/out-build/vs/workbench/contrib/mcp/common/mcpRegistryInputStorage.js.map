{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/common/mcpRegistryInputStorage.ts","vs/workbench/contrib/mcp/common/mcpRegistryInputStorage.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;AAEhG,OAAO,EAAE,SAAS,EAAE,MAAM,kCAAkC,CAAC;AAC7D,OAAO,EAAE,YAAY,EAAE,YAAY,EAAE,QAAQ,EAAE,MAAM,mCAAmC,CAAC;AACzF,OAAO,EAAE,IAAI,EAAE,MAAM,iCAAiC,CAAC;AACvD,OAAO,EAAE,UAAU,EAAE,MAAM,sCAAsC,CAAC;AAClE,OAAO,EAAE,aAAa,EAAE,MAAM,kCAAkC,CAAC;AACjE,OAAO,EAAE,WAAW,EAAE,MAAM,wCAAwC,CAAC;AACrE,OAAO,EAAE,qBAAqB,EAAE,MAAM,gDAAgD,CAAC;AACvF,OAAO,EAAE,eAAe,EAA+B,MAAM,gDAAgD,CAAC;AAG9G,MAAM,uBAAuB,GAAG,kBAAkB,CAAC;AACnD,MAAM,4BAA4B,GAAG,SAAS,CAAC;AAC/C,MAAM,sBAAsB,GAAG,GAAG,CAAC;AACnC,MAAM,wBAAwB,GAAG,EAAE,CAAC,CAAC,UAAU;AAC/C,MAAM,uBAAuB,GAAG,CAAC,CAAC;AAClC,MAAM,mBAAmB,GAAG,WAAW,CAAC;AAYjC,IAAM,uBAAuB,GAA7B,MAAM,uBAAwB,SAAQ,UAAU;;aACvC,oBAAe,GAAG,IAAI,SAAS,EAAhB,AAAkB,CAAC;IAmCjD,YACkB,MAAoB,EACrC,OAAsB,EACL,eAAiD,EAC3C,qBAA6D,EACvE,WAAyC;QAEtD,KAAK,EAAE,CAAC;QANS,WAAM,GAAN,MAAM,CAAc;QAEH,oBAAe,GAAf,eAAe,CAAiB;QAC1B,0BAAqB,GAArB,qBAAqB,CAAuB;QACtD,gBAAW,GAAX,WAAW,CAAa;QAvCtC,4BAAuB,GAAG,IAAI,SAAS,EAAE,CAAC;QAE1C,sBAAiB,GAAG,IAAI,IAAI,CAAC,GAAG,EAAE;YAClD,OAAO,yBAAuB,CAAC,eAAe,CAAC,KAAK,CAAC,KAAK,IAAI,EAAE;gBAC/D,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC;gBAC/E,IAAI,QAAQ,EAAE,CAAC;oBACd,IAAI,CAAC;wBACJ,MAAM,MAAM,GAAe,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;wBAChD,OAAO,MAAM,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,MAAM,EAAE,4BAA4B,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;oBAClH,CAAC;oBAAC,MAAM,CAAC;wBACR,eAAe;oBAChB,CAAC;gBACF,CAAC;gBAED,MAAM,GAAG,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,WAAW,CAC1C,EAAE,IAAI,EAAE,4BAA4B,EAAE,MAAM,EAAE,sBAAsB,EAAE,EACtE,IAAI,EACJ,CAAC,SAAS,EAAE,SAAS,CAAC,CACtB,CAAC;gBAEF,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;gBAC3D,MAAM,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,uBAAuB,EAAE,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACxF,OAAO,GAAG,CAAC;YACZ,CAAC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;QAEK,eAAU,GAAG,KAAK,CAAC;QAEnB,YAAO,GAAG,IAAI,IAAI,CAAgB,GAAG,EAAE;YAC9C,MAAM,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,SAAS,CAAc,mBAAmB,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;YAC7F,OAAO,MAAM,EAAE,OAAO,KAAK,uBAAuB,CAAC,CAAC,CAAC,EAAE,GAAG,MAAM,EAAE,CAAC,CAAC,CAAC,EAAE,OAAO,EAAE,uBAAuB,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC;QACvH,CAAC,CAAC,CAAC;QAYF,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,eAAe,CAAC,GAAG,EAAE;YACnD,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;gBACrB,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,mBAAmB,EAAE;oBAC/C,OAAO,EAAE,uBAAuB;oBAChC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM;oBACjC,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO;iBACb,EAAE,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;gBAC/C,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;YACzB,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,gDAAgD;IACzC,QAAQ;QACd,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,SAAS,CAAC;QACvC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,GAAG,SAAS,CAAC;QAC/C,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;IACxB,CAAC;IAED,wDAAwD;IACjD,KAAK,CAAC,KAAK,CAAC,QAAgB;QAClC,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;QAC5C,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC3C,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QAEvB,IAAI,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE,CAAC;YACtC,OAAO,OAAO,CAAC,QAAQ,CAAC,CAAC;YACzB,MAAM,IAAI,CAAC,YAAY,EAAE,CAAC;QAC3B,CAAC;IACF,CAAC;IAED,0CAA0C;IACnC,KAAK,CAAC,MAAM;QAClB,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;QAC5C,OAAO,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,GAAG,OAAO,EAAE,CAAC;IACrD,CAAC;IAED,sCAAsC;IAC/B,KAAK,CAAC,YAAY,CAAC,MAAsC;QAC/D,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QACjD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;IACxB,CAAC;IAED,yCAAyC;IAClC,KAAK,CAAC,UAAU,CAAC,MAAsC;QAC7D,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;QAC7C,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QAChC,MAAM,IAAI,CAAC,YAAY,EAAE,CAAC;IAC3B,CAAC;IAEO,KAAK,CAAC,YAAY;QACzB,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;QAC/C,OAAO,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC,KAAK,IAAI,EAAE;YACpD,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,IAAI,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,CAAC,EAAE,CAAC;gBAC9F,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,SAAS,CAAC;gBACvC,OAAO;YACR,CAAC;YAED,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;YAClE,MAAM,EAAE,GAAG,MAAM,CAAC,eAAe,CAAC,IAAI,UAAU,CAAC,wBAAwB,CAAC,CAAC,CAAC;YAC5E,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,OAAO,CAC5C,EAAE,IAAI,EAAE,4BAA4B,EAAE,EAAE,EAAE,EAAE,CAAC,MAAM,EAAE,EACrD,GAAG,EACH,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAqB,CACtD,CAAC;YAEF,MAAM,GAAG,GAAG,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YACnE,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,EAAE,EAAE,EAAE,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC;YACjF,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACxB,CAAC,CAAC,CAAC;IACJ,CAAC;IAEO,KAAK,CAAC,cAAc;QAC3B,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;YACjC,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,KAAK,EAAE,CAAC;QAClD,CAAC;QAED,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC;YACxC,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,CAAC;QAC3C,CAAC;QAED,IAAI,CAAC;YACJ,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;YAC/C,MAAM,EAAE,GAAG,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;YACvD,MAAM,SAAS,GAAG,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAEjE,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,OAAO,CAC5C,EAAE,IAAI,EAAE,4BAA4B,EAAE,EAAE,EAAE,EAAE,CAAC,MAAiC,EAAE,EAChF,GAAG,EACH,SAAS,CAAC,MAAiC,CAC3C,CAAC;YAEF,MAAM,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;YACxE,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,GAAG,eAAe,CAAC;YACrD,OAAO,eAAe,CAAC;QACxB,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,6BAA6B,EAAE,CAAC,CAAC,CAAC;YACxD,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,SAAS,CAAC;QACxC,CAAC;QAED,OAAO,EAAE,CAAC;IACX,CAAC;;AAnJW,uBAAuB;IAuCjC,WAAA,eAAe,CAAA;IACf,WAAA,qBAAqB,CAAA;IACrB,WAAA,WAAW,CAAA;GAzCD,uBAAuB,CAoJnC","file":"mcpRegistryInputStorage.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Sequencer } from '../../../../base/common/async.js';\nimport { decodeBase64, encodeBase64, VSBuffer } from '../../../../base/common/buffer.js';\nimport { Lazy } from '../../../../base/common/lazy.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { isEmptyObject } from '../../../../base/common/types.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { ISecretStorageService } from '../../../../platform/secrets/common/secrets.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { IResolvedValue } from '../../../services/configurationResolver/common/configurationResolverExpression.js';\n\nconst MCP_ENCRYPTION_KEY_NAME = 'mcpEncryptionKey';\nconst MCP_ENCRYPTION_KEY_ALGORITHM = 'AES-GCM';\nconst MCP_ENCRYPTION_KEY_LEN = 256;\nconst MCP_ENCRYPTION_IV_LENGTH = 12; // 96 bits\nconst MCP_DATA_STORED_VERSION = 1;\nconst MCP_DATA_STORED_KEY = 'mcpInputs';\n\ninterface IStoredData {\n\tversion: number;\n\tvalues: Record<string, IResolvedValue>;\n\tsecrets?: { value: string; iv: string }; // base64, encrypted\n}\n\ninterface IHydratedData extends IStoredData {\n\tunsealedSecrets?: Record<string, IResolvedValue>;\n}\n\nexport class McpRegistryInputStorage extends Disposable {\n\tprivate static secretSequencer = new Sequencer();\n\tprivate readonly _secretsSealerSequencer = new Sequencer();\n\n\tprivate readonly _getEncryptionKey = new Lazy(() => {\n\t\treturn McpRegistryInputStorage.secretSequencer.queue(async () => {\n\t\t\tconst existing = await this._secretStorageService.get(MCP_ENCRYPTION_KEY_NAME);\n\t\t\tif (existing) {\n\t\t\t\ttry {\n\t\t\t\t\tconst parsed: JsonWebKey = JSON.parse(existing);\n\t\t\t\t\treturn await crypto.subtle.importKey('jwk', parsed, MCP_ENCRYPTION_KEY_ALGORITHM, false, ['encrypt', 'decrypt']);\n\t\t\t\t} catch {\n\t\t\t\t\t// fall through\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst key = await crypto.subtle.generateKey(\n\t\t\t\t{ name: MCP_ENCRYPTION_KEY_ALGORITHM, length: MCP_ENCRYPTION_KEY_LEN },\n\t\t\t\ttrue,\n\t\t\t\t['encrypt', 'decrypt'],\n\t\t\t);\n\n\t\t\tconst exported = await crypto.subtle.exportKey('jwk', key);\n\t\t\tawait this._secretStorageService.set(MCP_ENCRYPTION_KEY_NAME, JSON.stringify(exported));\n\t\t\treturn key;\n\t\t});\n\t});\n\n\tprivate _didChange = false;\n\n\tprivate _record = new Lazy<IHydratedData>(() => {\n\t\tconst stored = this._storageService.getObject<IStoredData>(MCP_DATA_STORED_KEY, this._scope);\n\t\treturn stored?.version === MCP_DATA_STORED_VERSION ? { ...stored } : { version: MCP_DATA_STORED_VERSION, values: {} };\n\t});\n\n\n\tconstructor(\n\t\tprivate readonly _scope: StorageScope,\n\t\t_target: StorageTarget,\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t\t@ISecretStorageService private readonly _secretStorageService: ISecretStorageService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(_storageService.onWillSaveState(() => {\n\t\t\tif (this._didChange) {\n\t\t\t\tthis._storageService.store(MCP_DATA_STORED_KEY, {\n\t\t\t\t\tversion: MCP_DATA_STORED_VERSION,\n\t\t\t\t\tvalues: this._record.value.values,\n\t\t\t\t\tsecrets: this._record.value.secrets,\n\t\t\t\t} satisfies IStoredData, this._scope, _target);\n\t\t\t\tthis._didChange = false;\n\t\t\t}\n\t\t}));\n\t}\n\n\t/** Deletes all collection data from storage. */\n\tpublic clearAll() {\n\t\tthis._record.value.values = {};\n\t\tthis._record.value.secrets = undefined;\n\t\tthis._record.value.unsealedSecrets = undefined;\n\t\tthis._didChange = true;\n\t}\n\n\t/** Delete a single collection data from the storage. */\n\tpublic async clear(inputKey: string) {\n\t\tconst secrets = await this._unsealSecrets();\n\t\tdelete this._record.value.values[inputKey];\n\t\tthis._didChange = true;\n\n\t\tif (secrets.hasOwnProperty(inputKey)) {\n\t\t\tdelete secrets[inputKey];\n\t\t\tawait this._sealSecrets();\n\t\t}\n\t}\n\n\t/** Gets a mapping of saved input data. */\n\tpublic async getMap() {\n\t\tconst secrets = await this._unsealSecrets();\n\t\treturn { ...this._record.value.values, ...secrets };\n\t}\n\n\t/** Updates the input data mapping. */\n\tpublic async setPlainText(values: Record<string, IResolvedValue>) {\n\t\tObject.assign(this._record.value.values, values);\n\t\tthis._didChange = true;\n\t}\n\n\t/** Updates the input secrets mapping. */\n\tpublic async setSecrets(values: Record<string, IResolvedValue>) {\n\t\tconst unsealed = await this._unsealSecrets();\n\t\tObject.assign(unsealed, values);\n\t\tawait this._sealSecrets();\n\t}\n\n\tprivate async _sealSecrets() {\n\t\tconst key = await this._getEncryptionKey.value;\n\t\treturn this._secretsSealerSequencer.queue(async () => {\n\t\t\tif (!this._record.value.unsealedSecrets || isEmptyObject(this._record.value.unsealedSecrets)) {\n\t\t\t\tthis._record.value.secrets = undefined;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst toSeal = JSON.stringify(this._record.value.unsealedSecrets);\n\t\t\tconst iv = crypto.getRandomValues(new Uint8Array(MCP_ENCRYPTION_IV_LENGTH));\n\t\t\tconst encrypted = await crypto.subtle.encrypt(\n\t\t\t\t{ name: MCP_ENCRYPTION_KEY_ALGORITHM, iv: iv.buffer },\n\t\t\t\tkey,\n\t\t\t\tnew TextEncoder().encode(toSeal).buffer as ArrayBuffer,\n\t\t\t);\n\n\t\t\tconst enc = encodeBase64(VSBuffer.wrap(new Uint8Array(encrypted)));\n\t\t\tthis._record.value.secrets = { iv: encodeBase64(VSBuffer.wrap(iv)), value: enc };\n\t\t\tthis._didChange = true;\n\t\t});\n\t}\n\n\tprivate async _unsealSecrets(): Promise<Record<string, IResolvedValue>> {\n\t\tif (!this._record.value.secrets) {\n\t\t\treturn this._record.value.unsealedSecrets ??= {};\n\t\t}\n\n\t\tif (this._record.value.unsealedSecrets) {\n\t\t\treturn this._record.value.unsealedSecrets;\n\t\t}\n\n\t\ttry {\n\t\t\tconst key = await this._getEncryptionKey.value;\n\t\t\tconst iv = decodeBase64(this._record.value.secrets.iv);\n\t\t\tconst encrypted = decodeBase64(this._record.value.secrets.value);\n\n\t\t\tconst decrypted = await crypto.subtle.decrypt(\n\t\t\t\t{ name: MCP_ENCRYPTION_KEY_ALGORITHM, iv: iv.buffer as Uint8Array<ArrayBuffer> },\n\t\t\t\tkey,\n\t\t\t\tencrypted.buffer as Uint8Array<ArrayBuffer>,\n\t\t\t);\n\n\t\t\tconst unsealedSecrets = JSON.parse(new TextDecoder().decode(decrypted));\n\t\t\tthis._record.value.unsealedSecrets = unsealedSecrets;\n\t\t\treturn unsealedSecrets;\n\t\t} catch (e) {\n\t\t\tthis._logService.warn('Error unsealing MCP secrets', e);\n\t\t\tthis._record.value.secrets = undefined;\n\t\t}\n\n\t\treturn {};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Sequencer } from '../../../../base/common/async.js';\nimport { decodeBase64, encodeBase64, VSBuffer } from '../../../../base/common/buffer.js';\nimport { Lazy } from '../../../../base/common/lazy.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { isEmptyObject } from '../../../../base/common/types.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { ISecretStorageService } from '../../../../platform/secrets/common/secrets.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { IResolvedValue } from '../../../services/configurationResolver/common/configurationResolverExpression.js';\n\nconst MCP_ENCRYPTION_KEY_NAME = 'mcpEncryptionKey';\nconst MCP_ENCRYPTION_KEY_ALGORITHM = 'AES-GCM';\nconst MCP_ENCRYPTION_KEY_LEN = 256;\nconst MCP_ENCRYPTION_IV_LENGTH = 12; // 96 bits\nconst MCP_DATA_STORED_VERSION = 1;\nconst MCP_DATA_STORED_KEY = 'mcpInputs';\n\ninterface IStoredData {\n\tversion: number;\n\tvalues: Record<string, IResolvedValue>;\n\tsecrets?: { value: string; iv: string }; // base64, encrypted\n}\n\ninterface IHydratedData extends IStoredData {\n\tunsealedSecrets?: Record<string, IResolvedValue>;\n}\n\nexport class McpRegistryInputStorage extends Disposable {\n\tprivate static secretSequencer = new Sequencer();\n\tprivate readonly _secretsSealerSequencer = new Sequencer();\n\n\tprivate readonly _getEncryptionKey = new Lazy(() => {\n\t\treturn McpRegistryInputStorage.secretSequencer.queue(async () => {\n\t\t\tconst existing = await this._secretStorageService.get(MCP_ENCRYPTION_KEY_NAME);\n\t\t\tif (existing) {\n\t\t\t\ttry {\n\t\t\t\t\tconst parsed: JsonWebKey = JSON.parse(existing);\n\t\t\t\t\treturn await crypto.subtle.importKey('jwk', parsed, MCP_ENCRYPTION_KEY_ALGORITHM, false, ['encrypt', 'decrypt']);\n\t\t\t\t} catch {\n\t\t\t\t\t// fall through\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst key = await crypto.subtle.generateKey(\n\t\t\t\t{ name: MCP_ENCRYPTION_KEY_ALGORITHM, length: MCP_ENCRYPTION_KEY_LEN },\n\t\t\t\ttrue,\n\t\t\t\t['encrypt', 'decrypt'],\n\t\t\t);\n\n\t\t\tconst exported = await crypto.subtle.exportKey('jwk', key);\n\t\t\tawait this._secretStorageService.set(MCP_ENCRYPTION_KEY_NAME, JSON.stringify(exported));\n\t\t\treturn key;\n\t\t});\n\t});\n\n\tprivate _didChange = false;\n\n\tprivate _record = new Lazy<IHydratedData>(() => {\n\t\tconst stored = this._storageService.getObject<IStoredData>(MCP_DATA_STORED_KEY, this._scope);\n\t\treturn stored?.version === MCP_DATA_STORED_VERSION ? { ...stored } : { version: MCP_DATA_STORED_VERSION, values: {} };\n\t});\n\n\n\tconstructor(\n\t\tprivate readonly _scope: StorageScope,\n\t\t_target: StorageTarget,\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t\t@ISecretStorageService private readonly _secretStorageService: ISecretStorageService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(_storageService.onWillSaveState(() => {\n\t\t\tif (this._didChange) {\n\t\t\t\tthis._storageService.store(MCP_DATA_STORED_KEY, {\n\t\t\t\t\tversion: MCP_DATA_STORED_VERSION,\n\t\t\t\t\tvalues: this._record.value.values,\n\t\t\t\t\tsecrets: this._record.value.secrets,\n\t\t\t\t} satisfies IStoredData, this._scope, _target);\n\t\t\t\tthis._didChange = false;\n\t\t\t}\n\t\t}));\n\t}\n\n\t/** Deletes all collection data from storage. */\n\tpublic clearAll() {\n\t\tthis._record.value.values = {};\n\t\tthis._record.value.secrets = undefined;\n\t\tthis._record.value.unsealedSecrets = undefined;\n\t\tthis._didChange = true;\n\t}\n\n\t/** Delete a single collection data from the storage. */\n\tpublic async clear(inputKey: string) {\n\t\tconst secrets = await this._unsealSecrets();\n\t\tdelete this._record.value.values[inputKey];\n\t\tthis._didChange = true;\n\n\t\tif (secrets.hasOwnProperty(inputKey)) {\n\t\t\tdelete secrets[inputKey];\n\t\t\tawait this._sealSecrets();\n\t\t}\n\t}\n\n\t/** Gets a mapping of saved input data. */\n\tpublic async getMap() {\n\t\tconst secrets = await this._unsealSecrets();\n\t\treturn { ...this._record.value.values, ...secrets };\n\t}\n\n\t/** Updates the input data mapping. */\n\tpublic async setPlainText(values: Record<string, IResolvedValue>) {\n\t\tObject.assign(this._record.value.values, values);\n\t\tthis._didChange = true;\n\t}\n\n\t/** Updates the input secrets mapping. */\n\tpublic async setSecrets(values: Record<string, IResolvedValue>) {\n\t\tconst unsealed = await this._unsealSecrets();\n\t\tObject.assign(unsealed, values);\n\t\tawait this._sealSecrets();\n\t}\n\n\tprivate async _sealSecrets() {\n\t\tconst key = await this._getEncryptionKey.value;\n\t\treturn this._secretsSealerSequencer.queue(async () => {\n\t\t\tif (!this._record.value.unsealedSecrets || isEmptyObject(this._record.value.unsealedSecrets)) {\n\t\t\t\tthis._record.value.secrets = undefined;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst toSeal = JSON.stringify(this._record.value.unsealedSecrets);\n\t\t\tconst iv = crypto.getRandomValues(new Uint8Array(MCP_ENCRYPTION_IV_LENGTH));\n\t\t\tconst encrypted = await crypto.subtle.encrypt(\n\t\t\t\t{ name: MCP_ENCRYPTION_KEY_ALGORITHM, iv: iv.buffer },\n\t\t\t\tkey,\n\t\t\t\tnew TextEncoder().encode(toSeal).buffer as ArrayBuffer,\n\t\t\t);\n\n\t\t\tconst enc = encodeBase64(VSBuffer.wrap(new Uint8Array(encrypted)));\n\t\t\tthis._record.value.secrets = { iv: encodeBase64(VSBuffer.wrap(iv)), value: enc };\n\t\t\tthis._didChange = true;\n\t\t});\n\t}\n\n\tprivate async _unsealSecrets(): Promise<Record<string, IResolvedValue>> {\n\t\tif (!this._record.value.secrets) {\n\t\t\treturn this._record.value.unsealedSecrets ??= {};\n\t\t}\n\n\t\tif (this._record.value.unsealedSecrets) {\n\t\t\treturn this._record.value.unsealedSecrets;\n\t\t}\n\n\t\ttry {\n\t\t\tconst key = await this._getEncryptionKey.value;\n\t\t\tconst iv = decodeBase64(this._record.value.secrets.iv);\n\t\t\tconst encrypted = decodeBase64(this._record.value.secrets.value);\n\n\t\t\tconst decrypted = await crypto.subtle.decrypt(\n\t\t\t\t{ name: MCP_ENCRYPTION_KEY_ALGORITHM, iv: iv.buffer as Uint8Array<ArrayBuffer> },\n\t\t\t\tkey,\n\t\t\t\tencrypted.buffer as Uint8Array<ArrayBuffer>,\n\t\t\t);\n\n\t\t\tconst unsealedSecrets = JSON.parse(new TextDecoder().decode(decrypted));\n\t\t\tthis._record.value.unsealedSecrets = unsealedSecrets;\n\t\t\treturn unsealedSecrets;\n\t\t} catch (e) {\n\t\t\tthis._logService.warn('Error unsealing MCP secrets', e);\n\t\t\tthis._record.value.secrets = undefined;\n\t\t}\n\n\t\treturn {};\n\t}\n}\n"]}