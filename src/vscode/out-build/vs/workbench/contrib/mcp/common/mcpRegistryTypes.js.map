{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/common/mcpRegistryTypes.ts","vs/workbench/contrib/mcp/common/mcpRegistryTypes.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAMhG,OAAO,EAAE,eAAe,EAAE,MAAM,4DAA4D,CAAC;AAQ7F,MAAM,CAAC,MAAM,YAAY,GAAG,eAAe,CAAe,aAAa,CAAC,CAAC","file":"mcpRegistryTypes.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { IObservable } from '../../../../base/common/observable.js';\nimport { ConfigurationTarget } from '../../../../platform/configuration/common/configuration.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogger, LogLevel } from '../../../../platform/log/common/log.js';\nimport { StorageScope } from '../../../../platform/storage/common/storage.js';\nimport { IWorkspaceFolderData } from '../../../../platform/workspace/common/workspace.js';\nimport { IResolvedValue } from '../../../services/configurationResolver/common/configurationResolverExpression.js';\nimport { IMcpServerConnection, LazyCollectionState, McpCollectionDefinition, McpCollectionReference, McpConnectionState, McpDefinitionReference, McpServerDefinition, McpServerLaunch, McpStartServerInteraction } from './mcpTypes.js';\nimport { MCP } from './modelContextProtocol.js';\n\nexport const IMcpRegistry = createDecorator<IMcpRegistry>('mcpRegistry');\n\n/** Message transport to a single MCP server. */\nexport interface IMcpMessageTransport extends IDisposable {\n\treadonly state: IObservable<McpConnectionState>;\n\treadonly onDidLog: Event<{ level: LogLevel; message: string }>;\n\treadonly onDidReceiveMessage: Event<MCP.JSONRPCMessage>;\n\tsend(message: MCP.JSONRPCMessage): void;\n\tstop(): void;\n}\n\nexport interface IMcpHostDelegate {\n\t/** Priority for this delegate, delegates are tested in descending priority order */\n\treadonly priority: number;\n\twaitForInitialProviderPromises(): Promise<void>;\n\tcanStart(collectionDefinition: McpCollectionDefinition, serverDefinition: McpServerDefinition): boolean;\n\tsubstituteVariables(serverDefinition: McpServerDefinition, launch: McpServerLaunch): Promise<McpServerLaunch>;\n\tstart(collectionDefinition: McpCollectionDefinition, serverDefinition: McpServerDefinition, resolvedLaunch: McpServerLaunch, options?: { errorOnUserInteraction?: boolean }): IMcpMessageTransport;\n}\n\nexport interface IMcpResolveConnectionOptions {\n\tlogger: ILogger;\n\tinteraction?: McpStartServerInteraction;\n\tcollectionRef: McpCollectionReference;\n\tdefinitionRef: McpDefinitionReference;\n\n\t/** A reference (on the server) to its last nonce where trust was given. */\n\ttrustNonceBearer: { trustedAtNonce: string | undefined };\n\t/**\n\t * When to trigger the trust prompt.\n\t * - only-new: only prompt for servers that are not previously explicitly untrusted (default)\n\t * - all-untrusted: prompt for all servers that are not trusted\n\t * - never: don't prompt, fail silently when trying to start an untrusted server\n\t */\n\tpromptType?: 'only-new' | 'all-untrusted' | 'never';\n\t/**\n\t * Automatically trust if changed. This should ONLY be set for afforances that\n\t * ensure the user sees the config before it gets started (e.g. code lenses)\n\t */\n\tautoTrustChanges?: boolean;\n\n\t/** If set, try to launch with debugging when dev mode is configured */\n\tdebug?: boolean;\n\n\t/** If true, throw an error if any user interaction would be required during startup. */\n\terrorOnUserInteraction?: boolean;\n}\n\nexport interface IMcpRegistry {\n\treadonly _serviceBrand: undefined;\n\n\t/** Fired when the user provides more inputs when creating a connection. */\n\treadonly onDidChangeInputs: Event<void>;\n\n\treadonly collections: IObservable<readonly McpCollectionDefinition[]>;\n\treadonly delegates: IObservable<readonly IMcpHostDelegate[]>;\n\t/** Whether there are new collections that can be resolved with a discover() call */\n\treadonly lazyCollectionState: IObservable<{ state: LazyCollectionState; collections: McpCollectionDefinition[] }>;\n\n\t/** Helper function to observe a definition by its reference. */\n\tgetServerDefinition(collectionRef: McpDefinitionReference, definitionRef: McpDefinitionReference): IObservable<{ server: McpServerDefinition | undefined; collection: McpCollectionDefinition | undefined }>;\n\n\t/** Discover new collections, returning newly-discovered ones. */\n\tdiscoverCollections(): Promise<McpCollectionDefinition[]>;\n\n\tregisterDelegate(delegate: IMcpHostDelegate): IDisposable;\n\tregisterCollection(collection: McpCollectionDefinition): IDisposable;\n\n\t/** Resets any saved inputs for the input, or globally. */\n\tclearSavedInputs(scope: StorageScope, inputId?: string): Promise<void>;\n\t/** Edits a previously-saved input. */\n\teditSavedInput(inputId: string, folderData: IWorkspaceFolderData | undefined, configSection: string, target: ConfigurationTarget): Promise<void>;\n\t/** Updates a saved input. */\n\tsetSavedInput(inputId: string, target: ConfigurationTarget, value: string): Promise<void>;\n\t/** Gets saved inputs from storage. */\n\tgetSavedInputs(scope: StorageScope): Promise<{ [id: string]: IResolvedValue }>;\n\t/** Creates a connection for the collection and definition. */\n\tresolveConnection(options: IMcpResolveConnectionOptions): Promise<IMcpServerConnection | undefined>;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { IObservable } from '../../../../base/common/observable.js';\nimport { ConfigurationTarget } from '../../../../platform/configuration/common/configuration.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogger, LogLevel } from '../../../../platform/log/common/log.js';\nimport { StorageScope } from '../../../../platform/storage/common/storage.js';\nimport { IWorkspaceFolderData } from '../../../../platform/workspace/common/workspace.js';\nimport { IResolvedValue } from '../../../services/configurationResolver/common/configurationResolverExpression.js';\nimport { IMcpServerConnection, LazyCollectionState, McpCollectionDefinition, McpCollectionReference, McpConnectionState, McpDefinitionReference, McpServerDefinition, McpServerLaunch, McpStartServerInteraction } from './mcpTypes.js';\nimport { MCP } from './modelContextProtocol.js';\n\nexport const IMcpRegistry = createDecorator<IMcpRegistry>('mcpRegistry');\n\n/** Message transport to a single MCP server. */\nexport interface IMcpMessageTransport extends IDisposable {\n\treadonly state: IObservable<McpConnectionState>;\n\treadonly onDidLog: Event<{ level: LogLevel; message: string }>;\n\treadonly onDidReceiveMessage: Event<MCP.JSONRPCMessage>;\n\tsend(message: MCP.JSONRPCMessage): void;\n\tstop(): void;\n}\n\nexport interface IMcpHostDelegate {\n\t/** Priority for this delegate, delegates are tested in descending priority order */\n\treadonly priority: number;\n\twaitForInitialProviderPromises(): Promise<void>;\n\tcanStart(collectionDefinition: McpCollectionDefinition, serverDefinition: McpServerDefinition): boolean;\n\tsubstituteVariables(serverDefinition: McpServerDefinition, launch: McpServerLaunch): Promise<McpServerLaunch>;\n\tstart(collectionDefinition: McpCollectionDefinition, serverDefinition: McpServerDefinition, resolvedLaunch: McpServerLaunch, options?: { errorOnUserInteraction?: boolean }): IMcpMessageTransport;\n}\n\nexport interface IMcpResolveConnectionOptions {\n\tlogger: ILogger;\n\tinteraction?: McpStartServerInteraction;\n\tcollectionRef: McpCollectionReference;\n\tdefinitionRef: McpDefinitionReference;\n\n\t/** A reference (on the server) to its last nonce where trust was given. */\n\ttrustNonceBearer: { trustedAtNonce: string | undefined };\n\t/**\n\t * When to trigger the trust prompt.\n\t * - only-new: only prompt for servers that are not previously explicitly untrusted (default)\n\t * - all-untrusted: prompt for all servers that are not trusted\n\t * - never: don't prompt, fail silently when trying to start an untrusted server\n\t */\n\tpromptType?: 'only-new' | 'all-untrusted' | 'never';\n\t/**\n\t * Automatically trust if changed. This should ONLY be set for afforances that\n\t * ensure the user sees the config before it gets started (e.g. code lenses)\n\t */\n\tautoTrustChanges?: boolean;\n\n\t/** If set, try to launch with debugging when dev mode is configured */\n\tdebug?: boolean;\n\n\t/** If true, throw an error if any user interaction would be required during startup. */\n\terrorOnUserInteraction?: boolean;\n}\n\nexport interface IMcpRegistry {\n\treadonly _serviceBrand: undefined;\n\n\t/** Fired when the user provides more inputs when creating a connection. */\n\treadonly onDidChangeInputs: Event<void>;\n\n\treadonly collections: IObservable<readonly McpCollectionDefinition[]>;\n\treadonly delegates: IObservable<readonly IMcpHostDelegate[]>;\n\t/** Whether there are new collections that can be resolved with a discover() call */\n\treadonly lazyCollectionState: IObservable<{ state: LazyCollectionState; collections: McpCollectionDefinition[] }>;\n\n\t/** Helper function to observe a definition by its reference. */\n\tgetServerDefinition(collectionRef: McpDefinitionReference, definitionRef: McpDefinitionReference): IObservable<{ server: McpServerDefinition | undefined; collection: McpCollectionDefinition | undefined }>;\n\n\t/** Discover new collections, returning newly-discovered ones. */\n\tdiscoverCollections(): Promise<McpCollectionDefinition[]>;\n\n\tregisterDelegate(delegate: IMcpHostDelegate): IDisposable;\n\tregisterCollection(collection: McpCollectionDefinition): IDisposable;\n\n\t/** Resets any saved inputs for the input, or globally. */\n\tclearSavedInputs(scope: StorageScope, inputId?: string): Promise<void>;\n\t/** Edits a previously-saved input. */\n\teditSavedInput(inputId: string, folderData: IWorkspaceFolderData | undefined, configSection: string, target: ConfigurationTarget): Promise<void>;\n\t/** Updates a saved input. */\n\tsetSavedInput(inputId: string, target: ConfigurationTarget, value: string): Promise<void>;\n\t/** Gets saved inputs from storage. */\n\tgetSavedInputs(scope: StorageScope): Promise<{ [id: string]: IResolvedValue }>;\n\t/** Creates a connection for the collection and definition. */\n\tresolveConnection(options: IMcpResolveConnectionOptions): Promise<IMcpServerConnection | undefined>;\n}\n"]}