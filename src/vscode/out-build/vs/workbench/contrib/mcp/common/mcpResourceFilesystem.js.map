{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/mcp/common/mcpResourceFilesystem.ts","vs/workbench/contrib/mcp/common/mcpResourceFilesystem.ts"],"names":[],"mappings":"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","file":"mcpResourceFilesystem.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { sumBy } from '../../../../base/common/arrays.js';\nimport { disposableTimeout } from '../../../../base/common/async.js';\nimport { decodeBase64, VSBuffer } from '../../../../base/common/buffer.js';\nimport { CancellationToken, CancellationTokenPool, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Lazy } from '../../../../base/common/lazy.js';\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { autorun } from '../../../../base/common/observable.js';\nimport { newWriteableStream, ReadableStreamEvents } from '../../../../base/common/stream.js';\nimport { equalsIgnoreCase } from '../../../../base/common/strings.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { createFileSystemProviderError, FileChangeType, FileSystemProviderCapabilities, FileSystemProviderErrorCode, FileType, IFileChange, IFileDeleteOptions, IFileOverwriteOptions, IFileReadStreamOptions, IFileService, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IFileWriteOptions, IStat, IWatchOptions } from '../../../../platform/files/common/files.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IWebContentExtractorService } from '../../../../platform/webContentExtractor/common/webContentExtractor.js';\nimport { IWorkbenchContribution } from '../../../common/contributions.js';\nimport { McpServer } from './mcpServer.js';\nimport { McpServerRequestHandler } from './mcpServerRequestHandler.js';\nimport { IMcpService, McpCapability, McpResourceURI } from './mcpTypes.js';\nimport { canLoadMcpNetworkResourceDirectly } from './mcpTypesUtils.js';\nimport { MCP } from './modelContextProtocol.js';\n\nconst MOMENTARY_CACHE_DURATION = 3000;\n\ninterface IReadData {\n\tcontents: (MCP.TextResourceContents | MCP.BlobResourceContents)[];\n\tresourceURI: URL;\n\tforSameURI: (MCP.TextResourceContents | MCP.BlobResourceContents)[];\n}\n\nexport class McpResourceFilesystem extends Disposable implements IWorkbenchContribution,\n\tIFileSystemProviderWithFileReadWriteCapability,\n\tIFileSystemProviderWithFileAtomicReadCapability,\n\tIFileSystemProviderWithFileReadStreamCapability {\n\t/** Defer getting the MCP service since this is a BlockRestore and no need to make it unnecessarily. */\n\tprivate readonly _mcpServiceLazy = new Lazy(() => this._instantiationService.invokeFunction(a => a.get(IMcpService)));\n\n\t/**\n\t * For many file operations we re-read the resources quickly (e.g. stat\n\t * before reading the file) and would prefer to avoid spamming the MCP\n\t * with multiple reads. This is a very short-duration cache\n\t * to solve that.\n\t */\n\tprivate readonly _momentaryCache = new ResourceMap<{ pool: CancellationTokenPool; promise: Promise<IReadData> }>();\n\n\tprivate get _mcpService() {\n\t\treturn this._mcpServiceLazy.value;\n\t}\n\n\tpublic readonly onDidChangeCapabilities = Event.None;\n\n\tprivate readonly _onDidChangeFile = this._register(new Emitter<readonly IFileChange[]>());\n\tpublic readonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tpublic readonly capabilities: FileSystemProviderCapabilities = FileSystemProviderCapabilities.None\n\t\t| FileSystemProviderCapabilities.Readonly\n\t\t| FileSystemProviderCapabilities.PathCaseSensitive\n\t\t| FileSystemProviderCapabilities.FileReadStream\n\t\t| FileSystemProviderCapabilities.FileAtomicRead\n\t\t| FileSystemProviderCapabilities.FileReadWrite;\n\n\tconstructor(\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@IWebContentExtractorService private readonly _webContentExtractorService: IWebContentExtractorService,\n\t) {\n\t\tsuper();\n\t\tthis._register(this._fileService.registerProvider(McpResourceURI.scheme, this));\n\t}\n\n\t//#region Filesystem API\n\n\tpublic async readFile(resource: URI): Promise<Uint8Array> {\n\t\treturn this._readFile(resource);\n\t}\n\n\tpublic readFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer);\n\n\t\tthis._readFile(resource, token).then(\n\t\t\tdata => {\n\t\t\t\tif (opts.position) {\n\t\t\t\t\tdata = data.slice(opts.position);\n\t\t\t\t}\n\n\t\t\t\tif (opts.length) {\n\t\t\t\t\tdata = data.slice(0, opts.length);\n\t\t\t\t}\n\n\t\t\t\tstream.end(data);\n\t\t\t},\n\t\t\terr => stream.error(err),\n\t\t);\n\n\t\treturn stream;\n\t}\n\n\tpublic watch(uri: URI, _opts: IWatchOptions): IDisposable {\n\t\tconst { resourceURI, server } = this._decodeURI(uri);\n\t\tconst cap = server.capabilities.get();\n\t\tif (cap !== undefined && !(cap & McpCapability.ResourcesSubscribe)) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tserver.start();\n\n\t\tconst store = new DisposableStore();\n\t\tlet watchedOnHandler: McpServerRequestHandler | undefined;\n\t\tconst watchListener = store.add(new MutableDisposable());\n\t\tconst callCts = store.add(new MutableDisposable<CancellationTokenSource>());\n\t\tstore.add(autorun(reader => {\n\t\t\tconst connection = server.connection.read(reader);\n\t\t\tif (!connection) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst handler = connection.handler.read(reader);\n\t\t\tif (!handler || watchedOnHandler === handler) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcallCts.value?.dispose(true);\n\t\t\tcallCts.value = new CancellationTokenSource();\n\t\t\twatchedOnHandler = handler;\n\n\t\t\tconst token = callCts.value.token;\n\t\t\thandler.subscribe({ uri: resourceURI.toString() }, token).then(\n\t\t\t\t() => {\n\t\t\t\t\tif (!token.isCancellationRequested) {\n\t\t\t\t\t\twatchListener.value = handler.onDidUpdateResource(e => {\n\t\t\t\t\t\t\tif (equalsUrlPath(e.params.uri, resourceURI)) {\n\t\t\t\t\t\t\t\tthis._onDidChangeFile.fire([{ resource: uri, type: FileChangeType.UPDATED }]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, err => {\n\t\t\t\t\thandler.logger.warn(`Failed to subscribe to resource changes for ${resourceURI}: ${err}`);\n\t\t\t\t\twatchedOnHandler = undefined;\n\t\t\t\t},\n\t\t\t);\n\t\t}));\n\n\t\treturn store;\n\t}\n\n\tpublic async stat(resource: URI): Promise<IStat> {\n\t\tconst { forSameURI, contents } = await this._readURI(resource);\n\t\tif (!contents.length) {\n\t\t\tthrow createFileSystemProviderError(`File not found`, FileSystemProviderErrorCode.FileNotFound);\n\t\t}\n\n\t\treturn {\n\t\t\tctime: 0,\n\t\t\tmtime: 0,\n\t\t\tsize: sumBy(contents, c => contentToBuffer(c).byteLength),\n\t\t\ttype: forSameURI.length ? FileType.File : FileType.Directory,\n\t\t};\n\t}\n\n\tpublic async readdir(resource: URI): Promise<[string, FileType][]> {\n\t\tconst { forSameURI, contents, resourceURI } = await this._readURI(resource);\n\t\tif (forSameURI.length > 0) {\n\t\t\tthrow createFileSystemProviderError(`File is not a directory`, FileSystemProviderErrorCode.FileNotADirectory);\n\t\t}\n\t\tconst resourcePathParts = resourceURI.pathname.split('/');\n\n\t\tconst output = new Map<string, FileType>();\n\t\tfor (const content of contents) {\n\t\t\tconst contentURI = URI.parse(content.uri);\n\t\t\tconst contentPathParts = contentURI.path.split('/');\n\n\t\t\t// Skip contents that are not in the same directory\n\t\t\tif (contentPathParts.length <= resourcePathParts.length || !resourcePathParts.every((part, index) => equalsIgnoreCase(part, contentPathParts[index]))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// nested resource in a directory, just emit a directory to output\n\t\t\telse if (contentPathParts.length > resourcePathParts.length + 1) {\n\t\t\t\toutput.set(contentPathParts[resourcePathParts.length], FileType.Directory);\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\t// resource in the same directory, emit the file\n\t\t\t\tconst name = contentPathParts[contentPathParts.length - 1];\n\t\t\t\toutput.set(name, contentToBuffer(content).byteLength > 0 ? FileType.File : FileType.Directory);\n\t\t\t}\n\t\t}\n\n\t\treturn [...output];\n\t}\n\n\tpublic mkdir(resource: URI): Promise<void> {\n\t\tthrow createFileSystemProviderError('write is not supported', FileSystemProviderErrorCode.NoPermissions);\n\t}\n\tpublic writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\t\tthrow createFileSystemProviderError('write is not supported', FileSystemProviderErrorCode.NoPermissions);\n\t}\n\tpublic delete(resource: URI, opts: IFileDeleteOptions): Promise<void> {\n\t\tthrow createFileSystemProviderError('delete is not supported', FileSystemProviderErrorCode.NoPermissions);\n\t}\n\tpublic rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\tthrow createFileSystemProviderError('rename is not supported', FileSystemProviderErrorCode.NoPermissions);\n\t}\n\n\t//#endregion\n\n\tprivate async _readFile(resource: URI, token?: CancellationToken): Promise<Uint8Array> {\n\t\tconst { forSameURI, contents } = await this._readURI(resource);\n\n\t\t// MCP does not distinguish between files and directories, and says that\n\t\t// servers should just return multiple when 'reading' a directory.\n\t\tif (!forSameURI.length) {\n\t\t\tif (!contents.length) {\n\t\t\t\tthrow createFileSystemProviderError(`File not found`, FileSystemProviderErrorCode.FileNotFound);\n\t\t\t} else {\n\t\t\t\tthrow createFileSystemProviderError(`File is a directory`, FileSystemProviderErrorCode.FileIsADirectory);\n\t\t\t}\n\t\t}\n\n\t\treturn contentToBuffer(forSameURI[0]);\n\t}\n\n\tprivate _decodeURI(uri: URI) {\n\t\tlet definitionId: string;\n\t\tlet resourceURL: URL;\n\t\ttry {\n\t\t\t({ definitionId, resourceURL } = McpResourceURI.toServer(uri));\n\t\t} catch (e) {\n\t\t\tthrow createFileSystemProviderError(String(e), FileSystemProviderErrorCode.FileNotFound);\n\t\t}\n\n\t\tif (resourceURL.pathname.endsWith('/')) {\n\t\t\tresourceURL.pathname = resourceURL.pathname.slice(0, -1);\n\t\t}\n\n\t\tconst server = this._mcpService.servers.get().find(s => s.definition.id === definitionId);\n\t\tif (!server) {\n\t\t\tthrow createFileSystemProviderError(`MCP server ${definitionId} not found`, FileSystemProviderErrorCode.FileNotFound);\n\t\t}\n\n\t\tconst cap = server.capabilities.get();\n\t\tif (cap !== undefined && !(cap & McpCapability.Resources)) {\n\t\t\tthrow createFileSystemProviderError(`MCP server ${definitionId} does not support resources`, FileSystemProviderErrorCode.FileNotFound);\n\t\t}\n\n\t\treturn { definitionId, resourceURI: resourceURL, server };\n\t}\n\n\tprivate async _readURI(uri: URI, token?: CancellationToken) {\n\t\tconst cached = this._momentaryCache.get(uri);\n\t\tif (cached) {\n\t\t\tcached.pool.add(token || CancellationToken.None);\n\t\t\treturn cached.promise;\n\t\t}\n\n\t\tconst pool = this._store.add(new CancellationTokenPool());\n\t\tpool.add(token || CancellationToken.None);\n\n\t\tconst promise = this._readURIInner(uri, pool.token);\n\t\tthis._momentaryCache.set(uri, { pool, promise });\n\n\t\tconst disposable = this._store.add(disposableTimeout(() => {\n\t\t\tthis._momentaryCache.delete(uri);\n\t\t\tthis._store.delete(disposable);\n\t\t\tthis._store.delete(pool);\n\t\t}, MOMENTARY_CACHE_DURATION));\n\n\t\treturn promise;\n\t}\n\n\tprivate async _readURIInner(uri: URI, token?: CancellationToken): Promise<IReadData> {\n\t\tconst { resourceURI, server } = this._decodeURI(uri);\n\t\tconst matchedServer = this._mcpService.servers.get().find(s => s.definition.id === server.definition.id);\n\n\t\t//check for http/https resources and use web content extractor service to fetch the contents.\n\t\tif (canLoadMcpNetworkResourceDirectly(resourceURI, matchedServer)) {\n\t\t\tconst extractURI = URI.parse(resourceURI.toString());\n\t\t\tconst result = (await this._webContentExtractorService.extract([extractURI], { followRedirects: false })).at(0);\n\t\t\tif (result?.status === 'ok') {\n\t\t\t\treturn {\n\t\t\t\t\tcontents: [{ uri: resourceURI.toString(), text: result.result }],\n\t\t\t\t\tresourceURI,\n\t\t\t\t\tforSameURI: [{ uri: resourceURI.toString(), text: result.result }]\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst res = await McpServer.callOn(server, r => r.readResource({ uri: resourceURI.toString() }, token), token);\n\t\treturn {\n\t\t\tcontents: res.contents,\n\t\t\tresourceURI,\n\t\t\tforSameURI: res.contents.filter(c => equalsUrlPath(c.uri, resourceURI))\n\t\t};\n\t}\n}\n\nfunction equalsUrlPath(a: string, b: URL): boolean {\n\t// MCP doesn't specify either way, but underlying systems may can be case-sensitive.\n\t// It's better to treat case-sensitive paths as case-insensitive than vise-versa.\n\treturn equalsIgnoreCase(new URL(a).pathname, b.pathname);\n}\n\nfunction contentToBuffer(content: MCP.TextResourceContents | MCP.BlobResourceContents): Uint8Array {\n\tif ('text' in content) {\n\t\treturn VSBuffer.fromString(content.text).buffer;\n\t} else if ('blob' in content) {\n\t\treturn decodeBase64(content.blob).buffer;\n\t} else {\n\t\tthrow createFileSystemProviderError('Unknown content type', FileSystemProviderErrorCode.Unknown);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { sumBy } from '../../../../base/common/arrays.js';\nimport { disposableTimeout } from '../../../../base/common/async.js';\nimport { decodeBase64, VSBuffer } from '../../../../base/common/buffer.js';\nimport { CancellationToken, CancellationTokenPool, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Lazy } from '../../../../base/common/lazy.js';\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { autorun } from '../../../../base/common/observable.js';\nimport { newWriteableStream, ReadableStreamEvents } from '../../../../base/common/stream.js';\nimport { equalsIgnoreCase } from '../../../../base/common/strings.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { createFileSystemProviderError, FileChangeType, FileSystemProviderCapabilities, FileSystemProviderErrorCode, FileType, IFileChange, IFileDeleteOptions, IFileOverwriteOptions, IFileReadStreamOptions, IFileService, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IFileWriteOptions, IStat, IWatchOptions } from '../../../../platform/files/common/files.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IWebContentExtractorService } from '../../../../platform/webContentExtractor/common/webContentExtractor.js';\nimport { IWorkbenchContribution } from '../../../common/contributions.js';\nimport { McpServer } from './mcpServer.js';\nimport { McpServerRequestHandler } from './mcpServerRequestHandler.js';\nimport { IMcpService, McpCapability, McpResourceURI } from './mcpTypes.js';\nimport { canLoadMcpNetworkResourceDirectly } from './mcpTypesUtils.js';\nimport { MCP } from './modelContextProtocol.js';\n\nconst MOMENTARY_CACHE_DURATION = 3000;\n\ninterface IReadData {\n\tcontents: (MCP.TextResourceContents | MCP.BlobResourceContents)[];\n\tresourceURI: URL;\n\tforSameURI: (MCP.TextResourceContents | MCP.BlobResourceContents)[];\n}\n\nexport class McpResourceFilesystem extends Disposable implements IWorkbenchContribution,\n\tIFileSystemProviderWithFileReadWriteCapability,\n\tIFileSystemProviderWithFileAtomicReadCapability,\n\tIFileSystemProviderWithFileReadStreamCapability {\n\t/** Defer getting the MCP service since this is a BlockRestore and no need to make it unnecessarily. */\n\tprivate readonly _mcpServiceLazy = new Lazy(() => this._instantiationService.invokeFunction(a => a.get(IMcpService)));\n\n\t/**\n\t * For many file operations we re-read the resources quickly (e.g. stat\n\t * before reading the file) and would prefer to avoid spamming the MCP\n\t * with multiple reads. This is a very short-duration cache\n\t * to solve that.\n\t */\n\tprivate readonly _momentaryCache = new ResourceMap<{ pool: CancellationTokenPool; promise: Promise<IReadData> }>();\n\n\tprivate get _mcpService() {\n\t\treturn this._mcpServiceLazy.value;\n\t}\n\n\tpublic readonly onDidChangeCapabilities = Event.None;\n\n\tprivate readonly _onDidChangeFile = this._register(new Emitter<readonly IFileChange[]>());\n\tpublic readonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tpublic readonly capabilities: FileSystemProviderCapabilities = FileSystemProviderCapabilities.None\n\t\t| FileSystemProviderCapabilities.Readonly\n\t\t| FileSystemProviderCapabilities.PathCaseSensitive\n\t\t| FileSystemProviderCapabilities.FileReadStream\n\t\t| FileSystemProviderCapabilities.FileAtomicRead\n\t\t| FileSystemProviderCapabilities.FileReadWrite;\n\n\tconstructor(\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@IWebContentExtractorService private readonly _webContentExtractorService: IWebContentExtractorService,\n\t) {\n\t\tsuper();\n\t\tthis._register(this._fileService.registerProvider(McpResourceURI.scheme, this));\n\t}\n\n\t//#region Filesystem API\n\n\tpublic async readFile(resource: URI): Promise<Uint8Array> {\n\t\treturn this._readFile(resource);\n\t}\n\n\tpublic readFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer);\n\n\t\tthis._readFile(resource, token).then(\n\t\t\tdata => {\n\t\t\t\tif (opts.position) {\n\t\t\t\t\tdata = data.slice(opts.position);\n\t\t\t\t}\n\n\t\t\t\tif (opts.length) {\n\t\t\t\t\tdata = data.slice(0, opts.length);\n\t\t\t\t}\n\n\t\t\t\tstream.end(data);\n\t\t\t},\n\t\t\terr => stream.error(err),\n\t\t);\n\n\t\treturn stream;\n\t}\n\n\tpublic watch(uri: URI, _opts: IWatchOptions): IDisposable {\n\t\tconst { resourceURI, server } = this._decodeURI(uri);\n\t\tconst cap = server.capabilities.get();\n\t\tif (cap !== undefined && !(cap & McpCapability.ResourcesSubscribe)) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tserver.start();\n\n\t\tconst store = new DisposableStore();\n\t\tlet watchedOnHandler: McpServerRequestHandler | undefined;\n\t\tconst watchListener = store.add(new MutableDisposable());\n\t\tconst callCts = store.add(new MutableDisposable<CancellationTokenSource>());\n\t\tstore.add(autorun(reader => {\n\t\t\tconst connection = server.connection.read(reader);\n\t\t\tif (!connection) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst handler = connection.handler.read(reader);\n\t\t\tif (!handler || watchedOnHandler === handler) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcallCts.value?.dispose(true);\n\t\t\tcallCts.value = new CancellationTokenSource();\n\t\t\twatchedOnHandler = handler;\n\n\t\t\tconst token = callCts.value.token;\n\t\t\thandler.subscribe({ uri: resourceURI.toString() }, token).then(\n\t\t\t\t() => {\n\t\t\t\t\tif (!token.isCancellationRequested) {\n\t\t\t\t\t\twatchListener.value = handler.onDidUpdateResource(e => {\n\t\t\t\t\t\t\tif (equalsUrlPath(e.params.uri, resourceURI)) {\n\t\t\t\t\t\t\t\tthis._onDidChangeFile.fire([{ resource: uri, type: FileChangeType.UPDATED }]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, err => {\n\t\t\t\t\thandler.logger.warn(`Failed to subscribe to resource changes for ${resourceURI}: ${err}`);\n\t\t\t\t\twatchedOnHandler = undefined;\n\t\t\t\t},\n\t\t\t);\n\t\t}));\n\n\t\treturn store;\n\t}\n\n\tpublic async stat(resource: URI): Promise<IStat> {\n\t\tconst { forSameURI, contents } = await this._readURI(resource);\n\t\tif (!contents.length) {\n\t\t\tthrow createFileSystemProviderError(`File not found`, FileSystemProviderErrorCode.FileNotFound);\n\t\t}\n\n\t\treturn {\n\t\t\tctime: 0,\n\t\t\tmtime: 0,\n\t\t\tsize: sumBy(contents, c => contentToBuffer(c).byteLength),\n\t\t\ttype: forSameURI.length ? FileType.File : FileType.Directory,\n\t\t};\n\t}\n\n\tpublic async readdir(resource: URI): Promise<[string, FileType][]> {\n\t\tconst { forSameURI, contents, resourceURI } = await this._readURI(resource);\n\t\tif (forSameURI.length > 0) {\n\t\t\tthrow createFileSystemProviderError(`File is not a directory`, FileSystemProviderErrorCode.FileNotADirectory);\n\t\t}\n\t\tconst resourcePathParts = resourceURI.pathname.split('/');\n\n\t\tconst output = new Map<string, FileType>();\n\t\tfor (const content of contents) {\n\t\t\tconst contentURI = URI.parse(content.uri);\n\t\t\tconst contentPathParts = contentURI.path.split('/');\n\n\t\t\t// Skip contents that are not in the same directory\n\t\t\tif (contentPathParts.length <= resourcePathParts.length || !resourcePathParts.every((part, index) => equalsIgnoreCase(part, contentPathParts[index]))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// nested resource in a directory, just emit a directory to output\n\t\t\telse if (contentPathParts.length > resourcePathParts.length + 1) {\n\t\t\t\toutput.set(contentPathParts[resourcePathParts.length], FileType.Directory);\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\t// resource in the same directory, emit the file\n\t\t\t\tconst name = contentPathParts[contentPathParts.length - 1];\n\t\t\t\toutput.set(name, contentToBuffer(content).byteLength > 0 ? FileType.File : FileType.Directory);\n\t\t\t}\n\t\t}\n\n\t\treturn [...output];\n\t}\n\n\tpublic mkdir(resource: URI): Promise<void> {\n\t\tthrow createFileSystemProviderError('write is not supported', FileSystemProviderErrorCode.NoPermissions);\n\t}\n\tpublic writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\t\tthrow createFileSystemProviderError('write is not supported', FileSystemProviderErrorCode.NoPermissions);\n\t}\n\tpublic delete(resource: URI, opts: IFileDeleteOptions): Promise<void> {\n\t\tthrow createFileSystemProviderError('delete is not supported', FileSystemProviderErrorCode.NoPermissions);\n\t}\n\tpublic rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\tthrow createFileSystemProviderError('rename is not supported', FileSystemProviderErrorCode.NoPermissions);\n\t}\n\n\t//#endregion\n\n\tprivate async _readFile(resource: URI, token?: CancellationToken): Promise<Uint8Array> {\n\t\tconst { forSameURI, contents } = await this._readURI(resource);\n\n\t\t// MCP does not distinguish between files and directories, and says that\n\t\t// servers should just return multiple when 'reading' a directory.\n\t\tif (!forSameURI.length) {\n\t\t\tif (!contents.length) {\n\t\t\t\tthrow createFileSystemProviderError(`File not found`, FileSystemProviderErrorCode.FileNotFound);\n\t\t\t} else {\n\t\t\t\tthrow createFileSystemProviderError(`File is a directory`, FileSystemProviderErrorCode.FileIsADirectory);\n\t\t\t}\n\t\t}\n\n\t\treturn contentToBuffer(forSameURI[0]);\n\t}\n\n\tprivate _decodeURI(uri: URI) {\n\t\tlet definitionId: string;\n\t\tlet resourceURL: URL;\n\t\ttry {\n\t\t\t({ definitionId, resourceURL } = McpResourceURI.toServer(uri));\n\t\t} catch (e) {\n\t\t\tthrow createFileSystemProviderError(String(e), FileSystemProviderErrorCode.FileNotFound);\n\t\t}\n\n\t\tif (resourceURL.pathname.endsWith('/')) {\n\t\t\tresourceURL.pathname = resourceURL.pathname.slice(0, -1);\n\t\t}\n\n\t\tconst server = this._mcpService.servers.get().find(s => s.definition.id === definitionId);\n\t\tif (!server) {\n\t\t\tthrow createFileSystemProviderError(`MCP server ${definitionId} not found`, FileSystemProviderErrorCode.FileNotFound);\n\t\t}\n\n\t\tconst cap = server.capabilities.get();\n\t\tif (cap !== undefined && !(cap & McpCapability.Resources)) {\n\t\t\tthrow createFileSystemProviderError(`MCP server ${definitionId} does not support resources`, FileSystemProviderErrorCode.FileNotFound);\n\t\t}\n\n\t\treturn { definitionId, resourceURI: resourceURL, server };\n\t}\n\n\tprivate async _readURI(uri: URI, token?: CancellationToken) {\n\t\tconst cached = this._momentaryCache.get(uri);\n\t\tif (cached) {\n\t\t\tcached.pool.add(token || CancellationToken.None);\n\t\t\treturn cached.promise;\n\t\t}\n\n\t\tconst pool = this._store.add(new CancellationTokenPool());\n\t\tpool.add(token || CancellationToken.None);\n\n\t\tconst promise = this._readURIInner(uri, pool.token);\n\t\tthis._momentaryCache.set(uri, { pool, promise });\n\n\t\tconst disposable = this._store.add(disposableTimeout(() => {\n\t\t\tthis._momentaryCache.delete(uri);\n\t\t\tthis._store.delete(disposable);\n\t\t\tthis._store.delete(pool);\n\t\t}, MOMENTARY_CACHE_DURATION));\n\n\t\treturn promise;\n\t}\n\n\tprivate async _readURIInner(uri: URI, token?: CancellationToken): Promise<IReadData> {\n\t\tconst { resourceURI, server } = this._decodeURI(uri);\n\t\tconst matchedServer = this._mcpService.servers.get().find(s => s.definition.id === server.definition.id);\n\n\t\t//check for http/https resources and use web content extractor service to fetch the contents.\n\t\tif (canLoadMcpNetworkResourceDirectly(resourceURI, matchedServer)) {\n\t\t\tconst extractURI = URI.parse(resourceURI.toString());\n\t\t\tconst result = (await this._webContentExtractorService.extract([extractURI], { followRedirects: false })).at(0);\n\t\t\tif (result?.status === 'ok') {\n\t\t\t\treturn {\n\t\t\t\t\tcontents: [{ uri: resourceURI.toString(), text: result.result }],\n\t\t\t\t\tresourceURI,\n\t\t\t\t\tforSameURI: [{ uri: resourceURI.toString(), text: result.result }]\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst res = await McpServer.callOn(server, r => r.readResource({ uri: resourceURI.toString() }, token), token);\n\t\treturn {\n\t\t\tcontents: res.contents,\n\t\t\tresourceURI,\n\t\t\tforSameURI: res.contents.filter(c => equalsUrlPath(c.uri, resourceURI))\n\t\t};\n\t}\n}\n\nfunction equalsUrlPath(a: string, b: URL): boolean {\n\t// MCP doesn't specify either way, but underlying systems may can be case-sensitive.\n\t// It's better to treat case-sensitive paths as case-insensitive than vise-versa.\n\treturn equalsIgnoreCase(new URL(a).pathname, b.pathname);\n}\n\nfunction contentToBuffer(content: MCP.TextResourceContents | MCP.BlobResourceContents): Uint8Array {\n\tif ('text' in content) {\n\t\treturn VSBuffer.fromString(content.text).buffer;\n\t} else if ('blob' in content) {\n\t\treturn decodeBase64(content.blob).buffer;\n\t} else {\n\t\tthrow createFileSystemProviderError('Unknown content type', FileSystemProviderErrorCode.Unknown);\n\t}\n}\n"]}