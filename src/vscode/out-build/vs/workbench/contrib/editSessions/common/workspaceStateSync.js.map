{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/contrib/editSessions/common/workspaceStateSync.ts","vs/workbench/contrib/editSessions/common/workspaceStateSync.ts"],"names":[],"mappings":"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","file":"workspaceStateSync.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { IStringDictionary } from '../../../../base/common/collections.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { parse, stringify } from '../../../../base/common/marshalling.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IEnvironmentService } from '../../../../platform/environment/common/environment.js';\nimport { IFileService } from '../../../../platform/files/common/files.js';\nimport { IStorageEntry, IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IUserDataProfile } from '../../../../platform/userDataProfile/common/userDataProfile.js';\nimport { AbstractSynchroniser, IAcceptResult, IMergeResult, IResourcePreview, ISyncResourcePreview } from '../../../../platform/userDataSync/common/abstractSynchronizer.js';\nimport { IRemoteUserData, IResourceRefHandle, IUserDataSyncLocalStoreService, IUserDataSyncConfiguration, IUserDataSyncEnablementService, IUserDataSyncLogService, IUserDataSyncStoreService, IUserDataSynchroniser, IWorkspaceState, SyncResource, IUserDataSyncResourcePreview } from '../../../../platform/userDataSync/common/userDataSync.js';\nimport { EditSession, IEditSessionsStorageService } from './editSessions.js';\nimport { IWorkspaceIdentityService } from '../../../services/workspaces/common/workspaceIdentityService.js';\n\n\nclass NullBackupStoreService implements IUserDataSyncLocalStoreService {\n\t_serviceBrand: undefined;\n\tasync writeResource(): Promise<void> {\n\t\treturn;\n\t}\n\tasync getAllResourceRefs(): Promise<IResourceRefHandle[]> {\n\t\treturn [];\n\t}\n\tasync resolveResourceContent(): Promise<string | null> {\n\t\treturn null;\n\t}\n\n}\n\nclass NullEnablementService implements IUserDataSyncEnablementService {\n\t_serviceBrand: undefined;\n\n\tprivate _onDidChangeEnablement = new Emitter<boolean>();\n\treadonly onDidChangeEnablement: Event<boolean> = this._onDidChangeEnablement.event;\n\n\tprivate _onDidChangeResourceEnablement = new Emitter<[SyncResource, boolean]>();\n\treadonly onDidChangeResourceEnablement: Event<[SyncResource, boolean]> = this._onDidChangeResourceEnablement.event;\n\n\tisEnabled(): boolean { return true; }\n\tcanToggleEnablement(): boolean { return true; }\n\tsetEnablement(_enabled: boolean): void { }\n\tisResourceEnabled(_resource: SyncResource): boolean { return true; }\n\tisResourceEnablementConfigured(_resource: SyncResource): boolean { return false; }\n\tsetResourceEnablement(_resource: SyncResource, _enabled: boolean): void { }\n\tgetResourceSyncStateVersion(_resource: SyncResource): string | undefined { return undefined; }\n\n}\n\nexport class WorkspaceStateSynchroniser extends AbstractSynchroniser implements IUserDataSynchroniser {\n\tprotected override version: number = 1;\n\n\tconstructor(\n\t\tprofile: IUserDataProfile,\n\t\tcollection: string | undefined,\n\t\tuserDataSyncStoreService: IUserDataSyncStoreService,\n\t\tlogService: IUserDataSyncLogService,\n\t\t@IFileService fileService: IFileService,\n\t\t@IEnvironmentService environmentService: IEnvironmentService,\n\t\t@ITelemetryService telemetryService: ITelemetryService,\n\t\t@IConfigurationService configurationService: IConfigurationService,\n\t\t@IStorageService storageService: IStorageService,\n\t\t@IUriIdentityService uriIdentityService: IUriIdentityService,\n\t\t@IWorkspaceIdentityService private readonly workspaceIdentityService: IWorkspaceIdentityService,\n\t\t@IEditSessionsStorageService private readonly editSessionsStorageService: IEditSessionsStorageService,\n\t) {\n\t\tconst userDataSyncLocalStoreService = new NullBackupStoreService();\n\t\tconst userDataSyncEnablementService = new NullEnablementService();\n\t\tsuper({ syncResource: SyncResource.WorkspaceState, profile }, collection, fileService, environmentService, storageService, userDataSyncStoreService, userDataSyncLocalStoreService, userDataSyncEnablementService, telemetryService, logService, configurationService, uriIdentityService);\n\t}\n\n\toverride async sync(): Promise<IUserDataSyncResourcePreview | null> {\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tconst folders = await this.workspaceIdentityService.getWorkspaceStateFolders(cancellationTokenSource.token);\n\t\tif (!folders.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Ensure we have latest state by sending out onWillSaveState event\n\t\tawait this.storageService.flush();\n\n\t\tconst keys = this.storageService.keys(StorageScope.WORKSPACE, StorageTarget.USER);\n\t\tif (!keys.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst contributedData: IStringDictionary<string> = {};\n\t\tkeys.forEach((key) => {\n\t\t\tconst data = this.storageService.get(key, StorageScope.WORKSPACE);\n\t\t\tif (data) {\n\t\t\t\tcontributedData[key] = data;\n\t\t\t}\n\t\t});\n\n\t\tconst content: IWorkspaceState = { folders, storage: contributedData, version: this.version };\n\t\tawait this.editSessionsStorageService.write('workspaceState', stringify(content));\n\t\treturn null;\n\t}\n\n\toverride async apply(): Promise<ISyncResourcePreview | null> {\n\t\tconst payload = this.editSessionsStorageService.lastReadResources.get('editSessions')?.content;\n\t\tconst workspaceStateId = payload ? (JSON.parse(payload) as EditSession).workspaceStateId : undefined;\n\n\t\tconst resource = await this.editSessionsStorageService.read('workspaceState', workspaceStateId);\n\t\tif (!resource) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst remoteWorkspaceState: IWorkspaceState = parse(resource.content);\n\t\tif (!remoteWorkspaceState) {\n\t\t\tthis.logService.info('Skipping initializing workspace state because remote workspace state does not exist.');\n\t\t\treturn null;\n\t\t}\n\n\t\t// Evaluate whether storage is applicable for current workspace\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tconst replaceUris = await this.workspaceIdentityService.matches(remoteWorkspaceState.folders, cancellationTokenSource.token);\n\t\tif (!replaceUris) {\n\t\t\tthis.logService.info('Skipping initializing workspace state because remote workspace state does not match current workspace.');\n\t\t\treturn null;\n\t\t}\n\n\t\tconst storage: IStringDictionary<any> = {};\n\t\tfor (const key of Object.keys(remoteWorkspaceState.storage)) {\n\t\t\tstorage[key] = remoteWorkspaceState.storage[key];\n\t\t}\n\n\t\tif (Object.keys(storage).length) {\n\t\t\t// Initialize storage with remote storage\n\t\t\tconst storageEntries: Array<IStorageEntry> = [];\n\t\t\tfor (const key of Object.keys(storage)) {\n\t\t\t\t// Deserialize the stored state\n\t\t\t\ttry {\n\t\t\t\t\tconst value = parse(storage[key]);\n\t\t\t\t\t// Run URI conversion on the stored state\n\t\t\t\t\treplaceUris(value);\n\t\t\t\t\tstorageEntries.push({ key, value, scope: StorageScope.WORKSPACE, target: StorageTarget.USER });\n\t\t\t\t} catch {\n\t\t\t\t\tstorageEntries.push({ key, value: storage[key], scope: StorageScope.WORKSPACE, target: StorageTarget.USER });\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.storageService.storeAll(storageEntries, true);\n\t\t}\n\n\t\tthis.editSessionsStorageService.delete('workspaceState', resource.ref);\n\t\treturn null;\n\t}\n\n\t// TODO@joyceerhl implement AbstractSynchronizer in full\n\tprotected override applyResult(remoteUserData: IRemoteUserData, lastSyncUserData: IRemoteUserData | null, result: [IResourcePreview, IAcceptResult][], force: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tprotected override async generateSyncPreview(remoteUserData: IRemoteUserData, lastSyncUserData: IRemoteUserData | null, isRemoteDataFromCurrentMachine: boolean, userDataSyncConfiguration: IUserDataSyncConfiguration, token: CancellationToken): Promise<IResourcePreview[]> {\n\t\treturn [];\n\t}\n\tprotected override getMergeResult(resourcePreview: IResourcePreview, token: CancellationToken): Promise<IMergeResult> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tprotected override getAcceptResult(resourcePreview: IResourcePreview, resource: URI, content: string | null | undefined, token: CancellationToken): Promise<IAcceptResult> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tprotected override async hasRemoteChanged(lastSyncUserData: IRemoteUserData): Promise<boolean> {\n\t\treturn true;\n\t}\n\toverride async hasLocalData(): Promise<boolean> {\n\t\treturn false;\n\t}\n\toverride async resolveContent(uri: URI): Promise<string | null> {\n\t\treturn null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { IStringDictionary } from '../../../../base/common/collections.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { parse, stringify } from '../../../../base/common/marshalling.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IEnvironmentService } from '../../../../platform/environment/common/environment.js';\nimport { IFileService } from '../../../../platform/files/common/files.js';\nimport { IStorageEntry, IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IUserDataProfile } from '../../../../platform/userDataProfile/common/userDataProfile.js';\nimport { AbstractSynchroniser, IAcceptResult, IMergeResult, IResourcePreview, ISyncResourcePreview } from '../../../../platform/userDataSync/common/abstractSynchronizer.js';\nimport { IRemoteUserData, IResourceRefHandle, IUserDataSyncLocalStoreService, IUserDataSyncConfiguration, IUserDataSyncEnablementService, IUserDataSyncLogService, IUserDataSyncStoreService, IUserDataSynchroniser, IWorkspaceState, SyncResource, IUserDataSyncResourcePreview } from '../../../../platform/userDataSync/common/userDataSync.js';\nimport { EditSession, IEditSessionsStorageService } from './editSessions.js';\nimport { IWorkspaceIdentityService } from '../../../services/workspaces/common/workspaceIdentityService.js';\n\n\nclass NullBackupStoreService implements IUserDataSyncLocalStoreService {\n\t_serviceBrand: undefined;\n\tasync writeResource(): Promise<void> {\n\t\treturn;\n\t}\n\tasync getAllResourceRefs(): Promise<IResourceRefHandle[]> {\n\t\treturn [];\n\t}\n\tasync resolveResourceContent(): Promise<string | null> {\n\t\treturn null;\n\t}\n\n}\n\nclass NullEnablementService implements IUserDataSyncEnablementService {\n\t_serviceBrand: undefined;\n\n\tprivate _onDidChangeEnablement = new Emitter<boolean>();\n\treadonly onDidChangeEnablement: Event<boolean> = this._onDidChangeEnablement.event;\n\n\tprivate _onDidChangeResourceEnablement = new Emitter<[SyncResource, boolean]>();\n\treadonly onDidChangeResourceEnablement: Event<[SyncResource, boolean]> = this._onDidChangeResourceEnablement.event;\n\n\tisEnabled(): boolean { return true; }\n\tcanToggleEnablement(): boolean { return true; }\n\tsetEnablement(_enabled: boolean): void { }\n\tisResourceEnabled(_resource: SyncResource): boolean { return true; }\n\tisResourceEnablementConfigured(_resource: SyncResource): boolean { return false; }\n\tsetResourceEnablement(_resource: SyncResource, _enabled: boolean): void { }\n\tgetResourceSyncStateVersion(_resource: SyncResource): string | undefined { return undefined; }\n\n}\n\nexport class WorkspaceStateSynchroniser extends AbstractSynchroniser implements IUserDataSynchroniser {\n\tprotected override version: number = 1;\n\n\tconstructor(\n\t\tprofile: IUserDataProfile,\n\t\tcollection: string | undefined,\n\t\tuserDataSyncStoreService: IUserDataSyncStoreService,\n\t\tlogService: IUserDataSyncLogService,\n\t\t@IFileService fileService: IFileService,\n\t\t@IEnvironmentService environmentService: IEnvironmentService,\n\t\t@ITelemetryService telemetryService: ITelemetryService,\n\t\t@IConfigurationService configurationService: IConfigurationService,\n\t\t@IStorageService storageService: IStorageService,\n\t\t@IUriIdentityService uriIdentityService: IUriIdentityService,\n\t\t@IWorkspaceIdentityService private readonly workspaceIdentityService: IWorkspaceIdentityService,\n\t\t@IEditSessionsStorageService private readonly editSessionsStorageService: IEditSessionsStorageService,\n\t) {\n\t\tconst userDataSyncLocalStoreService = new NullBackupStoreService();\n\t\tconst userDataSyncEnablementService = new NullEnablementService();\n\t\tsuper({ syncResource: SyncResource.WorkspaceState, profile }, collection, fileService, environmentService, storageService, userDataSyncStoreService, userDataSyncLocalStoreService, userDataSyncEnablementService, telemetryService, logService, configurationService, uriIdentityService);\n\t}\n\n\toverride async sync(): Promise<IUserDataSyncResourcePreview | null> {\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tconst folders = await this.workspaceIdentityService.getWorkspaceStateFolders(cancellationTokenSource.token);\n\t\tif (!folders.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Ensure we have latest state by sending out onWillSaveState event\n\t\tawait this.storageService.flush();\n\n\t\tconst keys = this.storageService.keys(StorageScope.WORKSPACE, StorageTarget.USER);\n\t\tif (!keys.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst contributedData: IStringDictionary<string> = {};\n\t\tkeys.forEach((key) => {\n\t\t\tconst data = this.storageService.get(key, StorageScope.WORKSPACE);\n\t\t\tif (data) {\n\t\t\t\tcontributedData[key] = data;\n\t\t\t}\n\t\t});\n\n\t\tconst content: IWorkspaceState = { folders, storage: contributedData, version: this.version };\n\t\tawait this.editSessionsStorageService.write('workspaceState', stringify(content));\n\t\treturn null;\n\t}\n\n\toverride async apply(): Promise<ISyncResourcePreview | null> {\n\t\tconst payload = this.editSessionsStorageService.lastReadResources.get('editSessions')?.content;\n\t\tconst workspaceStateId = payload ? (JSON.parse(payload) as EditSession).workspaceStateId : undefined;\n\n\t\tconst resource = await this.editSessionsStorageService.read('workspaceState', workspaceStateId);\n\t\tif (!resource) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst remoteWorkspaceState: IWorkspaceState = parse(resource.content);\n\t\tif (!remoteWorkspaceState) {\n\t\t\tthis.logService.info('Skipping initializing workspace state because remote workspace state does not exist.');\n\t\t\treturn null;\n\t\t}\n\n\t\t// Evaluate whether storage is applicable for current workspace\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tconst replaceUris = await this.workspaceIdentityService.matches(remoteWorkspaceState.folders, cancellationTokenSource.token);\n\t\tif (!replaceUris) {\n\t\t\tthis.logService.info('Skipping initializing workspace state because remote workspace state does not match current workspace.');\n\t\t\treturn null;\n\t\t}\n\n\t\tconst storage: IStringDictionary<any> = {};\n\t\tfor (const key of Object.keys(remoteWorkspaceState.storage)) {\n\t\t\tstorage[key] = remoteWorkspaceState.storage[key];\n\t\t}\n\n\t\tif (Object.keys(storage).length) {\n\t\t\t// Initialize storage with remote storage\n\t\t\tconst storageEntries: Array<IStorageEntry> = [];\n\t\t\tfor (const key of Object.keys(storage)) {\n\t\t\t\t// Deserialize the stored state\n\t\t\t\ttry {\n\t\t\t\t\tconst value = parse(storage[key]);\n\t\t\t\t\t// Run URI conversion on the stored state\n\t\t\t\t\treplaceUris(value);\n\t\t\t\t\tstorageEntries.push({ key, value, scope: StorageScope.WORKSPACE, target: StorageTarget.USER });\n\t\t\t\t} catch {\n\t\t\t\t\tstorageEntries.push({ key, value: storage[key], scope: StorageScope.WORKSPACE, target: StorageTarget.USER });\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.storageService.storeAll(storageEntries, true);\n\t\t}\n\n\t\tthis.editSessionsStorageService.delete('workspaceState', resource.ref);\n\t\treturn null;\n\t}\n\n\t// TODO@joyceerhl implement AbstractSynchronizer in full\n\tprotected override applyResult(remoteUserData: IRemoteUserData, lastSyncUserData: IRemoteUserData | null, result: [IResourcePreview, IAcceptResult][], force: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tprotected override async generateSyncPreview(remoteUserData: IRemoteUserData, lastSyncUserData: IRemoteUserData | null, isRemoteDataFromCurrentMachine: boolean, userDataSyncConfiguration: IUserDataSyncConfiguration, token: CancellationToken): Promise<IResourcePreview[]> {\n\t\treturn [];\n\t}\n\tprotected override getMergeResult(resourcePreview: IResourcePreview, token: CancellationToken): Promise<IMergeResult> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tprotected override getAcceptResult(resourcePreview: IResourcePreview, resource: URI, content: string | null | undefined, token: CancellationToken): Promise<IAcceptResult> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\tprotected override async hasRemoteChanged(lastSyncUserData: IRemoteUserData): Promise<boolean> {\n\t\treturn true;\n\t}\n\toverride async hasLocalData(): Promise<boolean> {\n\t\treturn false;\n\t}\n\toverride async resolveContent(uri: URI): Promise<string | null> {\n\t\treturn null;\n\t}\n}\n"]}