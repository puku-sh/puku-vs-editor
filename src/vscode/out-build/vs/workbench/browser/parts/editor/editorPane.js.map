{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/browser/parts/editor/editorPane.ts","vs/workbench/browser/parts/editor/editorPane.ts"],"names":[],"mappings":"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","file":"editorPane.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Composite } from '../../composite.js';\nimport { IEditorPane, GroupIdentifier, IEditorMemento, IEditorOpenContext, isEditorInput } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IEditorGroup, IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { LRUCache, Touch } from '../../../../base/common/map.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { isEmptyObject } from '../../../../base/common/types.js';\nimport { DEFAULT_EDITOR_MIN_DIMENSIONS, DEFAULT_EDITOR_MAX_DIMENSIONS } from './editor.js';\nimport { joinPath, IExtUri, isEqual } from '../../../../base/common/resources.js';\nimport { indexOfPath } from '../../../../base/common/extpath.js';\nimport { Disposable, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IEditorOptions } from '../../../../platform/editor/common/editor.js';\nimport { ITextResourceConfigurationChangeEvent, ITextResourceConfigurationService } from '../../../../editor/common/services/textResourceConfiguration.js';\nimport { IBoundarySashes } from '../../../../base/browser/ui/sash/sash.js';\nimport { getWindowById } from '../../../../base/browser/dom.js';\n\n/**\n * The base class of editors in the workbench. Editors register themselves for specific editor inputs.\n * Editors are layed out in the editor part of the workbench in editor groups. Multiple editors can be\n * open at the same time. Each editor has a minimized representation that is good enough to provide some\n * information about the state of the editor data.\n *\n * The workbench will keep an editor alive after it has been created and show/hide it based on\n * user interaction. The lifecycle of a editor goes in the order:\n *\n * - `createEditor()`\n * - `setEditorVisible()`\n * - `layout()`\n * - `setInput()`\n * - `focus()`\n * - `dispose()`: when the editor group the editor is in closes\n *\n * During use of the workbench, a editor will often receive a `clearInput()`, `setEditorVisible()`, `layout()` and\n * `focus()` calls, but only one `create()` and `dispose()` call.\n *\n * This class is only intended to be subclassed and not instantiated.\n */\nexport abstract class EditorPane<MementoType extends object = object> extends Composite<MementoType> implements IEditorPane {\n\n\t//#region Events\n\n\treadonly onDidChangeSizeConstraints = Event.None;\n\n\tprotected readonly _onDidChangeControl = this._register(new Emitter<void>());\n\treadonly onDidChangeControl = this._onDidChangeControl.event;\n\n\t//#endregion\n\n\tprivate static readonly EDITOR_MEMENTOS = new Map<string, EditorMemento<unknown>>();\n\n\tget minimumWidth() { return DEFAULT_EDITOR_MIN_DIMENSIONS.width; }\n\tget maximumWidth() { return DEFAULT_EDITOR_MAX_DIMENSIONS.width; }\n\tget minimumHeight() { return DEFAULT_EDITOR_MIN_DIMENSIONS.height; }\n\tget maximumHeight() { return DEFAULT_EDITOR_MAX_DIMENSIONS.height; }\n\n\tprotected _input: EditorInput | undefined;\n\tget input(): EditorInput | undefined { return this._input; }\n\n\tprotected _options: IEditorOptions | undefined;\n\tget options(): IEditorOptions | undefined { return this._options; }\n\n\tget window() { return getWindowById(this.group.windowId, true).window; }\n\n\t/**\n\t * Should be overridden by editors that have their own ScopedContextKeyService\n\t */\n\tget scopedContextKeyService(): IContextKeyService | undefined { return undefined; }\n\n\tconstructor(\n\t\tid: string,\n\t\treadonly group: IEditorGroup,\n\t\ttelemetryService: ITelemetryService,\n\t\tthemeService: IThemeService,\n\t\tstorageService: IStorageService\n\t) {\n\t\tsuper(id, telemetryService, themeService, storageService);\n\t}\n\n\toverride create(parent: HTMLElement): void {\n\t\tsuper.create(parent);\n\n\t\t// Create Editor\n\t\tthis.createEditor(parent);\n\t}\n\n\t/**\n\t * Called to create the editor in the parent HTMLElement. Subclasses implement\n\t * this method to construct the editor widget.\n\t */\n\tprotected abstract createEditor(parent: HTMLElement): void;\n\n\t/**\n\t * Note: Clients should not call this method, the workbench calls this\n\t * method. Calling it otherwise may result in unexpected behavior.\n\t *\n\t * Sets the given input with the options to the editor. The input is guaranteed\n\t * to be different from the previous input that was set using the `input.matches()`\n\t * method.\n\t *\n\t * The provided context gives more information around how the editor was opened.\n\t *\n\t * The provided cancellation token should be used to test if the operation\n\t * was cancelled.\n\t */\n\tasync setInput(input: EditorInput, options: IEditorOptions | undefined, context: IEditorOpenContext, token: CancellationToken): Promise<void> {\n\t\tthis._input = input;\n\t\tthis._options = options;\n\t}\n\n\t/**\n\t * Called to indicate to the editor that the input should be cleared and\n\t * resources associated with the input should be freed.\n\t *\n\t * This method can be called based on different contexts, e.g. when opening\n\t * a different input or different editor control or when closing all editors\n\t * in a group.\n\t *\n\t * To monitor the lifecycle of editor inputs, you should not rely on this\n\t * method, rather refer to the listeners on `IEditorGroup` via `IEditorGroupsService`.\n\t */\n\tclearInput(): void {\n\t\tthis._input = undefined;\n\t\tthis._options = undefined;\n\t}\n\n\t/**\n\t * Note: Clients should not call this method, the workbench calls this\n\t * method. Calling it otherwise may result in unexpected behavior.\n\t *\n\t * Sets the given options to the editor. Clients should apply the options\n\t * to the current input.\n\t */\n\tsetOptions(options: IEditorOptions | undefined): void {\n\t\tthis._options = options;\n\t}\n\n\toverride setVisible(visible: boolean): void {\n\t\tsuper.setVisible(visible);\n\n\t\t// Propagate to Editor\n\t\tthis.setEditorVisible(visible);\n\t}\n\n\t/**\n\t * Indicates that the editor control got visible or hidden.\n\t *\n\t * @param visible the state of visibility of this editor\n\t */\n\tprotected setEditorVisible(visible: boolean): void {\n\t\t// Subclasses can implement\n\t}\n\n\tsetBoundarySashes(_sashes: IBoundarySashes) {\n\t\t// Subclasses can implement\n\t}\n\n\tprotected getEditorMemento<T>(editorGroupService: IEditorGroupsService, configurationService: ITextResourceConfigurationService, key: string, limit: number = 10): IEditorMemento<T> {\n\t\tconst mementoKey = `${this.getId()}${key}`;\n\n\t\tlet editorMemento = EditorPane.EDITOR_MEMENTOS.get(mementoKey);\n\t\tif (!editorMemento) {\n\t\t\teditorMemento = this._register(new EditorMemento(this.getId(), key, this.getMemento(StorageScope.WORKSPACE, StorageTarget.MACHINE), limit, editorGroupService, configurationService));\n\t\t\tEditorPane.EDITOR_MEMENTOS.set(mementoKey, editorMemento);\n\t\t}\n\n\t\treturn editorMemento as IEditorMemento<T>;\n\t}\n\n\tgetViewState(): object | undefined {\n\n\t\t// Subclasses to override\n\t\treturn undefined;\n\t}\n\n\tprotected override saveState(): void {\n\n\t\t// Save all editor memento for this editor type\n\t\tfor (const [, editorMemento] of EditorPane.EDITOR_MEMENTOS) {\n\t\t\tif (editorMemento.id === this.getId()) {\n\t\t\t\teditorMemento.saveState();\n\t\t\t}\n\t\t}\n\n\t\tsuper.saveState();\n\t}\n\n\toverride dispose(): void {\n\t\tthis._input = undefined;\n\t\tthis._options = undefined;\n\n\t\tsuper.dispose();\n\t}\n}\n\ninterface MapGroupToMemento<T> {\n\t[group: GroupIdentifier]: T;\n}\n\nexport class EditorMemento<T> extends Disposable implements IEditorMemento<T> {\n\n\tprivate static readonly SHARED_EDITOR_STATE = -1; // pick a number < 0 to be outside group id range\n\n\tprivate cache: LRUCache<string, MapGroupToMemento<T>> | undefined;\n\tprivate cleanedUp = false;\n\tprivate editorDisposables: Map<EditorInput, IDisposable> | undefined;\n\tprivate shareEditorState = false;\n\n\tconstructor(\n\t\treadonly id: string,\n\t\tprivate readonly key: string,\n\t\tprivate readonly memento: T,\n\t\tprivate readonly limit: number,\n\t\tprivate readonly editorGroupService: IEditorGroupsService,\n\t\tprivate readonly configurationService: ITextResourceConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tthis.updateConfiguration(undefined);\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => this.updateConfiguration(e)));\n\t}\n\n\tprivate updateConfiguration(e: ITextResourceConfigurationChangeEvent | undefined): void {\n\t\tif (!e || e.affectsConfiguration(undefined, 'workbench.editor.sharedViewState')) {\n\t\t\tthis.shareEditorState = this.configurationService.getValue(undefined, 'workbench.editor.sharedViewState') === true;\n\t\t}\n\t}\n\n\tsaveEditorState(group: IEditorGroup, resource: URI, state: T): void;\n\tsaveEditorState(group: IEditorGroup, editor: EditorInput, state: T): void;\n\tsaveEditorState(group: IEditorGroup, resourceOrEditor: URI | EditorInput, state: T): void {\n\t\tconst resource = this.doGetResource(resourceOrEditor);\n\t\tif (!resource || !group) {\n\t\t\treturn; // we are not in a good state to save any state for a resource\n\t\t}\n\n\t\tconst cache = this.doLoad();\n\n\t\t// Ensure mementos for resource map\n\t\tlet mementosForResource = cache.get(resource.toString());\n\t\tif (!mementosForResource) {\n\t\t\tmementosForResource = Object.create(null) as MapGroupToMemento<T>;\n\t\t\tcache.set(resource.toString(), mementosForResource);\n\t\t}\n\n\t\t// Store state for group\n\t\tmementosForResource[group.id] = state;\n\n\t\t// Store state as most recent one based on settings\n\t\tif (this.shareEditorState) {\n\t\t\tmementosForResource[EditorMemento.SHARED_EDITOR_STATE] = state;\n\t\t}\n\n\t\t// Automatically clear when editor input gets disposed if any\n\t\tif (isEditorInput(resourceOrEditor)) {\n\t\t\tthis.clearEditorStateOnDispose(resource, resourceOrEditor);\n\t\t}\n\t}\n\n\tloadEditorState(group: IEditorGroup, resource: URI): T | undefined;\n\tloadEditorState(group: IEditorGroup, editor: EditorInput): T | undefined;\n\tloadEditorState(group: IEditorGroup, resourceOrEditor: URI | EditorInput): T | undefined {\n\t\tconst resource = this.doGetResource(resourceOrEditor);\n\t\tif (!resource || !group) {\n\t\t\treturn; // we are not in a good state to load any state for a resource\n\t\t}\n\n\t\tconst cache = this.doLoad();\n\n\t\tconst mementosForResource = cache.get(resource.toString());\n\t\tif (mementosForResource) {\n\t\t\tconst mementoForResourceAndGroup = mementosForResource[group.id];\n\n\t\t\t// Return state for group if present\n\t\t\tif (mementoForResourceAndGroup) {\n\t\t\t\treturn mementoForResourceAndGroup;\n\t\t\t}\n\n\t\t\t// Return most recent state based on settings otherwise\n\t\t\tif (this.shareEditorState) {\n\t\t\t\treturn mementosForResource[EditorMemento.SHARED_EDITOR_STATE];\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tclearEditorState(resource: URI, group?: IEditorGroup): void;\n\tclearEditorState(editor: EditorInput, group?: IEditorGroup): void;\n\tclearEditorState(resourceOrEditor: URI | EditorInput, group?: IEditorGroup): void {\n\t\tif (isEditorInput(resourceOrEditor)) {\n\t\t\tthis.editorDisposables?.delete(resourceOrEditor);\n\t\t}\n\n\t\tconst resource = this.doGetResource(resourceOrEditor);\n\t\tif (resource) {\n\t\t\tconst cache = this.doLoad();\n\n\t\t\t// Clear state for group\n\t\t\tif (group) {\n\t\t\t\tconst mementosForResource = cache.get(resource.toString());\n\t\t\t\tif (mementosForResource) {\n\t\t\t\t\tdelete mementosForResource[group.id];\n\n\t\t\t\t\tif (isEmptyObject(mementosForResource)) {\n\t\t\t\t\t\tcache.delete(resource.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear state across all groups for resource\n\t\t\telse {\n\t\t\t\tcache.delete(resource.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\tclearEditorStateOnDispose(resource: URI, editor: EditorInput): void {\n\t\tif (!this.editorDisposables) {\n\t\t\tthis.editorDisposables = new Map<EditorInput, IDisposable>();\n\t\t}\n\n\t\tif (!this.editorDisposables.has(editor)) {\n\t\t\tthis.editorDisposables.set(editor, Event.once(editor.onWillDispose)(() => {\n\t\t\t\tthis.clearEditorState(resource);\n\t\t\t\tthis.editorDisposables?.delete(editor);\n\t\t\t}));\n\t\t}\n\t}\n\n\tmoveEditorState(source: URI, target: URI, comparer: IExtUri): void {\n\t\tconst cache = this.doLoad();\n\n\t\t// We need a copy of the keys to not iterate over\n\t\t// newly inserted elements.\n\t\tconst cacheKeys = [...cache.keys()];\n\t\tfor (const cacheKey of cacheKeys) {\n\t\t\tconst resource = URI.parse(cacheKey);\n\n\t\t\tif (!comparer.isEqualOrParent(resource, source)) {\n\t\t\t\tcontinue; // not matching our resource\n\t\t\t}\n\n\t\t\t// Determine new resulting target resource\n\t\t\tlet targetResource: URI;\n\t\t\tif (isEqual(source, resource)) {\n\t\t\t\ttargetResource = target; // file got moved\n\t\t\t} else {\n\t\t\t\tconst index = indexOfPath(resource.path, source.path);\n\t\t\t\ttargetResource = joinPath(target, resource.path.substr(index + source.path.length + 1)); // parent folder got moved\n\t\t\t}\n\n\t\t\t// Don't modify LRU state\n\t\t\tconst value = cache.get(cacheKey, Touch.None);\n\t\t\tif (value) {\n\t\t\t\tcache.delete(cacheKey);\n\t\t\t\tcache.set(targetResource.toString(), value);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doGetResource(resourceOrEditor: URI | EditorInput): URI | undefined {\n\t\tif (isEditorInput(resourceOrEditor)) {\n\t\t\treturn resourceOrEditor.resource;\n\t\t}\n\n\t\treturn resourceOrEditor;\n\t}\n\n\tprivate doLoad(): LRUCache<string, MapGroupToMemento<T>> {\n\t\tif (!this.cache) {\n\t\t\tthis.cache = new LRUCache<string, MapGroupToMemento<T>>(this.limit);\n\n\t\t\t// Restore from serialized map state\n\t\t\tconst rawEditorMemento = this.memento[this.key as keyof T];\n\t\t\tif (Array.isArray(rawEditorMemento)) {\n\t\t\t\tthis.cache.fromJSON(rawEditorMemento);\n\t\t\t}\n\t\t}\n\n\t\treturn this.cache;\n\t}\n\n\tsaveState(): void {\n\t\tconst cache = this.doLoad();\n\n\t\t// Cleanup once during session\n\t\tif (!this.cleanedUp) {\n\t\t\tthis.cleanUp();\n\t\t\tthis.cleanedUp = true;\n\t\t}\n\n\t\t(this.memento as Record<string, unknown>)[this.key] = cache.toJSON();\n\t}\n\n\tprivate cleanUp(): void {\n\t\tconst cache = this.doLoad();\n\n\t\t// Remove groups from states that no longer exist. Since we modify the\n\t\t// cache and its is a LRU cache make a copy to ensure iteration succeeds\n\t\tconst entries = [...cache.entries()];\n\t\tfor (const [resource, mapGroupToMementos] of entries) {\n\t\t\tfor (const group of Object.keys(mapGroupToMementos)) {\n\t\t\t\tconst groupId: GroupIdentifier = Number(group);\n\t\t\t\tif (groupId === EditorMemento.SHARED_EDITOR_STATE && this.shareEditorState) {\n\t\t\t\t\tcontinue; // skip over shared entries if sharing is enabled\n\t\t\t\t}\n\n\t\t\t\tif (!this.editorGroupService.getGroup(groupId)) {\n\t\t\t\t\tdelete mapGroupToMementos[groupId];\n\t\t\t\t\tif (isEmptyObject(mapGroupToMementos)) {\n\t\t\t\t\t\tcache.delete(resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Composite } from '../../composite.js';\nimport { IEditorPane, GroupIdentifier, IEditorMemento, IEditorOpenContext, isEditorInput } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IEditorGroup, IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { LRUCache, Touch } from '../../../../base/common/map.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { isEmptyObject } from '../../../../base/common/types.js';\nimport { DEFAULT_EDITOR_MIN_DIMENSIONS, DEFAULT_EDITOR_MAX_DIMENSIONS } from './editor.js';\nimport { joinPath, IExtUri, isEqual } from '../../../../base/common/resources.js';\nimport { indexOfPath } from '../../../../base/common/extpath.js';\nimport { Disposable, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IEditorOptions } from '../../../../platform/editor/common/editor.js';\nimport { ITextResourceConfigurationChangeEvent, ITextResourceConfigurationService } from '../../../../editor/common/services/textResourceConfiguration.js';\nimport { IBoundarySashes } from '../../../../base/browser/ui/sash/sash.js';\nimport { getWindowById } from '../../../../base/browser/dom.js';\n\n/**\n * The base class of editors in the workbench. Editors register themselves for specific editor inputs.\n * Editors are layed out in the editor part of the workbench in editor groups. Multiple editors can be\n * open at the same time. Each editor has a minimized representation that is good enough to provide some\n * information about the state of the editor data.\n *\n * The workbench will keep an editor alive after it has been created and show/hide it based on\n * user interaction. The lifecycle of a editor goes in the order:\n *\n * - `createEditor()`\n * - `setEditorVisible()`\n * - `layout()`\n * - `setInput()`\n * - `focus()`\n * - `dispose()`: when the editor group the editor is in closes\n *\n * During use of the workbench, a editor will often receive a `clearInput()`, `setEditorVisible()`, `layout()` and\n * `focus()` calls, but only one `create()` and `dispose()` call.\n *\n * This class is only intended to be subclassed and not instantiated.\n */\nexport abstract class EditorPane<MementoType extends object = object> extends Composite<MementoType> implements IEditorPane {\n\n\t//#region Events\n\n\treadonly onDidChangeSizeConstraints = Event.None;\n\n\tprotected readonly _onDidChangeControl = this._register(new Emitter<void>());\n\treadonly onDidChangeControl = this._onDidChangeControl.event;\n\n\t//#endregion\n\n\tprivate static readonly EDITOR_MEMENTOS = new Map<string, EditorMemento<unknown>>();\n\n\tget minimumWidth() { return DEFAULT_EDITOR_MIN_DIMENSIONS.width; }\n\tget maximumWidth() { return DEFAULT_EDITOR_MAX_DIMENSIONS.width; }\n\tget minimumHeight() { return DEFAULT_EDITOR_MIN_DIMENSIONS.height; }\n\tget maximumHeight() { return DEFAULT_EDITOR_MAX_DIMENSIONS.height; }\n\n\tprotected _input: EditorInput | undefined;\n\tget input(): EditorInput | undefined { return this._input; }\n\n\tprotected _options: IEditorOptions | undefined;\n\tget options(): IEditorOptions | undefined { return this._options; }\n\n\tget window() { return getWindowById(this.group.windowId, true).window; }\n\n\t/**\n\t * Should be overridden by editors that have their own ScopedContextKeyService\n\t */\n\tget scopedContextKeyService(): IContextKeyService | undefined { return undefined; }\n\n\tconstructor(\n\t\tid: string,\n\t\treadonly group: IEditorGroup,\n\t\ttelemetryService: ITelemetryService,\n\t\tthemeService: IThemeService,\n\t\tstorageService: IStorageService\n\t) {\n\t\tsuper(id, telemetryService, themeService, storageService);\n\t}\n\n\toverride create(parent: HTMLElement): void {\n\t\tsuper.create(parent);\n\n\t\t// Create Editor\n\t\tthis.createEditor(parent);\n\t}\n\n\t/**\n\t * Called to create the editor in the parent HTMLElement. Subclasses implement\n\t * this method to construct the editor widget.\n\t */\n\tprotected abstract createEditor(parent: HTMLElement): void;\n\n\t/**\n\t * Note: Clients should not call this method, the workbench calls this\n\t * method. Calling it otherwise may result in unexpected behavior.\n\t *\n\t * Sets the given input with the options to the editor. The input is guaranteed\n\t * to be different from the previous input that was set using the `input.matches()`\n\t * method.\n\t *\n\t * The provided context gives more information around how the editor was opened.\n\t *\n\t * The provided cancellation token should be used to test if the operation\n\t * was cancelled.\n\t */\n\tasync setInput(input: EditorInput, options: IEditorOptions | undefined, context: IEditorOpenContext, token: CancellationToken): Promise<void> {\n\t\tthis._input = input;\n\t\tthis._options = options;\n\t}\n\n\t/**\n\t * Called to indicate to the editor that the input should be cleared and\n\t * resources associated with the input should be freed.\n\t *\n\t * This method can be called based on different contexts, e.g. when opening\n\t * a different input or different editor control or when closing all editors\n\t * in a group.\n\t *\n\t * To monitor the lifecycle of editor inputs, you should not rely on this\n\t * method, rather refer to the listeners on `IEditorGroup` via `IEditorGroupsService`.\n\t */\n\tclearInput(): void {\n\t\tthis._input = undefined;\n\t\tthis._options = undefined;\n\t}\n\n\t/**\n\t * Note: Clients should not call this method, the workbench calls this\n\t * method. Calling it otherwise may result in unexpected behavior.\n\t *\n\t * Sets the given options to the editor. Clients should apply the options\n\t * to the current input.\n\t */\n\tsetOptions(options: IEditorOptions | undefined): void {\n\t\tthis._options = options;\n\t}\n\n\toverride setVisible(visible: boolean): void {\n\t\tsuper.setVisible(visible);\n\n\t\t// Propagate to Editor\n\t\tthis.setEditorVisible(visible);\n\t}\n\n\t/**\n\t * Indicates that the editor control got visible or hidden.\n\t *\n\t * @param visible the state of visibility of this editor\n\t */\n\tprotected setEditorVisible(visible: boolean): void {\n\t\t// Subclasses can implement\n\t}\n\n\tsetBoundarySashes(_sashes: IBoundarySashes) {\n\t\t// Subclasses can implement\n\t}\n\n\tprotected getEditorMemento<T>(editorGroupService: IEditorGroupsService, configurationService: ITextResourceConfigurationService, key: string, limit: number = 10): IEditorMemento<T> {\n\t\tconst mementoKey = `${this.getId()}${key}`;\n\n\t\tlet editorMemento = EditorPane.EDITOR_MEMENTOS.get(mementoKey);\n\t\tif (!editorMemento) {\n\t\t\teditorMemento = this._register(new EditorMemento(this.getId(), key, this.getMemento(StorageScope.WORKSPACE, StorageTarget.MACHINE), limit, editorGroupService, configurationService));\n\t\t\tEditorPane.EDITOR_MEMENTOS.set(mementoKey, editorMemento);\n\t\t}\n\n\t\treturn editorMemento as IEditorMemento<T>;\n\t}\n\n\tgetViewState(): object | undefined {\n\n\t\t// Subclasses to override\n\t\treturn undefined;\n\t}\n\n\tprotected override saveState(): void {\n\n\t\t// Save all editor memento for this editor type\n\t\tfor (const [, editorMemento] of EditorPane.EDITOR_MEMENTOS) {\n\t\t\tif (editorMemento.id === this.getId()) {\n\t\t\t\teditorMemento.saveState();\n\t\t\t}\n\t\t}\n\n\t\tsuper.saveState();\n\t}\n\n\toverride dispose(): void {\n\t\tthis._input = undefined;\n\t\tthis._options = undefined;\n\n\t\tsuper.dispose();\n\t}\n}\n\ninterface MapGroupToMemento<T> {\n\t[group: GroupIdentifier]: T;\n}\n\nexport class EditorMemento<T> extends Disposable implements IEditorMemento<T> {\n\n\tprivate static readonly SHARED_EDITOR_STATE = -1; // pick a number < 0 to be outside group id range\n\n\tprivate cache: LRUCache<string, MapGroupToMemento<T>> | undefined;\n\tprivate cleanedUp = false;\n\tprivate editorDisposables: Map<EditorInput, IDisposable> | undefined;\n\tprivate shareEditorState = false;\n\n\tconstructor(\n\t\treadonly id: string,\n\t\tprivate readonly key: string,\n\t\tprivate readonly memento: T,\n\t\tprivate readonly limit: number,\n\t\tprivate readonly editorGroupService: IEditorGroupsService,\n\t\tprivate readonly configurationService: ITextResourceConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tthis.updateConfiguration(undefined);\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => this.updateConfiguration(e)));\n\t}\n\n\tprivate updateConfiguration(e: ITextResourceConfigurationChangeEvent | undefined): void {\n\t\tif (!e || e.affectsConfiguration(undefined, 'workbench.editor.sharedViewState')) {\n\t\t\tthis.shareEditorState = this.configurationService.getValue(undefined, 'workbench.editor.sharedViewState') === true;\n\t\t}\n\t}\n\n\tsaveEditorState(group: IEditorGroup, resource: URI, state: T): void;\n\tsaveEditorState(group: IEditorGroup, editor: EditorInput, state: T): void;\n\tsaveEditorState(group: IEditorGroup, resourceOrEditor: URI | EditorInput, state: T): void {\n\t\tconst resource = this.doGetResource(resourceOrEditor);\n\t\tif (!resource || !group) {\n\t\t\treturn; // we are not in a good state to save any state for a resource\n\t\t}\n\n\t\tconst cache = this.doLoad();\n\n\t\t// Ensure mementos for resource map\n\t\tlet mementosForResource = cache.get(resource.toString());\n\t\tif (!mementosForResource) {\n\t\t\tmementosForResource = Object.create(null) as MapGroupToMemento<T>;\n\t\t\tcache.set(resource.toString(), mementosForResource);\n\t\t}\n\n\t\t// Store state for group\n\t\tmementosForResource[group.id] = state;\n\n\t\t// Store state as most recent one based on settings\n\t\tif (this.shareEditorState) {\n\t\t\tmementosForResource[EditorMemento.SHARED_EDITOR_STATE] = state;\n\t\t}\n\n\t\t// Automatically clear when editor input gets disposed if any\n\t\tif (isEditorInput(resourceOrEditor)) {\n\t\t\tthis.clearEditorStateOnDispose(resource, resourceOrEditor);\n\t\t}\n\t}\n\n\tloadEditorState(group: IEditorGroup, resource: URI): T | undefined;\n\tloadEditorState(group: IEditorGroup, editor: EditorInput): T | undefined;\n\tloadEditorState(group: IEditorGroup, resourceOrEditor: URI | EditorInput): T | undefined {\n\t\tconst resource = this.doGetResource(resourceOrEditor);\n\t\tif (!resource || !group) {\n\t\t\treturn; // we are not in a good state to load any state for a resource\n\t\t}\n\n\t\tconst cache = this.doLoad();\n\n\t\tconst mementosForResource = cache.get(resource.toString());\n\t\tif (mementosForResource) {\n\t\t\tconst mementoForResourceAndGroup = mementosForResource[group.id];\n\n\t\t\t// Return state for group if present\n\t\t\tif (mementoForResourceAndGroup) {\n\t\t\t\treturn mementoForResourceAndGroup;\n\t\t\t}\n\n\t\t\t// Return most recent state based on settings otherwise\n\t\t\tif (this.shareEditorState) {\n\t\t\t\treturn mementosForResource[EditorMemento.SHARED_EDITOR_STATE];\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tclearEditorState(resource: URI, group?: IEditorGroup): void;\n\tclearEditorState(editor: EditorInput, group?: IEditorGroup): void;\n\tclearEditorState(resourceOrEditor: URI | EditorInput, group?: IEditorGroup): void {\n\t\tif (isEditorInput(resourceOrEditor)) {\n\t\t\tthis.editorDisposables?.delete(resourceOrEditor);\n\t\t}\n\n\t\tconst resource = this.doGetResource(resourceOrEditor);\n\t\tif (resource) {\n\t\t\tconst cache = this.doLoad();\n\n\t\t\t// Clear state for group\n\t\t\tif (group) {\n\t\t\t\tconst mementosForResource = cache.get(resource.toString());\n\t\t\t\tif (mementosForResource) {\n\t\t\t\t\tdelete mementosForResource[group.id];\n\n\t\t\t\t\tif (isEmptyObject(mementosForResource)) {\n\t\t\t\t\t\tcache.delete(resource.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear state across all groups for resource\n\t\t\telse {\n\t\t\t\tcache.delete(resource.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\tclearEditorStateOnDispose(resource: URI, editor: EditorInput): void {\n\t\tif (!this.editorDisposables) {\n\t\t\tthis.editorDisposables = new Map<EditorInput, IDisposable>();\n\t\t}\n\n\t\tif (!this.editorDisposables.has(editor)) {\n\t\t\tthis.editorDisposables.set(editor, Event.once(editor.onWillDispose)(() => {\n\t\t\t\tthis.clearEditorState(resource);\n\t\t\t\tthis.editorDisposables?.delete(editor);\n\t\t\t}));\n\t\t}\n\t}\n\n\tmoveEditorState(source: URI, target: URI, comparer: IExtUri): void {\n\t\tconst cache = this.doLoad();\n\n\t\t// We need a copy of the keys to not iterate over\n\t\t// newly inserted elements.\n\t\tconst cacheKeys = [...cache.keys()];\n\t\tfor (const cacheKey of cacheKeys) {\n\t\t\tconst resource = URI.parse(cacheKey);\n\n\t\t\tif (!comparer.isEqualOrParent(resource, source)) {\n\t\t\t\tcontinue; // not matching our resource\n\t\t\t}\n\n\t\t\t// Determine new resulting target resource\n\t\t\tlet targetResource: URI;\n\t\t\tif (isEqual(source, resource)) {\n\t\t\t\ttargetResource = target; // file got moved\n\t\t\t} else {\n\t\t\t\tconst index = indexOfPath(resource.path, source.path);\n\t\t\t\ttargetResource = joinPath(target, resource.path.substr(index + source.path.length + 1)); // parent folder got moved\n\t\t\t}\n\n\t\t\t// Don't modify LRU state\n\t\t\tconst value = cache.get(cacheKey, Touch.None);\n\t\t\tif (value) {\n\t\t\t\tcache.delete(cacheKey);\n\t\t\t\tcache.set(targetResource.toString(), value);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doGetResource(resourceOrEditor: URI | EditorInput): URI | undefined {\n\t\tif (isEditorInput(resourceOrEditor)) {\n\t\t\treturn resourceOrEditor.resource;\n\t\t}\n\n\t\treturn resourceOrEditor;\n\t}\n\n\tprivate doLoad(): LRUCache<string, MapGroupToMemento<T>> {\n\t\tif (!this.cache) {\n\t\t\tthis.cache = new LRUCache<string, MapGroupToMemento<T>>(this.limit);\n\n\t\t\t// Restore from serialized map state\n\t\t\tconst rawEditorMemento = this.memento[this.key as keyof T];\n\t\t\tif (Array.isArray(rawEditorMemento)) {\n\t\t\t\tthis.cache.fromJSON(rawEditorMemento);\n\t\t\t}\n\t\t}\n\n\t\treturn this.cache;\n\t}\n\n\tsaveState(): void {\n\t\tconst cache = this.doLoad();\n\n\t\t// Cleanup once during session\n\t\tif (!this.cleanedUp) {\n\t\t\tthis.cleanUp();\n\t\t\tthis.cleanedUp = true;\n\t\t}\n\n\t\t(this.memento as Record<string, unknown>)[this.key] = cache.toJSON();\n\t}\n\n\tprivate cleanUp(): void {\n\t\tconst cache = this.doLoad();\n\n\t\t// Remove groups from states that no longer exist. Since we modify the\n\t\t// cache and its is a LRU cache make a copy to ensure iteration succeeds\n\t\tconst entries = [...cache.entries()];\n\t\tfor (const [resource, mapGroupToMementos] of entries) {\n\t\t\tfor (const group of Object.keys(mapGroupToMementos)) {\n\t\t\t\tconst groupId: GroupIdentifier = Number(group);\n\t\t\t\tif (groupId === EditorMemento.SHARED_EDITOR_STATE && this.shareEditorState) {\n\t\t\t\t\tcontinue; // skip over shared entries if sharing is enabled\n\t\t\t\t}\n\n\t\t\t\tif (!this.editorGroupService.getGroup(groupId)) {\n\t\t\t\t\tdelete mapGroupToMementos[groupId];\n\t\t\t\t\tif (isEmptyObject(mapGroupToMementos)) {\n\t\t\t\t\t\tcache.delete(resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]}