{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/browser/parts/editor/editorWithViewState.ts","vs/workbench/browser/parts/editor/editorWithViewState.ts"],"names":[],"mappings":"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","file":"editorWithViewState.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { IEditorMemento, IEditorCloseEvent, IEditorOpenContext, EditorResourceAccessor, SideBySideEditor } from '../../../common/editor.js';\nimport { EditorPane } from './editorPane.js';\nimport { IStorageService } from '../../../../platform/storage/common/storage.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { ITextResourceConfigurationService } from '../../../../editor/common/services/textResourceConfiguration.js';\nimport { IEditorGroupsService, IEditorGroup } from '../../../services/editor/common/editorGroupsService.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { IExtUri } from '../../../../base/common/resources.js';\nimport { IDisposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\n\n/**\n * Base class of editors that want to store and restore view state.\n */\nexport abstract class AbstractEditorWithViewState<T extends object> extends EditorPane {\n\n\tprivate viewState: IEditorMemento<T>;\n\n\tprivate readonly groupListener = this._register(new MutableDisposable());\n\n\tprivate editorViewStateDisposables: Map<EditorInput, IDisposable> | undefined;\n\n\tconstructor(\n\t\tid: string,\n\t\tgroup: IEditorGroup,\n\t\tviewStateStorageKey: string,\n\t\t@ITelemetryService telemetryService: ITelemetryService,\n\t\t@IInstantiationService protected readonly instantiationService: IInstantiationService,\n\t\t@IStorageService storageService: IStorageService,\n\t\t@ITextResourceConfigurationService protected readonly textResourceConfigurationService: ITextResourceConfigurationService,\n\t\t@IThemeService themeService: IThemeService,\n\t\t@IEditorService protected readonly editorService: IEditorService,\n\t\t@IEditorGroupsService protected readonly editorGroupService: IEditorGroupsService\n\t) {\n\t\tsuper(id, group, telemetryService, themeService, storageService);\n\n\t\tthis.viewState = this.getEditorMemento<T>(editorGroupService, textResourceConfigurationService, viewStateStorageKey, 100);\n\t}\n\n\tprotected override setEditorVisible(visible: boolean): void {\n\n\t\t// Listen to close events to trigger `onWillCloseEditorInGroup`\n\t\tthis.groupListener.value = this.group.onWillCloseEditor(e => this.onWillCloseEditor(e));\n\n\t\tsuper.setEditorVisible(visible);\n\t}\n\n\tprivate onWillCloseEditor(e: IEditorCloseEvent): void {\n\t\tconst editor = e.editor;\n\t\tif (editor === this.input) {\n\t\t\t// React to editors closing to preserve or clear view state. This needs to happen\n\t\t\t// in the `onWillCloseEditor` because at that time the editor has not yet\n\t\t\t// been disposed and we can safely persist the view state.\n\t\t\tthis.updateEditorViewState(editor);\n\t\t}\n\t}\n\n\toverride clearInput(): void {\n\n\t\t// Preserve current input view state before clearing\n\t\tthis.updateEditorViewState(this.input);\n\n\t\tsuper.clearInput();\n\t}\n\n\tprotected override saveState(): void {\n\n\t\t// Preserve current input view state before shutting down\n\t\tthis.updateEditorViewState(this.input);\n\n\t\tsuper.saveState();\n\t}\n\n\tprivate updateEditorViewState(input: EditorInput | undefined): void {\n\t\tif (!input || !this.tracksEditorViewState(input)) {\n\t\t\treturn; // ensure we have an input to handle view state for\n\t\t}\n\n\t\tconst resource = this.toEditorViewStateResource(input);\n\t\tif (!resource) {\n\t\t\treturn; // we need a resource\n\t\t}\n\n\t\t// If we are not tracking disposed editor view state\n\t\t// make sure to clear the view state once the editor\n\t\t// is disposed.\n\t\tif (!this.tracksDisposedEditorViewState()) {\n\t\t\tif (!this.editorViewStateDisposables) {\n\t\t\t\tthis.editorViewStateDisposables = new Map<EditorInput, IDisposable>();\n\t\t\t}\n\n\t\t\tif (!this.editorViewStateDisposables.has(input)) {\n\t\t\t\tthis.editorViewStateDisposables.set(input, Event.once(input.onWillDispose)(() => {\n\t\t\t\t\tthis.clearEditorViewState(resource, this.group);\n\t\t\t\t\tthis.editorViewStateDisposables?.delete(input);\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\t// Clear the editor view state if:\n\t\t// - the editor view state should not be tracked for disposed editors\n\t\t// - the user configured to not restore view state unless the editor is still opened in the group\n\t\tif (\n\t\t\t(input.isDisposed() && !this.tracksDisposedEditorViewState()) ||\n\t\t\t(!this.shouldRestoreEditorViewState(input) && !this.group.contains(input))\n\t\t) {\n\t\t\tthis.clearEditorViewState(resource, this.group);\n\t\t}\n\n\t\t// Otherwise we save the view state\n\t\telse if (!input.isDisposed()) {\n\t\t\tthis.saveEditorViewState(resource);\n\t\t}\n\t}\n\n\tprivate shouldRestoreEditorViewState(input: EditorInput, context?: IEditorOpenContext): boolean {\n\n\t\t// new editor: check with workbench.editor.restoreViewState setting\n\t\tif (context?.newInGroup) {\n\t\t\treturn this.textResourceConfigurationService.getValue<boolean>(EditorResourceAccessor.getOriginalUri(input, { supportSideBySide: SideBySideEditor.PRIMARY }), 'workbench.editor.restoreViewState') !== false /* restore by default */;\n\t\t}\n\n\t\t// existing editor: always restore viewstate\n\t\treturn true;\n\t}\n\n\toverride getViewState(): T | undefined {\n\t\tconst input = this.input;\n\t\tif (!input || !this.tracksEditorViewState(input)) {\n\t\t\treturn; // need valid input for view state\n\t\t}\n\n\t\tconst resource = this.toEditorViewStateResource(input);\n\t\tif (!resource) {\n\t\t\treturn; // need a resource for finding view state\n\t\t}\n\n\t\treturn this.computeEditorViewState(resource);\n\t}\n\n\tprivate saveEditorViewState(resource: URI): void {\n\t\tconst editorViewState = this.computeEditorViewState(resource);\n\t\tif (!editorViewState) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.viewState.saveEditorState(this.group, resource, editorViewState);\n\t}\n\n\tprotected loadEditorViewState(input: EditorInput | undefined, context?: IEditorOpenContext): T | undefined {\n\t\tif (!input) {\n\t\t\treturn undefined; // we need valid input\n\t\t}\n\n\t\tif (!this.tracksEditorViewState(input)) {\n\t\t\treturn undefined; // not tracking for input\n\t\t}\n\n\t\tif (!this.shouldRestoreEditorViewState(input, context)) {\n\t\t\treturn undefined; // not enabled for input\n\t\t}\n\n\t\tconst resource = this.toEditorViewStateResource(input);\n\t\tif (!resource) {\n\t\t\treturn; // need a resource for finding view state\n\t\t}\n\n\t\treturn this.viewState.loadEditorState(this.group, resource);\n\t}\n\n\tprotected moveEditorViewState(source: URI, target: URI, comparer: IExtUri): void {\n\t\treturn this.viewState.moveEditorState(source, target, comparer);\n\t}\n\n\tprotected clearEditorViewState(resource: URI, group?: IEditorGroup): void {\n\t\tthis.viewState.clearEditorState(resource, group);\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tif (this.editorViewStateDisposables) {\n\t\t\tfor (const [, disposables] of this.editorViewStateDisposables) {\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\n\t\t\tthis.editorViewStateDisposables = undefined;\n\t\t}\n\t}\n\n\t//#region Subclasses should/could override based on needs\n\n\t/**\n\t * The actual method to provide for gathering the view state\n\t * object for the control.\n\t *\n\t * @param resource the expected `URI` for the view state. This\n\t * should be used as a way to ensure the view state in the\n\t * editor control is matching the resource expected, for example\n\t * by comparing with the underlying model (this was a fix for\n\t * https://github.com/microsoft/vscode/issues/40114).\n\t */\n\tprotected abstract computeEditorViewState(resource: URI): T | undefined;\n\n\t/**\n\t * Whether view state should be associated with the given input.\n\t * Subclasses need to ensure that the editor input is expected\n\t * for the editor.\n\t */\n\tprotected abstract tracksEditorViewState(input: EditorInput): boolean;\n\n\t/**\n\t * Whether view state should be tracked even when the editor is\n\t * disposed.\n\t *\n\t * Subclasses should override this if the input can be restored\n\t * from the resource at a later point, e.g. if backed by files.\n\t */\n\tprotected tracksDisposedEditorViewState(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Asks to return the `URI` to associate with the view state.\n\t */\n\tprotected abstract toEditorViewStateResource(input: EditorInput): URI | undefined;\n\n\t//#endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { IEditorMemento, IEditorCloseEvent, IEditorOpenContext, EditorResourceAccessor, SideBySideEditor } from '../../../common/editor.js';\nimport { EditorPane } from './editorPane.js';\nimport { IStorageService } from '../../../../platform/storage/common/storage.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { ITextResourceConfigurationService } from '../../../../editor/common/services/textResourceConfiguration.js';\nimport { IEditorGroupsService, IEditorGroup } from '../../../services/editor/common/editorGroupsService.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { IExtUri } from '../../../../base/common/resources.js';\nimport { IDisposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\n\n/**\n * Base class of editors that want to store and restore view state.\n */\nexport abstract class AbstractEditorWithViewState<T extends object> extends EditorPane {\n\n\tprivate viewState: IEditorMemento<T>;\n\n\tprivate readonly groupListener = this._register(new MutableDisposable());\n\n\tprivate editorViewStateDisposables: Map<EditorInput, IDisposable> | undefined;\n\n\tconstructor(\n\t\tid: string,\n\t\tgroup: IEditorGroup,\n\t\tviewStateStorageKey: string,\n\t\t@ITelemetryService telemetryService: ITelemetryService,\n\t\t@IInstantiationService protected readonly instantiationService: IInstantiationService,\n\t\t@IStorageService storageService: IStorageService,\n\t\t@ITextResourceConfigurationService protected readonly textResourceConfigurationService: ITextResourceConfigurationService,\n\t\t@IThemeService themeService: IThemeService,\n\t\t@IEditorService protected readonly editorService: IEditorService,\n\t\t@IEditorGroupsService protected readonly editorGroupService: IEditorGroupsService\n\t) {\n\t\tsuper(id, group, telemetryService, themeService, storageService);\n\n\t\tthis.viewState = this.getEditorMemento<T>(editorGroupService, textResourceConfigurationService, viewStateStorageKey, 100);\n\t}\n\n\tprotected override setEditorVisible(visible: boolean): void {\n\n\t\t// Listen to close events to trigger `onWillCloseEditorInGroup`\n\t\tthis.groupListener.value = this.group.onWillCloseEditor(e => this.onWillCloseEditor(e));\n\n\t\tsuper.setEditorVisible(visible);\n\t}\n\n\tprivate onWillCloseEditor(e: IEditorCloseEvent): void {\n\t\tconst editor = e.editor;\n\t\tif (editor === this.input) {\n\t\t\t// React to editors closing to preserve or clear view state. This needs to happen\n\t\t\t// in the `onWillCloseEditor` because at that time the editor has not yet\n\t\t\t// been disposed and we can safely persist the view state.\n\t\t\tthis.updateEditorViewState(editor);\n\t\t}\n\t}\n\n\toverride clearInput(): void {\n\n\t\t// Preserve current input view state before clearing\n\t\tthis.updateEditorViewState(this.input);\n\n\t\tsuper.clearInput();\n\t}\n\n\tprotected override saveState(): void {\n\n\t\t// Preserve current input view state before shutting down\n\t\tthis.updateEditorViewState(this.input);\n\n\t\tsuper.saveState();\n\t}\n\n\tprivate updateEditorViewState(input: EditorInput | undefined): void {\n\t\tif (!input || !this.tracksEditorViewState(input)) {\n\t\t\treturn; // ensure we have an input to handle view state for\n\t\t}\n\n\t\tconst resource = this.toEditorViewStateResource(input);\n\t\tif (!resource) {\n\t\t\treturn; // we need a resource\n\t\t}\n\n\t\t// If we are not tracking disposed editor view state\n\t\t// make sure to clear the view state once the editor\n\t\t// is disposed.\n\t\tif (!this.tracksDisposedEditorViewState()) {\n\t\t\tif (!this.editorViewStateDisposables) {\n\t\t\t\tthis.editorViewStateDisposables = new Map<EditorInput, IDisposable>();\n\t\t\t}\n\n\t\t\tif (!this.editorViewStateDisposables.has(input)) {\n\t\t\t\tthis.editorViewStateDisposables.set(input, Event.once(input.onWillDispose)(() => {\n\t\t\t\t\tthis.clearEditorViewState(resource, this.group);\n\t\t\t\t\tthis.editorViewStateDisposables?.delete(input);\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\t// Clear the editor view state if:\n\t\t// - the editor view state should not be tracked for disposed editors\n\t\t// - the user configured to not restore view state unless the editor is still opened in the group\n\t\tif (\n\t\t\t(input.isDisposed() && !this.tracksDisposedEditorViewState()) ||\n\t\t\t(!this.shouldRestoreEditorViewState(input) && !this.group.contains(input))\n\t\t) {\n\t\t\tthis.clearEditorViewState(resource, this.group);\n\t\t}\n\n\t\t// Otherwise we save the view state\n\t\telse if (!input.isDisposed()) {\n\t\t\tthis.saveEditorViewState(resource);\n\t\t}\n\t}\n\n\tprivate shouldRestoreEditorViewState(input: EditorInput, context?: IEditorOpenContext): boolean {\n\n\t\t// new editor: check with workbench.editor.restoreViewState setting\n\t\tif (context?.newInGroup) {\n\t\t\treturn this.textResourceConfigurationService.getValue<boolean>(EditorResourceAccessor.getOriginalUri(input, { supportSideBySide: SideBySideEditor.PRIMARY }), 'workbench.editor.restoreViewState') !== false /* restore by default */;\n\t\t}\n\n\t\t// existing editor: always restore viewstate\n\t\treturn true;\n\t}\n\n\toverride getViewState(): T | undefined {\n\t\tconst input = this.input;\n\t\tif (!input || !this.tracksEditorViewState(input)) {\n\t\t\treturn; // need valid input for view state\n\t\t}\n\n\t\tconst resource = this.toEditorViewStateResource(input);\n\t\tif (!resource) {\n\t\t\treturn; // need a resource for finding view state\n\t\t}\n\n\t\treturn this.computeEditorViewState(resource);\n\t}\n\n\tprivate saveEditorViewState(resource: URI): void {\n\t\tconst editorViewState = this.computeEditorViewState(resource);\n\t\tif (!editorViewState) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.viewState.saveEditorState(this.group, resource, editorViewState);\n\t}\n\n\tprotected loadEditorViewState(input: EditorInput | undefined, context?: IEditorOpenContext): T | undefined {\n\t\tif (!input) {\n\t\t\treturn undefined; // we need valid input\n\t\t}\n\n\t\tif (!this.tracksEditorViewState(input)) {\n\t\t\treturn undefined; // not tracking for input\n\t\t}\n\n\t\tif (!this.shouldRestoreEditorViewState(input, context)) {\n\t\t\treturn undefined; // not enabled for input\n\t\t}\n\n\t\tconst resource = this.toEditorViewStateResource(input);\n\t\tif (!resource) {\n\t\t\treturn; // need a resource for finding view state\n\t\t}\n\n\t\treturn this.viewState.loadEditorState(this.group, resource);\n\t}\n\n\tprotected moveEditorViewState(source: URI, target: URI, comparer: IExtUri): void {\n\t\treturn this.viewState.moveEditorState(source, target, comparer);\n\t}\n\n\tprotected clearEditorViewState(resource: URI, group?: IEditorGroup): void {\n\t\tthis.viewState.clearEditorState(resource, group);\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tif (this.editorViewStateDisposables) {\n\t\t\tfor (const [, disposables] of this.editorViewStateDisposables) {\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\n\t\t\tthis.editorViewStateDisposables = undefined;\n\t\t}\n\t}\n\n\t//#region Subclasses should/could override based on needs\n\n\t/**\n\t * The actual method to provide for gathering the view state\n\t * object for the control.\n\t *\n\t * @param resource the expected `URI` for the view state. This\n\t * should be used as a way to ensure the view state in the\n\t * editor control is matching the resource expected, for example\n\t * by comparing with the underlying model (this was a fix for\n\t * https://github.com/microsoft/vscode/issues/40114).\n\t */\n\tprotected abstract computeEditorViewState(resource: URI): T | undefined;\n\n\t/**\n\t * Whether view state should be associated with the given input.\n\t * Subclasses need to ensure that the editor input is expected\n\t * for the editor.\n\t */\n\tprotected abstract tracksEditorViewState(input: EditorInput): boolean;\n\n\t/**\n\t * Whether view state should be tracked even when the editor is\n\t * disposed.\n\t *\n\t * Subclasses should override this if the input can be restored\n\t * from the resource at a later point, e.g. if backed by files.\n\t */\n\tprotected tracksDisposedEditorViewState(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Asks to return the `URI` to associate with the view state.\n\t */\n\tprotected abstract toEditorViewStateResource(input: EditorInput): URI | undefined;\n\n\t//#endregion\n}\n"]}