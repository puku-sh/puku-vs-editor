{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/browser/parts/editor/editorAutoSave.ts","vs/workbench/browser/parts/editor/editorAutoSave.ts"],"names":[],"mappings":"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","file":"editorAutoSave.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWorkbenchContribution } from '../../../common/contributions.js';\nimport { Disposable, DisposableStore, IDisposable, dispose, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { IFilesConfigurationService, AutoSaveMode, AutoSaveDisabledReason } from '../../../services/filesConfiguration/common/filesConfigurationService.js';\nimport { IHostService } from '../../../services/host/browser/host.js';\nimport { SaveReason, IEditorIdentifier, GroupIdentifier, EditorInputCapabilities } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';\nimport { IWorkingCopyService } from '../../../services/workingCopy/common/workingCopyService.js';\nimport { IWorkingCopy, WorkingCopyCapabilities } from '../../../services/workingCopy/common/workingCopy.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IMarkerService } from '../../../../platform/markers/common/markers.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\n\nexport class EditorAutoSave extends Disposable implements IWorkbenchContribution {\n\n\tstatic readonly ID = 'workbench.contrib.editorAutoSave';\n\n\t// Auto save: after delay\n\tprivate readonly scheduledAutoSavesAfterDelay = new Map<IWorkingCopy, IDisposable>();\n\n\t// Auto save: focus change & window change\n\tprivate lastActiveEditor: EditorInput | undefined = undefined;\n\tprivate lastActiveGroupId: GroupIdentifier | undefined = undefined;\n\tprivate readonly lastActiveEditorControlDisposable = this._register(new DisposableStore());\n\n\t// Auto save: waiting on specific condition\n\tprivate readonly waitingOnConditionAutoSaveWorkingCopies = new ResourceMap<{ readonly workingCopy: IWorkingCopy; readonly reason: SaveReason; condition: AutoSaveDisabledReason }>(resource => this.uriIdentityService.extUri.getComparisonKey(resource));\n\tprivate readonly waitingOnConditionAutoSaveEditors = new ResourceMap<{ readonly editor: IEditorIdentifier; readonly reason: SaveReason; condition: AutoSaveDisabledReason }>(resource => this.uriIdentityService.extUri.getComparisonKey(resource));\n\n\tconstructor(\n\t\t@IFilesConfigurationService private readonly filesConfigurationService: IFilesConfigurationService,\n\t\t@IHostService private readonly hostService: IHostService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@IWorkingCopyService private readonly workingCopyService: IWorkingCopyService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IMarkerService private readonly markerService: IMarkerService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService\n\t) {\n\t\tsuper();\n\n\t\t// Fill in initial dirty working copies\n\t\tfor (const dirtyWorkingCopy of this.workingCopyService.dirtyWorkingCopies) {\n\t\t\tthis.onDidRegister(dirtyWorkingCopy);\n\t\t}\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.hostService.onDidChangeFocus(focused => this.onWindowFocusChange(focused)));\n\t\tthis._register(this.hostService.onDidChangeActiveWindow(() => this.onActiveWindowChange()));\n\t\tthis._register(this.editorService.onDidActiveEditorChange(() => this.onDidActiveEditorChange()));\n\t\tthis._register(this.filesConfigurationService.onDidChangeAutoSaveConfiguration(() => this.onDidChangeAutoSaveConfiguration()));\n\n\t\t// Working Copy events\n\t\tthis._register(this.workingCopyService.onDidRegister(workingCopy => this.onDidRegister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidUnregister(workingCopy => this.onDidUnregister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeDirty(workingCopy => this.onDidChangeDirty(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeContent(workingCopy => this.onDidChangeContent(workingCopy)));\n\n\t\t// Condition changes\n\t\tthis._register(this.markerService.onMarkerChanged(e => this.onConditionChanged(e, AutoSaveDisabledReason.ERRORS)));\n\t\tthis._register(this.filesConfigurationService.onDidChangeAutoSaveDisabled(resource => this.onConditionChanged([resource], AutoSaveDisabledReason.DISABLED)));\n\t}\n\n\tprivate onConditionChanged(resources: readonly URI[], condition: AutoSaveDisabledReason.ERRORS | AutoSaveDisabledReason.DISABLED): void {\n\t\tfor (const resource of resources) {\n\n\t\t\t// Waiting working copies\n\t\t\tconst workingCopyResult = this.waitingOnConditionAutoSaveWorkingCopies.get(resource);\n\t\t\tif (workingCopyResult?.condition === condition) {\n\t\t\t\tif (\n\t\t\t\t\tworkingCopyResult.workingCopy.isDirty() &&\n\t\t\t\t\tthis.filesConfigurationService.getAutoSaveMode(workingCopyResult.workingCopy.resource, workingCopyResult.reason).mode !== AutoSaveMode.OFF\n\t\t\t\t) {\n\t\t\t\t\tthis.discardAutoSave(workingCopyResult.workingCopy);\n\n\t\t\t\t\tthis.logService.trace(`[editor auto save] running auto save from condition change event`, workingCopyResult.workingCopy.resource.toString(), workingCopyResult.workingCopy.typeId);\n\t\t\t\t\tworkingCopyResult.workingCopy.save({ reason: workingCopyResult.reason });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Waiting editors\n\t\t\telse {\n\t\t\t\tconst editorResult = this.waitingOnConditionAutoSaveEditors.get(resource);\n\t\t\t\tif (\n\t\t\t\t\teditorResult?.condition === condition &&\n\t\t\t\t\t!editorResult.editor.editor.isDisposed() &&\n\t\t\t\t\teditorResult.editor.editor.isDirty() &&\n\t\t\t\t\tthis.filesConfigurationService.getAutoSaveMode(editorResult.editor.editor, editorResult.reason).mode !== AutoSaveMode.OFF\n\t\t\t\t) {\n\t\t\t\t\tthis.waitingOnConditionAutoSaveEditors.delete(resource);\n\n\t\t\t\t\tthis.logService.trace(`[editor auto save] running auto save from condition change event with reason ${editorResult.reason}`);\n\t\t\t\t\tthis.editorService.save(editorResult.editor, { reason: editorResult.reason });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onWindowFocusChange(focused: boolean): void {\n\t\tif (!focused) {\n\t\t\tthis.maybeTriggerAutoSave(SaveReason.WINDOW_CHANGE);\n\t\t}\n\t}\n\n\tprivate onActiveWindowChange(): void {\n\t\tthis.maybeTriggerAutoSave(SaveReason.WINDOW_CHANGE);\n\t}\n\n\tprivate onDidActiveEditorChange(): void {\n\n\t\t// Treat editor change like a focus change for our last active editor if any\n\t\tif (this.lastActiveEditor && typeof this.lastActiveGroupId === 'number') {\n\t\t\tthis.maybeTriggerAutoSave(SaveReason.FOCUS_CHANGE, { groupId: this.lastActiveGroupId, editor: this.lastActiveEditor });\n\t\t}\n\n\t\t// Remember as last active\n\t\tconst activeGroup = this.editorGroupService.activeGroup;\n\t\tconst activeEditor = this.lastActiveEditor = activeGroup.activeEditor ?? undefined;\n\t\tthis.lastActiveGroupId = activeGroup.id;\n\n\t\t// Dispose previous active control listeners\n\t\tthis.lastActiveEditorControlDisposable.clear();\n\n\t\t// Listen to focus changes on control for auto save\n\t\tconst activeEditorPane = this.editorService.activeEditorPane;\n\t\tif (activeEditor && activeEditorPane) {\n\t\t\tthis.lastActiveEditorControlDisposable.add(activeEditorPane.onDidBlur(() => {\n\t\t\t\tthis.maybeTriggerAutoSave(SaveReason.FOCUS_CHANGE, { groupId: activeGroup.id, editor: activeEditor });\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate maybeTriggerAutoSave(reason: SaveReason.WINDOW_CHANGE | SaveReason.FOCUS_CHANGE, editorIdentifier?: IEditorIdentifier): void {\n\t\tif (editorIdentifier) {\n\t\t\tif (\n\t\t\t\t!editorIdentifier.editor.isDirty() ||\n\t\t\t\teditorIdentifier.editor.isReadonly() ||\n\t\t\t\teditorIdentifier.editor.hasCapability(EditorInputCapabilities.Untitled)\n\t\t\t) {\n\t\t\t\treturn; // no auto save for non-dirty, readonly or untitled editors\n\t\t\t}\n\n\t\t\tconst autoSaveMode = this.filesConfigurationService.getAutoSaveMode(editorIdentifier.editor, reason);\n\t\t\tif (autoSaveMode.mode !== AutoSaveMode.OFF) {\n\t\t\t\t// Determine if we need to save all. In case of a window focus change we also save if\n\t\t\t\t// auto save mode is configured to be ON_FOCUS_CHANGE (editor focus change)\n\t\t\t\tif (\n\t\t\t\t\t(reason === SaveReason.WINDOW_CHANGE && (autoSaveMode.mode === AutoSaveMode.ON_FOCUS_CHANGE || autoSaveMode.mode === AutoSaveMode.ON_WINDOW_CHANGE)) ||\n\t\t\t\t\t(reason === SaveReason.FOCUS_CHANGE && autoSaveMode.mode === AutoSaveMode.ON_FOCUS_CHANGE)\n\t\t\t\t) {\n\t\t\t\t\tthis.logService.trace(`[editor auto save] triggering auto save with reason ${reason}`);\n\t\t\t\t\tthis.editorService.save(editorIdentifier, { reason });\n\t\t\t\t}\n\t\t\t} else if (editorIdentifier.editor.resource && (autoSaveMode.reason === AutoSaveDisabledReason.ERRORS || autoSaveMode.reason === AutoSaveDisabledReason.DISABLED)) {\n\t\t\t\tthis.waitingOnConditionAutoSaveEditors.set(editorIdentifier.editor.resource, { editor: editorIdentifier, reason, condition: autoSaveMode.reason });\n\t\t\t}\n\t\t} else {\n\t\t\tthis.saveAllDirtyAutoSaveables(reason);\n\t\t}\n\t}\n\n\tprivate onDidChangeAutoSaveConfiguration(): void {\n\n\t\t// Trigger a save-all when auto save is enabled\n\t\tlet reason: SaveReason | undefined = undefined;\n\t\tswitch (this.filesConfigurationService.getAutoSaveMode(undefined).mode) {\n\t\t\tcase AutoSaveMode.ON_FOCUS_CHANGE:\n\t\t\t\treason = SaveReason.FOCUS_CHANGE;\n\t\t\t\tbreak;\n\t\t\tcase AutoSaveMode.ON_WINDOW_CHANGE:\n\t\t\t\treason = SaveReason.WINDOW_CHANGE;\n\t\t\t\tbreak;\n\t\t\tcase AutoSaveMode.AFTER_SHORT_DELAY:\n\t\t\tcase AutoSaveMode.AFTER_LONG_DELAY:\n\t\t\t\treason = SaveReason.AUTO;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (reason) {\n\t\t\tthis.saveAllDirtyAutoSaveables(reason);\n\t\t}\n\t}\n\n\tprivate saveAllDirtyAutoSaveables(reason: SaveReason): void {\n\t\tfor (const workingCopy of this.workingCopyService.dirtyWorkingCopies) {\n\t\t\tif (workingCopy.capabilities & WorkingCopyCapabilities.Untitled) {\n\t\t\t\tcontinue; // we never auto save untitled working copies\n\t\t\t}\n\n\t\t\tconst autoSaveMode = this.filesConfigurationService.getAutoSaveMode(workingCopy.resource, reason);\n\t\t\tif (autoSaveMode.mode !== AutoSaveMode.OFF) {\n\t\t\t\tworkingCopy.save({ reason });\n\t\t\t} else if (autoSaveMode.reason === AutoSaveDisabledReason.ERRORS || autoSaveMode.reason === AutoSaveDisabledReason.DISABLED) {\n\t\t\t\tthis.waitingOnConditionAutoSaveWorkingCopies.set(workingCopy.resource, { workingCopy, reason, condition: autoSaveMode.reason });\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidRegister(workingCopy: IWorkingCopy): void {\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis.scheduleAutoSave(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidUnregister(workingCopy: IWorkingCopy): void {\n\t\tthis.discardAutoSave(workingCopy);\n\t}\n\n\tprivate onDidChangeDirty(workingCopy: IWorkingCopy): void {\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis.scheduleAutoSave(workingCopy);\n\t\t} else {\n\t\t\tthis.discardAutoSave(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidChangeContent(workingCopy: IWorkingCopy): void {\n\t\tif (workingCopy.isDirty()) {\n\t\t\t// this listener will make sure that the auto save is\n\t\t\t// pushed out for as long as the user is still changing\n\t\t\t// the content of the working copy.\n\t\t\tthis.scheduleAutoSave(workingCopy);\n\t\t}\n\t}\n\n\tprivate scheduleAutoSave(workingCopy: IWorkingCopy): void {\n\t\tif (workingCopy.capabilities & WorkingCopyCapabilities.Untitled) {\n\t\t\treturn; // we never auto save untitled working copies\n\t\t}\n\n\t\tconst autoSaveAfterDelay = this.filesConfigurationService.getAutoSaveConfiguration(workingCopy.resource).autoSaveDelay;\n\t\tif (typeof autoSaveAfterDelay !== 'number') {\n\t\t\treturn; // auto save after delay must be enabled\n\t\t}\n\n\t\t// Clear any running auto save operation\n\t\tthis.discardAutoSave(workingCopy);\n\n\t\tthis.logService.trace(`[editor auto save] scheduling auto save after ${autoSaveAfterDelay}ms`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t// Schedule new auto save\n\t\tconst handle = setTimeout(() => {\n\n\t\t\t// Clear pending\n\t\t\tthis.discardAutoSave(workingCopy);\n\n\t\t\t// Save if dirty and unless prevented by other conditions such as error markers\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\tconst reason = SaveReason.AUTO;\n\t\t\t\tconst autoSaveMode = this.filesConfigurationService.getAutoSaveMode(workingCopy.resource, reason);\n\t\t\t\tif (autoSaveMode.mode !== AutoSaveMode.OFF) {\n\t\t\t\t\tthis.logService.trace(`[editor auto save] running auto save`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\t\t\tworkingCopy.save({ reason });\n\t\t\t\t} else if (autoSaveMode.reason === AutoSaveDisabledReason.ERRORS || autoSaveMode.reason === AutoSaveDisabledReason.DISABLED) {\n\t\t\t\t\tthis.waitingOnConditionAutoSaveWorkingCopies.set(workingCopy.resource, { workingCopy, reason, condition: autoSaveMode.reason });\n\t\t\t\t}\n\t\t\t}\n\t\t}, autoSaveAfterDelay);\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.scheduledAutoSavesAfterDelay.set(workingCopy, toDisposable(() => {\n\t\t\tthis.logService.trace(`[editor auto save] clearing pending auto save`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\tclearTimeout(handle);\n\t\t}));\n\t}\n\n\tprivate discardAutoSave(workingCopy: IWorkingCopy): void {\n\t\tdispose(this.scheduledAutoSavesAfterDelay.get(workingCopy));\n\t\tthis.scheduledAutoSavesAfterDelay.delete(workingCopy);\n\n\t\tthis.waitingOnConditionAutoSaveWorkingCopies.delete(workingCopy.resource);\n\t\tthis.waitingOnConditionAutoSaveEditors.delete(workingCopy.resource);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWorkbenchContribution } from '../../../common/contributions.js';\nimport { Disposable, DisposableStore, IDisposable, dispose, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { IFilesConfigurationService, AutoSaveMode, AutoSaveDisabledReason } from '../../../services/filesConfiguration/common/filesConfigurationService.js';\nimport { IHostService } from '../../../services/host/browser/host.js';\nimport { SaveReason, IEditorIdentifier, GroupIdentifier, EditorInputCapabilities } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.js';\nimport { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';\nimport { IWorkingCopyService } from '../../../services/workingCopy/common/workingCopyService.js';\nimport { IWorkingCopy, WorkingCopyCapabilities } from '../../../services/workingCopy/common/workingCopy.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IMarkerService } from '../../../../platform/markers/common/markers.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\n\nexport class EditorAutoSave extends Disposable implements IWorkbenchContribution {\n\n\tstatic readonly ID = 'workbench.contrib.editorAutoSave';\n\n\t// Auto save: after delay\n\tprivate readonly scheduledAutoSavesAfterDelay = new Map<IWorkingCopy, IDisposable>();\n\n\t// Auto save: focus change & window change\n\tprivate lastActiveEditor: EditorInput | undefined = undefined;\n\tprivate lastActiveGroupId: GroupIdentifier | undefined = undefined;\n\tprivate readonly lastActiveEditorControlDisposable = this._register(new DisposableStore());\n\n\t// Auto save: waiting on specific condition\n\tprivate readonly waitingOnConditionAutoSaveWorkingCopies = new ResourceMap<{ readonly workingCopy: IWorkingCopy; readonly reason: SaveReason; condition: AutoSaveDisabledReason }>(resource => this.uriIdentityService.extUri.getComparisonKey(resource));\n\tprivate readonly waitingOnConditionAutoSaveEditors = new ResourceMap<{ readonly editor: IEditorIdentifier; readonly reason: SaveReason; condition: AutoSaveDisabledReason }>(resource => this.uriIdentityService.extUri.getComparisonKey(resource));\n\n\tconstructor(\n\t\t@IFilesConfigurationService private readonly filesConfigurationService: IFilesConfigurationService,\n\t\t@IHostService private readonly hostService: IHostService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@IWorkingCopyService private readonly workingCopyService: IWorkingCopyService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IMarkerService private readonly markerService: IMarkerService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService\n\t) {\n\t\tsuper();\n\n\t\t// Fill in initial dirty working copies\n\t\tfor (const dirtyWorkingCopy of this.workingCopyService.dirtyWorkingCopies) {\n\t\t\tthis.onDidRegister(dirtyWorkingCopy);\n\t\t}\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.hostService.onDidChangeFocus(focused => this.onWindowFocusChange(focused)));\n\t\tthis._register(this.hostService.onDidChangeActiveWindow(() => this.onActiveWindowChange()));\n\t\tthis._register(this.editorService.onDidActiveEditorChange(() => this.onDidActiveEditorChange()));\n\t\tthis._register(this.filesConfigurationService.onDidChangeAutoSaveConfiguration(() => this.onDidChangeAutoSaveConfiguration()));\n\n\t\t// Working Copy events\n\t\tthis._register(this.workingCopyService.onDidRegister(workingCopy => this.onDidRegister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidUnregister(workingCopy => this.onDidUnregister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeDirty(workingCopy => this.onDidChangeDirty(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeContent(workingCopy => this.onDidChangeContent(workingCopy)));\n\n\t\t// Condition changes\n\t\tthis._register(this.markerService.onMarkerChanged(e => this.onConditionChanged(e, AutoSaveDisabledReason.ERRORS)));\n\t\tthis._register(this.filesConfigurationService.onDidChangeAutoSaveDisabled(resource => this.onConditionChanged([resource], AutoSaveDisabledReason.DISABLED)));\n\t}\n\n\tprivate onConditionChanged(resources: readonly URI[], condition: AutoSaveDisabledReason.ERRORS | AutoSaveDisabledReason.DISABLED): void {\n\t\tfor (const resource of resources) {\n\n\t\t\t// Waiting working copies\n\t\t\tconst workingCopyResult = this.waitingOnConditionAutoSaveWorkingCopies.get(resource);\n\t\t\tif (workingCopyResult?.condition === condition) {\n\t\t\t\tif (\n\t\t\t\t\tworkingCopyResult.workingCopy.isDirty() &&\n\t\t\t\t\tthis.filesConfigurationService.getAutoSaveMode(workingCopyResult.workingCopy.resource, workingCopyResult.reason).mode !== AutoSaveMode.OFF\n\t\t\t\t) {\n\t\t\t\t\tthis.discardAutoSave(workingCopyResult.workingCopy);\n\n\t\t\t\t\tthis.logService.trace(`[editor auto save] running auto save from condition change event`, workingCopyResult.workingCopy.resource.toString(), workingCopyResult.workingCopy.typeId);\n\t\t\t\t\tworkingCopyResult.workingCopy.save({ reason: workingCopyResult.reason });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Waiting editors\n\t\t\telse {\n\t\t\t\tconst editorResult = this.waitingOnConditionAutoSaveEditors.get(resource);\n\t\t\t\tif (\n\t\t\t\t\teditorResult?.condition === condition &&\n\t\t\t\t\t!editorResult.editor.editor.isDisposed() &&\n\t\t\t\t\teditorResult.editor.editor.isDirty() &&\n\t\t\t\t\tthis.filesConfigurationService.getAutoSaveMode(editorResult.editor.editor, editorResult.reason).mode !== AutoSaveMode.OFF\n\t\t\t\t) {\n\t\t\t\t\tthis.waitingOnConditionAutoSaveEditors.delete(resource);\n\n\t\t\t\t\tthis.logService.trace(`[editor auto save] running auto save from condition change event with reason ${editorResult.reason}`);\n\t\t\t\t\tthis.editorService.save(editorResult.editor, { reason: editorResult.reason });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onWindowFocusChange(focused: boolean): void {\n\t\tif (!focused) {\n\t\t\tthis.maybeTriggerAutoSave(SaveReason.WINDOW_CHANGE);\n\t\t}\n\t}\n\n\tprivate onActiveWindowChange(): void {\n\t\tthis.maybeTriggerAutoSave(SaveReason.WINDOW_CHANGE);\n\t}\n\n\tprivate onDidActiveEditorChange(): void {\n\n\t\t// Treat editor change like a focus change for our last active editor if any\n\t\tif (this.lastActiveEditor && typeof this.lastActiveGroupId === 'number') {\n\t\t\tthis.maybeTriggerAutoSave(SaveReason.FOCUS_CHANGE, { groupId: this.lastActiveGroupId, editor: this.lastActiveEditor });\n\t\t}\n\n\t\t// Remember as last active\n\t\tconst activeGroup = this.editorGroupService.activeGroup;\n\t\tconst activeEditor = this.lastActiveEditor = activeGroup.activeEditor ?? undefined;\n\t\tthis.lastActiveGroupId = activeGroup.id;\n\n\t\t// Dispose previous active control listeners\n\t\tthis.lastActiveEditorControlDisposable.clear();\n\n\t\t// Listen to focus changes on control for auto save\n\t\tconst activeEditorPane = this.editorService.activeEditorPane;\n\t\tif (activeEditor && activeEditorPane) {\n\t\t\tthis.lastActiveEditorControlDisposable.add(activeEditorPane.onDidBlur(() => {\n\t\t\t\tthis.maybeTriggerAutoSave(SaveReason.FOCUS_CHANGE, { groupId: activeGroup.id, editor: activeEditor });\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate maybeTriggerAutoSave(reason: SaveReason.WINDOW_CHANGE | SaveReason.FOCUS_CHANGE, editorIdentifier?: IEditorIdentifier): void {\n\t\tif (editorIdentifier) {\n\t\t\tif (\n\t\t\t\t!editorIdentifier.editor.isDirty() ||\n\t\t\t\teditorIdentifier.editor.isReadonly() ||\n\t\t\t\teditorIdentifier.editor.hasCapability(EditorInputCapabilities.Untitled)\n\t\t\t) {\n\t\t\t\treturn; // no auto save for non-dirty, readonly or untitled editors\n\t\t\t}\n\n\t\t\tconst autoSaveMode = this.filesConfigurationService.getAutoSaveMode(editorIdentifier.editor, reason);\n\t\t\tif (autoSaveMode.mode !== AutoSaveMode.OFF) {\n\t\t\t\t// Determine if we need to save all. In case of a window focus change we also save if\n\t\t\t\t// auto save mode is configured to be ON_FOCUS_CHANGE (editor focus change)\n\t\t\t\tif (\n\t\t\t\t\t(reason === SaveReason.WINDOW_CHANGE && (autoSaveMode.mode === AutoSaveMode.ON_FOCUS_CHANGE || autoSaveMode.mode === AutoSaveMode.ON_WINDOW_CHANGE)) ||\n\t\t\t\t\t(reason === SaveReason.FOCUS_CHANGE && autoSaveMode.mode === AutoSaveMode.ON_FOCUS_CHANGE)\n\t\t\t\t) {\n\t\t\t\t\tthis.logService.trace(`[editor auto save] triggering auto save with reason ${reason}`);\n\t\t\t\t\tthis.editorService.save(editorIdentifier, { reason });\n\t\t\t\t}\n\t\t\t} else if (editorIdentifier.editor.resource && (autoSaveMode.reason === AutoSaveDisabledReason.ERRORS || autoSaveMode.reason === AutoSaveDisabledReason.DISABLED)) {\n\t\t\t\tthis.waitingOnConditionAutoSaveEditors.set(editorIdentifier.editor.resource, { editor: editorIdentifier, reason, condition: autoSaveMode.reason });\n\t\t\t}\n\t\t} else {\n\t\t\tthis.saveAllDirtyAutoSaveables(reason);\n\t\t}\n\t}\n\n\tprivate onDidChangeAutoSaveConfiguration(): void {\n\n\t\t// Trigger a save-all when auto save is enabled\n\t\tlet reason: SaveReason | undefined = undefined;\n\t\tswitch (this.filesConfigurationService.getAutoSaveMode(undefined).mode) {\n\t\t\tcase AutoSaveMode.ON_FOCUS_CHANGE:\n\t\t\t\treason = SaveReason.FOCUS_CHANGE;\n\t\t\t\tbreak;\n\t\t\tcase AutoSaveMode.ON_WINDOW_CHANGE:\n\t\t\t\treason = SaveReason.WINDOW_CHANGE;\n\t\t\t\tbreak;\n\t\t\tcase AutoSaveMode.AFTER_SHORT_DELAY:\n\t\t\tcase AutoSaveMode.AFTER_LONG_DELAY:\n\t\t\t\treason = SaveReason.AUTO;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (reason) {\n\t\t\tthis.saveAllDirtyAutoSaveables(reason);\n\t\t}\n\t}\n\n\tprivate saveAllDirtyAutoSaveables(reason: SaveReason): void {\n\t\tfor (const workingCopy of this.workingCopyService.dirtyWorkingCopies) {\n\t\t\tif (workingCopy.capabilities & WorkingCopyCapabilities.Untitled) {\n\t\t\t\tcontinue; // we never auto save untitled working copies\n\t\t\t}\n\n\t\t\tconst autoSaveMode = this.filesConfigurationService.getAutoSaveMode(workingCopy.resource, reason);\n\t\t\tif (autoSaveMode.mode !== AutoSaveMode.OFF) {\n\t\t\t\tworkingCopy.save({ reason });\n\t\t\t} else if (autoSaveMode.reason === AutoSaveDisabledReason.ERRORS || autoSaveMode.reason === AutoSaveDisabledReason.DISABLED) {\n\t\t\t\tthis.waitingOnConditionAutoSaveWorkingCopies.set(workingCopy.resource, { workingCopy, reason, condition: autoSaveMode.reason });\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidRegister(workingCopy: IWorkingCopy): void {\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis.scheduleAutoSave(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidUnregister(workingCopy: IWorkingCopy): void {\n\t\tthis.discardAutoSave(workingCopy);\n\t}\n\n\tprivate onDidChangeDirty(workingCopy: IWorkingCopy): void {\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis.scheduleAutoSave(workingCopy);\n\t\t} else {\n\t\t\tthis.discardAutoSave(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidChangeContent(workingCopy: IWorkingCopy): void {\n\t\tif (workingCopy.isDirty()) {\n\t\t\t// this listener will make sure that the auto save is\n\t\t\t// pushed out for as long as the user is still changing\n\t\t\t// the content of the working copy.\n\t\t\tthis.scheduleAutoSave(workingCopy);\n\t\t}\n\t}\n\n\tprivate scheduleAutoSave(workingCopy: IWorkingCopy): void {\n\t\tif (workingCopy.capabilities & WorkingCopyCapabilities.Untitled) {\n\t\t\treturn; // we never auto save untitled working copies\n\t\t}\n\n\t\tconst autoSaveAfterDelay = this.filesConfigurationService.getAutoSaveConfiguration(workingCopy.resource).autoSaveDelay;\n\t\tif (typeof autoSaveAfterDelay !== 'number') {\n\t\t\treturn; // auto save after delay must be enabled\n\t\t}\n\n\t\t// Clear any running auto save operation\n\t\tthis.discardAutoSave(workingCopy);\n\n\t\tthis.logService.trace(`[editor auto save] scheduling auto save after ${autoSaveAfterDelay}ms`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t// Schedule new auto save\n\t\tconst handle = setTimeout(() => {\n\n\t\t\t// Clear pending\n\t\t\tthis.discardAutoSave(workingCopy);\n\n\t\t\t// Save if dirty and unless prevented by other conditions such as error markers\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\tconst reason = SaveReason.AUTO;\n\t\t\t\tconst autoSaveMode = this.filesConfigurationService.getAutoSaveMode(workingCopy.resource, reason);\n\t\t\t\tif (autoSaveMode.mode !== AutoSaveMode.OFF) {\n\t\t\t\t\tthis.logService.trace(`[editor auto save] running auto save`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\t\t\tworkingCopy.save({ reason });\n\t\t\t\t} else if (autoSaveMode.reason === AutoSaveDisabledReason.ERRORS || autoSaveMode.reason === AutoSaveDisabledReason.DISABLED) {\n\t\t\t\t\tthis.waitingOnConditionAutoSaveWorkingCopies.set(workingCopy.resource, { workingCopy, reason, condition: autoSaveMode.reason });\n\t\t\t\t}\n\t\t\t}\n\t\t}, autoSaveAfterDelay);\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.scheduledAutoSavesAfterDelay.set(workingCopy, toDisposable(() => {\n\t\t\tthis.logService.trace(`[editor auto save] clearing pending auto save`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\tclearTimeout(handle);\n\t\t}));\n\t}\n\n\tprivate discardAutoSave(workingCopy: IWorkingCopy): void {\n\t\tdispose(this.scheduledAutoSavesAfterDelay.get(workingCopy));\n\t\tthis.scheduledAutoSavesAfterDelay.delete(workingCopy);\n\n\t\tthis.waitingOnConditionAutoSaveWorkingCopies.delete(workingCopy.resource);\n\t\tthis.waitingOnConditionAutoSaveEditors.delete(workingCopy.resource);\n\t}\n}\n"]}