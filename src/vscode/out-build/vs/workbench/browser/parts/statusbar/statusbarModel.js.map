{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/browser/parts/statusbar/statusbarModel.ts","vs/workbench/browser/parts/statusbar/statusbarModel.ts"],"names":[],"mappings":"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","file":"statusbarModel.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { isStatusbarEntryLocation, IStatusbarEntryPriority, StatusbarAlignment } from '../../../services/statusbar/browser/statusbar.js';\nimport { hide, show, isAncestorOfActiveElement } from '../../../../base/browser/dom.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { Emitter } from '../../../../base/common/event.js';\n\nexport interface IStatusbarViewModelEntry {\n\treadonly id: string;\n\treadonly extensionId: string | undefined;\n\treadonly name: string;\n\treadonly hasCommand: boolean;\n\treadonly alignment: StatusbarAlignment;\n\treadonly priority: IStatusbarEntryPriority;\n\treadonly container: HTMLElement;\n\treadonly labelContainer: HTMLElement;\n}\n\nexport class StatusbarViewModel extends Disposable {\n\n\tprivate static readonly HIDDEN_ENTRIES_KEY = 'workbench.statusbar.hidden';\n\n\tprivate readonly _onDidChangeEntryVisibility = this._register(new Emitter<{ id: string; visible: boolean }>());\n\treadonly onDidChangeEntryVisibility = this._onDidChangeEntryVisibility.event;\n\n\tprivate _entries: IStatusbarViewModelEntry[] = []; // Intentionally not using a map here since multiple entries can have the same ID\n\tget entries(): IStatusbarViewModelEntry[] { return this._entries.slice(0); }\n\n\tprivate _lastFocusedEntry: IStatusbarViewModelEntry | undefined;\n\tget lastFocusedEntry(): IStatusbarViewModelEntry | undefined {\n\t\treturn this._lastFocusedEntry && !this.isHidden(this._lastFocusedEntry.id) ? this._lastFocusedEntry : undefined;\n\t}\n\n\tprivate hidden = new Set<string>();\n\n\tconstructor(private readonly storageService: IStorageService) {\n\t\tsuper();\n\n\t\tthis.restoreState();\n\t\tthis.registerListeners();\n\t}\n\n\tprivate restoreState(): void {\n\t\tconst hiddenRaw = this.storageService.get(StatusbarViewModel.HIDDEN_ENTRIES_KEY, StorageScope.PROFILE);\n\t\tif (hiddenRaw) {\n\t\t\ttry {\n\t\t\t\tthis.hidden = new Set(JSON.parse(hiddenRaw));\n\t\t\t} catch (error) {\n\t\t\t\t// ignore parsing errors\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.storageService.onDidChangeValue(StorageScope.PROFILE, StatusbarViewModel.HIDDEN_ENTRIES_KEY, this._store)(() => this.onDidStorageValueChange()));\n\t}\n\n\tprivate onDidStorageValueChange(): void {\n\n\t\t// Keep current hidden entries\n\t\tconst currentlyHidden = new Set(this.hidden);\n\n\t\t// Load latest state of hidden entries\n\t\tthis.hidden.clear();\n\t\tthis.restoreState();\n\n\t\tconst changed = new Set<string>();\n\n\t\t// Check for each entry that is now visible\n\t\tfor (const id of currentlyHidden) {\n\t\t\tif (!this.hidden.has(id)) {\n\t\t\t\tchanged.add(id);\n\t\t\t}\n\t\t}\n\n\t\t// Check for each entry that is now hidden\n\t\tfor (const id of this.hidden) {\n\t\t\tif (!currentlyHidden.has(id)) {\n\t\t\t\tchanged.add(id);\n\t\t\t}\n\t\t}\n\n\t\t// Update visibility for entries have changed\n\t\tif (changed.size > 0) {\n\t\t\tfor (const entry of this._entries) {\n\t\t\t\tif (changed.has(entry.id)) {\n\t\t\t\t\tthis.updateVisibility(entry.id, true);\n\n\t\t\t\t\tchanged.delete(entry.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tadd(entry: IStatusbarViewModelEntry): void {\n\n\t\t// Add to set of entries\n\t\tthis._entries.push(entry);\n\n\t\t// Update visibility directly\n\t\tthis.updateVisibility(entry, false);\n\n\t\t// Sort according to priority\n\t\tthis.sort();\n\n\t\t// Mark first/last visible entry\n\t\tthis.markFirstLastVisibleEntry();\n\t}\n\n\tremove(entry: IStatusbarViewModelEntry): void {\n\t\tconst index = this._entries.indexOf(entry);\n\t\tif (index >= 0) {\n\n\t\t\t// Remove from entries\n\t\t\tthis._entries.splice(index, 1);\n\n\t\t\t// Re-sort entries if this one was used\n\t\t\t// as reference from other entries\n\t\t\tif (this._entries.some(otherEntry => isStatusbarEntryLocation(otherEntry.priority.primary) && otherEntry.priority.primary.location.id === entry.id)) {\n\t\t\t\tthis.sort();\n\t\t\t}\n\n\t\t\t// Mark first/last visible entry\n\t\t\tthis.markFirstLastVisibleEntry();\n\t\t}\n\t}\n\n\tisHidden(id: string): boolean {\n\t\treturn this.hidden.has(id);\n\t}\n\n\thide(id: string): void {\n\t\tif (!this.hidden.has(id)) {\n\t\t\tthis.hidden.add(id);\n\n\t\t\tthis.updateVisibility(id, true);\n\n\t\t\tthis.saveState();\n\t\t}\n\t}\n\n\tshow(id: string): void {\n\t\tif (this.hidden.has(id)) {\n\t\t\tthis.hidden.delete(id);\n\n\t\t\tthis.updateVisibility(id, true);\n\n\t\t\tthis.saveState();\n\t\t}\n\t}\n\n\tfindEntry(container: HTMLElement): IStatusbarViewModelEntry | undefined {\n\t\treturn this._entries.find(entry => entry.container === container);\n\t}\n\n\tgetEntries(alignment: StatusbarAlignment): IStatusbarViewModelEntry[] {\n\t\treturn this._entries.filter(entry => entry.alignment === alignment);\n\t}\n\n\tfocusNextEntry(): void {\n\t\tthis.focusEntry(+1, 0);\n\t}\n\n\tfocusPreviousEntry(): void {\n\t\tthis.focusEntry(-1, this.entries.length - 1);\n\t}\n\n\tisEntryFocused(): boolean {\n\t\treturn !!this.getFocusedEntry();\n\t}\n\n\tprivate getFocusedEntry(): IStatusbarViewModelEntry | undefined {\n\t\treturn this._entries.find(entry => isAncestorOfActiveElement(entry.container));\n\t}\n\n\tprivate focusEntry(delta: number, restartPosition: number): void {\n\n\t\tconst getVisibleEntry = (start: number) => {\n\t\t\tlet indexToFocus = start;\n\t\t\tlet entry = (indexToFocus >= 0 && indexToFocus < this._entries.length) ? this._entries[indexToFocus] : undefined;\n\t\t\twhile (entry && this.isHidden(entry.id)) {\n\t\t\t\tindexToFocus += delta;\n\t\t\t\tentry = (indexToFocus >= 0 && indexToFocus < this._entries.length) ? this._entries[indexToFocus] : undefined;\n\t\t\t}\n\n\t\t\treturn entry;\n\t\t};\n\n\t\tconst focused = this.getFocusedEntry();\n\t\tif (focused) {\n\t\t\tconst entry = getVisibleEntry(this._entries.indexOf(focused) + delta);\n\t\t\tif (entry) {\n\t\t\t\tthis._lastFocusedEntry = entry;\n\n\t\t\t\tentry.labelContainer.focus();\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst entry = getVisibleEntry(restartPosition);\n\t\tif (entry) {\n\t\t\tthis._lastFocusedEntry = entry;\n\t\t\tentry.labelContainer.focus();\n\t\t}\n\t}\n\n\tprivate updateVisibility(id: string, trigger: boolean): void;\n\tprivate updateVisibility(entry: IStatusbarViewModelEntry, trigger: boolean): void;\n\tprivate updateVisibility(arg1: string | IStatusbarViewModelEntry, trigger: boolean): void {\n\n\t\t// By identifier\n\t\tif (typeof arg1 === 'string') {\n\t\t\tconst id = arg1;\n\n\t\t\tfor (const entry of this._entries) {\n\t\t\t\tif (entry.id === id) {\n\t\t\t\t\tthis.updateVisibility(entry, trigger);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// By entry\n\t\telse {\n\t\t\tconst entry = arg1;\n\t\t\tconst isHidden = this.isHidden(entry.id);\n\n\t\t\t// Use CSS to show/hide item container\n\t\t\tif (isHidden) {\n\t\t\t\thide(entry.container);\n\t\t\t} else {\n\t\t\t\tshow(entry.container);\n\t\t\t}\n\n\t\t\tif (trigger) {\n\t\t\t\tthis._onDidChangeEntryVisibility.fire({ id: entry.id, visible: !isHidden });\n\t\t\t}\n\n\t\t\t// Mark first/last visible entry\n\t\t\tthis.markFirstLastVisibleEntry();\n\t\t}\n\t}\n\n\tprivate saveState(): void {\n\t\tif (this.hidden.size > 0) {\n\t\t\tthis.storageService.store(StatusbarViewModel.HIDDEN_ENTRIES_KEY, JSON.stringify(Array.from(this.hidden.values())), StorageScope.PROFILE, StorageTarget.USER);\n\t\t} else {\n\t\t\tthis.storageService.remove(StatusbarViewModel.HIDDEN_ENTRIES_KEY, StorageScope.PROFILE);\n\t\t}\n\t}\n\n\tprivate sort(): void {\n\t\tconst allEntryIds = new Set(this._entries.map(entry => entry.id));\n\n\t\t// Split up entries into 2 buckets:\n\t\t// - those with priority as number that can be compared or with a missing relative entry\n\t\t// - those with a relative priority that must be sorted relative to another entry that exists\n\t\tconst mapEntryWithNumberedPriorityToIndex = new Map<IStatusbarViewModelEntry, number /* priority of entry as number */>();\n\t\tconst mapEntryWithRelativePriority = new Map<string /* id of entry to position after */, Map<string, IStatusbarViewModelEntry>>();\n\t\tfor (let i = 0; i < this._entries.length; i++) {\n\t\t\tconst entry = this._entries[i];\n\t\t\tif (typeof entry.priority.primary === 'number' || !allEntryIds.has(entry.priority.primary.location.id)) {\n\t\t\t\tmapEntryWithNumberedPriorityToIndex.set(entry, i);\n\t\t\t} else {\n\t\t\t\tconst referenceEntryId = entry.priority.primary.location.id;\n\t\t\t\tlet entries = mapEntryWithRelativePriority.get(referenceEntryId);\n\t\t\t\tif (!entries) {\n\n\t\t\t\t\t// It is possible that this entry references another entry\n\t\t\t\t\t// that itself references an entry. In that case, we want\n\t\t\t\t\t// to add it to the entries of the referenced entry.\n\n\t\t\t\t\tfor (const relativeEntries of mapEntryWithRelativePriority.values()) {\n\t\t\t\t\t\tif (relativeEntries.has(referenceEntryId)) {\n\t\t\t\t\t\t\tentries = relativeEntries;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!entries) {\n\t\t\t\t\t\tentries = new Map();\n\t\t\t\t\t\tmapEntryWithRelativePriority.set(referenceEntryId, entries);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tentries.set(entry.id, entry);\n\t\t\t}\n\t\t}\n\n\t\t// Sort the entries with `priority: number` or referencing a missing entry accordingly\n\t\tconst sortedEntriesWithNumberedPriority = Array.from(mapEntryWithNumberedPriorityToIndex.keys());\n\t\tsortedEntriesWithNumberedPriority.sort((entryA, entryB) => {\n\t\t\tif (entryA.alignment === entryB.alignment) {\n\n\t\t\t\t// Sort by primary/secondary priority: higher values move towards the left\n\n\t\t\t\tconst entryAPrimaryPriority = typeof entryA.priority.primary === 'number' ? entryA.priority.primary : entryA.priority.primary.location.priority;\n\t\t\t\tconst entryBPrimaryPriority = typeof entryB.priority.primary === 'number' ? entryB.priority.primary : entryB.priority.primary.location.priority;\n\n\t\t\t\tif (entryAPrimaryPriority !== entryBPrimaryPriority) {\n\t\t\t\t\treturn entryBPrimaryPriority - entryAPrimaryPriority;\n\t\t\t\t}\n\n\t\t\t\tif (entryA.priority.secondary !== entryB.priority.secondary) {\n\t\t\t\t\treturn entryB.priority.secondary - entryA.priority.secondary;\n\t\t\t\t}\n\n\t\t\t\t// otherwise maintain stable order (both values known to be in map)\n\t\t\t\treturn mapEntryWithNumberedPriorityToIndex.get(entryA)! - mapEntryWithNumberedPriorityToIndex.get(entryB)!;\n\t\t\t}\n\n\t\t\tif (entryA.alignment === StatusbarAlignment.LEFT) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (entryB.alignment === StatusbarAlignment.LEFT) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t});\n\n\t\tlet sortedEntries: IStatusbarViewModelEntry[];\n\n\t\t// Entries with location: sort in accordingly\n\t\tif (mapEntryWithRelativePriority.size > 0) {\n\t\t\tsortedEntries = [];\n\n\t\t\tfor (const entry of sortedEntriesWithNumberedPriority) {\n\t\t\t\tconst relativeEntriesMap = mapEntryWithRelativePriority.get(entry.id);\n\t\t\t\tconst relativeEntries = relativeEntriesMap ? Array.from(relativeEntriesMap.values()) : undefined;\n\n\t\t\t\t// Fill relative entries to LEFT\n\t\t\t\tif (relativeEntries) {\n\t\t\t\t\tsortedEntries.push(...relativeEntries\n\t\t\t\t\t\t.filter(entry => isStatusbarEntryLocation(entry.priority.primary) && entry.priority.primary.alignment === StatusbarAlignment.LEFT)\n\t\t\t\t\t\t.sort((entryA, entryB) => entryB.priority.secondary - entryA.priority.secondary));\n\t\t\t\t}\n\n\t\t\t\t// Fill referenced entry\n\t\t\t\tsortedEntries.push(entry);\n\n\t\t\t\t// Fill relative entries to RIGHT\n\t\t\t\tif (relativeEntries) {\n\t\t\t\t\tsortedEntries.push(...relativeEntries\n\t\t\t\t\t\t.filter(entry => isStatusbarEntryLocation(entry.priority.primary) && entry.priority.primary.alignment === StatusbarAlignment.RIGHT)\n\t\t\t\t\t\t.sort((entryA, entryB) => entryB.priority.secondary - entryA.priority.secondary));\n\t\t\t\t}\n\n\t\t\t\t// Delete from map to mark as handled\n\t\t\t\tmapEntryWithRelativePriority.delete(entry.id);\n\t\t\t}\n\n\t\t\t// Finally, just append all entries that reference another entry\n\t\t\t// that does not exist to the end of the list\n\t\t\t//\n\t\t\t// Note: this should really not happen because of our check in\n\t\t\t// `allEntryIds`, but we play it safe here to really consume\n\t\t\t// all entries.\n\t\t\t//\n\t\t\tfor (const [, entries] of mapEntryWithRelativePriority) {\n\t\t\t\tsortedEntries.push(...Array.from(entries.values()).sort((entryA, entryB) => entryB.priority.secondary - entryA.priority.secondary));\n\t\t\t}\n\t\t}\n\n\t\t// No entries with relative priority: take sorted entries as is\n\t\telse {\n\t\t\tsortedEntries = sortedEntriesWithNumberedPriority;\n\t\t}\n\n\t\t// Take over as new truth of entries\n\t\tthis._entries = sortedEntries;\n\t}\n\n\tprivate markFirstLastVisibleEntry(): void {\n\t\tthis.doMarkFirstLastVisibleStatusbarItem(this.getEntries(StatusbarAlignment.LEFT));\n\t\tthis.doMarkFirstLastVisibleStatusbarItem(this.getEntries(StatusbarAlignment.RIGHT));\n\t}\n\n\tprivate doMarkFirstLastVisibleStatusbarItem(entries: IStatusbarViewModelEntry[]): void {\n\t\tlet firstVisibleItem: IStatusbarViewModelEntry | undefined;\n\t\tlet lastVisibleItem: IStatusbarViewModelEntry | undefined;\n\n\t\tfor (const entry of entries) {\n\n\t\t\t// Clear previous first\n\t\t\tentry.container.classList.remove('first-visible-item', 'last-visible-item');\n\n\t\t\tconst isVisible = !this.isHidden(entry.id);\n\t\t\tif (isVisible) {\n\t\t\t\tif (!firstVisibleItem) {\n\t\t\t\t\tfirstVisibleItem = entry;\n\t\t\t\t}\n\n\t\t\t\tlastVisibleItem = entry;\n\t\t\t}\n\t\t}\n\n\t\t// Mark: first visible item\n\t\tfirstVisibleItem?.container.classList.add('first-visible-item');\n\n\t\t// Mark: last visible item\n\t\tlastVisibleItem?.container.classList.add('last-visible-item');\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { isStatusbarEntryLocation, IStatusbarEntryPriority, StatusbarAlignment } from '../../../services/statusbar/browser/statusbar.js';\nimport { hide, show, isAncestorOfActiveElement } from '../../../../base/browser/dom.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { Emitter } from '../../../../base/common/event.js';\n\nexport interface IStatusbarViewModelEntry {\n\treadonly id: string;\n\treadonly extensionId: string | undefined;\n\treadonly name: string;\n\treadonly hasCommand: boolean;\n\treadonly alignment: StatusbarAlignment;\n\treadonly priority: IStatusbarEntryPriority;\n\treadonly container: HTMLElement;\n\treadonly labelContainer: HTMLElement;\n}\n\nexport class StatusbarViewModel extends Disposable {\n\n\tprivate static readonly HIDDEN_ENTRIES_KEY = 'workbench.statusbar.hidden';\n\n\tprivate readonly _onDidChangeEntryVisibility = this._register(new Emitter<{ id: string; visible: boolean }>());\n\treadonly onDidChangeEntryVisibility = this._onDidChangeEntryVisibility.event;\n\n\tprivate _entries: IStatusbarViewModelEntry[] = []; // Intentionally not using a map here since multiple entries can have the same ID\n\tget entries(): IStatusbarViewModelEntry[] { return this._entries.slice(0); }\n\n\tprivate _lastFocusedEntry: IStatusbarViewModelEntry | undefined;\n\tget lastFocusedEntry(): IStatusbarViewModelEntry | undefined {\n\t\treturn this._lastFocusedEntry && !this.isHidden(this._lastFocusedEntry.id) ? this._lastFocusedEntry : undefined;\n\t}\n\n\tprivate hidden = new Set<string>();\n\n\tconstructor(private readonly storageService: IStorageService) {\n\t\tsuper();\n\n\t\tthis.restoreState();\n\t\tthis.registerListeners();\n\t}\n\n\tprivate restoreState(): void {\n\t\tconst hiddenRaw = this.storageService.get(StatusbarViewModel.HIDDEN_ENTRIES_KEY, StorageScope.PROFILE);\n\t\tif (hiddenRaw) {\n\t\t\ttry {\n\t\t\t\tthis.hidden = new Set(JSON.parse(hiddenRaw));\n\t\t\t} catch (error) {\n\t\t\t\t// ignore parsing errors\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.storageService.onDidChangeValue(StorageScope.PROFILE, StatusbarViewModel.HIDDEN_ENTRIES_KEY, this._store)(() => this.onDidStorageValueChange()));\n\t}\n\n\tprivate onDidStorageValueChange(): void {\n\n\t\t// Keep current hidden entries\n\t\tconst currentlyHidden = new Set(this.hidden);\n\n\t\t// Load latest state of hidden entries\n\t\tthis.hidden.clear();\n\t\tthis.restoreState();\n\n\t\tconst changed = new Set<string>();\n\n\t\t// Check for each entry that is now visible\n\t\tfor (const id of currentlyHidden) {\n\t\t\tif (!this.hidden.has(id)) {\n\t\t\t\tchanged.add(id);\n\t\t\t}\n\t\t}\n\n\t\t// Check for each entry that is now hidden\n\t\tfor (const id of this.hidden) {\n\t\t\tif (!currentlyHidden.has(id)) {\n\t\t\t\tchanged.add(id);\n\t\t\t}\n\t\t}\n\n\t\t// Update visibility for entries have changed\n\t\tif (changed.size > 0) {\n\t\t\tfor (const entry of this._entries) {\n\t\t\t\tif (changed.has(entry.id)) {\n\t\t\t\t\tthis.updateVisibility(entry.id, true);\n\n\t\t\t\t\tchanged.delete(entry.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tadd(entry: IStatusbarViewModelEntry): void {\n\n\t\t// Add to set of entries\n\t\tthis._entries.push(entry);\n\n\t\t// Update visibility directly\n\t\tthis.updateVisibility(entry, false);\n\n\t\t// Sort according to priority\n\t\tthis.sort();\n\n\t\t// Mark first/last visible entry\n\t\tthis.markFirstLastVisibleEntry();\n\t}\n\n\tremove(entry: IStatusbarViewModelEntry): void {\n\t\tconst index = this._entries.indexOf(entry);\n\t\tif (index >= 0) {\n\n\t\t\t// Remove from entries\n\t\t\tthis._entries.splice(index, 1);\n\n\t\t\t// Re-sort entries if this one was used\n\t\t\t// as reference from other entries\n\t\t\tif (this._entries.some(otherEntry => isStatusbarEntryLocation(otherEntry.priority.primary) && otherEntry.priority.primary.location.id === entry.id)) {\n\t\t\t\tthis.sort();\n\t\t\t}\n\n\t\t\t// Mark first/last visible entry\n\t\t\tthis.markFirstLastVisibleEntry();\n\t\t}\n\t}\n\n\tisHidden(id: string): boolean {\n\t\treturn this.hidden.has(id);\n\t}\n\n\thide(id: string): void {\n\t\tif (!this.hidden.has(id)) {\n\t\t\tthis.hidden.add(id);\n\n\t\t\tthis.updateVisibility(id, true);\n\n\t\t\tthis.saveState();\n\t\t}\n\t}\n\n\tshow(id: string): void {\n\t\tif (this.hidden.has(id)) {\n\t\t\tthis.hidden.delete(id);\n\n\t\t\tthis.updateVisibility(id, true);\n\n\t\t\tthis.saveState();\n\t\t}\n\t}\n\n\tfindEntry(container: HTMLElement): IStatusbarViewModelEntry | undefined {\n\t\treturn this._entries.find(entry => entry.container === container);\n\t}\n\n\tgetEntries(alignment: StatusbarAlignment): IStatusbarViewModelEntry[] {\n\t\treturn this._entries.filter(entry => entry.alignment === alignment);\n\t}\n\n\tfocusNextEntry(): void {\n\t\tthis.focusEntry(+1, 0);\n\t}\n\n\tfocusPreviousEntry(): void {\n\t\tthis.focusEntry(-1, this.entries.length - 1);\n\t}\n\n\tisEntryFocused(): boolean {\n\t\treturn !!this.getFocusedEntry();\n\t}\n\n\tprivate getFocusedEntry(): IStatusbarViewModelEntry | undefined {\n\t\treturn this._entries.find(entry => isAncestorOfActiveElement(entry.container));\n\t}\n\n\tprivate focusEntry(delta: number, restartPosition: number): void {\n\n\t\tconst getVisibleEntry = (start: number) => {\n\t\t\tlet indexToFocus = start;\n\t\t\tlet entry = (indexToFocus >= 0 && indexToFocus < this._entries.length) ? this._entries[indexToFocus] : undefined;\n\t\t\twhile (entry && this.isHidden(entry.id)) {\n\t\t\t\tindexToFocus += delta;\n\t\t\t\tentry = (indexToFocus >= 0 && indexToFocus < this._entries.length) ? this._entries[indexToFocus] : undefined;\n\t\t\t}\n\n\t\t\treturn entry;\n\t\t};\n\n\t\tconst focused = this.getFocusedEntry();\n\t\tif (focused) {\n\t\t\tconst entry = getVisibleEntry(this._entries.indexOf(focused) + delta);\n\t\t\tif (entry) {\n\t\t\t\tthis._lastFocusedEntry = entry;\n\n\t\t\t\tentry.labelContainer.focus();\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst entry = getVisibleEntry(restartPosition);\n\t\tif (entry) {\n\t\t\tthis._lastFocusedEntry = entry;\n\t\t\tentry.labelContainer.focus();\n\t\t}\n\t}\n\n\tprivate updateVisibility(id: string, trigger: boolean): void;\n\tprivate updateVisibility(entry: IStatusbarViewModelEntry, trigger: boolean): void;\n\tprivate updateVisibility(arg1: string | IStatusbarViewModelEntry, trigger: boolean): void {\n\n\t\t// By identifier\n\t\tif (typeof arg1 === 'string') {\n\t\t\tconst id = arg1;\n\n\t\t\tfor (const entry of this._entries) {\n\t\t\t\tif (entry.id === id) {\n\t\t\t\t\tthis.updateVisibility(entry, trigger);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// By entry\n\t\telse {\n\t\t\tconst entry = arg1;\n\t\t\tconst isHidden = this.isHidden(entry.id);\n\n\t\t\t// Use CSS to show/hide item container\n\t\t\tif (isHidden) {\n\t\t\t\thide(entry.container);\n\t\t\t} else {\n\t\t\t\tshow(entry.container);\n\t\t\t}\n\n\t\t\tif (trigger) {\n\t\t\t\tthis._onDidChangeEntryVisibility.fire({ id: entry.id, visible: !isHidden });\n\t\t\t}\n\n\t\t\t// Mark first/last visible entry\n\t\t\tthis.markFirstLastVisibleEntry();\n\t\t}\n\t}\n\n\tprivate saveState(): void {\n\t\tif (this.hidden.size > 0) {\n\t\t\tthis.storageService.store(StatusbarViewModel.HIDDEN_ENTRIES_KEY, JSON.stringify(Array.from(this.hidden.values())), StorageScope.PROFILE, StorageTarget.USER);\n\t\t} else {\n\t\t\tthis.storageService.remove(StatusbarViewModel.HIDDEN_ENTRIES_KEY, StorageScope.PROFILE);\n\t\t}\n\t}\n\n\tprivate sort(): void {\n\t\tconst allEntryIds = new Set(this._entries.map(entry => entry.id));\n\n\t\t// Split up entries into 2 buckets:\n\t\t// - those with priority as number that can be compared or with a missing relative entry\n\t\t// - those with a relative priority that must be sorted relative to another entry that exists\n\t\tconst mapEntryWithNumberedPriorityToIndex = new Map<IStatusbarViewModelEntry, number /* priority of entry as number */>();\n\t\tconst mapEntryWithRelativePriority = new Map<string /* id of entry to position after */, Map<string, IStatusbarViewModelEntry>>();\n\t\tfor (let i = 0; i < this._entries.length; i++) {\n\t\t\tconst entry = this._entries[i];\n\t\t\tif (typeof entry.priority.primary === 'number' || !allEntryIds.has(entry.priority.primary.location.id)) {\n\t\t\t\tmapEntryWithNumberedPriorityToIndex.set(entry, i);\n\t\t\t} else {\n\t\t\t\tconst referenceEntryId = entry.priority.primary.location.id;\n\t\t\t\tlet entries = mapEntryWithRelativePriority.get(referenceEntryId);\n\t\t\t\tif (!entries) {\n\n\t\t\t\t\t// It is possible that this entry references another entry\n\t\t\t\t\t// that itself references an entry. In that case, we want\n\t\t\t\t\t// to add it to the entries of the referenced entry.\n\n\t\t\t\t\tfor (const relativeEntries of mapEntryWithRelativePriority.values()) {\n\t\t\t\t\t\tif (relativeEntries.has(referenceEntryId)) {\n\t\t\t\t\t\t\tentries = relativeEntries;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!entries) {\n\t\t\t\t\t\tentries = new Map();\n\t\t\t\t\t\tmapEntryWithRelativePriority.set(referenceEntryId, entries);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tentries.set(entry.id, entry);\n\t\t\t}\n\t\t}\n\n\t\t// Sort the entries with `priority: number` or referencing a missing entry accordingly\n\t\tconst sortedEntriesWithNumberedPriority = Array.from(mapEntryWithNumberedPriorityToIndex.keys());\n\t\tsortedEntriesWithNumberedPriority.sort((entryA, entryB) => {\n\t\t\tif (entryA.alignment === entryB.alignment) {\n\n\t\t\t\t// Sort by primary/secondary priority: higher values move towards the left\n\n\t\t\t\tconst entryAPrimaryPriority = typeof entryA.priority.primary === 'number' ? entryA.priority.primary : entryA.priority.primary.location.priority;\n\t\t\t\tconst entryBPrimaryPriority = typeof entryB.priority.primary === 'number' ? entryB.priority.primary : entryB.priority.primary.location.priority;\n\n\t\t\t\tif (entryAPrimaryPriority !== entryBPrimaryPriority) {\n\t\t\t\t\treturn entryBPrimaryPriority - entryAPrimaryPriority;\n\t\t\t\t}\n\n\t\t\t\tif (entryA.priority.secondary !== entryB.priority.secondary) {\n\t\t\t\t\treturn entryB.priority.secondary - entryA.priority.secondary;\n\t\t\t\t}\n\n\t\t\t\t// otherwise maintain stable order (both values known to be in map)\n\t\t\t\treturn mapEntryWithNumberedPriorityToIndex.get(entryA)! - mapEntryWithNumberedPriorityToIndex.get(entryB)!;\n\t\t\t}\n\n\t\t\tif (entryA.alignment === StatusbarAlignment.LEFT) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (entryB.alignment === StatusbarAlignment.LEFT) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t});\n\n\t\tlet sortedEntries: IStatusbarViewModelEntry[];\n\n\t\t// Entries with location: sort in accordingly\n\t\tif (mapEntryWithRelativePriority.size > 0) {\n\t\t\tsortedEntries = [];\n\n\t\t\tfor (const entry of sortedEntriesWithNumberedPriority) {\n\t\t\t\tconst relativeEntriesMap = mapEntryWithRelativePriority.get(entry.id);\n\t\t\t\tconst relativeEntries = relativeEntriesMap ? Array.from(relativeEntriesMap.values()) : undefined;\n\n\t\t\t\t// Fill relative entries to LEFT\n\t\t\t\tif (relativeEntries) {\n\t\t\t\t\tsortedEntries.push(...relativeEntries\n\t\t\t\t\t\t.filter(entry => isStatusbarEntryLocation(entry.priority.primary) && entry.priority.primary.alignment === StatusbarAlignment.LEFT)\n\t\t\t\t\t\t.sort((entryA, entryB) => entryB.priority.secondary - entryA.priority.secondary));\n\t\t\t\t}\n\n\t\t\t\t// Fill referenced entry\n\t\t\t\tsortedEntries.push(entry);\n\n\t\t\t\t// Fill relative entries to RIGHT\n\t\t\t\tif (relativeEntries) {\n\t\t\t\t\tsortedEntries.push(...relativeEntries\n\t\t\t\t\t\t.filter(entry => isStatusbarEntryLocation(entry.priority.primary) && entry.priority.primary.alignment === StatusbarAlignment.RIGHT)\n\t\t\t\t\t\t.sort((entryA, entryB) => entryB.priority.secondary - entryA.priority.secondary));\n\t\t\t\t}\n\n\t\t\t\t// Delete from map to mark as handled\n\t\t\t\tmapEntryWithRelativePriority.delete(entry.id);\n\t\t\t}\n\n\t\t\t// Finally, just append all entries that reference another entry\n\t\t\t// that does not exist to the end of the list\n\t\t\t//\n\t\t\t// Note: this should really not happen because of our check in\n\t\t\t// `allEntryIds`, but we play it safe here to really consume\n\t\t\t// all entries.\n\t\t\t//\n\t\t\tfor (const [, entries] of mapEntryWithRelativePriority) {\n\t\t\t\tsortedEntries.push(...Array.from(entries.values()).sort((entryA, entryB) => entryB.priority.secondary - entryA.priority.secondary));\n\t\t\t}\n\t\t}\n\n\t\t// No entries with relative priority: take sorted entries as is\n\t\telse {\n\t\t\tsortedEntries = sortedEntriesWithNumberedPriority;\n\t\t}\n\n\t\t// Take over as new truth of entries\n\t\tthis._entries = sortedEntries;\n\t}\n\n\tprivate markFirstLastVisibleEntry(): void {\n\t\tthis.doMarkFirstLastVisibleStatusbarItem(this.getEntries(StatusbarAlignment.LEFT));\n\t\tthis.doMarkFirstLastVisibleStatusbarItem(this.getEntries(StatusbarAlignment.RIGHT));\n\t}\n\n\tprivate doMarkFirstLastVisibleStatusbarItem(entries: IStatusbarViewModelEntry[]): void {\n\t\tlet firstVisibleItem: IStatusbarViewModelEntry | undefined;\n\t\tlet lastVisibleItem: IStatusbarViewModelEntry | undefined;\n\n\t\tfor (const entry of entries) {\n\n\t\t\t// Clear previous first\n\t\t\tentry.container.classList.remove('first-visible-item', 'last-visible-item');\n\n\t\t\tconst isVisible = !this.isHidden(entry.id);\n\t\t\tif (isVisible) {\n\t\t\t\tif (!firstVisibleItem) {\n\t\t\t\t\tfirstVisibleItem = entry;\n\t\t\t\t}\n\n\t\t\t\tlastVisibleItem = entry;\n\t\t\t}\n\t\t}\n\n\t\t// Mark: first visible item\n\t\tfirstVisibleItem?.container.classList.add('first-visible-item');\n\n\t\t// Mark: last visible item\n\t\tlastVisibleItem?.container.classList.add('last-visible-item');\n\t}\n}\n"]}