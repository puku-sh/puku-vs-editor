{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/test/common/workbenchTestServices.ts","vs/workbench/test/common/workbenchTestServices.ts"],"names":[],"mappings":"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","file":"workbenchTestServices.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from '../../../base/common/async.js';\nimport { bufferToStream, readableToBuffer, VSBuffer, VSBufferReadable } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { observableValue } from '../../../base/common/observable.js';\nimport { join } from '../../../base/common/path.js';\nimport { isLinux, isMacintosh } from '../../../base/common/platform.js';\nimport { basename, isEqual, isEqualOrParent } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ITextResourcePropertiesService } from '../../../editor/common/services/textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IResourceEditorInput } from '../../../platform/editor/common/editor.js';\nimport { FileChangesEvent, FileOperationEvent, FileSystemProviderCapabilities, IBaseFileStat, ICreateFileOptions, IFileContent, IFileService, IFileStat, IFileStatResult, IFileStatWithMetadata, IFileStatWithPartialMetadata, IFileStreamContent, IFileSystemProvider, IFileSystemProviderActivationEvent, IFileSystemProviderCapabilitiesChangeEvent, IFileSystemWatcher, IReadFileOptions, IReadFileStreamOptions, IResolveFileOptions, IResolveMetadataFileOptions, IWatchOptions, IWatchOptionsWithCorrelation, IWriteFileOptions } from '../../../platform/files/common/files.js';\nimport { AbstractLoggerService, ILogger, LogLevel, NullLogger } from '../../../platform/log/common/log.js';\nimport { IMarker, IMarkerData, IMarkerService, IResourceMarker, MarkerStatistics } from '../../../platform/markers/common/markers.js';\nimport product from '../../../platform/product/common/product.js';\nimport { IProgress, IProgressStep } from '../../../platform/progress/common/progress.js';\nimport { InMemoryStorageService, WillSaveStateReason } from '../../../platform/storage/common/storage.js';\nimport { toUserDataProfile } from '../../../platform/userDataProfile/common/userDataProfile.js';\nimport { ISingleFolderWorkspaceIdentifier, IWorkspace, IWorkspaceContextService, IWorkspaceFolder, IWorkspaceFoldersChangeEvent, IWorkspaceFoldersWillChangeEvent, IWorkspaceIdentifier, WorkbenchState, Workspace } from '../../../platform/workspace/common/workspace.js';\nimport { IWorkspaceTrustEnablementService, IWorkspaceTrustManagementService, IWorkspaceTrustRequestService, IWorkspaceTrustTransitionParticipant, IWorkspaceTrustUriInfo, WorkspaceTrustRequestOptions, WorkspaceTrustUriResponse } from '../../../platform/workspace/common/workspaceTrust.js';\nimport { TestWorkspace } from '../../../platform/workspace/test/common/testWorkspace.js';\nimport { GroupIdentifier, IRevertOptions, ISaveOptions, SaveReason } from '../../common/editor.js';\nimport { EditorInput } from '../../common/editor/editorInput.js';\nimport { IActivity, IActivityService } from '../../services/activity/common/activity.js';\nimport { ChatEntitlement, IChatEntitlementService } from '../../services/chat/common/chatEntitlementService.js';\nimport { NullExtensionService } from '../../services/extensions/common/extensions.js';\nimport { IAutoSaveConfiguration, IAutoSaveMode, IFilesConfigurationService } from '../../services/filesConfiguration/common/filesConfigurationService.js';\nimport { IHistoryService } from '../../services/history/common/history.js';\nimport { IResourceEncoding } from '../../services/textfile/common/textfiles.js';\nimport { IUserDataProfileService } from '../../services/userDataProfile/common/userDataProfile.js';\nimport { IStoredFileWorkingCopySaveEvent } from '../../services/workingCopy/common/storedFileWorkingCopy.js';\nimport { IWorkingCopy, IWorkingCopyBackup, WorkingCopyCapabilities } from '../../services/workingCopy/common/workingCopy.js';\nimport { ICopyOperation, ICreateFileOperation, ICreateOperation, IDeleteOperation, IFileOperationUndoRedoInfo, IMoveOperation, IStoredFileWorkingCopySaveParticipant, IStoredFileWorkingCopySaveParticipantContext, IWorkingCopyFileOperationParticipant, IWorkingCopyFileService, WorkingCopyFileEvent } from '../../services/workingCopy/common/workingCopyFileService.js';\n\nexport class TestLoggerService extends AbstractLoggerService {\n\tconstructor(logsHome?: URI) {\n\t\tsuper(LogLevel.Info, logsHome ?? URI.file('tests').with({ scheme: 'vscode-tests' }));\n\t}\n\tprotected doCreateLogger(): ILogger { return new NullLogger(); }\n}\n\nexport class TestTextResourcePropertiesService implements ITextResourcePropertiesService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t) {\n\t}\n\n\tgetEOL(resource: URI, language?: string): string {\n\t\tconst eol = this.configurationService.getValue('files.eol', { overrideIdentifier: language, resource });\n\t\tif (eol && typeof eol === 'string' && eol !== 'auto') {\n\t\t\treturn eol;\n\t\t}\n\t\treturn (isLinux || isMacintosh) ? '\\n' : '\\r\\n';\n\t}\n}\n\nexport class TestUserDataProfileService implements IUserDataProfileService {\n\n\treadonly _serviceBrand: undefined;\n\treadonly onDidChangeCurrentProfile = Event.None;\n\treadonly currentProfile = toUserDataProfile('test', 'test', URI.file('tests').with({ scheme: 'vscode-tests' }), URI.file('tests').with({ scheme: 'vscode-tests' }));\n\tasync updateCurrentProfile(): Promise<void> { }\n}\n\nexport class TestContextService implements IWorkspaceContextService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate workspace: Workspace;\n\tprivate options: object;\n\n\tprivate readonly _onDidChangeWorkspaceName: Emitter<void>;\n\tget onDidChangeWorkspaceName(): Event<void> { return this._onDidChangeWorkspaceName.event; }\n\n\tprivate readonly _onWillChangeWorkspaceFolders: Emitter<IWorkspaceFoldersWillChangeEvent>;\n\tget onWillChangeWorkspaceFolders(): Event<IWorkspaceFoldersWillChangeEvent> { return this._onWillChangeWorkspaceFolders.event; }\n\n\tprivate readonly _onDidChangeWorkspaceFolders: Emitter<IWorkspaceFoldersChangeEvent>;\n\tget onDidChangeWorkspaceFolders(): Event<IWorkspaceFoldersChangeEvent> { return this._onDidChangeWorkspaceFolders.event; }\n\n\tprivate readonly _onDidChangeWorkbenchState: Emitter<WorkbenchState>;\n\tget onDidChangeWorkbenchState(): Event<WorkbenchState> { return this._onDidChangeWorkbenchState.event; }\n\n\tconstructor(workspace = TestWorkspace, options = null) {\n\t\tthis.workspace = workspace;\n\t\tthis.options = options || Object.create(null);\n\t\tthis._onDidChangeWorkspaceName = new Emitter<void>();\n\t\tthis._onWillChangeWorkspaceFolders = new Emitter<IWorkspaceFoldersWillChangeEvent>();\n\t\tthis._onDidChangeWorkspaceFolders = new Emitter<IWorkspaceFoldersChangeEvent>();\n\t\tthis._onDidChangeWorkbenchState = new Emitter<WorkbenchState>();\n\t}\n\n\tgetFolders(): IWorkspaceFolder[] {\n\t\treturn this.workspace ? this.workspace.folders : [];\n\t}\n\n\tgetWorkbenchState(): WorkbenchState {\n\t\tif (this.workspace.configuration) {\n\t\t\treturn WorkbenchState.WORKSPACE;\n\t\t}\n\n\t\tif (this.workspace.folders.length) {\n\t\t\treturn WorkbenchState.FOLDER;\n\t\t}\n\n\t\treturn WorkbenchState.EMPTY;\n\t}\n\n\tgetCompleteWorkspace(): Promise<IWorkspace> {\n\t\treturn Promise.resolve(this.getWorkspace());\n\t}\n\n\tgetWorkspace(): IWorkspace {\n\t\treturn this.workspace;\n\t}\n\n\tgetWorkspaceFolder(resource: URI): IWorkspaceFolder | null {\n\t\treturn this.workspace.getFolder(resource);\n\t}\n\n\tsetWorkspace(workspace: any): void {\n\t\tthis.workspace = workspace;\n\t}\n\n\tgetOptions() {\n\t\treturn this.options;\n\t}\n\n\tupdateOptions() { }\n\n\tisInsideWorkspace(resource: URI): boolean {\n\t\tif (resource && this.workspace) {\n\t\t\treturn isEqualOrParent(resource, this.workspace.folders[0].uri);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\ttoResource(workspaceRelativePath: string): URI {\n\t\treturn URI.file(join('C:\\\\', workspaceRelativePath));\n\t}\n\n\tisCurrentWorkspace(workspaceIdOrFolder: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | URI): boolean {\n\t\treturn URI.isUri(workspaceIdOrFolder) && isEqual(this.workspace.folders[0].uri, workspaceIdOrFolder);\n\t}\n}\n\nexport class TestStorageService extends InMemoryStorageService {\n\n\ttestEmitWillSaveState(reason: WillSaveStateReason): void {\n\t\tsuper.emitWillSaveState(reason);\n\t}\n}\n\nexport class TestHistoryService implements IHistoryService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(private root?: URI) { }\n\n\tasync reopenLastClosedEditor(): Promise<void> { }\n\tasync goForward(): Promise<void> { }\n\tasync goBack(): Promise<void> { }\n\tasync goPrevious(): Promise<void> { }\n\tasync goLast(): Promise<void> { }\n\tremoveFromHistory(_input: EditorInput | IResourceEditorInput): void { }\n\tclear(): void { }\n\tclearRecentlyOpened(): void { }\n\tgetHistory(): readonly (EditorInput | IResourceEditorInput)[] { return []; }\n\tasync openNextRecentlyUsedEditor(group?: GroupIdentifier): Promise<void> { }\n\tasync openPreviouslyUsedEditor(group?: GroupIdentifier): Promise<void> { }\n\tgetLastActiveWorkspaceRoot(_schemeFilter: string): URI | undefined { return this.root; }\n\tgetLastActiveFile(_schemeFilter: string): URI | undefined { return undefined; }\n}\n\nexport class TestWorkingCopy extends Disposable implements IWorkingCopy {\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<void>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeContent = this._register(new Emitter<void>());\n\treadonly onDidChangeContent = this._onDidChangeContent.event;\n\n\tprivate readonly _onDidSave = this._register(new Emitter<IStoredFileWorkingCopySaveEvent>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\treadonly capabilities = WorkingCopyCapabilities.None;\n\n\treadonly name;\n\n\tprivate dirty = false;\n\n\tconstructor(readonly resource: URI, isDirty = false, readonly typeId = 'testWorkingCopyType') {\n\t\tsuper();\n\n\t\tthis.name = basename(this.resource);\n\t\tthis.dirty = isDirty;\n\t}\n\n\tsetDirty(dirty: boolean): void {\n\t\tif (this.dirty !== dirty) {\n\t\t\tthis.dirty = dirty;\n\t\t\tthis._onDidChangeDirty.fire();\n\t\t}\n\t}\n\n\tsetContent(content: string): void {\n\t\tthis._onDidChangeContent.fire();\n\t}\n\n\tisDirty(): boolean {\n\t\treturn this.dirty;\n\t}\n\n\tisModified(): boolean {\n\t\treturn this.isDirty();\n\t}\n\n\tasync save(options?: ISaveOptions, stat?: IFileStatWithMetadata): Promise<boolean> {\n\t\tthis._onDidSave.fire({ reason: options?.reason ?? SaveReason.EXPLICIT, stat: stat ?? createFileStat(this.resource), source: options?.source });\n\n\t\treturn true;\n\t}\n\n\tasync revert(options?: IRevertOptions): Promise<void> {\n\t\tthis.setDirty(false);\n\t}\n\n\tasync backup(token: CancellationToken): Promise<IWorkingCopyBackup> {\n\t\treturn {};\n\t}\n}\n\nexport function createFileStat(resource: URI, readonly = false, isFile?: boolean, isDirectory?: boolean, isSymbolicLink?: boolean, children?: { resource: URI; isFile?: boolean; isDirectory?: boolean; isSymbolicLink?: boolean }[] | undefined): IFileStatWithMetadata {\n\treturn {\n\t\tresource,\n\t\tetag: Date.now().toString(),\n\t\tmtime: Date.now(),\n\t\tctime: Date.now(),\n\t\tsize: 42,\n\t\tisFile: isFile ?? true,\n\t\tisDirectory: isDirectory ?? false,\n\t\tisSymbolicLink: isSymbolicLink ?? false,\n\t\treadonly,\n\t\tlocked: false,\n\t\tname: basename(resource),\n\t\tchildren: children?.map(c => createFileStat(c.resource, false, c.isFile, c.isDirectory, c.isSymbolicLink)),\n\t};\n}\n\nexport class TestWorkingCopyFileService implements IWorkingCopyFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\treadonly onWillRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent> = Event.None;\n\treadonly onDidFailWorkingCopyFileOperation: Event<WorkingCopyFileEvent> = Event.None;\n\treadonly onDidRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent> = Event.None;\n\n\taddFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable { return Disposable.None; }\n\n\treadonly hasSaveParticipants = false;\n\taddSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable { return Disposable.None; }\n\tasync runSaveParticipants(workingCopy: IWorkingCopy, context: IStoredFileWorkingCopySaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void> { }\n\n\tasync delete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void> { }\n\n\tregisterWorkingCopyProvider(provider: (resourceOrFolder: URI) => IWorkingCopy[]): IDisposable { return Disposable.None; }\n\n\tgetDirty(resource: URI): IWorkingCopy[] { return []; }\n\n\tcreate(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> { throw new Error('Method not implemented.'); }\n\tcreateFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> { throw new Error('Method not implemented.'); }\n\n\tmove(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> { throw new Error('Method not implemented.'); }\n\n\tcopy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> { throw new Error('Method not implemented.'); }\n}\n\nexport function mock<T>(): Ctor<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn function () { } as any;\n}\n\nexport interface Ctor<T> {\n\tnew(): T;\n}\n\nexport class TestExtensionService extends NullExtensionService { }\n\nexport const TestProductService = { _serviceBrand: undefined, ...product };\n\nexport class TestActivityService implements IActivityService {\n\t_serviceBrand: undefined;\n\tonDidChangeActivity = Event.None;\n\tgetViewContainerActivities(viewContainerId: string): IActivity[] {\n\t\treturn [];\n\t}\n\tgetActivity(id: string): IActivity[] {\n\t\treturn [];\n\t}\n\tshowViewContainerActivity(viewContainerId: string, badge: IActivity): IDisposable {\n\t\treturn this;\n\t}\n\tshowViewActivity(viewId: string, badge: IActivity): IDisposable {\n\t\treturn this;\n\t}\n\tshowAccountsActivity(activity: IActivity): IDisposable {\n\t\treturn this;\n\t}\n\tshowGlobalActivity(activity: IActivity): IDisposable {\n\t\treturn this;\n\t}\n\n\tdispose() { }\n}\n\nexport const NullFilesConfigurationService = new class implements IFilesConfigurationService {\n\n\t_serviceBrand: undefined;\n\n\treadonly onDidChangeAutoSaveConfiguration = Event.None;\n\treadonly onDidChangeAutoSaveDisabled = Event.None;\n\treadonly onDidChangeReadonly = Event.None;\n\treadonly onDidChangeFilesAssociation = Event.None;\n\n\treadonly isHotExitEnabled = false;\n\treadonly hotExitConfiguration = undefined;\n\n\tgetAutoSaveConfiguration(): IAutoSaveConfiguration { throw new Error('Method not implemented.'); }\n\tgetAutoSaveMode(): IAutoSaveMode { throw new Error('Method not implemented.'); }\n\thasShortAutoSaveDelay(): boolean { throw new Error('Method not implemented.'); }\n\ttoggleAutoSave(): Promise<void> { throw new Error('Method not implemented.'); }\n\tenableAutoSaveAfterShortDelay(resourceOrEditor: URI | EditorInput): IDisposable { throw new Error('Method not implemented.'); }\n\tdisableAutoSave(resourceOrEditor: URI | EditorInput): IDisposable { throw new Error('Method not implemented.'); }\n\tisReadonly(resource: URI, stat?: IBaseFileStat | undefined): boolean { return false; }\n\tasync updateReadonly(resource: URI, readonly: boolean | 'toggle' | 'reset'): Promise<void> { }\n\tpreventSaveConflicts(resource: URI, language?: string | undefined): boolean { throw new Error('Method not implemented.'); }\n};\n\nexport class TestWorkspaceTrustEnablementService implements IWorkspaceTrustEnablementService {\n\t_serviceBrand: undefined;\n\n\tconstructor(private isEnabled: boolean = true) { }\n\n\tisWorkspaceTrustEnabled(): boolean {\n\t\treturn this.isEnabled;\n\t}\n}\n\nexport class TestWorkspaceTrustManagementService extends Disposable implements IWorkspaceTrustManagementService {\n\t_serviceBrand: undefined;\n\n\tprivate _onDidChangeTrust = this._register(new Emitter<boolean>());\n\tonDidChangeTrust = this._onDidChangeTrust.event;\n\n\tprivate _onDidChangeTrustedFolders = this._register(new Emitter<void>());\n\tonDidChangeTrustedFolders = this._onDidChangeTrustedFolders.event;\n\n\tprivate _onDidInitiateWorkspaceTrustRequestOnStartup = this._register(new Emitter<void>());\n\tonDidInitiateWorkspaceTrustRequestOnStartup = this._onDidInitiateWorkspaceTrustRequestOnStartup.event;\n\n\n\tconstructor(\n\t\tprivate trusted: boolean = true\n\t) {\n\t\tsuper();\n\t}\n\n\tget acceptsOutOfWorkspaceFiles(): boolean {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tset acceptsOutOfWorkspaceFiles(value: boolean) {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\taddWorkspaceTrustTransitionParticipant(participant: IWorkspaceTrustTransitionParticipant): IDisposable {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tgetTrustedUris(): URI[] {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsetParentFolderTrust(trusted: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tgetUriTrustInfo(uri: URI): Promise<IWorkspaceTrustUriInfo> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync setTrustedUris(folders: URI[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync setUrisTrust(uris: URI[], trusted: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcanSetParentFolderTrust(): boolean {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcanSetWorkspaceTrust(): boolean {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tisWorkspaceTrusted(): boolean {\n\t\treturn this.trusted;\n\t}\n\n\tisWorkspaceTrustForced(): boolean {\n\t\treturn false;\n\t}\n\n\tget workspaceTrustInitialized(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tget workspaceResolved(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tasync setWorkspaceTrust(trusted: boolean): Promise<void> {\n\t\tif (this.trusted !== trusted) {\n\t\t\tthis.trusted = trusted;\n\t\t\tthis._onDidChangeTrust.fire(this.trusted);\n\t\t}\n\t}\n}\n\nexport class TestWorkspaceTrustRequestService extends Disposable implements IWorkspaceTrustRequestService {\n\t_serviceBrand: any;\n\n\tprivate readonly _onDidInitiateOpenFilesTrustRequest = this._register(new Emitter<void>());\n\treadonly onDidInitiateOpenFilesTrustRequest = this._onDidInitiateOpenFilesTrustRequest.event;\n\n\tprivate readonly _onDidInitiateWorkspaceTrustRequest = this._register(new Emitter<WorkspaceTrustRequestOptions>());\n\treadonly onDidInitiateWorkspaceTrustRequest = this._onDidInitiateWorkspaceTrustRequest.event;\n\n\tprivate readonly _onDidInitiateWorkspaceTrustRequestOnStartup = this._register(new Emitter<void>());\n\treadonly onDidInitiateWorkspaceTrustRequestOnStartup = this._onDidInitiateWorkspaceTrustRequestOnStartup.event;\n\n\tconstructor(private readonly _trusted: boolean) {\n\t\tsuper();\n\t}\n\n\trequestOpenUrisHandler = async (uris: URI[]) => {\n\t\treturn WorkspaceTrustUriResponse.Open;\n\t};\n\n\trequestOpenFilesTrust(uris: URI[]): Promise<WorkspaceTrustUriResponse> {\n\t\treturn this.requestOpenUrisHandler(uris);\n\t}\n\n\tasync completeOpenFilesTrustRequest(result: WorkspaceTrustUriResponse, saveResponse: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcancelWorkspaceTrustRequest(): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync completeWorkspaceTrustRequest(trusted?: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync requestWorkspaceTrust(options?: WorkspaceTrustRequestOptions): Promise<boolean> {\n\t\treturn this._trusted;\n\t}\n\n\trequestWorkspaceTrustOnStartup(): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n}\n\nexport class TestMarkerService implements IMarkerService {\n\n\t_serviceBrand: undefined;\n\n\tonMarkerChanged = Event.None;\n\n\tgetStatistics(): MarkerStatistics { throw new Error('Method not implemented.'); }\n\tchangeOne(owner: string, resource: URI, markers: IMarkerData[]): void { }\n\tchangeAll(owner: string, data: IResourceMarker[]): void { }\n\tremove(owner: string, resources: URI[]): void { }\n\tread(filter?: { owner?: string | undefined; resource?: URI | undefined; severities?: number | undefined; take?: number | undefined } | undefined): IMarker[] { return []; }\n\tinstallResourceFilter(resource: URI, reason: string): IDisposable {\n\t\treturn { dispose: () => { /* TODO: Implement cleanup logic */ } };\n\t}\n}\n\nexport class TestFileService implements IFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _onDidFilesChange = new Emitter<FileChangesEvent>();\n\tget onDidFilesChange(): Event<FileChangesEvent> { return this._onDidFilesChange.event; }\n\tfireFileChanges(event: FileChangesEvent): void { this._onDidFilesChange.fire(event); }\n\n\tprivate readonly _onDidRunOperation = new Emitter<FileOperationEvent>();\n\tget onDidRunOperation(): Event<FileOperationEvent> { return this._onDidRunOperation.event; }\n\tfireAfterOperation(event: FileOperationEvent): void { this._onDidRunOperation.fire(event); }\n\n\tprivate readonly _onDidChangeFileSystemProviderCapabilities = new Emitter<IFileSystemProviderCapabilitiesChangeEvent>();\n\tget onDidChangeFileSystemProviderCapabilities(): Event<IFileSystemProviderCapabilitiesChangeEvent> { return this._onDidChangeFileSystemProviderCapabilities.event; }\n\tfireFileSystemProviderCapabilitiesChangeEvent(event: IFileSystemProviderCapabilitiesChangeEvent): void { this._onDidChangeFileSystemProviderCapabilities.fire(event); }\n\n\tprivate _onWillActivateFileSystemProvider = new Emitter<IFileSystemProviderActivationEvent>();\n\treadonly onWillActivateFileSystemProvider = this._onWillActivateFileSystemProvider.event;\n\treadonly onDidWatchError = Event.None;\n\n\tprotected content = 'Hello Html';\n\tprotected lastReadFileUri!: URI;\n\n\treadonly = false;\n\n\t// Tracking functionality for tests\n\treadonly writeOperations: Array<{ resource: URI; content: string }> = [];\n\treadonly readOperations: Array<{ resource: URI }> = [];\n\n\tsetContent(content: string): void { this.content = content; }\n\tgetContent(): string { return this.content; }\n\tgetLastReadFileUri(): URI { return this.lastReadFileUri; }\n\n\t// Clear tracking data for tests\n\tclearTracking(): void {\n\t\tthis.writeOperations.length = 0;\n\t\tthis.readOperations.length = 0;\n\t}\n\n\tresolve(resource: URI, _options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tresolve(resource: URI, _options?: IResolveFileOptions): Promise<IFileStat>;\n\tasync resolve(resource: URI, _options?: IResolveFileOptions): Promise<IFileStat> {\n\t\treturn createFileStat(resource, this.readonly);\n\t}\n\n\tstat(resource: URI): Promise<IFileStatWithPartialMetadata> {\n\t\treturn this.resolve(resource, { resolveMetadata: true });\n\t}\n\n\tasync realpath(resource: URI): Promise<URI> {\n\t\treturn resource;\n\t}\n\n\tasync resolveAll(toResolve: { resource: URI; options?: IResolveFileOptions }[]): Promise<IFileStatResult[]> {\n\t\tconst stats = await Promise.all(toResolve.map(resourceAndOption => this.resolve(resourceAndOption.resource, resourceAndOption.options)));\n\n\t\treturn stats.map(stat => ({ stat, success: true }));\n\t}\n\n\treadonly notExistsSet = new ResourceMap<boolean>();\n\n\tasync exists(_resource: URI): Promise<boolean> { return !this.notExistsSet.has(_resource); }\n\n\treadShouldThrowError: Error | undefined = undefined;\n\n\tasync readFile(resource: URI, options?: IReadFileOptions | undefined): Promise<IFileContent> {\n\t\tif (this.readShouldThrowError) {\n\t\t\tthrow this.readShouldThrowError;\n\t\t}\n\n\t\tthis.lastReadFileUri = resource;\n\t\tthis.readOperations.push({ resource });\n\n\t\treturn {\n\t\t\t...createFileStat(resource, this.readonly),\n\t\t\tvalue: VSBuffer.fromString(this.content)\n\t\t};\n\t}\n\n\tasync readFileStream(resource: URI, options?: IReadFileStreamOptions | undefined): Promise<IFileStreamContent> {\n\t\tif (this.readShouldThrowError) {\n\t\t\tthrow this.readShouldThrowError;\n\t\t}\n\n\t\tthis.lastReadFileUri = resource;\n\n\t\treturn {\n\t\t\t...createFileStat(resource, this.readonly),\n\t\t\tvalue: bufferToStream(VSBuffer.fromString(this.content))\n\t\t};\n\t}\n\n\twriteShouldThrowError: Error | undefined = undefined;\n\n\tasync writeFile(resource: URI, bufferOrReadable: VSBuffer | VSBufferReadable, options?: IWriteFileOptions): Promise<IFileStatWithMetadata> {\n\t\tawait timeout(0);\n\n\t\tif (this.writeShouldThrowError) {\n\t\t\tthrow this.writeShouldThrowError;\n\t\t}\n\n\t\tlet content: VSBuffer | undefined;\n\t\tif (bufferOrReadable instanceof VSBuffer) {\n\t\t\tcontent = bufferOrReadable;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcontent = readableToBuffer(bufferOrReadable);\n\t\t\t} catch {\n\t\t\t\t// Some preexisting tests are writing with invalid objects\n\t\t\t}\n\t\t}\n\n\t\tif (content) {\n\t\t\tthis.writeOperations.push({ resource, content: content.toString() });\n\t\t}\n\n\t\treturn createFileStat(resource, this.readonly);\n\t}\n\n\tmove(_source: URI, _target: URI, _overwrite?: boolean): Promise<IFileStatWithMetadata> { return Promise.resolve(null!); }\n\tcopy(_source: URI, _target: URI, _overwrite?: boolean): Promise<IFileStatWithMetadata> { return Promise.resolve(null!); }\n\tasync cloneFile(_source: URI, _target: URI): Promise<void> { }\n\tcreateFile(_resource: URI, _content?: VSBuffer | VSBufferReadable, _options?: ICreateFileOptions): Promise<IFileStatWithMetadata> { return Promise.resolve(null!); }\n\tcreateFolder(_resource: URI): Promise<IFileStatWithMetadata> { return Promise.resolve(null!); }\n\n\tonDidChangeFileSystemProviderRegistrations = Event.None;\n\n\tprivate providers = new Map<string, IFileSystemProvider>();\n\n\tregisterProvider(scheme: string, provider: IFileSystemProvider) {\n\t\tthis.providers.set(scheme, provider);\n\n\t\treturn toDisposable(() => this.providers.delete(scheme));\n\t}\n\n\tgetProvider(scheme: string) {\n\t\treturn this.providers.get(scheme);\n\t}\n\n\tasync activateProvider(_scheme: string): Promise<void> {\n\t\tthis._onWillActivateFileSystemProvider.fire({ scheme: _scheme, join: () => { } });\n\t}\n\tasync canHandleResource(resource: URI): Promise<boolean> { return this.hasProvider(resource); }\n\thasProvider(resource: URI): boolean { return resource.scheme === Schemas.file || this.providers.has(resource.scheme); }\n\tlistCapabilities() {\n\t\treturn [\n\t\t\t{ scheme: Schemas.file, capabilities: FileSystemProviderCapabilities.FileOpenReadWriteClose },\n\t\t\t...Iterable.map(this.providers, ([scheme, p]) => { return { scheme, capabilities: p.capabilities }; })\n\t\t];\n\t}\n\thasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\n\t\tif (capability === FileSystemProviderCapabilities.PathCaseSensitive && isLinux) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst provider = this.getProvider(resource.scheme);\n\n\t\treturn !!(provider && (provider.capabilities & capability));\n\t}\n\n\tasync del(_resource: URI, _options?: { useTrash?: boolean; recursive?: boolean }): Promise<void> { }\n\n\tcreateWatcher(resource: URI, options: IWatchOptions): IFileSystemWatcher {\n\t\treturn {\n\t\t\tonDidChange: Event.None,\n\t\t\tdispose: () => { }\n\t\t};\n\t}\n\n\n\treadonly watches: URI[] = [];\n\twatch(_resource: URI, options: IWatchOptionsWithCorrelation): IFileSystemWatcher;\n\twatch(_resource: URI): IDisposable;\n\twatch(_resource: URI): IDisposable {\n\t\tthis.watches.push(_resource);\n\n\t\treturn toDisposable(() => this.watches.splice(this.watches.indexOf(_resource), 1));\n\t}\n\n\tgetWriteEncoding(_resource: URI): IResourceEncoding { return { encoding: 'utf8', hasBOM: false }; }\n\tdispose(): void { }\n\n\tasync canCreateFile(source: URI, options?: ICreateFileOptions): Promise<Error | true> { return true; }\n\tasync canMove(source: URI, target: URI, overwrite?: boolean | undefined): Promise<Error | true> { return true; }\n\tasync canCopy(source: URI, target: URI, overwrite?: boolean | undefined): Promise<Error | true> { return true; }\n\tasync canDelete(resource: URI, options?: { useTrash?: boolean | undefined; recursive?: boolean | undefined } | undefined): Promise<Error | true> { return true; }\n}\n\n/**\n * TestFileService with in-memory file storage.\n * Use this when your test needs to write files and read them back.\n */\nexport class InMemoryTestFileService extends TestFileService {\n\n\tprivate files = new Map<string, VSBuffer>();\n\n\toverride clearTracking(): void {\n\t\tsuper.clearTracking();\n\t\tthis.files.clear();\n\t}\n\n\toverride async readFile(resource: URI, options?: IReadFileOptions | undefined): Promise<IFileContent> {\n\t\tif (this.readShouldThrowError) {\n\t\t\tthrow this.readShouldThrowError;\n\t\t}\n\n\t\tthis.lastReadFileUri = resource;\n\t\tthis.readOperations.push({ resource });\n\n\t\t// Check if we have content in our in-memory store\n\t\tconst content = this.files.get(resource.toString());\n\t\tif (content) {\n\t\t\treturn {\n\t\t\t\t...createFileStat(resource, this.readonly),\n\t\t\t\tvalue: content\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t...createFileStat(resource, this.readonly),\n\t\t\tvalue: VSBuffer.fromString(this.content)\n\t\t};\n\t}\n\n\toverride async writeFile(resource: URI, bufferOrReadable: VSBuffer | VSBufferReadable, options?: IWriteFileOptions): Promise<IFileStatWithMetadata> {\n\t\tawait timeout(0);\n\n\t\tif (this.writeShouldThrowError) {\n\t\t\tthrow this.writeShouldThrowError;\n\t\t}\n\n\t\tlet content: VSBuffer;\n\t\tif (bufferOrReadable instanceof VSBuffer) {\n\t\t\tcontent = bufferOrReadable;\n\t\t} else {\n\t\t\tcontent = readableToBuffer(bufferOrReadable);\n\t\t}\n\n\t\t// Store in memory and track\n\t\tthis.files.set(resource.toString(), content);\n\t\tthis.writeOperations.push({ resource, content: content.toString() });\n\n\t\treturn createFileStat(resource, this.readonly);\n\t}\n}\n\nexport class TestChatEntitlementService implements IChatEntitlementService {\n\n\t_serviceBrand: undefined;\n\n\treadonly organisations: undefined;\n\treadonly isInternal = false;\n\treadonly sku = undefined;\n\n\treadonly onDidChangeQuotaExceeded = Event.None;\n\treadonly onDidChangeQuotaRemaining = Event.None;\n\treadonly quotas = {};\n\n\tupdate(token: CancellationToken): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\treadonly onDidChangeSentiment = Event.None;\n\treadonly sentimentObs = observableValue({}, {});\n\treadonly sentiment = {};\n\n\treadonly onDidChangeEntitlement = Event.None;\n\tentitlement: ChatEntitlement = ChatEntitlement.Unknown;\n\treadonly entitlementObs = observableValue({}, ChatEntitlement.Unknown);\n\n\treadonly anonymous = false;\n\tonDidChangeAnonymous = Event.None;\n\treadonly anonymousObs = observableValue({}, false);\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from '../../../base/common/async.js';\nimport { bufferToStream, readableToBuffer, VSBuffer, VSBufferReadable } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { observableValue } from '../../../base/common/observable.js';\nimport { join } from '../../../base/common/path.js';\nimport { isLinux, isMacintosh } from '../../../base/common/platform.js';\nimport { basename, isEqual, isEqualOrParent } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ITextResourcePropertiesService } from '../../../editor/common/services/textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IResourceEditorInput } from '../../../platform/editor/common/editor.js';\nimport { FileChangesEvent, FileOperationEvent, FileSystemProviderCapabilities, IBaseFileStat, ICreateFileOptions, IFileContent, IFileService, IFileStat, IFileStatResult, IFileStatWithMetadata, IFileStatWithPartialMetadata, IFileStreamContent, IFileSystemProvider, IFileSystemProviderActivationEvent, IFileSystemProviderCapabilitiesChangeEvent, IFileSystemWatcher, IReadFileOptions, IReadFileStreamOptions, IResolveFileOptions, IResolveMetadataFileOptions, IWatchOptions, IWatchOptionsWithCorrelation, IWriteFileOptions } from '../../../platform/files/common/files.js';\nimport { AbstractLoggerService, ILogger, LogLevel, NullLogger } from '../../../platform/log/common/log.js';\nimport { IMarker, IMarkerData, IMarkerService, IResourceMarker, MarkerStatistics } from '../../../platform/markers/common/markers.js';\nimport product from '../../../platform/product/common/product.js';\nimport { IProgress, IProgressStep } from '../../../platform/progress/common/progress.js';\nimport { InMemoryStorageService, WillSaveStateReason } from '../../../platform/storage/common/storage.js';\nimport { toUserDataProfile } from '../../../platform/userDataProfile/common/userDataProfile.js';\nimport { ISingleFolderWorkspaceIdentifier, IWorkspace, IWorkspaceContextService, IWorkspaceFolder, IWorkspaceFoldersChangeEvent, IWorkspaceFoldersWillChangeEvent, IWorkspaceIdentifier, WorkbenchState, Workspace } from '../../../platform/workspace/common/workspace.js';\nimport { IWorkspaceTrustEnablementService, IWorkspaceTrustManagementService, IWorkspaceTrustRequestService, IWorkspaceTrustTransitionParticipant, IWorkspaceTrustUriInfo, WorkspaceTrustRequestOptions, WorkspaceTrustUriResponse } from '../../../platform/workspace/common/workspaceTrust.js';\nimport { TestWorkspace } from '../../../platform/workspace/test/common/testWorkspace.js';\nimport { GroupIdentifier, IRevertOptions, ISaveOptions, SaveReason } from '../../common/editor.js';\nimport { EditorInput } from '../../common/editor/editorInput.js';\nimport { IActivity, IActivityService } from '../../services/activity/common/activity.js';\nimport { ChatEntitlement, IChatEntitlementService } from '../../services/chat/common/chatEntitlementService.js';\nimport { NullExtensionService } from '../../services/extensions/common/extensions.js';\nimport { IAutoSaveConfiguration, IAutoSaveMode, IFilesConfigurationService } from '../../services/filesConfiguration/common/filesConfigurationService.js';\nimport { IHistoryService } from '../../services/history/common/history.js';\nimport { IResourceEncoding } from '../../services/textfile/common/textfiles.js';\nimport { IUserDataProfileService } from '../../services/userDataProfile/common/userDataProfile.js';\nimport { IStoredFileWorkingCopySaveEvent } from '../../services/workingCopy/common/storedFileWorkingCopy.js';\nimport { IWorkingCopy, IWorkingCopyBackup, WorkingCopyCapabilities } from '../../services/workingCopy/common/workingCopy.js';\nimport { ICopyOperation, ICreateFileOperation, ICreateOperation, IDeleteOperation, IFileOperationUndoRedoInfo, IMoveOperation, IStoredFileWorkingCopySaveParticipant, IStoredFileWorkingCopySaveParticipantContext, IWorkingCopyFileOperationParticipant, IWorkingCopyFileService, WorkingCopyFileEvent } from '../../services/workingCopy/common/workingCopyFileService.js';\n\nexport class TestLoggerService extends AbstractLoggerService {\n\tconstructor(logsHome?: URI) {\n\t\tsuper(LogLevel.Info, logsHome ?? URI.file('tests').with({ scheme: 'vscode-tests' }));\n\t}\n\tprotected doCreateLogger(): ILogger { return new NullLogger(); }\n}\n\nexport class TestTextResourcePropertiesService implements ITextResourcePropertiesService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t) {\n\t}\n\n\tgetEOL(resource: URI, language?: string): string {\n\t\tconst eol = this.configurationService.getValue('files.eol', { overrideIdentifier: language, resource });\n\t\tif (eol && typeof eol === 'string' && eol !== 'auto') {\n\t\t\treturn eol;\n\t\t}\n\t\treturn (isLinux || isMacintosh) ? '\\n' : '\\r\\n';\n\t}\n}\n\nexport class TestUserDataProfileService implements IUserDataProfileService {\n\n\treadonly _serviceBrand: undefined;\n\treadonly onDidChangeCurrentProfile = Event.None;\n\treadonly currentProfile = toUserDataProfile('test', 'test', URI.file('tests').with({ scheme: 'vscode-tests' }), URI.file('tests').with({ scheme: 'vscode-tests' }));\n\tasync updateCurrentProfile(): Promise<void> { }\n}\n\nexport class TestContextService implements IWorkspaceContextService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate workspace: Workspace;\n\tprivate options: object;\n\n\tprivate readonly _onDidChangeWorkspaceName: Emitter<void>;\n\tget onDidChangeWorkspaceName(): Event<void> { return this._onDidChangeWorkspaceName.event; }\n\n\tprivate readonly _onWillChangeWorkspaceFolders: Emitter<IWorkspaceFoldersWillChangeEvent>;\n\tget onWillChangeWorkspaceFolders(): Event<IWorkspaceFoldersWillChangeEvent> { return this._onWillChangeWorkspaceFolders.event; }\n\n\tprivate readonly _onDidChangeWorkspaceFolders: Emitter<IWorkspaceFoldersChangeEvent>;\n\tget onDidChangeWorkspaceFolders(): Event<IWorkspaceFoldersChangeEvent> { return this._onDidChangeWorkspaceFolders.event; }\n\n\tprivate readonly _onDidChangeWorkbenchState: Emitter<WorkbenchState>;\n\tget onDidChangeWorkbenchState(): Event<WorkbenchState> { return this._onDidChangeWorkbenchState.event; }\n\n\tconstructor(workspace = TestWorkspace, options = null) {\n\t\tthis.workspace = workspace;\n\t\tthis.options = options || Object.create(null);\n\t\tthis._onDidChangeWorkspaceName = new Emitter<void>();\n\t\tthis._onWillChangeWorkspaceFolders = new Emitter<IWorkspaceFoldersWillChangeEvent>();\n\t\tthis._onDidChangeWorkspaceFolders = new Emitter<IWorkspaceFoldersChangeEvent>();\n\t\tthis._onDidChangeWorkbenchState = new Emitter<WorkbenchState>();\n\t}\n\n\tgetFolders(): IWorkspaceFolder[] {\n\t\treturn this.workspace ? this.workspace.folders : [];\n\t}\n\n\tgetWorkbenchState(): WorkbenchState {\n\t\tif (this.workspace.configuration) {\n\t\t\treturn WorkbenchState.WORKSPACE;\n\t\t}\n\n\t\tif (this.workspace.folders.length) {\n\t\t\treturn WorkbenchState.FOLDER;\n\t\t}\n\n\t\treturn WorkbenchState.EMPTY;\n\t}\n\n\tgetCompleteWorkspace(): Promise<IWorkspace> {\n\t\treturn Promise.resolve(this.getWorkspace());\n\t}\n\n\tgetWorkspace(): IWorkspace {\n\t\treturn this.workspace;\n\t}\n\n\tgetWorkspaceFolder(resource: URI): IWorkspaceFolder | null {\n\t\treturn this.workspace.getFolder(resource);\n\t}\n\n\tsetWorkspace(workspace: any): void {\n\t\tthis.workspace = workspace;\n\t}\n\n\tgetOptions() {\n\t\treturn this.options;\n\t}\n\n\tupdateOptions() { }\n\n\tisInsideWorkspace(resource: URI): boolean {\n\t\tif (resource && this.workspace) {\n\t\t\treturn isEqualOrParent(resource, this.workspace.folders[0].uri);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\ttoResource(workspaceRelativePath: string): URI {\n\t\treturn URI.file(join('C:\\\\', workspaceRelativePath));\n\t}\n\n\tisCurrentWorkspace(workspaceIdOrFolder: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | URI): boolean {\n\t\treturn URI.isUri(workspaceIdOrFolder) && isEqual(this.workspace.folders[0].uri, workspaceIdOrFolder);\n\t}\n}\n\nexport class TestStorageService extends InMemoryStorageService {\n\n\ttestEmitWillSaveState(reason: WillSaveStateReason): void {\n\t\tsuper.emitWillSaveState(reason);\n\t}\n}\n\nexport class TestHistoryService implements IHistoryService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(private root?: URI) { }\n\n\tasync reopenLastClosedEditor(): Promise<void> { }\n\tasync goForward(): Promise<void> { }\n\tasync goBack(): Promise<void> { }\n\tasync goPrevious(): Promise<void> { }\n\tasync goLast(): Promise<void> { }\n\tremoveFromHistory(_input: EditorInput | IResourceEditorInput): void { }\n\tclear(): void { }\n\tclearRecentlyOpened(): void { }\n\tgetHistory(): readonly (EditorInput | IResourceEditorInput)[] { return []; }\n\tasync openNextRecentlyUsedEditor(group?: GroupIdentifier): Promise<void> { }\n\tasync openPreviouslyUsedEditor(group?: GroupIdentifier): Promise<void> { }\n\tgetLastActiveWorkspaceRoot(_schemeFilter: string): URI | undefined { return this.root; }\n\tgetLastActiveFile(_schemeFilter: string): URI | undefined { return undefined; }\n}\n\nexport class TestWorkingCopy extends Disposable implements IWorkingCopy {\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<void>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeContent = this._register(new Emitter<void>());\n\treadonly onDidChangeContent = this._onDidChangeContent.event;\n\n\tprivate readonly _onDidSave = this._register(new Emitter<IStoredFileWorkingCopySaveEvent>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\treadonly capabilities = WorkingCopyCapabilities.None;\n\n\treadonly name;\n\n\tprivate dirty = false;\n\n\tconstructor(readonly resource: URI, isDirty = false, readonly typeId = 'testWorkingCopyType') {\n\t\tsuper();\n\n\t\tthis.name = basename(this.resource);\n\t\tthis.dirty = isDirty;\n\t}\n\n\tsetDirty(dirty: boolean): void {\n\t\tif (this.dirty !== dirty) {\n\t\t\tthis.dirty = dirty;\n\t\t\tthis._onDidChangeDirty.fire();\n\t\t}\n\t}\n\n\tsetContent(content: string): void {\n\t\tthis._onDidChangeContent.fire();\n\t}\n\n\tisDirty(): boolean {\n\t\treturn this.dirty;\n\t}\n\n\tisModified(): boolean {\n\t\treturn this.isDirty();\n\t}\n\n\tasync save(options?: ISaveOptions, stat?: IFileStatWithMetadata): Promise<boolean> {\n\t\tthis._onDidSave.fire({ reason: options?.reason ?? SaveReason.EXPLICIT, stat: stat ?? createFileStat(this.resource), source: options?.source });\n\n\t\treturn true;\n\t}\n\n\tasync revert(options?: IRevertOptions): Promise<void> {\n\t\tthis.setDirty(false);\n\t}\n\n\tasync backup(token: CancellationToken): Promise<IWorkingCopyBackup> {\n\t\treturn {};\n\t}\n}\n\nexport function createFileStat(resource: URI, readonly = false, isFile?: boolean, isDirectory?: boolean, isSymbolicLink?: boolean, children?: { resource: URI; isFile?: boolean; isDirectory?: boolean; isSymbolicLink?: boolean }[] | undefined): IFileStatWithMetadata {\n\treturn {\n\t\tresource,\n\t\tetag: Date.now().toString(),\n\t\tmtime: Date.now(),\n\t\tctime: Date.now(),\n\t\tsize: 42,\n\t\tisFile: isFile ?? true,\n\t\tisDirectory: isDirectory ?? false,\n\t\tisSymbolicLink: isSymbolicLink ?? false,\n\t\treadonly,\n\t\tlocked: false,\n\t\tname: basename(resource),\n\t\tchildren: children?.map(c => createFileStat(c.resource, false, c.isFile, c.isDirectory, c.isSymbolicLink)),\n\t};\n}\n\nexport class TestWorkingCopyFileService implements IWorkingCopyFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\treadonly onWillRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent> = Event.None;\n\treadonly onDidFailWorkingCopyFileOperation: Event<WorkingCopyFileEvent> = Event.None;\n\treadonly onDidRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent> = Event.None;\n\n\taddFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable { return Disposable.None; }\n\n\treadonly hasSaveParticipants = false;\n\taddSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable { return Disposable.None; }\n\tasync runSaveParticipants(workingCopy: IWorkingCopy, context: IStoredFileWorkingCopySaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void> { }\n\n\tasync delete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void> { }\n\n\tregisterWorkingCopyProvider(provider: (resourceOrFolder: URI) => IWorkingCopy[]): IDisposable { return Disposable.None; }\n\n\tgetDirty(resource: URI): IWorkingCopy[] { return []; }\n\n\tcreate(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> { throw new Error('Method not implemented.'); }\n\tcreateFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> { throw new Error('Method not implemented.'); }\n\n\tmove(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> { throw new Error('Method not implemented.'); }\n\n\tcopy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> { throw new Error('Method not implemented.'); }\n}\n\nexport function mock<T>(): Ctor<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn function () { } as any;\n}\n\nexport interface Ctor<T> {\n\tnew(): T;\n}\n\nexport class TestExtensionService extends NullExtensionService { }\n\nexport const TestProductService = { _serviceBrand: undefined, ...product };\n\nexport class TestActivityService implements IActivityService {\n\t_serviceBrand: undefined;\n\tonDidChangeActivity = Event.None;\n\tgetViewContainerActivities(viewContainerId: string): IActivity[] {\n\t\treturn [];\n\t}\n\tgetActivity(id: string): IActivity[] {\n\t\treturn [];\n\t}\n\tshowViewContainerActivity(viewContainerId: string, badge: IActivity): IDisposable {\n\t\treturn this;\n\t}\n\tshowViewActivity(viewId: string, badge: IActivity): IDisposable {\n\t\treturn this;\n\t}\n\tshowAccountsActivity(activity: IActivity): IDisposable {\n\t\treturn this;\n\t}\n\tshowGlobalActivity(activity: IActivity): IDisposable {\n\t\treturn this;\n\t}\n\n\tdispose() { }\n}\n\nexport const NullFilesConfigurationService = new class implements IFilesConfigurationService {\n\n\t_serviceBrand: undefined;\n\n\treadonly onDidChangeAutoSaveConfiguration = Event.None;\n\treadonly onDidChangeAutoSaveDisabled = Event.None;\n\treadonly onDidChangeReadonly = Event.None;\n\treadonly onDidChangeFilesAssociation = Event.None;\n\n\treadonly isHotExitEnabled = false;\n\treadonly hotExitConfiguration = undefined;\n\n\tgetAutoSaveConfiguration(): IAutoSaveConfiguration { throw new Error('Method not implemented.'); }\n\tgetAutoSaveMode(): IAutoSaveMode { throw new Error('Method not implemented.'); }\n\thasShortAutoSaveDelay(): boolean { throw new Error('Method not implemented.'); }\n\ttoggleAutoSave(): Promise<void> { throw new Error('Method not implemented.'); }\n\tenableAutoSaveAfterShortDelay(resourceOrEditor: URI | EditorInput): IDisposable { throw new Error('Method not implemented.'); }\n\tdisableAutoSave(resourceOrEditor: URI | EditorInput): IDisposable { throw new Error('Method not implemented.'); }\n\tisReadonly(resource: URI, stat?: IBaseFileStat | undefined): boolean { return false; }\n\tasync updateReadonly(resource: URI, readonly: boolean | 'toggle' | 'reset'): Promise<void> { }\n\tpreventSaveConflicts(resource: URI, language?: string | undefined): boolean { throw new Error('Method not implemented.'); }\n};\n\nexport class TestWorkspaceTrustEnablementService implements IWorkspaceTrustEnablementService {\n\t_serviceBrand: undefined;\n\n\tconstructor(private isEnabled: boolean = true) { }\n\n\tisWorkspaceTrustEnabled(): boolean {\n\t\treturn this.isEnabled;\n\t}\n}\n\nexport class TestWorkspaceTrustManagementService extends Disposable implements IWorkspaceTrustManagementService {\n\t_serviceBrand: undefined;\n\n\tprivate _onDidChangeTrust = this._register(new Emitter<boolean>());\n\tonDidChangeTrust = this._onDidChangeTrust.event;\n\n\tprivate _onDidChangeTrustedFolders = this._register(new Emitter<void>());\n\tonDidChangeTrustedFolders = this._onDidChangeTrustedFolders.event;\n\n\tprivate _onDidInitiateWorkspaceTrustRequestOnStartup = this._register(new Emitter<void>());\n\tonDidInitiateWorkspaceTrustRequestOnStartup = this._onDidInitiateWorkspaceTrustRequestOnStartup.event;\n\n\n\tconstructor(\n\t\tprivate trusted: boolean = true\n\t) {\n\t\tsuper();\n\t}\n\n\tget acceptsOutOfWorkspaceFiles(): boolean {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tset acceptsOutOfWorkspaceFiles(value: boolean) {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\taddWorkspaceTrustTransitionParticipant(participant: IWorkspaceTrustTransitionParticipant): IDisposable {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tgetTrustedUris(): URI[] {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tsetParentFolderTrust(trusted: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tgetUriTrustInfo(uri: URI): Promise<IWorkspaceTrustUriInfo> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync setTrustedUris(folders: URI[]): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync setUrisTrust(uris: URI[], trusted: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcanSetParentFolderTrust(): boolean {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcanSetWorkspaceTrust(): boolean {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tisWorkspaceTrusted(): boolean {\n\t\treturn this.trusted;\n\t}\n\n\tisWorkspaceTrustForced(): boolean {\n\t\treturn false;\n\t}\n\n\tget workspaceTrustInitialized(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tget workspaceResolved(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tasync setWorkspaceTrust(trusted: boolean): Promise<void> {\n\t\tif (this.trusted !== trusted) {\n\t\t\tthis.trusted = trusted;\n\t\t\tthis._onDidChangeTrust.fire(this.trusted);\n\t\t}\n\t}\n}\n\nexport class TestWorkspaceTrustRequestService extends Disposable implements IWorkspaceTrustRequestService {\n\t_serviceBrand: any;\n\n\tprivate readonly _onDidInitiateOpenFilesTrustRequest = this._register(new Emitter<void>());\n\treadonly onDidInitiateOpenFilesTrustRequest = this._onDidInitiateOpenFilesTrustRequest.event;\n\n\tprivate readonly _onDidInitiateWorkspaceTrustRequest = this._register(new Emitter<WorkspaceTrustRequestOptions>());\n\treadonly onDidInitiateWorkspaceTrustRequest = this._onDidInitiateWorkspaceTrustRequest.event;\n\n\tprivate readonly _onDidInitiateWorkspaceTrustRequestOnStartup = this._register(new Emitter<void>());\n\treadonly onDidInitiateWorkspaceTrustRequestOnStartup = this._onDidInitiateWorkspaceTrustRequestOnStartup.event;\n\n\tconstructor(private readonly _trusted: boolean) {\n\t\tsuper();\n\t}\n\n\trequestOpenUrisHandler = async (uris: URI[]) => {\n\t\treturn WorkspaceTrustUriResponse.Open;\n\t};\n\n\trequestOpenFilesTrust(uris: URI[]): Promise<WorkspaceTrustUriResponse> {\n\t\treturn this.requestOpenUrisHandler(uris);\n\t}\n\n\tasync completeOpenFilesTrustRequest(result: WorkspaceTrustUriResponse, saveResponse: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tcancelWorkspaceTrustRequest(): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync completeWorkspaceTrustRequest(trusted?: boolean): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync requestWorkspaceTrust(options?: WorkspaceTrustRequestOptions): Promise<boolean> {\n\t\treturn this._trusted;\n\t}\n\n\trequestWorkspaceTrustOnStartup(): void {\n\t\tthrow new Error('Method not implemented.');\n\t}\n}\n\nexport class TestMarkerService implements IMarkerService {\n\n\t_serviceBrand: undefined;\n\n\tonMarkerChanged = Event.None;\n\n\tgetStatistics(): MarkerStatistics { throw new Error('Method not implemented.'); }\n\tchangeOne(owner: string, resource: URI, markers: IMarkerData[]): void { }\n\tchangeAll(owner: string, data: IResourceMarker[]): void { }\n\tremove(owner: string, resources: URI[]): void { }\n\tread(filter?: { owner?: string | undefined; resource?: URI | undefined; severities?: number | undefined; take?: number | undefined } | undefined): IMarker[] { return []; }\n\tinstallResourceFilter(resource: URI, reason: string): IDisposable {\n\t\treturn { dispose: () => { /* TODO: Implement cleanup logic */ } };\n\t}\n}\n\nexport class TestFileService implements IFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _onDidFilesChange = new Emitter<FileChangesEvent>();\n\tget onDidFilesChange(): Event<FileChangesEvent> { return this._onDidFilesChange.event; }\n\tfireFileChanges(event: FileChangesEvent): void { this._onDidFilesChange.fire(event); }\n\n\tprivate readonly _onDidRunOperation = new Emitter<FileOperationEvent>();\n\tget onDidRunOperation(): Event<FileOperationEvent> { return this._onDidRunOperation.event; }\n\tfireAfterOperation(event: FileOperationEvent): void { this._onDidRunOperation.fire(event); }\n\n\tprivate readonly _onDidChangeFileSystemProviderCapabilities = new Emitter<IFileSystemProviderCapabilitiesChangeEvent>();\n\tget onDidChangeFileSystemProviderCapabilities(): Event<IFileSystemProviderCapabilitiesChangeEvent> { return this._onDidChangeFileSystemProviderCapabilities.event; }\n\tfireFileSystemProviderCapabilitiesChangeEvent(event: IFileSystemProviderCapabilitiesChangeEvent): void { this._onDidChangeFileSystemProviderCapabilities.fire(event); }\n\n\tprivate _onWillActivateFileSystemProvider = new Emitter<IFileSystemProviderActivationEvent>();\n\treadonly onWillActivateFileSystemProvider = this._onWillActivateFileSystemProvider.event;\n\treadonly onDidWatchError = Event.None;\n\n\tprotected content = 'Hello Html';\n\tprotected lastReadFileUri!: URI;\n\n\treadonly = false;\n\n\t// Tracking functionality for tests\n\treadonly writeOperations: Array<{ resource: URI; content: string }> = [];\n\treadonly readOperations: Array<{ resource: URI }> = [];\n\n\tsetContent(content: string): void { this.content = content; }\n\tgetContent(): string { return this.content; }\n\tgetLastReadFileUri(): URI { return this.lastReadFileUri; }\n\n\t// Clear tracking data for tests\n\tclearTracking(): void {\n\t\tthis.writeOperations.length = 0;\n\t\tthis.readOperations.length = 0;\n\t}\n\n\tresolve(resource: URI, _options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tresolve(resource: URI, _options?: IResolveFileOptions): Promise<IFileStat>;\n\tasync resolve(resource: URI, _options?: IResolveFileOptions): Promise<IFileStat> {\n\t\treturn createFileStat(resource, this.readonly);\n\t}\n\n\tstat(resource: URI): Promise<IFileStatWithPartialMetadata> {\n\t\treturn this.resolve(resource, { resolveMetadata: true });\n\t}\n\n\tasync realpath(resource: URI): Promise<URI> {\n\t\treturn resource;\n\t}\n\n\tasync resolveAll(toResolve: { resource: URI; options?: IResolveFileOptions }[]): Promise<IFileStatResult[]> {\n\t\tconst stats = await Promise.all(toResolve.map(resourceAndOption => this.resolve(resourceAndOption.resource, resourceAndOption.options)));\n\n\t\treturn stats.map(stat => ({ stat, success: true }));\n\t}\n\n\treadonly notExistsSet = new ResourceMap<boolean>();\n\n\tasync exists(_resource: URI): Promise<boolean> { return !this.notExistsSet.has(_resource); }\n\n\treadShouldThrowError: Error | undefined = undefined;\n\n\tasync readFile(resource: URI, options?: IReadFileOptions | undefined): Promise<IFileContent> {\n\t\tif (this.readShouldThrowError) {\n\t\t\tthrow this.readShouldThrowError;\n\t\t}\n\n\t\tthis.lastReadFileUri = resource;\n\t\tthis.readOperations.push({ resource });\n\n\t\treturn {\n\t\t\t...createFileStat(resource, this.readonly),\n\t\t\tvalue: VSBuffer.fromString(this.content)\n\t\t};\n\t}\n\n\tasync readFileStream(resource: URI, options?: IReadFileStreamOptions | undefined): Promise<IFileStreamContent> {\n\t\tif (this.readShouldThrowError) {\n\t\t\tthrow this.readShouldThrowError;\n\t\t}\n\n\t\tthis.lastReadFileUri = resource;\n\n\t\treturn {\n\t\t\t...createFileStat(resource, this.readonly),\n\t\t\tvalue: bufferToStream(VSBuffer.fromString(this.content))\n\t\t};\n\t}\n\n\twriteShouldThrowError: Error | undefined = undefined;\n\n\tasync writeFile(resource: URI, bufferOrReadable: VSBuffer | VSBufferReadable, options?: IWriteFileOptions): Promise<IFileStatWithMetadata> {\n\t\tawait timeout(0);\n\n\t\tif (this.writeShouldThrowError) {\n\t\t\tthrow this.writeShouldThrowError;\n\t\t}\n\n\t\tlet content: VSBuffer | undefined;\n\t\tif (bufferOrReadable instanceof VSBuffer) {\n\t\t\tcontent = bufferOrReadable;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcontent = readableToBuffer(bufferOrReadable);\n\t\t\t} catch {\n\t\t\t\t// Some preexisting tests are writing with invalid objects\n\t\t\t}\n\t\t}\n\n\t\tif (content) {\n\t\t\tthis.writeOperations.push({ resource, content: content.toString() });\n\t\t}\n\n\t\treturn createFileStat(resource, this.readonly);\n\t}\n\n\tmove(_source: URI, _target: URI, _overwrite?: boolean): Promise<IFileStatWithMetadata> { return Promise.resolve(null!); }\n\tcopy(_source: URI, _target: URI, _overwrite?: boolean): Promise<IFileStatWithMetadata> { return Promise.resolve(null!); }\n\tasync cloneFile(_source: URI, _target: URI): Promise<void> { }\n\tcreateFile(_resource: URI, _content?: VSBuffer | VSBufferReadable, _options?: ICreateFileOptions): Promise<IFileStatWithMetadata> { return Promise.resolve(null!); }\n\tcreateFolder(_resource: URI): Promise<IFileStatWithMetadata> { return Promise.resolve(null!); }\n\n\tonDidChangeFileSystemProviderRegistrations = Event.None;\n\n\tprivate providers = new Map<string, IFileSystemProvider>();\n\n\tregisterProvider(scheme: string, provider: IFileSystemProvider) {\n\t\tthis.providers.set(scheme, provider);\n\n\t\treturn toDisposable(() => this.providers.delete(scheme));\n\t}\n\n\tgetProvider(scheme: string) {\n\t\treturn this.providers.get(scheme);\n\t}\n\n\tasync activateProvider(_scheme: string): Promise<void> {\n\t\tthis._onWillActivateFileSystemProvider.fire({ scheme: _scheme, join: () => { } });\n\t}\n\tasync canHandleResource(resource: URI): Promise<boolean> { return this.hasProvider(resource); }\n\thasProvider(resource: URI): boolean { return resource.scheme === Schemas.file || this.providers.has(resource.scheme); }\n\tlistCapabilities() {\n\t\treturn [\n\t\t\t{ scheme: Schemas.file, capabilities: FileSystemProviderCapabilities.FileOpenReadWriteClose },\n\t\t\t...Iterable.map(this.providers, ([scheme, p]) => { return { scheme, capabilities: p.capabilities }; })\n\t\t];\n\t}\n\thasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\n\t\tif (capability === FileSystemProviderCapabilities.PathCaseSensitive && isLinux) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst provider = this.getProvider(resource.scheme);\n\n\t\treturn !!(provider && (provider.capabilities & capability));\n\t}\n\n\tasync del(_resource: URI, _options?: { useTrash?: boolean; recursive?: boolean }): Promise<void> { }\n\n\tcreateWatcher(resource: URI, options: IWatchOptions): IFileSystemWatcher {\n\t\treturn {\n\t\t\tonDidChange: Event.None,\n\t\t\tdispose: () => { }\n\t\t};\n\t}\n\n\n\treadonly watches: URI[] = [];\n\twatch(_resource: URI, options: IWatchOptionsWithCorrelation): IFileSystemWatcher;\n\twatch(_resource: URI): IDisposable;\n\twatch(_resource: URI): IDisposable {\n\t\tthis.watches.push(_resource);\n\n\t\treturn toDisposable(() => this.watches.splice(this.watches.indexOf(_resource), 1));\n\t}\n\n\tgetWriteEncoding(_resource: URI): IResourceEncoding { return { encoding: 'utf8', hasBOM: false }; }\n\tdispose(): void { }\n\n\tasync canCreateFile(source: URI, options?: ICreateFileOptions): Promise<Error | true> { return true; }\n\tasync canMove(source: URI, target: URI, overwrite?: boolean | undefined): Promise<Error | true> { return true; }\n\tasync canCopy(source: URI, target: URI, overwrite?: boolean | undefined): Promise<Error | true> { return true; }\n\tasync canDelete(resource: URI, options?: { useTrash?: boolean | undefined; recursive?: boolean | undefined } | undefined): Promise<Error | true> { return true; }\n}\n\n/**\n * TestFileService with in-memory file storage.\n * Use this when your test needs to write files and read them back.\n */\nexport class InMemoryTestFileService extends TestFileService {\n\n\tprivate files = new Map<string, VSBuffer>();\n\n\toverride clearTracking(): void {\n\t\tsuper.clearTracking();\n\t\tthis.files.clear();\n\t}\n\n\toverride async readFile(resource: URI, options?: IReadFileOptions | undefined): Promise<IFileContent> {\n\t\tif (this.readShouldThrowError) {\n\t\t\tthrow this.readShouldThrowError;\n\t\t}\n\n\t\tthis.lastReadFileUri = resource;\n\t\tthis.readOperations.push({ resource });\n\n\t\t// Check if we have content in our in-memory store\n\t\tconst content = this.files.get(resource.toString());\n\t\tif (content) {\n\t\t\treturn {\n\t\t\t\t...createFileStat(resource, this.readonly),\n\t\t\t\tvalue: content\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t...createFileStat(resource, this.readonly),\n\t\t\tvalue: VSBuffer.fromString(this.content)\n\t\t};\n\t}\n\n\toverride async writeFile(resource: URI, bufferOrReadable: VSBuffer | VSBufferReadable, options?: IWriteFileOptions): Promise<IFileStatWithMetadata> {\n\t\tawait timeout(0);\n\n\t\tif (this.writeShouldThrowError) {\n\t\t\tthrow this.writeShouldThrowError;\n\t\t}\n\n\t\tlet content: VSBuffer;\n\t\tif (bufferOrReadable instanceof VSBuffer) {\n\t\t\tcontent = bufferOrReadable;\n\t\t} else {\n\t\t\tcontent = readableToBuffer(bufferOrReadable);\n\t\t}\n\n\t\t// Store in memory and track\n\t\tthis.files.set(resource.toString(), content);\n\t\tthis.writeOperations.push({ resource, content: content.toString() });\n\n\t\treturn createFileStat(resource, this.readonly);\n\t}\n}\n\nexport class TestChatEntitlementService implements IChatEntitlementService {\n\n\t_serviceBrand: undefined;\n\n\treadonly organisations: undefined;\n\treadonly isInternal = false;\n\treadonly sku = undefined;\n\n\treadonly onDidChangeQuotaExceeded = Event.None;\n\treadonly onDidChangeQuotaRemaining = Event.None;\n\treadonly quotas = {};\n\n\tupdate(token: CancellationToken): Promise<void> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\treadonly onDidChangeSentiment = Event.None;\n\treadonly sentimentObs = observableValue({}, {});\n\treadonly sentiment = {};\n\n\treadonly onDidChangeEntitlement = Event.None;\n\tentitlement: ChatEntitlement = ChatEntitlement.Unknown;\n\treadonly entitlementObs = observableValue({}, ChatEntitlement.Unknown);\n\n\treadonly anonymous = false;\n\tonDidChangeAnonymous = Event.None;\n\treadonly anonymousObs = observableValue({}, false);\n}\n\n"]}