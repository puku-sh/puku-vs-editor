{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/common/contributions.ts","vs/workbench/common/contributions.ts"],"names":[],"mappings":"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","file":"contributions.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService, IConstructorSignature, ServicesAccessor, BrandedService } from '../../platform/instantiation/common/instantiation.js';\nimport { ILifecycleService, LifecyclePhase } from '../services/lifecycle/common/lifecycle.js';\nimport { Registry } from '../../platform/registry/common/platform.js';\nimport { IdleDeadline, DeferredPromise, runWhenGlobalIdle } from '../../base/common/async.js';\nimport { mark } from '../../base/common/performance.js';\nimport { ILogService } from '../../platform/log/common/log.js';\nimport { IEnvironmentService } from '../../platform/environment/common/environment.js';\nimport { getOrSet } from '../../base/common/map.js';\nimport { Disposable, DisposableStore, isDisposable } from '../../base/common/lifecycle.js';\nimport { IEditorPaneService } from '../services/editor/common/editorPaneService.js';\n\n/**\n * A workbench contribution that will be loaded when the workbench starts and disposed when the workbench shuts down.\n */\nexport interface IWorkbenchContribution {\n\t// Marker Interface\n}\n\nexport namespace Extensions {\n\t/**\n\t * @deprecated use `registerWorkbenchContribution2` instead.\n\t */\n\texport const Workbench = 'workbench.contributions.kind';\n}\n\nexport const enum WorkbenchPhase {\n\n\t/**\n\t * The first phase signals that we are about to startup getting ready.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use the other types, preferable\n\t * `Lazy` to only instantiate the contribution when really needed.\n\t */\n\tBlockStartup = LifecyclePhase.Starting,\n\n\t/**\n\t * Services are ready and the window is about to restore its UI state.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use the other types, preferable\n\t * `Lazy` to only instantiate the contribution when really needed.\n\t */\n\tBlockRestore = LifecyclePhase.Ready,\n\n\t/**\n\t * Views, panels and editors have restored. Editors are given a bit of\n\t * time to restore their contents.\n\t */\n\tAfterRestored = LifecyclePhase.Restored,\n\n\t/**\n\t * The last phase after views, panels and editors have restored and\n\t * some time has passed (2-5 seconds).\n\t */\n\tEventually = LifecyclePhase.Eventually\n}\n\n/**\n * A workbenchch contribution that will only be instantiated\n * when calling `getWorkbenchContribution`.\n */\nexport interface ILazyWorkbenchContributionInstantiation {\n\treadonly lazy: true;\n}\n\n/**\n * A workbench contribution that will be instantiated when the\n * corresponding editor is being created.\n */\nexport interface IOnEditorWorkbenchContributionInstantiation {\n\treadonly editorTypeId: string;\n}\n\nfunction isOnEditorWorkbenchContributionInstantiation(obj: unknown): obj is IOnEditorWorkbenchContributionInstantiation {\n\tconst candidate = obj as IOnEditorWorkbenchContributionInstantiation | undefined;\n\treturn !!candidate && typeof candidate.editorTypeId === 'string';\n}\n\nexport type WorkbenchContributionInstantiation = WorkbenchPhase | ILazyWorkbenchContributionInstantiation | IOnEditorWorkbenchContributionInstantiation;\n\nfunction toWorkbenchPhase(phase: LifecyclePhase.Restored | LifecyclePhase.Eventually): WorkbenchPhase.AfterRestored | WorkbenchPhase.Eventually {\n\tswitch (phase) {\n\t\tcase LifecyclePhase.Restored:\n\t\t\treturn WorkbenchPhase.AfterRestored;\n\t\tcase LifecyclePhase.Eventually:\n\t\t\treturn WorkbenchPhase.Eventually;\n\t}\n}\n\nfunction toLifecyclePhase(instantiation: WorkbenchPhase): LifecyclePhase {\n\tswitch (instantiation) {\n\t\tcase WorkbenchPhase.BlockStartup:\n\t\t\treturn LifecyclePhase.Starting;\n\t\tcase WorkbenchPhase.BlockRestore:\n\t\t\treturn LifecyclePhase.Ready;\n\t\tcase WorkbenchPhase.AfterRestored:\n\t\t\treturn LifecyclePhase.Restored;\n\t\tcase WorkbenchPhase.Eventually:\n\t\t\treturn LifecyclePhase.Eventually;\n\t}\n}\n\ntype IWorkbenchContributionSignature<Service extends BrandedService[]> = new (...services: Service) => IWorkbenchContribution;\n\nexport interface IWorkbenchContributionsRegistry {\n\n\t/**\n\t * @deprecated use `registerWorkbenchContribution2` instead.\n\t */\n\tregisterWorkbenchContribution<Services extends BrandedService[]>(contribution: IWorkbenchContributionSignature<Services>, phase: LifecyclePhase.Restored | LifecyclePhase.Eventually): void;\n\n\t/**\n\t * Starts the registry by providing the required services.\n\t */\n\tstart(accessor: ServicesAccessor): void;\n\n\t/**\n\t * A promise that resolves when all contributions up to the `Restored`\n\t * phase have been instantiated.\n\t */\n\treadonly whenRestored: Promise<void>;\n\n\t/**\n\t * Provides access to the instantiation times of all contributions by\n\t * lifecycle phase.\n\t */\n\treadonly timings: Map<LifecyclePhase, Array<[string /* ID */, number /* Creation Time */]>>;\n}\n\ninterface IWorkbenchContributionRegistration {\n\treadonly id: string | undefined;\n\treadonly ctor: IConstructorSignature<IWorkbenchContribution>;\n}\n\nexport class WorkbenchContributionsRegistry extends Disposable implements IWorkbenchContributionsRegistry {\n\n\tstatic readonly INSTANCE = new WorkbenchContributionsRegistry();\n\n\tprivate static readonly BLOCK_BEFORE_RESTORE_WARN_THRESHOLD = 20;\n\tprivate static readonly BLOCK_AFTER_RESTORE_WARN_THRESHOLD = 100;\n\n\tprivate instantiationService: IInstantiationService | undefined;\n\tprivate lifecycleService: ILifecycleService | undefined;\n\tprivate logService: ILogService | undefined;\n\tprivate environmentService: IEnvironmentService | undefined;\n\tprivate editorPaneService: IEditorPaneService | undefined;\n\n\tprivate readonly contributionsByPhase = new Map<LifecyclePhase, IWorkbenchContributionRegistration[]>();\n\tprivate readonly contributionsByEditor = new Map<string, IWorkbenchContributionRegistration[]>();\n\tprivate readonly contributionsById = new Map<string, IWorkbenchContributionRegistration>();\n\n\tprivate readonly instancesById = new Map<string, IWorkbenchContribution>();\n\tprivate readonly instanceDisposables = this._register(new DisposableStore());\n\n\tprivate readonly timingsByPhase = new Map<LifecyclePhase, Array<[string /* ID */, number /* Creation Time */]>>();\n\tget timings() { return this.timingsByPhase; }\n\n\tprivate readonly pendingRestoredContributions = new DeferredPromise<void>();\n\treadonly whenRestored = this.pendingRestoredContributions.p;\n\n\tregisterWorkbenchContribution2(id: string, ctor: IConstructorSignature<IWorkbenchContribution>, phase: WorkbenchPhase.BlockStartup | WorkbenchPhase.BlockRestore): void;\n\tregisterWorkbenchContribution2(id: string | undefined, ctor: IConstructorSignature<IWorkbenchContribution>, phase: WorkbenchPhase.AfterRestored | WorkbenchPhase.Eventually): void;\n\tregisterWorkbenchContribution2(id: string, ctor: IConstructorSignature<IWorkbenchContribution>, lazy: ILazyWorkbenchContributionInstantiation): void;\n\tregisterWorkbenchContribution2(id: string, ctor: IConstructorSignature<IWorkbenchContribution>, onEditor: IOnEditorWorkbenchContributionInstantiation): void;\n\tregisterWorkbenchContribution2(id: string | undefined, ctor: IConstructorSignature<IWorkbenchContribution>, instantiation: WorkbenchContributionInstantiation): void {\n\t\tconst contribution: IWorkbenchContributionRegistration = { id, ctor };\n\n\t\t// Instantiate directly if we already have a matching instantiation condition\n\t\tif (\n\t\t\tthis.instantiationService && this.lifecycleService && this.logService && this.environmentService && this.editorPaneService &&\n\t\t\t(\n\t\t\t\t(typeof instantiation === 'number' && this.lifecycleService.phase >= instantiation) ||\n\t\t\t\t(typeof id === 'string' && isOnEditorWorkbenchContributionInstantiation(instantiation) && this.editorPaneService.didInstantiateEditorPane(instantiation.editorTypeId))\n\t\t\t)\n\t\t) {\n\t\t\tthis.safeCreateContribution(this.instantiationService, this.logService, this.environmentService, contribution, typeof instantiation === 'number' ? toLifecyclePhase(instantiation) : this.lifecycleService.phase);\n\t\t}\n\n\t\t// Otherwise keep contributions by instantiation kind for later instantiation\n\t\telse {\n\n\t\t\t// by phase\n\t\t\tif (typeof instantiation === 'number') {\n\t\t\t\tgetOrSet(this.contributionsByPhase, toLifecyclePhase(instantiation), []).push(contribution);\n\t\t\t}\n\n\t\t\tif (typeof id === 'string') {\n\n\t\t\t\t// by id\n\t\t\t\tif (!this.contributionsById.has(id)) {\n\t\t\t\t\tthis.contributionsById.set(id, contribution);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(`IWorkbenchContributionsRegistry#registerWorkbenchContribution(): Can't register multiple contributions with same id '${id}'`);\n\t\t\t\t}\n\n\t\t\t\t// by editor\n\t\t\t\tif (isOnEditorWorkbenchContributionInstantiation(instantiation)) {\n\t\t\t\t\tgetOrSet(this.contributionsByEditor, instantiation.editorTypeId, []).push(contribution);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterWorkbenchContribution(ctor: IConstructorSignature<IWorkbenchContribution>, phase: LifecyclePhase.Restored | LifecyclePhase.Eventually): void {\n\t\tthis.registerWorkbenchContribution2(undefined, ctor, toWorkbenchPhase(phase));\n\t}\n\n\tgetWorkbenchContribution<T extends IWorkbenchContribution>(id: string): T {\n\t\tif (this.instancesById.has(id)) {\n\t\t\treturn this.instancesById.get(id) as T;\n\t\t}\n\n\t\tconst instantiationService = this.instantiationService;\n\t\tconst lifecycleService = this.lifecycleService;\n\t\tconst logService = this.logService;\n\t\tconst environmentService = this.environmentService;\n\t\tif (!instantiationService || !lifecycleService || !logService || !environmentService) {\n\t\t\tthrow new Error(`IWorkbenchContributionsRegistry#getContribution('${id}'): cannot be called before registry started`);\n\t\t}\n\n\t\tconst contribution = this.contributionsById.get(id);\n\t\tif (!contribution) {\n\t\t\tthrow new Error(`IWorkbenchContributionsRegistry#getContribution('${id}'): contribution with that identifier is unknown.`);\n\t\t}\n\n\t\tif (lifecycleService.phase < LifecyclePhase.Restored) {\n\t\t\tlogService.warn(`IWorkbenchContributionsRegistry#getContribution('${id}'): contribution instantiated before LifecyclePhase.Restored!`);\n\t\t}\n\n\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, lifecycleService.phase);\n\n\t\tconst instance = this.instancesById.get(id);\n\t\tif (!instance) {\n\t\t\tthrow new Error(`IWorkbenchContributionsRegistry#getContribution('${id}'): failed to create contribution.`);\n\t\t}\n\n\t\treturn instance as T;\n\t}\n\n\tstart(accessor: ServicesAccessor): void {\n\t\tconst instantiationService = this.instantiationService = accessor.get(IInstantiationService);\n\t\tconst lifecycleService = this.lifecycleService = accessor.get(ILifecycleService);\n\t\tconst logService = this.logService = accessor.get(ILogService);\n\t\tconst environmentService = this.environmentService = accessor.get(IEnvironmentService);\n\t\tconst editorPaneService = this.editorPaneService = accessor.get(IEditorPaneService);\n\n\t\t// Dispose contributions on shutdown\n\t\tthis._register(lifecycleService.onDidShutdown(() => {\n\t\t\tthis.instanceDisposables.clear();\n\t\t}));\n\n\t\t// Instantiate contributions by phase when they are ready\n\t\tfor (const phase of [LifecyclePhase.Starting, LifecyclePhase.Ready, LifecyclePhase.Restored, LifecyclePhase.Eventually]) {\n\t\t\tthis.instantiateByPhase(instantiationService, lifecycleService, logService, environmentService, phase);\n\t\t}\n\n\t\t// Instantiate contributions by editor when they are created or have been\n\t\tfor (const editorTypeId of this.contributionsByEditor.keys()) {\n\t\t\tif (editorPaneService.didInstantiateEditorPane(editorTypeId)) {\n\t\t\t\tthis.onEditor(editorTypeId, instantiationService, lifecycleService, logService, environmentService);\n\t\t\t}\n\t\t}\n\t\tthis._register(editorPaneService.onWillInstantiateEditorPane(e => this.onEditor(e.typeId, instantiationService, lifecycleService, logService, environmentService)));\n\t}\n\n\tprivate onEditor(editorTypeId: string, instantiationService: IInstantiationService, lifecycleService: ILifecycleService, logService: ILogService, environmentService: IEnvironmentService): void {\n\t\tconst contributions = this.contributionsByEditor.get(editorTypeId);\n\t\tif (contributions) {\n\t\t\tthis.contributionsByEditor.delete(editorTypeId);\n\n\t\t\tfor (const contribution of contributions) {\n\t\t\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, lifecycleService.phase);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate instantiateByPhase(instantiationService: IInstantiationService, lifecycleService: ILifecycleService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): void {\n\n\t\t// Instantiate contributions directly when phase is already reached\n\t\tif (lifecycleService.phase >= phase) {\n\t\t\tthis.doInstantiateByPhase(instantiationService, logService, environmentService, phase);\n\t\t}\n\n\t\t// Otherwise wait for phase to be reached\n\t\telse {\n\t\t\tlifecycleService.when(phase).then(() => this.doInstantiateByPhase(instantiationService, logService, environmentService, phase));\n\t\t}\n\t}\n\n\tprivate async doInstantiateByPhase(instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): Promise<void> {\n\t\tconst contributions = this.contributionsByPhase.get(phase);\n\t\tif (contributions) {\n\t\t\tthis.contributionsByPhase.delete(phase);\n\n\t\t\tswitch (phase) {\n\t\t\t\tcase LifecyclePhase.Starting:\n\t\t\t\tcase LifecyclePhase.Ready: {\n\n\t\t\t\t\t// instantiate everything synchronously and blocking\n\t\t\t\t\t// measure the time it takes as perf marks for diagnosis\n\n\t\t\t\t\tmark(`code/willCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\t\tfor (const contribution of contributions) {\n\t\t\t\t\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);\n\t\t\t\t\t}\n\n\t\t\t\t\tmark(`code/didCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase LifecyclePhase.Restored:\n\t\t\t\tcase LifecyclePhase.Eventually: {\n\n\t\t\t\t\t// for the Restored/Eventually-phase we instantiate contributions\n\t\t\t\t\t// only when idle. this might take a few idle-busy-cycles but will\n\t\t\t\t\t// finish within the timeouts\n\t\t\t\t\t// given that, we must ensure to await the contributions from the\n\t\t\t\t\t// Restored-phase before we instantiate the Eventually-phase\n\n\t\t\t\t\tif (phase === LifecyclePhase.Eventually) {\n\t\t\t\t\t\tawait this.pendingRestoredContributions.p;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.doInstantiateWhenIdle(contributions, instantiationService, logService, environmentService, phase);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doInstantiateWhenIdle(contributions: IWorkbenchContributionRegistration[], instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): void {\n\t\tmark(`code/willCreateWorkbenchContributions/${phase}`);\n\n\t\tlet i = 0;\n\t\tconst forcedTimeout = phase === LifecyclePhase.Eventually ? 3000 : 500;\n\n\t\tconst instantiateSome = (idle: IdleDeadline) => {\n\t\t\twhile (i < contributions.length) {\n\t\t\t\tconst contribution = contributions[i++];\n\t\t\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);\n\t\t\t\tif (idle.timeRemaining() < 1) {\n\t\t\t\t\t// time is up -> reschedule\n\t\t\t\t\trunWhenGlobalIdle(instantiateSome, forcedTimeout);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i === contributions.length) {\n\t\t\t\tmark(`code/didCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\tif (phase === LifecyclePhase.Restored) {\n\t\t\t\t\tthis.pendingRestoredContributions.complete();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\trunWhenGlobalIdle(instantiateSome, forcedTimeout);\n\t}\n\n\tprivate safeCreateContribution(instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, contribution: IWorkbenchContributionRegistration, phase: LifecyclePhase): void {\n\t\tif (typeof contribution.id === 'string' && this.instancesById.has(contribution.id)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst now = Date.now();\n\n\t\ttry {\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tmark(`code/willCreateWorkbenchContribution/${phase}/${contribution.id}`);\n\t\t\t}\n\n\t\t\tconst instance = instantiationService.createInstance(contribution.ctor);\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tthis.instancesById.set(contribution.id, instance);\n\t\t\t\tthis.contributionsById.delete(contribution.id);\n\t\t\t}\n\t\t\tif (isDisposable(instance)) {\n\t\t\t\tthis.instanceDisposables.add(instance);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogService.error(`Unable to create workbench contribution '${contribution.id ?? contribution.ctor.name}'.`, error);\n\t\t} finally {\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tmark(`code/didCreateWorkbenchContribution/${phase}/${contribution.id}`);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof contribution.id === 'string' || !environmentService.isBuilt /* only log out of sources where we have good ctor names */) {\n\t\t\tconst time = Date.now() - now;\n\t\t\tif (time > (phase < LifecyclePhase.Restored ? WorkbenchContributionsRegistry.BLOCK_BEFORE_RESTORE_WARN_THRESHOLD : WorkbenchContributionsRegistry.BLOCK_AFTER_RESTORE_WARN_THRESHOLD)) {\n\t\t\t\tlogService.warn(`Creation of workbench contribution '${contribution.id ?? contribution.ctor.name}' took ${time}ms.`);\n\t\t\t}\n\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tlet timingsForPhase = this.timingsByPhase.get(phase);\n\t\t\t\tif (!timingsForPhase) {\n\t\t\t\t\ttimingsForPhase = [];\n\t\t\t\t\tthis.timingsByPhase.set(phase, timingsForPhase);\n\t\t\t\t}\n\n\t\t\t\ttimingsForPhase.push([contribution.id, time]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Register a workbench contribution that will be instantiated\n * based on the `instantiation` property.\n */\nexport const registerWorkbenchContribution2 = WorkbenchContributionsRegistry.INSTANCE.registerWorkbenchContribution2.bind(WorkbenchContributionsRegistry.INSTANCE) as {\n\t<Services extends BrandedService[]>(id: string, ctor: IWorkbenchContributionSignature<Services>, instantiation: WorkbenchContributionInstantiation): void;\n};\n\n/**\n * Provides access to a workbench contribution with a specific identifier.\n * The contribution is created if not yet done.\n *\n * Note: will throw an error if\n * - called too early before the registry has started\n * - no contribution is known for the given identifier\n */\nexport const getWorkbenchContribution = WorkbenchContributionsRegistry.INSTANCE.getWorkbenchContribution.bind(WorkbenchContributionsRegistry.INSTANCE);\n\nRegistry.add(Extensions.Workbench, WorkbenchContributionsRegistry.INSTANCE);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService, IConstructorSignature, ServicesAccessor, BrandedService } from '../../platform/instantiation/common/instantiation.js';\nimport { ILifecycleService, LifecyclePhase } from '../services/lifecycle/common/lifecycle.js';\nimport { Registry } from '../../platform/registry/common/platform.js';\nimport { IdleDeadline, DeferredPromise, runWhenGlobalIdle } from '../../base/common/async.js';\nimport { mark } from '../../base/common/performance.js';\nimport { ILogService } from '../../platform/log/common/log.js';\nimport { IEnvironmentService } from '../../platform/environment/common/environment.js';\nimport { getOrSet } from '../../base/common/map.js';\nimport { Disposable, DisposableStore, isDisposable } from '../../base/common/lifecycle.js';\nimport { IEditorPaneService } from '../services/editor/common/editorPaneService.js';\n\n/**\n * A workbench contribution that will be loaded when the workbench starts and disposed when the workbench shuts down.\n */\nexport interface IWorkbenchContribution {\n\t// Marker Interface\n}\n\nexport namespace Extensions {\n\t/**\n\t * @deprecated use `registerWorkbenchContribution2` instead.\n\t */\n\texport const Workbench = 'workbench.contributions.kind';\n}\n\nexport const enum WorkbenchPhase {\n\n\t/**\n\t * The first phase signals that we are about to startup getting ready.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use the other types, preferable\n\t * `Lazy` to only instantiate the contribution when really needed.\n\t */\n\tBlockStartup = LifecyclePhase.Starting,\n\n\t/**\n\t * Services are ready and the window is about to restore its UI state.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use the other types, preferable\n\t * `Lazy` to only instantiate the contribution when really needed.\n\t */\n\tBlockRestore = LifecyclePhase.Ready,\n\n\t/**\n\t * Views, panels and editors have restored. Editors are given a bit of\n\t * time to restore their contents.\n\t */\n\tAfterRestored = LifecyclePhase.Restored,\n\n\t/**\n\t * The last phase after views, panels and editors have restored and\n\t * some time has passed (2-5 seconds).\n\t */\n\tEventually = LifecyclePhase.Eventually\n}\n\n/**\n * A workbenchch contribution that will only be instantiated\n * when calling `getWorkbenchContribution`.\n */\nexport interface ILazyWorkbenchContributionInstantiation {\n\treadonly lazy: true;\n}\n\n/**\n * A workbench contribution that will be instantiated when the\n * corresponding editor is being created.\n */\nexport interface IOnEditorWorkbenchContributionInstantiation {\n\treadonly editorTypeId: string;\n}\n\nfunction isOnEditorWorkbenchContributionInstantiation(obj: unknown): obj is IOnEditorWorkbenchContributionInstantiation {\n\tconst candidate = obj as IOnEditorWorkbenchContributionInstantiation | undefined;\n\treturn !!candidate && typeof candidate.editorTypeId === 'string';\n}\n\nexport type WorkbenchContributionInstantiation = WorkbenchPhase | ILazyWorkbenchContributionInstantiation | IOnEditorWorkbenchContributionInstantiation;\n\nfunction toWorkbenchPhase(phase: LifecyclePhase.Restored | LifecyclePhase.Eventually): WorkbenchPhase.AfterRestored | WorkbenchPhase.Eventually {\n\tswitch (phase) {\n\t\tcase LifecyclePhase.Restored:\n\t\t\treturn WorkbenchPhase.AfterRestored;\n\t\tcase LifecyclePhase.Eventually:\n\t\t\treturn WorkbenchPhase.Eventually;\n\t}\n}\n\nfunction toLifecyclePhase(instantiation: WorkbenchPhase): LifecyclePhase {\n\tswitch (instantiation) {\n\t\tcase WorkbenchPhase.BlockStartup:\n\t\t\treturn LifecyclePhase.Starting;\n\t\tcase WorkbenchPhase.BlockRestore:\n\t\t\treturn LifecyclePhase.Ready;\n\t\tcase WorkbenchPhase.AfterRestored:\n\t\t\treturn LifecyclePhase.Restored;\n\t\tcase WorkbenchPhase.Eventually:\n\t\t\treturn LifecyclePhase.Eventually;\n\t}\n}\n\ntype IWorkbenchContributionSignature<Service extends BrandedService[]> = new (...services: Service) => IWorkbenchContribution;\n\nexport interface IWorkbenchContributionsRegistry {\n\n\t/**\n\t * @deprecated use `registerWorkbenchContribution2` instead.\n\t */\n\tregisterWorkbenchContribution<Services extends BrandedService[]>(contribution: IWorkbenchContributionSignature<Services>, phase: LifecyclePhase.Restored | LifecyclePhase.Eventually): void;\n\n\t/**\n\t * Starts the registry by providing the required services.\n\t */\n\tstart(accessor: ServicesAccessor): void;\n\n\t/**\n\t * A promise that resolves when all contributions up to the `Restored`\n\t * phase have been instantiated.\n\t */\n\treadonly whenRestored: Promise<void>;\n\n\t/**\n\t * Provides access to the instantiation times of all contributions by\n\t * lifecycle phase.\n\t */\n\treadonly timings: Map<LifecyclePhase, Array<[string /* ID */, number /* Creation Time */]>>;\n}\n\ninterface IWorkbenchContributionRegistration {\n\treadonly id: string | undefined;\n\treadonly ctor: IConstructorSignature<IWorkbenchContribution>;\n}\n\nexport class WorkbenchContributionsRegistry extends Disposable implements IWorkbenchContributionsRegistry {\n\n\tstatic readonly INSTANCE = new WorkbenchContributionsRegistry();\n\n\tprivate static readonly BLOCK_BEFORE_RESTORE_WARN_THRESHOLD = 20;\n\tprivate static readonly BLOCK_AFTER_RESTORE_WARN_THRESHOLD = 100;\n\n\tprivate instantiationService: IInstantiationService | undefined;\n\tprivate lifecycleService: ILifecycleService | undefined;\n\tprivate logService: ILogService | undefined;\n\tprivate environmentService: IEnvironmentService | undefined;\n\tprivate editorPaneService: IEditorPaneService | undefined;\n\n\tprivate readonly contributionsByPhase = new Map<LifecyclePhase, IWorkbenchContributionRegistration[]>();\n\tprivate readonly contributionsByEditor = new Map<string, IWorkbenchContributionRegistration[]>();\n\tprivate readonly contributionsById = new Map<string, IWorkbenchContributionRegistration>();\n\n\tprivate readonly instancesById = new Map<string, IWorkbenchContribution>();\n\tprivate readonly instanceDisposables = this._register(new DisposableStore());\n\n\tprivate readonly timingsByPhase = new Map<LifecyclePhase, Array<[string /* ID */, number /* Creation Time */]>>();\n\tget timings() { return this.timingsByPhase; }\n\n\tprivate readonly pendingRestoredContributions = new DeferredPromise<void>();\n\treadonly whenRestored = this.pendingRestoredContributions.p;\n\n\tregisterWorkbenchContribution2(id: string, ctor: IConstructorSignature<IWorkbenchContribution>, phase: WorkbenchPhase.BlockStartup | WorkbenchPhase.BlockRestore): void;\n\tregisterWorkbenchContribution2(id: string | undefined, ctor: IConstructorSignature<IWorkbenchContribution>, phase: WorkbenchPhase.AfterRestored | WorkbenchPhase.Eventually): void;\n\tregisterWorkbenchContribution2(id: string, ctor: IConstructorSignature<IWorkbenchContribution>, lazy: ILazyWorkbenchContributionInstantiation): void;\n\tregisterWorkbenchContribution2(id: string, ctor: IConstructorSignature<IWorkbenchContribution>, onEditor: IOnEditorWorkbenchContributionInstantiation): void;\n\tregisterWorkbenchContribution2(id: string | undefined, ctor: IConstructorSignature<IWorkbenchContribution>, instantiation: WorkbenchContributionInstantiation): void {\n\t\tconst contribution: IWorkbenchContributionRegistration = { id, ctor };\n\n\t\t// Instantiate directly if we already have a matching instantiation condition\n\t\tif (\n\t\t\tthis.instantiationService && this.lifecycleService && this.logService && this.environmentService && this.editorPaneService &&\n\t\t\t(\n\t\t\t\t(typeof instantiation === 'number' && this.lifecycleService.phase >= instantiation) ||\n\t\t\t\t(typeof id === 'string' && isOnEditorWorkbenchContributionInstantiation(instantiation) && this.editorPaneService.didInstantiateEditorPane(instantiation.editorTypeId))\n\t\t\t)\n\t\t) {\n\t\t\tthis.safeCreateContribution(this.instantiationService, this.logService, this.environmentService, contribution, typeof instantiation === 'number' ? toLifecyclePhase(instantiation) : this.lifecycleService.phase);\n\t\t}\n\n\t\t// Otherwise keep contributions by instantiation kind for later instantiation\n\t\telse {\n\n\t\t\t// by phase\n\t\t\tif (typeof instantiation === 'number') {\n\t\t\t\tgetOrSet(this.contributionsByPhase, toLifecyclePhase(instantiation), []).push(contribution);\n\t\t\t}\n\n\t\t\tif (typeof id === 'string') {\n\n\t\t\t\t// by id\n\t\t\t\tif (!this.contributionsById.has(id)) {\n\t\t\t\t\tthis.contributionsById.set(id, contribution);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(`IWorkbenchContributionsRegistry#registerWorkbenchContribution(): Can't register multiple contributions with same id '${id}'`);\n\t\t\t\t}\n\n\t\t\t\t// by editor\n\t\t\t\tif (isOnEditorWorkbenchContributionInstantiation(instantiation)) {\n\t\t\t\t\tgetOrSet(this.contributionsByEditor, instantiation.editorTypeId, []).push(contribution);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterWorkbenchContribution(ctor: IConstructorSignature<IWorkbenchContribution>, phase: LifecyclePhase.Restored | LifecyclePhase.Eventually): void {\n\t\tthis.registerWorkbenchContribution2(undefined, ctor, toWorkbenchPhase(phase));\n\t}\n\n\tgetWorkbenchContribution<T extends IWorkbenchContribution>(id: string): T {\n\t\tif (this.instancesById.has(id)) {\n\t\t\treturn this.instancesById.get(id) as T;\n\t\t}\n\n\t\tconst instantiationService = this.instantiationService;\n\t\tconst lifecycleService = this.lifecycleService;\n\t\tconst logService = this.logService;\n\t\tconst environmentService = this.environmentService;\n\t\tif (!instantiationService || !lifecycleService || !logService || !environmentService) {\n\t\t\tthrow new Error(`IWorkbenchContributionsRegistry#getContribution('${id}'): cannot be called before registry started`);\n\t\t}\n\n\t\tconst contribution = this.contributionsById.get(id);\n\t\tif (!contribution) {\n\t\t\tthrow new Error(`IWorkbenchContributionsRegistry#getContribution('${id}'): contribution with that identifier is unknown.`);\n\t\t}\n\n\t\tif (lifecycleService.phase < LifecyclePhase.Restored) {\n\t\t\tlogService.warn(`IWorkbenchContributionsRegistry#getContribution('${id}'): contribution instantiated before LifecyclePhase.Restored!`);\n\t\t}\n\n\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, lifecycleService.phase);\n\n\t\tconst instance = this.instancesById.get(id);\n\t\tif (!instance) {\n\t\t\tthrow new Error(`IWorkbenchContributionsRegistry#getContribution('${id}'): failed to create contribution.`);\n\t\t}\n\n\t\treturn instance as T;\n\t}\n\n\tstart(accessor: ServicesAccessor): void {\n\t\tconst instantiationService = this.instantiationService = accessor.get(IInstantiationService);\n\t\tconst lifecycleService = this.lifecycleService = accessor.get(ILifecycleService);\n\t\tconst logService = this.logService = accessor.get(ILogService);\n\t\tconst environmentService = this.environmentService = accessor.get(IEnvironmentService);\n\t\tconst editorPaneService = this.editorPaneService = accessor.get(IEditorPaneService);\n\n\t\t// Dispose contributions on shutdown\n\t\tthis._register(lifecycleService.onDidShutdown(() => {\n\t\t\tthis.instanceDisposables.clear();\n\t\t}));\n\n\t\t// Instantiate contributions by phase when they are ready\n\t\tfor (const phase of [LifecyclePhase.Starting, LifecyclePhase.Ready, LifecyclePhase.Restored, LifecyclePhase.Eventually]) {\n\t\t\tthis.instantiateByPhase(instantiationService, lifecycleService, logService, environmentService, phase);\n\t\t}\n\n\t\t// Instantiate contributions by editor when they are created or have been\n\t\tfor (const editorTypeId of this.contributionsByEditor.keys()) {\n\t\t\tif (editorPaneService.didInstantiateEditorPane(editorTypeId)) {\n\t\t\t\tthis.onEditor(editorTypeId, instantiationService, lifecycleService, logService, environmentService);\n\t\t\t}\n\t\t}\n\t\tthis._register(editorPaneService.onWillInstantiateEditorPane(e => this.onEditor(e.typeId, instantiationService, lifecycleService, logService, environmentService)));\n\t}\n\n\tprivate onEditor(editorTypeId: string, instantiationService: IInstantiationService, lifecycleService: ILifecycleService, logService: ILogService, environmentService: IEnvironmentService): void {\n\t\tconst contributions = this.contributionsByEditor.get(editorTypeId);\n\t\tif (contributions) {\n\t\t\tthis.contributionsByEditor.delete(editorTypeId);\n\n\t\t\tfor (const contribution of contributions) {\n\t\t\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, lifecycleService.phase);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate instantiateByPhase(instantiationService: IInstantiationService, lifecycleService: ILifecycleService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): void {\n\n\t\t// Instantiate contributions directly when phase is already reached\n\t\tif (lifecycleService.phase >= phase) {\n\t\t\tthis.doInstantiateByPhase(instantiationService, logService, environmentService, phase);\n\t\t}\n\n\t\t// Otherwise wait for phase to be reached\n\t\telse {\n\t\t\tlifecycleService.when(phase).then(() => this.doInstantiateByPhase(instantiationService, logService, environmentService, phase));\n\t\t}\n\t}\n\n\tprivate async doInstantiateByPhase(instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): Promise<void> {\n\t\tconst contributions = this.contributionsByPhase.get(phase);\n\t\tif (contributions) {\n\t\t\tthis.contributionsByPhase.delete(phase);\n\n\t\t\tswitch (phase) {\n\t\t\t\tcase LifecyclePhase.Starting:\n\t\t\t\tcase LifecyclePhase.Ready: {\n\n\t\t\t\t\t// instantiate everything synchronously and blocking\n\t\t\t\t\t// measure the time it takes as perf marks for diagnosis\n\n\t\t\t\t\tmark(`code/willCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\t\tfor (const contribution of contributions) {\n\t\t\t\t\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);\n\t\t\t\t\t}\n\n\t\t\t\t\tmark(`code/didCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase LifecyclePhase.Restored:\n\t\t\t\tcase LifecyclePhase.Eventually: {\n\n\t\t\t\t\t// for the Restored/Eventually-phase we instantiate contributions\n\t\t\t\t\t// only when idle. this might take a few idle-busy-cycles but will\n\t\t\t\t\t// finish within the timeouts\n\t\t\t\t\t// given that, we must ensure to await the contributions from the\n\t\t\t\t\t// Restored-phase before we instantiate the Eventually-phase\n\n\t\t\t\t\tif (phase === LifecyclePhase.Eventually) {\n\t\t\t\t\t\tawait this.pendingRestoredContributions.p;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.doInstantiateWhenIdle(contributions, instantiationService, logService, environmentService, phase);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doInstantiateWhenIdle(contributions: IWorkbenchContributionRegistration[], instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): void {\n\t\tmark(`code/willCreateWorkbenchContributions/${phase}`);\n\n\t\tlet i = 0;\n\t\tconst forcedTimeout = phase === LifecyclePhase.Eventually ? 3000 : 500;\n\n\t\tconst instantiateSome = (idle: IdleDeadline) => {\n\t\t\twhile (i < contributions.length) {\n\t\t\t\tconst contribution = contributions[i++];\n\t\t\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);\n\t\t\t\tif (idle.timeRemaining() < 1) {\n\t\t\t\t\t// time is up -> reschedule\n\t\t\t\t\trunWhenGlobalIdle(instantiateSome, forcedTimeout);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i === contributions.length) {\n\t\t\t\tmark(`code/didCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\tif (phase === LifecyclePhase.Restored) {\n\t\t\t\t\tthis.pendingRestoredContributions.complete();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\trunWhenGlobalIdle(instantiateSome, forcedTimeout);\n\t}\n\n\tprivate safeCreateContribution(instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, contribution: IWorkbenchContributionRegistration, phase: LifecyclePhase): void {\n\t\tif (typeof contribution.id === 'string' && this.instancesById.has(contribution.id)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst now = Date.now();\n\n\t\ttry {\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tmark(`code/willCreateWorkbenchContribution/${phase}/${contribution.id}`);\n\t\t\t}\n\n\t\t\tconst instance = instantiationService.createInstance(contribution.ctor);\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tthis.instancesById.set(contribution.id, instance);\n\t\t\t\tthis.contributionsById.delete(contribution.id);\n\t\t\t}\n\t\t\tif (isDisposable(instance)) {\n\t\t\t\tthis.instanceDisposables.add(instance);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogService.error(`Unable to create workbench contribution '${contribution.id ?? contribution.ctor.name}'.`, error);\n\t\t} finally {\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tmark(`code/didCreateWorkbenchContribution/${phase}/${contribution.id}`);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof contribution.id === 'string' || !environmentService.isBuilt /* only log out of sources where we have good ctor names */) {\n\t\t\tconst time = Date.now() - now;\n\t\t\tif (time > (phase < LifecyclePhase.Restored ? WorkbenchContributionsRegistry.BLOCK_BEFORE_RESTORE_WARN_THRESHOLD : WorkbenchContributionsRegistry.BLOCK_AFTER_RESTORE_WARN_THRESHOLD)) {\n\t\t\t\tlogService.warn(`Creation of workbench contribution '${contribution.id ?? contribution.ctor.name}' took ${time}ms.`);\n\t\t\t}\n\n\t\t\tif (typeof contribution.id === 'string') {\n\t\t\t\tlet timingsForPhase = this.timingsByPhase.get(phase);\n\t\t\t\tif (!timingsForPhase) {\n\t\t\t\t\ttimingsForPhase = [];\n\t\t\t\t\tthis.timingsByPhase.set(phase, timingsForPhase);\n\t\t\t\t}\n\n\t\t\t\ttimingsForPhase.push([contribution.id, time]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Register a workbench contribution that will be instantiated\n * based on the `instantiation` property.\n */\nexport const registerWorkbenchContribution2 = WorkbenchContributionsRegistry.INSTANCE.registerWorkbenchContribution2.bind(WorkbenchContributionsRegistry.INSTANCE) as {\n\t<Services extends BrandedService[]>(id: string, ctor: IWorkbenchContributionSignature<Services>, instantiation: WorkbenchContributionInstantiation): void;\n};\n\n/**\n * Provides access to a workbench contribution with a specific identifier.\n * The contribution is created if not yet done.\n *\n * Note: will throw an error if\n * - called too early before the registry has started\n * - no contribution is known for the given identifier\n */\nexport const getWorkbenchContribution = WorkbenchContributionsRegistry.INSTANCE.getWorkbenchContribution.bind(WorkbenchContributionsRegistry.INSTANCE);\n\nRegistry.add(Extensions.Workbench, WorkbenchContributionsRegistry.INSTANCE);\n"]}