{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/common/resources.ts","vs/workbench/common/resources.ts"],"names":[],"mappings":"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","file":"resources.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../base/common/uri.js';\nimport { equals } from '../../base/common/objects.js';\nimport { isAbsolute } from '../../base/common/path.js';\nimport { Emitter } from '../../base/common/event.js';\nimport { relativePath } from '../../base/common/resources.js';\nimport { Disposable } from '../../base/common/lifecycle.js';\nimport { ParsedExpression, IExpression, parse } from '../../base/common/glob.js';\nimport { IWorkspaceContextService } from '../../platform/workspace/common/workspace.js';\nimport { IConfigurationService, IConfigurationChangeEvent } from '../../platform/configuration/common/configuration.js';\nimport { Schemas } from '../../base/common/network.js';\nimport { ResourceSet } from '../../base/common/map.js';\nimport { getDriveLetter } from '../../base/common/extpath.js';\n\ninterface IConfiguredExpression {\n\treadonly expression: IExpression;\n\treadonly hasAbsolutePath: boolean;\n}\n\nexport class ResourceGlobMatcher extends Disposable {\n\n\tprivate static readonly NO_FOLDER = null;\n\n\tprivate readonly _onExpressionChange = this._register(new Emitter<void>());\n\treadonly onExpressionChange = this._onExpressionChange.event;\n\n\tprivate readonly mapFolderToParsedExpression = new Map<string | null, ParsedExpression>();\n\tprivate readonly mapFolderToConfiguredExpression = new Map<string | null, IConfiguredExpression>();\n\n\tconstructor(\n\t\tprivate getExpression: (folder?: URI) => IExpression | undefined,\n\t\tprivate shouldUpdate: (event: IConfigurationChangeEvent) => boolean,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tthis.updateExpressions(false);\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (this.shouldUpdate(e)) {\n\t\t\t\tthis.updateExpressions(true);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(this.contextService.onDidChangeWorkspaceFolders(() => this.updateExpressions(true)));\n\t}\n\n\tprivate updateExpressions(fromEvent: boolean): void {\n\t\tlet changed = false;\n\n\t\t// Add expressions per workspaces that got added\n\t\tfor (const folder of this.contextService.getWorkspace().folders) {\n\t\t\tconst folderUriStr = folder.uri.toString();\n\n\t\t\tconst newExpression = this.doGetExpression(folder.uri);\n\t\t\tconst currentExpression = this.mapFolderToConfiguredExpression.get(folderUriStr);\n\n\t\t\tif (newExpression) {\n\t\t\t\tif (!currentExpression || !equals(currentExpression.expression, newExpression.expression)) {\n\t\t\t\t\tchanged = true;\n\n\t\t\t\t\tthis.mapFolderToParsedExpression.set(folderUriStr, parse(newExpression.expression));\n\t\t\t\t\tthis.mapFolderToConfiguredExpression.set(folderUriStr, newExpression);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentExpression) {\n\t\t\t\t\tchanged = true;\n\n\t\t\t\t\tthis.mapFolderToParsedExpression.delete(folderUriStr);\n\t\t\t\t\tthis.mapFolderToConfiguredExpression.delete(folderUriStr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove expressions per workspace no longer present\n\t\tconst foldersMap = new ResourceSet(this.contextService.getWorkspace().folders.map(folder => folder.uri));\n\t\tfor (const [folder] of this.mapFolderToConfiguredExpression) {\n\t\t\tif (folder === ResourceGlobMatcher.NO_FOLDER) {\n\t\t\t\tcontinue; // always keep this one\n\t\t\t}\n\n\t\t\tif (!foldersMap.has(URI.parse(folder))) {\n\t\t\t\tthis.mapFolderToParsedExpression.delete(folder);\n\t\t\t\tthis.mapFolderToConfiguredExpression.delete(folder);\n\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Always set for resources outside workspace as well\n\t\tconst globalNewExpression = this.doGetExpression(undefined);\n\t\tconst globalCurrentExpression = this.mapFolderToConfiguredExpression.get(ResourceGlobMatcher.NO_FOLDER);\n\t\tif (globalNewExpression) {\n\t\t\tif (!globalCurrentExpression || !equals(globalCurrentExpression.expression, globalNewExpression.expression)) {\n\t\t\t\tchanged = true;\n\n\t\t\t\tthis.mapFolderToParsedExpression.set(ResourceGlobMatcher.NO_FOLDER, parse(globalNewExpression.expression));\n\t\t\t\tthis.mapFolderToConfiguredExpression.set(ResourceGlobMatcher.NO_FOLDER, globalNewExpression);\n\t\t\t}\n\t\t} else {\n\t\t\tif (globalCurrentExpression) {\n\t\t\t\tchanged = true;\n\n\t\t\t\tthis.mapFolderToParsedExpression.delete(ResourceGlobMatcher.NO_FOLDER);\n\t\t\t\tthis.mapFolderToConfiguredExpression.delete(ResourceGlobMatcher.NO_FOLDER);\n\t\t\t}\n\t\t}\n\n\t\tif (fromEvent && changed) {\n\t\t\tthis._onExpressionChange.fire();\n\t\t}\n\t}\n\n\tprivate doGetExpression(resource: URI | undefined): IConfiguredExpression | undefined {\n\t\tconst expression = this.getExpression(resource);\n\t\tif (!expression) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst keys = Object.keys(expression);\n\t\tif (keys.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet hasAbsolutePath = false;\n\n\t\t// Check the expression for absolute paths/globs\n\t\t// and specifically for Windows, make sure the\n\t\t// drive letter is lowercased, because we later\n\t\t// check with `URI.fsPath` which is always putting\n\t\t// the drive letter lowercased.\n\n\t\tconst massagedExpression: IExpression = Object.create(null);\n\t\tfor (const key of keys) {\n\t\t\tif (!hasAbsolutePath) {\n\t\t\t\thasAbsolutePath = isAbsolute(key);\n\t\t\t}\n\n\t\t\tlet massagedKey = key;\n\n\t\t\tconst driveLetter = getDriveLetter(massagedKey, true /* probe for windows */);\n\t\t\tif (driveLetter) {\n\t\t\t\tconst driveLetterLower = driveLetter.toLowerCase();\n\t\t\t\tif (driveLetter !== driveLetter.toLowerCase()) {\n\t\t\t\t\tmassagedKey = `${driveLetterLower}${massagedKey.substring(1)}`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmassagedExpression[massagedKey] = expression[key];\n\t\t}\n\n\t\treturn {\n\t\t\texpression: massagedExpression,\n\t\t\thasAbsolutePath\n\t\t};\n\t}\n\n\tmatches(\n\t\tresource: URI,\n\t\thasSibling?: (name: string) => boolean\n\t): boolean {\n\t\tif (this.mapFolderToParsedExpression.size === 0) {\n\t\t\treturn false; // return early: no expression for this matcher\n\t\t}\n\n\t\tconst folder = this.contextService.getWorkspaceFolder(resource);\n\t\tlet expressionForFolder: ParsedExpression | undefined;\n\t\tlet expressionConfigForFolder: IConfiguredExpression | undefined;\n\t\tif (folder && this.mapFolderToParsedExpression.has(folder.uri.toString())) {\n\t\t\texpressionForFolder = this.mapFolderToParsedExpression.get(folder.uri.toString());\n\t\t\texpressionConfigForFolder = this.mapFolderToConfiguredExpression.get(folder.uri.toString());\n\t\t} else {\n\t\t\texpressionForFolder = this.mapFolderToParsedExpression.get(ResourceGlobMatcher.NO_FOLDER);\n\t\t\texpressionConfigForFolder = this.mapFolderToConfiguredExpression.get(ResourceGlobMatcher.NO_FOLDER);\n\t\t}\n\n\t\tif (!expressionForFolder) {\n\t\t\treturn false; // return early: no expression for this resource\n\t\t}\n\n\t\t// If the resource if from a workspace, convert its absolute path to a relative\n\t\t// path so that glob patterns have a higher probability to match. For example\n\t\t// a glob pattern of \"src/**\" will not match on an absolute path \"/folder/src/file.txt\"\n\t\t// but can match on \"src/file.txt\"\n\n\t\tlet resourcePathToMatch: string | undefined;\n\t\tif (folder) {\n\t\t\tresourcePathToMatch = relativePath(folder.uri, resource);\n\t\t} else {\n\t\t\tresourcePathToMatch = this.uriToPath(resource);\n\t\t}\n\n\t\tif (typeof resourcePathToMatch === 'string' && !!expressionForFolder(resourcePathToMatch, undefined, hasSibling)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If the configured expression has an absolute path, we also check for absolute paths\n\t\t// to match, otherwise we potentially miss out on matches. We only do that if we previously\n\t\t// matched on the relative path.\n\n\t\tif (resourcePathToMatch !== this.uriToPath(resource) && expressionConfigForFolder?.hasAbsolutePath) {\n\t\t\treturn !!expressionForFolder(this.uriToPath(resource), undefined, hasSibling);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate uriToPath(uri: URI): string {\n\t\tif (uri.scheme === Schemas.file) {\n\t\t\treturn uri.fsPath;\n\t\t}\n\n\t\treturn uri.path;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../base/common/uri.js';\nimport { equals } from '../../base/common/objects.js';\nimport { isAbsolute } from '../../base/common/path.js';\nimport { Emitter } from '../../base/common/event.js';\nimport { relativePath } from '../../base/common/resources.js';\nimport { Disposable } from '../../base/common/lifecycle.js';\nimport { ParsedExpression, IExpression, parse } from '../../base/common/glob.js';\nimport { IWorkspaceContextService } from '../../platform/workspace/common/workspace.js';\nimport { IConfigurationService, IConfigurationChangeEvent } from '../../platform/configuration/common/configuration.js';\nimport { Schemas } from '../../base/common/network.js';\nimport { ResourceSet } from '../../base/common/map.js';\nimport { getDriveLetter } from '../../base/common/extpath.js';\n\ninterface IConfiguredExpression {\n\treadonly expression: IExpression;\n\treadonly hasAbsolutePath: boolean;\n}\n\nexport class ResourceGlobMatcher extends Disposable {\n\n\tprivate static readonly NO_FOLDER = null;\n\n\tprivate readonly _onExpressionChange = this._register(new Emitter<void>());\n\treadonly onExpressionChange = this._onExpressionChange.event;\n\n\tprivate readonly mapFolderToParsedExpression = new Map<string | null, ParsedExpression>();\n\tprivate readonly mapFolderToConfiguredExpression = new Map<string | null, IConfiguredExpression>();\n\n\tconstructor(\n\t\tprivate getExpression: (folder?: URI) => IExpression | undefined,\n\t\tprivate shouldUpdate: (event: IConfigurationChangeEvent) => boolean,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tthis.updateExpressions(false);\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (this.shouldUpdate(e)) {\n\t\t\t\tthis.updateExpressions(true);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(this.contextService.onDidChangeWorkspaceFolders(() => this.updateExpressions(true)));\n\t}\n\n\tprivate updateExpressions(fromEvent: boolean): void {\n\t\tlet changed = false;\n\n\t\t// Add expressions per workspaces that got added\n\t\tfor (const folder of this.contextService.getWorkspace().folders) {\n\t\t\tconst folderUriStr = folder.uri.toString();\n\n\t\t\tconst newExpression = this.doGetExpression(folder.uri);\n\t\t\tconst currentExpression = this.mapFolderToConfiguredExpression.get(folderUriStr);\n\n\t\t\tif (newExpression) {\n\t\t\t\tif (!currentExpression || !equals(currentExpression.expression, newExpression.expression)) {\n\t\t\t\t\tchanged = true;\n\n\t\t\t\t\tthis.mapFolderToParsedExpression.set(folderUriStr, parse(newExpression.expression));\n\t\t\t\t\tthis.mapFolderToConfiguredExpression.set(folderUriStr, newExpression);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentExpression) {\n\t\t\t\t\tchanged = true;\n\n\t\t\t\t\tthis.mapFolderToParsedExpression.delete(folderUriStr);\n\t\t\t\t\tthis.mapFolderToConfiguredExpression.delete(folderUriStr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove expressions per workspace no longer present\n\t\tconst foldersMap = new ResourceSet(this.contextService.getWorkspace().folders.map(folder => folder.uri));\n\t\tfor (const [folder] of this.mapFolderToConfiguredExpression) {\n\t\t\tif (folder === ResourceGlobMatcher.NO_FOLDER) {\n\t\t\t\tcontinue; // always keep this one\n\t\t\t}\n\n\t\t\tif (!foldersMap.has(URI.parse(folder))) {\n\t\t\t\tthis.mapFolderToParsedExpression.delete(folder);\n\t\t\t\tthis.mapFolderToConfiguredExpression.delete(folder);\n\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Always set for resources outside workspace as well\n\t\tconst globalNewExpression = this.doGetExpression(undefined);\n\t\tconst globalCurrentExpression = this.mapFolderToConfiguredExpression.get(ResourceGlobMatcher.NO_FOLDER);\n\t\tif (globalNewExpression) {\n\t\t\tif (!globalCurrentExpression || !equals(globalCurrentExpression.expression, globalNewExpression.expression)) {\n\t\t\t\tchanged = true;\n\n\t\t\t\tthis.mapFolderToParsedExpression.set(ResourceGlobMatcher.NO_FOLDER, parse(globalNewExpression.expression));\n\t\t\t\tthis.mapFolderToConfiguredExpression.set(ResourceGlobMatcher.NO_FOLDER, globalNewExpression);\n\t\t\t}\n\t\t} else {\n\t\t\tif (globalCurrentExpression) {\n\t\t\t\tchanged = true;\n\n\t\t\t\tthis.mapFolderToParsedExpression.delete(ResourceGlobMatcher.NO_FOLDER);\n\t\t\t\tthis.mapFolderToConfiguredExpression.delete(ResourceGlobMatcher.NO_FOLDER);\n\t\t\t}\n\t\t}\n\n\t\tif (fromEvent && changed) {\n\t\t\tthis._onExpressionChange.fire();\n\t\t}\n\t}\n\n\tprivate doGetExpression(resource: URI | undefined): IConfiguredExpression | undefined {\n\t\tconst expression = this.getExpression(resource);\n\t\tif (!expression) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst keys = Object.keys(expression);\n\t\tif (keys.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet hasAbsolutePath = false;\n\n\t\t// Check the expression for absolute paths/globs\n\t\t// and specifically for Windows, make sure the\n\t\t// drive letter is lowercased, because we later\n\t\t// check with `URI.fsPath` which is always putting\n\t\t// the drive letter lowercased.\n\n\t\tconst massagedExpression: IExpression = Object.create(null);\n\t\tfor (const key of keys) {\n\t\t\tif (!hasAbsolutePath) {\n\t\t\t\thasAbsolutePath = isAbsolute(key);\n\t\t\t}\n\n\t\t\tlet massagedKey = key;\n\n\t\t\tconst driveLetter = getDriveLetter(massagedKey, true /* probe for windows */);\n\t\t\tif (driveLetter) {\n\t\t\t\tconst driveLetterLower = driveLetter.toLowerCase();\n\t\t\t\tif (driveLetter !== driveLetter.toLowerCase()) {\n\t\t\t\t\tmassagedKey = `${driveLetterLower}${massagedKey.substring(1)}`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmassagedExpression[massagedKey] = expression[key];\n\t\t}\n\n\t\treturn {\n\t\t\texpression: massagedExpression,\n\t\t\thasAbsolutePath\n\t\t};\n\t}\n\n\tmatches(\n\t\tresource: URI,\n\t\thasSibling?: (name: string) => boolean\n\t): boolean {\n\t\tif (this.mapFolderToParsedExpression.size === 0) {\n\t\t\treturn false; // return early: no expression for this matcher\n\t\t}\n\n\t\tconst folder = this.contextService.getWorkspaceFolder(resource);\n\t\tlet expressionForFolder: ParsedExpression | undefined;\n\t\tlet expressionConfigForFolder: IConfiguredExpression | undefined;\n\t\tif (folder && this.mapFolderToParsedExpression.has(folder.uri.toString())) {\n\t\t\texpressionForFolder = this.mapFolderToParsedExpression.get(folder.uri.toString());\n\t\t\texpressionConfigForFolder = this.mapFolderToConfiguredExpression.get(folder.uri.toString());\n\t\t} else {\n\t\t\texpressionForFolder = this.mapFolderToParsedExpression.get(ResourceGlobMatcher.NO_FOLDER);\n\t\t\texpressionConfigForFolder = this.mapFolderToConfiguredExpression.get(ResourceGlobMatcher.NO_FOLDER);\n\t\t}\n\n\t\tif (!expressionForFolder) {\n\t\t\treturn false; // return early: no expression for this resource\n\t\t}\n\n\t\t// If the resource if from a workspace, convert its absolute path to a relative\n\t\t// path so that glob patterns have a higher probability to match. For example\n\t\t// a glob pattern of \"src/**\" will not match on an absolute path \"/folder/src/file.txt\"\n\t\t// but can match on \"src/file.txt\"\n\n\t\tlet resourcePathToMatch: string | undefined;\n\t\tif (folder) {\n\t\t\tresourcePathToMatch = relativePath(folder.uri, resource);\n\t\t} else {\n\t\t\tresourcePathToMatch = this.uriToPath(resource);\n\t\t}\n\n\t\tif (typeof resourcePathToMatch === 'string' && !!expressionForFolder(resourcePathToMatch, undefined, hasSibling)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If the configured expression has an absolute path, we also check for absolute paths\n\t\t// to match, otherwise we potentially miss out on matches. We only do that if we previously\n\t\t// matched on the relative path.\n\n\t\tif (resourcePathToMatch !== this.uriToPath(resource) && expressionConfigForFolder?.hasAbsolutePath) {\n\t\t\treturn !!expressionForFolder(this.uriToPath(resource), undefined, hasSibling);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate uriToPath(uri: URI): string {\n\t\tif (uri.scheme === Schemas.file) {\n\t\t\treturn uri.fsPath;\n\t\t}\n\n\t\treturn uri.path;\n\t}\n}\n"]}