{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/common/editor/filteredEditorGroupModel.ts","vs/workbench/common/editor/filteredEditorGroupModel.ts"],"names":[],"mappings":"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","file":"filteredEditorGroupModel.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IUntypedEditorInput, IMatchEditorOptions, EditorsOrder, GroupIdentifier } from '../editor.js';\nimport { EditorInput } from './editorInput.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { IGroupModelChangeEvent, IReadonlyEditorGroupModel } from './editorGroupModel.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\n\nabstract class FilteredEditorGroupModel extends Disposable implements IReadonlyEditorGroupModel {\n\n\tprivate readonly _onDidModelChange = this._register(new Emitter<IGroupModelChangeEvent>());\n\treadonly onDidModelChange = this._onDidModelChange.event;\n\n\tconstructor(\n\t\tprotected readonly model: IReadonlyEditorGroupModel\n\t) {\n\t\tsuper();\n\n\t\tthis._register(this.model.onDidModelChange(e => {\n\t\t\tconst candidateOrIndex = e.editorIndex ?? e.editor;\n\t\t\tif (candidateOrIndex !== undefined) {\n\t\t\t\tif (!this.filter(candidateOrIndex)) {\n\t\t\t\t\treturn; // exclude events for excluded items\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._onDidModelChange.fire(e);\n\t\t}));\n\t}\n\n\tget id(): GroupIdentifier { return this.model.id; }\n\tget isLocked(): boolean { return this.model.isLocked; }\n\tget stickyCount(): number { return this.model.stickyCount; }\n\n\tget activeEditor(): EditorInput | null { return this.model.activeEditor && this.filter(this.model.activeEditor) ? this.model.activeEditor : null; }\n\tget previewEditor(): EditorInput | null { return this.model.previewEditor && this.filter(this.model.previewEditor) ? this.model.previewEditor : null; }\n\tget selectedEditors(): EditorInput[] { return this.model.selectedEditors.filter(e => this.filter(e)); }\n\n\tisPinned(editorOrIndex: EditorInput | number): boolean { return this.model.isPinned(editorOrIndex); }\n\tisTransient(editorOrIndex: EditorInput | number): boolean { return this.model.isTransient(editorOrIndex); }\n\tisSticky(editorOrIndex: EditorInput | number): boolean { return this.model.isSticky(editorOrIndex); }\n\tisActive(editor: EditorInput | IUntypedEditorInput): boolean { return this.model.isActive(editor); }\n\tisSelected(editorOrIndex: EditorInput | number): boolean { return this.model.isSelected(editorOrIndex); }\n\n\tisFirst(editor: EditorInput): boolean {\n\t\treturn this.model.isFirst(editor, this.getEditors(EditorsOrder.SEQUENTIAL));\n\t}\n\n\tisLast(editor: EditorInput): boolean {\n\t\treturn this.model.isLast(editor, this.getEditors(EditorsOrder.SEQUENTIAL));\n\t}\n\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[] {\n\t\tconst editors = this.model.getEditors(order, options);\n\t\treturn editors.filter(e => this.filter(e));\n\t}\n\n\tfindEditor(candidate: EditorInput | null, options?: IMatchEditorOptions): [EditorInput, number] | undefined {\n\t\tconst result = this.model.findEditor(candidate, options);\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.filter(result[1]) ? result : undefined;\n\t}\n\n\tabstract get count(): number;\n\n\tabstract getEditorByIndex(index: number): EditorInput | undefined;\n\tabstract indexOf(editor: EditorInput | IUntypedEditorInput | null, editors?: EditorInput[], options?: IMatchEditorOptions): number;\n\tabstract contains(editor: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean;\n\n\tprotected abstract filter(editorOrIndex: EditorInput | number): boolean;\n}\n\nexport class StickyEditorGroupModel extends FilteredEditorGroupModel {\n\tget count(): number { return this.model.stickyCount; }\n\n\toverride getEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[] {\n\t\tif (options?.excludeSticky) {\n\t\t\treturn [];\n\t\t}\n\t\tif (order === EditorsOrder.SEQUENTIAL) {\n\t\t\treturn this.model.getEditors(EditorsOrder.SEQUENTIAL).slice(0, this.model.stickyCount);\n\t\t}\n\t\treturn super.getEditors(order, options);\n\t}\n\n\toverride isSticky(editorOrIndex: number | EditorInput): boolean {\n\t\treturn true;\n\t}\n\n\tgetEditorByIndex(index: number): EditorInput | undefined {\n\t\treturn index < this.count ? this.model.getEditorByIndex(index) : undefined;\n\t}\n\n\tindexOf(editor: EditorInput | IUntypedEditorInput | null, editors?: EditorInput[], options?: IMatchEditorOptions): number {\n\t\tconst editorIndex = this.model.indexOf(editor, editors, options);\n\t\tif (editorIndex < 0 || editorIndex >= this.model.stickyCount) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn editorIndex;\n\t}\n\n\tcontains(candidate: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean {\n\t\tconst editorIndex = this.model.indexOf(candidate, undefined, options);\n\t\treturn editorIndex >= 0 && editorIndex < this.model.stickyCount;\n\t}\n\n\tprotected filter(candidateOrIndex: EditorInput | number): boolean {\n\t\treturn this.model.isSticky(candidateOrIndex);\n\t}\n}\n\nexport class UnstickyEditorGroupModel extends FilteredEditorGroupModel {\n\tget count(): number { return this.model.count - this.model.stickyCount; }\n\toverride get stickyCount(): number { return 0; }\n\n\toverride isSticky(editorOrIndex: number | EditorInput): boolean {\n\t\treturn false;\n\t}\n\n\toverride getEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[] {\n\t\tif (order === EditorsOrder.SEQUENTIAL) {\n\t\t\treturn this.model.getEditors(EditorsOrder.SEQUENTIAL).slice(this.model.stickyCount);\n\t\t}\n\t\treturn super.getEditors(order, options);\n\t}\n\n\tgetEditorByIndex(index: number): EditorInput | undefined {\n\t\treturn index >= 0 ? this.model.getEditorByIndex(index + this.model.stickyCount) : undefined;\n\t}\n\n\tindexOf(editor: EditorInput | IUntypedEditorInput | null, editors?: EditorInput[], options?: IMatchEditorOptions): number {\n\t\tconst editorIndex = this.model.indexOf(editor, editors, options);\n\t\tif (editorIndex < this.model.stickyCount || editorIndex >= this.model.count) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn editorIndex - this.model.stickyCount;\n\t}\n\n\tcontains(candidate: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean {\n\t\tconst editorIndex = this.model.indexOf(candidate, undefined, options);\n\t\treturn editorIndex >= this.model.stickyCount && editorIndex < this.model.count;\n\t}\n\n\tprotected filter(candidateOrIndex: EditorInput | number): boolean {\n\t\treturn !this.model.isSticky(candidateOrIndex);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IUntypedEditorInput, IMatchEditorOptions, EditorsOrder, GroupIdentifier } from '../editor.js';\nimport { EditorInput } from './editorInput.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { IGroupModelChangeEvent, IReadonlyEditorGroupModel } from './editorGroupModel.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\n\nabstract class FilteredEditorGroupModel extends Disposable implements IReadonlyEditorGroupModel {\n\n\tprivate readonly _onDidModelChange = this._register(new Emitter<IGroupModelChangeEvent>());\n\treadonly onDidModelChange = this._onDidModelChange.event;\n\n\tconstructor(\n\t\tprotected readonly model: IReadonlyEditorGroupModel\n\t) {\n\t\tsuper();\n\n\t\tthis._register(this.model.onDidModelChange(e => {\n\t\t\tconst candidateOrIndex = e.editorIndex ?? e.editor;\n\t\t\tif (candidateOrIndex !== undefined) {\n\t\t\t\tif (!this.filter(candidateOrIndex)) {\n\t\t\t\t\treturn; // exclude events for excluded items\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._onDidModelChange.fire(e);\n\t\t}));\n\t}\n\n\tget id(): GroupIdentifier { return this.model.id; }\n\tget isLocked(): boolean { return this.model.isLocked; }\n\tget stickyCount(): number { return this.model.stickyCount; }\n\n\tget activeEditor(): EditorInput | null { return this.model.activeEditor && this.filter(this.model.activeEditor) ? this.model.activeEditor : null; }\n\tget previewEditor(): EditorInput | null { return this.model.previewEditor && this.filter(this.model.previewEditor) ? this.model.previewEditor : null; }\n\tget selectedEditors(): EditorInput[] { return this.model.selectedEditors.filter(e => this.filter(e)); }\n\n\tisPinned(editorOrIndex: EditorInput | number): boolean { return this.model.isPinned(editorOrIndex); }\n\tisTransient(editorOrIndex: EditorInput | number): boolean { return this.model.isTransient(editorOrIndex); }\n\tisSticky(editorOrIndex: EditorInput | number): boolean { return this.model.isSticky(editorOrIndex); }\n\tisActive(editor: EditorInput | IUntypedEditorInput): boolean { return this.model.isActive(editor); }\n\tisSelected(editorOrIndex: EditorInput | number): boolean { return this.model.isSelected(editorOrIndex); }\n\n\tisFirst(editor: EditorInput): boolean {\n\t\treturn this.model.isFirst(editor, this.getEditors(EditorsOrder.SEQUENTIAL));\n\t}\n\n\tisLast(editor: EditorInput): boolean {\n\t\treturn this.model.isLast(editor, this.getEditors(EditorsOrder.SEQUENTIAL));\n\t}\n\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[] {\n\t\tconst editors = this.model.getEditors(order, options);\n\t\treturn editors.filter(e => this.filter(e));\n\t}\n\n\tfindEditor(candidate: EditorInput | null, options?: IMatchEditorOptions): [EditorInput, number] | undefined {\n\t\tconst result = this.model.findEditor(candidate, options);\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.filter(result[1]) ? result : undefined;\n\t}\n\n\tabstract get count(): number;\n\n\tabstract getEditorByIndex(index: number): EditorInput | undefined;\n\tabstract indexOf(editor: EditorInput | IUntypedEditorInput | null, editors?: EditorInput[], options?: IMatchEditorOptions): number;\n\tabstract contains(editor: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean;\n\n\tprotected abstract filter(editorOrIndex: EditorInput | number): boolean;\n}\n\nexport class StickyEditorGroupModel extends FilteredEditorGroupModel {\n\tget count(): number { return this.model.stickyCount; }\n\n\toverride getEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[] {\n\t\tif (options?.excludeSticky) {\n\t\t\treturn [];\n\t\t}\n\t\tif (order === EditorsOrder.SEQUENTIAL) {\n\t\t\treturn this.model.getEditors(EditorsOrder.SEQUENTIAL).slice(0, this.model.stickyCount);\n\t\t}\n\t\treturn super.getEditors(order, options);\n\t}\n\n\toverride isSticky(editorOrIndex: number | EditorInput): boolean {\n\t\treturn true;\n\t}\n\n\tgetEditorByIndex(index: number): EditorInput | undefined {\n\t\treturn index < this.count ? this.model.getEditorByIndex(index) : undefined;\n\t}\n\n\tindexOf(editor: EditorInput | IUntypedEditorInput | null, editors?: EditorInput[], options?: IMatchEditorOptions): number {\n\t\tconst editorIndex = this.model.indexOf(editor, editors, options);\n\t\tif (editorIndex < 0 || editorIndex >= this.model.stickyCount) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn editorIndex;\n\t}\n\n\tcontains(candidate: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean {\n\t\tconst editorIndex = this.model.indexOf(candidate, undefined, options);\n\t\treturn editorIndex >= 0 && editorIndex < this.model.stickyCount;\n\t}\n\n\tprotected filter(candidateOrIndex: EditorInput | number): boolean {\n\t\treturn this.model.isSticky(candidateOrIndex);\n\t}\n}\n\nexport class UnstickyEditorGroupModel extends FilteredEditorGroupModel {\n\tget count(): number { return this.model.count - this.model.stickyCount; }\n\toverride get stickyCount(): number { return 0; }\n\n\toverride isSticky(editorOrIndex: number | EditorInput): boolean {\n\t\treturn false;\n\t}\n\n\toverride getEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[] {\n\t\tif (order === EditorsOrder.SEQUENTIAL) {\n\t\t\treturn this.model.getEditors(EditorsOrder.SEQUENTIAL).slice(this.model.stickyCount);\n\t\t}\n\t\treturn super.getEditors(order, options);\n\t}\n\n\tgetEditorByIndex(index: number): EditorInput | undefined {\n\t\treturn index >= 0 ? this.model.getEditorByIndex(index + this.model.stickyCount) : undefined;\n\t}\n\n\tindexOf(editor: EditorInput | IUntypedEditorInput | null, editors?: EditorInput[], options?: IMatchEditorOptions): number {\n\t\tconst editorIndex = this.model.indexOf(editor, editors, options);\n\t\tif (editorIndex < this.model.stickyCount || editorIndex >= this.model.count) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn editorIndex - this.model.stickyCount;\n\t}\n\n\tcontains(candidate: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean {\n\t\tconst editorIndex = this.model.indexOf(candidate, undefined, options);\n\t\treturn editorIndex >= this.model.stickyCount && editorIndex < this.model.count;\n\t}\n\n\tprotected filter(candidateOrIndex: EditorInput | number): boolean {\n\t\treturn !this.model.isSticky(candidateOrIndex);\n\t}\n}\n"]}