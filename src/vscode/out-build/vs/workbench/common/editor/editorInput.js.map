{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/common/editor/editorInput.ts","vs/workbench/common/editor/editorInput.ts"],"names":[],"mappings":"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","file":"editorInput.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../base/common/event.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { EditorInputCapabilities, Verbosity, GroupIdentifier, ISaveOptions, IRevertOptions, IMoveResult, IEditorDescriptor, IEditorPane, IUntypedEditorInput, EditorResourceAccessor, AbstractEditorInput, isEditorInput, IEditorIdentifier } from '../editor.js';\nimport { isEqual } from '../../../base/common/resources.js';\nimport { ConfirmResult } from '../../../platform/dialogs/common/dialogs.js';\nimport { IMarkdownString } from '../../../base/common/htmlContent.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\n\nexport interface IEditorCloseHandler {\n\n\t/**\n\t * If `true`, will call into the `confirm` method to ask for confirmation\n\t * before closing the editor.\n\t */\n\tshowConfirm(): boolean;\n\n\t/**\n\t * Allows an editor to control what should happen when the editor\n\t * (or a list of editor of the same kind) is being closed.\n\t *\n\t * By default a file specific dialog will open if the editor is\n\t * dirty and not in the process of saving.\n\t *\n\t * If the editor is not dealing with files or another condition\n\t * should be used besides dirty state, this method should be\n\t * implemented to show a different dialog.\n\t *\n\t * @param editors All editors of the same kind that are being closed. Should be used\n\t * to show a combined dialog.\n\t */\n\tconfirm(editors: ReadonlyArray<IEditorIdentifier>): Promise<ConfirmResult>;\n}\n\nexport interface IUntypedEditorOptions {\n\n\t/**\n\t * Implementations should try to preserve as much\n\t * view state as possible from the typed input based\n\t * on the group the editor is opened.\n\t */\n\treadonly preserveViewState?: GroupIdentifier;\n\n\t/**\n\t * Implementations should preserve the original\n\t * resource of the typed input and not alter\n\t * it.\n\t */\n\treadonly preserveResource?: boolean;\n}\n\n/**\n * Editor inputs are lightweight objects that can be passed to the workbench API to open inside the editor part.\n * Each editor input is mapped to an editor that is capable of opening it through the Platform facade.\n */\nexport abstract class EditorInput extends AbstractEditorInput {\n\n\tprotected readonly _onDidChangeDirty = this._register(new Emitter<void>());\n\tprotected readonly _onDidChangeLabel = this._register(new Emitter<void>());\n\tprotected readonly _onDidChangeCapabilities = this._register(new Emitter<void>());\n\n\tprivate readonly _onWillDispose = this._register(new Emitter<void>());\n\n\t/**\n\t * Triggered when this input changes its dirty state.\n\t */\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\t/**\n\t * Triggered when this input changes its label\n\t */\n\treadonly onDidChangeLabel = this._onDidChangeLabel.event;\n\n\t/**\n\t * Triggered when this input changes its capabilities.\n\t */\n\treadonly onDidChangeCapabilities = this._onDidChangeCapabilities.event;\n\n\t/**\n\t * Triggered when this input is about to be disposed.\n\t */\n\treadonly onWillDispose = this._onWillDispose.event;\n\n\t/**\n\t * Optional: subclasses can override to implement\n\t * custom confirmation on close behavior.\n\t */\n\treadonly closeHandler?: IEditorCloseHandler;\n\n\t/**\n\t * Unique type identifier for this input. Every editor input of the\n\t * same class should share the same type identifier. The type identifier\n\t * is used for example for serialising/deserialising editor inputs\n\t * via the serialisers of the `EditorInputFactoryRegistry`.\n\t */\n\tabstract get typeId(): string;\n\n\t/**\n\t * Returns the optional associated resource of this input.\n\t *\n\t * This resource should be unique for all editors of the same\n\t * kind and input and is often used to identify the editor input among\n\t * others.\n\t *\n\t * **Note:** DO NOT use this property for anything but identity\n\t * checks. DO NOT use this property to present as label to the user.\n\t * Please refer to `EditorResourceAccessor` documentation in that case.\n\t */\n\tabstract get resource(): URI | undefined;\n\n\t/**\n\t * Identifies the type of editor this input represents\n\t * This ID is registered with the {@link EditorResolverService} to allow\n\t * for resolving an untyped input to a typed one\n\t */\n\tget editorId(): string | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * The capabilities of the input.\n\t */\n\tget capabilities(): EditorInputCapabilities {\n\t\treturn EditorInputCapabilities.Readonly;\n\t}\n\n\t/**\n\t * Figure out if the input has the provided capability.\n\t */\n\thasCapability(capability: EditorInputCapabilities): boolean {\n\t\tif (capability === EditorInputCapabilities.None) {\n\t\t\treturn this.capabilities === EditorInputCapabilities.None;\n\t\t}\n\n\t\treturn (this.capabilities & capability) !== 0;\n\t}\n\n\tisReadonly(): boolean | IMarkdownString {\n\t\treturn this.hasCapability(EditorInputCapabilities.Readonly);\n\t}\n\n\t/**\n\t * Returns the display name of this input.\n\t */\n\tgetName(): string {\n\t\treturn `Editor ${this.typeId}`;\n\t}\n\n\t/**\n\t * Returns the display description of this input.\n\t */\n\tgetDescription(verbosity?: Verbosity): string | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Returns the display title of this input.\n\t */\n\tgetTitle(verbosity?: Verbosity): string {\n\t\treturn this.getName();\n\t}\n\n\t/**\n\t * Returns the extra classes to apply to the label of this input.\n\t */\n\tgetLabelExtraClasses(): string[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * Returns the aria label to be read out by a screen reader.\n\t */\n\tgetAriaLabel(): string {\n\t\treturn this.getTitle(Verbosity.SHORT);\n\t}\n\n\t/**\n\t * Returns the icon which represents this editor input.\n\t * If undefined, the default icon will be used.\n\t */\n\tgetIcon(): ThemeIcon | URI | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Returns a descriptor suitable for telemetry events.\n\t *\n\t * Subclasses should extend if they can contribute.\n\t */\n\tgetTelemetryDescriptor(): { [key: string]: unknown } {\n\t\t/* __GDPR__FRAGMENT__\n\t\t\t\"EditorTelemetryDescriptor\" : {\n\t\t\t\t\"typeId\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t}\n\t\t*/\n\t\treturn { typeId: this.typeId };\n\t}\n\n\t/**\n\t * Returns if this input is dirty or not.\n\t */\n\tisDirty(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns if the input has unsaved changes.\n\t */\n\tisModified(): boolean {\n\t\treturn this.isDirty();\n\t}\n\n\t/**\n\t * Returns if this input is currently being saved or soon to be\n\t * saved. Based on this assumption the editor may for example\n\t * decide to not signal the dirty state to the user assuming that\n\t * the save is scheduled to happen anyway.\n\t */\n\tisSaving(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns a type of `IDisposable` that represents the resolved input.\n\t * Subclasses should override to provide a meaningful model or return\n\t * `null` if the editor does not require a model.\n\t *\n\t * The `options` parameter are passed down from the editor when the\n\t * input is resolved as part of it.\n\t */\n\tasync resolve(): Promise<IDisposable | null> {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Saves the editor. The provided groupId helps implementors\n\t * to e.g. preserve view state of the editor and re-open it\n\t * in the correct group after saving.\n\t *\n\t * @returns the resulting editor input (typically the same) of\n\t * this operation or `undefined` to indicate that the operation\n\t * failed or was canceled.\n\t */\n\tasync save(group: GroupIdentifier, options?: ISaveOptions): Promise<EditorInput | IUntypedEditorInput | undefined> {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Saves the editor to a different location. The provided `group`\n\t * helps implementors to e.g. preserve view state of the editor\n\t * and re-open it in the correct group after saving.\n\t *\n\t * @returns the resulting editor input (typically a different one)\n\t * of this operation or `undefined` to indicate that the operation\n\t * failed or was canceled.\n\t */\n\tasync saveAs(group: GroupIdentifier, options?: ISaveOptions): Promise<EditorInput | IUntypedEditorInput | undefined> {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Reverts this input from the provided group.\n\t */\n\tasync revert(group: GroupIdentifier, options?: IRevertOptions): Promise<void> { }\n\n\t/**\n\t * Called to determine how to handle a resource that is renamed that matches\n\t * the editors resource (or is a child of).\n\t *\n\t * Implementors are free to not implement this method to signal no intent\n\t * to participate. If an editor is returned though, it will replace the\n\t * current one with that editor and optional options.\n\t */\n\tasync rename(group: GroupIdentifier, target: URI): Promise<IMoveResult | undefined> {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Returns a copy of the current editor input. Used when we can't just reuse the input\n\t */\n\tcopy(): EditorInput {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Indicates if this editor can be moved to another group. By default\n\t * editors can freely be moved around groups. If an editor cannot be\n\t * moved, a message should be returned to show to the user.\n\t *\n\t * @returns `true` if the editor can be moved to the target group, or\n\t * a string with a message to show to the user if the editor cannot be\n\t * moved.\n\t */\n\tcanMove(sourceGroup: GroupIdentifier, targetGroup: GroupIdentifier): true | string {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns if the other object matches this input.\n\t */\n\tmatches(otherInput: EditorInput | IUntypedEditorInput): boolean {\n\n\t\t// Typed inputs: via  === check\n\t\tif (isEditorInput(otherInput)) {\n\t\t\treturn this === otherInput;\n\t\t}\n\n\t\t// Untyped inputs: go into properties\n\t\tconst otherInputEditorId = otherInput.options?.override;\n\n\t\t// If the overrides are both defined and don't match that means they're separate inputs\n\t\tif (this.editorId !== otherInputEditorId && otherInputEditorId !== undefined && this.editorId !== undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isEqual(this.resource, EditorResourceAccessor.getCanonicalUri(otherInput));\n\t}\n\n\t/**\n\t * If a editor was registered onto multiple editor panes, this method\n\t * will be asked to return the preferred one to use.\n\t *\n\t * @param editorPanes a list of editor pane descriptors that are candidates\n\t * for the editor to open in.\n\t */\n\tprefersEditorPane<T extends IEditorDescriptor<IEditorPane>>(editorPanes: T[]): T | undefined {\n\t\treturn editorPanes.at(0);\n\t}\n\n\t/**\n\t * Returns a representation of this typed editor input as untyped\n\t * resource editor input that e.g. can be used to serialize the\n\t * editor input into a form that it can be restored.\n\t *\n\t * May return `undefined` if an untyped representation is not supported.\n\t */\n\ttoUntyped(options?: IUntypedEditorOptions): IUntypedEditorInput | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Returns if this editor is disposed.\n\t */\n\tisDisposed(): boolean {\n\t\treturn this._store.isDisposed;\n\t}\n\n\toverride dispose(): void {\n\t\tif (!this.isDisposed()) {\n\t\t\tthis._onWillDispose.fire();\n\t\t}\n\n\t\tsuper.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../base/common/event.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { EditorInputCapabilities, Verbosity, GroupIdentifier, ISaveOptions, IRevertOptions, IMoveResult, IEditorDescriptor, IEditorPane, IUntypedEditorInput, EditorResourceAccessor, AbstractEditorInput, isEditorInput, IEditorIdentifier } from '../editor.js';\nimport { isEqual } from '../../../base/common/resources.js';\nimport { ConfirmResult } from '../../../platform/dialogs/common/dialogs.js';\nimport { IMarkdownString } from '../../../base/common/htmlContent.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\n\nexport interface IEditorCloseHandler {\n\n\t/**\n\t * If `true`, will call into the `confirm` method to ask for confirmation\n\t * before closing the editor.\n\t */\n\tshowConfirm(): boolean;\n\n\t/**\n\t * Allows an editor to control what should happen when the editor\n\t * (or a list of editor of the same kind) is being closed.\n\t *\n\t * By default a file specific dialog will open if the editor is\n\t * dirty and not in the process of saving.\n\t *\n\t * If the editor is not dealing with files or another condition\n\t * should be used besides dirty state, this method should be\n\t * implemented to show a different dialog.\n\t *\n\t * @param editors All editors of the same kind that are being closed. Should be used\n\t * to show a combined dialog.\n\t */\n\tconfirm(editors: ReadonlyArray<IEditorIdentifier>): Promise<ConfirmResult>;\n}\n\nexport interface IUntypedEditorOptions {\n\n\t/**\n\t * Implementations should try to preserve as much\n\t * view state as possible from the typed input based\n\t * on the group the editor is opened.\n\t */\n\treadonly preserveViewState?: GroupIdentifier;\n\n\t/**\n\t * Implementations should preserve the original\n\t * resource of the typed input and not alter\n\t * it.\n\t */\n\treadonly preserveResource?: boolean;\n}\n\n/**\n * Editor inputs are lightweight objects that can be passed to the workbench API to open inside the editor part.\n * Each editor input is mapped to an editor that is capable of opening it through the Platform facade.\n */\nexport abstract class EditorInput extends AbstractEditorInput {\n\n\tprotected readonly _onDidChangeDirty = this._register(new Emitter<void>());\n\tprotected readonly _onDidChangeLabel = this._register(new Emitter<void>());\n\tprotected readonly _onDidChangeCapabilities = this._register(new Emitter<void>());\n\n\tprivate readonly _onWillDispose = this._register(new Emitter<void>());\n\n\t/**\n\t * Triggered when this input changes its dirty state.\n\t */\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\t/**\n\t * Triggered when this input changes its label\n\t */\n\treadonly onDidChangeLabel = this._onDidChangeLabel.event;\n\n\t/**\n\t * Triggered when this input changes its capabilities.\n\t */\n\treadonly onDidChangeCapabilities = this._onDidChangeCapabilities.event;\n\n\t/**\n\t * Triggered when this input is about to be disposed.\n\t */\n\treadonly onWillDispose = this._onWillDispose.event;\n\n\t/**\n\t * Optional: subclasses can override to implement\n\t * custom confirmation on close behavior.\n\t */\n\treadonly closeHandler?: IEditorCloseHandler;\n\n\t/**\n\t * Unique type identifier for this input. Every editor input of the\n\t * same class should share the same type identifier. The type identifier\n\t * is used for example for serialising/deserialising editor inputs\n\t * via the serialisers of the `EditorInputFactoryRegistry`.\n\t */\n\tabstract get typeId(): string;\n\n\t/**\n\t * Returns the optional associated resource of this input.\n\t *\n\t * This resource should be unique for all editors of the same\n\t * kind and input and is often used to identify the editor input among\n\t * others.\n\t *\n\t * **Note:** DO NOT use this property for anything but identity\n\t * checks. DO NOT use this property to present as label to the user.\n\t * Please refer to `EditorResourceAccessor` documentation in that case.\n\t */\n\tabstract get resource(): URI | undefined;\n\n\t/**\n\t * Identifies the type of editor this input represents\n\t * This ID is registered with the {@link EditorResolverService} to allow\n\t * for resolving an untyped input to a typed one\n\t */\n\tget editorId(): string | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * The capabilities of the input.\n\t */\n\tget capabilities(): EditorInputCapabilities {\n\t\treturn EditorInputCapabilities.Readonly;\n\t}\n\n\t/**\n\t * Figure out if the input has the provided capability.\n\t */\n\thasCapability(capability: EditorInputCapabilities): boolean {\n\t\tif (capability === EditorInputCapabilities.None) {\n\t\t\treturn this.capabilities === EditorInputCapabilities.None;\n\t\t}\n\n\t\treturn (this.capabilities & capability) !== 0;\n\t}\n\n\tisReadonly(): boolean | IMarkdownString {\n\t\treturn this.hasCapability(EditorInputCapabilities.Readonly);\n\t}\n\n\t/**\n\t * Returns the display name of this input.\n\t */\n\tgetName(): string {\n\t\treturn `Editor ${this.typeId}`;\n\t}\n\n\t/**\n\t * Returns the display description of this input.\n\t */\n\tgetDescription(verbosity?: Verbosity): string | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Returns the display title of this input.\n\t */\n\tgetTitle(verbosity?: Verbosity): string {\n\t\treturn this.getName();\n\t}\n\n\t/**\n\t * Returns the extra classes to apply to the label of this input.\n\t */\n\tgetLabelExtraClasses(): string[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * Returns the aria label to be read out by a screen reader.\n\t */\n\tgetAriaLabel(): string {\n\t\treturn this.getTitle(Verbosity.SHORT);\n\t}\n\n\t/**\n\t * Returns the icon which represents this editor input.\n\t * If undefined, the default icon will be used.\n\t */\n\tgetIcon(): ThemeIcon | URI | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Returns a descriptor suitable for telemetry events.\n\t *\n\t * Subclasses should extend if they can contribute.\n\t */\n\tgetTelemetryDescriptor(): { [key: string]: unknown } {\n\t\t/* __GDPR__FRAGMENT__\n\t\t\t\"EditorTelemetryDescriptor\" : {\n\t\t\t\t\"typeId\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t}\n\t\t*/\n\t\treturn { typeId: this.typeId };\n\t}\n\n\t/**\n\t * Returns if this input is dirty or not.\n\t */\n\tisDirty(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns if the input has unsaved changes.\n\t */\n\tisModified(): boolean {\n\t\treturn this.isDirty();\n\t}\n\n\t/**\n\t * Returns if this input is currently being saved or soon to be\n\t * saved. Based on this assumption the editor may for example\n\t * decide to not signal the dirty state to the user assuming that\n\t * the save is scheduled to happen anyway.\n\t */\n\tisSaving(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns a type of `IDisposable` that represents the resolved input.\n\t * Subclasses should override to provide a meaningful model or return\n\t * `null` if the editor does not require a model.\n\t *\n\t * The `options` parameter are passed down from the editor when the\n\t * input is resolved as part of it.\n\t */\n\tasync resolve(): Promise<IDisposable | null> {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Saves the editor. The provided groupId helps implementors\n\t * to e.g. preserve view state of the editor and re-open it\n\t * in the correct group after saving.\n\t *\n\t * @returns the resulting editor input (typically the same) of\n\t * this operation or `undefined` to indicate that the operation\n\t * failed or was canceled.\n\t */\n\tasync save(group: GroupIdentifier, options?: ISaveOptions): Promise<EditorInput | IUntypedEditorInput | undefined> {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Saves the editor to a different location. The provided `group`\n\t * helps implementors to e.g. preserve view state of the editor\n\t * and re-open it in the correct group after saving.\n\t *\n\t * @returns the resulting editor input (typically a different one)\n\t * of this operation or `undefined` to indicate that the operation\n\t * failed or was canceled.\n\t */\n\tasync saveAs(group: GroupIdentifier, options?: ISaveOptions): Promise<EditorInput | IUntypedEditorInput | undefined> {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Reverts this input from the provided group.\n\t */\n\tasync revert(group: GroupIdentifier, options?: IRevertOptions): Promise<void> { }\n\n\t/**\n\t * Called to determine how to handle a resource that is renamed that matches\n\t * the editors resource (or is a child of).\n\t *\n\t * Implementors are free to not implement this method to signal no intent\n\t * to participate. If an editor is returned though, it will replace the\n\t * current one with that editor and optional options.\n\t */\n\tasync rename(group: GroupIdentifier, target: URI): Promise<IMoveResult | undefined> {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Returns a copy of the current editor input. Used when we can't just reuse the input\n\t */\n\tcopy(): EditorInput {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Indicates if this editor can be moved to another group. By default\n\t * editors can freely be moved around groups. If an editor cannot be\n\t * moved, a message should be returned to show to the user.\n\t *\n\t * @returns `true` if the editor can be moved to the target group, or\n\t * a string with a message to show to the user if the editor cannot be\n\t * moved.\n\t */\n\tcanMove(sourceGroup: GroupIdentifier, targetGroup: GroupIdentifier): true | string {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns if the other object matches this input.\n\t */\n\tmatches(otherInput: EditorInput | IUntypedEditorInput): boolean {\n\n\t\t// Typed inputs: via  === check\n\t\tif (isEditorInput(otherInput)) {\n\t\t\treturn this === otherInput;\n\t\t}\n\n\t\t// Untyped inputs: go into properties\n\t\tconst otherInputEditorId = otherInput.options?.override;\n\n\t\t// If the overrides are both defined and don't match that means they're separate inputs\n\t\tif (this.editorId !== otherInputEditorId && otherInputEditorId !== undefined && this.editorId !== undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isEqual(this.resource, EditorResourceAccessor.getCanonicalUri(otherInput));\n\t}\n\n\t/**\n\t * If a editor was registered onto multiple editor panes, this method\n\t * will be asked to return the preferred one to use.\n\t *\n\t * @param editorPanes a list of editor pane descriptors that are candidates\n\t * for the editor to open in.\n\t */\n\tprefersEditorPane<T extends IEditorDescriptor<IEditorPane>>(editorPanes: T[]): T | undefined {\n\t\treturn editorPanes.at(0);\n\t}\n\n\t/**\n\t * Returns a representation of this typed editor input as untyped\n\t * resource editor input that e.g. can be used to serialize the\n\t * editor input into a form that it can be restored.\n\t *\n\t * May return `undefined` if an untyped representation is not supported.\n\t */\n\ttoUntyped(options?: IUntypedEditorOptions): IUntypedEditorInput | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Returns if this editor is disposed.\n\t */\n\tisDisposed(): boolean {\n\t\treturn this._store.isDisposed;\n\t}\n\n\toverride dispose(): void {\n\t\tif (!this.isDisposed()) {\n\t\t\tthis._onWillDispose.fire();\n\t\t}\n\n\t\tsuper.dispose();\n\t}\n}\n"]}