{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/common/editor/editorGroupModel.ts","vs/workbench/common/editor/editorGroupModel.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;AAEhG,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,+BAA+B,CAAC;AAC/D,OAAO,EAAyD,gBAAgB,EAAuB,gBAAgB,EAAE,kBAAkB,EAA6C,MAAM,cAAc,CAAC;AAC7M,OAAO,EAAE,WAAW,EAAE,MAAM,kBAAkB,CAAC;AAC/C,OAAO,EAAE,qBAAqB,EAAE,MAAM,4BAA4B,CAAC;AACnE,OAAO,EAAE,qBAAqB,EAAE,MAAM,yDAAyD,CAAC;AAChG,OAAO,EAA6B,qBAAqB,EAAE,MAAM,yDAAyD,CAAC;AAC3H,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,mCAAmC,CAAC;AACzF,OAAO,EAAE,QAAQ,EAAE,MAAM,+CAA+C,CAAC;AACzE,OAAO,EAAE,QAAQ,EAAE,MAAM,gCAAgC,CAAC;AAE1D,MAAM,qBAAqB,GAAG;IAC7B,IAAI,EAAE,MAAM;IACZ,KAAK,EAAE,OAAO;IACd,KAAK,EAAE,OAAO;IACd,IAAI,EAAE,MAAM;CACZ,CAAC;AA+BF,MAAM,UAAU,4BAA4B,CAAC,KAAe;IAC3D,MAAM,SAAS,GAAG,KAAgD,CAAC;IAEnE,OAAO,CAAC,CAAC,CAAC,SAAS,IAAI,OAAO,SAAS,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;AAC3H,CAAC;AA4BD,MAAM,UAAU,wBAAwB,CAAC,CAAyB;IACjE,MAAM,SAAS,GAAG,CAA0B,CAAC;IAE7C,OAAO,SAAS,CAAC,MAAM,IAAI,SAAS,CAAC,WAAW,KAAK,SAAS,CAAC;AAChE,CAAC;AAOD,MAAM,UAAU,sBAAsB,CAAC,CAAyB;IAC/D,MAAM,SAAS,GAAG,CAA0B,CAAC;IAE7C,OAAO,SAAS,CAAC,IAAI,6CAAqC,IAAI,SAAS,CAAC,WAAW,KAAK,SAAS,CAAC;AACnG,CAAC;AAcD,MAAM,UAAU,sBAAsB,CAAC,CAAyB;IAC/D,MAAM,SAAS,GAAG,CAA0B,CAAC;IAE7C,OAAO,SAAS,CAAC,IAAI,6CAAqC,IAAI,SAAS,CAAC,WAAW,KAAK,SAAS,IAAI,SAAS,CAAC,cAAc,KAAK,SAAS,CAAC;AAC7I,CAAC;AAqBD,MAAM,UAAU,uBAAuB,CAAC,CAAyB;IAChE,MAAM,SAAS,GAAG,CAA2B,CAAC;IAE9C,OAAO,SAAS,CAAC,IAAI,8CAAsC,IAAI,SAAS,CAAC,WAAW,KAAK,SAAS,IAAI,SAAS,CAAC,OAAO,KAAK,SAAS,IAAI,SAAS,CAAC,MAAM,KAAK,SAAS,CAAC;AACzK,CAAC;AA2CM,IAAM,gBAAgB,GAAtB,MAAM,gBAAiB,SAAQ,UAAU;;aAEhC,QAAG,GAAG,CAAH,AAAI,CAAC;IAUvB,IAAI,EAAE,KAAsB,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IAW9C,IAAY,MAAM;QACjB,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC;IAClC,CAAC;IASD,YACC,sBAA+D,EACxC,oBAA4D,EAC5D,oBAA4D;QAEnF,KAAK,EAAE,CAAC;QAHgC,yBAAoB,GAApB,oBAAoB,CAAuB;QAC3C,yBAAoB,GAApB,oBAAoB,CAAuB;QAjCpF,gBAAgB;QAEC,sBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,CAAyB,EAAE,oBAAoB,EAAE,GAAG,CAAC,wDAAwD,EAAE,CAAC,CAAC,CAAC;QACxK,qBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;QAOjD,YAAO,GAAkB,EAAE,CAAC;QAC5B,QAAG,GAAkB,EAAE,CAAC;QAEf,oBAAe,GAAG,IAAI,GAAG,EAAmB,CAAC;QAEtD,WAAM,GAAG,KAAK,CAAC;QAEf,cAAS,GAAkB,EAAE,CAAC,CAAK,iDAAiD;QAMpF,YAAO,GAAuB,IAAI,CAAC,CAAI,0BAA0B;QACjE,WAAM,GAAG,CAAC,CAAC,CAAC,CAAS,wCAAwC;QACpD,cAAS,GAAG,IAAI,GAAG,EAAe,CAAC,CAAE,6BAA6B;QAYlF,IAAI,4BAA4B,CAAC,sBAAsB,CAAC,EAAE,CAAC;YAC1D,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,sBAAsB,CAAC,CAAC;QACrD,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,GAAG,GAAG,kBAAgB,CAAC,GAAG,EAAE,CAAC;QACnC,CAAC;QAED,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC9B,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC1B,CAAC;IAEO,iBAAiB;QACxB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,oBAAoB,CAAC,wBAAwB,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACzG,CAAC;IAEO,sBAAsB,CAAC,CAA6B;QAC3D,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,oBAAoB,CAAC,kCAAkC,CAAC,IAAI,CAAC,CAAC,CAAC,oBAAoB,CAAC,8CAA8C,CAAC,EAAE,CAAC;YACjJ,OAAO;QACR,CAAC;QAED,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,kCAAkC,CAAC,CAAC;QACpG,IAAI,CAAC,2BAA2B,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,8CAA8C,CAAC,CAAC;IACvH,CAAC;IAED,IAAI,KAAK;QACR,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;IAC5B,CAAC;IAED,IAAI,WAAW;QACd,OAAO,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;IACxB,CAAC;IAED,UAAU,CAAC,KAAmB,EAAE,OAAqC;QACpE,MAAM,OAAO,GAAG,KAAK,8CAAsC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAExG,IAAI,OAAO,EAAE,aAAa,EAAE,CAAC;YAE5B,uCAAuC;YACvC,IAAI,KAAK,8CAAsC,EAAE,CAAC;gBACjD,OAAO,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;YACzD,CAAC;YAED,8CAA8C;YAC9C,OAAO,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACvC,CAAC;QAED,OAAO,OAAO,CAAC;IAChB,CAAC;IAED,gBAAgB,CAAC,KAAa;QAC7B,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC5B,CAAC;IAED,IAAI,YAAY;QACf,OAAO,IAAI,CAAC,MAAM,CAAC;IACpB,CAAC;IAED,QAAQ,CAAC,SAA4C;QACpD,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IAC7C,CAAC;IAED,IAAI,aAAa;QAChB,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAED,UAAU,CAAC,SAAsB,EAAE,OAA4B;QAC9D,MAAM,UAAU,GAAG,OAAO,EAAE,MAAM,IAAI,CAAC,OAAO,OAAO,EAAE,KAAK,KAAK,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QAC3G,MAAM,UAAU,GAAG,OAAO,EAAE,MAAM,IAAI,OAAO,EAAE,MAAM,CAAC;QACtD,MAAM,aAAa,GAAG,CAAC,CAAC,OAAO,EAAE,SAAS,CAAC;QAC3C,MAAM,UAAU,GAAG,OAAO,EAAE,MAAM,IAAI,CAAC,IAAI,CAAC,YAAY,IAAI,CAAC,CAAC,UAAU,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,YAAY,CAAC,CAAC;QAEhH,MAAM,sBAAsB,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAEnE,aAAa;QACb,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC7B,MAAM,SAAS,GAAG,SAAS,CAAC;YAC5B,MAAM,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAEhD,gCAAgC;YAChC,IAAI,WAAmB,CAAC;YACxB,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,QAAQ,EAAE,CAAC;gBAClD,WAAW,GAAG,OAAO,CAAC,KAAK,CAAC;YAC7B,CAAC;YAED,0BAA0B;iBACrB,IAAI,IAAI,CAAC,qBAAqB,KAAK,qBAAqB,CAAC,KAAK,EAAE,CAAC;gBACrE,WAAW,GAAG,CAAC,CAAC;gBAEhB,uDAAuD;gBACvD,0DAA0D;gBAC1D,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC;oBAC/C,WAAW,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;gBAC/B,CAAC;YACF,CAAC;YAED,oBAAoB;iBACf,IAAI,IAAI,CAAC,qBAAqB,KAAK,qBAAqB,CAAC,IAAI,EAAE,CAAC;gBACpE,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;YACnC,CAAC;YAED,2CAA2C;iBACtC,CAAC;gBAEL,sCAAsC;gBACtC,IAAI,IAAI,CAAC,qBAAqB,KAAK,qBAAqB,CAAC,IAAI,EAAE,CAAC;oBAC/D,IAAI,aAAa,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;wBACjD,WAAW,GAAG,CAAC,CAAC,CAAC,4CAA4C;oBAC9D,CAAC;yBAAM,CAAC;wBACP,WAAW,GAAG,aAAa,CAAC,CAAC,+BAA+B;oBAC7D,CAAC;gBACF,CAAC;gBAED,uCAAuC;qBAClC,CAAC;oBACL,WAAW,GAAG,aAAa,GAAG,CAAC,CAAC;gBACjC,CAAC;gBAED,uDAAuD;gBACvD,0DAA0D;gBAC1D,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC;oBAC/C,WAAW,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;gBAC/B,CAAC;YACF,CAAC;YAED,sEAAsE;YACtE,qEAAqE;YACrE,IAAI,UAAU,EAAE,CAAC;gBAChB,IAAI,CAAC,MAAM,EAAE,CAAC;gBAEd,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC;oBACjC,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC;gBAC3B,CAAC;YACF,CAAC;YAED,yEAAyE;YACzE,IAAI,UAAU,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;gBACjC,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;YAC5C,CAAC;YAED,mBAAmB;YACnB,IAAI,aAAa,EAAE,CAAC;gBACnB,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;YACnD,CAAC;YAED,iBAAiB;YACjB,IAAI,CAAC,UAAU,EAAE,CAAC;gBAEjB,iEAAiE;gBACjE,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;oBAClB,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;oBAClD,IAAI,WAAW,GAAG,cAAc,EAAE,CAAC;wBAClC,WAAW,EAAE,CAAC,CAAC,yDAAyD;oBACzE,CAAC;oBAED,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,EAAE,WAAW,EAAE,CAAC,UAAU,CAAC,CAAC;gBACvE,CAAC;gBAED,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;YAC1B,CAAC;YAED,YAAY;YACZ,IAAI,CAAC,uBAAuB,CAAC,SAAS,CAAC,CAAC;YAExC,QAAQ;YACR,MAAM,KAAK,GAA0B;gBACpC,IAAI,0CAAkC;gBACtC,MAAM,EAAE,SAAS;gBACjB,WAAW,EAAE,WAAW;aACxB,CAAC;YACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAEnC,0CAA0C;YAC1C,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,EAAE,OAAO,EAAE,iBAAiB,IAAI,EAAE,CAAC,CAAC;YAEhG,OAAO;gBACN,MAAM,EAAE,SAAS;gBACjB,KAAK,EAAE,IAAI;aACX,CAAC;QACH,CAAC;QAED,kBAAkB;aACb,CAAC;YACL,MAAM,CAAC,cAAc,EAAE,mBAAmB,CAAC,GAAG,sBAAsB,CAAC;YAErE,oFAAoF;YACpF,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,mBAAmB,EAAE,aAAa,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,CAAC;YAE7H,SAAS;YACT,IAAI,UAAU,EAAE,CAAC;gBAChB,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,mBAAmB,CAAC,CAAC;YACjD,CAAC;YAED,0CAA0C;YAC1C,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,EAAE,OAAO,EAAE,iBAAiB,IAAI,EAAE,CAAC,CAAC;YAErG,gBAAgB;YAChB,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,QAAQ,EAAE,CAAC;gBAClD,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;YAChD,CAAC;YAED,4DAA4D;YAC5D,sDAAsD;YACtD,IAAI,UAAU,EAAE,CAAC;gBAChB,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC;YAC5D,CAAC;YAED,OAAO;gBACN,MAAM,EAAE,cAAc;gBACtB,KAAK,EAAE,KAAK;aACZ,CAAC;QACH,CAAC;IACF,CAAC;IAEO,uBAAuB,CAAC,MAAmB;QAClD,MAAM,SAAS,GAAG,IAAI,eAAe,EAAE,CAAC;QACxC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAEpC,oDAAoD;QACpD,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,GAAG,EAAE;YACnD,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YACjD,IAAI,WAAW,IAAI,CAAC,EAAE,CAAC;gBACtB,MAAM,KAAK,GAA4B;oBACtC,IAAI,mDAA0C;oBAC9C,MAAM;oBACN,WAAW;iBACX,CAAC;gBACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACpC,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;QAEJ,8BAA8B;QAC9B,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,gBAAgB,CAAC,GAAG,EAAE;YAC1C,MAAM,KAAK,GAA4B;gBACtC,IAAI,4CAAmC;gBACvC,MAAM;gBACN,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC;aACzC,CAAC;YACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC,CAAC;QAEJ,wBAAwB;QACxB,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,gBAAgB,CAAC,GAAG,EAAE;YAC1C,MAAM,KAAK,GAA4B;gBACtC,IAAI,2CAAmC;gBACvC,MAAM;gBACN,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC;aACzC,CAAC;YACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC,CAAC;QAEJ,6BAA6B;QAC7B,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,uBAAuB,CAAC,GAAG,EAAE;YACjD,MAAM,KAAK,GAA4B;gBACtC,IAAI,mDAA0C;gBAC9C,MAAM;gBACN,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC;aACzC,CAAC;YACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC,CAAC;QAEJ,yDAAyD;QACzD,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE;YAC3C,IAAI,KAAK,CAAC,IAAI,8CAAsC,IAAI,KAAK,CAAC,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC;gBACvF,OAAO,CAAC,SAAS,CAAC,CAAC;gBACnB,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACxC,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,aAAa,CAAC,SAAsB,EAAE,WAAwB,EAAE,YAAoB,EAAE,QAAQ,GAAG,IAAI;QAC5G,MAAM,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,kBAAkB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC,2DAA2D;QAEpJ,6FAA6F;QAC7F,2FAA2F;QAC3F,0EAA0E;QAC1E,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE,KAAK,EAAE,WAAW,CAAC,CAAC;QAE9C,IAAI,WAAW,EAAE,CAAC;YACjB,MAAM,KAAK,GAA2B;gBACrC,IAAI,2CAAmC;gBACvC,GAAG,WAAW;aACd,CAAC;YACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC;IACF,CAAC;IAED,WAAW,CAAC,SAAsB,EAAE,OAAO,GAAG,kBAAkB,CAAC,OAAO,EAAE,QAAQ,GAAG,IAAI;QACxF,MAAM,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QAErE,IAAI,WAAW,EAAE,CAAC;YACjB,MAAM,KAAK,GAA2B;gBACrC,IAAI,2CAAmC;gBACvC,GAAG,WAAW;aACd,CAAC;YACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAEnC,OAAO,WAAW,CAAC;QACpB,CAAC;QAED,OAAO,SAAS,CAAC;IAClB,CAAC;IAEO,aAAa,CAAC,SAAsB,EAAE,OAA2B,EAAE,QAAiB;QAC3F,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QACtC,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE,CAAC;YAClB,OAAO,SAAS,CAAC,CAAC,YAAY;QAC/B,CAAC;QAED,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QACnC,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAEpC,uBAAuB;QACvB,MAAM,cAAc,GAAG,IAAI,CAAC,MAAM,KAAK,MAAM,CAAC;QAC9C,IAAI,QAAQ,IAAI,cAAc,EAAE,CAAC;YAEhC,uBAAuB;YACvB,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACzB,IAAI,SAAsB,CAAC;gBAC3B,IAAI,IAAI,CAAC,2BAA2B,EAAE,CAAC;oBACtC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,kFAAkF;gBAC5G,CAAC;qBAAM,CAAC;oBACP,IAAI,KAAK,KAAK,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;wBACvC,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,qDAAqD;oBAC3F,CAAC;yBAAM,CAAC;wBACP,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,iCAAiC;oBACvE,CAAC;gBACF,CAAC;gBAED,0BAA0B;gBAC1B,MAAM,0BAA0B,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,KAAK,MAAM,IAAI,QAAQ,KAAK,SAAS,CAAC,CAAC;gBACpH,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,0BAA0B,CAAC,CAAC;YAC7F,CAAC;YAED,sCAAsC;iBACjC,CAAC;gBACL,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC;YAC1C,CAAC;QACF,CAAC;QAED,yBAAyB;aACpB,IAAI,CAAC,cAAc,EAAE,CAAC;YAE1B,wCAAwC;YACxC,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,CAAC;gBAC/B,MAAM,0BAA0B,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,KAAK,MAAM,IAAI,QAAQ,KAAK,IAAI,CAAC,YAAY,CAAC,CAAC;gBAC5H,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,0BAA0B,CAAC,CAAC;YACrG,CAAC;QACF,CAAC;QAED,wBAAwB;QACxB,IAAI,IAAI,CAAC,OAAO,KAAK,MAAM,EAAE,CAAC;YAC7B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACrB,CAAC;QAED,wBAAwB;QACxB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAE9B,qBAAqB;QACrB,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QAEzB,QAAQ;QACR,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC;IACxD,CAAC;IAED,UAAU,CAAC,SAAsB,EAAE,OAAe;QAEjD,2CAA2C;QAC3C,IAAI,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;YACpC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;QACnC,CAAC;aAAM,IAAI,OAAO,GAAG,CAAC,EAAE,CAAC;YACxB,OAAO,GAAG,CAAC,CAAC;QACb,CAAC;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QACtC,IAAI,KAAK,GAAG,CAAC,IAAI,OAAO,KAAK,KAAK,EAAE,CAAC;YACpC,OAAO;QACR,CAAC;QAED,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QACnC,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAE3B,4EAA4E;QAC5E,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,OAAO,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;YACnD,IAAI,CAAC,MAAM,EAAE,CAAC;QACf,CAAC;QAED,2DAA2D;aACtD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,OAAO,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAC1D,IAAI,CAAC,MAAM,EAAE,CAAC;QACf,CAAC;QAED,OAAO;QACP,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAC9B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;QAExC,aAAa;QACb,MAAM,KAAK,GAA0B;YACpC,IAAI,0CAAkC;YACtC,MAAM;YACN,cAAc,EAAE,KAAK;YACrB,WAAW,EAAE,OAAO;SACpB,CAAC;QACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEnC,uDAAuD;QACvD,IAAI,MAAM,KAAK,IAAI,CAAC,MAAM,EAAE,CAAC;YAC5B,MAAM,KAAK,GAA4B;gBACtC,IAAI,6CAAoC;gBACxC,MAAM;gBACN,WAAW,EAAE,OAAO;aACpB,CAAC;YACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAED,SAAS,CAAC,SAAkC;QAC3C,IAAI,MAA+B,CAAC;QAEpC,IAAI,CAAC,SAAS,EAAE,CAAC;YAChB,IAAI,CAAC,cAAc,EAAE,CAAC;QACvB,CAAC;aAAM,CAAC;YACP,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;QAC1C,CAAC;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAEO,cAAc;QACrB,gEAAgE;QAChE,4DAA4D;QAC5D,4DAA4D;QAC5D,SAAS;QACT,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,IAAI,2CAAmC,EAAE,CAAC,CAAC;IAC1E,CAAC;IAEO,eAAe,CAAC,SAAsB;QAC7C,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QACvC,IAAI,CAAC,GAAG,EAAE,CAAC;YACV,OAAO,CAAC,YAAY;QACrB,CAAC;QAED,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,GAAG,GAAG,CAAC;QAElC,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,WAAW,EAAE,EAAE,CAAC,CAAC;QAE7C,OAAO,MAAM,CAAC;IACf,CAAC;IAED,IAAI,eAAe;QAClB,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,6BAA6B;IAC/F,CAAC;IAED,UAAU,CAAC,sBAA4C;QACtD,IAAI,MAA+B,CAAC;QACpC,IAAI,OAAO,sBAAsB,KAAK,QAAQ,EAAE,CAAC;YAChD,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAAC;QAC/C,CAAC;aAAM,CAAC;YACP,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,sBAAsB,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACvD,CAAC;QAED,OAAO,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IAC9C,CAAC;IAEO,YAAY,CAAC,MAAmB;QACvC,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IACxC,CAAC;IAED,YAAY,CAAC,6BAA0C,EAAE,gCAA+C;QACvG,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,6BAA6B,CAAC,CAAC;QAC3D,IAAI,CAAC,GAAG,EAAE,CAAC;YACV,OAAO,CAAC,YAAY;QACrB,CAAC;QAED,MAAM,CAAC,oBAAoB,EAAE,yBAAyB,CAAC,GAAG,GAAG,CAAC;QAE9D,MAAM,uBAAuB,GAAG,IAAI,GAAG,EAAe,CAAC;QACvD,KAAK,MAAM,+BAA+B,IAAI,gCAAgC,EAAE,CAAC;YAChF,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,+BAA+B,CAAC,CAAC;YAC7D,IAAI,CAAC,GAAG,EAAE,CAAC;gBACV,OAAO,CAAC,YAAY;YACrB,CAAC;YAED,MAAM,CAAC,sBAAsB,CAAC,GAAG,GAAG,CAAC;YACrC,IAAI,sBAAsB,KAAK,oBAAoB,EAAE,CAAC;gBACrD,SAAS,CAAC,mBAAmB;YAC9B,CAAC;YAED,uBAAuB,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAC;QACrD,CAAC;QAED,IAAI,CAAC,cAAc,CAAC,oBAAoB,EAAE,yBAAyB,EAAE,KAAK,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC,CAAC;IAC3G,CAAC;IAEO,cAAc,CAAC,oBAAwC,EAAE,yBAA6C,EAAE,uBAAsC;QACrJ,MAAM,oBAAoB,GAAG,IAAI,CAAC,YAAY,CAAC;QAC/C,MAAM,iBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC;QAEzC,IAAI,YAA2B,CAAC;QAChC,IAAI,oBAAoB,EAAE,CAAC;YAC1B,YAAY,GAAG,CAAC,oBAAoB,EAAE,GAAG,uBAAuB,CAAC,CAAC;QACnE,CAAC;aAAM,CAAC;YACP,YAAY,GAAG,EAAE,CAAC;QACnB,CAAC;QAED,mBAAmB;QACnB,IAAI,CAAC,SAAS,GAAG,YAAY,CAAC;QAE9B,yCAAyC;QACzC,MAAM,mBAAmB,GAAG,oBAAoB,IAAI,OAAO,yBAAyB,KAAK,QAAQ,IAAI,oBAAoB,KAAK,oBAAoB,CAAC;QACnJ,IAAI,mBAAmB,EAAE,CAAC;YAEzB,6BAA6B;YAC7B,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,oBAAoB,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;YAC9D,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;YAC7B,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,oBAAoB,CAAC,CAAC;YAEvC,QAAQ;YACR,MAAM,KAAK,GAA4B;gBACtC,IAAI,4CAAoC;gBACxC,MAAM,EAAE,oBAAoB;gBAC5B,WAAW,EAAE,yBAAyB;aACtC,CAAC;YACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC;QAED,0CAA0C;QAC1C,IACC,mBAAmB;YACnB,iBAAiB,CAAC,MAAM,KAAK,YAAY,CAAC,MAAM;YAChD,iBAAiB,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,EAC/D,CAAC;YACF,MAAM,KAAK,GAA2B;gBACrC,IAAI,gDAAwC;aAC5C,CAAC;YACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC;IACF,CAAC;IAED,QAAQ,CAAC,KAAa;QACrB,yDAAyD;QACzD,4DAA4D;QAC5D,4DAA4D;QAC5D,SAAS;QACT,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,IAAI,0CAAkC,EAAE,CAAC,CAAC;IACzE,CAAC;IAED,QAAQ,CAAC,KAAa;QACrB,yDAAyD;QACzD,4DAA4D;QAC5D,4DAA4D;QAC5D,SAAS;QACT,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,IAAI,0CAAkC,EAAE,CAAC,CAAC;IACzE,CAAC;IAED,GAAG,CAAC,SAAsB;QACzB,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QACvC,IAAI,CAAC,GAAG,EAAE,CAAC;YACV,OAAO,CAAC,YAAY;QACrB,CAAC;QAED,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,GAAG,GAAG,CAAC;QAElC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;QAEhC,OAAO,MAAM,CAAC;IACf,CAAC;IAEO,KAAK,CAAC,MAAmB,EAAE,WAAmB;QACrD,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC;YAC3B,OAAO,CAAC,gCAAgC;QACzC,CAAC;QAED,kBAAkB;QAClB,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAEjC,mDAAmD;QACnD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QAEpB,QAAQ;QACR,MAAM,KAAK,GAA4B;YACtC,IAAI,0CAAiC;YACrC,MAAM;YACN,WAAW;SACX,CAAC;QACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAED,KAAK,CAAC,SAAsB;QAC3B,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QACvC,IAAI,CAAC,GAAG,EAAE,CAAC;YACV,OAAO,CAAC,YAAY;QACrB,CAAC;QAED,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,GAAG,GAAG,CAAC;QAElC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;QAElC,OAAO,MAAM,CAAC;IACf,CAAC;IAEO,OAAO,CAAC,MAAmB,EAAE,WAAmB;QACvD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC;YAC5B,OAAO,CAAC,iCAAiC;QAC1C,CAAC;QAED,UAAU;QACV,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC;QAChC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QAEtB,QAAQ;QACR,MAAM,KAAK,GAA4B;YACtC,IAAI,0CAAiC;YACrC,MAAM;YACN,WAAW;SACX,CAAC;QACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEnC,kCAAkC;QAClC,IAAI,UAAU,EAAE,CAAC;YAChB,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,kBAAkB,CAAC,KAAK,CAAC,CAAC;QACxD,CAAC;IACF,CAAC;IAED,QAAQ,CAAC,sBAA4C;QACpD,IAAI,MAAmB,CAAC;QACxB,IAAI,OAAO,sBAAsB,KAAK,QAAQ,EAAE,CAAC;YAChD,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAAC;QAC/C,CAAC;aAAM,CAAC;YACP,MAAM,GAAG,sBAAsB,CAAC;QACjC,CAAC;QAED,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IAC5C,CAAC;IAED,KAAK,CAAC,SAAsB;QAC3B,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QACvC,IAAI,CAAC,GAAG,EAAE,CAAC;YACV,OAAO,CAAC,YAAY;QACrB,CAAC;QAED,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,GAAG,GAAG,CAAC;QAElC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;QAElC,OAAO,MAAM,CAAC;IACf,CAAC;IAEO,OAAO,CAAC,MAAmB,EAAE,WAAmB;QACvD,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC;YAChC,OAAO,CAAC,qCAAqC;QAC9C,CAAC;QAED,aAAa;QACb,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAEjB,2CAA2C;QAC3C,MAAM,cAAc,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QACvC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;QAExC,sBAAsB;QACtB,IAAI,CAAC,MAAM,EAAE,CAAC;QAEd,QAAQ;QACR,MAAM,KAAK,GAA4B;YACtC,IAAI,6CAAoC;YACxC,MAAM;YACN,WAAW,EAAE,cAAc;SAC3B,CAAC;QACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAED,OAAO,CAAC,SAAsB;QAC7B,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QACvC,IAAI,CAAC,GAAG,EAAE,CAAC;YACV,OAAO,CAAC,YAAY;QACrB,CAAC;QAED,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,GAAG,GAAG,CAAC;QAElC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;QAEpC,OAAO,MAAM,CAAC;IACf,CAAC;IAEO,SAAS,CAAC,MAAmB,EAAE,WAAmB;QACzD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC;YACjC,OAAO,CAAC,mCAAmC;QAC5C,CAAC;QAED,gDAAgD;QAChD,MAAM,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC;QACnC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;QAExC,sBAAsB;QACtB,IAAI,CAAC,MAAM,EAAE,CAAC;QAEd,QAAQ;QACR,MAAM,KAAK,GAA4B;YACtC,IAAI,6CAAoC;YACxC,MAAM;YACN,WAAW,EAAE,cAAc;SAC3B,CAAC;QACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAED,QAAQ,CAAC,gBAAsC;QAC9C,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACrB,OAAO,KAAK,CAAC,CAAC,mBAAmB;QAClC,CAAC;QAED,IAAI,KAAa,CAAC;QAClB,IAAI,OAAO,gBAAgB,KAAK,QAAQ,EAAE,CAAC;YAC1C,KAAK,GAAG,gBAAgB,CAAC;QAC1B,CAAC;aAAM,CAAC;YACP,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;QACxC,CAAC;QAED,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC;YACf,OAAO,KAAK,CAAC;QACd,CAAC;QAED,OAAO,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC;IAC7B,CAAC;IAED,YAAY,CAAC,SAAsB,EAAE,SAAkB;QACtD,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;YAC7C,OAAO,CAAC,sBAAsB;QAC/B,CAAC;QAED,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QACvC,IAAI,CAAC,GAAG,EAAE,CAAC;YACV,OAAO,CAAC,YAAY;QACrB,CAAC;QAED,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,GAAG,GAAG,CAAC;QAElC,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;QAEpD,OAAO,MAAM,CAAC;IACf,CAAC;IAEO,cAAc,CAAC,MAAmB,EAAE,WAAmB,EAAE,SAAkB;QAClF,IAAI,SAAS,EAAE,CAAC;YACf,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;gBAChC,OAAO;YACR,CAAC;YAED,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC5B,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;gBACjC,OAAO;YACR,CAAC;YAED,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAC/B,CAAC;QAED,QAAQ;QACR,MAAM,KAAK,GAA4B;YACtC,IAAI,gDAAuC;YAC3C,MAAM;YACN,WAAW;SACX,CAAC;QACF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAED,WAAW,CAAC,sBAA4C;QACvD,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;YAC/B,OAAO,KAAK,CAAC,CAAC,sBAAsB;QACrC,CAAC;QAED,IAAI,MAA+B,CAAC;QACpC,IAAI,OAAO,sBAAsB,KAAK,QAAQ,EAAE,CAAC;YAChD,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAAC;QAC/C,CAAC;aAAM,CAAC;YACP,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,sBAAsB,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACvD,CAAC;QAED,OAAO,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IAC/C,CAAC;IAEO,MAAM,CAAC,KAAa,EAAE,GAAY,EAAE,MAAoB;QAC/D,MAAM,uBAAuB,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAEpD,0BAA0B;QAC1B,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC;YACjC,IAAI,CAAC,MAAM,EAAE,CAAC;QACf,CAAC;QAED,2BAA2B;QAC3B,IAAI,MAAM,EAAE,CAAC;YACZ,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;QACjD,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACzC,CAAC;QAED,iBAAiB;QACjB,CAAC;YACA,MAAM;YACN,IAAI,CAAC,GAAG,IAAI,MAAM,EAAE,CAAC;gBACpB,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBAC3B,2CAA2C;oBAC3C,6CAA6C;oBAC7C,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACvB,CAAC;qBAAM,CAAC;oBACP,0CAA0C;oBAC1C,2CAA2C;oBAC3C,gDAAgD;oBAChD,yCAAyC;oBACzC,0CAA0C;oBAC1C,4CAA4C;oBAC5C,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;gBAC/B,CAAC;YACF,CAAC;YAED,mBAAmB;iBACd,CAAC;gBACL,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;gBAEnE,SAAS;gBACT,IAAI,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;oBACpB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,kBAAkB;gBACnD,CAAC;gBAED,UAAU;qBACL,IAAI,GAAG,IAAI,MAAM,EAAE,CAAC;oBACxB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,0BAA0B;gBACnE,CAAC;YACF,CAAC;QACF,CAAC;IACF,CAAC;IAED,OAAO,CAAC,SAAmD,EAAE,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,OAA6B;QACjH,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;QACf,IAAI,CAAC,SAAS,EAAE,CAAC;YAChB,OAAO,KAAK,CAAC;QACd,CAAC;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACzC,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YAE1B,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,SAAS,EAAE,OAAO,CAAC,EAAE,CAAC;gBAC9C,kEAAkE;gBAClE,qEAAqE;gBACrE,qEAAqE;gBACrE,IAAI,OAAO,EAAE,iBAAiB,IAAI,MAAM,YAAY,qBAAqB,IAAI,CAAC,CAAC,SAAS,YAAY,qBAAqB,CAAC,EAAE,CAAC;oBAC5H,KAAK,GAAG,CAAC,CAAC;gBACX,CAAC;qBAAM,CAAC;oBACP,KAAK,GAAG,CAAC,CAAC;oBACV,MAAM;gBACP,CAAC;YACF,CAAC;QACF,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAED,UAAU,CAAC,SAA6B,EAAE,OAA6B;QACtE,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAC7D,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE,CAAC;YAClB,OAAO,SAAS,CAAC;QAClB,CAAC;QAED,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;IACrC,CAAC;IAED,OAAO,CAAC,SAA6B,EAAE,OAAO,GAAG,IAAI,CAAC,OAAO;QAC5D,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;IAC5C,CAAC;IAED,MAAM,CAAC,SAA6B,EAAE,OAAO,GAAG,IAAI,CAAC,OAAO;QAC3D,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;IAC7D,CAAC;IAED,QAAQ,CAAC,SAA4C,EAAE,OAA6B;QACnF,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;IAC9D,CAAC;IAEO,OAAO,CAAC,MAAsC,EAAE,SAAmD,EAAE,OAA6B;QACzI,IAAI,CAAC,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC;YAC3B,OAAO,KAAK,CAAC;QACd,CAAC;QAED,IAAI,OAAO,EAAE,iBAAiB,IAAI,MAAM,YAAY,qBAAqB,IAAI,CAAC,CAAC,SAAS,YAAY,qBAAqB,CAAC,EAAE,CAAC;YAC5H,QAAQ,OAAO,CAAC,iBAAiB,EAAE,CAAC;gBACnC,KAAK,gBAAgB,CAAC,GAAG;oBACxB,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,EAAE,SAAS,EAAE,OAAO,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,SAAS,EAAE,OAAO,CAAC,EAAE,CAAC;wBAC5G,OAAO,IAAI,CAAC;oBACb,CAAC;oBACD,MAAM;gBACP,KAAK,gBAAgB,CAAC,IAAI;oBACzB,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,EAAE,SAAS,EAAE,OAAO,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,SAAS,EAAE,OAAO,CAAC,EAAE,CAAC;wBAC5G,OAAO,IAAI,CAAC;oBACb,CAAC;oBACD,MAAM;YACR,CAAC;QACF,CAAC;QAED,MAAM,YAAY,GAAG,MAAM,KAAK,SAAS,CAAC;QAE1C,IAAI,OAAO,EAAE,YAAY,EAAE,CAAC;YAC3B,OAAO,YAAY,CAAC;QACrB,CAAC;QAED,OAAO,YAAY,IAAI,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAClD,CAAC;IAED,IAAI,QAAQ;QACX,OAAO,IAAI,CAAC,MAAM,CAAC;IACpB,CAAC;IAED,IAAI,CAAC,MAAe;QACnB,IAAI,IAAI,CAAC,QAAQ,KAAK,MAAM,EAAE,CAAC;YAC9B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YAErB,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,IAAI,2CAAmC,EAAE,CAAC,CAAC;QAC1E,CAAC;IACF,CAAC;IAED,KAAK;QACJ,MAAM,KAAK,GAAG,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,kBAAgB,EAAE,SAAS,CAAC,CAAC;QAEpF,6BAA6B;QAC7B,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACtC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAC9B,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC7B,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAC1C,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAE3B,+CAA+C;QAC/C,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,OAAO,EAAE,CAAC;YACpC,KAAK,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;QACvC,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAED,SAAS;QACR,MAAM,QAAQ,GAAG,QAAQ,CAAC,EAAE,CAAyB,gBAAgB,CAAC,aAAa,CAAC,CAAC;QAErF,yDAAyD;QACzD,uDAAuD;QACvD,+CAA+C;QAC/C,MAAM,mBAAmB,GAAkB,EAAE,CAAC;QAC9C,MAAM,iBAAiB,GAA6B,EAAE,CAAC;QACvD,IAAI,wBAA4C,CAAC;QACjD,IAAI,kBAAkB,GAAG,IAAI,CAAC,MAAM,CAAC;QAErC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC9C,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC/B,IAAI,kBAAkB,GAAG,KAAK,CAAC;YAE/B,MAAM,gBAAgB,GAAG,QAAQ,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;YAC9D,IAAI,gBAAgB,EAAE,CAAC;gBACtB,MAAM,KAAK,GAAG,gBAAgB,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;gBAErG,2BAA2B;gBAC3B,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;oBAC/B,kBAAkB,GAAG,IAAI,CAAC;oBAE1B,iBAAiB,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,MAAM,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;oBACrD,mBAAmB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBAEjC,IAAI,IAAI,CAAC,OAAO,KAAK,MAAM,EAAE,CAAC;wBAC7B,wBAAwB,GAAG,mBAAmB,CAAC,MAAM,GAAG,CAAC,CAAC;oBAC3D,CAAC;gBACF,CAAC;gBAED,8BAA8B;qBACzB,CAAC;oBACL,kBAAkB,GAAG,KAAK,CAAC;gBAC5B,CAAC;YACF,CAAC;YAED,kFAAkF;YAClF,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC7C,kBAAkB,EAAE,CAAC;YACtB,CAAC;QACF,CAAC;QAED,MAAM,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,mBAAmB,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;QAE9G,OAAO;YACN,EAAE,EAAE,IAAI,CAAC,EAAE;YACX,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS;YACtC,OAAO,EAAE,iBAAiB;YAC1B,GAAG,EAAE,eAAe;YACpB,OAAO,EAAE,wBAAwB;YACjC,MAAM,EAAE,kBAAkB,IAAI,CAAC,CAAC,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC,SAAS;SAChE,CAAC;IACH,CAAC;IAEO,WAAW,CAAC,IAAiC;QACpD,MAAM,QAAQ,GAAG,QAAQ,CAAC,EAAE,CAAyB,gBAAgB,CAAC,aAAa,CAAC,CAAC;QAErF,IAAI,OAAO,IAAI,CAAC,EAAE,KAAK,QAAQ,EAAE,CAAC;YACjC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,EAAE,CAAC;YAEnB,kBAAgB,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,kBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC,8CAA8C;QACnH,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,GAAG,GAAG,kBAAgB,CAAC,GAAG,EAAE,CAAC,CAAC,0BAA0B;QAC9D,CAAC;QAED,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YACjB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACpB,CAAC;QAED,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;YACrD,IAAI,MAA+B,CAAC;YAEpC,MAAM,gBAAgB,GAAG,QAAQ,CAAC,mBAAmB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;YAC5D,IAAI,gBAAgB,EAAE,CAAC;gBACtB,MAAM,kBAAkB,GAAG,gBAAgB,CAAC,WAAW,CAAC,IAAI,CAAC,oBAAoB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;gBAC5F,IAAI,kBAAkB,YAAY,WAAW,EAAE,CAAC;oBAC/C,MAAM,GAAG,kBAAkB,CAAC;oBAC5B,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;gBACtC,CAAC;YACF,CAAC;YAED,IAAI,CAAC,MAAM,IAAI,OAAO,IAAI,CAAC,MAAM,KAAK,QAAQ,IAAI,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;gBACxE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,oFAAoF;YACpG,CAAC;YAED,OAAO,MAAM,CAAC;QACf,CAAC,CAAC,CAAC,CAAC;QAEJ,IAAI,CAAC,GAAG,GAAG,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAExD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAE1D,IAAI,OAAO,IAAI,CAAC,OAAO,KAAK,QAAQ,EAAE,CAAC;YACtC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC3C,CAAC;QAED,IAAI,OAAO,IAAI,CAAC,MAAM,KAAK,QAAQ,EAAE,CAAC;YACrC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC3B,CAAC;QAED,OAAO,IAAI,CAAC,GAAG,CAAC;IACjB,CAAC;IAEQ,OAAO;QACf,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;QAC1C,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;QAE7B,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;QAEvB,KAAK,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;;AAjkCW,gBAAgB;IAoC1B,WAAA,qBAAqB,CAAA;IACrB,WAAA,qBAAqB,CAAA;GArCX,gBAAgB,CAkkC5B","file":"editorGroupModel.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from '../../../base/common/event.js';\nimport { IEditorFactoryRegistry, GroupIdentifier, EditorsOrder, EditorExtensions, IUntypedEditorInput, SideBySideEditor, EditorCloseContext, IMatchEditorOptions, GroupModelChangeKind } from '../editor.js';\nimport { EditorInput } from './editorInput.js';\nimport { SideBySideEditorInput } from './sideBySideEditorInput.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationChangeEvent, IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { dispose, Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { coalesce } from '../../../base/common/arrays.js';\n\nconst EditorOpenPositioning = {\n\tLEFT: 'left',\n\tRIGHT: 'right',\n\tFIRST: 'first',\n\tLAST: 'last'\n};\n\nexport interface IEditorOpenOptions {\n\treadonly pinned?: boolean;\n\treadonly sticky?: boolean;\n\treadonly transient?: boolean;\n\tactive?: boolean;\n\treadonly inactiveSelection?: EditorInput[];\n\treadonly index?: number;\n\treadonly supportSideBySide?: SideBySideEditor.ANY | SideBySideEditor.BOTH;\n}\n\nexport interface IEditorOpenResult {\n\treadonly editor: EditorInput;\n\treadonly isNew: boolean;\n}\n\nexport interface ISerializedEditorInput {\n\treadonly id: string;\n\treadonly value: string;\n}\n\nexport interface ISerializedEditorGroupModel {\n\treadonly id: number;\n\treadonly locked?: boolean;\n\treadonly editors: ISerializedEditorInput[];\n\treadonly mru: number[];\n\treadonly preview?: number;\n\tsticky?: number;\n}\n\nexport function isSerializedEditorGroupModel(group?: unknown): group is ISerializedEditorGroupModel {\n\tconst candidate = group as ISerializedEditorGroupModel | undefined;\n\n\treturn !!(candidate && typeof candidate === 'object' && Array.isArray(candidate.editors) && Array.isArray(candidate.mru));\n}\n\nexport interface IGroupModelChangeEvent {\n\n\t/**\n\t * The kind of change that occurred in the group model.\n\t */\n\treadonly kind: GroupModelChangeKind;\n\n\t/**\n\t * Only applies when editors change providing\n\t * access to the editor the event is about.\n\t */\n\treadonly editor?: EditorInput;\n\n\t/**\n\t * Only applies when editors change providing\n\t * access to the index of the editor the event\n\t * is about.\n\t */\n\treadonly editorIndex?: number;\n}\n\nexport interface IGroupEditorChangeEvent extends IGroupModelChangeEvent {\n\treadonly editor: EditorInput;\n\treadonly editorIndex: number;\n}\n\nexport function isGroupEditorChangeEvent(e: IGroupModelChangeEvent): e is IGroupEditorChangeEvent {\n\tconst candidate = e as IGroupEditorOpenEvent;\n\n\treturn candidate.editor && candidate.editorIndex !== undefined;\n}\n\nexport interface IGroupEditorOpenEvent extends IGroupEditorChangeEvent {\n\n\treadonly kind: GroupModelChangeKind.EDITOR_OPEN;\n}\n\nexport function isGroupEditorOpenEvent(e: IGroupModelChangeEvent): e is IGroupEditorOpenEvent {\n\tconst candidate = e as IGroupEditorOpenEvent;\n\n\treturn candidate.kind === GroupModelChangeKind.EDITOR_OPEN && candidate.editorIndex !== undefined;\n}\n\nexport interface IGroupEditorMoveEvent extends IGroupEditorChangeEvent {\n\n\treadonly kind: GroupModelChangeKind.EDITOR_MOVE;\n\n\t/**\n\t * Signifies the index the editor is moving from.\n\t * `editorIndex` will contain the index the editor\n\t * is moving to.\n\t */\n\treadonly oldEditorIndex: number;\n}\n\nexport function isGroupEditorMoveEvent(e: IGroupModelChangeEvent): e is IGroupEditorMoveEvent {\n\tconst candidate = e as IGroupEditorMoveEvent;\n\n\treturn candidate.kind === GroupModelChangeKind.EDITOR_MOVE && candidate.editorIndex !== undefined && candidate.oldEditorIndex !== undefined;\n}\n\nexport interface IGroupEditorCloseEvent extends IGroupEditorChangeEvent {\n\n\treadonly kind: GroupModelChangeKind.EDITOR_CLOSE;\n\n\t/**\n\t * Signifies the context in which the editor\n\t * is being closed. This allows for understanding\n\t * if a replace or reopen is occurring\n\t */\n\treadonly context: EditorCloseContext;\n\n\t/**\n\t * Signifies whether or not the closed editor was\n\t * sticky. This is necessary becasue state is lost\n\t * after closing.\n\t */\n\treadonly sticky: boolean;\n}\n\nexport function isGroupEditorCloseEvent(e: IGroupModelChangeEvent): e is IGroupEditorCloseEvent {\n\tconst candidate = e as IGroupEditorCloseEvent;\n\n\treturn candidate.kind === GroupModelChangeKind.EDITOR_CLOSE && candidate.editorIndex !== undefined && candidate.context !== undefined && candidate.sticky !== undefined;\n}\n\ninterface IEditorCloseResult {\n\treadonly editor: EditorInput;\n\treadonly context: EditorCloseContext;\n\treadonly editorIndex: number;\n\treadonly sticky: boolean;\n}\n\nexport interface IReadonlyEditorGroupModel {\n\n\treadonly onDidModelChange: Event<IGroupModelChangeEvent>;\n\n\treadonly id: GroupIdentifier;\n\treadonly count: number;\n\treadonly stickyCount: number;\n\treadonly isLocked: boolean;\n\treadonly activeEditor: EditorInput | null;\n\treadonly previewEditor: EditorInput | null;\n\treadonly selectedEditors: EditorInput[];\n\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[];\n\tgetEditorByIndex(index: number): EditorInput | undefined;\n\tindexOf(editor: EditorInput | IUntypedEditorInput | null, editors?: EditorInput[], options?: IMatchEditorOptions): number;\n\tisActive(editor: EditorInput | IUntypedEditorInput): boolean;\n\tisPinned(editorOrIndex: EditorInput | number): boolean;\n\tisSticky(editorOrIndex: EditorInput | number): boolean;\n\tisSelected(editorOrIndex: EditorInput | number): boolean;\n\tisTransient(editorOrIndex: EditorInput | number): boolean;\n\tisFirst(editor: EditorInput, editors?: EditorInput[]): boolean;\n\tisLast(editor: EditorInput, editors?: EditorInput[]): boolean;\n\tfindEditor(editor: EditorInput | null, options?: IMatchEditorOptions): [EditorInput, number /* index */] | undefined;\n\tcontains(editor: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean;\n}\n\ninterface IEditorGroupModel extends IReadonlyEditorGroupModel {\n\topenEditor(editor: EditorInput, options?: IEditorOpenOptions): IEditorOpenResult;\n\tcloseEditor(editor: EditorInput, context?: EditorCloseContext, openNext?: boolean): IEditorCloseResult | undefined;\n\tmoveEditor(editor: EditorInput, toIndex: number): EditorInput | undefined;\n\tsetActive(editor: EditorInput | undefined): EditorInput | undefined;\n\tsetSelection(activeSelectedEditor: EditorInput, inactiveSelectedEditors: EditorInput[]): void;\n}\n\nexport class EditorGroupModel extends Disposable implements IEditorGroupModel {\n\n\tprivate static IDS = 0;\n\n\t//#region events\n\n\tprivate readonly _onDidModelChange = this._register(new Emitter<IGroupModelChangeEvent>({ leakWarningThreshold: 500 /* increased for users with hundreds of inputs opened */ }));\n\treadonly onDidModelChange = this._onDidModelChange.event;\n\n\t//#endregion\n\n\tprivate _id: GroupIdentifier;\n\tget id(): GroupIdentifier { return this._id; }\n\n\tprivate editors: EditorInput[] = [];\n\tprivate mru: EditorInput[] = [];\n\n\tprivate readonly editorListeners = new Set<DisposableStore>();\n\n\tprivate locked = false;\n\n\tprivate selection: EditorInput[] = [];\t\t\t\t\t// editors in selected state, first one is active\n\n\tprivate get active(): EditorInput | null {\n\t\treturn this.selection[0] ?? null;\n\t}\n\n\tprivate preview: EditorInput | null = null; \t\t\t// editor in preview state\n\tprivate sticky = -1;\t\t\t\t\t\t\t\t\t// index of first editor in sticky state\n\tprivate readonly transient = new Set<EditorInput>(); \t// editors in transient state\n\n\tprivate editorOpenPositioning: ('left' | 'right' | 'first' | 'last') | undefined;\n\tprivate focusRecentEditorAfterClose: boolean | undefined;\n\n\tconstructor(\n\t\tlabelOrSerializedGroup: ISerializedEditorGroupModel | undefined,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tif (isSerializedEditorGroupModel(labelOrSerializedGroup)) {\n\t\t\tthis._id = this.deserialize(labelOrSerializedGroup);\n\t\t} else {\n\t\t\tthis._id = EditorGroupModel.IDS++;\n\t\t}\n\n\t\tthis.onConfigurationUpdated();\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(e)));\n\t}\n\n\tprivate onConfigurationUpdated(e?: IConfigurationChangeEvent): void {\n\t\tif (e && !e.affectsConfiguration('workbench.editor.openPositioning') && !e.affectsConfiguration('workbench.editor.focusRecentEditorAfterClose')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.editorOpenPositioning = this.configurationService.getValue('workbench.editor.openPositioning');\n\t\tthis.focusRecentEditorAfterClose = this.configurationService.getValue('workbench.editor.focusRecentEditorAfterClose');\n\t}\n\n\tget count(): number {\n\t\treturn this.editors.length;\n\t}\n\n\tget stickyCount(): number {\n\t\treturn this.sticky + 1;\n\t}\n\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[] {\n\t\tconst editors = order === EditorsOrder.MOST_RECENTLY_ACTIVE ? this.mru.slice(0) : this.editors.slice(0);\n\n\t\tif (options?.excludeSticky) {\n\n\t\t\t// MRU: need to check for index on each\n\t\t\tif (order === EditorsOrder.MOST_RECENTLY_ACTIVE) {\n\t\t\t\treturn editors.filter(editor => !this.isSticky(editor));\n\t\t\t}\n\n\t\t\t// Sequential: simply start after sticky index\n\t\t\treturn editors.slice(this.sticky + 1);\n\t\t}\n\n\t\treturn editors;\n\t}\n\n\tgetEditorByIndex(index: number): EditorInput | undefined {\n\t\treturn this.editors[index];\n\t}\n\n\tget activeEditor(): EditorInput | null {\n\t\treturn this.active;\n\t}\n\n\tisActive(candidate: EditorInput | IUntypedEditorInput): boolean {\n\t\treturn this.matches(this.active, candidate);\n\t}\n\n\tget previewEditor(): EditorInput | null {\n\t\treturn this.preview;\n\t}\n\n\topenEditor(candidate: EditorInput, options?: IEditorOpenOptions): IEditorOpenResult {\n\t\tconst makeSticky = options?.sticky || (typeof options?.index === 'number' && this.isSticky(options.index));\n\t\tconst makePinned = options?.pinned || options?.sticky;\n\t\tconst makeTransient = !!options?.transient;\n\t\tconst makeActive = options?.active || !this.activeEditor || (!makePinned && this.preview === this.activeEditor);\n\n\t\tconst existingEditorAndIndex = this.findEditor(candidate, options);\n\n\t\t// New editor\n\t\tif (!existingEditorAndIndex) {\n\t\t\tconst newEditor = candidate;\n\t\t\tconst indexOfActive = this.indexOf(this.active);\n\n\t\t\t// Insert into specific position\n\t\t\tlet targetIndex: number;\n\t\t\tif (options && typeof options.index === 'number') {\n\t\t\t\ttargetIndex = options.index;\n\t\t\t}\n\n\t\t\t// Insert to the BEGINNING\n\t\t\telse if (this.editorOpenPositioning === EditorOpenPositioning.FIRST) {\n\t\t\t\ttargetIndex = 0;\n\n\t\t\t\t// Always make sure targetIndex is after sticky editors\n\t\t\t\t// unless we are explicitly told to make the editor sticky\n\t\t\t\tif (!makeSticky && this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Insert to the END\n\t\t\telse if (this.editorOpenPositioning === EditorOpenPositioning.LAST) {\n\t\t\t\ttargetIndex = this.editors.length;\n\t\t\t}\n\n\t\t\t// Insert to LEFT or RIGHT of active editor\n\t\t\telse {\n\n\t\t\t\t// Insert to the LEFT of active editor\n\t\t\t\tif (this.editorOpenPositioning === EditorOpenPositioning.LEFT) {\n\t\t\t\t\tif (indexOfActive === 0 || !this.editors.length) {\n\t\t\t\t\t\ttargetIndex = 0; // to the left becoming first editor in list\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargetIndex = indexOfActive; // to the left of active editor\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Insert to the RIGHT of active editor\n\t\t\t\telse {\n\t\t\t\t\ttargetIndex = indexOfActive + 1;\n\t\t\t\t}\n\n\t\t\t\t// Always make sure targetIndex is after sticky editors\n\t\t\t\t// unless we are explicitly told to make the editor sticky\n\t\t\t\tif (!makeSticky && this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the editor becomes sticky, increment the sticky index and adjust\n\t\t\t// the targetIndex to be at the end of sticky editors unless already.\n\t\t\tif (makeSticky) {\n\t\t\t\tthis.sticky++;\n\n\t\t\t\tif (!this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Insert into our list of editors if pinned or we have no preview editor\n\t\t\tif (makePinned || !this.preview) {\n\t\t\t\tthis.splice(targetIndex, false, newEditor);\n\t\t\t}\n\n\t\t\t// Handle transient\n\t\t\tif (makeTransient) {\n\t\t\t\tthis.doSetTransient(newEditor, targetIndex, true);\n\t\t\t}\n\n\t\t\t// Handle preview\n\t\t\tif (!makePinned) {\n\n\t\t\t\t// Replace existing preview with this editor if we have a preview\n\t\t\t\tif (this.preview) {\n\t\t\t\t\tconst indexOfPreview = this.indexOf(this.preview);\n\t\t\t\t\tif (targetIndex > indexOfPreview) {\n\t\t\t\t\t\ttargetIndex--; // accomodate for the fact that the preview editor closes\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.replaceEditor(this.preview, newEditor, targetIndex, !makeActive);\n\t\t\t\t}\n\n\t\t\t\tthis.preview = newEditor;\n\t\t\t}\n\n\t\t\t// Listeners\n\t\t\tthis.registerEditorListeners(newEditor);\n\n\t\t\t// Event\n\t\t\tconst event: IGroupEditorOpenEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_OPEN,\n\t\t\t\teditor: newEditor,\n\t\t\t\teditorIndex: targetIndex\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\n\t\t\t// Handle active editor / selected editors\n\t\t\tthis.setSelection(makeActive ? newEditor : this.activeEditor, options?.inactiveSelection ?? []);\n\n\t\t\treturn {\n\t\t\t\teditor: newEditor,\n\t\t\t\tisNew: true\n\t\t\t};\n\t\t}\n\n\t\t// Existing editor\n\t\telse {\n\t\t\tconst [existingEditor, existingEditorIndex] = existingEditorAndIndex;\n\n\t\t\t// Update transient (existing editors do not turn transient if they were not before)\n\t\t\tthis.doSetTransient(existingEditor, existingEditorIndex, makeTransient === false ? false : this.isTransient(existingEditor));\n\n\t\t\t// Pin it\n\t\t\tif (makePinned) {\n\t\t\t\tthis.doPin(existingEditor, existingEditorIndex);\n\t\t\t}\n\n\t\t\t// Handle active editor / selected editors\n\t\t\tthis.setSelection(makeActive ? existingEditor : this.activeEditor, options?.inactiveSelection ?? []);\n\n\t\t\t// Respect index\n\t\t\tif (options && typeof options.index === 'number') {\n\t\t\t\tthis.moveEditor(existingEditor, options.index);\n\t\t\t}\n\n\t\t\t// Stick it (intentionally after the moveEditor call in case\n\t\t\t// the editor was already moved into the sticky range)\n\t\t\tif (makeSticky) {\n\t\t\t\tthis.doStick(existingEditor, this.indexOf(existingEditor));\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\teditor: existingEditor,\n\t\t\t\tisNew: false\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate registerEditorListeners(editor: EditorInput): void {\n\t\tconst listeners = new DisposableStore();\n\t\tthis.editorListeners.add(listeners);\n\n\t\t// Re-emit disposal of editor input as our own event\n\t\tlisteners.add(Event.once(editor.onWillDispose)(() => {\n\t\t\tconst editorIndex = this.editors.indexOf(editor);\n\t\t\tif (editorIndex >= 0) {\n\t\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\t\tkind: GroupModelChangeKind.EDITOR_WILL_DISPOSE,\n\t\t\t\t\teditor,\n\t\t\t\t\teditorIndex\n\t\t\t\t};\n\t\t\t\tthis._onDidModelChange.fire(event);\n\t\t\t}\n\t\t}));\n\n\t\t// Re-Emit dirty state changes\n\t\tlisteners.add(editor.onDidChangeDirty(() => {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_DIRTY,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: this.editors.indexOf(editor)\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}));\n\n\t\t// Re-Emit label changes\n\t\tlisteners.add(editor.onDidChangeLabel(() => {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_LABEL,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: this.editors.indexOf(editor)\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}));\n\n\t\t// Re-Emit capability changes\n\t\tlisteners.add(editor.onDidChangeCapabilities(() => {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_CAPABILITIES,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: this.editors.indexOf(editor)\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}));\n\n\t\t// Clean up dispose listeners once the editor gets closed\n\t\tlisteners.add(this.onDidModelChange(event => {\n\t\t\tif (event.kind === GroupModelChangeKind.EDITOR_CLOSE && event.editor?.matches(editor)) {\n\t\t\t\tdispose(listeners);\n\t\t\t\tthis.editorListeners.delete(listeners);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate replaceEditor(toReplace: EditorInput, replaceWith: EditorInput, replaceIndex: number, openNext = true): void {\n\t\tconst closeResult = this.doCloseEditor(toReplace, EditorCloseContext.REPLACE, openNext); // optimization to prevent multiple setActive() in one call\n\n\t\t// We want to first add the new editor into our model before emitting the close event because\n\t\t// firing the close event can trigger a dispose on the same editor that is now being added.\n\t\t// This can lead into opening a disposed editor which is not what we want.\n\t\tthis.splice(replaceIndex, false, replaceWith);\n\n\t\tif (closeResult) {\n\t\t\tconst event: IGroupEditorCloseEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_CLOSE,\n\t\t\t\t...closeResult\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\t}\n\n\tcloseEditor(candidate: EditorInput, context = EditorCloseContext.UNKNOWN, openNext = true): IEditorCloseResult | undefined {\n\t\tconst closeResult = this.doCloseEditor(candidate, context, openNext);\n\n\t\tif (closeResult) {\n\t\t\tconst event: IGroupEditorCloseEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_CLOSE,\n\t\t\t\t...closeResult\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\n\t\t\treturn closeResult;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate doCloseEditor(candidate: EditorInput, context: EditorCloseContext, openNext: boolean): IEditorCloseResult | undefined {\n\t\tconst index = this.indexOf(candidate);\n\t\tif (index === -1) {\n\t\t\treturn undefined; // not found\n\t\t}\n\n\t\tconst editor = this.editors[index];\n\t\tconst sticky = this.isSticky(index);\n\n\t\t// Active editor closed\n\t\tconst isActiveEditor = this.active === editor;\n\t\tif (openNext && isActiveEditor) {\n\n\t\t\t// More than one editor\n\t\t\tif (this.mru.length > 1) {\n\t\t\t\tlet newActive: EditorInput;\n\t\t\t\tif (this.focusRecentEditorAfterClose) {\n\t\t\t\t\tnewActive = this.mru[1]; // active editor is always first in MRU, so pick second editor after as new active\n\t\t\t\t} else {\n\t\t\t\t\tif (index === this.editors.length - 1) {\n\t\t\t\t\t\tnewActive = this.editors[index - 1]; // last editor is closed, pick previous as new active\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewActive = this.editors[index + 1]; // pick next editor as new active\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Select editor as active\n\t\t\t\tconst newInactiveSelectedEditors = this.selection.filter(selected => selected !== editor && selected !== newActive);\n\t\t\t\tthis.doSetSelection(newActive, this.editors.indexOf(newActive), newInactiveSelectedEditors);\n\t\t\t}\n\n\t\t\t// Last editor closed: clear selection\n\t\t\telse {\n\t\t\t\tthis.doSetSelection(null, undefined, []);\n\t\t\t}\n\t\t}\n\n\t\t// Inactive editor closed\n\t\telse if (!isActiveEditor) {\n\n\t\t\t// Remove editor from inactive selection\n\t\t\tif (this.doIsSelected(editor)) {\n\t\t\t\tconst newInactiveSelectedEditors = this.selection.filter(selected => selected !== editor && selected !== this.activeEditor);\n\t\t\t\tthis.doSetSelection(this.activeEditor, this.indexOf(this.activeEditor), newInactiveSelectedEditors);\n\t\t\t}\n\t\t}\n\n\t\t// Preview Editor closed\n\t\tif (this.preview === editor) {\n\t\t\tthis.preview = null;\n\t\t}\n\n\t\t// Remove from transient\n\t\tthis.transient.delete(editor);\n\n\t\t// Remove from arrays\n\t\tthis.splice(index, true);\n\n\t\t// Event\n\t\treturn { editor, sticky, editorIndex: index, context };\n\t}\n\n\tmoveEditor(candidate: EditorInput, toIndex: number): EditorInput | undefined {\n\n\t\t// Ensure toIndex is in bounds of our model\n\t\tif (toIndex >= this.editors.length) {\n\t\t\ttoIndex = this.editors.length - 1;\n\t\t} else if (toIndex < 0) {\n\t\t\ttoIndex = 0;\n\t\t}\n\n\t\tconst index = this.indexOf(candidate);\n\t\tif (index < 0 || toIndex === index) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst editor = this.editors[index];\n\t\tconst sticky = this.sticky;\n\n\t\t// Adjust sticky index: editor moved out of sticky state into unsticky state\n\t\tif (this.isSticky(index) && toIndex > this.sticky) {\n\t\t\tthis.sticky--;\n\t\t}\n\n\t\t// ...or editor moved into sticky state from unsticky state\n\t\telse if (!this.isSticky(index) && toIndex <= this.sticky) {\n\t\t\tthis.sticky++;\n\t\t}\n\n\t\t// Move\n\t\tthis.editors.splice(index, 1);\n\t\tthis.editors.splice(toIndex, 0, editor);\n\n\t\t// Move Event\n\t\tconst event: IGroupEditorMoveEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_MOVE,\n\t\t\teditor,\n\t\t\toldEditorIndex: index,\n\t\t\teditorIndex: toIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\n\t\t// Sticky Event (if sticky changed as part of the move)\n\t\tif (sticky !== this.sticky) {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: toIndex\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\n\t\treturn editor;\n\t}\n\n\tsetActive(candidate: EditorInput | undefined): EditorInput | undefined {\n\t\tlet result: EditorInput | undefined;\n\n\t\tif (!candidate) {\n\t\t\tthis.setGroupActive();\n\t\t} else {\n\t\t\tresult = this.setEditorActive(candidate);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate setGroupActive(): void {\n\t\t// We do not really keep the `active` state in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_ACTIVE });\n\t}\n\n\tprivate setEditorActive(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doSetSelection(editor, editorIndex, []);\n\n\t\treturn editor;\n\t}\n\n\tget selectedEditors(): EditorInput[] {\n\t\treturn this.editors.filter(editor => this.doIsSelected(editor)); // return in sequential order\n\t}\n\n\tisSelected(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tlet editor: EditorInput | undefined;\n\t\tif (typeof editorCandidateOrIndex === 'number') {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = this.findEditor(editorCandidateOrIndex)?.[0];\n\t\t}\n\n\t\treturn !!editor && this.doIsSelected(editor);\n\t}\n\n\tprivate doIsSelected(editor: EditorInput): boolean {\n\t\treturn this.selection.includes(editor);\n\t}\n\n\tsetSelection(activeSelectedEditorCandidate: EditorInput, inactiveSelectedEditorCandidates: EditorInput[]): void {\n\t\tconst res = this.findEditor(activeSelectedEditorCandidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [activeSelectedEditor, activeSelectedEditorIndex] = res;\n\n\t\tconst inactiveSelectedEditors = new Set<EditorInput>();\n\t\tfor (const inactiveSelectedEditorCandidate of inactiveSelectedEditorCandidates) {\n\t\t\tconst res = this.findEditor(inactiveSelectedEditorCandidate);\n\t\t\tif (!res) {\n\t\t\t\treturn; // not found\n\t\t\t}\n\n\t\t\tconst [inactiveSelectedEditor] = res;\n\t\t\tif (inactiveSelectedEditor === activeSelectedEditor) {\n\t\t\t\tcontinue; // already selected\n\t\t\t}\n\n\t\t\tinactiveSelectedEditors.add(inactiveSelectedEditor);\n\t\t}\n\n\t\tthis.doSetSelection(activeSelectedEditor, activeSelectedEditorIndex, Array.from(inactiveSelectedEditors));\n\t}\n\n\tprivate doSetSelection(activeSelectedEditor: EditorInput | null, activeSelectedEditorIndex: number | undefined, inactiveSelectedEditors: EditorInput[]): void {\n\t\tconst previousActiveEditor = this.activeEditor;\n\t\tconst previousSelection = this.selection;\n\n\t\tlet newSelection: EditorInput[];\n\t\tif (activeSelectedEditor) {\n\t\t\tnewSelection = [activeSelectedEditor, ...inactiveSelectedEditors];\n\t\t} else {\n\t\t\tnewSelection = [];\n\t\t}\n\n\t\t// Update selection\n\t\tthis.selection = newSelection;\n\n\t\t// Update active editor if it has changed\n\t\tconst activeEditorChanged = activeSelectedEditor && typeof activeSelectedEditorIndex === 'number' && previousActiveEditor !== activeSelectedEditor;\n\t\tif (activeEditorChanged) {\n\n\t\t\t// Bring to front in MRU list\n\t\t\tconst mruIndex = this.indexOf(activeSelectedEditor, this.mru);\n\t\t\tthis.mru.splice(mruIndex, 1);\n\t\t\tthis.mru.unshift(activeSelectedEditor);\n\n\t\t\t// Event\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_ACTIVE,\n\t\t\t\teditor: activeSelectedEditor,\n\t\t\t\teditorIndex: activeSelectedEditorIndex\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\n\t\t// Fire event if the selection has changed\n\t\tif (\n\t\t\tactiveEditorChanged ||\n\t\t\tpreviousSelection.length !== newSelection.length ||\n\t\t\tpreviousSelection.some(editor => !newSelection.includes(editor))\n\t\t) {\n\t\t\tconst event: IGroupModelChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITORS_SELECTION\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\t}\n\n\tsetIndex(index: number) {\n\t\t// We do not really keep the `index` in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_INDEX });\n\t}\n\n\tsetLabel(label: string) {\n\t\t// We do not really keep the `label` in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_LABEL });\n\t}\n\n\tpin(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doPin(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doPin(editor: EditorInput, editorIndex: number): void {\n\t\tif (this.isPinned(editor)) {\n\t\t\treturn; // can only pin a preview editor\n\t\t}\n\n\t\t// Clear Transient\n\t\tthis.setTransient(editor, false);\n\n\t\t// Convert the preview editor to be a pinned editor\n\t\tthis.preview = null;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_PIN,\n\t\t\teditor,\n\t\t\teditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tunpin(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doUnpin(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doUnpin(editor: EditorInput, editorIndex: number): void {\n\t\tif (!this.isPinned(editor)) {\n\t\t\treturn; // can only unpin a pinned editor\n\t\t}\n\n\t\t// Set new\n\t\tconst oldPreview = this.preview;\n\t\tthis.preview = editor;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_PIN,\n\t\t\teditor,\n\t\t\teditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\n\t\t// Close old preview editor if any\n\t\tif (oldPreview) {\n\t\t\tthis.closeEditor(oldPreview, EditorCloseContext.UNPIN);\n\t\t}\n\t}\n\n\tisPinned(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tlet editor: EditorInput;\n\t\tif (typeof editorCandidateOrIndex === 'number') {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = editorCandidateOrIndex;\n\t\t}\n\n\t\treturn !this.matches(this.preview, editor);\n\t}\n\n\tstick(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doStick(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doStick(editor: EditorInput, editorIndex: number): void {\n\t\tif (this.isSticky(editorIndex)) {\n\t\t\treturn; // can only stick a non-sticky editor\n\t\t}\n\n\t\t// Pin editor\n\t\tthis.pin(editor);\n\n\t\t// Move editor to be the last sticky editor\n\t\tconst newEditorIndex = this.sticky + 1;\n\t\tthis.moveEditor(editor, newEditorIndex);\n\n\t\t// Adjust sticky index\n\t\tthis.sticky++;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\teditor,\n\t\t\teditorIndex: newEditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tunstick(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doUnstick(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doUnstick(editor: EditorInput, editorIndex: number): void {\n\t\tif (!this.isSticky(editorIndex)) {\n\t\t\treturn; // can only unstick a sticky editor\n\t\t}\n\n\t\t// Move editor to be the first non-sticky editor\n\t\tconst newEditorIndex = this.sticky;\n\t\tthis.moveEditor(editor, newEditorIndex);\n\n\t\t// Adjust sticky index\n\t\tthis.sticky--;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\teditor,\n\t\t\teditorIndex: newEditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tisSticky(candidateOrIndex: EditorInput | number): boolean {\n\t\tif (this.sticky < 0) {\n\t\t\treturn false; // no sticky editor\n\t\t}\n\n\t\tlet index: number;\n\t\tif (typeof candidateOrIndex === 'number') {\n\t\t\tindex = candidateOrIndex;\n\t\t} else {\n\t\t\tindex = this.indexOf(candidateOrIndex);\n\t\t}\n\n\t\tif (index < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn index <= this.sticky;\n\t}\n\n\tsetTransient(candidate: EditorInput, transient: boolean): EditorInput | undefined {\n\t\tif (!transient && this.transient.size === 0) {\n\t\t\treturn; // no transient editor\n\t\t}\n\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doSetTransient(editor, editorIndex, transient);\n\n\t\treturn editor;\n\t}\n\n\tprivate doSetTransient(editor: EditorInput, editorIndex: number, transient: boolean): void {\n\t\tif (transient) {\n\t\t\tif (this.transient.has(editor)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.transient.add(editor);\n\t\t} else {\n\t\t\tif (!this.transient.has(editor)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.transient.delete(editor);\n\t\t}\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_TRANSIENT,\n\t\t\teditor,\n\t\t\teditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tisTransient(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tif (this.transient.size === 0) {\n\t\t\treturn false; // no transient editor\n\t\t}\n\n\t\tlet editor: EditorInput | undefined;\n\t\tif (typeof editorCandidateOrIndex === 'number') {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = this.findEditor(editorCandidateOrIndex)?.[0];\n\t\t}\n\n\t\treturn !!editor && this.transient.has(editor);\n\t}\n\n\tprivate splice(index: number, del: boolean, editor?: EditorInput): void {\n\t\tconst editorToDeleteOrReplace = this.editors[index];\n\n\t\t// Perform on sticky index\n\t\tif (del && this.isSticky(index)) {\n\t\t\tthis.sticky--;\n\t\t}\n\n\t\t// Perform on editors array\n\t\tif (editor) {\n\t\t\tthis.editors.splice(index, del ? 1 : 0, editor);\n\t\t} else {\n\t\t\tthis.editors.splice(index, del ? 1 : 0);\n\t\t}\n\n\t\t// Perform on MRU\n\t\t{\n\t\t\t// Add\n\t\t\tif (!del && editor) {\n\t\t\t\tif (this.mru.length === 0) {\n\t\t\t\t\t// the list of most recent editors is empty\n\t\t\t\t\t// so this editor can only be the most recent\n\t\t\t\t\tthis.mru.push(editor);\n\t\t\t\t} else {\n\t\t\t\t\t// we have most recent editors. as such we\n\t\t\t\t\t// put this newly opened editor right after\n\t\t\t\t\t// the current most recent one because it cannot\n\t\t\t\t\t// be the most recently active one unless\n\t\t\t\t\t// it becomes active. but it is still more\n\t\t\t\t\t// active then any other editor in the list.\n\t\t\t\t\tthis.mru.splice(1, 0, editor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove / Replace\n\t\t\telse {\n\t\t\t\tconst indexInMRU = this.indexOf(editorToDeleteOrReplace, this.mru);\n\n\t\t\t\t// Remove\n\t\t\t\tif (del && !editor) {\n\t\t\t\t\tthis.mru.splice(indexInMRU, 1); // remove from MRU\n\t\t\t\t}\n\n\t\t\t\t// Replace\n\t\t\t\telse if (del && editor) {\n\t\t\t\t\tthis.mru.splice(indexInMRU, 1, editor); // replace MRU at location\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tindexOf(candidate: EditorInput | IUntypedEditorInput | null, editors = this.editors, options?: IMatchEditorOptions): number {\n\t\tlet index = -1;\n\t\tif (!candidate) {\n\t\t\treturn index;\n\t\t}\n\n\t\tfor (let i = 0; i < editors.length; i++) {\n\t\t\tconst editor = editors[i];\n\n\t\t\tif (this.matches(editor, candidate, options)) {\n\t\t\t\t// If we are to support side by side matching, it is possible that\n\t\t\t\t// a better direct match is found later. As such, we continue finding\n\t\t\t\t// a matching editor and prefer that match over the side by side one.\n\t\t\t\tif (options?.supportSideBySide && editor instanceof SideBySideEditorInput && !(candidate instanceof SideBySideEditorInput)) {\n\t\t\t\t\tindex = i;\n\t\t\t\t} else {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfindEditor(candidate: EditorInput | null, options?: IMatchEditorOptions): [EditorInput, number /* index */] | undefined {\n\t\tconst index = this.indexOf(candidate, this.editors, options);\n\t\tif (index === -1) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn [this.editors[index], index];\n\t}\n\n\tisFirst(candidate: EditorInput | null, editors = this.editors): boolean {\n\t\treturn this.matches(editors[0], candidate);\n\t}\n\n\tisLast(candidate: EditorInput | null, editors = this.editors): boolean {\n\t\treturn this.matches(editors[editors.length - 1], candidate);\n\t}\n\n\tcontains(candidate: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean {\n\t\treturn this.indexOf(candidate, this.editors, options) !== -1;\n\t}\n\n\tprivate matches(editor: EditorInput | null | undefined, candidate: EditorInput | IUntypedEditorInput | null, options?: IMatchEditorOptions): boolean {\n\t\tif (!editor || !candidate) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (options?.supportSideBySide && editor instanceof SideBySideEditorInput && !(candidate instanceof SideBySideEditorInput)) {\n\t\t\tswitch (options.supportSideBySide) {\n\t\t\t\tcase SideBySideEditor.ANY:\n\t\t\t\t\tif (this.matches(editor.primary, candidate, options) || this.matches(editor.secondary, candidate, options)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SideBySideEditor.BOTH:\n\t\t\t\t\tif (this.matches(editor.primary, candidate, options) && this.matches(editor.secondary, candidate, options)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst strictEquals = editor === candidate;\n\n\t\tif (options?.strictEquals) {\n\t\t\treturn strictEquals;\n\t\t}\n\n\t\treturn strictEquals || editor.matches(candidate);\n\t}\n\n\tget isLocked(): boolean {\n\t\treturn this.locked;\n\t}\n\n\tlock(locked: boolean): void {\n\t\tif (this.isLocked !== locked) {\n\t\t\tthis.locked = locked;\n\n\t\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_LOCKED });\n\t\t}\n\t}\n\n\tclone(): EditorGroupModel {\n\t\tconst clone = this.instantiationService.createInstance(EditorGroupModel, undefined);\n\n\t\t// Copy over group properties\n\t\tclone.editors = this.editors.slice(0);\n\t\tclone.mru = this.mru.slice(0);\n\t\tclone.preview = this.preview;\n\t\tclone.selection = this.selection.slice(0);\n\t\tclone.sticky = this.sticky;\n\n\t\t// Ensure to register listeners for each editor\n\t\tfor (const editor of clone.editors) {\n\t\t\tclone.registerEditorListeners(editor);\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\tserialize(): ISerializedEditorGroupModel {\n\t\tconst registry = Registry.as<IEditorFactoryRegistry>(EditorExtensions.EditorFactory);\n\n\t\t// Serialize all editor inputs so that we can store them.\n\t\t// Editors that cannot be serialized need to be ignored\n\t\t// from mru, active, preview and sticky if any.\n\t\tconst serializableEditors: EditorInput[] = [];\n\t\tconst serializedEditors: ISerializedEditorInput[] = [];\n\t\tlet serializablePreviewIndex: number | undefined;\n\t\tlet serializableSticky = this.sticky;\n\n\t\tfor (let i = 0; i < this.editors.length; i++) {\n\t\t\tconst editor = this.editors[i];\n\t\t\tlet canSerializeEditor = false;\n\n\t\t\tconst editorSerializer = registry.getEditorSerializer(editor);\n\t\t\tif (editorSerializer) {\n\t\t\t\tconst value = editorSerializer.canSerialize(editor) ? editorSerializer.serialize(editor) : undefined;\n\n\t\t\t\t// Editor can be serialized\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tcanSerializeEditor = true;\n\n\t\t\t\t\tserializedEditors.push({ id: editor.typeId, value });\n\t\t\t\t\tserializableEditors.push(editor);\n\n\t\t\t\t\tif (this.preview === editor) {\n\t\t\t\t\t\tserializablePreviewIndex = serializableEditors.length - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Editor cannot be serialized\n\t\t\t\telse {\n\t\t\t\t\tcanSerializeEditor = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adjust index of sticky editors if the editor cannot be serialized and is pinned\n\t\t\tif (!canSerializeEditor && this.isSticky(i)) {\n\t\t\t\tserializableSticky--;\n\t\t\t}\n\t\t}\n\n\t\tconst serializableMru = this.mru.map(editor => this.indexOf(editor, serializableEditors)).filter(i => i >= 0);\n\n\t\treturn {\n\t\t\tid: this.id,\n\t\t\tlocked: this.locked ? true : undefined,\n\t\t\teditors: serializedEditors,\n\t\t\tmru: serializableMru,\n\t\t\tpreview: serializablePreviewIndex,\n\t\t\tsticky: serializableSticky >= 0 ? serializableSticky : undefined\n\t\t};\n\t}\n\n\tprivate deserialize(data: ISerializedEditorGroupModel): number {\n\t\tconst registry = Registry.as<IEditorFactoryRegistry>(EditorExtensions.EditorFactory);\n\n\t\tif (typeof data.id === 'number') {\n\t\t\tthis._id = data.id;\n\n\t\t\tEditorGroupModel.IDS = Math.max(data.id + 1, EditorGroupModel.IDS); // make sure our ID generator is always larger\n\t\t} else {\n\t\t\tthis._id = EditorGroupModel.IDS++; // backwards compatibility\n\t\t}\n\n\t\tif (data.locked) {\n\t\t\tthis.locked = true;\n\t\t}\n\n\t\tthis.editors = coalesce(data.editors.map((e, index) => {\n\t\t\tlet editor: EditorInput | undefined;\n\n\t\t\tconst editorSerializer = registry.getEditorSerializer(e.id);\n\t\t\tif (editorSerializer) {\n\t\t\t\tconst deserializedEditor = editorSerializer.deserialize(this.instantiationService, e.value);\n\t\t\t\tif (deserializedEditor instanceof EditorInput) {\n\t\t\t\t\teditor = deserializedEditor;\n\t\t\t\t\tthis.registerEditorListeners(editor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!editor && typeof data.sticky === 'number' && index <= data.sticky) {\n\t\t\t\tdata.sticky--; // if editor cannot be deserialized but was sticky, we need to decrease sticky index\n\t\t\t}\n\n\t\t\treturn editor;\n\t\t}));\n\n\t\tthis.mru = coalesce(data.mru.map(i => this.editors[i]));\n\n\t\tthis.selection = this.mru.length > 0 ? [this.mru[0]] : [];\n\n\t\tif (typeof data.preview === 'number') {\n\t\t\tthis.preview = this.editors[data.preview];\n\t\t}\n\n\t\tif (typeof data.sticky === 'number') {\n\t\t\tthis.sticky = data.sticky;\n\t\t}\n\n\t\treturn this._id;\n\t}\n\n\toverride dispose(): void {\n\t\tdispose(Array.from(this.editorListeners));\n\t\tthis.editorListeners.clear();\n\n\t\tthis.transient.clear();\n\n\t\tsuper.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from '../../../base/common/event.js';\nimport { IEditorFactoryRegistry, GroupIdentifier, EditorsOrder, EditorExtensions, IUntypedEditorInput, SideBySideEditor, EditorCloseContext, IMatchEditorOptions, GroupModelChangeKind } from '../editor.js';\nimport { EditorInput } from './editorInput.js';\nimport { SideBySideEditorInput } from './sideBySideEditorInput.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationChangeEvent, IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { dispose, Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { coalesce } from '../../../base/common/arrays.js';\n\nconst EditorOpenPositioning = {\n\tLEFT: 'left',\n\tRIGHT: 'right',\n\tFIRST: 'first',\n\tLAST: 'last'\n};\n\nexport interface IEditorOpenOptions {\n\treadonly pinned?: boolean;\n\treadonly sticky?: boolean;\n\treadonly transient?: boolean;\n\tactive?: boolean;\n\treadonly inactiveSelection?: EditorInput[];\n\treadonly index?: number;\n\treadonly supportSideBySide?: SideBySideEditor.ANY | SideBySideEditor.BOTH;\n}\n\nexport interface IEditorOpenResult {\n\treadonly editor: EditorInput;\n\treadonly isNew: boolean;\n}\n\nexport interface ISerializedEditorInput {\n\treadonly id: string;\n\treadonly value: string;\n}\n\nexport interface ISerializedEditorGroupModel {\n\treadonly id: number;\n\treadonly locked?: boolean;\n\treadonly editors: ISerializedEditorInput[];\n\treadonly mru: number[];\n\treadonly preview?: number;\n\tsticky?: number;\n}\n\nexport function isSerializedEditorGroupModel(group?: unknown): group is ISerializedEditorGroupModel {\n\tconst candidate = group as ISerializedEditorGroupModel | undefined;\n\n\treturn !!(candidate && typeof candidate === 'object' && Array.isArray(candidate.editors) && Array.isArray(candidate.mru));\n}\n\nexport interface IGroupModelChangeEvent {\n\n\t/**\n\t * The kind of change that occurred in the group model.\n\t */\n\treadonly kind: GroupModelChangeKind;\n\n\t/**\n\t * Only applies when editors change providing\n\t * access to the editor the event is about.\n\t */\n\treadonly editor?: EditorInput;\n\n\t/**\n\t * Only applies when editors change providing\n\t * access to the index of the editor the event\n\t * is about.\n\t */\n\treadonly editorIndex?: number;\n}\n\nexport interface IGroupEditorChangeEvent extends IGroupModelChangeEvent {\n\treadonly editor: EditorInput;\n\treadonly editorIndex: number;\n}\n\nexport function isGroupEditorChangeEvent(e: IGroupModelChangeEvent): e is IGroupEditorChangeEvent {\n\tconst candidate = e as IGroupEditorOpenEvent;\n\n\treturn candidate.editor && candidate.editorIndex !== undefined;\n}\n\nexport interface IGroupEditorOpenEvent extends IGroupEditorChangeEvent {\n\n\treadonly kind: GroupModelChangeKind.EDITOR_OPEN;\n}\n\nexport function isGroupEditorOpenEvent(e: IGroupModelChangeEvent): e is IGroupEditorOpenEvent {\n\tconst candidate = e as IGroupEditorOpenEvent;\n\n\treturn candidate.kind === GroupModelChangeKind.EDITOR_OPEN && candidate.editorIndex !== undefined;\n}\n\nexport interface IGroupEditorMoveEvent extends IGroupEditorChangeEvent {\n\n\treadonly kind: GroupModelChangeKind.EDITOR_MOVE;\n\n\t/**\n\t * Signifies the index the editor is moving from.\n\t * `editorIndex` will contain the index the editor\n\t * is moving to.\n\t */\n\treadonly oldEditorIndex: number;\n}\n\nexport function isGroupEditorMoveEvent(e: IGroupModelChangeEvent): e is IGroupEditorMoveEvent {\n\tconst candidate = e as IGroupEditorMoveEvent;\n\n\treturn candidate.kind === GroupModelChangeKind.EDITOR_MOVE && candidate.editorIndex !== undefined && candidate.oldEditorIndex !== undefined;\n}\n\nexport interface IGroupEditorCloseEvent extends IGroupEditorChangeEvent {\n\n\treadonly kind: GroupModelChangeKind.EDITOR_CLOSE;\n\n\t/**\n\t * Signifies the context in which the editor\n\t * is being closed. This allows for understanding\n\t * if a replace or reopen is occurring\n\t */\n\treadonly context: EditorCloseContext;\n\n\t/**\n\t * Signifies whether or not the closed editor was\n\t * sticky. This is necessary becasue state is lost\n\t * after closing.\n\t */\n\treadonly sticky: boolean;\n}\n\nexport function isGroupEditorCloseEvent(e: IGroupModelChangeEvent): e is IGroupEditorCloseEvent {\n\tconst candidate = e as IGroupEditorCloseEvent;\n\n\treturn candidate.kind === GroupModelChangeKind.EDITOR_CLOSE && candidate.editorIndex !== undefined && candidate.context !== undefined && candidate.sticky !== undefined;\n}\n\ninterface IEditorCloseResult {\n\treadonly editor: EditorInput;\n\treadonly context: EditorCloseContext;\n\treadonly editorIndex: number;\n\treadonly sticky: boolean;\n}\n\nexport interface IReadonlyEditorGroupModel {\n\n\treadonly onDidModelChange: Event<IGroupModelChangeEvent>;\n\n\treadonly id: GroupIdentifier;\n\treadonly count: number;\n\treadonly stickyCount: number;\n\treadonly isLocked: boolean;\n\treadonly activeEditor: EditorInput | null;\n\treadonly previewEditor: EditorInput | null;\n\treadonly selectedEditors: EditorInput[];\n\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[];\n\tgetEditorByIndex(index: number): EditorInput | undefined;\n\tindexOf(editor: EditorInput | IUntypedEditorInput | null, editors?: EditorInput[], options?: IMatchEditorOptions): number;\n\tisActive(editor: EditorInput | IUntypedEditorInput): boolean;\n\tisPinned(editorOrIndex: EditorInput | number): boolean;\n\tisSticky(editorOrIndex: EditorInput | number): boolean;\n\tisSelected(editorOrIndex: EditorInput | number): boolean;\n\tisTransient(editorOrIndex: EditorInput | number): boolean;\n\tisFirst(editor: EditorInput, editors?: EditorInput[]): boolean;\n\tisLast(editor: EditorInput, editors?: EditorInput[]): boolean;\n\tfindEditor(editor: EditorInput | null, options?: IMatchEditorOptions): [EditorInput, number /* index */] | undefined;\n\tcontains(editor: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean;\n}\n\ninterface IEditorGroupModel extends IReadonlyEditorGroupModel {\n\topenEditor(editor: EditorInput, options?: IEditorOpenOptions): IEditorOpenResult;\n\tcloseEditor(editor: EditorInput, context?: EditorCloseContext, openNext?: boolean): IEditorCloseResult | undefined;\n\tmoveEditor(editor: EditorInput, toIndex: number): EditorInput | undefined;\n\tsetActive(editor: EditorInput | undefined): EditorInput | undefined;\n\tsetSelection(activeSelectedEditor: EditorInput, inactiveSelectedEditors: EditorInput[]): void;\n}\n\nexport class EditorGroupModel extends Disposable implements IEditorGroupModel {\n\n\tprivate static IDS = 0;\n\n\t//#region events\n\n\tprivate readonly _onDidModelChange = this._register(new Emitter<IGroupModelChangeEvent>({ leakWarningThreshold: 500 /* increased for users with hundreds of inputs opened */ }));\n\treadonly onDidModelChange = this._onDidModelChange.event;\n\n\t//#endregion\n\n\tprivate _id: GroupIdentifier;\n\tget id(): GroupIdentifier { return this._id; }\n\n\tprivate editors: EditorInput[] = [];\n\tprivate mru: EditorInput[] = [];\n\n\tprivate readonly editorListeners = new Set<DisposableStore>();\n\n\tprivate locked = false;\n\n\tprivate selection: EditorInput[] = [];\t\t\t\t\t// editors in selected state, first one is active\n\n\tprivate get active(): EditorInput | null {\n\t\treturn this.selection[0] ?? null;\n\t}\n\n\tprivate preview: EditorInput | null = null; \t\t\t// editor in preview state\n\tprivate sticky = -1;\t\t\t\t\t\t\t\t\t// index of first editor in sticky state\n\tprivate readonly transient = new Set<EditorInput>(); \t// editors in transient state\n\n\tprivate editorOpenPositioning: ('left' | 'right' | 'first' | 'last') | undefined;\n\tprivate focusRecentEditorAfterClose: boolean | undefined;\n\n\tconstructor(\n\t\tlabelOrSerializedGroup: ISerializedEditorGroupModel | undefined,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\n\t\tif (isSerializedEditorGroupModel(labelOrSerializedGroup)) {\n\t\t\tthis._id = this.deserialize(labelOrSerializedGroup);\n\t\t} else {\n\t\t\tthis._id = EditorGroupModel.IDS++;\n\t\t}\n\n\t\tthis.onConfigurationUpdated();\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(e)));\n\t}\n\n\tprivate onConfigurationUpdated(e?: IConfigurationChangeEvent): void {\n\t\tif (e && !e.affectsConfiguration('workbench.editor.openPositioning') && !e.affectsConfiguration('workbench.editor.focusRecentEditorAfterClose')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.editorOpenPositioning = this.configurationService.getValue('workbench.editor.openPositioning');\n\t\tthis.focusRecentEditorAfterClose = this.configurationService.getValue('workbench.editor.focusRecentEditorAfterClose');\n\t}\n\n\tget count(): number {\n\t\treturn this.editors.length;\n\t}\n\n\tget stickyCount(): number {\n\t\treturn this.sticky + 1;\n\t}\n\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): EditorInput[] {\n\t\tconst editors = order === EditorsOrder.MOST_RECENTLY_ACTIVE ? this.mru.slice(0) : this.editors.slice(0);\n\n\t\tif (options?.excludeSticky) {\n\n\t\t\t// MRU: need to check for index on each\n\t\t\tif (order === EditorsOrder.MOST_RECENTLY_ACTIVE) {\n\t\t\t\treturn editors.filter(editor => !this.isSticky(editor));\n\t\t\t}\n\n\t\t\t// Sequential: simply start after sticky index\n\t\t\treturn editors.slice(this.sticky + 1);\n\t\t}\n\n\t\treturn editors;\n\t}\n\n\tgetEditorByIndex(index: number): EditorInput | undefined {\n\t\treturn this.editors[index];\n\t}\n\n\tget activeEditor(): EditorInput | null {\n\t\treturn this.active;\n\t}\n\n\tisActive(candidate: EditorInput | IUntypedEditorInput): boolean {\n\t\treturn this.matches(this.active, candidate);\n\t}\n\n\tget previewEditor(): EditorInput | null {\n\t\treturn this.preview;\n\t}\n\n\topenEditor(candidate: EditorInput, options?: IEditorOpenOptions): IEditorOpenResult {\n\t\tconst makeSticky = options?.sticky || (typeof options?.index === 'number' && this.isSticky(options.index));\n\t\tconst makePinned = options?.pinned || options?.sticky;\n\t\tconst makeTransient = !!options?.transient;\n\t\tconst makeActive = options?.active || !this.activeEditor || (!makePinned && this.preview === this.activeEditor);\n\n\t\tconst existingEditorAndIndex = this.findEditor(candidate, options);\n\n\t\t// New editor\n\t\tif (!existingEditorAndIndex) {\n\t\t\tconst newEditor = candidate;\n\t\t\tconst indexOfActive = this.indexOf(this.active);\n\n\t\t\t// Insert into specific position\n\t\t\tlet targetIndex: number;\n\t\t\tif (options && typeof options.index === 'number') {\n\t\t\t\ttargetIndex = options.index;\n\t\t\t}\n\n\t\t\t// Insert to the BEGINNING\n\t\t\telse if (this.editorOpenPositioning === EditorOpenPositioning.FIRST) {\n\t\t\t\ttargetIndex = 0;\n\n\t\t\t\t// Always make sure targetIndex is after sticky editors\n\t\t\t\t// unless we are explicitly told to make the editor sticky\n\t\t\t\tif (!makeSticky && this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Insert to the END\n\t\t\telse if (this.editorOpenPositioning === EditorOpenPositioning.LAST) {\n\t\t\t\ttargetIndex = this.editors.length;\n\t\t\t}\n\n\t\t\t// Insert to LEFT or RIGHT of active editor\n\t\t\telse {\n\n\t\t\t\t// Insert to the LEFT of active editor\n\t\t\t\tif (this.editorOpenPositioning === EditorOpenPositioning.LEFT) {\n\t\t\t\t\tif (indexOfActive === 0 || !this.editors.length) {\n\t\t\t\t\t\ttargetIndex = 0; // to the left becoming first editor in list\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargetIndex = indexOfActive; // to the left of active editor\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Insert to the RIGHT of active editor\n\t\t\t\telse {\n\t\t\t\t\ttargetIndex = indexOfActive + 1;\n\t\t\t\t}\n\n\t\t\t\t// Always make sure targetIndex is after sticky editors\n\t\t\t\t// unless we are explicitly told to make the editor sticky\n\t\t\t\tif (!makeSticky && this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the editor becomes sticky, increment the sticky index and adjust\n\t\t\t// the targetIndex to be at the end of sticky editors unless already.\n\t\t\tif (makeSticky) {\n\t\t\t\tthis.sticky++;\n\n\t\t\t\tif (!this.isSticky(targetIndex)) {\n\t\t\t\t\ttargetIndex = this.sticky;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Insert into our list of editors if pinned or we have no preview editor\n\t\t\tif (makePinned || !this.preview) {\n\t\t\t\tthis.splice(targetIndex, false, newEditor);\n\t\t\t}\n\n\t\t\t// Handle transient\n\t\t\tif (makeTransient) {\n\t\t\t\tthis.doSetTransient(newEditor, targetIndex, true);\n\t\t\t}\n\n\t\t\t// Handle preview\n\t\t\tif (!makePinned) {\n\n\t\t\t\t// Replace existing preview with this editor if we have a preview\n\t\t\t\tif (this.preview) {\n\t\t\t\t\tconst indexOfPreview = this.indexOf(this.preview);\n\t\t\t\t\tif (targetIndex > indexOfPreview) {\n\t\t\t\t\t\ttargetIndex--; // accomodate for the fact that the preview editor closes\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.replaceEditor(this.preview, newEditor, targetIndex, !makeActive);\n\t\t\t\t}\n\n\t\t\t\tthis.preview = newEditor;\n\t\t\t}\n\n\t\t\t// Listeners\n\t\t\tthis.registerEditorListeners(newEditor);\n\n\t\t\t// Event\n\t\t\tconst event: IGroupEditorOpenEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_OPEN,\n\t\t\t\teditor: newEditor,\n\t\t\t\teditorIndex: targetIndex\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\n\t\t\t// Handle active editor / selected editors\n\t\t\tthis.setSelection(makeActive ? newEditor : this.activeEditor, options?.inactiveSelection ?? []);\n\n\t\t\treturn {\n\t\t\t\teditor: newEditor,\n\t\t\t\tisNew: true\n\t\t\t};\n\t\t}\n\n\t\t// Existing editor\n\t\telse {\n\t\t\tconst [existingEditor, existingEditorIndex] = existingEditorAndIndex;\n\n\t\t\t// Update transient (existing editors do not turn transient if they were not before)\n\t\t\tthis.doSetTransient(existingEditor, existingEditorIndex, makeTransient === false ? false : this.isTransient(existingEditor));\n\n\t\t\t// Pin it\n\t\t\tif (makePinned) {\n\t\t\t\tthis.doPin(existingEditor, existingEditorIndex);\n\t\t\t}\n\n\t\t\t// Handle active editor / selected editors\n\t\t\tthis.setSelection(makeActive ? existingEditor : this.activeEditor, options?.inactiveSelection ?? []);\n\n\t\t\t// Respect index\n\t\t\tif (options && typeof options.index === 'number') {\n\t\t\t\tthis.moveEditor(existingEditor, options.index);\n\t\t\t}\n\n\t\t\t// Stick it (intentionally after the moveEditor call in case\n\t\t\t// the editor was already moved into the sticky range)\n\t\t\tif (makeSticky) {\n\t\t\t\tthis.doStick(existingEditor, this.indexOf(existingEditor));\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\teditor: existingEditor,\n\t\t\t\tisNew: false\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate registerEditorListeners(editor: EditorInput): void {\n\t\tconst listeners = new DisposableStore();\n\t\tthis.editorListeners.add(listeners);\n\n\t\t// Re-emit disposal of editor input as our own event\n\t\tlisteners.add(Event.once(editor.onWillDispose)(() => {\n\t\t\tconst editorIndex = this.editors.indexOf(editor);\n\t\t\tif (editorIndex >= 0) {\n\t\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\t\tkind: GroupModelChangeKind.EDITOR_WILL_DISPOSE,\n\t\t\t\t\teditor,\n\t\t\t\t\teditorIndex\n\t\t\t\t};\n\t\t\t\tthis._onDidModelChange.fire(event);\n\t\t\t}\n\t\t}));\n\n\t\t// Re-Emit dirty state changes\n\t\tlisteners.add(editor.onDidChangeDirty(() => {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_DIRTY,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: this.editors.indexOf(editor)\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}));\n\n\t\t// Re-Emit label changes\n\t\tlisteners.add(editor.onDidChangeLabel(() => {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_LABEL,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: this.editors.indexOf(editor)\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}));\n\n\t\t// Re-Emit capability changes\n\t\tlisteners.add(editor.onDidChangeCapabilities(() => {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_CAPABILITIES,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: this.editors.indexOf(editor)\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}));\n\n\t\t// Clean up dispose listeners once the editor gets closed\n\t\tlisteners.add(this.onDidModelChange(event => {\n\t\t\tif (event.kind === GroupModelChangeKind.EDITOR_CLOSE && event.editor?.matches(editor)) {\n\t\t\t\tdispose(listeners);\n\t\t\t\tthis.editorListeners.delete(listeners);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate replaceEditor(toReplace: EditorInput, replaceWith: EditorInput, replaceIndex: number, openNext = true): void {\n\t\tconst closeResult = this.doCloseEditor(toReplace, EditorCloseContext.REPLACE, openNext); // optimization to prevent multiple setActive() in one call\n\n\t\t// We want to first add the new editor into our model before emitting the close event because\n\t\t// firing the close event can trigger a dispose on the same editor that is now being added.\n\t\t// This can lead into opening a disposed editor which is not what we want.\n\t\tthis.splice(replaceIndex, false, replaceWith);\n\n\t\tif (closeResult) {\n\t\t\tconst event: IGroupEditorCloseEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_CLOSE,\n\t\t\t\t...closeResult\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\t}\n\n\tcloseEditor(candidate: EditorInput, context = EditorCloseContext.UNKNOWN, openNext = true): IEditorCloseResult | undefined {\n\t\tconst closeResult = this.doCloseEditor(candidate, context, openNext);\n\n\t\tif (closeResult) {\n\t\t\tconst event: IGroupEditorCloseEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_CLOSE,\n\t\t\t\t...closeResult\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\n\t\t\treturn closeResult;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate doCloseEditor(candidate: EditorInput, context: EditorCloseContext, openNext: boolean): IEditorCloseResult | undefined {\n\t\tconst index = this.indexOf(candidate);\n\t\tif (index === -1) {\n\t\t\treturn undefined; // not found\n\t\t}\n\n\t\tconst editor = this.editors[index];\n\t\tconst sticky = this.isSticky(index);\n\n\t\t// Active editor closed\n\t\tconst isActiveEditor = this.active === editor;\n\t\tif (openNext && isActiveEditor) {\n\n\t\t\t// More than one editor\n\t\t\tif (this.mru.length > 1) {\n\t\t\t\tlet newActive: EditorInput;\n\t\t\t\tif (this.focusRecentEditorAfterClose) {\n\t\t\t\t\tnewActive = this.mru[1]; // active editor is always first in MRU, so pick second editor after as new active\n\t\t\t\t} else {\n\t\t\t\t\tif (index === this.editors.length - 1) {\n\t\t\t\t\t\tnewActive = this.editors[index - 1]; // last editor is closed, pick previous as new active\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewActive = this.editors[index + 1]; // pick next editor as new active\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Select editor as active\n\t\t\t\tconst newInactiveSelectedEditors = this.selection.filter(selected => selected !== editor && selected !== newActive);\n\t\t\t\tthis.doSetSelection(newActive, this.editors.indexOf(newActive), newInactiveSelectedEditors);\n\t\t\t}\n\n\t\t\t// Last editor closed: clear selection\n\t\t\telse {\n\t\t\t\tthis.doSetSelection(null, undefined, []);\n\t\t\t}\n\t\t}\n\n\t\t// Inactive editor closed\n\t\telse if (!isActiveEditor) {\n\n\t\t\t// Remove editor from inactive selection\n\t\t\tif (this.doIsSelected(editor)) {\n\t\t\t\tconst newInactiveSelectedEditors = this.selection.filter(selected => selected !== editor && selected !== this.activeEditor);\n\t\t\t\tthis.doSetSelection(this.activeEditor, this.indexOf(this.activeEditor), newInactiveSelectedEditors);\n\t\t\t}\n\t\t}\n\n\t\t// Preview Editor closed\n\t\tif (this.preview === editor) {\n\t\t\tthis.preview = null;\n\t\t}\n\n\t\t// Remove from transient\n\t\tthis.transient.delete(editor);\n\n\t\t// Remove from arrays\n\t\tthis.splice(index, true);\n\n\t\t// Event\n\t\treturn { editor, sticky, editorIndex: index, context };\n\t}\n\n\tmoveEditor(candidate: EditorInput, toIndex: number): EditorInput | undefined {\n\n\t\t// Ensure toIndex is in bounds of our model\n\t\tif (toIndex >= this.editors.length) {\n\t\t\ttoIndex = this.editors.length - 1;\n\t\t} else if (toIndex < 0) {\n\t\t\ttoIndex = 0;\n\t\t}\n\n\t\tconst index = this.indexOf(candidate);\n\t\tif (index < 0 || toIndex === index) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst editor = this.editors[index];\n\t\tconst sticky = this.sticky;\n\n\t\t// Adjust sticky index: editor moved out of sticky state into unsticky state\n\t\tif (this.isSticky(index) && toIndex > this.sticky) {\n\t\t\tthis.sticky--;\n\t\t}\n\n\t\t// ...or editor moved into sticky state from unsticky state\n\t\telse if (!this.isSticky(index) && toIndex <= this.sticky) {\n\t\t\tthis.sticky++;\n\t\t}\n\n\t\t// Move\n\t\tthis.editors.splice(index, 1);\n\t\tthis.editors.splice(toIndex, 0, editor);\n\n\t\t// Move Event\n\t\tconst event: IGroupEditorMoveEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_MOVE,\n\t\t\teditor,\n\t\t\toldEditorIndex: index,\n\t\t\teditorIndex: toIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\n\t\t// Sticky Event (if sticky changed as part of the move)\n\t\tif (sticky !== this.sticky) {\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\t\teditor,\n\t\t\t\teditorIndex: toIndex\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\n\t\treturn editor;\n\t}\n\n\tsetActive(candidate: EditorInput | undefined): EditorInput | undefined {\n\t\tlet result: EditorInput | undefined;\n\n\t\tif (!candidate) {\n\t\t\tthis.setGroupActive();\n\t\t} else {\n\t\t\tresult = this.setEditorActive(candidate);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate setGroupActive(): void {\n\t\t// We do not really keep the `active` state in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_ACTIVE });\n\t}\n\n\tprivate setEditorActive(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doSetSelection(editor, editorIndex, []);\n\n\t\treturn editor;\n\t}\n\n\tget selectedEditors(): EditorInput[] {\n\t\treturn this.editors.filter(editor => this.doIsSelected(editor)); // return in sequential order\n\t}\n\n\tisSelected(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tlet editor: EditorInput | undefined;\n\t\tif (typeof editorCandidateOrIndex === 'number') {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = this.findEditor(editorCandidateOrIndex)?.[0];\n\t\t}\n\n\t\treturn !!editor && this.doIsSelected(editor);\n\t}\n\n\tprivate doIsSelected(editor: EditorInput): boolean {\n\t\treturn this.selection.includes(editor);\n\t}\n\n\tsetSelection(activeSelectedEditorCandidate: EditorInput, inactiveSelectedEditorCandidates: EditorInput[]): void {\n\t\tconst res = this.findEditor(activeSelectedEditorCandidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [activeSelectedEditor, activeSelectedEditorIndex] = res;\n\n\t\tconst inactiveSelectedEditors = new Set<EditorInput>();\n\t\tfor (const inactiveSelectedEditorCandidate of inactiveSelectedEditorCandidates) {\n\t\t\tconst res = this.findEditor(inactiveSelectedEditorCandidate);\n\t\t\tif (!res) {\n\t\t\t\treturn; // not found\n\t\t\t}\n\n\t\t\tconst [inactiveSelectedEditor] = res;\n\t\t\tif (inactiveSelectedEditor === activeSelectedEditor) {\n\t\t\t\tcontinue; // already selected\n\t\t\t}\n\n\t\t\tinactiveSelectedEditors.add(inactiveSelectedEditor);\n\t\t}\n\n\t\tthis.doSetSelection(activeSelectedEditor, activeSelectedEditorIndex, Array.from(inactiveSelectedEditors));\n\t}\n\n\tprivate doSetSelection(activeSelectedEditor: EditorInput | null, activeSelectedEditorIndex: number | undefined, inactiveSelectedEditors: EditorInput[]): void {\n\t\tconst previousActiveEditor = this.activeEditor;\n\t\tconst previousSelection = this.selection;\n\n\t\tlet newSelection: EditorInput[];\n\t\tif (activeSelectedEditor) {\n\t\t\tnewSelection = [activeSelectedEditor, ...inactiveSelectedEditors];\n\t\t} else {\n\t\t\tnewSelection = [];\n\t\t}\n\n\t\t// Update selection\n\t\tthis.selection = newSelection;\n\n\t\t// Update active editor if it has changed\n\t\tconst activeEditorChanged = activeSelectedEditor && typeof activeSelectedEditorIndex === 'number' && previousActiveEditor !== activeSelectedEditor;\n\t\tif (activeEditorChanged) {\n\n\t\t\t// Bring to front in MRU list\n\t\t\tconst mruIndex = this.indexOf(activeSelectedEditor, this.mru);\n\t\t\tthis.mru.splice(mruIndex, 1);\n\t\t\tthis.mru.unshift(activeSelectedEditor);\n\n\t\t\t// Event\n\t\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITOR_ACTIVE,\n\t\t\t\teditor: activeSelectedEditor,\n\t\t\t\teditorIndex: activeSelectedEditorIndex\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\n\t\t// Fire event if the selection has changed\n\t\tif (\n\t\t\tactiveEditorChanged ||\n\t\t\tpreviousSelection.length !== newSelection.length ||\n\t\t\tpreviousSelection.some(editor => !newSelection.includes(editor))\n\t\t) {\n\t\t\tconst event: IGroupModelChangeEvent = {\n\t\t\t\tkind: GroupModelChangeKind.EDITORS_SELECTION\n\t\t\t};\n\t\t\tthis._onDidModelChange.fire(event);\n\t\t}\n\t}\n\n\tsetIndex(index: number) {\n\t\t// We do not really keep the `index` in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_INDEX });\n\t}\n\n\tsetLabel(label: string) {\n\t\t// We do not really keep the `label` in our model because\n\t\t// it has no special meaning to us here. But for consistency\n\t\t// we emit a `onDidModelChange` event so that components can\n\t\t// react.\n\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_LABEL });\n\t}\n\n\tpin(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doPin(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doPin(editor: EditorInput, editorIndex: number): void {\n\t\tif (this.isPinned(editor)) {\n\t\t\treturn; // can only pin a preview editor\n\t\t}\n\n\t\t// Clear Transient\n\t\tthis.setTransient(editor, false);\n\n\t\t// Convert the preview editor to be a pinned editor\n\t\tthis.preview = null;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_PIN,\n\t\t\teditor,\n\t\t\teditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tunpin(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doUnpin(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doUnpin(editor: EditorInput, editorIndex: number): void {\n\t\tif (!this.isPinned(editor)) {\n\t\t\treturn; // can only unpin a pinned editor\n\t\t}\n\n\t\t// Set new\n\t\tconst oldPreview = this.preview;\n\t\tthis.preview = editor;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_PIN,\n\t\t\teditor,\n\t\t\teditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\n\t\t// Close old preview editor if any\n\t\tif (oldPreview) {\n\t\t\tthis.closeEditor(oldPreview, EditorCloseContext.UNPIN);\n\t\t}\n\t}\n\n\tisPinned(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tlet editor: EditorInput;\n\t\tif (typeof editorCandidateOrIndex === 'number') {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = editorCandidateOrIndex;\n\t\t}\n\n\t\treturn !this.matches(this.preview, editor);\n\t}\n\n\tstick(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doStick(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doStick(editor: EditorInput, editorIndex: number): void {\n\t\tif (this.isSticky(editorIndex)) {\n\t\t\treturn; // can only stick a non-sticky editor\n\t\t}\n\n\t\t// Pin editor\n\t\tthis.pin(editor);\n\n\t\t// Move editor to be the last sticky editor\n\t\tconst newEditorIndex = this.sticky + 1;\n\t\tthis.moveEditor(editor, newEditorIndex);\n\n\t\t// Adjust sticky index\n\t\tthis.sticky++;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\teditor,\n\t\t\teditorIndex: newEditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tunstick(candidate: EditorInput): EditorInput | undefined {\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doUnstick(editor, editorIndex);\n\n\t\treturn editor;\n\t}\n\n\tprivate doUnstick(editor: EditorInput, editorIndex: number): void {\n\t\tif (!this.isSticky(editorIndex)) {\n\t\t\treturn; // can only unstick a sticky editor\n\t\t}\n\n\t\t// Move editor to be the first non-sticky editor\n\t\tconst newEditorIndex = this.sticky;\n\t\tthis.moveEditor(editor, newEditorIndex);\n\n\t\t// Adjust sticky index\n\t\tthis.sticky--;\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_STICKY,\n\t\t\teditor,\n\t\t\teditorIndex: newEditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tisSticky(candidateOrIndex: EditorInput | number): boolean {\n\t\tif (this.sticky < 0) {\n\t\t\treturn false; // no sticky editor\n\t\t}\n\n\t\tlet index: number;\n\t\tif (typeof candidateOrIndex === 'number') {\n\t\t\tindex = candidateOrIndex;\n\t\t} else {\n\t\t\tindex = this.indexOf(candidateOrIndex);\n\t\t}\n\n\t\tif (index < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn index <= this.sticky;\n\t}\n\n\tsetTransient(candidate: EditorInput, transient: boolean): EditorInput | undefined {\n\t\tif (!transient && this.transient.size === 0) {\n\t\t\treturn; // no transient editor\n\t\t}\n\n\t\tconst res = this.findEditor(candidate);\n\t\tif (!res) {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tconst [editor, editorIndex] = res;\n\n\t\tthis.doSetTransient(editor, editorIndex, transient);\n\n\t\treturn editor;\n\t}\n\n\tprivate doSetTransient(editor: EditorInput, editorIndex: number, transient: boolean): void {\n\t\tif (transient) {\n\t\t\tif (this.transient.has(editor)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.transient.add(editor);\n\t\t} else {\n\t\t\tif (!this.transient.has(editor)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.transient.delete(editor);\n\t\t}\n\n\t\t// Event\n\t\tconst event: IGroupEditorChangeEvent = {\n\t\t\tkind: GroupModelChangeKind.EDITOR_TRANSIENT,\n\t\t\teditor,\n\t\t\teditorIndex\n\t\t};\n\t\tthis._onDidModelChange.fire(event);\n\t}\n\n\tisTransient(editorCandidateOrIndex: EditorInput | number): boolean {\n\t\tif (this.transient.size === 0) {\n\t\t\treturn false; // no transient editor\n\t\t}\n\n\t\tlet editor: EditorInput | undefined;\n\t\tif (typeof editorCandidateOrIndex === 'number') {\n\t\t\teditor = this.editors[editorCandidateOrIndex];\n\t\t} else {\n\t\t\teditor = this.findEditor(editorCandidateOrIndex)?.[0];\n\t\t}\n\n\t\treturn !!editor && this.transient.has(editor);\n\t}\n\n\tprivate splice(index: number, del: boolean, editor?: EditorInput): void {\n\t\tconst editorToDeleteOrReplace = this.editors[index];\n\n\t\t// Perform on sticky index\n\t\tif (del && this.isSticky(index)) {\n\t\t\tthis.sticky--;\n\t\t}\n\n\t\t// Perform on editors array\n\t\tif (editor) {\n\t\t\tthis.editors.splice(index, del ? 1 : 0, editor);\n\t\t} else {\n\t\t\tthis.editors.splice(index, del ? 1 : 0);\n\t\t}\n\n\t\t// Perform on MRU\n\t\t{\n\t\t\t// Add\n\t\t\tif (!del && editor) {\n\t\t\t\tif (this.mru.length === 0) {\n\t\t\t\t\t// the list of most recent editors is empty\n\t\t\t\t\t// so this editor can only be the most recent\n\t\t\t\t\tthis.mru.push(editor);\n\t\t\t\t} else {\n\t\t\t\t\t// we have most recent editors. as such we\n\t\t\t\t\t// put this newly opened editor right after\n\t\t\t\t\t// the current most recent one because it cannot\n\t\t\t\t\t// be the most recently active one unless\n\t\t\t\t\t// it becomes active. but it is still more\n\t\t\t\t\t// active then any other editor in the list.\n\t\t\t\t\tthis.mru.splice(1, 0, editor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove / Replace\n\t\t\telse {\n\t\t\t\tconst indexInMRU = this.indexOf(editorToDeleteOrReplace, this.mru);\n\n\t\t\t\t// Remove\n\t\t\t\tif (del && !editor) {\n\t\t\t\t\tthis.mru.splice(indexInMRU, 1); // remove from MRU\n\t\t\t\t}\n\n\t\t\t\t// Replace\n\t\t\t\telse if (del && editor) {\n\t\t\t\t\tthis.mru.splice(indexInMRU, 1, editor); // replace MRU at location\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tindexOf(candidate: EditorInput | IUntypedEditorInput | null, editors = this.editors, options?: IMatchEditorOptions): number {\n\t\tlet index = -1;\n\t\tif (!candidate) {\n\t\t\treturn index;\n\t\t}\n\n\t\tfor (let i = 0; i < editors.length; i++) {\n\t\t\tconst editor = editors[i];\n\n\t\t\tif (this.matches(editor, candidate, options)) {\n\t\t\t\t// If we are to support side by side matching, it is possible that\n\t\t\t\t// a better direct match is found later. As such, we continue finding\n\t\t\t\t// a matching editor and prefer that match over the side by side one.\n\t\t\t\tif (options?.supportSideBySide && editor instanceof SideBySideEditorInput && !(candidate instanceof SideBySideEditorInput)) {\n\t\t\t\t\tindex = i;\n\t\t\t\t} else {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfindEditor(candidate: EditorInput | null, options?: IMatchEditorOptions): [EditorInput, number /* index */] | undefined {\n\t\tconst index = this.indexOf(candidate, this.editors, options);\n\t\tif (index === -1) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn [this.editors[index], index];\n\t}\n\n\tisFirst(candidate: EditorInput | null, editors = this.editors): boolean {\n\t\treturn this.matches(editors[0], candidate);\n\t}\n\n\tisLast(candidate: EditorInput | null, editors = this.editors): boolean {\n\t\treturn this.matches(editors[editors.length - 1], candidate);\n\t}\n\n\tcontains(candidate: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean {\n\t\treturn this.indexOf(candidate, this.editors, options) !== -1;\n\t}\n\n\tprivate matches(editor: EditorInput | null | undefined, candidate: EditorInput | IUntypedEditorInput | null, options?: IMatchEditorOptions): boolean {\n\t\tif (!editor || !candidate) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (options?.supportSideBySide && editor instanceof SideBySideEditorInput && !(candidate instanceof SideBySideEditorInput)) {\n\t\t\tswitch (options.supportSideBySide) {\n\t\t\t\tcase SideBySideEditor.ANY:\n\t\t\t\t\tif (this.matches(editor.primary, candidate, options) || this.matches(editor.secondary, candidate, options)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SideBySideEditor.BOTH:\n\t\t\t\t\tif (this.matches(editor.primary, candidate, options) && this.matches(editor.secondary, candidate, options)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst strictEquals = editor === candidate;\n\n\t\tif (options?.strictEquals) {\n\t\t\treturn strictEquals;\n\t\t}\n\n\t\treturn strictEquals || editor.matches(candidate);\n\t}\n\n\tget isLocked(): boolean {\n\t\treturn this.locked;\n\t}\n\n\tlock(locked: boolean): void {\n\t\tif (this.isLocked !== locked) {\n\t\t\tthis.locked = locked;\n\n\t\t\tthis._onDidModelChange.fire({ kind: GroupModelChangeKind.GROUP_LOCKED });\n\t\t}\n\t}\n\n\tclone(): EditorGroupModel {\n\t\tconst clone = this.instantiationService.createInstance(EditorGroupModel, undefined);\n\n\t\t// Copy over group properties\n\t\tclone.editors = this.editors.slice(0);\n\t\tclone.mru = this.mru.slice(0);\n\t\tclone.preview = this.preview;\n\t\tclone.selection = this.selection.slice(0);\n\t\tclone.sticky = this.sticky;\n\n\t\t// Ensure to register listeners for each editor\n\t\tfor (const editor of clone.editors) {\n\t\t\tclone.registerEditorListeners(editor);\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\tserialize(): ISerializedEditorGroupModel {\n\t\tconst registry = Registry.as<IEditorFactoryRegistry>(EditorExtensions.EditorFactory);\n\n\t\t// Serialize all editor inputs so that we can store them.\n\t\t// Editors that cannot be serialized need to be ignored\n\t\t// from mru, active, preview and sticky if any.\n\t\tconst serializableEditors: EditorInput[] = [];\n\t\tconst serializedEditors: ISerializedEditorInput[] = [];\n\t\tlet serializablePreviewIndex: number | undefined;\n\t\tlet serializableSticky = this.sticky;\n\n\t\tfor (let i = 0; i < this.editors.length; i++) {\n\t\t\tconst editor = this.editors[i];\n\t\t\tlet canSerializeEditor = false;\n\n\t\t\tconst editorSerializer = registry.getEditorSerializer(editor);\n\t\t\tif (editorSerializer) {\n\t\t\t\tconst value = editorSerializer.canSerialize(editor) ? editorSerializer.serialize(editor) : undefined;\n\n\t\t\t\t// Editor can be serialized\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tcanSerializeEditor = true;\n\n\t\t\t\t\tserializedEditors.push({ id: editor.typeId, value });\n\t\t\t\t\tserializableEditors.push(editor);\n\n\t\t\t\t\tif (this.preview === editor) {\n\t\t\t\t\t\tserializablePreviewIndex = serializableEditors.length - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Editor cannot be serialized\n\t\t\t\telse {\n\t\t\t\t\tcanSerializeEditor = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adjust index of sticky editors if the editor cannot be serialized and is pinned\n\t\t\tif (!canSerializeEditor && this.isSticky(i)) {\n\t\t\t\tserializableSticky--;\n\t\t\t}\n\t\t}\n\n\t\tconst serializableMru = this.mru.map(editor => this.indexOf(editor, serializableEditors)).filter(i => i >= 0);\n\n\t\treturn {\n\t\t\tid: this.id,\n\t\t\tlocked: this.locked ? true : undefined,\n\t\t\teditors: serializedEditors,\n\t\t\tmru: serializableMru,\n\t\t\tpreview: serializablePreviewIndex,\n\t\t\tsticky: serializableSticky >= 0 ? serializableSticky : undefined\n\t\t};\n\t}\n\n\tprivate deserialize(data: ISerializedEditorGroupModel): number {\n\t\tconst registry = Registry.as<IEditorFactoryRegistry>(EditorExtensions.EditorFactory);\n\n\t\tif (typeof data.id === 'number') {\n\t\t\tthis._id = data.id;\n\n\t\t\tEditorGroupModel.IDS = Math.max(data.id + 1, EditorGroupModel.IDS); // make sure our ID generator is always larger\n\t\t} else {\n\t\t\tthis._id = EditorGroupModel.IDS++; // backwards compatibility\n\t\t}\n\n\t\tif (data.locked) {\n\t\t\tthis.locked = true;\n\t\t}\n\n\t\tthis.editors = coalesce(data.editors.map((e, index) => {\n\t\t\tlet editor: EditorInput | undefined;\n\n\t\t\tconst editorSerializer = registry.getEditorSerializer(e.id);\n\t\t\tif (editorSerializer) {\n\t\t\t\tconst deserializedEditor = editorSerializer.deserialize(this.instantiationService, e.value);\n\t\t\t\tif (deserializedEditor instanceof EditorInput) {\n\t\t\t\t\teditor = deserializedEditor;\n\t\t\t\t\tthis.registerEditorListeners(editor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!editor && typeof data.sticky === 'number' && index <= data.sticky) {\n\t\t\t\tdata.sticky--; // if editor cannot be deserialized but was sticky, we need to decrease sticky index\n\t\t\t}\n\n\t\t\treturn editor;\n\t\t}));\n\n\t\tthis.mru = coalesce(data.mru.map(i => this.editors[i]));\n\n\t\tthis.selection = this.mru.length > 0 ? [this.mru[0]] : [];\n\n\t\tif (typeof data.preview === 'number') {\n\t\t\tthis.preview = this.editors[data.preview];\n\t\t}\n\n\t\tif (typeof data.sticky === 'number') {\n\t\t\tthis.sticky = data.sticky;\n\t\t}\n\n\t\treturn this._id;\n\t}\n\n\toverride dispose(): void {\n\t\tdispose(Array.from(this.editorListeners));\n\t\tthis.editorListeners.clear();\n\n\t\tthis.transient.clear();\n\n\t\tsuper.dispose();\n\t}\n}\n"]}