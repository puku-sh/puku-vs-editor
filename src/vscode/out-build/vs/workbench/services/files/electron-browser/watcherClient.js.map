{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/files/electron-browser/watcherClient.ts","vs/workbench/services/files/electron-browser/watcherClient.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAGhG,OAAO,EAAE,iBAAiB,EAAE,YAAY,EAAE,MAAM,0CAA0C,CAAC;AAE3F,OAAO,EAAE,8BAA8B,EAAkC,MAAM,8CAA8C,CAAC;AAG9H,MAAM,OAAO,sBAAuB,SAAQ,8BAA8B;IAEzE,YACC,aAA+C,EAC/C,YAAwC,EACxC,cAAuB,EACN,oCAA2E;QAE5F,KAAK,CAAC,aAAa,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;QAFlC,yCAAoC,GAApC,oCAAoC,CAAuC;QAI5F,IAAI,CAAC,IAAI,EAAE,CAAC;IACb,CAAC;IAEkB,aAAa,CAAC,WAA4B;QAC5D,MAAM,OAAO,GAAG,YAAY,CAAC,SAAS,CAAoB,iBAAiB,CAAC,CAAC,KAAK,IAAI,EAAE;YAEvF,uDAAuD;YACvD,EAAE;YACF,sDAAsD;YACtD,wDAAwD;YACxD,mCAAmC;YACnC,EAAE;YACF,2DAA2D;YAC3D,+DAA+D;YAC/D,MAAM,EAAE,MAAM,EAAE,cAAc,EAAE,GAAG,WAAW,CAAC,GAAG,CAAC,MAAM,IAAI,CAAC,oCAAoC,CAAC,YAAY,CAAC;gBAC/G,QAAQ,EAAE,4CAA4C;gBACtD,IAAI,EAAE,aAAa;gBACnB,IAAI,EAAE,cAAc;aACpB,CAAC,CAAC,CAAC;YAEJ,yDAAyD;YACzD,wDAAwD;YACxD,wDAAwD;YAExD,cAAc,CAAC,IAAI,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE;gBAClC,IAAI,MAAM,EAAE,IAAI,KAAK,CAAC,EAAE,CAAC;oBACxB,IAAI,CAAC,KAAK,CAAC,kCAAkC,MAAM,CAAC,IAAI,aAAa,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;gBACvF,CAAC;qBAAM,CAAC;oBACP,IAAI,CAAC,OAAO,CAAC,+CAA+C,MAAM,EAAE,IAAI,aAAa,MAAM,EAAE,MAAM,UAAU,CAAC,CAAC;gBAChH,CAAC;YACF,CAAC,CAAC,CAAC;YAEH,OAAO,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QACrC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAEP,OAAO,OAAO,CAAC;IAChB,CAAC;CACD","file":"watcherClient.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { getDelayedChannel, ProxyChannel } from '../../../../base/parts/ipc/common/ipc.js';\nimport { IFileChange } from '../../../../platform/files/common/files.js';\nimport { AbstractUniversalWatcherClient, ILogMessage, IRecursiveWatcher } from '../../../../platform/files/common/watcher.js';\nimport { IUtilityProcessWorkerWorkbenchService } from '../../utilityProcess/electron-browser/utilityProcessWorkerWorkbenchService.js';\n\nexport class UniversalWatcherClient extends AbstractUniversalWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean,\n\t\tprivate readonly utilityProcessWorkerWorkbenchService: IUtilityProcessWorkerWorkbenchService\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging);\n\n\t\tthis.init();\n\t}\n\n\tprotected override createWatcher(disposables: DisposableStore): IRecursiveWatcher {\n\t\tconst watcher = ProxyChannel.toService<IRecursiveWatcher>(getDelayedChannel((async () => {\n\n\t\t\t// Acquire universal watcher via utility process worker\n\t\t\t//\n\t\t\t// We explicitly do not add the worker as a disposable\n\t\t\t// because we need to call `stop` on disposal to prevent\n\t\t\t// a crash on shutdown (see below).\n\t\t\t//\n\t\t\t// The utility process worker services ensures to terminate\n\t\t\t// the process automatically when the window closes or reloads.\n\t\t\tconst { client, onDidTerminate } = disposables.add(await this.utilityProcessWorkerWorkbenchService.createWorker({\n\t\t\t\tmoduleId: 'vs/platform/files/node/watcher/watcherMain',\n\t\t\t\ttype: 'fileWatcher',\n\t\t\t\tname: 'file-watcher'\n\t\t\t}));\n\n\t\t\t// React on unexpected termination of the watcher process\n\t\t\t// by listening to the `onDidTerminate` event. We do not\n\t\t\t// consider an exit code of `0` as abnormal termination.\n\n\t\t\tonDidTerminate.then(({ reason }) => {\n\t\t\t\tif (reason?.code === 0) {\n\t\t\t\t\tthis.trace(`terminated by itself with code ${reason.code}, signal: ${reason.signal}`);\n\t\t\t\t} else {\n\t\t\t\t\tthis.onError(`terminated by itself unexpectedly with code ${reason?.code}, signal: ${reason?.signal} (ETERM)`);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn client.getChannel('watcher');\n\t\t})()));\n\n\t\treturn watcher;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { getDelayedChannel, ProxyChannel } from '../../../../base/parts/ipc/common/ipc.js';\nimport { IFileChange } from '../../../../platform/files/common/files.js';\nimport { AbstractUniversalWatcherClient, ILogMessage, IRecursiveWatcher } from '../../../../platform/files/common/watcher.js';\nimport { IUtilityProcessWorkerWorkbenchService } from '../../utilityProcess/electron-browser/utilityProcessWorkerWorkbenchService.js';\n\nexport class UniversalWatcherClient extends AbstractUniversalWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean,\n\t\tprivate readonly utilityProcessWorkerWorkbenchService: IUtilityProcessWorkerWorkbenchService\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging);\n\n\t\tthis.init();\n\t}\n\n\tprotected override createWatcher(disposables: DisposableStore): IRecursiveWatcher {\n\t\tconst watcher = ProxyChannel.toService<IRecursiveWatcher>(getDelayedChannel((async () => {\n\n\t\t\t// Acquire universal watcher via utility process worker\n\t\t\t//\n\t\t\t// We explicitly do not add the worker as a disposable\n\t\t\t// because we need to call `stop` on disposal to prevent\n\t\t\t// a crash on shutdown (see below).\n\t\t\t//\n\t\t\t// The utility process worker services ensures to terminate\n\t\t\t// the process automatically when the window closes or reloads.\n\t\t\tconst { client, onDidTerminate } = disposables.add(await this.utilityProcessWorkerWorkbenchService.createWorker({\n\t\t\t\tmoduleId: 'vs/platform/files/node/watcher/watcherMain',\n\t\t\t\ttype: 'fileWatcher',\n\t\t\t\tname: 'file-watcher'\n\t\t\t}));\n\n\t\t\t// React on unexpected termination of the watcher process\n\t\t\t// by listening to the `onDidTerminate` event. We do not\n\t\t\t// consider an exit code of `0` as abnormal termination.\n\n\t\t\tonDidTerminate.then(({ reason }) => {\n\t\t\t\tif (reason?.code === 0) {\n\t\t\t\t\tthis.trace(`terminated by itself with code ${reason.code}, signal: ${reason.signal}`);\n\t\t\t\t} else {\n\t\t\t\t\tthis.onError(`terminated by itself unexpectedly with code ${reason?.code}, signal: ${reason?.signal} (ETERM)`);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn client.getChannel('watcher');\n\t\t})()));\n\n\t\treturn watcher;\n\t}\n}\n"]}