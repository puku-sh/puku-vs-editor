{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/authentication/common/authentication.ts","vs/workbench/services/authentication/common/authentication.ts"],"names":[],"mappings":"AAQA,OAAO,EAAE,eAAe,EAAE,MAAM,4DAA4D,CAAC;AAE7F;;GAEG;AACH,MAAM,CAAC,MAAM,6BAA6B,GAAG,IAAI,CAAC;AAkElD,MAAM,UAAU,sCAAsC,CAAC,GAAY;IAClE,OAAO,OAAO,GAAG,KAAK,QAAQ;WAC1B,GAAG,KAAK,IAAI;WACZ,iBAAiB,IAAI,GAAG;WACxB,CAAC,OAAO,GAAG,CAAC,eAAe,KAAK,QAAQ,CAAC,CAAC;AAC/C,CAAC;AA+DD,MAAM,CAAC,MAAM,sBAAsB,GAAG,eAAe,CAAyB,wBAAwB,CAAC,CAAC;AAiIxG,MAAM,UAAU,uBAAuB,CAAC,KAAc;IACrD,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,KAAK,EAAE,CAAC;QACzC,OAAO,KAAK,CAAC;IACd,CAAC;IACD,MAAM,KAAK,GAAG,KAA8B,CAAC;IAC7C,IAAI,OAAO,KAAK,CAAC,EAAE,KAAK,QAAQ,EAAE,CAAC;QAClC,OAAO,KAAK,CAAC;IACd,CAAC;IACD,IAAI,OAAO,KAAK,CAAC,WAAW,KAAK,QAAQ,EAAE,CAAC;QAC3C,OAAO,KAAK,CAAC;IACd,CAAC;IACD,IAAI,OAAO,KAAK,CAAC,OAAO,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;QACzD,OAAO,KAAK,CAAC;IACd,CAAC;IACD,IAAI,OAAO,KAAK,CAAC,OAAO,CAAC,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC7C,OAAO,KAAK,CAAC;IACd,CAAC;IACD,IAAI,OAAO,KAAK,CAAC,OAAO,CAAC,EAAE,KAAK,QAAQ,EAAE,CAAC;QAC1C,OAAO,KAAK,CAAC;IACd,CAAC;IACD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC;QAClC,OAAO,KAAK,CAAC;IACd,CAAC;IACD,IAAI,KAAK,CAAC,OAAO,IAAI,OAAO,KAAK,CAAC,OAAO,KAAK,QAAQ,EAAE,CAAC;QACxD,OAAO,KAAK,CAAC;IACd,CAAC;IACD,OAAO,IAAI,CAAC;AACb,CAAC;AAED,gDAAgD;AAChD,MAAM,CAAC,MAAM,gCAAgC,GAAG,eAAe,CAAmC,kCAAkC,CAAC,CAAC","file":"authentication.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { IAuthenticationChallenge, IAuthorizationProtectedResourceMetadata, IAuthorizationServerMetadata } from '../../../../base/common/oauth.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\n\n/**\n * Use this if you don't want the onDidChangeSessions event to fire in the extension host\n */\nexport const INTERNAL_AUTH_PROVIDER_PREFIX = '__';\n\nexport interface AuthenticationSessionAccount {\n\tlabel: string;\n\tid: string;\n}\n\nexport interface AuthenticationSession {\n\tid: string;\n\taccessToken: string;\n\taccount: AuthenticationSessionAccount;\n\tscopes: ReadonlyArray<string>;\n\tidToken?: string;\n}\n\nexport interface AuthenticationSessionsChangeEvent {\n\tadded: ReadonlyArray<AuthenticationSession> | undefined;\n\tremoved: ReadonlyArray<AuthenticationSession> | undefined;\n\tchanged: ReadonlyArray<AuthenticationSession> | undefined;\n}\n\nexport interface AuthenticationProviderInformation {\n\tid: string;\n\tlabel: string;\n\tauthorizationServerGlobs?: ReadonlyArray<string>;\n}\n\n/**\n * Options for creating an authentication session via the service.\n */\nexport interface IAuthenticationCreateSessionOptions {\n\tactivateImmediate?: boolean;\n\t/**\n\t * The account that is being asked about. If this is passed in, the provider should\n\t * attempt to return the sessions that are only related to this account.\n\t */\n\taccount?: AuthenticationSessionAccount;\n\t/**\n\t * The authorization server URI to use for this creation request. If passed in, first we validate that\n\t * the provider can use this authorization server, then it is passed down to the auth provider.\n\t */\n\tauthorizationServer?: URI;\n\t/**\n\t * Allows the authentication provider to take in additional parameters.\n\t * It is up to the provider to define what these parameters are and handle them.\n\t * This is useful for passing in additional information that is specific to the provider\n\t * and not part of the standard authentication flow.\n\t */\n\t[key: string]: any;\n}\n\nexport interface IAuthenticationWwwAuthenticateRequest {\n\t/**\n\t * The raw WWW-Authenticate header value that triggered this challenge.\n\t * This will be parsed by the authentication provider to extract the necessary\n\t * challenge information.\n\t */\n\treadonly wwwAuthenticate: string;\n\n\t/**\n\t * Optional scopes for the session. If not provided, the authentication provider\n\t * may use default scopes or extract them from the challenge.\n\t */\n\treadonly fallbackScopes?: readonly string[];\n}\n\nexport function isAuthenticationWwwAuthenticateRequest(obj: unknown): obj is IAuthenticationWwwAuthenticateRequest {\n\treturn typeof obj === 'object'\n\t\t&& obj !== null\n\t\t&& 'wwwAuthenticate' in obj\n\t\t&& (typeof obj.wwwAuthenticate === 'string');\n}\n\n/**\n * Represents constraints for authentication, including challenges and optional scopes.\n * This is used when creating or retrieving sessions that must satisfy specific authentication\n * requirements from WWW-Authenticate headers.\n */\nexport interface IAuthenticationConstraint {\n\t/**\n\t * Array of authentication challenges parsed from WWW-Authenticate headers.\n\t */\n\treadonly challenges: readonly IAuthenticationChallenge[];\n\n\t/**\n\t * Optional scopes for the session. If not provided, the authentication provider\n\t * may extract scopes from the challenges or use default scopes.\n\t */\n\treadonly fallbackScopes?: readonly string[];\n}\n\n/**\n * Options for getting authentication sessions via the service.\n */\nexport interface IAuthenticationGetSessionsOptions {\n\t/**\n\t * The account that is being asked about. If this is passed in, the provider should\n\t * attempt to return the sessions that are only related to this account.\n\t */\n\taccount?: AuthenticationSessionAccount;\n\t/**\n\t * The authorization server URI to use for this request. If passed in, first we validate that\n\t * the provider can use this authorization server, then it is passed down to the auth provider.\n\t */\n\tauthorizationServer?: URI;\n\t/**\n\t * Allows the authentication provider to take in additional parameters.\n\t * It is up to the provider to define what these parameters are and handle them.\n\t * This is useful for passing in additional information that is specific to the provider\n\t * and not part of the standard authentication flow.\n\t */\n\t[key: string]: any;\n}\n\nexport interface AllowedExtension {\n\tid: string;\n\tname: string;\n\t/**\n\t * If true or undefined, the extension is allowed to use the account\n\t * If false, the extension is not allowed to use the account\n\t * TODO: undefined shouldn't be a valid value, but it is for now\n\t */\n\tallowed?: boolean;\n\tlastUsed?: number;\n\t// If true, this comes from the product.json\n\ttrusted?: boolean;\n}\n\nexport interface IAuthenticationProviderHostDelegate {\n\t/** Priority for this delegate, delegates are tested in descending priority order */\n\treadonly priority: number;\n\tcreate(authorizationServer: URI, serverMetadata: IAuthorizationServerMetadata, resource: IAuthorizationProtectedResourceMetadata | undefined): Promise<string>;\n}\n\nexport const IAuthenticationService = createDecorator<IAuthenticationService>('IAuthenticationService');\n\nexport interface IAuthenticationService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fires when an authentication provider has been registered\n\t */\n\treadonly onDidRegisterAuthenticationProvider: Event<AuthenticationProviderInformation>;\n\t/**\n\t * Fires when an authentication provider has been unregistered\n\t */\n\treadonly onDidUnregisterAuthenticationProvider: Event<AuthenticationProviderInformation>;\n\n\t/**\n\t * Fires when the list of sessions for a provider has been added, removed or changed\n\t */\n\treadonly onDidChangeSessions: Event<{ providerId: string; label: string; event: AuthenticationSessionsChangeEvent }>;\n\n\t/**\n\t * Fires when the list of declaredProviders has changed\n\t */\n\treadonly onDidChangeDeclaredProviders: Event<void>;\n\n\t/**\n\t * All providers that have been statically declared by extensions. These may not actually be registered or active yet.\n\t */\n\treadonly declaredProviders: AuthenticationProviderInformation[];\n\n\t/**\n\t * Registers that an extension has declared an authentication provider in their package.json\n\t * @param provider The provider information to register\n\t */\n\tregisterDeclaredAuthenticationProvider(provider: AuthenticationProviderInformation): void;\n\n\t/**\n\t * Unregisters a declared authentication provider\n\t * @param id The id of the provider to unregister\n\t */\n\tunregisterDeclaredAuthenticationProvider(id: string): void;\n\n\t/**\n\t * Checks if an authentication provider has been registered\n\t * @param id The id of the provider to check\n\t */\n\tisAuthenticationProviderRegistered(id: string): boolean;\n\n\t/**\n\t * Checks if an authentication provider is dynamic\n\t * @param id The id of the provider to check\n\t */\n\tisDynamicAuthenticationProvider(id: string): boolean;\n\n\t/**\n\t * Registers an authentication provider\n\t * @param id The id of the provider\n\t * @param provider The implementation of the provider\n\t */\n\tregisterAuthenticationProvider(id: string, provider: IAuthenticationProvider): void;\n\n\t/**\n\t * Unregisters an authentication provider\n\t * @param id The id of the provider to unregister\n\t */\n\tunregisterAuthenticationProvider(id: string): void;\n\n\t/**\n\t * Gets the provider ids of all registered authentication providers\n\t */\n\tgetProviderIds(): string[];\n\n\t/**\n\t * Gets the provider with the given id.\n\t * @param id The id of the provider to get\n\t * @throws if the provider is not registered\n\t */\n\tgetProvider(id: string): IAuthenticationProvider;\n\n\t/**\n\t * Gets all accounts that are currently logged in across all sessions\n\t * @param id The id of the provider to ask for accounts\n\t * @returns A promise that resolves to an array of accounts\n\t */\n\tgetAccounts(id: string): Promise<ReadonlyArray<AuthenticationSessionAccount>>;\n\n\t/**\n\t * Gets all sessions that satisfy the given scopes from the provider with the given id\n\t * @param id The id of the provider to ask for a session\n\t * @param scopes The scopes for the session\n\t * @param options Additional options for getting sessions\n\t * @param activateImmediate If true, the provider should activate immediately if it is not already\n\t */\n\tgetSessions(id: string, scopeListOrRequest?: ReadonlyArray<string> | IAuthenticationWwwAuthenticateRequest, options?: IAuthenticationGetSessionsOptions, activateImmediate?: boolean): Promise<ReadonlyArray<AuthenticationSession>>;\n\n\t/**\n\t * Creates an AuthenticationSession with the given provider and scopes\n\t * @param providerId The id of the provider\n\t * @param scopes The scopes to request\n\t * @param options Additional options for creating the session\n\t */\n\tcreateSession(providerId: string, scopeListOrRequest: ReadonlyArray<string> | IAuthenticationWwwAuthenticateRequest, options?: IAuthenticationCreateSessionOptions): Promise<AuthenticationSession>;\n\n\t/**\n\t * Removes the session with the given id from the provider with the given id\n\t * @param providerId The id of the provider\n\t * @param sessionId The id of the session to remove\n\t */\n\tremoveSession(providerId: string, sessionId: string): Promise<void>;\n\n\t/**\n\t * Gets a provider id for a specified authorization server\n\t * @param authorizationServer The authorization server url that this provider is responsible for\n\t * @param resourceServer The resource server URI that should match the provider's resourceServer (if defined)\n\t */\n\tgetOrActivateProviderIdForServer(authorizationServer: URI, resourceServer?: URI): Promise<string | undefined>;\n\n\t/**\n\t * Allows the ability register a delegate that will be used to start authentication providers\n\t * @param delegate The delegate to register\n\t */\n\tregisterAuthenticationProviderHostDelegate(delegate: IAuthenticationProviderHostDelegate): IDisposable;\n\n\t/**\n\t * Creates a dynamic authentication provider for the given server metadata\n\t * @param serverMetadata The metadata for the server that is being authenticated against\n\t */\n\tcreateDynamicAuthenticationProvider(authorizationServer: URI, serverMetadata: IAuthorizationServerMetadata, resourceMetadata: IAuthorizationProtectedResourceMetadata | undefined): Promise<IAuthenticationProvider | undefined>;\n}\n\nexport function isAuthenticationSession(thing: unknown): thing is AuthenticationSession {\n\tif (typeof thing !== 'object' || !thing) {\n\t\treturn false;\n\t}\n\tconst maybe = thing as AuthenticationSession;\n\tif (typeof maybe.id !== 'string') {\n\t\treturn false;\n\t}\n\tif (typeof maybe.accessToken !== 'string') {\n\t\treturn false;\n\t}\n\tif (typeof maybe.account !== 'object' || !maybe.account) {\n\t\treturn false;\n\t}\n\tif (typeof maybe.account.label !== 'string') {\n\t\treturn false;\n\t}\n\tif (typeof maybe.account.id !== 'string') {\n\t\treturn false;\n\t}\n\tif (!Array.isArray(maybe.scopes)) {\n\t\treturn false;\n\t}\n\tif (maybe.idToken && typeof maybe.idToken !== 'string') {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// TODO: Move this into MainThreadAuthentication\nexport const IAuthenticationExtensionsService = createDecorator<IAuthenticationExtensionsService>('IAuthenticationExtensionsService');\nexport interface IAuthenticationExtensionsService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fires when an account preference for a specific provider has changed for the specified extensions. Does not fire when:\n\t * * An account preference is removed\n\t * * A session preference is changed (because it's deprecated)\n\t * * A session preference is removed (because it's deprecated)\n\t */\n\treadonly onDidChangeAccountPreference: Event<{ extensionIds: string[]; providerId: string }>;\n\t/**\n\t * Returns the accountName (also known as account.label) to pair with `IAuthenticationAccessService` to get the account preference\n\t * @param providerId The authentication provider id\n\t * @param extensionId The extension id to get the preference for\n\t * @returns The accountName of the preference, or undefined if there is no preference set\n\t */\n\tgetAccountPreference(extensionId: string, providerId: string): string | undefined;\n\t/**\n\t * Sets the account preference for the given provider and extension\n\t * @param providerId The authentication provider id\n\t * @param extensionId The extension id to set the preference for\n\t * @param account The account to set the preference to\n\t */\n\tupdateAccountPreference(extensionId: string, providerId: string, account: AuthenticationSessionAccount): void;\n\t/**\n\t * Removes the account preference for the given provider and extension\n\t * @param providerId The authentication provider id\n\t * @param extensionId The extension id to remove the preference for\n\t */\n\tremoveAccountPreference(extensionId: string, providerId: string): void;\n\t/**\n\t * @deprecated Sets the session preference for the given provider and extension\n\t * @param providerId\n\t * @param extensionId\n\t * @param session\n\t */\n\tupdateSessionPreference(providerId: string, extensionId: string, session: AuthenticationSession): void;\n\t/**\n\t * @deprecated Gets the session preference for the given provider and extension\n\t * @param providerId\n\t * @param extensionId\n\t * @param scopes\n\t */\n\tgetSessionPreference(providerId: string, extensionId: string, scopes: string[]): string | undefined;\n\t/**\n\t * @deprecated Removes the session preference for the given provider and extension\n\t * @param providerId\n\t * @param extensionId\n\t * @param scopes\n\t */\n\tremoveSessionPreference(providerId: string, extensionId: string, scopes: string[]): void;\n\tselectSession(providerId: string, extensionId: string, extensionName: string, scopeListOrRequest: ReadonlyArray<string> | IAuthenticationWwwAuthenticateRequest, possibleSessions: readonly AuthenticationSession[]): Promise<AuthenticationSession>;\n\trequestSessionAccess(providerId: string, extensionId: string, extensionName: string, scopeListOrRequest: ReadonlyArray<string> | IAuthenticationWwwAuthenticateRequest, possibleSessions: readonly AuthenticationSession[]): void;\n\trequestNewSession(providerId: string, scopeListOrRequest: ReadonlyArray<string> | IAuthenticationWwwAuthenticateRequest, extensionId: string, extensionName: string): Promise<void>;\n\tupdateNewSessionRequests(providerId: string, addedSessions: readonly AuthenticationSession[]): void;\n}\n\n/**\n * Options passed to the authentication provider when asking for sessions.\n */\nexport interface IAuthenticationProviderSessionOptions {\n\t/**\n\t * The account that is being asked about. If this is passed in, the provider should\n\t * attempt to return the sessions that are only related to this account.\n\t */\n\taccount?: AuthenticationSessionAccount;\n\t/**\n\t * The authorization server that is being asked about. If this is passed in, the provider should\n\t * attempt to return sessions that are only related to this authorization server.\n\t */\n\tauthorizationServer?: URI;\n\t/**\n\t * Allows the authentication provider to take in additional parameters.\n\t * It is up to the provider to define what these parameters are and handle them.\n\t * This is useful for passing in additional information that is specific to the provider\n\t * and not part of the standard authentication flow.\n\t */\n\t[key: string]: any;\n}\n\n/**\n * Represents an authentication provider.\n */\nexport interface IAuthenticationProvider {\n\t/**\n\t * The unique identifier of the authentication provider.\n\t */\n\treadonly id: string;\n\n\t/**\n\t * The display label of the authentication provider.\n\t */\n\treadonly label: string;\n\n\t/**\n\t * The resource server URI that this provider is responsible for, if any.\n\t * TODO@TylerLeonhardt: Rather than this being added to the provider, it should be passed in to\n\t * getSessions/createSession/etc... this way we can have providers that handle multiple resource servers.\n\t */\n\treadonly resourceServer?: URI;\n\n\t/**\n\t * The resolved authorization servers. These can still contain globs, but should be concrete URIs\n\t */\n\treadonly authorizationServers?: ReadonlyArray<URI>;\n\n\t/**\n\t * Indicates whether the authentication provider supports multiple accounts.\n\t */\n\treadonly supportsMultipleAccounts: boolean;\n\n\t/**\n\t * Optional function to provide a custom confirmation message for authentication prompts.\n\t * If not implemented, the default confirmation messages will be used.\n\t * @param extensionName - The name of the extension requesting authentication.\n\t * @param recreatingSession - Whether this is recreating an existing session.\n\t * @returns A custom confirmation message or undefined to use the default message.\n\t */\n\treadonly confirmation?: (extensionName: string, recreatingSession: boolean) => string | undefined;\n\n\t/**\n\t * An {@link Event} which fires when the array of sessions has changed, or data\n\t * within a session has changed.\n\t */\n\treadonly onDidChangeSessions: Event<AuthenticationSessionsChangeEvent>;\n\n\t/**\n\t * Retrieves a list of authentication sessions.\n\t * @param scopes - An optional list of scopes. If provided, the sessions returned should match these permissions, otherwise all sessions should be returned.\n\t * @param options - Additional options for getting sessions.\n\t * @returns A promise that resolves to an array of authentication sessions.\n\t */\n\tgetSessions(scopes: string[] | undefined, options: IAuthenticationProviderSessionOptions): Promise<readonly AuthenticationSession[]>;\n\n\t/**\n\t * Prompts the user to log in.\n\t * If login is successful, the `onDidChangeSessions` event should be fired.\n\t * If login fails, a rejected promise should be returned.\n\t * If the provider does not support multiple accounts, this method should not be called if there is already an existing session matching the provided scopes.\n\t * @param scopes - A list of scopes that the new session should be created with.\n\t * @param options - Additional options for creating the session.\n\t * @returns A promise that resolves to an authentication session.\n\t */\n\tcreateSession(scopes: string[], options: IAuthenticationProviderSessionOptions): Promise<AuthenticationSession>;\n\n\t/**\n\t * Get existing sessions that match the given authentication constraints.\n\t *\n\t * @param constraint The authentication constraint containing challenges and optional scopes\n\t * @param options Options for the session request\n\t * @returns A thenable that resolves to an array of existing authentication sessions\n\t */\n\tgetSessionsFromChallenges?(constraint: IAuthenticationConstraint, options: IAuthenticationProviderSessionOptions): Promise<readonly AuthenticationSession[]>;\n\n\t/**\n\t * Create a new session based on authentication constraints.\n\t * This is called when no existing session matches the constraint requirements.\n\t *\n\t * @param constraint The authentication constraint containing challenges and optional scopes\n\t * @param options Options for the session creation\n\t * @returns A thenable that resolves to a new authentication session\n\t */\n\tcreateSessionFromChallenges?(constraint: IAuthenticationConstraint, options: IAuthenticationProviderSessionOptions): Promise<AuthenticationSession>;\n\n\t/**\n\t * Removes the session corresponding to the specified session ID.\n\t * If the removal is successful, the `onDidChangeSessions` event should be fired.\n\t * If a session cannot be removed, the provider should reject with an error message.\n\t * @param sessionId - The ID of the session to remove.\n\t */\n\tremoveSession(sessionId: string): Promise<void>;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { IAuthenticationChallenge, IAuthorizationProtectedResourceMetadata, IAuthorizationServerMetadata } from '../../../../base/common/oauth.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\n\n/**\n * Use this if you don't want the onDidChangeSessions event to fire in the extension host\n */\nexport const INTERNAL_AUTH_PROVIDER_PREFIX = '__';\n\nexport interface AuthenticationSessionAccount {\n\tlabel: string;\n\tid: string;\n}\n\nexport interface AuthenticationSession {\n\tid: string;\n\taccessToken: string;\n\taccount: AuthenticationSessionAccount;\n\tscopes: ReadonlyArray<string>;\n\tidToken?: string;\n}\n\nexport interface AuthenticationSessionsChangeEvent {\n\tadded: ReadonlyArray<AuthenticationSession> | undefined;\n\tremoved: ReadonlyArray<AuthenticationSession> | undefined;\n\tchanged: ReadonlyArray<AuthenticationSession> | undefined;\n}\n\nexport interface AuthenticationProviderInformation {\n\tid: string;\n\tlabel: string;\n\tauthorizationServerGlobs?: ReadonlyArray<string>;\n}\n\n/**\n * Options for creating an authentication session via the service.\n */\nexport interface IAuthenticationCreateSessionOptions {\n\tactivateImmediate?: boolean;\n\t/**\n\t * The account that is being asked about. If this is passed in, the provider should\n\t * attempt to return the sessions that are only related to this account.\n\t */\n\taccount?: AuthenticationSessionAccount;\n\t/**\n\t * The authorization server URI to use for this creation request. If passed in, first we validate that\n\t * the provider can use this authorization server, then it is passed down to the auth provider.\n\t */\n\tauthorizationServer?: URI;\n\t/**\n\t * Allows the authentication provider to take in additional parameters.\n\t * It is up to the provider to define what these parameters are and handle them.\n\t * This is useful for passing in additional information that is specific to the provider\n\t * and not part of the standard authentication flow.\n\t */\n\t[key: string]: any;\n}\n\nexport interface IAuthenticationWwwAuthenticateRequest {\n\t/**\n\t * The raw WWW-Authenticate header value that triggered this challenge.\n\t * This will be parsed by the authentication provider to extract the necessary\n\t * challenge information.\n\t */\n\treadonly wwwAuthenticate: string;\n\n\t/**\n\t * Optional scopes for the session. If not provided, the authentication provider\n\t * may use default scopes or extract them from the challenge.\n\t */\n\treadonly fallbackScopes?: readonly string[];\n}\n\nexport function isAuthenticationWwwAuthenticateRequest(obj: unknown): obj is IAuthenticationWwwAuthenticateRequest {\n\treturn typeof obj === 'object'\n\t\t&& obj !== null\n\t\t&& 'wwwAuthenticate' in obj\n\t\t&& (typeof obj.wwwAuthenticate === 'string');\n}\n\n/**\n * Represents constraints for authentication, including challenges and optional scopes.\n * This is used when creating or retrieving sessions that must satisfy specific authentication\n * requirements from WWW-Authenticate headers.\n */\nexport interface IAuthenticationConstraint {\n\t/**\n\t * Array of authentication challenges parsed from WWW-Authenticate headers.\n\t */\n\treadonly challenges: readonly IAuthenticationChallenge[];\n\n\t/**\n\t * Optional scopes for the session. If not provided, the authentication provider\n\t * may extract scopes from the challenges or use default scopes.\n\t */\n\treadonly fallbackScopes?: readonly string[];\n}\n\n/**\n * Options for getting authentication sessions via the service.\n */\nexport interface IAuthenticationGetSessionsOptions {\n\t/**\n\t * The account that is being asked about. If this is passed in, the provider should\n\t * attempt to return the sessions that are only related to this account.\n\t */\n\taccount?: AuthenticationSessionAccount;\n\t/**\n\t * The authorization server URI to use for this request. If passed in, first we validate that\n\t * the provider can use this authorization server, then it is passed down to the auth provider.\n\t */\n\tauthorizationServer?: URI;\n\t/**\n\t * Allows the authentication provider to take in additional parameters.\n\t * It is up to the provider to define what these parameters are and handle them.\n\t * This is useful for passing in additional information that is specific to the provider\n\t * and not part of the standard authentication flow.\n\t */\n\t[key: string]: any;\n}\n\nexport interface AllowedExtension {\n\tid: string;\n\tname: string;\n\t/**\n\t * If true or undefined, the extension is allowed to use the account\n\t * If false, the extension is not allowed to use the account\n\t * TODO: undefined shouldn't be a valid value, but it is for now\n\t */\n\tallowed?: boolean;\n\tlastUsed?: number;\n\t// If true, this comes from the product.json\n\ttrusted?: boolean;\n}\n\nexport interface IAuthenticationProviderHostDelegate {\n\t/** Priority for this delegate, delegates are tested in descending priority order */\n\treadonly priority: number;\n\tcreate(authorizationServer: URI, serverMetadata: IAuthorizationServerMetadata, resource: IAuthorizationProtectedResourceMetadata | undefined): Promise<string>;\n}\n\nexport const IAuthenticationService = createDecorator<IAuthenticationService>('IAuthenticationService');\n\nexport interface IAuthenticationService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fires when an authentication provider has been registered\n\t */\n\treadonly onDidRegisterAuthenticationProvider: Event<AuthenticationProviderInformation>;\n\t/**\n\t * Fires when an authentication provider has been unregistered\n\t */\n\treadonly onDidUnregisterAuthenticationProvider: Event<AuthenticationProviderInformation>;\n\n\t/**\n\t * Fires when the list of sessions for a provider has been added, removed or changed\n\t */\n\treadonly onDidChangeSessions: Event<{ providerId: string; label: string; event: AuthenticationSessionsChangeEvent }>;\n\n\t/**\n\t * Fires when the list of declaredProviders has changed\n\t */\n\treadonly onDidChangeDeclaredProviders: Event<void>;\n\n\t/**\n\t * All providers that have been statically declared by extensions. These may not actually be registered or active yet.\n\t */\n\treadonly declaredProviders: AuthenticationProviderInformation[];\n\n\t/**\n\t * Registers that an extension has declared an authentication provider in their package.json\n\t * @param provider The provider information to register\n\t */\n\tregisterDeclaredAuthenticationProvider(provider: AuthenticationProviderInformation): void;\n\n\t/**\n\t * Unregisters a declared authentication provider\n\t * @param id The id of the provider to unregister\n\t */\n\tunregisterDeclaredAuthenticationProvider(id: string): void;\n\n\t/**\n\t * Checks if an authentication provider has been registered\n\t * @param id The id of the provider to check\n\t */\n\tisAuthenticationProviderRegistered(id: string): boolean;\n\n\t/**\n\t * Checks if an authentication provider is dynamic\n\t * @param id The id of the provider to check\n\t */\n\tisDynamicAuthenticationProvider(id: string): boolean;\n\n\t/**\n\t * Registers an authentication provider\n\t * @param id The id of the provider\n\t * @param provider The implementation of the provider\n\t */\n\tregisterAuthenticationProvider(id: string, provider: IAuthenticationProvider): void;\n\n\t/**\n\t * Unregisters an authentication provider\n\t * @param id The id of the provider to unregister\n\t */\n\tunregisterAuthenticationProvider(id: string): void;\n\n\t/**\n\t * Gets the provider ids of all registered authentication providers\n\t */\n\tgetProviderIds(): string[];\n\n\t/**\n\t * Gets the provider with the given id.\n\t * @param id The id of the provider to get\n\t * @throws if the provider is not registered\n\t */\n\tgetProvider(id: string): IAuthenticationProvider;\n\n\t/**\n\t * Gets all accounts that are currently logged in across all sessions\n\t * @param id The id of the provider to ask for accounts\n\t * @returns A promise that resolves to an array of accounts\n\t */\n\tgetAccounts(id: string): Promise<ReadonlyArray<AuthenticationSessionAccount>>;\n\n\t/**\n\t * Gets all sessions that satisfy the given scopes from the provider with the given id\n\t * @param id The id of the provider to ask for a session\n\t * @param scopes The scopes for the session\n\t * @param options Additional options for getting sessions\n\t * @param activateImmediate If true, the provider should activate immediately if it is not already\n\t */\n\tgetSessions(id: string, scopeListOrRequest?: ReadonlyArray<string> | IAuthenticationWwwAuthenticateRequest, options?: IAuthenticationGetSessionsOptions, activateImmediate?: boolean): Promise<ReadonlyArray<AuthenticationSession>>;\n\n\t/**\n\t * Creates an AuthenticationSession with the given provider and scopes\n\t * @param providerId The id of the provider\n\t * @param scopes The scopes to request\n\t * @param options Additional options for creating the session\n\t */\n\tcreateSession(providerId: string, scopeListOrRequest: ReadonlyArray<string> | IAuthenticationWwwAuthenticateRequest, options?: IAuthenticationCreateSessionOptions): Promise<AuthenticationSession>;\n\n\t/**\n\t * Removes the session with the given id from the provider with the given id\n\t * @param providerId The id of the provider\n\t * @param sessionId The id of the session to remove\n\t */\n\tremoveSession(providerId: string, sessionId: string): Promise<void>;\n\n\t/**\n\t * Gets a provider id for a specified authorization server\n\t * @param authorizationServer The authorization server url that this provider is responsible for\n\t * @param resourceServer The resource server URI that should match the provider's resourceServer (if defined)\n\t */\n\tgetOrActivateProviderIdForServer(authorizationServer: URI, resourceServer?: URI): Promise<string | undefined>;\n\n\t/**\n\t * Allows the ability register a delegate that will be used to start authentication providers\n\t * @param delegate The delegate to register\n\t */\n\tregisterAuthenticationProviderHostDelegate(delegate: IAuthenticationProviderHostDelegate): IDisposable;\n\n\t/**\n\t * Creates a dynamic authentication provider for the given server metadata\n\t * @param serverMetadata The metadata for the server that is being authenticated against\n\t */\n\tcreateDynamicAuthenticationProvider(authorizationServer: URI, serverMetadata: IAuthorizationServerMetadata, resourceMetadata: IAuthorizationProtectedResourceMetadata | undefined): Promise<IAuthenticationProvider | undefined>;\n}\n\nexport function isAuthenticationSession(thing: unknown): thing is AuthenticationSession {\n\tif (typeof thing !== 'object' || !thing) {\n\t\treturn false;\n\t}\n\tconst maybe = thing as AuthenticationSession;\n\tif (typeof maybe.id !== 'string') {\n\t\treturn false;\n\t}\n\tif (typeof maybe.accessToken !== 'string') {\n\t\treturn false;\n\t}\n\tif (typeof maybe.account !== 'object' || !maybe.account) {\n\t\treturn false;\n\t}\n\tif (typeof maybe.account.label !== 'string') {\n\t\treturn false;\n\t}\n\tif (typeof maybe.account.id !== 'string') {\n\t\treturn false;\n\t}\n\tif (!Array.isArray(maybe.scopes)) {\n\t\treturn false;\n\t}\n\tif (maybe.idToken && typeof maybe.idToken !== 'string') {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// TODO: Move this into MainThreadAuthentication\nexport const IAuthenticationExtensionsService = createDecorator<IAuthenticationExtensionsService>('IAuthenticationExtensionsService');\nexport interface IAuthenticationExtensionsService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fires when an account preference for a specific provider has changed for the specified extensions. Does not fire when:\n\t * * An account preference is removed\n\t * * A session preference is changed (because it's deprecated)\n\t * * A session preference is removed (because it's deprecated)\n\t */\n\treadonly onDidChangeAccountPreference: Event<{ extensionIds: string[]; providerId: string }>;\n\t/**\n\t * Returns the accountName (also known as account.label) to pair with `IAuthenticationAccessService` to get the account preference\n\t * @param providerId The authentication provider id\n\t * @param extensionId The extension id to get the preference for\n\t * @returns The accountName of the preference, or undefined if there is no preference set\n\t */\n\tgetAccountPreference(extensionId: string, providerId: string): string | undefined;\n\t/**\n\t * Sets the account preference for the given provider and extension\n\t * @param providerId The authentication provider id\n\t * @param extensionId The extension id to set the preference for\n\t * @param account The account to set the preference to\n\t */\n\tupdateAccountPreference(extensionId: string, providerId: string, account: AuthenticationSessionAccount): void;\n\t/**\n\t * Removes the account preference for the given provider and extension\n\t * @param providerId The authentication provider id\n\t * @param extensionId The extension id to remove the preference for\n\t */\n\tremoveAccountPreference(extensionId: string, providerId: string): void;\n\t/**\n\t * @deprecated Sets the session preference for the given provider and extension\n\t * @param providerId\n\t * @param extensionId\n\t * @param session\n\t */\n\tupdateSessionPreference(providerId: string, extensionId: string, session: AuthenticationSession): void;\n\t/**\n\t * @deprecated Gets the session preference for the given provider and extension\n\t * @param providerId\n\t * @param extensionId\n\t * @param scopes\n\t */\n\tgetSessionPreference(providerId: string, extensionId: string, scopes: string[]): string | undefined;\n\t/**\n\t * @deprecated Removes the session preference for the given provider and extension\n\t * @param providerId\n\t * @param extensionId\n\t * @param scopes\n\t */\n\tremoveSessionPreference(providerId: string, extensionId: string, scopes: string[]): void;\n\tselectSession(providerId: string, extensionId: string, extensionName: string, scopeListOrRequest: ReadonlyArray<string> | IAuthenticationWwwAuthenticateRequest, possibleSessions: readonly AuthenticationSession[]): Promise<AuthenticationSession>;\n\trequestSessionAccess(providerId: string, extensionId: string, extensionName: string, scopeListOrRequest: ReadonlyArray<string> | IAuthenticationWwwAuthenticateRequest, possibleSessions: readonly AuthenticationSession[]): void;\n\trequestNewSession(providerId: string, scopeListOrRequest: ReadonlyArray<string> | IAuthenticationWwwAuthenticateRequest, extensionId: string, extensionName: string): Promise<void>;\n\tupdateNewSessionRequests(providerId: string, addedSessions: readonly AuthenticationSession[]): void;\n}\n\n/**\n * Options passed to the authentication provider when asking for sessions.\n */\nexport interface IAuthenticationProviderSessionOptions {\n\t/**\n\t * The account that is being asked about. If this is passed in, the provider should\n\t * attempt to return the sessions that are only related to this account.\n\t */\n\taccount?: AuthenticationSessionAccount;\n\t/**\n\t * The authorization server that is being asked about. If this is passed in, the provider should\n\t * attempt to return sessions that are only related to this authorization server.\n\t */\n\tauthorizationServer?: URI;\n\t/**\n\t * Allows the authentication provider to take in additional parameters.\n\t * It is up to the provider to define what these parameters are and handle them.\n\t * This is useful for passing in additional information that is specific to the provider\n\t * and not part of the standard authentication flow.\n\t */\n\t[key: string]: any;\n}\n\n/**\n * Represents an authentication provider.\n */\nexport interface IAuthenticationProvider {\n\t/**\n\t * The unique identifier of the authentication provider.\n\t */\n\treadonly id: string;\n\n\t/**\n\t * The display label of the authentication provider.\n\t */\n\treadonly label: string;\n\n\t/**\n\t * The resource server URI that this provider is responsible for, if any.\n\t * TODO@TylerLeonhardt: Rather than this being added to the provider, it should be passed in to\n\t * getSessions/createSession/etc... this way we can have providers that handle multiple resource servers.\n\t */\n\treadonly resourceServer?: URI;\n\n\t/**\n\t * The resolved authorization servers. These can still contain globs, but should be concrete URIs\n\t */\n\treadonly authorizationServers?: ReadonlyArray<URI>;\n\n\t/**\n\t * Indicates whether the authentication provider supports multiple accounts.\n\t */\n\treadonly supportsMultipleAccounts: boolean;\n\n\t/**\n\t * Optional function to provide a custom confirmation message for authentication prompts.\n\t * If not implemented, the default confirmation messages will be used.\n\t * @param extensionName - The name of the extension requesting authentication.\n\t * @param recreatingSession - Whether this is recreating an existing session.\n\t * @returns A custom confirmation message or undefined to use the default message.\n\t */\n\treadonly confirmation?: (extensionName: string, recreatingSession: boolean) => string | undefined;\n\n\t/**\n\t * An {@link Event} which fires when the array of sessions has changed, or data\n\t * within a session has changed.\n\t */\n\treadonly onDidChangeSessions: Event<AuthenticationSessionsChangeEvent>;\n\n\t/**\n\t * Retrieves a list of authentication sessions.\n\t * @param scopes - An optional list of scopes. If provided, the sessions returned should match these permissions, otherwise all sessions should be returned.\n\t * @param options - Additional options for getting sessions.\n\t * @returns A promise that resolves to an array of authentication sessions.\n\t */\n\tgetSessions(scopes: string[] | undefined, options: IAuthenticationProviderSessionOptions): Promise<readonly AuthenticationSession[]>;\n\n\t/**\n\t * Prompts the user to log in.\n\t * If login is successful, the `onDidChangeSessions` event should be fired.\n\t * If login fails, a rejected promise should be returned.\n\t * If the provider does not support multiple accounts, this method should not be called if there is already an existing session matching the provided scopes.\n\t * @param scopes - A list of scopes that the new session should be created with.\n\t * @param options - Additional options for creating the session.\n\t * @returns A promise that resolves to an authentication session.\n\t */\n\tcreateSession(scopes: string[], options: IAuthenticationProviderSessionOptions): Promise<AuthenticationSession>;\n\n\t/**\n\t * Get existing sessions that match the given authentication constraints.\n\t *\n\t * @param constraint The authentication constraint containing challenges and optional scopes\n\t * @param options Options for the session request\n\t * @returns A thenable that resolves to an array of existing authentication sessions\n\t */\n\tgetSessionsFromChallenges?(constraint: IAuthenticationConstraint, options: IAuthenticationProviderSessionOptions): Promise<readonly AuthenticationSession[]>;\n\n\t/**\n\t * Create a new session based on authentication constraints.\n\t * This is called when no existing session matches the constraint requirements.\n\t *\n\t * @param constraint The authentication constraint containing challenges and optional scopes\n\t * @param options Options for the session creation\n\t * @returns A thenable that resolves to a new authentication session\n\t */\n\tcreateSessionFromChallenges?(constraint: IAuthenticationConstraint, options: IAuthenticationProviderSessionOptions): Promise<AuthenticationSession>;\n\n\t/**\n\t * Removes the session corresponding to the specified session ID.\n\t * If the removal is successful, the `onDidChangeSessions` event should be fired.\n\t * If a session cannot be removed, the provider should reject with an error message.\n\t * @param sessionId - The ID of the session to remove.\n\t */\n\tremoveSession(sessionId: string): Promise<void>;\n}\n"]}