{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/authentication/browser/authenticationUsageService.ts","vs/workbench/services/authentication/browser/authenticationUsageService.ts"],"names":[],"mappings":"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","file":"authenticationUsageService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Queue } from '../../../../base/common/async.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { IAuthenticationService } from '../common/authentication.js';\n\nexport interface IAccountUsage {\n\textensionId: string;\n\textensionName: string;\n\tlastUsed: number;\n\tscopes?: string[];\n}\n\nexport const IAuthenticationUsageService = createDecorator<IAuthenticationUsageService>('IAuthenticationUsageService');\nexport interface IAuthenticationUsageService {\n\treadonly _serviceBrand: undefined;\n\t/**\n\t * Initializes the cache of extensions that use authentication. Ideally used in a contribution that can be run eventually after the workspace is loaded.\n\t */\n\tinitializeExtensionUsageCache(): Promise<void>;\n\t/**\n\t * Checks if an extension uses authentication\n\t * @param extensionId The id of the extension to check\n\t */\n\textensionUsesAuth(extensionId: string): Promise<boolean>;\n\t/**\n\t * Reads the usages for an account\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t */\n\treadAccountUsages(providerId: string, accountName: string,): IAccountUsage[];\n\t/**\n\t *\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t */\n\tremoveAccountUsage(providerId: string, accountName: string): void;\n\t/**\n\t * Adds a usage for an account\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t * @param extensionId The id of the extension to add a usage for\n\t * @param extensionName The name of the extension to add a usage for\n\t */\n\taddAccountUsage(providerId: string, accountName: string, scopes: ReadonlyArray<string> | undefined, extensionId: string, extensionName: string): void;\n}\n\nexport class AuthenticationUsageService extends Disposable implements IAuthenticationUsageService {\n\t_serviceBrand: undefined;\n\n\tprivate _queue = this._register(new Queue());\n\tprivate _extensionsUsingAuth = new Set<string>();\n\n\tprivate _disposed = false;\n\n\tconstructor(\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t\t@IAuthenticationService private readonly _authenticationService: IAuthenticationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IProductService productService: IProductService,\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => this._disposed = true));\n\t\t// If an extension is listed in `trustedExtensionAuthAccess` we should consider it as using auth\n\t\tconst trustedExtensionAuthAccess = productService.trustedExtensionAuthAccess;\n\t\tif (Array.isArray(trustedExtensionAuthAccess)) {\n\t\t\tfor (const extensionId of trustedExtensionAuthAccess) {\n\t\t\t\tthis._extensionsUsingAuth.add(extensionId);\n\t\t\t}\n\t\t} else if (trustedExtensionAuthAccess) {\n\t\t\tfor (const extensions of Object.values(trustedExtensionAuthAccess)) {\n\t\t\t\tfor (const extensionId of extensions) {\n\t\t\t\t\tthis._extensionsUsingAuth.add(extensionId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._register(this._authenticationService.onDidRegisterAuthenticationProvider(\n\t\t\tprovider => this._queue.queue(\n\t\t\t\t() => this._addExtensionsToCache(provider.id)\n\t\t\t)\n\t\t));\n\t}\n\n\tasync initializeExtensionUsageCache(): Promise<void> {\n\t\tawait this._queue.queue(() => Promise.all(this._authenticationService.getProviderIds().map(providerId => this._addExtensionsToCache(providerId))));\n\t}\n\n\tasync extensionUsesAuth(extensionId: string): Promise<boolean> {\n\t\tawait this._queue.whenIdle();\n\t\treturn this._extensionsUsingAuth.has(extensionId);\n\t}\n\n\treadAccountUsages(providerId: string, accountName: string): IAccountUsage[] {\n\t\tconst accountKey = `${providerId}-${accountName}-usages`;\n\t\tconst storedUsages = this._storageService.get(accountKey, StorageScope.APPLICATION);\n\t\tlet usages: IAccountUsage[] = [];\n\t\tif (storedUsages) {\n\t\t\ttry {\n\t\t\t\tusages = JSON.parse(storedUsages);\n\t\t\t} catch (e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\n\t\treturn usages;\n\t}\n\n\tremoveAccountUsage(providerId: string, accountName: string): void {\n\t\tconst accountKey = `${providerId}-${accountName}-usages`;\n\t\tthis._storageService.remove(accountKey, StorageScope.APPLICATION);\n\t}\n\n\taddAccountUsage(providerId: string, accountName: string, scopes: string[] | undefined, extensionId: string, extensionName: string): void {\n\t\tconst accountKey = `${providerId}-${accountName}-usages`;\n\t\tconst usages = this.readAccountUsages(providerId, accountName);\n\n\t\tconst existingUsageIndex = usages.findIndex(usage => usage.extensionId === extensionId);\n\t\tif (existingUsageIndex > -1) {\n\t\t\tusages.splice(existingUsageIndex, 1, {\n\t\t\t\textensionId,\n\t\t\t\textensionName,\n\t\t\t\tscopes,\n\t\t\t\tlastUsed: Date.now()\n\t\t\t});\n\t\t} else {\n\t\t\tusages.push({\n\t\t\t\textensionId,\n\t\t\t\textensionName,\n\t\t\t\tscopes,\n\t\t\t\tlastUsed: Date.now()\n\t\t\t});\n\t\t}\n\n\t\tthis._storageService.store(accountKey, JSON.stringify(usages), StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\tthis._extensionsUsingAuth.add(extensionId);\n\t}\n\n\tprivate async _addExtensionsToCache(providerId: string) {\n\t\tif (this._disposed) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tconst accounts = await this._authenticationService.getAccounts(providerId);\n\t\t\tfor (const account of accounts) {\n\t\t\t\tconst usage = this.readAccountUsages(providerId, account.label);\n\t\t\t\tfor (const u of usage) {\n\t\t\t\t\tthis._extensionsUsingAuth.add(u.extensionId);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logService.error(e);\n\t\t}\n\t}\n}\n\nregisterSingleton(IAuthenticationUsageService, AuthenticationUsageService, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Queue } from '../../../../base/common/async.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { IAuthenticationService } from '../common/authentication.js';\n\nexport interface IAccountUsage {\n\textensionId: string;\n\textensionName: string;\n\tlastUsed: number;\n\tscopes?: string[];\n}\n\nexport const IAuthenticationUsageService = createDecorator<IAuthenticationUsageService>('IAuthenticationUsageService');\nexport interface IAuthenticationUsageService {\n\treadonly _serviceBrand: undefined;\n\t/**\n\t * Initializes the cache of extensions that use authentication. Ideally used in a contribution that can be run eventually after the workspace is loaded.\n\t */\n\tinitializeExtensionUsageCache(): Promise<void>;\n\t/**\n\t * Checks if an extension uses authentication\n\t * @param extensionId The id of the extension to check\n\t */\n\textensionUsesAuth(extensionId: string): Promise<boolean>;\n\t/**\n\t * Reads the usages for an account\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t */\n\treadAccountUsages(providerId: string, accountName: string,): IAccountUsage[];\n\t/**\n\t *\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t */\n\tremoveAccountUsage(providerId: string, accountName: string): void;\n\t/**\n\t * Adds a usage for an account\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t * @param extensionId The id of the extension to add a usage for\n\t * @param extensionName The name of the extension to add a usage for\n\t */\n\taddAccountUsage(providerId: string, accountName: string, scopes: ReadonlyArray<string> | undefined, extensionId: string, extensionName: string): void;\n}\n\nexport class AuthenticationUsageService extends Disposable implements IAuthenticationUsageService {\n\t_serviceBrand: undefined;\n\n\tprivate _queue = this._register(new Queue());\n\tprivate _extensionsUsingAuth = new Set<string>();\n\n\tprivate _disposed = false;\n\n\tconstructor(\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t\t@IAuthenticationService private readonly _authenticationService: IAuthenticationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IProductService productService: IProductService,\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => this._disposed = true));\n\t\t// If an extension is listed in `trustedExtensionAuthAccess` we should consider it as using auth\n\t\tconst trustedExtensionAuthAccess = productService.trustedExtensionAuthAccess;\n\t\tif (Array.isArray(trustedExtensionAuthAccess)) {\n\t\t\tfor (const extensionId of trustedExtensionAuthAccess) {\n\t\t\t\tthis._extensionsUsingAuth.add(extensionId);\n\t\t\t}\n\t\t} else if (trustedExtensionAuthAccess) {\n\t\t\tfor (const extensions of Object.values(trustedExtensionAuthAccess)) {\n\t\t\t\tfor (const extensionId of extensions) {\n\t\t\t\t\tthis._extensionsUsingAuth.add(extensionId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._register(this._authenticationService.onDidRegisterAuthenticationProvider(\n\t\t\tprovider => this._queue.queue(\n\t\t\t\t() => this._addExtensionsToCache(provider.id)\n\t\t\t)\n\t\t));\n\t}\n\n\tasync initializeExtensionUsageCache(): Promise<void> {\n\t\tawait this._queue.queue(() => Promise.all(this._authenticationService.getProviderIds().map(providerId => this._addExtensionsToCache(providerId))));\n\t}\n\n\tasync extensionUsesAuth(extensionId: string): Promise<boolean> {\n\t\tawait this._queue.whenIdle();\n\t\treturn this._extensionsUsingAuth.has(extensionId);\n\t}\n\n\treadAccountUsages(providerId: string, accountName: string): IAccountUsage[] {\n\t\tconst accountKey = `${providerId}-${accountName}-usages`;\n\t\tconst storedUsages = this._storageService.get(accountKey, StorageScope.APPLICATION);\n\t\tlet usages: IAccountUsage[] = [];\n\t\tif (storedUsages) {\n\t\t\ttry {\n\t\t\t\tusages = JSON.parse(storedUsages);\n\t\t\t} catch (e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\n\t\treturn usages;\n\t}\n\n\tremoveAccountUsage(providerId: string, accountName: string): void {\n\t\tconst accountKey = `${providerId}-${accountName}-usages`;\n\t\tthis._storageService.remove(accountKey, StorageScope.APPLICATION);\n\t}\n\n\taddAccountUsage(providerId: string, accountName: string, scopes: string[] | undefined, extensionId: string, extensionName: string): void {\n\t\tconst accountKey = `${providerId}-${accountName}-usages`;\n\t\tconst usages = this.readAccountUsages(providerId, accountName);\n\n\t\tconst existingUsageIndex = usages.findIndex(usage => usage.extensionId === extensionId);\n\t\tif (existingUsageIndex > -1) {\n\t\t\tusages.splice(existingUsageIndex, 1, {\n\t\t\t\textensionId,\n\t\t\t\textensionName,\n\t\t\t\tscopes,\n\t\t\t\tlastUsed: Date.now()\n\t\t\t});\n\t\t} else {\n\t\t\tusages.push({\n\t\t\t\textensionId,\n\t\t\t\textensionName,\n\t\t\t\tscopes,\n\t\t\t\tlastUsed: Date.now()\n\t\t\t});\n\t\t}\n\n\t\tthis._storageService.store(accountKey, JSON.stringify(usages), StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\tthis._extensionsUsingAuth.add(extensionId);\n\t}\n\n\tprivate async _addExtensionsToCache(providerId: string) {\n\t\tif (this._disposed) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tconst accounts = await this._authenticationService.getAccounts(providerId);\n\t\t\tfor (const account of accounts) {\n\t\t\t\tconst usage = this.readAccountUsages(providerId, account.label);\n\t\t\t\tfor (const u of usage) {\n\t\t\t\t\tthis._extensionsUsingAuth.add(u.extensionId);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logService.error(e);\n\t\t}\n\t}\n}\n\nregisterSingleton(IAuthenticationUsageService, AuthenticationUsageService, InstantiationType.Delayed);\n"]}