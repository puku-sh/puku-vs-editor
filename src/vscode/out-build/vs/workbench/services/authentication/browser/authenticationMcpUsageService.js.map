{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/authentication/browser/authenticationMcpUsageService.ts","vs/workbench/services/authentication/browser/authenticationMcpUsageService.ts"],"names":[],"mappings":"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","file":"authenticationMcpUsageService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Queue } from '../../../../base/common/async.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { IAuthenticationService } from '../common/authentication.js';\n\nexport interface IAuthenticationMcpUsage {\n\tmcpServerId: string;\n\tmcpServerName: string;\n\tlastUsed: number;\n\tscopes?: string[];\n}\n\nexport const IAuthenticationMcpUsageService = createDecorator<IAuthenticationMcpUsageService>('IAuthenticationMcpUsageService');\nexport interface IAuthenticationMcpUsageService {\n\treadonly _serviceBrand: undefined;\n\t/**\n\t * Initializes the cache of MCP servers that use authentication. Ideally used in a contribution that can be run eventually after the workspace is loaded.\n\t */\n\tinitializeUsageCache(): Promise<void>;\n\t/**\n\t * Checks if an MCP server uses authentication\n\t * @param mcpServerId The id of the MCP server to check\n\t */\n\thasUsedAuth(mcpServerId: string): Promise<boolean>;\n\t/**\n\t * Reads the usages for an account\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t */\n\treadAccountUsages(providerId: string, accountName: string,): IAuthenticationMcpUsage[];\n\t/**\n\t *\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t */\n\tremoveAccountUsage(providerId: string, accountName: string): void;\n\t/**\n\t * Adds a usage for an account\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t * @param mcpServerId The id of the MCP server to add a usage for\n\t * @param mcpServerName The name of the MCP server to add a usage for\n\t */\n\taddAccountUsage(providerId: string, accountName: string, scopes: ReadonlyArray<string>, mcpServerId: string, mcpServerName: string): void;\n}\n\nexport class AuthenticationMcpUsageService extends Disposable implements IAuthenticationMcpUsageService {\n\t_serviceBrand: undefined;\n\n\tprivate _queue = new Queue();\n\tprivate _mcpServersUsingAuth = new Set<string>();\n\n\tconstructor(\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t\t@IAuthenticationService private readonly _authenticationService: IAuthenticationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IProductService productService: IProductService,\n\t) {\n\t\tsuper();\n\n\t\t// If an MCP server is listed in `trustedMcpAuthAccess` we should consider it as using auth\n\t\tconst trustedMcpAuthAccess = productService.trustedMcpAuthAccess;\n\t\tif (Array.isArray(trustedMcpAuthAccess)) {\n\t\t\tfor (const mcpServerId of trustedMcpAuthAccess) {\n\t\t\t\tthis._mcpServersUsingAuth.add(mcpServerId);\n\t\t\t}\n\t\t} else if (trustedMcpAuthAccess) {\n\t\t\tfor (const mcpServers of Object.values(trustedMcpAuthAccess)) {\n\t\t\t\tfor (const mcpServerId of mcpServers) {\n\t\t\t\t\tthis._mcpServersUsingAuth.add(mcpServerId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._register(this._authenticationService.onDidRegisterAuthenticationProvider(\n\t\t\tprovider => this._queue.queue(\n\t\t\t\t() => this._addToCache(provider.id)\n\t\t\t)\n\t\t));\n\t}\n\n\tasync initializeUsageCache(): Promise<void> {\n\t\tawait this._queue.queue(() => Promise.all(this._authenticationService.getProviderIds().map(providerId => this._addToCache(providerId))));\n\t}\n\n\tasync hasUsedAuth(mcpServerId: string): Promise<boolean> {\n\t\tawait this._queue.whenIdle();\n\t\treturn this._mcpServersUsingAuth.has(mcpServerId);\n\t}\n\n\treadAccountUsages(providerId: string, accountName: string): IAuthenticationMcpUsage[] {\n\t\tconst accountKey = `${providerId}-${accountName}-mcpserver-usages`;\n\t\tconst storedUsages = this._storageService.get(accountKey, StorageScope.APPLICATION);\n\t\tlet usages: IAuthenticationMcpUsage[] = [];\n\t\tif (storedUsages) {\n\t\t\ttry {\n\t\t\t\tusages = JSON.parse(storedUsages);\n\t\t\t} catch (e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\n\t\treturn usages;\n\t}\n\n\tremoveAccountUsage(providerId: string, accountName: string): void {\n\t\tconst accountKey = `${providerId}-${accountName}-mcpserver-usages`;\n\t\tthis._storageService.remove(accountKey, StorageScope.APPLICATION);\n\t}\n\n\taddAccountUsage(providerId: string, accountName: string, scopes: string[], mcpServerId: string, mcpServerName: string): void {\n\t\tconst accountKey = `${providerId}-${accountName}-mcpserver-usages`;\n\t\tconst usages = this.readAccountUsages(providerId, accountName);\n\n\t\tconst existingUsageIndex = usages.findIndex(usage => usage.mcpServerId === mcpServerId);\n\t\tif (existingUsageIndex > -1) {\n\t\t\tusages.splice(existingUsageIndex, 1, {\n\t\t\t\tmcpServerId,\n\t\t\t\tmcpServerName,\n\t\t\t\tscopes,\n\t\t\t\tlastUsed: Date.now()\n\t\t\t});\n\t\t} else {\n\t\t\tusages.push({\n\t\t\t\tmcpServerId,\n\t\t\t\tmcpServerName,\n\t\t\t\tscopes,\n\t\t\t\tlastUsed: Date.now()\n\t\t\t});\n\t\t}\n\n\t\tthis._storageService.store(accountKey, JSON.stringify(usages), StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\tthis._mcpServersUsingAuth.add(mcpServerId);\n\t}\n\n\tprivate async _addToCache(providerId: string) {\n\t\ttry {\n\t\t\tconst accounts = await this._authenticationService.getAccounts(providerId);\n\t\t\tfor (const account of accounts) {\n\t\t\t\tconst usage = this.readAccountUsages(providerId, account.label);\n\t\t\t\tfor (const u of usage) {\n\t\t\t\t\tthis._mcpServersUsingAuth.add(u.mcpServerId);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logService.error(e);\n\t\t}\n\t}\n}\n\nregisterSingleton(IAuthenticationMcpUsageService, AuthenticationMcpUsageService, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Queue } from '../../../../base/common/async.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { IAuthenticationService } from '../common/authentication.js';\n\nexport interface IAuthenticationMcpUsage {\n\tmcpServerId: string;\n\tmcpServerName: string;\n\tlastUsed: number;\n\tscopes?: string[];\n}\n\nexport const IAuthenticationMcpUsageService = createDecorator<IAuthenticationMcpUsageService>('IAuthenticationMcpUsageService');\nexport interface IAuthenticationMcpUsageService {\n\treadonly _serviceBrand: undefined;\n\t/**\n\t * Initializes the cache of MCP servers that use authentication. Ideally used in a contribution that can be run eventually after the workspace is loaded.\n\t */\n\tinitializeUsageCache(): Promise<void>;\n\t/**\n\t * Checks if an MCP server uses authentication\n\t * @param mcpServerId The id of the MCP server to check\n\t */\n\thasUsedAuth(mcpServerId: string): Promise<boolean>;\n\t/**\n\t * Reads the usages for an account\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t */\n\treadAccountUsages(providerId: string, accountName: string,): IAuthenticationMcpUsage[];\n\t/**\n\t *\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t */\n\tremoveAccountUsage(providerId: string, accountName: string): void;\n\t/**\n\t * Adds a usage for an account\n\t * @param providerId The id of the authentication provider to get usages for\n\t * @param accountName The name of the account to get usages for\n\t * @param mcpServerId The id of the MCP server to add a usage for\n\t * @param mcpServerName The name of the MCP server to add a usage for\n\t */\n\taddAccountUsage(providerId: string, accountName: string, scopes: ReadonlyArray<string>, mcpServerId: string, mcpServerName: string): void;\n}\n\nexport class AuthenticationMcpUsageService extends Disposable implements IAuthenticationMcpUsageService {\n\t_serviceBrand: undefined;\n\n\tprivate _queue = new Queue();\n\tprivate _mcpServersUsingAuth = new Set<string>();\n\n\tconstructor(\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t\t@IAuthenticationService private readonly _authenticationService: IAuthenticationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IProductService productService: IProductService,\n\t) {\n\t\tsuper();\n\n\t\t// If an MCP server is listed in `trustedMcpAuthAccess` we should consider it as using auth\n\t\tconst trustedMcpAuthAccess = productService.trustedMcpAuthAccess;\n\t\tif (Array.isArray(trustedMcpAuthAccess)) {\n\t\t\tfor (const mcpServerId of trustedMcpAuthAccess) {\n\t\t\t\tthis._mcpServersUsingAuth.add(mcpServerId);\n\t\t\t}\n\t\t} else if (trustedMcpAuthAccess) {\n\t\t\tfor (const mcpServers of Object.values(trustedMcpAuthAccess)) {\n\t\t\t\tfor (const mcpServerId of mcpServers) {\n\t\t\t\t\tthis._mcpServersUsingAuth.add(mcpServerId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._register(this._authenticationService.onDidRegisterAuthenticationProvider(\n\t\t\tprovider => this._queue.queue(\n\t\t\t\t() => this._addToCache(provider.id)\n\t\t\t)\n\t\t));\n\t}\n\n\tasync initializeUsageCache(): Promise<void> {\n\t\tawait this._queue.queue(() => Promise.all(this._authenticationService.getProviderIds().map(providerId => this._addToCache(providerId))));\n\t}\n\n\tasync hasUsedAuth(mcpServerId: string): Promise<boolean> {\n\t\tawait this._queue.whenIdle();\n\t\treturn this._mcpServersUsingAuth.has(mcpServerId);\n\t}\n\n\treadAccountUsages(providerId: string, accountName: string): IAuthenticationMcpUsage[] {\n\t\tconst accountKey = `${providerId}-${accountName}-mcpserver-usages`;\n\t\tconst storedUsages = this._storageService.get(accountKey, StorageScope.APPLICATION);\n\t\tlet usages: IAuthenticationMcpUsage[] = [];\n\t\tif (storedUsages) {\n\t\t\ttry {\n\t\t\t\tusages = JSON.parse(storedUsages);\n\t\t\t} catch (e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\n\t\treturn usages;\n\t}\n\n\tremoveAccountUsage(providerId: string, accountName: string): void {\n\t\tconst accountKey = `${providerId}-${accountName}-mcpserver-usages`;\n\t\tthis._storageService.remove(accountKey, StorageScope.APPLICATION);\n\t}\n\n\taddAccountUsage(providerId: string, accountName: string, scopes: string[], mcpServerId: string, mcpServerName: string): void {\n\t\tconst accountKey = `${providerId}-${accountName}-mcpserver-usages`;\n\t\tconst usages = this.readAccountUsages(providerId, accountName);\n\n\t\tconst existingUsageIndex = usages.findIndex(usage => usage.mcpServerId === mcpServerId);\n\t\tif (existingUsageIndex > -1) {\n\t\t\tusages.splice(existingUsageIndex, 1, {\n\t\t\t\tmcpServerId,\n\t\t\t\tmcpServerName,\n\t\t\t\tscopes,\n\t\t\t\tlastUsed: Date.now()\n\t\t\t});\n\t\t} else {\n\t\t\tusages.push({\n\t\t\t\tmcpServerId,\n\t\t\t\tmcpServerName,\n\t\t\t\tscopes,\n\t\t\t\tlastUsed: Date.now()\n\t\t\t});\n\t\t}\n\n\t\tthis._storageService.store(accountKey, JSON.stringify(usages), StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\tthis._mcpServersUsingAuth.add(mcpServerId);\n\t}\n\n\tprivate async _addToCache(providerId: string) {\n\t\ttry {\n\t\t\tconst accounts = await this._authenticationService.getAccounts(providerId);\n\t\t\tfor (const account of accounts) {\n\t\t\t\tconst usage = this.readAccountUsages(providerId, account.label);\n\t\t\t\tfor (const u of usage) {\n\t\t\t\t\tthis._mcpServersUsingAuth.add(u.mcpServerId);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logService.error(e);\n\t\t}\n\t}\n}\n\nregisterSingleton(IAuthenticationMcpUsageService, AuthenticationMcpUsageService, InstantiationType.Delayed);\n"]}