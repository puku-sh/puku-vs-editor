{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/authentication/browser/authenticationMcpAccessService.ts","vs/workbench/services/authentication/browser/authenticationMcpAccessService.ts"],"names":[],"mappings":"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","file":"authenticationMcpAccessService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\n\nexport interface AllowedMcpServer {\n\tid: string;\n\tname: string;\n\t/**\n\t * If true or undefined, the extension is allowed to use the account\n\t * If false, the extension is not allowed to use the account\n\t * TODO: undefined shouldn't be a valid value, but it is for now\n\t */\n\tallowed?: boolean;\n\tlastUsed?: number;\n\t// If true, this comes from the product.json\n\ttrusted?: boolean;\n}\n\nexport const IAuthenticationMcpAccessService = createDecorator<IAuthenticationMcpAccessService>('IAuthenticationMcpAccessService');\nexport interface IAuthenticationMcpAccessService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidChangeMcpSessionAccess: Event<{ providerId: string; accountName: string }>;\n\n\t/**\n\t * Check MCP server access to an account\n\t * @param providerId The id of the authentication provider\n\t * @param accountName The account name that access is checked for\n\t * @param mcpServerId The id of the MCP server requesting access\n\t * @returns Returns true or false if the user has opted to permanently grant or disallow access, and undefined\n\t * if they haven't made a choice yet\n\t */\n\tisAccessAllowed(providerId: string, accountName: string, mcpServerId: string): boolean | undefined;\n\treadAllowedMcpServers(providerId: string, accountName: string): AllowedMcpServer[];\n\tupdateAllowedMcpServers(providerId: string, accountName: string, mcpServers: AllowedMcpServer[]): void;\n\tremoveAllowedMcpServers(providerId: string, accountName: string): void;\n}\n\n// TODO@TylerLeonhardt: Should this class only keep track of allowed things and throw away disallowed ones?\nexport class AuthenticationMcpAccessService extends Disposable implements IAuthenticationMcpAccessService {\n\t_serviceBrand: undefined;\n\n\tprivate _onDidChangeMcpSessionAccess: Emitter<{ providerId: string; accountName: string }> = this._register(new Emitter<{ providerId: string; accountName: string }>());\n\treadonly onDidChangeMcpSessionAccess: Event<{ providerId: string; accountName: string }> = this._onDidChangeMcpSessionAccess.event;\n\n\tconstructor(\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t\t@IProductService private readonly _productService: IProductService\n\t) {\n\t\tsuper();\n\t}\n\n\tisAccessAllowed(providerId: string, accountName: string, mcpServerId: string): boolean | undefined {\n\t\tconst trustedMCPServerAuthAccess = this._productService.trustedMcpAuthAccess;\n\t\tif (Array.isArray(trustedMCPServerAuthAccess)) {\n\t\t\tif (trustedMCPServerAuthAccess.includes(mcpServerId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (trustedMCPServerAuthAccess?.[providerId]?.includes(mcpServerId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst allowList = this.readAllowedMcpServers(providerId, accountName);\n\t\tconst mcpServerData = allowList.find(mcpServer => mcpServer.id === mcpServerId);\n\t\tif (!mcpServerData) {\n\t\t\treturn undefined;\n\t\t}\n\t\t// This property didn't exist on this data previously, inclusion in the list at all indicates allowance\n\t\treturn mcpServerData.allowed !== undefined\n\t\t\t? mcpServerData.allowed\n\t\t\t: true;\n\t}\n\n\treadAllowedMcpServers(providerId: string, accountName: string): AllowedMcpServer[] {\n\t\tlet trustedMCPServers: AllowedMcpServer[] = [];\n\t\ttry {\n\t\t\tconst trustedMCPServerSrc = this._storageService.get(`mcpserver-${providerId}-${accountName}`, StorageScope.APPLICATION);\n\t\t\tif (trustedMCPServerSrc) {\n\t\t\t\ttrustedMCPServers = JSON.parse(trustedMCPServerSrc);\n\t\t\t}\n\t\t} catch (err) { }\n\n\t\t// Add trusted MCP servers from product.json if they're not already in the list\n\t\tconst trustedMcpServerAuthAccess = this._productService.trustedMcpAuthAccess;\n\t\tconst trustedMcpServerIds =\n\t\t\t// Case 1: trustedMcpServerAuthAccess is an array\n\t\t\tArray.isArray(trustedMcpServerAuthAccess)\n\t\t\t\t? trustedMcpServerAuthAccess\n\t\t\t\t// Case 2: trustedMcpServerAuthAccess is an object\n\t\t\t\t: typeof trustedMcpServerAuthAccess === 'object'\n\t\t\t\t\t? trustedMcpServerAuthAccess[providerId] ?? []\n\t\t\t\t\t: [];\n\n\t\tfor (const mcpServerId of trustedMcpServerIds) {\n\t\t\tconst existingServer = trustedMCPServers.find(server => server.id === mcpServerId);\n\t\t\tif (!existingServer) {\n\t\t\t\t// Add new trusted server (name will be set by caller if they have server info)\n\t\t\t\ttrustedMCPServers.push({\n\t\t\t\t\tid: mcpServerId,\n\t\t\t\t\tname: mcpServerId, // Default to ID, caller can update with proper name\n\t\t\t\t\tallowed: true,\n\t\t\t\t\ttrusted: true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Update existing server to be trusted\n\t\t\t\texistingServer.allowed = true;\n\t\t\t\texistingServer.trusted = true;\n\t\t\t}\n\t\t}\n\n\t\treturn trustedMCPServers;\n\t}\n\n\tupdateAllowedMcpServers(providerId: string, accountName: string, mcpServers: AllowedMcpServer[]): void {\n\t\tconst allowList = this.readAllowedMcpServers(providerId, accountName);\n\t\tfor (const mcpServer of mcpServers) {\n\t\t\tconst index = allowList.findIndex(e => e.id === mcpServer.id);\n\t\t\tif (index === -1) {\n\t\t\t\tallowList.push(mcpServer);\n\t\t\t} else {\n\t\t\t\tallowList[index].allowed = mcpServer.allowed;\n\t\t\t\t// Update name if provided and not already set to a proper name\n\t\t\t\tif (mcpServer.name && mcpServer.name !== mcpServer.id && allowList[index].name !== mcpServer.name) {\n\t\t\t\t\tallowList[index].name = mcpServer.name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filter out trusted servers before storing - they should only come from product.json, not user storage\n\t\tconst userManagedServers = allowList.filter(server => !server.trusted);\n\t\tthis._storageService.store(`mcpserver-${providerId}-${accountName}`, JSON.stringify(userManagedServers), StorageScope.APPLICATION, StorageTarget.USER);\n\t\tthis._onDidChangeMcpSessionAccess.fire({ providerId, accountName });\n\t}\n\n\tremoveAllowedMcpServers(providerId: string, accountName: string): void {\n\t\tthis._storageService.remove(`mcpserver-${providerId}-${accountName}`, StorageScope.APPLICATION);\n\t\tthis._onDidChangeMcpSessionAccess.fire({ providerId, accountName });\n\t}\n}\n\nregisterSingleton(IAuthenticationMcpAccessService, AuthenticationMcpAccessService, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\n\nexport interface AllowedMcpServer {\n\tid: string;\n\tname: string;\n\t/**\n\t * If true or undefined, the extension is allowed to use the account\n\t * If false, the extension is not allowed to use the account\n\t * TODO: undefined shouldn't be a valid value, but it is for now\n\t */\n\tallowed?: boolean;\n\tlastUsed?: number;\n\t// If true, this comes from the product.json\n\ttrusted?: boolean;\n}\n\nexport const IAuthenticationMcpAccessService = createDecorator<IAuthenticationMcpAccessService>('IAuthenticationMcpAccessService');\nexport interface IAuthenticationMcpAccessService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidChangeMcpSessionAccess: Event<{ providerId: string; accountName: string }>;\n\n\t/**\n\t * Check MCP server access to an account\n\t * @param providerId The id of the authentication provider\n\t * @param accountName The account name that access is checked for\n\t * @param mcpServerId The id of the MCP server requesting access\n\t * @returns Returns true or false if the user has opted to permanently grant or disallow access, and undefined\n\t * if they haven't made a choice yet\n\t */\n\tisAccessAllowed(providerId: string, accountName: string, mcpServerId: string): boolean | undefined;\n\treadAllowedMcpServers(providerId: string, accountName: string): AllowedMcpServer[];\n\tupdateAllowedMcpServers(providerId: string, accountName: string, mcpServers: AllowedMcpServer[]): void;\n\tremoveAllowedMcpServers(providerId: string, accountName: string): void;\n}\n\n// TODO@TylerLeonhardt: Should this class only keep track of allowed things and throw away disallowed ones?\nexport class AuthenticationMcpAccessService extends Disposable implements IAuthenticationMcpAccessService {\n\t_serviceBrand: undefined;\n\n\tprivate _onDidChangeMcpSessionAccess: Emitter<{ providerId: string; accountName: string }> = this._register(new Emitter<{ providerId: string; accountName: string }>());\n\treadonly onDidChangeMcpSessionAccess: Event<{ providerId: string; accountName: string }> = this._onDidChangeMcpSessionAccess.event;\n\n\tconstructor(\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t\t@IProductService private readonly _productService: IProductService\n\t) {\n\t\tsuper();\n\t}\n\n\tisAccessAllowed(providerId: string, accountName: string, mcpServerId: string): boolean | undefined {\n\t\tconst trustedMCPServerAuthAccess = this._productService.trustedMcpAuthAccess;\n\t\tif (Array.isArray(trustedMCPServerAuthAccess)) {\n\t\t\tif (trustedMCPServerAuthAccess.includes(mcpServerId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (trustedMCPServerAuthAccess?.[providerId]?.includes(mcpServerId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst allowList = this.readAllowedMcpServers(providerId, accountName);\n\t\tconst mcpServerData = allowList.find(mcpServer => mcpServer.id === mcpServerId);\n\t\tif (!mcpServerData) {\n\t\t\treturn undefined;\n\t\t}\n\t\t// This property didn't exist on this data previously, inclusion in the list at all indicates allowance\n\t\treturn mcpServerData.allowed !== undefined\n\t\t\t? mcpServerData.allowed\n\t\t\t: true;\n\t}\n\n\treadAllowedMcpServers(providerId: string, accountName: string): AllowedMcpServer[] {\n\t\tlet trustedMCPServers: AllowedMcpServer[] = [];\n\t\ttry {\n\t\t\tconst trustedMCPServerSrc = this._storageService.get(`mcpserver-${providerId}-${accountName}`, StorageScope.APPLICATION);\n\t\t\tif (trustedMCPServerSrc) {\n\t\t\t\ttrustedMCPServers = JSON.parse(trustedMCPServerSrc);\n\t\t\t}\n\t\t} catch (err) { }\n\n\t\t// Add trusted MCP servers from product.json if they're not already in the list\n\t\tconst trustedMcpServerAuthAccess = this._productService.trustedMcpAuthAccess;\n\t\tconst trustedMcpServerIds =\n\t\t\t// Case 1: trustedMcpServerAuthAccess is an array\n\t\t\tArray.isArray(trustedMcpServerAuthAccess)\n\t\t\t\t? trustedMcpServerAuthAccess\n\t\t\t\t// Case 2: trustedMcpServerAuthAccess is an object\n\t\t\t\t: typeof trustedMcpServerAuthAccess === 'object'\n\t\t\t\t\t? trustedMcpServerAuthAccess[providerId] ?? []\n\t\t\t\t\t: [];\n\n\t\tfor (const mcpServerId of trustedMcpServerIds) {\n\t\t\tconst existingServer = trustedMCPServers.find(server => server.id === mcpServerId);\n\t\t\tif (!existingServer) {\n\t\t\t\t// Add new trusted server (name will be set by caller if they have server info)\n\t\t\t\ttrustedMCPServers.push({\n\t\t\t\t\tid: mcpServerId,\n\t\t\t\t\tname: mcpServerId, // Default to ID, caller can update with proper name\n\t\t\t\t\tallowed: true,\n\t\t\t\t\ttrusted: true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Update existing server to be trusted\n\t\t\t\texistingServer.allowed = true;\n\t\t\t\texistingServer.trusted = true;\n\t\t\t}\n\t\t}\n\n\t\treturn trustedMCPServers;\n\t}\n\n\tupdateAllowedMcpServers(providerId: string, accountName: string, mcpServers: AllowedMcpServer[]): void {\n\t\tconst allowList = this.readAllowedMcpServers(providerId, accountName);\n\t\tfor (const mcpServer of mcpServers) {\n\t\t\tconst index = allowList.findIndex(e => e.id === mcpServer.id);\n\t\t\tif (index === -1) {\n\t\t\t\tallowList.push(mcpServer);\n\t\t\t} else {\n\t\t\t\tallowList[index].allowed = mcpServer.allowed;\n\t\t\t\t// Update name if provided and not already set to a proper name\n\t\t\t\tif (mcpServer.name && mcpServer.name !== mcpServer.id && allowList[index].name !== mcpServer.name) {\n\t\t\t\t\tallowList[index].name = mcpServer.name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filter out trusted servers before storing - they should only come from product.json, not user storage\n\t\tconst userManagedServers = allowList.filter(server => !server.trusted);\n\t\tthis._storageService.store(`mcpserver-${providerId}-${accountName}`, JSON.stringify(userManagedServers), StorageScope.APPLICATION, StorageTarget.USER);\n\t\tthis._onDidChangeMcpSessionAccess.fire({ providerId, accountName });\n\t}\n\n\tremoveAllowedMcpServers(providerId: string, accountName: string): void {\n\t\tthis._storageService.remove(`mcpserver-${providerId}-${accountName}`, StorageScope.APPLICATION);\n\t\tthis._onDidChangeMcpSessionAccess.fire({ providerId, accountName });\n\t}\n}\n\nregisterSingleton(IAuthenticationMcpAccessService, AuthenticationMcpAccessService, InstantiationType.Delayed);\n"]}