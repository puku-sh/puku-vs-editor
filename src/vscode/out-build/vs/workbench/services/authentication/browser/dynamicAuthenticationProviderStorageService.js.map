{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/authentication/browser/dynamicAuthenticationProviderStorageService.ts","vs/workbench/services/authentication/browser/dynamicAuthenticationProviderStorageService.ts"],"names":[],"mappings":"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","file":"dynamicAuthenticationProviderStorageService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { IDynamicAuthenticationProviderStorageService, DynamicAuthenticationProviderInfo, DynamicAuthenticationProviderTokensChangeEvent } from '../common/dynamicAuthenticationProviderStorage.js';\nimport { ISecretStorageService } from '../../../../platform/secrets/common/secrets.js';\nimport { IAuthorizationTokenResponse, isAuthorizationTokenResponse } from '../../../../base/common/oauth.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Queue } from '../../../../base/common/async.js';\n\nexport class DynamicAuthenticationProviderStorageService extends Disposable implements IDynamicAuthenticationProviderStorageService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly PROVIDERS_STORAGE_KEY = 'dynamicAuthProviders';\n\n\tprivate readonly _onDidChangeTokens = this._register(new Emitter<DynamicAuthenticationProviderTokensChangeEvent>());\n\treadonly onDidChangeTokens: Event<DynamicAuthenticationProviderTokensChangeEvent> = this._onDidChangeTokens.event;\n\n\tconstructor(\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t\t@ISecretStorageService private readonly secretStorageService: ISecretStorageService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\t// Listen for secret storage changes and emit events for dynamic auth provider token changes\n\t\tconst queue = new Queue<void>();\n\t\tthis._register(this.secretStorageService.onDidChangeSecret(async (key: string) => {\n\t\t\tlet payload: { isDynamicAuthProvider: boolean; authProviderId: string; clientId: string } | undefined;\n\t\t\ttry {\n\t\t\t\tpayload = JSON.parse(key);\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore errors... must not be a dynamic auth provider\n\t\t\t}\n\t\t\tif (payload?.isDynamicAuthProvider) {\n\t\t\t\tvoid queue.queue(async () => {\n\t\t\t\t\tconst tokens = await this.getSessionsForDynamicAuthProvider(payload.authProviderId, payload.clientId);\n\t\t\t\t\tthis._onDidChangeTokens.fire({\n\t\t\t\t\t\tauthProviderId: payload.authProviderId,\n\t\t\t\t\t\tclientId: payload.clientId,\n\t\t\t\t\t\ttokens\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}));\n\t}\n\n\tasync getClientRegistration(providerId: string): Promise<{ clientId?: string; clientSecret?: string } | undefined> {\n\t\t// First try new combined SecretStorage format\n\t\tconst key = `dynamicAuthProvider:clientRegistration:${providerId}`;\n\t\tconst credentialsValue = await this.secretStorageService.get(key);\n\t\tif (credentialsValue) {\n\t\t\ttry {\n\t\t\t\tconst credentials = JSON.parse(credentialsValue);\n\t\t\t\tif (credentials && (credentials.clientId || credentials.clientSecret)) {\n\t\t\t\t\treturn credentials;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\tawait this.secretStorageService.delete(key);\n\t\t\t}\n\t\t}\n\n\t\t// Just grab the client id from the provider\n\t\tconst providers = this._getStoredProviders();\n\t\tconst provider = providers.find(p => p.providerId === providerId);\n\t\treturn provider?.clientId ? { clientId: provider.clientId } : undefined;\n\t}\n\n\tgetClientId(providerId: string): string | undefined {\n\t\t// For backward compatibility, try old storage format first\n\t\tconst providers = this._getStoredProviders();\n\t\tconst provider = providers.find(p => p.providerId === providerId);\n\t\treturn provider?.clientId;\n\t}\n\n\tasync storeClientRegistration(providerId: string, authorizationServer: string, clientId: string, clientSecret?: string, label?: string): Promise<void> {\n\t\t// Store provider information for backward compatibility and UI display\n\t\tthis._trackProvider(providerId, authorizationServer, clientId, label);\n\n\t\t// Store both client ID and secret together in SecretStorage\n\t\tconst key = `dynamicAuthProvider:clientRegistration:${providerId}`;\n\t\tconst credentials = { clientId, clientSecret };\n\t\tawait this.secretStorageService.set(key, JSON.stringify(credentials));\n\t}\n\n\tprivate _trackProvider(providerId: string, authorizationServer: string, clientId: string, label?: string): void {\n\t\tconst providers = this._getStoredProviders();\n\n\t\t// Check if provider already exists\n\t\tconst existingProviderIndex = providers.findIndex(p => p.providerId === providerId);\n\t\tif (existingProviderIndex === -1) {\n\t\t\t// Add new provider with provided or default info\n\t\t\tconst newProvider: DynamicAuthenticationProviderInfo = {\n\t\t\t\tproviderId,\n\t\t\t\tlabel: label || providerId, // Use provided label or providerId as default\n\t\t\t\tauthorizationServer,\n\t\t\t\tclientId\n\t\t\t};\n\t\t\tproviders.push(newProvider);\n\t\t\tthis._storeProviders(providers);\n\t\t} else {\n\t\t\tconst existingProvider = providers[existingProviderIndex];\n\t\t\t// Create new provider object with updated info\n\t\t\tconst updatedProvider: DynamicAuthenticationProviderInfo = {\n\t\t\t\tproviderId,\n\t\t\t\tlabel: label || existingProvider.label,\n\t\t\t\tauthorizationServer,\n\t\t\t\tclientId\n\t\t\t};\n\t\t\tproviders[existingProviderIndex] = updatedProvider;\n\t\t\tthis._storeProviders(providers);\n\t\t}\n\t}\n\n\tprivate _getStoredProviders(): DynamicAuthenticationProviderInfo[] {\n\t\tconst stored = this.storageService.get(DynamicAuthenticationProviderStorageService.PROVIDERS_STORAGE_KEY, StorageScope.APPLICATION, '[]');\n\t\ttry {\n\t\t\tconst providerInfos = JSON.parse(stored);\n\t\t\t// MIGRATION: remove after an iteration or 2\n\t\t\tfor (const providerInfo of providerInfos) {\n\t\t\t\tif (!providerInfo.authorizationServer) {\n\t\t\t\t\tproviderInfo.authorizationServer = providerInfo.issuer;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn providerInfos;\n\t\t} catch {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate _storeProviders(providers: DynamicAuthenticationProviderInfo[]): void {\n\t\tthis.storageService.store(\n\t\t\tDynamicAuthenticationProviderStorageService.PROVIDERS_STORAGE_KEY,\n\t\t\tJSON.stringify(providers),\n\t\t\tStorageScope.APPLICATION,\n\t\t\tStorageTarget.MACHINE\n\t\t);\n\t}\n\n\tgetInteractedProviders(): ReadonlyArray<DynamicAuthenticationProviderInfo> {\n\t\treturn this._getStoredProviders();\n\t}\n\n\tasync removeDynamicProvider(providerId: string): Promise<void> {\n\t\t// Get provider info before removal for secret cleanup\n\t\tconst providers = this._getStoredProviders();\n\t\tconst providerInfo = providers.find(p => p.providerId === providerId);\n\n\t\t// Remove from stored providers\n\t\tconst filteredProviders = providers.filter(p => p.providerId !== providerId);\n\t\tthis._storeProviders(filteredProviders);\n\n\t\t// Remove sessions from secret storage if we have the provider info\n\t\tif (providerInfo) {\n\t\t\tconst secretKey = JSON.stringify({ isDynamicAuthProvider: true, authProviderId: providerId, clientId: providerInfo.clientId });\n\t\t\tawait this.secretStorageService.delete(secretKey);\n\t\t}\n\n\t\t// Remove client credentials from new SecretStorage format\n\t\tconst credentialsKey = `dynamicAuthProvider:clientRegistration:${providerId}`;\n\t\tawait this.secretStorageService.delete(credentialsKey);\n\t}\n\n\tasync getSessionsForDynamicAuthProvider(authProviderId: string, clientId: string): Promise<(IAuthorizationTokenResponse & { created_at: number })[] | undefined> {\n\t\tconst key = JSON.stringify({ isDynamicAuthProvider: true, authProviderId, clientId });\n\t\tconst value = await this.secretStorageService.get(key);\n\t\tif (value) {\n\t\t\tconst parsed = JSON.parse(value);\n\t\t\tif (!Array.isArray(parsed) || !parsed.every((t) => typeof t.created_at === 'number' && isAuthorizationTokenResponse(t))) {\n\t\t\t\tthis.logService.error(`Invalid session data for ${authProviderId} (${clientId}) in secret storage:`, parsed);\n\t\t\t\tawait this.secretStorageService.delete(key);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn parsed;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tasync setSessionsForDynamicAuthProvider(authProviderId: string, clientId: string, sessions: (IAuthorizationTokenResponse & { created_at: number })[]): Promise<void> {\n\t\tconst key = JSON.stringify({ isDynamicAuthProvider: true, authProviderId, clientId });\n\t\tconst value = JSON.stringify(sessions);\n\t\tawait this.secretStorageService.set(key, value);\n\t\tthis.logService.trace(`Set session data for ${authProviderId} (${clientId}) in secret storage:`, sessions);\n\t}\n}\n\nregisterSingleton(IDynamicAuthenticationProviderStorageService, DynamicAuthenticationProviderStorageService, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { IDynamicAuthenticationProviderStorageService, DynamicAuthenticationProviderInfo, DynamicAuthenticationProviderTokensChangeEvent } from '../common/dynamicAuthenticationProviderStorage.js';\nimport { ISecretStorageService } from '../../../../platform/secrets/common/secrets.js';\nimport { IAuthorizationTokenResponse, isAuthorizationTokenResponse } from '../../../../base/common/oauth.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Queue } from '../../../../base/common/async.js';\n\nexport class DynamicAuthenticationProviderStorageService extends Disposable implements IDynamicAuthenticationProviderStorageService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly PROVIDERS_STORAGE_KEY = 'dynamicAuthProviders';\n\n\tprivate readonly _onDidChangeTokens = this._register(new Emitter<DynamicAuthenticationProviderTokensChangeEvent>());\n\treadonly onDidChangeTokens: Event<DynamicAuthenticationProviderTokensChangeEvent> = this._onDidChangeTokens.event;\n\n\tconstructor(\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t\t@ISecretStorageService private readonly secretStorageService: ISecretStorageService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\t// Listen for secret storage changes and emit events for dynamic auth provider token changes\n\t\tconst queue = new Queue<void>();\n\t\tthis._register(this.secretStorageService.onDidChangeSecret(async (key: string) => {\n\t\t\tlet payload: { isDynamicAuthProvider: boolean; authProviderId: string; clientId: string } | undefined;\n\t\t\ttry {\n\t\t\t\tpayload = JSON.parse(key);\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore errors... must not be a dynamic auth provider\n\t\t\t}\n\t\t\tif (payload?.isDynamicAuthProvider) {\n\t\t\t\tvoid queue.queue(async () => {\n\t\t\t\t\tconst tokens = await this.getSessionsForDynamicAuthProvider(payload.authProviderId, payload.clientId);\n\t\t\t\t\tthis._onDidChangeTokens.fire({\n\t\t\t\t\t\tauthProviderId: payload.authProviderId,\n\t\t\t\t\t\tclientId: payload.clientId,\n\t\t\t\t\t\ttokens\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}));\n\t}\n\n\tasync getClientRegistration(providerId: string): Promise<{ clientId?: string; clientSecret?: string } | undefined> {\n\t\t// First try new combined SecretStorage format\n\t\tconst key = `dynamicAuthProvider:clientRegistration:${providerId}`;\n\t\tconst credentialsValue = await this.secretStorageService.get(key);\n\t\tif (credentialsValue) {\n\t\t\ttry {\n\t\t\t\tconst credentials = JSON.parse(credentialsValue);\n\t\t\t\tif (credentials && (credentials.clientId || credentials.clientSecret)) {\n\t\t\t\t\treturn credentials;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\tawait this.secretStorageService.delete(key);\n\t\t\t}\n\t\t}\n\n\t\t// Just grab the client id from the provider\n\t\tconst providers = this._getStoredProviders();\n\t\tconst provider = providers.find(p => p.providerId === providerId);\n\t\treturn provider?.clientId ? { clientId: provider.clientId } : undefined;\n\t}\n\n\tgetClientId(providerId: string): string | undefined {\n\t\t// For backward compatibility, try old storage format first\n\t\tconst providers = this._getStoredProviders();\n\t\tconst provider = providers.find(p => p.providerId === providerId);\n\t\treturn provider?.clientId;\n\t}\n\n\tasync storeClientRegistration(providerId: string, authorizationServer: string, clientId: string, clientSecret?: string, label?: string): Promise<void> {\n\t\t// Store provider information for backward compatibility and UI display\n\t\tthis._trackProvider(providerId, authorizationServer, clientId, label);\n\n\t\t// Store both client ID and secret together in SecretStorage\n\t\tconst key = `dynamicAuthProvider:clientRegistration:${providerId}`;\n\t\tconst credentials = { clientId, clientSecret };\n\t\tawait this.secretStorageService.set(key, JSON.stringify(credentials));\n\t}\n\n\tprivate _trackProvider(providerId: string, authorizationServer: string, clientId: string, label?: string): void {\n\t\tconst providers = this._getStoredProviders();\n\n\t\t// Check if provider already exists\n\t\tconst existingProviderIndex = providers.findIndex(p => p.providerId === providerId);\n\t\tif (existingProviderIndex === -1) {\n\t\t\t// Add new provider with provided or default info\n\t\t\tconst newProvider: DynamicAuthenticationProviderInfo = {\n\t\t\t\tproviderId,\n\t\t\t\tlabel: label || providerId, // Use provided label or providerId as default\n\t\t\t\tauthorizationServer,\n\t\t\t\tclientId\n\t\t\t};\n\t\t\tproviders.push(newProvider);\n\t\t\tthis._storeProviders(providers);\n\t\t} else {\n\t\t\tconst existingProvider = providers[existingProviderIndex];\n\t\t\t// Create new provider object with updated info\n\t\t\tconst updatedProvider: DynamicAuthenticationProviderInfo = {\n\t\t\t\tproviderId,\n\t\t\t\tlabel: label || existingProvider.label,\n\t\t\t\tauthorizationServer,\n\t\t\t\tclientId\n\t\t\t};\n\t\t\tproviders[existingProviderIndex] = updatedProvider;\n\t\t\tthis._storeProviders(providers);\n\t\t}\n\t}\n\n\tprivate _getStoredProviders(): DynamicAuthenticationProviderInfo[] {\n\t\tconst stored = this.storageService.get(DynamicAuthenticationProviderStorageService.PROVIDERS_STORAGE_KEY, StorageScope.APPLICATION, '[]');\n\t\ttry {\n\t\t\tconst providerInfos = JSON.parse(stored);\n\t\t\t// MIGRATION: remove after an iteration or 2\n\t\t\tfor (const providerInfo of providerInfos) {\n\t\t\t\tif (!providerInfo.authorizationServer) {\n\t\t\t\t\tproviderInfo.authorizationServer = providerInfo.issuer;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn providerInfos;\n\t\t} catch {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate _storeProviders(providers: DynamicAuthenticationProviderInfo[]): void {\n\t\tthis.storageService.store(\n\t\t\tDynamicAuthenticationProviderStorageService.PROVIDERS_STORAGE_KEY,\n\t\t\tJSON.stringify(providers),\n\t\t\tStorageScope.APPLICATION,\n\t\t\tStorageTarget.MACHINE\n\t\t);\n\t}\n\n\tgetInteractedProviders(): ReadonlyArray<DynamicAuthenticationProviderInfo> {\n\t\treturn this._getStoredProviders();\n\t}\n\n\tasync removeDynamicProvider(providerId: string): Promise<void> {\n\t\t// Get provider info before removal for secret cleanup\n\t\tconst providers = this._getStoredProviders();\n\t\tconst providerInfo = providers.find(p => p.providerId === providerId);\n\n\t\t// Remove from stored providers\n\t\tconst filteredProviders = providers.filter(p => p.providerId !== providerId);\n\t\tthis._storeProviders(filteredProviders);\n\n\t\t// Remove sessions from secret storage if we have the provider info\n\t\tif (providerInfo) {\n\t\t\tconst secretKey = JSON.stringify({ isDynamicAuthProvider: true, authProviderId: providerId, clientId: providerInfo.clientId });\n\t\t\tawait this.secretStorageService.delete(secretKey);\n\t\t}\n\n\t\t// Remove client credentials from new SecretStorage format\n\t\tconst credentialsKey = `dynamicAuthProvider:clientRegistration:${providerId}`;\n\t\tawait this.secretStorageService.delete(credentialsKey);\n\t}\n\n\tasync getSessionsForDynamicAuthProvider(authProviderId: string, clientId: string): Promise<(IAuthorizationTokenResponse & { created_at: number })[] | undefined> {\n\t\tconst key = JSON.stringify({ isDynamicAuthProvider: true, authProviderId, clientId });\n\t\tconst value = await this.secretStorageService.get(key);\n\t\tif (value) {\n\t\t\tconst parsed = JSON.parse(value);\n\t\t\tif (!Array.isArray(parsed) || !parsed.every((t) => typeof t.created_at === 'number' && isAuthorizationTokenResponse(t))) {\n\t\t\t\tthis.logService.error(`Invalid session data for ${authProviderId} (${clientId}) in secret storage:`, parsed);\n\t\t\t\tawait this.secretStorageService.delete(key);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn parsed;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tasync setSessionsForDynamicAuthProvider(authProviderId: string, clientId: string, sessions: (IAuthorizationTokenResponse & { created_at: number })[]): Promise<void> {\n\t\tconst key = JSON.stringify({ isDynamicAuthProvider: true, authProviderId, clientId });\n\t\tconst value = JSON.stringify(sessions);\n\t\tawait this.secretStorageService.set(key, value);\n\t\tthis.logService.trace(`Set session data for ${authProviderId} (${clientId}) in secret storage:`, sessions);\n\t}\n}\n\nregisterSingleton(IDynamicAuthenticationProviderStorageService, DynamicAuthenticationProviderStorageService, InstantiationType.Delayed);\n"]}