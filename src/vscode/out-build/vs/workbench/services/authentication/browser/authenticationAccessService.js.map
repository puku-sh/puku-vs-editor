{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/authentication/browser/authenticationAccessService.ts","vs/workbench/services/authentication/browser/authenticationAccessService.ts"],"names":[],"mappings":"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","file":"authenticationAccessService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { AllowedExtension } from '../common/authentication.js';\n\nexport const IAuthenticationAccessService = createDecorator<IAuthenticationAccessService>('IAuthenticationAccessService');\nexport interface IAuthenticationAccessService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidChangeExtensionSessionAccess: Event<{ providerId: string; accountName: string }>;\n\n\t/**\n\t * Check extension access to an account\n\t * @param providerId The id of the authentication provider\n\t * @param accountName The account name that access is checked for\n\t * @param extensionId The id of the extension requesting access\n\t * @returns Returns true or false if the user has opted to permanently grant or disallow access, and undefined\n\t * if they haven't made a choice yet\n\t */\n\tisAccessAllowed(providerId: string, accountName: string, extensionId: string): boolean | undefined;\n\treadAllowedExtensions(providerId: string, accountName: string): AllowedExtension[];\n\tupdateAllowedExtensions(providerId: string, accountName: string, extensions: AllowedExtension[]): void;\n\tremoveAllowedExtensions(providerId: string, accountName: string): void;\n}\n\n// TODO@TylerLeonhardt: Move this class to MainThreadAuthentication\n// TODO@TylerLeonhardt: Should this class only keep track of allowed things and throw away disallowed ones?\nexport class AuthenticationAccessService extends Disposable implements IAuthenticationAccessService {\n\t_serviceBrand: undefined;\n\n\tprivate _onDidChangeExtensionSessionAccess: Emitter<{ providerId: string; accountName: string }> = this._register(new Emitter<{ providerId: string; accountName: string }>());\n\treadonly onDidChangeExtensionSessionAccess: Event<{ providerId: string; accountName: string }> = this._onDidChangeExtensionSessionAccess.event;\n\n\tconstructor(\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t\t@IProductService private readonly _productService: IProductService\n\t) {\n\t\tsuper();\n\t}\n\n\tisAccessAllowed(providerId: string, accountName: string, extensionId: string): boolean | undefined {\n\t\tconst trustedExtensionAuthAccess = this._productService.trustedExtensionAuthAccess;\n\t\tconst extensionKey = ExtensionIdentifier.toKey(extensionId);\n\t\tif (Array.isArray(trustedExtensionAuthAccess)) {\n\t\t\tif (trustedExtensionAuthAccess.includes(extensionKey)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (trustedExtensionAuthAccess?.[providerId]?.includes(extensionKey)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst allowList = this.readAllowedExtensions(providerId, accountName);\n\t\tconst extensionData = allowList.find(extension => extension.id === extensionKey);\n\t\tif (!extensionData) {\n\t\t\treturn undefined;\n\t\t}\n\t\t// This property didn't exist on this data previously, inclusion in the list at all indicates allowance\n\t\treturn extensionData.allowed !== undefined\n\t\t\t? extensionData.allowed\n\t\t\t: true;\n\t}\n\n\treadAllowedExtensions(providerId: string, accountName: string): AllowedExtension[] {\n\t\tlet trustedExtensions: AllowedExtension[] = [];\n\t\ttry {\n\t\t\tconst trustedExtensionSrc = this._storageService.get(`${providerId}-${accountName}`, StorageScope.APPLICATION);\n\t\t\tif (trustedExtensionSrc) {\n\t\t\t\ttrustedExtensions = JSON.parse(trustedExtensionSrc);\n\t\t\t}\n\t\t} catch (err) { }\n\n\t\t// Add trusted extensions from product.json if they're not already in the list\n\t\tconst trustedExtensionAuthAccess = this._productService.trustedExtensionAuthAccess;\n\t\tconst trustedExtensionIds =\n\t\t\t// Case 1: trustedExtensionAuthAccess is an array\n\t\t\tArray.isArray(trustedExtensionAuthAccess)\n\t\t\t\t? trustedExtensionAuthAccess\n\t\t\t\t// Case 2: trustedExtensionAuthAccess is an object\n\t\t\t\t: typeof trustedExtensionAuthAccess === 'object'\n\t\t\t\t\t? trustedExtensionAuthAccess[providerId] ?? []\n\t\t\t\t\t: [];\n\n\t\tfor (const extensionId of trustedExtensionIds) {\n\t\t\tconst extensionKey = ExtensionIdentifier.toKey(extensionId);\n\t\t\tconst existingExtension = trustedExtensions.find(extension => extension.id === extensionKey);\n\t\t\tif (!existingExtension) {\n\t\t\t\t// Add new trusted extension (name will be set by caller if they have extension info)\n\t\t\t\ttrustedExtensions.push({\n\t\t\t\t\tid: extensionKey,\n\t\t\t\t\tname: extensionId, // Use original casing for display name\n\t\t\t\t\tallowed: true,\n\t\t\t\t\ttrusted: true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Update existing extension to be trusted\n\t\t\t\texistingExtension.allowed = true;\n\t\t\t\texistingExtension.trusted = true;\n\t\t\t}\n\t\t}\n\n\t\treturn trustedExtensions;\n\t}\n\n\tupdateAllowedExtensions(providerId: string, accountName: string, extensions: AllowedExtension[]): void {\n\t\tconst allowList = this.readAllowedExtensions(providerId, accountName);\n\t\tfor (const extension of extensions) {\n\t\t\tconst extensionKey = ExtensionIdentifier.toKey(extension.id);\n\t\t\tconst index = allowList.findIndex(e => e.id === extensionKey);\n\t\t\tif (index === -1) {\n\t\t\t\tallowList.push({\n\t\t\t\t\t...extension,\n\t\t\t\t\tid: extensionKey\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tallowList[index].allowed = extension.allowed;\n\t\t\t\t// Update name if provided and not already set to a proper name\n\t\t\t\tif (extension.name && extension.name !== extensionKey && allowList[index].name !== extension.name) {\n\t\t\t\t\tallowList[index].name = extension.name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filter out trusted extensions before storing - they should only come from product.json, not user storage\n\t\tconst userManagedExtensions = allowList.filter(extension => !extension.trusted);\n\t\tthis._storageService.store(`${providerId}-${accountName}`, JSON.stringify(userManagedExtensions), StorageScope.APPLICATION, StorageTarget.USER);\n\t\tthis._onDidChangeExtensionSessionAccess.fire({ providerId, accountName });\n\t}\n\n\tremoveAllowedExtensions(providerId: string, accountName: string): void {\n\t\tthis._storageService.remove(`${providerId}-${accountName}`, StorageScope.APPLICATION);\n\t\tthis._onDidChangeExtensionSessionAccess.fire({ providerId, accountName });\n\t}\n}\n\nregisterSingleton(IAuthenticationAccessService, AuthenticationAccessService, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IProductService } from '../../../../platform/product/common/productService.js';\nimport { IStorageService, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { AllowedExtension } from '../common/authentication.js';\n\nexport const IAuthenticationAccessService = createDecorator<IAuthenticationAccessService>('IAuthenticationAccessService');\nexport interface IAuthenticationAccessService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidChangeExtensionSessionAccess: Event<{ providerId: string; accountName: string }>;\n\n\t/**\n\t * Check extension access to an account\n\t * @param providerId The id of the authentication provider\n\t * @param accountName The account name that access is checked for\n\t * @param extensionId The id of the extension requesting access\n\t * @returns Returns true or false if the user has opted to permanently grant or disallow access, and undefined\n\t * if they haven't made a choice yet\n\t */\n\tisAccessAllowed(providerId: string, accountName: string, extensionId: string): boolean | undefined;\n\treadAllowedExtensions(providerId: string, accountName: string): AllowedExtension[];\n\tupdateAllowedExtensions(providerId: string, accountName: string, extensions: AllowedExtension[]): void;\n\tremoveAllowedExtensions(providerId: string, accountName: string): void;\n}\n\n// TODO@TylerLeonhardt: Move this class to MainThreadAuthentication\n// TODO@TylerLeonhardt: Should this class only keep track of allowed things and throw away disallowed ones?\nexport class AuthenticationAccessService extends Disposable implements IAuthenticationAccessService {\n\t_serviceBrand: undefined;\n\n\tprivate _onDidChangeExtensionSessionAccess: Emitter<{ providerId: string; accountName: string }> = this._register(new Emitter<{ providerId: string; accountName: string }>());\n\treadonly onDidChangeExtensionSessionAccess: Event<{ providerId: string; accountName: string }> = this._onDidChangeExtensionSessionAccess.event;\n\n\tconstructor(\n\t\t@IStorageService private readonly _storageService: IStorageService,\n\t\t@IProductService private readonly _productService: IProductService\n\t) {\n\t\tsuper();\n\t}\n\n\tisAccessAllowed(providerId: string, accountName: string, extensionId: string): boolean | undefined {\n\t\tconst trustedExtensionAuthAccess = this._productService.trustedExtensionAuthAccess;\n\t\tconst extensionKey = ExtensionIdentifier.toKey(extensionId);\n\t\tif (Array.isArray(trustedExtensionAuthAccess)) {\n\t\t\tif (trustedExtensionAuthAccess.includes(extensionKey)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (trustedExtensionAuthAccess?.[providerId]?.includes(extensionKey)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst allowList = this.readAllowedExtensions(providerId, accountName);\n\t\tconst extensionData = allowList.find(extension => extension.id === extensionKey);\n\t\tif (!extensionData) {\n\t\t\treturn undefined;\n\t\t}\n\t\t// This property didn't exist on this data previously, inclusion in the list at all indicates allowance\n\t\treturn extensionData.allowed !== undefined\n\t\t\t? extensionData.allowed\n\t\t\t: true;\n\t}\n\n\treadAllowedExtensions(providerId: string, accountName: string): AllowedExtension[] {\n\t\tlet trustedExtensions: AllowedExtension[] = [];\n\t\ttry {\n\t\t\tconst trustedExtensionSrc = this._storageService.get(`${providerId}-${accountName}`, StorageScope.APPLICATION);\n\t\t\tif (trustedExtensionSrc) {\n\t\t\t\ttrustedExtensions = JSON.parse(trustedExtensionSrc);\n\t\t\t}\n\t\t} catch (err) { }\n\n\t\t// Add trusted extensions from product.json if they're not already in the list\n\t\tconst trustedExtensionAuthAccess = this._productService.trustedExtensionAuthAccess;\n\t\tconst trustedExtensionIds =\n\t\t\t// Case 1: trustedExtensionAuthAccess is an array\n\t\t\tArray.isArray(trustedExtensionAuthAccess)\n\t\t\t\t? trustedExtensionAuthAccess\n\t\t\t\t// Case 2: trustedExtensionAuthAccess is an object\n\t\t\t\t: typeof trustedExtensionAuthAccess === 'object'\n\t\t\t\t\t? trustedExtensionAuthAccess[providerId] ?? []\n\t\t\t\t\t: [];\n\n\t\tfor (const extensionId of trustedExtensionIds) {\n\t\t\tconst extensionKey = ExtensionIdentifier.toKey(extensionId);\n\t\t\tconst existingExtension = trustedExtensions.find(extension => extension.id === extensionKey);\n\t\t\tif (!existingExtension) {\n\t\t\t\t// Add new trusted extension (name will be set by caller if they have extension info)\n\t\t\t\ttrustedExtensions.push({\n\t\t\t\t\tid: extensionKey,\n\t\t\t\t\tname: extensionId, // Use original casing for display name\n\t\t\t\t\tallowed: true,\n\t\t\t\t\ttrusted: true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Update existing extension to be trusted\n\t\t\t\texistingExtension.allowed = true;\n\t\t\t\texistingExtension.trusted = true;\n\t\t\t}\n\t\t}\n\n\t\treturn trustedExtensions;\n\t}\n\n\tupdateAllowedExtensions(providerId: string, accountName: string, extensions: AllowedExtension[]): void {\n\t\tconst allowList = this.readAllowedExtensions(providerId, accountName);\n\t\tfor (const extension of extensions) {\n\t\t\tconst extensionKey = ExtensionIdentifier.toKey(extension.id);\n\t\t\tconst index = allowList.findIndex(e => e.id === extensionKey);\n\t\t\tif (index === -1) {\n\t\t\t\tallowList.push({\n\t\t\t\t\t...extension,\n\t\t\t\t\tid: extensionKey\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tallowList[index].allowed = extension.allowed;\n\t\t\t\t// Update name if provided and not already set to a proper name\n\t\t\t\tif (extension.name && extension.name !== extensionKey && allowList[index].name !== extension.name) {\n\t\t\t\t\tallowList[index].name = extension.name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filter out trusted extensions before storing - they should only come from product.json, not user storage\n\t\tconst userManagedExtensions = allowList.filter(extension => !extension.trusted);\n\t\tthis._storageService.store(`${providerId}-${accountName}`, JSON.stringify(userManagedExtensions), StorageScope.APPLICATION, StorageTarget.USER);\n\t\tthis._onDidChangeExtensionSessionAccess.fire({ providerId, accountName });\n\t}\n\n\tremoveAllowedExtensions(providerId: string, accountName: string): void {\n\t\tthis._storageService.remove(`${providerId}-${accountName}`, StorageScope.APPLICATION);\n\t\tthis._onDidChangeExtensionSessionAccess.fire({ providerId, accountName });\n\t}\n}\n\nregisterSingleton(IAuthenticationAccessService, AuthenticationAccessService, InstantiationType.Delayed);\n"]}