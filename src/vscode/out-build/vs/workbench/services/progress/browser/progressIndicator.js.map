{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/progress/browser/progressIndicator.ts","vs/workbench/services/progress/browser/progressIndicator.ts"],"names":[],"mappings":"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","file":"progressIndicator.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ProgressBar } from '../../../../base/browser/ui/progressbar/progressbar.js';\nimport { IProgressRunner, IProgressIndicator, emptyProgressRunner } from '../../../../platform/progress/common/progress.js';\nimport { IEditorGroupView } from '../../../browser/parts/editor/editor.js';\nimport { GroupModelChangeKind } from '../../../common/editor.js';\n\nexport class EditorProgressIndicator extends Disposable implements IProgressIndicator {\n\n\tconstructor(\n\t\tprivate readonly progressBar: ProgressBar,\n\t\tprivate readonly group: IEditorGroupView\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Stop any running progress when the active editor changes or\n\t\t// the group becomes empty.\n\t\t// In contrast to the composite progress indicator, we do not\n\t\t// track active editor progress and replay it later (yet).\n\t\tthis._register(this.group.onDidModelChange(e => {\n\t\t\tif (\n\t\t\t\te.kind === GroupModelChangeKind.EDITOR_ACTIVE ||\n\t\t\t\t(e.kind === GroupModelChangeKind.EDITOR_CLOSE && this.group.isEmpty)\n\t\t\t) {\n\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t}\n\t\t}));\n\t}\n\n\tshow(infinite: true, delay?: number): IProgressRunner;\n\tshow(total: number, delay?: number): IProgressRunner;\n\tshow(infiniteOrTotal: true | number, delay?: number): IProgressRunner {\n\n\t\t// No editor open: ignore any progress reporting\n\t\tif (this.group.isEmpty) {\n\t\t\treturn emptyProgressRunner;\n\t\t}\n\n\t\tif (infiniteOrTotal === true) {\n\t\t\treturn this.doShow(true, delay);\n\t\t}\n\n\t\treturn this.doShow(infiniteOrTotal, delay);\n\t}\n\n\tprivate doShow(infinite: true, delay?: number): IProgressRunner;\n\tprivate doShow(total: number, delay?: number): IProgressRunner;\n\tprivate doShow(infiniteOrTotal: true | number, delay?: number): IProgressRunner {\n\t\tif (typeof infiniteOrTotal === 'boolean') {\n\t\t\tthis.progressBar.infinite().show(delay);\n\t\t} else {\n\t\t\tthis.progressBar.total(infiniteOrTotal).show(delay);\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: (total: number) => {\n\t\t\t\tthis.progressBar.total(total);\n\t\t\t},\n\n\t\t\tworked: (worked: number) => {\n\t\t\t\tif (this.progressBar.hasTotal()) {\n\t\t\t\t\tthis.progressBar.worked(worked);\n\t\t\t\t} else {\n\t\t\t\t\tthis.progressBar.infinite().show();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdone: () => {\n\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t}\n\t\t};\n\t}\n\n\tasync showWhile(promise: Promise<unknown>, delay?: number): Promise<void> {\n\n\t\t// No editor open: ignore any progress reporting\n\t\tif (this.group.isEmpty) {\n\t\t\ttry {\n\t\t\t\tawait promise;\n\t\t\t} catch (error) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\n\t\treturn this.doShowWhile(promise, delay);\n\t}\n\n\tprivate async doShowWhile(promise: Promise<unknown>, delay?: number): Promise<void> {\n\t\ttry {\n\t\t\tthis.progressBar.infinite().show(delay);\n\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t} finally {\n\t\t\tthis.progressBar.stop().hide();\n\t\t}\n\t}\n}\n\nnamespace ProgressIndicatorState {\n\n\texport const enum Type {\n\t\tNone,\n\t\tDone,\n\t\tInfinite,\n\t\tWhile,\n\t\tWork\n\t}\n\n\texport const None = { type: Type.None } as const;\n\texport const Done = { type: Type.Done } as const;\n\texport const Infinite = { type: Type.Infinite } as const;\n\n\texport class While {\n\n\t\treadonly type = Type.While;\n\n\t\tconstructor(\n\t\t\treadonly whilePromise: Promise<unknown>,\n\t\t\treadonly whileStart: number,\n\t\t\treadonly whileDelay: number,\n\t\t) { }\n\t}\n\n\texport class Work {\n\n\t\treadonly type = Type.Work;\n\n\t\tconstructor(\n\t\t\treadonly total: number | undefined,\n\t\t\treadonly worked: number | undefined\n\t\t) { }\n\t}\n\n\texport type State =\n\t\ttypeof None\n\t\t| typeof Done\n\t\t| typeof Infinite\n\t\t| While\n\t\t| Work;\n}\n\nexport interface IProgressScope {\n\n\t/**\n\t * Fired whenever `isActive` value changed.\n\t */\n\treadonly onDidChangeActive: Event<void>;\n\n\t/**\n\t * Whether progress should be active or not.\n\t */\n\treadonly isActive: boolean;\n}\n\nexport class ScopedProgressIndicator extends Disposable implements IProgressIndicator {\n\n\tprivate progressState: ProgressIndicatorState.State = ProgressIndicatorState.None;\n\n\tconstructor(\n\t\tprivate readonly progressBar: ProgressBar,\n\t\tprivate readonly scope: IProgressScope\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tregisterListeners() {\n\t\tthis._register(this.scope.onDidChangeActive(() => {\n\t\t\tif (this.scope.isActive) {\n\t\t\t\tthis.onDidScopeActivate();\n\t\t\t} else {\n\t\t\t\tthis.onDidScopeDeactivate();\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate onDidScopeActivate(): void {\n\n\t\t// Return early if progress state indicates that progress is done\n\t\tif (this.progressState.type === ProgressIndicatorState.Done.type) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Replay Infinite Progress from Promise\n\t\tif (this.progressState.type === ProgressIndicatorState.Type.While) {\n\t\t\tlet delay: number | undefined;\n\t\t\tif (this.progressState.whileDelay > 0) {\n\t\t\t\tconst remainingDelay = this.progressState.whileDelay - (Date.now() - this.progressState.whileStart);\n\t\t\t\tif (remainingDelay > 0) {\n\t\t\t\t\tdelay = remainingDelay;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.doShowWhile(delay);\n\t\t}\n\n\t\t// Replay Infinite Progress\n\t\telse if (this.progressState.type === ProgressIndicatorState.Type.Infinite) {\n\t\t\tthis.progressBar.infinite().show();\n\t\t}\n\n\t\t// Replay Finite Progress (Total & Worked)\n\t\telse if (this.progressState.type === ProgressIndicatorState.Type.Work) {\n\t\t\tif (this.progressState.total) {\n\t\t\t\tthis.progressBar.total(this.progressState.total).show();\n\t\t\t}\n\n\t\t\tif (this.progressState.worked) {\n\t\t\t\tthis.progressBar.worked(this.progressState.worked).show();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidScopeDeactivate(): void {\n\t\tthis.progressBar.stop().hide();\n\t}\n\n\tshow(infinite: true, delay?: number): IProgressRunner;\n\tshow(total: number, delay?: number): IProgressRunner;\n\tshow(infiniteOrTotal: true | number, delay?: number): IProgressRunner {\n\n\t\t// Sort out Arguments\n\t\tif (typeof infiniteOrTotal === 'boolean') {\n\t\t\tthis.progressState = ProgressIndicatorState.Infinite;\n\t\t} else {\n\t\t\tthis.progressState = new ProgressIndicatorState.Work(infiniteOrTotal, undefined);\n\t\t}\n\n\t\t// Active: Show Progress\n\t\tif (this.scope.isActive) {\n\n\t\t\t// Infinite: Start Progressbar and Show after Delay\n\t\t\tif (this.progressState.type === ProgressIndicatorState.Type.Infinite) {\n\t\t\t\tthis.progressBar.infinite().show(delay);\n\t\t\t}\n\n\t\t\t// Finite: Start Progressbar and Show after Delay\n\t\t\telse if (this.progressState.type === ProgressIndicatorState.Type.Work && typeof this.progressState.total === 'number') {\n\t\t\t\tthis.progressBar.total(this.progressState.total).show(delay);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: (total: number) => {\n\t\t\t\tthis.progressState = new ProgressIndicatorState.Work(\n\t\t\t\t\ttotal,\n\t\t\t\t\tthis.progressState.type === ProgressIndicatorState.Type.Work ? this.progressState.worked : undefined);\n\n\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\tthis.progressBar.total(total);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tworked: (worked: number) => {\n\n\t\t\t\t// Verify first that we are either not active or the progressbar has a total set\n\t\t\t\tif (!this.scope.isActive || this.progressBar.hasTotal()) {\n\t\t\t\t\tthis.progressState = new ProgressIndicatorState.Work(\n\t\t\t\t\t\tthis.progressState.type === ProgressIndicatorState.Type.Work ? this.progressState.total : undefined,\n\t\t\t\t\t\tthis.progressState.type === ProgressIndicatorState.Type.Work && typeof this.progressState.worked === 'number' ? this.progressState.worked + worked : worked);\n\n\t\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\t\tthis.progressBar.worked(worked);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Otherwise the progress bar does not support worked(), we fallback to infinite() progress\n\t\t\t\telse {\n\t\t\t\t\tthis.progressState = ProgressIndicatorState.Infinite;\n\t\t\t\t\tthis.progressBar.infinite().show();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdone: () => {\n\t\t\t\tthis.progressState = ProgressIndicatorState.Done;\n\n\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tasync showWhile(promise: Promise<unknown>, delay?: number): Promise<void> {\n\n\t\t// Join with existing running promise to ensure progress is accurate\n\t\tif (this.progressState.type === ProgressIndicatorState.Type.While) {\n\t\t\tpromise = Promise.allSettled([promise, this.progressState.whilePromise]);\n\t\t}\n\n\t\t// Keep Promise in State\n\t\tthis.progressState = new ProgressIndicatorState.While(promise, delay || 0, Date.now());\n\n\t\ttry {\n\t\t\tthis.doShowWhile(delay);\n\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t} finally {\n\n\t\t\t// If this is not the last promise in the list of joined promises, skip this\n\t\t\tif (this.progressState.type !== ProgressIndicatorState.Type.While || this.progressState.whilePromise === promise) {\n\n\t\t\t\t// The while promise is either null or equal the promise we last hooked on\n\t\t\t\tthis.progressState = ProgressIndicatorState.None;\n\n\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doShowWhile(delay?: number): void {\n\n\t\t// Show Progress when active\n\t\tif (this.scope.isActive) {\n\t\t\tthis.progressBar.infinite().show(delay);\n\t\t}\n\t}\n}\n\nexport abstract class AbstractProgressScope extends Disposable implements IProgressScope {\n\n\tprivate readonly _onDidChangeActive = this._register(new Emitter<void>());\n\treadonly onDidChangeActive = this._onDidChangeActive.event;\n\n\tget isActive() { return this._isActive; }\n\n\tconstructor(\n\t\tprivate scopeId: string,\n\t\tprivate _isActive: boolean\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected onScopeOpened(scopeId: string) {\n\t\tif (scopeId === this.scopeId) {\n\t\t\tif (!this._isActive) {\n\t\t\t\tthis._isActive = true;\n\n\t\t\t\tthis._onDidChangeActive.fire();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected onScopeClosed(scopeId: string) {\n\t\tif (scopeId === this.scopeId) {\n\t\t\tif (this._isActive) {\n\t\t\t\tthis._isActive = false;\n\n\t\t\t\tthis._onDidChangeActive.fire();\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ProgressBar } from '../../../../base/browser/ui/progressbar/progressbar.js';\nimport { IProgressRunner, IProgressIndicator, emptyProgressRunner } from '../../../../platform/progress/common/progress.js';\nimport { IEditorGroupView } from '../../../browser/parts/editor/editor.js';\nimport { GroupModelChangeKind } from '../../../common/editor.js';\n\nexport class EditorProgressIndicator extends Disposable implements IProgressIndicator {\n\n\tconstructor(\n\t\tprivate readonly progressBar: ProgressBar,\n\t\tprivate readonly group: IEditorGroupView\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Stop any running progress when the active editor changes or\n\t\t// the group becomes empty.\n\t\t// In contrast to the composite progress indicator, we do not\n\t\t// track active editor progress and replay it later (yet).\n\t\tthis._register(this.group.onDidModelChange(e => {\n\t\t\tif (\n\t\t\t\te.kind === GroupModelChangeKind.EDITOR_ACTIVE ||\n\t\t\t\t(e.kind === GroupModelChangeKind.EDITOR_CLOSE && this.group.isEmpty)\n\t\t\t) {\n\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t}\n\t\t}));\n\t}\n\n\tshow(infinite: true, delay?: number): IProgressRunner;\n\tshow(total: number, delay?: number): IProgressRunner;\n\tshow(infiniteOrTotal: true | number, delay?: number): IProgressRunner {\n\n\t\t// No editor open: ignore any progress reporting\n\t\tif (this.group.isEmpty) {\n\t\t\treturn emptyProgressRunner;\n\t\t}\n\n\t\tif (infiniteOrTotal === true) {\n\t\t\treturn this.doShow(true, delay);\n\t\t}\n\n\t\treturn this.doShow(infiniteOrTotal, delay);\n\t}\n\n\tprivate doShow(infinite: true, delay?: number): IProgressRunner;\n\tprivate doShow(total: number, delay?: number): IProgressRunner;\n\tprivate doShow(infiniteOrTotal: true | number, delay?: number): IProgressRunner {\n\t\tif (typeof infiniteOrTotal === 'boolean') {\n\t\t\tthis.progressBar.infinite().show(delay);\n\t\t} else {\n\t\t\tthis.progressBar.total(infiniteOrTotal).show(delay);\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: (total: number) => {\n\t\t\t\tthis.progressBar.total(total);\n\t\t\t},\n\n\t\t\tworked: (worked: number) => {\n\t\t\t\tif (this.progressBar.hasTotal()) {\n\t\t\t\t\tthis.progressBar.worked(worked);\n\t\t\t\t} else {\n\t\t\t\t\tthis.progressBar.infinite().show();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdone: () => {\n\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t}\n\t\t};\n\t}\n\n\tasync showWhile(promise: Promise<unknown>, delay?: number): Promise<void> {\n\n\t\t// No editor open: ignore any progress reporting\n\t\tif (this.group.isEmpty) {\n\t\t\ttry {\n\t\t\t\tawait promise;\n\t\t\t} catch (error) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\n\t\treturn this.doShowWhile(promise, delay);\n\t}\n\n\tprivate async doShowWhile(promise: Promise<unknown>, delay?: number): Promise<void> {\n\t\ttry {\n\t\t\tthis.progressBar.infinite().show(delay);\n\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t} finally {\n\t\t\tthis.progressBar.stop().hide();\n\t\t}\n\t}\n}\n\nnamespace ProgressIndicatorState {\n\n\texport const enum Type {\n\t\tNone,\n\t\tDone,\n\t\tInfinite,\n\t\tWhile,\n\t\tWork\n\t}\n\n\texport const None = { type: Type.None } as const;\n\texport const Done = { type: Type.Done } as const;\n\texport const Infinite = { type: Type.Infinite } as const;\n\n\texport class While {\n\n\t\treadonly type = Type.While;\n\n\t\tconstructor(\n\t\t\treadonly whilePromise: Promise<unknown>,\n\t\t\treadonly whileStart: number,\n\t\t\treadonly whileDelay: number,\n\t\t) { }\n\t}\n\n\texport class Work {\n\n\t\treadonly type = Type.Work;\n\n\t\tconstructor(\n\t\t\treadonly total: number | undefined,\n\t\t\treadonly worked: number | undefined\n\t\t) { }\n\t}\n\n\texport type State =\n\t\ttypeof None\n\t\t| typeof Done\n\t\t| typeof Infinite\n\t\t| While\n\t\t| Work;\n}\n\nexport interface IProgressScope {\n\n\t/**\n\t * Fired whenever `isActive` value changed.\n\t */\n\treadonly onDidChangeActive: Event<void>;\n\n\t/**\n\t * Whether progress should be active or not.\n\t */\n\treadonly isActive: boolean;\n}\n\nexport class ScopedProgressIndicator extends Disposable implements IProgressIndicator {\n\n\tprivate progressState: ProgressIndicatorState.State = ProgressIndicatorState.None;\n\n\tconstructor(\n\t\tprivate readonly progressBar: ProgressBar,\n\t\tprivate readonly scope: IProgressScope\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tregisterListeners() {\n\t\tthis._register(this.scope.onDidChangeActive(() => {\n\t\t\tif (this.scope.isActive) {\n\t\t\t\tthis.onDidScopeActivate();\n\t\t\t} else {\n\t\t\t\tthis.onDidScopeDeactivate();\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate onDidScopeActivate(): void {\n\n\t\t// Return early if progress state indicates that progress is done\n\t\tif (this.progressState.type === ProgressIndicatorState.Done.type) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Replay Infinite Progress from Promise\n\t\tif (this.progressState.type === ProgressIndicatorState.Type.While) {\n\t\t\tlet delay: number | undefined;\n\t\t\tif (this.progressState.whileDelay > 0) {\n\t\t\t\tconst remainingDelay = this.progressState.whileDelay - (Date.now() - this.progressState.whileStart);\n\t\t\t\tif (remainingDelay > 0) {\n\t\t\t\t\tdelay = remainingDelay;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.doShowWhile(delay);\n\t\t}\n\n\t\t// Replay Infinite Progress\n\t\telse if (this.progressState.type === ProgressIndicatorState.Type.Infinite) {\n\t\t\tthis.progressBar.infinite().show();\n\t\t}\n\n\t\t// Replay Finite Progress (Total & Worked)\n\t\telse if (this.progressState.type === ProgressIndicatorState.Type.Work) {\n\t\t\tif (this.progressState.total) {\n\t\t\t\tthis.progressBar.total(this.progressState.total).show();\n\t\t\t}\n\n\t\t\tif (this.progressState.worked) {\n\t\t\t\tthis.progressBar.worked(this.progressState.worked).show();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidScopeDeactivate(): void {\n\t\tthis.progressBar.stop().hide();\n\t}\n\n\tshow(infinite: true, delay?: number): IProgressRunner;\n\tshow(total: number, delay?: number): IProgressRunner;\n\tshow(infiniteOrTotal: true | number, delay?: number): IProgressRunner {\n\n\t\t// Sort out Arguments\n\t\tif (typeof infiniteOrTotal === 'boolean') {\n\t\t\tthis.progressState = ProgressIndicatorState.Infinite;\n\t\t} else {\n\t\t\tthis.progressState = new ProgressIndicatorState.Work(infiniteOrTotal, undefined);\n\t\t}\n\n\t\t// Active: Show Progress\n\t\tif (this.scope.isActive) {\n\n\t\t\t// Infinite: Start Progressbar and Show after Delay\n\t\t\tif (this.progressState.type === ProgressIndicatorState.Type.Infinite) {\n\t\t\t\tthis.progressBar.infinite().show(delay);\n\t\t\t}\n\n\t\t\t// Finite: Start Progressbar and Show after Delay\n\t\t\telse if (this.progressState.type === ProgressIndicatorState.Type.Work && typeof this.progressState.total === 'number') {\n\t\t\t\tthis.progressBar.total(this.progressState.total).show(delay);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: (total: number) => {\n\t\t\t\tthis.progressState = new ProgressIndicatorState.Work(\n\t\t\t\t\ttotal,\n\t\t\t\t\tthis.progressState.type === ProgressIndicatorState.Type.Work ? this.progressState.worked : undefined);\n\n\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\tthis.progressBar.total(total);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tworked: (worked: number) => {\n\n\t\t\t\t// Verify first that we are either not active or the progressbar has a total set\n\t\t\t\tif (!this.scope.isActive || this.progressBar.hasTotal()) {\n\t\t\t\t\tthis.progressState = new ProgressIndicatorState.Work(\n\t\t\t\t\t\tthis.progressState.type === ProgressIndicatorState.Type.Work ? this.progressState.total : undefined,\n\t\t\t\t\t\tthis.progressState.type === ProgressIndicatorState.Type.Work && typeof this.progressState.worked === 'number' ? this.progressState.worked + worked : worked);\n\n\t\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\t\tthis.progressBar.worked(worked);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Otherwise the progress bar does not support worked(), we fallback to infinite() progress\n\t\t\t\telse {\n\t\t\t\t\tthis.progressState = ProgressIndicatorState.Infinite;\n\t\t\t\t\tthis.progressBar.infinite().show();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdone: () => {\n\t\t\t\tthis.progressState = ProgressIndicatorState.Done;\n\n\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tasync showWhile(promise: Promise<unknown>, delay?: number): Promise<void> {\n\n\t\t// Join with existing running promise to ensure progress is accurate\n\t\tif (this.progressState.type === ProgressIndicatorState.Type.While) {\n\t\t\tpromise = Promise.allSettled([promise, this.progressState.whilePromise]);\n\t\t}\n\n\t\t// Keep Promise in State\n\t\tthis.progressState = new ProgressIndicatorState.While(promise, delay || 0, Date.now());\n\n\t\ttry {\n\t\t\tthis.doShowWhile(delay);\n\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t} finally {\n\n\t\t\t// If this is not the last promise in the list of joined promises, skip this\n\t\t\tif (this.progressState.type !== ProgressIndicatorState.Type.While || this.progressState.whilePromise === promise) {\n\n\t\t\t\t// The while promise is either null or equal the promise we last hooked on\n\t\t\t\tthis.progressState = ProgressIndicatorState.None;\n\n\t\t\t\tif (this.scope.isActive) {\n\t\t\t\t\tthis.progressBar.stop().hide();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doShowWhile(delay?: number): void {\n\n\t\t// Show Progress when active\n\t\tif (this.scope.isActive) {\n\t\t\tthis.progressBar.infinite().show(delay);\n\t\t}\n\t}\n}\n\nexport abstract class AbstractProgressScope extends Disposable implements IProgressScope {\n\n\tprivate readonly _onDidChangeActive = this._register(new Emitter<void>());\n\treadonly onDidChangeActive = this._onDidChangeActive.event;\n\n\tget isActive() { return this._isActive; }\n\n\tconstructor(\n\t\tprivate scopeId: string,\n\t\tprivate _isActive: boolean\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected onScopeOpened(scopeId: string) {\n\t\tif (scopeId === this.scopeId) {\n\t\t\tif (!this._isActive) {\n\t\t\t\tthis._isActive = true;\n\n\t\t\t\tthis._onDidChangeActive.fire();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected onScopeClosed(scopeId: string) {\n\t\tif (scopeId === this.scopeId) {\n\t\t\tif (this._isActive) {\n\t\t\t\tthis._isActive = false;\n\n\t\t\t\tthis._onDidChangeActive.fire();\n\t\t\t}\n\t\t}\n\t}\n}\n"]}