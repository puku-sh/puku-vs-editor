{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/workingCopy/common/abstractFileWorkingCopyManager.ts","vs/workbench/services/workingCopy/common/abstractFileWorkingCopyManager.ts"],"names":[],"mappings":"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","file":"abstractFileWorkingCopyManager.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable, dispose, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { Promises } from '../../../../base/common/async.js';\nimport { IFileService } from '../../../../platform/files/common/files.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IWorkingCopyBackupService } from './workingCopyBackup.js';\nimport { IFileWorkingCopy, IFileWorkingCopyModel } from './fileWorkingCopy.js';\n\nexport interface IBaseFileWorkingCopyManager<M extends IFileWorkingCopyModel, W extends IFileWorkingCopy<M>> extends IDisposable {\n\n\t/**\n\t * An event for when a file working copy was created.\n\t */\n\treadonly onDidCreate: Event<W>;\n\n\t/**\n\t * Access to all known file working copies within the manager.\n\t */\n\treadonly workingCopies: readonly W[];\n\n\t/**\n\t * Returns the file working copy for the provided resource\n\t * or `undefined` if none.\n\t */\n\tget(resource: URI): W | undefined;\n\n\t/**\n\t * Disposes all working copies of the manager and disposes the manager. This\n\t * method is different from `dispose` in that it will unregister any working\n\t * copy from the `IWorkingCopyService`. Since this impact things like backups,\n\t * the method is `async` because it needs to trigger `save` for any dirty\n\t * working copy to preserve the data.\n\t *\n\t * Callers should make sure to e.g. close any editors associated with the\n\t * working copy.\n\t */\n\tdestroy(): Promise<void>;\n}\n\nexport abstract class BaseFileWorkingCopyManager<M extends IFileWorkingCopyModel, W extends IFileWorkingCopy<M>> extends Disposable implements IBaseFileWorkingCopyManager<M, W> {\n\n\tprivate readonly _onDidCreate = this._register(new Emitter<W>());\n\treadonly onDidCreate = this._onDidCreate.event;\n\n\tprivate readonly mapResourceToWorkingCopy = new ResourceMap<W>();\n\tprivate readonly mapResourceToDisposeListener = new ResourceMap<IDisposable>();\n\n\tconstructor(\n\t\t@IFileService protected readonly fileService: IFileService,\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IWorkingCopyBackupService protected readonly workingCopyBackupService: IWorkingCopyBackupService\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected has(resource: URI): boolean {\n\t\treturn this.mapResourceToWorkingCopy.has(resource);\n\t}\n\n\tprotected add(resource: URI, workingCopy: W): void {\n\t\tconst knownWorkingCopy = this.get(resource);\n\t\tif (knownWorkingCopy === workingCopy) {\n\t\t\treturn; // already cached\n\t\t}\n\n\t\t// Add to our working copy map\n\t\tthis.mapResourceToWorkingCopy.set(resource, workingCopy);\n\n\t\t// Update our dispose listener to remove it on dispose\n\t\tthis.mapResourceToDisposeListener.get(resource)?.dispose();\n\t\tthis.mapResourceToDisposeListener.set(resource, workingCopy.onWillDispose(() => this.remove(resource)));\n\n\t\t// Signal creation event\n\t\tthis._onDidCreate.fire(workingCopy);\n\t}\n\n\tprotected remove(resource: URI): boolean {\n\n\t\t// Dispose any existing listener\n\t\tconst disposeListener = this.mapResourceToDisposeListener.get(resource);\n\t\tif (disposeListener) {\n\t\t\tdispose(disposeListener);\n\t\t\tthis.mapResourceToDisposeListener.delete(resource);\n\t\t}\n\n\t\t// Remove from our working copy map\n\t\treturn this.mapResourceToWorkingCopy.delete(resource);\n\t}\n\n\t//#region Get / Get all\n\n\tget workingCopies(): W[] {\n\t\treturn [...this.mapResourceToWorkingCopy.values()];\n\t}\n\n\tget(resource: URI): W | undefined {\n\t\treturn this.mapResourceToWorkingCopy.get(resource);\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Clear working copy caches\n\t\t//\n\t\t// Note: we are not explicitly disposing the working copies\n\t\t// known to the manager because this can have unwanted side\n\t\t// effects such as backups getting discarded once the working\n\t\t// copy unregisters. We have an explicit `destroy`\n\t\t// for that purpose (https://github.com/microsoft/vscode/pull/123555)\n\t\t//\n\t\tthis.mapResourceToWorkingCopy.clear();\n\n\t\t// Dispose the dispose listeners\n\t\tdispose(this.mapResourceToDisposeListener.values());\n\t\tthis.mapResourceToDisposeListener.clear();\n\t}\n\n\tasync destroy(): Promise<void> {\n\n\t\t// Make sure all dirty working copies are saved to disk\n\t\ttry {\n\t\t\tawait Promises.settled(this.workingCopies.map(async workingCopy => {\n\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\tawait this.saveWithFallback(workingCopy);\n\t\t\t\t}\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\t// Dispose all working copies\n\t\tdispose(this.mapResourceToWorkingCopy.values());\n\n\t\t// Finally dispose manager\n\t\tthis.dispose();\n\t}\n\n\tprivate async saveWithFallback(workingCopy: W): Promise<void> {\n\n\t\t// First try regular save\n\t\tlet saveSuccess = false;\n\t\ttry {\n\t\t\tsaveSuccess = await workingCopy.save();\n\t\t} catch (error) {\n\t\t\t// Ignore\n\t\t}\n\n\t\t// Then fallback to backup if that exists\n\t\tif (!saveSuccess || workingCopy.isDirty()) {\n\t\t\tconst backup = await this.workingCopyBackupService.resolve(workingCopy);\n\t\t\tif (backup) {\n\t\t\t\tawait this.fileService.writeFile(workingCopy.resource, backup.value, { unlock: true });\n\t\t\t}\n\t\t}\n\t}\n\n\t//#endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable, dispose, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { Promises } from '../../../../base/common/async.js';\nimport { IFileService } from '../../../../platform/files/common/files.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IWorkingCopyBackupService } from './workingCopyBackup.js';\nimport { IFileWorkingCopy, IFileWorkingCopyModel } from './fileWorkingCopy.js';\n\nexport interface IBaseFileWorkingCopyManager<M extends IFileWorkingCopyModel, W extends IFileWorkingCopy<M>> extends IDisposable {\n\n\t/**\n\t * An event for when a file working copy was created.\n\t */\n\treadonly onDidCreate: Event<W>;\n\n\t/**\n\t * Access to all known file working copies within the manager.\n\t */\n\treadonly workingCopies: readonly W[];\n\n\t/**\n\t * Returns the file working copy for the provided resource\n\t * or `undefined` if none.\n\t */\n\tget(resource: URI): W | undefined;\n\n\t/**\n\t * Disposes all working copies of the manager and disposes the manager. This\n\t * method is different from `dispose` in that it will unregister any working\n\t * copy from the `IWorkingCopyService`. Since this impact things like backups,\n\t * the method is `async` because it needs to trigger `save` for any dirty\n\t * working copy to preserve the data.\n\t *\n\t * Callers should make sure to e.g. close any editors associated with the\n\t * working copy.\n\t */\n\tdestroy(): Promise<void>;\n}\n\nexport abstract class BaseFileWorkingCopyManager<M extends IFileWorkingCopyModel, W extends IFileWorkingCopy<M>> extends Disposable implements IBaseFileWorkingCopyManager<M, W> {\n\n\tprivate readonly _onDidCreate = this._register(new Emitter<W>());\n\treadonly onDidCreate = this._onDidCreate.event;\n\n\tprivate readonly mapResourceToWorkingCopy = new ResourceMap<W>();\n\tprivate readonly mapResourceToDisposeListener = new ResourceMap<IDisposable>();\n\n\tconstructor(\n\t\t@IFileService protected readonly fileService: IFileService,\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IWorkingCopyBackupService protected readonly workingCopyBackupService: IWorkingCopyBackupService\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected has(resource: URI): boolean {\n\t\treturn this.mapResourceToWorkingCopy.has(resource);\n\t}\n\n\tprotected add(resource: URI, workingCopy: W): void {\n\t\tconst knownWorkingCopy = this.get(resource);\n\t\tif (knownWorkingCopy === workingCopy) {\n\t\t\treturn; // already cached\n\t\t}\n\n\t\t// Add to our working copy map\n\t\tthis.mapResourceToWorkingCopy.set(resource, workingCopy);\n\n\t\t// Update our dispose listener to remove it on dispose\n\t\tthis.mapResourceToDisposeListener.get(resource)?.dispose();\n\t\tthis.mapResourceToDisposeListener.set(resource, workingCopy.onWillDispose(() => this.remove(resource)));\n\n\t\t// Signal creation event\n\t\tthis._onDidCreate.fire(workingCopy);\n\t}\n\n\tprotected remove(resource: URI): boolean {\n\n\t\t// Dispose any existing listener\n\t\tconst disposeListener = this.mapResourceToDisposeListener.get(resource);\n\t\tif (disposeListener) {\n\t\t\tdispose(disposeListener);\n\t\t\tthis.mapResourceToDisposeListener.delete(resource);\n\t\t}\n\n\t\t// Remove from our working copy map\n\t\treturn this.mapResourceToWorkingCopy.delete(resource);\n\t}\n\n\t//#region Get / Get all\n\n\tget workingCopies(): W[] {\n\t\treturn [...this.mapResourceToWorkingCopy.values()];\n\t}\n\n\tget(resource: URI): W | undefined {\n\t\treturn this.mapResourceToWorkingCopy.get(resource);\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Clear working copy caches\n\t\t//\n\t\t// Note: we are not explicitly disposing the working copies\n\t\t// known to the manager because this can have unwanted side\n\t\t// effects such as backups getting discarded once the working\n\t\t// copy unregisters. We have an explicit `destroy`\n\t\t// for that purpose (https://github.com/microsoft/vscode/pull/123555)\n\t\t//\n\t\tthis.mapResourceToWorkingCopy.clear();\n\n\t\t// Dispose the dispose listeners\n\t\tdispose(this.mapResourceToDisposeListener.values());\n\t\tthis.mapResourceToDisposeListener.clear();\n\t}\n\n\tasync destroy(): Promise<void> {\n\n\t\t// Make sure all dirty working copies are saved to disk\n\t\ttry {\n\t\t\tawait Promises.settled(this.workingCopies.map(async workingCopy => {\n\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\tawait this.saveWithFallback(workingCopy);\n\t\t\t\t}\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\t// Dispose all working copies\n\t\tdispose(this.mapResourceToWorkingCopy.values());\n\n\t\t// Finally dispose manager\n\t\tthis.dispose();\n\t}\n\n\tprivate async saveWithFallback(workingCopy: W): Promise<void> {\n\n\t\t// First try regular save\n\t\tlet saveSuccess = false;\n\t\ttry {\n\t\t\tsaveSuccess = await workingCopy.save();\n\t\t} catch (error) {\n\t\t\t// Ignore\n\t\t}\n\n\t\t// Then fallback to backup if that exists\n\t\tif (!saveSuccess || workingCopy.isDirty()) {\n\t\t\tconst backup = await this.workingCopyBackupService.resolve(workingCopy);\n\t\t\tif (backup) {\n\t\t\t\tawait this.fileService.writeFile(workingCopy.resource, backup.value, { unlock: true });\n\t\t\t}\n\t\t}\n\t}\n\n\t//#endregion\n}\n"]}