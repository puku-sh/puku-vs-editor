{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/workingCopy/common/workingCopyService.ts","vs/workbench/services/workingCopy/common/workingCopyService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,eAAe,EAAE,MAAM,4DAA4D,CAAC;AAC7F,OAAO,EAAqB,iBAAiB,EAAE,MAAM,yDAAyD,CAAC;AAC/G,OAAO,EAAS,OAAO,EAAE,MAAM,kCAAkC,CAAC;AAClE,OAAO,EAAE,GAAG,EAAE,MAAM,gCAAgC,CAAC;AACrD,OAAO,EAAE,UAAU,EAAe,YAAY,EAAE,eAAe,EAAE,aAAa,EAAE,MAAM,sCAAsC,CAAC;AAC7H,OAAO,EAAE,WAAW,EAAE,MAAM,gCAAgC,CAAC;AAE7D,OAAO,EAAE,iBAAiB,EAAE,MAAM,mCAAmC,CAAC;AAEtE,MAAM,CAAC,MAAM,mBAAmB,GAAG,eAAe,CAAsB,oBAAoB,CAAC,CAAC;AA8H9F,MAAM,oBAAqB,SAAQ,KAAK;IAEvC,YAAY,OAAe,EAAE,KAAa;QACzC,KAAK,CAAC,OAAO,CAAC,CAAC;QAEf,IAAI,CAAC,IAAI,GAAG,sBAAsB,CAAC;QACnC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACpB,CAAC;CACD;AAED,MAAM,OAAO,kBAAmB,SAAQ,UAAU;IAAlD;;QAIC,gBAAgB;QAEC,mBAAc,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAgB,CAAC,CAAC;QACrE,kBAAa,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;QAElC,qBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAgB,CAAC,CAAC;QACvE,oBAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC;QAEtC,sBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAgB,CAAC,CAAC;QACxE,qBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;QAExC,wBAAmB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAgB,CAAC,CAAC;QAC1E,uBAAkB,GAAG,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC;QAE5C,eAAU,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAyB,CAAC,CAAC;QAC1E,cAAS,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;QAQnC,mBAAc,GAAG,IAAI,GAAG,EAAgB,CAAC;QAEhC,+BAA0B,GAAG,IAAI,WAAW,EAA6B,CAAC;QAC1E,8BAAyB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,aAAa,EAAgB,CAAC,CAAC;QAqG9E,qBAAgB,GAAG,IAAI,GAAG,EAAkB,CAAC;QAsG9D,YAAY;IACb,CAAC;IArNA,YAAY;IAGZ,kBAAkB;IAElB,IAAI,aAAa,KAAqB,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;IAMxF,mBAAmB,CAAC,WAAyB;QAC5C,IAAI,wBAAwB,GAAG,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QACzF,IAAI,wBAAwB,EAAE,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,EAAE,CAAC;YACvD,MAAM,IAAI,KAAK,CAAC,qEAAqE,WAAW,CAAC,QAAQ,CAAC,QAAQ,EAAE,aAAa,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;QACzJ,CAAC;QAED,iBAAiB;QACjB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAErC,wBAAwB;QACxB,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAC/B,wBAAwB,GAAG,IAAI,GAAG,EAAE,CAAC;YACrC,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,EAAE,wBAAwB,CAAC,CAAC;QACrF,CAAC;QACD,wBAAwB,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;QAE9D,iBAAiB;QACjB,MAAM,WAAW,GAAG,IAAI,eAAe,EAAE,CAAC;QAC1C,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QAClG,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QAC9F,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,WAAW,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACzF,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;QAE7D,2BAA2B;QAC3B,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACtC,IAAI,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC;YAC3B,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC1C,CAAC;QAED,cAAc;QACd,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAE5C,OAAO,YAAY,CAAC,GAAG,EAAE;YAExB,gBAAgB;YAChB,IAAI,MAAM,EAAE,CAAC;gBACZ,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;YAC3B,CAAC;YAED,0BAA0B;YAC1B,IAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC;YAExC,kBAAkB;YAClB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;IACJ,CAAC;IAES,qBAAqB,CAAC,WAAyB;QAExD,iBAAiB;QACjB,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QAExC,wBAAwB;QACxB,MAAM,wBAAwB,GAAG,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QAC3F,IAAI,wBAAwB,EAAE,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,wBAAwB,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;YACjG,IAAI,CAAC,0BAA0B,CAAC,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QAC9D,CAAC;QAED,uEAAuE;QACvE,wEAAwE;QACxE,IAAI,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC;YAC3B,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC1C,CAAC;QAED,kDAAkD;QAClD,IAAI,CAAC,yBAAyB,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC;IAC9D,CAAC;IAID,GAAG,CAAC,oBAAkD;QACrD,IAAI,GAAG,CAAC,KAAK,CAAC,oBAAoB,CAAC,EAAE,CAAC;YACrC,OAAO,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC;QAClE,CAAC;QAED,OAAO,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,oBAAoB,CAAC,QAAQ,CAAC,EAAE,GAAG,CAAC,oBAAoB,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC;IACtH,CAAC;IAED,GAAG,CAAC,UAAkC;QACrC,OAAO,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;IACzF,CAAC;IAED,MAAM,CAAC,QAAa;QACnB,MAAM,aAAa,GAAG,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACpE,IAAI,CAAC,aAAa,EAAE,CAAC;YACpB,OAAO,SAAS,CAAC;QAClB,CAAC;QAED,OAAO,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,CAAC;IAC3C,CAAC;IAED,YAAY;IAEZ,yBAAyB;aAED,4BAAuB,GAAG,GAAH,AAAM,CAAC;aAC9B,6BAAwB,GAAG,CAAC,GAAG,kBAAkB,CAAC,uBAA1B,AAAiD,CAAC;aACnF,kBAAa,GAAG,KAAH,AAAQ,CAAC;IAI7B,UAAU,CAAC,WAAyB;QAC3C,IAAI,kBAAkB,CAAC,aAAa,IAAI,IAAI,CAAC,cAAc,CAAC,IAAI,GAAG,kBAAkB,CAAC,uBAAuB,EAAE,CAAC;YAC/G,OAAO,SAAS,CAAC;QAClB,CAAC;QAED,MAAM,MAAM,GAAG,GAAG,WAAW,CAAC,QAAQ,CAAC,MAAM,IAAI,WAAW,CAAC,MAAM,IAAI,aAAa,KAAK,IAAI,KAAK,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC;QACpJ,MAAM,WAAW,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACjE,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;QAE/C,IAAI,IAAI,CAAC,cAAc,CAAC,IAAI,GAAG,kBAAkB,CAAC,wBAAwB,EAAE,CAAC;YAC5E,kBAAkB,CAAC,aAAa,GAAG,IAAI,CAAC;YAExC,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,CAAC,CAAC,MAAM,CAC7E,CAAC,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,QAAQ,CAAC,CACtF,CAAC;YAEF,MAAM,OAAO,GAAG,gDAAgD,IAAI,CAAC,cAAc,CAAC,IAAI,iDAAiD,QAAQ,GAAG,CAAC;YACrJ,iBAAiB,CAAC,IAAI,oBAAoB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAEO,YAAY,CAAC,MAAc;QAClC,MAAM,YAAY,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QAClE,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;QAEhD,IAAI,YAAY,KAAK,CAAC,EAAE,CAAC;YACxB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACtC,CAAC;IACF,CAAC;IAED,YAAY;IAEZ,wBAAwB;IAExB,IAAI,QAAQ;QACX,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YAC/C,IAAI,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC;gBAC3B,OAAO,IAAI,CAAC;YACb,CAAC;QACF,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAED,IAAI,UAAU;QACb,IAAI,eAAe,GAAG,CAAC,CAAC;QAExB,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YAC/C,IAAI,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC;gBAC3B,eAAe,EAAE,CAAC;YACnB,CAAC;QACF,CAAC;QAED,OAAO,eAAe,CAAC;IACxB,CAAC;IAED,IAAI,kBAAkB;QACrB,OAAO,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,CAAC;IACxE,CAAC;IAED,IAAI,aAAa;QAChB,IAAI,kBAAkB,GAAG,CAAC,CAAC;QAE3B,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YAC/C,IAAI,WAAW,CAAC,UAAU,EAAE,EAAE,CAAC;gBAC9B,kBAAkB,EAAE,CAAC;YACtB,CAAC;QACF,CAAC;QAED,OAAO,kBAAkB,CAAC;IAC3B,CAAC;IAED,IAAI,qBAAqB;QACxB,OAAO,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC,CAAC;IAC3E,CAAC;IAED,OAAO,CAAC,QAAa,EAAE,MAAe;QACrC,MAAM,aAAa,GAAG,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACpE,IAAI,aAAa,EAAE,CAAC;YAEnB,sBAAsB;YACtB,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE,CAAC;gBAChC,OAAO,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,IAAI,KAAK,CAAC;YACtD,CAAC;YAED,4BAA4B;iBACvB,CAAC;gBACL,KAAK,MAAM,CAAC,EAAE,WAAW,CAAC,IAAI,aAAa,EAAE,CAAC;oBAC7C,IAAI,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC;wBAC3B,OAAO,IAAI,CAAC;oBACb,CAAC;gBACF,CAAC;YACF,CAAC;QACF,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC;;AAKF,iBAAiB,CAAC,mBAAmB,EAAE,kBAAkB,oCAA4B,CAAC","file":"workingCopyService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Disposable, IDisposable, toDisposable, DisposableStore, DisposableMap } from '../../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IWorkingCopy, IWorkingCopyIdentifier, IWorkingCopySaveEvent as IBaseWorkingCopySaveEvent } from './workingCopy.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\n\nexport const IWorkingCopyService = createDecorator<IWorkingCopyService>('workingCopyService');\n\nexport interface IWorkingCopySaveEvent extends IBaseWorkingCopySaveEvent {\n\n\t/**\n\t * The working copy that was saved.\n\t */\n\treadonly workingCopy: IWorkingCopy;\n}\n\nexport interface IWorkingCopyService {\n\n\treadonly _serviceBrand: undefined;\n\n\n\t//#region Events\n\n\t/**\n\t * An event for when a working copy was registered.\n\t */\n\treadonly onDidRegister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy was unregistered.\n\t */\n\treadonly onDidUnregister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy dirty state changed.\n\t */\n\treadonly onDidChangeDirty: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy's content changed.\n\t */\n\treadonly onDidChangeContent: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy was saved.\n\t */\n\treadonly onDidSave: Event<IWorkingCopySaveEvent>;\n\n\t//#endregion\n\n\n\t//#region Dirty Tracking\n\n\t/**\n\t * The number of dirty working copies that are registered.\n\t */\n\treadonly dirtyCount: number;\n\n\t/**\n\t * All dirty working copies that are registered.\n\t */\n\treadonly dirtyWorkingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * The number of modified working copies that are registered,\n\t * including scratchpads, which are never dirty.\n\t */\n\treadonly modifiedCount: number;\n\n\t/**\n\t * All working copies with unsaved changes,\n\t * including scratchpads, which are never dirty.\n\t */\n\treadonly modifiedWorkingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Whether there is any registered working copy that is dirty.\n\t */\n\treadonly hasDirty: boolean;\n\n\t/**\n\t * Figure out if working copies with the given\n\t * resource are dirty or not.\n\t *\n\t * @param resource the URI of the working copy\n\t * @param typeId optional type identifier to only\n\t * consider working copies of that type.\n\t */\n\tisDirty(resource: URI, typeId?: string): boolean;\n\n\t//#endregion\n\n\n\t//#region Registry\n\n\t/**\n\t * All working copies that are registered.\n\t */\n\treadonly workingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Register a new working copy with the service. This method will\n\t * throw if you try to register a working copy on a resource that\n\t * has already been registered.\n\t *\n\t * Overall there can only ever be 1 working copy with the same\n\t * resource.\n\t */\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable;\n\n\t/**\n\t * Whether a working copy with the given resource or identifier\n\t * exists.\n\t */\n\thas(identifier: IWorkingCopyIdentifier): boolean;\n\thas(resource: URI): boolean;\n\n\t/**\n\t * Returns a working copy with the given identifier or `undefined`\n\t * if no such working copy exists.\n\t */\n\tget(identifier: IWorkingCopyIdentifier): IWorkingCopy | undefined;\n\n\t/**\n\t * Returns all working copies with the given resource or `undefined`\n\t * if no such working copy exists.\n\t */\n\tgetAll(resource: URI): readonly IWorkingCopy[] | undefined;\n\n\t//#endregion\n}\n\nclass WorkingCopyLeakError extends Error {\n\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\n\t\tthis.name = 'WorkingCopyLeakError';\n\t\tthis.stack = stack;\n\t}\n}\n\nexport class WorkingCopyService extends Disposable implements IWorkingCopyService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\tprivate readonly _onDidRegister = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidRegister = this._onDidRegister.event;\n\n\tprivate readonly _onDidUnregister = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidUnregister = this._onDidUnregister.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeContent = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidChangeContent = this._onDidChangeContent.event;\n\n\tprivate readonly _onDidSave = this._register(new Emitter<IWorkingCopySaveEvent>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\t//#endregion\n\n\n\t//#region Registry\n\n\tget workingCopies(): IWorkingCopy[] { return Array.from(this._workingCopies.values()); }\n\tprivate _workingCopies = new Set<IWorkingCopy>();\n\n\tprivate readonly mapResourceToWorkingCopies = new ResourceMap<Map<string, IWorkingCopy>>();\n\tprivate readonly mapWorkingCopyToListeners = this._register(new DisposableMap<IWorkingCopy>());\n\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable {\n\t\tlet workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);\n\t\tif (workingCopiesForResource?.has(workingCopy.typeId)) {\n\t\t\tthrow new Error(`Cannot register more than one working copy with the same resource ${workingCopy.resource.toString()} and type ${workingCopy.typeId}.`);\n\t\t}\n\n\t\t// Registry (all)\n\t\tthis._workingCopies.add(workingCopy);\n\n\t\t// Registry (type based)\n\t\tif (!workingCopiesForResource) {\n\t\t\tworkingCopiesForResource = new Map();\n\t\t\tthis.mapResourceToWorkingCopies.set(workingCopy.resource, workingCopiesForResource);\n\t\t}\n\t\tworkingCopiesForResource.set(workingCopy.typeId, workingCopy);\n\n\t\t// Wire in Events\n\t\tconst disposables = new DisposableStore();\n\t\tdisposables.add(workingCopy.onDidChangeContent(() => this._onDidChangeContent.fire(workingCopy)));\n\t\tdisposables.add(workingCopy.onDidChangeDirty(() => this._onDidChangeDirty.fire(workingCopy)));\n\t\tdisposables.add(workingCopy.onDidSave(e => this._onDidSave.fire({ workingCopy, ...e })));\n\t\tthis.mapWorkingCopyToListeners.set(workingCopy, disposables);\n\n\t\t// Send some initial events\n\t\tthis._onDidRegister.fire(workingCopy);\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\t// Track Leaks\n\t\tconst leakId = this.trackLeaks(workingCopy);\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Untrack Leaks\n\t\t\tif (leakId) {\n\t\t\t\tthis.untrackLeaks(leakId);\n\t\t\t}\n\n\t\t\t// Unregister working copy\n\t\t\tthis.unregisterWorkingCopy(workingCopy);\n\n\t\t\t// Signal as event\n\t\t\tthis._onDidUnregister.fire(workingCopy);\n\t\t});\n\t}\n\n\tprotected unregisterWorkingCopy(workingCopy: IWorkingCopy): void {\n\n\t\t// Registry (all)\n\t\tthis._workingCopies.delete(workingCopy);\n\n\t\t// Registry (type based)\n\t\tconst workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);\n\t\tif (workingCopiesForResource?.delete(workingCopy.typeId) && workingCopiesForResource.size === 0) {\n\t\t\tthis.mapResourceToWorkingCopies.delete(workingCopy.resource);\n\t\t}\n\n\t\t// If copy is dirty, ensure to fire an event to signal the dirty change\n\t\t// (a disposed working copy cannot account for being dirty in our model)\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\t// Remove all listeners associated to working copy\n\t\tthis.mapWorkingCopyToListeners.deleteAndDispose(workingCopy);\n\t}\n\n\thas(identifier: IWorkingCopyIdentifier): boolean;\n\thas(resource: URI): boolean;\n\thas(resourceOrIdentifier: URI | IWorkingCopyIdentifier): boolean {\n\t\tif (URI.isUri(resourceOrIdentifier)) {\n\t\t\treturn this.mapResourceToWorkingCopies.has(resourceOrIdentifier);\n\t\t}\n\n\t\treturn this.mapResourceToWorkingCopies.get(resourceOrIdentifier.resource)?.has(resourceOrIdentifier.typeId) ?? false;\n\t}\n\n\tget(identifier: IWorkingCopyIdentifier): IWorkingCopy | undefined {\n\t\treturn this.mapResourceToWorkingCopies.get(identifier.resource)?.get(identifier.typeId);\n\t}\n\n\tgetAll(resource: URI): readonly IWorkingCopy[] | undefined {\n\t\tconst workingCopies = this.mapResourceToWorkingCopies.get(resource);\n\t\tif (!workingCopies) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn Array.from(workingCopies.values());\n\t}\n\n\t//#endregion\n\n\t//#region Leak Monitoring\n\n\tprivate static readonly LEAK_TRACKING_THRESHOLD = 256;\n\tprivate static readonly LEAK_REPORTING_THRESHOLD = 2 * WorkingCopyService.LEAK_TRACKING_THRESHOLD;\n\tprivate static LEAK_REPORTED = false;\n\n\tprivate readonly mapLeakToCounter = new Map<string, number>();\n\n\tprivate trackLeaks(workingCopy: IWorkingCopy): string | undefined {\n\t\tif (WorkingCopyService.LEAK_REPORTED || this._workingCopies.size < WorkingCopyService.LEAK_TRACKING_THRESHOLD) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst leakId = `${workingCopy.resource.scheme}#${workingCopy.typeId || '<no typeId>'}\\n${new Error().stack?.split('\\n').slice(2).join('\\n') ?? ''}`;\n\t\tconst leakCounter = (this.mapLeakToCounter.get(leakId) ?? 0) + 1;\n\t\tthis.mapLeakToCounter.set(leakId, leakCounter);\n\n\t\tif (this._workingCopies.size > WorkingCopyService.LEAK_REPORTING_THRESHOLD) {\n\t\t\tWorkingCopyService.LEAK_REPORTED = true;\n\n\t\t\tconst [topLeak, topCount] = Array.from(this.mapLeakToCounter.entries()).reduce(\n\t\t\t\t([topLeak, topCount], [key, val]) => val > topCount ? [key, val] : [topLeak, topCount]\n\t\t\t);\n\n\t\t\tconst message = `Potential working copy LEAK detected, having ${this._workingCopies.size} working copies already. Most frequent owner (${topCount})`;\n\t\t\tonUnexpectedError(new WorkingCopyLeakError(message, topLeak));\n\t\t}\n\n\t\treturn leakId;\n\t}\n\n\tprivate untrackLeaks(leakId: string): void {\n\t\tconst stackCounter = (this.mapLeakToCounter.get(leakId) ?? 1) - 1;\n\t\tthis.mapLeakToCounter.set(leakId, stackCounter);\n\n\t\tif (stackCounter === 0) {\n\t\t\tthis.mapLeakToCounter.delete(leakId);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Dirty Tracking\n\n\tget hasDirty(): boolean {\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget dirtyCount(): number {\n\t\tlet totalDirtyCount = 0;\n\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\ttotalDirtyCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn totalDirtyCount;\n\t}\n\n\tget dirtyWorkingCopies(): IWorkingCopy[] {\n\t\treturn this.workingCopies.filter(workingCopy => workingCopy.isDirty());\n\t}\n\n\tget modifiedCount(): number {\n\t\tlet totalModifiedCount = 0;\n\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isModified()) {\n\t\t\t\ttotalModifiedCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn totalModifiedCount;\n\t}\n\n\tget modifiedWorkingCopies(): IWorkingCopy[] {\n\t\treturn this.workingCopies.filter(workingCopy => workingCopy.isModified());\n\t}\n\n\tisDirty(resource: URI, typeId?: string): boolean {\n\t\tconst workingCopies = this.mapResourceToWorkingCopies.get(resource);\n\t\tif (workingCopies) {\n\n\t\t\t// For a specific type\n\t\t\tif (typeof typeId === 'string') {\n\t\t\t\treturn workingCopies.get(typeId)?.isDirty() ?? false;\n\t\t\t}\n\n\t\t\t// Across all working copies\n\t\t\telse {\n\t\t\t\tfor (const [, workingCopy] of workingCopies) {\n\t\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//#endregion\n}\n\nregisterSingleton(IWorkingCopyService, WorkingCopyService, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Disposable, IDisposable, toDisposable, DisposableStore, DisposableMap } from '../../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IWorkingCopy, IWorkingCopyIdentifier, IWorkingCopySaveEvent as IBaseWorkingCopySaveEvent } from './workingCopy.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\n\nexport const IWorkingCopyService = createDecorator<IWorkingCopyService>('workingCopyService');\n\nexport interface IWorkingCopySaveEvent extends IBaseWorkingCopySaveEvent {\n\n\t/**\n\t * The working copy that was saved.\n\t */\n\treadonly workingCopy: IWorkingCopy;\n}\n\nexport interface IWorkingCopyService {\n\n\treadonly _serviceBrand: undefined;\n\n\n\t//#region Events\n\n\t/**\n\t * An event for when a working copy was registered.\n\t */\n\treadonly onDidRegister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy was unregistered.\n\t */\n\treadonly onDidUnregister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy dirty state changed.\n\t */\n\treadonly onDidChangeDirty: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy's content changed.\n\t */\n\treadonly onDidChangeContent: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy was saved.\n\t */\n\treadonly onDidSave: Event<IWorkingCopySaveEvent>;\n\n\t//#endregion\n\n\n\t//#region Dirty Tracking\n\n\t/**\n\t * The number of dirty working copies that are registered.\n\t */\n\treadonly dirtyCount: number;\n\n\t/**\n\t * All dirty working copies that are registered.\n\t */\n\treadonly dirtyWorkingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * The number of modified working copies that are registered,\n\t * including scratchpads, which are never dirty.\n\t */\n\treadonly modifiedCount: number;\n\n\t/**\n\t * All working copies with unsaved changes,\n\t * including scratchpads, which are never dirty.\n\t */\n\treadonly modifiedWorkingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Whether there is any registered working copy that is dirty.\n\t */\n\treadonly hasDirty: boolean;\n\n\t/**\n\t * Figure out if working copies with the given\n\t * resource are dirty or not.\n\t *\n\t * @param resource the URI of the working copy\n\t * @param typeId optional type identifier to only\n\t * consider working copies of that type.\n\t */\n\tisDirty(resource: URI, typeId?: string): boolean;\n\n\t//#endregion\n\n\n\t//#region Registry\n\n\t/**\n\t * All working copies that are registered.\n\t */\n\treadonly workingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Register a new working copy with the service. This method will\n\t * throw if you try to register a working copy on a resource that\n\t * has already been registered.\n\t *\n\t * Overall there can only ever be 1 working copy with the same\n\t * resource.\n\t */\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable;\n\n\t/**\n\t * Whether a working copy with the given resource or identifier\n\t * exists.\n\t */\n\thas(identifier: IWorkingCopyIdentifier): boolean;\n\thas(resource: URI): boolean;\n\n\t/**\n\t * Returns a working copy with the given identifier or `undefined`\n\t * if no such working copy exists.\n\t */\n\tget(identifier: IWorkingCopyIdentifier): IWorkingCopy | undefined;\n\n\t/**\n\t * Returns all working copies with the given resource or `undefined`\n\t * if no such working copy exists.\n\t */\n\tgetAll(resource: URI): readonly IWorkingCopy[] | undefined;\n\n\t//#endregion\n}\n\nclass WorkingCopyLeakError extends Error {\n\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\n\t\tthis.name = 'WorkingCopyLeakError';\n\t\tthis.stack = stack;\n\t}\n}\n\nexport class WorkingCopyService extends Disposable implements IWorkingCopyService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\tprivate readonly _onDidRegister = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidRegister = this._onDidRegister.event;\n\n\tprivate readonly _onDidUnregister = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidUnregister = this._onDidUnregister.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeContent = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidChangeContent = this._onDidChangeContent.event;\n\n\tprivate readonly _onDidSave = this._register(new Emitter<IWorkingCopySaveEvent>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\t//#endregion\n\n\n\t//#region Registry\n\n\tget workingCopies(): IWorkingCopy[] { return Array.from(this._workingCopies.values()); }\n\tprivate _workingCopies = new Set<IWorkingCopy>();\n\n\tprivate readonly mapResourceToWorkingCopies = new ResourceMap<Map<string, IWorkingCopy>>();\n\tprivate readonly mapWorkingCopyToListeners = this._register(new DisposableMap<IWorkingCopy>());\n\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable {\n\t\tlet workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);\n\t\tif (workingCopiesForResource?.has(workingCopy.typeId)) {\n\t\t\tthrow new Error(`Cannot register more than one working copy with the same resource ${workingCopy.resource.toString()} and type ${workingCopy.typeId}.`);\n\t\t}\n\n\t\t// Registry (all)\n\t\tthis._workingCopies.add(workingCopy);\n\n\t\t// Registry (type based)\n\t\tif (!workingCopiesForResource) {\n\t\t\tworkingCopiesForResource = new Map();\n\t\t\tthis.mapResourceToWorkingCopies.set(workingCopy.resource, workingCopiesForResource);\n\t\t}\n\t\tworkingCopiesForResource.set(workingCopy.typeId, workingCopy);\n\n\t\t// Wire in Events\n\t\tconst disposables = new DisposableStore();\n\t\tdisposables.add(workingCopy.onDidChangeContent(() => this._onDidChangeContent.fire(workingCopy)));\n\t\tdisposables.add(workingCopy.onDidChangeDirty(() => this._onDidChangeDirty.fire(workingCopy)));\n\t\tdisposables.add(workingCopy.onDidSave(e => this._onDidSave.fire({ workingCopy, ...e })));\n\t\tthis.mapWorkingCopyToListeners.set(workingCopy, disposables);\n\n\t\t// Send some initial events\n\t\tthis._onDidRegister.fire(workingCopy);\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\t// Track Leaks\n\t\tconst leakId = this.trackLeaks(workingCopy);\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Untrack Leaks\n\t\t\tif (leakId) {\n\t\t\t\tthis.untrackLeaks(leakId);\n\t\t\t}\n\n\t\t\t// Unregister working copy\n\t\t\tthis.unregisterWorkingCopy(workingCopy);\n\n\t\t\t// Signal as event\n\t\t\tthis._onDidUnregister.fire(workingCopy);\n\t\t});\n\t}\n\n\tprotected unregisterWorkingCopy(workingCopy: IWorkingCopy): void {\n\n\t\t// Registry (all)\n\t\tthis._workingCopies.delete(workingCopy);\n\n\t\t// Registry (type based)\n\t\tconst workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);\n\t\tif (workingCopiesForResource?.delete(workingCopy.typeId) && workingCopiesForResource.size === 0) {\n\t\t\tthis.mapResourceToWorkingCopies.delete(workingCopy.resource);\n\t\t}\n\n\t\t// If copy is dirty, ensure to fire an event to signal the dirty change\n\t\t// (a disposed working copy cannot account for being dirty in our model)\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\t// Remove all listeners associated to working copy\n\t\tthis.mapWorkingCopyToListeners.deleteAndDispose(workingCopy);\n\t}\n\n\thas(identifier: IWorkingCopyIdentifier): boolean;\n\thas(resource: URI): boolean;\n\thas(resourceOrIdentifier: URI | IWorkingCopyIdentifier): boolean {\n\t\tif (URI.isUri(resourceOrIdentifier)) {\n\t\t\treturn this.mapResourceToWorkingCopies.has(resourceOrIdentifier);\n\t\t}\n\n\t\treturn this.mapResourceToWorkingCopies.get(resourceOrIdentifier.resource)?.has(resourceOrIdentifier.typeId) ?? false;\n\t}\n\n\tget(identifier: IWorkingCopyIdentifier): IWorkingCopy | undefined {\n\t\treturn this.mapResourceToWorkingCopies.get(identifier.resource)?.get(identifier.typeId);\n\t}\n\n\tgetAll(resource: URI): readonly IWorkingCopy[] | undefined {\n\t\tconst workingCopies = this.mapResourceToWorkingCopies.get(resource);\n\t\tif (!workingCopies) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn Array.from(workingCopies.values());\n\t}\n\n\t//#endregion\n\n\t//#region Leak Monitoring\n\n\tprivate static readonly LEAK_TRACKING_THRESHOLD = 256;\n\tprivate static readonly LEAK_REPORTING_THRESHOLD = 2 * WorkingCopyService.LEAK_TRACKING_THRESHOLD;\n\tprivate static LEAK_REPORTED = false;\n\n\tprivate readonly mapLeakToCounter = new Map<string, number>();\n\n\tprivate trackLeaks(workingCopy: IWorkingCopy): string | undefined {\n\t\tif (WorkingCopyService.LEAK_REPORTED || this._workingCopies.size < WorkingCopyService.LEAK_TRACKING_THRESHOLD) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst leakId = `${workingCopy.resource.scheme}#${workingCopy.typeId || '<no typeId>'}\\n${new Error().stack?.split('\\n').slice(2).join('\\n') ?? ''}`;\n\t\tconst leakCounter = (this.mapLeakToCounter.get(leakId) ?? 0) + 1;\n\t\tthis.mapLeakToCounter.set(leakId, leakCounter);\n\n\t\tif (this._workingCopies.size > WorkingCopyService.LEAK_REPORTING_THRESHOLD) {\n\t\t\tWorkingCopyService.LEAK_REPORTED = true;\n\n\t\t\tconst [topLeak, topCount] = Array.from(this.mapLeakToCounter.entries()).reduce(\n\t\t\t\t([topLeak, topCount], [key, val]) => val > topCount ? [key, val] : [topLeak, topCount]\n\t\t\t);\n\n\t\t\tconst message = `Potential working copy LEAK detected, having ${this._workingCopies.size} working copies already. Most frequent owner (${topCount})`;\n\t\t\tonUnexpectedError(new WorkingCopyLeakError(message, topLeak));\n\t\t}\n\n\t\treturn leakId;\n\t}\n\n\tprivate untrackLeaks(leakId: string): void {\n\t\tconst stackCounter = (this.mapLeakToCounter.get(leakId) ?? 1) - 1;\n\t\tthis.mapLeakToCounter.set(leakId, stackCounter);\n\n\t\tif (stackCounter === 0) {\n\t\t\tthis.mapLeakToCounter.delete(leakId);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Dirty Tracking\n\n\tget hasDirty(): boolean {\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget dirtyCount(): number {\n\t\tlet totalDirtyCount = 0;\n\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\ttotalDirtyCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn totalDirtyCount;\n\t}\n\n\tget dirtyWorkingCopies(): IWorkingCopy[] {\n\t\treturn this.workingCopies.filter(workingCopy => workingCopy.isDirty());\n\t}\n\n\tget modifiedCount(): number {\n\t\tlet totalModifiedCount = 0;\n\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isModified()) {\n\t\t\t\ttotalModifiedCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn totalModifiedCount;\n\t}\n\n\tget modifiedWorkingCopies(): IWorkingCopy[] {\n\t\treturn this.workingCopies.filter(workingCopy => workingCopy.isModified());\n\t}\n\n\tisDirty(resource: URI, typeId?: string): boolean {\n\t\tconst workingCopies = this.mapResourceToWorkingCopies.get(resource);\n\t\tif (workingCopies) {\n\n\t\t\t// For a specific type\n\t\t\tif (typeof typeId === 'string') {\n\t\t\t\treturn workingCopies.get(typeId)?.isDirty() ?? false;\n\t\t\t}\n\n\t\t\t// Across all working copies\n\t\t\telse {\n\t\t\t\tfor (const [, workingCopy] of workingCopies) {\n\t\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//#endregion\n}\n\nregisterSingleton(IWorkingCopyService, WorkingCopyService, InstantiationType.Delayed);\n"]}