{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/workingCopy/common/workingCopyFileService.ts","vs/workbench/services/workingCopy/common/workingCopyFileService.ts"],"names":[],"mappings":"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","file":"workingCopyFileService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator, IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { Event, AsyncEmitter, IWaitUntil } from '../../../../base/common/event.js';\nimport { Promises } from '../../../../base/common/async.js';\nimport { insert } from '../../../../base/common/arrays.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { IFileService, FileOperation, IFileStatWithMetadata } from '../../../../platform/files/common/files.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IWorkingCopyService } from './workingCopyService.js';\nimport { IWorkingCopy } from './workingCopy.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { WorkingCopyFileOperationParticipant } from './workingCopyFileOperationParticipant.js';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { SaveReason } from '../../../common/editor.js';\nimport { IProgress, IProgressStep } from '../../../../platform/progress/common/progress.js';\nimport { StoredFileWorkingCopySaveParticipant } from './storedFileWorkingCopySaveParticipant.js';\nimport { IStoredFileWorkingCopy, IStoredFileWorkingCopyModel } from './storedFileWorkingCopy.js';\n\nexport const IWorkingCopyFileService = createDecorator<IWorkingCopyFileService>('workingCopyFileService');\n\nexport interface SourceTargetPair {\n\n\t/**\n\t * The source resource that is defined for move operations.\n\t */\n\treadonly source?: URI;\n\n\t/**\n\t * The target resource the event is about.\n\t */\n\treadonly target: URI;\n}\n\nexport interface IFileOperationUndoRedoInfo {\n\n\t/**\n\t * Id of the undo group that the file operation belongs to.\n\t */\n\tundoRedoGroupId?: number;\n\n\t/**\n\t * Flag indicates if the operation is an undo.\n\t */\n\tisUndoing?: boolean;\n}\n\nexport interface WorkingCopyFileEvent extends IWaitUntil {\n\n\t/**\n\t * An identifier to correlate the operation through the\n\t * different event types (before, after, error).\n\t */\n\treadonly correlationId: number;\n\n\t/**\n\t * The file operation that is taking place.\n\t */\n\treadonly operation: FileOperation;\n\n\t/**\n\t * The array of source/target pair of files involved in given operation.\n\t */\n\treadonly files: readonly SourceTargetPair[];\n}\n\nexport interface IWorkingCopyFileOperationParticipant {\n\n\t/**\n\t * Participate in a file operation of working copies. Allows to\n\t * change the working copies before they are being saved to disk.\n\t */\n\tparticipate(\n\t\tfiles: SourceTargetPair[],\n\t\toperation: FileOperation,\n\t\tundoInfo: IFileOperationUndoRedoInfo | undefined,\n\t\ttimeout: number,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface IStoredFileWorkingCopySaveParticipantContext {\n\t/**\n\t * The reason why the save was triggered.\n\t */\n\treadonly reason: SaveReason;\n\n\t/**\n\t * Only applies to when a text file was saved as, for\n\t * example when starting with untitled and saving. This\n\t * provides access to the initial resource the text\n\t * file had before.\n\t */\n\treadonly savedFrom?: URI;\n}\n\nexport interface IStoredFileWorkingCopySaveParticipant {\n\n\t/**\n\t * The ordinal number which determines the order of participation.\n\t * Lower values mean to participant sooner\n\t */\n\treadonly ordinal?: number;\n\n\t/**\n\t * Participate in a save operation of file stored working copies.\n\t * Allows to make changes before content is being saved to disk.\n\t */\n\tparticipate(\n\t\tworkingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>,\n\t\tcontext: IStoredFileWorkingCopySaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface ICreateOperation {\n\tresource: URI;\n\toverwrite?: boolean;\n}\n\nexport interface ICreateFileOperation extends ICreateOperation {\n\tcontents?: VSBuffer | VSBufferReadable | VSBufferReadableStream;\n}\n\nexport interface IDeleteOperation {\n\tresource: URI;\n\tuseTrash?: boolean;\n\trecursive?: boolean;\n}\n\nexport interface IMoveOperation {\n\tfile: Required<SourceTargetPair>;\n\toverwrite?: boolean;\n}\n\nexport interface ICopyOperation extends IMoveOperation { }\n\n/**\n * Returns the working copies for a given resource.\n */\ntype WorkingCopyProvider = (resourceOrFolder: URI) => IWorkingCopy[];\n\n/**\n * A service that allows to perform file operations with working copy support.\n * Any operation that would leave a stale dirty working copy behind will make\n * sure to revert the working copy first.\n *\n * On top of that events are provided to participate in each state of the\n * operation to perform additional work.\n */\nexport interface IWorkingCopyFileService {\n\n\treadonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\t/**\n\t * An event that is fired when a certain working copy IO operation is about to run.\n\t *\n\t * Participants can join this event with a long running operation to keep some state\n\t * before the operation is started, but working copies should not be changed at this\n\t * point in time. For that purpose, use the `IWorkingCopyFileOperationParticipant` API.\n\t */\n\treadonly onWillRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t/**\n\t * An event that is fired after a working copy IO operation has failed.\n\t *\n\t * Participants can join this event with a long running operation to clean up as needed.\n\t */\n\treadonly onDidFailWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t/**\n\t * An event that is fired after a working copy IO operation has been performed.\n\t *\n\t * Participants can join this event with a long running operation to make changes\n\t * after the operation has finished.\n\t */\n\treadonly onDidRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t//#endregion\n\n\n\t//#region File operation participants\n\n\t/**\n\t * Adds a participant for file operations on working copies.\n\t */\n\taddFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable;\n\n\t//#endregion\n\n\n\t//#region Stored File Working Copy save participants\n\n\t/**\n\t * Whether save participants are present for stored file working copies.\n\t */\n\tget hasSaveParticipants(): boolean;\n\n\t/**\n\t * Adds a participant for save operations on stored file working copies.\n\t */\n\taddSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable;\n\n\t/**\n\t * Runs all available save participants for stored file working copies.\n\t */\n\trunSaveParticipants(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: IStoredFileWorkingCopySaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;\n\n\t//#endregion\n\n\n\t//#region File operations\n\n\t/**\n\t * Will create a resource with the provided optional contents, optionally overwriting any target.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tcreate(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will create a folder and any parent folder that needs to be created.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t *\n\t * Note: events will only be emitted for the provided resource, but not any\n\t * parent folders that are being created as part of the operation.\n\t */\n\tcreateFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will move working copies matching the provided resources and corresponding children\n\t * to the target resources using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tmove(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will copy working copies matching the provided resources and corresponding children\n\t * to the target resources using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tcopy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will delete working copies matching the provided resources and children\n\t * using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tdelete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void>;\n\n\t//#endregion\n\n\n\t//#region Path related\n\n\t/**\n\t * Register a new provider for working copies based on a resource.\n\t *\n\t * @return a disposable that unregisters the provider.\n\t */\n\tregisterWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable;\n\n\t/**\n\t * Will return all working copies that are dirty matching the provided resource.\n\t * If the resource is a folder and the scheme supports file operations, a working\n\t * copy that is dirty and is a child of that folder will also be returned.\n\t */\n\tgetDirty(resource: URI): readonly IWorkingCopy[];\n\n\t//#endregion\n}\n\nexport class WorkingCopyFileService extends Disposable implements IWorkingCopyFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\tprivate readonly _onWillRunWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onWillRunWorkingCopyFileOperation = this._onWillRunWorkingCopyFileOperation.event;\n\n\tprivate readonly _onDidFailWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onDidFailWorkingCopyFileOperation = this._onDidFailWorkingCopyFileOperation.event;\n\n\tprivate readonly _onDidRunWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onDidRunWorkingCopyFileOperation = this._onDidRunWorkingCopyFileOperation.event;\n\n\t//#endregion\n\n\tprivate correlationIds = 0;\n\n\tconstructor(\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IWorkingCopyService private readonly workingCopyService: IWorkingCopyService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService\n\t) {\n\t\tsuper();\n\n\t\tthis.fileOperationParticipants = this._register(instantiationService.createInstance(WorkingCopyFileOperationParticipant));\n\t\tthis.saveParticipants = this._register(instantiationService.createInstance(StoredFileWorkingCopySaveParticipant));\n\n\t\t// register a default working copy provider that uses the working copy service\n\t\tthis._register(this.registerWorkingCopyProvider(resource => {\n\t\t\treturn this.workingCopyService.workingCopies.filter(workingCopy => {\n\t\t\t\tif (this.fileService.hasProvider(resource)) {\n\t\t\t\t\t// only check for parents if the resource can be handled\n\t\t\t\t\t// by the file system where we then assume a folder like\n\t\t\t\t\t// path structure\n\t\t\t\t\treturn this.uriIdentityService.extUri.isEqualOrParent(workingCopy.resource, resource);\n\t\t\t\t}\n\n\t\t\t\treturn this.uriIdentityService.extUri.isEqual(workingCopy.resource, resource);\n\t\t\t});\n\t\t}));\n\t}\n\n\n\t//#region File operations\n\n\tcreate(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doCreateFileOrFolder(operations, true, token, undoInfo);\n\t}\n\n\tcreateFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doCreateFileOrFolder(operations, false, token, undoInfo);\n\t}\n\n\tasync doCreateFileOrFolder(operations: (ICreateFileOperation | ICreateOperation)[], isFile: boolean, token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\tif (operations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// validate create operation before starting\n\t\tif (isFile) {\n\t\t\tconst validateCreates = await Promises.settled(operations.map(operation => this.fileService.canCreateFile(operation.resource, { overwrite: operation.overwrite })));\n\t\t\tconst error = validateCreates.find(validateCreate => validateCreate instanceof Error);\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(operation => ({ target: operation.resource }));\n\t\tawait this.runFileOperationParticipants(files, FileOperation.CREATE, undoInfo, token);\n\n\t\t// before events\n\t\tconst event = { correlationId: this.correlationIds++, operation: FileOperation.CREATE, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t// now actually create on disk\n\t\tlet stats: IFileStatWithMetadata[];\n\t\ttry {\n\t\t\tif (isFile) {\n\t\t\t\tstats = await Promises.settled(operations.map(operation => this.fileService.createFile(operation.resource, (operation as ICreateFileOperation).contents, { overwrite: operation.overwrite })));\n\t\t\t} else {\n\t\t\t\tstats = await Promises.settled(operations.map(operation => this.fileService.createFolder(operation.resource)));\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\treturn stats;\n\t}\n\n\tasync move(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doMoveOrCopy(operations, true, token, undoInfo);\n\t}\n\n\tasync copy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doMoveOrCopy(operations, false, token, undoInfo);\n\t}\n\n\tprivate async doMoveOrCopy(operations: IMoveOperation[] | ICopyOperation[], move: boolean, token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\tconst stats: IFileStatWithMetadata[] = [];\n\n\t\t// validate move/copy operation before starting\n\t\tfor (const { file: { source, target }, overwrite } of operations) {\n\t\t\tconst validateMoveOrCopy = await (move ? this.fileService.canMove(source, target, overwrite) : this.fileService.canCopy(source, target, overwrite));\n\t\t\tif (validateMoveOrCopy instanceof Error) {\n\t\t\t\tthrow validateMoveOrCopy;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(o => o.file);\n\t\tawait this.runFileOperationParticipants(files, move ? FileOperation.MOVE : FileOperation.COPY, undoInfo, token);\n\n\t\t// before event\n\t\tconst event = { correlationId: this.correlationIds++, operation: move ? FileOperation.MOVE : FileOperation.COPY, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\ttry {\n\t\t\tfor (const { file: { source, target }, overwrite } of operations) {\n\t\t\t\t// if source and target are not equal, handle dirty working copies\n\t\t\t\t// depending on the operation:\n\t\t\t\t// - move: revert both source and target (if any)\n\t\t\t\t// - copy: revert target (if any)\n\t\t\t\tif (!this.uriIdentityService.extUri.isEqual(source, target)) {\n\t\t\t\t\tconst dirtyWorkingCopies = (move ? [...this.getDirty(source), ...this.getDirty(target)] : this.getDirty(target));\n\t\t\t\t\tawait Promises.settled(dirtyWorkingCopies.map(dirtyWorkingCopy => dirtyWorkingCopy.revert({ soft: true })));\n\t\t\t\t}\n\n\t\t\t\t// now we can rename the source to target via file operation\n\t\t\t\tif (move) {\n\t\t\t\t\tstats.push(await this.fileService.move(source, target, overwrite));\n\t\t\t\t} else {\n\t\t\t\t\tstats.push(await this.fileService.copy(source, target, overwrite));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\treturn stats;\n\t}\n\n\tasync delete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void> {\n\n\t\t// validate delete operation before starting\n\t\tfor (const operation of operations) {\n\t\t\tconst validateDelete = await this.fileService.canDelete(operation.resource, { recursive: operation.recursive, useTrash: operation.useTrash });\n\t\t\tif (validateDelete instanceof Error) {\n\t\t\t\tthrow validateDelete;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(operation => ({ target: operation.resource }));\n\t\tawait this.runFileOperationParticipants(files, FileOperation.DELETE, undoInfo, token);\n\n\t\t// before events\n\t\tconst event = { correlationId: this.correlationIds++, operation: FileOperation.DELETE, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t// check for any existing dirty working copies for the resource\n\t\t// and do a soft revert before deleting to be able to close\n\t\t// any opened editor with these working copies\n\t\tfor (const operation of operations) {\n\t\t\tconst dirtyWorkingCopies = this.getDirty(operation.resource);\n\t\t\tawait Promises.settled(dirtyWorkingCopies.map(dirtyWorkingCopy => dirtyWorkingCopy.revert({ soft: true })));\n\t\t}\n\n\t\t// now actually delete from disk\n\t\ttry {\n\t\t\tfor (const operation of operations) {\n\t\t\t\tawait this.fileService.del(operation.resource, { recursive: operation.recursive, useTrash: operation.useTrash });\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\t}\n\n\t//#endregion\n\n\n\t//#region File operation participants\n\n\tprivate readonly fileOperationParticipants: WorkingCopyFileOperationParticipant;\n\n\taddFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable {\n\t\treturn this.fileOperationParticipants.addFileOperationParticipant(participant);\n\t}\n\n\tprivate runFileOperationParticipants(files: SourceTargetPair[], operation: FileOperation, undoInfo: IFileOperationUndoRedoInfo | undefined, token: CancellationToken): Promise<void> {\n\t\treturn this.fileOperationParticipants.participate(files, operation, undoInfo, token);\n\t}\n\n\t//#endregion\n\n\t//#region Save participants (stored file working copies only)\n\n\tprivate readonly saveParticipants: StoredFileWorkingCopySaveParticipant;\n\n\tget hasSaveParticipants(): boolean { return this.saveParticipants.length > 0; }\n\n\taddSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable {\n\t\treturn this.saveParticipants.addSaveParticipant(participant);\n\t}\n\n\trunSaveParticipants(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: IStoredFileWorkingCopySaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void> {\n\t\treturn this.saveParticipants.participate(workingCopy, context, progress, token);\n\t}\n\n\t//#endregion\n\n\n\t//#region Path related\n\n\tprivate readonly workingCopyProviders: WorkingCopyProvider[] = [];\n\n\tregisterWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable {\n\t\tconst remove = insert(this.workingCopyProviders, provider);\n\n\t\treturn toDisposable(remove);\n\t}\n\n\tgetDirty(resource: URI): IWorkingCopy[] {\n\t\tconst dirtyWorkingCopies = new Set<IWorkingCopy>();\n\t\tfor (const provider of this.workingCopyProviders) {\n\t\t\tfor (const workingCopy of provider(resource)) {\n\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\tdirtyWorkingCopies.add(workingCopy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(dirtyWorkingCopies);\n\t}\n\n\t//#endregion\n}\n\nregisterSingleton(IWorkingCopyFileService, WorkingCopyFileService, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator, IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { Event, AsyncEmitter, IWaitUntil } from '../../../../base/common/event.js';\nimport { Promises } from '../../../../base/common/async.js';\nimport { insert } from '../../../../base/common/arrays.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { IFileService, FileOperation, IFileStatWithMetadata } from '../../../../platform/files/common/files.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IWorkingCopyService } from './workingCopyService.js';\nimport { IWorkingCopy } from './workingCopy.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { WorkingCopyFileOperationParticipant } from './workingCopyFileOperationParticipant.js';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { SaveReason } from '../../../common/editor.js';\nimport { IProgress, IProgressStep } from '../../../../platform/progress/common/progress.js';\nimport { StoredFileWorkingCopySaveParticipant } from './storedFileWorkingCopySaveParticipant.js';\nimport { IStoredFileWorkingCopy, IStoredFileWorkingCopyModel } from './storedFileWorkingCopy.js';\n\nexport const IWorkingCopyFileService = createDecorator<IWorkingCopyFileService>('workingCopyFileService');\n\nexport interface SourceTargetPair {\n\n\t/**\n\t * The source resource that is defined for move operations.\n\t */\n\treadonly source?: URI;\n\n\t/**\n\t * The target resource the event is about.\n\t */\n\treadonly target: URI;\n}\n\nexport interface IFileOperationUndoRedoInfo {\n\n\t/**\n\t * Id of the undo group that the file operation belongs to.\n\t */\n\tundoRedoGroupId?: number;\n\n\t/**\n\t * Flag indicates if the operation is an undo.\n\t */\n\tisUndoing?: boolean;\n}\n\nexport interface WorkingCopyFileEvent extends IWaitUntil {\n\n\t/**\n\t * An identifier to correlate the operation through the\n\t * different event types (before, after, error).\n\t */\n\treadonly correlationId: number;\n\n\t/**\n\t * The file operation that is taking place.\n\t */\n\treadonly operation: FileOperation;\n\n\t/**\n\t * The array of source/target pair of files involved in given operation.\n\t */\n\treadonly files: readonly SourceTargetPair[];\n}\n\nexport interface IWorkingCopyFileOperationParticipant {\n\n\t/**\n\t * Participate in a file operation of working copies. Allows to\n\t * change the working copies before they are being saved to disk.\n\t */\n\tparticipate(\n\t\tfiles: SourceTargetPair[],\n\t\toperation: FileOperation,\n\t\tundoInfo: IFileOperationUndoRedoInfo | undefined,\n\t\ttimeout: number,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface IStoredFileWorkingCopySaveParticipantContext {\n\t/**\n\t * The reason why the save was triggered.\n\t */\n\treadonly reason: SaveReason;\n\n\t/**\n\t * Only applies to when a text file was saved as, for\n\t * example when starting with untitled and saving. This\n\t * provides access to the initial resource the text\n\t * file had before.\n\t */\n\treadonly savedFrom?: URI;\n}\n\nexport interface IStoredFileWorkingCopySaveParticipant {\n\n\t/**\n\t * The ordinal number which determines the order of participation.\n\t * Lower values mean to participant sooner\n\t */\n\treadonly ordinal?: number;\n\n\t/**\n\t * Participate in a save operation of file stored working copies.\n\t * Allows to make changes before content is being saved to disk.\n\t */\n\tparticipate(\n\t\tworkingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>,\n\t\tcontext: IStoredFileWorkingCopySaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface ICreateOperation {\n\tresource: URI;\n\toverwrite?: boolean;\n}\n\nexport interface ICreateFileOperation extends ICreateOperation {\n\tcontents?: VSBuffer | VSBufferReadable | VSBufferReadableStream;\n}\n\nexport interface IDeleteOperation {\n\tresource: URI;\n\tuseTrash?: boolean;\n\trecursive?: boolean;\n}\n\nexport interface IMoveOperation {\n\tfile: Required<SourceTargetPair>;\n\toverwrite?: boolean;\n}\n\nexport interface ICopyOperation extends IMoveOperation { }\n\n/**\n * Returns the working copies for a given resource.\n */\ntype WorkingCopyProvider = (resourceOrFolder: URI) => IWorkingCopy[];\n\n/**\n * A service that allows to perform file operations with working copy support.\n * Any operation that would leave a stale dirty working copy behind will make\n * sure to revert the working copy first.\n *\n * On top of that events are provided to participate in each state of the\n * operation to perform additional work.\n */\nexport interface IWorkingCopyFileService {\n\n\treadonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\t/**\n\t * An event that is fired when a certain working copy IO operation is about to run.\n\t *\n\t * Participants can join this event with a long running operation to keep some state\n\t * before the operation is started, but working copies should not be changed at this\n\t * point in time. For that purpose, use the `IWorkingCopyFileOperationParticipant` API.\n\t */\n\treadonly onWillRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t/**\n\t * An event that is fired after a working copy IO operation has failed.\n\t *\n\t * Participants can join this event with a long running operation to clean up as needed.\n\t */\n\treadonly onDidFailWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t/**\n\t * An event that is fired after a working copy IO operation has been performed.\n\t *\n\t * Participants can join this event with a long running operation to make changes\n\t * after the operation has finished.\n\t */\n\treadonly onDidRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t//#endregion\n\n\n\t//#region File operation participants\n\n\t/**\n\t * Adds a participant for file operations on working copies.\n\t */\n\taddFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable;\n\n\t//#endregion\n\n\n\t//#region Stored File Working Copy save participants\n\n\t/**\n\t * Whether save participants are present for stored file working copies.\n\t */\n\tget hasSaveParticipants(): boolean;\n\n\t/**\n\t * Adds a participant for save operations on stored file working copies.\n\t */\n\taddSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable;\n\n\t/**\n\t * Runs all available save participants for stored file working copies.\n\t */\n\trunSaveParticipants(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: IStoredFileWorkingCopySaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;\n\n\t//#endregion\n\n\n\t//#region File operations\n\n\t/**\n\t * Will create a resource with the provided optional contents, optionally overwriting any target.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tcreate(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will create a folder and any parent folder that needs to be created.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t *\n\t * Note: events will only be emitted for the provided resource, but not any\n\t * parent folders that are being created as part of the operation.\n\t */\n\tcreateFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will move working copies matching the provided resources and corresponding children\n\t * to the target resources using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tmove(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will copy working copies matching the provided resources and corresponding children\n\t * to the target resources using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tcopy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will delete working copies matching the provided resources and children\n\t * using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tdelete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void>;\n\n\t//#endregion\n\n\n\t//#region Path related\n\n\t/**\n\t * Register a new provider for working copies based on a resource.\n\t *\n\t * @return a disposable that unregisters the provider.\n\t */\n\tregisterWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable;\n\n\t/**\n\t * Will return all working copies that are dirty matching the provided resource.\n\t * If the resource is a folder and the scheme supports file operations, a working\n\t * copy that is dirty and is a child of that folder will also be returned.\n\t */\n\tgetDirty(resource: URI): readonly IWorkingCopy[];\n\n\t//#endregion\n}\n\nexport class WorkingCopyFileService extends Disposable implements IWorkingCopyFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\tprivate readonly _onWillRunWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onWillRunWorkingCopyFileOperation = this._onWillRunWorkingCopyFileOperation.event;\n\n\tprivate readonly _onDidFailWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onDidFailWorkingCopyFileOperation = this._onDidFailWorkingCopyFileOperation.event;\n\n\tprivate readonly _onDidRunWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onDidRunWorkingCopyFileOperation = this._onDidRunWorkingCopyFileOperation.event;\n\n\t//#endregion\n\n\tprivate correlationIds = 0;\n\n\tconstructor(\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IWorkingCopyService private readonly workingCopyService: IWorkingCopyService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService\n\t) {\n\t\tsuper();\n\n\t\tthis.fileOperationParticipants = this._register(instantiationService.createInstance(WorkingCopyFileOperationParticipant));\n\t\tthis.saveParticipants = this._register(instantiationService.createInstance(StoredFileWorkingCopySaveParticipant));\n\n\t\t// register a default working copy provider that uses the working copy service\n\t\tthis._register(this.registerWorkingCopyProvider(resource => {\n\t\t\treturn this.workingCopyService.workingCopies.filter(workingCopy => {\n\t\t\t\tif (this.fileService.hasProvider(resource)) {\n\t\t\t\t\t// only check for parents if the resource can be handled\n\t\t\t\t\t// by the file system where we then assume a folder like\n\t\t\t\t\t// path structure\n\t\t\t\t\treturn this.uriIdentityService.extUri.isEqualOrParent(workingCopy.resource, resource);\n\t\t\t\t}\n\n\t\t\t\treturn this.uriIdentityService.extUri.isEqual(workingCopy.resource, resource);\n\t\t\t});\n\t\t}));\n\t}\n\n\n\t//#region File operations\n\n\tcreate(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doCreateFileOrFolder(operations, true, token, undoInfo);\n\t}\n\n\tcreateFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doCreateFileOrFolder(operations, false, token, undoInfo);\n\t}\n\n\tasync doCreateFileOrFolder(operations: (ICreateFileOperation | ICreateOperation)[], isFile: boolean, token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\tif (operations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// validate create operation before starting\n\t\tif (isFile) {\n\t\t\tconst validateCreates = await Promises.settled(operations.map(operation => this.fileService.canCreateFile(operation.resource, { overwrite: operation.overwrite })));\n\t\t\tconst error = validateCreates.find(validateCreate => validateCreate instanceof Error);\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(operation => ({ target: operation.resource }));\n\t\tawait this.runFileOperationParticipants(files, FileOperation.CREATE, undoInfo, token);\n\n\t\t// before events\n\t\tconst event = { correlationId: this.correlationIds++, operation: FileOperation.CREATE, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t// now actually create on disk\n\t\tlet stats: IFileStatWithMetadata[];\n\t\ttry {\n\t\t\tif (isFile) {\n\t\t\t\tstats = await Promises.settled(operations.map(operation => this.fileService.createFile(operation.resource, (operation as ICreateFileOperation).contents, { overwrite: operation.overwrite })));\n\t\t\t} else {\n\t\t\t\tstats = await Promises.settled(operations.map(operation => this.fileService.createFolder(operation.resource)));\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\treturn stats;\n\t}\n\n\tasync move(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doMoveOrCopy(operations, true, token, undoInfo);\n\t}\n\n\tasync copy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doMoveOrCopy(operations, false, token, undoInfo);\n\t}\n\n\tprivate async doMoveOrCopy(operations: IMoveOperation[] | ICopyOperation[], move: boolean, token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\tconst stats: IFileStatWithMetadata[] = [];\n\n\t\t// validate move/copy operation before starting\n\t\tfor (const { file: { source, target }, overwrite } of operations) {\n\t\t\tconst validateMoveOrCopy = await (move ? this.fileService.canMove(source, target, overwrite) : this.fileService.canCopy(source, target, overwrite));\n\t\t\tif (validateMoveOrCopy instanceof Error) {\n\t\t\t\tthrow validateMoveOrCopy;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(o => o.file);\n\t\tawait this.runFileOperationParticipants(files, move ? FileOperation.MOVE : FileOperation.COPY, undoInfo, token);\n\n\t\t// before event\n\t\tconst event = { correlationId: this.correlationIds++, operation: move ? FileOperation.MOVE : FileOperation.COPY, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\ttry {\n\t\t\tfor (const { file: { source, target }, overwrite } of operations) {\n\t\t\t\t// if source and target are not equal, handle dirty working copies\n\t\t\t\t// depending on the operation:\n\t\t\t\t// - move: revert both source and target (if any)\n\t\t\t\t// - copy: revert target (if any)\n\t\t\t\tif (!this.uriIdentityService.extUri.isEqual(source, target)) {\n\t\t\t\t\tconst dirtyWorkingCopies = (move ? [...this.getDirty(source), ...this.getDirty(target)] : this.getDirty(target));\n\t\t\t\t\tawait Promises.settled(dirtyWorkingCopies.map(dirtyWorkingCopy => dirtyWorkingCopy.revert({ soft: true })));\n\t\t\t\t}\n\n\t\t\t\t// now we can rename the source to target via file operation\n\t\t\t\tif (move) {\n\t\t\t\t\tstats.push(await this.fileService.move(source, target, overwrite));\n\t\t\t\t} else {\n\t\t\t\t\tstats.push(await this.fileService.copy(source, target, overwrite));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\treturn stats;\n\t}\n\n\tasync delete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void> {\n\n\t\t// validate delete operation before starting\n\t\tfor (const operation of operations) {\n\t\t\tconst validateDelete = await this.fileService.canDelete(operation.resource, { recursive: operation.recursive, useTrash: operation.useTrash });\n\t\t\tif (validateDelete instanceof Error) {\n\t\t\t\tthrow validateDelete;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(operation => ({ target: operation.resource }));\n\t\tawait this.runFileOperationParticipants(files, FileOperation.DELETE, undoInfo, token);\n\n\t\t// before events\n\t\tconst event = { correlationId: this.correlationIds++, operation: FileOperation.DELETE, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t// check for any existing dirty working copies for the resource\n\t\t// and do a soft revert before deleting to be able to close\n\t\t// any opened editor with these working copies\n\t\tfor (const operation of operations) {\n\t\t\tconst dirtyWorkingCopies = this.getDirty(operation.resource);\n\t\t\tawait Promises.settled(dirtyWorkingCopies.map(dirtyWorkingCopy => dirtyWorkingCopy.revert({ soft: true })));\n\t\t}\n\n\t\t// now actually delete from disk\n\t\ttry {\n\t\t\tfor (const operation of operations) {\n\t\t\t\tawait this.fileService.del(operation.resource, { recursive: operation.recursive, useTrash: operation.useTrash });\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\t}\n\n\t//#endregion\n\n\n\t//#region File operation participants\n\n\tprivate readonly fileOperationParticipants: WorkingCopyFileOperationParticipant;\n\n\taddFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable {\n\t\treturn this.fileOperationParticipants.addFileOperationParticipant(participant);\n\t}\n\n\tprivate runFileOperationParticipants(files: SourceTargetPair[], operation: FileOperation, undoInfo: IFileOperationUndoRedoInfo | undefined, token: CancellationToken): Promise<void> {\n\t\treturn this.fileOperationParticipants.participate(files, operation, undoInfo, token);\n\t}\n\n\t//#endregion\n\n\t//#region Save participants (stored file working copies only)\n\n\tprivate readonly saveParticipants: StoredFileWorkingCopySaveParticipant;\n\n\tget hasSaveParticipants(): boolean { return this.saveParticipants.length > 0; }\n\n\taddSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable {\n\t\treturn this.saveParticipants.addSaveParticipant(participant);\n\t}\n\n\trunSaveParticipants(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: IStoredFileWorkingCopySaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void> {\n\t\treturn this.saveParticipants.participate(workingCopy, context, progress, token);\n\t}\n\n\t//#endregion\n\n\n\t//#region Path related\n\n\tprivate readonly workingCopyProviders: WorkingCopyProvider[] = [];\n\n\tregisterWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable {\n\t\tconst remove = insert(this.workingCopyProviders, provider);\n\n\t\treturn toDisposable(remove);\n\t}\n\n\tgetDirty(resource: URI): IWorkingCopy[] {\n\t\tconst dirtyWorkingCopies = new Set<IWorkingCopy>();\n\t\tfor (const provider of this.workingCopyProviders) {\n\t\t\tfor (const workingCopy of provider(resource)) {\n\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\tdirtyWorkingCopies.add(workingCopy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(dirtyWorkingCopies);\n\t}\n\n\t//#endregion\n}\n\nregisterSingleton(IWorkingCopyFileService, WorkingCopyFileService, InstantiationType.Delayed);\n"]}