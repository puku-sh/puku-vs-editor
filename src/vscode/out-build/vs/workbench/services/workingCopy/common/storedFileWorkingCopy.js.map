{"version":3,"sources":["vs/workbench/services/workingCopy/common/storedFileWorkingCopy.ts"],"names":[],"mappings":"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","file":"storedFileWorkingCopy.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from '../../../../nls.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { ETAG_DISABLED, FileOperationError, FileOperationResult, IFileReadLimits, IFileService, IFileStatWithMetadata, IFileStreamContent, IWriteFileOptions, NotModifiedSinceFileOperationError } from '../../../../platform/files/common/files.js';\nimport { ISaveOptions, IRevertOptions, SaveReason } from '../../../common/editor.js';\nimport { IWorkingCopyService } from './workingCopyService.js';\nimport { IWorkingCopyBackup, IWorkingCopyBackupMeta, IWorkingCopySaveEvent, WorkingCopyCapabilities } from './workingCopy.js';\nimport { raceCancellation, TaskSequentializer, timeout } from '../../../../base/common/async.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { assertReturnsDefined } from '../../../../base/common/types.js';\nimport { IWorkingCopyFileService } from './workingCopyFileService.js';\nimport { VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { IFilesConfigurationService } from '../../filesConfiguration/common/filesConfigurationService.js';\nimport { IWorkingCopyBackupService, IResolvedWorkingCopyBackup } from './workingCopyBackup.js';\nimport { INotificationService, Severity } from '../../../../platform/notification/common/notification.js';\nimport { hash } from '../../../../base/common/hash.js';\nimport { isErrorWithActions, toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { IAction, toAction } from '../../../../base/common/actions.js';\nimport { isWindows } from '../../../../base/common/platform.js';\nimport { IWorkingCopyEditorService } from './workingCopyEditorService.js';\nimport { IEditorService } from '../../editor/common/editorService.js';\nimport { IElevatedFileService } from '../../files/common/elevatedFileService.js';\nimport { IResourceWorkingCopy, ResourceWorkingCopy } from './resourceWorkingCopy.js';\nimport { IFileWorkingCopy, IFileWorkingCopyModel, IFileWorkingCopyModelFactory, SnapshotContext } from './fileWorkingCopy.js';\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\nimport { IProgress, IProgressService, IProgressStep, ProgressLocation } from '../../../../platform/progress/common/progress.js';\nimport { isCancellationError } from '../../../../base/common/errors.js';\n\n/**\n * Stored file specific working copy model factory.\n */\nexport interface IStoredFileWorkingCopyModelFactory<M extends IStoredFileWorkingCopyModel> extends IFileWorkingCopyModelFactory<M> { }\n\n/**\n * The underlying model of a stored file working copy provides some\n * methods for the stored file working copy to function. The model is\n * typically only available after the working copy has been\n * resolved via it's `resolve()` method.\n */\nexport interface IStoredFileWorkingCopyModel extends IFileWorkingCopyModel {\n\n\treadonly onDidChangeContent: Event<IStoredFileWorkingCopyModelContentChangedEvent>;\n\n\t/**\n\t * A version ID of the model. If a `onDidChangeContent` is fired\n\t * from the model and the last known saved `versionId` matches\n\t * with the `model.versionId`, the stored file working copy will\n\t * discard any dirty state.\n\t *\n\t * A use case is the following:\n\t * - a stored file working copy gets edited and thus dirty\n\t * - the user triggers undo to revert the changes\n\t * - at this point the `versionId` should match the one we had saved\n\t *\n\t * This requires the model to be aware of undo/redo operations.\n\t */\n\treadonly versionId: unknown;\n\n\t/**\n\t * Close the current undo-redo element. This offers a way\n\t * to create an undo/redo stop point.\n\t *\n\t * This method may for example be called right before the\n\t * save is triggered so that the user can always undo back\n\t * to the state before saving.\n\t */\n\tpushStackElement(): void;\n\n\t/**\n\t * Optionally allows a stored file working copy model to\n\t * implement the `save` method. This allows to implement\n\t * a more efficient save logic compared to the default\n\t * which is to ask the model for a `snapshot` and then\n\t * writing that to the model's resource.\n\t */\n\tsave?(options: IWriteFileOptions, token: CancellationToken): Promise<IFileStatWithMetadata>;\n}\n\nexport interface IStoredFileWorkingCopyModelContentChangedEvent {\n\n\t/**\n\t * Flag that indicates that this event was generated while undoing.\n\t */\n\treadonly isUndoing: boolean;\n\n\t/**\n\t * Flag that indicates that this event was generated while redoing.\n\t */\n\treadonly isRedoing: boolean;\n}\n\n/**\n * A stored file based `IWorkingCopy` is backed by a `URI` from a\n * known file system provider. Given this assumption, a lot\n * of functionality can be built on top, such as saving in\n * a secure way to prevent data loss.\n */\nexport interface IStoredFileWorkingCopy<M extends IStoredFileWorkingCopyModel> extends IResourceWorkingCopy, IFileWorkingCopy<M> {\n\n\t/**\n\t * An event for when a stored file working copy was resolved.\n\t */\n\treadonly onDidResolve: Event<void>;\n\n\t/**\n\t * An event for when a stored file working copy was saved successfully.\n\t */\n\treadonly onDidSave: Event<IStoredFileWorkingCopySaveEvent>;\n\n\t/**\n\t * An event indicating that a stored file working copy save operation failed.\n\t */\n\treadonly onDidSaveError: Event<void>;\n\n\t/**\n\t * An event for when the readonly state of the stored file working copy changes.\n\t */\n\treadonly onDidChangeReadonly: Event<void>;\n\n\t/**\n\t * Resolves a stored file working copy.\n\t */\n\tresolve(options?: IStoredFileWorkingCopyResolveOptions): Promise<void>;\n\n\t/**\n\t * Explicitly sets the working copy to be modified.\n\t */\n\tmarkModified(): void;\n\n\t/**\n\t * Whether the stored file working copy is in the provided `state`\n\t * or not.\n\t *\n\t * @param state the `FileWorkingCopyState` to check on.\n\t */\n\thasState(state: StoredFileWorkingCopyState): boolean;\n\n\t/**\n\t * Allows to join a state change away from the provided `state`.\n\t *\n\t * @param state currently only `FileWorkingCopyState.PENDING_SAVE`\n\t * can be awaited on to resolve.\n\t */\n\tjoinState(state: StoredFileWorkingCopyState.PENDING_SAVE): Promise<void>;\n\n\t/**\n\t * Whether we have a resolved model or not.\n\t */\n\tisResolved(): this is IResolvedStoredFileWorkingCopy<M>;\n\n\t/**\n\t * Whether the stored file working copy is readonly or not.\n\t */\n\tisReadonly(): boolean | IMarkdownString;\n\n\t/**\n\t * Asks the stored file working copy to save. If the stored file\n\t * working copy was dirty, it is expected to be non-dirty after\n\t * this operation has finished.\n\t *\n\t * @returns `true` if the operation was successful and `false` otherwise.\n\t */\n\tsave(options?: IStoredFileWorkingCopySaveAsOptions): Promise<boolean>;\n}\n\nexport interface IResolvedStoredFileWorkingCopy<M extends IStoredFileWorkingCopyModel> extends IStoredFileWorkingCopy<M> {\n\n\t/**\n\t * A resolved stored file working copy has a resolved model.\n\t */\n\treadonly model: M;\n}\n\n/**\n * States the stored file working copy can be in.\n */\nexport const enum StoredFileWorkingCopyState {\n\n\t/**\n\t * A stored file working copy is saved.\n\t */\n\tSAVED,\n\n\t/**\n\t * A stored file working copy is dirty.\n\t */\n\tDIRTY,\n\n\t/**\n\t * A stored file working copy is currently being saved but\n\t * this operation has not completed yet.\n\t */\n\tPENDING_SAVE,\n\n\t/**\n\t * A stored file working copy is in conflict mode when changes\n\t * cannot be saved because the underlying file has changed.\n\t * Stored file working copies in conflict mode are always dirty.\n\t */\n\tCONFLICT,\n\n\t/**\n\t * A stored file working copy is in orphan state when the underlying\n\t * file has been deleted.\n\t */\n\tORPHAN,\n\n\t/**\n\t * Any error that happens during a save that is not causing\n\t * the `StoredFileWorkingCopyState.CONFLICT` state.\n\t * Stored file working copies in error mode are always dirty.\n\t */\n\tERROR\n}\n\nexport interface IStoredFileWorkingCopySaveOptions extends ISaveOptions {\n\n\t/**\n\t * Save the stored file working copy with an attempt to unlock it.\n\t */\n\treadonly writeUnlock?: boolean;\n\n\t/**\n\t * Save the stored file working copy with elevated privileges.\n\t *\n\t * Note: This may not be supported in all environments.\n\t */\n\treadonly writeElevated?: boolean;\n\n\t/**\n\t * Allows to write to a stored file working copy even if it has been\n\t * modified on disk. This should only be triggered from an\n\t * explicit user action.\n\t */\n\treadonly ignoreModifiedSince?: boolean;\n\n\t/**\n\t * If set, will bubble up the stored file working copy save error to\n\t * the caller instead of handling it.\n\t */\n\treadonly ignoreErrorHandler?: boolean;\n}\n\nexport interface IStoredFileWorkingCopySaveAsOptions extends IStoredFileWorkingCopySaveOptions {\n\n\t/**\n\t * Optional URI of the resource the text file is saved from if known.\n\t */\n\treadonly from?: URI;\n}\n\nexport interface IStoredFileWorkingCopyResolver {\n\n\t/**\n\t * Resolves the working copy in a safe way from an external\n\t * working copy manager that can make sure multiple parallel\n\t * resolves execute properly.\n\t */\n\t(options?: IStoredFileWorkingCopyResolveOptions): Promise<void>;\n}\n\nexport interface IStoredFileWorkingCopyResolveOptions {\n\n\t/**\n\t * The contents to use for the stored file working copy if known. If not\n\t * provided, the contents will be retrieved from the underlying\n\t * resource or backup if present.\n\t *\n\t * If contents are provided, the stored file working copy will be marked\n\t * as dirty right from the beginning.\n\t */\n\treadonly contents?: VSBufferReadableStream;\n\n\t/**\n\t * Go to disk bypassing any cache of the stored file working copy if any.\n\t */\n\treadonly forceReadFromFile?: boolean;\n\n\t/**\n\t * If provided, the size of the file will be checked against the limits\n\t * and an error will be thrown if any limit is exceeded.\n\t */\n\treadonly limits?: IFileReadLimits;\n}\n\n/**\n * Metadata associated with a stored file working copy backup.\n */\ninterface IStoredFileWorkingCopyBackupMetaData extends IWorkingCopyBackupMeta {\n\treadonly mtime: number;\n\treadonly ctime: number;\n\treadonly size: number;\n\treadonly etag: string;\n\treadonly orphaned: boolean;\n}\n\nexport interface IStoredFileWorkingCopySaveEvent extends IWorkingCopySaveEvent {\n\n\t/**\n\t * The resolved stat from the save operation.\n\t */\n\treadonly stat: IFileStatWithMetadata;\n}\n\nexport function isStoredFileWorkingCopySaveEvent(e: IWorkingCopySaveEvent): e is IStoredFileWorkingCopySaveEvent {\n\tconst candidate = e as IStoredFileWorkingCopySaveEvent;\n\n\treturn !!candidate.stat;\n}\n\nexport class StoredFileWorkingCopy<M extends IStoredFileWorkingCopyModel> extends ResourceWorkingCopy implements IStoredFileWorkingCopy<M> {\n\n\treadonly capabilities: WorkingCopyCapabilities = WorkingCopyCapabilities.None;\n\n\tprivate _model: M | undefined = undefined;\n\tget model(): M | undefined { return this._model; }\n\n\t//#region events\n\n\tprivate readonly _onDidChangeContent = this._register(new Emitter<void>());\n\treadonly onDidChangeContent = this._onDidChangeContent.event;\n\n\tprivate readonly _onDidResolve = this._register(new Emitter<void>());\n\treadonly onDidResolve = this._onDidResolve.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<void>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidSaveError = this._register(new Emitter<void>());\n\treadonly onDidSaveError = this._onDidSaveError.event;\n\n\tprivate readonly _onDidSave = this._register(new Emitter<IStoredFileWorkingCopySaveEvent>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\tprivate readonly _onDidRevert = this._register(new Emitter<void>());\n\treadonly onDidRevert = this._onDidRevert.event;\n\n\tprivate readonly _onDidChangeReadonly = this._register(new Emitter<void>());\n\treadonly onDidChangeReadonly = this._onDidChangeReadonly.event;\n\n\t//#endregion\n\n\tconstructor(\n\t\treadonly typeId: string,\n\t\tresource: URI,\n\t\treadonly name: string,\n\t\tprivate readonly modelFactory: IStoredFileWorkingCopyModelFactory<M>,\n\t\tprivate readonly externalResolver: IStoredFileWorkingCopyResolver,\n\t\t@IFileService fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWorkingCopyFileService private readonly workingCopyFileService: IWorkingCopyFileService,\n\t\t@IFilesConfigurationService private readonly filesConfigurationService: IFilesConfigurationService,\n\t\t@IWorkingCopyBackupService private readonly workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IWorkingCopyService workingCopyService: IWorkingCopyService,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@IWorkingCopyEditorService private readonly workingCopyEditorService: IWorkingCopyEditorService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IElevatedFileService private readonly elevatedFileService: IElevatedFileService,\n\t\t@IProgressService private readonly progressService: IProgressService\n\t) {\n\t\tsuper(resource, fileService);\n\n\t\t// Make known to working copy service\n\t\tthis._register(workingCopyService.registerWorkingCopy(this));\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.filesConfigurationService.onDidChangeReadonly(() => this._onDidChangeReadonly.fire()));\n\t}\n\n\t//#region Dirty\n\n\tprivate dirty = false;\n\tprivate savedVersionId: unknown;\n\n\tisDirty(): this is IResolvedStoredFileWorkingCopy<M> {\n\t\treturn this.dirty;\n\t}\n\n\tmarkModified(): void {\n\t\tthis.setDirty(true); // stored file working copy tracks modified via dirty\n\t}\n\n\tprivate setDirty(dirty: boolean): void {\n\t\tif (!this.isResolved()) {\n\t\t\treturn; // only resolved working copies can be marked dirty\n\t\t}\n\n\t\t// Track dirty state and version id\n\t\tconst wasDirty = this.dirty;\n\t\tthis.doSetDirty(dirty);\n\n\t\t// Emit as Event if dirty changed\n\t\tif (dirty !== wasDirty) {\n\t\t\tthis._onDidChangeDirty.fire();\n\t\t}\n\t}\n\n\tprivate doSetDirty(dirty: boolean): () => void {\n\t\tconst wasDirty = this.dirty;\n\t\tconst wasInConflictMode = this.inConflictMode;\n\t\tconst wasInErrorMode = this.inErrorMode;\n\t\tconst oldSavedVersionId = this.savedVersionId;\n\n\t\tif (!dirty) {\n\t\t\tthis.dirty = false;\n\t\t\tthis.inConflictMode = false;\n\t\t\tthis.inErrorMode = false;\n\n\t\t\t// we remember the models alternate version id to remember when the version\n\t\t\t// of the model matches with the saved version on disk. we need to keep this\n\t\t\t// in order to find out if the model changed back to a saved version (e.g.\n\t\t\t// when undoing long enough to reach to a version that is saved and then to\n\t\t\t// clear the dirty flag)\n\t\t\tif (this.isResolved()) {\n\t\t\t\tthis.savedVersionId = this.model.versionId;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.dirty = true;\n\t\t}\n\n\t\t// Return function to revert this call\n\t\treturn () => {\n\t\t\tthis.dirty = wasDirty;\n\t\t\tthis.inConflictMode = wasInConflictMode;\n\t\t\tthis.inErrorMode = wasInErrorMode;\n\t\t\tthis.savedVersionId = oldSavedVersionId;\n\t\t};\n\t}\n\n\t//#endregion\n\n\t//#region Resolve\n\n\tlastResolvedFileStat: IFileStatWithMetadata | undefined; // !!! DO NOT MARK PRIVATE! USED IN TESTS !!!\n\n\tisResolved(): this is IResolvedStoredFileWorkingCopy<M> {\n\t\treturn !!this.model;\n\t}\n\n\tasync resolve(options?: IStoredFileWorkingCopyResolveOptions): Promise<void> {\n\t\tthis.trace('resolve() - enter');\n\n\t\t// Return early if we are disposed\n\t\tif (this.isDisposed()) {\n\t\t\tthis.trace('resolve() - exit - without resolving because file working copy is disposed');\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Unless there are explicit contents provided, it is important that we do not\n\t\t// resolve a working copy that is dirty or is in the process of saving to prevent\n\t\t// data loss.\n\t\tif (!options?.contents && (this.dirty || this.saveSequentializer.isRunning())) {\n\t\t\tthis.trace('resolve() - exit - without resolving because file working copy is dirty or being saved');\n\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doResolve(options);\n\t}\n\n\tprivate async doResolve(options?: IStoredFileWorkingCopyResolveOptions): Promise<void> {\n\n\t\t// First check if we have contents to use for the working copy\n\t\tif (options?.contents) {\n\t\t\treturn this.resolveFromBuffer(options.contents);\n\t\t}\n\n\t\t// Second, check if we have a backup to resolve from (only for new working copies)\n\t\tconst isNew = !this.isResolved();\n\t\tif (isNew) {\n\t\t\tconst resolvedFromBackup = await this.resolveFromBackup();\n\t\t\tif (resolvedFromBackup) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Finally, resolve from file resource\n\t\treturn this.resolveFromFile(options);\n\t}\n\n\tprivate async resolveFromBuffer(buffer: VSBufferReadableStream): Promise<void> {\n\t\tthis.trace('resolveFromBuffer()');\n\n\t\t// Try to resolve metdata from disk\n\t\tlet mtime: number;\n\t\tlet ctime: number;\n\t\tlet size: number;\n\t\tlet etag: string;\n\t\ttry {\n\t\t\tconst metadata = await this.fileService.stat(this.resource);\n\t\t\tmtime = metadata.mtime;\n\t\t\tctime = metadata.ctime;\n\t\t\tsize = metadata.size;\n\t\t\tetag = metadata.etag;\n\n\t\t\t// Clear orphaned state when resolving was successful\n\t\t\tthis.setOrphaned(false);\n\t\t} catch (error) {\n\n\t\t\t// Put some fallback values in error case\n\t\t\tmtime = Date.now();\n\t\t\tctime = Date.now();\n\t\t\tsize = 0;\n\t\t\tetag = ETAG_DISABLED;\n\n\t\t\t// Apply orphaned state based on error code\n\t\t\tthis.setOrphaned(error.fileOperationResult === FileOperationResult.FILE_NOT_FOUND);\n\t\t}\n\n\t\t// Resolve with buffer\n\t\treturn this.resolveFromContent({\n\t\t\tresource: this.resource,\n\t\t\tname: this.name,\n\t\t\tmtime,\n\t\t\tctime,\n\t\t\tsize,\n\t\t\tetag,\n\t\t\tvalue: buffer,\n\t\t\treadonly: false,\n\t\t\tlocked: false\n\t\t}, true /* dirty (resolved from buffer) */);\n\t}\n\n\tprivate async resolveFromBackup(): Promise<boolean> {\n\n\t\t// Resolve backup if any\n\t\tconst backup = await this.workingCopyBackupService.resolve<IStoredFileWorkingCopyBackupMetaData>(this);\n\n\t\t// Abort if someone else managed to resolve the working copy by now\n\t\tconst isNew = !this.isResolved();\n\t\tif (!isNew) {\n\t\t\tthis.trace('resolveFromBackup() - exit - withoutresolving because previously new file working copy got created meanwhile');\n\n\t\t\treturn true; // imply that resolving has happened in another operation\n\t\t}\n\n\t\t// Try to resolve from backup if we have any\n\t\tif (backup) {\n\t\t\tawait this.doResolveFromBackup(backup);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Otherwise signal back that resolving did not happen\n\t\treturn false;\n\t}\n\n\tprivate async doResolveFromBackup(backup: IResolvedWorkingCopyBackup<IStoredFileWorkingCopyBackupMetaData>): Promise<void> {\n\t\tthis.trace('doResolveFromBackup()');\n\n\t\t// Resolve with backup\n\t\tawait this.resolveFromContent({\n\t\t\tresource: this.resource,\n\t\t\tname: this.name,\n\t\t\tmtime: backup.meta ? backup.meta.mtime : Date.now(),\n\t\t\tctime: backup.meta ? backup.meta.ctime : Date.now(),\n\t\t\tsize: backup.meta ? backup.meta.size : 0,\n\t\t\tetag: backup.meta ? backup.meta.etag : ETAG_DISABLED, // etag disabled if unknown!\n\t\t\tvalue: backup.value,\n\t\t\treadonly: false,\n\t\t\tlocked: false\n\t\t}, true /* dirty (resolved from backup) */);\n\n\t\t// Restore orphaned flag based on state\n\t\tif (backup.meta?.orphaned) {\n\t\t\tthis.setOrphaned(true);\n\t\t}\n\t}\n\n\tprivate async resolveFromFile(options?: IStoredFileWorkingCopyResolveOptions): Promise<void> {\n\t\tthis.trace('resolveFromFile()');\n\n\t\tconst forceReadFromFile = options?.forceReadFromFile;\n\n\t\t// Decide on etag\n\t\tlet etag: string | undefined;\n\t\tif (forceReadFromFile) {\n\t\t\tetag = ETAG_DISABLED; // disable ETag if we enforce to read from disk\n\t\t} else if (this.lastResolvedFileStat) {\n\t\t\tetag = this.lastResolvedFileStat.etag; // otherwise respect etag to support caching\n\t\t}\n\n\t\t// Remember current version before doing any long running operation\n\t\t// to ensure we are not changing a working copy that was changed\n\t\t// meanwhile\n\t\tconst currentVersionId = this.versionId;\n\n\t\t// Resolve Content\n\t\ttry {\n\t\t\tconst content = await this.fileService.readFileStream(this.resource, {\n\t\t\t\tetag,\n\t\t\t\tlimits: options?.limits\n\t\t\t});\n\n\t\t\t// Clear orphaned state when resolving was successful\n\t\t\tthis.setOrphaned(false);\n\n\t\t\t// Return early if the working copy content has changed\n\t\t\t// meanwhile to prevent loosing any changes\n\t\t\tif (currentVersionId !== this.versionId) {\n\t\t\t\tthis.trace('resolveFromFile() - exit - without resolving because file working copy content changed');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait this.resolveFromContent(content, false /* not dirty (resolved from file) */);\n\t\t} catch (error) {\n\t\t\tconst result = error.fileOperationResult;\n\n\t\t\t// Apply orphaned state based on error code\n\t\t\tthis.setOrphaned(result === FileOperationResult.FILE_NOT_FOUND);\n\n\t\t\t// NotModified status is expected and can be handled gracefully\n\t\t\t// if we are resolved. We still want to update our last resolved\n\t\t\t// stat to e.g. detect changes to the file's readonly state\n\t\t\tif (this.isResolved() && result === FileOperationResult.FILE_NOT_MODIFIED_SINCE) {\n\t\t\t\tif (error instanceof NotModifiedSinceFileOperationError) {\n\t\t\t\t\tthis.updateLastResolvedFileStat(error.stat);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Unless we are forced to read from the file, ignore when a working copy has\n\t\t\t// been resolved once and the file was deleted meanwhile. Since we already have\n\t\t\t// the working copy resolved, we can return to this state and update the orphaned\n\t\t\t// flag to indicate that this working copy has no version on disk anymore.\n\t\t\tif (this.isResolved() && result === FileOperationResult.FILE_NOT_FOUND && !forceReadFromFile) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise bubble up the error\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async resolveFromContent(content: IFileStreamContent, dirty: boolean): Promise<void> {\n\t\tthis.trace('resolveFromContent() - enter');\n\n\t\t// Return early if we are disposed\n\t\tif (this.isDisposed()) {\n\t\t\tthis.trace('resolveFromContent() - exit - because working copy is disposed');\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Update our resolved disk stat\n\t\tthis.updateLastResolvedFileStat({\n\t\t\tresource: this.resource,\n\t\t\tname: content.name,\n\t\t\tmtime: content.mtime,\n\t\t\tctime: content.ctime,\n\t\t\tsize: content.size,\n\t\t\tetag: content.etag,\n\t\t\treadonly: content.readonly,\n\t\t\tlocked: content.locked,\n\t\t\tisFile: true,\n\t\t\tisDirectory: false,\n\t\t\tisSymbolicLink: false,\n\t\t\tchildren: undefined\n\t\t});\n\n\t\t// Update existing model if we had been resolved\n\t\tif (this.isResolved()) {\n\t\t\tawait this.doUpdateModel(content.value);\n\t\t}\n\n\t\t// Create new model otherwise\n\t\telse {\n\t\t\tawait this.doCreateModel(content.value);\n\t\t}\n\n\t\t// Update working copy dirty flag. This is very important to call\n\t\t// in both cases of dirty or not because it conditionally updates\n\t\t// the `savedVersionId` to determine the version when to consider\n\t\t// the working copy as saved again (e.g. when undoing back to the\n\t\t// saved state)\n\t\tthis.setDirty(!!dirty);\n\n\t\t// Emit as event\n\t\tthis._onDidResolve.fire();\n\t}\n\n\tprivate async doCreateModel(contents: VSBufferReadableStream): Promise<void> {\n\t\tthis.trace('doCreateModel()');\n\n\t\t// Create model and dispose it when we get disposed\n\t\tthis._model = this._register(await this.modelFactory.createModel(this.resource, contents, CancellationToken.None));\n\n\t\t// Model listeners\n\t\tthis.installModelListeners(this._model);\n\t}\n\n\tprivate ignoreDirtyOnModelContentChange = false;\n\n\tprivate async doUpdateModel(contents: VSBufferReadableStream): Promise<void> {\n\t\tthis.trace('doUpdateModel()');\n\n\t\t// Update model value in a block that ignores content change events for dirty tracking\n\t\tthis.ignoreDirtyOnModelContentChange = true;\n\t\ttry {\n\t\t\tawait this.model?.update(contents, CancellationToken.None);\n\t\t} finally {\n\t\t\tthis.ignoreDirtyOnModelContentChange = false;\n\t\t}\n\t}\n\n\tprivate installModelListeners(model: M): void {\n\n\t\t// See https://github.com/microsoft/vscode/issues/30189\n\t\t// This code has been extracted to a different method because it caused a memory leak\n\t\t// where `value` was captured in the content change listener closure scope.\n\n\t\t// Content Change\n\t\tthis._register(model.onDidChangeContent(e => this.onModelContentChanged(model, e.isUndoing || e.isRedoing)));\n\n\t\t// Lifecycle\n\t\tthis._register(model.onWillDispose(() => this.dispose()));\n\t}\n\n\tprivate onModelContentChanged(model: M, isUndoingOrRedoing: boolean): void {\n\t\tthis.trace(`onModelContentChanged() - enter`);\n\n\t\t// In any case increment the version id because it tracks the content state of the model at all times\n\t\tthis.versionId++;\n\t\tthis.trace(`onModelContentChanged() - new versionId ${this.versionId}`);\n\n\t\t// Remember when the user changed the model through a undo/redo operation.\n\t\t// We need this information to throttle save participants to fix\n\t\t// https://github.com/microsoft/vscode/issues/102542\n\t\tif (isUndoingOrRedoing) {\n\t\t\tthis.lastContentChangeFromUndoRedo = Date.now();\n\t\t}\n\n\t\t// We mark check for a dirty-state change upon model content change, unless:\n\t\t// - explicitly instructed to ignore it (e.g. from model.resolve())\n\t\t// - the model is readonly (in that case we never assume the change was done by the user)\n\t\tif (!this.ignoreDirtyOnModelContentChange && !this.isReadonly()) {\n\n\t\t\t// The contents changed as a matter of Undo and the version reached matches the saved one\n\t\t\t// In this case we clear the dirty flag and emit a SAVED event to indicate this state.\n\t\t\tif (model.versionId === this.savedVersionId) {\n\t\t\t\tthis.trace('onModelContentChanged() - model content changed back to last saved version');\n\n\t\t\t\t// Clear flags\n\t\t\t\tconst wasDirty = this.dirty;\n\t\t\t\tthis.setDirty(false);\n\n\t\t\t\t// Emit revert event if we were dirty\n\t\t\t\tif (wasDirty) {\n\t\t\t\t\tthis._onDidRevert.fire();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise the content has changed and we signal this as becoming dirty\n\t\t\telse {\n\t\t\t\tthis.trace('onModelContentChanged() - model content changed and marked as dirty');\n\n\t\t\t\t// Mark as dirty\n\t\t\t\tthis.setDirty(true);\n\t\t\t}\n\t\t}\n\n\t\t// Emit as event\n\t\tthis._onDidChangeContent.fire();\n\t}\n\n\tprivate async forceResolveFromFile(): Promise<void> {\n\t\tif (this.isDisposed()) {\n\t\t\treturn; // return early when the working copy is invalid\n\t\t}\n\n\t\t// We go through the resolver to make\n\t\t// sure this kind of `resolve` is properly\n\t\t// running in sequence with any other running\n\t\t// `resolve` if any, including subsequent runs\n\t\t// that are triggered right after.\n\n\t\tawait this.externalResolver({\n\t\t\tforceReadFromFile: true\n\t\t});\n\t}\n\n\t//#endregion\n\n\t//#region Backup\n\n\tget backupDelay(): number | undefined {\n\t\treturn this.model?.configuration?.backupDelay;\n\t}\n\n\tasync backup(token: CancellationToken): Promise<IWorkingCopyBackup> {\n\n\t\t// Fill in metadata if we are resolved\n\t\tlet meta: IStoredFileWorkingCopyBackupMetaData | undefined = undefined;\n\t\tif (this.lastResolvedFileStat) {\n\t\t\tmeta = {\n\t\t\t\tmtime: this.lastResolvedFileStat.mtime,\n\t\t\t\tctime: this.lastResolvedFileStat.ctime,\n\t\t\t\tsize: this.lastResolvedFileStat.size,\n\t\t\t\tetag: this.lastResolvedFileStat.etag,\n\t\t\t\torphaned: this.isOrphaned()\n\t\t\t};\n\t\t}\n\n\t\t// Fill in content if we are resolved\n\t\tlet content: VSBufferReadableStream | undefined = undefined;\n\t\tif (this.isResolved()) {\n\t\t\tcontent = await raceCancellation(this.model.snapshot(SnapshotContext.Backup, token), token);\n\t\t}\n\n\t\treturn { meta, content };\n\t}\n\n\t//#endregion\n\n\t//#region Save\n\n\tprivate versionId = 0;\n\n\tprivate static readonly UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD = 500;\n\tprivate lastContentChangeFromUndoRedo: number | undefined = undefined;\n\n\tprivate readonly saveSequentializer = new TaskSequentializer();\n\n\tprivate ignoreSaveFromSaveParticipants = false;\n\n\tasync save(options: IStoredFileWorkingCopySaveAsOptions = Object.create(null)): Promise<boolean> {\n\t\tif (!this.isResolved()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.isReadonly()) {\n\t\t\tthis.trace('save() - ignoring request for readonly resource');\n\n\t\t\treturn false; // if working copy is readonly we do not attempt to save at all\n\t\t}\n\n\t\tif (\n\t\t\t(this.hasState(StoredFileWorkingCopyState.CONFLICT) || this.hasState(StoredFileWorkingCopyState.ERROR)) &&\n\t\t\t(options.reason === SaveReason.AUTO || options.reason === SaveReason.FOCUS_CHANGE || options.reason === SaveReason.WINDOW_CHANGE)\n\t\t) {\n\t\t\tthis.trace('save() - ignoring auto save request for file working copy that is in conflict or error');\n\n\t\t\treturn false; // if working copy is in save conflict or error, do not save unless save reason is explicit\n\t\t}\n\n\t\t// Actually do save\n\t\tthis.trace('save() - enter');\n\t\tawait this.doSave(options);\n\t\tthis.trace('save() - exit');\n\n\t\treturn this.hasState(StoredFileWorkingCopyState.SAVED);\n\t}\n\n\tprivate async doSave(options: IStoredFileWorkingCopySaveAsOptions): Promise<void> {\n\t\tif (typeof options.reason !== 'number') {\n\t\t\toptions.reason = SaveReason.EXPLICIT;\n\t\t}\n\n\t\tconst versionId = this.versionId;\n\t\tthis.trace(`doSave(${versionId}) - enter with versionId ${versionId}`);\n\n\t\t// Return early if saved from within save participant to break recursion\n\t\t//\n\t\t// Scenario: a save participant triggers a save() on the working copy\n\t\tif (this.ignoreSaveFromSaveParticipants) {\n\t\t\tthis.trace(`doSave(${versionId}) - exit - refusing to save() recursively from save participant`);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Lookup any running save for this versionId and return it if found\n\t\t//\n\t\t// Scenario: user invoked the save action multiple times quickly for the same contents\n\t\t//           while the save was not yet finished to disk\n\t\t//\n\t\tif (this.saveSequentializer.isRunning(versionId)) {\n\t\t\tthis.trace(`doSave(${versionId}) - exit - found a running save for versionId ${versionId}`);\n\n\t\t\treturn this.saveSequentializer.running;\n\t\t}\n\n\t\t// Return early if not dirty (unless forced)\n\t\t//\n\t\t// Scenario: user invoked save action even though the working copy is not dirty\n\t\tif (!options.force && !this.dirty) {\n\t\t\tthis.trace(`doSave(${versionId}) - exit - because not dirty and/or versionId is different (this.isDirty: ${this.dirty}, this.versionId: ${this.versionId})`);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Return if currently saving by storing this save request as the next save that should happen.\n\t\t// Never ever must 2 saves execute at the same time because this can lead to dirty writes and race conditions.\n\t\t//\n\t\t// Scenario A: auto save was triggered and is currently busy saving to disk. this takes long enough that another auto save\n\t\t//             kicks in.\n\t\t// Scenario B: save is very slow (e.g. network share) and the user manages to change the working copy and trigger another save\n\t\t//             while the first save has not returned yet.\n\t\t//\n\t\tif (this.saveSequentializer.isRunning()) {\n\t\t\tthis.trace(`doSave(${versionId}) - exit - because busy saving`);\n\n\t\t\t// Indicate to the save sequentializer that we want to\n\t\t\t// cancel the running operation so that ours can run\n\t\t\t// before the running one finishes.\n\t\t\t// Currently this will try to cancel running save\n\t\t\t// participants and running snapshots from the\n\t\t\t// save operation, but not the actual save which does\n\t\t\t// not support cancellation yet.\n\t\t\tthis.saveSequentializer.cancelRunning();\n\n\t\t\t// Queue this as the upcoming save and return\n\t\t\treturn this.saveSequentializer.queue(() => this.doSave(options));\n\t\t}\n\n\t\t// Push all edit operations to the undo stack so that the user has a chance to\n\t\t// Ctrl+Z back to the saved version.\n\t\tif (this.isResolved()) {\n\t\t\tthis.model.pushStackElement();\n\t\t}\n\n\t\tconst saveCancellation = new CancellationTokenSource();\n\n\t\treturn this.progressService.withProgress({\n\t\t\ttitle: localize('saveParticipants', \"Saving '{0}'\", this.name),\n\t\t\tlocation: ProgressLocation.Window,\n\t\t\tcancellable: true,\n\t\t\tdelay: this.isDirty() ? 3000 : 5000\n\t\t}, progress => {\n\t\t\treturn this.doSaveSequential(versionId, options, progress, saveCancellation);\n\t\t}, () => {\n\t\t\tsaveCancellation.cancel();\n\t\t}).finally(() => {\n\t\t\tsaveCancellation.dispose();\n\t\t});\n\t}\n\n\tprivate doSaveSequential(versionId: number, options: IStoredFileWorkingCopySaveAsOptions, progress: IProgress<IProgressStep>, saveCancellation: CancellationTokenSource): Promise<void> {\n\t\treturn this.saveSequentializer.run(versionId, (async () => {\n\n\t\t\t// A save participant can still change the working copy now\n\t\t\t// and since we are so close to saving we do not want to trigger\n\t\t\t// another auto save or similar, so we block this\n\t\t\t// In addition we update our version right after in case it changed\n\t\t\t// because of a working copy change\n\t\t\t// Save participants can also be skipped through API.\n\t\t\tif (this.isResolved() && !options.skipSaveParticipants && this.workingCopyFileService.hasSaveParticipants) {\n\t\t\t\ttry {\n\n\t\t\t\t\t// Measure the time it took from the last undo/redo operation to this save. If this\n\t\t\t\t\t// time is below `UNDO_REDO_SAVE_PARTICIPANTS_THROTTLE_THRESHOLD`, we make sure to\n\t\t\t\t\t// delay the save participant for the remaining time if the reason is auto save.\n\t\t\t\t\t//\n\t\t\t\t\t// This fixes the following issue:\n\t\t\t\t\t// - the user has configured auto save with delay of 100ms or shorter\n\t\t\t\t\t// - the user has a save participant enabled that modifies the file on each save\n\t\t\t\t\t// - the user types into the file and the file gets saved\n\t\t\t\t\t// - the user triggers undo operation\n\t\t\t\t\t// - this will undo the save participant change but trigger the save participant right after\n\t\t\t\t\t// - the user has no chance to undo over the save participant\n\t\t\t\t\t//\n\t\t\t\t\t// Reported as: https://github.com/microsoft/vscode/issues/102542\n\t\t\t\t\tif (options.reason === SaveReason.AUTO && typeof this.lastContentChangeFromUndoRedo === 'number') {\n\t\t\t\t\t\tconst timeFromUndoRedoToSave = Date.now() - this.lastContentChangeFromUndoRedo;\n\t\t\t\t\t\tif (timeFromUndoRedoToSave < StoredFileWorkingCopy.UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD) {\n\t\t\t\t\t\t\tawait timeout(StoredFileWorkingCopy.UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD - timeFromUndoRedoToSave);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Run save participants unless save was cancelled meanwhile\n\t\t\t\t\tif (!saveCancellation.token.isCancellationRequested) {\n\t\t\t\t\t\tthis.ignoreSaveFromSaveParticipants = true;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.workingCopyFileService.runSaveParticipants(this, { reason: options.reason ?? SaveReason.EXPLICIT, savedFrom: options.from }, progress, saveCancellation.token);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tif (isCancellationError(err) && !saveCancellation.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\t// participant wants to cancel this operation\n\t\t\t\t\t\t\t\tsaveCancellation.cancel();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tthis.ignoreSaveFromSaveParticipants = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(`[stored file working copy] runSaveParticipants(${versionId}) - resulted in an error: ${error.toString()}`, this.resource.toString(), this.typeId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// It is possible that a subsequent save is cancelling this\n\t\t\t// running save. As such we return early when we detect that.\n\t\t\tif (saveCancellation.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// We have to protect against being disposed at this point. It could be that the save() operation\n\t\t\t// was triggerd followed by a dispose() operation right after without waiting. Typically we cannot\n\t\t\t// be disposed if we are dirty, but if we are not dirty, save() and dispose() can still be triggered\n\t\t\t// one after the other without waiting for the save() to complete. If we are disposed(), we risk\n\t\t\t// saving contents to disk that are stale (see https://github.com/microsoft/vscode/issues/50942).\n\t\t\t// To fix this issue, we will not store the contents to disk when we got disposed.\n\t\t\tif (this.isDisposed()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// We require a resolved working copy from this point on, since we are about to write data to disk.\n\t\t\tif (!this.isResolved()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// update versionId with its new value (if pre-save changes happened)\n\t\t\tversionId = this.versionId;\n\n\t\t\t// Clear error flag since we are trying to save again\n\t\t\tthis.inErrorMode = false;\n\n\t\t\t// Save to Disk. We mark the save operation as currently running with\n\t\t\t// the latest versionId because it might have changed from a save\n\t\t\t// participant triggering\n\t\t\tprogress.report({ message: localize('saveTextFile', \"Writing into file...\") });\n\t\t\tthis.trace(`doSave(${versionId}) - before write()`);\n\t\t\tconst lastResolvedFileStat = assertReturnsDefined(this.lastResolvedFileStat);\n\t\t\tconst resolvedFileWorkingCopy = this;\n\t\t\treturn this.saveSequentializer.run(versionId, (async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst writeFileOptions: IWriteFileOptions = {\n\t\t\t\t\t\tmtime: lastResolvedFileStat.mtime,\n\t\t\t\t\t\tetag: (options.ignoreModifiedSince || !this.filesConfigurationService.preventSaveConflicts(lastResolvedFileStat.resource)) ? ETAG_DISABLED : lastResolvedFileStat.etag,\n\t\t\t\t\t\tunlock: options.writeUnlock\n\t\t\t\t\t};\n\n\t\t\t\t\tlet stat: IFileStatWithMetadata;\n\n\t\t\t\t\t// Delegate to working copy model save method if any\n\t\t\t\t\tif (typeof resolvedFileWorkingCopy.model.save === 'function') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tstat = await resolvedFileWorkingCopy.model.save(writeFileOptions, saveCancellation.token);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tif (saveCancellation.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn undefined; // save was cancelled\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise ask for a snapshot and save via file services\n\t\t\t\t\telse {\n\n\t\t\t\t\t\t// Snapshot working copy model contents\n\t\t\t\t\t\tconst snapshot = await raceCancellation(resolvedFileWorkingCopy.model.snapshot(SnapshotContext.Save, saveCancellation.token), saveCancellation.token);\n\n\t\t\t\t\t\t// It is possible that a subsequent save is cancelling this\n\t\t\t\t\t\t// running save. As such we return early when we detect that\n\t\t\t\t\t\t// However, we do not pass the token into the file service\n\t\t\t\t\t\t// because that is an atomic operation currently without\n\t\t\t\t\t\t// cancellation support, so we dispose the cancellation if\n\t\t\t\t\t\t// it was not cancelled yet.\n\t\t\t\t\t\tif (saveCancellation.token.isCancellationRequested) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsaveCancellation.dispose();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Write them to disk\n\t\t\t\t\t\tif (options?.writeElevated && this.elevatedFileService.isSupported(lastResolvedFileStat.resource)) {\n\t\t\t\t\t\t\tstat = await this.elevatedFileService.writeFileElevated(lastResolvedFileStat.resource, assertReturnsDefined(snapshot), writeFileOptions);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstat = await this.fileService.writeFile(lastResolvedFileStat.resource, assertReturnsDefined(snapshot), writeFileOptions);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.handleSaveSuccess(stat, versionId, options);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.handleSaveError(error, versionId, options);\n\t\t\t\t}\n\t\t\t})(), () => saveCancellation.cancel());\n\t\t})(), () => saveCancellation.cancel());\n\t}\n\n\tprivate handleSaveSuccess(stat: IFileStatWithMetadata, versionId: number, options: IStoredFileWorkingCopySaveAsOptions): void {\n\n\t\t// Updated resolved stat with updated stat\n\t\tthis.updateLastResolvedFileStat(stat);\n\n\t\t// Update dirty state unless working copy has changed meanwhile\n\t\tif (versionId === this.versionId) {\n\t\t\tthis.trace(`handleSaveSuccess(${versionId}) - setting dirty to false because versionId did not change`);\n\t\t\tthis.setDirty(false);\n\t\t} else {\n\t\t\tthis.trace(`handleSaveSuccess(${versionId}) - not setting dirty to false because versionId did change meanwhile`);\n\t\t}\n\n\t\t// Update orphan state given save was successful\n\t\tthis.setOrphaned(false);\n\n\t\t// Emit Save Event\n\t\tthis._onDidSave.fire({ reason: options.reason, stat, source: options.source });\n\t}\n\n\tprivate handleSaveError(error: Error, versionId: number, options: IStoredFileWorkingCopySaveAsOptions): void {\n\t\t(options.ignoreErrorHandler ? this.logService.trace : this.logService.error).apply(this.logService, [`[stored file working copy] handleSaveError(${versionId}) - exit - resulted in a save error: ${error.toString()}`, this.resource.toString(), this.typeId]);\n\n\t\t// Return early if the save() call was made asking to\n\t\t// handle the save error itself.\n\t\tif (options.ignoreErrorHandler) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// In any case of an error, we mark the working copy as dirty to prevent data loss\n\t\t// It could be possible that the write corrupted the file on disk (e.g. when\n\t\t// an error happened after truncating the file) and as such we want to preserve\n\t\t// the working copy contents to prevent data loss.\n\t\tthis.setDirty(true);\n\n\t\t// Flag as error state\n\t\tthis.inErrorMode = true;\n\n\t\t// Look out for a save conflict\n\t\tif ((error as FileOperationError).fileOperationResult === FileOperationResult.FILE_MODIFIED_SINCE) {\n\t\t\tthis.inConflictMode = true;\n\t\t}\n\n\t\t// Show save error to user for handling\n\t\tthis.doHandleSaveError(error, options);\n\n\t\t// Emit as event\n\t\tthis._onDidSaveError.fire();\n\t}\n\n\tprivate doHandleSaveError(error: Error, options: IStoredFileWorkingCopySaveAsOptions): void {\n\t\tconst fileOperationError = error as FileOperationError;\n\t\tconst primaryActions: IAction[] = [];\n\n\t\tlet message: string;\n\n\t\t// Dirty write prevention\n\t\tif (fileOperationError.fileOperationResult === FileOperationResult.FILE_MODIFIED_SINCE) {\n\t\t\tmessage = localize('staleSaveError', \"Failed to save '{0}': The content of the file is newer. Do you want to overwrite the file with your changes?\", this.name);\n\n\t\t\tprimaryActions.push(toAction({ id: 'fileWorkingCopy.overwrite', label: localize('overwrite', \"Overwrite\"), run: () => this.save({ ...options, ignoreModifiedSince: true, reason: SaveReason.EXPLICIT }) }));\n\t\t\tprimaryActions.push(toAction({ id: 'fileWorkingCopy.revert', label: localize('revert', \"Revert\"), run: () => this.revert() }));\n\t\t}\n\n\t\t// Any other save error\n\t\telse {\n\t\t\tconst isWriteLocked = fileOperationError.fileOperationResult === FileOperationResult.FILE_WRITE_LOCKED;\n\t\t\tconst triedToUnlock = isWriteLocked && (fileOperationError.options as IWriteFileOptions | undefined)?.unlock;\n\t\t\tconst isPermissionDenied = fileOperationError.fileOperationResult === FileOperationResult.FILE_PERMISSION_DENIED;\n\t\t\tconst canSaveElevated = this.elevatedFileService.isSupported(this.resource);\n\n\t\t\t// Error with Actions\n\t\t\tif (isErrorWithActions(error)) {\n\t\t\t\tprimaryActions.push(...error.actions);\n\t\t\t}\n\n\t\t\t// Save Elevated\n\t\t\tif (canSaveElevated && (isPermissionDenied || triedToUnlock)) {\n\t\t\t\tprimaryActions.push(toAction({\n\t\t\t\t\tid: 'fileWorkingCopy.saveElevated',\n\t\t\t\t\tlabel: triedToUnlock ?\n\t\t\t\t\t\tisWindows ? localize('overwriteElevated', \"Overwrite as Admin...\") : localize('overwriteElevatedSudo', \"Overwrite as Sudo...\") :\n\t\t\t\t\t\tisWindows ? localize('saveElevated', \"Retry as Admin...\") : localize('saveElevatedSudo', \"Retry as Sudo...\"),\n\t\t\t\t\trun: () => {\n\t\t\t\t\t\tthis.save({ ...options, writeElevated: true, writeUnlock: triedToUnlock, reason: SaveReason.EXPLICIT });\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// Unlock\n\t\t\telse if (isWriteLocked) {\n\t\t\t\tprimaryActions.push(toAction({ id: 'fileWorkingCopy.unlock', label: localize('overwrite', \"Overwrite\"), run: () => this.save({ ...options, writeUnlock: true, reason: SaveReason.EXPLICIT }) }));\n\t\t\t}\n\n\t\t\t// Retry\n\t\t\telse {\n\t\t\t\tprimaryActions.push(toAction({ id: 'fileWorkingCopy.retry', label: localize('retry', \"Retry\"), run: () => this.save({ ...options, reason: SaveReason.EXPLICIT }) }));\n\t\t\t}\n\n\t\t\t// Save As\n\t\t\tprimaryActions.push(toAction({\n\t\t\t\tid: 'fileWorkingCopy.saveAs',\n\t\t\t\tlabel: localize('saveAs', \"Save As...\"),\n\t\t\t\trun: async () => {\n\t\t\t\t\tconst editor = this.workingCopyEditorService.findEditor(this);\n\t\t\t\t\tif (editor) {\n\t\t\t\t\t\tconst result = await this.editorService.save(editor, { saveAs: true, reason: SaveReason.EXPLICIT });\n\t\t\t\t\t\tif (!result.success) {\n\t\t\t\t\t\t\tthis.doHandleSaveError(error, options); // show error again given the operation failed\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\t// Revert\n\t\t\tprimaryActions.push(toAction({ id: 'fileWorkingCopy.revert', label: localize('revert', \"Revert\"), run: () => this.revert() }));\n\n\t\t\t// Message\n\t\t\tif (isWriteLocked) {\n\t\t\t\tif (triedToUnlock && canSaveElevated) {\n\t\t\t\t\tmessage = isWindows ?\n\t\t\t\t\t\tlocalize('readonlySaveErrorAdmin', \"Failed to save '{0}': File is read-only. Select 'Overwrite as Admin' to retry as administrator.\", this.name) :\n\t\t\t\t\t\tlocalize('readonlySaveErrorSudo', \"Failed to save '{0}': File is read-only. Select 'Overwrite as Sudo' to retry as superuser.\", this.name);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = localize('readonlySaveError', \"Failed to save '{0}': File is read-only. Select 'Overwrite' to attempt to make it writeable.\", this.name);\n\t\t\t\t}\n\t\t\t} else if (canSaveElevated && isPermissionDenied) {\n\t\t\t\tmessage = isWindows ?\n\t\t\t\t\tlocalize('permissionDeniedSaveError', \"Failed to save '{0}': Insufficient permissions. Select 'Retry as Admin' to retry as administrator.\", this.name) :\n\t\t\t\t\tlocalize('permissionDeniedSaveErrorSudo', \"Failed to save '{0}': Insufficient permissions. Select 'Retry as Sudo' to retry as superuser.\", this.name);\n\t\t\t} else {\n\t\t\t\tmessage = localize({ key: 'genericSaveError', comment: ['{0} is the resource that failed to save and {1} the error message'] }, \"Failed to save '{0}': {1}\", this.name, toErrorMessage(error, false));\n\t\t\t}\n\t\t}\n\n\t\t// Show to the user as notification\n\t\tconst handle = this.notificationService.notify({ id: `${hash(this.resource.toString())}`, severity: Severity.Error, message, actions: { primary: primaryActions } });\n\n\t\t// Remove automatically when we get saved/reverted\n\t\tconst listener = this._register(Event.once(Event.any(this.onDidSave, this.onDidRevert))(() => handle.close()));\n\t\tthis._register(Event.once(handle.onDidClose)(() => listener.dispose()));\n\t}\n\n\tprivate updateLastResolvedFileStat(newFileStat: IFileStatWithMetadata): void {\n\t\tconst oldReadonly = this.isReadonly();\n\n\t\t// First resolve - just take\n\t\tif (!this.lastResolvedFileStat) {\n\t\t\tthis.lastResolvedFileStat = newFileStat;\n\t\t}\n\n\t\t// Subsequent resolve - make sure that we only assign it if the mtime\n\t\t// is equal or has advanced.\n\t\t// This prevents race conditions from resolving and saving. If a save\n\t\t// comes in late after a revert was called, the mtime could be out of\n\t\t// sync.\n\t\telse if (this.lastResolvedFileStat.mtime <= newFileStat.mtime) {\n\t\t\tthis.lastResolvedFileStat = newFileStat;\n\t\t}\n\n\t\t// In all other cases update only the readonly and locked flags\n\t\telse {\n\t\t\tthis.lastResolvedFileStat = { ...this.lastResolvedFileStat, readonly: newFileStat.readonly, locked: newFileStat.locked };\n\t\t}\n\n\t\t// Signal that the readonly state changed\n\t\tif (this.isReadonly() !== oldReadonly) {\n\t\t\tthis._onDidChangeReadonly.fire();\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Revert\n\n\tasync revert(options?: IRevertOptions): Promise<void> {\n\t\tif (!this.isResolved() || (!this.dirty && !options?.force)) {\n\t\t\treturn; // ignore if not resolved or not dirty and not enforced\n\t\t}\n\n\t\tthis.trace('revert()');\n\n\t\t// Unset flags\n\t\tconst wasDirty = this.dirty;\n\t\tconst undoSetDirty = this.doSetDirty(false);\n\n\t\t// Force read from disk unless reverting soft\n\t\tconst softUndo = options?.soft;\n\t\tif (!softUndo) {\n\t\t\ttry {\n\t\t\t\tawait this.forceResolveFromFile();\n\t\t\t} catch (error) {\n\n\t\t\t\t// FileNotFound means the file got deleted meanwhile, so ignore it\n\t\t\t\tif ((error as FileOperationError).fileOperationResult !== FileOperationResult.FILE_NOT_FOUND) {\n\n\t\t\t\t\t// Set flags back to previous values, we are still dirty if revert failed\n\t\t\t\t\tundoSetDirty();\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Emit file change event\n\t\tthis._onDidRevert.fire();\n\n\t\t// Emit dirty change event\n\t\tif (wasDirty) {\n\t\t\tthis._onDidChangeDirty.fire();\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region State\n\n\tprivate inConflictMode = false;\n\tprivate inErrorMode = false;\n\n\thasState(state: StoredFileWorkingCopyState): boolean {\n\t\tswitch (state) {\n\t\t\tcase StoredFileWorkingCopyState.CONFLICT:\n\t\t\t\treturn this.inConflictMode;\n\t\t\tcase StoredFileWorkingCopyState.DIRTY:\n\t\t\t\treturn this.dirty;\n\t\t\tcase StoredFileWorkingCopyState.ERROR:\n\t\t\t\treturn this.inErrorMode;\n\t\t\tcase StoredFileWorkingCopyState.ORPHAN:\n\t\t\t\treturn this.isOrphaned();\n\t\t\tcase StoredFileWorkingCopyState.PENDING_SAVE:\n\t\t\t\treturn this.saveSequentializer.isRunning();\n\t\t\tcase StoredFileWorkingCopyState.SAVED:\n\t\t\t\treturn !this.dirty;\n\t\t}\n\t}\n\n\tasync joinState(state: StoredFileWorkingCopyState.PENDING_SAVE): Promise<void> {\n\t\treturn this.saveSequentializer.running;\n\t}\n\n\t//#endregion\n\n\t//#region Utilities\n\n\tisReadonly(): boolean | IMarkdownString {\n\t\treturn this.filesConfigurationService.isReadonly(this.resource, this.lastResolvedFileStat);\n\t}\n\n\tprivate trace(msg: string): void {\n\t\tthis.logService.trace(`[stored file working copy] ${msg}`, this.resource.toString(), this.typeId);\n\t}\n\n\t//#endregion\n\n\t//#region Dispose\n\n\toverride dispose(): void {\n\t\tthis.trace('dispose()');\n\n\t\t// State\n\t\tthis.inConflictMode = false;\n\t\tthis.inErrorMode = false;\n\n\t\t// Free up model for GC\n\t\tthis._model = undefined;\n\n\t\tsuper.dispose();\n\t}\n\n\t//#endregion\n}\n"]}