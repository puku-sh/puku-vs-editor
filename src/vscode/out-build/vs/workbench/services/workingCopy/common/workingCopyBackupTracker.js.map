{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/workingCopy/common/workingCopyBackupTracker.ts","vs/workbench/services/workingCopy/common/workingCopyBackupTracker.ts"],"names":[],"mappings":"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","file":"workingCopyBackupTracker.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWorkingCopyBackupService } from './workingCopyBackup.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { IWorkingCopyService } from './workingCopyService.js';\nimport { IWorkingCopy, IWorkingCopyIdentifier, WorkingCopyCapabilities } from './workingCopy.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { ShutdownReason, ILifecycleService, LifecyclePhase, InternalBeforeShutdownEvent } from '../../lifecycle/common/lifecycle.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { IFilesConfigurationService } from '../../filesConfiguration/common/filesConfigurationService.js';\nimport { IWorkingCopyEditorHandler, IWorkingCopyEditorService } from './workingCopyEditorService.js';\nimport { Promises } from '../../../../base/common/async.js';\nimport { IEditorService } from '../../editor/common/editorService.js';\nimport { EditorsOrder } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorGroupsService } from '../../editor/common/editorGroupsService.js';\n\n/**\n * The working copy backup tracker deals with:\n * - restoring backups that exist\n * - creating backups for modified working copies\n * - deleting backups for saved working copies\n * - handling backups on shutdown\n */\nexport abstract class WorkingCopyBackupTracker extends Disposable {\n\n\tconstructor(\n\t\tprotected readonly workingCopyBackupService: IWorkingCopyBackupService,\n\t\tprotected readonly workingCopyService: IWorkingCopyService,\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly lifecycleService: ILifecycleService,\n\t\tprotected readonly filesConfigurationService: IFilesConfigurationService,\n\t\tprivate readonly workingCopyEditorService: IWorkingCopyEditorService,\n\t\tprotected readonly editorService: IEditorService,\n\t\tprivate readonly editorGroupService: IEditorGroupsService\n\t) {\n\t\tsuper();\n\n\t\tthis.whenReady = this.resolveBackupsToRestore();\n\n\t\t// Fill in initial modified working copies\n\t\tfor (const workingCopy of this.workingCopyService.modifiedWorkingCopies) {\n\t\t\tthis.onDidRegister(workingCopy);\n\t\t}\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Working Copy events\n\t\tthis._register(this.workingCopyService.onDidRegister(workingCopy => this.onDidRegister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidUnregister(workingCopy => this.onDidUnregister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeDirty(workingCopy => this.onDidChangeDirty(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeContent(workingCopy => this.onDidChangeContent(workingCopy)));\n\n\t\t// Lifecycle\n\t\tthis._register(this.lifecycleService.onBeforeShutdown(event => (event as InternalBeforeShutdownEvent).finalVeto(() => this.onFinalBeforeShutdown(event.reason), 'veto.backups')));\n\t\tthis._register(this.lifecycleService.onWillShutdown(() => this.onWillShutdown()));\n\n\t\t// Once a handler registers, restore backups\n\t\tthis._register(this.workingCopyEditorService.onDidRegisterHandler(handler => this.restoreBackups(handler)));\n\t}\n\n\tprotected abstract onFinalBeforeShutdown(reason: ShutdownReason): boolean | Promise<boolean>;\n\n\tprivate onWillShutdown(): void {\n\n\t\t// Here we know that we will shutdown. Any backup operation that is\n\t\t// already scheduled or being scheduled from this moment on runs\n\t\t// at the risk of corrupting a backup because the backup operation\n\t\t// might terminate at any given time now. As such, we need to disable\n\t\t// this tracker from performing more backups by cancelling pending\n\t\t// operations and suspending the tracker without resuming.\n\n\t\tthis.cancelBackupOperations();\n\t\tthis.suspendBackupOperations();\n\t}\n\n\n\t//#region Backup Creator\n\n\t// Delay creation of backups when content changes to avoid too much\n\t// load on the backup service when the user is typing into the editor\n\t// Since we always schedule a backup, even when auto save is on, we\n\t// have different scheduling delays based on auto save configuration.\n\t// With 'delayed' we avoid a (not critical but also not really wanted)\n\t// race between saving (after 1s per default) and making a backup of\n\t// the working copy.\n\tprivate static readonly DEFAULT_BACKUP_SCHEDULE_DELAYS = {\n\t\t['default']: 1000,\n\t\t['delayed']: 2000\n\t};\n\n\t// A map from working copy to a version ID we compute on each content\n\t// change. This version ID allows to e.g. ask if a backup for a specific\n\t// content has been made before closing.\n\tprivate readonly mapWorkingCopyToContentVersion = new Map<IWorkingCopy, number>();\n\n\t// A map of scheduled pending backup operations for working copies\n\t// Given https://github.com/microsoft/vscode/issues/158038, we explicitly\n\t// do not store `IWorkingCopy` but the identifier in the map, since it\n\t// looks like GC is not running for the working copy otherwise.\n\tprotected readonly pendingBackupOperations = new Map<IWorkingCopyIdentifier, { disposable: IDisposable; cancel: () => void }>();\n\n\tprivate suspended = false;\n\n\tprivate onDidRegister(workingCopy: IWorkingCopy): void {\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring register event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\tif (workingCopy.isModified()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidUnregister(workingCopy: IWorkingCopy): void {\n\n\t\t// Remove from content version map\n\t\tthis.mapWorkingCopyToContentVersion.delete(workingCopy);\n\n\t\t// Check suspended\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring unregister event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\t// Discard backup\n\t\tthis.discardBackup(workingCopy);\n\t}\n\n\tprivate onDidChangeDirty(workingCopy: IWorkingCopy): void {\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring dirty change event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t} else {\n\t\t\tthis.discardBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidChangeContent(workingCopy: IWorkingCopy): void {\n\n\t\t// Increment content version ID\n\t\tconst contentVersionId = this.getContentVersion(workingCopy);\n\t\tthis.mapWorkingCopyToContentVersion.set(workingCopy, contentVersionId + 1);\n\n\t\t// Check suspended\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring content change event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\t// Schedule backup for modified working copies\n\t\tif (workingCopy.isModified()) {\n\t\t\t// this listener will make sure that the backup is\n\t\t\t// pushed out for as long as the user is still changing\n\t\t\t// the content of the working copy.\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate scheduleBackup(workingCopy: IWorkingCopy): void {\n\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackupOperation(workingCopy);\n\n\t\tthis.logService.trace(`[backup tracker] scheduling backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t// Schedule new backup\n\t\tconst workingCopyIdentifier = { resource: workingCopy.resource, typeId: workingCopy.typeId };\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst handle = setTimeout(async () => {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Backup if modified\n\t\t\tif (workingCopy.isModified()) {\n\t\t\t\tthis.logService.trace(`[backup tracker] creating backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst backup = await workingCopy.backup(cts.token);\n\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (workingCopy.isModified()) {\n\t\t\t\t\t\tthis.logService.trace(`[backup tracker] storing backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\t\t\tawait this.workingCopyBackupService.backup(workingCopy, backup.content, this.getContentVersion(workingCopy), backup.meta, cts.token);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear disposable unless we got canceled which would\n\t\t\t// indicate another operation has started meanwhile\n\t\t\tif (!cts.token.isCancellationRequested) {\n\t\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier);\n\t\t\t}\n\t\t}, this.getBackupScheduleDelay(workingCopy));\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.pendingBackupOperations.set(workingCopyIdentifier, {\n\t\t\tcancel: () => {\n\t\t\t\tthis.logService.trace(`[backup tracker] clearing pending backup creation`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\tcts.cancel();\n\t\t\t},\n\t\t\tdisposable: toDisposable(() => {\n\t\t\t\tcts.dispose();\n\t\t\t\tclearTimeout(handle);\n\t\t\t})\n\t\t});\n\t}\n\n\tprotected getBackupScheduleDelay(workingCopy: IWorkingCopy): number {\n\t\tif (typeof workingCopy.backupDelay === 'number') {\n\t\t\treturn workingCopy.backupDelay; // respect working copy override\n\t\t}\n\n\t\tlet backupScheduleDelay: 'default' | 'delayed';\n\t\tif (workingCopy.capabilities & WorkingCopyCapabilities.Untitled) {\n\t\t\tbackupScheduleDelay = 'default'; // auto-save is never on for untitled working copies\n\t\t} else {\n\t\t\tbackupScheduleDelay = this.filesConfigurationService.hasShortAutoSaveDelay(workingCopy.resource) ? 'delayed' : 'default';\n\t\t}\n\n\t\treturn WorkingCopyBackupTracker.DEFAULT_BACKUP_SCHEDULE_DELAYS[backupScheduleDelay];\n\t}\n\n\tprotected getContentVersion(workingCopy: IWorkingCopy): number {\n\t\treturn this.mapWorkingCopyToContentVersion.get(workingCopy) || 0;\n\t}\n\n\tprivate discardBackup(workingCopy: IWorkingCopy): void {\n\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackupOperation(workingCopy);\n\n\t\t// Schedule backup discard asap\n\t\tconst workingCopyIdentifier = { resource: workingCopy.resource, typeId: workingCopy.typeId };\n\t\tconst cts = new CancellationTokenSource();\n\t\tthis.doDiscardBackup(workingCopyIdentifier, cts);\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.pendingBackupOperations.set(workingCopyIdentifier, {\n\t\t\tcancel: () => {\n\t\t\t\tthis.logService.trace(`[backup tracker] clearing pending backup discard`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\tcts.cancel();\n\t\t\t},\n\t\t\tdisposable: cts\n\t\t});\n\t}\n\n\tprivate async doDiscardBackup(workingCopyIdentifier: IWorkingCopyIdentifier, cts: CancellationTokenSource) {\n\t\tthis.logService.trace(`[backup tracker] discarding backup`, workingCopyIdentifier.resource.toString(), workingCopyIdentifier.typeId);\n\n\t\t// Discard backup\n\t\ttry {\n\t\t\tawait this.workingCopyBackupService.discardBackup(workingCopyIdentifier, cts.token);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\t// Clear disposable unless we got canceled which would\n\t\t// indicate another operation has started meanwhile\n\t\tif (!cts.token.isCancellationRequested) {\n\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier);\n\t\t}\n\t}\n\n\tprivate cancelBackupOperation(workingCopy: IWorkingCopy): void {\n\n\t\t// Given a working copy we want to find the matching\n\t\t// identifier in our pending operations map because\n\t\t// we cannot use the working copy directly, as the\n\t\t// identifier might have different object identity.\n\n\t\tlet workingCopyIdentifier: IWorkingCopyIdentifier | undefined = undefined;\n\t\tfor (const [identifier] of this.pendingBackupOperations) {\n\t\t\tif (identifier.resource.toString() === workingCopy.resource.toString() && identifier.typeId === workingCopy.typeId) {\n\t\t\t\tworkingCopyIdentifier = identifier;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (workingCopyIdentifier) {\n\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier, { cancel: true });\n\t\t}\n\t}\n\n\tprivate doClearPendingBackupOperation(workingCopyIdentifier: IWorkingCopyIdentifier, options?: { cancel: boolean }): void {\n\t\tconst pendingBackupOperation = this.pendingBackupOperations.get(workingCopyIdentifier);\n\t\tif (!pendingBackupOperation) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (options?.cancel) {\n\t\t\tpendingBackupOperation.cancel();\n\t\t}\n\n\t\tpendingBackupOperation.disposable.dispose();\n\n\t\tthis.pendingBackupOperations.delete(workingCopyIdentifier);\n\t}\n\n\tprotected cancelBackupOperations(): void {\n\t\tfor (const [, operation] of this.pendingBackupOperations) {\n\t\t\toperation.cancel();\n\t\t\toperation.disposable.dispose();\n\t\t}\n\n\t\tthis.pendingBackupOperations.clear();\n\t}\n\n\tprotected suspendBackupOperations(): { resume: () => void } {\n\t\tthis.suspended = true;\n\n\t\treturn { resume: () => this.suspended = false };\n\t}\n\n\t//#endregion\n\n\n\t//#region Backup Restorer\n\n\tprotected readonly unrestoredBackups = new Set<IWorkingCopyIdentifier>();\n\tprotected readonly whenReady: Promise<void>;\n\n\tprivate _isReady = false;\n\tprotected get isReady(): boolean { return this._isReady; }\n\n\tprivate async resolveBackupsToRestore(): Promise<void> {\n\n\t\t// Wait for resolving backups until we are restored to reduce startup pressure\n\t\tawait this.lifecycleService.when(LifecyclePhase.Restored);\n\n\t\t// Remember each backup that needs to restore\n\t\tfor (const backup of await this.workingCopyBackupService.getBackups()) {\n\t\t\tthis.unrestoredBackups.add(backup);\n\t\t}\n\n\t\tthis._isReady = true;\n\t}\n\n\tprotected async restoreBackups(handler: IWorkingCopyEditorHandler): Promise<void> {\n\n\t\t// Wait for backups to be resolved\n\t\tawait this.whenReady;\n\n\t\t// Figure out already opened editors for backups vs\n\t\t// non-opened.\n\t\tconst openedEditorsForBackups = new Set<EditorInput>();\n\t\tconst nonOpenedEditorsForBackups = new Set<EditorInput>();\n\n\t\t// Ensure each backup that can be handled has an\n\t\t// associated editor.\n\t\tconst restoredBackups = new Set<IWorkingCopyIdentifier>();\n\t\tfor (const unrestoredBackup of this.unrestoredBackups) {\n\t\t\tconst canHandleUnrestoredBackup = await handler.handles(unrestoredBackup);\n\t\t\tif (!canHandleUnrestoredBackup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Collect already opened editors for backup\n\t\t\tlet hasOpenedEditorForBackup = false;\n\t\t\tfor (const { editor } of this.editorService.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tconst isUnrestoredBackupOpened = handler.isOpen(unrestoredBackup, editor);\n\t\t\t\tif (isUnrestoredBackupOpened) {\n\t\t\t\t\topenedEditorsForBackups.add(editor);\n\t\t\t\t\thasOpenedEditorForBackup = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise, make sure to create at least one editor\n\t\t\t// for the backup to show\n\t\t\tif (!hasOpenedEditorForBackup) {\n\t\t\t\tnonOpenedEditorsForBackups.add(await handler.createEditor(unrestoredBackup));\n\t\t\t}\n\n\t\t\t// Remember as (potentially) restored\n\t\t\trestoredBackups.add(unrestoredBackup);\n\t\t}\n\n\t\t// Ensure editors are opened for each backup without editor\n\t\t// in the background without stealing focus\n\t\tif (nonOpenedEditorsForBackups.size > 0) {\n\t\t\tawait this.editorGroupService.activeGroup.openEditors([...nonOpenedEditorsForBackups].map(nonOpenedEditorForBackup => ({\n\t\t\t\teditor: nonOpenedEditorForBackup,\n\t\t\t\toptions: {\n\t\t\t\t\tpinned: true,\n\t\t\t\t\tpreserveFocus: true,\n\t\t\t\t\tinactive: true\n\t\t\t\t}\n\t\t\t})));\n\n\t\t\tfor (const nonOpenedEditorForBackup of nonOpenedEditorsForBackups) {\n\t\t\t\topenedEditorsForBackups.add(nonOpenedEditorForBackup);\n\t\t\t}\n\t\t}\n\n\t\t// Then, resolve each opened editor to make sure the working copy\n\t\t// is loaded and the modified editor appears properly.\n\t\t// We only do that for editors that are not active in a group\n\t\t// already to prevent calling `resolve` twice!\n\t\tawait Promises.settled([...openedEditorsForBackups].map(async openedEditorForBackup => {\n\t\t\tif (this.editorService.isVisible(openedEditorForBackup)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn openedEditorForBackup.resolve();\n\t\t}));\n\n\t\t// Finally, remove all handled backups from the list\n\t\tfor (const restoredBackup of restoredBackups) {\n\t\t\tthis.unrestoredBackups.delete(restoredBackup);\n\t\t}\n\t}\n\n\t//#endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWorkingCopyBackupService } from './workingCopyBackup.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { IWorkingCopyService } from './workingCopyService.js';\nimport { IWorkingCopy, IWorkingCopyIdentifier, WorkingCopyCapabilities } from './workingCopy.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { ShutdownReason, ILifecycleService, LifecyclePhase, InternalBeforeShutdownEvent } from '../../lifecycle/common/lifecycle.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { IFilesConfigurationService } from '../../filesConfiguration/common/filesConfigurationService.js';\nimport { IWorkingCopyEditorHandler, IWorkingCopyEditorService } from './workingCopyEditorService.js';\nimport { Promises } from '../../../../base/common/async.js';\nimport { IEditorService } from '../../editor/common/editorService.js';\nimport { EditorsOrder } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorGroupsService } from '../../editor/common/editorGroupsService.js';\n\n/**\n * The working copy backup tracker deals with:\n * - restoring backups that exist\n * - creating backups for modified working copies\n * - deleting backups for saved working copies\n * - handling backups on shutdown\n */\nexport abstract class WorkingCopyBackupTracker extends Disposable {\n\n\tconstructor(\n\t\tprotected readonly workingCopyBackupService: IWorkingCopyBackupService,\n\t\tprotected readonly workingCopyService: IWorkingCopyService,\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly lifecycleService: ILifecycleService,\n\t\tprotected readonly filesConfigurationService: IFilesConfigurationService,\n\t\tprivate readonly workingCopyEditorService: IWorkingCopyEditorService,\n\t\tprotected readonly editorService: IEditorService,\n\t\tprivate readonly editorGroupService: IEditorGroupsService\n\t) {\n\t\tsuper();\n\n\t\tthis.whenReady = this.resolveBackupsToRestore();\n\n\t\t// Fill in initial modified working copies\n\t\tfor (const workingCopy of this.workingCopyService.modifiedWorkingCopies) {\n\t\t\tthis.onDidRegister(workingCopy);\n\t\t}\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Working Copy events\n\t\tthis._register(this.workingCopyService.onDidRegister(workingCopy => this.onDidRegister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidUnregister(workingCopy => this.onDidUnregister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeDirty(workingCopy => this.onDidChangeDirty(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeContent(workingCopy => this.onDidChangeContent(workingCopy)));\n\n\t\t// Lifecycle\n\t\tthis._register(this.lifecycleService.onBeforeShutdown(event => (event as InternalBeforeShutdownEvent).finalVeto(() => this.onFinalBeforeShutdown(event.reason), 'veto.backups')));\n\t\tthis._register(this.lifecycleService.onWillShutdown(() => this.onWillShutdown()));\n\n\t\t// Once a handler registers, restore backups\n\t\tthis._register(this.workingCopyEditorService.onDidRegisterHandler(handler => this.restoreBackups(handler)));\n\t}\n\n\tprotected abstract onFinalBeforeShutdown(reason: ShutdownReason): boolean | Promise<boolean>;\n\n\tprivate onWillShutdown(): void {\n\n\t\t// Here we know that we will shutdown. Any backup operation that is\n\t\t// already scheduled or being scheduled from this moment on runs\n\t\t// at the risk of corrupting a backup because the backup operation\n\t\t// might terminate at any given time now. As such, we need to disable\n\t\t// this tracker from performing more backups by cancelling pending\n\t\t// operations and suspending the tracker without resuming.\n\n\t\tthis.cancelBackupOperations();\n\t\tthis.suspendBackupOperations();\n\t}\n\n\n\t//#region Backup Creator\n\n\t// Delay creation of backups when content changes to avoid too much\n\t// load on the backup service when the user is typing into the editor\n\t// Since we always schedule a backup, even when auto save is on, we\n\t// have different scheduling delays based on auto save configuration.\n\t// With 'delayed' we avoid a (not critical but also not really wanted)\n\t// race between saving (after 1s per default) and making a backup of\n\t// the working copy.\n\tprivate static readonly DEFAULT_BACKUP_SCHEDULE_DELAYS = {\n\t\t['default']: 1000,\n\t\t['delayed']: 2000\n\t};\n\n\t// A map from working copy to a version ID we compute on each content\n\t// change. This version ID allows to e.g. ask if a backup for a specific\n\t// content has been made before closing.\n\tprivate readonly mapWorkingCopyToContentVersion = new Map<IWorkingCopy, number>();\n\n\t// A map of scheduled pending backup operations for working copies\n\t// Given https://github.com/microsoft/vscode/issues/158038, we explicitly\n\t// do not store `IWorkingCopy` but the identifier in the map, since it\n\t// looks like GC is not running for the working copy otherwise.\n\tprotected readonly pendingBackupOperations = new Map<IWorkingCopyIdentifier, { disposable: IDisposable; cancel: () => void }>();\n\n\tprivate suspended = false;\n\n\tprivate onDidRegister(workingCopy: IWorkingCopy): void {\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring register event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\tif (workingCopy.isModified()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidUnregister(workingCopy: IWorkingCopy): void {\n\n\t\t// Remove from content version map\n\t\tthis.mapWorkingCopyToContentVersion.delete(workingCopy);\n\n\t\t// Check suspended\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring unregister event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\t// Discard backup\n\t\tthis.discardBackup(workingCopy);\n\t}\n\n\tprivate onDidChangeDirty(workingCopy: IWorkingCopy): void {\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring dirty change event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t} else {\n\t\t\tthis.discardBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidChangeContent(workingCopy: IWorkingCopy): void {\n\n\t\t// Increment content version ID\n\t\tconst contentVersionId = this.getContentVersion(workingCopy);\n\t\tthis.mapWorkingCopyToContentVersion.set(workingCopy, contentVersionId + 1);\n\n\t\t// Check suspended\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring content change event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\t// Schedule backup for modified working copies\n\t\tif (workingCopy.isModified()) {\n\t\t\t// this listener will make sure that the backup is\n\t\t\t// pushed out for as long as the user is still changing\n\t\t\t// the content of the working copy.\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate scheduleBackup(workingCopy: IWorkingCopy): void {\n\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackupOperation(workingCopy);\n\n\t\tthis.logService.trace(`[backup tracker] scheduling backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t// Schedule new backup\n\t\tconst workingCopyIdentifier = { resource: workingCopy.resource, typeId: workingCopy.typeId };\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst handle = setTimeout(async () => {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Backup if modified\n\t\t\tif (workingCopy.isModified()) {\n\t\t\t\tthis.logService.trace(`[backup tracker] creating backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst backup = await workingCopy.backup(cts.token);\n\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (workingCopy.isModified()) {\n\t\t\t\t\t\tthis.logService.trace(`[backup tracker] storing backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\t\t\tawait this.workingCopyBackupService.backup(workingCopy, backup.content, this.getContentVersion(workingCopy), backup.meta, cts.token);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear disposable unless we got canceled which would\n\t\t\t// indicate another operation has started meanwhile\n\t\t\tif (!cts.token.isCancellationRequested) {\n\t\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier);\n\t\t\t}\n\t\t}, this.getBackupScheduleDelay(workingCopy));\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.pendingBackupOperations.set(workingCopyIdentifier, {\n\t\t\tcancel: () => {\n\t\t\t\tthis.logService.trace(`[backup tracker] clearing pending backup creation`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\tcts.cancel();\n\t\t\t},\n\t\t\tdisposable: toDisposable(() => {\n\t\t\t\tcts.dispose();\n\t\t\t\tclearTimeout(handle);\n\t\t\t})\n\t\t});\n\t}\n\n\tprotected getBackupScheduleDelay(workingCopy: IWorkingCopy): number {\n\t\tif (typeof workingCopy.backupDelay === 'number') {\n\t\t\treturn workingCopy.backupDelay; // respect working copy override\n\t\t}\n\n\t\tlet backupScheduleDelay: 'default' | 'delayed';\n\t\tif (workingCopy.capabilities & WorkingCopyCapabilities.Untitled) {\n\t\t\tbackupScheduleDelay = 'default'; // auto-save is never on for untitled working copies\n\t\t} else {\n\t\t\tbackupScheduleDelay = this.filesConfigurationService.hasShortAutoSaveDelay(workingCopy.resource) ? 'delayed' : 'default';\n\t\t}\n\n\t\treturn WorkingCopyBackupTracker.DEFAULT_BACKUP_SCHEDULE_DELAYS[backupScheduleDelay];\n\t}\n\n\tprotected getContentVersion(workingCopy: IWorkingCopy): number {\n\t\treturn this.mapWorkingCopyToContentVersion.get(workingCopy) || 0;\n\t}\n\n\tprivate discardBackup(workingCopy: IWorkingCopy): void {\n\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackupOperation(workingCopy);\n\n\t\t// Schedule backup discard asap\n\t\tconst workingCopyIdentifier = { resource: workingCopy.resource, typeId: workingCopy.typeId };\n\t\tconst cts = new CancellationTokenSource();\n\t\tthis.doDiscardBackup(workingCopyIdentifier, cts);\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.pendingBackupOperations.set(workingCopyIdentifier, {\n\t\t\tcancel: () => {\n\t\t\t\tthis.logService.trace(`[backup tracker] clearing pending backup discard`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\tcts.cancel();\n\t\t\t},\n\t\t\tdisposable: cts\n\t\t});\n\t}\n\n\tprivate async doDiscardBackup(workingCopyIdentifier: IWorkingCopyIdentifier, cts: CancellationTokenSource) {\n\t\tthis.logService.trace(`[backup tracker] discarding backup`, workingCopyIdentifier.resource.toString(), workingCopyIdentifier.typeId);\n\n\t\t// Discard backup\n\t\ttry {\n\t\t\tawait this.workingCopyBackupService.discardBackup(workingCopyIdentifier, cts.token);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\t// Clear disposable unless we got canceled which would\n\t\t// indicate another operation has started meanwhile\n\t\tif (!cts.token.isCancellationRequested) {\n\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier);\n\t\t}\n\t}\n\n\tprivate cancelBackupOperation(workingCopy: IWorkingCopy): void {\n\n\t\t// Given a working copy we want to find the matching\n\t\t// identifier in our pending operations map because\n\t\t// we cannot use the working copy directly, as the\n\t\t// identifier might have different object identity.\n\n\t\tlet workingCopyIdentifier: IWorkingCopyIdentifier | undefined = undefined;\n\t\tfor (const [identifier] of this.pendingBackupOperations) {\n\t\t\tif (identifier.resource.toString() === workingCopy.resource.toString() && identifier.typeId === workingCopy.typeId) {\n\t\t\t\tworkingCopyIdentifier = identifier;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (workingCopyIdentifier) {\n\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier, { cancel: true });\n\t\t}\n\t}\n\n\tprivate doClearPendingBackupOperation(workingCopyIdentifier: IWorkingCopyIdentifier, options?: { cancel: boolean }): void {\n\t\tconst pendingBackupOperation = this.pendingBackupOperations.get(workingCopyIdentifier);\n\t\tif (!pendingBackupOperation) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (options?.cancel) {\n\t\t\tpendingBackupOperation.cancel();\n\t\t}\n\n\t\tpendingBackupOperation.disposable.dispose();\n\n\t\tthis.pendingBackupOperations.delete(workingCopyIdentifier);\n\t}\n\n\tprotected cancelBackupOperations(): void {\n\t\tfor (const [, operation] of this.pendingBackupOperations) {\n\t\t\toperation.cancel();\n\t\t\toperation.disposable.dispose();\n\t\t}\n\n\t\tthis.pendingBackupOperations.clear();\n\t}\n\n\tprotected suspendBackupOperations(): { resume: () => void } {\n\t\tthis.suspended = true;\n\n\t\treturn { resume: () => this.suspended = false };\n\t}\n\n\t//#endregion\n\n\n\t//#region Backup Restorer\n\n\tprotected readonly unrestoredBackups = new Set<IWorkingCopyIdentifier>();\n\tprotected readonly whenReady: Promise<void>;\n\n\tprivate _isReady = false;\n\tprotected get isReady(): boolean { return this._isReady; }\n\n\tprivate async resolveBackupsToRestore(): Promise<void> {\n\n\t\t// Wait for resolving backups until we are restored to reduce startup pressure\n\t\tawait this.lifecycleService.when(LifecyclePhase.Restored);\n\n\t\t// Remember each backup that needs to restore\n\t\tfor (const backup of await this.workingCopyBackupService.getBackups()) {\n\t\t\tthis.unrestoredBackups.add(backup);\n\t\t}\n\n\t\tthis._isReady = true;\n\t}\n\n\tprotected async restoreBackups(handler: IWorkingCopyEditorHandler): Promise<void> {\n\n\t\t// Wait for backups to be resolved\n\t\tawait this.whenReady;\n\n\t\t// Figure out already opened editors for backups vs\n\t\t// non-opened.\n\t\tconst openedEditorsForBackups = new Set<EditorInput>();\n\t\tconst nonOpenedEditorsForBackups = new Set<EditorInput>();\n\n\t\t// Ensure each backup that can be handled has an\n\t\t// associated editor.\n\t\tconst restoredBackups = new Set<IWorkingCopyIdentifier>();\n\t\tfor (const unrestoredBackup of this.unrestoredBackups) {\n\t\t\tconst canHandleUnrestoredBackup = await handler.handles(unrestoredBackup);\n\t\t\tif (!canHandleUnrestoredBackup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Collect already opened editors for backup\n\t\t\tlet hasOpenedEditorForBackup = false;\n\t\t\tfor (const { editor } of this.editorService.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tconst isUnrestoredBackupOpened = handler.isOpen(unrestoredBackup, editor);\n\t\t\t\tif (isUnrestoredBackupOpened) {\n\t\t\t\t\topenedEditorsForBackups.add(editor);\n\t\t\t\t\thasOpenedEditorForBackup = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise, make sure to create at least one editor\n\t\t\t// for the backup to show\n\t\t\tif (!hasOpenedEditorForBackup) {\n\t\t\t\tnonOpenedEditorsForBackups.add(await handler.createEditor(unrestoredBackup));\n\t\t\t}\n\n\t\t\t// Remember as (potentially) restored\n\t\t\trestoredBackups.add(unrestoredBackup);\n\t\t}\n\n\t\t// Ensure editors are opened for each backup without editor\n\t\t// in the background without stealing focus\n\t\tif (nonOpenedEditorsForBackups.size > 0) {\n\t\t\tawait this.editorGroupService.activeGroup.openEditors([...nonOpenedEditorsForBackups].map(nonOpenedEditorForBackup => ({\n\t\t\t\teditor: nonOpenedEditorForBackup,\n\t\t\t\toptions: {\n\t\t\t\t\tpinned: true,\n\t\t\t\t\tpreserveFocus: true,\n\t\t\t\t\tinactive: true\n\t\t\t\t}\n\t\t\t})));\n\n\t\t\tfor (const nonOpenedEditorForBackup of nonOpenedEditorsForBackups) {\n\t\t\t\topenedEditorsForBackups.add(nonOpenedEditorForBackup);\n\t\t\t}\n\t\t}\n\n\t\t// Then, resolve each opened editor to make sure the working copy\n\t\t// is loaded and the modified editor appears properly.\n\t\t// We only do that for editors that are not active in a group\n\t\t// already to prevent calling `resolve` twice!\n\t\tawait Promises.settled([...openedEditorsForBackups].map(async openedEditorForBackup => {\n\t\t\tif (this.editorService.isVisible(openedEditorForBackup)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn openedEditorForBackup.resolve();\n\t\t}));\n\n\t\t// Finally, remove all handled backups from the list\n\t\tfor (const restoredBackup of restoredBackups) {\n\t\t\tthis.unrestoredBackups.delete(restoredBackup);\n\t\t}\n\t}\n\n\t//#endregion\n}\n"]}