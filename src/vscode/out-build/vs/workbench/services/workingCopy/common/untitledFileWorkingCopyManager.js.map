{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/workingCopy/common/untitledFileWorkingCopyManager.ts","vs/workbench/services/workingCopy/common/untitledFileWorkingCopyManager.ts"],"names":[],"mappings":"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","file":"untitledFileWorkingCopyManager.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, dispose, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IUntitledFileWorkingCopy, IUntitledFileWorkingCopyInitialContents, IUntitledFileWorkingCopyModel, IUntitledFileWorkingCopyModelFactory, IUntitledFileWorkingCopySaveDelegate, UntitledFileWorkingCopy } from './untitledFileWorkingCopy.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { IWorkingCopyService } from './workingCopyService.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IWorkingCopyBackupService } from './workingCopyBackup.js';\nimport { IFileService } from '../../../../platform/files/common/files.js';\nimport { BaseFileWorkingCopyManager, IBaseFileWorkingCopyManager } from './abstractFileWorkingCopyManager.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\n\nexport interface IUntitledFileWorkingCopySaveEvent {\n\n\t/**\n\t * The source untitled file working copy that was saved. It is disposed at this point.\n\t */\n\treadonly source: URI;\n\n\t/**\n\t * The target file working copy the untitled was saved to. Is never untitled.\n\t */\n\treadonly target: URI;\n}\n\n/**\n * The only one that should be dealing with `IUntitledFileWorkingCopy` and\n * handle all operations that are working copy related, such as save/revert,\n * backup and resolving.\n */\nexport interface IUntitledFileWorkingCopyManager<M extends IUntitledFileWorkingCopyModel> extends IBaseFileWorkingCopyManager<M, IUntitledFileWorkingCopy<M>> {\n\n\t/**\n\t * An event for when an untitled file working copy was saved.\n\t * At the point the event fires, the untitled file working copy is\n\t * disposed.\n\t */\n\treadonly onDidSave: Event<IUntitledFileWorkingCopySaveEvent>;\n\n\t/**\n\t * An event for when a untitled file working copy changed it's dirty state.\n\t */\n\treadonly onDidChangeDirty: Event<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a untitled file working copy is about to be disposed.\n\t */\n\treadonly onWillDispose: Event<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents\n\t * and associated resource. The associated resource will be used when\n\t * saving and will not require to ask the user for a file path.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * Creates a new untitled file working copy with optional initial contents\n\t * with the provided resource or return an existing untitled file working\n\t * copy otherwise.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewOrExistingUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * Internal method: triggers the onDidSave event.\n\t */\n\tnotifyDidSave(source: URI, target: URI): void;\n}\n\nexport interface INewUntitledFileWorkingCopyOptions {\n\n\t/**\n\t * Initial value of the untitled file working copy\n\t * with support to indicate whether this should turn\n\t * the working copy dirty or not.\n\t */\n\tcontents?: IUntitledFileWorkingCopyInitialContents;\n}\n\nexport interface INewUntitledFileWorkingCopyWithAssociatedResourceOptions extends INewUntitledFileWorkingCopyOptions {\n\n\t/**\n\t * Resource components to associate with the untitled file working copy.\n\t * When saving, the associated components will be used and the user\n\t * is not being asked to provide a file path.\n\t *\n\t * Note: currently it is not possible to specify the `scheme` to use. The\n\t * untitled file working copy will saved to the default local or remote resource.\n\t */\n\tassociatedResource: { authority?: string; path?: string; query?: string; fragment?: string };\n}\n\nexport interface INewOrExistingUntitledFileWorkingCopyOptions extends INewUntitledFileWorkingCopyOptions {\n\n\t/**\n\t * A resource to identify the untitled file working copy\n\t * to create or return if already existing.\n\t *\n\t * Note: the resource will not be used unless the scheme is `untitled`.\n\t */\n\tuntitledResource: URI;\n\n\t/**\n\t * A flag that will prevent the working copy from appearing dirty in the UI\n\t * and not show a confirmation dialog when closed with unsaved content.\n\t */\n\tisScratchpad?: boolean;\n}\n\ntype IInternalUntitledFileWorkingCopyOptions = INewUntitledFileWorkingCopyOptions & INewUntitledFileWorkingCopyWithAssociatedResourceOptions & INewOrExistingUntitledFileWorkingCopyOptions;\n\nexport class UntitledFileWorkingCopyManager<M extends IUntitledFileWorkingCopyModel> extends BaseFileWorkingCopyManager<M, IUntitledFileWorkingCopy<M>> implements IUntitledFileWorkingCopyManager<M> {\n\n\t//#region Events\n\n\tprivate readonly _onDidSave = this._register(new Emitter<IUntitledFileWorkingCopySaveEvent>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<IUntitledFileWorkingCopy<M>>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onWillDispose = this._register(new Emitter<IUntitledFileWorkingCopy<M>>());\n\treadonly onWillDispose = this._onWillDispose.event;\n\n\t//#endregion\n\n\tprivate readonly mapResourceToWorkingCopyListeners = new ResourceMap<IDisposable>();\n\n\tconstructor(\n\t\tprivate readonly workingCopyTypeId: string,\n\t\tprivate readonly modelFactory: IUntitledFileWorkingCopyModelFactory<M>,\n\t\tprivate readonly saveDelegate: IUntitledFileWorkingCopySaveDelegate<M>,\n\t\t@IFileService fileService: IFileService,\n\t\t@ILabelService private readonly labelService: ILabelService,\n\t\t@ILogService logService: ILogService,\n\t\t@IWorkingCopyBackupService workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IWorkingCopyService private readonly workingCopyService: IWorkingCopyService\n\t) {\n\t\tsuper(fileService, logService, workingCopyBackupService);\n\t}\n\n\t//#region Resolve\n\n\tresolve(options?: INewUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\tresolve(options?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\tresolve(options?: INewOrExistingUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\tasync resolve(options?: IInternalUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>> {\n\t\tconst workingCopy = this.doCreateOrGet(options);\n\t\tawait workingCopy.resolve();\n\n\t\treturn workingCopy;\n\t}\n\n\tprivate doCreateOrGet(options: IInternalUntitledFileWorkingCopyOptions = Object.create(null)): IUntitledFileWorkingCopy<M> {\n\t\tconst massagedOptions = this.massageOptions(options);\n\n\t\t// Return existing instance if asked for it\n\t\tif (massagedOptions.untitledResource) {\n\t\t\tconst existingWorkingCopy = this.get(massagedOptions.untitledResource);\n\t\t\tif (existingWorkingCopy) {\n\t\t\t\treturn existingWorkingCopy;\n\t\t\t}\n\t\t}\n\n\t\t// Create new instance otherwise\n\t\treturn this.doCreate(massagedOptions);\n\t}\n\n\tprivate massageOptions(options: IInternalUntitledFileWorkingCopyOptions): IInternalUntitledFileWorkingCopyOptions {\n\t\tconst massagedOptions: IInternalUntitledFileWorkingCopyOptions = Object.create(null);\n\n\t\t// Handle associated resource\n\t\tif (options.associatedResource) {\n\t\t\tmassagedOptions.untitledResource = URI.from({\n\t\t\t\tscheme: Schemas.untitled,\n\t\t\t\tauthority: options.associatedResource.authority,\n\t\t\t\tfragment: options.associatedResource.fragment,\n\t\t\t\tpath: options.associatedResource.path,\n\t\t\t\tquery: options.associatedResource.query\n\t\t\t});\n\t\t\tmassagedOptions.associatedResource = options.associatedResource;\n\t\t}\n\n\t\t// Handle untitled resource\n\t\telse {\n\t\t\tif (options.untitledResource?.scheme === Schemas.untitled) {\n\t\t\t\tmassagedOptions.untitledResource = options.untitledResource;\n\t\t\t}\n\t\t\tmassagedOptions.isScratchpad = options.isScratchpad;\n\t\t}\n\n\t\t// Take over initial value\n\t\tmassagedOptions.contents = options.contents;\n\n\t\treturn massagedOptions;\n\t}\n\n\tprivate doCreate(options: IInternalUntitledFileWorkingCopyOptions): IUntitledFileWorkingCopy<M> {\n\n\t\t// Create a new untitled resource if none is provided\n\t\tlet untitledResource = options.untitledResource;\n\t\tif (!untitledResource) {\n\t\t\tlet counter = 1;\n\t\t\tdo {\n\t\t\t\tuntitledResource = URI.from({\n\t\t\t\t\tscheme: Schemas.untitled,\n\t\t\t\t\tpath: options.isScratchpad ? `Scratchpad-${counter}` : `Untitled-${counter}`,\n\t\t\t\t\tquery: this.workingCopyTypeId ?\n\t\t\t\t\t\t`typeId=${this.workingCopyTypeId}` : // distinguish untitled resources among others by encoding the `typeId` as query param\n\t\t\t\t\t\tundefined\t\t\t\t\t\t\t // keep untitled resources for text files as they are (when `typeId === ''`)\n\t\t\t\t});\n\t\t\t\tcounter++;\n\t\t\t} while (this.has(untitledResource));\n\t\t}\n\n\t\t// Create new working copy with provided options\n\t\tconst workingCopy = new UntitledFileWorkingCopy(\n\t\t\tthis.workingCopyTypeId,\n\t\t\tuntitledResource,\n\t\t\tthis.labelService.getUriBasenameLabel(untitledResource),\n\t\t\t!!options.associatedResource,\n\t\t\t!!options.isScratchpad,\n\t\t\toptions.contents,\n\t\t\tthis.modelFactory,\n\t\t\tthis.saveDelegate,\n\t\t\tthis.workingCopyService,\n\t\t\tthis.workingCopyBackupService,\n\t\t\tthis.logService\n\t\t);\n\n\t\t// Register\n\t\tthis.registerWorkingCopy(workingCopy);\n\n\t\treturn workingCopy;\n\t}\n\n\tprivate registerWorkingCopy(workingCopy: IUntitledFileWorkingCopy<M>): void {\n\n\t\t// Install working copy listeners\n\t\tconst workingCopyListeners = new DisposableStore();\n\t\tworkingCopyListeners.add(workingCopy.onDidChangeDirty(() => this._onDidChangeDirty.fire(workingCopy)));\n\t\tworkingCopyListeners.add(workingCopy.onWillDispose(() => this._onWillDispose.fire(workingCopy)));\n\n\t\t// Keep for disposal\n\t\tthis.mapResourceToWorkingCopyListeners.set(workingCopy.resource, workingCopyListeners);\n\n\t\t// Add to cache\n\t\tthis.add(workingCopy.resource, workingCopy);\n\n\t\t// If the working copy is dirty right from the beginning,\n\t\t// make sure to emit this as an event\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\t}\n\n\tprotected override remove(resource: URI): boolean {\n\t\tconst removed = super.remove(resource);\n\n\t\t// Dispose any existing working copy listeners\n\t\tconst workingCopyListener = this.mapResourceToWorkingCopyListeners.get(resource);\n\t\tif (workingCopyListener) {\n\t\t\tdispose(workingCopyListener);\n\t\t\tthis.mapResourceToWorkingCopyListeners.delete(resource);\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Dispose the working copy change listeners\n\t\tdispose(this.mapResourceToWorkingCopyListeners.values());\n\t\tthis.mapResourceToWorkingCopyListeners.clear();\n\t}\n\n\t//#endregion\n\n\tnotifyDidSave(source: URI, target: URI): void {\n\t\tthis._onDidSave.fire({ source, target });\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, dispose, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IUntitledFileWorkingCopy, IUntitledFileWorkingCopyInitialContents, IUntitledFileWorkingCopyModel, IUntitledFileWorkingCopyModelFactory, IUntitledFileWorkingCopySaveDelegate, UntitledFileWorkingCopy } from './untitledFileWorkingCopy.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { IWorkingCopyService } from './workingCopyService.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IWorkingCopyBackupService } from './workingCopyBackup.js';\nimport { IFileService } from '../../../../platform/files/common/files.js';\nimport { BaseFileWorkingCopyManager, IBaseFileWorkingCopyManager } from './abstractFileWorkingCopyManager.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\n\nexport interface IUntitledFileWorkingCopySaveEvent {\n\n\t/**\n\t * The source untitled file working copy that was saved. It is disposed at this point.\n\t */\n\treadonly source: URI;\n\n\t/**\n\t * The target file working copy the untitled was saved to. Is never untitled.\n\t */\n\treadonly target: URI;\n}\n\n/**\n * The only one that should be dealing with `IUntitledFileWorkingCopy` and\n * handle all operations that are working copy related, such as save/revert,\n * backup and resolving.\n */\nexport interface IUntitledFileWorkingCopyManager<M extends IUntitledFileWorkingCopyModel> extends IBaseFileWorkingCopyManager<M, IUntitledFileWorkingCopy<M>> {\n\n\t/**\n\t * An event for when an untitled file working copy was saved.\n\t * At the point the event fires, the untitled file working copy is\n\t * disposed.\n\t */\n\treadonly onDidSave: Event<IUntitledFileWorkingCopySaveEvent>;\n\n\t/**\n\t * An event for when a untitled file working copy changed it's dirty state.\n\t */\n\treadonly onDidChangeDirty: Event<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a untitled file working copy is about to be disposed.\n\t */\n\treadonly onWillDispose: Event<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents\n\t * and associated resource. The associated resource will be used when\n\t * saving and will not require to ask the user for a file path.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * Creates a new untitled file working copy with optional initial contents\n\t * with the provided resource or return an existing untitled file working\n\t * copy otherwise.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewOrExistingUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\n\t/**\n\t * Internal method: triggers the onDidSave event.\n\t */\n\tnotifyDidSave(source: URI, target: URI): void;\n}\n\nexport interface INewUntitledFileWorkingCopyOptions {\n\n\t/**\n\t * Initial value of the untitled file working copy\n\t * with support to indicate whether this should turn\n\t * the working copy dirty or not.\n\t */\n\tcontents?: IUntitledFileWorkingCopyInitialContents;\n}\n\nexport interface INewUntitledFileWorkingCopyWithAssociatedResourceOptions extends INewUntitledFileWorkingCopyOptions {\n\n\t/**\n\t * Resource components to associate with the untitled file working copy.\n\t * When saving, the associated components will be used and the user\n\t * is not being asked to provide a file path.\n\t *\n\t * Note: currently it is not possible to specify the `scheme` to use. The\n\t * untitled file working copy will saved to the default local or remote resource.\n\t */\n\tassociatedResource: { authority?: string; path?: string; query?: string; fragment?: string };\n}\n\nexport interface INewOrExistingUntitledFileWorkingCopyOptions extends INewUntitledFileWorkingCopyOptions {\n\n\t/**\n\t * A resource to identify the untitled file working copy\n\t * to create or return if already existing.\n\t *\n\t * Note: the resource will not be used unless the scheme is `untitled`.\n\t */\n\tuntitledResource: URI;\n\n\t/**\n\t * A flag that will prevent the working copy from appearing dirty in the UI\n\t * and not show a confirmation dialog when closed with unsaved content.\n\t */\n\tisScratchpad?: boolean;\n}\n\ntype IInternalUntitledFileWorkingCopyOptions = INewUntitledFileWorkingCopyOptions & INewUntitledFileWorkingCopyWithAssociatedResourceOptions & INewOrExistingUntitledFileWorkingCopyOptions;\n\nexport class UntitledFileWorkingCopyManager<M extends IUntitledFileWorkingCopyModel> extends BaseFileWorkingCopyManager<M, IUntitledFileWorkingCopy<M>> implements IUntitledFileWorkingCopyManager<M> {\n\n\t//#region Events\n\n\tprivate readonly _onDidSave = this._register(new Emitter<IUntitledFileWorkingCopySaveEvent>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<IUntitledFileWorkingCopy<M>>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onWillDispose = this._register(new Emitter<IUntitledFileWorkingCopy<M>>());\n\treadonly onWillDispose = this._onWillDispose.event;\n\n\t//#endregion\n\n\tprivate readonly mapResourceToWorkingCopyListeners = new ResourceMap<IDisposable>();\n\n\tconstructor(\n\t\tprivate readonly workingCopyTypeId: string,\n\t\tprivate readonly modelFactory: IUntitledFileWorkingCopyModelFactory<M>,\n\t\tprivate readonly saveDelegate: IUntitledFileWorkingCopySaveDelegate<M>,\n\t\t@IFileService fileService: IFileService,\n\t\t@ILabelService private readonly labelService: ILabelService,\n\t\t@ILogService logService: ILogService,\n\t\t@IWorkingCopyBackupService workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IWorkingCopyService private readonly workingCopyService: IWorkingCopyService\n\t) {\n\t\tsuper(fileService, logService, workingCopyBackupService);\n\t}\n\n\t//#region Resolve\n\n\tresolve(options?: INewUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\tresolve(options?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\tresolve(options?: INewOrExistingUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>>;\n\tasync resolve(options?: IInternalUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<M>> {\n\t\tconst workingCopy = this.doCreateOrGet(options);\n\t\tawait workingCopy.resolve();\n\n\t\treturn workingCopy;\n\t}\n\n\tprivate doCreateOrGet(options: IInternalUntitledFileWorkingCopyOptions = Object.create(null)): IUntitledFileWorkingCopy<M> {\n\t\tconst massagedOptions = this.massageOptions(options);\n\n\t\t// Return existing instance if asked for it\n\t\tif (massagedOptions.untitledResource) {\n\t\t\tconst existingWorkingCopy = this.get(massagedOptions.untitledResource);\n\t\t\tif (existingWorkingCopy) {\n\t\t\t\treturn existingWorkingCopy;\n\t\t\t}\n\t\t}\n\n\t\t// Create new instance otherwise\n\t\treturn this.doCreate(massagedOptions);\n\t}\n\n\tprivate massageOptions(options: IInternalUntitledFileWorkingCopyOptions): IInternalUntitledFileWorkingCopyOptions {\n\t\tconst massagedOptions: IInternalUntitledFileWorkingCopyOptions = Object.create(null);\n\n\t\t// Handle associated resource\n\t\tif (options.associatedResource) {\n\t\t\tmassagedOptions.untitledResource = URI.from({\n\t\t\t\tscheme: Schemas.untitled,\n\t\t\t\tauthority: options.associatedResource.authority,\n\t\t\t\tfragment: options.associatedResource.fragment,\n\t\t\t\tpath: options.associatedResource.path,\n\t\t\t\tquery: options.associatedResource.query\n\t\t\t});\n\t\t\tmassagedOptions.associatedResource = options.associatedResource;\n\t\t}\n\n\t\t// Handle untitled resource\n\t\telse {\n\t\t\tif (options.untitledResource?.scheme === Schemas.untitled) {\n\t\t\t\tmassagedOptions.untitledResource = options.untitledResource;\n\t\t\t}\n\t\t\tmassagedOptions.isScratchpad = options.isScratchpad;\n\t\t}\n\n\t\t// Take over initial value\n\t\tmassagedOptions.contents = options.contents;\n\n\t\treturn massagedOptions;\n\t}\n\n\tprivate doCreate(options: IInternalUntitledFileWorkingCopyOptions): IUntitledFileWorkingCopy<M> {\n\n\t\t// Create a new untitled resource if none is provided\n\t\tlet untitledResource = options.untitledResource;\n\t\tif (!untitledResource) {\n\t\t\tlet counter = 1;\n\t\t\tdo {\n\t\t\t\tuntitledResource = URI.from({\n\t\t\t\t\tscheme: Schemas.untitled,\n\t\t\t\t\tpath: options.isScratchpad ? `Scratchpad-${counter}` : `Untitled-${counter}`,\n\t\t\t\t\tquery: this.workingCopyTypeId ?\n\t\t\t\t\t\t`typeId=${this.workingCopyTypeId}` : // distinguish untitled resources among others by encoding the `typeId` as query param\n\t\t\t\t\t\tundefined\t\t\t\t\t\t\t // keep untitled resources for text files as they are (when `typeId === ''`)\n\t\t\t\t});\n\t\t\t\tcounter++;\n\t\t\t} while (this.has(untitledResource));\n\t\t}\n\n\t\t// Create new working copy with provided options\n\t\tconst workingCopy = new UntitledFileWorkingCopy(\n\t\t\tthis.workingCopyTypeId,\n\t\t\tuntitledResource,\n\t\t\tthis.labelService.getUriBasenameLabel(untitledResource),\n\t\t\t!!options.associatedResource,\n\t\t\t!!options.isScratchpad,\n\t\t\toptions.contents,\n\t\t\tthis.modelFactory,\n\t\t\tthis.saveDelegate,\n\t\t\tthis.workingCopyService,\n\t\t\tthis.workingCopyBackupService,\n\t\t\tthis.logService\n\t\t);\n\n\t\t// Register\n\t\tthis.registerWorkingCopy(workingCopy);\n\n\t\treturn workingCopy;\n\t}\n\n\tprivate registerWorkingCopy(workingCopy: IUntitledFileWorkingCopy<M>): void {\n\n\t\t// Install working copy listeners\n\t\tconst workingCopyListeners = new DisposableStore();\n\t\tworkingCopyListeners.add(workingCopy.onDidChangeDirty(() => this._onDidChangeDirty.fire(workingCopy)));\n\t\tworkingCopyListeners.add(workingCopy.onWillDispose(() => this._onWillDispose.fire(workingCopy)));\n\n\t\t// Keep for disposal\n\t\tthis.mapResourceToWorkingCopyListeners.set(workingCopy.resource, workingCopyListeners);\n\n\t\t// Add to cache\n\t\tthis.add(workingCopy.resource, workingCopy);\n\n\t\t// If the working copy is dirty right from the beginning,\n\t\t// make sure to emit this as an event\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\t}\n\n\tprotected override remove(resource: URI): boolean {\n\t\tconst removed = super.remove(resource);\n\n\t\t// Dispose any existing working copy listeners\n\t\tconst workingCopyListener = this.mapResourceToWorkingCopyListeners.get(resource);\n\t\tif (workingCopyListener) {\n\t\t\tdispose(workingCopyListener);\n\t\t\tthis.mapResourceToWorkingCopyListeners.delete(resource);\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Dispose the working copy change listeners\n\t\tdispose(this.mapResourceToWorkingCopyListeners.values());\n\t\tthis.mapResourceToWorkingCopyListeners.clear();\n\t}\n\n\t//#endregion\n\n\tnotifyDidSave(source: URI, target: URI): void {\n\t\tthis._onDidSave.fire({ source, target });\n\t}\n}\n"]}