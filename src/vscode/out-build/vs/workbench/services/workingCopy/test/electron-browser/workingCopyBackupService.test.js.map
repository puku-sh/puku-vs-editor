{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/workingCopy/test/electron-browser/workingCopyBackupService.test.ts","vs/workbench/services/workingCopy/test/electron-browser/workingCopyBackupService.test.ts"],"names":[],"mappings":"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GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,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","file":"workingCopyBackupService.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { isWindows } from '../../../../../base/common/platform.js';\nimport { insert } from '../../../../../base/common/arrays.js';\nimport { hash } from '../../../../../base/common/hash.js';\nimport { isEqual, joinPath, dirname } from '../../../../../base/common/resources.js';\nimport { join } from '../../../../../base/common/path.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { WorkingCopyBackupsModel, hashIdentifier } from '../../common/workingCopyBackupService.js';\nimport { createTextModel } from '../../../../../editor/test/common/testTextModel.js';\nimport { Schemas } from '../../../../../base/common/network.js';\nimport { FileService } from '../../../../../platform/files/common/fileService.js';\nimport { LogLevel, NullLogService } from '../../../../../platform/log/common/log.js';\nimport { NativeWorkbenchEnvironmentService } from '../../../environment/electron-browser/environmentService.js';\nimport { toBufferOrReadable } from '../../../textfile/common/textfiles.js';\nimport { IFileService } from '../../../../../platform/files/common/files.js';\nimport { NativeWorkingCopyBackupService } from '../../electron-browser/workingCopyBackupService.js';\nimport { FileUserDataProvider } from '../../../../../platform/userData/common/fileUserDataProvider.js';\nimport { bufferToReadable, bufferToStream, streamToBuffer, VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../../base/common/buffer.js';\nimport { TestLifecycleService, toTypedWorkingCopyId, toUntypedWorkingCopyId } from '../../../../test/browser/workbenchTestServices.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { IWorkingCopyBackupMeta, IWorkingCopyIdentifier } from '../../common/workingCopy.js';\nimport { consumeStream } from '../../../../../base/common/stream.js';\nimport { TestProductService } from '../../../../test/common/workbenchTestServices.js';\nimport { InMemoryFileSystemProvider } from '../../../../../platform/files/common/inMemoryFilesystemProvider.js';\nimport { generateUuid } from '../../../../../base/common/uuid.js';\nimport { INativeWindowConfiguration } from '../../../../../platform/window/common/window.js';\nimport product from '../../../../../platform/product/common/product.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { DisposableStore } from '../../../../../base/common/lifecycle.js';\nimport { UserDataProfilesService } from '../../../../../platform/userDataProfile/common/userDataProfile.js';\nimport { UriIdentityService } from '../../../../../platform/uriIdentity/common/uriIdentityService.js';\n\nconst homeDir = URI.file('home').with({ scheme: Schemas.inMemory });\nconst tmpDir = URI.file('tmp').with({ scheme: Schemas.inMemory });\nconst NULL_PROFILE = {\n\tname: '',\n\tid: '',\n\tshortName: '',\n\tisDefault: false,\n\tlocation: homeDir,\n\tsettingsResource: joinPath(homeDir, 'settings.json'),\n\tglobalStorageHome: joinPath(homeDir, 'globalStorage'),\n\tkeybindingsResource: joinPath(homeDir, 'keybindings.json'),\n\ttasksResource: joinPath(homeDir, 'tasks.json'),\n\tmcpResource: joinPath(homeDir, 'mcp.json'),\n\tsnippetsHome: joinPath(homeDir, 'snippets'),\n\tpromptsHome: joinPath(homeDir, 'prompts'),\n\textensionsResource: joinPath(homeDir, 'extensions.json'),\n\tcacheHome: joinPath(homeDir, 'cache')\n};\n\nconst TestNativeWindowConfiguration: INativeWindowConfiguration = {\n\twindowId: 0,\n\tmachineId: 'testMachineId',\n\tsqmId: 'testSqmId',\n\tdevDeviceId: 'testdevDeviceId',\n\tlogLevel: LogLevel.Error,\n\tloggers: [],\n\tmainPid: 0,\n\tappRoot: '',\n\tuserEnv: {},\n\texecPath: process.execPath,\n\tperfMarks: [],\n\tcolorScheme: { dark: true, highContrast: false },\n\tos: { release: 'unknown', hostname: 'unknown', arch: 'unknown' },\n\tproduct,\n\thomeDir: homeDir.fsPath,\n\ttmpDir: tmpDir.fsPath,\n\tuserDataDir: joinPath(homeDir, product.nameShort).fsPath,\n\tprofiles: { profile: NULL_PROFILE, all: [NULL_PROFILE], home: homeDir },\n\tnls: {\n\t\tmessages: [],\n\t\tlanguage: 'en'\n\t},\n\t_: []\n};\n\nexport class TestNativeWorkbenchEnvironmentService extends NativeWorkbenchEnvironmentService {\n\n\tconstructor(testDir: URI, backupPath: URI) {\n\t\tsuper({ ...TestNativeWindowConfiguration, backupPath: backupPath.fsPath, 'user-data-dir': testDir.fsPath }, TestProductService);\n\t}\n}\n\nexport class NodeTestWorkingCopyBackupService extends NativeWorkingCopyBackupService {\n\n\tprivate backupResourceJoiners: Function[];\n\tprivate discardBackupJoiners: Function[];\n\tdiscardedBackups: IWorkingCopyIdentifier[];\n\tdiscardedAllBackups: boolean;\n\tprivate pendingBackupsArr: Promise<void>[];\n\n\treadonly _fileService: IFileService;\n\n\tconstructor(testDir: URI, workspaceBackupPath: URI) {\n\t\tconst environmentService = new TestNativeWorkbenchEnvironmentService(testDir, workspaceBackupPath);\n\t\tconst logService = new NullLogService();\n\t\tconst fileService = new FileService(logService);\n\t\tconst lifecycleService = new TestLifecycleService();\n\t\tsuper(environmentService, fileService, logService, lifecycleService);\n\n\t\tconst fsp = new InMemoryFileSystemProvider();\n\t\tfileService.registerProvider(Schemas.inMemory, fsp);\n\t\tconst uriIdentityService = new UriIdentityService(fileService);\n\t\tconst userDataProfilesService = new UserDataProfilesService(environmentService, fileService, uriIdentityService, logService);\n\t\tfileService.registerProvider(Schemas.vscodeUserData, new FileUserDataProvider(Schemas.file, fsp, Schemas.vscodeUserData, userDataProfilesService, uriIdentityService, logService));\n\n\t\tthis._fileService = fileService;\n\n\t\tthis.backupResourceJoiners = [];\n\t\tthis.discardBackupJoiners = [];\n\t\tthis.discardedBackups = [];\n\t\tthis.pendingBackupsArr = [];\n\t\tthis.discardedAllBackups = false;\n\t}\n\n\ttestGetFileService(): IFileService {\n\t\treturn this.fileService;\n\t}\n\n\tasync waitForAllBackups(): Promise<void> {\n\t\tawait Promise.all(this.pendingBackupsArr);\n\t}\n\n\tjoinBackupResource(): Promise<void> {\n\t\treturn new Promise(resolve => this.backupResourceJoiners.push(resolve));\n\t}\n\n\toverride async backup(identifier: IWorkingCopyIdentifier, content?: VSBufferReadableStream | VSBufferReadable, versionId?: number, meta?: any, token?: CancellationToken): Promise<void> {\n\t\tconst p = super.backup(identifier, content, versionId, meta, token);\n\t\tconst removeFromPendingBackups = insert(this.pendingBackupsArr, p.then(undefined, undefined));\n\n\t\ttry {\n\t\t\tawait p;\n\t\t} finally {\n\t\t\tremoveFromPendingBackups();\n\t\t}\n\n\t\twhile (this.backupResourceJoiners.length) {\n\t\t\tthis.backupResourceJoiners.pop()!();\n\t\t}\n\t}\n\n\tjoinDiscardBackup(): Promise<void> {\n\t\treturn new Promise(resolve => this.discardBackupJoiners.push(resolve));\n\t}\n\n\toverride async discardBackup(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\tawait super.discardBackup(identifier);\n\t\tthis.discardedBackups.push(identifier);\n\n\t\twhile (this.discardBackupJoiners.length) {\n\t\t\tthis.discardBackupJoiners.pop()!();\n\t\t}\n\t}\n\n\toverride async discardBackups(filter?: { except: IWorkingCopyIdentifier[] }): Promise<void> {\n\t\tthis.discardedAllBackups = true;\n\n\t\treturn super.discardBackups(filter);\n\t}\n\n\tasync getBackupContents(identifier: IWorkingCopyIdentifier): Promise<string> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\tconst fileContents = await this.fileService.readFile(backupResource);\n\n\t\treturn fileContents.value.toString();\n\t}\n}\n\nsuite('WorkingCopyBackupService', () => {\n\n\tlet testDir: URI;\n\tlet backupHome: URI;\n\tlet workspacesJsonPath: URI;\n\tlet workspaceBackupPath: URI;\n\n\tlet service: NodeTestWorkingCopyBackupService;\n\tlet fileService: IFileService;\n\n\tconst disposables = new DisposableStore();\n\n\tconst workspaceResource = URI.file(isWindows ? 'c:\\\\workspace' : '/workspace');\n\tconst fooFile = URI.file(isWindows ? 'c:\\\\Foo' : '/Foo');\n\tconst customFile = URI.parse('customScheme://some/path');\n\tconst customFileWithFragment = URI.parse('customScheme2://some/path#fragment');\n\tconst barFile = URI.file(isWindows ? 'c:\\\\Bar' : '/Bar');\n\tconst fooBarFile = URI.file(isWindows ? 'c:\\\\Foo Bar' : '/Foo Bar');\n\tconst untitledFile = URI.from({ scheme: Schemas.untitled, path: 'Untitled-1' });\n\n\tsetup(async () => {\n\t\ttestDir = URI.file(join(generateUuid(), 'vsctests', 'workingcopybackupservice')).with({ scheme: Schemas.inMemory });\n\t\tbackupHome = joinPath(testDir, 'Backups');\n\t\tworkspacesJsonPath = joinPath(backupHome, 'workspaces.json');\n\t\tworkspaceBackupPath = joinPath(backupHome, hash(workspaceResource.fsPath).toString(16));\n\n\t\tservice = disposables.add(new NodeTestWorkingCopyBackupService(testDir, workspaceBackupPath));\n\t\tfileService = service._fileService;\n\n\t\tawait fileService.createFolder(backupHome);\n\n\t\treturn fileService.writeFile(workspacesJsonPath, VSBuffer.fromString(''));\n\t});\n\n\tteardown(() => {\n\t\tdisposables.clear();\n\t});\n\n\tsuite('hashIdentifier', () => {\n\t\ttest('should correctly hash the identifier for untitled scheme URIs', () => {\n\t\t\tconst uri = URI.from({ scheme: Schemas.untitled, path: 'Untitled-1' });\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes change people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tconst untypedBackupHash = hashIdentifier(toUntypedWorkingCopyId(uri));\n\t\t\tassert.strictEqual(untypedBackupHash, '-7f9c1a2e');\n\t\t\tassert.strictEqual(untypedBackupHash, hash(uri.fsPath).toString(16));\n\n\t\t\tconst typedBackupHash = hashIdentifier({ typeId: 'hashTest', resource: uri });\n\t\t\tif (isWindows) {\n\t\t\t\tassert.strictEqual(typedBackupHash, '-17c47cdc');\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(typedBackupHash, '-8ad5f4f');\n\t\t\t}\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes collide people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tassert.notStrictEqual(untypedBackupHash, typedBackupHash);\n\t\t});\n\n\t\ttest('should correctly hash the identifier for file scheme URIs', () => {\n\t\t\tconst uri = URI.file('/foo');\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes change people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tconst untypedBackupHash = hashIdentifier(toUntypedWorkingCopyId(uri));\n\t\t\tif (isWindows) {\n\t\t\t\tassert.strictEqual(untypedBackupHash, '20ffaa13');\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(untypedBackupHash, '20eb3560');\n\t\t\t}\n\t\t\tassert.strictEqual(untypedBackupHash, hash(uri.fsPath).toString(16));\n\n\t\t\tconst typedBackupHash = hashIdentifier({ typeId: 'hashTest', resource: uri });\n\t\t\tif (isWindows) {\n\t\t\t\tassert.strictEqual(typedBackupHash, '-55fc55db');\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(typedBackupHash, '51e56bf');\n\t\t\t}\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes collide people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tassert.notStrictEqual(untypedBackupHash, typedBackupHash);\n\t\t});\n\n\t\ttest('should correctly hash the identifier for custom scheme URIs', () => {\n\t\t\tconst uri = URI.from({\n\t\t\t\tscheme: 'vscode-custom',\n\t\t\t\tpath: 'somePath'\n\t\t\t});\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes change people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tconst untypedBackupHash = hashIdentifier(toUntypedWorkingCopyId(uri));\n\t\t\tassert.strictEqual(untypedBackupHash, '-44972d98');\n\t\t\tassert.strictEqual(untypedBackupHash, hash(uri.toString()).toString(16));\n\n\t\t\tconst typedBackupHash = hashIdentifier({ typeId: 'hashTest', resource: uri });\n\t\t\tassert.strictEqual(typedBackupHash, '502149c7');\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes collide people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tassert.notStrictEqual(untypedBackupHash, typedBackupHash);\n\t\t});\n\n\t\ttest('should not fail for URIs without path', () => {\n\t\t\tconst uri = URI.from({\n\t\t\t\tscheme: 'vscode-fragment',\n\t\t\t\tfragment: 'frag'\n\t\t\t});\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes change people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tconst untypedBackupHash = hashIdentifier(toUntypedWorkingCopyId(uri));\n\t\t\tassert.strictEqual(untypedBackupHash, '-2f6b2f1b');\n\t\t\tassert.strictEqual(untypedBackupHash, hash(uri.toString()).toString(16));\n\n\t\t\tconst typedBackupHash = hashIdentifier({ typeId: 'hashTest', resource: uri });\n\t\t\tassert.strictEqual(typedBackupHash, '6e82ca57');\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes collide people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tassert.notStrictEqual(untypedBackupHash, typedBackupHash);\n\t\t});\n\t});\n\n\tsuite('getBackupResource', () => {\n\t\ttest('should get the correct backup path for text files', () => {\n\n\t\t\t// Format should be: <backupHome>/<workspaceHash>/<scheme>/<filePathHash>\n\t\t\tconst backupResource = fooFile;\n\t\t\tconst workspaceHash = hash(workspaceResource.fsPath).toString(16);\n\n\t\t\t// No Type ID\n\t\t\tlet backupId = toUntypedWorkingCopyId(backupResource);\n\t\t\tlet filePathHash = hashIdentifier(backupId);\n\t\t\tlet expectedPath = joinPath(backupHome, workspaceHash, Schemas.file, filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\n\t\t\t// With Type ID\n\t\t\tbackupId = toTypedWorkingCopyId(backupResource);\n\t\t\tfilePathHash = hashIdentifier(backupId);\n\t\t\texpectedPath = joinPath(backupHome, workspaceHash, Schemas.file, filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\t\t});\n\n\t\ttest('should get the correct backup path for untitled files', () => {\n\n\t\t\t// Format should be: <backupHome>/<workspaceHash>/<scheme>/<filePathHash>\n\t\t\tconst backupResource = URI.from({ scheme: Schemas.untitled, path: 'Untitled-1' });\n\t\t\tconst workspaceHash = hash(workspaceResource.fsPath).toString(16);\n\n\t\t\t// No Type ID\n\t\t\tlet backupId = toUntypedWorkingCopyId(backupResource);\n\t\t\tlet filePathHash = hashIdentifier(backupId);\n\t\t\tlet expectedPath = joinPath(backupHome, workspaceHash, Schemas.untitled, filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\n\t\t\t// With Type ID\n\t\t\tbackupId = toTypedWorkingCopyId(backupResource);\n\t\t\tfilePathHash = hashIdentifier(backupId);\n\t\t\texpectedPath = joinPath(backupHome, workspaceHash, Schemas.untitled, filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\t\t});\n\n\t\ttest('should get the correct backup path for custom files', () => {\n\n\t\t\t// Format should be: <backupHome>/<workspaceHash>/<scheme>/<filePathHash>\n\t\t\tconst backupResource = URI.from({ scheme: 'custom', path: 'custom/file.txt' });\n\t\t\tconst workspaceHash = hash(workspaceResource.fsPath).toString(16);\n\n\t\t\t// No Type ID\n\t\t\tlet backupId = toUntypedWorkingCopyId(backupResource);\n\t\t\tlet filePathHash = hashIdentifier(backupId);\n\t\t\tlet expectedPath = joinPath(backupHome, workspaceHash, 'custom', filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\n\t\t\t// With Type ID\n\t\t\tbackupId = toTypedWorkingCopyId(backupResource);\n\t\t\tfilePathHash = hashIdentifier(backupId);\n\t\t\texpectedPath = joinPath(backupHome, workspaceHash, 'custom', filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\t\t});\n\t});\n\n\tsuite('backup', () => {\n\n\t\tfunction toExpectedPreamble(identifier: IWorkingCopyIdentifier, content = '', meta?: object): string {\n\t\t\treturn `${identifier.resource.toString()} ${JSON.stringify({ ...meta, typeId: identifier.typeId })}\\n${content}`;\n\t\t}\n\n\t\ttest('joining', async () => {\n\t\t\tlet backupJoined = false;\n\t\t\tconst joinBackupsPromise = service.joinBackups();\n\t\t\tjoinBackupsPromise.then(() => backupJoined = true);\n\t\t\tawait joinBackupsPromise;\n\t\t\tassert.strictEqual(backupJoined, true);\n\n\t\t\tbackupJoined = false;\n\t\t\tservice.joinBackups().then(() => backupJoined = true);\n\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tconst backupPromise = service.backup(identifier);\n\t\t\tassert.strictEqual(backupJoined, false);\n\t\t\tawait backupPromise;\n\t\t\tassert.strictEqual(backupJoined, true);\n\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('no text', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test'));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file (with version)', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')), 666);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test'));\n\t\t\tassert.ok(!service.hasBackupSync(identifier, 555));\n\t\t\tassert.ok(service.hasBackupSync(identifier, 666));\n\t\t});\n\n\t\ttest('text file (with meta)', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst meta = { etag: '678', orphaned: true };\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')), undefined, meta);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test', meta));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file with whitespace in name and type (with meta)', async () => {\n\t\t\tconst fileWithSpace = URI.file(isWindows ? 'c:\\\\Foo \\n Bar' : '/Foo \\n Bar');\n\t\t\tconst identifier = toTypedWorkingCopyId(fileWithSpace, ' test id \\n');\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst meta = { etag: '678 \\n k', orphaned: true };\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')), undefined, meta);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test', meta));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file with unicode character in name and type (with meta)', async () => {\n\t\t\tconst fileWithUnicode = URI.file(isWindows ? 'c:\\\\some' : '/some');\n\t\t\tconst identifier = toTypedWorkingCopyId(fileWithUnicode, ' test some id \\n');\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst meta = { etag: '678some', orphaned: true };\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')), undefined, meta);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test', meta));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('untitled file', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test'));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file (readable)', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst model = createTextModel('test');\n\n\t\t\tawait service.backup(identifier, toBufferOrReadable(model.createSnapshot()));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test'));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\n\t\t\tmodel.dispose();\n\t\t});\n\n\t\ttest('untitled file (readable)', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst model = createTextModel('test');\n\n\t\t\tawait service.backup(identifier, toBufferOrReadable(model.createSnapshot()));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test'));\n\n\t\t\tmodel.dispose();\n\t\t});\n\n\t\ttest('text file (large file, stream)', () => {\n\t\t\tconst largeString = (new Array(30 * 1024)).join('Large String\\n');\n\n\t\t\treturn testLargeTextFile(largeString, bufferToStream(VSBuffer.fromString(largeString)));\n\t\t});\n\n\t\ttest('text file (large file, readable)', async () => {\n\t\t\tconst largeString = (new Array(30 * 1024)).join('Large String\\n');\n\t\t\tconst model = createTextModel(largeString);\n\n\t\t\tawait testLargeTextFile(largeString, toBufferOrReadable(model.createSnapshot()));\n\n\t\t\tmodel.dispose();\n\t\t});\n\n\t\tasync function testLargeTextFile(largeString: string, buffer: VSBufferReadable | VSBufferReadableStream) {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, buffer, undefined, { largeTest: true });\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, largeString, { largeTest: true }));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t}\n\n\t\ttest('untitled file (large file, readable)', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst largeString = (new Array(30 * 1024)).join('Large String\\n');\n\t\t\tconst model = createTextModel(largeString);\n\n\t\t\tawait service.backup(identifier, toBufferOrReadable(model.createSnapshot()));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, largeString));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\n\t\t\tmodel.dispose();\n\t\t});\n\n\t\ttest('cancellation', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tconst cts = new CancellationTokenSource();\n\t\t\tconst promise = service.backup(identifier, undefined, undefined, undefined, cts.token);\n\t\t\tcts.cancel();\n\t\t\tawait promise;\n\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\tassert.ok(!service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('multiple', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait Promise.all([\n\t\t\t\tservice.backup(identifier),\n\t\t\t\tservice.backup(identifier),\n\t\t\t\tservice.backup(identifier),\n\t\t\t\tservice.backup(identifier)\n\t\t\t]);\n\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('multiple same resource, different type id', async () => {\n\t\t\tconst backupId1 = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupId2 = toTypedWorkingCopyId(fooFile, 'type1');\n\t\t\tconst backupId3 = toTypedWorkingCopyId(fooFile, 'type2');\n\n\t\t\tawait Promise.all([\n\t\t\t\tservice.backup(backupId1),\n\t\t\t\tservice.backup(backupId2),\n\t\t\t\tservice.backup(backupId3)\n\t\t\t]);\n\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 3);\n\n\t\t\tfor (const backupId of [backupId1, backupId2, backupId3]) {\n\t\t\t\tconst fooBackupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\t\t\t\tassert.strictEqual((await fileService.exists(fooBackupPath)), true);\n\t\t\t\tassert.strictEqual((await fileService.readFile(fooBackupPath)).value.toString(), toExpectedPreamble(backupId));\n\t\t\t\tassert.ok(service.hasBackupSync(backupId));\n\t\t\t}\n\t\t});\n\t});\n\n\tsuite('discardBackup', () => {\n\n\t\ttest('joining', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\n\t\t\tlet backupJoined = false;\n\t\t\tservice.joinBackups().then(() => backupJoined = true);\n\n\t\t\tconst discardBackupPromise = service.discardBackup(identifier);\n\t\t\tassert.strictEqual(backupJoined, false);\n\t\t\tawait discardBackupPromise;\n\t\t\tassert.strictEqual(backupJoined, true);\n\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 0);\n\t\t\tassert.ok(!service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\n\t\t\tawait service.discardBackup(identifier);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 0);\n\t\t\tassert.ok(!service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('untitled file', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\n\t\t\tawait service.discardBackup(identifier);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 0);\n\t\t});\n\n\t\ttest('multiple same resource, different type id', async () => {\n\t\t\tconst backupId1 = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupId2 = toTypedWorkingCopyId(fooFile, 'type1');\n\t\t\tconst backupId3 = toTypedWorkingCopyId(fooFile, 'type2');\n\n\t\t\tawait Promise.all([\n\t\t\t\tservice.backup(backupId1),\n\t\t\t\tservice.backup(backupId2),\n\t\t\t\tservice.backup(backupId3)\n\t\t\t]);\n\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 3);\n\n\t\t\tfor (const backupId of [backupId1, backupId2, backupId3]) {\n\t\t\t\tconst backupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\t\t\t\tawait service.discardBackup(backupId);\n\t\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\t}\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 0);\n\t\t});\n\t});\n\n\tsuite('discardBackups (all)', () => {\n\t\ttest('text file', async () => {\n\t\t\tconst backupId1 = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupId2 = toUntypedWorkingCopyId(barFile);\n\t\t\tconst backupId3 = toTypedWorkingCopyId(barFile);\n\n\t\t\tawait service.backup(backupId1, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\n\t\t\tawait service.backup(backupId2, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 2);\n\n\t\t\tawait service.backup(backupId3, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 3);\n\n\t\t\tawait service.discardBackups();\n\t\t\tfor (const backupId of [backupId1, backupId2, backupId3]) {\n\t\t\t\tconst backupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\t\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\t}\n\n\t\t\tassert.strictEqual((await fileService.exists(joinPath(workspaceBackupPath, 'file'))), false);\n\t\t});\n\n\t\ttest('untitled file', async () => {\n\t\t\tconst backupId = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\n\t\t\tawait service.backup(backupId, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\n\t\t\tawait service.discardBackups();\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\tassert.strictEqual((await fileService.exists(joinPath(workspaceBackupPath, 'untitled'))), false);\n\t\t});\n\n\t\ttest('can backup after discarding all', async () => {\n\t\t\tawait service.discardBackups();\n\t\t\tawait service.backup(toUntypedWorkingCopyId(untitledFile), bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.exists(workspaceBackupPath)), true);\n\t\t});\n\t});\n\n\tsuite('discardBackups (except some)', () => {\n\t\ttest('text file', async () => {\n\t\t\tconst backupId1 = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupId2 = toUntypedWorkingCopyId(barFile);\n\t\t\tconst backupId3 = toTypedWorkingCopyId(barFile);\n\n\t\t\tawait service.backup(backupId1, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\n\t\t\tawait service.backup(backupId2, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 2);\n\n\t\t\tawait service.backup(backupId3, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 3);\n\n\t\t\tawait service.discardBackups({ except: [backupId2, backupId3] });\n\n\t\t\tlet backupPath = joinPath(workspaceBackupPath, backupId1.resource.scheme, hashIdentifier(backupId1));\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\n\t\t\tbackupPath = joinPath(workspaceBackupPath, backupId2.resource.scheme, hashIdentifier(backupId2));\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\n\t\t\tbackupPath = joinPath(workspaceBackupPath, backupId3.resource.scheme, hashIdentifier(backupId3));\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\n\t\t\tawait service.discardBackups({ except: [backupId1] });\n\n\t\t\tfor (const backupId of [backupId1, backupId2, backupId3]) {\n\t\t\t\tconst backupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\t\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\t}\n\t\t});\n\n\t\ttest('untitled file', async () => {\n\t\t\tconst backupId = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\n\t\t\tawait service.backup(backupId, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\n\t\t\tawait service.discardBackups({ except: [backupId] });\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t});\n\t});\n\n\tsuite('getBackups', () => {\n\t\ttest('text file', async () => {\n\t\t\tawait Promise.all([\n\t\t\t\tservice.backup(toUntypedWorkingCopyId(fooFile), bufferToReadable(VSBuffer.fromString('test'))),\n\t\t\t\tservice.backup(toTypedWorkingCopyId(fooFile, 'type1'), bufferToReadable(VSBuffer.fromString('test'))),\n\t\t\t\tservice.backup(toTypedWorkingCopyId(fooFile, 'type2'), bufferToReadable(VSBuffer.fromString('test')))\n\t\t\t]);\n\n\t\t\tlet backups = await service.getBackups();\n\t\t\tassert.strictEqual(backups.length, 3);\n\n\t\t\tfor (const backup of backups) {\n\t\t\t\tif (backup.typeId === '') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), fooFile.toString());\n\t\t\t\t} else if (backup.typeId === 'type1') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), fooFile.toString());\n\t\t\t\t} else if (backup.typeId === 'type2') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), fooFile.toString());\n\t\t\t\t} else {\n\t\t\t\t\tassert.fail('Unexpected backup');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait service.backup(toUntypedWorkingCopyId(barFile), bufferToReadable(VSBuffer.fromString('test')));\n\n\t\t\tbackups = await service.getBackups();\n\t\t\tassert.strictEqual(backups.length, 4);\n\t\t});\n\n\t\ttest('untitled file', async () => {\n\t\t\tawait Promise.all([\n\t\t\t\tservice.backup(toUntypedWorkingCopyId(untitledFile), bufferToReadable(VSBuffer.fromString('test'))),\n\t\t\t\tservice.backup(toTypedWorkingCopyId(untitledFile, 'type1'), bufferToReadable(VSBuffer.fromString('test'))),\n\t\t\t\tservice.backup(toTypedWorkingCopyId(untitledFile, 'type2'), bufferToReadable(VSBuffer.fromString('test')))\n\t\t\t]);\n\n\t\t\tconst backups = await service.getBackups();\n\t\t\tassert.strictEqual(backups.length, 3);\n\n\t\t\tfor (const backup of backups) {\n\t\t\t\tif (backup.typeId === '') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), untitledFile.toString());\n\t\t\t\t} else if (backup.typeId === 'type1') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), untitledFile.toString());\n\t\t\t\t} else if (backup.typeId === 'type2') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), untitledFile.toString());\n\t\t\t\t} else {\n\t\t\t\t\tassert.fail('Unexpected backup');\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\tsuite('resolve', () => {\n\n\t\tinterface IBackupTestMetaData extends IWorkingCopyBackupMeta {\n\t\t\tmtime?: number;\n\t\t\tsize?: number;\n\t\t\tetag?: string;\n\t\t\torphaned?: boolean;\n\t\t}\n\n\t\ttest('should restore the original contents (untitled file)', async () => {\n\t\t\tconst contents = 'test\\nand more stuff';\n\n\t\t\tawait testResolveBackup(untitledFile, contents);\n\t\t});\n\n\t\ttest('should restore the original contents (untitled file with metadata)', async () => {\n\t\t\tconst contents = 'test\\nand more stuff';\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'the Etag',\n\t\t\t\tsize: 666,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: true\n\t\t\t};\n\n\t\t\tawait testResolveBackup(untitledFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (untitled file empty with metadata)', async () => {\n\t\t\tconst contents = '';\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'the Etag',\n\t\t\t\tsize: 666,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: true\n\t\t\t};\n\n\t\t\tawait testResolveBackup(untitledFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (untitled large file with metadata)', async () => {\n\t\t\tconst contents = (new Array(30 * 1024)).join('Large String\\n');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'the Etag',\n\t\t\t\tsize: 666,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: true\n\t\t\t};\n\n\t\t\tawait testResolveBackup(untitledFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (text file)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'consectetur ',\n\t\t\t\t'adipiscing  elit'\n\t\t\t].join('');\n\n\t\t\tawait testResolveBackup(fooFile, contents);\n\t\t});\n\n\t\ttest('should restore the original contents (text file - custom scheme)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'consectetur ',\n\t\t\t\t'adipiscing  elit'\n\t\t\t].join('');\n\n\t\t\tawait testResolveBackup(customFile, contents);\n\t\t});\n\n\t\ttest('should restore the original contents (text file with metadata)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (empty text file with metadata)', async () => {\n\t\t\tconst contents = '';\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (large text file with metadata)', async () => {\n\t\t\tconst contents = (new Array(30 * 1024)).join('Large String\\n');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (text file with metadata changed once)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooFile, contents, meta);\n\n\t\t\t// Change meta and test again\n\t\t\tmeta.size = 999;\n\t\t\tawait testResolveBackup(fooFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (text file with metadata and fragment URI)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(customFileWithFragment, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (text file with space in name with metadata)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooBarFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (text file with too large metadata to persist)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: (new Array(100 * 1024)).join('Large String'),\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooFile, contents, meta, true);\n\t\t});\n\n\t\tasync function testResolveBackup(resource: URI, contents: string, meta?: IBackupTestMetaData, expectNoMeta?: boolean) {\n\t\t\tawait doTestResolveBackup(toUntypedWorkingCopyId(resource), contents, meta, expectNoMeta);\n\t\t\tawait doTestResolveBackup(toTypedWorkingCopyId(resource), contents, meta, expectNoMeta);\n\t\t}\n\n\t\tasync function doTestResolveBackup(identifier: IWorkingCopyIdentifier, contents: string, meta?: IBackupTestMetaData, expectNoMeta?: boolean) {\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString(contents)), 1, meta);\n\n\t\t\tconst backup = await service.resolve<IBackupTestMetaData>(identifier);\n\t\t\tassert.ok(backup);\n\t\t\tassert.strictEqual(contents, (await streamToBuffer(backup.value)).toString());\n\n\t\t\tif (expectNoMeta || !meta) {\n\t\t\t\tassert.strictEqual(backup.meta, undefined);\n\t\t\t} else {\n\t\t\t\tassert.ok(backup.meta);\n\t\t\t\tassert.strictEqual(backup.meta.etag, meta.etag);\n\t\t\t\tassert.strictEqual(backup.meta.size, meta.size);\n\t\t\t\tassert.strictEqual(backup.meta.mtime, meta.mtime);\n\t\t\t\tassert.strictEqual(backup.meta.orphaned, meta.orphaned);\n\n\t\t\t\tassert.strictEqual(Object.keys(meta).length, Object.keys(backup.meta).length);\n\t\t\t}\n\t\t}\n\n\t\ttest('should restore the original contents (text file with broken metadata)', async () => {\n\t\t\tawait testShouldRestoreOriginalContentsWithBrokenBackup(toUntypedWorkingCopyId(fooFile));\n\t\t\tawait testShouldRestoreOriginalContentsWithBrokenBackup(toTypedWorkingCopyId(fooFile));\n\t\t});\n\n\t\tasync function testShouldRestoreOriginalContentsWithBrokenBackup(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString(contents)), 1, meta);\n\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tconst fileContents = (await fileService.readFile(backupPath)).value.toString();\n\t\t\tassert.strictEqual(fileContents.indexOf(identifier.resource.toString()), 0);\n\n\t\t\tconst metaIndex = fileContents.indexOf('{');\n\t\t\tconst newFileContents = fileContents.substring(0, metaIndex) + '{{' + fileContents.substr(metaIndex);\n\t\t\tawait fileService.writeFile(backupPath, VSBuffer.fromString(newFileContents));\n\n\t\t\tconst backup = await service.resolve(identifier);\n\t\t\tassert.ok(backup);\n\t\t\tassert.strictEqual(contents, (await streamToBuffer(backup.value)).toString());\n\t\t\tassert.strictEqual(backup.meta, undefined);\n\t\t}\n\n\t\ttest('should update metadata from file into model when resolving', async () => {\n\t\t\tawait testShouldUpdateMetaFromFileWhenResolving(toUntypedWorkingCopyId(fooFile));\n\t\t\tawait testShouldUpdateMetaFromFileWhenResolving(toTypedWorkingCopyId(fooFile));\n\t\t});\n\n\t\tasync function testShouldUpdateMetaFromFileWhenResolving(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\t\tconst contents = 'Foo Bar';\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtagForThisMetadataTest',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tconst updatedMeta = {\n\t\t\t\t...meta,\n\t\t\t\tetag: meta.etag + meta.etag\n\t\t\t};\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString(contents)), 1, meta);\n\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\t// Simulate the condition of the backups model loading initially without\n\t\t\t// meta data information and then getting the meta data updated on the\n\t\t\t// first call to resolve the backup. We simulate this by explicitly changing\n\t\t\t// the meta data in the file and then verifying that the updated meta data\n\t\t\t// is persisted back into the model (verified via `hasBackupSync`).\n\t\t\t// This is not really something that would happen in real life because any\n\t\t\t// backup that is made via backup service will update the model accordingly.\n\n\t\t\tconst originalFileContents = (await fileService.readFile(backupPath)).value.toString();\n\t\t\tawait fileService.writeFile(backupPath, VSBuffer.fromString(originalFileContents.replace(meta.etag, updatedMeta.etag)));\n\n\t\t\tawait service.resolve(identifier);\n\n\t\t\tassert.strictEqual(service.hasBackupSync(identifier, undefined, meta), false);\n\t\t\tassert.strictEqual(service.hasBackupSync(identifier, undefined, updatedMeta), true);\n\n\t\t\tawait fileService.writeFile(backupPath, VSBuffer.fromString(originalFileContents));\n\n\t\t\tawait service.getBackups();\n\n\t\t\tassert.strictEqual(service.hasBackupSync(identifier, undefined, meta), true);\n\t\t\tassert.strictEqual(service.hasBackupSync(identifier, undefined, updatedMeta), false);\n\t\t}\n\n\t\ttest('should ignore invalid backups (empty file)', async () => {\n\t\t\tconst contents = 'test\\nand more stuff';\n\n\t\t\tawait service.backup(toUntypedWorkingCopyId(fooFile), bufferToReadable(VSBuffer.fromString(contents)), 1);\n\n\t\t\tlet backup = await service.resolve(toUntypedWorkingCopyId(fooFile));\n\t\t\tassert.ok(backup);\n\n\t\t\tawait service.testGetFileService().writeFile(service.toBackupResource(toUntypedWorkingCopyId(fooFile)), VSBuffer.fromString(''));\n\n\t\t\tbackup = await service.resolve<IBackupTestMetaData>(toUntypedWorkingCopyId(fooFile));\n\t\t\tassert.ok(!backup);\n\t\t});\n\n\t\ttest('should ignore invalid backups (no preamble)', async () => {\n\t\t\tconst contents = 'testand more stuff';\n\n\t\t\tawait service.backup(toUntypedWorkingCopyId(fooFile), bufferToReadable(VSBuffer.fromString(contents)), 1);\n\n\t\t\tlet backup = await service.resolve(toUntypedWorkingCopyId(fooFile));\n\t\t\tassert.ok(backup);\n\n\t\t\tawait service.testGetFileService().writeFile(service.toBackupResource(toUntypedWorkingCopyId(fooFile)), VSBuffer.fromString(contents));\n\n\t\t\tbackup = await service.resolve<IBackupTestMetaData>(toUntypedWorkingCopyId(fooFile));\n\t\t\tassert.ok(!backup);\n\t\t});\n\n\t\ttest('file with binary data', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\n\t\t\tconst buffer = Uint8Array.from([\n\t\t\t\t137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 73, 0, 0, 0, 67, 8, 2, 0, 0, 0, 95, 138, 191, 237, 0, 0, 0, 1, 115, 82, 71, 66, 0, 174, 206, 28, 233, 0, 0, 0, 4, 103, 65, 77, 65, 0, 0, 177, 143, 11, 252, 97, 5, 0, 0, 0, 9, 112, 72, 89, 115, 0, 0, 14, 195, 0, 0, 14, 195, 1, 199, 111, 168, 100, 0, 0, 0, 71, 116, 69, 88, 116, 83, 111, 117, 114, 99, 101, 0, 83, 104, 111, 116, 116, 121, 32, 118, 50, 46, 48, 46, 50, 46, 50, 49, 54, 32, 40, 67, 41, 32, 84, 104, 111, 109, 97, 115, 32, 66, 97, 117, 109, 97, 110, 110, 32, 45, 32, 104, 116, 116, 112, 58, 47, 47, 115, 104, 111, 116, 116, 121, 46, 100, 101, 118, 115, 45, 111, 110, 46, 110, 101, 116, 44, 132, 21, 213, 0, 0, 0, 84, 73, 68, 65, 84, 120, 218, 237, 207, 65, 17, 0, 0, 12, 2, 32, 211, 217, 63, 146, 37, 246, 218, 65, 3, 210, 191, 226, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 118, 100, 169, 4, 173, 8, 44, 248, 184, 40, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130\n\t\t\t]);\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.wrap(buffer)), undefined, { binaryTest: 'true' });\n\n\t\t\tconst backup = await service.resolve(toUntypedWorkingCopyId(fooFile));\n\t\t\tassert.ok(backup);\n\n\t\t\tconst backupBuffer = await consumeStream(backup.value, chunks => VSBuffer.concat(chunks));\n\t\t\tassert.strictEqual(backupBuffer.buffer.byteLength, buffer.byteLength);\n\t\t});\n\t});\n\n\tsuite('WorkingCopyBackupsModel', () => {\n\n\t\ttest('simple', async () => {\n\t\t\tconst model = await WorkingCopyBackupsModel.create(workspaceBackupPath, service.testGetFileService());\n\n\t\t\tconst resource1 = URI.file('test.html');\n\n\t\t\tassert.strictEqual(model.has(resource1), false);\n\n\t\t\tmodel.add(resource1);\n\n\t\t\tassert.strictEqual(model.has(resource1), true);\n\t\t\tassert.strictEqual(model.has(resource1, 0), true);\n\t\t\tassert.strictEqual(model.has(resource1, 1), false);\n\t\t\tassert.strictEqual(model.has(resource1, 1, { foo: 'bar' }), false);\n\n\t\t\tmodel.remove(resource1);\n\n\t\t\tassert.strictEqual(model.has(resource1), false);\n\n\t\t\tmodel.add(resource1);\n\n\t\t\tassert.strictEqual(model.has(resource1), true);\n\t\t\tassert.strictEqual(model.has(resource1, 0), true);\n\t\t\tassert.strictEqual(model.has(resource1, 1), false);\n\n\t\t\tmodel.clear();\n\n\t\t\tassert.strictEqual(model.has(resource1), false);\n\n\t\t\tmodel.add(resource1, 1);\n\n\t\t\tassert.strictEqual(model.has(resource1), true);\n\t\t\tassert.strictEqual(model.has(resource1, 0), false);\n\t\t\tassert.strictEqual(model.has(resource1, 1), true);\n\n\t\t\tconst resource2 = URI.file('test1.html');\n\t\t\tconst resource3 = URI.file('test2.html');\n\t\t\tconst resource4 = URI.file('test3.html');\n\n\t\t\tmodel.add(resource2);\n\t\t\tmodel.add(resource3);\n\t\t\tmodel.add(resource4, undefined, { foo: 'bar' });\n\n\t\t\tassert.strictEqual(model.has(resource1), true);\n\t\t\tassert.strictEqual(model.has(resource2), true);\n\t\t\tassert.strictEqual(model.has(resource3), true);\n\n\t\t\tassert.strictEqual(model.has(resource4), true);\n\t\t\tassert.strictEqual(model.has(resource4, undefined, { foo: 'bar' }), true);\n\t\t\tassert.strictEqual(model.has(resource4, undefined, { bar: 'foo' }), false);\n\n\t\t\tmodel.update(resource4, { foo: 'nothing' });\n\t\t\tassert.strictEqual(model.has(resource4, undefined, { foo: 'nothing' }), true);\n\t\t\tassert.strictEqual(model.has(resource4, undefined, { foo: 'bar' }), false);\n\n\t\t\tmodel.update(resource4);\n\t\t\tassert.strictEqual(model.has(resource4), true);\n\t\t\tassert.strictEqual(model.has(resource4, undefined, { foo: 'nothing' }), false);\n\t\t});\n\n\t\ttest('create', async () => {\n\t\t\tconst fooBackupPath = joinPath(workspaceBackupPath, fooFile.scheme, hashIdentifier(toUntypedWorkingCopyId(fooFile)));\n\t\t\tawait fileService.createFolder(dirname(fooBackupPath));\n\t\t\tawait fileService.writeFile(fooBackupPath, VSBuffer.fromString('foo'));\n\t\t\tconst model = await WorkingCopyBackupsModel.create(workspaceBackupPath, service.testGetFileService());\n\n\t\t\tassert.strictEqual(model.has(fooBackupPath), true);\n\t\t});\n\n\t\ttest('get', async () => {\n\t\t\tconst model = await WorkingCopyBackupsModel.create(workspaceBackupPath, service.testGetFileService());\n\n\t\t\tassert.deepStrictEqual(model.get(), []);\n\n\t\t\tconst file1 = URI.file('/root/file/foo.html');\n\t\t\tconst file2 = URI.file('/root/file/bar.html');\n\t\t\tconst untitled = URI.file('/root/untitled/bar.html');\n\n\t\t\tmodel.add(file1);\n\t\t\tmodel.add(file2);\n\t\t\tmodel.add(untitled);\n\n\t\t\tassert.deepStrictEqual(model.get().map(f => f.fsPath), [file1.fsPath, file2.fsPath, untitled.fsPath]);\n\t\t});\n\t});\n\n\tsuite('typeId migration', () => {\n\n\t\ttest('works (when meta is missing)', async () => {\n\t\t\tconst fooBackupId = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst untitledBackupId = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst customBackupId = toUntypedWorkingCopyId(customFile);\n\n\t\t\tconst fooBackupPath = joinPath(workspaceBackupPath, fooFile.scheme, hashIdentifier(fooBackupId));\n\t\t\tconst untitledBackupPath = joinPath(workspaceBackupPath, untitledFile.scheme, hashIdentifier(untitledBackupId));\n\t\t\tconst customFileBackupPath = joinPath(workspaceBackupPath, customFile.scheme, hashIdentifier(customBackupId));\n\n\t\t\t// Prepare backups of the old format without meta\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, fooFile.scheme));\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, untitledFile.scheme));\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, customFile.scheme));\n\t\t\tawait fileService.writeFile(fooBackupPath, VSBuffer.fromString(`${fooFile.toString()}\\ntest file`));\n\t\t\tawait fileService.writeFile(untitledBackupPath, VSBuffer.fromString(`${untitledFile.toString()}\\ntest untitled`));\n\t\t\tawait fileService.writeFile(customFileBackupPath, VSBuffer.fromString(`${customFile.toString()}\\ntest custom`));\n\n\t\t\tservice.reinitialize(workspaceBackupPath);\n\n\t\t\tconst backups = await service.getBackups();\n\t\t\tassert.strictEqual(backups.length, 3);\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, fooFile)));\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, untitledFile)));\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, customFile)));\n\t\t\tassert.ok(backups.every(backup => backup.typeId === ''));\n\t\t});\n\n\t\ttest('works (when typeId in meta is missing)', async () => {\n\t\t\tconst fooBackupId = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst untitledBackupId = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst customBackupId = toUntypedWorkingCopyId(customFile);\n\n\t\t\tconst fooBackupPath = joinPath(workspaceBackupPath, fooFile.scheme, hashIdentifier(fooBackupId));\n\t\t\tconst untitledBackupPath = joinPath(workspaceBackupPath, untitledFile.scheme, hashIdentifier(untitledBackupId));\n\t\t\tconst customFileBackupPath = joinPath(workspaceBackupPath, customFile.scheme, hashIdentifier(customBackupId));\n\n\t\t\t// Prepare backups of the old format without meta\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, fooFile.scheme));\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, untitledFile.scheme));\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, customFile.scheme));\n\t\t\tawait fileService.writeFile(fooBackupPath, VSBuffer.fromString(`${fooFile.toString()} ${JSON.stringify({ foo: 'bar' })}\\ntest file`));\n\t\t\tawait fileService.writeFile(untitledBackupPath, VSBuffer.fromString(`${untitledFile.toString()} ${JSON.stringify({ foo: 'bar' })}\\ntest untitled`));\n\t\t\tawait fileService.writeFile(customFileBackupPath, VSBuffer.fromString(`${customFile.toString()} ${JSON.stringify({ foo: 'bar' })}\\ntest custom`));\n\n\t\t\tservice.reinitialize(workspaceBackupPath);\n\n\t\t\tconst backups = await service.getBackups();\n\t\t\tassert.strictEqual(backups.length, 3);\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, fooFile)));\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, untitledFile)));\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, customFile)));\n\t\t\tassert.ok(backups.every(backup => backup.typeId === ''));\n\t\t});\n\t});\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { isWindows } from '../../../../../base/common/platform.js';\nimport { insert } from '../../../../../base/common/arrays.js';\nimport { hash } from '../../../../../base/common/hash.js';\nimport { isEqual, joinPath, dirname } from '../../../../../base/common/resources.js';\nimport { join } from '../../../../../base/common/path.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { WorkingCopyBackupsModel, hashIdentifier } from '../../common/workingCopyBackupService.js';\nimport { createTextModel } from '../../../../../editor/test/common/testTextModel.js';\nimport { Schemas } from '../../../../../base/common/network.js';\nimport { FileService } from '../../../../../platform/files/common/fileService.js';\nimport { LogLevel, NullLogService } from '../../../../../platform/log/common/log.js';\nimport { NativeWorkbenchEnvironmentService } from '../../../environment/electron-browser/environmentService.js';\nimport { toBufferOrReadable } from '../../../textfile/common/textfiles.js';\nimport { IFileService } from '../../../../../platform/files/common/files.js';\nimport { NativeWorkingCopyBackupService } from '../../electron-browser/workingCopyBackupService.js';\nimport { FileUserDataProvider } from '../../../../../platform/userData/common/fileUserDataProvider.js';\nimport { bufferToReadable, bufferToStream, streamToBuffer, VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../../base/common/buffer.js';\nimport { TestLifecycleService, toTypedWorkingCopyId, toUntypedWorkingCopyId } from '../../../../test/browser/workbenchTestServices.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { IWorkingCopyBackupMeta, IWorkingCopyIdentifier } from '../../common/workingCopy.js';\nimport { consumeStream } from '../../../../../base/common/stream.js';\nimport { TestProductService } from '../../../../test/common/workbenchTestServices.js';\nimport { InMemoryFileSystemProvider } from '../../../../../platform/files/common/inMemoryFilesystemProvider.js';\nimport { generateUuid } from '../../../../../base/common/uuid.js';\nimport { INativeWindowConfiguration } from '../../../../../platform/window/common/window.js';\nimport product from '../../../../../platform/product/common/product.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';\nimport { DisposableStore } from '../../../../../base/common/lifecycle.js';\nimport { UserDataProfilesService } from '../../../../../platform/userDataProfile/common/userDataProfile.js';\nimport { UriIdentityService } from '../../../../../platform/uriIdentity/common/uriIdentityService.js';\n\nconst homeDir = URI.file('home').with({ scheme: Schemas.inMemory });\nconst tmpDir = URI.file('tmp').with({ scheme: Schemas.inMemory });\nconst NULL_PROFILE = {\n\tname: '',\n\tid: '',\n\tshortName: '',\n\tisDefault: false,\n\tlocation: homeDir,\n\tsettingsResource: joinPath(homeDir, 'settings.json'),\n\tglobalStorageHome: joinPath(homeDir, 'globalStorage'),\n\tkeybindingsResource: joinPath(homeDir, 'keybindings.json'),\n\ttasksResource: joinPath(homeDir, 'tasks.json'),\n\tmcpResource: joinPath(homeDir, 'mcp.json'),\n\tsnippetsHome: joinPath(homeDir, 'snippets'),\n\tpromptsHome: joinPath(homeDir, 'prompts'),\n\textensionsResource: joinPath(homeDir, 'extensions.json'),\n\tcacheHome: joinPath(homeDir, 'cache')\n};\n\nconst TestNativeWindowConfiguration: INativeWindowConfiguration = {\n\twindowId: 0,\n\tmachineId: 'testMachineId',\n\tsqmId: 'testSqmId',\n\tdevDeviceId: 'testdevDeviceId',\n\tlogLevel: LogLevel.Error,\n\tloggers: [],\n\tmainPid: 0,\n\tappRoot: '',\n\tuserEnv: {},\n\texecPath: process.execPath,\n\tperfMarks: [],\n\tcolorScheme: { dark: true, highContrast: false },\n\tos: { release: 'unknown', hostname: 'unknown', arch: 'unknown' },\n\tproduct,\n\thomeDir: homeDir.fsPath,\n\ttmpDir: tmpDir.fsPath,\n\tuserDataDir: joinPath(homeDir, product.nameShort).fsPath,\n\tprofiles: { profile: NULL_PROFILE, all: [NULL_PROFILE], home: homeDir },\n\tnls: {\n\t\tmessages: [],\n\t\tlanguage: 'en'\n\t},\n\t_: []\n};\n\nexport class TestNativeWorkbenchEnvironmentService extends NativeWorkbenchEnvironmentService {\n\n\tconstructor(testDir: URI, backupPath: URI) {\n\t\tsuper({ ...TestNativeWindowConfiguration, backupPath: backupPath.fsPath, 'user-data-dir': testDir.fsPath }, TestProductService);\n\t}\n}\n\nexport class NodeTestWorkingCopyBackupService extends NativeWorkingCopyBackupService {\n\n\tprivate backupResourceJoiners: Function[];\n\tprivate discardBackupJoiners: Function[];\n\tdiscardedBackups: IWorkingCopyIdentifier[];\n\tdiscardedAllBackups: boolean;\n\tprivate pendingBackupsArr: Promise<void>[];\n\n\treadonly _fileService: IFileService;\n\n\tconstructor(testDir: URI, workspaceBackupPath: URI) {\n\t\tconst environmentService = new TestNativeWorkbenchEnvironmentService(testDir, workspaceBackupPath);\n\t\tconst logService = new NullLogService();\n\t\tconst fileService = new FileService(logService);\n\t\tconst lifecycleService = new TestLifecycleService();\n\t\tsuper(environmentService, fileService, logService, lifecycleService);\n\n\t\tconst fsp = new InMemoryFileSystemProvider();\n\t\tfileService.registerProvider(Schemas.inMemory, fsp);\n\t\tconst uriIdentityService = new UriIdentityService(fileService);\n\t\tconst userDataProfilesService = new UserDataProfilesService(environmentService, fileService, uriIdentityService, logService);\n\t\tfileService.registerProvider(Schemas.vscodeUserData, new FileUserDataProvider(Schemas.file, fsp, Schemas.vscodeUserData, userDataProfilesService, uriIdentityService, logService));\n\n\t\tthis._fileService = fileService;\n\n\t\tthis.backupResourceJoiners = [];\n\t\tthis.discardBackupJoiners = [];\n\t\tthis.discardedBackups = [];\n\t\tthis.pendingBackupsArr = [];\n\t\tthis.discardedAllBackups = false;\n\t}\n\n\ttestGetFileService(): IFileService {\n\t\treturn this.fileService;\n\t}\n\n\tasync waitForAllBackups(): Promise<void> {\n\t\tawait Promise.all(this.pendingBackupsArr);\n\t}\n\n\tjoinBackupResource(): Promise<void> {\n\t\treturn new Promise(resolve => this.backupResourceJoiners.push(resolve));\n\t}\n\n\toverride async backup(identifier: IWorkingCopyIdentifier, content?: VSBufferReadableStream | VSBufferReadable, versionId?: number, meta?: any, token?: CancellationToken): Promise<void> {\n\t\tconst p = super.backup(identifier, content, versionId, meta, token);\n\t\tconst removeFromPendingBackups = insert(this.pendingBackupsArr, p.then(undefined, undefined));\n\n\t\ttry {\n\t\t\tawait p;\n\t\t} finally {\n\t\t\tremoveFromPendingBackups();\n\t\t}\n\n\t\twhile (this.backupResourceJoiners.length) {\n\t\t\tthis.backupResourceJoiners.pop()!();\n\t\t}\n\t}\n\n\tjoinDiscardBackup(): Promise<void> {\n\t\treturn new Promise(resolve => this.discardBackupJoiners.push(resolve));\n\t}\n\n\toverride async discardBackup(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\tawait super.discardBackup(identifier);\n\t\tthis.discardedBackups.push(identifier);\n\n\t\twhile (this.discardBackupJoiners.length) {\n\t\t\tthis.discardBackupJoiners.pop()!();\n\t\t}\n\t}\n\n\toverride async discardBackups(filter?: { except: IWorkingCopyIdentifier[] }): Promise<void> {\n\t\tthis.discardedAllBackups = true;\n\n\t\treturn super.discardBackups(filter);\n\t}\n\n\tasync getBackupContents(identifier: IWorkingCopyIdentifier): Promise<string> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\tconst fileContents = await this.fileService.readFile(backupResource);\n\n\t\treturn fileContents.value.toString();\n\t}\n}\n\nsuite('WorkingCopyBackupService', () => {\n\n\tlet testDir: URI;\n\tlet backupHome: URI;\n\tlet workspacesJsonPath: URI;\n\tlet workspaceBackupPath: URI;\n\n\tlet service: NodeTestWorkingCopyBackupService;\n\tlet fileService: IFileService;\n\n\tconst disposables = new DisposableStore();\n\n\tconst workspaceResource = URI.file(isWindows ? 'c:\\\\workspace' : '/workspace');\n\tconst fooFile = URI.file(isWindows ? 'c:\\\\Foo' : '/Foo');\n\tconst customFile = URI.parse('customScheme://some/path');\n\tconst customFileWithFragment = URI.parse('customScheme2://some/path#fragment');\n\tconst barFile = URI.file(isWindows ? 'c:\\\\Bar' : '/Bar');\n\tconst fooBarFile = URI.file(isWindows ? 'c:\\\\Foo Bar' : '/Foo Bar');\n\tconst untitledFile = URI.from({ scheme: Schemas.untitled, path: 'Untitled-1' });\n\n\tsetup(async () => {\n\t\ttestDir = URI.file(join(generateUuid(), 'vsctests', 'workingcopybackupservice')).with({ scheme: Schemas.inMemory });\n\t\tbackupHome = joinPath(testDir, 'Backups');\n\t\tworkspacesJsonPath = joinPath(backupHome, 'workspaces.json');\n\t\tworkspaceBackupPath = joinPath(backupHome, hash(workspaceResource.fsPath).toString(16));\n\n\t\tservice = disposables.add(new NodeTestWorkingCopyBackupService(testDir, workspaceBackupPath));\n\t\tfileService = service._fileService;\n\n\t\tawait fileService.createFolder(backupHome);\n\n\t\treturn fileService.writeFile(workspacesJsonPath, VSBuffer.fromString(''));\n\t});\n\n\tteardown(() => {\n\t\tdisposables.clear();\n\t});\n\n\tsuite('hashIdentifier', () => {\n\t\ttest('should correctly hash the identifier for untitled scheme URIs', () => {\n\t\t\tconst uri = URI.from({ scheme: Schemas.untitled, path: 'Untitled-1' });\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes change people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tconst untypedBackupHash = hashIdentifier(toUntypedWorkingCopyId(uri));\n\t\t\tassert.strictEqual(untypedBackupHash, '-7f9c1a2e');\n\t\t\tassert.strictEqual(untypedBackupHash, hash(uri.fsPath).toString(16));\n\n\t\t\tconst typedBackupHash = hashIdentifier({ typeId: 'hashTest', resource: uri });\n\t\t\tif (isWindows) {\n\t\t\t\tassert.strictEqual(typedBackupHash, '-17c47cdc');\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(typedBackupHash, '-8ad5f4f');\n\t\t\t}\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes collide people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tassert.notStrictEqual(untypedBackupHash, typedBackupHash);\n\t\t});\n\n\t\ttest('should correctly hash the identifier for file scheme URIs', () => {\n\t\t\tconst uri = URI.file('/foo');\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes change people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tconst untypedBackupHash = hashIdentifier(toUntypedWorkingCopyId(uri));\n\t\t\tif (isWindows) {\n\t\t\t\tassert.strictEqual(untypedBackupHash, '20ffaa13');\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(untypedBackupHash, '20eb3560');\n\t\t\t}\n\t\t\tassert.strictEqual(untypedBackupHash, hash(uri.fsPath).toString(16));\n\n\t\t\tconst typedBackupHash = hashIdentifier({ typeId: 'hashTest', resource: uri });\n\t\t\tif (isWindows) {\n\t\t\t\tassert.strictEqual(typedBackupHash, '-55fc55db');\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(typedBackupHash, '51e56bf');\n\t\t\t}\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes collide people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tassert.notStrictEqual(untypedBackupHash, typedBackupHash);\n\t\t});\n\n\t\ttest('should correctly hash the identifier for custom scheme URIs', () => {\n\t\t\tconst uri = URI.from({\n\t\t\t\tscheme: 'vscode-custom',\n\t\t\t\tpath: 'somePath'\n\t\t\t});\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes change people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tconst untypedBackupHash = hashIdentifier(toUntypedWorkingCopyId(uri));\n\t\t\tassert.strictEqual(untypedBackupHash, '-44972d98');\n\t\t\tassert.strictEqual(untypedBackupHash, hash(uri.toString()).toString(16));\n\n\t\t\tconst typedBackupHash = hashIdentifier({ typeId: 'hashTest', resource: uri });\n\t\t\tassert.strictEqual(typedBackupHash, '502149c7');\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes collide people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tassert.notStrictEqual(untypedBackupHash, typedBackupHash);\n\t\t});\n\n\t\ttest('should not fail for URIs without path', () => {\n\t\t\tconst uri = URI.from({\n\t\t\t\tscheme: 'vscode-fragment',\n\t\t\t\tfragment: 'frag'\n\t\t\t});\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes change people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tconst untypedBackupHash = hashIdentifier(toUntypedWorkingCopyId(uri));\n\t\t\tassert.strictEqual(untypedBackupHash, '-2f6b2f1b');\n\t\t\tassert.strictEqual(untypedBackupHash, hash(uri.toString()).toString(16));\n\n\t\t\tconst typedBackupHash = hashIdentifier({ typeId: 'hashTest', resource: uri });\n\t\t\tassert.strictEqual(typedBackupHash, '6e82ca57');\n\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\t// If these hashes collide people will lose their backed up files\n\t\t\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t\t\tassert.notStrictEqual(untypedBackupHash, typedBackupHash);\n\t\t});\n\t});\n\n\tsuite('getBackupResource', () => {\n\t\ttest('should get the correct backup path for text files', () => {\n\n\t\t\t// Format should be: <backupHome>/<workspaceHash>/<scheme>/<filePathHash>\n\t\t\tconst backupResource = fooFile;\n\t\t\tconst workspaceHash = hash(workspaceResource.fsPath).toString(16);\n\n\t\t\t// No Type ID\n\t\t\tlet backupId = toUntypedWorkingCopyId(backupResource);\n\t\t\tlet filePathHash = hashIdentifier(backupId);\n\t\t\tlet expectedPath = joinPath(backupHome, workspaceHash, Schemas.file, filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\n\t\t\t// With Type ID\n\t\t\tbackupId = toTypedWorkingCopyId(backupResource);\n\t\t\tfilePathHash = hashIdentifier(backupId);\n\t\t\texpectedPath = joinPath(backupHome, workspaceHash, Schemas.file, filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\t\t});\n\n\t\ttest('should get the correct backup path for untitled files', () => {\n\n\t\t\t// Format should be: <backupHome>/<workspaceHash>/<scheme>/<filePathHash>\n\t\t\tconst backupResource = URI.from({ scheme: Schemas.untitled, path: 'Untitled-1' });\n\t\t\tconst workspaceHash = hash(workspaceResource.fsPath).toString(16);\n\n\t\t\t// No Type ID\n\t\t\tlet backupId = toUntypedWorkingCopyId(backupResource);\n\t\t\tlet filePathHash = hashIdentifier(backupId);\n\t\t\tlet expectedPath = joinPath(backupHome, workspaceHash, Schemas.untitled, filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\n\t\t\t// With Type ID\n\t\t\tbackupId = toTypedWorkingCopyId(backupResource);\n\t\t\tfilePathHash = hashIdentifier(backupId);\n\t\t\texpectedPath = joinPath(backupHome, workspaceHash, Schemas.untitled, filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\t\t});\n\n\t\ttest('should get the correct backup path for custom files', () => {\n\n\t\t\t// Format should be: <backupHome>/<workspaceHash>/<scheme>/<filePathHash>\n\t\t\tconst backupResource = URI.from({ scheme: 'custom', path: 'custom/file.txt' });\n\t\t\tconst workspaceHash = hash(workspaceResource.fsPath).toString(16);\n\n\t\t\t// No Type ID\n\t\t\tlet backupId = toUntypedWorkingCopyId(backupResource);\n\t\t\tlet filePathHash = hashIdentifier(backupId);\n\t\t\tlet expectedPath = joinPath(backupHome, workspaceHash, 'custom', filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\n\t\t\t// With Type ID\n\t\t\tbackupId = toTypedWorkingCopyId(backupResource);\n\t\t\tfilePathHash = hashIdentifier(backupId);\n\t\t\texpectedPath = joinPath(backupHome, workspaceHash, 'custom', filePathHash).with({ scheme: Schemas.vscodeUserData }).toString();\n\t\t\tassert.strictEqual(service.toBackupResource(backupId).toString(), expectedPath);\n\t\t});\n\t});\n\n\tsuite('backup', () => {\n\n\t\tfunction toExpectedPreamble(identifier: IWorkingCopyIdentifier, content = '', meta?: object): string {\n\t\t\treturn `${identifier.resource.toString()} ${JSON.stringify({ ...meta, typeId: identifier.typeId })}\\n${content}`;\n\t\t}\n\n\t\ttest('joining', async () => {\n\t\t\tlet backupJoined = false;\n\t\t\tconst joinBackupsPromise = service.joinBackups();\n\t\t\tjoinBackupsPromise.then(() => backupJoined = true);\n\t\t\tawait joinBackupsPromise;\n\t\t\tassert.strictEqual(backupJoined, true);\n\n\t\t\tbackupJoined = false;\n\t\t\tservice.joinBackups().then(() => backupJoined = true);\n\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tconst backupPromise = service.backup(identifier);\n\t\t\tassert.strictEqual(backupJoined, false);\n\t\t\tawait backupPromise;\n\t\t\tassert.strictEqual(backupJoined, true);\n\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('no text', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test'));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file (with version)', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')), 666);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test'));\n\t\t\tassert.ok(!service.hasBackupSync(identifier, 555));\n\t\t\tassert.ok(service.hasBackupSync(identifier, 666));\n\t\t});\n\n\t\ttest('text file (with meta)', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst meta = { etag: '678', orphaned: true };\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')), undefined, meta);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test', meta));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file with whitespace in name and type (with meta)', async () => {\n\t\t\tconst fileWithSpace = URI.file(isWindows ? 'c:\\\\Foo \\n Bar' : '/Foo \\n Bar');\n\t\t\tconst identifier = toTypedWorkingCopyId(fileWithSpace, ' test id \\n');\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst meta = { etag: '678 \\n k', orphaned: true };\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')), undefined, meta);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test', meta));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file with unicode character in name and type (with meta)', async () => {\n\t\t\tconst fileWithUnicode = URI.file(isWindows ? 'c:\\\\some' : '/some');\n\t\t\tconst identifier = toTypedWorkingCopyId(fileWithUnicode, ' test some id \\n');\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst meta = { etag: '678some', orphaned: true };\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')), undefined, meta);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test', meta));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('untitled file', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test'));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file (readable)', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst model = createTextModel('test');\n\n\t\t\tawait service.backup(identifier, toBufferOrReadable(model.createSnapshot()));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test'));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\n\t\t\tmodel.dispose();\n\t\t});\n\n\t\ttest('untitled file (readable)', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst model = createTextModel('test');\n\n\t\t\tawait service.backup(identifier, toBufferOrReadable(model.createSnapshot()));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, 'test'));\n\n\t\t\tmodel.dispose();\n\t\t});\n\n\t\ttest('text file (large file, stream)', () => {\n\t\t\tconst largeString = (new Array(30 * 1024)).join('Large String\\n');\n\n\t\t\treturn testLargeTextFile(largeString, bufferToStream(VSBuffer.fromString(largeString)));\n\t\t});\n\n\t\ttest('text file (large file, readable)', async () => {\n\t\t\tconst largeString = (new Array(30 * 1024)).join('Large String\\n');\n\t\t\tconst model = createTextModel(largeString);\n\n\t\t\tawait testLargeTextFile(largeString, toBufferOrReadable(model.createSnapshot()));\n\n\t\t\tmodel.dispose();\n\t\t});\n\n\t\tasync function testLargeTextFile(largeString: string, buffer: VSBufferReadable | VSBufferReadableStream) {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, buffer, undefined, { largeTest: true });\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, largeString, { largeTest: true }));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t}\n\n\t\ttest('untitled file (large file, readable)', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\t\t\tconst largeString = (new Array(30 * 1024)).join('Large String\\n');\n\t\t\tconst model = createTextModel(largeString);\n\n\t\t\tawait service.backup(identifier, toBufferOrReadable(model.createSnapshot()));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier, largeString));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\n\t\t\tmodel.dispose();\n\t\t});\n\n\t\ttest('cancellation', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tconst cts = new CancellationTokenSource();\n\t\t\tconst promise = service.backup(identifier, undefined, undefined, undefined, cts.token);\n\t\t\tcts.cancel();\n\t\t\tawait promise;\n\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\tassert.ok(!service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('multiple', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait Promise.all([\n\t\t\t\tservice.backup(identifier),\n\t\t\t\tservice.backup(identifier),\n\t\t\t\tservice.backup(identifier),\n\t\t\t\tservice.backup(identifier)\n\t\t\t]);\n\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.readFile(backupPath)).value.toString(), toExpectedPreamble(identifier));\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('multiple same resource, different type id', async () => {\n\t\t\tconst backupId1 = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupId2 = toTypedWorkingCopyId(fooFile, 'type1');\n\t\t\tconst backupId3 = toTypedWorkingCopyId(fooFile, 'type2');\n\n\t\t\tawait Promise.all([\n\t\t\t\tservice.backup(backupId1),\n\t\t\t\tservice.backup(backupId2),\n\t\t\t\tservice.backup(backupId3)\n\t\t\t]);\n\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 3);\n\n\t\t\tfor (const backupId of [backupId1, backupId2, backupId3]) {\n\t\t\t\tconst fooBackupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\t\t\t\tassert.strictEqual((await fileService.exists(fooBackupPath)), true);\n\t\t\t\tassert.strictEqual((await fileService.readFile(fooBackupPath)).value.toString(), toExpectedPreamble(backupId));\n\t\t\t\tassert.ok(service.hasBackupSync(backupId));\n\t\t\t}\n\t\t});\n\t});\n\n\tsuite('discardBackup', () => {\n\n\t\ttest('joining', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\n\t\t\tlet backupJoined = false;\n\t\t\tservice.joinBackups().then(() => backupJoined = true);\n\n\t\t\tconst discardBackupPromise = service.discardBackup(identifier);\n\t\t\tassert.strictEqual(backupJoined, false);\n\t\t\tawait discardBackupPromise;\n\t\t\tassert.strictEqual(backupJoined, true);\n\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 0);\n\t\t\tassert.ok(!service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('text file', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\t\t\tassert.ok(service.hasBackupSync(identifier));\n\n\t\t\tawait service.discardBackup(identifier);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 0);\n\t\t\tassert.ok(!service.hasBackupSync(identifier));\n\t\t});\n\n\t\ttest('untitled file', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\n\t\t\tawait service.discardBackup(identifier);\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 0);\n\t\t});\n\n\t\ttest('multiple same resource, different type id', async () => {\n\t\t\tconst backupId1 = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupId2 = toTypedWorkingCopyId(fooFile, 'type1');\n\t\t\tconst backupId3 = toTypedWorkingCopyId(fooFile, 'type2');\n\n\t\t\tawait Promise.all([\n\t\t\t\tservice.backup(backupId1),\n\t\t\t\tservice.backup(backupId2),\n\t\t\t\tservice.backup(backupId3)\n\t\t\t]);\n\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 3);\n\n\t\t\tfor (const backupId of [backupId1, backupId2, backupId3]) {\n\t\t\t\tconst backupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\t\t\t\tawait service.discardBackup(backupId);\n\t\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\t}\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 0);\n\t\t});\n\t});\n\n\tsuite('discardBackups (all)', () => {\n\t\ttest('text file', async () => {\n\t\t\tconst backupId1 = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupId2 = toUntypedWorkingCopyId(barFile);\n\t\t\tconst backupId3 = toTypedWorkingCopyId(barFile);\n\n\t\t\tawait service.backup(backupId1, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\n\t\t\tawait service.backup(backupId2, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 2);\n\n\t\t\tawait service.backup(backupId3, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 3);\n\n\t\t\tawait service.discardBackups();\n\t\t\tfor (const backupId of [backupId1, backupId2, backupId3]) {\n\t\t\t\tconst backupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\t\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\t}\n\n\t\t\tassert.strictEqual((await fileService.exists(joinPath(workspaceBackupPath, 'file'))), false);\n\t\t});\n\n\t\ttest('untitled file', async () => {\n\t\t\tconst backupId = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\n\t\t\tawait service.backup(backupId, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\n\t\t\tawait service.discardBackups();\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\tassert.strictEqual((await fileService.exists(joinPath(workspaceBackupPath, 'untitled'))), false);\n\t\t});\n\n\t\ttest('can backup after discarding all', async () => {\n\t\t\tawait service.discardBackups();\n\t\t\tawait service.backup(toUntypedWorkingCopyId(untitledFile), bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.exists(workspaceBackupPath)), true);\n\t\t});\n\t});\n\n\tsuite('discardBackups (except some)', () => {\n\t\ttest('text file', async () => {\n\t\t\tconst backupId1 = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst backupId2 = toUntypedWorkingCopyId(barFile);\n\t\t\tconst backupId3 = toTypedWorkingCopyId(barFile);\n\n\t\t\tawait service.backup(backupId1, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 1);\n\n\t\t\tawait service.backup(backupId2, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 2);\n\n\t\t\tawait service.backup(backupId3, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'file'))).children?.length, 3);\n\n\t\t\tawait service.discardBackups({ except: [backupId2, backupId3] });\n\n\t\t\tlet backupPath = joinPath(workspaceBackupPath, backupId1.resource.scheme, hashIdentifier(backupId1));\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\n\t\t\tbackupPath = joinPath(workspaceBackupPath, backupId2.resource.scheme, hashIdentifier(backupId2));\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\n\t\t\tbackupPath = joinPath(workspaceBackupPath, backupId3.resource.scheme, hashIdentifier(backupId3));\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\n\t\t\tawait service.discardBackups({ except: [backupId1] });\n\n\t\t\tfor (const backupId of [backupId1, backupId2, backupId3]) {\n\t\t\t\tconst backupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\t\t\t\tassert.strictEqual((await fileService.exists(backupPath)), false);\n\t\t\t}\n\t\t});\n\n\t\ttest('untitled file', async () => {\n\t\t\tconst backupId = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, backupId.resource.scheme, hashIdentifier(backupId));\n\n\t\t\tawait service.backup(backupId, bufferToReadable(VSBuffer.fromString('test')));\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t\tassert.strictEqual((await fileService.resolve(joinPath(workspaceBackupPath, 'untitled'))).children?.length, 1);\n\n\t\t\tawait service.discardBackups({ except: [backupId] });\n\t\t\tassert.strictEqual((await fileService.exists(backupPath)), true);\n\t\t});\n\t});\n\n\tsuite('getBackups', () => {\n\t\ttest('text file', async () => {\n\t\t\tawait Promise.all([\n\t\t\t\tservice.backup(toUntypedWorkingCopyId(fooFile), bufferToReadable(VSBuffer.fromString('test'))),\n\t\t\t\tservice.backup(toTypedWorkingCopyId(fooFile, 'type1'), bufferToReadable(VSBuffer.fromString('test'))),\n\t\t\t\tservice.backup(toTypedWorkingCopyId(fooFile, 'type2'), bufferToReadable(VSBuffer.fromString('test')))\n\t\t\t]);\n\n\t\t\tlet backups = await service.getBackups();\n\t\t\tassert.strictEqual(backups.length, 3);\n\n\t\t\tfor (const backup of backups) {\n\t\t\t\tif (backup.typeId === '') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), fooFile.toString());\n\t\t\t\t} else if (backup.typeId === 'type1') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), fooFile.toString());\n\t\t\t\t} else if (backup.typeId === 'type2') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), fooFile.toString());\n\t\t\t\t} else {\n\t\t\t\t\tassert.fail('Unexpected backup');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait service.backup(toUntypedWorkingCopyId(barFile), bufferToReadable(VSBuffer.fromString('test')));\n\n\t\t\tbackups = await service.getBackups();\n\t\t\tassert.strictEqual(backups.length, 4);\n\t\t});\n\n\t\ttest('untitled file', async () => {\n\t\t\tawait Promise.all([\n\t\t\t\tservice.backup(toUntypedWorkingCopyId(untitledFile), bufferToReadable(VSBuffer.fromString('test'))),\n\t\t\t\tservice.backup(toTypedWorkingCopyId(untitledFile, 'type1'), bufferToReadable(VSBuffer.fromString('test'))),\n\t\t\t\tservice.backup(toTypedWorkingCopyId(untitledFile, 'type2'), bufferToReadable(VSBuffer.fromString('test')))\n\t\t\t]);\n\n\t\t\tconst backups = await service.getBackups();\n\t\t\tassert.strictEqual(backups.length, 3);\n\n\t\t\tfor (const backup of backups) {\n\t\t\t\tif (backup.typeId === '') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), untitledFile.toString());\n\t\t\t\t} else if (backup.typeId === 'type1') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), untitledFile.toString());\n\t\t\t\t} else if (backup.typeId === 'type2') {\n\t\t\t\t\tassert.strictEqual(backup.resource.toString(), untitledFile.toString());\n\t\t\t\t} else {\n\t\t\t\t\tassert.fail('Unexpected backup');\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\tsuite('resolve', () => {\n\n\t\tinterface IBackupTestMetaData extends IWorkingCopyBackupMeta {\n\t\t\tmtime?: number;\n\t\t\tsize?: number;\n\t\t\tetag?: string;\n\t\t\torphaned?: boolean;\n\t\t}\n\n\t\ttest('should restore the original contents (untitled file)', async () => {\n\t\t\tconst contents = 'test\\nand more stuff';\n\n\t\t\tawait testResolveBackup(untitledFile, contents);\n\t\t});\n\n\t\ttest('should restore the original contents (untitled file with metadata)', async () => {\n\t\t\tconst contents = 'test\\nand more stuff';\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'the Etag',\n\t\t\t\tsize: 666,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: true\n\t\t\t};\n\n\t\t\tawait testResolveBackup(untitledFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (untitled file empty with metadata)', async () => {\n\t\t\tconst contents = '';\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'the Etag',\n\t\t\t\tsize: 666,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: true\n\t\t\t};\n\n\t\t\tawait testResolveBackup(untitledFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (untitled large file with metadata)', async () => {\n\t\t\tconst contents = (new Array(30 * 1024)).join('Large String\\n');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'the Etag',\n\t\t\t\tsize: 666,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: true\n\t\t\t};\n\n\t\t\tawait testResolveBackup(untitledFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (text file)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'consectetur ',\n\t\t\t\t'adipiscing  elit'\n\t\t\t].join('');\n\n\t\t\tawait testResolveBackup(fooFile, contents);\n\t\t});\n\n\t\ttest('should restore the original contents (text file - custom scheme)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'consectetur ',\n\t\t\t\t'adipiscing  elit'\n\t\t\t].join('');\n\n\t\t\tawait testResolveBackup(customFile, contents);\n\t\t});\n\n\t\ttest('should restore the original contents (text file with metadata)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (empty text file with metadata)', async () => {\n\t\t\tconst contents = '';\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (large text file with metadata)', async () => {\n\t\t\tconst contents = (new Array(30 * 1024)).join('Large String\\n');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (text file with metadata changed once)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooFile, contents, meta);\n\n\t\t\t// Change meta and test again\n\t\t\tmeta.size = 999;\n\t\t\tawait testResolveBackup(fooFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (text file with metadata and fragment URI)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(customFileWithFragment, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (text file with space in name with metadata)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooBarFile, contents, meta);\n\t\t});\n\n\t\ttest('should restore the original contents (text file with too large metadata to persist)', async () => {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: (new Array(100 * 1024)).join('Large String'),\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait testResolveBackup(fooFile, contents, meta, true);\n\t\t});\n\n\t\tasync function testResolveBackup(resource: URI, contents: string, meta?: IBackupTestMetaData, expectNoMeta?: boolean) {\n\t\t\tawait doTestResolveBackup(toUntypedWorkingCopyId(resource), contents, meta, expectNoMeta);\n\t\t\tawait doTestResolveBackup(toTypedWorkingCopyId(resource), contents, meta, expectNoMeta);\n\t\t}\n\n\t\tasync function doTestResolveBackup(identifier: IWorkingCopyIdentifier, contents: string, meta?: IBackupTestMetaData, expectNoMeta?: boolean) {\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString(contents)), 1, meta);\n\n\t\t\tconst backup = await service.resolve<IBackupTestMetaData>(identifier);\n\t\t\tassert.ok(backup);\n\t\t\tassert.strictEqual(contents, (await streamToBuffer(backup.value)).toString());\n\n\t\t\tif (expectNoMeta || !meta) {\n\t\t\t\tassert.strictEqual(backup.meta, undefined);\n\t\t\t} else {\n\t\t\t\tassert.ok(backup.meta);\n\t\t\t\tassert.strictEqual(backup.meta.etag, meta.etag);\n\t\t\t\tassert.strictEqual(backup.meta.size, meta.size);\n\t\t\t\tassert.strictEqual(backup.meta.mtime, meta.mtime);\n\t\t\t\tassert.strictEqual(backup.meta.orphaned, meta.orphaned);\n\n\t\t\t\tassert.strictEqual(Object.keys(meta).length, Object.keys(backup.meta).length);\n\t\t\t}\n\t\t}\n\n\t\ttest('should restore the original contents (text file with broken metadata)', async () => {\n\t\t\tawait testShouldRestoreOriginalContentsWithBrokenBackup(toUntypedWorkingCopyId(fooFile));\n\t\t\tawait testShouldRestoreOriginalContentsWithBrokenBackup(toTypedWorkingCopyId(fooFile));\n\t\t});\n\n\t\tasync function testShouldRestoreOriginalContentsWithBrokenBackup(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\t\tconst contents = [\n\t\t\t\t'Lorem ipsum ',\n\t\t\t\t'dolor  sit amet ',\n\t\t\t\t'adipiscing  elit',\n\t\t\t\t'consectetur '\n\t\t\t].join('');\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtag',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString(contents)), 1, meta);\n\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\tconst fileContents = (await fileService.readFile(backupPath)).value.toString();\n\t\t\tassert.strictEqual(fileContents.indexOf(identifier.resource.toString()), 0);\n\n\t\t\tconst metaIndex = fileContents.indexOf('{');\n\t\t\tconst newFileContents = fileContents.substring(0, metaIndex) + '{{' + fileContents.substr(metaIndex);\n\t\t\tawait fileService.writeFile(backupPath, VSBuffer.fromString(newFileContents));\n\n\t\t\tconst backup = await service.resolve(identifier);\n\t\t\tassert.ok(backup);\n\t\t\tassert.strictEqual(contents, (await streamToBuffer(backup.value)).toString());\n\t\t\tassert.strictEqual(backup.meta, undefined);\n\t\t}\n\n\t\ttest('should update metadata from file into model when resolving', async () => {\n\t\t\tawait testShouldUpdateMetaFromFileWhenResolving(toUntypedWorkingCopyId(fooFile));\n\t\t\tawait testShouldUpdateMetaFromFileWhenResolving(toTypedWorkingCopyId(fooFile));\n\t\t});\n\n\t\tasync function testShouldUpdateMetaFromFileWhenResolving(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\t\tconst contents = 'Foo Bar';\n\n\t\t\tconst meta = {\n\t\t\t\tetag: 'theEtagForThisMetadataTest',\n\t\t\t\tsize: 888,\n\t\t\t\tmtime: Date.now(),\n\t\t\t\torphaned: false\n\t\t\t};\n\n\t\t\tconst updatedMeta = {\n\t\t\t\t...meta,\n\t\t\t\tetag: meta.etag + meta.etag\n\t\t\t};\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.fromString(contents)), 1, meta);\n\n\t\t\tconst backupPath = joinPath(workspaceBackupPath, identifier.resource.scheme, hashIdentifier(identifier));\n\n\t\t\t// Simulate the condition of the backups model loading initially without\n\t\t\t// meta data information and then getting the meta data updated on the\n\t\t\t// first call to resolve the backup. We simulate this by explicitly changing\n\t\t\t// the meta data in the file and then verifying that the updated meta data\n\t\t\t// is persisted back into the model (verified via `hasBackupSync`).\n\t\t\t// This is not really something that would happen in real life because any\n\t\t\t// backup that is made via backup service will update the model accordingly.\n\n\t\t\tconst originalFileContents = (await fileService.readFile(backupPath)).value.toString();\n\t\t\tawait fileService.writeFile(backupPath, VSBuffer.fromString(originalFileContents.replace(meta.etag, updatedMeta.etag)));\n\n\t\t\tawait service.resolve(identifier);\n\n\t\t\tassert.strictEqual(service.hasBackupSync(identifier, undefined, meta), false);\n\t\t\tassert.strictEqual(service.hasBackupSync(identifier, undefined, updatedMeta), true);\n\n\t\t\tawait fileService.writeFile(backupPath, VSBuffer.fromString(originalFileContents));\n\n\t\t\tawait service.getBackups();\n\n\t\t\tassert.strictEqual(service.hasBackupSync(identifier, undefined, meta), true);\n\t\t\tassert.strictEqual(service.hasBackupSync(identifier, undefined, updatedMeta), false);\n\t\t}\n\n\t\ttest('should ignore invalid backups (empty file)', async () => {\n\t\t\tconst contents = 'test\\nand more stuff';\n\n\t\t\tawait service.backup(toUntypedWorkingCopyId(fooFile), bufferToReadable(VSBuffer.fromString(contents)), 1);\n\n\t\t\tlet backup = await service.resolve(toUntypedWorkingCopyId(fooFile));\n\t\t\tassert.ok(backup);\n\n\t\t\tawait service.testGetFileService().writeFile(service.toBackupResource(toUntypedWorkingCopyId(fooFile)), VSBuffer.fromString(''));\n\n\t\t\tbackup = await service.resolve<IBackupTestMetaData>(toUntypedWorkingCopyId(fooFile));\n\t\t\tassert.ok(!backup);\n\t\t});\n\n\t\ttest('should ignore invalid backups (no preamble)', async () => {\n\t\t\tconst contents = 'testand more stuff';\n\n\t\t\tawait service.backup(toUntypedWorkingCopyId(fooFile), bufferToReadable(VSBuffer.fromString(contents)), 1);\n\n\t\t\tlet backup = await service.resolve(toUntypedWorkingCopyId(fooFile));\n\t\t\tassert.ok(backup);\n\n\t\t\tawait service.testGetFileService().writeFile(service.toBackupResource(toUntypedWorkingCopyId(fooFile)), VSBuffer.fromString(contents));\n\n\t\t\tbackup = await service.resolve<IBackupTestMetaData>(toUntypedWorkingCopyId(fooFile));\n\t\t\tassert.ok(!backup);\n\t\t});\n\n\t\ttest('file with binary data', async () => {\n\t\t\tconst identifier = toUntypedWorkingCopyId(fooFile);\n\n\t\t\tconst buffer = Uint8Array.from([\n\t\t\t\t137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 73, 0, 0, 0, 67, 8, 2, 0, 0, 0, 95, 138, 191, 237, 0, 0, 0, 1, 115, 82, 71, 66, 0, 174, 206, 28, 233, 0, 0, 0, 4, 103, 65, 77, 65, 0, 0, 177, 143, 11, 252, 97, 5, 0, 0, 0, 9, 112, 72, 89, 115, 0, 0, 14, 195, 0, 0, 14, 195, 1, 199, 111, 168, 100, 0, 0, 0, 71, 116, 69, 88, 116, 83, 111, 117, 114, 99, 101, 0, 83, 104, 111, 116, 116, 121, 32, 118, 50, 46, 48, 46, 50, 46, 50, 49, 54, 32, 40, 67, 41, 32, 84, 104, 111, 109, 97, 115, 32, 66, 97, 117, 109, 97, 110, 110, 32, 45, 32, 104, 116, 116, 112, 58, 47, 47, 115, 104, 111, 116, 116, 121, 46, 100, 101, 118, 115, 45, 111, 110, 46, 110, 101, 116, 44, 132, 21, 213, 0, 0, 0, 84, 73, 68, 65, 84, 120, 218, 237, 207, 65, 17, 0, 0, 12, 2, 32, 211, 217, 63, 146, 37, 246, 218, 65, 3, 210, 191, 226, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 118, 100, 169, 4, 173, 8, 44, 248, 184, 40, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130\n\t\t\t]);\n\n\t\t\tawait service.backup(identifier, bufferToReadable(VSBuffer.wrap(buffer)), undefined, { binaryTest: 'true' });\n\n\t\t\tconst backup = await service.resolve(toUntypedWorkingCopyId(fooFile));\n\t\t\tassert.ok(backup);\n\n\t\t\tconst backupBuffer = await consumeStream(backup.value, chunks => VSBuffer.concat(chunks));\n\t\t\tassert.strictEqual(backupBuffer.buffer.byteLength, buffer.byteLength);\n\t\t});\n\t});\n\n\tsuite('WorkingCopyBackupsModel', () => {\n\n\t\ttest('simple', async () => {\n\t\t\tconst model = await WorkingCopyBackupsModel.create(workspaceBackupPath, service.testGetFileService());\n\n\t\t\tconst resource1 = URI.file('test.html');\n\n\t\t\tassert.strictEqual(model.has(resource1), false);\n\n\t\t\tmodel.add(resource1);\n\n\t\t\tassert.strictEqual(model.has(resource1), true);\n\t\t\tassert.strictEqual(model.has(resource1, 0), true);\n\t\t\tassert.strictEqual(model.has(resource1, 1), false);\n\t\t\tassert.strictEqual(model.has(resource1, 1, { foo: 'bar' }), false);\n\n\t\t\tmodel.remove(resource1);\n\n\t\t\tassert.strictEqual(model.has(resource1), false);\n\n\t\t\tmodel.add(resource1);\n\n\t\t\tassert.strictEqual(model.has(resource1), true);\n\t\t\tassert.strictEqual(model.has(resource1, 0), true);\n\t\t\tassert.strictEqual(model.has(resource1, 1), false);\n\n\t\t\tmodel.clear();\n\n\t\t\tassert.strictEqual(model.has(resource1), false);\n\n\t\t\tmodel.add(resource1, 1);\n\n\t\t\tassert.strictEqual(model.has(resource1), true);\n\t\t\tassert.strictEqual(model.has(resource1, 0), false);\n\t\t\tassert.strictEqual(model.has(resource1, 1), true);\n\n\t\t\tconst resource2 = URI.file('test1.html');\n\t\t\tconst resource3 = URI.file('test2.html');\n\t\t\tconst resource4 = URI.file('test3.html');\n\n\t\t\tmodel.add(resource2);\n\t\t\tmodel.add(resource3);\n\t\t\tmodel.add(resource4, undefined, { foo: 'bar' });\n\n\t\t\tassert.strictEqual(model.has(resource1), true);\n\t\t\tassert.strictEqual(model.has(resource2), true);\n\t\t\tassert.strictEqual(model.has(resource3), true);\n\n\t\t\tassert.strictEqual(model.has(resource4), true);\n\t\t\tassert.strictEqual(model.has(resource4, undefined, { foo: 'bar' }), true);\n\t\t\tassert.strictEqual(model.has(resource4, undefined, { bar: 'foo' }), false);\n\n\t\t\tmodel.update(resource4, { foo: 'nothing' });\n\t\t\tassert.strictEqual(model.has(resource4, undefined, { foo: 'nothing' }), true);\n\t\t\tassert.strictEqual(model.has(resource4, undefined, { foo: 'bar' }), false);\n\n\t\t\tmodel.update(resource4);\n\t\t\tassert.strictEqual(model.has(resource4), true);\n\t\t\tassert.strictEqual(model.has(resource4, undefined, { foo: 'nothing' }), false);\n\t\t});\n\n\t\ttest('create', async () => {\n\t\t\tconst fooBackupPath = joinPath(workspaceBackupPath, fooFile.scheme, hashIdentifier(toUntypedWorkingCopyId(fooFile)));\n\t\t\tawait fileService.createFolder(dirname(fooBackupPath));\n\t\t\tawait fileService.writeFile(fooBackupPath, VSBuffer.fromString('foo'));\n\t\t\tconst model = await WorkingCopyBackupsModel.create(workspaceBackupPath, service.testGetFileService());\n\n\t\t\tassert.strictEqual(model.has(fooBackupPath), true);\n\t\t});\n\n\t\ttest('get', async () => {\n\t\t\tconst model = await WorkingCopyBackupsModel.create(workspaceBackupPath, service.testGetFileService());\n\n\t\t\tassert.deepStrictEqual(model.get(), []);\n\n\t\t\tconst file1 = URI.file('/root/file/foo.html');\n\t\t\tconst file2 = URI.file('/root/file/bar.html');\n\t\t\tconst untitled = URI.file('/root/untitled/bar.html');\n\n\t\t\tmodel.add(file1);\n\t\t\tmodel.add(file2);\n\t\t\tmodel.add(untitled);\n\n\t\t\tassert.deepStrictEqual(model.get().map(f => f.fsPath), [file1.fsPath, file2.fsPath, untitled.fsPath]);\n\t\t});\n\t});\n\n\tsuite('typeId migration', () => {\n\n\t\ttest('works (when meta is missing)', async () => {\n\t\t\tconst fooBackupId = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst untitledBackupId = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst customBackupId = toUntypedWorkingCopyId(customFile);\n\n\t\t\tconst fooBackupPath = joinPath(workspaceBackupPath, fooFile.scheme, hashIdentifier(fooBackupId));\n\t\t\tconst untitledBackupPath = joinPath(workspaceBackupPath, untitledFile.scheme, hashIdentifier(untitledBackupId));\n\t\t\tconst customFileBackupPath = joinPath(workspaceBackupPath, customFile.scheme, hashIdentifier(customBackupId));\n\n\t\t\t// Prepare backups of the old format without meta\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, fooFile.scheme));\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, untitledFile.scheme));\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, customFile.scheme));\n\t\t\tawait fileService.writeFile(fooBackupPath, VSBuffer.fromString(`${fooFile.toString()}\\ntest file`));\n\t\t\tawait fileService.writeFile(untitledBackupPath, VSBuffer.fromString(`${untitledFile.toString()}\\ntest untitled`));\n\t\t\tawait fileService.writeFile(customFileBackupPath, VSBuffer.fromString(`${customFile.toString()}\\ntest custom`));\n\n\t\t\tservice.reinitialize(workspaceBackupPath);\n\n\t\t\tconst backups = await service.getBackups();\n\t\t\tassert.strictEqual(backups.length, 3);\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, fooFile)));\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, untitledFile)));\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, customFile)));\n\t\t\tassert.ok(backups.every(backup => backup.typeId === ''));\n\t\t});\n\n\t\ttest('works (when typeId in meta is missing)', async () => {\n\t\t\tconst fooBackupId = toUntypedWorkingCopyId(fooFile);\n\t\t\tconst untitledBackupId = toUntypedWorkingCopyId(untitledFile);\n\t\t\tconst customBackupId = toUntypedWorkingCopyId(customFile);\n\n\t\t\tconst fooBackupPath = joinPath(workspaceBackupPath, fooFile.scheme, hashIdentifier(fooBackupId));\n\t\t\tconst untitledBackupPath = joinPath(workspaceBackupPath, untitledFile.scheme, hashIdentifier(untitledBackupId));\n\t\t\tconst customFileBackupPath = joinPath(workspaceBackupPath, customFile.scheme, hashIdentifier(customBackupId));\n\n\t\t\t// Prepare backups of the old format without meta\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, fooFile.scheme));\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, untitledFile.scheme));\n\t\t\tawait fileService.createFolder(joinPath(workspaceBackupPath, customFile.scheme));\n\t\t\tawait fileService.writeFile(fooBackupPath, VSBuffer.fromString(`${fooFile.toString()} ${JSON.stringify({ foo: 'bar' })}\\ntest file`));\n\t\t\tawait fileService.writeFile(untitledBackupPath, VSBuffer.fromString(`${untitledFile.toString()} ${JSON.stringify({ foo: 'bar' })}\\ntest untitled`));\n\t\t\tawait fileService.writeFile(customFileBackupPath, VSBuffer.fromString(`${customFile.toString()} ${JSON.stringify({ foo: 'bar' })}\\ntest custom`));\n\n\t\t\tservice.reinitialize(workspaceBackupPath);\n\n\t\t\tconst backups = await service.getBackups();\n\t\t\tassert.strictEqual(backups.length, 3);\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, fooFile)));\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, untitledFile)));\n\t\t\tassert.ok(backups.some(backup => isEqual(backup.resource, customFile)));\n\t\t\tassert.ok(backups.every(backup => backup.typeId === ''));\n\t\t});\n\t});\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n});\n"]}