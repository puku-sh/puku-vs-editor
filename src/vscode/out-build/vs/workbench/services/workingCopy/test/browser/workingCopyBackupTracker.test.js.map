{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/workingCopy/test/browser/workingCopyBackupTracker.test.ts","vs/workbench/services/workingCopy/test/browser/workingCopyBackupTracker.test.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;AAEhG,OAAO,MAAM,MAAM,QAAQ,CAAC;AAC5B,OAAO,EAAE,GAAG,EAAE,MAAM,mCAAmC,CAAC;AACxD,OAAO,EAAE,cAAc,EAAE,MAAM,yCAAyC,CAAC;AAEzE,OAAO,EAAE,oBAAoB,EAAE,MAAM,+CAA+C,CAAC;AACrF,OAAO,EAAE,aAAa,EAAE,MAAM,0CAA0C,CAAC;AAEzE,OAAO,EAAE,yBAAyB,EAAE,MAAM,mCAAmC,CAAC;AAC9E,OAAO,EAAE,uCAAuC,EAAE,UAAU,EAAE,MAAM,0CAA0C,CAAC;AAC/G,OAAO,EAAE,0BAA0B,EAAE,MAAM,iEAAiE,CAAC;AAC7G,OAAO,EAAE,mBAAmB,EAAE,MAAM,oCAAoC,CAAC;AAEzE,OAAO,EAAE,WAAW,EAAE,MAAM,2CAA2C,CAAC;AACxE,OAAO,EAAE,iBAAiB,EAAkB,MAAM,wCAAwC,CAAC;AAE3F,OAAO,EAAE,uBAAuB,EAAE,MAAM,qDAAqD,CAAC;AAC9F,OAAO,EAAE,gBAAgB,EAAE,oCAAoC,EAAE,0BAA0B,EAAE,mBAAmB,EAAE,oBAAoB,EAAE,sBAAsB,EAAE,6BAA6B,EAAE,iBAAiB,EAAE,MAAM,mDAAmD,CAAC;AAC5Q,OAAO,EAAE,eAAe,EAAE,MAAM,kDAAkD,CAAC;AAEnF,OAAO,EAAE,OAAO,EAAE,MAAM,qCAAqC,CAAC;AAC9D,OAAO,EAAE,+BAA+B,EAAE,MAAM,2CAA2C,CAAC;AAC5F,OAAO,EAAE,eAAe,EAAE,MAAM,yCAAyC,CAAC;AAC1E,OAAO,EAA6B,yBAAyB,EAAE,MAAM,0CAA0C,CAAC;AAChH,OAAO,EAAE,gBAAgB,EAAE,QAAQ,EAAE,MAAM,sCAAsC,CAAC;AAClF,OAAO,EAAE,SAAS,EAAE,MAAM,wCAAwC,CAAC;AACnE,OAAO,EAAE,OAAO,EAAE,MAAM,uCAAuC,CAAC;AAEhE,KAAK,CAAC,oCAAoC,EAAE;IAC3C,IAAI,QAA6B,CAAC;IAClC,MAAM,WAAW,GAAG,IAAI,eAAe,EAAE,CAAC;IAE1C,KAAK,CAAC,GAAG,EAAE;QACV,WAAW,CAAC,GAAG,CAAC,0BAA0B,EAAE,CAAC,CAAC;IAC/C,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,KAAK,IAAI,EAAE;QACnB,MAAM,iBAAiB,CAAC,QAAQ,CAAC,oBAAoB,CAAC,CAAC;QAEvD,WAAW,CAAC,KAAK,EAAE,CAAC;IACrB,CAAC,CAAC,CAAC;IAEH,IAAM,4BAA4B,GAAlC,MAAM,4BAA6B,SAAQ,+BAA+B;QAEzE,YAC4B,wBAAmD,EAClD,yBAAqD,EAC5D,kBAAuC,EACzC,gBAAmC,EACzC,UAAuB,EACT,wBAAmD,EAC9D,aAA6B,EACvB,kBAAwC;YAE9D,KAAK,CAAC,wBAAwB,EAAE,yBAAyB,EAAE,kBAAkB,EAAE,gBAAgB,EAAE,UAAU,EAAE,wBAAwB,EAAE,aAAa,EAAE,kBAAkB,CAAC,CAAC;QAC3K,CAAC;QAEkB,sBAAsB;YACxC,OAAO,EAAE,CAAC,CAAC,2BAA2B;QACvC,CAAC;QAED,IAAI,2BAA2B,KAAa,OAAO,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC;QAEvF,oBAAoB;YACnB,OAAO,IAAI,CAAC,iBAAiB,CAAC;QAC/B,CAAC;QAED,KAAK,CAAC,kBAAkB,CAAC,OAAkC;YAC1D,OAAO,KAAK,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QACtC,CAAC;KACD,CAAA;IA5BK,4BAA4B;QAG/B,WAAA,yBAAyB,CAAA;QACzB,WAAA,0BAA0B,CAAA;QAC1B,WAAA,mBAAmB,CAAA;QACnB,WAAA,iBAAiB,CAAA;QACjB,WAAA,WAAW,CAAA;QACX,WAAA,yBAAyB,CAAA;QACzB,WAAA,cAAc,CAAA;QACd,WAAA,oBAAoB,CAAA;OAVjB,4BAA4B,CA4BjC;IAED,MAAM,2BAA4B,SAAQ,uBAAuB;QAAjE;;YAEC,aAAQ,GAAG,KAAK,CAAC;QAOlB,CAAC;QALS,OAAO;YACf,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YAErB,OAAO,KAAK,CAAC,OAAO,EAAE,CAAC;QACxB,CAAC;KACD;IAED,KAAK,UAAU,aAAa;QAC3B,MAAM,wBAAwB,GAAG,WAAW,CAAC,GAAG,CAAC,IAAI,oCAAoC,EAAE,CAAC,CAAC;QAC7F,MAAM,oBAAoB,GAAG,6BAA6B,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;QACnF,oBAAoB,CAAC,IAAI,CAAC,yBAAyB,EAAE,wBAAwB,CAAC,CAAC;QAE/E,MAAM,IAAI,GAAG,MAAM,gBAAgB,CAAC,oBAAoB,EAAE,WAAW,CAAC,CAAC;QACvE,oBAAoB,CAAC,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAC;QAEtD,WAAW,CAAC,GAAG,CAAC,0BAA0B,EAAE,CAAC,CAAC;QAE9C,MAAM,aAAa,GAAkB,WAAW,CAAC,GAAG,CAAC,oBAAoB,CAAC,cAAc,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC,CAAC;QACpH,oBAAoB,CAAC,IAAI,CAAC,cAAc,EAAE,aAAa,CAAC,CAAC;QAEzD,QAAQ,GAAG,oBAAoB,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;QAEpE,MAAM,OAAO,GAAG,WAAW,CAAC,GAAG,CAAC,oBAAoB,CAAC,cAAc,CAAC,4BAA4B,CAAC,CAAC,CAAC;QAEnG,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,OAAO,EAAE,wBAAwB,EAAE,wBAAwB,EAAE,oBAAoB,EAAE,CAAC;IAC9G,CAAC;IAED,KAAK,UAAU,kBAAkB,CAAC,WAA6C,EAAE,QAAQ,EAAE,SAAS,EAAE;QACrG,MAAM,EAAE,QAAQ,EAAE,wBAAwB,EAAE,GAAG,MAAM,aAAa,EAAE,CAAC;QAErE,MAAM,kBAAkB,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,MAAM,QAAQ,CAAC,aAAa,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,KAAgC,CAAC,CAAC;QAClI,MAAM,iBAAiB,GAAG,WAAW,CAAC,GAAG,CAAC,MAAM,kBAAkB,CAAC,OAAO,EAAE,CAAC,CAAC;QAE9E,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAE,CAAC;YACzB,iBAAiB,CAAC,eAAe,EAAE,QAAQ,CAAC,YAAY,CAAC,CAAC;QAC3D,CAAC;QAED,MAAM,wBAAwB,CAAC,kBAAkB,EAAE,CAAC;QAEpD,MAAM,CAAC,WAAW,CAAC,wBAAwB,CAAC,aAAa,CAAC,iBAAiB,CAAC,EAAE,IAAI,CAAC,CAAC;QAEpF,iBAAiB,CAAC,OAAO,EAAE,CAAC;QAE5B,MAAM,wBAAwB,CAAC,iBAAiB,EAAE,CAAC;QAEnD,MAAM,CAAC,WAAW,CAAC,wBAAwB,CAAC,aAAa,CAAC,iBAAiB,CAAC,EAAE,KAAK,CAAC,CAAC;IACtF,CAAC;IAED,IAAI,CAAC,0BAA0B,EAAE;QAChC,OAAO,kBAAkB,EAAE,CAAC;IAC7B,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,gDAAgD,EAAE;QACtD,OAAO,kBAAkB,CAAC,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC;IACzE,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,wBAAwB,EAAE,KAAK;QACnC,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,wBAAwB,EAAE,GAAG,MAAM,aAAa,EAAE,CAAC;QAE9E,MAAM,qBAAsB,SAAQ,eAAe;YAElD,YAAY,QAAa;gBACxB,KAAK,CAAC,QAAQ,CAAC,CAAC;gBAKR,gBAAW,GAAG,EAAE,CAAC;gBAHzB,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,kBAAkB,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC;YACxE,CAAC;YAIQ,KAAK,CAAC,MAAM,CAAC,KAAwB;gBAC7C,MAAM,OAAO,CAAC,CAAC,CAAC,CAAC;gBAEjB,OAAO,EAAE,CAAC;YACX,CAAC;SACD;QAED,MAAM,QAAQ,GAAQ,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,kBAAkB,CAAC,CAAC;QAChE,MAAM,iBAAiB,GAAG,WAAW,CAAC,GAAG,CAAC,IAAI,qBAAqB,CAAC,QAAQ,CAAC,CAAC,CAAC;QAE/E,SAAS;QACT,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACjC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,2BAA2B,EAAE,CAAC,CAAC,CAAC;QAC3D,MAAM,wBAAwB,CAAC,kBAAkB,EAAE,CAAC;QACpD,MAAM,CAAC,WAAW,CAAC,wBAAwB,CAAC,aAAa,CAAC,iBAAiB,CAAC,EAAE,IAAI,CAAC,CAAC;QAEpF,iBAAiB,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAClC,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACjC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,2BAA2B,EAAE,CAAC,CAAC,CAAC;QAC3D,MAAM,wBAAwB,CAAC,kBAAkB,EAAE,CAAC;QACpD,MAAM,CAAC,WAAW,CAAC,wBAAwB,CAAC,aAAa,CAAC,iBAAiB,CAAC,EAAE,IAAI,CAAC,CAAC;QAEpF,iBAAiB,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAClC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,2BAA2B,EAAE,CAAC,CAAC,CAAC;QAC3D,MAAM,wBAAwB,CAAC,iBAAiB,EAAE,CAAC;QACnD,MAAM,CAAC,WAAW,CAAC,wBAAwB,CAAC,aAAa,CAAC,iBAAiB,CAAC,EAAE,KAAK,CAAC,CAAC;QAErF,eAAe;QACf,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACjC,MAAM,OAAO,CAAC,CAAC,CAAC,CAAC;QACjB,iBAAiB,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAClC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,2BAA2B,EAAE,CAAC,CAAC,CAAC;QAC3D,MAAM,wBAAwB,CAAC,iBAAiB,EAAE,CAAC;QACnD,MAAM,CAAC,WAAW,CAAC,wBAAwB,CAAC,aAAa,CAAC,iBAAiB,CAAC,EAAE,KAAK,CAAC,CAAC;IACtF,CAAC,CAAC,CAAC;IAEH,KAAK,UAAU,kBAAkB;QAChC,MAAM,OAAO,GAAG,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACzD,MAAM,OAAO,GAAG,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACzD,MAAM,aAAa,GAAG,GAAG,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,OAAO,CAAC,QAAQ,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC,CAAC;QACjF,MAAM,aAAa,GAAG,GAAG,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,OAAO,CAAC,QAAQ,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC,CAAC;QAEjF,MAAM,wBAAwB,GAAG,WAAW,CAAC,GAAG,CAAC,IAAI,oCAAoC,EAAE,CAAC,CAAC;QAC7F,MAAM,oBAAoB,GAAG,6BAA6B,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;QACnF,oBAAoB,CAAC,IAAI,CAAC,yBAAyB,EAAE,wBAAwB,CAAC,CAAC;QAE/E,MAAM,IAAI,GAAG,MAAM,gBAAgB,CAAC,oBAAoB,EAAE,WAAW,CAAC,CAAC;QACvE,oBAAoB,CAAC,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAC;QAEtD,MAAM,aAAa,GAAkB,WAAW,CAAC,GAAG,CAAC,oBAAoB,CAAC,cAAc,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC,CAAC;QACpH,oBAAoB,CAAC,IAAI,CAAC,cAAc,EAAE,aAAa,CAAC,CAAC;QAEzD,QAAQ,GAAG,oBAAoB,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;QAEpE,6CAA6C;QAC7C,MAAM,0BAA0B,GAAG,sBAAsB,CAAC,aAAa,CAAC,CAAC;QACzE,MAAM,0BAA0B,GAAG,oBAAoB,CAAC,aAAa,CAAC,CAAC;QACvE,MAAM,wBAAwB,CAAC,MAAM,CAAC,0BAA0B,EAAE,gBAAgB,CAAC,QAAQ,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;QACvH,MAAM,wBAAwB,CAAC,MAAM,CAAC,0BAA0B,EAAE,gBAAgB,CAAC,QAAQ,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;QAEvH,MAAM,oBAAoB,GAAG,sBAAsB,CAAC,OAAO,CAAC,CAAC;QAC7D,MAAM,oBAAoB,GAAG,oBAAoB,CAAC,OAAO,CAAC,CAAC;QAC3D,MAAM,wBAAwB,CAAC,MAAM,CAAC,oBAAoB,EAAE,gBAAgB,CAAC,QAAQ,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QAC9G,MAAM,wBAAwB,CAAC,MAAM,CAAC,oBAAoB,EAAE,gBAAgB,CAAC,QAAQ,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QAE9G,MAAM,OAAO,GAAG,WAAW,CAAC,GAAG,CAAC,oBAAoB,CAAC,cAAc,CAAC,4BAA4B,CAAC,CAAC,CAAC;QAEnG,QAAQ,CAAC,gBAAgB,CAAC,KAAK,kCAA0B,CAAC;QAE1D,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAC5B,CAAC;IAED,IAAI,CAAC,wCAAwC,EAAE,KAAK;QACnD,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,GAAG,MAAM,kBAAkB,EAAE,CAAC;QAEvD,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,oBAAoB,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QAE3D,IAAI,cAAc,GAAG,CAAC,CAAC;QACvB,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,IAAI,mBAAmB,GAAG,CAAC,CAAC;QAE5B,MAAM,OAAO,CAAC,kBAAkB,CAAC;YAChC,OAAO,EAAE,WAAW,CAAC,EAAE;gBACtB,cAAc,EAAE,CAAC;gBAEjB,OAAO,WAAW,CAAC,MAAM,KAAK,kBAAkB,CAAC;YAClD,CAAC;YACD,MAAM,EAAE,CAAC,WAAW,EAAE,MAAM,EAAE,EAAE;gBAC/B,aAAa,EAAE,CAAC;gBAEhB,OAAO,KAAK,CAAC;YACd,CAAC;YACD,YAAY,EAAE,WAAW,CAAC,EAAE;gBAC3B,mBAAmB,EAAE,CAAC;gBAEtB,OAAO,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,oBAAoB,CAAC,cAAc,CAAC,2BAA2B,EAAE,QAAQ,CAAC,yBAAyB,CAAC,MAAM,CAAC,EAAE,YAAY,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;YACvK,CAAC;SACD,CAAC,CAAC;QAEH,MAAM,CAAC,WAAW,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;QACtC,MAAM,CAAC,WAAW,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;QACrC,MAAM,CAAC,WAAW,CAAC,mBAAmB,EAAE,CAAC,CAAC,CAAC;QAE3C,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QACpD,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QAC5E,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,oBAAoB,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QAE3D,KAAK,MAAM,MAAM,IAAI,QAAQ,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC;YACrD,MAAM,CAAC,EAAE,CAAC,MAAM,YAAY,2BAA2B,CAAC,CAAC;YACzD,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAC3C,CAAC;IACF,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,wCAAwC,EAAE,KAAK;QACnD,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,GAAG,MAAM,kBAAkB,EAAE,CAAC;QAEvD,MAAM,OAAO,CAAC,kBAAkB,CAAC;YAChC,OAAO,EAAE,WAAW,CAAC,EAAE,CAAC,KAAK;YAC7B,MAAM,EAAE,CAAC,WAAW,EAAE,MAAM,EAAE,EAAE,GAAG,MAAM,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;YACnE,YAAY,EAAE,WAAW,CAAC,EAAE,GAAG,MAAM,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;SAC/D,CAAC,CAAC;QAEH,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QACpD,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,oBAAoB,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IAC5D,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,sCAAsC,EAAE,KAAK;QACjD,MAAM,CAAC,OAAO,CAAC,GAAG,MAAM,kBAAkB,EAAE,CAAC;QAE7C,IAAI,CAAC;YACJ,MAAM,OAAO,CAAC,kBAAkB,CAAC;gBAChC,OAAO,EAAE,WAAW,CAAC,EAAE,CAAC,IAAI;gBAC5B,MAAM,EAAE,CAAC,WAAW,EAAE,MAAM,EAAE,EAAE,GAAG,MAAM,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;gBACnE,YAAY,EAAE,WAAW,CAAC,EAAE,GAAG,MAAM,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;aAC/D,CAAC,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,SAAS;QACV,CAAC;QAED,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,oBAAoB,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IAC5D,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,qCAAqC,EAAE,KAAK;QAChD,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,GAAG,MAAM,kBAAkB,EAAE,CAAC;QAEvD,MAAM,YAAY,GAAG,OAAO,CAAC,kBAAkB,CAAC;YAC/C,OAAO,EAAE,WAAW,CAAC,EAAE;gBACtB,OAAO,WAAW,CAAC,MAAM,KAAK,kBAAkB,CAAC;YAClD,CAAC;YACD,MAAM,EAAE,CAAC,WAAW,EAAE,MAAM,EAAE,EAAE;gBAC/B,OAAO,KAAK,CAAC;YACd,CAAC;YACD,YAAY,EAAE,WAAW,CAAC,EAAE;gBAC3B,OAAO,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,oBAAoB,CAAC,cAAc,CAAC,2BAA2B,EAAE,QAAQ,CAAC,yBAAyB,CAAC,MAAM,CAAC,EAAE,YAAY,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;YACvK,CAAC;SACD,CAAC,CAAC;QAEH,MAAM,aAAa,GAAG,OAAO,CAAC,kBAAkB,CAAC;YAChD,OAAO,EAAE,WAAW,CAAC,EAAE;gBACtB,OAAO,WAAW,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC;YACxC,CAAC;YACD,MAAM,EAAE,CAAC,WAAW,EAAE,MAAM,EAAE,EAAE;gBAC/B,OAAO,KAAK,CAAC;YACd,CAAC;YACD,YAAY,EAAE,WAAW,CAAC,EAAE;gBAC3B,OAAO,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,oBAAoB,CAAC,cAAc,CAAC,2BAA2B,EAAE,QAAQ,CAAC,yBAAyB,CAAC,MAAM,CAAC,EAAE,YAAY,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;YACvK,CAAC;SACD,CAAC,CAAC;QAEH,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,YAAY,EAAE,aAAa,CAAC,CAAC,CAAC;QAEjD,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QACpD,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QAC5E,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,oBAAoB,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QAE3D,KAAK,MAAM,MAAM,IAAI,QAAQ,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC;YACrD,MAAM,CAAC,EAAE,CAAC,MAAM,YAAY,2BAA2B,CAAC,CAAC;YACzD,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAC3C,CAAC;IACF,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,0CAA0C,EAAE,KAAK;QACrD,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,GAAG,MAAM,kBAAkB,EAAE,CAAC;QAEvD,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,oBAAoB,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QAE3D,IAAI,cAAc,GAAG,CAAC,CAAC;QACvB,IAAI,aAAa,GAAG,CAAC,CAAC;QAEtB,MAAM,OAAO,GAAG,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,oBAAoB,CAAC,cAAc,CAAC,2BAA2B,EAAE,QAAQ,CAAC,yBAAyB,CAAC,MAAM,CAAC,EAAE,YAAY,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;QAC/K,MAAM,OAAO,GAAG,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,oBAAoB,CAAC,cAAc,CAAC,2BAA2B,EAAE,QAAQ,CAAC,yBAAyB,CAAC,MAAM,CAAC,EAAE,YAAY,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;QAE/K,MAAM,QAAQ,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;QAErF,OAAO,CAAC,QAAQ,GAAG,KAAK,CAAC;QACzB,OAAO,CAAC,QAAQ,GAAG,KAAK,CAAC;QAEzB,MAAM,OAAO,CAAC,kBAAkB,CAAC;YAChC,OAAO,EAAE,WAAW,CAAC,EAAE;gBACtB,cAAc,EAAE,CAAC;gBAEjB,OAAO,WAAW,CAAC,MAAM,KAAK,kBAAkB,CAAC;YAClD,CAAC;YACD,MAAM,EAAE,CAAC,WAAW,EAAE,MAAM,EAAE,EAAE;gBAC/B,aAAa,EAAE,CAAC;gBAEhB,OAAO,IAAI,CAAC;YACb,CAAC;YACD,YAAY,EAAE,WAAW,CAAC,EAAE,GAAG,MAAM,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;SAC/D,CAAC,CAAC;QAEH,MAAM,CAAC,WAAW,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;QACtC,MAAM,CAAC,WAAW,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;QAErC,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QACpD,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,oBAAoB,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QAE3D,KAAK,MAAM,MAAM,IAAI,QAAQ,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC;YACrD,MAAM,CAAC,EAAE,CAAC,MAAM,YAAY,2BAA2B,CAAC,CAAC;YAEzD,yDAAyD;YACzD,IAAI,QAAQ,CAAC,aAAa,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC;gBAC9C,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YAC5C,CAAC;iBAAM,CAAC;gBACP,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;YAC3C,CAAC;QACF,CAAC;IACF,CAAC,CAAC,CAAC;IAEH,uCAAuC,EAAE,CAAC;AAC3C,CAAC,CAAC,CAAC","file":"workingCopyBackupTracker.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IEditorService } from '../../../editor/common/editorService.js';\nimport { EditorPart } from '../../../../browser/parts/editor/editorPart.js';\nimport { IEditorGroupsService } from '../../../editor/common/editorGroupsService.js';\nimport { EditorService } from '../../../editor/browser/editorService.js';\nimport { IUntitledTextResourceEditorInput } from '../../../../common/editor.js';\nimport { IWorkingCopyBackupService } from '../../common/workingCopyBackup.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite, toResource } from '../../../../../base/test/common/utils.js';\nimport { IFilesConfigurationService } from '../../../filesConfiguration/common/filesConfigurationService.js';\nimport { IWorkingCopyService } from '../../common/workingCopyService.js';\nimport { IWorkingCopyBackup } from '../../common/workingCopy.js';\nimport { ILogService } from '../../../../../platform/log/common/log.js';\nimport { ILifecycleService, LifecyclePhase } from '../../../lifecycle/common/lifecycle.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { UntitledTextEditorInput } from '../../../untitled/common/untitledTextEditorInput.js';\nimport { createEditorPart, InMemoryTestWorkingCopyBackupService, registerTestResourceEditor, TestServiceAccessor, toTypedWorkingCopyId, toUntypedWorkingCopyId, workbenchInstantiationService, workbenchTeardown } from '../../../../test/browser/workbenchTestServices.js';\nimport { TestWorkingCopy } from '../../../../test/common/workbenchTestServices.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { timeout } from '../../../../../base/common/async.js';\nimport { BrowserWorkingCopyBackupTracker } from '../../browser/workingCopyBackupTracker.js';\nimport { DisposableStore } from '../../../../../base/common/lifecycle.js';\nimport { IWorkingCopyEditorHandler, IWorkingCopyEditorService } from '../../common/workingCopyEditorService.js';\nimport { bufferToReadable, VSBuffer } from '../../../../../base/common/buffer.js';\nimport { isWindows } from '../../../../../base/common/platform.js';\nimport { Schemas } from '../../../../../base/common/network.js';\n\nsuite('WorkingCopyBackupTracker (browser)', function () {\n\tlet accessor: TestServiceAccessor;\n\tconst disposables = new DisposableStore();\n\n\tsetup(() => {\n\t\tdisposables.add(registerTestResourceEditor());\n\t});\n\n\tteardown(async () => {\n\t\tawait workbenchTeardown(accessor.instantiationService);\n\n\t\tdisposables.clear();\n\t});\n\n\tclass TestWorkingCopyBackupTracker extends BrowserWorkingCopyBackupTracker {\n\n\t\tconstructor(\n\t\t\t@IWorkingCopyBackupService workingCopyBackupService: IWorkingCopyBackupService,\n\t\t\t@IFilesConfigurationService filesConfigurationService: IFilesConfigurationService,\n\t\t\t@IWorkingCopyService workingCopyService: IWorkingCopyService,\n\t\t\t@ILifecycleService lifecycleService: ILifecycleService,\n\t\t\t@ILogService logService: ILogService,\n\t\t\t@IWorkingCopyEditorService workingCopyEditorService: IWorkingCopyEditorService,\n\t\t\t@IEditorService editorService: IEditorService,\n\t\t\t@IEditorGroupsService editorGroupService: IEditorGroupsService\n\t\t) {\n\t\t\tsuper(workingCopyBackupService, filesConfigurationService, workingCopyService, lifecycleService, logService, workingCopyEditorService, editorService, editorGroupService);\n\t\t}\n\n\t\tprotected override getBackupScheduleDelay(): number {\n\t\t\treturn 10; // Reduce timeout for tests\n\t\t}\n\n\t\tget pendingBackupOperationCount(): number { return this.pendingBackupOperations.size; }\n\n\t\tgetUnrestoredBackups() {\n\t\t\treturn this.unrestoredBackups;\n\t\t}\n\n\t\tasync testRestoreBackups(handler: IWorkingCopyEditorHandler): Promise<void> {\n\t\t\treturn super.restoreBackups(handler);\n\t\t}\n\t}\n\n\tclass TestUntitledTextEditorInput extends UntitledTextEditorInput {\n\n\t\tresolved = false;\n\n\t\toverride resolve() {\n\t\t\tthis.resolved = true;\n\n\t\t\treturn super.resolve();\n\t\t}\n\t}\n\n\tasync function createTracker(): Promise<{ accessor: TestServiceAccessor; part: EditorPart; tracker: TestWorkingCopyBackupTracker; workingCopyBackupService: InMemoryTestWorkingCopyBackupService; instantiationService: IInstantiationService }> {\n\t\tconst workingCopyBackupService = disposables.add(new InMemoryTestWorkingCopyBackupService());\n\t\tconst instantiationService = workbenchInstantiationService(undefined, disposables);\n\t\tinstantiationService.stub(IWorkingCopyBackupService, workingCopyBackupService);\n\n\t\tconst part = await createEditorPart(instantiationService, disposables);\n\t\tinstantiationService.stub(IEditorGroupsService, part);\n\n\t\tdisposables.add(registerTestResourceEditor());\n\n\t\tconst editorService: EditorService = disposables.add(instantiationService.createInstance(EditorService, undefined));\n\t\tinstantiationService.stub(IEditorService, editorService);\n\n\t\taccessor = instantiationService.createInstance(TestServiceAccessor);\n\n\t\tconst tracker = disposables.add(instantiationService.createInstance(TestWorkingCopyBackupTracker));\n\n\t\treturn { accessor, part, tracker, workingCopyBackupService: workingCopyBackupService, instantiationService };\n\t}\n\n\tasync function untitledBackupTest(untitled: IUntitledTextResourceEditorInput = { resource: undefined }): Promise<void> {\n\t\tconst { accessor, workingCopyBackupService } = await createTracker();\n\n\t\tconst untitledTextEditor = disposables.add((await accessor.editorService.openEditor(untitled))?.input as UntitledTextEditorInput);\n\t\tconst untitledTextModel = disposables.add(await untitledTextEditor.resolve());\n\n\t\tif (!untitled?.contents) {\n\t\t\tuntitledTextModel.textEditorModel?.setValue('Super Good');\n\t\t}\n\n\t\tawait workingCopyBackupService.joinBackupResource();\n\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(untitledTextModel), true);\n\n\t\tuntitledTextModel.dispose();\n\n\t\tawait workingCopyBackupService.joinDiscardBackup();\n\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(untitledTextModel), false);\n\t}\n\n\ttest('Track backups (untitled)', function () {\n\t\treturn untitledBackupTest();\n\t});\n\n\ttest('Track backups (untitled with initial contents)', function () {\n\t\treturn untitledBackupTest({ resource: undefined, contents: 'Foo Bar' });\n\t});\n\n\ttest('Track backups (custom)', async function () {\n\t\tconst { accessor, tracker, workingCopyBackupService } = await createTracker();\n\n\t\tclass TestBackupWorkingCopy extends TestWorkingCopy {\n\n\t\t\tconstructor(resource: URI) {\n\t\t\t\tsuper(resource);\n\n\t\t\t\tdisposables.add(accessor.workingCopyService.registerWorkingCopy(this));\n\t\t\t}\n\n\t\t\treadonly backupDelay = 10;\n\n\t\t\toverride async backup(token: CancellationToken): Promise<IWorkingCopyBackup> {\n\t\t\t\tawait timeout(0);\n\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}\n\n\t\tconst resource: URI = toResource.call(this, '/path/custom.txt');\n\t\tconst customWorkingCopy = disposables.add(new TestBackupWorkingCopy(resource));\n\n\t\t// Normal\n\t\tcustomWorkingCopy.setDirty(true);\n\t\tassert.strictEqual(tracker.pendingBackupOperationCount, 1);\n\t\tawait workingCopyBackupService.joinBackupResource();\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(customWorkingCopy), true);\n\n\t\tcustomWorkingCopy.setDirty(false);\n\t\tcustomWorkingCopy.setDirty(true);\n\t\tassert.strictEqual(tracker.pendingBackupOperationCount, 1);\n\t\tawait workingCopyBackupService.joinBackupResource();\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(customWorkingCopy), true);\n\n\t\tcustomWorkingCopy.setDirty(false);\n\t\tassert.strictEqual(tracker.pendingBackupOperationCount, 1);\n\t\tawait workingCopyBackupService.joinDiscardBackup();\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(customWorkingCopy), false);\n\n\t\t// Cancellation\n\t\tcustomWorkingCopy.setDirty(true);\n\t\tawait timeout(0);\n\t\tcustomWorkingCopy.setDirty(false);\n\t\tassert.strictEqual(tracker.pendingBackupOperationCount, 1);\n\t\tawait workingCopyBackupService.joinDiscardBackup();\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(customWorkingCopy), false);\n\t});\n\n\tasync function restoreBackupsInit(): Promise<[TestWorkingCopyBackupTracker, TestServiceAccessor]> {\n\t\tconst fooFile = URI.file(isWindows ? 'c:\\\\Foo' : '/Foo');\n\t\tconst barFile = URI.file(isWindows ? 'c:\\\\Bar' : '/Bar');\n\t\tconst untitledFile1 = URI.from({ scheme: Schemas.untitled, path: 'Untitled-1' });\n\t\tconst untitledFile2 = URI.from({ scheme: Schemas.untitled, path: 'Untitled-2' });\n\n\t\tconst workingCopyBackupService = disposables.add(new InMemoryTestWorkingCopyBackupService());\n\t\tconst instantiationService = workbenchInstantiationService(undefined, disposables);\n\t\tinstantiationService.stub(IWorkingCopyBackupService, workingCopyBackupService);\n\n\t\tconst part = await createEditorPart(instantiationService, disposables);\n\t\tinstantiationService.stub(IEditorGroupsService, part);\n\n\t\tconst editorService: EditorService = disposables.add(instantiationService.createInstance(EditorService, undefined));\n\t\tinstantiationService.stub(IEditorService, editorService);\n\n\t\taccessor = instantiationService.createInstance(TestServiceAccessor);\n\n\t\t// Backup 2 normal files and 2 untitled files\n\t\tconst untitledFile1WorkingCopyId = toUntypedWorkingCopyId(untitledFile1);\n\t\tconst untitledFile2WorkingCopyId = toTypedWorkingCopyId(untitledFile2);\n\t\tawait workingCopyBackupService.backup(untitledFile1WorkingCopyId, bufferToReadable(VSBuffer.fromString('untitled-1')));\n\t\tawait workingCopyBackupService.backup(untitledFile2WorkingCopyId, bufferToReadable(VSBuffer.fromString('untitled-2')));\n\n\t\tconst fooFileWorkingCopyId = toUntypedWorkingCopyId(fooFile);\n\t\tconst barFileWorkingCopyId = toTypedWorkingCopyId(barFile);\n\t\tawait workingCopyBackupService.backup(fooFileWorkingCopyId, bufferToReadable(VSBuffer.fromString('fooFile')));\n\t\tawait workingCopyBackupService.backup(barFileWorkingCopyId, bufferToReadable(VSBuffer.fromString('barFile')));\n\n\t\tconst tracker = disposables.add(instantiationService.createInstance(TestWorkingCopyBackupTracker));\n\n\t\taccessor.lifecycleService.phase = LifecyclePhase.Restored;\n\n\t\treturn [tracker, accessor];\n\t}\n\n\ttest('Restore backups (basics, some handled)', async function () {\n\t\tconst [tracker, accessor] = await restoreBackupsInit();\n\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 0);\n\n\t\tlet handlesCounter = 0;\n\t\tlet isOpenCounter = 0;\n\t\tlet createEditorCounter = 0;\n\n\t\tawait tracker.testRestoreBackups({\n\t\t\thandles: workingCopy => {\n\t\t\t\thandlesCounter++;\n\n\t\t\t\treturn workingCopy.typeId === 'testBackupTypeId';\n\t\t\t},\n\t\t\tisOpen: (workingCopy, editor) => {\n\t\t\t\tisOpenCounter++;\n\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tcreateEditor: workingCopy => {\n\t\t\t\tcreateEditorCounter++;\n\n\t\t\t\treturn disposables.add(accessor.instantiationService.createInstance(TestUntitledTextEditorInput, accessor.untitledTextEditorService.create({ initialValue: 'foo' })));\n\t\t\t}\n\t\t});\n\n\t\tassert.strictEqual(handlesCounter, 4);\n\t\tassert.strictEqual(isOpenCounter, 0);\n\t\tassert.strictEqual(createEditorCounter, 2);\n\n\t\tassert.strictEqual(accessor.editorService.count, 2);\n\t\tassert.ok(accessor.editorService.editors.every(editor => editor.isDirty()));\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 2);\n\n\t\tfor (const editor of accessor.editorService.editors) {\n\t\t\tassert.ok(editor instanceof TestUntitledTextEditorInput);\n\t\t\tassert.strictEqual(editor.resolved, true);\n\t\t}\n\t});\n\n\ttest('Restore backups (basics, none handled)', async function () {\n\t\tconst [tracker, accessor] = await restoreBackupsInit();\n\n\t\tawait tracker.testRestoreBackups({\n\t\t\thandles: workingCopy => false,\n\t\t\tisOpen: (workingCopy, editor) => { throw new Error('unexpected'); },\n\t\t\tcreateEditor: workingCopy => { throw new Error('unexpected'); }\n\t\t});\n\n\t\tassert.strictEqual(accessor.editorService.count, 0);\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 4);\n\t});\n\n\ttest('Restore backups (basics, error case)', async function () {\n\t\tconst [tracker] = await restoreBackupsInit();\n\n\t\ttry {\n\t\t\tawait tracker.testRestoreBackups({\n\t\t\t\thandles: workingCopy => true,\n\t\t\t\tisOpen: (workingCopy, editor) => { throw new Error('unexpected'); },\n\t\t\t\tcreateEditor: workingCopy => { throw new Error('unexpected'); }\n\t\t\t});\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 4);\n\t});\n\n\ttest('Restore backups (multiple handlers)', async function () {\n\t\tconst [tracker, accessor] = await restoreBackupsInit();\n\n\t\tconst firstHandler = tracker.testRestoreBackups({\n\t\t\thandles: workingCopy => {\n\t\t\t\treturn workingCopy.typeId === 'testBackupTypeId';\n\t\t\t},\n\t\t\tisOpen: (workingCopy, editor) => {\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tcreateEditor: workingCopy => {\n\t\t\t\treturn disposables.add(accessor.instantiationService.createInstance(TestUntitledTextEditorInput, accessor.untitledTextEditorService.create({ initialValue: 'foo' })));\n\t\t\t}\n\t\t});\n\n\t\tconst secondHandler = tracker.testRestoreBackups({\n\t\t\thandles: workingCopy => {\n\t\t\t\treturn workingCopy.typeId.length === 0;\n\t\t\t},\n\t\t\tisOpen: (workingCopy, editor) => {\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tcreateEditor: workingCopy => {\n\t\t\t\treturn disposables.add(accessor.instantiationService.createInstance(TestUntitledTextEditorInput, accessor.untitledTextEditorService.create({ initialValue: 'foo' })));\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.all([firstHandler, secondHandler]);\n\n\t\tassert.strictEqual(accessor.editorService.count, 4);\n\t\tassert.ok(accessor.editorService.editors.every(editor => editor.isDirty()));\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 0);\n\n\t\tfor (const editor of accessor.editorService.editors) {\n\t\t\tassert.ok(editor instanceof TestUntitledTextEditorInput);\n\t\t\tassert.strictEqual(editor.resolved, true);\n\t\t}\n\t});\n\n\ttest('Restore backups (editors already opened)', async function () {\n\t\tconst [tracker, accessor] = await restoreBackupsInit();\n\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 0);\n\n\t\tlet handlesCounter = 0;\n\t\tlet isOpenCounter = 0;\n\n\t\tconst editor1 = disposables.add(accessor.instantiationService.createInstance(TestUntitledTextEditorInput, accessor.untitledTextEditorService.create({ initialValue: 'foo' })));\n\t\tconst editor2 = disposables.add(accessor.instantiationService.createInstance(TestUntitledTextEditorInput, accessor.untitledTextEditorService.create({ initialValue: 'foo' })));\n\n\t\tawait accessor.editorService.openEditors([{ editor: editor1 }, { editor: editor2 }]);\n\n\t\teditor1.resolved = false;\n\t\teditor2.resolved = false;\n\n\t\tawait tracker.testRestoreBackups({\n\t\t\thandles: workingCopy => {\n\t\t\t\thandlesCounter++;\n\n\t\t\t\treturn workingCopy.typeId === 'testBackupTypeId';\n\t\t\t},\n\t\t\tisOpen: (workingCopy, editor) => {\n\t\t\t\tisOpenCounter++;\n\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tcreateEditor: workingCopy => { throw new Error('unexpected'); }\n\t\t});\n\n\t\tassert.strictEqual(handlesCounter, 4);\n\t\tassert.strictEqual(isOpenCounter, 4);\n\n\t\tassert.strictEqual(accessor.editorService.count, 2);\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 2);\n\n\t\tfor (const editor of accessor.editorService.editors) {\n\t\t\tassert.ok(editor instanceof TestUntitledTextEditorInput);\n\n\t\t\t// assert that we only call `resolve` on inactive editors\n\t\t\tif (accessor.editorService.isVisible(editor)) {\n\t\t\t\tassert.strictEqual(editor.resolved, false);\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(editor.resolved, true);\n\t\t\t}\n\t\t}\n\t});\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { IEditorService } from '../../../editor/common/editorService.js';\nimport { EditorPart } from '../../../../browser/parts/editor/editorPart.js';\nimport { IEditorGroupsService } from '../../../editor/common/editorGroupsService.js';\nimport { EditorService } from '../../../editor/browser/editorService.js';\nimport { IUntitledTextResourceEditorInput } from '../../../../common/editor.js';\nimport { IWorkingCopyBackupService } from '../../common/workingCopyBackup.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite, toResource } from '../../../../../base/test/common/utils.js';\nimport { IFilesConfigurationService } from '../../../filesConfiguration/common/filesConfigurationService.js';\nimport { IWorkingCopyService } from '../../common/workingCopyService.js';\nimport { IWorkingCopyBackup } from '../../common/workingCopy.js';\nimport { ILogService } from '../../../../../platform/log/common/log.js';\nimport { ILifecycleService, LifecyclePhase } from '../../../lifecycle/common/lifecycle.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { UntitledTextEditorInput } from '../../../untitled/common/untitledTextEditorInput.js';\nimport { createEditorPart, InMemoryTestWorkingCopyBackupService, registerTestResourceEditor, TestServiceAccessor, toTypedWorkingCopyId, toUntypedWorkingCopyId, workbenchInstantiationService, workbenchTeardown } from '../../../../test/browser/workbenchTestServices.js';\nimport { TestWorkingCopy } from '../../../../test/common/workbenchTestServices.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { timeout } from '../../../../../base/common/async.js';\nimport { BrowserWorkingCopyBackupTracker } from '../../browser/workingCopyBackupTracker.js';\nimport { DisposableStore } from '../../../../../base/common/lifecycle.js';\nimport { IWorkingCopyEditorHandler, IWorkingCopyEditorService } from '../../common/workingCopyEditorService.js';\nimport { bufferToReadable, VSBuffer } from '../../../../../base/common/buffer.js';\nimport { isWindows } from '../../../../../base/common/platform.js';\nimport { Schemas } from '../../../../../base/common/network.js';\n\nsuite('WorkingCopyBackupTracker (browser)', function () {\n\tlet accessor: TestServiceAccessor;\n\tconst disposables = new DisposableStore();\n\n\tsetup(() => {\n\t\tdisposables.add(registerTestResourceEditor());\n\t});\n\n\tteardown(async () => {\n\t\tawait workbenchTeardown(accessor.instantiationService);\n\n\t\tdisposables.clear();\n\t});\n\n\tclass TestWorkingCopyBackupTracker extends BrowserWorkingCopyBackupTracker {\n\n\t\tconstructor(\n\t\t\t@IWorkingCopyBackupService workingCopyBackupService: IWorkingCopyBackupService,\n\t\t\t@IFilesConfigurationService filesConfigurationService: IFilesConfigurationService,\n\t\t\t@IWorkingCopyService workingCopyService: IWorkingCopyService,\n\t\t\t@ILifecycleService lifecycleService: ILifecycleService,\n\t\t\t@ILogService logService: ILogService,\n\t\t\t@IWorkingCopyEditorService workingCopyEditorService: IWorkingCopyEditorService,\n\t\t\t@IEditorService editorService: IEditorService,\n\t\t\t@IEditorGroupsService editorGroupService: IEditorGroupsService\n\t\t) {\n\t\t\tsuper(workingCopyBackupService, filesConfigurationService, workingCopyService, lifecycleService, logService, workingCopyEditorService, editorService, editorGroupService);\n\t\t}\n\n\t\tprotected override getBackupScheduleDelay(): number {\n\t\t\treturn 10; // Reduce timeout for tests\n\t\t}\n\n\t\tget pendingBackupOperationCount(): number { return this.pendingBackupOperations.size; }\n\n\t\tgetUnrestoredBackups() {\n\t\t\treturn this.unrestoredBackups;\n\t\t}\n\n\t\tasync testRestoreBackups(handler: IWorkingCopyEditorHandler): Promise<void> {\n\t\t\treturn super.restoreBackups(handler);\n\t\t}\n\t}\n\n\tclass TestUntitledTextEditorInput extends UntitledTextEditorInput {\n\n\t\tresolved = false;\n\n\t\toverride resolve() {\n\t\t\tthis.resolved = true;\n\n\t\t\treturn super.resolve();\n\t\t}\n\t}\n\n\tasync function createTracker(): Promise<{ accessor: TestServiceAccessor; part: EditorPart; tracker: TestWorkingCopyBackupTracker; workingCopyBackupService: InMemoryTestWorkingCopyBackupService; instantiationService: IInstantiationService }> {\n\t\tconst workingCopyBackupService = disposables.add(new InMemoryTestWorkingCopyBackupService());\n\t\tconst instantiationService = workbenchInstantiationService(undefined, disposables);\n\t\tinstantiationService.stub(IWorkingCopyBackupService, workingCopyBackupService);\n\n\t\tconst part = await createEditorPart(instantiationService, disposables);\n\t\tinstantiationService.stub(IEditorGroupsService, part);\n\n\t\tdisposables.add(registerTestResourceEditor());\n\n\t\tconst editorService: EditorService = disposables.add(instantiationService.createInstance(EditorService, undefined));\n\t\tinstantiationService.stub(IEditorService, editorService);\n\n\t\taccessor = instantiationService.createInstance(TestServiceAccessor);\n\n\t\tconst tracker = disposables.add(instantiationService.createInstance(TestWorkingCopyBackupTracker));\n\n\t\treturn { accessor, part, tracker, workingCopyBackupService: workingCopyBackupService, instantiationService };\n\t}\n\n\tasync function untitledBackupTest(untitled: IUntitledTextResourceEditorInput = { resource: undefined }): Promise<void> {\n\t\tconst { accessor, workingCopyBackupService } = await createTracker();\n\n\t\tconst untitledTextEditor = disposables.add((await accessor.editorService.openEditor(untitled))?.input as UntitledTextEditorInput);\n\t\tconst untitledTextModel = disposables.add(await untitledTextEditor.resolve());\n\n\t\tif (!untitled?.contents) {\n\t\t\tuntitledTextModel.textEditorModel?.setValue('Super Good');\n\t\t}\n\n\t\tawait workingCopyBackupService.joinBackupResource();\n\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(untitledTextModel), true);\n\n\t\tuntitledTextModel.dispose();\n\n\t\tawait workingCopyBackupService.joinDiscardBackup();\n\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(untitledTextModel), false);\n\t}\n\n\ttest('Track backups (untitled)', function () {\n\t\treturn untitledBackupTest();\n\t});\n\n\ttest('Track backups (untitled with initial contents)', function () {\n\t\treturn untitledBackupTest({ resource: undefined, contents: 'Foo Bar' });\n\t});\n\n\ttest('Track backups (custom)', async function () {\n\t\tconst { accessor, tracker, workingCopyBackupService } = await createTracker();\n\n\t\tclass TestBackupWorkingCopy extends TestWorkingCopy {\n\n\t\t\tconstructor(resource: URI) {\n\t\t\t\tsuper(resource);\n\n\t\t\t\tdisposables.add(accessor.workingCopyService.registerWorkingCopy(this));\n\t\t\t}\n\n\t\t\treadonly backupDelay = 10;\n\n\t\t\toverride async backup(token: CancellationToken): Promise<IWorkingCopyBackup> {\n\t\t\t\tawait timeout(0);\n\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}\n\n\t\tconst resource: URI = toResource.call(this, '/path/custom.txt');\n\t\tconst customWorkingCopy = disposables.add(new TestBackupWorkingCopy(resource));\n\n\t\t// Normal\n\t\tcustomWorkingCopy.setDirty(true);\n\t\tassert.strictEqual(tracker.pendingBackupOperationCount, 1);\n\t\tawait workingCopyBackupService.joinBackupResource();\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(customWorkingCopy), true);\n\n\t\tcustomWorkingCopy.setDirty(false);\n\t\tcustomWorkingCopy.setDirty(true);\n\t\tassert.strictEqual(tracker.pendingBackupOperationCount, 1);\n\t\tawait workingCopyBackupService.joinBackupResource();\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(customWorkingCopy), true);\n\n\t\tcustomWorkingCopy.setDirty(false);\n\t\tassert.strictEqual(tracker.pendingBackupOperationCount, 1);\n\t\tawait workingCopyBackupService.joinDiscardBackup();\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(customWorkingCopy), false);\n\n\t\t// Cancellation\n\t\tcustomWorkingCopy.setDirty(true);\n\t\tawait timeout(0);\n\t\tcustomWorkingCopy.setDirty(false);\n\t\tassert.strictEqual(tracker.pendingBackupOperationCount, 1);\n\t\tawait workingCopyBackupService.joinDiscardBackup();\n\t\tassert.strictEqual(workingCopyBackupService.hasBackupSync(customWorkingCopy), false);\n\t});\n\n\tasync function restoreBackupsInit(): Promise<[TestWorkingCopyBackupTracker, TestServiceAccessor]> {\n\t\tconst fooFile = URI.file(isWindows ? 'c:\\\\Foo' : '/Foo');\n\t\tconst barFile = URI.file(isWindows ? 'c:\\\\Bar' : '/Bar');\n\t\tconst untitledFile1 = URI.from({ scheme: Schemas.untitled, path: 'Untitled-1' });\n\t\tconst untitledFile2 = URI.from({ scheme: Schemas.untitled, path: 'Untitled-2' });\n\n\t\tconst workingCopyBackupService = disposables.add(new InMemoryTestWorkingCopyBackupService());\n\t\tconst instantiationService = workbenchInstantiationService(undefined, disposables);\n\t\tinstantiationService.stub(IWorkingCopyBackupService, workingCopyBackupService);\n\n\t\tconst part = await createEditorPart(instantiationService, disposables);\n\t\tinstantiationService.stub(IEditorGroupsService, part);\n\n\t\tconst editorService: EditorService = disposables.add(instantiationService.createInstance(EditorService, undefined));\n\t\tinstantiationService.stub(IEditorService, editorService);\n\n\t\taccessor = instantiationService.createInstance(TestServiceAccessor);\n\n\t\t// Backup 2 normal files and 2 untitled files\n\t\tconst untitledFile1WorkingCopyId = toUntypedWorkingCopyId(untitledFile1);\n\t\tconst untitledFile2WorkingCopyId = toTypedWorkingCopyId(untitledFile2);\n\t\tawait workingCopyBackupService.backup(untitledFile1WorkingCopyId, bufferToReadable(VSBuffer.fromString('untitled-1')));\n\t\tawait workingCopyBackupService.backup(untitledFile2WorkingCopyId, bufferToReadable(VSBuffer.fromString('untitled-2')));\n\n\t\tconst fooFileWorkingCopyId = toUntypedWorkingCopyId(fooFile);\n\t\tconst barFileWorkingCopyId = toTypedWorkingCopyId(barFile);\n\t\tawait workingCopyBackupService.backup(fooFileWorkingCopyId, bufferToReadable(VSBuffer.fromString('fooFile')));\n\t\tawait workingCopyBackupService.backup(barFileWorkingCopyId, bufferToReadable(VSBuffer.fromString('barFile')));\n\n\t\tconst tracker = disposables.add(instantiationService.createInstance(TestWorkingCopyBackupTracker));\n\n\t\taccessor.lifecycleService.phase = LifecyclePhase.Restored;\n\n\t\treturn [tracker, accessor];\n\t}\n\n\ttest('Restore backups (basics, some handled)', async function () {\n\t\tconst [tracker, accessor] = await restoreBackupsInit();\n\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 0);\n\n\t\tlet handlesCounter = 0;\n\t\tlet isOpenCounter = 0;\n\t\tlet createEditorCounter = 0;\n\n\t\tawait tracker.testRestoreBackups({\n\t\t\thandles: workingCopy => {\n\t\t\t\thandlesCounter++;\n\n\t\t\t\treturn workingCopy.typeId === 'testBackupTypeId';\n\t\t\t},\n\t\t\tisOpen: (workingCopy, editor) => {\n\t\t\t\tisOpenCounter++;\n\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tcreateEditor: workingCopy => {\n\t\t\t\tcreateEditorCounter++;\n\n\t\t\t\treturn disposables.add(accessor.instantiationService.createInstance(TestUntitledTextEditorInput, accessor.untitledTextEditorService.create({ initialValue: 'foo' })));\n\t\t\t}\n\t\t});\n\n\t\tassert.strictEqual(handlesCounter, 4);\n\t\tassert.strictEqual(isOpenCounter, 0);\n\t\tassert.strictEqual(createEditorCounter, 2);\n\n\t\tassert.strictEqual(accessor.editorService.count, 2);\n\t\tassert.ok(accessor.editorService.editors.every(editor => editor.isDirty()));\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 2);\n\n\t\tfor (const editor of accessor.editorService.editors) {\n\t\t\tassert.ok(editor instanceof TestUntitledTextEditorInput);\n\t\t\tassert.strictEqual(editor.resolved, true);\n\t\t}\n\t});\n\n\ttest('Restore backups (basics, none handled)', async function () {\n\t\tconst [tracker, accessor] = await restoreBackupsInit();\n\n\t\tawait tracker.testRestoreBackups({\n\t\t\thandles: workingCopy => false,\n\t\t\tisOpen: (workingCopy, editor) => { throw new Error('unexpected'); },\n\t\t\tcreateEditor: workingCopy => { throw new Error('unexpected'); }\n\t\t});\n\n\t\tassert.strictEqual(accessor.editorService.count, 0);\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 4);\n\t});\n\n\ttest('Restore backups (basics, error case)', async function () {\n\t\tconst [tracker] = await restoreBackupsInit();\n\n\t\ttry {\n\t\t\tawait tracker.testRestoreBackups({\n\t\t\t\thandles: workingCopy => true,\n\t\t\t\tisOpen: (workingCopy, editor) => { throw new Error('unexpected'); },\n\t\t\t\tcreateEditor: workingCopy => { throw new Error('unexpected'); }\n\t\t\t});\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 4);\n\t});\n\n\ttest('Restore backups (multiple handlers)', async function () {\n\t\tconst [tracker, accessor] = await restoreBackupsInit();\n\n\t\tconst firstHandler = tracker.testRestoreBackups({\n\t\t\thandles: workingCopy => {\n\t\t\t\treturn workingCopy.typeId === 'testBackupTypeId';\n\t\t\t},\n\t\t\tisOpen: (workingCopy, editor) => {\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tcreateEditor: workingCopy => {\n\t\t\t\treturn disposables.add(accessor.instantiationService.createInstance(TestUntitledTextEditorInput, accessor.untitledTextEditorService.create({ initialValue: 'foo' })));\n\t\t\t}\n\t\t});\n\n\t\tconst secondHandler = tracker.testRestoreBackups({\n\t\t\thandles: workingCopy => {\n\t\t\t\treturn workingCopy.typeId.length === 0;\n\t\t\t},\n\t\t\tisOpen: (workingCopy, editor) => {\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tcreateEditor: workingCopy => {\n\t\t\t\treturn disposables.add(accessor.instantiationService.createInstance(TestUntitledTextEditorInput, accessor.untitledTextEditorService.create({ initialValue: 'foo' })));\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.all([firstHandler, secondHandler]);\n\n\t\tassert.strictEqual(accessor.editorService.count, 4);\n\t\tassert.ok(accessor.editorService.editors.every(editor => editor.isDirty()));\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 0);\n\n\t\tfor (const editor of accessor.editorService.editors) {\n\t\t\tassert.ok(editor instanceof TestUntitledTextEditorInput);\n\t\t\tassert.strictEqual(editor.resolved, true);\n\t\t}\n\t});\n\n\ttest('Restore backups (editors already opened)', async function () {\n\t\tconst [tracker, accessor] = await restoreBackupsInit();\n\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 0);\n\n\t\tlet handlesCounter = 0;\n\t\tlet isOpenCounter = 0;\n\n\t\tconst editor1 = disposables.add(accessor.instantiationService.createInstance(TestUntitledTextEditorInput, accessor.untitledTextEditorService.create({ initialValue: 'foo' })));\n\t\tconst editor2 = disposables.add(accessor.instantiationService.createInstance(TestUntitledTextEditorInput, accessor.untitledTextEditorService.create({ initialValue: 'foo' })));\n\n\t\tawait accessor.editorService.openEditors([{ editor: editor1 }, { editor: editor2 }]);\n\n\t\teditor1.resolved = false;\n\t\teditor2.resolved = false;\n\n\t\tawait tracker.testRestoreBackups({\n\t\t\thandles: workingCopy => {\n\t\t\t\thandlesCounter++;\n\n\t\t\t\treturn workingCopy.typeId === 'testBackupTypeId';\n\t\t\t},\n\t\t\tisOpen: (workingCopy, editor) => {\n\t\t\t\tisOpenCounter++;\n\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tcreateEditor: workingCopy => { throw new Error('unexpected'); }\n\t\t});\n\n\t\tassert.strictEqual(handlesCounter, 4);\n\t\tassert.strictEqual(isOpenCounter, 4);\n\n\t\tassert.strictEqual(accessor.editorService.count, 2);\n\t\tassert.strictEqual(tracker.getUnrestoredBackups().size, 2);\n\n\t\tfor (const editor of accessor.editorService.editors) {\n\t\t\tassert.ok(editor instanceof TestUntitledTextEditorInput);\n\n\t\t\t// assert that we only call `resolve` on inactive editors\n\t\t\tif (accessor.editorService.isVisible(editor)) {\n\t\t\t\tassert.strictEqual(editor.resolved, false);\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(editor.resolved, true);\n\t\t\t}\n\t\t}\n\t});\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n});\n"]}