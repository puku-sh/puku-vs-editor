{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/extensions/common/extensionDescriptionRegistry.ts","vs/workbench/services/extensions/common/extensionDescriptionRegistry.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,mBAAmB,EAAE,sBAAsB,EAAE,sBAAsB,EAAyB,MAAM,sDAAsD,CAAC;AAClK,OAAO,EAAE,OAAO,EAAE,MAAM,kCAAkC,CAAC;AAC3D,OAAO,KAAK,IAAI,MAAM,iCAAiC,CAAC;AACxD,OAAO,EAAE,UAAU,EAAe,YAAY,EAAE,MAAM,sCAAsC,CAAC;AAC7F,OAAO,EAAE,oBAAoB,EAAE,MAAM,kCAAkC,CAAC;AAExE,MAAM,OAAO,qBAAqB;IACjC,YACiB,SAAiB,EACjB,mBAA4C;QAD5C,cAAS,GAAT,SAAS,CAAQ;QACjB,wBAAmB,GAAnB,mBAAmB,CAAyB;IACzD,CAAC;CACL;AAYD,MAAM,OAAO,4BAA6B,SAAQ,UAAU;IAEpD,MAAM,CAAC,eAAe,CAAC,WAAyC,EAAE,UAAwC,EAAE,cAA4C;QAC9J,IAAI,UAAU,CAAC,uBAAuB,CAAC,WAAW,CAAC,EAAE,CAAC;YACrD,wBAAwB;YACxB,OAAO,KAAK,CAAC;QACd,CAAC;QACD,MAAM,oBAAoB,GAAG,cAAc,CAAC,uBAAuB,CAAC,WAAW,CAAC,CAAC;QACjF,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAC3B,oBAAoB;YACpB,OAAO,KAAK,CAAC;QACd,CAAC;QACD,IAAI,CAAC,oBAAoB,CAAC,IAAI,IAAI,oBAAoB,CAAC,OAAO,CAAC,IAAI,oBAAoB,CAAC,GAAG,KAAK,MAAM,EAAE,CAAC;YACxG,OAAO,IAAI,CAAC;QACb,CAAC;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAWD,YACkB,uBAAgD,EACjE,qBAA8C;QAE9C,KAAK,EAAE,CAAC;QAHS,4BAAuB,GAAvB,uBAAuB,CAAyB;QAVjD,iBAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QACpD,gBAAW,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;QAE9C,eAAU,GAAW,CAAC,CAAC;QAW9B,IAAI,CAAC,sBAAsB,GAAG,qBAAqB,CAAC;QACpD,IAAI,CAAC,WAAW,EAAE,CAAC;IACpB,CAAC;IAEO,WAAW;QAClB,8EAA8E;QAC9E,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAE/C,IAAI,CAAC,cAAc,GAAG,IAAI,sBAAsB,EAAyB,CAAC;QAC1E,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;QACzB,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG,EAAmC,CAAC;QAEjE,KAAK,MAAM,oBAAoB,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAChE,IAAI,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,oBAAoB,CAAC,UAAU,CAAC,EAAE,CAAC;gBAC9D,0BAA0B;gBAC1B,OAAO,CAAC,KAAK,CAAC,aAAa,GAAG,oBAAoB,CAAC,UAAU,CAAC,KAAK,GAAG,yBAAyB,CAAC,CAAC;gBACjG,SAAS;YACV,CAAC;YAED,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,oBAAoB,CAAC,UAAU,EAAE,oBAAoB,CAAC,CAAC;YAC/E,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;YAE/C,MAAM,gBAAgB,GAAG,IAAI,CAAC,uBAAuB,CAAC,oBAAoB,CAAC,oBAAoB,CAAC,CAAC;YACjG,KAAK,MAAM,eAAe,IAAI,gBAAgB,EAAE,CAAC;gBAChD,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,eAAe,CAAC,EAAE,CAAC;oBAC/C,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,eAAe,EAAE,EAAE,CAAC,CAAC;gBAC9C,CAAC;gBACD,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,eAAe,CAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;YACtE,CAAC;QACF,CAAC;IACF,CAAC;IAEM,GAAG,CAAC,qBAA8C;QACxD,IAAI,CAAC,sBAAsB,GAAG,qBAAqB,CAAC;QACpD,IAAI,CAAC,WAAW,EAAE,CAAC;QACnB,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAClC,OAAO;YACN,SAAS,EAAE,IAAI,CAAC,UAAU;SAC1B,CAAC;IACH,CAAC;IAEM,eAAe,CAAC,KAA8B,EAAE,QAA+B;QACrF,6FAA6F;QAC7F,mCAAmC;QACnC,IAAI,CAAC,sBAAsB,GAAG,gBAAgB,CAAC,IAAI,CAAC,sBAAsB,EAAE,QAAQ,CAAC,CAAC;QAEtF,qCAAqC;QACrC,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAExE,yCAAyC;QACzC,MAAM,OAAO,GAAG,4BAA4B,CAAC,sBAAsB,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC;QACjG,IAAI,CAAC,sBAAsB,GAAG,gBAAgB,CAAC,IAAI,CAAC,sBAAsB,EAAE,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;QAEhH,IAAI,CAAC,WAAW,EAAE,CAAC;QACnB,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAClC,OAAO,IAAI,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IAC5D,CAAC;IAEO,MAAM,CAAC,sBAAsB,CAAC,qBAA8C;QACnF,MAAM,CAAC,GAAG,IAAI;YAAA;gBAEL,UAAK,GAAG,IAAI,GAAG,EAAoB,CAAC;gBACpC,cAAS,GAAG,IAAI,GAAG,EAAU,CAAC;gBAC9B,cAAS,GAAa,EAAE,CAAC;YAuClC,CAAC;YArCA,OAAO,CAAC,EAAU;gBACjB,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;oBAC7B,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;oBACvB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBACzB,CAAC;YACF,CAAC;YAED,MAAM,CAAC,IAAY,EAAE,EAAU;gBAC9B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBACnB,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;gBACjB,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;oBAC1B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBAChC,CAAC;qBAAM,CAAC;oBACP,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC5B,CAAC;YACF,CAAC;YAED,OAAO,CAAC,EAAU;gBACjB,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;oBACxB,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAE,CAAC;gBAC5B,CAAC;gBACD,OAAO,EAAE,CAAC;YACX,CAAC;YAED,eAAe,CAAC,EAAU,EAAE,IAAiB;gBAC5C,MAAM,YAAY,GAAG,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;gBACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC9C,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;wBAChC,OAAO,KAAK,CAAC;oBACd,CAAC;gBACF,CAAC;gBACD,OAAO,IAAI,CAAC;YACb,CAAC;YAED,QAAQ;gBACP,OAAO,IAAI,CAAC,SAAS,CAAC;YACvB,CAAC;SACD,CAAC;QAEF,MAAM,KAAK,GAAG,IAAI,sBAAsB,EAAyB,CAAC;QAClE,KAAK,MAAM,oBAAoB,IAAI,qBAAqB,EAAE,CAAC;YAC1D,KAAK,CAAC,GAAG,CAAC,oBAAoB,CAAC,UAAU,EAAE,oBAAoB,CAAC,CAAC;YACjE,IAAI,oBAAoB,CAAC,qBAAqB,EAAE,CAAC;gBAChD,KAAK,MAAM,KAAK,IAAI,oBAAoB,CAAC,qBAAqB,EAAE,CAAC;oBAChE,CAAC,CAAC,MAAM,CAAC,mBAAmB,CAAC,KAAK,CAAC,oBAAoB,CAAC,UAAU,CAAC,EAAE,mBAAmB,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;gBACxG,CAAC;YACF,CAAC;QACF,CAAC;QAED,uDAAuD;QACvD,MAAM,IAAI,GAAG,IAAI,GAAG,EAAU,CAAC;QAC/B,CAAC,CAAC,QAAQ,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;QAElF,gDAAgD;QAChD,MAAM,KAAK,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;QAEvD,IAAI,YAAqB,CAAC;QAC1B,GAAG,CAAC;YACH,YAAY,GAAG,KAAK,CAAC;YAErB,8CAA8C;YAC9C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACvC,MAAM,EAAE,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBAEpB,IAAI,CAAC,CAAC,eAAe,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC;oBACjC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBACnB,CAAC,EAAE,CAAC;oBACJ,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;oBACb,YAAY,GAAG,IAAI,CAAC;gBACrB,CAAC;YACF,CAAC;QACF,CAAC,QAAQ,YAAY,EAAE;QAEvB,6CAA6C;QAC7C,OAAO,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAE,CAAC,CAAC;IACxC,CAAC;IAEM,uBAAuB,CAAC,eAAuB;QACrD,OAAO,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;IACjD,CAAC;IAEM,iBAAiB,CAAC,WAAgC;QACxD,OAAO,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IAC7C,CAAC;IAEM,0CAA0C,CAAC,eAAuB;QACxE,MAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;QAC5D,OAAO,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IAC9C,CAAC;IAEM,2BAA2B;QACjC,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACrC,CAAC;IAEM,WAAW;QACjB,OAAO,IAAI,oCAAoC,CAC9C,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,2BAA2B,EAAE,CAClC,CAAC;IACH,CAAC;IAEM,uBAAuB,CAAC,WAAyC;QACvE,MAAM,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QACvD,OAAO,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC;IAC1C,CAAC;IAEM,6BAA6B,CAAC,IAAY;QAChD,KAAK,MAAM,oBAAoB,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACxD,IAAI,oBAAoB,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC;gBACxC,OAAO,oBAAoB,CAAC;YAC7B,CAAC;QACF,CAAC;QACD,OAAO,SAAS,CAAC;IAClB,CAAC;IAEM,iCAAiC,CAAC,WAAyC,EAAE,IAAwB;QAC3G,OAAO,CACN,IAAI,CAAC,uBAAuB,CAAC,WAAW,CAAC;eACtC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAChE,CAAC;IACH,CAAC;CACD;AAED,MAAM,OAAO,oCAAoC;IAChD,YACiB,SAAiB,EACjB,UAA4C;QAD5C,cAAS,GAAT,SAAS,CAAQ;QACjB,eAAU,GAAV,UAAU,CAAkC;IACzD,CAAC;CACL;AAMD,MAAM,OAAO,oCAAoC;IAKhD,YAAY,sBAA+C;QAF1C,UAAK,GAAG,IAAI,IAAI,EAAE,CAAC;QAGnC,IAAI,CAAC,OAAO,GAAG,IAAI,4BAA4B,CAAC,sBAAsB,EAAE,EAAE,CAAC,CAAC;IAC7E,CAAC;IAEM,KAAK,CAAC,WAAW,CAAC,YAAoB;QAC5C,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QACpD,OAAO,IAAI,gCAAgC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACzD,CAAC;IAEM,eAAe,CAAC,YAA8C,EAAE,KAA8B,EAAE,QAA+B;QACrI,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,CAAC;YACvC,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;QACrC,CAAC;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IACtD,CAAC;IAEM,uBAAuB,CAAC,eAAuB;QACrD,OAAO,IAAI,CAAC,OAAO,CAAC,uBAAuB,CAAC,eAAe,CAAC,CAAC;IAC9D,CAAC;IACM,iBAAiB,CAAC,WAAgC;QACxD,OAAO,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;IACpD,CAAC;IACM,0CAA0C,CAAC,eAAuB;QACxE,OAAO,IAAI,CAAC,OAAO,CAAC,0CAA0C,CAAC,eAAe,CAAC,CAAC;IACjF,CAAC;IACM,2BAA2B;QACjC,OAAO,IAAI,CAAC,OAAO,CAAC,2BAA2B,EAAE,CAAC;IACnD,CAAC;IACM,WAAW;QACjB,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;IACnC,CAAC;IACM,uBAAuB,CAAC,WAAyC;QACvE,OAAO,IAAI,CAAC,OAAO,CAAC,uBAAuB,CAAC,WAAW,CAAC,CAAC;IAC1D,CAAC;IACM,6BAA6B,CAAC,IAAY;QAChD,OAAO,IAAI,CAAC,OAAO,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC;IACzD,CAAC;IACM,iCAAiC,CAAC,WAAyC,EAAE,IAAwB;QAC3G,OAAO,IAAI,CAAC,OAAO,CAAC,iCAAiC,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;IAC1E,CAAC;CACD;AAED,MAAM,OAAO,gCAAiC,SAAQ,UAAU;IAI/D,YACkB,SAA+C,EAChE,IAAiB;QAEjB,KAAK,EAAE,CAAC;QAHS,cAAS,GAAT,SAAS,CAAsC;QAHzD,gBAAW,GAAG,KAAK,CAAC;QAO3B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACtB,CAAC;IAEM,aAAa,CAAC,QAA8C;QAClE,OAAO,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,SAAS,KAAK,QAAQ,CAAC;IACzD,CAAC;CACD;AAED,MAAM,YAAY;IAIjB,YACiB,IAAY;QAAZ,SAAI,GAAJ,IAAI,CAAQ;QAE5B,MAAM,aAAa,GAAG,oBAAoB,EAAe,CAAC;QAC1D,IAAI,CAAC,OAAO,GAAG,aAAa,CAAC,OAAO,CAAC;QACrC,IAAI,CAAC,QAAQ,GAAG,aAAa,CAAC,OAAO,CAAC;IACvC,CAAC;IAED,OAAO,CAAC,KAAkB;QACzB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IACtB,CAAC;CACD;AAED,MAAM,IAAI;IAAV;QACkB,sBAAiB,GAAmB,EAAE,CAAC;QAChD,cAAS,GAAG,KAAK,CAAC;IA0C3B,CAAC;IAxCO,KAAK,CAAC,OAAO,CAAC,YAAoB;QACxC,MAAM,QAAQ,GAAG,IAAI,YAAY,CAAC,YAAY,CAAC,CAAC;QAChD,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACtC,IAAI,CAAC,QAAQ,EAAE,CAAC;QAChB,OAAO,QAAQ,CAAC,OAAO,CAAC;IACzB,CAAC;IAEO,QAAQ;QACf,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACpB,qBAAqB;YACrB,OAAO;QACR,CAAC;QACD,IAAI,IAAI,CAAC,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACzC,4BAA4B;YAC5B,OAAO;QACR,CAAC;QAED,MAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAG,CAAC;QAEjD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,IAAI,iBAAiB,GAAG,IAAI,CAAC;QAE7B,MAAM,6BAA6B,GAAG,UAAU,CAAC,GAAG,EAAE;YACrD,IAAI,iBAAiB,EAAE,CAAC;gBACvB,OAAO,CAAC,IAAI,CAAC,sBAAsB,QAAQ,CAAC,IAAI,oEAAoE,CAAC,CAAC;YACvH,CAAC;QACF,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAE/B,MAAM,WAAW,GAAG,GAAG,EAAE;YACxB,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBACxB,OAAO;YACR,CAAC;YACD,YAAY,CAAC,6BAA6B,CAAC,CAAC;YAC5C,iBAAiB,GAAG,KAAK,CAAC;YAC1B,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;YACvB,IAAI,CAAC,QAAQ,EAAE,CAAC;QACjB,CAAC,CAAC;QAEF,QAAQ,CAAC,OAAO,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC;IAC7C,CAAC;CACD;AAED,IAAW,UAIV;AAJD,WAAW,UAAU;IACpB,iDAAW,CAAA;IACX,2CAAQ,CAAA;IACR,yCAAO,CAAA;AACR,CAAC,EAJU,UAAU,KAAV,UAAU,QAIpB;AAED;;;;;;;GAOG;AACH,SAAS,YAAY,CAAC,CAAwB,EAAE,CAAwB;IACvE,MAAM,WAAW,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,4BAAoB,CAAC,CAAC,CAAC,CAAC,kBAAkB,CAAC,CAAC,wBAAgB,CAAC,wBAAgB,CAAC,CAAC;IACjH,MAAM,WAAW,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,4BAAoB,CAAC,CAAC,CAAC,CAAC,kBAAkB,CAAC,CAAC,wBAAgB,CAAC,wBAAgB,CAAC,CAAC;IACjH,IAAI,WAAW,KAAK,WAAW,EAAE,CAAC;QACjC,OAAO,WAAW,GAAG,WAAW,CAAC;IAClC,CAAC;IACD,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACnE,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACnE,IAAI,YAAY,GAAG,YAAY,EAAE,CAAC;QACjC,OAAO,CAAC,CAAC,CAAC;IACX,CAAC;IACD,IAAI,YAAY,GAAG,YAAY,EAAE,CAAC;QACjC,OAAO,CAAC,CAAC;IACV,CAAC;IACD,OAAO,CAAC,CAAC;AACV,CAAC;AAED,SAAS,gBAAgB,CAAC,GAA4B,EAAE,QAA+B;IACtF,MAAM,WAAW,GAAG,IAAI,sBAAsB,CAAC,QAAQ,CAAC,CAAC;IACzD,OAAO,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,WAAW,CAAC,GAAG,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC;AACxE,CAAC","file":"extensionDescriptionRegistry.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ExtensionIdentifier, ExtensionIdentifierMap, ExtensionIdentifierSet, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as path from '../../../../base/common/path.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { promiseWithResolvers } from '../../../../base/common/async.js';\n\nexport class DeltaExtensionsResult {\n\tconstructor(\n\t\tpublic readonly versionId: number,\n\t\tpublic readonly removedDueToLooping: IExtensionDescription[]\n\t) { }\n}\n\nexport interface IReadOnlyExtensionDescriptionRegistry {\n\tcontainsActivationEvent(activationEvent: string): boolean;\n\tcontainsExtension(extensionId: ExtensionIdentifier): boolean;\n\tgetExtensionDescriptionsForActivationEvent(activationEvent: string): IExtensionDescription[];\n\tgetAllExtensionDescriptions(): IExtensionDescription[];\n\tgetExtensionDescription(extensionId: ExtensionIdentifier | string): IExtensionDescription | undefined;\n\tgetExtensionDescriptionByUUID(uuid: string): IExtensionDescription | undefined;\n\tgetExtensionDescriptionByIdOrUUID(extensionId: ExtensionIdentifier | string, uuid: string | undefined): IExtensionDescription | undefined;\n}\n\nexport class ExtensionDescriptionRegistry extends Disposable implements IReadOnlyExtensionDescriptionRegistry {\n\n\tpublic static isHostExtension(extensionId: ExtensionIdentifier | string, myRegistry: ExtensionDescriptionRegistry, globalRegistry: ExtensionDescriptionRegistry): boolean {\n\t\tif (myRegistry.getExtensionDescription(extensionId)) {\n\t\t\t// I have this extension\n\t\t\treturn false;\n\t\t}\n\t\tconst extensionDescription = globalRegistry.getExtensionDescription(extensionId);\n\t\tif (!extensionDescription) {\n\t\t\t// unknown extension\n\t\t\treturn false;\n\t\t}\n\t\tif ((extensionDescription.main || extensionDescription.browser) && extensionDescription.api === 'none') {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate readonly _onDidChange = this._register(new Emitter<void>());\n\tpublic readonly onDidChange = this._onDidChange.event;\n\n\tprivate _versionId: number = 0;\n\tprivate _extensionDescriptions: IExtensionDescription[];\n\tprivate _extensionsMap!: ExtensionIdentifierMap<IExtensionDescription>;\n\tprivate _extensionsArr!: IExtensionDescription[];\n\tprivate _activationMap!: Map<string, IExtensionDescription[]>;\n\n\tconstructor(\n\t\tprivate readonly _activationEventsReader: IActivationEventsReader,\n\t\textensionDescriptions: IExtensionDescription[]\n\t) {\n\t\tsuper();\n\t\tthis._extensionDescriptions = extensionDescriptions;\n\t\tthis._initialize();\n\t}\n\n\tprivate _initialize(): void {\n\t\t// Ensure extensions are stored in the order: builtin, user, under development\n\t\tthis._extensionDescriptions.sort(extensionCmp);\n\n\t\tthis._extensionsMap = new ExtensionIdentifierMap<IExtensionDescription>();\n\t\tthis._extensionsArr = [];\n\t\tthis._activationMap = new Map<string, IExtensionDescription[]>();\n\n\t\tfor (const extensionDescription of this._extensionDescriptions) {\n\t\t\tif (this._extensionsMap.has(extensionDescription.identifier)) {\n\t\t\t\t// No overwriting allowed!\n\t\t\t\tconsole.error('Extension `' + extensionDescription.identifier.value + '` is already registered');\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._extensionsMap.set(extensionDescription.identifier, extensionDescription);\n\t\t\tthis._extensionsArr.push(extensionDescription);\n\n\t\t\tconst activationEvents = this._activationEventsReader.readActivationEvents(extensionDescription);\n\t\t\tfor (const activationEvent of activationEvents) {\n\t\t\t\tif (!this._activationMap.has(activationEvent)) {\n\t\t\t\t\tthis._activationMap.set(activationEvent, []);\n\t\t\t\t}\n\t\t\t\tthis._activationMap.get(activationEvent)!.push(extensionDescription);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic set(extensionDescriptions: IExtensionDescription[]): { versionId: number } {\n\t\tthis._extensionDescriptions = extensionDescriptions;\n\t\tthis._initialize();\n\t\tthis._versionId++;\n\t\tthis._onDidChange.fire(undefined);\n\t\treturn {\n\t\t\tversionId: this._versionId\n\t\t};\n\t}\n\n\tpublic deltaExtensions(toAdd: IExtensionDescription[], toRemove: ExtensionIdentifier[]): DeltaExtensionsResult {\n\t\t// It is possible that an extension is removed, only to be added again at a different version\n\t\t// so we will first handle removals\n\t\tthis._extensionDescriptions = removeExtensions(this._extensionDescriptions, toRemove);\n\n\t\t// Then, handle the extensions to add\n\t\tthis._extensionDescriptions = this._extensionDescriptions.concat(toAdd);\n\n\t\t// Immediately remove looping extensions!\n\t\tconst looping = ExtensionDescriptionRegistry._findLoopingExtensions(this._extensionDescriptions);\n\t\tthis._extensionDescriptions = removeExtensions(this._extensionDescriptions, looping.map(ext => ext.identifier));\n\n\t\tthis._initialize();\n\t\tthis._versionId++;\n\t\tthis._onDidChange.fire(undefined);\n\t\treturn new DeltaExtensionsResult(this._versionId, looping);\n\t}\n\n\tprivate static _findLoopingExtensions(extensionDescriptions: IExtensionDescription[]): IExtensionDescription[] {\n\t\tconst G = new class {\n\n\t\t\tprivate _arcs = new Map<string, string[]>();\n\t\t\tprivate _nodesSet = new Set<string>();\n\t\t\tprivate _nodesArr: string[] = [];\n\n\t\t\taddNode(id: string): void {\n\t\t\t\tif (!this._nodesSet.has(id)) {\n\t\t\t\t\tthis._nodesSet.add(id);\n\t\t\t\t\tthis._nodesArr.push(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taddArc(from: string, to: string): void {\n\t\t\t\tthis.addNode(from);\n\t\t\t\tthis.addNode(to);\n\t\t\t\tif (this._arcs.has(from)) {\n\t\t\t\t\tthis._arcs.get(from)!.push(to);\n\t\t\t\t} else {\n\t\t\t\t\tthis._arcs.set(from, [to]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgetArcs(id: string): string[] {\n\t\t\t\tif (this._arcs.has(id)) {\n\t\t\t\t\treturn this._arcs.get(id)!;\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\thasOnlyGoodArcs(id: string, good: Set<string>): boolean {\n\t\t\t\tconst dependencies = G.getArcs(id);\n\t\t\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\t\t\tif (!good.has(dependencies[i])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tgetNodes(): string[] {\n\t\t\t\treturn this._nodesArr;\n\t\t\t}\n\t\t};\n\n\t\tconst descs = new ExtensionIdentifierMap<IExtensionDescription>();\n\t\tfor (const extensionDescription of extensionDescriptions) {\n\t\t\tdescs.set(extensionDescription.identifier, extensionDescription);\n\t\t\tif (extensionDescription.extensionDependencies) {\n\t\t\t\tfor (const depId of extensionDescription.extensionDependencies) {\n\t\t\t\t\tG.addArc(ExtensionIdentifier.toKey(extensionDescription.identifier), ExtensionIdentifier.toKey(depId));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// initialize with all extensions with no dependencies.\n\t\tconst good = new Set<string>();\n\t\tG.getNodes().filter(id => G.getArcs(id).length === 0).forEach(id => good.add(id));\n\n\t\t// all other extensions will be processed below.\n\t\tconst nodes = G.getNodes().filter(id => !good.has(id));\n\n\t\tlet madeProgress: boolean;\n\t\tdo {\n\t\t\tmadeProgress = false;\n\n\t\t\t// find one extension which has only good deps\n\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\tconst id = nodes[i];\n\n\t\t\t\tif (G.hasOnlyGoodArcs(id, good)) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tgood.add(id);\n\t\t\t\t\tmadeProgress = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (madeProgress);\n\n\t\t// The remaining nodes are bad and have loops\n\t\treturn nodes.map(id => descs.get(id)!);\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\treturn this._activationMap.has(activationEvent);\n\t}\n\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\treturn this._extensionsMap.has(extensionId);\n\t}\n\n\tpublic getExtensionDescriptionsForActivationEvent(activationEvent: string): IExtensionDescription[] {\n\t\tconst extensions = this._activationMap.get(activationEvent);\n\t\treturn extensions ? extensions.slice(0) : [];\n\t}\n\n\tpublic getAllExtensionDescriptions(): IExtensionDescription[] {\n\t\treturn this._extensionsArr.slice(0);\n\t}\n\n\tpublic getSnapshot(): ExtensionDescriptionRegistrySnapshot {\n\t\treturn new ExtensionDescriptionRegistrySnapshot(\n\t\t\tthis._versionId,\n\t\t\tthis.getAllExtensionDescriptions()\n\t\t);\n\t}\n\n\tpublic getExtensionDescription(extensionId: ExtensionIdentifier | string): IExtensionDescription | undefined {\n\t\tconst extension = this._extensionsMap.get(extensionId);\n\t\treturn extension ? extension : undefined;\n\t}\n\n\tpublic getExtensionDescriptionByUUID(uuid: string): IExtensionDescription | undefined {\n\t\tfor (const extensionDescription of this._extensionsArr) {\n\t\t\tif (extensionDescription.uuid === uuid) {\n\t\t\t\treturn extensionDescription;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic getExtensionDescriptionByIdOrUUID(extensionId: ExtensionIdentifier | string, uuid: string | undefined): IExtensionDescription | undefined {\n\t\treturn (\n\t\t\tthis.getExtensionDescription(extensionId)\n\t\t\t?? (uuid ? this.getExtensionDescriptionByUUID(uuid) : undefined)\n\t\t);\n\t}\n}\n\nexport class ExtensionDescriptionRegistrySnapshot {\n\tconstructor(\n\t\tpublic readonly versionId: number,\n\t\tpublic readonly extensions: readonly IExtensionDescription[]\n\t) { }\n}\n\nexport interface IActivationEventsReader {\n\treadActivationEvents(extensionDescription: IExtensionDescription): string[];\n}\n\nexport class LockableExtensionDescriptionRegistry implements IReadOnlyExtensionDescriptionRegistry {\n\n\tprivate readonly _actual: ExtensionDescriptionRegistry;\n\tprivate readonly _lock = new Lock();\n\n\tconstructor(activationEventsReader: IActivationEventsReader) {\n\t\tthis._actual = new ExtensionDescriptionRegistry(activationEventsReader, []);\n\t}\n\n\tpublic async acquireLock(customerName: string): Promise<ExtensionDescriptionRegistryLock> {\n\t\tconst lock = await this._lock.acquire(customerName);\n\t\treturn new ExtensionDescriptionRegistryLock(this, lock);\n\t}\n\n\tpublic deltaExtensions(acquiredLock: ExtensionDescriptionRegistryLock, toAdd: IExtensionDescription[], toRemove: ExtensionIdentifier[]): DeltaExtensionsResult {\n\t\tif (!acquiredLock.isAcquiredFor(this)) {\n\t\t\tthrow new Error('Lock is not held');\n\t\t}\n\t\treturn this._actual.deltaExtensions(toAdd, toRemove);\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\treturn this._actual.containsActivationEvent(activationEvent);\n\t}\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\treturn this._actual.containsExtension(extensionId);\n\t}\n\tpublic getExtensionDescriptionsForActivationEvent(activationEvent: string): IExtensionDescription[] {\n\t\treturn this._actual.getExtensionDescriptionsForActivationEvent(activationEvent);\n\t}\n\tpublic getAllExtensionDescriptions(): IExtensionDescription[] {\n\t\treturn this._actual.getAllExtensionDescriptions();\n\t}\n\tpublic getSnapshot(): ExtensionDescriptionRegistrySnapshot {\n\t\treturn this._actual.getSnapshot();\n\t}\n\tpublic getExtensionDescription(extensionId: ExtensionIdentifier | string): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescription(extensionId);\n\t}\n\tpublic getExtensionDescriptionByUUID(uuid: string): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescriptionByUUID(uuid);\n\t}\n\tpublic getExtensionDescriptionByIdOrUUID(extensionId: ExtensionIdentifier | string, uuid: string | undefined): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescriptionByIdOrUUID(extensionId, uuid);\n\t}\n}\n\nexport class ExtensionDescriptionRegistryLock extends Disposable {\n\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _registry: LockableExtensionDescriptionRegistry,\n\t\tlock: IDisposable\n\t) {\n\t\tsuper();\n\t\tthis._register(lock);\n\t}\n\n\tpublic isAcquiredFor(registry: LockableExtensionDescriptionRegistry): boolean {\n\t\treturn !this._isDisposed && this._registry === registry;\n\t}\n}\n\nclass LockCustomer {\n\tpublic readonly promise: Promise<IDisposable>;\n\tprivate readonly _resolve: (value: IDisposable) => void;\n\n\tconstructor(\n\t\tpublic readonly name: string\n\t) {\n\t\tconst withResolvers = promiseWithResolvers<IDisposable>();\n\t\tthis.promise = withResolvers.promise;\n\t\tthis._resolve = withResolvers.resolve;\n\t}\n\n\tresolve(value: IDisposable): void {\n\t\tthis._resolve(value);\n\t}\n}\n\nclass Lock {\n\tprivate readonly _pendingCustomers: LockCustomer[] = [];\n\tprivate _isLocked = false;\n\n\tpublic async acquire(customerName: string): Promise<IDisposable> {\n\t\tconst customer = new LockCustomer(customerName);\n\t\tthis._pendingCustomers.push(customer);\n\t\tthis._advance();\n\t\treturn customer.promise;\n\t}\n\n\tprivate _advance(): void {\n\t\tif (this._isLocked) {\n\t\t\t// cannot advance yet\n\t\t\treturn;\n\t\t}\n\t\tif (this._pendingCustomers.length === 0) {\n\t\t\t// no more waiting customers\n\t\t\treturn;\n\t\t}\n\n\t\tconst customer = this._pendingCustomers.shift()!;\n\n\t\tthis._isLocked = true;\n\t\tlet customerHoldsLock = true;\n\n\t\tconst logLongRunningCustomerTimeout = setTimeout(() => {\n\t\t\tif (customerHoldsLock) {\n\t\t\t\tconsole.warn(`The customer named ${customer.name} has been holding on to the lock for 30s. This might be a problem.`);\n\t\t\t}\n\t\t}, 30 * 1000 /* 30 seconds */);\n\n\t\tconst releaseLock = () => {\n\t\t\tif (!customerHoldsLock) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tclearTimeout(logLongRunningCustomerTimeout);\n\t\t\tcustomerHoldsLock = false;\n\t\t\tthis._isLocked = false;\n\t\t\tthis._advance();\n\t\t};\n\n\t\tcustomer.resolve(toDisposable(releaseLock));\n\t}\n}\n\nconst enum SortBucket {\n\tBuiltin = 0,\n\tUser = 1,\n\tDev = 2\n}\n\n/**\n * Ensure that:\n * - first are builtin extensions\n * - second are user extensions\n * - third are extensions under development\n *\n * In each bucket, extensions must be sorted alphabetically by their folder name.\n */\nfunction extensionCmp(a: IExtensionDescription, b: IExtensionDescription): number {\n\tconst aSortBucket = (a.isBuiltin ? SortBucket.Builtin : a.isUnderDevelopment ? SortBucket.Dev : SortBucket.User);\n\tconst bSortBucket = (b.isBuiltin ? SortBucket.Builtin : b.isUnderDevelopment ? SortBucket.Dev : SortBucket.User);\n\tif (aSortBucket !== bSortBucket) {\n\t\treturn aSortBucket - bSortBucket;\n\t}\n\tconst aLastSegment = path.posix.basename(a.extensionLocation.path);\n\tconst bLastSegment = path.posix.basename(b.extensionLocation.path);\n\tif (aLastSegment < bLastSegment) {\n\t\treturn -1;\n\t}\n\tif (aLastSegment > bLastSegment) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction removeExtensions(arr: IExtensionDescription[], toRemove: ExtensionIdentifier[]): IExtensionDescription[] {\n\tconst toRemoveSet = new ExtensionIdentifierSet(toRemove);\n\treturn arr.filter(extension => !toRemoveSet.has(extension.identifier));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ExtensionIdentifier, ExtensionIdentifierMap, ExtensionIdentifierSet, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as path from '../../../../base/common/path.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { promiseWithResolvers } from '../../../../base/common/async.js';\n\nexport class DeltaExtensionsResult {\n\tconstructor(\n\t\tpublic readonly versionId: number,\n\t\tpublic readonly removedDueToLooping: IExtensionDescription[]\n\t) { }\n}\n\nexport interface IReadOnlyExtensionDescriptionRegistry {\n\tcontainsActivationEvent(activationEvent: string): boolean;\n\tcontainsExtension(extensionId: ExtensionIdentifier): boolean;\n\tgetExtensionDescriptionsForActivationEvent(activationEvent: string): IExtensionDescription[];\n\tgetAllExtensionDescriptions(): IExtensionDescription[];\n\tgetExtensionDescription(extensionId: ExtensionIdentifier | string): IExtensionDescription | undefined;\n\tgetExtensionDescriptionByUUID(uuid: string): IExtensionDescription | undefined;\n\tgetExtensionDescriptionByIdOrUUID(extensionId: ExtensionIdentifier | string, uuid: string | undefined): IExtensionDescription | undefined;\n}\n\nexport class ExtensionDescriptionRegistry extends Disposable implements IReadOnlyExtensionDescriptionRegistry {\n\n\tpublic static isHostExtension(extensionId: ExtensionIdentifier | string, myRegistry: ExtensionDescriptionRegistry, globalRegistry: ExtensionDescriptionRegistry): boolean {\n\t\tif (myRegistry.getExtensionDescription(extensionId)) {\n\t\t\t// I have this extension\n\t\t\treturn false;\n\t\t}\n\t\tconst extensionDescription = globalRegistry.getExtensionDescription(extensionId);\n\t\tif (!extensionDescription) {\n\t\t\t// unknown extension\n\t\t\treturn false;\n\t\t}\n\t\tif ((extensionDescription.main || extensionDescription.browser) && extensionDescription.api === 'none') {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate readonly _onDidChange = this._register(new Emitter<void>());\n\tpublic readonly onDidChange = this._onDidChange.event;\n\n\tprivate _versionId: number = 0;\n\tprivate _extensionDescriptions: IExtensionDescription[];\n\tprivate _extensionsMap!: ExtensionIdentifierMap<IExtensionDescription>;\n\tprivate _extensionsArr!: IExtensionDescription[];\n\tprivate _activationMap!: Map<string, IExtensionDescription[]>;\n\n\tconstructor(\n\t\tprivate readonly _activationEventsReader: IActivationEventsReader,\n\t\textensionDescriptions: IExtensionDescription[]\n\t) {\n\t\tsuper();\n\t\tthis._extensionDescriptions = extensionDescriptions;\n\t\tthis._initialize();\n\t}\n\n\tprivate _initialize(): void {\n\t\t// Ensure extensions are stored in the order: builtin, user, under development\n\t\tthis._extensionDescriptions.sort(extensionCmp);\n\n\t\tthis._extensionsMap = new ExtensionIdentifierMap<IExtensionDescription>();\n\t\tthis._extensionsArr = [];\n\t\tthis._activationMap = new Map<string, IExtensionDescription[]>();\n\n\t\tfor (const extensionDescription of this._extensionDescriptions) {\n\t\t\tif (this._extensionsMap.has(extensionDescription.identifier)) {\n\t\t\t\t// No overwriting allowed!\n\t\t\t\tconsole.error('Extension `' + extensionDescription.identifier.value + '` is already registered');\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._extensionsMap.set(extensionDescription.identifier, extensionDescription);\n\t\t\tthis._extensionsArr.push(extensionDescription);\n\n\t\t\tconst activationEvents = this._activationEventsReader.readActivationEvents(extensionDescription);\n\t\t\tfor (const activationEvent of activationEvents) {\n\t\t\t\tif (!this._activationMap.has(activationEvent)) {\n\t\t\t\t\tthis._activationMap.set(activationEvent, []);\n\t\t\t\t}\n\t\t\t\tthis._activationMap.get(activationEvent)!.push(extensionDescription);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic set(extensionDescriptions: IExtensionDescription[]): { versionId: number } {\n\t\tthis._extensionDescriptions = extensionDescriptions;\n\t\tthis._initialize();\n\t\tthis._versionId++;\n\t\tthis._onDidChange.fire(undefined);\n\t\treturn {\n\t\t\tversionId: this._versionId\n\t\t};\n\t}\n\n\tpublic deltaExtensions(toAdd: IExtensionDescription[], toRemove: ExtensionIdentifier[]): DeltaExtensionsResult {\n\t\t// It is possible that an extension is removed, only to be added again at a different version\n\t\t// so we will first handle removals\n\t\tthis._extensionDescriptions = removeExtensions(this._extensionDescriptions, toRemove);\n\n\t\t// Then, handle the extensions to add\n\t\tthis._extensionDescriptions = this._extensionDescriptions.concat(toAdd);\n\n\t\t// Immediately remove looping extensions!\n\t\tconst looping = ExtensionDescriptionRegistry._findLoopingExtensions(this._extensionDescriptions);\n\t\tthis._extensionDescriptions = removeExtensions(this._extensionDescriptions, looping.map(ext => ext.identifier));\n\n\t\tthis._initialize();\n\t\tthis._versionId++;\n\t\tthis._onDidChange.fire(undefined);\n\t\treturn new DeltaExtensionsResult(this._versionId, looping);\n\t}\n\n\tprivate static _findLoopingExtensions(extensionDescriptions: IExtensionDescription[]): IExtensionDescription[] {\n\t\tconst G = new class {\n\n\t\t\tprivate _arcs = new Map<string, string[]>();\n\t\t\tprivate _nodesSet = new Set<string>();\n\t\t\tprivate _nodesArr: string[] = [];\n\n\t\t\taddNode(id: string): void {\n\t\t\t\tif (!this._nodesSet.has(id)) {\n\t\t\t\t\tthis._nodesSet.add(id);\n\t\t\t\t\tthis._nodesArr.push(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taddArc(from: string, to: string): void {\n\t\t\t\tthis.addNode(from);\n\t\t\t\tthis.addNode(to);\n\t\t\t\tif (this._arcs.has(from)) {\n\t\t\t\t\tthis._arcs.get(from)!.push(to);\n\t\t\t\t} else {\n\t\t\t\t\tthis._arcs.set(from, [to]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgetArcs(id: string): string[] {\n\t\t\t\tif (this._arcs.has(id)) {\n\t\t\t\t\treturn this._arcs.get(id)!;\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\thasOnlyGoodArcs(id: string, good: Set<string>): boolean {\n\t\t\t\tconst dependencies = G.getArcs(id);\n\t\t\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\t\t\tif (!good.has(dependencies[i])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tgetNodes(): string[] {\n\t\t\t\treturn this._nodesArr;\n\t\t\t}\n\t\t};\n\n\t\tconst descs = new ExtensionIdentifierMap<IExtensionDescription>();\n\t\tfor (const extensionDescription of extensionDescriptions) {\n\t\t\tdescs.set(extensionDescription.identifier, extensionDescription);\n\t\t\tif (extensionDescription.extensionDependencies) {\n\t\t\t\tfor (const depId of extensionDescription.extensionDependencies) {\n\t\t\t\t\tG.addArc(ExtensionIdentifier.toKey(extensionDescription.identifier), ExtensionIdentifier.toKey(depId));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// initialize with all extensions with no dependencies.\n\t\tconst good = new Set<string>();\n\t\tG.getNodes().filter(id => G.getArcs(id).length === 0).forEach(id => good.add(id));\n\n\t\t// all other extensions will be processed below.\n\t\tconst nodes = G.getNodes().filter(id => !good.has(id));\n\n\t\tlet madeProgress: boolean;\n\t\tdo {\n\t\t\tmadeProgress = false;\n\n\t\t\t// find one extension which has only good deps\n\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\tconst id = nodes[i];\n\n\t\t\t\tif (G.hasOnlyGoodArcs(id, good)) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tgood.add(id);\n\t\t\t\t\tmadeProgress = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (madeProgress);\n\n\t\t// The remaining nodes are bad and have loops\n\t\treturn nodes.map(id => descs.get(id)!);\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\treturn this._activationMap.has(activationEvent);\n\t}\n\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\treturn this._extensionsMap.has(extensionId);\n\t}\n\n\tpublic getExtensionDescriptionsForActivationEvent(activationEvent: string): IExtensionDescription[] {\n\t\tconst extensions = this._activationMap.get(activationEvent);\n\t\treturn extensions ? extensions.slice(0) : [];\n\t}\n\n\tpublic getAllExtensionDescriptions(): IExtensionDescription[] {\n\t\treturn this._extensionsArr.slice(0);\n\t}\n\n\tpublic getSnapshot(): ExtensionDescriptionRegistrySnapshot {\n\t\treturn new ExtensionDescriptionRegistrySnapshot(\n\t\t\tthis._versionId,\n\t\t\tthis.getAllExtensionDescriptions()\n\t\t);\n\t}\n\n\tpublic getExtensionDescription(extensionId: ExtensionIdentifier | string): IExtensionDescription | undefined {\n\t\tconst extension = this._extensionsMap.get(extensionId);\n\t\treturn extension ? extension : undefined;\n\t}\n\n\tpublic getExtensionDescriptionByUUID(uuid: string): IExtensionDescription | undefined {\n\t\tfor (const extensionDescription of this._extensionsArr) {\n\t\t\tif (extensionDescription.uuid === uuid) {\n\t\t\t\treturn extensionDescription;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic getExtensionDescriptionByIdOrUUID(extensionId: ExtensionIdentifier | string, uuid: string | undefined): IExtensionDescription | undefined {\n\t\treturn (\n\t\t\tthis.getExtensionDescription(extensionId)\n\t\t\t?? (uuid ? this.getExtensionDescriptionByUUID(uuid) : undefined)\n\t\t);\n\t}\n}\n\nexport class ExtensionDescriptionRegistrySnapshot {\n\tconstructor(\n\t\tpublic readonly versionId: number,\n\t\tpublic readonly extensions: readonly IExtensionDescription[]\n\t) { }\n}\n\nexport interface IActivationEventsReader {\n\treadActivationEvents(extensionDescription: IExtensionDescription): string[];\n}\n\nexport class LockableExtensionDescriptionRegistry implements IReadOnlyExtensionDescriptionRegistry {\n\n\tprivate readonly _actual: ExtensionDescriptionRegistry;\n\tprivate readonly _lock = new Lock();\n\n\tconstructor(activationEventsReader: IActivationEventsReader) {\n\t\tthis._actual = new ExtensionDescriptionRegistry(activationEventsReader, []);\n\t}\n\n\tpublic async acquireLock(customerName: string): Promise<ExtensionDescriptionRegistryLock> {\n\t\tconst lock = await this._lock.acquire(customerName);\n\t\treturn new ExtensionDescriptionRegistryLock(this, lock);\n\t}\n\n\tpublic deltaExtensions(acquiredLock: ExtensionDescriptionRegistryLock, toAdd: IExtensionDescription[], toRemove: ExtensionIdentifier[]): DeltaExtensionsResult {\n\t\tif (!acquiredLock.isAcquiredFor(this)) {\n\t\t\tthrow new Error('Lock is not held');\n\t\t}\n\t\treturn this._actual.deltaExtensions(toAdd, toRemove);\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\treturn this._actual.containsActivationEvent(activationEvent);\n\t}\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\treturn this._actual.containsExtension(extensionId);\n\t}\n\tpublic getExtensionDescriptionsForActivationEvent(activationEvent: string): IExtensionDescription[] {\n\t\treturn this._actual.getExtensionDescriptionsForActivationEvent(activationEvent);\n\t}\n\tpublic getAllExtensionDescriptions(): IExtensionDescription[] {\n\t\treturn this._actual.getAllExtensionDescriptions();\n\t}\n\tpublic getSnapshot(): ExtensionDescriptionRegistrySnapshot {\n\t\treturn this._actual.getSnapshot();\n\t}\n\tpublic getExtensionDescription(extensionId: ExtensionIdentifier | string): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescription(extensionId);\n\t}\n\tpublic getExtensionDescriptionByUUID(uuid: string): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescriptionByUUID(uuid);\n\t}\n\tpublic getExtensionDescriptionByIdOrUUID(extensionId: ExtensionIdentifier | string, uuid: string | undefined): IExtensionDescription | undefined {\n\t\treturn this._actual.getExtensionDescriptionByIdOrUUID(extensionId, uuid);\n\t}\n}\n\nexport class ExtensionDescriptionRegistryLock extends Disposable {\n\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _registry: LockableExtensionDescriptionRegistry,\n\t\tlock: IDisposable\n\t) {\n\t\tsuper();\n\t\tthis._register(lock);\n\t}\n\n\tpublic isAcquiredFor(registry: LockableExtensionDescriptionRegistry): boolean {\n\t\treturn !this._isDisposed && this._registry === registry;\n\t}\n}\n\nclass LockCustomer {\n\tpublic readonly promise: Promise<IDisposable>;\n\tprivate readonly _resolve: (value: IDisposable) => void;\n\n\tconstructor(\n\t\tpublic readonly name: string\n\t) {\n\t\tconst withResolvers = promiseWithResolvers<IDisposable>();\n\t\tthis.promise = withResolvers.promise;\n\t\tthis._resolve = withResolvers.resolve;\n\t}\n\n\tresolve(value: IDisposable): void {\n\t\tthis._resolve(value);\n\t}\n}\n\nclass Lock {\n\tprivate readonly _pendingCustomers: LockCustomer[] = [];\n\tprivate _isLocked = false;\n\n\tpublic async acquire(customerName: string): Promise<IDisposable> {\n\t\tconst customer = new LockCustomer(customerName);\n\t\tthis._pendingCustomers.push(customer);\n\t\tthis._advance();\n\t\treturn customer.promise;\n\t}\n\n\tprivate _advance(): void {\n\t\tif (this._isLocked) {\n\t\t\t// cannot advance yet\n\t\t\treturn;\n\t\t}\n\t\tif (this._pendingCustomers.length === 0) {\n\t\t\t// no more waiting customers\n\t\t\treturn;\n\t\t}\n\n\t\tconst customer = this._pendingCustomers.shift()!;\n\n\t\tthis._isLocked = true;\n\t\tlet customerHoldsLock = true;\n\n\t\tconst logLongRunningCustomerTimeout = setTimeout(() => {\n\t\t\tif (customerHoldsLock) {\n\t\t\t\tconsole.warn(`The customer named ${customer.name} has been holding on to the lock for 30s. This might be a problem.`);\n\t\t\t}\n\t\t}, 30 * 1000 /* 30 seconds */);\n\n\t\tconst releaseLock = () => {\n\t\t\tif (!customerHoldsLock) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tclearTimeout(logLongRunningCustomerTimeout);\n\t\t\tcustomerHoldsLock = false;\n\t\t\tthis._isLocked = false;\n\t\t\tthis._advance();\n\t\t};\n\n\t\tcustomer.resolve(toDisposable(releaseLock));\n\t}\n}\n\nconst enum SortBucket {\n\tBuiltin = 0,\n\tUser = 1,\n\tDev = 2\n}\n\n/**\n * Ensure that:\n * - first are builtin extensions\n * - second are user extensions\n * - third are extensions under development\n *\n * In each bucket, extensions must be sorted alphabetically by their folder name.\n */\nfunction extensionCmp(a: IExtensionDescription, b: IExtensionDescription): number {\n\tconst aSortBucket = (a.isBuiltin ? SortBucket.Builtin : a.isUnderDevelopment ? SortBucket.Dev : SortBucket.User);\n\tconst bSortBucket = (b.isBuiltin ? SortBucket.Builtin : b.isUnderDevelopment ? SortBucket.Dev : SortBucket.User);\n\tif (aSortBucket !== bSortBucket) {\n\t\treturn aSortBucket - bSortBucket;\n\t}\n\tconst aLastSegment = path.posix.basename(a.extensionLocation.path);\n\tconst bLastSegment = path.posix.basename(b.extensionLocation.path);\n\tif (aLastSegment < bLastSegment) {\n\t\treturn -1;\n\t}\n\tif (aLastSegment > bLastSegment) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction removeExtensions(arr: IExtensionDescription[], toRemove: ExtensionIdentifier[]): IExtensionDescription[] {\n\tconst toRemoveSet = new ExtensionIdentifierSet(toRemove);\n\treturn arr.filter(extension => !toRemoveSet.has(extension.identifier));\n}\n"]}