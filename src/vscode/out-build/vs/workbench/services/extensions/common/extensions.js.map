{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/extensions/common/extensions.ts","vs/workbench/services/extensions/common/extensions.ts"],"names":[],"mappings":"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","file":"extensions.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport Severity from '../../../../base/common/severity.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IMessagePassingProtocol } from '../../../../base/parts/ipc/common/ipc.js';\nimport { getExtensionId, getGalleryExtensionId } from '../../../../platform/extensionManagement/common/extensionManagementUtil.js';\nimport { ImplicitActivationEvents } from '../../../../platform/extensionManagement/common/implicitActivationEvents.js';\nimport { ExtensionIdentifier, ExtensionIdentifierMap, ExtensionIdentifierSet, ExtensionType, IExtension, IExtensionContributions, IExtensionDescription, TargetPlatform } from '../../../../platform/extensions/common/extensions.js';\nimport { ApiProposalName } from '../../../../platform/extensions/common/extensionsApiProposals.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IV8Profile } from '../../../../platform/profiling/common/profiling.js';\nimport { ExtensionHostKind } from './extensionHostKind.js';\nimport { IExtensionDescriptionDelta, IExtensionDescriptionSnapshot } from './extensionHostProtocol.js';\nimport { ExtensionRunningLocation } from './extensionRunningLocation.js';\nimport { IExtensionPoint } from './extensionsRegistry.js';\n\nexport const nullExtensionDescription = Object.freeze<IExtensionDescription>({\n\tidentifier: new ExtensionIdentifier('nullExtensionDescription'),\n\tname: 'Null Extension Description',\n\tversion: '0.0.0',\n\tpublisher: 'vscode',\n\tengines: { vscode: '' },\n\textensionLocation: URI.parse('void:location'),\n\tisBuiltin: false,\n\ttargetPlatform: TargetPlatform.UNDEFINED,\n\tisUserBuiltin: false,\n\tisUnderDevelopment: false,\n\tpreRelease: false,\n});\n\nexport type WebWorkerExtHostConfigValue = boolean | 'auto';\nexport const webWorkerExtHostConfig = 'extensions.webWorker';\n\nexport const IExtensionService = createDecorator<IExtensionService>('extensionService');\n\nexport interface IMessage {\n\ttype: Severity;\n\tmessage: string;\n\textensionId: ExtensionIdentifier;\n\textensionPointId: string;\n}\n\nexport interface IExtensionsStatus {\n\tid: ExtensionIdentifier;\n\tmessages: IMessage[];\n\tactivationStarted: boolean;\n\tactivationTimes: ActivationTimes | undefined;\n\truntimeErrors: Error[];\n\trunningLocation: ExtensionRunningLocation | null;\n}\n\nexport class MissingExtensionDependency {\n\tconstructor(readonly dependency: string) { }\n}\n\n/**\n * e.g.\n * ```\n * {\n *    startTime: 1511954813493000,\n *    endTime: 1511954835590000,\n *    deltas: [ 100, 1500, 123456, 1500, 100000 ],\n *    ids: [ 'idle', 'self', 'extension1', 'self', 'idle' ]\n * }\n * ```\n */\nexport interface IExtensionHostProfile {\n\t/**\n\t * Profiling start timestamp in microseconds.\n\t */\n\tstartTime: number;\n\t/**\n\t * Profiling end timestamp in microseconds.\n\t */\n\tendTime: number;\n\t/**\n\t * Duration of segment in microseconds.\n\t */\n\tdeltas: number[];\n\t/**\n\t * Segment identifier: extension id or one of the four known strings.\n\t */\n\tids: ProfileSegmentId[];\n\n\t/**\n\t * Get the information as a .cpuprofile.\n\t */\n\tdata: IV8Profile;\n\n\t/**\n\t * Get the aggregated time per segmentId\n\t */\n\tgetAggregatedTimes(): Map<ProfileSegmentId, number>;\n}\n\nexport const enum ExtensionHostStartup {\n\t/**\n\t * The extension host should be launched immediately and doesn't require a `$startExtensionHost` call.\n\t */\n\tEagerAutoStart = 1,\n\t/**\n\t * The extension host should be launched immediately and needs a `$startExtensionHost` call.\n\t */\n\tEagerManualStart = 2,\n\t/**\n\t * The extension host should be launched lazily and only when it has extensions it needs to host. It doesn't require a `$startExtensionHost` call.\n\t */\n\tLazyAutoStart = 3,\n}\n\nexport interface IExtensionInspectInfo {\n\treadonly port: number;\n\treadonly host: string;\n\treadonly devtoolsUrl?: string;\n\treadonly devtoolsLabel?: string;\n}\n\nexport interface IExtensionHost {\n\treadonly pid: number | null;\n\treadonly runningLocation: ExtensionRunningLocation;\n\treadonly remoteAuthority: string | null;\n\treadonly startup: ExtensionHostStartup;\n\t/**\n\t * A collection of extensions which includes information about which\n\t * extension will execute or is executing on this extension host.\n\t * **NOTE**: this will reflect extensions correctly only after `start()` resolves.\n\t */\n\treadonly extensions: ExtensionHostExtensions | null;\n\treadonly onExit: Event<[number, string | null]>;\n\n\tstart(): Promise<IMessagePassingProtocol>;\n\tgetInspectPort(): IExtensionInspectInfo | undefined;\n\tenableInspectPort(): Promise<boolean>;\n\tdisconnect?(): Promise<void>;\n\tdispose(): void;\n}\n\nexport class ExtensionHostExtensions {\n\tprivate _versionId: number;\n\tprivate _allExtensions: IExtensionDescription[];\n\tprivate _myExtensions: ExtensionIdentifier[];\n\tprivate _myActivationEvents: Set<string> | null;\n\n\tpublic get versionId(): number {\n\t\treturn this._versionId;\n\t}\n\n\tpublic get allExtensions(): IExtensionDescription[] {\n\t\treturn this._allExtensions;\n\t}\n\n\tpublic get myExtensions(): ExtensionIdentifier[] {\n\t\treturn this._myExtensions;\n\t}\n\n\tconstructor(versionId: number, allExtensions: readonly IExtensionDescription[], myExtensions: ExtensionIdentifier[]) {\n\t\tthis._versionId = versionId;\n\t\tthis._allExtensions = allExtensions.slice(0);\n\t\tthis._myExtensions = myExtensions.slice(0);\n\t\tthis._myActivationEvents = null;\n\t}\n\n\ttoSnapshot(): IExtensionDescriptionSnapshot {\n\t\treturn {\n\t\t\tversionId: this._versionId,\n\t\t\tallExtensions: this._allExtensions,\n\t\t\tmyExtensions: this._myExtensions,\n\t\t\tactivationEvents: ImplicitActivationEvents.createActivationEventsMap(this._allExtensions)\n\t\t};\n\t}\n\n\tpublic set(versionId: number, allExtensions: IExtensionDescription[], myExtensions: ExtensionIdentifier[]): IExtensionDescriptionDelta {\n\t\tif (this._versionId > versionId) {\n\t\t\tthrow new Error(`ExtensionHostExtensions: invalid versionId ${versionId} (current: ${this._versionId})`);\n\t\t}\n\t\tconst toRemove: ExtensionIdentifier[] = [];\n\t\tconst toAdd: IExtensionDescription[] = [];\n\t\tconst myToRemove: ExtensionIdentifier[] = [];\n\t\tconst myToAdd: ExtensionIdentifier[] = [];\n\n\t\tconst oldExtensionsMap = extensionDescriptionArrayToMap(this._allExtensions);\n\t\tconst newExtensionsMap = extensionDescriptionArrayToMap(allExtensions);\n\t\tconst extensionsAreTheSame = (a: IExtensionDescription, b: IExtensionDescription) => {\n\t\t\treturn (\n\t\t\t\t(a.extensionLocation.toString() === b.extensionLocation.toString())\n\t\t\t\t|| (a.isBuiltin === b.isBuiltin)\n\t\t\t\t|| (a.isUserBuiltin === b.isUserBuiltin)\n\t\t\t\t|| (a.isUnderDevelopment === b.isUnderDevelopment)\n\t\t\t);\n\t\t};\n\n\t\tfor (const oldExtension of this._allExtensions) {\n\t\t\tconst newExtension = newExtensionsMap.get(oldExtension.identifier);\n\t\t\tif (!newExtension) {\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!extensionsAreTheSame(oldExtension, newExtension)) {\n\t\t\t\t// The new extension is different than the old one\n\t\t\t\t// (e.g. maybe it executes in a different location)\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (const newExtension of allExtensions) {\n\t\t\tconst oldExtension = oldExtensionsMap.get(newExtension.identifier);\n\t\t\tif (!oldExtension) {\n\t\t\t\ttoAdd.push(newExtension);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!extensionsAreTheSame(oldExtension, newExtension)) {\n\t\t\t\t// The new extension is different than the old one\n\t\t\t\t// (e.g. maybe it executes in a different location)\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tconst myOldExtensionsSet = new ExtensionIdentifierSet(this._myExtensions);\n\t\tconst myNewExtensionsSet = new ExtensionIdentifierSet(myExtensions);\n\t\tfor (const oldExtensionId of this._myExtensions) {\n\t\t\tif (!myNewExtensionsSet.has(oldExtensionId)) {\n\t\t\t\tmyToRemove.push(oldExtensionId);\n\t\t\t}\n\t\t}\n\t\tfor (const newExtensionId of myExtensions) {\n\t\t\tif (!myOldExtensionsSet.has(newExtensionId)) {\n\t\t\t\tmyToAdd.push(newExtensionId);\n\t\t\t}\n\t\t}\n\n\t\tconst addActivationEvents = ImplicitActivationEvents.createActivationEventsMap(toAdd);\n\t\tconst delta = { versionId, toRemove, toAdd, addActivationEvents, myToRemove, myToAdd };\n\t\tthis.delta(delta);\n\t\treturn delta;\n\t}\n\n\tpublic delta(extensionsDelta: IExtensionDescriptionDelta): IExtensionDescriptionDelta | null {\n\t\tif (this._versionId >= extensionsDelta.versionId) {\n\t\t\t// ignore older deltas\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { toRemove, toAdd, myToRemove, myToAdd } = extensionsDelta;\n\t\t// First handle removals\n\t\tconst toRemoveSet = new ExtensionIdentifierSet(toRemove);\n\t\tconst myToRemoveSet = new ExtensionIdentifierSet(myToRemove);\n\t\tfor (let i = 0; i < this._allExtensions.length; i++) {\n\t\t\tif (toRemoveSet.has(this._allExtensions[i].identifier)) {\n\t\t\t\tthis._allExtensions.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < this._myExtensions.length; i++) {\n\t\t\tif (myToRemoveSet.has(this._myExtensions[i])) {\n\t\t\t\tthis._myExtensions.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t// Then handle additions\n\t\tfor (const extension of toAdd) {\n\t\t\tthis._allExtensions.push(extension);\n\t\t}\n\t\tfor (const extensionId of myToAdd) {\n\t\t\tthis._myExtensions.push(extensionId);\n\t\t}\n\n\t\t// clear cached activation events\n\t\tthis._myActivationEvents = null;\n\n\t\treturn extensionsDelta;\n\t}\n\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\tfor (const myExtensionId of this._myExtensions) {\n\t\t\tif (ExtensionIdentifier.equals(myExtensionId, extensionId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\tif (!this._myActivationEvents) {\n\t\t\tthis._myActivationEvents = this._readMyActivationEvents();\n\t\t}\n\t\treturn this._myActivationEvents.has(activationEvent);\n\t}\n\n\tprivate _readMyActivationEvents(): Set<string> {\n\t\tconst result = new Set<string>();\n\n\t\tfor (const extensionDescription of this._allExtensions) {\n\t\t\tif (!this.containsExtension(extensionDescription.identifier)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst activationEvents = ImplicitActivationEvents.readActivationEvents(extensionDescription);\n\t\t\tfor (const activationEvent of activationEvents) {\n\t\t\t\tresult.add(activationEvent);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nfunction extensionDescriptionArrayToMap(extensions: IExtensionDescription[]): ExtensionIdentifierMap<IExtensionDescription> {\n\tconst result = new ExtensionIdentifierMap<IExtensionDescription>();\n\tfor (const extension of extensions) {\n\t\tresult.set(extension.identifier, extension);\n\t}\n\treturn result;\n}\n\nexport function isProposedApiEnabled(extension: IExtensionDescription, proposal: ApiProposalName): boolean {\n\tif (!extension.enabledApiProposals) {\n\t\treturn false;\n\t}\n\treturn extension.enabledApiProposals.includes(proposal);\n}\n\nexport function checkProposedApiEnabled(extension: IExtensionDescription, proposal: ApiProposalName): void {\n\tif (!isProposedApiEnabled(extension, proposal)) {\n\t\tthrow new Error(`Extension '${extension.identifier.value}' CANNOT use API proposal: ${proposal}.\\nIts package.json#enabledApiProposals-property declares: ${extension.enabledApiProposals?.join(', ') ?? '[]'} but NOT ${proposal}.\\n The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${extension.identifier.value}`);\n\t}\n}\n\n\n/**\n * Extension id or one of the four known program states.\n */\nexport type ProfileSegmentId = string | 'idle' | 'program' | 'gc' | 'self';\n\nexport interface ExtensionActivationReason {\n\treadonly startup: boolean;\n\treadonly extensionId: ExtensionIdentifier;\n\treadonly activationEvent: string;\n}\n\nexport class ActivationTimes {\n\tconstructor(\n\t\tpublic readonly codeLoadingTime: number,\n\t\tpublic readonly activateCallTime: number,\n\t\tpublic readonly activateResolvedTime: number,\n\t\tpublic readonly activationReason: ExtensionActivationReason\n\t) {\n\t}\n}\n\nexport class ExtensionPointContribution<T> {\n\treadonly description: IExtensionDescription;\n\treadonly value: T;\n\n\tconstructor(description: IExtensionDescription, value: T) {\n\t\tthis.description = description;\n\t\tthis.value = value;\n\t}\n}\n\nexport interface IWillActivateEvent {\n\treadonly event: string;\n\treadonly activation: Promise<void>;\n}\n\nexport interface IResponsiveStateChangeEvent {\n\textensionHostKind: ExtensionHostKind;\n\tisResponsive: boolean;\n\t/**\n\t * Return the inspect port or `0`. `0` means inspection is not possible.\n\t */\n\tgetInspectListener(tryEnableInspector: boolean): Promise<IExtensionInspectInfo | undefined>;\n}\n\nexport const enum ActivationKind {\n\tNormal = 0,\n\tImmediate = 1\n}\n\nexport interface WillStopExtensionHostsEvent {\n\n\t/**\n\t * A human readable reason for stopping the extension hosts\n\t * that e.g. can be shown in a confirmation dialog to the\n\t * user.\n\t */\n\treadonly reason: string;\n\n\t/**\n\t * A flag to indicate if the operation was triggered automatically\n\t */\n\treadonly auto: boolean;\n\n\t/**\n\t * Allows to veto the stopping of extension hosts. The veto can be a long running\n\t * operation.\n\t *\n\t * @param reason a human readable reason for vetoing the extension host stop in case\n\t * where the resolved `value: true`.\n\t */\n\tveto(value: boolean | Promise<boolean>, reason: string): void;\n}\n\nexport interface IExtensionService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event emitted when extensions are registered after their extension points got handled.\n\t *\n\t * This event will also fire on startup to signal the installed extensions.\n\t *\n\t * @returns the extensions that got registered\n\t */\n\treadonly onDidRegisterExtensions: Event<void>;\n\n\t/**\n\t * @event\n\t * Fired when extensions status changes.\n\t * The event contains the ids of the extensions that have changed.\n\t */\n\treadonly onDidChangeExtensionsStatus: Event<ExtensionIdentifier[]>;\n\n\t/**\n\t * Fired when the available extensions change (i.e. when extensions are added or removed).\n\t */\n\treadonly onDidChangeExtensions: Event<{ readonly added: readonly IExtensionDescription[]; readonly removed: readonly IExtensionDescription[] }>;\n\n\t/**\n\t * All registered extensions.\n\t * - List will be empty initially during workbench startup and will be filled with extensions as they are registered\n\t * - Listen to `onDidChangeExtensions` event for any changes to the extensions list. It will change as extensions get registered or de-reigstered.\n\t * - Listen to `onDidRegisterExtensions` event or wait for `whenInstalledExtensionsRegistered` promise to get the initial list of registered extensions.\n\t */\n\treadonly extensions: readonly IExtensionDescription[];\n\n\t/**\n\t * An event that is fired when activation happens.\n\t */\n\treadonly onWillActivateByEvent: Event<IWillActivateEvent>;\n\n\t/**\n\t * An event that is fired when an extension host changes its\n\t * responsive-state.\n\t */\n\treadonly onDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent>;\n\n\t/**\n\t * Fired before stop of extension hosts happens. Allows listeners to veto against the\n\t * stop to prevent it from happening.\n\t */\n\treadonly onWillStop: Event<WillStopExtensionHostsEvent>;\n\n\t/**\n\t * Send an activation event and activate interested extensions.\n\t *\n\t * This will wait for the normal startup of the extension host(s).\n\t *\n\t * In extraordinary circumstances, if the activation event needs to activate\n\t * one or more extensions before the normal startup is finished, then you can use\n\t * `ActivationKind.Immediate`. Please do not use this flag unless really necessary\n\t * and you understand all consequences.\n\t */\n\tactivateByEvent(activationEvent: string, activationKind?: ActivationKind): Promise<void>;\n\n\t/**\n\t * Send an activation ID and activate interested extensions.\n\t *\n\t */\n\tactivateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void>;\n\n\t/**\n\t * Determine if `activateByEvent(activationEvent)` has resolved already.\n\t *\n\t * i.e. the activation event is finished and all interested extensions are already active.\n\t */\n\tactivationEventIsDone(activationEvent: string): boolean;\n\n\t/**\n\t * An promise that resolves when the installed extensions are registered after\n\t * their extension points got handled.\n\t */\n\twhenInstalledExtensionsRegistered(): Promise<boolean>;\n\n\t/**\n\t * Return a specific extension\n\t * @param id An extension id\n\t */\n\tgetExtension(id: string): Promise<IExtensionDescription | undefined>;\n\n\t/**\n\t * Returns `true` if the given extension can be added. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanAddExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Returns `true` if the given extension can be removed. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanRemoveExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Read all contributions to an extension point.\n\t */\n\treadExtensionPointContributions<T extends IExtensionContributions[keyof IExtensionContributions]>(extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]>;\n\n\t/**\n\t * Get information about extensions status.\n\t */\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus };\n\n\t/**\n\t * Return the inspect ports (if inspection is possible) for extension hosts of kind `extensionHostKind`.\n\t */\n\tgetInspectPorts(extensionHostKind: ExtensionHostKind, tryEnableInspector: boolean): Promise<IExtensionInspectInfo[]>;\n\n\t/**\n\t * Stops the extension hosts.\n\t *\n\t * @param reason a human readable reason for stopping the extension hosts. This maybe\n\t * can be presented to the user when showing dialogs.\n\t *\n\t * @param auto indicates if the operation was triggered by an automatic action\n\t *\n\t * @returns a promise that resolves to `true` if the extension hosts were stopped, `false`\n\t * if the operation was vetoed by listeners of the `onWillStop` event.\n\t */\n\tstopExtensionHosts(reason: string, auto?: boolean): Promise<boolean>;\n\n\t/**\n\t * Starts the extension hosts. If updates are provided, the extension hosts are started with the given updates.\n\t */\n\tstartExtensionHosts(updates?: { readonly toAdd: readonly IExtension[]; readonly toRemove: readonly string[] }): Promise<void>;\n\n\t/**\n\t * Modify the environment of the remote extension host\n\t * @param env New properties for the remote extension host\n\t */\n\tsetRemoteEnvironment(env: { [key: string]: string | null }): Promise<void>;\n}\n\nexport interface IInternalExtensionService {\n\t_activateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void>;\n\t_onWillActivateExtension(extensionId: ExtensionIdentifier): void;\n\t_onDidActivateExtension(extensionId: ExtensionIdentifier, codeLoadingTime: number, activateCallTime: number, activateResolvedTime: number, activationReason: ExtensionActivationReason): void;\n\t_onDidActivateExtensionError(extensionId: ExtensionIdentifier, error: Error): void;\n\t_onExtensionRuntimeError(extensionId: ExtensionIdentifier, err: Error): void;\n}\n\nexport interface ProfileSession {\n\tstop(): Promise<IExtensionHostProfile>;\n}\n\nexport function toExtension(extensionDescription: IExtensionDescription): IExtension {\n\treturn {\n\t\ttype: extensionDescription.isBuiltin ? ExtensionType.System : ExtensionType.User,\n\t\tisBuiltin: extensionDescription.isBuiltin || extensionDescription.isUserBuiltin,\n\t\tidentifier: { id: getGalleryExtensionId(extensionDescription.publisher, extensionDescription.name), uuid: extensionDescription.uuid },\n\t\tmanifest: extensionDescription,\n\t\tlocation: extensionDescription.extensionLocation,\n\t\ttargetPlatform: extensionDescription.targetPlatform,\n\t\tvalidations: [],\n\t\tisValid: true,\n\t\tpreRelease: extensionDescription.preRelease,\n\t\tpublisherDisplayName: extensionDescription.publisherDisplayName,\n\t};\n}\n\nexport function toExtensionDescription(extension: IExtension, isUnderDevelopment?: boolean): IExtensionDescription {\n\tconst id = getExtensionId(extension.manifest.publisher, extension.manifest.name);\n\treturn {\n\t\tid,\n\t\tidentifier: new ExtensionIdentifier(id),\n\t\tisBuiltin: extension.type === ExtensionType.System,\n\t\tisUserBuiltin: extension.type === ExtensionType.User && extension.isBuiltin,\n\t\tisUnderDevelopment: !!isUnderDevelopment,\n\t\textensionLocation: extension.location,\n\t\tuuid: extension.identifier.uuid,\n\t\ttargetPlatform: extension.targetPlatform,\n\t\tpublisherDisplayName: extension.publisherDisplayName,\n\t\tpreRelease: extension.preRelease,\n\t\t...extension.manifest\n\t};\n}\n\n\nexport class NullExtensionService implements IExtensionService {\n\tdeclare readonly _serviceBrand: undefined;\n\treadonly onDidRegisterExtensions: Event<void> = Event.None;\n\treadonly onDidChangeExtensionsStatus: Event<ExtensionIdentifier[]> = Event.None;\n\tonDidChangeExtensions = Event.None;\n\treadonly onWillActivateByEvent: Event<IWillActivateEvent> = Event.None;\n\treadonly onDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent> = Event.None;\n\treadonly onWillStop: Event<WillStopExtensionHostsEvent> = Event.None;\n\treadonly extensions = [];\n\tactivateByEvent(_activationEvent: string): Promise<void> { return Promise.resolve(undefined); }\n\tactivateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void> { return Promise.resolve(undefined); }\n\tactivationEventIsDone(_activationEvent: string): boolean { return false; }\n\twhenInstalledExtensionsRegistered(): Promise<boolean> { return Promise.resolve(true); }\n\tgetExtension() { return Promise.resolve(undefined); }\n\treadExtensionPointContributions<T>(_extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]> { return Promise.resolve(Object.create(null)); }\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus } { return Object.create(null); }\n\tgetInspectPorts(_extensionHostKind: ExtensionHostKind, _tryEnableInspector: boolean): Promise<IExtensionInspectInfo[]> { return Promise.resolve([]); }\n\tasync stopExtensionHosts(): Promise<boolean> { return true; }\n\tasync startExtensionHosts(): Promise<void> { }\n\tasync setRemoteEnvironment(_env: { [key: string]: string | null }): Promise<void> { }\n\tcanAddExtension(): boolean { return false; }\n\tcanRemoveExtension(): boolean { return false; }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport Severity from '../../../../base/common/severity.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IMessagePassingProtocol } from '../../../../base/parts/ipc/common/ipc.js';\nimport { getExtensionId, getGalleryExtensionId } from '../../../../platform/extensionManagement/common/extensionManagementUtil.js';\nimport { ImplicitActivationEvents } from '../../../../platform/extensionManagement/common/implicitActivationEvents.js';\nimport { ExtensionIdentifier, ExtensionIdentifierMap, ExtensionIdentifierSet, ExtensionType, IExtension, IExtensionContributions, IExtensionDescription, TargetPlatform } from '../../../../platform/extensions/common/extensions.js';\nimport { ApiProposalName } from '../../../../platform/extensions/common/extensionsApiProposals.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IV8Profile } from '../../../../platform/profiling/common/profiling.js';\nimport { ExtensionHostKind } from './extensionHostKind.js';\nimport { IExtensionDescriptionDelta, IExtensionDescriptionSnapshot } from './extensionHostProtocol.js';\nimport { ExtensionRunningLocation } from './extensionRunningLocation.js';\nimport { IExtensionPoint } from './extensionsRegistry.js';\n\nexport const nullExtensionDescription = Object.freeze<IExtensionDescription>({\n\tidentifier: new ExtensionIdentifier('nullExtensionDescription'),\n\tname: 'Null Extension Description',\n\tversion: '0.0.0',\n\tpublisher: 'vscode',\n\tengines: { vscode: '' },\n\textensionLocation: URI.parse('void:location'),\n\tisBuiltin: false,\n\ttargetPlatform: TargetPlatform.UNDEFINED,\n\tisUserBuiltin: false,\n\tisUnderDevelopment: false,\n\tpreRelease: false,\n});\n\nexport type WebWorkerExtHostConfigValue = boolean | 'auto';\nexport const webWorkerExtHostConfig = 'extensions.webWorker';\n\nexport const IExtensionService = createDecorator<IExtensionService>('extensionService');\n\nexport interface IMessage {\n\ttype: Severity;\n\tmessage: string;\n\textensionId: ExtensionIdentifier;\n\textensionPointId: string;\n}\n\nexport interface IExtensionsStatus {\n\tid: ExtensionIdentifier;\n\tmessages: IMessage[];\n\tactivationStarted: boolean;\n\tactivationTimes: ActivationTimes | undefined;\n\truntimeErrors: Error[];\n\trunningLocation: ExtensionRunningLocation | null;\n}\n\nexport class MissingExtensionDependency {\n\tconstructor(readonly dependency: string) { }\n}\n\n/**\n * e.g.\n * ```\n * {\n *    startTime: 1511954813493000,\n *    endTime: 1511954835590000,\n *    deltas: [ 100, 1500, 123456, 1500, 100000 ],\n *    ids: [ 'idle', 'self', 'extension1', 'self', 'idle' ]\n * }\n * ```\n */\nexport interface IExtensionHostProfile {\n\t/**\n\t * Profiling start timestamp in microseconds.\n\t */\n\tstartTime: number;\n\t/**\n\t * Profiling end timestamp in microseconds.\n\t */\n\tendTime: number;\n\t/**\n\t * Duration of segment in microseconds.\n\t */\n\tdeltas: number[];\n\t/**\n\t * Segment identifier: extension id or one of the four known strings.\n\t */\n\tids: ProfileSegmentId[];\n\n\t/**\n\t * Get the information as a .cpuprofile.\n\t */\n\tdata: IV8Profile;\n\n\t/**\n\t * Get the aggregated time per segmentId\n\t */\n\tgetAggregatedTimes(): Map<ProfileSegmentId, number>;\n}\n\nexport const enum ExtensionHostStartup {\n\t/**\n\t * The extension host should be launched immediately and doesn't require a `$startExtensionHost` call.\n\t */\n\tEagerAutoStart = 1,\n\t/**\n\t * The extension host should be launched immediately and needs a `$startExtensionHost` call.\n\t */\n\tEagerManualStart = 2,\n\t/**\n\t * The extension host should be launched lazily and only when it has extensions it needs to host. It doesn't require a `$startExtensionHost` call.\n\t */\n\tLazyAutoStart = 3,\n}\n\nexport interface IExtensionInspectInfo {\n\treadonly port: number;\n\treadonly host: string;\n\treadonly devtoolsUrl?: string;\n\treadonly devtoolsLabel?: string;\n}\n\nexport interface IExtensionHost {\n\treadonly pid: number | null;\n\treadonly runningLocation: ExtensionRunningLocation;\n\treadonly remoteAuthority: string | null;\n\treadonly startup: ExtensionHostStartup;\n\t/**\n\t * A collection of extensions which includes information about which\n\t * extension will execute or is executing on this extension host.\n\t * **NOTE**: this will reflect extensions correctly only after `start()` resolves.\n\t */\n\treadonly extensions: ExtensionHostExtensions | null;\n\treadonly onExit: Event<[number, string | null]>;\n\n\tstart(): Promise<IMessagePassingProtocol>;\n\tgetInspectPort(): IExtensionInspectInfo | undefined;\n\tenableInspectPort(): Promise<boolean>;\n\tdisconnect?(): Promise<void>;\n\tdispose(): void;\n}\n\nexport class ExtensionHostExtensions {\n\tprivate _versionId: number;\n\tprivate _allExtensions: IExtensionDescription[];\n\tprivate _myExtensions: ExtensionIdentifier[];\n\tprivate _myActivationEvents: Set<string> | null;\n\n\tpublic get versionId(): number {\n\t\treturn this._versionId;\n\t}\n\n\tpublic get allExtensions(): IExtensionDescription[] {\n\t\treturn this._allExtensions;\n\t}\n\n\tpublic get myExtensions(): ExtensionIdentifier[] {\n\t\treturn this._myExtensions;\n\t}\n\n\tconstructor(versionId: number, allExtensions: readonly IExtensionDescription[], myExtensions: ExtensionIdentifier[]) {\n\t\tthis._versionId = versionId;\n\t\tthis._allExtensions = allExtensions.slice(0);\n\t\tthis._myExtensions = myExtensions.slice(0);\n\t\tthis._myActivationEvents = null;\n\t}\n\n\ttoSnapshot(): IExtensionDescriptionSnapshot {\n\t\treturn {\n\t\t\tversionId: this._versionId,\n\t\t\tallExtensions: this._allExtensions,\n\t\t\tmyExtensions: this._myExtensions,\n\t\t\tactivationEvents: ImplicitActivationEvents.createActivationEventsMap(this._allExtensions)\n\t\t};\n\t}\n\n\tpublic set(versionId: number, allExtensions: IExtensionDescription[], myExtensions: ExtensionIdentifier[]): IExtensionDescriptionDelta {\n\t\tif (this._versionId > versionId) {\n\t\t\tthrow new Error(`ExtensionHostExtensions: invalid versionId ${versionId} (current: ${this._versionId})`);\n\t\t}\n\t\tconst toRemove: ExtensionIdentifier[] = [];\n\t\tconst toAdd: IExtensionDescription[] = [];\n\t\tconst myToRemove: ExtensionIdentifier[] = [];\n\t\tconst myToAdd: ExtensionIdentifier[] = [];\n\n\t\tconst oldExtensionsMap = extensionDescriptionArrayToMap(this._allExtensions);\n\t\tconst newExtensionsMap = extensionDescriptionArrayToMap(allExtensions);\n\t\tconst extensionsAreTheSame = (a: IExtensionDescription, b: IExtensionDescription) => {\n\t\t\treturn (\n\t\t\t\t(a.extensionLocation.toString() === b.extensionLocation.toString())\n\t\t\t\t|| (a.isBuiltin === b.isBuiltin)\n\t\t\t\t|| (a.isUserBuiltin === b.isUserBuiltin)\n\t\t\t\t|| (a.isUnderDevelopment === b.isUnderDevelopment)\n\t\t\t);\n\t\t};\n\n\t\tfor (const oldExtension of this._allExtensions) {\n\t\t\tconst newExtension = newExtensionsMap.get(oldExtension.identifier);\n\t\t\tif (!newExtension) {\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!extensionsAreTheSame(oldExtension, newExtension)) {\n\t\t\t\t// The new extension is different than the old one\n\t\t\t\t// (e.g. maybe it executes in a different location)\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (const newExtension of allExtensions) {\n\t\t\tconst oldExtension = oldExtensionsMap.get(newExtension.identifier);\n\t\t\tif (!oldExtension) {\n\t\t\t\ttoAdd.push(newExtension);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!extensionsAreTheSame(oldExtension, newExtension)) {\n\t\t\t\t// The new extension is different than the old one\n\t\t\t\t// (e.g. maybe it executes in a different location)\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tconst myOldExtensionsSet = new ExtensionIdentifierSet(this._myExtensions);\n\t\tconst myNewExtensionsSet = new ExtensionIdentifierSet(myExtensions);\n\t\tfor (const oldExtensionId of this._myExtensions) {\n\t\t\tif (!myNewExtensionsSet.has(oldExtensionId)) {\n\t\t\t\tmyToRemove.push(oldExtensionId);\n\t\t\t}\n\t\t}\n\t\tfor (const newExtensionId of myExtensions) {\n\t\t\tif (!myOldExtensionsSet.has(newExtensionId)) {\n\t\t\t\tmyToAdd.push(newExtensionId);\n\t\t\t}\n\t\t}\n\n\t\tconst addActivationEvents = ImplicitActivationEvents.createActivationEventsMap(toAdd);\n\t\tconst delta = { versionId, toRemove, toAdd, addActivationEvents, myToRemove, myToAdd };\n\t\tthis.delta(delta);\n\t\treturn delta;\n\t}\n\n\tpublic delta(extensionsDelta: IExtensionDescriptionDelta): IExtensionDescriptionDelta | null {\n\t\tif (this._versionId >= extensionsDelta.versionId) {\n\t\t\t// ignore older deltas\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { toRemove, toAdd, myToRemove, myToAdd } = extensionsDelta;\n\t\t// First handle removals\n\t\tconst toRemoveSet = new ExtensionIdentifierSet(toRemove);\n\t\tconst myToRemoveSet = new ExtensionIdentifierSet(myToRemove);\n\t\tfor (let i = 0; i < this._allExtensions.length; i++) {\n\t\t\tif (toRemoveSet.has(this._allExtensions[i].identifier)) {\n\t\t\t\tthis._allExtensions.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < this._myExtensions.length; i++) {\n\t\t\tif (myToRemoveSet.has(this._myExtensions[i])) {\n\t\t\t\tthis._myExtensions.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t// Then handle additions\n\t\tfor (const extension of toAdd) {\n\t\t\tthis._allExtensions.push(extension);\n\t\t}\n\t\tfor (const extensionId of myToAdd) {\n\t\t\tthis._myExtensions.push(extensionId);\n\t\t}\n\n\t\t// clear cached activation events\n\t\tthis._myActivationEvents = null;\n\n\t\treturn extensionsDelta;\n\t}\n\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\tfor (const myExtensionId of this._myExtensions) {\n\t\t\tif (ExtensionIdentifier.equals(myExtensionId, extensionId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic containsActivationEvent(activationEvent: string): boolean {\n\t\tif (!this._myActivationEvents) {\n\t\t\tthis._myActivationEvents = this._readMyActivationEvents();\n\t\t}\n\t\treturn this._myActivationEvents.has(activationEvent);\n\t}\n\n\tprivate _readMyActivationEvents(): Set<string> {\n\t\tconst result = new Set<string>();\n\n\t\tfor (const extensionDescription of this._allExtensions) {\n\t\t\tif (!this.containsExtension(extensionDescription.identifier)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst activationEvents = ImplicitActivationEvents.readActivationEvents(extensionDescription);\n\t\t\tfor (const activationEvent of activationEvents) {\n\t\t\t\tresult.add(activationEvent);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nfunction extensionDescriptionArrayToMap(extensions: IExtensionDescription[]): ExtensionIdentifierMap<IExtensionDescription> {\n\tconst result = new ExtensionIdentifierMap<IExtensionDescription>();\n\tfor (const extension of extensions) {\n\t\tresult.set(extension.identifier, extension);\n\t}\n\treturn result;\n}\n\nexport function isProposedApiEnabled(extension: IExtensionDescription, proposal: ApiProposalName): boolean {\n\tif (!extension.enabledApiProposals) {\n\t\treturn false;\n\t}\n\treturn extension.enabledApiProposals.includes(proposal);\n}\n\nexport function checkProposedApiEnabled(extension: IExtensionDescription, proposal: ApiProposalName): void {\n\tif (!isProposedApiEnabled(extension, proposal)) {\n\t\tthrow new Error(`Extension '${extension.identifier.value}' CANNOT use API proposal: ${proposal}.\\nIts package.json#enabledApiProposals-property declares: ${extension.enabledApiProposals?.join(', ') ?? '[]'} but NOT ${proposal}.\\n The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${extension.identifier.value}`);\n\t}\n}\n\n\n/**\n * Extension id or one of the four known program states.\n */\nexport type ProfileSegmentId = string | 'idle' | 'program' | 'gc' | 'self';\n\nexport interface ExtensionActivationReason {\n\treadonly startup: boolean;\n\treadonly extensionId: ExtensionIdentifier;\n\treadonly activationEvent: string;\n}\n\nexport class ActivationTimes {\n\tconstructor(\n\t\tpublic readonly codeLoadingTime: number,\n\t\tpublic readonly activateCallTime: number,\n\t\tpublic readonly activateResolvedTime: number,\n\t\tpublic readonly activationReason: ExtensionActivationReason\n\t) {\n\t}\n}\n\nexport class ExtensionPointContribution<T> {\n\treadonly description: IExtensionDescription;\n\treadonly value: T;\n\n\tconstructor(description: IExtensionDescription, value: T) {\n\t\tthis.description = description;\n\t\tthis.value = value;\n\t}\n}\n\nexport interface IWillActivateEvent {\n\treadonly event: string;\n\treadonly activation: Promise<void>;\n}\n\nexport interface IResponsiveStateChangeEvent {\n\textensionHostKind: ExtensionHostKind;\n\tisResponsive: boolean;\n\t/**\n\t * Return the inspect port or `0`. `0` means inspection is not possible.\n\t */\n\tgetInspectListener(tryEnableInspector: boolean): Promise<IExtensionInspectInfo | undefined>;\n}\n\nexport const enum ActivationKind {\n\tNormal = 0,\n\tImmediate = 1\n}\n\nexport interface WillStopExtensionHostsEvent {\n\n\t/**\n\t * A human readable reason for stopping the extension hosts\n\t * that e.g. can be shown in a confirmation dialog to the\n\t * user.\n\t */\n\treadonly reason: string;\n\n\t/**\n\t * A flag to indicate if the operation was triggered automatically\n\t */\n\treadonly auto: boolean;\n\n\t/**\n\t * Allows to veto the stopping of extension hosts. The veto can be a long running\n\t * operation.\n\t *\n\t * @param reason a human readable reason for vetoing the extension host stop in case\n\t * where the resolved `value: true`.\n\t */\n\tveto(value: boolean | Promise<boolean>, reason: string): void;\n}\n\nexport interface IExtensionService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event emitted when extensions are registered after their extension points got handled.\n\t *\n\t * This event will also fire on startup to signal the installed extensions.\n\t *\n\t * @returns the extensions that got registered\n\t */\n\treadonly onDidRegisterExtensions: Event<void>;\n\n\t/**\n\t * @event\n\t * Fired when extensions status changes.\n\t * The event contains the ids of the extensions that have changed.\n\t */\n\treadonly onDidChangeExtensionsStatus: Event<ExtensionIdentifier[]>;\n\n\t/**\n\t * Fired when the available extensions change (i.e. when extensions are added or removed).\n\t */\n\treadonly onDidChangeExtensions: Event<{ readonly added: readonly IExtensionDescription[]; readonly removed: readonly IExtensionDescription[] }>;\n\n\t/**\n\t * All registered extensions.\n\t * - List will be empty initially during workbench startup and will be filled with extensions as they are registered\n\t * - Listen to `onDidChangeExtensions` event for any changes to the extensions list. It will change as extensions get registered or de-reigstered.\n\t * - Listen to `onDidRegisterExtensions` event or wait for `whenInstalledExtensionsRegistered` promise to get the initial list of registered extensions.\n\t */\n\treadonly extensions: readonly IExtensionDescription[];\n\n\t/**\n\t * An event that is fired when activation happens.\n\t */\n\treadonly onWillActivateByEvent: Event<IWillActivateEvent>;\n\n\t/**\n\t * An event that is fired when an extension host changes its\n\t * responsive-state.\n\t */\n\treadonly onDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent>;\n\n\t/**\n\t * Fired before stop of extension hosts happens. Allows listeners to veto against the\n\t * stop to prevent it from happening.\n\t */\n\treadonly onWillStop: Event<WillStopExtensionHostsEvent>;\n\n\t/**\n\t * Send an activation event and activate interested extensions.\n\t *\n\t * This will wait for the normal startup of the extension host(s).\n\t *\n\t * In extraordinary circumstances, if the activation event needs to activate\n\t * one or more extensions before the normal startup is finished, then you can use\n\t * `ActivationKind.Immediate`. Please do not use this flag unless really necessary\n\t * and you understand all consequences.\n\t */\n\tactivateByEvent(activationEvent: string, activationKind?: ActivationKind): Promise<void>;\n\n\t/**\n\t * Send an activation ID and activate interested extensions.\n\t *\n\t */\n\tactivateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void>;\n\n\t/**\n\t * Determine if `activateByEvent(activationEvent)` has resolved already.\n\t *\n\t * i.e. the activation event is finished and all interested extensions are already active.\n\t */\n\tactivationEventIsDone(activationEvent: string): boolean;\n\n\t/**\n\t * An promise that resolves when the installed extensions are registered after\n\t * their extension points got handled.\n\t */\n\twhenInstalledExtensionsRegistered(): Promise<boolean>;\n\n\t/**\n\t * Return a specific extension\n\t * @param id An extension id\n\t */\n\tgetExtension(id: string): Promise<IExtensionDescription | undefined>;\n\n\t/**\n\t * Returns `true` if the given extension can be added. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanAddExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Returns `true` if the given extension can be removed. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanRemoveExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Read all contributions to an extension point.\n\t */\n\treadExtensionPointContributions<T extends IExtensionContributions[keyof IExtensionContributions]>(extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]>;\n\n\t/**\n\t * Get information about extensions status.\n\t */\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus };\n\n\t/**\n\t * Return the inspect ports (if inspection is possible) for extension hosts of kind `extensionHostKind`.\n\t */\n\tgetInspectPorts(extensionHostKind: ExtensionHostKind, tryEnableInspector: boolean): Promise<IExtensionInspectInfo[]>;\n\n\t/**\n\t * Stops the extension hosts.\n\t *\n\t * @param reason a human readable reason for stopping the extension hosts. This maybe\n\t * can be presented to the user when showing dialogs.\n\t *\n\t * @param auto indicates if the operation was triggered by an automatic action\n\t *\n\t * @returns a promise that resolves to `true` if the extension hosts were stopped, `false`\n\t * if the operation was vetoed by listeners of the `onWillStop` event.\n\t */\n\tstopExtensionHosts(reason: string, auto?: boolean): Promise<boolean>;\n\n\t/**\n\t * Starts the extension hosts. If updates are provided, the extension hosts are started with the given updates.\n\t */\n\tstartExtensionHosts(updates?: { readonly toAdd: readonly IExtension[]; readonly toRemove: readonly string[] }): Promise<void>;\n\n\t/**\n\t * Modify the environment of the remote extension host\n\t * @param env New properties for the remote extension host\n\t */\n\tsetRemoteEnvironment(env: { [key: string]: string | null }): Promise<void>;\n}\n\nexport interface IInternalExtensionService {\n\t_activateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void>;\n\t_onWillActivateExtension(extensionId: ExtensionIdentifier): void;\n\t_onDidActivateExtension(extensionId: ExtensionIdentifier, codeLoadingTime: number, activateCallTime: number, activateResolvedTime: number, activationReason: ExtensionActivationReason): void;\n\t_onDidActivateExtensionError(extensionId: ExtensionIdentifier, error: Error): void;\n\t_onExtensionRuntimeError(extensionId: ExtensionIdentifier, err: Error): void;\n}\n\nexport interface ProfileSession {\n\tstop(): Promise<IExtensionHostProfile>;\n}\n\nexport function toExtension(extensionDescription: IExtensionDescription): IExtension {\n\treturn {\n\t\ttype: extensionDescription.isBuiltin ? ExtensionType.System : ExtensionType.User,\n\t\tisBuiltin: extensionDescription.isBuiltin || extensionDescription.isUserBuiltin,\n\t\tidentifier: { id: getGalleryExtensionId(extensionDescription.publisher, extensionDescription.name), uuid: extensionDescription.uuid },\n\t\tmanifest: extensionDescription,\n\t\tlocation: extensionDescription.extensionLocation,\n\t\ttargetPlatform: extensionDescription.targetPlatform,\n\t\tvalidations: [],\n\t\tisValid: true,\n\t\tpreRelease: extensionDescription.preRelease,\n\t\tpublisherDisplayName: extensionDescription.publisherDisplayName,\n\t};\n}\n\nexport function toExtensionDescription(extension: IExtension, isUnderDevelopment?: boolean): IExtensionDescription {\n\tconst id = getExtensionId(extension.manifest.publisher, extension.manifest.name);\n\treturn {\n\t\tid,\n\t\tidentifier: new ExtensionIdentifier(id),\n\t\tisBuiltin: extension.type === ExtensionType.System,\n\t\tisUserBuiltin: extension.type === ExtensionType.User && extension.isBuiltin,\n\t\tisUnderDevelopment: !!isUnderDevelopment,\n\t\textensionLocation: extension.location,\n\t\tuuid: extension.identifier.uuid,\n\t\ttargetPlatform: extension.targetPlatform,\n\t\tpublisherDisplayName: extension.publisherDisplayName,\n\t\tpreRelease: extension.preRelease,\n\t\t...extension.manifest\n\t};\n}\n\n\nexport class NullExtensionService implements IExtensionService {\n\tdeclare readonly _serviceBrand: undefined;\n\treadonly onDidRegisterExtensions: Event<void> = Event.None;\n\treadonly onDidChangeExtensionsStatus: Event<ExtensionIdentifier[]> = Event.None;\n\tonDidChangeExtensions = Event.None;\n\treadonly onWillActivateByEvent: Event<IWillActivateEvent> = Event.None;\n\treadonly onDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent> = Event.None;\n\treadonly onWillStop: Event<WillStopExtensionHostsEvent> = Event.None;\n\treadonly extensions = [];\n\tactivateByEvent(_activationEvent: string): Promise<void> { return Promise.resolve(undefined); }\n\tactivateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void> { return Promise.resolve(undefined); }\n\tactivationEventIsDone(_activationEvent: string): boolean { return false; }\n\twhenInstalledExtensionsRegistered(): Promise<boolean> { return Promise.resolve(true); }\n\tgetExtension() { return Promise.resolve(undefined); }\n\treadExtensionPointContributions<T>(_extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]> { return Promise.resolve(Object.create(null)); }\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus } { return Object.create(null); }\n\tgetInspectPorts(_extensionHostKind: ExtensionHostKind, _tryEnableInspector: boolean): Promise<IExtensionInspectInfo[]> { return Promise.resolve([]); }\n\tasync stopExtensionHosts(): Promise<boolean> { return true; }\n\tasync startExtensionHosts(): Promise<void> { }\n\tasync setRemoteEnvironment(_env: { [key: string]: string | null }): Promise<void> { }\n\tcanAddExtension(): boolean { return false; }\n\tcanRemoveExtension(): boolean { return false; }\n}\n"]}