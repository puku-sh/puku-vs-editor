{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/extensions/common/extensionRunningLocationTracker.ts","vs/workbench/services/extensions/common/extensionRunningLocationTracker.ts"],"names":[],"mappings":"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","file":"extensionRunningLocationTracker.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Schemas } from '../../../../base/common/network.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { ExtensionKind } from '../../../../platform/environment/common/environment.js';\nimport { ExtensionIdentifier, ExtensionIdentifierMap, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IWorkbenchEnvironmentService } from '../../environment/common/environmentService.js';\nimport { IReadOnlyExtensionDescriptionRegistry } from './extensionDescriptionRegistry.js';\nimport { ExtensionHostKind, ExtensionRunningPreference, IExtensionHostKindPicker, determineExtensionHostKinds } from './extensionHostKind.js';\nimport { IExtensionHostManager } from './extensionHostManagers.js';\nimport { IExtensionManifestPropertiesService } from './extensionManifestPropertiesService.js';\nimport { ExtensionRunningLocation, LocalProcessRunningLocation, LocalWebWorkerRunningLocation, RemoteRunningLocation } from './extensionRunningLocation.js';\n\nexport class ExtensionRunningLocationTracker {\n\n\tprivate _runningLocation = new ExtensionIdentifierMap<ExtensionRunningLocation | null>();\n\tprivate _maxLocalProcessAffinity: number = 0;\n\tprivate _maxLocalWebWorkerAffinity: number = 0;\n\n\tpublic get maxLocalProcessAffinity(): number {\n\t\treturn this._maxLocalProcessAffinity;\n\t}\n\n\tpublic get maxLocalWebWorkerAffinity(): number {\n\t\treturn this._maxLocalWebWorkerAffinity;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _registry: IReadOnlyExtensionDescriptionRegistry,\n\t\tprivate readonly _extensionHostKindPicker: IExtensionHostKindPicker,\n\t\t@IWorkbenchEnvironmentService private readonly _environmentService: IWorkbenchEnvironmentService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IExtensionManifestPropertiesService private readonly _extensionManifestPropertiesService: IExtensionManifestPropertiesService,\n\t) { }\n\n\tpublic set(extensionId: ExtensionIdentifier, runningLocation: ExtensionRunningLocation) {\n\t\tthis._runningLocation.set(extensionId, runningLocation);\n\t}\n\n\tpublic readExtensionKinds(extensionDescription: IExtensionDescription): ExtensionKind[] {\n\t\tif (extensionDescription.isUnderDevelopment && this._environmentService.extensionDevelopmentKind) {\n\t\t\treturn this._environmentService.extensionDevelopmentKind;\n\t\t}\n\n\t\treturn this._extensionManifestPropertiesService.getExtensionKind(extensionDescription);\n\t}\n\n\tpublic getRunningLocation(extensionId: ExtensionIdentifier): ExtensionRunningLocation | null {\n\t\treturn this._runningLocation.get(extensionId) || null;\n\t}\n\n\tpublic filterByRunningLocation(extensions: readonly IExtensionDescription[], desiredRunningLocation: ExtensionRunningLocation): IExtensionDescription[] {\n\t\treturn filterExtensionDescriptions(extensions, this._runningLocation, extRunningLocation => desiredRunningLocation.equals(extRunningLocation));\n\t}\n\n\tpublic filterByExtensionHostKind(extensions: readonly IExtensionDescription[], desiredExtensionHostKind: ExtensionHostKind): IExtensionDescription[] {\n\t\treturn filterExtensionDescriptions(extensions, this._runningLocation, extRunningLocation => extRunningLocation.kind === desiredExtensionHostKind);\n\t}\n\n\tpublic filterByExtensionHostManager(extensions: readonly IExtensionDescription[], extensionHostManager: IExtensionHostManager): IExtensionDescription[] {\n\t\treturn filterExtensionDescriptions(extensions, this._runningLocation, extRunningLocation => extensionHostManager.representsRunningLocation(extRunningLocation));\n\t}\n\n\tprivate _computeAffinity(inputExtensions: IExtensionDescription[], extensionHostKind: ExtensionHostKind, isInitialAllocation: boolean): { affinities: ExtensionIdentifierMap<number>; maxAffinity: number } {\n\t\t// Only analyze extensions that can execute\n\t\tconst extensions = new ExtensionIdentifierMap<IExtensionDescription>();\n\t\tfor (const extension of inputExtensions) {\n\t\t\tif (extension.main || extension.browser) {\n\t\t\t\textensions.set(extension.identifier, extension);\n\t\t\t}\n\t\t}\n\t\t// Also add existing extensions of the same kind that can execute\n\t\tfor (const extension of this._registry.getAllExtensionDescriptions()) {\n\t\t\tif (extension.main || extension.browser) {\n\t\t\t\tconst runningLocation = this._runningLocation.get(extension.identifier);\n\t\t\t\tif (runningLocation && runningLocation.kind === extensionHostKind) {\n\t\t\t\t\textensions.set(extension.identifier, extension);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Initially, each extension belongs to its own group\n\t\tconst groups = new ExtensionIdentifierMap<number>();\n\t\tlet groupNumber = 0;\n\t\tfor (const [_, extension] of extensions) {\n\t\t\tgroups.set(extension.identifier, ++groupNumber);\n\t\t}\n\n\t\tconst changeGroup = (from: number, to: number) => {\n\t\t\tfor (const [key, group] of groups) {\n\t\t\t\tif (group === from) {\n\t\t\t\t\tgroups.set(key, to);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// We will group things together when there are dependencies\n\t\tfor (const [_, extension] of extensions) {\n\t\t\tif (!extension.extensionDependencies) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst myGroup = groups.get(extension.identifier)!;\n\t\t\tfor (const depId of extension.extensionDependencies) {\n\t\t\t\tconst depGroup = groups.get(depId);\n\t\t\t\tif (!depGroup) {\n\t\t\t\t\t// probably can't execute, so it has no impact\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (depGroup === myGroup) {\n\t\t\t\t\t// already in the same group\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tchangeGroup(depGroup, myGroup);\n\t\t\t}\n\t\t}\n\n\t\t// Initialize with existing affinities\n\t\tconst resultingAffinities = new Map<number, number>();\n\t\tlet lastAffinity = 0;\n\t\tfor (const [_, extension] of extensions) {\n\t\t\tconst runningLocation = this._runningLocation.get(extension.identifier);\n\t\t\tif (runningLocation) {\n\t\t\t\tconst group = groups.get(extension.identifier)!;\n\t\t\t\tresultingAffinities.set(group, runningLocation.affinity);\n\t\t\t\tlastAffinity = Math.max(lastAffinity, runningLocation.affinity);\n\t\t\t}\n\t\t}\n\n\t\t// When doing extension host debugging, we will ignore the configured affinity\n\t\t// because we can currently debug a single extension host\n\t\tif (!this._environmentService.isExtensionDevelopment) {\n\t\t\t// Go through each configured affinity and try to accomodate it\n\t\t\tconst configuredAffinities = this._configurationService.getValue<{ [extensionId: string]: number } | undefined>('extensions.experimental.affinity') || {};\n\t\t\tconst configuredExtensionIds = Object.keys(configuredAffinities);\n\t\t\tconst configuredAffinityToResultingAffinity = new Map<number, number>();\n\t\t\tfor (const extensionId of configuredExtensionIds) {\n\t\t\t\tconst configuredAffinity = configuredAffinities[extensionId];\n\t\t\t\tif (typeof configuredAffinity !== 'number' || configuredAffinity <= 0 || Math.floor(configuredAffinity) !== configuredAffinity) {\n\t\t\t\t\tthis._logService.info(`Ignoring configured affinity for '${extensionId}' because the value is not a positive integer.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst group = groups.get(extensionId);\n\t\t\t\tif (!group) {\n\t\t\t\t\t// The extension is not known or cannot execute for this extension host kind\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst affinity1 = resultingAffinities.get(group);\n\t\t\t\tif (affinity1) {\n\t\t\t\t\t// Affinity for this group is already established\n\t\t\t\t\tconfiguredAffinityToResultingAffinity.set(configuredAffinity, affinity1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst affinity2 = configuredAffinityToResultingAffinity.get(configuredAffinity);\n\t\t\t\tif (affinity2) {\n\t\t\t\t\t// Affinity for this configuration is already established\n\t\t\t\t\tresultingAffinities.set(group, affinity2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!isInitialAllocation) {\n\t\t\t\t\tthis._logService.info(`Ignoring configured affinity for '${extensionId}' because extension host(s) are already running. Reload window.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst affinity3 = ++lastAffinity;\n\t\t\t\tconfiguredAffinityToResultingAffinity.set(configuredAffinity, affinity3);\n\t\t\t\tresultingAffinities.set(group, affinity3);\n\t\t\t}\n\t\t}\n\n\t\tconst result = new ExtensionIdentifierMap<number>();\n\t\tfor (const extension of inputExtensions) {\n\t\t\tconst group = groups.get(extension.identifier) || 0;\n\t\t\tconst affinity = resultingAffinities.get(group) || 0;\n\t\t\tresult.set(extension.identifier, affinity);\n\t\t}\n\n\t\tif (lastAffinity > 0 && isInitialAllocation) {\n\t\t\tfor (let affinity = 1; affinity <= lastAffinity; affinity++) {\n\t\t\t\tconst extensionIds: ExtensionIdentifier[] = [];\n\t\t\t\tfor (const extension of inputExtensions) {\n\t\t\t\t\tif (result.get(extension.identifier) === affinity) {\n\t\t\t\t\t\textensionIds.push(extension.identifier);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._logService.info(`Placing extension(s) ${extensionIds.map(e => e.value).join(', ')} on a separate extension host.`);\n\t\t\t}\n\t\t}\n\n\t\treturn { affinities: result, maxAffinity: lastAffinity };\n\t}\n\n\tpublic computeRunningLocation(localExtensions: IExtensionDescription[], remoteExtensions: IExtensionDescription[], isInitialAllocation: boolean): ExtensionIdentifierMap<ExtensionRunningLocation | null> {\n\t\treturn this._doComputeRunningLocation(this._runningLocation, localExtensions, remoteExtensions, isInitialAllocation).runningLocation;\n\t}\n\n\tprivate _doComputeRunningLocation(existingRunningLocation: ExtensionIdentifierMap<ExtensionRunningLocation | null>, localExtensions: IExtensionDescription[], remoteExtensions: IExtensionDescription[], isInitialAllocation: boolean): { runningLocation: ExtensionIdentifierMap<ExtensionRunningLocation | null>; maxLocalProcessAffinity: number; maxLocalWebWorkerAffinity: number } {\n\t\t// Skip extensions that have an existing running location\n\t\tlocalExtensions = localExtensions.filter(extension => !existingRunningLocation.has(extension.identifier));\n\t\tremoteExtensions = remoteExtensions.filter(extension => !existingRunningLocation.has(extension.identifier));\n\n\t\tconst extensionHostKinds = determineExtensionHostKinds(\n\t\t\tlocalExtensions,\n\t\t\tremoteExtensions,\n\t\t\t(extension) => this.readExtensionKinds(extension),\n\t\t\t(extensionId, extensionKinds, isInstalledLocally, isInstalledRemotely, preference) => this._extensionHostKindPicker.pickExtensionHostKind(extensionId, extensionKinds, isInstalledLocally, isInstalledRemotely, preference)\n\t\t);\n\n\t\tconst extensions = new ExtensionIdentifierMap<IExtensionDescription>();\n\t\tfor (const extension of localExtensions) {\n\t\t\textensions.set(extension.identifier, extension);\n\t\t}\n\t\tfor (const extension of remoteExtensions) {\n\t\t\textensions.set(extension.identifier, extension);\n\t\t}\n\n\t\tconst result = new ExtensionIdentifierMap<ExtensionRunningLocation | null>();\n\t\tconst localProcessExtensions: IExtensionDescription[] = [];\n\t\tconst localWebWorkerExtensions: IExtensionDescription[] = [];\n\t\tfor (const [extensionIdKey, extensionHostKind] of extensionHostKinds) {\n\t\t\tlet runningLocation: ExtensionRunningLocation | null = null;\n\t\t\tif (extensionHostKind === ExtensionHostKind.LocalProcess) {\n\t\t\t\tconst extensionDescription = extensions.get(extensionIdKey);\n\t\t\t\tif (extensionDescription) {\n\t\t\t\t\tlocalProcessExtensions.push(extensionDescription);\n\t\t\t\t}\n\t\t\t} else if (extensionHostKind === ExtensionHostKind.LocalWebWorker) {\n\t\t\t\tconst extensionDescription = extensions.get(extensionIdKey);\n\t\t\t\tif (extensionDescription) {\n\t\t\t\t\tlocalWebWorkerExtensions.push(extensionDescription);\n\t\t\t\t}\n\t\t\t} else if (extensionHostKind === ExtensionHostKind.Remote) {\n\t\t\t\trunningLocation = new RemoteRunningLocation();\n\t\t\t}\n\t\t\tresult.set(extensionIdKey, runningLocation);\n\t\t}\n\n\t\tconst { affinities, maxAffinity } = this._computeAffinity(localProcessExtensions, ExtensionHostKind.LocalProcess, isInitialAllocation);\n\t\tfor (const extension of localProcessExtensions) {\n\t\t\tconst affinity = affinities.get(extension.identifier) || 0;\n\t\t\tresult.set(extension.identifier, new LocalProcessRunningLocation(affinity));\n\t\t}\n\t\tconst { affinities: localWebWorkerAffinities, maxAffinity: maxLocalWebWorkerAffinity } = this._computeAffinity(localWebWorkerExtensions, ExtensionHostKind.LocalWebWorker, isInitialAllocation);\n\t\tfor (const extension of localWebWorkerExtensions) {\n\t\t\tconst affinity = localWebWorkerAffinities.get(extension.identifier) || 0;\n\t\t\tresult.set(extension.identifier, new LocalWebWorkerRunningLocation(affinity));\n\t\t}\n\n\t\t// Add extensions that already have an existing running location\n\t\tfor (const [extensionIdKey, runningLocation] of existingRunningLocation) {\n\t\t\tif (runningLocation) {\n\t\t\t\tresult.set(extensionIdKey, runningLocation);\n\t\t\t}\n\t\t}\n\n\t\treturn { runningLocation: result, maxLocalProcessAffinity: maxAffinity, maxLocalWebWorkerAffinity: maxLocalWebWorkerAffinity };\n\t}\n\n\tpublic initializeRunningLocation(localExtensions: IExtensionDescription[], remoteExtensions: IExtensionDescription[]): void {\n\t\tconst { runningLocation, maxLocalProcessAffinity, maxLocalWebWorkerAffinity } = this._doComputeRunningLocation(this._runningLocation, localExtensions, remoteExtensions, true);\n\t\tthis._runningLocation = runningLocation;\n\t\tthis._maxLocalProcessAffinity = maxLocalProcessAffinity;\n\t\tthis._maxLocalWebWorkerAffinity = maxLocalWebWorkerAffinity;\n\t}\n\n\t/**\n\t * Returns the running locations for the removed extensions.\n\t */\n\tpublic deltaExtensions(toAdd: IExtensionDescription[], toRemove: ExtensionIdentifier[]): ExtensionIdentifierMap<ExtensionRunningLocation | null> {\n\t\t// Remove old running location\n\t\tconst removedRunningLocation = new ExtensionIdentifierMap<ExtensionRunningLocation | null>();\n\t\tfor (const extensionId of toRemove) {\n\t\t\tconst extensionKey = extensionId;\n\t\t\tremovedRunningLocation.set(extensionKey, this._runningLocation.get(extensionKey) || null);\n\t\t\tthis._runningLocation.delete(extensionKey);\n\t\t}\n\n\t\t// Determine new running location\n\t\tthis._updateRunningLocationForAddedExtensions(toAdd);\n\n\t\treturn removedRunningLocation;\n\t}\n\n\t/**\n\t * Update `this._runningLocation` with running locations for newly enabled/installed extensions.\n\t */\n\tprivate _updateRunningLocationForAddedExtensions(toAdd: IExtensionDescription[]): void {\n\t\t// Determine new running location\n\t\tconst localProcessExtensions: IExtensionDescription[] = [];\n\t\tconst localWebWorkerExtensions: IExtensionDescription[] = [];\n\t\tfor (const extension of toAdd) {\n\t\t\tconst extensionKind = this.readExtensionKinds(extension);\n\t\t\tconst isRemote = extension.extensionLocation.scheme === Schemas.vscodeRemote;\n\t\t\tconst extensionHostKind = this._extensionHostKindPicker.pickExtensionHostKind(extension.identifier, extensionKind, !isRemote, isRemote, ExtensionRunningPreference.None);\n\t\t\tlet runningLocation: ExtensionRunningLocation | null = null;\n\t\t\tif (extensionHostKind === ExtensionHostKind.LocalProcess) {\n\t\t\t\tlocalProcessExtensions.push(extension);\n\t\t\t} else if (extensionHostKind === ExtensionHostKind.LocalWebWorker) {\n\t\t\t\tlocalWebWorkerExtensions.push(extension);\n\t\t\t} else if (extensionHostKind === ExtensionHostKind.Remote) {\n\t\t\t\trunningLocation = new RemoteRunningLocation();\n\t\t\t}\n\t\t\tthis._runningLocation.set(extension.identifier, runningLocation);\n\t\t}\n\n\t\tconst { affinities } = this._computeAffinity(localProcessExtensions, ExtensionHostKind.LocalProcess, false);\n\t\tfor (const extension of localProcessExtensions) {\n\t\t\tconst affinity = affinities.get(extension.identifier) || 0;\n\t\t\tthis._runningLocation.set(extension.identifier, new LocalProcessRunningLocation(affinity));\n\t\t}\n\n\t\tconst { affinities: webWorkerExtensionsAffinities } = this._computeAffinity(localWebWorkerExtensions, ExtensionHostKind.LocalWebWorker, false);\n\t\tfor (const extension of localWebWorkerExtensions) {\n\t\t\tconst affinity = webWorkerExtensionsAffinities.get(extension.identifier) || 0;\n\t\t\tthis._runningLocation.set(extension.identifier, new LocalWebWorkerRunningLocation(affinity));\n\t\t}\n\t}\n}\n\nexport function filterExtensionDescriptions(extensions: readonly IExtensionDescription[], runningLocation: ExtensionIdentifierMap<ExtensionRunningLocation | null>, predicate: (extRunningLocation: ExtensionRunningLocation) => boolean): IExtensionDescription[] {\n\treturn extensions.filter((ext) => {\n\t\tconst extRunningLocation = runningLocation.get(ext.identifier);\n\t\treturn extRunningLocation && predicate(extRunningLocation);\n\t});\n}\n\nexport function filterExtensionIdentifiers(extensions: readonly ExtensionIdentifier[], runningLocation: ExtensionIdentifierMap<ExtensionRunningLocation | null>, predicate: (extRunningLocation: ExtensionRunningLocation) => boolean): ExtensionIdentifier[] {\n\treturn extensions.filter((ext) => {\n\t\tconst extRunningLocation = runningLocation.get(ext);\n\t\treturn extRunningLocation && predicate(extRunningLocation);\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Schemas } from '../../../../base/common/network.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { ExtensionKind } from '../../../../platform/environment/common/environment.js';\nimport { ExtensionIdentifier, ExtensionIdentifierMap, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IWorkbenchEnvironmentService } from '../../environment/common/environmentService.js';\nimport { IReadOnlyExtensionDescriptionRegistry } from './extensionDescriptionRegistry.js';\nimport { ExtensionHostKind, ExtensionRunningPreference, IExtensionHostKindPicker, determineExtensionHostKinds } from './extensionHostKind.js';\nimport { IExtensionHostManager } from './extensionHostManagers.js';\nimport { IExtensionManifestPropertiesService } from './extensionManifestPropertiesService.js';\nimport { ExtensionRunningLocation, LocalProcessRunningLocation, LocalWebWorkerRunningLocation, RemoteRunningLocation } from './extensionRunningLocation.js';\n\nexport class ExtensionRunningLocationTracker {\n\n\tprivate _runningLocation = new ExtensionIdentifierMap<ExtensionRunningLocation | null>();\n\tprivate _maxLocalProcessAffinity: number = 0;\n\tprivate _maxLocalWebWorkerAffinity: number = 0;\n\n\tpublic get maxLocalProcessAffinity(): number {\n\t\treturn this._maxLocalProcessAffinity;\n\t}\n\n\tpublic get maxLocalWebWorkerAffinity(): number {\n\t\treturn this._maxLocalWebWorkerAffinity;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _registry: IReadOnlyExtensionDescriptionRegistry,\n\t\tprivate readonly _extensionHostKindPicker: IExtensionHostKindPicker,\n\t\t@IWorkbenchEnvironmentService private readonly _environmentService: IWorkbenchEnvironmentService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IExtensionManifestPropertiesService private readonly _extensionManifestPropertiesService: IExtensionManifestPropertiesService,\n\t) { }\n\n\tpublic set(extensionId: ExtensionIdentifier, runningLocation: ExtensionRunningLocation) {\n\t\tthis._runningLocation.set(extensionId, runningLocation);\n\t}\n\n\tpublic readExtensionKinds(extensionDescription: IExtensionDescription): ExtensionKind[] {\n\t\tif (extensionDescription.isUnderDevelopment && this._environmentService.extensionDevelopmentKind) {\n\t\t\treturn this._environmentService.extensionDevelopmentKind;\n\t\t}\n\n\t\treturn this._extensionManifestPropertiesService.getExtensionKind(extensionDescription);\n\t}\n\n\tpublic getRunningLocation(extensionId: ExtensionIdentifier): ExtensionRunningLocation | null {\n\t\treturn this._runningLocation.get(extensionId) || null;\n\t}\n\n\tpublic filterByRunningLocation(extensions: readonly IExtensionDescription[], desiredRunningLocation: ExtensionRunningLocation): IExtensionDescription[] {\n\t\treturn filterExtensionDescriptions(extensions, this._runningLocation, extRunningLocation => desiredRunningLocation.equals(extRunningLocation));\n\t}\n\n\tpublic filterByExtensionHostKind(extensions: readonly IExtensionDescription[], desiredExtensionHostKind: ExtensionHostKind): IExtensionDescription[] {\n\t\treturn filterExtensionDescriptions(extensions, this._runningLocation, extRunningLocation => extRunningLocation.kind === desiredExtensionHostKind);\n\t}\n\n\tpublic filterByExtensionHostManager(extensions: readonly IExtensionDescription[], extensionHostManager: IExtensionHostManager): IExtensionDescription[] {\n\t\treturn filterExtensionDescriptions(extensions, this._runningLocation, extRunningLocation => extensionHostManager.representsRunningLocation(extRunningLocation));\n\t}\n\n\tprivate _computeAffinity(inputExtensions: IExtensionDescription[], extensionHostKind: ExtensionHostKind, isInitialAllocation: boolean): { affinities: ExtensionIdentifierMap<number>; maxAffinity: number } {\n\t\t// Only analyze extensions that can execute\n\t\tconst extensions = new ExtensionIdentifierMap<IExtensionDescription>();\n\t\tfor (const extension of inputExtensions) {\n\t\t\tif (extension.main || extension.browser) {\n\t\t\t\textensions.set(extension.identifier, extension);\n\t\t\t}\n\t\t}\n\t\t// Also add existing extensions of the same kind that can execute\n\t\tfor (const extension of this._registry.getAllExtensionDescriptions()) {\n\t\t\tif (extension.main || extension.browser) {\n\t\t\t\tconst runningLocation = this._runningLocation.get(extension.identifier);\n\t\t\t\tif (runningLocation && runningLocation.kind === extensionHostKind) {\n\t\t\t\t\textensions.set(extension.identifier, extension);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Initially, each extension belongs to its own group\n\t\tconst groups = new ExtensionIdentifierMap<number>();\n\t\tlet groupNumber = 0;\n\t\tfor (const [_, extension] of extensions) {\n\t\t\tgroups.set(extension.identifier, ++groupNumber);\n\t\t}\n\n\t\tconst changeGroup = (from: number, to: number) => {\n\t\t\tfor (const [key, group] of groups) {\n\t\t\t\tif (group === from) {\n\t\t\t\t\tgroups.set(key, to);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// We will group things together when there are dependencies\n\t\tfor (const [_, extension] of extensions) {\n\t\t\tif (!extension.extensionDependencies) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst myGroup = groups.get(extension.identifier)!;\n\t\t\tfor (const depId of extension.extensionDependencies) {\n\t\t\t\tconst depGroup = groups.get(depId);\n\t\t\t\tif (!depGroup) {\n\t\t\t\t\t// probably can't execute, so it has no impact\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (depGroup === myGroup) {\n\t\t\t\t\t// already in the same group\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tchangeGroup(depGroup, myGroup);\n\t\t\t}\n\t\t}\n\n\t\t// Initialize with existing affinities\n\t\tconst resultingAffinities = new Map<number, number>();\n\t\tlet lastAffinity = 0;\n\t\tfor (const [_, extension] of extensions) {\n\t\t\tconst runningLocation = this._runningLocation.get(extension.identifier);\n\t\t\tif (runningLocation) {\n\t\t\t\tconst group = groups.get(extension.identifier)!;\n\t\t\t\tresultingAffinities.set(group, runningLocation.affinity);\n\t\t\t\tlastAffinity = Math.max(lastAffinity, runningLocation.affinity);\n\t\t\t}\n\t\t}\n\n\t\t// When doing extension host debugging, we will ignore the configured affinity\n\t\t// because we can currently debug a single extension host\n\t\tif (!this._environmentService.isExtensionDevelopment) {\n\t\t\t// Go through each configured affinity and try to accomodate it\n\t\t\tconst configuredAffinities = this._configurationService.getValue<{ [extensionId: string]: number } | undefined>('extensions.experimental.affinity') || {};\n\t\t\tconst configuredExtensionIds = Object.keys(configuredAffinities);\n\t\t\tconst configuredAffinityToResultingAffinity = new Map<number, number>();\n\t\t\tfor (const extensionId of configuredExtensionIds) {\n\t\t\t\tconst configuredAffinity = configuredAffinities[extensionId];\n\t\t\t\tif (typeof configuredAffinity !== 'number' || configuredAffinity <= 0 || Math.floor(configuredAffinity) !== configuredAffinity) {\n\t\t\t\t\tthis._logService.info(`Ignoring configured affinity for '${extensionId}' because the value is not a positive integer.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst group = groups.get(extensionId);\n\t\t\t\tif (!group) {\n\t\t\t\t\t// The extension is not known or cannot execute for this extension host kind\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst affinity1 = resultingAffinities.get(group);\n\t\t\t\tif (affinity1) {\n\t\t\t\t\t// Affinity for this group is already established\n\t\t\t\t\tconfiguredAffinityToResultingAffinity.set(configuredAffinity, affinity1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst affinity2 = configuredAffinityToResultingAffinity.get(configuredAffinity);\n\t\t\t\tif (affinity2) {\n\t\t\t\t\t// Affinity for this configuration is already established\n\t\t\t\t\tresultingAffinities.set(group, affinity2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!isInitialAllocation) {\n\t\t\t\t\tthis._logService.info(`Ignoring configured affinity for '${extensionId}' because extension host(s) are already running. Reload window.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst affinity3 = ++lastAffinity;\n\t\t\t\tconfiguredAffinityToResultingAffinity.set(configuredAffinity, affinity3);\n\t\t\t\tresultingAffinities.set(group, affinity3);\n\t\t\t}\n\t\t}\n\n\t\tconst result = new ExtensionIdentifierMap<number>();\n\t\tfor (const extension of inputExtensions) {\n\t\t\tconst group = groups.get(extension.identifier) || 0;\n\t\t\tconst affinity = resultingAffinities.get(group) || 0;\n\t\t\tresult.set(extension.identifier, affinity);\n\t\t}\n\n\t\tif (lastAffinity > 0 && isInitialAllocation) {\n\t\t\tfor (let affinity = 1; affinity <= lastAffinity; affinity++) {\n\t\t\t\tconst extensionIds: ExtensionIdentifier[] = [];\n\t\t\t\tfor (const extension of inputExtensions) {\n\t\t\t\t\tif (result.get(extension.identifier) === affinity) {\n\t\t\t\t\t\textensionIds.push(extension.identifier);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._logService.info(`Placing extension(s) ${extensionIds.map(e => e.value).join(', ')} on a separate extension host.`);\n\t\t\t}\n\t\t}\n\n\t\treturn { affinities: result, maxAffinity: lastAffinity };\n\t}\n\n\tpublic computeRunningLocation(localExtensions: IExtensionDescription[], remoteExtensions: IExtensionDescription[], isInitialAllocation: boolean): ExtensionIdentifierMap<ExtensionRunningLocation | null> {\n\t\treturn this._doComputeRunningLocation(this._runningLocation, localExtensions, remoteExtensions, isInitialAllocation).runningLocation;\n\t}\n\n\tprivate _doComputeRunningLocation(existingRunningLocation: ExtensionIdentifierMap<ExtensionRunningLocation | null>, localExtensions: IExtensionDescription[], remoteExtensions: IExtensionDescription[], isInitialAllocation: boolean): { runningLocation: ExtensionIdentifierMap<ExtensionRunningLocation | null>; maxLocalProcessAffinity: number; maxLocalWebWorkerAffinity: number } {\n\t\t// Skip extensions that have an existing running location\n\t\tlocalExtensions = localExtensions.filter(extension => !existingRunningLocation.has(extension.identifier));\n\t\tremoteExtensions = remoteExtensions.filter(extension => !existingRunningLocation.has(extension.identifier));\n\n\t\tconst extensionHostKinds = determineExtensionHostKinds(\n\t\t\tlocalExtensions,\n\t\t\tremoteExtensions,\n\t\t\t(extension) => this.readExtensionKinds(extension),\n\t\t\t(extensionId, extensionKinds, isInstalledLocally, isInstalledRemotely, preference) => this._extensionHostKindPicker.pickExtensionHostKind(extensionId, extensionKinds, isInstalledLocally, isInstalledRemotely, preference)\n\t\t);\n\n\t\tconst extensions = new ExtensionIdentifierMap<IExtensionDescription>();\n\t\tfor (const extension of localExtensions) {\n\t\t\textensions.set(extension.identifier, extension);\n\t\t}\n\t\tfor (const extension of remoteExtensions) {\n\t\t\textensions.set(extension.identifier, extension);\n\t\t}\n\n\t\tconst result = new ExtensionIdentifierMap<ExtensionRunningLocation | null>();\n\t\tconst localProcessExtensions: IExtensionDescription[] = [];\n\t\tconst localWebWorkerExtensions: IExtensionDescription[] = [];\n\t\tfor (const [extensionIdKey, extensionHostKind] of extensionHostKinds) {\n\t\t\tlet runningLocation: ExtensionRunningLocation | null = null;\n\t\t\tif (extensionHostKind === ExtensionHostKind.LocalProcess) {\n\t\t\t\tconst extensionDescription = extensions.get(extensionIdKey);\n\t\t\t\tif (extensionDescription) {\n\t\t\t\t\tlocalProcessExtensions.push(extensionDescription);\n\t\t\t\t}\n\t\t\t} else if (extensionHostKind === ExtensionHostKind.LocalWebWorker) {\n\t\t\t\tconst extensionDescription = extensions.get(extensionIdKey);\n\t\t\t\tif (extensionDescription) {\n\t\t\t\t\tlocalWebWorkerExtensions.push(extensionDescription);\n\t\t\t\t}\n\t\t\t} else if (extensionHostKind === ExtensionHostKind.Remote) {\n\t\t\t\trunningLocation = new RemoteRunningLocation();\n\t\t\t}\n\t\t\tresult.set(extensionIdKey, runningLocation);\n\t\t}\n\n\t\tconst { affinities, maxAffinity } = this._computeAffinity(localProcessExtensions, ExtensionHostKind.LocalProcess, isInitialAllocation);\n\t\tfor (const extension of localProcessExtensions) {\n\t\t\tconst affinity = affinities.get(extension.identifier) || 0;\n\t\t\tresult.set(extension.identifier, new LocalProcessRunningLocation(affinity));\n\t\t}\n\t\tconst { affinities: localWebWorkerAffinities, maxAffinity: maxLocalWebWorkerAffinity } = this._computeAffinity(localWebWorkerExtensions, ExtensionHostKind.LocalWebWorker, isInitialAllocation);\n\t\tfor (const extension of localWebWorkerExtensions) {\n\t\t\tconst affinity = localWebWorkerAffinities.get(extension.identifier) || 0;\n\t\t\tresult.set(extension.identifier, new LocalWebWorkerRunningLocation(affinity));\n\t\t}\n\n\t\t// Add extensions that already have an existing running location\n\t\tfor (const [extensionIdKey, runningLocation] of existingRunningLocation) {\n\t\t\tif (runningLocation) {\n\t\t\t\tresult.set(extensionIdKey, runningLocation);\n\t\t\t}\n\t\t}\n\n\t\treturn { runningLocation: result, maxLocalProcessAffinity: maxAffinity, maxLocalWebWorkerAffinity: maxLocalWebWorkerAffinity };\n\t}\n\n\tpublic initializeRunningLocation(localExtensions: IExtensionDescription[], remoteExtensions: IExtensionDescription[]): void {\n\t\tconst { runningLocation, maxLocalProcessAffinity, maxLocalWebWorkerAffinity } = this._doComputeRunningLocation(this._runningLocation, localExtensions, remoteExtensions, true);\n\t\tthis._runningLocation = runningLocation;\n\t\tthis._maxLocalProcessAffinity = maxLocalProcessAffinity;\n\t\tthis._maxLocalWebWorkerAffinity = maxLocalWebWorkerAffinity;\n\t}\n\n\t/**\n\t * Returns the running locations for the removed extensions.\n\t */\n\tpublic deltaExtensions(toAdd: IExtensionDescription[], toRemove: ExtensionIdentifier[]): ExtensionIdentifierMap<ExtensionRunningLocation | null> {\n\t\t// Remove old running location\n\t\tconst removedRunningLocation = new ExtensionIdentifierMap<ExtensionRunningLocation | null>();\n\t\tfor (const extensionId of toRemove) {\n\t\t\tconst extensionKey = extensionId;\n\t\t\tremovedRunningLocation.set(extensionKey, this._runningLocation.get(extensionKey) || null);\n\t\t\tthis._runningLocation.delete(extensionKey);\n\t\t}\n\n\t\t// Determine new running location\n\t\tthis._updateRunningLocationForAddedExtensions(toAdd);\n\n\t\treturn removedRunningLocation;\n\t}\n\n\t/**\n\t * Update `this._runningLocation` with running locations for newly enabled/installed extensions.\n\t */\n\tprivate _updateRunningLocationForAddedExtensions(toAdd: IExtensionDescription[]): void {\n\t\t// Determine new running location\n\t\tconst localProcessExtensions: IExtensionDescription[] = [];\n\t\tconst localWebWorkerExtensions: IExtensionDescription[] = [];\n\t\tfor (const extension of toAdd) {\n\t\t\tconst extensionKind = this.readExtensionKinds(extension);\n\t\t\tconst isRemote = extension.extensionLocation.scheme === Schemas.vscodeRemote;\n\t\t\tconst extensionHostKind = this._extensionHostKindPicker.pickExtensionHostKind(extension.identifier, extensionKind, !isRemote, isRemote, ExtensionRunningPreference.None);\n\t\t\tlet runningLocation: ExtensionRunningLocation | null = null;\n\t\t\tif (extensionHostKind === ExtensionHostKind.LocalProcess) {\n\t\t\t\tlocalProcessExtensions.push(extension);\n\t\t\t} else if (extensionHostKind === ExtensionHostKind.LocalWebWorker) {\n\t\t\t\tlocalWebWorkerExtensions.push(extension);\n\t\t\t} else if (extensionHostKind === ExtensionHostKind.Remote) {\n\t\t\t\trunningLocation = new RemoteRunningLocation();\n\t\t\t}\n\t\t\tthis._runningLocation.set(extension.identifier, runningLocation);\n\t\t}\n\n\t\tconst { affinities } = this._computeAffinity(localProcessExtensions, ExtensionHostKind.LocalProcess, false);\n\t\tfor (const extension of localProcessExtensions) {\n\t\t\tconst affinity = affinities.get(extension.identifier) || 0;\n\t\t\tthis._runningLocation.set(extension.identifier, new LocalProcessRunningLocation(affinity));\n\t\t}\n\n\t\tconst { affinities: webWorkerExtensionsAffinities } = this._computeAffinity(localWebWorkerExtensions, ExtensionHostKind.LocalWebWorker, false);\n\t\tfor (const extension of localWebWorkerExtensions) {\n\t\t\tconst affinity = webWorkerExtensionsAffinities.get(extension.identifier) || 0;\n\t\t\tthis._runningLocation.set(extension.identifier, new LocalWebWorkerRunningLocation(affinity));\n\t\t}\n\t}\n}\n\nexport function filterExtensionDescriptions(extensions: readonly IExtensionDescription[], runningLocation: ExtensionIdentifierMap<ExtensionRunningLocation | null>, predicate: (extRunningLocation: ExtensionRunningLocation) => boolean): IExtensionDescription[] {\n\treturn extensions.filter((ext) => {\n\t\tconst extRunningLocation = runningLocation.get(ext.identifier);\n\t\treturn extRunningLocation && predicate(extRunningLocation);\n\t});\n}\n\nexport function filterExtensionIdentifiers(extensions: readonly ExtensionIdentifier[], runningLocation: ExtensionIdentifierMap<ExtensionRunningLocation | null>, predicate: (extRunningLocation: ExtensionRunningLocation) => boolean): ExtensionIdentifier[] {\n\treturn extensions.filter((ext) => {\n\t\tconst extRunningLocation = runningLocation.get(ext);\n\t\treturn extRunningLocation && predicate(extRunningLocation);\n\t});\n}\n"]}