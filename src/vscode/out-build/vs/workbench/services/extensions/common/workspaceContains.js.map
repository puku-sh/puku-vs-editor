{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/extensions/common/workspaceContains.ts","vs/workbench/services/extensions/common/workspaceContains.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,KAAK,SAAS,MAAM,sCAAsC,CAAC;AAClE,OAAO,EAAE,GAAG,EAAiB,MAAM,gCAAgC,CAAC;AACpE,OAAO,EAAE,uBAAuB,EAAqB,MAAM,yCAAyC,CAAC;AACrG,OAAO,KAAK,MAAM,MAAM,mCAAmC,CAAC;AAE5D,OAAO,EAAE,qBAAqB,EAAoB,MAAM,4DAA4D,CAAC;AACrH,OAAO,EAAE,YAAY,EAAE,MAAM,qCAAqC,CAAC;AACnE,OAAO,EAAE,cAAc,EAAE,MAAM,+BAA+B,CAAC;AAC/D,OAAO,EAAE,iBAAiB,EAAE,MAAM,oDAAoD,CAAC;AAEvF,OAAO,EAAE,oBAAoB,EAAE,MAAM,kCAAkC,CAAC;AAExE,MAAM,0BAA0B,GAAG,IAAI,CAAC;AAexC,MAAM,UAAU,uCAAuC,CAAC,IAA8B,EAAE,IAA2B;IAClH,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;IAC/C,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACvB,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IACnC,CAAC;IAED,MAAM,SAAS,GAAa,EAAE,CAAC;IAC/B,MAAM,YAAY,GAAa,EAAE,CAAC;IAElC,KAAK,MAAM,eAAe,IAAI,gBAAgB,EAAE,CAAC;QAChD,IAAI,qBAAqB,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC;YACjD,MAAM,cAAc,GAAG,eAAe,CAAC,MAAM,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;YAC3E,IAAI,cAAc,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBACnG,YAAY,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YACnC,CAAC;iBAAM,CAAC;gBACP,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YAChC,CAAC;QACF,CAAC;IACF,CAAC;IAED,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACzD,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IACnC,CAAC;IAED,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,oBAAoB,EAA0C,CAAC;IAC5F,MAAM,QAAQ,GAAG,CAAC,eAAuB,EAAE,EAAE,CAAC,OAAO,CAAC,EAAE,eAAe,EAAE,CAAC,CAAC;IAE3E,MAAM,eAAe,GAAG,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,mBAAmB,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;IAChI,MAAM,kBAAkB,GAAG,uBAAuB,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,YAAY,EAAE,QAAQ,CAAC,CAAC;IAElG,OAAO,CAAC,GAAG,CAAC,CAAC,eAAe,EAAE,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;QAC5D,2FAA2F;QAC3F,OAAO,CAAC,SAAS,CAAC,CAAC;IACpB,CAAC,CAAC,CAAC;IAEH,OAAO,OAAO,CAAC;AAChB,CAAC;AAED,KAAK,UAAU,mBAAmB,CAAC,IAA8B,EAAE,QAAgB,EAAE,QAA2C;IAC/H,kBAAkB;IAClB,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;QAChC,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,QAAQ,CAAC,CAAC,EAAE,CAAC;YACtE,qBAAqB;YACrB,QAAQ,CAAC,qBAAqB,QAAQ,EAAE,CAAC,CAAC;YAC1C,OAAO;QACR,CAAC;IACF,CAAC;AACF,CAAC;AAED,KAAK,UAAU,uBAAuB,CAAC,IAA8B,EAAE,WAAgC,EAAE,YAAsB,EAAE,QAA2C;IAC3K,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAC/B,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IACnC,CAAC;IAED,MAAM,WAAW,GAAG,IAAI,uBAAuB,EAAE,CAAC;IAClD,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,EAAE,YAAY,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC;IAEhF,MAAM,KAAK,GAAG,UAAU,CAAC,KAAK,IAAI,EAAE;QACnC,WAAW,CAAC,MAAM,EAAE,CAAC;QACrB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,6BAA6B,WAAW,CAAC,KAAK,gEAAgE,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAC9J,CAAC,EAAE,0BAA0B,CAAC,CAAC;IAE/B,IAAI,MAAM,GAAY,KAAK,CAAC;IAC5B,IAAI,CAAC;QACJ,MAAM,GAAG,MAAM,OAAO,CAAC;IACxB,CAAC;IAAC,OAAO,GAAG,EAAE,CAAC;QACd,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,GAAG,CAAC,EAAE,CAAC;YACtC,MAAM,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC;QAC/B,CAAC;IACF,CAAC;IAED,WAAW,CAAC,OAAO,EAAE,CAAC;IACtB,YAAY,CAAC,KAAK,CAAC,CAAC;IAEpB,IAAI,MAAM,EAAE,CAAC;QACZ,qDAAqD;QACrD,QAAQ,CAAC,qBAAqB,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IACzD,CAAC;AACF,CAAC;AAED,MAAM,UAAU,mBAAmB,CAClC,QAA0B,EAC1B,OAAiC,EACjC,QAAkB,EAClB,KAAwB;IAExB,MAAM,oBAAoB,GAAG,QAAQ,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAC;IACjE,MAAM,aAAa,GAAG,QAAQ,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IACnD,MAAM,YAAY,GAAG,oBAAoB,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;IACvE,MAAM,KAAK,GAAG,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,iBAAiB,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;QAC7F,OAAO,EAAE,aAAa;QACtB,cAAc,EAAE,QAAQ;QACxB,MAAM,EAAE,IAAI;KACZ,CAAC,CAAC;IAEH,OAAO,aAAa,CAAC,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,IAAI,CACjD,MAAM,CAAC,EAAE;QACR,OAAO,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;IAC1B,CAAC,EACD,GAAG,CAAC,EAAE;QACL,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,GAAG,CAAC,EAAE,CAAC;YACtC,OAAO,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QAC5B,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC,CAAC,CAAC;AACL,CAAC","file":"workspaceContains.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as resources from '../../../../base/common/resources.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { CancellationTokenSource, CancellationToken } from '../../../../base/common/cancellation.js';\nimport * as errors from '../../../../base/common/errors.js';\nimport { ExtensionIdentifier, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService, ServicesAccessor } from '../../../../platform/instantiation/common/instantiation.js';\nimport { QueryBuilder } from '../../search/common/queryBuilder.js';\nimport { ISearchService } from '../../search/common/search.js';\nimport { toWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { promiseWithResolvers } from '../../../../base/common/async.js';\n\nconst WORKSPACE_CONTAINS_TIMEOUT = 7000;\n\nexport interface IExtensionActivationHost {\n\treadonly logService: ILogService;\n\treadonly folders: readonly UriComponents[];\n\treadonly forceUsingSearch: boolean;\n\n\texists(uri: URI): Promise<boolean>;\n\tcheckExists(folders: readonly UriComponents[], includes: string[], token: CancellationToken): Promise<boolean>;\n}\n\nexport interface IExtensionActivationResult {\n\tactivationEvent: string;\n}\n\nexport function checkActivateWorkspaceContainsExtension(host: IExtensionActivationHost, desc: IExtensionDescription): Promise<IExtensionActivationResult | undefined> {\n\tconst activationEvents = desc.activationEvents;\n\tif (!activationEvents) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tconst fileNames: string[] = [];\n\tconst globPatterns: string[] = [];\n\n\tfor (const activationEvent of activationEvents) {\n\t\tif (/^workspaceContains:/.test(activationEvent)) {\n\t\t\tconst fileNameOrGlob = activationEvent.substr('workspaceContains:'.length);\n\t\t\tif (fileNameOrGlob.indexOf('*') >= 0 || fileNameOrGlob.indexOf('?') >= 0 || host.forceUsingSearch) {\n\t\t\t\tglobPatterns.push(fileNameOrGlob);\n\t\t\t} else {\n\t\t\t\tfileNames.push(fileNameOrGlob);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fileNames.length === 0 && globPatterns.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tconst { promise, resolve } = promiseWithResolvers<IExtensionActivationResult | undefined>();\n\tconst activate = (activationEvent: string) => resolve({ activationEvent });\n\n\tconst fileNamePromise = Promise.all(fileNames.map((fileName) => _activateIfFileName(host, fileName, activate))).then(() => { });\n\tconst globPatternPromise = _activateIfGlobPatterns(host, desc.identifier, globPatterns, activate);\n\n\tPromise.all([fileNamePromise, globPatternPromise]).then(() => {\n\t\t// when all are done, resolve with undefined (relevant only if it was not activated so far)\n\t\tresolve(undefined);\n\t});\n\n\treturn promise;\n}\n\nasync function _activateIfFileName(host: IExtensionActivationHost, fileName: string, activate: (activationEvent: string) => void): Promise<void> {\n\t// find exact path\n\tfor (const uri of host.folders) {\n\t\tif (await host.exists(resources.joinPath(URI.revive(uri), fileName))) {\n\t\t\t// the file was found\n\t\t\tactivate(`workspaceContains:${fileName}`);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nasync function _activateIfGlobPatterns(host: IExtensionActivationHost, extensionId: ExtensionIdentifier, globPatterns: string[], activate: (activationEvent: string) => void): Promise<void> {\n\tif (globPatterns.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tconst tokenSource = new CancellationTokenSource();\n\tconst searchP = host.checkExists(host.folders, globPatterns, tokenSource.token);\n\n\tconst timer = setTimeout(async () => {\n\t\ttokenSource.cancel();\n\t\thost.logService.info(`Not activating extension '${extensionId.value}': Timed out while searching for 'workspaceContains' pattern ${globPatterns.join(',')}`);\n\t}, WORKSPACE_CONTAINS_TIMEOUT);\n\n\tlet exists: boolean = false;\n\ttry {\n\t\texists = await searchP;\n\t} catch (err) {\n\t\tif (!errors.isCancellationError(err)) {\n\t\t\terrors.onUnexpectedError(err);\n\t\t}\n\t}\n\n\ttokenSource.dispose();\n\tclearTimeout(timer);\n\n\tif (exists) {\n\t\t// a file was found matching one of the glob patterns\n\t\tactivate(`workspaceContains:${globPatterns.join(',')}`);\n\t}\n}\n\nexport function checkGlobFileExists(\n\taccessor: ServicesAccessor,\n\tfolders: readonly UriComponents[],\n\tincludes: string[],\n\ttoken: CancellationToken,\n): Promise<boolean> {\n\tconst instantiationService = accessor.get(IInstantiationService);\n\tconst searchService = accessor.get(ISearchService);\n\tconst queryBuilder = instantiationService.createInstance(QueryBuilder);\n\tconst query = queryBuilder.file(folders.map(folder => toWorkspaceFolder(URI.revive(folder))), {\n\t\t_reason: 'checkExists',\n\t\tincludePattern: includes,\n\t\texists: true\n\t});\n\n\treturn searchService.fileSearch(query, token).then(\n\t\tresult => {\n\t\t\treturn !!result.limitHit;\n\t\t},\n\t\terr => {\n\t\t\tif (!errors.isCancellationError(err)) {\n\t\t\t\treturn Promise.reject(err);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as resources from '../../../../base/common/resources.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { CancellationTokenSource, CancellationToken } from '../../../../base/common/cancellation.js';\nimport * as errors from '../../../../base/common/errors.js';\nimport { ExtensionIdentifier, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService, ServicesAccessor } from '../../../../platform/instantiation/common/instantiation.js';\nimport { QueryBuilder } from '../../search/common/queryBuilder.js';\nimport { ISearchService } from '../../search/common/search.js';\nimport { toWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { promiseWithResolvers } from '../../../../base/common/async.js';\n\nconst WORKSPACE_CONTAINS_TIMEOUT = 7000;\n\nexport interface IExtensionActivationHost {\n\treadonly logService: ILogService;\n\treadonly folders: readonly UriComponents[];\n\treadonly forceUsingSearch: boolean;\n\n\texists(uri: URI): Promise<boolean>;\n\tcheckExists(folders: readonly UriComponents[], includes: string[], token: CancellationToken): Promise<boolean>;\n}\n\nexport interface IExtensionActivationResult {\n\tactivationEvent: string;\n}\n\nexport function checkActivateWorkspaceContainsExtension(host: IExtensionActivationHost, desc: IExtensionDescription): Promise<IExtensionActivationResult | undefined> {\n\tconst activationEvents = desc.activationEvents;\n\tif (!activationEvents) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tconst fileNames: string[] = [];\n\tconst globPatterns: string[] = [];\n\n\tfor (const activationEvent of activationEvents) {\n\t\tif (/^workspaceContains:/.test(activationEvent)) {\n\t\t\tconst fileNameOrGlob = activationEvent.substr('workspaceContains:'.length);\n\t\t\tif (fileNameOrGlob.indexOf('*') >= 0 || fileNameOrGlob.indexOf('?') >= 0 || host.forceUsingSearch) {\n\t\t\t\tglobPatterns.push(fileNameOrGlob);\n\t\t\t} else {\n\t\t\t\tfileNames.push(fileNameOrGlob);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fileNames.length === 0 && globPatterns.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tconst { promise, resolve } = promiseWithResolvers<IExtensionActivationResult | undefined>();\n\tconst activate = (activationEvent: string) => resolve({ activationEvent });\n\n\tconst fileNamePromise = Promise.all(fileNames.map((fileName) => _activateIfFileName(host, fileName, activate))).then(() => { });\n\tconst globPatternPromise = _activateIfGlobPatterns(host, desc.identifier, globPatterns, activate);\n\n\tPromise.all([fileNamePromise, globPatternPromise]).then(() => {\n\t\t// when all are done, resolve with undefined (relevant only if it was not activated so far)\n\t\tresolve(undefined);\n\t});\n\n\treturn promise;\n}\n\nasync function _activateIfFileName(host: IExtensionActivationHost, fileName: string, activate: (activationEvent: string) => void): Promise<void> {\n\t// find exact path\n\tfor (const uri of host.folders) {\n\t\tif (await host.exists(resources.joinPath(URI.revive(uri), fileName))) {\n\t\t\t// the file was found\n\t\t\tactivate(`workspaceContains:${fileName}`);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nasync function _activateIfGlobPatterns(host: IExtensionActivationHost, extensionId: ExtensionIdentifier, globPatterns: string[], activate: (activationEvent: string) => void): Promise<void> {\n\tif (globPatterns.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tconst tokenSource = new CancellationTokenSource();\n\tconst searchP = host.checkExists(host.folders, globPatterns, tokenSource.token);\n\n\tconst timer = setTimeout(async () => {\n\t\ttokenSource.cancel();\n\t\thost.logService.info(`Not activating extension '${extensionId.value}': Timed out while searching for 'workspaceContains' pattern ${globPatterns.join(',')}`);\n\t}, WORKSPACE_CONTAINS_TIMEOUT);\n\n\tlet exists: boolean = false;\n\ttry {\n\t\texists = await searchP;\n\t} catch (err) {\n\t\tif (!errors.isCancellationError(err)) {\n\t\t\terrors.onUnexpectedError(err);\n\t\t}\n\t}\n\n\ttokenSource.dispose();\n\tclearTimeout(timer);\n\n\tif (exists) {\n\t\t// a file was found matching one of the glob patterns\n\t\tactivate(`workspaceContains:${globPatterns.join(',')}`);\n\t}\n}\n\nexport function checkGlobFileExists(\n\taccessor: ServicesAccessor,\n\tfolders: readonly UriComponents[],\n\tincludes: string[],\n\ttoken: CancellationToken,\n): Promise<boolean> {\n\tconst instantiationService = accessor.get(IInstantiationService);\n\tconst searchService = accessor.get(ISearchService);\n\tconst queryBuilder = instantiationService.createInstance(QueryBuilder);\n\tconst query = queryBuilder.file(folders.map(folder => toWorkspaceFolder(URI.revive(folder))), {\n\t\t_reason: 'checkExists',\n\t\tincludePattern: includes,\n\t\texists: true\n\t});\n\n\treturn searchService.fileSearch(query, token).then(\n\t\tresult => {\n\t\t\treturn !!result.limitHit;\n\t\t},\n\t\terr => {\n\t\t\tif (!errors.isCancellationError(err)) {\n\t\t\t\treturn Promise.reject(err);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n}\n"]}