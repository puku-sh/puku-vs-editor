{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/aiEmbeddingVector/common/aiEmbeddingVectorService.ts","vs/workbench/services/aiEmbeddingVector/common/aiEmbeddingVectorService.ts"],"names":[],"mappings":"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","file":"aiEmbeddingVectorService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancelablePromise, createCancelablePromise, raceCancellablePromises, timeout } from '../../../../base/common/async.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\n\nexport const IAiEmbeddingVectorService = createDecorator<IAiEmbeddingVectorService>('IAiEmbeddingVectorService');\n\nexport interface IAiEmbeddingVectorService {\n\treadonly _serviceBrand: undefined;\n\n\tisEnabled(): boolean;\n\tgetEmbeddingVector(str: string, token: CancellationToken): Promise<number[]>;\n\tgetEmbeddingVector(strings: string[], token: CancellationToken): Promise<number[][]>;\n\tregisterAiEmbeddingVectorProvider(model: string, provider: IAiEmbeddingVectorProvider): IDisposable;\n}\n\nexport interface IAiEmbeddingVectorProvider {\n\tprovideAiEmbeddingVector(strings: string[], token: CancellationToken): Promise<number[][]>;\n}\n\nexport class AiEmbeddingVectorService implements IAiEmbeddingVectorService {\n\treadonly _serviceBrand: undefined;\n\n\tstatic readonly DEFAULT_TIMEOUT = 1000 * 10; // 10 seconds\n\n\tprivate readonly _providers: IAiEmbeddingVectorProvider[] = [];\n\n\tconstructor(@ILogService private readonly logService: ILogService) { }\n\n\tisEnabled(): boolean {\n\t\treturn this._providers.length > 0;\n\t}\n\n\tregisterAiEmbeddingVectorProvider(model: string, provider: IAiEmbeddingVectorProvider): IDisposable {\n\t\tthis._providers.push(provider);\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tconst index = this._providers.indexOf(provider);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tthis._providers.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tgetEmbeddingVector(str: string, token: CancellationToken): Promise<number[]>;\n\tgetEmbeddingVector(strings: string[], token: CancellationToken): Promise<number[][]>;\n\tasync getEmbeddingVector(strings: string | string[], token: CancellationToken): Promise<number[] | number[][]> {\n\t\tif (this._providers.length === 0) {\n\t\t\tthrow new Error('No embedding vector providers registered');\n\t\t}\n\n\t\tconst stopwatch = StopWatch.create();\n\n\t\tconst cancellablePromises: Array<CancelablePromise<number[][]>> = [];\n\n\t\tconst timer = timeout(AiEmbeddingVectorService.DEFAULT_TIMEOUT);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tdisposable.dispose();\n\t\t\ttimer.cancel();\n\t\t});\n\n\t\tfor (const provider of this._providers) {\n\t\t\tcancellablePromises.push(createCancelablePromise(async t => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await provider.provideAiEmbeddingVector(\n\t\t\t\t\t\tArray.isArray(strings) ? strings : [strings],\n\t\t\t\t\t\tt\n\t\t\t\t\t);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// logged in extension host\n\t\t\t\t}\n\t\t\t\t// Wait for the timer to finish to allow for another provider to resolve.\n\t\t\t\t// Alternatively, if something resolved, or we've timed out, this will throw\n\t\t\t\t// as expected.\n\t\t\t\tawait timer;\n\t\t\t\tthrow new Error('Embedding vector provider timed out');\n\t\t\t}));\n\t\t}\n\n\t\tcancellablePromises.push(createCancelablePromise(async (t) => {\n\t\t\tconst disposable = t.onCancellationRequested(() => {\n\t\t\t\ttimer.cancel();\n\t\t\t\tdisposable.dispose();\n\t\t\t});\n\t\t\tawait timer;\n\t\t\tthrow new Error('Embedding vector provider timed out');\n\t\t}));\n\n\t\ttry {\n\t\t\tconst result = await raceCancellablePromises(cancellablePromises);\n\n\t\t\t// If we have a single result, return it directly, otherwise return an array.\n\t\t\t// This aligns with the API overloads.\n\t\t\tif (result.length === 1) {\n\t\t\t\treturn result[0];\n\t\t\t}\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tstopwatch.stop();\n\t\t\tthis.logService.trace(`[AiEmbeddingVectorService]: getEmbeddingVector took ${stopwatch.elapsed()}ms`);\n\t\t}\n\t}\n}\n\nregisterSingleton(IAiEmbeddingVectorService, AiEmbeddingVectorService, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancelablePromise, createCancelablePromise, raceCancellablePromises, timeout } from '../../../../base/common/async.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\n\nexport const IAiEmbeddingVectorService = createDecorator<IAiEmbeddingVectorService>('IAiEmbeddingVectorService');\n\nexport interface IAiEmbeddingVectorService {\n\treadonly _serviceBrand: undefined;\n\n\tisEnabled(): boolean;\n\tgetEmbeddingVector(str: string, token: CancellationToken): Promise<number[]>;\n\tgetEmbeddingVector(strings: string[], token: CancellationToken): Promise<number[][]>;\n\tregisterAiEmbeddingVectorProvider(model: string, provider: IAiEmbeddingVectorProvider): IDisposable;\n}\n\nexport interface IAiEmbeddingVectorProvider {\n\tprovideAiEmbeddingVector(strings: string[], token: CancellationToken): Promise<number[][]>;\n}\n\nexport class AiEmbeddingVectorService implements IAiEmbeddingVectorService {\n\treadonly _serviceBrand: undefined;\n\n\tstatic readonly DEFAULT_TIMEOUT = 1000 * 10; // 10 seconds\n\n\tprivate readonly _providers: IAiEmbeddingVectorProvider[] = [];\n\n\tconstructor(@ILogService private readonly logService: ILogService) { }\n\n\tisEnabled(): boolean {\n\t\treturn this._providers.length > 0;\n\t}\n\n\tregisterAiEmbeddingVectorProvider(model: string, provider: IAiEmbeddingVectorProvider): IDisposable {\n\t\tthis._providers.push(provider);\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tconst index = this._providers.indexOf(provider);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tthis._providers.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tgetEmbeddingVector(str: string, token: CancellationToken): Promise<number[]>;\n\tgetEmbeddingVector(strings: string[], token: CancellationToken): Promise<number[][]>;\n\tasync getEmbeddingVector(strings: string | string[], token: CancellationToken): Promise<number[] | number[][]> {\n\t\tif (this._providers.length === 0) {\n\t\t\tthrow new Error('No embedding vector providers registered');\n\t\t}\n\n\t\tconst stopwatch = StopWatch.create();\n\n\t\tconst cancellablePromises: Array<CancelablePromise<number[][]>> = [];\n\n\t\tconst timer = timeout(AiEmbeddingVectorService.DEFAULT_TIMEOUT);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tdisposable.dispose();\n\t\t\ttimer.cancel();\n\t\t});\n\n\t\tfor (const provider of this._providers) {\n\t\t\tcancellablePromises.push(createCancelablePromise(async t => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await provider.provideAiEmbeddingVector(\n\t\t\t\t\t\tArray.isArray(strings) ? strings : [strings],\n\t\t\t\t\t\tt\n\t\t\t\t\t);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// logged in extension host\n\t\t\t\t}\n\t\t\t\t// Wait for the timer to finish to allow for another provider to resolve.\n\t\t\t\t// Alternatively, if something resolved, or we've timed out, this will throw\n\t\t\t\t// as expected.\n\t\t\t\tawait timer;\n\t\t\t\tthrow new Error('Embedding vector provider timed out');\n\t\t\t}));\n\t\t}\n\n\t\tcancellablePromises.push(createCancelablePromise(async (t) => {\n\t\t\tconst disposable = t.onCancellationRequested(() => {\n\t\t\t\ttimer.cancel();\n\t\t\t\tdisposable.dispose();\n\t\t\t});\n\t\t\tawait timer;\n\t\t\tthrow new Error('Embedding vector provider timed out');\n\t\t}));\n\n\t\ttry {\n\t\t\tconst result = await raceCancellablePromises(cancellablePromises);\n\n\t\t\t// If we have a single result, return it directly, otherwise return an array.\n\t\t\t// This aligns with the API overloads.\n\t\t\tif (result.length === 1) {\n\t\t\t\treturn result[0];\n\t\t\t}\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tstopwatch.stop();\n\t\t\tthis.logService.trace(`[AiEmbeddingVectorService]: getEmbeddingVector took ${stopwatch.elapsed()}ms`);\n\t\t}\n\t}\n}\n\nregisterSingleton(IAiEmbeddingVectorService, AiEmbeddingVectorService, InstantiationType.Delayed);\n"]}