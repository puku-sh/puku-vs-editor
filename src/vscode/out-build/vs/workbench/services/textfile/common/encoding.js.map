{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/textfile/common/encoding.ts","vs/workbench/services/textfile/common/encoding.ts"],"names":[],"mappings":"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","file":"encoding.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Readable, ReadableStream, newWriteableStream, listenStream } from '../../../../base/common/stream.js';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { importAMDNodeModule } from '../../../../amdX.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\n\nexport const UTF8 = 'utf8';\nexport const UTF8_with_bom = 'utf8bom';\nexport const UTF16be = 'utf16be';\nexport const UTF16le = 'utf16le';\n\nexport type UTF_ENCODING = typeof UTF8 | typeof UTF8_with_bom | typeof UTF16be | typeof UTF16le;\n\nexport function isUTFEncoding(encoding: string): encoding is UTF_ENCODING {\n\treturn [UTF8, UTF8_with_bom, UTF16be, UTF16le].some(utfEncoding => utfEncoding === encoding);\n}\n\nexport const UTF16be_BOM = [0xFE, 0xFF];\nexport const UTF16le_BOM = [0xFF, 0xFE];\nexport const UTF8_BOM = [0xEF, 0xBB, 0xBF];\n\nconst ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512; \t// number of bytes to look at to decide about a file being binary or not\nconst NO_ENCODING_GUESS_MIN_BYTES = 512; \t\t\t// when not auto guessing the encoding, small number of bytes are enough\nconst AUTO_ENCODING_GUESS_MIN_BYTES = 512 * 8; \t\t// with auto guessing we want a lot more content to be read for guessing\nconst AUTO_ENCODING_GUESS_MAX_BYTES = 512 * 128; \t// set an upper limit for the number of bytes we pass on to jschardet\n\nexport interface IDecodeStreamOptions {\n\tacceptTextOnly: boolean;\n\tguessEncoding: boolean;\n\tcandidateGuessEncodings: string[];\n\tminBytesRequiredForDetection?: number;\n\n\toverwriteEncoding(detectedEncoding: string | null): Promise<string>;\n}\n\nexport interface IDecodeStreamResult {\n\tstream: ReadableStream<string>;\n\tdetected: IDetectedEncodingResult;\n}\n\nexport const enum DecodeStreamErrorKind {\n\n\t/**\n\t * Error indicating that the stream is binary even\n\t * though `acceptTextOnly` was specified.\n\t */\n\tSTREAM_IS_BINARY = 1\n}\n\nexport class DecodeStreamError extends Error {\n\n\tconstructor(\n\t\tmessage: string,\n\t\treadonly decodeStreamErrorKind: DecodeStreamErrorKind\n\t) {\n\t\tsuper(message);\n\t}\n}\n\nexport interface IDecoderStream {\n\twrite(buffer: Uint8Array): string;\n\tend(): string | undefined;\n}\n\nclass DecoderStream implements IDecoderStream {\n\n\t/**\n\t * This stream will only load iconv-lite lazily if the encoding\n\t * is not UTF-8. This ensures that for most common cases we do\n\t * not pay the price of loading the module from disk.\n\t *\n\t * We still need to be careful when converting UTF-8 to a string\n\t * though because we read the file in chunks of Buffer and thus\n\t * need to decode it via TextDecoder helper that is available\n\t * in browser and node.js environments.\n\t */\n\tstatic async create(encoding: string): Promise<DecoderStream> {\n\t\tlet decoder: IDecoderStream | undefined = undefined;\n\t\tif (encoding !== UTF8) {\n\t\t\tconst iconv = await importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js');\n\t\t\tdecoder = iconv.getDecoder(toNodeEncoding(encoding));\n\t\t} else {\n\t\t\tconst utf8TextDecoder = new TextDecoder();\n\t\t\tdecoder = {\n\t\t\t\twrite(buffer: Uint8Array): string {\n\t\t\t\t\treturn utf8TextDecoder.decode(buffer, {\n\t\t\t\t\t\t// Signal to TextDecoder that potentially more data is coming\n\t\t\t\t\t\t// and that we are calling `decode` in the end to consume any\n\t\t\t\t\t\t// remainders\n\t\t\t\t\t\tstream: true\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\tend(): string | undefined {\n\t\t\t\t\treturn utf8TextDecoder.decode();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\treturn new DecoderStream(decoder);\n\t}\n\n\tprivate constructor(private iconvLiteDecoder: IDecoderStream) { }\n\n\twrite(buffer: Uint8Array): string {\n\t\treturn this.iconvLiteDecoder.write(buffer);\n\t}\n\n\tend(): string | undefined {\n\t\treturn this.iconvLiteDecoder.end();\n\t}\n}\n\nexport function toDecodeStream(source: VSBufferReadableStream, options: IDecodeStreamOptions): Promise<IDecodeStreamResult> {\n\tconst minBytesRequiredForDetection = options.minBytesRequiredForDetection ?? (options.guessEncoding ? AUTO_ENCODING_GUESS_MIN_BYTES : NO_ENCODING_GUESS_MIN_BYTES);\n\n\treturn new Promise<IDecodeStreamResult>((resolve, reject) => {\n\t\tconst target = newWriteableStream<string>(strings => strings.join(''));\n\n\t\tconst bufferedChunks: VSBuffer[] = [];\n\t\tlet bytesBuffered = 0;\n\n\t\tlet decoder: IDecoderStream | undefined = undefined;\n\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst createDecoder = async () => {\n\t\t\ttry {\n\n\t\t\t\t// detect encoding from buffer\n\t\t\t\tconst detected = await detectEncodingFromBuffer({\n\t\t\t\t\tbuffer: VSBuffer.concat(bufferedChunks),\n\t\t\t\t\tbytesRead: bytesBuffered\n\t\t\t\t}, options.guessEncoding, options.candidateGuessEncodings);\n\n\t\t\t\t// throw early if the source seems binary and\n\t\t\t\t// we are instructed to only accept text\n\t\t\t\tif (detected.seemsBinary && options.acceptTextOnly) {\n\t\t\t\t\tthrow new DecodeStreamError('Stream is binary but only text is accepted for decoding', DecodeStreamErrorKind.STREAM_IS_BINARY);\n\t\t\t\t}\n\n\t\t\t\t// ensure to respect overwrite of encoding\n\t\t\t\tdetected.encoding = await options.overwriteEncoding(detected.encoding);\n\n\t\t\t\t// decode and write buffered content\n\t\t\t\tdecoder = await DecoderStream.create(detected.encoding);\n\t\t\t\tconst decoded = decoder.write(VSBuffer.concat(bufferedChunks).buffer);\n\t\t\t\ttarget.write(decoded);\n\n\t\t\t\tbufferedChunks.length = 0;\n\t\t\t\tbytesBuffered = 0;\n\n\t\t\t\t// signal to the outside our detected encoding and final decoder stream\n\t\t\t\tresolve({\n\t\t\t\t\tstream: target,\n\t\t\t\t\tdetected\n\t\t\t\t});\n\t\t\t} catch (error) {\n\n\t\t\t\t// Stop handling anything from the source and target\n\t\t\t\tcts.cancel();\n\t\t\t\ttarget.destroy();\n\n\t\t\t\treject(error);\n\t\t\t}\n\t\t};\n\n\t\tlistenStream(source, {\n\t\t\tonData: async chunk => {\n\n\t\t\t\t// if the decoder is ready, we just write directly\n\t\t\t\tif (decoder) {\n\t\t\t\t\ttarget.write(decoder.write(chunk.buffer));\n\t\t\t\t}\n\n\t\t\t\t// otherwise we need to buffer the data until the stream is ready\n\t\t\t\telse {\n\t\t\t\t\tbufferedChunks.push(chunk);\n\t\t\t\t\tbytesBuffered += chunk.byteLength;\n\n\t\t\t\t\t// buffered enough data for encoding detection, create stream\n\t\t\t\t\tif (bytesBuffered >= minBytesRequiredForDetection) {\n\n\t\t\t\t\t\t// pause stream here until the decoder is ready\n\t\t\t\t\t\tsource.pause();\n\n\t\t\t\t\t\tawait createDecoder();\n\n\t\t\t\t\t\t// resume stream now that decoder is ready but\n\t\t\t\t\t\t// outside of this stack to reduce recursion\n\t\t\t\t\t\tsetTimeout(() => source.resume());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => target.error(error), // simply forward to target\n\t\t\tonEnd: async () => {\n\n\t\t\t\t// we were still waiting for data to do the encoding\n\t\t\t\t// detection. thus, wrap up starting the stream even\n\t\t\t\t// without all the data to get things going\n\t\t\t\tif (!decoder) {\n\t\t\t\t\tawait createDecoder();\n\t\t\t\t}\n\n\t\t\t\t// end the target with the remainders of the decoder\n\t\t\t\ttarget.end(decoder?.end());\n\t\t\t}\n\t\t}, cts.token);\n\t});\n}\n\nexport async function toEncodeReadable(readable: Readable<string>, encoding: string, options?: { addBOM?: boolean }): Promise<VSBufferReadable> {\n\tconst iconv = await importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js');\n\tconst encoder = iconv.getEncoder(toNodeEncoding(encoding), options);\n\n\tlet bytesWritten = false;\n\tlet done = false;\n\n\treturn {\n\t\tread() {\n\t\t\tif (done) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst chunk = readable.read();\n\t\t\tif (typeof chunk !== 'string') {\n\t\t\t\tdone = true;\n\n\t\t\t\t// If we are instructed to add a BOM but we detect that no\n\t\t\t\t// bytes have been written, we must ensure to return the BOM\n\t\t\t\t// ourselves so that we comply with the contract.\n\t\t\t\tif (!bytesWritten && options?.addBOM) {\n\t\t\t\t\tswitch (encoding) {\n\t\t\t\t\t\tcase UTF8:\n\t\t\t\t\t\tcase UTF8_with_bom:\n\t\t\t\t\t\t\treturn VSBuffer.wrap(Uint8Array.from(UTF8_BOM));\n\t\t\t\t\t\tcase UTF16be:\n\t\t\t\t\t\t\treturn VSBuffer.wrap(Uint8Array.from(UTF16be_BOM));\n\t\t\t\t\t\tcase UTF16le:\n\t\t\t\t\t\t\treturn VSBuffer.wrap(Uint8Array.from(UTF16le_BOM));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst leftovers = encoder.end();\n\t\t\t\tif (leftovers && leftovers.length > 0) {\n\t\t\t\t\tbytesWritten = true;\n\n\t\t\t\t\treturn VSBuffer.wrap(leftovers);\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tbytesWritten = true;\n\n\t\t\treturn VSBuffer.wrap(encoder.write(chunk));\n\t\t}\n\t};\n}\n\nexport async function encodingExists(encoding: string): Promise<boolean> {\n\tconst iconv = await importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js');\n\n\treturn iconv.encodingExists(toNodeEncoding(encoding));\n}\n\nexport function toNodeEncoding(enc: string | null): string {\n\tif (enc === UTF8_with_bom || enc === null) {\n\t\treturn UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it\n\t}\n\n\treturn enc;\n}\n\nexport function detectEncodingByBOMFromBuffer(buffer: VSBuffer | null, bytesRead: number): typeof UTF8_with_bom | typeof UTF16le | typeof UTF16be | null {\n\tif (!buffer || bytesRead < UTF16be_BOM.length) {\n\t\treturn null;\n\t}\n\n\tconst b0 = buffer.readUInt8(0);\n\tconst b1 = buffer.readUInt8(1);\n\n\t// UTF-16 BE\n\tif (b0 === UTF16be_BOM[0] && b1 === UTF16be_BOM[1]) {\n\t\treturn UTF16be;\n\t}\n\n\t// UTF-16 LE\n\tif (b0 === UTF16le_BOM[0] && b1 === UTF16le_BOM[1]) {\n\t\treturn UTF16le;\n\t}\n\n\tif (bytesRead < UTF8_BOM.length) {\n\t\treturn null;\n\t}\n\n\tconst b2 = buffer.readUInt8(2);\n\n\t// UTF-8\n\tif (b0 === UTF8_BOM[0] && b1 === UTF8_BOM[1] && b2 === UTF8_BOM[2]) {\n\t\treturn UTF8_with_bom;\n\t}\n\n\treturn null;\n}\n\n// we explicitly ignore a specific set of encodings from auto guessing\n// - ASCII: we never want this encoding (most UTF-8 files would happily detect as\n//          ASCII files and then you could not type non-ASCII characters anymore)\n// - UTF-16: we have our own detection logic for UTF-16\n// - UTF-32: we do not support this encoding in VSCode\nconst IGNORE_ENCODINGS = ['ascii', 'utf-16', 'utf-32'];\n\n/**\n * Guesses the encoding from buffer.\n */\nasync function guessEncodingByBuffer(buffer: VSBuffer, candidateGuessEncodings?: string[]): Promise<string | null> {\n\tconst jschardet = await importAMDNodeModule<typeof import('jschardet')>('jschardet', 'dist/jschardet.min.js');\n\n\t// ensure to limit buffer for guessing due to https://github.com/aadsm/jschardet/issues/53\n\tconst limitedBuffer = buffer.slice(0, AUTO_ENCODING_GUESS_MAX_BYTES);\n\n\t// before guessing jschardet calls toString('binary') on input if it is a Buffer,\n\t// since we are using it inside browser environment as well we do conversion ourselves\n\t// https://github.com/aadsm/jschardet/blob/v2.1.1/src/index.js#L36-L40\n\tconst binaryString = encodeLatin1(limitedBuffer.buffer);\n\n\t// ensure to convert candidate encodings to jschardet encoding names if provided\n\tif (candidateGuessEncodings) {\n\t\tcandidateGuessEncodings = coalesce(candidateGuessEncodings.map(e => toJschardetEncoding(e)));\n\t\tif (candidateGuessEncodings.length === 0) {\n\t\t\tcandidateGuessEncodings = undefined;\n\t\t}\n\t}\n\n\tlet guessed: { encoding: string | undefined } | undefined;\n\ttry {\n\t\tguessed = jschardet.detect(binaryString, candidateGuessEncodings ? { detectEncodings: candidateGuessEncodings } : undefined);\n\t} catch (error) {\n\t\treturn null; // jschardet throws for unknown encodings (https://github.com/microsoft/vscode/issues/239928)\n\t}\n\n\tif (!guessed?.encoding) {\n\t\treturn null;\n\t}\n\n\tconst enc = guessed.encoding.toLowerCase();\n\tif (0 <= IGNORE_ENCODINGS.indexOf(enc)) {\n\t\treturn null; // see comment above why we ignore some encodings\n\t}\n\n\treturn toIconvLiteEncoding(guessed.encoding);\n}\n\nconst JSCHARDET_TO_ICONV_ENCODINGS: { [name: string]: string } = {\n\t'ibm866': 'cp866',\n\t'big5': 'cp950'\n};\n\nfunction normalizeEncoding(encodingName: string): string {\n\treturn encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n}\n\nfunction toIconvLiteEncoding(encodingName: string): string {\n\tconst normalizedEncodingName = normalizeEncoding(encodingName);\n\tconst mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];\n\n\treturn mapped || normalizedEncodingName;\n}\n\nfunction toJschardetEncoding(encodingName: string): string | undefined {\n\tconst normalizedEncodingName = normalizeEncoding(encodingName);\n\tconst mapped = GUESSABLE_ENCODINGS[normalizedEncodingName];\n\n\treturn mapped ? mapped.guessableName : undefined;\n}\n\nfunction encodeLatin1(buffer: Uint8Array): string {\n\tlet result = '';\n\tfor (let i = 0; i < buffer.length; i++) {\n\t\tresult += String.fromCharCode(buffer[i]);\n\t}\n\n\treturn result;\n}\n\n/**\n * The encodings that are allowed in a settings file don't match the canonical encoding labels specified by WHATWG.\n * See https://encoding.spec.whatwg.org/#names-and-labels\n * Iconv-lite strips all non-alphanumeric characters, but ripgrep doesn't. For backcompat, allow these labels.\n */\nexport function toCanonicalName(enc: string): string {\n\tswitch (enc) {\n\t\tcase 'shiftjis':\n\t\t\treturn 'shift-jis';\n\t\tcase 'utf16le':\n\t\t\treturn 'utf-16le';\n\t\tcase 'utf16be':\n\t\t\treturn 'utf-16be';\n\t\tcase 'big5hkscs':\n\t\t\treturn 'big5-hkscs';\n\t\tcase 'eucjp':\n\t\t\treturn 'euc-jp';\n\t\tcase 'euckr':\n\t\t\treturn 'euc-kr';\n\t\tcase 'koi8r':\n\t\t\treturn 'koi8-r';\n\t\tcase 'koi8u':\n\t\t\treturn 'koi8-u';\n\t\tcase 'macroman':\n\t\t\treturn 'x-mac-roman';\n\t\tcase 'utf8bom':\n\t\t\treturn 'utf8';\n\t\tdefault: {\n\t\t\tconst m = enc.match(/windows(\\d+)/);\n\t\t\tif (m) {\n\t\t\t\treturn 'windows-' + m[1];\n\t\t\t}\n\n\t\t\treturn enc;\n\t\t}\n\t}\n}\n\nexport interface IDetectedEncodingResult {\n\tencoding: string | null;\n\tseemsBinary: boolean;\n}\n\nexport interface IReadResult {\n\tbuffer: VSBuffer | null;\n\tbytesRead: number;\n}\n\nexport function detectEncodingFromBuffer(readResult: IReadResult, autoGuessEncoding?: false, candidateGuessEncodings?: string[]): IDetectedEncodingResult;\nexport function detectEncodingFromBuffer(readResult: IReadResult, autoGuessEncoding?: boolean, candidateGuessEncodings?: string[]): Promise<IDetectedEncodingResult>;\nexport function detectEncodingFromBuffer({ buffer, bytesRead }: IReadResult, autoGuessEncoding?: boolean, candidateGuessEncodings?: string[]): Promise<IDetectedEncodingResult> | IDetectedEncodingResult {\n\n\t// Always first check for BOM to find out about encoding\n\tlet encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);\n\n\t// Detect 0 bytes to see if file is binary or UTF-16 LE/BE\n\t// unless we already know that this file has a UTF-16 encoding\n\tlet seemsBinary = false;\n\tif (encoding !== UTF16be && encoding !== UTF16le && buffer) {\n\t\tlet couldBeUTF16LE = true; // e.g. 0xAA 0x00\n\t\tlet couldBeUTF16BE = true; // e.g. 0x00 0xAA\n\t\tlet containsZeroByte = false;\n\n\t\t// This is a simplified guess to detect UTF-16 BE or LE by just checking if\n\t\t// the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE\n\t\t// this would be the odd byte index and for UTF-16 BE the even one.\n\t\t// Note: this can produce false positives (a binary file that uses a 2-byte\n\t\t// encoding of the same format as UTF-16) and false negatives (a UTF-16 file\n\t\t// that is using 4 bytes to encode a character).\n\t\tfor (let i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {\n\t\t\tconst isEndian = (i % 2 === 1); // assume 2-byte sequences typical for UTF-16\n\t\t\tconst isZeroByte = (buffer.readUInt8(i) === 0);\n\n\t\t\tif (isZeroByte) {\n\t\t\t\tcontainsZeroByte = true;\n\t\t\t}\n\n\t\t\t// UTF-16 LE: expect e.g. 0xAA 0x00\n\t\t\tif (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {\n\t\t\t\tcouldBeUTF16LE = false;\n\t\t\t}\n\n\t\t\t// UTF-16 BE: expect e.g. 0x00 0xAA\n\t\t\tif (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {\n\t\t\t\tcouldBeUTF16BE = false;\n\t\t\t}\n\n\t\t\t// Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary\n\t\t\tif (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Handle case of 0-byte included\n\t\tif (containsZeroByte) {\n\t\t\tif (couldBeUTF16LE) {\n\t\t\t\tencoding = UTF16le;\n\t\t\t} else if (couldBeUTF16BE) {\n\t\t\t\tencoding = UTF16be;\n\t\t\t} else {\n\t\t\t\tseemsBinary = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Auto guess encoding if configured\n\tif (autoGuessEncoding && !seemsBinary && !encoding && buffer) {\n\t\treturn guessEncodingByBuffer(buffer.slice(0, bytesRead), candidateGuessEncodings).then(guessedEncoding => {\n\t\t\treturn {\n\t\t\t\tseemsBinary: false,\n\t\t\t\tencoding: guessedEncoding\n\t\t\t};\n\t\t});\n\t}\n\n\treturn { seemsBinary, encoding };\n}\n\ntype EncodingsMap = { [encoding: string]: { labelLong: string; labelShort: string; order: number; encodeOnly?: boolean; alias?: string; guessableName?: string } };\n\nexport const SUPPORTED_ENCODINGS: EncodingsMap = {\n\tutf8: {\n\t\tlabelLong: 'UTF-8',\n\t\tlabelShort: 'UTF-8',\n\t\torder: 1,\n\t\talias: 'utf8bom',\n\t\tguessableName: 'UTF-8'\n\t},\n\tutf8bom: {\n\t\tlabelLong: 'UTF-8 with BOM',\n\t\tlabelShort: 'UTF-8 with BOM',\n\t\tencodeOnly: true,\n\t\torder: 2,\n\t\talias: 'utf8'\n\t},\n\tutf16le: {\n\t\tlabelLong: 'UTF-16 LE',\n\t\tlabelShort: 'UTF-16 LE',\n\t\torder: 3,\n\t\tguessableName: 'UTF-16LE'\n\t},\n\tutf16be: {\n\t\tlabelLong: 'UTF-16 BE',\n\t\tlabelShort: 'UTF-16 BE',\n\t\torder: 4,\n\t\tguessableName: 'UTF-16BE'\n\t},\n\twindows1252: {\n\t\tlabelLong: 'Western (Windows 1252)',\n\t\tlabelShort: 'Windows 1252',\n\t\torder: 5,\n\t\tguessableName: 'windows-1252'\n\t},\n\tiso88591: {\n\t\tlabelLong: 'Western (ISO 8859-1)',\n\t\tlabelShort: 'ISO 8859-1',\n\t\torder: 6\n\t},\n\tiso88593: {\n\t\tlabelLong: 'Western (ISO 8859-3)',\n\t\tlabelShort: 'ISO 8859-3',\n\t\torder: 7\n\t},\n\tiso885915: {\n\t\tlabelLong: 'Western (ISO 8859-15)',\n\t\tlabelShort: 'ISO 8859-15',\n\t\torder: 8\n\t},\n\tmacroman: {\n\t\tlabelLong: 'Western (Mac Roman)',\n\t\tlabelShort: 'Mac Roman',\n\t\torder: 9\n\t},\n\tcp437: {\n\t\tlabelLong: 'DOS (CP 437)',\n\t\tlabelShort: 'CP437',\n\t\torder: 10\n\t},\n\twindows1256: {\n\t\tlabelLong: 'Arabic (Windows 1256)',\n\t\tlabelShort: 'Windows 1256',\n\t\torder: 11\n\t},\n\tiso88596: {\n\t\tlabelLong: 'Arabic (ISO 8859-6)',\n\t\tlabelShort: 'ISO 8859-6',\n\t\torder: 12\n\t},\n\twindows1257: {\n\t\tlabelLong: 'Baltic (Windows 1257)',\n\t\tlabelShort: 'Windows 1257',\n\t\torder: 13\n\t},\n\tiso88594: {\n\t\tlabelLong: 'Baltic (ISO 8859-4)',\n\t\tlabelShort: 'ISO 8859-4',\n\t\torder: 14\n\t},\n\tiso885914: {\n\t\tlabelLong: 'Celtic (ISO 8859-14)',\n\t\tlabelShort: 'ISO 8859-14',\n\t\torder: 15\n\t},\n\twindows1250: {\n\t\tlabelLong: 'Central European (Windows 1250)',\n\t\tlabelShort: 'Windows 1250',\n\t\torder: 16,\n\t\tguessableName: 'windows-1250'\n\t},\n\tiso88592: {\n\t\tlabelLong: 'Central European (ISO 8859-2)',\n\t\tlabelShort: 'ISO 8859-2',\n\t\torder: 17,\n\t\tguessableName: 'ISO-8859-2'\n\t},\n\tcp852: {\n\t\tlabelLong: 'Central European (CP 852)',\n\t\tlabelShort: 'CP 852',\n\t\torder: 18\n\t},\n\twindows1251: {\n\t\tlabelLong: 'Cyrillic (Windows 1251)',\n\t\tlabelShort: 'Windows 1251',\n\t\torder: 19,\n\t\tguessableName: 'windows-1251'\n\t},\n\tcp866: {\n\t\tlabelLong: 'Cyrillic (CP 866)',\n\t\tlabelShort: 'CP 866',\n\t\torder: 20,\n\t\tguessableName: 'IBM866'\n\t},\n\tcp1125: {\n\t\tlabelLong: 'Cyrillic (CP 1125)',\n\t\tlabelShort: 'CP 1125',\n\t\torder: 21,\n\t\tguessableName: 'IBM1125'\n\t},\n\tiso88595: {\n\t\tlabelLong: 'Cyrillic (ISO 8859-5)',\n\t\tlabelShort: 'ISO 8859-5',\n\t\torder: 22,\n\t\tguessableName: 'ISO-8859-5'\n\t},\n\tkoi8r: {\n\t\tlabelLong: 'Cyrillic (KOI8-R)',\n\t\tlabelShort: 'KOI8-R',\n\t\torder: 23,\n\t\tguessableName: 'KOI8-R'\n\t},\n\tkoi8u: {\n\t\tlabelLong: 'Cyrillic (KOI8-U)',\n\t\tlabelShort: 'KOI8-U',\n\t\torder: 24\n\t},\n\tiso885913: {\n\t\tlabelLong: 'Estonian (ISO 8859-13)',\n\t\tlabelShort: 'ISO 8859-13',\n\t\torder: 25\n\t},\n\twindows1253: {\n\t\tlabelLong: 'Greek (Windows 1253)',\n\t\tlabelShort: 'Windows 1253',\n\t\torder: 26,\n\t\tguessableName: 'windows-1253'\n\t},\n\tiso88597: {\n\t\tlabelLong: 'Greek (ISO 8859-7)',\n\t\tlabelShort: 'ISO 8859-7',\n\t\torder: 27,\n\t\tguessableName: 'ISO-8859-7'\n\t},\n\twindows1255: {\n\t\tlabelLong: 'Hebrew (Windows 1255)',\n\t\tlabelShort: 'Windows 1255',\n\t\torder: 28,\n\t\tguessableName: 'windows-1255'\n\t},\n\tiso88598: {\n\t\tlabelLong: 'Hebrew (ISO 8859-8)',\n\t\tlabelShort: 'ISO 8859-8',\n\t\torder: 29,\n\t\tguessableName: 'ISO-8859-8'\n\t},\n\tiso885910: {\n\t\tlabelLong: 'Nordic (ISO 8859-10)',\n\t\tlabelShort: 'ISO 8859-10',\n\t\torder: 30\n\t},\n\tiso885916: {\n\t\tlabelLong: 'Romanian (ISO 8859-16)',\n\t\tlabelShort: 'ISO 8859-16',\n\t\torder: 31\n\t},\n\twindows1254: {\n\t\tlabelLong: 'Turkish (Windows 1254)',\n\t\tlabelShort: 'Windows 1254',\n\t\torder: 32\n\t},\n\tiso88599: {\n\t\tlabelLong: 'Turkish (ISO 8859-9)',\n\t\tlabelShort: 'ISO 8859-9',\n\t\torder: 33\n\t},\n\twindows1258: {\n\t\tlabelLong: 'Vietnamese (Windows 1258)',\n\t\tlabelShort: 'Windows 1258',\n\t\torder: 34\n\t},\n\tgbk: {\n\t\tlabelLong: 'Simplified Chinese (GBK)',\n\t\tlabelShort: 'GBK',\n\t\torder: 35\n\t},\n\tgb18030: {\n\t\tlabelLong: 'Simplified Chinese (GB18030)',\n\t\tlabelShort: 'GB18030',\n\t\torder: 36\n\t},\n\tcp950: {\n\t\tlabelLong: 'Traditional Chinese (Big5)',\n\t\tlabelShort: 'Big5',\n\t\torder: 37,\n\t\tguessableName: 'Big5'\n\t},\n\tbig5hkscs: {\n\t\tlabelLong: 'Traditional Chinese (Big5-HKSCS)',\n\t\tlabelShort: 'Big5-HKSCS',\n\t\torder: 38\n\t},\n\tshiftjis: {\n\t\tlabelLong: 'Japanese (Shift JIS)',\n\t\tlabelShort: 'Shift JIS',\n\t\torder: 39,\n\t\tguessableName: 'SHIFT_JIS'\n\t},\n\teucjp: {\n\t\tlabelLong: 'Japanese (EUC-JP)',\n\t\tlabelShort: 'EUC-JP',\n\t\torder: 40,\n\t\tguessableName: 'EUC-JP'\n\t},\n\teuckr: {\n\t\tlabelLong: 'Korean (EUC-KR)',\n\t\tlabelShort: 'EUC-KR',\n\t\torder: 41,\n\t\tguessableName: 'EUC-KR'\n\t},\n\twindows874: {\n\t\tlabelLong: 'Thai (Windows 874)',\n\t\tlabelShort: 'Windows 874',\n\t\torder: 42\n\t},\n\tiso885911: {\n\t\tlabelLong: 'Latin/Thai (ISO 8859-11)',\n\t\tlabelShort: 'ISO 8859-11',\n\t\torder: 43\n\t},\n\tkoi8ru: {\n\t\tlabelLong: 'Cyrillic (KOI8-RU)',\n\t\tlabelShort: 'KOI8-RU',\n\t\torder: 44\n\t},\n\tkoi8t: {\n\t\tlabelLong: 'Tajik (KOI8-T)',\n\t\tlabelShort: 'KOI8-T',\n\t\torder: 45\n\t},\n\tgb2312: {\n\t\tlabelLong: 'Simplified Chinese (GB 2312)',\n\t\tlabelShort: 'GB 2312',\n\t\torder: 46,\n\t\tguessableName: 'GB2312'\n\t},\n\tcp865: {\n\t\tlabelLong: 'Nordic DOS (CP 865)',\n\t\tlabelShort: 'CP 865',\n\t\torder: 47\n\t},\n\tcp850: {\n\t\tlabelLong: 'Western European DOS (CP 850)',\n\t\tlabelShort: 'CP 850',\n\t\torder: 48\n\t}\n};\n\nexport const GUESSABLE_ENCODINGS: EncodingsMap = (() => {\n\tconst guessableEncodings: EncodingsMap = {};\n\tfor (const encoding in SUPPORTED_ENCODINGS) {\n\t\tif (SUPPORTED_ENCODINGS[encoding].guessableName) {\n\t\t\tguessableEncodings[encoding] = SUPPORTED_ENCODINGS[encoding];\n\t\t}\n\t}\n\n\treturn guessableEncodings;\n})();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Readable, ReadableStream, newWriteableStream, listenStream } from '../../../../base/common/stream.js';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { importAMDNodeModule } from '../../../../amdX.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\n\nexport const UTF8 = 'utf8';\nexport const UTF8_with_bom = 'utf8bom';\nexport const UTF16be = 'utf16be';\nexport const UTF16le = 'utf16le';\n\nexport type UTF_ENCODING = typeof UTF8 | typeof UTF8_with_bom | typeof UTF16be | typeof UTF16le;\n\nexport function isUTFEncoding(encoding: string): encoding is UTF_ENCODING {\n\treturn [UTF8, UTF8_with_bom, UTF16be, UTF16le].some(utfEncoding => utfEncoding === encoding);\n}\n\nexport const UTF16be_BOM = [0xFE, 0xFF];\nexport const UTF16le_BOM = [0xFF, 0xFE];\nexport const UTF8_BOM = [0xEF, 0xBB, 0xBF];\n\nconst ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512; \t// number of bytes to look at to decide about a file being binary or not\nconst NO_ENCODING_GUESS_MIN_BYTES = 512; \t\t\t// when not auto guessing the encoding, small number of bytes are enough\nconst AUTO_ENCODING_GUESS_MIN_BYTES = 512 * 8; \t\t// with auto guessing we want a lot more content to be read for guessing\nconst AUTO_ENCODING_GUESS_MAX_BYTES = 512 * 128; \t// set an upper limit for the number of bytes we pass on to jschardet\n\nexport interface IDecodeStreamOptions {\n\tacceptTextOnly: boolean;\n\tguessEncoding: boolean;\n\tcandidateGuessEncodings: string[];\n\tminBytesRequiredForDetection?: number;\n\n\toverwriteEncoding(detectedEncoding: string | null): Promise<string>;\n}\n\nexport interface IDecodeStreamResult {\n\tstream: ReadableStream<string>;\n\tdetected: IDetectedEncodingResult;\n}\n\nexport const enum DecodeStreamErrorKind {\n\n\t/**\n\t * Error indicating that the stream is binary even\n\t * though `acceptTextOnly` was specified.\n\t */\n\tSTREAM_IS_BINARY = 1\n}\n\nexport class DecodeStreamError extends Error {\n\n\tconstructor(\n\t\tmessage: string,\n\t\treadonly decodeStreamErrorKind: DecodeStreamErrorKind\n\t) {\n\t\tsuper(message);\n\t}\n}\n\nexport interface IDecoderStream {\n\twrite(buffer: Uint8Array): string;\n\tend(): string | undefined;\n}\n\nclass DecoderStream implements IDecoderStream {\n\n\t/**\n\t * This stream will only load iconv-lite lazily if the encoding\n\t * is not UTF-8. This ensures that for most common cases we do\n\t * not pay the price of loading the module from disk.\n\t *\n\t * We still need to be careful when converting UTF-8 to a string\n\t * though because we read the file in chunks of Buffer and thus\n\t * need to decode it via TextDecoder helper that is available\n\t * in browser and node.js environments.\n\t */\n\tstatic async create(encoding: string): Promise<DecoderStream> {\n\t\tlet decoder: IDecoderStream | undefined = undefined;\n\t\tif (encoding !== UTF8) {\n\t\t\tconst iconv = await importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js');\n\t\t\tdecoder = iconv.getDecoder(toNodeEncoding(encoding));\n\t\t} else {\n\t\t\tconst utf8TextDecoder = new TextDecoder();\n\t\t\tdecoder = {\n\t\t\t\twrite(buffer: Uint8Array): string {\n\t\t\t\t\treturn utf8TextDecoder.decode(buffer, {\n\t\t\t\t\t\t// Signal to TextDecoder that potentially more data is coming\n\t\t\t\t\t\t// and that we are calling `decode` in the end to consume any\n\t\t\t\t\t\t// remainders\n\t\t\t\t\t\tstream: true\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\tend(): string | undefined {\n\t\t\t\t\treturn utf8TextDecoder.decode();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\treturn new DecoderStream(decoder);\n\t}\n\n\tprivate constructor(private iconvLiteDecoder: IDecoderStream) { }\n\n\twrite(buffer: Uint8Array): string {\n\t\treturn this.iconvLiteDecoder.write(buffer);\n\t}\n\n\tend(): string | undefined {\n\t\treturn this.iconvLiteDecoder.end();\n\t}\n}\n\nexport function toDecodeStream(source: VSBufferReadableStream, options: IDecodeStreamOptions): Promise<IDecodeStreamResult> {\n\tconst minBytesRequiredForDetection = options.minBytesRequiredForDetection ?? (options.guessEncoding ? AUTO_ENCODING_GUESS_MIN_BYTES : NO_ENCODING_GUESS_MIN_BYTES);\n\n\treturn new Promise<IDecodeStreamResult>((resolve, reject) => {\n\t\tconst target = newWriteableStream<string>(strings => strings.join(''));\n\n\t\tconst bufferedChunks: VSBuffer[] = [];\n\t\tlet bytesBuffered = 0;\n\n\t\tlet decoder: IDecoderStream | undefined = undefined;\n\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst createDecoder = async () => {\n\t\t\ttry {\n\n\t\t\t\t// detect encoding from buffer\n\t\t\t\tconst detected = await detectEncodingFromBuffer({\n\t\t\t\t\tbuffer: VSBuffer.concat(bufferedChunks),\n\t\t\t\t\tbytesRead: bytesBuffered\n\t\t\t\t}, options.guessEncoding, options.candidateGuessEncodings);\n\n\t\t\t\t// throw early if the source seems binary and\n\t\t\t\t// we are instructed to only accept text\n\t\t\t\tif (detected.seemsBinary && options.acceptTextOnly) {\n\t\t\t\t\tthrow new DecodeStreamError('Stream is binary but only text is accepted for decoding', DecodeStreamErrorKind.STREAM_IS_BINARY);\n\t\t\t\t}\n\n\t\t\t\t// ensure to respect overwrite of encoding\n\t\t\t\tdetected.encoding = await options.overwriteEncoding(detected.encoding);\n\n\t\t\t\t// decode and write buffered content\n\t\t\t\tdecoder = await DecoderStream.create(detected.encoding);\n\t\t\t\tconst decoded = decoder.write(VSBuffer.concat(bufferedChunks).buffer);\n\t\t\t\ttarget.write(decoded);\n\n\t\t\t\tbufferedChunks.length = 0;\n\t\t\t\tbytesBuffered = 0;\n\n\t\t\t\t// signal to the outside our detected encoding and final decoder stream\n\t\t\t\tresolve({\n\t\t\t\t\tstream: target,\n\t\t\t\t\tdetected\n\t\t\t\t});\n\t\t\t} catch (error) {\n\n\t\t\t\t// Stop handling anything from the source and target\n\t\t\t\tcts.cancel();\n\t\t\t\ttarget.destroy();\n\n\t\t\t\treject(error);\n\t\t\t}\n\t\t};\n\n\t\tlistenStream(source, {\n\t\t\tonData: async chunk => {\n\n\t\t\t\t// if the decoder is ready, we just write directly\n\t\t\t\tif (decoder) {\n\t\t\t\t\ttarget.write(decoder.write(chunk.buffer));\n\t\t\t\t}\n\n\t\t\t\t// otherwise we need to buffer the data until the stream is ready\n\t\t\t\telse {\n\t\t\t\t\tbufferedChunks.push(chunk);\n\t\t\t\t\tbytesBuffered += chunk.byteLength;\n\n\t\t\t\t\t// buffered enough data for encoding detection, create stream\n\t\t\t\t\tif (bytesBuffered >= minBytesRequiredForDetection) {\n\n\t\t\t\t\t\t// pause stream here until the decoder is ready\n\t\t\t\t\t\tsource.pause();\n\n\t\t\t\t\t\tawait createDecoder();\n\n\t\t\t\t\t\t// resume stream now that decoder is ready but\n\t\t\t\t\t\t// outside of this stack to reduce recursion\n\t\t\t\t\t\tsetTimeout(() => source.resume());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => target.error(error), // simply forward to target\n\t\t\tonEnd: async () => {\n\n\t\t\t\t// we were still waiting for data to do the encoding\n\t\t\t\t// detection. thus, wrap up starting the stream even\n\t\t\t\t// without all the data to get things going\n\t\t\t\tif (!decoder) {\n\t\t\t\t\tawait createDecoder();\n\t\t\t\t}\n\n\t\t\t\t// end the target with the remainders of the decoder\n\t\t\t\ttarget.end(decoder?.end());\n\t\t\t}\n\t\t}, cts.token);\n\t});\n}\n\nexport async function toEncodeReadable(readable: Readable<string>, encoding: string, options?: { addBOM?: boolean }): Promise<VSBufferReadable> {\n\tconst iconv = await importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js');\n\tconst encoder = iconv.getEncoder(toNodeEncoding(encoding), options);\n\n\tlet bytesWritten = false;\n\tlet done = false;\n\n\treturn {\n\t\tread() {\n\t\t\tif (done) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst chunk = readable.read();\n\t\t\tif (typeof chunk !== 'string') {\n\t\t\t\tdone = true;\n\n\t\t\t\t// If we are instructed to add a BOM but we detect that no\n\t\t\t\t// bytes have been written, we must ensure to return the BOM\n\t\t\t\t// ourselves so that we comply with the contract.\n\t\t\t\tif (!bytesWritten && options?.addBOM) {\n\t\t\t\t\tswitch (encoding) {\n\t\t\t\t\t\tcase UTF8:\n\t\t\t\t\t\tcase UTF8_with_bom:\n\t\t\t\t\t\t\treturn VSBuffer.wrap(Uint8Array.from(UTF8_BOM));\n\t\t\t\t\t\tcase UTF16be:\n\t\t\t\t\t\t\treturn VSBuffer.wrap(Uint8Array.from(UTF16be_BOM));\n\t\t\t\t\t\tcase UTF16le:\n\t\t\t\t\t\t\treturn VSBuffer.wrap(Uint8Array.from(UTF16le_BOM));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst leftovers = encoder.end();\n\t\t\t\tif (leftovers && leftovers.length > 0) {\n\t\t\t\t\tbytesWritten = true;\n\n\t\t\t\t\treturn VSBuffer.wrap(leftovers);\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tbytesWritten = true;\n\n\t\t\treturn VSBuffer.wrap(encoder.write(chunk));\n\t\t}\n\t};\n}\n\nexport async function encodingExists(encoding: string): Promise<boolean> {\n\tconst iconv = await importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js');\n\n\treturn iconv.encodingExists(toNodeEncoding(encoding));\n}\n\nexport function toNodeEncoding(enc: string | null): string {\n\tif (enc === UTF8_with_bom || enc === null) {\n\t\treturn UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it\n\t}\n\n\treturn enc;\n}\n\nexport function detectEncodingByBOMFromBuffer(buffer: VSBuffer | null, bytesRead: number): typeof UTF8_with_bom | typeof UTF16le | typeof UTF16be | null {\n\tif (!buffer || bytesRead < UTF16be_BOM.length) {\n\t\treturn null;\n\t}\n\n\tconst b0 = buffer.readUInt8(0);\n\tconst b1 = buffer.readUInt8(1);\n\n\t// UTF-16 BE\n\tif (b0 === UTF16be_BOM[0] && b1 === UTF16be_BOM[1]) {\n\t\treturn UTF16be;\n\t}\n\n\t// UTF-16 LE\n\tif (b0 === UTF16le_BOM[0] && b1 === UTF16le_BOM[1]) {\n\t\treturn UTF16le;\n\t}\n\n\tif (bytesRead < UTF8_BOM.length) {\n\t\treturn null;\n\t}\n\n\tconst b2 = buffer.readUInt8(2);\n\n\t// UTF-8\n\tif (b0 === UTF8_BOM[0] && b1 === UTF8_BOM[1] && b2 === UTF8_BOM[2]) {\n\t\treturn UTF8_with_bom;\n\t}\n\n\treturn null;\n}\n\n// we explicitly ignore a specific set of encodings from auto guessing\n// - ASCII: we never want this encoding (most UTF-8 files would happily detect as\n//          ASCII files and then you could not type non-ASCII characters anymore)\n// - UTF-16: we have our own detection logic for UTF-16\n// - UTF-32: we do not support this encoding in VSCode\nconst IGNORE_ENCODINGS = ['ascii', 'utf-16', 'utf-32'];\n\n/**\n * Guesses the encoding from buffer.\n */\nasync function guessEncodingByBuffer(buffer: VSBuffer, candidateGuessEncodings?: string[]): Promise<string | null> {\n\tconst jschardet = await importAMDNodeModule<typeof import('jschardet')>('jschardet', 'dist/jschardet.min.js');\n\n\t// ensure to limit buffer for guessing due to https://github.com/aadsm/jschardet/issues/53\n\tconst limitedBuffer = buffer.slice(0, AUTO_ENCODING_GUESS_MAX_BYTES);\n\n\t// before guessing jschardet calls toString('binary') on input if it is a Buffer,\n\t// since we are using it inside browser environment as well we do conversion ourselves\n\t// https://github.com/aadsm/jschardet/blob/v2.1.1/src/index.js#L36-L40\n\tconst binaryString = encodeLatin1(limitedBuffer.buffer);\n\n\t// ensure to convert candidate encodings to jschardet encoding names if provided\n\tif (candidateGuessEncodings) {\n\t\tcandidateGuessEncodings = coalesce(candidateGuessEncodings.map(e => toJschardetEncoding(e)));\n\t\tif (candidateGuessEncodings.length === 0) {\n\t\t\tcandidateGuessEncodings = undefined;\n\t\t}\n\t}\n\n\tlet guessed: { encoding: string | undefined } | undefined;\n\ttry {\n\t\tguessed = jschardet.detect(binaryString, candidateGuessEncodings ? { detectEncodings: candidateGuessEncodings } : undefined);\n\t} catch (error) {\n\t\treturn null; // jschardet throws for unknown encodings (https://github.com/microsoft/vscode/issues/239928)\n\t}\n\n\tif (!guessed?.encoding) {\n\t\treturn null;\n\t}\n\n\tconst enc = guessed.encoding.toLowerCase();\n\tif (0 <= IGNORE_ENCODINGS.indexOf(enc)) {\n\t\treturn null; // see comment above why we ignore some encodings\n\t}\n\n\treturn toIconvLiteEncoding(guessed.encoding);\n}\n\nconst JSCHARDET_TO_ICONV_ENCODINGS: { [name: string]: string } = {\n\t'ibm866': 'cp866',\n\t'big5': 'cp950'\n};\n\nfunction normalizeEncoding(encodingName: string): string {\n\treturn encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n}\n\nfunction toIconvLiteEncoding(encodingName: string): string {\n\tconst normalizedEncodingName = normalizeEncoding(encodingName);\n\tconst mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];\n\n\treturn mapped || normalizedEncodingName;\n}\n\nfunction toJschardetEncoding(encodingName: string): string | undefined {\n\tconst normalizedEncodingName = normalizeEncoding(encodingName);\n\tconst mapped = GUESSABLE_ENCODINGS[normalizedEncodingName];\n\n\treturn mapped ? mapped.guessableName : undefined;\n}\n\nfunction encodeLatin1(buffer: Uint8Array): string {\n\tlet result = '';\n\tfor (let i = 0; i < buffer.length; i++) {\n\t\tresult += String.fromCharCode(buffer[i]);\n\t}\n\n\treturn result;\n}\n\n/**\n * The encodings that are allowed in a settings file don't match the canonical encoding labels specified by WHATWG.\n * See https://encoding.spec.whatwg.org/#names-and-labels\n * Iconv-lite strips all non-alphanumeric characters, but ripgrep doesn't. For backcompat, allow these labels.\n */\nexport function toCanonicalName(enc: string): string {\n\tswitch (enc) {\n\t\tcase 'shiftjis':\n\t\t\treturn 'shift-jis';\n\t\tcase 'utf16le':\n\t\t\treturn 'utf-16le';\n\t\tcase 'utf16be':\n\t\t\treturn 'utf-16be';\n\t\tcase 'big5hkscs':\n\t\t\treturn 'big5-hkscs';\n\t\tcase 'eucjp':\n\t\t\treturn 'euc-jp';\n\t\tcase 'euckr':\n\t\t\treturn 'euc-kr';\n\t\tcase 'koi8r':\n\t\t\treturn 'koi8-r';\n\t\tcase 'koi8u':\n\t\t\treturn 'koi8-u';\n\t\tcase 'macroman':\n\t\t\treturn 'x-mac-roman';\n\t\tcase 'utf8bom':\n\t\t\treturn 'utf8';\n\t\tdefault: {\n\t\t\tconst m = enc.match(/windows(\\d+)/);\n\t\t\tif (m) {\n\t\t\t\treturn 'windows-' + m[1];\n\t\t\t}\n\n\t\t\treturn enc;\n\t\t}\n\t}\n}\n\nexport interface IDetectedEncodingResult {\n\tencoding: string | null;\n\tseemsBinary: boolean;\n}\n\nexport interface IReadResult {\n\tbuffer: VSBuffer | null;\n\tbytesRead: number;\n}\n\nexport function detectEncodingFromBuffer(readResult: IReadResult, autoGuessEncoding?: false, candidateGuessEncodings?: string[]): IDetectedEncodingResult;\nexport function detectEncodingFromBuffer(readResult: IReadResult, autoGuessEncoding?: boolean, candidateGuessEncodings?: string[]): Promise<IDetectedEncodingResult>;\nexport function detectEncodingFromBuffer({ buffer, bytesRead }: IReadResult, autoGuessEncoding?: boolean, candidateGuessEncodings?: string[]): Promise<IDetectedEncodingResult> | IDetectedEncodingResult {\n\n\t// Always first check for BOM to find out about encoding\n\tlet encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);\n\n\t// Detect 0 bytes to see if file is binary or UTF-16 LE/BE\n\t// unless we already know that this file has a UTF-16 encoding\n\tlet seemsBinary = false;\n\tif (encoding !== UTF16be && encoding !== UTF16le && buffer) {\n\t\tlet couldBeUTF16LE = true; // e.g. 0xAA 0x00\n\t\tlet couldBeUTF16BE = true; // e.g. 0x00 0xAA\n\t\tlet containsZeroByte = false;\n\n\t\t// This is a simplified guess to detect UTF-16 BE or LE by just checking if\n\t\t// the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE\n\t\t// this would be the odd byte index and for UTF-16 BE the even one.\n\t\t// Note: this can produce false positives (a binary file that uses a 2-byte\n\t\t// encoding of the same format as UTF-16) and false negatives (a UTF-16 file\n\t\t// that is using 4 bytes to encode a character).\n\t\tfor (let i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {\n\t\t\tconst isEndian = (i % 2 === 1); // assume 2-byte sequences typical for UTF-16\n\t\t\tconst isZeroByte = (buffer.readUInt8(i) === 0);\n\n\t\t\tif (isZeroByte) {\n\t\t\t\tcontainsZeroByte = true;\n\t\t\t}\n\n\t\t\t// UTF-16 LE: expect e.g. 0xAA 0x00\n\t\t\tif (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {\n\t\t\t\tcouldBeUTF16LE = false;\n\t\t\t}\n\n\t\t\t// UTF-16 BE: expect e.g. 0x00 0xAA\n\t\t\tif (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {\n\t\t\t\tcouldBeUTF16BE = false;\n\t\t\t}\n\n\t\t\t// Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary\n\t\t\tif (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Handle case of 0-byte included\n\t\tif (containsZeroByte) {\n\t\t\tif (couldBeUTF16LE) {\n\t\t\t\tencoding = UTF16le;\n\t\t\t} else if (couldBeUTF16BE) {\n\t\t\t\tencoding = UTF16be;\n\t\t\t} else {\n\t\t\t\tseemsBinary = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Auto guess encoding if configured\n\tif (autoGuessEncoding && !seemsBinary && !encoding && buffer) {\n\t\treturn guessEncodingByBuffer(buffer.slice(0, bytesRead), candidateGuessEncodings).then(guessedEncoding => {\n\t\t\treturn {\n\t\t\t\tseemsBinary: false,\n\t\t\t\tencoding: guessedEncoding\n\t\t\t};\n\t\t});\n\t}\n\n\treturn { seemsBinary, encoding };\n}\n\ntype EncodingsMap = { [encoding: string]: { labelLong: string; labelShort: string; order: number; encodeOnly?: boolean; alias?: string; guessableName?: string } };\n\nexport const SUPPORTED_ENCODINGS: EncodingsMap = {\n\tutf8: {\n\t\tlabelLong: 'UTF-8',\n\t\tlabelShort: 'UTF-8',\n\t\torder: 1,\n\t\talias: 'utf8bom',\n\t\tguessableName: 'UTF-8'\n\t},\n\tutf8bom: {\n\t\tlabelLong: 'UTF-8 with BOM',\n\t\tlabelShort: 'UTF-8 with BOM',\n\t\tencodeOnly: true,\n\t\torder: 2,\n\t\talias: 'utf8'\n\t},\n\tutf16le: {\n\t\tlabelLong: 'UTF-16 LE',\n\t\tlabelShort: 'UTF-16 LE',\n\t\torder: 3,\n\t\tguessableName: 'UTF-16LE'\n\t},\n\tutf16be: {\n\t\tlabelLong: 'UTF-16 BE',\n\t\tlabelShort: 'UTF-16 BE',\n\t\torder: 4,\n\t\tguessableName: 'UTF-16BE'\n\t},\n\twindows1252: {\n\t\tlabelLong: 'Western (Windows 1252)',\n\t\tlabelShort: 'Windows 1252',\n\t\torder: 5,\n\t\tguessableName: 'windows-1252'\n\t},\n\tiso88591: {\n\t\tlabelLong: 'Western (ISO 8859-1)',\n\t\tlabelShort: 'ISO 8859-1',\n\t\torder: 6\n\t},\n\tiso88593: {\n\t\tlabelLong: 'Western (ISO 8859-3)',\n\t\tlabelShort: 'ISO 8859-3',\n\t\torder: 7\n\t},\n\tiso885915: {\n\t\tlabelLong: 'Western (ISO 8859-15)',\n\t\tlabelShort: 'ISO 8859-15',\n\t\torder: 8\n\t},\n\tmacroman: {\n\t\tlabelLong: 'Western (Mac Roman)',\n\t\tlabelShort: 'Mac Roman',\n\t\torder: 9\n\t},\n\tcp437: {\n\t\tlabelLong: 'DOS (CP 437)',\n\t\tlabelShort: 'CP437',\n\t\torder: 10\n\t},\n\twindows1256: {\n\t\tlabelLong: 'Arabic (Windows 1256)',\n\t\tlabelShort: 'Windows 1256',\n\t\torder: 11\n\t},\n\tiso88596: {\n\t\tlabelLong: 'Arabic (ISO 8859-6)',\n\t\tlabelShort: 'ISO 8859-6',\n\t\torder: 12\n\t},\n\twindows1257: {\n\t\tlabelLong: 'Baltic (Windows 1257)',\n\t\tlabelShort: 'Windows 1257',\n\t\torder: 13\n\t},\n\tiso88594: {\n\t\tlabelLong: 'Baltic (ISO 8859-4)',\n\t\tlabelShort: 'ISO 8859-4',\n\t\torder: 14\n\t},\n\tiso885914: {\n\t\tlabelLong: 'Celtic (ISO 8859-14)',\n\t\tlabelShort: 'ISO 8859-14',\n\t\torder: 15\n\t},\n\twindows1250: {\n\t\tlabelLong: 'Central European (Windows 1250)',\n\t\tlabelShort: 'Windows 1250',\n\t\torder: 16,\n\t\tguessableName: 'windows-1250'\n\t},\n\tiso88592: {\n\t\tlabelLong: 'Central European (ISO 8859-2)',\n\t\tlabelShort: 'ISO 8859-2',\n\t\torder: 17,\n\t\tguessableName: 'ISO-8859-2'\n\t},\n\tcp852: {\n\t\tlabelLong: 'Central European (CP 852)',\n\t\tlabelShort: 'CP 852',\n\t\torder: 18\n\t},\n\twindows1251: {\n\t\tlabelLong: 'Cyrillic (Windows 1251)',\n\t\tlabelShort: 'Windows 1251',\n\t\torder: 19,\n\t\tguessableName: 'windows-1251'\n\t},\n\tcp866: {\n\t\tlabelLong: 'Cyrillic (CP 866)',\n\t\tlabelShort: 'CP 866',\n\t\torder: 20,\n\t\tguessableName: 'IBM866'\n\t},\n\tcp1125: {\n\t\tlabelLong: 'Cyrillic (CP 1125)',\n\t\tlabelShort: 'CP 1125',\n\t\torder: 21,\n\t\tguessableName: 'IBM1125'\n\t},\n\tiso88595: {\n\t\tlabelLong: 'Cyrillic (ISO 8859-5)',\n\t\tlabelShort: 'ISO 8859-5',\n\t\torder: 22,\n\t\tguessableName: 'ISO-8859-5'\n\t},\n\tkoi8r: {\n\t\tlabelLong: 'Cyrillic (KOI8-R)',\n\t\tlabelShort: 'KOI8-R',\n\t\torder: 23,\n\t\tguessableName: 'KOI8-R'\n\t},\n\tkoi8u: {\n\t\tlabelLong: 'Cyrillic (KOI8-U)',\n\t\tlabelShort: 'KOI8-U',\n\t\torder: 24\n\t},\n\tiso885913: {\n\t\tlabelLong: 'Estonian (ISO 8859-13)',\n\t\tlabelShort: 'ISO 8859-13',\n\t\torder: 25\n\t},\n\twindows1253: {\n\t\tlabelLong: 'Greek (Windows 1253)',\n\t\tlabelShort: 'Windows 1253',\n\t\torder: 26,\n\t\tguessableName: 'windows-1253'\n\t},\n\tiso88597: {\n\t\tlabelLong: 'Greek (ISO 8859-7)',\n\t\tlabelShort: 'ISO 8859-7',\n\t\torder: 27,\n\t\tguessableName: 'ISO-8859-7'\n\t},\n\twindows1255: {\n\t\tlabelLong: 'Hebrew (Windows 1255)',\n\t\tlabelShort: 'Windows 1255',\n\t\torder: 28,\n\t\tguessableName: 'windows-1255'\n\t},\n\tiso88598: {\n\t\tlabelLong: 'Hebrew (ISO 8859-8)',\n\t\tlabelShort: 'ISO 8859-8',\n\t\torder: 29,\n\t\tguessableName: 'ISO-8859-8'\n\t},\n\tiso885910: {\n\t\tlabelLong: 'Nordic (ISO 8859-10)',\n\t\tlabelShort: 'ISO 8859-10',\n\t\torder: 30\n\t},\n\tiso885916: {\n\t\tlabelLong: 'Romanian (ISO 8859-16)',\n\t\tlabelShort: 'ISO 8859-16',\n\t\torder: 31\n\t},\n\twindows1254: {\n\t\tlabelLong: 'Turkish (Windows 1254)',\n\t\tlabelShort: 'Windows 1254',\n\t\torder: 32\n\t},\n\tiso88599: {\n\t\tlabelLong: 'Turkish (ISO 8859-9)',\n\t\tlabelShort: 'ISO 8859-9',\n\t\torder: 33\n\t},\n\twindows1258: {\n\t\tlabelLong: 'Vietnamese (Windows 1258)',\n\t\tlabelShort: 'Windows 1258',\n\t\torder: 34\n\t},\n\tgbk: {\n\t\tlabelLong: 'Simplified Chinese (GBK)',\n\t\tlabelShort: 'GBK',\n\t\torder: 35\n\t},\n\tgb18030: {\n\t\tlabelLong: 'Simplified Chinese (GB18030)',\n\t\tlabelShort: 'GB18030',\n\t\torder: 36\n\t},\n\tcp950: {\n\t\tlabelLong: 'Traditional Chinese (Big5)',\n\t\tlabelShort: 'Big5',\n\t\torder: 37,\n\t\tguessableName: 'Big5'\n\t},\n\tbig5hkscs: {\n\t\tlabelLong: 'Traditional Chinese (Big5-HKSCS)',\n\t\tlabelShort: 'Big5-HKSCS',\n\t\torder: 38\n\t},\n\tshiftjis: {\n\t\tlabelLong: 'Japanese (Shift JIS)',\n\t\tlabelShort: 'Shift JIS',\n\t\torder: 39,\n\t\tguessableName: 'SHIFT_JIS'\n\t},\n\teucjp: {\n\t\tlabelLong: 'Japanese (EUC-JP)',\n\t\tlabelShort: 'EUC-JP',\n\t\torder: 40,\n\t\tguessableName: 'EUC-JP'\n\t},\n\teuckr: {\n\t\tlabelLong: 'Korean (EUC-KR)',\n\t\tlabelShort: 'EUC-KR',\n\t\torder: 41,\n\t\tguessableName: 'EUC-KR'\n\t},\n\twindows874: {\n\t\tlabelLong: 'Thai (Windows 874)',\n\t\tlabelShort: 'Windows 874',\n\t\torder: 42\n\t},\n\tiso885911: {\n\t\tlabelLong: 'Latin/Thai (ISO 8859-11)',\n\t\tlabelShort: 'ISO 8859-11',\n\t\torder: 43\n\t},\n\tkoi8ru: {\n\t\tlabelLong: 'Cyrillic (KOI8-RU)',\n\t\tlabelShort: 'KOI8-RU',\n\t\torder: 44\n\t},\n\tkoi8t: {\n\t\tlabelLong: 'Tajik (KOI8-T)',\n\t\tlabelShort: 'KOI8-T',\n\t\torder: 45\n\t},\n\tgb2312: {\n\t\tlabelLong: 'Simplified Chinese (GB 2312)',\n\t\tlabelShort: 'GB 2312',\n\t\torder: 46,\n\t\tguessableName: 'GB2312'\n\t},\n\tcp865: {\n\t\tlabelLong: 'Nordic DOS (CP 865)',\n\t\tlabelShort: 'CP 865',\n\t\torder: 47\n\t},\n\tcp850: {\n\t\tlabelLong: 'Western European DOS (CP 850)',\n\t\tlabelShort: 'CP 850',\n\t\torder: 48\n\t}\n};\n\nexport const GUESSABLE_ENCODINGS: EncodingsMap = (() => {\n\tconst guessableEncodings: EncodingsMap = {};\n\tfor (const encoding in SUPPORTED_ENCODINGS) {\n\t\tif (SUPPORTED_ENCODINGS[encoding].guessableName) {\n\t\t\tguessableEncodings[encoding] = SUPPORTED_ENCODINGS[encoding];\n\t\t}\n\t}\n\n\treturn guessableEncodings;\n})();\n"]}