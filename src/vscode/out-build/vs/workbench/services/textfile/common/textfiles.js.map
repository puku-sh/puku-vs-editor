{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/textfile/common/textfiles.ts","vs/workbench/services/textfile/common/textfiles.ts"],"names":[],"mappings":"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","file":"textfiles.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { ISaveOptions, IRevertOptions, SaveReason } from '../../../common/editor.js';\nimport { ReadableStream } from '../../../../base/common/stream.js';\nimport { IBaseFileStatWithMetadata, IFileStatWithMetadata, IWriteFileOptions, FileOperationError, FileOperationResult, IReadFileStreamOptions, IFileReadLimits } from '../../../../platform/files/common/files.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ITextEditorModel } from '../../../../editor/common/services/resolverService.js';\nimport { ITextBufferFactory, ITextModel, ITextSnapshot } from '../../../../editor/common/model.js';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { areFunctions, isUndefinedOrNull } from '../../../../base/common/types.js';\nimport { IWorkingCopy, IWorkingCopySaveEvent } from '../../workingCopy/common/workingCopy.js';\nimport { IUntitledTextEditorModelManager } from '../../untitled/common/untitledTextEditorService.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IProgress, IProgressStep } from '../../../../platform/progress/common/progress.js';\nimport { IFileOperationUndoRedoInfo } from '../../workingCopy/common/workingCopyFileService.js';\n\nexport const ITextFileService = createDecorator<ITextFileService>('textFileService');\n\nexport interface ITextFileService extends IDisposable {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Access to the manager of text file editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly files: ITextFileEditorModelManager;\n\n\t/**\n\t * Access to the manager of untitled text editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly untitled: IUntitledTextEditorModelManager;\n\n\t/**\n\t * Helper to determine encoding for resources.\n\t */\n\treadonly encoding: IResourceEncodings;\n\n\t/**\n\t * A resource is dirty if it has unsaved changes or is an untitled file not yet saved.\n\t *\n\t * @param resource the resource to check for being dirty\n\t */\n\tisDirty(resource: URI): boolean;\n\n\t/**\n\t * Saves the resource.\n\t *\n\t * @param resource the resource to save\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsave(resource: URI, options?: ITextFileSaveOptions): Promise<URI | undefined>;\n\n\t/**\n\t * Saves the provided resource asking the user for a file name or using the provided one.\n\t *\n\t * @param resource the resource to save as.\n\t * @param targetResource the optional target to save to.\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsaveAs(resource: URI, targetResource?: URI, options?: ITextFileSaveAsOptions): Promise<URI | undefined>;\n\n\t/**\n\t * Reverts the provided resource.\n\t *\n\t * @param resource the resource of the file to revert.\n\t * @param force to force revert even when the file is not dirty\n\t */\n\trevert(resource: URI, options?: IRevertOptions): Promise<void>;\n\n\t/**\n\t * Read the contents of a file identified by the resource.\n\t */\n\tread(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileContent>;\n\n\t/**\n\t * Read the contents of a file identified by the resource as stream.\n\t */\n\treadStream(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileStreamContent>;\n\n\t/**\n\t * Update a file with given contents.\n\t */\n\twrite(resource: URI, value: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Create files. If the file exists it will be overwritten with the contents if\n\t * the options enable to overwrite.\n\t */\n\tcreate(operations: { resource: URI; value?: string | ITextSnapshot; options?: { overwrite?: boolean } }[], undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Returns the readable that uses the appropriate encoding. This method should\n\t * be used whenever a `string` or `ITextSnapshot` is being persisted to the\n\t * file system.\n\t */\n\tgetEncodedReadable(resource: URI | undefined, value: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable>;\n\tgetEncodedReadable(resource: URI | undefined, value: string, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable>;\n\tgetEncodedReadable(resource: URI | undefined, value?: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable | undefined>;\n\tgetEncodedReadable(resource: URI | undefined, value?: string, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable | undefined>;\n\tgetEncodedReadable(resource: URI | undefined, value?: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable | undefined>;\n\n\t/**\n\t * Returns a stream of strings that uses the appropriate encoding. This method should\n\t * be used whenever a `VSBufferReadableStream` is being loaded from the file system.\n\t *\n\t * Will throw an error if `acceptTextOnly: true` for resources that seem to be binary.\n\t */\n\tgetDecodedStream(resource: URI | undefined, value: VSBufferReadableStream, options?: IReadTextFileEncodingOptions): Promise<ReadableStream<string>>;\n\n\t/**\n\t * Get the encoding for the provided `resource`. Will try to determine the encoding\n\t * from any existing model for that `resource` and fallback to the configured defaults.\n\t */\n\tgetEncoding(resource: URI): string;\n\n\t/**\n\t * Get the properties for decoding the provided `resource` based on configuration.\n\t */\n\tresolveDecoding(resource: URI | undefined, options?: IReadTextFileEncodingOptions): Promise<{ preferredEncoding: string; guessEncoding: boolean; candidateGuessEncodings: string[] }>;\n\n\t/**\n\t * Get the properties for encoding the provided `resource` based on configuration.\n\t */\n\tresolveEncoding(resource: URI | undefined, options?: IWriteTextFileOptions): Promise<{ encoding: string; addBOM: boolean }>;\n\n\t/**\n\t * Given a detected encoding, validate it against the configured encoding options.\n\t */\n\tvalidateDetectedEncoding(resource: URI | undefined, detectedEncoding: string, options?: IReadTextFileEncodingOptions): Promise<string>;\n}\n\nexport interface IReadTextFileEncodingOptions {\n\n\t/**\n\t * The optional encoding parameter allows to specify the desired encoding when resolving\n\t * the contents of the file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * The optional guessEncoding parameter allows to guess encoding from content of the file.\n\t */\n\treadonly autoGuessEncoding?: boolean;\n\n\t/**\n\t * The optional candidateGuessEncodings parameter limits the allowed encodings to guess from.\n\t */\n\treadonly candidateGuessEncodings?: string[];\n\n\t/**\n\t * The optional acceptTextOnly parameter allows to fail this request early if the file\n\t * contents are not textual.\n\t */\n\treadonly acceptTextOnly?: boolean;\n}\n\nexport interface IReadTextFileOptions extends IReadTextFileEncodingOptions, IReadFileStreamOptions { }\n\nexport interface IWriteTextFileOptions extends IWriteFileOptions {\n\n\t/**\n\t * The encoding to use when updating a file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * Whether to write to the file as elevated (admin) user. When setting this option a prompt will\n\t * ask the user to authenticate as super user.\n\t */\n\treadonly writeElevated?: boolean;\n}\n\nexport const enum TextFileOperationResult {\n\tFILE_IS_BINARY\n}\n\nexport class TextFileOperationError extends FileOperationError {\n\n\tstatic isTextFileOperationError(obj: unknown): obj is TextFileOperationError {\n\t\treturn obj instanceof Error && !isUndefinedOrNull((obj as TextFileOperationError).textFileOperationResult);\n\t}\n\n\toverride readonly options?: IReadTextFileOptions & IWriteTextFileOptions;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic textFileOperationResult: TextFileOperationResult,\n\t\toptions?: IReadTextFileOptions & IWriteTextFileOptions\n\t) {\n\t\tsuper(message, FileOperationResult.FILE_OTHER_ERROR);\n\n\t\tthis.options = options;\n\t}\n}\n\nexport interface IResourceEncodings {\n\tgetPreferredReadEncoding(resource: URI): Promise<IResourceEncoding>;\n\tgetPreferredWriteEncoding(resource: URI, preferredEncoding?: string): Promise<IResourceEncoding>;\n}\n\nexport interface IResourceEncoding {\n\treadonly encoding: string;\n\treadonly hasBOM: boolean;\n}\n\n/**\n * The save error handler can be installed on the text file editor model to install code that executes when save errors occur.\n */\nexport interface ISaveErrorHandler {\n\n\t/**\n\t * Called whenever a save fails.\n\t */\n\tonSaveError(error: Error, model: ITextFileEditorModel, options: ITextFileSaveAsOptions): void;\n}\n\n/**\n * States the text file editor model can be in.\n */\nexport const enum TextFileEditorModelState {\n\n\t/**\n\t * A model is saved.\n\t */\n\tSAVED,\n\n\t/**\n\t * A model is dirty.\n\t */\n\tDIRTY,\n\n\t/**\n\t * A model is currently being saved but this operation has not completed yet.\n\t */\n\tPENDING_SAVE,\n\n\t/**\n\t * A model is in conflict mode when changes cannot be saved because the\n\t * underlying file has changed. Models in conflict mode are always dirty.\n\t */\n\tCONFLICT,\n\n\t/**\n\t * A model is in orphan state when the underlying file has been deleted.\n\t */\n\tORPHAN,\n\n\t/**\n\t * Any error that happens during a save that is not causing the CONFLICT state.\n\t * Models in error mode are always dirty.\n\t */\n\tERROR\n}\n\nexport const enum TextFileResolveReason {\n\tEDITOR = 1,\n\tREFERENCE = 2,\n\tOTHER = 3\n}\n\ninterface IBaseTextFileContent extends IBaseFileStatWithMetadata {\n\n\t/**\n\t * The encoding of the content if known.\n\t */\n\treadonly encoding: string;\n}\n\nexport interface ITextFileContent extends IBaseTextFileContent {\n\n\t/**\n\t * The content of a text file.\n\t */\n\treadonly value: string;\n}\n\nexport interface ITextFileStreamContent extends IBaseTextFileContent {\n\n\t/**\n\t * The line grouped content of a text file.\n\t */\n\treadonly value: ITextBufferFactory;\n}\n\nexport interface ITextFileEditorModelResolveOrCreateOptions extends ITextFileResolveOptions {\n\n\t/**\n\t * The language id to use for the model text content.\n\t */\n\treadonly languageId?: string;\n\n\t/**\n\t * The encoding to use when resolving the model text content.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * If the model was already resolved before, allows to trigger\n\t * a reload of it to fetch the latest contents.\n\t */\n\treadonly reload?: {\n\n\t\t/**\n\t\t * Controls whether the reload happens in the background\n\t\t * or whether `resolve` will await the reload to happen.\n\t\t */\n\t\treadonly async: boolean;\n\t};\n}\n\nexport interface ITextFileSaveEvent extends ITextFileEditorModelSaveEvent {\n\n\t/**\n\t * The model that was saved.\n\t */\n\treadonly model: ITextFileEditorModel;\n}\n\nexport interface ITextFileResolveEvent {\n\n\t/**\n\t * The model that was resolved.\n\t */\n\treadonly model: ITextFileEditorModel;\n\n\t/**\n\t * The reason why the model was resolved.\n\t */\n\treadonly reason: TextFileResolveReason;\n}\n\nexport interface ITextFileSaveParticipantContext {\n\n\t/**\n\t * The reason why the save was triggered.\n\t */\n\treadonly reason: SaveReason;\n\n\t/**\n\t * Only applies to when a text file was saved as, for\n\t * example when starting with untitled and saving. This\n\t * provides access to the initial resource the text\n\t * file had before.\n\t */\n\treadonly savedFrom?: URI;\n}\n\nexport interface ITextFileSaveParticipant {\n\n\t/**\n\t * The ordinal number which determines the order of participation.\n\t * Lower values mean to participant sooner\n\t */\n\treadonly ordinal?: number;\n\n\t/**\n\t * Participate in a save of a model. Allows to change the model\n\t * before it is being saved to disk.\n\t */\n\tparticipate(\n\t\tmodel: ITextFileEditorModel,\n\t\tcontext: ITextFileSaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface ITextFileEditorModelManager {\n\n\treadonly onDidCreate: Event<ITextFileEditorModel>;\n\treadonly onDidResolve: Event<ITextFileResolveEvent>;\n\treadonly onDidChangeDirty: Event<ITextFileEditorModel>;\n\treadonly onDidChangeReadonly: Event<ITextFileEditorModel>;\n\treadonly onDidRemove: Event<URI>;\n\treadonly onDidChangeOrphaned: Event<ITextFileEditorModel>;\n\treadonly onDidChangeEncoding: Event<ITextFileEditorModel>;\n\treadonly onDidSaveError: Event<ITextFileEditorModel>;\n\treadonly onDidSave: Event<ITextFileSaveEvent>;\n\treadonly onDidRevert: Event<ITextFileEditorModel>;\n\n\t/**\n\t * Access to all text file editor models in memory.\n\t */\n\treadonly models: ITextFileEditorModel[];\n\n\t/**\n\t * Allows to configure the error handler that is called on save errors.\n\t */\n\tsaveErrorHandler: ISaveErrorHandler;\n\n\t/**\n\t * Returns the text file editor model for the provided resource\n\t * or undefined if none.\n\t */\n\tget(resource: URI): ITextFileEditorModel | undefined;\n\n\t/**\n\t * Allows to resolve a text file model from disk.\n\t */\n\tresolve(resource: URI, options?: ITextFileEditorModelResolveOrCreateOptions): Promise<ITextFileEditorModel>;\n\n\t/**\n\t * Adds a participant for saving text file models.\n\t */\n\taddSaveParticipant(participant: ITextFileSaveParticipant): IDisposable;\n\n\t/**\n\t * Runs the registered save participants on the provided model.\n\t */\n\trunSaveParticipants(model: ITextFileEditorModel, context: ITextFileSaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;\n\n\t/**\n\t * Waits for the model to be ready to be disposed. There may be conditions\n\t * under which the model cannot be disposed, e.g. when it is dirty. Once the\n\t * promise is settled, it is safe to dispose the model.\n\t */\n\tcanDispose(model: ITextFileEditorModel): true | Promise<true>;\n}\n\nexport interface ITextFileSaveOptions extends ISaveOptions {\n\n\t/**\n\t * Save the file with an attempt to unlock it.\n\t */\n\treadonly writeUnlock?: boolean;\n\n\t/**\n\t * Save the file with elevated privileges.\n\t *\n\t * Note: This may not be supported in all environments.\n\t */\n\treadonly writeElevated?: boolean;\n\n\t/**\n\t * Allows to write to a file even if it has been modified on disk.\n\t */\n\treadonly ignoreModifiedSince?: boolean;\n\n\t/**\n\t * If set, will bubble up the error to the caller instead of handling it.\n\t */\n\treadonly ignoreErrorHandler?: boolean;\n}\n\nexport interface ITextFileSaveAsOptions extends ITextFileSaveOptions {\n\n\t/**\n\t * Optional URI of the resource the text file is saved from if known.\n\t */\n\treadonly from?: URI;\n\n\t/**\n\t * Optional URI to use as suggested file path to save as.\n\t */\n\treadonly suggestedTarget?: URI;\n}\n\nexport interface ITextFileResolveOptions {\n\n\t/**\n\t * The contents to use for the model if known. If not\n\t * provided, the contents will be retrieved from the\n\t * underlying resource or backup if present.\n\t */\n\treadonly contents?: ITextBufferFactory;\n\n\t/**\n\t * Go to file bypassing any cache of the model if any.\n\t */\n\treadonly forceReadFromFile?: boolean;\n\n\t/**\n\t * Allow to resolve a model even if we think it is a binary file.\n\t */\n\treadonly allowBinary?: boolean;\n\n\t/**\n\t * Context why the model is being resolved.\n\t */\n\treadonly reason?: TextFileResolveReason;\n\n\t/**\n\t * If provided, the size of the file will be checked against the limits\n\t * and an error will be thrown if any limit is exceeded.\n\t */\n\treadonly limits?: IFileReadLimits;\n}\n\nexport const enum EncodingMode {\n\n\t/**\n\t * Instructs the encoding support to encode the object with the provided encoding\n\t */\n\tEncode,\n\n\t/**\n\t * Instructs the encoding support to decode the object with the provided encoding\n\t */\n\tDecode\n}\n\nexport interface IEncodingSupport {\n\n\t/**\n\t * Gets the encoding of the object if known.\n\t */\n\tgetEncoding(): string | undefined;\n\n\t/**\n\t * Sets the encoding for the object for saving.\n\t */\n\tsetEncoding(encoding: string, mode: EncodingMode): Promise<void>;\n}\n\nexport interface ILanguageSupport {\n\n\t/**\n\t * Sets the language id of the object.\n\t */\n\tsetLanguageId(languageId: string, source?: string): void;\n}\n\nexport interface ITextFileEditorModelSaveEvent extends IWorkingCopySaveEvent {\n\n\t/**\n\t * The resolved stat from the save operation.\n\t */\n\treadonly stat: IFileStatWithMetadata;\n}\n\nexport interface ITextFileEditorModel extends ITextEditorModel, IEncodingSupport, ILanguageSupport, IWorkingCopy {\n\n\treadonly onDidSave: Event<ITextFileEditorModelSaveEvent>;\n\treadonly onDidSaveError: Event<void>;\n\treadonly onDidChangeOrphaned: Event<void>;\n\treadonly onDidChangeReadonly: Event<void>;\n\treadonly onDidChangeEncoding: Event<void>;\n\n\thasState(state: TextFileEditorModelState): boolean;\n\tjoinState(state: TextFileEditorModelState.PENDING_SAVE): Promise<void>;\n\n\tupdatePreferredEncoding(encoding: string | undefined): void;\n\n\tsave(options?: ITextFileSaveAsOptions): Promise<boolean>;\n\trevert(options?: IRevertOptions): Promise<void>;\n\n\tresolve(options?: ITextFileResolveOptions): Promise<void>;\n\n\tisDirty(): this is IResolvedTextFileEditorModel;\n\n\tgetLanguageId(): string | undefined;\n\n\tisResolved(): this is IResolvedTextFileEditorModel;\n}\n\nexport function isTextFileEditorModel(model: ITextEditorModel): model is ITextFileEditorModel {\n\tconst candidate = model as ITextFileEditorModel;\n\n\treturn areFunctions(candidate.setEncoding, candidate.getEncoding, candidate.save, candidate.revert, candidate.isDirty, candidate.getLanguageId);\n}\n\nexport interface IResolvedTextFileEditorModel extends ITextFileEditorModel {\n\n\treadonly textEditorModel: ITextModel;\n\n\tcreateSnapshot(): ITextSnapshot;\n}\n\nexport function snapshotToString(snapshot: ITextSnapshot): string {\n\tconst chunks: string[] = [];\n\n\tlet chunk: string | null;\n\twhile (typeof (chunk = snapshot.read()) === 'string') {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn chunks.join('');\n}\n\nexport function stringToSnapshot(value: string): ITextSnapshot {\n\tlet done = false;\n\n\treturn {\n\t\tread(): string | null {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\nexport function toBufferOrReadable(value: string): VSBuffer;\nexport function toBufferOrReadable(value: ITextSnapshot): VSBufferReadable;\nexport function toBufferOrReadable(value: string | ITextSnapshot): VSBuffer | VSBufferReadable;\nexport function toBufferOrReadable(value: string | ITextSnapshot | undefined): VSBuffer | VSBufferReadable | undefined;\nexport function toBufferOrReadable(value: string | ITextSnapshot | undefined): VSBuffer | VSBufferReadable | undefined {\n\tif (typeof value === 'undefined') {\n\t\treturn undefined;\n\t}\n\n\tif (typeof value === 'string') {\n\t\treturn VSBuffer.fromString(value);\n\t}\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = value.read();\n\t\t\tif (typeof chunk === 'string') {\n\t\t\t\treturn VSBuffer.fromString(chunk);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { ISaveOptions, IRevertOptions, SaveReason } from '../../../common/editor.js';\nimport { ReadableStream } from '../../../../base/common/stream.js';\nimport { IBaseFileStatWithMetadata, IFileStatWithMetadata, IWriteFileOptions, FileOperationError, FileOperationResult, IReadFileStreamOptions, IFileReadLimits } from '../../../../platform/files/common/files.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ITextEditorModel } from '../../../../editor/common/services/resolverService.js';\nimport { ITextBufferFactory, ITextModel, ITextSnapshot } from '../../../../editor/common/model.js';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from '../../../../base/common/buffer.js';\nimport { areFunctions, isUndefinedOrNull } from '../../../../base/common/types.js';\nimport { IWorkingCopy, IWorkingCopySaveEvent } from '../../workingCopy/common/workingCopy.js';\nimport { IUntitledTextEditorModelManager } from '../../untitled/common/untitledTextEditorService.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IProgress, IProgressStep } from '../../../../platform/progress/common/progress.js';\nimport { IFileOperationUndoRedoInfo } from '../../workingCopy/common/workingCopyFileService.js';\n\nexport const ITextFileService = createDecorator<ITextFileService>('textFileService');\n\nexport interface ITextFileService extends IDisposable {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Access to the manager of text file editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly files: ITextFileEditorModelManager;\n\n\t/**\n\t * Access to the manager of untitled text editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly untitled: IUntitledTextEditorModelManager;\n\n\t/**\n\t * Helper to determine encoding for resources.\n\t */\n\treadonly encoding: IResourceEncodings;\n\n\t/**\n\t * A resource is dirty if it has unsaved changes or is an untitled file not yet saved.\n\t *\n\t * @param resource the resource to check for being dirty\n\t */\n\tisDirty(resource: URI): boolean;\n\n\t/**\n\t * Saves the resource.\n\t *\n\t * @param resource the resource to save\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsave(resource: URI, options?: ITextFileSaveOptions): Promise<URI | undefined>;\n\n\t/**\n\t * Saves the provided resource asking the user for a file name or using the provided one.\n\t *\n\t * @param resource the resource to save as.\n\t * @param targetResource the optional target to save to.\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsaveAs(resource: URI, targetResource?: URI, options?: ITextFileSaveAsOptions): Promise<URI | undefined>;\n\n\t/**\n\t * Reverts the provided resource.\n\t *\n\t * @param resource the resource of the file to revert.\n\t * @param force to force revert even when the file is not dirty\n\t */\n\trevert(resource: URI, options?: IRevertOptions): Promise<void>;\n\n\t/**\n\t * Read the contents of a file identified by the resource.\n\t */\n\tread(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileContent>;\n\n\t/**\n\t * Read the contents of a file identified by the resource as stream.\n\t */\n\treadStream(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileStreamContent>;\n\n\t/**\n\t * Update a file with given contents.\n\t */\n\twrite(resource: URI, value: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Create files. If the file exists it will be overwritten with the contents if\n\t * the options enable to overwrite.\n\t */\n\tcreate(operations: { resource: URI; value?: string | ITextSnapshot; options?: { overwrite?: boolean } }[], undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Returns the readable that uses the appropriate encoding. This method should\n\t * be used whenever a `string` or `ITextSnapshot` is being persisted to the\n\t * file system.\n\t */\n\tgetEncodedReadable(resource: URI | undefined, value: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable>;\n\tgetEncodedReadable(resource: URI | undefined, value: string, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable>;\n\tgetEncodedReadable(resource: URI | undefined, value?: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable | undefined>;\n\tgetEncodedReadable(resource: URI | undefined, value?: string, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable | undefined>;\n\tgetEncodedReadable(resource: URI | undefined, value?: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable | undefined>;\n\n\t/**\n\t * Returns a stream of strings that uses the appropriate encoding. This method should\n\t * be used whenever a `VSBufferReadableStream` is being loaded from the file system.\n\t *\n\t * Will throw an error if `acceptTextOnly: true` for resources that seem to be binary.\n\t */\n\tgetDecodedStream(resource: URI | undefined, value: VSBufferReadableStream, options?: IReadTextFileEncodingOptions): Promise<ReadableStream<string>>;\n\n\t/**\n\t * Get the encoding for the provided `resource`. Will try to determine the encoding\n\t * from any existing model for that `resource` and fallback to the configured defaults.\n\t */\n\tgetEncoding(resource: URI): string;\n\n\t/**\n\t * Get the properties for decoding the provided `resource` based on configuration.\n\t */\n\tresolveDecoding(resource: URI | undefined, options?: IReadTextFileEncodingOptions): Promise<{ preferredEncoding: string; guessEncoding: boolean; candidateGuessEncodings: string[] }>;\n\n\t/**\n\t * Get the properties for encoding the provided `resource` based on configuration.\n\t */\n\tresolveEncoding(resource: URI | undefined, options?: IWriteTextFileOptions): Promise<{ encoding: string; addBOM: boolean }>;\n\n\t/**\n\t * Given a detected encoding, validate it against the configured encoding options.\n\t */\n\tvalidateDetectedEncoding(resource: URI | undefined, detectedEncoding: string, options?: IReadTextFileEncodingOptions): Promise<string>;\n}\n\nexport interface IReadTextFileEncodingOptions {\n\n\t/**\n\t * The optional encoding parameter allows to specify the desired encoding when resolving\n\t * the contents of the file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * The optional guessEncoding parameter allows to guess encoding from content of the file.\n\t */\n\treadonly autoGuessEncoding?: boolean;\n\n\t/**\n\t * The optional candidateGuessEncodings parameter limits the allowed encodings to guess from.\n\t */\n\treadonly candidateGuessEncodings?: string[];\n\n\t/**\n\t * The optional acceptTextOnly parameter allows to fail this request early if the file\n\t * contents are not textual.\n\t */\n\treadonly acceptTextOnly?: boolean;\n}\n\nexport interface IReadTextFileOptions extends IReadTextFileEncodingOptions, IReadFileStreamOptions { }\n\nexport interface IWriteTextFileOptions extends IWriteFileOptions {\n\n\t/**\n\t * The encoding to use when updating a file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * Whether to write to the file as elevated (admin) user. When setting this option a prompt will\n\t * ask the user to authenticate as super user.\n\t */\n\treadonly writeElevated?: boolean;\n}\n\nexport const enum TextFileOperationResult {\n\tFILE_IS_BINARY\n}\n\nexport class TextFileOperationError extends FileOperationError {\n\n\tstatic isTextFileOperationError(obj: unknown): obj is TextFileOperationError {\n\t\treturn obj instanceof Error && !isUndefinedOrNull((obj as TextFileOperationError).textFileOperationResult);\n\t}\n\n\toverride readonly options?: IReadTextFileOptions & IWriteTextFileOptions;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic textFileOperationResult: TextFileOperationResult,\n\t\toptions?: IReadTextFileOptions & IWriteTextFileOptions\n\t) {\n\t\tsuper(message, FileOperationResult.FILE_OTHER_ERROR);\n\n\t\tthis.options = options;\n\t}\n}\n\nexport interface IResourceEncodings {\n\tgetPreferredReadEncoding(resource: URI): Promise<IResourceEncoding>;\n\tgetPreferredWriteEncoding(resource: URI, preferredEncoding?: string): Promise<IResourceEncoding>;\n}\n\nexport interface IResourceEncoding {\n\treadonly encoding: string;\n\treadonly hasBOM: boolean;\n}\n\n/**\n * The save error handler can be installed on the text file editor model to install code that executes when save errors occur.\n */\nexport interface ISaveErrorHandler {\n\n\t/**\n\t * Called whenever a save fails.\n\t */\n\tonSaveError(error: Error, model: ITextFileEditorModel, options: ITextFileSaveAsOptions): void;\n}\n\n/**\n * States the text file editor model can be in.\n */\nexport const enum TextFileEditorModelState {\n\n\t/**\n\t * A model is saved.\n\t */\n\tSAVED,\n\n\t/**\n\t * A model is dirty.\n\t */\n\tDIRTY,\n\n\t/**\n\t * A model is currently being saved but this operation has not completed yet.\n\t */\n\tPENDING_SAVE,\n\n\t/**\n\t * A model is in conflict mode when changes cannot be saved because the\n\t * underlying file has changed. Models in conflict mode are always dirty.\n\t */\n\tCONFLICT,\n\n\t/**\n\t * A model is in orphan state when the underlying file has been deleted.\n\t */\n\tORPHAN,\n\n\t/**\n\t * Any error that happens during a save that is not causing the CONFLICT state.\n\t * Models in error mode are always dirty.\n\t */\n\tERROR\n}\n\nexport const enum TextFileResolveReason {\n\tEDITOR = 1,\n\tREFERENCE = 2,\n\tOTHER = 3\n}\n\ninterface IBaseTextFileContent extends IBaseFileStatWithMetadata {\n\n\t/**\n\t * The encoding of the content if known.\n\t */\n\treadonly encoding: string;\n}\n\nexport interface ITextFileContent extends IBaseTextFileContent {\n\n\t/**\n\t * The content of a text file.\n\t */\n\treadonly value: string;\n}\n\nexport interface ITextFileStreamContent extends IBaseTextFileContent {\n\n\t/**\n\t * The line grouped content of a text file.\n\t */\n\treadonly value: ITextBufferFactory;\n}\n\nexport interface ITextFileEditorModelResolveOrCreateOptions extends ITextFileResolveOptions {\n\n\t/**\n\t * The language id to use for the model text content.\n\t */\n\treadonly languageId?: string;\n\n\t/**\n\t * The encoding to use when resolving the model text content.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * If the model was already resolved before, allows to trigger\n\t * a reload of it to fetch the latest contents.\n\t */\n\treadonly reload?: {\n\n\t\t/**\n\t\t * Controls whether the reload happens in the background\n\t\t * or whether `resolve` will await the reload to happen.\n\t\t */\n\t\treadonly async: boolean;\n\t};\n}\n\nexport interface ITextFileSaveEvent extends ITextFileEditorModelSaveEvent {\n\n\t/**\n\t * The model that was saved.\n\t */\n\treadonly model: ITextFileEditorModel;\n}\n\nexport interface ITextFileResolveEvent {\n\n\t/**\n\t * The model that was resolved.\n\t */\n\treadonly model: ITextFileEditorModel;\n\n\t/**\n\t * The reason why the model was resolved.\n\t */\n\treadonly reason: TextFileResolveReason;\n}\n\nexport interface ITextFileSaveParticipantContext {\n\n\t/**\n\t * The reason why the save was triggered.\n\t */\n\treadonly reason: SaveReason;\n\n\t/**\n\t * Only applies to when a text file was saved as, for\n\t * example when starting with untitled and saving. This\n\t * provides access to the initial resource the text\n\t * file had before.\n\t */\n\treadonly savedFrom?: URI;\n}\n\nexport interface ITextFileSaveParticipant {\n\n\t/**\n\t * The ordinal number which determines the order of participation.\n\t * Lower values mean to participant sooner\n\t */\n\treadonly ordinal?: number;\n\n\t/**\n\t * Participate in a save of a model. Allows to change the model\n\t * before it is being saved to disk.\n\t */\n\tparticipate(\n\t\tmodel: ITextFileEditorModel,\n\t\tcontext: ITextFileSaveParticipantContext,\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface ITextFileEditorModelManager {\n\n\treadonly onDidCreate: Event<ITextFileEditorModel>;\n\treadonly onDidResolve: Event<ITextFileResolveEvent>;\n\treadonly onDidChangeDirty: Event<ITextFileEditorModel>;\n\treadonly onDidChangeReadonly: Event<ITextFileEditorModel>;\n\treadonly onDidRemove: Event<URI>;\n\treadonly onDidChangeOrphaned: Event<ITextFileEditorModel>;\n\treadonly onDidChangeEncoding: Event<ITextFileEditorModel>;\n\treadonly onDidSaveError: Event<ITextFileEditorModel>;\n\treadonly onDidSave: Event<ITextFileSaveEvent>;\n\treadonly onDidRevert: Event<ITextFileEditorModel>;\n\n\t/**\n\t * Access to all text file editor models in memory.\n\t */\n\treadonly models: ITextFileEditorModel[];\n\n\t/**\n\t * Allows to configure the error handler that is called on save errors.\n\t */\n\tsaveErrorHandler: ISaveErrorHandler;\n\n\t/**\n\t * Returns the text file editor model for the provided resource\n\t * or undefined if none.\n\t */\n\tget(resource: URI): ITextFileEditorModel | undefined;\n\n\t/**\n\t * Allows to resolve a text file model from disk.\n\t */\n\tresolve(resource: URI, options?: ITextFileEditorModelResolveOrCreateOptions): Promise<ITextFileEditorModel>;\n\n\t/**\n\t * Adds a participant for saving text file models.\n\t */\n\taddSaveParticipant(participant: ITextFileSaveParticipant): IDisposable;\n\n\t/**\n\t * Runs the registered save participants on the provided model.\n\t */\n\trunSaveParticipants(model: ITextFileEditorModel, context: ITextFileSaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;\n\n\t/**\n\t * Waits for the model to be ready to be disposed. There may be conditions\n\t * under which the model cannot be disposed, e.g. when it is dirty. Once the\n\t * promise is settled, it is safe to dispose the model.\n\t */\n\tcanDispose(model: ITextFileEditorModel): true | Promise<true>;\n}\n\nexport interface ITextFileSaveOptions extends ISaveOptions {\n\n\t/**\n\t * Save the file with an attempt to unlock it.\n\t */\n\treadonly writeUnlock?: boolean;\n\n\t/**\n\t * Save the file with elevated privileges.\n\t *\n\t * Note: This may not be supported in all environments.\n\t */\n\treadonly writeElevated?: boolean;\n\n\t/**\n\t * Allows to write to a file even if it has been modified on disk.\n\t */\n\treadonly ignoreModifiedSince?: boolean;\n\n\t/**\n\t * If set, will bubble up the error to the caller instead of handling it.\n\t */\n\treadonly ignoreErrorHandler?: boolean;\n}\n\nexport interface ITextFileSaveAsOptions extends ITextFileSaveOptions {\n\n\t/**\n\t * Optional URI of the resource the text file is saved from if known.\n\t */\n\treadonly from?: URI;\n\n\t/**\n\t * Optional URI to use as suggested file path to save as.\n\t */\n\treadonly suggestedTarget?: URI;\n}\n\nexport interface ITextFileResolveOptions {\n\n\t/**\n\t * The contents to use for the model if known. If not\n\t * provided, the contents will be retrieved from the\n\t * underlying resource or backup if present.\n\t */\n\treadonly contents?: ITextBufferFactory;\n\n\t/**\n\t * Go to file bypassing any cache of the model if any.\n\t */\n\treadonly forceReadFromFile?: boolean;\n\n\t/**\n\t * Allow to resolve a model even if we think it is a binary file.\n\t */\n\treadonly allowBinary?: boolean;\n\n\t/**\n\t * Context why the model is being resolved.\n\t */\n\treadonly reason?: TextFileResolveReason;\n\n\t/**\n\t * If provided, the size of the file will be checked against the limits\n\t * and an error will be thrown if any limit is exceeded.\n\t */\n\treadonly limits?: IFileReadLimits;\n}\n\nexport const enum EncodingMode {\n\n\t/**\n\t * Instructs the encoding support to encode the object with the provided encoding\n\t */\n\tEncode,\n\n\t/**\n\t * Instructs the encoding support to decode the object with the provided encoding\n\t */\n\tDecode\n}\n\nexport interface IEncodingSupport {\n\n\t/**\n\t * Gets the encoding of the object if known.\n\t */\n\tgetEncoding(): string | undefined;\n\n\t/**\n\t * Sets the encoding for the object for saving.\n\t */\n\tsetEncoding(encoding: string, mode: EncodingMode): Promise<void>;\n}\n\nexport interface ILanguageSupport {\n\n\t/**\n\t * Sets the language id of the object.\n\t */\n\tsetLanguageId(languageId: string, source?: string): void;\n}\n\nexport interface ITextFileEditorModelSaveEvent extends IWorkingCopySaveEvent {\n\n\t/**\n\t * The resolved stat from the save operation.\n\t */\n\treadonly stat: IFileStatWithMetadata;\n}\n\nexport interface ITextFileEditorModel extends ITextEditorModel, IEncodingSupport, ILanguageSupport, IWorkingCopy {\n\n\treadonly onDidSave: Event<ITextFileEditorModelSaveEvent>;\n\treadonly onDidSaveError: Event<void>;\n\treadonly onDidChangeOrphaned: Event<void>;\n\treadonly onDidChangeReadonly: Event<void>;\n\treadonly onDidChangeEncoding: Event<void>;\n\n\thasState(state: TextFileEditorModelState): boolean;\n\tjoinState(state: TextFileEditorModelState.PENDING_SAVE): Promise<void>;\n\n\tupdatePreferredEncoding(encoding: string | undefined): void;\n\n\tsave(options?: ITextFileSaveAsOptions): Promise<boolean>;\n\trevert(options?: IRevertOptions): Promise<void>;\n\n\tresolve(options?: ITextFileResolveOptions): Promise<void>;\n\n\tisDirty(): this is IResolvedTextFileEditorModel;\n\n\tgetLanguageId(): string | undefined;\n\n\tisResolved(): this is IResolvedTextFileEditorModel;\n}\n\nexport function isTextFileEditorModel(model: ITextEditorModel): model is ITextFileEditorModel {\n\tconst candidate = model as ITextFileEditorModel;\n\n\treturn areFunctions(candidate.setEncoding, candidate.getEncoding, candidate.save, candidate.revert, candidate.isDirty, candidate.getLanguageId);\n}\n\nexport interface IResolvedTextFileEditorModel extends ITextFileEditorModel {\n\n\treadonly textEditorModel: ITextModel;\n\n\tcreateSnapshot(): ITextSnapshot;\n}\n\nexport function snapshotToString(snapshot: ITextSnapshot): string {\n\tconst chunks: string[] = [];\n\n\tlet chunk: string | null;\n\twhile (typeof (chunk = snapshot.read()) === 'string') {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn chunks.join('');\n}\n\nexport function stringToSnapshot(value: string): ITextSnapshot {\n\tlet done = false;\n\n\treturn {\n\t\tread(): string | null {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\nexport function toBufferOrReadable(value: string): VSBuffer;\nexport function toBufferOrReadable(value: ITextSnapshot): VSBufferReadable;\nexport function toBufferOrReadable(value: string | ITextSnapshot): VSBuffer | VSBufferReadable;\nexport function toBufferOrReadable(value: string | ITextSnapshot | undefined): VSBuffer | VSBufferReadable | undefined;\nexport function toBufferOrReadable(value: string | ITextSnapshot | undefined): VSBuffer | VSBufferReadable | undefined {\n\tif (typeof value === 'undefined') {\n\t\treturn undefined;\n\t}\n\n\tif (typeof value === 'string') {\n\t\treturn VSBuffer.fromString(value);\n\t}\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = value.read();\n\t\t\tif (typeof chunk === 'string') {\n\t\t\t\treturn VSBuffer.fromString(chunk);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n"]}