{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/textfile/test/node/encoding/encoding.test.ts","vs/workbench/services/textfile/test/node/encoding/encoding.test.ts"],"names":[],"mappings":"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","file":"encoding.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport * as fs from 'fs';\nimport * as encoding from '../../../common/encoding.js';\nimport * as streams from '../../../../../../base/common/stream.js';\nimport { newWriteableBufferStream, VSBuffer, VSBufferReadableStream, streamToBufferReadableStream } from '../../../../../../base/common/buffer.js';\nimport { splitLines } from '../../../../../../base/common/strings.js';\nimport { FileAccess } from '../../../../../../base/common/network.js';\nimport { importAMDNodeModule } from '../../../../../../amdX.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../../base/test/common/utils.js';\n\nexport async function detectEncodingByBOM(file: string): Promise<typeof encoding.UTF16be | typeof encoding.UTF16le | typeof encoding.UTF8_with_bom | null> {\n\ttry {\n\t\tconst { buffer, bytesRead } = await readExactlyByFile(file, 3);\n\n\t\treturn encoding.detectEncodingByBOMFromBuffer(buffer, bytesRead);\n\t} catch (error) {\n\t\treturn null; // ignore errors (like file not found)\n\t}\n}\n\ninterface ReadResult {\n\tbuffer: VSBuffer | null;\n\tbytesRead: number;\n}\n\nfunction readExactlyByFile(file: string, totalBytes: number): Promise<ReadResult> {\n\treturn new Promise<ReadResult>((resolve, reject) => {\n\t\tfs.open(file, 'r', null, (err, fd) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject(err);\n\t\t\t}\n\n\t\t\tfunction end(err: Error | null, resultBuffer: Buffer | null, bytesRead: number): void {\n\t\t\t\tfs.close(fd, closeError => {\n\t\t\t\t\tif (closeError) {\n\t\t\t\t\t\treturn reject(closeError);\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t\t\tif (err && (<any>err).code === 'EISDIR') {\n\t\t\t\t\t\treturn reject(err); // we want to bubble this error up (file is actually a folder)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ buffer: resultBuffer ? VSBuffer.wrap(resultBuffer) : null, bytesRead });\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst buffer = Buffer.allocUnsafe(totalBytes);\n\t\t\tlet offset = 0;\n\n\t\t\tfunction readChunk(): void {\n\t\t\t\tfs.read(fd, buffer, offset, totalBytes - offset, null, (err, bytesRead) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn end(err, null, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bytesRead === 0) {\n\t\t\t\t\t\treturn end(null, buffer, offset);\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += bytesRead;\n\n\t\t\t\t\tif (offset === totalBytes) {\n\t\t\t\t\t\treturn end(null, buffer, offset);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn readChunk();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treadChunk();\n\t\t});\n\t});\n}\n\nsuite('Encoding', () => {\n\n\ttest('detectBOM does not return error for non existing file', async () => {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/not-exist.css').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, null);\n\t});\n\n\ttest('detectBOM UTF-8', async () => {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf8.css').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, 'utf8bom');\n\t});\n\n\ttest('detectBOM UTF-16 LE', async () => {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16le.css').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, 'utf16le');\n\t});\n\n\ttest('detectBOM UTF-16 BE', async () => {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16be.css').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, 'utf16be');\n\t});\n\n\ttest('detectBOM ANSI', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_ansi.css').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, null);\n\t});\n\n\ttest('detectBOM ANSI (2)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/empty.txt').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, null);\n\t});\n\n\ttest('detectEncodingFromBuffer (JSON saved as PNG)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.json.png').fsPath;\n\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, false);\n\t});\n\n\ttest('detectEncodingFromBuffer (PNG saved as TXT)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.png.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, true);\n\t});\n\n\ttest('detectEncodingFromBuffer (XML saved as PNG)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.xml.png').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, false);\n\t});\n\n\ttest('detectEncodingFromBuffer (QWOFF saved as TXT)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.qwoff.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, true);\n\t});\n\n\ttest('detectEncodingFromBuffer (CSS saved as QWOFF)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.css.qwoff').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, false);\n\t});\n\n\ttest('detectEncodingFromBuffer (PDF)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.pdf').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, true);\n\t});\n\n\ttest('detectEncodingFromBuffer (guess UTF-16 LE from content without BOM)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/utf16_le_nobom.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.encoding, encoding.UTF16le);\n\t\tassert.strictEqual(mimes.seemsBinary, false);\n\t});\n\n\ttest('detectEncodingFromBuffer (guess UTF-16 BE from content without BOM)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/utf16_be_nobom.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.encoding, encoding.UTF16be);\n\t\tassert.strictEqual(mimes.seemsBinary, false);\n\t});\n\n\ttest('autoGuessEncoding (UTF8)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_file.css').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512 * 8);\n\t\tconst mimes = await encoding.detectEncodingFromBuffer(buffer, true);\n\t\tassert.strictEqual(mimes.encoding, 'utf8');\n\t});\n\n\ttest('autoGuessEncoding (ASCII)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_ansi.css').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512 * 8);\n\t\tconst mimes = await encoding.detectEncodingFromBuffer(buffer, true);\n\t\tassert.strictEqual(mimes.encoding, null);\n\t});\n\n\ttest('autoGuessEncoding (ShiftJIS)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.shiftjis.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512 * 8);\n\t\tconst mimes = await encoding.detectEncodingFromBuffer(buffer, true);\n\t\tassert.strictEqual(mimes.encoding, 'shiftjis');\n\t});\n\n\ttest('autoGuessEncoding (CP1252)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.cp1252.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512 * 8);\n\t\tconst mimes = await encoding.detectEncodingFromBuffer(buffer, true);\n\t\tassert.strictEqual(mimes.encoding, 'windows1252');\n\t});\n\n\ttest('autoGuessEncoding (candidateGuessEncodings - ShiftJIS)', async function () {\n\t\t// This file is determined to be windows1252 unless candidateDetectEncoding is set.\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.shiftjis.1.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512 * 8);\n\t\tconst mimes = await encoding.detectEncodingFromBuffer(buffer, true, ['utf8', 'shiftjis', 'eucjp']);\n\t\tassert.strictEqual(mimes.encoding, 'shiftjis');\n\t});\n\n\tasync function readAndDecodeFromDisk(path: string, fileEncoding: string | null) {\n\t\treturn new Promise<string>((resolve, reject) => {\n\t\t\tfs.readFile(path, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js').then(iconv => iconv.decode(data, encoding.toNodeEncoding(fileEncoding))));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction newTestReadableStream(buffers: Buffer[]): VSBufferReadableStream {\n\t\tconst stream = newWriteableBufferStream();\n\t\tbuffers\n\t\t\t.map(VSBuffer.wrap)\n\t\t\t.forEach(buffer => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tstream.write(buffer);\n\t\t\t\t});\n\t\t\t});\n\t\tsetTimeout(() => {\n\t\t\tstream.end();\n\t\t});\n\t\treturn stream;\n\t}\n\n\tasync function readAllAsString(stream: streams.ReadableStream<string>) {\n\t\treturn streams.consumeStream(stream, strings => strings.join(''));\n\t}\n\n\ttest('toDecodeStream - some stream', async function () {\n\t\tconst source = newTestReadableStream([\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t]);\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 4, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tassert.ok(detected);\n\t\tassert.ok(stream);\n\n\t\tconst content = await readAllAsString(stream);\n\t\tassert.strictEqual(content, 'ABCABCABC');\n\t});\n\n\ttest('toDecodeStream - some stream, expect too much data', async function () {\n\t\tconst source = newTestReadableStream([\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t]);\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 64, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tassert.ok(detected);\n\t\tassert.ok(stream);\n\n\t\tconst content = await readAllAsString(stream);\n\t\tassert.strictEqual(content, 'ABCABCABC');\n\t});\n\n\ttest('toDecodeStream - some stream, no data', async function () {\n\t\tconst source = newWriteableBufferStream();\n\t\tsource.end();\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 512, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tassert.ok(detected);\n\t\tassert.ok(stream);\n\n\t\tconst content = await readAllAsString(stream);\n\t\tassert.strictEqual(content, '');\n\t});\n\n\ttest('toDecodeStream - encoding, utf16be', async function () {\n\t\tconst path = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16be.css').fsPath;\n\t\tconst source = streamToBufferReadableStream(fs.createReadStream(path));\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 64, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tassert.strictEqual(detected.encoding, 'utf16be');\n\t\tassert.strictEqual(detected.seemsBinary, false);\n\n\t\tconst expected = await readAndDecodeFromDisk(path, detected.encoding);\n\t\tconst actual = await readAllAsString(stream);\n\t\tassert.strictEqual(actual, expected);\n\t});\n\n\ttest('toDecodeStream - empty file', async function () {\n\t\tconst path = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/empty.txt').fsPath;\n\t\tconst source = streamToBufferReadableStream(fs.createReadStream(path));\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tconst expected = await readAndDecodeFromDisk(path, detected.encoding);\n\t\tconst actual = await readAllAsString(stream);\n\t\tassert.strictEqual(actual, expected);\n\t});\n\n\ttest('toDecodeStream - decodes buffer entirely', async function () {\n\t\tconst emojis = Buffer.from('üñ•Ô∏èüíªüíæ');\n\t\tconst incompleteEmojis = emojis.slice(0, emojis.length - 1);\n\n\t\tconst buffers: Buffer[] = [];\n\t\tfor (let i = 0; i < incompleteEmojis.length; i++) {\n\t\t\tbuffers.push(incompleteEmojis.slice(i, i + 1));\n\t\t}\n\n\t\tconst source = newTestReadableStream(buffers);\n\t\tconst { stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 4, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tconst expected = new TextDecoder().decode(incompleteEmojis);\n\t\tconst actual = await readAllAsString(stream);\n\n\t\tassert.strictEqual(actual, expected);\n\t});\n\n\ttest('toDecodeStream - some stream (GBK issue #101856)', async function () {\n\t\tconst path = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_gbk.txt').fsPath;\n\t\tconst source = streamToBufferReadableStream(fs.createReadStream(path));\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 4, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async () => 'gbk' });\n\t\tassert.ok(detected);\n\t\tassert.ok(stream);\n\n\t\tconst content = await readAllAsString(stream);\n\t\tassert.strictEqual(content.length, 65537);\n\t});\n\n\ttest('toDecodeStream - some stream (UTF-8 issue #102202)', async function () {\n\t\tconst path = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/issue_102202.txt').fsPath;\n\t\tconst source = streamToBufferReadableStream(fs.createReadStream(path));\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 4, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async () => 'utf-8' });\n\t\tassert.ok(detected);\n\t\tassert.ok(stream);\n\n\t\tconst content = await readAllAsString(stream);\n\t\tconst lines = splitLines(content);\n\n\t\tassert.strictEqual(lines[981].toString(), 'ÂïäÂïäÂïäÂïäÂïäÂïäaaaÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÔºåÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïä„ÄÇ');\n\t});\n\n\ttest('toDecodeStream - binary', async function () {\n\t\tconst source = () => {\n\t\t\treturn newTestReadableStream([\n\t\t\t\tBuffer.from([0, 0, 0]),\n\t\t\t\tBuffer.from('Hello World'),\n\t\t\t\tBuffer.from([0])\n\t\t\t]);\n\t\t};\n\n\t\t// acceptTextOnly: true\n\n\t\tlet error: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait encoding.toDecodeStream(source(), { acceptTextOnly: true, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error instanceof encoding.DecodeStreamError);\n\t\tassert.strictEqual(error.decodeStreamErrorKind, encoding.DecodeStreamErrorKind.STREAM_IS_BINARY);\n\n\t\t// acceptTextOnly: false\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source(), { acceptTextOnly: false, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tassert.ok(detected);\n\t\tassert.strictEqual(detected.seemsBinary, true);\n\t\tassert.ok(stream);\n\t});\n\n\ttest('toEncodeReadable - encoding, utf16be', async function () {\n\t\tconst path = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16be.css').fsPath;\n\t\tconst source = await readAndDecodeFromDisk(path, encoding.UTF16be);\n\n\t\tconst iconv = await importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js');\n\n\t\tconst expected = VSBuffer.wrap(\n\t\t\ticonv.encode(source, encoding.toNodeEncoding(encoding.UTF16be))\n\t\t).toString();\n\n\t\tconst actual = streams.consumeReadable(\n\t\t\tawait encoding.toEncodeReadable(streams.toReadable(source), encoding.UTF16be),\n\t\t\tVSBuffer.concat\n\t\t).toString();\n\n\t\tassert.strictEqual(actual, expected);\n\t});\n\n\ttest('toEncodeReadable - empty readable to utf8', async function () {\n\t\tconst source: streams.Readable<string> = {\n\t\t\tread() {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\n\t\tconst actual = streams.consumeReadable(\n\t\t\tawait encoding.toEncodeReadable(source, encoding.UTF8),\n\t\t\tVSBuffer.concat\n\t\t).toString();\n\n\t\tassert.strictEqual(actual, '');\n\t});\n\n\t[{\n\t\tutfEncoding: encoding.UTF8,\n\t\trelatedBom: encoding.UTF8_BOM\n\t}, {\n\t\tutfEncoding: encoding.UTF8_with_bom,\n\t\trelatedBom: encoding.UTF8_BOM\n\t}, {\n\t\tutfEncoding: encoding.UTF16be,\n\t\trelatedBom: encoding.UTF16be_BOM,\n\t}, {\n\t\tutfEncoding: encoding.UTF16le,\n\t\trelatedBom: encoding.UTF16le_BOM\n\t}].forEach(({ utfEncoding, relatedBom }) => {\n\t\ttest(`toEncodeReadable - empty readable to ${utfEncoding} with BOM`, async function () {\n\t\t\tconst source: streams.Readable<string> = {\n\t\t\t\tread() {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst encodedReadable = encoding.toEncodeReadable(source, utfEncoding, { addBOM: true });\n\n\t\t\tconst expected = VSBuffer.wrap(Buffer.from(relatedBom)).toString();\n\t\t\tconst actual = streams.consumeReadable(await encodedReadable, VSBuffer.concat).toString();\n\n\t\t\tassert.strictEqual(actual, expected);\n\t\t});\n\t});\n\n\ttest('encodingExists', async function () {\n\t\tfor (const enc in encoding.SUPPORTED_ENCODINGS) {\n\t\t\tif (enc === encoding.UTF8_with_bom) {\n\t\t\t\tcontinue; // skip over encodings from us\n\t\t\t}\n\t\t\tconst iconv = await importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js');\n\t\t\tassert.strictEqual(iconv.encodingExists(enc), true, enc);\n\t\t}\n\t});\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport * as fs from 'fs';\nimport * as encoding from '../../../common/encoding.js';\nimport * as streams from '../../../../../../base/common/stream.js';\nimport { newWriteableBufferStream, VSBuffer, VSBufferReadableStream, streamToBufferReadableStream } from '../../../../../../base/common/buffer.js';\nimport { splitLines } from '../../../../../../base/common/strings.js';\nimport { FileAccess } from '../../../../../../base/common/network.js';\nimport { importAMDNodeModule } from '../../../../../../amdX.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../../base/test/common/utils.js';\n\nexport async function detectEncodingByBOM(file: string): Promise<typeof encoding.UTF16be | typeof encoding.UTF16le | typeof encoding.UTF8_with_bom | null> {\n\ttry {\n\t\tconst { buffer, bytesRead } = await readExactlyByFile(file, 3);\n\n\t\treturn encoding.detectEncodingByBOMFromBuffer(buffer, bytesRead);\n\t} catch (error) {\n\t\treturn null; // ignore errors (like file not found)\n\t}\n}\n\ninterface ReadResult {\n\tbuffer: VSBuffer | null;\n\tbytesRead: number;\n}\n\nfunction readExactlyByFile(file: string, totalBytes: number): Promise<ReadResult> {\n\treturn new Promise<ReadResult>((resolve, reject) => {\n\t\tfs.open(file, 'r', null, (err, fd) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject(err);\n\t\t\t}\n\n\t\t\tfunction end(err: Error | null, resultBuffer: Buffer | null, bytesRead: number): void {\n\t\t\t\tfs.close(fd, closeError => {\n\t\t\t\t\tif (closeError) {\n\t\t\t\t\t\treturn reject(closeError);\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t\t\tif (err && (<any>err).code === 'EISDIR') {\n\t\t\t\t\t\treturn reject(err); // we want to bubble this error up (file is actually a folder)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ buffer: resultBuffer ? VSBuffer.wrap(resultBuffer) : null, bytesRead });\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst buffer = Buffer.allocUnsafe(totalBytes);\n\t\t\tlet offset = 0;\n\n\t\t\tfunction readChunk(): void {\n\t\t\t\tfs.read(fd, buffer, offset, totalBytes - offset, null, (err, bytesRead) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn end(err, null, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bytesRead === 0) {\n\t\t\t\t\t\treturn end(null, buffer, offset);\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += bytesRead;\n\n\t\t\t\t\tif (offset === totalBytes) {\n\t\t\t\t\t\treturn end(null, buffer, offset);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn readChunk();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treadChunk();\n\t\t});\n\t});\n}\n\nsuite('Encoding', () => {\n\n\ttest('detectBOM does not return error for non existing file', async () => {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/not-exist.css').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, null);\n\t});\n\n\ttest('detectBOM UTF-8', async () => {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf8.css').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, 'utf8bom');\n\t});\n\n\ttest('detectBOM UTF-16 LE', async () => {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16le.css').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, 'utf16le');\n\t});\n\n\ttest('detectBOM UTF-16 BE', async () => {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16be.css').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, 'utf16be');\n\t});\n\n\ttest('detectBOM ANSI', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_ansi.css').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, null);\n\t});\n\n\ttest('detectBOM ANSI (2)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/empty.txt').fsPath;\n\n\t\tconst detectedEncoding = await detectEncodingByBOM(file);\n\t\tassert.strictEqual(detectedEncoding, null);\n\t});\n\n\ttest('detectEncodingFromBuffer (JSON saved as PNG)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.json.png').fsPath;\n\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, false);\n\t});\n\n\ttest('detectEncodingFromBuffer (PNG saved as TXT)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.png.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, true);\n\t});\n\n\ttest('detectEncodingFromBuffer (XML saved as PNG)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.xml.png').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, false);\n\t});\n\n\ttest('detectEncodingFromBuffer (QWOFF saved as TXT)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.qwoff.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, true);\n\t});\n\n\ttest('detectEncodingFromBuffer (CSS saved as QWOFF)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.css.qwoff').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, false);\n\t});\n\n\ttest('detectEncodingFromBuffer (PDF)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.pdf').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.seemsBinary, true);\n\t});\n\n\ttest('detectEncodingFromBuffer (guess UTF-16 LE from content without BOM)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/utf16_le_nobom.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.encoding, encoding.UTF16le);\n\t\tassert.strictEqual(mimes.seemsBinary, false);\n\t});\n\n\ttest('detectEncodingFromBuffer (guess UTF-16 BE from content without BOM)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/utf16_be_nobom.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512);\n\t\tconst mimes = encoding.detectEncodingFromBuffer(buffer);\n\t\tassert.strictEqual(mimes.encoding, encoding.UTF16be);\n\t\tassert.strictEqual(mimes.seemsBinary, false);\n\t});\n\n\ttest('autoGuessEncoding (UTF8)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_file.css').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512 * 8);\n\t\tconst mimes = await encoding.detectEncodingFromBuffer(buffer, true);\n\t\tassert.strictEqual(mimes.encoding, 'utf8');\n\t});\n\n\ttest('autoGuessEncoding (ASCII)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_ansi.css').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512 * 8);\n\t\tconst mimes = await encoding.detectEncodingFromBuffer(buffer, true);\n\t\tassert.strictEqual(mimes.encoding, null);\n\t});\n\n\ttest('autoGuessEncoding (ShiftJIS)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.shiftjis.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512 * 8);\n\t\tconst mimes = await encoding.detectEncodingFromBuffer(buffer, true);\n\t\tassert.strictEqual(mimes.encoding, 'shiftjis');\n\t});\n\n\ttest('autoGuessEncoding (CP1252)', async function () {\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.cp1252.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512 * 8);\n\t\tconst mimes = await encoding.detectEncodingFromBuffer(buffer, true);\n\t\tassert.strictEqual(mimes.encoding, 'windows1252');\n\t});\n\n\ttest('autoGuessEncoding (candidateGuessEncodings - ShiftJIS)', async function () {\n\t\t// This file is determined to be windows1252 unless candidateDetectEncoding is set.\n\t\tconst file = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some.shiftjis.1.txt').fsPath;\n\t\tconst buffer = await readExactlyByFile(file, 512 * 8);\n\t\tconst mimes = await encoding.detectEncodingFromBuffer(buffer, true, ['utf8', 'shiftjis', 'eucjp']);\n\t\tassert.strictEqual(mimes.encoding, 'shiftjis');\n\t});\n\n\tasync function readAndDecodeFromDisk(path: string, fileEncoding: string | null) {\n\t\treturn new Promise<string>((resolve, reject) => {\n\t\t\tfs.readFile(path, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js').then(iconv => iconv.decode(data, encoding.toNodeEncoding(fileEncoding))));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction newTestReadableStream(buffers: Buffer[]): VSBufferReadableStream {\n\t\tconst stream = newWriteableBufferStream();\n\t\tbuffers\n\t\t\t.map(VSBuffer.wrap)\n\t\t\t.forEach(buffer => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tstream.write(buffer);\n\t\t\t\t});\n\t\t\t});\n\t\tsetTimeout(() => {\n\t\t\tstream.end();\n\t\t});\n\t\treturn stream;\n\t}\n\n\tasync function readAllAsString(stream: streams.ReadableStream<string>) {\n\t\treturn streams.consumeStream(stream, strings => strings.join(''));\n\t}\n\n\ttest('toDecodeStream - some stream', async function () {\n\t\tconst source = newTestReadableStream([\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t]);\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 4, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tassert.ok(detected);\n\t\tassert.ok(stream);\n\n\t\tconst content = await readAllAsString(stream);\n\t\tassert.strictEqual(content, 'ABCABCABC');\n\t});\n\n\ttest('toDecodeStream - some stream, expect too much data', async function () {\n\t\tconst source = newTestReadableStream([\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t\tBuffer.from([65, 66, 67]),\n\t\t]);\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 64, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tassert.ok(detected);\n\t\tassert.ok(stream);\n\n\t\tconst content = await readAllAsString(stream);\n\t\tassert.strictEqual(content, 'ABCABCABC');\n\t});\n\n\ttest('toDecodeStream - some stream, no data', async function () {\n\t\tconst source = newWriteableBufferStream();\n\t\tsource.end();\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 512, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tassert.ok(detected);\n\t\tassert.ok(stream);\n\n\t\tconst content = await readAllAsString(stream);\n\t\tassert.strictEqual(content, '');\n\t});\n\n\ttest('toDecodeStream - encoding, utf16be', async function () {\n\t\tconst path = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16be.css').fsPath;\n\t\tconst source = streamToBufferReadableStream(fs.createReadStream(path));\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 64, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tassert.strictEqual(detected.encoding, 'utf16be');\n\t\tassert.strictEqual(detected.seemsBinary, false);\n\n\t\tconst expected = await readAndDecodeFromDisk(path, detected.encoding);\n\t\tconst actual = await readAllAsString(stream);\n\t\tassert.strictEqual(actual, expected);\n\t});\n\n\ttest('toDecodeStream - empty file', async function () {\n\t\tconst path = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/empty.txt').fsPath;\n\t\tconst source = streamToBufferReadableStream(fs.createReadStream(path));\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tconst expected = await readAndDecodeFromDisk(path, detected.encoding);\n\t\tconst actual = await readAllAsString(stream);\n\t\tassert.strictEqual(actual, expected);\n\t});\n\n\ttest('toDecodeStream - decodes buffer entirely', async function () {\n\t\tconst emojis = Buffer.from('üñ•Ô∏èüíªüíæ');\n\t\tconst incompleteEmojis = emojis.slice(0, emojis.length - 1);\n\n\t\tconst buffers: Buffer[] = [];\n\t\tfor (let i = 0; i < incompleteEmojis.length; i++) {\n\t\t\tbuffers.push(incompleteEmojis.slice(i, i + 1));\n\t\t}\n\n\t\tconst source = newTestReadableStream(buffers);\n\t\tconst { stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 4, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tconst expected = new TextDecoder().decode(incompleteEmojis);\n\t\tconst actual = await readAllAsString(stream);\n\n\t\tassert.strictEqual(actual, expected);\n\t});\n\n\ttest('toDecodeStream - some stream (GBK issue #101856)', async function () {\n\t\tconst path = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_gbk.txt').fsPath;\n\t\tconst source = streamToBufferReadableStream(fs.createReadStream(path));\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 4, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async () => 'gbk' });\n\t\tassert.ok(detected);\n\t\tassert.ok(stream);\n\n\t\tconst content = await readAllAsString(stream);\n\t\tassert.strictEqual(content.length, 65537);\n\t});\n\n\ttest('toDecodeStream - some stream (UTF-8 issue #102202)', async function () {\n\t\tconst path = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/issue_102202.txt').fsPath;\n\t\tconst source = streamToBufferReadableStream(fs.createReadStream(path));\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source, { acceptTextOnly: true, minBytesRequiredForDetection: 4, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async () => 'utf-8' });\n\t\tassert.ok(detected);\n\t\tassert.ok(stream);\n\n\t\tconst content = await readAllAsString(stream);\n\t\tconst lines = splitLines(content);\n\n\t\tassert.strictEqual(lines[981].toString(), 'ÂïäÂïäÂïäÂïäÂïäÂïäaaaÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÔºåÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïäÂïä„ÄÇ');\n\t});\n\n\ttest('toDecodeStream - binary', async function () {\n\t\tconst source = () => {\n\t\t\treturn newTestReadableStream([\n\t\t\t\tBuffer.from([0, 0, 0]),\n\t\t\t\tBuffer.from('Hello World'),\n\t\t\t\tBuffer.from([0])\n\t\t\t]);\n\t\t};\n\n\t\t// acceptTextOnly: true\n\n\t\tlet error: Error | undefined = undefined;\n\t\ttry {\n\t\t\tawait encoding.toDecodeStream(source(), { acceptTextOnly: true, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\n\t\tassert.ok(error instanceof encoding.DecodeStreamError);\n\t\tassert.strictEqual(error.decodeStreamErrorKind, encoding.DecodeStreamErrorKind.STREAM_IS_BINARY);\n\n\t\t// acceptTextOnly: false\n\n\t\tconst { detected, stream } = await encoding.toDecodeStream(source(), { acceptTextOnly: false, guessEncoding: false, candidateGuessEncodings: [], overwriteEncoding: async detected => detected || encoding.UTF8 });\n\n\t\tassert.ok(detected);\n\t\tassert.strictEqual(detected.seemsBinary, true);\n\t\tassert.ok(stream);\n\t});\n\n\ttest('toEncodeReadable - encoding, utf16be', async function () {\n\t\tconst path = FileAccess.asFileUri('vs/workbench/services/textfile/test/node/encoding/fixtures/some_utf16be.css').fsPath;\n\t\tconst source = await readAndDecodeFromDisk(path, encoding.UTF16be);\n\n\t\tconst iconv = await importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js');\n\n\t\tconst expected = VSBuffer.wrap(\n\t\t\ticonv.encode(source, encoding.toNodeEncoding(encoding.UTF16be))\n\t\t).toString();\n\n\t\tconst actual = streams.consumeReadable(\n\t\t\tawait encoding.toEncodeReadable(streams.toReadable(source), encoding.UTF16be),\n\t\t\tVSBuffer.concat\n\t\t).toString();\n\n\t\tassert.strictEqual(actual, expected);\n\t});\n\n\ttest('toEncodeReadable - empty readable to utf8', async function () {\n\t\tconst source: streams.Readable<string> = {\n\t\t\tread() {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\n\t\tconst actual = streams.consumeReadable(\n\t\t\tawait encoding.toEncodeReadable(source, encoding.UTF8),\n\t\t\tVSBuffer.concat\n\t\t).toString();\n\n\t\tassert.strictEqual(actual, '');\n\t});\n\n\t[{\n\t\tutfEncoding: encoding.UTF8,\n\t\trelatedBom: encoding.UTF8_BOM\n\t}, {\n\t\tutfEncoding: encoding.UTF8_with_bom,\n\t\trelatedBom: encoding.UTF8_BOM\n\t}, {\n\t\tutfEncoding: encoding.UTF16be,\n\t\trelatedBom: encoding.UTF16be_BOM,\n\t}, {\n\t\tutfEncoding: encoding.UTF16le,\n\t\trelatedBom: encoding.UTF16le_BOM\n\t}].forEach(({ utfEncoding, relatedBom }) => {\n\t\ttest(`toEncodeReadable - empty readable to ${utfEncoding} with BOM`, async function () {\n\t\t\tconst source: streams.Readable<string> = {\n\t\t\t\tread() {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst encodedReadable = encoding.toEncodeReadable(source, utfEncoding, { addBOM: true });\n\n\t\t\tconst expected = VSBuffer.wrap(Buffer.from(relatedBom)).toString();\n\t\t\tconst actual = streams.consumeReadable(await encodedReadable, VSBuffer.concat).toString();\n\n\t\t\tassert.strictEqual(actual, expected);\n\t\t});\n\t});\n\n\ttest('encodingExists', async function () {\n\t\tfor (const enc in encoding.SUPPORTED_ENCODINGS) {\n\t\t\tif (enc === encoding.UTF8_with_bom) {\n\t\t\t\tcontinue; // skip over encodings from us\n\t\t\t}\n\t\t\tconst iconv = await importAMDNodeModule<typeof import('@vscode/iconv-lite-umd')>('@vscode/iconv-lite-umd', 'lib/iconv-lite-umd.js');\n\t\t\tassert.strictEqual(iconv.encodingExists(enc), true, enc);\n\t\t}\n\t});\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n});\n"]}