{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/configurationResolver/common/configurationResolverExpression.ts","vs/workbench/services/configurationResolver/common/configurationResolverExpression.ts"],"names":[],"mappings":"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","file":"configurationResolverExpression.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { isLinux, isMacintosh, isWindows } from '../../../../base/common/platform.js';\nimport { ConfiguredInput } from './configurationResolver.js';\n\n/** A replacement found in the object, as ${name} or ${name:arg} */\nexport type Replacement = {\n\t/** ${name:arg} */\n\tid: string;\n\t/** The `name:arg` in ${name:arg} */\n\tinner: string;\n\t/** The `name` in ${name:arg} */\n\tname: string;\n\t/** The `arg` in ${name:arg} */\n\targ?: string;\n};\n\ninterface IConfigurationResolverExpression<T> {\n\t/**\n\t * Gets the replacements which have not yet been\n\t * resolved.\n\t */\n\tunresolved(): Iterable<Replacement>;\n\n\t/**\n\t * Gets the replacements which have been resolved.\n\t */\n\tresolved(): Iterable<[Replacement, IResolvedValue]>;\n\n\t/**\n\t * Resolves a replacement into the string value.\n\t * If the value is undefined, the original variable text will be preserved.\n\t */\n\tresolve(replacement: Replacement, data: string | IResolvedValue): void;\n\n\t/**\n\t * Returns the complete object. Any unresolved replacements are left intact.\n\t */\n\ttoObject(): T;\n}\n\ntype PropertyLocation = {\n\tobject: any;\n\tpropertyName: string | number;\n\treplaceKeyName?: boolean;\n};\n\nexport interface IResolvedValue {\n\tvalue: string | undefined;\n\n\t/** Present when the variable is resolved from an input field. */\n\tinput?: ConfiguredInput;\n}\n\ninterface IReplacementLocation {\n\treplacement: Replacement;\n\tlocations: PropertyLocation[];\n\tresolved?: IResolvedValue;\n}\n\nexport class ConfigurationResolverExpression<T> implements IConfigurationResolverExpression<T> {\n\tpublic static readonly VARIABLE_LHS = '${';\n\n\tprivate readonly locations = new Map<string, IReplacementLocation>();\n\tprivate root: T;\n\tprivate stringRoot: boolean;\n\t/**\n\t * Callbacks when a new replacement is made, so that nested resolutions from\n\t * `expr.unresolved()` can be fulfilled in the same iteration.\n\t */\n\tprivate newReplacementNotifiers = new Set<(r: Replacement) => void>();\n\n\tprivate constructor(object: T) {\n\t\t// If the input is a string, wrap it in an object so we can use the same logic\n\t\tif (typeof object === 'string') {\n\t\t\tthis.stringRoot = true;\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tthis.root = { value: object } as any;\n\t\t} else {\n\t\t\tthis.stringRoot = false;\n\t\t\tthis.root = structuredClone(object);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new {@link ConfigurationResolverExpression} from an object.\n\t * Note that platform-specific keys (i.e. `windows`, `osx`, `linux`) are\n\t * applied during parsing.\n\t */\n\tpublic static parse<T>(object: T): ConfigurationResolverExpression<T> {\n\t\tif (object instanceof ConfigurationResolverExpression) {\n\t\t\treturn object;\n\t\t}\n\n\t\tconst expr = new ConfigurationResolverExpression<T>(object);\n\t\texpr.applyPlatformSpecificKeys();\n\t\texpr.parseObject(expr.root);\n\t\treturn expr;\n\t}\n\n\tprivate applyPlatformSpecificKeys() {\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tconst config = this.root as any; // already cloned by ctor, safe to change\n\t\tconst key = isWindows ? 'windows' : isMacintosh ? 'osx' : isLinux ? 'linux' : undefined;\n\n\t\tif (key && config && typeof config === 'object' && config.hasOwnProperty(key)) {\n\t\t\tObject.keys(config[key]).forEach(k => config[k] = config[key][k]);\n\t\t}\n\n\t\tdelete config.windows;\n\t\tdelete config.osx;\n\t\tdelete config.linux;\n\t}\n\n\tprivate parseVariable(str: string, start: number): { replacement: Replacement; end: number } | undefined {\n\t\tif (str[start] !== '$' || str[start + 1] !== '{') {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet end = start + 2;\n\t\tlet braceCount = 1;\n\t\twhile (end < str.length) {\n\t\t\tif (str[end] === '{') {\n\t\t\t\tbraceCount++;\n\t\t\t} else if (str[end] === '}') {\n\t\t\t\tbraceCount--;\n\t\t\t\tif (braceCount === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tend++;\n\t\t}\n\n\t\tif (braceCount !== 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst id = str.slice(start, end + 1);\n\t\tconst inner = str.substring(start + 2, end);\n\t\tconst colonIdx = inner.indexOf(':');\n\t\tif (colonIdx === -1) {\n\t\t\treturn { replacement: { id, name: inner, inner }, end };\n\t\t}\n\n\t\treturn {\n\t\t\treplacement: {\n\t\t\t\tid,\n\t\t\t\tinner,\n\t\t\t\tname: inner.slice(0, colonIdx),\n\t\t\t\targ: inner.slice(colonIdx + 1)\n\t\t\t},\n\t\t\tend\n\t\t};\n\t}\n\n\tprivate parseObject(obj: any): void {\n\t\tif (typeof obj !== 'object' || obj === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (Array.isArray(obj)) {\n\t\t\tfor (let i = 0; i < obj.length; i++) {\n\t\t\t\tconst value = obj[i];\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tthis.parseString(obj, i, value);\n\t\t\t\t} else {\n\t\t\t\t\tthis.parseObject(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\tthis.parseString(obj, key, key, true); // parse key\n\n\t\t\tif (typeof value === 'string') {\n\t\t\t\tthis.parseString(obj, key, value);\n\t\t\t} else {\n\t\t\t\tthis.parseObject(value);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate parseString(object: any, propertyName: string | number, value: string, replaceKeyName?: boolean, replacementPath?: string[]): void {\n\t\tlet pos = 0;\n\t\twhile (pos < value.length) {\n\t\t\tconst match = value.indexOf('${', pos);\n\t\t\tif (match === -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst parsed = this.parseVariable(value, match);\n\t\t\tif (parsed) {\n\t\t\t\tpos = parsed.end + 1;\n\t\t\t\tif (replacementPath?.includes(parsed.replacement.id)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst locations = this.locations.get(parsed.replacement.id) || { locations: [], replacement: parsed.replacement };\n\t\t\t\tconst newLocation: PropertyLocation = { object, propertyName, replaceKeyName };\n\t\t\t\tlocations.locations.push(newLocation);\n\t\t\t\tthis.locations.set(parsed.replacement.id, locations);\n\n\t\t\t\tif (locations.resolved) {\n\t\t\t\t\tthis._resolveAtLocation(parsed.replacement, newLocation, locations.resolved, replacementPath);\n\t\t\t\t} else {\n\t\t\t\t\tthis.newReplacementNotifiers.forEach(n => n(parsed.replacement));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpos = match + 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic *unresolved(): Iterable<Replacement> {\n\t\tconst newReplacements = new Map<string, Replacement>();\n\t\tconst notifier = (replacement: Replacement) => {\n\t\t\tnewReplacements.set(replacement.id, replacement);\n\t\t};\n\n\t\tfor (const location of this.locations.values()) {\n\t\t\tif (location.resolved === undefined) {\n\t\t\t\tnewReplacements.set(location.replacement.id, location.replacement);\n\t\t\t}\n\t\t}\n\n\t\tthis.newReplacementNotifiers.add(notifier);\n\n\t\twhile (true) {\n\t\t\tconst next = Iterable.first(newReplacements);\n\t\t\tif (!next) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst [key, value] = next;\n\t\t\tyield value;\n\t\t\tnewReplacements.delete(key);\n\t\t}\n\n\t\tthis.newReplacementNotifiers.delete(notifier);\n\t}\n\n\tpublic resolved(): Iterable<[Replacement, IResolvedValue]> {\n\t\treturn Iterable.map(Iterable.filter(this.locations.values(), l => !!l.resolved), l => [l.replacement, l.resolved!]);\n\t}\n\n\tpublic resolve(replacement: Replacement, data: string | IResolvedValue): void {\n\t\tif (typeof data !== 'object') {\n\t\t\tdata = { value: String(data) };\n\t\t}\n\n\t\tconst location = this.locations.get(replacement.id);\n\t\tif (!location) {\n\t\t\treturn;\n\t\t}\n\n\t\tlocation.resolved = data;\n\n\t\tif (data.value !== undefined) {\n\t\t\tfor (const l of location.locations || Iterable.empty()) {\n\t\t\t\tthis._resolveAtLocation(replacement, l, data);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _resolveAtLocation(replacement: Replacement, { replaceKeyName, propertyName, object }: PropertyLocation, data: IResolvedValue, path: string[] = []) {\n\t\tif (data.value === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// avoid recursive resolution, e.g. ${env:FOO} -> ${env:BAR}=${env:FOO}\n\t\tpath.push(replacement.id);\n\n\t\t// note: in nested `this.parseString`, parse only the new substring for any replacements, don't reparse the whole string\n\t\tif (replaceKeyName && typeof propertyName === 'string') {\n\t\t\tconst value = object[propertyName];\n\t\t\tconst newKey = propertyName.replaceAll(replacement.id, data.value);\n\t\t\tdelete object[propertyName];\n\t\t\tobject[newKey] = value;\n\t\t\tthis._renameKeyInLocations(object, propertyName, newKey);\n\t\t\tthis.parseString(object, newKey, data.value, true, path);\n\t\t} else {\n\t\t\tobject[propertyName] = object[propertyName].replaceAll(replacement.id, data.value);\n\t\t\tthis.parseString(object, propertyName, data.value, false, path);\n\t\t}\n\n\t\tpath.pop();\n\t}\n\n\tprivate _renameKeyInLocations(obj: object, oldKey: string, newKey: string) {\n\t\tfor (const location of this.locations.values()) {\n\t\t\tfor (const loc of location.locations) {\n\t\t\t\tif (loc.object === obj && loc.propertyName === oldKey) {\n\t\t\t\t\tloc.propertyName = newKey;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic toObject(): T {\n\t\t// If we wrapped a string, unwrap it\n\t\tif (this.stringRoot) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\treturn (this.root as any).value as T;\n\t\t}\n\n\t\treturn this.root;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { isLinux, isMacintosh, isWindows } from '../../../../base/common/platform.js';\nimport { ConfiguredInput } from './configurationResolver.js';\n\n/** A replacement found in the object, as ${name} or ${name:arg} */\nexport type Replacement = {\n\t/** ${name:arg} */\n\tid: string;\n\t/** The `name:arg` in ${name:arg} */\n\tinner: string;\n\t/** The `name` in ${name:arg} */\n\tname: string;\n\t/** The `arg` in ${name:arg} */\n\targ?: string;\n};\n\ninterface IConfigurationResolverExpression<T> {\n\t/**\n\t * Gets the replacements which have not yet been\n\t * resolved.\n\t */\n\tunresolved(): Iterable<Replacement>;\n\n\t/**\n\t * Gets the replacements which have been resolved.\n\t */\n\tresolved(): Iterable<[Replacement, IResolvedValue]>;\n\n\t/**\n\t * Resolves a replacement into the string value.\n\t * If the value is undefined, the original variable text will be preserved.\n\t */\n\tresolve(replacement: Replacement, data: string | IResolvedValue): void;\n\n\t/**\n\t * Returns the complete object. Any unresolved replacements are left intact.\n\t */\n\ttoObject(): T;\n}\n\ntype PropertyLocation = {\n\tobject: any;\n\tpropertyName: string | number;\n\treplaceKeyName?: boolean;\n};\n\nexport interface IResolvedValue {\n\tvalue: string | undefined;\n\n\t/** Present when the variable is resolved from an input field. */\n\tinput?: ConfiguredInput;\n}\n\ninterface IReplacementLocation {\n\treplacement: Replacement;\n\tlocations: PropertyLocation[];\n\tresolved?: IResolvedValue;\n}\n\nexport class ConfigurationResolverExpression<T> implements IConfigurationResolverExpression<T> {\n\tpublic static readonly VARIABLE_LHS = '${';\n\n\tprivate readonly locations = new Map<string, IReplacementLocation>();\n\tprivate root: T;\n\tprivate stringRoot: boolean;\n\t/**\n\t * Callbacks when a new replacement is made, so that nested resolutions from\n\t * `expr.unresolved()` can be fulfilled in the same iteration.\n\t */\n\tprivate newReplacementNotifiers = new Set<(r: Replacement) => void>();\n\n\tprivate constructor(object: T) {\n\t\t// If the input is a string, wrap it in an object so we can use the same logic\n\t\tif (typeof object === 'string') {\n\t\t\tthis.stringRoot = true;\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tthis.root = { value: object } as any;\n\t\t} else {\n\t\t\tthis.stringRoot = false;\n\t\t\tthis.root = structuredClone(object);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new {@link ConfigurationResolverExpression} from an object.\n\t * Note that platform-specific keys (i.e. `windows`, `osx`, `linux`) are\n\t * applied during parsing.\n\t */\n\tpublic static parse<T>(object: T): ConfigurationResolverExpression<T> {\n\t\tif (object instanceof ConfigurationResolverExpression) {\n\t\t\treturn object;\n\t\t}\n\n\t\tconst expr = new ConfigurationResolverExpression<T>(object);\n\t\texpr.applyPlatformSpecificKeys();\n\t\texpr.parseObject(expr.root);\n\t\treturn expr;\n\t}\n\n\tprivate applyPlatformSpecificKeys() {\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tconst config = this.root as any; // already cloned by ctor, safe to change\n\t\tconst key = isWindows ? 'windows' : isMacintosh ? 'osx' : isLinux ? 'linux' : undefined;\n\n\t\tif (key && config && typeof config === 'object' && config.hasOwnProperty(key)) {\n\t\t\tObject.keys(config[key]).forEach(k => config[k] = config[key][k]);\n\t\t}\n\n\t\tdelete config.windows;\n\t\tdelete config.osx;\n\t\tdelete config.linux;\n\t}\n\n\tprivate parseVariable(str: string, start: number): { replacement: Replacement; end: number } | undefined {\n\t\tif (str[start] !== '$' || str[start + 1] !== '{') {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet end = start + 2;\n\t\tlet braceCount = 1;\n\t\twhile (end < str.length) {\n\t\t\tif (str[end] === '{') {\n\t\t\t\tbraceCount++;\n\t\t\t} else if (str[end] === '}') {\n\t\t\t\tbraceCount--;\n\t\t\t\tif (braceCount === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tend++;\n\t\t}\n\n\t\tif (braceCount !== 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst id = str.slice(start, end + 1);\n\t\tconst inner = str.substring(start + 2, end);\n\t\tconst colonIdx = inner.indexOf(':');\n\t\tif (colonIdx === -1) {\n\t\t\treturn { replacement: { id, name: inner, inner }, end };\n\t\t}\n\n\t\treturn {\n\t\t\treplacement: {\n\t\t\t\tid,\n\t\t\t\tinner,\n\t\t\t\tname: inner.slice(0, colonIdx),\n\t\t\t\targ: inner.slice(colonIdx + 1)\n\t\t\t},\n\t\t\tend\n\t\t};\n\t}\n\n\tprivate parseObject(obj: any): void {\n\t\tif (typeof obj !== 'object' || obj === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (Array.isArray(obj)) {\n\t\t\tfor (let i = 0; i < obj.length; i++) {\n\t\t\t\tconst value = obj[i];\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tthis.parseString(obj, i, value);\n\t\t\t\t} else {\n\t\t\t\t\tthis.parseObject(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\tthis.parseString(obj, key, key, true); // parse key\n\n\t\t\tif (typeof value === 'string') {\n\t\t\t\tthis.parseString(obj, key, value);\n\t\t\t} else {\n\t\t\t\tthis.parseObject(value);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate parseString(object: any, propertyName: string | number, value: string, replaceKeyName?: boolean, replacementPath?: string[]): void {\n\t\tlet pos = 0;\n\t\twhile (pos < value.length) {\n\t\t\tconst match = value.indexOf('${', pos);\n\t\t\tif (match === -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst parsed = this.parseVariable(value, match);\n\t\t\tif (parsed) {\n\t\t\t\tpos = parsed.end + 1;\n\t\t\t\tif (replacementPath?.includes(parsed.replacement.id)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst locations = this.locations.get(parsed.replacement.id) || { locations: [], replacement: parsed.replacement };\n\t\t\t\tconst newLocation: PropertyLocation = { object, propertyName, replaceKeyName };\n\t\t\t\tlocations.locations.push(newLocation);\n\t\t\t\tthis.locations.set(parsed.replacement.id, locations);\n\n\t\t\t\tif (locations.resolved) {\n\t\t\t\t\tthis._resolveAtLocation(parsed.replacement, newLocation, locations.resolved, replacementPath);\n\t\t\t\t} else {\n\t\t\t\t\tthis.newReplacementNotifiers.forEach(n => n(parsed.replacement));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpos = match + 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic *unresolved(): Iterable<Replacement> {\n\t\tconst newReplacements = new Map<string, Replacement>();\n\t\tconst notifier = (replacement: Replacement) => {\n\t\t\tnewReplacements.set(replacement.id, replacement);\n\t\t};\n\n\t\tfor (const location of this.locations.values()) {\n\t\t\tif (location.resolved === undefined) {\n\t\t\t\tnewReplacements.set(location.replacement.id, location.replacement);\n\t\t\t}\n\t\t}\n\n\t\tthis.newReplacementNotifiers.add(notifier);\n\n\t\twhile (true) {\n\t\t\tconst next = Iterable.first(newReplacements);\n\t\t\tif (!next) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst [key, value] = next;\n\t\t\tyield value;\n\t\t\tnewReplacements.delete(key);\n\t\t}\n\n\t\tthis.newReplacementNotifiers.delete(notifier);\n\t}\n\n\tpublic resolved(): Iterable<[Replacement, IResolvedValue]> {\n\t\treturn Iterable.map(Iterable.filter(this.locations.values(), l => !!l.resolved), l => [l.replacement, l.resolved!]);\n\t}\n\n\tpublic resolve(replacement: Replacement, data: string | IResolvedValue): void {\n\t\tif (typeof data !== 'object') {\n\t\t\tdata = { value: String(data) };\n\t\t}\n\n\t\tconst location = this.locations.get(replacement.id);\n\t\tif (!location) {\n\t\t\treturn;\n\t\t}\n\n\t\tlocation.resolved = data;\n\n\t\tif (data.value !== undefined) {\n\t\t\tfor (const l of location.locations || Iterable.empty()) {\n\t\t\t\tthis._resolveAtLocation(replacement, l, data);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _resolveAtLocation(replacement: Replacement, { replaceKeyName, propertyName, object }: PropertyLocation, data: IResolvedValue, path: string[] = []) {\n\t\tif (data.value === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// avoid recursive resolution, e.g. ${env:FOO} -> ${env:BAR}=${env:FOO}\n\t\tpath.push(replacement.id);\n\n\t\t// note: in nested `this.parseString`, parse only the new substring for any replacements, don't reparse the whole string\n\t\tif (replaceKeyName && typeof propertyName === 'string') {\n\t\t\tconst value = object[propertyName];\n\t\t\tconst newKey = propertyName.replaceAll(replacement.id, data.value);\n\t\t\tdelete object[propertyName];\n\t\t\tobject[newKey] = value;\n\t\t\tthis._renameKeyInLocations(object, propertyName, newKey);\n\t\t\tthis.parseString(object, newKey, data.value, true, path);\n\t\t} else {\n\t\t\tobject[propertyName] = object[propertyName].replaceAll(replacement.id, data.value);\n\t\t\tthis.parseString(object, propertyName, data.value, false, path);\n\t\t}\n\n\t\tpath.pop();\n\t}\n\n\tprivate _renameKeyInLocations(obj: object, oldKey: string, newKey: string) {\n\t\tfor (const location of this.locations.values()) {\n\t\t\tfor (const loc of location.locations) {\n\t\t\t\tif (loc.object === obj && loc.propertyName === oldKey) {\n\t\t\t\t\tloc.propertyName = newKey;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic toObject(): T {\n\t\t// If we wrapped a string, unwrap it\n\t\tif (this.stringRoot) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\treturn (this.root as any).value as T;\n\t\t}\n\n\t\treturn this.root;\n\t}\n}\n"]}