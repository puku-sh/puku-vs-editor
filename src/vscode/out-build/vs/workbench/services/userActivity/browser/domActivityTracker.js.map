{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/userActivity/browser/domActivityTracker.ts","vs/workbench/services/userActivity/browser/domActivityTracker.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,KAAK,GAAG,MAAM,iCAAiC,CAAC;AACvD,OAAO,EAAE,UAAU,EAAE,MAAM,oCAAoC,CAAC;AAChE,OAAO,EAAE,KAAK,EAAE,MAAM,kCAAkC,CAAC;AACzD,OAAO,EAAE,UAAU,EAAE,iBAAiB,EAAE,MAAM,sCAAsC,CAAC;AAGrF;;;;;;;;;GASG;AACH,MAAM,cAAc,GAAG,MAAM,CAAC;AAE9B,iCAAiC;AACjC,MAAM,8BAA8B,GAAG,CAAC,CAAC;AAEzC,MAAM,oBAAoB,GAA4B;IACrD,OAAO,EAAE,IAAI,EAAE,gCAAgC;IAC/C,OAAO,EAAE,IAAI,EAAE,8DAA8D;CAC7E,CAAC;AAEF,MAAM,OAAO,kBAAmB,SAAQ,UAAU;IACjD,YAAY,mBAAyC;QACpD,KAAK,EAAE,CAAC;QAER,IAAI,wBAAwB,GAAG,8BAA8B,CAAC;QAC9D,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,CAAC,mBAAmB,EAAE,CAAC,CAAC;QACpE,MAAM,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,iBAAiB,EAAE,CAAC,CAAC;QAC5D,WAAW,CAAC,KAAK,GAAG,mBAAmB,CAAC,UAAU,EAAE,CAAC;QAErD,MAAM,UAAU,GAAG,GAAG,EAAE;YACvB,IAAI,EAAE,wBAAwB,KAAK,8BAA8B,EAAE,CAAC;gBACnE,WAAW,CAAC,KAAK,EAAE,CAAC;gBACpB,aAAa,CAAC,MAAM,EAAE,CAAC;YACxB,CAAC;QACF,CAAC,CAAC;QAEF,MAAM,UAAU,GAAG,CAAC,YAAwC,EAAE,EAAE;YAC/D,wCAAwC;YACxC,IAAI,wBAAwB,KAAK,8BAA8B,EAAE,CAAC;gBACjE,WAAW,CAAC,KAAK,GAAG,mBAAmB,CAAC,UAAU,EAAE,CAAC;gBACrD,aAAa,CAAC,YAAY,CAAC,UAAU,EAAE,cAAc,EAAE,YAAY,CAAC,CAAC;YACtE,CAAC;YAED,wBAAwB,GAAG,CAAC,CAAC;QAC9B,CAAC,CAAC;QAEF,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,eAAe,CAAC,GAAG,CAAC,mBAAmB,EAAE,CAAC,EAAE,MAAM,EAAE,WAAW,EAAE,EAAE,EAAE;YACzF,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,qBAAqB,CAAC,MAAM,CAAC,QAAQ,EAAE,YAAY,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,oBAAoB,CAAC,CAAC,CAAC;YAC1H,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,qBAAqB,CAAC,MAAM,CAAC,QAAQ,EAAE,WAAW,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,oBAAoB,CAAC,CAAC,CAAC;YACzH,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,qBAAqB,CAAC,MAAM,CAAC,QAAQ,EAAE,SAAS,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,oBAAoB,CAAC,CAAC,CAAC;QACxH,CAAC,EAAE,EAAE,MAAM,EAAE,UAAU,EAAE,WAAW,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QAEtD,UAAU,CAAC,UAAU,CAAC,CAAC;IACxB,CAAC;CACD","file":"domActivityTracker.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as dom from '../../../../base/browser/dom.js';\nimport { mainWindow } from '../../../../base/browser/window.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { IUserActivityService } from '../common/userActivityService.js';\n\n/**\n * This uses a time interval and checks whether there's any activity in that\n * interval. A naive approach might be to use a debounce whenever an event\n * happens, but this has some scheduling overhead. Instead, the tracker counts\n * how many intervals have elapsed since any activity happened.\n *\n * If there's more than `MIN_INTERVALS_WITHOUT_ACTIVITY`, then say the user is\n * inactive. Therefore the maximum time before an inactive user is detected\n * is `CHECK_INTERVAL * (MIN_INTERVALS_WITHOUT_ACTIVITY + 1)`.\n */\nconst CHECK_INTERVAL = 30_000;\n\n/** See {@link CHECK_INTERVAL} */\nconst MIN_INTERVALS_WITHOUT_ACTIVITY = 2;\n\nconst eventListenerOptions: AddEventListenerOptions = {\n\tpassive: true, /** does not preventDefault() */\n\tcapture: true, /** should dispatch first (before anyone stopPropagation()) */\n};\n\nexport class DomActivityTracker extends Disposable {\n\tconstructor(userActivityService: IUserActivityService) {\n\t\tsuper();\n\n\t\tlet intervalsWithoutActivity = MIN_INTERVALS_WITHOUT_ACTIVITY;\n\t\tconst intervalTimer = this._register(new dom.WindowIntervalTimer());\n\t\tconst activeMutex = this._register(new MutableDisposable());\n\t\tactiveMutex.value = userActivityService.markActive();\n\n\t\tconst onInterval = () => {\n\t\t\tif (++intervalsWithoutActivity === MIN_INTERVALS_WITHOUT_ACTIVITY) {\n\t\t\t\tactiveMutex.clear();\n\t\t\t\tintervalTimer.cancel();\n\t\t\t}\n\t\t};\n\n\t\tconst onActivity = (targetWindow: Window & typeof globalThis) => {\n\t\t\t// if was inactive, they've now returned\n\t\t\tif (intervalsWithoutActivity === MIN_INTERVALS_WITHOUT_ACTIVITY) {\n\t\t\t\tactiveMutex.value = userActivityService.markActive();\n\t\t\t\tintervalTimer.cancelAndSet(onInterval, CHECK_INTERVAL, targetWindow);\n\t\t\t}\n\n\t\t\tintervalsWithoutActivity = 0;\n\t\t};\n\n\t\tthis._register(Event.runAndSubscribe(dom.onDidRegisterWindow, ({ window, disposables }) => {\n\t\t\tdisposables.add(dom.addDisposableListener(window.document, 'touchstart', () => onActivity(window), eventListenerOptions));\n\t\t\tdisposables.add(dom.addDisposableListener(window.document, 'mousedown', () => onActivity(window), eventListenerOptions));\n\t\t\tdisposables.add(dom.addDisposableListener(window.document, 'keydown', () => onActivity(window), eventListenerOptions));\n\t\t}, { window: mainWindow, disposables: this._store }));\n\n\t\tonActivity(mainWindow);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as dom from '../../../../base/browser/dom.js';\nimport { mainWindow } from '../../../../base/browser/window.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { IUserActivityService } from '../common/userActivityService.js';\n\n/**\n * This uses a time interval and checks whether there's any activity in that\n * interval. A naive approach might be to use a debounce whenever an event\n * happens, but this has some scheduling overhead. Instead, the tracker counts\n * how many intervals have elapsed since any activity happened.\n *\n * If there's more than `MIN_INTERVALS_WITHOUT_ACTIVITY`, then say the user is\n * inactive. Therefore the maximum time before an inactive user is detected\n * is `CHECK_INTERVAL * (MIN_INTERVALS_WITHOUT_ACTIVITY + 1)`.\n */\nconst CHECK_INTERVAL = 30_000;\n\n/** See {@link CHECK_INTERVAL} */\nconst MIN_INTERVALS_WITHOUT_ACTIVITY = 2;\n\nconst eventListenerOptions: AddEventListenerOptions = {\n\tpassive: true, /** does not preventDefault() */\n\tcapture: true, /** should dispatch first (before anyone stopPropagation()) */\n};\n\nexport class DomActivityTracker extends Disposable {\n\tconstructor(userActivityService: IUserActivityService) {\n\t\tsuper();\n\n\t\tlet intervalsWithoutActivity = MIN_INTERVALS_WITHOUT_ACTIVITY;\n\t\tconst intervalTimer = this._register(new dom.WindowIntervalTimer());\n\t\tconst activeMutex = this._register(new MutableDisposable());\n\t\tactiveMutex.value = userActivityService.markActive();\n\n\t\tconst onInterval = () => {\n\t\t\tif (++intervalsWithoutActivity === MIN_INTERVALS_WITHOUT_ACTIVITY) {\n\t\t\t\tactiveMutex.clear();\n\t\t\t\tintervalTimer.cancel();\n\t\t\t}\n\t\t};\n\n\t\tconst onActivity = (targetWindow: Window & typeof globalThis) => {\n\t\t\t// if was inactive, they've now returned\n\t\t\tif (intervalsWithoutActivity === MIN_INTERVALS_WITHOUT_ACTIVITY) {\n\t\t\t\tactiveMutex.value = userActivityService.markActive();\n\t\t\t\tintervalTimer.cancelAndSet(onInterval, CHECK_INTERVAL, targetWindow);\n\t\t\t}\n\n\t\t\tintervalsWithoutActivity = 0;\n\t\t};\n\n\t\tthis._register(Event.runAndSubscribe(dom.onDidRegisterWindow, ({ window, disposables }) => {\n\t\t\tdisposables.add(dom.addDisposableListener(window.document, 'touchstart', () => onActivity(window), eventListenerOptions));\n\t\t\tdisposables.add(dom.addDisposableListener(window.document, 'mousedown', () => onActivity(window), eventListenerOptions));\n\t\t\tdisposables.add(dom.addDisposableListener(window.document, 'keydown', () => onActivity(window), eventListenerOptions));\n\t\t}, { window: mainWindow, disposables: this._store }));\n\n\t\tonActivity(mainWindow);\n\t}\n}\n"]}