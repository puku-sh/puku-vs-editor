{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/path/common/pathService.ts","vs/workbench/services/path/common/pathService.ts"],"names":[],"mappings":"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","file":"pathService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isValidBasename } from '../../../../base/common/extpath.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { IPath, win32, posix } from '../../../../base/common/path.js';\nimport { OperatingSystem, OS } from '../../../../base/common/platform.js';\nimport { basename } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { getVirtualWorkspaceScheme } from '../../../../platform/workspace/common/virtualWorkspace.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { IWorkbenchEnvironmentService } from '../../environment/common/environmentService.js';\nimport { IRemoteAgentService } from '../../remote/common/remoteAgentService.js';\n\nexport const IPathService = createDecorator<IPathService>('pathService');\n\n/**\n * Provides access to path related properties that will match the\n * environment. If the environment is connected to a remote, the\n * path properties will match that of the remotes operating system.\n */\nexport interface IPathService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * The correct path library to use for the target environment. If\n\t * the environment is connected to a remote, this will be the\n\t * path library of the remote file system. Otherwise it will be\n\t * the local file system's path library depending on the OS.\n\t */\n\treadonly path: Promise<IPath>;\n\n\t/**\n\t * Determines the best default URI scheme for the current workspace.\n\t * It uses information about whether we're running remote, in browser,\n\t * or native combined with information about the current workspace to\n\t * find the best default scheme.\n\t */\n\treadonly defaultUriScheme: string;\n\n\t/**\n\t * Converts the given path to a file URI to use for the target\n\t * environment. If the environment is connected to a remote, it\n\t * will use the path separators according to the remote file\n\t * system. Otherwise it will use the local file system's path\n\t * separators.\n\t */\n\tfileURI(path: string): Promise<URI>;\n\n\t/**\n\t * Resolves the user-home directory for the target environment.\n\t * If the envrionment is connected to a remote, this will be the\n\t * remote's user home directory, otherwise the local one unless\n\t * `preferLocal` is set to `true`.\n\t */\n\tuserHome(options: { preferLocal: true }): URI;\n\tuserHome(options?: { preferLocal: boolean }): Promise<URI>;\n\n\t/**\n\t * Figures out if the provided resource has a valid file name\n\t * for the operating system the file is saved to.\n\t *\n\t * Note: this currently only supports `file` and `vscode-file`\n\t * protocols where we know the limits of the file systems behind\n\t * these OS. Other remotes are not supported and this method\n\t * will always return `true` for them.\n\t */\n\thasValidBasename(resource: URI, basename?: string): Promise<boolean>;\n\thasValidBasename(resource: URI, os: OperatingSystem, basename?: string): boolean;\n\n\t/**\n\t * @deprecated use `userHome` instead.\n\t */\n\treadonly resolvedUserHome: URI | undefined;\n}\n\nexport abstract class AbstractPathService implements IPathService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate resolveOS: Promise<OperatingSystem>;\n\n\tprivate resolveUserHome: Promise<URI>;\n\tprivate maybeUnresolvedUserHome: URI | undefined;\n\n\tconstructor(\n\t\tprivate localUserHome: URI,\n\t\t@IRemoteAgentService private readonly remoteAgentService: IRemoteAgentService,\n\t\t@IWorkbenchEnvironmentService private readonly environmentService: IWorkbenchEnvironmentService,\n\t\t@IWorkspaceContextService private contextService: IWorkspaceContextService\n\t) {\n\n\t\t// OS\n\t\tthis.resolveOS = (async () => {\n\t\t\tconst env = await this.remoteAgentService.getEnvironment();\n\n\t\t\treturn env?.os || OS;\n\t\t})();\n\n\t\t// User Home\n\t\tthis.resolveUserHome = (async () => {\n\t\t\tconst env = await this.remoteAgentService.getEnvironment();\n\t\t\tconst userHome = this.maybeUnresolvedUserHome = env?.userHome ?? localUserHome;\n\n\t\t\treturn userHome;\n\t\t})();\n\t}\n\n\thasValidBasename(resource: URI, basename?: string): Promise<boolean>;\n\thasValidBasename(resource: URI, os: OperatingSystem, basename?: string): boolean;\n\thasValidBasename(resource: URI, arg2?: string | OperatingSystem, basename?: string): boolean | Promise<boolean> {\n\n\t\t// async version\n\t\tif (typeof arg2 === 'string' || typeof arg2 === 'undefined') {\n\t\t\treturn this.resolveOS.then(os => this.doHasValidBasename(resource, os, arg2));\n\t\t}\n\n\t\t// sync version\n\t\treturn this.doHasValidBasename(resource, arg2, basename);\n\t}\n\n\tprivate doHasValidBasename(resource: URI, os: OperatingSystem, name?: string): boolean {\n\n\t\t// Our `isValidBasename` method only works with our\n\t\t// standard schemes for files on disk, either locally\n\t\t// or remote.\n\t\tif (resource.scheme === Schemas.file || resource.scheme === Schemas.vscodeRemote) {\n\t\t\treturn isValidBasename(name ?? basename(resource), os === OperatingSystem.Windows);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget defaultUriScheme(): string {\n\t\treturn AbstractPathService.findDefaultUriScheme(this.environmentService, this.contextService);\n\t}\n\n\tstatic findDefaultUriScheme(environmentService: IWorkbenchEnvironmentService, contextService: IWorkspaceContextService): string {\n\t\tif (environmentService.remoteAuthority) {\n\t\t\treturn Schemas.vscodeRemote;\n\t\t}\n\n\t\tconst virtualWorkspace = getVirtualWorkspaceScheme(contextService.getWorkspace());\n\t\tif (virtualWorkspace) {\n\t\t\treturn virtualWorkspace;\n\t\t}\n\n\t\tconst firstFolder = contextService.getWorkspace().folders[0];\n\t\tif (firstFolder) {\n\t\t\treturn firstFolder.uri.scheme;\n\t\t}\n\n\t\tconst configuration = contextService.getWorkspace().configuration;\n\t\tif (configuration) {\n\t\t\treturn configuration.scheme;\n\t\t}\n\n\t\treturn Schemas.file;\n\t}\n\n\tuserHome(options?: { preferLocal: boolean }): Promise<URI>;\n\tuserHome(options: { preferLocal: true }): URI;\n\tuserHome(options?: { preferLocal: boolean }): Promise<URI> | URI {\n\t\treturn options?.preferLocal ? this.localUserHome : this.resolveUserHome;\n\t}\n\n\tget resolvedUserHome(): URI | undefined {\n\t\treturn this.maybeUnresolvedUserHome;\n\t}\n\n\tget path(): Promise<IPath> {\n\t\treturn this.resolveOS.then(os => {\n\t\t\treturn os === OperatingSystem.Windows ?\n\t\t\t\twin32 :\n\t\t\t\tposix;\n\t\t});\n\t}\n\n\tasync fileURI(_path: string): Promise<URI> {\n\t\tlet authority = '';\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tconst os = await this.resolveOS;\n\t\tif (os === OperatingSystem.Windows) {\n\t\t\t_path = _path.replace(/\\\\/g, '/');\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (_path[0] === '/' && _path[1] === '/') {\n\t\t\tconst idx = _path.indexOf('/', 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = _path.substring(2);\n\t\t\t\t_path = '/';\n\t\t\t} else {\n\t\t\t\tauthority = _path.substring(2, idx);\n\t\t\t\t_path = _path.substring(idx) || '/';\n\t\t\t}\n\t\t}\n\n\t\treturn URI.from({\n\t\t\tscheme: Schemas.file,\n\t\t\tauthority,\n\t\t\tpath: _path,\n\t\t\tquery: '',\n\t\t\tfragment: ''\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isValidBasename } from '../../../../base/common/extpath.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { IPath, win32, posix } from '../../../../base/common/path.js';\nimport { OperatingSystem, OS } from '../../../../base/common/platform.js';\nimport { basename } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { getVirtualWorkspaceScheme } from '../../../../platform/workspace/common/virtualWorkspace.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { IWorkbenchEnvironmentService } from '../../environment/common/environmentService.js';\nimport { IRemoteAgentService } from '../../remote/common/remoteAgentService.js';\n\nexport const IPathService = createDecorator<IPathService>('pathService');\n\n/**\n * Provides access to path related properties that will match the\n * environment. If the environment is connected to a remote, the\n * path properties will match that of the remotes operating system.\n */\nexport interface IPathService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * The correct path library to use for the target environment. If\n\t * the environment is connected to a remote, this will be the\n\t * path library of the remote file system. Otherwise it will be\n\t * the local file system's path library depending on the OS.\n\t */\n\treadonly path: Promise<IPath>;\n\n\t/**\n\t * Determines the best default URI scheme for the current workspace.\n\t * It uses information about whether we're running remote, in browser,\n\t * or native combined with information about the current workspace to\n\t * find the best default scheme.\n\t */\n\treadonly defaultUriScheme: string;\n\n\t/**\n\t * Converts the given path to a file URI to use for the target\n\t * environment. If the environment is connected to a remote, it\n\t * will use the path separators according to the remote file\n\t * system. Otherwise it will use the local file system's path\n\t * separators.\n\t */\n\tfileURI(path: string): Promise<URI>;\n\n\t/**\n\t * Resolves the user-home directory for the target environment.\n\t * If the envrionment is connected to a remote, this will be the\n\t * remote's user home directory, otherwise the local one unless\n\t * `preferLocal` is set to `true`.\n\t */\n\tuserHome(options: { preferLocal: true }): URI;\n\tuserHome(options?: { preferLocal: boolean }): Promise<URI>;\n\n\t/**\n\t * Figures out if the provided resource has a valid file name\n\t * for the operating system the file is saved to.\n\t *\n\t * Note: this currently only supports `file` and `vscode-file`\n\t * protocols where we know the limits of the file systems behind\n\t * these OS. Other remotes are not supported and this method\n\t * will always return `true` for them.\n\t */\n\thasValidBasename(resource: URI, basename?: string): Promise<boolean>;\n\thasValidBasename(resource: URI, os: OperatingSystem, basename?: string): boolean;\n\n\t/**\n\t * @deprecated use `userHome` instead.\n\t */\n\treadonly resolvedUserHome: URI | undefined;\n}\n\nexport abstract class AbstractPathService implements IPathService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate resolveOS: Promise<OperatingSystem>;\n\n\tprivate resolveUserHome: Promise<URI>;\n\tprivate maybeUnresolvedUserHome: URI | undefined;\n\n\tconstructor(\n\t\tprivate localUserHome: URI,\n\t\t@IRemoteAgentService private readonly remoteAgentService: IRemoteAgentService,\n\t\t@IWorkbenchEnvironmentService private readonly environmentService: IWorkbenchEnvironmentService,\n\t\t@IWorkspaceContextService private contextService: IWorkspaceContextService\n\t) {\n\n\t\t// OS\n\t\tthis.resolveOS = (async () => {\n\t\t\tconst env = await this.remoteAgentService.getEnvironment();\n\n\t\t\treturn env?.os || OS;\n\t\t})();\n\n\t\t// User Home\n\t\tthis.resolveUserHome = (async () => {\n\t\t\tconst env = await this.remoteAgentService.getEnvironment();\n\t\t\tconst userHome = this.maybeUnresolvedUserHome = env?.userHome ?? localUserHome;\n\n\t\t\treturn userHome;\n\t\t})();\n\t}\n\n\thasValidBasename(resource: URI, basename?: string): Promise<boolean>;\n\thasValidBasename(resource: URI, os: OperatingSystem, basename?: string): boolean;\n\thasValidBasename(resource: URI, arg2?: string | OperatingSystem, basename?: string): boolean | Promise<boolean> {\n\n\t\t// async version\n\t\tif (typeof arg2 === 'string' || typeof arg2 === 'undefined') {\n\t\t\treturn this.resolveOS.then(os => this.doHasValidBasename(resource, os, arg2));\n\t\t}\n\n\t\t// sync version\n\t\treturn this.doHasValidBasename(resource, arg2, basename);\n\t}\n\n\tprivate doHasValidBasename(resource: URI, os: OperatingSystem, name?: string): boolean {\n\n\t\t// Our `isValidBasename` method only works with our\n\t\t// standard schemes for files on disk, either locally\n\t\t// or remote.\n\t\tif (resource.scheme === Schemas.file || resource.scheme === Schemas.vscodeRemote) {\n\t\t\treturn isValidBasename(name ?? basename(resource), os === OperatingSystem.Windows);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget defaultUriScheme(): string {\n\t\treturn AbstractPathService.findDefaultUriScheme(this.environmentService, this.contextService);\n\t}\n\n\tstatic findDefaultUriScheme(environmentService: IWorkbenchEnvironmentService, contextService: IWorkspaceContextService): string {\n\t\tif (environmentService.remoteAuthority) {\n\t\t\treturn Schemas.vscodeRemote;\n\t\t}\n\n\t\tconst virtualWorkspace = getVirtualWorkspaceScheme(contextService.getWorkspace());\n\t\tif (virtualWorkspace) {\n\t\t\treturn virtualWorkspace;\n\t\t}\n\n\t\tconst firstFolder = contextService.getWorkspace().folders[0];\n\t\tif (firstFolder) {\n\t\t\treturn firstFolder.uri.scheme;\n\t\t}\n\n\t\tconst configuration = contextService.getWorkspace().configuration;\n\t\tif (configuration) {\n\t\t\treturn configuration.scheme;\n\t\t}\n\n\t\treturn Schemas.file;\n\t}\n\n\tuserHome(options?: { preferLocal: boolean }): Promise<URI>;\n\tuserHome(options: { preferLocal: true }): URI;\n\tuserHome(options?: { preferLocal: boolean }): Promise<URI> | URI {\n\t\treturn options?.preferLocal ? this.localUserHome : this.resolveUserHome;\n\t}\n\n\tget resolvedUserHome(): URI | undefined {\n\t\treturn this.maybeUnresolvedUserHome;\n\t}\n\n\tget path(): Promise<IPath> {\n\t\treturn this.resolveOS.then(os => {\n\t\t\treturn os === OperatingSystem.Windows ?\n\t\t\t\twin32 :\n\t\t\t\tposix;\n\t\t});\n\t}\n\n\tasync fileURI(_path: string): Promise<URI> {\n\t\tlet authority = '';\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tconst os = await this.resolveOS;\n\t\tif (os === OperatingSystem.Windows) {\n\t\t\t_path = _path.replace(/\\\\/g, '/');\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (_path[0] === '/' && _path[1] === '/') {\n\t\t\tconst idx = _path.indexOf('/', 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = _path.substring(2);\n\t\t\t\t_path = '/';\n\t\t\t} else {\n\t\t\t\tauthority = _path.substring(2, idx);\n\t\t\t\t_path = _path.substring(idx) || '/';\n\t\t\t}\n\t\t}\n\n\t\treturn URI.from({\n\t\t\tscheme: Schemas.file,\n\t\t\tauthority,\n\t\t\tpath: _path,\n\t\t\tquery: '',\n\t\t\tfragment: ''\n\t\t});\n\t}\n}\n"]}