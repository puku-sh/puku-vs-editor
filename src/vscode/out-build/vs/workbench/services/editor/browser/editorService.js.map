{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/editor/browser/editorService.ts","vs/workbench/services/editor/browser/editorService.ts"],"names":[],"mappings":"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","file":"editorService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IResourceEditorInput, IEditorOptions, EditorActivation, IResourceEditorInputIdentifier, ITextResourceEditorInput } from '../../../../platform/editor/common/editor.js';\nimport { SideBySideEditor, IEditorPane, GroupIdentifier, IUntitledTextResourceEditorInput, IResourceDiffEditorInput, EditorInputWithOptions, isEditorInputWithOptions, IEditorIdentifier, IEditorCloseEvent, ITextDiffEditorPane, IRevertOptions, SaveReason, EditorsOrder, IWorkbenchEditorConfiguration, EditorResourceAccessor, IVisibleEditorPane, EditorInputCapabilities, isResourceDiffEditorInput, IUntypedEditorInput, isResourceEditorInput, isEditorInput, isEditorInputWithOptionsAndGroup, IFindEditorOptions, isResourceMergeEditorInput, IEditorWillOpenEvent, IEditorControl, ITextResourceDiffEditorInput } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { SideBySideEditorInput } from '../../../common/editor/sideBySideEditorInput.js';\nimport { ResourceMap, ResourceSet } from '../../../../base/common/map.js';\nimport { IFileService, FileOperationEvent, FileOperation, FileChangesEvent, FileChangeType } from '../../../../platform/files/common/files.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { joinPath } from '../../../../base/common/resources.js';\nimport { DiffEditorInput } from '../../../common/editor/diffEditorInput.js';\nimport { SideBySideEditor as SideBySideEditorPane } from '../../../browser/parts/editor/sideBySideEditor.js';\nimport { IEditorGroupsService, IEditorGroup, GroupsOrder, IEditorReplacement, isEditorReplacement, ICloseEditorOptions, IEditorGroupsContainer } from '../common/editorGroupsService.js';\nimport { IUntypedEditorReplacement, IEditorService, ISaveEditorsOptions, ISaveAllEditorsOptions, IRevertAllEditorsOptions, IBaseSaveRevertAllEditorOptions, IOpenEditorsOptions, PreferredGroup, isPreferredGroup, IEditorsChangeEvent, ISaveEditorsResult } from '../common/editorService.js';\nimport { IConfigurationChangeEvent, IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { Disposable, IDisposable, dispose, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { coalesce, distinct } from '../../../../base/common/arrays.js';\nimport { isCodeEditor, isDiffEditor, ICodeEditor, IDiffEditor, isCompositeEditor } from '../../../../editor/browser/editorBrowser.js';\nimport { IEditorGroupView, EditorServiceImpl } from '../../../browser/parts/editor/editor.js';\nimport { registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { isUndefined } from '../../../../base/common/types.js';\nimport { EditorsObserver } from '../../../browser/parts/editor/editorsObserver.js';\nimport { Promises, timeout } from '../../../../base/common/async.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { indexOfPath } from '../../../../base/common/extpath.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IEditorResolverService, ResolvedStatus } from '../common/editorResolverService.js';\nimport { IWorkspaceTrustRequestService, WorkspaceTrustUriResponse } from '../../../../platform/workspace/common/workspaceTrust.js';\nimport { IHostService } from '../../host/browser/host.js';\nimport { findGroup } from '../common/editorGroupFinder.js';\nimport { ITextEditorService } from '../../textfile/common/textEditorService.js';\nimport { SyncDescriptor } from '../../../../platform/instantiation/common/descriptors.js';\n\nexport class EditorService extends Disposable implements EditorServiceImpl {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region events\n\n\tprivate readonly _onDidActiveEditorChange = this._register(new Emitter<void>());\n\treadonly onDidActiveEditorChange = this._onDidActiveEditorChange.event;\n\n\tprivate readonly _onDidVisibleEditorsChange = this._register(new Emitter<void>());\n\treadonly onDidVisibleEditorsChange = this._onDidVisibleEditorsChange.event;\n\n\tprivate readonly _onDidEditorsChange = this._register(new Emitter<IEditorsChangeEvent>());\n\treadonly onDidEditorsChange = this._onDidEditorsChange.event;\n\n\tprivate readonly _onWillOpenEditor = this._register(new Emitter<IEditorWillOpenEvent>());\n\treadonly onWillOpenEditor = this._onWillOpenEditor.event;\n\n\tprivate readonly _onDidCloseEditor = this._register(new Emitter<IEditorCloseEvent>());\n\treadonly onDidCloseEditor = this._onDidCloseEditor.event;\n\n\tprivate readonly _onDidOpenEditorFail = this._register(new Emitter<IEditorIdentifier>());\n\treadonly onDidOpenEditorFail = this._onDidOpenEditorFail.event;\n\n\tprivate readonly _onDidMostRecentlyActiveEditorsChange = this._register(new Emitter<void>());\n\treadonly onDidMostRecentlyActiveEditorsChange = this._onDidMostRecentlyActiveEditorsChange.event;\n\n\t//#endregion\n\n\tprivate readonly editorGroupsContainer: IEditorGroupsContainer;\n\n\tconstructor(\n\t\teditorGroupsContainer: IEditorGroupsContainer | undefined,\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@IEditorResolverService private readonly editorResolverService: IEditorResolverService,\n\t\t@IWorkspaceTrustRequestService private readonly workspaceTrustRequestService: IWorkspaceTrustRequestService,\n\t\t@IHostService private readonly hostService: IHostService,\n\t\t@ITextEditorService private readonly textEditorService: ITextEditorService\n\t) {\n\t\tsuper();\n\n\t\tthis.editorGroupsContainer = editorGroupsContainer ?? editorGroupService;\n\t\tthis.editorsObserver = this._register(this.instantiationService.createInstance(EditorsObserver, this.editorGroupsContainer));\n\n\t\tthis.onConfigurationUpdated();\n\n\t\tthis.registerListeners();\n\t}\n\n\tcreateScoped(editorGroupsContainer: IEditorGroupsContainer, disposables: DisposableStore): IEditorService {\n\t\treturn disposables.add(new EditorService(editorGroupsContainer, this.editorGroupService, this.instantiationService, this.fileService, this.configurationService, this.contextService, this.uriIdentityService, this.editorResolverService, this.workspaceTrustRequestService, this.hostService, this.textEditorService));\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Editor & group changes\n\t\tif (this.editorGroupsContainer === this.editorGroupService.mainPart || this.editorGroupsContainer === this.editorGroupService) {\n\t\t\tthis.editorGroupService.whenReady.then(() => this.onEditorGroupsReady());\n\t\t} else {\n\t\t\tthis.onEditorGroupsReady();\n\t\t}\n\t\tthis._register(this.editorGroupsContainer.onDidChangeActiveGroup(group => this.handleActiveEditorChange(group)));\n\t\tthis._register(this.editorGroupsContainer.onDidAddGroup(group => this.registerGroupListeners(group as IEditorGroupView)));\n\t\tthis._register(this.editorsObserver.onDidMostRecentlyActiveEditorsChange(() => this._onDidMostRecentlyActiveEditorsChange.fire()));\n\n\t\t// Out of workspace file watchers\n\t\tthis._register(this.onDidVisibleEditorsChange(() => this.handleVisibleEditorsChange()));\n\n\t\t// File changes & operations\n\t\t// Note: there is some duplication with the two file event handlers- Since we cannot always rely on the disk events\n\t\t// carrying all necessary data in all environments, we also use the file operation events to make sure operations are handled.\n\t\t// In any case there is no guarantee if the local event is fired first or the disk one. Thus, code must handle the case\n\t\t// that the event ordering is random as well as might not carry all information needed.\n\t\tthis._register(this.fileService.onDidRunOperation(e => this.onDidRunFileOperation(e)));\n\t\tthis._register(this.fileService.onDidFilesChange(e => this.onDidFilesChange(e)));\n\n\t\t// Configuration\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(e)));\n\t}\n\n\t//#region Editor & group event handlers\n\n\tprivate lastActiveEditor: EditorInput | undefined = undefined;\n\n\tprivate onEditorGroupsReady(): void {\n\n\t\t// Register listeners to each opened group\n\t\tfor (const group of this.editorGroupsContainer.groups) {\n\t\t\tthis.registerGroupListeners(group as IEditorGroupView);\n\t\t}\n\n\t\t// Fire initial set of editor events if there is an active editor\n\t\tif (this.activeEditor) {\n\t\t\tthis.doHandleActiveEditorChangeEvent();\n\t\t\tthis._onDidVisibleEditorsChange.fire();\n\t\t}\n\t}\n\n\tprivate handleActiveEditorChange(group: IEditorGroup): void {\n\t\tif (group !== this.editorGroupsContainer.activeGroup) {\n\t\t\treturn; // ignore if not the active group\n\t\t}\n\n\t\tif (!this.lastActiveEditor && !group.activeEditor) {\n\t\t\treturn; // ignore if we still have no active editor\n\t\t}\n\n\t\tthis.doHandleActiveEditorChangeEvent();\n\t}\n\n\tprivate doHandleActiveEditorChangeEvent(): void {\n\n\t\t// Remember as last active\n\t\tconst activeGroup = this.editorGroupsContainer.activeGroup;\n\t\tthis.lastActiveEditor = activeGroup.activeEditor ?? undefined;\n\n\t\t// Fire event to outside parties\n\t\tthis._onDidActiveEditorChange.fire();\n\t}\n\n\tprivate registerGroupListeners(group: IEditorGroupView): void {\n\t\tconst groupDisposables = new DisposableStore();\n\n\t\tgroupDisposables.add(group.onDidModelChange(e => {\n\t\t\tthis._onDidEditorsChange.fire({ groupId: group.id, event: e });\n\t\t}));\n\n\t\tgroupDisposables.add(group.onDidActiveEditorChange(() => {\n\t\t\tthis.handleActiveEditorChange(group);\n\t\t\tthis._onDidVisibleEditorsChange.fire();\n\t\t}));\n\n\t\tgroupDisposables.add(group.onWillOpenEditor(e => {\n\t\t\tthis._onWillOpenEditor.fire(e);\n\t\t}));\n\n\t\tgroupDisposables.add(group.onDidCloseEditor(e => {\n\t\t\tthis._onDidCloseEditor.fire(e);\n\t\t}));\n\n\t\tgroupDisposables.add(group.onDidOpenEditorFail(editor => {\n\t\t\tthis._onDidOpenEditorFail.fire({ editor, groupId: group.id });\n\t\t}));\n\n\t\tEvent.once(group.onWillDispose)(() => {\n\t\t\tdispose(groupDisposables);\n\t\t});\n\t}\n\n\t//#endregion\n\n\t//#region Visible Editors Change: Install file watchers for out of workspace resources that became visible\n\n\tprivate readonly activeOutOfWorkspaceWatchers = new ResourceMap<IDisposable>();\n\n\tprivate handleVisibleEditorsChange(): void {\n\t\tconst visibleOutOfWorkspaceResources = new ResourceSet();\n\n\t\tfor (const editor of this.visibleEditors) {\n\t\t\tconst resources = distinct(coalesce([\n\t\t\t\tEditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY }),\n\t\t\t\tEditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.SECONDARY })\n\t\t\t]), resource => resource.toString());\n\n\t\t\tfor (const resource of resources) {\n\t\t\t\tif (this.fileService.hasProvider(resource) && !this.contextService.isInsideWorkspace(resource)) {\n\t\t\t\t\tvisibleOutOfWorkspaceResources.add(resource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle no longer visible out of workspace resources\n\t\tfor (const resource of this.activeOutOfWorkspaceWatchers.keys()) {\n\t\t\tif (!visibleOutOfWorkspaceResources.has(resource)) {\n\t\t\t\tdispose(this.activeOutOfWorkspaceWatchers.get(resource));\n\t\t\t\tthis.activeOutOfWorkspaceWatchers.delete(resource);\n\t\t\t}\n\t\t}\n\n\t\t// Handle newly visible out of workspace resources\n\t\tfor (const resource of visibleOutOfWorkspaceResources.keys()) {\n\t\t\tif (!this.activeOutOfWorkspaceWatchers.get(resource)) {\n\t\t\t\tconst disposable = this.fileService.watch(resource);\n\t\t\t\tthis.activeOutOfWorkspaceWatchers.set(resource, disposable);\n\t\t\t}\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Changes: Move & Deletes to move or close opend editors\n\n\tprivate async onDidRunFileOperation(e: FileOperationEvent): Promise<void> {\n\n\t\t// Handle moves specially when file is opened\n\t\tif (e.isOperation(FileOperation.MOVE)) {\n\t\t\tthis.handleMovedFile(e.resource, e.target.resource);\n\t\t}\n\n\t\t// Handle deletes\n\t\tif (e.isOperation(FileOperation.DELETE) || e.isOperation(FileOperation.MOVE)) {\n\t\t\tthis.handleDeletedFile(e.resource, false, e.target ? e.target.resource : undefined);\n\t\t}\n\t}\n\n\tprivate onDidFilesChange(e: FileChangesEvent): void {\n\t\tif (e.gotDeleted()) {\n\t\t\tthis.handleDeletedFile(e, true);\n\t\t}\n\t}\n\n\tprivate async handleMovedFile(source: URI, target: URI): Promise<void> {\n\t\tfor (const group of this.editorGroupsContainer.groups) {\n\t\t\tconst replacements: (IUntypedEditorReplacement | IEditorReplacement)[] = [];\n\n\t\t\tfor (const editor of group.editors) {\n\t\t\t\tconst resource = editor.resource;\n\t\t\t\tif (!resource || !this.uriIdentityService.extUri.isEqualOrParent(resource, source)) {\n\t\t\t\t\tcontinue; // not matching our resource\n\t\t\t\t}\n\n\t\t\t\t// Determine new resulting target resource\n\t\t\t\tlet targetResource: URI;\n\t\t\t\tif (this.uriIdentityService.extUri.isEqual(source, resource)) {\n\t\t\t\t\ttargetResource = target; // file got moved\n\t\t\t\t} else {\n\t\t\t\t\tconst index = indexOfPath(resource.path, source.path, this.uriIdentityService.extUri.ignorePathCasing(resource));\n\t\t\t\t\ttargetResource = joinPath(target, resource.path.substr(index + source.path.length + 1)); // parent folder got moved\n\t\t\t\t}\n\n\t\t\t\t// Delegate rename() to editor instance\n\t\t\t\tconst moveResult = await editor.rename(group.id, targetResource);\n\t\t\t\tif (!moveResult) {\n\t\t\t\t\treturn; // not target - ignore\n\t\t\t\t}\n\n\t\t\t\tconst optionOverrides = {\n\t\t\t\t\tpreserveFocus: true,\n\t\t\t\t\tpinned: group.isPinned(editor),\n\t\t\t\t\tsticky: group.isSticky(editor),\n\t\t\t\t\tindex: group.getIndexOfEditor(editor),\n\t\t\t\t\tinactive: !group.isActive(editor)\n\t\t\t\t};\n\n\t\t\t\t// Construct a replacement with our extra options mixed in\n\t\t\t\tif (isEditorInput(moveResult.editor)) {\n\t\t\t\t\treplacements.push({\n\t\t\t\t\t\teditor,\n\t\t\t\t\t\treplacement: moveResult.editor,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t...moveResult.options,\n\t\t\t\t\t\t\t...optionOverrides\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treplacements.push({\n\t\t\t\t\t\teditor,\n\t\t\t\t\t\treplacement: {\n\t\t\t\t\t\t\t...moveResult.editor,\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t...moveResult.editor.options,\n\t\t\t\t\t\t\t\t...optionOverrides\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply replacements\n\t\t\tif (replacements.length) {\n\t\t\t\tthis.replaceEditors(replacements, group);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate closeOnFileDelete = false;\n\n\tprivate onConfigurationUpdated(e?: IConfigurationChangeEvent): void {\n\t\tif (e && !e.affectsConfiguration('workbench.editor.closeOnFileDelete')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst configuration = this.configurationService.getValue<IWorkbenchEditorConfiguration>();\n\t\tif (typeof configuration.workbench?.editor?.closeOnFileDelete === 'boolean') {\n\t\t\tthis.closeOnFileDelete = configuration.workbench.editor.closeOnFileDelete;\n\t\t} else {\n\t\t\tthis.closeOnFileDelete = false; // default\n\t\t}\n\t}\n\n\tprivate handleDeletedFile(arg1: URI | FileChangesEvent, isExternal: boolean, movedTo?: URI): void {\n\t\tfor (const editor of this.getAllNonDirtyEditors({ includeUntitled: false, supportSideBySide: true })) {\n\t\t\t(async () => {\n\t\t\t\tconst resource = editor.resource;\n\t\t\t\tif (!resource) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Handle deletes in opened editors depending on:\n\t\t\t\t// - we close any editor when `closeOnFileDelete: true`\n\t\t\t\t// - we close any editor when the delete occurred from within VSCode\n\t\t\t\tif (this.closeOnFileDelete || !isExternal) {\n\n\t\t\t\t\t// Do NOT close any opened editor that matches the resource path (either equal or being parent) of the\n\t\t\t\t\t// resource we move to (movedTo). Otherwise we would close a resource that has been renamed to the same\n\t\t\t\t\t// path but different casing.\n\t\t\t\t\tif (movedTo && this.uriIdentityService.extUri.isEqualOrParent(resource, movedTo)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet matches = false;\n\t\t\t\t\tif (arg1 instanceof FileChangesEvent) {\n\t\t\t\t\t\tmatches = arg1.contains(resource, FileChangeType.DELETED);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatches = this.uriIdentityService.extUri.isEqualOrParent(resource, arg1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!matches) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We have received reports of users seeing delete events even though the file still\n\t\t\t\t\t// exists (network shares issue: https://github.com/microsoft/vscode/issues/13665).\n\t\t\t\t\t// Since we do not want to close an editor without reason, we have to check if the\n\t\t\t\t\t// file is really gone and not just a faulty file event.\n\t\t\t\t\t// This only applies to external file events, so we need to check for the isExternal\n\t\t\t\t\t// flag.\n\t\t\t\t\tlet exists = false;\n\t\t\t\t\tif (isExternal && this.fileService.hasProvider(resource)) {\n\t\t\t\t\t\tawait timeout(100);\n\t\t\t\t\t\texists = await this.fileService.exists(resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!exists && !editor.isDisposed()) {\n\t\t\t\t\t\teditor.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t}\n\n\tprivate getAllNonDirtyEditors(options: { includeUntitled: boolean; supportSideBySide: boolean }): EditorInput[] {\n\t\tconst editors: EditorInput[] = [];\n\n\t\tfunction conditionallyAddEditor(editor: EditorInput): void {\n\t\t\tif (editor.hasCapability(EditorInputCapabilities.Untitled) && !options.includeUntitled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (editor.isDirty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\teditors.push(editor);\n\t\t}\n\n\t\tfor (const editor of this.editors) {\n\t\t\tif (options.supportSideBySide && editor instanceof SideBySideEditorInput) {\n\t\t\t\tconditionallyAddEditor(editor.primary);\n\t\t\t\tconditionallyAddEditor(editor.secondary);\n\t\t\t} else {\n\t\t\t\tconditionallyAddEditor(editor);\n\t\t\t}\n\t\t}\n\n\t\treturn editors;\n\t}\n\n\t//#endregion\n\n\t//#region Editor accessors\n\n\tprivate readonly editorsObserver: EditorsObserver;\n\n\tget activeEditorPane(): IVisibleEditorPane | undefined {\n\t\treturn this.editorGroupsContainer.activeGroup?.activeEditorPane;\n\t}\n\n\tget activeTextEditorControl(): ICodeEditor | IDiffEditor | undefined {\n\t\tconst activeEditorPane = this.activeEditorPane;\n\t\tif (activeEditorPane) {\n\t\t\tconst activeControl = activeEditorPane.getControl();\n\t\t\tif (isCodeEditor(activeControl) || isDiffEditor(activeControl)) {\n\t\t\t\treturn activeControl;\n\t\t\t}\n\t\t\tif (isCompositeEditor(activeControl) && isCodeEditor(activeControl.activeCodeEditor)) {\n\t\t\t\treturn activeControl.activeCodeEditor;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tget activeTextEditorLanguageId(): string | undefined {\n\t\tlet activeCodeEditor: ICodeEditor | undefined = undefined;\n\n\t\tconst activeTextEditorControl = this.activeTextEditorControl;\n\t\tif (isDiffEditor(activeTextEditorControl)) {\n\t\t\tactiveCodeEditor = activeTextEditorControl.getModifiedEditor();\n\t\t} else {\n\t\t\tactiveCodeEditor = activeTextEditorControl;\n\t\t}\n\n\t\treturn activeCodeEditor?.getModel()?.getLanguageId();\n\t}\n\n\tget count(): number {\n\t\treturn this.editorsObserver.count;\n\t}\n\n\tget editors(): EditorInput[] {\n\t\treturn this.getEditors(EditorsOrder.SEQUENTIAL).map(({ editor }) => editor);\n\t}\n\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): IEditorIdentifier[] {\n\t\tswitch (order) {\n\n\t\t\t// MRU\n\t\t\tcase EditorsOrder.MOST_RECENTLY_ACTIVE:\n\t\t\t\tif (options?.excludeSticky) {\n\t\t\t\t\treturn this.editorsObserver.editors.filter(({ groupId, editor }) => !this.editorGroupsContainer.getGroup(groupId)?.isSticky(editor));\n\t\t\t\t}\n\n\t\t\t\treturn this.editorsObserver.editors;\n\n\t\t\t// Sequential\n\t\t\tcase EditorsOrder.SEQUENTIAL: {\n\t\t\t\tconst editors: IEditorIdentifier[] = [];\n\n\t\t\t\tfor (const group of this.editorGroupsContainer.getGroups(GroupsOrder.GRID_APPEARANCE)) {\n\t\t\t\t\teditors.push(...group.getEditors(EditorsOrder.SEQUENTIAL, options).map(editor => ({ editor, groupId: group.id })));\n\t\t\t\t}\n\n\t\t\t\treturn editors;\n\t\t\t}\n\t\t}\n\t}\n\n\tget activeEditor(): EditorInput | undefined {\n\t\tconst activeGroup = this.editorGroupsContainer.activeGroup;\n\n\t\treturn activeGroup ? activeGroup.activeEditor ?? undefined : undefined;\n\t}\n\n\tget visibleEditorPanes(): IVisibleEditorPane[] {\n\t\treturn coalesce(this.editorGroupsContainer.groups.map(group => group.activeEditorPane));\n\t}\n\n\tget visibleTextEditorControls(): Array<ICodeEditor | IDiffEditor> {\n\t\treturn this.doGetVisibleTextEditorControls(this.visibleEditorPanes);\n\t}\n\n\tprivate doGetVisibleTextEditorControls(editorPanes: IVisibleEditorPane[]): Array<ICodeEditor | IDiffEditor> {\n\t\tconst visibleTextEditorControls: Array<ICodeEditor | IDiffEditor> = [];\n\t\tfor (const editorPane of editorPanes) {\n\t\t\tconst controls: Array<IEditorControl | undefined> = [];\n\t\t\tif (editorPane instanceof SideBySideEditorPane) {\n\t\t\t\tcontrols.push(editorPane.getPrimaryEditorPane()?.getControl());\n\t\t\t\tcontrols.push(editorPane.getSecondaryEditorPane()?.getControl());\n\t\t\t} else {\n\t\t\t\tcontrols.push(editorPane.getControl());\n\t\t\t}\n\n\t\t\tfor (const control of controls) {\n\t\t\t\tif (isCodeEditor(control) || isDiffEditor(control)) {\n\t\t\t\t\tvisibleTextEditorControls.push(control);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn visibleTextEditorControls;\n\t}\n\n\tgetVisibleTextEditorControls(order: EditorsOrder): readonly (ICodeEditor | IDiffEditor)[] {\n\t\treturn this.doGetVisibleTextEditorControls(coalesce(this.editorGroupsContainer.getGroups(order === EditorsOrder.SEQUENTIAL ? GroupsOrder.GRID_APPEARANCE : GroupsOrder.MOST_RECENTLY_ACTIVE).map(group => group.activeEditorPane)));\n\t}\n\n\tget visibleEditors(): EditorInput[] {\n\t\treturn coalesce(this.editorGroupsContainer.groups.map(group => group.activeEditor));\n\t}\n\n\t//#endregion\n\n\t//#region openEditor()\n\n\topenEditor(editor: EditorInput, options?: IEditorOptions, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: IUntypedEditorInput, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: IResourceEditorInput, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: ITextResourceEditorInput | IUntitledTextResourceEditorInput, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: ITextResourceDiffEditorInput, group?: PreferredGroup): Promise<ITextDiffEditorPane | undefined>;\n\topenEditor(editor: IResourceDiffEditorInput, group?: PreferredGroup): Promise<ITextDiffEditorPane | undefined>;\n\topenEditor(editor: EditorInput | IUntypedEditorInput, optionsOrPreferredGroup?: IEditorOptions | PreferredGroup, preferredGroup?: PreferredGroup): Promise<IEditorPane | undefined>;\n\tasync openEditor(editor: EditorInput | IUntypedEditorInput, optionsOrPreferredGroup?: IEditorOptions | PreferredGroup, preferredGroup?: PreferredGroup): Promise<IEditorPane | undefined> {\n\t\tlet typedEditor: EditorInput | undefined = undefined;\n\t\tlet options = isEditorInput(editor) ? optionsOrPreferredGroup as IEditorOptions : editor.options;\n\t\tlet group: IEditorGroup | undefined = undefined;\n\n\t\tif (isPreferredGroup(optionsOrPreferredGroup)) {\n\t\t\tpreferredGroup = optionsOrPreferredGroup;\n\t\t}\n\n\t\t// Resolve override unless disabled\n\t\tif (!isEditorInput(editor)) {\n\t\t\tconst resolvedEditor = await this.editorResolverService.resolveEditor(editor, preferredGroup);\n\n\t\t\tif (resolvedEditor === ResolvedStatus.ABORT) {\n\t\t\t\treturn; // skip editor if override is aborted\n\t\t\t}\n\n\t\t\t// We resolved an editor to use\n\t\t\tif (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n\t\t\t\ttypedEditor = resolvedEditor.editor;\n\t\t\t\toptions = resolvedEditor.options;\n\t\t\t\tgroup = resolvedEditor.group;\n\t\t\t}\n\t\t}\n\n\t\t// Override is disabled or did not apply: fallback to default\n\t\tif (!typedEditor) {\n\t\t\ttypedEditor = isEditorInput(editor) ? editor : await this.textEditorService.resolveTextEditor(editor);\n\t\t}\n\n\t\t// If group still isn't defined because of a disabled override we resolve it\n\t\tif (!group) {\n\t\t\tlet activation: EditorActivation | undefined = undefined;\n\t\t\tconst findGroupResult = this.instantiationService.invokeFunction(findGroup, { editor: typedEditor, options }, preferredGroup);\n\t\t\tif (findGroupResult instanceof Promise) {\n\t\t\t\t([group, activation] = await findGroupResult);\n\t\t\t} else {\n\t\t\t\t([group, activation] = findGroupResult);\n\t\t\t}\n\n\t\t\t// Mixin editor group activation if returned\n\t\t\tif (activation) {\n\t\t\t\toptions = { ...options, activation };\n\t\t\t}\n\t\t}\n\n\t\treturn group.openEditor(typedEditor, options);\n\t}\n\n\t//#endregion\n\n\t//#region openEditors()\n\n\topenEditors(editors: EditorInputWithOptions[], group?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]>;\n\topenEditors(editors: IUntypedEditorInput[], group?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]>;\n\topenEditors(editors: Array<EditorInputWithOptions | IUntypedEditorInput>, group?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]>;\n\tasync openEditors(editors: Array<EditorInputWithOptions | IUntypedEditorInput>, preferredGroup?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]> {\n\n\t\t// Pass all editors to trust service to determine if\n\t\t// we should proceed with opening the editors if we\n\t\t// are asked to validate trust.\n\t\tif (options?.validateTrust) {\n\t\t\tconst editorsTrusted = await this.handleWorkspaceTrust(editors);\n\t\t\tif (!editorsTrusted) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\t// Find target groups for editors to open\n\t\tconst mapGroupToTypedEditors = new Map<IEditorGroup, Array<EditorInputWithOptions>>();\n\t\tfor (const editor of editors) {\n\t\t\tlet typedEditor: EditorInputWithOptions | undefined = undefined;\n\t\t\tlet group: IEditorGroup | undefined = undefined;\n\n\t\t\t// Resolve override unless disabled\n\t\t\tif (!isEditorInputWithOptions(editor)) {\n\t\t\t\tconst resolvedEditor = await this.editorResolverService.resolveEditor(editor, preferredGroup);\n\n\t\t\t\tif (resolvedEditor === ResolvedStatus.ABORT) {\n\t\t\t\t\tcontinue; // skip editor if override is aborted\n\t\t\t\t}\n\n\t\t\t\t// We resolved an editor to use\n\t\t\t\tif (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n\t\t\t\t\ttypedEditor = resolvedEditor;\n\t\t\t\t\tgroup = resolvedEditor.group;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override is disabled or did not apply: fallback to default\n\t\t\tif (!typedEditor) {\n\t\t\t\ttypedEditor = isEditorInputWithOptions(editor) ? editor : { editor: await this.textEditorService.resolveTextEditor(editor), options: editor.options };\n\t\t\t}\n\n\t\t\t// If group still isn't defined because of a disabled override we resolve it\n\t\t\tif (!group) {\n\t\t\t\tconst findGroupResult = this.instantiationService.invokeFunction(findGroup, typedEditor, preferredGroup);\n\t\t\t\tif (findGroupResult instanceof Promise) {\n\t\t\t\t\t([group] = await findGroupResult);\n\t\t\t\t} else {\n\t\t\t\t\t([group] = findGroupResult);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update map of groups to editors\n\t\t\tlet targetGroupEditors = mapGroupToTypedEditors.get(group);\n\t\t\tif (!targetGroupEditors) {\n\t\t\t\ttargetGroupEditors = [];\n\t\t\t\tmapGroupToTypedEditors.set(group, targetGroupEditors);\n\t\t\t}\n\n\t\t\ttargetGroupEditors.push(typedEditor);\n\t\t}\n\n\t\t// Open in target groups\n\t\tconst result: Promise<IEditorPane | undefined>[] = [];\n\t\tfor (const [group, editors] of mapGroupToTypedEditors) {\n\t\t\tresult.push(group.openEditors(editors));\n\t\t}\n\n\t\treturn coalesce(await Promises.settled(result));\n\t}\n\n\tprivate async handleWorkspaceTrust(editors: Array<EditorInputWithOptions | IUntypedEditorInput>): Promise<boolean> {\n\t\tconst { resources, diffMode, mergeMode } = this.extractEditorResources(editors);\n\n\t\tconst trustResult = await this.workspaceTrustRequestService.requestOpenFilesTrust(resources);\n\t\tswitch (trustResult) {\n\t\t\tcase WorkspaceTrustUriResponse.Open:\n\t\t\t\treturn true;\n\t\t\tcase WorkspaceTrustUriResponse.OpenInNewWindow:\n\t\t\t\tawait this.hostService.openWindow(resources.map(resource => ({ fileUri: resource })), { forceNewWindow: true, diffMode, mergeMode });\n\t\t\t\treturn false;\n\t\t\tcase WorkspaceTrustUriResponse.Cancel:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate extractEditorResources(editors: Array<EditorInputWithOptions | IUntypedEditorInput>): { resources: URI[]; diffMode?: boolean; mergeMode?: boolean } {\n\t\tconst resources = new ResourceSet();\n\t\tlet diffMode = false;\n\t\tlet mergeMode = false;\n\n\t\tfor (const editor of editors) {\n\n\t\t\t// Typed Editor\n\t\t\tif (isEditorInputWithOptions(editor)) {\n\t\t\t\tconst resource = EditorResourceAccessor.getOriginalUri(editor.editor, { supportSideBySide: SideBySideEditor.BOTH });\n\t\t\t\tif (URI.isUri(resource)) {\n\t\t\t\t\tresources.add(resource);\n\t\t\t\t} else if (resource) {\n\t\t\t\t\tif (resource.primary) {\n\t\t\t\t\t\tresources.add(resource.primary);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (resource.secondary) {\n\t\t\t\t\t\tresources.add(resource.secondary);\n\t\t\t\t\t}\n\n\t\t\t\t\tdiffMode = editor.editor instanceof DiffEditorInput;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Untyped editor\n\t\t\telse {\n\t\t\t\tif (isResourceMergeEditorInput(editor)) {\n\t\t\t\t\tif (URI.isUri(editor.input1)) {\n\t\t\t\t\t\tresources.add(editor.input1.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.input2)) {\n\t\t\t\t\t\tresources.add(editor.input2.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.base)) {\n\t\t\t\t\t\tresources.add(editor.base.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.result)) {\n\t\t\t\t\t\tresources.add(editor.result.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tmergeMode = true;\n\t\t\t\t} if (isResourceDiffEditorInput(editor)) {\n\t\t\t\t\tif (URI.isUri(editor.original.resource)) {\n\t\t\t\t\t\tresources.add(editor.original.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.modified.resource)) {\n\t\t\t\t\t\tresources.add(editor.modified.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tdiffMode = true;\n\t\t\t\t} else if (isResourceEditorInput(editor)) {\n\t\t\t\t\tresources.add(editor.resource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tresources: Array.from(resources.keys()),\n\t\t\tdiffMode,\n\t\t\tmergeMode\n\t\t};\n\t}\n\n\t//#endregion\n\n\t//#region isOpened() / isVisible()\n\n\tisOpened(editor: IResourceEditorInputIdentifier): boolean {\n\t\treturn this.editorsObserver.hasEditor({\n\t\t\tresource: this.uriIdentityService.asCanonicalUri(editor.resource),\n\t\t\ttypeId: editor.typeId,\n\t\t\teditorId: editor.editorId\n\t\t});\n\t}\n\n\tisVisible(editor: EditorInput): boolean {\n\t\tfor (const group of this.editorGroupsContainer.groups) {\n\t\t\tif (group.activeEditor?.matches(editor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//#endregion\n\n\t//#region closeEditor()\n\n\tasync closeEditor({ editor, groupId }: IEditorIdentifier, options?: ICloseEditorOptions): Promise<void> {\n\t\tconst group = this.editorGroupsContainer.getGroup(groupId);\n\n\t\tawait group?.closeEditor(editor, options);\n\t}\n\n\t//#endregion\n\n\t//#region closeEditors()\n\n\tasync closeEditors(editors: IEditorIdentifier[], options?: ICloseEditorOptions): Promise<void> {\n\t\tconst mapGroupToEditors = new Map<IEditorGroup, EditorInput[]>();\n\n\t\tfor (const { editor, groupId } of editors) {\n\t\t\tconst group = this.editorGroupsContainer.getGroup(groupId);\n\t\t\tif (!group) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet editors = mapGroupToEditors.get(group);\n\t\t\tif (!editors) {\n\t\t\t\teditors = [];\n\t\t\t\tmapGroupToEditors.set(group, editors);\n\t\t\t}\n\n\t\t\teditors.push(editor);\n\t\t}\n\n\t\tfor (const [group, editors] of mapGroupToEditors) {\n\t\t\tawait group.closeEditors(editors, options);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region findEditors()\n\n\tfindEditors(resource: URI, options?: IFindEditorOptions): readonly IEditorIdentifier[];\n\tfindEditors(editor: IResourceEditorInputIdentifier, options?: IFindEditorOptions): readonly IEditorIdentifier[];\n\tfindEditors(resource: URI, options: IFindEditorOptions | undefined, group: IEditorGroup | GroupIdentifier): readonly EditorInput[];\n\tfindEditors(editor: IResourceEditorInputIdentifier, options: IFindEditorOptions | undefined, group: IEditorGroup | GroupIdentifier): EditorInput | undefined;\n\tfindEditors(arg1: URI | IResourceEditorInputIdentifier, options: IFindEditorOptions | undefined, arg2?: IEditorGroup | GroupIdentifier): readonly IEditorIdentifier[] | readonly EditorInput[] | EditorInput | undefined;\n\tfindEditors(arg1: URI | IResourceEditorInputIdentifier, options: IFindEditorOptions | undefined, arg2?: IEditorGroup | GroupIdentifier): readonly IEditorIdentifier[] | readonly EditorInput[] | EditorInput | undefined {\n\t\tconst resource = URI.isUri(arg1) ? arg1 : arg1.resource;\n\t\tconst typeId = URI.isUri(arg1) ? undefined : arg1.typeId;\n\n\t\t// Do a quick check for the resource via the editor observer\n\t\t// which is a very efficient way to find an editor by resource.\n\t\t// However, we can only do that unless we are asked to find an\n\t\t// editor on the secondary side of a side by side editor, because\n\t\t// the editor observer provides fast lookups only for primary\n\t\t// editors.\n\t\tif (options?.supportSideBySide !== SideBySideEditor.ANY && options?.supportSideBySide !== SideBySideEditor.SECONDARY) {\n\t\t\tif (!this.editorsObserver.hasEditors(resource)) {\n\t\t\t\tif (URI.isUri(arg1) || isUndefined(arg2)) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\t// Search only in specific group\n\t\tif (!isUndefined(arg2)) {\n\t\t\tconst targetGroup = typeof arg2 === 'number' ? this.editorGroupsContainer.getGroup(arg2) : arg2;\n\n\t\t\t// Resource provided: result is an array\n\t\t\tif (URI.isUri(arg1)) {\n\t\t\t\tif (!targetGroup) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\treturn targetGroup.findEditors(resource, options);\n\t\t\t}\n\n\t\t\t// Editor identifier provided, result is single\n\t\t\telse {\n\t\t\t\tif (!targetGroup) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tconst editors = targetGroup.findEditors(resource, options);\n\t\t\t\tfor (const editor of editors) {\n\t\t\t\t\tif (editor.typeId === typeId) {\n\t\t\t\t\t\treturn editor;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\t// Search across all groups in MRU order\n\t\telse {\n\t\t\tconst result: IEditorIdentifier[] = [];\n\n\t\t\tfor (const group of this.editorGroupsContainer.getGroups(options?.order === EditorsOrder.SEQUENTIAL ? GroupsOrder.GRID_APPEARANCE : GroupsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tconst editors: EditorInput[] = [];\n\n\t\t\t\t// Resource provided: result is an array\n\t\t\t\tif (URI.isUri(arg1)) {\n\t\t\t\t\teditors.push(...this.findEditors(arg1, options, group));\n\t\t\t\t}\n\n\t\t\t\t// Editor identifier provided, result is single\n\t\t\t\telse {\n\t\t\t\t\tconst editor = this.findEditors(arg1, options, group);\n\t\t\t\t\tif (editor) {\n\t\t\t\t\t\teditors.push(editor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.push(...editors.map(editor => ({ editor, groupId: group.id })));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region replaceEditors()\n\n\tasync replaceEditors(replacements: IUntypedEditorReplacement[], group: IEditorGroup | GroupIdentifier): Promise<void>;\n\tasync replaceEditors(replacements: IEditorReplacement[], group: IEditorGroup | GroupIdentifier): Promise<void>;\n\tasync replaceEditors(replacements: Array<IEditorReplacement | IUntypedEditorReplacement>, group: IEditorGroup | GroupIdentifier): Promise<void> {\n\t\tconst targetGroup = typeof group === 'number' ? this.editorGroupsContainer.getGroup(group) : group;\n\n\t\t// Convert all replacements to typed editors unless already\n\t\t// typed and handle overrides properly.\n\t\tconst typedReplacements: IEditorReplacement[] = [];\n\t\tfor (const replacement of replacements) {\n\t\t\tlet typedReplacement: IEditorReplacement | undefined = undefined;\n\n\t\t\t// Resolve override unless disabled\n\t\t\tif (!isEditorInput(replacement.replacement)) {\n\t\t\t\tconst resolvedEditor = await this.editorResolverService.resolveEditor(\n\t\t\t\t\treplacement.replacement,\n\t\t\t\t\ttargetGroup\n\t\t\t\t);\n\n\t\t\t\tif (resolvedEditor === ResolvedStatus.ABORT) {\n\t\t\t\t\tcontinue; // skip editor if override is aborted\n\t\t\t\t}\n\n\t\t\t\t// We resolved an editor to use\n\t\t\t\tif (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n\t\t\t\t\ttypedReplacement = {\n\t\t\t\t\t\teditor: replacement.editor,\n\t\t\t\t\t\treplacement: resolvedEditor.editor,\n\t\t\t\t\t\toptions: resolvedEditor.options,\n\t\t\t\t\t\tforceReplaceDirty: replacement.forceReplaceDirty\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override is disabled or did not apply: fallback to default\n\t\t\tif (!typedReplacement) {\n\t\t\t\ttypedReplacement = {\n\t\t\t\t\teditor: replacement.editor,\n\t\t\t\t\treplacement: isEditorReplacement(replacement) ? replacement.replacement : await this.textEditorService.resolveTextEditor(replacement.replacement),\n\t\t\t\t\toptions: isEditorReplacement(replacement) ? replacement.options : replacement.replacement.options,\n\t\t\t\t\tforceReplaceDirty: replacement.forceReplaceDirty\n\t\t\t\t};\n\t\t\t}\n\n\t\t\ttypedReplacements.push(typedReplacement);\n\t\t}\n\n\t\treturn targetGroup?.replaceEditors(typedReplacements);\n\t}\n\n\t//#endregion\n\n\t//#region save/revert\n\n\tasync save(editors: IEditorIdentifier | IEditorIdentifier[], options?: ISaveEditorsOptions): Promise<ISaveEditorsResult> {\n\n\t\t// Convert to array\n\t\tif (!Array.isArray(editors)) {\n\t\t\teditors = [editors];\n\t\t}\n\n\t\t// Make sure to not save the same editor multiple times\n\t\t// by using the `matches()` method to find duplicates\n\t\tconst uniqueEditors = this.getUniqueEditors(editors);\n\n\t\t// Split editors up into a bucket that is saved in parallel\n\t\t// and sequentially. Unless \"Save As\", all non-untitled editors\n\t\t// can be saved in parallel to speed up the operation. Remaining\n\t\t// editors are potentially bringing up some UI and thus run\n\t\t// sequentially.\n\t\tconst editorsToSaveParallel: IEditorIdentifier[] = [];\n\t\tconst editorsToSaveSequentially: IEditorIdentifier[] = [];\n\t\tif (options?.saveAs) {\n\t\t\teditorsToSaveSequentially.push(...uniqueEditors);\n\t\t} else {\n\t\t\tfor (const { groupId, editor } of uniqueEditors) {\n\t\t\t\tif (editor.hasCapability(EditorInputCapabilities.Untitled)) {\n\t\t\t\t\teditorsToSaveSequentially.push({ groupId, editor });\n\t\t\t\t} else {\n\t\t\t\t\teditorsToSaveParallel.push({ groupId, editor });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Editors to save in parallel\n\t\tconst saveResults = await Promises.settled(editorsToSaveParallel.map(({ groupId, editor }) => {\n\n\t\t\t// Use save as a hint to pin the editor if used explicitly\n\t\t\tif (options?.reason === SaveReason.EXPLICIT) {\n\t\t\t\tthis.editorGroupsContainer.getGroup(groupId)?.pinEditor(editor);\n\t\t\t}\n\n\t\t\t// Save\n\t\t\treturn editor.save(groupId, options);\n\t\t}));\n\n\t\t// Editors to save sequentially\n\t\tfor (const { groupId, editor } of editorsToSaveSequentially) {\n\t\t\tif (editor.isDisposed()) {\n\t\t\t\tcontinue; // might have been disposed from the save already\n\t\t\t}\n\n\t\t\t// Preserve view state by opening the editor first if the editor\n\t\t\t// is untitled or we \"Save As\". This also allows the user to review\n\t\t\t// the contents of the editor before making a decision.\n\t\t\tconst editorPane = await this.openEditor(editor, groupId);\n\t\t\tconst editorOptions: IEditorOptions = {\n\t\t\t\tpinned: true,\n\t\t\t\tviewState: editorPane?.getViewState()\n\t\t\t};\n\n\t\t\tconst result = options?.saveAs ? await editor.saveAs(groupId, options) : await editor.save(groupId, options);\n\t\t\tsaveResults.push(result);\n\n\t\t\tif (!result) {\n\t\t\t\tbreak; // failed or cancelled, abort\n\t\t\t}\n\n\t\t\t// Replace editor preserving viewstate (either across all groups or\n\t\t\t// only selected group) if the resulting editor is different from the\n\t\t\t// current one.\n\t\t\tif (!editor.matches(result)) {\n\t\t\t\tconst targetGroups = editor.hasCapability(EditorInputCapabilities.Untitled) ? this.editorGroupsContainer.groups.map(group => group.id) /* untitled replaces across all groups */ : [groupId];\n\t\t\t\tfor (const targetGroup of targetGroups) {\n\t\t\t\t\tif (result instanceof EditorInput) {\n\t\t\t\t\t\tawait this.replaceEditors([{ editor, replacement: result, options: editorOptions }], targetGroup);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tawait this.replaceEditors([{ editor, replacement: { ...result, options: editorOptions } }], targetGroup);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tsuccess: saveResults.every(result => !!result),\n\t\t\teditors: coalesce(saveResults)\n\t\t};\n\t}\n\n\tsaveAll(options?: ISaveAllEditorsOptions): Promise<ISaveEditorsResult> {\n\t\treturn this.save(this.getAllModifiedEditors(options), options);\n\t}\n\n\tasync revert(editors: IEditorIdentifier | IEditorIdentifier[], options?: IRevertOptions): Promise<boolean> {\n\n\t\t// Convert to array\n\t\tif (!Array.isArray(editors)) {\n\t\t\teditors = [editors];\n\t\t}\n\n\t\t// Make sure to not revert the same editor multiple times\n\t\t// by using the `matches()` method to find duplicates\n\t\tconst uniqueEditors = this.getUniqueEditors(editors);\n\n\t\tawait Promises.settled(uniqueEditors.map(async ({ groupId, editor }) => {\n\n\t\t\t// Use revert as a hint to pin the editor\n\t\t\tthis.editorGroupsContainer.getGroup(groupId)?.pinEditor(editor);\n\n\t\t\treturn editor.revert(groupId, options);\n\t\t}));\n\n\t\treturn !uniqueEditors.some(({ editor }) => editor.isDirty());\n\t}\n\n\tasync revertAll(options?: IRevertAllEditorsOptions): Promise<boolean> {\n\t\treturn this.revert(this.getAllModifiedEditors(options), options);\n\t}\n\n\tprivate getAllModifiedEditors(options?: IBaseSaveRevertAllEditorOptions): IEditorIdentifier[] {\n\t\tconst editors: IEditorIdentifier[] = [];\n\n\t\tfor (const group of this.editorGroupsContainer.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\tfor (const editor of group.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tif (!editor.isModified()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ((typeof options?.includeUntitled === 'boolean' || !options?.includeUntitled?.includeScratchpad)\n\t\t\t\t\t&& editor.hasCapability(EditorInputCapabilities.Scratchpad)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!options?.includeUntitled && editor.hasCapability(EditorInputCapabilities.Untitled)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (options?.excludeSticky && group.isSticky(editor)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\teditors.push({ groupId: group.id, editor });\n\t\t\t}\n\t\t}\n\n\t\treturn editors;\n\t}\n\n\tprivate getUniqueEditors(editors: IEditorIdentifier[]): IEditorIdentifier[] {\n\t\tconst uniqueEditors: IEditorIdentifier[] = [];\n\t\tfor (const { editor, groupId } of editors) {\n\t\t\tif (uniqueEditors.some(uniqueEditor => uniqueEditor.editor.matches(editor))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuniqueEditors.push({ editor, groupId });\n\t\t}\n\n\t\treturn uniqueEditors;\n\t}\n\n\t//#endregion\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Dispose remaining watchers if any\n\t\tthis.activeOutOfWorkspaceWatchers.forEach(disposable => dispose(disposable));\n\t\tthis.activeOutOfWorkspaceWatchers.clear();\n\t}\n}\n\nregisterSingleton(IEditorService, new SyncDescriptor(EditorService, [undefined], false));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IResourceEditorInput, IEditorOptions, EditorActivation, IResourceEditorInputIdentifier, ITextResourceEditorInput } from '../../../../platform/editor/common/editor.js';\nimport { SideBySideEditor, IEditorPane, GroupIdentifier, IUntitledTextResourceEditorInput, IResourceDiffEditorInput, EditorInputWithOptions, isEditorInputWithOptions, IEditorIdentifier, IEditorCloseEvent, ITextDiffEditorPane, IRevertOptions, SaveReason, EditorsOrder, IWorkbenchEditorConfiguration, EditorResourceAccessor, IVisibleEditorPane, EditorInputCapabilities, isResourceDiffEditorInput, IUntypedEditorInput, isResourceEditorInput, isEditorInput, isEditorInputWithOptionsAndGroup, IFindEditorOptions, isResourceMergeEditorInput, IEditorWillOpenEvent, IEditorControl, ITextResourceDiffEditorInput } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { SideBySideEditorInput } from '../../../common/editor/sideBySideEditorInput.js';\nimport { ResourceMap, ResourceSet } from '../../../../base/common/map.js';\nimport { IFileService, FileOperationEvent, FileOperation, FileChangesEvent, FileChangeType } from '../../../../platform/files/common/files.js';\nimport { Event, Emitter } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { joinPath } from '../../../../base/common/resources.js';\nimport { DiffEditorInput } from '../../../common/editor/diffEditorInput.js';\nimport { SideBySideEditor as SideBySideEditorPane } from '../../../browser/parts/editor/sideBySideEditor.js';\nimport { IEditorGroupsService, IEditorGroup, GroupsOrder, IEditorReplacement, isEditorReplacement, ICloseEditorOptions, IEditorGroupsContainer } from '../common/editorGroupsService.js';\nimport { IUntypedEditorReplacement, IEditorService, ISaveEditorsOptions, ISaveAllEditorsOptions, IRevertAllEditorsOptions, IBaseSaveRevertAllEditorOptions, IOpenEditorsOptions, PreferredGroup, isPreferredGroup, IEditorsChangeEvent, ISaveEditorsResult } from '../common/editorService.js';\nimport { IConfigurationChangeEvent, IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { Disposable, IDisposable, dispose, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { coalesce, distinct } from '../../../../base/common/arrays.js';\nimport { isCodeEditor, isDiffEditor, ICodeEditor, IDiffEditor, isCompositeEditor } from '../../../../editor/browser/editorBrowser.js';\nimport { IEditorGroupView, EditorServiceImpl } from '../../../browser/parts/editor/editor.js';\nimport { registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { isUndefined } from '../../../../base/common/types.js';\nimport { EditorsObserver } from '../../../browser/parts/editor/editorsObserver.js';\nimport { Promises, timeout } from '../../../../base/common/async.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { indexOfPath } from '../../../../base/common/extpath.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.js';\nimport { IEditorResolverService, ResolvedStatus } from '../common/editorResolverService.js';\nimport { IWorkspaceTrustRequestService, WorkspaceTrustUriResponse } from '../../../../platform/workspace/common/workspaceTrust.js';\nimport { IHostService } from '../../host/browser/host.js';\nimport { findGroup } from '../common/editorGroupFinder.js';\nimport { ITextEditorService } from '../../textfile/common/textEditorService.js';\nimport { SyncDescriptor } from '../../../../platform/instantiation/common/descriptors.js';\n\nexport class EditorService extends Disposable implements EditorServiceImpl {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region events\n\n\tprivate readonly _onDidActiveEditorChange = this._register(new Emitter<void>());\n\treadonly onDidActiveEditorChange = this._onDidActiveEditorChange.event;\n\n\tprivate readonly _onDidVisibleEditorsChange = this._register(new Emitter<void>());\n\treadonly onDidVisibleEditorsChange = this._onDidVisibleEditorsChange.event;\n\n\tprivate readonly _onDidEditorsChange = this._register(new Emitter<IEditorsChangeEvent>());\n\treadonly onDidEditorsChange = this._onDidEditorsChange.event;\n\n\tprivate readonly _onWillOpenEditor = this._register(new Emitter<IEditorWillOpenEvent>());\n\treadonly onWillOpenEditor = this._onWillOpenEditor.event;\n\n\tprivate readonly _onDidCloseEditor = this._register(new Emitter<IEditorCloseEvent>());\n\treadonly onDidCloseEditor = this._onDidCloseEditor.event;\n\n\tprivate readonly _onDidOpenEditorFail = this._register(new Emitter<IEditorIdentifier>());\n\treadonly onDidOpenEditorFail = this._onDidOpenEditorFail.event;\n\n\tprivate readonly _onDidMostRecentlyActiveEditorsChange = this._register(new Emitter<void>());\n\treadonly onDidMostRecentlyActiveEditorsChange = this._onDidMostRecentlyActiveEditorsChange.event;\n\n\t//#endregion\n\n\tprivate readonly editorGroupsContainer: IEditorGroupsContainer;\n\n\tconstructor(\n\t\teditorGroupsContainer: IEditorGroupsContainer | undefined,\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@IEditorResolverService private readonly editorResolverService: IEditorResolverService,\n\t\t@IWorkspaceTrustRequestService private readonly workspaceTrustRequestService: IWorkspaceTrustRequestService,\n\t\t@IHostService private readonly hostService: IHostService,\n\t\t@ITextEditorService private readonly textEditorService: ITextEditorService\n\t) {\n\t\tsuper();\n\n\t\tthis.editorGroupsContainer = editorGroupsContainer ?? editorGroupService;\n\t\tthis.editorsObserver = this._register(this.instantiationService.createInstance(EditorsObserver, this.editorGroupsContainer));\n\n\t\tthis.onConfigurationUpdated();\n\n\t\tthis.registerListeners();\n\t}\n\n\tcreateScoped(editorGroupsContainer: IEditorGroupsContainer, disposables: DisposableStore): IEditorService {\n\t\treturn disposables.add(new EditorService(editorGroupsContainer, this.editorGroupService, this.instantiationService, this.fileService, this.configurationService, this.contextService, this.uriIdentityService, this.editorResolverService, this.workspaceTrustRequestService, this.hostService, this.textEditorService));\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Editor & group changes\n\t\tif (this.editorGroupsContainer === this.editorGroupService.mainPart || this.editorGroupsContainer === this.editorGroupService) {\n\t\t\tthis.editorGroupService.whenReady.then(() => this.onEditorGroupsReady());\n\t\t} else {\n\t\t\tthis.onEditorGroupsReady();\n\t\t}\n\t\tthis._register(this.editorGroupsContainer.onDidChangeActiveGroup(group => this.handleActiveEditorChange(group)));\n\t\tthis._register(this.editorGroupsContainer.onDidAddGroup(group => this.registerGroupListeners(group as IEditorGroupView)));\n\t\tthis._register(this.editorsObserver.onDidMostRecentlyActiveEditorsChange(() => this._onDidMostRecentlyActiveEditorsChange.fire()));\n\n\t\t// Out of workspace file watchers\n\t\tthis._register(this.onDidVisibleEditorsChange(() => this.handleVisibleEditorsChange()));\n\n\t\t// File changes & operations\n\t\t// Note: there is some duplication with the two file event handlers- Since we cannot always rely on the disk events\n\t\t// carrying all necessary data in all environments, we also use the file operation events to make sure operations are handled.\n\t\t// In any case there is no guarantee if the local event is fired first or the disk one. Thus, code must handle the case\n\t\t// that the event ordering is random as well as might not carry all information needed.\n\t\tthis._register(this.fileService.onDidRunOperation(e => this.onDidRunFileOperation(e)));\n\t\tthis._register(this.fileService.onDidFilesChange(e => this.onDidFilesChange(e)));\n\n\t\t// Configuration\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(e)));\n\t}\n\n\t//#region Editor & group event handlers\n\n\tprivate lastActiveEditor: EditorInput | undefined = undefined;\n\n\tprivate onEditorGroupsReady(): void {\n\n\t\t// Register listeners to each opened group\n\t\tfor (const group of this.editorGroupsContainer.groups) {\n\t\t\tthis.registerGroupListeners(group as IEditorGroupView);\n\t\t}\n\n\t\t// Fire initial set of editor events if there is an active editor\n\t\tif (this.activeEditor) {\n\t\t\tthis.doHandleActiveEditorChangeEvent();\n\t\t\tthis._onDidVisibleEditorsChange.fire();\n\t\t}\n\t}\n\n\tprivate handleActiveEditorChange(group: IEditorGroup): void {\n\t\tif (group !== this.editorGroupsContainer.activeGroup) {\n\t\t\treturn; // ignore if not the active group\n\t\t}\n\n\t\tif (!this.lastActiveEditor && !group.activeEditor) {\n\t\t\treturn; // ignore if we still have no active editor\n\t\t}\n\n\t\tthis.doHandleActiveEditorChangeEvent();\n\t}\n\n\tprivate doHandleActiveEditorChangeEvent(): void {\n\n\t\t// Remember as last active\n\t\tconst activeGroup = this.editorGroupsContainer.activeGroup;\n\t\tthis.lastActiveEditor = activeGroup.activeEditor ?? undefined;\n\n\t\t// Fire event to outside parties\n\t\tthis._onDidActiveEditorChange.fire();\n\t}\n\n\tprivate registerGroupListeners(group: IEditorGroupView): void {\n\t\tconst groupDisposables = new DisposableStore();\n\n\t\tgroupDisposables.add(group.onDidModelChange(e => {\n\t\t\tthis._onDidEditorsChange.fire({ groupId: group.id, event: e });\n\t\t}));\n\n\t\tgroupDisposables.add(group.onDidActiveEditorChange(() => {\n\t\t\tthis.handleActiveEditorChange(group);\n\t\t\tthis._onDidVisibleEditorsChange.fire();\n\t\t}));\n\n\t\tgroupDisposables.add(group.onWillOpenEditor(e => {\n\t\t\tthis._onWillOpenEditor.fire(e);\n\t\t}));\n\n\t\tgroupDisposables.add(group.onDidCloseEditor(e => {\n\t\t\tthis._onDidCloseEditor.fire(e);\n\t\t}));\n\n\t\tgroupDisposables.add(group.onDidOpenEditorFail(editor => {\n\t\t\tthis._onDidOpenEditorFail.fire({ editor, groupId: group.id });\n\t\t}));\n\n\t\tEvent.once(group.onWillDispose)(() => {\n\t\t\tdispose(groupDisposables);\n\t\t});\n\t}\n\n\t//#endregion\n\n\t//#region Visible Editors Change: Install file watchers for out of workspace resources that became visible\n\n\tprivate readonly activeOutOfWorkspaceWatchers = new ResourceMap<IDisposable>();\n\n\tprivate handleVisibleEditorsChange(): void {\n\t\tconst visibleOutOfWorkspaceResources = new ResourceSet();\n\n\t\tfor (const editor of this.visibleEditors) {\n\t\t\tconst resources = distinct(coalesce([\n\t\t\t\tEditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY }),\n\t\t\t\tEditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.SECONDARY })\n\t\t\t]), resource => resource.toString());\n\n\t\t\tfor (const resource of resources) {\n\t\t\t\tif (this.fileService.hasProvider(resource) && !this.contextService.isInsideWorkspace(resource)) {\n\t\t\t\t\tvisibleOutOfWorkspaceResources.add(resource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle no longer visible out of workspace resources\n\t\tfor (const resource of this.activeOutOfWorkspaceWatchers.keys()) {\n\t\t\tif (!visibleOutOfWorkspaceResources.has(resource)) {\n\t\t\t\tdispose(this.activeOutOfWorkspaceWatchers.get(resource));\n\t\t\t\tthis.activeOutOfWorkspaceWatchers.delete(resource);\n\t\t\t}\n\t\t}\n\n\t\t// Handle newly visible out of workspace resources\n\t\tfor (const resource of visibleOutOfWorkspaceResources.keys()) {\n\t\t\tif (!this.activeOutOfWorkspaceWatchers.get(resource)) {\n\t\t\t\tconst disposable = this.fileService.watch(resource);\n\t\t\t\tthis.activeOutOfWorkspaceWatchers.set(resource, disposable);\n\t\t\t}\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Changes: Move & Deletes to move or close opend editors\n\n\tprivate async onDidRunFileOperation(e: FileOperationEvent): Promise<void> {\n\n\t\t// Handle moves specially when file is opened\n\t\tif (e.isOperation(FileOperation.MOVE)) {\n\t\t\tthis.handleMovedFile(e.resource, e.target.resource);\n\t\t}\n\n\t\t// Handle deletes\n\t\tif (e.isOperation(FileOperation.DELETE) || e.isOperation(FileOperation.MOVE)) {\n\t\t\tthis.handleDeletedFile(e.resource, false, e.target ? e.target.resource : undefined);\n\t\t}\n\t}\n\n\tprivate onDidFilesChange(e: FileChangesEvent): void {\n\t\tif (e.gotDeleted()) {\n\t\t\tthis.handleDeletedFile(e, true);\n\t\t}\n\t}\n\n\tprivate async handleMovedFile(source: URI, target: URI): Promise<void> {\n\t\tfor (const group of this.editorGroupsContainer.groups) {\n\t\t\tconst replacements: (IUntypedEditorReplacement | IEditorReplacement)[] = [];\n\n\t\t\tfor (const editor of group.editors) {\n\t\t\t\tconst resource = editor.resource;\n\t\t\t\tif (!resource || !this.uriIdentityService.extUri.isEqualOrParent(resource, source)) {\n\t\t\t\t\tcontinue; // not matching our resource\n\t\t\t\t}\n\n\t\t\t\t// Determine new resulting target resource\n\t\t\t\tlet targetResource: URI;\n\t\t\t\tif (this.uriIdentityService.extUri.isEqual(source, resource)) {\n\t\t\t\t\ttargetResource = target; // file got moved\n\t\t\t\t} else {\n\t\t\t\t\tconst index = indexOfPath(resource.path, source.path, this.uriIdentityService.extUri.ignorePathCasing(resource));\n\t\t\t\t\ttargetResource = joinPath(target, resource.path.substr(index + source.path.length + 1)); // parent folder got moved\n\t\t\t\t}\n\n\t\t\t\t// Delegate rename() to editor instance\n\t\t\t\tconst moveResult = await editor.rename(group.id, targetResource);\n\t\t\t\tif (!moveResult) {\n\t\t\t\t\treturn; // not target - ignore\n\t\t\t\t}\n\n\t\t\t\tconst optionOverrides = {\n\t\t\t\t\tpreserveFocus: true,\n\t\t\t\t\tpinned: group.isPinned(editor),\n\t\t\t\t\tsticky: group.isSticky(editor),\n\t\t\t\t\tindex: group.getIndexOfEditor(editor),\n\t\t\t\t\tinactive: !group.isActive(editor)\n\t\t\t\t};\n\n\t\t\t\t// Construct a replacement with our extra options mixed in\n\t\t\t\tif (isEditorInput(moveResult.editor)) {\n\t\t\t\t\treplacements.push({\n\t\t\t\t\t\teditor,\n\t\t\t\t\t\treplacement: moveResult.editor,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t...moveResult.options,\n\t\t\t\t\t\t\t...optionOverrides\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treplacements.push({\n\t\t\t\t\t\teditor,\n\t\t\t\t\t\treplacement: {\n\t\t\t\t\t\t\t...moveResult.editor,\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t...moveResult.editor.options,\n\t\t\t\t\t\t\t\t...optionOverrides\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply replacements\n\t\t\tif (replacements.length) {\n\t\t\t\tthis.replaceEditors(replacements, group);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate closeOnFileDelete = false;\n\n\tprivate onConfigurationUpdated(e?: IConfigurationChangeEvent): void {\n\t\tif (e && !e.affectsConfiguration('workbench.editor.closeOnFileDelete')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst configuration = this.configurationService.getValue<IWorkbenchEditorConfiguration>();\n\t\tif (typeof configuration.workbench?.editor?.closeOnFileDelete === 'boolean') {\n\t\t\tthis.closeOnFileDelete = configuration.workbench.editor.closeOnFileDelete;\n\t\t} else {\n\t\t\tthis.closeOnFileDelete = false; // default\n\t\t}\n\t}\n\n\tprivate handleDeletedFile(arg1: URI | FileChangesEvent, isExternal: boolean, movedTo?: URI): void {\n\t\tfor (const editor of this.getAllNonDirtyEditors({ includeUntitled: false, supportSideBySide: true })) {\n\t\t\t(async () => {\n\t\t\t\tconst resource = editor.resource;\n\t\t\t\tif (!resource) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Handle deletes in opened editors depending on:\n\t\t\t\t// - we close any editor when `closeOnFileDelete: true`\n\t\t\t\t// - we close any editor when the delete occurred from within VSCode\n\t\t\t\tif (this.closeOnFileDelete || !isExternal) {\n\n\t\t\t\t\t// Do NOT close any opened editor that matches the resource path (either equal or being parent) of the\n\t\t\t\t\t// resource we move to (movedTo). Otherwise we would close a resource that has been renamed to the same\n\t\t\t\t\t// path but different casing.\n\t\t\t\t\tif (movedTo && this.uriIdentityService.extUri.isEqualOrParent(resource, movedTo)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet matches = false;\n\t\t\t\t\tif (arg1 instanceof FileChangesEvent) {\n\t\t\t\t\t\tmatches = arg1.contains(resource, FileChangeType.DELETED);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatches = this.uriIdentityService.extUri.isEqualOrParent(resource, arg1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!matches) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We have received reports of users seeing delete events even though the file still\n\t\t\t\t\t// exists (network shares issue: https://github.com/microsoft/vscode/issues/13665).\n\t\t\t\t\t// Since we do not want to close an editor without reason, we have to check if the\n\t\t\t\t\t// file is really gone and not just a faulty file event.\n\t\t\t\t\t// This only applies to external file events, so we need to check for the isExternal\n\t\t\t\t\t// flag.\n\t\t\t\t\tlet exists = false;\n\t\t\t\t\tif (isExternal && this.fileService.hasProvider(resource)) {\n\t\t\t\t\t\tawait timeout(100);\n\t\t\t\t\t\texists = await this.fileService.exists(resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!exists && !editor.isDisposed()) {\n\t\t\t\t\t\teditor.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t}\n\n\tprivate getAllNonDirtyEditors(options: { includeUntitled: boolean; supportSideBySide: boolean }): EditorInput[] {\n\t\tconst editors: EditorInput[] = [];\n\n\t\tfunction conditionallyAddEditor(editor: EditorInput): void {\n\t\t\tif (editor.hasCapability(EditorInputCapabilities.Untitled) && !options.includeUntitled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (editor.isDirty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\teditors.push(editor);\n\t\t}\n\n\t\tfor (const editor of this.editors) {\n\t\t\tif (options.supportSideBySide && editor instanceof SideBySideEditorInput) {\n\t\t\t\tconditionallyAddEditor(editor.primary);\n\t\t\t\tconditionallyAddEditor(editor.secondary);\n\t\t\t} else {\n\t\t\t\tconditionallyAddEditor(editor);\n\t\t\t}\n\t\t}\n\n\t\treturn editors;\n\t}\n\n\t//#endregion\n\n\t//#region Editor accessors\n\n\tprivate readonly editorsObserver: EditorsObserver;\n\n\tget activeEditorPane(): IVisibleEditorPane | undefined {\n\t\treturn this.editorGroupsContainer.activeGroup?.activeEditorPane;\n\t}\n\n\tget activeTextEditorControl(): ICodeEditor | IDiffEditor | undefined {\n\t\tconst activeEditorPane = this.activeEditorPane;\n\t\tif (activeEditorPane) {\n\t\t\tconst activeControl = activeEditorPane.getControl();\n\t\t\tif (isCodeEditor(activeControl) || isDiffEditor(activeControl)) {\n\t\t\t\treturn activeControl;\n\t\t\t}\n\t\t\tif (isCompositeEditor(activeControl) && isCodeEditor(activeControl.activeCodeEditor)) {\n\t\t\t\treturn activeControl.activeCodeEditor;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tget activeTextEditorLanguageId(): string | undefined {\n\t\tlet activeCodeEditor: ICodeEditor | undefined = undefined;\n\n\t\tconst activeTextEditorControl = this.activeTextEditorControl;\n\t\tif (isDiffEditor(activeTextEditorControl)) {\n\t\t\tactiveCodeEditor = activeTextEditorControl.getModifiedEditor();\n\t\t} else {\n\t\t\tactiveCodeEditor = activeTextEditorControl;\n\t\t}\n\n\t\treturn activeCodeEditor?.getModel()?.getLanguageId();\n\t}\n\n\tget count(): number {\n\t\treturn this.editorsObserver.count;\n\t}\n\n\tget editors(): EditorInput[] {\n\t\treturn this.getEditors(EditorsOrder.SEQUENTIAL).map(({ editor }) => editor);\n\t}\n\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): IEditorIdentifier[] {\n\t\tswitch (order) {\n\n\t\t\t// MRU\n\t\t\tcase EditorsOrder.MOST_RECENTLY_ACTIVE:\n\t\t\t\tif (options?.excludeSticky) {\n\t\t\t\t\treturn this.editorsObserver.editors.filter(({ groupId, editor }) => !this.editorGroupsContainer.getGroup(groupId)?.isSticky(editor));\n\t\t\t\t}\n\n\t\t\t\treturn this.editorsObserver.editors;\n\n\t\t\t// Sequential\n\t\t\tcase EditorsOrder.SEQUENTIAL: {\n\t\t\t\tconst editors: IEditorIdentifier[] = [];\n\n\t\t\t\tfor (const group of this.editorGroupsContainer.getGroups(GroupsOrder.GRID_APPEARANCE)) {\n\t\t\t\t\teditors.push(...group.getEditors(EditorsOrder.SEQUENTIAL, options).map(editor => ({ editor, groupId: group.id })));\n\t\t\t\t}\n\n\t\t\t\treturn editors;\n\t\t\t}\n\t\t}\n\t}\n\n\tget activeEditor(): EditorInput | undefined {\n\t\tconst activeGroup = this.editorGroupsContainer.activeGroup;\n\n\t\treturn activeGroup ? activeGroup.activeEditor ?? undefined : undefined;\n\t}\n\n\tget visibleEditorPanes(): IVisibleEditorPane[] {\n\t\treturn coalesce(this.editorGroupsContainer.groups.map(group => group.activeEditorPane));\n\t}\n\n\tget visibleTextEditorControls(): Array<ICodeEditor | IDiffEditor> {\n\t\treturn this.doGetVisibleTextEditorControls(this.visibleEditorPanes);\n\t}\n\n\tprivate doGetVisibleTextEditorControls(editorPanes: IVisibleEditorPane[]): Array<ICodeEditor | IDiffEditor> {\n\t\tconst visibleTextEditorControls: Array<ICodeEditor | IDiffEditor> = [];\n\t\tfor (const editorPane of editorPanes) {\n\t\t\tconst controls: Array<IEditorControl | undefined> = [];\n\t\t\tif (editorPane instanceof SideBySideEditorPane) {\n\t\t\t\tcontrols.push(editorPane.getPrimaryEditorPane()?.getControl());\n\t\t\t\tcontrols.push(editorPane.getSecondaryEditorPane()?.getControl());\n\t\t\t} else {\n\t\t\t\tcontrols.push(editorPane.getControl());\n\t\t\t}\n\n\t\t\tfor (const control of controls) {\n\t\t\t\tif (isCodeEditor(control) || isDiffEditor(control)) {\n\t\t\t\t\tvisibleTextEditorControls.push(control);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn visibleTextEditorControls;\n\t}\n\n\tgetVisibleTextEditorControls(order: EditorsOrder): readonly (ICodeEditor | IDiffEditor)[] {\n\t\treturn this.doGetVisibleTextEditorControls(coalesce(this.editorGroupsContainer.getGroups(order === EditorsOrder.SEQUENTIAL ? GroupsOrder.GRID_APPEARANCE : GroupsOrder.MOST_RECENTLY_ACTIVE).map(group => group.activeEditorPane)));\n\t}\n\n\tget visibleEditors(): EditorInput[] {\n\t\treturn coalesce(this.editorGroupsContainer.groups.map(group => group.activeEditor));\n\t}\n\n\t//#endregion\n\n\t//#region openEditor()\n\n\topenEditor(editor: EditorInput, options?: IEditorOptions, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: IUntypedEditorInput, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: IResourceEditorInput, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: ITextResourceEditorInput | IUntitledTextResourceEditorInput, group?: PreferredGroup): Promise<IEditorPane | undefined>;\n\topenEditor(editor: ITextResourceDiffEditorInput, group?: PreferredGroup): Promise<ITextDiffEditorPane | undefined>;\n\topenEditor(editor: IResourceDiffEditorInput, group?: PreferredGroup): Promise<ITextDiffEditorPane | undefined>;\n\topenEditor(editor: EditorInput | IUntypedEditorInput, optionsOrPreferredGroup?: IEditorOptions | PreferredGroup, preferredGroup?: PreferredGroup): Promise<IEditorPane | undefined>;\n\tasync openEditor(editor: EditorInput | IUntypedEditorInput, optionsOrPreferredGroup?: IEditorOptions | PreferredGroup, preferredGroup?: PreferredGroup): Promise<IEditorPane | undefined> {\n\t\tlet typedEditor: EditorInput | undefined = undefined;\n\t\tlet options = isEditorInput(editor) ? optionsOrPreferredGroup as IEditorOptions : editor.options;\n\t\tlet group: IEditorGroup | undefined = undefined;\n\n\t\tif (isPreferredGroup(optionsOrPreferredGroup)) {\n\t\t\tpreferredGroup = optionsOrPreferredGroup;\n\t\t}\n\n\t\t// Resolve override unless disabled\n\t\tif (!isEditorInput(editor)) {\n\t\t\tconst resolvedEditor = await this.editorResolverService.resolveEditor(editor, preferredGroup);\n\n\t\t\tif (resolvedEditor === ResolvedStatus.ABORT) {\n\t\t\t\treturn; // skip editor if override is aborted\n\t\t\t}\n\n\t\t\t// We resolved an editor to use\n\t\t\tif (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n\t\t\t\ttypedEditor = resolvedEditor.editor;\n\t\t\t\toptions = resolvedEditor.options;\n\t\t\t\tgroup = resolvedEditor.group;\n\t\t\t}\n\t\t}\n\n\t\t// Override is disabled or did not apply: fallback to default\n\t\tif (!typedEditor) {\n\t\t\ttypedEditor = isEditorInput(editor) ? editor : await this.textEditorService.resolveTextEditor(editor);\n\t\t}\n\n\t\t// If group still isn't defined because of a disabled override we resolve it\n\t\tif (!group) {\n\t\t\tlet activation: EditorActivation | undefined = undefined;\n\t\t\tconst findGroupResult = this.instantiationService.invokeFunction(findGroup, { editor: typedEditor, options }, preferredGroup);\n\t\t\tif (findGroupResult instanceof Promise) {\n\t\t\t\t([group, activation] = await findGroupResult);\n\t\t\t} else {\n\t\t\t\t([group, activation] = findGroupResult);\n\t\t\t}\n\n\t\t\t// Mixin editor group activation if returned\n\t\t\tif (activation) {\n\t\t\t\toptions = { ...options, activation };\n\t\t\t}\n\t\t}\n\n\t\treturn group.openEditor(typedEditor, options);\n\t}\n\n\t//#endregion\n\n\t//#region openEditors()\n\n\topenEditors(editors: EditorInputWithOptions[], group?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]>;\n\topenEditors(editors: IUntypedEditorInput[], group?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]>;\n\topenEditors(editors: Array<EditorInputWithOptions | IUntypedEditorInput>, group?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]>;\n\tasync openEditors(editors: Array<EditorInputWithOptions | IUntypedEditorInput>, preferredGroup?: PreferredGroup, options?: IOpenEditorsOptions): Promise<IEditorPane[]> {\n\n\t\t// Pass all editors to trust service to determine if\n\t\t// we should proceed with opening the editors if we\n\t\t// are asked to validate trust.\n\t\tif (options?.validateTrust) {\n\t\t\tconst editorsTrusted = await this.handleWorkspaceTrust(editors);\n\t\t\tif (!editorsTrusted) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\t// Find target groups for editors to open\n\t\tconst mapGroupToTypedEditors = new Map<IEditorGroup, Array<EditorInputWithOptions>>();\n\t\tfor (const editor of editors) {\n\t\t\tlet typedEditor: EditorInputWithOptions | undefined = undefined;\n\t\t\tlet group: IEditorGroup | undefined = undefined;\n\n\t\t\t// Resolve override unless disabled\n\t\t\tif (!isEditorInputWithOptions(editor)) {\n\t\t\t\tconst resolvedEditor = await this.editorResolverService.resolveEditor(editor, preferredGroup);\n\n\t\t\t\tif (resolvedEditor === ResolvedStatus.ABORT) {\n\t\t\t\t\tcontinue; // skip editor if override is aborted\n\t\t\t\t}\n\n\t\t\t\t// We resolved an editor to use\n\t\t\t\tif (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n\t\t\t\t\ttypedEditor = resolvedEditor;\n\t\t\t\t\tgroup = resolvedEditor.group;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override is disabled or did not apply: fallback to default\n\t\t\tif (!typedEditor) {\n\t\t\t\ttypedEditor = isEditorInputWithOptions(editor) ? editor : { editor: await this.textEditorService.resolveTextEditor(editor), options: editor.options };\n\t\t\t}\n\n\t\t\t// If group still isn't defined because of a disabled override we resolve it\n\t\t\tif (!group) {\n\t\t\t\tconst findGroupResult = this.instantiationService.invokeFunction(findGroup, typedEditor, preferredGroup);\n\t\t\t\tif (findGroupResult instanceof Promise) {\n\t\t\t\t\t([group] = await findGroupResult);\n\t\t\t\t} else {\n\t\t\t\t\t([group] = findGroupResult);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update map of groups to editors\n\t\t\tlet targetGroupEditors = mapGroupToTypedEditors.get(group);\n\t\t\tif (!targetGroupEditors) {\n\t\t\t\ttargetGroupEditors = [];\n\t\t\t\tmapGroupToTypedEditors.set(group, targetGroupEditors);\n\t\t\t}\n\n\t\t\ttargetGroupEditors.push(typedEditor);\n\t\t}\n\n\t\t// Open in target groups\n\t\tconst result: Promise<IEditorPane | undefined>[] = [];\n\t\tfor (const [group, editors] of mapGroupToTypedEditors) {\n\t\t\tresult.push(group.openEditors(editors));\n\t\t}\n\n\t\treturn coalesce(await Promises.settled(result));\n\t}\n\n\tprivate async handleWorkspaceTrust(editors: Array<EditorInputWithOptions | IUntypedEditorInput>): Promise<boolean> {\n\t\tconst { resources, diffMode, mergeMode } = this.extractEditorResources(editors);\n\n\t\tconst trustResult = await this.workspaceTrustRequestService.requestOpenFilesTrust(resources);\n\t\tswitch (trustResult) {\n\t\t\tcase WorkspaceTrustUriResponse.Open:\n\t\t\t\treturn true;\n\t\t\tcase WorkspaceTrustUriResponse.OpenInNewWindow:\n\t\t\t\tawait this.hostService.openWindow(resources.map(resource => ({ fileUri: resource })), { forceNewWindow: true, diffMode, mergeMode });\n\t\t\t\treturn false;\n\t\t\tcase WorkspaceTrustUriResponse.Cancel:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate extractEditorResources(editors: Array<EditorInputWithOptions | IUntypedEditorInput>): { resources: URI[]; diffMode?: boolean; mergeMode?: boolean } {\n\t\tconst resources = new ResourceSet();\n\t\tlet diffMode = false;\n\t\tlet mergeMode = false;\n\n\t\tfor (const editor of editors) {\n\n\t\t\t// Typed Editor\n\t\t\tif (isEditorInputWithOptions(editor)) {\n\t\t\t\tconst resource = EditorResourceAccessor.getOriginalUri(editor.editor, { supportSideBySide: SideBySideEditor.BOTH });\n\t\t\t\tif (URI.isUri(resource)) {\n\t\t\t\t\tresources.add(resource);\n\t\t\t\t} else if (resource) {\n\t\t\t\t\tif (resource.primary) {\n\t\t\t\t\t\tresources.add(resource.primary);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (resource.secondary) {\n\t\t\t\t\t\tresources.add(resource.secondary);\n\t\t\t\t\t}\n\n\t\t\t\t\tdiffMode = editor.editor instanceof DiffEditorInput;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Untyped editor\n\t\t\telse {\n\t\t\t\tif (isResourceMergeEditorInput(editor)) {\n\t\t\t\t\tif (URI.isUri(editor.input1)) {\n\t\t\t\t\t\tresources.add(editor.input1.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.input2)) {\n\t\t\t\t\t\tresources.add(editor.input2.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.base)) {\n\t\t\t\t\t\tresources.add(editor.base.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.result)) {\n\t\t\t\t\t\tresources.add(editor.result.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tmergeMode = true;\n\t\t\t\t} if (isResourceDiffEditorInput(editor)) {\n\t\t\t\t\tif (URI.isUri(editor.original.resource)) {\n\t\t\t\t\t\tresources.add(editor.original.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (URI.isUri(editor.modified.resource)) {\n\t\t\t\t\t\tresources.add(editor.modified.resource);\n\t\t\t\t\t}\n\n\t\t\t\t\tdiffMode = true;\n\t\t\t\t} else if (isResourceEditorInput(editor)) {\n\t\t\t\t\tresources.add(editor.resource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tresources: Array.from(resources.keys()),\n\t\t\tdiffMode,\n\t\t\tmergeMode\n\t\t};\n\t}\n\n\t//#endregion\n\n\t//#region isOpened() / isVisible()\n\n\tisOpened(editor: IResourceEditorInputIdentifier): boolean {\n\t\treturn this.editorsObserver.hasEditor({\n\t\t\tresource: this.uriIdentityService.asCanonicalUri(editor.resource),\n\t\t\ttypeId: editor.typeId,\n\t\t\teditorId: editor.editorId\n\t\t});\n\t}\n\n\tisVisible(editor: EditorInput): boolean {\n\t\tfor (const group of this.editorGroupsContainer.groups) {\n\t\t\tif (group.activeEditor?.matches(editor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//#endregion\n\n\t//#region closeEditor()\n\n\tasync closeEditor({ editor, groupId }: IEditorIdentifier, options?: ICloseEditorOptions): Promise<void> {\n\t\tconst group = this.editorGroupsContainer.getGroup(groupId);\n\n\t\tawait group?.closeEditor(editor, options);\n\t}\n\n\t//#endregion\n\n\t//#region closeEditors()\n\n\tasync closeEditors(editors: IEditorIdentifier[], options?: ICloseEditorOptions): Promise<void> {\n\t\tconst mapGroupToEditors = new Map<IEditorGroup, EditorInput[]>();\n\n\t\tfor (const { editor, groupId } of editors) {\n\t\t\tconst group = this.editorGroupsContainer.getGroup(groupId);\n\t\t\tif (!group) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet editors = mapGroupToEditors.get(group);\n\t\t\tif (!editors) {\n\t\t\t\teditors = [];\n\t\t\t\tmapGroupToEditors.set(group, editors);\n\t\t\t}\n\n\t\t\teditors.push(editor);\n\t\t}\n\n\t\tfor (const [group, editors] of mapGroupToEditors) {\n\t\t\tawait group.closeEditors(editors, options);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region findEditors()\n\n\tfindEditors(resource: URI, options?: IFindEditorOptions): readonly IEditorIdentifier[];\n\tfindEditors(editor: IResourceEditorInputIdentifier, options?: IFindEditorOptions): readonly IEditorIdentifier[];\n\tfindEditors(resource: URI, options: IFindEditorOptions | undefined, group: IEditorGroup | GroupIdentifier): readonly EditorInput[];\n\tfindEditors(editor: IResourceEditorInputIdentifier, options: IFindEditorOptions | undefined, group: IEditorGroup | GroupIdentifier): EditorInput | undefined;\n\tfindEditors(arg1: URI | IResourceEditorInputIdentifier, options: IFindEditorOptions | undefined, arg2?: IEditorGroup | GroupIdentifier): readonly IEditorIdentifier[] | readonly EditorInput[] | EditorInput | undefined;\n\tfindEditors(arg1: URI | IResourceEditorInputIdentifier, options: IFindEditorOptions | undefined, arg2?: IEditorGroup | GroupIdentifier): readonly IEditorIdentifier[] | readonly EditorInput[] | EditorInput | undefined {\n\t\tconst resource = URI.isUri(arg1) ? arg1 : arg1.resource;\n\t\tconst typeId = URI.isUri(arg1) ? undefined : arg1.typeId;\n\n\t\t// Do a quick check for the resource via the editor observer\n\t\t// which is a very efficient way to find an editor by resource.\n\t\t// However, we can only do that unless we are asked to find an\n\t\t// editor on the secondary side of a side by side editor, because\n\t\t// the editor observer provides fast lookups only for primary\n\t\t// editors.\n\t\tif (options?.supportSideBySide !== SideBySideEditor.ANY && options?.supportSideBySide !== SideBySideEditor.SECONDARY) {\n\t\t\tif (!this.editorsObserver.hasEditors(resource)) {\n\t\t\t\tif (URI.isUri(arg1) || isUndefined(arg2)) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\t// Search only in specific group\n\t\tif (!isUndefined(arg2)) {\n\t\t\tconst targetGroup = typeof arg2 === 'number' ? this.editorGroupsContainer.getGroup(arg2) : arg2;\n\n\t\t\t// Resource provided: result is an array\n\t\t\tif (URI.isUri(arg1)) {\n\t\t\t\tif (!targetGroup) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\treturn targetGroup.findEditors(resource, options);\n\t\t\t}\n\n\t\t\t// Editor identifier provided, result is single\n\t\t\telse {\n\t\t\t\tif (!targetGroup) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tconst editors = targetGroup.findEditors(resource, options);\n\t\t\t\tfor (const editor of editors) {\n\t\t\t\t\tif (editor.typeId === typeId) {\n\t\t\t\t\t\treturn editor;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\t// Search across all groups in MRU order\n\t\telse {\n\t\t\tconst result: IEditorIdentifier[] = [];\n\n\t\t\tfor (const group of this.editorGroupsContainer.getGroups(options?.order === EditorsOrder.SEQUENTIAL ? GroupsOrder.GRID_APPEARANCE : GroupsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tconst editors: EditorInput[] = [];\n\n\t\t\t\t// Resource provided: result is an array\n\t\t\t\tif (URI.isUri(arg1)) {\n\t\t\t\t\teditors.push(...this.findEditors(arg1, options, group));\n\t\t\t\t}\n\n\t\t\t\t// Editor identifier provided, result is single\n\t\t\t\telse {\n\t\t\t\t\tconst editor = this.findEditors(arg1, options, group);\n\t\t\t\t\tif (editor) {\n\t\t\t\t\t\teditors.push(editor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.push(...editors.map(editor => ({ editor, groupId: group.id })));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region replaceEditors()\n\n\tasync replaceEditors(replacements: IUntypedEditorReplacement[], group: IEditorGroup | GroupIdentifier): Promise<void>;\n\tasync replaceEditors(replacements: IEditorReplacement[], group: IEditorGroup | GroupIdentifier): Promise<void>;\n\tasync replaceEditors(replacements: Array<IEditorReplacement | IUntypedEditorReplacement>, group: IEditorGroup | GroupIdentifier): Promise<void> {\n\t\tconst targetGroup = typeof group === 'number' ? this.editorGroupsContainer.getGroup(group) : group;\n\n\t\t// Convert all replacements to typed editors unless already\n\t\t// typed and handle overrides properly.\n\t\tconst typedReplacements: IEditorReplacement[] = [];\n\t\tfor (const replacement of replacements) {\n\t\t\tlet typedReplacement: IEditorReplacement | undefined = undefined;\n\n\t\t\t// Resolve override unless disabled\n\t\t\tif (!isEditorInput(replacement.replacement)) {\n\t\t\t\tconst resolvedEditor = await this.editorResolverService.resolveEditor(\n\t\t\t\t\treplacement.replacement,\n\t\t\t\t\ttargetGroup\n\t\t\t\t);\n\n\t\t\t\tif (resolvedEditor === ResolvedStatus.ABORT) {\n\t\t\t\t\tcontinue; // skip editor if override is aborted\n\t\t\t\t}\n\n\t\t\t\t// We resolved an editor to use\n\t\t\t\tif (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n\t\t\t\t\ttypedReplacement = {\n\t\t\t\t\t\teditor: replacement.editor,\n\t\t\t\t\t\treplacement: resolvedEditor.editor,\n\t\t\t\t\t\toptions: resolvedEditor.options,\n\t\t\t\t\t\tforceReplaceDirty: replacement.forceReplaceDirty\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override is disabled or did not apply: fallback to default\n\t\t\tif (!typedReplacement) {\n\t\t\t\ttypedReplacement = {\n\t\t\t\t\teditor: replacement.editor,\n\t\t\t\t\treplacement: isEditorReplacement(replacement) ? replacement.replacement : await this.textEditorService.resolveTextEditor(replacement.replacement),\n\t\t\t\t\toptions: isEditorReplacement(replacement) ? replacement.options : replacement.replacement.options,\n\t\t\t\t\tforceReplaceDirty: replacement.forceReplaceDirty\n\t\t\t\t};\n\t\t\t}\n\n\t\t\ttypedReplacements.push(typedReplacement);\n\t\t}\n\n\t\treturn targetGroup?.replaceEditors(typedReplacements);\n\t}\n\n\t//#endregion\n\n\t//#region save/revert\n\n\tasync save(editors: IEditorIdentifier | IEditorIdentifier[], options?: ISaveEditorsOptions): Promise<ISaveEditorsResult> {\n\n\t\t// Convert to array\n\t\tif (!Array.isArray(editors)) {\n\t\t\teditors = [editors];\n\t\t}\n\n\t\t// Make sure to not save the same editor multiple times\n\t\t// by using the `matches()` method to find duplicates\n\t\tconst uniqueEditors = this.getUniqueEditors(editors);\n\n\t\t// Split editors up into a bucket that is saved in parallel\n\t\t// and sequentially. Unless \"Save As\", all non-untitled editors\n\t\t// can be saved in parallel to speed up the operation. Remaining\n\t\t// editors are potentially bringing up some UI and thus run\n\t\t// sequentially.\n\t\tconst editorsToSaveParallel: IEditorIdentifier[] = [];\n\t\tconst editorsToSaveSequentially: IEditorIdentifier[] = [];\n\t\tif (options?.saveAs) {\n\t\t\teditorsToSaveSequentially.push(...uniqueEditors);\n\t\t} else {\n\t\t\tfor (const { groupId, editor } of uniqueEditors) {\n\t\t\t\tif (editor.hasCapability(EditorInputCapabilities.Untitled)) {\n\t\t\t\t\teditorsToSaveSequentially.push({ groupId, editor });\n\t\t\t\t} else {\n\t\t\t\t\teditorsToSaveParallel.push({ groupId, editor });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Editors to save in parallel\n\t\tconst saveResults = await Promises.settled(editorsToSaveParallel.map(({ groupId, editor }) => {\n\n\t\t\t// Use save as a hint to pin the editor if used explicitly\n\t\t\tif (options?.reason === SaveReason.EXPLICIT) {\n\t\t\t\tthis.editorGroupsContainer.getGroup(groupId)?.pinEditor(editor);\n\t\t\t}\n\n\t\t\t// Save\n\t\t\treturn editor.save(groupId, options);\n\t\t}));\n\n\t\t// Editors to save sequentially\n\t\tfor (const { groupId, editor } of editorsToSaveSequentially) {\n\t\t\tif (editor.isDisposed()) {\n\t\t\t\tcontinue; // might have been disposed from the save already\n\t\t\t}\n\n\t\t\t// Preserve view state by opening the editor first if the editor\n\t\t\t// is untitled or we \"Save As\". This also allows the user to review\n\t\t\t// the contents of the editor before making a decision.\n\t\t\tconst editorPane = await this.openEditor(editor, groupId);\n\t\t\tconst editorOptions: IEditorOptions = {\n\t\t\t\tpinned: true,\n\t\t\t\tviewState: editorPane?.getViewState()\n\t\t\t};\n\n\t\t\tconst result = options?.saveAs ? await editor.saveAs(groupId, options) : await editor.save(groupId, options);\n\t\t\tsaveResults.push(result);\n\n\t\t\tif (!result) {\n\t\t\t\tbreak; // failed or cancelled, abort\n\t\t\t}\n\n\t\t\t// Replace editor preserving viewstate (either across all groups or\n\t\t\t// only selected group) if the resulting editor is different from the\n\t\t\t// current one.\n\t\t\tif (!editor.matches(result)) {\n\t\t\t\tconst targetGroups = editor.hasCapability(EditorInputCapabilities.Untitled) ? this.editorGroupsContainer.groups.map(group => group.id) /* untitled replaces across all groups */ : [groupId];\n\t\t\t\tfor (const targetGroup of targetGroups) {\n\t\t\t\t\tif (result instanceof EditorInput) {\n\t\t\t\t\t\tawait this.replaceEditors([{ editor, replacement: result, options: editorOptions }], targetGroup);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tawait this.replaceEditors([{ editor, replacement: { ...result, options: editorOptions } }], targetGroup);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tsuccess: saveResults.every(result => !!result),\n\t\t\teditors: coalesce(saveResults)\n\t\t};\n\t}\n\n\tsaveAll(options?: ISaveAllEditorsOptions): Promise<ISaveEditorsResult> {\n\t\treturn this.save(this.getAllModifiedEditors(options), options);\n\t}\n\n\tasync revert(editors: IEditorIdentifier | IEditorIdentifier[], options?: IRevertOptions): Promise<boolean> {\n\n\t\t// Convert to array\n\t\tif (!Array.isArray(editors)) {\n\t\t\teditors = [editors];\n\t\t}\n\n\t\t// Make sure to not revert the same editor multiple times\n\t\t// by using the `matches()` method to find duplicates\n\t\tconst uniqueEditors = this.getUniqueEditors(editors);\n\n\t\tawait Promises.settled(uniqueEditors.map(async ({ groupId, editor }) => {\n\n\t\t\t// Use revert as a hint to pin the editor\n\t\t\tthis.editorGroupsContainer.getGroup(groupId)?.pinEditor(editor);\n\n\t\t\treturn editor.revert(groupId, options);\n\t\t}));\n\n\t\treturn !uniqueEditors.some(({ editor }) => editor.isDirty());\n\t}\n\n\tasync revertAll(options?: IRevertAllEditorsOptions): Promise<boolean> {\n\t\treturn this.revert(this.getAllModifiedEditors(options), options);\n\t}\n\n\tprivate getAllModifiedEditors(options?: IBaseSaveRevertAllEditorOptions): IEditorIdentifier[] {\n\t\tconst editors: IEditorIdentifier[] = [];\n\n\t\tfor (const group of this.editorGroupsContainer.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\tfor (const editor of group.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tif (!editor.isModified()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ((typeof options?.includeUntitled === 'boolean' || !options?.includeUntitled?.includeScratchpad)\n\t\t\t\t\t&& editor.hasCapability(EditorInputCapabilities.Scratchpad)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!options?.includeUntitled && editor.hasCapability(EditorInputCapabilities.Untitled)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (options?.excludeSticky && group.isSticky(editor)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\teditors.push({ groupId: group.id, editor });\n\t\t\t}\n\t\t}\n\n\t\treturn editors;\n\t}\n\n\tprivate getUniqueEditors(editors: IEditorIdentifier[]): IEditorIdentifier[] {\n\t\tconst uniqueEditors: IEditorIdentifier[] = [];\n\t\tfor (const { editor, groupId } of editors) {\n\t\t\tif (uniqueEditors.some(uniqueEditor => uniqueEditor.editor.matches(editor))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuniqueEditors.push({ editor, groupId });\n\t\t}\n\n\t\treturn uniqueEditors;\n\t}\n\n\t//#endregion\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Dispose remaining watchers if any\n\t\tthis.activeOutOfWorkspaceWatchers.forEach(disposable => dispose(disposable));\n\t\tthis.activeOutOfWorkspaceWatchers.clear();\n\t}\n}\n\nregisterSingleton(IEditorService, new SyncDescriptor(EditorService, [undefined], false));\n"]}