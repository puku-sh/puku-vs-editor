{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/editor/common/editorGroupFinder.ts","vs/workbench/services/editor/common/editorGroupFinder.ts"],"names":[],"mappings":"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","file":"editorGroupFinder.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { EditorActivation } from '../../../../platform/editor/common/editor.js';\nimport { ServicesAccessor } from '../../../../platform/instantiation/common/instantiation.js';\nimport { EditorInputWithOptions, isEditorInputWithOptions, IUntypedEditorInput, isEditorInput, EditorInputCapabilities } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorGroup, GroupsOrder, preferredSideBySideGroupDirection, IEditorGroupsService } from './editorGroupsService.js';\nimport { AUX_WINDOW_GROUP, AUX_WINDOW_GROUP_TYPE, PreferredGroup, SIDE_GROUP } from './editorService.js';\n\n/**\n * Finds the target `IEditorGroup` given the instructions provided\n * that is best for the editor and matches the preferred group if\n * possible.\n */\nexport function findGroup(accessor: ServicesAccessor, editor: IUntypedEditorInput, preferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions, preferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: IUntypedEditorInput, preferredGroup: AUX_WINDOW_GROUP_TYPE): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions, preferredGroup: AUX_WINDOW_GROUP_TYPE): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: AUX_WINDOW_GROUP_TYPE): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined): Promise<[IEditorGroup, EditorActivation | undefined]> | [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined): Promise<[IEditorGroup, EditorActivation | undefined]> | [IEditorGroup, EditorActivation | undefined] {\n\tconst editorGroupService = accessor.get(IEditorGroupsService);\n\tconst configurationService = accessor.get(IConfigurationService);\n\n\tconst group = doFindGroup(editor, preferredGroup, editorGroupService, configurationService);\n\tif (group instanceof Promise) {\n\t\treturn group.then(group => handleGroupActivation(group, editor, preferredGroup, editorGroupService));\n\t}\n\n\treturn handleGroupActivation(group, editor, preferredGroup, editorGroupService);\n}\n\nfunction handleGroupActivation(group: IEditorGroup, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined, editorGroupService: IEditorGroupsService): [IEditorGroup, EditorActivation | undefined] {\n\n\t// Resolve editor activation strategy\n\tlet activation: EditorActivation | undefined = undefined;\n\tif (\n\t\teditorGroupService.activeGroup !== group && \t\t// only if target group is not already active\n\t\teditor.options && !editor.options.inactive &&\t\t// never for inactive editors\n\t\teditor.options.preserveFocus &&\t\t\t\t\t\t// only if preserveFocus\n\t\ttypeof editor.options.activation !== 'number' &&\t// only if activation is not already defined (either true or false)\n\t\tpreferredGroup !== SIDE_GROUP\t\t\t\t\t\t// never for the SIDE_GROUP\n\t) {\n\t\t// If the resolved group is not the active one, we typically\n\t\t// want the group to become active. There are a few cases\n\t\t// where we stay away from encorcing this, e.g. if the caller\n\t\t// is already providing `activation`.\n\t\t//\n\t\t// Specifically for historic reasons we do not activate a\n\t\t// group is it is opened as `SIDE_GROUP` with `preserveFocus:true`.\n\t\t// repeated Alt-clicking of files in the explorer always open\n\t\t// into the same side group and not cause a group to be created each time.\n\t\tactivation = EditorActivation.ACTIVATE;\n\t}\n\n\treturn [group, activation];\n}\n\nfunction doFindGroup(input: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined, editorGroupService: IEditorGroupsService, configurationService: IConfigurationService): Promise<IEditorGroup> | IEditorGroup {\n\tlet group: Promise<IEditorGroup> | IEditorGroup | undefined;\n\tconst editor = isEditorInputWithOptions(input) ? input.editor : input;\n\tconst options = input.options;\n\n\t// Group: Instance of Group\n\tif (preferredGroup && typeof preferredGroup !== 'number') {\n\t\tgroup = preferredGroup;\n\t}\n\n\t// Group: Specific Group\n\telse if (typeof preferredGroup === 'number' && preferredGroup >= 0) {\n\t\tgroup = editorGroupService.getGroup(preferredGroup);\n\t}\n\n\t// Group: Side by Side\n\telse if (preferredGroup === SIDE_GROUP) {\n\t\tconst direction = preferredSideBySideGroupDirection(configurationService);\n\n\t\tlet candidateGroup = editorGroupService.findGroup({ direction });\n\t\tif (!candidateGroup || isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\t// Create new group either when the candidate group\n\t\t\t// is locked or was not found in the direction\n\t\t\tcandidateGroup = editorGroupService.addGroup(editorGroupService.activeGroup, direction);\n\t\t}\n\n\t\tgroup = candidateGroup;\n\t}\n\n\t// Group: Aux Window\n\telse if (preferredGroup === AUX_WINDOW_GROUP) {\n\t\tgroup = editorGroupService.createAuxiliaryEditorPart({\n\t\t\tbounds: options?.auxiliary?.bounds,\n\t\t\tcompact: options?.auxiliary?.compact,\n\t\t\talwaysOnTop: options?.auxiliary?.alwaysOnTop\n\t\t}).then(group => group.activeGroup);\n\t}\n\n\t// Group: Unspecified without a specific index to open\n\telse if (!options || typeof options.index !== 'number') {\n\t\tconst groupsByLastActive = editorGroupService.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE);\n\n\t\t// Respect option to reveal an editor if it is already visible in any group\n\t\tif (options?.revealIfVisible) {\n\t\t\tfor (const lastActiveGroup of groupsByLastActive) {\n\t\t\t\tif (isActive(lastActiveGroup, editor)) {\n\t\t\t\t\tgroup = lastActiveGroup;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Respect option to reveal an editor if it is open (not necessarily visible)\n\t\t// Still prefer to reveal an editor in a group where the editor is active though.\n\t\t// We also try to reveal an editor if it has the `Singleton` capability which\n\t\t// indicates that the same editor cannot be opened across groups.\n\t\tif (!group) {\n\t\t\tif (options?.revealIfOpened || configurationService.getValue<boolean>('workbench.editor.revealIfOpen') || (isEditorInput(editor) && editor.hasCapability(EditorInputCapabilities.Singleton))) {\n\t\t\t\tlet groupWithInputActive: IEditorGroup | undefined = undefined;\n\t\t\t\tlet groupWithInputOpened: IEditorGroup | undefined = undefined;\n\n\t\t\t\tfor (const group of groupsByLastActive) {\n\t\t\t\t\tif (isOpened(group, editor)) {\n\t\t\t\t\t\tif (!groupWithInputOpened) {\n\t\t\t\t\t\t\tgroupWithInputOpened = group;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!groupWithInputActive && group.isActive(editor)) {\n\t\t\t\t\t\t\tgroupWithInputActive = group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (groupWithInputOpened && groupWithInputActive) {\n\t\t\t\t\t\tbreak; // we found all groups we wanted\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Prefer a target group where the input is visible\n\t\t\t\tgroup = groupWithInputActive || groupWithInputOpened;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to active group if target not valid but avoid\n\t// locked editor groups unless editor is already opened there\n\tif (!group) {\n\t\tlet candidateGroup = editorGroupService.activeGroup;\n\n\t\t// Locked group: find the next non-locked group\n\t\t// going up the neigbours of the group or create\n\t\t// a new group otherwise\n\t\tif (isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\tfor (const group of editorGroupService.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tif (isGroupLockedForEditor(group, editor)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcandidateGroup = group;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\t\t// Group is still locked, so we have to create a new\n\t\t\t\t// group to the side of the candidate group\n\t\t\t\tgroup = editorGroupService.addGroup(candidateGroup, preferredSideBySideGroupDirection(configurationService));\n\t\t\t} else {\n\t\t\t\tgroup = candidateGroup;\n\t\t\t}\n\t\t}\n\n\t\t// Non-locked group: take as is\n\t\telse {\n\t\t\tgroup = candidateGroup;\n\t\t}\n\t}\n\n\treturn group;\n}\n\nfunction isGroupLockedForEditor(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tif (!group.isLocked) {\n\t\t// only relevant for locked editor groups\n\t\treturn false;\n\t}\n\n\tif (isOpened(group, editor)) {\n\t\t// special case: the locked group contains\n\t\t// the provided editor. in that case we do not want\n\t\t// to open the editor in any different group.\n\t\treturn false;\n\t}\n\n\t// group is locked for this editor\n\treturn true;\n}\n\nfunction isActive(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tif (!group.activeEditor) {\n\t\treturn false;\n\t}\n\n\treturn group.activeEditor.matches(editor);\n}\n\nfunction isOpened(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tfor (const typedEditor of group.editors) {\n\t\tif (typedEditor.matches(editor)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { EditorActivation } from '../../../../platform/editor/common/editor.js';\nimport { ServicesAccessor } from '../../../../platform/instantiation/common/instantiation.js';\nimport { EditorInputWithOptions, isEditorInputWithOptions, IUntypedEditorInput, isEditorInput, EditorInputCapabilities } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { IEditorGroup, GroupsOrder, preferredSideBySideGroupDirection, IEditorGroupsService } from './editorGroupsService.js';\nimport { AUX_WINDOW_GROUP, AUX_WINDOW_GROUP_TYPE, PreferredGroup, SIDE_GROUP } from './editorService.js';\n\n/**\n * Finds the target `IEditorGroup` given the instructions provided\n * that is best for the editor and matches the preferred group if\n * possible.\n */\nexport function findGroup(accessor: ServicesAccessor, editor: IUntypedEditorInput, preferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions, preferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: Exclude<PreferredGroup, AUX_WINDOW_GROUP_TYPE> | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: IUntypedEditorInput, preferredGroup: AUX_WINDOW_GROUP_TYPE): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions, preferredGroup: AUX_WINDOW_GROUP_TYPE): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: AUX_WINDOW_GROUP_TYPE): Promise<[IEditorGroup, EditorActivation | undefined]>;\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined): Promise<[IEditorGroup, EditorActivation | undefined]> | [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined): Promise<[IEditorGroup, EditorActivation | undefined]> | [IEditorGroup, EditorActivation | undefined] {\n\tconst editorGroupService = accessor.get(IEditorGroupsService);\n\tconst configurationService = accessor.get(IConfigurationService);\n\n\tconst group = doFindGroup(editor, preferredGroup, editorGroupService, configurationService);\n\tif (group instanceof Promise) {\n\t\treturn group.then(group => handleGroupActivation(group, editor, preferredGroup, editorGroupService));\n\t}\n\n\treturn handleGroupActivation(group, editor, preferredGroup, editorGroupService);\n}\n\nfunction handleGroupActivation(group: IEditorGroup, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined, editorGroupService: IEditorGroupsService): [IEditorGroup, EditorActivation | undefined] {\n\n\t// Resolve editor activation strategy\n\tlet activation: EditorActivation | undefined = undefined;\n\tif (\n\t\teditorGroupService.activeGroup !== group && \t\t// only if target group is not already active\n\t\teditor.options && !editor.options.inactive &&\t\t// never for inactive editors\n\t\teditor.options.preserveFocus &&\t\t\t\t\t\t// only if preserveFocus\n\t\ttypeof editor.options.activation !== 'number' &&\t// only if activation is not already defined (either true or false)\n\t\tpreferredGroup !== SIDE_GROUP\t\t\t\t\t\t// never for the SIDE_GROUP\n\t) {\n\t\t// If the resolved group is not the active one, we typically\n\t\t// want the group to become active. There are a few cases\n\t\t// where we stay away from encorcing this, e.g. if the caller\n\t\t// is already providing `activation`.\n\t\t//\n\t\t// Specifically for historic reasons we do not activate a\n\t\t// group is it is opened as `SIDE_GROUP` with `preserveFocus:true`.\n\t\t// repeated Alt-clicking of files in the explorer always open\n\t\t// into the same side group and not cause a group to be created each time.\n\t\tactivation = EditorActivation.ACTIVATE;\n\t}\n\n\treturn [group, activation];\n}\n\nfunction doFindGroup(input: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined, editorGroupService: IEditorGroupsService, configurationService: IConfigurationService): Promise<IEditorGroup> | IEditorGroup {\n\tlet group: Promise<IEditorGroup> | IEditorGroup | undefined;\n\tconst editor = isEditorInputWithOptions(input) ? input.editor : input;\n\tconst options = input.options;\n\n\t// Group: Instance of Group\n\tif (preferredGroup && typeof preferredGroup !== 'number') {\n\t\tgroup = preferredGroup;\n\t}\n\n\t// Group: Specific Group\n\telse if (typeof preferredGroup === 'number' && preferredGroup >= 0) {\n\t\tgroup = editorGroupService.getGroup(preferredGroup);\n\t}\n\n\t// Group: Side by Side\n\telse if (preferredGroup === SIDE_GROUP) {\n\t\tconst direction = preferredSideBySideGroupDirection(configurationService);\n\n\t\tlet candidateGroup = editorGroupService.findGroup({ direction });\n\t\tif (!candidateGroup || isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\t// Create new group either when the candidate group\n\t\t\t// is locked or was not found in the direction\n\t\t\tcandidateGroup = editorGroupService.addGroup(editorGroupService.activeGroup, direction);\n\t\t}\n\n\t\tgroup = candidateGroup;\n\t}\n\n\t// Group: Aux Window\n\telse if (preferredGroup === AUX_WINDOW_GROUP) {\n\t\tgroup = editorGroupService.createAuxiliaryEditorPart({\n\t\t\tbounds: options?.auxiliary?.bounds,\n\t\t\tcompact: options?.auxiliary?.compact,\n\t\t\talwaysOnTop: options?.auxiliary?.alwaysOnTop\n\t\t}).then(group => group.activeGroup);\n\t}\n\n\t// Group: Unspecified without a specific index to open\n\telse if (!options || typeof options.index !== 'number') {\n\t\tconst groupsByLastActive = editorGroupService.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE);\n\n\t\t// Respect option to reveal an editor if it is already visible in any group\n\t\tif (options?.revealIfVisible) {\n\t\t\tfor (const lastActiveGroup of groupsByLastActive) {\n\t\t\t\tif (isActive(lastActiveGroup, editor)) {\n\t\t\t\t\tgroup = lastActiveGroup;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Respect option to reveal an editor if it is open (not necessarily visible)\n\t\t// Still prefer to reveal an editor in a group where the editor is active though.\n\t\t// We also try to reveal an editor if it has the `Singleton` capability which\n\t\t// indicates that the same editor cannot be opened across groups.\n\t\tif (!group) {\n\t\t\tif (options?.revealIfOpened || configurationService.getValue<boolean>('workbench.editor.revealIfOpen') || (isEditorInput(editor) && editor.hasCapability(EditorInputCapabilities.Singleton))) {\n\t\t\t\tlet groupWithInputActive: IEditorGroup | undefined = undefined;\n\t\t\t\tlet groupWithInputOpened: IEditorGroup | undefined = undefined;\n\n\t\t\t\tfor (const group of groupsByLastActive) {\n\t\t\t\t\tif (isOpened(group, editor)) {\n\t\t\t\t\t\tif (!groupWithInputOpened) {\n\t\t\t\t\t\t\tgroupWithInputOpened = group;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!groupWithInputActive && group.isActive(editor)) {\n\t\t\t\t\t\t\tgroupWithInputActive = group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (groupWithInputOpened && groupWithInputActive) {\n\t\t\t\t\t\tbreak; // we found all groups we wanted\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Prefer a target group where the input is visible\n\t\t\t\tgroup = groupWithInputActive || groupWithInputOpened;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to active group if target not valid but avoid\n\t// locked editor groups unless editor is already opened there\n\tif (!group) {\n\t\tlet candidateGroup = editorGroupService.activeGroup;\n\n\t\t// Locked group: find the next non-locked group\n\t\t// going up the neigbours of the group or create\n\t\t// a new group otherwise\n\t\tif (isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\tfor (const group of editorGroupService.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tif (isGroupLockedForEditor(group, editor)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcandidateGroup = group;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\t\t// Group is still locked, so we have to create a new\n\t\t\t\t// group to the side of the candidate group\n\t\t\t\tgroup = editorGroupService.addGroup(candidateGroup, preferredSideBySideGroupDirection(configurationService));\n\t\t\t} else {\n\t\t\t\tgroup = candidateGroup;\n\t\t\t}\n\t\t}\n\n\t\t// Non-locked group: take as is\n\t\telse {\n\t\t\tgroup = candidateGroup;\n\t\t}\n\t}\n\n\treturn group;\n}\n\nfunction isGroupLockedForEditor(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tif (!group.isLocked) {\n\t\t// only relevant for locked editor groups\n\t\treturn false;\n\t}\n\n\tif (isOpened(group, editor)) {\n\t\t// special case: the locked group contains\n\t\t// the provided editor. in that case we do not want\n\t\t// to open the editor in any different group.\n\t\treturn false;\n\t}\n\n\t// group is locked for this editor\n\treturn true;\n}\n\nfunction isActive(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tif (!group.activeEditor) {\n\t\treturn false;\n\t}\n\n\treturn group.activeEditor.matches(editor);\n}\n\nfunction isOpened(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tfor (const typedEditor of group.editors) {\n\t\tif (typedEditor.matches(editor)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n"]}