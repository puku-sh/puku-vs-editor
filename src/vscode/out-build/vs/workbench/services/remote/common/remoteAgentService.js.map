{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/remote/common/remoteAgentService.ts","vs/workbench/services/remote/common/remoteAgentService.ts"],"names":[],"mappings":"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","file":"remoteAgentService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { RemoteAgentConnectionContext, IRemoteAgentEnvironment } from '../../../../platform/remote/common/remoteAgentEnvironment.js';\nimport { IChannel, IServerChannel } from '../../../../base/parts/ipc/common/ipc.js';\nimport { IDiagnosticInfoOptions, IDiagnosticInfo } from '../../../../platform/diagnostics/common/diagnostics.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { PersistentConnectionEvent } from '../../../../platform/remote/common/remoteAgentConnection.js';\nimport { ITelemetryData, TelemetryLevel } from '../../../../platform/telemetry/common/telemetry.js';\nimport { timeout } from '../../../../base/common/async.js';\n\nexport const IRemoteAgentService = createDecorator<IRemoteAgentService>('remoteAgentService');\n\nexport interface IRemoteAgentService {\n\treadonly _serviceBrand: undefined;\n\n\tgetConnection(): IRemoteAgentConnection | null;\n\t/**\n\t * Get the remote environment. In case of an error, returns `null`.\n\t */\n\tgetEnvironment(): Promise<IRemoteAgentEnvironment | null>;\n\t/**\n\t * Get the remote environment. Can return an error.\n\t */\n\tgetRawEnvironment(): Promise<IRemoteAgentEnvironment | null>;\n\t/**\n\t * Get exit information for a remote extension host.\n\t */\n\tgetExtensionHostExitInfo(reconnectionToken: string): Promise<IExtensionHostExitInfo | null>;\n\n\t/**\n\t * Gets the round trip time from the remote extension host. Note that this\n\t * may be delayed if the extension host is busy.\n\t */\n\tgetRoundTripTime(): Promise<number | undefined>;\n\n\t/**\n\t * Gracefully ends the current connection, if any.\n\t */\n\tendConnection(): Promise<void>;\n\n\tgetDiagnosticInfo(options: IDiagnosticInfoOptions): Promise<IDiagnosticInfo | undefined>;\n\tupdateTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void>;\n\tlogTelemetry(eventName: string, data?: ITelemetryData): Promise<void>;\n\tflushTelemetry(): Promise<void>;\n}\n\nexport interface IExtensionHostExitInfo {\n\tcode: number;\n\tsignal: string;\n}\n\nexport interface IRemoteAgentConnection {\n\treadonly remoteAuthority: string;\n\n\treadonly onReconnecting: Event<void>;\n\treadonly onDidStateChange: Event<PersistentConnectionEvent>;\n\n\tend(): Promise<void>;\n\tdispose(): void;\n\tgetChannel<T extends IChannel>(channelName: string): T;\n\twithChannel<T extends IChannel, R>(channelName: string, callback: (channel: T) => Promise<R>): Promise<R>;\n\tregisterChannel<T extends IServerChannel<RemoteAgentConnectionContext>>(channelName: string, channel: T): void;\n\tgetInitialConnectionTimeMs(): Promise<number>;\n\tupdateGraceTime(graceTime: number): void;\n}\n\nexport interface IRemoteConnectionLatencyMeasurement {\n\n\treadonly initial: number | undefined;\n\treadonly current: number;\n\treadonly average: number;\n\n\treadonly high: boolean;\n}\n\nexport const remoteConnectionLatencyMeasurer = new class {\n\n\treadonly maxSampleCount = 5;\n\treadonly sampleDelay = 2000;\n\n\treadonly initial: number[] = [];\n\treadonly maxInitialCount = 3;\n\n\treadonly average: number[] = [];\n\treadonly maxAverageCount = 100;\n\n\treadonly highLatencyMultiple = 2;\n\treadonly highLatencyMinThreshold = 500;\n\treadonly highLatencyMaxThreshold = 1500;\n\n\tlastMeasurement: IRemoteConnectionLatencyMeasurement | undefined = undefined;\n\tget latency() { return this.lastMeasurement; }\n\n\tasync measure(remoteAgentService: IRemoteAgentService): Promise<IRemoteConnectionLatencyMeasurement | undefined> {\n\t\tlet currentLatency = Infinity;\n\n\t\t// Measure up to samples count\n\t\tfor (let i = 0; i < this.maxSampleCount; i++) {\n\t\t\tconst rtt = await remoteAgentService.getRoundTripTime();\n\t\t\tif (rtt === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tcurrentLatency = Math.min(currentLatency, rtt / 2 /* we want just one way, not round trip time */);\n\t\t\tawait timeout(this.sampleDelay);\n\t\t}\n\n\t\t// Keep track of average latency\n\t\tthis.average.push(currentLatency);\n\t\tif (this.average.length > this.maxAverageCount) {\n\t\t\tthis.average.shift();\n\t\t}\n\n\t\t// Keep track of initial latency\n\t\tlet initialLatency: number | undefined = undefined;\n\t\tif (this.initial.length < this.maxInitialCount) {\n\t\t\tthis.initial.push(currentLatency);\n\t\t} else {\n\t\t\tinitialLatency = this.initial.reduce((sum, value) => sum + value, 0) / this.initial.length;\n\t\t}\n\n\t\t// Remember as last measurement\n\t\tthis.lastMeasurement = {\n\t\t\tinitial: initialLatency,\n\t\t\tcurrent: currentLatency,\n\t\t\taverage: this.average.reduce((sum, value) => sum + value, 0) / this.average.length,\n\t\t\thigh: (() => {\n\n\t\t\t\t// based on the initial, average and current latency, try to decide\n\t\t\t\t// if the connection has high latency\n\t\t\t\t// Some rules:\n\t\t\t\t// - we require the initial latency to be computed\n\t\t\t\t// - we only consider latency above highLatencyMinThreshold as potentially high\n\t\t\t\t// - we require the current latency to be above the average latency by a factor of highLatencyMultiple\n\t\t\t\t// - but not if the latency is actually above highLatencyMaxThreshold\n\n\t\t\t\tif (typeof initialLatency === 'undefined') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (currentLatency > this.highLatencyMaxThreshold) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (currentLatency > this.highLatencyMinThreshold && currentLatency > initialLatency * this.highLatencyMultiple) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t})()\n\t\t};\n\n\t\treturn this.lastMeasurement;\n\t}\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { RemoteAgentConnectionContext, IRemoteAgentEnvironment } from '../../../../platform/remote/common/remoteAgentEnvironment.js';\nimport { IChannel, IServerChannel } from '../../../../base/parts/ipc/common/ipc.js';\nimport { IDiagnosticInfoOptions, IDiagnosticInfo } from '../../../../platform/diagnostics/common/diagnostics.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { PersistentConnectionEvent } from '../../../../platform/remote/common/remoteAgentConnection.js';\nimport { ITelemetryData, TelemetryLevel } from '../../../../platform/telemetry/common/telemetry.js';\nimport { timeout } from '../../../../base/common/async.js';\n\nexport const IRemoteAgentService = createDecorator<IRemoteAgentService>('remoteAgentService');\n\nexport interface IRemoteAgentService {\n\treadonly _serviceBrand: undefined;\n\n\tgetConnection(): IRemoteAgentConnection | null;\n\t/**\n\t * Get the remote environment. In case of an error, returns `null`.\n\t */\n\tgetEnvironment(): Promise<IRemoteAgentEnvironment | null>;\n\t/**\n\t * Get the remote environment. Can return an error.\n\t */\n\tgetRawEnvironment(): Promise<IRemoteAgentEnvironment | null>;\n\t/**\n\t * Get exit information for a remote extension host.\n\t */\n\tgetExtensionHostExitInfo(reconnectionToken: string): Promise<IExtensionHostExitInfo | null>;\n\n\t/**\n\t * Gets the round trip time from the remote extension host. Note that this\n\t * may be delayed if the extension host is busy.\n\t */\n\tgetRoundTripTime(): Promise<number | undefined>;\n\n\t/**\n\t * Gracefully ends the current connection, if any.\n\t */\n\tendConnection(): Promise<void>;\n\n\tgetDiagnosticInfo(options: IDiagnosticInfoOptions): Promise<IDiagnosticInfo | undefined>;\n\tupdateTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void>;\n\tlogTelemetry(eventName: string, data?: ITelemetryData): Promise<void>;\n\tflushTelemetry(): Promise<void>;\n}\n\nexport interface IExtensionHostExitInfo {\n\tcode: number;\n\tsignal: string;\n}\n\nexport interface IRemoteAgentConnection {\n\treadonly remoteAuthority: string;\n\n\treadonly onReconnecting: Event<void>;\n\treadonly onDidStateChange: Event<PersistentConnectionEvent>;\n\n\tend(): Promise<void>;\n\tdispose(): void;\n\tgetChannel<T extends IChannel>(channelName: string): T;\n\twithChannel<T extends IChannel, R>(channelName: string, callback: (channel: T) => Promise<R>): Promise<R>;\n\tregisterChannel<T extends IServerChannel<RemoteAgentConnectionContext>>(channelName: string, channel: T): void;\n\tgetInitialConnectionTimeMs(): Promise<number>;\n\tupdateGraceTime(graceTime: number): void;\n}\n\nexport interface IRemoteConnectionLatencyMeasurement {\n\n\treadonly initial: number | undefined;\n\treadonly current: number;\n\treadonly average: number;\n\n\treadonly high: boolean;\n}\n\nexport const remoteConnectionLatencyMeasurer = new class {\n\n\treadonly maxSampleCount = 5;\n\treadonly sampleDelay = 2000;\n\n\treadonly initial: number[] = [];\n\treadonly maxInitialCount = 3;\n\n\treadonly average: number[] = [];\n\treadonly maxAverageCount = 100;\n\n\treadonly highLatencyMultiple = 2;\n\treadonly highLatencyMinThreshold = 500;\n\treadonly highLatencyMaxThreshold = 1500;\n\n\tlastMeasurement: IRemoteConnectionLatencyMeasurement | undefined = undefined;\n\tget latency() { return this.lastMeasurement; }\n\n\tasync measure(remoteAgentService: IRemoteAgentService): Promise<IRemoteConnectionLatencyMeasurement | undefined> {\n\t\tlet currentLatency = Infinity;\n\n\t\t// Measure up to samples count\n\t\tfor (let i = 0; i < this.maxSampleCount; i++) {\n\t\t\tconst rtt = await remoteAgentService.getRoundTripTime();\n\t\t\tif (rtt === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tcurrentLatency = Math.min(currentLatency, rtt / 2 /* we want just one way, not round trip time */);\n\t\t\tawait timeout(this.sampleDelay);\n\t\t}\n\n\t\t// Keep track of average latency\n\t\tthis.average.push(currentLatency);\n\t\tif (this.average.length > this.maxAverageCount) {\n\t\t\tthis.average.shift();\n\t\t}\n\n\t\t// Keep track of initial latency\n\t\tlet initialLatency: number | undefined = undefined;\n\t\tif (this.initial.length < this.maxInitialCount) {\n\t\t\tthis.initial.push(currentLatency);\n\t\t} else {\n\t\t\tinitialLatency = this.initial.reduce((sum, value) => sum + value, 0) / this.initial.length;\n\t\t}\n\n\t\t// Remember as last measurement\n\t\tthis.lastMeasurement = {\n\t\t\tinitial: initialLatency,\n\t\t\tcurrent: currentLatency,\n\t\t\taverage: this.average.reduce((sum, value) => sum + value, 0) / this.average.length,\n\t\t\thigh: (() => {\n\n\t\t\t\t// based on the initial, average and current latency, try to decide\n\t\t\t\t// if the connection has high latency\n\t\t\t\t// Some rules:\n\t\t\t\t// - we require the initial latency to be computed\n\t\t\t\t// - we only consider latency above highLatencyMinThreshold as potentially high\n\t\t\t\t// - we require the current latency to be above the average latency by a factor of highLatencyMultiple\n\t\t\t\t// - but not if the latency is actually above highLatencyMaxThreshold\n\n\t\t\t\tif (typeof initialLatency === 'undefined') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (currentLatency > this.highLatencyMaxThreshold) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (currentLatency > this.highLatencyMinThreshold && currentLatency > initialLatency * this.highLatencyMultiple) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t})()\n\t\t};\n\n\t\treturn this.lastMeasurement;\n\t}\n};\n"]}