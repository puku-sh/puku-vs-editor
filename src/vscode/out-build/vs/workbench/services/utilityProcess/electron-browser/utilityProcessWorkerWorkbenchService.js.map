{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/utilityProcess/electron-browser/utilityProcessWorkerWorkbenchService.ts","vs/workbench/services/utilityProcess/electron-browser/utilityProcessWorkerWorkbenchService.ts"],"names":[],"mappings":"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","file":"utilityProcessWorkerWorkbenchService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { IMainProcessService } from '../../../../platform/ipc/common/mainProcessService.js';\nimport { Client as MessagePortClient } from '../../../../base/parts/ipc/common/ipc.mp.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IPCClient, ProxyChannel } from '../../../../base/parts/ipc/common/ipc.js';\nimport { generateUuid } from '../../../../base/common/uuid.js';\nimport { acquirePort } from '../../../../base/parts/ipc/electron-browser/ipc.mp.js';\nimport { IOnDidTerminateUtilityrocessWorkerProcess, ipcUtilityProcessWorkerChannelName, IUtilityProcessWorkerProcess, IUtilityProcessWorkerService } from '../../../../platform/utilityProcess/common/utilityProcessWorkerService.js';\nimport { Barrier, timeout } from '../../../../base/common/async.js';\n\nexport const IUtilityProcessWorkerWorkbenchService = createDecorator<IUtilityProcessWorkerWorkbenchService>('utilityProcessWorkerWorkbenchService');\n\nexport interface IUtilityProcessWorker extends IDisposable {\n\n\t/**\n\t * A IPC client to communicate to the worker process.\n\t */\n\tclient: IPCClient<string>;\n\n\t/**\n\t * A promise that resolves to an object once the\n\t * worker process terminates, giving information\n\t * how the process terminated.\n\t *\n\t * This can be used to figure out whether the worker\n\t * should be restarted in case of an unexpected\n\t * termination.\n\t */\n\tonDidTerminate: Promise<IOnDidTerminateUtilityrocessWorkerProcess>;\n}\n\nexport interface IUtilityProcessWorkerWorkbenchService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Will fork a new process with the provided module identifier in a utility\n\t * process and establishes a message port connection to that process.\n\t *\n\t * Requires the forked process to be ES module that uses our IPC channel framework\n\t * to respond to the provided `channelName` as a server.\n\t *\n\t * The process will be automatically terminated when the workbench window closes,\n\t * crashes or loads/reloads.\n\t *\n\t * Note on affinity: repeated calls to `createWorkerChannel` with the same `moduleId`\n\t * from the same window will result in any previous forked process to get terminated.\n\t * In other words, it is not possible, nor intended to create multiple workers of\n\t * the same process from one window. The intent of these workers is to be reused per\n\t * window and the communication channel allows to dynamically update the processes\n\t * after the fact.\n\t *\n\t * @param process information around the process to fork as worker\n\t *\n\t * @returns the worker IPC client to communicate with. Provides a `dispose` method that\n\t * allows to terminate the worker if needed.\n\t */\n\tcreateWorker(process: IUtilityProcessWorkerProcess): Promise<IUtilityProcessWorker>;\n\n\t/**\n\t * Notifies the service that the workbench window has restored.\n\t */\n\tnotifyRestored(): void;\n}\n\nexport class UtilityProcessWorkerWorkbenchService extends Disposable implements IUtilityProcessWorkerWorkbenchService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _utilityProcessWorkerService: IUtilityProcessWorkerService | undefined = undefined;\n\tprivate get utilityProcessWorkerService(): IUtilityProcessWorkerService {\n\t\tif (!this._utilityProcessWorkerService) {\n\t\t\tconst channel = this.mainProcessService.getChannel(ipcUtilityProcessWorkerChannelName);\n\t\t\tthis._utilityProcessWorkerService = ProxyChannel.toService<IUtilityProcessWorkerService>(channel);\n\t\t}\n\n\t\treturn this._utilityProcessWorkerService;\n\t}\n\n\tprivate readonly restoredBarrier = new Barrier();\n\n\tconstructor(\n\t\treadonly windowId: number,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IMainProcessService private readonly mainProcessService: IMainProcessService\n\t) {\n\t\tsuper();\n\t}\n\n\tasync createWorker(process: IUtilityProcessWorkerProcess): Promise<IUtilityProcessWorker> {\n\t\tthis.logService.trace('Renderer->UtilityProcess#createWorker');\n\n\t\t// We want to avoid heavy utility process work to happen before\n\t\t// the window has restored. As such, make sure we await the\n\t\t// `Restored` phase before making a connection attempt, but also\n\t\t// add a timeout to be safe against possible deadlocks.\n\n\t\tawait Promise.race([this.restoredBarrier.wait(), timeout(2000)]);\n\n\t\t// Get ready to acquire the message port from the utility process worker\n\t\tconst nonce = generateUuid();\n\t\tconst responseChannel = 'vscode:createUtilityProcessWorkerMessageChannelResult';\n\t\tconst portPromise = acquirePort(undefined /* we trigger the request via service call! */, responseChannel, nonce);\n\n\t\t// Actually talk with the utility process service\n\t\t// to create a new process from a worker\n\t\tconst onDidTerminate = this.utilityProcessWorkerService.createWorker({\n\t\t\tprocess,\n\t\t\treply: { windowId: this.windowId, channel: responseChannel, nonce }\n\t\t});\n\n\t\t// Dispose worker upon disposal via utility process service\n\t\tconst disposables = new DisposableStore();\n\t\tdisposables.add(toDisposable(() => {\n\t\t\tthis.logService.trace('Renderer->UtilityProcess#disposeWorker', process);\n\n\t\t\tthis.utilityProcessWorkerService.disposeWorker({\n\t\t\t\tprocess,\n\t\t\t\treply: { windowId: this.windowId }\n\t\t\t});\n\t\t}));\n\n\t\tconst port = await portPromise;\n\t\tconst client = disposables.add(new MessagePortClient(port, `window:${this.windowId},module:${process.moduleId}`));\n\t\tthis.logService.trace('Renderer->UtilityProcess#createWorkerChannel: connection established');\n\n\t\tonDidTerminate.then(({ reason }) => {\n\t\t\tif (reason?.code === 0) {\n\t\t\t\tthis.logService.trace(`[UtilityProcessWorker]: terminated normally with code ${reason.code}, signal: ${reason.signal}`);\n\t\t\t} else {\n\t\t\t\tthis.logService.error(`[UtilityProcessWorker]: terminated unexpectedly with code ${reason?.code}, signal: ${reason?.signal}`);\n\t\t\t}\n\t\t});\n\n\t\treturn { client, onDidTerminate, dispose: () => disposables.dispose() };\n\t}\n\n\tnotifyRestored(): void {\n\t\tif (!this.restoredBarrier.isOpen()) {\n\t\t\tthis.restoredBarrier.open();\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { IMainProcessService } from '../../../../platform/ipc/common/mainProcessService.js';\nimport { Client as MessagePortClient } from '../../../../base/parts/ipc/common/ipc.mp.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IPCClient, ProxyChannel } from '../../../../base/parts/ipc/common/ipc.js';\nimport { generateUuid } from '../../../../base/common/uuid.js';\nimport { acquirePort } from '../../../../base/parts/ipc/electron-browser/ipc.mp.js';\nimport { IOnDidTerminateUtilityrocessWorkerProcess, ipcUtilityProcessWorkerChannelName, IUtilityProcessWorkerProcess, IUtilityProcessWorkerService } from '../../../../platform/utilityProcess/common/utilityProcessWorkerService.js';\nimport { Barrier, timeout } from '../../../../base/common/async.js';\n\nexport const IUtilityProcessWorkerWorkbenchService = createDecorator<IUtilityProcessWorkerWorkbenchService>('utilityProcessWorkerWorkbenchService');\n\nexport interface IUtilityProcessWorker extends IDisposable {\n\n\t/**\n\t * A IPC client to communicate to the worker process.\n\t */\n\tclient: IPCClient<string>;\n\n\t/**\n\t * A promise that resolves to an object once the\n\t * worker process terminates, giving information\n\t * how the process terminated.\n\t *\n\t * This can be used to figure out whether the worker\n\t * should be restarted in case of an unexpected\n\t * termination.\n\t */\n\tonDidTerminate: Promise<IOnDidTerminateUtilityrocessWorkerProcess>;\n}\n\nexport interface IUtilityProcessWorkerWorkbenchService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Will fork a new process with the provided module identifier in a utility\n\t * process and establishes a message port connection to that process.\n\t *\n\t * Requires the forked process to be ES module that uses our IPC channel framework\n\t * to respond to the provided `channelName` as a server.\n\t *\n\t * The process will be automatically terminated when the workbench window closes,\n\t * crashes or loads/reloads.\n\t *\n\t * Note on affinity: repeated calls to `createWorkerChannel` with the same `moduleId`\n\t * from the same window will result in any previous forked process to get terminated.\n\t * In other words, it is not possible, nor intended to create multiple workers of\n\t * the same process from one window. The intent of these workers is to be reused per\n\t * window and the communication channel allows to dynamically update the processes\n\t * after the fact.\n\t *\n\t * @param process information around the process to fork as worker\n\t *\n\t * @returns the worker IPC client to communicate with. Provides a `dispose` method that\n\t * allows to terminate the worker if needed.\n\t */\n\tcreateWorker(process: IUtilityProcessWorkerProcess): Promise<IUtilityProcessWorker>;\n\n\t/**\n\t * Notifies the service that the workbench window has restored.\n\t */\n\tnotifyRestored(): void;\n}\n\nexport class UtilityProcessWorkerWorkbenchService extends Disposable implements IUtilityProcessWorkerWorkbenchService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _utilityProcessWorkerService: IUtilityProcessWorkerService | undefined = undefined;\n\tprivate get utilityProcessWorkerService(): IUtilityProcessWorkerService {\n\t\tif (!this._utilityProcessWorkerService) {\n\t\t\tconst channel = this.mainProcessService.getChannel(ipcUtilityProcessWorkerChannelName);\n\t\t\tthis._utilityProcessWorkerService = ProxyChannel.toService<IUtilityProcessWorkerService>(channel);\n\t\t}\n\n\t\treturn this._utilityProcessWorkerService;\n\t}\n\n\tprivate readonly restoredBarrier = new Barrier();\n\n\tconstructor(\n\t\treadonly windowId: number,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IMainProcessService private readonly mainProcessService: IMainProcessService\n\t) {\n\t\tsuper();\n\t}\n\n\tasync createWorker(process: IUtilityProcessWorkerProcess): Promise<IUtilityProcessWorker> {\n\t\tthis.logService.trace('Renderer->UtilityProcess#createWorker');\n\n\t\t// We want to avoid heavy utility process work to happen before\n\t\t// the window has restored. As such, make sure we await the\n\t\t// `Restored` phase before making a connection attempt, but also\n\t\t// add a timeout to be safe against possible deadlocks.\n\n\t\tawait Promise.race([this.restoredBarrier.wait(), timeout(2000)]);\n\n\t\t// Get ready to acquire the message port from the utility process worker\n\t\tconst nonce = generateUuid();\n\t\tconst responseChannel = 'vscode:createUtilityProcessWorkerMessageChannelResult';\n\t\tconst portPromise = acquirePort(undefined /* we trigger the request via service call! */, responseChannel, nonce);\n\n\t\t// Actually talk with the utility process service\n\t\t// to create a new process from a worker\n\t\tconst onDidTerminate = this.utilityProcessWorkerService.createWorker({\n\t\t\tprocess,\n\t\t\treply: { windowId: this.windowId, channel: responseChannel, nonce }\n\t\t});\n\n\t\t// Dispose worker upon disposal via utility process service\n\t\tconst disposables = new DisposableStore();\n\t\tdisposables.add(toDisposable(() => {\n\t\t\tthis.logService.trace('Renderer->UtilityProcess#disposeWorker', process);\n\n\t\t\tthis.utilityProcessWorkerService.disposeWorker({\n\t\t\t\tprocess,\n\t\t\t\treply: { windowId: this.windowId }\n\t\t\t});\n\t\t}));\n\n\t\tconst port = await portPromise;\n\t\tconst client = disposables.add(new MessagePortClient(port, `window:${this.windowId},module:${process.moduleId}`));\n\t\tthis.logService.trace('Renderer->UtilityProcess#createWorkerChannel: connection established');\n\n\t\tonDidTerminate.then(({ reason }) => {\n\t\t\tif (reason?.code === 0) {\n\t\t\t\tthis.logService.trace(`[UtilityProcessWorker]: terminated normally with code ${reason.code}, signal: ${reason.signal}`);\n\t\t\t} else {\n\t\t\t\tthis.logService.error(`[UtilityProcessWorker]: terminated unexpectedly with code ${reason?.code}, signal: ${reason?.signal}`);\n\t\t\t}\n\t\t});\n\n\t\treturn { client, onDidTerminate, dispose: () => disposables.dispose() };\n\t}\n\n\tnotifyRestored(): void {\n\t\tif (!this.restoredBarrier.isOpen()) {\n\t\t\tthis.restoredBarrier.open();\n\t\t}\n\t}\n}\n"]}