{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/extensionManagement/common/extensionFeatures.ts","vs/workbench/services/extensionManagement/common/extensionFeatures.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAKhG,OAAO,EAAE,eAAe,EAAE,MAAM,4DAA4D,CAAC;AAC7F,OAAO,EAAE,QAAQ,EAAE,MAAM,kDAAkD,CAAC;AAS5E,MAAM,KAAW,UAAU,CAE1B;AAFD,WAAiB,UAAU;IACb,oCAAyB,GAAG,sCAAsC,CAAC;AACjF,CAAC,EAFgB,UAAU,KAAV,UAAU,QAE1B;AAoED,MAAM,CAAC,MAAM,mCAAmC,GAAG,eAAe,CAAsC,qCAAqC,CAAC,CAAC;AAiB/I,MAAM,yBAAyB;IAA/B;QAEkB,sBAAiB,GAAG,IAAI,GAAG,EAAuC,CAAC;IAmBrF,CAAC;IAjBA,wBAAwB,CAAC,UAAuC;QAC/D,IAAI,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC;YAC/C,MAAM,IAAI,KAAK,CAAC,8BAA8B,UAAU,CAAC,EAAE,kBAAkB,CAAC,CAAC;QAChF,CAAC;QACD,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;QACtD,OAAO;YACN,OAAO,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC;SAC3D,CAAC;IACH,CAAC;IAED,mBAAmB,CAAC,EAAU;QAC7B,OAAO,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IACvC,CAAC;IAED,oBAAoB;QACnB,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE,CAAC,CAAC;IACpD,CAAC;CACD;AAED,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,yBAAyB,EAAE,IAAI,yBAAyB,EAAE,CAAC,CAAC","file":"extensionFeatures.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { ExtensionIdentifier, IExtensionManifest } from '../../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { SyncDescriptor } from '../../../../platform/instantiation/common/descriptors.js';\nimport Severity from '../../../../base/common/severity.js';\nimport { IStringDictionary } from '../../../../base/common/collections.js';\nimport { ResolvedKeybinding } from '../../../../base/common/keybindings.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\n\nexport namespace Extensions {\n\texport const ExtensionFeaturesRegistry = 'workbench.registry.extensionFeatures';\n}\n\nexport interface IExtensionFeatureRenderer extends IDisposable {\n\ttype: string;\n\tshouldRender(manifest: IExtensionManifest): boolean;\n\trender(manifest: IExtensionManifest): IDisposable;\n}\n\nexport interface IRenderedData<T> extends IDisposable {\n\treadonly data: T;\n\treadonly onDidChange?: Event<T>;\n}\n\nexport interface IExtensionFeatureMarkdownRenderer extends IExtensionFeatureRenderer {\n\ttype: 'markdown';\n\trender(manifest: IExtensionManifest): IRenderedData<IMarkdownString>;\n}\n\nexport type IRowData = string | IMarkdownString | ResolvedKeybinding | Color | ReadonlyArray<ResolvedKeybinding | IMarkdownString | Color>;\n\nexport interface ITableData {\n\theaders: string[];\n\trows: IRowData[][];\n}\n\nexport interface IExtensionFeatureTableRenderer extends IExtensionFeatureRenderer {\n\ttype: 'table';\n\trender(manifest: IExtensionManifest): IRenderedData<ITableData>;\n}\n\nexport interface IExtensionFeatureMarkdownAndTableRenderer extends IExtensionFeatureRenderer {\n\ttype: 'markdown+table';\n\trender(manifest: IExtensionManifest): IRenderedData<Array<IMarkdownString | ITableData>>;\n}\n\nexport interface IExtensionFeatureDescriptor {\n\treadonly id: string;\n\treadonly label: string;\n\t// label of the access data, if different from the feature title.\n\t// This is useful when the feature is a part of a larger feature and the access data is not about the larger feature.\n\t// This is shown in the access chart like \"There were ${accessCount} ${accessLabel} requests from this extension\".\n\treadonly accessDataLabel?: string;\n\treadonly description?: string;\n\treadonly icon?: ThemeIcon;\n\treadonly access: {\n\t\treadonly canToggle?: boolean;\n\t\treadonly requireUserConsent?: boolean;\n\t\treadonly extensionsList?: IStringDictionary<boolean>;\n\t};\n\treadonly renderer?: SyncDescriptor<IExtensionFeatureRenderer>;\n}\n\nexport interface IExtensionFeaturesRegistry {\n\n\tregisterExtensionFeature(descriptor: IExtensionFeatureDescriptor): IDisposable;\n\tgetExtensionFeature(id: string): IExtensionFeatureDescriptor | undefined;\n\tgetExtensionFeatures(): ReadonlyArray<IExtensionFeatureDescriptor>;\n}\n\nexport interface IExtensionFeatureAccessData {\n\treadonly current?: {\n\t\treadonly accessTimes: Date[];\n\t\treadonly lastAccessed: Date;\n\t\treadonly status?: { readonly severity: Severity; readonly message: string };\n\t};\n\treadonly accessTimes: Date[];\n}\n\nexport const IExtensionFeaturesManagementService = createDecorator<IExtensionFeaturesManagementService>('IExtensionFeaturesManagementService');\nexport interface IExtensionFeaturesManagementService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidChangeEnablement: Event<{ readonly extension: ExtensionIdentifier; readonly featureId: string; readonly enabled: boolean }>;\n\tisEnabled(extension: ExtensionIdentifier, featureId: string): boolean;\n\tsetEnablement(extension: ExtensionIdentifier, featureId: string, enabled: boolean): void;\n\tgetEnablementData(featureId: string): { readonly extension: ExtensionIdentifier; readonly enabled: boolean }[];\n\n\tgetAccess(extension: ExtensionIdentifier, featureId: string, justification?: string): Promise<boolean>;\n\n\treadonly onDidChangeAccessData: Event<{ readonly extension: ExtensionIdentifier; readonly featureId: string; readonly accessData: IExtensionFeatureAccessData }>;\n\tgetAllAccessDataForExtension(extension: ExtensionIdentifier): Map<string, IExtensionFeatureAccessData>;\n\tgetAccessData(extension: ExtensionIdentifier, featureId: string): IExtensionFeatureAccessData | undefined;\n\tsetStatus(extension: ExtensionIdentifier, featureId: string, status: { readonly severity: Severity; readonly message: string } | undefined): void;\n}\n\nclass ExtensionFeaturesRegistry implements IExtensionFeaturesRegistry {\n\n\tprivate readonly extensionFeatures = new Map<string, IExtensionFeatureDescriptor>();\n\n\tregisterExtensionFeature(descriptor: IExtensionFeatureDescriptor): IDisposable {\n\t\tif (this.extensionFeatures.has(descriptor.id)) {\n\t\t\tthrow new Error(`Extension feature with id '${descriptor.id}' already exists`);\n\t\t}\n\t\tthis.extensionFeatures.set(descriptor.id, descriptor);\n\t\treturn {\n\t\t\tdispose: () => this.extensionFeatures.delete(descriptor.id)\n\t\t};\n\t}\n\n\tgetExtensionFeature(id: string): IExtensionFeatureDescriptor | undefined {\n\t\treturn this.extensionFeatures.get(id);\n\t}\n\n\tgetExtensionFeatures(): ReadonlyArray<IExtensionFeatureDescriptor> {\n\t\treturn Array.from(this.extensionFeatures.values());\n\t}\n}\n\nRegistry.add(Extensions.ExtensionFeaturesRegistry, new ExtensionFeaturesRegistry());\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { ExtensionIdentifier, IExtensionManifest } from '../../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { SyncDescriptor } from '../../../../platform/instantiation/common/descriptors.js';\nimport Severity from '../../../../base/common/severity.js';\nimport { IStringDictionary } from '../../../../base/common/collections.js';\nimport { ResolvedKeybinding } from '../../../../base/common/keybindings.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\n\nexport namespace Extensions {\n\texport const ExtensionFeaturesRegistry = 'workbench.registry.extensionFeatures';\n}\n\nexport interface IExtensionFeatureRenderer extends IDisposable {\n\ttype: string;\n\tshouldRender(manifest: IExtensionManifest): boolean;\n\trender(manifest: IExtensionManifest): IDisposable;\n}\n\nexport interface IRenderedData<T> extends IDisposable {\n\treadonly data: T;\n\treadonly onDidChange?: Event<T>;\n}\n\nexport interface IExtensionFeatureMarkdownRenderer extends IExtensionFeatureRenderer {\n\ttype: 'markdown';\n\trender(manifest: IExtensionManifest): IRenderedData<IMarkdownString>;\n}\n\nexport type IRowData = string | IMarkdownString | ResolvedKeybinding | Color | ReadonlyArray<ResolvedKeybinding | IMarkdownString | Color>;\n\nexport interface ITableData {\n\theaders: string[];\n\trows: IRowData[][];\n}\n\nexport interface IExtensionFeatureTableRenderer extends IExtensionFeatureRenderer {\n\ttype: 'table';\n\trender(manifest: IExtensionManifest): IRenderedData<ITableData>;\n}\n\nexport interface IExtensionFeatureMarkdownAndTableRenderer extends IExtensionFeatureRenderer {\n\ttype: 'markdown+table';\n\trender(manifest: IExtensionManifest): IRenderedData<Array<IMarkdownString | ITableData>>;\n}\n\nexport interface IExtensionFeatureDescriptor {\n\treadonly id: string;\n\treadonly label: string;\n\t// label of the access data, if different from the feature title.\n\t// This is useful when the feature is a part of a larger feature and the access data is not about the larger feature.\n\t// This is shown in the access chart like \"There were ${accessCount} ${accessLabel} requests from this extension\".\n\treadonly accessDataLabel?: string;\n\treadonly description?: string;\n\treadonly icon?: ThemeIcon;\n\treadonly access: {\n\t\treadonly canToggle?: boolean;\n\t\treadonly requireUserConsent?: boolean;\n\t\treadonly extensionsList?: IStringDictionary<boolean>;\n\t};\n\treadonly renderer?: SyncDescriptor<IExtensionFeatureRenderer>;\n}\n\nexport interface IExtensionFeaturesRegistry {\n\n\tregisterExtensionFeature(descriptor: IExtensionFeatureDescriptor): IDisposable;\n\tgetExtensionFeature(id: string): IExtensionFeatureDescriptor | undefined;\n\tgetExtensionFeatures(): ReadonlyArray<IExtensionFeatureDescriptor>;\n}\n\nexport interface IExtensionFeatureAccessData {\n\treadonly current?: {\n\t\treadonly accessTimes: Date[];\n\t\treadonly lastAccessed: Date;\n\t\treadonly status?: { readonly severity: Severity; readonly message: string };\n\t};\n\treadonly accessTimes: Date[];\n}\n\nexport const IExtensionFeaturesManagementService = createDecorator<IExtensionFeaturesManagementService>('IExtensionFeaturesManagementService');\nexport interface IExtensionFeaturesManagementService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidChangeEnablement: Event<{ readonly extension: ExtensionIdentifier; readonly featureId: string; readonly enabled: boolean }>;\n\tisEnabled(extension: ExtensionIdentifier, featureId: string): boolean;\n\tsetEnablement(extension: ExtensionIdentifier, featureId: string, enabled: boolean): void;\n\tgetEnablementData(featureId: string): { readonly extension: ExtensionIdentifier; readonly enabled: boolean }[];\n\n\tgetAccess(extension: ExtensionIdentifier, featureId: string, justification?: string): Promise<boolean>;\n\n\treadonly onDidChangeAccessData: Event<{ readonly extension: ExtensionIdentifier; readonly featureId: string; readonly accessData: IExtensionFeatureAccessData }>;\n\tgetAllAccessDataForExtension(extension: ExtensionIdentifier): Map<string, IExtensionFeatureAccessData>;\n\tgetAccessData(extension: ExtensionIdentifier, featureId: string): IExtensionFeatureAccessData | undefined;\n\tsetStatus(extension: ExtensionIdentifier, featureId: string, status: { readonly severity: Severity; readonly message: string } | undefined): void;\n}\n\nclass ExtensionFeaturesRegistry implements IExtensionFeaturesRegistry {\n\n\tprivate readonly extensionFeatures = new Map<string, IExtensionFeatureDescriptor>();\n\n\tregisterExtensionFeature(descriptor: IExtensionFeatureDescriptor): IDisposable {\n\t\tif (this.extensionFeatures.has(descriptor.id)) {\n\t\t\tthrow new Error(`Extension feature with id '${descriptor.id}' already exists`);\n\t\t}\n\t\tthis.extensionFeatures.set(descriptor.id, descriptor);\n\t\treturn {\n\t\t\tdispose: () => this.extensionFeatures.delete(descriptor.id)\n\t\t};\n\t}\n\n\tgetExtensionFeature(id: string): IExtensionFeatureDescriptor | undefined {\n\t\treturn this.extensionFeatures.get(id);\n\t}\n\n\tgetExtensionFeatures(): ReadonlyArray<IExtensionFeatureDescriptor> {\n\t\treturn Array.from(this.extensionFeatures.values());\n\t}\n}\n\nRegistry.add(Extensions.ExtensionFeaturesRegistry, new ExtensionFeaturesRegistry());\n"]}