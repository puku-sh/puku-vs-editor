{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/extensionManagement/common/extensionManagement.ts","vs/workbench/services/extensionManagement/common/extensionManagement.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAGhG,OAAO,EAAE,eAAe,EAAE,sBAAsB,EAAE,MAAM,4DAA4D,CAAC;AAErH,OAAO,EAAE,2BAA2B,EAAsN,MAAM,wEAAwE,CAAC;AAMzU,MAAM,CAAC,MAAM,uCAAuC,GAAG,sBAAsB,CAAuE,2BAA2B,CAAC,CAAC;AAcjL,MAAM,CAAN,IAAkB,wBAIjB;AAJD,WAAkB,wBAAwB;IACzC,yEAAS,CAAA;IACT,2EAAM,CAAA;IACN,qEAAG,CAAA;AACJ,CAAC,EAJiB,wBAAwB,KAAxB,wBAAwB,QAIzC;AAED,MAAM,CAAC,MAAM,iCAAiC,GAAG,eAAe,CAAoC,kCAAkC,CAAC,CAAC;AA6BxI,MAAM,CAAC,MAAM,oCAAoC,GAAG,sBAAsB,CAAgF,uCAAuC,CAAC,CAAC;AAqCnM,MAAM,CAAN,IAAkB,eAejB;AAfD,WAAkB,eAAe;IAChC,iGAA0B,CAAA;IAC1B,2FAAuB,CAAA;IACvB,uFAAqB,CAAA;IACrB,qFAAoB,CAAA;IACpB,mFAAmB,CAAA;IACnB,iGAA0B,CAAA;IAC1B,iGAA0B,CAAA;IAC1B,mFAAmB,CAAA;IACnB,uGAA6B,CAAA;IAC7B,uFAAqB,CAAA;IACrB,8EAAgB,CAAA;IAChB,gFAAiB,CAAA;IACjB,4EAAe,CAAA;IACf,8EAAgB,CAAA;AACjB,CAAC,EAfiB,eAAe,KAAf,eAAe,QAehC;AAED,MAAM,CAAC,MAAM,oCAAoC,GAAG,eAAe,CAAuC,4BAA4B,CAAC,CAAC;AA8ExI,MAAM,CAAC,MAAM,4BAA4B,GAAG,eAAe,CAA+B,8BAA8B,CAAC,CAAC","file":"extensionManagement.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { createDecorator, refineServiceDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IExtension, ExtensionType, IExtensionManifest, IExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { IExtensionManagementService, IGalleryExtension, ILocalExtension, InstallOptions, InstallExtensionEvent, DidUninstallExtensionEvent, InstallExtensionResult, Metadata, UninstallExtensionEvent, DidUpdateExtensionMetadata, InstallExtensionInfo } from '../../../../platform/extensionManagement/common/extensionManagement.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\n\nexport type DidChangeProfileEvent = { readonly added: ILocalExtension[]; readonly removed: ILocalExtension[] };\n\nexport const IProfileAwareExtensionManagementService = refineServiceDecorator<IExtensionManagementService, IProfileAwareExtensionManagementService>(IExtensionManagementService);\nexport interface IProfileAwareExtensionManagementService extends IExtensionManagementService {\n\treadonly onProfileAwareDidInstallExtensions: Event<readonly InstallExtensionResult[]>;\n\treadonly onProfileAwareDidUninstallExtension: Event<DidUninstallExtensionEvent>;\n\treadonly onProfileAwareDidUpdateExtensionMetadata: Event<DidUpdateExtensionMetadata>;\n\treadonly onDidChangeProfile: Event<DidChangeProfileEvent>;\n}\n\nexport interface IExtensionManagementServer {\n\treadonly id: string;\n\treadonly label: string;\n\treadonly extensionManagementService: IProfileAwareExtensionManagementService;\n}\n\nexport const enum ExtensionInstallLocation {\n\tLocal = 1,\n\tRemote,\n\tWeb\n}\n\nexport const IExtensionManagementServerService = createDecorator<IExtensionManagementServerService>('extensionManagementServerService');\nexport interface IExtensionManagementServerService {\n\treadonly _serviceBrand: undefined;\n\treadonly localExtensionManagementServer: IExtensionManagementServer | null;\n\treadonly remoteExtensionManagementServer: IExtensionManagementServer | null;\n\treadonly webExtensionManagementServer: IExtensionManagementServer | null;\n\tgetExtensionManagementServer(extension: IExtension): IExtensionManagementServer | null;\n\tgetExtensionInstallLocation(extension: IExtension): ExtensionInstallLocation | null;\n}\n\nexport interface IResourceExtension {\n\treadonly type: 'resource';\n\treadonly identifier: IExtensionIdentifier;\n\treadonly location: URI;\n\treadonly manifest: IExtensionManifest;\n\treadonly readmeUri?: URI;\n\treadonly changelogUri?: URI;\n}\n\nexport type InstallExtensionOnServerEvent = InstallExtensionEvent & { server: IExtensionManagementServer };\nexport type UninstallExtensionOnServerEvent = UninstallExtensionEvent & { server: IExtensionManagementServer };\nexport type DidUninstallExtensionOnServerEvent = DidUninstallExtensionEvent & { server: IExtensionManagementServer };\nexport type DidChangeProfileForServerEvent = DidChangeProfileEvent & { server: IExtensionManagementServer };\n\nexport interface IPublisherInfo {\n\treadonly publisher: string;\n\treadonly publisherDisplayName: string;\n}\n\nexport const IWorkbenchExtensionManagementService = refineServiceDecorator<IProfileAwareExtensionManagementService, IWorkbenchExtensionManagementService>(IProfileAwareExtensionManagementService);\nexport interface IWorkbenchExtensionManagementService extends IProfileAwareExtensionManagementService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onInstallExtension: Event<InstallExtensionOnServerEvent>;\n\treadonly onDidInstallExtensions: Event<readonly InstallExtensionResult[]>;\n\treadonly onUninstallExtension: Event<UninstallExtensionOnServerEvent>;\n\treadonly onDidUninstallExtension: Event<DidUninstallExtensionOnServerEvent>;\n\treadonly onDidChangeProfile: Event<DidChangeProfileForServerEvent>;\n\treadonly onDidEnableExtensions: Event<IExtension[]>;\n\n\treadonly onProfileAwareDidInstallExtensions: Event<readonly InstallExtensionResult[]>;\n\treadonly onProfileAwareDidUninstallExtension: Event<DidUninstallExtensionOnServerEvent>;\n\treadonly onProfileAwareDidUpdateExtensionMetadata: Event<DidUpdateExtensionMetadata>;\n\n\tgetExtensions(locations: URI[]): Promise<IResourceExtension[]>;\n\tgetInstalledWorkspaceExtensionLocations(): URI[];\n\tgetInstalledWorkspaceExtensions(includeInvalid: boolean): Promise<ILocalExtension[]>;\n\n\tcanInstall(extension: IGalleryExtension | IResourceExtension): Promise<true | IMarkdownString>;\n\n\tgetInstallableServers(extension: IGalleryExtension): Promise<IExtensionManagementServer[]>;\n\tinstallVSIX(location: URI, manifest: IExtensionManifest, installOptions?: InstallOptions): Promise<ILocalExtension>;\n\tinstallFromGallery(gallery: IGalleryExtension, installOptions?: InstallOptions, servers?: IExtensionManagementServer[]): Promise<ILocalExtension>;\n\tinstallFromLocation(location: URI): Promise<ILocalExtension>;\n\tinstallResourceExtension(extension: IResourceExtension, installOptions: InstallOptions): Promise<ILocalExtension>;\n\n\tupdateFromGallery(gallery: IGalleryExtension, extension: ILocalExtension, installOptions?: InstallOptions): Promise<ILocalExtension>;\n\tupdateMetadata(local: ILocalExtension, metadata: Partial<Metadata>): Promise<ILocalExtension>;\n\n\trequestPublisherTrust(extensions: InstallExtensionInfo[]): Promise<void>;\n\tisPublisherTrusted(extension: IGalleryExtension): boolean;\n\tgetTrustedPublishers(): IPublisherInfo[];\n\ttrustPublishers(...publishers: IPublisherInfo[]): void;\n\tuntrustPublishers(...publishers: string[]): void;\n}\n\nexport const enum EnablementState {\n\tDisabledByTrustRequirement,\n\tDisabledByExtensionKind,\n\tDisabledByEnvironment,\n\tEnabledByEnvironment,\n\tDisabledByMalicious,\n\tDisabledByVirtualWorkspace,\n\tDisabledByInvalidExtension,\n\tDisabledByAllowlist,\n\tDisabledByExtensionDependency,\n\tDisabledByUnification, // Temporary TODO@benibenj remove when unification transition is complete\n\tDisabledGlobally,\n\tDisabledWorkspace,\n\tEnabledGlobally,\n\tEnabledWorkspace\n}\n\nexport const IWorkbenchExtensionEnablementService = createDecorator<IWorkbenchExtensionEnablementService>('extensionEnablementService');\n\nexport interface IWorkbenchExtensionEnablementService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Event to listen on for extension enablement changes\n\t */\n\treadonly onEnablementChanged: Event<readonly IExtension[]>;\n\n\t/**\n\t * Returns the enablement state for the given extension\n\t */\n\tgetEnablementState(extension: IExtension): EnablementState;\n\n\t/**\n\t * Returns the enablement states for the given extensions\n\t * @param extensions list of extensions\n\t * @param workspaceTypeOverrides Workspace type overrides\n\t */\n\tgetEnablementStates(extensions: IExtension[], workspaceTypeOverrides?: { trusted?: boolean }): EnablementState[];\n\n\t/**\n\t * Returns the enablement states for the dependencies of the given extension\n\t */\n\tgetDependenciesEnablementStates(extension: IExtension): [IExtension, EnablementState][];\n\n\t/**\n\t * Returns `true` if the enablement can be changed.\n\t */\n\tcanChangeEnablement(extension: IExtension): boolean;\n\n\t/**\n\t * Returns `true` if the enablement can be changed.\n\t */\n\tcanChangeWorkspaceEnablement(extension: IExtension): boolean;\n\n\t/**\n\t * Returns `true` if the given extension is enabled.\n\t */\n\tisEnabled(extension: IExtension): boolean;\n\n\t/**\n\t * Returns `true` if the given enablement state is enabled enablement state.\n\t */\n\tisEnabledEnablementState(enablementState: EnablementState): boolean;\n\n\t/**\n\t * Returns `true` if the given extension identifier is disabled globally.\n\t * Extensions can be disabled globally or in workspace or both.\n\t * If an extension is disabled in both then enablement state shows only workspace.\n\t * This will\n\t */\n\tisDisabledGlobally(extension: IExtension): boolean;\n\n\t/**\n\t * Enable or disable the given extension.\n\t * if `workspace` is `true` then enablement is done for workspace, otherwise globally.\n\t *\n\t * Returns a promise that resolves to boolean value.\n\t * if resolves to `true` then requires restart for the change to take effect.\n\t *\n\t * Throws error if enablement is requested for workspace and there is no workspace\n\t */\n\tsetEnablement(extensions: IExtension[], state: EnablementState): Promise<boolean[]>;\n\n\t/**\n\t * Updates the enablement state of the extensions when workspace trust changes.\n\t */\n\tupdateExtensionsEnablementsWhenWorkspaceTrustChanges(): Promise<void>;\n}\n\nexport interface IScannedExtension extends IExtension {\n\treadonly metadata?: Metadata;\n}\n\nexport type ScanOptions = { readonly skipInvalidExtensions?: boolean };\n\nexport const IWebExtensionsScannerService = createDecorator<IWebExtensionsScannerService>('IWebExtensionsScannerService');\nexport interface IWebExtensionsScannerService {\n\treadonly _serviceBrand: undefined;\n\n\tscanSystemExtensions(): Promise<IExtension[]>;\n\tscanUserExtensions(profileLocation: URI, options?: ScanOptions): Promise<IScannedExtension[]>;\n\tscanExtensionsUnderDevelopment(): Promise<IExtension[]>;\n\tscanExistingExtension(extensionLocation: URI, extensionType: ExtensionType, profileLocation: URI): Promise<IScannedExtension | null>;\n\n\taddExtension(location: URI, metadata: Metadata, profileLocation: URI): Promise<IScannedExtension>;\n\taddExtensionFromGallery(galleryExtension: IGalleryExtension, metadata: Metadata, profileLocation: URI): Promise<IScannedExtension>;\n\tremoveExtension(extension: IScannedExtension, profileLocation: URI): Promise<void>;\n\tcopyExtensions(fromProfileLocation: URI, toProfileLocation: URI, filter: (extension: IScannedExtension) => boolean): Promise<void>;\n\n\tupdateMetadata(extension: IScannedExtension, metaData: Partial<Metadata>, profileLocation: URI): Promise<IScannedExtension>;\n\n\tscanExtensionManifest(extensionLocation: URI): Promise<IExtensionManifest | null>;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event.js';\nimport { createDecorator, refineServiceDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IExtension, ExtensionType, IExtensionManifest, IExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { IExtensionManagementService, IGalleryExtension, ILocalExtension, InstallOptions, InstallExtensionEvent, DidUninstallExtensionEvent, InstallExtensionResult, Metadata, UninstallExtensionEvent, DidUpdateExtensionMetadata, InstallExtensionInfo } from '../../../../platform/extensionManagement/common/extensionManagement.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IMarkdownString } from '../../../../base/common/htmlContent.js';\n\nexport type DidChangeProfileEvent = { readonly added: ILocalExtension[]; readonly removed: ILocalExtension[] };\n\nexport const IProfileAwareExtensionManagementService = refineServiceDecorator<IExtensionManagementService, IProfileAwareExtensionManagementService>(IExtensionManagementService);\nexport interface IProfileAwareExtensionManagementService extends IExtensionManagementService {\n\treadonly onProfileAwareDidInstallExtensions: Event<readonly InstallExtensionResult[]>;\n\treadonly onProfileAwareDidUninstallExtension: Event<DidUninstallExtensionEvent>;\n\treadonly onProfileAwareDidUpdateExtensionMetadata: Event<DidUpdateExtensionMetadata>;\n\treadonly onDidChangeProfile: Event<DidChangeProfileEvent>;\n}\n\nexport interface IExtensionManagementServer {\n\treadonly id: string;\n\treadonly label: string;\n\treadonly extensionManagementService: IProfileAwareExtensionManagementService;\n}\n\nexport const enum ExtensionInstallLocation {\n\tLocal = 1,\n\tRemote,\n\tWeb\n}\n\nexport const IExtensionManagementServerService = createDecorator<IExtensionManagementServerService>('extensionManagementServerService');\nexport interface IExtensionManagementServerService {\n\treadonly _serviceBrand: undefined;\n\treadonly localExtensionManagementServer: IExtensionManagementServer | null;\n\treadonly remoteExtensionManagementServer: IExtensionManagementServer | null;\n\treadonly webExtensionManagementServer: IExtensionManagementServer | null;\n\tgetExtensionManagementServer(extension: IExtension): IExtensionManagementServer | null;\n\tgetExtensionInstallLocation(extension: IExtension): ExtensionInstallLocation | null;\n}\n\nexport interface IResourceExtension {\n\treadonly type: 'resource';\n\treadonly identifier: IExtensionIdentifier;\n\treadonly location: URI;\n\treadonly manifest: IExtensionManifest;\n\treadonly readmeUri?: URI;\n\treadonly changelogUri?: URI;\n}\n\nexport type InstallExtensionOnServerEvent = InstallExtensionEvent & { server: IExtensionManagementServer };\nexport type UninstallExtensionOnServerEvent = UninstallExtensionEvent & { server: IExtensionManagementServer };\nexport type DidUninstallExtensionOnServerEvent = DidUninstallExtensionEvent & { server: IExtensionManagementServer };\nexport type DidChangeProfileForServerEvent = DidChangeProfileEvent & { server: IExtensionManagementServer };\n\nexport interface IPublisherInfo {\n\treadonly publisher: string;\n\treadonly publisherDisplayName: string;\n}\n\nexport const IWorkbenchExtensionManagementService = refineServiceDecorator<IProfileAwareExtensionManagementService, IWorkbenchExtensionManagementService>(IProfileAwareExtensionManagementService);\nexport interface IWorkbenchExtensionManagementService extends IProfileAwareExtensionManagementService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onInstallExtension: Event<InstallExtensionOnServerEvent>;\n\treadonly onDidInstallExtensions: Event<readonly InstallExtensionResult[]>;\n\treadonly onUninstallExtension: Event<UninstallExtensionOnServerEvent>;\n\treadonly onDidUninstallExtension: Event<DidUninstallExtensionOnServerEvent>;\n\treadonly onDidChangeProfile: Event<DidChangeProfileForServerEvent>;\n\treadonly onDidEnableExtensions: Event<IExtension[]>;\n\n\treadonly onProfileAwareDidInstallExtensions: Event<readonly InstallExtensionResult[]>;\n\treadonly onProfileAwareDidUninstallExtension: Event<DidUninstallExtensionOnServerEvent>;\n\treadonly onProfileAwareDidUpdateExtensionMetadata: Event<DidUpdateExtensionMetadata>;\n\n\tgetExtensions(locations: URI[]): Promise<IResourceExtension[]>;\n\tgetInstalledWorkspaceExtensionLocations(): URI[];\n\tgetInstalledWorkspaceExtensions(includeInvalid: boolean): Promise<ILocalExtension[]>;\n\n\tcanInstall(extension: IGalleryExtension | IResourceExtension): Promise<true | IMarkdownString>;\n\n\tgetInstallableServers(extension: IGalleryExtension): Promise<IExtensionManagementServer[]>;\n\tinstallVSIX(location: URI, manifest: IExtensionManifest, installOptions?: InstallOptions): Promise<ILocalExtension>;\n\tinstallFromGallery(gallery: IGalleryExtension, installOptions?: InstallOptions, servers?: IExtensionManagementServer[]): Promise<ILocalExtension>;\n\tinstallFromLocation(location: URI): Promise<ILocalExtension>;\n\tinstallResourceExtension(extension: IResourceExtension, installOptions: InstallOptions): Promise<ILocalExtension>;\n\n\tupdateFromGallery(gallery: IGalleryExtension, extension: ILocalExtension, installOptions?: InstallOptions): Promise<ILocalExtension>;\n\tupdateMetadata(local: ILocalExtension, metadata: Partial<Metadata>): Promise<ILocalExtension>;\n\n\trequestPublisherTrust(extensions: InstallExtensionInfo[]): Promise<void>;\n\tisPublisherTrusted(extension: IGalleryExtension): boolean;\n\tgetTrustedPublishers(): IPublisherInfo[];\n\ttrustPublishers(...publishers: IPublisherInfo[]): void;\n\tuntrustPublishers(...publishers: string[]): void;\n}\n\nexport const enum EnablementState {\n\tDisabledByTrustRequirement,\n\tDisabledByExtensionKind,\n\tDisabledByEnvironment,\n\tEnabledByEnvironment,\n\tDisabledByMalicious,\n\tDisabledByVirtualWorkspace,\n\tDisabledByInvalidExtension,\n\tDisabledByAllowlist,\n\tDisabledByExtensionDependency,\n\tDisabledByUnification, // Temporary TODO@benibenj remove when unification transition is complete\n\tDisabledGlobally,\n\tDisabledWorkspace,\n\tEnabledGlobally,\n\tEnabledWorkspace\n}\n\nexport const IWorkbenchExtensionEnablementService = createDecorator<IWorkbenchExtensionEnablementService>('extensionEnablementService');\n\nexport interface IWorkbenchExtensionEnablementService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Event to listen on for extension enablement changes\n\t */\n\treadonly onEnablementChanged: Event<readonly IExtension[]>;\n\n\t/**\n\t * Returns the enablement state for the given extension\n\t */\n\tgetEnablementState(extension: IExtension): EnablementState;\n\n\t/**\n\t * Returns the enablement states for the given extensions\n\t * @param extensions list of extensions\n\t * @param workspaceTypeOverrides Workspace type overrides\n\t */\n\tgetEnablementStates(extensions: IExtension[], workspaceTypeOverrides?: { trusted?: boolean }): EnablementState[];\n\n\t/**\n\t * Returns the enablement states for the dependencies of the given extension\n\t */\n\tgetDependenciesEnablementStates(extension: IExtension): [IExtension, EnablementState][];\n\n\t/**\n\t * Returns `true` if the enablement can be changed.\n\t */\n\tcanChangeEnablement(extension: IExtension): boolean;\n\n\t/**\n\t * Returns `true` if the enablement can be changed.\n\t */\n\tcanChangeWorkspaceEnablement(extension: IExtension): boolean;\n\n\t/**\n\t * Returns `true` if the given extension is enabled.\n\t */\n\tisEnabled(extension: IExtension): boolean;\n\n\t/**\n\t * Returns `true` if the given enablement state is enabled enablement state.\n\t */\n\tisEnabledEnablementState(enablementState: EnablementState): boolean;\n\n\t/**\n\t * Returns `true` if the given extension identifier is disabled globally.\n\t * Extensions can be disabled globally or in workspace or both.\n\t * If an extension is disabled in both then enablement state shows only workspace.\n\t * This will\n\t */\n\tisDisabledGlobally(extension: IExtension): boolean;\n\n\t/**\n\t * Enable or disable the given extension.\n\t * if `workspace` is `true` then enablement is done for workspace, otherwise globally.\n\t *\n\t * Returns a promise that resolves to boolean value.\n\t * if resolves to `true` then requires restart for the change to take effect.\n\t *\n\t * Throws error if enablement is requested for workspace and there is no workspace\n\t */\n\tsetEnablement(extensions: IExtension[], state: EnablementState): Promise<boolean[]>;\n\n\t/**\n\t * Updates the enablement state of the extensions when workspace trust changes.\n\t */\n\tupdateExtensionsEnablementsWhenWorkspaceTrustChanges(): Promise<void>;\n}\n\nexport interface IScannedExtension extends IExtension {\n\treadonly metadata?: Metadata;\n}\n\nexport type ScanOptions = { readonly skipInvalidExtensions?: boolean };\n\nexport const IWebExtensionsScannerService = createDecorator<IWebExtensionsScannerService>('IWebExtensionsScannerService');\nexport interface IWebExtensionsScannerService {\n\treadonly _serviceBrand: undefined;\n\n\tscanSystemExtensions(): Promise<IExtension[]>;\n\tscanUserExtensions(profileLocation: URI, options?: ScanOptions): Promise<IScannedExtension[]>;\n\tscanExtensionsUnderDevelopment(): Promise<IExtension[]>;\n\tscanExistingExtension(extensionLocation: URI, extensionType: ExtensionType, profileLocation: URI): Promise<IScannedExtension | null>;\n\n\taddExtension(location: URI, metadata: Metadata, profileLocation: URI): Promise<IScannedExtension>;\n\taddExtensionFromGallery(galleryExtension: IGalleryExtension, metadata: Metadata, profileLocation: URI): Promise<IScannedExtension>;\n\tremoveExtension(extension: IScannedExtension, profileLocation: URI): Promise<void>;\n\tcopyExtensions(fromProfileLocation: URI, toProfileLocation: URI, filter: (extension: IScannedExtension) => boolean): Promise<void>;\n\n\tupdateMetadata(extension: IScannedExtension, metaData: Partial<Metadata>, profileLocation: URI): Promise<IScannedExtension>;\n\n\tscanExtensionManifest(extensionLocation: URI): Promise<IExtensionManifest | null>;\n}\n"]}