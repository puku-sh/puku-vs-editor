{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/common/replace.ts","vs/workbench/services/search/common/replace.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,KAAK,OAAO,MAAM,oCAAoC,CAAC;AAG9D,OAAO,EAAE,mCAAmC,EAAE,MAAM,mCAAmC,CAAC;AAExF,MAAM,OAAO,cAAc;IAS1B,YAAY,aAAqB,EAAE,IAAS,EAAE,IAAU;QANhD,mBAAc,GAAY,KAAK,CAAC;QAOvC,IAAI,CAAC,eAAe,GAAG,aAAa,CAAC;QACrC,IAAI,iBAA+B,CAAC;QACpC,IAAI,eAAwB,CAAC;QAC7B,IAAI,OAAO,IAAI,KAAK,SAAS,EAAE,CAAC;YAC/B,eAAe,GAAG,IAAI,CAAC;YACvB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QAErB,CAAC;aAAM,CAAC;YACP,iBAAiB,GAAG,IAAI,CAAC;YACzB,eAAe,GAAG,CAAC,CAAC,iBAAiB,CAAC,QAAQ,CAAC;YAC/C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,YAAY,CAAC,iBAAiB,CAAC,OAAO,EAAE,CAAC,CAAC,iBAAiB,CAAC,QAAQ,EAAE,EAAE,SAAS,EAAE,iBAAiB,CAAC,eAAe,EAAE,SAAS,EAAE,iBAAiB,CAAC,WAAW,EAAE,SAAS,EAAE,iBAAiB,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;QAClQ,CAAC;QAED,IAAI,eAAe,EAAE,CAAC;YACrB,IAAI,CAAC,kBAAkB,CAAC,aAAa,CAAC,CAAC;QACxC,CAAC;QAED,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;YACzB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE,SAAS,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;QAC7K,CAAC;QAED,IAAI,CAAC,cAAc,GAAG,IAAI,MAAM,CAAC,kDAAkD,CAAC,CAAC;IACtF,CAAC;IAED,IAAI,aAAa;QAChB,OAAO,IAAI,CAAC,cAAc,CAAC;IAC5B,CAAC;IAED,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,eAAe,CAAC;IAC7B,CAAC;IAED,IAAI,MAAM;QACT,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAED;;;MAGE;IACF,gBAAgB,CAAC,IAAY,EAAE,YAAsB;QACpD,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,CAAC,CAAC;QAC3B,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtC,IAAI,KAAK,EAAE,CAAC;YACX,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;gBACxB,MAAM,aAAa,GAAG,IAAI,CAAC,yBAAyB,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC,CAAC;gBACvH,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;oBACvB,OAAO,aAAa,CAAC;gBACtB,CAAC;gBACD,OAAO,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC;YAClG,CAAC;YACD,OAAO,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;QACrD,CAAC;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;;;;;;;OAQG;IACK,yBAAyB,CAAC,IAAY,EAAE,KAAa,EAAE,aAAqB;QACnF,iCAAiC;QACjC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC;YACrC,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;QAC3C,CAAC;QACD,6CAA6C;QAC7C,MAAM,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,UAAU,KAAK,IAAI,EAAE,CAAC;YACzB,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;QAC3C,CAAC;QAED,IAAI,QAAgC,CAAC;QACrC,IAAI,gBAAgB,GAAG,EAAE,CAAC;QAC1B,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,SAAS,GAAG,EAAE,CAAC;QACnB,iGAAiG;QACjG,OAAO,CAAC,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;YACtE,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC;YAC3B,MAAM,SAAS,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC9B,SAAS,GAAG,SAAS,CAAC;YACtB,IAAI,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,iBAAiB;YAC5C,MAAM,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,eAAe;YAE1C,IAAI,CAAC,OAAO,EAAE,CAAC;gBACd,gBAAgB,IAAI,SAAS,CAAC;gBAC9B,SAAS;YACV,CAAC;YACD,MAAM,WAAW,GAAG,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACzD,IAAI,CAAC,WAAW,EAAE,CAAC;gBAClB,gBAAgB,IAAI,SAAS,CAAC;gBAC9B,SAAS;YACV,CAAC;YACD,MAAM,cAAc,GAAG,WAAW,CAAC,MAAM,CAAC;YAE1C,gBAAgB,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS;YAC1C,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YACrC,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,OAAO,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAChC,QAAQ,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;oBACpB,KAAK,GAAG;wBACP,gBAAgB,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;wBACvD,CAAC,GAAG,cAAc,CAAC;wBACnB,MAAM;oBACP,KAAK,GAAG;wBACP,gBAAgB,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;wBACjD,MAAM;oBACP,KAAK,GAAG;wBACP,gBAAgB,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;wBACvD,CAAC,GAAG,cAAc,CAAC;wBACnB,MAAM;oBACP,KAAK,GAAG;wBACP,gBAAgB,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;wBACjD,MAAM;gBACR,CAAC;YACF,CAAC;YACD,kFAAkF;YAClF,IAAI,CAAC,GAAG,cAAc,EAAE,CAAC;gBACxB,gBAAgB,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC1C,CAAC;YAED,gBAAgB,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS;QAC3C,CAAC;QAED,qEAAqE;QACrE,gBAAgB,IAAI,aAAa,CAAC,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC;QAEtE,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAC;IAC9C,CAAC;IAEM,kBAAkB,CAAC,OAAwB,EAAE,YAAsB;QACzE,IAAI,YAAY,EAAE,CAAC;YAClB,OAAO,mCAAmC,CAAC,OAAO,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;QAC3E,CAAC;aAAM,CAAC;YACP,OAAO,IAAI,CAAC,eAAe,CAAC;QAC7B,CAAC;IACF,CAAC;IAED;;;;;;OAMG;IACK,kBAAkB,CAAC,aAAqB;QAC/C,IAAI,CAAC,aAAa,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAClD,OAAO;QACR,CAAC;QAED,IAAI,UAAU,GAAG,CAAC,EAAE,MAAM,GAAG,EAAE,CAAC;QAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;YAC1D,MAAM,MAAM,GAAG,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAE3C,IAAI,MAAM,gCAAuB,EAAE,CAAC;gBAEnC,oBAAoB;gBACpB,CAAC,EAAE,CAAC;gBAEJ,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;oBACd,uBAAuB;oBACvB,MAAM;gBACP,CAAC;gBAED,MAAM,UAAU,GAAG,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC/C,IAAI,oBAAoB,GAAkB,IAAI,CAAC;gBAE/C,QAAQ,UAAU,EAAE,CAAC;oBACpB;wBACC,UAAU;wBACV,oBAAoB,GAAG,IAAI,CAAC;wBAC5B,MAAM;oBACP;wBACC,WAAW;wBACX,oBAAoB,GAAG,IAAI,CAAC;wBAC5B,MAAM;oBACP;wBACC,YAAY;wBACZ,oBAAoB,GAAG,IAAI,CAAC;wBAC5B,MAAM;gBACR,CAAC;gBAED,IAAI,oBAAoB,EAAE,CAAC;oBAC1B,MAAM,IAAI,aAAa,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,oBAAoB,CAAC;oBAC5E,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC;gBACpB,CAAC;YACF,CAAC;YAED,IAAI,MAAM,iCAAwB,EAAE,CAAC;gBAEpC,oBAAoB;gBACpB,CAAC,EAAE,CAAC;gBAEJ,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;oBACd,uBAAuB;oBACvB,MAAM;gBACP,CAAC;gBAED,MAAM,UAAU,GAAG,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC/C,IAAI,oBAAoB,GAAkB,IAAI,CAAC;gBAE/C,QAAQ,UAAU,EAAE,CAAC;oBACpB;wBACC,WAAW;wBACX,oBAAoB,GAAG,IAAI,CAAC;wBAC5B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;wBAC3B,MAAM;oBACP,gCAAuB;oBACvB;wBACC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;wBAC3B,MAAM;oBACP,OAAO,CAAC,CAAC,CAAC;wBACT,2FAA2F;wBAC3F,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,qDAAmC,EAAE,CAAC;4BACjE,MAAM;wBACP,CAAC;wBACD,IAAI,CAAC,KAAK,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;4BACpC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;4BAC3B,MAAM;wBACP,CAAC;wBACD,IAAI,QAAQ,GAAG,aAAa,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC;wBAC7C,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,qDAAmC,EAAE,CAAC;4BAC/D,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;4BAC3B,EAAE,CAAC,CAAC;4BACJ,MAAM;wBACP,CAAC;wBACD,IAAI,CAAC,KAAK,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;4BACpC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;4BAC3B,MAAM;wBACP,CAAC;wBACD,QAAQ,GAAG,aAAa,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC;wBACzC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,qDAAmC,EAAE,CAAC;4BAC/D,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;4BAC3B,EAAE,CAAC,CAAC;4BACJ,MAAM;wBACP,CAAC;wBACD,MAAM;oBACP,CAAC;gBACF,CAAC;gBAED,IAAI,oBAAoB,EAAE,CAAC;oBAC1B,MAAM,IAAI,aAAa,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,oBAAoB,CAAC;oBAC5E,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC;gBACpB,CAAC;YACF,CAAC;QACF,CAAC;QAED,IAAI,UAAU,KAAK,CAAC,EAAE,CAAC;YACtB,0BAA0B;YAC1B,OAAO;QACR,CAAC;QAED,IAAI,CAAC,eAAe,GAAG,MAAM,GAAG,aAAa,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;IACrE,CAAC;IAEO,OAAO,CAAC,KAAa,EAAE,IAAY,EAAE,EAAU;QACtD,OAAO,IAAI,IAAI,KAAK,IAAI,KAAK,IAAI,EAAE,CAAC;IACrC,CAAC;CACD","file":"replace.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../../base/common/strings.js';\nimport { IPatternInfo } from './search.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { buildReplaceStringWithCasePreserved } from '../../../../base/common/search.js';\n\nexport class ReplacePattern {\n\n\tprivate _replacePattern: string;\n\tprivate _hasParameters: boolean = false;\n\tprivate _regExp: RegExp;\n\tprivate _caseOpsRegExp: RegExp;\n\n\tconstructor(replaceString: string, searchPatternInfo: IPatternInfo);\n\tconstructor(replaceString: string, parseParameters: boolean, regEx: RegExp);\n\tconstructor(replaceString: string, arg2: any, arg3?: any) {\n\t\tthis._replacePattern = replaceString;\n\t\tlet searchPatternInfo: IPatternInfo;\n\t\tlet parseParameters: boolean;\n\t\tif (typeof arg2 === 'boolean') {\n\t\t\tparseParameters = arg2;\n\t\t\tthis._regExp = arg3;\n\n\t\t} else {\n\t\t\tsearchPatternInfo = arg2;\n\t\t\tparseParameters = !!searchPatternInfo.isRegExp;\n\t\t\tthis._regExp = strings.createRegExp(searchPatternInfo.pattern, !!searchPatternInfo.isRegExp, { matchCase: searchPatternInfo.isCaseSensitive, wholeWord: searchPatternInfo.isWordMatch, multiline: searchPatternInfo.isMultiline, global: false, unicode: true });\n\t\t}\n\n\t\tif (parseParameters) {\n\t\t\tthis.parseReplaceString(replaceString);\n\t\t}\n\n\t\tif (this._regExp.global) {\n\t\t\tthis._regExp = strings.createRegExp(this._regExp.source, true, { matchCase: !this._regExp.ignoreCase, wholeWord: false, multiline: this._regExp.multiline, global: false });\n\t\t}\n\n\t\tthis._caseOpsRegExp = new RegExp(/([\\s\\S]*?)((?:\\\\[uUlL])+?|)(\\$[0-9]+)([\\s\\S]*?)/g);\n\t}\n\n\tget hasParameters(): boolean {\n\t\treturn this._hasParameters;\n\t}\n\n\tget pattern(): string {\n\t\treturn this._replacePattern;\n\t}\n\n\tget regExp(): RegExp {\n\t\treturn this._regExp;\n\t}\n\n\t/**\n\t* Returns the replace string for the first match in the given text.\n\t* If text has no matches then returns null.\n\t*/\n\tgetReplaceString(text: string, preserveCase?: boolean): string | null {\n\t\tthis._regExp.lastIndex = 0;\n\t\tconst match = this._regExp.exec(text);\n\t\tif (match) {\n\t\t\tif (this.hasParameters) {\n\t\t\t\tconst replaceString = this.replaceWithCaseOperations(text, this._regExp, this.buildReplaceString(match, preserveCase));\n\t\t\t\tif (match[0] === text) {\n\t\t\t\t\treturn replaceString;\n\t\t\t\t}\n\t\t\t\treturn replaceString.substr(match.index, match[0].length - (text.length - replaceString.length));\n\t\t\t}\n\t\t\treturn this.buildReplaceString(match, preserveCase);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * replaceWithCaseOperations applies case operations to relevant replacement strings and applies\n\t * the affected $N arguments. It then passes unaffected $N arguments through to string.replace().\n\t *\n\t * \\u\t\t\t=> upper-cases one character in a match.\n\t * \\U\t\t\t=> upper-cases ALL remaining characters in a match.\n\t * \\l\t\t\t=> lower-cases one character in a match.\n\t * \\L\t\t\t=> lower-cases ALL remaining characters in a match.\n\t */\n\tprivate replaceWithCaseOperations(text: string, regex: RegExp, replaceString: string): string {\n\t\t// Short-circuit the common path.\n\t\tif (!/\\\\[uUlL]/.test(replaceString)) {\n\t\t\treturn text.replace(regex, replaceString);\n\t\t}\n\t\t// Store the values of the search parameters.\n\t\tconst firstMatch = regex.exec(text);\n\t\tif (firstMatch === null) {\n\t\t\treturn text.replace(regex, replaceString);\n\t\t}\n\n\t\tlet patMatch: RegExpExecArray | null;\n\t\tlet newReplaceString = '';\n\t\tlet lastIndex = 0;\n\t\tlet lastMatch = '';\n\t\t// For each annotated $N, perform text processing on the parameters and perform the substitution.\n\t\twhile ((patMatch = this._caseOpsRegExp.exec(replaceString)) !== null) {\n\t\t\tlastIndex = patMatch.index;\n\t\t\tconst fullMatch = patMatch[0];\n\t\t\tlastMatch = fullMatch;\n\t\t\tlet caseOps = patMatch[2]; // \\u, \\l\\u, etc.\n\t\t\tconst money = patMatch[3]; // $1, $2, etc.\n\n\t\t\tif (!caseOps) {\n\t\t\t\tnewReplaceString += fullMatch;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst replacement = firstMatch[parseInt(money.slice(1))];\n\t\t\tif (!replacement) {\n\t\t\t\tnewReplaceString += fullMatch;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst replacementLen = replacement.length;\n\n\t\t\tnewReplaceString += patMatch[1]; // prefix\n\t\t\tcaseOps = caseOps.replace(/\\\\/g, '');\n\t\t\tlet i = 0;\n\t\t\tfor (; i < caseOps.length; i++) {\n\t\t\t\tswitch (caseOps[i]) {\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\tnewReplaceString += replacement.slice(i).toUpperCase();\n\t\t\t\t\t\ti = replacementLen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tnewReplaceString += replacement[i].toUpperCase();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tnewReplaceString += replacement.slice(i).toLowerCase();\n\t\t\t\t\t\ti = replacementLen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tnewReplaceString += replacement[i].toLowerCase();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Append any remaining replacement string content not covered by case operations.\n\t\t\tif (i < replacementLen) {\n\t\t\t\tnewReplaceString += replacement.slice(i);\n\t\t\t}\n\n\t\t\tnewReplaceString += patMatch[4]; // suffix\n\t\t}\n\n\t\t// Append any remaining trailing content after the final regex match.\n\t\tnewReplaceString += replaceString.slice(lastIndex + lastMatch.length);\n\n\t\treturn text.replace(regex, newReplaceString);\n\t}\n\n\tpublic buildReplaceString(matches: string[] | null, preserveCase?: boolean): string {\n\t\tif (preserveCase) {\n\t\t\treturn buildReplaceStringWithCasePreserved(matches, this._replacePattern);\n\t\t} else {\n\t\t\treturn this._replacePattern;\n\t\t}\n\t}\n\n\t/**\n\t * \\n => LF\n\t * \\t => TAB\n\t * \\\\ => \\\n\t * $0 => $& (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter)\n\t * everything else stays untouched\n\t */\n\tprivate parseReplaceString(replaceString: string): void {\n\t\tif (!replaceString || replaceString.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet substrFrom = 0, result = '';\n\t\tfor (let i = 0, len = replaceString.length; i < len; i++) {\n\t\t\tconst chCode = replaceString.charCodeAt(i);\n\n\t\t\tif (chCode === CharCode.Backslash) {\n\n\t\t\t\t// move to next char\n\t\t\t\ti++;\n\n\t\t\t\tif (i >= len) {\n\t\t\t\t\t// string ends with a \\\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst nextChCode = replaceString.charCodeAt(i);\n\t\t\t\tlet replaceWithCharacter: string | null = null;\n\n\t\t\t\tswitch (nextChCode) {\n\t\t\t\t\tcase CharCode.Backslash:\n\t\t\t\t\t\t// \\\\ => \\\n\t\t\t\t\t\treplaceWithCharacter = '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharCode.n:\n\t\t\t\t\t\t// \\n => LF\n\t\t\t\t\t\treplaceWithCharacter = '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharCode.t:\n\t\t\t\t\t\t// \\t => TAB\n\t\t\t\t\t\treplaceWithCharacter = '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (replaceWithCharacter) {\n\t\t\t\t\tresult += replaceString.substring(substrFrom, i - 1) + replaceWithCharacter;\n\t\t\t\t\tsubstrFrom = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (chCode === CharCode.DollarSign) {\n\n\t\t\t\t// move to next char\n\t\t\t\ti++;\n\n\t\t\t\tif (i >= len) {\n\t\t\t\t\t// string ends with a $\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst nextChCode = replaceString.charCodeAt(i);\n\t\t\t\tlet replaceWithCharacter: string | null = null;\n\n\t\t\t\tswitch (nextChCode) {\n\t\t\t\t\tcase CharCode.Digit0:\n\t\t\t\t\t\t// $0 => $&\n\t\t\t\t\t\treplaceWithCharacter = '$&';\n\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharCode.BackTick:\n\t\t\t\t\tcase CharCode.SingleQuote:\n\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\t// check if it is a valid string parameter $n (0 <= n <= 99). $0 is already handled by now.\n\t\t\t\t\t\tif (!this.between(nextChCode, CharCode.Digit1, CharCode.Digit9)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === replaceString.length - 1) {\n\t\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet charCode = replaceString.charCodeAt(++i);\n\t\t\t\t\t\tif (!this.between(charCode, CharCode.Digit0, CharCode.Digit9)) {\n\t\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\t\t--i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === replaceString.length - 1) {\n\t\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcharCode = replaceString.charCodeAt(++i);\n\t\t\t\t\t\tif (!this.between(charCode, CharCode.Digit0, CharCode.Digit9)) {\n\t\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\t\t--i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (replaceWithCharacter) {\n\t\t\t\t\tresult += replaceString.substring(substrFrom, i - 1) + replaceWithCharacter;\n\t\t\t\t\tsubstrFrom = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (substrFrom === 0) {\n\t\t\t// no replacement occurred\n\t\t\treturn;\n\t\t}\n\n\t\tthis._replacePattern = result + replaceString.substring(substrFrom);\n\t}\n\n\tprivate between(value: number, from: number, to: number): boolean {\n\t\treturn from <= value && value <= to;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../../base/common/strings.js';\nimport { IPatternInfo } from './search.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { buildReplaceStringWithCasePreserved } from '../../../../base/common/search.js';\n\nexport class ReplacePattern {\n\n\tprivate _replacePattern: string;\n\tprivate _hasParameters: boolean = false;\n\tprivate _regExp: RegExp;\n\tprivate _caseOpsRegExp: RegExp;\n\n\tconstructor(replaceString: string, searchPatternInfo: IPatternInfo);\n\tconstructor(replaceString: string, parseParameters: boolean, regEx: RegExp);\n\tconstructor(replaceString: string, arg2: any, arg3?: any) {\n\t\tthis._replacePattern = replaceString;\n\t\tlet searchPatternInfo: IPatternInfo;\n\t\tlet parseParameters: boolean;\n\t\tif (typeof arg2 === 'boolean') {\n\t\t\tparseParameters = arg2;\n\t\t\tthis._regExp = arg3;\n\n\t\t} else {\n\t\t\tsearchPatternInfo = arg2;\n\t\t\tparseParameters = !!searchPatternInfo.isRegExp;\n\t\t\tthis._regExp = strings.createRegExp(searchPatternInfo.pattern, !!searchPatternInfo.isRegExp, { matchCase: searchPatternInfo.isCaseSensitive, wholeWord: searchPatternInfo.isWordMatch, multiline: searchPatternInfo.isMultiline, global: false, unicode: true });\n\t\t}\n\n\t\tif (parseParameters) {\n\t\t\tthis.parseReplaceString(replaceString);\n\t\t}\n\n\t\tif (this._regExp.global) {\n\t\t\tthis._regExp = strings.createRegExp(this._regExp.source, true, { matchCase: !this._regExp.ignoreCase, wholeWord: false, multiline: this._regExp.multiline, global: false });\n\t\t}\n\n\t\tthis._caseOpsRegExp = new RegExp(/([\\s\\S]*?)((?:\\\\[uUlL])+?|)(\\$[0-9]+)([\\s\\S]*?)/g);\n\t}\n\n\tget hasParameters(): boolean {\n\t\treturn this._hasParameters;\n\t}\n\n\tget pattern(): string {\n\t\treturn this._replacePattern;\n\t}\n\n\tget regExp(): RegExp {\n\t\treturn this._regExp;\n\t}\n\n\t/**\n\t* Returns the replace string for the first match in the given text.\n\t* If text has no matches then returns null.\n\t*/\n\tgetReplaceString(text: string, preserveCase?: boolean): string | null {\n\t\tthis._regExp.lastIndex = 0;\n\t\tconst match = this._regExp.exec(text);\n\t\tif (match) {\n\t\t\tif (this.hasParameters) {\n\t\t\t\tconst replaceString = this.replaceWithCaseOperations(text, this._regExp, this.buildReplaceString(match, preserveCase));\n\t\t\t\tif (match[0] === text) {\n\t\t\t\t\treturn replaceString;\n\t\t\t\t}\n\t\t\t\treturn replaceString.substr(match.index, match[0].length - (text.length - replaceString.length));\n\t\t\t}\n\t\t\treturn this.buildReplaceString(match, preserveCase);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * replaceWithCaseOperations applies case operations to relevant replacement strings and applies\n\t * the affected $N arguments. It then passes unaffected $N arguments through to string.replace().\n\t *\n\t * \\u\t\t\t=> upper-cases one character in a match.\n\t * \\U\t\t\t=> upper-cases ALL remaining characters in a match.\n\t * \\l\t\t\t=> lower-cases one character in a match.\n\t * \\L\t\t\t=> lower-cases ALL remaining characters in a match.\n\t */\n\tprivate replaceWithCaseOperations(text: string, regex: RegExp, replaceString: string): string {\n\t\t// Short-circuit the common path.\n\t\tif (!/\\\\[uUlL]/.test(replaceString)) {\n\t\t\treturn text.replace(regex, replaceString);\n\t\t}\n\t\t// Store the values of the search parameters.\n\t\tconst firstMatch = regex.exec(text);\n\t\tif (firstMatch === null) {\n\t\t\treturn text.replace(regex, replaceString);\n\t\t}\n\n\t\tlet patMatch: RegExpExecArray | null;\n\t\tlet newReplaceString = '';\n\t\tlet lastIndex = 0;\n\t\tlet lastMatch = '';\n\t\t// For each annotated $N, perform text processing on the parameters and perform the substitution.\n\t\twhile ((patMatch = this._caseOpsRegExp.exec(replaceString)) !== null) {\n\t\t\tlastIndex = patMatch.index;\n\t\t\tconst fullMatch = patMatch[0];\n\t\t\tlastMatch = fullMatch;\n\t\t\tlet caseOps = patMatch[2]; // \\u, \\l\\u, etc.\n\t\t\tconst money = patMatch[3]; // $1, $2, etc.\n\n\t\t\tif (!caseOps) {\n\t\t\t\tnewReplaceString += fullMatch;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst replacement = firstMatch[parseInt(money.slice(1))];\n\t\t\tif (!replacement) {\n\t\t\t\tnewReplaceString += fullMatch;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst replacementLen = replacement.length;\n\n\t\t\tnewReplaceString += patMatch[1]; // prefix\n\t\t\tcaseOps = caseOps.replace(/\\\\/g, '');\n\t\t\tlet i = 0;\n\t\t\tfor (; i < caseOps.length; i++) {\n\t\t\t\tswitch (caseOps[i]) {\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\tnewReplaceString += replacement.slice(i).toUpperCase();\n\t\t\t\t\t\ti = replacementLen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tnewReplaceString += replacement[i].toUpperCase();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tnewReplaceString += replacement.slice(i).toLowerCase();\n\t\t\t\t\t\ti = replacementLen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tnewReplaceString += replacement[i].toLowerCase();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Append any remaining replacement string content not covered by case operations.\n\t\t\tif (i < replacementLen) {\n\t\t\t\tnewReplaceString += replacement.slice(i);\n\t\t\t}\n\n\t\t\tnewReplaceString += patMatch[4]; // suffix\n\t\t}\n\n\t\t// Append any remaining trailing content after the final regex match.\n\t\tnewReplaceString += replaceString.slice(lastIndex + lastMatch.length);\n\n\t\treturn text.replace(regex, newReplaceString);\n\t}\n\n\tpublic buildReplaceString(matches: string[] | null, preserveCase?: boolean): string {\n\t\tif (preserveCase) {\n\t\t\treturn buildReplaceStringWithCasePreserved(matches, this._replacePattern);\n\t\t} else {\n\t\t\treturn this._replacePattern;\n\t\t}\n\t}\n\n\t/**\n\t * \\n => LF\n\t * \\t => TAB\n\t * \\\\ => \\\n\t * $0 => $& (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter)\n\t * everything else stays untouched\n\t */\n\tprivate parseReplaceString(replaceString: string): void {\n\t\tif (!replaceString || replaceString.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet substrFrom = 0, result = '';\n\t\tfor (let i = 0, len = replaceString.length; i < len; i++) {\n\t\t\tconst chCode = replaceString.charCodeAt(i);\n\n\t\t\tif (chCode === CharCode.Backslash) {\n\n\t\t\t\t// move to next char\n\t\t\t\ti++;\n\n\t\t\t\tif (i >= len) {\n\t\t\t\t\t// string ends with a \\\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst nextChCode = replaceString.charCodeAt(i);\n\t\t\t\tlet replaceWithCharacter: string | null = null;\n\n\t\t\t\tswitch (nextChCode) {\n\t\t\t\t\tcase CharCode.Backslash:\n\t\t\t\t\t\t// \\\\ => \\\n\t\t\t\t\t\treplaceWithCharacter = '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharCode.n:\n\t\t\t\t\t\t// \\n => LF\n\t\t\t\t\t\treplaceWithCharacter = '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharCode.t:\n\t\t\t\t\t\t// \\t => TAB\n\t\t\t\t\t\treplaceWithCharacter = '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (replaceWithCharacter) {\n\t\t\t\t\tresult += replaceString.substring(substrFrom, i - 1) + replaceWithCharacter;\n\t\t\t\t\tsubstrFrom = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (chCode === CharCode.DollarSign) {\n\n\t\t\t\t// move to next char\n\t\t\t\ti++;\n\n\t\t\t\tif (i >= len) {\n\t\t\t\t\t// string ends with a $\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst nextChCode = replaceString.charCodeAt(i);\n\t\t\t\tlet replaceWithCharacter: string | null = null;\n\n\t\t\t\tswitch (nextChCode) {\n\t\t\t\t\tcase CharCode.Digit0:\n\t\t\t\t\t\t// $0 => $&\n\t\t\t\t\t\treplaceWithCharacter = '$&';\n\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharCode.BackTick:\n\t\t\t\t\tcase CharCode.SingleQuote:\n\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\t// check if it is a valid string parameter $n (0 <= n <= 99). $0 is already handled by now.\n\t\t\t\t\t\tif (!this.between(nextChCode, CharCode.Digit1, CharCode.Digit9)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === replaceString.length - 1) {\n\t\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet charCode = replaceString.charCodeAt(++i);\n\t\t\t\t\t\tif (!this.between(charCode, CharCode.Digit0, CharCode.Digit9)) {\n\t\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\t\t--i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i === replaceString.length - 1) {\n\t\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcharCode = replaceString.charCodeAt(++i);\n\t\t\t\t\t\tif (!this.between(charCode, CharCode.Digit0, CharCode.Digit9)) {\n\t\t\t\t\t\t\tthis._hasParameters = true;\n\t\t\t\t\t\t\t--i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (replaceWithCharacter) {\n\t\t\t\t\tresult += replaceString.substring(substrFrom, i - 1) + replaceWithCharacter;\n\t\t\t\t\tsubstrFrom = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (substrFrom === 0) {\n\t\t\t// no replacement occurred\n\t\t\treturn;\n\t\t}\n\n\t\tthis._replacePattern = result + replaceString.substring(substrFrom);\n\t}\n\n\tprivate between(value: number, from: number, to: number): boolean {\n\t\treturn from <= value && value <= to;\n\t}\n}\n"]}