{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/common/folderQuerySearchTree.ts","vs/workbench/services/search/common/folderQuerySearchTree.ts"],"names":[],"mappings":"AAMA,OAAO,EAAE,iBAAiB,EAAE,WAAW,EAAE,MAAM,8CAA8C,CAAC;AAC9F,OAAO,EAAE,WAAW,EAAE,MAAM,gCAAgC,CAAC;AAE7D;;;GAGG;AACH,MAAM,OAAO,qBAA+D,SAAQ,iBAAoD;IACvI,YAAY,aAAkC,EAC7C,kBAAoE,EACpE,mBAA0C,GAAG,EAAE,CAAC,KAAK;QAErD,MAAM,WAAW,GAAG,IAAI,WAAW,CAAC,gBAAgB,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC;QACnE,KAAK,CAAC,WAAW,CAAC,CAAC;QAEnB,MAAM,YAAY,GAAG,IAAI,WAAW,EAA0C,CAAC;QAC/E,aAAa,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE;YAC/B,MAAM,yBAAyB,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC;YAC9E,IAAI,YAAY,CAAC,GAAG,CAAC,yBAAyB,CAAC,EAAE,CAAC;gBACjD,YAAY,CAAC,GAAG,CAAC,yBAAyB,CAAE,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;YAC9D,CAAC;iBAAM,CAAC;gBACP,YAAY,CAAC,GAAG,CAAC,yBAAyB,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAC1D,CAAC;QACF,CAAC,CAAC,CAAC;QACH,YAAY,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE;YACpC,MAAM,wBAAwB,GAAG,IAAI,GAAG,EAA2B,CAAC;YACpE,KAAK,MAAM,OAAO,IAAI,MAAM,EAAE,CAAC;gBAC9B,MAAM,eAAe,GAAG,kBAAkB,CAAC,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;gBAClE,wBAAwB,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,CAAC,MAAM,CAAC,EAAE,eAAe,CAAC,CAAC;YAClF,CAAC;YACD,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,wBAAwB,CAAC,CAAC;QAC1C,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,4BAA4B,CAAC,GAAQ;QAEpC,MAAM,aAAa,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QAC9E,IAAI,CAAC,aAAa,EAAE,CAAC;YACpB,OAAO,SAAS,CAAC;QAClB,CAAC;QACD,MAAM,mBAAmB,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;QAChD,OAAO,aAAa,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC;IAE/C,CAAC;IAED,sBAAsB,CAAC,EAA8C;QACpE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IACnE,CAAC;IAEO,SAAS,CAAC,GAAQ;QACzB,IAAI,GAAG,GAAG,EAAE,CAAC;QACb,IAAI,GAAG,CAAC,KAAK,EAAE,CAAC;YACf,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC;QAClB,CAAC;QACD,IAAI,GAAG,CAAC,QAAQ,EAAE,CAAC;YAClB,GAAG,IAAI,GAAG,GAAG,GAAG,CAAC,QAAQ,CAAC;QAC3B,CAAC;QACD,OAAO,GAAG,CAAC;IACZ,CAAC;CAED","file":"folderQuerySearchTree.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { URI } from '../../../../base/common/uri.js';\nimport { IFolderQuery } from './search.js';\nimport { TernarySearchTree, UriIterator } from '../../../../base/common/ternarySearchTree.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\n\n/**\n * A ternary search tree that supports URI keys and query/fragment-aware substring matching, specifically for file search.\n * This is because the traditional TST does not support query and fragments https://github.com/microsoft/vscode/issues/227836\n */\nexport class FolderQuerySearchTree<FolderQueryInfo extends { folder: URI }> extends TernarySearchTree<URI, Map<string, FolderQueryInfo>> {\n\tconstructor(folderQueries: IFolderQuery<URI>[],\n\t\tgetFolderQueryInfo: (fq: IFolderQuery, i: number) => FolderQueryInfo,\n\t\tignorePathCasing: (key: URI) => boolean = () => false\n\t) {\n\t\tconst uriIterator = new UriIterator(ignorePathCasing, () => false);\n\t\tsuper(uriIterator);\n\n\t\tconst fqBySameBase = new ResourceMap<{ fq: IFolderQuery<URI>; i: number }[]>();\n\t\tfolderQueries.forEach((fq, i) => {\n\t\t\tconst uriWithoutQueryOrFragment = fq.folder.with({ query: '', fragment: '' });\n\t\t\tif (fqBySameBase.has(uriWithoutQueryOrFragment)) {\n\t\t\t\tfqBySameBase.get(uriWithoutQueryOrFragment)!.push({ fq, i });\n\t\t\t} else {\n\t\t\t\tfqBySameBase.set(uriWithoutQueryOrFragment, [{ fq, i }]);\n\t\t\t}\n\t\t});\n\t\tfqBySameBase.forEach((values, key) => {\n\t\t\tconst folderQueriesWithQueries = new Map<string, FolderQueryInfo>();\n\t\t\tfor (const fqBases of values) {\n\t\t\t\tconst folderQueryInfo = getFolderQueryInfo(fqBases.fq, fqBases.i);\n\t\t\t\tfolderQueriesWithQueries.set(this.encodeKey(fqBases.fq.folder), folderQueryInfo);\n\t\t\t}\n\t\t\tsuper.set(key, folderQueriesWithQueries);\n\t\t});\n\t}\n\n\tfindQueryFragmentAwareSubstr(key: URI): FolderQueryInfo | undefined {\n\n\t\tconst baseURIResult = super.findSubstr(key.with({ query: '', fragment: '' }));\n\t\tif (!baseURIResult) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst queryAndFragmentKey = this.encodeKey(key);\n\t\treturn baseURIResult.get(queryAndFragmentKey);\n\n\t}\n\n\tforEachFolderQueryInfo(fn: (folderQueryInfo: FolderQueryInfo) => void): void {\n\t\treturn this.forEach(elem => elem.forEach(mapElem => fn(mapElem)));\n\t}\n\n\tprivate encodeKey(key: URI): string {\n\t\tlet str = '';\n\t\tif (key.query) {\n\t\t\tstr += key.query;\n\t\t}\n\t\tif (key.fragment) {\n\t\t\tstr += '#' + key.fragment;\n\t\t}\n\t\treturn str;\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { URI } from '../../../../base/common/uri.js';\nimport { IFolderQuery } from './search.js';\nimport { TernarySearchTree, UriIterator } from '../../../../base/common/ternarySearchTree.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\n\n/**\n * A ternary search tree that supports URI keys and query/fragment-aware substring matching, specifically for file search.\n * This is because the traditional TST does not support query and fragments https://github.com/microsoft/vscode/issues/227836\n */\nexport class FolderQuerySearchTree<FolderQueryInfo extends { folder: URI }> extends TernarySearchTree<URI, Map<string, FolderQueryInfo>> {\n\tconstructor(folderQueries: IFolderQuery<URI>[],\n\t\tgetFolderQueryInfo: (fq: IFolderQuery, i: number) => FolderQueryInfo,\n\t\tignorePathCasing: (key: URI) => boolean = () => false\n\t) {\n\t\tconst uriIterator = new UriIterator(ignorePathCasing, () => false);\n\t\tsuper(uriIterator);\n\n\t\tconst fqBySameBase = new ResourceMap<{ fq: IFolderQuery<URI>; i: number }[]>();\n\t\tfolderQueries.forEach((fq, i) => {\n\t\t\tconst uriWithoutQueryOrFragment = fq.folder.with({ query: '', fragment: '' });\n\t\t\tif (fqBySameBase.has(uriWithoutQueryOrFragment)) {\n\t\t\t\tfqBySameBase.get(uriWithoutQueryOrFragment)!.push({ fq, i });\n\t\t\t} else {\n\t\t\t\tfqBySameBase.set(uriWithoutQueryOrFragment, [{ fq, i }]);\n\t\t\t}\n\t\t});\n\t\tfqBySameBase.forEach((values, key) => {\n\t\t\tconst folderQueriesWithQueries = new Map<string, FolderQueryInfo>();\n\t\t\tfor (const fqBases of values) {\n\t\t\t\tconst folderQueryInfo = getFolderQueryInfo(fqBases.fq, fqBases.i);\n\t\t\t\tfolderQueriesWithQueries.set(this.encodeKey(fqBases.fq.folder), folderQueryInfo);\n\t\t\t}\n\t\t\tsuper.set(key, folderQueriesWithQueries);\n\t\t});\n\t}\n\n\tfindQueryFragmentAwareSubstr(key: URI): FolderQueryInfo | undefined {\n\n\t\tconst baseURIResult = super.findSubstr(key.with({ query: '', fragment: '' }));\n\t\tif (!baseURIResult) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst queryAndFragmentKey = this.encodeKey(key);\n\t\treturn baseURIResult.get(queryAndFragmentKey);\n\n\t}\n\n\tforEachFolderQueryInfo(fn: (folderQueryInfo: FolderQueryInfo) => void): void {\n\t\treturn this.forEach(elem => elem.forEach(mapElem => fn(mapElem)));\n\t}\n\n\tprivate encodeKey(key: URI): string {\n\t\tlet str = '';\n\t\tif (key.query) {\n\t\t\tstr += key.query;\n\t\t}\n\t\tif (key.fragment) {\n\t\t\tstr += '#' + key.fragment;\n\t\t}\n\t\treturn str;\n\t}\n\n}\n"]}