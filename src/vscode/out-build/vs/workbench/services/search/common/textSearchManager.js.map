{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/common/textSearchManager.ts","vs/workbench/services/search/common/textSearchManager.ts"],"names":[],"mappings":"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","file":"textSearchManager.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isThenable } from '../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport * as path from '../../../../base/common/path.js';\nimport * as resources from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { FolderQuerySearchTree } from './folderQuerySearchTree.js';\nimport { DEFAULT_MAX_SEARCH_RESULTS, hasSiblingPromiseFn, IAITextQuery, IExtendedExtensionSearchOptions, IFileMatch, IFolderQuery, excludeToGlobPattern, IPatternInfo, ISearchCompleteStats, ITextQuery, ITextSearchContext, ITextSearchMatch, ITextSearchResult, ITextSearchStats, QueryGlobTester, QueryType, resolvePatternsForProvider, ISearchRange, DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS } from './search.js';\nimport { TextSearchComplete2, TextSearchMatch2, TextSearchProviderFolderOptions, TextSearchProvider2, TextSearchProviderOptions, TextSearchQuery2, TextSearchResult2, AITextSearchProvider, AISearchResult, AISearchKeyword } from './searchExtTypes.js';\n\nexport interface IFileUtils {\n\treaddir: (resource: URI) => Promise<string[]>;\n\ttoCanonicalName: (encoding: string) => string;\n}\ninterface IAITextQueryProviderPair {\n\tquery: IAITextQuery; provider: AITextSearchProvider;\n}\n\ninterface ITextQueryProviderPair {\n\tquery: ITextQuery; provider: TextSearchProvider2;\n}\ninterface FolderQueryInfo {\n\tqueryTester: QueryGlobTester;\n\tfolder: URI;\n\tfolderIdx: number;\n}\n\nexport class TextSearchManager {\n\n\tprivate collector: TextSearchResultsCollector | null = null;\n\n\tprivate isLimitHit = false;\n\tprivate resultCount = 0;\n\n\tconstructor(private queryProviderPair: IAITextQueryProviderPair | ITextQueryProviderPair,\n\t\tprivate fileUtils: IFileUtils,\n\t\tprivate processType: ITextSearchStats['type']) { }\n\n\tprivate get query() {\n\t\treturn this.queryProviderPair.query;\n\t}\n\n\tsearch(onProgress: (matches: IFileMatch[]) => void, token: CancellationToken, onKeywordResult?: (keyword: AISearchKeyword) => void): Promise<ISearchCompleteStats> {\n\t\tconst folderQueries = this.query.folderQueries || [];\n\t\tconst tokenSource = new CancellationTokenSource(token);\n\n\t\treturn new Promise<ISearchCompleteStats>((resolve, reject) => {\n\t\t\tthis.collector = new TextSearchResultsCollector(onProgress);\n\n\t\t\tlet isCanceled = false;\n\t\t\tconst onResult = (result: TextSearchResult2, folderIdx: number) => {\n\t\t\t\tif (result instanceof AISearchKeyword) {\n\t\t\t\t\t// Already processed by the callback.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (isCanceled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this.isLimitHit) {\n\t\t\t\t\tconst resultSize = this.resultSize(result);\n\t\t\t\t\tif (result instanceof TextSearchMatch2 && typeof this.query.maxResults === 'number' && this.resultCount + resultSize > this.query.maxResults) {\n\t\t\t\t\t\tthis.isLimitHit = true;\n\t\t\t\t\t\tisCanceled = true;\n\t\t\t\t\t\ttokenSource.cancel();\n\n\t\t\t\t\t\tresult = this.trimResultToSize(result, this.query.maxResults - this.resultCount);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst newResultSize = this.resultSize(result);\n\t\t\t\t\tthis.resultCount += newResultSize;\n\t\t\t\t\tconst a = result instanceof TextSearchMatch2;\n\n\t\t\t\t\tif (newResultSize > 0 || !a) {\n\t\t\t\t\t\tthis.collector!.add(result, folderIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// For each root folder\n\t\t\tthis.doSearch(folderQueries, onResult, tokenSource.token, onKeywordResult).then(result => {\n\t\t\t\ttokenSource.dispose();\n\t\t\t\tthis.collector!.flush();\n\n\t\t\t\tresolve({\n\t\t\t\t\tlimitHit: this.isLimitHit || result?.limitHit,\n\t\t\t\t\tmessages: this.getMessagesFromResults(result),\n\t\t\t\t\tstats: {\n\t\t\t\t\t\ttype: this.processType\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, (err: Error) => {\n\t\t\t\ttokenSource.dispose();\n\t\t\t\tconst errMsg = toErrorMessage(err);\n\t\t\t\treject(new Error(errMsg));\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate getMessagesFromResults(result: TextSearchComplete2 | null | undefined) {\n\t\tif (!result?.message) { return []; }\n\t\tif (Array.isArray(result.message)) { return result.message; }\n\t\treturn [result.message];\n\t}\n\n\tprivate resultSize(result: TextSearchResult2): number {\n\t\tif (result instanceof TextSearchMatch2) {\n\t\t\treturn Array.isArray(result.ranges) ?\n\t\t\t\tresult.ranges.length :\n\t\t\t\t1;\n\t\t}\n\t\telse {\n\t\t\t// #104400 context lines shoudn't count towards result count\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate trimResultToSize(result: TextSearchMatch2, size: number): TextSearchMatch2 {\n\t\treturn new TextSearchMatch2(result.uri, result.ranges.slice(0, size), result.previewText);\n\t}\n\n\tprivate async doSearch(folderQueries: IFolderQuery<URI>[], onResult: (result: TextSearchResult2, folderIdx: number) => void, token: CancellationToken, onKeywordResult?: (keyword: AISearchKeyword) => void): Promise<TextSearchComplete2 | null | undefined> {\n\t\tconst folderMappings: FolderQuerySearchTree<FolderQueryInfo> = new FolderQuerySearchTree<FolderQueryInfo>(\n\t\t\tfolderQueries,\n\t\t\t(fq, i) => {\n\t\t\t\tconst queryTester = new QueryGlobTester(this.query, fq);\n\t\t\t\treturn { queryTester, folder: fq.folder, folderIdx: i };\n\t\t\t},\n\t\t\t() => true\n\t\t);\n\n\t\tconst testingPs: Promise<void>[] = [];\n\t\tconst progress = {\n\t\t\treport: (result: TextSearchResult2 | AISearchResult) => {\n\t\t\t\tif (result instanceof AISearchKeyword) {\n\t\t\t\t\tonKeywordResult?.(result);\n\t\t\t\t} else {\n\t\t\t\t\tif (result.uri === undefined) {\n\t\t\t\t\t\tthrow Error('Text search result URI is undefined. Please check provider implementation.');\n\t\t\t\t\t}\n\t\t\t\t\tconst folderQuery = folderMappings.findQueryFragmentAwareSubstr(result.uri)!;\n\t\t\t\t\tconst hasSibling = folderQuery.folder.scheme === Schemas.file ?\n\t\t\t\t\t\thasSiblingPromiseFn(() => {\n\t\t\t\t\t\t\treturn this.fileUtils.readdir(resources.dirname(result.uri));\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tundefined;\n\n\t\t\t\t\tconst relativePath = resources.relativePath(folderQuery.folder, result.uri);\n\t\t\t\t\tif (relativePath) {\n\t\t\t\t\t\t// This method is only async when the exclude contains sibling clauses\n\t\t\t\t\t\tconst included = folderQuery.queryTester.includedInQuery(relativePath, path.basename(relativePath), hasSibling);\n\t\t\t\t\t\tif (isThenable(included)) {\n\t\t\t\t\t\t\ttestingPs.push(\n\t\t\t\t\t\t\t\tincluded.then(isIncluded => {\n\t\t\t\t\t\t\t\t\tif (isIncluded) {\n\t\t\t\t\t\t\t\t\t\tonResult(result, folderQuery.folderIdx);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t} else if (included) {\n\t\t\t\t\t\t\tonResult(result, folderQuery.folderIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst folderOptions = folderQueries.map(fq => this.getSearchOptionsForFolder(fq));\n\t\tconst searchOptions: TextSearchProviderOptions = {\n\t\t\tfolderOptions,\n\t\t\tmaxFileSize: this.query.maxFileSize,\n\t\t\tmaxResults: this.query.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS,\n\t\t\tpreviewOptions: this.query.previewOptions ?? DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS,\n\t\t\tsurroundingContext: this.query.surroundingContext ?? 0,\n\t\t};\n\t\tif ('usePCRE2' in this.query) {\n\t\t\t(<IExtendedExtensionSearchOptions>searchOptions).usePCRE2 = this.query.usePCRE2;\n\t\t}\n\n\t\tlet result;\n\t\tif (this.queryProviderPair.query.type === QueryType.aiText) {\n\t\t\tresult = await (this.queryProviderPair as IAITextQueryProviderPair).provider.provideAITextSearchResults(this.queryProviderPair.query.contentPattern, searchOptions, progress, token);\n\t\t} else {\n\t\t\tresult = await (this.queryProviderPair as ITextQueryProviderPair).provider.provideTextSearchResults(patternInfoToQuery(this.queryProviderPair.query.contentPattern), searchOptions, progress, token);\n\t\t}\n\t\tif (testingPs.length) {\n\t\t\tawait Promise.all(testingPs);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate getSearchOptionsForFolder(fq: IFolderQuery<URI>): TextSearchProviderFolderOptions {\n\t\tconst includes = resolvePatternsForProvider(this.query.includePattern, fq.includePattern);\n\n\t\tlet excludePattern = fq.excludePattern?.map(e => ({\n\t\t\tfolder: e.folder,\n\t\t\tpatterns: resolvePatternsForProvider(this.query.excludePattern, e.pattern)\n\t\t}));\n\n\t\tif (!excludePattern || excludePattern.length === 0) {\n\t\t\texcludePattern = [{\n\t\t\t\tfolder: undefined,\n\t\t\t\tpatterns: resolvePatternsForProvider(this.query.excludePattern, undefined)\n\t\t\t}];\n\t\t}\n\t\tconst excludes = excludeToGlobPattern(excludePattern);\n\n\t\tconst options = {\n\t\t\tfolder: URI.from(fq.folder),\n\t\t\texcludes,\n\t\t\tincludes,\n\t\t\tuseIgnoreFiles: {\n\t\t\t\tlocal: !fq.disregardIgnoreFiles,\n\t\t\t\tparent: !fq.disregardParentIgnoreFiles,\n\t\t\t\tglobal: !fq.disregardGlobalIgnoreFiles\n\t\t\t},\n\t\t\tfollowSymlinks: !fq.ignoreSymlinks,\n\t\t\tencoding: (fq.fileEncoding && this.fileUtils.toCanonicalName(fq.fileEncoding)) ?? '',\n\t\t};\n\t\treturn options;\n\t}\n}\n\nfunction patternInfoToQuery(patternInfo: IPatternInfo): TextSearchQuery2 {\n\treturn {\n\t\tisCaseSensitive: patternInfo.isCaseSensitive || false,\n\t\tisRegExp: patternInfo.isRegExp || false,\n\t\tisWordMatch: patternInfo.isWordMatch || false,\n\t\tisMultiline: patternInfo.isMultiline || false,\n\t\tpattern: patternInfo.pattern\n\t};\n}\n\nexport class TextSearchResultsCollector {\n\tprivate _batchedCollector: BatchedCollector<IFileMatch>;\n\n\tprivate _currentFolderIdx: number = -1;\n\tprivate _currentUri: URI | undefined;\n\tprivate _currentFileMatch: IFileMatch | null = null;\n\n\tconstructor(private _onResult: (result: IFileMatch[]) => void) {\n\t\tthis._batchedCollector = new BatchedCollector<IFileMatch>(512, items => this.sendItems(items));\n\t}\n\n\tadd(data: TextSearchResult2, folderIdx: number): void {\n\t\t// Collects TextSearchResults into IInternalFileMatches and collates using BatchedCollector.\n\t\t// This is efficient for ripgrep which sends results back one file at a time. It wouldn't be efficient for other search\n\t\t// providers that send results in random order. We could do this step afterwards instead.\n\t\tif (this._currentFileMatch && (this._currentFolderIdx !== folderIdx || !resources.isEqual(this._currentUri, data.uri))) {\n\t\t\tthis.pushToCollector();\n\t\t\tthis._currentFileMatch = null;\n\t\t}\n\n\t\tif (!this._currentFileMatch) {\n\t\t\tthis._currentFolderIdx = folderIdx;\n\t\t\tthis._currentFileMatch = {\n\t\t\t\tresource: data.uri,\n\t\t\t\tresults: []\n\t\t\t};\n\t\t}\n\n\t\tthis._currentFileMatch.results!.push(extensionResultToFrontendResult(data));\n\t}\n\n\tprivate pushToCollector(): void {\n\t\tconst size = this._currentFileMatch && this._currentFileMatch.results ?\n\t\t\tthis._currentFileMatch.results.length :\n\t\t\t0;\n\t\tthis._batchedCollector.addItem(this._currentFileMatch!, size);\n\t}\n\n\tflush(): void {\n\t\tthis.pushToCollector();\n\t\tthis._batchedCollector.flush();\n\t}\n\n\tprivate sendItems(items: IFileMatch[]): void {\n\t\tthis._onResult(items);\n\t}\n}\n\nfunction extensionResultToFrontendResult(data: TextSearchResult2): ITextSearchResult {\n\t// Warning: result from RipgrepTextSearchEH has fake Range. Don't depend on any other props beyond these...\n\tif (data instanceof TextSearchMatch2) {\n\t\treturn {\n\t\t\tpreviewText: data.previewText,\n\t\t\trangeLocations: data.ranges.map(r => ({\n\t\t\t\tpreview: {\n\t\t\t\t\tstartLineNumber: r.previewRange.start.line,\n\t\t\t\t\tstartColumn: r.previewRange.start.character,\n\t\t\t\t\tendLineNumber: r.previewRange.end.line,\n\t\t\t\t\tendColumn: r.previewRange.end.character\n\t\t\t\t} satisfies ISearchRange,\n\t\t\t\tsource: {\n\t\t\t\t\tstartLineNumber: r.sourceRange.start.line,\n\t\t\t\t\tstartColumn: r.sourceRange.start.character,\n\t\t\t\t\tendLineNumber: r.sourceRange.end.line,\n\t\t\t\t\tendColumn: r.sourceRange.end.character\n\t\t\t\t} satisfies ISearchRange,\n\t\t\t})),\n\t\t} satisfies ITextSearchMatch;\n\t} else {\n\t\treturn {\n\t\t\ttext: data.text,\n\t\t\tlineNumber: data.lineNumber\n\t\t} satisfies ITextSearchContext;\n\t}\n}\n\n\n/**\n * Collects items that have a size - before the cumulative size of collected items reaches START_BATCH_AFTER_COUNT, the callback is called for every\n * set of items collected.\n * But after that point, the callback is called with batches of maxBatchSize.\n * If the batch isn't filled within some time, the callback is also called.\n */\nexport class BatchedCollector<T> {\n\tprivate static readonly TIMEOUT = 4000;\n\n\t// After START_BATCH_AFTER_COUNT items have been collected, stop flushing on timeout\n\tprivate static readonly START_BATCH_AFTER_COUNT = 50;\n\n\tprivate totalNumberCompleted = 0;\n\tprivate batch: T[] = [];\n\tprivate batchSize = 0;\n\tprivate timeoutHandle: Timeout | undefined;\n\n\tconstructor(private maxBatchSize: number, private cb: (items: T[]) => void) {\n\t}\n\n\taddItem(item: T, size: number): void {\n\t\tif (!item) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.addItemToBatch(item, size);\n\t}\n\n\taddItems(items: T[], size: number): void {\n\t\tif (!items) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.addItemsToBatch(items, size);\n\t}\n\n\tprivate addItemToBatch(item: T, size: number): void {\n\t\tthis.batch.push(item);\n\t\tthis.batchSize += size;\n\t\tthis.onUpdate();\n\t}\n\n\tprivate addItemsToBatch(item: T[], size: number): void {\n\t\tthis.batch = this.batch.concat(item);\n\t\tthis.batchSize += size;\n\t\tthis.onUpdate();\n\t}\n\n\tprivate onUpdate(): void {\n\t\tif (this.totalNumberCompleted < BatchedCollector.START_BATCH_AFTER_COUNT) {\n\t\t\t// Flush because we aren't batching yet\n\t\t\tthis.flush();\n\t\t} else if (this.batchSize >= this.maxBatchSize) {\n\t\t\t// Flush because the batch is full\n\t\t\tthis.flush();\n\t\t} else if (!this.timeoutHandle) {\n\t\t\t// No timeout running, start a timeout to flush\n\t\t\tthis.timeoutHandle = setTimeout(() => {\n\t\t\t\tthis.flush();\n\t\t\t}, BatchedCollector.TIMEOUT);\n\t\t}\n\t}\n\n\tflush(): void {\n\t\tif (this.batchSize) {\n\t\t\tthis.totalNumberCompleted += this.batchSize;\n\t\t\tthis.cb(this.batch);\n\t\t\tthis.batch = [];\n\t\t\tthis.batchSize = 0;\n\n\t\t\tif (this.timeoutHandle) {\n\t\t\t\tclearTimeout(this.timeoutHandle);\n\t\t\t\tthis.timeoutHandle = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isThenable } from '../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport * as path from '../../../../base/common/path.js';\nimport * as resources from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { FolderQuerySearchTree } from './folderQuerySearchTree.js';\nimport { DEFAULT_MAX_SEARCH_RESULTS, hasSiblingPromiseFn, IAITextQuery, IExtendedExtensionSearchOptions, IFileMatch, IFolderQuery, excludeToGlobPattern, IPatternInfo, ISearchCompleteStats, ITextQuery, ITextSearchContext, ITextSearchMatch, ITextSearchResult, ITextSearchStats, QueryGlobTester, QueryType, resolvePatternsForProvider, ISearchRange, DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS } from './search.js';\nimport { TextSearchComplete2, TextSearchMatch2, TextSearchProviderFolderOptions, TextSearchProvider2, TextSearchProviderOptions, TextSearchQuery2, TextSearchResult2, AITextSearchProvider, AISearchResult, AISearchKeyword } from './searchExtTypes.js';\n\nexport interface IFileUtils {\n\treaddir: (resource: URI) => Promise<string[]>;\n\ttoCanonicalName: (encoding: string) => string;\n}\ninterface IAITextQueryProviderPair {\n\tquery: IAITextQuery; provider: AITextSearchProvider;\n}\n\ninterface ITextQueryProviderPair {\n\tquery: ITextQuery; provider: TextSearchProvider2;\n}\ninterface FolderQueryInfo {\n\tqueryTester: QueryGlobTester;\n\tfolder: URI;\n\tfolderIdx: number;\n}\n\nexport class TextSearchManager {\n\n\tprivate collector: TextSearchResultsCollector | null = null;\n\n\tprivate isLimitHit = false;\n\tprivate resultCount = 0;\n\n\tconstructor(private queryProviderPair: IAITextQueryProviderPair | ITextQueryProviderPair,\n\t\tprivate fileUtils: IFileUtils,\n\t\tprivate processType: ITextSearchStats['type']) { }\n\n\tprivate get query() {\n\t\treturn this.queryProviderPair.query;\n\t}\n\n\tsearch(onProgress: (matches: IFileMatch[]) => void, token: CancellationToken, onKeywordResult?: (keyword: AISearchKeyword) => void): Promise<ISearchCompleteStats> {\n\t\tconst folderQueries = this.query.folderQueries || [];\n\t\tconst tokenSource = new CancellationTokenSource(token);\n\n\t\treturn new Promise<ISearchCompleteStats>((resolve, reject) => {\n\t\t\tthis.collector = new TextSearchResultsCollector(onProgress);\n\n\t\t\tlet isCanceled = false;\n\t\t\tconst onResult = (result: TextSearchResult2, folderIdx: number) => {\n\t\t\t\tif (result instanceof AISearchKeyword) {\n\t\t\t\t\t// Already processed by the callback.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (isCanceled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this.isLimitHit) {\n\t\t\t\t\tconst resultSize = this.resultSize(result);\n\t\t\t\t\tif (result instanceof TextSearchMatch2 && typeof this.query.maxResults === 'number' && this.resultCount + resultSize > this.query.maxResults) {\n\t\t\t\t\t\tthis.isLimitHit = true;\n\t\t\t\t\t\tisCanceled = true;\n\t\t\t\t\t\ttokenSource.cancel();\n\n\t\t\t\t\t\tresult = this.trimResultToSize(result, this.query.maxResults - this.resultCount);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst newResultSize = this.resultSize(result);\n\t\t\t\t\tthis.resultCount += newResultSize;\n\t\t\t\t\tconst a = result instanceof TextSearchMatch2;\n\n\t\t\t\t\tif (newResultSize > 0 || !a) {\n\t\t\t\t\t\tthis.collector!.add(result, folderIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// For each root folder\n\t\t\tthis.doSearch(folderQueries, onResult, tokenSource.token, onKeywordResult).then(result => {\n\t\t\t\ttokenSource.dispose();\n\t\t\t\tthis.collector!.flush();\n\n\t\t\t\tresolve({\n\t\t\t\t\tlimitHit: this.isLimitHit || result?.limitHit,\n\t\t\t\t\tmessages: this.getMessagesFromResults(result),\n\t\t\t\t\tstats: {\n\t\t\t\t\t\ttype: this.processType\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, (err: Error) => {\n\t\t\t\ttokenSource.dispose();\n\t\t\t\tconst errMsg = toErrorMessage(err);\n\t\t\t\treject(new Error(errMsg));\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate getMessagesFromResults(result: TextSearchComplete2 | null | undefined) {\n\t\tif (!result?.message) { return []; }\n\t\tif (Array.isArray(result.message)) { return result.message; }\n\t\treturn [result.message];\n\t}\n\n\tprivate resultSize(result: TextSearchResult2): number {\n\t\tif (result instanceof TextSearchMatch2) {\n\t\t\treturn Array.isArray(result.ranges) ?\n\t\t\t\tresult.ranges.length :\n\t\t\t\t1;\n\t\t}\n\t\telse {\n\t\t\t// #104400 context lines shoudn't count towards result count\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate trimResultToSize(result: TextSearchMatch2, size: number): TextSearchMatch2 {\n\t\treturn new TextSearchMatch2(result.uri, result.ranges.slice(0, size), result.previewText);\n\t}\n\n\tprivate async doSearch(folderQueries: IFolderQuery<URI>[], onResult: (result: TextSearchResult2, folderIdx: number) => void, token: CancellationToken, onKeywordResult?: (keyword: AISearchKeyword) => void): Promise<TextSearchComplete2 | null | undefined> {\n\t\tconst folderMappings: FolderQuerySearchTree<FolderQueryInfo> = new FolderQuerySearchTree<FolderQueryInfo>(\n\t\t\tfolderQueries,\n\t\t\t(fq, i) => {\n\t\t\t\tconst queryTester = new QueryGlobTester(this.query, fq);\n\t\t\t\treturn { queryTester, folder: fq.folder, folderIdx: i };\n\t\t\t},\n\t\t\t() => true\n\t\t);\n\n\t\tconst testingPs: Promise<void>[] = [];\n\t\tconst progress = {\n\t\t\treport: (result: TextSearchResult2 | AISearchResult) => {\n\t\t\t\tif (result instanceof AISearchKeyword) {\n\t\t\t\t\tonKeywordResult?.(result);\n\t\t\t\t} else {\n\t\t\t\t\tif (result.uri === undefined) {\n\t\t\t\t\t\tthrow Error('Text search result URI is undefined. Please check provider implementation.');\n\t\t\t\t\t}\n\t\t\t\t\tconst folderQuery = folderMappings.findQueryFragmentAwareSubstr(result.uri)!;\n\t\t\t\t\tconst hasSibling = folderQuery.folder.scheme === Schemas.file ?\n\t\t\t\t\t\thasSiblingPromiseFn(() => {\n\t\t\t\t\t\t\treturn this.fileUtils.readdir(resources.dirname(result.uri));\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tundefined;\n\n\t\t\t\t\tconst relativePath = resources.relativePath(folderQuery.folder, result.uri);\n\t\t\t\t\tif (relativePath) {\n\t\t\t\t\t\t// This method is only async when the exclude contains sibling clauses\n\t\t\t\t\t\tconst included = folderQuery.queryTester.includedInQuery(relativePath, path.basename(relativePath), hasSibling);\n\t\t\t\t\t\tif (isThenable(included)) {\n\t\t\t\t\t\t\ttestingPs.push(\n\t\t\t\t\t\t\t\tincluded.then(isIncluded => {\n\t\t\t\t\t\t\t\t\tif (isIncluded) {\n\t\t\t\t\t\t\t\t\t\tonResult(result, folderQuery.folderIdx);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t} else if (included) {\n\t\t\t\t\t\t\tonResult(result, folderQuery.folderIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst folderOptions = folderQueries.map(fq => this.getSearchOptionsForFolder(fq));\n\t\tconst searchOptions: TextSearchProviderOptions = {\n\t\t\tfolderOptions,\n\t\t\tmaxFileSize: this.query.maxFileSize,\n\t\t\tmaxResults: this.query.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS,\n\t\t\tpreviewOptions: this.query.previewOptions ?? DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS,\n\t\t\tsurroundingContext: this.query.surroundingContext ?? 0,\n\t\t};\n\t\tif ('usePCRE2' in this.query) {\n\t\t\t(<IExtendedExtensionSearchOptions>searchOptions).usePCRE2 = this.query.usePCRE2;\n\t\t}\n\n\t\tlet result;\n\t\tif (this.queryProviderPair.query.type === QueryType.aiText) {\n\t\t\tresult = await (this.queryProviderPair as IAITextQueryProviderPair).provider.provideAITextSearchResults(this.queryProviderPair.query.contentPattern, searchOptions, progress, token);\n\t\t} else {\n\t\t\tresult = await (this.queryProviderPair as ITextQueryProviderPair).provider.provideTextSearchResults(patternInfoToQuery(this.queryProviderPair.query.contentPattern), searchOptions, progress, token);\n\t\t}\n\t\tif (testingPs.length) {\n\t\t\tawait Promise.all(testingPs);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate getSearchOptionsForFolder(fq: IFolderQuery<URI>): TextSearchProviderFolderOptions {\n\t\tconst includes = resolvePatternsForProvider(this.query.includePattern, fq.includePattern);\n\n\t\tlet excludePattern = fq.excludePattern?.map(e => ({\n\t\t\tfolder: e.folder,\n\t\t\tpatterns: resolvePatternsForProvider(this.query.excludePattern, e.pattern)\n\t\t}));\n\n\t\tif (!excludePattern || excludePattern.length === 0) {\n\t\t\texcludePattern = [{\n\t\t\t\tfolder: undefined,\n\t\t\t\tpatterns: resolvePatternsForProvider(this.query.excludePattern, undefined)\n\t\t\t}];\n\t\t}\n\t\tconst excludes = excludeToGlobPattern(excludePattern);\n\n\t\tconst options = {\n\t\t\tfolder: URI.from(fq.folder),\n\t\t\texcludes,\n\t\t\tincludes,\n\t\t\tuseIgnoreFiles: {\n\t\t\t\tlocal: !fq.disregardIgnoreFiles,\n\t\t\t\tparent: !fq.disregardParentIgnoreFiles,\n\t\t\t\tglobal: !fq.disregardGlobalIgnoreFiles\n\t\t\t},\n\t\t\tfollowSymlinks: !fq.ignoreSymlinks,\n\t\t\tencoding: (fq.fileEncoding && this.fileUtils.toCanonicalName(fq.fileEncoding)) ?? '',\n\t\t};\n\t\treturn options;\n\t}\n}\n\nfunction patternInfoToQuery(patternInfo: IPatternInfo): TextSearchQuery2 {\n\treturn {\n\t\tisCaseSensitive: patternInfo.isCaseSensitive || false,\n\t\tisRegExp: patternInfo.isRegExp || false,\n\t\tisWordMatch: patternInfo.isWordMatch || false,\n\t\tisMultiline: patternInfo.isMultiline || false,\n\t\tpattern: patternInfo.pattern\n\t};\n}\n\nexport class TextSearchResultsCollector {\n\tprivate _batchedCollector: BatchedCollector<IFileMatch>;\n\n\tprivate _currentFolderIdx: number = -1;\n\tprivate _currentUri: URI | undefined;\n\tprivate _currentFileMatch: IFileMatch | null = null;\n\n\tconstructor(private _onResult: (result: IFileMatch[]) => void) {\n\t\tthis._batchedCollector = new BatchedCollector<IFileMatch>(512, items => this.sendItems(items));\n\t}\n\n\tadd(data: TextSearchResult2, folderIdx: number): void {\n\t\t// Collects TextSearchResults into IInternalFileMatches and collates using BatchedCollector.\n\t\t// This is efficient for ripgrep which sends results back one file at a time. It wouldn't be efficient for other search\n\t\t// providers that send results in random order. We could do this step afterwards instead.\n\t\tif (this._currentFileMatch && (this._currentFolderIdx !== folderIdx || !resources.isEqual(this._currentUri, data.uri))) {\n\t\t\tthis.pushToCollector();\n\t\t\tthis._currentFileMatch = null;\n\t\t}\n\n\t\tif (!this._currentFileMatch) {\n\t\t\tthis._currentFolderIdx = folderIdx;\n\t\t\tthis._currentFileMatch = {\n\t\t\t\tresource: data.uri,\n\t\t\t\tresults: []\n\t\t\t};\n\t\t}\n\n\t\tthis._currentFileMatch.results!.push(extensionResultToFrontendResult(data));\n\t}\n\n\tprivate pushToCollector(): void {\n\t\tconst size = this._currentFileMatch && this._currentFileMatch.results ?\n\t\t\tthis._currentFileMatch.results.length :\n\t\t\t0;\n\t\tthis._batchedCollector.addItem(this._currentFileMatch!, size);\n\t}\n\n\tflush(): void {\n\t\tthis.pushToCollector();\n\t\tthis._batchedCollector.flush();\n\t}\n\n\tprivate sendItems(items: IFileMatch[]): void {\n\t\tthis._onResult(items);\n\t}\n}\n\nfunction extensionResultToFrontendResult(data: TextSearchResult2): ITextSearchResult {\n\t// Warning: result from RipgrepTextSearchEH has fake Range. Don't depend on any other props beyond these...\n\tif (data instanceof TextSearchMatch2) {\n\t\treturn {\n\t\t\tpreviewText: data.previewText,\n\t\t\trangeLocations: data.ranges.map(r => ({\n\t\t\t\tpreview: {\n\t\t\t\t\tstartLineNumber: r.previewRange.start.line,\n\t\t\t\t\tstartColumn: r.previewRange.start.character,\n\t\t\t\t\tendLineNumber: r.previewRange.end.line,\n\t\t\t\t\tendColumn: r.previewRange.end.character\n\t\t\t\t} satisfies ISearchRange,\n\t\t\t\tsource: {\n\t\t\t\t\tstartLineNumber: r.sourceRange.start.line,\n\t\t\t\t\tstartColumn: r.sourceRange.start.character,\n\t\t\t\t\tendLineNumber: r.sourceRange.end.line,\n\t\t\t\t\tendColumn: r.sourceRange.end.character\n\t\t\t\t} satisfies ISearchRange,\n\t\t\t})),\n\t\t} satisfies ITextSearchMatch;\n\t} else {\n\t\treturn {\n\t\t\ttext: data.text,\n\t\t\tlineNumber: data.lineNumber\n\t\t} satisfies ITextSearchContext;\n\t}\n}\n\n\n/**\n * Collects items that have a size - before the cumulative size of collected items reaches START_BATCH_AFTER_COUNT, the callback is called for every\n * set of items collected.\n * But after that point, the callback is called with batches of maxBatchSize.\n * If the batch isn't filled within some time, the callback is also called.\n */\nexport class BatchedCollector<T> {\n\tprivate static readonly TIMEOUT = 4000;\n\n\t// After START_BATCH_AFTER_COUNT items have been collected, stop flushing on timeout\n\tprivate static readonly START_BATCH_AFTER_COUNT = 50;\n\n\tprivate totalNumberCompleted = 0;\n\tprivate batch: T[] = [];\n\tprivate batchSize = 0;\n\tprivate timeoutHandle: Timeout | undefined;\n\n\tconstructor(private maxBatchSize: number, private cb: (items: T[]) => void) {\n\t}\n\n\taddItem(item: T, size: number): void {\n\t\tif (!item) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.addItemToBatch(item, size);\n\t}\n\n\taddItems(items: T[], size: number): void {\n\t\tif (!items) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.addItemsToBatch(items, size);\n\t}\n\n\tprivate addItemToBatch(item: T, size: number): void {\n\t\tthis.batch.push(item);\n\t\tthis.batchSize += size;\n\t\tthis.onUpdate();\n\t}\n\n\tprivate addItemsToBatch(item: T[], size: number): void {\n\t\tthis.batch = this.batch.concat(item);\n\t\tthis.batchSize += size;\n\t\tthis.onUpdate();\n\t}\n\n\tprivate onUpdate(): void {\n\t\tif (this.totalNumberCompleted < BatchedCollector.START_BATCH_AFTER_COUNT) {\n\t\t\t// Flush because we aren't batching yet\n\t\t\tthis.flush();\n\t\t} else if (this.batchSize >= this.maxBatchSize) {\n\t\t\t// Flush because the batch is full\n\t\t\tthis.flush();\n\t\t} else if (!this.timeoutHandle) {\n\t\t\t// No timeout running, start a timeout to flush\n\t\t\tthis.timeoutHandle = setTimeout(() => {\n\t\t\t\tthis.flush();\n\t\t\t}, BatchedCollector.TIMEOUT);\n\t\t}\n\t}\n\n\tflush(): void {\n\t\tif (this.batchSize) {\n\t\t\tthis.totalNumberCompleted += this.batchSize;\n\t\t\tthis.cb(this.batch);\n\t\t\tthis.batch = [];\n\t\t\tthis.batchSize = 0;\n\n\t\t\tif (this.timeoutHandle) {\n\t\t\t\tclearTimeout(this.timeoutHandle);\n\t\t\t\tthis.timeoutHandle = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n"]}