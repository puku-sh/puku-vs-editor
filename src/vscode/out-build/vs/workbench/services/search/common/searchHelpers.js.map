{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/common/searchHelpers.ts","vs/workbench/services/search/common/searchHelpers.ts"],"names":[],"mappings":"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","file":"searchHelpers.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../../../../editor/common/core/range.js';\nimport { FindMatch, ITextModel } from '../../../../editor/common/model.js';\nimport { ITextSearchPreviewOptions, TextSearchMatch, ITextSearchResult, ITextSearchMatch, ITextSearchQuery } from './search.js';\n\nfunction editorMatchToTextSearchResult(matches: FindMatch[], model: ITextModel, previewOptions?: ITextSearchPreviewOptions): TextSearchMatch {\n\tconst firstLine = matches[0].range.startLineNumber;\n\tconst lastLine = matches[matches.length - 1].range.endLineNumber;\n\n\tconst lineTexts: string[] = [];\n\tfor (let i = firstLine; i <= lastLine; i++) {\n\t\tlineTexts.push(model.getLineContent(i));\n\t}\n\n\treturn new TextSearchMatch(\n\t\tlineTexts.join('\\n') + '\\n',\n\t\tmatches.map(m => new Range(m.range.startLineNumber - 1, m.range.startColumn - 1, m.range.endLineNumber - 1, m.range.endColumn - 1)),\n\t\tpreviewOptions);\n}\n\n/**\n * Combine a set of FindMatches into a set of TextSearchResults. They should be grouped by matches that start on the same line that the previous match ends on.\n */\nexport function editorMatchesToTextSearchResults(matches: FindMatch[], model: ITextModel, previewOptions?: ITextSearchPreviewOptions): TextSearchMatch[] {\n\tlet previousEndLine = -1;\n\tconst groupedMatches: FindMatch[][] = [];\n\tlet currentMatches: FindMatch[] = [];\n\tmatches.forEach((match) => {\n\t\tif (match.range.startLineNumber !== previousEndLine) {\n\t\t\tcurrentMatches = [];\n\t\t\tgroupedMatches.push(currentMatches);\n\t\t}\n\n\t\tcurrentMatches.push(match);\n\t\tpreviousEndLine = match.range.endLineNumber;\n\t});\n\n\treturn groupedMatches.map(sameLineMatches => {\n\t\treturn editorMatchToTextSearchResult(sameLineMatches, model, previewOptions);\n\t});\n}\n\nexport function getTextSearchMatchWithModelContext(matches: ITextSearchMatch[], model: ITextModel, query: ITextSearchQuery): ITextSearchResult[] {\n\tconst results: ITextSearchResult[] = [];\n\n\tlet prevLine = -1;\n\tfor (let i = 0; i < matches.length; i++) {\n\t\tconst { start: matchStartLine, end: matchEndLine } = getMatchStartEnd(matches[i]);\n\t\tif (typeof query.surroundingContext === 'number' && query.surroundingContext > 0) {\n\t\t\tconst beforeContextStartLine = Math.max(prevLine + 1, matchStartLine - query.surroundingContext);\n\t\t\tfor (let b = beforeContextStartLine; b < matchStartLine; b++) {\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: model.getLineContent(b + 1),\n\t\t\t\t\tlineNumber: b + 1\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tresults.push(matches[i]);\n\n\t\tconst nextMatch = matches[i + 1];\n\t\tconst nextMatchStartLine = nextMatch ? getMatchStartEnd(nextMatch).start : Number.MAX_VALUE;\n\t\tif (typeof query.surroundingContext === 'number' && query.surroundingContext > 0) {\n\t\t\tconst afterContextToLine = Math.min(nextMatchStartLine - 1, matchEndLine + query.surroundingContext, model.getLineCount() - 1);\n\t\t\tfor (let a = matchEndLine + 1; a <= afterContextToLine; a++) {\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: model.getLineContent(a + 1),\n\t\t\t\t\tlineNumber: a + 1\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tprevLine = matchEndLine;\n\t}\n\n\treturn results;\n}\n\nfunction getMatchStartEnd(match: ITextSearchMatch): { start: number; end: number } {\n\tconst matchRanges = match.rangeLocations.map(e => e.source);\n\tconst matchStartLine = matchRanges[0].startLineNumber;\n\tconst matchEndLine = matchRanges[matchRanges.length - 1].endLineNumber;\n\n\treturn {\n\t\tstart: matchStartLine,\n\t\tend: matchEndLine\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../../../../editor/common/core/range.js';\nimport { FindMatch, ITextModel } from '../../../../editor/common/model.js';\nimport { ITextSearchPreviewOptions, TextSearchMatch, ITextSearchResult, ITextSearchMatch, ITextSearchQuery } from './search.js';\n\nfunction editorMatchToTextSearchResult(matches: FindMatch[], model: ITextModel, previewOptions?: ITextSearchPreviewOptions): TextSearchMatch {\n\tconst firstLine = matches[0].range.startLineNumber;\n\tconst lastLine = matches[matches.length - 1].range.endLineNumber;\n\n\tconst lineTexts: string[] = [];\n\tfor (let i = firstLine; i <= lastLine; i++) {\n\t\tlineTexts.push(model.getLineContent(i));\n\t}\n\n\treturn new TextSearchMatch(\n\t\tlineTexts.join('\\n') + '\\n',\n\t\tmatches.map(m => new Range(m.range.startLineNumber - 1, m.range.startColumn - 1, m.range.endLineNumber - 1, m.range.endColumn - 1)),\n\t\tpreviewOptions);\n}\n\n/**\n * Combine a set of FindMatches into a set of TextSearchResults. They should be grouped by matches that start on the same line that the previous match ends on.\n */\nexport function editorMatchesToTextSearchResults(matches: FindMatch[], model: ITextModel, previewOptions?: ITextSearchPreviewOptions): TextSearchMatch[] {\n\tlet previousEndLine = -1;\n\tconst groupedMatches: FindMatch[][] = [];\n\tlet currentMatches: FindMatch[] = [];\n\tmatches.forEach((match) => {\n\t\tif (match.range.startLineNumber !== previousEndLine) {\n\t\t\tcurrentMatches = [];\n\t\t\tgroupedMatches.push(currentMatches);\n\t\t}\n\n\t\tcurrentMatches.push(match);\n\t\tpreviousEndLine = match.range.endLineNumber;\n\t});\n\n\treturn groupedMatches.map(sameLineMatches => {\n\t\treturn editorMatchToTextSearchResult(sameLineMatches, model, previewOptions);\n\t});\n}\n\nexport function getTextSearchMatchWithModelContext(matches: ITextSearchMatch[], model: ITextModel, query: ITextSearchQuery): ITextSearchResult[] {\n\tconst results: ITextSearchResult[] = [];\n\n\tlet prevLine = -1;\n\tfor (let i = 0; i < matches.length; i++) {\n\t\tconst { start: matchStartLine, end: matchEndLine } = getMatchStartEnd(matches[i]);\n\t\tif (typeof query.surroundingContext === 'number' && query.surroundingContext > 0) {\n\t\t\tconst beforeContextStartLine = Math.max(prevLine + 1, matchStartLine - query.surroundingContext);\n\t\t\tfor (let b = beforeContextStartLine; b < matchStartLine; b++) {\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: model.getLineContent(b + 1),\n\t\t\t\t\tlineNumber: b + 1\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tresults.push(matches[i]);\n\n\t\tconst nextMatch = matches[i + 1];\n\t\tconst nextMatchStartLine = nextMatch ? getMatchStartEnd(nextMatch).start : Number.MAX_VALUE;\n\t\tif (typeof query.surroundingContext === 'number' && query.surroundingContext > 0) {\n\t\t\tconst afterContextToLine = Math.min(nextMatchStartLine - 1, matchEndLine + query.surroundingContext, model.getLineCount() - 1);\n\t\t\tfor (let a = matchEndLine + 1; a <= afterContextToLine; a++) {\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: model.getLineContent(a + 1),\n\t\t\t\t\tlineNumber: a + 1\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tprevLine = matchEndLine;\n\t}\n\n\treturn results;\n}\n\nfunction getMatchStartEnd(match: ITextSearchMatch): { start: number; end: number } {\n\tconst matchRanges = match.rangeLocations.map(e => e.source);\n\tconst matchStartLine = matchRanges[0].startLineNumber;\n\tconst matchEndLine = matchRanges[matchRanges.length - 1].endLineNumber;\n\n\treturn {\n\t\tstart: matchStartLine,\n\t\tend: matchEndLine\n\t};\n}\n"]}