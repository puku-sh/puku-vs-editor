{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/common/getFileResults.ts","vs/workbench/services/search/common/getFileResults.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAGhG,OAAO,EAAE,KAAK,EAAE,MAAM,yCAAyC,CAAC;AAEhE,MAAM,CAAC,MAAM,cAAc,GAAG,CAC7B,KAAiB,EACjB,OAAe,EACf,OAIC,EACqB,EAAE;IAExB,IAAI,IAAY,CAAC;IACjB,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;QAC5C,IAAI,GAAG,IAAI,WAAW,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAClD,CAAC;SAAM,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;QACnD,IAAI,GAAG,IAAI,WAAW,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAClD,CAAC;SAAM,CAAC;QACP,IAAI,GAAG,IAAI,WAAW,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC7C,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;YACjE,OAAO,EAAE,CAAC;QACX,CAAC;IACF,CAAC;IAED,MAAM,OAAO,GAAwB,EAAE,CAAC;IAExC,MAAM,cAAc,GAAuD,EAAE,CAAC;IAE9E,IAAI,YAAY,GAA2B,IAAI,CAAC;IAChD,IAAI,oBAAoB,GAAG,OAAO,CAAC,oBAAoB,CAAC;IACxD,OAAO,oBAAoB,IAAI,CAAC,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;QACzE,cAAc,CAAC,IAAI,CAAC,EAAE,eAAe,EAAE,YAAY,CAAC,KAAK,EAAE,WAAW,EAAE,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QAC3F,oBAAoB,EAAE,CAAC;IACxB,CAAC;IAED,IAAI,cAAc,CAAC,MAAM,EAAE,CAAC;QAC3B,MAAM,kBAAkB,GAAG,IAAI,GAAG,EAAU,CAAC;QAC7C,MAAM,WAAW,GAAG,IAAI,GAAG,EAAU,CAAC;QAEtC,MAAM,UAAU,GAAqC,EAAE,CAAC;QACxD,MAAM,QAAQ,GAAG,CAAC,UAAkB,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,KAAK,EAAE,UAAU,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC;QAE9G,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,IAAI,eAAe,GAA2B,IAAI,CAAC;QACnD,MAAM,YAAY,GAAG,QAAQ,CAAC;QAC9B,OAAO,CAAC,eAAe,GAAG,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;YACpD,UAAU,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,EAAE,eAAe,CAAC,KAAK,EAAE,CAAC,CAAC;YACpE,WAAW,GAAG,eAAe,CAAC,KAAK,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QACjE,CAAC;QACD,IAAI,WAAW,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;YAAC,UAAU,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;QAAC,CAAC;QAE7F,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,KAAK,MAAM,EAAE,eAAe,EAAE,WAAW,EAAE,IAAI,cAAc,EAAE,CAAC;YAC/D,IAAI,oBAAoB,GAAG,CAAC,EAAE,CAAC;gBAC9B,MAAM;YACP,CAAC;YAED,OAAO,OAAO,CAAC,UAAU,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,IAAI,eAAe,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,CAAC;gBAC1F,SAAS,EAAE,CAAC;YACb,CAAC;YACD,IAAI,OAAO,GAAG,SAAS,CAAC;YACxB,OAAO,OAAO,CAAC,UAAU,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,IAAI,eAAe,GAAG,WAAW,CAAC,MAAM,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,CAAC;gBAC3G,OAAO,EAAE,CAAC;YACX,CAAC;YAED,IAAI,OAAO,CAAC,kBAAkB,EAAE,CAAC;gBAChC,KAAK,IAAI,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,GAAG,OAAO,CAAC,kBAAkB,CAAC,EAAE,WAAW,GAAG,SAAS,EAAE,WAAW,EAAE,EAAE,CAAC;oBACpH,kBAAkB,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;gBACrC,CAAC;YACF,CAAC;YAED,IAAI,WAAW,GAAG,EAAE,CAAC;YACrB,IAAI,MAAM,GAAG,CAAC,CAAC;YACf,KAAK,IAAI,SAAS,GAAG,SAAS,EAAE,SAAS,IAAI,OAAO,EAAE,SAAS,EAAE,EAAE,CAAC;gBACnE,IAAI,WAAW,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;gBACtC,IAAI,OAAO,CAAC,cAAc,EAAE,YAAY,IAAI,WAAW,CAAC,MAAM,GAAG,OAAO,CAAC,cAAc,CAAC,YAAY,EAAE,CAAC;oBACtG,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,eAAe,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC,KAAK,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;oBACzE,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;gBAC/E,CAAC;gBACD,WAAW,IAAI,GAAG,WAAW,IAAI,CAAC;gBAClC,WAAW,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YAC5B,CAAC;YAED,MAAM,SAAS,GAAG,IAAI,KAAK,CAC1B,SAAS,EACT,eAAe,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC,KAAK,EAC7C,OAAO,EACP,eAAe,GAAG,WAAW,CAAC,MAAM,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC,KAAK,CAChE,CAAC;YACF,MAAM,YAAY,GAAG,IAAI,KAAK,CAC7B,CAAC,EACD,eAAe,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC,KAAK,GAAG,MAAM,EACtD,OAAO,GAAG,SAAS,EACnB,eAAe,GAAG,WAAW,CAAC,MAAM,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC,KAAK,GAAG,CAAC,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CACvG,CAAC;YAEF,MAAM,KAAK,GAAqB;gBAC/B,cAAc,EAAE,CAAC;wBAChB,MAAM,EAAE,SAAS;wBACjB,OAAO,EAAE,YAAY;qBACrB,CAAC;gBACF,WAAW,EAAE,WAAW;aACxB,CAAC;YAEF,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAEpB,IAAI,OAAO,CAAC,kBAAkB,EAAE,CAAC;gBAChC,KAAK,IAAI,WAAW,GAAG,OAAO,GAAG,CAAC,EAAE,WAAW,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,GAAG,OAAO,CAAC,kBAAkB,EAAE,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,WAAW,EAAE,EAAE,CAAC;oBACzI,kBAAkB,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;gBACrC,CAAC;YACF,CAAC;QACF,CAAC;QACD,KAAK,MAAM,WAAW,IAAI,kBAAkB,EAAE,CAAC;YAC9C,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC;gBAEnC,OAAO,CAAC,IAAI,CAAC;oBACZ,IAAI,EAAE,QAAQ,CAAC,WAAW,CAAC;oBAC3B,UAAU,EAAE,WAAW,GAAG,CAAC;iBAC3B,CAAC,CAAC;YACJ,CAAC;QACF,CAAC;IACF,CAAC;IACD,OAAO,OAAO,CAAC;AAChB,CAAC,CAAC","file":"getFileResults.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextSearchMatch, ITextSearchPreviewOptions, ITextSearchResult } from './search.js';\nimport { Range } from '../../../../editor/common/core/range.js';\n\nexport const getFileResults = (\n\tbytes: Uint8Array,\n\tpattern: RegExp,\n\toptions: {\n\t\tsurroundingContext: number;\n\t\tpreviewOptions: ITextSearchPreviewOptions | undefined;\n\t\tremainingResultQuota: number;\n\t}\n): ITextSearchResult[] => {\n\n\tlet text: string;\n\tif (bytes[0] === 0xff && bytes[1] === 0xfe) {\n\t\ttext = new TextDecoder('utf-16le').decode(bytes);\n\t} else if (bytes[0] === 0xfe && bytes[1] === 0xff) {\n\t\ttext = new TextDecoder('utf-16be').decode(bytes);\n\t} else {\n\t\ttext = new TextDecoder('utf8').decode(bytes);\n\t\tif (text.slice(0, 1000).includes('\\uFFFD') && bytes.includes(0)) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tconst results: ITextSearchResult[] = [];\n\n\tconst patternIndices: { matchStartIndex: number; matchedText: string }[] = [];\n\n\tlet patternMatch: RegExpExecArray | null = null;\n\tlet remainingResultQuota = options.remainingResultQuota;\n\twhile (remainingResultQuota >= 0 && (patternMatch = pattern.exec(text))) {\n\t\tpatternIndices.push({ matchStartIndex: patternMatch.index, matchedText: patternMatch[0] });\n\t\tremainingResultQuota--;\n\t}\n\n\tif (patternIndices.length) {\n\t\tconst contextLinesNeeded = new Set<number>();\n\t\tconst resultLines = new Set<number>();\n\n\t\tconst lineRanges: { start: number; end: number }[] = [];\n\t\tconst readLine = (lineNumber: number) => text.slice(lineRanges[lineNumber].start, lineRanges[lineNumber].end);\n\n\t\tlet prevLineEnd = 0;\n\t\tlet lineEndingMatch: RegExpExecArray | null = null;\n\t\tconst lineEndRegex = /\\r?\\n/g;\n\t\twhile ((lineEndingMatch = lineEndRegex.exec(text))) {\n\t\t\tlineRanges.push({ start: prevLineEnd, end: lineEndingMatch.index });\n\t\t\tprevLineEnd = lineEndingMatch.index + lineEndingMatch[0].length;\n\t\t}\n\t\tif (prevLineEnd < text.length) { lineRanges.push({ start: prevLineEnd, end: text.length }); }\n\n\t\tlet startLine = 0;\n\t\tfor (const { matchStartIndex, matchedText } of patternIndices) {\n\t\t\tif (remainingResultQuota < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (Boolean(lineRanges[startLine + 1]) && matchStartIndex > lineRanges[startLine].end) {\n\t\t\t\tstartLine++;\n\t\t\t}\n\t\t\tlet endLine = startLine;\n\t\t\twhile (Boolean(lineRanges[endLine + 1]) && matchStartIndex + matchedText.length > lineRanges[endLine].end) {\n\t\t\t\tendLine++;\n\t\t\t}\n\n\t\t\tif (options.surroundingContext) {\n\t\t\t\tfor (let contextLine = Math.max(0, startLine - options.surroundingContext); contextLine < startLine; contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet previewText = '';\n\t\t\tlet offset = 0;\n\t\t\tfor (let matchLine = startLine; matchLine <= endLine; matchLine++) {\n\t\t\t\tlet previewLine = readLine(matchLine);\n\t\t\t\tif (options.previewOptions?.charsPerLine && previewLine.length > options.previewOptions.charsPerLine) {\n\t\t\t\t\toffset = Math.max(matchStartIndex - lineRanges[startLine].start - 20, 0);\n\t\t\t\t\tpreviewLine = previewLine.substr(offset, options.previewOptions.charsPerLine);\n\t\t\t\t}\n\t\t\t\tpreviewText += `${previewLine}\\n`;\n\t\t\t\tresultLines.add(matchLine);\n\t\t\t}\n\n\t\t\tconst fileRange = new Range(\n\t\t\t\tstartLine,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start,\n\t\t\t\tendLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start\n\t\t\t);\n\t\t\tconst previewRange = new Range(\n\t\t\t\t0,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start - offset,\n\t\t\t\tendLine - startLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start - (endLine === startLine ? offset : 0)\n\t\t\t);\n\n\t\t\tconst match: ITextSearchMatch = {\n\t\t\t\trangeLocations: [{\n\t\t\t\t\tsource: fileRange,\n\t\t\t\t\tpreview: previewRange,\n\t\t\t\t}],\n\t\t\t\tpreviewText: previewText\n\t\t\t};\n\n\t\t\tresults.push(match);\n\n\t\t\tif (options.surroundingContext) {\n\t\t\t\tfor (let contextLine = endLine + 1; contextLine <= Math.min(endLine + options.surroundingContext, lineRanges.length - 1); contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const contextLine of contextLinesNeeded) {\n\t\t\tif (!resultLines.has(contextLine)) {\n\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: readLine(contextLine),\n\t\t\t\t\tlineNumber: contextLine + 1,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextSearchMatch, ITextSearchPreviewOptions, ITextSearchResult } from './search.js';\nimport { Range } from '../../../../editor/common/core/range.js';\n\nexport const getFileResults = (\n\tbytes: Uint8Array,\n\tpattern: RegExp,\n\toptions: {\n\t\tsurroundingContext: number;\n\t\tpreviewOptions: ITextSearchPreviewOptions | undefined;\n\t\tremainingResultQuota: number;\n\t}\n): ITextSearchResult[] => {\n\n\tlet text: string;\n\tif (bytes[0] === 0xff && bytes[1] === 0xfe) {\n\t\ttext = new TextDecoder('utf-16le').decode(bytes);\n\t} else if (bytes[0] === 0xfe && bytes[1] === 0xff) {\n\t\ttext = new TextDecoder('utf-16be').decode(bytes);\n\t} else {\n\t\ttext = new TextDecoder('utf8').decode(bytes);\n\t\tif (text.slice(0, 1000).includes('\\uFFFD') && bytes.includes(0)) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tconst results: ITextSearchResult[] = [];\n\n\tconst patternIndices: { matchStartIndex: number; matchedText: string }[] = [];\n\n\tlet patternMatch: RegExpExecArray | null = null;\n\tlet remainingResultQuota = options.remainingResultQuota;\n\twhile (remainingResultQuota >= 0 && (patternMatch = pattern.exec(text))) {\n\t\tpatternIndices.push({ matchStartIndex: patternMatch.index, matchedText: patternMatch[0] });\n\t\tremainingResultQuota--;\n\t}\n\n\tif (patternIndices.length) {\n\t\tconst contextLinesNeeded = new Set<number>();\n\t\tconst resultLines = new Set<number>();\n\n\t\tconst lineRanges: { start: number; end: number }[] = [];\n\t\tconst readLine = (lineNumber: number) => text.slice(lineRanges[lineNumber].start, lineRanges[lineNumber].end);\n\n\t\tlet prevLineEnd = 0;\n\t\tlet lineEndingMatch: RegExpExecArray | null = null;\n\t\tconst lineEndRegex = /\\r?\\n/g;\n\t\twhile ((lineEndingMatch = lineEndRegex.exec(text))) {\n\t\t\tlineRanges.push({ start: prevLineEnd, end: lineEndingMatch.index });\n\t\t\tprevLineEnd = lineEndingMatch.index + lineEndingMatch[0].length;\n\t\t}\n\t\tif (prevLineEnd < text.length) { lineRanges.push({ start: prevLineEnd, end: text.length }); }\n\n\t\tlet startLine = 0;\n\t\tfor (const { matchStartIndex, matchedText } of patternIndices) {\n\t\t\tif (remainingResultQuota < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (Boolean(lineRanges[startLine + 1]) && matchStartIndex > lineRanges[startLine].end) {\n\t\t\t\tstartLine++;\n\t\t\t}\n\t\t\tlet endLine = startLine;\n\t\t\twhile (Boolean(lineRanges[endLine + 1]) && matchStartIndex + matchedText.length > lineRanges[endLine].end) {\n\t\t\t\tendLine++;\n\t\t\t}\n\n\t\t\tif (options.surroundingContext) {\n\t\t\t\tfor (let contextLine = Math.max(0, startLine - options.surroundingContext); contextLine < startLine; contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet previewText = '';\n\t\t\tlet offset = 0;\n\t\t\tfor (let matchLine = startLine; matchLine <= endLine; matchLine++) {\n\t\t\t\tlet previewLine = readLine(matchLine);\n\t\t\t\tif (options.previewOptions?.charsPerLine && previewLine.length > options.previewOptions.charsPerLine) {\n\t\t\t\t\toffset = Math.max(matchStartIndex - lineRanges[startLine].start - 20, 0);\n\t\t\t\t\tpreviewLine = previewLine.substr(offset, options.previewOptions.charsPerLine);\n\t\t\t\t}\n\t\t\t\tpreviewText += `${previewLine}\\n`;\n\t\t\t\tresultLines.add(matchLine);\n\t\t\t}\n\n\t\t\tconst fileRange = new Range(\n\t\t\t\tstartLine,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start,\n\t\t\t\tendLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start\n\t\t\t);\n\t\t\tconst previewRange = new Range(\n\t\t\t\t0,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start - offset,\n\t\t\t\tendLine - startLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start - (endLine === startLine ? offset : 0)\n\t\t\t);\n\n\t\t\tconst match: ITextSearchMatch = {\n\t\t\t\trangeLocations: [{\n\t\t\t\t\tsource: fileRange,\n\t\t\t\t\tpreview: previewRange,\n\t\t\t\t}],\n\t\t\t\tpreviewText: previewText\n\t\t\t};\n\n\t\t\tresults.push(match);\n\n\t\t\tif (options.surroundingContext) {\n\t\t\t\tfor (let contextLine = endLine + 1; contextLine <= Math.min(endLine + options.surroundingContext, lineRanges.length - 1); contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const contextLine of contextLinesNeeded) {\n\t\t\tif (!resultLines.has(contextLine)) {\n\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: readLine(contextLine),\n\t\t\t\t\tlineNumber: contextLine + 1,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n};\n"]}