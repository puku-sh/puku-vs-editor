{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/common/fileSearchManager.ts","vs/workbench/services/search/common/fileSearchManager.ts"],"names":[],"mappings":"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","file":"fileSearchManager.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from '../../../../base/common/path.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport * as glob from '../../../../base/common/glob.js';\nimport * as resources from '../../../../base/common/resources.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IFileMatch, IFileSearchProviderStats, IFolderQuery, ISearchCompleteStats, IFileQuery, QueryGlobTester, resolvePatternsForProvider, hasSiblingFn, excludeToGlobPattern, DEFAULT_MAX_SEARCH_RESULTS } from './search.js';\nimport { FileSearchProviderFolderOptions, FileSearchProvider2, FileSearchProviderOptions } from './searchExtTypes.js';\nimport { OldFileSearchProviderConverter } from './searchExtConversionTypes.js';\nimport { FolderQuerySearchTree } from './folderQuerySearchTree.js';\n\ninterface IInternalFileMatch {\n\tbase: URI;\n\toriginal?: URI;\n\trelativePath?: string; // Not present for extraFiles or absolute path matches\n\tbasename: string;\n\tsize?: number;\n}\n\ninterface IDirectoryEntry {\n\tbase: URI;\n\trelativePath: string;\n\tbasename: string;\n}\n\ninterface FolderQueryInfo {\n\tqueryTester: QueryGlobTester;\n\tnoSiblingsClauses: boolean;\n\tfolder: URI;\n\ttree: IDirectoryTree;\n}\n\ninterface IDirectoryTree {\n\trootEntries: IDirectoryEntry[];\n\tpathToEntries: { [relativePath: string]: IDirectoryEntry[] };\n}\n\nclass FileSearchEngine {\n\tprivate filePattern?: string;\n\tprivate includePattern?: glob.ParsedExpression;\n\tprivate maxResults?: number;\n\tprivate exists?: boolean;\n\tprivate isLimitHit = false;\n\tprivate resultCount = 0;\n\tprivate isCanceled = false;\n\n\tprivate activeCancellationTokens: Set<CancellationTokenSource>;\n\n\tprivate globalExcludePattern?: glob.ParsedExpression;\n\n\tconstructor(private config: IFileQuery, private provider: FileSearchProvider2, private sessionLifecycle?: SessionLifecycle) {\n\t\tthis.filePattern = config.filePattern;\n\t\tthis.includePattern = config.includePattern && glob.parse(config.includePattern);\n\t\tthis.maxResults = config.maxResults || undefined;\n\t\tthis.exists = config.exists;\n\t\tthis.activeCancellationTokens = new Set<CancellationTokenSource>();\n\n\t\tthis.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);\n\t}\n\n\tcancel(): void {\n\t\tthis.isCanceled = true;\n\t\tthis.activeCancellationTokens.forEach(t => t.cancel());\n\t\tthis.activeCancellationTokens = new Set();\n\t}\n\n\tsearch(_onResult: (match: IInternalFileMatch) => void): Promise<IInternalSearchComplete> {\n\t\tconst folderQueries = this.config.folderQueries || [];\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst onResult = (match: IInternalFileMatch) => {\n\t\t\t\tthis.resultCount++;\n\t\t\t\t_onResult(match);\n\t\t\t};\n\n\t\t\t// Support that the file pattern is a full path to a file that exists\n\t\t\tif (this.isCanceled) {\n\t\t\t\treturn resolve({ limitHit: this.isLimitHit });\n\t\t\t}\n\n\t\t\t// For each extra file\n\t\t\tif (this.config.extraFileResources) {\n\t\t\t\tthis.config.extraFileResources\n\t\t\t\t\t.forEach(extraFile => {\n\t\t\t\t\t\tconst extraFileStr = extraFile.toString(); // ?\n\t\t\t\t\t\tconst basename = path.basename(extraFileStr);\n\t\t\t\t\t\tif (this.globalExcludePattern && this.globalExcludePattern(extraFileStr, basename)) {\n\t\t\t\t\t\t\treturn; // excluded\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\t\t\t\tthis.matchFile(onResult, { base: extraFile, basename });\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\t// For each root folder'\n\n\t\t\t// NEW: can just call with an array of folder info\n\t\t\tthis.doSearch(folderQueries, onResult).then(stats => {\n\t\t\t\tresolve({\n\t\t\t\t\tlimitHit: this.isLimitHit,\n\t\t\t\t\tstats: stats || undefined // Only looking at single-folder workspace stats...\n\t\t\t\t});\n\t\t\t}, (err: Error) => {\n\t\t\t\treject(new Error(toErrorMessage(err)));\n\t\t\t});\n\t\t});\n\t}\n\n\n\tprivate async doSearch(fqs: IFolderQuery<URI>[], onResult: (match: IInternalFileMatch) => void): Promise<IFileSearchProviderStats | null> {\n\t\tconst cancellation = new CancellationTokenSource();\n\t\tconst folderOptions = fqs.map(fq => this.getSearchOptionsForFolder(fq));\n\t\tconst session = this.provider instanceof OldFileSearchProviderConverter ? this.sessionLifecycle?.tokenSource.token : this.sessionLifecycle?.obj;\n\t\tconst options: FileSearchProviderOptions = {\n\t\t\tfolderOptions,\n\t\t\tmaxResults: this.config.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS,\n\t\t\tsession\n\t\t};\n\n\n\t\tconst getFolderQueryInfo = (fq: IFolderQuery) => {\n\t\t\tconst queryTester = new QueryGlobTester(this.config, fq);\n\t\t\tconst noSiblingsClauses = !queryTester.hasSiblingExcludeClauses();\n\t\t\treturn { queryTester, noSiblingsClauses, folder: fq.folder, tree: this.initDirectoryTree() };\n\t\t};\n\n\t\tconst folderMappings: FolderQuerySearchTree<FolderQueryInfo> = new FolderQuerySearchTree<FolderQueryInfo>(fqs, getFolderQueryInfo);\n\n\t\tlet providerSW: StopWatch;\n\n\t\ttry {\n\t\t\tthis.activeCancellationTokens.add(cancellation);\n\n\t\t\tproviderSW = StopWatch.create();\n\t\t\tconst results = await this.provider.provideFileSearchResults(\n\t\t\t\tthis.config.filePattern || '',\n\t\t\t\toptions,\n\t\t\t\tcancellation.token);\n\t\t\tconst providerTime = providerSW.elapsed();\n\t\t\tconst postProcessSW = StopWatch.create();\n\n\t\t\tif (this.isCanceled && !this.isLimitHit) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\n\t\t\tif (results) {\n\t\t\t\tresults.forEach(result => {\n\t\t\t\t\tconst fqFolderInfo = folderMappings.findQueryFragmentAwareSubstr(result)!;\n\t\t\t\t\tconst relativePath = path.posix.relative(fqFolderInfo.folder.path, result.path);\n\n\t\t\t\t\tif (fqFolderInfo.noSiblingsClauses) {\n\t\t\t\t\t\tconst basename = path.basename(result.path);\n\t\t\t\t\t\tthis.matchFile(onResult, { base: fqFolderInfo.folder, relativePath, basename });\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// TODO: Optimize siblings clauses with ripgrep here.\n\t\t\t\t\tthis.addDirectoryEntries(fqFolderInfo.tree, fqFolderInfo.folder, relativePath, onResult);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (this.isCanceled && !this.isLimitHit) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfolderMappings.forEachFolderQueryInfo(e => {\n\t\t\t\tthis.matchDirectoryTree(e.tree, e.queryTester, onResult);\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tproviderTime,\n\t\t\t\tpostProcessTime: postProcessSW.elapsed()\n\t\t\t};\n\t\t} finally {\n\t\t\tcancellation.dispose();\n\t\t\tthis.activeCancellationTokens.delete(cancellation);\n\t\t}\n\t}\n\n\tprivate getSearchOptionsForFolder(fq: IFolderQuery<URI>): FileSearchProviderFolderOptions {\n\t\tconst includes = resolvePatternsForProvider(this.config.includePattern, fq.includePattern);\n\t\tlet excludePattern = fq.excludePattern?.map(e => ({\n\t\t\tfolder: e.folder,\n\t\t\tpatterns: resolvePatternsForProvider(this.config.excludePattern, e.pattern)\n\t\t}));\n\t\tif (!excludePattern?.length) {\n\t\t\texcludePattern = [{\n\t\t\t\tfolder: undefined,\n\t\t\t\tpatterns: resolvePatternsForProvider(this.config.excludePattern, undefined)\n\t\t\t}];\n\t\t}\n\t\tconst excludes = excludeToGlobPattern(excludePattern);\n\n\t\treturn {\n\t\t\tfolder: fq.folder,\n\t\t\texcludes,\n\t\t\tincludes,\n\t\t\tuseIgnoreFiles: {\n\t\t\t\tlocal: !fq.disregardIgnoreFiles,\n\t\t\t\tparent: !fq.disregardParentIgnoreFiles,\n\t\t\t\tglobal: !fq.disregardGlobalIgnoreFiles\n\t\t\t},\n\t\t\tfollowSymlinks: !fq.ignoreSymlinks,\n\t\t};\n\t}\n\n\tprivate initDirectoryTree(): IDirectoryTree {\n\t\tconst tree: IDirectoryTree = {\n\t\t\trootEntries: [],\n\t\t\tpathToEntries: Object.create(null)\n\t\t};\n\t\ttree.pathToEntries['.'] = tree.rootEntries;\n\t\treturn tree;\n\t}\n\n\tprivate addDirectoryEntries({ pathToEntries }: IDirectoryTree, base: URI, relativeFile: string, onResult: (result: IInternalFileMatch) => void) {\n\t\t// Support relative paths to files from a root resource (ignores excludes)\n\t\tif (relativeFile === this.filePattern) {\n\t\t\tconst basename = path.basename(this.filePattern);\n\t\t\tthis.matchFile(onResult, { base: base, relativePath: this.filePattern, basename });\n\t\t}\n\n\t\tfunction add(relativePath: string) {\n\t\t\tconst basename = path.basename(relativePath);\n\t\t\tconst dirname = path.dirname(relativePath);\n\t\t\tlet entries = pathToEntries[dirname];\n\t\t\tif (!entries) {\n\t\t\t\tentries = pathToEntries[dirname] = [];\n\t\t\t\tadd(dirname);\n\t\t\t}\n\t\t\tentries.push({\n\t\t\t\tbase,\n\t\t\t\trelativePath,\n\t\t\t\tbasename\n\t\t\t});\n\t\t}\n\n\t\tadd(relativeFile);\n\t}\n\n\tprivate matchDirectoryTree({ rootEntries, pathToEntries }: IDirectoryTree, queryTester: QueryGlobTester, onResult: (result: IInternalFileMatch) => void) {\n\t\tconst self = this;\n\t\tconst filePattern = this.filePattern;\n\t\tfunction matchDirectory(entries: IDirectoryEntry[]) {\n\t\t\tconst hasSibling = hasSiblingFn(() => entries.map(entry => entry.basename));\n\t\t\tfor (let i = 0, n = entries.length; i < n; i++) {\n\t\t\t\tconst entry = entries[i];\n\t\t\t\tconst { relativePath, basename } = entry;\n\n\t\t\t\t// Check exclude pattern\n\t\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t\t// to ignore filtering by siblings because the user seems to know what they\n\t\t\t\t// are searching for and we want to include the result in that case anyway\n\t\t\t\tif (queryTester.matchesExcludesSync(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst sub = pathToEntries[relativePath];\n\t\t\t\tif (sub) {\n\t\t\t\t\tmatchDirectory(sub);\n\t\t\t\t} else {\n\t\t\t\t\tif (relativePath === filePattern) {\n\t\t\t\t\t\tcontinue; // ignore file if its path matches with the file pattern because that is already matched above\n\t\t\t\t\t}\n\n\t\t\t\t\tself.matchFile(onResult, entry);\n\t\t\t\t}\n\n\t\t\t\tif (self.isLimitHit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatchDirectory(rootEntries);\n\t}\n\n\tprivate matchFile(onResult: (result: IInternalFileMatch) => void, candidate: IInternalFileMatch): void {\n\t\tif (!this.includePattern || (candidate.relativePath && this.includePattern(candidate.relativePath, candidate.basename))) {\n\t\t\tif (this.exists || (this.maxResults && this.resultCount >= this.maxResults)) {\n\t\t\t\tthis.isLimitHit = true;\n\t\t\t\tthis.cancel();\n\t\t\t}\n\n\t\t\tif (!this.isLimitHit) {\n\t\t\t\tonResult(candidate);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninterface IInternalSearchComplete {\n\tlimitHit: boolean;\n\tstats?: IFileSearchProviderStats;\n}\n\n/**\n * For backwards compatibility, store both a cancellation token and a session object. The session object is the new implementation, where\n */\nclass SessionLifecycle {\n\tprivate _obj: object | undefined;\n\tpublic readonly tokenSource: CancellationTokenSource;\n\n\tconstructor() {\n\t\tthis._obj = new Object();\n\t\tthis.tokenSource = new CancellationTokenSource();\n\t}\n\n\tpublic get obj() {\n\t\tif (this._obj) {\n\t\t\treturn this._obj;\n\t\t}\n\n\t\tthrow new Error('Session object has been dereferenced.');\n\t}\n\n\tcancel() {\n\t\tthis.tokenSource.cancel();\n\t\tthis._obj = undefined; // dereference\n\t}\n}\n\nexport class FileSearchManager {\n\n\tprivate static readonly BATCH_SIZE = 512;\n\n\tprivate readonly sessions = new Map<string, SessionLifecycle>();\n\n\tfileSearch(config: IFileQuery, provider: FileSearchProvider2, onBatch: (matches: IFileMatch[]) => void, token: CancellationToken): Promise<ISearchCompleteStats> {\n\t\tconst sessionTokenSource = this.getSessionTokenSource(config.cacheKey);\n\t\tconst engine = new FileSearchEngine(config, provider, sessionTokenSource);\n\n\t\tlet resultCount = 0;\n\t\tconst onInternalResult = (batch: IInternalFileMatch[]) => {\n\t\t\tresultCount += batch.length;\n\t\t\tonBatch(batch.map(m => this.rawMatchToSearchItem(m)));\n\t\t};\n\n\t\treturn this.doSearch(engine, FileSearchManager.BATCH_SIZE, onInternalResult, token).then(\n\t\t\tresult => {\n\t\t\t\treturn {\n\t\t\t\t\tlimitHit: result.limitHit,\n\t\t\t\t\tstats: result.stats ? {\n\t\t\t\t\t\tfromCache: false,\n\t\t\t\t\t\ttype: 'fileSearchProvider',\n\t\t\t\t\t\tresultCount,\n\t\t\t\t\t\tdetailStats: result.stats\n\t\t\t\t\t} : undefined,\n\t\t\t\t\tmessages: []\n\t\t\t\t};\n\t\t\t});\n\t}\n\n\tclearCache(cacheKey: string): void {\n\t\t// cancel the token\n\t\tthis.sessions.get(cacheKey)?.cancel();\n\t\t// with no reference to this, it will be removed from WeakMaps\n\t\tthis.sessions.delete(cacheKey);\n\t}\n\n\tprivate getSessionTokenSource(cacheKey: string | undefined): SessionLifecycle | undefined {\n\t\tif (!cacheKey) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this.sessions.has(cacheKey)) {\n\t\t\tthis.sessions.set(cacheKey, new SessionLifecycle());\n\t\t}\n\n\t\treturn this.sessions.get(cacheKey);\n\t}\n\n\tprivate rawMatchToSearchItem(match: IInternalFileMatch): IFileMatch {\n\t\tif (match.relativePath) {\n\t\t\treturn {\n\t\t\t\tresource: resources.joinPath(match.base, match.relativePath)\n\t\t\t};\n\t\t} else {\n\t\t\t// extraFileResources\n\t\t\treturn {\n\t\t\t\tresource: match.base\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate doSearch(engine: FileSearchEngine, batchSize: number, onResultBatch: (matches: IInternalFileMatch[]) => void, token: CancellationToken): Promise<IInternalSearchComplete> {\n\t\tconst listener = token.onCancellationRequested(() => {\n\t\t\tengine.cancel();\n\t\t});\n\n\t\tconst _onResult = (match: IInternalFileMatch) => {\n\t\t\tif (match) {\n\t\t\t\tbatch.push(match);\n\t\t\t\tif (batchSize > 0 && batch.length >= batchSize) {\n\t\t\t\t\tonResultBatch(batch);\n\t\t\t\t\tbatch = [];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet batch: IInternalFileMatch[] = [];\n\t\treturn engine.search(_onResult).then(result => {\n\t\t\tif (batch.length) {\n\t\t\t\tonResultBatch(batch);\n\t\t\t}\n\n\t\t\tlistener.dispose();\n\t\t\treturn result;\n\t\t}, error => {\n\t\t\tif (batch.length) {\n\t\t\t\tonResultBatch(batch);\n\t\t\t}\n\n\t\t\tlistener.dispose();\n\t\t\treturn Promise.reject(error);\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from '../../../../base/common/path.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport * as glob from '../../../../base/common/glob.js';\nimport * as resources from '../../../../base/common/resources.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IFileMatch, IFileSearchProviderStats, IFolderQuery, ISearchCompleteStats, IFileQuery, QueryGlobTester, resolvePatternsForProvider, hasSiblingFn, excludeToGlobPattern, DEFAULT_MAX_SEARCH_RESULTS } from './search.js';\nimport { FileSearchProviderFolderOptions, FileSearchProvider2, FileSearchProviderOptions } from './searchExtTypes.js';\nimport { OldFileSearchProviderConverter } from './searchExtConversionTypes.js';\nimport { FolderQuerySearchTree } from './folderQuerySearchTree.js';\n\ninterface IInternalFileMatch {\n\tbase: URI;\n\toriginal?: URI;\n\trelativePath?: string; // Not present for extraFiles or absolute path matches\n\tbasename: string;\n\tsize?: number;\n}\n\ninterface IDirectoryEntry {\n\tbase: URI;\n\trelativePath: string;\n\tbasename: string;\n}\n\ninterface FolderQueryInfo {\n\tqueryTester: QueryGlobTester;\n\tnoSiblingsClauses: boolean;\n\tfolder: URI;\n\ttree: IDirectoryTree;\n}\n\ninterface IDirectoryTree {\n\trootEntries: IDirectoryEntry[];\n\tpathToEntries: { [relativePath: string]: IDirectoryEntry[] };\n}\n\nclass FileSearchEngine {\n\tprivate filePattern?: string;\n\tprivate includePattern?: glob.ParsedExpression;\n\tprivate maxResults?: number;\n\tprivate exists?: boolean;\n\tprivate isLimitHit = false;\n\tprivate resultCount = 0;\n\tprivate isCanceled = false;\n\n\tprivate activeCancellationTokens: Set<CancellationTokenSource>;\n\n\tprivate globalExcludePattern?: glob.ParsedExpression;\n\n\tconstructor(private config: IFileQuery, private provider: FileSearchProvider2, private sessionLifecycle?: SessionLifecycle) {\n\t\tthis.filePattern = config.filePattern;\n\t\tthis.includePattern = config.includePattern && glob.parse(config.includePattern);\n\t\tthis.maxResults = config.maxResults || undefined;\n\t\tthis.exists = config.exists;\n\t\tthis.activeCancellationTokens = new Set<CancellationTokenSource>();\n\n\t\tthis.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);\n\t}\n\n\tcancel(): void {\n\t\tthis.isCanceled = true;\n\t\tthis.activeCancellationTokens.forEach(t => t.cancel());\n\t\tthis.activeCancellationTokens = new Set();\n\t}\n\n\tsearch(_onResult: (match: IInternalFileMatch) => void): Promise<IInternalSearchComplete> {\n\t\tconst folderQueries = this.config.folderQueries || [];\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst onResult = (match: IInternalFileMatch) => {\n\t\t\t\tthis.resultCount++;\n\t\t\t\t_onResult(match);\n\t\t\t};\n\n\t\t\t// Support that the file pattern is a full path to a file that exists\n\t\t\tif (this.isCanceled) {\n\t\t\t\treturn resolve({ limitHit: this.isLimitHit });\n\t\t\t}\n\n\t\t\t// For each extra file\n\t\t\tif (this.config.extraFileResources) {\n\t\t\t\tthis.config.extraFileResources\n\t\t\t\t\t.forEach(extraFile => {\n\t\t\t\t\t\tconst extraFileStr = extraFile.toString(); // ?\n\t\t\t\t\t\tconst basename = path.basename(extraFileStr);\n\t\t\t\t\t\tif (this.globalExcludePattern && this.globalExcludePattern(extraFileStr, basename)) {\n\t\t\t\t\t\t\treturn; // excluded\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\t\t\t\tthis.matchFile(onResult, { base: extraFile, basename });\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\t// For each root folder'\n\n\t\t\t// NEW: can just call with an array of folder info\n\t\t\tthis.doSearch(folderQueries, onResult).then(stats => {\n\t\t\t\tresolve({\n\t\t\t\t\tlimitHit: this.isLimitHit,\n\t\t\t\t\tstats: stats || undefined // Only looking at single-folder workspace stats...\n\t\t\t\t});\n\t\t\t}, (err: Error) => {\n\t\t\t\treject(new Error(toErrorMessage(err)));\n\t\t\t});\n\t\t});\n\t}\n\n\n\tprivate async doSearch(fqs: IFolderQuery<URI>[], onResult: (match: IInternalFileMatch) => void): Promise<IFileSearchProviderStats | null> {\n\t\tconst cancellation = new CancellationTokenSource();\n\t\tconst folderOptions = fqs.map(fq => this.getSearchOptionsForFolder(fq));\n\t\tconst session = this.provider instanceof OldFileSearchProviderConverter ? this.sessionLifecycle?.tokenSource.token : this.sessionLifecycle?.obj;\n\t\tconst options: FileSearchProviderOptions = {\n\t\t\tfolderOptions,\n\t\t\tmaxResults: this.config.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS,\n\t\t\tsession\n\t\t};\n\n\n\t\tconst getFolderQueryInfo = (fq: IFolderQuery) => {\n\t\t\tconst queryTester = new QueryGlobTester(this.config, fq);\n\t\t\tconst noSiblingsClauses = !queryTester.hasSiblingExcludeClauses();\n\t\t\treturn { queryTester, noSiblingsClauses, folder: fq.folder, tree: this.initDirectoryTree() };\n\t\t};\n\n\t\tconst folderMappings: FolderQuerySearchTree<FolderQueryInfo> = new FolderQuerySearchTree<FolderQueryInfo>(fqs, getFolderQueryInfo);\n\n\t\tlet providerSW: StopWatch;\n\n\t\ttry {\n\t\t\tthis.activeCancellationTokens.add(cancellation);\n\n\t\t\tproviderSW = StopWatch.create();\n\t\t\tconst results = await this.provider.provideFileSearchResults(\n\t\t\t\tthis.config.filePattern || '',\n\t\t\t\toptions,\n\t\t\t\tcancellation.token);\n\t\t\tconst providerTime = providerSW.elapsed();\n\t\t\tconst postProcessSW = StopWatch.create();\n\n\t\t\tif (this.isCanceled && !this.isLimitHit) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\n\t\t\tif (results) {\n\t\t\t\tresults.forEach(result => {\n\t\t\t\t\tconst fqFolderInfo = folderMappings.findQueryFragmentAwareSubstr(result)!;\n\t\t\t\t\tconst relativePath = path.posix.relative(fqFolderInfo.folder.path, result.path);\n\n\t\t\t\t\tif (fqFolderInfo.noSiblingsClauses) {\n\t\t\t\t\t\tconst basename = path.basename(result.path);\n\t\t\t\t\t\tthis.matchFile(onResult, { base: fqFolderInfo.folder, relativePath, basename });\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// TODO: Optimize siblings clauses with ripgrep here.\n\t\t\t\t\tthis.addDirectoryEntries(fqFolderInfo.tree, fqFolderInfo.folder, relativePath, onResult);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (this.isCanceled && !this.isLimitHit) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfolderMappings.forEachFolderQueryInfo(e => {\n\t\t\t\tthis.matchDirectoryTree(e.tree, e.queryTester, onResult);\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tproviderTime,\n\t\t\t\tpostProcessTime: postProcessSW.elapsed()\n\t\t\t};\n\t\t} finally {\n\t\t\tcancellation.dispose();\n\t\t\tthis.activeCancellationTokens.delete(cancellation);\n\t\t}\n\t}\n\n\tprivate getSearchOptionsForFolder(fq: IFolderQuery<URI>): FileSearchProviderFolderOptions {\n\t\tconst includes = resolvePatternsForProvider(this.config.includePattern, fq.includePattern);\n\t\tlet excludePattern = fq.excludePattern?.map(e => ({\n\t\t\tfolder: e.folder,\n\t\t\tpatterns: resolvePatternsForProvider(this.config.excludePattern, e.pattern)\n\t\t}));\n\t\tif (!excludePattern?.length) {\n\t\t\texcludePattern = [{\n\t\t\t\tfolder: undefined,\n\t\t\t\tpatterns: resolvePatternsForProvider(this.config.excludePattern, undefined)\n\t\t\t}];\n\t\t}\n\t\tconst excludes = excludeToGlobPattern(excludePattern);\n\n\t\treturn {\n\t\t\tfolder: fq.folder,\n\t\t\texcludes,\n\t\t\tincludes,\n\t\t\tuseIgnoreFiles: {\n\t\t\t\tlocal: !fq.disregardIgnoreFiles,\n\t\t\t\tparent: !fq.disregardParentIgnoreFiles,\n\t\t\t\tglobal: !fq.disregardGlobalIgnoreFiles\n\t\t\t},\n\t\t\tfollowSymlinks: !fq.ignoreSymlinks,\n\t\t};\n\t}\n\n\tprivate initDirectoryTree(): IDirectoryTree {\n\t\tconst tree: IDirectoryTree = {\n\t\t\trootEntries: [],\n\t\t\tpathToEntries: Object.create(null)\n\t\t};\n\t\ttree.pathToEntries['.'] = tree.rootEntries;\n\t\treturn tree;\n\t}\n\n\tprivate addDirectoryEntries({ pathToEntries }: IDirectoryTree, base: URI, relativeFile: string, onResult: (result: IInternalFileMatch) => void) {\n\t\t// Support relative paths to files from a root resource (ignores excludes)\n\t\tif (relativeFile === this.filePattern) {\n\t\t\tconst basename = path.basename(this.filePattern);\n\t\t\tthis.matchFile(onResult, { base: base, relativePath: this.filePattern, basename });\n\t\t}\n\n\t\tfunction add(relativePath: string) {\n\t\t\tconst basename = path.basename(relativePath);\n\t\t\tconst dirname = path.dirname(relativePath);\n\t\t\tlet entries = pathToEntries[dirname];\n\t\t\tif (!entries) {\n\t\t\t\tentries = pathToEntries[dirname] = [];\n\t\t\t\tadd(dirname);\n\t\t\t}\n\t\t\tentries.push({\n\t\t\t\tbase,\n\t\t\t\trelativePath,\n\t\t\t\tbasename\n\t\t\t});\n\t\t}\n\n\t\tadd(relativeFile);\n\t}\n\n\tprivate matchDirectoryTree({ rootEntries, pathToEntries }: IDirectoryTree, queryTester: QueryGlobTester, onResult: (result: IInternalFileMatch) => void) {\n\t\tconst self = this;\n\t\tconst filePattern = this.filePattern;\n\t\tfunction matchDirectory(entries: IDirectoryEntry[]) {\n\t\t\tconst hasSibling = hasSiblingFn(() => entries.map(entry => entry.basename));\n\t\t\tfor (let i = 0, n = entries.length; i < n; i++) {\n\t\t\t\tconst entry = entries[i];\n\t\t\t\tconst { relativePath, basename } = entry;\n\n\t\t\t\t// Check exclude pattern\n\t\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t\t// to ignore filtering by siblings because the user seems to know what they\n\t\t\t\t// are searching for and we want to include the result in that case anyway\n\t\t\t\tif (queryTester.matchesExcludesSync(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst sub = pathToEntries[relativePath];\n\t\t\t\tif (sub) {\n\t\t\t\t\tmatchDirectory(sub);\n\t\t\t\t} else {\n\t\t\t\t\tif (relativePath === filePattern) {\n\t\t\t\t\t\tcontinue; // ignore file if its path matches with the file pattern because that is already matched above\n\t\t\t\t\t}\n\n\t\t\t\t\tself.matchFile(onResult, entry);\n\t\t\t\t}\n\n\t\t\t\tif (self.isLimitHit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatchDirectory(rootEntries);\n\t}\n\n\tprivate matchFile(onResult: (result: IInternalFileMatch) => void, candidate: IInternalFileMatch): void {\n\t\tif (!this.includePattern || (candidate.relativePath && this.includePattern(candidate.relativePath, candidate.basename))) {\n\t\t\tif (this.exists || (this.maxResults && this.resultCount >= this.maxResults)) {\n\t\t\t\tthis.isLimitHit = true;\n\t\t\t\tthis.cancel();\n\t\t\t}\n\n\t\t\tif (!this.isLimitHit) {\n\t\t\t\tonResult(candidate);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninterface IInternalSearchComplete {\n\tlimitHit: boolean;\n\tstats?: IFileSearchProviderStats;\n}\n\n/**\n * For backwards compatibility, store both a cancellation token and a session object. The session object is the new implementation, where\n */\nclass SessionLifecycle {\n\tprivate _obj: object | undefined;\n\tpublic readonly tokenSource: CancellationTokenSource;\n\n\tconstructor() {\n\t\tthis._obj = new Object();\n\t\tthis.tokenSource = new CancellationTokenSource();\n\t}\n\n\tpublic get obj() {\n\t\tif (this._obj) {\n\t\t\treturn this._obj;\n\t\t}\n\n\t\tthrow new Error('Session object has been dereferenced.');\n\t}\n\n\tcancel() {\n\t\tthis.tokenSource.cancel();\n\t\tthis._obj = undefined; // dereference\n\t}\n}\n\nexport class FileSearchManager {\n\n\tprivate static readonly BATCH_SIZE = 512;\n\n\tprivate readonly sessions = new Map<string, SessionLifecycle>();\n\n\tfileSearch(config: IFileQuery, provider: FileSearchProvider2, onBatch: (matches: IFileMatch[]) => void, token: CancellationToken): Promise<ISearchCompleteStats> {\n\t\tconst sessionTokenSource = this.getSessionTokenSource(config.cacheKey);\n\t\tconst engine = new FileSearchEngine(config, provider, sessionTokenSource);\n\n\t\tlet resultCount = 0;\n\t\tconst onInternalResult = (batch: IInternalFileMatch[]) => {\n\t\t\tresultCount += batch.length;\n\t\t\tonBatch(batch.map(m => this.rawMatchToSearchItem(m)));\n\t\t};\n\n\t\treturn this.doSearch(engine, FileSearchManager.BATCH_SIZE, onInternalResult, token).then(\n\t\t\tresult => {\n\t\t\t\treturn {\n\t\t\t\t\tlimitHit: result.limitHit,\n\t\t\t\t\tstats: result.stats ? {\n\t\t\t\t\t\tfromCache: false,\n\t\t\t\t\t\ttype: 'fileSearchProvider',\n\t\t\t\t\t\tresultCount,\n\t\t\t\t\t\tdetailStats: result.stats\n\t\t\t\t\t} : undefined,\n\t\t\t\t\tmessages: []\n\t\t\t\t};\n\t\t\t});\n\t}\n\n\tclearCache(cacheKey: string): void {\n\t\t// cancel the token\n\t\tthis.sessions.get(cacheKey)?.cancel();\n\t\t// with no reference to this, it will be removed from WeakMaps\n\t\tthis.sessions.delete(cacheKey);\n\t}\n\n\tprivate getSessionTokenSource(cacheKey: string | undefined): SessionLifecycle | undefined {\n\t\tif (!cacheKey) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this.sessions.has(cacheKey)) {\n\t\t\tthis.sessions.set(cacheKey, new SessionLifecycle());\n\t\t}\n\n\t\treturn this.sessions.get(cacheKey);\n\t}\n\n\tprivate rawMatchToSearchItem(match: IInternalFileMatch): IFileMatch {\n\t\tif (match.relativePath) {\n\t\t\treturn {\n\t\t\t\tresource: resources.joinPath(match.base, match.relativePath)\n\t\t\t};\n\t\t} else {\n\t\t\t// extraFileResources\n\t\t\treturn {\n\t\t\t\tresource: match.base\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate doSearch(engine: FileSearchEngine, batchSize: number, onResultBatch: (matches: IInternalFileMatch[]) => void, token: CancellationToken): Promise<IInternalSearchComplete> {\n\t\tconst listener = token.onCancellationRequested(() => {\n\t\t\tengine.cancel();\n\t\t});\n\n\t\tconst _onResult = (match: IInternalFileMatch) => {\n\t\t\tif (match) {\n\t\t\t\tbatch.push(match);\n\t\t\t\tif (batchSize > 0 && batch.length >= batchSize) {\n\t\t\t\t\tonResultBatch(batch);\n\t\t\t\t\tbatch = [];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet batch: IInternalFileMatch[] = [];\n\t\treturn engine.search(_onResult).then(result => {\n\t\t\tif (batch.length) {\n\t\t\t\tonResultBatch(batch);\n\t\t\t}\n\n\t\t\tlistener.dispose();\n\t\t\treturn result;\n\t\t}, error => {\n\t\t\tif (batch.length) {\n\t\t\t\tonResultBatch(batch);\n\t\t\t}\n\n\t\t\tlistener.dispose();\n\t\t\treturn Promise.reject(error);\n\t\t});\n\t}\n}\n"]}