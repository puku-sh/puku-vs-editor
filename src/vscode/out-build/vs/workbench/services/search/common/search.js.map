{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/common/search.ts","vs/workbench/services/search/common/search.ts"],"names":[],"mappings":"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","file":"search.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mapArrayOrNot } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport * as glob from '../../../../base/common/glob.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport * as objects from '../../../../base/common/objects.js';\nimport * as extpath from '../../../../base/common/extpath.js';\nimport { fuzzyContains, getNLines } from '../../../../base/common/strings.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { IFilesConfiguration } from '../../../../platform/files/common/files.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ITelemetryData } from '../../../../platform/telemetry/common/telemetry.js';\nimport { Event } from '../../../../base/common/event.js';\nimport * as paths from '../../../../base/common/path.js';\nimport { isCancellationError } from '../../../../base/common/errors.js';\nimport { AISearchKeyword, GlobPattern, TextSearchCompleteMessageType } from './searchExtTypes.js';\nimport { isThenable } from '../../../../base/common/async.js';\nimport { ResourceSet } from '../../../../base/common/map.js';\n\nexport { TextSearchCompleteMessageType };\n\nexport const VIEWLET_ID = 'workbench.view.search';\nexport const PANEL_ID = 'workbench.panel.search';\nexport const VIEW_ID = 'workbench.view.search';\nexport const SEARCH_RESULT_LANGUAGE_ID = 'search-result';\n\nexport const SEARCH_EXCLUDE_CONFIG = 'search.exclude';\nexport const DEFAULT_MAX_SEARCH_RESULTS = 20000;\n\n// Warning: this pattern is used in the search editor to detect offsets. If you\n// change this, also change the search-result built-in extension\nconst SEARCH_ELIDED_PREFIX = '⟪ ';\nconst SEARCH_ELIDED_SUFFIX = ' characters skipped ⟫';\nconst SEARCH_ELIDED_MIN_LEN = (SEARCH_ELIDED_PREFIX.length + SEARCH_ELIDED_SUFFIX.length + 5) * 2;\n\nexport const ISearchService = createDecorator<ISearchService>('searchService');\n\n/**\n * A service that enables to search for files or with in files.\n */\nexport interface ISearchService {\n\treadonly _serviceBrand: undefined;\n\ttextSearch(query: ITextQuery, token?: CancellationToken, onProgress?: (result: ISearchProgressItem) => void): Promise<ISearchComplete>;\n\taiTextSearch(query: IAITextQuery, token?: CancellationToken, onProgress?: (result: ISearchProgressItem) => void): Promise<ISearchComplete>;\n\tgetAIName(): Promise<string | undefined>;\n\ttextSearchSplitSyncAsync(query: ITextQuery, token?: CancellationToken | undefined, onProgress?: ((result: ISearchProgressItem) => void) | undefined, notebookFilesToIgnore?: ResourceSet, asyncNotebookFilesToIgnore?: Promise<ResourceSet>): { syncResults: ISearchComplete; asyncResults: Promise<ISearchComplete> };\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete>;\n\tschemeHasFileSearchProvider(scheme: string): boolean;\n\tclearCache(cacheKey: string): Promise<void>;\n\tregisterSearchResultProvider(scheme: string, type: SearchProviderType, provider: ISearchResultProvider): IDisposable;\n}\n\n/**\n * TODO@roblou - split text from file search entirely, or share code in a more natural way.\n */\nexport const enum SearchProviderType {\n\tfile,\n\ttext,\n\taiText\n}\n\nexport interface ISearchResultProvider {\n\tgetAIName(): Promise<string | undefined>;\n\ttextSearch(query: ITextQuery, onProgress?: (p: ISearchProgressItem) => void, token?: CancellationToken): Promise<ISearchComplete>;\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\n\nexport interface ExcludeGlobPattern<U extends UriComponents = URI> {\n\tfolder?: U;\n\tpattern: glob.IExpression;\n}\n\nexport interface IFolderQuery<U extends UriComponents = URI> {\n\tfolder: U;\n\tfolderName?: string;\n\texcludePattern?: ExcludeGlobPattern<U>[];\n\tincludePattern?: glob.IExpression;\n\tfileEncoding?: string;\n\tdisregardIgnoreFiles?: boolean;\n\tdisregardGlobalIgnoreFiles?: boolean;\n\tdisregardParentIgnoreFiles?: boolean;\n\tignoreSymlinks?: boolean;\n}\n\nexport interface ICommonQueryProps<U extends UriComponents> {\n\t/** For telemetry - indicates what is triggering the source */\n\t_reason?: string;\n\n\tfolderQueries: IFolderQuery<U>[];\n\t// The include pattern for files that gets passed into ripgrep.\n\t// Note that this will override any ignore files if applicable.\n\tincludePattern?: glob.IExpression;\n\texcludePattern?: glob.IExpression;\n\textraFileResources?: U[];\n\n\tonlyOpenEditors?: boolean;\n\n\tmaxResults?: number;\n\tusingSearchPaths?: boolean;\n\tonlyFileScheme?: boolean;\n}\n\nexport interface IFileQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.File;\n\tfilePattern?: string;\n\n\t// when walking through the tree to find the result, don't use the filePattern to fuzzy match.\n\t// Instead, should use glob matching.\n\tshouldGlobMatchFilePattern?: boolean;\n\n\t/**\n\t * If true no results will be returned. Instead `limitHit` will indicate if at least one result exists or not.\n\t * Currently does not work with queries including a 'siblings clause'.\n\t */\n\texists?: boolean;\n\tsortByScore?: boolean;\n\tcacheKey?: string;\n}\n\nexport interface ITextQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.Text;\n\tcontentPattern: IPatternInfo;\n\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tmaxFileSize?: number;\n\tusePCRE2?: boolean;\n\tsurroundingContext?: number;\n\n\tuserDisabledExcludesAndIgnoreFiles?: boolean;\n}\n\nexport interface IAITextQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.aiText;\n\tcontentPattern: string;\n\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tmaxFileSize?: number;\n\tsurroundingContext?: number;\n\n\tuserDisabledExcludesAndIgnoreFiles?: boolean;\n}\n\nexport type IFileQuery = IFileQueryProps<URI>;\nexport type IRawFileQuery = IFileQueryProps<UriComponents>;\nexport type ITextQuery = ITextQueryProps<URI>;\nexport type IRawTextQuery = ITextQueryProps<UriComponents>;\nexport type IAITextQuery = IAITextQueryProps<URI>;\nexport type IRawAITextQuery = IAITextQueryProps<UriComponents>;\n\nexport type IRawQuery = IRawTextQuery | IRawFileQuery | IRawAITextQuery;\nexport type ISearchQuery = ITextQuery | IFileQuery | IAITextQuery;\nexport type ITextSearchQuery = ITextQuery | IAITextQuery;\n\nexport const enum QueryType {\n\tFile = 1,\n\tText = 2,\n\taiText = 3\n}\n\n/* __GDPR__FRAGMENT__\n\t\"IPatternInfo\" : {\n\t\t\"isRegExp\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isWordMatch\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"wordSeparators\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"isMultiline\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isCaseSensitive\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isSmartCase\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n\t}\n*/\nexport interface IPatternInfo {\n\tpattern: string;\n\tisRegExp?: boolean;\n\tisWordMatch?: boolean;\n\twordSeparators?: string;\n\tisMultiline?: boolean;\n\tisUnicode?: boolean;\n\tisCaseSensitive?: boolean;\n\tnotebookInfo?: INotebookPatternInfo;\n}\n\nexport interface INotebookPatternInfo {\n\tisInNotebookMarkdownInput?: boolean;\n\tisInNotebookMarkdownPreview?: boolean;\n\tisInNotebookCellInput?: boolean;\n\tisInNotebookCellOutput?: boolean;\n}\n\nexport interface IExtendedExtensionSearchOptions {\n\tusePCRE2?: boolean;\n}\n\nexport interface IFileMatch<U extends UriComponents = URI> {\n\tresource: U;\n\tresults?: ITextSearchResult<U>[];\n}\n\nexport type IRawFileMatch2 = IFileMatch<UriComponents>;\n\nexport interface ITextSearchPreviewOptions {\n\tmatchLines: number;\n\tcharsPerLine: number;\n}\n\nexport interface ISearchRange {\n\treadonly startLineNumber: number;\n\treadonly startColumn: number;\n\treadonly endLineNumber: number;\n\treadonly endColumn: number;\n}\n\nexport interface ITextSearchMatch<U extends UriComponents = URI> {\n\turi?: U;\n\trangeLocations: SearchRangeSetPairing[];\n\tpreviewText: string;\n\twebviewIndex?: number;\n\tcellFragment?: string;\n}\n\nexport interface ITextSearchContext<U extends UriComponents = URI> {\n\turi?: U;\n\ttext: string;\n\tlineNumber: number;\n}\n\nexport type ITextSearchResult<U extends UriComponents = URI> = ITextSearchMatch<U> | ITextSearchContext<U>;\n\nexport function resultIsMatch(result: ITextSearchResult): result is ITextSearchMatch {\n\treturn !!(<ITextSearchMatch>result).rangeLocations && !!(<ITextSearchMatch>result).previewText;\n}\n\nexport interface IProgressMessage {\n\tmessage: string;\n}\n\nexport type ISearchProgressItem = IFileMatch | IProgressMessage | AISearchKeyword;\n\nexport function isFileMatch(p: ISearchProgressItem): p is IFileMatch {\n\treturn !!(<IFileMatch>p).resource;\n}\n\nexport function isAIKeyword(p: ISearchProgressItem): p is AISearchKeyword {\n\treturn !!(<AISearchKeyword>p).keyword;\n}\n\nexport function isProgressMessage(p: ISearchProgressItem | ISerializedSearchProgressItem): p is IProgressMessage {\n\treturn !!(p as IProgressMessage).message;\n}\n\nexport interface ITextSearchCompleteMessage {\n\ttext: string;\n\ttype: TextSearchCompleteMessageType;\n\ttrusted?: boolean;\n}\n\nexport interface ISearchCompleteStats {\n\tlimitHit?: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchComplete extends ISearchCompleteStats {\n\tresults: IFileMatch[];\n\texit?: SearchCompletionExitCode;\n\taiKeywords?: AISearchKeyword[];\n}\n\nexport const enum SearchCompletionExitCode {\n\tNormal,\n\tNewSearchStarted\n}\n\nexport interface ITextSearchStats {\n\ttype: 'textSearchProvider' | 'searchProcess' | 'aiTextSearchProvider';\n}\n\nexport interface IFileSearchStats {\n\tfromCache: boolean;\n\tdetailStats: ISearchEngineStats | ICachedSearchStats | IFileSearchProviderStats;\n\n\tresultCount: number;\n\ttype: 'fileSearchProvider' | 'searchProcess';\n\tsortingTime?: number;\n}\n\nexport interface ICachedSearchStats {\n\tcacheWasResolved: boolean;\n\tcacheLookupTime: number;\n\tcacheFilterTime: number;\n\tcacheEntryCount: number;\n}\n\nexport interface ISearchEngineStats {\n\tfileWalkTime: number;\n\tdirectoriesWalked: number;\n\tfilesWalked: number;\n\tcmdTime: number;\n\tcmdResultCount?: number;\n}\n\nexport interface IFileSearchProviderStats {\n\tproviderTime: number;\n\tpostProcessTime: number;\n}\n\nexport class FileMatch implements IFileMatch {\n\tresults: ITextSearchResult[] = [];\n\tconstructor(public resource: URI) {\n\t\t// empty\n\t}\n}\n\nexport interface SearchRangeSetPairing {\n\tsource: ISearchRange;\n\tpreview: ISearchRange;\n}\n\nexport class TextSearchMatch implements ITextSearchMatch {\n\trangeLocations: SearchRangeSetPairing[] = [];\n\tpreviewText: string;\n\twebviewIndex?: number;\n\n\tconstructor(text: string, ranges: ISearchRange | ISearchRange[], previewOptions?: ITextSearchPreviewOptions, webviewIndex?: number) {\n\t\tthis.webviewIndex = webviewIndex;\n\n\t\t// Trim preview if this is one match and a single-line match with a preview requested.\n\t\t// Otherwise send the full text, like for replace or for showing multiple previews.\n\t\t// TODO this is fishy.\n\t\tconst rangesArr = Array.isArray(ranges) ? ranges : [ranges];\n\n\t\tif (previewOptions && previewOptions.matchLines === 1 && isSingleLineRangeList(rangesArr)) {\n\t\t\t// 1 line preview requested\n\t\t\ttext = getNLines(text, previewOptions.matchLines);\n\n\t\t\tlet result = '';\n\t\t\tlet shift = 0;\n\t\t\tlet lastEnd = 0;\n\t\t\tconst leadingChars = Math.floor(previewOptions.charsPerLine / 5);\n\t\t\tfor (const range of rangesArr) {\n\t\t\t\tconst previewStart = Math.max(range.startColumn - leadingChars, 0);\n\t\t\t\tconst previewEnd = range.startColumn + previewOptions.charsPerLine;\n\t\t\t\tif (previewStart > lastEnd + leadingChars + SEARCH_ELIDED_MIN_LEN) {\n\t\t\t\t\tconst elision = SEARCH_ELIDED_PREFIX + (previewStart - lastEnd) + SEARCH_ELIDED_SUFFIX;\n\t\t\t\t\tresult += elision + text.slice(previewStart, previewEnd);\n\t\t\t\t\tshift += previewStart - (lastEnd + elision.length);\n\t\t\t\t} else {\n\t\t\t\t\tresult += text.slice(lastEnd, previewEnd);\n\t\t\t\t}\n\n\t\t\t\tlastEnd = previewEnd;\n\t\t\t\tthis.rangeLocations.push({\n\t\t\t\t\tsource: range,\n\t\t\t\t\tpreview: new OneLineRange(0, range.startColumn - shift, range.endColumn - shift)\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\tthis.previewText = result;\n\t\t} else {\n\t\t\tconst firstMatchLine = Array.isArray(ranges) ? ranges[0].startLineNumber : ranges.startLineNumber;\n\n\t\t\tconst rangeLocs = mapArrayOrNot(ranges, r => ({\n\t\t\t\tpreview: new SearchRange(r.startLineNumber - firstMatchLine, r.startColumn, r.endLineNumber - firstMatchLine, r.endColumn),\n\t\t\t\tsource: r\n\t\t\t}));\n\n\t\t\tthis.rangeLocations = Array.isArray(rangeLocs) ? rangeLocs : [rangeLocs];\n\t\t\tthis.previewText = text;\n\t\t}\n\t}\n}\n\nfunction isSingleLineRangeList(ranges: ISearchRange[]): boolean {\n\tconst line = ranges[0].startLineNumber;\n\tfor (const r of ranges) {\n\t\tif (r.startLineNumber !== line || r.endLineNumber !== line) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport class SearchRange implements ISearchRange {\n\tstartLineNumber: number;\n\tstartColumn: number;\n\tendLineNumber: number;\n\tendColumn: number;\n\n\tconstructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number) {\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.startColumn = startColumn;\n\t\tthis.endLineNumber = endLineNumber;\n\t\tthis.endColumn = endColumn;\n\t}\n}\n\nexport class OneLineRange extends SearchRange {\n\tconstructor(lineNumber: number, startColumn: number, endColumn: number) {\n\t\tsuper(lineNumber, startColumn, lineNumber, endColumn);\n\t}\n}\n\nexport const enum ViewMode {\n\tList = 'list',\n\tTree = 'tree'\n}\n\nexport const enum SearchSortOrder {\n\tDefault = 'default',\n\tFileNames = 'fileNames',\n\tType = 'type',\n\tModified = 'modified',\n\tCountDescending = 'countDescending',\n\tCountAscending = 'countAscending'\n}\n\nexport const enum SemanticSearchBehavior {\n\tAuto = 'auto',\n\tManual = 'manual',\n\tRunOnEmpty = 'runOnEmpty',\n}\n\nexport interface ISearchConfigurationProperties {\n\texclude: glob.IExpression;\n\tuseRipgrep: boolean;\n\t/**\n\t * Use ignore file for file search.\n\t */\n\tuseIgnoreFiles: boolean;\n\tuseGlobalIgnoreFiles: boolean;\n\tuseParentIgnoreFiles: boolean;\n\tfollowSymlinks: boolean;\n\tsmartCase: boolean;\n\tglobalFindClipboard: boolean;\n\tlocation: 'sidebar' | 'panel';\n\tuseReplacePreview: boolean;\n\tshowLineNumbers: boolean;\n\tusePCRE2: boolean;\n\tactionsPosition: 'auto' | 'right';\n\tmaintainFileSearchCache: boolean;\n\tmaxResults: number | null;\n\tcollapseResults: 'auto' | 'alwaysCollapse' | 'alwaysExpand';\n\tsearchOnType: boolean;\n\tseedOnFocus: boolean;\n\tseedWithNearestWord: boolean;\n\tsearchOnTypeDebouncePeriod: number;\n\tmode: 'view' | 'reuseEditor' | 'newEditor';\n\tsearchEditor: {\n\t\tdoubleClickBehaviour: 'selectWord' | 'goToLocation' | 'openLocationToSide';\n\t\tsingleClickBehaviour: 'default' | 'peekDefinition';\n\t\treusePriorSearchConfiguration: boolean;\n\t\tdefaultNumberOfContextLines: number | null;\n\t\tfocusResultsOnSearch: boolean;\n\t\texperimental: {};\n\t};\n\tsortOrder: SearchSortOrder;\n\tdecorations: {\n\t\tcolors: boolean;\n\t\tbadges: boolean;\n\t};\n\tquickAccess: {\n\t\tpreserveInput: boolean;\n\t};\n\tdefaultViewMode: ViewMode;\n\texperimental: {\n\t\tclosedNotebookRichContentResults: boolean;\n\t};\n\tsearchView: {\n\t\tsemanticSearchBehavior: string;\n\t\tkeywordSuggestions: boolean;\n\t};\n}\n\nexport interface ISearchConfiguration extends IFilesConfiguration {\n\tsearch: ISearchConfigurationProperties;\n\teditor: {\n\t\twordSeparators: string;\n\t};\n}\n\nexport function getExcludes(configuration: ISearchConfiguration, includeSearchExcludes = true): glob.IExpression | undefined {\n\tconst fileExcludes = configuration && configuration.files && configuration.files.exclude;\n\tconst searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;\n\n\tif (!fileExcludes && !searchExcludes) {\n\t\treturn undefined;\n\t}\n\n\tif (!fileExcludes || !searchExcludes) {\n\t\treturn fileExcludes || searchExcludes || undefined;\n\t}\n\n\tlet allExcludes: glob.IExpression = Object.create(null);\n\t// clone the config as it could be frozen\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(searchExcludes), true);\n\n\treturn allExcludes;\n}\n\nexport function pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (queryProps.includePattern && glob.match(queryProps.includePattern, fsPath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\t\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {\n\t\t\t\tconst searchPath = fq.folder.fsPath;\n\t\t\t\tif (extpath.isEqualOrParent(fsPath, searchPath)) {\n\t\t\t\t\tconst relPath = paths.relative(searchPath, fsPath);\n\t\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, relPath);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport enum SearchErrorCode {\n\tunknownEncoding = 1,\n\tregexParseError,\n\tglobParseError,\n\tinvalidLiteral,\n\trgProcessError,\n\tother,\n\tcanceled\n}\n\nexport class SearchError extends Error {\n\tconstructor(message: string, readonly code?: SearchErrorCode) {\n\t\tsuper(message);\n\t}\n}\n\nexport function deserializeSearchError(error: Error): SearchError {\n\tconst errorMsg = error.message;\n\n\tif (isCancellationError(error)) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.canceled);\n\t}\n\n\ttry {\n\t\tconst details = JSON.parse(errorMsg);\n\t\treturn new SearchError(details.message, details.code);\n\t} catch (e) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.other);\n\t}\n}\n\nexport function serializeSearchError(searchError: SearchError): Error {\n\tconst details = { message: searchError.message, code: searchError.code };\n\treturn new Error(JSON.stringify(details));\n}\nexport interface ITelemetryEvent {\n\teventName: string;\n\tdata: ITelemetryData;\n}\n\nexport interface IRawSearchService {\n\tfileSearch(search: IRawFileQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\ttextSearch(search: IRawTextQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\nexport interface IRawFileMatch {\n\tbase?: string;\n\t/**\n\t * The path of the file relative to the containing `base` folder.\n\t * This path is exactly as it appears on the filesystem.\n\t */\n\trelativePath: string;\n\t/**\n\t * This path is transformed for search purposes. For example, this could be\n\t * the `relativePath` with the workspace folder name prepended. This way the\n\t * search algorithm would also match against the name of the containing folder.\n\t *\n\t * If not given, the search algorithm should use `relativePath`.\n\t */\n\tsearchPath: string | undefined;\n}\n\nexport interface ISearchEngine<T> {\n\tsearch: (onResult: (matches: T) => void, onProgress: (progress: IProgressMessage) => void, done: (error: Error | null, complete: ISearchEngineSuccess) => void) => void;\n\tcancel: () => void;\n}\n\nexport interface ISerializedSearchSuccess {\n\ttype: 'success';\n\tlimitHit: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchEngineSuccess {\n\tlimitHit: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats: ISearchEngineStats;\n}\n\nexport interface ISerializedSearchError {\n\ttype: 'error';\n\terror: {\n\t\tmessage: string;\n\t\tstack: string;\n\t};\n}\n\nexport type ISerializedSearchComplete = ISerializedSearchSuccess | ISerializedSearchError;\n\nexport function isSerializedSearchComplete(arg: ISerializedSearchProgressItem | ISerializedSearchComplete): arg is ISerializedSearchComplete {\n\t// eslint-disable-next-line local/code-no-any-casts\n\tif ((arg as any).type === 'error') {\n\t\treturn true;\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t} else if ((arg as any).type === 'success') {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport function isSerializedSearchSuccess(arg: ISerializedSearchComplete): arg is ISerializedSearchSuccess {\n\treturn arg.type === 'success';\n}\n\nexport function isSerializedFileMatch(arg: ISerializedSearchProgressItem): arg is ISerializedFileMatch {\n\treturn !!(<ISerializedFileMatch>arg).path;\n}\n\nexport function isFilePatternMatch(candidate: IRawFileMatch, filePatternToUse: string, fuzzy = true): boolean {\n\tconst pathToMatch = candidate.searchPath ? candidate.searchPath : candidate.relativePath;\n\treturn fuzzy ?\n\t\tfuzzyContains(pathToMatch, filePatternToUse) :\n\t\tglob.match(filePatternToUse, pathToMatch);\n}\n\nexport interface ISerializedFileMatch {\n\tpath: string;\n\tresults?: ITextSearchResult[];\n\tnumMatches?: number;\n}\n\n// Type of the possible values for progress calls from the engine\nexport type ISerializedSearchProgressItem = ISerializedFileMatch | ISerializedFileMatch[] | IProgressMessage;\nexport type IFileSearchProgressItem = IRawFileMatch | IRawFileMatch[] | IProgressMessage;\n\n\nexport class SerializableFileMatch implements ISerializedFileMatch {\n\tpath: string;\n\tresults: ITextSearchMatch[];\n\n\tconstructor(path: string) {\n\t\tthis.path = path;\n\t\tthis.results = [];\n\t}\n\n\taddMatch(match: ITextSearchMatch): void {\n\t\tthis.results.push(match);\n\t}\n\n\tserialize(): ISerializedFileMatch {\n\t\treturn {\n\t\t\tpath: this.path,\n\t\t\tresults: this.results,\n\t\t\tnumMatches: this.results.length\n\t\t};\n\t}\n}\n\n/**\n *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns\n */\nexport function resolvePatternsForProvider(globalPattern: glob.IExpression | undefined, folderPattern: glob.IExpression | undefined): string[] {\n\tconst merged = {\n\t\t...(globalPattern || {}),\n\t\t...(folderPattern || {})\n\t};\n\n\treturn Object.keys(merged)\n\t\t.filter(key => {\n\t\t\tconst value = merged[key];\n\t\t\treturn typeof value === 'boolean' && value;\n\t\t});\n}\n\nexport class QueryGlobTester {\n\n\tprivate _excludeExpression: glob.IExpression[]; // TODO: evaluate globs based on baseURI of pattern\n\tprivate _parsedExcludeExpression: glob.ParsedExpression[];\n\n\tprivate _parsedIncludeExpression: glob.ParsedExpression | null = null;\n\n\tconstructor(config: ISearchQuery, folderQuery: IFolderQuery) {\n\t\t// todo: try to incorporate folderQuery.excludePattern.folder if available\n\t\tthis._excludeExpression = folderQuery.excludePattern?.map(excludePattern => {\n\t\t\treturn {\n\t\t\t\t...(config.excludePattern || {}),\n\t\t\t\t...(excludePattern.pattern || {})\n\t\t\t} satisfies glob.IExpression;\n\t\t}) ?? [];\n\n\t\tif (this._excludeExpression.length === 0) {\n\t\t\t// even if there are no folderQueries, we want to observe  the global excludes\n\t\t\tthis._excludeExpression = [config.excludePattern || {}];\n\t\t}\n\n\t\tthis._parsedExcludeExpression = this._excludeExpression.map(e => glob.parse(e));\n\n\t\t// Empty includeExpression means include nothing, so no {} shortcuts\n\t\tlet includeExpression: glob.IExpression | undefined = config.includePattern;\n\t\tif (folderQuery.includePattern) {\n\t\t\tif (includeExpression) {\n\t\t\t\tincludeExpression = {\n\t\t\t\t\t...includeExpression,\n\t\t\t\t\t...folderQuery.includePattern\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tincludeExpression = folderQuery.includePattern;\n\t\t\t}\n\t\t}\n\n\t\tif (includeExpression) {\n\t\t\tthis._parsedIncludeExpression = glob.parse(includeExpression);\n\t\t}\n\t}\n\n\tprivate _evalParsedExcludeExpression(testPath: string, basename: string | undefined, hasSibling?: (name: string) => boolean): string | null {\n\t\t// todo: less hacky way of evaluating sync vs async sibling clauses\n\t\tlet result: string | null = null;\n\n\t\tfor (const folderExclude of this._parsedExcludeExpression) {\n\n\t\t\t// find first non-null result\n\t\t\tconst evaluation = folderExclude(testPath, basename, hasSibling);\n\n\t\t\tif (typeof evaluation === 'string') {\n\t\t\t\tresult = evaluation;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\n\tmatchesExcludesSync(testPath: string, basename?: string, hasSibling?: (name: string) => boolean): boolean {\n\t\tif (this._parsedExcludeExpression && this._evalParsedExcludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Guaranteed sync - siblingsFn should not return a promise.\n\t */\n\tincludedInQuerySync(testPath: string, basename?: string, hasSibling?: (name: string) => boolean): boolean {\n\t\tif (this._parsedExcludeExpression && this._evalParsedExcludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Evaluating the exclude expression is only async if it includes sibling clauses. As an optimization, avoid doing anything with Promises\n\t * unless the expression is async.\n\t */\n\tincludedInQuery(testPath: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): Promise<boolean> | boolean {\n\n\t\tconst isIncluded = () => {\n\t\t\treturn this._parsedIncludeExpression ?\n\t\t\t\t!!(this._parsedIncludeExpression(testPath, basename, hasSibling)) :\n\t\t\t\ttrue;\n\t\t};\n\n\t\treturn Promise.all(this._parsedExcludeExpression.map(e => {\n\t\t\tconst excluded = e(testPath, basename, hasSibling);\n\t\t\tif (isThenable(excluded)) {\n\t\t\t\treturn excluded.then(excluded => {\n\t\t\t\t\tif (excluded) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn isIncluded();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn isIncluded();\n\n\t\t})).then(e => e.some(e => !!e));\n\n\n\t}\n\n\thasSiblingExcludeClauses(): boolean {\n\t\treturn this._excludeExpression.reduce((prev, curr) => hasSiblingClauses(curr) || prev, false);\n\t}\n}\n\nfunction hasSiblingClauses(pattern: glob.IExpression): boolean {\n\tfor (const key in pattern) {\n\t\tif (typeof pattern[key] !== 'boolean') {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function excludeToGlobPattern(excludesForFolder: { baseUri?: URI | undefined; patterns: string[] }[]): GlobPattern[] {\n\treturn excludesForFolder.flatMap(exclude => exclude.patterns.map(pattern => {\n\t\treturn exclude.baseUri ?\n\t\t\t{\n\t\t\t\tbaseUri: exclude.baseUri,\n\t\t\t\tpattern: pattern\n\t\t\t} : pattern;\n\t}));\n}\n\nexport const DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS = {\n\tmatchLines: 100,\n\tcharsPerLine: 10000\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mapArrayOrNot } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport * as glob from '../../../../base/common/glob.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport * as objects from '../../../../base/common/objects.js';\nimport * as extpath from '../../../../base/common/extpath.js';\nimport { fuzzyContains, getNLines } from '../../../../base/common/strings.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { IFilesConfiguration } from '../../../../platform/files/common/files.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ITelemetryData } from '../../../../platform/telemetry/common/telemetry.js';\nimport { Event } from '../../../../base/common/event.js';\nimport * as paths from '../../../../base/common/path.js';\nimport { isCancellationError } from '../../../../base/common/errors.js';\nimport { AISearchKeyword, GlobPattern, TextSearchCompleteMessageType } from './searchExtTypes.js';\nimport { isThenable } from '../../../../base/common/async.js';\nimport { ResourceSet } from '../../../../base/common/map.js';\n\nexport { TextSearchCompleteMessageType };\n\nexport const VIEWLET_ID = 'workbench.view.search';\nexport const PANEL_ID = 'workbench.panel.search';\nexport const VIEW_ID = 'workbench.view.search';\nexport const SEARCH_RESULT_LANGUAGE_ID = 'search-result';\n\nexport const SEARCH_EXCLUDE_CONFIG = 'search.exclude';\nexport const DEFAULT_MAX_SEARCH_RESULTS = 20000;\n\n// Warning: this pattern is used in the search editor to detect offsets. If you\n// change this, also change the search-result built-in extension\nconst SEARCH_ELIDED_PREFIX = '⟪ ';\nconst SEARCH_ELIDED_SUFFIX = ' characters skipped ⟫';\nconst SEARCH_ELIDED_MIN_LEN = (SEARCH_ELIDED_PREFIX.length + SEARCH_ELIDED_SUFFIX.length + 5) * 2;\n\nexport const ISearchService = createDecorator<ISearchService>('searchService');\n\n/**\n * A service that enables to search for files or with in files.\n */\nexport interface ISearchService {\n\treadonly _serviceBrand: undefined;\n\ttextSearch(query: ITextQuery, token?: CancellationToken, onProgress?: (result: ISearchProgressItem) => void): Promise<ISearchComplete>;\n\taiTextSearch(query: IAITextQuery, token?: CancellationToken, onProgress?: (result: ISearchProgressItem) => void): Promise<ISearchComplete>;\n\tgetAIName(): Promise<string | undefined>;\n\ttextSearchSplitSyncAsync(query: ITextQuery, token?: CancellationToken | undefined, onProgress?: ((result: ISearchProgressItem) => void) | undefined, notebookFilesToIgnore?: ResourceSet, asyncNotebookFilesToIgnore?: Promise<ResourceSet>): { syncResults: ISearchComplete; asyncResults: Promise<ISearchComplete> };\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete>;\n\tschemeHasFileSearchProvider(scheme: string): boolean;\n\tclearCache(cacheKey: string): Promise<void>;\n\tregisterSearchResultProvider(scheme: string, type: SearchProviderType, provider: ISearchResultProvider): IDisposable;\n}\n\n/**\n * TODO@roblou - split text from file search entirely, or share code in a more natural way.\n */\nexport const enum SearchProviderType {\n\tfile,\n\ttext,\n\taiText\n}\n\nexport interface ISearchResultProvider {\n\tgetAIName(): Promise<string | undefined>;\n\ttextSearch(query: ITextQuery, onProgress?: (p: ISearchProgressItem) => void, token?: CancellationToken): Promise<ISearchComplete>;\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\n\nexport interface ExcludeGlobPattern<U extends UriComponents = URI> {\n\tfolder?: U;\n\tpattern: glob.IExpression;\n}\n\nexport interface IFolderQuery<U extends UriComponents = URI> {\n\tfolder: U;\n\tfolderName?: string;\n\texcludePattern?: ExcludeGlobPattern<U>[];\n\tincludePattern?: glob.IExpression;\n\tfileEncoding?: string;\n\tdisregardIgnoreFiles?: boolean;\n\tdisregardGlobalIgnoreFiles?: boolean;\n\tdisregardParentIgnoreFiles?: boolean;\n\tignoreSymlinks?: boolean;\n}\n\nexport interface ICommonQueryProps<U extends UriComponents> {\n\t/** For telemetry - indicates what is triggering the source */\n\t_reason?: string;\n\n\tfolderQueries: IFolderQuery<U>[];\n\t// The include pattern for files that gets passed into ripgrep.\n\t// Note that this will override any ignore files if applicable.\n\tincludePattern?: glob.IExpression;\n\texcludePattern?: glob.IExpression;\n\textraFileResources?: U[];\n\n\tonlyOpenEditors?: boolean;\n\n\tmaxResults?: number;\n\tusingSearchPaths?: boolean;\n\tonlyFileScheme?: boolean;\n}\n\nexport interface IFileQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.File;\n\tfilePattern?: string;\n\n\t// when walking through the tree to find the result, don't use the filePattern to fuzzy match.\n\t// Instead, should use glob matching.\n\tshouldGlobMatchFilePattern?: boolean;\n\n\t/**\n\t * If true no results will be returned. Instead `limitHit` will indicate if at least one result exists or not.\n\t * Currently does not work with queries including a 'siblings clause'.\n\t */\n\texists?: boolean;\n\tsortByScore?: boolean;\n\tcacheKey?: string;\n}\n\nexport interface ITextQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.Text;\n\tcontentPattern: IPatternInfo;\n\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tmaxFileSize?: number;\n\tusePCRE2?: boolean;\n\tsurroundingContext?: number;\n\n\tuserDisabledExcludesAndIgnoreFiles?: boolean;\n}\n\nexport interface IAITextQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.aiText;\n\tcontentPattern: string;\n\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tmaxFileSize?: number;\n\tsurroundingContext?: number;\n\n\tuserDisabledExcludesAndIgnoreFiles?: boolean;\n}\n\nexport type IFileQuery = IFileQueryProps<URI>;\nexport type IRawFileQuery = IFileQueryProps<UriComponents>;\nexport type ITextQuery = ITextQueryProps<URI>;\nexport type IRawTextQuery = ITextQueryProps<UriComponents>;\nexport type IAITextQuery = IAITextQueryProps<URI>;\nexport type IRawAITextQuery = IAITextQueryProps<UriComponents>;\n\nexport type IRawQuery = IRawTextQuery | IRawFileQuery | IRawAITextQuery;\nexport type ISearchQuery = ITextQuery | IFileQuery | IAITextQuery;\nexport type ITextSearchQuery = ITextQuery | IAITextQuery;\n\nexport const enum QueryType {\n\tFile = 1,\n\tText = 2,\n\taiText = 3\n}\n\n/* __GDPR__FRAGMENT__\n\t\"IPatternInfo\" : {\n\t\t\"isRegExp\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isWordMatch\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"wordSeparators\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"isMultiline\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isCaseSensitive\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isSmartCase\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n\t}\n*/\nexport interface IPatternInfo {\n\tpattern: string;\n\tisRegExp?: boolean;\n\tisWordMatch?: boolean;\n\twordSeparators?: string;\n\tisMultiline?: boolean;\n\tisUnicode?: boolean;\n\tisCaseSensitive?: boolean;\n\tnotebookInfo?: INotebookPatternInfo;\n}\n\nexport interface INotebookPatternInfo {\n\tisInNotebookMarkdownInput?: boolean;\n\tisInNotebookMarkdownPreview?: boolean;\n\tisInNotebookCellInput?: boolean;\n\tisInNotebookCellOutput?: boolean;\n}\n\nexport interface IExtendedExtensionSearchOptions {\n\tusePCRE2?: boolean;\n}\n\nexport interface IFileMatch<U extends UriComponents = URI> {\n\tresource: U;\n\tresults?: ITextSearchResult<U>[];\n}\n\nexport type IRawFileMatch2 = IFileMatch<UriComponents>;\n\nexport interface ITextSearchPreviewOptions {\n\tmatchLines: number;\n\tcharsPerLine: number;\n}\n\nexport interface ISearchRange {\n\treadonly startLineNumber: number;\n\treadonly startColumn: number;\n\treadonly endLineNumber: number;\n\treadonly endColumn: number;\n}\n\nexport interface ITextSearchMatch<U extends UriComponents = URI> {\n\turi?: U;\n\trangeLocations: SearchRangeSetPairing[];\n\tpreviewText: string;\n\twebviewIndex?: number;\n\tcellFragment?: string;\n}\n\nexport interface ITextSearchContext<U extends UriComponents = URI> {\n\turi?: U;\n\ttext: string;\n\tlineNumber: number;\n}\n\nexport type ITextSearchResult<U extends UriComponents = URI> = ITextSearchMatch<U> | ITextSearchContext<U>;\n\nexport function resultIsMatch(result: ITextSearchResult): result is ITextSearchMatch {\n\treturn !!(<ITextSearchMatch>result).rangeLocations && !!(<ITextSearchMatch>result).previewText;\n}\n\nexport interface IProgressMessage {\n\tmessage: string;\n}\n\nexport type ISearchProgressItem = IFileMatch | IProgressMessage | AISearchKeyword;\n\nexport function isFileMatch(p: ISearchProgressItem): p is IFileMatch {\n\treturn !!(<IFileMatch>p).resource;\n}\n\nexport function isAIKeyword(p: ISearchProgressItem): p is AISearchKeyword {\n\treturn !!(<AISearchKeyword>p).keyword;\n}\n\nexport function isProgressMessage(p: ISearchProgressItem | ISerializedSearchProgressItem): p is IProgressMessage {\n\treturn !!(p as IProgressMessage).message;\n}\n\nexport interface ITextSearchCompleteMessage {\n\ttext: string;\n\ttype: TextSearchCompleteMessageType;\n\ttrusted?: boolean;\n}\n\nexport interface ISearchCompleteStats {\n\tlimitHit?: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchComplete extends ISearchCompleteStats {\n\tresults: IFileMatch[];\n\texit?: SearchCompletionExitCode;\n\taiKeywords?: AISearchKeyword[];\n}\n\nexport const enum SearchCompletionExitCode {\n\tNormal,\n\tNewSearchStarted\n}\n\nexport interface ITextSearchStats {\n\ttype: 'textSearchProvider' | 'searchProcess' | 'aiTextSearchProvider';\n}\n\nexport interface IFileSearchStats {\n\tfromCache: boolean;\n\tdetailStats: ISearchEngineStats | ICachedSearchStats | IFileSearchProviderStats;\n\n\tresultCount: number;\n\ttype: 'fileSearchProvider' | 'searchProcess';\n\tsortingTime?: number;\n}\n\nexport interface ICachedSearchStats {\n\tcacheWasResolved: boolean;\n\tcacheLookupTime: number;\n\tcacheFilterTime: number;\n\tcacheEntryCount: number;\n}\n\nexport interface ISearchEngineStats {\n\tfileWalkTime: number;\n\tdirectoriesWalked: number;\n\tfilesWalked: number;\n\tcmdTime: number;\n\tcmdResultCount?: number;\n}\n\nexport interface IFileSearchProviderStats {\n\tproviderTime: number;\n\tpostProcessTime: number;\n}\n\nexport class FileMatch implements IFileMatch {\n\tresults: ITextSearchResult[] = [];\n\tconstructor(public resource: URI) {\n\t\t// empty\n\t}\n}\n\nexport interface SearchRangeSetPairing {\n\tsource: ISearchRange;\n\tpreview: ISearchRange;\n}\n\nexport class TextSearchMatch implements ITextSearchMatch {\n\trangeLocations: SearchRangeSetPairing[] = [];\n\tpreviewText: string;\n\twebviewIndex?: number;\n\n\tconstructor(text: string, ranges: ISearchRange | ISearchRange[], previewOptions?: ITextSearchPreviewOptions, webviewIndex?: number) {\n\t\tthis.webviewIndex = webviewIndex;\n\n\t\t// Trim preview if this is one match and a single-line match with a preview requested.\n\t\t// Otherwise send the full text, like for replace or for showing multiple previews.\n\t\t// TODO this is fishy.\n\t\tconst rangesArr = Array.isArray(ranges) ? ranges : [ranges];\n\n\t\tif (previewOptions && previewOptions.matchLines === 1 && isSingleLineRangeList(rangesArr)) {\n\t\t\t// 1 line preview requested\n\t\t\ttext = getNLines(text, previewOptions.matchLines);\n\n\t\t\tlet result = '';\n\t\t\tlet shift = 0;\n\t\t\tlet lastEnd = 0;\n\t\t\tconst leadingChars = Math.floor(previewOptions.charsPerLine / 5);\n\t\t\tfor (const range of rangesArr) {\n\t\t\t\tconst previewStart = Math.max(range.startColumn - leadingChars, 0);\n\t\t\t\tconst previewEnd = range.startColumn + previewOptions.charsPerLine;\n\t\t\t\tif (previewStart > lastEnd + leadingChars + SEARCH_ELIDED_MIN_LEN) {\n\t\t\t\t\tconst elision = SEARCH_ELIDED_PREFIX + (previewStart - lastEnd) + SEARCH_ELIDED_SUFFIX;\n\t\t\t\t\tresult += elision + text.slice(previewStart, previewEnd);\n\t\t\t\t\tshift += previewStart - (lastEnd + elision.length);\n\t\t\t\t} else {\n\t\t\t\t\tresult += text.slice(lastEnd, previewEnd);\n\t\t\t\t}\n\n\t\t\t\tlastEnd = previewEnd;\n\t\t\t\tthis.rangeLocations.push({\n\t\t\t\t\tsource: range,\n\t\t\t\t\tpreview: new OneLineRange(0, range.startColumn - shift, range.endColumn - shift)\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\tthis.previewText = result;\n\t\t} else {\n\t\t\tconst firstMatchLine = Array.isArray(ranges) ? ranges[0].startLineNumber : ranges.startLineNumber;\n\n\t\t\tconst rangeLocs = mapArrayOrNot(ranges, r => ({\n\t\t\t\tpreview: new SearchRange(r.startLineNumber - firstMatchLine, r.startColumn, r.endLineNumber - firstMatchLine, r.endColumn),\n\t\t\t\tsource: r\n\t\t\t}));\n\n\t\t\tthis.rangeLocations = Array.isArray(rangeLocs) ? rangeLocs : [rangeLocs];\n\t\t\tthis.previewText = text;\n\t\t}\n\t}\n}\n\nfunction isSingleLineRangeList(ranges: ISearchRange[]): boolean {\n\tconst line = ranges[0].startLineNumber;\n\tfor (const r of ranges) {\n\t\tif (r.startLineNumber !== line || r.endLineNumber !== line) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport class SearchRange implements ISearchRange {\n\tstartLineNumber: number;\n\tstartColumn: number;\n\tendLineNumber: number;\n\tendColumn: number;\n\n\tconstructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number) {\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.startColumn = startColumn;\n\t\tthis.endLineNumber = endLineNumber;\n\t\tthis.endColumn = endColumn;\n\t}\n}\n\nexport class OneLineRange extends SearchRange {\n\tconstructor(lineNumber: number, startColumn: number, endColumn: number) {\n\t\tsuper(lineNumber, startColumn, lineNumber, endColumn);\n\t}\n}\n\nexport const enum ViewMode {\n\tList = 'list',\n\tTree = 'tree'\n}\n\nexport const enum SearchSortOrder {\n\tDefault = 'default',\n\tFileNames = 'fileNames',\n\tType = 'type',\n\tModified = 'modified',\n\tCountDescending = 'countDescending',\n\tCountAscending = 'countAscending'\n}\n\nexport const enum SemanticSearchBehavior {\n\tAuto = 'auto',\n\tManual = 'manual',\n\tRunOnEmpty = 'runOnEmpty',\n}\n\nexport interface ISearchConfigurationProperties {\n\texclude: glob.IExpression;\n\tuseRipgrep: boolean;\n\t/**\n\t * Use ignore file for file search.\n\t */\n\tuseIgnoreFiles: boolean;\n\tuseGlobalIgnoreFiles: boolean;\n\tuseParentIgnoreFiles: boolean;\n\tfollowSymlinks: boolean;\n\tsmartCase: boolean;\n\tglobalFindClipboard: boolean;\n\tlocation: 'sidebar' | 'panel';\n\tuseReplacePreview: boolean;\n\tshowLineNumbers: boolean;\n\tusePCRE2: boolean;\n\tactionsPosition: 'auto' | 'right';\n\tmaintainFileSearchCache: boolean;\n\tmaxResults: number | null;\n\tcollapseResults: 'auto' | 'alwaysCollapse' | 'alwaysExpand';\n\tsearchOnType: boolean;\n\tseedOnFocus: boolean;\n\tseedWithNearestWord: boolean;\n\tsearchOnTypeDebouncePeriod: number;\n\tmode: 'view' | 'reuseEditor' | 'newEditor';\n\tsearchEditor: {\n\t\tdoubleClickBehaviour: 'selectWord' | 'goToLocation' | 'openLocationToSide';\n\t\tsingleClickBehaviour: 'default' | 'peekDefinition';\n\t\treusePriorSearchConfiguration: boolean;\n\t\tdefaultNumberOfContextLines: number | null;\n\t\tfocusResultsOnSearch: boolean;\n\t\texperimental: {};\n\t};\n\tsortOrder: SearchSortOrder;\n\tdecorations: {\n\t\tcolors: boolean;\n\t\tbadges: boolean;\n\t};\n\tquickAccess: {\n\t\tpreserveInput: boolean;\n\t};\n\tdefaultViewMode: ViewMode;\n\texperimental: {\n\t\tclosedNotebookRichContentResults: boolean;\n\t};\n\tsearchView: {\n\t\tsemanticSearchBehavior: string;\n\t\tkeywordSuggestions: boolean;\n\t};\n}\n\nexport interface ISearchConfiguration extends IFilesConfiguration {\n\tsearch: ISearchConfigurationProperties;\n\teditor: {\n\t\twordSeparators: string;\n\t};\n}\n\nexport function getExcludes(configuration: ISearchConfiguration, includeSearchExcludes = true): glob.IExpression | undefined {\n\tconst fileExcludes = configuration && configuration.files && configuration.files.exclude;\n\tconst searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;\n\n\tif (!fileExcludes && !searchExcludes) {\n\t\treturn undefined;\n\t}\n\n\tif (!fileExcludes || !searchExcludes) {\n\t\treturn fileExcludes || searchExcludes || undefined;\n\t}\n\n\tlet allExcludes: glob.IExpression = Object.create(null);\n\t// clone the config as it could be frozen\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(searchExcludes), true);\n\n\treturn allExcludes;\n}\n\nexport function pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (queryProps.includePattern && glob.match(queryProps.includePattern, fsPath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\t\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {\n\t\t\t\tconst searchPath = fq.folder.fsPath;\n\t\t\t\tif (extpath.isEqualOrParent(fsPath, searchPath)) {\n\t\t\t\t\tconst relPath = paths.relative(searchPath, fsPath);\n\t\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, relPath);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport enum SearchErrorCode {\n\tunknownEncoding = 1,\n\tregexParseError,\n\tglobParseError,\n\tinvalidLiteral,\n\trgProcessError,\n\tother,\n\tcanceled\n}\n\nexport class SearchError extends Error {\n\tconstructor(message: string, readonly code?: SearchErrorCode) {\n\t\tsuper(message);\n\t}\n}\n\nexport function deserializeSearchError(error: Error): SearchError {\n\tconst errorMsg = error.message;\n\n\tif (isCancellationError(error)) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.canceled);\n\t}\n\n\ttry {\n\t\tconst details = JSON.parse(errorMsg);\n\t\treturn new SearchError(details.message, details.code);\n\t} catch (e) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.other);\n\t}\n}\n\nexport function serializeSearchError(searchError: SearchError): Error {\n\tconst details = { message: searchError.message, code: searchError.code };\n\treturn new Error(JSON.stringify(details));\n}\nexport interface ITelemetryEvent {\n\teventName: string;\n\tdata: ITelemetryData;\n}\n\nexport interface IRawSearchService {\n\tfileSearch(search: IRawFileQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\ttextSearch(search: IRawTextQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\nexport interface IRawFileMatch {\n\tbase?: string;\n\t/**\n\t * The path of the file relative to the containing `base` folder.\n\t * This path is exactly as it appears on the filesystem.\n\t */\n\trelativePath: string;\n\t/**\n\t * This path is transformed for search purposes. For example, this could be\n\t * the `relativePath` with the workspace folder name prepended. This way the\n\t * search algorithm would also match against the name of the containing folder.\n\t *\n\t * If not given, the search algorithm should use `relativePath`.\n\t */\n\tsearchPath: string | undefined;\n}\n\nexport interface ISearchEngine<T> {\n\tsearch: (onResult: (matches: T) => void, onProgress: (progress: IProgressMessage) => void, done: (error: Error | null, complete: ISearchEngineSuccess) => void) => void;\n\tcancel: () => void;\n}\n\nexport interface ISerializedSearchSuccess {\n\ttype: 'success';\n\tlimitHit: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchEngineSuccess {\n\tlimitHit: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats: ISearchEngineStats;\n}\n\nexport interface ISerializedSearchError {\n\ttype: 'error';\n\terror: {\n\t\tmessage: string;\n\t\tstack: string;\n\t};\n}\n\nexport type ISerializedSearchComplete = ISerializedSearchSuccess | ISerializedSearchError;\n\nexport function isSerializedSearchComplete(arg: ISerializedSearchProgressItem | ISerializedSearchComplete): arg is ISerializedSearchComplete {\n\t// eslint-disable-next-line local/code-no-any-casts\n\tif ((arg as any).type === 'error') {\n\t\treturn true;\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t} else if ((arg as any).type === 'success') {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport function isSerializedSearchSuccess(arg: ISerializedSearchComplete): arg is ISerializedSearchSuccess {\n\treturn arg.type === 'success';\n}\n\nexport function isSerializedFileMatch(arg: ISerializedSearchProgressItem): arg is ISerializedFileMatch {\n\treturn !!(<ISerializedFileMatch>arg).path;\n}\n\nexport function isFilePatternMatch(candidate: IRawFileMatch, filePatternToUse: string, fuzzy = true): boolean {\n\tconst pathToMatch = candidate.searchPath ? candidate.searchPath : candidate.relativePath;\n\treturn fuzzy ?\n\t\tfuzzyContains(pathToMatch, filePatternToUse) :\n\t\tglob.match(filePatternToUse, pathToMatch);\n}\n\nexport interface ISerializedFileMatch {\n\tpath: string;\n\tresults?: ITextSearchResult[];\n\tnumMatches?: number;\n}\n\n// Type of the possible values for progress calls from the engine\nexport type ISerializedSearchProgressItem = ISerializedFileMatch | ISerializedFileMatch[] | IProgressMessage;\nexport type IFileSearchProgressItem = IRawFileMatch | IRawFileMatch[] | IProgressMessage;\n\n\nexport class SerializableFileMatch implements ISerializedFileMatch {\n\tpath: string;\n\tresults: ITextSearchMatch[];\n\n\tconstructor(path: string) {\n\t\tthis.path = path;\n\t\tthis.results = [];\n\t}\n\n\taddMatch(match: ITextSearchMatch): void {\n\t\tthis.results.push(match);\n\t}\n\n\tserialize(): ISerializedFileMatch {\n\t\treturn {\n\t\t\tpath: this.path,\n\t\t\tresults: this.results,\n\t\t\tnumMatches: this.results.length\n\t\t};\n\t}\n}\n\n/**\n *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns\n */\nexport function resolvePatternsForProvider(globalPattern: glob.IExpression | undefined, folderPattern: glob.IExpression | undefined): string[] {\n\tconst merged = {\n\t\t...(globalPattern || {}),\n\t\t...(folderPattern || {})\n\t};\n\n\treturn Object.keys(merged)\n\t\t.filter(key => {\n\t\t\tconst value = merged[key];\n\t\t\treturn typeof value === 'boolean' && value;\n\t\t});\n}\n\nexport class QueryGlobTester {\n\n\tprivate _excludeExpression: glob.IExpression[]; // TODO: evaluate globs based on baseURI of pattern\n\tprivate _parsedExcludeExpression: glob.ParsedExpression[];\n\n\tprivate _parsedIncludeExpression: glob.ParsedExpression | null = null;\n\n\tconstructor(config: ISearchQuery, folderQuery: IFolderQuery) {\n\t\t// todo: try to incorporate folderQuery.excludePattern.folder if available\n\t\tthis._excludeExpression = folderQuery.excludePattern?.map(excludePattern => {\n\t\t\treturn {\n\t\t\t\t...(config.excludePattern || {}),\n\t\t\t\t...(excludePattern.pattern || {})\n\t\t\t} satisfies glob.IExpression;\n\t\t}) ?? [];\n\n\t\tif (this._excludeExpression.length === 0) {\n\t\t\t// even if there are no folderQueries, we want to observe  the global excludes\n\t\t\tthis._excludeExpression = [config.excludePattern || {}];\n\t\t}\n\n\t\tthis._parsedExcludeExpression = this._excludeExpression.map(e => glob.parse(e));\n\n\t\t// Empty includeExpression means include nothing, so no {} shortcuts\n\t\tlet includeExpression: glob.IExpression | undefined = config.includePattern;\n\t\tif (folderQuery.includePattern) {\n\t\t\tif (includeExpression) {\n\t\t\t\tincludeExpression = {\n\t\t\t\t\t...includeExpression,\n\t\t\t\t\t...folderQuery.includePattern\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tincludeExpression = folderQuery.includePattern;\n\t\t\t}\n\t\t}\n\n\t\tif (includeExpression) {\n\t\t\tthis._parsedIncludeExpression = glob.parse(includeExpression);\n\t\t}\n\t}\n\n\tprivate _evalParsedExcludeExpression(testPath: string, basename: string | undefined, hasSibling?: (name: string) => boolean): string | null {\n\t\t// todo: less hacky way of evaluating sync vs async sibling clauses\n\t\tlet result: string | null = null;\n\n\t\tfor (const folderExclude of this._parsedExcludeExpression) {\n\n\t\t\t// find first non-null result\n\t\t\tconst evaluation = folderExclude(testPath, basename, hasSibling);\n\n\t\t\tif (typeof evaluation === 'string') {\n\t\t\t\tresult = evaluation;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\n\tmatchesExcludesSync(testPath: string, basename?: string, hasSibling?: (name: string) => boolean): boolean {\n\t\tif (this._parsedExcludeExpression && this._evalParsedExcludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Guaranteed sync - siblingsFn should not return a promise.\n\t */\n\tincludedInQuerySync(testPath: string, basename?: string, hasSibling?: (name: string) => boolean): boolean {\n\t\tif (this._parsedExcludeExpression && this._evalParsedExcludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Evaluating the exclude expression is only async if it includes sibling clauses. As an optimization, avoid doing anything with Promises\n\t * unless the expression is async.\n\t */\n\tincludedInQuery(testPath: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): Promise<boolean> | boolean {\n\n\t\tconst isIncluded = () => {\n\t\t\treturn this._parsedIncludeExpression ?\n\t\t\t\t!!(this._parsedIncludeExpression(testPath, basename, hasSibling)) :\n\t\t\t\ttrue;\n\t\t};\n\n\t\treturn Promise.all(this._parsedExcludeExpression.map(e => {\n\t\t\tconst excluded = e(testPath, basename, hasSibling);\n\t\t\tif (isThenable(excluded)) {\n\t\t\t\treturn excluded.then(excluded => {\n\t\t\t\t\tif (excluded) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn isIncluded();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn isIncluded();\n\n\t\t})).then(e => e.some(e => !!e));\n\n\n\t}\n\n\thasSiblingExcludeClauses(): boolean {\n\t\treturn this._excludeExpression.reduce((prev, curr) => hasSiblingClauses(curr) || prev, false);\n\t}\n}\n\nfunction hasSiblingClauses(pattern: glob.IExpression): boolean {\n\tfor (const key in pattern) {\n\t\tif (typeof pattern[key] !== 'boolean') {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function excludeToGlobPattern(excludesForFolder: { baseUri?: URI | undefined; patterns: string[] }[]): GlobPattern[] {\n\treturn excludesForFolder.flatMap(exclude => exclude.patterns.map(pattern => {\n\t\treturn exclude.baseUri ?\n\t\t\t{\n\t\t\t\tbaseUri: exclude.baseUri,\n\t\t\t\tpattern: pattern\n\t\t\t} : pattern;\n\t}));\n}\n\nexport const DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS = {\n\tmatchLines: 100,\n\tcharsPerLine: 10000\n};\n"]}