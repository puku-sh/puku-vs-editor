{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/worker/localFileSearch.ts","vs/workbench/services/search/worker/localFileSearch.ts"],"names":[],"mappings":"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","file":"localFileSearch.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from '../../../../base/common/glob.js';\nimport { UriComponents, URI } from '../../../../base/common/uri.js';\nimport { IWebWorkerServerRequestHandler, IWebWorkerServer } from '../../../../base/common/worker/webWorker.js';\nimport { ILocalFileSearchWorker, LocalFileSearchWorkerHost, IWorkerFileSearchComplete, IWorkerFileSystemDirectoryHandle, IWorkerFileSystemHandle, IWorkerTextSearchComplete } from '../common/localFileSearchWorkerTypes.js';\nimport { ICommonQueryProps, IFileMatch, IFileQueryProps, IFolderQuery, IPatternInfo, ITextQueryProps, } from '../common/search.js';\nimport * as paths from '../../../../base/common/path.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { getFileResults } from '../common/getFileResults.js';\nimport { IgnoreFile } from '../common/ignoreFile.js';\nimport { createRegExp } from '../../../../base/common/strings.js';\nimport { Promises } from '../../../../base/common/async.js';\nimport { ExtUri } from '../../../../base/common/resources.js';\nimport { revive } from '../../../../base/common/marshalling.js';\n\nconst PERF = false;\n\ntype FileNode = {\n\ttype: 'file';\n\tname: string;\n\tpath: string;\n\tresolve: () => Promise<ArrayBuffer>;\n};\n\ntype DirNode = {\n\ttype: 'dir';\n\tname: string;\n\tentries: Promise<(DirNode | FileNode)[]>;\n};\n\nconst globalStart = +new Date();\nconst itrcount: Record<string, number> = {};\nconst time = async <T>(name: string, task: () => Promise<T> | T) => {\n\tif (!PERF) { return task(); }\n\n\tconst start = Date.now();\n\tconst itr = (itrcount[name] ?? 0) + 1;\n\tconsole.info(name, itr, 'starting', Math.round((start - globalStart) * 10) / 10000);\n\n\titrcount[name] = itr;\n\tconst r = await task();\n\tconst end = Date.now();\n\tconsole.info(name, itr, 'took', end - start);\n\treturn r;\n};\n\nexport function create(workerServer: IWebWorkerServer): IWebWorkerServerRequestHandler {\n\treturn new LocalFileSearchWorker(workerServer);\n}\n\nexport class LocalFileSearchWorker implements ILocalFileSearchWorker, IWebWorkerServerRequestHandler {\n\t_requestHandlerBrand: void = undefined;\n\n\tprivate readonly host: LocalFileSearchWorkerHost;\n\tcancellationTokens: Map<number, CancellationTokenSource> = new Map();\n\n\tconstructor(workerServer: IWebWorkerServer) {\n\t\tthis.host = LocalFileSearchWorkerHost.getChannel(workerServer);\n\t}\n\n\t$cancelQuery(queryId: number): void {\n\t\tthis.cancellationTokens.get(queryId)?.cancel();\n\t}\n\n\tprivate registerCancellationToken(queryId: number): CancellationTokenSource {\n\t\tconst source = new CancellationTokenSource();\n\t\tthis.cancellationTokens.set(queryId, source);\n\t\treturn source;\n\t}\n\n\tasync $listDirectory(handle: IWorkerFileSystemDirectoryHandle, query: IFileQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerFileSearchComplete> {\n\t\tconst revivedFolderQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\tconst token = this.registerCancellationToken(queryId);\n\t\tconst entries: string[] = [];\n\t\tlet limitHit = false;\n\t\tlet count = 0;\n\n\t\tconst max = query.maxResults || 512;\n\n\t\tconst filePatternMatcher = query.filePattern\n\t\t\t? (name: string) => query.filePattern!.split('').every(c => name.includes(c))\n\t\t\t: (name: string) => true;\n\n\t\tawait time('listDirectory', () => this.walkFolderQuery(handle, reviveQueryProps(query), revivedFolderQuery, extUri, file => {\n\t\t\tif (!filePatternMatcher(file.name)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcount++;\n\n\t\t\tif (max && count > max) {\n\t\t\t\tlimitHit = true;\n\t\t\t\ttoken.cancel();\n\t\t\t}\n\t\t\treturn entries.push(file.path);\n\t\t}, token.token));\n\n\t\treturn {\n\t\t\tresults: entries,\n\t\t\tlimitHit\n\t\t};\n\t}\n\n\tasync $searchDirectory(handle: IWorkerFileSystemDirectoryHandle, query: ITextQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerTextSearchComplete> {\n\t\tconst revivedQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\treturn time('searchInFiles', async () => {\n\t\t\tconst token = this.registerCancellationToken(queryId);\n\n\t\t\tconst results: IFileMatch[] = [];\n\n\t\t\tconst pattern = createSearchRegExp(query.contentPattern);\n\n\t\t\tconst onGoingProcesses: Promise<void>[] = [];\n\n\t\t\tlet fileCount = 0;\n\t\t\tlet resultCount = 0;\n\t\t\tconst limitHit = false;\n\n\t\t\tconst processFile = async (file: FileNode) => {\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfileCount++;\n\n\t\t\t\tconst contents = await file.resolve();\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst bytes = new Uint8Array(contents);\n\t\t\t\tconst fileResults = getFileResults(bytes, pattern, {\n\t\t\t\t\tsurroundingContext: query.surroundingContext ?? 0,\n\t\t\t\t\tpreviewOptions: query.previewOptions,\n\t\t\t\t\tremainingResultQuota: query.maxResults ? (query.maxResults - resultCount) : 10000,\n\t\t\t\t});\n\n\t\t\t\tif (fileResults.length) {\n\t\t\t\t\tresultCount += fileResults.length;\n\t\t\t\t\tif (query.maxResults && resultCount > query.maxResults) {\n\t\t\t\t\t\ttoken.cancel();\n\t\t\t\t\t}\n\t\t\t\t\tconst match = {\n\t\t\t\t\t\tresource: URI.joinPath(revivedQuery.folder, file.path),\n\t\t\t\t\t\tresults: fileResults,\n\t\t\t\t\t};\n\t\t\t\t\tthis.host.$sendTextSearchMatch(match, queryId);\n\t\t\t\t\tresults.push(match);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tawait time('walkFolderToResolve', () =>\n\t\t\t\tthis.walkFolderQuery(handle, reviveQueryProps(query), revivedQuery, extUri, async file => onGoingProcesses.push(processFile(file)), token.token)\n\t\t\t);\n\n\t\t\tawait time('resolveOngoingProcesses', () => Promise.all(onGoingProcesses));\n\n\t\t\tif (PERF) { console.log('Searched in', fileCount, 'files'); }\n\n\t\t\treturn {\n\t\t\t\tresults,\n\t\t\t\tlimitHit,\n\t\t\t};\n\t\t});\n\n\t}\n\n\tprivate async walkFolderQuery(handle: IWorkerFileSystemDirectoryHandle, queryProps: ICommonQueryProps<URI>, folderQuery: IFolderQuery<URI>, extUri: ExtUri, onFile: (file: FileNode) => Promise<unknown> | unknown, token: CancellationToken): Promise<void> {\n\n\t\tconst folderExcludes = folderQuery.excludePattern?.map(excludePattern => glob.parse(excludePattern.pattern ?? {}, { trimForExclusions: true }) as glob.ParsedExpression);\n\n\t\tconst evalFolderExcludes = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\treturn folderExcludes?.some(folderExclude => {\n\t\t\t\treturn folderExclude(path, basename, hasSibling);\n\t\t\t});\n\n\t\t};\n\t\t// For folders, only check if the folder is explicitly excluded so walking continues.\n\t\tconst isFolderExcluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (evalFolderExcludes(path, basename, hasSibling)) { return true; }\n\t\t\tif (pathExcludedInQuery(queryProps, path)) { return true; }\n\t\t\treturn false;\n\t\t};\n\n\t\t// For files ensure the full check takes place.\n\t\tconst isFileIncluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (evalFolderExcludes(path, basename, hasSibling)) { return false; }\n\t\t\tif (!pathIncludedInQuery(queryProps, path, extUri)) { return false; }\n\t\t\treturn true;\n\t\t};\n\n\t\tconst processFile = (file: FileSystemFileHandle, prior: string): FileNode => {\n\n\t\t\tconst resolved: FileNode = {\n\t\t\t\ttype: 'file',\n\t\t\t\tname: file.name,\n\t\t\t\tpath: prior,\n\t\t\t\tresolve: () => file.getFile().then(r => r.arrayBuffer())\n\t\t\t} as const;\n\n\t\t\treturn resolved;\n\t\t};\n\n\t\tconst isFileSystemDirectoryHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemDirectoryHandle => {\n\t\t\treturn handle.kind === 'directory';\n\t\t};\n\n\t\tconst isFileSystemFileHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemFileHandle => {\n\t\t\treturn handle.kind === 'file';\n\t\t};\n\n\t\tconst processDirectory = async (directory: IWorkerFileSystemDirectoryHandle, prior: string, ignoreFile?: IgnoreFile): Promise<DirNode> => {\n\n\t\t\tif (!folderQuery.disregardIgnoreFiles) {\n\t\t\t\tconst ignoreFiles = await Promise.all([\n\t\t\t\t\tdirectory.getFileHandle('.gitignore').catch(e => undefined),\n\t\t\t\t\tdirectory.getFileHandle('.ignore').catch(e => undefined),\n\t\t\t\t]);\n\n\t\t\t\tawait Promise.all(ignoreFiles.map(async file => {\n\t\t\t\t\tif (!file) { return; }\n\n\t\t\t\t\tconst ignoreContents = new TextDecoder('utf8').decode(new Uint8Array(await (await file.getFile()).arrayBuffer()));\n\t\t\t\t\tignoreFile = new IgnoreFile(ignoreContents, prior, ignoreFile);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tconst entries = Promises.withAsyncBody<(FileNode | DirNode)[]>(async c => {\n\t\t\t\tconst files: FileNode[] = [];\n\t\t\t\tconst dirs: Promise<DirNode>[] = [];\n\n\t\t\t\tconst entries: [string, IWorkerFileSystemHandle][] = [];\n\t\t\t\tconst sibilings = new Set<string>();\n\n\t\t\t\tfor await (const entry of directory.entries()) {\n\t\t\t\t\tentries.push(entry);\n\t\t\t\t\tsibilings.add(entry[0]);\n\t\t\t\t}\n\n\t\t\t\tfor (const [basename, handle] of entries) {\n\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst path = prior + basename;\n\n\t\t\t\t\tif (ignoreFile && !ignoreFile.isPathIncludedInTraversal(path, handle.kind === 'directory')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst hasSibling = (query: string) => sibilings.has(query);\n\n\t\t\t\t\tif (isFileSystemDirectoryHandle(handle) && !isFolderExcluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tdirs.push(processDirectory(handle, path + '/', ignoreFile));\n\t\t\t\t\t} else if (isFileSystemFileHandle(handle) && isFileIncluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tfiles.push(processFile(handle, path));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc([...await Promise.all(dirs), ...files]);\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttype: 'dir',\n\t\t\t\tname: directory.name,\n\t\t\t\tentries\n\t\t\t};\n\t\t};\n\n\t\tconst resolveDirectory = async (directory: DirNode, onFile: (f: FileNode) => Promise<unknown> | unknown) => {\n\t\t\tif (token.isCancellationRequested) { return; }\n\n\t\t\tawait Promise.all(\n\t\t\t\t(await directory.entries)\n\t\t\t\t\t.sort((a, b) => -(a.type === 'dir' ? 0 : 1) + (b.type === 'dir' ? 0 : 1))\n\t\t\t\t\t.map(async entry => {\n\t\t\t\t\t\tif (entry.type === 'dir') {\n\t\t\t\t\t\t\treturn resolveDirectory(entry, onFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn onFile(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t};\n\n\t\tconst processed = await time('process', () => processDirectory(handle, '/'));\n\t\tawait time('resolve', () => resolveDirectory(processed, onFile));\n\t}\n}\n\nfunction createSearchRegExp(options: IPatternInfo): RegExp {\n\treturn createRegExp(options.pattern, !!options.isRegExp, {\n\t\twholeWord: options.isWordMatch,\n\t\tglobal: true,\n\t\tmatchCase: options.isCaseSensitive,\n\t\tmultiline: true,\n\t\tunicode: true,\n\t});\n}\n\nfunction reviveFolderQuery(folderQuery: IFolderQuery<UriComponents>): IFolderQuery<URI> {\n\t// @todo: andrea - try to see why we can't just call 'revive' here\n\treturn revive({\n\t\t...revive(folderQuery),\n\t\texcludePattern: folderQuery.excludePattern?.map(ep => ({ folder: URI.revive(ep.folder), pattern: ep.pattern })),\n\t\tfolder: URI.revive(folderQuery.folder),\n\t});\n}\n\nfunction reviveQueryProps(queryProps: ICommonQueryProps<UriComponents>): ICommonQueryProps<URI> {\n\treturn {\n\t\t...queryProps,\n\t\textraFileResources: queryProps.extraFileResources?.map(r => URI.revive(r)),\n\t\tfolderQueries: queryProps.folderQueries.map(fq => reviveFolderQuery(fq)),\n\t};\n}\n\n\nfunction pathExcludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, path: string, extUri: ExtUri): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, path)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (queryProps.includePattern && glob.match(queryProps.includePattern, path)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\n\t\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {\n\t\t\t\tconst searchPath = fq.folder;\n\t\t\t\tconst uri = URI.file(path);\n\t\t\t\tif (extUri.isEqualOrParent(uri, searchPath)) {\n\t\t\t\t\tconst relPath = paths.relative(searchPath.path, uri.path);\n\t\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, relPath);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from '../../../../base/common/glob.js';\nimport { UriComponents, URI } from '../../../../base/common/uri.js';\nimport { IWebWorkerServerRequestHandler, IWebWorkerServer } from '../../../../base/common/worker/webWorker.js';\nimport { ILocalFileSearchWorker, LocalFileSearchWorkerHost, IWorkerFileSearchComplete, IWorkerFileSystemDirectoryHandle, IWorkerFileSystemHandle, IWorkerTextSearchComplete } from '../common/localFileSearchWorkerTypes.js';\nimport { ICommonQueryProps, IFileMatch, IFileQueryProps, IFolderQuery, IPatternInfo, ITextQueryProps, } from '../common/search.js';\nimport * as paths from '../../../../base/common/path.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { getFileResults } from '../common/getFileResults.js';\nimport { IgnoreFile } from '../common/ignoreFile.js';\nimport { createRegExp } from '../../../../base/common/strings.js';\nimport { Promises } from '../../../../base/common/async.js';\nimport { ExtUri } from '../../../../base/common/resources.js';\nimport { revive } from '../../../../base/common/marshalling.js';\n\nconst PERF = false;\n\ntype FileNode = {\n\ttype: 'file';\n\tname: string;\n\tpath: string;\n\tresolve: () => Promise<ArrayBuffer>;\n};\n\ntype DirNode = {\n\ttype: 'dir';\n\tname: string;\n\tentries: Promise<(DirNode | FileNode)[]>;\n};\n\nconst globalStart = +new Date();\nconst itrcount: Record<string, number> = {};\nconst time = async <T>(name: string, task: () => Promise<T> | T) => {\n\tif (!PERF) { return task(); }\n\n\tconst start = Date.now();\n\tconst itr = (itrcount[name] ?? 0) + 1;\n\tconsole.info(name, itr, 'starting', Math.round((start - globalStart) * 10) / 10000);\n\n\titrcount[name] = itr;\n\tconst r = await task();\n\tconst end = Date.now();\n\tconsole.info(name, itr, 'took', end - start);\n\treturn r;\n};\n\nexport function create(workerServer: IWebWorkerServer): IWebWorkerServerRequestHandler {\n\treturn new LocalFileSearchWorker(workerServer);\n}\n\nexport class LocalFileSearchWorker implements ILocalFileSearchWorker, IWebWorkerServerRequestHandler {\n\t_requestHandlerBrand: void = undefined;\n\n\tprivate readonly host: LocalFileSearchWorkerHost;\n\tcancellationTokens: Map<number, CancellationTokenSource> = new Map();\n\n\tconstructor(workerServer: IWebWorkerServer) {\n\t\tthis.host = LocalFileSearchWorkerHost.getChannel(workerServer);\n\t}\n\n\t$cancelQuery(queryId: number): void {\n\t\tthis.cancellationTokens.get(queryId)?.cancel();\n\t}\n\n\tprivate registerCancellationToken(queryId: number): CancellationTokenSource {\n\t\tconst source = new CancellationTokenSource();\n\t\tthis.cancellationTokens.set(queryId, source);\n\t\treturn source;\n\t}\n\n\tasync $listDirectory(handle: IWorkerFileSystemDirectoryHandle, query: IFileQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerFileSearchComplete> {\n\t\tconst revivedFolderQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\tconst token = this.registerCancellationToken(queryId);\n\t\tconst entries: string[] = [];\n\t\tlet limitHit = false;\n\t\tlet count = 0;\n\n\t\tconst max = query.maxResults || 512;\n\n\t\tconst filePatternMatcher = query.filePattern\n\t\t\t? (name: string) => query.filePattern!.split('').every(c => name.includes(c))\n\t\t\t: (name: string) => true;\n\n\t\tawait time('listDirectory', () => this.walkFolderQuery(handle, reviveQueryProps(query), revivedFolderQuery, extUri, file => {\n\t\t\tif (!filePatternMatcher(file.name)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcount++;\n\n\t\t\tif (max && count > max) {\n\t\t\t\tlimitHit = true;\n\t\t\t\ttoken.cancel();\n\t\t\t}\n\t\t\treturn entries.push(file.path);\n\t\t}, token.token));\n\n\t\treturn {\n\t\t\tresults: entries,\n\t\t\tlimitHit\n\t\t};\n\t}\n\n\tasync $searchDirectory(handle: IWorkerFileSystemDirectoryHandle, query: ITextQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerTextSearchComplete> {\n\t\tconst revivedQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\treturn time('searchInFiles', async () => {\n\t\t\tconst token = this.registerCancellationToken(queryId);\n\n\t\t\tconst results: IFileMatch[] = [];\n\n\t\t\tconst pattern = createSearchRegExp(query.contentPattern);\n\n\t\t\tconst onGoingProcesses: Promise<void>[] = [];\n\n\t\t\tlet fileCount = 0;\n\t\t\tlet resultCount = 0;\n\t\t\tconst limitHit = false;\n\n\t\t\tconst processFile = async (file: FileNode) => {\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfileCount++;\n\n\t\t\t\tconst contents = await file.resolve();\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst bytes = new Uint8Array(contents);\n\t\t\t\tconst fileResults = getFileResults(bytes, pattern, {\n\t\t\t\t\tsurroundingContext: query.surroundingContext ?? 0,\n\t\t\t\t\tpreviewOptions: query.previewOptions,\n\t\t\t\t\tremainingResultQuota: query.maxResults ? (query.maxResults - resultCount) : 10000,\n\t\t\t\t});\n\n\t\t\t\tif (fileResults.length) {\n\t\t\t\t\tresultCount += fileResults.length;\n\t\t\t\t\tif (query.maxResults && resultCount > query.maxResults) {\n\t\t\t\t\t\ttoken.cancel();\n\t\t\t\t\t}\n\t\t\t\t\tconst match = {\n\t\t\t\t\t\tresource: URI.joinPath(revivedQuery.folder, file.path),\n\t\t\t\t\t\tresults: fileResults,\n\t\t\t\t\t};\n\t\t\t\t\tthis.host.$sendTextSearchMatch(match, queryId);\n\t\t\t\t\tresults.push(match);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tawait time('walkFolderToResolve', () =>\n\t\t\t\tthis.walkFolderQuery(handle, reviveQueryProps(query), revivedQuery, extUri, async file => onGoingProcesses.push(processFile(file)), token.token)\n\t\t\t);\n\n\t\t\tawait time('resolveOngoingProcesses', () => Promise.all(onGoingProcesses));\n\n\t\t\tif (PERF) { console.log('Searched in', fileCount, 'files'); }\n\n\t\t\treturn {\n\t\t\t\tresults,\n\t\t\t\tlimitHit,\n\t\t\t};\n\t\t});\n\n\t}\n\n\tprivate async walkFolderQuery(handle: IWorkerFileSystemDirectoryHandle, queryProps: ICommonQueryProps<URI>, folderQuery: IFolderQuery<URI>, extUri: ExtUri, onFile: (file: FileNode) => Promise<unknown> | unknown, token: CancellationToken): Promise<void> {\n\n\t\tconst folderExcludes = folderQuery.excludePattern?.map(excludePattern => glob.parse(excludePattern.pattern ?? {}, { trimForExclusions: true }) as glob.ParsedExpression);\n\n\t\tconst evalFolderExcludes = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\treturn folderExcludes?.some(folderExclude => {\n\t\t\t\treturn folderExclude(path, basename, hasSibling);\n\t\t\t});\n\n\t\t};\n\t\t// For folders, only check if the folder is explicitly excluded so walking continues.\n\t\tconst isFolderExcluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (evalFolderExcludes(path, basename, hasSibling)) { return true; }\n\t\t\tif (pathExcludedInQuery(queryProps, path)) { return true; }\n\t\t\treturn false;\n\t\t};\n\n\t\t// For files ensure the full check takes place.\n\t\tconst isFileIncluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (evalFolderExcludes(path, basename, hasSibling)) { return false; }\n\t\t\tif (!pathIncludedInQuery(queryProps, path, extUri)) { return false; }\n\t\t\treturn true;\n\t\t};\n\n\t\tconst processFile = (file: FileSystemFileHandle, prior: string): FileNode => {\n\n\t\t\tconst resolved: FileNode = {\n\t\t\t\ttype: 'file',\n\t\t\t\tname: file.name,\n\t\t\t\tpath: prior,\n\t\t\t\tresolve: () => file.getFile().then(r => r.arrayBuffer())\n\t\t\t} as const;\n\n\t\t\treturn resolved;\n\t\t};\n\n\t\tconst isFileSystemDirectoryHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemDirectoryHandle => {\n\t\t\treturn handle.kind === 'directory';\n\t\t};\n\n\t\tconst isFileSystemFileHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemFileHandle => {\n\t\t\treturn handle.kind === 'file';\n\t\t};\n\n\t\tconst processDirectory = async (directory: IWorkerFileSystemDirectoryHandle, prior: string, ignoreFile?: IgnoreFile): Promise<DirNode> => {\n\n\t\t\tif (!folderQuery.disregardIgnoreFiles) {\n\t\t\t\tconst ignoreFiles = await Promise.all([\n\t\t\t\t\tdirectory.getFileHandle('.gitignore').catch(e => undefined),\n\t\t\t\t\tdirectory.getFileHandle('.ignore').catch(e => undefined),\n\t\t\t\t]);\n\n\t\t\t\tawait Promise.all(ignoreFiles.map(async file => {\n\t\t\t\t\tif (!file) { return; }\n\n\t\t\t\t\tconst ignoreContents = new TextDecoder('utf8').decode(new Uint8Array(await (await file.getFile()).arrayBuffer()));\n\t\t\t\t\tignoreFile = new IgnoreFile(ignoreContents, prior, ignoreFile);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tconst entries = Promises.withAsyncBody<(FileNode | DirNode)[]>(async c => {\n\t\t\t\tconst files: FileNode[] = [];\n\t\t\t\tconst dirs: Promise<DirNode>[] = [];\n\n\t\t\t\tconst entries: [string, IWorkerFileSystemHandle][] = [];\n\t\t\t\tconst sibilings = new Set<string>();\n\n\t\t\t\tfor await (const entry of directory.entries()) {\n\t\t\t\t\tentries.push(entry);\n\t\t\t\t\tsibilings.add(entry[0]);\n\t\t\t\t}\n\n\t\t\t\tfor (const [basename, handle] of entries) {\n\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst path = prior + basename;\n\n\t\t\t\t\tif (ignoreFile && !ignoreFile.isPathIncludedInTraversal(path, handle.kind === 'directory')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst hasSibling = (query: string) => sibilings.has(query);\n\n\t\t\t\t\tif (isFileSystemDirectoryHandle(handle) && !isFolderExcluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tdirs.push(processDirectory(handle, path + '/', ignoreFile));\n\t\t\t\t\t} else if (isFileSystemFileHandle(handle) && isFileIncluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tfiles.push(processFile(handle, path));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc([...await Promise.all(dirs), ...files]);\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttype: 'dir',\n\t\t\t\tname: directory.name,\n\t\t\t\tentries\n\t\t\t};\n\t\t};\n\n\t\tconst resolveDirectory = async (directory: DirNode, onFile: (f: FileNode) => Promise<unknown> | unknown) => {\n\t\t\tif (token.isCancellationRequested) { return; }\n\n\t\t\tawait Promise.all(\n\t\t\t\t(await directory.entries)\n\t\t\t\t\t.sort((a, b) => -(a.type === 'dir' ? 0 : 1) + (b.type === 'dir' ? 0 : 1))\n\t\t\t\t\t.map(async entry => {\n\t\t\t\t\t\tif (entry.type === 'dir') {\n\t\t\t\t\t\t\treturn resolveDirectory(entry, onFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn onFile(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t};\n\n\t\tconst processed = await time('process', () => processDirectory(handle, '/'));\n\t\tawait time('resolve', () => resolveDirectory(processed, onFile));\n\t}\n}\n\nfunction createSearchRegExp(options: IPatternInfo): RegExp {\n\treturn createRegExp(options.pattern, !!options.isRegExp, {\n\t\twholeWord: options.isWordMatch,\n\t\tglobal: true,\n\t\tmatchCase: options.isCaseSensitive,\n\t\tmultiline: true,\n\t\tunicode: true,\n\t});\n}\n\nfunction reviveFolderQuery(folderQuery: IFolderQuery<UriComponents>): IFolderQuery<URI> {\n\t// @todo: andrea - try to see why we can't just call 'revive' here\n\treturn revive({\n\t\t...revive(folderQuery),\n\t\texcludePattern: folderQuery.excludePattern?.map(ep => ({ folder: URI.revive(ep.folder), pattern: ep.pattern })),\n\t\tfolder: URI.revive(folderQuery.folder),\n\t});\n}\n\nfunction reviveQueryProps(queryProps: ICommonQueryProps<UriComponents>): ICommonQueryProps<URI> {\n\treturn {\n\t\t...queryProps,\n\t\textraFileResources: queryProps.extraFileResources?.map(r => URI.revive(r)),\n\t\tfolderQueries: queryProps.folderQueries.map(fq => reviveFolderQuery(fq)),\n\t};\n}\n\n\nfunction pathExcludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, path: string, extUri: ExtUri): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, path)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (queryProps.includePattern && glob.match(queryProps.includePattern, path)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\n\t\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {\n\t\t\t\tconst searchPath = fq.folder;\n\t\t\t\tconst uri = URI.file(path);\n\t\t\t\tif (extUri.isEqualOrParent(uri, searchPath)) {\n\t\t\t\t\tconst relPath = paths.relative(searchPath.path, uri.path);\n\t\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, relPath);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n"]}