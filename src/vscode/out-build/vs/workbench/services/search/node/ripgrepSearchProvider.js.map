{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/node/ripgrepSearchProvider.ts","vs/workbench/services/search/node/ripgrepSearchProvider.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,uBAAuB,EAAqB,MAAM,yCAAyC,CAAC;AAErG,OAAO,EAAE,uBAAuB,EAAE,MAAM,8BAA8B,CAAC;AAEvE,OAAO,EAAE,QAAQ,EAAE,MAAM,kDAAkD,CAAC;AAC5E,OAAO,EAAE,OAAO,EAAE,MAAM,oCAAoC,CAAC;AAG7D,MAAM,OAAO,qBAAqB;IAGjC,YAAoB,aAA4B,EAAU,aAAgD;QAAtF,kBAAa,GAAb,aAAa,CAAe;QAAU,kBAAa,GAAb,aAAa,CAAmC;QAFlG,eAAU,GAAiC,IAAI,GAAG,EAAE,CAAC;QAG5D,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;IAC5C,CAAC;IAED,KAAK,CAAC,wBAAwB,CAAC,KAAuB,EAAE,OAAkC,EAAE,QAAqC,EAAE,KAAwB;QAC1J,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,aAAa,EAAE,CAAC;QAC9C,MAAM,MAAM,GAAG,IAAI,uBAAuB,CAAC,IAAI,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;QAE3E,OAAO,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,aAAa,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;YAE3D,MAAM,eAAe,GAA6B;gBACjD,aAAa,EAAE,YAAY;gBAC3B,UAAU;gBACV,UAAU,EAAE,OAAO,CAAC,UAAU;gBAC9B,cAAc,EAAE,OAAO,CAAC,cAAc;gBACtC,WAAW,EAAE,OAAO,CAAC,WAAW;gBAChC,kBAAkB,EAAE,OAAO,CAAC,kBAAkB;aAC9C,CAAC;YACF,IAAI,YAAY,CAAC,MAAM,CAAC,MAAM,KAAK,OAAO,CAAC,cAAc,EAAE,CAAC;gBAC3D,4LAA4L;gBAC5L,yIAAyI;gBACzI,MAAM,iBAAiB,GAAG,EAAE,GAAG,eAAe,EAAE,MAAM,EAAE,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,OAAO,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC;gBAC7G,MAAM,kBAAkB,GAAG,IAAI,QAAQ,CAAoB,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,YAAY,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC7J,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,qCAAqC,CAAC,KAAK,EAAE,iBAAiB,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC,CAAC;YAC1I,CAAC;iBAAM,CAAC;gBACP,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,qCAAqC,CAAC,KAAK,EAAE,eAAe,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;YAC9H,CAAC;QACF,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;YACb,MAAM,QAAQ,GAAwB;gBACrC,mCAAmC;gBACnC,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,QAAQ,CAAC;aAC7D,CAAC;YACF,OAAO,QAAQ,CAAC;QACjB,CAAC,CAAC,CAAC,CAAC;IAEL,CAAC;IAEO,KAAK,CAAC,SAAS,CAAI,KAAwB,EAAE,EAA4C;QAChG,MAAM,MAAM,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC;QACxC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC5B,MAAM,MAAM,GAAG,MAAM,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACtC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAE/B,OAAO,MAAM,CAAC;IACf,CAAC;IAEO,OAAO;QACd,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;IACpD,CAAC;CACD;AAED,SAAS,iBAAiB,CAAC,KAAwB;IAClD,MAAM,WAAW,GAAG,IAAI,uBAAuB,EAAE,CAAC;IAClD,KAAK,CAAC,uBAAuB,CAAC,GAAG,EAAE,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC,CAAC;IAE1D,OAAO,WAAW,CAAC;AACpB,CAAC","file":"ripgrepSearchProvider.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationTokenSource, CancellationToken } from '../../../../base/common/cancellation.js';\nimport { OutputChannel } from './ripgrepSearchUtils.js';\nimport { RipgrepTextSearchEngine } from './ripgrepTextSearchEngine.js';\nimport { TextSearchProvider2, TextSearchComplete2, TextSearchResult2, TextSearchQuery2, TextSearchProviderOptions, } from '../common/searchExtTypes.js';\nimport { Progress } from '../../../../platform/progress/common/progress.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport type { RipgrepTextSearchOptions } from '../common/searchExtTypesInternal.js';\n\nexport class RipgrepSearchProvider implements TextSearchProvider2 {\n\tprivate inProgress: Set<CancellationTokenSource> = new Set();\n\n\tconstructor(private outputChannel: OutputChannel, private getNumThreads: () => Promise<number | undefined>) {\n\t\tprocess.once('exit', () => this.dispose());\n\t}\n\n\tasync provideTextSearchResults(query: TextSearchQuery2, options: TextSearchProviderOptions, progress: Progress<TextSearchResult2>, token: CancellationToken): Promise<TextSearchComplete2> {\n\t\tconst numThreads = await this.getNumThreads();\n\t\tconst engine = new RipgrepTextSearchEngine(this.outputChannel, numThreads);\n\n\t\treturn Promise.all(options.folderOptions.map(folderOption => {\n\n\t\t\tconst extendedOptions: RipgrepTextSearchOptions = {\n\t\t\t\tfolderOptions: folderOption,\n\t\t\t\tnumThreads,\n\t\t\t\tmaxResults: options.maxResults,\n\t\t\t\tpreviewOptions: options.previewOptions,\n\t\t\t\tmaxFileSize: options.maxFileSize,\n\t\t\t\tsurroundingContext: options.surroundingContext\n\t\t\t};\n\t\t\tif (folderOption.folder.scheme === Schemas.vscodeUserData) {\n\t\t\t\t// Ripgrep search engine can only provide file-scheme results, but we want to use it to search some schemes that are backed by the filesystem, but with some other provider as the frontend,\n\t\t\t\t// case in point vscode-userdata. In these cases we translate the query to a file, and translate the results back to the frontend scheme.\n\t\t\t\tconst translatedOptions = { ...extendedOptions, folder: folderOption.folder.with({ scheme: Schemas.file }) };\n\t\t\t\tconst progressTranslator = new Progress<TextSearchResult2>(data => progress.report({ ...data, uri: data.uri.with({ scheme: folderOption.folder.scheme }) }));\n\t\t\t\treturn this.withToken(token, token => engine.provideTextSearchResultsWithRgOptions(query, translatedOptions, progressTranslator, token));\n\t\t\t} else {\n\t\t\t\treturn this.withToken(token, token => engine.provideTextSearchResultsWithRgOptions(query, extendedOptions, progress, token));\n\t\t\t}\n\t\t})).then((e => {\n\t\t\tconst complete: TextSearchComplete2 = {\n\t\t\t\t// todo: get this to actually check\n\t\t\t\tlimitHit: e.some(complete => !!complete && complete.limitHit)\n\t\t\t};\n\t\t\treturn complete;\n\t\t}));\n\n\t}\n\n\tprivate async withToken<T>(token: CancellationToken, fn: (token: CancellationToken) => Promise<T>): Promise<T> {\n\t\tconst merged = mergedTokenSource(token);\n\t\tthis.inProgress.add(merged);\n\t\tconst result = await fn(merged.token);\n\t\tthis.inProgress.delete(merged);\n\n\t\treturn result;\n\t}\n\n\tprivate dispose() {\n\t\tthis.inProgress.forEach(engine => engine.cancel());\n\t}\n}\n\nfunction mergedTokenSource(token: CancellationToken): CancellationTokenSource {\n\tconst tokenSource = new CancellationTokenSource();\n\ttoken.onCancellationRequested(() => tokenSource.cancel());\n\n\treturn tokenSource;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationTokenSource, CancellationToken } from '../../../../base/common/cancellation.js';\nimport { OutputChannel } from './ripgrepSearchUtils.js';\nimport { RipgrepTextSearchEngine } from './ripgrepTextSearchEngine.js';\nimport { TextSearchProvider2, TextSearchComplete2, TextSearchResult2, TextSearchQuery2, TextSearchProviderOptions, } from '../common/searchExtTypes.js';\nimport { Progress } from '../../../../platform/progress/common/progress.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport type { RipgrepTextSearchOptions } from '../common/searchExtTypesInternal.js';\n\nexport class RipgrepSearchProvider implements TextSearchProvider2 {\n\tprivate inProgress: Set<CancellationTokenSource> = new Set();\n\n\tconstructor(private outputChannel: OutputChannel, private getNumThreads: () => Promise<number | undefined>) {\n\t\tprocess.once('exit', () => this.dispose());\n\t}\n\n\tasync provideTextSearchResults(query: TextSearchQuery2, options: TextSearchProviderOptions, progress: Progress<TextSearchResult2>, token: CancellationToken): Promise<TextSearchComplete2> {\n\t\tconst numThreads = await this.getNumThreads();\n\t\tconst engine = new RipgrepTextSearchEngine(this.outputChannel, numThreads);\n\n\t\treturn Promise.all(options.folderOptions.map(folderOption => {\n\n\t\t\tconst extendedOptions: RipgrepTextSearchOptions = {\n\t\t\t\tfolderOptions: folderOption,\n\t\t\t\tnumThreads,\n\t\t\t\tmaxResults: options.maxResults,\n\t\t\t\tpreviewOptions: options.previewOptions,\n\t\t\t\tmaxFileSize: options.maxFileSize,\n\t\t\t\tsurroundingContext: options.surroundingContext\n\t\t\t};\n\t\t\tif (folderOption.folder.scheme === Schemas.vscodeUserData) {\n\t\t\t\t// Ripgrep search engine can only provide file-scheme results, but we want to use it to search some schemes that are backed by the filesystem, but with some other provider as the frontend,\n\t\t\t\t// case in point vscode-userdata. In these cases we translate the query to a file, and translate the results back to the frontend scheme.\n\t\t\t\tconst translatedOptions = { ...extendedOptions, folder: folderOption.folder.with({ scheme: Schemas.file }) };\n\t\t\t\tconst progressTranslator = new Progress<TextSearchResult2>(data => progress.report({ ...data, uri: data.uri.with({ scheme: folderOption.folder.scheme }) }));\n\t\t\t\treturn this.withToken(token, token => engine.provideTextSearchResultsWithRgOptions(query, translatedOptions, progressTranslator, token));\n\t\t\t} else {\n\t\t\t\treturn this.withToken(token, token => engine.provideTextSearchResultsWithRgOptions(query, extendedOptions, progress, token));\n\t\t\t}\n\t\t})).then((e => {\n\t\t\tconst complete: TextSearchComplete2 = {\n\t\t\t\t// todo: get this to actually check\n\t\t\t\tlimitHit: e.some(complete => !!complete && complete.limitHit)\n\t\t\t};\n\t\t\treturn complete;\n\t\t}));\n\n\t}\n\n\tprivate async withToken<T>(token: CancellationToken, fn: (token: CancellationToken) => Promise<T>): Promise<T> {\n\t\tconst merged = mergedTokenSource(token);\n\t\tthis.inProgress.add(merged);\n\t\tconst result = await fn(merged.token);\n\t\tthis.inProgress.delete(merged);\n\n\t\treturn result;\n\t}\n\n\tprivate dispose() {\n\t\tthis.inProgress.forEach(engine => engine.cancel());\n\t}\n}\n\nfunction mergedTokenSource(token: CancellationToken): CancellationTokenSource {\n\tconst tokenSource = new CancellationTokenSource();\n\ttoken.onCancellationRequested(() => tokenSource.cancel());\n\n\treturn tokenSource;\n}\n"]}