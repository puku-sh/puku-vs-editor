{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/node/ripgrepFileSearch.ts","vs/workbench/services/search/node/ripgrepFileSearch.ts"],"names":[],"mappings":"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","file":"ripgrepFileSearch.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport * as path from '../../../../base/common/path.js';\nimport * as glob from '../../../../base/common/glob.js';\nimport { normalizeNFD } from '../../../../base/common/normalization.js';\nimport * as extpath from '../../../../base/common/extpath.js';\nimport { isMacintosh as isMac } from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IFileQuery, IFolderQuery } from '../common/search.js';\nimport { anchorGlob } from './ripgrepSearchUtils.js';\nimport { rgPath } from '@vscode/ripgrep';\n\n// If @vscode/ripgrep is in an .asar file, then the binary is unpacked.\nconst rgDiskPath = rgPath.replace(/\\bnode_modules\\.asar\\b/, 'node_modules.asar.unpacked');\n\nexport function spawnRipgrepCmd(config: IFileQuery, folderQuery: IFolderQuery, includePattern?: glob.IExpression, excludePattern?: glob.IExpression, numThreads?: number) {\n\tconst rgArgs = getRgArgs(config, folderQuery, includePattern, excludePattern, numThreads);\n\tconst cwd = folderQuery.folder.fsPath;\n\treturn {\n\t\tcmd: cp.spawn(rgDiskPath, rgArgs.args, { cwd }),\n\t\trgDiskPath,\n\t\tsiblingClauses: rgArgs.siblingClauses,\n\t\trgArgs,\n\t\tcwd\n\t};\n}\n\nfunction getRgArgs(config: IFileQuery, folderQuery: IFolderQuery, includePattern?: glob.IExpression, excludePattern?: glob.IExpression, numThreads?: number) {\n\tconst args = ['--files', '--hidden', '--case-sensitive', '--no-require-git'];\n\n\t// includePattern can't have siblingClauses\n\tfoldersToIncludeGlobs([folderQuery], includePattern, false).forEach(globArg => {\n\t\tconst inclusion = anchorGlob(globArg);\n\t\targs.push('-g', inclusion);\n\t\tif (isMac) {\n\t\t\tconst normalized = normalizeNFD(inclusion);\n\t\t\tif (normalized !== inclusion) {\n\t\t\t\targs.push('-g', normalized);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst rgGlobs = foldersToRgExcludeGlobs([folderQuery], excludePattern, undefined, false);\n\trgGlobs.globArgs.forEach(globArg => {\n\t\tconst exclusion = `!${anchorGlob(globArg)}`;\n\t\targs.push('-g', exclusion);\n\t\tif (isMac) {\n\t\t\tconst normalized = normalizeNFD(exclusion);\n\t\t\tif (normalized !== exclusion) {\n\t\t\t\targs.push('-g', normalized);\n\t\t\t}\n\t\t}\n\t});\n\tif (folderQuery.disregardIgnoreFiles !== false) {\n\t\t// Don't use .gitignore or .ignore\n\t\targs.push('--no-ignore');\n\t} else if (folderQuery.disregardParentIgnoreFiles !== false) {\n\t\targs.push('--no-ignore-parent');\n\t}\n\n\t// Follow symlinks\n\tif (!folderQuery.ignoreSymlinks) {\n\t\targs.push('--follow');\n\t}\n\n\tif (config.exists) {\n\t\targs.push('--quiet');\n\t}\n\n\tif (numThreads) {\n\t\targs.push('--threads', `${numThreads}`);\n\t}\n\n\targs.push('--no-config');\n\tif (folderQuery.disregardGlobalIgnoreFiles) {\n\t\targs.push('--no-ignore-global');\n\t}\n\n\treturn {\n\t\targs,\n\t\tsiblingClauses: rgGlobs.siblingClauses\n\t};\n}\n\ninterface IRgGlobResult {\n\tglobArgs: string[];\n\tsiblingClauses: glob.IExpression;\n}\n\nfunction foldersToRgExcludeGlobs(folderQueries: IFolderQuery[], globalExclude?: glob.IExpression, excludesToSkip?: Set<string>, absoluteGlobs = true): IRgGlobResult {\n\tconst globArgs: string[] = [];\n\tlet siblingClauses: glob.IExpression = {};\n\tfolderQueries.forEach(folderQuery => {\n\t\tconst totalExcludePattern = Object.assign({}, folderQuery.excludePattern || {}, globalExclude || {});\n\t\tconst result = globExprsToRgGlobs(totalExcludePattern, absoluteGlobs ? folderQuery.folder.fsPath : undefined, excludesToSkip);\n\t\tglobArgs.push(...result.globArgs);\n\t\tif (result.siblingClauses) {\n\t\t\tsiblingClauses = Object.assign(siblingClauses, result.siblingClauses);\n\t\t}\n\t});\n\n\treturn { globArgs, siblingClauses };\n}\n\nfunction foldersToIncludeGlobs(folderQueries: IFolderQuery[], globalInclude?: glob.IExpression, absoluteGlobs = true): string[] {\n\tconst globArgs: string[] = [];\n\tfolderQueries.forEach(folderQuery => {\n\t\tconst totalIncludePattern = Object.assign({}, globalInclude || {}, folderQuery.includePattern || {});\n\t\tconst result = globExprsToRgGlobs(totalIncludePattern, absoluteGlobs ? folderQuery.folder.fsPath : undefined);\n\t\tglobArgs.push(...result.globArgs);\n\t});\n\n\treturn globArgs;\n}\n\nfunction globExprsToRgGlobs(patterns: glob.IExpression, folder?: string, excludesToSkip?: Set<string>): IRgGlobResult {\n\tconst globArgs: string[] = [];\n\tconst siblingClauses: glob.IExpression = {};\n\tObject.keys(patterns)\n\t\t.forEach(key => {\n\t\t\tif (excludesToSkip && excludesToSkip.has(key)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!key) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst value = patterns[key];\n\t\t\tkey = trimTrailingSlash(folder ? getAbsoluteGlob(folder, key) : key);\n\n\t\t\t// glob.ts requires forward slashes, but a UNC path still must start with \\\\\n\t\t\t// #38165 and #38151\n\t\t\tif (key.startsWith('\\\\\\\\')) {\n\t\t\t\tkey = '\\\\\\\\' + key.substr(2).replace(/\\\\/g, '/');\n\t\t\t} else {\n\t\t\t\tkey = key.replace(/\\\\/g, '/');\n\t\t\t}\n\n\t\t\tif (typeof value === 'boolean' && value) {\n\t\t\t\tif (key.startsWith('\\\\\\\\')) {\n\t\t\t\t\t// Absolute globs UNC paths don't work properly, see #58758\n\t\t\t\t\tkey += '**';\n\t\t\t\t}\n\n\t\t\t\tglobArgs.push(fixDriveC(key));\n\t\t\t} else if (value && value.when) {\n\t\t\t\tsiblingClauses[key] = value;\n\t\t\t}\n\t\t});\n\n\treturn { globArgs, siblingClauses };\n}\n\n/**\n * Resolves a glob like \"node_modules/**\" in \"/foo/bar\" to \"/foo/bar/node_modules/**\".\n * Special cases C:/foo paths to write the glob like /foo instead - see https://github.com/BurntSushi/ripgrep/issues/530.\n *\n * Exported for testing\n */\nexport function getAbsoluteGlob(folder: string, key: string): string {\n\treturn path.isAbsolute(key) ?\n\t\tkey :\n\t\tpath.join(folder, key);\n}\n\nfunction trimTrailingSlash(str: string): string {\n\tstr = strings.rtrim(str, '\\\\');\n\treturn strings.rtrim(str, '/');\n}\n\nexport function fixDriveC(path: string): string {\n\tconst root = extpath.getRoot(path);\n\treturn root.toLowerCase() === 'c:/' ?\n\t\tpath.replace(/^c:[/\\\\]/i, '/') :\n\t\tpath;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport * as path from '../../../../base/common/path.js';\nimport * as glob from '../../../../base/common/glob.js';\nimport { normalizeNFD } from '../../../../base/common/normalization.js';\nimport * as extpath from '../../../../base/common/extpath.js';\nimport { isMacintosh as isMac } from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IFileQuery, IFolderQuery } from '../common/search.js';\nimport { anchorGlob } from './ripgrepSearchUtils.js';\nimport { rgPath } from '@vscode/ripgrep';\n\n// If @vscode/ripgrep is in an .asar file, then the binary is unpacked.\nconst rgDiskPath = rgPath.replace(/\\bnode_modules\\.asar\\b/, 'node_modules.asar.unpacked');\n\nexport function spawnRipgrepCmd(config: IFileQuery, folderQuery: IFolderQuery, includePattern?: glob.IExpression, excludePattern?: glob.IExpression, numThreads?: number) {\n\tconst rgArgs = getRgArgs(config, folderQuery, includePattern, excludePattern, numThreads);\n\tconst cwd = folderQuery.folder.fsPath;\n\treturn {\n\t\tcmd: cp.spawn(rgDiskPath, rgArgs.args, { cwd }),\n\t\trgDiskPath,\n\t\tsiblingClauses: rgArgs.siblingClauses,\n\t\trgArgs,\n\t\tcwd\n\t};\n}\n\nfunction getRgArgs(config: IFileQuery, folderQuery: IFolderQuery, includePattern?: glob.IExpression, excludePattern?: glob.IExpression, numThreads?: number) {\n\tconst args = ['--files', '--hidden', '--case-sensitive', '--no-require-git'];\n\n\t// includePattern can't have siblingClauses\n\tfoldersToIncludeGlobs([folderQuery], includePattern, false).forEach(globArg => {\n\t\tconst inclusion = anchorGlob(globArg);\n\t\targs.push('-g', inclusion);\n\t\tif (isMac) {\n\t\t\tconst normalized = normalizeNFD(inclusion);\n\t\t\tif (normalized !== inclusion) {\n\t\t\t\targs.push('-g', normalized);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst rgGlobs = foldersToRgExcludeGlobs([folderQuery], excludePattern, undefined, false);\n\trgGlobs.globArgs.forEach(globArg => {\n\t\tconst exclusion = `!${anchorGlob(globArg)}`;\n\t\targs.push('-g', exclusion);\n\t\tif (isMac) {\n\t\t\tconst normalized = normalizeNFD(exclusion);\n\t\t\tif (normalized !== exclusion) {\n\t\t\t\targs.push('-g', normalized);\n\t\t\t}\n\t\t}\n\t});\n\tif (folderQuery.disregardIgnoreFiles !== false) {\n\t\t// Don't use .gitignore or .ignore\n\t\targs.push('--no-ignore');\n\t} else if (folderQuery.disregardParentIgnoreFiles !== false) {\n\t\targs.push('--no-ignore-parent');\n\t}\n\n\t// Follow symlinks\n\tif (!folderQuery.ignoreSymlinks) {\n\t\targs.push('--follow');\n\t}\n\n\tif (config.exists) {\n\t\targs.push('--quiet');\n\t}\n\n\tif (numThreads) {\n\t\targs.push('--threads', `${numThreads}`);\n\t}\n\n\targs.push('--no-config');\n\tif (folderQuery.disregardGlobalIgnoreFiles) {\n\t\targs.push('--no-ignore-global');\n\t}\n\n\treturn {\n\t\targs,\n\t\tsiblingClauses: rgGlobs.siblingClauses\n\t};\n}\n\ninterface IRgGlobResult {\n\tglobArgs: string[];\n\tsiblingClauses: glob.IExpression;\n}\n\nfunction foldersToRgExcludeGlobs(folderQueries: IFolderQuery[], globalExclude?: glob.IExpression, excludesToSkip?: Set<string>, absoluteGlobs = true): IRgGlobResult {\n\tconst globArgs: string[] = [];\n\tlet siblingClauses: glob.IExpression = {};\n\tfolderQueries.forEach(folderQuery => {\n\t\tconst totalExcludePattern = Object.assign({}, folderQuery.excludePattern || {}, globalExclude || {});\n\t\tconst result = globExprsToRgGlobs(totalExcludePattern, absoluteGlobs ? folderQuery.folder.fsPath : undefined, excludesToSkip);\n\t\tglobArgs.push(...result.globArgs);\n\t\tif (result.siblingClauses) {\n\t\t\tsiblingClauses = Object.assign(siblingClauses, result.siblingClauses);\n\t\t}\n\t});\n\n\treturn { globArgs, siblingClauses };\n}\n\nfunction foldersToIncludeGlobs(folderQueries: IFolderQuery[], globalInclude?: glob.IExpression, absoluteGlobs = true): string[] {\n\tconst globArgs: string[] = [];\n\tfolderQueries.forEach(folderQuery => {\n\t\tconst totalIncludePattern = Object.assign({}, globalInclude || {}, folderQuery.includePattern || {});\n\t\tconst result = globExprsToRgGlobs(totalIncludePattern, absoluteGlobs ? folderQuery.folder.fsPath : undefined);\n\t\tglobArgs.push(...result.globArgs);\n\t});\n\n\treturn globArgs;\n}\n\nfunction globExprsToRgGlobs(patterns: glob.IExpression, folder?: string, excludesToSkip?: Set<string>): IRgGlobResult {\n\tconst globArgs: string[] = [];\n\tconst siblingClauses: glob.IExpression = {};\n\tObject.keys(patterns)\n\t\t.forEach(key => {\n\t\t\tif (excludesToSkip && excludesToSkip.has(key)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!key) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst value = patterns[key];\n\t\t\tkey = trimTrailingSlash(folder ? getAbsoluteGlob(folder, key) : key);\n\n\t\t\t// glob.ts requires forward slashes, but a UNC path still must start with \\\\\n\t\t\t// #38165 and #38151\n\t\t\tif (key.startsWith('\\\\\\\\')) {\n\t\t\t\tkey = '\\\\\\\\' + key.substr(2).replace(/\\\\/g, '/');\n\t\t\t} else {\n\t\t\t\tkey = key.replace(/\\\\/g, '/');\n\t\t\t}\n\n\t\t\tif (typeof value === 'boolean' && value) {\n\t\t\t\tif (key.startsWith('\\\\\\\\')) {\n\t\t\t\t\t// Absolute globs UNC paths don't work properly, see #58758\n\t\t\t\t\tkey += '**';\n\t\t\t\t}\n\n\t\t\t\tglobArgs.push(fixDriveC(key));\n\t\t\t} else if (value && value.when) {\n\t\t\t\tsiblingClauses[key] = value;\n\t\t\t}\n\t\t});\n\n\treturn { globArgs, siblingClauses };\n}\n\n/**\n * Resolves a glob like \"node_modules/**\" in \"/foo/bar\" to \"/foo/bar/node_modules/**\".\n * Special cases C:/foo paths to write the glob like /foo instead - see https://github.com/BurntSushi/ripgrep/issues/530.\n *\n * Exported for testing\n */\nexport function getAbsoluteGlob(folder: string, key: string): string {\n\treturn path.isAbsolute(key) ?\n\t\tkey :\n\t\tpath.join(folder, key);\n}\n\nfunction trimTrailingSlash(str: string): string {\n\tstr = strings.rtrim(str, '\\\\');\n\treturn strings.rtrim(str, '/');\n}\n\nexport function fixDriveC(path: string): string {\n\tconst root = extpath.getRoot(path);\n\treturn root.toLowerCase() === 'c:/' ?\n\t\tpath.replace(/^c:[/\\\\]/i, '/') :\n\t\tpath;\n}\n"]}