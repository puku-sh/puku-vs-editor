{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/node/rawSearchService.ts","vs/workbench/services/search/node/rawSearchService.ts"],"names":[],"mappings":"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","file":"rawSearchService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { CancelablePromise, createCancelablePromise } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { canceled } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { compareItemsByFuzzyScore, FuzzyScorerCache, IItemAccessor, prepareQuery } from '../../../../base/common/fuzzyScorer.js';\nimport { revive } from '../../../../base/common/marshalling.js';\nimport { basename, dirname, join, sep } from '../../../../base/common/path.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { ByteSize } from '../../../../platform/files/common/files.js';\nimport { DEFAULT_MAX_SEARCH_RESULTS, ICachedSearchStats, IFileQuery, IFileSearchProgressItem, IFileSearchStats, IFolderQuery, IProgressMessage, IRawFileMatch, IRawFileQuery, IRawQuery, IRawSearchService, IRawTextQuery, ISearchEngine, ISearchEngineSuccess, ISerializedFileMatch, ISerializedSearchComplete, ISerializedSearchProgressItem, ISerializedSearchSuccess, isFilePatternMatch, ITextQuery } from '../common/search.js';\nimport { Engine as FileSearchEngine } from './fileSearch.js';\nimport { TextSearchEngineAdapter } from './textSearchAdapter.js';\n\nexport type IProgressCallback = (p: ISerializedSearchProgressItem) => void;\ntype IFileProgressCallback = (p: IFileSearchProgressItem) => void;\n\nexport class SearchService implements IRawSearchService {\n\n\tprivate static readonly BATCH_SIZE = 512;\n\n\tprivate caches: { [cacheKey: string]: Cache } = Object.create(null);\n\n\tconstructor(private readonly processType: IFileSearchStats['type'] = 'searchProcess', private readonly getNumThreads?: () => Promise<number | undefined>) { }\n\n\tfileSearch(config: IRawFileQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\tlet promise: CancelablePromise<ISerializedSearchSuccess>;\n\n\t\tconst query = reviveQuery(config);\n\t\tconst emitter = new Emitter<ISerializedSearchProgressItem | ISerializedSearchComplete>({\n\t\t\tonDidAddFirstListener: () => {\n\t\t\t\tpromise = createCancelablePromise(async token => {\n\t\t\t\t\tconst numThreads = await this.getNumThreads?.();\n\t\t\t\t\treturn this.doFileSearchWithEngine(FileSearchEngine, query, p => emitter.fire(p), token, SearchService.BATCH_SIZE, numThreads);\n\t\t\t\t});\n\n\t\t\t\tpromise.then(\n\t\t\t\t\tc => emitter.fire(c),\n\t\t\t\t\terr => emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\ttextSearch(rawQuery: IRawTextQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\tlet promise: CancelablePromise<ISerializedSearchComplete>;\n\n\t\tconst query = reviveQuery(rawQuery);\n\t\tconst emitter = new Emitter<ISerializedSearchProgressItem | ISerializedSearchComplete>({\n\t\t\tonDidAddFirstListener: () => {\n\t\t\t\tpromise = createCancelablePromise(token => {\n\t\t\t\t\treturn this.ripgrepTextSearch(query, p => emitter.fire(p), token);\n\t\t\t\t});\n\n\t\t\t\tpromise.then(\n\t\t\t\t\tc => emitter.fire(c),\n\t\t\t\t\terr => emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate async ripgrepTextSearch(config: ITextQuery, progressCallback: IProgressCallback, token: CancellationToken): Promise<ISerializedSearchSuccess> {\n\t\tconfig.maxFileSize = this.getPlatformFileLimits().maxFileSize;\n\t\tconst numThreads = await this.getNumThreads?.();\n\t\tconst engine = new TextSearchEngineAdapter(config, numThreads);\n\n\t\treturn engine.search(token, progressCallback, progressCallback);\n\t}\n\n\tprivate getPlatformFileLimits(): { readonly maxFileSize: number } {\n\t\treturn {\n\t\t\tmaxFileSize: 16 * ByteSize.GB\n\t\t};\n\t}\n\n\tdoFileSearch(config: IFileQuery, numThreads: number | undefined, progressCallback: IProgressCallback, token?: CancellationToken): Promise<ISerializedSearchSuccess> {\n\t\treturn this.doFileSearchWithEngine(FileSearchEngine, config, progressCallback, token, SearchService.BATCH_SIZE, numThreads);\n\t}\n\n\tdoFileSearchWithEngine(EngineClass: { new(config: IFileQuery, numThreads?: number | undefined): ISearchEngine<IRawFileMatch> }, config: IFileQuery, progressCallback: IProgressCallback, token?: CancellationToken, batchSize = SearchService.BATCH_SIZE, threads?: number): Promise<ISerializedSearchSuccess> {\n\t\tlet resultCount = 0;\n\t\tconst fileProgressCallback: IFileProgressCallback = progress => {\n\t\t\tif (Array.isArray(progress)) {\n\t\t\t\tresultCount += progress.length;\n\t\t\t\tprogressCallback(progress.map(m => this.rawMatchToSearchItem(m)));\n\t\t\t} else if ((<IRawFileMatch>progress).relativePath) {\n\t\t\t\tresultCount++;\n\t\t\t\tprogressCallback(this.rawMatchToSearchItem(<IRawFileMatch>progress));\n\t\t\t} else {\n\t\t\t\tprogressCallback(<IProgressMessage>progress);\n\t\t\t}\n\t\t};\n\n\t\tif (config.sortByScore) {\n\t\t\tlet sortedSearch = this.trySortedSearchFromCache(config, fileProgressCallback, token);\n\t\t\tif (!sortedSearch) {\n\t\t\t\tconst walkerConfig = config.maxResults ? Object.assign({}, config, { maxResults: null }) : config;\n\t\t\t\tconst engine = new EngineClass(walkerConfig, threads);\n\t\t\t\tsortedSearch = this.doSortedSearch(engine, config, progressCallback, fileProgressCallback, token);\n\t\t\t}\n\n\t\t\treturn new Promise<ISerializedSearchSuccess>((c, e) => {\n\t\t\t\tsortedSearch.then(([result, rawMatches]) => {\n\t\t\t\t\tconst serializedMatches = rawMatches.map(rawMatch => this.rawMatchToSearchItem(rawMatch));\n\t\t\t\t\tthis.sendProgress(serializedMatches, progressCallback, batchSize);\n\t\t\t\t\tc(result);\n\t\t\t\t}, e);\n\t\t\t});\n\t\t}\n\n\t\tconst engine = new EngineClass(config, threads);\n\n\t\treturn this.doSearch(engine, fileProgressCallback, batchSize, token).then(complete => {\n\t\t\treturn {\n\t\t\t\tlimitHit: complete.limitHit,\n\t\t\t\ttype: 'success',\n\t\t\t\tstats: {\n\t\t\t\t\tdetailStats: complete.stats,\n\t\t\t\t\ttype: this.processType,\n\t\t\t\t\tfromCache: false,\n\t\t\t\t\tresultCount,\n\t\t\t\t\tsortingTime: undefined\n\t\t\t\t},\n\t\t\t\tmessages: []\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate rawMatchToSearchItem(match: IRawFileMatch): ISerializedFileMatch {\n\t\treturn { path: match.base ? join(match.base, match.relativePath) : match.relativePath };\n\t}\n\n\tprivate doSortedSearch(engine: ISearchEngine<IRawFileMatch>, config: IFileQuery, progressCallback: IProgressCallback, fileProgressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISerializedSearchSuccess, IRawFileMatch[]]> {\n\t\tconst emitter = new Emitter<IFileSearchProgressItem>();\n\n\t\tlet allResultsPromise = createCancelablePromise(token => {\n\t\t\tlet results: IRawFileMatch[] = [];\n\n\t\t\tconst innerProgressCallback: IFileProgressCallback = progress => {\n\t\t\t\tif (Array.isArray(progress)) {\n\t\t\t\t\tresults = progress;\n\t\t\t\t} else {\n\t\t\t\t\tfileProgressCallback(progress);\n\t\t\t\t\temitter.fire(progress);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn this.doSearch(engine, innerProgressCallback, -1, token)\n\t\t\t\t.then<[ISearchEngineSuccess, IRawFileMatch[]]>(result => {\n\t\t\t\t\treturn [result, results];\n\t\t\t\t});\n\t\t});\n\n\t\tlet cache: Cache;\n\t\tif (config.cacheKey) {\n\t\t\tcache = this.getOrCreateCache(config.cacheKey);\n\t\t\tconst cacheRow: ICacheRow = {\n\t\t\t\tpromise: allResultsPromise,\n\t\t\t\tevent: emitter.event,\n\t\t\t\tresolved: false\n\t\t\t};\n\t\t\tcache.resultsToSearchCache[config.filePattern || ''] = cacheRow;\n\t\t\tallResultsPromise.then(() => {\n\t\t\t\tcacheRow.resolved = true;\n\t\t\t}, err => {\n\t\t\t\tdelete cache.resultsToSearchCache[config.filePattern || ''];\n\t\t\t});\n\n\t\t\tallResultsPromise = this.preventCancellation(allResultsPromise);\n\t\t}\n\n\t\treturn allResultsPromise.then(([result, results]) => {\n\t\t\tconst scorerCache: FuzzyScorerCache = cache ? cache.scorerCache : Object.create(null);\n\t\t\tconst sortSW = (typeof config.maxResults !== 'number' || config.maxResults > 0) && StopWatch.create(false);\n\t\t\treturn this.sortResults(config, results, scorerCache, token)\n\t\t\t\t.then<[ISerializedSearchSuccess, IRawFileMatch[]]>(sortedResults => {\n\t\t\t\t\t// sortingTime: -1 indicates a \"sorted\" search that was not sorted, i.e. populating the cache when quickaccess is opened.\n\t\t\t\t\t// Contrasting with findFiles which is not sorted and will have sortingTime: undefined\n\t\t\t\t\tconst sortingTime = sortSW ? sortSW.elapsed() : -1;\n\n\t\t\t\t\treturn [{\n\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\tstats: {\n\t\t\t\t\t\t\tdetailStats: result.stats,\n\t\t\t\t\t\t\tsortingTime,\n\t\t\t\t\t\t\tfromCache: false,\n\t\t\t\t\t\t\ttype: this.processType,\n\t\t\t\t\t\t\tresultCount: sortedResults.length\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmessages: result.messages,\n\t\t\t\t\t\tlimitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults\n\t\t\t\t\t}, sortedResults];\n\t\t\t\t});\n\t\t});\n\t}\n\n\tprivate getOrCreateCache(cacheKey: string): Cache {\n\t\tconst existing = this.caches[cacheKey];\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\t\treturn this.caches[cacheKey] = new Cache();\n\t}\n\n\tprivate trySortedSearchFromCache(config: IFileQuery, progressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISerializedSearchSuccess, IRawFileMatch[]]> | undefined {\n\t\tconst cache = config.cacheKey && this.caches[config.cacheKey];\n\t\tif (!cache) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst cached = this.getResultsFromCache(cache, config.filePattern || '', progressCallback, token);\n\t\tif (cached) {\n\t\t\treturn cached.then(([result, results, cacheStats]) => {\n\t\t\t\tconst sortSW = StopWatch.create(false);\n\t\t\t\treturn this.sortResults(config, results, cache.scorerCache, token)\n\t\t\t\t\t.then<[ISerializedSearchSuccess, IRawFileMatch[]]>(sortedResults => {\n\t\t\t\t\t\tconst sortingTime = sortSW.elapsed();\n\t\t\t\t\t\tconst stats: IFileSearchStats = {\n\t\t\t\t\t\t\tfromCache: true,\n\t\t\t\t\t\t\tdetailStats: cacheStats,\n\t\t\t\t\t\t\ttype: this.processType,\n\t\t\t\t\t\t\tresultCount: results.length,\n\t\t\t\t\t\t\tsortingTime\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\t\t\tlimitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults,\n\t\t\t\t\t\t\t\tstats,\n\t\t\t\t\t\t\t\tmessages: [],\n\t\t\t\t\t\t\t} satisfies ISerializedSearchSuccess,\n\t\t\t\t\t\t\tsortedResults\n\t\t\t\t\t\t];\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate sortResults(config: IFileQuery, results: IRawFileMatch[], scorerCache: FuzzyScorerCache, token?: CancellationToken): Promise<IRawFileMatch[]> {\n\t\t// we use the same compare function that is used later when showing the results using fuzzy scoring\n\t\t// this is very important because we are also limiting the number of results by config.maxResults\n\t\t// and as such we want the top items to be included in this result set if the number of items\n\t\t// exceeds config.maxResults.\n\t\tconst query = prepareQuery(config.filePattern || '');\n\t\tconst compare = (matchA: IRawFileMatch, matchB: IRawFileMatch) => compareItemsByFuzzyScore(matchA, matchB, query, true, FileMatchItemAccessor, scorerCache);\n\n\t\tconst maxResults = typeof config.maxResults === 'number' ? config.maxResults : DEFAULT_MAX_SEARCH_RESULTS;\n\t\treturn arrays.topAsync(results, compare, maxResults, 10000, token);\n\t}\n\n\tprivate sendProgress(results: ISerializedFileMatch[], progressCb: IProgressCallback, batchSize: number) {\n\t\tif (batchSize && batchSize > 0) {\n\t\t\tfor (let i = 0; i < results.length; i += batchSize) {\n\t\t\t\tprogressCb(results.slice(i, i + batchSize));\n\t\t\t}\n\t\t} else {\n\t\t\tprogressCb(results);\n\t\t}\n\t}\n\n\tprivate getResultsFromCache(cache: Cache, searchValue: string, progressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISearchEngineSuccess, IRawFileMatch[], ICachedSearchStats]> | null {\n\t\tconst cacheLookupSW = StopWatch.create(false);\n\n\t\t// Find cache entries by prefix of search value\n\t\tconst hasPathSep = searchValue.indexOf(sep) >= 0;\n\t\tlet cachedRow: ICacheRow | undefined;\n\t\tfor (const previousSearch in cache.resultsToSearchCache) {\n\t\t\t// If we narrow down, we might be able to reuse the cached results\n\t\t\tif (searchValue.startsWith(previousSearch)) {\n\t\t\t\tif (hasPathSep && previousSearch.indexOf(sep) < 0 && previousSearch !== '') {\n\t\t\t\t\tcontinue; // since a path character widens the search for potential more matches, require it in previous search too\n\t\t\t\t}\n\n\t\t\t\tconst row = cache.resultsToSearchCache[previousSearch];\n\t\t\t\tcachedRow = {\n\t\t\t\t\tpromise: this.preventCancellation(row.promise),\n\t\t\t\t\tevent: row.event,\n\t\t\t\t\tresolved: row.resolved\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!cachedRow) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cacheLookupTime = cacheLookupSW.elapsed();\n\t\tconst cacheFilterSW = StopWatch.create(false);\n\n\t\tconst listener = cachedRow.event(progressCallback);\n\t\tif (token) {\n\t\t\ttoken.onCancellationRequested(() => {\n\t\t\t\tlistener.dispose();\n\t\t\t});\n\t\t}\n\n\t\treturn cachedRow.promise.then<[ISearchEngineSuccess, IRawFileMatch[], ICachedSearchStats]>(([complete, cachedEntries]) => {\n\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\tthrow canceled();\n\t\t\t}\n\n\t\t\t// Pattern match on results\n\t\t\tconst results: IRawFileMatch[] = [];\n\t\t\tconst normalizedSearchValueLowercase = prepareQuery(searchValue).normalizedLowercase;\n\t\t\tfor (const entry of cachedEntries) {\n\n\t\t\t\t// Check if this entry is a match for the search value\n\t\t\t\tif (!isFilePatternMatch(entry, normalizedSearchValueLowercase)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tresults.push(entry);\n\t\t\t}\n\n\t\t\treturn [complete, results, {\n\t\t\t\tcacheWasResolved: cachedRow.resolved,\n\t\t\t\tcacheLookupTime,\n\t\t\t\tcacheFilterTime: cacheFilterSW.elapsed(),\n\t\t\t\tcacheEntryCount: cachedEntries.length\n\t\t\t}];\n\t\t});\n\t}\n\n\n\n\tprivate doSearch(engine: ISearchEngine<IRawFileMatch>, progressCallback: IFileProgressCallback, batchSize: number, token?: CancellationToken): Promise<ISearchEngineSuccess> {\n\t\treturn new Promise<ISearchEngineSuccess>((c, e) => {\n\t\t\tlet batch: IRawFileMatch[] = [];\n\t\t\ttoken?.onCancellationRequested(() => engine.cancel());\n\n\t\t\tengine.search((match) => {\n\t\t\t\tif (match) {\n\t\t\t\t\tif (batchSize) {\n\t\t\t\t\t\tbatch.push(match);\n\t\t\t\t\t\tif (batchSize > 0 && batch.length >= batchSize) {\n\t\t\t\t\t\t\tprogressCallback(batch);\n\t\t\t\t\t\t\tbatch = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprogressCallback(match);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, (progress) => {\n\t\t\t\tprogressCallback(progress);\n\t\t\t}, (error, complete) => {\n\t\t\t\tif (batch.length) {\n\t\t\t\t\tprogressCallback(batch);\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprogressCallback({ message: 'Search finished. Error: ' + error.message });\n\t\t\t\t\te(error);\n\t\t\t\t} else {\n\t\t\t\t\tprogressCallback({ message: 'Search finished. Stats: ' + JSON.stringify(complete.stats) });\n\t\t\t\t\tc(complete);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tclearCache(cacheKey: string): Promise<void> {\n\t\tdelete this.caches[cacheKey];\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\t/**\n\t * Return a CancelablePromise which is not actually cancelable\n\t * TODO@rob - Is this really needed?\n\t */\n\tprivate preventCancellation<C>(promise: CancelablePromise<C>): CancelablePromise<C> {\n\t\treturn new class implements CancelablePromise<C> {\n\t\t\tget [Symbol.toStringTag]() { return this.toString(); }\n\t\t\tcancel() {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\tthen<TResult1 = C, TResult2 = never>(resolve?: ((value: C) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\t\treturn promise.then(resolve, reject);\n\t\t\t}\n\t\t\tcatch(reject?: any) {\n\t\t\t\treturn this.then(undefined, reject);\n\t\t\t}\n\t\t\tfinally(onFinally: any) {\n\t\t\t\treturn promise.finally(onFinally);\n\t\t\t}\n\t\t};\n\t}\n}\n\ninterface ICacheRow {\n\t// TODO@roblou - never actually canceled\n\tpromise: CancelablePromise<[ISearchEngineSuccess, IRawFileMatch[]]>;\n\tresolved: boolean;\n\treadonly event: Event<IFileSearchProgressItem>;\n}\n\nclass Cache {\n\n\tresultsToSearchCache: { [searchValue: string]: ICacheRow } = Object.create(null);\n\n\tscorerCache: FuzzyScorerCache = Object.create(null);\n}\n\nconst FileMatchItemAccessor = new class implements IItemAccessor<IRawFileMatch> {\n\n\tgetItemLabel(match: IRawFileMatch): string {\n\t\treturn basename(match.relativePath); // e.g. myFile.txt\n\t}\n\n\tgetItemDescription(match: IRawFileMatch): string {\n\t\treturn dirname(match.relativePath); // e.g. some/path/to/file\n\t}\n\n\tgetItemPath(match: IRawFileMatch): string {\n\t\treturn match.relativePath; // e.g. some/path/to/file/myFile.txt\n\t}\n};\n\nfunction reviveQuery<U extends IRawQuery>(rawQuery: U): U extends IRawTextQuery ? ITextQuery : IFileQuery {\n\treturn {\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t...<any>rawQuery, // TODO\n\t\t...{\n\t\t\tfolderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),\n\t\t\textraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map(components => URI.revive(components))\n\t\t}\n\t};\n}\n\nfunction reviveFolderQuery(rawFolderQuery: IFolderQuery<UriComponents>): IFolderQuery<URI> {\n\treturn revive(rawFolderQuery);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { CancelablePromise, createCancelablePromise } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { canceled } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { compareItemsByFuzzyScore, FuzzyScorerCache, IItemAccessor, prepareQuery } from '../../../../base/common/fuzzyScorer.js';\nimport { revive } from '../../../../base/common/marshalling.js';\nimport { basename, dirname, join, sep } from '../../../../base/common/path.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { URI, UriComponents } from '../../../../base/common/uri.js';\nimport { ByteSize } from '../../../../platform/files/common/files.js';\nimport { DEFAULT_MAX_SEARCH_RESULTS, ICachedSearchStats, IFileQuery, IFileSearchProgressItem, IFileSearchStats, IFolderQuery, IProgressMessage, IRawFileMatch, IRawFileQuery, IRawQuery, IRawSearchService, IRawTextQuery, ISearchEngine, ISearchEngineSuccess, ISerializedFileMatch, ISerializedSearchComplete, ISerializedSearchProgressItem, ISerializedSearchSuccess, isFilePatternMatch, ITextQuery } from '../common/search.js';\nimport { Engine as FileSearchEngine } from './fileSearch.js';\nimport { TextSearchEngineAdapter } from './textSearchAdapter.js';\n\nexport type IProgressCallback = (p: ISerializedSearchProgressItem) => void;\ntype IFileProgressCallback = (p: IFileSearchProgressItem) => void;\n\nexport class SearchService implements IRawSearchService {\n\n\tprivate static readonly BATCH_SIZE = 512;\n\n\tprivate caches: { [cacheKey: string]: Cache } = Object.create(null);\n\n\tconstructor(private readonly processType: IFileSearchStats['type'] = 'searchProcess', private readonly getNumThreads?: () => Promise<number | undefined>) { }\n\n\tfileSearch(config: IRawFileQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\tlet promise: CancelablePromise<ISerializedSearchSuccess>;\n\n\t\tconst query = reviveQuery(config);\n\t\tconst emitter = new Emitter<ISerializedSearchProgressItem | ISerializedSearchComplete>({\n\t\t\tonDidAddFirstListener: () => {\n\t\t\t\tpromise = createCancelablePromise(async token => {\n\t\t\t\t\tconst numThreads = await this.getNumThreads?.();\n\t\t\t\t\treturn this.doFileSearchWithEngine(FileSearchEngine, query, p => emitter.fire(p), token, SearchService.BATCH_SIZE, numThreads);\n\t\t\t\t});\n\n\t\t\t\tpromise.then(\n\t\t\t\t\tc => emitter.fire(c),\n\t\t\t\t\terr => emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\ttextSearch(rawQuery: IRawTextQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\tlet promise: CancelablePromise<ISerializedSearchComplete>;\n\n\t\tconst query = reviveQuery(rawQuery);\n\t\tconst emitter = new Emitter<ISerializedSearchProgressItem | ISerializedSearchComplete>({\n\t\t\tonDidAddFirstListener: () => {\n\t\t\t\tpromise = createCancelablePromise(token => {\n\t\t\t\t\treturn this.ripgrepTextSearch(query, p => emitter.fire(p), token);\n\t\t\t\t});\n\n\t\t\t\tpromise.then(\n\t\t\t\t\tc => emitter.fire(c),\n\t\t\t\t\terr => emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate async ripgrepTextSearch(config: ITextQuery, progressCallback: IProgressCallback, token: CancellationToken): Promise<ISerializedSearchSuccess> {\n\t\tconfig.maxFileSize = this.getPlatformFileLimits().maxFileSize;\n\t\tconst numThreads = await this.getNumThreads?.();\n\t\tconst engine = new TextSearchEngineAdapter(config, numThreads);\n\n\t\treturn engine.search(token, progressCallback, progressCallback);\n\t}\n\n\tprivate getPlatformFileLimits(): { readonly maxFileSize: number } {\n\t\treturn {\n\t\t\tmaxFileSize: 16 * ByteSize.GB\n\t\t};\n\t}\n\n\tdoFileSearch(config: IFileQuery, numThreads: number | undefined, progressCallback: IProgressCallback, token?: CancellationToken): Promise<ISerializedSearchSuccess> {\n\t\treturn this.doFileSearchWithEngine(FileSearchEngine, config, progressCallback, token, SearchService.BATCH_SIZE, numThreads);\n\t}\n\n\tdoFileSearchWithEngine(EngineClass: { new(config: IFileQuery, numThreads?: number | undefined): ISearchEngine<IRawFileMatch> }, config: IFileQuery, progressCallback: IProgressCallback, token?: CancellationToken, batchSize = SearchService.BATCH_SIZE, threads?: number): Promise<ISerializedSearchSuccess> {\n\t\tlet resultCount = 0;\n\t\tconst fileProgressCallback: IFileProgressCallback = progress => {\n\t\t\tif (Array.isArray(progress)) {\n\t\t\t\tresultCount += progress.length;\n\t\t\t\tprogressCallback(progress.map(m => this.rawMatchToSearchItem(m)));\n\t\t\t} else if ((<IRawFileMatch>progress).relativePath) {\n\t\t\t\tresultCount++;\n\t\t\t\tprogressCallback(this.rawMatchToSearchItem(<IRawFileMatch>progress));\n\t\t\t} else {\n\t\t\t\tprogressCallback(<IProgressMessage>progress);\n\t\t\t}\n\t\t};\n\n\t\tif (config.sortByScore) {\n\t\t\tlet sortedSearch = this.trySortedSearchFromCache(config, fileProgressCallback, token);\n\t\t\tif (!sortedSearch) {\n\t\t\t\tconst walkerConfig = config.maxResults ? Object.assign({}, config, { maxResults: null }) : config;\n\t\t\t\tconst engine = new EngineClass(walkerConfig, threads);\n\t\t\t\tsortedSearch = this.doSortedSearch(engine, config, progressCallback, fileProgressCallback, token);\n\t\t\t}\n\n\t\t\treturn new Promise<ISerializedSearchSuccess>((c, e) => {\n\t\t\t\tsortedSearch.then(([result, rawMatches]) => {\n\t\t\t\t\tconst serializedMatches = rawMatches.map(rawMatch => this.rawMatchToSearchItem(rawMatch));\n\t\t\t\t\tthis.sendProgress(serializedMatches, progressCallback, batchSize);\n\t\t\t\t\tc(result);\n\t\t\t\t}, e);\n\t\t\t});\n\t\t}\n\n\t\tconst engine = new EngineClass(config, threads);\n\n\t\treturn this.doSearch(engine, fileProgressCallback, batchSize, token).then(complete => {\n\t\t\treturn {\n\t\t\t\tlimitHit: complete.limitHit,\n\t\t\t\ttype: 'success',\n\t\t\t\tstats: {\n\t\t\t\t\tdetailStats: complete.stats,\n\t\t\t\t\ttype: this.processType,\n\t\t\t\t\tfromCache: false,\n\t\t\t\t\tresultCount,\n\t\t\t\t\tsortingTime: undefined\n\t\t\t\t},\n\t\t\t\tmessages: []\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate rawMatchToSearchItem(match: IRawFileMatch): ISerializedFileMatch {\n\t\treturn { path: match.base ? join(match.base, match.relativePath) : match.relativePath };\n\t}\n\n\tprivate doSortedSearch(engine: ISearchEngine<IRawFileMatch>, config: IFileQuery, progressCallback: IProgressCallback, fileProgressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISerializedSearchSuccess, IRawFileMatch[]]> {\n\t\tconst emitter = new Emitter<IFileSearchProgressItem>();\n\n\t\tlet allResultsPromise = createCancelablePromise(token => {\n\t\t\tlet results: IRawFileMatch[] = [];\n\n\t\t\tconst innerProgressCallback: IFileProgressCallback = progress => {\n\t\t\t\tif (Array.isArray(progress)) {\n\t\t\t\t\tresults = progress;\n\t\t\t\t} else {\n\t\t\t\t\tfileProgressCallback(progress);\n\t\t\t\t\temitter.fire(progress);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn this.doSearch(engine, innerProgressCallback, -1, token)\n\t\t\t\t.then<[ISearchEngineSuccess, IRawFileMatch[]]>(result => {\n\t\t\t\t\treturn [result, results];\n\t\t\t\t});\n\t\t});\n\n\t\tlet cache: Cache;\n\t\tif (config.cacheKey) {\n\t\t\tcache = this.getOrCreateCache(config.cacheKey);\n\t\t\tconst cacheRow: ICacheRow = {\n\t\t\t\tpromise: allResultsPromise,\n\t\t\t\tevent: emitter.event,\n\t\t\t\tresolved: false\n\t\t\t};\n\t\t\tcache.resultsToSearchCache[config.filePattern || ''] = cacheRow;\n\t\t\tallResultsPromise.then(() => {\n\t\t\t\tcacheRow.resolved = true;\n\t\t\t}, err => {\n\t\t\t\tdelete cache.resultsToSearchCache[config.filePattern || ''];\n\t\t\t});\n\n\t\t\tallResultsPromise = this.preventCancellation(allResultsPromise);\n\t\t}\n\n\t\treturn allResultsPromise.then(([result, results]) => {\n\t\t\tconst scorerCache: FuzzyScorerCache = cache ? cache.scorerCache : Object.create(null);\n\t\t\tconst sortSW = (typeof config.maxResults !== 'number' || config.maxResults > 0) && StopWatch.create(false);\n\t\t\treturn this.sortResults(config, results, scorerCache, token)\n\t\t\t\t.then<[ISerializedSearchSuccess, IRawFileMatch[]]>(sortedResults => {\n\t\t\t\t\t// sortingTime: -1 indicates a \"sorted\" search that was not sorted, i.e. populating the cache when quickaccess is opened.\n\t\t\t\t\t// Contrasting with findFiles which is not sorted and will have sortingTime: undefined\n\t\t\t\t\tconst sortingTime = sortSW ? sortSW.elapsed() : -1;\n\n\t\t\t\t\treturn [{\n\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\tstats: {\n\t\t\t\t\t\t\tdetailStats: result.stats,\n\t\t\t\t\t\t\tsortingTime,\n\t\t\t\t\t\t\tfromCache: false,\n\t\t\t\t\t\t\ttype: this.processType,\n\t\t\t\t\t\t\tresultCount: sortedResults.length\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmessages: result.messages,\n\t\t\t\t\t\tlimitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults\n\t\t\t\t\t}, sortedResults];\n\t\t\t\t});\n\t\t});\n\t}\n\n\tprivate getOrCreateCache(cacheKey: string): Cache {\n\t\tconst existing = this.caches[cacheKey];\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\t\treturn this.caches[cacheKey] = new Cache();\n\t}\n\n\tprivate trySortedSearchFromCache(config: IFileQuery, progressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISerializedSearchSuccess, IRawFileMatch[]]> | undefined {\n\t\tconst cache = config.cacheKey && this.caches[config.cacheKey];\n\t\tif (!cache) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst cached = this.getResultsFromCache(cache, config.filePattern || '', progressCallback, token);\n\t\tif (cached) {\n\t\t\treturn cached.then(([result, results, cacheStats]) => {\n\t\t\t\tconst sortSW = StopWatch.create(false);\n\t\t\t\treturn this.sortResults(config, results, cache.scorerCache, token)\n\t\t\t\t\t.then<[ISerializedSearchSuccess, IRawFileMatch[]]>(sortedResults => {\n\t\t\t\t\t\tconst sortingTime = sortSW.elapsed();\n\t\t\t\t\t\tconst stats: IFileSearchStats = {\n\t\t\t\t\t\t\tfromCache: true,\n\t\t\t\t\t\t\tdetailStats: cacheStats,\n\t\t\t\t\t\t\ttype: this.processType,\n\t\t\t\t\t\t\tresultCount: results.length,\n\t\t\t\t\t\t\tsortingTime\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\t\t\tlimitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults,\n\t\t\t\t\t\t\t\tstats,\n\t\t\t\t\t\t\t\tmessages: [],\n\t\t\t\t\t\t\t} satisfies ISerializedSearchSuccess,\n\t\t\t\t\t\t\tsortedResults\n\t\t\t\t\t\t];\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate sortResults(config: IFileQuery, results: IRawFileMatch[], scorerCache: FuzzyScorerCache, token?: CancellationToken): Promise<IRawFileMatch[]> {\n\t\t// we use the same compare function that is used later when showing the results using fuzzy scoring\n\t\t// this is very important because we are also limiting the number of results by config.maxResults\n\t\t// and as such we want the top items to be included in this result set if the number of items\n\t\t// exceeds config.maxResults.\n\t\tconst query = prepareQuery(config.filePattern || '');\n\t\tconst compare = (matchA: IRawFileMatch, matchB: IRawFileMatch) => compareItemsByFuzzyScore(matchA, matchB, query, true, FileMatchItemAccessor, scorerCache);\n\n\t\tconst maxResults = typeof config.maxResults === 'number' ? config.maxResults : DEFAULT_MAX_SEARCH_RESULTS;\n\t\treturn arrays.topAsync(results, compare, maxResults, 10000, token);\n\t}\n\n\tprivate sendProgress(results: ISerializedFileMatch[], progressCb: IProgressCallback, batchSize: number) {\n\t\tif (batchSize && batchSize > 0) {\n\t\t\tfor (let i = 0; i < results.length; i += batchSize) {\n\t\t\t\tprogressCb(results.slice(i, i + batchSize));\n\t\t\t}\n\t\t} else {\n\t\t\tprogressCb(results);\n\t\t}\n\t}\n\n\tprivate getResultsFromCache(cache: Cache, searchValue: string, progressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISearchEngineSuccess, IRawFileMatch[], ICachedSearchStats]> | null {\n\t\tconst cacheLookupSW = StopWatch.create(false);\n\n\t\t// Find cache entries by prefix of search value\n\t\tconst hasPathSep = searchValue.indexOf(sep) >= 0;\n\t\tlet cachedRow: ICacheRow | undefined;\n\t\tfor (const previousSearch in cache.resultsToSearchCache) {\n\t\t\t// If we narrow down, we might be able to reuse the cached results\n\t\t\tif (searchValue.startsWith(previousSearch)) {\n\t\t\t\tif (hasPathSep && previousSearch.indexOf(sep) < 0 && previousSearch !== '') {\n\t\t\t\t\tcontinue; // since a path character widens the search for potential more matches, require it in previous search too\n\t\t\t\t}\n\n\t\t\t\tconst row = cache.resultsToSearchCache[previousSearch];\n\t\t\t\tcachedRow = {\n\t\t\t\t\tpromise: this.preventCancellation(row.promise),\n\t\t\t\t\tevent: row.event,\n\t\t\t\t\tresolved: row.resolved\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!cachedRow) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cacheLookupTime = cacheLookupSW.elapsed();\n\t\tconst cacheFilterSW = StopWatch.create(false);\n\n\t\tconst listener = cachedRow.event(progressCallback);\n\t\tif (token) {\n\t\t\ttoken.onCancellationRequested(() => {\n\t\t\t\tlistener.dispose();\n\t\t\t});\n\t\t}\n\n\t\treturn cachedRow.promise.then<[ISearchEngineSuccess, IRawFileMatch[], ICachedSearchStats]>(([complete, cachedEntries]) => {\n\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\tthrow canceled();\n\t\t\t}\n\n\t\t\t// Pattern match on results\n\t\t\tconst results: IRawFileMatch[] = [];\n\t\t\tconst normalizedSearchValueLowercase = prepareQuery(searchValue).normalizedLowercase;\n\t\t\tfor (const entry of cachedEntries) {\n\n\t\t\t\t// Check if this entry is a match for the search value\n\t\t\t\tif (!isFilePatternMatch(entry, normalizedSearchValueLowercase)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tresults.push(entry);\n\t\t\t}\n\n\t\t\treturn [complete, results, {\n\t\t\t\tcacheWasResolved: cachedRow.resolved,\n\t\t\t\tcacheLookupTime,\n\t\t\t\tcacheFilterTime: cacheFilterSW.elapsed(),\n\t\t\t\tcacheEntryCount: cachedEntries.length\n\t\t\t}];\n\t\t});\n\t}\n\n\n\n\tprivate doSearch(engine: ISearchEngine<IRawFileMatch>, progressCallback: IFileProgressCallback, batchSize: number, token?: CancellationToken): Promise<ISearchEngineSuccess> {\n\t\treturn new Promise<ISearchEngineSuccess>((c, e) => {\n\t\t\tlet batch: IRawFileMatch[] = [];\n\t\t\ttoken?.onCancellationRequested(() => engine.cancel());\n\n\t\t\tengine.search((match) => {\n\t\t\t\tif (match) {\n\t\t\t\t\tif (batchSize) {\n\t\t\t\t\t\tbatch.push(match);\n\t\t\t\t\t\tif (batchSize > 0 && batch.length >= batchSize) {\n\t\t\t\t\t\t\tprogressCallback(batch);\n\t\t\t\t\t\t\tbatch = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprogressCallback(match);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, (progress) => {\n\t\t\t\tprogressCallback(progress);\n\t\t\t}, (error, complete) => {\n\t\t\t\tif (batch.length) {\n\t\t\t\t\tprogressCallback(batch);\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprogressCallback({ message: 'Search finished. Error: ' + error.message });\n\t\t\t\t\te(error);\n\t\t\t\t} else {\n\t\t\t\t\tprogressCallback({ message: 'Search finished. Stats: ' + JSON.stringify(complete.stats) });\n\t\t\t\t\tc(complete);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tclearCache(cacheKey: string): Promise<void> {\n\t\tdelete this.caches[cacheKey];\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\t/**\n\t * Return a CancelablePromise which is not actually cancelable\n\t * TODO@rob - Is this really needed?\n\t */\n\tprivate preventCancellation<C>(promise: CancelablePromise<C>): CancelablePromise<C> {\n\t\treturn new class implements CancelablePromise<C> {\n\t\t\tget [Symbol.toStringTag]() { return this.toString(); }\n\t\t\tcancel() {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\tthen<TResult1 = C, TResult2 = never>(resolve?: ((value: C) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\t\treturn promise.then(resolve, reject);\n\t\t\t}\n\t\t\tcatch(reject?: any) {\n\t\t\t\treturn this.then(undefined, reject);\n\t\t\t}\n\t\t\tfinally(onFinally: any) {\n\t\t\t\treturn promise.finally(onFinally);\n\t\t\t}\n\t\t};\n\t}\n}\n\ninterface ICacheRow {\n\t// TODO@roblou - never actually canceled\n\tpromise: CancelablePromise<[ISearchEngineSuccess, IRawFileMatch[]]>;\n\tresolved: boolean;\n\treadonly event: Event<IFileSearchProgressItem>;\n}\n\nclass Cache {\n\n\tresultsToSearchCache: { [searchValue: string]: ICacheRow } = Object.create(null);\n\n\tscorerCache: FuzzyScorerCache = Object.create(null);\n}\n\nconst FileMatchItemAccessor = new class implements IItemAccessor<IRawFileMatch> {\n\n\tgetItemLabel(match: IRawFileMatch): string {\n\t\treturn basename(match.relativePath); // e.g. myFile.txt\n\t}\n\n\tgetItemDescription(match: IRawFileMatch): string {\n\t\treturn dirname(match.relativePath); // e.g. some/path/to/file\n\t}\n\n\tgetItemPath(match: IRawFileMatch): string {\n\t\treturn match.relativePath; // e.g. some/path/to/file/myFile.txt\n\t}\n};\n\nfunction reviveQuery<U extends IRawQuery>(rawQuery: U): U extends IRawTextQuery ? ITextQuery : IFileQuery {\n\treturn {\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t...<any>rawQuery, // TODO\n\t\t...{\n\t\t\tfolderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),\n\t\t\textraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map(components => URI.revive(components))\n\t\t}\n\t};\n}\n\nfunction reviveFolderQuery(rawFolderQuery: IFolderQuery<UriComponents>): IFolderQuery<URI> {\n\treturn revive(rawFolderQuery);\n}\n"]}