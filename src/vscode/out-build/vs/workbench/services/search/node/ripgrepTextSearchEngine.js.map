{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/node/ripgrepTextSearchEngine.ts","vs/workbench/services/search/node/ripgrepTextSearchEngine.ts"],"names":[],"mappings":"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","file":"ripgrepTextSearchEngine.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { EventEmitter } from 'events';\nimport { StringDecoder } from 'string_decoder';\nimport { coalesce, mapArrayOrNot } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { groupBy } from '../../../../base/common/collections.js';\nimport { splitGlobAware } from '../../../../base/common/glob.js';\nimport { createRegExp, escapeRegExpCharacters } from '../../../../base/common/strings.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Progress } from '../../../../platform/progress/common/progress.js';\nimport { DEFAULT_MAX_SEARCH_RESULTS, IExtendedExtensionSearchOptions, ITextSearchPreviewOptions, SearchError, SearchErrorCode, serializeSearchError, TextSearchMatch } from '../common/search.js';\nimport { Range, TextSearchComplete2, TextSearchContext2, TextSearchMatch2, TextSearchProviderOptions, TextSearchQuery2, TextSearchResult2 } from '../common/searchExtTypes.js';\nimport { AST as ReAST, RegExpParser, RegExpVisitor } from 'vscode-regexpp';\nimport { rgPath } from '@vscode/ripgrep';\nimport { anchorGlob, IOutputChannel, Maybe, rangeToSearchRange, searchRangeToRange } from './ripgrepSearchUtils.js';\nimport type { RipgrepTextSearchOptions } from '../common/searchExtTypesInternal.js';\nimport { newToOldPreviewOptions } from '../common/searchExtConversionTypes.js';\n\n// If @vscode/ripgrep is in an .asar file, then the binary is unpacked.\nconst rgDiskPath = rgPath.replace(/\\bnode_modules\\.asar\\b/, 'node_modules.asar.unpacked');\n\nexport class RipgrepTextSearchEngine {\n\n\tconstructor(private outputChannel: IOutputChannel, private readonly _numThreads?: number | undefined) { }\n\n\tprovideTextSearchResults(query: TextSearchQuery2, options: TextSearchProviderOptions, progress: Progress<TextSearchResult2>, token: CancellationToken): Promise<TextSearchComplete2> {\n\t\treturn Promise.all(options.folderOptions.map(folderOption => {\n\t\t\tconst extendedOptions: RipgrepTextSearchOptions = {\n\t\t\t\tfolderOptions: folderOption,\n\t\t\t\tnumThreads: this._numThreads,\n\t\t\t\tmaxResults: options.maxResults,\n\t\t\t\tpreviewOptions: options.previewOptions,\n\t\t\t\tmaxFileSize: options.maxFileSize,\n\t\t\t\tsurroundingContext: options.surroundingContext\n\t\t\t};\n\t\t\treturn this.provideTextSearchResultsWithRgOptions(query, extendedOptions, progress, token);\n\t\t})).then((e => {\n\t\t\tconst complete: TextSearchComplete2 = {\n\t\t\t\t// todo: get this to actually check\n\t\t\t\tlimitHit: e.some(complete => !!complete && complete.limitHit)\n\t\t\t};\n\t\t\treturn complete;\n\t\t}));\n\t}\n\n\tprovideTextSearchResultsWithRgOptions(query: TextSearchQuery2, options: RipgrepTextSearchOptions, progress: Progress<TextSearchResult2>, token: CancellationToken): Promise<TextSearchComplete2> {\n\t\tthis.outputChannel.appendLine(`provideTextSearchResults ${query.pattern}, ${JSON.stringify({\n\t\t\t...options,\n\t\t\t...{\n\t\t\t\tfolder: options.folderOptions.folder.toString()\n\t\t\t}\n\t\t})}`);\n\n\t\tif (!query.pattern) {\n\t\t\treturn Promise.resolve({ limitHit: false });\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttoken.onCancellationRequested(() => cancel());\n\n\t\t\tconst extendedOptions: RipgrepTextSearchOptions = {\n\t\t\t\t...options,\n\t\t\t\tnumThreads: this._numThreads\n\t\t\t};\n\t\t\tconst rgArgs = getRgArgs(query, extendedOptions);\n\n\t\t\tconst cwd = options.folderOptions.folder.fsPath;\n\n\t\t\tconst escapedArgs = rgArgs\n\t\t\t\t.map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n\t\t\t\t.join(' ');\n\t\t\tthis.outputChannel.appendLine(`${rgDiskPath} ${escapedArgs}\\n - cwd: ${cwd}`);\n\n\t\t\tlet rgProc: Maybe<cp.ChildProcess> = cp.spawn(rgDiskPath, rgArgs, { cwd });\n\t\t\trgProc.on('error', e => {\n\t\t\t\tconsole.error(e);\n\t\t\t\tthis.outputChannel.appendLine('Error: ' + (e && e.message));\n\t\t\t\treject(serializeSearchError(new SearchError(e && e.message, SearchErrorCode.rgProcessError)));\n\t\t\t});\n\n\t\t\tlet gotResult = false;\n\t\t\tconst ripgrepParser = new RipgrepParser(options.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS, options.folderOptions.folder, newToOldPreviewOptions(options.previewOptions));\n\t\t\tripgrepParser.on('result', (match: TextSearchResult2) => {\n\t\t\t\tgotResult = true;\n\t\t\t\tdataWithoutResult = '';\n\t\t\t\tprogress.report(match);\n\t\t\t});\n\n\t\t\tlet isDone = false;\n\t\t\tconst cancel = () => {\n\t\t\t\tisDone = true;\n\n\t\t\t\trgProc?.kill();\n\n\t\t\t\tripgrepParser?.cancel();\n\t\t\t};\n\n\t\t\tlet limitHit = false;\n\t\t\tripgrepParser.on('hitLimit', () => {\n\t\t\t\tlimitHit = true;\n\t\t\t\tcancel();\n\t\t\t});\n\n\t\t\tlet dataWithoutResult = '';\n\t\t\trgProc.stdout!.on('data', data => {\n\t\t\t\tripgrepParser.handleData(data);\n\t\t\t\tif (!gotResult) {\n\t\t\t\t\tdataWithoutResult += data;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlet gotData = false;\n\t\t\trgProc.stdout!.once('data', () => gotData = true);\n\n\t\t\tlet stderr = '';\n\t\t\trgProc.stderr!.on('data', data => {\n\t\t\t\tconst message = data.toString();\n\t\t\t\tthis.outputChannel.appendLine(message);\n\n\t\t\t\tif (stderr.length + message.length < 1e6) {\n\t\t\t\t\tstderr += message;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trgProc.on('close', () => {\n\t\t\t\tthis.outputChannel.appendLine(gotData ? 'Got data from stdout' : 'No data from stdout');\n\t\t\t\tthis.outputChannel.appendLine(gotResult ? 'Got result from parser' : 'No result from parser');\n\t\t\t\tif (dataWithoutResult) {\n\t\t\t\t\tthis.outputChannel.appendLine(`Got data without result: ${dataWithoutResult}`);\n\t\t\t\t}\n\n\t\t\t\tthis.outputChannel.appendLine('');\n\n\t\t\t\tif (isDone) {\n\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t} else {\n\t\t\t\t\t// Trigger last result\n\t\t\t\t\tripgrepParser.flush();\n\t\t\t\t\trgProc = null;\n\t\t\t\t\tlet searchError: Maybe<SearchError>;\n\t\t\t\t\tif (stderr && !gotData && (searchError = rgErrorMsgForDisplay(stderr))) {\n\t\t\t\t\t\treject(serializeSearchError(new SearchError(searchError.message, searchError.code)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\n/**\n * Read the first line of stderr and return an error for display or undefined, based on a list of\n * allowed properties.\n * Ripgrep produces stderr output which is not from a fatal error, and we only want the search to be\n * \"failed\" when a fatal error was produced.\n */\nfunction rgErrorMsgForDisplay(msg: string): Maybe<SearchError> {\n\tconst lines = msg.split('\\n');\n\tconst firstLine = lines[0].trim();\n\n\tif (lines.some(l => l.startsWith('regex parse error'))) {\n\t\treturn new SearchError(buildRegexParseError(lines), SearchErrorCode.regexParseError);\n\t}\n\n\tconst match = firstLine.match(/grep config error: unknown encoding: (.*)/);\n\tif (match) {\n\t\treturn new SearchError(`Unknown encoding: ${match[1]}`, SearchErrorCode.unknownEncoding);\n\t}\n\n\tif (firstLine.startsWith('error parsing glob')) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), SearchErrorCode.globParseError);\n\t}\n\n\tif (firstLine.startsWith('the literal')) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), SearchErrorCode.invalidLiteral);\n\t}\n\n\tif (firstLine.startsWith('PCRE2: error compiling pattern')) {\n\t\treturn new SearchError(firstLine, SearchErrorCode.regexParseError);\n\t}\n\n\treturn undefined;\n}\n\nfunction buildRegexParseError(lines: string[]): string {\n\tconst errorMessage: string[] = ['Regex parse error'];\n\tconst pcre2ErrorLine = lines.filter(l => (l.startsWith('PCRE2:')));\n\tif (pcre2ErrorLine.length >= 1) {\n\t\tconst pcre2ErrorMessage = pcre2ErrorLine[0].replace('PCRE2:', '');\n\t\tif (pcre2ErrorMessage.indexOf(':') !== -1 && pcre2ErrorMessage.split(':').length >= 2) {\n\t\t\tconst pcre2ActualErrorMessage = pcre2ErrorMessage.split(':')[1];\n\t\t\terrorMessage.push(':' + pcre2ActualErrorMessage);\n\t\t}\n\t}\n\n\treturn errorMessage.join('');\n}\n\n\nexport class RipgrepParser extends EventEmitter {\n\tprivate remainder = '';\n\tprivate isDone = false;\n\tprivate hitLimit = false;\n\tprivate stringDecoder: StringDecoder;\n\n\tprivate numResults = 0;\n\n\tconstructor(private maxResults: number, private root: URI, private previewOptions: ITextSearchPreviewOptions) {\n\t\tsuper();\n\t\tthis.stringDecoder = new StringDecoder();\n\t}\n\n\tcancel(): void {\n\t\tthis.isDone = true;\n\t}\n\n\tflush(): void {\n\t\tthis.handleDecodedData(this.stringDecoder.end());\n\t}\n\n\n\toverride on(event: 'result', listener: (result: TextSearchResult2) => void): this;\n\toverride on(event: 'hitLimit', listener: () => void): this;\n\toverride on(event: string, listener: (...args: any[]) => void): this {\n\t\tsuper.on(event, listener);\n\t\treturn this;\n\t}\n\n\thandleData(data: Buffer | string): void {\n\t\tif (this.isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst dataStr = typeof data === 'string' ? data : this.stringDecoder.write(data);\n\t\tthis.handleDecodedData(dataStr);\n\t}\n\n\tprivate handleDecodedData(decodedData: string): void {\n\t\t// check for newline before appending to remainder\n\t\tlet newlineIdx = decodedData.indexOf('\\n');\n\n\t\t// If the previous data chunk didn't end in a newline, prepend it to this chunk\n\t\tconst dataStr = this.remainder + decodedData;\n\n\t\tif (newlineIdx >= 0) {\n\t\t\tnewlineIdx += this.remainder.length;\n\t\t} else {\n\t\t\t// Shortcut\n\t\t\tthis.remainder = dataStr;\n\t\t\treturn;\n\t\t}\n\n\t\tlet prevIdx = 0;\n\t\twhile (newlineIdx >= 0) {\n\t\t\tthis.handleLine(dataStr.substring(prevIdx, newlineIdx).trim());\n\t\t\tprevIdx = newlineIdx + 1;\n\t\t\tnewlineIdx = dataStr.indexOf('\\n', prevIdx);\n\t\t}\n\n\t\tthis.remainder = dataStr.substring(prevIdx);\n\t}\n\n\n\tprivate handleLine(outputLine: string): void {\n\t\tif (this.isDone || !outputLine) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet parsedLine: IRgMessage;\n\t\ttry {\n\t\t\tparsedLine = JSON.parse(outputLine);\n\t\t} catch (e) {\n\t\t\tthrow new Error(`malformed line from rg: ${outputLine}`);\n\t\t}\n\n\t\tif (parsedLine.type === 'match') {\n\t\t\tconst matchPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.joinPath(this.root, matchPath);\n\t\t\tconst result = this.createTextSearchMatch(parsedLine.data, uri);\n\t\t\tthis.onResult(result);\n\n\t\t\tif (this.hitLimit) {\n\t\t\t\tthis.cancel();\n\t\t\t\tthis.emit('hitLimit');\n\t\t\t}\n\t\t} else if (parsedLine.type === 'context') {\n\t\t\tconst contextPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.joinPath(this.root, contextPath);\n\t\t\tconst result = this.createTextSearchContexts(parsedLine.data, uri);\n\t\t\tresult.forEach(r => this.onResult(r));\n\t\t}\n\t}\n\n\tprivate createTextSearchMatch(data: IRgMatch, uri: URI): TextSearchMatch2 {\n\t\tconst lineNumber = data.line_number - 1;\n\t\tconst fullText = bytesOrTextToString(data.lines);\n\t\tconst fullTextBytes = Buffer.from(fullText);\n\n\t\tlet prevMatchEnd = 0;\n\t\tlet prevMatchEndCol = 0;\n\t\tlet prevMatchEndLine = lineNumber;\n\n\t\t// it looks like certain regexes can match a line, but cause rg to not\n\t\t// emit any specific submatches for that line.\n\t\t// https://github.com/microsoft/vscode/issues/100569#issuecomment-738496991\n\t\tif (data.submatches.length === 0) {\n\t\t\tdata.submatches.push(\n\t\t\t\tfullText.length\n\t\t\t\t\t? { start: 0, end: 1, match: { text: fullText[0] } }\n\t\t\t\t\t: { start: 0, end: 0, match: { text: '' } }\n\t\t\t);\n\t\t}\n\n\t\tconst ranges = coalesce(data.submatches.map((match, i) => {\n\t\t\tif (this.hitLimit) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tthis.numResults++;\n\t\t\tif (this.numResults >= this.maxResults) {\n\t\t\t\t// Finish the line, then report the result below\n\t\t\t\tthis.hitLimit = true;\n\t\t\t}\n\n\t\t\tconst matchText = bytesOrTextToString(match.match);\n\n\t\t\tconst inBetweenText = fullTextBytes.slice(prevMatchEnd, match.start).toString();\n\t\t\tconst inBetweenStats = getNumLinesAndLastNewlineLength(inBetweenText);\n\t\t\tconst startCol = inBetweenStats.numLines > 0 ?\n\t\t\t\tinBetweenStats.lastLineLength :\n\t\t\t\tinBetweenStats.lastLineLength + prevMatchEndCol;\n\n\t\t\tconst stats = getNumLinesAndLastNewlineLength(matchText);\n\t\t\tconst startLineNumber = inBetweenStats.numLines + prevMatchEndLine;\n\t\t\tconst endLineNumber = stats.numLines + startLineNumber;\n\t\t\tconst endCol = stats.numLines > 0 ?\n\t\t\t\tstats.lastLineLength :\n\t\t\t\tstats.lastLineLength + startCol;\n\n\t\t\tprevMatchEnd = match.end;\n\t\t\tprevMatchEndCol = endCol;\n\t\t\tprevMatchEndLine = endLineNumber;\n\n\t\t\treturn new Range(startLineNumber, startCol, endLineNumber, endCol);\n\t\t}));\n\n\t\tconst searchRange = mapArrayOrNot(<Range[]>ranges, rangeToSearchRange);\n\n\t\tconst internalResult = new TextSearchMatch(fullText, searchRange, this.previewOptions);\n\t\treturn new TextSearchMatch2(\n\t\t\turi,\n\t\t\tinternalResult.rangeLocations.map(e => (\n\t\t\t\t{\n\t\t\t\t\tsourceRange: searchRangeToRange(e.source),\n\t\t\t\t\tpreviewRange: searchRangeToRange(e.preview),\n\t\t\t\t}\n\t\t\t)),\n\t\t\tinternalResult.previewText);\n\t}\n\n\tprivate createTextSearchContexts(data: IRgMatch, uri: URI): TextSearchContext2[] {\n\t\tconst text = bytesOrTextToString(data.lines);\n\t\tconst startLine = data.line_number;\n\t\treturn text\n\t\t\t.replace(/\\r?\\n$/, '')\n\t\t\t.split('\\n')\n\t\t\t.map((line, i) => new TextSearchContext2(uri, line, startLine + i));\n\t}\n\n\tprivate onResult(match: TextSearchResult2): void {\n\t\tthis.emit('result', match);\n\t}\n}\n\nfunction bytesOrTextToString(obj: any): string {\n\treturn obj.bytes ?\n\t\tBuffer.from(obj.bytes, 'base64').toString() :\n\t\tobj.text;\n}\n\nfunction getNumLinesAndLastNewlineLength(text: string): { numLines: number; lastLineLength: number } {\n\tconst re = /\\n/g;\n\tlet numLines = 0;\n\tlet lastNewlineIdx = -1;\n\tlet match: ReturnType<typeof re.exec>;\n\twhile (match = re.exec(text)) {\n\t\tnumLines++;\n\t\tlastNewlineIdx = match.index;\n\t}\n\n\tconst lastLineLength = lastNewlineIdx >= 0 ?\n\t\ttext.length - lastNewlineIdx - 1 :\n\t\ttext.length;\n\n\treturn { numLines, lastLineLength };\n}\n\n// exported for testing\nexport function getRgArgs(query: TextSearchQuery2, options: RipgrepTextSearchOptions): string[] {\n\tconst args = ['--hidden', '--no-require-git'];\n\targs.push(query.isCaseSensitive ? '--case-sensitive' : '--ignore-case');\n\n\tconst { doubleStarIncludes, otherIncludes } = groupBy(\n\t\toptions.folderOptions.includes,\n\t\t(include: string) => include.startsWith('**') ? 'doubleStarIncludes' : 'otherIncludes');\n\n\tif (otherIncludes && otherIncludes.length) {\n\t\tconst uniqueOthers = new Set<string>();\n\t\totherIncludes.forEach(other => { uniqueOthers.add(other); });\n\n\t\targs.push('-g', '!*');\n\t\tuniqueOthers\n\t\t\t.forEach(otherIncude => {\n\t\t\t\tspreadGlobComponents(otherIncude)\n\t\t\t\t\t.map(anchorGlob)\n\t\t\t\t\t.forEach(globArg => {\n\t\t\t\t\t\targs.push('-g', globArg);\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\tif (doubleStarIncludes && doubleStarIncludes.length) {\n\t\tdoubleStarIncludes.forEach(globArg => {\n\t\t\targs.push('-g', globArg);\n\t\t});\n\t}\n\n\toptions.folderOptions.excludes.map(e => typeof (e) === 'string' ? e : e.pattern)\n\t\t.map(anchorGlob)\n\t\t.forEach(rgGlob => args.push('-g', `!${rgGlob}`));\n\n\tif (options.maxFileSize) {\n\t\targs.push('--max-filesize', options.maxFileSize + '');\n\t}\n\n\tif (options.folderOptions.useIgnoreFiles.local) {\n\t\tif (!options.folderOptions.useIgnoreFiles.parent) {\n\t\t\targs.push('--no-ignore-parent');\n\t\t}\n\t} else {\n\t\t// Don't use .gitignore or .ignore\n\t\targs.push('--no-ignore');\n\t}\n\n\tif (options.folderOptions.followSymlinks) {\n\t\targs.push('--follow');\n\t}\n\n\tif (options.folderOptions.encoding && options.folderOptions.encoding !== 'utf8') {\n\t\targs.push('--encoding', options.folderOptions.encoding);\n\t}\n\n\tif (options.numThreads) {\n\t\targs.push('--threads', `${options.numThreads}`);\n\t}\n\n\t// Ripgrep handles -- as a -- arg separator. Only --.\n\t// - is ok, --- is ok, --some-flag is also ok. Need to special case.\n\tif (query.pattern === '--') {\n\t\tquery.isRegExp = true;\n\t\tquery.pattern = '\\\\-\\\\-';\n\t}\n\n\tif (query.isMultiline && !query.isRegExp) {\n\t\tquery.pattern = escapeRegExpCharacters(query.pattern);\n\t\tquery.isRegExp = true;\n\t}\n\n\tif ((<IExtendedExtensionSearchOptions>options).usePCRE2) {\n\t\targs.push('--pcre2');\n\t}\n\n\t// Allow $ to match /r/n\n\targs.push('--crlf');\n\n\tif (query.isRegExp) {\n\t\tquery.pattern = unicodeEscapesToPCRE2(query.pattern);\n\t\targs.push('--engine', 'auto');\n\t}\n\n\tlet searchPatternAfterDoubleDashes: Maybe<string>;\n\tif (query.isWordMatch) {\n\t\tconst regexp = createRegExp(query.pattern, !!query.isRegExp, { wholeWord: query.isWordMatch });\n\t\tconst regexpStr = regexp.source.replace(/\\\\\\//g, '/'); // RegExp.source arbitrarily returns escaped slashes. Search and destroy.\n\t\targs.push('--regexp', regexpStr);\n\t} else if (query.isRegExp) {\n\t\tlet fixedRegexpQuery = fixRegexNewline(query.pattern);\n\t\tfixedRegexpQuery = fixNewline(fixedRegexpQuery);\n\t\targs.push('--regexp', fixedRegexpQuery);\n\t} else {\n\t\tsearchPatternAfterDoubleDashes = query.pattern;\n\t\targs.push('--fixed-strings');\n\t}\n\n\targs.push('--no-config');\n\tif (!options.folderOptions.useIgnoreFiles.global) {\n\t\targs.push('--no-ignore-global');\n\t}\n\n\targs.push('--json');\n\n\tif (query.isMultiline) {\n\t\targs.push('--multiline');\n\t}\n\n\tif (options.surroundingContext) {\n\t\targs.push('--before-context', options.surroundingContext + '');\n\t\targs.push('--after-context', options.surroundingContext + '');\n\t}\n\n\t// Folder to search\n\targs.push('--');\n\n\tif (searchPatternAfterDoubleDashes) {\n\t\t// Put the query after --, in case the query starts with a dash\n\t\targs.push(searchPatternAfterDoubleDashes);\n\t}\n\n\targs.push('.');\n\n\treturn args;\n}\n\n/**\n * `\"foo/*bar/something\"` -> `[\"foo\", \"foo/*bar\", \"foo/*bar/something\", \"foo/*bar/something/**\"]`\n */\nfunction spreadGlobComponents(globComponent: string): string[] {\n\tconst globComponentWithBraceExpansion = performBraceExpansionForRipgrep(globComponent);\n\n\treturn globComponentWithBraceExpansion.flatMap((globArg) => {\n\t\tconst components = splitGlobAware(globArg, '/');\n\t\treturn components.map((_, i) => components.slice(0, i + 1).join('/'));\n\t});\n\n}\n\nexport function unicodeEscapesToPCRE2(pattern: string): string {\n\t// Match \\u1234\n\tconst unicodePattern = /((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u([a-z0-9]{4})/gi;\n\n\twhile (pattern.match(unicodePattern)) {\n\t\tpattern = pattern.replace(unicodePattern, `$1\\\\x{$2}`);\n\t}\n\n\t// Match \\u{1234}\n\t// \\u with 5-6 characters will be left alone because \\x only takes 4 characters.\n\tconst unicodePatternWithBraces = /((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u\\{([a-z0-9]{4})\\}/gi;\n\twhile (pattern.match(unicodePatternWithBraces)) {\n\t\tpattern = pattern.replace(unicodePatternWithBraces, `$1\\\\x{$2}`);\n\t}\n\n\treturn pattern;\n}\n\nexport interface IRgMessage {\n\ttype: 'match' | 'context' | string;\n\tdata: IRgMatch;\n}\n\nexport interface IRgMatch {\n\tpath: IRgBytesOrText;\n\tlines: IRgBytesOrText;\n\tline_number: number;\n\tabsolute_offset: number;\n\tsubmatches: IRgSubmatch[];\n}\n\nexport interface IRgSubmatch {\n\tmatch: IRgBytesOrText;\n\tstart: number;\n\tend: number;\n}\n\nexport type IRgBytesOrText = { bytes: string } | { text: string };\n\nconst isLookBehind = (node: ReAST.Node) => node.type === 'Assertion' && node.kind === 'lookbehind';\n\nexport function fixRegexNewline(pattern: string): string {\n\t// we parse the pattern anew each tiem\n\tlet re: ReAST.Pattern;\n\ttry {\n\t\tre = new RegExpParser().parsePattern(pattern);\n\t} catch {\n\t\treturn pattern;\n\t}\n\n\tlet output = '';\n\tlet lastEmittedIndex = 0;\n\tconst replace = (start: number, end: number, text: string) => {\n\t\toutput += pattern.slice(lastEmittedIndex, start) + text;\n\t\tlastEmittedIndex = end;\n\t};\n\n\tconst context: ReAST.Node[] = [];\n\tconst visitor = new RegExpVisitor({\n\t\tonCharacterEnter(char) {\n\t\t\tif (char.raw !== '\\\\n') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst parent = context[0];\n\t\t\tif (!parent) {\n\t\t\t\t// simple char, \\n -> \\r?\\n\n\t\t\t\treplace(char.start, char.end, '\\\\r?\\\\n');\n\t\t\t} else if (context.some(isLookBehind)) {\n\t\t\t\t// no-op in a lookbehind, see #100569\n\t\t\t} else if (parent.type === 'CharacterClass') {\n\t\t\t\tif (parent.negate) {\n\t\t\t\t\t// negative bracket expr, [^a-z\\n] -> (?![a-z]|\\r?\\n)\n\t\t\t\t\tconst otherContent = pattern.slice(parent.start + 2, char.start) + pattern.slice(char.end, parent.end - 1);\n\t\t\t\t\tif (parent.parent?.type === 'Quantifier') {\n\t\t\t\t\t\t// If quantified, we can't use a negative lookahead in a quantifier.\n\t\t\t\t\t\t// But `.` already doesn't match new lines, so we can just use that\n\t\t\t\t\t\t// (with any other negations) instead.\n\t\t\t\t\t\treplace(parent.start, parent.end, otherContent ? `[^${otherContent}]` : '.');\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplace(parent.start, parent.end, '(?!\\\\r?\\\\n' + (otherContent ? `|[${otherContent}]` : '') + ')');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// positive bracket expr, [a-z\\n] -> (?:[a-z]|\\r?\\n)\n\t\t\t\t\tconst otherContent = pattern.slice(parent.start + 1, char.start) + pattern.slice(char.end, parent.end - 1);\n\t\t\t\t\treplace(parent.start, parent.end, otherContent === '' ? '\\\\r?\\\\n' : `(?:[${otherContent}]|\\\\r?\\\\n)`);\n\t\t\t\t}\n\t\t\t} else if (parent.type === 'Quantifier') {\n\t\t\t\treplace(char.start, char.end, '(?:\\\\r?\\\\n)');\n\t\t\t}\n\t\t},\n\t\tonQuantifierEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonQuantifierLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonCharacterClassRangeEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonCharacterClassRangeLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonCharacterClassEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonCharacterClassLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonAssertionEnter(node) {\n\t\t\tif (isLookBehind(node)) {\n\t\t\t\tcontext.push(node);\n\t\t\t}\n\t\t},\n\t\tonAssertionLeave(node) {\n\t\t\tif (context[0] === node) {\n\t\t\t\tcontext.shift();\n\t\t\t}\n\t\t},\n\t});\n\n\tvisitor.visit(re);\n\toutput += pattern.slice(lastEmittedIndex);\n\treturn output;\n}\n\nexport function fixNewline(pattern: string): string {\n\treturn pattern.replace(/\\n/g, '\\\\r?\\\\n');\n}\n\n// brace expansion for ripgrep\n\n/**\n * Split string given first opportunity for brace expansion in the string.\n * - If the brace is prepended by a \\ character, then it is escaped.\n * - Does not process escapes that are within the sub-glob.\n * - If two unescaped `{` occur before `}`, then ripgrep will return an error for brace nesting, so don't split on those.\n */\nfunction getEscapeAwareSplitStringForRipgrep(pattern: string): { fixedStart?: string; strInBraces: string; fixedEnd?: string } {\n\tlet inBraces = false;\n\tlet escaped = false;\n\tlet fixedStart = '';\n\tlet strInBraces = '';\n\tfor (let i = 0; i < pattern.length; i++) {\n\t\tconst char = pattern[i];\n\t\tswitch (char) {\n\t\t\tcase '\\\\':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// If we're already escaped, then just leave the escaped slash and the preceeding slash that escapes it.\n\t\t\t\t\t// The two escaped slashes will result in a single slash and whatever processes the glob later will properly process the escape\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += '\\\\' + char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += '\\\\' + char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else {\n\t\t\t\t\tescaped = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// if we escaped this opening bracket, then it is to be taken literally. Remove the `\\` because we've acknowleged it and add the `{` to the appropriate string\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\t// ripgrep treats this as attempting to do a nested alternate group, which is invalid. Return with pattern including changes from escaped braces.\n\t\t\t\t\t\treturn { strInBraces: fixedStart + '{' + strInBraces + '{' + pattern.substring(i + 1) };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// same as `}`, but for closing bracket\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else if (inBraces) {\n\t\t\t\t\t// we found an end bracket to a valid opening bracket. Return the appropriate strings.\n\t\t\t\t\treturn { fixedStart, strInBraces, fixedEnd: pattern.substring(i + 1) };\n\t\t\t\t} else {\n\t\t\t\t\t// if we're not in braces and not escaped, then this is a literal `}` character and we're still adding to fixedStart.\n\t\t\t\t\tfixedStart += char;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// similar to the `\\\\` case, we didn't do anything with the escape, so we should re-insert it into the appropriate string\n\t\t\t\t// to be consumed later when individual parts of the glob are processed\n\t\t\t\tif (inBraces) {\n\t\t\t\t\tstrInBraces += (escaped ? '\\\\' : '') + char;\n\t\t\t\t} else {\n\t\t\t\t\tfixedStart += (escaped ? '\\\\' : '') + char;\n\t\t\t\t}\n\t\t\t\tescaped = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t// we are haven't hit the last brace, so no splitting should occur. Return with pattern including changes from escaped braces.\n\treturn { strInBraces: fixedStart + (inBraces ? ('{' + strInBraces) : '') };\n}\n\n/**\n * Parses out curly braces and returns equivalent globs. Only supports one level of nesting.\n * Exported for testing.\n */\nexport function performBraceExpansionForRipgrep(pattern: string): string[] {\n\tconst { fixedStart, strInBraces, fixedEnd } = getEscapeAwareSplitStringForRipgrep(pattern);\n\tif (fixedStart === undefined || fixedEnd === undefined) {\n\t\treturn [strInBraces];\n\t}\n\n\tlet arr = splitGlobAware(strInBraces, ',');\n\n\tif (!arr.length) {\n\t\t// occurs if the braces are empty.\n\t\tarr = [''];\n\t}\n\n\tconst ends = performBraceExpansionForRipgrep(fixedEnd);\n\n\treturn arr.flatMap((elem) => {\n\t\tconst start = fixedStart + elem;\n\t\treturn ends.map((end) => {\n\t\t\treturn start + end;\n\t\t});\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { EventEmitter } from 'events';\nimport { StringDecoder } from 'string_decoder';\nimport { coalesce, mapArrayOrNot } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { groupBy } from '../../../../base/common/collections.js';\nimport { splitGlobAware } from '../../../../base/common/glob.js';\nimport { createRegExp, escapeRegExpCharacters } from '../../../../base/common/strings.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Progress } from '../../../../platform/progress/common/progress.js';\nimport { DEFAULT_MAX_SEARCH_RESULTS, IExtendedExtensionSearchOptions, ITextSearchPreviewOptions, SearchError, SearchErrorCode, serializeSearchError, TextSearchMatch } from '../common/search.js';\nimport { Range, TextSearchComplete2, TextSearchContext2, TextSearchMatch2, TextSearchProviderOptions, TextSearchQuery2, TextSearchResult2 } from '../common/searchExtTypes.js';\nimport { AST as ReAST, RegExpParser, RegExpVisitor } from 'vscode-regexpp';\nimport { rgPath } from '@vscode/ripgrep';\nimport { anchorGlob, IOutputChannel, Maybe, rangeToSearchRange, searchRangeToRange } from './ripgrepSearchUtils.js';\nimport type { RipgrepTextSearchOptions } from '../common/searchExtTypesInternal.js';\nimport { newToOldPreviewOptions } from '../common/searchExtConversionTypes.js';\n\n// If @vscode/ripgrep is in an .asar file, then the binary is unpacked.\nconst rgDiskPath = rgPath.replace(/\\bnode_modules\\.asar\\b/, 'node_modules.asar.unpacked');\n\nexport class RipgrepTextSearchEngine {\n\n\tconstructor(private outputChannel: IOutputChannel, private readonly _numThreads?: number | undefined) { }\n\n\tprovideTextSearchResults(query: TextSearchQuery2, options: TextSearchProviderOptions, progress: Progress<TextSearchResult2>, token: CancellationToken): Promise<TextSearchComplete2> {\n\t\treturn Promise.all(options.folderOptions.map(folderOption => {\n\t\t\tconst extendedOptions: RipgrepTextSearchOptions = {\n\t\t\t\tfolderOptions: folderOption,\n\t\t\t\tnumThreads: this._numThreads,\n\t\t\t\tmaxResults: options.maxResults,\n\t\t\t\tpreviewOptions: options.previewOptions,\n\t\t\t\tmaxFileSize: options.maxFileSize,\n\t\t\t\tsurroundingContext: options.surroundingContext\n\t\t\t};\n\t\t\treturn this.provideTextSearchResultsWithRgOptions(query, extendedOptions, progress, token);\n\t\t})).then((e => {\n\t\t\tconst complete: TextSearchComplete2 = {\n\t\t\t\t// todo: get this to actually check\n\t\t\t\tlimitHit: e.some(complete => !!complete && complete.limitHit)\n\t\t\t};\n\t\t\treturn complete;\n\t\t}));\n\t}\n\n\tprovideTextSearchResultsWithRgOptions(query: TextSearchQuery2, options: RipgrepTextSearchOptions, progress: Progress<TextSearchResult2>, token: CancellationToken): Promise<TextSearchComplete2> {\n\t\tthis.outputChannel.appendLine(`provideTextSearchResults ${query.pattern}, ${JSON.stringify({\n\t\t\t...options,\n\t\t\t...{\n\t\t\t\tfolder: options.folderOptions.folder.toString()\n\t\t\t}\n\t\t})}`);\n\n\t\tif (!query.pattern) {\n\t\t\treturn Promise.resolve({ limitHit: false });\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttoken.onCancellationRequested(() => cancel());\n\n\t\t\tconst extendedOptions: RipgrepTextSearchOptions = {\n\t\t\t\t...options,\n\t\t\t\tnumThreads: this._numThreads\n\t\t\t};\n\t\t\tconst rgArgs = getRgArgs(query, extendedOptions);\n\n\t\t\tconst cwd = options.folderOptions.folder.fsPath;\n\n\t\t\tconst escapedArgs = rgArgs\n\t\t\t\t.map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n\t\t\t\t.join(' ');\n\t\t\tthis.outputChannel.appendLine(`${rgDiskPath} ${escapedArgs}\\n - cwd: ${cwd}`);\n\n\t\t\tlet rgProc: Maybe<cp.ChildProcess> = cp.spawn(rgDiskPath, rgArgs, { cwd });\n\t\t\trgProc.on('error', e => {\n\t\t\t\tconsole.error(e);\n\t\t\t\tthis.outputChannel.appendLine('Error: ' + (e && e.message));\n\t\t\t\treject(serializeSearchError(new SearchError(e && e.message, SearchErrorCode.rgProcessError)));\n\t\t\t});\n\n\t\t\tlet gotResult = false;\n\t\t\tconst ripgrepParser = new RipgrepParser(options.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS, options.folderOptions.folder, newToOldPreviewOptions(options.previewOptions));\n\t\t\tripgrepParser.on('result', (match: TextSearchResult2) => {\n\t\t\t\tgotResult = true;\n\t\t\t\tdataWithoutResult = '';\n\t\t\t\tprogress.report(match);\n\t\t\t});\n\n\t\t\tlet isDone = false;\n\t\t\tconst cancel = () => {\n\t\t\t\tisDone = true;\n\n\t\t\t\trgProc?.kill();\n\n\t\t\t\tripgrepParser?.cancel();\n\t\t\t};\n\n\t\t\tlet limitHit = false;\n\t\t\tripgrepParser.on('hitLimit', () => {\n\t\t\t\tlimitHit = true;\n\t\t\t\tcancel();\n\t\t\t});\n\n\t\t\tlet dataWithoutResult = '';\n\t\t\trgProc.stdout!.on('data', data => {\n\t\t\t\tripgrepParser.handleData(data);\n\t\t\t\tif (!gotResult) {\n\t\t\t\t\tdataWithoutResult += data;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlet gotData = false;\n\t\t\trgProc.stdout!.once('data', () => gotData = true);\n\n\t\t\tlet stderr = '';\n\t\t\trgProc.stderr!.on('data', data => {\n\t\t\t\tconst message = data.toString();\n\t\t\t\tthis.outputChannel.appendLine(message);\n\n\t\t\t\tif (stderr.length + message.length < 1e6) {\n\t\t\t\t\tstderr += message;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trgProc.on('close', () => {\n\t\t\t\tthis.outputChannel.appendLine(gotData ? 'Got data from stdout' : 'No data from stdout');\n\t\t\t\tthis.outputChannel.appendLine(gotResult ? 'Got result from parser' : 'No result from parser');\n\t\t\t\tif (dataWithoutResult) {\n\t\t\t\t\tthis.outputChannel.appendLine(`Got data without result: ${dataWithoutResult}`);\n\t\t\t\t}\n\n\t\t\t\tthis.outputChannel.appendLine('');\n\n\t\t\t\tif (isDone) {\n\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t} else {\n\t\t\t\t\t// Trigger last result\n\t\t\t\t\tripgrepParser.flush();\n\t\t\t\t\trgProc = null;\n\t\t\t\t\tlet searchError: Maybe<SearchError>;\n\t\t\t\t\tif (stderr && !gotData && (searchError = rgErrorMsgForDisplay(stderr))) {\n\t\t\t\t\t\treject(serializeSearchError(new SearchError(searchError.message, searchError.code)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\n/**\n * Read the first line of stderr and return an error for display or undefined, based on a list of\n * allowed properties.\n * Ripgrep produces stderr output which is not from a fatal error, and we only want the search to be\n * \"failed\" when a fatal error was produced.\n */\nfunction rgErrorMsgForDisplay(msg: string): Maybe<SearchError> {\n\tconst lines = msg.split('\\n');\n\tconst firstLine = lines[0].trim();\n\n\tif (lines.some(l => l.startsWith('regex parse error'))) {\n\t\treturn new SearchError(buildRegexParseError(lines), SearchErrorCode.regexParseError);\n\t}\n\n\tconst match = firstLine.match(/grep config error: unknown encoding: (.*)/);\n\tif (match) {\n\t\treturn new SearchError(`Unknown encoding: ${match[1]}`, SearchErrorCode.unknownEncoding);\n\t}\n\n\tif (firstLine.startsWith('error parsing glob')) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), SearchErrorCode.globParseError);\n\t}\n\n\tif (firstLine.startsWith('the literal')) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), SearchErrorCode.invalidLiteral);\n\t}\n\n\tif (firstLine.startsWith('PCRE2: error compiling pattern')) {\n\t\treturn new SearchError(firstLine, SearchErrorCode.regexParseError);\n\t}\n\n\treturn undefined;\n}\n\nfunction buildRegexParseError(lines: string[]): string {\n\tconst errorMessage: string[] = ['Regex parse error'];\n\tconst pcre2ErrorLine = lines.filter(l => (l.startsWith('PCRE2:')));\n\tif (pcre2ErrorLine.length >= 1) {\n\t\tconst pcre2ErrorMessage = pcre2ErrorLine[0].replace('PCRE2:', '');\n\t\tif (pcre2ErrorMessage.indexOf(':') !== -1 && pcre2ErrorMessage.split(':').length >= 2) {\n\t\t\tconst pcre2ActualErrorMessage = pcre2ErrorMessage.split(':')[1];\n\t\t\terrorMessage.push(':' + pcre2ActualErrorMessage);\n\t\t}\n\t}\n\n\treturn errorMessage.join('');\n}\n\n\nexport class RipgrepParser extends EventEmitter {\n\tprivate remainder = '';\n\tprivate isDone = false;\n\tprivate hitLimit = false;\n\tprivate stringDecoder: StringDecoder;\n\n\tprivate numResults = 0;\n\n\tconstructor(private maxResults: number, private root: URI, private previewOptions: ITextSearchPreviewOptions) {\n\t\tsuper();\n\t\tthis.stringDecoder = new StringDecoder();\n\t}\n\n\tcancel(): void {\n\t\tthis.isDone = true;\n\t}\n\n\tflush(): void {\n\t\tthis.handleDecodedData(this.stringDecoder.end());\n\t}\n\n\n\toverride on(event: 'result', listener: (result: TextSearchResult2) => void): this;\n\toverride on(event: 'hitLimit', listener: () => void): this;\n\toverride on(event: string, listener: (...args: any[]) => void): this {\n\t\tsuper.on(event, listener);\n\t\treturn this;\n\t}\n\n\thandleData(data: Buffer | string): void {\n\t\tif (this.isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst dataStr = typeof data === 'string' ? data : this.stringDecoder.write(data);\n\t\tthis.handleDecodedData(dataStr);\n\t}\n\n\tprivate handleDecodedData(decodedData: string): void {\n\t\t// check for newline before appending to remainder\n\t\tlet newlineIdx = decodedData.indexOf('\\n');\n\n\t\t// If the previous data chunk didn't end in a newline, prepend it to this chunk\n\t\tconst dataStr = this.remainder + decodedData;\n\n\t\tif (newlineIdx >= 0) {\n\t\t\tnewlineIdx += this.remainder.length;\n\t\t} else {\n\t\t\t// Shortcut\n\t\t\tthis.remainder = dataStr;\n\t\t\treturn;\n\t\t}\n\n\t\tlet prevIdx = 0;\n\t\twhile (newlineIdx >= 0) {\n\t\t\tthis.handleLine(dataStr.substring(prevIdx, newlineIdx).trim());\n\t\t\tprevIdx = newlineIdx + 1;\n\t\t\tnewlineIdx = dataStr.indexOf('\\n', prevIdx);\n\t\t}\n\n\t\tthis.remainder = dataStr.substring(prevIdx);\n\t}\n\n\n\tprivate handleLine(outputLine: string): void {\n\t\tif (this.isDone || !outputLine) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet parsedLine: IRgMessage;\n\t\ttry {\n\t\t\tparsedLine = JSON.parse(outputLine);\n\t\t} catch (e) {\n\t\t\tthrow new Error(`malformed line from rg: ${outputLine}`);\n\t\t}\n\n\t\tif (parsedLine.type === 'match') {\n\t\t\tconst matchPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.joinPath(this.root, matchPath);\n\t\t\tconst result = this.createTextSearchMatch(parsedLine.data, uri);\n\t\t\tthis.onResult(result);\n\n\t\t\tif (this.hitLimit) {\n\t\t\t\tthis.cancel();\n\t\t\t\tthis.emit('hitLimit');\n\t\t\t}\n\t\t} else if (parsedLine.type === 'context') {\n\t\t\tconst contextPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.joinPath(this.root, contextPath);\n\t\t\tconst result = this.createTextSearchContexts(parsedLine.data, uri);\n\t\t\tresult.forEach(r => this.onResult(r));\n\t\t}\n\t}\n\n\tprivate createTextSearchMatch(data: IRgMatch, uri: URI): TextSearchMatch2 {\n\t\tconst lineNumber = data.line_number - 1;\n\t\tconst fullText = bytesOrTextToString(data.lines);\n\t\tconst fullTextBytes = Buffer.from(fullText);\n\n\t\tlet prevMatchEnd = 0;\n\t\tlet prevMatchEndCol = 0;\n\t\tlet prevMatchEndLine = lineNumber;\n\n\t\t// it looks like certain regexes can match a line, but cause rg to not\n\t\t// emit any specific submatches for that line.\n\t\t// https://github.com/microsoft/vscode/issues/100569#issuecomment-738496991\n\t\tif (data.submatches.length === 0) {\n\t\t\tdata.submatches.push(\n\t\t\t\tfullText.length\n\t\t\t\t\t? { start: 0, end: 1, match: { text: fullText[0] } }\n\t\t\t\t\t: { start: 0, end: 0, match: { text: '' } }\n\t\t\t);\n\t\t}\n\n\t\tconst ranges = coalesce(data.submatches.map((match, i) => {\n\t\t\tif (this.hitLimit) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tthis.numResults++;\n\t\t\tif (this.numResults >= this.maxResults) {\n\t\t\t\t// Finish the line, then report the result below\n\t\t\t\tthis.hitLimit = true;\n\t\t\t}\n\n\t\t\tconst matchText = bytesOrTextToString(match.match);\n\n\t\t\tconst inBetweenText = fullTextBytes.slice(prevMatchEnd, match.start).toString();\n\t\t\tconst inBetweenStats = getNumLinesAndLastNewlineLength(inBetweenText);\n\t\t\tconst startCol = inBetweenStats.numLines > 0 ?\n\t\t\t\tinBetweenStats.lastLineLength :\n\t\t\t\tinBetweenStats.lastLineLength + prevMatchEndCol;\n\n\t\t\tconst stats = getNumLinesAndLastNewlineLength(matchText);\n\t\t\tconst startLineNumber = inBetweenStats.numLines + prevMatchEndLine;\n\t\t\tconst endLineNumber = stats.numLines + startLineNumber;\n\t\t\tconst endCol = stats.numLines > 0 ?\n\t\t\t\tstats.lastLineLength :\n\t\t\t\tstats.lastLineLength + startCol;\n\n\t\t\tprevMatchEnd = match.end;\n\t\t\tprevMatchEndCol = endCol;\n\t\t\tprevMatchEndLine = endLineNumber;\n\n\t\t\treturn new Range(startLineNumber, startCol, endLineNumber, endCol);\n\t\t}));\n\n\t\tconst searchRange = mapArrayOrNot(<Range[]>ranges, rangeToSearchRange);\n\n\t\tconst internalResult = new TextSearchMatch(fullText, searchRange, this.previewOptions);\n\t\treturn new TextSearchMatch2(\n\t\t\turi,\n\t\t\tinternalResult.rangeLocations.map(e => (\n\t\t\t\t{\n\t\t\t\t\tsourceRange: searchRangeToRange(e.source),\n\t\t\t\t\tpreviewRange: searchRangeToRange(e.preview),\n\t\t\t\t}\n\t\t\t)),\n\t\t\tinternalResult.previewText);\n\t}\n\n\tprivate createTextSearchContexts(data: IRgMatch, uri: URI): TextSearchContext2[] {\n\t\tconst text = bytesOrTextToString(data.lines);\n\t\tconst startLine = data.line_number;\n\t\treturn text\n\t\t\t.replace(/\\r?\\n$/, '')\n\t\t\t.split('\\n')\n\t\t\t.map((line, i) => new TextSearchContext2(uri, line, startLine + i));\n\t}\n\n\tprivate onResult(match: TextSearchResult2): void {\n\t\tthis.emit('result', match);\n\t}\n}\n\nfunction bytesOrTextToString(obj: any): string {\n\treturn obj.bytes ?\n\t\tBuffer.from(obj.bytes, 'base64').toString() :\n\t\tobj.text;\n}\n\nfunction getNumLinesAndLastNewlineLength(text: string): { numLines: number; lastLineLength: number } {\n\tconst re = /\\n/g;\n\tlet numLines = 0;\n\tlet lastNewlineIdx = -1;\n\tlet match: ReturnType<typeof re.exec>;\n\twhile (match = re.exec(text)) {\n\t\tnumLines++;\n\t\tlastNewlineIdx = match.index;\n\t}\n\n\tconst lastLineLength = lastNewlineIdx >= 0 ?\n\t\ttext.length - lastNewlineIdx - 1 :\n\t\ttext.length;\n\n\treturn { numLines, lastLineLength };\n}\n\n// exported for testing\nexport function getRgArgs(query: TextSearchQuery2, options: RipgrepTextSearchOptions): string[] {\n\tconst args = ['--hidden', '--no-require-git'];\n\targs.push(query.isCaseSensitive ? '--case-sensitive' : '--ignore-case');\n\n\tconst { doubleStarIncludes, otherIncludes } = groupBy(\n\t\toptions.folderOptions.includes,\n\t\t(include: string) => include.startsWith('**') ? 'doubleStarIncludes' : 'otherIncludes');\n\n\tif (otherIncludes && otherIncludes.length) {\n\t\tconst uniqueOthers = new Set<string>();\n\t\totherIncludes.forEach(other => { uniqueOthers.add(other); });\n\n\t\targs.push('-g', '!*');\n\t\tuniqueOthers\n\t\t\t.forEach(otherIncude => {\n\t\t\t\tspreadGlobComponents(otherIncude)\n\t\t\t\t\t.map(anchorGlob)\n\t\t\t\t\t.forEach(globArg => {\n\t\t\t\t\t\targs.push('-g', globArg);\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\tif (doubleStarIncludes && doubleStarIncludes.length) {\n\t\tdoubleStarIncludes.forEach(globArg => {\n\t\t\targs.push('-g', globArg);\n\t\t});\n\t}\n\n\toptions.folderOptions.excludes.map(e => typeof (e) === 'string' ? e : e.pattern)\n\t\t.map(anchorGlob)\n\t\t.forEach(rgGlob => args.push('-g', `!${rgGlob}`));\n\n\tif (options.maxFileSize) {\n\t\targs.push('--max-filesize', options.maxFileSize + '');\n\t}\n\n\tif (options.folderOptions.useIgnoreFiles.local) {\n\t\tif (!options.folderOptions.useIgnoreFiles.parent) {\n\t\t\targs.push('--no-ignore-parent');\n\t\t}\n\t} else {\n\t\t// Don't use .gitignore or .ignore\n\t\targs.push('--no-ignore');\n\t}\n\n\tif (options.folderOptions.followSymlinks) {\n\t\targs.push('--follow');\n\t}\n\n\tif (options.folderOptions.encoding && options.folderOptions.encoding !== 'utf8') {\n\t\targs.push('--encoding', options.folderOptions.encoding);\n\t}\n\n\tif (options.numThreads) {\n\t\targs.push('--threads', `${options.numThreads}`);\n\t}\n\n\t// Ripgrep handles -- as a -- arg separator. Only --.\n\t// - is ok, --- is ok, --some-flag is also ok. Need to special case.\n\tif (query.pattern === '--') {\n\t\tquery.isRegExp = true;\n\t\tquery.pattern = '\\\\-\\\\-';\n\t}\n\n\tif (query.isMultiline && !query.isRegExp) {\n\t\tquery.pattern = escapeRegExpCharacters(query.pattern);\n\t\tquery.isRegExp = true;\n\t}\n\n\tif ((<IExtendedExtensionSearchOptions>options).usePCRE2) {\n\t\targs.push('--pcre2');\n\t}\n\n\t// Allow $ to match /r/n\n\targs.push('--crlf');\n\n\tif (query.isRegExp) {\n\t\tquery.pattern = unicodeEscapesToPCRE2(query.pattern);\n\t\targs.push('--engine', 'auto');\n\t}\n\n\tlet searchPatternAfterDoubleDashes: Maybe<string>;\n\tif (query.isWordMatch) {\n\t\tconst regexp = createRegExp(query.pattern, !!query.isRegExp, { wholeWord: query.isWordMatch });\n\t\tconst regexpStr = regexp.source.replace(/\\\\\\//g, '/'); // RegExp.source arbitrarily returns escaped slashes. Search and destroy.\n\t\targs.push('--regexp', regexpStr);\n\t} else if (query.isRegExp) {\n\t\tlet fixedRegexpQuery = fixRegexNewline(query.pattern);\n\t\tfixedRegexpQuery = fixNewline(fixedRegexpQuery);\n\t\targs.push('--regexp', fixedRegexpQuery);\n\t} else {\n\t\tsearchPatternAfterDoubleDashes = query.pattern;\n\t\targs.push('--fixed-strings');\n\t}\n\n\targs.push('--no-config');\n\tif (!options.folderOptions.useIgnoreFiles.global) {\n\t\targs.push('--no-ignore-global');\n\t}\n\n\targs.push('--json');\n\n\tif (query.isMultiline) {\n\t\targs.push('--multiline');\n\t}\n\n\tif (options.surroundingContext) {\n\t\targs.push('--before-context', options.surroundingContext + '');\n\t\targs.push('--after-context', options.surroundingContext + '');\n\t}\n\n\t// Folder to search\n\targs.push('--');\n\n\tif (searchPatternAfterDoubleDashes) {\n\t\t// Put the query after --, in case the query starts with a dash\n\t\targs.push(searchPatternAfterDoubleDashes);\n\t}\n\n\targs.push('.');\n\n\treturn args;\n}\n\n/**\n * `\"foo/*bar/something\"` -> `[\"foo\", \"foo/*bar\", \"foo/*bar/something\", \"foo/*bar/something/**\"]`\n */\nfunction spreadGlobComponents(globComponent: string): string[] {\n\tconst globComponentWithBraceExpansion = performBraceExpansionForRipgrep(globComponent);\n\n\treturn globComponentWithBraceExpansion.flatMap((globArg) => {\n\t\tconst components = splitGlobAware(globArg, '/');\n\t\treturn components.map((_, i) => components.slice(0, i + 1).join('/'));\n\t});\n\n}\n\nexport function unicodeEscapesToPCRE2(pattern: string): string {\n\t// Match \\u1234\n\tconst unicodePattern = /((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u([a-z0-9]{4})/gi;\n\n\twhile (pattern.match(unicodePattern)) {\n\t\tpattern = pattern.replace(unicodePattern, `$1\\\\x{$2}`);\n\t}\n\n\t// Match \\u{1234}\n\t// \\u with 5-6 characters will be left alone because \\x only takes 4 characters.\n\tconst unicodePatternWithBraces = /((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u\\{([a-z0-9]{4})\\}/gi;\n\twhile (pattern.match(unicodePatternWithBraces)) {\n\t\tpattern = pattern.replace(unicodePatternWithBraces, `$1\\\\x{$2}`);\n\t}\n\n\treturn pattern;\n}\n\nexport interface IRgMessage {\n\ttype: 'match' | 'context' | string;\n\tdata: IRgMatch;\n}\n\nexport interface IRgMatch {\n\tpath: IRgBytesOrText;\n\tlines: IRgBytesOrText;\n\tline_number: number;\n\tabsolute_offset: number;\n\tsubmatches: IRgSubmatch[];\n}\n\nexport interface IRgSubmatch {\n\tmatch: IRgBytesOrText;\n\tstart: number;\n\tend: number;\n}\n\nexport type IRgBytesOrText = { bytes: string } | { text: string };\n\nconst isLookBehind = (node: ReAST.Node) => node.type === 'Assertion' && node.kind === 'lookbehind';\n\nexport function fixRegexNewline(pattern: string): string {\n\t// we parse the pattern anew each tiem\n\tlet re: ReAST.Pattern;\n\ttry {\n\t\tre = new RegExpParser().parsePattern(pattern);\n\t} catch {\n\t\treturn pattern;\n\t}\n\n\tlet output = '';\n\tlet lastEmittedIndex = 0;\n\tconst replace = (start: number, end: number, text: string) => {\n\t\toutput += pattern.slice(lastEmittedIndex, start) + text;\n\t\tlastEmittedIndex = end;\n\t};\n\n\tconst context: ReAST.Node[] = [];\n\tconst visitor = new RegExpVisitor({\n\t\tonCharacterEnter(char) {\n\t\t\tif (char.raw !== '\\\\n') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst parent = context[0];\n\t\t\tif (!parent) {\n\t\t\t\t// simple char, \\n -> \\r?\\n\n\t\t\t\treplace(char.start, char.end, '\\\\r?\\\\n');\n\t\t\t} else if (context.some(isLookBehind)) {\n\t\t\t\t// no-op in a lookbehind, see #100569\n\t\t\t} else if (parent.type === 'CharacterClass') {\n\t\t\t\tif (parent.negate) {\n\t\t\t\t\t// negative bracket expr, [^a-z\\n] -> (?![a-z]|\\r?\\n)\n\t\t\t\t\tconst otherContent = pattern.slice(parent.start + 2, char.start) + pattern.slice(char.end, parent.end - 1);\n\t\t\t\t\tif (parent.parent?.type === 'Quantifier') {\n\t\t\t\t\t\t// If quantified, we can't use a negative lookahead in a quantifier.\n\t\t\t\t\t\t// But `.` already doesn't match new lines, so we can just use that\n\t\t\t\t\t\t// (with any other negations) instead.\n\t\t\t\t\t\treplace(parent.start, parent.end, otherContent ? `[^${otherContent}]` : '.');\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplace(parent.start, parent.end, '(?!\\\\r?\\\\n' + (otherContent ? `|[${otherContent}]` : '') + ')');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// positive bracket expr, [a-z\\n] -> (?:[a-z]|\\r?\\n)\n\t\t\t\t\tconst otherContent = pattern.slice(parent.start + 1, char.start) + pattern.slice(char.end, parent.end - 1);\n\t\t\t\t\treplace(parent.start, parent.end, otherContent === '' ? '\\\\r?\\\\n' : `(?:[${otherContent}]|\\\\r?\\\\n)`);\n\t\t\t\t}\n\t\t\t} else if (parent.type === 'Quantifier') {\n\t\t\t\treplace(char.start, char.end, '(?:\\\\r?\\\\n)');\n\t\t\t}\n\t\t},\n\t\tonQuantifierEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonQuantifierLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonCharacterClassRangeEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonCharacterClassRangeLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonCharacterClassEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonCharacterClassLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonAssertionEnter(node) {\n\t\t\tif (isLookBehind(node)) {\n\t\t\t\tcontext.push(node);\n\t\t\t}\n\t\t},\n\t\tonAssertionLeave(node) {\n\t\t\tif (context[0] === node) {\n\t\t\t\tcontext.shift();\n\t\t\t}\n\t\t},\n\t});\n\n\tvisitor.visit(re);\n\toutput += pattern.slice(lastEmittedIndex);\n\treturn output;\n}\n\nexport function fixNewline(pattern: string): string {\n\treturn pattern.replace(/\\n/g, '\\\\r?\\\\n');\n}\n\n// brace expansion for ripgrep\n\n/**\n * Split string given first opportunity for brace expansion in the string.\n * - If the brace is prepended by a \\ character, then it is escaped.\n * - Does not process escapes that are within the sub-glob.\n * - If two unescaped `{` occur before `}`, then ripgrep will return an error for brace nesting, so don't split on those.\n */\nfunction getEscapeAwareSplitStringForRipgrep(pattern: string): { fixedStart?: string; strInBraces: string; fixedEnd?: string } {\n\tlet inBraces = false;\n\tlet escaped = false;\n\tlet fixedStart = '';\n\tlet strInBraces = '';\n\tfor (let i = 0; i < pattern.length; i++) {\n\t\tconst char = pattern[i];\n\t\tswitch (char) {\n\t\t\tcase '\\\\':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// If we're already escaped, then just leave the escaped slash and the preceeding slash that escapes it.\n\t\t\t\t\t// The two escaped slashes will result in a single slash and whatever processes the glob later will properly process the escape\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += '\\\\' + char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += '\\\\' + char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else {\n\t\t\t\t\tescaped = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// if we escaped this opening bracket, then it is to be taken literally. Remove the `\\` because we've acknowleged it and add the `{` to the appropriate string\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\t// ripgrep treats this as attempting to do a nested alternate group, which is invalid. Return with pattern including changes from escaped braces.\n\t\t\t\t\t\treturn { strInBraces: fixedStart + '{' + strInBraces + '{' + pattern.substring(i + 1) };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// same as `}`, but for closing bracket\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else if (inBraces) {\n\t\t\t\t\t// we found an end bracket to a valid opening bracket. Return the appropriate strings.\n\t\t\t\t\treturn { fixedStart, strInBraces, fixedEnd: pattern.substring(i + 1) };\n\t\t\t\t} else {\n\t\t\t\t\t// if we're not in braces and not escaped, then this is a literal `}` character and we're still adding to fixedStart.\n\t\t\t\t\tfixedStart += char;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// similar to the `\\\\` case, we didn't do anything with the escape, so we should re-insert it into the appropriate string\n\t\t\t\t// to be consumed later when individual parts of the glob are processed\n\t\t\t\tif (inBraces) {\n\t\t\t\t\tstrInBraces += (escaped ? '\\\\' : '') + char;\n\t\t\t\t} else {\n\t\t\t\t\tfixedStart += (escaped ? '\\\\' : '') + char;\n\t\t\t\t}\n\t\t\t\tescaped = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t// we are haven't hit the last brace, so no splitting should occur. Return with pattern including changes from escaped braces.\n\treturn { strInBraces: fixedStart + (inBraces ? ('{' + strInBraces) : '') };\n}\n\n/**\n * Parses out curly braces and returns equivalent globs. Only supports one level of nesting.\n * Exported for testing.\n */\nexport function performBraceExpansionForRipgrep(pattern: string): string[] {\n\tconst { fixedStart, strInBraces, fixedEnd } = getEscapeAwareSplitStringForRipgrep(pattern);\n\tif (fixedStart === undefined || fixedEnd === undefined) {\n\t\treturn [strInBraces];\n\t}\n\n\tlet arr = splitGlobAware(strInBraces, ',');\n\n\tif (!arr.length) {\n\t\t// occurs if the braces are empty.\n\t\tarr = [''];\n\t}\n\n\tconst ends = performBraceExpansionForRipgrep(fixedEnd);\n\n\treturn arr.flatMap((elem) => {\n\t\tconst start = fixedStart + elem;\n\t\treturn ends.map((end) => {\n\t\t\treturn start + end;\n\t\t});\n\t});\n}\n"]}