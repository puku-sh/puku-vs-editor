{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/search/node/fileSearch.ts","vs/workbench/services/search/node/fileSearch.ts"],"names":[],"mappings":"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","file":"fileSearch.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as childProcess from 'child_process';\nimport * as fs from 'fs';\nimport * as path from '../../../../base/common/path.js';\nimport { Readable } from 'stream';\nimport { StringDecoder } from 'string_decoder';\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport * as glob from '../../../../base/common/glob.js';\nimport * as normalization from '../../../../base/common/normalization.js';\nimport { isEqualOrParent } from '../../../../base/common/extpath.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport * as types from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Promises } from '../../../../base/node/pfs.js';\nimport { IFileQuery, IFolderQuery, IProgressMessage, ISearchEngineStats, IRawFileMatch, ISearchEngine, ISearchEngineSuccess, isFilePatternMatch, hasSiblingFn } from '../common/search.js';\nimport { spawnRipgrepCmd } from './ripgrepFileSearch.js';\nimport { prepareQuery } from '../../../../base/common/fuzzyScorer.js';\n\ninterface IDirectoryEntry extends IRawFileMatch {\n\tbase: string;\n\tbasename: string;\n}\n\ninterface IDirectoryTree {\n\trootEntries: IDirectoryEntry[];\n\tpathToEntries: { [relativePath: string]: IDirectoryEntry[] };\n}\n\nconst killCmds = new Set<() => void>();\nprocess.on('exit', () => {\n\tkillCmds.forEach(cmd => cmd());\n});\n\nexport class FileWalker {\n\tprivate config: IFileQuery;\n\tprivate filePattern: string;\n\tprivate normalizedFilePatternLowercase: string | null = null;\n\tprivate includePattern: glob.ParsedExpression | undefined;\n\tprivate maxResults: number | null;\n\tprivate exists: boolean;\n\tprivate maxFilesize: number | null = null;\n\tprivate isLimitHit: boolean;\n\tprivate resultCount: number;\n\tprivate isCanceled = false;\n\tprivate fileWalkSW: StopWatch | null = null;\n\tprivate directoriesWalked: number;\n\tprivate filesWalked: number;\n\tprivate errors: string[];\n\tprivate cmdSW: StopWatch | null = null;\n\tprivate cmdResultCount: number = 0;\n\n\tprivate folderExcludePatterns: Map<string, AbsoluteAndRelativeParsedExpression>;\n\tprivate globalExcludePattern: glob.ParsedExpression | undefined;\n\n\tprivate walkedPaths: { [path: string]: boolean };\n\n\tconstructor(config: IFileQuery) {\n\t\tthis.config = config;\n\t\tthis.filePattern = config.filePattern || '';\n\t\tthis.includePattern = config.includePattern && glob.parse(config.includePattern);\n\t\tthis.maxResults = config.maxResults || null;\n\t\tthis.exists = !!config.exists;\n\t\tthis.walkedPaths = Object.create(null);\n\t\tthis.resultCount = 0;\n\t\tthis.isLimitHit = false;\n\t\tthis.directoriesWalked = 0;\n\t\tthis.filesWalked = 0;\n\t\tthis.errors = [];\n\n\t\tif (this.filePattern) {\n\t\t\tthis.normalizedFilePatternLowercase = config.shouldGlobMatchFilePattern ? null : prepareQuery(this.filePattern).normalizedLowercase;\n\t\t}\n\n\t\tthis.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);\n\t\tthis.folderExcludePatterns = new Map<string, AbsoluteAndRelativeParsedExpression>();\n\n\t\tconfig.folderQueries.forEach(folderQuery => {\n\t\t\tconst folderExcludeExpression: glob.IExpression = {}; // todo: consider exclude baseURI\n\n\t\t\tfolderQuery.excludePattern?.forEach(excludePattern => {\n\t\t\t\tObject.assign(folderExcludeExpression, excludePattern.pattern || {}, this.config.excludePattern || {});\n\t\t\t});\n\n\t\t\tif (!folderQuery.excludePattern?.length) {\n\t\t\t\tObject.assign(folderExcludeExpression, this.config.excludePattern || {});\n\t\t\t}\n\n\t\t\t// Add excludes for other root folders\n\t\t\tconst fqPath = folderQuery.folder.fsPath;\n\t\t\tconfig.folderQueries\n\t\t\t\t.map(rootFolderQuery => rootFolderQuery.folder.fsPath)\n\t\t\t\t.filter(rootFolder => rootFolder !== fqPath)\n\t\t\t\t.forEach(otherRootFolder => {\n\t\t\t\t\t// Exclude nested root folders\n\t\t\t\t\tif (isEqualOrParent(otherRootFolder, fqPath)) {\n\t\t\t\t\t\tfolderExcludeExpression[path.relative(fqPath, otherRootFolder)] = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tthis.folderExcludePatterns.set(fqPath, new AbsoluteAndRelativeParsedExpression(folderExcludeExpression, fqPath));\n\t\t});\n\t}\n\n\tcancel(): void {\n\t\tthis.isCanceled = true;\n\t\tkillCmds.forEach(cmd => cmd());\n\t}\n\n\twalk(folderQueries: IFolderQuery[], extraFiles: URI[], numThreads: number | undefined, onResult: (result: IRawFileMatch) => void, onMessage: (message: IProgressMessage) => void, done: (error: Error | null, isLimitHit: boolean) => void): void {\n\t\tthis.fileWalkSW = StopWatch.create(false);\n\n\t\t// Support that the file pattern is a full path to a file that exists\n\t\tif (this.isCanceled) {\n\t\t\treturn done(null, this.isLimitHit);\n\t\t}\n\n\t\t// For each extra file\n\t\textraFiles.forEach(extraFilePath => {\n\t\t\tconst basename = path.basename(extraFilePath.fsPath);\n\t\t\tif (this.globalExcludePattern && this.globalExcludePattern(extraFilePath.fsPath, basename)) {\n\t\t\t\treturn; // excluded\n\t\t\t}\n\n\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\tthis.matchFile(onResult, { relativePath: extraFilePath.fsPath /* no workspace relative path */, searchPath: undefined });\n\t\t});\n\n\t\tthis.cmdSW = StopWatch.create(false);\n\n\t\t// For each root folder\n\t\tthis.parallel<IFolderQuery, void>(folderQueries, (folderQuery: IFolderQuery, rootFolderDone: (err: Error | null, result: void) => void) => {\n\t\t\tthis.call(this.cmdTraversal, this, folderQuery, numThreads, onResult, onMessage, (err?: Error) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tconst errorMessage = toErrorMessage(err);\n\t\t\t\t\tconsole.error(errorMessage);\n\t\t\t\t\tthis.errors.push(errorMessage);\n\t\t\t\t\trootFolderDone(err, undefined);\n\t\t\t\t} else {\n\t\t\t\t\trootFolderDone(null, undefined);\n\t\t\t\t}\n\t\t\t});\n\t\t}, (errors, _result) => {\n\t\t\tthis.fileWalkSW!.stop();\n\t\t\tconst err = errors ? arrays.coalesce(errors)[0] : null;\n\t\t\tdone(err, this.isLimitHit);\n\t\t});\n\t}\n\n\tprivate parallel<T, E>(list: T[], fn: (item: T, callback: (err: Error | null, result: E | null) => void) => void, callback: (err: Array<Error | null> | null, result: E[]) => void): void {\n\t\tconst results = new Array(list.length);\n\t\tconst errors = new Array<Error | null>(list.length);\n\t\tlet didErrorOccur = false;\n\t\tlet doneCount = 0;\n\n\t\tif (list.length === 0) {\n\t\t\treturn callback(null, []);\n\t\t}\n\n\t\tlist.forEach((item, index) => {\n\t\t\tfn(item, (error, result) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tdidErrorOccur = true;\n\t\t\t\t\tresults[index] = null;\n\t\t\t\t\terrors[index] = error;\n\t\t\t\t} else {\n\t\t\t\t\tresults[index] = result;\n\t\t\t\t\terrors[index] = null;\n\t\t\t\t}\n\n\t\t\t\tif (++doneCount === list.length) {\n\t\t\t\t\treturn callback(didErrorOccur ? errors : null, results);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate call<F extends Function>(fun: F, that: any, ...args: any[]): void {\n\t\ttry {\n\t\t\tfun.apply(that, args);\n\t\t} catch (e) {\n\t\t\targs[args.length - 1](e);\n\t\t}\n\t}\n\n\tprivate cmdTraversal(folderQuery: IFolderQuery, numThreads: number | undefined, onResult: (result: IRawFileMatch) => void, onMessage: (message: IProgressMessage) => void, cb: (err?: Error) => void): void {\n\t\tconst rootFolder = folderQuery.folder.fsPath;\n\t\tconst isMac = platform.isMacintosh;\n\n\t\tconst killCmd = () => cmd && cmd.kill();\n\t\tkillCmds.add(killCmd);\n\n\t\tlet done = (err?: Error) => {\n\t\t\tkillCmds.delete(killCmd);\n\t\t\tdone = () => { };\n\t\t\tcb(err);\n\t\t};\n\t\tlet leftover = '';\n\t\tconst tree = this.initDirectoryTree();\n\n\t\tconst ripgrep = spawnRipgrepCmd(this.config, folderQuery, this.config.includePattern, this.folderExcludePatterns.get(folderQuery.folder.fsPath)!.expression, numThreads);\n\t\tconst cmd = ripgrep.cmd;\n\t\tconst noSiblingsClauses = !Object.keys(ripgrep.siblingClauses).length;\n\n\t\tconst escapedArgs = ripgrep.rgArgs.args\n\t\t\t.map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n\t\t\t.join(' ');\n\n\t\tlet rgCmd = `${ripgrep.rgDiskPath} ${escapedArgs}\\n - cwd: ${ripgrep.cwd}`;\n\t\tif (ripgrep.rgArgs.siblingClauses) {\n\t\t\trgCmd += `\\n - Sibling clauses: ${JSON.stringify(ripgrep.rgArgs.siblingClauses)}`;\n\t\t}\n\t\tonMessage({ message: rgCmd });\n\n\t\tthis.cmdResultCount = 0;\n\t\tthis.collectStdout(cmd, 'utf8', onMessage, (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err) {\n\t\t\t\tdone(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.isLimitHit) {\n\t\t\t\tdone();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\tconst normalized = leftover + (isMac ? normalization.normalizeNFC(stdout || '') : stdout);\n\t\t\tconst relativeFiles = normalized.split('\\n');\n\n\t\t\tif (last) {\n\t\t\t\tconst n = relativeFiles.length;\n\t\t\t\trelativeFiles[n - 1] = relativeFiles[n - 1].trim();\n\t\t\t\tif (!relativeFiles[n - 1]) {\n\t\t\t\t\trelativeFiles.pop();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tleftover = relativeFiles.pop() || '';\n\t\t\t}\n\n\t\t\tif (relativeFiles.length && relativeFiles[0].indexOf('\\n') !== -1) {\n\t\t\t\tdone(new Error('Splitting up files failed'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.cmdResultCount += relativeFiles.length;\n\n\t\t\tif (noSiblingsClauses) {\n\t\t\t\tfor (const relativePath of relativeFiles) {\n\t\t\t\t\tthis.matchFile(onResult, { base: rootFolder, relativePath, searchPath: this.getSearchPath(folderQuery, relativePath) });\n\t\t\t\t\tif (this.isLimitHit) {\n\t\t\t\t\t\tkillCmd();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (last || this.isLimitHit) {\n\t\t\t\t\tdone();\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// TODO: Optimize siblings clauses with ripgrep here.\n\t\t\tthis.addDirectoryEntries(folderQuery, tree, rootFolder, relativeFiles, onResult);\n\n\t\t\tif (last) {\n\t\t\t\tthis.matchDirectoryTree(tree, rootFolder, onResult);\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\tspawnFindCmd(folderQuery: IFolderQuery) {\n\t\tconst excludePattern = this.folderExcludePatterns.get(folderQuery.folder.fsPath)!;\n\t\tconst basenames = excludePattern.getBasenameTerms();\n\t\tconst pathTerms = excludePattern.getPathTerms();\n\t\tconst args = ['-L', '.'];\n\t\tif (basenames.length || pathTerms.length) {\n\t\t\targs.push('-not', '(', '(');\n\t\t\tfor (const basename of basenames) {\n\t\t\t\targs.push('-name', basename);\n\t\t\t\targs.push('-o');\n\t\t\t}\n\t\t\tfor (const path of pathTerms) {\n\t\t\t\targs.push('-path', path);\n\t\t\t\targs.push('-o');\n\t\t\t}\n\t\t\targs.pop();\n\t\t\targs.push(')', '-prune', ')');\n\t\t}\n\t\targs.push('-type', 'f');\n\t\treturn childProcess.spawn('find', args, { cwd: folderQuery.folder.fsPath });\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\treadStdout(cmd: childProcess.ChildProcess, encoding: BufferEncoding, cb: (err: Error | null, stdout?: string) => void): void {\n\t\tlet all = '';\n\t\tthis.collectStdout(cmd, encoding, () => { }, (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err) {\n\t\t\t\tcb(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tall += stdout;\n\t\t\tif (last) {\n\t\t\t\tcb(null, all);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate collectStdout(cmd: childProcess.ChildProcess, encoding: BufferEncoding, onMessage: (message: IProgressMessage) => void, cb: (err: Error | null, stdout?: string, last?: boolean) => void): void {\n\t\tlet onData = (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err || last) {\n\t\t\t\tonData = () => { };\n\n\t\t\t\tthis.cmdSW?.stop();\n\t\t\t}\n\t\t\tcb(err, stdout, last);\n\t\t};\n\n\t\tlet gotData = false;\n\t\tif (cmd.stdout) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tthis.forwardData(cmd.stdout, encoding, onData);\n\t\t\tcmd.stdout.once('data', () => gotData = true);\n\t\t} else {\n\t\t\tonMessage({ message: 'stdout is null' });\n\t\t}\n\n\t\tlet stderr: Buffer[];\n\t\tif (cmd.stderr) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tstderr = this.collectData(cmd.stderr);\n\t\t} else {\n\t\t\tonMessage({ message: 'stderr is null' });\n\t\t}\n\n\t\tcmd.on('error', (err: Error) => {\n\t\t\tonData(err);\n\t\t});\n\n\t\tcmd.on('close', (code: number) => {\n\t\t\t// ripgrep returns code=1 when no results are found\n\t\t\tlet stderrText: string;\n\t\t\tif (!gotData && (stderrText = this.decodeData(stderr, encoding)) && rgErrorMsgForDisplay(stderrText)) {\n\t\t\t\tonData(new Error(`command failed with error code ${code}: ${this.decodeData(stderr, encoding)}`));\n\t\t\t} else {\n\t\t\t\tif (this.exists && code === 0) {\n\t\t\t\t\tthis.isLimitHit = true;\n\t\t\t\t}\n\t\t\t\tonData(null, '', true);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate forwardData(stream: Readable, encoding: BufferEncoding, cb: (err: Error | null, stdout?: string) => void): StringDecoder {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\tstream.on('data', (data: Buffer) => {\n\t\t\tcb(null, decoder.write(data));\n\t\t});\n\t\treturn decoder;\n\t}\n\n\tprivate collectData(stream: Readable): Buffer[] {\n\t\tconst buffers: Buffer[] = [];\n\t\tstream.on('data', (data: Buffer) => {\n\t\t\tbuffers.push(data);\n\t\t});\n\t\treturn buffers;\n\t}\n\n\tprivate decodeData(buffers: Buffer[], encoding: BufferEncoding): string {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\treturn buffers.map(buffer => decoder.write(buffer)).join('');\n\t}\n\n\tprivate initDirectoryTree(): IDirectoryTree {\n\t\tconst tree: IDirectoryTree = {\n\t\t\trootEntries: [],\n\t\t\tpathToEntries: Object.create(null)\n\t\t};\n\t\ttree.pathToEntries['.'] = tree.rootEntries;\n\t\treturn tree;\n\t}\n\n\tprivate addDirectoryEntries(folderQuery: IFolderQuery, { pathToEntries }: IDirectoryTree, base: string, relativeFiles: string[], onResult: (result: IRawFileMatch) => void) {\n\t\t// Support relative paths to files from a root resource (ignores excludes)\n\t\tif (relativeFiles.indexOf(this.filePattern) !== -1) {\n\t\t\tthis.matchFile(onResult, {\n\t\t\t\tbase,\n\t\t\t\trelativePath: this.filePattern,\n\t\t\t\tsearchPath: this.getSearchPath(folderQuery, this.filePattern)\n\t\t\t});\n\t\t}\n\n\t\tconst add = (relativePath: string) => {\n\t\t\tconst basename = path.basename(relativePath);\n\t\t\tconst dirname = path.dirname(relativePath);\n\t\t\tlet entries = pathToEntries[dirname];\n\t\t\tif (!entries) {\n\t\t\t\tentries = pathToEntries[dirname] = [];\n\t\t\t\tadd(dirname);\n\t\t\t}\n\t\t\tentries.push({\n\t\t\t\tbase,\n\t\t\t\trelativePath,\n\t\t\t\tbasename,\n\t\t\t\tsearchPath: this.getSearchPath(folderQuery, relativePath),\n\t\t\t});\n\t\t};\n\t\trelativeFiles.forEach(add);\n\t}\n\n\tprivate matchDirectoryTree({ rootEntries, pathToEntries }: IDirectoryTree, rootFolder: string, onResult: (result: IRawFileMatch) => void) {\n\t\tconst self = this;\n\t\tconst excludePattern = this.folderExcludePatterns.get(rootFolder)!;\n\t\tconst filePattern = this.filePattern;\n\t\tfunction matchDirectory(entries: IDirectoryEntry[]) {\n\t\t\tself.directoriesWalked++;\n\t\t\tconst hasSibling = hasSiblingFn(() => entries.map(entry => entry.basename));\n\t\t\tfor (let i = 0, n = entries.length; i < n; i++) {\n\t\t\t\tconst entry = entries[i];\n\t\t\t\tconst { relativePath, basename } = entry;\n\n\t\t\t\t// Check exclude pattern\n\t\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t\t// to ignore filtering by siblings because the user seems to know what they\n\t\t\t\t// are searching for and we want to include the result in that case anyway\n\t\t\t\tif (excludePattern.test(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst sub = pathToEntries[relativePath];\n\t\t\t\tif (sub) {\n\t\t\t\t\tmatchDirectory(sub);\n\t\t\t\t} else {\n\t\t\t\t\tself.filesWalked++;\n\t\t\t\t\tif (relativePath === filePattern) {\n\t\t\t\t\t\tcontinue; // ignore file if its path matches with the file pattern because that is already matched above\n\t\t\t\t\t}\n\n\t\t\t\t\tself.matchFile(onResult, entry);\n\t\t\t\t}\n\n\t\t\t\tif (self.isLimitHit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatchDirectory(rootEntries);\n\t}\n\n\tgetStats(): ISearchEngineStats {\n\t\treturn {\n\t\t\tcmdTime: this.cmdSW!.elapsed(),\n\t\t\tfileWalkTime: this.fileWalkSW!.elapsed(),\n\t\t\tdirectoriesWalked: this.directoriesWalked,\n\t\t\tfilesWalked: this.filesWalked,\n\t\t\tcmdResultCount: this.cmdResultCount\n\t\t};\n\t}\n\n\tprivate doWalk(folderQuery: IFolderQuery, relativeParentPath: string, files: string[], onResult: (result: IRawFileMatch) => void, done: (error?: Error) => void): void {\n\t\tconst rootFolder = folderQuery.folder;\n\n\t\t// Execute tasks on each file in parallel to optimize throughput\n\t\tconst hasSibling = hasSiblingFn(() => files);\n\t\tthis.parallel(files, (file: string, clb: (error: Error | null, _?: any) => void): void => {\n\n\t\t\t// Check canceled\n\t\t\tif (this.isCanceled || this.isLimitHit) {\n\t\t\t\treturn clb(null);\n\t\t\t}\n\n\t\t\t// Check exclude pattern\n\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t// to ignore filtering by siblings because the user seems to know what they\n\t\t\t// are searching for and we want to include the result in that case anyway\n\t\t\tconst currentRelativePath = relativeParentPath ? [relativeParentPath, file].join(path.sep) : file;\n\t\t\tif (this.folderExcludePatterns.get(folderQuery.folder.fsPath)!.test(currentRelativePath, file, this.config.filePattern !== file ? hasSibling : undefined)) {\n\t\t\t\treturn clb(null);\n\t\t\t}\n\n\t\t\t// Use lstat to detect links\n\t\t\tconst currentAbsolutePath = [rootFolder.fsPath, currentRelativePath].join(path.sep);\n\t\t\tfs.lstat(currentAbsolutePath, (error, lstat) => {\n\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\treturn clb(null);\n\t\t\t\t}\n\n\t\t\t\t// If the path is a link, we must instead use fs.stat() to find out if the\n\t\t\t\t// link is a directory or not because lstat will always return the stat of\n\t\t\t\t// the link which is always a file.\n\t\t\t\tthis.statLinkIfNeeded(currentAbsolutePath, lstat, (error, stat) => {\n\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Directory: Follow directories\n\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\tthis.directoriesWalked++;\n\n\t\t\t\t\t\t// to really prevent loops with links we need to resolve the real path of them\n\t\t\t\t\t\treturn this.realPathIfNeeded(currentAbsolutePath, lstat, (error, realpath) => {\n\t\t\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trealpath = realpath || '';\n\t\t\t\t\t\t\tif (this.walkedPaths[realpath]) {\n\t\t\t\t\t\t\t\treturn clb(null); // escape when there are cycles (can happen with symlinks)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.walkedPaths[realpath] = true; // remember as walked\n\n\t\t\t\t\t\t\t// Continue walking\n\t\t\t\t\t\t\treturn Promises.readdir(currentAbsolutePath).then(children => {\n\t\t\t\t\t\t\t\tif (this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.doWalk(folderQuery, currentRelativePath, children, onResult, err => clb(err || null));\n\t\t\t\t\t\t\t}, error => {\n\t\t\t\t\t\t\t\tclb(null);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.filesWalked++;\n\t\t\t\t\t\tif (currentRelativePath === this.filePattern) {\n\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if its path matches with the file pattern because checkFilePatternRelativeMatch() takes care of those\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.maxFilesize && types.isNumber(stat.size) && stat.size > this.maxFilesize) {\n\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if max file size is hit\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.matchFile(onResult, {\n\t\t\t\t\t\t\tbase: rootFolder.fsPath,\n\t\t\t\t\t\t\trelativePath: currentRelativePath,\n\t\t\t\t\t\t\tsearchPath: this.getSearchPath(folderQuery, currentRelativePath),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unwind\n\t\t\t\t\treturn clb(null, undefined);\n\t\t\t\t});\n\t\t\t});\n\t\t}, (error: Array<Error | null> | null): void => {\n\t\t\tconst filteredErrors = error ? arrays.coalesce(error) : error; // find any error by removing null values first\n\t\t\treturn done(filteredErrors && filteredErrors.length > 0 ? filteredErrors[0] : undefined);\n\t\t});\n\t}\n\n\tprivate matchFile(onResult: (result: IRawFileMatch) => void, candidate: IRawFileMatch): void {\n\t\tif (this.isFileMatch(candidate) && (!this.includePattern || this.includePattern(candidate.relativePath, path.basename(candidate.relativePath)))) {\n\t\t\tthis.resultCount++;\n\n\t\t\tif (this.exists || (this.maxResults && this.resultCount > this.maxResults)) {\n\t\t\t\tthis.isLimitHit = true;\n\t\t\t}\n\n\t\t\tif (!this.isLimitHit) {\n\t\t\t\tonResult(candidate);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isFileMatch(candidate: IRawFileMatch): boolean {\n\t\t// Check for search pattern\n\t\tif (this.filePattern) {\n\t\t\tif (this.filePattern === '*') {\n\t\t\t\treturn true; // support the all-matching wildcard\n\t\t\t}\n\n\t\t\tif (this.normalizedFilePatternLowercase) {\n\t\t\t\treturn isFilePatternMatch(candidate, this.normalizedFilePatternLowercase);\n\t\t\t} else if (this.filePattern) {\n\t\t\t\treturn isFilePatternMatch(candidate, this.filePattern, false);\n\t\t\t}\n\t\t}\n\n\t\t// No patterns means we match all\n\t\treturn true;\n\t}\n\n\tprivate statLinkIfNeeded(path: string, lstat: fs.Stats, clb: (error: Error | null, stat: fs.Stats) => void): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.stat(path, clb); // stat the target the link points to\n\t\t}\n\n\t\treturn clb(null, lstat); // not a link, so the stat is already ok for us\n\t}\n\n\tprivate realPathIfNeeded(path: string, lstat: fs.Stats, clb: (error: Error | null, realpath?: string) => void): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.realpath(path, (error, realpath) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn clb(error);\n\t\t\t\t}\n\n\t\t\t\treturn clb(null, realpath);\n\t\t\t});\n\t\t}\n\n\t\treturn clb(null, path);\n\t}\n\n\t/**\n\t * If we're searching for files in multiple workspace folders, then better prepend the\n\t * name of the workspace folder to the path of the file. This way we'll be able to\n\t * better filter files that are all on the top of a workspace folder and have all the\n\t * same name. A typical example are `package.json` or `README.md` files.\n\t */\n\tprivate getSearchPath(folderQuery: IFolderQuery, relativePath: string): string {\n\t\tif (folderQuery.folderName) {\n\t\t\treturn path.join(folderQuery.folderName, relativePath);\n\t\t}\n\t\treturn relativePath;\n\t}\n}\n\nexport class Engine implements ISearchEngine<IRawFileMatch> {\n\tprivate folderQueries: IFolderQuery[];\n\tprivate extraFiles: URI[];\n\tprivate walker: FileWalker;\n\tprivate numThreads?: number;\n\n\tconstructor(config: IFileQuery, numThreads?: number) {\n\t\tthis.folderQueries = config.folderQueries;\n\t\tthis.extraFiles = config.extraFileResources || [];\n\t\tthis.numThreads = numThreads;\n\n\t\tthis.walker = new FileWalker(config);\n\t}\n\n\tsearch(onResult: (result: IRawFileMatch) => void, onProgress: (progress: IProgressMessage) => void, done: (error: Error | null, complete: ISearchEngineSuccess) => void): void {\n\t\tthis.walker.walk(this.folderQueries, this.extraFiles, this.numThreads, onResult, onProgress, (err: Error | null, isLimitHit: boolean) => {\n\t\t\tdone(err, {\n\t\t\t\tlimitHit: isLimitHit,\n\t\t\t\tstats: this.walker.getStats(),\n\t\t\t\tmessages: [],\n\t\t\t});\n\t\t});\n\t}\n\n\tcancel(): void {\n\t\tthis.walker.cancel();\n\t}\n}\n\n/**\n * This class exists to provide one interface on top of two ParsedExpressions, one for absolute expressions and one for relative expressions.\n * The absolute and relative expressions don't \"have\" to be kept separate, but this keeps us from having to path.join every single\n * file searched, it's only used for a text search with a searchPath\n */\nclass AbsoluteAndRelativeParsedExpression {\n\tprivate absoluteParsedExpr: glob.ParsedExpression | undefined;\n\tprivate relativeParsedExpr: glob.ParsedExpression | undefined;\n\n\tconstructor(public expression: glob.IExpression, private root: string) {\n\t\tthis.init(expression);\n\t}\n\n\t/**\n\t * Split the IExpression into its absolute and relative components, and glob.parse them separately.\n\t */\n\tprivate init(expr: glob.IExpression): void {\n\t\tlet absoluteGlobExpr: glob.IExpression | undefined;\n\t\tlet relativeGlobExpr: glob.IExpression | undefined;\n\t\tObject.keys(expr)\n\t\t\t.filter(key => expr[key])\n\t\t\t.forEach(key => {\n\t\t\t\tif (path.isAbsolute(key)) {\n\t\t\t\t\tabsoluteGlobExpr = absoluteGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\tabsoluteGlobExpr[key] = expr[key];\n\t\t\t\t} else {\n\t\t\t\t\trelativeGlobExpr = relativeGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\trelativeGlobExpr[key] = expr[key];\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.absoluteParsedExpr = absoluteGlobExpr && glob.parse(absoluteGlobExpr, { trimForExclusions: true });\n\t\tthis.relativeParsedExpr = relativeGlobExpr && glob.parse(relativeGlobExpr, { trimForExclusions: true });\n\t}\n\n\ttest(_path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | Promise<string | null> | undefined | null {\n\t\treturn (this.relativeParsedExpr && this.relativeParsedExpr(_path, basename, hasSibling)) ||\n\t\t\t(this.absoluteParsedExpr && this.absoluteParsedExpr(path.join(this.root, _path), basename, hasSibling));\n\t}\n\n\tgetBasenameTerms(): string[] {\n\t\tconst basenameTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tbasenameTerms.push(...glob.getBasenameTerms(this.absoluteParsedExpr));\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tbasenameTerms.push(...glob.getBasenameTerms(this.relativeParsedExpr));\n\t\t}\n\n\t\treturn basenameTerms;\n\t}\n\n\tgetPathTerms(): string[] {\n\t\tconst pathTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.absoluteParsedExpr));\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.relativeParsedExpr));\n\t\t}\n\n\t\treturn pathTerms;\n\t}\n}\n\nfunction rgErrorMsgForDisplay(msg: string): string | undefined {\n\tconst lines = msg.trim().split('\\n');\n\tconst firstLine = lines[0].trim();\n\n\tif (firstLine.startsWith('Error parsing regex')) {\n\t\treturn firstLine;\n\t}\n\n\tif (firstLine.startsWith('regex parse error')) {\n\t\treturn strings.uppercaseFirstLetter(lines[lines.length - 1].trim());\n\t}\n\n\tif (firstLine.startsWith('error parsing glob') ||\n\t\tfirstLine.startsWith('unsupported encoding')) {\n\t\t// Uppercase first letter\n\t\treturn firstLine.charAt(0).toUpperCase() + firstLine.substr(1);\n\t}\n\n\tif (firstLine === `Literal '\\\\n' not allowed.`) {\n\t\t// I won't localize this because none of the Ripgrep error messages are localized\n\t\treturn `Literal '\\\\n' currently not supported`;\n\t}\n\n\tif (firstLine.startsWith('Literal ')) {\n\t\t// Other unsupported chars\n\t\treturn firstLine;\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as childProcess from 'child_process';\nimport * as fs from 'fs';\nimport * as path from '../../../../base/common/path.js';\nimport { Readable } from 'stream';\nimport { StringDecoder } from 'string_decoder';\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport * as glob from '../../../../base/common/glob.js';\nimport * as normalization from '../../../../base/common/normalization.js';\nimport { isEqualOrParent } from '../../../../base/common/extpath.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport * as types from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Promises } from '../../../../base/node/pfs.js';\nimport { IFileQuery, IFolderQuery, IProgressMessage, ISearchEngineStats, IRawFileMatch, ISearchEngine, ISearchEngineSuccess, isFilePatternMatch, hasSiblingFn } from '../common/search.js';\nimport { spawnRipgrepCmd } from './ripgrepFileSearch.js';\nimport { prepareQuery } from '../../../../base/common/fuzzyScorer.js';\n\ninterface IDirectoryEntry extends IRawFileMatch {\n\tbase: string;\n\tbasename: string;\n}\n\ninterface IDirectoryTree {\n\trootEntries: IDirectoryEntry[];\n\tpathToEntries: { [relativePath: string]: IDirectoryEntry[] };\n}\n\nconst killCmds = new Set<() => void>();\nprocess.on('exit', () => {\n\tkillCmds.forEach(cmd => cmd());\n});\n\nexport class FileWalker {\n\tprivate config: IFileQuery;\n\tprivate filePattern: string;\n\tprivate normalizedFilePatternLowercase: string | null = null;\n\tprivate includePattern: glob.ParsedExpression | undefined;\n\tprivate maxResults: number | null;\n\tprivate exists: boolean;\n\tprivate maxFilesize: number | null = null;\n\tprivate isLimitHit: boolean;\n\tprivate resultCount: number;\n\tprivate isCanceled = false;\n\tprivate fileWalkSW: StopWatch | null = null;\n\tprivate directoriesWalked: number;\n\tprivate filesWalked: number;\n\tprivate errors: string[];\n\tprivate cmdSW: StopWatch | null = null;\n\tprivate cmdResultCount: number = 0;\n\n\tprivate folderExcludePatterns: Map<string, AbsoluteAndRelativeParsedExpression>;\n\tprivate globalExcludePattern: glob.ParsedExpression | undefined;\n\n\tprivate walkedPaths: { [path: string]: boolean };\n\n\tconstructor(config: IFileQuery) {\n\t\tthis.config = config;\n\t\tthis.filePattern = config.filePattern || '';\n\t\tthis.includePattern = config.includePattern && glob.parse(config.includePattern);\n\t\tthis.maxResults = config.maxResults || null;\n\t\tthis.exists = !!config.exists;\n\t\tthis.walkedPaths = Object.create(null);\n\t\tthis.resultCount = 0;\n\t\tthis.isLimitHit = false;\n\t\tthis.directoriesWalked = 0;\n\t\tthis.filesWalked = 0;\n\t\tthis.errors = [];\n\n\t\tif (this.filePattern) {\n\t\t\tthis.normalizedFilePatternLowercase = config.shouldGlobMatchFilePattern ? null : prepareQuery(this.filePattern).normalizedLowercase;\n\t\t}\n\n\t\tthis.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);\n\t\tthis.folderExcludePatterns = new Map<string, AbsoluteAndRelativeParsedExpression>();\n\n\t\tconfig.folderQueries.forEach(folderQuery => {\n\t\t\tconst folderExcludeExpression: glob.IExpression = {}; // todo: consider exclude baseURI\n\n\t\t\tfolderQuery.excludePattern?.forEach(excludePattern => {\n\t\t\t\tObject.assign(folderExcludeExpression, excludePattern.pattern || {}, this.config.excludePattern || {});\n\t\t\t});\n\n\t\t\tif (!folderQuery.excludePattern?.length) {\n\t\t\t\tObject.assign(folderExcludeExpression, this.config.excludePattern || {});\n\t\t\t}\n\n\t\t\t// Add excludes for other root folders\n\t\t\tconst fqPath = folderQuery.folder.fsPath;\n\t\t\tconfig.folderQueries\n\t\t\t\t.map(rootFolderQuery => rootFolderQuery.folder.fsPath)\n\t\t\t\t.filter(rootFolder => rootFolder !== fqPath)\n\t\t\t\t.forEach(otherRootFolder => {\n\t\t\t\t\t// Exclude nested root folders\n\t\t\t\t\tif (isEqualOrParent(otherRootFolder, fqPath)) {\n\t\t\t\t\t\tfolderExcludeExpression[path.relative(fqPath, otherRootFolder)] = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tthis.folderExcludePatterns.set(fqPath, new AbsoluteAndRelativeParsedExpression(folderExcludeExpression, fqPath));\n\t\t});\n\t}\n\n\tcancel(): void {\n\t\tthis.isCanceled = true;\n\t\tkillCmds.forEach(cmd => cmd());\n\t}\n\n\twalk(folderQueries: IFolderQuery[], extraFiles: URI[], numThreads: number | undefined, onResult: (result: IRawFileMatch) => void, onMessage: (message: IProgressMessage) => void, done: (error: Error | null, isLimitHit: boolean) => void): void {\n\t\tthis.fileWalkSW = StopWatch.create(false);\n\n\t\t// Support that the file pattern is a full path to a file that exists\n\t\tif (this.isCanceled) {\n\t\t\treturn done(null, this.isLimitHit);\n\t\t}\n\n\t\t// For each extra file\n\t\textraFiles.forEach(extraFilePath => {\n\t\t\tconst basename = path.basename(extraFilePath.fsPath);\n\t\t\tif (this.globalExcludePattern && this.globalExcludePattern(extraFilePath.fsPath, basename)) {\n\t\t\t\treturn; // excluded\n\t\t\t}\n\n\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\tthis.matchFile(onResult, { relativePath: extraFilePath.fsPath /* no workspace relative path */, searchPath: undefined });\n\t\t});\n\n\t\tthis.cmdSW = StopWatch.create(false);\n\n\t\t// For each root folder\n\t\tthis.parallel<IFolderQuery, void>(folderQueries, (folderQuery: IFolderQuery, rootFolderDone: (err: Error | null, result: void) => void) => {\n\t\t\tthis.call(this.cmdTraversal, this, folderQuery, numThreads, onResult, onMessage, (err?: Error) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tconst errorMessage = toErrorMessage(err);\n\t\t\t\t\tconsole.error(errorMessage);\n\t\t\t\t\tthis.errors.push(errorMessage);\n\t\t\t\t\trootFolderDone(err, undefined);\n\t\t\t\t} else {\n\t\t\t\t\trootFolderDone(null, undefined);\n\t\t\t\t}\n\t\t\t});\n\t\t}, (errors, _result) => {\n\t\t\tthis.fileWalkSW!.stop();\n\t\t\tconst err = errors ? arrays.coalesce(errors)[0] : null;\n\t\t\tdone(err, this.isLimitHit);\n\t\t});\n\t}\n\n\tprivate parallel<T, E>(list: T[], fn: (item: T, callback: (err: Error | null, result: E | null) => void) => void, callback: (err: Array<Error | null> | null, result: E[]) => void): void {\n\t\tconst results = new Array(list.length);\n\t\tconst errors = new Array<Error | null>(list.length);\n\t\tlet didErrorOccur = false;\n\t\tlet doneCount = 0;\n\n\t\tif (list.length === 0) {\n\t\t\treturn callback(null, []);\n\t\t}\n\n\t\tlist.forEach((item, index) => {\n\t\t\tfn(item, (error, result) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tdidErrorOccur = true;\n\t\t\t\t\tresults[index] = null;\n\t\t\t\t\terrors[index] = error;\n\t\t\t\t} else {\n\t\t\t\t\tresults[index] = result;\n\t\t\t\t\terrors[index] = null;\n\t\t\t\t}\n\n\t\t\t\tif (++doneCount === list.length) {\n\t\t\t\t\treturn callback(didErrorOccur ? errors : null, results);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate call<F extends Function>(fun: F, that: any, ...args: any[]): void {\n\t\ttry {\n\t\t\tfun.apply(that, args);\n\t\t} catch (e) {\n\t\t\targs[args.length - 1](e);\n\t\t}\n\t}\n\n\tprivate cmdTraversal(folderQuery: IFolderQuery, numThreads: number | undefined, onResult: (result: IRawFileMatch) => void, onMessage: (message: IProgressMessage) => void, cb: (err?: Error) => void): void {\n\t\tconst rootFolder = folderQuery.folder.fsPath;\n\t\tconst isMac = platform.isMacintosh;\n\n\t\tconst killCmd = () => cmd && cmd.kill();\n\t\tkillCmds.add(killCmd);\n\n\t\tlet done = (err?: Error) => {\n\t\t\tkillCmds.delete(killCmd);\n\t\t\tdone = () => { };\n\t\t\tcb(err);\n\t\t};\n\t\tlet leftover = '';\n\t\tconst tree = this.initDirectoryTree();\n\n\t\tconst ripgrep = spawnRipgrepCmd(this.config, folderQuery, this.config.includePattern, this.folderExcludePatterns.get(folderQuery.folder.fsPath)!.expression, numThreads);\n\t\tconst cmd = ripgrep.cmd;\n\t\tconst noSiblingsClauses = !Object.keys(ripgrep.siblingClauses).length;\n\n\t\tconst escapedArgs = ripgrep.rgArgs.args\n\t\t\t.map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n\t\t\t.join(' ');\n\n\t\tlet rgCmd = `${ripgrep.rgDiskPath} ${escapedArgs}\\n - cwd: ${ripgrep.cwd}`;\n\t\tif (ripgrep.rgArgs.siblingClauses) {\n\t\t\trgCmd += `\\n - Sibling clauses: ${JSON.stringify(ripgrep.rgArgs.siblingClauses)}`;\n\t\t}\n\t\tonMessage({ message: rgCmd });\n\n\t\tthis.cmdResultCount = 0;\n\t\tthis.collectStdout(cmd, 'utf8', onMessage, (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err) {\n\t\t\t\tdone(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.isLimitHit) {\n\t\t\t\tdone();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\tconst normalized = leftover + (isMac ? normalization.normalizeNFC(stdout || '') : stdout);\n\t\t\tconst relativeFiles = normalized.split('\\n');\n\n\t\t\tif (last) {\n\t\t\t\tconst n = relativeFiles.length;\n\t\t\t\trelativeFiles[n - 1] = relativeFiles[n - 1].trim();\n\t\t\t\tif (!relativeFiles[n - 1]) {\n\t\t\t\t\trelativeFiles.pop();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tleftover = relativeFiles.pop() || '';\n\t\t\t}\n\n\t\t\tif (relativeFiles.length && relativeFiles[0].indexOf('\\n') !== -1) {\n\t\t\t\tdone(new Error('Splitting up files failed'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.cmdResultCount += relativeFiles.length;\n\n\t\t\tif (noSiblingsClauses) {\n\t\t\t\tfor (const relativePath of relativeFiles) {\n\t\t\t\t\tthis.matchFile(onResult, { base: rootFolder, relativePath, searchPath: this.getSearchPath(folderQuery, relativePath) });\n\t\t\t\t\tif (this.isLimitHit) {\n\t\t\t\t\t\tkillCmd();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (last || this.isLimitHit) {\n\t\t\t\t\tdone();\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// TODO: Optimize siblings clauses with ripgrep here.\n\t\t\tthis.addDirectoryEntries(folderQuery, tree, rootFolder, relativeFiles, onResult);\n\n\t\t\tif (last) {\n\t\t\t\tthis.matchDirectoryTree(tree, rootFolder, onResult);\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\tspawnFindCmd(folderQuery: IFolderQuery) {\n\t\tconst excludePattern = this.folderExcludePatterns.get(folderQuery.folder.fsPath)!;\n\t\tconst basenames = excludePattern.getBasenameTerms();\n\t\tconst pathTerms = excludePattern.getPathTerms();\n\t\tconst args = ['-L', '.'];\n\t\tif (basenames.length || pathTerms.length) {\n\t\t\targs.push('-not', '(', '(');\n\t\t\tfor (const basename of basenames) {\n\t\t\t\targs.push('-name', basename);\n\t\t\t\targs.push('-o');\n\t\t\t}\n\t\t\tfor (const path of pathTerms) {\n\t\t\t\targs.push('-path', path);\n\t\t\t\targs.push('-o');\n\t\t\t}\n\t\t\targs.pop();\n\t\t\targs.push(')', '-prune', ')');\n\t\t}\n\t\targs.push('-type', 'f');\n\t\treturn childProcess.spawn('find', args, { cwd: folderQuery.folder.fsPath });\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\treadStdout(cmd: childProcess.ChildProcess, encoding: BufferEncoding, cb: (err: Error | null, stdout?: string) => void): void {\n\t\tlet all = '';\n\t\tthis.collectStdout(cmd, encoding, () => { }, (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err) {\n\t\t\t\tcb(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tall += stdout;\n\t\t\tif (last) {\n\t\t\t\tcb(null, all);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate collectStdout(cmd: childProcess.ChildProcess, encoding: BufferEncoding, onMessage: (message: IProgressMessage) => void, cb: (err: Error | null, stdout?: string, last?: boolean) => void): void {\n\t\tlet onData = (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err || last) {\n\t\t\t\tonData = () => { };\n\n\t\t\t\tthis.cmdSW?.stop();\n\t\t\t}\n\t\t\tcb(err, stdout, last);\n\t\t};\n\n\t\tlet gotData = false;\n\t\tif (cmd.stdout) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tthis.forwardData(cmd.stdout, encoding, onData);\n\t\t\tcmd.stdout.once('data', () => gotData = true);\n\t\t} else {\n\t\t\tonMessage({ message: 'stdout is null' });\n\t\t}\n\n\t\tlet stderr: Buffer[];\n\t\tif (cmd.stderr) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tstderr = this.collectData(cmd.stderr);\n\t\t} else {\n\t\t\tonMessage({ message: 'stderr is null' });\n\t\t}\n\n\t\tcmd.on('error', (err: Error) => {\n\t\t\tonData(err);\n\t\t});\n\n\t\tcmd.on('close', (code: number) => {\n\t\t\t// ripgrep returns code=1 when no results are found\n\t\t\tlet stderrText: string;\n\t\t\tif (!gotData && (stderrText = this.decodeData(stderr, encoding)) && rgErrorMsgForDisplay(stderrText)) {\n\t\t\t\tonData(new Error(`command failed with error code ${code}: ${this.decodeData(stderr, encoding)}`));\n\t\t\t} else {\n\t\t\t\tif (this.exists && code === 0) {\n\t\t\t\t\tthis.isLimitHit = true;\n\t\t\t\t}\n\t\t\t\tonData(null, '', true);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate forwardData(stream: Readable, encoding: BufferEncoding, cb: (err: Error | null, stdout?: string) => void): StringDecoder {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\tstream.on('data', (data: Buffer) => {\n\t\t\tcb(null, decoder.write(data));\n\t\t});\n\t\treturn decoder;\n\t}\n\n\tprivate collectData(stream: Readable): Buffer[] {\n\t\tconst buffers: Buffer[] = [];\n\t\tstream.on('data', (data: Buffer) => {\n\t\t\tbuffers.push(data);\n\t\t});\n\t\treturn buffers;\n\t}\n\n\tprivate decodeData(buffers: Buffer[], encoding: BufferEncoding): string {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\treturn buffers.map(buffer => decoder.write(buffer)).join('');\n\t}\n\n\tprivate initDirectoryTree(): IDirectoryTree {\n\t\tconst tree: IDirectoryTree = {\n\t\t\trootEntries: [],\n\t\t\tpathToEntries: Object.create(null)\n\t\t};\n\t\ttree.pathToEntries['.'] = tree.rootEntries;\n\t\treturn tree;\n\t}\n\n\tprivate addDirectoryEntries(folderQuery: IFolderQuery, { pathToEntries }: IDirectoryTree, base: string, relativeFiles: string[], onResult: (result: IRawFileMatch) => void) {\n\t\t// Support relative paths to files from a root resource (ignores excludes)\n\t\tif (relativeFiles.indexOf(this.filePattern) !== -1) {\n\t\t\tthis.matchFile(onResult, {\n\t\t\t\tbase,\n\t\t\t\trelativePath: this.filePattern,\n\t\t\t\tsearchPath: this.getSearchPath(folderQuery, this.filePattern)\n\t\t\t});\n\t\t}\n\n\t\tconst add = (relativePath: string) => {\n\t\t\tconst basename = path.basename(relativePath);\n\t\t\tconst dirname = path.dirname(relativePath);\n\t\t\tlet entries = pathToEntries[dirname];\n\t\t\tif (!entries) {\n\t\t\t\tentries = pathToEntries[dirname] = [];\n\t\t\t\tadd(dirname);\n\t\t\t}\n\t\t\tentries.push({\n\t\t\t\tbase,\n\t\t\t\trelativePath,\n\t\t\t\tbasename,\n\t\t\t\tsearchPath: this.getSearchPath(folderQuery, relativePath),\n\t\t\t});\n\t\t};\n\t\trelativeFiles.forEach(add);\n\t}\n\n\tprivate matchDirectoryTree({ rootEntries, pathToEntries }: IDirectoryTree, rootFolder: string, onResult: (result: IRawFileMatch) => void) {\n\t\tconst self = this;\n\t\tconst excludePattern = this.folderExcludePatterns.get(rootFolder)!;\n\t\tconst filePattern = this.filePattern;\n\t\tfunction matchDirectory(entries: IDirectoryEntry[]) {\n\t\t\tself.directoriesWalked++;\n\t\t\tconst hasSibling = hasSiblingFn(() => entries.map(entry => entry.basename));\n\t\t\tfor (let i = 0, n = entries.length; i < n; i++) {\n\t\t\t\tconst entry = entries[i];\n\t\t\t\tconst { relativePath, basename } = entry;\n\n\t\t\t\t// Check exclude pattern\n\t\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t\t// to ignore filtering by siblings because the user seems to know what they\n\t\t\t\t// are searching for and we want to include the result in that case anyway\n\t\t\t\tif (excludePattern.test(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst sub = pathToEntries[relativePath];\n\t\t\t\tif (sub) {\n\t\t\t\t\tmatchDirectory(sub);\n\t\t\t\t} else {\n\t\t\t\t\tself.filesWalked++;\n\t\t\t\t\tif (relativePath === filePattern) {\n\t\t\t\t\t\tcontinue; // ignore file if its path matches with the file pattern because that is already matched above\n\t\t\t\t\t}\n\n\t\t\t\t\tself.matchFile(onResult, entry);\n\t\t\t\t}\n\n\t\t\t\tif (self.isLimitHit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatchDirectory(rootEntries);\n\t}\n\n\tgetStats(): ISearchEngineStats {\n\t\treturn {\n\t\t\tcmdTime: this.cmdSW!.elapsed(),\n\t\t\tfileWalkTime: this.fileWalkSW!.elapsed(),\n\t\t\tdirectoriesWalked: this.directoriesWalked,\n\t\t\tfilesWalked: this.filesWalked,\n\t\t\tcmdResultCount: this.cmdResultCount\n\t\t};\n\t}\n\n\tprivate doWalk(folderQuery: IFolderQuery, relativeParentPath: string, files: string[], onResult: (result: IRawFileMatch) => void, done: (error?: Error) => void): void {\n\t\tconst rootFolder = folderQuery.folder;\n\n\t\t// Execute tasks on each file in parallel to optimize throughput\n\t\tconst hasSibling = hasSiblingFn(() => files);\n\t\tthis.parallel(files, (file: string, clb: (error: Error | null, _?: any) => void): void => {\n\n\t\t\t// Check canceled\n\t\t\tif (this.isCanceled || this.isLimitHit) {\n\t\t\t\treturn clb(null);\n\t\t\t}\n\n\t\t\t// Check exclude pattern\n\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t// to ignore filtering by siblings because the user seems to know what they\n\t\t\t// are searching for and we want to include the result in that case anyway\n\t\t\tconst currentRelativePath = relativeParentPath ? [relativeParentPath, file].join(path.sep) : file;\n\t\t\tif (this.folderExcludePatterns.get(folderQuery.folder.fsPath)!.test(currentRelativePath, file, this.config.filePattern !== file ? hasSibling : undefined)) {\n\t\t\t\treturn clb(null);\n\t\t\t}\n\n\t\t\t// Use lstat to detect links\n\t\t\tconst currentAbsolutePath = [rootFolder.fsPath, currentRelativePath].join(path.sep);\n\t\t\tfs.lstat(currentAbsolutePath, (error, lstat) => {\n\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\treturn clb(null);\n\t\t\t\t}\n\n\t\t\t\t// If the path is a link, we must instead use fs.stat() to find out if the\n\t\t\t\t// link is a directory or not because lstat will always return the stat of\n\t\t\t\t// the link which is always a file.\n\t\t\t\tthis.statLinkIfNeeded(currentAbsolutePath, lstat, (error, stat) => {\n\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Directory: Follow directories\n\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\tthis.directoriesWalked++;\n\n\t\t\t\t\t\t// to really prevent loops with links we need to resolve the real path of them\n\t\t\t\t\t\treturn this.realPathIfNeeded(currentAbsolutePath, lstat, (error, realpath) => {\n\t\t\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trealpath = realpath || '';\n\t\t\t\t\t\t\tif (this.walkedPaths[realpath]) {\n\t\t\t\t\t\t\t\treturn clb(null); // escape when there are cycles (can happen with symlinks)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.walkedPaths[realpath] = true; // remember as walked\n\n\t\t\t\t\t\t\t// Continue walking\n\t\t\t\t\t\t\treturn Promises.readdir(currentAbsolutePath).then(children => {\n\t\t\t\t\t\t\t\tif (this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.doWalk(folderQuery, currentRelativePath, children, onResult, err => clb(err || null));\n\t\t\t\t\t\t\t}, error => {\n\t\t\t\t\t\t\t\tclb(null);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.filesWalked++;\n\t\t\t\t\t\tif (currentRelativePath === this.filePattern) {\n\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if its path matches with the file pattern because checkFilePatternRelativeMatch() takes care of those\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.maxFilesize && types.isNumber(stat.size) && stat.size > this.maxFilesize) {\n\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if max file size is hit\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.matchFile(onResult, {\n\t\t\t\t\t\t\tbase: rootFolder.fsPath,\n\t\t\t\t\t\t\trelativePath: currentRelativePath,\n\t\t\t\t\t\t\tsearchPath: this.getSearchPath(folderQuery, currentRelativePath),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unwind\n\t\t\t\t\treturn clb(null, undefined);\n\t\t\t\t});\n\t\t\t});\n\t\t}, (error: Array<Error | null> | null): void => {\n\t\t\tconst filteredErrors = error ? arrays.coalesce(error) : error; // find any error by removing null values first\n\t\t\treturn done(filteredErrors && filteredErrors.length > 0 ? filteredErrors[0] : undefined);\n\t\t});\n\t}\n\n\tprivate matchFile(onResult: (result: IRawFileMatch) => void, candidate: IRawFileMatch): void {\n\t\tif (this.isFileMatch(candidate) && (!this.includePattern || this.includePattern(candidate.relativePath, path.basename(candidate.relativePath)))) {\n\t\t\tthis.resultCount++;\n\n\t\t\tif (this.exists || (this.maxResults && this.resultCount > this.maxResults)) {\n\t\t\t\tthis.isLimitHit = true;\n\t\t\t}\n\n\t\t\tif (!this.isLimitHit) {\n\t\t\t\tonResult(candidate);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isFileMatch(candidate: IRawFileMatch): boolean {\n\t\t// Check for search pattern\n\t\tif (this.filePattern) {\n\t\t\tif (this.filePattern === '*') {\n\t\t\t\treturn true; // support the all-matching wildcard\n\t\t\t}\n\n\t\t\tif (this.normalizedFilePatternLowercase) {\n\t\t\t\treturn isFilePatternMatch(candidate, this.normalizedFilePatternLowercase);\n\t\t\t} else if (this.filePattern) {\n\t\t\t\treturn isFilePatternMatch(candidate, this.filePattern, false);\n\t\t\t}\n\t\t}\n\n\t\t// No patterns means we match all\n\t\treturn true;\n\t}\n\n\tprivate statLinkIfNeeded(path: string, lstat: fs.Stats, clb: (error: Error | null, stat: fs.Stats) => void): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.stat(path, clb); // stat the target the link points to\n\t\t}\n\n\t\treturn clb(null, lstat); // not a link, so the stat is already ok for us\n\t}\n\n\tprivate realPathIfNeeded(path: string, lstat: fs.Stats, clb: (error: Error | null, realpath?: string) => void): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.realpath(path, (error, realpath) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn clb(error);\n\t\t\t\t}\n\n\t\t\t\treturn clb(null, realpath);\n\t\t\t});\n\t\t}\n\n\t\treturn clb(null, path);\n\t}\n\n\t/**\n\t * If we're searching for files in multiple workspace folders, then better prepend the\n\t * name of the workspace folder to the path of the file. This way we'll be able to\n\t * better filter files that are all on the top of a workspace folder and have all the\n\t * same name. A typical example are `package.json` or `README.md` files.\n\t */\n\tprivate getSearchPath(folderQuery: IFolderQuery, relativePath: string): string {\n\t\tif (folderQuery.folderName) {\n\t\t\treturn path.join(folderQuery.folderName, relativePath);\n\t\t}\n\t\treturn relativePath;\n\t}\n}\n\nexport class Engine implements ISearchEngine<IRawFileMatch> {\n\tprivate folderQueries: IFolderQuery[];\n\tprivate extraFiles: URI[];\n\tprivate walker: FileWalker;\n\tprivate numThreads?: number;\n\n\tconstructor(config: IFileQuery, numThreads?: number) {\n\t\tthis.folderQueries = config.folderQueries;\n\t\tthis.extraFiles = config.extraFileResources || [];\n\t\tthis.numThreads = numThreads;\n\n\t\tthis.walker = new FileWalker(config);\n\t}\n\n\tsearch(onResult: (result: IRawFileMatch) => void, onProgress: (progress: IProgressMessage) => void, done: (error: Error | null, complete: ISearchEngineSuccess) => void): void {\n\t\tthis.walker.walk(this.folderQueries, this.extraFiles, this.numThreads, onResult, onProgress, (err: Error | null, isLimitHit: boolean) => {\n\t\t\tdone(err, {\n\t\t\t\tlimitHit: isLimitHit,\n\t\t\t\tstats: this.walker.getStats(),\n\t\t\t\tmessages: [],\n\t\t\t});\n\t\t});\n\t}\n\n\tcancel(): void {\n\t\tthis.walker.cancel();\n\t}\n}\n\n/**\n * This class exists to provide one interface on top of two ParsedExpressions, one for absolute expressions and one for relative expressions.\n * The absolute and relative expressions don't \"have\" to be kept separate, but this keeps us from having to path.join every single\n * file searched, it's only used for a text search with a searchPath\n */\nclass AbsoluteAndRelativeParsedExpression {\n\tprivate absoluteParsedExpr: glob.ParsedExpression | undefined;\n\tprivate relativeParsedExpr: glob.ParsedExpression | undefined;\n\n\tconstructor(public expression: glob.IExpression, private root: string) {\n\t\tthis.init(expression);\n\t}\n\n\t/**\n\t * Split the IExpression into its absolute and relative components, and glob.parse them separately.\n\t */\n\tprivate init(expr: glob.IExpression): void {\n\t\tlet absoluteGlobExpr: glob.IExpression | undefined;\n\t\tlet relativeGlobExpr: glob.IExpression | undefined;\n\t\tObject.keys(expr)\n\t\t\t.filter(key => expr[key])\n\t\t\t.forEach(key => {\n\t\t\t\tif (path.isAbsolute(key)) {\n\t\t\t\t\tabsoluteGlobExpr = absoluteGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\tabsoluteGlobExpr[key] = expr[key];\n\t\t\t\t} else {\n\t\t\t\t\trelativeGlobExpr = relativeGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\trelativeGlobExpr[key] = expr[key];\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.absoluteParsedExpr = absoluteGlobExpr && glob.parse(absoluteGlobExpr, { trimForExclusions: true });\n\t\tthis.relativeParsedExpr = relativeGlobExpr && glob.parse(relativeGlobExpr, { trimForExclusions: true });\n\t}\n\n\ttest(_path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | Promise<string | null> | undefined | null {\n\t\treturn (this.relativeParsedExpr && this.relativeParsedExpr(_path, basename, hasSibling)) ||\n\t\t\t(this.absoluteParsedExpr && this.absoluteParsedExpr(path.join(this.root, _path), basename, hasSibling));\n\t}\n\n\tgetBasenameTerms(): string[] {\n\t\tconst basenameTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tbasenameTerms.push(...glob.getBasenameTerms(this.absoluteParsedExpr));\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tbasenameTerms.push(...glob.getBasenameTerms(this.relativeParsedExpr));\n\t\t}\n\n\t\treturn basenameTerms;\n\t}\n\n\tgetPathTerms(): string[] {\n\t\tconst pathTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.absoluteParsedExpr));\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.relativeParsedExpr));\n\t\t}\n\n\t\treturn pathTerms;\n\t}\n}\n\nfunction rgErrorMsgForDisplay(msg: string): string | undefined {\n\tconst lines = msg.trim().split('\\n');\n\tconst firstLine = lines[0].trim();\n\n\tif (firstLine.startsWith('Error parsing regex')) {\n\t\treturn firstLine;\n\t}\n\n\tif (firstLine.startsWith('regex parse error')) {\n\t\treturn strings.uppercaseFirstLetter(lines[lines.length - 1].trim());\n\t}\n\n\tif (firstLine.startsWith('error parsing glob') ||\n\t\tfirstLine.startsWith('unsupported encoding')) {\n\t\t// Uppercase first letter\n\t\treturn firstLine.charAt(0).toUpperCase() + firstLine.substr(1);\n\t}\n\n\tif (firstLine === `Literal '\\\\n' not allowed.`) {\n\t\t// I won't localize this because none of the Ripgrep error messages are localized\n\t\treturn `Literal '\\\\n' currently not supported`;\n\t}\n\n\tif (firstLine.startsWith('Literal ')) {\n\t\t// Other unsupported chars\n\t\treturn firstLine;\n\t}\n\n\treturn undefined;\n}\n"]}