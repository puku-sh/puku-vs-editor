{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/themes/common/textMateScopeMatcher.ts","vs/workbench/services/themes/common/textMateScopeMatcher.ts"],"names":[],"mappings":"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","file":"textMateScopeMatcher.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nexport interface MatcherWithPriority<T> {\n\tmatcher: Matcher<T>;\n\tpriority: -1 | 0 | 1;\n}\n\nexport interface Matcher<T> {\n\t(matcherInput: T): number;\n}\n\nexport function createMatchers<T>(selector: string, matchesName: (names: string[], matcherInput: T) => number, results: MatcherWithPriority<T>[]): void {\n\tconst tokenizer = newTokenizer(selector);\n\tlet token = tokenizer.next();\n\twhile (token !== null) {\n\t\tlet priority: -1 | 0 | 1 = 0;\n\t\tif (token.length === 2 && token.charAt(1) === ':') {\n\t\t\tswitch (token.charAt(0)) {\n\t\t\t\tcase 'R': priority = 1; break;\n\t\t\t\tcase 'L': priority = -1; break;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(`Unknown priority ${token} in scope selector`);\n\t\t\t}\n\t\t\ttoken = tokenizer.next();\n\t\t}\n\t\tconst matcher = parseConjunction();\n\t\tif (matcher) {\n\t\t\tresults.push({ matcher, priority });\n\t\t}\n\t\tif (token !== ',') {\n\t\t\tbreak;\n\t\t}\n\t\ttoken = tokenizer.next();\n\t}\n\n\tfunction parseOperand(): Matcher<T> | null {\n\t\tif (token === '-') {\n\t\t\ttoken = tokenizer.next();\n\t\t\tconst expressionToNegate = parseOperand();\n\t\t\tif (!expressionToNegate) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn matcherInput => {\n\t\t\t\tconst score = expressionToNegate(matcherInput);\n\t\t\t\treturn score < 0 ? 0 : -1;\n\t\t\t};\n\t\t}\n\t\tif (token === '(') {\n\t\t\ttoken = tokenizer.next();\n\t\t\tconst expressionInParents = parseInnerExpression();\n\t\t\tif (token === ')') {\n\t\t\t\ttoken = tokenizer.next();\n\t\t\t}\n\t\t\treturn expressionInParents;\n\t\t}\n\t\tif (isIdentifier(token)) {\n\t\t\tconst identifiers: string[] = [];\n\t\t\tdo {\n\t\t\t\tidentifiers.push(token);\n\t\t\t\ttoken = tokenizer.next();\n\t\t\t} while (isIdentifier(token));\n\t\t\treturn matcherInput => matchesName(identifiers, matcherInput);\n\t\t}\n\t\treturn null;\n\t}\n\tfunction parseConjunction(): Matcher<T> | null {\n\t\tlet matcher = parseOperand();\n\t\tif (!matcher) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matchers: Matcher<T>[] = [];\n\t\twhile (matcher) {\n\t\t\tmatchers.push(matcher);\n\t\t\tmatcher = parseOperand();\n\t\t}\n\t\treturn matcherInput => {  // and\n\t\t\tlet min = matchers[0](matcherInput);\n\t\t\tfor (let i = 1; min >= 0 && i < matchers.length; i++) {\n\t\t\t\tmin = Math.min(min, matchers[i](matcherInput));\n\t\t\t}\n\t\t\treturn min;\n\t\t};\n\t}\n\tfunction parseInnerExpression(): Matcher<T> | null {\n\t\tlet matcher = parseConjunction();\n\t\tif (!matcher) {\n\t\t\treturn null;\n\t\t}\n\t\tconst matchers: Matcher<T>[] = [];\n\t\twhile (matcher) {\n\t\t\tmatchers.push(matcher);\n\t\t\tif (token === '|' || token === ',') {\n\t\t\t\tdo {\n\t\t\t\t\ttoken = tokenizer.next();\n\t\t\t\t} while (token === '|' || token === ','); // ignore subsequent commas\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatcher = parseConjunction();\n\t\t}\n\t\treturn matcherInput => {  // or\n\t\t\tlet max = matchers[0](matcherInput);\n\t\t\tfor (let i = 1; i < matchers.length; i++) {\n\t\t\t\tmax = Math.max(max, matchers[i](matcherInput));\n\t\t\t}\n\t\t\treturn max;\n\t\t};\n\t}\n}\n\nfunction isIdentifier(token: string | null): token is string {\n\treturn !!token && !!token.match(/[\\w\\.:]+/);\n}\n\nfunction newTokenizer(input: string): { next: () => string | null } {\n\tconst regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n\tlet match = regex.exec(input);\n\treturn {\n\t\tnext: () => {\n\t\t\tif (!match) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst res = match[0];\n\t\t\tmatch = regex.exec(input);\n\t\t\treturn res;\n\t\t}\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nexport interface MatcherWithPriority<T> {\n\tmatcher: Matcher<T>;\n\tpriority: -1 | 0 | 1;\n}\n\nexport interface Matcher<T> {\n\t(matcherInput: T): number;\n}\n\nexport function createMatchers<T>(selector: string, matchesName: (names: string[], matcherInput: T) => number, results: MatcherWithPriority<T>[]): void {\n\tconst tokenizer = newTokenizer(selector);\n\tlet token = tokenizer.next();\n\twhile (token !== null) {\n\t\tlet priority: -1 | 0 | 1 = 0;\n\t\tif (token.length === 2 && token.charAt(1) === ':') {\n\t\t\tswitch (token.charAt(0)) {\n\t\t\t\tcase 'R': priority = 1; break;\n\t\t\t\tcase 'L': priority = -1; break;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(`Unknown priority ${token} in scope selector`);\n\t\t\t}\n\t\t\ttoken = tokenizer.next();\n\t\t}\n\t\tconst matcher = parseConjunction();\n\t\tif (matcher) {\n\t\t\tresults.push({ matcher, priority });\n\t\t}\n\t\tif (token !== ',') {\n\t\t\tbreak;\n\t\t}\n\t\ttoken = tokenizer.next();\n\t}\n\n\tfunction parseOperand(): Matcher<T> | null {\n\t\tif (token === '-') {\n\t\t\ttoken = tokenizer.next();\n\t\t\tconst expressionToNegate = parseOperand();\n\t\t\tif (!expressionToNegate) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn matcherInput => {\n\t\t\t\tconst score = expressionToNegate(matcherInput);\n\t\t\t\treturn score < 0 ? 0 : -1;\n\t\t\t};\n\t\t}\n\t\tif (token === '(') {\n\t\t\ttoken = tokenizer.next();\n\t\t\tconst expressionInParents = parseInnerExpression();\n\t\t\tif (token === ')') {\n\t\t\t\ttoken = tokenizer.next();\n\t\t\t}\n\t\t\treturn expressionInParents;\n\t\t}\n\t\tif (isIdentifier(token)) {\n\t\t\tconst identifiers: string[] = [];\n\t\t\tdo {\n\t\t\t\tidentifiers.push(token);\n\t\t\t\ttoken = tokenizer.next();\n\t\t\t} while (isIdentifier(token));\n\t\t\treturn matcherInput => matchesName(identifiers, matcherInput);\n\t\t}\n\t\treturn null;\n\t}\n\tfunction parseConjunction(): Matcher<T> | null {\n\t\tlet matcher = parseOperand();\n\t\tif (!matcher) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matchers: Matcher<T>[] = [];\n\t\twhile (matcher) {\n\t\t\tmatchers.push(matcher);\n\t\t\tmatcher = parseOperand();\n\t\t}\n\t\treturn matcherInput => {  // and\n\t\t\tlet min = matchers[0](matcherInput);\n\t\t\tfor (let i = 1; min >= 0 && i < matchers.length; i++) {\n\t\t\t\tmin = Math.min(min, matchers[i](matcherInput));\n\t\t\t}\n\t\t\treturn min;\n\t\t};\n\t}\n\tfunction parseInnerExpression(): Matcher<T> | null {\n\t\tlet matcher = parseConjunction();\n\t\tif (!matcher) {\n\t\t\treturn null;\n\t\t}\n\t\tconst matchers: Matcher<T>[] = [];\n\t\twhile (matcher) {\n\t\t\tmatchers.push(matcher);\n\t\t\tif (token === '|' || token === ',') {\n\t\t\t\tdo {\n\t\t\t\t\ttoken = tokenizer.next();\n\t\t\t\t} while (token === '|' || token === ','); // ignore subsequent commas\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatcher = parseConjunction();\n\t\t}\n\t\treturn matcherInput => {  // or\n\t\t\tlet max = matchers[0](matcherInput);\n\t\t\tfor (let i = 1; i < matchers.length; i++) {\n\t\t\t\tmax = Math.max(max, matchers[i](matcherInput));\n\t\t\t}\n\t\t\treturn max;\n\t\t};\n\t}\n}\n\nfunction isIdentifier(token: string | null): token is string {\n\treturn !!token && !!token.match(/[\\w\\.:]+/);\n}\n\nfunction newTokenizer(input: string): { next: () => string | null } {\n\tconst regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n\tlet match = regex.exec(input);\n\treturn {\n\t\tnext: () => {\n\t\t\tif (!match) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst res = match[0];\n\t\t\tmatch = regex.exec(input);\n\t\t\treturn res;\n\t\t}\n\t};\n}\n"]}