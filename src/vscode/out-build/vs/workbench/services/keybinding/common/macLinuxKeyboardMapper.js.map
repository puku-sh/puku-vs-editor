{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/keybinding/common/macLinuxKeyboardMapper.ts","vs/workbench/services/keybinding/common/macLinuxKeyboardMapper.ts"],"names":[],"mappings":"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","file":"macLinuxKeyboardMapper.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { KeyCode, KeyCodeUtils, IMMUTABLE_CODE_TO_KEY_CODE, IMMUTABLE_KEY_CODE_TO_CODE, ScanCode, ScanCodeUtils, isModifierKey } from '../../../../base/common/keyCodes.js';\nimport { ResolvedKeybinding, KeyCodeChord, SingleModifierChord, ScanCodeChord, Keybinding, Chord } from '../../../../base/common/keybindings.js';\nimport { OperatingSystem } from '../../../../base/common/platform.js';\nimport { IKeyboardEvent } from '../../../../platform/keybinding/common/keybinding.js';\nimport { IKeyboardMapper } from '../../../../platform/keyboardLayout/common/keyboardMapper.js';\nimport { BaseResolvedKeybinding } from '../../../../platform/keybinding/common/baseResolvedKeybinding.js';\nimport { IMacLinuxKeyboardMapping, IMacLinuxKeyMapping } from '../../../../platform/keyboardLayout/common/keyboardLayout.js';\n\n/**\n * A map from character to key codes.\n * e.g. Contains entries such as:\n *  - '/' => { keyCode: KeyCode.US_SLASH, shiftKey: false }\n *  - '?' => { keyCode: KeyCode.US_SLASH, shiftKey: true }\n */\nconst CHAR_CODE_TO_KEY_CODE: ({ keyCode: KeyCode; shiftKey: boolean } | null)[] = [];\n\nexport class NativeResolvedKeybinding extends BaseResolvedKeybinding<ScanCodeChord> {\n\n\tprivate readonly _mapper: MacLinuxKeyboardMapper;\n\n\tconstructor(mapper: MacLinuxKeyboardMapper, os: OperatingSystem, chords: ScanCodeChord[]) {\n\t\tsuper(os, chords);\n\t\tthis._mapper = mapper;\n\t}\n\n\tprotected _getLabel(chord: ScanCodeChord): string | null {\n\t\treturn this._mapper.getUILabelForScanCodeChord(chord);\n\t}\n\n\tprotected _getAriaLabel(chord: ScanCodeChord): string | null {\n\t\treturn this._mapper.getAriaLabelForScanCodeChord(chord);\n\t}\n\n\tprotected _getElectronAccelerator(chord: ScanCodeChord): string | null {\n\t\treturn this._mapper.getElectronAcceleratorLabelForScanCodeChord(chord);\n\t}\n\n\tprotected _getUserSettingsLabel(chord: ScanCodeChord): string | null {\n\t\treturn this._mapper.getUserSettingsLabelForScanCodeChord(chord);\n\t}\n\n\tprotected _isWYSIWYG(binding: ScanCodeChord | null): boolean {\n\t\tif (!binding) {\n\t\t\treturn true;\n\t\t}\n\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode] !== KeyCode.DependsOnKbLayout) {\n\t\t\treturn true;\n\t\t}\n\t\tconst a = this._mapper.getAriaLabelForScanCodeChord(binding);\n\t\tconst b = this._mapper.getUserSettingsLabelForScanCodeChord(binding);\n\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || !b) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (a.toLowerCase() === b.toLowerCase());\n\t}\n\n\tprotected _getChordDispatch(chord: ScanCodeChord): string | null {\n\t\treturn this._mapper.getDispatchStrForScanCodeChord(chord);\n\t}\n\n\tprotected _getSingleModifierChordDispatch(chord: ScanCodeChord): SingleModifierChord | null {\n\t\tif ((chord.scanCode === ScanCode.ControlLeft || chord.scanCode === ScanCode.ControlRight) && !chord.shiftKey && !chord.altKey && !chord.metaKey) {\n\t\t\treturn 'ctrl';\n\t\t}\n\t\tif ((chord.scanCode === ScanCode.AltLeft || chord.scanCode === ScanCode.AltRight) && !chord.ctrlKey && !chord.shiftKey && !chord.metaKey) {\n\t\t\treturn 'alt';\n\t\t}\n\t\tif ((chord.scanCode === ScanCode.ShiftLeft || chord.scanCode === ScanCode.ShiftRight) && !chord.ctrlKey && !chord.altKey && !chord.metaKey) {\n\t\t\treturn 'shift';\n\t\t}\n\t\tif ((chord.scanCode === ScanCode.MetaLeft || chord.scanCode === ScanCode.MetaRight) && !chord.ctrlKey && !chord.shiftKey && !chord.altKey) {\n\t\t\treturn 'meta';\n\t\t}\n\t\treturn null;\n\t}\n}\n\ninterface IScanCodeMapping {\n\tscanCode: ScanCode;\n\tvalue: number;\n\twithShift: number;\n\twithAltGr: number;\n\twithShiftAltGr: number;\n}\n\nclass ScanCodeCombo {\n\tpublic readonly ctrlKey: boolean;\n\tpublic readonly shiftKey: boolean;\n\tpublic readonly altKey: boolean;\n\tpublic readonly scanCode: ScanCode;\n\n\tconstructor(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, scanCode: ScanCode) {\n\t\tthis.ctrlKey = ctrlKey;\n\t\tthis.shiftKey = shiftKey;\n\t\tthis.altKey = altKey;\n\t\tthis.scanCode = scanCode;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.ctrlKey ? 'Ctrl+' : ''}${this.shiftKey ? 'Shift+' : ''}${this.altKey ? 'Alt+' : ''}${ScanCodeUtils.toString(this.scanCode)}`;\n\t}\n\n\tpublic equals(other: ScanCodeCombo): boolean {\n\t\treturn (\n\t\t\tthis.ctrlKey === other.ctrlKey\n\t\t\t&& this.shiftKey === other.shiftKey\n\t\t\t&& this.altKey === other.altKey\n\t\t\t&& this.scanCode === other.scanCode\n\t\t);\n\t}\n\n\tprivate getProducedCharCode(mapping: IMacLinuxKeyMapping): string {\n\t\tif (!mapping) {\n\t\t\treturn '';\n\t\t}\n\t\tif (this.ctrlKey && this.shiftKey && this.altKey) {\n\t\t\treturn mapping.withShiftAltGr;\n\t\t}\n\t\tif (this.ctrlKey && this.altKey) {\n\t\t\treturn mapping.withAltGr;\n\t\t}\n\t\tif (this.shiftKey) {\n\t\t\treturn mapping.withShift;\n\t\t}\n\t\treturn mapping.value;\n\t}\n\n\tpublic getProducedChar(mapping: IMacLinuxKeyMapping): string {\n\t\tconst charCode = MacLinuxKeyboardMapper.getCharCode(this.getProducedCharCode(mapping));\n\t\tif (charCode === 0) {\n\t\t\treturn ' --- ';\n\t\t}\n\t\tif (charCode >= CharCode.U_Combining_Grave_Accent && charCode <= CharCode.U_Combining_Latin_Small_Letter_X) {\n\t\t\t// combining\n\t\t\treturn 'U+' + charCode.toString(16);\n\t\t}\n\t\treturn '  ' + String.fromCharCode(charCode) + '  ';\n\t}\n}\n\nclass KeyCodeCombo {\n\tpublic readonly ctrlKey: boolean;\n\tpublic readonly shiftKey: boolean;\n\tpublic readonly altKey: boolean;\n\tpublic readonly keyCode: KeyCode;\n\n\tconstructor(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, keyCode: KeyCode) {\n\t\tthis.ctrlKey = ctrlKey;\n\t\tthis.shiftKey = shiftKey;\n\t\tthis.altKey = altKey;\n\t\tthis.keyCode = keyCode;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.ctrlKey ? 'Ctrl+' : ''}${this.shiftKey ? 'Shift+' : ''}${this.altKey ? 'Alt+' : ''}${KeyCodeUtils.toString(this.keyCode)}`;\n\t}\n}\n\nclass ScanCodeKeyCodeMapper {\n\n\t/**\n\t * ScanCode combination => KeyCode combination.\n\t * Only covers relevant modifiers ctrl, shift, alt (since meta does not influence the mappings).\n\t */\n\tprivate readonly _scanCodeToKeyCode: number[][] = [];\n\t/**\n\t * inverse of `_scanCodeToKeyCode`.\n\t * KeyCode combination => ScanCode combination.\n\t * Only covers relevant modifiers ctrl, shift, alt (since meta does not influence the mappings).\n\t */\n\tprivate readonly _keyCodeToScanCode: number[][] = [];\n\n\tconstructor() {\n\t\tthis._scanCodeToKeyCode = [];\n\t\tthis._keyCodeToScanCode = [];\n\t}\n\n\tpublic registrationComplete(): void {\n\t\t// IntlHash and IntlBackslash are rare keys, so ensure they don't end up being the preferred...\n\t\tthis._moveToEnd(ScanCode.IntlHash);\n\t\tthis._moveToEnd(ScanCode.IntlBackslash);\n\t}\n\n\tprivate _moveToEnd(scanCode: ScanCode): void {\n\t\tfor (let mod = 0; mod < 8; mod++) {\n\t\t\tconst encodedKeyCodeCombos = this._scanCodeToKeyCode[(scanCode << 3) + mod];\n\t\t\tif (!encodedKeyCodeCombos) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (let i = 0, len = encodedKeyCodeCombos.length; i < len; i++) {\n\t\t\t\tconst encodedScanCodeCombos = this._keyCodeToScanCode[encodedKeyCodeCombos[i]];\n\t\t\t\tif (encodedScanCodeCombos.length === 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (let j = 0, len = encodedScanCodeCombos.length; j < len; j++) {\n\t\t\t\t\tconst entry = encodedScanCodeCombos[j];\n\t\t\t\t\tconst entryScanCode = (entry >>> 3);\n\t\t\t\t\tif (entryScanCode === scanCode) {\n\t\t\t\t\t\t// Move this entry to the end\n\t\t\t\t\t\tfor (let k = j + 1; k < len; k++) {\n\t\t\t\t\t\t\tencodedScanCodeCombos[k - 1] = encodedScanCodeCombos[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencodedScanCodeCombos[len - 1] = entry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic registerIfUnknown(scanCodeCombo: ScanCodeCombo, keyCodeCombo: KeyCodeCombo): void {\n\t\tif (keyCodeCombo.keyCode === KeyCode.Unknown) {\n\t\t\treturn;\n\t\t}\n\t\tconst scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);\n\t\tconst keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);\n\n\t\tconst keyCodeIsDigit = (keyCodeCombo.keyCode >= KeyCode.Digit0 && keyCodeCombo.keyCode <= KeyCode.Digit9);\n\t\tconst keyCodeIsLetter = (keyCodeCombo.keyCode >= KeyCode.KeyA && keyCodeCombo.keyCode <= KeyCode.KeyZ);\n\n\t\tconst existingKeyCodeCombos = this._scanCodeToKeyCode[scanCodeComboEncoded];\n\n\t\t// Allow a scan code to map to multiple key codes if it is a digit or a letter key code\n\t\tif (keyCodeIsDigit || keyCodeIsLetter) {\n\t\t\t// Only check that we don't insert the same entry twice\n\t\t\tif (existingKeyCodeCombos) {\n\t\t\t\tfor (let i = 0, len = existingKeyCodeCombos.length; i < len; i++) {\n\t\t\t\t\tif (existingKeyCodeCombos[i] === keyCodeComboEncoded) {\n\t\t\t\t\t\t// avoid duplicates\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Don't allow multiples\n\t\t\tif (existingKeyCodeCombos && existingKeyCodeCombos.length !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis._scanCodeToKeyCode[scanCodeComboEncoded] = this._scanCodeToKeyCode[scanCodeComboEncoded] || [];\n\t\tthis._scanCodeToKeyCode[scanCodeComboEncoded].unshift(keyCodeComboEncoded);\n\n\t\tthis._keyCodeToScanCode[keyCodeComboEncoded] = this._keyCodeToScanCode[keyCodeComboEncoded] || [];\n\t\tthis._keyCodeToScanCode[keyCodeComboEncoded].unshift(scanCodeComboEncoded);\n\t}\n\n\tpublic lookupKeyCodeCombo(keyCodeCombo: KeyCodeCombo): ScanCodeCombo[] {\n\t\tconst keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);\n\t\tconst scanCodeCombosEncoded = this._keyCodeToScanCode[keyCodeComboEncoded];\n\t\tif (!scanCodeCombosEncoded || scanCodeCombosEncoded.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: ScanCodeCombo[] = [];\n\t\tfor (let i = 0, len = scanCodeCombosEncoded.length; i < len; i++) {\n\t\t\tconst scanCodeComboEncoded = scanCodeCombosEncoded[i];\n\n\t\t\tconst ctrlKey = (scanCodeComboEncoded & 0b001) ? true : false;\n\t\t\tconst shiftKey = (scanCodeComboEncoded & 0b010) ? true : false;\n\t\t\tconst altKey = (scanCodeComboEncoded & 0b100) ? true : false;\n\t\t\tconst scanCode: ScanCode = (scanCodeComboEncoded >>> 3);\n\n\t\t\tresult[i] = new ScanCodeCombo(ctrlKey, shiftKey, altKey, scanCode);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic lookupScanCodeCombo(scanCodeCombo: ScanCodeCombo): KeyCodeCombo[] {\n\t\tconst scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);\n\t\tconst keyCodeCombosEncoded = this._scanCodeToKeyCode[scanCodeComboEncoded];\n\t\tif (!keyCodeCombosEncoded || keyCodeCombosEncoded.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: KeyCodeCombo[] = [];\n\t\tfor (let i = 0, len = keyCodeCombosEncoded.length; i < len; i++) {\n\t\t\tconst keyCodeComboEncoded = keyCodeCombosEncoded[i];\n\n\t\t\tconst ctrlKey = (keyCodeComboEncoded & 0b001) ? true : false;\n\t\t\tconst shiftKey = (keyCodeComboEncoded & 0b010) ? true : false;\n\t\t\tconst altKey = (keyCodeComboEncoded & 0b100) ? true : false;\n\t\t\tconst keyCode: KeyCode = (keyCodeComboEncoded >>> 3);\n\n\t\t\tresult[i] = new KeyCodeCombo(ctrlKey, shiftKey, altKey, keyCode);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic guessStableKeyCode(scanCode: ScanCode): KeyCode {\n\t\tif (scanCode >= ScanCode.Digit1 && scanCode <= ScanCode.Digit0) {\n\t\t\t// digits are ok\n\t\t\tswitch (scanCode) {\n\t\t\t\tcase ScanCode.Digit1: return KeyCode.Digit1;\n\t\t\t\tcase ScanCode.Digit2: return KeyCode.Digit2;\n\t\t\t\tcase ScanCode.Digit3: return KeyCode.Digit3;\n\t\t\t\tcase ScanCode.Digit4: return KeyCode.Digit4;\n\t\t\t\tcase ScanCode.Digit5: return KeyCode.Digit5;\n\t\t\t\tcase ScanCode.Digit6: return KeyCode.Digit6;\n\t\t\t\tcase ScanCode.Digit7: return KeyCode.Digit7;\n\t\t\t\tcase ScanCode.Digit8: return KeyCode.Digit8;\n\t\t\t\tcase ScanCode.Digit9: return KeyCode.Digit9;\n\t\t\t\tcase ScanCode.Digit0: return KeyCode.Digit0;\n\t\t\t}\n\t\t}\n\n\t\t// Lookup the scanCode with and without shift and see if the keyCode is stable\n\t\tconst keyCodeCombos1 = this.lookupScanCodeCombo(new ScanCodeCombo(false, false, false, scanCode));\n\t\tconst keyCodeCombos2 = this.lookupScanCodeCombo(new ScanCodeCombo(false, true, false, scanCode));\n\t\tif (keyCodeCombos1.length === 1 && keyCodeCombos2.length === 1) {\n\t\t\tconst shiftKey1 = keyCodeCombos1[0].shiftKey;\n\t\t\tconst keyCode1 = keyCodeCombos1[0].keyCode;\n\t\t\tconst shiftKey2 = keyCodeCombos2[0].shiftKey;\n\t\t\tconst keyCode2 = keyCodeCombos2[0].keyCode;\n\t\t\tif (keyCode1 === keyCode2 && shiftKey1 !== shiftKey2) {\n\t\t\t\t// This looks like a stable mapping\n\t\t\t\treturn keyCode1;\n\t\t\t}\n\t\t}\n\n\t\treturn KeyCode.DependsOnKbLayout;\n\t}\n\n\tprivate _encodeScanCodeCombo(scanCodeCombo: ScanCodeCombo): number {\n\t\treturn this._encode(scanCodeCombo.ctrlKey, scanCodeCombo.shiftKey, scanCodeCombo.altKey, scanCodeCombo.scanCode);\n\t}\n\n\tprivate _encodeKeyCodeCombo(keyCodeCombo: KeyCodeCombo): number {\n\t\treturn this._encode(keyCodeCombo.ctrlKey, keyCodeCombo.shiftKey, keyCodeCombo.altKey, keyCodeCombo.keyCode);\n\t}\n\n\tprivate _encode(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, principal: number): number {\n\t\treturn (\n\t\t\t((ctrlKey ? 1 : 0) << 0)\n\t\t\t| ((shiftKey ? 1 : 0) << 1)\n\t\t\t| ((altKey ? 1 : 0) << 2)\n\t\t\t| principal << 3\n\t\t) >>> 0;\n\t}\n}\n\nexport class MacLinuxKeyboardMapper implements IKeyboardMapper {\n\n\t/**\n\t * used only for debug purposes.\n\t */\n\tprivate readonly _codeInfo: IMacLinuxKeyMapping[];\n\t/**\n\t * Maps ScanCode combos <-> KeyCode combos.\n\t */\n\tprivate readonly _scanCodeKeyCodeMapper: ScanCodeKeyCodeMapper;\n\t/**\n\t * UI label for a ScanCode.\n\t */\n\tprivate readonly _scanCodeToLabel: Array<string | null> = [];\n\t/**\n\t * Dispatching string for a ScanCode.\n\t */\n\tprivate readonly _scanCodeToDispatch: Array<string | null> = [];\n\n\tconstructor(\n\t\tprivate readonly _isUSStandard: boolean,\n\t\trawMappings: IMacLinuxKeyboardMapping,\n\t\tprivate readonly _mapAltGrToCtrlAlt: boolean,\n\t\tprivate readonly _OS: OperatingSystem,\n\t) {\n\t\tthis._codeInfo = [];\n\t\tthis._scanCodeKeyCodeMapper = new ScanCodeKeyCodeMapper();\n\t\tthis._scanCodeToLabel = [];\n\t\tthis._scanCodeToDispatch = [];\n\n\t\tconst _registerIfUnknown = (\n\t\t\thwCtrlKey: 0 | 1, hwShiftKey: 0 | 1, hwAltKey: 0 | 1, scanCode: ScanCode,\n\t\t\tkbCtrlKey: 0 | 1, kbShiftKey: 0 | 1, kbAltKey: 0 | 1, keyCode: KeyCode,\n\t\t): void => {\n\t\t\tthis._scanCodeKeyCodeMapper.registerIfUnknown(\n\t\t\t\tnew ScanCodeCombo(hwCtrlKey ? true : false, hwShiftKey ? true : false, hwAltKey ? true : false, scanCode),\n\t\t\t\tnew KeyCodeCombo(kbCtrlKey ? true : false, kbShiftKey ? true : false, kbAltKey ? true : false, keyCode)\n\t\t\t);\n\t\t};\n\n\t\tconst _registerAllCombos = (_ctrlKey: 0 | 1, _shiftKey: 0 | 1, _altKey: 0 | 1, scanCode: ScanCode, keyCode: KeyCode): void => {\n\t\t\tfor (let ctrlKey = _ctrlKey; ctrlKey <= 1; ctrlKey++) {\n\t\t\t\tfor (let shiftKey = _shiftKey; shiftKey <= 1; shiftKey++) {\n\t\t\t\t\tfor (let altKey = _altKey; altKey <= 1; altKey++) {\n\t\t\t\t\t\t_registerIfUnknown(\n\t\t\t\t\t\t\tctrlKey, shiftKey, altKey, scanCode,\n\t\t\t\t\t\t\tctrlKey, shiftKey, altKey, keyCode\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Initialize `_scanCodeToLabel`\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tthis._scanCodeToLabel[scanCode] = null;\n\t\t}\n\n\t\t// Initialize `_scanCodeToDispatch`\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tthis._scanCodeToDispatch[scanCode] = null;\n\t\t}\n\n\t\t// Handle immutable mappings\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tconst keyCode = IMMUTABLE_CODE_TO_KEY_CODE[scanCode];\n\t\t\tif (keyCode !== KeyCode.DependsOnKbLayout) {\n\t\t\t\t_registerAllCombos(0, 0, 0, scanCode, keyCode);\n\t\t\t\tthis._scanCodeToLabel[scanCode] = KeyCodeUtils.toString(keyCode);\n\n\t\t\t\tif (keyCode === KeyCode.Unknown || isModifierKey(keyCode)) {\n\t\t\t\t\tthis._scanCodeToDispatch[scanCode] = null; // cannot dispatch on this ScanCode\n\t\t\t\t} else {\n\t\t\t\t\tthis._scanCodeToDispatch[scanCode] = `[${ScanCodeUtils.toString(scanCode)}]`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Try to identify keyboard layouts where characters A-Z are missing\n\t\t// and forcibly map them to their corresponding scan codes if that is the case\n\t\tconst missingLatinLettersOverride: { [scanCode: string]: IMacLinuxKeyMapping } = {};\n\n\t\t{\n\t\t\tconst producesLatinLetter: boolean[] = [];\n\t\t\tfor (const strScanCode in rawMappings) {\n\t\t\t\tif (rawMappings.hasOwnProperty(strScanCode)) {\n\t\t\t\t\tconst scanCode = ScanCodeUtils.toEnum(strScanCode);\n\t\t\t\t\tif (scanCode === ScanCode.None) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== KeyCode.DependsOnKbLayout) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rawMapping = rawMappings[strScanCode];\n\t\t\t\t\tconst value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);\n\n\t\t\t\t\tif (value >= CharCode.a && value <= CharCode.z) {\n\t\t\t\t\t\tconst upperCaseValue = CharCode.A + (value - CharCode.a);\n\t\t\t\t\t\tproducesLatinLetter[upperCaseValue] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst _registerLetterIfMissing = (charCode: CharCode, scanCode: ScanCode, value: string, withShift: string): void => {\n\t\t\t\tif (!producesLatinLetter[charCode]) {\n\t\t\t\t\tmissingLatinLettersOverride[ScanCodeUtils.toString(scanCode)] = {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\twithShift: withShift,\n\t\t\t\t\t\twithAltGr: '',\n\t\t\t\t\t\twithShiftAltGr: ''\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Ensure letters are mapped\n\t\t\t_registerLetterIfMissing(CharCode.A, ScanCode.KeyA, 'a', 'A');\n\t\t\t_registerLetterIfMissing(CharCode.B, ScanCode.KeyB, 'b', 'B');\n\t\t\t_registerLetterIfMissing(CharCode.C, ScanCode.KeyC, 'c', 'C');\n\t\t\t_registerLetterIfMissing(CharCode.D, ScanCode.KeyD, 'd', 'D');\n\t\t\t_registerLetterIfMissing(CharCode.E, ScanCode.KeyE, 'e', 'E');\n\t\t\t_registerLetterIfMissing(CharCode.F, ScanCode.KeyF, 'f', 'F');\n\t\t\t_registerLetterIfMissing(CharCode.G, ScanCode.KeyG, 'g', 'G');\n\t\t\t_registerLetterIfMissing(CharCode.H, ScanCode.KeyH, 'h', 'H');\n\t\t\t_registerLetterIfMissing(CharCode.I, ScanCode.KeyI, 'i', 'I');\n\t\t\t_registerLetterIfMissing(CharCode.J, ScanCode.KeyJ, 'j', 'J');\n\t\t\t_registerLetterIfMissing(CharCode.K, ScanCode.KeyK, 'k', 'K');\n\t\t\t_registerLetterIfMissing(CharCode.L, ScanCode.KeyL, 'l', 'L');\n\t\t\t_registerLetterIfMissing(CharCode.M, ScanCode.KeyM, 'm', 'M');\n\t\t\t_registerLetterIfMissing(CharCode.N, ScanCode.KeyN, 'n', 'N');\n\t\t\t_registerLetterIfMissing(CharCode.O, ScanCode.KeyO, 'o', 'O');\n\t\t\t_registerLetterIfMissing(CharCode.P, ScanCode.KeyP, 'p', 'P');\n\t\t\t_registerLetterIfMissing(CharCode.Q, ScanCode.KeyQ, 'q', 'Q');\n\t\t\t_registerLetterIfMissing(CharCode.R, ScanCode.KeyR, 'r', 'R');\n\t\t\t_registerLetterIfMissing(CharCode.S, ScanCode.KeyS, 's', 'S');\n\t\t\t_registerLetterIfMissing(CharCode.T, ScanCode.KeyT, 't', 'T');\n\t\t\t_registerLetterIfMissing(CharCode.U, ScanCode.KeyU, 'u', 'U');\n\t\t\t_registerLetterIfMissing(CharCode.V, ScanCode.KeyV, 'v', 'V');\n\t\t\t_registerLetterIfMissing(CharCode.W, ScanCode.KeyW, 'w', 'W');\n\t\t\t_registerLetterIfMissing(CharCode.X, ScanCode.KeyX, 'x', 'X');\n\t\t\t_registerLetterIfMissing(CharCode.Y, ScanCode.KeyY, 'y', 'Y');\n\t\t\t_registerLetterIfMissing(CharCode.Z, ScanCode.KeyZ, 'z', 'Z');\n\t\t}\n\n\t\tconst mappings: IScanCodeMapping[] = [];\n\t\tlet mappingsLen = 0;\n\t\tfor (const strScanCode in rawMappings) {\n\t\t\tif (rawMappings.hasOwnProperty(strScanCode)) {\n\t\t\t\tconst scanCode = ScanCodeUtils.toEnum(strScanCode);\n\t\t\t\tif (scanCode === ScanCode.None) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== KeyCode.DependsOnKbLayout) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tthis._codeInfo[scanCode] = rawMappings[strScanCode];\n\n\t\t\t\tconst rawMapping = missingLatinLettersOverride[strScanCode] || rawMappings[strScanCode];\n\t\t\t\tconst value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);\n\t\t\t\tconst withShift = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShift);\n\t\t\t\tconst withAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withAltGr);\n\t\t\t\tconst withShiftAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShiftAltGr);\n\n\t\t\t\tconst mapping: IScanCodeMapping = {\n\t\t\t\t\tscanCode: scanCode,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\twithShift: withShift,\n\t\t\t\t\twithAltGr: withAltGr,\n\t\t\t\t\twithShiftAltGr: withShiftAltGr,\n\t\t\t\t};\n\t\t\t\tmappings[mappingsLen++] = mapping;\n\n\t\t\t\tthis._scanCodeToDispatch[scanCode] = `[${ScanCodeUtils.toString(scanCode)}]`;\n\n\t\t\t\tif (value >= CharCode.a && value <= CharCode.z) {\n\t\t\t\t\tconst upperCaseValue = CharCode.A + (value - CharCode.a);\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = String.fromCharCode(upperCaseValue);\n\t\t\t\t} else if (value >= CharCode.A && value <= CharCode.Z) {\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = String.fromCharCode(value);\n\t\t\t\t} else if (value) {\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = String.fromCharCode(value);\n\t\t\t\t} else {\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle all `withShiftAltGr` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst withShiftAltGr = mapping.withShiftAltGr;\n\t\t\tif (withShiftAltGr === mapping.withAltGr || withShiftAltGr === mapping.withShift || withShiftAltGr === mapping.value) {\n\t\t\t\t// handled below\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(withShiftAltGr);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// Ctrl+Shift+Alt+ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 0, 1, 0, keyCode); //       Ctrl+Alt+ScanCode =>          Shift+KeyCode\n\t\t\t} else {\n\t\t\t\t// Ctrl+Shift+Alt+ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 0, 0, 0, keyCode); //       Ctrl+Alt+ScanCode =>                KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all `withAltGr` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst withAltGr = mapping.withAltGr;\n\t\t\tif (withAltGr === mapping.withShift || withAltGr === mapping.value) {\n\t\t\t\t// handled below\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(withAltGr);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// Ctrl+Alt+ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 0, 1, 0, keyCode); //       Ctrl+Alt+ScanCode =>          Shift+KeyCode\n\t\t\t} else {\n\t\t\t\t// Ctrl+Alt+ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 0, 0, 0, keyCode); //       Ctrl+Alt+ScanCode =>                KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all `withShift` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst withShift = mapping.withShift;\n\t\t\tif (withShift === mapping.value) {\n\t\t\t\t// handled below\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(withShift);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// Shift+ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t} else {\n\t\t\t\t// Shift+ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 0, 0, keyCode); //          Shift+ScanCode =>                KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 0, 1, keyCode); //      Shift+Alt+ScanCode =>            Alt+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 0, 0, keyCode); //     Ctrl+Shift+ScanCode =>           Ctrl+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 0, 1, keyCode); // Ctrl+Shift+Alt+ScanCode =>       Ctrl+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all `value` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(mapping.value);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 0, scanCode, 0, 1, 0, keyCode); //                ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 1, scanCode, 0, 1, 1, keyCode); //            Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 0, scanCode, 1, 1, 0, keyCode); //           Ctrl+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 1, 1, 1, keyCode); //       Ctrl+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t} else {\n\t\t\t\t// ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 0, scanCode, 0, 0, 0, keyCode); //                ScanCode =>                KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 1, scanCode, 0, 0, 1, keyCode); //            Alt+ScanCode =>            Alt+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 0, scanCode, 1, 0, 0, keyCode); //           Ctrl+ScanCode =>           Ctrl+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 1, 0, 1, keyCode); //       Ctrl+Alt+ScanCode =>       Ctrl+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all left-over available digits\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit1, KeyCode.Digit1);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit2, KeyCode.Digit2);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit3, KeyCode.Digit3);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit4, KeyCode.Digit4);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit5, KeyCode.Digit5);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit6, KeyCode.Digit6);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit7, KeyCode.Digit7);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit8, KeyCode.Digit8);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit9, KeyCode.Digit9);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit0, KeyCode.Digit0);\n\n\t\tthis._scanCodeKeyCodeMapper.registrationComplete();\n\t}\n\n\tpublic dumpDebugInfo(): string {\n\t\tconst result: string[] = [];\n\n\t\tconst immutableSamples = [\n\t\t\tScanCode.ArrowUp,\n\t\t\tScanCode.Numpad0\n\t\t];\n\n\t\tlet cnt = 0;\n\t\tresult.push(`isUSStandard: ${this._isUSStandard}`);\n\t\tresult.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== KeyCode.DependsOnKbLayout) {\n\t\t\t\tif (immutableSamples.indexOf(scanCode) === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cnt % 4 === 0) {\n\t\t\t\tresult.push(`|       HW Code combination      |  Key  |    KeyCode combination    | Pri |          UI label         |         User settings          |    Electron accelerator   |       Dispatching string       | WYSIWYG |`);\n\t\t\t\tresult.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n\t\t\t}\n\t\t\tcnt++;\n\n\t\t\tconst mapping = this._codeInfo[scanCode];\n\n\t\t\tfor (let mod = 0; mod < 8; mod++) {\n\t\t\t\tconst hwCtrlKey = (mod & 0b001) ? true : false;\n\t\t\t\tconst hwShiftKey = (mod & 0b010) ? true : false;\n\t\t\t\tconst hwAltKey = (mod & 0b100) ? true : false;\n\t\t\t\tconst scanCodeCombo = new ScanCodeCombo(hwCtrlKey, hwShiftKey, hwAltKey, scanCode);\n\t\t\t\tconst resolvedKb = this.resolveKeyboardEvent({\n\t\t\t\t\t_standardKeyboardEventBrand: true,\n\t\t\t\t\tctrlKey: scanCodeCombo.ctrlKey,\n\t\t\t\t\tshiftKey: scanCodeCombo.shiftKey,\n\t\t\t\t\taltKey: scanCodeCombo.altKey,\n\t\t\t\t\tmetaKey: false,\n\t\t\t\t\taltGraphKey: false,\n\t\t\t\t\tkeyCode: KeyCode.DependsOnKbLayout,\n\t\t\t\t\tcode: ScanCodeUtils.toString(scanCode)\n\t\t\t\t});\n\n\t\t\t\tconst outScanCodeCombo = scanCodeCombo.toString();\n\t\t\t\tconst outKey = scanCodeCombo.getProducedChar(mapping);\n\t\t\t\tconst ariaLabel = resolvedKb.getAriaLabel();\n\t\t\t\tconst outUILabel = (ariaLabel ? ariaLabel.replace(/Control\\+/, 'Ctrl+') : null);\n\t\t\t\tconst outUserSettings = resolvedKb.getUserSettingsLabel();\n\t\t\t\tconst outElectronAccelerator = resolvedKb.getElectronAccelerator();\n\t\t\t\tconst outDispatchStr = resolvedKb.getDispatchChords()[0];\n\n\t\t\t\tconst isWYSIWYG = (resolvedKb ? resolvedKb.isWYSIWYG() : false);\n\t\t\t\tconst outWYSIWYG = (isWYSIWYG ? '       ' : '   NO  ');\n\n\t\t\t\tconst kbCombos = this._scanCodeKeyCodeMapper.lookupScanCodeCombo(scanCodeCombo);\n\t\t\t\tif (kbCombos.length === 0) {\n\t\t\t\t\tresult.push(`| ${this._leftPad(outScanCodeCombo, 30)} | ${outKey} | ${this._leftPad('', 25)} | ${this._leftPad('', 3)} | ${this._leftPad(outUILabel, 25)} | ${this._leftPad(outUserSettings, 30)} | ${this._leftPad(outElectronAccelerator, 25)} | ${this._leftPad(outDispatchStr, 30)} | ${outWYSIWYG} |`);\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0, len = kbCombos.length; i < len; i++) {\n\t\t\t\t\t\tconst kbCombo = kbCombos[i];\n\t\t\t\t\t\t// find out the priority of this scan code for this key code\n\t\t\t\t\t\tlet colPriority: string;\n\n\t\t\t\t\t\tconst scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(kbCombo);\n\t\t\t\t\t\tif (scanCodeCombos.length === 1) {\n\t\t\t\t\t\t\t// no need for priority, this key code combo maps to precisely this scan code combo\n\t\t\t\t\t\t\tcolPriority = '';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet priority = -1;\n\t\t\t\t\t\t\tfor (let j = 0; j < scanCodeCombos.length; j++) {\n\t\t\t\t\t\t\t\tif (scanCodeCombos[j].equals(scanCodeCombo)) {\n\t\t\t\t\t\t\t\t\tpriority = j + 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcolPriority = String(priority);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst outKeybinding = kbCombo.toString();\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\tresult.push(`| ${this._leftPad(outScanCodeCombo, 30)} | ${outKey} | ${this._leftPad(outKeybinding, 25)} | ${this._leftPad(colPriority, 3)} | ${this._leftPad(outUILabel, 25)} | ${this._leftPad(outUserSettings, 30)} | ${this._leftPad(outElectronAccelerator, 25)} | ${this._leftPad(outDispatchStr, 30)} | ${outWYSIWYG} |`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// secondary keybindings\n\t\t\t\t\t\t\tresult.push(`| ${this._leftPad('', 30)} |       | ${this._leftPad(outKeybinding, 25)} | ${this._leftPad(colPriority, 3)} | ${this._leftPad('', 25)} | ${this._leftPad('', 30)} | ${this._leftPad('', 25)} | ${this._leftPad('', 30)} |         |`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tresult.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n\t\t}\n\n\t\treturn result.join('\\n');\n\t}\n\n\tprivate _leftPad(str: string | null, cnt: number): string {\n\t\tif (str === null) {\n\t\t\tstr = 'null';\n\t\t}\n\t\twhile (str.length < cnt) {\n\t\t\tstr = ' ' + str;\n\t\t}\n\t\treturn str;\n\t}\n\n\tpublic keyCodeChordToScanCodeChord(chord: KeyCodeChord): ScanCodeChord[] {\n\t\t// Avoid double Enter bindings (both ScanCode.NumpadEnter and ScanCode.Enter point to KeyCode.Enter)\n\t\tif (chord.keyCode === KeyCode.Enter) {\n\t\t\treturn [new ScanCodeChord(chord.ctrlKey, chord.shiftKey, chord.altKey, chord.metaKey, ScanCode.Enter)];\n\t\t}\n\n\t\tconst scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(\n\t\t\tnew KeyCodeCombo(chord.ctrlKey, chord.shiftKey, chord.altKey, chord.keyCode)\n\t\t);\n\n\t\tconst result: ScanCodeChord[] = [];\n\t\tfor (let i = 0, len = scanCodeCombos.length; i < len; i++) {\n\t\t\tconst scanCodeCombo = scanCodeCombos[i];\n\t\t\tresult[i] = new ScanCodeChord(scanCodeCombo.ctrlKey, scanCodeCombo.shiftKey, scanCodeCombo.altKey, chord.metaKey, scanCodeCombo.scanCode);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getUILabelForScanCodeChord(chord: ScanCodeChord | null): string | null {\n\t\tif (!chord) {\n\t\t\treturn null;\n\t\t}\n\t\tif (chord.isDuplicateModifierCase()) {\n\t\t\treturn '';\n\t\t}\n\t\tif (this._OS === OperatingSystem.Macintosh) {\n\t\t\tswitch (chord.scanCode) {\n\t\t\t\tcase ScanCode.ArrowLeft:\n\t\t\t\t\treturn '';\n\t\t\t\tcase ScanCode.ArrowUp:\n\t\t\t\t\treturn '';\n\t\t\t\tcase ScanCode.ArrowRight:\n\t\t\t\t\treturn '';\n\t\t\t\tcase ScanCode.ArrowDown:\n\t\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t\treturn this._scanCodeToLabel[chord.scanCode];\n\t}\n\n\tpublic getAriaLabelForScanCodeChord(chord: ScanCodeChord | null): string | null {\n\t\tif (!chord) {\n\t\t\treturn null;\n\t\t}\n\t\tif (chord.isDuplicateModifierCase()) {\n\t\t\treturn '';\n\t\t}\n\t\treturn this._scanCodeToLabel[chord.scanCode];\n\t}\n\n\tpublic getDispatchStrForScanCodeChord(chord: ScanCodeChord): string | null {\n\t\tconst codeDispatch = this._scanCodeToDispatch[chord.scanCode];\n\t\tif (!codeDispatch) {\n\t\t\treturn null;\n\t\t}\n\t\tlet result = '';\n\n\t\tif (chord.ctrlKey) {\n\t\t\tresult += 'ctrl+';\n\t\t}\n\t\tif (chord.shiftKey) {\n\t\t\tresult += 'shift+';\n\t\t}\n\t\tif (chord.altKey) {\n\t\t\tresult += 'alt+';\n\t\t}\n\t\tif (chord.metaKey) {\n\t\t\tresult += 'meta+';\n\t\t}\n\t\tresult += codeDispatch;\n\n\t\treturn result;\n\t}\n\n\tpublic getUserSettingsLabelForScanCodeChord(chord: ScanCodeChord | null): string | null {\n\t\tif (!chord) {\n\t\t\treturn null;\n\t\t}\n\t\tif (chord.isDuplicateModifierCase()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[chord.scanCode];\n\t\tif (immutableKeyCode !== KeyCode.DependsOnKbLayout) {\n\t\t\treturn KeyCodeUtils.toUserSettingsUS(immutableKeyCode).toLowerCase();\n\t\t}\n\n\t\t// Check if this scanCode always maps to the same keyCode and back\n\t\tconst constantKeyCode: KeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(chord.scanCode);\n\t\tif (constantKeyCode !== KeyCode.DependsOnKbLayout) {\n\t\t\t// Verify that this is a good key code that can be mapped back to the same scan code\n\t\t\tconst reverseChords = this.keyCodeChordToScanCodeChord(new KeyCodeChord(chord.ctrlKey, chord.shiftKey, chord.altKey, chord.metaKey, constantKeyCode));\n\t\t\tfor (let i = 0, len = reverseChords.length; i < len; i++) {\n\t\t\t\tconst reverseChord = reverseChords[i];\n\t\t\t\tif (reverseChord.scanCode === chord.scanCode) {\n\t\t\t\t\treturn KeyCodeUtils.toUserSettingsUS(constantKeyCode).toLowerCase();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._scanCodeToDispatch[chord.scanCode];\n\t}\n\n\tpublic getElectronAcceleratorLabelForScanCodeChord(chord: ScanCodeChord | null): string | null {\n\t\tif (!chord) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[chord.scanCode];\n\t\tif (immutableKeyCode !== KeyCode.DependsOnKbLayout) {\n\t\t\treturn KeyCodeUtils.toElectronAccelerator(immutableKeyCode);\n\t\t}\n\n\t\t// Check if this scanCode always maps to the same keyCode and back\n\t\tconst constantKeyCode: KeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(chord.scanCode);\n\n\t\tif (this._OS === OperatingSystem.Linux && !this._isUSStandard) {\n\t\t\t// [Electron Accelerators] On Linux, Electron does not handle correctly OEM keys.\n\t\t\t// when using a different keyboard layout than US Standard.\n\t\t\t// See https://github.com/microsoft/vscode/issues/23706\n\t\t\t// See https://github.com/microsoft/vscode/pull/134890#issuecomment-941671791\n\t\t\tconst isOEMKey = (\n\t\t\t\tconstantKeyCode === KeyCode.Semicolon\n\t\t\t\t|| constantKeyCode === KeyCode.Equal\n\t\t\t\t|| constantKeyCode === KeyCode.Comma\n\t\t\t\t|| constantKeyCode === KeyCode.Minus\n\t\t\t\t|| constantKeyCode === KeyCode.Period\n\t\t\t\t|| constantKeyCode === KeyCode.Slash\n\t\t\t\t|| constantKeyCode === KeyCode.Backquote\n\t\t\t\t|| constantKeyCode === KeyCode.BracketLeft\n\t\t\t\t|| constantKeyCode === KeyCode.Backslash\n\t\t\t\t|| constantKeyCode === KeyCode.BracketRight\n\t\t\t);\n\n\t\t\tif (isOEMKey) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (constantKeyCode !== KeyCode.DependsOnKbLayout) {\n\t\t\treturn KeyCodeUtils.toElectronAccelerator(constantKeyCode);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _toResolvedKeybinding(chordParts: ScanCodeChord[][]): NativeResolvedKeybinding[] {\n\t\tif (chordParts.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tconst result: NativeResolvedKeybinding[] = [];\n\t\tthis._generateResolvedKeybindings(chordParts, 0, [], result);\n\t\treturn result;\n\t}\n\n\tprivate _generateResolvedKeybindings(chordParts: ScanCodeChord[][], currentIndex: number, previousParts: ScanCodeChord[], result: NativeResolvedKeybinding[]) {\n\t\tconst chordPart = chordParts[currentIndex];\n\t\tconst isFinalIndex = currentIndex === chordParts.length - 1;\n\t\tfor (let i = 0, len = chordPart.length; i < len; i++) {\n\t\t\tconst chords = [...previousParts, chordPart[i]];\n\t\t\tif (isFinalIndex) {\n\t\t\t\tresult.push(new NativeResolvedKeybinding(this, this._OS, chords));\n\t\t\t} else {\n\t\t\t\tthis._generateResolvedKeybindings(chordParts, currentIndex + 1, chords, result);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic resolveKeyboardEvent(keyboardEvent: IKeyboardEvent): NativeResolvedKeybinding {\n\t\tlet code = ScanCodeUtils.toEnum(keyboardEvent.code);\n\n\t\t// Treat NumpadEnter as Enter\n\t\tif (code === ScanCode.NumpadEnter) {\n\t\t\tcode = ScanCode.Enter;\n\t\t}\n\n\t\tconst keyCode = keyboardEvent.keyCode;\n\n\t\tif (\n\t\t\t(keyCode === KeyCode.LeftArrow)\n\t\t\t|| (keyCode === KeyCode.UpArrow)\n\t\t\t|| (keyCode === KeyCode.RightArrow)\n\t\t\t|| (keyCode === KeyCode.DownArrow)\n\t\t\t|| (keyCode === KeyCode.Delete)\n\t\t\t|| (keyCode === KeyCode.Insert)\n\t\t\t|| (keyCode === KeyCode.Home)\n\t\t\t|| (keyCode === KeyCode.End)\n\t\t\t|| (keyCode === KeyCode.PageDown)\n\t\t\t|| (keyCode === KeyCode.PageUp)\n\t\t\t|| (keyCode === KeyCode.Backspace)\n\t\t) {\n\t\t\t// \"Dispatch\" on keyCode for these key codes to workaround issues with remote desktoping software\n\t\t\t// where the scan codes appear to be incorrect (see https://github.com/microsoft/vscode/issues/24107)\n\t\t\tconst immutableScanCode = IMMUTABLE_KEY_CODE_TO_CODE[keyCode];\n\t\t\tif (immutableScanCode !== ScanCode.DependsOnKbLayout) {\n\t\t\t\tcode = immutableScanCode;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (\n\t\t\t\t(code === ScanCode.Numpad1)\n\t\t\t\t|| (code === ScanCode.Numpad2)\n\t\t\t\t|| (code === ScanCode.Numpad3)\n\t\t\t\t|| (code === ScanCode.Numpad4)\n\t\t\t\t|| (code === ScanCode.Numpad5)\n\t\t\t\t|| (code === ScanCode.Numpad6)\n\t\t\t\t|| (code === ScanCode.Numpad7)\n\t\t\t\t|| (code === ScanCode.Numpad8)\n\t\t\t\t|| (code === ScanCode.Numpad9)\n\t\t\t\t|| (code === ScanCode.Numpad0)\n\t\t\t\t|| (code === ScanCode.NumpadDecimal)\n\t\t\t) {\n\t\t\t\t// \"Dispatch\" on keyCode for all numpad keys in order for NumLock to work correctly\n\t\t\t\tif (keyCode >= 0) {\n\t\t\t\t\tconst immutableScanCode = IMMUTABLE_KEY_CODE_TO_CODE[keyCode];\n\t\t\t\t\tif (immutableScanCode !== ScanCode.DependsOnKbLayout) {\n\t\t\t\t\t\tcode = immutableScanCode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst ctrlKey = keyboardEvent.ctrlKey || (this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey);\n\t\tconst altKey = keyboardEvent.altKey || (this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey);\n\t\tconst chord = new ScanCodeChord(ctrlKey, keyboardEvent.shiftKey, altKey, keyboardEvent.metaKey, code);\n\t\treturn new NativeResolvedKeybinding(this, this._OS, [chord]);\n\t}\n\n\tprivate _resolveChord(chord: Chord | null): ScanCodeChord[] {\n\t\tif (!chord) {\n\t\t\treturn [];\n\t\t}\n\t\tif (chord instanceof ScanCodeChord) {\n\t\t\treturn [chord];\n\t\t}\n\t\treturn this.keyCodeChordToScanCodeChord(chord);\n\t}\n\n\tpublic resolveKeybinding(keybinding: Keybinding): ResolvedKeybinding[] {\n\t\tconst chords: ScanCodeChord[][] = keybinding.chords.map(chord => this._resolveChord(chord));\n\t\treturn this._toResolvedKeybinding(chords);\n\t}\n\n\tprivate static _redirectCharCode(charCode: number): number {\n\t\tswitch (charCode) {\n\t\t\t// allow-any-unicode-next-line\n\t\t\t// CJK:       \n\t\t\t// map: . [ ] [ ] ; ,\n\t\t\tcase CharCode.U_IDEOGRAPHIC_FULL_STOP: return CharCode.Period;\n\t\t\tcase CharCode.U_LEFT_CORNER_BRACKET: return CharCode.OpenSquareBracket;\n\t\t\tcase CharCode.U_RIGHT_CORNER_BRACKET: return CharCode.CloseSquareBracket;\n\t\t\tcase CharCode.U_LEFT_BLACK_LENTICULAR_BRACKET: return CharCode.OpenSquareBracket;\n\t\t\tcase CharCode.U_RIGHT_BLACK_LENTICULAR_BRACKET: return CharCode.CloseSquareBracket;\n\t\t\tcase CharCode.U_FULLWIDTH_SEMICOLON: return CharCode.Semicolon;\n\t\t\tcase CharCode.U_FULLWIDTH_COMMA: return CharCode.Comma;\n\t\t}\n\t\treturn charCode;\n\t}\n\n\tprivate static _charCodeToKb(charCode: number): { keyCode: KeyCode; shiftKey: boolean } | null {\n\t\tcharCode = this._redirectCharCode(charCode);\n\t\tif (charCode < CHAR_CODE_TO_KEY_CODE.length) {\n\t\t\treturn CHAR_CODE_TO_KEY_CODE[charCode];\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Attempt to map a combining character to a regular one that renders the same way.\n\t *\n\t * https://www.compart.com/en/unicode/bidiclass/NSM\n\t */\n\tpublic static getCharCode(char: string): number {\n\t\tif (char.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst charCode = char.charCodeAt(0);\n\t\tswitch (charCode) {\n\t\t\tcase CharCode.U_Combining_Grave_Accent: return CharCode.U_GRAVE_ACCENT;\n\t\t\tcase CharCode.U_Combining_Acute_Accent: return CharCode.U_ACUTE_ACCENT;\n\t\t\tcase CharCode.U_Combining_Circumflex_Accent: return CharCode.U_CIRCUMFLEX;\n\t\t\tcase CharCode.U_Combining_Tilde: return CharCode.U_SMALL_TILDE;\n\t\t\tcase CharCode.U_Combining_Macron: return CharCode.U_MACRON;\n\t\t\tcase CharCode.U_Combining_Overline: return CharCode.U_OVERLINE;\n\t\t\tcase CharCode.U_Combining_Breve: return CharCode.U_BREVE;\n\t\t\tcase CharCode.U_Combining_Dot_Above: return CharCode.U_DOT_ABOVE;\n\t\t\tcase CharCode.U_Combining_Diaeresis: return CharCode.U_DIAERESIS;\n\t\t\tcase CharCode.U_Combining_Ring_Above: return CharCode.U_RING_ABOVE;\n\t\t\tcase CharCode.U_Combining_Double_Acute_Accent: return CharCode.U_DOUBLE_ACUTE_ACCENT;\n\t\t}\n\t\treturn charCode;\n\t}\n}\n\n(function () {\n\tfunction define(charCode: number, keyCode: KeyCode, shiftKey: boolean): void {\n\t\tfor (let i = CHAR_CODE_TO_KEY_CODE.length; i < charCode; i++) {\n\t\t\tCHAR_CODE_TO_KEY_CODE[i] = null;\n\t\t}\n\t\tCHAR_CODE_TO_KEY_CODE[charCode] = { keyCode: keyCode, shiftKey: shiftKey };\n\t}\n\n\tfor (let chCode = CharCode.A; chCode <= CharCode.Z; chCode++) {\n\t\tdefine(chCode, KeyCode.KeyA + (chCode - CharCode.A), true);\n\t}\n\n\tfor (let chCode = CharCode.a; chCode <= CharCode.z; chCode++) {\n\t\tdefine(chCode, KeyCode.KeyA + (chCode - CharCode.a), false);\n\t}\n\n\tdefine(CharCode.Semicolon, KeyCode.Semicolon, false);\n\tdefine(CharCode.Colon, KeyCode.Semicolon, true);\n\n\tdefine(CharCode.Equals, KeyCode.Equal, false);\n\tdefine(CharCode.Plus, KeyCode.Equal, true);\n\n\tdefine(CharCode.Comma, KeyCode.Comma, false);\n\tdefine(CharCode.LessThan, KeyCode.Comma, true);\n\n\tdefine(CharCode.Dash, KeyCode.Minus, false);\n\tdefine(CharCode.Underline, KeyCode.Minus, true);\n\n\tdefine(CharCode.Period, KeyCode.Period, false);\n\tdefine(CharCode.GreaterThan, KeyCode.Period, true);\n\n\tdefine(CharCode.Slash, KeyCode.Slash, false);\n\tdefine(CharCode.QuestionMark, KeyCode.Slash, true);\n\n\tdefine(CharCode.BackTick, KeyCode.Backquote, false);\n\tdefine(CharCode.Tilde, KeyCode.Backquote, true);\n\n\tdefine(CharCode.OpenSquareBracket, KeyCode.BracketLeft, false);\n\tdefine(CharCode.OpenCurlyBrace, KeyCode.BracketLeft, true);\n\n\tdefine(CharCode.Backslash, KeyCode.Backslash, false);\n\tdefine(CharCode.Pipe, KeyCode.Backslash, true);\n\n\tdefine(CharCode.CloseSquareBracket, KeyCode.BracketRight, false);\n\tdefine(CharCode.CloseCurlyBrace, KeyCode.BracketRight, true);\n\n\tdefine(CharCode.SingleQuote, KeyCode.Quote, false);\n\tdefine(CharCode.DoubleQuote, KeyCode.Quote, true);\n})();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { KeyCode, KeyCodeUtils, IMMUTABLE_CODE_TO_KEY_CODE, IMMUTABLE_KEY_CODE_TO_CODE, ScanCode, ScanCodeUtils, isModifierKey } from '../../../../base/common/keyCodes.js';\nimport { ResolvedKeybinding, KeyCodeChord, SingleModifierChord, ScanCodeChord, Keybinding, Chord } from '../../../../base/common/keybindings.js';\nimport { OperatingSystem } from '../../../../base/common/platform.js';\nimport { IKeyboardEvent } from '../../../../platform/keybinding/common/keybinding.js';\nimport { IKeyboardMapper } from '../../../../platform/keyboardLayout/common/keyboardMapper.js';\nimport { BaseResolvedKeybinding } from '../../../../platform/keybinding/common/baseResolvedKeybinding.js';\nimport { IMacLinuxKeyboardMapping, IMacLinuxKeyMapping } from '../../../../platform/keyboardLayout/common/keyboardLayout.js';\n\n/**\n * A map from character to key codes.\n * e.g. Contains entries such as:\n *  - '/' => { keyCode: KeyCode.US_SLASH, shiftKey: false }\n *  - '?' => { keyCode: KeyCode.US_SLASH, shiftKey: true }\n */\nconst CHAR_CODE_TO_KEY_CODE: ({ keyCode: KeyCode; shiftKey: boolean } | null)[] = [];\n\nexport class NativeResolvedKeybinding extends BaseResolvedKeybinding<ScanCodeChord> {\n\n\tprivate readonly _mapper: MacLinuxKeyboardMapper;\n\n\tconstructor(mapper: MacLinuxKeyboardMapper, os: OperatingSystem, chords: ScanCodeChord[]) {\n\t\tsuper(os, chords);\n\t\tthis._mapper = mapper;\n\t}\n\n\tprotected _getLabel(chord: ScanCodeChord): string | null {\n\t\treturn this._mapper.getUILabelForScanCodeChord(chord);\n\t}\n\n\tprotected _getAriaLabel(chord: ScanCodeChord): string | null {\n\t\treturn this._mapper.getAriaLabelForScanCodeChord(chord);\n\t}\n\n\tprotected _getElectronAccelerator(chord: ScanCodeChord): string | null {\n\t\treturn this._mapper.getElectronAcceleratorLabelForScanCodeChord(chord);\n\t}\n\n\tprotected _getUserSettingsLabel(chord: ScanCodeChord): string | null {\n\t\treturn this._mapper.getUserSettingsLabelForScanCodeChord(chord);\n\t}\n\n\tprotected _isWYSIWYG(binding: ScanCodeChord | null): boolean {\n\t\tif (!binding) {\n\t\t\treturn true;\n\t\t}\n\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode] !== KeyCode.DependsOnKbLayout) {\n\t\t\treturn true;\n\t\t}\n\t\tconst a = this._mapper.getAriaLabelForScanCodeChord(binding);\n\t\tconst b = this._mapper.getUserSettingsLabelForScanCodeChord(binding);\n\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || !b) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (a.toLowerCase() === b.toLowerCase());\n\t}\n\n\tprotected _getChordDispatch(chord: ScanCodeChord): string | null {\n\t\treturn this._mapper.getDispatchStrForScanCodeChord(chord);\n\t}\n\n\tprotected _getSingleModifierChordDispatch(chord: ScanCodeChord): SingleModifierChord | null {\n\t\tif ((chord.scanCode === ScanCode.ControlLeft || chord.scanCode === ScanCode.ControlRight) && !chord.shiftKey && !chord.altKey && !chord.metaKey) {\n\t\t\treturn 'ctrl';\n\t\t}\n\t\tif ((chord.scanCode === ScanCode.AltLeft || chord.scanCode === ScanCode.AltRight) && !chord.ctrlKey && !chord.shiftKey && !chord.metaKey) {\n\t\t\treturn 'alt';\n\t\t}\n\t\tif ((chord.scanCode === ScanCode.ShiftLeft || chord.scanCode === ScanCode.ShiftRight) && !chord.ctrlKey && !chord.altKey && !chord.metaKey) {\n\t\t\treturn 'shift';\n\t\t}\n\t\tif ((chord.scanCode === ScanCode.MetaLeft || chord.scanCode === ScanCode.MetaRight) && !chord.ctrlKey && !chord.shiftKey && !chord.altKey) {\n\t\t\treturn 'meta';\n\t\t}\n\t\treturn null;\n\t}\n}\n\ninterface IScanCodeMapping {\n\tscanCode: ScanCode;\n\tvalue: number;\n\twithShift: number;\n\twithAltGr: number;\n\twithShiftAltGr: number;\n}\n\nclass ScanCodeCombo {\n\tpublic readonly ctrlKey: boolean;\n\tpublic readonly shiftKey: boolean;\n\tpublic readonly altKey: boolean;\n\tpublic readonly scanCode: ScanCode;\n\n\tconstructor(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, scanCode: ScanCode) {\n\t\tthis.ctrlKey = ctrlKey;\n\t\tthis.shiftKey = shiftKey;\n\t\tthis.altKey = altKey;\n\t\tthis.scanCode = scanCode;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.ctrlKey ? 'Ctrl+' : ''}${this.shiftKey ? 'Shift+' : ''}${this.altKey ? 'Alt+' : ''}${ScanCodeUtils.toString(this.scanCode)}`;\n\t}\n\n\tpublic equals(other: ScanCodeCombo): boolean {\n\t\treturn (\n\t\t\tthis.ctrlKey === other.ctrlKey\n\t\t\t&& this.shiftKey === other.shiftKey\n\t\t\t&& this.altKey === other.altKey\n\t\t\t&& this.scanCode === other.scanCode\n\t\t);\n\t}\n\n\tprivate getProducedCharCode(mapping: IMacLinuxKeyMapping): string {\n\t\tif (!mapping) {\n\t\t\treturn '';\n\t\t}\n\t\tif (this.ctrlKey && this.shiftKey && this.altKey) {\n\t\t\treturn mapping.withShiftAltGr;\n\t\t}\n\t\tif (this.ctrlKey && this.altKey) {\n\t\t\treturn mapping.withAltGr;\n\t\t}\n\t\tif (this.shiftKey) {\n\t\t\treturn mapping.withShift;\n\t\t}\n\t\treturn mapping.value;\n\t}\n\n\tpublic getProducedChar(mapping: IMacLinuxKeyMapping): string {\n\t\tconst charCode = MacLinuxKeyboardMapper.getCharCode(this.getProducedCharCode(mapping));\n\t\tif (charCode === 0) {\n\t\t\treturn ' --- ';\n\t\t}\n\t\tif (charCode >= CharCode.U_Combining_Grave_Accent && charCode <= CharCode.U_Combining_Latin_Small_Letter_X) {\n\t\t\t// combining\n\t\t\treturn 'U+' + charCode.toString(16);\n\t\t}\n\t\treturn '  ' + String.fromCharCode(charCode) + '  ';\n\t}\n}\n\nclass KeyCodeCombo {\n\tpublic readonly ctrlKey: boolean;\n\tpublic readonly shiftKey: boolean;\n\tpublic readonly altKey: boolean;\n\tpublic readonly keyCode: KeyCode;\n\n\tconstructor(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, keyCode: KeyCode) {\n\t\tthis.ctrlKey = ctrlKey;\n\t\tthis.shiftKey = shiftKey;\n\t\tthis.altKey = altKey;\n\t\tthis.keyCode = keyCode;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.ctrlKey ? 'Ctrl+' : ''}${this.shiftKey ? 'Shift+' : ''}${this.altKey ? 'Alt+' : ''}${KeyCodeUtils.toString(this.keyCode)}`;\n\t}\n}\n\nclass ScanCodeKeyCodeMapper {\n\n\t/**\n\t * ScanCode combination => KeyCode combination.\n\t * Only covers relevant modifiers ctrl, shift, alt (since meta does not influence the mappings).\n\t */\n\tprivate readonly _scanCodeToKeyCode: number[][] = [];\n\t/**\n\t * inverse of `_scanCodeToKeyCode`.\n\t * KeyCode combination => ScanCode combination.\n\t * Only covers relevant modifiers ctrl, shift, alt (since meta does not influence the mappings).\n\t */\n\tprivate readonly _keyCodeToScanCode: number[][] = [];\n\n\tconstructor() {\n\t\tthis._scanCodeToKeyCode = [];\n\t\tthis._keyCodeToScanCode = [];\n\t}\n\n\tpublic registrationComplete(): void {\n\t\t// IntlHash and IntlBackslash are rare keys, so ensure they don't end up being the preferred...\n\t\tthis._moveToEnd(ScanCode.IntlHash);\n\t\tthis._moveToEnd(ScanCode.IntlBackslash);\n\t}\n\n\tprivate _moveToEnd(scanCode: ScanCode): void {\n\t\tfor (let mod = 0; mod < 8; mod++) {\n\t\t\tconst encodedKeyCodeCombos = this._scanCodeToKeyCode[(scanCode << 3) + mod];\n\t\t\tif (!encodedKeyCodeCombos) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (let i = 0, len = encodedKeyCodeCombos.length; i < len; i++) {\n\t\t\t\tconst encodedScanCodeCombos = this._keyCodeToScanCode[encodedKeyCodeCombos[i]];\n\t\t\t\tif (encodedScanCodeCombos.length === 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (let j = 0, len = encodedScanCodeCombos.length; j < len; j++) {\n\t\t\t\t\tconst entry = encodedScanCodeCombos[j];\n\t\t\t\t\tconst entryScanCode = (entry >>> 3);\n\t\t\t\t\tif (entryScanCode === scanCode) {\n\t\t\t\t\t\t// Move this entry to the end\n\t\t\t\t\t\tfor (let k = j + 1; k < len; k++) {\n\t\t\t\t\t\t\tencodedScanCodeCombos[k - 1] = encodedScanCodeCombos[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencodedScanCodeCombos[len - 1] = entry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic registerIfUnknown(scanCodeCombo: ScanCodeCombo, keyCodeCombo: KeyCodeCombo): void {\n\t\tif (keyCodeCombo.keyCode === KeyCode.Unknown) {\n\t\t\treturn;\n\t\t}\n\t\tconst scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);\n\t\tconst keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);\n\n\t\tconst keyCodeIsDigit = (keyCodeCombo.keyCode >= KeyCode.Digit0 && keyCodeCombo.keyCode <= KeyCode.Digit9);\n\t\tconst keyCodeIsLetter = (keyCodeCombo.keyCode >= KeyCode.KeyA && keyCodeCombo.keyCode <= KeyCode.KeyZ);\n\n\t\tconst existingKeyCodeCombos = this._scanCodeToKeyCode[scanCodeComboEncoded];\n\n\t\t// Allow a scan code to map to multiple key codes if it is a digit or a letter key code\n\t\tif (keyCodeIsDigit || keyCodeIsLetter) {\n\t\t\t// Only check that we don't insert the same entry twice\n\t\t\tif (existingKeyCodeCombos) {\n\t\t\t\tfor (let i = 0, len = existingKeyCodeCombos.length; i < len; i++) {\n\t\t\t\t\tif (existingKeyCodeCombos[i] === keyCodeComboEncoded) {\n\t\t\t\t\t\t// avoid duplicates\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Don't allow multiples\n\t\t\tif (existingKeyCodeCombos && existingKeyCodeCombos.length !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis._scanCodeToKeyCode[scanCodeComboEncoded] = this._scanCodeToKeyCode[scanCodeComboEncoded] || [];\n\t\tthis._scanCodeToKeyCode[scanCodeComboEncoded].unshift(keyCodeComboEncoded);\n\n\t\tthis._keyCodeToScanCode[keyCodeComboEncoded] = this._keyCodeToScanCode[keyCodeComboEncoded] || [];\n\t\tthis._keyCodeToScanCode[keyCodeComboEncoded].unshift(scanCodeComboEncoded);\n\t}\n\n\tpublic lookupKeyCodeCombo(keyCodeCombo: KeyCodeCombo): ScanCodeCombo[] {\n\t\tconst keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);\n\t\tconst scanCodeCombosEncoded = this._keyCodeToScanCode[keyCodeComboEncoded];\n\t\tif (!scanCodeCombosEncoded || scanCodeCombosEncoded.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: ScanCodeCombo[] = [];\n\t\tfor (let i = 0, len = scanCodeCombosEncoded.length; i < len; i++) {\n\t\t\tconst scanCodeComboEncoded = scanCodeCombosEncoded[i];\n\n\t\t\tconst ctrlKey = (scanCodeComboEncoded & 0b001) ? true : false;\n\t\t\tconst shiftKey = (scanCodeComboEncoded & 0b010) ? true : false;\n\t\t\tconst altKey = (scanCodeComboEncoded & 0b100) ? true : false;\n\t\t\tconst scanCode: ScanCode = (scanCodeComboEncoded >>> 3);\n\n\t\t\tresult[i] = new ScanCodeCombo(ctrlKey, shiftKey, altKey, scanCode);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic lookupScanCodeCombo(scanCodeCombo: ScanCodeCombo): KeyCodeCombo[] {\n\t\tconst scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);\n\t\tconst keyCodeCombosEncoded = this._scanCodeToKeyCode[scanCodeComboEncoded];\n\t\tif (!keyCodeCombosEncoded || keyCodeCombosEncoded.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: KeyCodeCombo[] = [];\n\t\tfor (let i = 0, len = keyCodeCombosEncoded.length; i < len; i++) {\n\t\t\tconst keyCodeComboEncoded = keyCodeCombosEncoded[i];\n\n\t\t\tconst ctrlKey = (keyCodeComboEncoded & 0b001) ? true : false;\n\t\t\tconst shiftKey = (keyCodeComboEncoded & 0b010) ? true : false;\n\t\t\tconst altKey = (keyCodeComboEncoded & 0b100) ? true : false;\n\t\t\tconst keyCode: KeyCode = (keyCodeComboEncoded >>> 3);\n\n\t\t\tresult[i] = new KeyCodeCombo(ctrlKey, shiftKey, altKey, keyCode);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic guessStableKeyCode(scanCode: ScanCode): KeyCode {\n\t\tif (scanCode >= ScanCode.Digit1 && scanCode <= ScanCode.Digit0) {\n\t\t\t// digits are ok\n\t\t\tswitch (scanCode) {\n\t\t\t\tcase ScanCode.Digit1: return KeyCode.Digit1;\n\t\t\t\tcase ScanCode.Digit2: return KeyCode.Digit2;\n\t\t\t\tcase ScanCode.Digit3: return KeyCode.Digit3;\n\t\t\t\tcase ScanCode.Digit4: return KeyCode.Digit4;\n\t\t\t\tcase ScanCode.Digit5: return KeyCode.Digit5;\n\t\t\t\tcase ScanCode.Digit6: return KeyCode.Digit6;\n\t\t\t\tcase ScanCode.Digit7: return KeyCode.Digit7;\n\t\t\t\tcase ScanCode.Digit8: return KeyCode.Digit8;\n\t\t\t\tcase ScanCode.Digit9: return KeyCode.Digit9;\n\t\t\t\tcase ScanCode.Digit0: return KeyCode.Digit0;\n\t\t\t}\n\t\t}\n\n\t\t// Lookup the scanCode with and without shift and see if the keyCode is stable\n\t\tconst keyCodeCombos1 = this.lookupScanCodeCombo(new ScanCodeCombo(false, false, false, scanCode));\n\t\tconst keyCodeCombos2 = this.lookupScanCodeCombo(new ScanCodeCombo(false, true, false, scanCode));\n\t\tif (keyCodeCombos1.length === 1 && keyCodeCombos2.length === 1) {\n\t\t\tconst shiftKey1 = keyCodeCombos1[0].shiftKey;\n\t\t\tconst keyCode1 = keyCodeCombos1[0].keyCode;\n\t\t\tconst shiftKey2 = keyCodeCombos2[0].shiftKey;\n\t\t\tconst keyCode2 = keyCodeCombos2[0].keyCode;\n\t\t\tif (keyCode1 === keyCode2 && shiftKey1 !== shiftKey2) {\n\t\t\t\t// This looks like a stable mapping\n\t\t\t\treturn keyCode1;\n\t\t\t}\n\t\t}\n\n\t\treturn KeyCode.DependsOnKbLayout;\n\t}\n\n\tprivate _encodeScanCodeCombo(scanCodeCombo: ScanCodeCombo): number {\n\t\treturn this._encode(scanCodeCombo.ctrlKey, scanCodeCombo.shiftKey, scanCodeCombo.altKey, scanCodeCombo.scanCode);\n\t}\n\n\tprivate _encodeKeyCodeCombo(keyCodeCombo: KeyCodeCombo): number {\n\t\treturn this._encode(keyCodeCombo.ctrlKey, keyCodeCombo.shiftKey, keyCodeCombo.altKey, keyCodeCombo.keyCode);\n\t}\n\n\tprivate _encode(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, principal: number): number {\n\t\treturn (\n\t\t\t((ctrlKey ? 1 : 0) << 0)\n\t\t\t| ((shiftKey ? 1 : 0) << 1)\n\t\t\t| ((altKey ? 1 : 0) << 2)\n\t\t\t| principal << 3\n\t\t) >>> 0;\n\t}\n}\n\nexport class MacLinuxKeyboardMapper implements IKeyboardMapper {\n\n\t/**\n\t * used only for debug purposes.\n\t */\n\tprivate readonly _codeInfo: IMacLinuxKeyMapping[];\n\t/**\n\t * Maps ScanCode combos <-> KeyCode combos.\n\t */\n\tprivate readonly _scanCodeKeyCodeMapper: ScanCodeKeyCodeMapper;\n\t/**\n\t * UI label for a ScanCode.\n\t */\n\tprivate readonly _scanCodeToLabel: Array<string | null> = [];\n\t/**\n\t * Dispatching string for a ScanCode.\n\t */\n\tprivate readonly _scanCodeToDispatch: Array<string | null> = [];\n\n\tconstructor(\n\t\tprivate readonly _isUSStandard: boolean,\n\t\trawMappings: IMacLinuxKeyboardMapping,\n\t\tprivate readonly _mapAltGrToCtrlAlt: boolean,\n\t\tprivate readonly _OS: OperatingSystem,\n\t) {\n\t\tthis._codeInfo = [];\n\t\tthis._scanCodeKeyCodeMapper = new ScanCodeKeyCodeMapper();\n\t\tthis._scanCodeToLabel = [];\n\t\tthis._scanCodeToDispatch = [];\n\n\t\tconst _registerIfUnknown = (\n\t\t\thwCtrlKey: 0 | 1, hwShiftKey: 0 | 1, hwAltKey: 0 | 1, scanCode: ScanCode,\n\t\t\tkbCtrlKey: 0 | 1, kbShiftKey: 0 | 1, kbAltKey: 0 | 1, keyCode: KeyCode,\n\t\t): void => {\n\t\t\tthis._scanCodeKeyCodeMapper.registerIfUnknown(\n\t\t\t\tnew ScanCodeCombo(hwCtrlKey ? true : false, hwShiftKey ? true : false, hwAltKey ? true : false, scanCode),\n\t\t\t\tnew KeyCodeCombo(kbCtrlKey ? true : false, kbShiftKey ? true : false, kbAltKey ? true : false, keyCode)\n\t\t\t);\n\t\t};\n\n\t\tconst _registerAllCombos = (_ctrlKey: 0 | 1, _shiftKey: 0 | 1, _altKey: 0 | 1, scanCode: ScanCode, keyCode: KeyCode): void => {\n\t\t\tfor (let ctrlKey = _ctrlKey; ctrlKey <= 1; ctrlKey++) {\n\t\t\t\tfor (let shiftKey = _shiftKey; shiftKey <= 1; shiftKey++) {\n\t\t\t\t\tfor (let altKey = _altKey; altKey <= 1; altKey++) {\n\t\t\t\t\t\t_registerIfUnknown(\n\t\t\t\t\t\t\tctrlKey, shiftKey, altKey, scanCode,\n\t\t\t\t\t\t\tctrlKey, shiftKey, altKey, keyCode\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Initialize `_scanCodeToLabel`\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tthis._scanCodeToLabel[scanCode] = null;\n\t\t}\n\n\t\t// Initialize `_scanCodeToDispatch`\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tthis._scanCodeToDispatch[scanCode] = null;\n\t\t}\n\n\t\t// Handle immutable mappings\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tconst keyCode = IMMUTABLE_CODE_TO_KEY_CODE[scanCode];\n\t\t\tif (keyCode !== KeyCode.DependsOnKbLayout) {\n\t\t\t\t_registerAllCombos(0, 0, 0, scanCode, keyCode);\n\t\t\t\tthis._scanCodeToLabel[scanCode] = KeyCodeUtils.toString(keyCode);\n\n\t\t\t\tif (keyCode === KeyCode.Unknown || isModifierKey(keyCode)) {\n\t\t\t\t\tthis._scanCodeToDispatch[scanCode] = null; // cannot dispatch on this ScanCode\n\t\t\t\t} else {\n\t\t\t\t\tthis._scanCodeToDispatch[scanCode] = `[${ScanCodeUtils.toString(scanCode)}]`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Try to identify keyboard layouts where characters A-Z are missing\n\t\t// and forcibly map them to their corresponding scan codes if that is the case\n\t\tconst missingLatinLettersOverride: { [scanCode: string]: IMacLinuxKeyMapping } = {};\n\n\t\t{\n\t\t\tconst producesLatinLetter: boolean[] = [];\n\t\t\tfor (const strScanCode in rawMappings) {\n\t\t\t\tif (rawMappings.hasOwnProperty(strScanCode)) {\n\t\t\t\t\tconst scanCode = ScanCodeUtils.toEnum(strScanCode);\n\t\t\t\t\tif (scanCode === ScanCode.None) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== KeyCode.DependsOnKbLayout) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rawMapping = rawMappings[strScanCode];\n\t\t\t\t\tconst value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);\n\n\t\t\t\t\tif (value >= CharCode.a && value <= CharCode.z) {\n\t\t\t\t\t\tconst upperCaseValue = CharCode.A + (value - CharCode.a);\n\t\t\t\t\t\tproducesLatinLetter[upperCaseValue] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst _registerLetterIfMissing = (charCode: CharCode, scanCode: ScanCode, value: string, withShift: string): void => {\n\t\t\t\tif (!producesLatinLetter[charCode]) {\n\t\t\t\t\tmissingLatinLettersOverride[ScanCodeUtils.toString(scanCode)] = {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\twithShift: withShift,\n\t\t\t\t\t\twithAltGr: '',\n\t\t\t\t\t\twithShiftAltGr: ''\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Ensure letters are mapped\n\t\t\t_registerLetterIfMissing(CharCode.A, ScanCode.KeyA, 'a', 'A');\n\t\t\t_registerLetterIfMissing(CharCode.B, ScanCode.KeyB, 'b', 'B');\n\t\t\t_registerLetterIfMissing(CharCode.C, ScanCode.KeyC, 'c', 'C');\n\t\t\t_registerLetterIfMissing(CharCode.D, ScanCode.KeyD, 'd', 'D');\n\t\t\t_registerLetterIfMissing(CharCode.E, ScanCode.KeyE, 'e', 'E');\n\t\t\t_registerLetterIfMissing(CharCode.F, ScanCode.KeyF, 'f', 'F');\n\t\t\t_registerLetterIfMissing(CharCode.G, ScanCode.KeyG, 'g', 'G');\n\t\t\t_registerLetterIfMissing(CharCode.H, ScanCode.KeyH, 'h', 'H');\n\t\t\t_registerLetterIfMissing(CharCode.I, ScanCode.KeyI, 'i', 'I');\n\t\t\t_registerLetterIfMissing(CharCode.J, ScanCode.KeyJ, 'j', 'J');\n\t\t\t_registerLetterIfMissing(CharCode.K, ScanCode.KeyK, 'k', 'K');\n\t\t\t_registerLetterIfMissing(CharCode.L, ScanCode.KeyL, 'l', 'L');\n\t\t\t_registerLetterIfMissing(CharCode.M, ScanCode.KeyM, 'm', 'M');\n\t\t\t_registerLetterIfMissing(CharCode.N, ScanCode.KeyN, 'n', 'N');\n\t\t\t_registerLetterIfMissing(CharCode.O, ScanCode.KeyO, 'o', 'O');\n\t\t\t_registerLetterIfMissing(CharCode.P, ScanCode.KeyP, 'p', 'P');\n\t\t\t_registerLetterIfMissing(CharCode.Q, ScanCode.KeyQ, 'q', 'Q');\n\t\t\t_registerLetterIfMissing(CharCode.R, ScanCode.KeyR, 'r', 'R');\n\t\t\t_registerLetterIfMissing(CharCode.S, ScanCode.KeyS, 's', 'S');\n\t\t\t_registerLetterIfMissing(CharCode.T, ScanCode.KeyT, 't', 'T');\n\t\t\t_registerLetterIfMissing(CharCode.U, ScanCode.KeyU, 'u', 'U');\n\t\t\t_registerLetterIfMissing(CharCode.V, ScanCode.KeyV, 'v', 'V');\n\t\t\t_registerLetterIfMissing(CharCode.W, ScanCode.KeyW, 'w', 'W');\n\t\t\t_registerLetterIfMissing(CharCode.X, ScanCode.KeyX, 'x', 'X');\n\t\t\t_registerLetterIfMissing(CharCode.Y, ScanCode.KeyY, 'y', 'Y');\n\t\t\t_registerLetterIfMissing(CharCode.Z, ScanCode.KeyZ, 'z', 'Z');\n\t\t}\n\n\t\tconst mappings: IScanCodeMapping[] = [];\n\t\tlet mappingsLen = 0;\n\t\tfor (const strScanCode in rawMappings) {\n\t\t\tif (rawMappings.hasOwnProperty(strScanCode)) {\n\t\t\t\tconst scanCode = ScanCodeUtils.toEnum(strScanCode);\n\t\t\t\tif (scanCode === ScanCode.None) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== KeyCode.DependsOnKbLayout) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tthis._codeInfo[scanCode] = rawMappings[strScanCode];\n\n\t\t\t\tconst rawMapping = missingLatinLettersOverride[strScanCode] || rawMappings[strScanCode];\n\t\t\t\tconst value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);\n\t\t\t\tconst withShift = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShift);\n\t\t\t\tconst withAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withAltGr);\n\t\t\t\tconst withShiftAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShiftAltGr);\n\n\t\t\t\tconst mapping: IScanCodeMapping = {\n\t\t\t\t\tscanCode: scanCode,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\twithShift: withShift,\n\t\t\t\t\twithAltGr: withAltGr,\n\t\t\t\t\twithShiftAltGr: withShiftAltGr,\n\t\t\t\t};\n\t\t\t\tmappings[mappingsLen++] = mapping;\n\n\t\t\t\tthis._scanCodeToDispatch[scanCode] = `[${ScanCodeUtils.toString(scanCode)}]`;\n\n\t\t\t\tif (value >= CharCode.a && value <= CharCode.z) {\n\t\t\t\t\tconst upperCaseValue = CharCode.A + (value - CharCode.a);\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = String.fromCharCode(upperCaseValue);\n\t\t\t\t} else if (value >= CharCode.A && value <= CharCode.Z) {\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = String.fromCharCode(value);\n\t\t\t\t} else if (value) {\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = String.fromCharCode(value);\n\t\t\t\t} else {\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle all `withShiftAltGr` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst withShiftAltGr = mapping.withShiftAltGr;\n\t\t\tif (withShiftAltGr === mapping.withAltGr || withShiftAltGr === mapping.withShift || withShiftAltGr === mapping.value) {\n\t\t\t\t// handled below\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(withShiftAltGr);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// Ctrl+Shift+Alt+ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 0, 1, 0, keyCode); //       Ctrl+Alt+ScanCode =>          Shift+KeyCode\n\t\t\t} else {\n\t\t\t\t// Ctrl+Shift+Alt+ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 0, 0, 0, keyCode); //       Ctrl+Alt+ScanCode =>                KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all `withAltGr` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst withAltGr = mapping.withAltGr;\n\t\t\tif (withAltGr === mapping.withShift || withAltGr === mapping.value) {\n\t\t\t\t// handled below\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(withAltGr);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// Ctrl+Alt+ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 0, 1, 0, keyCode); //       Ctrl+Alt+ScanCode =>          Shift+KeyCode\n\t\t\t} else {\n\t\t\t\t// Ctrl+Alt+ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 0, 0, 0, keyCode); //       Ctrl+Alt+ScanCode =>                KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all `withShift` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst withShift = mapping.withShift;\n\t\t\tif (withShift === mapping.value) {\n\t\t\t\t// handled below\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(withShift);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// Shift+ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t} else {\n\t\t\t\t// Shift+ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 0, 0, keyCode); //          Shift+ScanCode =>                KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 0, 1, keyCode); //      Shift+Alt+ScanCode =>            Alt+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 0, 0, keyCode); //     Ctrl+Shift+ScanCode =>           Ctrl+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 0, 1, keyCode); // Ctrl+Shift+Alt+ScanCode =>       Ctrl+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all `value` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(mapping.value);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 0, scanCode, 0, 1, 0, keyCode); //                ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 1, scanCode, 0, 1, 1, keyCode); //            Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 0, scanCode, 1, 1, 0, keyCode); //           Ctrl+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 1, 1, 1, keyCode); //       Ctrl+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t} else {\n\t\t\t\t// ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 0, scanCode, 0, 0, 0, keyCode); //                ScanCode =>                KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 1, scanCode, 0, 0, 1, keyCode); //            Alt+ScanCode =>            Alt+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 0, scanCode, 1, 0, 0, keyCode); //           Ctrl+ScanCode =>           Ctrl+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 1, 0, 1, keyCode); //       Ctrl+Alt+ScanCode =>       Ctrl+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all left-over available digits\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit1, KeyCode.Digit1);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit2, KeyCode.Digit2);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit3, KeyCode.Digit3);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit4, KeyCode.Digit4);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit5, KeyCode.Digit5);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit6, KeyCode.Digit6);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit7, KeyCode.Digit7);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit8, KeyCode.Digit8);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit9, KeyCode.Digit9);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit0, KeyCode.Digit0);\n\n\t\tthis._scanCodeKeyCodeMapper.registrationComplete();\n\t}\n\n\tpublic dumpDebugInfo(): string {\n\t\tconst result: string[] = [];\n\n\t\tconst immutableSamples = [\n\t\t\tScanCode.ArrowUp,\n\t\t\tScanCode.Numpad0\n\t\t];\n\n\t\tlet cnt = 0;\n\t\tresult.push(`isUSStandard: ${this._isUSStandard}`);\n\t\tresult.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== KeyCode.DependsOnKbLayout) {\n\t\t\t\tif (immutableSamples.indexOf(scanCode) === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cnt % 4 === 0) {\n\t\t\t\tresult.push(`|       HW Code combination      |  Key  |    KeyCode combination    | Pri |          UI label         |         User settings          |    Electron accelerator   |       Dispatching string       | WYSIWYG |`);\n\t\t\t\tresult.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n\t\t\t}\n\t\t\tcnt++;\n\n\t\t\tconst mapping = this._codeInfo[scanCode];\n\n\t\t\tfor (let mod = 0; mod < 8; mod++) {\n\t\t\t\tconst hwCtrlKey = (mod & 0b001) ? true : false;\n\t\t\t\tconst hwShiftKey = (mod & 0b010) ? true : false;\n\t\t\t\tconst hwAltKey = (mod & 0b100) ? true : false;\n\t\t\t\tconst scanCodeCombo = new ScanCodeCombo(hwCtrlKey, hwShiftKey, hwAltKey, scanCode);\n\t\t\t\tconst resolvedKb = this.resolveKeyboardEvent({\n\t\t\t\t\t_standardKeyboardEventBrand: true,\n\t\t\t\t\tctrlKey: scanCodeCombo.ctrlKey,\n\t\t\t\t\tshiftKey: scanCodeCombo.shiftKey,\n\t\t\t\t\taltKey: scanCodeCombo.altKey,\n\t\t\t\t\tmetaKey: false,\n\t\t\t\t\taltGraphKey: false,\n\t\t\t\t\tkeyCode: KeyCode.DependsOnKbLayout,\n\t\t\t\t\tcode: ScanCodeUtils.toString(scanCode)\n\t\t\t\t});\n\n\t\t\t\tconst outScanCodeCombo = scanCodeCombo.toString();\n\t\t\t\tconst outKey = scanCodeCombo.getProducedChar(mapping);\n\t\t\t\tconst ariaLabel = resolvedKb.getAriaLabel();\n\t\t\t\tconst outUILabel = (ariaLabel ? ariaLabel.replace(/Control\\+/, 'Ctrl+') : null);\n\t\t\t\tconst outUserSettings = resolvedKb.getUserSettingsLabel();\n\t\t\t\tconst outElectronAccelerator = resolvedKb.getElectronAccelerator();\n\t\t\t\tconst outDispatchStr = resolvedKb.getDispatchChords()[0];\n\n\t\t\t\tconst isWYSIWYG = (resolvedKb ? resolvedKb.isWYSIWYG() : false);\n\t\t\t\tconst outWYSIWYG = (isWYSIWYG ? '       ' : '   NO  ');\n\n\t\t\t\tconst kbCombos = this._scanCodeKeyCodeMapper.lookupScanCodeCombo(scanCodeCombo);\n\t\t\t\tif (kbCombos.length === 0) {\n\t\t\t\t\tresult.push(`| ${this._leftPad(outScanCodeCombo, 30)} | ${outKey} | ${this._leftPad('', 25)} | ${this._leftPad('', 3)} | ${this._leftPad(outUILabel, 25)} | ${this._leftPad(outUserSettings, 30)} | ${this._leftPad(outElectronAccelerator, 25)} | ${this._leftPad(outDispatchStr, 30)} | ${outWYSIWYG} |`);\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0, len = kbCombos.length; i < len; i++) {\n\t\t\t\t\t\tconst kbCombo = kbCombos[i];\n\t\t\t\t\t\t// find out the priority of this scan code for this key code\n\t\t\t\t\t\tlet colPriority: string;\n\n\t\t\t\t\t\tconst scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(kbCombo);\n\t\t\t\t\t\tif (scanCodeCombos.length === 1) {\n\t\t\t\t\t\t\t// no need for priority, this key code combo maps to precisely this scan code combo\n\t\t\t\t\t\t\tcolPriority = '';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet priority = -1;\n\t\t\t\t\t\t\tfor (let j = 0; j < scanCodeCombos.length; j++) {\n\t\t\t\t\t\t\t\tif (scanCodeCombos[j].equals(scanCodeCombo)) {\n\t\t\t\t\t\t\t\t\tpriority = j + 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcolPriority = String(priority);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst outKeybinding = kbCombo.toString();\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\tresult.push(`| ${this._leftPad(outScanCodeCombo, 30)} | ${outKey} | ${this._leftPad(outKeybinding, 25)} | ${this._leftPad(colPriority, 3)} | ${this._leftPad(outUILabel, 25)} | ${this._leftPad(outUserSettings, 30)} | ${this._leftPad(outElectronAccelerator, 25)} | ${this._leftPad(outDispatchStr, 30)} | ${outWYSIWYG} |`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// secondary keybindings\n\t\t\t\t\t\t\tresult.push(`| ${this._leftPad('', 30)} |       | ${this._leftPad(outKeybinding, 25)} | ${this._leftPad(colPriority, 3)} | ${this._leftPad('', 25)} | ${this._leftPad('', 30)} | ${this._leftPad('', 25)} | ${this._leftPad('', 30)} |         |`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tresult.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n\t\t}\n\n\t\treturn result.join('\\n');\n\t}\n\n\tprivate _leftPad(str: string | null, cnt: number): string {\n\t\tif (str === null) {\n\t\t\tstr = 'null';\n\t\t}\n\t\twhile (str.length < cnt) {\n\t\t\tstr = ' ' + str;\n\t\t}\n\t\treturn str;\n\t}\n\n\tpublic keyCodeChordToScanCodeChord(chord: KeyCodeChord): ScanCodeChord[] {\n\t\t// Avoid double Enter bindings (both ScanCode.NumpadEnter and ScanCode.Enter point to KeyCode.Enter)\n\t\tif (chord.keyCode === KeyCode.Enter) {\n\t\t\treturn [new ScanCodeChord(chord.ctrlKey, chord.shiftKey, chord.altKey, chord.metaKey, ScanCode.Enter)];\n\t\t}\n\n\t\tconst scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(\n\t\t\tnew KeyCodeCombo(chord.ctrlKey, chord.shiftKey, chord.altKey, chord.keyCode)\n\t\t);\n\n\t\tconst result: ScanCodeChord[] = [];\n\t\tfor (let i = 0, len = scanCodeCombos.length; i < len; i++) {\n\t\t\tconst scanCodeCombo = scanCodeCombos[i];\n\t\t\tresult[i] = new ScanCodeChord(scanCodeCombo.ctrlKey, scanCodeCombo.shiftKey, scanCodeCombo.altKey, chord.metaKey, scanCodeCombo.scanCode);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getUILabelForScanCodeChord(chord: ScanCodeChord | null): string | null {\n\t\tif (!chord) {\n\t\t\treturn null;\n\t\t}\n\t\tif (chord.isDuplicateModifierCase()) {\n\t\t\treturn '';\n\t\t}\n\t\tif (this._OS === OperatingSystem.Macintosh) {\n\t\t\tswitch (chord.scanCode) {\n\t\t\t\tcase ScanCode.ArrowLeft:\n\t\t\t\t\treturn '';\n\t\t\t\tcase ScanCode.ArrowUp:\n\t\t\t\t\treturn '';\n\t\t\t\tcase ScanCode.ArrowRight:\n\t\t\t\t\treturn '';\n\t\t\t\tcase ScanCode.ArrowDown:\n\t\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t\treturn this._scanCodeToLabel[chord.scanCode];\n\t}\n\n\tpublic getAriaLabelForScanCodeChord(chord: ScanCodeChord | null): string | null {\n\t\tif (!chord) {\n\t\t\treturn null;\n\t\t}\n\t\tif (chord.isDuplicateModifierCase()) {\n\t\t\treturn '';\n\t\t}\n\t\treturn this._scanCodeToLabel[chord.scanCode];\n\t}\n\n\tpublic getDispatchStrForScanCodeChord(chord: ScanCodeChord): string | null {\n\t\tconst codeDispatch = this._scanCodeToDispatch[chord.scanCode];\n\t\tif (!codeDispatch) {\n\t\t\treturn null;\n\t\t}\n\t\tlet result = '';\n\n\t\tif (chord.ctrlKey) {\n\t\t\tresult += 'ctrl+';\n\t\t}\n\t\tif (chord.shiftKey) {\n\t\t\tresult += 'shift+';\n\t\t}\n\t\tif (chord.altKey) {\n\t\t\tresult += 'alt+';\n\t\t}\n\t\tif (chord.metaKey) {\n\t\t\tresult += 'meta+';\n\t\t}\n\t\tresult += codeDispatch;\n\n\t\treturn result;\n\t}\n\n\tpublic getUserSettingsLabelForScanCodeChord(chord: ScanCodeChord | null): string | null {\n\t\tif (!chord) {\n\t\t\treturn null;\n\t\t}\n\t\tif (chord.isDuplicateModifierCase()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[chord.scanCode];\n\t\tif (immutableKeyCode !== KeyCode.DependsOnKbLayout) {\n\t\t\treturn KeyCodeUtils.toUserSettingsUS(immutableKeyCode).toLowerCase();\n\t\t}\n\n\t\t// Check if this scanCode always maps to the same keyCode and back\n\t\tconst constantKeyCode: KeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(chord.scanCode);\n\t\tif (constantKeyCode !== KeyCode.DependsOnKbLayout) {\n\t\t\t// Verify that this is a good key code that can be mapped back to the same scan code\n\t\t\tconst reverseChords = this.keyCodeChordToScanCodeChord(new KeyCodeChord(chord.ctrlKey, chord.shiftKey, chord.altKey, chord.metaKey, constantKeyCode));\n\t\t\tfor (let i = 0, len = reverseChords.length; i < len; i++) {\n\t\t\t\tconst reverseChord = reverseChords[i];\n\t\t\t\tif (reverseChord.scanCode === chord.scanCode) {\n\t\t\t\t\treturn KeyCodeUtils.toUserSettingsUS(constantKeyCode).toLowerCase();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._scanCodeToDispatch[chord.scanCode];\n\t}\n\n\tpublic getElectronAcceleratorLabelForScanCodeChord(chord: ScanCodeChord | null): string | null {\n\t\tif (!chord) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[chord.scanCode];\n\t\tif (immutableKeyCode !== KeyCode.DependsOnKbLayout) {\n\t\t\treturn KeyCodeUtils.toElectronAccelerator(immutableKeyCode);\n\t\t}\n\n\t\t// Check if this scanCode always maps to the same keyCode and back\n\t\tconst constantKeyCode: KeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(chord.scanCode);\n\n\t\tif (this._OS === OperatingSystem.Linux && !this._isUSStandard) {\n\t\t\t// [Electron Accelerators] On Linux, Electron does not handle correctly OEM keys.\n\t\t\t// when using a different keyboard layout than US Standard.\n\t\t\t// See https://github.com/microsoft/vscode/issues/23706\n\t\t\t// See https://github.com/microsoft/vscode/pull/134890#issuecomment-941671791\n\t\t\tconst isOEMKey = (\n\t\t\t\tconstantKeyCode === KeyCode.Semicolon\n\t\t\t\t|| constantKeyCode === KeyCode.Equal\n\t\t\t\t|| constantKeyCode === KeyCode.Comma\n\t\t\t\t|| constantKeyCode === KeyCode.Minus\n\t\t\t\t|| constantKeyCode === KeyCode.Period\n\t\t\t\t|| constantKeyCode === KeyCode.Slash\n\t\t\t\t|| constantKeyCode === KeyCode.Backquote\n\t\t\t\t|| constantKeyCode === KeyCode.BracketLeft\n\t\t\t\t|| constantKeyCode === KeyCode.Backslash\n\t\t\t\t|| constantKeyCode === KeyCode.BracketRight\n\t\t\t);\n\n\t\t\tif (isOEMKey) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (constantKeyCode !== KeyCode.DependsOnKbLayout) {\n\t\t\treturn KeyCodeUtils.toElectronAccelerator(constantKeyCode);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _toResolvedKeybinding(chordParts: ScanCodeChord[][]): NativeResolvedKeybinding[] {\n\t\tif (chordParts.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tconst result: NativeResolvedKeybinding[] = [];\n\t\tthis._generateResolvedKeybindings(chordParts, 0, [], result);\n\t\treturn result;\n\t}\n\n\tprivate _generateResolvedKeybindings(chordParts: ScanCodeChord[][], currentIndex: number, previousParts: ScanCodeChord[], result: NativeResolvedKeybinding[]) {\n\t\tconst chordPart = chordParts[currentIndex];\n\t\tconst isFinalIndex = currentIndex === chordParts.length - 1;\n\t\tfor (let i = 0, len = chordPart.length; i < len; i++) {\n\t\t\tconst chords = [...previousParts, chordPart[i]];\n\t\t\tif (isFinalIndex) {\n\t\t\t\tresult.push(new NativeResolvedKeybinding(this, this._OS, chords));\n\t\t\t} else {\n\t\t\t\tthis._generateResolvedKeybindings(chordParts, currentIndex + 1, chords, result);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic resolveKeyboardEvent(keyboardEvent: IKeyboardEvent): NativeResolvedKeybinding {\n\t\tlet code = ScanCodeUtils.toEnum(keyboardEvent.code);\n\n\t\t// Treat NumpadEnter as Enter\n\t\tif (code === ScanCode.NumpadEnter) {\n\t\t\tcode = ScanCode.Enter;\n\t\t}\n\n\t\tconst keyCode = keyboardEvent.keyCode;\n\n\t\tif (\n\t\t\t(keyCode === KeyCode.LeftArrow)\n\t\t\t|| (keyCode === KeyCode.UpArrow)\n\t\t\t|| (keyCode === KeyCode.RightArrow)\n\t\t\t|| (keyCode === KeyCode.DownArrow)\n\t\t\t|| (keyCode === KeyCode.Delete)\n\t\t\t|| (keyCode === KeyCode.Insert)\n\t\t\t|| (keyCode === KeyCode.Home)\n\t\t\t|| (keyCode === KeyCode.End)\n\t\t\t|| (keyCode === KeyCode.PageDown)\n\t\t\t|| (keyCode === KeyCode.PageUp)\n\t\t\t|| (keyCode === KeyCode.Backspace)\n\t\t) {\n\t\t\t// \"Dispatch\" on keyCode for these key codes to workaround issues with remote desktoping software\n\t\t\t// where the scan codes appear to be incorrect (see https://github.com/microsoft/vscode/issues/24107)\n\t\t\tconst immutableScanCode = IMMUTABLE_KEY_CODE_TO_CODE[keyCode];\n\t\t\tif (immutableScanCode !== ScanCode.DependsOnKbLayout) {\n\t\t\t\tcode = immutableScanCode;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (\n\t\t\t\t(code === ScanCode.Numpad1)\n\t\t\t\t|| (code === ScanCode.Numpad2)\n\t\t\t\t|| (code === ScanCode.Numpad3)\n\t\t\t\t|| (code === ScanCode.Numpad4)\n\t\t\t\t|| (code === ScanCode.Numpad5)\n\t\t\t\t|| (code === ScanCode.Numpad6)\n\t\t\t\t|| (code === ScanCode.Numpad7)\n\t\t\t\t|| (code === ScanCode.Numpad8)\n\t\t\t\t|| (code === ScanCode.Numpad9)\n\t\t\t\t|| (code === ScanCode.Numpad0)\n\t\t\t\t|| (code === ScanCode.NumpadDecimal)\n\t\t\t) {\n\t\t\t\t// \"Dispatch\" on keyCode for all numpad keys in order for NumLock to work correctly\n\t\t\t\tif (keyCode >= 0) {\n\t\t\t\t\tconst immutableScanCode = IMMUTABLE_KEY_CODE_TO_CODE[keyCode];\n\t\t\t\t\tif (immutableScanCode !== ScanCode.DependsOnKbLayout) {\n\t\t\t\t\t\tcode = immutableScanCode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst ctrlKey = keyboardEvent.ctrlKey || (this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey);\n\t\tconst altKey = keyboardEvent.altKey || (this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey);\n\t\tconst chord = new ScanCodeChord(ctrlKey, keyboardEvent.shiftKey, altKey, keyboardEvent.metaKey, code);\n\t\treturn new NativeResolvedKeybinding(this, this._OS, [chord]);\n\t}\n\n\tprivate _resolveChord(chord: Chord | null): ScanCodeChord[] {\n\t\tif (!chord) {\n\t\t\treturn [];\n\t\t}\n\t\tif (chord instanceof ScanCodeChord) {\n\t\t\treturn [chord];\n\t\t}\n\t\treturn this.keyCodeChordToScanCodeChord(chord);\n\t}\n\n\tpublic resolveKeybinding(keybinding: Keybinding): ResolvedKeybinding[] {\n\t\tconst chords: ScanCodeChord[][] = keybinding.chords.map(chord => this._resolveChord(chord));\n\t\treturn this._toResolvedKeybinding(chords);\n\t}\n\n\tprivate static _redirectCharCode(charCode: number): number {\n\t\tswitch (charCode) {\n\t\t\t// allow-any-unicode-next-line\n\t\t\t// CJK:       \n\t\t\t// map: . [ ] [ ] ; ,\n\t\t\tcase CharCode.U_IDEOGRAPHIC_FULL_STOP: return CharCode.Period;\n\t\t\tcase CharCode.U_LEFT_CORNER_BRACKET: return CharCode.OpenSquareBracket;\n\t\t\tcase CharCode.U_RIGHT_CORNER_BRACKET: return CharCode.CloseSquareBracket;\n\t\t\tcase CharCode.U_LEFT_BLACK_LENTICULAR_BRACKET: return CharCode.OpenSquareBracket;\n\t\t\tcase CharCode.U_RIGHT_BLACK_LENTICULAR_BRACKET: return CharCode.CloseSquareBracket;\n\t\t\tcase CharCode.U_FULLWIDTH_SEMICOLON: return CharCode.Semicolon;\n\t\t\tcase CharCode.U_FULLWIDTH_COMMA: return CharCode.Comma;\n\t\t}\n\t\treturn charCode;\n\t}\n\n\tprivate static _charCodeToKb(charCode: number): { keyCode: KeyCode; shiftKey: boolean } | null {\n\t\tcharCode = this._redirectCharCode(charCode);\n\t\tif (charCode < CHAR_CODE_TO_KEY_CODE.length) {\n\t\t\treturn CHAR_CODE_TO_KEY_CODE[charCode];\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Attempt to map a combining character to a regular one that renders the same way.\n\t *\n\t * https://www.compart.com/en/unicode/bidiclass/NSM\n\t */\n\tpublic static getCharCode(char: string): number {\n\t\tif (char.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst charCode = char.charCodeAt(0);\n\t\tswitch (charCode) {\n\t\t\tcase CharCode.U_Combining_Grave_Accent: return CharCode.U_GRAVE_ACCENT;\n\t\t\tcase CharCode.U_Combining_Acute_Accent: return CharCode.U_ACUTE_ACCENT;\n\t\t\tcase CharCode.U_Combining_Circumflex_Accent: return CharCode.U_CIRCUMFLEX;\n\t\t\tcase CharCode.U_Combining_Tilde: return CharCode.U_SMALL_TILDE;\n\t\t\tcase CharCode.U_Combining_Macron: return CharCode.U_MACRON;\n\t\t\tcase CharCode.U_Combining_Overline: return CharCode.U_OVERLINE;\n\t\t\tcase CharCode.U_Combining_Breve: return CharCode.U_BREVE;\n\t\t\tcase CharCode.U_Combining_Dot_Above: return CharCode.U_DOT_ABOVE;\n\t\t\tcase CharCode.U_Combining_Diaeresis: return CharCode.U_DIAERESIS;\n\t\t\tcase CharCode.U_Combining_Ring_Above: return CharCode.U_RING_ABOVE;\n\t\t\tcase CharCode.U_Combining_Double_Acute_Accent: return CharCode.U_DOUBLE_ACUTE_ACCENT;\n\t\t}\n\t\treturn charCode;\n\t}\n}\n\n(function () {\n\tfunction define(charCode: number, keyCode: KeyCode, shiftKey: boolean): void {\n\t\tfor (let i = CHAR_CODE_TO_KEY_CODE.length; i < charCode; i++) {\n\t\t\tCHAR_CODE_TO_KEY_CODE[i] = null;\n\t\t}\n\t\tCHAR_CODE_TO_KEY_CODE[charCode] = { keyCode: keyCode, shiftKey: shiftKey };\n\t}\n\n\tfor (let chCode = CharCode.A; chCode <= CharCode.Z; chCode++) {\n\t\tdefine(chCode, KeyCode.KeyA + (chCode - CharCode.A), true);\n\t}\n\n\tfor (let chCode = CharCode.a; chCode <= CharCode.z; chCode++) {\n\t\tdefine(chCode, KeyCode.KeyA + (chCode - CharCode.a), false);\n\t}\n\n\tdefine(CharCode.Semicolon, KeyCode.Semicolon, false);\n\tdefine(CharCode.Colon, KeyCode.Semicolon, true);\n\n\tdefine(CharCode.Equals, KeyCode.Equal, false);\n\tdefine(CharCode.Plus, KeyCode.Equal, true);\n\n\tdefine(CharCode.Comma, KeyCode.Comma, false);\n\tdefine(CharCode.LessThan, KeyCode.Comma, true);\n\n\tdefine(CharCode.Dash, KeyCode.Minus, false);\n\tdefine(CharCode.Underline, KeyCode.Minus, true);\n\n\tdefine(CharCode.Period, KeyCode.Period, false);\n\tdefine(CharCode.GreaterThan, KeyCode.Period, true);\n\n\tdefine(CharCode.Slash, KeyCode.Slash, false);\n\tdefine(CharCode.QuestionMark, KeyCode.Slash, true);\n\n\tdefine(CharCode.BackTick, KeyCode.Backquote, false);\n\tdefine(CharCode.Tilde, KeyCode.Backquote, true);\n\n\tdefine(CharCode.OpenSquareBracket, KeyCode.BracketLeft, false);\n\tdefine(CharCode.OpenCurlyBrace, KeyCode.BracketLeft, true);\n\n\tdefine(CharCode.Backslash, KeyCode.Backslash, false);\n\tdefine(CharCode.Pipe, KeyCode.Backslash, true);\n\n\tdefine(CharCode.CloseSquareBracket, KeyCode.BracketRight, false);\n\tdefine(CharCode.CloseCurlyBrace, KeyCode.BracketRight, true);\n\n\tdefine(CharCode.SingleQuote, KeyCode.Quote, false);\n\tdefine(CharCode.DoubleQuote, KeyCode.Quote, true);\n})();\n"]}