{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/commands/common/commandService.ts","vs/workbench/services/commands/common/commandService.ts"],"names":[],"mappings":"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","file":"commandService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancelablePromise, notCancellablePromise, raceCancellablePromises, timeout } from '../../../../base/common/async.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { CommandsRegistry, ICommandEvent, ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IExtensionService } from '../../extensions/common/extensions.js';\n\nexport class CommandService extends Disposable implements ICommandService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _extensionHostIsReady: boolean = false;\n\tprivate _starActivation: CancelablePromise<void> | null;\n\n\tprivate readonly _onWillExecuteCommand: Emitter<ICommandEvent> = this._register(new Emitter<ICommandEvent>());\n\tpublic readonly onWillExecuteCommand: Event<ICommandEvent> = this._onWillExecuteCommand.event;\n\n\tprivate readonly _onDidExecuteCommand: Emitter<ICommandEvent> = new Emitter<ICommandEvent>();\n\tpublic readonly onDidExecuteCommand: Event<ICommandEvent> = this._onDidExecuteCommand.event;\n\n\tconstructor(\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IExtensionService private readonly _extensionService: IExtensionService,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._extensionService.whenInstalledExtensionsRegistered().then(value => this._extensionHostIsReady = value);\n\t\tthis._starActivation = null;\n\t}\n\n\tprivate _activateStar(): Promise<void> {\n\t\tif (!this._starActivation) {\n\t\t\t// wait for * activation, limited to at most 30s.\n\t\t\tthis._starActivation = raceCancellablePromises([\n\t\t\t\tthis._extensionService.activateByEvent(`*`),\n\t\t\t\ttimeout(30000)\n\t\t\t]);\n\t\t}\n\n\t\t// This is wrapped with notCancellablePromise so it doesn't get cancelled\n\t\t// early because it is shared between consumers.\n\t\treturn notCancellablePromise(this._starActivation);\n\t}\n\n\tasync executeCommand<T>(id: string, ...args: unknown[]): Promise<T> {\n\t\tthis._logService.trace('CommandService#executeCommand', id);\n\n\t\tconst activationEvent = `onCommand:${id}`;\n\t\tconst commandIsRegistered = !!CommandsRegistry.getCommand(id);\n\n\t\tif (commandIsRegistered) {\n\n\t\t\t// if the activation event has already resolved (i.e. subsequent call),\n\t\t\t// we will execute the registered command immediately\n\t\t\tif (this._extensionService.activationEventIsDone(activationEvent)) {\n\t\t\t\treturn this._tryExecuteCommand(id, args);\n\t\t\t}\n\n\t\t\t// if the extension host didn't start yet, we will execute the registered\n\t\t\t// command immediately and send an activation event, but not wait for it\n\t\t\tif (!this._extensionHostIsReady) {\n\t\t\t\tthis._extensionService.activateByEvent(activationEvent); // intentionally not awaited\n\t\t\t\treturn this._tryExecuteCommand(id, args);\n\t\t\t}\n\n\t\t\t// we will wait for a simple activation event (e.g. in case an extension wants to overwrite it)\n\t\t\tawait this._extensionService.activateByEvent(activationEvent);\n\t\t\treturn this._tryExecuteCommand(id, args);\n\t\t}\n\n\t\t// finally, if the command is not registered we will send a simple activation event\n\t\t// as well as a * activation event raced against registration and against 30s\n\t\tawait Promise.all([\n\t\t\tthis._extensionService.activateByEvent(activationEvent),\n\t\t\traceCancellablePromises<unknown>([\n\t\t\t\t// race * activation against command registration\n\t\t\t\tthis._activateStar(),\n\t\t\t\tEvent.toPromise(Event.filter(CommandsRegistry.onDidRegisterCommand, e => e === id))\n\t\t\t]),\n\t\t]);\n\n\t\treturn this._tryExecuteCommand(id, args);\n\t}\n\n\tprivate _tryExecuteCommand(id: string, args: unknown[]): Promise<any> {\n\t\tconst command = CommandsRegistry.getCommand(id);\n\t\tif (!command) {\n\t\t\treturn Promise.reject(new Error(`command '${id}' not found`));\n\t\t}\n\t\ttry {\n\t\t\tthis._onWillExecuteCommand.fire({ commandId: id, args });\n\t\t\tconst result = this._instantiationService.invokeFunction(command.handler, ...args);\n\t\t\tthis._onDidExecuteCommand.fire({ commandId: id, args });\n\t\t\treturn Promise.resolve(result);\n\t\t} catch (err) {\n\t\t\treturn Promise.reject(err);\n\t\t}\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\tthis._starActivation?.cancel();\n\t}\n}\n\nregisterSingleton(ICommandService, CommandService, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancelablePromise, notCancellablePromise, raceCancellablePromises, timeout } from '../../../../base/common/async.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { CommandsRegistry, ICommandEvent, ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { IExtensionService } from '../../extensions/common/extensions.js';\n\nexport class CommandService extends Disposable implements ICommandService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _extensionHostIsReady: boolean = false;\n\tprivate _starActivation: CancelablePromise<void> | null;\n\n\tprivate readonly _onWillExecuteCommand: Emitter<ICommandEvent> = this._register(new Emitter<ICommandEvent>());\n\tpublic readonly onWillExecuteCommand: Event<ICommandEvent> = this._onWillExecuteCommand.event;\n\n\tprivate readonly _onDidExecuteCommand: Emitter<ICommandEvent> = new Emitter<ICommandEvent>();\n\tpublic readonly onDidExecuteCommand: Event<ICommandEvent> = this._onDidExecuteCommand.event;\n\n\tconstructor(\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IExtensionService private readonly _extensionService: IExtensionService,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._extensionService.whenInstalledExtensionsRegistered().then(value => this._extensionHostIsReady = value);\n\t\tthis._starActivation = null;\n\t}\n\n\tprivate _activateStar(): Promise<void> {\n\t\tif (!this._starActivation) {\n\t\t\t// wait for * activation, limited to at most 30s.\n\t\t\tthis._starActivation = raceCancellablePromises([\n\t\t\t\tthis._extensionService.activateByEvent(`*`),\n\t\t\t\ttimeout(30000)\n\t\t\t]);\n\t\t}\n\n\t\t// This is wrapped with notCancellablePromise so it doesn't get cancelled\n\t\t// early because it is shared between consumers.\n\t\treturn notCancellablePromise(this._starActivation);\n\t}\n\n\tasync executeCommand<T>(id: string, ...args: unknown[]): Promise<T> {\n\t\tthis._logService.trace('CommandService#executeCommand', id);\n\n\t\tconst activationEvent = `onCommand:${id}`;\n\t\tconst commandIsRegistered = !!CommandsRegistry.getCommand(id);\n\n\t\tif (commandIsRegistered) {\n\n\t\t\t// if the activation event has already resolved (i.e. subsequent call),\n\t\t\t// we will execute the registered command immediately\n\t\t\tif (this._extensionService.activationEventIsDone(activationEvent)) {\n\t\t\t\treturn this._tryExecuteCommand(id, args);\n\t\t\t}\n\n\t\t\t// if the extension host didn't start yet, we will execute the registered\n\t\t\t// command immediately and send an activation event, but not wait for it\n\t\t\tif (!this._extensionHostIsReady) {\n\t\t\t\tthis._extensionService.activateByEvent(activationEvent); // intentionally not awaited\n\t\t\t\treturn this._tryExecuteCommand(id, args);\n\t\t\t}\n\n\t\t\t// we will wait for a simple activation event (e.g. in case an extension wants to overwrite it)\n\t\t\tawait this._extensionService.activateByEvent(activationEvent);\n\t\t\treturn this._tryExecuteCommand(id, args);\n\t\t}\n\n\t\t// finally, if the command is not registered we will send a simple activation event\n\t\t// as well as a * activation event raced against registration and against 30s\n\t\tawait Promise.all([\n\t\t\tthis._extensionService.activateByEvent(activationEvent),\n\t\t\traceCancellablePromises<unknown>([\n\t\t\t\t// race * activation against command registration\n\t\t\t\tthis._activateStar(),\n\t\t\t\tEvent.toPromise(Event.filter(CommandsRegistry.onDidRegisterCommand, e => e === id))\n\t\t\t]),\n\t\t]);\n\n\t\treturn this._tryExecuteCommand(id, args);\n\t}\n\n\tprivate _tryExecuteCommand(id: string, args: unknown[]): Promise<any> {\n\t\tconst command = CommandsRegistry.getCommand(id);\n\t\tif (!command) {\n\t\t\treturn Promise.reject(new Error(`command '${id}' not found`));\n\t\t}\n\t\ttry {\n\t\t\tthis._onWillExecuteCommand.fire({ commandId: id, args });\n\t\t\tconst result = this._instantiationService.invokeFunction(command.handler, ...args);\n\t\t\tthis._onDidExecuteCommand.fire({ commandId: id, args });\n\t\t\treturn Promise.resolve(result);\n\t\t} catch (err) {\n\t\t\treturn Promise.reject(err);\n\t\t}\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\tthis._starActivation?.cancel();\n\t}\n}\n\nregisterSingleton(ICommandService, CommandService, InstantiationType.Delayed);\n"]}