{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/textMateWorkerTokenizerController.ts","vs/workbench/services/textMate/browser/backgroundTokenization/textMateWorkerTokenizerController.ts"],"names":[],"mappings":"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","file":"textMateWorkerTokenizerController.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { importAMDNodeModule } from '../../../../../amdX.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { IObservable, autorun, keepObserved } from '../../../../../base/common/observable.js';\nimport { Proxied } from '../../../../../base/common/worker/webWorker.js';\nimport { LineRange } from '../../../../../editor/common/core/ranges/lineRange.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { IBackgroundTokenizationStore, ILanguageIdCodec } from '../../../../../editor/common/languages.js';\nimport { ITextModel } from '../../../../../editor/common/model.js';\nimport { TokenizationStateStore } from '../../../../../editor/common/model/textModelTokens.js';\nimport { IModelContentChangedEvent } from '../../../../../editor/common/textModelEvents.js';\nimport { IModelContentChange } from '../../../../../editor/common/model/mirrorTextModel.js';\nimport { ContiguousMultilineTokensBuilder } from '../../../../../editor/common/tokens/contiguousMultilineTokensBuilder.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { observableConfigValue } from '../../../../../platform/observable/common/platformObservableUtils.js';\nimport { MonotonousIndexTransformer } from '../indexTransformer.js';\nimport type { StateDeltas, TextMateTokenizationWorker } from './worker/textMateTokenizationWorker.worker.js';\nimport type { applyStateStackDiff, StateStack } from 'vscode-textmate';\nimport { linesLengthEditFromModelContentChange } from '../../../../../editor/common/model/textModelStringEdit.js';\n\nexport class TextMateWorkerTokenizerController extends Disposable {\n\tprivate static _id = 0;\n\n\tpublic readonly controllerId;\n\tprivate readonly _pendingChanges: IModelContentChangedEvent[];\n\n\t/**\n\t * These states will eventually equal the worker states.\n\t * _states[i] stores the state at the end of line number i+1.\n\t */\n\tprivate readonly _states;\n\n\tprivate readonly _loggingEnabled;\n\n\tprivate _applyStateStackDiffFn?: typeof applyStateStackDiff;\n\tprivate _initialState?: StateStack;\n\n\tconstructor(\n\t\tprivate readonly _model: ITextModel,\n\t\tprivate readonly _worker: Proxied<TextMateTokenizationWorker>,\n\t\tprivate readonly _languageIdCodec: ILanguageIdCodec,\n\t\tprivate readonly _backgroundTokenizationStore: IBackgroundTokenizationStore,\n\t\tprivate readonly _configurationService: IConfigurationService,\n\t\tprivate readonly _maxTokenizationLineLength: IObservable<number>,\n\t) {\n\t\tsuper();\n\t\tthis.controllerId = TextMateWorkerTokenizerController._id++;\n\t\tthis._pendingChanges = [];\n\t\tthis._states = new TokenizationStateStore<StateStack>();\n\t\tthis._loggingEnabled = observableConfigValue('editor.experimental.asyncTokenizationLogging', false, this._configurationService);\n\n\t\tthis._register(keepObserved(this._loggingEnabled));\n\n\t\tthis._register(this._model.onDidChangeContent((e) => {\n\t\t\tif (this._shouldLog) {\n\t\t\t\tconsole.log('model change', {\n\t\t\t\t\tfileName: this._model.uri.fsPath.split('\\\\').pop(),\n\t\t\t\t\tchanges: changesToString(e.changes),\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis._worker.$acceptModelChanged(this.controllerId, e);\n\t\t\tthis._pendingChanges.push(e);\n\t\t}));\n\n\t\tthis._register(this._model.onDidChangeLanguage((e) => {\n\t\t\tconst languageId = this._model.getLanguageId();\n\t\t\tconst encodedLanguageId =\n\t\t\t\tthis._languageIdCodec.encodeLanguageId(languageId);\n\t\t\tthis._worker.$acceptModelLanguageChanged(\n\t\t\t\tthis.controllerId,\n\t\t\t\tlanguageId,\n\t\t\t\tencodedLanguageId\n\t\t\t);\n\t\t}));\n\n\t\tconst languageId = this._model.getLanguageId();\n\t\tconst encodedLanguageId = this._languageIdCodec.encodeLanguageId(languageId);\n\t\tthis._worker.$acceptNewModel({\n\t\t\turi: this._model.uri,\n\t\t\tversionId: this._model.getVersionId(),\n\t\t\tlines: this._model.getLinesContent(),\n\t\t\tEOL: this._model.getEOL(),\n\t\t\tlanguageId,\n\t\t\tencodedLanguageId,\n\t\t\tmaxTokenizationLineLength: this._maxTokenizationLineLength.get(),\n\t\t\tcontrollerId: this.controllerId,\n\t\t});\n\n\t\tthis._register(autorun(reader => {\n\t\t\t/** @description update maxTokenizationLineLength */\n\t\t\tconst maxTokenizationLineLength = this._maxTokenizationLineLength.read(reader);\n\t\t\tthis._worker.$acceptMaxTokenizationLineLength(this.controllerId, maxTokenizationLineLength);\n\t\t}));\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\tthis._worker.$acceptRemovedModel(this.controllerId);\n\t}\n\n\tpublic requestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._worker.$retokenize(this.controllerId, startLineNumber, endLineNumberExclusive);\n\t}\n\n\t/**\n\t * This method is called from the worker through the worker host.\n\t */\n\tpublic async setTokensAndStates(controllerId: number, versionId: number, rawTokens: Uint8Array, stateDeltas: StateDeltas[]): Promise<void> {\n\t\tif (this.controllerId !== controllerId) {\n\t\t\t// This event is for an outdated controller (the worker didn't receive the delete/create messages yet), ignore the event.\n\t\t\treturn;\n\t\t}\n\n\t\t// _states state, change{k}, ..., change{versionId}, state delta base & rawTokens, change{j}, ..., change{m}, current renderer state\n\t\t//                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                ^^^^^^^^^^^^^^^^^^^^^^^^^\n\t\t//                | past changes                                                   | future states\n\n\t\tlet tokens = ContiguousMultilineTokensBuilder.deserialize(\n\t\t\tnew Uint8Array(rawTokens)\n\t\t);\n\n\t\tif (this._shouldLog) {\n\t\t\tconsole.log('received background tokenization result', {\n\t\t\t\tfileName: this._model.uri.fsPath.split('\\\\').pop(),\n\t\t\t\tupdatedTokenLines: tokens.map((t) => t.getLineRange()).join(' & '),\n\t\t\t\tupdatedStateLines: stateDeltas.map((s) => new LineRange(s.startLineNumber, s.startLineNumber + s.stateDeltas.length).toString()).join(' & '),\n\t\t\t});\n\t\t}\n\n\t\tif (this._shouldLog) {\n\t\t\tconst changes = this._pendingChanges.filter(c => c.versionId <= versionId).map(c => c.changes).map(c => changesToString(c)).join(' then ');\n\t\t\tconsole.log('Applying changes to local states', changes);\n\t\t}\n\n\t\t// Apply past changes to _states\n\t\twhile (\n\t\t\tthis._pendingChanges.length > 0 &&\n\t\t\tthis._pendingChanges[0].versionId <= versionId\n\t\t) {\n\t\t\tconst change = this._pendingChanges.shift()!;\n\t\t\tthis._states.acceptChanges(change.changes);\n\t\t}\n\n\t\tif (this._pendingChanges.length > 0) {\n\t\t\tif (this._shouldLog) {\n\t\t\t\tconst changes = this._pendingChanges.map(c => c.changes).map(c => changesToString(c)).join(' then ');\n\t\t\t\tconsole.log('Considering non-processed changes', changes);\n\t\t\t}\n\n\t\t\tconst curToFutureTransformerTokens = MonotonousIndexTransformer.fromMany(\n\t\t\t\tthis._pendingChanges.map((c) => linesLengthEditFromModelContentChange(c.changes))\n\t\t\t);\n\n\t\t\t// Filter tokens in lines that got changed in the future to prevent flickering\n\t\t\t// These tokens are recomputed anyway.\n\t\t\tconst b = new ContiguousMultilineTokensBuilder();\n\t\t\tfor (const t of tokens) {\n\t\t\t\tfor (let i = t.startLineNumber; i <= t.endLineNumber; i++) {\n\t\t\t\t\tconst result = curToFutureTransformerTokens.transform(i - 1);\n\t\t\t\t\t// If result is undefined, the current line got touched by an edit.\n\t\t\t\t\t// The webworker will send us new tokens for all the new/touched lines after it received the edits.\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tb.add(i, t.getLineTokens(i) as Uint32Array);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttokens = b.finalize();\n\n\t\t\t// Apply future changes to tokens\n\t\t\tfor (const change of this._pendingChanges) {\n\t\t\t\tfor (const innerChanges of change.changes) {\n\t\t\t\t\tfor (let j = 0; j < tokens.length; j++) {\n\t\t\t\t\t\ttokens[j].applyEdit(innerChanges.range, innerChanges.text);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst curToFutureTransformerStates = MonotonousIndexTransformer.fromMany(\n\t\t\tthis._pendingChanges.map((c) => linesLengthEditFromModelContentChange(c.changes))\n\t\t);\n\n\t\tif (!this._applyStateStackDiffFn || !this._initialState) {\n\t\t\tconst { applyStateStackDiff, INITIAL } = await importAMDNodeModule<typeof import('vscode-textmate')>('vscode-textmate', 'release/main.js');\n\t\t\tthis._applyStateStackDiffFn = applyStateStackDiff;\n\t\t\tthis._initialState = INITIAL;\n\t\t}\n\n\n\t\t// Apply state deltas to _states and _backgroundTokenizationStore\n\t\tfor (const d of stateDeltas) {\n\t\t\tlet prevState = d.startLineNumber <= 1 ? this._initialState : this._states.getEndState(d.startLineNumber - 1);\n\t\t\tfor (let i = 0; i < d.stateDeltas.length; i++) {\n\t\t\t\tconst delta = d.stateDeltas[i];\n\t\t\t\tlet state: StateStack;\n\t\t\t\tif (delta) {\n\t\t\t\t\tstate = this._applyStateStackDiffFn(prevState, delta)!;\n\t\t\t\t\tthis._states.setEndState(d.startLineNumber + i, state);\n\t\t\t\t} else {\n\t\t\t\t\tstate = this._states.getEndState(d.startLineNumber + i)!;\n\t\t\t\t}\n\n\t\t\t\tconst offset = curToFutureTransformerStates.transform(d.startLineNumber + i - 1);\n\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t// Only set the state if there is no future change in this line,\n\t\t\t\t\t// as this might make consumers believe that the state/tokens are accurate\n\t\t\t\t\tthis._backgroundTokenizationStore.setEndState(offset + 1, state);\n\t\t\t\t}\n\n\t\t\t\tif (d.startLineNumber + i >= this._model.getLineCount() - 1) {\n\t\t\t\t\tthis._backgroundTokenizationStore.backgroundTokenizationFinished();\n\t\t\t\t}\n\n\t\t\t\tprevState = state;\n\t\t\t}\n\t\t}\n\t\t// First set states, then tokens, so that events fired from set tokens don't read invalid states\n\t\tthis._backgroundTokenizationStore.setTokens(tokens);\n\t}\n\n\tprivate get _shouldLog() { return this._loggingEnabled.get(); }\n\n}\n\nfunction changesToString(changes: IModelContentChange[]): string {\n\treturn changes.map(c => Range.lift(c.range).toString() + ' => ' + c.text).join(' & ');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { importAMDNodeModule } from '../../../../../amdX.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { IObservable, autorun, keepObserved } from '../../../../../base/common/observable.js';\nimport { Proxied } from '../../../../../base/common/worker/webWorker.js';\nimport { LineRange } from '../../../../../editor/common/core/ranges/lineRange.js';\nimport { Range } from '../../../../../editor/common/core/range.js';\nimport { IBackgroundTokenizationStore, ILanguageIdCodec } from '../../../../../editor/common/languages.js';\nimport { ITextModel } from '../../../../../editor/common/model.js';\nimport { TokenizationStateStore } from '../../../../../editor/common/model/textModelTokens.js';\nimport { IModelContentChangedEvent } from '../../../../../editor/common/textModelEvents.js';\nimport { IModelContentChange } from '../../../../../editor/common/model/mirrorTextModel.js';\nimport { ContiguousMultilineTokensBuilder } from '../../../../../editor/common/tokens/contiguousMultilineTokensBuilder.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { observableConfigValue } from '../../../../../platform/observable/common/platformObservableUtils.js';\nimport { MonotonousIndexTransformer } from '../indexTransformer.js';\nimport type { StateDeltas, TextMateTokenizationWorker } from './worker/textMateTokenizationWorker.worker.js';\nimport type { applyStateStackDiff, StateStack } from 'vscode-textmate';\nimport { linesLengthEditFromModelContentChange } from '../../../../../editor/common/model/textModelStringEdit.js';\n\nexport class TextMateWorkerTokenizerController extends Disposable {\n\tprivate static _id = 0;\n\n\tpublic readonly controllerId;\n\tprivate readonly _pendingChanges: IModelContentChangedEvent[];\n\n\t/**\n\t * These states will eventually equal the worker states.\n\t * _states[i] stores the state at the end of line number i+1.\n\t */\n\tprivate readonly _states;\n\n\tprivate readonly _loggingEnabled;\n\n\tprivate _applyStateStackDiffFn?: typeof applyStateStackDiff;\n\tprivate _initialState?: StateStack;\n\n\tconstructor(\n\t\tprivate readonly _model: ITextModel,\n\t\tprivate readonly _worker: Proxied<TextMateTokenizationWorker>,\n\t\tprivate readonly _languageIdCodec: ILanguageIdCodec,\n\t\tprivate readonly _backgroundTokenizationStore: IBackgroundTokenizationStore,\n\t\tprivate readonly _configurationService: IConfigurationService,\n\t\tprivate readonly _maxTokenizationLineLength: IObservable<number>,\n\t) {\n\t\tsuper();\n\t\tthis.controllerId = TextMateWorkerTokenizerController._id++;\n\t\tthis._pendingChanges = [];\n\t\tthis._states = new TokenizationStateStore<StateStack>();\n\t\tthis._loggingEnabled = observableConfigValue('editor.experimental.asyncTokenizationLogging', false, this._configurationService);\n\n\t\tthis._register(keepObserved(this._loggingEnabled));\n\n\t\tthis._register(this._model.onDidChangeContent((e) => {\n\t\t\tif (this._shouldLog) {\n\t\t\t\tconsole.log('model change', {\n\t\t\t\t\tfileName: this._model.uri.fsPath.split('\\\\').pop(),\n\t\t\t\t\tchanges: changesToString(e.changes),\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis._worker.$acceptModelChanged(this.controllerId, e);\n\t\t\tthis._pendingChanges.push(e);\n\t\t}));\n\n\t\tthis._register(this._model.onDidChangeLanguage((e) => {\n\t\t\tconst languageId = this._model.getLanguageId();\n\t\t\tconst encodedLanguageId =\n\t\t\t\tthis._languageIdCodec.encodeLanguageId(languageId);\n\t\t\tthis._worker.$acceptModelLanguageChanged(\n\t\t\t\tthis.controllerId,\n\t\t\t\tlanguageId,\n\t\t\t\tencodedLanguageId\n\t\t\t);\n\t\t}));\n\n\t\tconst languageId = this._model.getLanguageId();\n\t\tconst encodedLanguageId = this._languageIdCodec.encodeLanguageId(languageId);\n\t\tthis._worker.$acceptNewModel({\n\t\t\turi: this._model.uri,\n\t\t\tversionId: this._model.getVersionId(),\n\t\t\tlines: this._model.getLinesContent(),\n\t\t\tEOL: this._model.getEOL(),\n\t\t\tlanguageId,\n\t\t\tencodedLanguageId,\n\t\t\tmaxTokenizationLineLength: this._maxTokenizationLineLength.get(),\n\t\t\tcontrollerId: this.controllerId,\n\t\t});\n\n\t\tthis._register(autorun(reader => {\n\t\t\t/** @description update maxTokenizationLineLength */\n\t\t\tconst maxTokenizationLineLength = this._maxTokenizationLineLength.read(reader);\n\t\t\tthis._worker.$acceptMaxTokenizationLineLength(this.controllerId, maxTokenizationLineLength);\n\t\t}));\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\tthis._worker.$acceptRemovedModel(this.controllerId);\n\t}\n\n\tpublic requestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._worker.$retokenize(this.controllerId, startLineNumber, endLineNumberExclusive);\n\t}\n\n\t/**\n\t * This method is called from the worker through the worker host.\n\t */\n\tpublic async setTokensAndStates(controllerId: number, versionId: number, rawTokens: Uint8Array, stateDeltas: StateDeltas[]): Promise<void> {\n\t\tif (this.controllerId !== controllerId) {\n\t\t\t// This event is for an outdated controller (the worker didn't receive the delete/create messages yet), ignore the event.\n\t\t\treturn;\n\t\t}\n\n\t\t// _states state, change{k}, ..., change{versionId}, state delta base & rawTokens, change{j}, ..., change{m}, current renderer state\n\t\t//                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                ^^^^^^^^^^^^^^^^^^^^^^^^^\n\t\t//                | past changes                                                   | future states\n\n\t\tlet tokens = ContiguousMultilineTokensBuilder.deserialize(\n\t\t\tnew Uint8Array(rawTokens)\n\t\t);\n\n\t\tif (this._shouldLog) {\n\t\t\tconsole.log('received background tokenization result', {\n\t\t\t\tfileName: this._model.uri.fsPath.split('\\\\').pop(),\n\t\t\t\tupdatedTokenLines: tokens.map((t) => t.getLineRange()).join(' & '),\n\t\t\t\tupdatedStateLines: stateDeltas.map((s) => new LineRange(s.startLineNumber, s.startLineNumber + s.stateDeltas.length).toString()).join(' & '),\n\t\t\t});\n\t\t}\n\n\t\tif (this._shouldLog) {\n\t\t\tconst changes = this._pendingChanges.filter(c => c.versionId <= versionId).map(c => c.changes).map(c => changesToString(c)).join(' then ');\n\t\t\tconsole.log('Applying changes to local states', changes);\n\t\t}\n\n\t\t// Apply past changes to _states\n\t\twhile (\n\t\t\tthis._pendingChanges.length > 0 &&\n\t\t\tthis._pendingChanges[0].versionId <= versionId\n\t\t) {\n\t\t\tconst change = this._pendingChanges.shift()!;\n\t\t\tthis._states.acceptChanges(change.changes);\n\t\t}\n\n\t\tif (this._pendingChanges.length > 0) {\n\t\t\tif (this._shouldLog) {\n\t\t\t\tconst changes = this._pendingChanges.map(c => c.changes).map(c => changesToString(c)).join(' then ');\n\t\t\t\tconsole.log('Considering non-processed changes', changes);\n\t\t\t}\n\n\t\t\tconst curToFutureTransformerTokens = MonotonousIndexTransformer.fromMany(\n\t\t\t\tthis._pendingChanges.map((c) => linesLengthEditFromModelContentChange(c.changes))\n\t\t\t);\n\n\t\t\t// Filter tokens in lines that got changed in the future to prevent flickering\n\t\t\t// These tokens are recomputed anyway.\n\t\t\tconst b = new ContiguousMultilineTokensBuilder();\n\t\t\tfor (const t of tokens) {\n\t\t\t\tfor (let i = t.startLineNumber; i <= t.endLineNumber; i++) {\n\t\t\t\t\tconst result = curToFutureTransformerTokens.transform(i - 1);\n\t\t\t\t\t// If result is undefined, the current line got touched by an edit.\n\t\t\t\t\t// The webworker will send us new tokens for all the new/touched lines after it received the edits.\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tb.add(i, t.getLineTokens(i) as Uint32Array);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttokens = b.finalize();\n\n\t\t\t// Apply future changes to tokens\n\t\t\tfor (const change of this._pendingChanges) {\n\t\t\t\tfor (const innerChanges of change.changes) {\n\t\t\t\t\tfor (let j = 0; j < tokens.length; j++) {\n\t\t\t\t\t\ttokens[j].applyEdit(innerChanges.range, innerChanges.text);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst curToFutureTransformerStates = MonotonousIndexTransformer.fromMany(\n\t\t\tthis._pendingChanges.map((c) => linesLengthEditFromModelContentChange(c.changes))\n\t\t);\n\n\t\tif (!this._applyStateStackDiffFn || !this._initialState) {\n\t\t\tconst { applyStateStackDiff, INITIAL } = await importAMDNodeModule<typeof import('vscode-textmate')>('vscode-textmate', 'release/main.js');\n\t\t\tthis._applyStateStackDiffFn = applyStateStackDiff;\n\t\t\tthis._initialState = INITIAL;\n\t\t}\n\n\n\t\t// Apply state deltas to _states and _backgroundTokenizationStore\n\t\tfor (const d of stateDeltas) {\n\t\t\tlet prevState = d.startLineNumber <= 1 ? this._initialState : this._states.getEndState(d.startLineNumber - 1);\n\t\t\tfor (let i = 0; i < d.stateDeltas.length; i++) {\n\t\t\t\tconst delta = d.stateDeltas[i];\n\t\t\t\tlet state: StateStack;\n\t\t\t\tif (delta) {\n\t\t\t\t\tstate = this._applyStateStackDiffFn(prevState, delta)!;\n\t\t\t\t\tthis._states.setEndState(d.startLineNumber + i, state);\n\t\t\t\t} else {\n\t\t\t\t\tstate = this._states.getEndState(d.startLineNumber + i)!;\n\t\t\t\t}\n\n\t\t\t\tconst offset = curToFutureTransformerStates.transform(d.startLineNumber + i - 1);\n\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t// Only set the state if there is no future change in this line,\n\t\t\t\t\t// as this might make consumers believe that the state/tokens are accurate\n\t\t\t\t\tthis._backgroundTokenizationStore.setEndState(offset + 1, state);\n\t\t\t\t}\n\n\t\t\t\tif (d.startLineNumber + i >= this._model.getLineCount() - 1) {\n\t\t\t\t\tthis._backgroundTokenizationStore.backgroundTokenizationFinished();\n\t\t\t\t}\n\n\t\t\t\tprevState = state;\n\t\t\t}\n\t\t}\n\t\t// First set states, then tokens, so that events fired from set tokens don't read invalid states\n\t\tthis._backgroundTokenizationStore.setTokens(tokens);\n\t}\n\n\tprivate get _shouldLog() { return this._loggingEnabled.get(); }\n\n}\n\nfunction changesToString(changes: IModelContentChange[]): string {\n\treturn changes.map(c => Range.lift(c.range).toString() + ' => ' + c.text).join(' & ');\n}\n"]}