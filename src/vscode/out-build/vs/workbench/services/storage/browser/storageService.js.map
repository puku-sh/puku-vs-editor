{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/storage/browser/storageService.ts","vs/workbench/services/storage/browser/storageService.ts"],"names":[],"mappings":"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","file":"storageService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BroadcastDataChannel } from '../../../../base/browser/broadcast.js';\nimport { isSafari } from '../../../../base/browser/browser.js';\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { IndexedDB } from '../../../../base/browser/indexedDB.js';\nimport { DeferredPromise, Promises } from '../../../../base/common/async.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { assertReturnsDefined } from '../../../../base/common/types.js';\nimport { InMemoryStorageDatabase, isStorageItemsChangeEvent, IStorage, IStorageDatabase, IStorageItemsChangeEvent, IUpdateRequest, Storage } from '../../../../base/parts/storage/common/storage.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { AbstractStorageService, isProfileUsingDefaultStorage, IS_NEW_KEY, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { isUserDataProfile, IUserDataProfile } from '../../../../platform/userDataProfile/common/userDataProfile.js';\nimport { IAnyWorkspaceIdentifier } from '../../../../platform/workspace/common/workspace.js';\nimport { IUserDataProfileService } from '../../userDataProfile/common/userDataProfile.js';\n\nexport class BrowserStorageService extends AbstractStorageService {\n\n\tprivate static BROWSER_DEFAULT_FLUSH_INTERVAL = 5 * 1000; // every 5s because async operations are not permitted on shutdown\n\n\tprivate applicationStorage: IStorage | undefined;\n\tprivate applicationStorageDatabase: IIndexedDBStorageDatabase | undefined;\n\tprivate readonly applicationStoragePromise = new DeferredPromise<{ indexedDb: IIndexedDBStorageDatabase; storage: IStorage }>();\n\n\tprivate profileStorage: IStorage | undefined;\n\tprivate profileStorageDatabase: IIndexedDBStorageDatabase | undefined;\n\tprivate profileStorageProfile: IUserDataProfile;\n\tprivate readonly profileStorageDisposables = this._register(new DisposableStore());\n\n\tprivate workspaceStorage: IStorage | undefined;\n\tprivate workspaceStorageDatabase: IIndexedDBStorageDatabase | undefined;\n\n\tget hasPendingUpdate(): boolean {\n\t\treturn Boolean(\n\t\t\tthis.applicationStorageDatabase?.hasPendingUpdate ||\n\t\t\tthis.profileStorageDatabase?.hasPendingUpdate ||\n\t\t\tthis.workspaceStorageDatabase?.hasPendingUpdate\n\t\t);\n\t}\n\n\tconstructor(\n\t\tprivate readonly workspace: IAnyWorkspaceIdentifier,\n\t\tprivate readonly userDataProfileService: IUserDataProfileService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper({ flushInterval: BrowserStorageService.BROWSER_DEFAULT_FLUSH_INTERVAL });\n\n\t\tthis.profileStorageProfile = this.userDataProfileService.currentProfile;\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.userDataProfileService.onDidChangeCurrentProfile(e => e.join(this.switchToProfile(e.profile))));\n\t}\n\n\tprotected async doInitialize(): Promise<void> {\n\n\t\t// Init storages\n\t\tawait Promises.settled([\n\t\t\tthis.createApplicationStorage(),\n\t\t\tthis.createProfileStorage(this.profileStorageProfile),\n\t\t\tthis.createWorkspaceStorage()\n\t\t]);\n\t}\n\n\tprivate async createApplicationStorage(): Promise<void> {\n\t\tconst applicationStorageIndexedDB = await IndexedDBStorageDatabase.createApplicationStorage(this.logService);\n\n\t\tthis.applicationStorageDatabase = this._register(applicationStorageIndexedDB);\n\t\tthis.applicationStorage = this._register(new Storage(this.applicationStorageDatabase));\n\n\t\tthis._register(this.applicationStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.APPLICATION, e)));\n\n\t\tawait this.applicationStorage.init();\n\n\t\tthis.updateIsNew(this.applicationStorage);\n\n\t\tthis.applicationStoragePromise.complete({ indexedDb: applicationStorageIndexedDB, storage: this.applicationStorage });\n\t}\n\n\tprivate async createProfileStorage(profile: IUserDataProfile): Promise<void> {\n\n\t\t// First clear any previously associated disposables\n\t\tthis.profileStorageDisposables.clear();\n\n\t\t// Remember profile associated to profile storage\n\t\tthis.profileStorageProfile = profile;\n\n\t\tif (isProfileUsingDefaultStorage(this.profileStorageProfile)) {\n\n\t\t\t// If we are using default profile storage, the profile storage is\n\t\t\t// actually the same as application storage. As such we\n\t\t\t// avoid creating the storage library a second time on\n\t\t\t// the same DB.\n\n\t\t\tconst { indexedDb: applicationStorageIndexedDB, storage: applicationStorage } = await this.applicationStoragePromise.p;\n\n\t\t\tthis.profileStorageDatabase = applicationStorageIndexedDB;\n\t\t\tthis.profileStorage = applicationStorage;\n\n\t\t\tthis.profileStorageDisposables.add(this.profileStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.PROFILE, e)));\n\t\t} else {\n\t\t\tconst profileStorageIndexedDB = await IndexedDBStorageDatabase.createProfileStorage(this.profileStorageProfile, this.logService);\n\n\t\t\tthis.profileStorageDatabase = this.profileStorageDisposables.add(profileStorageIndexedDB);\n\t\t\tthis.profileStorage = this.profileStorageDisposables.add(new Storage(this.profileStorageDatabase));\n\n\t\t\tthis.profileStorageDisposables.add(this.profileStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.PROFILE, e)));\n\n\t\t\tawait this.profileStorage.init();\n\n\t\t\tthis.updateIsNew(this.profileStorage);\n\t\t}\n\t}\n\n\tprivate async createWorkspaceStorage(): Promise<void> {\n\t\tconst workspaceStorageIndexedDB = await IndexedDBStorageDatabase.createWorkspaceStorage(this.workspace.id, this.logService);\n\n\t\tthis.workspaceStorageDatabase = this._register(workspaceStorageIndexedDB);\n\t\tthis.workspaceStorage = this._register(new Storage(this.workspaceStorageDatabase));\n\n\t\tthis._register(this.workspaceStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.WORKSPACE, e)));\n\n\t\tawait this.workspaceStorage.init();\n\n\t\tthis.updateIsNew(this.workspaceStorage);\n\t}\n\n\tprivate updateIsNew(storage: IStorage): void {\n\t\tconst firstOpen = storage.getBoolean(IS_NEW_KEY);\n\t\tif (firstOpen === undefined) {\n\t\t\tstorage.set(IS_NEW_KEY, true);\n\t\t} else if (firstOpen) {\n\t\t\tstorage.set(IS_NEW_KEY, false);\n\t\t}\n\t}\n\n\tprotected getStorage(scope: StorageScope): IStorage | undefined {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationStorage;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileStorage;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceStorage;\n\t\t}\n\t}\n\n\tprotected getLogDetails(scope: StorageScope): string | undefined {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationStorageDatabase?.name;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileStorageDatabase?.name;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceStorageDatabase?.name;\n\t\t}\n\t}\n\n\tprotected async switchToProfile(toProfile: IUserDataProfile): Promise<void> {\n\t\tif (!this.canSwitchProfile(this.profileStorageProfile, toProfile)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldProfileStorage = assertReturnsDefined(this.profileStorage);\n\t\tconst oldItems = oldProfileStorage.items;\n\n\t\t// Close old profile storage but only if this is\n\t\t// different from application storage!\n\t\tif (oldProfileStorage !== this.applicationStorage) {\n\t\t\tawait oldProfileStorage.close();\n\t\t}\n\n\t\t// Create new profile storage & init\n\t\tawait this.createProfileStorage(toProfile);\n\n\t\t// Handle data switch and eventing\n\t\tthis.switchData(oldItems, assertReturnsDefined(this.profileStorage), StorageScope.PROFILE);\n\t}\n\n\tprotected async switchToWorkspace(toWorkspace: IAnyWorkspaceIdentifier, preserveData: boolean): Promise<void> {\n\t\tthrow new Error('Migrating storage is currently unsupported in Web');\n\t}\n\n\tprotected override shouldFlushWhenIdle(): boolean {\n\t\t// this flush() will potentially cause new state to be stored\n\t\t// since new state will only be created while the document\n\t\t// has focus, one optimization is to not run this when the\n\t\t// document has no focus, assuming that state has not changed\n\t\t//\n\t\t// another optimization is to not collect more state if we\n\t\t// have a pending update already running which indicates\n\t\t// that the connection is either slow or disconnected and\n\t\t// thus unhealthy.\n\t\treturn getActiveWindow().document.hasFocus() && !this.hasPendingUpdate;\n\t}\n\n\tclose(): void {\n\n\t\t// Safari: there is an issue where the page can hang on load when\n\t\t// a previous session has kept IndexedDB transactions running.\n\t\t// The only fix seems to be to cancel any pending transactions\n\t\t// (https://github.com/microsoft/vscode/issues/136295)\n\t\t//\n\t\t// On all other browsers, we keep the databases opened because\n\t\t// we expect data to be written when the unload happens.\n\t\tif (isSafari) {\n\t\t\tthis.applicationStorage?.close();\n\t\t\tthis.profileStorageDatabase?.close();\n\t\t\tthis.workspaceStorageDatabase?.close();\n\t\t}\n\n\t\t// Always dispose to ensure that no timeouts or callbacks\n\t\t// get triggered in this phase.\n\t\tthis.dispose();\n\t}\n\n\tasync clear(): Promise<void> {\n\n\t\t// Clear key/values\n\t\tfor (const scope of [StorageScope.APPLICATION, StorageScope.PROFILE, StorageScope.WORKSPACE]) {\n\t\t\tfor (const target of [StorageTarget.USER, StorageTarget.MACHINE]) {\n\t\t\t\tfor (const key of this.keys(scope, target)) {\n\t\t\t\t\tthis.remove(key, scope);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait this.getStorage(scope)?.whenFlushed();\n\t\t}\n\n\t\t// Clear databases\n\t\tawait Promises.settled([\n\t\t\tthis.applicationStorageDatabase?.clear() ?? Promise.resolve(),\n\t\t\tthis.profileStorageDatabase?.clear() ?? Promise.resolve(),\n\t\t\tthis.workspaceStorageDatabase?.clear() ?? Promise.resolve()\n\t\t]);\n\t}\n\n\thasScope(scope: IAnyWorkspaceIdentifier | IUserDataProfile): boolean {\n\t\tif (isUserDataProfile(scope)) {\n\t\t\treturn this.profileStorageProfile.id === scope.id;\n\t\t}\n\n\t\treturn this.workspace.id === scope.id;\n\t}\n}\n\ninterface IIndexedDBStorageDatabase extends IStorageDatabase, IDisposable {\n\n\t/**\n\t * Name of the database.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Whether an update in the DB is currently pending\n\t * (either update or delete operation).\n\t */\n\treadonly hasPendingUpdate: boolean;\n\n\t/**\n\t * For testing only.\n\t */\n\tclear(): Promise<void>;\n}\n\nclass InMemoryIndexedDBStorageDatabase extends InMemoryStorageDatabase implements IIndexedDBStorageDatabase {\n\n\treadonly hasPendingUpdate = false;\n\treadonly name = 'in-memory-indexedb-storage';\n\n\tasync clear(): Promise<void> {\n\t\t(await this.getItems()).clear();\n\t}\n\n\tdispose(): void {\n\t\t// No-op\n\t}\n}\n\ninterface IndexedDBStorageDatabaseOptions {\n\tid: string;\n\tbroadcastChanges?: boolean;\n}\n\nexport class IndexedDBStorageDatabase extends Disposable implements IIndexedDBStorageDatabase {\n\n\tstatic async createApplicationStorage(logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\treturn IndexedDBStorageDatabase.create({ id: 'global', broadcastChanges: true }, logService);\n\t}\n\n\tstatic async createProfileStorage(profile: IUserDataProfile, logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\treturn IndexedDBStorageDatabase.create({ id: `global-${profile.id}`, broadcastChanges: true }, logService);\n\t}\n\n\tstatic async createWorkspaceStorage(workspaceId: string, logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\treturn IndexedDBStorageDatabase.create({ id: workspaceId }, logService);\n\t}\n\n\tstatic async create(options: IndexedDBStorageDatabaseOptions, logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\ttry {\n\t\t\tconst database = new IndexedDBStorageDatabase(options, logService);\n\t\t\tawait database.whenConnected;\n\n\t\t\treturn database;\n\t\t} catch (error) {\n\t\t\tlogService.error(`[IndexedDB Storage ${options.id}] create(): ${toErrorMessage(error, true)}`);\n\n\t\t\treturn new InMemoryIndexedDBStorageDatabase();\n\t\t}\n\t}\n\n\tprivate static readonly STORAGE_DATABASE_PREFIX = 'vscode-web-state-db-';\n\tprivate static readonly STORAGE_OBJECT_STORE = 'ItemTable';\n\n\tprivate readonly _onDidChangeItemsExternal = this._register(new Emitter<IStorageItemsChangeEvent>());\n\treadonly onDidChangeItemsExternal = this._onDidChangeItemsExternal.event;\n\n\tprivate broadcastChannel: BroadcastDataChannel<IStorageItemsChangeEvent> | undefined;\n\n\tprivate pendingUpdate: Promise<boolean> | undefined = undefined;\n\tget hasPendingUpdate(): boolean { return !!this.pendingUpdate; }\n\n\treadonly name: string;\n\tprivate readonly whenConnected: Promise<IndexedDB>;\n\n\tprivate constructor(\n\t\toptions: IndexedDBStorageDatabaseOptions,\n\t\tprivate readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.name = `${IndexedDBStorageDatabase.STORAGE_DATABASE_PREFIX}${options.id}`;\n\t\tthis.broadcastChannel = options.broadcastChanges ? this._register(new BroadcastDataChannel<IStorageItemsChangeEvent>(this.name)) : undefined;\n\n\t\tthis.whenConnected = this.connect();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Check for storage change events from other\n\t\t// windows/tabs via `BroadcastChannel` mechanisms.\n\t\tif (this.broadcastChannel) {\n\t\t\tthis._register(this.broadcastChannel.onDidReceiveData(data => {\n\t\t\t\tif (isStorageItemsChangeEvent(data)) {\n\t\t\t\t\tthis._onDidChangeItemsExternal.fire(data);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate async connect(): Promise<IndexedDB> {\n\t\ttry {\n\t\t\treturn await IndexedDB.create(this.name, undefined, [IndexedDBStorageDatabase.STORAGE_OBJECT_STORE]);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`[IndexedDB Storage ${this.name}] connect() error: ${toErrorMessage(error)}`);\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\tconst db = await this.whenConnected;\n\n\t\tfunction isValid(value: unknown): value is string {\n\t\t\treturn typeof value === 'string';\n\t\t}\n\n\t\treturn db.getKeyValues<string>(IndexedDBStorageDatabase.STORAGE_OBJECT_STORE, isValid);\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\n\t\t// Run the update\n\t\tlet didUpdate = false;\n\t\tthis.pendingUpdate = this.doUpdateItems(request);\n\t\ttry {\n\t\t\tdidUpdate = await this.pendingUpdate;\n\t\t} finally {\n\t\t\tthis.pendingUpdate = undefined;\n\t\t}\n\n\t\t// Broadcast changes to other windows/tabs if enabled\n\t\t// and only if we actually did update storage items.\n\t\tif (this.broadcastChannel && didUpdate) {\n\t\t\tconst event: IStorageItemsChangeEvent = {\n\t\t\t\tchanged: request.insert,\n\t\t\t\tdeleted: request.delete\n\t\t\t};\n\n\t\t\tthis.broadcastChannel.postData(event);\n\t\t}\n\t}\n\n\tprivate async doUpdateItems(request: IUpdateRequest): Promise<boolean> {\n\n\t\t// Return early if the request is empty\n\t\tconst toInsert = request.insert;\n\t\tconst toDelete = request.delete;\n\t\tif ((!toInsert && !toDelete) || (toInsert?.size === 0 && toDelete?.size === 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst db = await this.whenConnected;\n\n\t\t// Update `ItemTable` with inserts and/or deletes\n\t\tawait db.runInTransaction(IndexedDBStorageDatabase.STORAGE_OBJECT_STORE, 'readwrite', objectStore => {\n\t\t\tconst requests: IDBRequest[] = [];\n\n\t\t\t// Inserts\n\t\t\tif (toInsert) {\n\t\t\t\tfor (const [key, value] of toInsert) {\n\t\t\t\t\trequests.push(objectStore.put(value, key));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Deletes\n\t\t\tif (toDelete) {\n\t\t\t\tfor (const key of toDelete) {\n\t\t\t\t\trequests.push(objectStore.delete(key));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn requests;\n\t\t});\n\n\t\treturn true;\n\t}\n\n\tasync optimize(): Promise<void> {\n\t\t// not suported in IndexedDB\n\t}\n\n\tasync close(): Promise<void> {\n\t\tconst db = await this.whenConnected;\n\n\t\t// Wait for pending updates to having finished\n\t\tawait this.pendingUpdate;\n\n\t\t// Finally, close IndexedDB\n\t\treturn db.close();\n\t}\n\n\tasync clear(): Promise<void> {\n\t\tconst db = await this.whenConnected;\n\n\t\tawait db.runInTransaction(IndexedDBStorageDatabase.STORAGE_OBJECT_STORE, 'readwrite', objectStore => objectStore.clear());\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BroadcastDataChannel } from '../../../../base/browser/broadcast.js';\nimport { isSafari } from '../../../../base/browser/browser.js';\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { IndexedDB } from '../../../../base/browser/indexedDB.js';\nimport { DeferredPromise, Promises } from '../../../../base/common/async.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable } from '../../../../base/common/lifecycle.js';\nimport { assertReturnsDefined } from '../../../../base/common/types.js';\nimport { InMemoryStorageDatabase, isStorageItemsChangeEvent, IStorage, IStorageDatabase, IStorageItemsChangeEvent, IUpdateRequest, Storage } from '../../../../base/parts/storage/common/storage.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { AbstractStorageService, isProfileUsingDefaultStorage, IS_NEW_KEY, StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';\nimport { isUserDataProfile, IUserDataProfile } from '../../../../platform/userDataProfile/common/userDataProfile.js';\nimport { IAnyWorkspaceIdentifier } from '../../../../platform/workspace/common/workspace.js';\nimport { IUserDataProfileService } from '../../userDataProfile/common/userDataProfile.js';\n\nexport class BrowserStorageService extends AbstractStorageService {\n\n\tprivate static BROWSER_DEFAULT_FLUSH_INTERVAL = 5 * 1000; // every 5s because async operations are not permitted on shutdown\n\n\tprivate applicationStorage: IStorage | undefined;\n\tprivate applicationStorageDatabase: IIndexedDBStorageDatabase | undefined;\n\tprivate readonly applicationStoragePromise = new DeferredPromise<{ indexedDb: IIndexedDBStorageDatabase; storage: IStorage }>();\n\n\tprivate profileStorage: IStorage | undefined;\n\tprivate profileStorageDatabase: IIndexedDBStorageDatabase | undefined;\n\tprivate profileStorageProfile: IUserDataProfile;\n\tprivate readonly profileStorageDisposables = this._register(new DisposableStore());\n\n\tprivate workspaceStorage: IStorage | undefined;\n\tprivate workspaceStorageDatabase: IIndexedDBStorageDatabase | undefined;\n\n\tget hasPendingUpdate(): boolean {\n\t\treturn Boolean(\n\t\t\tthis.applicationStorageDatabase?.hasPendingUpdate ||\n\t\t\tthis.profileStorageDatabase?.hasPendingUpdate ||\n\t\t\tthis.workspaceStorageDatabase?.hasPendingUpdate\n\t\t);\n\t}\n\n\tconstructor(\n\t\tprivate readonly workspace: IAnyWorkspaceIdentifier,\n\t\tprivate readonly userDataProfileService: IUserDataProfileService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper({ flushInterval: BrowserStorageService.BROWSER_DEFAULT_FLUSH_INTERVAL });\n\n\t\tthis.profileStorageProfile = this.userDataProfileService.currentProfile;\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.userDataProfileService.onDidChangeCurrentProfile(e => e.join(this.switchToProfile(e.profile))));\n\t}\n\n\tprotected async doInitialize(): Promise<void> {\n\n\t\t// Init storages\n\t\tawait Promises.settled([\n\t\t\tthis.createApplicationStorage(),\n\t\t\tthis.createProfileStorage(this.profileStorageProfile),\n\t\t\tthis.createWorkspaceStorage()\n\t\t]);\n\t}\n\n\tprivate async createApplicationStorage(): Promise<void> {\n\t\tconst applicationStorageIndexedDB = await IndexedDBStorageDatabase.createApplicationStorage(this.logService);\n\n\t\tthis.applicationStorageDatabase = this._register(applicationStorageIndexedDB);\n\t\tthis.applicationStorage = this._register(new Storage(this.applicationStorageDatabase));\n\n\t\tthis._register(this.applicationStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.APPLICATION, e)));\n\n\t\tawait this.applicationStorage.init();\n\n\t\tthis.updateIsNew(this.applicationStorage);\n\n\t\tthis.applicationStoragePromise.complete({ indexedDb: applicationStorageIndexedDB, storage: this.applicationStorage });\n\t}\n\n\tprivate async createProfileStorage(profile: IUserDataProfile): Promise<void> {\n\n\t\t// First clear any previously associated disposables\n\t\tthis.profileStorageDisposables.clear();\n\n\t\t// Remember profile associated to profile storage\n\t\tthis.profileStorageProfile = profile;\n\n\t\tif (isProfileUsingDefaultStorage(this.profileStorageProfile)) {\n\n\t\t\t// If we are using default profile storage, the profile storage is\n\t\t\t// actually the same as application storage. As such we\n\t\t\t// avoid creating the storage library a second time on\n\t\t\t// the same DB.\n\n\t\t\tconst { indexedDb: applicationStorageIndexedDB, storage: applicationStorage } = await this.applicationStoragePromise.p;\n\n\t\t\tthis.profileStorageDatabase = applicationStorageIndexedDB;\n\t\t\tthis.profileStorage = applicationStorage;\n\n\t\t\tthis.profileStorageDisposables.add(this.profileStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.PROFILE, e)));\n\t\t} else {\n\t\t\tconst profileStorageIndexedDB = await IndexedDBStorageDatabase.createProfileStorage(this.profileStorageProfile, this.logService);\n\n\t\t\tthis.profileStorageDatabase = this.profileStorageDisposables.add(profileStorageIndexedDB);\n\t\t\tthis.profileStorage = this.profileStorageDisposables.add(new Storage(this.profileStorageDatabase));\n\n\t\t\tthis.profileStorageDisposables.add(this.profileStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.PROFILE, e)));\n\n\t\t\tawait this.profileStorage.init();\n\n\t\t\tthis.updateIsNew(this.profileStorage);\n\t\t}\n\t}\n\n\tprivate async createWorkspaceStorage(): Promise<void> {\n\t\tconst workspaceStorageIndexedDB = await IndexedDBStorageDatabase.createWorkspaceStorage(this.workspace.id, this.logService);\n\n\t\tthis.workspaceStorageDatabase = this._register(workspaceStorageIndexedDB);\n\t\tthis.workspaceStorage = this._register(new Storage(this.workspaceStorageDatabase));\n\n\t\tthis._register(this.workspaceStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.WORKSPACE, e)));\n\n\t\tawait this.workspaceStorage.init();\n\n\t\tthis.updateIsNew(this.workspaceStorage);\n\t}\n\n\tprivate updateIsNew(storage: IStorage): void {\n\t\tconst firstOpen = storage.getBoolean(IS_NEW_KEY);\n\t\tif (firstOpen === undefined) {\n\t\t\tstorage.set(IS_NEW_KEY, true);\n\t\t} else if (firstOpen) {\n\t\t\tstorage.set(IS_NEW_KEY, false);\n\t\t}\n\t}\n\n\tprotected getStorage(scope: StorageScope): IStorage | undefined {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationStorage;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileStorage;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceStorage;\n\t\t}\n\t}\n\n\tprotected getLogDetails(scope: StorageScope): string | undefined {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationStorageDatabase?.name;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileStorageDatabase?.name;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceStorageDatabase?.name;\n\t\t}\n\t}\n\n\tprotected async switchToProfile(toProfile: IUserDataProfile): Promise<void> {\n\t\tif (!this.canSwitchProfile(this.profileStorageProfile, toProfile)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldProfileStorage = assertReturnsDefined(this.profileStorage);\n\t\tconst oldItems = oldProfileStorage.items;\n\n\t\t// Close old profile storage but only if this is\n\t\t// different from application storage!\n\t\tif (oldProfileStorage !== this.applicationStorage) {\n\t\t\tawait oldProfileStorage.close();\n\t\t}\n\n\t\t// Create new profile storage & init\n\t\tawait this.createProfileStorage(toProfile);\n\n\t\t// Handle data switch and eventing\n\t\tthis.switchData(oldItems, assertReturnsDefined(this.profileStorage), StorageScope.PROFILE);\n\t}\n\n\tprotected async switchToWorkspace(toWorkspace: IAnyWorkspaceIdentifier, preserveData: boolean): Promise<void> {\n\t\tthrow new Error('Migrating storage is currently unsupported in Web');\n\t}\n\n\tprotected override shouldFlushWhenIdle(): boolean {\n\t\t// this flush() will potentially cause new state to be stored\n\t\t// since new state will only be created while the document\n\t\t// has focus, one optimization is to not run this when the\n\t\t// document has no focus, assuming that state has not changed\n\t\t//\n\t\t// another optimization is to not collect more state if we\n\t\t// have a pending update already running which indicates\n\t\t// that the connection is either slow or disconnected and\n\t\t// thus unhealthy.\n\t\treturn getActiveWindow().document.hasFocus() && !this.hasPendingUpdate;\n\t}\n\n\tclose(): void {\n\n\t\t// Safari: there is an issue where the page can hang on load when\n\t\t// a previous session has kept IndexedDB transactions running.\n\t\t// The only fix seems to be to cancel any pending transactions\n\t\t// (https://github.com/microsoft/vscode/issues/136295)\n\t\t//\n\t\t// On all other browsers, we keep the databases opened because\n\t\t// we expect data to be written when the unload happens.\n\t\tif (isSafari) {\n\t\t\tthis.applicationStorage?.close();\n\t\t\tthis.profileStorageDatabase?.close();\n\t\t\tthis.workspaceStorageDatabase?.close();\n\t\t}\n\n\t\t// Always dispose to ensure that no timeouts or callbacks\n\t\t// get triggered in this phase.\n\t\tthis.dispose();\n\t}\n\n\tasync clear(): Promise<void> {\n\n\t\t// Clear key/values\n\t\tfor (const scope of [StorageScope.APPLICATION, StorageScope.PROFILE, StorageScope.WORKSPACE]) {\n\t\t\tfor (const target of [StorageTarget.USER, StorageTarget.MACHINE]) {\n\t\t\t\tfor (const key of this.keys(scope, target)) {\n\t\t\t\t\tthis.remove(key, scope);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait this.getStorage(scope)?.whenFlushed();\n\t\t}\n\n\t\t// Clear databases\n\t\tawait Promises.settled([\n\t\t\tthis.applicationStorageDatabase?.clear() ?? Promise.resolve(),\n\t\t\tthis.profileStorageDatabase?.clear() ?? Promise.resolve(),\n\t\t\tthis.workspaceStorageDatabase?.clear() ?? Promise.resolve()\n\t\t]);\n\t}\n\n\thasScope(scope: IAnyWorkspaceIdentifier | IUserDataProfile): boolean {\n\t\tif (isUserDataProfile(scope)) {\n\t\t\treturn this.profileStorageProfile.id === scope.id;\n\t\t}\n\n\t\treturn this.workspace.id === scope.id;\n\t}\n}\n\ninterface IIndexedDBStorageDatabase extends IStorageDatabase, IDisposable {\n\n\t/**\n\t * Name of the database.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Whether an update in the DB is currently pending\n\t * (either update or delete operation).\n\t */\n\treadonly hasPendingUpdate: boolean;\n\n\t/**\n\t * For testing only.\n\t */\n\tclear(): Promise<void>;\n}\n\nclass InMemoryIndexedDBStorageDatabase extends InMemoryStorageDatabase implements IIndexedDBStorageDatabase {\n\n\treadonly hasPendingUpdate = false;\n\treadonly name = 'in-memory-indexedb-storage';\n\n\tasync clear(): Promise<void> {\n\t\t(await this.getItems()).clear();\n\t}\n\n\tdispose(): void {\n\t\t// No-op\n\t}\n}\n\ninterface IndexedDBStorageDatabaseOptions {\n\tid: string;\n\tbroadcastChanges?: boolean;\n}\n\nexport class IndexedDBStorageDatabase extends Disposable implements IIndexedDBStorageDatabase {\n\n\tstatic async createApplicationStorage(logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\treturn IndexedDBStorageDatabase.create({ id: 'global', broadcastChanges: true }, logService);\n\t}\n\n\tstatic async createProfileStorage(profile: IUserDataProfile, logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\treturn IndexedDBStorageDatabase.create({ id: `global-${profile.id}`, broadcastChanges: true }, logService);\n\t}\n\n\tstatic async createWorkspaceStorage(workspaceId: string, logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\treturn IndexedDBStorageDatabase.create({ id: workspaceId }, logService);\n\t}\n\n\tstatic async create(options: IndexedDBStorageDatabaseOptions, logService: ILogService): Promise<IIndexedDBStorageDatabase> {\n\t\ttry {\n\t\t\tconst database = new IndexedDBStorageDatabase(options, logService);\n\t\t\tawait database.whenConnected;\n\n\t\t\treturn database;\n\t\t} catch (error) {\n\t\t\tlogService.error(`[IndexedDB Storage ${options.id}] create(): ${toErrorMessage(error, true)}`);\n\n\t\t\treturn new InMemoryIndexedDBStorageDatabase();\n\t\t}\n\t}\n\n\tprivate static readonly STORAGE_DATABASE_PREFIX = 'vscode-web-state-db-';\n\tprivate static readonly STORAGE_OBJECT_STORE = 'ItemTable';\n\n\tprivate readonly _onDidChangeItemsExternal = this._register(new Emitter<IStorageItemsChangeEvent>());\n\treadonly onDidChangeItemsExternal = this._onDidChangeItemsExternal.event;\n\n\tprivate broadcastChannel: BroadcastDataChannel<IStorageItemsChangeEvent> | undefined;\n\n\tprivate pendingUpdate: Promise<boolean> | undefined = undefined;\n\tget hasPendingUpdate(): boolean { return !!this.pendingUpdate; }\n\n\treadonly name: string;\n\tprivate readonly whenConnected: Promise<IndexedDB>;\n\n\tprivate constructor(\n\t\toptions: IndexedDBStorageDatabaseOptions,\n\t\tprivate readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.name = `${IndexedDBStorageDatabase.STORAGE_DATABASE_PREFIX}${options.id}`;\n\t\tthis.broadcastChannel = options.broadcastChanges ? this._register(new BroadcastDataChannel<IStorageItemsChangeEvent>(this.name)) : undefined;\n\n\t\tthis.whenConnected = this.connect();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Check for storage change events from other\n\t\t// windows/tabs via `BroadcastChannel` mechanisms.\n\t\tif (this.broadcastChannel) {\n\t\t\tthis._register(this.broadcastChannel.onDidReceiveData(data => {\n\t\t\t\tif (isStorageItemsChangeEvent(data)) {\n\t\t\t\t\tthis._onDidChangeItemsExternal.fire(data);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate async connect(): Promise<IndexedDB> {\n\t\ttry {\n\t\t\treturn await IndexedDB.create(this.name, undefined, [IndexedDBStorageDatabase.STORAGE_OBJECT_STORE]);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`[IndexedDB Storage ${this.name}] connect() error: ${toErrorMessage(error)}`);\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\tconst db = await this.whenConnected;\n\n\t\tfunction isValid(value: unknown): value is string {\n\t\t\treturn typeof value === 'string';\n\t\t}\n\n\t\treturn db.getKeyValues<string>(IndexedDBStorageDatabase.STORAGE_OBJECT_STORE, isValid);\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\n\t\t// Run the update\n\t\tlet didUpdate = false;\n\t\tthis.pendingUpdate = this.doUpdateItems(request);\n\t\ttry {\n\t\t\tdidUpdate = await this.pendingUpdate;\n\t\t} finally {\n\t\t\tthis.pendingUpdate = undefined;\n\t\t}\n\n\t\t// Broadcast changes to other windows/tabs if enabled\n\t\t// and only if we actually did update storage items.\n\t\tif (this.broadcastChannel && didUpdate) {\n\t\t\tconst event: IStorageItemsChangeEvent = {\n\t\t\t\tchanged: request.insert,\n\t\t\t\tdeleted: request.delete\n\t\t\t};\n\n\t\t\tthis.broadcastChannel.postData(event);\n\t\t}\n\t}\n\n\tprivate async doUpdateItems(request: IUpdateRequest): Promise<boolean> {\n\n\t\t// Return early if the request is empty\n\t\tconst toInsert = request.insert;\n\t\tconst toDelete = request.delete;\n\t\tif ((!toInsert && !toDelete) || (toInsert?.size === 0 && toDelete?.size === 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst db = await this.whenConnected;\n\n\t\t// Update `ItemTable` with inserts and/or deletes\n\t\tawait db.runInTransaction(IndexedDBStorageDatabase.STORAGE_OBJECT_STORE, 'readwrite', objectStore => {\n\t\t\tconst requests: IDBRequest[] = [];\n\n\t\t\t// Inserts\n\t\t\tif (toInsert) {\n\t\t\t\tfor (const [key, value] of toInsert) {\n\t\t\t\t\trequests.push(objectStore.put(value, key));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Deletes\n\t\t\tif (toDelete) {\n\t\t\t\tfor (const key of toDelete) {\n\t\t\t\t\trequests.push(objectStore.delete(key));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn requests;\n\t\t});\n\n\t\treturn true;\n\t}\n\n\tasync optimize(): Promise<void> {\n\t\t// not suported in IndexedDB\n\t}\n\n\tasync close(): Promise<void> {\n\t\tconst db = await this.whenConnected;\n\n\t\t// Wait for pending updates to having finished\n\t\tawait this.pendingUpdate;\n\n\t\t// Finally, close IndexedDB\n\t\treturn db.close();\n\t}\n\n\tasync clear(): Promise<void> {\n\t\tconst db = await this.whenConnected;\n\n\t\tawait db.runInTransaction(IndexedDBStorageDatabase.STORAGE_OBJECT_STORE, 'readwrite', objectStore => objectStore.clear());\n\t}\n}\n"]}