{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/lifecycle/common/lifecycleService.ts","vs/workbench/services/lifecycle/common/lifecycleService.ts"],"names":[],"mappings":"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","file":"lifecycleService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Barrier } from '../../../../base/common/async.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ILifecycleService, WillShutdownEvent, StartupKind, LifecyclePhase, LifecyclePhaseToString, ShutdownReason, BeforeShutdownErrorEvent, InternalBeforeShutdownEvent } from './lifecycle.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { mark } from '../../../../base/common/performance.js';\nimport { IStorageService, StorageScope, StorageTarget, WillSaveStateReason } from '../../../../platform/storage/common/storage.js';\n\nexport abstract class AbstractLifecycleService extends Disposable implements ILifecycleService {\n\n\tprivate static readonly LAST_SHUTDOWN_REASON_KEY = 'lifecyle.lastShutdownReason';\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprotected readonly _onBeforeShutdown = this._register(new Emitter<InternalBeforeShutdownEvent>());\n\treadonly onBeforeShutdown = this._onBeforeShutdown.event;\n\n\tprotected readonly _onWillShutdown = this._register(new Emitter<WillShutdownEvent>());\n\treadonly onWillShutdown = this._onWillShutdown.event;\n\n\tprotected readonly _onDidShutdown = this._register(new Emitter<void>());\n\treadonly onDidShutdown = this._onDidShutdown.event;\n\n\tprotected readonly _onBeforeShutdownError = this._register(new Emitter<BeforeShutdownErrorEvent>());\n\treadonly onBeforeShutdownError = this._onBeforeShutdownError.event;\n\n\tprotected readonly _onShutdownVeto = this._register(new Emitter<void>());\n\treadonly onShutdownVeto = this._onShutdownVeto.event;\n\n\tprivate _startupKind: StartupKind;\n\tget startupKind(): StartupKind { return this._startupKind; }\n\n\tprivate _phase = LifecyclePhase.Starting;\n\tget phase(): LifecyclePhase { return this._phase; }\n\n\tprotected _willShutdown = false;\n\tget willShutdown(): boolean { return this._willShutdown; }\n\n\tprivate readonly phaseWhen = new Map<LifecyclePhase, Barrier>();\n\n\tprotected shutdownReason: ShutdownReason | undefined;\n\n\tconstructor(\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IStorageService protected readonly storageService: IStorageService\n\t) {\n\t\tsuper();\n\n\t\t// Resolve startup kind\n\t\tthis._startupKind = this.resolveStartupKind();\n\n\t\t// Save shutdown reason to retrieve on next startup\n\t\tthis._register(this.storageService.onWillSaveState(e => {\n\t\t\tif (e.reason === WillSaveStateReason.SHUTDOWN) {\n\t\t\t\tthis.storageService.store(AbstractLifecycleService.LAST_SHUTDOWN_REASON_KEY, this.shutdownReason, StorageScope.WORKSPACE, StorageTarget.MACHINE);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate resolveStartupKind(): StartupKind {\n\t\tconst startupKind = this.doResolveStartupKind() ?? StartupKind.NewWindow;\n\t\tthis.logService.trace(`[lifecycle] starting up (startup kind: ${startupKind})`);\n\n\t\treturn startupKind;\n\t}\n\n\tprotected doResolveStartupKind(): StartupKind | undefined {\n\n\t\t// Retrieve and reset last shutdown reason\n\t\tconst lastShutdownReason = this.storageService.getNumber(AbstractLifecycleService.LAST_SHUTDOWN_REASON_KEY, StorageScope.WORKSPACE);\n\t\tthis.storageService.remove(AbstractLifecycleService.LAST_SHUTDOWN_REASON_KEY, StorageScope.WORKSPACE);\n\n\t\t// Convert into startup kind\n\t\tlet startupKind: StartupKind | undefined = undefined;\n\t\tswitch (lastShutdownReason) {\n\t\t\tcase ShutdownReason.RELOAD:\n\t\t\t\tstartupKind = StartupKind.ReloadedWindow;\n\t\t\t\tbreak;\n\t\t\tcase ShutdownReason.LOAD:\n\t\t\t\tstartupKind = StartupKind.ReopenedWindow;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn startupKind;\n\t}\n\n\tset phase(value: LifecyclePhase) {\n\t\tif (value < this.phase) {\n\t\t\tthrow new Error('Lifecycle cannot go backwards');\n\t\t}\n\n\t\tif (this._phase === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.logService.trace(`lifecycle: phase changed (value: ${value})`);\n\n\t\tthis._phase = value;\n\t\tmark(`code/LifecyclePhase/${LifecyclePhaseToString(value)}`);\n\n\t\tconst barrier = this.phaseWhen.get(this._phase);\n\t\tif (barrier) {\n\t\t\tbarrier.open();\n\t\t\tthis.phaseWhen.delete(this._phase);\n\t\t}\n\t}\n\n\tasync when(phase: LifecyclePhase): Promise<void> {\n\t\tif (phase <= this._phase) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet barrier = this.phaseWhen.get(phase);\n\t\tif (!barrier) {\n\t\t\tbarrier = new Barrier();\n\t\t\tthis.phaseWhen.set(phase, barrier);\n\t\t}\n\n\t\tawait barrier.wait();\n\t}\n\n\t/**\n\t * Subclasses to implement the explicit shutdown method.\n\t */\n\tabstract shutdown(): Promise<void>;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Barrier } from '../../../../base/common/async.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ILifecycleService, WillShutdownEvent, StartupKind, LifecyclePhase, LifecyclePhaseToString, ShutdownReason, BeforeShutdownErrorEvent, InternalBeforeShutdownEvent } from './lifecycle.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { mark } from '../../../../base/common/performance.js';\nimport { IStorageService, StorageScope, StorageTarget, WillSaveStateReason } from '../../../../platform/storage/common/storage.js';\n\nexport abstract class AbstractLifecycleService extends Disposable implements ILifecycleService {\n\n\tprivate static readonly LAST_SHUTDOWN_REASON_KEY = 'lifecyle.lastShutdownReason';\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprotected readonly _onBeforeShutdown = this._register(new Emitter<InternalBeforeShutdownEvent>());\n\treadonly onBeforeShutdown = this._onBeforeShutdown.event;\n\n\tprotected readonly _onWillShutdown = this._register(new Emitter<WillShutdownEvent>());\n\treadonly onWillShutdown = this._onWillShutdown.event;\n\n\tprotected readonly _onDidShutdown = this._register(new Emitter<void>());\n\treadonly onDidShutdown = this._onDidShutdown.event;\n\n\tprotected readonly _onBeforeShutdownError = this._register(new Emitter<BeforeShutdownErrorEvent>());\n\treadonly onBeforeShutdownError = this._onBeforeShutdownError.event;\n\n\tprotected readonly _onShutdownVeto = this._register(new Emitter<void>());\n\treadonly onShutdownVeto = this._onShutdownVeto.event;\n\n\tprivate _startupKind: StartupKind;\n\tget startupKind(): StartupKind { return this._startupKind; }\n\n\tprivate _phase = LifecyclePhase.Starting;\n\tget phase(): LifecyclePhase { return this._phase; }\n\n\tprotected _willShutdown = false;\n\tget willShutdown(): boolean { return this._willShutdown; }\n\n\tprivate readonly phaseWhen = new Map<LifecyclePhase, Barrier>();\n\n\tprotected shutdownReason: ShutdownReason | undefined;\n\n\tconstructor(\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IStorageService protected readonly storageService: IStorageService\n\t) {\n\t\tsuper();\n\n\t\t// Resolve startup kind\n\t\tthis._startupKind = this.resolveStartupKind();\n\n\t\t// Save shutdown reason to retrieve on next startup\n\t\tthis._register(this.storageService.onWillSaveState(e => {\n\t\t\tif (e.reason === WillSaveStateReason.SHUTDOWN) {\n\t\t\t\tthis.storageService.store(AbstractLifecycleService.LAST_SHUTDOWN_REASON_KEY, this.shutdownReason, StorageScope.WORKSPACE, StorageTarget.MACHINE);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate resolveStartupKind(): StartupKind {\n\t\tconst startupKind = this.doResolveStartupKind() ?? StartupKind.NewWindow;\n\t\tthis.logService.trace(`[lifecycle] starting up (startup kind: ${startupKind})`);\n\n\t\treturn startupKind;\n\t}\n\n\tprotected doResolveStartupKind(): StartupKind | undefined {\n\n\t\t// Retrieve and reset last shutdown reason\n\t\tconst lastShutdownReason = this.storageService.getNumber(AbstractLifecycleService.LAST_SHUTDOWN_REASON_KEY, StorageScope.WORKSPACE);\n\t\tthis.storageService.remove(AbstractLifecycleService.LAST_SHUTDOWN_REASON_KEY, StorageScope.WORKSPACE);\n\n\t\t// Convert into startup kind\n\t\tlet startupKind: StartupKind | undefined = undefined;\n\t\tswitch (lastShutdownReason) {\n\t\t\tcase ShutdownReason.RELOAD:\n\t\t\t\tstartupKind = StartupKind.ReloadedWindow;\n\t\t\t\tbreak;\n\t\t\tcase ShutdownReason.LOAD:\n\t\t\t\tstartupKind = StartupKind.ReopenedWindow;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn startupKind;\n\t}\n\n\tset phase(value: LifecyclePhase) {\n\t\tif (value < this.phase) {\n\t\t\tthrow new Error('Lifecycle cannot go backwards');\n\t\t}\n\n\t\tif (this._phase === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.logService.trace(`lifecycle: phase changed (value: ${value})`);\n\n\t\tthis._phase = value;\n\t\tmark(`code/LifecyclePhase/${LifecyclePhaseToString(value)}`);\n\n\t\tconst barrier = this.phaseWhen.get(this._phase);\n\t\tif (barrier) {\n\t\t\tbarrier.open();\n\t\t\tthis.phaseWhen.delete(this._phase);\n\t\t}\n\t}\n\n\tasync when(phase: LifecyclePhase): Promise<void> {\n\t\tif (phase <= this._phase) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet barrier = this.phaseWhen.get(phase);\n\t\tif (!barrier) {\n\t\t\tbarrier = new Barrier();\n\t\t\tthis.phaseWhen.set(phase, barrier);\n\t\t}\n\n\t\tawait barrier.wait();\n\t}\n\n\t/**\n\t * Subclasses to implement the explicit shutdown method.\n\t */\n\tabstract shutdown(): Promise<void>;\n}\n"]}