{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/host/browser/host.ts","vs/workbench/services/host/browser/host.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAIhG,OAAO,EAAE,eAAe,EAAE,MAAM,4DAA4D,CAAC;AAI7F,MAAM,CAAC,MAAM,YAAY,GAAG,eAAe,CAAe,aAAa,CAAC,CAAC","file":"host.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { FocusMode } from '../../../../platform/native/common/native.js';\nimport { IWindowOpenable, IOpenWindowOptions, IOpenEmptyWindowOptions, IPoint, IRectangle, IOpenedMainWindow, IOpenedAuxiliaryWindow } from '../../../../platform/window/common/window.js';\n\nexport const IHostService = createDecorator<IHostService>('hostService');\n\n/**\n * A set of methods supported in both web and native environments.\n *\n * @see {@link INativeHostService} for methods that are specific to native\n * environments.\n */\nexport interface IHostService {\n\n\treadonly _serviceBrand: undefined;\n\n\t//#region Focus\n\n\t/**\n\t * Emitted when the focus of the window changes.\n\t *\n\t * Note: this considers the main window as well as auxiliary windows\n\t * when they are in focus. As long as the main window or any of its\n\t * auxiliary windows have focus, this event fires with `true`. It will\n\t * fire with `false` when neither the main window nor any of its\n\t * auxiliary windows have focus.\n\t */\n\treadonly onDidChangeFocus: Event<boolean>;\n\n\t/**\n\t * Find out if the window or any of its auxiliary windows have focus.\n\t */\n\treadonly hasFocus: boolean;\n\n\t/**\n\t * Find out if the window had the last focus.\n\t */\n\thadLastFocus(): Promise<boolean>;\n\n\t/**\n\t * Attempt to bring the window to the foreground and focus it.\n\t *\n\t * @param options How to focus the window, defaults to {@link FocusMode.Transfer}\n\t */\n\tfocus(targetWindow: Window, options?: { mode?: FocusMode }): Promise<void>;\n\n\t//#endregion\n\n\t//#region Window\n\n\t/**\n\t * Emitted when the active window changes between main window\n\t * and auxiliary windows.\n\t */\n\treadonly onDidChangeActiveWindow: Event<number>;\n\n\t/**\n\t * Emitted when the window with the given identifier changes\n\t * its fullscreen state.\n\t */\n\treadonly onDidChangeFullScreen: Event<{ windowId: number; fullscreen: boolean }>;\n\n\t/**\n\t * Opens an empty window. The optional parameter allows to define if\n\t * a new window should open or the existing one change to an empty.\n\t */\n\topenWindow(options?: IOpenEmptyWindowOptions): Promise<void>;\n\n\t/**\n\t * Opens the provided array of openables in a window with the provided options.\n\t */\n\topenWindow(toOpen: IWindowOpenable[], options?: IOpenWindowOptions): Promise<void>;\n\n\t/**\n\t * Switch between fullscreen and normal window.\n\t */\n\ttoggleFullScreen(targetWindow: Window): Promise<void>;\n\n\t/**\n\t * Bring a window to the front and restore it if needed.\n\t */\n\tmoveTop(targetWindow: Window): Promise<void>;\n\n\t/**\n\t * Get the location of the mouse cursor and its display bounds or `undefined` if unavailable.\n\t */\n\tgetCursorScreenPoint(): Promise<{ readonly point: IPoint; readonly display: IRectangle } | undefined>;\n\n\t/**\n\t * Get the list of opened windows, optionally including auxiliary windows.\n\t */\n\tgetWindows(options: { includeAuxiliaryWindows: true }): Promise<Array<IOpenedMainWindow | IOpenedAuxiliaryWindow>>;\n\tgetWindows(options: { includeAuxiliaryWindows: false }): Promise<Array<IOpenedMainWindow>>;\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\t/**\n\t * Restart the entire application.\n\t */\n\trestart(): Promise<void>;\n\n\t/**\n\t * Reload the currently active main window.\n\t */\n\treload(options?: { disableExtensions?: boolean }): Promise<void>;\n\n\t/**\n\t * Attempt to close the active main window.\n\t */\n\tclose(): Promise<void>;\n\n\t/**\n\t * Execute an asynchronous `expectedShutdownTask`. While this task is\n\t * in progress, attempts to quit the application will not be vetoed with a dialog.\n\t */\n\twithExpectedShutdown<T>(expectedShutdownTask: () => Promise<T>): Promise<T>;\n\n\t//#endregion\n\n\t//#region Screenshots\n\n\t/**\n\t * Captures a screenshot.\n\t */\n\tgetScreenshot(rect?: IRectangle): Promise<VSBuffer | undefined>;\n\n\t//#endregion\n\n\t//#region Native Handle\n\n\t/**\n\t * Get the native handle of the window.\n\t */\n\tgetNativeWindowHandle(windowId: number): Promise<VSBuffer | undefined>;\n\n\t//#endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { FocusMode } from '../../../../platform/native/common/native.js';\nimport { IWindowOpenable, IOpenWindowOptions, IOpenEmptyWindowOptions, IPoint, IRectangle, IOpenedMainWindow, IOpenedAuxiliaryWindow } from '../../../../platform/window/common/window.js';\n\nexport const IHostService = createDecorator<IHostService>('hostService');\n\n/**\n * A set of methods supported in both web and native environments.\n *\n * @see {@link INativeHostService} for methods that are specific to native\n * environments.\n */\nexport interface IHostService {\n\n\treadonly _serviceBrand: undefined;\n\n\t//#region Focus\n\n\t/**\n\t * Emitted when the focus of the window changes.\n\t *\n\t * Note: this considers the main window as well as auxiliary windows\n\t * when they are in focus. As long as the main window or any of its\n\t * auxiliary windows have focus, this event fires with `true`. It will\n\t * fire with `false` when neither the main window nor any of its\n\t * auxiliary windows have focus.\n\t */\n\treadonly onDidChangeFocus: Event<boolean>;\n\n\t/**\n\t * Find out if the window or any of its auxiliary windows have focus.\n\t */\n\treadonly hasFocus: boolean;\n\n\t/**\n\t * Find out if the window had the last focus.\n\t */\n\thadLastFocus(): Promise<boolean>;\n\n\t/**\n\t * Attempt to bring the window to the foreground and focus it.\n\t *\n\t * @param options How to focus the window, defaults to {@link FocusMode.Transfer}\n\t */\n\tfocus(targetWindow: Window, options?: { mode?: FocusMode }): Promise<void>;\n\n\t//#endregion\n\n\t//#region Window\n\n\t/**\n\t * Emitted when the active window changes between main window\n\t * and auxiliary windows.\n\t */\n\treadonly onDidChangeActiveWindow: Event<number>;\n\n\t/**\n\t * Emitted when the window with the given identifier changes\n\t * its fullscreen state.\n\t */\n\treadonly onDidChangeFullScreen: Event<{ windowId: number; fullscreen: boolean }>;\n\n\t/**\n\t * Opens an empty window. The optional parameter allows to define if\n\t * a new window should open or the existing one change to an empty.\n\t */\n\topenWindow(options?: IOpenEmptyWindowOptions): Promise<void>;\n\n\t/**\n\t * Opens the provided array of openables in a window with the provided options.\n\t */\n\topenWindow(toOpen: IWindowOpenable[], options?: IOpenWindowOptions): Promise<void>;\n\n\t/**\n\t * Switch between fullscreen and normal window.\n\t */\n\ttoggleFullScreen(targetWindow: Window): Promise<void>;\n\n\t/**\n\t * Bring a window to the front and restore it if needed.\n\t */\n\tmoveTop(targetWindow: Window): Promise<void>;\n\n\t/**\n\t * Get the location of the mouse cursor and its display bounds or `undefined` if unavailable.\n\t */\n\tgetCursorScreenPoint(): Promise<{ readonly point: IPoint; readonly display: IRectangle } | undefined>;\n\n\t/**\n\t * Get the list of opened windows, optionally including auxiliary windows.\n\t */\n\tgetWindows(options: { includeAuxiliaryWindows: true }): Promise<Array<IOpenedMainWindow | IOpenedAuxiliaryWindow>>;\n\tgetWindows(options: { includeAuxiliaryWindows: false }): Promise<Array<IOpenedMainWindow>>;\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\t/**\n\t * Restart the entire application.\n\t */\n\trestart(): Promise<void>;\n\n\t/**\n\t * Reload the currently active main window.\n\t */\n\treload(options?: { disableExtensions?: boolean }): Promise<void>;\n\n\t/**\n\t * Attempt to close the active main window.\n\t */\n\tclose(): Promise<void>;\n\n\t/**\n\t * Execute an asynchronous `expectedShutdownTask`. While this task is\n\t * in progress, attempts to quit the application will not be vetoed with a dialog.\n\t */\n\twithExpectedShutdown<T>(expectedShutdownTask: () => Promise<T>): Promise<T>;\n\n\t//#endregion\n\n\t//#region Screenshots\n\n\t/**\n\t * Captures a screenshot.\n\t */\n\tgetScreenshot(rect?: IRectangle): Promise<VSBuffer | undefined>;\n\n\t//#endregion\n\n\t//#region Native Handle\n\n\t/**\n\t * Get the native handle of the window.\n\t */\n\tgetNativeWindowHandle(windowId: number): Promise<VSBuffer | undefined>;\n\n\t//#endregion\n}\n"]}