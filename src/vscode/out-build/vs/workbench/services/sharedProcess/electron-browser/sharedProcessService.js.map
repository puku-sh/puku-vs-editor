{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/services/sharedProcess/electron-browser/sharedProcessService.ts","vs/workbench/services/sharedProcess/electron-browser/sharedProcessService.ts"],"names":[],"mappings":"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","file":"sharedProcessService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Client as MessagePortClient } from '../../../../base/parts/ipc/common/ipc.mp.js';\nimport { IChannel, IServerChannel, getDelayedChannel } from '../../../../base/parts/ipc/common/ipc.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ISharedProcessService } from '../../../../platform/ipc/electron-browser/services.js';\nimport { SharedProcessChannelConnection, SharedProcessRawConnection } from '../../../../platform/sharedProcess/common/sharedProcess.js';\nimport { mark } from '../../../../base/common/performance.js';\nimport { Barrier, timeout } from '../../../../base/common/async.js';\nimport { acquirePort } from '../../../../base/parts/ipc/electron-browser/ipc.mp.js';\n\nexport class SharedProcessService extends Disposable implements ISharedProcessService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly withSharedProcessConnection: Promise<MessagePortClient>;\n\n\tprivate readonly restoredBarrier = new Barrier();\n\n\tconstructor(\n\t\treadonly windowId: number,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.withSharedProcessConnection = this.connect();\n\t}\n\n\tprivate async connect(): Promise<MessagePortClient> {\n\t\tthis.logService.trace('Renderer->SharedProcess#connect');\n\n\t\t// Our performance tests show that a connection to the shared\n\t\t// process can have significant overhead to the startup time\n\t\t// of the window because the shared process could be created\n\t\t// as a result. As such, make sure we await the `Restored`\n\t\t// phase before making a connection attempt, but also add a\n\t\t// timeout to be safe against possible deadlocks.\n\n\t\tawait Promise.race([this.restoredBarrier.wait(), timeout(2000)]);\n\n\t\t// Acquire a message port connected to the shared process\n\t\tmark('code/willConnectSharedProcess');\n\t\tthis.logService.trace('Renderer->SharedProcess#connect: before acquirePort');\n\t\tconst port = await acquirePort(SharedProcessChannelConnection.request, SharedProcessChannelConnection.response);\n\t\tmark('code/didConnectSharedProcess');\n\t\tthis.logService.trace('Renderer->SharedProcess#connect: connection established');\n\n\t\treturn this._register(new MessagePortClient(port, `window:${this.windowId}`));\n\t}\n\n\tnotifyRestored(): void {\n\t\tif (!this.restoredBarrier.isOpen()) {\n\t\t\tthis.restoredBarrier.open();\n\t\t}\n\t}\n\n\tgetChannel(channelName: string): IChannel {\n\t\treturn getDelayedChannel(this.withSharedProcessConnection.then(connection => connection.getChannel(channelName)));\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<string>): void {\n\t\tthis.withSharedProcessConnection.then(connection => connection.registerChannel(channelName, channel));\n\t}\n\n\tasync createRawConnection(): Promise<MessagePort> {\n\n\t\t// Await initialization of the shared process\n\t\tawait this.withSharedProcessConnection;\n\n\t\t// Create a new port to the shared process\n\t\tthis.logService.trace('Renderer->SharedProcess#createRawConnection: before acquirePort');\n\t\tconst port = await acquirePort(SharedProcessRawConnection.request, SharedProcessRawConnection.response);\n\t\tthis.logService.trace('Renderer->SharedProcess#createRawConnection: connection established');\n\n\t\treturn port;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Client as MessagePortClient } from '../../../../base/parts/ipc/common/ipc.mp.js';\nimport { IChannel, IServerChannel, getDelayedChannel } from '../../../../base/parts/ipc/common/ipc.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { ISharedProcessService } from '../../../../platform/ipc/electron-browser/services.js';\nimport { SharedProcessChannelConnection, SharedProcessRawConnection } from '../../../../platform/sharedProcess/common/sharedProcess.js';\nimport { mark } from '../../../../base/common/performance.js';\nimport { Barrier, timeout } from '../../../../base/common/async.js';\nimport { acquirePort } from '../../../../base/parts/ipc/electron-browser/ipc.mp.js';\n\nexport class SharedProcessService extends Disposable implements ISharedProcessService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly withSharedProcessConnection: Promise<MessagePortClient>;\n\n\tprivate readonly restoredBarrier = new Barrier();\n\n\tconstructor(\n\t\treadonly windowId: number,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.withSharedProcessConnection = this.connect();\n\t}\n\n\tprivate async connect(): Promise<MessagePortClient> {\n\t\tthis.logService.trace('Renderer->SharedProcess#connect');\n\n\t\t// Our performance tests show that a connection to the shared\n\t\t// process can have significant overhead to the startup time\n\t\t// of the window because the shared process could be created\n\t\t// as a result. As such, make sure we await the `Restored`\n\t\t// phase before making a connection attempt, but also add a\n\t\t// timeout to be safe against possible deadlocks.\n\n\t\tawait Promise.race([this.restoredBarrier.wait(), timeout(2000)]);\n\n\t\t// Acquire a message port connected to the shared process\n\t\tmark('code/willConnectSharedProcess');\n\t\tthis.logService.trace('Renderer->SharedProcess#connect: before acquirePort');\n\t\tconst port = await acquirePort(SharedProcessChannelConnection.request, SharedProcessChannelConnection.response);\n\t\tmark('code/didConnectSharedProcess');\n\t\tthis.logService.trace('Renderer->SharedProcess#connect: connection established');\n\n\t\treturn this._register(new MessagePortClient(port, `window:${this.windowId}`));\n\t}\n\n\tnotifyRestored(): void {\n\t\tif (!this.restoredBarrier.isOpen()) {\n\t\t\tthis.restoredBarrier.open();\n\t\t}\n\t}\n\n\tgetChannel(channelName: string): IChannel {\n\t\treturn getDelayedChannel(this.withSharedProcessConnection.then(connection => connection.getChannel(channelName)));\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<string>): void {\n\t\tthis.withSharedProcessConnection.then(connection => connection.registerChannel(channelName, channel));\n\t}\n\n\tasync createRawConnection(): Promise<MessagePort> {\n\n\t\t// Await initialization of the shared process\n\t\tawait this.withSharedProcessConnection;\n\n\t\t// Create a new port to the shared process\n\t\tthis.logService.trace('Renderer->SharedProcess#createRawConnection: before acquirePort');\n\t\tconst port = await acquirePort(SharedProcessRawConnection.request, SharedProcessRawConnection.response);\n\t\tthis.logService.trace('Renderer->SharedProcess#createRawConnection: connection established');\n\n\t\treturn port;\n\t}\n}\n"]}