{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/browser/mainThreadNotebookDocuments.ts","vs/workbench/api/browser/mainThreadNotebookDocuments.ts"],"names":[],"mappings":"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","file":"mainThreadNotebookDocuments.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { DisposableStore, dispose } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { BoundModelReferenceCollection } from './mainThreadDocuments.js';\nimport { NotebookTextModel } from '../../contrib/notebook/common/model/notebookTextModel.js';\nimport { NotebookCellsChangeType } from '../../contrib/notebook/common/notebookCommon.js';\nimport { INotebookEditorModelResolverService } from '../../contrib/notebook/common/notebookEditorModelResolverService.js';\nimport { IUriIdentityService } from '../../../platform/uriIdentity/common/uriIdentity.js';\nimport { ExtHostContext, ExtHostNotebookDocumentsShape, MainThreadNotebookDocumentsShape, NotebookCellDto, NotebookCellsChangedEventDto, NotebookDataDto } from '../common/extHost.protocol.js';\nimport { NotebookDto } from './mainThreadNotebookDto.js';\nimport { SerializableObjectWithBuffers } from '../../services/extensions/common/proxyIdentifier.js';\nimport { IExtHostContext } from '../../services/extensions/common/extHostCustomers.js';\n\nexport class MainThreadNotebookDocuments implements MainThreadNotebookDocumentsShape {\n\n\tprivate readonly _disposables = new DisposableStore();\n\n\tprivate readonly _proxy: ExtHostNotebookDocumentsShape;\n\tprivate readonly _documentEventListenersMapping = new ResourceMap<DisposableStore>();\n\tprivate readonly _modelReferenceCollection: BoundModelReferenceCollection;\n\n\tconstructor(\n\t\textHostContext: IExtHostContext,\n\t\t@INotebookEditorModelResolverService private readonly _notebookEditorModelResolverService: INotebookEditorModelResolverService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService\n\t) {\n\t\tthis._proxy = extHostContext.getProxy(ExtHostContext.ExtHostNotebookDocuments);\n\t\tthis._modelReferenceCollection = new BoundModelReferenceCollection(this._uriIdentityService.extUri);\n\n\t\t// forward dirty and save events\n\t\tthis._disposables.add(this._notebookEditorModelResolverService.onDidChangeDirty(model => this._proxy.$acceptDirtyStateChanged(model.resource, model.isDirty())));\n\t\tthis._disposables.add(this._notebookEditorModelResolverService.onDidSaveNotebook(e => this._proxy.$acceptModelSaved(e)));\n\n\t\t// when a conflict is going to happen RELEASE references that are held by extensions\n\t\tthis._disposables.add(_notebookEditorModelResolverService.onWillFailWithConflict(e => {\n\t\t\tthis._modelReferenceCollection.remove(e.resource);\n\t\t}));\n\t}\n\n\tdispose(): void {\n\t\tthis._disposables.dispose();\n\t\tthis._modelReferenceCollection.dispose();\n\t\tdispose(this._documentEventListenersMapping.values());\n\t}\n\n\thandleNotebooksAdded(notebooks: readonly NotebookTextModel[]): void {\n\n\t\tfor (const textModel of notebooks) {\n\t\t\tconst disposableStore = new DisposableStore();\n\t\t\tdisposableStore.add(textModel.onDidChangeContent(event => {\n\n\t\t\t\tconst eventDto: NotebookCellsChangedEventDto = {\n\t\t\t\t\tversionId: event.versionId,\n\t\t\t\t\trawEvents: []\n\t\t\t\t};\n\n\t\t\t\tfor (const e of event.rawEvents) {\n\n\t\t\t\t\tswitch (e.kind) {\n\t\t\t\t\t\tcase NotebookCellsChangeType.ModelChange:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tchanges: e.changes.map(diff => [diff[0], diff[1], diff[2].map(cell => NotebookDto.toNotebookCellDto(cell))] as [number, number, NotebookCellDto[]])\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.Move:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tindex: e.index,\n\t\t\t\t\t\t\t\tlength: e.length,\n\t\t\t\t\t\t\t\tnewIdx: e.newIdx,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.Output:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tindex: e.index,\n\t\t\t\t\t\t\t\toutputs: e.outputs.map(NotebookDto.toNotebookOutputDto)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.OutputItem:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tindex: e.index,\n\t\t\t\t\t\t\t\toutputId: e.outputId,\n\t\t\t\t\t\t\t\toutputItems: e.outputItems.map(NotebookDto.toNotebookOutputItemDto),\n\t\t\t\t\t\t\t\tappend: e.append\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellLanguage:\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellContent:\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellMetadata:\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellInternalMetadata:\n\t\t\t\t\t\t\teventDto.rawEvents.push(e);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst hasDocumentMetadataChangeEvent = event.rawEvents.find(e => e.kind === NotebookCellsChangeType.ChangeDocumentMetadata);\n\n\t\t\t\t// using the model resolver service to know if the model is dirty or not.\n\t\t\t\t// assuming this is the first listener it can mean that at first the model\n\t\t\t\t// is marked as dirty and that another event is fired\n\t\t\t\tthis._proxy.$acceptModelChanged(\n\t\t\t\t\ttextModel.uri,\n\t\t\t\t\tnew SerializableObjectWithBuffers(eventDto),\n\t\t\t\t\tthis._notebookEditorModelResolverService.isDirty(textModel.uri),\n\t\t\t\t\thasDocumentMetadataChangeEvent ? textModel.metadata : undefined\n\t\t\t\t);\n\t\t\t}));\n\n\t\t\tthis._documentEventListenersMapping.set(textModel.uri, disposableStore);\n\t\t}\n\t}\n\n\thandleNotebooksRemoved(uris: URI[]): void {\n\t\tfor (const uri of uris) {\n\t\t\tthis._documentEventListenersMapping.get(uri)?.dispose();\n\t\t\tthis._documentEventListenersMapping.delete(uri);\n\t\t}\n\t}\n\n\tasync $tryCreateNotebook(options: { viewType: string; content?: NotebookDataDto }): Promise<UriComponents> {\n\t\tif (options.content) {\n\t\t\tconst ref = await this._notebookEditorModelResolverService.resolve({ untitledResource: undefined }, options.viewType);\n\n\t\t\t// untitled notebooks are disposed when they get saved. we should not hold a reference\n\t\t\t// to such a disposed notebook and therefore dispose the reference as well\n\t\t\tEvent.once(ref.object.notebook.onWillDispose)(() => {\n\t\t\t\tref.dispose();\n\t\t\t});\n\n\t\t\t// untitled notebooks with content are dirty by default\n\t\t\tthis._proxy.$acceptDirtyStateChanged(ref.object.resource, true);\n\n\t\t\t// apply content changes... slightly HACKY -> this triggers a change event\n\t\t\tif (options.content) {\n\t\t\t\tconst data = NotebookDto.fromNotebookDataDto(options.content);\n\t\t\t\tref.object.notebook.reset(data.cells, data.metadata, ref.object.notebook.transientOptions);\n\t\t\t}\n\t\t\treturn ref.object.notebook.uri;\n\t\t} else {\n\t\t\t// If we aren't adding content, we don't need to resolve the full editor model yet.\n\t\t\t// This will allow us to adjust settings when the editor is opened, e.g. scratchpad\n\t\t\tconst notebook = await this._notebookEditorModelResolverService.createUntitledNotebookTextModel(options.viewType);\n\t\t\treturn notebook.uri;\n\t\t}\n\t}\n\n\tasync $tryOpenNotebook(uriComponents: UriComponents): Promise<URI> {\n\t\tconst uri = URI.revive(uriComponents);\n\t\tconst ref = await this._notebookEditorModelResolverService.resolve(uri, undefined);\n\n\t\tif (uriComponents.scheme === 'untitled') {\n\t\t\t// untitled notebooks are disposed when they get saved. we should not hold a reference\n\t\t\t// to such a disposed notebook and therefore dispose the reference as well\n\t\t\tref.object.notebook.onWillDispose(() => {\n\t\t\t\tref.dispose();\n\t\t\t});\n\t\t}\n\n\t\tthis._modelReferenceCollection.add(uri, ref);\n\t\treturn uri;\n\t}\n\n\tasync $trySaveNotebook(uriComponents: UriComponents) {\n\t\tconst uri = URI.revive(uriComponents);\n\n\t\tconst ref = await this._notebookEditorModelResolverService.resolve(uri);\n\t\tconst saveResult = await ref.object.save();\n\t\tref.dispose();\n\t\treturn saveResult;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { DisposableStore, dispose } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { BoundModelReferenceCollection } from './mainThreadDocuments.js';\nimport { NotebookTextModel } from '../../contrib/notebook/common/model/notebookTextModel.js';\nimport { NotebookCellsChangeType } from '../../contrib/notebook/common/notebookCommon.js';\nimport { INotebookEditorModelResolverService } from '../../contrib/notebook/common/notebookEditorModelResolverService.js';\nimport { IUriIdentityService } from '../../../platform/uriIdentity/common/uriIdentity.js';\nimport { ExtHostContext, ExtHostNotebookDocumentsShape, MainThreadNotebookDocumentsShape, NotebookCellDto, NotebookCellsChangedEventDto, NotebookDataDto } from '../common/extHost.protocol.js';\nimport { NotebookDto } from './mainThreadNotebookDto.js';\nimport { SerializableObjectWithBuffers } from '../../services/extensions/common/proxyIdentifier.js';\nimport { IExtHostContext } from '../../services/extensions/common/extHostCustomers.js';\n\nexport class MainThreadNotebookDocuments implements MainThreadNotebookDocumentsShape {\n\n\tprivate readonly _disposables = new DisposableStore();\n\n\tprivate readonly _proxy: ExtHostNotebookDocumentsShape;\n\tprivate readonly _documentEventListenersMapping = new ResourceMap<DisposableStore>();\n\tprivate readonly _modelReferenceCollection: BoundModelReferenceCollection;\n\n\tconstructor(\n\t\textHostContext: IExtHostContext,\n\t\t@INotebookEditorModelResolverService private readonly _notebookEditorModelResolverService: INotebookEditorModelResolverService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService\n\t) {\n\t\tthis._proxy = extHostContext.getProxy(ExtHostContext.ExtHostNotebookDocuments);\n\t\tthis._modelReferenceCollection = new BoundModelReferenceCollection(this._uriIdentityService.extUri);\n\n\t\t// forward dirty and save events\n\t\tthis._disposables.add(this._notebookEditorModelResolverService.onDidChangeDirty(model => this._proxy.$acceptDirtyStateChanged(model.resource, model.isDirty())));\n\t\tthis._disposables.add(this._notebookEditorModelResolverService.onDidSaveNotebook(e => this._proxy.$acceptModelSaved(e)));\n\n\t\t// when a conflict is going to happen RELEASE references that are held by extensions\n\t\tthis._disposables.add(_notebookEditorModelResolverService.onWillFailWithConflict(e => {\n\t\t\tthis._modelReferenceCollection.remove(e.resource);\n\t\t}));\n\t}\n\n\tdispose(): void {\n\t\tthis._disposables.dispose();\n\t\tthis._modelReferenceCollection.dispose();\n\t\tdispose(this._documentEventListenersMapping.values());\n\t}\n\n\thandleNotebooksAdded(notebooks: readonly NotebookTextModel[]): void {\n\n\t\tfor (const textModel of notebooks) {\n\t\t\tconst disposableStore = new DisposableStore();\n\t\t\tdisposableStore.add(textModel.onDidChangeContent(event => {\n\n\t\t\t\tconst eventDto: NotebookCellsChangedEventDto = {\n\t\t\t\t\tversionId: event.versionId,\n\t\t\t\t\trawEvents: []\n\t\t\t\t};\n\n\t\t\t\tfor (const e of event.rawEvents) {\n\n\t\t\t\t\tswitch (e.kind) {\n\t\t\t\t\t\tcase NotebookCellsChangeType.ModelChange:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tchanges: e.changes.map(diff => [diff[0], diff[1], diff[2].map(cell => NotebookDto.toNotebookCellDto(cell))] as [number, number, NotebookCellDto[]])\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.Move:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tindex: e.index,\n\t\t\t\t\t\t\t\tlength: e.length,\n\t\t\t\t\t\t\t\tnewIdx: e.newIdx,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.Output:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tindex: e.index,\n\t\t\t\t\t\t\t\toutputs: e.outputs.map(NotebookDto.toNotebookOutputDto)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.OutputItem:\n\t\t\t\t\t\t\teventDto.rawEvents.push({\n\t\t\t\t\t\t\t\tkind: e.kind,\n\t\t\t\t\t\t\t\tindex: e.index,\n\t\t\t\t\t\t\t\toutputId: e.outputId,\n\t\t\t\t\t\t\t\toutputItems: e.outputItems.map(NotebookDto.toNotebookOutputItemDto),\n\t\t\t\t\t\t\t\tappend: e.append\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellLanguage:\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellContent:\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellMetadata:\n\t\t\t\t\t\tcase NotebookCellsChangeType.ChangeCellInternalMetadata:\n\t\t\t\t\t\t\teventDto.rawEvents.push(e);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst hasDocumentMetadataChangeEvent = event.rawEvents.find(e => e.kind === NotebookCellsChangeType.ChangeDocumentMetadata);\n\n\t\t\t\t// using the model resolver service to know if the model is dirty or not.\n\t\t\t\t// assuming this is the first listener it can mean that at first the model\n\t\t\t\t// is marked as dirty and that another event is fired\n\t\t\t\tthis._proxy.$acceptModelChanged(\n\t\t\t\t\ttextModel.uri,\n\t\t\t\t\tnew SerializableObjectWithBuffers(eventDto),\n\t\t\t\t\tthis._notebookEditorModelResolverService.isDirty(textModel.uri),\n\t\t\t\t\thasDocumentMetadataChangeEvent ? textModel.metadata : undefined\n\t\t\t\t);\n\t\t\t}));\n\n\t\t\tthis._documentEventListenersMapping.set(textModel.uri, disposableStore);\n\t\t}\n\t}\n\n\thandleNotebooksRemoved(uris: URI[]): void {\n\t\tfor (const uri of uris) {\n\t\t\tthis._documentEventListenersMapping.get(uri)?.dispose();\n\t\t\tthis._documentEventListenersMapping.delete(uri);\n\t\t}\n\t}\n\n\tasync $tryCreateNotebook(options: { viewType: string; content?: NotebookDataDto }): Promise<UriComponents> {\n\t\tif (options.content) {\n\t\t\tconst ref = await this._notebookEditorModelResolverService.resolve({ untitledResource: undefined }, options.viewType);\n\n\t\t\t// untitled notebooks are disposed when they get saved. we should not hold a reference\n\t\t\t// to such a disposed notebook and therefore dispose the reference as well\n\t\t\tEvent.once(ref.object.notebook.onWillDispose)(() => {\n\t\t\t\tref.dispose();\n\t\t\t});\n\n\t\t\t// untitled notebooks with content are dirty by default\n\t\t\tthis._proxy.$acceptDirtyStateChanged(ref.object.resource, true);\n\n\t\t\t// apply content changes... slightly HACKY -> this triggers a change event\n\t\t\tif (options.content) {\n\t\t\t\tconst data = NotebookDto.fromNotebookDataDto(options.content);\n\t\t\t\tref.object.notebook.reset(data.cells, data.metadata, ref.object.notebook.transientOptions);\n\t\t\t}\n\t\t\treturn ref.object.notebook.uri;\n\t\t} else {\n\t\t\t// If we aren't adding content, we don't need to resolve the full editor model yet.\n\t\t\t// This will allow us to adjust settings when the editor is opened, e.g. scratchpad\n\t\t\tconst notebook = await this._notebookEditorModelResolverService.createUntitledNotebookTextModel(options.viewType);\n\t\t\treturn notebook.uri;\n\t\t}\n\t}\n\n\tasync $tryOpenNotebook(uriComponents: UriComponents): Promise<URI> {\n\t\tconst uri = URI.revive(uriComponents);\n\t\tconst ref = await this._notebookEditorModelResolverService.resolve(uri, undefined);\n\n\t\tif (uriComponents.scheme === 'untitled') {\n\t\t\t// untitled notebooks are disposed when they get saved. we should not hold a reference\n\t\t\t// to such a disposed notebook and therefore dispose the reference as well\n\t\t\tref.object.notebook.onWillDispose(() => {\n\t\t\t\tref.dispose();\n\t\t\t});\n\t\t}\n\n\t\tthis._modelReferenceCollection.add(uri, ref);\n\t\treturn uri;\n\t}\n\n\tasync $trySaveNotebook(uriComponents: UriComponents) {\n\t\tconst uri = URI.revive(uriComponents);\n\n\t\tconst ref = await this._notebookEditorModelResolverService.resolve(uri);\n\t\tconst saveResult = await ref.object.save();\n\t\tref.dispose();\n\t\treturn saveResult;\n\t}\n}\n"]}