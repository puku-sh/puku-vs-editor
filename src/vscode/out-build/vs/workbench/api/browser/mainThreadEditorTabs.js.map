{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/browser/mainThreadEditorTabs.ts","vs/workbench/api/browser/mainThreadEditorTabs.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;AAEhG,OAAO,EAAE,KAAK,EAAE,MAAM,+BAA+B,CAAC;AACtD,OAAO,EAAE,aAAa,EAAE,eAAe,EAAE,MAAM,mCAAmC,CAAC;AACnF,OAAO,EAAE,OAAO,EAAE,MAAM,mCAAmC,CAAC;AAC5D,OAAO,EAAE,GAAG,EAAE,MAAM,6BAA6B,CAAC;AAClD,OAAO,EAAE,qBAAqB,EAAE,MAAM,yDAAyD,CAAC;AAChG,OAAO,EAAE,WAAW,EAAE,MAAM,qCAAqC,CAAC;AAClE,OAAO,EAAe,cAAc,EAA8D,WAAW,EAAoF,MAAM,+BAA+B,CAAC;AACvO,OAAO,EAAE,sBAAsB,EAAwB,gBAAgB,EAAE,MAAM,wBAAwB,CAAC;AACxG,OAAO,EAAE,eAAe,EAAE,MAAM,wCAAwC,CAAC;AACzE,OAAO,EAAE,sBAAsB,EAAE,MAAM,yCAAyC,CAAC;AAEjF,OAAO,EAAE,qBAAqB,EAAE,MAAM,8CAA8C,CAAC;AACrF,OAAO,EAAE,+BAA+B,EAAE,MAAM,gDAAgD,CAAC;AACjG,OAAO,EAAE,eAAe,EAAE,MAAM,+CAA+C,CAAC;AAChF,OAAO,EAAE,iBAAiB,EAAE,MAAM,yDAAyD,CAAC;AAC5F,OAAO,EAAE,sBAAsB,EAAE,MAAM,6DAA6D,CAAC;AACrG,OAAO,EAAE,gBAAgB,EAAE,MAAM,uDAAuD,CAAC;AACzF,OAAO,EAAE,oBAAoB,EAAE,MAAM,+DAA+D,CAAC;AACrG,OAAO,EAAE,mBAAmB,EAAE,MAAM,sDAAsD,CAAC;AAC3F,OAAO,EAAE,mBAAmB,EAAE,MAAM,uDAAuD,CAAC;AAC5F,OAAO,EAAE,YAAY,EAAE,MAAM,0DAA0D,CAAC;AACxF,OAAO,EAAE,mBAAmB,EAAqB,mBAAmB,EAAE,MAAM,mDAAmD,CAAC;AAChI,OAAO,EAAgC,oBAAoB,EAAE,iCAAiC,EAAE,MAAM,qDAAqD,CAAC;AAC5J,OAAO,EAAuB,cAAc,EAAE,UAAU,EAAE,MAAM,+CAA+C,CAAC;AAChH,OAAO,EAAE,oBAAoB,EAAmB,MAAM,sDAAsD,CAAC;AAQtG,IAAM,oBAAoB,GAA1B,MAAM,oBAAoB;IAahC,YACC,cAA+B,EACT,oBAA2D,EAC1D,qBAA6D,EACvE,WAAyC,EACtC,aAA6B;QAHN,yBAAoB,GAApB,oBAAoB,CAAsB;QACzC,0BAAqB,GAArB,qBAAqB,CAAuB;QACtD,gBAAW,GAAX,WAAW,CAAa;QAftC,gBAAW,GAAG,IAAI,eAAe,EAAE,CAAC;QAErD,yEAAyE;QACjE,mBAAc,GAAyB,EAAE,CAAC;QAClD,uCAAuC;QACtB,iBAAY,GAAoC,IAAI,GAAG,EAAE,CAAC;QAC3E,qCAAqC;QACpB,mBAAc,GAAyB,IAAI,GAAG,EAAE,CAAC;QAClE,gFAAgF;QAC/D,mCAA8B,GAAwC,IAAI,aAAa,EAAE,CAAC;QAU1G,IAAI,CAAC,MAAM,GAAG,cAAc,CAAC,QAAQ,CAAC,cAAc,CAAC,iBAAiB,CAAC,CAAC;QAExE,iEAAiE;QACjE,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,aAAa,CAAC,kBAAkB,CAAC,CAAC,KAAK,EAAE,EAAE;YAC/D,IAAI,CAAC;gBACJ,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;YAC9B,CAAC;YAAC,MAAM,CAAC;gBACR,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,oCAAoC,CAAC,CAAC;gBAC7D,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACzB,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;QAEJ,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,8BAA8B,CAAC,CAAC;QAE1D,4EAA4E;QAC5E,kEAAkE;QAClE,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,oBAAoB,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAC;QAC7F,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAC;QAEhG,4DAA4D;QAC5D,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC;IACzE,CAAC;IAED,OAAO;QACN,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;QAC1B,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;QAC5B,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;IAC5B,CAAC;IAED;;;;;OAKG;IACK,eAAe,CAAC,KAAmB,EAAE,MAAmB,EAAE,WAAmB;QACpF,MAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;QACjC,MAAM,GAAG,GAAkB;YAC1B,EAAE,EAAE,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,CAAC;YACzC,KAAK,EAAE,MAAM,CAAC,OAAO,EAAE;YACvB,QAAQ;YACR,KAAK,EAAE,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC;YACrC,QAAQ,EAAE,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC;YACrC,SAAS,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC;YACvC,QAAQ,EAAE,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC;YAChC,OAAO,EAAE,MAAM,CAAC,OAAO,EAAE;SACzB,CAAC;QACF,OAAO,GAAG,CAAC;IACZ,CAAC;IAEO,iBAAiB,CAAC,MAAmB;QAE5C,IAAI,MAAM,YAAY,gBAAgB,EAAE,CAAC;YACxC,OAAO;gBACN,IAAI,qCAA6B;gBACjC,IAAI,EAAE,MAAM,CAAC,IAAI;gBACjB,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG;gBACzB,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG;gBACzB,MAAM,EAAE,MAAM,CAAC,QAAQ;aACvB,CAAC;QACH,CAAC;QAED,IAAI,MAAM,YAAY,+BAA+B,EAAE,CAAC;YACvD,OAAO;gBACN,IAAI,gCAAwB;gBAC5B,GAAG,EAAE,MAAM,CAAC,QAAQ;aACpB,CAAC;QACH,CAAC;QAED,IAAI,MAAM,YAAY,qBAAqB,IAAI,CAAC,CAAC,MAAM,YAAY,eAAe,CAAC,EAAE,CAAC;YACrF,MAAM,eAAe,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;YAChD,MAAM,iBAAiB,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;YACpD,0FAA0F;YAC1F,IAAI,MAAM,CAAC,OAAO,YAAY,+BAA+B;mBACzD,MAAM,CAAC,SAAS,YAAY,+BAA+B;mBAC3D,OAAO,CAAC,eAAe,EAAE,iBAAiB,CAAC;mBAC3C,eAAe;mBACf,iBAAiB,EACnB,CAAC;gBACF,OAAO;oBACN,IAAI,gCAAwB;oBAC5B,GAAG,EAAE,eAAe;iBACpB,CAAC;YACH,CAAC;YACD,OAAO,EAAE,IAAI,mCAA2B,EAAE,CAAC;QAC5C,CAAC;QAED,IAAI,MAAM,YAAY,mBAAmB,EAAE,CAAC;YAC3C,OAAO;gBACN,IAAI,oCAA4B;gBAChC,YAAY,EAAE,MAAM,CAAC,QAAQ;gBAC7B,GAAG,EAAE,MAAM,CAAC,QAAQ;aACpB,CAAC;QACH,CAAC;QAED,IAAI,MAAM,YAAY,iBAAiB,EAAE,CAAC;YACzC,OAAO;gBACN,IAAI,wCAAgC;gBACpC,QAAQ,EAAE,MAAM,CAAC,QAAQ;gBACzB,GAAG,EAAE,MAAM,CAAC,QAAQ;aACpB,CAAC;QACH,CAAC;QAED,IAAI,MAAM,YAAY,YAAY,EAAE,CAAC;YACpC,OAAO;gBACN,IAAI,yCAAiC;gBACrC,QAAQ,EAAE,MAAM,CAAC,QAAQ;aACzB,CAAC;QACH,CAAC;QAED,IAAI,MAAM,YAAY,mBAAmB,EAAE,CAAC;YAC3C,OAAO;gBACN,IAAI,0CAAkC;aACtC,CAAC;QACH,CAAC;QAED,IAAI,MAAM,YAAY,eAAe,EAAE,CAAC;YACvC,IAAI,MAAM,CAAC,QAAQ,YAAY,+BAA+B,IAAI,MAAM,CAAC,QAAQ,YAAY,+BAA+B,EAAE,CAAC;gBAC9H,OAAO;oBACN,IAAI,oCAA4B;oBAChC,QAAQ,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ;oBAClC,QAAQ,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ;iBAClC,CAAC;YACH,CAAC;YACD,IAAI,MAAM,CAAC,QAAQ,YAAY,mBAAmB,IAAI,MAAM,CAAC,QAAQ,YAAY,mBAAmB,EAAE,CAAC;gBACtG,OAAO;oBACN,IAAI,wCAAgC;oBACpC,YAAY,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ;oBACtC,QAAQ,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ;oBAClC,QAAQ,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ;iBAClC,CAAC;YACH,CAAC;QACF,CAAC;QAED,IAAI,MAAM,YAAY,sBAAsB,EAAE,CAAC;YAC9C,OAAO;gBACN,IAAI,6CAAqC;gBACzC,GAAG,EAAE,MAAM,CAAC,QAAQ;gBACpB,WAAW,EAAE,MAAM,CAAC,aAAa;aACjC,CAAC;QACH,CAAC;QAED,IAAI,MAAM,YAAY,eAAe,EAAE,CAAC;YACvC,OAAO;gBACN,IAAI,uCAA8B;aAClC,CAAC;QACH,CAAC;QAED,IAAI,MAAM,YAAY,oBAAoB,EAAE,CAAC;YAC5C,MAAM,WAAW,GAAuB,EAAE,CAAC;YAC3C,KAAK,MAAM,QAAQ,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;gBACxD,IAAI,QAAQ,CAAC,WAAW,IAAI,QAAQ,CAAC,WAAW,EAAE,CAAC;oBAClD,WAAW,CAAC,IAAI,CAAC;wBAChB,IAAI,oCAA4B;wBAChC,QAAQ,EAAE,QAAQ,CAAC,WAAW;wBAC9B,QAAQ,EAAE,QAAQ,CAAC,WAAW;qBAC9B,CAAC,CAAC;gBACJ,CAAC;YACF,CAAC;YAED,OAAO;gBACN,IAAI,4CAAmC;gBACvC,WAAW;aACX,CAAC;QACH,CAAC;QAED,OAAO,EAAE,IAAI,mCAA2B,EAAE,CAAC;IAC5C,CAAC;IAED;;;;;OAKG;IACK,cAAc,CAAC,MAAmB,EAAE,OAAe;QAC1D,IAAI,cAAkC,CAAC;QACvC,iEAAiE;QACjE,MAAM,QAAQ,GAAG,sBAAsB,CAAC,eAAe,CAAC,MAAM,EAAE,EAAE,iBAAiB,EAAE,gBAAgB,CAAC,IAAI,EAAE,CAAC,CAAC;QAC9G,IAAI,QAAQ,YAAY,GAAG,EAAE,CAAC;YAC7B,cAAc,GAAG,QAAQ,CAAC,QAAQ,EAAE,CAAC;QACtC,CAAC;aAAM,CAAC;YACP,cAAc,GAAG,GAAG,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,IAAI,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,EAAE,CAAC;QACxF,CAAC;QACD,OAAO,GAAG,OAAO,IAAI,MAAM,CAAC,QAAQ,IAAI,MAAM,CAAC,MAAM,IAAI,cAAc,GAAG,CAAC;IAC5E,CAAC;IAED;;OAEG;IACK,mBAAmB;QAC1B,MAAM,aAAa,GAAG,IAAI,CAAC,oBAAoB,CAAC,WAAW,CAAC,EAAE,CAAC;QAC/D,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;QACzD,IAAI,WAAW,EAAE,CAAC;YACjB,sDAAsD;YACtD,WAAW,CAAC,QAAQ,GAAG,IAAI,CAAC;YAC5B,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC;QAChD,CAAC;IACF,CAAC;IAED;;;;OAIG;IACK,oBAAoB,CAAC,OAAe,EAAE,WAAwB,EAAE,WAAmB;QAC1F,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;QACxD,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC/C,sCAAsC;QACtC,IAAI,OAAO,EAAE,CAAC;YACb,OAAO,CAAC,GAAG,CAAC,KAAK,GAAG,WAAW,CAAC,OAAO,EAAE,CAAC;YAC1C,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC;gBAC/B,OAAO;gBACP,KAAK,EAAE,WAAW;gBAClB,MAAM,EAAE,OAAO,CAAC,GAAG;gBACnB,IAAI,0CAAkC;aACtC,CAAC,CAAC;QACJ,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,4CAA4C,CAAC,CAAC;YACrE,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACzB,CAAC;IACF,CAAC;IAED;;;;;OAKG;IACK,aAAa,CAAC,OAAe,EAAE,WAAwB,EAAE,WAAmB;QACnF,MAAM,KAAK,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC1D,8FAA8F;QAC9F,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,SAAS,CAAC;QAClE,+DAA+D;QAC/D,IAAI,CAAC,KAAK,IAAI,CAAC,YAAY,EAAE,CAAC;YAC7B,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,OAAO;QACR,CAAC;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC;QAClD,IAAI,CAAC,IAAI,EAAE,CAAC;YACX,OAAO;QACR,CAAC;QACD,6CAA6C;QAC7C,MAAM,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC;QACxE,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,EAAE,SAAS,CAAC,CAAC;QACvC,gBAAgB;QAChB,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;QACxD,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,EAAE,SAAS,EAAE,CAAC,CAAC;QAEvE,IAAI,WAAW,YAAY,oBAAoB,EAAE,CAAC;YACjD,IAAI,CAAC,8BAA8B,CAAC,GAAG,CAAC,WAAW,EAAE,KAAK,CAAC,mBAAmB,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE;gBAC1G,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBAC/C,IAAI,CAAC,OAAO,EAAE,CAAC;oBACd,OAAO;gBACR,CAAC;gBACD,OAAO,CAAC,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC;gBACpE,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC;oBAC/B,OAAO;oBACP,KAAK,EAAE,WAAW;oBAClB,MAAM,EAAE,OAAO,CAAC,GAAG;oBACnB,IAAI,0CAAkC;iBACtC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC,CAAC;QACL,CAAC;QAED,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC;YAC/B,OAAO;YACP,KAAK,EAAE,WAAW;YAClB,MAAM,EAAE,SAAS;YACjB,IAAI,wCAAgC;SACpC,CAAC,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACK,cAAc,CAAC,OAAe,EAAE,WAAmB;QAC1D,MAAM,KAAK,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC1D,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC;QAClD,wDAAwD;QACxD,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,EAAE,CAAC;YACrB,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,OAAO;QACR,CAAC;QACD,6CAA6C;QAC7C,MAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;QAE/C,yDAAyD;QACzD,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC7B,OAAO;QACR,CAAC;QAED,gBAAgB;QAChB,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC;QAEpD,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE,KAAK,YAAY,oBAAoB,EAAE,CAAC;YAC1D,IAAI,CAAC,8BAA8B,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;QAC5E,CAAC;QAED,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC;YAC/B,OAAO;YACP,KAAK,EAAE,WAAW;YAClB,MAAM,EAAE,UAAU,CAAC,CAAC,CAAC;YACrB,IAAI,yCAAiC;SACrC,CAAC,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACK,qBAAqB,CAAC,OAAe,EAAE,WAAmB;QACjE,mFAAmF;QACnF,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC;QAClD,IAAI,CAAC,IAAI,EAAE,CAAC;YACX,OAAO;QACR,CAAC;QACD,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC;QACpC,+EAA+E;QAC/E,SAAS,CAAC,QAAQ,GAAG,IAAI,CAAC;QAC1B,iCAAiC;QACjC,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC;YAC/B,OAAO;YACP,KAAK,EAAE,WAAW;YAClB,MAAM,EAAE,SAAS;YACjB,IAAI,0CAAkC;SACtC,CAAC,CAAC;IAEJ,CAAC;IAED;;;;;OAKG;IACK,cAAc,CAAC,OAAe,EAAE,WAAmB,EAAE,MAAmB;QAC/E,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QACnD,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC/C,qDAAqD;QACrD,IAAI,CAAC,OAAO,EAAE,CAAC;YACd,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,4CAA4C,CAAC,CAAC;YACrE,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,OAAO;QACR,CAAC;QACD,OAAO,CAAC,GAAG,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,EAAE,CAAC;QACvC,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC;YAC/B,OAAO;YACP,KAAK,EAAE,WAAW;YAClB,MAAM,EAAE,OAAO,CAAC,GAAG;YACnB,IAAI,0CAAkC;SACtC,CAAC,CAAC;IACJ,CAAC;IAED;;;;;OAKG;IACK,kBAAkB,CAAC,OAAe,EAAE,WAAmB,EAAE,MAAmB;QACnF,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QACnD,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC/C,MAAM,KAAK,GAAG,OAAO,EAAE,KAAK,CAAC;QAC7B,MAAM,GAAG,GAAG,OAAO,EAAE,GAAG,CAAC;QACzB,qDAAqD;QACrD,IAAI,CAAC,KAAK,IAAI,CAAC,GAAG,EAAE,CAAC;YACpB,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,6CAA6C,CAAC,CAAC;YACtE,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,OAAO;QACR,CAAC;QACD,0EAA0E;QAC1E,GAAG,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QAC3C,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC;YAC/B,OAAO;YACP,KAAK,EAAE,WAAW;YAClB,MAAM,EAAE,GAAG;YACX,IAAI,0CAAkC;SACtC,CAAC,CAAC;IACJ,CAAC;IAED;;;;;GAKE;IACM,sBAAsB,CAAC,OAAe,EAAE,WAAmB,EAAE,MAAmB;QACvF,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QACnD,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC/C,MAAM,KAAK,GAAG,OAAO,EAAE,KAAK,CAAC;QAC7B,MAAM,GAAG,GAAG,OAAO,EAAE,GAAG,CAAC;QACzB,qDAAqD;QACrD,IAAI,CAAC,KAAK,IAAI,CAAC,GAAG,EAAE,CAAC;YACpB,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,6CAA6C,CAAC,CAAC;YACtE,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,OAAO;QACR,CAAC;QACD,0EAA0E;QAC1E,GAAG,CAAC,SAAS,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QAC7C,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC;YAC/B,IAAI,0CAAkC;YACtC,OAAO;YACP,MAAM,EAAE,GAAG;YACX,KAAK,EAAE,WAAW;SAClB,CAAC,CAAC;IACJ,CAAC;IAEO,aAAa,CAAC,OAAe,EAAE,WAAmB,EAAE,cAAsB,EAAE,MAAmB;QACtG,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC;QAClD,qDAAqD;QACrD,IAAI,CAAC,IAAI,EAAE,CAAC;YACX,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,2CAA2C,CAAC,CAAC;YACpE,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,OAAO;QACR,CAAC;QAED,uCAAuC;QACvC,MAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;QAClD,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC7B,OAAO;QACR,CAAC;QACD,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;QAE3C,yBAAyB;QACzB,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC;YAC/B,IAAI,wCAAgC;YACpC,OAAO;YACP,MAAM,EAAE,UAAU,CAAC,CAAC,CAAC;YACrB,KAAK,EAAE,WAAW;YAClB,QAAQ,EAAE,cAAc;SACxB,CAAC,CAAC;IACJ,CAAC;IAED;;OAEG;IACK,gBAAgB;QACvB,IAAI,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACnD,OAAO,CAAC,6HAA6H;QACtI,CAAC;QAED,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;QACzB,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;QAC1B,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;QAC5B,IAAI,IAAI,GAAoB,EAAE,CAAC;QAC/B,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,oBAAoB,CAAC,MAAM,EAAE,CAAC;YACtD,MAAM,oBAAoB,GAAuB;gBAChD,OAAO,EAAE,KAAK,CAAC,EAAE;gBACjB,QAAQ,EAAE,KAAK,CAAC,EAAE,KAAK,IAAI,CAAC,oBAAoB,CAAC,WAAW,CAAC,EAAE;gBAC/D,UAAU,EAAE,mBAAmB,CAAC,IAAI,CAAC,oBAAoB,EAAE,KAAK,CAAC;gBACjE,IAAI,EAAE,EAAE;aACR,CAAC;YACF,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,WAAW,EAAE,EAAE;gBAC7C,MAAM,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;gBAC7D,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACf,8CAA8C;gBAC9C,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,CAAC,EAAE;oBAC9D,KAAK;oBACL,GAAG;oBACH,WAAW,EAAE,MAAM;iBACnB,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;YACH,oBAAoB,CAAC,IAAI,GAAG,IAAI,CAAC;YACjC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;YAC/C,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,EAAE,oBAAoB,CAAC,CAAC;YACtD,IAAI,GAAG,EAAE,CAAC;QACX,CAAC;QACD,uCAAuC;QACvC,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IACxD,CAAC;IAED,sEAAsE;IACtE,mFAAmF;IACnF,yBAAyB;IACzB,yBAAyB;IACzB,gFAAgF;IAChF,oFAAoF;IACpF,8EAA8E;IAC9E,gFAAgF;IAChF,kFAAkF;IAClF,gFAAgF;IAChF,kFAAkF;IAClF,kFAAkF;IAClF,kFAAkF;IAClF,kFAAkF;IAClF,oFAAoF;IACpF,6DAA6D;IAC7D,KAAK;IACL,uBAAuB;IACvB,IAAI;IAEJ;;;OAGG;IACK,gBAAgB,CAAC,WAAgC;QACxD,MAAM,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC;QAChC,MAAM,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC;QACpC,QAAQ,KAAK,CAAC,IAAI,EAAE,CAAC;YACpB;gBACC,IAAI,OAAO,KAAK,IAAI,CAAC,oBAAoB,CAAC,WAAW,CAAC,EAAE,EAAE,CAAC;oBAC1D,IAAI,CAAC,mBAAmB,EAAE,CAAC;oBAC3B,MAAM;gBACP,CAAC;qBAAM,CAAC;oBACP,OAAO;gBACR,CAAC;YACF;gBACC,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,IAAI,KAAK,CAAC,WAAW,KAAK,SAAS,EAAE,CAAC;oBACnE,IAAI,CAAC,oBAAoB,CAAC,OAAO,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;oBACpE,MAAM;gBACP,CAAC;YACF;gBACC,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,IAAI,KAAK,CAAC,WAAW,KAAK,SAAS,EAAE,CAAC;oBACnE,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;oBAC7D,MAAM;gBACP,CAAC;YACF;gBACC,IAAI,KAAK,CAAC,WAAW,KAAK,SAAS,EAAE,CAAC;oBACrC,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;oBAChD,MAAM;gBACP,CAAC;YACF;gBACC,IAAI,KAAK,CAAC,WAAW,KAAK,SAAS,EAAE,CAAC;oBACrC,IAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;oBACvD,MAAM;gBACP,CAAC;YACF;gBACC,IAAI,KAAK,CAAC,WAAW,KAAK,SAAS,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;oBACnE,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;oBAC9D,MAAM;gBACP,CAAC;YACF;gBACC,IAAI,KAAK,CAAC,WAAW,KAAK,SAAS,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;oBACnE,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;oBAClE,MAAM;gBACP,CAAC;YACF;gBACC,IAAI,KAAK,CAAC,WAAW,KAAK,SAAS,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;oBACnE,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;oBACtE,MAAM;gBACP,CAAC;YACF;gBACC,mCAAmC;gBACnC,MAAM;YACP;gBACC,IAAI,sBAAsB,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,WAAW,KAAK,SAAS,IAAI,KAAK,CAAC,cAAc,KAAK,SAAS,EAAE,CAAC;oBAC5H,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;oBACnF,MAAM;gBACP,CAAC;YACF;gBACC,uEAAuE;gBACvE,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAC1B,CAAC;IACF,CAAC;IACD,yCAAyC;IACzC,QAAQ,CAAC,KAAa,EAAE,KAAa,EAAE,UAA6B,EAAE,aAAuB;QAC5F,MAAM,OAAO,GAAG,mBAAmB,CAAC,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,qBAAqB,EAAE,UAAU,CAAC,CAAC;QACvG,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC/C,MAAM,GAAG,GAAG,OAAO,EAAE,GAAG,CAAC;QACzB,IAAI,CAAC,GAAG,EAAE,CAAC;YACV,MAAM,IAAI,KAAK,CAAC,kCAAkC,KAAK,uBAAuB,CAAC,CAAC;QACjF,CAAC;QACD,IAAI,WAAqC,CAAC;QAC1C,MAAM,WAAW,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QACzE,IAAI,CAAC,WAAW,EAAE,CAAC;YAClB,OAAO;QACR,CAAC;QACD,+FAA+F;QAC/F,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,SAAS,EAAE,CAAC;YAClD,IAAI,SAAS,+BAAuB,CAAC;YACrC,2DAA2D;YAC3D,IAAI,UAAU,KAAK,UAAU,EAAE,CAAC;gBAC/B,SAAS,GAAG,iCAAiC,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;YAC3E,CAAC;YACD,WAAW,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;QAC5I,CAAC;aAAM,CAAC;YACP,WAAW,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC3D,CAAC;QACD,IAAI,CAAC,WAAW,EAAE,CAAC;YAClB,OAAO;QACR,CAAC;QAED,oEAAoE;QACpE,IAAI,KAAK,GAAG,CAAC,IAAI,KAAK,GAAG,WAAW,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;YACrD,KAAK,GAAG,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC;QACpC,CAAC;QACD,kDAAkD;QAClD,MAAM,WAAW,GAAG,OAAO,EAAE,WAAW,CAAC;QACzC,IAAI,CAAC,WAAW,EAAE,CAAC;YAClB,OAAO;QACR,CAAC;QACD,sCAAsC;QACtC,WAAW,CAAC,UAAU,CAAC,WAAW,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,aAAa,EAAE,CAAC,CAAC;QAC3E,OAAO;IACR,CAAC;IAED,KAAK,CAAC,SAAS,CAAC,MAAgB,EAAE,aAAuB;QACxD,MAAM,MAAM,GAAqC,IAAI,GAAG,EAAE,CAAC;QAC3D,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;YAC5B,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAC/C,MAAM,GAAG,GAAG,OAAO,EAAE,GAAG,CAAC;YACzB,MAAM,KAAK,GAAG,OAAO,EAAE,KAAK,CAAC;YAC7B,MAAM,SAAS,GAAG,OAAO,EAAE,WAAW,CAAC;YACvC,oBAAoB;YACpB,IAAI,CAAC,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC;gBAC9C,SAAS;YACV,CAAC;YACD,MAAM,YAAY,GAAG,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YACvC,IAAI,CAAC,YAAY,EAAE,CAAC;gBACnB,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;YAChC,CAAC;iBAAM,CAAC;gBACP,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC9B,CAAC;QACF,CAAC;QACD,yDAAyD;QACzD,MAAM,OAAO,GAAc,EAAE,CAAC;QAC9B,KAAK,MAAM,CAAC,KAAK,EAAE,OAAO,CAAC,IAAI,MAAM,EAAE,CAAC;YACvC,OAAO,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,YAAY,CAAC,OAAO,EAAE,EAAE,aAAa,EAAE,CAAC,CAAC,CAAC;QACpE,CAAC;QACD,oFAAoF;QACpF,OAAO,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC;IACxC,CAAC;IAED,KAAK,CAAC,WAAW,CAAC,QAAkB,EAAE,aAAuB;QAC5D,MAAM,iBAAiB,GAAc,EAAE,CAAC;QACxC,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAChC,MAAM,KAAK,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YAC1D,IAAI,KAAK,EAAE,CAAC;gBACX,iBAAiB,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,eAAe,EAAE,CAAC,CAAC;gBACtD,8DAA8D;gBAC9D,IAAI,KAAK,CAAC,KAAK,KAAK,CAAC,IAAI,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC;oBACvE,IAAI,CAAC,oBAAoB,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;gBAC9C,CAAC;YACF,CAAC;QACF,CAAC;QACD,OAAO,iBAAiB,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC;IAClD,CAAC;CAED,CAAA;AAvpBY,oBAAoB;IADhC,oBAAoB,CAAC,WAAW,CAAC,oBAAoB,CAAC;IAgBpD,WAAA,oBAAoB,CAAA;IACpB,WAAA,qBAAqB,CAAA;IACrB,WAAA,WAAW,CAAA;IACX,WAAA,cAAc,CAAA;GAlBJ,oBAAoB,CAupBhC","file":"mainThreadEditorTabs.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { isEqual } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { AnyInputDto, ExtHostContext, IEditorTabDto, IEditorTabGroupDto, IExtHostEditorTabsShape, MainContext, MainThreadEditorTabsShape, TabInputKind, TabModelOperationKind, TextDiffInputDto } from '../common/extHost.protocol.js';\nimport { EditorResourceAccessor, GroupModelChangeKind, SideBySideEditor } from '../../common/editor.js';\nimport { DiffEditorInput } from '../../common/editor/diffEditorInput.js';\nimport { isGroupEditorMoveEvent } from '../../common/editor/editorGroupModel.js';\nimport { EditorInput } from '../../common/editor/editorInput.js';\nimport { SideBySideEditorInput } from '../../common/editor/sideBySideEditorInput.js';\nimport { AbstractTextResourceEditorInput } from '../../common/editor/textResourceEditorInput.js';\nimport { ChatEditorInput } from '../../contrib/chat/browser/chatEditorInput.js';\nimport { CustomEditorInput } from '../../contrib/customEditor/browser/customEditorInput.js';\nimport { InteractiveEditorInput } from '../../contrib/interactive/browser/interactiveEditorInput.js';\nimport { MergeEditorInput } from '../../contrib/mergeEditor/browser/mergeEditorInput.js';\nimport { MultiDiffEditorInput } from '../../contrib/multiDiffEditor/browser/multiDiffEditorInput.js';\nimport { NotebookEditorInput } from '../../contrib/notebook/common/notebookEditorInput.js';\nimport { TerminalEditorInput } from '../../contrib/terminal/browser/terminalEditorInput.js';\nimport { WebviewInput } from '../../contrib/webviewPanel/browser/webviewEditorInput.js';\nimport { columnToEditorGroup, EditorGroupColumn, editorGroupToColumn } from '../../services/editor/common/editorGroupColumn.js';\nimport { GroupDirection, IEditorGroup, IEditorGroupsService, preferredSideBySideGroupDirection } from '../../services/editor/common/editorGroupsService.js';\nimport { IEditorsChangeEvent, IEditorService, SIDE_GROUP } from '../../services/editor/common/editorService.js';\nimport { extHostNamedCustomer, IExtHostContext } from '../../services/extensions/common/extHostCustomers.js';\n\ninterface TabInfo {\n\ttab: IEditorTabDto;\n\tgroup: IEditorGroup;\n\teditorInput: EditorInput;\n}\n@extHostNamedCustomer(MainContext.MainThreadEditorTabs)\nexport class MainThreadEditorTabs implements MainThreadEditorTabsShape {\n\n\tprivate readonly _dispoables = new DisposableStore();\n\tprivate readonly _proxy: IExtHostEditorTabsShape;\n\t// List of all groups and their corresponding tabs, this is **the** model\n\tprivate _tabGroupModel: IEditorTabGroupDto[] = [];\n\t// Lookup table for finding group by id\n\tprivate readonly _groupLookup: Map<number, IEditorTabGroupDto> = new Map();\n\t// Lookup table for finding tab by id\n\tprivate readonly _tabInfoLookup: Map<string, TabInfo> = new Map();\n\t// Tracks the currently open MultiDiffEditorInputs to listen to resource changes\n\tprivate readonly _multiDiffEditorInputListeners: DisposableMap<MultiDiffEditorInput> = new DisposableMap();\n\n\tconstructor(\n\t\textHostContext: IExtHostContext,\n\t\t@IEditorGroupsService private readonly _editorGroupsService: IEditorGroupsService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IEditorService editorService: IEditorService\n\t) {\n\n\t\tthis._proxy = extHostContext.getProxy(ExtHostContext.ExtHostEditorTabs);\n\n\t\t// Main listener which responds to events from the editor service\n\t\tthis._dispoables.add(editorService.onDidEditorsChange((event) => {\n\t\t\ttry {\n\t\t\t\tthis._updateTabsModel(event);\n\t\t\t} catch {\n\t\t\t\tthis._logService.error('Failed to update model, rebuilding');\n\t\t\t\tthis._createTabsModel();\n\t\t\t}\n\t\t}));\n\n\t\tthis._dispoables.add(this._multiDiffEditorInputListeners);\n\n\t\t// Structural group changes (add, remove, move, etc) are difficult to patch.\n\t\t// Since they happen infrequently we just rebuild the entire model\n\t\tthis._dispoables.add(this._editorGroupsService.onDidAddGroup(() => this._createTabsModel()));\n\t\tthis._dispoables.add(this._editorGroupsService.onDidRemoveGroup(() => this._createTabsModel()));\n\n\t\t// Once everything is read go ahead and initialize the model\n\t\tthis._editorGroupsService.whenReady.then(() => this._createTabsModel());\n\t}\n\n\tdispose(): void {\n\t\tthis._groupLookup.clear();\n\t\tthis._tabInfoLookup.clear();\n\t\tthis._dispoables.dispose();\n\t}\n\n\t/**\n\t * Creates a tab object with the correct properties\n\t * @param editor The editor input represented by the tab\n\t * @param group The group the tab is in\n\t * @returns A tab object\n\t */\n\tprivate _buildTabObject(group: IEditorGroup, editor: EditorInput, editorIndex: number): IEditorTabDto {\n\t\tconst editorId = editor.editorId;\n\t\tconst tab: IEditorTabDto = {\n\t\t\tid: this._generateTabId(editor, group.id),\n\t\t\tlabel: editor.getName(),\n\t\t\teditorId,\n\t\t\tinput: this._editorInputToDto(editor),\n\t\t\tisPinned: group.isSticky(editorIndex),\n\t\t\tisPreview: !group.isPinned(editorIndex),\n\t\t\tisActive: group.isActive(editor),\n\t\t\tisDirty: editor.isDirty()\n\t\t};\n\t\treturn tab;\n\t}\n\n\tprivate _editorInputToDto(editor: EditorInput): AnyInputDto {\n\n\t\tif (editor instanceof MergeEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.TextMergeInput,\n\t\t\t\tbase: editor.base,\n\t\t\t\tinput1: editor.input1.uri,\n\t\t\t\tinput2: editor.input2.uri,\n\t\t\t\tresult: editor.resource\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof AbstractTextResourceEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.TextInput,\n\t\t\t\turi: editor.resource\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof SideBySideEditorInput && !(editor instanceof DiffEditorInput)) {\n\t\t\tconst primaryResource = editor.primary.resource;\n\t\t\tconst secondaryResource = editor.secondary.resource;\n\t\t\t// If side by side editor with same resource on both sides treat it as a singular tab kind\n\t\t\tif (editor.primary instanceof AbstractTextResourceEditorInput\n\t\t\t\t&& editor.secondary instanceof AbstractTextResourceEditorInput\n\t\t\t\t&& isEqual(primaryResource, secondaryResource)\n\t\t\t\t&& primaryResource\n\t\t\t\t&& secondaryResource\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: TabInputKind.TextInput,\n\t\t\t\t\turi: primaryResource\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn { kind: TabInputKind.UnknownInput };\n\t\t}\n\n\t\tif (editor instanceof NotebookEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.NotebookInput,\n\t\t\t\tnotebookType: editor.viewType,\n\t\t\t\turi: editor.resource\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof CustomEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.CustomEditorInput,\n\t\t\t\tviewType: editor.viewType,\n\t\t\t\turi: editor.resource,\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof WebviewInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.WebviewEditorInput,\n\t\t\t\tviewType: editor.viewType\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof TerminalEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.TerminalEditorInput\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof DiffEditorInput) {\n\t\t\tif (editor.modified instanceof AbstractTextResourceEditorInput && editor.original instanceof AbstractTextResourceEditorInput) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: TabInputKind.TextDiffInput,\n\t\t\t\t\tmodified: editor.modified.resource,\n\t\t\t\t\toriginal: editor.original.resource\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (editor.modified instanceof NotebookEditorInput && editor.original instanceof NotebookEditorInput) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: TabInputKind.NotebookDiffInput,\n\t\t\t\t\tnotebookType: editor.original.viewType,\n\t\t\t\t\tmodified: editor.modified.resource,\n\t\t\t\t\toriginal: editor.original.resource\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (editor instanceof InteractiveEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.InteractiveEditorInput,\n\t\t\t\turi: editor.resource,\n\t\t\t\tinputBoxUri: editor.inputResource\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof ChatEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.ChatEditorInput,\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof MultiDiffEditorInput) {\n\t\t\tconst diffEditors: TextDiffInputDto[] = [];\n\t\t\tfor (const resource of (editor?.resources.get() ?? [])) {\n\t\t\t\tif (resource.originalUri && resource.modifiedUri) {\n\t\t\t\t\tdiffEditors.push({\n\t\t\t\t\t\tkind: TabInputKind.TextDiffInput,\n\t\t\t\t\t\toriginal: resource.originalUri,\n\t\t\t\t\t\tmodified: resource.modifiedUri\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.MultiDiffEditorInput,\n\t\t\t\tdiffEditors\n\t\t\t};\n\t\t}\n\n\t\treturn { kind: TabInputKind.UnknownInput };\n\t}\n\n\t/**\n\t * Generates a unique id for a tab\n\t * @param editor The editor input\n\t * @param groupId The group id\n\t * @returns A unique identifier for a specific tab\n\t */\n\tprivate _generateTabId(editor: EditorInput, groupId: number) {\n\t\tlet resourceString: string | undefined;\n\t\t// Properly get the resource and account for side by side editors\n\t\tconst resource = EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.BOTH });\n\t\tif (resource instanceof URI) {\n\t\t\tresourceString = resource.toString();\n\t\t} else {\n\t\t\tresourceString = `${resource?.primary?.toString()}-${resource?.secondary?.toString()}`;\n\t\t}\n\t\treturn `${groupId}~${editor.editorId}-${editor.typeId}-${resourceString} `;\n\t}\n\n\t/**\n\t * Called whenever a group activates, updates the model by marking the group as active an notifies the extension host\n\t */\n\tprivate _onDidGroupActivate() {\n\t\tconst activeGroupId = this._editorGroupsService.activeGroup.id;\n\t\tconst activeGroup = this._groupLookup.get(activeGroupId);\n\t\tif (activeGroup) {\n\t\t\t// Ok not to loop as exthost accepts last active group\n\t\t\tactiveGroup.isActive = true;\n\t\t\tthis._proxy.$acceptTabGroupUpdate(activeGroup);\n\t\t}\n\t}\n\n\t/**\n\t * Called when the tab label changes\n\t * @param groupId The id of the group the tab exists in\n\t * @param editorInput The editor input represented by the tab\n\t */\n\tprivate _onDidTabLabelChange(groupId: number, editorInput: EditorInput, editorIndex: number) {\n\t\tconst tabId = this._generateTabId(editorInput, groupId);\n\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\t// If tab is found patch, else rebuild\n\t\tif (tabInfo) {\n\t\t\ttabInfo.tab.label = editorInput.getName();\n\t\t\tthis._proxy.$acceptTabOperation({\n\t\t\t\tgroupId,\n\t\t\t\tindex: editorIndex,\n\t\t\t\ttabDto: tabInfo.tab,\n\t\t\t\tkind: TabModelOperationKind.TAB_UPDATE\n\t\t\t});\n\t\t} else {\n\t\t\tthis._logService.error('Invalid model for label change, rebuilding');\n\t\t\tthis._createTabsModel();\n\t\t}\n\t}\n\n\t/**\n\t * Called when a new tab is opened\n\t * @param groupId The id of the group the tab is being created in\n\t * @param editorInput The editor input being opened\n\t * @param editorIndex The index of the editor within that group\n\t */\n\tprivate _onDidTabOpen(groupId: number, editorInput: EditorInput, editorIndex: number) {\n\t\tconst group = this._editorGroupsService.getGroup(groupId);\n\t\t// Even if the editor service knows about the group the group might not exist yet in our model\n\t\tconst groupInModel = this._groupLookup.get(groupId) !== undefined;\n\t\t// Means a new group was likely created so we rebuild the model\n\t\tif (!group || !groupInModel) {\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\t\tconst tabs = this._groupLookup.get(groupId)?.tabs;\n\t\tif (!tabs) {\n\t\t\treturn;\n\t\t}\n\t\t// Splice tab into group at index editorIndex\n\t\tconst tabObject = this._buildTabObject(group, editorInput, editorIndex);\n\t\ttabs.splice(editorIndex, 0, tabObject);\n\t\t// Update lookup\n\t\tconst tabId = this._generateTabId(editorInput, groupId);\n\t\tthis._tabInfoLookup.set(tabId, { group, editorInput, tab: tabObject });\n\n\t\tif (editorInput instanceof MultiDiffEditorInput) {\n\t\t\tthis._multiDiffEditorInputListeners.set(editorInput, Event.fromObservableLight(editorInput.resources)(() => {\n\t\t\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\t\t\tif (!tabInfo) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttabInfo.tab = this._buildTabObject(group, editorInput, editorIndex);\n\t\t\t\tthis._proxy.$acceptTabOperation({\n\t\t\t\t\tgroupId,\n\t\t\t\t\tindex: editorIndex,\n\t\t\t\t\ttabDto: tabInfo.tab,\n\t\t\t\t\tkind: TabModelOperationKind.TAB_UPDATE\n\t\t\t\t});\n\t\t\t}));\n\t\t}\n\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tgroupId,\n\t\t\tindex: editorIndex,\n\t\t\ttabDto: tabObject,\n\t\t\tkind: TabModelOperationKind.TAB_OPEN\n\t\t});\n\t}\n\n\t/**\n\t * Called when a tab is closed\n\t * @param groupId The id of the group the tab is being removed from\n\t * @param editorIndex The index of the editor within that group\n\t */\n\tprivate _onDidTabClose(groupId: number, editorIndex: number) {\n\t\tconst group = this._editorGroupsService.getGroup(groupId);\n\t\tconst tabs = this._groupLookup.get(groupId)?.tabs;\n\t\t// Something is wrong with the model state so we rebuild\n\t\tif (!group || !tabs) {\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\t\t// Splice tab into group at index editorIndex\n\t\tconst removedTab = tabs.splice(editorIndex, 1);\n\n\t\t// Index must no longer be valid so we return prematurely\n\t\tif (removedTab.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update lookup\n\t\tthis._tabInfoLookup.delete(removedTab[0]?.id ?? '');\n\n\t\tif (removedTab[0]?.input instanceof MultiDiffEditorInput) {\n\t\t\tthis._multiDiffEditorInputListeners.deleteAndDispose(removedTab[0]?.input);\n\t\t}\n\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tgroupId,\n\t\t\tindex: editorIndex,\n\t\t\ttabDto: removedTab[0],\n\t\t\tkind: TabModelOperationKind.TAB_CLOSE\n\t\t});\n\t}\n\n\t/**\n\t * Called when the active tab changes\n\t * @param groupId The id of the group the tab is contained in\n\t * @param editorIndex The index of the tab\n\t */\n\tprivate _onDidTabActiveChange(groupId: number, editorIndex: number) {\n\t\t// TODO @lramos15 use the tab lookup here if possible. Do we have an editor input?!\n\t\tconst tabs = this._groupLookup.get(groupId)?.tabs;\n\t\tif (!tabs) {\n\t\t\treturn;\n\t\t}\n\t\tconst activeTab = tabs[editorIndex];\n\t\t// No need to loop over as the exthost uses the most recently marked active tab\n\t\tactiveTab.isActive = true;\n\t\t// Send DTO update to the exthost\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tgroupId,\n\t\t\tindex: editorIndex,\n\t\t\ttabDto: activeTab,\n\t\t\tkind: TabModelOperationKind.TAB_UPDATE\n\t\t});\n\n\t}\n\n\t/**\n\t * Called when the dirty indicator on the tab changes\n\t * @param groupId The id of the group the tab is in\n\t * @param editorIndex The index of the tab\n\t * @param editor The editor input represented by the tab\n\t */\n\tprivate _onDidTabDirty(groupId: number, editorIndex: number, editor: EditorInput) {\n\t\tconst tabId = this._generateTabId(editor, groupId);\n\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\t// Something wrong with the model state so we rebuild\n\t\tif (!tabInfo) {\n\t\t\tthis._logService.error('Invalid model for dirty change, rebuilding');\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\t\ttabInfo.tab.isDirty = editor.isDirty();\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tgroupId,\n\t\t\tindex: editorIndex,\n\t\t\ttabDto: tabInfo.tab,\n\t\t\tkind: TabModelOperationKind.TAB_UPDATE\n\t\t});\n\t}\n\n\t/**\n\t * Called when the tab is pinned/unpinned\n\t * @param groupId The id of the group the tab is in\n\t * @param editorIndex The index of the tab\n\t * @param editor The editor input represented by the tab\n\t */\n\tprivate _onDidTabPinChange(groupId: number, editorIndex: number, editor: EditorInput) {\n\t\tconst tabId = this._generateTabId(editor, groupId);\n\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\tconst group = tabInfo?.group;\n\t\tconst tab = tabInfo?.tab;\n\t\t// Something wrong with the model state so we rebuild\n\t\tif (!group || !tab) {\n\t\t\tthis._logService.error('Invalid model for sticky change, rebuilding');\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\t\t// Whether or not the tab has the pin icon (internally it's called sticky)\n\t\ttab.isPinned = group.isSticky(editorIndex);\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tgroupId,\n\t\t\tindex: editorIndex,\n\t\t\ttabDto: tab,\n\t\t\tkind: TabModelOperationKind.TAB_UPDATE\n\t\t});\n\t}\n\n\t/**\n * Called when the tab is preview / unpreviewed\n * @param groupId The id of the group the tab is in\n * @param editorIndex The index of the tab\n * @param editor The editor input represented by the tab\n */\n\tprivate _onDidTabPreviewChange(groupId: number, editorIndex: number, editor: EditorInput) {\n\t\tconst tabId = this._generateTabId(editor, groupId);\n\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\tconst group = tabInfo?.group;\n\t\tconst tab = tabInfo?.tab;\n\t\t// Something wrong with the model state so we rebuild\n\t\tif (!group || !tab) {\n\t\t\tthis._logService.error('Invalid model for sticky change, rebuilding');\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\t\t// Whether or not the tab has the pin icon (internally it's called pinned)\n\t\ttab.isPreview = !group.isPinned(editorIndex);\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tkind: TabModelOperationKind.TAB_UPDATE,\n\t\t\tgroupId,\n\t\t\ttabDto: tab,\n\t\t\tindex: editorIndex\n\t\t});\n\t}\n\n\tprivate _onDidTabMove(groupId: number, editorIndex: number, oldEditorIndex: number, editor: EditorInput) {\n\t\tconst tabs = this._groupLookup.get(groupId)?.tabs;\n\t\t// Something wrong with the model state so we rebuild\n\t\tif (!tabs) {\n\t\t\tthis._logService.error('Invalid model for move change, rebuilding');\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\n\t\t// Move tab from old index to new index\n\t\tconst removedTab = tabs.splice(oldEditorIndex, 1);\n\t\tif (removedTab.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\ttabs.splice(editorIndex, 0, removedTab[0]);\n\n\t\t// Notify exthost of move\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tkind: TabModelOperationKind.TAB_MOVE,\n\t\t\tgroupId,\n\t\t\ttabDto: removedTab[0],\n\t\t\tindex: editorIndex,\n\t\t\toldIndex: oldEditorIndex\n\t\t});\n\t}\n\n\t/**\n\t * Builds the model from scratch based on the current state of the editor service.\n\t */\n\tprivate _createTabsModel(): void {\n\t\tif (this._editorGroupsService.groups.length === 0) {\n\t\t\treturn; // skip this invalid state, it may happen when the entire editor area is transitioning to other state (\"editor working sets\")\n\t\t}\n\n\t\tthis._tabGroupModel = [];\n\t\tthis._groupLookup.clear();\n\t\tthis._tabInfoLookup.clear();\n\t\tlet tabs: IEditorTabDto[] = [];\n\t\tfor (const group of this._editorGroupsService.groups) {\n\t\t\tconst currentTabGroupModel: IEditorTabGroupDto = {\n\t\t\t\tgroupId: group.id,\n\t\t\t\tisActive: group.id === this._editorGroupsService.activeGroup.id,\n\t\t\t\tviewColumn: editorGroupToColumn(this._editorGroupsService, group),\n\t\t\t\ttabs: []\n\t\t\t};\n\t\t\tgroup.editors.forEach((editor, editorIndex) => {\n\t\t\t\tconst tab = this._buildTabObject(group, editor, editorIndex);\n\t\t\t\ttabs.push(tab);\n\t\t\t\t// Add information about the tab to the lookup\n\t\t\t\tthis._tabInfoLookup.set(this._generateTabId(editor, group.id), {\n\t\t\t\t\tgroup,\n\t\t\t\t\ttab,\n\t\t\t\t\teditorInput: editor\n\t\t\t\t});\n\t\t\t});\n\t\t\tcurrentTabGroupModel.tabs = tabs;\n\t\t\tthis._tabGroupModel.push(currentTabGroupModel);\n\t\t\tthis._groupLookup.set(group.id, currentTabGroupModel);\n\t\t\ttabs = [];\n\t\t}\n\t\t// notify the ext host of the new model\n\t\tthis._proxy.$acceptEditorTabModel(this._tabGroupModel);\n\t}\n\n\t// TODOD @lramos15 Remove this after done finishing the tab model code\n\t// private _eventToString(event: IEditorsChangeEvent | IEditorsMoveEvent): string {\n\t// \tlet eventString = '';\n\t// \tswitch (event.kind) {\n\t// \t\tcase GroupModelChangeKind.GROUP_INDEX: eventString += 'GROUP_INDEX'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_ACTIVE: eventString += 'EDITOR_ACTIVE'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_PIN: eventString += 'EDITOR_PIN'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_OPEN: eventString += 'EDITOR_OPEN'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_CLOSE: eventString += 'EDITOR_CLOSE'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_MOVE: eventString += 'EDITOR_MOVE'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_LABEL: eventString += 'EDITOR_LABEL'; break;\n\t// \t\tcase GroupModelChangeKind.GROUP_ACTIVE: eventString += 'GROUP_ACTIVE'; break;\n\t// \t\tcase GroupModelChangeKind.GROUP_LOCKED: eventString += 'GROUP_LOCKED'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_DIRTY: eventString += 'EDITOR_DIRTY'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_STICKY: eventString += 'EDITOR_STICKY'; break;\n\t// \t\tdefault: eventString += `UNKNOWN: ${event.kind}`; break;\n\t// \t}\n\t// \treturn eventString;\n\t// }\n\n\t/**\n\t * The main handler for the tab events\n\t * @param events The list of events to process\n\t */\n\tprivate _updateTabsModel(changeEvent: IEditorsChangeEvent): void {\n\t\tconst event = changeEvent.event;\n\t\tconst groupId = changeEvent.groupId;\n\t\tswitch (event.kind) {\n\t\t\tcase GroupModelChangeKind.GROUP_ACTIVE:\n\t\t\t\tif (groupId === this._editorGroupsService.activeGroup.id) {\n\t\t\t\t\tthis._onDidGroupActivate();\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_LABEL:\n\t\t\t\tif (event.editor !== undefined && event.editorIndex !== undefined) {\n\t\t\t\t\tthis._onDidTabLabelChange(groupId, event.editor, event.editorIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_OPEN:\n\t\t\t\tif (event.editor !== undefined && event.editorIndex !== undefined) {\n\t\t\t\t\tthis._onDidTabOpen(groupId, event.editor, event.editorIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_CLOSE:\n\t\t\t\tif (event.editorIndex !== undefined) {\n\t\t\t\t\tthis._onDidTabClose(groupId, event.editorIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_ACTIVE:\n\t\t\t\tif (event.editorIndex !== undefined) {\n\t\t\t\t\tthis._onDidTabActiveChange(groupId, event.editorIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_DIRTY:\n\t\t\t\tif (event.editorIndex !== undefined && event.editor !== undefined) {\n\t\t\t\t\tthis._onDidTabDirty(groupId, event.editorIndex, event.editor);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_STICKY:\n\t\t\t\tif (event.editorIndex !== undefined && event.editor !== undefined) {\n\t\t\t\t\tthis._onDidTabPinChange(groupId, event.editorIndex, event.editor);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_PIN:\n\t\t\t\tif (event.editorIndex !== undefined && event.editor !== undefined) {\n\t\t\t\t\tthis._onDidTabPreviewChange(groupId, event.editorIndex, event.editor);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_TRANSIENT:\n\t\t\t\t// Currently not exposed in the API\n\t\t\t\tbreak;\n\t\t\tcase GroupModelChangeKind.EDITOR_MOVE:\n\t\t\t\tif (isGroupEditorMoveEvent(event) && event.editor && event.editorIndex !== undefined && event.oldEditorIndex !== undefined) {\n\t\t\t\t\tthis._onDidTabMove(groupId, event.editorIndex, event.oldEditorIndex, event.editor);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// If it's not an optimized case we rebuild the tabs model from scratch\n\t\t\t\tthis._createTabsModel();\n\t\t}\n\t}\n\t//#region Messages received from Ext Host\n\t$moveTab(tabId: string, index: number, viewColumn: EditorGroupColumn, preserveFocus?: boolean): void {\n\t\tconst groupId = columnToEditorGroup(this._editorGroupsService, this._configurationService, viewColumn);\n\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\tconst tab = tabInfo?.tab;\n\t\tif (!tab) {\n\t\t\tthrow new Error(`Attempted to close tab with id ${tabId} which does not exist`);\n\t\t}\n\t\tlet targetGroup: IEditorGroup | undefined;\n\t\tconst sourceGroup = this._editorGroupsService.getGroup(tabInfo.group.id);\n\t\tif (!sourceGroup) {\n\t\t\treturn;\n\t\t}\n\t\t// If group index is out of bounds then we make a new one that's to the right of the last group\n\t\tif (this._groupLookup.get(groupId) === undefined) {\n\t\t\tlet direction = GroupDirection.RIGHT;\n\t\t\t// Make sure we respect the user's preferred side direction\n\t\t\tif (viewColumn === SIDE_GROUP) {\n\t\t\t\tdirection = preferredSideBySideGroupDirection(this._configurationService);\n\t\t\t}\n\t\t\ttargetGroup = this._editorGroupsService.addGroup(this._editorGroupsService.groups[this._editorGroupsService.groups.length - 1], direction);\n\t\t} else {\n\t\t\ttargetGroup = this._editorGroupsService.getGroup(groupId);\n\t\t}\n\t\tif (!targetGroup) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Similar logic to if index is out of bounds we place it at the end\n\t\tif (index < 0 || index > targetGroup.editors.length) {\n\t\t\tindex = targetGroup.editors.length;\n\t\t}\n\t\t// Find the correct EditorInput using the tab info\n\t\tconst editorInput = tabInfo?.editorInput;\n\t\tif (!editorInput) {\n\t\t\treturn;\n\t\t}\n\t\t// Move the editor to the target group\n\t\tsourceGroup.moveEditor(editorInput, targetGroup, { index, preserveFocus });\n\t\treturn;\n\t}\n\n\tasync $closeTab(tabIds: string[], preserveFocus?: boolean): Promise<boolean> {\n\t\tconst groups: Map<IEditorGroup, EditorInput[]> = new Map();\n\t\tfor (const tabId of tabIds) {\n\t\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\t\tconst tab = tabInfo?.tab;\n\t\t\tconst group = tabInfo?.group;\n\t\t\tconst editorTab = tabInfo?.editorInput;\n\t\t\t// If not found skip\n\t\t\tif (!group || !tab || !tabInfo || !editorTab) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst groupEditors = groups.get(group);\n\t\t\tif (!groupEditors) {\n\t\t\t\tgroups.set(group, [editorTab]);\n\t\t\t} else {\n\t\t\t\tgroupEditors.push(editorTab);\n\t\t\t}\n\t\t}\n\t\t// Loop over keys of the groups map and call closeEditors\n\t\tconst results: boolean[] = [];\n\t\tfor (const [group, editors] of groups) {\n\t\t\tresults.push(await group.closeEditors(editors, { preserveFocus }));\n\t\t}\n\t\t// TODO @jrieken This isn't quite right how can we say true for some but not others?\n\t\treturn results.every(result => result);\n\t}\n\n\tasync $closeGroup(groupIds: number[], preserveFocus?: boolean): Promise<boolean> {\n\t\tconst groupCloseResults: boolean[] = [];\n\t\tfor (const groupId of groupIds) {\n\t\t\tconst group = this._editorGroupsService.getGroup(groupId);\n\t\t\tif (group) {\n\t\t\t\tgroupCloseResults.push(await group.closeAllEditors());\n\t\t\t\t// Make sure group is empty but still there before removing it\n\t\t\t\tif (group.count === 0 && this._editorGroupsService.getGroup(group.id)) {\n\t\t\t\t\tthis._editorGroupsService.removeGroup(group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn groupCloseResults.every(result => result);\n\t}\n\t//#endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { isEqual } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { AnyInputDto, ExtHostContext, IEditorTabDto, IEditorTabGroupDto, IExtHostEditorTabsShape, MainContext, MainThreadEditorTabsShape, TabInputKind, TabModelOperationKind, TextDiffInputDto } from '../common/extHost.protocol.js';\nimport { EditorResourceAccessor, GroupModelChangeKind, SideBySideEditor } from '../../common/editor.js';\nimport { DiffEditorInput } from '../../common/editor/diffEditorInput.js';\nimport { isGroupEditorMoveEvent } from '../../common/editor/editorGroupModel.js';\nimport { EditorInput } from '../../common/editor/editorInput.js';\nimport { SideBySideEditorInput } from '../../common/editor/sideBySideEditorInput.js';\nimport { AbstractTextResourceEditorInput } from '../../common/editor/textResourceEditorInput.js';\nimport { ChatEditorInput } from '../../contrib/chat/browser/chatEditorInput.js';\nimport { CustomEditorInput } from '../../contrib/customEditor/browser/customEditorInput.js';\nimport { InteractiveEditorInput } from '../../contrib/interactive/browser/interactiveEditorInput.js';\nimport { MergeEditorInput } from '../../contrib/mergeEditor/browser/mergeEditorInput.js';\nimport { MultiDiffEditorInput } from '../../contrib/multiDiffEditor/browser/multiDiffEditorInput.js';\nimport { NotebookEditorInput } from '../../contrib/notebook/common/notebookEditorInput.js';\nimport { TerminalEditorInput } from '../../contrib/terminal/browser/terminalEditorInput.js';\nimport { WebviewInput } from '../../contrib/webviewPanel/browser/webviewEditorInput.js';\nimport { columnToEditorGroup, EditorGroupColumn, editorGroupToColumn } from '../../services/editor/common/editorGroupColumn.js';\nimport { GroupDirection, IEditorGroup, IEditorGroupsService, preferredSideBySideGroupDirection } from '../../services/editor/common/editorGroupsService.js';\nimport { IEditorsChangeEvent, IEditorService, SIDE_GROUP } from '../../services/editor/common/editorService.js';\nimport { extHostNamedCustomer, IExtHostContext } from '../../services/extensions/common/extHostCustomers.js';\n\ninterface TabInfo {\n\ttab: IEditorTabDto;\n\tgroup: IEditorGroup;\n\teditorInput: EditorInput;\n}\n@extHostNamedCustomer(MainContext.MainThreadEditorTabs)\nexport class MainThreadEditorTabs implements MainThreadEditorTabsShape {\n\n\tprivate readonly _dispoables = new DisposableStore();\n\tprivate readonly _proxy: IExtHostEditorTabsShape;\n\t// List of all groups and their corresponding tabs, this is **the** model\n\tprivate _tabGroupModel: IEditorTabGroupDto[] = [];\n\t// Lookup table for finding group by id\n\tprivate readonly _groupLookup: Map<number, IEditorTabGroupDto> = new Map();\n\t// Lookup table for finding tab by id\n\tprivate readonly _tabInfoLookup: Map<string, TabInfo> = new Map();\n\t// Tracks the currently open MultiDiffEditorInputs to listen to resource changes\n\tprivate readonly _multiDiffEditorInputListeners: DisposableMap<MultiDiffEditorInput> = new DisposableMap();\n\n\tconstructor(\n\t\textHostContext: IExtHostContext,\n\t\t@IEditorGroupsService private readonly _editorGroupsService: IEditorGroupsService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IEditorService editorService: IEditorService\n\t) {\n\n\t\tthis._proxy = extHostContext.getProxy(ExtHostContext.ExtHostEditorTabs);\n\n\t\t// Main listener which responds to events from the editor service\n\t\tthis._dispoables.add(editorService.onDidEditorsChange((event) => {\n\t\t\ttry {\n\t\t\t\tthis._updateTabsModel(event);\n\t\t\t} catch {\n\t\t\t\tthis._logService.error('Failed to update model, rebuilding');\n\t\t\t\tthis._createTabsModel();\n\t\t\t}\n\t\t}));\n\n\t\tthis._dispoables.add(this._multiDiffEditorInputListeners);\n\n\t\t// Structural group changes (add, remove, move, etc) are difficult to patch.\n\t\t// Since they happen infrequently we just rebuild the entire model\n\t\tthis._dispoables.add(this._editorGroupsService.onDidAddGroup(() => this._createTabsModel()));\n\t\tthis._dispoables.add(this._editorGroupsService.onDidRemoveGroup(() => this._createTabsModel()));\n\n\t\t// Once everything is read go ahead and initialize the model\n\t\tthis._editorGroupsService.whenReady.then(() => this._createTabsModel());\n\t}\n\n\tdispose(): void {\n\t\tthis._groupLookup.clear();\n\t\tthis._tabInfoLookup.clear();\n\t\tthis._dispoables.dispose();\n\t}\n\n\t/**\n\t * Creates a tab object with the correct properties\n\t * @param editor The editor input represented by the tab\n\t * @param group The group the tab is in\n\t * @returns A tab object\n\t */\n\tprivate _buildTabObject(group: IEditorGroup, editor: EditorInput, editorIndex: number): IEditorTabDto {\n\t\tconst editorId = editor.editorId;\n\t\tconst tab: IEditorTabDto = {\n\t\t\tid: this._generateTabId(editor, group.id),\n\t\t\tlabel: editor.getName(),\n\t\t\teditorId,\n\t\t\tinput: this._editorInputToDto(editor),\n\t\t\tisPinned: group.isSticky(editorIndex),\n\t\t\tisPreview: !group.isPinned(editorIndex),\n\t\t\tisActive: group.isActive(editor),\n\t\t\tisDirty: editor.isDirty()\n\t\t};\n\t\treturn tab;\n\t}\n\n\tprivate _editorInputToDto(editor: EditorInput): AnyInputDto {\n\n\t\tif (editor instanceof MergeEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.TextMergeInput,\n\t\t\t\tbase: editor.base,\n\t\t\t\tinput1: editor.input1.uri,\n\t\t\t\tinput2: editor.input2.uri,\n\t\t\t\tresult: editor.resource\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof AbstractTextResourceEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.TextInput,\n\t\t\t\turi: editor.resource\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof SideBySideEditorInput && !(editor instanceof DiffEditorInput)) {\n\t\t\tconst primaryResource = editor.primary.resource;\n\t\t\tconst secondaryResource = editor.secondary.resource;\n\t\t\t// If side by side editor with same resource on both sides treat it as a singular tab kind\n\t\t\tif (editor.primary instanceof AbstractTextResourceEditorInput\n\t\t\t\t&& editor.secondary instanceof AbstractTextResourceEditorInput\n\t\t\t\t&& isEqual(primaryResource, secondaryResource)\n\t\t\t\t&& primaryResource\n\t\t\t\t&& secondaryResource\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: TabInputKind.TextInput,\n\t\t\t\t\turi: primaryResource\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn { kind: TabInputKind.UnknownInput };\n\t\t}\n\n\t\tif (editor instanceof NotebookEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.NotebookInput,\n\t\t\t\tnotebookType: editor.viewType,\n\t\t\t\turi: editor.resource\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof CustomEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.CustomEditorInput,\n\t\t\t\tviewType: editor.viewType,\n\t\t\t\turi: editor.resource,\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof WebviewInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.WebviewEditorInput,\n\t\t\t\tviewType: editor.viewType\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof TerminalEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.TerminalEditorInput\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof DiffEditorInput) {\n\t\t\tif (editor.modified instanceof AbstractTextResourceEditorInput && editor.original instanceof AbstractTextResourceEditorInput) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: TabInputKind.TextDiffInput,\n\t\t\t\t\tmodified: editor.modified.resource,\n\t\t\t\t\toriginal: editor.original.resource\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (editor.modified instanceof NotebookEditorInput && editor.original instanceof NotebookEditorInput) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: TabInputKind.NotebookDiffInput,\n\t\t\t\t\tnotebookType: editor.original.viewType,\n\t\t\t\t\tmodified: editor.modified.resource,\n\t\t\t\t\toriginal: editor.original.resource\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (editor instanceof InteractiveEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.InteractiveEditorInput,\n\t\t\t\turi: editor.resource,\n\t\t\t\tinputBoxUri: editor.inputResource\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof ChatEditorInput) {\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.ChatEditorInput,\n\t\t\t};\n\t\t}\n\n\t\tif (editor instanceof MultiDiffEditorInput) {\n\t\t\tconst diffEditors: TextDiffInputDto[] = [];\n\t\t\tfor (const resource of (editor?.resources.get() ?? [])) {\n\t\t\t\tif (resource.originalUri && resource.modifiedUri) {\n\t\t\t\t\tdiffEditors.push({\n\t\t\t\t\t\tkind: TabInputKind.TextDiffInput,\n\t\t\t\t\t\toriginal: resource.originalUri,\n\t\t\t\t\t\tmodified: resource.modifiedUri\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tkind: TabInputKind.MultiDiffEditorInput,\n\t\t\t\tdiffEditors\n\t\t\t};\n\t\t}\n\n\t\treturn { kind: TabInputKind.UnknownInput };\n\t}\n\n\t/**\n\t * Generates a unique id for a tab\n\t * @param editor The editor input\n\t * @param groupId The group id\n\t * @returns A unique identifier for a specific tab\n\t */\n\tprivate _generateTabId(editor: EditorInput, groupId: number) {\n\t\tlet resourceString: string | undefined;\n\t\t// Properly get the resource and account for side by side editors\n\t\tconst resource = EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.BOTH });\n\t\tif (resource instanceof URI) {\n\t\t\tresourceString = resource.toString();\n\t\t} else {\n\t\t\tresourceString = `${resource?.primary?.toString()}-${resource?.secondary?.toString()}`;\n\t\t}\n\t\treturn `${groupId}~${editor.editorId}-${editor.typeId}-${resourceString} `;\n\t}\n\n\t/**\n\t * Called whenever a group activates, updates the model by marking the group as active an notifies the extension host\n\t */\n\tprivate _onDidGroupActivate() {\n\t\tconst activeGroupId = this._editorGroupsService.activeGroup.id;\n\t\tconst activeGroup = this._groupLookup.get(activeGroupId);\n\t\tif (activeGroup) {\n\t\t\t// Ok not to loop as exthost accepts last active group\n\t\t\tactiveGroup.isActive = true;\n\t\t\tthis._proxy.$acceptTabGroupUpdate(activeGroup);\n\t\t}\n\t}\n\n\t/**\n\t * Called when the tab label changes\n\t * @param groupId The id of the group the tab exists in\n\t * @param editorInput The editor input represented by the tab\n\t */\n\tprivate _onDidTabLabelChange(groupId: number, editorInput: EditorInput, editorIndex: number) {\n\t\tconst tabId = this._generateTabId(editorInput, groupId);\n\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\t// If tab is found patch, else rebuild\n\t\tif (tabInfo) {\n\t\t\ttabInfo.tab.label = editorInput.getName();\n\t\t\tthis._proxy.$acceptTabOperation({\n\t\t\t\tgroupId,\n\t\t\t\tindex: editorIndex,\n\t\t\t\ttabDto: tabInfo.tab,\n\t\t\t\tkind: TabModelOperationKind.TAB_UPDATE\n\t\t\t});\n\t\t} else {\n\t\t\tthis._logService.error('Invalid model for label change, rebuilding');\n\t\t\tthis._createTabsModel();\n\t\t}\n\t}\n\n\t/**\n\t * Called when a new tab is opened\n\t * @param groupId The id of the group the tab is being created in\n\t * @param editorInput The editor input being opened\n\t * @param editorIndex The index of the editor within that group\n\t */\n\tprivate _onDidTabOpen(groupId: number, editorInput: EditorInput, editorIndex: number) {\n\t\tconst group = this._editorGroupsService.getGroup(groupId);\n\t\t// Even if the editor service knows about the group the group might not exist yet in our model\n\t\tconst groupInModel = this._groupLookup.get(groupId) !== undefined;\n\t\t// Means a new group was likely created so we rebuild the model\n\t\tif (!group || !groupInModel) {\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\t\tconst tabs = this._groupLookup.get(groupId)?.tabs;\n\t\tif (!tabs) {\n\t\t\treturn;\n\t\t}\n\t\t// Splice tab into group at index editorIndex\n\t\tconst tabObject = this._buildTabObject(group, editorInput, editorIndex);\n\t\ttabs.splice(editorIndex, 0, tabObject);\n\t\t// Update lookup\n\t\tconst tabId = this._generateTabId(editorInput, groupId);\n\t\tthis._tabInfoLookup.set(tabId, { group, editorInput, tab: tabObject });\n\n\t\tif (editorInput instanceof MultiDiffEditorInput) {\n\t\t\tthis._multiDiffEditorInputListeners.set(editorInput, Event.fromObservableLight(editorInput.resources)(() => {\n\t\t\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\t\t\tif (!tabInfo) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttabInfo.tab = this._buildTabObject(group, editorInput, editorIndex);\n\t\t\t\tthis._proxy.$acceptTabOperation({\n\t\t\t\t\tgroupId,\n\t\t\t\t\tindex: editorIndex,\n\t\t\t\t\ttabDto: tabInfo.tab,\n\t\t\t\t\tkind: TabModelOperationKind.TAB_UPDATE\n\t\t\t\t});\n\t\t\t}));\n\t\t}\n\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tgroupId,\n\t\t\tindex: editorIndex,\n\t\t\ttabDto: tabObject,\n\t\t\tkind: TabModelOperationKind.TAB_OPEN\n\t\t});\n\t}\n\n\t/**\n\t * Called when a tab is closed\n\t * @param groupId The id of the group the tab is being removed from\n\t * @param editorIndex The index of the editor within that group\n\t */\n\tprivate _onDidTabClose(groupId: number, editorIndex: number) {\n\t\tconst group = this._editorGroupsService.getGroup(groupId);\n\t\tconst tabs = this._groupLookup.get(groupId)?.tabs;\n\t\t// Something is wrong with the model state so we rebuild\n\t\tif (!group || !tabs) {\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\t\t// Splice tab into group at index editorIndex\n\t\tconst removedTab = tabs.splice(editorIndex, 1);\n\n\t\t// Index must no longer be valid so we return prematurely\n\t\tif (removedTab.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update lookup\n\t\tthis._tabInfoLookup.delete(removedTab[0]?.id ?? '');\n\n\t\tif (removedTab[0]?.input instanceof MultiDiffEditorInput) {\n\t\t\tthis._multiDiffEditorInputListeners.deleteAndDispose(removedTab[0]?.input);\n\t\t}\n\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tgroupId,\n\t\t\tindex: editorIndex,\n\t\t\ttabDto: removedTab[0],\n\t\t\tkind: TabModelOperationKind.TAB_CLOSE\n\t\t});\n\t}\n\n\t/**\n\t * Called when the active tab changes\n\t * @param groupId The id of the group the tab is contained in\n\t * @param editorIndex The index of the tab\n\t */\n\tprivate _onDidTabActiveChange(groupId: number, editorIndex: number) {\n\t\t// TODO @lramos15 use the tab lookup here if possible. Do we have an editor input?!\n\t\tconst tabs = this._groupLookup.get(groupId)?.tabs;\n\t\tif (!tabs) {\n\t\t\treturn;\n\t\t}\n\t\tconst activeTab = tabs[editorIndex];\n\t\t// No need to loop over as the exthost uses the most recently marked active tab\n\t\tactiveTab.isActive = true;\n\t\t// Send DTO update to the exthost\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tgroupId,\n\t\t\tindex: editorIndex,\n\t\t\ttabDto: activeTab,\n\t\t\tkind: TabModelOperationKind.TAB_UPDATE\n\t\t});\n\n\t}\n\n\t/**\n\t * Called when the dirty indicator on the tab changes\n\t * @param groupId The id of the group the tab is in\n\t * @param editorIndex The index of the tab\n\t * @param editor The editor input represented by the tab\n\t */\n\tprivate _onDidTabDirty(groupId: number, editorIndex: number, editor: EditorInput) {\n\t\tconst tabId = this._generateTabId(editor, groupId);\n\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\t// Something wrong with the model state so we rebuild\n\t\tif (!tabInfo) {\n\t\t\tthis._logService.error('Invalid model for dirty change, rebuilding');\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\t\ttabInfo.tab.isDirty = editor.isDirty();\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tgroupId,\n\t\t\tindex: editorIndex,\n\t\t\ttabDto: tabInfo.tab,\n\t\t\tkind: TabModelOperationKind.TAB_UPDATE\n\t\t});\n\t}\n\n\t/**\n\t * Called when the tab is pinned/unpinned\n\t * @param groupId The id of the group the tab is in\n\t * @param editorIndex The index of the tab\n\t * @param editor The editor input represented by the tab\n\t */\n\tprivate _onDidTabPinChange(groupId: number, editorIndex: number, editor: EditorInput) {\n\t\tconst tabId = this._generateTabId(editor, groupId);\n\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\tconst group = tabInfo?.group;\n\t\tconst tab = tabInfo?.tab;\n\t\t// Something wrong with the model state so we rebuild\n\t\tif (!group || !tab) {\n\t\t\tthis._logService.error('Invalid model for sticky change, rebuilding');\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\t\t// Whether or not the tab has the pin icon (internally it's called sticky)\n\t\ttab.isPinned = group.isSticky(editorIndex);\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tgroupId,\n\t\t\tindex: editorIndex,\n\t\t\ttabDto: tab,\n\t\t\tkind: TabModelOperationKind.TAB_UPDATE\n\t\t});\n\t}\n\n\t/**\n * Called when the tab is preview / unpreviewed\n * @param groupId The id of the group the tab is in\n * @param editorIndex The index of the tab\n * @param editor The editor input represented by the tab\n */\n\tprivate _onDidTabPreviewChange(groupId: number, editorIndex: number, editor: EditorInput) {\n\t\tconst tabId = this._generateTabId(editor, groupId);\n\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\tconst group = tabInfo?.group;\n\t\tconst tab = tabInfo?.tab;\n\t\t// Something wrong with the model state so we rebuild\n\t\tif (!group || !tab) {\n\t\t\tthis._logService.error('Invalid model for sticky change, rebuilding');\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\t\t// Whether or not the tab has the pin icon (internally it's called pinned)\n\t\ttab.isPreview = !group.isPinned(editorIndex);\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tkind: TabModelOperationKind.TAB_UPDATE,\n\t\t\tgroupId,\n\t\t\ttabDto: tab,\n\t\t\tindex: editorIndex\n\t\t});\n\t}\n\n\tprivate _onDidTabMove(groupId: number, editorIndex: number, oldEditorIndex: number, editor: EditorInput) {\n\t\tconst tabs = this._groupLookup.get(groupId)?.tabs;\n\t\t// Something wrong with the model state so we rebuild\n\t\tif (!tabs) {\n\t\t\tthis._logService.error('Invalid model for move change, rebuilding');\n\t\t\tthis._createTabsModel();\n\t\t\treturn;\n\t\t}\n\n\t\t// Move tab from old index to new index\n\t\tconst removedTab = tabs.splice(oldEditorIndex, 1);\n\t\tif (removedTab.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\ttabs.splice(editorIndex, 0, removedTab[0]);\n\n\t\t// Notify exthost of move\n\t\tthis._proxy.$acceptTabOperation({\n\t\t\tkind: TabModelOperationKind.TAB_MOVE,\n\t\t\tgroupId,\n\t\t\ttabDto: removedTab[0],\n\t\t\tindex: editorIndex,\n\t\t\toldIndex: oldEditorIndex\n\t\t});\n\t}\n\n\t/**\n\t * Builds the model from scratch based on the current state of the editor service.\n\t */\n\tprivate _createTabsModel(): void {\n\t\tif (this._editorGroupsService.groups.length === 0) {\n\t\t\treturn; // skip this invalid state, it may happen when the entire editor area is transitioning to other state (\"editor working sets\")\n\t\t}\n\n\t\tthis._tabGroupModel = [];\n\t\tthis._groupLookup.clear();\n\t\tthis._tabInfoLookup.clear();\n\t\tlet tabs: IEditorTabDto[] = [];\n\t\tfor (const group of this._editorGroupsService.groups) {\n\t\t\tconst currentTabGroupModel: IEditorTabGroupDto = {\n\t\t\t\tgroupId: group.id,\n\t\t\t\tisActive: group.id === this._editorGroupsService.activeGroup.id,\n\t\t\t\tviewColumn: editorGroupToColumn(this._editorGroupsService, group),\n\t\t\t\ttabs: []\n\t\t\t};\n\t\t\tgroup.editors.forEach((editor, editorIndex) => {\n\t\t\t\tconst tab = this._buildTabObject(group, editor, editorIndex);\n\t\t\t\ttabs.push(tab);\n\t\t\t\t// Add information about the tab to the lookup\n\t\t\t\tthis._tabInfoLookup.set(this._generateTabId(editor, group.id), {\n\t\t\t\t\tgroup,\n\t\t\t\t\ttab,\n\t\t\t\t\teditorInput: editor\n\t\t\t\t});\n\t\t\t});\n\t\t\tcurrentTabGroupModel.tabs = tabs;\n\t\t\tthis._tabGroupModel.push(currentTabGroupModel);\n\t\t\tthis._groupLookup.set(group.id, currentTabGroupModel);\n\t\t\ttabs = [];\n\t\t}\n\t\t// notify the ext host of the new model\n\t\tthis._proxy.$acceptEditorTabModel(this._tabGroupModel);\n\t}\n\n\t// TODOD @lramos15 Remove this after done finishing the tab model code\n\t// private _eventToString(event: IEditorsChangeEvent | IEditorsMoveEvent): string {\n\t// \tlet eventString = '';\n\t// \tswitch (event.kind) {\n\t// \t\tcase GroupModelChangeKind.GROUP_INDEX: eventString += 'GROUP_INDEX'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_ACTIVE: eventString += 'EDITOR_ACTIVE'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_PIN: eventString += 'EDITOR_PIN'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_OPEN: eventString += 'EDITOR_OPEN'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_CLOSE: eventString += 'EDITOR_CLOSE'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_MOVE: eventString += 'EDITOR_MOVE'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_LABEL: eventString += 'EDITOR_LABEL'; break;\n\t// \t\tcase GroupModelChangeKind.GROUP_ACTIVE: eventString += 'GROUP_ACTIVE'; break;\n\t// \t\tcase GroupModelChangeKind.GROUP_LOCKED: eventString += 'GROUP_LOCKED'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_DIRTY: eventString += 'EDITOR_DIRTY'; break;\n\t// \t\tcase GroupModelChangeKind.EDITOR_STICKY: eventString += 'EDITOR_STICKY'; break;\n\t// \t\tdefault: eventString += `UNKNOWN: ${event.kind}`; break;\n\t// \t}\n\t// \treturn eventString;\n\t// }\n\n\t/**\n\t * The main handler for the tab events\n\t * @param events The list of events to process\n\t */\n\tprivate _updateTabsModel(changeEvent: IEditorsChangeEvent): void {\n\t\tconst event = changeEvent.event;\n\t\tconst groupId = changeEvent.groupId;\n\t\tswitch (event.kind) {\n\t\t\tcase GroupModelChangeKind.GROUP_ACTIVE:\n\t\t\t\tif (groupId === this._editorGroupsService.activeGroup.id) {\n\t\t\t\t\tthis._onDidGroupActivate();\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_LABEL:\n\t\t\t\tif (event.editor !== undefined && event.editorIndex !== undefined) {\n\t\t\t\t\tthis._onDidTabLabelChange(groupId, event.editor, event.editorIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_OPEN:\n\t\t\t\tif (event.editor !== undefined && event.editorIndex !== undefined) {\n\t\t\t\t\tthis._onDidTabOpen(groupId, event.editor, event.editorIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_CLOSE:\n\t\t\t\tif (event.editorIndex !== undefined) {\n\t\t\t\t\tthis._onDidTabClose(groupId, event.editorIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_ACTIVE:\n\t\t\t\tif (event.editorIndex !== undefined) {\n\t\t\t\t\tthis._onDidTabActiveChange(groupId, event.editorIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_DIRTY:\n\t\t\t\tif (event.editorIndex !== undefined && event.editor !== undefined) {\n\t\t\t\t\tthis._onDidTabDirty(groupId, event.editorIndex, event.editor);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_STICKY:\n\t\t\t\tif (event.editorIndex !== undefined && event.editor !== undefined) {\n\t\t\t\t\tthis._onDidTabPinChange(groupId, event.editorIndex, event.editor);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_PIN:\n\t\t\t\tif (event.editorIndex !== undefined && event.editor !== undefined) {\n\t\t\t\t\tthis._onDidTabPreviewChange(groupId, event.editorIndex, event.editor);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase GroupModelChangeKind.EDITOR_TRANSIENT:\n\t\t\t\t// Currently not exposed in the API\n\t\t\t\tbreak;\n\t\t\tcase GroupModelChangeKind.EDITOR_MOVE:\n\t\t\t\tif (isGroupEditorMoveEvent(event) && event.editor && event.editorIndex !== undefined && event.oldEditorIndex !== undefined) {\n\t\t\t\t\tthis._onDidTabMove(groupId, event.editorIndex, event.oldEditorIndex, event.editor);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// If it's not an optimized case we rebuild the tabs model from scratch\n\t\t\t\tthis._createTabsModel();\n\t\t}\n\t}\n\t//#region Messages received from Ext Host\n\t$moveTab(tabId: string, index: number, viewColumn: EditorGroupColumn, preserveFocus?: boolean): void {\n\t\tconst groupId = columnToEditorGroup(this._editorGroupsService, this._configurationService, viewColumn);\n\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\tconst tab = tabInfo?.tab;\n\t\tif (!tab) {\n\t\t\tthrow new Error(`Attempted to close tab with id ${tabId} which does not exist`);\n\t\t}\n\t\tlet targetGroup: IEditorGroup | undefined;\n\t\tconst sourceGroup = this._editorGroupsService.getGroup(tabInfo.group.id);\n\t\tif (!sourceGroup) {\n\t\t\treturn;\n\t\t}\n\t\t// If group index is out of bounds then we make a new one that's to the right of the last group\n\t\tif (this._groupLookup.get(groupId) === undefined) {\n\t\t\tlet direction = GroupDirection.RIGHT;\n\t\t\t// Make sure we respect the user's preferred side direction\n\t\t\tif (viewColumn === SIDE_GROUP) {\n\t\t\t\tdirection = preferredSideBySideGroupDirection(this._configurationService);\n\t\t\t}\n\t\t\ttargetGroup = this._editorGroupsService.addGroup(this._editorGroupsService.groups[this._editorGroupsService.groups.length - 1], direction);\n\t\t} else {\n\t\t\ttargetGroup = this._editorGroupsService.getGroup(groupId);\n\t\t}\n\t\tif (!targetGroup) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Similar logic to if index is out of bounds we place it at the end\n\t\tif (index < 0 || index > targetGroup.editors.length) {\n\t\t\tindex = targetGroup.editors.length;\n\t\t}\n\t\t// Find the correct EditorInput using the tab info\n\t\tconst editorInput = tabInfo?.editorInput;\n\t\tif (!editorInput) {\n\t\t\treturn;\n\t\t}\n\t\t// Move the editor to the target group\n\t\tsourceGroup.moveEditor(editorInput, targetGroup, { index, preserveFocus });\n\t\treturn;\n\t}\n\n\tasync $closeTab(tabIds: string[], preserveFocus?: boolean): Promise<boolean> {\n\t\tconst groups: Map<IEditorGroup, EditorInput[]> = new Map();\n\t\tfor (const tabId of tabIds) {\n\t\t\tconst tabInfo = this._tabInfoLookup.get(tabId);\n\t\t\tconst tab = tabInfo?.tab;\n\t\t\tconst group = tabInfo?.group;\n\t\t\tconst editorTab = tabInfo?.editorInput;\n\t\t\t// If not found skip\n\t\t\tif (!group || !tab || !tabInfo || !editorTab) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst groupEditors = groups.get(group);\n\t\t\tif (!groupEditors) {\n\t\t\t\tgroups.set(group, [editorTab]);\n\t\t\t} else {\n\t\t\t\tgroupEditors.push(editorTab);\n\t\t\t}\n\t\t}\n\t\t// Loop over keys of the groups map and call closeEditors\n\t\tconst results: boolean[] = [];\n\t\tfor (const [group, editors] of groups) {\n\t\t\tresults.push(await group.closeEditors(editors, { preserveFocus }));\n\t\t}\n\t\t// TODO @jrieken This isn't quite right how can we say true for some but not others?\n\t\treturn results.every(result => result);\n\t}\n\n\tasync $closeGroup(groupIds: number[], preserveFocus?: boolean): Promise<boolean> {\n\t\tconst groupCloseResults: boolean[] = [];\n\t\tfor (const groupId of groupIds) {\n\t\t\tconst group = this._editorGroupsService.getGroup(groupId);\n\t\t\tif (group) {\n\t\t\t\tgroupCloseResults.push(await group.closeAllEditors());\n\t\t\t\t// Make sure group is empty but still there before removing it\n\t\t\t\tif (group.count === 0 && this._editorGroupsService.getGroup(group.id)) {\n\t\t\t\t\tthis._editorGroupsService.removeGroup(group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn groupCloseResults.every(result => result);\n\t}\n\t//#endregion\n}\n"]}