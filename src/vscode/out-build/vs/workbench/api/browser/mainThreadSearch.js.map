{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/browser/mainThreadSearch.ts","vs/workbench/api/browser/mainThreadSearch.ts"],"names":[],"mappings":"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","file":"mainThreadSearch.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { DisposableStore, dispose, IDisposable } from '../../../base/common/lifecycle.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ITelemetryData, ITelemetryService } from '../../../platform/telemetry/common/telemetry.js';\nimport { extHostNamedCustomer, IExtHostContext } from '../../services/extensions/common/extHostCustomers.js';\nimport { IFileMatch, IFileQuery, IRawFileMatch2, ISearchComplete, ISearchCompleteStats, ISearchProgressItem, ISearchQuery, ISearchResultProvider, ISearchService, ITextQuery, QueryType, SearchProviderType } from '../../services/search/common/search.js';\nimport { ExtHostContext, ExtHostSearchShape, MainContext, MainThreadSearchShape } from '../common/extHost.protocol.js';\nimport { revive } from '../../../base/common/marshalling.js';\nimport * as Constants from '../../contrib/search/common/constants.js';\nimport { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { AISearchKeyword } from '../../services/search/common/searchExtTypes.js';\n\n@extHostNamedCustomer(MainContext.MainThreadSearch)\nexport class MainThreadSearch implements MainThreadSearchShape {\n\n\tprivate readonly _proxy: ExtHostSearchShape;\n\tprivate readonly _searchProvider = new Map<number, RemoteSearchProvider>();\n\n\tconstructor(\n\t\textHostContext: IExtHostContext,\n\t\t@ISearchService private readonly _searchService: ISearchService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService,\n\t\t@IConfigurationService _configurationService: IConfigurationService,\n\t\t@IContextKeyService protected contextKeyService: IContextKeyService,\n\t) {\n\t\tthis._proxy = extHostContext.getProxy(ExtHostContext.ExtHostSearch);\n\t\tthis._proxy.$enableExtensionHostSearch();\n\t}\n\n\tdispose(): void {\n\t\tthis._searchProvider.forEach(value => value.dispose());\n\t\tthis._searchProvider.clear();\n\t}\n\n\t$registerTextSearchProvider(handle: number, scheme: string): void {\n\t\tthis._searchProvider.set(handle, new RemoteSearchProvider(this._searchService, SearchProviderType.text, scheme, handle, this._proxy));\n\t}\n\n\t$registerAITextSearchProvider(handle: number, scheme: string): void {\n\t\tConstants.SearchContext.hasAIResultProvider.bindTo(this.contextKeyService).set(true);\n\t\tthis._searchProvider.set(handle, new RemoteSearchProvider(this._searchService, SearchProviderType.aiText, scheme, handle, this._proxy));\n\t}\n\n\t$registerFileSearchProvider(handle: number, scheme: string): void {\n\t\tthis._searchProvider.set(handle, new RemoteSearchProvider(this._searchService, SearchProviderType.file, scheme, handle, this._proxy));\n\t}\n\n\t$unregisterProvider(handle: number): void {\n\t\tdispose(this._searchProvider.get(handle));\n\t\tthis._searchProvider.delete(handle);\n\t}\n\n\t$handleFileMatch(handle: number, session: number, data: UriComponents[]): void {\n\t\tconst provider = this._searchProvider.get(handle);\n\t\tif (!provider) {\n\t\t\tthrow new Error('Got result for unknown provider');\n\t\t}\n\n\t\tprovider.handleFindMatch(session, data);\n\t}\n\n\t$handleTextMatch(handle: number, session: number, data: IRawFileMatch2[]): void {\n\t\tconst provider = this._searchProvider.get(handle);\n\t\tif (!provider) {\n\t\t\tthrow new Error('Got result for unknown provider');\n\t\t}\n\n\t\tprovider.handleFindMatch(session, data);\n\t}\n\n\t$handleKeywordResult(handle: number, session: number, data: AISearchKeyword): void {\n\t\tconst provider = this._searchProvider.get(handle);\n\t\tif (!provider) {\n\t\t\tthrow new Error('Got result for unknown provider');\n\t\t}\n\n\t\tprovider.handleKeywordResult(session, data);\n\t}\n\n\t$handleTelemetry(eventName: string, data: ITelemetryData | undefined): void {\n\t\tthis._telemetryService.publicLog(eventName, data);\n\t}\n}\n\nclass SearchOperation {\n\n\tprivate static _idPool = 0;\n\n\tconstructor(\n\t\treadonly progress?: (match: IFileMatch | AISearchKeyword) => unknown,\n\t\treadonly id: number = ++SearchOperation._idPool,\n\t\treadonly matches = new Map<string, IFileMatch>(),\n\t\treadonly keywords: AISearchKeyword[] = []\n\t) {\n\t\t//\n\t}\n\n\taddMatch(match: IFileMatch): void {\n\t\tconst existingMatch = this.matches.get(match.resource.toString());\n\t\tif (existingMatch) {\n\t\t\t// TODO@rob clean up text/file result types\n\t\t\t// If a file search returns the same file twice, we would enter this branch.\n\t\t\t// It's possible that could happen, #90813\n\t\t\tif (existingMatch.results && match.results) {\n\t\t\t\texistingMatch.results.push(...match.results);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.matches.set(match.resource.toString(), match);\n\t\t}\n\n\t\tthis.progress?.(match);\n\t}\n\n\taddKeyword(result: AISearchKeyword): void {\n\t\tthis.keywords.push(result);\n\t\tthis.progress?.(result);\n\t}\n}\n\nclass RemoteSearchProvider implements ISearchResultProvider, IDisposable {\n\n\tprivate readonly _registrations = new DisposableStore();\n\tprivate readonly _searches = new Map<number, SearchOperation>();\n\tprivate cachedAIName: string | undefined;\n\n\tconstructor(\n\t\tsearchService: ISearchService,\n\t\ttype: SearchProviderType,\n\t\tprivate readonly _scheme: string,\n\t\tprivate readonly _handle: number,\n\t\tprivate readonly _proxy: ExtHostSearchShape\n\t) {\n\t\tthis._registrations.add(searchService.registerSearchResultProvider(this._scheme, type, this));\n\t}\n\n\tasync getAIName(): Promise<string | undefined> {\n\t\tif (this.cachedAIName === undefined) {\n\t\t\tthis.cachedAIName = await this._proxy.$getAIName(this._handle);\n\t\t}\n\t\treturn this.cachedAIName;\n\t}\n\n\tdispose(): void {\n\t\tthis._registrations.dispose();\n\t}\n\n\tfileSearch(query: IFileQuery, token: CancellationToken = CancellationToken.None): Promise<ISearchComplete> {\n\t\treturn this.doSearch(query, undefined, token);\n\t}\n\n\ttextSearch(query: ITextQuery, onProgress?: (p: ISearchProgressItem) => void, token: CancellationToken = CancellationToken.None): Promise<ISearchComplete> {\n\t\treturn this.doSearch(query, onProgress, token);\n\t}\n\n\tdoSearch(query: ISearchQuery, onProgress?: (p: ISearchProgressItem) => void, token: CancellationToken = CancellationToken.None): Promise<ISearchComplete> {\n\t\tif (!query.folderQueries.length) {\n\t\t\tthrow new Error('Empty folderQueries');\n\t\t}\n\n\t\tconst search = new SearchOperation(onProgress);\n\t\tthis._searches.set(search.id, search);\n\n\t\tconst searchP = this._provideSearchResults(query, search.id, token);\n\n\t\treturn Promise.resolve(searchP).then((result: ISearchCompleteStats) => {\n\t\t\tthis._searches.delete(search.id);\n\t\t\treturn { results: Array.from(search.matches.values()), aiKeywords: Array.from(search.keywords), stats: result.stats, limitHit: result.limitHit, messages: result.messages };\n\t\t}, err => {\n\t\t\tthis._searches.delete(search.id);\n\t\t\treturn Promise.reject(err);\n\t\t});\n\t}\n\n\tclearCache(cacheKey: string): Promise<void> {\n\t\treturn Promise.resolve(this._proxy.$clearCache(cacheKey));\n\t}\n\n\thandleFindMatch(session: number, dataOrUri: Array<UriComponents | IRawFileMatch2>): void {\n\t\tconst searchOp = this._searches.get(session);\n\n\t\tif (!searchOp) {\n\t\t\t// ignore...\n\t\t\treturn;\n\t\t}\n\n\t\tdataOrUri.forEach(result => {\n\t\t\tif ((<IRawFileMatch2>result).results) {\n\t\t\t\tsearchOp.addMatch(revive((<IRawFileMatch2>result)));\n\t\t\t} else {\n\t\t\t\tsearchOp.addMatch({\n\t\t\t\t\tresource: URI.revive(<UriComponents>result)\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\thandleKeywordResult(session: number, data: AISearchKeyword): void {\n\t\tconst searchOp = this._searches.get(session);\n\n\t\tif (!searchOp) {\n\t\t\t// ignore...\n\t\t\treturn;\n\t\t}\n\t\tsearchOp.addKeyword(data);\n\t}\n\n\tprivate _provideSearchResults(query: ISearchQuery, session: number, token: CancellationToken): Promise<ISearchCompleteStats> {\n\t\tswitch (query.type) {\n\t\t\tcase QueryType.File:\n\t\t\t\treturn this._proxy.$provideFileSearchResults(this._handle, session, query, token);\n\t\t\tcase QueryType.Text:\n\t\t\t\treturn this._proxy.$provideTextSearchResults(this._handle, session, query, token);\n\t\t\tdefault:\n\t\t\t\treturn this._proxy.$provideAITextSearchResults(this._handle, session, query, token);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { DisposableStore, dispose, IDisposable } from '../../../base/common/lifecycle.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ITelemetryData, ITelemetryService } from '../../../platform/telemetry/common/telemetry.js';\nimport { extHostNamedCustomer, IExtHostContext } from '../../services/extensions/common/extHostCustomers.js';\nimport { IFileMatch, IFileQuery, IRawFileMatch2, ISearchComplete, ISearchCompleteStats, ISearchProgressItem, ISearchQuery, ISearchResultProvider, ISearchService, ITextQuery, QueryType, SearchProviderType } from '../../services/search/common/search.js';\nimport { ExtHostContext, ExtHostSearchShape, MainContext, MainThreadSearchShape } from '../common/extHost.protocol.js';\nimport { revive } from '../../../base/common/marshalling.js';\nimport * as Constants from '../../contrib/search/common/constants.js';\nimport { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { AISearchKeyword } from '../../services/search/common/searchExtTypes.js';\n\n@extHostNamedCustomer(MainContext.MainThreadSearch)\nexport class MainThreadSearch implements MainThreadSearchShape {\n\n\tprivate readonly _proxy: ExtHostSearchShape;\n\tprivate readonly _searchProvider = new Map<number, RemoteSearchProvider>();\n\n\tconstructor(\n\t\textHostContext: IExtHostContext,\n\t\t@ISearchService private readonly _searchService: ISearchService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService,\n\t\t@IConfigurationService _configurationService: IConfigurationService,\n\t\t@IContextKeyService protected contextKeyService: IContextKeyService,\n\t) {\n\t\tthis._proxy = extHostContext.getProxy(ExtHostContext.ExtHostSearch);\n\t\tthis._proxy.$enableExtensionHostSearch();\n\t}\n\n\tdispose(): void {\n\t\tthis._searchProvider.forEach(value => value.dispose());\n\t\tthis._searchProvider.clear();\n\t}\n\n\t$registerTextSearchProvider(handle: number, scheme: string): void {\n\t\tthis._searchProvider.set(handle, new RemoteSearchProvider(this._searchService, SearchProviderType.text, scheme, handle, this._proxy));\n\t}\n\n\t$registerAITextSearchProvider(handle: number, scheme: string): void {\n\t\tConstants.SearchContext.hasAIResultProvider.bindTo(this.contextKeyService).set(true);\n\t\tthis._searchProvider.set(handle, new RemoteSearchProvider(this._searchService, SearchProviderType.aiText, scheme, handle, this._proxy));\n\t}\n\n\t$registerFileSearchProvider(handle: number, scheme: string): void {\n\t\tthis._searchProvider.set(handle, new RemoteSearchProvider(this._searchService, SearchProviderType.file, scheme, handle, this._proxy));\n\t}\n\n\t$unregisterProvider(handle: number): void {\n\t\tdispose(this._searchProvider.get(handle));\n\t\tthis._searchProvider.delete(handle);\n\t}\n\n\t$handleFileMatch(handle: number, session: number, data: UriComponents[]): void {\n\t\tconst provider = this._searchProvider.get(handle);\n\t\tif (!provider) {\n\t\t\tthrow new Error('Got result for unknown provider');\n\t\t}\n\n\t\tprovider.handleFindMatch(session, data);\n\t}\n\n\t$handleTextMatch(handle: number, session: number, data: IRawFileMatch2[]): void {\n\t\tconst provider = this._searchProvider.get(handle);\n\t\tif (!provider) {\n\t\t\tthrow new Error('Got result for unknown provider');\n\t\t}\n\n\t\tprovider.handleFindMatch(session, data);\n\t}\n\n\t$handleKeywordResult(handle: number, session: number, data: AISearchKeyword): void {\n\t\tconst provider = this._searchProvider.get(handle);\n\t\tif (!provider) {\n\t\t\tthrow new Error('Got result for unknown provider');\n\t\t}\n\n\t\tprovider.handleKeywordResult(session, data);\n\t}\n\n\t$handleTelemetry(eventName: string, data: ITelemetryData | undefined): void {\n\t\tthis._telemetryService.publicLog(eventName, data);\n\t}\n}\n\nclass SearchOperation {\n\n\tprivate static _idPool = 0;\n\n\tconstructor(\n\t\treadonly progress?: (match: IFileMatch | AISearchKeyword) => unknown,\n\t\treadonly id: number = ++SearchOperation._idPool,\n\t\treadonly matches = new Map<string, IFileMatch>(),\n\t\treadonly keywords: AISearchKeyword[] = []\n\t) {\n\t\t//\n\t}\n\n\taddMatch(match: IFileMatch): void {\n\t\tconst existingMatch = this.matches.get(match.resource.toString());\n\t\tif (existingMatch) {\n\t\t\t// TODO@rob clean up text/file result types\n\t\t\t// If a file search returns the same file twice, we would enter this branch.\n\t\t\t// It's possible that could happen, #90813\n\t\t\tif (existingMatch.results && match.results) {\n\t\t\t\texistingMatch.results.push(...match.results);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.matches.set(match.resource.toString(), match);\n\t\t}\n\n\t\tthis.progress?.(match);\n\t}\n\n\taddKeyword(result: AISearchKeyword): void {\n\t\tthis.keywords.push(result);\n\t\tthis.progress?.(result);\n\t}\n}\n\nclass RemoteSearchProvider implements ISearchResultProvider, IDisposable {\n\n\tprivate readonly _registrations = new DisposableStore();\n\tprivate readonly _searches = new Map<number, SearchOperation>();\n\tprivate cachedAIName: string | undefined;\n\n\tconstructor(\n\t\tsearchService: ISearchService,\n\t\ttype: SearchProviderType,\n\t\tprivate readonly _scheme: string,\n\t\tprivate readonly _handle: number,\n\t\tprivate readonly _proxy: ExtHostSearchShape\n\t) {\n\t\tthis._registrations.add(searchService.registerSearchResultProvider(this._scheme, type, this));\n\t}\n\n\tasync getAIName(): Promise<string | undefined> {\n\t\tif (this.cachedAIName === undefined) {\n\t\t\tthis.cachedAIName = await this._proxy.$getAIName(this._handle);\n\t\t}\n\t\treturn this.cachedAIName;\n\t}\n\n\tdispose(): void {\n\t\tthis._registrations.dispose();\n\t}\n\n\tfileSearch(query: IFileQuery, token: CancellationToken = CancellationToken.None): Promise<ISearchComplete> {\n\t\treturn this.doSearch(query, undefined, token);\n\t}\n\n\ttextSearch(query: ITextQuery, onProgress?: (p: ISearchProgressItem) => void, token: CancellationToken = CancellationToken.None): Promise<ISearchComplete> {\n\t\treturn this.doSearch(query, onProgress, token);\n\t}\n\n\tdoSearch(query: ISearchQuery, onProgress?: (p: ISearchProgressItem) => void, token: CancellationToken = CancellationToken.None): Promise<ISearchComplete> {\n\t\tif (!query.folderQueries.length) {\n\t\t\tthrow new Error('Empty folderQueries');\n\t\t}\n\n\t\tconst search = new SearchOperation(onProgress);\n\t\tthis._searches.set(search.id, search);\n\n\t\tconst searchP = this._provideSearchResults(query, search.id, token);\n\n\t\treturn Promise.resolve(searchP).then((result: ISearchCompleteStats) => {\n\t\t\tthis._searches.delete(search.id);\n\t\t\treturn { results: Array.from(search.matches.values()), aiKeywords: Array.from(search.keywords), stats: result.stats, limitHit: result.limitHit, messages: result.messages };\n\t\t}, err => {\n\t\t\tthis._searches.delete(search.id);\n\t\t\treturn Promise.reject(err);\n\t\t});\n\t}\n\n\tclearCache(cacheKey: string): Promise<void> {\n\t\treturn Promise.resolve(this._proxy.$clearCache(cacheKey));\n\t}\n\n\thandleFindMatch(session: number, dataOrUri: Array<UriComponents | IRawFileMatch2>): void {\n\t\tconst searchOp = this._searches.get(session);\n\n\t\tif (!searchOp) {\n\t\t\t// ignore...\n\t\t\treturn;\n\t\t}\n\n\t\tdataOrUri.forEach(result => {\n\t\t\tif ((<IRawFileMatch2>result).results) {\n\t\t\t\tsearchOp.addMatch(revive((<IRawFileMatch2>result)));\n\t\t\t} else {\n\t\t\t\tsearchOp.addMatch({\n\t\t\t\t\tresource: URI.revive(<UriComponents>result)\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\thandleKeywordResult(session: number, data: AISearchKeyword): void {\n\t\tconst searchOp = this._searches.get(session);\n\n\t\tif (!searchOp) {\n\t\t\t// ignore...\n\t\t\treturn;\n\t\t}\n\t\tsearchOp.addKeyword(data);\n\t}\n\n\tprivate _provideSearchResults(query: ISearchQuery, session: number, token: CancellationToken): Promise<ISearchCompleteStats> {\n\t\tswitch (query.type) {\n\t\t\tcase QueryType.File:\n\t\t\t\treturn this._proxy.$provideFileSearchResults(this._handle, session, query, token);\n\t\t\tcase QueryType.Text:\n\t\t\t\treturn this._proxy.$provideTextSearchResults(this._handle, session, query, token);\n\t\t\tdefault:\n\t\t\t\treturn this._proxy.$provideAITextSearchResults(this._handle, session, query, token);\n\t\t}\n\t}\n}\n"]}