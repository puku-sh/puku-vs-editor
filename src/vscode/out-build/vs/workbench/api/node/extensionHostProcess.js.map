{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/node/extensionHostProcess.ts","vs/workbench/api/node/extensionHostProcess.ts"],"names":[],"mappings":"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","file":"extensionHostProcess.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport minimist from 'minimist';\nimport * as nativeWatchdog from 'native-watchdog';\nimport * as net from 'net';\nimport { ProcessTimeRunOnceScheduler } from '../../../base/common/async.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { PendingMigrationError, isCancellationError, isSigPipeError, onUnexpectedError, onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { Event } from '../../../base/common/event.js';\nimport * as performance from '../../../base/common/performance.js';\nimport { IURITransformer } from '../../../base/common/uriIpc.js';\nimport { Promises } from '../../../base/node/pfs.js';\nimport { IMessagePassingProtocol } from '../../../base/parts/ipc/common/ipc.js';\nimport { BufferedEmitter, PersistentProtocol, ProtocolConstants } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { NodeSocket, WebSocketNodeSocket } from '../../../base/parts/ipc/node/ipc.net.js';\nimport type { MessagePortMain, MessageEvent as UtilityMessageEvent } from '../../../base/parts/sandbox/node/electronTypes.js';\nimport { boolean } from '../../../editor/common/config/editorOptions.js';\nimport product from '../../../platform/product/common/product.js';\nimport { ExtensionHostMain, IExitFn } from '../common/extensionHostMain.js';\nimport { IHostUtils } from '../common/extHostExtensionService.js';\nimport { createURITransformer } from '../../../base/common/uriTransformer.js';\nimport { ExtHostConnectionType, readExtHostConnection } from '../../services/extensions/common/extensionHostEnv.js';\nimport { ExtensionHostExitCode, IExtHostReadyMessage, IExtHostReduceGraceTimeMessage, IExtHostSocketMessage, IExtensionHostInitData, MessageType, createMessageOfType, isMessageOfType } from '../../services/extensions/common/extensionHostProtocol.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport '../common/extHost.common.services.js';\nimport './extHost.node.services.js';\nimport { createRequire } from 'node:module';\nconst require = createRequire(import.meta.url);\n\ninterface ParsedExtHostArgs {\n\ttransformURIs?: boolean;\n\tskipWorkspaceStorageLock?: boolean;\n\tsupportGlobalNavigator?: boolean; // enable global navigator object in nodejs\n\tuseHostProxy?: 'true' | 'false'; // use a string, as undefined is also a valid value\n}\n\n// silence experimental warnings when in development\nif (process.env.VSCODE_DEV) {\n\tconst warningListeners = process.listeners('warning');\n\tprocess.removeAllListeners('warning');\n\tprocess.on('warning', (warning: any) => {\n\t\tif (warning.code === 'ExperimentalWarning' || warning.name === 'ExperimentalWarning' || warning.name === 'DeprecationWarning') {\n\t\t\tconsole.debug(warning);\n\t\t\treturn;\n\t\t}\n\n\t\twarningListeners[0](warning);\n\t});\n}\n\n// workaround for https://github.com/microsoft/vscode/issues/85490\n// remove --inspect-port=0 after start so that it doesn't trigger LSP debugging\n(function removeInspectPort() {\n\tfor (let i = 0; i < process.execArgv.length; i++) {\n\t\tif (process.execArgv[i] === '--inspect-port=0') {\n\t\t\tprocess.execArgv.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n})();\n\nconst args = minimist(process.argv.slice(2), {\n\tboolean: [\n\t\t'transformURIs',\n\t\t'skipWorkspaceStorageLock',\n\t\t'supportGlobalNavigator',\n\t],\n\tstring: [\n\t\t'useHostProxy' // 'true' | 'false' | undefined\n\t]\n}) as ParsedExtHostArgs;\n\n// With Electron 2.x and node.js 8.x the \"natives\" module\n// can cause a native crash (see https://github.com/nodejs/node/issues/19891 and\n// https://github.com/electron/electron/issues/10905). To prevent this from\n// happening we essentially blocklist this module from getting loaded in any\n// extension by patching the node require() function.\n(function () {\n\tconst Module = require('module');\n\tconst originalLoad = Module._load;\n\n\tModule._load = function (request: string) {\n\t\tif (request === 'natives') {\n\t\t\tthrow new Error('Either the extension or an NPM dependency is using the [unsupported \"natives\" node module](https://go.microsoft.com/fwlink/?linkid=871887).');\n\t\t}\n\n\t\treturn originalLoad.apply(this, arguments);\n\t};\n})();\n\n// custom process.exit logic...\nconst nativeExit: IExitFn = process.exit.bind(process);\nconst nativeOn = process.on.bind(process);\nfunction patchProcess(allowExit: boolean) {\n\tprocess.exit = function (code?: number) {\n\t\tif (allowExit) {\n\t\t\tnativeExit(code);\n\t\t} else {\n\t\t\tconst err = new Error('An extension called process.exit() and this was prevented.');\n\t\t\tconsole.warn(err.stack);\n\t\t}\n\t} as (code?: number) => never;\n\n\t// override Electron's process.crash() method\n\t// eslint-disable-next-line local/code-no-any-casts\n\t(process as any /* bypass layer checker */).crash = function () {\n\t\tconst err = new Error('An extension called process.crash() and this was prevented.');\n\t\tconsole.warn(err.stack);\n\t};\n\n\t// Set ELECTRON_RUN_AS_NODE environment variable for extensions that use\n\t// child_process.spawn with process.execPath and expect to run as node process\n\t// on the desktop.\n\t// Refs https://github.com/microsoft/vscode/issues/151012#issuecomment-1156593228\n\tprocess.env['ELECTRON_RUN_AS_NODE'] = '1';\n\n\t// eslint-disable-next-line local/code-no-any-casts\n\tprocess.on = <any>function (event: string, listener: (...args: any[]) => void) {\n\t\tif (event === 'uncaughtException') {\n\t\t\tconst actualListener = listener;\n\t\t\tlistener = function (...args: unknown[]) {\n\t\t\t\ttry {\n\t\t\t\t\treturn actualListener.apply(undefined, args);\n\t\t\t\t} catch {\n\t\t\t\t\t// DO NOT HANDLE NOR PRINT the error here because this can and will lead to\n\t\t\t\t\t// more errors which will cause error handling to be reentrant and eventually\n\t\t\t\t\t// overflowing the stack. Do not be sad, we do handle and annotate uncaught\n\t\t\t\t\t// errors properly in 'extensionHostMain'\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tnativeOn(event, listener);\n\t};\n\n}\n\n// NodeJS since v21 defines navigator as a global object. This will likely surprise many extensions and potentially break them\n// because `navigator` has historically often been used to check if running in a browser (vs running inside NodeJS)\nif (!args.supportGlobalNavigator) {\n\tObject.defineProperty(globalThis, 'navigator', {\n\t\tget: () => {\n\t\t\tonUnexpectedExternalError(new PendingMigrationError('navigator is now a global in nodejs, please see https://aka.ms/vscode-extensions/navigator for additional info on this error.'));\n\t\t\treturn undefined;\n\t\t}\n\t});\n}\n\n\ninterface IRendererConnection {\n\tprotocol: IMessagePassingProtocol;\n\tinitData: IExtensionHostInitData;\n}\n\n// This calls exit directly in case the initialization is not finished and we need to exit\n// Otherwise, if initialization completed we go to extensionHostMain.terminate()\nlet onTerminate = function (reason: string) {\n\tnativeExit();\n};\n\nfunction readReconnectionValue(envKey: string, fallback: number): number {\n\tconst raw = process.env[envKey];\n\tif (typeof raw !== 'string' || raw.trim().length === 0) {\n\t\tconsole.log(`[reconnection-grace-time] Extension host: env var ${envKey} not set, using default: ${fallback}ms (${Math.floor(fallback / 1000)}s)`);\n\t\treturn fallback;\n\t}\n\tconst parsed = Number(raw);\n\tif (!isFinite(parsed) || parsed < 0) {\n\t\tconsole.log(`[reconnection-grace-time] Extension host: env var ${envKey} invalid value '${raw}', using default: ${fallback}ms (${Math.floor(fallback / 1000)}s)`);\n\t\treturn fallback;\n\t}\n\tconst millis = Math.floor(parsed);\n\tconst result = millis > Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : millis;\n\tconsole.log(`[reconnection-grace-time] Extension host: read ${envKey}=${raw}ms (${Math.floor(result / 1000)}s)`);\n\treturn result;\n}\n\nfunction _createExtHostProtocol(): Promise<IMessagePassingProtocol> {\n\tconst extHostConnection = readExtHostConnection(process.env);\n\n\tif (extHostConnection.type === ExtHostConnectionType.MessagePort) {\n\n\t\treturn new Promise<IMessagePassingProtocol>((resolve, reject) => {\n\n\t\t\tconst withPorts = (ports: MessagePortMain[]) => {\n\t\t\t\tconst port = ports[0];\n\t\t\t\tconst onMessage = new BufferedEmitter<VSBuffer>();\n\t\t\t\tport.on('message', (e) => onMessage.fire(VSBuffer.wrap(e.data as Uint8Array)));\n\t\t\t\tport.on('close', () => {\n\t\t\t\t\tonTerminate('renderer closed the MessagePort');\n\t\t\t\t});\n\t\t\t\tport.start();\n\n\t\t\t\tresolve({\n\t\t\t\t\tonMessage: onMessage.event,\n\t\t\t\t\tsend: message => port.postMessage(message.buffer)\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t(process as unknown as { parentPort: { on: (event: 'message', listener: (messageEvent: UtilityMessageEvent) => void) => void } }).parentPort.on('message', (e: UtilityMessageEvent) => withPorts(e.ports));\n\t\t});\n\n\t} else if (extHostConnection.type === ExtHostConnectionType.Socket) {\n\n\t\treturn new Promise<PersistentProtocol>((resolve, reject) => {\n\n\t\t\tlet protocol: PersistentProtocol | null = null;\n\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\tonTerminate('VSCODE_EXTHOST_IPC_SOCKET timeout');\n\t\t\t}, 60000);\n\n\t\t\tconst reconnectionGraceTime = readReconnectionValue('VSCODE_RECONNECTION_GRACE_TIME', ProtocolConstants.ReconnectionGraceTime);\n\t\t\tconst reconnectionShortGraceTime = reconnectionGraceTime > 0 ? Math.min(ProtocolConstants.ReconnectionShortGraceTime, reconnectionGraceTime) : 0;\n\t\t\tconst disconnectRunner1 = new ProcessTimeRunOnceScheduler(() => onTerminate('renderer disconnected for too long (1)'), reconnectionGraceTime);\n\t\t\tconst disconnectRunner2 = new ProcessTimeRunOnceScheduler(() => onTerminate('renderer disconnected for too long (2)'), reconnectionShortGraceTime);\n\n\t\t\tprocess.on('message', (msg: IExtHostSocketMessage | IExtHostReduceGraceTimeMessage, handle: net.Socket) => {\n\t\t\t\tif (msg && msg.type === 'VSCODE_EXTHOST_IPC_SOCKET') {\n\t\t\t\t\t// Disable Nagle's algorithm. We also do this on the server process,\n\t\t\t\t\t// but nodejs doesn't document if this option is transferred with the socket\n\t\t\t\t\thandle.setNoDelay(true);\n\n\t\t\t\t\tconst initialDataChunk = VSBuffer.wrap(Buffer.from(msg.initialDataChunk, 'base64'));\n\t\t\t\t\tlet socket: NodeSocket | WebSocketNodeSocket;\n\t\t\t\t\tif (msg.skipWebSocketFrames) {\n\t\t\t\t\t\tsocket = new NodeSocket(handle, 'extHost-socket');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst inflateBytes = VSBuffer.wrap(Buffer.from(msg.inflateBytes, 'base64'));\n\t\t\t\t\t\tsocket = new WebSocketNodeSocket(new NodeSocket(handle, 'extHost-socket'), msg.permessageDeflate, inflateBytes, false);\n\t\t\t\t\t}\n\t\t\t\t\tif (protocol) {\n\t\t\t\t\t\t// reconnection case\n\t\t\t\t\t\tdisconnectRunner1.cancel();\n\t\t\t\t\t\tdisconnectRunner2.cancel();\n\t\t\t\t\t\tprotocol.beginAcceptReconnection(socket, initialDataChunk);\n\t\t\t\t\t\tprotocol.endAcceptReconnection();\n\t\t\t\t\t\tprotocol.sendResume();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\t\tprotocol = new PersistentProtocol({ socket, initialChunk: initialDataChunk });\n\t\t\t\t\t\tprotocol.sendResume();\n\t\t\t\t\t\tprotocol.onDidDispose(() => onTerminate('renderer disconnected'));\n\t\t\t\t\t\tresolve(protocol);\n\n\t\t\t\t\t\t// Wait for rich client to reconnect\n\t\t\t\t\t\tprotocol.onSocketClose(() => {\n\t\t\t\t\t\t\t// The socket has closed, let's give the renderer a certain amount of time to reconnect\n\t\t\t\t\t\t\tdisconnectRunner1.schedule();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (msg && msg.type === 'VSCODE_EXTHOST_IPC_REDUCE_GRACE_TIME') {\n\t\t\t\t\tif (disconnectRunner2.isScheduled()) {\n\t\t\t\t\t\t// we are disconnected and already running the short reconnection timer\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (disconnectRunner1.isScheduled()) {\n\t\t\t\t\t\t// we are disconnected and running the long reconnection timer\n\t\t\t\t\t\tdisconnectRunner2.schedule();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Now that we have managed to install a message listener, ask the other side to send us the socket\n\t\t\tconst req: IExtHostReadyMessage = { type: 'VSCODE_EXTHOST_IPC_READY' };\n\t\t\tprocess.send?.(req);\n\t\t});\n\n\t} else {\n\n\t\tconst pipeName = extHostConnection.pipeName;\n\n\t\treturn new Promise<PersistentProtocol>((resolve, reject) => {\n\n\t\t\tconst socket = net.createConnection(pipeName, () => {\n\t\t\t\tsocket.removeListener('error', reject);\n\t\t\t\tconst protocol = new PersistentProtocol({ socket: new NodeSocket(socket, 'extHost-renderer') });\n\t\t\t\tprotocol.sendResume();\n\t\t\t\tresolve(protocol);\n\t\t\t});\n\t\t\tsocket.once('error', reject);\n\n\t\t\tsocket.on('close', () => {\n\t\t\t\tonTerminate('renderer closed the socket');\n\t\t\t});\n\t\t});\n\t}\n}\n\nasync function createExtHostProtocol(): Promise<IMessagePassingProtocol> {\n\n\tconst protocol = await _createExtHostProtocol();\n\n\treturn new class implements IMessagePassingProtocol {\n\n\t\tprivate readonly _onMessage = new BufferedEmitter<VSBuffer>();\n\t\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\t\tprivate _terminating: boolean;\n\t\tprivate _protocolListener: IDisposable;\n\n\t\tconstructor() {\n\t\t\tthis._terminating = false;\n\t\t\tthis._protocolListener = protocol.onMessage((msg) => {\n\t\t\t\tif (isMessageOfType(msg, MessageType.Terminate)) {\n\t\t\t\t\tthis._terminating = true;\n\t\t\t\t\tthis._protocolListener.dispose();\n\t\t\t\t\tonTerminate('received terminate message from renderer');\n\t\t\t\t} else {\n\t\t\t\t\tthis._onMessage.fire(msg);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tsend(msg: any): void {\n\t\t\tif (!this._terminating) {\n\t\t\t\tprotocol.send(msg);\n\t\t\t}\n\t\t}\n\n\t\tasync drain(): Promise<void> {\n\t\t\tif (protocol.drain) {\n\t\t\t\treturn protocol.drain();\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction connectToRenderer(protocol: IMessagePassingProtocol): Promise<IRendererConnection> {\n\treturn new Promise<IRendererConnection>((c) => {\n\n\t\t// Listen init data message\n\t\tconst first = protocol.onMessage(raw => {\n\t\t\tfirst.dispose();\n\n\t\t\tconst initData = <IExtensionHostInitData>JSON.parse(raw.toString());\n\n\t\t\tconst rendererCommit = initData.commit;\n\t\t\tconst myCommit = product.commit;\n\n\t\t\tif (rendererCommit && myCommit) {\n\t\t\t\t// Running in the built version where commits are defined\n\t\t\t\tif (rendererCommit !== myCommit) {\n\t\t\t\t\tnativeExit(ExtensionHostExitCode.VersionMismatch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (initData.parentPid) {\n\t\t\t\t// Kill oneself if one's parent dies. Much drama.\n\t\t\t\tlet epermErrors = 0;\n\t\t\t\tsetInterval(function () {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocess.kill(initData.parentPid, 0); // throws an exception if the main process doesn't exist anymore.\n\t\t\t\t\t\tepermErrors = 0;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e && e.code === 'EPERM') {\n\t\t\t\t\t\t\t// Even if the parent process is still alive,\n\t\t\t\t\t\t\t// some antivirus software can lead to an EPERM error to be thrown here.\n\t\t\t\t\t\t\t// Let's terminate only if we get 3 consecutive EPERM errors.\n\t\t\t\t\t\t\tepermErrors++;\n\t\t\t\t\t\t\tif (epermErrors >= 3) {\n\t\t\t\t\t\t\t\tonTerminate(`parent process ${initData.parentPid} does not exist anymore (3 x EPERM): ${e.message} (code: ${e.code}) (errno: ${e.errno})`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonTerminate(`parent process ${initData.parentPid} does not exist anymore: ${e.message} (code: ${e.code}) (errno: ${e.errno})`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, 1000);\n\n\t\t\t\t// In certain cases, the event loop can become busy and never yield\n\t\t\t\t// e.g. while-true or process.nextTick endless loops\n\t\t\t\t// So also use the native node module to do it from a separate thread\n\t\t\t\tlet watchdog: typeof nativeWatchdog;\n\t\t\t\ttry {\n\t\t\t\t\twatchdog = require('native-watchdog');\n\t\t\t\t\twatchdog.start(initData.parentPid);\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// no problem...\n\t\t\t\t\tonUnexpectedError(err);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tell the outside that we are initialized\n\t\t\tprotocol.send(createMessageOfType(MessageType.Initialized));\n\n\t\t\tc({ protocol, initData });\n\t\t});\n\n\t\t// Tell the outside that we are ready to receive messages\n\t\tprotocol.send(createMessageOfType(MessageType.Ready));\n\t});\n}\n\nasync function startExtensionHostProcess(): Promise<void> {\n\n\t// Print a console message when rejection isn't handled within N seconds. For details:\n\t// see https://nodejs.org/api/process.html#process_event_unhandledrejection\n\t// and https://nodejs.org/api/process.html#process_event_rejectionhandled\n\tconst unhandledPromises: Promise<any>[] = [];\n\tprocess.on('unhandledRejection', (reason: any, promise: Promise<any>) => {\n\t\tunhandledPromises.push(promise);\n\t\tsetTimeout(() => {\n\t\t\tconst idx = unhandledPromises.indexOf(promise);\n\t\t\tif (idx >= 0) {\n\t\t\t\tpromise.catch(e => {\n\t\t\t\t\tunhandledPromises.splice(idx, 1);\n\t\t\t\t\tif (!isCancellationError(e)) {\n\t\t\t\t\t\tconsole.warn(`rejected promise not handled within 1 second: ${e}`);\n\t\t\t\t\t\tif (e && e.stack) {\n\t\t\t\t\t\t\tconsole.warn(`stack trace: ${e.stack}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (reason) {\n\t\t\t\t\t\t\tonUnexpectedError(reason);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, 1000);\n\t});\n\n\tprocess.on('rejectionHandled', (promise: Promise<any>) => {\n\t\tconst idx = unhandledPromises.indexOf(promise);\n\t\tif (idx >= 0) {\n\t\t\tunhandledPromises.splice(idx, 1);\n\t\t}\n\t});\n\n\t// Print a console message when an exception isn't handled.\n\tprocess.on('uncaughtException', function (err: Error) {\n\t\tif (!isSigPipeError(err)) {\n\t\t\tonUnexpectedError(err);\n\t\t}\n\t});\n\n\tperformance.mark(`code/extHost/willConnectToRenderer`);\n\tconst protocol = await createExtHostProtocol();\n\tperformance.mark(`code/extHost/didConnectToRenderer`);\n\tconst renderer = await connectToRenderer(protocol);\n\tperformance.mark(`code/extHost/didWaitForInitData`);\n\tconst { initData } = renderer;\n\t// setup things\n\tpatchProcess(!!initData.environment.extensionTestsLocationURI); // to support other test frameworks like Jasmin that use process.exit (https://github.com/microsoft/vscode/issues/37708)\n\tinitData.environment.useHostProxy = args.useHostProxy !== undefined ? args.useHostProxy !== 'false' : undefined;\n\tinitData.environment.skipWorkspaceStorageLock = boolean(args.skipWorkspaceStorageLock, false);\n\n\t// host abstraction\n\tconst hostUtils = new class NodeHost implements IHostUtils {\n\t\tdeclare readonly _serviceBrand: undefined;\n\t\tpublic readonly pid = process.pid;\n\t\texit(code: number) { nativeExit(code); }\n\t\tfsExists(path: string) { return Promises.exists(path); }\n\t\tfsRealpath(path: string) { return Promises.realpath(path); }\n\t};\n\n\t// Attempt to load uri transformer\n\tlet uriTransformer: IURITransformer | null = null;\n\tif (initData.remote.authority && args.transformURIs) {\n\t\turiTransformer = createURITransformer(initData.remote.authority);\n\t}\n\n\tconst extensionHostMain = new ExtensionHostMain(\n\t\trenderer.protocol,\n\t\tinitData,\n\t\thostUtils,\n\t\turiTransformer\n\t);\n\n\t// rewrite onTerminate-function to be a proper shutdown\n\tonTerminate = (reason: string) => extensionHostMain.terminate(reason);\n}\n\nstartExtensionHostProcess().catch((err) => console.log(err));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport minimist from 'minimist';\nimport * as nativeWatchdog from 'native-watchdog';\nimport * as net from 'net';\nimport { ProcessTimeRunOnceScheduler } from '../../../base/common/async.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { PendingMigrationError, isCancellationError, isSigPipeError, onUnexpectedError, onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { Event } from '../../../base/common/event.js';\nimport * as performance from '../../../base/common/performance.js';\nimport { IURITransformer } from '../../../base/common/uriIpc.js';\nimport { Promises } from '../../../base/node/pfs.js';\nimport { IMessagePassingProtocol } from '../../../base/parts/ipc/common/ipc.js';\nimport { BufferedEmitter, PersistentProtocol, ProtocolConstants } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { NodeSocket, WebSocketNodeSocket } from '../../../base/parts/ipc/node/ipc.net.js';\nimport type { MessagePortMain, MessageEvent as UtilityMessageEvent } from '../../../base/parts/sandbox/node/electronTypes.js';\nimport { boolean } from '../../../editor/common/config/editorOptions.js';\nimport product from '../../../platform/product/common/product.js';\nimport { ExtensionHostMain, IExitFn } from '../common/extensionHostMain.js';\nimport { IHostUtils } from '../common/extHostExtensionService.js';\nimport { createURITransformer } from '../../../base/common/uriTransformer.js';\nimport { ExtHostConnectionType, readExtHostConnection } from '../../services/extensions/common/extensionHostEnv.js';\nimport { ExtensionHostExitCode, IExtHostReadyMessage, IExtHostReduceGraceTimeMessage, IExtHostSocketMessage, IExtensionHostInitData, MessageType, createMessageOfType, isMessageOfType } from '../../services/extensions/common/extensionHostProtocol.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport '../common/extHost.common.services.js';\nimport './extHost.node.services.js';\nimport { createRequire } from 'node:module';\nconst require = createRequire(import.meta.url);\n\ninterface ParsedExtHostArgs {\n\ttransformURIs?: boolean;\n\tskipWorkspaceStorageLock?: boolean;\n\tsupportGlobalNavigator?: boolean; // enable global navigator object in nodejs\n\tuseHostProxy?: 'true' | 'false'; // use a string, as undefined is also a valid value\n}\n\n// silence experimental warnings when in development\nif (process.env.VSCODE_DEV) {\n\tconst warningListeners = process.listeners('warning');\n\tprocess.removeAllListeners('warning');\n\tprocess.on('warning', (warning: any) => {\n\t\tif (warning.code === 'ExperimentalWarning' || warning.name === 'ExperimentalWarning' || warning.name === 'DeprecationWarning') {\n\t\t\tconsole.debug(warning);\n\t\t\treturn;\n\t\t}\n\n\t\twarningListeners[0](warning);\n\t});\n}\n\n// workaround for https://github.com/microsoft/vscode/issues/85490\n// remove --inspect-port=0 after start so that it doesn't trigger LSP debugging\n(function removeInspectPort() {\n\tfor (let i = 0; i < process.execArgv.length; i++) {\n\t\tif (process.execArgv[i] === '--inspect-port=0') {\n\t\t\tprocess.execArgv.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n})();\n\nconst args = minimist(process.argv.slice(2), {\n\tboolean: [\n\t\t'transformURIs',\n\t\t'skipWorkspaceStorageLock',\n\t\t'supportGlobalNavigator',\n\t],\n\tstring: [\n\t\t'useHostProxy' // 'true' | 'false' | undefined\n\t]\n}) as ParsedExtHostArgs;\n\n// With Electron 2.x and node.js 8.x the \"natives\" module\n// can cause a native crash (see https://github.com/nodejs/node/issues/19891 and\n// https://github.com/electron/electron/issues/10905). To prevent this from\n// happening we essentially blocklist this module from getting loaded in any\n// extension by patching the node require() function.\n(function () {\n\tconst Module = require('module');\n\tconst originalLoad = Module._load;\n\n\tModule._load = function (request: string) {\n\t\tif (request === 'natives') {\n\t\t\tthrow new Error('Either the extension or an NPM dependency is using the [unsupported \"natives\" node module](https://go.microsoft.com/fwlink/?linkid=871887).');\n\t\t}\n\n\t\treturn originalLoad.apply(this, arguments);\n\t};\n})();\n\n// custom process.exit logic...\nconst nativeExit: IExitFn = process.exit.bind(process);\nconst nativeOn = process.on.bind(process);\nfunction patchProcess(allowExit: boolean) {\n\tprocess.exit = function (code?: number) {\n\t\tif (allowExit) {\n\t\t\tnativeExit(code);\n\t\t} else {\n\t\t\tconst err = new Error('An extension called process.exit() and this was prevented.');\n\t\t\tconsole.warn(err.stack);\n\t\t}\n\t} as (code?: number) => never;\n\n\t// override Electron's process.crash() method\n\t// eslint-disable-next-line local/code-no-any-casts\n\t(process as any /* bypass layer checker */).crash = function () {\n\t\tconst err = new Error('An extension called process.crash() and this was prevented.');\n\t\tconsole.warn(err.stack);\n\t};\n\n\t// Set ELECTRON_RUN_AS_NODE environment variable for extensions that use\n\t// child_process.spawn with process.execPath and expect to run as node process\n\t// on the desktop.\n\t// Refs https://github.com/microsoft/vscode/issues/151012#issuecomment-1156593228\n\tprocess.env['ELECTRON_RUN_AS_NODE'] = '1';\n\n\t// eslint-disable-next-line local/code-no-any-casts\n\tprocess.on = <any>function (event: string, listener: (...args: any[]) => void) {\n\t\tif (event === 'uncaughtException') {\n\t\t\tconst actualListener = listener;\n\t\t\tlistener = function (...args: unknown[]) {\n\t\t\t\ttry {\n\t\t\t\t\treturn actualListener.apply(undefined, args);\n\t\t\t\t} catch {\n\t\t\t\t\t// DO NOT HANDLE NOR PRINT the error here because this can and will lead to\n\t\t\t\t\t// more errors which will cause error handling to be reentrant and eventually\n\t\t\t\t\t// overflowing the stack. Do not be sad, we do handle and annotate uncaught\n\t\t\t\t\t// errors properly in 'extensionHostMain'\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tnativeOn(event, listener);\n\t};\n\n}\n\n// NodeJS since v21 defines navigator as a global object. This will likely surprise many extensions and potentially break them\n// because `navigator` has historically often been used to check if running in a browser (vs running inside NodeJS)\nif (!args.supportGlobalNavigator) {\n\tObject.defineProperty(globalThis, 'navigator', {\n\t\tget: () => {\n\t\t\tonUnexpectedExternalError(new PendingMigrationError('navigator is now a global in nodejs, please see https://aka.ms/vscode-extensions/navigator for additional info on this error.'));\n\t\t\treturn undefined;\n\t\t}\n\t});\n}\n\n\ninterface IRendererConnection {\n\tprotocol: IMessagePassingProtocol;\n\tinitData: IExtensionHostInitData;\n}\n\n// This calls exit directly in case the initialization is not finished and we need to exit\n// Otherwise, if initialization completed we go to extensionHostMain.terminate()\nlet onTerminate = function (reason: string) {\n\tnativeExit();\n};\n\nfunction readReconnectionValue(envKey: string, fallback: number): number {\n\tconst raw = process.env[envKey];\n\tif (typeof raw !== 'string' || raw.trim().length === 0) {\n\t\tconsole.log(`[reconnection-grace-time] Extension host: env var ${envKey} not set, using default: ${fallback}ms (${Math.floor(fallback / 1000)}s)`);\n\t\treturn fallback;\n\t}\n\tconst parsed = Number(raw);\n\tif (!isFinite(parsed) || parsed < 0) {\n\t\tconsole.log(`[reconnection-grace-time] Extension host: env var ${envKey} invalid value '${raw}', using default: ${fallback}ms (${Math.floor(fallback / 1000)}s)`);\n\t\treturn fallback;\n\t}\n\tconst millis = Math.floor(parsed);\n\tconst result = millis > Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : millis;\n\tconsole.log(`[reconnection-grace-time] Extension host: read ${envKey}=${raw}ms (${Math.floor(result / 1000)}s)`);\n\treturn result;\n}\n\nfunction _createExtHostProtocol(): Promise<IMessagePassingProtocol> {\n\tconst extHostConnection = readExtHostConnection(process.env);\n\n\tif (extHostConnection.type === ExtHostConnectionType.MessagePort) {\n\n\t\treturn new Promise<IMessagePassingProtocol>((resolve, reject) => {\n\n\t\t\tconst withPorts = (ports: MessagePortMain[]) => {\n\t\t\t\tconst port = ports[0];\n\t\t\t\tconst onMessage = new BufferedEmitter<VSBuffer>();\n\t\t\t\tport.on('message', (e) => onMessage.fire(VSBuffer.wrap(e.data as Uint8Array)));\n\t\t\t\tport.on('close', () => {\n\t\t\t\t\tonTerminate('renderer closed the MessagePort');\n\t\t\t\t});\n\t\t\t\tport.start();\n\n\t\t\t\tresolve({\n\t\t\t\t\tonMessage: onMessage.event,\n\t\t\t\t\tsend: message => port.postMessage(message.buffer)\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t(process as unknown as { parentPort: { on: (event: 'message', listener: (messageEvent: UtilityMessageEvent) => void) => void } }).parentPort.on('message', (e: UtilityMessageEvent) => withPorts(e.ports));\n\t\t});\n\n\t} else if (extHostConnection.type === ExtHostConnectionType.Socket) {\n\n\t\treturn new Promise<PersistentProtocol>((resolve, reject) => {\n\n\t\t\tlet protocol: PersistentProtocol | null = null;\n\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\tonTerminate('VSCODE_EXTHOST_IPC_SOCKET timeout');\n\t\t\t}, 60000);\n\n\t\t\tconst reconnectionGraceTime = readReconnectionValue('VSCODE_RECONNECTION_GRACE_TIME', ProtocolConstants.ReconnectionGraceTime);\n\t\t\tconst reconnectionShortGraceTime = reconnectionGraceTime > 0 ? Math.min(ProtocolConstants.ReconnectionShortGraceTime, reconnectionGraceTime) : 0;\n\t\t\tconst disconnectRunner1 = new ProcessTimeRunOnceScheduler(() => onTerminate('renderer disconnected for too long (1)'), reconnectionGraceTime);\n\t\t\tconst disconnectRunner2 = new ProcessTimeRunOnceScheduler(() => onTerminate('renderer disconnected for too long (2)'), reconnectionShortGraceTime);\n\n\t\t\tprocess.on('message', (msg: IExtHostSocketMessage | IExtHostReduceGraceTimeMessage, handle: net.Socket) => {\n\t\t\t\tif (msg && msg.type === 'VSCODE_EXTHOST_IPC_SOCKET') {\n\t\t\t\t\t// Disable Nagle's algorithm. We also do this on the server process,\n\t\t\t\t\t// but nodejs doesn't document if this option is transferred with the socket\n\t\t\t\t\thandle.setNoDelay(true);\n\n\t\t\t\t\tconst initialDataChunk = VSBuffer.wrap(Buffer.from(msg.initialDataChunk, 'base64'));\n\t\t\t\t\tlet socket: NodeSocket | WebSocketNodeSocket;\n\t\t\t\t\tif (msg.skipWebSocketFrames) {\n\t\t\t\t\t\tsocket = new NodeSocket(handle, 'extHost-socket');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst inflateBytes = VSBuffer.wrap(Buffer.from(msg.inflateBytes, 'base64'));\n\t\t\t\t\t\tsocket = new WebSocketNodeSocket(new NodeSocket(handle, 'extHost-socket'), msg.permessageDeflate, inflateBytes, false);\n\t\t\t\t\t}\n\t\t\t\t\tif (protocol) {\n\t\t\t\t\t\t// reconnection case\n\t\t\t\t\t\tdisconnectRunner1.cancel();\n\t\t\t\t\t\tdisconnectRunner2.cancel();\n\t\t\t\t\t\tprotocol.beginAcceptReconnection(socket, initialDataChunk);\n\t\t\t\t\t\tprotocol.endAcceptReconnection();\n\t\t\t\t\t\tprotocol.sendResume();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\t\tprotocol = new PersistentProtocol({ socket, initialChunk: initialDataChunk });\n\t\t\t\t\t\tprotocol.sendResume();\n\t\t\t\t\t\tprotocol.onDidDispose(() => onTerminate('renderer disconnected'));\n\t\t\t\t\t\tresolve(protocol);\n\n\t\t\t\t\t\t// Wait for rich client to reconnect\n\t\t\t\t\t\tprotocol.onSocketClose(() => {\n\t\t\t\t\t\t\t// The socket has closed, let's give the renderer a certain amount of time to reconnect\n\t\t\t\t\t\t\tdisconnectRunner1.schedule();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (msg && msg.type === 'VSCODE_EXTHOST_IPC_REDUCE_GRACE_TIME') {\n\t\t\t\t\tif (disconnectRunner2.isScheduled()) {\n\t\t\t\t\t\t// we are disconnected and already running the short reconnection timer\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (disconnectRunner1.isScheduled()) {\n\t\t\t\t\t\t// we are disconnected and running the long reconnection timer\n\t\t\t\t\t\tdisconnectRunner2.schedule();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Now that we have managed to install a message listener, ask the other side to send us the socket\n\t\t\tconst req: IExtHostReadyMessage = { type: 'VSCODE_EXTHOST_IPC_READY' };\n\t\t\tprocess.send?.(req);\n\t\t});\n\n\t} else {\n\n\t\tconst pipeName = extHostConnection.pipeName;\n\n\t\treturn new Promise<PersistentProtocol>((resolve, reject) => {\n\n\t\t\tconst socket = net.createConnection(pipeName, () => {\n\t\t\t\tsocket.removeListener('error', reject);\n\t\t\t\tconst protocol = new PersistentProtocol({ socket: new NodeSocket(socket, 'extHost-renderer') });\n\t\t\t\tprotocol.sendResume();\n\t\t\t\tresolve(protocol);\n\t\t\t});\n\t\t\tsocket.once('error', reject);\n\n\t\t\tsocket.on('close', () => {\n\t\t\t\tonTerminate('renderer closed the socket');\n\t\t\t});\n\t\t});\n\t}\n}\n\nasync function createExtHostProtocol(): Promise<IMessagePassingProtocol> {\n\n\tconst protocol = await _createExtHostProtocol();\n\n\treturn new class implements IMessagePassingProtocol {\n\n\t\tprivate readonly _onMessage = new BufferedEmitter<VSBuffer>();\n\t\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\t\tprivate _terminating: boolean;\n\t\tprivate _protocolListener: IDisposable;\n\n\t\tconstructor() {\n\t\t\tthis._terminating = false;\n\t\t\tthis._protocolListener = protocol.onMessage((msg) => {\n\t\t\t\tif (isMessageOfType(msg, MessageType.Terminate)) {\n\t\t\t\t\tthis._terminating = true;\n\t\t\t\t\tthis._protocolListener.dispose();\n\t\t\t\t\tonTerminate('received terminate message from renderer');\n\t\t\t\t} else {\n\t\t\t\t\tthis._onMessage.fire(msg);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tsend(msg: any): void {\n\t\t\tif (!this._terminating) {\n\t\t\t\tprotocol.send(msg);\n\t\t\t}\n\t\t}\n\n\t\tasync drain(): Promise<void> {\n\t\t\tif (protocol.drain) {\n\t\t\t\treturn protocol.drain();\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction connectToRenderer(protocol: IMessagePassingProtocol): Promise<IRendererConnection> {\n\treturn new Promise<IRendererConnection>((c) => {\n\n\t\t// Listen init data message\n\t\tconst first = protocol.onMessage(raw => {\n\t\t\tfirst.dispose();\n\n\t\t\tconst initData = <IExtensionHostInitData>JSON.parse(raw.toString());\n\n\t\t\tconst rendererCommit = initData.commit;\n\t\t\tconst myCommit = product.commit;\n\n\t\t\tif (rendererCommit && myCommit) {\n\t\t\t\t// Running in the built version where commits are defined\n\t\t\t\tif (rendererCommit !== myCommit) {\n\t\t\t\t\tnativeExit(ExtensionHostExitCode.VersionMismatch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (initData.parentPid) {\n\t\t\t\t// Kill oneself if one's parent dies. Much drama.\n\t\t\t\tlet epermErrors = 0;\n\t\t\t\tsetInterval(function () {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocess.kill(initData.parentPid, 0); // throws an exception if the main process doesn't exist anymore.\n\t\t\t\t\t\tepermErrors = 0;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e && e.code === 'EPERM') {\n\t\t\t\t\t\t\t// Even if the parent process is still alive,\n\t\t\t\t\t\t\t// some antivirus software can lead to an EPERM error to be thrown here.\n\t\t\t\t\t\t\t// Let's terminate only if we get 3 consecutive EPERM errors.\n\t\t\t\t\t\t\tepermErrors++;\n\t\t\t\t\t\t\tif (epermErrors >= 3) {\n\t\t\t\t\t\t\t\tonTerminate(`parent process ${initData.parentPid} does not exist anymore (3 x EPERM): ${e.message} (code: ${e.code}) (errno: ${e.errno})`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonTerminate(`parent process ${initData.parentPid} does not exist anymore: ${e.message} (code: ${e.code}) (errno: ${e.errno})`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, 1000);\n\n\t\t\t\t// In certain cases, the event loop can become busy and never yield\n\t\t\t\t// e.g. while-true or process.nextTick endless loops\n\t\t\t\t// So also use the native node module to do it from a separate thread\n\t\t\t\tlet watchdog: typeof nativeWatchdog;\n\t\t\t\ttry {\n\t\t\t\t\twatchdog = require('native-watchdog');\n\t\t\t\t\twatchdog.start(initData.parentPid);\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// no problem...\n\t\t\t\t\tonUnexpectedError(err);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tell the outside that we are initialized\n\t\t\tprotocol.send(createMessageOfType(MessageType.Initialized));\n\n\t\t\tc({ protocol, initData });\n\t\t});\n\n\t\t// Tell the outside that we are ready to receive messages\n\t\tprotocol.send(createMessageOfType(MessageType.Ready));\n\t});\n}\n\nasync function startExtensionHostProcess(): Promise<void> {\n\n\t// Print a console message when rejection isn't handled within N seconds. For details:\n\t// see https://nodejs.org/api/process.html#process_event_unhandledrejection\n\t// and https://nodejs.org/api/process.html#process_event_rejectionhandled\n\tconst unhandledPromises: Promise<any>[] = [];\n\tprocess.on('unhandledRejection', (reason: any, promise: Promise<any>) => {\n\t\tunhandledPromises.push(promise);\n\t\tsetTimeout(() => {\n\t\t\tconst idx = unhandledPromises.indexOf(promise);\n\t\t\tif (idx >= 0) {\n\t\t\t\tpromise.catch(e => {\n\t\t\t\t\tunhandledPromises.splice(idx, 1);\n\t\t\t\t\tif (!isCancellationError(e)) {\n\t\t\t\t\t\tconsole.warn(`rejected promise not handled within 1 second: ${e}`);\n\t\t\t\t\t\tif (e && e.stack) {\n\t\t\t\t\t\t\tconsole.warn(`stack trace: ${e.stack}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (reason) {\n\t\t\t\t\t\t\tonUnexpectedError(reason);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, 1000);\n\t});\n\n\tprocess.on('rejectionHandled', (promise: Promise<any>) => {\n\t\tconst idx = unhandledPromises.indexOf(promise);\n\t\tif (idx >= 0) {\n\t\t\tunhandledPromises.splice(idx, 1);\n\t\t}\n\t});\n\n\t// Print a console message when an exception isn't handled.\n\tprocess.on('uncaughtException', function (err: Error) {\n\t\tif (!isSigPipeError(err)) {\n\t\t\tonUnexpectedError(err);\n\t\t}\n\t});\n\n\tperformance.mark(`code/extHost/willConnectToRenderer`);\n\tconst protocol = await createExtHostProtocol();\n\tperformance.mark(`code/extHost/didConnectToRenderer`);\n\tconst renderer = await connectToRenderer(protocol);\n\tperformance.mark(`code/extHost/didWaitForInitData`);\n\tconst { initData } = renderer;\n\t// setup things\n\tpatchProcess(!!initData.environment.extensionTestsLocationURI); // to support other test frameworks like Jasmin that use process.exit (https://github.com/microsoft/vscode/issues/37708)\n\tinitData.environment.useHostProxy = args.useHostProxy !== undefined ? args.useHostProxy !== 'false' : undefined;\n\tinitData.environment.skipWorkspaceStorageLock = boolean(args.skipWorkspaceStorageLock, false);\n\n\t// host abstraction\n\tconst hostUtils = new class NodeHost implements IHostUtils {\n\t\tdeclare readonly _serviceBrand: undefined;\n\t\tpublic readonly pid = process.pid;\n\t\texit(code: number) { nativeExit(code); }\n\t\tfsExists(path: string) { return Promises.exists(path); }\n\t\tfsRealpath(path: string) { return Promises.realpath(path); }\n\t};\n\n\t// Attempt to load uri transformer\n\tlet uriTransformer: IURITransformer | null = null;\n\tif (initData.remote.authority && args.transformURIs) {\n\t\turiTransformer = createURITransformer(initData.remote.authority);\n\t}\n\n\tconst extensionHostMain = new ExtensionHostMain(\n\t\trenderer.protocol,\n\t\tinitData,\n\t\thostUtils,\n\t\turiTransformer\n\t);\n\n\t// rewrite onTerminate-function to be a proper shutdown\n\tonTerminate = (reason: string) => extensionHostMain.terminate(reason);\n}\n\nstartExtensionHostProcess().catch((err) => console.log(err));\n"]}