{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/node/extHostMcpNode.ts","vs/workbench/api/node/extHostMcpNode.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAkC,KAAK,EAAE,MAAM,eAAe,CAAC;AACtE,OAAO,EAAE,QAAQ,EAAE,MAAM,aAAa,CAAC;AACvC,OAAO,EAAE,OAAO,EAAE,MAAM,IAAI,CAAC;AAE7B,OAAO,EAAE,YAAY,EAAE,MAAM,iCAAiC,CAAC;AAC/D,OAAO,EAAE,SAAS,EAAE,MAAM,gCAAgC,CAAC;AAC3D,OAAO,EAAE,IAAI,EAAE,MAAM,8BAA8B,CAAC;AACpD,OAAO,EAAE,aAAa,EAAE,MAAM,mCAAmC,CAAC;AAClE,OAAO,KAAK,IAAI,MAAM,8BAA8B,CAAC;AACrD,OAAO,EAAE,GAAG,EAAE,MAAM,6BAA6B,CAAC;AAClD,OAAO,EAAE,cAAc,EAAE,MAAM,mCAAmC,CAAC;AACnE,OAAO,EAAE,cAAc,EAAE,MAAM,iCAAiC,CAAC;AACjE,OAAO,EAAE,QAAQ,EAAE,MAAM,qCAAqC,CAAC;AAE/D,OAAO,EAAE,oBAAoB,EAAE,MAAM,gDAAgD,CAAC;AACtF,OAAO,EAAqC,iBAAiB,EAAE,aAAa,EAAE,MAAM,yBAAyB,CAAC;AAE9G,MAAM,OAAO,qBAAsB,SAAQ,iBAAiB;IAA5D;;QACS,gBAAW,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,aAAa,EAAgC,CAAC,CAAC;IAoHzF,CAAC;IAlHmB,SAAS,CAAC,EAAU,EAAE,MAAuB,EAAE,UAAgB,EAAE,sBAAgC;QACnH,IAAI,MAAM,CAAC,IAAI,yCAAiC,EAAE,CAAC;YAClD,IAAI,CAAC,YAAY,CAAC,EAAE,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;QAC3C,CAAC;aAAM,IAAI,MAAM,CAAC,IAAI,wCAAgC,EAAE,CAAC;YACxD,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,iBAAiB,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,WAAW,EAAE,sBAAsB,CAAC,CAAC,CAAC;QACzH,CAAC;aAAM,CAAC;YACP,KAAK,CAAC,SAAS,CAAC,EAAE,EAAE,MAAM,EAAE,UAAU,EAAE,sBAAsB,CAAC,CAAC;QACjE,CAAC;IACF,CAAC;IAEQ,QAAQ,CAAC,EAAU;QAC3B,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAC5C,IAAI,UAAU,EAAE,CAAC;YAChB,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC,0DAA0D;QAC9E,CAAC;aAAM,CAAC;YACP,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QACpB,CAAC;IACF,CAAC;IAEQ,YAAY,CAAC,EAAU,EAAE,OAAe;QAChD,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAC5C,IAAI,UAAU,EAAE,CAAC;YAChB,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QAC3B,CAAC;aAAM,CAAC;YACP,KAAK,CAAC,YAAY,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;QACjC,CAAC;IACF,CAAC;IAEO,KAAK,CAAC,YAAY,CAAC,EAAU,EAAE,MAA+B,EAAE,UAAgB;QACvF,MAAM,OAAO,GAAG,CAAC,GAAmB,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,EAAE,EAAE;YAC1E,KAAK,uCAA+B;YACpC,mDAAmD;YACnD,IAAI,EAAE,GAAG,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAE,GAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS;YACxE,OAAO,EAAE,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO;SACpD,CAAC,CAAC;QAEH,uEAAuE;QACvE,yEAAyE;QACzE,MAAM,GAAG,GAAG,EAAE,GAAG,OAAO,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;YACpB,IAAI,CAAC;gBACJ,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,YAAY,CAAC,MAAM,QAAQ,CAAC,MAAM,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,EAAE,CAAC;oBAClF,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;gBAClB,CAAC;YACF,CAAC;YAAC,OAAO,CAAC,EAAE,CAAC;gBACZ,OAAO,CAAC,2BAA2B,MAAM,CAAC,OAAO,MAAM,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;gBACpE,OAAO;YACR,CAAC;QACF,CAAC;QACD,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC;YACvD,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACvD,CAAC;QAED,IAAI,KAAqC,CAAC;QAC1C,IAAI,CAAC;YACJ,MAAM,IAAI,GAAG,OAAO,EAAE,CAAC;YACvB,IAAI,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,EAAE,MAAM,IAAI,IAAI,CAAC,CAAC;YAClF,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;gBAC3B,GAAG,GAAG,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;YAC7E,CAAC;YAED,MAAM,EAAE,UAAU,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yBAAyB,CAClE,SAAS,CAAC,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,EAC/B,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EACxC,GAAG,EACH,GAAG,CACH,CAAC;YAEF,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAAE,EAAE,QAAQ,CAAC,KAAK,EAAE,wBAAwB,UAAU,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;YACzG,KAAK,GAAG,KAAK,CAAC,UAAU,EAAE,IAAI,EAAE;gBAC/B,KAAK,EAAE,MAAM;gBACb,GAAG;gBACH,GAAG;gBACH,KAAK;aACL,CAAC,CAAC;QACJ,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,OAAO,CAAC,CAAC,CAAC,CAAC;YACX,OAAO;QACR,CAAC;QAED,sDAAsD;QACtD,MAAM,iBAAiB,GAAG,IAAI,oBAAoB,CAAC,KAAK,CAAC,CAAC;QAE1D,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,EAAE,EAAE,EAAE,KAAK,0CAAkC,EAAE,CAAC,CAAC;QAE/E,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,oBAAoB,CAAC,EAAE,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;QAEtH,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QACjC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAElC,8GAA8G;QAC9G,4CAA4C;QAC5C,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAAE,EAAE,QAAQ,CAAC,OAAO,EAAE,mBAAmB,IAAI,CAAC,QAAQ,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;QAEnK,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,EAAE,EAAE,EAAE,KAAK,yCAAiC,EAAE,CAAC,CAAC,CAAC;QAEvG,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE;YACrB,OAAO,CAAC,CAAC,CAAC,CAAC;QACZ,CAAC,CAAC,CAAC;QACH,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;YACvB,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC;YAEtC,IAAI,IAAI,KAAK,CAAC,IAAI,iBAAiB,CAAC,OAAO,EAAE,CAAC;gBAC7C,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,EAAE,EAAE,EAAE,KAAK,yCAAiC,EAAE,CAAC,CAAC;YAC/E,CAAC;iBAAM,CAAC;gBACP,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,EAAE,EAAE;oBACjC,KAAK,uCAA+B;oBACpC,OAAO,EAAE,4BAA4B,IAAI,EAAE;iBAC3C,CAAC,CAAC;YACJ,CAAC;QACF,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,EAAE,EAAE,iBAAiB,CAAC,CAAC;IAC7C,CAAC;CACD;AAED,MAAM,iBAAkB,SAAQ,aAAa;IAA7C;;QACkB,YAAO,GAAG,IAAI,IAAI,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;IAwC7D,CAAC;IAtCmB,KAAK,CAAC,cAAc,CAAC,GAAW,EAAE,IAAwB;QAC5E,kGAAkG;QAClG,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC;QAElD,MAAM,UAAU,GAAsB,EAAE,GAAG,IAAI,EAAE,CAAC;QAElD,IAAI,OAAO,GAAG,GAAG,CAAC;QAClB,MAAM,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAE3B,IAAI,GAAG,CAAC,MAAM,KAAK,MAAM,IAAI,GAAG,CAAC,MAAM,KAAK,MAAM,EAAE,CAAC;YACpD,kGAAkG;YAClG,8CAA8C;YAC9C,UAAU,CAAC,UAAU,GAAG,IAAI,KAAK,CAAC;gBACjC,UAAU,EAAE,GAAG,CAAC,IAAI;aACpB,CAAC,CAAC;YAEH,6DAA6D;YAC7D,OAAO,GAAG,GAAG,CAAC,IAAI,CAAC;gBAClB,MAAM,EAAE,MAAM;gBACd,SAAS,EAAE,WAAW,EAAE,+HAA+H;gBACvJ,IAAI,EAAE,GAAG,CAAC,QAAQ;aAClB,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACnB,CAAC;aAAM,CAAC;YACP,OAAO,KAAK,CAAC,cAAc,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QACxC,CAAC;QAED,MAAM,cAAc,GAAG,MAAM,KAAK,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;QAExD,OAAO;YACN,MAAM,EAAE,cAAc,CAAC,MAAM;YAC7B,UAAU,EAAE,cAAc,CAAC,UAAU;YACrC,OAAO,EAAE,cAAc,CAAC,OAAO;YAC/B,IAAI,EAAE,cAAc,CAAC,IAAsB,EAAE,mJAAmJ;YAChM,GAAG,EAAE,cAAc,CAAC,GAAG;YACvB,IAAI,EAAE,GAAG,EAAE,CAAC,cAAc,CAAC,IAAI,EAAE;YACjC,IAAI,EAAE,GAAG,EAAE,CAAC,cAAc,CAAC,IAAI,EAAE;SACjC,CAAC;IACH,CAAC;CACD;AAED,MAAM,oBAAoB,GAAG,eAAe,CAAC;AAE7C;;GAEG;AACH,MAAM,CAAC,MAAM,yBAAyB,GAAG,KAAK,EAC7C,UAAkB,EAClB,IAA2B,EAC3B,GAAuB,EACvB,GAAuC,EACtC,EAAE;IACH,IAAI,OAAO,CAAC,QAAQ,KAAK,OAAO,EAAE,CAAC;QAClC,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC;IAC3C,CAAC;IAED,MAAM,KAAK,GAAG,MAAM,cAAc,CAAC,UAAU,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG,CAAC,CAAC;IACpE,IAAI,KAAK,IAAI,oBAAoB,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;QAC/C,MAAM,KAAK,GAAG,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5D,OAAO;YACN,UAAU,EAAE,KAAK,CAAC,KAAK,CAAC;YACxB,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;YACrB,KAAK,EAAE,IAAI;SACX,CAAC;IACH,CAAC;IAED,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC;AAC3C,CAAC,CAAC","file":"extHostMcpNode.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcessWithoutNullStreams, spawn } from 'child_process';\nimport { readFile } from 'fs/promises';\nimport { homedir } from 'os';\nimport type { RequestInit as UndiciRequestInit } from 'undici';\nimport { parseEnvFile } from '../../../base/common/envfile.js';\nimport { untildify } from '../../../base/common/labels.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nimport { DisposableMap } from '../../../base/common/lifecycle.js';\nimport * as path from '../../../base/common/path.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { StreamSplitter } from '../../../base/node/nodeStreams.js';\nimport { findExecutable } from '../../../base/node/processes.js';\nimport { LogLevel } from '../../../platform/log/common/log.js';\nimport { McpConnectionState, McpServerLaunch, McpServerTransportStdio, McpServerTransportType } from '../../contrib/mcp/common/mcpTypes.js';\nimport { McpStdioStateHandler } from '../../contrib/mcp/node/mcpStdioStateHandler.js';\nimport { CommonRequestInit, CommonResponse, ExtHostMcpService, McpHTTPHandle } from '../common/extHostMcp.js';\n\nexport class NodeExtHostMpcService extends ExtHostMcpService {\n\tprivate nodeServers = this._register(new DisposableMap<number, McpStdioStateHandler>());\n\n\tprotected override _startMcp(id: number, launch: McpServerLaunch, defaultCwd?: URI, errorOnUserInteraction?: boolean): void {\n\t\tif (launch.type === McpServerTransportType.Stdio) {\n\t\t\tthis.startNodeMpc(id, launch, defaultCwd);\n\t\t} else if (launch.type === McpServerTransportType.HTTP) {\n\t\t\tthis._sseEventSources.set(id, new McpHTTPHandleNode(id, launch, this._proxy, this._logService, errorOnUserInteraction));\n\t\t} else {\n\t\t\tsuper._startMcp(id, launch, defaultCwd, errorOnUserInteraction);\n\t\t}\n\t}\n\n\toverride $stopMcp(id: number): void {\n\t\tconst nodeServer = this.nodeServers.get(id);\n\t\tif (nodeServer) {\n\t\t\tnodeServer.stop(); // will get removed from map when process is fully stopped\n\t\t} else {\n\t\t\tsuper.$stopMcp(id);\n\t\t}\n\t}\n\n\toverride $sendMessage(id: number, message: string): void {\n\t\tconst nodeServer = this.nodeServers.get(id);\n\t\tif (nodeServer) {\n\t\t\tnodeServer.write(message);\n\t\t} else {\n\t\t\tsuper.$sendMessage(id, message);\n\t\t}\n\t}\n\n\tprivate async startNodeMpc(id: number, launch: McpServerTransportStdio, defaultCwd?: URI): Promise<void> {\n\t\tconst onError = (err: Error | string) => this._proxy.$onDidChangeState(id, {\n\t\t\tstate: McpConnectionState.Kind.Error,\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tcode: err.hasOwnProperty('code') ? String((err as any).code) : undefined,\n\t\t\tmessage: typeof err === 'string' ? err : err.message,\n\t\t});\n\n\t\t// MCP servers are run on the same authority where they are defined, so\n\t\t// reading the envfile based on its path off the filesystem here is fine.\n\t\tconst env = { ...process.env };\n\t\tif (launch.envFile) {\n\t\t\ttry {\n\t\t\t\tfor (const [key, value] of parseEnvFile(await readFile(launch.envFile, 'utf-8'))) {\n\t\t\t\t\tenv[key] = value;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonError(`Failed to read envFile '${launch.envFile}': ${e.message}`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor (const [key, value] of Object.entries(launch.env)) {\n\t\t\tenv[key] = value === null ? undefined : String(value);\n\t\t}\n\n\t\tlet child: ChildProcessWithoutNullStreams;\n\t\ttry {\n\t\t\tconst home = homedir();\n\t\t\tlet cwd = launch.cwd ? untildify(launch.cwd, home) : (defaultCwd?.fsPath || home);\n\t\t\tif (!path.isAbsolute(cwd)) {\n\t\t\t\tcwd = defaultCwd ? path.join(defaultCwd.fsPath, cwd) : path.join(home, cwd);\n\t\t\t}\n\n\t\t\tconst { executable, args, shell } = await formatSubprocessArguments(\n\t\t\t\tuntildify(launch.command, home),\n\t\t\t\tlaunch.args.map(a => untildify(a, home)),\n\t\t\t\tcwd,\n\t\t\t\tenv\n\t\t\t);\n\n\t\t\tthis._proxy.$onDidPublishLog(id, LogLevel.Debug, `Server command line: ${executable} ${args.join(' ')}`);\n\t\t\tchild = spawn(executable, args, {\n\t\t\t\tstdio: 'pipe',\n\t\t\t\tcwd,\n\t\t\t\tenv,\n\t\t\t\tshell,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tonError(e);\n\t\t\treturn;\n\t\t}\n\n\t\t// Create the connection manager for graceful shutdown\n\t\tconst connectionManager = new McpStdioStateHandler(child);\n\n\t\tthis._proxy.$onDidChangeState(id, { state: McpConnectionState.Kind.Starting });\n\n\t\tchild.stdout.pipe(new StreamSplitter('\\n')).on('data', line => this._proxy.$onDidReceiveMessage(id, line.toString()));\n\n\t\tchild.stdin.on('error', onError);\n\t\tchild.stdout.on('error', onError);\n\n\t\t// Stderr handling is not currently specified https://github.com/modelcontextprotocol/specification/issues/177\n\t\t// Just treat it as generic log data for now\n\t\tchild.stderr.pipe(new StreamSplitter('\\n')).on('data', line => this._proxy.$onDidPublishLog(id, LogLevel.Warning, `[server stderr] ${line.toString().trimEnd()}`));\n\n\t\tchild.on('spawn', () => this._proxy.$onDidChangeState(id, { state: McpConnectionState.Kind.Running }));\n\n\t\tchild.on('error', e => {\n\t\t\tonError(e);\n\t\t});\n\t\tchild.on('exit', code => {\n\t\t\tthis.nodeServers.deleteAndDispose(id);\n\n\t\t\tif (code === 0 || connectionManager.stopped) {\n\t\t\t\tthis._proxy.$onDidChangeState(id, { state: McpConnectionState.Kind.Stopped });\n\t\t\t} else {\n\t\t\t\tthis._proxy.$onDidChangeState(id, {\n\t\t\t\t\tstate: McpConnectionState.Kind.Error,\n\t\t\t\t\tmessage: `Process exited with code ${code}`,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tthis.nodeServers.set(id, connectionManager);\n\t}\n}\n\nclass McpHTTPHandleNode extends McpHTTPHandle {\n\tprivate readonly _undici = new Lazy(() => import('undici'));\n\n\tprotected override async _fetchInternal(url: string, init?: CommonRequestInit): Promise<CommonResponse> {\n\t\t// Note: imported async so that we can ensure we load undici after proxy patches have been applied\n\t\tconst { fetch, Agent } = await this._undici.value;\n\n\t\tconst undiciInit: UndiciRequestInit = { ...init };\n\n\t\tlet httpUrl = url;\n\t\tconst uri = URI.parse(url);\n\n\t\tif (uri.scheme === 'unix' || uri.scheme === 'pipe') {\n\t\t\t// By convention, we put the *socket path* as the URI path, and the *request path* in the fragment\n\t\t\t// So, set the dispatcher with the socket path\n\t\t\tundiciInit.dispatcher = new Agent({\n\t\t\t\tsocketPath: uri.path,\n\t\t\t});\n\n\t\t\t// And then rewrite the URL to be http://localhost/<fragment>\n\t\t\thttpUrl = uri.with({\n\t\t\t\tscheme: 'http',\n\t\t\t\tauthority: 'localhost', // HTTP always wants a host (not that we're using it), but if we're using a socket or pipe then localhost is sorta right anyway\n\t\t\t\tpath: uri.fragment,\n\t\t\t}).toString(true);\n\t\t} else {\n\t\t\treturn super._fetchInternal(url, init);\n\t\t}\n\n\t\tconst undiciResponse = await fetch(httpUrl, undiciInit);\n\n\t\treturn {\n\t\t\tstatus: undiciResponse.status,\n\t\t\tstatusText: undiciResponse.statusText,\n\t\t\theaders: undiciResponse.headers,\n\t\t\tbody: undiciResponse.body as ReadableStream, // Way down in `ReadableStreamReadDoneResult<T>`, `value` is optional in the undici type but required (yet can be `undefined`) in the standard type\n\t\t\turl: undiciResponse.url,\n\t\t\tjson: () => undiciResponse.json(),\n\t\t\ttext: () => undiciResponse.text(),\n\t\t};\n\t}\n}\n\nconst windowsShellScriptRe = /\\.(bat|cmd)$/i;\n\n/**\n * Formats arguments to avoid issues on Windows for CVE-2024-27980.\n */\nexport const formatSubprocessArguments = async (\n\texecutable: string,\n\targs: ReadonlyArray<string>,\n\tcwd: string | undefined,\n\tenv: Record<string, string | undefined>,\n) => {\n\tif (process.platform !== 'win32') {\n\t\treturn { executable, args, shell: false };\n\t}\n\n\tconst found = await findExecutable(executable, cwd, undefined, env);\n\tif (found && windowsShellScriptRe.test(found)) {\n\t\tconst quote = (s: string) => s.includes(' ') ? `\"${s}\"` : s;\n\t\treturn {\n\t\t\texecutable: quote(found),\n\t\t\targs: args.map(quote),\n\t\t\tshell: true,\n\t\t};\n\t}\n\n\treturn { executable, args, shell: false };\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcessWithoutNullStreams, spawn } from 'child_process';\nimport { readFile } from 'fs/promises';\nimport { homedir } from 'os';\nimport type { RequestInit as UndiciRequestInit } from 'undici';\nimport { parseEnvFile } from '../../../base/common/envfile.js';\nimport { untildify } from '../../../base/common/labels.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nimport { DisposableMap } from '../../../base/common/lifecycle.js';\nimport * as path from '../../../base/common/path.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { StreamSplitter } from '../../../base/node/nodeStreams.js';\nimport { findExecutable } from '../../../base/node/processes.js';\nimport { LogLevel } from '../../../platform/log/common/log.js';\nimport { McpConnectionState, McpServerLaunch, McpServerTransportStdio, McpServerTransportType } from '../../contrib/mcp/common/mcpTypes.js';\nimport { McpStdioStateHandler } from '../../contrib/mcp/node/mcpStdioStateHandler.js';\nimport { CommonRequestInit, CommonResponse, ExtHostMcpService, McpHTTPHandle } from '../common/extHostMcp.js';\n\nexport class NodeExtHostMpcService extends ExtHostMcpService {\n\tprivate nodeServers = this._register(new DisposableMap<number, McpStdioStateHandler>());\n\n\tprotected override _startMcp(id: number, launch: McpServerLaunch, defaultCwd?: URI, errorOnUserInteraction?: boolean): void {\n\t\tif (launch.type === McpServerTransportType.Stdio) {\n\t\t\tthis.startNodeMpc(id, launch, defaultCwd);\n\t\t} else if (launch.type === McpServerTransportType.HTTP) {\n\t\t\tthis._sseEventSources.set(id, new McpHTTPHandleNode(id, launch, this._proxy, this._logService, errorOnUserInteraction));\n\t\t} else {\n\t\t\tsuper._startMcp(id, launch, defaultCwd, errorOnUserInteraction);\n\t\t}\n\t}\n\n\toverride $stopMcp(id: number): void {\n\t\tconst nodeServer = this.nodeServers.get(id);\n\t\tif (nodeServer) {\n\t\t\tnodeServer.stop(); // will get removed from map when process is fully stopped\n\t\t} else {\n\t\t\tsuper.$stopMcp(id);\n\t\t}\n\t}\n\n\toverride $sendMessage(id: number, message: string): void {\n\t\tconst nodeServer = this.nodeServers.get(id);\n\t\tif (nodeServer) {\n\t\t\tnodeServer.write(message);\n\t\t} else {\n\t\t\tsuper.$sendMessage(id, message);\n\t\t}\n\t}\n\n\tprivate async startNodeMpc(id: number, launch: McpServerTransportStdio, defaultCwd?: URI): Promise<void> {\n\t\tconst onError = (err: Error | string) => this._proxy.$onDidChangeState(id, {\n\t\t\tstate: McpConnectionState.Kind.Error,\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tcode: err.hasOwnProperty('code') ? String((err as any).code) : undefined,\n\t\t\tmessage: typeof err === 'string' ? err : err.message,\n\t\t});\n\n\t\t// MCP servers are run on the same authority where they are defined, so\n\t\t// reading the envfile based on its path off the filesystem here is fine.\n\t\tconst env = { ...process.env };\n\t\tif (launch.envFile) {\n\t\t\ttry {\n\t\t\t\tfor (const [key, value] of parseEnvFile(await readFile(launch.envFile, 'utf-8'))) {\n\t\t\t\t\tenv[key] = value;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonError(`Failed to read envFile '${launch.envFile}': ${e.message}`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor (const [key, value] of Object.entries(launch.env)) {\n\t\t\tenv[key] = value === null ? undefined : String(value);\n\t\t}\n\n\t\tlet child: ChildProcessWithoutNullStreams;\n\t\ttry {\n\t\t\tconst home = homedir();\n\t\t\tlet cwd = launch.cwd ? untildify(launch.cwd, home) : (defaultCwd?.fsPath || home);\n\t\t\tif (!path.isAbsolute(cwd)) {\n\t\t\t\tcwd = defaultCwd ? path.join(defaultCwd.fsPath, cwd) : path.join(home, cwd);\n\t\t\t}\n\n\t\t\tconst { executable, args, shell } = await formatSubprocessArguments(\n\t\t\t\tuntildify(launch.command, home),\n\t\t\t\tlaunch.args.map(a => untildify(a, home)),\n\t\t\t\tcwd,\n\t\t\t\tenv\n\t\t\t);\n\n\t\t\tthis._proxy.$onDidPublishLog(id, LogLevel.Debug, `Server command line: ${executable} ${args.join(' ')}`);\n\t\t\tchild = spawn(executable, args, {\n\t\t\t\tstdio: 'pipe',\n\t\t\t\tcwd,\n\t\t\t\tenv,\n\t\t\t\tshell,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tonError(e);\n\t\t\treturn;\n\t\t}\n\n\t\t// Create the connection manager for graceful shutdown\n\t\tconst connectionManager = new McpStdioStateHandler(child);\n\n\t\tthis._proxy.$onDidChangeState(id, { state: McpConnectionState.Kind.Starting });\n\n\t\tchild.stdout.pipe(new StreamSplitter('\\n')).on('data', line => this._proxy.$onDidReceiveMessage(id, line.toString()));\n\n\t\tchild.stdin.on('error', onError);\n\t\tchild.stdout.on('error', onError);\n\n\t\t// Stderr handling is not currently specified https://github.com/modelcontextprotocol/specification/issues/177\n\t\t// Just treat it as generic log data for now\n\t\tchild.stderr.pipe(new StreamSplitter('\\n')).on('data', line => this._proxy.$onDidPublishLog(id, LogLevel.Warning, `[server stderr] ${line.toString().trimEnd()}`));\n\n\t\tchild.on('spawn', () => this._proxy.$onDidChangeState(id, { state: McpConnectionState.Kind.Running }));\n\n\t\tchild.on('error', e => {\n\t\t\tonError(e);\n\t\t});\n\t\tchild.on('exit', code => {\n\t\t\tthis.nodeServers.deleteAndDispose(id);\n\n\t\t\tif (code === 0 || connectionManager.stopped) {\n\t\t\t\tthis._proxy.$onDidChangeState(id, { state: McpConnectionState.Kind.Stopped });\n\t\t\t} else {\n\t\t\t\tthis._proxy.$onDidChangeState(id, {\n\t\t\t\t\tstate: McpConnectionState.Kind.Error,\n\t\t\t\t\tmessage: `Process exited with code ${code}`,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tthis.nodeServers.set(id, connectionManager);\n\t}\n}\n\nclass McpHTTPHandleNode extends McpHTTPHandle {\n\tprivate readonly _undici = new Lazy(() => import('undici'));\n\n\tprotected override async _fetchInternal(url: string, init?: CommonRequestInit): Promise<CommonResponse> {\n\t\t// Note: imported async so that we can ensure we load undici after proxy patches have been applied\n\t\tconst { fetch, Agent } = await this._undici.value;\n\n\t\tconst undiciInit: UndiciRequestInit = { ...init };\n\n\t\tlet httpUrl = url;\n\t\tconst uri = URI.parse(url);\n\n\t\tif (uri.scheme === 'unix' || uri.scheme === 'pipe') {\n\t\t\t// By convention, we put the *socket path* as the URI path, and the *request path* in the fragment\n\t\t\t// So, set the dispatcher with the socket path\n\t\t\tundiciInit.dispatcher = new Agent({\n\t\t\t\tsocketPath: uri.path,\n\t\t\t});\n\n\t\t\t// And then rewrite the URL to be http://localhost/<fragment>\n\t\t\thttpUrl = uri.with({\n\t\t\t\tscheme: 'http',\n\t\t\t\tauthority: 'localhost', // HTTP always wants a host (not that we're using it), but if we're using a socket or pipe then localhost is sorta right anyway\n\t\t\t\tpath: uri.fragment,\n\t\t\t}).toString(true);\n\t\t} else {\n\t\t\treturn super._fetchInternal(url, init);\n\t\t}\n\n\t\tconst undiciResponse = await fetch(httpUrl, undiciInit);\n\n\t\treturn {\n\t\t\tstatus: undiciResponse.status,\n\t\t\tstatusText: undiciResponse.statusText,\n\t\t\theaders: undiciResponse.headers,\n\t\t\tbody: undiciResponse.body as ReadableStream, // Way down in `ReadableStreamReadDoneResult<T>`, `value` is optional in the undici type but required (yet can be `undefined`) in the standard type\n\t\t\turl: undiciResponse.url,\n\t\t\tjson: () => undiciResponse.json(),\n\t\t\ttext: () => undiciResponse.text(),\n\t\t};\n\t}\n}\n\nconst windowsShellScriptRe = /\\.(bat|cmd)$/i;\n\n/**\n * Formats arguments to avoid issues on Windows for CVE-2024-27980.\n */\nexport const formatSubprocessArguments = async (\n\texecutable: string,\n\targs: ReadonlyArray<string>,\n\tcwd: string | undefined,\n\tenv: Record<string, string | undefined>,\n) => {\n\tif (process.platform !== 'win32') {\n\t\treturn { executable, args, shell: false };\n\t}\n\n\tconst found = await findExecutable(executable, cwd, undefined, env);\n\tif (found && windowsShellScriptRe.test(found)) {\n\t\tconst quote = (s: string) => s.includes(' ') ? `\"${s}\"` : s;\n\t\treturn {\n\t\t\texecutable: quote(found),\n\t\t\targs: args.map(quote),\n\t\t\tshell: true,\n\t\t};\n\t}\n\n\treturn { executable, args, shell: false };\n};\n"]}