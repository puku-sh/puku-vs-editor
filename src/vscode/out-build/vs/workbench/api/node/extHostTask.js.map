{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/node/extHostTask.ts","vs/workbench/api/node/extHostTask.ts"],"names":[],"mappings":"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","file":"extHostTask.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from '../../../base/common/path.js';\n\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { findExecutable } from '../../../base/node/processes.js';\nimport * as types from '../common/extHostTypes.js';\nimport { IExtHostWorkspace } from '../common/extHostWorkspace.js';\nimport type * as vscode from 'vscode';\nimport * as tasks from '../common/shared/tasks.js';\nimport { IExtHostDocumentsAndEditors } from '../common/extHostDocumentsAndEditors.js';\nimport { IExtHostConfiguration } from '../common/extHostConfiguration.js';\nimport { IWorkspaceFolder, WorkspaceFolder } from '../../../platform/workspace/common/workspace.js';\nimport { IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { IExtHostTerminalService } from '../common/extHostTerminalService.js';\nimport { IExtHostRpcService } from '../common/extHostRpcService.js';\nimport { IExtHostInitDataService } from '../common/extHostInitDataService.js';\nimport { ExtHostTaskBase, TaskHandleDTO, TaskDTO, CustomExecutionDTO, HandlerData } from '../common/extHostTask.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { IExtHostApiDeprecationService } from '../common/extHostApiDeprecationService.js';\nimport * as resources from '../../../base/common/resources.js';\nimport { homedir } from 'os';\nimport { IExtHostVariableResolverProvider } from '../common/extHostVariableResolverService.js';\n\nexport class ExtHostTask extends ExtHostTaskBase {\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService initData: IExtHostInitDataService,\n\t\t@IExtHostWorkspace private readonly workspaceService: IExtHostWorkspace,\n\t\t@IExtHostDocumentsAndEditors editorService: IExtHostDocumentsAndEditors,\n\t\t@IExtHostConfiguration configurationService: IExtHostConfiguration,\n\t\t@IExtHostTerminalService extHostTerminalService: IExtHostTerminalService,\n\t\t@ILogService logService: ILogService,\n\t\t@IExtHostApiDeprecationService deprecationService: IExtHostApiDeprecationService,\n\t\t@IExtHostVariableResolverProvider private readonly variableResolver: IExtHostVariableResolverProvider,\n\t) {\n\t\tsuper(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService);\n\t\tif (initData.remote.isRemote && initData.remote.authority) {\n\t\t\tthis.registerTaskSystem(Schemas.vscodeRemote, {\n\t\t\t\tscheme: Schemas.vscodeRemote,\n\t\t\t\tauthority: initData.remote.authority,\n\t\t\t\tplatform: process.platform\n\t\t\t});\n\t\t} else {\n\t\t\tthis.registerTaskSystem(Schemas.file, {\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\tauthority: '',\n\t\t\t\tplatform: process.platform\n\t\t\t});\n\t\t}\n\t\tthis._proxy.$registerSupportedExecutions(true, true, true);\n\t}\n\n\tpublic async executeTask(extension: IExtensionDescription, task: vscode.Task): Promise<vscode.TaskExecution> {\n\t\tconst tTask = (task as types.Task);\n\n\t\tif (!task.execution && (tTask._id === undefined)) {\n\t\t\tthrow new Error('Tasks to execute must include an execution');\n\t\t}\n\n\t\t// We have a preserved ID. So the task didn't change.\n\t\tif (tTask._id !== undefined) {\n\t\t\t// Always get the task execution first to prevent timing issues when retrieving it later\n\t\t\tconst handleDto = TaskHandleDTO.from(tTask, this.workspaceService);\n\t\t\tconst executionDTO = await this._proxy.$getTaskExecution(handleDto);\n\t\t\tif (executionDTO.task === undefined) {\n\t\t\t\tthrow new Error('Task from execution DTO is undefined');\n\t\t\t}\n\t\t\tconst execution = await this.getTaskExecution(executionDTO, task);\n\t\t\tthis._proxy.$executeTask(handleDto).catch(() => { /* The error here isn't actionable. */ });\n\t\t\treturn execution;\n\t\t} else {\n\t\t\tconst dto = TaskDTO.from(task, extension);\n\t\t\tif (dto === undefined) {\n\t\t\t\treturn Promise.reject(new Error('Task is not valid'));\n\t\t\t}\n\n\t\t\t// If this task is a custom execution, then we need to save it away\n\t\t\t// in the provided custom execution map that is cleaned up after the\n\t\t\t// task is executed.\n\t\t\tif (CustomExecutionDTO.is(dto.execution)) {\n\t\t\t\tawait this.addCustomExecution(dto, task, false);\n\t\t\t}\n\t\t\t// Always get the task execution first to prevent timing issues when retrieving it later\n\t\t\tconst execution = await this.getTaskExecution(await this._proxy.$getTaskExecution(dto), task);\n\t\t\tthis._proxy.$executeTask(dto).catch(() => { /* The error here isn't actionable. */ });\n\t\t\treturn execution;\n\t\t}\n\t}\n\n\tprotected provideTasksInternal(validTypes: { [key: string]: boolean }, taskIdPromises: Promise<void>[], handler: HandlerData, value: vscode.Task[] | null | undefined): { tasks: tasks.ITaskDTO[]; extension: IExtensionDescription } {\n\t\tconst taskDTOs: tasks.ITaskDTO[] = [];\n\t\tif (value) {\n\t\t\tfor (const task of value) {\n\t\t\t\tthis.checkDeprecation(task, handler);\n\n\t\t\t\tif (!task.definition || !validTypes[task.definition.type]) {\n\t\t\t\t\tthis._logService.warn(`The task [${task.source}, ${task.name}] uses an undefined task type. The task will be ignored in the future.`);\n\t\t\t\t}\n\n\t\t\t\tconst taskDTO: tasks.ITaskDTO | undefined = TaskDTO.from(task, handler.extension);\n\t\t\t\tif (taskDTO) {\n\t\t\t\t\ttaskDTOs.push(taskDTO);\n\n\t\t\t\t\tif (CustomExecutionDTO.is(taskDTO.execution)) {\n\t\t\t\t\t\t// The ID is calculated on the main thread task side, so, let's call into it here.\n\t\t\t\t\t\t// We need the task id's pre-computed for custom task executions because when OnDidStartTask\n\t\t\t\t\t\t// is invoked, we have to be able to map it back to our data.\n\t\t\t\t\t\ttaskIdPromises.push(this.addCustomExecution(taskDTO, task, true));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttasks: taskDTOs,\n\t\t\textension: handler.extension\n\t\t};\n\t}\n\n\tprotected async resolveTaskInternal(resolvedTaskDTO: tasks.ITaskDTO): Promise<tasks.ITaskDTO | undefined> {\n\t\treturn resolvedTaskDTO;\n\t}\n\n\tprivate async getAFolder(workspaceFolders: vscode.WorkspaceFolder[] | undefined): Promise<IWorkspaceFolder> {\n\t\tlet folder = (workspaceFolders && workspaceFolders.length > 0) ? workspaceFolders[0] : undefined;\n\t\tif (!folder) {\n\t\t\tconst userhome = URI.file(homedir());\n\t\t\tfolder = new WorkspaceFolder({ uri: userhome, name: resources.basename(userhome), index: 0 });\n\t\t}\n\t\treturn {\n\t\t\turi: folder.uri,\n\t\t\tname: folder.name,\n\t\t\tindex: folder.index,\n\t\t\ttoResource: () => {\n\t\t\t\tthrow new Error('Not implemented');\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic async $resolveVariables(uriComponents: UriComponents, toResolve: { process?: { name: string; cwd?: string; path?: string }; variables: string[] }): Promise<{ process?: string; variables: { [key: string]: string } }> {\n\t\tconst uri: URI = URI.revive(uriComponents);\n\t\tconst result = {\n\t\t\tprocess: undefined as string | undefined,\n\t\t\tvariables: Object.create(null)\n\t\t};\n\t\tconst workspaceFolder = await this._workspaceProvider.resolveWorkspaceFolder(uri);\n\t\tconst workspaceFolders = (await this._workspaceProvider.getWorkspaceFolders2()) ?? [];\n\n\t\tconst resolver = await this.variableResolver.getResolver();\n\t\tconst ws: IWorkspaceFolder = workspaceFolder ? {\n\t\t\turi: workspaceFolder.uri,\n\t\t\tname: workspaceFolder.name,\n\t\t\tindex: workspaceFolder.index,\n\t\t\ttoResource: () => {\n\t\t\t\tthrow new Error('Not implemented');\n\t\t\t}\n\t\t} : await this.getAFolder(workspaceFolders);\n\n\t\tfor (const variable of toResolve.variables) {\n\t\t\tresult.variables[variable] = await resolver.resolveAsync(ws, variable);\n\t\t}\n\t\tif (toResolve.process !== undefined) {\n\t\t\tlet paths: string[] | undefined = undefined;\n\t\t\tif (toResolve.process.path !== undefined) {\n\t\t\t\tpaths = toResolve.process.path.split(path.delimiter);\n\t\t\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\t\t\tpaths[i] = await resolver.resolveAsync(ws, paths[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst processName = await resolver.resolveAsync(ws, toResolve.process.name);\n\t\t\tconst cwd = toResolve.process.cwd !== undefined ? await resolver.resolveAsync(ws, toResolve.process.cwd) : undefined;\n\t\t\tconst foundExecutable = await findExecutable(processName, cwd, paths);\n\t\t\tif (foundExecutable) {\n\t\t\t\tresult.process = foundExecutable;\n\t\t\t} else if (path.isAbsolute(processName)) {\n\t\t\t\tresult.process = processName;\n\t\t\t} else {\n\t\t\t\tresult.process = path.join(cwd ?? '', processName);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic async $jsonTasksSupported(): Promise<boolean> {\n\t\treturn true;\n\t}\n\n\tpublic async $findExecutable(command: string, cwd?: string, paths?: string[]): Promise<string | undefined> {\n\t\treturn findExecutable(command, cwd, paths);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from '../../../base/common/path.js';\n\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { findExecutable } from '../../../base/node/processes.js';\nimport * as types from '../common/extHostTypes.js';\nimport { IExtHostWorkspace } from '../common/extHostWorkspace.js';\nimport type * as vscode from 'vscode';\nimport * as tasks from '../common/shared/tasks.js';\nimport { IExtHostDocumentsAndEditors } from '../common/extHostDocumentsAndEditors.js';\nimport { IExtHostConfiguration } from '../common/extHostConfiguration.js';\nimport { IWorkspaceFolder, WorkspaceFolder } from '../../../platform/workspace/common/workspace.js';\nimport { IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { IExtHostTerminalService } from '../common/extHostTerminalService.js';\nimport { IExtHostRpcService } from '../common/extHostRpcService.js';\nimport { IExtHostInitDataService } from '../common/extHostInitDataService.js';\nimport { ExtHostTaskBase, TaskHandleDTO, TaskDTO, CustomExecutionDTO, HandlerData } from '../common/extHostTask.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { IExtHostApiDeprecationService } from '../common/extHostApiDeprecationService.js';\nimport * as resources from '../../../base/common/resources.js';\nimport { homedir } from 'os';\nimport { IExtHostVariableResolverProvider } from '../common/extHostVariableResolverService.js';\n\nexport class ExtHostTask extends ExtHostTaskBase {\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService initData: IExtHostInitDataService,\n\t\t@IExtHostWorkspace private readonly workspaceService: IExtHostWorkspace,\n\t\t@IExtHostDocumentsAndEditors editorService: IExtHostDocumentsAndEditors,\n\t\t@IExtHostConfiguration configurationService: IExtHostConfiguration,\n\t\t@IExtHostTerminalService extHostTerminalService: IExtHostTerminalService,\n\t\t@ILogService logService: ILogService,\n\t\t@IExtHostApiDeprecationService deprecationService: IExtHostApiDeprecationService,\n\t\t@IExtHostVariableResolverProvider private readonly variableResolver: IExtHostVariableResolverProvider,\n\t) {\n\t\tsuper(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService);\n\t\tif (initData.remote.isRemote && initData.remote.authority) {\n\t\t\tthis.registerTaskSystem(Schemas.vscodeRemote, {\n\t\t\t\tscheme: Schemas.vscodeRemote,\n\t\t\t\tauthority: initData.remote.authority,\n\t\t\t\tplatform: process.platform\n\t\t\t});\n\t\t} else {\n\t\t\tthis.registerTaskSystem(Schemas.file, {\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\tauthority: '',\n\t\t\t\tplatform: process.platform\n\t\t\t});\n\t\t}\n\t\tthis._proxy.$registerSupportedExecutions(true, true, true);\n\t}\n\n\tpublic async executeTask(extension: IExtensionDescription, task: vscode.Task): Promise<vscode.TaskExecution> {\n\t\tconst tTask = (task as types.Task);\n\n\t\tif (!task.execution && (tTask._id === undefined)) {\n\t\t\tthrow new Error('Tasks to execute must include an execution');\n\t\t}\n\n\t\t// We have a preserved ID. So the task didn't change.\n\t\tif (tTask._id !== undefined) {\n\t\t\t// Always get the task execution first to prevent timing issues when retrieving it later\n\t\t\tconst handleDto = TaskHandleDTO.from(tTask, this.workspaceService);\n\t\t\tconst executionDTO = await this._proxy.$getTaskExecution(handleDto);\n\t\t\tif (executionDTO.task === undefined) {\n\t\t\t\tthrow new Error('Task from execution DTO is undefined');\n\t\t\t}\n\t\t\tconst execution = await this.getTaskExecution(executionDTO, task);\n\t\t\tthis._proxy.$executeTask(handleDto).catch(() => { /* The error here isn't actionable. */ });\n\t\t\treturn execution;\n\t\t} else {\n\t\t\tconst dto = TaskDTO.from(task, extension);\n\t\t\tif (dto === undefined) {\n\t\t\t\treturn Promise.reject(new Error('Task is not valid'));\n\t\t\t}\n\n\t\t\t// If this task is a custom execution, then we need to save it away\n\t\t\t// in the provided custom execution map that is cleaned up after the\n\t\t\t// task is executed.\n\t\t\tif (CustomExecutionDTO.is(dto.execution)) {\n\t\t\t\tawait this.addCustomExecution(dto, task, false);\n\t\t\t}\n\t\t\t// Always get the task execution first to prevent timing issues when retrieving it later\n\t\t\tconst execution = await this.getTaskExecution(await this._proxy.$getTaskExecution(dto), task);\n\t\t\tthis._proxy.$executeTask(dto).catch(() => { /* The error here isn't actionable. */ });\n\t\t\treturn execution;\n\t\t}\n\t}\n\n\tprotected provideTasksInternal(validTypes: { [key: string]: boolean }, taskIdPromises: Promise<void>[], handler: HandlerData, value: vscode.Task[] | null | undefined): { tasks: tasks.ITaskDTO[]; extension: IExtensionDescription } {\n\t\tconst taskDTOs: tasks.ITaskDTO[] = [];\n\t\tif (value) {\n\t\t\tfor (const task of value) {\n\t\t\t\tthis.checkDeprecation(task, handler);\n\n\t\t\t\tif (!task.definition || !validTypes[task.definition.type]) {\n\t\t\t\t\tthis._logService.warn(`The task [${task.source}, ${task.name}] uses an undefined task type. The task will be ignored in the future.`);\n\t\t\t\t}\n\n\t\t\t\tconst taskDTO: tasks.ITaskDTO | undefined = TaskDTO.from(task, handler.extension);\n\t\t\t\tif (taskDTO) {\n\t\t\t\t\ttaskDTOs.push(taskDTO);\n\n\t\t\t\t\tif (CustomExecutionDTO.is(taskDTO.execution)) {\n\t\t\t\t\t\t// The ID is calculated on the main thread task side, so, let's call into it here.\n\t\t\t\t\t\t// We need the task id's pre-computed for custom task executions because when OnDidStartTask\n\t\t\t\t\t\t// is invoked, we have to be able to map it back to our data.\n\t\t\t\t\t\ttaskIdPromises.push(this.addCustomExecution(taskDTO, task, true));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttasks: taskDTOs,\n\t\t\textension: handler.extension\n\t\t};\n\t}\n\n\tprotected async resolveTaskInternal(resolvedTaskDTO: tasks.ITaskDTO): Promise<tasks.ITaskDTO | undefined> {\n\t\treturn resolvedTaskDTO;\n\t}\n\n\tprivate async getAFolder(workspaceFolders: vscode.WorkspaceFolder[] | undefined): Promise<IWorkspaceFolder> {\n\t\tlet folder = (workspaceFolders && workspaceFolders.length > 0) ? workspaceFolders[0] : undefined;\n\t\tif (!folder) {\n\t\t\tconst userhome = URI.file(homedir());\n\t\t\tfolder = new WorkspaceFolder({ uri: userhome, name: resources.basename(userhome), index: 0 });\n\t\t}\n\t\treturn {\n\t\t\turi: folder.uri,\n\t\t\tname: folder.name,\n\t\t\tindex: folder.index,\n\t\t\ttoResource: () => {\n\t\t\t\tthrow new Error('Not implemented');\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic async $resolveVariables(uriComponents: UriComponents, toResolve: { process?: { name: string; cwd?: string; path?: string }; variables: string[] }): Promise<{ process?: string; variables: { [key: string]: string } }> {\n\t\tconst uri: URI = URI.revive(uriComponents);\n\t\tconst result = {\n\t\t\tprocess: undefined as string | undefined,\n\t\t\tvariables: Object.create(null)\n\t\t};\n\t\tconst workspaceFolder = await this._workspaceProvider.resolveWorkspaceFolder(uri);\n\t\tconst workspaceFolders = (await this._workspaceProvider.getWorkspaceFolders2()) ?? [];\n\n\t\tconst resolver = await this.variableResolver.getResolver();\n\t\tconst ws: IWorkspaceFolder = workspaceFolder ? {\n\t\t\turi: workspaceFolder.uri,\n\t\t\tname: workspaceFolder.name,\n\t\t\tindex: workspaceFolder.index,\n\t\t\ttoResource: () => {\n\t\t\t\tthrow new Error('Not implemented');\n\t\t\t}\n\t\t} : await this.getAFolder(workspaceFolders);\n\n\t\tfor (const variable of toResolve.variables) {\n\t\t\tresult.variables[variable] = await resolver.resolveAsync(ws, variable);\n\t\t}\n\t\tif (toResolve.process !== undefined) {\n\t\t\tlet paths: string[] | undefined = undefined;\n\t\t\tif (toResolve.process.path !== undefined) {\n\t\t\t\tpaths = toResolve.process.path.split(path.delimiter);\n\t\t\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\t\t\tpaths[i] = await resolver.resolveAsync(ws, paths[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst processName = await resolver.resolveAsync(ws, toResolve.process.name);\n\t\t\tconst cwd = toResolve.process.cwd !== undefined ? await resolver.resolveAsync(ws, toResolve.process.cwd) : undefined;\n\t\t\tconst foundExecutable = await findExecutable(processName, cwd, paths);\n\t\t\tif (foundExecutable) {\n\t\t\t\tresult.process = foundExecutable;\n\t\t\t} else if (path.isAbsolute(processName)) {\n\t\t\t\tresult.process = processName;\n\t\t\t} else {\n\t\t\t\tresult.process = path.join(cwd ?? '', processName);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic async $jsonTasksSupported(): Promise<boolean> {\n\t\treturn true;\n\t}\n\n\tpublic async $findExecutable(command: string, cwd?: string, paths?: string[]): Promise<string | undefined> {\n\t\treturn findExecutable(command, cwd, paths);\n\t}\n}\n"]}