{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/node/extHostStoragePaths.ts","vs/workbench/api/node/extHostStoragePaths.ts"],"names":[],"mappings":"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","file":"extHostStoragePaths.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as path from '../../../base/common/path.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ExtensionStoragePaths as CommonExtensionStoragePaths } from '../common/extHostStoragePaths.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { IntervalTimer, timeout } from '../../../base/common/async.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { Promises } from '../../../base/node/pfs.js';\n\nexport class ExtensionStoragePaths extends CommonExtensionStoragePaths {\n\n\tprivate _workspaceStorageLock: Lock | null = null;\n\n\tprotected override async _getWorkspaceStorageURI(storageName: string): Promise<URI> {\n\t\tconst workspaceStorageURI = await super._getWorkspaceStorageURI(storageName);\n\t\tif (workspaceStorageURI.scheme !== Schemas.file) {\n\t\t\treturn workspaceStorageURI;\n\t\t}\n\n\t\tif (this._environment.skipWorkspaceStorageLock) {\n\t\t\tthis._logService.info(`Skipping acquiring lock for ${workspaceStorageURI.fsPath}.`);\n\t\t\treturn workspaceStorageURI;\n\t\t}\n\n\t\tconst workspaceStorageBase = workspaceStorageURI.fsPath;\n\t\tlet attempt = 0;\n\t\tdo {\n\t\t\tlet workspaceStoragePath: string;\n\t\t\tif (attempt === 0) {\n\t\t\t\tworkspaceStoragePath = workspaceStorageBase;\n\t\t\t} else {\n\t\t\t\tworkspaceStoragePath = (\n\t\t\t\t\t/[/\\\\]$/.test(workspaceStorageBase)\n\t\t\t\t\t\t? `${workspaceStorageBase.substr(0, workspaceStorageBase.length - 1)}-${attempt}`\n\t\t\t\t\t\t: `${workspaceStorageBase}-${attempt}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tawait mkdir(workspaceStoragePath);\n\n\t\t\tconst lockfile = path.join(workspaceStoragePath, 'vscode.lock');\n\t\t\tconst lock = await tryAcquireLock(this._logService, lockfile, false);\n\t\t\tif (lock) {\n\t\t\t\tthis._workspaceStorageLock = lock;\n\t\t\t\tprocess.on('exit', () => {\n\t\t\t\t\tlock.dispose();\n\t\t\t\t});\n\t\t\t\treturn URI.file(workspaceStoragePath);\n\t\t\t}\n\n\t\t\tattempt++;\n\t\t} while (attempt < 10);\n\n\t\t// just give up\n\t\treturn workspaceStorageURI;\n\t}\n\n\toverride onWillDeactivateAll(): void {\n\t\t// the lock will be released soon\n\t\tthis._workspaceStorageLock?.setWillRelease(6000);\n\t}\n}\n\nasync function mkdir(dir: string): Promise<void> {\n\ttry {\n\t\tawait fs.promises.stat(dir);\n\t\treturn;\n\t} catch {\n\t\t// doesn't exist, that's OK\n\t}\n\n\ttry {\n\t\tawait fs.promises.mkdir(dir, { recursive: true });\n\t} catch {\n\t}\n}\n\nconst MTIME_UPDATE_TIME = 1000; // 1s\nconst STALE_LOCK_TIME = 10 * 60 * 1000; // 10 minutes\n\nclass Lock extends Disposable {\n\n\tprivate readonly _timer: IntervalTimer;\n\n\tconstructor(\n\t\tprivate readonly logService: ILogService,\n\t\tprivate readonly filename: string\n\t) {\n\t\tsuper();\n\n\t\tthis._timer = this._register(new IntervalTimer());\n\t\tthis._timer.cancelAndSet(async () => {\n\t\t\tconst contents = await readLockfileContents(logService, filename);\n\t\t\tif (!contents || contents.pid !== process.pid) {\n\t\t\t\t// we don't hold the lock anymore ...\n\t\t\t\tlogService.info(`Lock '${filename}': The lock was lost unexpectedly.`);\n\t\t\t\tthis._timer.cancel();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait fs.promises.utimes(filename, new Date(), new Date());\n\t\t\t} catch (err) {\n\t\t\t\tlogService.error(err);\n\t\t\t\tlogService.info(`Lock '${filename}': Could not update mtime.`);\n\t\t\t}\n\t\t}, MTIME_UPDATE_TIME);\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\ttry { fs.unlinkSync(this.filename); } catch (err) { }\n\t}\n\n\tpublic async setWillRelease(timeUntilReleaseMs: number): Promise<void> {\n\t\tthis.logService.info(`Lock '${this.filename}': Marking the lockfile as scheduled to be released in ${timeUntilReleaseMs} ms.`);\n\t\ttry {\n\t\t\tconst contents: ILockfileContents = {\n\t\t\t\tpid: process.pid,\n\t\t\t\twillReleaseAt: Date.now() + timeUntilReleaseMs\n\t\t\t};\n\t\t\tawait Promises.writeFile(this.filename, JSON.stringify(contents), { flag: 'w' });\n\t\t} catch (err) {\n\t\t\tthis.logService.error(err);\n\t\t}\n\t}\n}\n\n/**\n * Attempt to acquire a lock on a directory.\n * This does not use the real `flock`, but uses a file.\n * @returns a disposable if the lock could be acquired or null if it could not.\n */\nasync function tryAcquireLock(logService: ILogService, filename: string, isSecondAttempt: boolean): Promise<Lock | null> {\n\ttry {\n\t\tconst contents: ILockfileContents = {\n\t\t\tpid: process.pid,\n\t\t\twillReleaseAt: 0\n\t\t};\n\t\tawait Promises.writeFile(filename, JSON.stringify(contents), { flag: 'wx' });\n\t} catch (err) {\n\t\tlogService.error(err);\n\t}\n\n\t// let's see if we got the lock\n\tconst contents = await readLockfileContents(logService, filename);\n\tif (!contents || contents.pid !== process.pid) {\n\t\t// we didn't get the lock\n\t\tif (isSecondAttempt) {\n\t\t\tlogService.info(`Lock '${filename}': Could not acquire lock, giving up.`);\n\t\t\treturn null;\n\t\t}\n\t\tlogService.info(`Lock '${filename}': Could not acquire lock, checking if the file is stale.`);\n\t\treturn checkStaleAndTryAcquireLock(logService, filename);\n\t}\n\n\t// we got the lock\n\tlogService.info(`Lock '${filename}': Lock acquired.`);\n\treturn new Lock(logService, filename);\n}\n\ninterface ILockfileContents {\n\tpid: number;\n\twillReleaseAt: number | undefined;\n}\n\n/**\n * @returns 0 if the pid cannot be read\n */\nasync function readLockfileContents(logService: ILogService, filename: string): Promise<ILockfileContents | null> {\n\tlet contents: Buffer;\n\ttry {\n\t\tcontents = await fs.promises.readFile(filename);\n\t} catch (err) {\n\t\t// cannot read the file\n\t\tlogService.error(err);\n\t\treturn null;\n\t}\n\n\ttry {\n\t\treturn JSON.parse(String(contents));\n\t} catch (err) {\n\t\t// cannot parse the file\n\t\tlogService.error(err);\n\t\treturn null;\n\t}\n}\n\n/**\n * @returns 0 if the mtime cannot be read\n */\nasync function readmtime(logService: ILogService, filename: string): Promise<number> {\n\tlet stats: fs.Stats;\n\ttry {\n\t\tstats = await fs.promises.stat(filename);\n\t} catch (err) {\n\t\t// cannot read the file stats to check if it is stale or not\n\t\tlogService.error(err);\n\t\treturn 0;\n\t}\n\treturn stats.mtime.getTime();\n}\n\nfunction processExists(pid: number): boolean {\n\ttry {\n\t\tprocess.kill(pid, 0); // throws an exception if the process doesn't exist anymore.\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nasync function checkStaleAndTryAcquireLock(logService: ILogService, filename: string): Promise<Lock | null> {\n\tconst contents = await readLockfileContents(logService, filename);\n\tif (!contents) {\n\t\tlogService.info(`Lock '${filename}': Could not read pid of lock holder.`);\n\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t}\n\n\tif (contents.willReleaseAt) {\n\t\tlet timeUntilRelease = contents.willReleaseAt - Date.now();\n\t\tif (timeUntilRelease < 5000) {\n\t\t\tif (timeUntilRelease > 0) {\n\t\t\t\tlogService.info(`Lock '${filename}': The lockfile is scheduled to be released in ${timeUntilRelease} ms.`);\n\t\t\t} else {\n\t\t\t\tlogService.info(`Lock '${filename}': The lockfile is scheduled to have been released.`);\n\t\t\t}\n\n\t\t\twhile (timeUntilRelease > 0) {\n\t\t\t\tawait timeout(Math.min(100, timeUntilRelease));\n\t\t\t\tconst mtime = await readmtime(logService, filename);\n\t\t\t\tif (mtime === 0) {\n\t\t\t\t\t// looks like the lock was released\n\t\t\t\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t\t\t\t}\n\t\t\t\ttimeUntilRelease = contents.willReleaseAt - Date.now();\n\t\t\t}\n\n\t\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t\t}\n\t}\n\n\tif (!processExists(contents.pid)) {\n\t\tlogService.info(`Lock '${filename}': The pid ${contents.pid} appears to be gone.`);\n\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t}\n\n\tconst mtime1 = await readmtime(logService, filename);\n\tconst elapsed1 = Date.now() - mtime1;\n\tif (elapsed1 <= STALE_LOCK_TIME) {\n\t\t// the lock does not look stale\n\t\tlogService.info(`Lock '${filename}': The lock does not look stale, elapsed: ${elapsed1} ms, giving up.`);\n\t\treturn null;\n\t}\n\n\t// the lock holder updates the mtime every 1s.\n\t// let's give it a chance to update the mtime\n\t// in case of a wake from sleep or something similar\n\tlogService.info(`Lock '${filename}': The lock looks stale, waiting for 2s.`);\n\tawait timeout(2000);\n\n\tconst mtime2 = await readmtime(logService, filename);\n\tconst elapsed2 = Date.now() - mtime2;\n\tif (elapsed2 <= STALE_LOCK_TIME) {\n\t\t// the lock does not look stale\n\t\tlogService.info(`Lock '${filename}': The lock does not look stale, elapsed: ${elapsed2} ms, giving up.`);\n\t\treturn null;\n\t}\n\n\t// the lock looks stale\n\tlogService.info(`Lock '${filename}': The lock looks stale even after waiting for 2s.`);\n\treturn tryDeleteAndAcquireLock(logService, filename);\n}\n\nasync function tryDeleteAndAcquireLock(logService: ILogService, filename: string): Promise<Lock | null> {\n\tlogService.info(`Lock '${filename}': Deleting a stale lock.`);\n\ttry {\n\t\tawait fs.promises.unlink(filename);\n\t} catch (err) {\n\t\t// cannot delete the file\n\t\t// maybe the file is already deleted\n\t}\n\treturn tryAcquireLock(logService, filename, true);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as path from '../../../base/common/path.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ExtensionStoragePaths as CommonExtensionStoragePaths } from '../common/extHostStoragePaths.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { IntervalTimer, timeout } from '../../../base/common/async.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { Promises } from '../../../base/node/pfs.js';\n\nexport class ExtensionStoragePaths extends CommonExtensionStoragePaths {\n\n\tprivate _workspaceStorageLock: Lock | null = null;\n\n\tprotected override async _getWorkspaceStorageURI(storageName: string): Promise<URI> {\n\t\tconst workspaceStorageURI = await super._getWorkspaceStorageURI(storageName);\n\t\tif (workspaceStorageURI.scheme !== Schemas.file) {\n\t\t\treturn workspaceStorageURI;\n\t\t}\n\n\t\tif (this._environment.skipWorkspaceStorageLock) {\n\t\t\tthis._logService.info(`Skipping acquiring lock for ${workspaceStorageURI.fsPath}.`);\n\t\t\treturn workspaceStorageURI;\n\t\t}\n\n\t\tconst workspaceStorageBase = workspaceStorageURI.fsPath;\n\t\tlet attempt = 0;\n\t\tdo {\n\t\t\tlet workspaceStoragePath: string;\n\t\t\tif (attempt === 0) {\n\t\t\t\tworkspaceStoragePath = workspaceStorageBase;\n\t\t\t} else {\n\t\t\t\tworkspaceStoragePath = (\n\t\t\t\t\t/[/\\\\]$/.test(workspaceStorageBase)\n\t\t\t\t\t\t? `${workspaceStorageBase.substr(0, workspaceStorageBase.length - 1)}-${attempt}`\n\t\t\t\t\t\t: `${workspaceStorageBase}-${attempt}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tawait mkdir(workspaceStoragePath);\n\n\t\t\tconst lockfile = path.join(workspaceStoragePath, 'vscode.lock');\n\t\t\tconst lock = await tryAcquireLock(this._logService, lockfile, false);\n\t\t\tif (lock) {\n\t\t\t\tthis._workspaceStorageLock = lock;\n\t\t\t\tprocess.on('exit', () => {\n\t\t\t\t\tlock.dispose();\n\t\t\t\t});\n\t\t\t\treturn URI.file(workspaceStoragePath);\n\t\t\t}\n\n\t\t\tattempt++;\n\t\t} while (attempt < 10);\n\n\t\t// just give up\n\t\treturn workspaceStorageURI;\n\t}\n\n\toverride onWillDeactivateAll(): void {\n\t\t// the lock will be released soon\n\t\tthis._workspaceStorageLock?.setWillRelease(6000);\n\t}\n}\n\nasync function mkdir(dir: string): Promise<void> {\n\ttry {\n\t\tawait fs.promises.stat(dir);\n\t\treturn;\n\t} catch {\n\t\t// doesn't exist, that's OK\n\t}\n\n\ttry {\n\t\tawait fs.promises.mkdir(dir, { recursive: true });\n\t} catch {\n\t}\n}\n\nconst MTIME_UPDATE_TIME = 1000; // 1s\nconst STALE_LOCK_TIME = 10 * 60 * 1000; // 10 minutes\n\nclass Lock extends Disposable {\n\n\tprivate readonly _timer: IntervalTimer;\n\n\tconstructor(\n\t\tprivate readonly logService: ILogService,\n\t\tprivate readonly filename: string\n\t) {\n\t\tsuper();\n\n\t\tthis._timer = this._register(new IntervalTimer());\n\t\tthis._timer.cancelAndSet(async () => {\n\t\t\tconst contents = await readLockfileContents(logService, filename);\n\t\t\tif (!contents || contents.pid !== process.pid) {\n\t\t\t\t// we don't hold the lock anymore ...\n\t\t\t\tlogService.info(`Lock '${filename}': The lock was lost unexpectedly.`);\n\t\t\t\tthis._timer.cancel();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait fs.promises.utimes(filename, new Date(), new Date());\n\t\t\t} catch (err) {\n\t\t\t\tlogService.error(err);\n\t\t\t\tlogService.info(`Lock '${filename}': Could not update mtime.`);\n\t\t\t}\n\t\t}, MTIME_UPDATE_TIME);\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\ttry { fs.unlinkSync(this.filename); } catch (err) { }\n\t}\n\n\tpublic async setWillRelease(timeUntilReleaseMs: number): Promise<void> {\n\t\tthis.logService.info(`Lock '${this.filename}': Marking the lockfile as scheduled to be released in ${timeUntilReleaseMs} ms.`);\n\t\ttry {\n\t\t\tconst contents: ILockfileContents = {\n\t\t\t\tpid: process.pid,\n\t\t\t\twillReleaseAt: Date.now() + timeUntilReleaseMs\n\t\t\t};\n\t\t\tawait Promises.writeFile(this.filename, JSON.stringify(contents), { flag: 'w' });\n\t\t} catch (err) {\n\t\t\tthis.logService.error(err);\n\t\t}\n\t}\n}\n\n/**\n * Attempt to acquire a lock on a directory.\n * This does not use the real `flock`, but uses a file.\n * @returns a disposable if the lock could be acquired or null if it could not.\n */\nasync function tryAcquireLock(logService: ILogService, filename: string, isSecondAttempt: boolean): Promise<Lock | null> {\n\ttry {\n\t\tconst contents: ILockfileContents = {\n\t\t\tpid: process.pid,\n\t\t\twillReleaseAt: 0\n\t\t};\n\t\tawait Promises.writeFile(filename, JSON.stringify(contents), { flag: 'wx' });\n\t} catch (err) {\n\t\tlogService.error(err);\n\t}\n\n\t// let's see if we got the lock\n\tconst contents = await readLockfileContents(logService, filename);\n\tif (!contents || contents.pid !== process.pid) {\n\t\t// we didn't get the lock\n\t\tif (isSecondAttempt) {\n\t\t\tlogService.info(`Lock '${filename}': Could not acquire lock, giving up.`);\n\t\t\treturn null;\n\t\t}\n\t\tlogService.info(`Lock '${filename}': Could not acquire lock, checking if the file is stale.`);\n\t\treturn checkStaleAndTryAcquireLock(logService, filename);\n\t}\n\n\t// we got the lock\n\tlogService.info(`Lock '${filename}': Lock acquired.`);\n\treturn new Lock(logService, filename);\n}\n\ninterface ILockfileContents {\n\tpid: number;\n\twillReleaseAt: number | undefined;\n}\n\n/**\n * @returns 0 if the pid cannot be read\n */\nasync function readLockfileContents(logService: ILogService, filename: string): Promise<ILockfileContents | null> {\n\tlet contents: Buffer;\n\ttry {\n\t\tcontents = await fs.promises.readFile(filename);\n\t} catch (err) {\n\t\t// cannot read the file\n\t\tlogService.error(err);\n\t\treturn null;\n\t}\n\n\ttry {\n\t\treturn JSON.parse(String(contents));\n\t} catch (err) {\n\t\t// cannot parse the file\n\t\tlogService.error(err);\n\t\treturn null;\n\t}\n}\n\n/**\n * @returns 0 if the mtime cannot be read\n */\nasync function readmtime(logService: ILogService, filename: string): Promise<number> {\n\tlet stats: fs.Stats;\n\ttry {\n\t\tstats = await fs.promises.stat(filename);\n\t} catch (err) {\n\t\t// cannot read the file stats to check if it is stale or not\n\t\tlogService.error(err);\n\t\treturn 0;\n\t}\n\treturn stats.mtime.getTime();\n}\n\nfunction processExists(pid: number): boolean {\n\ttry {\n\t\tprocess.kill(pid, 0); // throws an exception if the process doesn't exist anymore.\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nasync function checkStaleAndTryAcquireLock(logService: ILogService, filename: string): Promise<Lock | null> {\n\tconst contents = await readLockfileContents(logService, filename);\n\tif (!contents) {\n\t\tlogService.info(`Lock '${filename}': Could not read pid of lock holder.`);\n\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t}\n\n\tif (contents.willReleaseAt) {\n\t\tlet timeUntilRelease = contents.willReleaseAt - Date.now();\n\t\tif (timeUntilRelease < 5000) {\n\t\t\tif (timeUntilRelease > 0) {\n\t\t\t\tlogService.info(`Lock '${filename}': The lockfile is scheduled to be released in ${timeUntilRelease} ms.`);\n\t\t\t} else {\n\t\t\t\tlogService.info(`Lock '${filename}': The lockfile is scheduled to have been released.`);\n\t\t\t}\n\n\t\t\twhile (timeUntilRelease > 0) {\n\t\t\t\tawait timeout(Math.min(100, timeUntilRelease));\n\t\t\t\tconst mtime = await readmtime(logService, filename);\n\t\t\t\tif (mtime === 0) {\n\t\t\t\t\t// looks like the lock was released\n\t\t\t\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t\t\t\t}\n\t\t\t\ttimeUntilRelease = contents.willReleaseAt - Date.now();\n\t\t\t}\n\n\t\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t\t}\n\t}\n\n\tif (!processExists(contents.pid)) {\n\t\tlogService.info(`Lock '${filename}': The pid ${contents.pid} appears to be gone.`);\n\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t}\n\n\tconst mtime1 = await readmtime(logService, filename);\n\tconst elapsed1 = Date.now() - mtime1;\n\tif (elapsed1 <= STALE_LOCK_TIME) {\n\t\t// the lock does not look stale\n\t\tlogService.info(`Lock '${filename}': The lock does not look stale, elapsed: ${elapsed1} ms, giving up.`);\n\t\treturn null;\n\t}\n\n\t// the lock holder updates the mtime every 1s.\n\t// let's give it a chance to update the mtime\n\t// in case of a wake from sleep or something similar\n\tlogService.info(`Lock '${filename}': The lock looks stale, waiting for 2s.`);\n\tawait timeout(2000);\n\n\tconst mtime2 = await readmtime(logService, filename);\n\tconst elapsed2 = Date.now() - mtime2;\n\tif (elapsed2 <= STALE_LOCK_TIME) {\n\t\t// the lock does not look stale\n\t\tlogService.info(`Lock '${filename}': The lock does not look stale, elapsed: ${elapsed2} ms, giving up.`);\n\t\treturn null;\n\t}\n\n\t// the lock looks stale\n\tlogService.info(`Lock '${filename}': The lock looks stale even after waiting for 2s.`);\n\treturn tryDeleteAndAcquireLock(logService, filename);\n}\n\nasync function tryDeleteAndAcquireLock(logService: ILogService, filename: string): Promise<Lock | null> {\n\tlogService.info(`Lock '${filename}': Deleting a stale lock.`);\n\ttry {\n\t\tawait fs.promises.unlink(filename);\n\t} catch (err) {\n\t\t// cannot delete the file\n\t\t// maybe the file is already deleted\n\t}\n\treturn tryAcquireLock(logService, filename, true);\n}\n"]}