{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/node/extHostTunnelService.ts","vs/workbench/api/node/extHostTunnelService.ts"],"names":[],"mappings":"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","file":"extHostTunnelService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { exec } from 'child_process';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { MovingAverage } from '../../../base/common/numbers.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport * as resources from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport * as pfs from '../../../base/node/pfs.js';\nimport { ISocket, SocketCloseEventType } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { ManagedSocket, RemoteSocketHalf, connectManagedSocket } from '../../../platform/remote/common/managedSocket.js';\nimport { ManagedRemoteConnection } from '../../../platform/remote/common/remoteAuthorityResolver.js';\nimport { ISignService } from '../../../platform/sign/common/sign.js';\nimport { isAllInterfaces, isLocalhost } from '../../../platform/tunnel/common/tunnel.js';\nimport { NodeRemoteTunnel } from '../../../platform/tunnel/node/tunnelService.js';\nimport { IExtHostInitDataService } from '../common/extHostInitDataService.js';\nimport { IExtHostRpcService } from '../common/extHostRpcService.js';\nimport { ExtHostTunnelService } from '../common/extHostTunnelService.js';\nimport { CandidatePort, parseAddress } from '../../services/remote/common/tunnelModel.js';\nimport * as vscode from 'vscode';\nimport { IExtHostConfiguration } from '../common/extHostConfiguration.js';\n\nexport function getSockets(stdout: string): Record<string, { pid: number; socket: number }> {\n\tconst lines = stdout.trim().split('\\n');\n\tconst mapped: { pid: number; socket: number }[] = [];\n\tlines.forEach(line => {\n\t\tconst match = /\\/proc\\/(\\d+)\\/fd\\/\\d+ -> socket:\\[(\\d+)\\]/.exec(line)!;\n\t\tif (match && match.length >= 3) {\n\t\t\tmapped.push({\n\t\t\t\tpid: parseInt(match[1], 10),\n\t\t\t\tsocket: parseInt(match[2], 10)\n\t\t\t});\n\t\t}\n\t});\n\tconst socketMap = mapped.reduce((m: Record<string, typeof mapped[0]>, socket) => {\n\t\tm[socket.socket] = socket;\n\t\treturn m;\n\t}, {});\n\treturn socketMap;\n}\n\nexport function loadListeningPorts(...stdouts: string[]): { socket: number; ip: string; port: number }[] {\n\tconst table = ([] as Record<string, string>[]).concat(...stdouts.map(loadConnectionTable));\n\treturn [\n\t\t...new Map(\n\t\t\ttable.filter(row => row.st === '0A')\n\t\t\t\t.map(row => {\n\t\t\t\t\tconst address = row.local_address.split(':');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsocket: parseInt(row.inode, 10),\n\t\t\t\t\t\tip: parseIpAddress(address[0]),\n\t\t\t\t\t\tport: parseInt(address[1], 16)\n\t\t\t\t\t};\n\t\t\t\t}).map(port => [port.ip + ':' + port.port, port])\n\t\t).values()\n\t];\n}\n\nexport function parseIpAddress(hex: string): string {\n\tlet result = '';\n\tif (hex.length === 8) {\n\t\tfor (let i = hex.length - 2; i >= 0; i -= 2) {\n\t\t\tresult += parseInt(hex.substr(i, 2), 16);\n\t\t\tif (i !== 0) {\n\t\t\t\tresult += '.';\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Nice explanation of host format in tcp6 file: https://serverfault.com/questions/592574/why-does-proc-net-tcp6-represents-1-as-1000\n\t\tfor (let i = 0; i < hex.length; i += 8) {\n\t\t\tconst word = hex.substring(i, i + 8);\n\t\t\tlet subWord = '';\n\t\t\tfor (let j = 8; j >= 2; j -= 2) {\n\t\t\t\tsubWord += word.substring(j - 2, j);\n\t\t\t\tif ((j === 6) || (j === 2)) {\n\t\t\t\t\t// Trim leading zeros\n\t\t\t\t\tsubWord = parseInt(subWord, 16).toString(16);\n\t\t\t\t\tresult += `${subWord}`;\n\t\t\t\t\tsubWord = '';\n\t\t\t\t\tif (i + j !== hex.length - 6) {\n\t\t\t\t\t\tresult += ':';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function loadConnectionTable(stdout: string): Record<string, string>[] {\n\tconst lines = stdout.trim().split('\\n');\n\tconst names = lines.shift()!.trim().split(/\\s+/)\n\t\t.filter(name => name !== 'rx_queue' && name !== 'tm->when');\n\tconst table = lines.map(line => line.trim().split(/\\s+/).reduce((obj: Record<string, string>, value, i) => {\n\t\tobj[names[i] || i] = value;\n\t\treturn obj;\n\t}, {}));\n\treturn table;\n}\n\nfunction knownExcludeCmdline(command: string): boolean {\n\tif (command.length > 500) {\n\t\treturn false;\n\t}\n\treturn !!command.match(/.*\\.vscode-server-[a-zA-Z]+\\/bin.*/)\n\t\t|| (command.indexOf('out/server-main.js') !== -1)\n\t\t|| (command.indexOf('_productName=VSCode') !== -1);\n}\n\nexport function getRootProcesses(stdout: string) {\n\tconst lines = stdout.trim().split('\\n');\n\tconst mapped: { pid: number; cmd: string; ppid: number }[] = [];\n\tlines.forEach(line => {\n\t\tconst match = /^\\d+\\s+\\D+\\s+root\\s+(\\d+)\\s+(\\d+).+\\d+\\:\\d+\\:\\d+\\s+(.+)$/.exec(line)!;\n\t\tif (match && match.length >= 4) {\n\t\t\tmapped.push({\n\t\t\t\tpid: parseInt(match[1], 10),\n\t\t\t\tppid: parseInt(match[2]),\n\t\t\t\tcmd: match[3]\n\t\t\t});\n\t\t}\n\t});\n\treturn mapped;\n}\n\nexport async function findPorts(connections: { socket: number; ip: string; port: number }[], socketMap: Record<string, { pid: number; socket: number }>, processes: { pid: number; cwd: string; cmd: string }[]): Promise<CandidatePort[]> {\n\tconst processMap = processes.reduce((m: Record<string, typeof processes[0]>, process) => {\n\t\tm[process.pid] = process;\n\t\treturn m;\n\t}, {});\n\n\tconst ports: CandidatePort[] = [];\n\tconnections.forEach(({ socket, ip, port }) => {\n\t\tconst pid = socketMap[socket] ? socketMap[socket].pid : undefined;\n\t\tconst command: string | undefined = pid ? processMap[pid]?.cmd : undefined;\n\t\tif (pid && command && !knownExcludeCmdline(command)) {\n\t\t\tports.push({ host: ip, port, detail: command, pid });\n\t\t}\n\t});\n\treturn ports;\n}\n\nexport function tryFindRootPorts(connections: { socket: number; ip: string; port: number }[], rootProcessesStdout: string, previousPorts: Map<number, CandidatePort & { ppid: number }>): Map<number, CandidatePort & { ppid: number }> {\n\tconst ports: Map<number, CandidatePort & { ppid: number }> = new Map();\n\tconst rootProcesses = getRootProcesses(rootProcessesStdout);\n\n\tfor (const connection of connections) {\n\t\tconst previousPort = previousPorts.get(connection.port);\n\t\tif (previousPort) {\n\t\t\tports.set(connection.port, previousPort);\n\t\t\tcontinue;\n\t\t}\n\t\tconst rootProcessMatch = rootProcesses.find((value) => value.cmd.includes(`${connection.port}`));\n\t\tif (rootProcessMatch) {\n\t\t\tlet bestMatch = rootProcessMatch;\n\t\t\t// There are often several processes that \"look\" like they could match the port.\n\t\t\t// The one we want is usually the child of the other. Find the most child process.\n\t\t\tlet mostChild: { pid: number; cmd: string; ppid: number } | undefined;\n\t\t\tdo {\n\t\t\t\tmostChild = rootProcesses.find(value => value.ppid === bestMatch.pid);\n\t\t\t\tif (mostChild) {\n\t\t\t\t\tbestMatch = mostChild;\n\t\t\t\t}\n\t\t\t} while (mostChild);\n\t\t\tports.set(connection.port, { host: connection.ip, port: connection.port, pid: bestMatch.pid, detail: bestMatch.cmd, ppid: bestMatch.ppid });\n\t\t} else {\n\t\t\tports.set(connection.port, { host: connection.ip, port: connection.port, ppid: Number.MAX_VALUE });\n\t\t}\n\t}\n\n\treturn ports;\n}\n\nexport class NodeExtHostTunnelService extends ExtHostTunnelService {\n\tprivate _initialCandidates: CandidatePort[] | undefined = undefined;\n\tprivate _foundRootPorts: Map<number, CandidatePort & { ppid: number }> = new Map();\n\tprivate _candidateFindingEnabled: boolean = false;\n\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService private readonly initData: IExtHostInitDataService,\n\t\t@ILogService logService: ILogService,\n\t\t@ISignService private readonly signService: ISignService,\n\t\t@IExtHostConfiguration private readonly configurationService: IExtHostConfiguration,\n\t) {\n\t\tsuper(extHostRpc, initData, logService);\n\t\tif (isLinux && initData.remote.isRemote && initData.remote.authority) {\n\t\t\tthis._proxy.$setRemoteTunnelService(process.pid);\n\t\t\tthis.setInitialCandidates();\n\t\t}\n\t}\n\n\toverride async $registerCandidateFinder(enable: boolean): Promise<void> {\n\t\tif (enable && this._candidateFindingEnabled) {\n\t\t\t// already enabled\n\t\t\treturn;\n\t\t}\n\n\t\tthis._candidateFindingEnabled = enable;\n\t\tlet oldPorts: { host: string; port: number; detail?: string }[] | undefined = undefined;\n\n\t\t// If we already have found initial candidates send those immediately.\n\t\tif (this._initialCandidates) {\n\t\t\toldPorts = this._initialCandidates;\n\t\t\tawait this._proxy.$onFoundNewCandidates(this._initialCandidates);\n\t\t}\n\n\t\t// Regularly scan to see if the candidate ports have changed.\n\t\tconst movingAverage = new MovingAverage();\n\t\tlet scanCount = 0;\n\t\twhile (this._candidateFindingEnabled) {\n\t\t\tconst startTime = new Date().getTime();\n\t\t\tconst newPorts = (await this.findCandidatePorts()).filter(candidate => (isLocalhost(candidate.host) || isAllInterfaces(candidate.host)));\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) found candidate ports ${newPorts.map(port => port.port).join(', ')}`);\n\t\t\tconst timeTaken = new Date().getTime() - startTime;\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) candidate port scan took ${timeTaken} ms.`);\n\t\t\t// Do not count the first few scans towards the moving average as they are likely to be slower.\n\t\t\tif (scanCount++ > 3) {\n\t\t\t\tmovingAverage.update(timeTaken);\n\t\t\t}\n\t\t\tif (!oldPorts || (JSON.stringify(oldPorts) !== JSON.stringify(newPorts))) {\n\t\t\t\toldPorts = newPorts;\n\t\t\t\tawait this._proxy.$onFoundNewCandidates(oldPorts);\n\t\t\t}\n\t\t\tconst delay = this.calculateDelay(movingAverage.value);\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) next candidate port scan in ${delay} ms.`);\n\t\t\tawait (new Promise<void>(resolve => setTimeout(() => resolve(), delay)));\n\t\t}\n\t}\n\n\tprivate calculateDelay(movingAverage: number) {\n\t\t// Some local testing indicated that the moving average might be between 50-100 ms.\n\t\treturn Math.max(movingAverage * 20, 2000);\n\t}\n\n\tprivate async setInitialCandidates(): Promise<void> {\n\t\tthis._initialCandidates = await this.findCandidatePorts();\n\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) Initial candidates found: ${this._initialCandidates.map(c => c.port).join(', ')}`);\n\t}\n\n\tprivate async findCandidatePorts(): Promise<CandidatePort[]> {\n\t\tlet tcp: string = '';\n\t\tlet tcp6: string = '';\n\t\ttry {\n\t\t\ttcp = await fs.promises.readFile('/proc/net/tcp', 'utf8');\n\t\t\ttcp6 = await fs.promises.readFile('/proc/net/tcp6', 'utf8');\n\t\t} catch (e) {\n\t\t\t// File reading error. No additional handling needed.\n\t\t}\n\t\tconst connections: { socket: number; ip: string; port: number }[] = loadListeningPorts(tcp, tcp6);\n\n\t\tconst procSockets: string = await (new Promise(resolve => {\n\t\t\texec('ls -l /proc/[0-9]*/fd/[0-9]* | grep socket:', (error, stdout, stderr) => {\n\t\t\t\tresolve(stdout);\n\t\t\t});\n\t\t}));\n\t\tconst socketMap = getSockets(procSockets);\n\n\t\tconst procChildren = await pfs.Promises.readdir('/proc');\n\t\tconst processes: {\n\t\t\tpid: number; cwd: string; cmd: string;\n\t\t}[] = [];\n\t\tfor (const childName of procChildren) {\n\t\t\ttry {\n\t\t\t\tconst pid: number = Number(childName);\n\t\t\t\tconst childUri = resources.joinPath(URI.file('/proc'), childName);\n\t\t\t\tconst childStat = await fs.promises.stat(childUri.fsPath);\n\t\t\t\tif (childStat.isDirectory() && !isNaN(pid)) {\n\t\t\t\t\tconst cwd = await fs.promises.readlink(resources.joinPath(childUri, 'cwd').fsPath);\n\t\t\t\t\tconst cmd = await fs.promises.readFile(resources.joinPath(childUri, 'cmdline').fsPath, 'utf8');\n\t\t\t\t\tprocesses.push({ pid, cwd, cmd });\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t//\n\t\t\t}\n\t\t}\n\n\t\tconst unFoundConnections: { socket: number; ip: string; port: number }[] = [];\n\t\tconst filteredConnections = connections.filter((connection => {\n\t\t\tconst foundConnection = socketMap[connection.socket];\n\t\t\tif (!foundConnection) {\n\t\t\t\tunFoundConnections.push(connection);\n\t\t\t}\n\t\t\treturn foundConnection;\n\t\t}));\n\n\t\tconst foundPorts = findPorts(filteredConnections, socketMap, processes);\n\t\tlet heuristicPorts: CandidatePort[] | undefined;\n\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) number of possible root ports ${unFoundConnections.length}`);\n\t\tif (unFoundConnections.length > 0) {\n\t\t\tconst rootProcesses: string = await (new Promise(resolve => {\n\t\t\t\texec('ps -F -A -l | grep root', (error, stdout, stderr) => {\n\t\t\t\t\tresolve(stdout);\n\t\t\t\t});\n\t\t\t}));\n\t\t\tthis._foundRootPorts = tryFindRootPorts(unFoundConnections, rootProcesses, this._foundRootPorts);\n\t\t\theuristicPorts = Array.from(this._foundRootPorts.values());\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) heuristic ports ${heuristicPorts.map(heuristicPort => heuristicPort.port).join(', ')}`);\n\n\t\t}\n\t\treturn foundPorts.then(foundCandidates => {\n\t\t\tif (heuristicPorts) {\n\t\t\t\treturn foundCandidates.concat(heuristicPorts);\n\t\t\t} else {\n\t\t\t\treturn foundCandidates;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async defaultTunnelHost(): Promise<string> {\n\t\tconst settingValue = (await this.configurationService.getConfigProvider()).getConfiguration('remote').get('localPortHost');\n\t\treturn (!settingValue || settingValue === 'localhost') ? '127.0.0.1' : '0.0.0.0';\n\t}\n\n\tprotected override makeManagedTunnelFactory(authority: vscode.ManagedResolvedAuthority): vscode.RemoteAuthorityResolver['tunnelFactory'] {\n\t\treturn async (tunnelOptions) => {\n\t\t\tconst t = new NodeRemoteTunnel(\n\t\t\t\t{\n\t\t\t\t\tcommit: this.initData.commit,\n\t\t\t\t\tquality: this.initData.quality,\n\t\t\t\t\tlogService: this.logService,\n\t\t\t\t\tipcLogger: null,\n\t\t\t\t\t// services and address providers have stubs since we don't need\n\t\t\t\t\t// the connection identification that the renderer process uses\n\t\t\t\t\tremoteSocketFactoryService: {\n\t\t\t\t\t\t_serviceBrand: undefined,\n\t\t\t\t\t\tasync connect(_connectTo: ManagedRemoteConnection, path: string, query: string, debugLabel: string): Promise<ISocket> {\n\t\t\t\t\t\t\tconst result = await authority.makeConnection();\n\t\t\t\t\t\t\treturn ExtHostManagedSocket.connect(result, path, query, debugLabel);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tregister() {\n\t\t\t\t\t\t\tthrow new Error('not implemented');\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\taddressProvider: {\n\t\t\t\t\t\tgetAddress() {\n\t\t\t\t\t\t\treturn Promise.resolve({\n\t\t\t\t\t\t\t\tconnectTo: new ManagedRemoteConnection(0),\n\t\t\t\t\t\t\t\tconnectionToken: authority.connectionToken,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tsignService: this.signService,\n\t\t\t\t},\n\t\t\t\tawait this.defaultTunnelHost(),\n\t\t\t\ttunnelOptions.remoteAddress.host || 'localhost',\n\t\t\t\ttunnelOptions.remoteAddress.port,\n\t\t\t\ttunnelOptions.localAddressPort,\n\t\t\t);\n\n\t\t\tawait t.waitForReady();\n\n\t\t\tconst disposeEmitter = new Emitter<void>();\n\n\t\t\treturn {\n\t\t\t\tlocalAddress: parseAddress(t.localAddress) ?? t.localAddress,\n\t\t\t\tremoteAddress: { port: t.tunnelRemotePort, host: t.tunnelRemoteHost },\n\t\t\t\tonDidDispose: disposeEmitter.event,\n\t\t\t\tdispose: () => {\n\t\t\t\t\tt.dispose();\n\t\t\t\t\tdisposeEmitter.fire();\n\t\t\t\t\tdisposeEmitter.dispose();\n\t\t\t\t},\n\t\t\t};\n\t\t};\n\t}\n}\n\nclass ExtHostManagedSocket extends ManagedSocket {\n\tpublic static connect(\n\t\tpassing: vscode.ManagedMessagePassing,\n\t\tpath: string, query: string, debugLabel: string,\n\t): Promise<ExtHostManagedSocket> {\n\t\tconst d = new DisposableStore();\n\t\tconst half: RemoteSocketHalf = {\n\t\t\tonClose: d.add(new Emitter()),\n\t\t\tonData: d.add(new Emitter()),\n\t\t\tonEnd: d.add(new Emitter()),\n\t\t};\n\n\t\td.add(passing.onDidReceiveMessage(d => half.onData.fire(VSBuffer.wrap(d))));\n\t\td.add(passing.onDidEnd(() => half.onEnd.fire()));\n\t\td.add(passing.onDidClose(error => half.onClose.fire({\n\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\terror,\n\t\t\thadError: !!error\n\t\t})));\n\n\t\tconst socket = new ExtHostManagedSocket(passing, debugLabel, half);\n\t\tsocket._register(d);\n\t\treturn connectManagedSocket(socket, path, query, debugLabel, half);\n\t}\n\n\tconstructor(\n\t\tprivate readonly passing: vscode.ManagedMessagePassing,\n\t\tdebugLabel: string,\n\t\thalf: RemoteSocketHalf,\n\t) {\n\t\tsuper(debugLabel, half);\n\t}\n\n\tpublic override write(buffer: VSBuffer): void {\n\t\tthis.passing.send(buffer.buffer);\n\t}\n\tprotected override closeRemote(): void {\n\t\tthis.passing.end();\n\t}\n\n\tpublic override async drain(): Promise<void> {\n\t\tawait this.passing.drain?.();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { exec } from 'child_process';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { MovingAverage } from '../../../base/common/numbers.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport * as resources from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport * as pfs from '../../../base/node/pfs.js';\nimport { ISocket, SocketCloseEventType } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { ManagedSocket, RemoteSocketHalf, connectManagedSocket } from '../../../platform/remote/common/managedSocket.js';\nimport { ManagedRemoteConnection } from '../../../platform/remote/common/remoteAuthorityResolver.js';\nimport { ISignService } from '../../../platform/sign/common/sign.js';\nimport { isAllInterfaces, isLocalhost } from '../../../platform/tunnel/common/tunnel.js';\nimport { NodeRemoteTunnel } from '../../../platform/tunnel/node/tunnelService.js';\nimport { IExtHostInitDataService } from '../common/extHostInitDataService.js';\nimport { IExtHostRpcService } from '../common/extHostRpcService.js';\nimport { ExtHostTunnelService } from '../common/extHostTunnelService.js';\nimport { CandidatePort, parseAddress } from '../../services/remote/common/tunnelModel.js';\nimport * as vscode from 'vscode';\nimport { IExtHostConfiguration } from '../common/extHostConfiguration.js';\n\nexport function getSockets(stdout: string): Record<string, { pid: number; socket: number }> {\n\tconst lines = stdout.trim().split('\\n');\n\tconst mapped: { pid: number; socket: number }[] = [];\n\tlines.forEach(line => {\n\t\tconst match = /\\/proc\\/(\\d+)\\/fd\\/\\d+ -> socket:\\[(\\d+)\\]/.exec(line)!;\n\t\tif (match && match.length >= 3) {\n\t\t\tmapped.push({\n\t\t\t\tpid: parseInt(match[1], 10),\n\t\t\t\tsocket: parseInt(match[2], 10)\n\t\t\t});\n\t\t}\n\t});\n\tconst socketMap = mapped.reduce((m: Record<string, typeof mapped[0]>, socket) => {\n\t\tm[socket.socket] = socket;\n\t\treturn m;\n\t}, {});\n\treturn socketMap;\n}\n\nexport function loadListeningPorts(...stdouts: string[]): { socket: number; ip: string; port: number }[] {\n\tconst table = ([] as Record<string, string>[]).concat(...stdouts.map(loadConnectionTable));\n\treturn [\n\t\t...new Map(\n\t\t\ttable.filter(row => row.st === '0A')\n\t\t\t\t.map(row => {\n\t\t\t\t\tconst address = row.local_address.split(':');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsocket: parseInt(row.inode, 10),\n\t\t\t\t\t\tip: parseIpAddress(address[0]),\n\t\t\t\t\t\tport: parseInt(address[1], 16)\n\t\t\t\t\t};\n\t\t\t\t}).map(port => [port.ip + ':' + port.port, port])\n\t\t).values()\n\t];\n}\n\nexport function parseIpAddress(hex: string): string {\n\tlet result = '';\n\tif (hex.length === 8) {\n\t\tfor (let i = hex.length - 2; i >= 0; i -= 2) {\n\t\t\tresult += parseInt(hex.substr(i, 2), 16);\n\t\t\tif (i !== 0) {\n\t\t\t\tresult += '.';\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Nice explanation of host format in tcp6 file: https://serverfault.com/questions/592574/why-does-proc-net-tcp6-represents-1-as-1000\n\t\tfor (let i = 0; i < hex.length; i += 8) {\n\t\t\tconst word = hex.substring(i, i + 8);\n\t\t\tlet subWord = '';\n\t\t\tfor (let j = 8; j >= 2; j -= 2) {\n\t\t\t\tsubWord += word.substring(j - 2, j);\n\t\t\t\tif ((j === 6) || (j === 2)) {\n\t\t\t\t\t// Trim leading zeros\n\t\t\t\t\tsubWord = parseInt(subWord, 16).toString(16);\n\t\t\t\t\tresult += `${subWord}`;\n\t\t\t\t\tsubWord = '';\n\t\t\t\t\tif (i + j !== hex.length - 6) {\n\t\t\t\t\t\tresult += ':';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function loadConnectionTable(stdout: string): Record<string, string>[] {\n\tconst lines = stdout.trim().split('\\n');\n\tconst names = lines.shift()!.trim().split(/\\s+/)\n\t\t.filter(name => name !== 'rx_queue' && name !== 'tm->when');\n\tconst table = lines.map(line => line.trim().split(/\\s+/).reduce((obj: Record<string, string>, value, i) => {\n\t\tobj[names[i] || i] = value;\n\t\treturn obj;\n\t}, {}));\n\treturn table;\n}\n\nfunction knownExcludeCmdline(command: string): boolean {\n\tif (command.length > 500) {\n\t\treturn false;\n\t}\n\treturn !!command.match(/.*\\.vscode-server-[a-zA-Z]+\\/bin.*/)\n\t\t|| (command.indexOf('out/server-main.js') !== -1)\n\t\t|| (command.indexOf('_productName=VSCode') !== -1);\n}\n\nexport function getRootProcesses(stdout: string) {\n\tconst lines = stdout.trim().split('\\n');\n\tconst mapped: { pid: number; cmd: string; ppid: number }[] = [];\n\tlines.forEach(line => {\n\t\tconst match = /^\\d+\\s+\\D+\\s+root\\s+(\\d+)\\s+(\\d+).+\\d+\\:\\d+\\:\\d+\\s+(.+)$/.exec(line)!;\n\t\tif (match && match.length >= 4) {\n\t\t\tmapped.push({\n\t\t\t\tpid: parseInt(match[1], 10),\n\t\t\t\tppid: parseInt(match[2]),\n\t\t\t\tcmd: match[3]\n\t\t\t});\n\t\t}\n\t});\n\treturn mapped;\n}\n\nexport async function findPorts(connections: { socket: number; ip: string; port: number }[], socketMap: Record<string, { pid: number; socket: number }>, processes: { pid: number; cwd: string; cmd: string }[]): Promise<CandidatePort[]> {\n\tconst processMap = processes.reduce((m: Record<string, typeof processes[0]>, process) => {\n\t\tm[process.pid] = process;\n\t\treturn m;\n\t}, {});\n\n\tconst ports: CandidatePort[] = [];\n\tconnections.forEach(({ socket, ip, port }) => {\n\t\tconst pid = socketMap[socket] ? socketMap[socket].pid : undefined;\n\t\tconst command: string | undefined = pid ? processMap[pid]?.cmd : undefined;\n\t\tif (pid && command && !knownExcludeCmdline(command)) {\n\t\t\tports.push({ host: ip, port, detail: command, pid });\n\t\t}\n\t});\n\treturn ports;\n}\n\nexport function tryFindRootPorts(connections: { socket: number; ip: string; port: number }[], rootProcessesStdout: string, previousPorts: Map<number, CandidatePort & { ppid: number }>): Map<number, CandidatePort & { ppid: number }> {\n\tconst ports: Map<number, CandidatePort & { ppid: number }> = new Map();\n\tconst rootProcesses = getRootProcesses(rootProcessesStdout);\n\n\tfor (const connection of connections) {\n\t\tconst previousPort = previousPorts.get(connection.port);\n\t\tif (previousPort) {\n\t\t\tports.set(connection.port, previousPort);\n\t\t\tcontinue;\n\t\t}\n\t\tconst rootProcessMatch = rootProcesses.find((value) => value.cmd.includes(`${connection.port}`));\n\t\tif (rootProcessMatch) {\n\t\t\tlet bestMatch = rootProcessMatch;\n\t\t\t// There are often several processes that \"look\" like they could match the port.\n\t\t\t// The one we want is usually the child of the other. Find the most child process.\n\t\t\tlet mostChild: { pid: number; cmd: string; ppid: number } | undefined;\n\t\t\tdo {\n\t\t\t\tmostChild = rootProcesses.find(value => value.ppid === bestMatch.pid);\n\t\t\t\tif (mostChild) {\n\t\t\t\t\tbestMatch = mostChild;\n\t\t\t\t}\n\t\t\t} while (mostChild);\n\t\t\tports.set(connection.port, { host: connection.ip, port: connection.port, pid: bestMatch.pid, detail: bestMatch.cmd, ppid: bestMatch.ppid });\n\t\t} else {\n\t\t\tports.set(connection.port, { host: connection.ip, port: connection.port, ppid: Number.MAX_VALUE });\n\t\t}\n\t}\n\n\treturn ports;\n}\n\nexport class NodeExtHostTunnelService extends ExtHostTunnelService {\n\tprivate _initialCandidates: CandidatePort[] | undefined = undefined;\n\tprivate _foundRootPorts: Map<number, CandidatePort & { ppid: number }> = new Map();\n\tprivate _candidateFindingEnabled: boolean = false;\n\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService private readonly initData: IExtHostInitDataService,\n\t\t@ILogService logService: ILogService,\n\t\t@ISignService private readonly signService: ISignService,\n\t\t@IExtHostConfiguration private readonly configurationService: IExtHostConfiguration,\n\t) {\n\t\tsuper(extHostRpc, initData, logService);\n\t\tif (isLinux && initData.remote.isRemote && initData.remote.authority) {\n\t\t\tthis._proxy.$setRemoteTunnelService(process.pid);\n\t\t\tthis.setInitialCandidates();\n\t\t}\n\t}\n\n\toverride async $registerCandidateFinder(enable: boolean): Promise<void> {\n\t\tif (enable && this._candidateFindingEnabled) {\n\t\t\t// already enabled\n\t\t\treturn;\n\t\t}\n\n\t\tthis._candidateFindingEnabled = enable;\n\t\tlet oldPorts: { host: string; port: number; detail?: string }[] | undefined = undefined;\n\n\t\t// If we already have found initial candidates send those immediately.\n\t\tif (this._initialCandidates) {\n\t\t\toldPorts = this._initialCandidates;\n\t\t\tawait this._proxy.$onFoundNewCandidates(this._initialCandidates);\n\t\t}\n\n\t\t// Regularly scan to see if the candidate ports have changed.\n\t\tconst movingAverage = new MovingAverage();\n\t\tlet scanCount = 0;\n\t\twhile (this._candidateFindingEnabled) {\n\t\t\tconst startTime = new Date().getTime();\n\t\t\tconst newPorts = (await this.findCandidatePorts()).filter(candidate => (isLocalhost(candidate.host) || isAllInterfaces(candidate.host)));\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) found candidate ports ${newPorts.map(port => port.port).join(', ')}`);\n\t\t\tconst timeTaken = new Date().getTime() - startTime;\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) candidate port scan took ${timeTaken} ms.`);\n\t\t\t// Do not count the first few scans towards the moving average as they are likely to be slower.\n\t\t\tif (scanCount++ > 3) {\n\t\t\t\tmovingAverage.update(timeTaken);\n\t\t\t}\n\t\t\tif (!oldPorts || (JSON.stringify(oldPorts) !== JSON.stringify(newPorts))) {\n\t\t\t\toldPorts = newPorts;\n\t\t\t\tawait this._proxy.$onFoundNewCandidates(oldPorts);\n\t\t\t}\n\t\t\tconst delay = this.calculateDelay(movingAverage.value);\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) next candidate port scan in ${delay} ms.`);\n\t\t\tawait (new Promise<void>(resolve => setTimeout(() => resolve(), delay)));\n\t\t}\n\t}\n\n\tprivate calculateDelay(movingAverage: number) {\n\t\t// Some local testing indicated that the moving average might be between 50-100 ms.\n\t\treturn Math.max(movingAverage * 20, 2000);\n\t}\n\n\tprivate async setInitialCandidates(): Promise<void> {\n\t\tthis._initialCandidates = await this.findCandidatePorts();\n\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) Initial candidates found: ${this._initialCandidates.map(c => c.port).join(', ')}`);\n\t}\n\n\tprivate async findCandidatePorts(): Promise<CandidatePort[]> {\n\t\tlet tcp: string = '';\n\t\tlet tcp6: string = '';\n\t\ttry {\n\t\t\ttcp = await fs.promises.readFile('/proc/net/tcp', 'utf8');\n\t\t\ttcp6 = await fs.promises.readFile('/proc/net/tcp6', 'utf8');\n\t\t} catch (e) {\n\t\t\t// File reading error. No additional handling needed.\n\t\t}\n\t\tconst connections: { socket: number; ip: string; port: number }[] = loadListeningPorts(tcp, tcp6);\n\n\t\tconst procSockets: string = await (new Promise(resolve => {\n\t\t\texec('ls -l /proc/[0-9]*/fd/[0-9]* | grep socket:', (error, stdout, stderr) => {\n\t\t\t\tresolve(stdout);\n\t\t\t});\n\t\t}));\n\t\tconst socketMap = getSockets(procSockets);\n\n\t\tconst procChildren = await pfs.Promises.readdir('/proc');\n\t\tconst processes: {\n\t\t\tpid: number; cwd: string; cmd: string;\n\t\t}[] = [];\n\t\tfor (const childName of procChildren) {\n\t\t\ttry {\n\t\t\t\tconst pid: number = Number(childName);\n\t\t\t\tconst childUri = resources.joinPath(URI.file('/proc'), childName);\n\t\t\t\tconst childStat = await fs.promises.stat(childUri.fsPath);\n\t\t\t\tif (childStat.isDirectory() && !isNaN(pid)) {\n\t\t\t\t\tconst cwd = await fs.promises.readlink(resources.joinPath(childUri, 'cwd').fsPath);\n\t\t\t\t\tconst cmd = await fs.promises.readFile(resources.joinPath(childUri, 'cmdline').fsPath, 'utf8');\n\t\t\t\t\tprocesses.push({ pid, cwd, cmd });\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t//\n\t\t\t}\n\t\t}\n\n\t\tconst unFoundConnections: { socket: number; ip: string; port: number }[] = [];\n\t\tconst filteredConnections = connections.filter((connection => {\n\t\t\tconst foundConnection = socketMap[connection.socket];\n\t\t\tif (!foundConnection) {\n\t\t\t\tunFoundConnections.push(connection);\n\t\t\t}\n\t\t\treturn foundConnection;\n\t\t}));\n\n\t\tconst foundPorts = findPorts(filteredConnections, socketMap, processes);\n\t\tlet heuristicPorts: CandidatePort[] | undefined;\n\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) number of possible root ports ${unFoundConnections.length}`);\n\t\tif (unFoundConnections.length > 0) {\n\t\t\tconst rootProcesses: string = await (new Promise(resolve => {\n\t\t\t\texec('ps -F -A -l | grep root', (error, stdout, stderr) => {\n\t\t\t\t\tresolve(stdout);\n\t\t\t\t});\n\t\t\t}));\n\t\t\tthis._foundRootPorts = tryFindRootPorts(unFoundConnections, rootProcesses, this._foundRootPorts);\n\t\t\theuristicPorts = Array.from(this._foundRootPorts.values());\n\t\t\tthis.logService.trace(`ForwardedPorts: (ExtHostTunnelService) heuristic ports ${heuristicPorts.map(heuristicPort => heuristicPort.port).join(', ')}`);\n\n\t\t}\n\t\treturn foundPorts.then(foundCandidates => {\n\t\t\tif (heuristicPorts) {\n\t\t\t\treturn foundCandidates.concat(heuristicPorts);\n\t\t\t} else {\n\t\t\t\treturn foundCandidates;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async defaultTunnelHost(): Promise<string> {\n\t\tconst settingValue = (await this.configurationService.getConfigProvider()).getConfiguration('remote').get('localPortHost');\n\t\treturn (!settingValue || settingValue === 'localhost') ? '127.0.0.1' : '0.0.0.0';\n\t}\n\n\tprotected override makeManagedTunnelFactory(authority: vscode.ManagedResolvedAuthority): vscode.RemoteAuthorityResolver['tunnelFactory'] {\n\t\treturn async (tunnelOptions) => {\n\t\t\tconst t = new NodeRemoteTunnel(\n\t\t\t\t{\n\t\t\t\t\tcommit: this.initData.commit,\n\t\t\t\t\tquality: this.initData.quality,\n\t\t\t\t\tlogService: this.logService,\n\t\t\t\t\tipcLogger: null,\n\t\t\t\t\t// services and address providers have stubs since we don't need\n\t\t\t\t\t// the connection identification that the renderer process uses\n\t\t\t\t\tremoteSocketFactoryService: {\n\t\t\t\t\t\t_serviceBrand: undefined,\n\t\t\t\t\t\tasync connect(_connectTo: ManagedRemoteConnection, path: string, query: string, debugLabel: string): Promise<ISocket> {\n\t\t\t\t\t\t\tconst result = await authority.makeConnection();\n\t\t\t\t\t\t\treturn ExtHostManagedSocket.connect(result, path, query, debugLabel);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tregister() {\n\t\t\t\t\t\t\tthrow new Error('not implemented');\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\taddressProvider: {\n\t\t\t\t\t\tgetAddress() {\n\t\t\t\t\t\t\treturn Promise.resolve({\n\t\t\t\t\t\t\t\tconnectTo: new ManagedRemoteConnection(0),\n\t\t\t\t\t\t\t\tconnectionToken: authority.connectionToken,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tsignService: this.signService,\n\t\t\t\t},\n\t\t\t\tawait this.defaultTunnelHost(),\n\t\t\t\ttunnelOptions.remoteAddress.host || 'localhost',\n\t\t\t\ttunnelOptions.remoteAddress.port,\n\t\t\t\ttunnelOptions.localAddressPort,\n\t\t\t);\n\n\t\t\tawait t.waitForReady();\n\n\t\t\tconst disposeEmitter = new Emitter<void>();\n\n\t\t\treturn {\n\t\t\t\tlocalAddress: parseAddress(t.localAddress) ?? t.localAddress,\n\t\t\t\tremoteAddress: { port: t.tunnelRemotePort, host: t.tunnelRemoteHost },\n\t\t\t\tonDidDispose: disposeEmitter.event,\n\t\t\t\tdispose: () => {\n\t\t\t\t\tt.dispose();\n\t\t\t\t\tdisposeEmitter.fire();\n\t\t\t\t\tdisposeEmitter.dispose();\n\t\t\t\t},\n\t\t\t};\n\t\t};\n\t}\n}\n\nclass ExtHostManagedSocket extends ManagedSocket {\n\tpublic static connect(\n\t\tpassing: vscode.ManagedMessagePassing,\n\t\tpath: string, query: string, debugLabel: string,\n\t): Promise<ExtHostManagedSocket> {\n\t\tconst d = new DisposableStore();\n\t\tconst half: RemoteSocketHalf = {\n\t\t\tonClose: d.add(new Emitter()),\n\t\t\tonData: d.add(new Emitter()),\n\t\t\tonEnd: d.add(new Emitter()),\n\t\t};\n\n\t\td.add(passing.onDidReceiveMessage(d => half.onData.fire(VSBuffer.wrap(d))));\n\t\td.add(passing.onDidEnd(() => half.onEnd.fire()));\n\t\td.add(passing.onDidClose(error => half.onClose.fire({\n\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\terror,\n\t\t\thadError: !!error\n\t\t})));\n\n\t\tconst socket = new ExtHostManagedSocket(passing, debugLabel, half);\n\t\tsocket._register(d);\n\t\treturn connectManagedSocket(socket, path, query, debugLabel, half);\n\t}\n\n\tconstructor(\n\t\tprivate readonly passing: vscode.ManagedMessagePassing,\n\t\tdebugLabel: string,\n\t\thalf: RemoteSocketHalf,\n\t) {\n\t\tsuper(debugLabel, half);\n\t}\n\n\tpublic override write(buffer: VSBuffer): void {\n\t\tthis.passing.send(buffer.buffer);\n\t}\n\tprotected override closeRemote(): void {\n\t\tthis.passing.end();\n\t}\n\n\tpublic override async drain(): Promise<void> {\n\t\tawait this.passing.drain?.();\n\t}\n}\n"]}