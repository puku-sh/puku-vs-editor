{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/common/extHostEditorTabs.ts","vs/workbench/api/common/extHostEditorTabs.ts"],"names":[],"mappings":"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","file":"extHostEditorTabs.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { diffSets } from '../../../base/common/collections.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { assertReturnsDefined } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IEditorTabDto, IEditorTabGroupDto, IExtHostEditorTabsShape, MainContext, MainThreadEditorTabsShape, TabInputKind, TabModelOperationKind, TabOperation } from './extHost.protocol.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport * as typeConverters from './extHostTypeConverters.js';\nimport { ChatEditorTabInput, CustomEditorTabInput, InteractiveWindowInput, NotebookDiffEditorTabInput, NotebookEditorTabInput, TerminalEditorTabInput, TextDiffTabInput, TextMergeTabInput, TextTabInput, WebviewEditorTabInput, TextMultiDiffTabInput } from './extHostTypes.js';\nimport type * as vscode from 'vscode';\n\nexport interface IExtHostEditorTabs extends IExtHostEditorTabsShape {\n\treadonly _serviceBrand: undefined;\n\ttabGroups: vscode.TabGroups;\n}\n\nexport const IExtHostEditorTabs = createDecorator<IExtHostEditorTabs>('IExtHostEditorTabs');\n\ntype AnyTabInput = TextTabInput | TextDiffTabInput | TextMultiDiffTabInput | CustomEditorTabInput | NotebookEditorTabInput | NotebookDiffEditorTabInput | WebviewEditorTabInput | TerminalEditorTabInput | InteractiveWindowInput | ChatEditorTabInput;\n\nclass ExtHostEditorTab {\n\tprivate _apiObject: vscode.Tab | undefined;\n\tprivate _dto!: IEditorTabDto;\n\tprivate _input: AnyTabInput | undefined;\n\tprivate _parentGroup: ExtHostEditorTabGroup;\n\tprivate readonly _activeTabIdGetter: () => string;\n\n\tconstructor(dto: IEditorTabDto, parentGroup: ExtHostEditorTabGroup, activeTabIdGetter: () => string) {\n\t\tthis._activeTabIdGetter = activeTabIdGetter;\n\t\tthis._parentGroup = parentGroup;\n\t\tthis.acceptDtoUpdate(dto);\n\t}\n\n\tget apiObject(): vscode.Tab {\n\t\tif (!this._apiObject) {\n\t\t\t// Don't want to lose reference to parent `this` in the getters\n\t\t\tconst that = this;\n\t\t\tconst obj: vscode.Tab = {\n\t\t\t\tget isActive() {\n\t\t\t\t\t// We use a getter function here to always ensure at most 1 active tab per group and prevent iteration for being required\n\t\t\t\t\treturn that._dto.id === that._activeTabIdGetter();\n\t\t\t\t},\n\t\t\t\tget label() {\n\t\t\t\t\treturn that._dto.label;\n\t\t\t\t},\n\t\t\t\tget input() {\n\t\t\t\t\treturn that._input;\n\t\t\t\t},\n\t\t\t\tget isDirty() {\n\t\t\t\t\treturn that._dto.isDirty;\n\t\t\t\t},\n\t\t\t\tget isPinned() {\n\t\t\t\t\treturn that._dto.isPinned;\n\t\t\t\t},\n\t\t\t\tget isPreview() {\n\t\t\t\t\treturn that._dto.isPreview;\n\t\t\t\t},\n\t\t\t\tget group() {\n\t\t\t\t\treturn that._parentGroup.apiObject;\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._apiObject = Object.freeze<vscode.Tab>(obj);\n\t\t}\n\t\treturn this._apiObject;\n\t}\n\n\tget tabId(): string {\n\t\treturn this._dto.id;\n\t}\n\n\tacceptDtoUpdate(dto: IEditorTabDto) {\n\t\tthis._dto = dto;\n\t\tthis._input = this._initInput();\n\t}\n\n\tprivate _initInput() {\n\t\tswitch (this._dto.input.kind) {\n\t\t\tcase TabInputKind.TextInput:\n\t\t\t\treturn new TextTabInput(URI.revive(this._dto.input.uri));\n\t\t\tcase TabInputKind.TextDiffInput:\n\t\t\t\treturn new TextDiffTabInput(URI.revive(this._dto.input.original), URI.revive(this._dto.input.modified));\n\t\t\tcase TabInputKind.TextMergeInput:\n\t\t\t\treturn new TextMergeTabInput(URI.revive(this._dto.input.base), URI.revive(this._dto.input.input1), URI.revive(this._dto.input.input2), URI.revive(this._dto.input.result));\n\t\t\tcase TabInputKind.CustomEditorInput:\n\t\t\t\treturn new CustomEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.viewType);\n\t\t\tcase TabInputKind.WebviewEditorInput:\n\t\t\t\treturn new WebviewEditorTabInput(this._dto.input.viewType);\n\t\t\tcase TabInputKind.NotebookInput:\n\t\t\t\treturn new NotebookEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.notebookType);\n\t\t\tcase TabInputKind.NotebookDiffInput:\n\t\t\t\treturn new NotebookDiffEditorTabInput(URI.revive(this._dto.input.original), URI.revive(this._dto.input.modified), this._dto.input.notebookType);\n\t\t\tcase TabInputKind.TerminalEditorInput:\n\t\t\t\treturn new TerminalEditorTabInput();\n\t\t\tcase TabInputKind.InteractiveEditorInput:\n\t\t\t\treturn new InteractiveWindowInput(URI.revive(this._dto.input.uri), URI.revive(this._dto.input.inputBoxUri));\n\t\t\tcase TabInputKind.ChatEditorInput:\n\t\t\t\treturn new ChatEditorTabInput();\n\t\t\tcase TabInputKind.MultiDiffEditorInput:\n\t\t\t\treturn new TextMultiDiffTabInput(this._dto.input.diffEditors.map(diff => new TextDiffTabInput(URI.revive(diff.original), URI.revive(diff.modified))));\n\t\t\tdefault:\n\t\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nclass ExtHostEditorTabGroup {\n\n\tprivate _apiObject: vscode.TabGroup | undefined;\n\tprivate _dto: IEditorTabGroupDto;\n\tprivate _tabs: ExtHostEditorTab[] = [];\n\tprivate _activeTabId: string = '';\n\tprivate _activeGroupIdGetter: () => number | undefined;\n\n\tconstructor(dto: IEditorTabGroupDto, activeGroupIdGetter: () => number | undefined) {\n\t\tthis._dto = dto;\n\t\tthis._activeGroupIdGetter = activeGroupIdGetter;\n\t\t// Construct all tabs from the given dto\n\t\tfor (const tabDto of dto.tabs) {\n\t\t\tif (tabDto.isActive) {\n\t\t\t\tthis._activeTabId = tabDto.id;\n\t\t\t}\n\t\t\tthis._tabs.push(new ExtHostEditorTab(tabDto, this, () => this.activeTabId()));\n\t\t}\n\t}\n\n\tget apiObject(): vscode.TabGroup {\n\t\tif (!this._apiObject) {\n\t\t\t// Don't want to lose reference to parent `this` in the getters\n\t\t\tconst that = this;\n\t\t\tconst obj: vscode.TabGroup = {\n\t\t\t\tget isActive() {\n\t\t\t\t\t// We use a getter function here to always ensure at most 1 active group and prevent iteration for being required\n\t\t\t\t\treturn that._dto.groupId === that._activeGroupIdGetter();\n\t\t\t\t},\n\t\t\t\tget viewColumn() {\n\t\t\t\t\treturn typeConverters.ViewColumn.to(that._dto.viewColumn);\n\t\t\t\t},\n\t\t\t\tget activeTab() {\n\t\t\t\t\treturn that._tabs.find(tab => tab.tabId === that._activeTabId)?.apiObject;\n\t\t\t\t},\n\t\t\t\tget tabs() {\n\t\t\t\t\treturn Object.freeze(that._tabs.map(tab => tab.apiObject));\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._apiObject = Object.freeze<vscode.TabGroup>(obj);\n\t\t}\n\t\treturn this._apiObject;\n\t}\n\n\tget groupId(): number {\n\t\treturn this._dto.groupId;\n\t}\n\n\tget tabs(): ExtHostEditorTab[] {\n\t\treturn this._tabs;\n\t}\n\n\tacceptGroupDtoUpdate(dto: IEditorTabGroupDto) {\n\t\tthis._dto = dto;\n\t}\n\n\tacceptTabOperation(operation: TabOperation): ExtHostEditorTab {\n\t\t// In the open case we add the tab to the group\n\t\tif (operation.kind === TabModelOperationKind.TAB_OPEN) {\n\t\t\tconst tab = new ExtHostEditorTab(operation.tabDto, this, () => this.activeTabId());\n\t\t\t// Insert tab at editor index\n\t\t\tthis._tabs.splice(operation.index, 0, tab);\n\t\t\tif (operation.tabDto.isActive) {\n\t\t\t\tthis._activeTabId = tab.tabId;\n\t\t\t}\n\t\t\treturn tab;\n\t\t} else if (operation.kind === TabModelOperationKind.TAB_CLOSE) {\n\t\t\tconst tab = this._tabs.splice(operation.index, 1)[0];\n\t\t\tif (!tab) {\n\t\t\t\tthrow new Error(`Tab close updated received for index ${operation.index} which does not exist`);\n\t\t\t}\n\t\t\tif (tab.tabId === this._activeTabId) {\n\t\t\t\tthis._activeTabId = '';\n\t\t\t}\n\t\t\treturn tab;\n\t\t} else if (operation.kind === TabModelOperationKind.TAB_MOVE) {\n\t\t\tif (operation.oldIndex === undefined) {\n\t\t\t\tthrow new Error('Invalid old index on move IPC');\n\t\t\t}\n\t\t\t// Splice to remove at old index and insert at new index === moving the tab\n\t\t\tconst tab = this._tabs.splice(operation.oldIndex, 1)[0];\n\t\t\tif (!tab) {\n\t\t\t\tthrow new Error(`Tab move updated received for index ${operation.oldIndex} which does not exist`);\n\t\t\t}\n\t\t\tthis._tabs.splice(operation.index, 0, tab);\n\t\t\treturn tab;\n\t\t}\n\t\tconst tab = this._tabs.find(extHostTab => extHostTab.tabId === operation.tabDto.id);\n\t\tif (!tab) {\n\t\t\tthrow new Error('INVALID tab');\n\t\t}\n\t\tif (operation.tabDto.isActive) {\n\t\t\tthis._activeTabId = operation.tabDto.id;\n\t\t} else if (this._activeTabId === operation.tabDto.id && !operation.tabDto.isActive) {\n\t\t\t// Events aren't guaranteed to be in order so if we receive a dto that matches the active tab id\n\t\t\t// but isn't active we mark the active tab id as empty. This prevent onDidActiveTabChange from\n\t\t\t// firing incorrectly\n\t\t\tthis._activeTabId = '';\n\t\t}\n\t\ttab.acceptDtoUpdate(operation.tabDto);\n\t\treturn tab;\n\t}\n\n\t// Not a getter since it must be a function to be used as a callback for the tabs\n\tactiveTabId(): string {\n\t\treturn this._activeTabId;\n\t}\n}\n\nexport class ExtHostEditorTabs implements IExtHostEditorTabs {\n\treadonly _serviceBrand: undefined;\n\n\tprivate readonly _proxy: MainThreadEditorTabsShape;\n\tprivate readonly _onDidChangeTabs = new Emitter<vscode.TabChangeEvent>();\n\tprivate readonly _onDidChangeTabGroups = new Emitter<vscode.TabGroupChangeEvent>();\n\n\t// Have to use ! because this gets initialized via an RPC proxy\n\tprivate _activeGroupId!: number;\n\n\tprivate _extHostTabGroups: ExtHostEditorTabGroup[] = [];\n\n\tprivate _apiObject: vscode.TabGroups | undefined;\n\n\tconstructor(@IExtHostRpcService extHostRpc: IExtHostRpcService) {\n\t\tthis._proxy = extHostRpc.getProxy(MainContext.MainThreadEditorTabs);\n\t}\n\n\tget tabGroups(): vscode.TabGroups {\n\t\tif (!this._apiObject) {\n\t\t\tconst that = this;\n\t\t\tconst obj: vscode.TabGroups = {\n\t\t\t\t// never changes -> simple value\n\t\t\t\tonDidChangeTabGroups: that._onDidChangeTabGroups.event,\n\t\t\t\tonDidChangeTabs: that._onDidChangeTabs.event,\n\t\t\t\t// dynamic -> getters\n\t\t\t\tget all() {\n\t\t\t\t\treturn Object.freeze(that._extHostTabGroups.map(group => group.apiObject));\n\t\t\t\t},\n\t\t\t\tget activeTabGroup() {\n\t\t\t\t\tconst activeTabGroupId = that._activeGroupId;\n\t\t\t\t\tconst activeTabGroup = assertReturnsDefined(that._extHostTabGroups.find(candidate => candidate.groupId === activeTabGroupId)?.apiObject);\n\t\t\t\t\treturn activeTabGroup;\n\t\t\t\t},\n\t\t\t\tclose: async (tabOrTabGroup: vscode.Tab | readonly vscode.Tab[] | vscode.TabGroup | readonly vscode.TabGroup[], preserveFocus?: boolean) => {\n\t\t\t\t\tconst tabsOrTabGroups = Array.isArray(tabOrTabGroup) ? tabOrTabGroup : [tabOrTabGroup];\n\t\t\t\t\tif (!tabsOrTabGroups.length) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Check which type was passed in and call the appropriate close\n\t\t\t\t\t// Casting is needed as typescript doesn't seem to infer enough from this\n\t\t\t\t\tif (isTabGroup(tabsOrTabGroups[0])) {\n\t\t\t\t\t\treturn this._closeGroups(tabsOrTabGroups as vscode.TabGroup[], preserveFocus);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._closeTabs(tabsOrTabGroups as vscode.Tab[], preserveFocus);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// move: async (tab: vscode.Tab, viewColumn: ViewColumn, index: number, preserveFocus?: boolean) => {\n\t\t\t\t// \tconst extHostTab = this._findExtHostTabFromApi(tab);\n\t\t\t\t// \tif (!extHostTab) {\n\t\t\t\t// \t\tthrow new Error('Invalid tab');\n\t\t\t\t// \t}\n\t\t\t\t// \tthis._proxy.$moveTab(extHostTab.tabId, index, typeConverters.ViewColumn.from(viewColumn), preserveFocus);\n\t\t\t\t// \treturn;\n\t\t\t\t// }\n\t\t\t};\n\t\t\tthis._apiObject = Object.freeze(obj);\n\t\t}\n\t\treturn this._apiObject;\n\t}\n\n\t$acceptEditorTabModel(tabGroups: IEditorTabGroupDto[]): void {\n\n\t\tconst groupIdsBefore = new Set(this._extHostTabGroups.map(group => group.groupId));\n\t\tconst groupIdsAfter = new Set(tabGroups.map(dto => dto.groupId));\n\t\tconst diff = diffSets(groupIdsBefore, groupIdsAfter);\n\n\t\tconst closed: vscode.TabGroup[] = this._extHostTabGroups.filter(group => diff.removed.includes(group.groupId)).map(group => group.apiObject);\n\t\tconst opened: vscode.TabGroup[] = [];\n\t\tconst changed: vscode.TabGroup[] = [];\n\n\n\t\tthis._extHostTabGroups = tabGroups.map(tabGroup => {\n\t\t\tconst group = new ExtHostEditorTabGroup(tabGroup, () => this._activeGroupId);\n\t\t\tif (diff.added.includes(group.groupId)) {\n\t\t\t\topened.push(group.apiObject);\n\t\t\t} else {\n\t\t\t\tchanged.push(group.apiObject);\n\t\t\t}\n\t\t\treturn group;\n\t\t});\n\n\t\t// Set the active tab group id\n\t\tconst activeTabGroupId = assertReturnsDefined(tabGroups.find(group => group.isActive === true)?.groupId);\n\t\tif (activeTabGroupId !== undefined && this._activeGroupId !== activeTabGroupId) {\n\t\t\tthis._activeGroupId = activeTabGroupId;\n\t\t}\n\t\tthis._onDidChangeTabGroups.fire(Object.freeze({ opened, closed, changed }));\n\t}\n\n\t$acceptTabGroupUpdate(groupDto: IEditorTabGroupDto) {\n\t\tconst group = this._extHostTabGroups.find(group => group.groupId === groupDto.groupId);\n\t\tif (!group) {\n\t\t\tthrow new Error('Update Group IPC call received before group creation.');\n\t\t}\n\t\tgroup.acceptGroupDtoUpdate(groupDto);\n\t\tif (groupDto.isActive) {\n\t\t\tthis._activeGroupId = groupDto.groupId;\n\t\t}\n\t\tthis._onDidChangeTabGroups.fire(Object.freeze({ changed: [group.apiObject], opened: [], closed: [] }));\n\t}\n\n\t$acceptTabOperation(operation: TabOperation) {\n\t\tconst group = this._extHostTabGroups.find(group => group.groupId === operation.groupId);\n\t\tif (!group) {\n\t\t\tthrow new Error('Update Tabs IPC call received before group creation.');\n\t\t}\n\t\tconst tab = group.acceptTabOperation(operation);\n\n\t\t// Construct the tab change event based on the operation\n\t\tswitch (operation.kind) {\n\t\t\tcase TabModelOperationKind.TAB_OPEN:\n\t\t\t\tthis._onDidChangeTabs.fire(Object.freeze({\n\t\t\t\t\topened: [tab.apiObject],\n\t\t\t\t\tclosed: [],\n\t\t\t\t\tchanged: []\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\tcase TabModelOperationKind.TAB_CLOSE:\n\t\t\t\tthis._onDidChangeTabs.fire(Object.freeze({\n\t\t\t\t\topened: [],\n\t\t\t\t\tclosed: [tab.apiObject],\n\t\t\t\t\tchanged: []\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\tcase TabModelOperationKind.TAB_MOVE:\n\t\t\tcase TabModelOperationKind.TAB_UPDATE:\n\t\t\t\tthis._onDidChangeTabs.fire(Object.freeze({\n\t\t\t\t\topened: [],\n\t\t\t\t\tclosed: [],\n\t\t\t\t\tchanged: [tab.apiObject]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tprivate _findExtHostTabFromApi(apiTab: vscode.Tab): ExtHostEditorTab | undefined {\n\t\tfor (const group of this._extHostTabGroups) {\n\t\t\tfor (const tab of group.tabs) {\n\t\t\t\tif (tab.apiObject === apiTab) {\n\t\t\t\t\treturn tab;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate _findExtHostTabGroupFromApi(apiTabGroup: vscode.TabGroup): ExtHostEditorTabGroup | undefined {\n\t\treturn this._extHostTabGroups.find(candidate => candidate.apiObject === apiTabGroup);\n\t}\n\n\tprivate async _closeTabs(tabs: vscode.Tab[], preserveFocus?: boolean): Promise<boolean> {\n\t\tconst extHostTabIds: string[] = [];\n\t\tfor (const tab of tabs) {\n\t\t\tconst extHostTab = this._findExtHostTabFromApi(tab);\n\t\t\tif (!extHostTab) {\n\t\t\t\tthrow new Error('Tab close: Invalid tab not found!');\n\t\t\t}\n\t\t\textHostTabIds.push(extHostTab.tabId);\n\t\t}\n\t\treturn this._proxy.$closeTab(extHostTabIds, preserveFocus);\n\t}\n\n\tprivate async _closeGroups(groups: vscode.TabGroup[], preserverFoucs?: boolean): Promise<boolean> {\n\t\tconst extHostGroupIds: number[] = [];\n\t\tfor (const group of groups) {\n\t\t\tconst extHostGroup = this._findExtHostTabGroupFromApi(group);\n\t\t\tif (!extHostGroup) {\n\t\t\t\tthrow new Error('Group close: Invalid group not found!');\n\t\t\t}\n\t\t\textHostGroupIds.push(extHostGroup.groupId);\n\t\t}\n\t\treturn this._proxy.$closeGroup(extHostGroupIds, preserverFoucs);\n\t}\n}\n\n//#region Utils\nfunction isTabGroup(obj: unknown): obj is vscode.TabGroup {\n\tconst tabGroup = obj as vscode.TabGroup;\n\tif (tabGroup.tabs !== undefined) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { diffSets } from '../../../base/common/collections.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { assertReturnsDefined } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IEditorTabDto, IEditorTabGroupDto, IExtHostEditorTabsShape, MainContext, MainThreadEditorTabsShape, TabInputKind, TabModelOperationKind, TabOperation } from './extHost.protocol.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport * as typeConverters from './extHostTypeConverters.js';\nimport { ChatEditorTabInput, CustomEditorTabInput, InteractiveWindowInput, NotebookDiffEditorTabInput, NotebookEditorTabInput, TerminalEditorTabInput, TextDiffTabInput, TextMergeTabInput, TextTabInput, WebviewEditorTabInput, TextMultiDiffTabInput } from './extHostTypes.js';\nimport type * as vscode from 'vscode';\n\nexport interface IExtHostEditorTabs extends IExtHostEditorTabsShape {\n\treadonly _serviceBrand: undefined;\n\ttabGroups: vscode.TabGroups;\n}\n\nexport const IExtHostEditorTabs = createDecorator<IExtHostEditorTabs>('IExtHostEditorTabs');\n\ntype AnyTabInput = TextTabInput | TextDiffTabInput | TextMultiDiffTabInput | CustomEditorTabInput | NotebookEditorTabInput | NotebookDiffEditorTabInput | WebviewEditorTabInput | TerminalEditorTabInput | InteractiveWindowInput | ChatEditorTabInput;\n\nclass ExtHostEditorTab {\n\tprivate _apiObject: vscode.Tab | undefined;\n\tprivate _dto!: IEditorTabDto;\n\tprivate _input: AnyTabInput | undefined;\n\tprivate _parentGroup: ExtHostEditorTabGroup;\n\tprivate readonly _activeTabIdGetter: () => string;\n\n\tconstructor(dto: IEditorTabDto, parentGroup: ExtHostEditorTabGroup, activeTabIdGetter: () => string) {\n\t\tthis._activeTabIdGetter = activeTabIdGetter;\n\t\tthis._parentGroup = parentGroup;\n\t\tthis.acceptDtoUpdate(dto);\n\t}\n\n\tget apiObject(): vscode.Tab {\n\t\tif (!this._apiObject) {\n\t\t\t// Don't want to lose reference to parent `this` in the getters\n\t\t\tconst that = this;\n\t\t\tconst obj: vscode.Tab = {\n\t\t\t\tget isActive() {\n\t\t\t\t\t// We use a getter function here to always ensure at most 1 active tab per group and prevent iteration for being required\n\t\t\t\t\treturn that._dto.id === that._activeTabIdGetter();\n\t\t\t\t},\n\t\t\t\tget label() {\n\t\t\t\t\treturn that._dto.label;\n\t\t\t\t},\n\t\t\t\tget input() {\n\t\t\t\t\treturn that._input;\n\t\t\t\t},\n\t\t\t\tget isDirty() {\n\t\t\t\t\treturn that._dto.isDirty;\n\t\t\t\t},\n\t\t\t\tget isPinned() {\n\t\t\t\t\treturn that._dto.isPinned;\n\t\t\t\t},\n\t\t\t\tget isPreview() {\n\t\t\t\t\treturn that._dto.isPreview;\n\t\t\t\t},\n\t\t\t\tget group() {\n\t\t\t\t\treturn that._parentGroup.apiObject;\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._apiObject = Object.freeze<vscode.Tab>(obj);\n\t\t}\n\t\treturn this._apiObject;\n\t}\n\n\tget tabId(): string {\n\t\treturn this._dto.id;\n\t}\n\n\tacceptDtoUpdate(dto: IEditorTabDto) {\n\t\tthis._dto = dto;\n\t\tthis._input = this._initInput();\n\t}\n\n\tprivate _initInput() {\n\t\tswitch (this._dto.input.kind) {\n\t\t\tcase TabInputKind.TextInput:\n\t\t\t\treturn new TextTabInput(URI.revive(this._dto.input.uri));\n\t\t\tcase TabInputKind.TextDiffInput:\n\t\t\t\treturn new TextDiffTabInput(URI.revive(this._dto.input.original), URI.revive(this._dto.input.modified));\n\t\t\tcase TabInputKind.TextMergeInput:\n\t\t\t\treturn new TextMergeTabInput(URI.revive(this._dto.input.base), URI.revive(this._dto.input.input1), URI.revive(this._dto.input.input2), URI.revive(this._dto.input.result));\n\t\t\tcase TabInputKind.CustomEditorInput:\n\t\t\t\treturn new CustomEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.viewType);\n\t\t\tcase TabInputKind.WebviewEditorInput:\n\t\t\t\treturn new WebviewEditorTabInput(this._dto.input.viewType);\n\t\t\tcase TabInputKind.NotebookInput:\n\t\t\t\treturn new NotebookEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.notebookType);\n\t\t\tcase TabInputKind.NotebookDiffInput:\n\t\t\t\treturn new NotebookDiffEditorTabInput(URI.revive(this._dto.input.original), URI.revive(this._dto.input.modified), this._dto.input.notebookType);\n\t\t\tcase TabInputKind.TerminalEditorInput:\n\t\t\t\treturn new TerminalEditorTabInput();\n\t\t\tcase TabInputKind.InteractiveEditorInput:\n\t\t\t\treturn new InteractiveWindowInput(URI.revive(this._dto.input.uri), URI.revive(this._dto.input.inputBoxUri));\n\t\t\tcase TabInputKind.ChatEditorInput:\n\t\t\t\treturn new ChatEditorTabInput();\n\t\t\tcase TabInputKind.MultiDiffEditorInput:\n\t\t\t\treturn new TextMultiDiffTabInput(this._dto.input.diffEditors.map(diff => new TextDiffTabInput(URI.revive(diff.original), URI.revive(diff.modified))));\n\t\t\tdefault:\n\t\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nclass ExtHostEditorTabGroup {\n\n\tprivate _apiObject: vscode.TabGroup | undefined;\n\tprivate _dto: IEditorTabGroupDto;\n\tprivate _tabs: ExtHostEditorTab[] = [];\n\tprivate _activeTabId: string = '';\n\tprivate _activeGroupIdGetter: () => number | undefined;\n\n\tconstructor(dto: IEditorTabGroupDto, activeGroupIdGetter: () => number | undefined) {\n\t\tthis._dto = dto;\n\t\tthis._activeGroupIdGetter = activeGroupIdGetter;\n\t\t// Construct all tabs from the given dto\n\t\tfor (const tabDto of dto.tabs) {\n\t\t\tif (tabDto.isActive) {\n\t\t\t\tthis._activeTabId = tabDto.id;\n\t\t\t}\n\t\t\tthis._tabs.push(new ExtHostEditorTab(tabDto, this, () => this.activeTabId()));\n\t\t}\n\t}\n\n\tget apiObject(): vscode.TabGroup {\n\t\tif (!this._apiObject) {\n\t\t\t// Don't want to lose reference to parent `this` in the getters\n\t\t\tconst that = this;\n\t\t\tconst obj: vscode.TabGroup = {\n\t\t\t\tget isActive() {\n\t\t\t\t\t// We use a getter function here to always ensure at most 1 active group and prevent iteration for being required\n\t\t\t\t\treturn that._dto.groupId === that._activeGroupIdGetter();\n\t\t\t\t},\n\t\t\t\tget viewColumn() {\n\t\t\t\t\treturn typeConverters.ViewColumn.to(that._dto.viewColumn);\n\t\t\t\t},\n\t\t\t\tget activeTab() {\n\t\t\t\t\treturn that._tabs.find(tab => tab.tabId === that._activeTabId)?.apiObject;\n\t\t\t\t},\n\t\t\t\tget tabs() {\n\t\t\t\t\treturn Object.freeze(that._tabs.map(tab => tab.apiObject));\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._apiObject = Object.freeze<vscode.TabGroup>(obj);\n\t\t}\n\t\treturn this._apiObject;\n\t}\n\n\tget groupId(): number {\n\t\treturn this._dto.groupId;\n\t}\n\n\tget tabs(): ExtHostEditorTab[] {\n\t\treturn this._tabs;\n\t}\n\n\tacceptGroupDtoUpdate(dto: IEditorTabGroupDto) {\n\t\tthis._dto = dto;\n\t}\n\n\tacceptTabOperation(operation: TabOperation): ExtHostEditorTab {\n\t\t// In the open case we add the tab to the group\n\t\tif (operation.kind === TabModelOperationKind.TAB_OPEN) {\n\t\t\tconst tab = new ExtHostEditorTab(operation.tabDto, this, () => this.activeTabId());\n\t\t\t// Insert tab at editor index\n\t\t\tthis._tabs.splice(operation.index, 0, tab);\n\t\t\tif (operation.tabDto.isActive) {\n\t\t\t\tthis._activeTabId = tab.tabId;\n\t\t\t}\n\t\t\treturn tab;\n\t\t} else if (operation.kind === TabModelOperationKind.TAB_CLOSE) {\n\t\t\tconst tab = this._tabs.splice(operation.index, 1)[0];\n\t\t\tif (!tab) {\n\t\t\t\tthrow new Error(`Tab close updated received for index ${operation.index} which does not exist`);\n\t\t\t}\n\t\t\tif (tab.tabId === this._activeTabId) {\n\t\t\t\tthis._activeTabId = '';\n\t\t\t}\n\t\t\treturn tab;\n\t\t} else if (operation.kind === TabModelOperationKind.TAB_MOVE) {\n\t\t\tif (operation.oldIndex === undefined) {\n\t\t\t\tthrow new Error('Invalid old index on move IPC');\n\t\t\t}\n\t\t\t// Splice to remove at old index and insert at new index === moving the tab\n\t\t\tconst tab = this._tabs.splice(operation.oldIndex, 1)[0];\n\t\t\tif (!tab) {\n\t\t\t\tthrow new Error(`Tab move updated received for index ${operation.oldIndex} which does not exist`);\n\t\t\t}\n\t\t\tthis._tabs.splice(operation.index, 0, tab);\n\t\t\treturn tab;\n\t\t}\n\t\tconst tab = this._tabs.find(extHostTab => extHostTab.tabId === operation.tabDto.id);\n\t\tif (!tab) {\n\t\t\tthrow new Error('INVALID tab');\n\t\t}\n\t\tif (operation.tabDto.isActive) {\n\t\t\tthis._activeTabId = operation.tabDto.id;\n\t\t} else if (this._activeTabId === operation.tabDto.id && !operation.tabDto.isActive) {\n\t\t\t// Events aren't guaranteed to be in order so if we receive a dto that matches the active tab id\n\t\t\t// but isn't active we mark the active tab id as empty. This prevent onDidActiveTabChange from\n\t\t\t// firing incorrectly\n\t\t\tthis._activeTabId = '';\n\t\t}\n\t\ttab.acceptDtoUpdate(operation.tabDto);\n\t\treturn tab;\n\t}\n\n\t// Not a getter since it must be a function to be used as a callback for the tabs\n\tactiveTabId(): string {\n\t\treturn this._activeTabId;\n\t}\n}\n\nexport class ExtHostEditorTabs implements IExtHostEditorTabs {\n\treadonly _serviceBrand: undefined;\n\n\tprivate readonly _proxy: MainThreadEditorTabsShape;\n\tprivate readonly _onDidChangeTabs = new Emitter<vscode.TabChangeEvent>();\n\tprivate readonly _onDidChangeTabGroups = new Emitter<vscode.TabGroupChangeEvent>();\n\n\t// Have to use ! because this gets initialized via an RPC proxy\n\tprivate _activeGroupId!: number;\n\n\tprivate _extHostTabGroups: ExtHostEditorTabGroup[] = [];\n\n\tprivate _apiObject: vscode.TabGroups | undefined;\n\n\tconstructor(@IExtHostRpcService extHostRpc: IExtHostRpcService) {\n\t\tthis._proxy = extHostRpc.getProxy(MainContext.MainThreadEditorTabs);\n\t}\n\n\tget tabGroups(): vscode.TabGroups {\n\t\tif (!this._apiObject) {\n\t\t\tconst that = this;\n\t\t\tconst obj: vscode.TabGroups = {\n\t\t\t\t// never changes -> simple value\n\t\t\t\tonDidChangeTabGroups: that._onDidChangeTabGroups.event,\n\t\t\t\tonDidChangeTabs: that._onDidChangeTabs.event,\n\t\t\t\t// dynamic -> getters\n\t\t\t\tget all() {\n\t\t\t\t\treturn Object.freeze(that._extHostTabGroups.map(group => group.apiObject));\n\t\t\t\t},\n\t\t\t\tget activeTabGroup() {\n\t\t\t\t\tconst activeTabGroupId = that._activeGroupId;\n\t\t\t\t\tconst activeTabGroup = assertReturnsDefined(that._extHostTabGroups.find(candidate => candidate.groupId === activeTabGroupId)?.apiObject);\n\t\t\t\t\treturn activeTabGroup;\n\t\t\t\t},\n\t\t\t\tclose: async (tabOrTabGroup: vscode.Tab | readonly vscode.Tab[] | vscode.TabGroup | readonly vscode.TabGroup[], preserveFocus?: boolean) => {\n\t\t\t\t\tconst tabsOrTabGroups = Array.isArray(tabOrTabGroup) ? tabOrTabGroup : [tabOrTabGroup];\n\t\t\t\t\tif (!tabsOrTabGroups.length) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Check which type was passed in and call the appropriate close\n\t\t\t\t\t// Casting is needed as typescript doesn't seem to infer enough from this\n\t\t\t\t\tif (isTabGroup(tabsOrTabGroups[0])) {\n\t\t\t\t\t\treturn this._closeGroups(tabsOrTabGroups as vscode.TabGroup[], preserveFocus);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._closeTabs(tabsOrTabGroups as vscode.Tab[], preserveFocus);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// move: async (tab: vscode.Tab, viewColumn: ViewColumn, index: number, preserveFocus?: boolean) => {\n\t\t\t\t// \tconst extHostTab = this._findExtHostTabFromApi(tab);\n\t\t\t\t// \tif (!extHostTab) {\n\t\t\t\t// \t\tthrow new Error('Invalid tab');\n\t\t\t\t// \t}\n\t\t\t\t// \tthis._proxy.$moveTab(extHostTab.tabId, index, typeConverters.ViewColumn.from(viewColumn), preserveFocus);\n\t\t\t\t// \treturn;\n\t\t\t\t// }\n\t\t\t};\n\t\t\tthis._apiObject = Object.freeze(obj);\n\t\t}\n\t\treturn this._apiObject;\n\t}\n\n\t$acceptEditorTabModel(tabGroups: IEditorTabGroupDto[]): void {\n\n\t\tconst groupIdsBefore = new Set(this._extHostTabGroups.map(group => group.groupId));\n\t\tconst groupIdsAfter = new Set(tabGroups.map(dto => dto.groupId));\n\t\tconst diff = diffSets(groupIdsBefore, groupIdsAfter);\n\n\t\tconst closed: vscode.TabGroup[] = this._extHostTabGroups.filter(group => diff.removed.includes(group.groupId)).map(group => group.apiObject);\n\t\tconst opened: vscode.TabGroup[] = [];\n\t\tconst changed: vscode.TabGroup[] = [];\n\n\n\t\tthis._extHostTabGroups = tabGroups.map(tabGroup => {\n\t\t\tconst group = new ExtHostEditorTabGroup(tabGroup, () => this._activeGroupId);\n\t\t\tif (diff.added.includes(group.groupId)) {\n\t\t\t\topened.push(group.apiObject);\n\t\t\t} else {\n\t\t\t\tchanged.push(group.apiObject);\n\t\t\t}\n\t\t\treturn group;\n\t\t});\n\n\t\t// Set the active tab group id\n\t\tconst activeTabGroupId = assertReturnsDefined(tabGroups.find(group => group.isActive === true)?.groupId);\n\t\tif (activeTabGroupId !== undefined && this._activeGroupId !== activeTabGroupId) {\n\t\t\tthis._activeGroupId = activeTabGroupId;\n\t\t}\n\t\tthis._onDidChangeTabGroups.fire(Object.freeze({ opened, closed, changed }));\n\t}\n\n\t$acceptTabGroupUpdate(groupDto: IEditorTabGroupDto) {\n\t\tconst group = this._extHostTabGroups.find(group => group.groupId === groupDto.groupId);\n\t\tif (!group) {\n\t\t\tthrow new Error('Update Group IPC call received before group creation.');\n\t\t}\n\t\tgroup.acceptGroupDtoUpdate(groupDto);\n\t\tif (groupDto.isActive) {\n\t\t\tthis._activeGroupId = groupDto.groupId;\n\t\t}\n\t\tthis._onDidChangeTabGroups.fire(Object.freeze({ changed: [group.apiObject], opened: [], closed: [] }));\n\t}\n\n\t$acceptTabOperation(operation: TabOperation) {\n\t\tconst group = this._extHostTabGroups.find(group => group.groupId === operation.groupId);\n\t\tif (!group) {\n\t\t\tthrow new Error('Update Tabs IPC call received before group creation.');\n\t\t}\n\t\tconst tab = group.acceptTabOperation(operation);\n\n\t\t// Construct the tab change event based on the operation\n\t\tswitch (operation.kind) {\n\t\t\tcase TabModelOperationKind.TAB_OPEN:\n\t\t\t\tthis._onDidChangeTabs.fire(Object.freeze({\n\t\t\t\t\topened: [tab.apiObject],\n\t\t\t\t\tclosed: [],\n\t\t\t\t\tchanged: []\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\tcase TabModelOperationKind.TAB_CLOSE:\n\t\t\t\tthis._onDidChangeTabs.fire(Object.freeze({\n\t\t\t\t\topened: [],\n\t\t\t\t\tclosed: [tab.apiObject],\n\t\t\t\t\tchanged: []\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\tcase TabModelOperationKind.TAB_MOVE:\n\t\t\tcase TabModelOperationKind.TAB_UPDATE:\n\t\t\t\tthis._onDidChangeTabs.fire(Object.freeze({\n\t\t\t\t\topened: [],\n\t\t\t\t\tclosed: [],\n\t\t\t\t\tchanged: [tab.apiObject]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tprivate _findExtHostTabFromApi(apiTab: vscode.Tab): ExtHostEditorTab | undefined {\n\t\tfor (const group of this._extHostTabGroups) {\n\t\t\tfor (const tab of group.tabs) {\n\t\t\t\tif (tab.apiObject === apiTab) {\n\t\t\t\t\treturn tab;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate _findExtHostTabGroupFromApi(apiTabGroup: vscode.TabGroup): ExtHostEditorTabGroup | undefined {\n\t\treturn this._extHostTabGroups.find(candidate => candidate.apiObject === apiTabGroup);\n\t}\n\n\tprivate async _closeTabs(tabs: vscode.Tab[], preserveFocus?: boolean): Promise<boolean> {\n\t\tconst extHostTabIds: string[] = [];\n\t\tfor (const tab of tabs) {\n\t\t\tconst extHostTab = this._findExtHostTabFromApi(tab);\n\t\t\tif (!extHostTab) {\n\t\t\t\tthrow new Error('Tab close: Invalid tab not found!');\n\t\t\t}\n\t\t\textHostTabIds.push(extHostTab.tabId);\n\t\t}\n\t\treturn this._proxy.$closeTab(extHostTabIds, preserveFocus);\n\t}\n\n\tprivate async _closeGroups(groups: vscode.TabGroup[], preserverFoucs?: boolean): Promise<boolean> {\n\t\tconst extHostGroupIds: number[] = [];\n\t\tfor (const group of groups) {\n\t\t\tconst extHostGroup = this._findExtHostTabGroupFromApi(group);\n\t\t\tif (!extHostGroup) {\n\t\t\t\tthrow new Error('Group close: Invalid group not found!');\n\t\t\t}\n\t\t\textHostGroupIds.push(extHostGroup.groupId);\n\t\t}\n\t\treturn this._proxy.$closeGroup(extHostGroupIds, preserverFoucs);\n\t}\n}\n\n//#region Utils\nfunction isTabGroup(obj: unknown): obj is vscode.TabGroup {\n\tconst tabGroup = obj as vscode.TabGroup;\n\tif (tabGroup.tabs !== undefined) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n//#endregion\n"]}