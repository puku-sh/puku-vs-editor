{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/common/extHostMcp.ts","vs/workbench/api/common/extHostMcp.ts"],"names":[],"mappings":"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","file":"extHostMcp.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as vscode from 'vscode';\nimport { DeferredPromise, raceCancellationError, Sequencer, timeout } from '../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../base/common/errors.js';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { AUTH_SCOPE_SEPARATOR, fetchAuthorizationServerMetadata, fetchResourceMetadata, getDefaultMetadataForUrl, IAuthorizationProtectedResourceMetadata, IAuthorizationServerMetadata, parseWWWAuthenticateHeader, scopesMatch } from '../../../base/common/oauth.js';\nimport { SSEParser } from '../../../base/common/sseParser.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { vArray, vNumber, vObj, vObjAny, vOptionalProp, vString } from '../../../base/common/validation.js';\nimport { ConfigurationTarget } from '../../../platform/configuration/common/configuration.js';\nimport { ExtensionIdentifier, IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { canLog, ILogService, LogLevel } from '../../../platform/log/common/log.js';\nimport product from '../../../platform/product/common/product.js';\nimport { StorageScope } from '../../../platform/storage/common/storage.js';\nimport { extensionPrefixedIdentifier, McpCollectionDefinition, McpConnectionState, McpServerDefinition, McpServerLaunch, McpServerStaticMetadata, McpServerStaticToolAvailability, McpServerTransportHTTP, McpServerTransportType, UserInteractionRequiredError } from '../../contrib/mcp/common/mcpTypes.js';\nimport { MCP } from '../../contrib/mcp/common/modelContextProtocol.js';\nimport { checkProposedApiEnabled, isProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { ExtHostMcpShape, IMcpAuthenticationDetails, IStartMcpOptions, MainContext, MainThreadMcpShape } from './extHost.protocol.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport * as Convert from './extHostTypeConverters.js';\nimport { McpHttpServerDefinition, McpStdioServerDefinition, McpToolAvailability } from './extHostTypes.js';\nimport { IExtHostVariableResolverProvider } from './extHostVariableResolverService.js';\nimport { IExtHostWorkspace } from './extHostWorkspace.js';\n\nexport const IExtHostMpcService = createDecorator<IExtHostMpcService>('IExtHostMpcService');\n\nexport interface IExtHostMpcService extends ExtHostMcpShape {\n\tregisterMcpConfigurationProvider(extension: IExtensionDescription, id: string, provider: vscode.McpServerDefinitionProvider): IDisposable;\n}\n\nconst serverDataValidation = vObj({\n\tlabel: vString(),\n\tversion: vOptionalProp(vString()),\n\tmetadata: vOptionalProp(vObj({\n\t\tcapabilities: vOptionalProp(vObjAny()),\n\t\tserverInfo: vOptionalProp(vObjAny()),\n\t\ttools: vOptionalProp(vArray(vObj({\n\t\t\tavailability: vNumber(),\n\t\t\tdefinition: vObjAny(),\n\t\t}))),\n\t})),\n\tauthentication: vOptionalProp(vObj({\n\t\tproviderId: vString(),\n\t\tscopes: vArray(vString()),\n\t}))\n});\n\n// Can be validated with:\n// declare const _serverDataValidationTest: vscode.McpStdioServerDefinition | vscode.McpHttpServerDefinition;\n// const _serverDataValidationProd: ValidatorType<typeof serverDataValidation> = _serverDataValidationTest;\n\nexport class ExtHostMcpService extends Disposable implements IExtHostMpcService {\n\tprotected _proxy: MainThreadMcpShape;\n\tprivate readonly _initialProviderPromises = new Set<Promise<void>>();\n\tprotected readonly _sseEventSources = this._register(new DisposableMap<number, McpHTTPHandle>());\n\tprivate readonly _unresolvedMcpServers = new Map</* collectionId */ string, {\n\t\tprovider: vscode.McpServerDefinitionProvider;\n\t\tservers: vscode.McpServerDefinition[];\n\t}>();\n\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@ILogService protected readonly _logService: ILogService,\n\t\t@IExtHostInitDataService private readonly _extHostInitData: IExtHostInitDataService,\n\t\t@IExtHostWorkspace protected readonly _workspaceService: IExtHostWorkspace,\n\t\t@IExtHostVariableResolverProvider private readonly _variableResolver: IExtHostVariableResolverProvider,\n\t) {\n\t\tsuper();\n\t\tthis._proxy = extHostRpc.getProxy(MainContext.MainThreadMcp);\n\t}\n\n\t$startMcp(id: number, opts: IStartMcpOptions): void {\n\t\tthis._startMcp(id, McpServerLaunch.fromSerialized(opts.launch), opts.defaultCwd && URI.revive(opts.defaultCwd), opts.errorOnUserInteraction);\n\t}\n\n\tprotected _startMcp(id: number, launch: McpServerLaunch, _defaultCwd?: URI, errorOnUserInteraction?: boolean): void {\n\t\tif (launch.type === McpServerTransportType.HTTP) {\n\t\t\tthis._sseEventSources.set(id, new McpHTTPHandle(id, launch, this._proxy, this._logService, errorOnUserInteraction));\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error('not implemented');\n\t}\n\n\tasync $substituteVariables<T>(_workspaceFolder: UriComponents | undefined, value: T): Promise<T> {\n\t\tconst folderURI = URI.revive(_workspaceFolder);\n\t\tconst folder = folderURI && await this._workspaceService.resolveWorkspaceFolder(folderURI);\n\t\tconst variableResolver = await this._variableResolver.getResolver();\n\t\treturn variableResolver.resolveAsync(folder && {\n\t\t\turi: folder.uri,\n\t\t\tname: folder.name,\n\t\t\tindex: folder.index,\n\t\t}, value) as T;\n\t}\n\n\t$stopMcp(id: number): void {\n\t\tthis._sseEventSources.get(id)\n\t\t\t?.close()\n\t\t\t.then(() => this._didClose(id));\n\t}\n\n\tprivate _didClose(id: number) {\n\t\tthis._sseEventSources.deleteAndDispose(id);\n\t}\n\n\t$sendMessage(id: number, message: string): void {\n\t\tthis._sseEventSources.get(id)?.send(message);\n\t}\n\n\tasync $waitForInitialCollectionProviders(): Promise<void> {\n\t\tawait Promise.all(this._initialProviderPromises);\n\t}\n\n\tasync $resolveMcpLaunch(collectionId: string, label: string): Promise<McpServerLaunch.Serialized | undefined> {\n\t\tconst rec = this._unresolvedMcpServers.get(collectionId);\n\t\tif (!rec) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst server = rec.servers.find(s => s.label === label);\n\t\tif (!server) {\n\t\t\treturn;\n\t\t}\n\t\tif (!rec.provider.resolveMcpServerDefinition) {\n\t\t\treturn Convert.McpServerDefinition.from(server);\n\t\t}\n\n\t\tconst resolved = await rec.provider.resolveMcpServerDefinition(server, CancellationToken.None);\n\t\treturn resolved ? Convert.McpServerDefinition.from(resolved) : undefined;\n\t}\n\n\t/** {@link vscode.lm.registerMcpServerDefinitionProvider} */\n\tpublic registerMcpConfigurationProvider(extension: IExtensionDescription, id: string, provider: vscode.McpServerDefinitionProvider): IDisposable {\n\t\tconst store = new DisposableStore();\n\n\t\tconst metadata = extension.contributes?.mcpServerDefinitionProviders?.find(m => m.id === id);\n\t\tif (!metadata) {\n\t\t\tthrow new Error(`MCP configuration providers must be registered in the contributes.mcpServerDefinitionProviders array within your package.json, but \"${id}\" was not`);\n\t\t}\n\n\t\tconst mcp: McpCollectionDefinition.FromExtHost = {\n\t\t\tid: extensionPrefixedIdentifier(extension.identifier, id),\n\t\t\tisTrustedByDefault: true,\n\t\t\tlabel: metadata?.label ?? extension.displayName ?? extension.name,\n\t\t\tscope: StorageScope.WORKSPACE,\n\t\t\tcanResolveLaunch: typeof provider.resolveMcpServerDefinition === 'function',\n\t\t\textensionId: extension.identifier.value,\n\t\t\tconfigTarget: this._extHostInitData.remote.isRemote ? ConfigurationTarget.USER_REMOTE : ConfigurationTarget.USER,\n\t\t};\n\n\t\tconst update = async () => {\n\t\t\tconst list = await provider.provideMcpServerDefinitions(CancellationToken.None);\n\t\t\tthis._unresolvedMcpServers.set(mcp.id, { servers: list ?? [], provider });\n\n\t\t\tconst servers: McpServerDefinition.Serialized[] = [];\n\t\t\tfor (const item of list ?? []) {\n\t\t\t\tlet id = ExtensionIdentifier.toKey(extension.identifier) + '/' + item.label;\n\t\t\t\tif (servers.some(s => s.id === id)) {\n\t\t\t\t\tlet i = 2;\n\t\t\t\t\twhile (servers.some(s => s.id === id + i)) { i++; }\n\t\t\t\t\tid = id + i;\n\t\t\t\t}\n\n\t\t\t\tserverDataValidation.validateOrThrow(item);\n\t\t\t\tif ((item as vscode.McpHttpServerDefinition2).authentication) {\n\t\t\t\t\tcheckProposedApiEnabled(extension, 'mcpToolDefinitions');\n\t\t\t\t}\n\n\t\t\t\tlet staticMetadata: McpServerStaticMetadata | undefined;\n\t\t\t\tconst castAs2 = item as McpStdioServerDefinition | McpHttpServerDefinition;\n\t\t\t\tif (isProposedApiEnabled(extension, 'mcpToolDefinitions') && castAs2.metadata) {\n\t\t\t\t\tstaticMetadata = {\n\t\t\t\t\t\tcapabilities: castAs2.metadata.capabilities as MCP.ServerCapabilities,\n\t\t\t\t\t\tinstructions: castAs2.metadata.instructions,\n\t\t\t\t\t\tserverInfo: castAs2.metadata.serverInfo as MCP.Implementation,\n\t\t\t\t\t\ttools: castAs2.metadata.tools?.map(t => ({\n\t\t\t\t\t\t\tavailability: t.availability === McpToolAvailability.Dynamic ? McpServerStaticToolAvailability.Dynamic : McpServerStaticToolAvailability.Initial,\n\t\t\t\t\t\t\tdefinition: t.definition as MCP.Tool,\n\t\t\t\t\t\t})),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tservers.push({\n\t\t\t\t\tid,\n\t\t\t\t\tlabel: item.label,\n\t\t\t\t\tcacheNonce: item.version || '$$NONE',\n\t\t\t\t\tstaticMetadata,\n\t\t\t\t\tlaunch: Convert.McpServerDefinition.from(item),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._proxy.$upsertMcpCollection(mcp, servers);\n\t\t};\n\n\t\tstore.add(toDisposable(() => {\n\t\t\tthis._unresolvedMcpServers.delete(mcp.id);\n\t\t\tthis._proxy.$deleteMcpCollection(mcp.id);\n\t\t}));\n\n\t\tif (provider.onDidChangeMcpServerDefinitions) {\n\t\t\tstore.add(provider.onDidChangeMcpServerDefinitions(update));\n\t\t}\n\t\t// todo@connor4312: proposed API back-compat\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tif ((provider as any).onDidChangeServerDefinitions) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tstore.add((provider as any).onDidChangeServerDefinitions(update));\n\t\t}\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tif ((provider as any).onDidChange) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tstore.add((provider as any).onDidChange(update));\n\t\t}\n\n\t\tconst promise = new Promise<void>(resolve => {\n\t\t\tsetTimeout(() => update().finally(() => {\n\t\t\t\tthis._initialProviderPromises.delete(promise);\n\t\t\t\tresolve();\n\t\t\t}), 0);\n\t\t});\n\n\t\tthis._initialProviderPromises.add(promise);\n\n\t\treturn store;\n\t}\n}\n\nconst enum HttpMode {\n\tUnknown,\n\tHttp,\n\tSSE,\n}\n\ntype HttpModeT =\n\t| { value: HttpMode.Unknown }\n\t| { value: HttpMode.Http; sessionId: string | undefined }\n\t| { value: HttpMode.SSE; endpoint: string };\n\nconst MAX_FOLLOW_REDIRECTS = 5;\nconst REDIRECT_STATUS_CODES = [301, 302, 303, 307, 308];\n\n/**\n * Implementation of both MCP HTTP Streaming as well as legacy SSE.\n *\n * The first request will POST to the endpoint, assuming HTTP streaming. If the\n * server is legacy SSE, it should return some 4xx status in that case,\n * and we'll automatically fall back to SSE and res\n */\nexport class McpHTTPHandle extends Disposable {\n\tprivate readonly _requestSequencer = new Sequencer();\n\tprivate readonly _postEndpoint = new DeferredPromise<{ url: string; transport: McpServerTransportHTTP }>();\n\tprivate _mode: HttpModeT = { value: HttpMode.Unknown };\n\tprivate readonly _cts = new CancellationTokenSource();\n\tprivate readonly _abortCtrl = new AbortController();\n\tprivate _authMetadata?: {\n\t\tauthorizationServer: URI;\n\t\tserverMetadata: IAuthorizationServerMetadata;\n\t\tresourceMetadata?: IAuthorizationProtectedResourceMetadata;\n\t\tscopes?: string[];\n\t};\n\tprivate _didSendClose = false;\n\n\tconstructor(\n\t\tprivate readonly _id: number,\n\t\tprivate readonly _launch: McpServerTransportHTTP,\n\t\tprivate readonly _proxy: MainThreadMcpShape,\n\t\tprivate readonly _logService: ILogService,\n\t\tprivate readonly _errorOnUserInteraction?: boolean,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._abortCtrl.abort();\n\t\t\tthis._cts.dispose(true);\n\t\t}));\n\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Running });\n\t}\n\n\tasync send(message: string) {\n\t\ttry {\n\t\t\tif (this._mode.value === HttpMode.Unknown) {\n\t\t\t\tawait this._requestSequencer.queue(() => this._send(message));\n\t\t\t} else {\n\t\t\t\tawait this._send(message);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconst msg = `Error sending message to ${this._launch.uri}: ${String(err)}`;\n\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Error, message: msg });\n\t\t}\n\t}\n\n\tasync close() {\n\t\tif (this._mode.value === HttpMode.Http && this._mode.sessionId && !this._didSendClose) {\n\t\t\tthis._didSendClose = true;\n\t\t\ttry {\n\t\t\t\tawait this._closeSession(this._mode.sessionId);\n\t\t\t} catch {\n\t\t\t\t// ignored -- already logged\n\t\t\t}\n\t\t}\n\n\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Stopped });\n\t}\n\n\tprivate async _closeSession(sessionId: string) {\n\t\tconst headers: Record<string, string> = {\n\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t'Mcp-Session-Id': sessionId,\n\t\t};\n\n\t\tawait this._addAuthHeader(headers);\n\n\t\t// no fetch with retry here -- don't try to auth if we get an auth failure\n\t\tawait this._fetch(\n\t\t\tthis._launch.uri.toString(true),\n\t\t\t{\n\t\t\t\tmethod: 'DELETE',\n\t\t\t\theaders,\n\t\t\t},\n\t\t);\n\t}\n\n\tprivate _send(message: string) {\n\t\tif (this._mode.value === HttpMode.SSE) {\n\t\t\treturn this._sendLegacySSE(this._mode.endpoint, message);\n\t\t} else {\n\t\t\treturn this._sendStreamableHttp(message, this._mode.value === HttpMode.Http ? this._mode.sessionId : undefined);\n\t\t}\n\t}\n\n\t/**\n\t * Sends a streamable-HTTP request.\n\t * 1. Posts to the endpoint\n\t * 2. Updates internal state as needed. Falls back to SSE if appropriate.\n\t * 3. If the response body is empty, JSON, or a JSON stream, handle it appropriately.\n\t */\n\tprivate async _sendStreamableHttp(message: string, sessionId: string | undefined) {\n\t\tconst asBytes = new TextEncoder().encode(message) as Uint8Array<ArrayBuffer>;\n\t\tconst headers: Record<string, string> = {\n\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t'Content-Type': 'application/json',\n\t\t\t'Content-Length': String(asBytes.length),\n\t\t\tAccept: 'text/event-stream, application/json',\n\t\t};\n\t\tif (sessionId) {\n\t\t\theaders['Mcp-Session-Id'] = sessionId;\n\t\t}\n\t\tawait this._addAuthHeader(headers);\n\n\t\tconst res = await this._fetchWithAuthRetry(\n\t\t\tthis._launch.uri.toString(true),\n\t\t\t{\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders,\n\t\t\t\tbody: asBytes,\n\t\t\t},\n\t\t\theaders\n\t\t);\n\n\t\tconst wasUnknown = this._mode.value === HttpMode.Unknown;\n\n\t\t// Mcp-Session-Id is the strongest signal that we're in streamable HTTP mode\n\t\tconst nextSessionId = res.headers.get('Mcp-Session-Id');\n\t\tif (nextSessionId) {\n\t\t\tthis._mode = { value: HttpMode.Http, sessionId: nextSessionId };\n\t\t}\n\n\t\tif (this._mode.value === HttpMode.Unknown &&\n\t\t\t// We care about 4xx errors...\n\t\t\tres.status >= 400 && res.status < 500\n\t\t\t// ...except for auth errors\n\t\t\t&& !isAuthStatusCode(res.status)\n\t\t) {\n\t\t\tthis._log(LogLevel.Info, `${res.status} status sending message to ${this._launch.uri}, will attempt to fall back to legacy SSE`);\n\t\t\tthis._sseFallbackWithMessage(message);\n\t\t\treturn;\n\t\t}\n\n\t\tif (res.status >= 300) {\n\t\t\t// \"When a client receives HTTP 404 in response to a request containing an Mcp-Session-Id, it MUST start a new session by sending a new InitializeRequest without a session ID attached\"\n\t\t\t// Though this says only 404, some servers send 400s as well, including their example\n\t\t\t// https://github.com/modelcontextprotocol/typescript-sdk/issues/389\n\t\t\tconst retryWithSessionId = this._mode.value === HttpMode.Http && !!this._mode.sessionId && (res.status === 400 || res.status === 404);\n\n\t\t\tthis._proxy.$onDidChangeState(this._id, {\n\t\t\t\tstate: McpConnectionState.Kind.Error,\n\t\t\t\tmessage: `${res.status} status sending message to ${this._launch.uri}: ${await this._getErrText(res)}` + (retryWithSessionId ? `; will retry with new session ID` : ''),\n\t\t\t\tshouldRetry: retryWithSessionId,\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._mode.value === HttpMode.Unknown) {\n\t\t\tthis._mode = { value: HttpMode.Http, sessionId: undefined };\n\t\t}\n\t\tif (wasUnknown) {\n\t\t\tthis._attachStreamableBackchannel();\n\t\t}\n\n\t\tawait this._handleSuccessfulStreamableHttp(res, message);\n\t}\n\n\tprivate async _sseFallbackWithMessage(message: string) {\n\t\tconst endpoint = await this._attachSSE();\n\t\tif (endpoint) {\n\t\t\tthis._mode = { value: HttpMode.SSE, endpoint };\n\t\t\tawait this._sendLegacySSE(endpoint, message);\n\t\t}\n\t}\n\n\tprivate async _populateAuthMetadata(mcpUrl: string, originalResponse: CommonResponse): Promise<void> {\n\t\t// If there is a resource_metadata challenge, use that to get the oauth server. This is done in 2 steps.\n\t\t// First, extract the resource_metada challenge from the WWW-Authenticate header (if available)\n\t\tconst { resourceMetadataChallenge, scopesChallenge: scopesChallengeFromHeader } = this._parseWWWAuthenticateHeader(originalResponse);\n\t\t// Second, fetch the resource metadata either from the challenge URL or from well-known URIs\n\t\tlet serverMetadataUrl: string | undefined;\n\t\tlet resource: IAuthorizationProtectedResourceMetadata | undefined;\n\t\tlet scopesChallenge = scopesChallengeFromHeader;\n\t\ttry {\n\t\t\tconst resourceMetadata = await fetchResourceMetadata(mcpUrl, resourceMetadataChallenge, {\n\t\t\t\tsameOriginHeaders: {\n\t\t\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t\t\t'MCP-Protocol-Version': MCP.LATEST_PROTOCOL_VERSION\n\t\t\t\t},\n\t\t\t\tfetch: (url, init) => this._fetch(url, init)\n\t\t\t});\n\t\t\t// TODO:@TylerLeonhardt support multiple authorization servers\n\t\t\t// Consider using one that has an auth provider first, over the dynamic flow\n\t\t\tserverMetadataUrl = resourceMetadata.authorization_servers?.[0];\n\t\t\tthis._log(LogLevel.Debug, `Using auth server metadata url: ${serverMetadataUrl}`);\n\t\t\tscopesChallenge ??= resourceMetadata.scopes_supported;\n\t\t\tresource = resourceMetadata;\n\t\t} catch (e) {\n\t\t\tthis._log(LogLevel.Debug, `Could not fetch resource metadata: ${String(e)}`);\n\t\t}\n\n\t\tconst baseUrl = new URL(originalResponse.url).origin;\n\n\t\t// If we are not given a resource_metadata, see if the well-known server metadata is available\n\t\t// on the base url.\n\t\tlet additionalHeaders: Record<string, string> = {};\n\t\tif (!serverMetadataUrl) {\n\t\t\tserverMetadataUrl = baseUrl;\n\t\t\t// Maintain the launch headers when talking to the MCP origin.\n\t\t\tadditionalHeaders = {\n\t\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t\t'MCP-Protocol-Version': MCP.LATEST_PROTOCOL_VERSION\n\t\t\t};\n\t\t}\n\t\ttry {\n\t\t\tthis._log(LogLevel.Debug, `Fetching auth server metadata for: ${serverMetadataUrl} ...`);\n\t\t\tconst serverMetadataResponse = await fetchAuthorizationServerMetadata(serverMetadataUrl, {\n\t\t\t\tadditionalHeaders,\n\t\t\t\tfetch: (url, init) => this._fetch(url, init)\n\t\t\t});\n\t\t\tthis._log(LogLevel.Info, 'Populated auth metadata');\n\t\t\tthis._authMetadata = {\n\t\t\t\tauthorizationServer: URI.parse(serverMetadataUrl),\n\t\t\t\tserverMetadata: serverMetadataResponse,\n\t\t\t\tresourceMetadata: resource,\n\t\t\t\tscopes: scopesChallenge\n\t\t\t};\n\t\t\treturn;\n\t\t} catch (e) {\n\t\t\tthis._log(LogLevel.Warning, `Error populating auth server metadata for ${serverMetadataUrl}: ${String(e)}`);\n\t\t}\n\n\t\t// If there's no well-known server metadata, then use the default values based off of the url.\n\t\tconst defaultMetadata = getDefaultMetadataForUrl(new URL(baseUrl));\n\t\tthis._authMetadata = {\n\t\t\tauthorizationServer: URI.parse(baseUrl),\n\t\t\tserverMetadata: defaultMetadata,\n\t\t\tresourceMetadata: resource,\n\t\t\tscopes: scopesChallenge\n\t\t};\n\t\tthis._log(LogLevel.Info, 'Using default auth metadata');\n\t}\n\n\n\tprivate async _handleSuccessfulStreamableHttp(res: CommonResponse, message: string) {\n\t\tif (res.status === 202) {\n\t\t\treturn; // no body\n\t\t}\n\n\t\tconst contentType = res.headers.get('Content-Type')?.toLowerCase() || '';\n\t\tif (contentType.startsWith('text/event-stream')) {\n\t\t\tconst parser = new SSEParser(event => {\n\t\t\t\tif (event.type === 'message') {\n\t\t\t\t\tthis._proxy.$onDidReceiveMessage(this._id, event.data);\n\t\t\t\t} else if (event.type === 'endpoint') {\n\t\t\t\t\t// An SSE server that didn't correctly return a 4xx status when we POSTed\n\t\t\t\t\tthis._log(LogLevel.Warning, `Received SSE endpoint from a POST to ${this._launch.uri}, will fall back to legacy SSE`);\n\t\t\t\t\tthis._sseFallbackWithMessage(message);\n\t\t\t\t\tthrow new CancellationError(); // just to end the SSE stream\n\t\t\t\t}\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tawait this._doSSE(parser, res);\n\t\t\t} catch (err) {\n\t\t\t\tthis._log(LogLevel.Warning, `Error reading SSE stream: ${String(err)}`);\n\t\t\t}\n\t\t} else if (contentType.startsWith('application/json')) {\n\t\t\tthis._proxy.$onDidReceiveMessage(this._id, await res.text());\n\t\t} else {\n\t\t\tconst responseBody = await res.text();\n\t\t\tif (isJSON(responseBody)) { // try to read as JSON even if the server didn't set the content type\n\t\t\t\tthis._proxy.$onDidReceiveMessage(this._id, responseBody);\n\t\t\t} else {\n\t\t\t\tthis._log(LogLevel.Warning, `Unexpected ${res.status} response for request: ${responseBody}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Attaches the SSE backchannel that streamable HTTP servers can use\n\t * for async notifications. This is a \"MAY\" support, so if the server gives\n\t * us a 4xx code, we'll stop trying to connect..\n\t */\n\tprivate async _attachStreamableBackchannel() {\n\t\tlet lastEventId: string | undefined;\n\t\tlet canReconnectAt: number | undefined;\n\t\tfor (let retry = 0; !this._store.isDisposed; retry++) {\n\t\t\tif (canReconnectAt !== undefined) {\n\t\t\t\tawait timeout(Math.max(0, canReconnectAt - Date.now()), this._cts.token);\n\t\t\t\tcanReconnectAt = undefined;\n\t\t\t} else {\n\t\t\t\tawait timeout(Math.min(retry * 1000, 30_000), this._cts.token);\n\t\t\t}\n\n\t\t\tlet res: CommonResponse;\n\t\t\ttry {\n\t\t\t\tconst headers: Record<string, string> = {\n\t\t\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t\t\t'Accept': 'text/event-stream',\n\t\t\t\t};\n\t\t\t\tawait this._addAuthHeader(headers);\n\n\t\t\t\tif (this._mode.value === HttpMode.Http && this._mode.sessionId !== undefined) {\n\t\t\t\t\theaders['Mcp-Session-Id'] = this._mode.sessionId;\n\t\t\t\t}\n\t\t\t\tif (lastEventId) {\n\t\t\t\t\theaders['Last-Event-ID'] = lastEventId;\n\t\t\t\t}\n\n\t\t\t\tres = await this._fetchWithAuthRetry(\n\t\t\t\t\tthis._launch.uri.toString(true),\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod: 'GET',\n\t\t\t\t\t\theaders,\n\t\t\t\t\t},\n\t\t\t\t\theaders\n\t\t\t\t);\n\t\t\t} catch (e) {\n\t\t\t\tthis._log(LogLevel.Info, `Error connecting to ${this._launch.uri} for async notifications, will retry`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (res.status >= 400) {\n\t\t\t\tthis._log(LogLevel.Debug, `${res.status} status connecting to ${this._launch.uri} for async notifications; they will be disabled: ${await this._getErrText(res)}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Only reset the retry counter if we definitely get an event stream to avoid\n\t\t\t// spamming servers that (incorrectly) don't return one from this endpoint.\n\t\t\tif (res.headers.get('content-type')?.toLowerCase().includes('text/event-stream')) {\n\t\t\t\tretry = 0;\n\t\t\t}\n\n\t\t\tconst parser = new SSEParser(event => {\n\t\t\t\tif (event.retry) {\n\t\t\t\t\tcanReconnectAt = Date.now() + event.retry;\n\t\t\t\t}\n\t\t\t\tif (event.type === 'message' && event.data) {\n\t\t\t\t\tthis._proxy.$onDidReceiveMessage(this._id, event.data);\n\t\t\t\t}\n\t\t\t\tif (event.id) {\n\t\t\t\t\tlastEventId = event.id;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tawait this._doSSE(parser, res);\n\t\t\t} catch (e) {\n\t\t\t\tthis._log(LogLevel.Info, `Error reading from async stream, we will reconnect: ${e}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Starts a legacy SSE attachment, where the SSE response is the session lifetime.\n\t * Unlike `_attachStreamableBackchannel`, this fails the server if it disconnects.\n\t */\n\tprivate async _attachSSE(): Promise<string | undefined> {\n\t\tconst postEndpoint = new DeferredPromise<string>();\n\t\tconst headers: Record<string, string> = {\n\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t'Accept': 'text/event-stream',\n\t\t};\n\t\tawait this._addAuthHeader(headers);\n\n\t\tlet res: CommonResponse;\n\t\ttry {\n\t\t\tres = await this._fetchWithAuthRetry(\n\t\t\t\tthis._launch.uri.toString(true),\n\t\t\t\t{\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t\theaders,\n\t\t\t\t},\n\t\t\t\theaders\n\t\t\t);\n\t\t\tif (res.status >= 300) {\n\t\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Error, message: `${res.status} status connecting to ${this._launch.uri} as SSE: ${await this._getErrText(res)}` });\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Error, message: `Error connecting to ${this._launch.uri} as SSE: ${e}` });\n\t\t\treturn;\n\t\t}\n\n\t\tconst parser = new SSEParser(event => {\n\t\t\tif (event.type === 'message') {\n\t\t\t\tthis._proxy.$onDidReceiveMessage(this._id, event.data);\n\t\t\t} else if (event.type === 'endpoint') {\n\t\t\t\tpostEndpoint.complete(new URL(event.data, this._launch.uri.toString(true)).toString());\n\t\t\t}\n\t\t});\n\n\t\tthis._register(toDisposable(() => postEndpoint.cancel()));\n\t\tthis._doSSE(parser, res).catch(err => {\n\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Error, message: `Error reading SSE stream: ${String(err)}` });\n\t\t});\n\n\t\treturn postEndpoint.p;\n\t}\n\n\t/**\n\t * Sends a legacy SSE message to the server. The response is always empty and\n\t * is otherwise received in {@link _attachSSE}'s loop.\n\t */\n\tprivate async _sendLegacySSE(url: string, message: string) {\n\t\tconst asBytes = new TextEncoder().encode(message) as Uint8Array<ArrayBuffer>;\n\t\tconst headers: Record<string, string> = {\n\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t'Content-Type': 'application/json',\n\t\t\t'Content-Length': String(asBytes.length),\n\t\t};\n\t\tawait this._addAuthHeader(headers);\n\t\tconst res = await this._fetch(url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders,\n\t\t\tbody: asBytes,\n\t\t});\n\n\t\tif (res.status >= 300) {\n\t\t\tthis._log(LogLevel.Warning, `${res.status} status sending message to ${this._postEndpoint}: ${await this._getErrText(res)}`);\n\t\t}\n\t}\n\n\t/** Generic handle to pipe a response into an SSE parser. */\n\tprivate async _doSSE(parser: SSEParser, res: CommonResponse) {\n\t\tif (!res.body) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst reader = res.body.getReader();\n\t\tlet chunk: ReadableStreamReadResult<Uint8Array>;\n\t\tdo {\n\t\t\ttry {\n\t\t\t\tchunk = await raceCancellationError(reader.read(), this._cts.token);\n\t\t\t} catch (err) {\n\t\t\t\treader.cancel();\n\t\t\t\tif (this._store.isDisposed) {\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (chunk.value) {\n\t\t\t\tparser.feed(chunk.value);\n\t\t\t}\n\t\t} while (!chunk.done);\n\t}\n\n\tprivate async _addAuthHeader(headers: Record<string, string>, forceNewRegistration?: boolean) {\n\t\tif (this._authMetadata) {\n\t\t\ttry {\n\t\t\t\tconst authDetails: IMcpAuthenticationDetails = {\n\t\t\t\t\tauthorizationServer: this._authMetadata.authorizationServer.toJSON(),\n\t\t\t\t\tauthorizationServerMetadata: this._authMetadata.serverMetadata,\n\t\t\t\t\tresourceMetadata: this._authMetadata.resourceMetadata,\n\t\t\t\t\tscopes: this._authMetadata.scopes\n\t\t\t\t};\n\t\t\t\tconst token = await this._proxy.$getTokenFromServerMetadata(\n\t\t\t\t\tthis._id,\n\t\t\t\t\tauthDetails,\n\t\t\t\t\t{\n\t\t\t\t\t\terrorOnUserInteraction: this._errorOnUserInteraction,\n\t\t\t\t\t\tforceNewRegistration\n\t\t\t\t\t});\n\t\t\t\tif (token) {\n\t\t\t\t\theaders['Authorization'] = `Bearer ${token}`;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (UserInteractionRequiredError.is(e)) {\n\t\t\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Stopped, reason: 'needs-user-interaction' });\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t}\n\t\t\t\tthis._log(LogLevel.Warning, `Error getting token from server metadata: ${String(e)}`);\n\t\t\t}\n\t\t}\n\t\tif (this._launch.authentication) {\n\t\t\ttry {\n\t\t\t\tthis._log(LogLevel.Debug, `Using provided authentication config: providerId=${this._launch.authentication.providerId}, scopes=${this._launch.authentication.scopes.join(', ')}`);\n\t\t\t\tconst token = await this._proxy.$getTokenForProviderId(\n\t\t\t\t\tthis._id,\n\t\t\t\t\tthis._launch.authentication.providerId,\n\t\t\t\t\tthis._launch.authentication.scopes,\n\t\t\t\t\t{\n\t\t\t\t\t\terrorOnUserInteraction: this._errorOnUserInteraction,\n\t\t\t\t\t\tforceNewRegistration\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tif (token) {\n\t\t\t\t\theaders['Authorization'] = `Bearer ${token}`;\n\t\t\t\t\tthis._log(LogLevel.Info, 'Successfully obtained token from provided authentication config');\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (UserInteractionRequiredError.is(e)) {\n\t\t\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Stopped, reason: 'needs-user-interaction' });\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t}\n\t\t\t\tthis._log(LogLevel.Warning, `Error getting token from provided authentication config: ${String(e)}`);\n\t\t\t}\n\t\t}\n\t\treturn headers;\n\t}\n\n\tprivate _log(level: LogLevel, message: string) {\n\t\tif (!this._store.isDisposed) {\n\t\t\tthis._proxy.$onDidPublishLog(this._id, level, message);\n\t\t}\n\t}\n\n\tprivate _parseWWWAuthenticateHeader(response: CommonResponse): { resourceMetadataChallenge: string | undefined; scopesChallenge: string[] | undefined } {\n\t\tlet resourceMetadataChallenge: string | undefined;\n\t\tlet scopesChallenge: string[] | undefined;\n\t\tif (response.headers.has('WWW-Authenticate')) {\n\t\t\tconst authHeader = response.headers.get('WWW-Authenticate')!;\n\t\t\tconst challenges = parseWWWAuthenticateHeader(authHeader);\n\t\t\tfor (const challenge of challenges) {\n\t\t\t\tif (challenge.scheme === 'Bearer') {\n\t\t\t\t\tif (!resourceMetadataChallenge && challenge.params['resource_metadata']) {\n\t\t\t\t\t\tresourceMetadataChallenge = challenge.params['resource_metadata'];\n\t\t\t\t\t\tthis._log(LogLevel.Debug, `Found resource_metadata challenge in WWW-Authenticate header: ${resourceMetadataChallenge}`);\n\t\t\t\t\t}\n\t\t\t\t\tif (!scopesChallenge && challenge.params['scope']) {\n\t\t\t\t\t\tconst scopes = challenge.params['scope'].split(AUTH_SCOPE_SEPARATOR).filter(s => s.trim().length);\n\t\t\t\t\t\tif (scopes.length) {\n\t\t\t\t\t\t\tthis._log(LogLevel.Debug, `Found scope challenge in WWW-Authenticate header: ${challenge.params['scope']}`);\n\t\t\t\t\t\t\tscopesChallenge = scopes;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (resourceMetadataChallenge && scopesChallenge) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { resourceMetadataChallenge, scopesChallenge };\n\t}\n\n\tprivate async _getErrText(res: CommonResponse) {\n\t\ttry {\n\t\t\treturn await res.text();\n\t\t} catch {\n\t\t\treturn res.statusText;\n\t\t}\n\t}\n\n\t/**\n\t * Helper method to perform fetch with authentication retry logic.\n\t * If the initial request returns an auth error and we don't have auth metadata,\n\t * it will populate the auth metadata and retry once.\n\t * If we already have auth metadata, check if the scopes changed and update them.\n\t */\n\tprivate async _fetchWithAuthRetry(mcpUrl: string, init: MinimalRequestInit, headers: Record<string, string>): Promise<CommonResponse> {\n\t\tconst doFetch = () => this._fetch(mcpUrl, init);\n\n\t\tlet res = await doFetch();\n\t\tif (isAuthStatusCode(res.status)) {\n\t\t\tif (!this._authMetadata) {\n\t\t\t\tawait this._populateAuthMetadata(mcpUrl, res);\n\t\t\t\tawait this._addAuthHeader(headers);\n\t\t\t\tif (headers['Authorization']) {\n\t\t\t\t\t// Update the headers in the init object\n\t\t\t\t\tinit.headers = headers;\n\t\t\t\t\tres = await doFetch();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We have auth metadata, but got an auth error. Check if the scopes changed.\n\t\t\t\tconst { scopesChallenge } = this._parseWWWAuthenticateHeader(res);\n\t\t\t\tif (!scopesMatch(scopesChallenge, this._authMetadata.scopes)) {\n\t\t\t\t\tthis._log(LogLevel.Debug, `Scopes changed from ${JSON.stringify(this._authMetadata.scopes)} to ${JSON.stringify(scopesChallenge)}, updating and retrying`);\n\t\t\t\t\tthis._authMetadata.scopes = scopesChallenge;\n\t\t\t\t\tawait this._addAuthHeader(headers);\n\t\t\t\t\tif (headers['Authorization']) {\n\t\t\t\t\t\t// Update the headers in the init object\n\t\t\t\t\t\tinit.headers = headers;\n\t\t\t\t\t\tres = await doFetch();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If we have an Authorization header and still get an auth error, we should retry with a new auth registration\n\t\tif (headers['Authorization'] && isAuthStatusCode(res.status)) {\n\t\t\tawait this._addAuthHeader(headers, true);\n\t\t\tres = await doFetch();\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate async _fetch(url: string, init: MinimalRequestInit): Promise<CommonResponse> {\n\t\tinit.headers['user-agent'] = `${product.nameLong}/${product.version}`;\n\n\t\tif (canLog(this._logService.getLevel(), LogLevel.Trace)) {\n\t\t\tconst traceObj: any = { ...init, headers: { ...init.headers } };\n\t\t\tif (traceObj.body) {\n\t\t\t\ttraceObj.body = new TextDecoder().decode(traceObj.body);\n\t\t\t}\n\t\t\tif (traceObj.headers?.Authorization) {\n\t\t\t\ttraceObj.headers.Authorization = '***'; // don't log the auth header\n\t\t\t}\n\t\t\tthis._log(LogLevel.Trace, `Fetching ${url} with options: ${JSON.stringify(traceObj)}`);\n\t\t}\n\n\t\tlet currentUrl = url;\n\t\tlet response!: CommonResponse;\n\t\tfor (let redirectCount = 0; redirectCount < MAX_FOLLOW_REDIRECTS; redirectCount++) {\n\t\t\tresponse = await this._fetchInternal(currentUrl, {\n\t\t\t\t...init,\n\t\t\t\tsignal: this._abortCtrl.signal,\n\t\t\t\tredirect: 'manual'\n\t\t\t});\n\n\t\t\t// Check for redirect status codes (301, 302, 303, 307, 308)\n\t\t\tif (!REDIRECT_STATUS_CODES.includes(response.status)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst location = response.headers.get('location');\n\t\t\tif (!location) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst nextUrl = new URL(location, currentUrl).toString();\n\t\t\tthis._log(LogLevel.Trace, `Redirect (${response.status}) from ${currentUrl} to ${nextUrl}`);\n\t\t\tcurrentUrl = nextUrl;\n\t\t\t// Per fetch spec, for 303 always use GET, keep method unless original was POST and 301/302, then GET.\n\t\t\tif (response.status === 303 || ((response.status === 301 || response.status === 302) && init.method === 'POST')) {\n\t\t\t\tinit.method = 'GET';\n\t\t\t\tdelete init.body;\n\t\t\t}\n\t\t}\n\n\t\tif (canLog(this._logService.getLevel(), LogLevel.Trace)) {\n\t\t\tconst headers: Record<string, string> = {};\n\t\t\tresponse.headers.forEach((value, key) => { headers[key] = value; });\n\t\t\tthis._log(LogLevel.Trace, `Fetched ${currentUrl}: ${JSON.stringify({\n\t\t\t\tstatus: response.status,\n\t\t\t\theaders: headers,\n\t\t\t})}`);\n\t\t}\n\n\t\treturn response;\n\t}\n\n\tprotected _fetchInternal(url: string, init?: CommonRequestInit): Promise<CommonResponse> {\n\t\treturn fetch(url, init);\n\t}\n}\n\ninterface MinimalRequestInit {\n\tmethod: string;\n\theaders: Record<string, string>;\n\tbody?: Uint8Array<ArrayBuffer>;\n}\n\nexport interface CommonRequestInit extends MinimalRequestInit {\n\tsignal?: AbortSignal;\n\tredirect?: RequestRedirect;\n}\n\nexport interface CommonResponse {\n\tstatus: number;\n\tstatusText: string;\n\theaders: Headers;\n\tbody?: ReadableStream | null;\n\turl: string;\n\tjson(): Promise<any>;\n\ttext(): Promise<string>;\n}\n\nfunction isJSON(str: string): boolean {\n\ttry {\n\t\tJSON.parse(str);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nfunction isAuthStatusCode(status: number): boolean {\n\treturn status === 401 || status === 403;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as vscode from 'vscode';\nimport { DeferredPromise, raceCancellationError, Sequencer, timeout } from '../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../base/common/errors.js';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { AUTH_SCOPE_SEPARATOR, fetchAuthorizationServerMetadata, fetchResourceMetadata, getDefaultMetadataForUrl, IAuthorizationProtectedResourceMetadata, IAuthorizationServerMetadata, parseWWWAuthenticateHeader, scopesMatch } from '../../../base/common/oauth.js';\nimport { SSEParser } from '../../../base/common/sseParser.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { vArray, vNumber, vObj, vObjAny, vOptionalProp, vString } from '../../../base/common/validation.js';\nimport { ConfigurationTarget } from '../../../platform/configuration/common/configuration.js';\nimport { ExtensionIdentifier, IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { canLog, ILogService, LogLevel } from '../../../platform/log/common/log.js';\nimport product from '../../../platform/product/common/product.js';\nimport { StorageScope } from '../../../platform/storage/common/storage.js';\nimport { extensionPrefixedIdentifier, McpCollectionDefinition, McpConnectionState, McpServerDefinition, McpServerLaunch, McpServerStaticMetadata, McpServerStaticToolAvailability, McpServerTransportHTTP, McpServerTransportType, UserInteractionRequiredError } from '../../contrib/mcp/common/mcpTypes.js';\nimport { MCP } from '../../contrib/mcp/common/modelContextProtocol.js';\nimport { checkProposedApiEnabled, isProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { ExtHostMcpShape, IMcpAuthenticationDetails, IStartMcpOptions, MainContext, MainThreadMcpShape } from './extHost.protocol.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport * as Convert from './extHostTypeConverters.js';\nimport { McpHttpServerDefinition, McpStdioServerDefinition, McpToolAvailability } from './extHostTypes.js';\nimport { IExtHostVariableResolverProvider } from './extHostVariableResolverService.js';\nimport { IExtHostWorkspace } from './extHostWorkspace.js';\n\nexport const IExtHostMpcService = createDecorator<IExtHostMpcService>('IExtHostMpcService');\n\nexport interface IExtHostMpcService extends ExtHostMcpShape {\n\tregisterMcpConfigurationProvider(extension: IExtensionDescription, id: string, provider: vscode.McpServerDefinitionProvider): IDisposable;\n}\n\nconst serverDataValidation = vObj({\n\tlabel: vString(),\n\tversion: vOptionalProp(vString()),\n\tmetadata: vOptionalProp(vObj({\n\t\tcapabilities: vOptionalProp(vObjAny()),\n\t\tserverInfo: vOptionalProp(vObjAny()),\n\t\ttools: vOptionalProp(vArray(vObj({\n\t\t\tavailability: vNumber(),\n\t\t\tdefinition: vObjAny(),\n\t\t}))),\n\t})),\n\tauthentication: vOptionalProp(vObj({\n\t\tproviderId: vString(),\n\t\tscopes: vArray(vString()),\n\t}))\n});\n\n// Can be validated with:\n// declare const _serverDataValidationTest: vscode.McpStdioServerDefinition | vscode.McpHttpServerDefinition;\n// const _serverDataValidationProd: ValidatorType<typeof serverDataValidation> = _serverDataValidationTest;\n\nexport class ExtHostMcpService extends Disposable implements IExtHostMpcService {\n\tprotected _proxy: MainThreadMcpShape;\n\tprivate readonly _initialProviderPromises = new Set<Promise<void>>();\n\tprotected readonly _sseEventSources = this._register(new DisposableMap<number, McpHTTPHandle>());\n\tprivate readonly _unresolvedMcpServers = new Map</* collectionId */ string, {\n\t\tprovider: vscode.McpServerDefinitionProvider;\n\t\tservers: vscode.McpServerDefinition[];\n\t}>();\n\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@ILogService protected readonly _logService: ILogService,\n\t\t@IExtHostInitDataService private readonly _extHostInitData: IExtHostInitDataService,\n\t\t@IExtHostWorkspace protected readonly _workspaceService: IExtHostWorkspace,\n\t\t@IExtHostVariableResolverProvider private readonly _variableResolver: IExtHostVariableResolverProvider,\n\t) {\n\t\tsuper();\n\t\tthis._proxy = extHostRpc.getProxy(MainContext.MainThreadMcp);\n\t}\n\n\t$startMcp(id: number, opts: IStartMcpOptions): void {\n\t\tthis._startMcp(id, McpServerLaunch.fromSerialized(opts.launch), opts.defaultCwd && URI.revive(opts.defaultCwd), opts.errorOnUserInteraction);\n\t}\n\n\tprotected _startMcp(id: number, launch: McpServerLaunch, _defaultCwd?: URI, errorOnUserInteraction?: boolean): void {\n\t\tif (launch.type === McpServerTransportType.HTTP) {\n\t\t\tthis._sseEventSources.set(id, new McpHTTPHandle(id, launch, this._proxy, this._logService, errorOnUserInteraction));\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error('not implemented');\n\t}\n\n\tasync $substituteVariables<T>(_workspaceFolder: UriComponents | undefined, value: T): Promise<T> {\n\t\tconst folderURI = URI.revive(_workspaceFolder);\n\t\tconst folder = folderURI && await this._workspaceService.resolveWorkspaceFolder(folderURI);\n\t\tconst variableResolver = await this._variableResolver.getResolver();\n\t\treturn variableResolver.resolveAsync(folder && {\n\t\t\turi: folder.uri,\n\t\t\tname: folder.name,\n\t\t\tindex: folder.index,\n\t\t}, value) as T;\n\t}\n\n\t$stopMcp(id: number): void {\n\t\tthis._sseEventSources.get(id)\n\t\t\t?.close()\n\t\t\t.then(() => this._didClose(id));\n\t}\n\n\tprivate _didClose(id: number) {\n\t\tthis._sseEventSources.deleteAndDispose(id);\n\t}\n\n\t$sendMessage(id: number, message: string): void {\n\t\tthis._sseEventSources.get(id)?.send(message);\n\t}\n\n\tasync $waitForInitialCollectionProviders(): Promise<void> {\n\t\tawait Promise.all(this._initialProviderPromises);\n\t}\n\n\tasync $resolveMcpLaunch(collectionId: string, label: string): Promise<McpServerLaunch.Serialized | undefined> {\n\t\tconst rec = this._unresolvedMcpServers.get(collectionId);\n\t\tif (!rec) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst server = rec.servers.find(s => s.label === label);\n\t\tif (!server) {\n\t\t\treturn;\n\t\t}\n\t\tif (!rec.provider.resolveMcpServerDefinition) {\n\t\t\treturn Convert.McpServerDefinition.from(server);\n\t\t}\n\n\t\tconst resolved = await rec.provider.resolveMcpServerDefinition(server, CancellationToken.None);\n\t\treturn resolved ? Convert.McpServerDefinition.from(resolved) : undefined;\n\t}\n\n\t/** {@link vscode.lm.registerMcpServerDefinitionProvider} */\n\tpublic registerMcpConfigurationProvider(extension: IExtensionDescription, id: string, provider: vscode.McpServerDefinitionProvider): IDisposable {\n\t\tconst store = new DisposableStore();\n\n\t\tconst metadata = extension.contributes?.mcpServerDefinitionProviders?.find(m => m.id === id);\n\t\tif (!metadata) {\n\t\t\tthrow new Error(`MCP configuration providers must be registered in the contributes.mcpServerDefinitionProviders array within your package.json, but \"${id}\" was not`);\n\t\t}\n\n\t\tconst mcp: McpCollectionDefinition.FromExtHost = {\n\t\t\tid: extensionPrefixedIdentifier(extension.identifier, id),\n\t\t\tisTrustedByDefault: true,\n\t\t\tlabel: metadata?.label ?? extension.displayName ?? extension.name,\n\t\t\tscope: StorageScope.WORKSPACE,\n\t\t\tcanResolveLaunch: typeof provider.resolveMcpServerDefinition === 'function',\n\t\t\textensionId: extension.identifier.value,\n\t\t\tconfigTarget: this._extHostInitData.remote.isRemote ? ConfigurationTarget.USER_REMOTE : ConfigurationTarget.USER,\n\t\t};\n\n\t\tconst update = async () => {\n\t\t\tconst list = await provider.provideMcpServerDefinitions(CancellationToken.None);\n\t\t\tthis._unresolvedMcpServers.set(mcp.id, { servers: list ?? [], provider });\n\n\t\t\tconst servers: McpServerDefinition.Serialized[] = [];\n\t\t\tfor (const item of list ?? []) {\n\t\t\t\tlet id = ExtensionIdentifier.toKey(extension.identifier) + '/' + item.label;\n\t\t\t\tif (servers.some(s => s.id === id)) {\n\t\t\t\t\tlet i = 2;\n\t\t\t\t\twhile (servers.some(s => s.id === id + i)) { i++; }\n\t\t\t\t\tid = id + i;\n\t\t\t\t}\n\n\t\t\t\tserverDataValidation.validateOrThrow(item);\n\t\t\t\tif ((item as vscode.McpHttpServerDefinition2).authentication) {\n\t\t\t\t\tcheckProposedApiEnabled(extension, 'mcpToolDefinitions');\n\t\t\t\t}\n\n\t\t\t\tlet staticMetadata: McpServerStaticMetadata | undefined;\n\t\t\t\tconst castAs2 = item as McpStdioServerDefinition | McpHttpServerDefinition;\n\t\t\t\tif (isProposedApiEnabled(extension, 'mcpToolDefinitions') && castAs2.metadata) {\n\t\t\t\t\tstaticMetadata = {\n\t\t\t\t\t\tcapabilities: castAs2.metadata.capabilities as MCP.ServerCapabilities,\n\t\t\t\t\t\tinstructions: castAs2.metadata.instructions,\n\t\t\t\t\t\tserverInfo: castAs2.metadata.serverInfo as MCP.Implementation,\n\t\t\t\t\t\ttools: castAs2.metadata.tools?.map(t => ({\n\t\t\t\t\t\t\tavailability: t.availability === McpToolAvailability.Dynamic ? McpServerStaticToolAvailability.Dynamic : McpServerStaticToolAvailability.Initial,\n\t\t\t\t\t\t\tdefinition: t.definition as MCP.Tool,\n\t\t\t\t\t\t})),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tservers.push({\n\t\t\t\t\tid,\n\t\t\t\t\tlabel: item.label,\n\t\t\t\t\tcacheNonce: item.version || '$$NONE',\n\t\t\t\t\tstaticMetadata,\n\t\t\t\t\tlaunch: Convert.McpServerDefinition.from(item),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._proxy.$upsertMcpCollection(mcp, servers);\n\t\t};\n\n\t\tstore.add(toDisposable(() => {\n\t\t\tthis._unresolvedMcpServers.delete(mcp.id);\n\t\t\tthis._proxy.$deleteMcpCollection(mcp.id);\n\t\t}));\n\n\t\tif (provider.onDidChangeMcpServerDefinitions) {\n\t\t\tstore.add(provider.onDidChangeMcpServerDefinitions(update));\n\t\t}\n\t\t// todo@connor4312: proposed API back-compat\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tif ((provider as any).onDidChangeServerDefinitions) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tstore.add((provider as any).onDidChangeServerDefinitions(update));\n\t\t}\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tif ((provider as any).onDidChange) {\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tstore.add((provider as any).onDidChange(update));\n\t\t}\n\n\t\tconst promise = new Promise<void>(resolve => {\n\t\t\tsetTimeout(() => update().finally(() => {\n\t\t\t\tthis._initialProviderPromises.delete(promise);\n\t\t\t\tresolve();\n\t\t\t}), 0);\n\t\t});\n\n\t\tthis._initialProviderPromises.add(promise);\n\n\t\treturn store;\n\t}\n}\n\nconst enum HttpMode {\n\tUnknown,\n\tHttp,\n\tSSE,\n}\n\ntype HttpModeT =\n\t| { value: HttpMode.Unknown }\n\t| { value: HttpMode.Http; sessionId: string | undefined }\n\t| { value: HttpMode.SSE; endpoint: string };\n\nconst MAX_FOLLOW_REDIRECTS = 5;\nconst REDIRECT_STATUS_CODES = [301, 302, 303, 307, 308];\n\n/**\n * Implementation of both MCP HTTP Streaming as well as legacy SSE.\n *\n * The first request will POST to the endpoint, assuming HTTP streaming. If the\n * server is legacy SSE, it should return some 4xx status in that case,\n * and we'll automatically fall back to SSE and res\n */\nexport class McpHTTPHandle extends Disposable {\n\tprivate readonly _requestSequencer = new Sequencer();\n\tprivate readonly _postEndpoint = new DeferredPromise<{ url: string; transport: McpServerTransportHTTP }>();\n\tprivate _mode: HttpModeT = { value: HttpMode.Unknown };\n\tprivate readonly _cts = new CancellationTokenSource();\n\tprivate readonly _abortCtrl = new AbortController();\n\tprivate _authMetadata?: {\n\t\tauthorizationServer: URI;\n\t\tserverMetadata: IAuthorizationServerMetadata;\n\t\tresourceMetadata?: IAuthorizationProtectedResourceMetadata;\n\t\tscopes?: string[];\n\t};\n\tprivate _didSendClose = false;\n\n\tconstructor(\n\t\tprivate readonly _id: number,\n\t\tprivate readonly _launch: McpServerTransportHTTP,\n\t\tprivate readonly _proxy: MainThreadMcpShape,\n\t\tprivate readonly _logService: ILogService,\n\t\tprivate readonly _errorOnUserInteraction?: boolean,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._abortCtrl.abort();\n\t\t\tthis._cts.dispose(true);\n\t\t}));\n\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Running });\n\t}\n\n\tasync send(message: string) {\n\t\ttry {\n\t\t\tif (this._mode.value === HttpMode.Unknown) {\n\t\t\t\tawait this._requestSequencer.queue(() => this._send(message));\n\t\t\t} else {\n\t\t\t\tawait this._send(message);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconst msg = `Error sending message to ${this._launch.uri}: ${String(err)}`;\n\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Error, message: msg });\n\t\t}\n\t}\n\n\tasync close() {\n\t\tif (this._mode.value === HttpMode.Http && this._mode.sessionId && !this._didSendClose) {\n\t\t\tthis._didSendClose = true;\n\t\t\ttry {\n\t\t\t\tawait this._closeSession(this._mode.sessionId);\n\t\t\t} catch {\n\t\t\t\t// ignored -- already logged\n\t\t\t}\n\t\t}\n\n\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Stopped });\n\t}\n\n\tprivate async _closeSession(sessionId: string) {\n\t\tconst headers: Record<string, string> = {\n\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t'Mcp-Session-Id': sessionId,\n\t\t};\n\n\t\tawait this._addAuthHeader(headers);\n\n\t\t// no fetch with retry here -- don't try to auth if we get an auth failure\n\t\tawait this._fetch(\n\t\t\tthis._launch.uri.toString(true),\n\t\t\t{\n\t\t\t\tmethod: 'DELETE',\n\t\t\t\theaders,\n\t\t\t},\n\t\t);\n\t}\n\n\tprivate _send(message: string) {\n\t\tif (this._mode.value === HttpMode.SSE) {\n\t\t\treturn this._sendLegacySSE(this._mode.endpoint, message);\n\t\t} else {\n\t\t\treturn this._sendStreamableHttp(message, this._mode.value === HttpMode.Http ? this._mode.sessionId : undefined);\n\t\t}\n\t}\n\n\t/**\n\t * Sends a streamable-HTTP request.\n\t * 1. Posts to the endpoint\n\t * 2. Updates internal state as needed. Falls back to SSE if appropriate.\n\t * 3. If the response body is empty, JSON, or a JSON stream, handle it appropriately.\n\t */\n\tprivate async _sendStreamableHttp(message: string, sessionId: string | undefined) {\n\t\tconst asBytes = new TextEncoder().encode(message) as Uint8Array<ArrayBuffer>;\n\t\tconst headers: Record<string, string> = {\n\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t'Content-Type': 'application/json',\n\t\t\t'Content-Length': String(asBytes.length),\n\t\t\tAccept: 'text/event-stream, application/json',\n\t\t};\n\t\tif (sessionId) {\n\t\t\theaders['Mcp-Session-Id'] = sessionId;\n\t\t}\n\t\tawait this._addAuthHeader(headers);\n\n\t\tconst res = await this._fetchWithAuthRetry(\n\t\t\tthis._launch.uri.toString(true),\n\t\t\t{\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders,\n\t\t\t\tbody: asBytes,\n\t\t\t},\n\t\t\theaders\n\t\t);\n\n\t\tconst wasUnknown = this._mode.value === HttpMode.Unknown;\n\n\t\t// Mcp-Session-Id is the strongest signal that we're in streamable HTTP mode\n\t\tconst nextSessionId = res.headers.get('Mcp-Session-Id');\n\t\tif (nextSessionId) {\n\t\t\tthis._mode = { value: HttpMode.Http, sessionId: nextSessionId };\n\t\t}\n\n\t\tif (this._mode.value === HttpMode.Unknown &&\n\t\t\t// We care about 4xx errors...\n\t\t\tres.status >= 400 && res.status < 500\n\t\t\t// ...except for auth errors\n\t\t\t&& !isAuthStatusCode(res.status)\n\t\t) {\n\t\t\tthis._log(LogLevel.Info, `${res.status} status sending message to ${this._launch.uri}, will attempt to fall back to legacy SSE`);\n\t\t\tthis._sseFallbackWithMessage(message);\n\t\t\treturn;\n\t\t}\n\n\t\tif (res.status >= 300) {\n\t\t\t// \"When a client receives HTTP 404 in response to a request containing an Mcp-Session-Id, it MUST start a new session by sending a new InitializeRequest without a session ID attached\"\n\t\t\t// Though this says only 404, some servers send 400s as well, including their example\n\t\t\t// https://github.com/modelcontextprotocol/typescript-sdk/issues/389\n\t\t\tconst retryWithSessionId = this._mode.value === HttpMode.Http && !!this._mode.sessionId && (res.status === 400 || res.status === 404);\n\n\t\t\tthis._proxy.$onDidChangeState(this._id, {\n\t\t\t\tstate: McpConnectionState.Kind.Error,\n\t\t\t\tmessage: `${res.status} status sending message to ${this._launch.uri}: ${await this._getErrText(res)}` + (retryWithSessionId ? `; will retry with new session ID` : ''),\n\t\t\t\tshouldRetry: retryWithSessionId,\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._mode.value === HttpMode.Unknown) {\n\t\t\tthis._mode = { value: HttpMode.Http, sessionId: undefined };\n\t\t}\n\t\tif (wasUnknown) {\n\t\t\tthis._attachStreamableBackchannel();\n\t\t}\n\n\t\tawait this._handleSuccessfulStreamableHttp(res, message);\n\t}\n\n\tprivate async _sseFallbackWithMessage(message: string) {\n\t\tconst endpoint = await this._attachSSE();\n\t\tif (endpoint) {\n\t\t\tthis._mode = { value: HttpMode.SSE, endpoint };\n\t\t\tawait this._sendLegacySSE(endpoint, message);\n\t\t}\n\t}\n\n\tprivate async _populateAuthMetadata(mcpUrl: string, originalResponse: CommonResponse): Promise<void> {\n\t\t// If there is a resource_metadata challenge, use that to get the oauth server. This is done in 2 steps.\n\t\t// First, extract the resource_metada challenge from the WWW-Authenticate header (if available)\n\t\tconst { resourceMetadataChallenge, scopesChallenge: scopesChallengeFromHeader } = this._parseWWWAuthenticateHeader(originalResponse);\n\t\t// Second, fetch the resource metadata either from the challenge URL or from well-known URIs\n\t\tlet serverMetadataUrl: string | undefined;\n\t\tlet resource: IAuthorizationProtectedResourceMetadata | undefined;\n\t\tlet scopesChallenge = scopesChallengeFromHeader;\n\t\ttry {\n\t\t\tconst resourceMetadata = await fetchResourceMetadata(mcpUrl, resourceMetadataChallenge, {\n\t\t\t\tsameOriginHeaders: {\n\t\t\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t\t\t'MCP-Protocol-Version': MCP.LATEST_PROTOCOL_VERSION\n\t\t\t\t},\n\t\t\t\tfetch: (url, init) => this._fetch(url, init)\n\t\t\t});\n\t\t\t// TODO:@TylerLeonhardt support multiple authorization servers\n\t\t\t// Consider using one that has an auth provider first, over the dynamic flow\n\t\t\tserverMetadataUrl = resourceMetadata.authorization_servers?.[0];\n\t\t\tthis._log(LogLevel.Debug, `Using auth server metadata url: ${serverMetadataUrl}`);\n\t\t\tscopesChallenge ??= resourceMetadata.scopes_supported;\n\t\t\tresource = resourceMetadata;\n\t\t} catch (e) {\n\t\t\tthis._log(LogLevel.Debug, `Could not fetch resource metadata: ${String(e)}`);\n\t\t}\n\n\t\tconst baseUrl = new URL(originalResponse.url).origin;\n\n\t\t// If we are not given a resource_metadata, see if the well-known server metadata is available\n\t\t// on the base url.\n\t\tlet additionalHeaders: Record<string, string> = {};\n\t\tif (!serverMetadataUrl) {\n\t\t\tserverMetadataUrl = baseUrl;\n\t\t\t// Maintain the launch headers when talking to the MCP origin.\n\t\t\tadditionalHeaders = {\n\t\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t\t'MCP-Protocol-Version': MCP.LATEST_PROTOCOL_VERSION\n\t\t\t};\n\t\t}\n\t\ttry {\n\t\t\tthis._log(LogLevel.Debug, `Fetching auth server metadata for: ${serverMetadataUrl} ...`);\n\t\t\tconst serverMetadataResponse = await fetchAuthorizationServerMetadata(serverMetadataUrl, {\n\t\t\t\tadditionalHeaders,\n\t\t\t\tfetch: (url, init) => this._fetch(url, init)\n\t\t\t});\n\t\t\tthis._log(LogLevel.Info, 'Populated auth metadata');\n\t\t\tthis._authMetadata = {\n\t\t\t\tauthorizationServer: URI.parse(serverMetadataUrl),\n\t\t\t\tserverMetadata: serverMetadataResponse,\n\t\t\t\tresourceMetadata: resource,\n\t\t\t\tscopes: scopesChallenge\n\t\t\t};\n\t\t\treturn;\n\t\t} catch (e) {\n\t\t\tthis._log(LogLevel.Warning, `Error populating auth server metadata for ${serverMetadataUrl}: ${String(e)}`);\n\t\t}\n\n\t\t// If there's no well-known server metadata, then use the default values based off of the url.\n\t\tconst defaultMetadata = getDefaultMetadataForUrl(new URL(baseUrl));\n\t\tthis._authMetadata = {\n\t\t\tauthorizationServer: URI.parse(baseUrl),\n\t\t\tserverMetadata: defaultMetadata,\n\t\t\tresourceMetadata: resource,\n\t\t\tscopes: scopesChallenge\n\t\t};\n\t\tthis._log(LogLevel.Info, 'Using default auth metadata');\n\t}\n\n\n\tprivate async _handleSuccessfulStreamableHttp(res: CommonResponse, message: string) {\n\t\tif (res.status === 202) {\n\t\t\treturn; // no body\n\t\t}\n\n\t\tconst contentType = res.headers.get('Content-Type')?.toLowerCase() || '';\n\t\tif (contentType.startsWith('text/event-stream')) {\n\t\t\tconst parser = new SSEParser(event => {\n\t\t\t\tif (event.type === 'message') {\n\t\t\t\t\tthis._proxy.$onDidReceiveMessage(this._id, event.data);\n\t\t\t\t} else if (event.type === 'endpoint') {\n\t\t\t\t\t// An SSE server that didn't correctly return a 4xx status when we POSTed\n\t\t\t\t\tthis._log(LogLevel.Warning, `Received SSE endpoint from a POST to ${this._launch.uri}, will fall back to legacy SSE`);\n\t\t\t\t\tthis._sseFallbackWithMessage(message);\n\t\t\t\t\tthrow new CancellationError(); // just to end the SSE stream\n\t\t\t\t}\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tawait this._doSSE(parser, res);\n\t\t\t} catch (err) {\n\t\t\t\tthis._log(LogLevel.Warning, `Error reading SSE stream: ${String(err)}`);\n\t\t\t}\n\t\t} else if (contentType.startsWith('application/json')) {\n\t\t\tthis._proxy.$onDidReceiveMessage(this._id, await res.text());\n\t\t} else {\n\t\t\tconst responseBody = await res.text();\n\t\t\tif (isJSON(responseBody)) { // try to read as JSON even if the server didn't set the content type\n\t\t\t\tthis._proxy.$onDidReceiveMessage(this._id, responseBody);\n\t\t\t} else {\n\t\t\t\tthis._log(LogLevel.Warning, `Unexpected ${res.status} response for request: ${responseBody}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Attaches the SSE backchannel that streamable HTTP servers can use\n\t * for async notifications. This is a \"MAY\" support, so if the server gives\n\t * us a 4xx code, we'll stop trying to connect..\n\t */\n\tprivate async _attachStreamableBackchannel() {\n\t\tlet lastEventId: string | undefined;\n\t\tlet canReconnectAt: number | undefined;\n\t\tfor (let retry = 0; !this._store.isDisposed; retry++) {\n\t\t\tif (canReconnectAt !== undefined) {\n\t\t\t\tawait timeout(Math.max(0, canReconnectAt - Date.now()), this._cts.token);\n\t\t\t\tcanReconnectAt = undefined;\n\t\t\t} else {\n\t\t\t\tawait timeout(Math.min(retry * 1000, 30_000), this._cts.token);\n\t\t\t}\n\n\t\t\tlet res: CommonResponse;\n\t\t\ttry {\n\t\t\t\tconst headers: Record<string, string> = {\n\t\t\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t\t\t'Accept': 'text/event-stream',\n\t\t\t\t};\n\t\t\t\tawait this._addAuthHeader(headers);\n\n\t\t\t\tif (this._mode.value === HttpMode.Http && this._mode.sessionId !== undefined) {\n\t\t\t\t\theaders['Mcp-Session-Id'] = this._mode.sessionId;\n\t\t\t\t}\n\t\t\t\tif (lastEventId) {\n\t\t\t\t\theaders['Last-Event-ID'] = lastEventId;\n\t\t\t\t}\n\n\t\t\t\tres = await this._fetchWithAuthRetry(\n\t\t\t\t\tthis._launch.uri.toString(true),\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod: 'GET',\n\t\t\t\t\t\theaders,\n\t\t\t\t\t},\n\t\t\t\t\theaders\n\t\t\t\t);\n\t\t\t} catch (e) {\n\t\t\t\tthis._log(LogLevel.Info, `Error connecting to ${this._launch.uri} for async notifications, will retry`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (res.status >= 400) {\n\t\t\t\tthis._log(LogLevel.Debug, `${res.status} status connecting to ${this._launch.uri} for async notifications; they will be disabled: ${await this._getErrText(res)}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Only reset the retry counter if we definitely get an event stream to avoid\n\t\t\t// spamming servers that (incorrectly) don't return one from this endpoint.\n\t\t\tif (res.headers.get('content-type')?.toLowerCase().includes('text/event-stream')) {\n\t\t\t\tretry = 0;\n\t\t\t}\n\n\t\t\tconst parser = new SSEParser(event => {\n\t\t\t\tif (event.retry) {\n\t\t\t\t\tcanReconnectAt = Date.now() + event.retry;\n\t\t\t\t}\n\t\t\t\tif (event.type === 'message' && event.data) {\n\t\t\t\t\tthis._proxy.$onDidReceiveMessage(this._id, event.data);\n\t\t\t\t}\n\t\t\t\tif (event.id) {\n\t\t\t\t\tlastEventId = event.id;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tawait this._doSSE(parser, res);\n\t\t\t} catch (e) {\n\t\t\t\tthis._log(LogLevel.Info, `Error reading from async stream, we will reconnect: ${e}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Starts a legacy SSE attachment, where the SSE response is the session lifetime.\n\t * Unlike `_attachStreamableBackchannel`, this fails the server if it disconnects.\n\t */\n\tprivate async _attachSSE(): Promise<string | undefined> {\n\t\tconst postEndpoint = new DeferredPromise<string>();\n\t\tconst headers: Record<string, string> = {\n\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t'Accept': 'text/event-stream',\n\t\t};\n\t\tawait this._addAuthHeader(headers);\n\n\t\tlet res: CommonResponse;\n\t\ttry {\n\t\t\tres = await this._fetchWithAuthRetry(\n\t\t\t\tthis._launch.uri.toString(true),\n\t\t\t\t{\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t\theaders,\n\t\t\t\t},\n\t\t\t\theaders\n\t\t\t);\n\t\t\tif (res.status >= 300) {\n\t\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Error, message: `${res.status} status connecting to ${this._launch.uri} as SSE: ${await this._getErrText(res)}` });\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Error, message: `Error connecting to ${this._launch.uri} as SSE: ${e}` });\n\t\t\treturn;\n\t\t}\n\n\t\tconst parser = new SSEParser(event => {\n\t\t\tif (event.type === 'message') {\n\t\t\t\tthis._proxy.$onDidReceiveMessage(this._id, event.data);\n\t\t\t} else if (event.type === 'endpoint') {\n\t\t\t\tpostEndpoint.complete(new URL(event.data, this._launch.uri.toString(true)).toString());\n\t\t\t}\n\t\t});\n\n\t\tthis._register(toDisposable(() => postEndpoint.cancel()));\n\t\tthis._doSSE(parser, res).catch(err => {\n\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Error, message: `Error reading SSE stream: ${String(err)}` });\n\t\t});\n\n\t\treturn postEndpoint.p;\n\t}\n\n\t/**\n\t * Sends a legacy SSE message to the server. The response is always empty and\n\t * is otherwise received in {@link _attachSSE}'s loop.\n\t */\n\tprivate async _sendLegacySSE(url: string, message: string) {\n\t\tconst asBytes = new TextEncoder().encode(message) as Uint8Array<ArrayBuffer>;\n\t\tconst headers: Record<string, string> = {\n\t\t\t...Object.fromEntries(this._launch.headers),\n\t\t\t'Content-Type': 'application/json',\n\t\t\t'Content-Length': String(asBytes.length),\n\t\t};\n\t\tawait this._addAuthHeader(headers);\n\t\tconst res = await this._fetch(url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders,\n\t\t\tbody: asBytes,\n\t\t});\n\n\t\tif (res.status >= 300) {\n\t\t\tthis._log(LogLevel.Warning, `${res.status} status sending message to ${this._postEndpoint}: ${await this._getErrText(res)}`);\n\t\t}\n\t}\n\n\t/** Generic handle to pipe a response into an SSE parser. */\n\tprivate async _doSSE(parser: SSEParser, res: CommonResponse) {\n\t\tif (!res.body) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst reader = res.body.getReader();\n\t\tlet chunk: ReadableStreamReadResult<Uint8Array>;\n\t\tdo {\n\t\t\ttry {\n\t\t\t\tchunk = await raceCancellationError(reader.read(), this._cts.token);\n\t\t\t} catch (err) {\n\t\t\t\treader.cancel();\n\t\t\t\tif (this._store.isDisposed) {\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (chunk.value) {\n\t\t\t\tparser.feed(chunk.value);\n\t\t\t}\n\t\t} while (!chunk.done);\n\t}\n\n\tprivate async _addAuthHeader(headers: Record<string, string>, forceNewRegistration?: boolean) {\n\t\tif (this._authMetadata) {\n\t\t\ttry {\n\t\t\t\tconst authDetails: IMcpAuthenticationDetails = {\n\t\t\t\t\tauthorizationServer: this._authMetadata.authorizationServer.toJSON(),\n\t\t\t\t\tauthorizationServerMetadata: this._authMetadata.serverMetadata,\n\t\t\t\t\tresourceMetadata: this._authMetadata.resourceMetadata,\n\t\t\t\t\tscopes: this._authMetadata.scopes\n\t\t\t\t};\n\t\t\t\tconst token = await this._proxy.$getTokenFromServerMetadata(\n\t\t\t\t\tthis._id,\n\t\t\t\t\tauthDetails,\n\t\t\t\t\t{\n\t\t\t\t\t\terrorOnUserInteraction: this._errorOnUserInteraction,\n\t\t\t\t\t\tforceNewRegistration\n\t\t\t\t\t});\n\t\t\t\tif (token) {\n\t\t\t\t\theaders['Authorization'] = `Bearer ${token}`;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (UserInteractionRequiredError.is(e)) {\n\t\t\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Stopped, reason: 'needs-user-interaction' });\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t}\n\t\t\t\tthis._log(LogLevel.Warning, `Error getting token from server metadata: ${String(e)}`);\n\t\t\t}\n\t\t}\n\t\tif (this._launch.authentication) {\n\t\t\ttry {\n\t\t\t\tthis._log(LogLevel.Debug, `Using provided authentication config: providerId=${this._launch.authentication.providerId}, scopes=${this._launch.authentication.scopes.join(', ')}`);\n\t\t\t\tconst token = await this._proxy.$getTokenForProviderId(\n\t\t\t\t\tthis._id,\n\t\t\t\t\tthis._launch.authentication.providerId,\n\t\t\t\t\tthis._launch.authentication.scopes,\n\t\t\t\t\t{\n\t\t\t\t\t\terrorOnUserInteraction: this._errorOnUserInteraction,\n\t\t\t\t\t\tforceNewRegistration\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tif (token) {\n\t\t\t\t\theaders['Authorization'] = `Bearer ${token}`;\n\t\t\t\t\tthis._log(LogLevel.Info, 'Successfully obtained token from provided authentication config');\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (UserInteractionRequiredError.is(e)) {\n\t\t\t\t\tthis._proxy.$onDidChangeState(this._id, { state: McpConnectionState.Kind.Stopped, reason: 'needs-user-interaction' });\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t}\n\t\t\t\tthis._log(LogLevel.Warning, `Error getting token from provided authentication config: ${String(e)}`);\n\t\t\t}\n\t\t}\n\t\treturn headers;\n\t}\n\n\tprivate _log(level: LogLevel, message: string) {\n\t\tif (!this._store.isDisposed) {\n\t\t\tthis._proxy.$onDidPublishLog(this._id, level, message);\n\t\t}\n\t}\n\n\tprivate _parseWWWAuthenticateHeader(response: CommonResponse): { resourceMetadataChallenge: string | undefined; scopesChallenge: string[] | undefined } {\n\t\tlet resourceMetadataChallenge: string | undefined;\n\t\tlet scopesChallenge: string[] | undefined;\n\t\tif (response.headers.has('WWW-Authenticate')) {\n\t\t\tconst authHeader = response.headers.get('WWW-Authenticate')!;\n\t\t\tconst challenges = parseWWWAuthenticateHeader(authHeader);\n\t\t\tfor (const challenge of challenges) {\n\t\t\t\tif (challenge.scheme === 'Bearer') {\n\t\t\t\t\tif (!resourceMetadataChallenge && challenge.params['resource_metadata']) {\n\t\t\t\t\t\tresourceMetadataChallenge = challenge.params['resource_metadata'];\n\t\t\t\t\t\tthis._log(LogLevel.Debug, `Found resource_metadata challenge in WWW-Authenticate header: ${resourceMetadataChallenge}`);\n\t\t\t\t\t}\n\t\t\t\t\tif (!scopesChallenge && challenge.params['scope']) {\n\t\t\t\t\t\tconst scopes = challenge.params['scope'].split(AUTH_SCOPE_SEPARATOR).filter(s => s.trim().length);\n\t\t\t\t\t\tif (scopes.length) {\n\t\t\t\t\t\t\tthis._log(LogLevel.Debug, `Found scope challenge in WWW-Authenticate header: ${challenge.params['scope']}`);\n\t\t\t\t\t\t\tscopesChallenge = scopes;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (resourceMetadataChallenge && scopesChallenge) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { resourceMetadataChallenge, scopesChallenge };\n\t}\n\n\tprivate async _getErrText(res: CommonResponse) {\n\t\ttry {\n\t\t\treturn await res.text();\n\t\t} catch {\n\t\t\treturn res.statusText;\n\t\t}\n\t}\n\n\t/**\n\t * Helper method to perform fetch with authentication retry logic.\n\t * If the initial request returns an auth error and we don't have auth metadata,\n\t * it will populate the auth metadata and retry once.\n\t * If we already have auth metadata, check if the scopes changed and update them.\n\t */\n\tprivate async _fetchWithAuthRetry(mcpUrl: string, init: MinimalRequestInit, headers: Record<string, string>): Promise<CommonResponse> {\n\t\tconst doFetch = () => this._fetch(mcpUrl, init);\n\n\t\tlet res = await doFetch();\n\t\tif (isAuthStatusCode(res.status)) {\n\t\t\tif (!this._authMetadata) {\n\t\t\t\tawait this._populateAuthMetadata(mcpUrl, res);\n\t\t\t\tawait this._addAuthHeader(headers);\n\t\t\t\tif (headers['Authorization']) {\n\t\t\t\t\t// Update the headers in the init object\n\t\t\t\t\tinit.headers = headers;\n\t\t\t\t\tres = await doFetch();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We have auth metadata, but got an auth error. Check if the scopes changed.\n\t\t\t\tconst { scopesChallenge } = this._parseWWWAuthenticateHeader(res);\n\t\t\t\tif (!scopesMatch(scopesChallenge, this._authMetadata.scopes)) {\n\t\t\t\t\tthis._log(LogLevel.Debug, `Scopes changed from ${JSON.stringify(this._authMetadata.scopes)} to ${JSON.stringify(scopesChallenge)}, updating and retrying`);\n\t\t\t\t\tthis._authMetadata.scopes = scopesChallenge;\n\t\t\t\t\tawait this._addAuthHeader(headers);\n\t\t\t\t\tif (headers['Authorization']) {\n\t\t\t\t\t\t// Update the headers in the init object\n\t\t\t\t\t\tinit.headers = headers;\n\t\t\t\t\t\tres = await doFetch();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If we have an Authorization header and still get an auth error, we should retry with a new auth registration\n\t\tif (headers['Authorization'] && isAuthStatusCode(res.status)) {\n\t\t\tawait this._addAuthHeader(headers, true);\n\t\t\tres = await doFetch();\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate async _fetch(url: string, init: MinimalRequestInit): Promise<CommonResponse> {\n\t\tinit.headers['user-agent'] = `${product.nameLong}/${product.version}`;\n\n\t\tif (canLog(this._logService.getLevel(), LogLevel.Trace)) {\n\t\t\tconst traceObj: any = { ...init, headers: { ...init.headers } };\n\t\t\tif (traceObj.body) {\n\t\t\t\ttraceObj.body = new TextDecoder().decode(traceObj.body);\n\t\t\t}\n\t\t\tif (traceObj.headers?.Authorization) {\n\t\t\t\ttraceObj.headers.Authorization = '***'; // don't log the auth header\n\t\t\t}\n\t\t\tthis._log(LogLevel.Trace, `Fetching ${url} with options: ${JSON.stringify(traceObj)}`);\n\t\t}\n\n\t\tlet currentUrl = url;\n\t\tlet response!: CommonResponse;\n\t\tfor (let redirectCount = 0; redirectCount < MAX_FOLLOW_REDIRECTS; redirectCount++) {\n\t\t\tresponse = await this._fetchInternal(currentUrl, {\n\t\t\t\t...init,\n\t\t\t\tsignal: this._abortCtrl.signal,\n\t\t\t\tredirect: 'manual'\n\t\t\t});\n\n\t\t\t// Check for redirect status codes (301, 302, 303, 307, 308)\n\t\t\tif (!REDIRECT_STATUS_CODES.includes(response.status)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst location = response.headers.get('location');\n\t\t\tif (!location) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst nextUrl = new URL(location, currentUrl).toString();\n\t\t\tthis._log(LogLevel.Trace, `Redirect (${response.status}) from ${currentUrl} to ${nextUrl}`);\n\t\t\tcurrentUrl = nextUrl;\n\t\t\t// Per fetch spec, for 303 always use GET, keep method unless original was POST and 301/302, then GET.\n\t\t\tif (response.status === 303 || ((response.status === 301 || response.status === 302) && init.method === 'POST')) {\n\t\t\t\tinit.method = 'GET';\n\t\t\t\tdelete init.body;\n\t\t\t}\n\t\t}\n\n\t\tif (canLog(this._logService.getLevel(), LogLevel.Trace)) {\n\t\t\tconst headers: Record<string, string> = {};\n\t\t\tresponse.headers.forEach((value, key) => { headers[key] = value; });\n\t\t\tthis._log(LogLevel.Trace, `Fetched ${currentUrl}: ${JSON.stringify({\n\t\t\t\tstatus: response.status,\n\t\t\t\theaders: headers,\n\t\t\t})}`);\n\t\t}\n\n\t\treturn response;\n\t}\n\n\tprotected _fetchInternal(url: string, init?: CommonRequestInit): Promise<CommonResponse> {\n\t\treturn fetch(url, init);\n\t}\n}\n\ninterface MinimalRequestInit {\n\tmethod: string;\n\theaders: Record<string, string>;\n\tbody?: Uint8Array<ArrayBuffer>;\n}\n\nexport interface CommonRequestInit extends MinimalRequestInit {\n\tsignal?: AbortSignal;\n\tredirect?: RequestRedirect;\n}\n\nexport interface CommonResponse {\n\tstatus: number;\n\tstatusText: string;\n\theaders: Headers;\n\tbody?: ReadableStream | null;\n\turl: string;\n\tjson(): Promise<any>;\n\ttext(): Promise<string>;\n}\n\nfunction isJSON(str: string): boolean {\n\ttry {\n\t\tJSON.parse(str);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nfunction isAuthStatusCode(status: number): boolean {\n\treturn status === 401 || status === 403;\n}\n"]}