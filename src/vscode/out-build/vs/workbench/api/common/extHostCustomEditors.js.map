{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/common/extHostCustomEditors.ts","vs/workbench/api/common/extHostCustomEditors.ts"],"names":[],"mappings":"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","file":"extHostCustomEditors.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { joinPath } from '../../../base/common/resources.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { ExtHostDocuments } from './extHostDocuments.js';\nimport { IExtensionStoragePaths } from './extHostStoragePaths.js';\nimport * as typeConverters from './extHostTypeConverters.js';\nimport { ExtHostWebviews, shouldSerializeBuffersForPostMessage, toExtensionData } from './extHostWebview.js';\nimport { ExtHostWebviewPanels } from './extHostWebviewPanels.js';\nimport { EditorGroupColumn } from '../../services/editor/common/editorGroupColumn.js';\nimport type * as vscode from 'vscode';\nimport { Cache } from './cache.js';\nimport * as extHostProtocol from './extHost.protocol.js';\nimport * as extHostTypes from './extHostTypes.js';\n\n\nclass CustomDocumentStoreEntry {\n\n\tprivate _backupCounter = 1;\n\n\tconstructor(\n\t\tpublic readonly document: vscode.CustomDocument,\n\t\tprivate readonly _storagePath: URI | undefined,\n\t) { }\n\n\tprivate readonly _edits = new Cache<vscode.CustomDocumentEditEvent>('custom documents');\n\n\tprivate _backup?: vscode.CustomDocumentBackup;\n\n\taddEdit(item: vscode.CustomDocumentEditEvent): number {\n\t\treturn this._edits.add([item]);\n\t}\n\n\tasync undo(editId: number, isDirty: boolean): Promise<void> {\n\t\tawait this.getEdit(editId).undo();\n\t\tif (!isDirty) {\n\t\t\tthis.disposeBackup();\n\t\t}\n\t}\n\n\tasync redo(editId: number, isDirty: boolean): Promise<void> {\n\t\tawait this.getEdit(editId).redo();\n\t\tif (!isDirty) {\n\t\t\tthis.disposeBackup();\n\t\t}\n\t}\n\n\tdisposeEdits(editIds: number[]): void {\n\t\tfor (const id of editIds) {\n\t\t\tthis._edits.delete(id);\n\t\t}\n\t}\n\n\tgetNewBackupUri(): URI {\n\t\tif (!this._storagePath) {\n\t\t\tthrow new Error('Backup requires a valid storage path');\n\t\t}\n\t\tconst fileName = hashPath(this.document.uri) + (this._backupCounter++);\n\t\treturn joinPath(this._storagePath, fileName);\n\t}\n\n\tupdateBackup(backup: vscode.CustomDocumentBackup): void {\n\t\tthis._backup?.delete();\n\t\tthis._backup = backup;\n\t}\n\n\tdisposeBackup(): void {\n\t\tthis._backup?.delete();\n\t\tthis._backup = undefined;\n\t}\n\n\tprivate getEdit(editId: number): vscode.CustomDocumentEditEvent {\n\t\tconst edit = this._edits.get(editId, 0);\n\t\tif (!edit) {\n\t\t\tthrow new Error('No edit found');\n\t\t}\n\t\treturn edit;\n\t}\n}\n\nclass CustomDocumentStore {\n\tprivate readonly _documents = new Map<string, CustomDocumentStoreEntry>();\n\n\tpublic get(viewType: string, resource: vscode.Uri): CustomDocumentStoreEntry | undefined {\n\t\treturn this._documents.get(this.key(viewType, resource));\n\t}\n\n\tpublic add(viewType: string, document: vscode.CustomDocument, storagePath: URI | undefined): CustomDocumentStoreEntry {\n\t\tconst key = this.key(viewType, document.uri);\n\t\tif (this._documents.has(key)) {\n\t\t\tthrow new Error(`Document already exists for viewType:${viewType} resource:${document.uri}`);\n\t\t}\n\t\tconst entry = new CustomDocumentStoreEntry(document, storagePath);\n\t\tthis._documents.set(key, entry);\n\t\treturn entry;\n\t}\n\n\tpublic delete(viewType: string, document: vscode.CustomDocument) {\n\t\tconst key = this.key(viewType, document.uri);\n\t\tthis._documents.delete(key);\n\t}\n\n\tprivate key(viewType: string, resource: vscode.Uri): string {\n\t\treturn `${viewType}@@@${resource}`;\n\t}\n}\n\nconst enum CustomEditorType {\n\tText,\n\tCustom\n}\n\ntype ProviderEntry = {\n\treadonly extension: IExtensionDescription;\n\treadonly type: CustomEditorType.Text;\n\treadonly provider: vscode.CustomTextEditorProvider;\n} | {\n\treadonly extension: IExtensionDescription;\n\treadonly type: CustomEditorType.Custom;\n\treadonly provider: vscode.CustomReadonlyEditorProvider;\n};\n\nclass EditorProviderStore {\n\tprivate readonly _providers = new Map<string, ProviderEntry>();\n\n\tpublic addTextProvider(viewType: string, extension: IExtensionDescription, provider: vscode.CustomTextEditorProvider): vscode.Disposable {\n\t\treturn this.add(viewType, { type: CustomEditorType.Text, extension, provider });\n\t}\n\n\tpublic addCustomProvider(viewType: string, extension: IExtensionDescription, provider: vscode.CustomReadonlyEditorProvider): vscode.Disposable {\n\t\treturn this.add(viewType, { type: CustomEditorType.Custom, extension, provider });\n\t}\n\n\tpublic get(viewType: string): ProviderEntry | undefined {\n\t\treturn this._providers.get(viewType);\n\t}\n\n\tprivate add(viewType: string, entry: ProviderEntry): vscode.Disposable {\n\t\tif (this._providers.has(viewType)) {\n\t\t\tthrow new Error(`Provider for viewType:${viewType} already registered`);\n\t\t}\n\t\tthis._providers.set(viewType, entry);\n\t\treturn new extHostTypes.Disposable(() => this._providers.delete(viewType));\n\t}\n}\n\nexport class ExtHostCustomEditors implements extHostProtocol.ExtHostCustomEditorsShape {\n\n\tprivate readonly _proxy: extHostProtocol.MainThreadCustomEditorsShape;\n\n\tprivate readonly _editorProviders = new EditorProviderStore();\n\n\tprivate readonly _documents = new CustomDocumentStore();\n\n\tconstructor(\n\t\tmainContext: extHostProtocol.IMainContext,\n\t\tprivate readonly _extHostDocuments: ExtHostDocuments,\n\t\tprivate readonly _extensionStoragePaths: IExtensionStoragePaths | undefined,\n\t\tprivate readonly _extHostWebview: ExtHostWebviews,\n\t\tprivate readonly _extHostWebviewPanels: ExtHostWebviewPanels,\n\t) {\n\t\tthis._proxy = mainContext.getProxy(extHostProtocol.MainContext.MainThreadCustomEditors);\n\t}\n\n\tpublic registerCustomEditorProvider(\n\t\textension: IExtensionDescription,\n\t\tviewType: string,\n\t\tprovider: vscode.CustomReadonlyEditorProvider | vscode.CustomTextEditorProvider,\n\t\toptions: { webviewOptions?: vscode.WebviewPanelOptions; supportsMultipleEditorsPerDocument?: boolean },\n\t): vscode.Disposable {\n\t\tconst disposables = new DisposableStore();\n\t\tif (isCustomTextEditorProvider(provider)) {\n\t\t\tdisposables.add(this._editorProviders.addTextProvider(viewType, extension, provider));\n\t\t\tthis._proxy.$registerTextEditorProvider(toExtensionData(extension), viewType, options.webviewOptions || {}, {\n\t\t\t\tsupportsMove: !!provider.moveCustomTextEditor,\n\t\t\t}, shouldSerializeBuffersForPostMessage(extension));\n\t\t} else {\n\t\t\tdisposables.add(this._editorProviders.addCustomProvider(viewType, extension, provider));\n\n\t\t\tif (isCustomEditorProviderWithEditingCapability(provider)) {\n\t\t\t\tdisposables.add(provider.onDidChangeCustomDocument(e => {\n\t\t\t\t\tconst entry = this.getCustomDocumentEntry(viewType, e.document.uri);\n\t\t\t\t\tif (isEditEvent(e)) {\n\t\t\t\t\t\tconst editId = entry.addEdit(e);\n\t\t\t\t\t\tthis._proxy.$onDidEdit(e.document.uri, viewType, editId, e.label);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._proxy.$onContentChange(e.document.uri, viewType);\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tthis._proxy.$registerCustomEditorProvider(toExtensionData(extension), viewType, options.webviewOptions || {}, !!options.supportsMultipleEditorsPerDocument, shouldSerializeBuffersForPostMessage(extension));\n\t\t}\n\n\t\treturn extHostTypes.Disposable.from(\n\t\t\tdisposables,\n\t\t\tnew extHostTypes.Disposable(() => {\n\t\t\t\tthis._proxy.$unregisterEditorProvider(viewType);\n\t\t\t}));\n\t}\n\n\tasync $createCustomDocument(resource: UriComponents, viewType: string, backupId: string | undefined, untitledDocumentData: VSBuffer | undefined, cancellation: CancellationToken) {\n\t\tconst entry = this._editorProviders.get(viewType);\n\t\tif (!entry) {\n\t\t\tthrow new Error(`No provider found for '${viewType}'`);\n\t\t}\n\n\t\tif (entry.type !== CustomEditorType.Custom) {\n\t\t\tthrow new Error(`Invalid provide type for '${viewType}'`);\n\t\t}\n\n\t\tconst revivedResource = URI.revive(resource);\n\t\tconst document = await entry.provider.openCustomDocument(revivedResource, { backupId, untitledDocumentData: untitledDocumentData?.buffer }, cancellation);\n\n\t\tlet storageRoot: URI | undefined;\n\t\tif (isCustomEditorProviderWithEditingCapability(entry.provider) && this._extensionStoragePaths) {\n\t\t\tstorageRoot = this._extensionStoragePaths.workspaceValue(entry.extension) ?? this._extensionStoragePaths.globalValue(entry.extension);\n\t\t}\n\t\tthis._documents.add(viewType, document, storageRoot);\n\n\t\treturn { editable: isCustomEditorProviderWithEditingCapability(entry.provider) };\n\t}\n\n\tasync $disposeCustomDocument(resource: UriComponents, viewType: string): Promise<void> {\n\t\tconst entry = this._editorProviders.get(viewType);\n\t\tif (!entry) {\n\t\t\tthrow new Error(`No provider found for '${viewType}'`);\n\t\t}\n\n\t\tif (entry.type !== CustomEditorType.Custom) {\n\t\t\tthrow new Error(`Invalid provider type for '${viewType}'`);\n\t\t}\n\n\t\tconst revivedResource = URI.revive(resource);\n\t\tconst { document } = this.getCustomDocumentEntry(viewType, revivedResource);\n\t\tthis._documents.delete(viewType, document);\n\t\tdocument.dispose();\n\t}\n\n\tasync $resolveCustomEditor(\n\t\tresource: UriComponents,\n\t\thandle: extHostProtocol.WebviewHandle,\n\t\tviewType: string,\n\t\tinitData: {\n\t\t\ttitle: string;\n\t\t\tcontentOptions: extHostProtocol.IWebviewContentOptions;\n\t\t\toptions: extHostProtocol.IWebviewPanelOptions;\n\t\t\tactive: boolean;\n\t\t},\n\t\tposition: EditorGroupColumn,\n\t\tcancellation: CancellationToken,\n\t): Promise<void> {\n\t\tconst entry = this._editorProviders.get(viewType);\n\t\tif (!entry) {\n\t\t\tthrow new Error(`No provider found for '${viewType}'`);\n\t\t}\n\n\t\tconst viewColumn = typeConverters.ViewColumn.to(position);\n\n\t\tconst webview = this._extHostWebview.createNewWebview(handle, initData.contentOptions, entry.extension);\n\t\tconst panel = this._extHostWebviewPanels.createNewWebviewPanel(handle, viewType, initData.title, viewColumn, initData.options, webview, initData.active);\n\n\t\tconst revivedResource = URI.revive(resource);\n\n\t\tswitch (entry.type) {\n\t\t\tcase CustomEditorType.Custom: {\n\t\t\t\tconst { document } = this.getCustomDocumentEntry(viewType, revivedResource);\n\t\t\t\treturn entry.provider.resolveCustomEditor(document, panel, cancellation);\n\t\t\t}\n\t\t\tcase CustomEditorType.Text: {\n\t\t\t\tconst document = this._extHostDocuments.getDocument(revivedResource);\n\t\t\t\treturn entry.provider.resolveCustomTextEditor(document, panel, cancellation);\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('Unknown webview provider type');\n\t\t\t}\n\t\t}\n\t}\n\n\t$disposeEdits(resourceComponents: UriComponents, viewType: string, editIds: number[]): void {\n\t\tconst document = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\tdocument.disposeEdits(editIds);\n\t}\n\n\tasync $onMoveCustomEditor(handle: string, newResourceComponents: UriComponents, viewType: string): Promise<void> {\n\t\tconst entry = this._editorProviders.get(viewType);\n\t\tif (!entry) {\n\t\t\tthrow new Error(`No provider found for '${viewType}'`);\n\t\t}\n\n\t\tif (!(entry.provider as vscode.CustomTextEditorProvider).moveCustomTextEditor) {\n\t\t\tthrow new Error(`Provider does not implement move '${viewType}'`);\n\t\t}\n\n\t\tconst webview = this._extHostWebviewPanels.getWebviewPanel(handle);\n\t\tif (!webview) {\n\t\t\tthrow new Error(`No webview found`);\n\t\t}\n\n\t\tconst resource = URI.revive(newResourceComponents);\n\t\tconst document = this._extHostDocuments.getDocument(resource);\n\t\tawait (entry.provider as vscode.CustomTextEditorProvider).moveCustomTextEditor!(document, webview, CancellationToken.None);\n\t}\n\n\tasync $undo(resourceComponents: UriComponents, viewType: string, editId: number, isDirty: boolean): Promise<void> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\treturn entry.undo(editId, isDirty);\n\t}\n\n\tasync $redo(resourceComponents: UriComponents, viewType: string, editId: number, isDirty: boolean): Promise<void> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\treturn entry.redo(editId, isDirty);\n\t}\n\n\tasync $revert(resourceComponents: UriComponents, viewType: string, cancellation: CancellationToken): Promise<void> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\tconst provider = this.getCustomEditorProvider(viewType);\n\t\tawait provider.revertCustomDocument(entry.document, cancellation);\n\t\tentry.disposeBackup();\n\t}\n\n\tasync $onSave(resourceComponents: UriComponents, viewType: string, cancellation: CancellationToken): Promise<void> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\tconst provider = this.getCustomEditorProvider(viewType);\n\t\tawait provider.saveCustomDocument(entry.document, cancellation);\n\t\tentry.disposeBackup();\n\t}\n\n\tasync $onSaveAs(resourceComponents: UriComponents, viewType: string, targetResource: UriComponents, cancellation: CancellationToken): Promise<void> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\tconst provider = this.getCustomEditorProvider(viewType);\n\t\treturn provider.saveCustomDocumentAs(entry.document, URI.revive(targetResource), cancellation);\n\t}\n\n\tasync $backup(resourceComponents: UriComponents, viewType: string, cancellation: CancellationToken): Promise<string> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\tconst provider = this.getCustomEditorProvider(viewType);\n\n\t\tconst backup = await provider.backupCustomDocument(entry.document, {\n\t\t\tdestination: entry.getNewBackupUri(),\n\t\t}, cancellation);\n\t\tentry.updateBackup(backup);\n\t\treturn backup.id;\n\t}\n\n\tprivate getCustomDocumentEntry(viewType: string, resource: UriComponents): CustomDocumentStoreEntry {\n\t\tconst entry = this._documents.get(viewType, URI.revive(resource));\n\t\tif (!entry) {\n\t\t\tthrow new Error('No custom document found');\n\t\t}\n\t\treturn entry;\n\t}\n\n\tprivate getCustomEditorProvider(viewType: string): vscode.CustomEditorProvider {\n\t\tconst entry = this._editorProviders.get(viewType);\n\t\tconst provider = entry?.provider;\n\t\tif (!provider || !isCustomEditorProviderWithEditingCapability(provider)) {\n\t\t\tthrow new Error('Custom document is not editable');\n\t\t}\n\t\treturn provider;\n\t}\n}\n\nfunction isCustomEditorProviderWithEditingCapability(provider: vscode.CustomTextEditorProvider | vscode.CustomEditorProvider | vscode.CustomReadonlyEditorProvider): provider is vscode.CustomEditorProvider {\n\treturn !!(provider as vscode.CustomEditorProvider).onDidChangeCustomDocument;\n}\n\nfunction isCustomTextEditorProvider(provider: vscode.CustomReadonlyEditorProvider<vscode.CustomDocument> | vscode.CustomTextEditorProvider): provider is vscode.CustomTextEditorProvider {\n\treturn typeof (provider as vscode.CustomTextEditorProvider).resolveCustomTextEditor === 'function';\n}\n\nfunction isEditEvent(e: vscode.CustomDocumentContentChangeEvent | vscode.CustomDocumentEditEvent): e is vscode.CustomDocumentEditEvent {\n\treturn typeof (e as vscode.CustomDocumentEditEvent).undo === 'function'\n\t\t&& typeof (e as vscode.CustomDocumentEditEvent).redo === 'function';\n}\n\nfunction hashPath(resource: URI): string {\n\tconst str = resource.scheme === Schemas.file || resource.scheme === Schemas.untitled ? resource.fsPath : resource.toString();\n\treturn hash(str) + '';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { joinPath } from '../../../base/common/resources.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { ExtHostDocuments } from './extHostDocuments.js';\nimport { IExtensionStoragePaths } from './extHostStoragePaths.js';\nimport * as typeConverters from './extHostTypeConverters.js';\nimport { ExtHostWebviews, shouldSerializeBuffersForPostMessage, toExtensionData } from './extHostWebview.js';\nimport { ExtHostWebviewPanels } from './extHostWebviewPanels.js';\nimport { EditorGroupColumn } from '../../services/editor/common/editorGroupColumn.js';\nimport type * as vscode from 'vscode';\nimport { Cache } from './cache.js';\nimport * as extHostProtocol from './extHost.protocol.js';\nimport * as extHostTypes from './extHostTypes.js';\n\n\nclass CustomDocumentStoreEntry {\n\n\tprivate _backupCounter = 1;\n\n\tconstructor(\n\t\tpublic readonly document: vscode.CustomDocument,\n\t\tprivate readonly _storagePath: URI | undefined,\n\t) { }\n\n\tprivate readonly _edits = new Cache<vscode.CustomDocumentEditEvent>('custom documents');\n\n\tprivate _backup?: vscode.CustomDocumentBackup;\n\n\taddEdit(item: vscode.CustomDocumentEditEvent): number {\n\t\treturn this._edits.add([item]);\n\t}\n\n\tasync undo(editId: number, isDirty: boolean): Promise<void> {\n\t\tawait this.getEdit(editId).undo();\n\t\tif (!isDirty) {\n\t\t\tthis.disposeBackup();\n\t\t}\n\t}\n\n\tasync redo(editId: number, isDirty: boolean): Promise<void> {\n\t\tawait this.getEdit(editId).redo();\n\t\tif (!isDirty) {\n\t\t\tthis.disposeBackup();\n\t\t}\n\t}\n\n\tdisposeEdits(editIds: number[]): void {\n\t\tfor (const id of editIds) {\n\t\t\tthis._edits.delete(id);\n\t\t}\n\t}\n\n\tgetNewBackupUri(): URI {\n\t\tif (!this._storagePath) {\n\t\t\tthrow new Error('Backup requires a valid storage path');\n\t\t}\n\t\tconst fileName = hashPath(this.document.uri) + (this._backupCounter++);\n\t\treturn joinPath(this._storagePath, fileName);\n\t}\n\n\tupdateBackup(backup: vscode.CustomDocumentBackup): void {\n\t\tthis._backup?.delete();\n\t\tthis._backup = backup;\n\t}\n\n\tdisposeBackup(): void {\n\t\tthis._backup?.delete();\n\t\tthis._backup = undefined;\n\t}\n\n\tprivate getEdit(editId: number): vscode.CustomDocumentEditEvent {\n\t\tconst edit = this._edits.get(editId, 0);\n\t\tif (!edit) {\n\t\t\tthrow new Error('No edit found');\n\t\t}\n\t\treturn edit;\n\t}\n}\n\nclass CustomDocumentStore {\n\tprivate readonly _documents = new Map<string, CustomDocumentStoreEntry>();\n\n\tpublic get(viewType: string, resource: vscode.Uri): CustomDocumentStoreEntry | undefined {\n\t\treturn this._documents.get(this.key(viewType, resource));\n\t}\n\n\tpublic add(viewType: string, document: vscode.CustomDocument, storagePath: URI | undefined): CustomDocumentStoreEntry {\n\t\tconst key = this.key(viewType, document.uri);\n\t\tif (this._documents.has(key)) {\n\t\t\tthrow new Error(`Document already exists for viewType:${viewType} resource:${document.uri}`);\n\t\t}\n\t\tconst entry = new CustomDocumentStoreEntry(document, storagePath);\n\t\tthis._documents.set(key, entry);\n\t\treturn entry;\n\t}\n\n\tpublic delete(viewType: string, document: vscode.CustomDocument) {\n\t\tconst key = this.key(viewType, document.uri);\n\t\tthis._documents.delete(key);\n\t}\n\n\tprivate key(viewType: string, resource: vscode.Uri): string {\n\t\treturn `${viewType}@@@${resource}`;\n\t}\n}\n\nconst enum CustomEditorType {\n\tText,\n\tCustom\n}\n\ntype ProviderEntry = {\n\treadonly extension: IExtensionDescription;\n\treadonly type: CustomEditorType.Text;\n\treadonly provider: vscode.CustomTextEditorProvider;\n} | {\n\treadonly extension: IExtensionDescription;\n\treadonly type: CustomEditorType.Custom;\n\treadonly provider: vscode.CustomReadonlyEditorProvider;\n};\n\nclass EditorProviderStore {\n\tprivate readonly _providers = new Map<string, ProviderEntry>();\n\n\tpublic addTextProvider(viewType: string, extension: IExtensionDescription, provider: vscode.CustomTextEditorProvider): vscode.Disposable {\n\t\treturn this.add(viewType, { type: CustomEditorType.Text, extension, provider });\n\t}\n\n\tpublic addCustomProvider(viewType: string, extension: IExtensionDescription, provider: vscode.CustomReadonlyEditorProvider): vscode.Disposable {\n\t\treturn this.add(viewType, { type: CustomEditorType.Custom, extension, provider });\n\t}\n\n\tpublic get(viewType: string): ProviderEntry | undefined {\n\t\treturn this._providers.get(viewType);\n\t}\n\n\tprivate add(viewType: string, entry: ProviderEntry): vscode.Disposable {\n\t\tif (this._providers.has(viewType)) {\n\t\t\tthrow new Error(`Provider for viewType:${viewType} already registered`);\n\t\t}\n\t\tthis._providers.set(viewType, entry);\n\t\treturn new extHostTypes.Disposable(() => this._providers.delete(viewType));\n\t}\n}\n\nexport class ExtHostCustomEditors implements extHostProtocol.ExtHostCustomEditorsShape {\n\n\tprivate readonly _proxy: extHostProtocol.MainThreadCustomEditorsShape;\n\n\tprivate readonly _editorProviders = new EditorProviderStore();\n\n\tprivate readonly _documents = new CustomDocumentStore();\n\n\tconstructor(\n\t\tmainContext: extHostProtocol.IMainContext,\n\t\tprivate readonly _extHostDocuments: ExtHostDocuments,\n\t\tprivate readonly _extensionStoragePaths: IExtensionStoragePaths | undefined,\n\t\tprivate readonly _extHostWebview: ExtHostWebviews,\n\t\tprivate readonly _extHostWebviewPanels: ExtHostWebviewPanels,\n\t) {\n\t\tthis._proxy = mainContext.getProxy(extHostProtocol.MainContext.MainThreadCustomEditors);\n\t}\n\n\tpublic registerCustomEditorProvider(\n\t\textension: IExtensionDescription,\n\t\tviewType: string,\n\t\tprovider: vscode.CustomReadonlyEditorProvider | vscode.CustomTextEditorProvider,\n\t\toptions: { webviewOptions?: vscode.WebviewPanelOptions; supportsMultipleEditorsPerDocument?: boolean },\n\t): vscode.Disposable {\n\t\tconst disposables = new DisposableStore();\n\t\tif (isCustomTextEditorProvider(provider)) {\n\t\t\tdisposables.add(this._editorProviders.addTextProvider(viewType, extension, provider));\n\t\t\tthis._proxy.$registerTextEditorProvider(toExtensionData(extension), viewType, options.webviewOptions || {}, {\n\t\t\t\tsupportsMove: !!provider.moveCustomTextEditor,\n\t\t\t}, shouldSerializeBuffersForPostMessage(extension));\n\t\t} else {\n\t\t\tdisposables.add(this._editorProviders.addCustomProvider(viewType, extension, provider));\n\n\t\t\tif (isCustomEditorProviderWithEditingCapability(provider)) {\n\t\t\t\tdisposables.add(provider.onDidChangeCustomDocument(e => {\n\t\t\t\t\tconst entry = this.getCustomDocumentEntry(viewType, e.document.uri);\n\t\t\t\t\tif (isEditEvent(e)) {\n\t\t\t\t\t\tconst editId = entry.addEdit(e);\n\t\t\t\t\t\tthis._proxy.$onDidEdit(e.document.uri, viewType, editId, e.label);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._proxy.$onContentChange(e.document.uri, viewType);\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tthis._proxy.$registerCustomEditorProvider(toExtensionData(extension), viewType, options.webviewOptions || {}, !!options.supportsMultipleEditorsPerDocument, shouldSerializeBuffersForPostMessage(extension));\n\t\t}\n\n\t\treturn extHostTypes.Disposable.from(\n\t\t\tdisposables,\n\t\t\tnew extHostTypes.Disposable(() => {\n\t\t\t\tthis._proxy.$unregisterEditorProvider(viewType);\n\t\t\t}));\n\t}\n\n\tasync $createCustomDocument(resource: UriComponents, viewType: string, backupId: string | undefined, untitledDocumentData: VSBuffer | undefined, cancellation: CancellationToken) {\n\t\tconst entry = this._editorProviders.get(viewType);\n\t\tif (!entry) {\n\t\t\tthrow new Error(`No provider found for '${viewType}'`);\n\t\t}\n\n\t\tif (entry.type !== CustomEditorType.Custom) {\n\t\t\tthrow new Error(`Invalid provide type for '${viewType}'`);\n\t\t}\n\n\t\tconst revivedResource = URI.revive(resource);\n\t\tconst document = await entry.provider.openCustomDocument(revivedResource, { backupId, untitledDocumentData: untitledDocumentData?.buffer }, cancellation);\n\n\t\tlet storageRoot: URI | undefined;\n\t\tif (isCustomEditorProviderWithEditingCapability(entry.provider) && this._extensionStoragePaths) {\n\t\t\tstorageRoot = this._extensionStoragePaths.workspaceValue(entry.extension) ?? this._extensionStoragePaths.globalValue(entry.extension);\n\t\t}\n\t\tthis._documents.add(viewType, document, storageRoot);\n\n\t\treturn { editable: isCustomEditorProviderWithEditingCapability(entry.provider) };\n\t}\n\n\tasync $disposeCustomDocument(resource: UriComponents, viewType: string): Promise<void> {\n\t\tconst entry = this._editorProviders.get(viewType);\n\t\tif (!entry) {\n\t\t\tthrow new Error(`No provider found for '${viewType}'`);\n\t\t}\n\n\t\tif (entry.type !== CustomEditorType.Custom) {\n\t\t\tthrow new Error(`Invalid provider type for '${viewType}'`);\n\t\t}\n\n\t\tconst revivedResource = URI.revive(resource);\n\t\tconst { document } = this.getCustomDocumentEntry(viewType, revivedResource);\n\t\tthis._documents.delete(viewType, document);\n\t\tdocument.dispose();\n\t}\n\n\tasync $resolveCustomEditor(\n\t\tresource: UriComponents,\n\t\thandle: extHostProtocol.WebviewHandle,\n\t\tviewType: string,\n\t\tinitData: {\n\t\t\ttitle: string;\n\t\t\tcontentOptions: extHostProtocol.IWebviewContentOptions;\n\t\t\toptions: extHostProtocol.IWebviewPanelOptions;\n\t\t\tactive: boolean;\n\t\t},\n\t\tposition: EditorGroupColumn,\n\t\tcancellation: CancellationToken,\n\t): Promise<void> {\n\t\tconst entry = this._editorProviders.get(viewType);\n\t\tif (!entry) {\n\t\t\tthrow new Error(`No provider found for '${viewType}'`);\n\t\t}\n\n\t\tconst viewColumn = typeConverters.ViewColumn.to(position);\n\n\t\tconst webview = this._extHostWebview.createNewWebview(handle, initData.contentOptions, entry.extension);\n\t\tconst panel = this._extHostWebviewPanels.createNewWebviewPanel(handle, viewType, initData.title, viewColumn, initData.options, webview, initData.active);\n\n\t\tconst revivedResource = URI.revive(resource);\n\n\t\tswitch (entry.type) {\n\t\t\tcase CustomEditorType.Custom: {\n\t\t\t\tconst { document } = this.getCustomDocumentEntry(viewType, revivedResource);\n\t\t\t\treturn entry.provider.resolveCustomEditor(document, panel, cancellation);\n\t\t\t}\n\t\t\tcase CustomEditorType.Text: {\n\t\t\t\tconst document = this._extHostDocuments.getDocument(revivedResource);\n\t\t\t\treturn entry.provider.resolveCustomTextEditor(document, panel, cancellation);\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('Unknown webview provider type');\n\t\t\t}\n\t\t}\n\t}\n\n\t$disposeEdits(resourceComponents: UriComponents, viewType: string, editIds: number[]): void {\n\t\tconst document = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\tdocument.disposeEdits(editIds);\n\t}\n\n\tasync $onMoveCustomEditor(handle: string, newResourceComponents: UriComponents, viewType: string): Promise<void> {\n\t\tconst entry = this._editorProviders.get(viewType);\n\t\tif (!entry) {\n\t\t\tthrow new Error(`No provider found for '${viewType}'`);\n\t\t}\n\n\t\tif (!(entry.provider as vscode.CustomTextEditorProvider).moveCustomTextEditor) {\n\t\t\tthrow new Error(`Provider does not implement move '${viewType}'`);\n\t\t}\n\n\t\tconst webview = this._extHostWebviewPanels.getWebviewPanel(handle);\n\t\tif (!webview) {\n\t\t\tthrow new Error(`No webview found`);\n\t\t}\n\n\t\tconst resource = URI.revive(newResourceComponents);\n\t\tconst document = this._extHostDocuments.getDocument(resource);\n\t\tawait (entry.provider as vscode.CustomTextEditorProvider).moveCustomTextEditor!(document, webview, CancellationToken.None);\n\t}\n\n\tasync $undo(resourceComponents: UriComponents, viewType: string, editId: number, isDirty: boolean): Promise<void> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\treturn entry.undo(editId, isDirty);\n\t}\n\n\tasync $redo(resourceComponents: UriComponents, viewType: string, editId: number, isDirty: boolean): Promise<void> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\treturn entry.redo(editId, isDirty);\n\t}\n\n\tasync $revert(resourceComponents: UriComponents, viewType: string, cancellation: CancellationToken): Promise<void> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\tconst provider = this.getCustomEditorProvider(viewType);\n\t\tawait provider.revertCustomDocument(entry.document, cancellation);\n\t\tentry.disposeBackup();\n\t}\n\n\tasync $onSave(resourceComponents: UriComponents, viewType: string, cancellation: CancellationToken): Promise<void> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\tconst provider = this.getCustomEditorProvider(viewType);\n\t\tawait provider.saveCustomDocument(entry.document, cancellation);\n\t\tentry.disposeBackup();\n\t}\n\n\tasync $onSaveAs(resourceComponents: UriComponents, viewType: string, targetResource: UriComponents, cancellation: CancellationToken): Promise<void> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\tconst provider = this.getCustomEditorProvider(viewType);\n\t\treturn provider.saveCustomDocumentAs(entry.document, URI.revive(targetResource), cancellation);\n\t}\n\n\tasync $backup(resourceComponents: UriComponents, viewType: string, cancellation: CancellationToken): Promise<string> {\n\t\tconst entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n\t\tconst provider = this.getCustomEditorProvider(viewType);\n\n\t\tconst backup = await provider.backupCustomDocument(entry.document, {\n\t\t\tdestination: entry.getNewBackupUri(),\n\t\t}, cancellation);\n\t\tentry.updateBackup(backup);\n\t\treturn backup.id;\n\t}\n\n\tprivate getCustomDocumentEntry(viewType: string, resource: UriComponents): CustomDocumentStoreEntry {\n\t\tconst entry = this._documents.get(viewType, URI.revive(resource));\n\t\tif (!entry) {\n\t\t\tthrow new Error('No custom document found');\n\t\t}\n\t\treturn entry;\n\t}\n\n\tprivate getCustomEditorProvider(viewType: string): vscode.CustomEditorProvider {\n\t\tconst entry = this._editorProviders.get(viewType);\n\t\tconst provider = entry?.provider;\n\t\tif (!provider || !isCustomEditorProviderWithEditingCapability(provider)) {\n\t\t\tthrow new Error('Custom document is not editable');\n\t\t}\n\t\treturn provider;\n\t}\n}\n\nfunction isCustomEditorProviderWithEditingCapability(provider: vscode.CustomTextEditorProvider | vscode.CustomEditorProvider | vscode.CustomReadonlyEditorProvider): provider is vscode.CustomEditorProvider {\n\treturn !!(provider as vscode.CustomEditorProvider).onDidChangeCustomDocument;\n}\n\nfunction isCustomTextEditorProvider(provider: vscode.CustomReadonlyEditorProvider<vscode.CustomDocument> | vscode.CustomTextEditorProvider): provider is vscode.CustomTextEditorProvider {\n\treturn typeof (provider as vscode.CustomTextEditorProvider).resolveCustomTextEditor === 'function';\n}\n\nfunction isEditEvent(e: vscode.CustomDocumentContentChangeEvent | vscode.CustomDocumentEditEvent): e is vscode.CustomDocumentEditEvent {\n\treturn typeof (e as vscode.CustomDocumentEditEvent).undo === 'function'\n\t\t&& typeof (e as vscode.CustomDocumentEditEvent).redo === 'function';\n}\n\nfunction hashPath(resource: URI): string {\n\tconst str = resource.scheme === Schemas.file || resource.scheme === Schemas.untitled ? resource.fsPath : resource.toString();\n\treturn hash(str) + '';\n}\n"]}