{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/common/extHostTesting.ts","vs/workbench/api/common/extHostTesting.ts"],"names":[],"mappings":"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","file":"extHostTesting.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* eslint-disable local/code-no-native-private */\n\nimport type * as vscode from 'vscode';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { createSingleCallFunction } from '../../../base/common/functional.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../base/common/lifecycle.js';\nimport { MarshalledId } from '../../../base/common/marshallingIds.js';\nimport { isDefined } from '../../../base/common/types.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { IPosition } from '../../../editor/common/core/position.js';\nimport { IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { TestCommandId } from '../../contrib/testing/common/constants.js';\nimport { TestId, TestPosition } from '../../contrib/testing/common/testId.js';\nimport { InvalidTestItemError } from '../../contrib/testing/common/testItemCollection.js';\nimport { AbstractIncrementalTestCollection, CoverageDetails, ICallProfileRunHandler, ISerializedTestResults, IStartControllerTests, IStartControllerTestsResult, ITestErrorMessage, ITestItem, ITestItemContext, ITestMessageMenuArgs, ITestRunProfile, IncrementalChangeCollector, IncrementalTestCollectionItem, InternalTestItem, TestControllerCapability, TestMessageFollowupRequest, TestMessageFollowupResponse, TestResultState, TestsDiff, TestsDiffOp, isStartControllerTests } from '../../contrib/testing/common/testTypes.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { ExtHostTestingShape, ILocationDto, MainContext, MainThreadTestingShape } from './extHost.protocol.js';\nimport { IExtHostCommands } from './extHostCommands.js';\nimport { IExtHostDocumentsAndEditors } from './extHostDocumentsAndEditors.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { ExtHostTestItemCollection, TestItemImpl, TestItemRootImpl, toItemFromContext } from './extHostTestItem.js';\nimport * as Convert from './extHostTypeConverters.js';\nimport { FileCoverage, TestRunProfileBase, TestRunRequest } from './extHostTypes.js';\n\ninterface ControllerInfo {\n\tcontroller: vscode.TestController;\n\tprofiles: Map<number, vscode.TestRunProfile>;\n\tcollection: ExtHostTestItemCollection;\n\textension: IExtensionDescription;\n\trelatedCodeProvider?: vscode.TestRelatedCodeProvider;\n\tactiveProfiles: Set<number>;\n}\n\ntype DefaultProfileChangeEvent = Map</* controllerId */ string, Map< /* profileId */number, boolean>>;\n\nlet followupCounter = 0;\n\nconst testResultInternalIDs = new WeakMap<vscode.TestRunResult, string>();\n\nexport const IExtHostTesting = createDecorator<IExtHostTesting>('IExtHostTesting');\nexport interface IExtHostTesting extends ExtHostTesting {\n\treadonly _serviceBrand: undefined;\n}\n\nexport class ExtHostTesting extends Disposable implements ExtHostTestingShape {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly resultsChangedEmitter = this._register(new Emitter<void>());\n\tprotected readonly controllers = new Map</* controller ID */ string, ControllerInfo>();\n\tprivate readonly proxy: MainThreadTestingShape;\n\tprivate readonly runTracker: TestRunCoordinator;\n\tprivate readonly observer: TestObservers;\n\tprivate readonly defaultProfilesChangedEmitter = this._register(new Emitter<DefaultProfileChangeEvent>());\n\tprivate readonly followupProviders = new Set<vscode.TestFollowupProvider>();\n\tprivate readonly testFollowups = new Map<number, vscode.Command>();\n\n\tpublic onResultsChanged = this.resultsChangedEmitter.event;\n\tpublic results: ReadonlyArray<vscode.TestRunResult> = [];\n\n\tconstructor(\n\t\t@IExtHostRpcService rpc: IExtHostRpcService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IExtHostCommands private readonly commands: IExtHostCommands,\n\t\t@IExtHostDocumentsAndEditors private readonly editors: IExtHostDocumentsAndEditors,\n\t) {\n\t\tsuper();\n\t\tthis.proxy = rpc.getProxy(MainContext.MainThreadTesting);\n\t\tthis.observer = new TestObservers(this.proxy);\n\t\tthis.runTracker = new TestRunCoordinator(this.proxy, logService);\n\n\t\tcommands.registerArgumentProcessor({\n\t\t\tprocessArgument: arg => {\n\t\t\t\tswitch (arg?.$mid) {\n\t\t\t\t\tcase MarshalledId.TestItemContext: {\n\t\t\t\t\t\tconst cast = arg as ITestItemContext;\n\t\t\t\t\t\tconst targetTest = cast.tests[cast.tests.length - 1].item.extId;\n\t\t\t\t\t\tconst controller = this.controllers.get(TestId.root(targetTest));\n\t\t\t\t\t\treturn controller?.collection.tree.get(targetTest)?.actual ?? toItemFromContext(arg);\n\t\t\t\t\t}\n\t\t\t\t\tcase MarshalledId.TestMessageMenuArgs: {\n\t\t\t\t\t\tconst { test, message } = arg as ITestMessageMenuArgs;\n\t\t\t\t\t\tconst extId = test.item.extId;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttest: this.controllers.get(TestId.root(extId))?.collection.tree.get(extId)?.actual\n\t\t\t\t\t\t\t\t?? toItemFromContext({ $mid: MarshalledId.TestItemContext, tests: [test] }),\n\t\t\t\t\t\t\tmessage: Convert.TestMessage.to(message as ITestErrorMessage.Serialized),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tdefault: return arg;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tcommands.registerCommand(false, 'testing.getExplorerSelection', async (): Promise<any> => {\n\t\t\tconst inner = await commands.executeCommand<{\n\t\t\t\tinclude: string[];\n\t\t\t\texclude: string[];\n\t\t\t}>(TestCommandId.GetExplorerSelection);\n\n\t\t\tconst lookup = (i: string) => {\n\t\t\t\tconst controller = this.controllers.get(TestId.root(i));\n\t\t\t\tif (!controller) { return undefined; }\n\t\t\t\treturn TestId.isRoot(i) ? controller.controller : controller.collection.tree.get(i)?.actual;\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\tinclude: inner?.include.map(lookup).filter(isDefined) || [],\n\t\t\t\texclude: inner?.exclude.map(lookup).filter(isDefined) || [],\n\t\t\t};\n\t\t});\n\t}\n\n\t//#region public API\n\n\t/**\n\t * Implements vscode.test.registerTestProvider\n\t */\n\tpublic createTestController(extension: IExtensionDescription, controllerId: string, label: string, refreshHandler?: (token: CancellationToken) => Thenable<void> | void): vscode.TestController {\n\t\tif (this.controllers.has(controllerId)) {\n\t\t\tthrow new Error(`Attempt to insert a duplicate controller with ID \"${controllerId}\"`);\n\t\t}\n\n\t\tconst disposable = new DisposableStore();\n\t\tconst collection = disposable.add(new ExtHostTestItemCollection(controllerId, label, this.editors));\n\t\tcollection.root.label = label;\n\n\t\tconst profiles = new Map<number, vscode.TestRunProfile>();\n\t\tconst activeProfiles = new Set<number>();\n\t\tconst proxy = this.proxy;\n\n\t\tconst getCapability = () => {\n\t\t\tlet cap = 0;\n\t\t\tif (refreshHandler) {\n\t\t\t\tcap |= TestControllerCapability.Refresh;\n\t\t\t}\n\t\t\tconst rcp = info.relatedCodeProvider;\n\t\t\tif (rcp) {\n\t\t\t\tif (rcp?.provideRelatedTests) {\n\t\t\t\t\tcap |= TestControllerCapability.TestRelatedToCode;\n\t\t\t\t}\n\t\t\t\tif (rcp?.provideRelatedCode) {\n\t\t\t\t\tcap |= TestControllerCapability.CodeRelatedToTest;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cap as TestControllerCapability;\n\t\t};\n\n\t\tconst controller: vscode.TestController = {\n\t\t\titems: collection.root.children,\n\t\t\tget label() {\n\t\t\t\treturn label;\n\t\t\t},\n\t\t\tset label(value: string) {\n\t\t\t\tlabel = value;\n\t\t\t\tcollection.root.label = value;\n\t\t\t\tproxy.$updateController(controllerId, { label });\n\t\t\t},\n\t\t\tget refreshHandler() {\n\t\t\t\treturn refreshHandler;\n\t\t\t},\n\t\t\tset refreshHandler(value: ((token: CancellationToken) => Thenable<void> | void) | undefined) {\n\t\t\t\trefreshHandler = value;\n\t\t\t\tproxy.$updateController(controllerId, { capabilities: getCapability() });\n\t\t\t},\n\t\t\tget id() {\n\t\t\t\treturn controllerId;\n\t\t\t},\n\t\t\tget relatedCodeProvider() {\n\t\t\t\treturn info.relatedCodeProvider;\n\t\t\t},\n\t\t\tset relatedCodeProvider(value: vscode.TestRelatedCodeProvider | undefined) {\n\t\t\t\tcheckProposedApiEnabled(extension, 'testRelatedCode');\n\t\t\t\tinfo.relatedCodeProvider = value;\n\t\t\t\tproxy.$updateController(controllerId, { capabilities: getCapability() });\n\t\t\t},\n\t\t\tcreateRunProfile: (label, group, runHandler, isDefault, tag?: vscode.TestTag | undefined, supportsContinuousRun?: boolean) => {\n\t\t\t\t// Derive the profile ID from a hash so that the same profile will tend\n\t\t\t\t// to have the same hashes, allowing re-run requests to work across reloads.\n\t\t\t\tlet profileId = hash(label);\n\t\t\t\twhile (profiles.has(profileId)) {\n\t\t\t\t\tprofileId++;\n\t\t\t\t}\n\n\t\t\t\treturn new TestRunProfileImpl(this.proxy, profiles, activeProfiles, this.defaultProfilesChangedEmitter.event, controllerId, profileId, label, group, runHandler, isDefault, tag, supportsContinuousRun);\n\t\t\t},\n\t\t\tcreateTestItem(id, label, uri) {\n\t\t\t\treturn new TestItemImpl(controllerId, id, label, uri);\n\t\t\t},\n\t\t\tcreateTestRun: (request, name, persist = true) => {\n\t\t\t\treturn this.runTracker.createTestRun(extension, controllerId, collection, request, name, persist);\n\t\t\t},\n\t\t\tinvalidateTestResults: items => {\n\t\t\t\tif (items === undefined) {\n\t\t\t\t\tthis.proxy.$markTestRetired(undefined);\n\t\t\t\t} else {\n\t\t\t\t\tconst itemsArr = items instanceof Array ? items : [items];\n\t\t\t\t\tthis.proxy.$markTestRetired(itemsArr.map(i => TestId.fromExtHostTestItem(i!, controllerId).toString()));\n\t\t\t\t}\n\t\t\t},\n\t\t\tset resolveHandler(fn) {\n\t\t\t\tcollection.resolveHandler = fn;\n\t\t\t},\n\t\t\tget resolveHandler() {\n\t\t\t\treturn collection.resolveHandler as undefined | ((item?: vscode.TestItem) => void);\n\t\t\t},\n\t\t\tdispose: () => {\n\t\t\t\tdisposable.dispose();\n\t\t\t},\n\t\t};\n\n\t\tconst info: ControllerInfo = { controller, collection, profiles, extension, activeProfiles };\n\t\tproxy.$registerTestController(controllerId, label, getCapability());\n\t\tdisposable.add(toDisposable(() => proxy.$unregisterTestController(controllerId)));\n\n\t\tthis.controllers.set(controllerId, info);\n\t\tdisposable.add(toDisposable(() => this.controllers.delete(controllerId)));\n\n\t\tdisposable.add(collection.onDidGenerateDiff(diff => proxy.$publishDiff(controllerId, diff.map(TestsDiffOp.serialize))));\n\n\t\treturn controller;\n\t}\n\n\t/**\n\t * Implements vscode.test.createTestObserver\n\t */\n\tpublic createTestObserver() {\n\t\treturn this.observer.checkout();\n\t}\n\n\n\t/**\n\t * Implements vscode.test.runTests\n\t */\n\tpublic async runTests(req: vscode.TestRunRequest, token = CancellationToken.None) {\n\t\tconst profile = tryGetProfileFromTestRunReq(req);\n\t\tif (!profile) {\n\t\t\tthrow new Error('The request passed to `vscode.test.runTests` must include a profile');\n\t\t}\n\n\t\tconst controller = this.controllers.get(profile.controllerId);\n\t\tif (!controller) {\n\t\t\tthrow new Error('Controller not found');\n\t\t}\n\n\t\tawait this.proxy.$runTests({\n\t\t\tpreserveFocus: req.preserveFocus ?? true,\n\t\t\tgroup: Convert.TestRunProfileKind.from(profile.kind),\n\t\t\ttargets: [{\n\t\t\t\ttestIds: req.include?.map(t => TestId.fromExtHostTestItem(t, controller.collection.root.id).toString()) ?? [controller.collection.root.id],\n\t\t\t\tprofileId: profile.profileId,\n\t\t\t\tcontrollerId: profile.controllerId,\n\t\t\t}],\n\t\t\texclude: req.exclude?.map(t => t.id),\n\t\t}, token);\n\t}\n\n\t/**\n\t * Implements vscode.test.registerTestFollowupProvider\n\t */\n\tpublic registerTestFollowupProvider(provider: vscode.TestFollowupProvider): vscode.Disposable {\n\t\tthis.followupProviders.add(provider);\n\t\treturn { dispose: () => { this.followupProviders.delete(provider); } };\n\t}\n\n\t//#endregion\n\n\t//#region RPC methods\n\t/**\n\t * @inheritdoc\n\t */\n\tasync $getTestsRelatedToCode(uri: UriComponents, _position: IPosition, token: CancellationToken): Promise<string[]> {\n\t\tconst doc = this.editors.getDocument(URI.revive(uri));\n\t\tif (!doc) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst position = Convert.Position.to(_position);\n\t\tconst related: string[] = [];\n\t\tawait Promise.all([...this.controllers.values()].map(async (c) => {\n\t\t\tlet tests: vscode.TestItem[] | undefined | null;\n\t\t\ttry {\n\t\t\t\ttests = await c.relatedCodeProvider?.provideRelatedTests?.(doc.document, position, token);\n\t\t\t} catch (e) {\n\t\t\t\tif (!token.isCancellationRequested) {\n\t\t\t\t\tthis.logService.warn(`Error thrown while providing related tests for ${c.controller.label}`, e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tests) {\n\t\t\t\tfor (const test of tests) {\n\t\t\t\t\trelated.push(TestId.fromExtHostTestItem(test, c.controller.id).toString());\n\t\t\t\t}\n\t\t\t\tc.collection.flushDiff();\n\t\t\t}\n\t\t}));\n\n\t\treturn related;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tasync $getCodeRelatedToTest(testId: string, token: CancellationToken): Promise<ILocationDto[]> {\n\t\tconst controller = this.controllers.get(TestId.root(testId));\n\t\tif (!controller) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst test = controller.collection.tree.get(testId);\n\t\tif (!test) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst locations = await controller.relatedCodeProvider?.provideRelatedCode?.(test.actual, token);\n\t\treturn locations?.map(Convert.location.from) ?? [];\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\t$syncTests(): Promise<void> {\n\t\tfor (const { collection } of this.controllers.values()) {\n\t\t\tcollection.flushDiff();\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tasync $getCoverageDetails(coverageId: string, testId: string | undefined, token: CancellationToken): Promise<CoverageDetails.Serialized[]> {\n\t\tconst details = await this.runTracker.getCoverageDetails(coverageId, testId, token);\n\t\treturn details?.map(Convert.TestCoverage.fromDetails);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tasync $disposeRun(runId: string) {\n\t\tthis.runTracker.disposeTestRun(runId);\n\t}\n\n\t/** @inheritdoc */\n\t$configureRunProfile(controllerId: string, profileId: number) {\n\t\tthis.controllers.get(controllerId)?.profiles.get(profileId)?.configureHandler?.();\n\t}\n\n\t/** @inheritdoc */\n\t$setDefaultRunProfiles(profiles: Record</* controller id */string, /* profile id */ number[]>): void {\n\t\tconst evt: DefaultProfileChangeEvent = new Map();\n\t\tfor (const [controllerId, profileIds] of Object.entries(profiles)) {\n\t\t\tconst ctrl = this.controllers.get(controllerId);\n\t\t\tif (!ctrl) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst changes = new Map<number, boolean>();\n\t\t\tconst added = profileIds.filter(id => !ctrl.activeProfiles.has(id));\n\t\t\tconst removed = [...ctrl.activeProfiles].filter(id => !profileIds.includes(id));\n\t\t\tfor (const id of added) {\n\t\t\t\tchanges.set(id, true);\n\t\t\t\tctrl.activeProfiles.add(id);\n\t\t\t}\n\t\t\tfor (const id of removed) {\n\t\t\t\tchanges.set(id, false);\n\t\t\t\tctrl.activeProfiles.delete(id);\n\t\t\t}\n\t\t\tif (changes.size) {\n\t\t\t\tevt.set(controllerId, changes);\n\t\t\t}\n\t\t}\n\n\t\tthis.defaultProfilesChangedEmitter.fire(evt);\n\t}\n\n\t/** @inheritdoc */\n\tasync $refreshTests(controllerId: string, token: CancellationToken) {\n\t\tawait this.controllers.get(controllerId)?.controller.refreshHandler?.(token);\n\t}\n\n\t/**\n\t * Updates test results shown to extensions.\n\t * @override\n\t */\n\tpublic $publishTestResults(results: ISerializedTestResults[]): void {\n\t\tthis.results = Object.freeze(\n\t\t\tresults\n\t\t\t\t.map(r => {\n\t\t\t\t\tconst o = Convert.TestResults.to(r);\n\t\t\t\t\tconst taskWithCoverage = r.tasks.findIndex(t => t.hasCoverage);\n\t\t\t\t\tif (taskWithCoverage !== -1) {\n\t\t\t\t\t\to.getDetailedCoverage = (uri, token = CancellationToken.None) =>\n\t\t\t\t\t\t\tthis.proxy.$getCoverageDetails(r.id, taskWithCoverage, uri, token).then(r => r.map(Convert.TestCoverage.to));\n\t\t\t\t\t}\n\n\t\t\t\t\ttestResultInternalIDs.set(o, r.id);\n\t\t\t\t\treturn o;\n\t\t\t\t})\n\t\t\t\t.concat(this.results)\n\t\t\t\t.sort((a, b) => b.completedAt - a.completedAt)\n\t\t\t\t.slice(0, 32),\n\t\t);\n\n\t\tthis.resultsChangedEmitter.fire();\n\t}\n\n\t/**\n\t * Expands the nodes in the test tree. If levels is less than zero, it will\n\t * be treated as infinite.\n\t */\n\tpublic async $expandTest(testId: string, levels: number) {\n\t\tconst collection = this.controllers.get(TestId.fromString(testId).controllerId)?.collection;\n\t\tif (collection) {\n\t\t\tawait collection.expand(testId, levels < 0 ? Infinity : levels);\n\t\t\tcollection.flushDiff();\n\t\t}\n\t}\n\n\t/**\n\t * Receives a test update from the main thread. Called (eventually) whenever\n\t * tests change.\n\t */\n\tpublic $acceptDiff(diff: TestsDiffOp.Serialized[]): void {\n\t\tthis.observer.applyDiff(diff.map(d => TestsDiffOp.deserialize({ asCanonicalUri: u => u }, d)));\n\t}\n\n\t/**\n\t * Runs tests with the given set of IDs. Allows for test from multiple\n\t * providers to be run.\n\t * @inheritdoc\n\t */\n\tpublic async $runControllerTests(reqs: IStartControllerTests[], token: CancellationToken): Promise<IStartControllerTestsResult[]> {\n\t\treturn Promise.all(reqs.map(req => this.runControllerTestRequest(req, false, token)));\n\t}\n\n\t/**\n\t * Starts continuous test runs with the given set of IDs. Allows for test from\n\t * multiple providers to be run.\n\t * @inheritdoc\n\t */\n\tpublic async $startContinuousRun(reqs: IStartControllerTests[], token: CancellationToken): Promise<IStartControllerTestsResult[]> {\n\t\tconst cts = new CancellationTokenSource(token);\n\t\tconst res = await Promise.all(reqs.map(req => this.runControllerTestRequest(req, true, cts.token)));\n\n\t\t// avoid returning until cancellation is requested, otherwise ipc disposes of the token\n\t\tif (!token.isCancellationRequested && !res.some(r => r.error)) {\n\t\t\tawait new Promise(r => token.onCancellationRequested(r));\n\t\t}\n\n\t\tcts.dispose(true);\n\t\treturn res;\n\t}\n\n\t/** @inheritdoc */\n\tpublic async $provideTestFollowups(req: TestMessageFollowupRequest, token: CancellationToken): Promise<TestMessageFollowupResponse[]> {\n\t\tconst results = this.results.find(r => testResultInternalIDs.get(r) === req.resultId);\n\t\tconst test = results && findTestInResultSnapshot(TestId.fromString(req.extId), results?.results);\n\t\tif (!test) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet followups: vscode.Command[] = [];\n\t\tawait Promise.all([...this.followupProviders].map(async provider => {\n\t\t\ttry {\n\t\t\t\tconst r = await provider.provideFollowup(results, test, req.taskIndex, req.messageIndex, token);\n\t\t\t\tif (r) {\n\t\t\t\t\tfollowups = followups.concat(r);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis.logService.error(`Error thrown while providing followup for test message`, e);\n\t\t\t}\n\t\t}));\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn followups.map(command => {\n\t\t\tconst id = followupCounter++;\n\t\t\tthis.testFollowups.set(id, command);\n\t\t\treturn { title: command.title, id };\n\t\t});\n\t}\n\n\t$disposeTestFollowups(id: number[]): void {\n\t\tfor (const i of id) {\n\t\t\tthis.testFollowups.delete(i);\n\t\t}\n\t}\n\n\t$executeTestFollowup(id: number): Promise<void> {\n\t\tconst command = this.testFollowups.get(id);\n\t\tif (!command) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn this.commands.executeCommand(command.command, ...(command.arguments || []));\n\t}\n\n\t/**\n\t * Cancels an ongoing test run.\n\t */\n\tpublic $cancelExtensionTestRun(runId: string | undefined, taskId: string | undefined) {\n\t\tif (runId === undefined) {\n\t\t\tthis.runTracker.cancelAllRuns();\n\t\t} else {\n\t\t\tthis.runTracker.cancelRunById(runId, taskId);\n\t\t}\n\t}\n\n\t//#endregion\n\n\tpublic getMetadataForRun(run: vscode.TestRun) {\n\t\tfor (const tracker of this.runTracker.trackers) {\n\t\t\tconst taskId = tracker.getTaskIdForRun(run);\n\t\t\tif (taskId) {\n\t\t\t\treturn { taskId, runId: tracker.id };\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async runControllerTestRequest(req: ICallProfileRunHandler | ICallProfileRunHandler, isContinuous: boolean, token: CancellationToken): Promise<IStartControllerTestsResult> {\n\t\tconst lookup = this.controllers.get(req.controllerId);\n\t\tif (!lookup) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst { collection, profiles, extension } = lookup;\n\t\tconst profile = profiles.get(req.profileId);\n\t\tif (!profile) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst includeTests = req.testIds\n\t\t\t.map((testId) => collection.tree.get(testId))\n\t\t\t.filter(isDefined);\n\n\t\tconst excludeTests = req.excludeExtIds\n\t\t\t.map(id => lookup.collection.tree.get(id))\n\t\t\t.filter(isDefined)\n\t\t\t.filter(exclude => includeTests.some(\n\t\t\t\tinclude => include.fullId.compare(exclude.fullId) === TestPosition.IsChild,\n\t\t\t));\n\n\t\tif (!includeTests.length) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst publicReq = new TestRunRequest(\n\t\t\tincludeTests.some(i => i.actual instanceof TestItemRootImpl) ? undefined : includeTests.map(t => t.actual),\n\t\t\texcludeTests.map(t => t.actual),\n\t\t\tprofile,\n\t\t\tisContinuous,\n\t\t);\n\n\t\tconst tracker = isStartControllerTests(req) && this.runTracker.prepareForMainThreadTestRun(\n\t\t\textension,\n\t\t\tpublicReq,\n\t\t\tTestRunDto.fromInternal(req, lookup.collection),\n\t\t\tprofile,\n\t\t\ttoken,\n\t\t);\n\n\t\ttry {\n\t\t\tawait profile.runHandler(publicReq, token);\n\t\t\treturn {};\n\t\t} catch (e) {\n\t\t\treturn { error: String(e) };\n\t\t} finally {\n\t\t\tif (tracker) {\n\t\t\t\tif (tracker.hasRunningTasks && !token.isCancellationRequested) {\n\t\t\t\t\tawait Event.toPromise(tracker.onEnd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Deadline after being requested by a user that a test run is forcibly cancelled.\nconst RUN_CANCEL_DEADLINE = 10_000;\n\nconst enum TestRunTrackerState {\n\t// Default state\n\tRunning,\n\t// Cancellation is requested, but the run is still going.\n\tCancelling,\n\t// All tasks have ended\n\tEnded,\n}\n\nclass TestRunTracker extends Disposable {\n\tprivate state = TestRunTrackerState.Running;\n\tprivate running = 0;\n\tprivate readonly tasks = new Map</* task ID */string, { cts: CancellationTokenSource; run: vscode.TestRun }>();\n\tprivate readonly sharedTestIds = new Set<string>();\n\tprivate readonly cts: CancellationTokenSource;\n\tprivate readonly endEmitter = this._register(new Emitter<void>());\n\tprivate readonly onDidDispose: Event<void>;\n\tprivate readonly publishedCoverage = new Map<string, { report: vscode.FileCoverage; extIds: string[] }>();\n\n\t/**\n\t * Fires when a test ends, and no more tests are left running.\n\t */\n\tpublic readonly onEnd = this.endEmitter.event;\n\n\t/**\n\t * Gets whether there are any tests running.\n\t */\n\tpublic get hasRunningTasks() {\n\t\treturn this.running > 0;\n\t}\n\n\t/**\n\t * Gets the run ID.\n\t */\n\tpublic get id() {\n\t\treturn this.dto.id;\n\t}\n\n\tconstructor(\n\t\tprivate readonly dto: TestRunDto,\n\t\tprivate readonly proxy: MainThreadTestingShape,\n\t\tprivate readonly logService: ILogService,\n\t\tprivate readonly profile: vscode.TestRunProfile | undefined,\n\t\tprivate readonly extension: IExtensionDescription,\n\t\tparentToken?: CancellationToken,\n\t) {\n\t\tsuper();\n\t\tthis.cts = this._register(new CancellationTokenSource(parentToken));\n\n\t\tconst forciblyEnd = this._register(new RunOnceScheduler(() => this.forciblyEndTasks(), RUN_CANCEL_DEADLINE));\n\t\tthis._register(this.cts.token.onCancellationRequested(() => forciblyEnd.schedule()));\n\n\t\tconst didDisposeEmitter = new Emitter<void>();\n\t\tthis.onDidDispose = didDisposeEmitter.event;\n\t\tthis._register(toDisposable(() => {\n\t\t\tdidDisposeEmitter.fire();\n\t\t\tdidDisposeEmitter.dispose();\n\t\t}));\n\t}\n\n\t/** Gets the task ID from a test run object. */\n\tpublic getTaskIdForRun(run: vscode.TestRun) {\n\t\tfor (const [taskId, { run: r }] of this.tasks) {\n\t\t\tif (r === run) {\n\t\t\t\treturn taskId;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/** Requests cancellation of the run. On the second call, forces cancellation. */\n\tpublic cancel(taskId?: string) {\n\t\tif (taskId) {\n\t\t\tthis.tasks.get(taskId)?.cts.cancel();\n\t\t} else if (this.state === TestRunTrackerState.Running) {\n\t\t\tthis.cts.cancel();\n\t\t\tthis.state = TestRunTrackerState.Cancelling;\n\t\t} else if (this.state === TestRunTrackerState.Cancelling) {\n\t\t\tthis.forciblyEndTasks();\n\t\t}\n\t}\n\n\t/** Gets details for a previously-emitted coverage object. */\n\tpublic async getCoverageDetails(id: string, testId: string | undefined, token: CancellationToken): Promise<vscode.FileCoverageDetail[]> {\n\t\tconst [, taskId] = TestId.fromString(id).path; /** runId, taskId, URI */\n\t\tconst coverage = this.publishedCoverage.get(id);\n\t\tif (!coverage) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst { report, extIds } = coverage;\n\t\tconst task = this.tasks.get(taskId);\n\t\tif (!task) {\n\t\t\tthrow new Error('unreachable: run task was not found');\n\t\t}\n\n\t\tlet testItem: vscode.TestItem | undefined;\n\t\tif (testId && report instanceof FileCoverage) {\n\t\t\tconst index = extIds.indexOf(testId);\n\t\t\tif (index === -1) {\n\t\t\t\treturn []; // ??\n\t\t\t}\n\t\t\ttestItem = report.includesTests[index];\n\t\t}\n\n\t\tconst details = testItem\n\t\t\t? this.profile?.loadDetailedCoverageForTest?.(task.run, report, testItem, token)\n\t\t\t: this.profile?.loadDetailedCoverage?.(task.run, report, token);\n\n\t\treturn (await details) ?? [];\n\t}\n\n\t/** Creates the public test run interface to give to extensions. */\n\tpublic createRun(name: string | undefined): vscode.TestRun {\n\t\tconst runId = this.dto.id;\n\t\tconst ctrlId = this.dto.controllerId;\n\t\tconst taskId = generateUuid();\n\n\t\tconst guardTestMutation = <Args extends unknown[]>(fn: (test: vscode.TestItem, ...args: Args) => void) =>\n\t\t\t(test: vscode.TestItem, ...args: Args) => {\n\t\t\t\tif (ended) {\n\t\t\t\t\tthis.logService.warn(`Setting the state of test \"${test.id}\" is a no-op after the run ends.`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.ensureTestIsKnown(test);\n\t\t\t\tfn(test, ...args);\n\t\t\t};\n\n\t\tconst appendMessages = (test: vscode.TestItem, messages: vscode.TestMessage | readonly vscode.TestMessage[]) => {\n\t\t\tconst converted = messages instanceof Array\n\t\t\t\t? messages.map(Convert.TestMessage.from)\n\t\t\t\t: [Convert.TestMessage.from(messages)];\n\n\t\t\tif (test.uri && test.range) {\n\t\t\t\tconst defaultLocation: ILocationDto = { range: Convert.Range.from(test.range), uri: test.uri };\n\t\t\t\tfor (const message of converted) {\n\t\t\t\t\tmessage.location = message.location || defaultLocation;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.proxy.$appendTestMessagesInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), converted);\n\t\t};\n\n\t\tlet ended = false;\n\t\t// tasks are alive for as long as the tracker is alive, so simple this._register is fine:\n\t\tconst cts = this._register(new CancellationTokenSource(this.cts.token));\n\n\t\t// one-off map used to associate test items with incrementing IDs in `addCoverage`.\n\t\t// There's no need to include their entire ID, we just want to make sure they're\n\t\t// stable and unique. Normal map is okay since TestRun lifetimes are limited.\n\t\tconst run: vscode.TestRun = {\n\t\t\tisPersisted: this.dto.isPersisted,\n\t\t\ttoken: cts.token,\n\t\t\tname,\n\t\t\tonDidDispose: this.onDidDispose,\n\t\t\taddCoverage: (coverage) => {\n\t\t\t\tif (ended) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst includesTests = coverage instanceof FileCoverage ? coverage.includesTests : [];\n\t\t\t\tif (includesTests.length) {\n\t\t\t\t\tfor (const test of includesTests) {\n\t\t\t\t\t\tthis.ensureTestIsKnown(test);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst uriStr = coverage.uri.toString();\n\t\t\t\tconst id = new TestId([runId, taskId, uriStr]).toString();\n\t\t\t\t// it's a lil funky, but it's possible for a test item's ID to change after\n\t\t\t\t// it's been reported if it's rehomed under a different parent. Record its\n\t\t\t\t// ID at the time when the coverage report is generated so we can reference\n\t\t\t\t// it later if needeed.\n\t\t\t\tthis.publishedCoverage.set(id, { report: coverage, extIds: includesTests.map(t => TestId.fromExtHostTestItem(t, ctrlId).toString()) });\n\t\t\t\tthis.proxy.$appendCoverage(runId, taskId, Convert.TestCoverage.fromFile(ctrlId, id, coverage));\n\t\t\t},\n\t\t\t//#region state mutation\n\t\t\tenqueued: guardTestMutation(test => {\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), TestResultState.Queued);\n\t\t\t}),\n\t\t\tskipped: guardTestMutation(test => {\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), TestResultState.Skipped);\n\t\t\t}),\n\t\t\tstarted: guardTestMutation(test => {\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), TestResultState.Running);\n\t\t\t}),\n\t\t\terrored: guardTestMutation((test, messages, duration) => {\n\t\t\t\tappendMessages(test, messages);\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), TestResultState.Errored, duration);\n\t\t\t}),\n\t\t\tfailed: guardTestMutation((test, messages, duration) => {\n\t\t\t\tappendMessages(test, messages);\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), TestResultState.Failed, duration);\n\t\t\t}),\n\t\t\tpassed: guardTestMutation((test, duration) => {\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, this.dto.controllerId).toString(), TestResultState.Passed, duration);\n\t\t\t}),\n\t\t\t//#endregion\n\t\t\tappendOutput: (output, location?: vscode.Location, test?: vscode.TestItem) => {\n\t\t\t\tif (ended) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (test) {\n\t\t\t\t\tthis.ensureTestIsKnown(test);\n\t\t\t\t}\n\n\t\t\t\tthis.proxy.$appendOutputToRun(\n\t\t\t\t\trunId,\n\t\t\t\t\ttaskId,\n\t\t\t\t\tVSBuffer.fromString(output),\n\t\t\t\t\tlocation && Convert.location.from(location),\n\t\t\t\t\ttest && TestId.fromExtHostTestItem(test, ctrlId).toString(),\n\t\t\t\t);\n\t\t\t},\n\t\t\tend: () => {\n\t\t\t\tif (ended) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tended = true;\n\t\t\t\tthis.proxy.$finishedTestRunTask(runId, taskId);\n\t\t\t\tif (!--this.running) {\n\t\t\t\t\tthis.markEnded();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.running++;\n\t\tthis.tasks.set(taskId, { run, cts });\n\t\tthis.proxy.$startedTestRunTask(runId, {\n\t\t\tid: taskId,\n\t\t\tctrlId: this.dto.controllerId,\n\t\t\tname: name || this.extension.displayName || this.extension.identifier.value,\n\t\t\trunning: true,\n\t\t});\n\n\t\treturn run;\n\t}\n\n\tprivate forciblyEndTasks() {\n\t\tfor (const { run } of this.tasks.values()) {\n\t\t\trun.end();\n\t\t}\n\t}\n\n\tprivate markEnded() {\n\t\tif (this.state !== TestRunTrackerState.Ended) {\n\t\t\tthis.state = TestRunTrackerState.Ended;\n\t\t\tthis.endEmitter.fire();\n\t\t}\n\t}\n\n\tprivate ensureTestIsKnown(test: vscode.TestItem) {\n\t\tif (!(test instanceof TestItemImpl)) {\n\t\t\tthrow new InvalidTestItemError(test.id);\n\t\t}\n\n\t\tif (this.sharedTestIds.has(TestId.fromExtHostTestItem(test, this.dto.controllerId).toString())) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst chain: ITestItem.Serialized[] = [];\n\t\tconst root = this.dto.colllection.root;\n\t\twhile (true) {\n\t\t\tconst converted = Convert.TestItem.from(test as TestItemImpl);\n\t\t\tchain.unshift(converted);\n\n\t\t\tif (this.sharedTestIds.has(converted.extId)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.sharedTestIds.add(converted.extId);\n\t\t\tif (test === root) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttest = test.parent || root;\n\t\t}\n\n\t\tthis.proxy.$addTestsToRun(this.dto.controllerId, this.dto.id, chain);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis.markEnded();\n\t\tsuper.dispose();\n\t}\n}\n\n/**\n * Queues runs for a single extension and provides the currently-executing\n * run so that `createTestRun` can be properly correlated.\n */\nexport class TestRunCoordinator {\n\tprivate readonly tracked = new Map<vscode.TestRunRequest, TestRunTracker>();\n\tprivate readonly trackedById = new Map<string, TestRunTracker>();\n\n\tpublic get trackers() {\n\t\treturn this.tracked.values();\n\t}\n\n\tconstructor(\n\t\tprivate readonly proxy: MainThreadTestingShape,\n\t\tprivate readonly logService: ILogService,\n\t) { }\n\n\t/**\n\t * Gets a coverage report for a given run and task ID.\n\t */\n\tpublic getCoverageDetails(id: string, testId: string | undefined, token: vscode.CancellationToken) {\n\t\tconst runId = TestId.root(id);\n\t\treturn this.trackedById.get(runId)?.getCoverageDetails(id, testId, token) || [];\n\t}\n\n\t/**\n\t * Disposes the test run, called when the main thread is no longer interested\n\t * in associated data.\n\t */\n\tpublic disposeTestRun(runId: string) {\n\t\tthis.trackedById.get(runId)?.dispose();\n\t\tthis.trackedById.delete(runId);\n\t\tfor (const [req, { id }] of this.tracked) {\n\t\t\tif (id === runId) {\n\t\t\t\tthis.tracked.delete(req);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Registers a request as being invoked by the main thread, so\n\t * `$startedExtensionTestRun` is not invoked. The run must eventually\n\t * be cancelled manually.\n\t */\n\tpublic prepareForMainThreadTestRun(extension: IExtensionDescription, req: vscode.TestRunRequest, dto: TestRunDto, profile: vscode.TestRunProfile, token: CancellationToken) {\n\t\treturn this.getTracker(req, dto, profile, extension, token);\n\t}\n\n\t/**\n\t * Cancels an existing test run via its cancellation token.\n\t */\n\tpublic cancelRunById(runId: string, taskId?: string) {\n\t\tthis.trackedById.get(runId)?.cancel(taskId);\n\t}\n\n\t/**\n\t * Cancels an existing test run via its cancellation token.\n\t */\n\tpublic cancelAllRuns() {\n\t\tfor (const tracker of this.tracked.values()) {\n\t\t\ttracker.cancel();\n\t\t}\n\t}\n\n\t/**\n\t * Implements the public `createTestRun` API.\n\t */\n\tpublic createTestRun(extension: IExtensionDescription, controllerId: string, collection: ExtHostTestItemCollection, request: vscode.TestRunRequest, name: string | undefined, persist: boolean): vscode.TestRun {\n\t\tconst existing = this.tracked.get(request);\n\t\tif (existing) {\n\t\t\treturn existing.createRun(name);\n\t\t}\n\n\t\t// If there is not an existing tracked extension for the request, start\n\t\t// a new, detached session.\n\t\tconst dto = TestRunDto.fromPublic(controllerId, collection, request, persist);\n\t\tconst profile = tryGetProfileFromTestRunReq(request);\n\t\tthis.proxy.$startedExtensionTestRun({\n\t\t\tcontrollerId,\n\t\t\tcontinuous: !!request.continuous,\n\t\t\tprofile: profile && { group: Convert.TestRunProfileKind.from(profile.kind), id: profile.profileId },\n\t\t\texclude: request.exclude?.map(t => TestId.fromExtHostTestItem(t, collection.root.id).toString()) ?? [],\n\t\t\tid: dto.id,\n\t\t\tinclude: request.include?.map(t => TestId.fromExtHostTestItem(t, collection.root.id).toString()) ?? [collection.root.id],\n\t\t\tpreserveFocus: request.preserveFocus ?? true,\n\t\t\tpersist\n\t\t});\n\n\t\tconst tracker = this.getTracker(request, dto, request.profile, extension);\n\t\tEvent.once(tracker.onEnd)(() => {\n\t\t\tthis.proxy.$finishedExtensionTestRun(dto.id);\n\t\t});\n\n\t\treturn tracker.createRun(name);\n\t}\n\n\tprivate getTracker(req: vscode.TestRunRequest, dto: TestRunDto, profile: vscode.TestRunProfile | undefined, extension: IExtensionDescription, token?: CancellationToken) {\n\t\tconst tracker = new TestRunTracker(dto, this.proxy, this.logService, profile, extension, token);\n\t\tthis.tracked.set(req, tracker);\n\t\tthis.trackedById.set(tracker.id, tracker);\n\t\treturn tracker;\n\t}\n}\n\nconst tryGetProfileFromTestRunReq = (request: vscode.TestRunRequest) => {\n\tif (!request.profile) {\n\t\treturn undefined;\n\t}\n\n\tif (!(request.profile instanceof TestRunProfileImpl)) {\n\t\tthrow new Error(`TestRunRequest.profile is not an instance created from TestController.createRunProfile`);\n\t}\n\n\treturn request.profile;\n};\n\nexport class TestRunDto {\n\tpublic static fromPublic(controllerId: string, collection: ExtHostTestItemCollection, request: vscode.TestRunRequest, persist: boolean) {\n\t\treturn new TestRunDto(\n\t\t\tcontrollerId,\n\t\t\tgenerateUuid(),\n\t\t\tpersist,\n\t\t\tcollection,\n\t\t);\n\t}\n\n\tpublic static fromInternal(request: IStartControllerTests, collection: ExtHostTestItemCollection) {\n\t\treturn new TestRunDto(\n\t\t\trequest.controllerId,\n\t\t\trequest.runId,\n\t\t\ttrue,\n\t\t\tcollection,\n\t\t);\n\t}\n\n\tconstructor(\n\t\tpublic readonly controllerId: string,\n\t\tpublic readonly id: string,\n\t\tpublic readonly isPersisted: boolean,\n\t\tpublic readonly colllection: ExtHostTestItemCollection,\n\t) {\n\t}\n}\n\n/**\n * @private\n */\ninterface MirroredCollectionTestItem extends IncrementalTestCollectionItem {\n\trevived: vscode.TestItem;\n\tdepth: number;\n}\n\nclass MirroredChangeCollector implements IncrementalChangeCollector<MirroredCollectionTestItem> {\n\tprivate readonly added = new Set<MirroredCollectionTestItem>();\n\tprivate readonly updated = new Set<MirroredCollectionTestItem>();\n\tprivate readonly removed = new Set<MirroredCollectionTestItem>();\n\n\tprivate readonly alreadyRemoved = new Set<string>();\n\n\tpublic get isEmpty() {\n\t\treturn this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0;\n\t}\n\n\tconstructor(private readonly emitter: Emitter<vscode.TestsChangeEvent>) {\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic add(node: MirroredCollectionTestItem): void {\n\t\tthis.added.add(node);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic update(node: MirroredCollectionTestItem): void {\n\t\tObject.assign(node.revived, Convert.TestItem.toPlain(node.item));\n\t\tif (!this.added.has(node)) {\n\t\t\tthis.updated.add(node);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic remove(node: MirroredCollectionTestItem): void {\n\t\tif (this.added.has(node)) {\n\t\t\tthis.added.delete(node);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.updated.delete(node);\n\n\t\tconst parentId = TestId.parentId(node.item.extId);\n\t\tif (parentId && this.alreadyRemoved.has(parentId.toString())) {\n\t\t\tthis.alreadyRemoved.add(node.item.extId);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.removed.add(node);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getChangeEvent(): vscode.TestsChangeEvent {\n\t\tconst { added, updated, removed } = this;\n\t\treturn {\n\t\t\tget added() { return [...added].map(n => n.revived); },\n\t\t\tget updated() { return [...updated].map(n => n.revived); },\n\t\t\tget removed() { return [...removed].map(n => n.revived); },\n\t\t};\n\t}\n\n\tpublic complete() {\n\t\tif (!this.isEmpty) {\n\t\t\tthis.emitter.fire(this.getChangeEvent());\n\t\t}\n\t}\n}\n\n/**\n * Maintains tests in this extension host sent from the main thread.\n * @private\n */\nclass MirroredTestCollection extends AbstractIncrementalTestCollection<MirroredCollectionTestItem> {\n\tprivate changeEmitter = new Emitter<vscode.TestsChangeEvent>();\n\n\t/**\n\t * Change emitter that fires with the same semantics as `TestObserver.onDidChangeTests`.\n\t */\n\tpublic readonly onDidChangeTests = this.changeEmitter.event;\n\n\t/**\n\t * Gets a list of root test items.\n\t */\n\tpublic get rootTests() {\n\t\treturn this.roots;\n\t}\n\n\t/**\n\t *\n\t * If the test ID exists, returns its underlying ID.\n\t */\n\tpublic getMirroredTestDataById(itemId: string) {\n\t\treturn this.items.get(itemId);\n\t}\n\n\t/**\n\t * If the test item is a mirrored test item, returns its underlying ID.\n\t */\n\tpublic getMirroredTestDataByReference(item: vscode.TestItem) {\n\t\treturn this.items.get(item.id);\n\t}\n\n\t/**\n\t * @override\n\t */\n\tprotected createItem(item: InternalTestItem, parent?: MirroredCollectionTestItem): MirroredCollectionTestItem {\n\t\treturn {\n\t\t\t...item,\n\t\t\t// todo@connor4312: make this work well again with children\n\t\t\trevived: Convert.TestItem.toPlain(item.item) as vscode.TestItem,\n\t\t\tdepth: parent ? parent.depth + 1 : 0,\n\t\t\tchildren: new Set(),\n\t\t};\n\t}\n\n\t/**\n\t * @override\n\t */\n\tprotected override createChangeCollector() {\n\t\treturn new MirroredChangeCollector(this.changeEmitter);\n\t}\n}\n\nclass TestObservers {\n\tprivate current?: {\n\t\tobservers: number;\n\t\ttests: MirroredTestCollection;\n\t};\n\n\tconstructor(\n\t\tprivate readonly proxy: MainThreadTestingShape,\n\t) {\n\t}\n\n\tpublic checkout(): vscode.TestObserver {\n\t\tif (!this.current) {\n\t\t\tthis.current = this.createObserverData();\n\t\t}\n\n\t\tconst current = this.current;\n\t\tcurrent.observers++;\n\n\t\treturn {\n\t\t\tonDidChangeTest: current.tests.onDidChangeTests,\n\t\t\tget tests() { return [...current.tests.rootTests].map(t => t.revived); },\n\t\t\tdispose: createSingleCallFunction(() => {\n\t\t\t\tif (--current.observers === 0) {\n\t\t\t\t\tthis.proxy.$unsubscribeFromDiffs();\n\t\t\t\t\tthis.current = undefined;\n\t\t\t\t}\n\t\t\t}),\n\t\t};\n\t}\n\n\t/**\n\t * Gets the internal test data by its reference.\n\t */\n\tpublic getMirroredTestDataByReference(ref: vscode.TestItem) {\n\t\treturn this.current?.tests.getMirroredTestDataByReference(ref);\n\t}\n\n\t/**\n\t * Applies test diffs to the current set of observed tests.\n\t */\n\tpublic applyDiff(diff: TestsDiff) {\n\t\tthis.current?.tests.apply(diff);\n\t}\n\n\tprivate createObserverData() {\n\t\tconst tests = new MirroredTestCollection({ asCanonicalUri: u => u });\n\t\tthis.proxy.$subscribeToDiffs();\n\t\treturn { observers: 0, tests, };\n\t}\n}\n\nconst updateProfile = (impl: TestRunProfileImpl, proxy: MainThreadTestingShape, initial: ITestRunProfile | undefined, update: Partial<ITestRunProfile>) => {\n\tif (initial) {\n\t\tObject.assign(initial, update);\n\t} else {\n\t\tproxy.$updateTestRunConfig(impl.controllerId, impl.profileId, update);\n\t}\n};\n\nexport class TestRunProfileImpl extends TestRunProfileBase implements vscode.TestRunProfile {\n\treadonly #proxy: MainThreadTestingShape;\n\treadonly #activeProfiles: Set<number>;\n\treadonly #onDidChangeDefaultProfiles: Event<DefaultProfileChangeEvent>;\n\t#initialPublish?: ITestRunProfile;\n\t#profiles?: Map<number, vscode.TestRunProfile>;\n\tprivate _configureHandler?: (() => void);\n\n\tpublic get label() {\n\t\treturn this._label;\n\t}\n\n\tpublic set label(label: string) {\n\t\tif (label !== this._label) {\n\t\t\tthis._label = label;\n\t\t\tupdateProfile(this, this.#proxy, this.#initialPublish, { label });\n\t\t}\n\t}\n\n\tpublic get supportsContinuousRun() {\n\t\treturn this._supportsContinuousRun;\n\t}\n\n\tpublic set supportsContinuousRun(supports: boolean) {\n\t\tif (supports !== this._supportsContinuousRun) {\n\t\t\tthis._supportsContinuousRun = supports;\n\t\t\tupdateProfile(this, this.#proxy, this.#initialPublish, { supportsContinuousRun: supports });\n\t\t}\n\t}\n\n\tpublic get isDefault() {\n\t\treturn this.#activeProfiles.has(this.profileId);\n\t}\n\n\tpublic set isDefault(isDefault: boolean) {\n\t\tif (isDefault !== this.isDefault) {\n\t\t\t// #activeProfiles is synced from the main thread, so we can make\n\t\t\t// provisional changes here that will get confirmed momentarily\n\t\t\tif (isDefault) {\n\t\t\t\tthis.#activeProfiles.add(this.profileId);\n\t\t\t} else {\n\t\t\t\tthis.#activeProfiles.delete(this.profileId);\n\t\t\t}\n\n\t\t\tupdateProfile(this, this.#proxy, this.#initialPublish, { isDefault });\n\t\t}\n\t}\n\n\tpublic get tag() {\n\t\treturn this._tag;\n\t}\n\n\tpublic set tag(tag: vscode.TestTag | undefined) {\n\t\tif (tag?.id !== this._tag?.id) {\n\t\t\tthis._tag = tag;\n\t\t\tupdateProfile(this, this.#proxy, this.#initialPublish, {\n\t\t\t\ttag: tag ? Convert.TestTag.namespace(this.controllerId, tag.id) : null,\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic get configureHandler() {\n\t\treturn this._configureHandler;\n\t}\n\n\tpublic set configureHandler(handler: undefined | (() => void)) {\n\t\tif (handler !== this._configureHandler) {\n\t\t\tthis._configureHandler = handler;\n\t\t\tupdateProfile(this, this.#proxy, this.#initialPublish, { hasConfigurationHandler: !!handler });\n\t\t}\n\t}\n\n\tpublic get onDidChangeDefault() {\n\t\treturn Event.chain(this.#onDidChangeDefaultProfiles, $ => $\n\t\t\t.map(ev => ev.get(this.controllerId)?.get(this.profileId))\n\t\t\t.filter(isDefined)\n\t\t);\n\t}\n\n\tconstructor(\n\t\tproxy: MainThreadTestingShape,\n\t\tprofiles: Map<number, vscode.TestRunProfile>,\n\t\tactiveProfiles: Set<number>,\n\t\tonDidChangeActiveProfiles: Event<DefaultProfileChangeEvent>,\n\t\tcontrollerId: string,\n\t\tprofileId: number,\n\t\tprivate _label: string,\n\t\tkind: vscode.TestRunProfileKind,\n\t\tpublic runHandler: (request: vscode.TestRunRequest, token: vscode.CancellationToken) => Thenable<void> | void,\n\t\t_isDefault = false,\n\t\tpublic _tag: vscode.TestTag | undefined = undefined,\n\t\tprivate _supportsContinuousRun = false,\n\t) {\n\t\tsuper(controllerId, profileId, kind);\n\n\t\tthis.#proxy = proxy;\n\t\tthis.#profiles = profiles;\n\t\tthis.#activeProfiles = activeProfiles;\n\t\tthis.#onDidChangeDefaultProfiles = onDidChangeActiveProfiles;\n\t\tprofiles.set(profileId, this);\n\n\t\tconst groupBitset = Convert.TestRunProfileKind.from(kind);\n\t\tif (_isDefault) {\n\t\t\tactiveProfiles.add(profileId);\n\t\t}\n\n\t\tthis.#initialPublish = {\n\t\t\tprofileId: profileId,\n\t\t\tcontrollerId,\n\t\t\ttag: _tag ? Convert.TestTag.namespace(this.controllerId, _tag.id) : null,\n\t\t\tlabel: _label,\n\t\t\tgroup: groupBitset,\n\t\t\tisDefault: _isDefault,\n\t\t\thasConfigurationHandler: false,\n\t\t\tsupportsContinuousRun: _supportsContinuousRun,\n\t\t};\n\n\t\t// we send the initial profile publish out on the next microtask so that\n\t\t// initially setting the isDefault value doesn't overwrite a user-configured value\n\t\tqueueMicrotask(() => {\n\t\t\tif (this.#initialPublish) {\n\t\t\t\tthis.#proxy.$publishTestRunProfile(this.#initialPublish);\n\t\t\t\tthis.#initialPublish = undefined;\n\t\t\t}\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tif (this.#profiles?.delete(this.profileId)) {\n\t\t\tthis.#profiles = undefined;\n\t\t\tthis.#proxy.$removeTestProfile(this.controllerId, this.profileId);\n\t\t}\n\t\tthis.#initialPublish = undefined;\n\t}\n}\n\nfunction findTestInResultSnapshot(extId: TestId, snapshot: readonly Readonly<vscode.TestResultSnapshot>[]) {\n\tfor (let i = 0; i < extId.path.length; i++) {\n\t\tconst item = snapshot.find(s => s.id === extId.path[i]);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (i === extId.path.length - 1) {\n\t\t\treturn item;\n\t\t}\n\n\t\tsnapshot = item.children;\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* eslint-disable local/code-no-native-private */\n\nimport type * as vscode from 'vscode';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { createSingleCallFunction } from '../../../base/common/functional.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../base/common/lifecycle.js';\nimport { MarshalledId } from '../../../base/common/marshallingIds.js';\nimport { isDefined } from '../../../base/common/types.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { IPosition } from '../../../editor/common/core/position.js';\nimport { IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { TestCommandId } from '../../contrib/testing/common/constants.js';\nimport { TestId, TestPosition } from '../../contrib/testing/common/testId.js';\nimport { InvalidTestItemError } from '../../contrib/testing/common/testItemCollection.js';\nimport { AbstractIncrementalTestCollection, CoverageDetails, ICallProfileRunHandler, ISerializedTestResults, IStartControllerTests, IStartControllerTestsResult, ITestErrorMessage, ITestItem, ITestItemContext, ITestMessageMenuArgs, ITestRunProfile, IncrementalChangeCollector, IncrementalTestCollectionItem, InternalTestItem, TestControllerCapability, TestMessageFollowupRequest, TestMessageFollowupResponse, TestResultState, TestsDiff, TestsDiffOp, isStartControllerTests } from '../../contrib/testing/common/testTypes.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { ExtHostTestingShape, ILocationDto, MainContext, MainThreadTestingShape } from './extHost.protocol.js';\nimport { IExtHostCommands } from './extHostCommands.js';\nimport { IExtHostDocumentsAndEditors } from './extHostDocumentsAndEditors.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { ExtHostTestItemCollection, TestItemImpl, TestItemRootImpl, toItemFromContext } from './extHostTestItem.js';\nimport * as Convert from './extHostTypeConverters.js';\nimport { FileCoverage, TestRunProfileBase, TestRunRequest } from './extHostTypes.js';\n\ninterface ControllerInfo {\n\tcontroller: vscode.TestController;\n\tprofiles: Map<number, vscode.TestRunProfile>;\n\tcollection: ExtHostTestItemCollection;\n\textension: IExtensionDescription;\n\trelatedCodeProvider?: vscode.TestRelatedCodeProvider;\n\tactiveProfiles: Set<number>;\n}\n\ntype DefaultProfileChangeEvent = Map</* controllerId */ string, Map< /* profileId */number, boolean>>;\n\nlet followupCounter = 0;\n\nconst testResultInternalIDs = new WeakMap<vscode.TestRunResult, string>();\n\nexport const IExtHostTesting = createDecorator<IExtHostTesting>('IExtHostTesting');\nexport interface IExtHostTesting extends ExtHostTesting {\n\treadonly _serviceBrand: undefined;\n}\n\nexport class ExtHostTesting extends Disposable implements ExtHostTestingShape {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly resultsChangedEmitter = this._register(new Emitter<void>());\n\tprotected readonly controllers = new Map</* controller ID */ string, ControllerInfo>();\n\tprivate readonly proxy: MainThreadTestingShape;\n\tprivate readonly runTracker: TestRunCoordinator;\n\tprivate readonly observer: TestObservers;\n\tprivate readonly defaultProfilesChangedEmitter = this._register(new Emitter<DefaultProfileChangeEvent>());\n\tprivate readonly followupProviders = new Set<vscode.TestFollowupProvider>();\n\tprivate readonly testFollowups = new Map<number, vscode.Command>();\n\n\tpublic onResultsChanged = this.resultsChangedEmitter.event;\n\tpublic results: ReadonlyArray<vscode.TestRunResult> = [];\n\n\tconstructor(\n\t\t@IExtHostRpcService rpc: IExtHostRpcService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IExtHostCommands private readonly commands: IExtHostCommands,\n\t\t@IExtHostDocumentsAndEditors private readonly editors: IExtHostDocumentsAndEditors,\n\t) {\n\t\tsuper();\n\t\tthis.proxy = rpc.getProxy(MainContext.MainThreadTesting);\n\t\tthis.observer = new TestObservers(this.proxy);\n\t\tthis.runTracker = new TestRunCoordinator(this.proxy, logService);\n\n\t\tcommands.registerArgumentProcessor({\n\t\t\tprocessArgument: arg => {\n\t\t\t\tswitch (arg?.$mid) {\n\t\t\t\t\tcase MarshalledId.TestItemContext: {\n\t\t\t\t\t\tconst cast = arg as ITestItemContext;\n\t\t\t\t\t\tconst targetTest = cast.tests[cast.tests.length - 1].item.extId;\n\t\t\t\t\t\tconst controller = this.controllers.get(TestId.root(targetTest));\n\t\t\t\t\t\treturn controller?.collection.tree.get(targetTest)?.actual ?? toItemFromContext(arg);\n\t\t\t\t\t}\n\t\t\t\t\tcase MarshalledId.TestMessageMenuArgs: {\n\t\t\t\t\t\tconst { test, message } = arg as ITestMessageMenuArgs;\n\t\t\t\t\t\tconst extId = test.item.extId;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttest: this.controllers.get(TestId.root(extId))?.collection.tree.get(extId)?.actual\n\t\t\t\t\t\t\t\t?? toItemFromContext({ $mid: MarshalledId.TestItemContext, tests: [test] }),\n\t\t\t\t\t\t\tmessage: Convert.TestMessage.to(message as ITestErrorMessage.Serialized),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tdefault: return arg;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tcommands.registerCommand(false, 'testing.getExplorerSelection', async (): Promise<any> => {\n\t\t\tconst inner = await commands.executeCommand<{\n\t\t\t\tinclude: string[];\n\t\t\t\texclude: string[];\n\t\t\t}>(TestCommandId.GetExplorerSelection);\n\n\t\t\tconst lookup = (i: string) => {\n\t\t\t\tconst controller = this.controllers.get(TestId.root(i));\n\t\t\t\tif (!controller) { return undefined; }\n\t\t\t\treturn TestId.isRoot(i) ? controller.controller : controller.collection.tree.get(i)?.actual;\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\tinclude: inner?.include.map(lookup).filter(isDefined) || [],\n\t\t\t\texclude: inner?.exclude.map(lookup).filter(isDefined) || [],\n\t\t\t};\n\t\t});\n\t}\n\n\t//#region public API\n\n\t/**\n\t * Implements vscode.test.registerTestProvider\n\t */\n\tpublic createTestController(extension: IExtensionDescription, controllerId: string, label: string, refreshHandler?: (token: CancellationToken) => Thenable<void> | void): vscode.TestController {\n\t\tif (this.controllers.has(controllerId)) {\n\t\t\tthrow new Error(`Attempt to insert a duplicate controller with ID \"${controllerId}\"`);\n\t\t}\n\n\t\tconst disposable = new DisposableStore();\n\t\tconst collection = disposable.add(new ExtHostTestItemCollection(controllerId, label, this.editors));\n\t\tcollection.root.label = label;\n\n\t\tconst profiles = new Map<number, vscode.TestRunProfile>();\n\t\tconst activeProfiles = new Set<number>();\n\t\tconst proxy = this.proxy;\n\n\t\tconst getCapability = () => {\n\t\t\tlet cap = 0;\n\t\t\tif (refreshHandler) {\n\t\t\t\tcap |= TestControllerCapability.Refresh;\n\t\t\t}\n\t\t\tconst rcp = info.relatedCodeProvider;\n\t\t\tif (rcp) {\n\t\t\t\tif (rcp?.provideRelatedTests) {\n\t\t\t\t\tcap |= TestControllerCapability.TestRelatedToCode;\n\t\t\t\t}\n\t\t\t\tif (rcp?.provideRelatedCode) {\n\t\t\t\t\tcap |= TestControllerCapability.CodeRelatedToTest;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cap as TestControllerCapability;\n\t\t};\n\n\t\tconst controller: vscode.TestController = {\n\t\t\titems: collection.root.children,\n\t\t\tget label() {\n\t\t\t\treturn label;\n\t\t\t},\n\t\t\tset label(value: string) {\n\t\t\t\tlabel = value;\n\t\t\t\tcollection.root.label = value;\n\t\t\t\tproxy.$updateController(controllerId, { label });\n\t\t\t},\n\t\t\tget refreshHandler() {\n\t\t\t\treturn refreshHandler;\n\t\t\t},\n\t\t\tset refreshHandler(value: ((token: CancellationToken) => Thenable<void> | void) | undefined) {\n\t\t\t\trefreshHandler = value;\n\t\t\t\tproxy.$updateController(controllerId, { capabilities: getCapability() });\n\t\t\t},\n\t\t\tget id() {\n\t\t\t\treturn controllerId;\n\t\t\t},\n\t\t\tget relatedCodeProvider() {\n\t\t\t\treturn info.relatedCodeProvider;\n\t\t\t},\n\t\t\tset relatedCodeProvider(value: vscode.TestRelatedCodeProvider | undefined) {\n\t\t\t\tcheckProposedApiEnabled(extension, 'testRelatedCode');\n\t\t\t\tinfo.relatedCodeProvider = value;\n\t\t\t\tproxy.$updateController(controllerId, { capabilities: getCapability() });\n\t\t\t},\n\t\t\tcreateRunProfile: (label, group, runHandler, isDefault, tag?: vscode.TestTag | undefined, supportsContinuousRun?: boolean) => {\n\t\t\t\t// Derive the profile ID from a hash so that the same profile will tend\n\t\t\t\t// to have the same hashes, allowing re-run requests to work across reloads.\n\t\t\t\tlet profileId = hash(label);\n\t\t\t\twhile (profiles.has(profileId)) {\n\t\t\t\t\tprofileId++;\n\t\t\t\t}\n\n\t\t\t\treturn new TestRunProfileImpl(this.proxy, profiles, activeProfiles, this.defaultProfilesChangedEmitter.event, controllerId, profileId, label, group, runHandler, isDefault, tag, supportsContinuousRun);\n\t\t\t},\n\t\t\tcreateTestItem(id, label, uri) {\n\t\t\t\treturn new TestItemImpl(controllerId, id, label, uri);\n\t\t\t},\n\t\t\tcreateTestRun: (request, name, persist = true) => {\n\t\t\t\treturn this.runTracker.createTestRun(extension, controllerId, collection, request, name, persist);\n\t\t\t},\n\t\t\tinvalidateTestResults: items => {\n\t\t\t\tif (items === undefined) {\n\t\t\t\t\tthis.proxy.$markTestRetired(undefined);\n\t\t\t\t} else {\n\t\t\t\t\tconst itemsArr = items instanceof Array ? items : [items];\n\t\t\t\t\tthis.proxy.$markTestRetired(itemsArr.map(i => TestId.fromExtHostTestItem(i!, controllerId).toString()));\n\t\t\t\t}\n\t\t\t},\n\t\t\tset resolveHandler(fn) {\n\t\t\t\tcollection.resolveHandler = fn;\n\t\t\t},\n\t\t\tget resolveHandler() {\n\t\t\t\treturn collection.resolveHandler as undefined | ((item?: vscode.TestItem) => void);\n\t\t\t},\n\t\t\tdispose: () => {\n\t\t\t\tdisposable.dispose();\n\t\t\t},\n\t\t};\n\n\t\tconst info: ControllerInfo = { controller, collection, profiles, extension, activeProfiles };\n\t\tproxy.$registerTestController(controllerId, label, getCapability());\n\t\tdisposable.add(toDisposable(() => proxy.$unregisterTestController(controllerId)));\n\n\t\tthis.controllers.set(controllerId, info);\n\t\tdisposable.add(toDisposable(() => this.controllers.delete(controllerId)));\n\n\t\tdisposable.add(collection.onDidGenerateDiff(diff => proxy.$publishDiff(controllerId, diff.map(TestsDiffOp.serialize))));\n\n\t\treturn controller;\n\t}\n\n\t/**\n\t * Implements vscode.test.createTestObserver\n\t */\n\tpublic createTestObserver() {\n\t\treturn this.observer.checkout();\n\t}\n\n\n\t/**\n\t * Implements vscode.test.runTests\n\t */\n\tpublic async runTests(req: vscode.TestRunRequest, token = CancellationToken.None) {\n\t\tconst profile = tryGetProfileFromTestRunReq(req);\n\t\tif (!profile) {\n\t\t\tthrow new Error('The request passed to `vscode.test.runTests` must include a profile');\n\t\t}\n\n\t\tconst controller = this.controllers.get(profile.controllerId);\n\t\tif (!controller) {\n\t\t\tthrow new Error('Controller not found');\n\t\t}\n\n\t\tawait this.proxy.$runTests({\n\t\t\tpreserveFocus: req.preserveFocus ?? true,\n\t\t\tgroup: Convert.TestRunProfileKind.from(profile.kind),\n\t\t\ttargets: [{\n\t\t\t\ttestIds: req.include?.map(t => TestId.fromExtHostTestItem(t, controller.collection.root.id).toString()) ?? [controller.collection.root.id],\n\t\t\t\tprofileId: profile.profileId,\n\t\t\t\tcontrollerId: profile.controllerId,\n\t\t\t}],\n\t\t\texclude: req.exclude?.map(t => t.id),\n\t\t}, token);\n\t}\n\n\t/**\n\t * Implements vscode.test.registerTestFollowupProvider\n\t */\n\tpublic registerTestFollowupProvider(provider: vscode.TestFollowupProvider): vscode.Disposable {\n\t\tthis.followupProviders.add(provider);\n\t\treturn { dispose: () => { this.followupProviders.delete(provider); } };\n\t}\n\n\t//#endregion\n\n\t//#region RPC methods\n\t/**\n\t * @inheritdoc\n\t */\n\tasync $getTestsRelatedToCode(uri: UriComponents, _position: IPosition, token: CancellationToken): Promise<string[]> {\n\t\tconst doc = this.editors.getDocument(URI.revive(uri));\n\t\tif (!doc) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst position = Convert.Position.to(_position);\n\t\tconst related: string[] = [];\n\t\tawait Promise.all([...this.controllers.values()].map(async (c) => {\n\t\t\tlet tests: vscode.TestItem[] | undefined | null;\n\t\t\ttry {\n\t\t\t\ttests = await c.relatedCodeProvider?.provideRelatedTests?.(doc.document, position, token);\n\t\t\t} catch (e) {\n\t\t\t\tif (!token.isCancellationRequested) {\n\t\t\t\t\tthis.logService.warn(`Error thrown while providing related tests for ${c.controller.label}`, e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tests) {\n\t\t\t\tfor (const test of tests) {\n\t\t\t\t\trelated.push(TestId.fromExtHostTestItem(test, c.controller.id).toString());\n\t\t\t\t}\n\t\t\t\tc.collection.flushDiff();\n\t\t\t}\n\t\t}));\n\n\t\treturn related;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tasync $getCodeRelatedToTest(testId: string, token: CancellationToken): Promise<ILocationDto[]> {\n\t\tconst controller = this.controllers.get(TestId.root(testId));\n\t\tif (!controller) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst test = controller.collection.tree.get(testId);\n\t\tif (!test) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst locations = await controller.relatedCodeProvider?.provideRelatedCode?.(test.actual, token);\n\t\treturn locations?.map(Convert.location.from) ?? [];\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\t$syncTests(): Promise<void> {\n\t\tfor (const { collection } of this.controllers.values()) {\n\t\t\tcollection.flushDiff();\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tasync $getCoverageDetails(coverageId: string, testId: string | undefined, token: CancellationToken): Promise<CoverageDetails.Serialized[]> {\n\t\tconst details = await this.runTracker.getCoverageDetails(coverageId, testId, token);\n\t\treturn details?.map(Convert.TestCoverage.fromDetails);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tasync $disposeRun(runId: string) {\n\t\tthis.runTracker.disposeTestRun(runId);\n\t}\n\n\t/** @inheritdoc */\n\t$configureRunProfile(controllerId: string, profileId: number) {\n\t\tthis.controllers.get(controllerId)?.profiles.get(profileId)?.configureHandler?.();\n\t}\n\n\t/** @inheritdoc */\n\t$setDefaultRunProfiles(profiles: Record</* controller id */string, /* profile id */ number[]>): void {\n\t\tconst evt: DefaultProfileChangeEvent = new Map();\n\t\tfor (const [controllerId, profileIds] of Object.entries(profiles)) {\n\t\t\tconst ctrl = this.controllers.get(controllerId);\n\t\t\tif (!ctrl) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst changes = new Map<number, boolean>();\n\t\t\tconst added = profileIds.filter(id => !ctrl.activeProfiles.has(id));\n\t\t\tconst removed = [...ctrl.activeProfiles].filter(id => !profileIds.includes(id));\n\t\t\tfor (const id of added) {\n\t\t\t\tchanges.set(id, true);\n\t\t\t\tctrl.activeProfiles.add(id);\n\t\t\t}\n\t\t\tfor (const id of removed) {\n\t\t\t\tchanges.set(id, false);\n\t\t\t\tctrl.activeProfiles.delete(id);\n\t\t\t}\n\t\t\tif (changes.size) {\n\t\t\t\tevt.set(controllerId, changes);\n\t\t\t}\n\t\t}\n\n\t\tthis.defaultProfilesChangedEmitter.fire(evt);\n\t}\n\n\t/** @inheritdoc */\n\tasync $refreshTests(controllerId: string, token: CancellationToken) {\n\t\tawait this.controllers.get(controllerId)?.controller.refreshHandler?.(token);\n\t}\n\n\t/**\n\t * Updates test results shown to extensions.\n\t * @override\n\t */\n\tpublic $publishTestResults(results: ISerializedTestResults[]): void {\n\t\tthis.results = Object.freeze(\n\t\t\tresults\n\t\t\t\t.map(r => {\n\t\t\t\t\tconst o = Convert.TestResults.to(r);\n\t\t\t\t\tconst taskWithCoverage = r.tasks.findIndex(t => t.hasCoverage);\n\t\t\t\t\tif (taskWithCoverage !== -1) {\n\t\t\t\t\t\to.getDetailedCoverage = (uri, token = CancellationToken.None) =>\n\t\t\t\t\t\t\tthis.proxy.$getCoverageDetails(r.id, taskWithCoverage, uri, token).then(r => r.map(Convert.TestCoverage.to));\n\t\t\t\t\t}\n\n\t\t\t\t\ttestResultInternalIDs.set(o, r.id);\n\t\t\t\t\treturn o;\n\t\t\t\t})\n\t\t\t\t.concat(this.results)\n\t\t\t\t.sort((a, b) => b.completedAt - a.completedAt)\n\t\t\t\t.slice(0, 32),\n\t\t);\n\n\t\tthis.resultsChangedEmitter.fire();\n\t}\n\n\t/**\n\t * Expands the nodes in the test tree. If levels is less than zero, it will\n\t * be treated as infinite.\n\t */\n\tpublic async $expandTest(testId: string, levels: number) {\n\t\tconst collection = this.controllers.get(TestId.fromString(testId).controllerId)?.collection;\n\t\tif (collection) {\n\t\t\tawait collection.expand(testId, levels < 0 ? Infinity : levels);\n\t\t\tcollection.flushDiff();\n\t\t}\n\t}\n\n\t/**\n\t * Receives a test update from the main thread. Called (eventually) whenever\n\t * tests change.\n\t */\n\tpublic $acceptDiff(diff: TestsDiffOp.Serialized[]): void {\n\t\tthis.observer.applyDiff(diff.map(d => TestsDiffOp.deserialize({ asCanonicalUri: u => u }, d)));\n\t}\n\n\t/**\n\t * Runs tests with the given set of IDs. Allows for test from multiple\n\t * providers to be run.\n\t * @inheritdoc\n\t */\n\tpublic async $runControllerTests(reqs: IStartControllerTests[], token: CancellationToken): Promise<IStartControllerTestsResult[]> {\n\t\treturn Promise.all(reqs.map(req => this.runControllerTestRequest(req, false, token)));\n\t}\n\n\t/**\n\t * Starts continuous test runs with the given set of IDs. Allows for test from\n\t * multiple providers to be run.\n\t * @inheritdoc\n\t */\n\tpublic async $startContinuousRun(reqs: IStartControllerTests[], token: CancellationToken): Promise<IStartControllerTestsResult[]> {\n\t\tconst cts = new CancellationTokenSource(token);\n\t\tconst res = await Promise.all(reqs.map(req => this.runControllerTestRequest(req, true, cts.token)));\n\n\t\t// avoid returning until cancellation is requested, otherwise ipc disposes of the token\n\t\tif (!token.isCancellationRequested && !res.some(r => r.error)) {\n\t\t\tawait new Promise(r => token.onCancellationRequested(r));\n\t\t}\n\n\t\tcts.dispose(true);\n\t\treturn res;\n\t}\n\n\t/** @inheritdoc */\n\tpublic async $provideTestFollowups(req: TestMessageFollowupRequest, token: CancellationToken): Promise<TestMessageFollowupResponse[]> {\n\t\tconst results = this.results.find(r => testResultInternalIDs.get(r) === req.resultId);\n\t\tconst test = results && findTestInResultSnapshot(TestId.fromString(req.extId), results?.results);\n\t\tif (!test) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet followups: vscode.Command[] = [];\n\t\tawait Promise.all([...this.followupProviders].map(async provider => {\n\t\t\ttry {\n\t\t\t\tconst r = await provider.provideFollowup(results, test, req.taskIndex, req.messageIndex, token);\n\t\t\t\tif (r) {\n\t\t\t\t\tfollowups = followups.concat(r);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis.logService.error(`Error thrown while providing followup for test message`, e);\n\t\t\t}\n\t\t}));\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn followups.map(command => {\n\t\t\tconst id = followupCounter++;\n\t\t\tthis.testFollowups.set(id, command);\n\t\t\treturn { title: command.title, id };\n\t\t});\n\t}\n\n\t$disposeTestFollowups(id: number[]): void {\n\t\tfor (const i of id) {\n\t\t\tthis.testFollowups.delete(i);\n\t\t}\n\t}\n\n\t$executeTestFollowup(id: number): Promise<void> {\n\t\tconst command = this.testFollowups.get(id);\n\t\tif (!command) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn this.commands.executeCommand(command.command, ...(command.arguments || []));\n\t}\n\n\t/**\n\t * Cancels an ongoing test run.\n\t */\n\tpublic $cancelExtensionTestRun(runId: string | undefined, taskId: string | undefined) {\n\t\tif (runId === undefined) {\n\t\t\tthis.runTracker.cancelAllRuns();\n\t\t} else {\n\t\t\tthis.runTracker.cancelRunById(runId, taskId);\n\t\t}\n\t}\n\n\t//#endregion\n\n\tpublic getMetadataForRun(run: vscode.TestRun) {\n\t\tfor (const tracker of this.runTracker.trackers) {\n\t\t\tconst taskId = tracker.getTaskIdForRun(run);\n\t\t\tif (taskId) {\n\t\t\t\treturn { taskId, runId: tracker.id };\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async runControllerTestRequest(req: ICallProfileRunHandler | ICallProfileRunHandler, isContinuous: boolean, token: CancellationToken): Promise<IStartControllerTestsResult> {\n\t\tconst lookup = this.controllers.get(req.controllerId);\n\t\tif (!lookup) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst { collection, profiles, extension } = lookup;\n\t\tconst profile = profiles.get(req.profileId);\n\t\tif (!profile) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst includeTests = req.testIds\n\t\t\t.map((testId) => collection.tree.get(testId))\n\t\t\t.filter(isDefined);\n\n\t\tconst excludeTests = req.excludeExtIds\n\t\t\t.map(id => lookup.collection.tree.get(id))\n\t\t\t.filter(isDefined)\n\t\t\t.filter(exclude => includeTests.some(\n\t\t\t\tinclude => include.fullId.compare(exclude.fullId) === TestPosition.IsChild,\n\t\t\t));\n\n\t\tif (!includeTests.length) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst publicReq = new TestRunRequest(\n\t\t\tincludeTests.some(i => i.actual instanceof TestItemRootImpl) ? undefined : includeTests.map(t => t.actual),\n\t\t\texcludeTests.map(t => t.actual),\n\t\t\tprofile,\n\t\t\tisContinuous,\n\t\t);\n\n\t\tconst tracker = isStartControllerTests(req) && this.runTracker.prepareForMainThreadTestRun(\n\t\t\textension,\n\t\t\tpublicReq,\n\t\t\tTestRunDto.fromInternal(req, lookup.collection),\n\t\t\tprofile,\n\t\t\ttoken,\n\t\t);\n\n\t\ttry {\n\t\t\tawait profile.runHandler(publicReq, token);\n\t\t\treturn {};\n\t\t} catch (e) {\n\t\t\treturn { error: String(e) };\n\t\t} finally {\n\t\t\tif (tracker) {\n\t\t\t\tif (tracker.hasRunningTasks && !token.isCancellationRequested) {\n\t\t\t\t\tawait Event.toPromise(tracker.onEnd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Deadline after being requested by a user that a test run is forcibly cancelled.\nconst RUN_CANCEL_DEADLINE = 10_000;\n\nconst enum TestRunTrackerState {\n\t// Default state\n\tRunning,\n\t// Cancellation is requested, but the run is still going.\n\tCancelling,\n\t// All tasks have ended\n\tEnded,\n}\n\nclass TestRunTracker extends Disposable {\n\tprivate state = TestRunTrackerState.Running;\n\tprivate running = 0;\n\tprivate readonly tasks = new Map</* task ID */string, { cts: CancellationTokenSource; run: vscode.TestRun }>();\n\tprivate readonly sharedTestIds = new Set<string>();\n\tprivate readonly cts: CancellationTokenSource;\n\tprivate readonly endEmitter = this._register(new Emitter<void>());\n\tprivate readonly onDidDispose: Event<void>;\n\tprivate readonly publishedCoverage = new Map<string, { report: vscode.FileCoverage; extIds: string[] }>();\n\n\t/**\n\t * Fires when a test ends, and no more tests are left running.\n\t */\n\tpublic readonly onEnd = this.endEmitter.event;\n\n\t/**\n\t * Gets whether there are any tests running.\n\t */\n\tpublic get hasRunningTasks() {\n\t\treturn this.running > 0;\n\t}\n\n\t/**\n\t * Gets the run ID.\n\t */\n\tpublic get id() {\n\t\treturn this.dto.id;\n\t}\n\n\tconstructor(\n\t\tprivate readonly dto: TestRunDto,\n\t\tprivate readonly proxy: MainThreadTestingShape,\n\t\tprivate readonly logService: ILogService,\n\t\tprivate readonly profile: vscode.TestRunProfile | undefined,\n\t\tprivate readonly extension: IExtensionDescription,\n\t\tparentToken?: CancellationToken,\n\t) {\n\t\tsuper();\n\t\tthis.cts = this._register(new CancellationTokenSource(parentToken));\n\n\t\tconst forciblyEnd = this._register(new RunOnceScheduler(() => this.forciblyEndTasks(), RUN_CANCEL_DEADLINE));\n\t\tthis._register(this.cts.token.onCancellationRequested(() => forciblyEnd.schedule()));\n\n\t\tconst didDisposeEmitter = new Emitter<void>();\n\t\tthis.onDidDispose = didDisposeEmitter.event;\n\t\tthis._register(toDisposable(() => {\n\t\t\tdidDisposeEmitter.fire();\n\t\t\tdidDisposeEmitter.dispose();\n\t\t}));\n\t}\n\n\t/** Gets the task ID from a test run object. */\n\tpublic getTaskIdForRun(run: vscode.TestRun) {\n\t\tfor (const [taskId, { run: r }] of this.tasks) {\n\t\t\tif (r === run) {\n\t\t\t\treturn taskId;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/** Requests cancellation of the run. On the second call, forces cancellation. */\n\tpublic cancel(taskId?: string) {\n\t\tif (taskId) {\n\t\t\tthis.tasks.get(taskId)?.cts.cancel();\n\t\t} else if (this.state === TestRunTrackerState.Running) {\n\t\t\tthis.cts.cancel();\n\t\t\tthis.state = TestRunTrackerState.Cancelling;\n\t\t} else if (this.state === TestRunTrackerState.Cancelling) {\n\t\t\tthis.forciblyEndTasks();\n\t\t}\n\t}\n\n\t/** Gets details for a previously-emitted coverage object. */\n\tpublic async getCoverageDetails(id: string, testId: string | undefined, token: CancellationToken): Promise<vscode.FileCoverageDetail[]> {\n\t\tconst [, taskId] = TestId.fromString(id).path; /** runId, taskId, URI */\n\t\tconst coverage = this.publishedCoverage.get(id);\n\t\tif (!coverage) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst { report, extIds } = coverage;\n\t\tconst task = this.tasks.get(taskId);\n\t\tif (!task) {\n\t\t\tthrow new Error('unreachable: run task was not found');\n\t\t}\n\n\t\tlet testItem: vscode.TestItem | undefined;\n\t\tif (testId && report instanceof FileCoverage) {\n\t\t\tconst index = extIds.indexOf(testId);\n\t\t\tif (index === -1) {\n\t\t\t\treturn []; // ??\n\t\t\t}\n\t\t\ttestItem = report.includesTests[index];\n\t\t}\n\n\t\tconst details = testItem\n\t\t\t? this.profile?.loadDetailedCoverageForTest?.(task.run, report, testItem, token)\n\t\t\t: this.profile?.loadDetailedCoverage?.(task.run, report, token);\n\n\t\treturn (await details) ?? [];\n\t}\n\n\t/** Creates the public test run interface to give to extensions. */\n\tpublic createRun(name: string | undefined): vscode.TestRun {\n\t\tconst runId = this.dto.id;\n\t\tconst ctrlId = this.dto.controllerId;\n\t\tconst taskId = generateUuid();\n\n\t\tconst guardTestMutation = <Args extends unknown[]>(fn: (test: vscode.TestItem, ...args: Args) => void) =>\n\t\t\t(test: vscode.TestItem, ...args: Args) => {\n\t\t\t\tif (ended) {\n\t\t\t\t\tthis.logService.warn(`Setting the state of test \"${test.id}\" is a no-op after the run ends.`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.ensureTestIsKnown(test);\n\t\t\t\tfn(test, ...args);\n\t\t\t};\n\n\t\tconst appendMessages = (test: vscode.TestItem, messages: vscode.TestMessage | readonly vscode.TestMessage[]) => {\n\t\t\tconst converted = messages instanceof Array\n\t\t\t\t? messages.map(Convert.TestMessage.from)\n\t\t\t\t: [Convert.TestMessage.from(messages)];\n\n\t\t\tif (test.uri && test.range) {\n\t\t\t\tconst defaultLocation: ILocationDto = { range: Convert.Range.from(test.range), uri: test.uri };\n\t\t\t\tfor (const message of converted) {\n\t\t\t\t\tmessage.location = message.location || defaultLocation;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.proxy.$appendTestMessagesInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), converted);\n\t\t};\n\n\t\tlet ended = false;\n\t\t// tasks are alive for as long as the tracker is alive, so simple this._register is fine:\n\t\tconst cts = this._register(new CancellationTokenSource(this.cts.token));\n\n\t\t// one-off map used to associate test items with incrementing IDs in `addCoverage`.\n\t\t// There's no need to include their entire ID, we just want to make sure they're\n\t\t// stable and unique. Normal map is okay since TestRun lifetimes are limited.\n\t\tconst run: vscode.TestRun = {\n\t\t\tisPersisted: this.dto.isPersisted,\n\t\t\ttoken: cts.token,\n\t\t\tname,\n\t\t\tonDidDispose: this.onDidDispose,\n\t\t\taddCoverage: (coverage) => {\n\t\t\t\tif (ended) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst includesTests = coverage instanceof FileCoverage ? coverage.includesTests : [];\n\t\t\t\tif (includesTests.length) {\n\t\t\t\t\tfor (const test of includesTests) {\n\t\t\t\t\t\tthis.ensureTestIsKnown(test);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst uriStr = coverage.uri.toString();\n\t\t\t\tconst id = new TestId([runId, taskId, uriStr]).toString();\n\t\t\t\t// it's a lil funky, but it's possible for a test item's ID to change after\n\t\t\t\t// it's been reported if it's rehomed under a different parent. Record its\n\t\t\t\t// ID at the time when the coverage report is generated so we can reference\n\t\t\t\t// it later if needeed.\n\t\t\t\tthis.publishedCoverage.set(id, { report: coverage, extIds: includesTests.map(t => TestId.fromExtHostTestItem(t, ctrlId).toString()) });\n\t\t\t\tthis.proxy.$appendCoverage(runId, taskId, Convert.TestCoverage.fromFile(ctrlId, id, coverage));\n\t\t\t},\n\t\t\t//#region state mutation\n\t\t\tenqueued: guardTestMutation(test => {\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), TestResultState.Queued);\n\t\t\t}),\n\t\t\tskipped: guardTestMutation(test => {\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), TestResultState.Skipped);\n\t\t\t}),\n\t\t\tstarted: guardTestMutation(test => {\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), TestResultState.Running);\n\t\t\t}),\n\t\t\terrored: guardTestMutation((test, messages, duration) => {\n\t\t\t\tappendMessages(test, messages);\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), TestResultState.Errored, duration);\n\t\t\t}),\n\t\t\tfailed: guardTestMutation((test, messages, duration) => {\n\t\t\t\tappendMessages(test, messages);\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, ctrlId).toString(), TestResultState.Failed, duration);\n\t\t\t}),\n\t\t\tpassed: guardTestMutation((test, duration) => {\n\t\t\t\tthis.proxy.$updateTestStateInRun(runId, taskId, TestId.fromExtHostTestItem(test, this.dto.controllerId).toString(), TestResultState.Passed, duration);\n\t\t\t}),\n\t\t\t//#endregion\n\t\t\tappendOutput: (output, location?: vscode.Location, test?: vscode.TestItem) => {\n\t\t\t\tif (ended) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (test) {\n\t\t\t\t\tthis.ensureTestIsKnown(test);\n\t\t\t\t}\n\n\t\t\t\tthis.proxy.$appendOutputToRun(\n\t\t\t\t\trunId,\n\t\t\t\t\ttaskId,\n\t\t\t\t\tVSBuffer.fromString(output),\n\t\t\t\t\tlocation && Convert.location.from(location),\n\t\t\t\t\ttest && TestId.fromExtHostTestItem(test, ctrlId).toString(),\n\t\t\t\t);\n\t\t\t},\n\t\t\tend: () => {\n\t\t\t\tif (ended) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tended = true;\n\t\t\t\tthis.proxy.$finishedTestRunTask(runId, taskId);\n\t\t\t\tif (!--this.running) {\n\t\t\t\t\tthis.markEnded();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.running++;\n\t\tthis.tasks.set(taskId, { run, cts });\n\t\tthis.proxy.$startedTestRunTask(runId, {\n\t\t\tid: taskId,\n\t\t\tctrlId: this.dto.controllerId,\n\t\t\tname: name || this.extension.displayName || this.extension.identifier.value,\n\t\t\trunning: true,\n\t\t});\n\n\t\treturn run;\n\t}\n\n\tprivate forciblyEndTasks() {\n\t\tfor (const { run } of this.tasks.values()) {\n\t\t\trun.end();\n\t\t}\n\t}\n\n\tprivate markEnded() {\n\t\tif (this.state !== TestRunTrackerState.Ended) {\n\t\t\tthis.state = TestRunTrackerState.Ended;\n\t\t\tthis.endEmitter.fire();\n\t\t}\n\t}\n\n\tprivate ensureTestIsKnown(test: vscode.TestItem) {\n\t\tif (!(test instanceof TestItemImpl)) {\n\t\t\tthrow new InvalidTestItemError(test.id);\n\t\t}\n\n\t\tif (this.sharedTestIds.has(TestId.fromExtHostTestItem(test, this.dto.controllerId).toString())) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst chain: ITestItem.Serialized[] = [];\n\t\tconst root = this.dto.colllection.root;\n\t\twhile (true) {\n\t\t\tconst converted = Convert.TestItem.from(test as TestItemImpl);\n\t\t\tchain.unshift(converted);\n\n\t\t\tif (this.sharedTestIds.has(converted.extId)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.sharedTestIds.add(converted.extId);\n\t\t\tif (test === root) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttest = test.parent || root;\n\t\t}\n\n\t\tthis.proxy.$addTestsToRun(this.dto.controllerId, this.dto.id, chain);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis.markEnded();\n\t\tsuper.dispose();\n\t}\n}\n\n/**\n * Queues runs for a single extension and provides the currently-executing\n * run so that `createTestRun` can be properly correlated.\n */\nexport class TestRunCoordinator {\n\tprivate readonly tracked = new Map<vscode.TestRunRequest, TestRunTracker>();\n\tprivate readonly trackedById = new Map<string, TestRunTracker>();\n\n\tpublic get trackers() {\n\t\treturn this.tracked.values();\n\t}\n\n\tconstructor(\n\t\tprivate readonly proxy: MainThreadTestingShape,\n\t\tprivate readonly logService: ILogService,\n\t) { }\n\n\t/**\n\t * Gets a coverage report for a given run and task ID.\n\t */\n\tpublic getCoverageDetails(id: string, testId: string | undefined, token: vscode.CancellationToken) {\n\t\tconst runId = TestId.root(id);\n\t\treturn this.trackedById.get(runId)?.getCoverageDetails(id, testId, token) || [];\n\t}\n\n\t/**\n\t * Disposes the test run, called when the main thread is no longer interested\n\t * in associated data.\n\t */\n\tpublic disposeTestRun(runId: string) {\n\t\tthis.trackedById.get(runId)?.dispose();\n\t\tthis.trackedById.delete(runId);\n\t\tfor (const [req, { id }] of this.tracked) {\n\t\t\tif (id === runId) {\n\t\t\t\tthis.tracked.delete(req);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Registers a request as being invoked by the main thread, so\n\t * `$startedExtensionTestRun` is not invoked. The run must eventually\n\t * be cancelled manually.\n\t */\n\tpublic prepareForMainThreadTestRun(extension: IExtensionDescription, req: vscode.TestRunRequest, dto: TestRunDto, profile: vscode.TestRunProfile, token: CancellationToken) {\n\t\treturn this.getTracker(req, dto, profile, extension, token);\n\t}\n\n\t/**\n\t * Cancels an existing test run via its cancellation token.\n\t */\n\tpublic cancelRunById(runId: string, taskId?: string) {\n\t\tthis.trackedById.get(runId)?.cancel(taskId);\n\t}\n\n\t/**\n\t * Cancels an existing test run via its cancellation token.\n\t */\n\tpublic cancelAllRuns() {\n\t\tfor (const tracker of this.tracked.values()) {\n\t\t\ttracker.cancel();\n\t\t}\n\t}\n\n\t/**\n\t * Implements the public `createTestRun` API.\n\t */\n\tpublic createTestRun(extension: IExtensionDescription, controllerId: string, collection: ExtHostTestItemCollection, request: vscode.TestRunRequest, name: string | undefined, persist: boolean): vscode.TestRun {\n\t\tconst existing = this.tracked.get(request);\n\t\tif (existing) {\n\t\t\treturn existing.createRun(name);\n\t\t}\n\n\t\t// If there is not an existing tracked extension for the request, start\n\t\t// a new, detached session.\n\t\tconst dto = TestRunDto.fromPublic(controllerId, collection, request, persist);\n\t\tconst profile = tryGetProfileFromTestRunReq(request);\n\t\tthis.proxy.$startedExtensionTestRun({\n\t\t\tcontrollerId,\n\t\t\tcontinuous: !!request.continuous,\n\t\t\tprofile: profile && { group: Convert.TestRunProfileKind.from(profile.kind), id: profile.profileId },\n\t\t\texclude: request.exclude?.map(t => TestId.fromExtHostTestItem(t, collection.root.id).toString()) ?? [],\n\t\t\tid: dto.id,\n\t\t\tinclude: request.include?.map(t => TestId.fromExtHostTestItem(t, collection.root.id).toString()) ?? [collection.root.id],\n\t\t\tpreserveFocus: request.preserveFocus ?? true,\n\t\t\tpersist\n\t\t});\n\n\t\tconst tracker = this.getTracker(request, dto, request.profile, extension);\n\t\tEvent.once(tracker.onEnd)(() => {\n\t\t\tthis.proxy.$finishedExtensionTestRun(dto.id);\n\t\t});\n\n\t\treturn tracker.createRun(name);\n\t}\n\n\tprivate getTracker(req: vscode.TestRunRequest, dto: TestRunDto, profile: vscode.TestRunProfile | undefined, extension: IExtensionDescription, token?: CancellationToken) {\n\t\tconst tracker = new TestRunTracker(dto, this.proxy, this.logService, profile, extension, token);\n\t\tthis.tracked.set(req, tracker);\n\t\tthis.trackedById.set(tracker.id, tracker);\n\t\treturn tracker;\n\t}\n}\n\nconst tryGetProfileFromTestRunReq = (request: vscode.TestRunRequest) => {\n\tif (!request.profile) {\n\t\treturn undefined;\n\t}\n\n\tif (!(request.profile instanceof TestRunProfileImpl)) {\n\t\tthrow new Error(`TestRunRequest.profile is not an instance created from TestController.createRunProfile`);\n\t}\n\n\treturn request.profile;\n};\n\nexport class TestRunDto {\n\tpublic static fromPublic(controllerId: string, collection: ExtHostTestItemCollection, request: vscode.TestRunRequest, persist: boolean) {\n\t\treturn new TestRunDto(\n\t\t\tcontrollerId,\n\t\t\tgenerateUuid(),\n\t\t\tpersist,\n\t\t\tcollection,\n\t\t);\n\t}\n\n\tpublic static fromInternal(request: IStartControllerTests, collection: ExtHostTestItemCollection) {\n\t\treturn new TestRunDto(\n\t\t\trequest.controllerId,\n\t\t\trequest.runId,\n\t\t\ttrue,\n\t\t\tcollection,\n\t\t);\n\t}\n\n\tconstructor(\n\t\tpublic readonly controllerId: string,\n\t\tpublic readonly id: string,\n\t\tpublic readonly isPersisted: boolean,\n\t\tpublic readonly colllection: ExtHostTestItemCollection,\n\t) {\n\t}\n}\n\n/**\n * @private\n */\ninterface MirroredCollectionTestItem extends IncrementalTestCollectionItem {\n\trevived: vscode.TestItem;\n\tdepth: number;\n}\n\nclass MirroredChangeCollector implements IncrementalChangeCollector<MirroredCollectionTestItem> {\n\tprivate readonly added = new Set<MirroredCollectionTestItem>();\n\tprivate readonly updated = new Set<MirroredCollectionTestItem>();\n\tprivate readonly removed = new Set<MirroredCollectionTestItem>();\n\n\tprivate readonly alreadyRemoved = new Set<string>();\n\n\tpublic get isEmpty() {\n\t\treturn this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0;\n\t}\n\n\tconstructor(private readonly emitter: Emitter<vscode.TestsChangeEvent>) {\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic add(node: MirroredCollectionTestItem): void {\n\t\tthis.added.add(node);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic update(node: MirroredCollectionTestItem): void {\n\t\tObject.assign(node.revived, Convert.TestItem.toPlain(node.item));\n\t\tif (!this.added.has(node)) {\n\t\t\tthis.updated.add(node);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic remove(node: MirroredCollectionTestItem): void {\n\t\tif (this.added.has(node)) {\n\t\t\tthis.added.delete(node);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.updated.delete(node);\n\n\t\tconst parentId = TestId.parentId(node.item.extId);\n\t\tif (parentId && this.alreadyRemoved.has(parentId.toString())) {\n\t\t\tthis.alreadyRemoved.add(node.item.extId);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.removed.add(node);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getChangeEvent(): vscode.TestsChangeEvent {\n\t\tconst { added, updated, removed } = this;\n\t\treturn {\n\t\t\tget added() { return [...added].map(n => n.revived); },\n\t\t\tget updated() { return [...updated].map(n => n.revived); },\n\t\t\tget removed() { return [...removed].map(n => n.revived); },\n\t\t};\n\t}\n\n\tpublic complete() {\n\t\tif (!this.isEmpty) {\n\t\t\tthis.emitter.fire(this.getChangeEvent());\n\t\t}\n\t}\n}\n\n/**\n * Maintains tests in this extension host sent from the main thread.\n * @private\n */\nclass MirroredTestCollection extends AbstractIncrementalTestCollection<MirroredCollectionTestItem> {\n\tprivate changeEmitter = new Emitter<vscode.TestsChangeEvent>();\n\n\t/**\n\t * Change emitter that fires with the same semantics as `TestObserver.onDidChangeTests`.\n\t */\n\tpublic readonly onDidChangeTests = this.changeEmitter.event;\n\n\t/**\n\t * Gets a list of root test items.\n\t */\n\tpublic get rootTests() {\n\t\treturn this.roots;\n\t}\n\n\t/**\n\t *\n\t * If the test ID exists, returns its underlying ID.\n\t */\n\tpublic getMirroredTestDataById(itemId: string) {\n\t\treturn this.items.get(itemId);\n\t}\n\n\t/**\n\t * If the test item is a mirrored test item, returns its underlying ID.\n\t */\n\tpublic getMirroredTestDataByReference(item: vscode.TestItem) {\n\t\treturn this.items.get(item.id);\n\t}\n\n\t/**\n\t * @override\n\t */\n\tprotected createItem(item: InternalTestItem, parent?: MirroredCollectionTestItem): MirroredCollectionTestItem {\n\t\treturn {\n\t\t\t...item,\n\t\t\t// todo@connor4312: make this work well again with children\n\t\t\trevived: Convert.TestItem.toPlain(item.item) as vscode.TestItem,\n\t\t\tdepth: parent ? parent.depth + 1 : 0,\n\t\t\tchildren: new Set(),\n\t\t};\n\t}\n\n\t/**\n\t * @override\n\t */\n\tprotected override createChangeCollector() {\n\t\treturn new MirroredChangeCollector(this.changeEmitter);\n\t}\n}\n\nclass TestObservers {\n\tprivate current?: {\n\t\tobservers: number;\n\t\ttests: MirroredTestCollection;\n\t};\n\n\tconstructor(\n\t\tprivate readonly proxy: MainThreadTestingShape,\n\t) {\n\t}\n\n\tpublic checkout(): vscode.TestObserver {\n\t\tif (!this.current) {\n\t\t\tthis.current = this.createObserverData();\n\t\t}\n\n\t\tconst current = this.current;\n\t\tcurrent.observers++;\n\n\t\treturn {\n\t\t\tonDidChangeTest: current.tests.onDidChangeTests,\n\t\t\tget tests() { return [...current.tests.rootTests].map(t => t.revived); },\n\t\t\tdispose: createSingleCallFunction(() => {\n\t\t\t\tif (--current.observers === 0) {\n\t\t\t\t\tthis.proxy.$unsubscribeFromDiffs();\n\t\t\t\t\tthis.current = undefined;\n\t\t\t\t}\n\t\t\t}),\n\t\t};\n\t}\n\n\t/**\n\t * Gets the internal test data by its reference.\n\t */\n\tpublic getMirroredTestDataByReference(ref: vscode.TestItem) {\n\t\treturn this.current?.tests.getMirroredTestDataByReference(ref);\n\t}\n\n\t/**\n\t * Applies test diffs to the current set of observed tests.\n\t */\n\tpublic applyDiff(diff: TestsDiff) {\n\t\tthis.current?.tests.apply(diff);\n\t}\n\n\tprivate createObserverData() {\n\t\tconst tests = new MirroredTestCollection({ asCanonicalUri: u => u });\n\t\tthis.proxy.$subscribeToDiffs();\n\t\treturn { observers: 0, tests, };\n\t}\n}\n\nconst updateProfile = (impl: TestRunProfileImpl, proxy: MainThreadTestingShape, initial: ITestRunProfile | undefined, update: Partial<ITestRunProfile>) => {\n\tif (initial) {\n\t\tObject.assign(initial, update);\n\t} else {\n\t\tproxy.$updateTestRunConfig(impl.controllerId, impl.profileId, update);\n\t}\n};\n\nexport class TestRunProfileImpl extends TestRunProfileBase implements vscode.TestRunProfile {\n\treadonly #proxy: MainThreadTestingShape;\n\treadonly #activeProfiles: Set<number>;\n\treadonly #onDidChangeDefaultProfiles: Event<DefaultProfileChangeEvent>;\n\t#initialPublish?: ITestRunProfile;\n\t#profiles?: Map<number, vscode.TestRunProfile>;\n\tprivate _configureHandler?: (() => void);\n\n\tpublic get label() {\n\t\treturn this._label;\n\t}\n\n\tpublic set label(label: string) {\n\t\tif (label !== this._label) {\n\t\t\tthis._label = label;\n\t\t\tupdateProfile(this, this.#proxy, this.#initialPublish, { label });\n\t\t}\n\t}\n\n\tpublic get supportsContinuousRun() {\n\t\treturn this._supportsContinuousRun;\n\t}\n\n\tpublic set supportsContinuousRun(supports: boolean) {\n\t\tif (supports !== this._supportsContinuousRun) {\n\t\t\tthis._supportsContinuousRun = supports;\n\t\t\tupdateProfile(this, this.#proxy, this.#initialPublish, { supportsContinuousRun: supports });\n\t\t}\n\t}\n\n\tpublic get isDefault() {\n\t\treturn this.#activeProfiles.has(this.profileId);\n\t}\n\n\tpublic set isDefault(isDefault: boolean) {\n\t\tif (isDefault !== this.isDefault) {\n\t\t\t// #activeProfiles is synced from the main thread, so we can make\n\t\t\t// provisional changes here that will get confirmed momentarily\n\t\t\tif (isDefault) {\n\t\t\t\tthis.#activeProfiles.add(this.profileId);\n\t\t\t} else {\n\t\t\t\tthis.#activeProfiles.delete(this.profileId);\n\t\t\t}\n\n\t\t\tupdateProfile(this, this.#proxy, this.#initialPublish, { isDefault });\n\t\t}\n\t}\n\n\tpublic get tag() {\n\t\treturn this._tag;\n\t}\n\n\tpublic set tag(tag: vscode.TestTag | undefined) {\n\t\tif (tag?.id !== this._tag?.id) {\n\t\t\tthis._tag = tag;\n\t\t\tupdateProfile(this, this.#proxy, this.#initialPublish, {\n\t\t\t\ttag: tag ? Convert.TestTag.namespace(this.controllerId, tag.id) : null,\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic get configureHandler() {\n\t\treturn this._configureHandler;\n\t}\n\n\tpublic set configureHandler(handler: undefined | (() => void)) {\n\t\tif (handler !== this._configureHandler) {\n\t\t\tthis._configureHandler = handler;\n\t\t\tupdateProfile(this, this.#proxy, this.#initialPublish, { hasConfigurationHandler: !!handler });\n\t\t}\n\t}\n\n\tpublic get onDidChangeDefault() {\n\t\treturn Event.chain(this.#onDidChangeDefaultProfiles, $ => $\n\t\t\t.map(ev => ev.get(this.controllerId)?.get(this.profileId))\n\t\t\t.filter(isDefined)\n\t\t);\n\t}\n\n\tconstructor(\n\t\tproxy: MainThreadTestingShape,\n\t\tprofiles: Map<number, vscode.TestRunProfile>,\n\t\tactiveProfiles: Set<number>,\n\t\tonDidChangeActiveProfiles: Event<DefaultProfileChangeEvent>,\n\t\tcontrollerId: string,\n\t\tprofileId: number,\n\t\tprivate _label: string,\n\t\tkind: vscode.TestRunProfileKind,\n\t\tpublic runHandler: (request: vscode.TestRunRequest, token: vscode.CancellationToken) => Thenable<void> | void,\n\t\t_isDefault = false,\n\t\tpublic _tag: vscode.TestTag | undefined = undefined,\n\t\tprivate _supportsContinuousRun = false,\n\t) {\n\t\tsuper(controllerId, profileId, kind);\n\n\t\tthis.#proxy = proxy;\n\t\tthis.#profiles = profiles;\n\t\tthis.#activeProfiles = activeProfiles;\n\t\tthis.#onDidChangeDefaultProfiles = onDidChangeActiveProfiles;\n\t\tprofiles.set(profileId, this);\n\n\t\tconst groupBitset = Convert.TestRunProfileKind.from(kind);\n\t\tif (_isDefault) {\n\t\t\tactiveProfiles.add(profileId);\n\t\t}\n\n\t\tthis.#initialPublish = {\n\t\t\tprofileId: profileId,\n\t\t\tcontrollerId,\n\t\t\ttag: _tag ? Convert.TestTag.namespace(this.controllerId, _tag.id) : null,\n\t\t\tlabel: _label,\n\t\t\tgroup: groupBitset,\n\t\t\tisDefault: _isDefault,\n\t\t\thasConfigurationHandler: false,\n\t\t\tsupportsContinuousRun: _supportsContinuousRun,\n\t\t};\n\n\t\t// we send the initial profile publish out on the next microtask so that\n\t\t// initially setting the isDefault value doesn't overwrite a user-configured value\n\t\tqueueMicrotask(() => {\n\t\t\tif (this.#initialPublish) {\n\t\t\t\tthis.#proxy.$publishTestRunProfile(this.#initialPublish);\n\t\t\t\tthis.#initialPublish = undefined;\n\t\t\t}\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tif (this.#profiles?.delete(this.profileId)) {\n\t\t\tthis.#profiles = undefined;\n\t\t\tthis.#proxy.$removeTestProfile(this.controllerId, this.profileId);\n\t\t}\n\t\tthis.#initialPublish = undefined;\n\t}\n}\n\nfunction findTestInResultSnapshot(extId: TestId, snapshot: readonly Readonly<vscode.TestResultSnapshot>[]) {\n\tfor (let i = 0; i < extId.path.length; i++) {\n\t\tconst item = snapshot.find(s => s.id === extId.path[i]);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (i === extId.path.length - 1) {\n\t\t\treturn item;\n\t\t}\n\n\t\tsnapshot = item.children;\n\t}\n\n\treturn undefined;\n}\n"]}