{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/common/extensionHostMain.ts","vs/workbench/api/common/extensionHostMain.ts"],"names":[],"mappings":"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","file":"extensionHostMain.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from '../../../base/common/errors.js';\nimport * as performance from '../../../base/common/performance.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IURITransformer } from '../../../base/common/uriIpc.js';\nimport { IMessagePassingProtocol } from '../../../base/parts/ipc/common/ipc.js';\nimport { MainContext, MainThreadConsoleShape } from './extHost.protocol.js';\nimport { IExtensionHostInitData } from '../../services/extensions/common/extensionHostProtocol.js';\nimport { RPCProtocol } from '../../services/extensions/common/rpcProtocol.js';\nimport { ExtensionError, ExtensionIdentifier, IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { getSingletonServiceDescriptors } from '../../../platform/instantiation/common/extensions.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { InstantiationService } from '../../../platform/instantiation/common/instantiationService.js';\nimport { IInstantiationService, ServicesAccessor } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostRpcService, ExtHostRpcService } from './extHostRpcService.js';\nimport { IURITransformerService, URITransformerService } from './extHostUriTransformerService.js';\nimport { IExtHostExtensionService, IHostUtils } from './extHostExtensionService.js';\nimport { IExtHostTelemetry } from './extHostTelemetry.js';\nimport { Mutable } from '../../../base/common/types.js';\nimport { IExtHostApiDeprecationService } from './extHostApiDeprecationService.js';\n\nexport interface IExitFn {\n\t(code?: number): any;\n}\n\nexport interface IConsolePatchFn {\n\t(mainThreadConsole: MainThreadConsoleShape): any;\n}\n\nexport abstract class ErrorHandler {\n\n\tstatic async installEarlyHandler(accessor: ServicesAccessor): Promise<void> {\n\n\t\t// increase number of stack frames (from 10, https://github.com/v8/v8/wiki/Stack-Trace-API)\n\t\tError.stackTraceLimit = 100;\n\n\t\t// does NOT dependent of extension information, can be installed immediately, and simply forwards\n\t\t// to the log service and main thread errors\n\t\tconst logService = accessor.get(ILogService);\n\t\tconst rpcService = accessor.get(IExtHostRpcService);\n\t\tconst mainThreadErrors = rpcService.getProxy(MainContext.MainThreadErrors);\n\n\t\terrors.setUnexpectedErrorHandler(err => {\n\t\t\tlogService.error(err);\n\t\t\tconst data = errors.transformErrorForSerialization(err);\n\t\t\tmainThreadErrors.$onUnexpectedError(data);\n\t\t});\n\t}\n\n\tstatic async installFullHandler(accessor: ServicesAccessor): Promise<void> {\n\t\t// uses extension knowledges to correlate errors with extensions\n\n\t\tconst logService = accessor.get(ILogService);\n\t\tconst rpcService = accessor.get(IExtHostRpcService);\n\t\tconst extensionService = accessor.get(IExtHostExtensionService);\n\t\tconst extensionTelemetry = accessor.get(IExtHostTelemetry);\n\t\tconst apiDeprecationService = accessor.get(IExtHostApiDeprecationService);\n\n\t\tconst mainThreadExtensions = rpcService.getProxy(MainContext.MainThreadExtensionService);\n\t\tconst mainThreadErrors = rpcService.getProxy(MainContext.MainThreadErrors);\n\n\t\tconst extensionsRegistry = await extensionService.getExtensionRegistry();\n\t\tconst extensionsMap = await extensionService.getExtensionPathIndex();\n\t\tconst extensionErrors = new WeakMap<Error, { extensionIdentifier: ExtensionIdentifier | undefined; stack: string }>();\n\n\t\t// PART 1\n\t\t// set the prepareStackTrace-handle and use it as a side-effect to associate errors\n\t\t// with extensions - this works by looking up callsites in the extension path index\n\t\tfunction prepareStackTraceAndFindExtension(error: Error, stackTrace: errors.V8CallSite[]) {\n\t\t\tif (extensionErrors.has(error)) {\n\t\t\t\treturn extensionErrors.get(error)!.stack;\n\t\t\t}\n\t\t\tlet stackTraceMessage = '';\n\t\t\tlet extension: IExtensionDescription | undefined;\n\t\t\tlet fileName: string | null;\n\t\t\tfor (const call of stackTrace) {\n\t\t\t\tstackTraceMessage += `\\n\\tat ${call.toString()}`;\n\t\t\t\tfileName = call.getFileName();\n\t\t\t\tif (!extension && fileName) {\n\t\t\t\t\textension = extensionsMap.findSubstr(URI.file(fileName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = `${error.name || 'Error'}: ${error.message || ''}${stackTraceMessage}`;\n\t\t\textensionErrors.set(error, { extensionIdentifier: extension?.identifier, stack: result });\n\t\t\treturn result;\n\t\t}\n\n\t\tconst _wasWrapped = Symbol('prepareStackTrace wrapped');\n\t\tlet _prepareStackTrace = prepareStackTraceAndFindExtension;\n\n\t\tObject.defineProperty(Error, 'prepareStackTrace', {\n\t\t\tconfigurable: false,\n\t\t\tget() {\n\t\t\t\treturn _prepareStackTrace;\n\t\t\t},\n\t\t\tset(v) {\n\t\t\t\tif (v === prepareStackTraceAndFindExtension || !v || v[_wasWrapped]) {\n\t\t\t\t\t_prepareStackTrace = v || prepareStackTraceAndFindExtension;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t_prepareStackTrace = function (error, stackTrace) {\n\t\t\t\t\tprepareStackTraceAndFindExtension(error, stackTrace);\n\t\t\t\t\treturn v.call(Error, error, stackTrace);\n\t\t\t\t};\n\n\t\t\t\tObject.assign(_prepareStackTrace, { [_wasWrapped]: true });\n\t\t\t},\n\t\t});\n\n\t\t// PART 2\n\t\t// set the unexpectedErrorHandler and check for extensions that have been identified as\n\t\t// having caused the error. Note that the runtime order is actually reversed, the code\n\t\t// below accesses the stack-property which triggers the code above\n\t\terrors.setUnexpectedErrorHandler(err => {\n\n\t\t\tif (!errors.PendingMigrationError.is(err)) {\n\t\t\t\tlogService.error(err);\n\t\t\t}\n\n\t\t\tconst errorData = errors.transformErrorForSerialization(err);\n\n\t\t\tlet extension: ExtensionIdentifier | undefined;\n\t\t\tif (err instanceof ExtensionError) {\n\t\t\t\textension = err.extension;\n\t\t\t} else {\n\t\t\t\tconst stackData = extensionErrors.get(err);\n\t\t\t\textension = stackData?.extensionIdentifier;\n\t\t\t}\n\n\t\t\tif (!extension) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (errors.PendingMigrationError.is(err)) {\n\t\t\t\t// report pending migration via the API deprecation service which (1) informs the extensions author during\n\t\t\t\t// dev-time and (2) collects telemetry so that we can reach out too\n\t\t\t\tconst extensionDesc = extensionsRegistry.getExtensionDescription(extension);\n\t\t\t\tif (extensionDesc) {\n\t\t\t\t\tapiDeprecationService.report(err.name, extensionDesc, `${err.message}\\n FROM: ${err.stack}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmainThreadExtensions.$onExtensionRuntimeError(extension, errorData);\n\t\t\t\tconst reported = extensionTelemetry.onExtensionError(extension, err);\n\t\t\t\tlogService.trace('forwarded error to extension?', reported, extension);\n\t\t\t}\n\t\t});\n\n\t\terrors.errorHandler.addListener(err => {\n\t\t\tmainThreadErrors.$onUnexpectedError(err);\n\t\t});\n\t}\n}\n\nexport class ExtensionHostMain {\n\n\tprivate readonly _hostUtils: IHostUtils;\n\tprivate readonly _rpcProtocol: RPCProtocol;\n\tprivate readonly _extensionService: IExtHostExtensionService;\n\tprivate readonly _logService: ILogService;\n\n\tconstructor(\n\t\tprotocol: IMessagePassingProtocol,\n\t\tinitData: IExtensionHostInitData,\n\t\thostUtils: IHostUtils,\n\t\turiTransformer: IURITransformer | null,\n\t\tmessagePorts?: ReadonlyMap<string, MessagePort>\n\t) {\n\t\tthis._hostUtils = hostUtils;\n\t\tthis._rpcProtocol = new RPCProtocol(protocol, null, uriTransformer);\n\n\t\t// ensure URIs are transformed and revived\n\t\tinitData = ExtensionHostMain._transform(initData, this._rpcProtocol);\n\n\t\t// bootstrap services\n\t\tconst services = new ServiceCollection(...getSingletonServiceDescriptors());\n\t\tservices.set(IExtHostInitDataService, { _serviceBrand: undefined, ...initData, messagePorts });\n\t\tservices.set(IExtHostRpcService, new ExtHostRpcService(this._rpcProtocol));\n\t\tservices.set(IURITransformerService, new URITransformerService(uriTransformer));\n\t\tservices.set(IHostUtils, hostUtils);\n\n\t\tconst instaService: IInstantiationService = new InstantiationService(services, true);\n\n\t\tinstaService.invokeFunction(ErrorHandler.installEarlyHandler);\n\n\t\t// ugly self - inject\n\t\tthis._logService = instaService.invokeFunction(accessor => accessor.get(ILogService));\n\n\t\tperformance.mark(`code/extHost/didCreateServices`);\n\t\tif (this._hostUtils.pid) {\n\t\t\tthis._logService.info(`Extension host with pid ${this._hostUtils.pid} started`);\n\t\t} else {\n\t\t\tthis._logService.info(`Extension host started`);\n\t\t}\n\t\tthis._logService.trace('initData', initData);\n\n\t\t// ugly self - inject\n\t\t// must call initialize *after* creating the extension service\n\t\t// because `initialize` itself creates instances that depend on it\n\t\tthis._extensionService = instaService.invokeFunction(accessor => accessor.get(IExtHostExtensionService));\n\t\tthis._extensionService.initialize();\n\n\t\t// install error handler that is extension-aware\n\t\tinstaService.invokeFunction(ErrorHandler.installFullHandler);\n\t}\n\n\tasync asBrowserUri(uri: URI): Promise<URI> {\n\t\tconst mainThreadExtensionsProxy = this._rpcProtocol.getProxy(MainContext.MainThreadExtensionService);\n\t\treturn URI.revive(await mainThreadExtensionsProxy.$asBrowserUri(uri));\n\t}\n\n\tterminate(reason: string): void {\n\t\tthis._extensionService.terminate(reason);\n\t}\n\n\tprivate static _transform(initData: IExtensionHostInitData, rpcProtocol: RPCProtocol): IExtensionHostInitData {\n\t\tinitData.extensions.allExtensions.forEach((ext) => {\n\t\t\t(<Mutable<IExtensionDescription>>ext).extensionLocation = URI.revive(rpcProtocol.transformIncomingURIs(ext.extensionLocation));\n\t\t});\n\t\tinitData.environment.appRoot = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.appRoot));\n\t\tconst extDevLocs = initData.environment.extensionDevelopmentLocationURI;\n\t\tif (extDevLocs) {\n\t\t\tinitData.environment.extensionDevelopmentLocationURI = extDevLocs.map(url => URI.revive(rpcProtocol.transformIncomingURIs(url)));\n\t\t}\n\t\tinitData.environment.extensionTestsLocationURI = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.extensionTestsLocationURI));\n\t\tinitData.environment.globalStorageHome = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.globalStorageHome));\n\t\tinitData.environment.workspaceStorageHome = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.workspaceStorageHome));\n\t\tinitData.nlsBaseUrl = URI.revive(rpcProtocol.transformIncomingURIs(initData.nlsBaseUrl));\n\t\tinitData.logsLocation = URI.revive(rpcProtocol.transformIncomingURIs(initData.logsLocation));\n\t\tinitData.workspace = rpcProtocol.transformIncomingURIs(initData.workspace);\n\t\treturn initData;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from '../../../base/common/errors.js';\nimport * as performance from '../../../base/common/performance.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IURITransformer } from '../../../base/common/uriIpc.js';\nimport { IMessagePassingProtocol } from '../../../base/parts/ipc/common/ipc.js';\nimport { MainContext, MainThreadConsoleShape } from './extHost.protocol.js';\nimport { IExtensionHostInitData } from '../../services/extensions/common/extensionHostProtocol.js';\nimport { RPCProtocol } from '../../services/extensions/common/rpcProtocol.js';\nimport { ExtensionError, ExtensionIdentifier, IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { getSingletonServiceDescriptors } from '../../../platform/instantiation/common/extensions.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { InstantiationService } from '../../../platform/instantiation/common/instantiationService.js';\nimport { IInstantiationService, ServicesAccessor } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostRpcService, ExtHostRpcService } from './extHostRpcService.js';\nimport { IURITransformerService, URITransformerService } from './extHostUriTransformerService.js';\nimport { IExtHostExtensionService, IHostUtils } from './extHostExtensionService.js';\nimport { IExtHostTelemetry } from './extHostTelemetry.js';\nimport { Mutable } from '../../../base/common/types.js';\nimport { IExtHostApiDeprecationService } from './extHostApiDeprecationService.js';\n\nexport interface IExitFn {\n\t(code?: number): any;\n}\n\nexport interface IConsolePatchFn {\n\t(mainThreadConsole: MainThreadConsoleShape): any;\n}\n\nexport abstract class ErrorHandler {\n\n\tstatic async installEarlyHandler(accessor: ServicesAccessor): Promise<void> {\n\n\t\t// increase number of stack frames (from 10, https://github.com/v8/v8/wiki/Stack-Trace-API)\n\t\tError.stackTraceLimit = 100;\n\n\t\t// does NOT dependent of extension information, can be installed immediately, and simply forwards\n\t\t// to the log service and main thread errors\n\t\tconst logService = accessor.get(ILogService);\n\t\tconst rpcService = accessor.get(IExtHostRpcService);\n\t\tconst mainThreadErrors = rpcService.getProxy(MainContext.MainThreadErrors);\n\n\t\terrors.setUnexpectedErrorHandler(err => {\n\t\t\tlogService.error(err);\n\t\t\tconst data = errors.transformErrorForSerialization(err);\n\t\t\tmainThreadErrors.$onUnexpectedError(data);\n\t\t});\n\t}\n\n\tstatic async installFullHandler(accessor: ServicesAccessor): Promise<void> {\n\t\t// uses extension knowledges to correlate errors with extensions\n\n\t\tconst logService = accessor.get(ILogService);\n\t\tconst rpcService = accessor.get(IExtHostRpcService);\n\t\tconst extensionService = accessor.get(IExtHostExtensionService);\n\t\tconst extensionTelemetry = accessor.get(IExtHostTelemetry);\n\t\tconst apiDeprecationService = accessor.get(IExtHostApiDeprecationService);\n\n\t\tconst mainThreadExtensions = rpcService.getProxy(MainContext.MainThreadExtensionService);\n\t\tconst mainThreadErrors = rpcService.getProxy(MainContext.MainThreadErrors);\n\n\t\tconst extensionsRegistry = await extensionService.getExtensionRegistry();\n\t\tconst extensionsMap = await extensionService.getExtensionPathIndex();\n\t\tconst extensionErrors = new WeakMap<Error, { extensionIdentifier: ExtensionIdentifier | undefined; stack: string }>();\n\n\t\t// PART 1\n\t\t// set the prepareStackTrace-handle and use it as a side-effect to associate errors\n\t\t// with extensions - this works by looking up callsites in the extension path index\n\t\tfunction prepareStackTraceAndFindExtension(error: Error, stackTrace: errors.V8CallSite[]) {\n\t\t\tif (extensionErrors.has(error)) {\n\t\t\t\treturn extensionErrors.get(error)!.stack;\n\t\t\t}\n\t\t\tlet stackTraceMessage = '';\n\t\t\tlet extension: IExtensionDescription | undefined;\n\t\t\tlet fileName: string | null;\n\t\t\tfor (const call of stackTrace) {\n\t\t\t\tstackTraceMessage += `\\n\\tat ${call.toString()}`;\n\t\t\t\tfileName = call.getFileName();\n\t\t\t\tif (!extension && fileName) {\n\t\t\t\t\textension = extensionsMap.findSubstr(URI.file(fileName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = `${error.name || 'Error'}: ${error.message || ''}${stackTraceMessage}`;\n\t\t\textensionErrors.set(error, { extensionIdentifier: extension?.identifier, stack: result });\n\t\t\treturn result;\n\t\t}\n\n\t\tconst _wasWrapped = Symbol('prepareStackTrace wrapped');\n\t\tlet _prepareStackTrace = prepareStackTraceAndFindExtension;\n\n\t\tObject.defineProperty(Error, 'prepareStackTrace', {\n\t\t\tconfigurable: false,\n\t\t\tget() {\n\t\t\t\treturn _prepareStackTrace;\n\t\t\t},\n\t\t\tset(v) {\n\t\t\t\tif (v === prepareStackTraceAndFindExtension || !v || v[_wasWrapped]) {\n\t\t\t\t\t_prepareStackTrace = v || prepareStackTraceAndFindExtension;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t_prepareStackTrace = function (error, stackTrace) {\n\t\t\t\t\tprepareStackTraceAndFindExtension(error, stackTrace);\n\t\t\t\t\treturn v.call(Error, error, stackTrace);\n\t\t\t\t};\n\n\t\t\t\tObject.assign(_prepareStackTrace, { [_wasWrapped]: true });\n\t\t\t},\n\t\t});\n\n\t\t// PART 2\n\t\t// set the unexpectedErrorHandler and check for extensions that have been identified as\n\t\t// having caused the error. Note that the runtime order is actually reversed, the code\n\t\t// below accesses the stack-property which triggers the code above\n\t\terrors.setUnexpectedErrorHandler(err => {\n\n\t\t\tif (!errors.PendingMigrationError.is(err)) {\n\t\t\t\tlogService.error(err);\n\t\t\t}\n\n\t\t\tconst errorData = errors.transformErrorForSerialization(err);\n\n\t\t\tlet extension: ExtensionIdentifier | undefined;\n\t\t\tif (err instanceof ExtensionError) {\n\t\t\t\textension = err.extension;\n\t\t\t} else {\n\t\t\t\tconst stackData = extensionErrors.get(err);\n\t\t\t\textension = stackData?.extensionIdentifier;\n\t\t\t}\n\n\t\t\tif (!extension) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (errors.PendingMigrationError.is(err)) {\n\t\t\t\t// report pending migration via the API deprecation service which (1) informs the extensions author during\n\t\t\t\t// dev-time and (2) collects telemetry so that we can reach out too\n\t\t\t\tconst extensionDesc = extensionsRegistry.getExtensionDescription(extension);\n\t\t\t\tif (extensionDesc) {\n\t\t\t\t\tapiDeprecationService.report(err.name, extensionDesc, `${err.message}\\n FROM: ${err.stack}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmainThreadExtensions.$onExtensionRuntimeError(extension, errorData);\n\t\t\t\tconst reported = extensionTelemetry.onExtensionError(extension, err);\n\t\t\t\tlogService.trace('forwarded error to extension?', reported, extension);\n\t\t\t}\n\t\t});\n\n\t\terrors.errorHandler.addListener(err => {\n\t\t\tmainThreadErrors.$onUnexpectedError(err);\n\t\t});\n\t}\n}\n\nexport class ExtensionHostMain {\n\n\tprivate readonly _hostUtils: IHostUtils;\n\tprivate readonly _rpcProtocol: RPCProtocol;\n\tprivate readonly _extensionService: IExtHostExtensionService;\n\tprivate readonly _logService: ILogService;\n\n\tconstructor(\n\t\tprotocol: IMessagePassingProtocol,\n\t\tinitData: IExtensionHostInitData,\n\t\thostUtils: IHostUtils,\n\t\turiTransformer: IURITransformer | null,\n\t\tmessagePorts?: ReadonlyMap<string, MessagePort>\n\t) {\n\t\tthis._hostUtils = hostUtils;\n\t\tthis._rpcProtocol = new RPCProtocol(protocol, null, uriTransformer);\n\n\t\t// ensure URIs are transformed and revived\n\t\tinitData = ExtensionHostMain._transform(initData, this._rpcProtocol);\n\n\t\t// bootstrap services\n\t\tconst services = new ServiceCollection(...getSingletonServiceDescriptors());\n\t\tservices.set(IExtHostInitDataService, { _serviceBrand: undefined, ...initData, messagePorts });\n\t\tservices.set(IExtHostRpcService, new ExtHostRpcService(this._rpcProtocol));\n\t\tservices.set(IURITransformerService, new URITransformerService(uriTransformer));\n\t\tservices.set(IHostUtils, hostUtils);\n\n\t\tconst instaService: IInstantiationService = new InstantiationService(services, true);\n\n\t\tinstaService.invokeFunction(ErrorHandler.installEarlyHandler);\n\n\t\t// ugly self - inject\n\t\tthis._logService = instaService.invokeFunction(accessor => accessor.get(ILogService));\n\n\t\tperformance.mark(`code/extHost/didCreateServices`);\n\t\tif (this._hostUtils.pid) {\n\t\t\tthis._logService.info(`Extension host with pid ${this._hostUtils.pid} started`);\n\t\t} else {\n\t\t\tthis._logService.info(`Extension host started`);\n\t\t}\n\t\tthis._logService.trace('initData', initData);\n\n\t\t// ugly self - inject\n\t\t// must call initialize *after* creating the extension service\n\t\t// because `initialize` itself creates instances that depend on it\n\t\tthis._extensionService = instaService.invokeFunction(accessor => accessor.get(IExtHostExtensionService));\n\t\tthis._extensionService.initialize();\n\n\t\t// install error handler that is extension-aware\n\t\tinstaService.invokeFunction(ErrorHandler.installFullHandler);\n\t}\n\n\tasync asBrowserUri(uri: URI): Promise<URI> {\n\t\tconst mainThreadExtensionsProxy = this._rpcProtocol.getProxy(MainContext.MainThreadExtensionService);\n\t\treturn URI.revive(await mainThreadExtensionsProxy.$asBrowserUri(uri));\n\t}\n\n\tterminate(reason: string): void {\n\t\tthis._extensionService.terminate(reason);\n\t}\n\n\tprivate static _transform(initData: IExtensionHostInitData, rpcProtocol: RPCProtocol): IExtensionHostInitData {\n\t\tinitData.extensions.allExtensions.forEach((ext) => {\n\t\t\t(<Mutable<IExtensionDescription>>ext).extensionLocation = URI.revive(rpcProtocol.transformIncomingURIs(ext.extensionLocation));\n\t\t});\n\t\tinitData.environment.appRoot = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.appRoot));\n\t\tconst extDevLocs = initData.environment.extensionDevelopmentLocationURI;\n\t\tif (extDevLocs) {\n\t\t\tinitData.environment.extensionDevelopmentLocationURI = extDevLocs.map(url => URI.revive(rpcProtocol.transformIncomingURIs(url)));\n\t\t}\n\t\tinitData.environment.extensionTestsLocationURI = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.extensionTestsLocationURI));\n\t\tinitData.environment.globalStorageHome = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.globalStorageHome));\n\t\tinitData.environment.workspaceStorageHome = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.workspaceStorageHome));\n\t\tinitData.nlsBaseUrl = URI.revive(rpcProtocol.transformIncomingURIs(initData.nlsBaseUrl));\n\t\tinitData.logsLocation = URI.revive(rpcProtocol.transformIncomingURIs(initData.logsLocation));\n\t\tinitData.workspace = rpcProtocol.transformIncomingURIs(initData.workspace);\n\t\treturn initData;\n\t}\n}\n"]}