{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/common/extHostTypes/notebooks.ts","vs/workbench/api/common/extHostTypes/notebooks.ts"],"names":[],"mappings":"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","file":"notebooks.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type * as vscode from 'vscode';\nimport { es5ClassCompat } from './es5ClassCompat.js';\nimport { illegalArgument } from '../../../../base/common/errors.js';\nimport { Mimes, normalizeMimeType, isTextStreamMime } from '../../../../base/common/mime.js';\nimport { generateUuid } from '../../../../base/common/uuid.js';\n\n/* eslint-disable local/code-no-native-private */\n\nexport enum NotebookCellKind {\n\tMarkup = 1,\n\tCode = 2\n}\n\nexport class NotebookRange {\n\tstatic isNotebookRange(thing: unknown): thing is vscode.NotebookRange {\n\t\tif (thing instanceof NotebookRange) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<NotebookRange>thing).start === 'number'\n\t\t\t&& typeof (<NotebookRange>thing).end === 'number';\n\t}\n\n\tprivate _start: number;\n\tprivate _end: number;\n\n\tget start() {\n\t\treturn this._start;\n\t}\n\n\tget end() {\n\t\treturn this._end;\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this._start === this._end;\n\t}\n\n\tconstructor(start: number, end: number) {\n\t\tif (start < 0) {\n\t\t\tthrow illegalArgument('start must be positive');\n\t\t}\n\t\tif (end < 0) {\n\t\t\tthrow illegalArgument('end must be positive');\n\t\t}\n\t\tif (start <= end) {\n\t\t\tthis._start = start;\n\t\t\tthis._end = end;\n\t\t} else {\n\t\t\tthis._start = end;\n\t\t\tthis._end = start;\n\t\t}\n\t}\n\n\twith(change: { start?: number; end?: number }): NotebookRange {\n\t\tlet start = this._start;\n\t\tlet end = this._end;\n\n\t\tif (change.start !== undefined) {\n\t\t\tstart = change.start;\n\t\t}\n\t\tif (change.end !== undefined) {\n\t\t\tend = change.end;\n\t\t}\n\t\tif (start === this._start && end === this._end) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new NotebookRange(start, end);\n\t}\n}\n\nexport class NotebookCellData {\n\n\tstatic validate(data: NotebookCellData): void {\n\t\tif (typeof data.kind !== 'number') {\n\t\t\tthrow new Error('NotebookCellData MUST have \\'kind\\' property');\n\t\t}\n\t\tif (typeof data.value !== 'string') {\n\t\t\tthrow new Error('NotebookCellData MUST have \\'value\\' property');\n\t\t}\n\t\tif (typeof data.languageId !== 'string') {\n\t\t\tthrow new Error('NotebookCellData MUST have \\'languageId\\' property');\n\t\t}\n\t}\n\n\tstatic isNotebookCellDataArray(value: unknown): value is vscode.NotebookCellData[] {\n\t\treturn Array.isArray(value) && (<unknown[]>value).every(elem => NotebookCellData.isNotebookCellData(elem));\n\t}\n\n\tstatic isNotebookCellData(value: unknown): value is vscode.NotebookCellData {\n\t\t// return value instanceof NotebookCellData;\n\t\treturn true;\n\t}\n\n\tkind: NotebookCellKind;\n\tvalue: string;\n\tlanguageId: string;\n\tmime?: string;\n\toutputs?: vscode.NotebookCellOutput[];\n\tmetadata?: Record<string, unknown>;\n\texecutionSummary?: vscode.NotebookCellExecutionSummary;\n\n\tconstructor(kind: NotebookCellKind, value: string, languageId: string, mime?: string, outputs?: vscode.NotebookCellOutput[], metadata?: Record<string, unknown>, executionSummary?: vscode.NotebookCellExecutionSummary) {\n\t\tthis.kind = kind;\n\t\tthis.value = value;\n\t\tthis.languageId = languageId;\n\t\tthis.mime = mime;\n\t\tthis.outputs = outputs ?? [];\n\t\tthis.metadata = metadata;\n\t\tthis.executionSummary = executionSummary;\n\n\t\tNotebookCellData.validate(this);\n\t}\n}\n\nexport class NotebookData {\n\n\tcells: NotebookCellData[];\n\tmetadata?: { [key: string]: unknown };\n\n\tconstructor(cells: NotebookCellData[]) {\n\t\tthis.cells = cells;\n\t}\n}\n\n@es5ClassCompat\nexport class NotebookEdit implements vscode.NotebookEdit {\n\n\tstatic isNotebookCellEdit(thing: unknown): thing is NotebookEdit {\n\t\tif (thing instanceof NotebookEdit) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn NotebookRange.isNotebookRange((<NotebookEdit>thing))\n\t\t\t&& Array.isArray((<NotebookEdit>thing).newCells);\n\t}\n\n\tstatic replaceCells(range: NotebookRange, newCells: NotebookCellData[]): NotebookEdit {\n\t\treturn new NotebookEdit(range, newCells);\n\t}\n\n\tstatic insertCells(index: number, newCells: vscode.NotebookCellData[]): vscode.NotebookEdit {\n\t\treturn new NotebookEdit(new NotebookRange(index, index), newCells);\n\t}\n\n\tstatic deleteCells(range: NotebookRange): NotebookEdit {\n\t\treturn new NotebookEdit(range, []);\n\t}\n\n\tstatic updateCellMetadata(index: number, newMetadata: { [key: string]: unknown }): NotebookEdit {\n\t\tconst edit = new NotebookEdit(new NotebookRange(index, index), []);\n\t\tedit.newCellMetadata = newMetadata;\n\t\treturn edit;\n\t}\n\n\tstatic updateNotebookMetadata(newMetadata: { [key: string]: unknown }): NotebookEdit {\n\t\tconst edit = new NotebookEdit(new NotebookRange(0, 0), []);\n\t\tedit.newNotebookMetadata = newMetadata;\n\t\treturn edit;\n\t}\n\n\trange: NotebookRange;\n\tnewCells: NotebookCellData[];\n\tnewCellMetadata?: { [key: string]: unknown };\n\tnewNotebookMetadata?: { [key: string]: unknown };\n\n\tconstructor(range: NotebookRange, newCells: NotebookCellData[]) {\n\t\tthis.range = range;\n\t\tthis.newCells = newCells;\n\t}\n}\n\nexport class NotebookCellOutputItem {\n\n\tstatic isNotebookCellOutputItem(obj: unknown): obj is vscode.NotebookCellOutputItem {\n\t\tif (obj instanceof NotebookCellOutputItem) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!obj) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<vscode.NotebookCellOutputItem>obj).mime === 'string'\n\t\t\t&& (<vscode.NotebookCellOutputItem>obj).data instanceof Uint8Array;\n\t}\n\n\tstatic error(err: Error | { name: string; message?: string; stack?: string }): NotebookCellOutputItem {\n\t\tconst obj = {\n\t\t\tname: err.name,\n\t\t\tmessage: err.message,\n\t\t\tstack: err.stack\n\t\t};\n\t\treturn NotebookCellOutputItem.json(obj, 'application/vnd.code.notebook.error');\n\t}\n\n\tstatic stdout(value: string): NotebookCellOutputItem {\n\t\treturn NotebookCellOutputItem.text(value, 'application/vnd.code.notebook.stdout');\n\t}\n\n\tstatic stderr(value: string): NotebookCellOutputItem {\n\t\treturn NotebookCellOutputItem.text(value, 'application/vnd.code.notebook.stderr');\n\t}\n\n\tstatic bytes(value: Uint8Array, mime: string = 'application/octet-stream'): NotebookCellOutputItem {\n\t\treturn new NotebookCellOutputItem(value, mime);\n\t}\n\n\tstatic #encoder = new TextEncoder();\n\n\tstatic text(value: string, mime: string = Mimes.text): NotebookCellOutputItem {\n\t\tconst bytes = NotebookCellOutputItem.#encoder.encode(String(value));\n\t\treturn new NotebookCellOutputItem(bytes, mime);\n\t}\n\n\tstatic json(value: unknown, mime: string = 'text/x-json'): NotebookCellOutputItem {\n\t\tconst rawStr = JSON.stringify(value, undefined, '\\t');\n\t\treturn NotebookCellOutputItem.text(rawStr, mime);\n\t}\n\n\tconstructor(\n\t\tpublic data: Uint8Array,\n\t\tpublic mime: string\n\t) {\n\t\tconst mimeNormalized = normalizeMimeType(mime, true);\n\t\tif (!mimeNormalized) {\n\t\t\tthrow new Error(`INVALID mime type: ${mime}. Must be in the format \"type/subtype[;optionalparameter]\"`);\n\t\t}\n\t\tthis.mime = mimeNormalized;\n\t}\n}\n\nexport class NotebookCellOutput {\n\n\tstatic isNotebookCellOutput(candidate: unknown): candidate is vscode.NotebookCellOutput {\n\t\tif (candidate instanceof NotebookCellOutput) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!candidate || typeof candidate !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<NotebookCellOutput>candidate).id === 'string' && Array.isArray((<NotebookCellOutput>candidate).items);\n\t}\n\n\tstatic ensureUniqueMimeTypes(items: NotebookCellOutputItem[], warn: boolean = false): NotebookCellOutputItem[] {\n\t\tconst seen = new Set<string>();\n\t\tconst removeIdx = new Set<number>();\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\tconst item = items[i];\n\t\t\tconst normalMime = normalizeMimeType(item.mime);\n\t\t\t// We can have multiple text stream mime types in the same output.\n\t\t\tif (!seen.has(normalMime) || isTextStreamMime(normalMime)) {\n\t\t\t\tseen.add(normalMime);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// duplicated mime types... first has won\n\t\t\tremoveIdx.add(i);\n\t\t\tif (warn) {\n\t\t\t\tconsole.warn(`DUPLICATED mime type '${item.mime}' will be dropped`);\n\t\t\t}\n\t\t}\n\t\tif (removeIdx.size === 0) {\n\t\t\treturn items;\n\t\t}\n\t\treturn items.filter((_item, index) => !removeIdx.has(index));\n\t}\n\n\tid: string;\n\titems: NotebookCellOutputItem[];\n\tmetadata?: Record<string, unknown>;\n\n\tconstructor(\n\t\titems: NotebookCellOutputItem[],\n\t\tidOrMetadata?: string | Record<string, unknown>,\n\t\tmetadata?: Record<string, unknown>\n\t) {\n\t\tthis.items = NotebookCellOutput.ensureUniqueMimeTypes(items, true);\n\t\tif (typeof idOrMetadata === 'string') {\n\t\t\tthis.id = idOrMetadata;\n\t\t\tthis.metadata = metadata;\n\t\t} else {\n\t\t\tthis.id = generateUuid();\n\t\t\tthis.metadata = idOrMetadata ?? metadata;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type * as vscode from 'vscode';\nimport { es5ClassCompat } from './es5ClassCompat.js';\nimport { illegalArgument } from '../../../../base/common/errors.js';\nimport { Mimes, normalizeMimeType, isTextStreamMime } from '../../../../base/common/mime.js';\nimport { generateUuid } from '../../../../base/common/uuid.js';\n\n/* eslint-disable local/code-no-native-private */\n\nexport enum NotebookCellKind {\n\tMarkup = 1,\n\tCode = 2\n}\n\nexport class NotebookRange {\n\tstatic isNotebookRange(thing: unknown): thing is vscode.NotebookRange {\n\t\tif (thing instanceof NotebookRange) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<NotebookRange>thing).start === 'number'\n\t\t\t&& typeof (<NotebookRange>thing).end === 'number';\n\t}\n\n\tprivate _start: number;\n\tprivate _end: number;\n\n\tget start() {\n\t\treturn this._start;\n\t}\n\n\tget end() {\n\t\treturn this._end;\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this._start === this._end;\n\t}\n\n\tconstructor(start: number, end: number) {\n\t\tif (start < 0) {\n\t\t\tthrow illegalArgument('start must be positive');\n\t\t}\n\t\tif (end < 0) {\n\t\t\tthrow illegalArgument('end must be positive');\n\t\t}\n\t\tif (start <= end) {\n\t\t\tthis._start = start;\n\t\t\tthis._end = end;\n\t\t} else {\n\t\t\tthis._start = end;\n\t\t\tthis._end = start;\n\t\t}\n\t}\n\n\twith(change: { start?: number; end?: number }): NotebookRange {\n\t\tlet start = this._start;\n\t\tlet end = this._end;\n\n\t\tif (change.start !== undefined) {\n\t\t\tstart = change.start;\n\t\t}\n\t\tif (change.end !== undefined) {\n\t\t\tend = change.end;\n\t\t}\n\t\tif (start === this._start && end === this._end) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new NotebookRange(start, end);\n\t}\n}\n\nexport class NotebookCellData {\n\n\tstatic validate(data: NotebookCellData): void {\n\t\tif (typeof data.kind !== 'number') {\n\t\t\tthrow new Error('NotebookCellData MUST have \\'kind\\' property');\n\t\t}\n\t\tif (typeof data.value !== 'string') {\n\t\t\tthrow new Error('NotebookCellData MUST have \\'value\\' property');\n\t\t}\n\t\tif (typeof data.languageId !== 'string') {\n\t\t\tthrow new Error('NotebookCellData MUST have \\'languageId\\' property');\n\t\t}\n\t}\n\n\tstatic isNotebookCellDataArray(value: unknown): value is vscode.NotebookCellData[] {\n\t\treturn Array.isArray(value) && (<unknown[]>value).every(elem => NotebookCellData.isNotebookCellData(elem));\n\t}\n\n\tstatic isNotebookCellData(value: unknown): value is vscode.NotebookCellData {\n\t\t// return value instanceof NotebookCellData;\n\t\treturn true;\n\t}\n\n\tkind: NotebookCellKind;\n\tvalue: string;\n\tlanguageId: string;\n\tmime?: string;\n\toutputs?: vscode.NotebookCellOutput[];\n\tmetadata?: Record<string, unknown>;\n\texecutionSummary?: vscode.NotebookCellExecutionSummary;\n\n\tconstructor(kind: NotebookCellKind, value: string, languageId: string, mime?: string, outputs?: vscode.NotebookCellOutput[], metadata?: Record<string, unknown>, executionSummary?: vscode.NotebookCellExecutionSummary) {\n\t\tthis.kind = kind;\n\t\tthis.value = value;\n\t\tthis.languageId = languageId;\n\t\tthis.mime = mime;\n\t\tthis.outputs = outputs ?? [];\n\t\tthis.metadata = metadata;\n\t\tthis.executionSummary = executionSummary;\n\n\t\tNotebookCellData.validate(this);\n\t}\n}\n\nexport class NotebookData {\n\n\tcells: NotebookCellData[];\n\tmetadata?: { [key: string]: unknown };\n\n\tconstructor(cells: NotebookCellData[]) {\n\t\tthis.cells = cells;\n\t}\n}\n\n@es5ClassCompat\nexport class NotebookEdit implements vscode.NotebookEdit {\n\n\tstatic isNotebookCellEdit(thing: unknown): thing is NotebookEdit {\n\t\tif (thing instanceof NotebookEdit) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn NotebookRange.isNotebookRange((<NotebookEdit>thing))\n\t\t\t&& Array.isArray((<NotebookEdit>thing).newCells);\n\t}\n\n\tstatic replaceCells(range: NotebookRange, newCells: NotebookCellData[]): NotebookEdit {\n\t\treturn new NotebookEdit(range, newCells);\n\t}\n\n\tstatic insertCells(index: number, newCells: vscode.NotebookCellData[]): vscode.NotebookEdit {\n\t\treturn new NotebookEdit(new NotebookRange(index, index), newCells);\n\t}\n\n\tstatic deleteCells(range: NotebookRange): NotebookEdit {\n\t\treturn new NotebookEdit(range, []);\n\t}\n\n\tstatic updateCellMetadata(index: number, newMetadata: { [key: string]: unknown }): NotebookEdit {\n\t\tconst edit = new NotebookEdit(new NotebookRange(index, index), []);\n\t\tedit.newCellMetadata = newMetadata;\n\t\treturn edit;\n\t}\n\n\tstatic updateNotebookMetadata(newMetadata: { [key: string]: unknown }): NotebookEdit {\n\t\tconst edit = new NotebookEdit(new NotebookRange(0, 0), []);\n\t\tedit.newNotebookMetadata = newMetadata;\n\t\treturn edit;\n\t}\n\n\trange: NotebookRange;\n\tnewCells: NotebookCellData[];\n\tnewCellMetadata?: { [key: string]: unknown };\n\tnewNotebookMetadata?: { [key: string]: unknown };\n\n\tconstructor(range: NotebookRange, newCells: NotebookCellData[]) {\n\t\tthis.range = range;\n\t\tthis.newCells = newCells;\n\t}\n}\n\nexport class NotebookCellOutputItem {\n\n\tstatic isNotebookCellOutputItem(obj: unknown): obj is vscode.NotebookCellOutputItem {\n\t\tif (obj instanceof NotebookCellOutputItem) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!obj) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<vscode.NotebookCellOutputItem>obj).mime === 'string'\n\t\t\t&& (<vscode.NotebookCellOutputItem>obj).data instanceof Uint8Array;\n\t}\n\n\tstatic error(err: Error | { name: string; message?: string; stack?: string }): NotebookCellOutputItem {\n\t\tconst obj = {\n\t\t\tname: err.name,\n\t\t\tmessage: err.message,\n\t\t\tstack: err.stack\n\t\t};\n\t\treturn NotebookCellOutputItem.json(obj, 'application/vnd.code.notebook.error');\n\t}\n\n\tstatic stdout(value: string): NotebookCellOutputItem {\n\t\treturn NotebookCellOutputItem.text(value, 'application/vnd.code.notebook.stdout');\n\t}\n\n\tstatic stderr(value: string): NotebookCellOutputItem {\n\t\treturn NotebookCellOutputItem.text(value, 'application/vnd.code.notebook.stderr');\n\t}\n\n\tstatic bytes(value: Uint8Array, mime: string = 'application/octet-stream'): NotebookCellOutputItem {\n\t\treturn new NotebookCellOutputItem(value, mime);\n\t}\n\n\tstatic #encoder = new TextEncoder();\n\n\tstatic text(value: string, mime: string = Mimes.text): NotebookCellOutputItem {\n\t\tconst bytes = NotebookCellOutputItem.#encoder.encode(String(value));\n\t\treturn new NotebookCellOutputItem(bytes, mime);\n\t}\n\n\tstatic json(value: unknown, mime: string = 'text/x-json'): NotebookCellOutputItem {\n\t\tconst rawStr = JSON.stringify(value, undefined, '\\t');\n\t\treturn NotebookCellOutputItem.text(rawStr, mime);\n\t}\n\n\tconstructor(\n\t\tpublic data: Uint8Array,\n\t\tpublic mime: string\n\t) {\n\t\tconst mimeNormalized = normalizeMimeType(mime, true);\n\t\tif (!mimeNormalized) {\n\t\t\tthrow new Error(`INVALID mime type: ${mime}. Must be in the format \"type/subtype[;optionalparameter]\"`);\n\t\t}\n\t\tthis.mime = mimeNormalized;\n\t}\n}\n\nexport class NotebookCellOutput {\n\n\tstatic isNotebookCellOutput(candidate: unknown): candidate is vscode.NotebookCellOutput {\n\t\tif (candidate instanceof NotebookCellOutput) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!candidate || typeof candidate !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<NotebookCellOutput>candidate).id === 'string' && Array.isArray((<NotebookCellOutput>candidate).items);\n\t}\n\n\tstatic ensureUniqueMimeTypes(items: NotebookCellOutputItem[], warn: boolean = false): NotebookCellOutputItem[] {\n\t\tconst seen = new Set<string>();\n\t\tconst removeIdx = new Set<number>();\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\tconst item = items[i];\n\t\t\tconst normalMime = normalizeMimeType(item.mime);\n\t\t\t// We can have multiple text stream mime types in the same output.\n\t\t\tif (!seen.has(normalMime) || isTextStreamMime(normalMime)) {\n\t\t\t\tseen.add(normalMime);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// duplicated mime types... first has won\n\t\t\tremoveIdx.add(i);\n\t\t\tif (warn) {\n\t\t\t\tconsole.warn(`DUPLICATED mime type '${item.mime}' will be dropped`);\n\t\t\t}\n\t\t}\n\t\tif (removeIdx.size === 0) {\n\t\t\treturn items;\n\t\t}\n\t\treturn items.filter((_item, index) => !removeIdx.has(index));\n\t}\n\n\tid: string;\n\titems: NotebookCellOutputItem[];\n\tmetadata?: Record<string, unknown>;\n\n\tconstructor(\n\t\titems: NotebookCellOutputItem[],\n\t\tidOrMetadata?: string | Record<string, unknown>,\n\t\tmetadata?: Record<string, unknown>\n\t) {\n\t\tthis.items = NotebookCellOutput.ensureUniqueMimeTypes(items, true);\n\t\tif (typeof idOrMetadata === 'string') {\n\t\t\tthis.id = idOrMetadata;\n\t\t\tthis.metadata = metadata;\n\t\t} else {\n\t\t\tthis.id = generateUuid();\n\t\t\tthis.metadata = idOrMetadata ?? metadata;\n\t\t}\n\t}\n}\n"]}