{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/common/extHostTask.ts","vs/workbench/api/common/extHostTask.ts"],"names":[],"mappings":"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","file":"extHostTask.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* eslint-disable local/code-no-native-private */\n\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { asPromise } from '../../../base/common/async.js';\nimport { Event, Emitter } from '../../../base/common/event.js';\n\nimport { MainContext, MainThreadTaskShape, ExtHostTaskShape } from './extHost.protocol.js';\nimport * as types from './extHostTypes.js';\nimport { IExtHostWorkspaceProvider, IExtHostWorkspace } from './extHostWorkspace.js';\nimport type * as vscode from 'vscode';\nimport * as tasks from './shared/tasks.js';\nimport { IExtHostDocumentsAndEditors } from './extHostDocumentsAndEditors.js';\nimport { IExtHostConfiguration } from './extHostConfiguration.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { IExtHostTerminalService } from './extHostTerminalService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport * as Platform from '../../../base/common/platform.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { IExtHostApiDeprecationService } from './extHostApiDeprecationService.js';\nimport { USER_TASKS_GROUP_KEY } from '../../contrib/tasks/common/tasks.js';\nimport { ErrorNoTelemetry, NotSupportedError } from '../../../base/common/errors.js';\nimport { asArray } from '../../../base/common/arrays.js';\nimport { ITaskProblemMatcherStartedDto, ITaskProblemMatcherEndedDto } from './shared/tasks.js';\n\nexport interface IExtHostTask extends ExtHostTaskShape {\n\n\treadonly _serviceBrand: undefined;\n\n\ttaskExecutions: vscode.TaskExecution[];\n\treadonly onDidStartTask: Event<vscode.TaskStartEvent>;\n\treadonly onDidEndTask: Event<vscode.TaskEndEvent>;\n\treadonly onDidStartTaskProcess: Event<vscode.TaskProcessStartEvent>;\n\treadonly onDidEndTaskProcess: Event<vscode.TaskProcessEndEvent>;\n\treadonly onDidStartTaskProblemMatchers: Event<vscode.TaskProblemMatcherStartedEvent>;\n\treadonly onDidEndTaskProblemMatchers: Event<vscode.TaskProblemMatcherEndedEvent>;\n\n\tregisterTaskProvider(extension: IExtensionDescription, type: string, provider: vscode.TaskProvider): vscode.Disposable;\n\tregisterTaskSystem(scheme: string, info: tasks.ITaskSystemInfoDTO): void;\n\tfetchTasks(filter?: vscode.TaskFilter): Promise<vscode.Task[]>;\n\texecuteTask(extension: IExtensionDescription, task: vscode.Task): Promise<vscode.TaskExecution>;\n\tterminateTask(execution: vscode.TaskExecution): Promise<void>;\n}\n\nnamespace TaskDefinitionDTO {\n\texport function from(value: vscode.TaskDefinition): tasks.ITaskDefinitionDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n\texport function to(value: tasks.ITaskDefinitionDTO): vscode.TaskDefinition | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n}\n\nnamespace TaskPresentationOptionsDTO {\n\texport function from(value: vscode.TaskPresentationOptions): tasks.ITaskPresentationOptionsDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n\texport function to(value: tasks.ITaskPresentationOptionsDTO): vscode.TaskPresentationOptions | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n}\n\nnamespace ProcessExecutionOptionsDTO {\n\texport function from(value: vscode.ProcessExecutionOptions): tasks.IProcessExecutionOptionsDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n\texport function to(value: tasks.IProcessExecutionOptionsDTO): vscode.ProcessExecutionOptions | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n}\n\nnamespace ProcessExecutionDTO {\n\texport function is(value: tasks.IShellExecutionDTO | tasks.IProcessExecutionDTO | tasks.ICustomExecutionDTO | undefined): value is tasks.IProcessExecutionDTO {\n\t\tif (value) {\n\t\t\tconst candidate = value as tasks.IProcessExecutionDTO;\n\t\t\treturn candidate && !!candidate.process;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\texport function from(value: vscode.ProcessExecution): tasks.IProcessExecutionDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst result: tasks.IProcessExecutionDTO = {\n\t\t\tprocess: value.process,\n\t\t\targs: value.args\n\t\t};\n\t\tif (value.options) {\n\t\t\tresult.options = ProcessExecutionOptionsDTO.from(value.options);\n\t\t}\n\t\treturn result;\n\t}\n\texport function to(value: tasks.IProcessExecutionDTO): types.ProcessExecution | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new types.ProcessExecution(value.process, value.args, value.options);\n\t}\n}\n\nnamespace ShellExecutionOptionsDTO {\n\texport function from(value: vscode.ShellExecutionOptions): tasks.IShellExecutionOptionsDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n\texport function to(value: tasks.IShellExecutionOptionsDTO): vscode.ShellExecutionOptions | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n}\n\nnamespace ShellExecutionDTO {\n\texport function is(value: tasks.IShellExecutionDTO | tasks.IProcessExecutionDTO | tasks.ICustomExecutionDTO | undefined): value is tasks.IShellExecutionDTO {\n\t\tif (value) {\n\t\t\tconst candidate = value as tasks.IShellExecutionDTO;\n\t\t\treturn candidate && (!!candidate.commandLine || !!candidate.command);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\texport function from(value: vscode.ShellExecution): tasks.IShellExecutionDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst result: tasks.IShellExecutionDTO = {\n\t\t};\n\t\tif (value.commandLine !== undefined) {\n\t\t\tresult.commandLine = value.commandLine;\n\t\t} else {\n\t\t\tresult.command = value.command;\n\t\t\tresult.args = value.args;\n\t\t}\n\t\tif (value.options) {\n\t\t\tresult.options = ShellExecutionOptionsDTO.from(value.options);\n\t\t}\n\t\treturn result;\n\t}\n\texport function to(value: tasks.IShellExecutionDTO): types.ShellExecution | undefined {\n\t\tif (value === undefined || value === null || (value.command === undefined && value.commandLine === undefined)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (value.commandLine) {\n\t\t\treturn new types.ShellExecution(value.commandLine, value.options);\n\t\t} else {\n\t\t\treturn new types.ShellExecution(value.command!, value.args ? value.args : [], value.options);\n\t\t}\n\t}\n}\n\nexport namespace CustomExecutionDTO {\n\texport function is(value: tasks.IShellExecutionDTO | tasks.IProcessExecutionDTO | tasks.ICustomExecutionDTO | undefined): value is tasks.ICustomExecutionDTO {\n\t\tif (value) {\n\t\t\tconst candidate = value as tasks.ICustomExecutionDTO;\n\t\t\treturn candidate && candidate.customExecution === 'customExecution';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\texport function from(value: vscode.CustomExecution): tasks.ICustomExecutionDTO {\n\t\treturn {\n\t\t\tcustomExecution: 'customExecution'\n\t\t};\n\t}\n\n\texport function to(taskId: string, providedCustomExeutions: Map<string, types.CustomExecution>): types.CustomExecution | undefined {\n\t\treturn providedCustomExeutions.get(taskId);\n\t}\n}\n\n\nexport namespace TaskHandleDTO {\n\texport function from(value: types.Task, workspaceService?: IExtHostWorkspace): tasks.ITaskHandleDTO {\n\t\tlet folder: UriComponents | string;\n\t\tif (value.scope !== undefined && typeof value.scope !== 'number') {\n\t\t\tfolder = value.scope.uri;\n\t\t} else if (value.scope !== undefined && typeof value.scope === 'number') {\n\t\t\tif ((value.scope === types.TaskScope.Workspace) && workspaceService && workspaceService.workspaceFile) {\n\t\t\t\tfolder = workspaceService.workspaceFile;\n\t\t\t} else {\n\t\t\t\tfolder = USER_TASKS_GROUP_KEY;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tid: value._id!,\n\t\t\tworkspaceFolder: folder!\n\t\t};\n\t}\n}\nnamespace TaskGroupDTO {\n\texport function from(value: vscode.TaskGroup): tasks.ITaskGroupDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn { _id: value.id, isDefault: value.isDefault };\n\t}\n}\n\nexport namespace TaskDTO {\n\texport function fromMany(tasks: vscode.Task[], extension: IExtensionDescription): tasks.ITaskDTO[] {\n\t\tif (tasks === undefined || tasks === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst result: tasks.ITaskDTO[] = [];\n\t\tfor (const task of tasks) {\n\t\t\tconst converted = from(task, extension);\n\t\t\tif (converted) {\n\t\t\t\tresult.push(converted);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\texport function from(value: vscode.Task, extension: IExtensionDescription): tasks.ITaskDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet execution: tasks.IShellExecutionDTO | tasks.IProcessExecutionDTO | tasks.ICustomExecutionDTO | undefined;\n\t\tif (value.execution instanceof types.ProcessExecution) {\n\t\t\texecution = ProcessExecutionDTO.from(value.execution);\n\t\t} else if (value.execution instanceof types.ShellExecution) {\n\t\t\texecution = ShellExecutionDTO.from(value.execution);\n\t\t} else if (value.execution && value.execution instanceof types.CustomExecution) {\n\t\t\texecution = CustomExecutionDTO.from(<types.CustomExecution>value.execution);\n\t\t}\n\n\t\tconst definition: tasks.ITaskDefinitionDTO | undefined = TaskDefinitionDTO.from(value.definition);\n\t\tlet scope: number | UriComponents;\n\t\tif (value.scope) {\n\t\t\tif (typeof value.scope === 'number') {\n\t\t\t\tscope = value.scope;\n\t\t\t} else {\n\t\t\t\tscope = value.scope.uri;\n\t\t\t}\n\t\t} else {\n\t\t\t// To continue to support the deprecated task constructor that doesn't take a scope, we must add a scope here:\n\t\t\tscope = types.TaskScope.Workspace;\n\t\t}\n\t\tif (!definition || !scope) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst result: tasks.ITaskDTO = {\n\t\t\t_id: (value as types.Task)._id!,\n\t\t\tdefinition,\n\t\t\tname: value.name,\n\t\t\tsource: {\n\t\t\t\textensionId: extension.identifier.value,\n\t\t\t\tlabel: value.source,\n\t\t\t\tscope: scope\n\t\t\t},\n\t\t\texecution: execution!,\n\t\t\tisBackground: value.isBackground,\n\t\t\tgroup: TaskGroupDTO.from(value.group as vscode.TaskGroup),\n\t\t\tpresentationOptions: TaskPresentationOptionsDTO.from(value.presentationOptions),\n\t\t\tproblemMatchers: asArray(value.problemMatchers),\n\t\t\thasDefinedMatchers: (value as types.Task).hasDefinedMatchers,\n\t\t\trunOptions: value.runOptions ? value.runOptions : { reevaluateOnRerun: true },\n\t\t\tdetail: value.detail\n\t\t};\n\t\treturn result;\n\t}\n\texport async function to(value: tasks.ITaskDTO | undefined, workspace: IExtHostWorkspaceProvider, providedCustomExeutions: Map<string, types.CustomExecution>): Promise<types.Task | undefined> {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet execution: types.ShellExecution | types.ProcessExecution | types.CustomExecution | undefined;\n\t\tif (ProcessExecutionDTO.is(value.execution)) {\n\t\t\texecution = ProcessExecutionDTO.to(value.execution);\n\t\t} else if (ShellExecutionDTO.is(value.execution)) {\n\t\t\texecution = ShellExecutionDTO.to(value.execution);\n\t\t} else if (CustomExecutionDTO.is(value.execution)) {\n\t\t\texecution = CustomExecutionDTO.to(value._id, providedCustomExeutions);\n\t\t}\n\t\tconst definition: vscode.TaskDefinition | undefined = TaskDefinitionDTO.to(value.definition);\n\t\tlet scope: vscode.TaskScope.Global | vscode.TaskScope.Workspace | vscode.WorkspaceFolder | undefined;\n\t\tif (value.source) {\n\t\t\tif (value.source.scope !== undefined) {\n\t\t\t\tif (typeof value.source.scope === 'number') {\n\t\t\t\t\tscope = value.source.scope;\n\t\t\t\t} else {\n\t\t\t\t\tscope = await workspace.resolveWorkspaceFolder(URI.revive(value.source.scope));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscope = types.TaskScope.Workspace;\n\t\t\t}\n\t\t}\n\t\tif (!definition || !scope) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst result = new types.Task(definition, scope, value.name!, value.source.label, execution, value.problemMatchers);\n\t\tif (value.isBackground !== undefined) {\n\t\t\tresult.isBackground = value.isBackground;\n\t\t}\n\t\tif (value.group !== undefined) {\n\t\t\tresult.group = types.TaskGroup.from(value.group._id);\n\t\t\tif (result.group && value.group.isDefault) {\n\t\t\t\tresult.group = new types.TaskGroup(result.group.id, result.group.label);\n\t\t\t\tif (value.group.isDefault === true) {\n\t\t\t\t\tresult.group.isDefault = value.group.isDefault;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (value.presentationOptions) {\n\t\t\tresult.presentationOptions = TaskPresentationOptionsDTO.to(value.presentationOptions)!;\n\t\t}\n\t\tif (value._id) {\n\t\t\tresult._id = value._id;\n\t\t}\n\t\tif (value.detail) {\n\t\t\tresult.detail = value.detail;\n\t\t}\n\t\treturn result;\n\t}\n}\n\nnamespace TaskFilterDTO {\n\texport function from(value: vscode.TaskFilter | undefined): tasks.ITaskFilterDTO | undefined {\n\t\treturn value;\n\t}\n\n\texport function to(value: tasks.ITaskFilterDTO): vscode.TaskFilter | undefined {\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn Object.assign(Object.create(null), value);\n\t}\n}\n\nclass TaskExecutionImpl implements vscode.TaskExecution {\n\n\treadonly #tasks: ExtHostTaskBase;\n\tprivate _terminal: vscode.Terminal | undefined;\n\n\tconstructor(tasks: ExtHostTaskBase, readonly _id: string, private readonly _task: vscode.Task) {\n\t\tthis.#tasks = tasks;\n\t}\n\n\tpublic get task(): vscode.Task {\n\t\treturn this._task;\n\t}\n\n\tpublic terminate(): void {\n\t\tthis.#tasks.terminateTask(this);\n\t}\n\n\tpublic fireDidStartProcess(value: tasks.ITaskProcessStartedDTO): void {\n\t}\n\n\tpublic fireDidEndProcess(value: tasks.ITaskProcessEndedDTO): void {\n\t}\n\n\tpublic get terminal(): vscode.Terminal | undefined {\n\t\treturn this._terminal;\n\t}\n\n\tpublic set terminal(term: vscode.Terminal | undefined) {\n\t\tthis._terminal = term;\n\t}\n}\n\nexport interface HandlerData {\n\ttype: string;\n\tprovider: vscode.TaskProvider;\n\textension: IExtensionDescription;\n}\n\nexport abstract class ExtHostTaskBase implements ExtHostTaskShape, IExtHostTask {\n\treadonly _serviceBrand: undefined;\n\n\tprotected readonly _proxy: MainThreadTaskShape;\n\tprotected readonly _workspaceProvider: IExtHostWorkspaceProvider;\n\tprotected readonly _editorService: IExtHostDocumentsAndEditors;\n\tprotected readonly _configurationService: IExtHostConfiguration;\n\tprotected readonly _terminalService: IExtHostTerminalService;\n\tprotected readonly _logService: ILogService;\n\tprotected readonly _deprecationService: IExtHostApiDeprecationService;\n\tprotected _handleCounter: number;\n\tprotected _handlers: Map<number, HandlerData>;\n\tprotected _taskExecutions: Map<string, TaskExecutionImpl>;\n\tprotected _taskExecutionPromises: Map<string, Promise<TaskExecutionImpl>>;\n\tprotected _providedCustomExecutions2: Map<string, types.CustomExecution>;\n\tprivate _notProvidedCustomExecutions: Set<string>; // Used for custom executions tasks that are created and run through executeTask.\n\tprotected _activeCustomExecutions2: Map<string, types.CustomExecution>;\n\tprivate _lastStartedTask: string | undefined;\n\tprotected readonly _onDidExecuteTask: Emitter<vscode.TaskStartEvent> = new Emitter<vscode.TaskStartEvent>();\n\tprotected readonly _onDidTerminateTask: Emitter<vscode.TaskEndEvent> = new Emitter<vscode.TaskEndEvent>();\n\n\tprotected readonly _onDidTaskProcessStarted: Emitter<vscode.TaskProcessStartEvent> = new Emitter<vscode.TaskProcessStartEvent>();\n\tprotected readonly _onDidTaskProcessEnded: Emitter<vscode.TaskProcessEndEvent> = new Emitter<vscode.TaskProcessEndEvent>();\n\tprotected readonly _onDidStartTaskProblemMatchers: Emitter<vscode.TaskProblemMatcherStartedEvent> = new Emitter<vscode.TaskProblemMatcherStartedEvent>();\n\tprotected readonly _onDidEndTaskProblemMatchers: Emitter<vscode.TaskProblemMatcherEndedEvent> = new Emitter<vscode.TaskProblemMatcherEndedEvent>();\n\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService initData: IExtHostInitDataService,\n\t\t@IExtHostWorkspace workspaceService: IExtHostWorkspace,\n\t\t@IExtHostDocumentsAndEditors editorService: IExtHostDocumentsAndEditors,\n\t\t@IExtHostConfiguration configurationService: IExtHostConfiguration,\n\t\t@IExtHostTerminalService extHostTerminalService: IExtHostTerminalService,\n\t\t@ILogService logService: ILogService,\n\t\t@IExtHostApiDeprecationService deprecationService: IExtHostApiDeprecationService\n\t) {\n\t\tthis._proxy = extHostRpc.getProxy(MainContext.MainThreadTask);\n\t\tthis._workspaceProvider = workspaceService;\n\t\tthis._editorService = editorService;\n\t\tthis._configurationService = configurationService;\n\t\tthis._terminalService = extHostTerminalService;\n\t\tthis._handleCounter = 0;\n\t\tthis._handlers = new Map<number, HandlerData>();\n\t\tthis._taskExecutions = new Map<string, TaskExecutionImpl>();\n\t\tthis._taskExecutionPromises = new Map<string, Promise<TaskExecutionImpl>>();\n\t\tthis._providedCustomExecutions2 = new Map<string, types.CustomExecution>();\n\t\tthis._notProvidedCustomExecutions = new Set<string>();\n\t\tthis._activeCustomExecutions2 = new Map<string, types.CustomExecution>();\n\t\tthis._logService = logService;\n\t\tthis._deprecationService = deprecationService;\n\t\tthis._proxy.$registerSupportedExecutions(true);\n\t}\n\n\tpublic registerTaskProvider(extension: IExtensionDescription, type: string, provider: vscode.TaskProvider): vscode.Disposable {\n\t\tif (!provider) {\n\t\t\treturn new types.Disposable(() => { });\n\t\t}\n\t\tconst handle = this.nextHandle();\n\t\tthis._handlers.set(handle, { type, provider, extension });\n\t\tthis._proxy.$registerTaskProvider(handle, type);\n\t\treturn new types.Disposable(() => {\n\t\t\tthis._handlers.delete(handle);\n\t\t\tthis._proxy.$unregisterTaskProvider(handle);\n\t\t});\n\t}\n\n\tpublic registerTaskSystem(scheme: string, info: tasks.ITaskSystemInfoDTO): void {\n\t\tthis._proxy.$registerTaskSystem(scheme, info);\n\t}\n\n\tpublic fetchTasks(filter?: vscode.TaskFilter): Promise<vscode.Task[]> {\n\t\treturn this._proxy.$fetchTasks(TaskFilterDTO.from(filter)).then(async (values) => {\n\t\t\tconst result: vscode.Task[] = [];\n\t\t\tfor (const value of values) {\n\t\t\t\tconst task = await TaskDTO.to(value, this._workspaceProvider, this._providedCustomExecutions2);\n\t\t\t\tif (task) {\n\t\t\t\t\tresult.push(task);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tpublic abstract executeTask(extension: IExtensionDescription, task: vscode.Task): Promise<vscode.TaskExecution>;\n\n\tpublic get taskExecutions(): vscode.TaskExecution[] {\n\t\tconst result: vscode.TaskExecution[] = [];\n\t\tthis._taskExecutions.forEach(value => result.push(value));\n\t\treturn result;\n\t}\n\n\tpublic terminateTask(execution: vscode.TaskExecution): Promise<void> {\n\t\tif (!(execution instanceof TaskExecutionImpl)) {\n\t\t\tthrow new Error('No valid task execution provided');\n\t\t}\n\t\treturn this._proxy.$terminateTask((execution as TaskExecutionImpl)._id);\n\t}\n\n\tpublic get onDidStartTask(): Event<vscode.TaskStartEvent> {\n\t\treturn this._onDidExecuteTask.event;\n\t}\n\n\tpublic async $onDidStartTask(execution: tasks.ITaskExecutionDTO, terminalId: number, resolvedDefinition: tasks.ITaskDefinitionDTO): Promise<void> {\n\t\tconst customExecution: types.CustomExecution | undefined = this._providedCustomExecutions2.get(execution.id);\n\t\tif (customExecution) {\n\t\t\t// Clone the custom execution to keep the original untouched. This is important for multiple runs of the same task.\n\t\t\tthis._activeCustomExecutions2.set(execution.id, customExecution);\n\t\t\tthis._terminalService.attachPtyToTerminal(terminalId, await customExecution.callback(resolvedDefinition));\n\t\t}\n\t\tthis._lastStartedTask = execution.id;\n\n\t\tconst taskExecution = await this.getTaskExecution(execution);\n\t\tconst terminal = this._terminalService.getTerminalById(terminalId)?.value;\n\t\tif (taskExecution) {\n\t\t\ttaskExecution.terminal = terminal;\n\t\t}\n\n\t\tthis._onDidExecuteTask.fire({\n\t\t\texecution: taskExecution\n\t\t});\n\t}\n\n\tpublic get onDidEndTask(): Event<vscode.TaskEndEvent> {\n\t\treturn this._onDidTerminateTask.event;\n\t}\n\n\tpublic async $OnDidEndTask(execution: tasks.ITaskExecutionDTO): Promise<void> {\n\t\tif (!this._taskExecutionPromises.has(execution.id)) {\n\t\t\t// Event already fired by the main thread\n\t\t\t// See https://github.com/microsoft/vscode/commit/aaf73920aeae171096d205efb2c58804a32b6846\n\t\t\treturn;\n\t\t}\n\t\tconst _execution = await this.getTaskExecution(execution);\n\t\tthis._taskExecutionPromises.delete(execution.id);\n\t\tthis._taskExecutions.delete(execution.id);\n\t\tthis.customExecutionComplete(execution);\n\t\tthis._onDidTerminateTask.fire({\n\t\t\texecution: _execution\n\t\t});\n\t}\n\n\tpublic get onDidStartTaskProcess(): Event<vscode.TaskProcessStartEvent> {\n\t\treturn this._onDidTaskProcessStarted.event;\n\t}\n\n\tpublic async $onDidStartTaskProcess(value: tasks.ITaskProcessStartedDTO): Promise<void> {\n\t\tconst execution = await this.getTaskExecution(value.id);\n\t\tthis._onDidTaskProcessStarted.fire({\n\t\t\texecution: execution,\n\t\t\tprocessId: value.processId\n\t\t});\n\t}\n\n\tpublic get onDidEndTaskProcess(): Event<vscode.TaskProcessEndEvent> {\n\t\treturn this._onDidTaskProcessEnded.event;\n\t}\n\n\tpublic async $onDidEndTaskProcess(value: tasks.ITaskProcessEndedDTO): Promise<void> {\n\t\tconst execution = await this.getTaskExecution(value.id);\n\t\tthis._onDidTaskProcessEnded.fire({\n\t\t\texecution: execution,\n\t\t\texitCode: value.exitCode\n\t\t});\n\t}\n\n\tpublic get onDidStartTaskProblemMatchers(): Event<vscode.TaskProblemMatcherStartedEvent> {\n\t\treturn this._onDidStartTaskProblemMatchers.event;\n\t}\n\n\tpublic async $onDidStartTaskProblemMatchers(value: ITaskProblemMatcherStartedDto): Promise<void> {\n\t\tlet execution;\n\t\ttry {\n\t\t\texecution = await this.getTaskExecution(value.execution.id);\n\t\t} catch (error) {\n\t\t\t// The task execution is not available anymore\n\t\t\treturn;\n\t\t}\n\n\t\tthis._onDidStartTaskProblemMatchers.fire({ execution });\n\t}\n\n\tpublic get onDidEndTaskProblemMatchers(): Event<vscode.TaskProblemMatcherEndedEvent> {\n\t\treturn this._onDidEndTaskProblemMatchers.event;\n\t}\n\n\tpublic async $onDidEndTaskProblemMatchers(value: ITaskProblemMatcherEndedDto): Promise<void> {\n\t\tlet execution;\n\t\ttry {\n\t\t\texecution = await this.getTaskExecution(value.execution.id);\n\t\t} catch (error) {\n\t\t\t// The task execution is not available anymore\n\t\t\treturn;\n\t\t}\n\n\t\tthis._onDidEndTaskProblemMatchers.fire({ execution, hasErrors: value.hasErrors });\n\t}\n\n\tprotected abstract provideTasksInternal(validTypes: { [key: string]: boolean }, taskIdPromises: Promise<void>[], handler: HandlerData, value: vscode.Task[] | null | undefined): { tasks: tasks.ITaskDTO[]; extension: IExtensionDescription };\n\n\tpublic $provideTasks(handle: number, validTypes: { [key: string]: boolean }): Promise<tasks.ITaskSetDTO> {\n\t\tconst handler = this._handlers.get(handle);\n\t\tif (!handler) {\n\t\t\treturn Promise.reject(new Error('no handler found'));\n\t\t}\n\n\t\t// Set up a list of task ID promises that we can wait on\n\t\t// before returning the provided tasks. The ensures that\n\t\t// our task IDs are calculated for any custom execution tasks.\n\t\t// Knowing this ID ahead of time is needed because when a task\n\t\t// start event is fired this is when the custom execution is called.\n\t\t// The task start event is also the first time we see the ID from the main\n\t\t// thread, which is too late for us because we need to save an map\n\t\t// from an ID to the custom execution function. (Kind of a cart before the horse problem).\n\t\tconst taskIdPromises: Promise<void>[] = [];\n\t\tconst fetchPromise = asPromise(() => handler.provider.provideTasks(CancellationToken.None)).then(value => {\n\t\t\treturn this.provideTasksInternal(validTypes, taskIdPromises, handler, value);\n\t\t});\n\n\t\treturn new Promise((resolve) => {\n\t\t\tfetchPromise.then((result) => {\n\t\t\t\tPromise.all(taskIdPromises).then(() => {\n\t\t\t\t\tresolve(result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tprotected abstract resolveTaskInternal(resolvedTaskDTO: tasks.ITaskDTO): Promise<tasks.ITaskDTO | undefined>;\n\n\tpublic async $resolveTask(handle: number, taskDTO: tasks.ITaskDTO): Promise<tasks.ITaskDTO | undefined> {\n\t\tconst handler = this._handlers.get(handle);\n\t\tif (!handler) {\n\t\t\treturn Promise.reject(new Error('no handler found'));\n\t\t}\n\n\t\tif (taskDTO.definition.type !== handler.type) {\n\t\t\tthrow new Error(`Unexpected: Task of type [${taskDTO.definition.type}] cannot be resolved by provider of type [${handler.type}].`);\n\t\t}\n\n\t\tconst task = await TaskDTO.to(taskDTO, this._workspaceProvider, this._providedCustomExecutions2);\n\t\tif (!task) {\n\t\t\tthrow new Error('Unexpected: Task cannot be resolved.');\n\t\t}\n\n\t\tconst resolvedTask = await handler.provider.resolveTask(task, CancellationToken.None);\n\t\tif (!resolvedTask) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.checkDeprecation(resolvedTask, handler);\n\n\t\tconst resolvedTaskDTO: tasks.ITaskDTO | undefined = TaskDTO.from(resolvedTask, handler.extension);\n\t\tif (!resolvedTaskDTO) {\n\t\t\tthrow new Error('Unexpected: Task cannot be resolved.');\n\t\t}\n\n\t\tif (resolvedTask.definition !== task.definition) {\n\t\t\tthrow new Error('Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed.');\n\t\t}\n\n\t\tif (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {\n\t\t\tawait this.addCustomExecution(resolvedTaskDTO, resolvedTask, true);\n\t\t}\n\n\t\treturn await this.resolveTaskInternal(resolvedTaskDTO);\n\t}\n\n\tpublic abstract $resolveVariables(uriComponents: UriComponents, toResolve: { process?: { name: string; cwd?: string; path?: string }; variables: string[] }): Promise<{ process?: string; variables: { [key: string]: string } }>;\n\n\tprivate nextHandle(): number {\n\t\treturn this._handleCounter++;\n\t}\n\n\tprotected async addCustomExecution(taskDTO: tasks.ITaskDTO, task: vscode.Task, isProvided: boolean): Promise<void> {\n\t\tconst taskId = await this._proxy.$createTaskId(taskDTO);\n\t\tif (!isProvided && !this._providedCustomExecutions2.has(taskId)) {\n\t\t\tthis._notProvidedCustomExecutions.add(taskId);\n\t\t\t// Also add to active executions when not coming from a provider to prevent timing issue.\n\t\t\tthis._activeCustomExecutions2.set(taskId, <types.CustomExecution>task.execution);\n\t\t}\n\t\tthis._providedCustomExecutions2.set(taskId, <types.CustomExecution>task.execution);\n\t}\n\n\tprotected async getTaskExecution(execution: tasks.ITaskExecutionDTO | string, task?: vscode.Task): Promise<TaskExecutionImpl> {\n\t\tif (typeof execution === 'string') {\n\t\t\tconst taskExecution = this._taskExecutionPromises.get(execution);\n\t\t\tif (!taskExecution) {\n\t\t\t\tthrow new ErrorNoTelemetry('Unexpected: The specified task is missing an execution');\n\t\t\t}\n\t\t\treturn taskExecution;\n\t\t}\n\n\t\tconst result: Promise<TaskExecutionImpl> | undefined = this._taskExecutionPromises.get(execution.id);\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tlet executionPromise: Promise<TaskExecutionImpl>;\n\t\tif (!task) {\n\t\t\texecutionPromise = TaskDTO.to(execution.task, this._workspaceProvider, this._providedCustomExecutions2).then(t => {\n\t\t\t\tif (!t) {\n\t\t\t\t\tthrow new ErrorNoTelemetry('Unexpected: Task does not exist.');\n\t\t\t\t}\n\t\t\t\treturn new TaskExecutionImpl(this, execution.id, t);\n\t\t\t});\n\t\t} else {\n\t\t\texecutionPromise = Promise.resolve(new TaskExecutionImpl(this, execution.id, task));\n\t\t}\n\t\tthis._taskExecutionPromises.set(execution.id, executionPromise);\n\t\treturn executionPromise.then(taskExecution => {\n\t\t\tthis._taskExecutions.set(execution.id, taskExecution);\n\t\t\treturn taskExecution;\n\t\t});\n\t}\n\n\tprotected checkDeprecation(task: vscode.Task, handler: HandlerData) {\n\t\tconst tTask = (task as types.Task);\n\t\tif (tTask._deprecated) {\n\t\t\tthis._deprecationService.report('Task.constructor', handler.extension, 'Use the Task constructor that takes a `scope` instead.');\n\t\t}\n\t}\n\n\tprivate customExecutionComplete(execution: tasks.ITaskExecutionDTO): void {\n\t\tconst extensionCallback2: vscode.CustomExecution | undefined = this._activeCustomExecutions2.get(execution.id);\n\t\tif (extensionCallback2) {\n\t\t\tthis._activeCustomExecutions2.delete(execution.id);\n\t\t}\n\n\t\t// Technically we don't really need to do this, however, if an extension\n\t\t// is executing a task through \"executeTask\" over and over again\n\t\t// with different properties in the task definition, then the map of executions\n\t\t// could grow indefinitely, something we don't want.\n\t\tif (this._notProvidedCustomExecutions.has(execution.id) && (this._lastStartedTask !== execution.id)) {\n\t\t\tthis._providedCustomExecutions2.delete(execution.id);\n\t\t\tthis._notProvidedCustomExecutions.delete(execution.id);\n\t\t}\n\t\tconst iterator = this._notProvidedCustomExecutions.values();\n\t\tlet iteratorResult = iterator.next();\n\t\twhile (!iteratorResult.done) {\n\t\t\tif (!this._activeCustomExecutions2.has(iteratorResult.value) && (this._lastStartedTask !== iteratorResult.value)) {\n\t\t\t\tthis._providedCustomExecutions2.delete(iteratorResult.value);\n\t\t\t\tthis._notProvidedCustomExecutions.delete(iteratorResult.value);\n\t\t\t}\n\t\t\titeratorResult = iterator.next();\n\t\t}\n\t}\n\n\tpublic abstract $jsonTasksSupported(): Promise<boolean>;\n\n\tpublic abstract $findExecutable(command: string, cwd?: string | undefined, paths?: string[] | undefined): Promise<string | undefined>;\n}\n\nexport class WorkerExtHostTask extends ExtHostTaskBase {\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService initData: IExtHostInitDataService,\n\t\t@IExtHostWorkspace workspaceService: IExtHostWorkspace,\n\t\t@IExtHostDocumentsAndEditors editorService: IExtHostDocumentsAndEditors,\n\t\t@IExtHostConfiguration configurationService: IExtHostConfiguration,\n\t\t@IExtHostTerminalService extHostTerminalService: IExtHostTerminalService,\n\t\t@ILogService logService: ILogService,\n\t\t@IExtHostApiDeprecationService deprecationService: IExtHostApiDeprecationService\n\t) {\n\t\tsuper(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService);\n\t\tthis.registerTaskSystem(Schemas.vscodeRemote, {\n\t\t\tscheme: Schemas.vscodeRemote,\n\t\t\tauthority: '',\n\t\t\tplatform: Platform.PlatformToString(Platform.Platform.Web)\n\t\t});\n\t}\n\n\tpublic async executeTask(extension: IExtensionDescription, task: vscode.Task): Promise<vscode.TaskExecution> {\n\t\tif (!task.execution) {\n\t\t\tthrow new Error('Tasks to execute must include an execution');\n\t\t}\n\n\t\tconst dto = TaskDTO.from(task, extension);\n\t\tif (dto === undefined) {\n\t\t\tthrow new Error('Task is not valid');\n\t\t}\n\n\t\t// If this task is a custom execution, then we need to save it away\n\t\t// in the provided custom execution map that is cleaned up after the\n\t\t// task is executed.\n\t\tif (CustomExecutionDTO.is(dto.execution)) {\n\t\t\tawait this.addCustomExecution(dto, task, false);\n\t\t} else {\n\t\t\tthrow new NotSupportedError();\n\t\t}\n\n\t\t// Always get the task execution first to prevent timing issues when retrieving it later\n\t\tconst execution = await this.getTaskExecution(await this._proxy.$getTaskExecution(dto), task);\n\t\tthis._proxy.$executeTask(dto).catch(error => { throw new Error(error); });\n\t\treturn execution;\n\t}\n\n\tprotected provideTasksInternal(validTypes: { [key: string]: boolean }, taskIdPromises: Promise<void>[], handler: HandlerData, value: vscode.Task[] | null | undefined): { tasks: tasks.ITaskDTO[]; extension: IExtensionDescription } {\n\t\tconst taskDTOs: tasks.ITaskDTO[] = [];\n\t\tif (value) {\n\t\t\tfor (const task of value) {\n\t\t\t\tthis.checkDeprecation(task, handler);\n\t\t\t\tif (!task.definition || !validTypes[task.definition.type]) {\n\t\t\t\t\tconst source = task.source ? task.source : 'No task source';\n\t\t\t\t\tthis._logService.warn(`The task [${source}, ${task.name}] uses an undefined task type. The task will be ignored in the future.`);\n\t\t\t\t}\n\n\t\t\t\tconst taskDTO: tasks.ITaskDTO | undefined = TaskDTO.from(task, handler.extension);\n\t\t\t\tif (taskDTO && CustomExecutionDTO.is(taskDTO.execution)) {\n\t\t\t\t\ttaskDTOs.push(taskDTO);\n\t\t\t\t\t// The ID is calculated on the main thread task side, so, let's call into it here.\n\t\t\t\t\t// We need the task id's pre-computed for custom task executions because when OnDidStartTask\n\t\t\t\t\t// is invoked, we have to be able to map it back to our data.\n\t\t\t\t\ttaskIdPromises.push(this.addCustomExecution(taskDTO, task, true));\n\t\t\t\t} else {\n\t\t\t\t\tthis._logService.warn('Only custom execution tasks supported.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttasks: taskDTOs,\n\t\t\textension: handler.extension\n\t\t};\n\t}\n\n\tprotected async resolveTaskInternal(resolvedTaskDTO: tasks.ITaskDTO): Promise<tasks.ITaskDTO | undefined> {\n\t\tif (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {\n\t\t\treturn resolvedTaskDTO;\n\t\t} else {\n\t\t\tthis._logService.warn('Only custom execution tasks supported.');\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic async $resolveVariables(uriComponents: UriComponents, toResolve: { process?: { name: string; cwd?: string; path?: string }; variables: string[] }): Promise<{ process?: string; variables: { [key: string]: string } }> {\n\t\tconst result = {\n\t\t\tprocess: <unknown>undefined as string,\n\t\t\tvariables: Object.create(null)\n\t\t};\n\t\treturn result;\n\t}\n\n\tpublic async $jsonTasksSupported(): Promise<boolean> {\n\t\treturn false;\n\t}\n\n\tpublic async $findExecutable(command: string, cwd?: string | undefined, paths?: string[] | undefined): Promise<string | undefined> {\n\t\treturn undefined;\n\t}\n}\n\nexport const IExtHostTask = createDecorator<IExtHostTask>('IExtHostTask');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/* eslint-disable local/code-no-native-private */\n\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { asPromise } from '../../../base/common/async.js';\nimport { Event, Emitter } from '../../../base/common/event.js';\n\nimport { MainContext, MainThreadTaskShape, ExtHostTaskShape } from './extHost.protocol.js';\nimport * as types from './extHostTypes.js';\nimport { IExtHostWorkspaceProvider, IExtHostWorkspace } from './extHostWorkspace.js';\nimport type * as vscode from 'vscode';\nimport * as tasks from './shared/tasks.js';\nimport { IExtHostDocumentsAndEditors } from './extHostDocumentsAndEditors.js';\nimport { IExtHostConfiguration } from './extHostConfiguration.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { IExtensionDescription } from '../../../platform/extensions/common/extensions.js';\nimport { IExtHostTerminalService } from './extHostTerminalService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport * as Platform from '../../../base/common/platform.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { IExtHostApiDeprecationService } from './extHostApiDeprecationService.js';\nimport { USER_TASKS_GROUP_KEY } from '../../contrib/tasks/common/tasks.js';\nimport { ErrorNoTelemetry, NotSupportedError } from '../../../base/common/errors.js';\nimport { asArray } from '../../../base/common/arrays.js';\nimport { ITaskProblemMatcherStartedDto, ITaskProblemMatcherEndedDto } from './shared/tasks.js';\n\nexport interface IExtHostTask extends ExtHostTaskShape {\n\n\treadonly _serviceBrand: undefined;\n\n\ttaskExecutions: vscode.TaskExecution[];\n\treadonly onDidStartTask: Event<vscode.TaskStartEvent>;\n\treadonly onDidEndTask: Event<vscode.TaskEndEvent>;\n\treadonly onDidStartTaskProcess: Event<vscode.TaskProcessStartEvent>;\n\treadonly onDidEndTaskProcess: Event<vscode.TaskProcessEndEvent>;\n\treadonly onDidStartTaskProblemMatchers: Event<vscode.TaskProblemMatcherStartedEvent>;\n\treadonly onDidEndTaskProblemMatchers: Event<vscode.TaskProblemMatcherEndedEvent>;\n\n\tregisterTaskProvider(extension: IExtensionDescription, type: string, provider: vscode.TaskProvider): vscode.Disposable;\n\tregisterTaskSystem(scheme: string, info: tasks.ITaskSystemInfoDTO): void;\n\tfetchTasks(filter?: vscode.TaskFilter): Promise<vscode.Task[]>;\n\texecuteTask(extension: IExtensionDescription, task: vscode.Task): Promise<vscode.TaskExecution>;\n\tterminateTask(execution: vscode.TaskExecution): Promise<void>;\n}\n\nnamespace TaskDefinitionDTO {\n\texport function from(value: vscode.TaskDefinition): tasks.ITaskDefinitionDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n\texport function to(value: tasks.ITaskDefinitionDTO): vscode.TaskDefinition | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n}\n\nnamespace TaskPresentationOptionsDTO {\n\texport function from(value: vscode.TaskPresentationOptions): tasks.ITaskPresentationOptionsDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n\texport function to(value: tasks.ITaskPresentationOptionsDTO): vscode.TaskPresentationOptions | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n}\n\nnamespace ProcessExecutionOptionsDTO {\n\texport function from(value: vscode.ProcessExecutionOptions): tasks.IProcessExecutionOptionsDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n\texport function to(value: tasks.IProcessExecutionOptionsDTO): vscode.ProcessExecutionOptions | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n}\n\nnamespace ProcessExecutionDTO {\n\texport function is(value: tasks.IShellExecutionDTO | tasks.IProcessExecutionDTO | tasks.ICustomExecutionDTO | undefined): value is tasks.IProcessExecutionDTO {\n\t\tif (value) {\n\t\t\tconst candidate = value as tasks.IProcessExecutionDTO;\n\t\t\treturn candidate && !!candidate.process;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\texport function from(value: vscode.ProcessExecution): tasks.IProcessExecutionDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst result: tasks.IProcessExecutionDTO = {\n\t\t\tprocess: value.process,\n\t\t\targs: value.args\n\t\t};\n\t\tif (value.options) {\n\t\t\tresult.options = ProcessExecutionOptionsDTO.from(value.options);\n\t\t}\n\t\treturn result;\n\t}\n\texport function to(value: tasks.IProcessExecutionDTO): types.ProcessExecution | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new types.ProcessExecution(value.process, value.args, value.options);\n\t}\n}\n\nnamespace ShellExecutionOptionsDTO {\n\texport function from(value: vscode.ShellExecutionOptions): tasks.IShellExecutionOptionsDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n\texport function to(value: tasks.IShellExecutionOptionsDTO): vscode.ShellExecutionOptions | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t}\n}\n\nnamespace ShellExecutionDTO {\n\texport function is(value: tasks.IShellExecutionDTO | tasks.IProcessExecutionDTO | tasks.ICustomExecutionDTO | undefined): value is tasks.IShellExecutionDTO {\n\t\tif (value) {\n\t\t\tconst candidate = value as tasks.IShellExecutionDTO;\n\t\t\treturn candidate && (!!candidate.commandLine || !!candidate.command);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\texport function from(value: vscode.ShellExecution): tasks.IShellExecutionDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst result: tasks.IShellExecutionDTO = {\n\t\t};\n\t\tif (value.commandLine !== undefined) {\n\t\t\tresult.commandLine = value.commandLine;\n\t\t} else {\n\t\t\tresult.command = value.command;\n\t\t\tresult.args = value.args;\n\t\t}\n\t\tif (value.options) {\n\t\t\tresult.options = ShellExecutionOptionsDTO.from(value.options);\n\t\t}\n\t\treturn result;\n\t}\n\texport function to(value: tasks.IShellExecutionDTO): types.ShellExecution | undefined {\n\t\tif (value === undefined || value === null || (value.command === undefined && value.commandLine === undefined)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (value.commandLine) {\n\t\t\treturn new types.ShellExecution(value.commandLine, value.options);\n\t\t} else {\n\t\t\treturn new types.ShellExecution(value.command!, value.args ? value.args : [], value.options);\n\t\t}\n\t}\n}\n\nexport namespace CustomExecutionDTO {\n\texport function is(value: tasks.IShellExecutionDTO | tasks.IProcessExecutionDTO | tasks.ICustomExecutionDTO | undefined): value is tasks.ICustomExecutionDTO {\n\t\tif (value) {\n\t\t\tconst candidate = value as tasks.ICustomExecutionDTO;\n\t\t\treturn candidate && candidate.customExecution === 'customExecution';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\texport function from(value: vscode.CustomExecution): tasks.ICustomExecutionDTO {\n\t\treturn {\n\t\t\tcustomExecution: 'customExecution'\n\t\t};\n\t}\n\n\texport function to(taskId: string, providedCustomExeutions: Map<string, types.CustomExecution>): types.CustomExecution | undefined {\n\t\treturn providedCustomExeutions.get(taskId);\n\t}\n}\n\n\nexport namespace TaskHandleDTO {\n\texport function from(value: types.Task, workspaceService?: IExtHostWorkspace): tasks.ITaskHandleDTO {\n\t\tlet folder: UriComponents | string;\n\t\tif (value.scope !== undefined && typeof value.scope !== 'number') {\n\t\t\tfolder = value.scope.uri;\n\t\t} else if (value.scope !== undefined && typeof value.scope === 'number') {\n\t\t\tif ((value.scope === types.TaskScope.Workspace) && workspaceService && workspaceService.workspaceFile) {\n\t\t\t\tfolder = workspaceService.workspaceFile;\n\t\t\t} else {\n\t\t\t\tfolder = USER_TASKS_GROUP_KEY;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tid: value._id!,\n\t\t\tworkspaceFolder: folder!\n\t\t};\n\t}\n}\nnamespace TaskGroupDTO {\n\texport function from(value: vscode.TaskGroup): tasks.ITaskGroupDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn { _id: value.id, isDefault: value.isDefault };\n\t}\n}\n\nexport namespace TaskDTO {\n\texport function fromMany(tasks: vscode.Task[], extension: IExtensionDescription): tasks.ITaskDTO[] {\n\t\tif (tasks === undefined || tasks === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst result: tasks.ITaskDTO[] = [];\n\t\tfor (const task of tasks) {\n\t\t\tconst converted = from(task, extension);\n\t\t\tif (converted) {\n\t\t\t\tresult.push(converted);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\texport function from(value: vscode.Task, extension: IExtensionDescription): tasks.ITaskDTO | undefined {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet execution: tasks.IShellExecutionDTO | tasks.IProcessExecutionDTO | tasks.ICustomExecutionDTO | undefined;\n\t\tif (value.execution instanceof types.ProcessExecution) {\n\t\t\texecution = ProcessExecutionDTO.from(value.execution);\n\t\t} else if (value.execution instanceof types.ShellExecution) {\n\t\t\texecution = ShellExecutionDTO.from(value.execution);\n\t\t} else if (value.execution && value.execution instanceof types.CustomExecution) {\n\t\t\texecution = CustomExecutionDTO.from(<types.CustomExecution>value.execution);\n\t\t}\n\n\t\tconst definition: tasks.ITaskDefinitionDTO | undefined = TaskDefinitionDTO.from(value.definition);\n\t\tlet scope: number | UriComponents;\n\t\tif (value.scope) {\n\t\t\tif (typeof value.scope === 'number') {\n\t\t\t\tscope = value.scope;\n\t\t\t} else {\n\t\t\t\tscope = value.scope.uri;\n\t\t\t}\n\t\t} else {\n\t\t\t// To continue to support the deprecated task constructor that doesn't take a scope, we must add a scope here:\n\t\t\tscope = types.TaskScope.Workspace;\n\t\t}\n\t\tif (!definition || !scope) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst result: tasks.ITaskDTO = {\n\t\t\t_id: (value as types.Task)._id!,\n\t\t\tdefinition,\n\t\t\tname: value.name,\n\t\t\tsource: {\n\t\t\t\textensionId: extension.identifier.value,\n\t\t\t\tlabel: value.source,\n\t\t\t\tscope: scope\n\t\t\t},\n\t\t\texecution: execution!,\n\t\t\tisBackground: value.isBackground,\n\t\t\tgroup: TaskGroupDTO.from(value.group as vscode.TaskGroup),\n\t\t\tpresentationOptions: TaskPresentationOptionsDTO.from(value.presentationOptions),\n\t\t\tproblemMatchers: asArray(value.problemMatchers),\n\t\t\thasDefinedMatchers: (value as types.Task).hasDefinedMatchers,\n\t\t\trunOptions: value.runOptions ? value.runOptions : { reevaluateOnRerun: true },\n\t\t\tdetail: value.detail\n\t\t};\n\t\treturn result;\n\t}\n\texport async function to(value: tasks.ITaskDTO | undefined, workspace: IExtHostWorkspaceProvider, providedCustomExeutions: Map<string, types.CustomExecution>): Promise<types.Task | undefined> {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet execution: types.ShellExecution | types.ProcessExecution | types.CustomExecution | undefined;\n\t\tif (ProcessExecutionDTO.is(value.execution)) {\n\t\t\texecution = ProcessExecutionDTO.to(value.execution);\n\t\t} else if (ShellExecutionDTO.is(value.execution)) {\n\t\t\texecution = ShellExecutionDTO.to(value.execution);\n\t\t} else if (CustomExecutionDTO.is(value.execution)) {\n\t\t\texecution = CustomExecutionDTO.to(value._id, providedCustomExeutions);\n\t\t}\n\t\tconst definition: vscode.TaskDefinition | undefined = TaskDefinitionDTO.to(value.definition);\n\t\tlet scope: vscode.TaskScope.Global | vscode.TaskScope.Workspace | vscode.WorkspaceFolder | undefined;\n\t\tif (value.source) {\n\t\t\tif (value.source.scope !== undefined) {\n\t\t\t\tif (typeof value.source.scope === 'number') {\n\t\t\t\t\tscope = value.source.scope;\n\t\t\t\t} else {\n\t\t\t\t\tscope = await workspace.resolveWorkspaceFolder(URI.revive(value.source.scope));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscope = types.TaskScope.Workspace;\n\t\t\t}\n\t\t}\n\t\tif (!definition || !scope) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst result = new types.Task(definition, scope, value.name!, value.source.label, execution, value.problemMatchers);\n\t\tif (value.isBackground !== undefined) {\n\t\t\tresult.isBackground = value.isBackground;\n\t\t}\n\t\tif (value.group !== undefined) {\n\t\t\tresult.group = types.TaskGroup.from(value.group._id);\n\t\t\tif (result.group && value.group.isDefault) {\n\t\t\t\tresult.group = new types.TaskGroup(result.group.id, result.group.label);\n\t\t\t\tif (value.group.isDefault === true) {\n\t\t\t\t\tresult.group.isDefault = value.group.isDefault;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (value.presentationOptions) {\n\t\t\tresult.presentationOptions = TaskPresentationOptionsDTO.to(value.presentationOptions)!;\n\t\t}\n\t\tif (value._id) {\n\t\t\tresult._id = value._id;\n\t\t}\n\t\tif (value.detail) {\n\t\t\tresult.detail = value.detail;\n\t\t}\n\t\treturn result;\n\t}\n}\n\nnamespace TaskFilterDTO {\n\texport function from(value: vscode.TaskFilter | undefined): tasks.ITaskFilterDTO | undefined {\n\t\treturn value;\n\t}\n\n\texport function to(value: tasks.ITaskFilterDTO): vscode.TaskFilter | undefined {\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn Object.assign(Object.create(null), value);\n\t}\n}\n\nclass TaskExecutionImpl implements vscode.TaskExecution {\n\n\treadonly #tasks: ExtHostTaskBase;\n\tprivate _terminal: vscode.Terminal | undefined;\n\n\tconstructor(tasks: ExtHostTaskBase, readonly _id: string, private readonly _task: vscode.Task) {\n\t\tthis.#tasks = tasks;\n\t}\n\n\tpublic get task(): vscode.Task {\n\t\treturn this._task;\n\t}\n\n\tpublic terminate(): void {\n\t\tthis.#tasks.terminateTask(this);\n\t}\n\n\tpublic fireDidStartProcess(value: tasks.ITaskProcessStartedDTO): void {\n\t}\n\n\tpublic fireDidEndProcess(value: tasks.ITaskProcessEndedDTO): void {\n\t}\n\n\tpublic get terminal(): vscode.Terminal | undefined {\n\t\treturn this._terminal;\n\t}\n\n\tpublic set terminal(term: vscode.Terminal | undefined) {\n\t\tthis._terminal = term;\n\t}\n}\n\nexport interface HandlerData {\n\ttype: string;\n\tprovider: vscode.TaskProvider;\n\textension: IExtensionDescription;\n}\n\nexport abstract class ExtHostTaskBase implements ExtHostTaskShape, IExtHostTask {\n\treadonly _serviceBrand: undefined;\n\n\tprotected readonly _proxy: MainThreadTaskShape;\n\tprotected readonly _workspaceProvider: IExtHostWorkspaceProvider;\n\tprotected readonly _editorService: IExtHostDocumentsAndEditors;\n\tprotected readonly _configurationService: IExtHostConfiguration;\n\tprotected readonly _terminalService: IExtHostTerminalService;\n\tprotected readonly _logService: ILogService;\n\tprotected readonly _deprecationService: IExtHostApiDeprecationService;\n\tprotected _handleCounter: number;\n\tprotected _handlers: Map<number, HandlerData>;\n\tprotected _taskExecutions: Map<string, TaskExecutionImpl>;\n\tprotected _taskExecutionPromises: Map<string, Promise<TaskExecutionImpl>>;\n\tprotected _providedCustomExecutions2: Map<string, types.CustomExecution>;\n\tprivate _notProvidedCustomExecutions: Set<string>; // Used for custom executions tasks that are created and run through executeTask.\n\tprotected _activeCustomExecutions2: Map<string, types.CustomExecution>;\n\tprivate _lastStartedTask: string | undefined;\n\tprotected readonly _onDidExecuteTask: Emitter<vscode.TaskStartEvent> = new Emitter<vscode.TaskStartEvent>();\n\tprotected readonly _onDidTerminateTask: Emitter<vscode.TaskEndEvent> = new Emitter<vscode.TaskEndEvent>();\n\n\tprotected readonly _onDidTaskProcessStarted: Emitter<vscode.TaskProcessStartEvent> = new Emitter<vscode.TaskProcessStartEvent>();\n\tprotected readonly _onDidTaskProcessEnded: Emitter<vscode.TaskProcessEndEvent> = new Emitter<vscode.TaskProcessEndEvent>();\n\tprotected readonly _onDidStartTaskProblemMatchers: Emitter<vscode.TaskProblemMatcherStartedEvent> = new Emitter<vscode.TaskProblemMatcherStartedEvent>();\n\tprotected readonly _onDidEndTaskProblemMatchers: Emitter<vscode.TaskProblemMatcherEndedEvent> = new Emitter<vscode.TaskProblemMatcherEndedEvent>();\n\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService initData: IExtHostInitDataService,\n\t\t@IExtHostWorkspace workspaceService: IExtHostWorkspace,\n\t\t@IExtHostDocumentsAndEditors editorService: IExtHostDocumentsAndEditors,\n\t\t@IExtHostConfiguration configurationService: IExtHostConfiguration,\n\t\t@IExtHostTerminalService extHostTerminalService: IExtHostTerminalService,\n\t\t@ILogService logService: ILogService,\n\t\t@IExtHostApiDeprecationService deprecationService: IExtHostApiDeprecationService\n\t) {\n\t\tthis._proxy = extHostRpc.getProxy(MainContext.MainThreadTask);\n\t\tthis._workspaceProvider = workspaceService;\n\t\tthis._editorService = editorService;\n\t\tthis._configurationService = configurationService;\n\t\tthis._terminalService = extHostTerminalService;\n\t\tthis._handleCounter = 0;\n\t\tthis._handlers = new Map<number, HandlerData>();\n\t\tthis._taskExecutions = new Map<string, TaskExecutionImpl>();\n\t\tthis._taskExecutionPromises = new Map<string, Promise<TaskExecutionImpl>>();\n\t\tthis._providedCustomExecutions2 = new Map<string, types.CustomExecution>();\n\t\tthis._notProvidedCustomExecutions = new Set<string>();\n\t\tthis._activeCustomExecutions2 = new Map<string, types.CustomExecution>();\n\t\tthis._logService = logService;\n\t\tthis._deprecationService = deprecationService;\n\t\tthis._proxy.$registerSupportedExecutions(true);\n\t}\n\n\tpublic registerTaskProvider(extension: IExtensionDescription, type: string, provider: vscode.TaskProvider): vscode.Disposable {\n\t\tif (!provider) {\n\t\t\treturn new types.Disposable(() => { });\n\t\t}\n\t\tconst handle = this.nextHandle();\n\t\tthis._handlers.set(handle, { type, provider, extension });\n\t\tthis._proxy.$registerTaskProvider(handle, type);\n\t\treturn new types.Disposable(() => {\n\t\t\tthis._handlers.delete(handle);\n\t\t\tthis._proxy.$unregisterTaskProvider(handle);\n\t\t});\n\t}\n\n\tpublic registerTaskSystem(scheme: string, info: tasks.ITaskSystemInfoDTO): void {\n\t\tthis._proxy.$registerTaskSystem(scheme, info);\n\t}\n\n\tpublic fetchTasks(filter?: vscode.TaskFilter): Promise<vscode.Task[]> {\n\t\treturn this._proxy.$fetchTasks(TaskFilterDTO.from(filter)).then(async (values) => {\n\t\t\tconst result: vscode.Task[] = [];\n\t\t\tfor (const value of values) {\n\t\t\t\tconst task = await TaskDTO.to(value, this._workspaceProvider, this._providedCustomExecutions2);\n\t\t\t\tif (task) {\n\t\t\t\t\tresult.push(task);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tpublic abstract executeTask(extension: IExtensionDescription, task: vscode.Task): Promise<vscode.TaskExecution>;\n\n\tpublic get taskExecutions(): vscode.TaskExecution[] {\n\t\tconst result: vscode.TaskExecution[] = [];\n\t\tthis._taskExecutions.forEach(value => result.push(value));\n\t\treturn result;\n\t}\n\n\tpublic terminateTask(execution: vscode.TaskExecution): Promise<void> {\n\t\tif (!(execution instanceof TaskExecutionImpl)) {\n\t\t\tthrow new Error('No valid task execution provided');\n\t\t}\n\t\treturn this._proxy.$terminateTask((execution as TaskExecutionImpl)._id);\n\t}\n\n\tpublic get onDidStartTask(): Event<vscode.TaskStartEvent> {\n\t\treturn this._onDidExecuteTask.event;\n\t}\n\n\tpublic async $onDidStartTask(execution: tasks.ITaskExecutionDTO, terminalId: number, resolvedDefinition: tasks.ITaskDefinitionDTO): Promise<void> {\n\t\tconst customExecution: types.CustomExecution | undefined = this._providedCustomExecutions2.get(execution.id);\n\t\tif (customExecution) {\n\t\t\t// Clone the custom execution to keep the original untouched. This is important for multiple runs of the same task.\n\t\t\tthis._activeCustomExecutions2.set(execution.id, customExecution);\n\t\t\tthis._terminalService.attachPtyToTerminal(terminalId, await customExecution.callback(resolvedDefinition));\n\t\t}\n\t\tthis._lastStartedTask = execution.id;\n\n\t\tconst taskExecution = await this.getTaskExecution(execution);\n\t\tconst terminal = this._terminalService.getTerminalById(terminalId)?.value;\n\t\tif (taskExecution) {\n\t\t\ttaskExecution.terminal = terminal;\n\t\t}\n\n\t\tthis._onDidExecuteTask.fire({\n\t\t\texecution: taskExecution\n\t\t});\n\t}\n\n\tpublic get onDidEndTask(): Event<vscode.TaskEndEvent> {\n\t\treturn this._onDidTerminateTask.event;\n\t}\n\n\tpublic async $OnDidEndTask(execution: tasks.ITaskExecutionDTO): Promise<void> {\n\t\tif (!this._taskExecutionPromises.has(execution.id)) {\n\t\t\t// Event already fired by the main thread\n\t\t\t// See https://github.com/microsoft/vscode/commit/aaf73920aeae171096d205efb2c58804a32b6846\n\t\t\treturn;\n\t\t}\n\t\tconst _execution = await this.getTaskExecution(execution);\n\t\tthis._taskExecutionPromises.delete(execution.id);\n\t\tthis._taskExecutions.delete(execution.id);\n\t\tthis.customExecutionComplete(execution);\n\t\tthis._onDidTerminateTask.fire({\n\t\t\texecution: _execution\n\t\t});\n\t}\n\n\tpublic get onDidStartTaskProcess(): Event<vscode.TaskProcessStartEvent> {\n\t\treturn this._onDidTaskProcessStarted.event;\n\t}\n\n\tpublic async $onDidStartTaskProcess(value: tasks.ITaskProcessStartedDTO): Promise<void> {\n\t\tconst execution = await this.getTaskExecution(value.id);\n\t\tthis._onDidTaskProcessStarted.fire({\n\t\t\texecution: execution,\n\t\t\tprocessId: value.processId\n\t\t});\n\t}\n\n\tpublic get onDidEndTaskProcess(): Event<vscode.TaskProcessEndEvent> {\n\t\treturn this._onDidTaskProcessEnded.event;\n\t}\n\n\tpublic async $onDidEndTaskProcess(value: tasks.ITaskProcessEndedDTO): Promise<void> {\n\t\tconst execution = await this.getTaskExecution(value.id);\n\t\tthis._onDidTaskProcessEnded.fire({\n\t\t\texecution: execution,\n\t\t\texitCode: value.exitCode\n\t\t});\n\t}\n\n\tpublic get onDidStartTaskProblemMatchers(): Event<vscode.TaskProblemMatcherStartedEvent> {\n\t\treturn this._onDidStartTaskProblemMatchers.event;\n\t}\n\n\tpublic async $onDidStartTaskProblemMatchers(value: ITaskProblemMatcherStartedDto): Promise<void> {\n\t\tlet execution;\n\t\ttry {\n\t\t\texecution = await this.getTaskExecution(value.execution.id);\n\t\t} catch (error) {\n\t\t\t// The task execution is not available anymore\n\t\t\treturn;\n\t\t}\n\n\t\tthis._onDidStartTaskProblemMatchers.fire({ execution });\n\t}\n\n\tpublic get onDidEndTaskProblemMatchers(): Event<vscode.TaskProblemMatcherEndedEvent> {\n\t\treturn this._onDidEndTaskProblemMatchers.event;\n\t}\n\n\tpublic async $onDidEndTaskProblemMatchers(value: ITaskProblemMatcherEndedDto): Promise<void> {\n\t\tlet execution;\n\t\ttry {\n\t\t\texecution = await this.getTaskExecution(value.execution.id);\n\t\t} catch (error) {\n\t\t\t// The task execution is not available anymore\n\t\t\treturn;\n\t\t}\n\n\t\tthis._onDidEndTaskProblemMatchers.fire({ execution, hasErrors: value.hasErrors });\n\t}\n\n\tprotected abstract provideTasksInternal(validTypes: { [key: string]: boolean }, taskIdPromises: Promise<void>[], handler: HandlerData, value: vscode.Task[] | null | undefined): { tasks: tasks.ITaskDTO[]; extension: IExtensionDescription };\n\n\tpublic $provideTasks(handle: number, validTypes: { [key: string]: boolean }): Promise<tasks.ITaskSetDTO> {\n\t\tconst handler = this._handlers.get(handle);\n\t\tif (!handler) {\n\t\t\treturn Promise.reject(new Error('no handler found'));\n\t\t}\n\n\t\t// Set up a list of task ID promises that we can wait on\n\t\t// before returning the provided tasks. The ensures that\n\t\t// our task IDs are calculated for any custom execution tasks.\n\t\t// Knowing this ID ahead of time is needed because when a task\n\t\t// start event is fired this is when the custom execution is called.\n\t\t// The task start event is also the first time we see the ID from the main\n\t\t// thread, which is too late for us because we need to save an map\n\t\t// from an ID to the custom execution function. (Kind of a cart before the horse problem).\n\t\tconst taskIdPromises: Promise<void>[] = [];\n\t\tconst fetchPromise = asPromise(() => handler.provider.provideTasks(CancellationToken.None)).then(value => {\n\t\t\treturn this.provideTasksInternal(validTypes, taskIdPromises, handler, value);\n\t\t});\n\n\t\treturn new Promise((resolve) => {\n\t\t\tfetchPromise.then((result) => {\n\t\t\t\tPromise.all(taskIdPromises).then(() => {\n\t\t\t\t\tresolve(result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tprotected abstract resolveTaskInternal(resolvedTaskDTO: tasks.ITaskDTO): Promise<tasks.ITaskDTO | undefined>;\n\n\tpublic async $resolveTask(handle: number, taskDTO: tasks.ITaskDTO): Promise<tasks.ITaskDTO | undefined> {\n\t\tconst handler = this._handlers.get(handle);\n\t\tif (!handler) {\n\t\t\treturn Promise.reject(new Error('no handler found'));\n\t\t}\n\n\t\tif (taskDTO.definition.type !== handler.type) {\n\t\t\tthrow new Error(`Unexpected: Task of type [${taskDTO.definition.type}] cannot be resolved by provider of type [${handler.type}].`);\n\t\t}\n\n\t\tconst task = await TaskDTO.to(taskDTO, this._workspaceProvider, this._providedCustomExecutions2);\n\t\tif (!task) {\n\t\t\tthrow new Error('Unexpected: Task cannot be resolved.');\n\t\t}\n\n\t\tconst resolvedTask = await handler.provider.resolveTask(task, CancellationToken.None);\n\t\tif (!resolvedTask) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.checkDeprecation(resolvedTask, handler);\n\n\t\tconst resolvedTaskDTO: tasks.ITaskDTO | undefined = TaskDTO.from(resolvedTask, handler.extension);\n\t\tif (!resolvedTaskDTO) {\n\t\t\tthrow new Error('Unexpected: Task cannot be resolved.');\n\t\t}\n\n\t\tif (resolvedTask.definition !== task.definition) {\n\t\t\tthrow new Error('Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed.');\n\t\t}\n\n\t\tif (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {\n\t\t\tawait this.addCustomExecution(resolvedTaskDTO, resolvedTask, true);\n\t\t}\n\n\t\treturn await this.resolveTaskInternal(resolvedTaskDTO);\n\t}\n\n\tpublic abstract $resolveVariables(uriComponents: UriComponents, toResolve: { process?: { name: string; cwd?: string; path?: string }; variables: string[] }): Promise<{ process?: string; variables: { [key: string]: string } }>;\n\n\tprivate nextHandle(): number {\n\t\treturn this._handleCounter++;\n\t}\n\n\tprotected async addCustomExecution(taskDTO: tasks.ITaskDTO, task: vscode.Task, isProvided: boolean): Promise<void> {\n\t\tconst taskId = await this._proxy.$createTaskId(taskDTO);\n\t\tif (!isProvided && !this._providedCustomExecutions2.has(taskId)) {\n\t\t\tthis._notProvidedCustomExecutions.add(taskId);\n\t\t\t// Also add to active executions when not coming from a provider to prevent timing issue.\n\t\t\tthis._activeCustomExecutions2.set(taskId, <types.CustomExecution>task.execution);\n\t\t}\n\t\tthis._providedCustomExecutions2.set(taskId, <types.CustomExecution>task.execution);\n\t}\n\n\tprotected async getTaskExecution(execution: tasks.ITaskExecutionDTO | string, task?: vscode.Task): Promise<TaskExecutionImpl> {\n\t\tif (typeof execution === 'string') {\n\t\t\tconst taskExecution = this._taskExecutionPromises.get(execution);\n\t\t\tif (!taskExecution) {\n\t\t\t\tthrow new ErrorNoTelemetry('Unexpected: The specified task is missing an execution');\n\t\t\t}\n\t\t\treturn taskExecution;\n\t\t}\n\n\t\tconst result: Promise<TaskExecutionImpl> | undefined = this._taskExecutionPromises.get(execution.id);\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tlet executionPromise: Promise<TaskExecutionImpl>;\n\t\tif (!task) {\n\t\t\texecutionPromise = TaskDTO.to(execution.task, this._workspaceProvider, this._providedCustomExecutions2).then(t => {\n\t\t\t\tif (!t) {\n\t\t\t\t\tthrow new ErrorNoTelemetry('Unexpected: Task does not exist.');\n\t\t\t\t}\n\t\t\t\treturn new TaskExecutionImpl(this, execution.id, t);\n\t\t\t});\n\t\t} else {\n\t\t\texecutionPromise = Promise.resolve(new TaskExecutionImpl(this, execution.id, task));\n\t\t}\n\t\tthis._taskExecutionPromises.set(execution.id, executionPromise);\n\t\treturn executionPromise.then(taskExecution => {\n\t\t\tthis._taskExecutions.set(execution.id, taskExecution);\n\t\t\treturn taskExecution;\n\t\t});\n\t}\n\n\tprotected checkDeprecation(task: vscode.Task, handler: HandlerData) {\n\t\tconst tTask = (task as types.Task);\n\t\tif (tTask._deprecated) {\n\t\t\tthis._deprecationService.report('Task.constructor', handler.extension, 'Use the Task constructor that takes a `scope` instead.');\n\t\t}\n\t}\n\n\tprivate customExecutionComplete(execution: tasks.ITaskExecutionDTO): void {\n\t\tconst extensionCallback2: vscode.CustomExecution | undefined = this._activeCustomExecutions2.get(execution.id);\n\t\tif (extensionCallback2) {\n\t\t\tthis._activeCustomExecutions2.delete(execution.id);\n\t\t}\n\n\t\t// Technically we don't really need to do this, however, if an extension\n\t\t// is executing a task through \"executeTask\" over and over again\n\t\t// with different properties in the task definition, then the map of executions\n\t\t// could grow indefinitely, something we don't want.\n\t\tif (this._notProvidedCustomExecutions.has(execution.id) && (this._lastStartedTask !== execution.id)) {\n\t\t\tthis._providedCustomExecutions2.delete(execution.id);\n\t\t\tthis._notProvidedCustomExecutions.delete(execution.id);\n\t\t}\n\t\tconst iterator = this._notProvidedCustomExecutions.values();\n\t\tlet iteratorResult = iterator.next();\n\t\twhile (!iteratorResult.done) {\n\t\t\tif (!this._activeCustomExecutions2.has(iteratorResult.value) && (this._lastStartedTask !== iteratorResult.value)) {\n\t\t\t\tthis._providedCustomExecutions2.delete(iteratorResult.value);\n\t\t\t\tthis._notProvidedCustomExecutions.delete(iteratorResult.value);\n\t\t\t}\n\t\t\titeratorResult = iterator.next();\n\t\t}\n\t}\n\n\tpublic abstract $jsonTasksSupported(): Promise<boolean>;\n\n\tpublic abstract $findExecutable(command: string, cwd?: string | undefined, paths?: string[] | undefined): Promise<string | undefined>;\n}\n\nexport class WorkerExtHostTask extends ExtHostTaskBase {\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService initData: IExtHostInitDataService,\n\t\t@IExtHostWorkspace workspaceService: IExtHostWorkspace,\n\t\t@IExtHostDocumentsAndEditors editorService: IExtHostDocumentsAndEditors,\n\t\t@IExtHostConfiguration configurationService: IExtHostConfiguration,\n\t\t@IExtHostTerminalService extHostTerminalService: IExtHostTerminalService,\n\t\t@ILogService logService: ILogService,\n\t\t@IExtHostApiDeprecationService deprecationService: IExtHostApiDeprecationService\n\t) {\n\t\tsuper(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService);\n\t\tthis.registerTaskSystem(Schemas.vscodeRemote, {\n\t\t\tscheme: Schemas.vscodeRemote,\n\t\t\tauthority: '',\n\t\t\tplatform: Platform.PlatformToString(Platform.Platform.Web)\n\t\t});\n\t}\n\n\tpublic async executeTask(extension: IExtensionDescription, task: vscode.Task): Promise<vscode.TaskExecution> {\n\t\tif (!task.execution) {\n\t\t\tthrow new Error('Tasks to execute must include an execution');\n\t\t}\n\n\t\tconst dto = TaskDTO.from(task, extension);\n\t\tif (dto === undefined) {\n\t\t\tthrow new Error('Task is not valid');\n\t\t}\n\n\t\t// If this task is a custom execution, then we need to save it away\n\t\t// in the provided custom execution map that is cleaned up after the\n\t\t// task is executed.\n\t\tif (CustomExecutionDTO.is(dto.execution)) {\n\t\t\tawait this.addCustomExecution(dto, task, false);\n\t\t} else {\n\t\t\tthrow new NotSupportedError();\n\t\t}\n\n\t\t// Always get the task execution first to prevent timing issues when retrieving it later\n\t\tconst execution = await this.getTaskExecution(await this._proxy.$getTaskExecution(dto), task);\n\t\tthis._proxy.$executeTask(dto).catch(error => { throw new Error(error); });\n\t\treturn execution;\n\t}\n\n\tprotected provideTasksInternal(validTypes: { [key: string]: boolean }, taskIdPromises: Promise<void>[], handler: HandlerData, value: vscode.Task[] | null | undefined): { tasks: tasks.ITaskDTO[]; extension: IExtensionDescription } {\n\t\tconst taskDTOs: tasks.ITaskDTO[] = [];\n\t\tif (value) {\n\t\t\tfor (const task of value) {\n\t\t\t\tthis.checkDeprecation(task, handler);\n\t\t\t\tif (!task.definition || !validTypes[task.definition.type]) {\n\t\t\t\t\tconst source = task.source ? task.source : 'No task source';\n\t\t\t\t\tthis._logService.warn(`The task [${source}, ${task.name}] uses an undefined task type. The task will be ignored in the future.`);\n\t\t\t\t}\n\n\t\t\t\tconst taskDTO: tasks.ITaskDTO | undefined = TaskDTO.from(task, handler.extension);\n\t\t\t\tif (taskDTO && CustomExecutionDTO.is(taskDTO.execution)) {\n\t\t\t\t\ttaskDTOs.push(taskDTO);\n\t\t\t\t\t// The ID is calculated on the main thread task side, so, let's call into it here.\n\t\t\t\t\t// We need the task id's pre-computed for custom task executions because when OnDidStartTask\n\t\t\t\t\t// is invoked, we have to be able to map it back to our data.\n\t\t\t\t\ttaskIdPromises.push(this.addCustomExecution(taskDTO, task, true));\n\t\t\t\t} else {\n\t\t\t\t\tthis._logService.warn('Only custom execution tasks supported.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttasks: taskDTOs,\n\t\t\textension: handler.extension\n\t\t};\n\t}\n\n\tprotected async resolveTaskInternal(resolvedTaskDTO: tasks.ITaskDTO): Promise<tasks.ITaskDTO | undefined> {\n\t\tif (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {\n\t\t\treturn resolvedTaskDTO;\n\t\t} else {\n\t\t\tthis._logService.warn('Only custom execution tasks supported.');\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic async $resolveVariables(uriComponents: UriComponents, toResolve: { process?: { name: string; cwd?: string; path?: string }; variables: string[] }): Promise<{ process?: string; variables: { [key: string]: string } }> {\n\t\tconst result = {\n\t\t\tprocess: <unknown>undefined as string,\n\t\t\tvariables: Object.create(null)\n\t\t};\n\t\treturn result;\n\t}\n\n\tpublic async $jsonTasksSupported(): Promise<boolean> {\n\t\treturn false;\n\t}\n\n\tpublic async $findExecutable(command: string, cwd?: string | undefined, paths?: string[] | undefined): Promise<string | undefined> {\n\t\treturn undefined;\n\t}\n}\n\nexport const IExtHostTask = createDecorator<IExtHostTask>('IExtHostTask');\n"]}