{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/workbench/api/common/extHostConsoleForwarder.ts","vs/workbench/api/common/extHostConsoleForwarder.ts"],"names":[],"mappings":"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","file":"extHostConsoleForwarder.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IStackArgument } from '../../../base/common/console.js';\nimport { safeStringify } from '../../../base/common/objects.js';\nimport { MainContext, MainThreadConsoleShape } from './extHost.protocol.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\n\nexport abstract class AbstractExtHostConsoleForwarder {\n\n\tprivate readonly _mainThreadConsole: MainThreadConsoleShape;\n\tprivate readonly _includeStack: boolean;\n\tprivate readonly _logNative: boolean;\n\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService initData: IExtHostInitDataService,\n\t) {\n\t\tthis._mainThreadConsole = extHostRpc.getProxy(MainContext.MainThreadConsole);\n\t\tthis._includeStack = initData.consoleForward.includeStack;\n\t\tthis._logNative = initData.consoleForward.logNative;\n\n\t\t// Pass console logging to the outside so that we have it in the main side if told so\n\t\tthis._wrapConsoleMethod('info', 'log');\n\t\tthis._wrapConsoleMethod('log', 'log');\n\t\tthis._wrapConsoleMethod('warn', 'warn');\n\t\tthis._wrapConsoleMethod('debug', 'debug');\n\t\tthis._wrapConsoleMethod('error', 'error');\n\t}\n\n\t/**\n\t * Wraps a console message so that it is transmitted to the renderer. If\n\t * native logging is turned on, the original console message will be written\n\t * as well. This is needed since the console methods are \"magic\" in V8 and\n\t * are the only methods that allow later introspection of logged variables.\n\t *\n\t * The wrapped property is not defined with `writable: false` to avoid\n\t * throwing errors, but rather a no-op setting. See https://github.com/microsoft/vscode-extension-telemetry/issues/88\n\t */\n\tprivate _wrapConsoleMethod(method: 'log' | 'info' | 'warn' | 'error' | 'debug', severity: 'log' | 'warn' | 'error' | 'debug') {\n\t\tconst that = this;\n\t\tconst original = console[method];\n\n\t\tObject.defineProperty(console, method, {\n\t\t\tset: () => { },\n\t\t\tget: () => function () {\n\t\t\t\tthat._handleConsoleCall(method, severity, original, arguments);\n\t\t\t},\n\t\t});\n\t}\n\n\tprivate _handleConsoleCall(method: 'log' | 'info' | 'warn' | 'error' | 'debug', severity: 'log' | 'warn' | 'error' | 'debug', original: (...args: any[]) => void, args: IArguments): void {\n\t\tthis._mainThreadConsole.$logExtensionHostMessage({\n\t\t\ttype: '__$console',\n\t\t\tseverity,\n\t\t\targuments: safeStringifyArgumentsToArray(args, this._includeStack)\n\t\t});\n\t\tif (this._logNative) {\n\t\t\tthis._nativeConsoleLogMessage(method, original, args);\n\t\t}\n\t}\n\n\tprotected abstract _nativeConsoleLogMessage(method: 'log' | 'info' | 'warn' | 'error' | 'debug', original: (...args: any[]) => void, args: IArguments): void;\n\n}\n\nconst MAX_LENGTH = 100000;\n\n/**\n * Prevent circular stringify and convert arguments to real array\n */\nfunction safeStringifyArgumentsToArray(args: IArguments, includeStack: boolean): string {\n\tconst argsArray = [];\n\n\t// Massage some arguments with special treatment\n\tif (args.length) {\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tlet arg = args[i];\n\n\t\t\t// Any argument of type 'undefined' needs to be specially treated because\n\t\t\t// JSON.stringify will simply ignore those. We replace them with the string\n\t\t\t// 'undefined' which is not 100% right, but good enough to be logged to console\n\t\t\tif (typeof arg === 'undefined') {\n\t\t\t\targ = 'undefined';\n\t\t\t}\n\n\t\t\t// Any argument that is an Error will be changed to be just the error stack/message\n\t\t\t// itself because currently cannot serialize the error over entirely.\n\t\t\telse if (arg instanceof Error) {\n\t\t\t\tconst errorObj = arg;\n\t\t\t\tif (errorObj.stack) {\n\t\t\t\t\targ = errorObj.stack;\n\t\t\t\t} else {\n\t\t\t\t\targ = errorObj.toString();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\targsArray.push(arg);\n\t\t}\n\t}\n\n\t// Add the stack trace as payload if we are told so. We remove the message and the 2 top frames\n\t// to start the stacktrace where the console message was being written\n\tif (includeStack) {\n\t\tconst stack = new Error().stack;\n\t\tif (stack) {\n\t\t\targsArray.push({ __$stack: stack.split('\\n').slice(3).join('\\n') } satisfies IStackArgument);\n\t\t}\n\t}\n\n\ttry {\n\t\tconst res = safeStringify(argsArray);\n\n\t\tif (res.length > MAX_LENGTH) {\n\t\t\treturn 'Output omitted for a large object that exceeds the limits';\n\t\t}\n\n\t\treturn res;\n\t} catch (error) {\n\t\treturn `Output omitted for an object that cannot be inspected ('${error.toString()}')`;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IStackArgument } from '../../../base/common/console.js';\nimport { safeStringify } from '../../../base/common/objects.js';\nimport { MainContext, MainThreadConsoleShape } from './extHost.protocol.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\n\nexport abstract class AbstractExtHostConsoleForwarder {\n\n\tprivate readonly _mainThreadConsole: MainThreadConsoleShape;\n\tprivate readonly _includeStack: boolean;\n\tprivate readonly _logNative: boolean;\n\n\tconstructor(\n\t\t@IExtHostRpcService extHostRpc: IExtHostRpcService,\n\t\t@IExtHostInitDataService initData: IExtHostInitDataService,\n\t) {\n\t\tthis._mainThreadConsole = extHostRpc.getProxy(MainContext.MainThreadConsole);\n\t\tthis._includeStack = initData.consoleForward.includeStack;\n\t\tthis._logNative = initData.consoleForward.logNative;\n\n\t\t// Pass console logging to the outside so that we have it in the main side if told so\n\t\tthis._wrapConsoleMethod('info', 'log');\n\t\tthis._wrapConsoleMethod('log', 'log');\n\t\tthis._wrapConsoleMethod('warn', 'warn');\n\t\tthis._wrapConsoleMethod('debug', 'debug');\n\t\tthis._wrapConsoleMethod('error', 'error');\n\t}\n\n\t/**\n\t * Wraps a console message so that it is transmitted to the renderer. If\n\t * native logging is turned on, the original console message will be written\n\t * as well. This is needed since the console methods are \"magic\" in V8 and\n\t * are the only methods that allow later introspection of logged variables.\n\t *\n\t * The wrapped property is not defined with `writable: false` to avoid\n\t * throwing errors, but rather a no-op setting. See https://github.com/microsoft/vscode-extension-telemetry/issues/88\n\t */\n\tprivate _wrapConsoleMethod(method: 'log' | 'info' | 'warn' | 'error' | 'debug', severity: 'log' | 'warn' | 'error' | 'debug') {\n\t\tconst that = this;\n\t\tconst original = console[method];\n\n\t\tObject.defineProperty(console, method, {\n\t\t\tset: () => { },\n\t\t\tget: () => function () {\n\t\t\t\tthat._handleConsoleCall(method, severity, original, arguments);\n\t\t\t},\n\t\t});\n\t}\n\n\tprivate _handleConsoleCall(method: 'log' | 'info' | 'warn' | 'error' | 'debug', severity: 'log' | 'warn' | 'error' | 'debug', original: (...args: any[]) => void, args: IArguments): void {\n\t\tthis._mainThreadConsole.$logExtensionHostMessage({\n\t\t\ttype: '__$console',\n\t\t\tseverity,\n\t\t\targuments: safeStringifyArgumentsToArray(args, this._includeStack)\n\t\t});\n\t\tif (this._logNative) {\n\t\t\tthis._nativeConsoleLogMessage(method, original, args);\n\t\t}\n\t}\n\n\tprotected abstract _nativeConsoleLogMessage(method: 'log' | 'info' | 'warn' | 'error' | 'debug', original: (...args: any[]) => void, args: IArguments): void;\n\n}\n\nconst MAX_LENGTH = 100000;\n\n/**\n * Prevent circular stringify and convert arguments to real array\n */\nfunction safeStringifyArgumentsToArray(args: IArguments, includeStack: boolean): string {\n\tconst argsArray = [];\n\n\t// Massage some arguments with special treatment\n\tif (args.length) {\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tlet arg = args[i];\n\n\t\t\t// Any argument of type 'undefined' needs to be specially treated because\n\t\t\t// JSON.stringify will simply ignore those. We replace them with the string\n\t\t\t// 'undefined' which is not 100% right, but good enough to be logged to console\n\t\t\tif (typeof arg === 'undefined') {\n\t\t\t\targ = 'undefined';\n\t\t\t}\n\n\t\t\t// Any argument that is an Error will be changed to be just the error stack/message\n\t\t\t// itself because currently cannot serialize the error over entirely.\n\t\t\telse if (arg instanceof Error) {\n\t\t\t\tconst errorObj = arg;\n\t\t\t\tif (errorObj.stack) {\n\t\t\t\t\targ = errorObj.stack;\n\t\t\t\t} else {\n\t\t\t\t\targ = errorObj.toString();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\targsArray.push(arg);\n\t\t}\n\t}\n\n\t// Add the stack trace as payload if we are told so. We remove the message and the 2 top frames\n\t// to start the stacktrace where the console message was being written\n\tif (includeStack) {\n\t\tconst stack = new Error().stack;\n\t\tif (stack) {\n\t\t\targsArray.push({ __$stack: stack.split('\\n').slice(3).join('\\n') } satisfies IStackArgument);\n\t\t}\n\t}\n\n\ttry {\n\t\tconst res = safeStringify(argsArray);\n\n\t\tif (res.length > MAX_LENGTH) {\n\t\t\treturn 'Output omitted for a large object that exceeds the limits';\n\t\t}\n\n\t\treturn res;\n\t} catch (error) {\n\t\treturn `Output omitted for an object that cannot be inspected ('${error.toString()}')`;\n\t}\n}\n"]}