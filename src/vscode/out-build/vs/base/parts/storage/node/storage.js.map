{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/parts/storage/node/storage.ts","vs/base/parts/storage/node/storage.ts"],"names":[],"mappings":"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","file":"storage.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { timeout } from '../../../common/async.js';\nimport { Event } from '../../../common/event.js';\nimport { mapToString, setToString } from '../../../common/map.js';\nimport { basename } from '../../../common/path.js';\nimport { Promises } from '../../../node/pfs.js';\nimport { IStorageDatabase, IStorageItemsChangeEvent, IUpdateRequest } from '../common/storage.js';\nimport type { Database, Statement } from '@vscode/sqlite3';\n\ninterface IDatabaseConnection {\n\treadonly db: Database;\n\treadonly isInMemory: boolean;\n\n\tisErroneous?: boolean;\n\tlastError?: string;\n}\n\nexport interface ISQLiteStorageDatabaseOptions {\n\treadonly logging?: ISQLiteStorageDatabaseLoggingOptions;\n}\n\nexport interface ISQLiteStorageDatabaseLoggingOptions {\n\tlogError?: (error: string | Error) => void;\n\tlogTrace?: (msg: string) => void;\n}\n\nexport class SQLiteStorageDatabase implements IStorageDatabase {\n\n\tstatic readonly IN_MEMORY_PATH = ':memory:';\n\n\tget onDidChangeItemsExternal(): Event<IStorageItemsChangeEvent> { return Event.None; } // since we are the only client, there can be no external changes\n\n\tprivate static readonly BUSY_OPEN_TIMEOUT = 2000; // timeout in ms to retry when opening DB fails with SQLITE_BUSY\n\tprivate static readonly MAX_HOST_PARAMETERS = 256; // maximum number of parameters within a statement\n\n\tprivate readonly name: string;\n\n\tprivate readonly logger: SQLiteStorageDatabaseLogger;\n\n\tprivate readonly whenConnected: Promise<IDatabaseConnection>;\n\n\tconstructor(\n\t\tprivate readonly path: string,\n\t\toptions: ISQLiteStorageDatabaseOptions = Object.create(null)\n\t) {\n\t\tthis.name = basename(this.path);\n\t\tthis.logger = new SQLiteStorageDatabaseLogger(options.logging);\n\t\tthis.whenConnected = this.connect(this.path);\n\t}\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\tconst connection = await this.whenConnected;\n\n\t\tconst items = new Map<string, string>();\n\n\t\tconst rows = await this.all(connection, 'SELECT * FROM ItemTable');\n\t\trows.forEach(row => items.set(row.key, row.value));\n\n\t\tif (this.logger.isTracing) {\n\t\t\tthis.logger.trace(`[storage ${this.name}] getItems(): ${items.size} rows`);\n\t\t}\n\n\t\treturn items;\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.doUpdateItems(connection, request);\n\t}\n\n\tprivate doUpdateItems(connection: IDatabaseConnection, request: IUpdateRequest): Promise<void> {\n\t\tif (this.logger.isTracing) {\n\t\t\tthis.logger.trace(`[storage ${this.name}] updateItems(): insert(${request.insert ? mapToString(request.insert) : '0'}), delete(${request.delete ? setToString(request.delete) : '0'})`);\n\t\t}\n\n\t\treturn this.transaction(connection, () => {\n\t\t\tconst toInsert = request.insert;\n\t\t\tconst toDelete = request.delete;\n\n\t\t\t// INSERT\n\t\t\tif (toInsert && toInsert.size > 0) {\n\t\t\t\tconst keysValuesChunks: (string[])[] = [];\n\t\t\t\tkeysValuesChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split key/values into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the INSERT with as many HOST parameters as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\ttoInsert.forEach((value, key) => {\n\t\t\t\t\tlet keyValueChunk = keysValuesChunks[currentChunkIndex];\n\n\t\t\t\t\tif (keyValueChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyValueChunk = [];\n\t\t\t\t\t\tkeysValuesChunks.push(keyValueChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyValueChunk.push(key, value);\n\t\t\t\t});\n\n\t\t\t\tkeysValuesChunks.forEach(keysValuesChunk => {\n\t\t\t\t\tthis.prepare(connection, `INSERT INTO ItemTable VALUES ${new Array(keysValuesChunk.length / 2).fill('(?,?)').join(',')} ON CONFLICT (key) DO UPDATE SET value = excluded.value WHERE value != excluded.value`, stmt => stmt.run(keysValuesChunk), () => {\n\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\tlet length = 0;\n\t\t\t\t\t\ttoInsert.forEach((value, key) => {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t\tlength += value.length;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn `Keys: ${keys.join(', ')} Length: ${length}`;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// DELETE\n\t\t\tif (toDelete?.size) {\n\t\t\t\tconst keysChunks: (string[])[] = [];\n\t\t\t\tkeysChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split keys into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the DELETE with as many HOST parameters\n\t\t\t\t// as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\ttoDelete.forEach(key => {\n\t\t\t\t\tlet keyChunk = keysChunks[currentChunkIndex];\n\n\t\t\t\t\tif (keyChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyChunk = [];\n\t\t\t\t\t\tkeysChunks.push(keyChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyChunk.push(key);\n\t\t\t\t});\n\n\t\t\t\tkeysChunks.forEach(keysChunk => {\n\t\t\t\t\tthis.prepare(connection, `DELETE FROM ItemTable WHERE key IN (${new Array(keysChunk.length).fill('?').join(',')})`, stmt => stmt.run(keysChunk), () => {\n\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\ttoDelete.forEach(key => {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn `Keys: ${keys.join(', ')}`;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tasync optimize(): Promise<void> {\n\t\tthis.logger.trace(`[storage ${this.name}] vacuum()`);\n\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.exec(connection, 'VACUUM');\n\t}\n\n\tasync close(recovery?: () => Map<string, string>): Promise<void> {\n\t\tthis.logger.trace(`[storage ${this.name}] close()`);\n\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.doClose(connection, recovery);\n\t}\n\n\tprivate doClose(connection: IDatabaseConnection, recovery?: () => Map<string, string>): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.close(closeError => {\n\t\t\t\tif (closeError) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] close(): ${closeError}`);\n\t\t\t\t}\n\n\t\t\t\t// Return early if this storage was created only in-memory\n\t\t\t\t// e.g. when running tests we do not need to backup.\n\t\t\t\tif (this.path === SQLiteStorageDatabase.IN_MEMORY_PATH) {\n\t\t\t\t\treturn resolve();\n\t\t\t\t}\n\n\t\t\t\t// If the DB closed successfully and we are not running in-memory\n\t\t\t\t// and the DB did not get errors during runtime, make a backup\n\t\t\t\t// of the DB so that we can use it as fallback in case the actual\n\t\t\t\t// DB becomes corrupt in the future.\n\t\t\t\tif (!connection.isErroneous && !connection.isInMemory) {\n\t\t\t\t\treturn this.backup().then(resolve, error => {\n\t\t\t\t\t\tthis.logger.error(`[storage ${this.name}] backup(): ${error}`);\n\n\t\t\t\t\t\treturn resolve(); // ignore failing backup\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Recovery: if we detected errors while using the DB or we are using\n\t\t\t\t// an inmemory DB (as a fallback to not being able to open the DB initially)\n\t\t\t\t// and we have a recovery function provided, we recreate the DB with this\n\t\t\t\t// data to recover all known data without loss if possible.\n\t\t\t\tif (typeof recovery === 'function') {\n\n\t\t\t\t\t// Delete the existing DB. If the path does not exist or fails to\n\t\t\t\t\t// be deleted, we do not try to recover anymore because we assume\n\t\t\t\t\t// that the path is no longer writeable for us.\n\t\t\t\t\treturn fs.promises.unlink(this.path).then(() => {\n\n\t\t\t\t\t\t// Re-open the DB fresh\n\t\t\t\t\t\treturn this.doConnect(this.path).then(recoveryConnection => {\n\t\t\t\t\t\t\tconst closeRecoveryConnection = () => {\n\t\t\t\t\t\t\t\treturn this.doClose(recoveryConnection, undefined /* do not attempt to recover again */);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Store items\n\t\t\t\t\t\t\treturn this.doUpdateItems(recoveryConnection, { insert: recovery() }).then(() => closeRecoveryConnection(), error => {\n\n\t\t\t\t\t\t\t\t// In case of an error updating items, still ensure to close the connection\n\t\t\t\t\t\t\t\t// to prevent SQLITE_BUSY errors when the connection is reestablished\n\t\t\t\t\t\t\t\tcloseRecoveryConnection();\n\n\t\t\t\t\t\t\t\treturn Promise.reject(error);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}).then(resolve, reject);\n\t\t\t\t}\n\n\t\t\t\t// Finally without recovery we just reject\n\t\t\t\treturn reject(closeError || new Error('Database has errors or is in-memory without recovery option'));\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate backup(): Promise<void> {\n\t\tconst backupPath = this.toBackupPath(this.path);\n\n\t\treturn Promises.copy(this.path, backupPath, { preserveSymlinks: false });\n\t}\n\n\tprivate toBackupPath(path: string): string {\n\t\treturn `${path}.backup`;\n\t}\n\n\tasync checkIntegrity(full: boolean): Promise<string> {\n\t\tthis.logger.trace(`[storage ${this.name}] checkIntegrity(full: ${full})`);\n\n\t\tconst connection = await this.whenConnected;\n\t\tconst row = await this.get(connection, full ? 'PRAGMA integrity_check' : 'PRAGMA quick_check');\n\n\t\tconst integrity = full ? (row as { integrity_check: string }).integrity_check : (row as { quick_check: string }).quick_check;\n\n\t\tif (connection.isErroneous) {\n\t\t\treturn `${integrity} (last error: ${connection.lastError})`;\n\t\t}\n\n\t\tif (connection.isInMemory) {\n\t\t\treturn `${integrity} (in-memory!)`;\n\t\t}\n\n\t\treturn integrity;\n\t}\n\n\tprivate async connect(path: string, retryOnBusy = true): Promise<IDatabaseConnection> {\n\t\tthis.logger.trace(`[storage ${this.name}] open(${path}, retryOnBusy: ${retryOnBusy})`);\n\n\t\ttry {\n\t\t\treturn await this.doConnect(path);\n\t\t} catch (error) {\n\t\t\tthis.logger.error(`[storage ${this.name}] open(): Unable to open DB due to ${error}`);\n\n\t\t\t// SQLITE_BUSY should only arise if another process is locking the same DB we want\n\t\t\t// to open at that time. This typically never happens because a DB connection is\n\t\t\t// limited per window. However, in the event of a window reload, it may be possible\n\t\t\t// that the previous connection was not properly closed while the new connection is\n\t\t\t// already established.\n\t\t\t//\n\t\t\t// In this case we simply wait for some time and retry once to establish the connection.\n\t\t\t//\n\t\t\tif (error.code === 'SQLITE_BUSY' && retryOnBusy) {\n\t\t\t\tawait timeout(SQLiteStorageDatabase.BUSY_OPEN_TIMEOUT);\n\n\t\t\t\treturn this.connect(path, false /* not another retry */);\n\t\t\t}\n\n\t\t\t// Otherwise, best we can do is to recover from a backup if that exists, as such we\n\t\t\t// move the DB to a different filename and try to load from backup. If that fails,\n\t\t\t// a new empty DB is being created automatically.\n\t\t\t//\n\t\t\t// The final fallback is to use an in-memory DB which should only happen if the target\n\t\t\t// folder is really not writeable for us.\n\t\t\t//\n\t\t\ttry {\n\t\t\t\tawait fs.promises.unlink(path);\n\t\t\t\ttry {\n\t\t\t\t\tawait Promises.rename(this.toBackupPath(path), path, false /* no retry */);\n\t\t\t\t} catch {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\n\t\t\t\treturn await this.doConnect(path);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logger.error(`[storage ${this.name}] open(): Unable to use backup due to ${error}`);\n\n\t\t\t\t// In case of any error to open the DB, use an in-memory\n\t\t\t\t// DB so that we always have a valid DB to talk to.\n\t\t\t\treturn this.doConnect(SQLiteStorageDatabase.IN_MEMORY_PATH);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleSQLiteError(connection: IDatabaseConnection, msg: string): void {\n\t\tconnection.isErroneous = true;\n\t\tconnection.lastError = msg;\n\n\t\tthis.logger.error(msg);\n\t}\n\n\tprivate doConnect(path: string): Promise<IDatabaseConnection> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\timport('@vscode/sqlite3').then(sqlite3 => {\n\t\t\t\tconst ctor = (this.logger.isTracing ? sqlite3.default.verbose().Database : sqlite3.default.Database);\n\t\t\t\tconst connection: IDatabaseConnection = {\n\t\t\t\t\tdb: new ctor(path, (error: (Error & { code?: string }) | null) => {\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treturn (connection.db && error.code !== 'SQLITE_CANTOPEN' /* https://github.com/TryGhost/node-sqlite3/issues/1617 */) ? connection.db.close(() => reject(error)) : reject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The following exec() statement serves two purposes:\n\t\t\t\t\t\t// - create the DB if it does not exist yet\n\t\t\t\t\t\t// - validate that the DB is not corrupt (the open() call does not throw otherwise)\n\t\t\t\t\t\treturn this.exec(connection, [\n\t\t\t\t\t\t\t'PRAGMA user_version = 1;',\n\t\t\t\t\t\t\t'CREATE TABLE IF NOT EXISTS ItemTable (key TEXT UNIQUE ON CONFLICT REPLACE, value BLOB)'\n\t\t\t\t\t\t].join('')).then(() => {\n\t\t\t\t\t\t\treturn resolve(connection);\n\t\t\t\t\t\t}, error => {\n\t\t\t\t\t\t\treturn connection.db.close(() => reject(error));\n\t\t\t\t\t\t});\n\t\t\t\t\t}),\n\t\t\t\t\tisInMemory: path === SQLiteStorageDatabase.IN_MEMORY_PATH\n\t\t\t\t};\n\n\t\t\t\t// Errors\n\t\t\t\tconnection.db.on('error', error => this.handleSQLiteError(connection, `[storage ${this.name}] Error (event): ${error}`));\n\n\t\t\t\t// Tracing\n\t\t\t\tif (this.logger.isTracing) {\n\t\t\t\t\tconnection.db.on('trace', sql => this.logger.trace(`[storage ${this.name}] Trace (event): ${sql}`));\n\t\t\t\t}\n\t\t\t}, reject);\n\t\t});\n\t}\n\n\tprivate exec(connection: IDatabaseConnection, sql: string): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.exec(sql, error => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] exec(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate get(connection: IDatabaseConnection, sql: string): Promise<object> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.get(sql, (error, row) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] get(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(row);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate all(connection: IDatabaseConnection, sql: string): Promise<{ key: string; value: string }[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.all(sql, (error, rows) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] all(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(rows);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate transaction(connection: IDatabaseConnection, transactions: () => void): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.serialize(() => {\n\t\t\t\tconnection.db.run('BEGIN TRANSACTION');\n\n\t\t\t\ttransactions();\n\n\t\t\t\tconnection.db.run('END TRANSACTION', error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] transaction(): ${error}`);\n\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate prepare(connection: IDatabaseConnection, sql: string, runCallback: (stmt: Statement) => void, errorDetails: () => string): void {\n\t\tconst stmt = connection.db.prepare(sql);\n\n\t\tconst statementErrorListener = (error: Error) => {\n\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] prepare(): ${error} (${sql}). Details: ${errorDetails()}`);\n\t\t};\n\n\t\tstmt.on('error', statementErrorListener);\n\n\t\trunCallback(stmt);\n\n\t\tstmt.finalize(error => {\n\t\t\tif (error) {\n\t\t\t\tstatementErrorListener(error);\n\t\t\t}\n\n\t\t\tstmt.removeListener('error', statementErrorListener);\n\t\t});\n\t}\n}\n\nclass SQLiteStorageDatabaseLogger {\n\n\t// to reduce lots of output, require an environment variable to enable tracing\n\t// this helps when running with --verbose normally where the storage tracing\n\t// might hide useful output to look at\n\tprivate static readonly VSCODE_TRACE_STORAGE = 'VSCODE_TRACE_STORAGE';\n\n\tprivate readonly logTrace: ((msg: string) => void) | undefined;\n\tprivate readonly logError: ((error: string | Error) => void) | undefined;\n\n\tconstructor(options?: ISQLiteStorageDatabaseLoggingOptions) {\n\t\tif (options && typeof options.logTrace === 'function' && process.env[SQLiteStorageDatabaseLogger.VSCODE_TRACE_STORAGE]) {\n\t\t\tthis.logTrace = options.logTrace;\n\t\t}\n\n\t\tif (options && typeof options.logError === 'function') {\n\t\t\tthis.logError = options.logError;\n\t\t}\n\t}\n\n\tget isTracing(): boolean {\n\t\treturn !!this.logTrace;\n\t}\n\n\ttrace(msg: string): void {\n\t\tthis.logTrace?.(msg);\n\t}\n\n\terror(error: string | Error): void {\n\t\tthis.logError?.(error);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { timeout } from '../../../common/async.js';\nimport { Event } from '../../../common/event.js';\nimport { mapToString, setToString } from '../../../common/map.js';\nimport { basename } from '../../../common/path.js';\nimport { Promises } from '../../../node/pfs.js';\nimport { IStorageDatabase, IStorageItemsChangeEvent, IUpdateRequest } from '../common/storage.js';\nimport type { Database, Statement } from '@vscode/sqlite3';\n\ninterface IDatabaseConnection {\n\treadonly db: Database;\n\treadonly isInMemory: boolean;\n\n\tisErroneous?: boolean;\n\tlastError?: string;\n}\n\nexport interface ISQLiteStorageDatabaseOptions {\n\treadonly logging?: ISQLiteStorageDatabaseLoggingOptions;\n}\n\nexport interface ISQLiteStorageDatabaseLoggingOptions {\n\tlogError?: (error: string | Error) => void;\n\tlogTrace?: (msg: string) => void;\n}\n\nexport class SQLiteStorageDatabase implements IStorageDatabase {\n\n\tstatic readonly IN_MEMORY_PATH = ':memory:';\n\n\tget onDidChangeItemsExternal(): Event<IStorageItemsChangeEvent> { return Event.None; } // since we are the only client, there can be no external changes\n\n\tprivate static readonly BUSY_OPEN_TIMEOUT = 2000; // timeout in ms to retry when opening DB fails with SQLITE_BUSY\n\tprivate static readonly MAX_HOST_PARAMETERS = 256; // maximum number of parameters within a statement\n\n\tprivate readonly name: string;\n\n\tprivate readonly logger: SQLiteStorageDatabaseLogger;\n\n\tprivate readonly whenConnected: Promise<IDatabaseConnection>;\n\n\tconstructor(\n\t\tprivate readonly path: string,\n\t\toptions: ISQLiteStorageDatabaseOptions = Object.create(null)\n\t) {\n\t\tthis.name = basename(this.path);\n\t\tthis.logger = new SQLiteStorageDatabaseLogger(options.logging);\n\t\tthis.whenConnected = this.connect(this.path);\n\t}\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\tconst connection = await this.whenConnected;\n\n\t\tconst items = new Map<string, string>();\n\n\t\tconst rows = await this.all(connection, 'SELECT * FROM ItemTable');\n\t\trows.forEach(row => items.set(row.key, row.value));\n\n\t\tif (this.logger.isTracing) {\n\t\t\tthis.logger.trace(`[storage ${this.name}] getItems(): ${items.size} rows`);\n\t\t}\n\n\t\treturn items;\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.doUpdateItems(connection, request);\n\t}\n\n\tprivate doUpdateItems(connection: IDatabaseConnection, request: IUpdateRequest): Promise<void> {\n\t\tif (this.logger.isTracing) {\n\t\t\tthis.logger.trace(`[storage ${this.name}] updateItems(): insert(${request.insert ? mapToString(request.insert) : '0'}), delete(${request.delete ? setToString(request.delete) : '0'})`);\n\t\t}\n\n\t\treturn this.transaction(connection, () => {\n\t\t\tconst toInsert = request.insert;\n\t\t\tconst toDelete = request.delete;\n\n\t\t\t// INSERT\n\t\t\tif (toInsert && toInsert.size > 0) {\n\t\t\t\tconst keysValuesChunks: (string[])[] = [];\n\t\t\t\tkeysValuesChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split key/values into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the INSERT with as many HOST parameters as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\ttoInsert.forEach((value, key) => {\n\t\t\t\t\tlet keyValueChunk = keysValuesChunks[currentChunkIndex];\n\n\t\t\t\t\tif (keyValueChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyValueChunk = [];\n\t\t\t\t\t\tkeysValuesChunks.push(keyValueChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyValueChunk.push(key, value);\n\t\t\t\t});\n\n\t\t\t\tkeysValuesChunks.forEach(keysValuesChunk => {\n\t\t\t\t\tthis.prepare(connection, `INSERT INTO ItemTable VALUES ${new Array(keysValuesChunk.length / 2).fill('(?,?)').join(',')} ON CONFLICT (key) DO UPDATE SET value = excluded.value WHERE value != excluded.value`, stmt => stmt.run(keysValuesChunk), () => {\n\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\tlet length = 0;\n\t\t\t\t\t\ttoInsert.forEach((value, key) => {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t\tlength += value.length;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn `Keys: ${keys.join(', ')} Length: ${length}`;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// DELETE\n\t\t\tif (toDelete?.size) {\n\t\t\t\tconst keysChunks: (string[])[] = [];\n\t\t\t\tkeysChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split keys into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the DELETE with as many HOST parameters\n\t\t\t\t// as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\ttoDelete.forEach(key => {\n\t\t\t\t\tlet keyChunk = keysChunks[currentChunkIndex];\n\n\t\t\t\t\tif (keyChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyChunk = [];\n\t\t\t\t\t\tkeysChunks.push(keyChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyChunk.push(key);\n\t\t\t\t});\n\n\t\t\t\tkeysChunks.forEach(keysChunk => {\n\t\t\t\t\tthis.prepare(connection, `DELETE FROM ItemTable WHERE key IN (${new Array(keysChunk.length).fill('?').join(',')})`, stmt => stmt.run(keysChunk), () => {\n\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\ttoDelete.forEach(key => {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn `Keys: ${keys.join(', ')}`;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tasync optimize(): Promise<void> {\n\t\tthis.logger.trace(`[storage ${this.name}] vacuum()`);\n\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.exec(connection, 'VACUUM');\n\t}\n\n\tasync close(recovery?: () => Map<string, string>): Promise<void> {\n\t\tthis.logger.trace(`[storage ${this.name}] close()`);\n\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.doClose(connection, recovery);\n\t}\n\n\tprivate doClose(connection: IDatabaseConnection, recovery?: () => Map<string, string>): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.close(closeError => {\n\t\t\t\tif (closeError) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] close(): ${closeError}`);\n\t\t\t\t}\n\n\t\t\t\t// Return early if this storage was created only in-memory\n\t\t\t\t// e.g. when running tests we do not need to backup.\n\t\t\t\tif (this.path === SQLiteStorageDatabase.IN_MEMORY_PATH) {\n\t\t\t\t\treturn resolve();\n\t\t\t\t}\n\n\t\t\t\t// If the DB closed successfully and we are not running in-memory\n\t\t\t\t// and the DB did not get errors during runtime, make a backup\n\t\t\t\t// of the DB so that we can use it as fallback in case the actual\n\t\t\t\t// DB becomes corrupt in the future.\n\t\t\t\tif (!connection.isErroneous && !connection.isInMemory) {\n\t\t\t\t\treturn this.backup().then(resolve, error => {\n\t\t\t\t\t\tthis.logger.error(`[storage ${this.name}] backup(): ${error}`);\n\n\t\t\t\t\t\treturn resolve(); // ignore failing backup\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Recovery: if we detected errors while using the DB or we are using\n\t\t\t\t// an inmemory DB (as a fallback to not being able to open the DB initially)\n\t\t\t\t// and we have a recovery function provided, we recreate the DB with this\n\t\t\t\t// data to recover all known data without loss if possible.\n\t\t\t\tif (typeof recovery === 'function') {\n\n\t\t\t\t\t// Delete the existing DB. If the path does not exist or fails to\n\t\t\t\t\t// be deleted, we do not try to recover anymore because we assume\n\t\t\t\t\t// that the path is no longer writeable for us.\n\t\t\t\t\treturn fs.promises.unlink(this.path).then(() => {\n\n\t\t\t\t\t\t// Re-open the DB fresh\n\t\t\t\t\t\treturn this.doConnect(this.path).then(recoveryConnection => {\n\t\t\t\t\t\t\tconst closeRecoveryConnection = () => {\n\t\t\t\t\t\t\t\treturn this.doClose(recoveryConnection, undefined /* do not attempt to recover again */);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Store items\n\t\t\t\t\t\t\treturn this.doUpdateItems(recoveryConnection, { insert: recovery() }).then(() => closeRecoveryConnection(), error => {\n\n\t\t\t\t\t\t\t\t// In case of an error updating items, still ensure to close the connection\n\t\t\t\t\t\t\t\t// to prevent SQLITE_BUSY errors when the connection is reestablished\n\t\t\t\t\t\t\t\tcloseRecoveryConnection();\n\n\t\t\t\t\t\t\t\treturn Promise.reject(error);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}).then(resolve, reject);\n\t\t\t\t}\n\n\t\t\t\t// Finally without recovery we just reject\n\t\t\t\treturn reject(closeError || new Error('Database has errors or is in-memory without recovery option'));\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate backup(): Promise<void> {\n\t\tconst backupPath = this.toBackupPath(this.path);\n\n\t\treturn Promises.copy(this.path, backupPath, { preserveSymlinks: false });\n\t}\n\n\tprivate toBackupPath(path: string): string {\n\t\treturn `${path}.backup`;\n\t}\n\n\tasync checkIntegrity(full: boolean): Promise<string> {\n\t\tthis.logger.trace(`[storage ${this.name}] checkIntegrity(full: ${full})`);\n\n\t\tconst connection = await this.whenConnected;\n\t\tconst row = await this.get(connection, full ? 'PRAGMA integrity_check' : 'PRAGMA quick_check');\n\n\t\tconst integrity = full ? (row as { integrity_check: string }).integrity_check : (row as { quick_check: string }).quick_check;\n\n\t\tif (connection.isErroneous) {\n\t\t\treturn `${integrity} (last error: ${connection.lastError})`;\n\t\t}\n\n\t\tif (connection.isInMemory) {\n\t\t\treturn `${integrity} (in-memory!)`;\n\t\t}\n\n\t\treturn integrity;\n\t}\n\n\tprivate async connect(path: string, retryOnBusy = true): Promise<IDatabaseConnection> {\n\t\tthis.logger.trace(`[storage ${this.name}] open(${path}, retryOnBusy: ${retryOnBusy})`);\n\n\t\ttry {\n\t\t\treturn await this.doConnect(path);\n\t\t} catch (error) {\n\t\t\tthis.logger.error(`[storage ${this.name}] open(): Unable to open DB due to ${error}`);\n\n\t\t\t// SQLITE_BUSY should only arise if another process is locking the same DB we want\n\t\t\t// to open at that time. This typically never happens because a DB connection is\n\t\t\t// limited per window. However, in the event of a window reload, it may be possible\n\t\t\t// that the previous connection was not properly closed while the new connection is\n\t\t\t// already established.\n\t\t\t//\n\t\t\t// In this case we simply wait for some time and retry once to establish the connection.\n\t\t\t//\n\t\t\tif (error.code === 'SQLITE_BUSY' && retryOnBusy) {\n\t\t\t\tawait timeout(SQLiteStorageDatabase.BUSY_OPEN_TIMEOUT);\n\n\t\t\t\treturn this.connect(path, false /* not another retry */);\n\t\t\t}\n\n\t\t\t// Otherwise, best we can do is to recover from a backup if that exists, as such we\n\t\t\t// move the DB to a different filename and try to load from backup. If that fails,\n\t\t\t// a new empty DB is being created automatically.\n\t\t\t//\n\t\t\t// The final fallback is to use an in-memory DB which should only happen if the target\n\t\t\t// folder is really not writeable for us.\n\t\t\t//\n\t\t\ttry {\n\t\t\t\tawait fs.promises.unlink(path);\n\t\t\t\ttry {\n\t\t\t\t\tawait Promises.rename(this.toBackupPath(path), path, false /* no retry */);\n\t\t\t\t} catch {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\n\t\t\t\treturn await this.doConnect(path);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logger.error(`[storage ${this.name}] open(): Unable to use backup due to ${error}`);\n\n\t\t\t\t// In case of any error to open the DB, use an in-memory\n\t\t\t\t// DB so that we always have a valid DB to talk to.\n\t\t\t\treturn this.doConnect(SQLiteStorageDatabase.IN_MEMORY_PATH);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleSQLiteError(connection: IDatabaseConnection, msg: string): void {\n\t\tconnection.isErroneous = true;\n\t\tconnection.lastError = msg;\n\n\t\tthis.logger.error(msg);\n\t}\n\n\tprivate doConnect(path: string): Promise<IDatabaseConnection> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\timport('@vscode/sqlite3').then(sqlite3 => {\n\t\t\t\tconst ctor = (this.logger.isTracing ? sqlite3.default.verbose().Database : sqlite3.default.Database);\n\t\t\t\tconst connection: IDatabaseConnection = {\n\t\t\t\t\tdb: new ctor(path, (error: (Error & { code?: string }) | null) => {\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treturn (connection.db && error.code !== 'SQLITE_CANTOPEN' /* https://github.com/TryGhost/node-sqlite3/issues/1617 */) ? connection.db.close(() => reject(error)) : reject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The following exec() statement serves two purposes:\n\t\t\t\t\t\t// - create the DB if it does not exist yet\n\t\t\t\t\t\t// - validate that the DB is not corrupt (the open() call does not throw otherwise)\n\t\t\t\t\t\treturn this.exec(connection, [\n\t\t\t\t\t\t\t'PRAGMA user_version = 1;',\n\t\t\t\t\t\t\t'CREATE TABLE IF NOT EXISTS ItemTable (key TEXT UNIQUE ON CONFLICT REPLACE, value BLOB)'\n\t\t\t\t\t\t].join('')).then(() => {\n\t\t\t\t\t\t\treturn resolve(connection);\n\t\t\t\t\t\t}, error => {\n\t\t\t\t\t\t\treturn connection.db.close(() => reject(error));\n\t\t\t\t\t\t});\n\t\t\t\t\t}),\n\t\t\t\t\tisInMemory: path === SQLiteStorageDatabase.IN_MEMORY_PATH\n\t\t\t\t};\n\n\t\t\t\t// Errors\n\t\t\t\tconnection.db.on('error', error => this.handleSQLiteError(connection, `[storage ${this.name}] Error (event): ${error}`));\n\n\t\t\t\t// Tracing\n\t\t\t\tif (this.logger.isTracing) {\n\t\t\t\t\tconnection.db.on('trace', sql => this.logger.trace(`[storage ${this.name}] Trace (event): ${sql}`));\n\t\t\t\t}\n\t\t\t}, reject);\n\t\t});\n\t}\n\n\tprivate exec(connection: IDatabaseConnection, sql: string): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.exec(sql, error => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] exec(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate get(connection: IDatabaseConnection, sql: string): Promise<object> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.get(sql, (error, row) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] get(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(row);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate all(connection: IDatabaseConnection, sql: string): Promise<{ key: string; value: string }[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.all(sql, (error, rows) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] all(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(rows);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate transaction(connection: IDatabaseConnection, transactions: () => void): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.serialize(() => {\n\t\t\t\tconnection.db.run('BEGIN TRANSACTION');\n\n\t\t\t\ttransactions();\n\n\t\t\t\tconnection.db.run('END TRANSACTION', error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] transaction(): ${error}`);\n\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate prepare(connection: IDatabaseConnection, sql: string, runCallback: (stmt: Statement) => void, errorDetails: () => string): void {\n\t\tconst stmt = connection.db.prepare(sql);\n\n\t\tconst statementErrorListener = (error: Error) => {\n\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] prepare(): ${error} (${sql}). Details: ${errorDetails()}`);\n\t\t};\n\n\t\tstmt.on('error', statementErrorListener);\n\n\t\trunCallback(stmt);\n\n\t\tstmt.finalize(error => {\n\t\t\tif (error) {\n\t\t\t\tstatementErrorListener(error);\n\t\t\t}\n\n\t\t\tstmt.removeListener('error', statementErrorListener);\n\t\t});\n\t}\n}\n\nclass SQLiteStorageDatabaseLogger {\n\n\t// to reduce lots of output, require an environment variable to enable tracing\n\t// this helps when running with --verbose normally where the storage tracing\n\t// might hide useful output to look at\n\tprivate static readonly VSCODE_TRACE_STORAGE = 'VSCODE_TRACE_STORAGE';\n\n\tprivate readonly logTrace: ((msg: string) => void) | undefined;\n\tprivate readonly logError: ((error: string | Error) => void) | undefined;\n\n\tconstructor(options?: ISQLiteStorageDatabaseLoggingOptions) {\n\t\tif (options && typeof options.logTrace === 'function' && process.env[SQLiteStorageDatabaseLogger.VSCODE_TRACE_STORAGE]) {\n\t\t\tthis.logTrace = options.logTrace;\n\t\t}\n\n\t\tif (options && typeof options.logError === 'function') {\n\t\t\tthis.logError = options.logError;\n\t\t}\n\t}\n\n\tget isTracing(): boolean {\n\t\treturn !!this.logTrace;\n\t}\n\n\ttrace(msg: string): void {\n\t\tthis.logTrace?.(msg);\n\t}\n\n\terror(error: string | Error): void {\n\t\tthis.logError?.(error);\n\t}\n}\n"]}