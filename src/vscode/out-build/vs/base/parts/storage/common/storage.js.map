{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/parts/storage/common/storage.ts","vs/base/parts/storage/common/storage.ts"],"names":[],"mappings":"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","file":"storage.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ThrottledDelayer } from '../../../common/async.js';\nimport { Event, PauseableEmitter } from '../../../common/event.js';\nimport { Disposable, IDisposable } from '../../../common/lifecycle.js';\nimport { parse, stringify } from '../../../common/marshalling.js';\nimport { isObject, isUndefinedOrNull } from '../../../common/types.js';\n\nexport enum StorageHint {\n\n\t// A hint to the storage that the storage\n\t// does not exist on disk yet. This allows\n\t// the storage library to improve startup\n\t// time by not checking the storage for data.\n\tSTORAGE_DOES_NOT_EXIST,\n\n\t// A hint to the storage that the storage\n\t// is backed by an in-memory storage.\n\tSTORAGE_IN_MEMORY\n}\n\nexport interface IStorageOptions {\n\treadonly hint?: StorageHint;\n}\n\nexport interface IUpdateRequest {\n\treadonly insert?: Map<string, string>;\n\treadonly delete?: Set<string>;\n}\n\nexport interface IStorageItemsChangeEvent {\n\treadonly changed?: Map<string, string>;\n\treadonly deleted?: Set<string>;\n}\n\nexport function isStorageItemsChangeEvent(thing: unknown): thing is IStorageItemsChangeEvent {\n\tconst candidate = thing as IStorageItemsChangeEvent | undefined;\n\n\treturn candidate?.changed instanceof Map || candidate?.deleted instanceof Set;\n}\n\nexport interface IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal: Event<IStorageItemsChangeEvent>;\n\n\tgetItems(): Promise<Map<string, string>>;\n\tupdateItems(request: IUpdateRequest): Promise<void>;\n\n\toptimize(): Promise<void>;\n\n\tclose(recovery?: () => Map<string, string>): Promise<void>;\n}\n\nexport interface IStorageChangeEvent {\n\n\t/**\n\t * The `key` of the storage entry that was changed\n\t * or was removed.\n\t */\n\treadonly key: string;\n\n\t/**\n\t * A hint how the storage change event was triggered. If\n\t * `true`, the storage change was triggered by an external\n\t * source, such as:\n\t * - another process (for example another window)\n\t * - operations such as settings sync or profiles change\n\t */\n\treadonly external?: boolean;\n}\n\nexport type StorageValue = string | boolean | number | undefined | null | object;\n\nexport interface IStorage extends IDisposable {\n\n\treadonly onDidChangeStorage: Event<IStorageChangeEvent>;\n\n\treadonly items: Map<string, string>;\n\treadonly size: number;\n\n\tinit(): Promise<void>;\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\n\tgetObject<T extends object>(key: string, fallbackValue: T): T;\n\tgetObject<T extends object>(key: string, fallbackValue?: T): T | undefined;\n\n\tset(key: string, value: StorageValue, external?: boolean): Promise<void>;\n\tdelete(key: string, external?: boolean): Promise<void>;\n\n\tflush(delay?: number): Promise<void>;\n\twhenFlushed(): Promise<void>;\n\n\toptimize(): Promise<void>;\n\n\tclose(): Promise<void>;\n}\n\nexport enum StorageState {\n\tNone,\n\tInitialized,\n\tClosed\n}\n\nexport class Storage extends Disposable implements IStorage {\n\n\tprivate static readonly DEFAULT_FLUSH_DELAY = 100;\n\n\tprivate readonly _onDidChangeStorage = this._register(new PauseableEmitter<IStorageChangeEvent>());\n\treadonly onDidChangeStorage = this._onDidChangeStorage.event;\n\n\tprivate state = StorageState.None;\n\n\tprivate cache = new Map<string, string>();\n\n\tprivate readonly flushDelayer = this._register(new ThrottledDelayer<void>(Storage.DEFAULT_FLUSH_DELAY));\n\n\tprivate pendingDeletes = new Set<string>();\n\tprivate pendingInserts = new Map<string, string>();\n\n\tprivate pendingClose: Promise<void> | undefined = undefined;\n\n\tprivate readonly whenFlushedCallbacks: Function[] = [];\n\n\tconstructor(\n\t\tprotected readonly database: IStorageDatabase,\n\t\tprivate readonly options: IStorageOptions = Object.create(null)\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n\t}\n\n\tprivate onDidChangeItemsExternal(e: IStorageItemsChangeEvent): void {\n\t\tthis._onDidChangeStorage.pause();\n\n\t\ttry {\n\t\t\t// items that change external require us to update our\n\t\t\t// caches with the values. we just accept the value and\n\t\t\t// emit an event if there is a change.\n\n\t\t\te.changed?.forEach((value, key) => this.acceptExternal(key, value));\n\t\t\te.deleted?.forEach(key => this.acceptExternal(key, undefined));\n\n\t\t} finally {\n\t\t\tthis._onDidChangeStorage.resume();\n\t\t}\n\t}\n\n\tprivate acceptExternal(key: string, value: string | undefined): void {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\tlet changed = false;\n\n\t\t// Item got removed, check for deletion\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tchanged = this.cache.delete(key);\n\t\t}\n\n\t\t// Item got updated, check for change\n\t\telse {\n\t\t\tconst currentValue = this.cache.get(key);\n\t\t\tif (currentValue !== value) {\n\t\t\t\tthis.cache.set(key, value);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Signal to outside listeners\n\t\tif (changed) {\n\t\t\tthis._onDidChangeStorage.fire({ key, external: true });\n\t\t}\n\t}\n\n\tget items(): Map<string, string> {\n\t\treturn this.cache;\n\t}\n\n\tget size(): number {\n\t\treturn this.cache.size;\n\t}\n\n\tasync init(): Promise<void> {\n\t\tif (this.state !== StorageState.None) {\n\t\t\treturn; // either closed or already initialized\n\t\t}\n\n\t\tthis.state = StorageState.Initialized;\n\n\t\tif (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {\n\t\t\t// return early if we know the storage file does not exist. this is a performance\n\t\t\t// optimization to not load all items of the underlying storage if we know that\n\t\t\t// there can be no items because the storage does not exist.\n\t\t\treturn;\n\t\t}\n\n\t\tthis.cache = await this.database.getItems();\n\t}\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\tconst value = this.cache.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value === 'true';\n\t}\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parseInt(value, 10);\n\t}\n\n\tgetObject(key: string, fallbackValue: object): object;\n\tgetObject(key: string, fallbackValue?: object | undefined): object | undefined;\n\tgetObject(key: string, fallbackValue?: object): object | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parse(value);\n\t}\n\n\tasync set(key: string, value: string | boolean | number | null | undefined | object, external = false): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn this.delete(key, external);\n\t\t}\n\n\t\t// Otherwise, convert to String and store\n\t\tconst valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);\n\n\t\t// Return early if value already set\n\t\tconst currentValue = this.cache.get(key);\n\t\tif (currentValue === valueStr) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update in cache and pending\n\t\tthis.cache.set(key, valueStr);\n\t\tthis.pendingInserts.set(key, valueStr);\n\t\tthis.pendingDeletes.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tasync delete(key: string, external = false): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Remove from cache and add to pending\n\t\tconst wasDeleted = this.cache.delete(key);\n\t\tif (!wasDeleted) {\n\t\t\treturn; // Return early if value already deleted\n\t\t}\n\n\t\tif (!this.pendingDeletes.has(key)) {\n\t\t\tthis.pendingDeletes.add(key);\n\t\t}\n\n\t\tthis.pendingInserts.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tasync optimize(): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Await pending data to be flushed to the DB\n\t\t// before attempting to optimize the DB\n\t\tawait this.flush(0);\n\n\t\treturn this.database.optimize();\n\t}\n\n\tasync close(): Promise<void> {\n\t\tif (!this.pendingClose) {\n\t\t\tthis.pendingClose = this.doClose();\n\t\t}\n\n\t\treturn this.pendingClose;\n\t}\n\n\tprivate async doClose(): Promise<void> {\n\n\t\t// Update state\n\t\tthis.state = StorageState.Closed;\n\n\t\t// Trigger new flush to ensure data is persisted and then close\n\t\t// even if there is an error flushing. We must always ensure\n\t\t// the DB is closed to avoid corruption.\n\t\t//\n\t\t// Recovery: we pass our cache over as recovery option in case\n\t\t// the DB is not healthy.\n\t\ttry {\n\t\t\tawait this.doFlush(0 /* as soon as possible */);\n\t\t} catch {\n\t\t\t// Ignore\n\t\t}\n\n\t\tawait this.database.close(() => this.cache);\n\t}\n\n\tprivate get hasPending() {\n\t\treturn this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n\t}\n\n\tprivate async flushPending(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\t// Get pending data\n\t\tconst updateRequest: IUpdateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n\n\t\t// Reset pending data for next run\n\t\tthis.pendingDeletes = new Set<string>();\n\t\tthis.pendingInserts = new Map<string, string>();\n\n\t\t// Update in storage and release any\n\t\t// waiters we have once done\n\t\treturn this.database.updateItems(updateRequest).finally(() => {\n\t\t\tif (!this.hasPending) {\n\t\t\t\twhile (this.whenFlushedCallbacks.length) {\n\t\t\t\t\tthis.whenFlushedCallbacks.pop()?.();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tasync flush(delay?: number): Promise<void> {\n\t\tif (\n\t\t\tthis.state === StorageState.Closed || \t// Return early if we are already closed\n\t\t\tthis.pendingClose \t\t\t\t\t\t// return early if nothing to do\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doFlush(delay);\n\t}\n\n\tprivate async doFlush(delay?: number): Promise<void> {\n\t\tif (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {\n\t\t\treturn this.flushPending(); // return early if in-memory\n\t\t}\n\n\t\treturn this.flushDelayer.trigger(() => this.flushPending(), delay);\n\t}\n\n\tasync whenFlushed(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\treturn new Promise(resolve => this.whenFlushedCallbacks.push(resolve));\n\t}\n\n\tisInMemory(): boolean {\n\t\treturn this.options.hint === StorageHint.STORAGE_IN_MEMORY;\n\t}\n}\n\nexport class InMemoryStorageDatabase implements IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal = Event.None;\n\n\tprivate readonly items = new Map<string, string>();\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\treturn this.items;\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\trequest.insert?.forEach((value, key) => this.items.set(key, value));\n\n\t\trequest.delete?.forEach(key => this.items.delete(key));\n\t}\n\n\tasync optimize(): Promise<void> { }\n\tasync close(): Promise<void> { }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ThrottledDelayer } from '../../../common/async.js';\nimport { Event, PauseableEmitter } from '../../../common/event.js';\nimport { Disposable, IDisposable } from '../../../common/lifecycle.js';\nimport { parse, stringify } from '../../../common/marshalling.js';\nimport { isObject, isUndefinedOrNull } from '../../../common/types.js';\n\nexport enum StorageHint {\n\n\t// A hint to the storage that the storage\n\t// does not exist on disk yet. This allows\n\t// the storage library to improve startup\n\t// time by not checking the storage for data.\n\tSTORAGE_DOES_NOT_EXIST,\n\n\t// A hint to the storage that the storage\n\t// is backed by an in-memory storage.\n\tSTORAGE_IN_MEMORY\n}\n\nexport interface IStorageOptions {\n\treadonly hint?: StorageHint;\n}\n\nexport interface IUpdateRequest {\n\treadonly insert?: Map<string, string>;\n\treadonly delete?: Set<string>;\n}\n\nexport interface IStorageItemsChangeEvent {\n\treadonly changed?: Map<string, string>;\n\treadonly deleted?: Set<string>;\n}\n\nexport function isStorageItemsChangeEvent(thing: unknown): thing is IStorageItemsChangeEvent {\n\tconst candidate = thing as IStorageItemsChangeEvent | undefined;\n\n\treturn candidate?.changed instanceof Map || candidate?.deleted instanceof Set;\n}\n\nexport interface IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal: Event<IStorageItemsChangeEvent>;\n\n\tgetItems(): Promise<Map<string, string>>;\n\tupdateItems(request: IUpdateRequest): Promise<void>;\n\n\toptimize(): Promise<void>;\n\n\tclose(recovery?: () => Map<string, string>): Promise<void>;\n}\n\nexport interface IStorageChangeEvent {\n\n\t/**\n\t * The `key` of the storage entry that was changed\n\t * or was removed.\n\t */\n\treadonly key: string;\n\n\t/**\n\t * A hint how the storage change event was triggered. If\n\t * `true`, the storage change was triggered by an external\n\t * source, such as:\n\t * - another process (for example another window)\n\t * - operations such as settings sync or profiles change\n\t */\n\treadonly external?: boolean;\n}\n\nexport type StorageValue = string | boolean | number | undefined | null | object;\n\nexport interface IStorage extends IDisposable {\n\n\treadonly onDidChangeStorage: Event<IStorageChangeEvent>;\n\n\treadonly items: Map<string, string>;\n\treadonly size: number;\n\n\tinit(): Promise<void>;\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\n\tgetObject<T extends object>(key: string, fallbackValue: T): T;\n\tgetObject<T extends object>(key: string, fallbackValue?: T): T | undefined;\n\n\tset(key: string, value: StorageValue, external?: boolean): Promise<void>;\n\tdelete(key: string, external?: boolean): Promise<void>;\n\n\tflush(delay?: number): Promise<void>;\n\twhenFlushed(): Promise<void>;\n\n\toptimize(): Promise<void>;\n\n\tclose(): Promise<void>;\n}\n\nexport enum StorageState {\n\tNone,\n\tInitialized,\n\tClosed\n}\n\nexport class Storage extends Disposable implements IStorage {\n\n\tprivate static readonly DEFAULT_FLUSH_DELAY = 100;\n\n\tprivate readonly _onDidChangeStorage = this._register(new PauseableEmitter<IStorageChangeEvent>());\n\treadonly onDidChangeStorage = this._onDidChangeStorage.event;\n\n\tprivate state = StorageState.None;\n\n\tprivate cache = new Map<string, string>();\n\n\tprivate readonly flushDelayer = this._register(new ThrottledDelayer<void>(Storage.DEFAULT_FLUSH_DELAY));\n\n\tprivate pendingDeletes = new Set<string>();\n\tprivate pendingInserts = new Map<string, string>();\n\n\tprivate pendingClose: Promise<void> | undefined = undefined;\n\n\tprivate readonly whenFlushedCallbacks: Function[] = [];\n\n\tconstructor(\n\t\tprotected readonly database: IStorageDatabase,\n\t\tprivate readonly options: IStorageOptions = Object.create(null)\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n\t}\n\n\tprivate onDidChangeItemsExternal(e: IStorageItemsChangeEvent): void {\n\t\tthis._onDidChangeStorage.pause();\n\n\t\ttry {\n\t\t\t// items that change external require us to update our\n\t\t\t// caches with the values. we just accept the value and\n\t\t\t// emit an event if there is a change.\n\n\t\t\te.changed?.forEach((value, key) => this.acceptExternal(key, value));\n\t\t\te.deleted?.forEach(key => this.acceptExternal(key, undefined));\n\n\t\t} finally {\n\t\t\tthis._onDidChangeStorage.resume();\n\t\t}\n\t}\n\n\tprivate acceptExternal(key: string, value: string | undefined): void {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\tlet changed = false;\n\n\t\t// Item got removed, check for deletion\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tchanged = this.cache.delete(key);\n\t\t}\n\n\t\t// Item got updated, check for change\n\t\telse {\n\t\t\tconst currentValue = this.cache.get(key);\n\t\t\tif (currentValue !== value) {\n\t\t\t\tthis.cache.set(key, value);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Signal to outside listeners\n\t\tif (changed) {\n\t\t\tthis._onDidChangeStorage.fire({ key, external: true });\n\t\t}\n\t}\n\n\tget items(): Map<string, string> {\n\t\treturn this.cache;\n\t}\n\n\tget size(): number {\n\t\treturn this.cache.size;\n\t}\n\n\tasync init(): Promise<void> {\n\t\tif (this.state !== StorageState.None) {\n\t\t\treturn; // either closed or already initialized\n\t\t}\n\n\t\tthis.state = StorageState.Initialized;\n\n\t\tif (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {\n\t\t\t// return early if we know the storage file does not exist. this is a performance\n\t\t\t// optimization to not load all items of the underlying storage if we know that\n\t\t\t// there can be no items because the storage does not exist.\n\t\t\treturn;\n\t\t}\n\n\t\tthis.cache = await this.database.getItems();\n\t}\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\tconst value = this.cache.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value === 'true';\n\t}\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parseInt(value, 10);\n\t}\n\n\tgetObject(key: string, fallbackValue: object): object;\n\tgetObject(key: string, fallbackValue?: object | undefined): object | undefined;\n\tgetObject(key: string, fallbackValue?: object): object | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parse(value);\n\t}\n\n\tasync set(key: string, value: string | boolean | number | null | undefined | object, external = false): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn this.delete(key, external);\n\t\t}\n\n\t\t// Otherwise, convert to String and store\n\t\tconst valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);\n\n\t\t// Return early if value already set\n\t\tconst currentValue = this.cache.get(key);\n\t\tif (currentValue === valueStr) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update in cache and pending\n\t\tthis.cache.set(key, valueStr);\n\t\tthis.pendingInserts.set(key, valueStr);\n\t\tthis.pendingDeletes.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tasync delete(key: string, external = false): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Remove from cache and add to pending\n\t\tconst wasDeleted = this.cache.delete(key);\n\t\tif (!wasDeleted) {\n\t\t\treturn; // Return early if value already deleted\n\t\t}\n\n\t\tif (!this.pendingDeletes.has(key)) {\n\t\t\tthis.pendingDeletes.add(key);\n\t\t}\n\n\t\tthis.pendingInserts.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tasync optimize(): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Await pending data to be flushed to the DB\n\t\t// before attempting to optimize the DB\n\t\tawait this.flush(0);\n\n\t\treturn this.database.optimize();\n\t}\n\n\tasync close(): Promise<void> {\n\t\tif (!this.pendingClose) {\n\t\t\tthis.pendingClose = this.doClose();\n\t\t}\n\n\t\treturn this.pendingClose;\n\t}\n\n\tprivate async doClose(): Promise<void> {\n\n\t\t// Update state\n\t\tthis.state = StorageState.Closed;\n\n\t\t// Trigger new flush to ensure data is persisted and then close\n\t\t// even if there is an error flushing. We must always ensure\n\t\t// the DB is closed to avoid corruption.\n\t\t//\n\t\t// Recovery: we pass our cache over as recovery option in case\n\t\t// the DB is not healthy.\n\t\ttry {\n\t\t\tawait this.doFlush(0 /* as soon as possible */);\n\t\t} catch {\n\t\t\t// Ignore\n\t\t}\n\n\t\tawait this.database.close(() => this.cache);\n\t}\n\n\tprivate get hasPending() {\n\t\treturn this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n\t}\n\n\tprivate async flushPending(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\t// Get pending data\n\t\tconst updateRequest: IUpdateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n\n\t\t// Reset pending data for next run\n\t\tthis.pendingDeletes = new Set<string>();\n\t\tthis.pendingInserts = new Map<string, string>();\n\n\t\t// Update in storage and release any\n\t\t// waiters we have once done\n\t\treturn this.database.updateItems(updateRequest).finally(() => {\n\t\t\tif (!this.hasPending) {\n\t\t\t\twhile (this.whenFlushedCallbacks.length) {\n\t\t\t\t\tthis.whenFlushedCallbacks.pop()?.();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tasync flush(delay?: number): Promise<void> {\n\t\tif (\n\t\t\tthis.state === StorageState.Closed || \t// Return early if we are already closed\n\t\t\tthis.pendingClose \t\t\t\t\t\t// return early if nothing to do\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doFlush(delay);\n\t}\n\n\tprivate async doFlush(delay?: number): Promise<void> {\n\t\tif (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {\n\t\t\treturn this.flushPending(); // return early if in-memory\n\t\t}\n\n\t\treturn this.flushDelayer.trigger(() => this.flushPending(), delay);\n\t}\n\n\tasync whenFlushed(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\treturn new Promise(resolve => this.whenFlushedCallbacks.push(resolve));\n\t}\n\n\tisInMemory(): boolean {\n\t\treturn this.options.hint === StorageHint.STORAGE_IN_MEMORY;\n\t}\n}\n\nexport class InMemoryStorageDatabase implements IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal = Event.None;\n\n\tprivate readonly items = new Map<string, string>();\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\treturn this.items;\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\trequest.insert?.forEach((value, key) => this.items.set(key, value));\n\n\t\trequest.delete?.forEach(key => this.items.delete(key));\n\t}\n\n\tasync optimize(): Promise<void> { }\n\tasync close(): Promise<void> { }\n}\n"]}