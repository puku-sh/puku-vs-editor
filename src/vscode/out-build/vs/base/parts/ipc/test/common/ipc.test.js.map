{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/parts/ipc/test/common/ipc.test.ts","vs/base/parts/ipc/test/common/ipc.test.ts"],"names":[],"mappings":"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","file":"ipc.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { timeout } from '../../../../common/async.js';\nimport { VSBuffer } from '../../../../common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../common/cancellation.js';\nimport { canceled } from '../../../../common/errors.js';\nimport { Emitter, Event } from '../../../../common/event.js';\nimport { DisposableStore } from '../../../../common/lifecycle.js';\nimport { isEqual } from '../../../../common/resources.js';\nimport { URI } from '../../../../common/uri.js';\nimport { BufferReader, BufferWriter, ClientConnectionEvent, deserialize, IChannel, IMessagePassingProtocol, IPCClient, IPCServer, IServerChannel, ProxyChannel, serialize } from '../../common/ipc.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../test/common/utils.js';\n\nclass QueueProtocol implements IMessagePassingProtocol {\n\n\tprivate buffering = true;\n\tprivate buffers: VSBuffer[] = [];\n\n\tprivate readonly _onMessage = new Emitter<VSBuffer>({\n\t\tonDidAddFirstListener: () => {\n\t\t\tfor (const buffer of this.buffers) {\n\t\t\t\tthis._onMessage.fire(buffer);\n\t\t\t}\n\n\t\t\tthis.buffers = [];\n\t\t\tthis.buffering = false;\n\t\t},\n\t\tonDidRemoveLastListener: () => {\n\t\t\tthis.buffering = true;\n\t\t}\n\t});\n\n\treadonly onMessage = this._onMessage.event;\n\tother!: QueueProtocol;\n\n\tsend(buffer: VSBuffer): void {\n\t\tthis.other.receive(buffer);\n\t}\n\n\tprotected receive(buffer: VSBuffer): void {\n\t\tif (this.buffering) {\n\t\t\tthis.buffers.push(buffer);\n\t\t} else {\n\t\t\tthis._onMessage.fire(buffer);\n\t\t}\n\t}\n}\n\nfunction createProtocolPair(): [IMessagePassingProtocol, IMessagePassingProtocol] {\n\tconst one = new QueueProtocol();\n\tconst other = new QueueProtocol();\n\tone.other = other;\n\tother.other = one;\n\n\treturn [one, other];\n}\n\nclass TestIPCClient extends IPCClient<string> {\n\n\tprivate readonly _onDidDisconnect = new Emitter<void>();\n\treadonly onDidDisconnect = this._onDidDisconnect.event;\n\n\tconstructor(protocol: IMessagePassingProtocol, id: string) {\n\t\tsuper(protocol, id);\n\t}\n\n\toverride dispose(): void {\n\t\tthis._onDidDisconnect.fire();\n\t\tsuper.dispose();\n\t}\n}\n\nclass TestIPCServer extends IPCServer<string> {\n\n\tprivate readonly onDidClientConnect: Emitter<ClientConnectionEvent>;\n\n\tconstructor() {\n\t\tconst onDidClientConnect = new Emitter<ClientConnectionEvent>();\n\t\tsuper(onDidClientConnect.event);\n\t\tthis.onDidClientConnect = onDidClientConnect;\n\t}\n\n\tcreateConnection(id: string): IPCClient<string> {\n\t\tconst [pc, ps] = createProtocolPair();\n\t\tconst client = new TestIPCClient(pc, id);\n\n\t\tthis.onDidClientConnect.fire({\n\t\t\tprotocol: ps,\n\t\t\tonDidClientDisconnect: client.onDidDisconnect\n\t\t});\n\n\t\treturn client;\n\t}\n}\n\nconst TestChannelId = 'testchannel';\n\ninterface ITestService {\n\tmarco(): Promise<string>;\n\terror(message: string): Promise<void>;\n\tneverComplete(): Promise<void>;\n\tneverCompleteCT(cancellationToken: CancellationToken): Promise<void>;\n\tbuffersLength(buffers: VSBuffer[]): Promise<number>;\n\tmarshall(uri: URI): Promise<URI>;\n\tcontext(): Promise<unknown>;\n\n\treadonly onPong: Event<string>;\n}\n\nclass TestService implements ITestService {\n\n\tprivate readonly disposables = new DisposableStore();\n\n\tprivate readonly _onPong = new Emitter<string>();\n\treadonly onPong = this._onPong.event;\n\n\tmarco(): Promise<string> {\n\t\treturn Promise.resolve('polo');\n\t}\n\n\terror(message: string): Promise<void> {\n\t\treturn Promise.reject(new Error(message));\n\t}\n\n\tneverComplete(): Promise<void> {\n\t\treturn new Promise(_ => { });\n\t}\n\n\tneverCompleteCT(cancellationToken: CancellationToken): Promise<void> {\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(canceled());\n\t\t}\n\n\t\treturn new Promise((_, e) => this.disposables.add(cancellationToken.onCancellationRequested(() => e(canceled()))));\n\t}\n\n\tbuffersLength(buffers: VSBuffer[]): Promise<number> {\n\t\treturn Promise.resolve(buffers.reduce((r, b) => r + b.buffer.length, 0));\n\t}\n\n\tping(msg: string): void {\n\t\tthis._onPong.fire(msg);\n\t}\n\n\tmarshall(uri: URI): Promise<URI> {\n\t\treturn Promise.resolve(uri);\n\t}\n\n\tcontext(context?: unknown): Promise<unknown> {\n\t\treturn Promise.resolve(context);\n\t}\n\n\tdispose() {\n\t\tthis.disposables.dispose();\n\t}\n}\n\nclass TestChannel implements IServerChannel {\n\n\tconstructor(private service: ITestService) { }\n\n\tcall(_: unknown, command: string, arg: any, cancellationToken: CancellationToken): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'marco': return this.service.marco();\n\t\t\tcase 'error': return this.service.error(arg);\n\t\t\tcase 'neverComplete': return this.service.neverComplete();\n\t\t\tcase 'neverCompleteCT': return this.service.neverCompleteCT(cancellationToken);\n\t\t\tcase 'buffersLength': return this.service.buffersLength(arg);\n\t\t\tdefault: return Promise.reject(new Error('not implemented'));\n\t\t}\n\t}\n\n\tlisten(_: unknown, event: string, arg?: any): Event<any> {\n\t\tswitch (event) {\n\t\t\tcase 'onPong': return this.service.onPong;\n\t\t\tdefault: throw new Error('not implemented');\n\t\t}\n\t}\n}\n\nclass TestChannelClient implements ITestService {\n\n\tget onPong(): Event<string> {\n\t\treturn this.channel.listen('onPong');\n\t}\n\n\tconstructor(private channel: IChannel) { }\n\n\tmarco(): Promise<string> {\n\t\treturn this.channel.call('marco');\n\t}\n\n\terror(message: string): Promise<void> {\n\t\treturn this.channel.call('error', message);\n\t}\n\n\tneverComplete(): Promise<void> {\n\t\treturn this.channel.call('neverComplete');\n\t}\n\n\tneverCompleteCT(cancellationToken: CancellationToken): Promise<void> {\n\t\treturn this.channel.call('neverCompleteCT', undefined, cancellationToken);\n\t}\n\n\tbuffersLength(buffers: VSBuffer[]): Promise<number> {\n\t\treturn this.channel.call('buffersLength', buffers);\n\t}\n\n\tmarshall(uri: URI): Promise<URI> {\n\t\treturn this.channel.call('marshall', uri);\n\t}\n\n\tcontext(): Promise<unknown> {\n\t\treturn this.channel.call('context');\n\t}\n}\n\nsuite('Base IPC', function () {\n\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('createProtocolPair', async function () {\n\t\tconst [clientProtocol, serverProtocol] = createProtocolPair();\n\n\t\tconst b1 = VSBuffer.alloc(0);\n\t\tclientProtocol.send(b1);\n\n\t\tconst b3 = VSBuffer.alloc(0);\n\t\tserverProtocol.send(b3);\n\n\t\tconst b2 = await Event.toPromise(serverProtocol.onMessage);\n\t\tconst b4 = await Event.toPromise(clientProtocol.onMessage);\n\n\t\tassert.strictEqual(b1, b2);\n\t\tassert.strictEqual(b3, b4);\n\t});\n\n\tsuite('one to one', function () {\n\t\tlet server: IPCServer;\n\t\tlet client: IPCClient;\n\t\tlet service: TestService;\n\t\tlet ipcService: ITestService;\n\n\t\tsetup(function () {\n\t\t\tservice = store.add(new TestService());\n\t\t\tconst testServer = store.add(new TestIPCServer());\n\t\t\tserver = testServer;\n\n\t\t\tserver.registerChannel(TestChannelId, new TestChannel(service));\n\n\t\t\tclient = store.add(testServer.createConnection('client1'));\n\t\t\tipcService = new TestChannelClient(client.getChannel(TestChannelId));\n\t\t});\n\n\t\ttest('call success', async function () {\n\t\t\tconst r = await ipcService.marco();\n\t\t\treturn assert.strictEqual(r, 'polo');\n\t\t});\n\n\t\ttest('call error', async function () {\n\t\t\ttry {\n\t\t\t\tawait ipcService.error('nice error');\n\t\t\t\treturn assert.fail('should not reach here');\n\t\t\t} catch (err) {\n\t\t\t\treturn assert.strictEqual(err.message, 'nice error');\n\t\t\t}\n\t\t});\n\n\t\ttest('cancel call with cancelled cancellation token', async function () {\n\t\t\ttry {\n\t\t\t\tawait ipcService.neverCompleteCT(CancellationToken.Cancelled);\n\t\t\t\treturn assert.fail('should not reach here');\n\t\t\t} catch (err) {\n\t\t\t\treturn assert(err.message === 'Canceled');\n\t\t\t}\n\t\t});\n\n\t\ttest('cancel call with cancellation token (sync)', function () {\n\t\t\tconst cts = new CancellationTokenSource();\n\t\t\tconst promise = ipcService.neverCompleteCT(cts.token).then(\n\t\t\t\t_ => assert.fail('should not reach here'),\n\t\t\t\terr => assert(err.message === 'Canceled')\n\t\t\t);\n\n\t\t\tcts.cancel();\n\n\t\t\treturn promise;\n\t\t});\n\n\t\ttest('cancel call with cancellation token (async)', function () {\n\t\t\tconst cts = new CancellationTokenSource();\n\t\t\tconst promise = ipcService.neverCompleteCT(cts.token).then(\n\t\t\t\t_ => assert.fail('should not reach here'),\n\t\t\t\terr => assert(err.message === 'Canceled')\n\t\t\t);\n\n\t\t\tsetTimeout(() => cts.cancel());\n\n\t\t\treturn promise;\n\t\t});\n\n\t\ttest('listen to events', async function () {\n\t\t\tconst messages: string[] = [];\n\n\t\t\tstore.add(ipcService.onPong(msg => messages.push(msg)));\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, []);\n\t\t\tservice.ping('hello');\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, ['hello']);\n\t\t\tservice.ping('world');\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, ['hello', 'world']);\n\t\t});\n\n\t\ttest('buffers in arrays', async function () {\n\t\t\tconst r = await ipcService.buffersLength([VSBuffer.alloc(2), VSBuffer.alloc(3)]);\n\t\t\treturn assert.strictEqual(r, 5);\n\t\t});\n\n\t\ttest('round trips numbers', () => {\n\t\t\tconst input = [\n\t\t\t\t0,\n\t\t\t\t1,\n\t\t\t\t-1,\n\t\t\t\t12345,\n\t\t\t\t-12345,\n\t\t\t\t42.6,\n\t\t\t\t123412341234\n\t\t\t];\n\n\t\t\tconst writer = new BufferWriter();\n\t\t\tserialize(writer, input);\n\t\t\tassert.deepStrictEqual(deserialize(new BufferReader(writer.buffer)), input);\n\t\t});\n\t});\n\n\tsuite('one to one (proxy)', function () {\n\t\tlet server: IPCServer;\n\t\tlet client: IPCClient;\n\t\tlet service: TestService;\n\t\tlet ipcService: ITestService;\n\n\t\tconst disposables = new DisposableStore();\n\n\t\tsetup(function () {\n\t\t\tservice = store.add(new TestService());\n\t\t\tconst testServer = disposables.add(new TestIPCServer());\n\t\t\tserver = testServer;\n\n\t\t\tserver.registerChannel(TestChannelId, ProxyChannel.fromService(service, disposables));\n\n\t\t\tclient = disposables.add(testServer.createConnection('client1'));\n\t\t\tipcService = ProxyChannel.toService(client.getChannel(TestChannelId));\n\t\t});\n\n\t\tteardown(function () {\n\t\t\tdisposables.clear();\n\t\t});\n\n\t\ttest('call success', async function () {\n\t\t\tconst r = await ipcService.marco();\n\t\t\treturn assert.strictEqual(r, 'polo');\n\t\t});\n\n\t\ttest('call error', async function () {\n\t\t\ttry {\n\t\t\t\tawait ipcService.error('nice error');\n\t\t\t\treturn assert.fail('should not reach here');\n\t\t\t} catch (err) {\n\t\t\t\treturn assert.strictEqual(err.message, 'nice error');\n\t\t\t}\n\t\t});\n\n\t\ttest('listen to events', async function () {\n\t\t\tconst messages: string[] = [];\n\n\t\t\tdisposables.add(ipcService.onPong(msg => messages.push(msg)));\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, []);\n\t\t\tservice.ping('hello');\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, ['hello']);\n\t\t\tservice.ping('world');\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, ['hello', 'world']);\n\t\t});\n\n\t\ttest('marshalling uri', async function () {\n\t\t\tconst uri = URI.file('foobar');\n\t\t\tconst r = await ipcService.marshall(uri);\n\t\t\tassert.ok(r instanceof URI);\n\t\t\treturn assert.ok(isEqual(r, uri));\n\t\t});\n\n\t\ttest('buffers in arrays', async function () {\n\t\t\tconst r = await ipcService.buffersLength([VSBuffer.alloc(2), VSBuffer.alloc(3)]);\n\t\t\treturn assert.strictEqual(r, 5);\n\t\t});\n\t});\n\n\tsuite('one to one (proxy, extra context)', function () {\n\t\tlet server: IPCServer;\n\t\tlet client: IPCClient;\n\t\tlet service: TestService;\n\t\tlet ipcService: ITestService;\n\n\t\tconst disposables = new DisposableStore();\n\n\t\tsetup(function () {\n\t\t\tservice = store.add(new TestService());\n\t\t\tconst testServer = disposables.add(new TestIPCServer());\n\t\t\tserver = testServer;\n\n\t\t\tserver.registerChannel(TestChannelId, ProxyChannel.fromService(service, disposables));\n\n\t\t\tclient = disposables.add(testServer.createConnection('client1'));\n\t\t\tipcService = ProxyChannel.toService(client.getChannel(TestChannelId), { context: 'Super Context' });\n\t\t});\n\n\t\tteardown(function () {\n\t\t\tdisposables.clear();\n\t\t});\n\n\t\ttest('call extra context', async function () {\n\t\t\tconst r = await ipcService.context();\n\t\t\treturn assert.strictEqual(r, 'Super Context');\n\t\t});\n\t});\n\n\tsuite('one to many', function () {\n\t\ttest('all clients get pinged', async function () {\n\t\t\tconst service = store.add(new TestService());\n\t\t\tconst channel = new TestChannel(service);\n\t\t\tconst server = store.add(new TestIPCServer());\n\t\t\tserver.registerChannel('channel', channel);\n\n\t\t\tlet client1GotPinged = false;\n\t\t\tconst client1 = store.add(server.createConnection('client1'));\n\t\t\tconst ipcService1 = new TestChannelClient(client1.getChannel('channel'));\n\t\t\tstore.add(ipcService1.onPong(() => client1GotPinged = true));\n\n\t\t\tlet client2GotPinged = false;\n\t\t\tconst client2 = store.add(server.createConnection('client2'));\n\t\t\tconst ipcService2 = new TestChannelClient(client2.getChannel('channel'));\n\t\t\tstore.add(ipcService2.onPong(() => client2GotPinged = true));\n\n\t\t\tawait timeout(1);\n\t\t\tservice.ping('hello');\n\n\t\t\tawait timeout(1);\n\t\t\tassert(client1GotPinged, 'client 1 got pinged');\n\t\t\tassert(client2GotPinged, 'client 2 got pinged');\n\t\t});\n\n\t\ttest('server gets pings from all clients (broadcast channel)', async function () {\n\t\t\tconst server = store.add(new TestIPCServer());\n\n\t\t\tconst client1 = server.createConnection('client1');\n\t\t\tconst clientService1 = store.add(new TestService());\n\t\t\tconst clientChannel1 = new TestChannel(clientService1);\n\t\t\tclient1.registerChannel('channel', clientChannel1);\n\n\t\t\tconst pings: string[] = [];\n\t\t\tconst channel = server.getChannel('channel', () => true);\n\t\t\tconst service = new TestChannelClient(channel);\n\t\t\tstore.add(service.onPong(msg => pings.push(msg)));\n\n\t\t\tawait timeout(1);\n\t\t\tclientService1.ping('hello 1');\n\n\t\t\tawait timeout(1);\n\t\t\tassert.deepStrictEqual(pings, ['hello 1']);\n\n\t\t\tconst client2 = server.createConnection('client2');\n\t\t\tconst clientService2 = store.add(new TestService());\n\t\t\tconst clientChannel2 = new TestChannel(clientService2);\n\t\t\tclient2.registerChannel('channel', clientChannel2);\n\n\t\t\tawait timeout(1);\n\t\t\tclientService2.ping('hello 2');\n\n\t\t\tawait timeout(1);\n\t\t\tassert.deepStrictEqual(pings, ['hello 1', 'hello 2']);\n\n\t\t\tclient1.dispose();\n\t\t\tclientService1.ping('hello 1');\n\n\t\t\tawait timeout(1);\n\t\t\tassert.deepStrictEqual(pings, ['hello 1', 'hello 2']);\n\n\t\t\tawait timeout(1);\n\t\t\tclientService2.ping('hello again 2');\n\n\t\t\tawait timeout(1);\n\t\t\tassert.deepStrictEqual(pings, ['hello 1', 'hello 2', 'hello again 2']);\n\n\t\t\tclient2.dispose();\n\t\t});\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { timeout } from '../../../../common/async.js';\nimport { VSBuffer } from '../../../../common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../common/cancellation.js';\nimport { canceled } from '../../../../common/errors.js';\nimport { Emitter, Event } from '../../../../common/event.js';\nimport { DisposableStore } from '../../../../common/lifecycle.js';\nimport { isEqual } from '../../../../common/resources.js';\nimport { URI } from '../../../../common/uri.js';\nimport { BufferReader, BufferWriter, ClientConnectionEvent, deserialize, IChannel, IMessagePassingProtocol, IPCClient, IPCServer, IServerChannel, ProxyChannel, serialize } from '../../common/ipc.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../test/common/utils.js';\n\nclass QueueProtocol implements IMessagePassingProtocol {\n\n\tprivate buffering = true;\n\tprivate buffers: VSBuffer[] = [];\n\n\tprivate readonly _onMessage = new Emitter<VSBuffer>({\n\t\tonDidAddFirstListener: () => {\n\t\t\tfor (const buffer of this.buffers) {\n\t\t\t\tthis._onMessage.fire(buffer);\n\t\t\t}\n\n\t\t\tthis.buffers = [];\n\t\t\tthis.buffering = false;\n\t\t},\n\t\tonDidRemoveLastListener: () => {\n\t\t\tthis.buffering = true;\n\t\t}\n\t});\n\n\treadonly onMessage = this._onMessage.event;\n\tother!: QueueProtocol;\n\n\tsend(buffer: VSBuffer): void {\n\t\tthis.other.receive(buffer);\n\t}\n\n\tprotected receive(buffer: VSBuffer): void {\n\t\tif (this.buffering) {\n\t\t\tthis.buffers.push(buffer);\n\t\t} else {\n\t\t\tthis._onMessage.fire(buffer);\n\t\t}\n\t}\n}\n\nfunction createProtocolPair(): [IMessagePassingProtocol, IMessagePassingProtocol] {\n\tconst one = new QueueProtocol();\n\tconst other = new QueueProtocol();\n\tone.other = other;\n\tother.other = one;\n\n\treturn [one, other];\n}\n\nclass TestIPCClient extends IPCClient<string> {\n\n\tprivate readonly _onDidDisconnect = new Emitter<void>();\n\treadonly onDidDisconnect = this._onDidDisconnect.event;\n\n\tconstructor(protocol: IMessagePassingProtocol, id: string) {\n\t\tsuper(protocol, id);\n\t}\n\n\toverride dispose(): void {\n\t\tthis._onDidDisconnect.fire();\n\t\tsuper.dispose();\n\t}\n}\n\nclass TestIPCServer extends IPCServer<string> {\n\n\tprivate readonly onDidClientConnect: Emitter<ClientConnectionEvent>;\n\n\tconstructor() {\n\t\tconst onDidClientConnect = new Emitter<ClientConnectionEvent>();\n\t\tsuper(onDidClientConnect.event);\n\t\tthis.onDidClientConnect = onDidClientConnect;\n\t}\n\n\tcreateConnection(id: string): IPCClient<string> {\n\t\tconst [pc, ps] = createProtocolPair();\n\t\tconst client = new TestIPCClient(pc, id);\n\n\t\tthis.onDidClientConnect.fire({\n\t\t\tprotocol: ps,\n\t\t\tonDidClientDisconnect: client.onDidDisconnect\n\t\t});\n\n\t\treturn client;\n\t}\n}\n\nconst TestChannelId = 'testchannel';\n\ninterface ITestService {\n\tmarco(): Promise<string>;\n\terror(message: string): Promise<void>;\n\tneverComplete(): Promise<void>;\n\tneverCompleteCT(cancellationToken: CancellationToken): Promise<void>;\n\tbuffersLength(buffers: VSBuffer[]): Promise<number>;\n\tmarshall(uri: URI): Promise<URI>;\n\tcontext(): Promise<unknown>;\n\n\treadonly onPong: Event<string>;\n}\n\nclass TestService implements ITestService {\n\n\tprivate readonly disposables = new DisposableStore();\n\n\tprivate readonly _onPong = new Emitter<string>();\n\treadonly onPong = this._onPong.event;\n\n\tmarco(): Promise<string> {\n\t\treturn Promise.resolve('polo');\n\t}\n\n\terror(message: string): Promise<void> {\n\t\treturn Promise.reject(new Error(message));\n\t}\n\n\tneverComplete(): Promise<void> {\n\t\treturn new Promise(_ => { });\n\t}\n\n\tneverCompleteCT(cancellationToken: CancellationToken): Promise<void> {\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(canceled());\n\t\t}\n\n\t\treturn new Promise((_, e) => this.disposables.add(cancellationToken.onCancellationRequested(() => e(canceled()))));\n\t}\n\n\tbuffersLength(buffers: VSBuffer[]): Promise<number> {\n\t\treturn Promise.resolve(buffers.reduce((r, b) => r + b.buffer.length, 0));\n\t}\n\n\tping(msg: string): void {\n\t\tthis._onPong.fire(msg);\n\t}\n\n\tmarshall(uri: URI): Promise<URI> {\n\t\treturn Promise.resolve(uri);\n\t}\n\n\tcontext(context?: unknown): Promise<unknown> {\n\t\treturn Promise.resolve(context);\n\t}\n\n\tdispose() {\n\t\tthis.disposables.dispose();\n\t}\n}\n\nclass TestChannel implements IServerChannel {\n\n\tconstructor(private service: ITestService) { }\n\n\tcall(_: unknown, command: string, arg: any, cancellationToken: CancellationToken): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'marco': return this.service.marco();\n\t\t\tcase 'error': return this.service.error(arg);\n\t\t\tcase 'neverComplete': return this.service.neverComplete();\n\t\t\tcase 'neverCompleteCT': return this.service.neverCompleteCT(cancellationToken);\n\t\t\tcase 'buffersLength': return this.service.buffersLength(arg);\n\t\t\tdefault: return Promise.reject(new Error('not implemented'));\n\t\t}\n\t}\n\n\tlisten(_: unknown, event: string, arg?: any): Event<any> {\n\t\tswitch (event) {\n\t\t\tcase 'onPong': return this.service.onPong;\n\t\t\tdefault: throw new Error('not implemented');\n\t\t}\n\t}\n}\n\nclass TestChannelClient implements ITestService {\n\n\tget onPong(): Event<string> {\n\t\treturn this.channel.listen('onPong');\n\t}\n\n\tconstructor(private channel: IChannel) { }\n\n\tmarco(): Promise<string> {\n\t\treturn this.channel.call('marco');\n\t}\n\n\terror(message: string): Promise<void> {\n\t\treturn this.channel.call('error', message);\n\t}\n\n\tneverComplete(): Promise<void> {\n\t\treturn this.channel.call('neverComplete');\n\t}\n\n\tneverCompleteCT(cancellationToken: CancellationToken): Promise<void> {\n\t\treturn this.channel.call('neverCompleteCT', undefined, cancellationToken);\n\t}\n\n\tbuffersLength(buffers: VSBuffer[]): Promise<number> {\n\t\treturn this.channel.call('buffersLength', buffers);\n\t}\n\n\tmarshall(uri: URI): Promise<URI> {\n\t\treturn this.channel.call('marshall', uri);\n\t}\n\n\tcontext(): Promise<unknown> {\n\t\treturn this.channel.call('context');\n\t}\n}\n\nsuite('Base IPC', function () {\n\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('createProtocolPair', async function () {\n\t\tconst [clientProtocol, serverProtocol] = createProtocolPair();\n\n\t\tconst b1 = VSBuffer.alloc(0);\n\t\tclientProtocol.send(b1);\n\n\t\tconst b3 = VSBuffer.alloc(0);\n\t\tserverProtocol.send(b3);\n\n\t\tconst b2 = await Event.toPromise(serverProtocol.onMessage);\n\t\tconst b4 = await Event.toPromise(clientProtocol.onMessage);\n\n\t\tassert.strictEqual(b1, b2);\n\t\tassert.strictEqual(b3, b4);\n\t});\n\n\tsuite('one to one', function () {\n\t\tlet server: IPCServer;\n\t\tlet client: IPCClient;\n\t\tlet service: TestService;\n\t\tlet ipcService: ITestService;\n\n\t\tsetup(function () {\n\t\t\tservice = store.add(new TestService());\n\t\t\tconst testServer = store.add(new TestIPCServer());\n\t\t\tserver = testServer;\n\n\t\t\tserver.registerChannel(TestChannelId, new TestChannel(service));\n\n\t\t\tclient = store.add(testServer.createConnection('client1'));\n\t\t\tipcService = new TestChannelClient(client.getChannel(TestChannelId));\n\t\t});\n\n\t\ttest('call success', async function () {\n\t\t\tconst r = await ipcService.marco();\n\t\t\treturn assert.strictEqual(r, 'polo');\n\t\t});\n\n\t\ttest('call error', async function () {\n\t\t\ttry {\n\t\t\t\tawait ipcService.error('nice error');\n\t\t\t\treturn assert.fail('should not reach here');\n\t\t\t} catch (err) {\n\t\t\t\treturn assert.strictEqual(err.message, 'nice error');\n\t\t\t}\n\t\t});\n\n\t\ttest('cancel call with cancelled cancellation token', async function () {\n\t\t\ttry {\n\t\t\t\tawait ipcService.neverCompleteCT(CancellationToken.Cancelled);\n\t\t\t\treturn assert.fail('should not reach here');\n\t\t\t} catch (err) {\n\t\t\t\treturn assert(err.message === 'Canceled');\n\t\t\t}\n\t\t});\n\n\t\ttest('cancel call with cancellation token (sync)', function () {\n\t\t\tconst cts = new CancellationTokenSource();\n\t\t\tconst promise = ipcService.neverCompleteCT(cts.token).then(\n\t\t\t\t_ => assert.fail('should not reach here'),\n\t\t\t\terr => assert(err.message === 'Canceled')\n\t\t\t);\n\n\t\t\tcts.cancel();\n\n\t\t\treturn promise;\n\t\t});\n\n\t\ttest('cancel call with cancellation token (async)', function () {\n\t\t\tconst cts = new CancellationTokenSource();\n\t\t\tconst promise = ipcService.neverCompleteCT(cts.token).then(\n\t\t\t\t_ => assert.fail('should not reach here'),\n\t\t\t\terr => assert(err.message === 'Canceled')\n\t\t\t);\n\n\t\t\tsetTimeout(() => cts.cancel());\n\n\t\t\treturn promise;\n\t\t});\n\n\t\ttest('listen to events', async function () {\n\t\t\tconst messages: string[] = [];\n\n\t\t\tstore.add(ipcService.onPong(msg => messages.push(msg)));\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, []);\n\t\t\tservice.ping('hello');\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, ['hello']);\n\t\t\tservice.ping('world');\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, ['hello', 'world']);\n\t\t});\n\n\t\ttest('buffers in arrays', async function () {\n\t\t\tconst r = await ipcService.buffersLength([VSBuffer.alloc(2), VSBuffer.alloc(3)]);\n\t\t\treturn assert.strictEqual(r, 5);\n\t\t});\n\n\t\ttest('round trips numbers', () => {\n\t\t\tconst input = [\n\t\t\t\t0,\n\t\t\t\t1,\n\t\t\t\t-1,\n\t\t\t\t12345,\n\t\t\t\t-12345,\n\t\t\t\t42.6,\n\t\t\t\t123412341234\n\t\t\t];\n\n\t\t\tconst writer = new BufferWriter();\n\t\t\tserialize(writer, input);\n\t\t\tassert.deepStrictEqual(deserialize(new BufferReader(writer.buffer)), input);\n\t\t});\n\t});\n\n\tsuite('one to one (proxy)', function () {\n\t\tlet server: IPCServer;\n\t\tlet client: IPCClient;\n\t\tlet service: TestService;\n\t\tlet ipcService: ITestService;\n\n\t\tconst disposables = new DisposableStore();\n\n\t\tsetup(function () {\n\t\t\tservice = store.add(new TestService());\n\t\t\tconst testServer = disposables.add(new TestIPCServer());\n\t\t\tserver = testServer;\n\n\t\t\tserver.registerChannel(TestChannelId, ProxyChannel.fromService(service, disposables));\n\n\t\t\tclient = disposables.add(testServer.createConnection('client1'));\n\t\t\tipcService = ProxyChannel.toService(client.getChannel(TestChannelId));\n\t\t});\n\n\t\tteardown(function () {\n\t\t\tdisposables.clear();\n\t\t});\n\n\t\ttest('call success', async function () {\n\t\t\tconst r = await ipcService.marco();\n\t\t\treturn assert.strictEqual(r, 'polo');\n\t\t});\n\n\t\ttest('call error', async function () {\n\t\t\ttry {\n\t\t\t\tawait ipcService.error('nice error');\n\t\t\t\treturn assert.fail('should not reach here');\n\t\t\t} catch (err) {\n\t\t\t\treturn assert.strictEqual(err.message, 'nice error');\n\t\t\t}\n\t\t});\n\n\t\ttest('listen to events', async function () {\n\t\t\tconst messages: string[] = [];\n\n\t\t\tdisposables.add(ipcService.onPong(msg => messages.push(msg)));\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, []);\n\t\t\tservice.ping('hello');\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, ['hello']);\n\t\t\tservice.ping('world');\n\t\t\tawait timeout(0);\n\n\t\t\tassert.deepStrictEqual(messages, ['hello', 'world']);\n\t\t});\n\n\t\ttest('marshalling uri', async function () {\n\t\t\tconst uri = URI.file('foobar');\n\t\t\tconst r = await ipcService.marshall(uri);\n\t\t\tassert.ok(r instanceof URI);\n\t\t\treturn assert.ok(isEqual(r, uri));\n\t\t});\n\n\t\ttest('buffers in arrays', async function () {\n\t\t\tconst r = await ipcService.buffersLength([VSBuffer.alloc(2), VSBuffer.alloc(3)]);\n\t\t\treturn assert.strictEqual(r, 5);\n\t\t});\n\t});\n\n\tsuite('one to one (proxy, extra context)', function () {\n\t\tlet server: IPCServer;\n\t\tlet client: IPCClient;\n\t\tlet service: TestService;\n\t\tlet ipcService: ITestService;\n\n\t\tconst disposables = new DisposableStore();\n\n\t\tsetup(function () {\n\t\t\tservice = store.add(new TestService());\n\t\t\tconst testServer = disposables.add(new TestIPCServer());\n\t\t\tserver = testServer;\n\n\t\t\tserver.registerChannel(TestChannelId, ProxyChannel.fromService(service, disposables));\n\n\t\t\tclient = disposables.add(testServer.createConnection('client1'));\n\t\t\tipcService = ProxyChannel.toService(client.getChannel(TestChannelId), { context: 'Super Context' });\n\t\t});\n\n\t\tteardown(function () {\n\t\t\tdisposables.clear();\n\t\t});\n\n\t\ttest('call extra context', async function () {\n\t\t\tconst r = await ipcService.context();\n\t\t\treturn assert.strictEqual(r, 'Super Context');\n\t\t});\n\t});\n\n\tsuite('one to many', function () {\n\t\ttest('all clients get pinged', async function () {\n\t\t\tconst service = store.add(new TestService());\n\t\t\tconst channel = new TestChannel(service);\n\t\t\tconst server = store.add(new TestIPCServer());\n\t\t\tserver.registerChannel('channel', channel);\n\n\t\t\tlet client1GotPinged = false;\n\t\t\tconst client1 = store.add(server.createConnection('client1'));\n\t\t\tconst ipcService1 = new TestChannelClient(client1.getChannel('channel'));\n\t\t\tstore.add(ipcService1.onPong(() => client1GotPinged = true));\n\n\t\t\tlet client2GotPinged = false;\n\t\t\tconst client2 = store.add(server.createConnection('client2'));\n\t\t\tconst ipcService2 = new TestChannelClient(client2.getChannel('channel'));\n\t\t\tstore.add(ipcService2.onPong(() => client2GotPinged = true));\n\n\t\t\tawait timeout(1);\n\t\t\tservice.ping('hello');\n\n\t\t\tawait timeout(1);\n\t\t\tassert(client1GotPinged, 'client 1 got pinged');\n\t\t\tassert(client2GotPinged, 'client 2 got pinged');\n\t\t});\n\n\t\ttest('server gets pings from all clients (broadcast channel)', async function () {\n\t\t\tconst server = store.add(new TestIPCServer());\n\n\t\t\tconst client1 = server.createConnection('client1');\n\t\t\tconst clientService1 = store.add(new TestService());\n\t\t\tconst clientChannel1 = new TestChannel(clientService1);\n\t\t\tclient1.registerChannel('channel', clientChannel1);\n\n\t\t\tconst pings: string[] = [];\n\t\t\tconst channel = server.getChannel('channel', () => true);\n\t\t\tconst service = new TestChannelClient(channel);\n\t\t\tstore.add(service.onPong(msg => pings.push(msg)));\n\n\t\t\tawait timeout(1);\n\t\t\tclientService1.ping('hello 1');\n\n\t\t\tawait timeout(1);\n\t\t\tassert.deepStrictEqual(pings, ['hello 1']);\n\n\t\t\tconst client2 = server.createConnection('client2');\n\t\t\tconst clientService2 = store.add(new TestService());\n\t\t\tconst clientChannel2 = new TestChannel(clientService2);\n\t\t\tclient2.registerChannel('channel', clientChannel2);\n\n\t\t\tawait timeout(1);\n\t\t\tclientService2.ping('hello 2');\n\n\t\t\tawait timeout(1);\n\t\t\tassert.deepStrictEqual(pings, ['hello 1', 'hello 2']);\n\n\t\t\tclient1.dispose();\n\t\t\tclientService1.ping('hello 1');\n\n\t\t\tawait timeout(1);\n\t\t\tassert.deepStrictEqual(pings, ['hello 1', 'hello 2']);\n\n\t\t\tawait timeout(1);\n\t\t\tclientService2.ping('hello again 2');\n\n\t\t\tawait timeout(1);\n\t\t\tassert.deepStrictEqual(pings, ['hello 1', 'hello 2', 'hello again 2']);\n\n\t\t\tclient2.dispose();\n\t\t});\n\t});\n});\n"]}