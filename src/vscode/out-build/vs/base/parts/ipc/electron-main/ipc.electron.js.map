{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/parts/ipc/electron-main/ipc.electron.ts","vs/base/parts/ipc/electron-main/ipc.electron.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAGhG,OAAO,EAAE,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAChD,OAAO,EAAE,QAAQ,EAAE,MAAM,2BAA2B,CAAC;AACrD,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,0BAA0B,CAAC;AAC1D,OAAO,EAAe,YAAY,EAAE,MAAM,8BAA8B,CAAC;AACzE,OAAO,EAAyB,SAAS,EAAE,MAAM,kBAAkB,CAAC;AACpE,OAAO,EAAE,QAAQ,IAAI,gBAAgB,EAAE,MAAM,2BAA2B,CAAC;AAOzE,SAAS,0BAA0B,CAAC,QAAgB,EAAE,SAAiB;IACtE,MAAM,SAAS,GAAG,KAAK,CAAC,oBAAoB,CAAY,gBAAgB,EAAE,SAAS,EAAE,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;IAC/H,MAAM,mBAAmB,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,KAAK,QAAQ,CAAC,CAAC;IAEjG,OAAO,KAAK,CAAC,GAAG,CAAC,mBAAmB,EAAE,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;AACpG,CAAC;AAED;;GAEG;AACH,MAAM,OAAO,MAAO,SAAQ,SAAS;aAEZ,YAAO,GAAG,IAAI,GAAG,EAAuB,CAAC;IAEzD,MAAM,CAAC,qBAAqB;QACnC,MAAM,OAAO,GAAG,KAAK,CAAC,oBAAoB,CAAc,gBAAgB,EAAE,cAAc,EAAE,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC;QAElH,OAAO,KAAK,CAAC,GAAG,CAAC,OAAO,EAAE,WAAW,CAAC,EAAE;YACvC,MAAM,EAAE,GAAG,WAAW,CAAC,EAAE,CAAC;YAC1B,MAAM,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;YAEtC,MAAM,EAAE,OAAO,EAAE,CAAC;YAElB,MAAM,oBAAoB,GAAG,IAAI,OAAO,EAAQ,CAAC;YACjD,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,YAAY,CAAC,GAAG,EAAE,CAAC,oBAAoB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;YAExE,MAAM,SAAS,GAAG,0BAA0B,CAAC,EAAE,EAAE,gBAAgB,CAAoB,CAAC;YACtF,MAAM,qBAAqB,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,0BAA0B,CAAC,EAAE,EAAE,mBAAmB,CAAC,CAAC,EAAE,oBAAoB,CAAC,KAAK,CAAC,CAAC;YACvI,MAAM,QAAQ,GAAG,IAAI,gBAAgB,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;YAE9D,OAAO,EAAE,QAAQ,EAAE,qBAAqB,EAAE,CAAC;QAC5C,CAAC,CAAC,CAAC;IACJ,CAAC;IAED;QACC,KAAK,CAAC,MAAM,CAAC,qBAAqB,EAAE,CAAC,CAAC;IACvC,CAAC","file":"ipc.electron.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { WebContents } from 'electron';\nimport { validatedIpcMain } from './ipcMain.js';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { IDisposable, toDisposable } from '../../../common/lifecycle.js';\nimport { ClientConnectionEvent, IPCServer } from '../common/ipc.js';\nimport { Protocol as ElectronProtocol } from '../common/ipc.electron.js';\n\ninterface IIPCEvent {\n\tevent: { sender: WebContents };\n\tmessage: Buffer | null;\n}\n\nfunction createScopedOnMessageEvent(senderId: number, eventName: string): Event<VSBuffer | null> {\n\tconst onMessage = Event.fromNodeEventEmitter<IIPCEvent>(validatedIpcMain, eventName, (event, message) => ({ event, message }));\n\tconst onMessageFromSender = Event.filter(onMessage, ({ event }) => event.sender.id === senderId);\n\n\treturn Event.map(onMessageFromSender, ({ message }) => message ? VSBuffer.wrap(message) : message);\n}\n\n/**\n * An implementation of `IPCServer` on top of Electron `ipcMain` API.\n */\nexport class Server extends IPCServer {\n\n\tprivate static readonly Clients = new Map<number, IDisposable>();\n\n\tprivate static getOnDidClientConnect(): Event<ClientConnectionEvent> {\n\t\tconst onHello = Event.fromNodeEventEmitter<WebContents>(validatedIpcMain, 'vscode:hello', ({ sender }) => sender);\n\n\t\treturn Event.map(onHello, webContents => {\n\t\t\tconst id = webContents.id;\n\t\t\tconst client = Server.Clients.get(id);\n\n\t\t\tclient?.dispose();\n\n\t\t\tconst onDidClientReconnect = new Emitter<void>();\n\t\t\tServer.Clients.set(id, toDisposable(() => onDidClientReconnect.fire()));\n\n\t\t\tconst onMessage = createScopedOnMessageEvent(id, 'vscode:message') as Event<VSBuffer>;\n\t\t\tconst onDidClientDisconnect = Event.any(Event.signal(createScopedOnMessageEvent(id, 'vscode:disconnect')), onDidClientReconnect.event);\n\t\t\tconst protocol = new ElectronProtocol(webContents, onMessage);\n\n\t\t\treturn { protocol, onDidClientDisconnect };\n\t\t});\n\t}\n\n\tconstructor() {\n\t\tsuper(Server.getOnDidClientConnect());\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { WebContents } from 'electron';\nimport { validatedIpcMain } from './ipcMain.js';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { IDisposable, toDisposable } from '../../../common/lifecycle.js';\nimport { ClientConnectionEvent, IPCServer } from '../common/ipc.js';\nimport { Protocol as ElectronProtocol } from '../common/ipc.electron.js';\n\ninterface IIPCEvent {\n\tevent: { sender: WebContents };\n\tmessage: Buffer | null;\n}\n\nfunction createScopedOnMessageEvent(senderId: number, eventName: string): Event<VSBuffer | null> {\n\tconst onMessage = Event.fromNodeEventEmitter<IIPCEvent>(validatedIpcMain, eventName, (event, message) => ({ event, message }));\n\tconst onMessageFromSender = Event.filter(onMessage, ({ event }) => event.sender.id === senderId);\n\n\treturn Event.map(onMessageFromSender, ({ message }) => message ? VSBuffer.wrap(message) : message);\n}\n\n/**\n * An implementation of `IPCServer` on top of Electron `ipcMain` API.\n */\nexport class Server extends IPCServer {\n\n\tprivate static readonly Clients = new Map<number, IDisposable>();\n\n\tprivate static getOnDidClientConnect(): Event<ClientConnectionEvent> {\n\t\tconst onHello = Event.fromNodeEventEmitter<WebContents>(validatedIpcMain, 'vscode:hello', ({ sender }) => sender);\n\n\t\treturn Event.map(onHello, webContents => {\n\t\t\tconst id = webContents.id;\n\t\t\tconst client = Server.Clients.get(id);\n\n\t\t\tclient?.dispose();\n\n\t\t\tconst onDidClientReconnect = new Emitter<void>();\n\t\t\tServer.Clients.set(id, toDisposable(() => onDidClientReconnect.fire()));\n\n\t\t\tconst onMessage = createScopedOnMessageEvent(id, 'vscode:message') as Event<VSBuffer>;\n\t\t\tconst onDidClientDisconnect = Event.any(Event.signal(createScopedOnMessageEvent(id, 'vscode:disconnect')), onDidClientReconnect.event);\n\t\t\tconst protocol = new ElectronProtocol(webContents, onMessage);\n\n\t\t\treturn { protocol, onDidClientDisconnect };\n\t\t});\n\t}\n\n\tconstructor() {\n\t\tsuper(Server.getOnDidClientConnect());\n\t}\n}\n"]}