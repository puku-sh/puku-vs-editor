{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/parts/ipc/node/ipc.mp.ts","vs/base/parts/ipc/node/ipc.mp.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAmB,gBAAgB,EAAgB,MAAM,qCAAqC,CAAC;AACtG,OAAO,EAAE,QAAQ,EAAE,MAAM,2BAA2B,CAAC;AACrD,OAAO,EAAkD,SAAS,EAAE,MAAM,kBAAkB,CAAC;AAC7F,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,0BAA0B,CAAC;AAC1D,OAAO,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAC;AAEtD;;;GAGG;AACH,MAAM,QAAQ;IAIb,YAAoB,IAAqB;QAArB,SAAI,GAAJ,IAAI,CAAiB;QACxC,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,oBAAoB,CAAW,IAAI,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC,CAAe,EAAE,EAAE;YAC/F,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC;gBACZ,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,IAAkB,CAAC,CAAC;YAC5C,CAAC;YACD,OAAO,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;QACH,sDAAsD;QACtD,IAAI,CAAC,KAAK,EAAE,CAAC;IACd,CAAC;IAED,IAAI,CAAC,OAAiB;QACrB,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IACvC,CAAC;IAED,UAAU;QACT,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;IACnB,CAAC;CACD;AAeD;;;GAGG;AACH,MAAM,OAAO,MAAO,SAAQ,SAAS;IAE5B,MAAM,CAAC,qBAAqB,CAAC,MAAgC;QACpE,UAAU,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,0BAA0B,CAAC,CAAC;QAElE,MAAM,sBAAsB,GAAG,IAAI,OAAO,EAAmB,CAAC;QAE9D,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,CAAe,EAAE,EAAE;YACpD,IAAI,MAAM,EAAE,uBAAuB,CAAC,CAAC,CAAC,EAAE,CAAC;gBACxC,OAAO;YACR,CAAC;YAED,MAAM,IAAI,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAC3B,IAAI,IAAI,EAAE,CAAC;gBACV,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACnC,CAAC;QACF,CAAC,CAAC,CAAC;QAEH,OAAO,KAAK,CAAC,GAAG,CAAC,sBAAsB,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE;YACrD,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC;YAEpC,MAAM,MAAM,GAA0B;gBACrC,QAAQ;gBACR,wEAAwE;gBACxE,oEAAoE;gBACpE,+FAA+F;gBAC/F,qBAAqB,EAAE,KAAK,CAAC,oBAAoB,CAAC,IAAI,EAAE,OAAO,CAAC;aAChE,CAAC;YAEF,OAAO,MAAM,CAAC;QACf,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,YAAY,MAAgC;QAC3C,KAAK,CAAC,MAAM,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC,CAAC;IAC7C,CAAC;CACD;AAOD,MAAM,UAAU,IAAI,CAAC,IAA8B,EAAE,OAAgB,EAAE,QAAoB;IAC1F,MAAM,QAAQ,GAAG,CAAC,CAAe,EAAE,EAAE;QACpC,IAAI,CAAC,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;YACxB,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;YACzC,QAAQ,EAAE,CAAC;QACZ,CAAC;IACF,CAAC,CAAC;IAEF,IAAI,CAAC,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;AAC9B,CAAC","file":"ipc.mp.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { MessagePortMain, isUtilityProcess, MessageEvent } from '../../sandbox/node/electronTypes.js';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { ClientConnectionEvent, IMessagePassingProtocol, IPCServer } from '../common/ipc.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { assertType } from '../../../common/types.js';\n\n/**\n * The MessagePort `Protocol` leverages MessagePortMain style IPC communication\n * for the implementation of the `IMessagePassingProtocol`.\n */\nclass Protocol implements IMessagePassingProtocol {\n\n\treadonly onMessage;\n\n\tconstructor(private port: MessagePortMain) {\n\t\tthis.onMessage = Event.fromNodeEventEmitter<VSBuffer>(this.port, 'message', (e: MessageEvent) => {\n\t\t\tif (e.data) {\n\t\t\t\treturn VSBuffer.wrap(e.data as Uint8Array);\n\t\t\t}\n\t\t\treturn VSBuffer.alloc(0);\n\t\t});\n\t\t// we must call start() to ensure messages are flowing\n\t\tport.start();\n\t}\n\n\tsend(message: VSBuffer): void {\n\t\tthis.port.postMessage(message.buffer);\n\t}\n\n\tdisconnect(): void {\n\t\tthis.port.close();\n\t}\n}\n\nexport interface IClientConnectionFilter {\n\n\t/**\n\t * Allows to filter incoming messages to the\n\t * server to handle them differently.\n\t *\n\t * @param e the message event to handle\n\t * @returns `true` if the event was handled\n\t * and should not be processed by the server.\n\t */\n\thandledClientConnection(e: MessageEvent): boolean;\n}\n\n/**\n * An implementation of a `IPCServer` on top of MessagePort style IPC communication.\n * The clients register themselves via Electron Utility Process IPC transfer.\n */\nexport class Server extends IPCServer {\n\n\tprivate static getOnDidClientConnect(filter?: IClientConnectionFilter): Event<ClientConnectionEvent> {\n\t\tassertType(isUtilityProcess(process), 'Electron Utility Process');\n\n\t\tconst onCreateMessageChannel = new Emitter<MessagePortMain>();\n\n\t\tprocess.parentPort.on('message', (e: MessageEvent) => {\n\t\t\tif (filter?.handledClientConnection(e)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst port = e.ports.at(0);\n\t\t\tif (port) {\n\t\t\t\tonCreateMessageChannel.fire(port);\n\t\t\t}\n\t\t});\n\n\t\treturn Event.map(onCreateMessageChannel.event, port => {\n\t\t\tconst protocol = new Protocol(port);\n\n\t\t\tconst result: ClientConnectionEvent = {\n\t\t\t\tprotocol,\n\t\t\t\t// Not part of the standard spec, but in Electron we get a `close` event\n\t\t\t\t// when the other side closes. We can use this to detect disconnects\n\t\t\t\t// (https://github.com/electron/electron/blob/11-x-y/docs/api/message-port-main.md#event-close)\n\t\t\t\tonDidClientDisconnect: Event.fromNodeEventEmitter(port, 'close')\n\t\t\t};\n\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tconstructor(filter?: IClientConnectionFilter) {\n\t\tsuper(Server.getOnDidClientConnect(filter));\n\t}\n}\n\ninterface INodeMessagePortFragment {\n\ton(event: 'message', listener: (messageEvent: MessageEvent) => void): this;\n\tremoveListener(event: 'message', listener: (messageEvent: MessageEvent) => void): this;\n}\n\nexport function once(port: INodeMessagePortFragment, message: unknown, callback: () => void): void {\n\tconst listener = (e: MessageEvent) => {\n\t\tif (e.data === message) {\n\t\t\tport.removeListener('message', listener);\n\t\t\tcallback();\n\t\t}\n\t};\n\n\tport.on('message', listener);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { MessagePortMain, isUtilityProcess, MessageEvent } from '../../sandbox/node/electronTypes.js';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { ClientConnectionEvent, IMessagePassingProtocol, IPCServer } from '../common/ipc.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { assertType } from '../../../common/types.js';\n\n/**\n * The MessagePort `Protocol` leverages MessagePortMain style IPC communication\n * for the implementation of the `IMessagePassingProtocol`.\n */\nclass Protocol implements IMessagePassingProtocol {\n\n\treadonly onMessage;\n\n\tconstructor(private port: MessagePortMain) {\n\t\tthis.onMessage = Event.fromNodeEventEmitter<VSBuffer>(this.port, 'message', (e: MessageEvent) => {\n\t\t\tif (e.data) {\n\t\t\t\treturn VSBuffer.wrap(e.data as Uint8Array);\n\t\t\t}\n\t\t\treturn VSBuffer.alloc(0);\n\t\t});\n\t\t// we must call start() to ensure messages are flowing\n\t\tport.start();\n\t}\n\n\tsend(message: VSBuffer): void {\n\t\tthis.port.postMessage(message.buffer);\n\t}\n\n\tdisconnect(): void {\n\t\tthis.port.close();\n\t}\n}\n\nexport interface IClientConnectionFilter {\n\n\t/**\n\t * Allows to filter incoming messages to the\n\t * server to handle them differently.\n\t *\n\t * @param e the message event to handle\n\t * @returns `true` if the event was handled\n\t * and should not be processed by the server.\n\t */\n\thandledClientConnection(e: MessageEvent): boolean;\n}\n\n/**\n * An implementation of a `IPCServer` on top of MessagePort style IPC communication.\n * The clients register themselves via Electron Utility Process IPC transfer.\n */\nexport class Server extends IPCServer {\n\n\tprivate static getOnDidClientConnect(filter?: IClientConnectionFilter): Event<ClientConnectionEvent> {\n\t\tassertType(isUtilityProcess(process), 'Electron Utility Process');\n\n\t\tconst onCreateMessageChannel = new Emitter<MessagePortMain>();\n\n\t\tprocess.parentPort.on('message', (e: MessageEvent) => {\n\t\t\tif (filter?.handledClientConnection(e)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst port = e.ports.at(0);\n\t\t\tif (port) {\n\t\t\t\tonCreateMessageChannel.fire(port);\n\t\t\t}\n\t\t});\n\n\t\treturn Event.map(onCreateMessageChannel.event, port => {\n\t\t\tconst protocol = new Protocol(port);\n\n\t\t\tconst result: ClientConnectionEvent = {\n\t\t\t\tprotocol,\n\t\t\t\t// Not part of the standard spec, but in Electron we get a `close` event\n\t\t\t\t// when the other side closes. We can use this to detect disconnects\n\t\t\t\t// (https://github.com/electron/electron/blob/11-x-y/docs/api/message-port-main.md#event-close)\n\t\t\t\tonDidClientDisconnect: Event.fromNodeEventEmitter(port, 'close')\n\t\t\t};\n\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tconstructor(filter?: IClientConnectionFilter) {\n\t\tsuper(Server.getOnDidClientConnect(filter));\n\t}\n}\n\ninterface INodeMessagePortFragment {\n\ton(event: 'message', listener: (messageEvent: MessageEvent) => void): this;\n\tremoveListener(event: 'message', listener: (messageEvent: MessageEvent) => void): this;\n}\n\nexport function once(port: INodeMessagePortFragment, message: unknown, callback: () => void): void {\n\tconst listener = (e: MessageEvent) => {\n\t\tif (e.data === message) {\n\t\t\tport.removeListener('message', listener);\n\t\t\tcallback();\n\t\t}\n\t};\n\n\tport.on('message', listener);\n}\n"]}