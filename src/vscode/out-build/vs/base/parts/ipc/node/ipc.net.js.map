{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/parts/ipc/node/ipc.net.ts","vs/base/parts/ipc/node/ipc.net.ts"],"names":[],"mappings":"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","file":"ipc.net.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createHash } from 'crypto';\nimport type * as http from 'http';\nimport { Server as NetServer, Socket, createConnection, createServer } from 'net';\nimport { tmpdir } from 'os';\nimport { DeflateRaw, InflateRaw, ZlibOptions, createDeflateRaw, createInflateRaw } from 'zlib';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Disposable, IDisposable } from '../../../common/lifecycle.js';\nimport { join } from '../../../common/path.js';\nimport { Platform, platform } from '../../../common/platform.js';\nimport { generateUuid } from '../../../common/uuid.js';\nimport { ClientConnectionEvent, IPCServer } from '../common/ipc.js';\nimport { ChunkStream, Client, ISocket, Protocol, SocketCloseEvent, SocketCloseEventType, SocketDiagnostics, SocketDiagnosticsEventType } from '../common/ipc.net.js';\n\nexport function upgradeToISocket(req: http.IncomingMessage, socket: Socket, {\n\tdebugLabel,\n\tskipWebSocketFrames = false,\n\tdisableWebSocketCompression = false,\n}: {\n\tdebugLabel: string;\n\tskipWebSocketFrames?: boolean;\n\tdisableWebSocketCompression?: boolean;\n}): NodeSocket | WebSocketNodeSocket | undefined {\n\tif (req.headers.upgrade === undefined || req.headers.upgrade.toLowerCase() !== 'websocket') {\n\t\tsocket.end('HTTP/1.1 400 Bad Request');\n\t\treturn;\n\t}\n\n\t// https://tools.ietf.org/html/rfc6455#section-4\n\tconst requestNonce = req.headers['sec-websocket-key'];\n\tconst hash = createHash('sha1');// CodeQL [SM04514] SHA1 must be used here to respect the WebSocket protocol specification\n\thash.update(requestNonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n\tconst responseNonce = hash.digest('base64');\n\n\tconst responseHeaders = [\n\t\t`HTTP/1.1 101 Switching Protocols`,\n\t\t`Upgrade: websocket`,\n\t\t`Connection: Upgrade`,\n\t\t`Sec-WebSocket-Accept: ${responseNonce}`\n\t];\n\n\t// See https://tools.ietf.org/html/rfc7692#page-12\n\tlet permessageDeflate = false;\n\tif (!skipWebSocketFrames && !disableWebSocketCompression && req.headers['sec-websocket-extensions']) {\n\t\tconst websocketExtensionOptions = Array.isArray(req.headers['sec-websocket-extensions']) ? req.headers['sec-websocket-extensions'] : [req.headers['sec-websocket-extensions']];\n\t\tfor (const websocketExtensionOption of websocketExtensionOptions) {\n\t\t\tif (/\\b((server_max_window_bits)|(server_no_context_takeover)|(client_no_context_takeover))\\b/.test(websocketExtensionOption)) {\n\t\t\t\t// sorry, the server does not support zlib parameter tweaks\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (/\\b(permessage-deflate)\\b/.test(websocketExtensionOption)) {\n\t\t\t\tpermessageDeflate = true;\n\t\t\t\tresponseHeaders.push(`Sec-WebSocket-Extensions: permessage-deflate`);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (/\\b(x-webkit-deflate-frame)\\b/.test(websocketExtensionOption)) {\n\t\t\t\tpermessageDeflate = true;\n\t\t\t\tresponseHeaders.push(`Sec-WebSocket-Extensions: x-webkit-deflate-frame`);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsocket.write(responseHeaders.join('\\r\\n') + '\\r\\n\\r\\n');\n\n\t// Never timeout this socket due to inactivity!\n\tsocket.setTimeout(0);\n\t// Disable Nagle's algorithm\n\tsocket.setNoDelay(true);\n\t// Finally!\n\n\tif (skipWebSocketFrames) {\n\t\treturn new NodeSocket(socket, debugLabel);\n\t} else {\n\t\treturn new WebSocketNodeSocket(new NodeSocket(socket, debugLabel), permessageDeflate, null, true);\n\t}\n}\n\n/**\n * Maximum time to wait for a 'close' event to fire after the socket stream\n * ends. For unix domain sockets, the close event may not fire consistently\n * due to what appears to be a Node.js bug.\n *\n * @see https://github.com/microsoft/vscode/issues/211462#issuecomment-2155471996\n */\nconst socketEndTimeoutMs = 30_000;\n\nexport class NodeSocket implements ISocket {\n\n\tpublic readonly debugLabel: string;\n\tpublic readonly socket: Socket;\n\tprivate readonly _errorListener: (err: NodeJS.ErrnoException) => void;\n\tprivate readonly _closeListener: (hadError: boolean) => void;\n\tprivate readonly _endListener: () => void;\n\tprivate _canWrite = true;\n\n\tpublic traceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | unknown): void {\n\t\tSocketDiagnostics.traceSocketEvent(this.socket, this.debugLabel, type, data);\n\t}\n\n\tconstructor(socket: Socket, debugLabel = '') {\n\t\tthis.debugLabel = debugLabel;\n\t\tthis.socket = socket;\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Created, { type: 'NodeSocket' });\n\t\tthis._errorListener = (err: NodeJS.ErrnoException) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Error, { code: err?.code, message: err?.message });\n\t\t\tif (err) {\n\t\t\t\tif (err.code === 'EPIPE') {\n\t\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tonUnexpectedError(err);\n\t\t\t}\n\t\t};\n\t\tthis.socket.on('error', this._errorListener);\n\n\t\tlet endTimeoutHandle: Timeout | undefined;\n\t\tthis._closeListener = (hadError: boolean) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Close, { hadError });\n\t\t\tthis._canWrite = false;\n\t\t\tif (endTimeoutHandle) {\n\t\t\t\tclearTimeout(endTimeoutHandle);\n\t\t\t}\n\t\t};\n\t\tthis.socket.on('close', this._closeListener);\n\n\t\tthis._endListener = () => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeEndReceived);\n\t\t\tthis._canWrite = false;\n\t\t\tendTimeoutHandle = setTimeout(() => socket.destroy(), socketEndTimeoutMs);\n\t\t};\n\t\tthis.socket.on('end', this._endListener);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.socket.off('error', this._errorListener);\n\t\tthis.socket.off('close', this._closeListener);\n\t\tthis.socket.off('end', this._endListener);\n\t\tthis.socket.destroy();\n\t}\n\n\tpublic onData(_listener: (e: VSBuffer) => void): IDisposable {\n\t\tconst listener = (buff: Buffer) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Read, buff);\n\t\t\t_listener(VSBuffer.wrap(buff));\n\t\t};\n\t\tthis.socket.on('data', listener);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('data', listener)\n\t\t};\n\t}\n\n\tpublic onClose(listener: (e: SocketCloseEvent) => void): IDisposable {\n\t\tconst adapter = (hadError: boolean) => {\n\t\t\tlistener({\n\t\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\t\thadError: hadError,\n\t\t\t\terror: undefined\n\t\t\t});\n\t\t};\n\t\tthis.socket.on('close', adapter);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('close', adapter)\n\t\t};\n\t}\n\n\tpublic onEnd(listener: () => void): IDisposable {\n\t\tconst adapter = () => {\n\t\t\tlistener();\n\t\t};\n\t\tthis.socket.on('end', adapter);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('end', adapter)\n\t\t};\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\t// return early if socket has been destroyed in the meantime\n\t\tif (this.socket.destroyed || !this._canWrite) {\n\t\t\treturn;\n\t\t}\n\n\t\t// we ignore the returned value from `write` because we would have to cached the data\n\t\t// anyways and nodejs is already doing that for us:\n\t\t// > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\n\t\t// > However, the false return value is only advisory and the writable stream will unconditionally\n\t\t// > accept and buffer chunk even if it has not been allowed to drain.\n\t\ttry {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Write, buffer);\n\t\t\tthis.socket.write(buffer.buffer, (err: NodeJS.ErrnoException | null | undefined) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === 'EPIPE') {\n\t\t\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tonUnexpectedError(err);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (err.code === 'EPIPE') {\n\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tonUnexpectedError(err);\n\t\t}\n\t}\n\n\tpublic end(): void {\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeEndSent);\n\t\tthis.socket.end();\n\t}\n\n\tpublic drain(): Promise<void> {\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainBegin);\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tif (this.socket.bufferSize === 0) {\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainEnd);\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst finished = () => {\n\t\t\t\tthis.socket.off('close', finished);\n\t\t\t\tthis.socket.off('end', finished);\n\t\t\t\tthis.socket.off('error', finished);\n\t\t\t\tthis.socket.off('timeout', finished);\n\t\t\t\tthis.socket.off('drain', finished);\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainEnd);\n\t\t\t\tresolve();\n\t\t\t};\n\t\t\tthis.socket.on('close', finished);\n\t\t\tthis.socket.on('end', finished);\n\t\t\tthis.socket.on('error', finished);\n\t\t\tthis.socket.on('timeout', finished);\n\t\t\tthis.socket.on('drain', finished);\n\t\t});\n\t}\n}\n\nconst enum Constants {\n\tMinHeaderByteSize = 2,\n\t/**\n\t * If we need to write a large buffer, we will split it into 256KB chunks and\n\t * send each chunk as a websocket message. This is to prevent that the sending\n\t * side is stuck waiting for the entire buffer to be compressed before writing\n\t * to the underlying socket or that the receiving side is stuck waiting for the\n\t * entire message to be received before processing the bytes.\n\t */\n\tMaxWebSocketMessageLength = 256 * 1024 // 256 KB\n}\n\nconst enum ReadState {\n\tPeekHeader = 1,\n\tReadHeader = 2,\n\tReadBody = 3,\n\tFin = 4\n}\n\ninterface ISocketTracer {\n\ttraceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | unknown): void;\n}\n\ninterface FrameOptions {\n\tcompressed: boolean;\n\topcode: number;\n}\n\n/**\n * See https://tools.ietf.org/html/rfc6455#section-5.2\n */\nexport class WebSocketNodeSocket extends Disposable implements ISocket, ISocketTracer {\n\n\tpublic readonly socket: NodeSocket;\n\tprivate readonly _flowManager: WebSocketFlowManager;\n\tprivate readonly _incomingData: ChunkStream;\n\tprivate readonly _onData = this._register(new Emitter<VSBuffer>());\n\tprivate readonly _onClose = this._register(new Emitter<SocketCloseEvent>());\n\tprivate _isEnded = false;\n\n\tprivate readonly _state = {\n\t\tstate: ReadState.PeekHeader,\n\t\treadLen: Constants.MinHeaderByteSize,\n\t\tfin: 0,\n\t\tcompressed: false,\n\t\tfirstFrameOfMessage: true,\n\t\tmask: 0,\n\t\topcode: 0\n\t};\n\n\tpublic get permessageDeflate(): boolean {\n\t\treturn this._flowManager.permessageDeflate;\n\t}\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\treturn this._flowManager.recordedInflateBytes;\n\t}\n\n\tpublic traceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | unknown): void {\n\t\tthis.socket.traceSocketEvent(type, data);\n\t}\n\n\t/**\n\t * Create a socket which can communicate using WebSocket frames.\n\t *\n\t * **NOTE**: When using the permessage-deflate WebSocket extension, if parts of inflating was done\n\t *  in a different zlib instance, we need to pass all those bytes into zlib, otherwise the inflate\n\t *  might hit an inflated portion referencing a distance too far back.\n\t *\n\t * @param socket The underlying socket\n\t * @param permessageDeflate Use the permessage-deflate WebSocket extension\n\t * @param inflateBytes \"Seed\" zlib inflate with these bytes.\n\t * @param recordInflateBytes Record all bytes sent to inflate\n\t */\n\tconstructor(socket: NodeSocket, permessageDeflate: boolean, inflateBytes: VSBuffer | null, recordInflateBytes: boolean) {\n\t\tsuper();\n\t\tthis.socket = socket;\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Created, { type: 'WebSocketNodeSocket', permessageDeflate, inflateBytesLength: inflateBytes?.byteLength || 0, recordInflateBytes });\n\t\tthis._flowManager = this._register(new WebSocketFlowManager(\n\t\t\tthis,\n\t\t\tpermessageDeflate,\n\t\t\tinflateBytes,\n\t\t\trecordInflateBytes,\n\t\t\tthis._onData,\n\t\t\t(data, options) => this._write(data, options)\n\t\t));\n\t\tthis._register(this._flowManager.onError((err) => {\n\t\t\t// zlib errors are fatal, since we have no idea how to recover\n\t\t\tconsole.error(err);\n\t\t\tonUnexpectedError(err);\n\t\t\tthis._onClose.fire({\n\t\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\t\thadError: true,\n\t\t\t\terror: err\n\t\t\t});\n\t\t}));\n\t\tthis._incomingData = new ChunkStream();\n\t\tthis._register(this.socket.onData(data => this._acceptChunk(data)));\n\t\tthis._register(this.socket.onClose(async (e) => {\n\t\t\t// Delay surfacing the close event until the async inflating is done\n\t\t\t// and all data has been emitted\n\t\t\tif (this._flowManager.isProcessingReadQueue()) {\n\t\t\t\tawait Event.toPromise(this._flowManager.onDidFinishProcessingReadQueue);\n\t\t\t}\n\t\t\tthis._onClose.fire(e);\n\t\t}));\n\t}\n\n\tpublic override dispose(): void {\n\t\tif (this._flowManager.isProcessingWriteQueue()) {\n\t\t\t// Wait for any outstanding writes to finish before disposing\n\t\t\tthis._register(this._flowManager.onDidFinishProcessingWriteQueue(() => {\n\t\t\t\tthis.dispose();\n\t\t\t}));\n\t\t} else {\n\t\t\tthis.socket.dispose();\n\t\t\tsuper.dispose();\n\t\t}\n\t}\n\n\tpublic onData(listener: (e: VSBuffer) => void): IDisposable {\n\t\treturn this._onData.event(listener);\n\t}\n\n\tpublic onClose(listener: (e: SocketCloseEvent) => void): IDisposable {\n\t\treturn this._onClose.event(listener);\n\t}\n\n\tpublic onEnd(listener: () => void): IDisposable {\n\t\treturn this.socket.onEnd(listener);\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\t// If we write many logical messages (let's say 1000 messages of 100KB) during a single process tick, we do\n\t\t// this thing where we install a process.nextTick timer and group all of them together and we then issue a\n\t\t// single WebSocketNodeSocket.write with a 100MB buffer.\n\t\t//\n\t\t// The first problem is that the actual writing to the underlying node socket will only happen after all of\n\t\t// the 100MB have been deflated (due to waiting on zlib flush). The second problem is on the reading side,\n\t\t// where we will get a single WebSocketNodeSocket.onData event fired when all the 100MB have arrived,\n\t\t// delaying processing the 1000 received messages until all have arrived, instead of processing them as each\n\t\t// one arrives.\n\t\t//\n\t\t// We therefore split the buffer into chunks, and issue a write for each chunk.\n\n\t\tlet start = 0;\n\t\twhile (start < buffer.byteLength) {\n\t\t\tthis._flowManager.writeMessage(buffer.slice(start, Math.min(start + Constants.MaxWebSocketMessageLength, buffer.byteLength)), { compressed: true, opcode: 0x02 /* Binary frame */ });\n\t\t\tstart += Constants.MaxWebSocketMessageLength;\n\t\t}\n\t}\n\n\tprivate _write(buffer: VSBuffer, { compressed, opcode }: FrameOptions): void {\n\t\tif (this._isEnded) {\n\t\t\t// Avoid ERR_STREAM_WRITE_AFTER_END\n\t\t\treturn;\n\t\t}\n\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketWrite, buffer);\n\t\tlet headerLen = Constants.MinHeaderByteSize;\n\t\tif (buffer.byteLength < 126) {\n\t\t\theaderLen += 0;\n\t\t} else if (buffer.byteLength < 2 ** 16) {\n\t\t\theaderLen += 2;\n\t\t} else {\n\t\t\theaderLen += 8;\n\t\t}\n\t\tconst header = VSBuffer.alloc(headerLen);\n\n\t\t// The RSV1 bit indicates a compressed frame\n\t\tconst compressedFlag = compressed ? 0b01000000 : 0;\n\t\tconst opcodeFlag = opcode & 0b00001111;\n\t\theader.writeUInt8(0b10000000 | compressedFlag | opcodeFlag, 0);\n\t\tif (buffer.byteLength < 126) {\n\t\t\theader.writeUInt8(buffer.byteLength, 1);\n\t\t} else if (buffer.byteLength < 2 ** 16) {\n\t\t\theader.writeUInt8(126, 1);\n\t\t\tlet offset = 1;\n\t\t\theader.writeUInt8((buffer.byteLength >>> 8) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 0) & 0b11111111, ++offset);\n\t\t} else {\n\t\t\theader.writeUInt8(127, 1);\n\t\t\tlet offset = 1;\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 24) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 16) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 8) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 0) & 0b11111111, ++offset);\n\t\t}\n\n\t\tthis.socket.write(VSBuffer.concat([header, buffer]));\n\t}\n\n\tpublic end(): void {\n\t\tthis._isEnded = true;\n\t\tthis.socket.end();\n\t}\n\n\tprivate _acceptChunk(data: VSBuffer): void {\n\t\tif (data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingData.acceptChunk(data);\n\n\t\twhile (this._incomingData.byteLength >= this._state.readLen) {\n\n\t\t\tif (this._state.state === ReadState.PeekHeader) {\n\t\t\t\t// peek to see if we can read the entire header\n\t\t\t\tconst peekHeader = this._incomingData.peek(this._state.readLen);\n\t\t\t\tconst firstByte = peekHeader.readUInt8(0);\n\t\t\t\tconst finBit = (firstByte & 0b10000000) >>> 7;\n\t\t\t\tconst rsv1Bit = (firstByte & 0b01000000) >>> 6;\n\t\t\t\tconst opcode = (firstByte & 0b00001111);\n\n\t\t\t\tconst secondByte = peekHeader.readUInt8(1);\n\t\t\t\tconst hasMask = (secondByte & 0b10000000) >>> 7;\n\t\t\t\tconst len = (secondByte & 0b01111111);\n\n\t\t\t\tthis._state.state = ReadState.ReadHeader;\n\t\t\t\tthis._state.readLen = Constants.MinHeaderByteSize + (hasMask ? 4 : 0) + (len === 126 ? 2 : 0) + (len === 127 ? 8 : 0);\n\t\t\t\tthis._state.fin = finBit;\n\t\t\t\tif (this._state.firstFrameOfMessage) {\n\t\t\t\t\t// if the frame is compressed, the RSV1 bit is set only for the first frame of the message\n\t\t\t\t\tthis._state.compressed = Boolean(rsv1Bit);\n\t\t\t\t}\n\t\t\t\tthis._state.firstFrameOfMessage = Boolean(finBit);\n\t\t\t\tthis._state.mask = 0;\n\t\t\t\tthis._state.opcode = opcode;\n\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketPeekedHeader, { headerSize: this._state.readLen, compressed: this._state.compressed, fin: this._state.fin, opcode: this._state.opcode });\n\n\t\t\t} else if (this._state.state === ReadState.ReadHeader) {\n\t\t\t\t// read entire header\n\t\t\t\tconst header = this._incomingData.read(this._state.readLen);\n\t\t\t\tconst secondByte = header.readUInt8(1);\n\t\t\t\tconst hasMask = (secondByte & 0b10000000) >>> 7;\n\t\t\t\tlet len = (secondByte & 0b01111111);\n\n\t\t\t\tlet offset = 1;\n\t\t\t\tif (len === 126) {\n\t\t\t\t\tlen = (\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 8\n\t\t\t\t\t\t+ header.readUInt8(++offset)\n\t\t\t\t\t);\n\t\t\t\t} else if (len === 127) {\n\t\t\t\t\tlen = (\n\t\t\t\t\t\theader.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 24\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 16\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 8\n\t\t\t\t\t\t+ header.readUInt8(++offset)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet mask = 0;\n\t\t\t\tif (hasMask) {\n\t\t\t\t\tmask = (\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 24\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 16\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 8\n\t\t\t\t\t\t+ header.readUInt8(++offset)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis._state.state = ReadState.ReadBody;\n\t\t\t\tthis._state.readLen = len;\n\t\t\t\tthis._state.mask = mask;\n\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketPeekedHeader, { bodySize: this._state.readLen, compressed: this._state.compressed, fin: this._state.fin, mask: this._state.mask, opcode: this._state.opcode });\n\n\t\t\t} else if (this._state.state === ReadState.ReadBody) {\n\t\t\t\t// read body\n\n\t\t\t\tconst body = this._incomingData.read(this._state.readLen);\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketReadData, body);\n\n\t\t\t\tunmask(body, this._state.mask);\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketUnmaskedData, body);\n\n\t\t\t\tthis._state.state = ReadState.PeekHeader;\n\t\t\t\tthis._state.readLen = Constants.MinHeaderByteSize;\n\t\t\t\tthis._state.mask = 0;\n\n\t\t\t\tif (this._state.opcode <= 0x02 /* Continuation frame or Text frame or binary frame */) {\n\t\t\t\t\tthis._flowManager.acceptFrame(body, this._state.compressed, !!this._state.fin);\n\t\t\t\t} else if (this._state.opcode === 0x09 /* Ping frame */) {\n\t\t\t\t\t// Ping frames could be send by some browsers e.g. Firefox\n\t\t\t\t\tthis._flowManager.writeMessage(body, { compressed: false, opcode: 0x0A /* Pong frame */ });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic async drain(): Promise<void> {\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketDrainBegin);\n\t\tif (this._flowManager.isProcessingWriteQueue()) {\n\t\t\tawait Event.toPromise(this._flowManager.onDidFinishProcessingWriteQueue);\n\t\t}\n\t\tawait this.socket.drain();\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketDrainEnd);\n\t}\n}\n\nclass WebSocketFlowManager extends Disposable {\n\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibInflateStream: ZlibInflateStream | null;\n\tprivate readonly _zlibDeflateStream: ZlibDeflateStream | null;\n\tprivate readonly _writeQueue: { data: VSBuffer; options: FrameOptions }[] = [];\n\tprivate readonly _readQueue: { data: VSBuffer; isCompressed: boolean; isLastFrameOfMessage: boolean }[] = [];\n\n\tprivate readonly _onDidFinishProcessingReadQueue = this._register(new Emitter<void>());\n\tpublic readonly onDidFinishProcessingReadQueue = this._onDidFinishProcessingReadQueue.event;\n\n\tprivate readonly _onDidFinishProcessingWriteQueue = this._register(new Emitter<void>());\n\tpublic readonly onDidFinishProcessingWriteQueue = this._onDidFinishProcessingWriteQueue.event;\n\n\tpublic get permessageDeflate(): boolean {\n\t\treturn Boolean(this._zlibInflateStream && this._zlibDeflateStream);\n\t}\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\tif (this._zlibInflateStream) {\n\t\t\treturn this._zlibInflateStream.recordedInflateBytes;\n\t\t}\n\t\treturn VSBuffer.alloc(0);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\tpermessageDeflate: boolean,\n\t\tinflateBytes: VSBuffer | null,\n\t\trecordInflateBytes: boolean,\n\t\tprivate readonly _onData: Emitter<VSBuffer>,\n\t\tprivate readonly _writeFn: (data: VSBuffer, options: FrameOptions) => void\n\t) {\n\t\tsuper();\n\t\tif (permessageDeflate) {\n\t\t\t// See https://tools.ietf.org/html/rfc7692#page-16\n\t\t\t// To simplify our logic, we don't negotiate the window size\n\t\t\t// and simply dedicate (2^15) / 32kb per web socket\n\t\t\tthis._zlibInflateStream = this._register(new ZlibInflateStream(this._tracer, recordInflateBytes, inflateBytes, { windowBits: 15 }));\n\t\t\tthis._zlibDeflateStream = this._register(new ZlibDeflateStream(this._tracer, { windowBits: 15 }));\n\t\t\tthis._register(this._zlibInflateStream.onError((err) => this._onError.fire(err)));\n\t\t\tthis._register(this._zlibDeflateStream.onError((err) => this._onError.fire(err)));\n\t\t} else {\n\t\t\tthis._zlibInflateStream = null;\n\t\t\tthis._zlibDeflateStream = null;\n\t\t}\n\t}\n\n\tpublic writeMessage(data: VSBuffer, options: FrameOptions): void {\n\t\tthis._writeQueue.push({ data, options });\n\t\tthis._processWriteQueue();\n\t}\n\n\tprivate _isProcessingWriteQueue = false;\n\tprivate async _processWriteQueue(): Promise<void> {\n\t\tif (this._isProcessingWriteQueue) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isProcessingWriteQueue = true;\n\t\twhile (this._writeQueue.length > 0) {\n\t\t\tconst { data, options } = this._writeQueue.shift()!;\n\t\t\tif (this._zlibDeflateStream && options.compressed) {\n\t\t\t\tconst compressedData = await this._deflateMessage(this._zlibDeflateStream, data);\n\t\t\t\tthis._writeFn(compressedData, options);\n\t\t\t} else {\n\t\t\t\tthis._writeFn(data, { ...options, compressed: false });\n\t\t\t}\n\t\t}\n\t\tthis._isProcessingWriteQueue = false;\n\t\tthis._onDidFinishProcessingWriteQueue.fire();\n\t}\n\n\tpublic isProcessingWriteQueue(): boolean {\n\t\treturn (this._isProcessingWriteQueue);\n\t}\n\n\t/**\n\t * Subsequent calls should wait for the previous `_deflateBuffer` call to complete.\n\t */\n\tprivate _deflateMessage(zlibDeflateStream: ZlibDeflateStream, buffer: VSBuffer): Promise<VSBuffer> {\n\t\treturn new Promise<VSBuffer>((resolve, reject) => {\n\t\t\tzlibDeflateStream.write(buffer);\n\t\t\tzlibDeflateStream.flush(data => resolve(data));\n\t\t});\n\t}\n\n\tpublic acceptFrame(data: VSBuffer, isCompressed: boolean, isLastFrameOfMessage: boolean): void {\n\t\tthis._readQueue.push({ data, isCompressed, isLastFrameOfMessage });\n\t\tthis._processReadQueue();\n\t}\n\n\tprivate _isProcessingReadQueue = false;\n\tprivate async _processReadQueue(): Promise<void> {\n\t\tif (this._isProcessingReadQueue) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isProcessingReadQueue = true;\n\t\twhile (this._readQueue.length > 0) {\n\t\t\tconst frameInfo = this._readQueue.shift()!;\n\t\t\tif (this._zlibInflateStream && frameInfo.isCompressed) {\n\t\t\t\t// See https://datatracker.ietf.org/doc/html/rfc7692#section-9.2\n\t\t\t\t// Even if permessageDeflate is negotiated, it is possible\n\t\t\t\t// that the other side might decide to send uncompressed messages\n\t\t\t\t// So only decompress messages that have the RSV 1 bit set\n\t\t\t\tconst data = await this._inflateFrame(this._zlibInflateStream, frameInfo.data, frameInfo.isLastFrameOfMessage);\n\t\t\t\tthis._onData.fire(data);\n\t\t\t} else {\n\t\t\t\tthis._onData.fire(frameInfo.data);\n\t\t\t}\n\t\t}\n\t\tthis._isProcessingReadQueue = false;\n\t\tthis._onDidFinishProcessingReadQueue.fire();\n\t}\n\n\tpublic isProcessingReadQueue(): boolean {\n\t\treturn (this._isProcessingReadQueue);\n\t}\n\n\t/**\n\t * Subsequent calls should wait for the previous `transformRead` call to complete.\n\t */\n\tprivate _inflateFrame(zlibInflateStream: ZlibInflateStream, buffer: VSBuffer, isLastFrameOfMessage: boolean): Promise<VSBuffer> {\n\t\treturn new Promise<VSBuffer>((resolve, reject) => {\n\t\t\t// See https://tools.ietf.org/html/rfc7692#section-7.2.2\n\t\t\tzlibInflateStream.write(buffer);\n\t\t\tif (isLastFrameOfMessage) {\n\t\t\t\tzlibInflateStream.write(VSBuffer.fromByteArray([0x00, 0x00, 0xff, 0xff]));\n\t\t\t}\n\t\t\tzlibInflateStream.flush(data => resolve(data));\n\t\t});\n\t}\n}\n\nclass ZlibInflateStream extends Disposable {\n\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibInflate: InflateRaw;\n\tprivate readonly _recordedInflateBytes: VSBuffer[] = [];\n\tprivate readonly _pendingInflateData: VSBuffer[] = [];\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\tif (this._recordInflateBytes) {\n\t\t\treturn VSBuffer.concat(this._recordedInflateBytes);\n\t\t}\n\t\treturn VSBuffer.alloc(0);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\tprivate readonly _recordInflateBytes: boolean,\n\t\tinflateBytes: VSBuffer | null,\n\t\toptions: ZlibOptions\n\t) {\n\t\tsuper();\n\t\tthis._zlibInflate = createInflateRaw(options);\n\t\tthis._zlibInflate.on('error', (err: Error) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateError, { message: err?.message, code: (err as NodeJS.ErrnoException)?.code });\n\t\t\tthis._onError.fire(err);\n\t\t});\n\t\tthis._zlibInflate.on('data', (data: Buffer) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateData, data);\n\t\t\tthis._pendingInflateData.push(VSBuffer.wrap(data));\n\t\t});\n\t\tif (inflateBytes) {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateInitialWrite, inflateBytes.buffer);\n\t\t\tthis._zlibInflate.write(inflateBytes.buffer);\n\t\t\tthis._zlibInflate.flush(() => {\n\t\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateInitialFlushFired);\n\t\t\t\tthis._pendingInflateData.length = 0;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\tif (this._recordInflateBytes) {\n\t\t\tthis._recordedInflateBytes.push(buffer.clone());\n\t\t}\n\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateWrite, buffer);\n\t\tthis._zlibInflate.write(buffer.buffer);\n\t}\n\n\tpublic flush(callback: (data: VSBuffer) => void): void {\n\t\tthis._zlibInflate.flush(() => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateFlushFired);\n\t\t\tconst data = VSBuffer.concat(this._pendingInflateData);\n\t\t\tthis._pendingInflateData.length = 0;\n\t\t\tcallback(data);\n\t\t});\n\t}\n}\n\nclass ZlibDeflateStream extends Disposable {\n\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibDeflate: DeflateRaw;\n\tprivate readonly _pendingDeflateData: VSBuffer[] = [];\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\toptions: ZlibOptions\n\t) {\n\t\tsuper();\n\n\t\tthis._zlibDeflate = createDeflateRaw({\n\t\t\twindowBits: 15\n\t\t});\n\t\tthis._zlibDeflate.on('error', (err: Error) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateError, { message: err?.message, code: (err as NodeJS.ErrnoException)?.code });\n\t\t\tthis._onError.fire(err);\n\t\t});\n\t\tthis._zlibDeflate.on('data', (data: Buffer) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateData, data);\n\t\t\tthis._pendingDeflateData.push(VSBuffer.wrap(data));\n\t\t});\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateWrite, buffer.buffer);\n\t\tthis._zlibDeflate.write(<Buffer>buffer.buffer);\n\t}\n\n\tpublic flush(callback: (data: VSBuffer) => void): void {\n\t\t// See https://zlib.net/manual.html#Constants\n\t\tthis._zlibDeflate.flush(/*Z_SYNC_FLUSH*/2, () => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateFlushFired);\n\n\t\t\tlet data = VSBuffer.concat(this._pendingDeflateData);\n\t\t\tthis._pendingDeflateData.length = 0;\n\n\t\t\t// See https://tools.ietf.org/html/rfc7692#section-7.2.1\n\t\t\tdata = data.slice(0, data.byteLength - 4);\n\n\t\t\tcallback(data);\n\t\t});\n\t}\n}\n\nfunction unmask(buffer: VSBuffer, mask: number): void {\n\tif (mask === 0) {\n\t\treturn;\n\t}\n\tconst cnt = buffer.byteLength >>> 2;\n\tfor (let i = 0; i < cnt; i++) {\n\t\tconst v = buffer.readUInt32BE(i * 4);\n\t\tbuffer.writeUInt32BE(v ^ mask, i * 4);\n\t}\n\tconst offset = cnt * 4;\n\tconst bytesLeft = buffer.byteLength - offset;\n\tconst m3 = (mask >>> 24) & 0b11111111;\n\tconst m2 = (mask >>> 16) & 0b11111111;\n\tconst m1 = (mask >>> 8) & 0b11111111;\n\tif (bytesLeft >= 1) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset) ^ m3, offset);\n\t}\n\tif (bytesLeft >= 2) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset + 1) ^ m2, offset + 1);\n\t}\n\tif (bytesLeft >= 3) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset + 2) ^ m1, offset + 2);\n\t}\n}\n\n// Read this before there's any chance it is overwritten\n// Related to https://github.com/microsoft/vscode/issues/30624\nexport const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];\n\nconst safeIpcPathLengths: { [platform: number]: number } = {\n\t[Platform.Linux]: 107,\n\t[Platform.Mac]: 103\n};\n\nexport function createRandomIPCHandle(): string {\n\tconst randomSuffix = generateUuid();\n\n\t// Windows: use named pipe\n\tif (process.platform === 'win32') {\n\t\treturn `\\\\\\\\.\\\\pipe\\\\vscode-ipc-${randomSuffix}-sock`;\n\t}\n\n\t// Mac & Unix: Use socket file\n\t// Unix: Prefer XDG_RUNTIME_DIR over user data path\n\tconst basePath = process.platform !== 'darwin' && XDG_RUNTIME_DIR ? XDG_RUNTIME_DIR : tmpdir();\n\tconst result = join(basePath, `vscode-ipc-${randomSuffix}.sock`);\n\n\t// Validate length\n\tvalidateIPCHandleLength(result);\n\n\treturn result;\n}\n\nexport function createStaticIPCHandle(directoryPath: string, type: string, version: string): string {\n\tconst scope = createHash('sha256').update(directoryPath).digest('hex');\n\tconst scopeForSocket = scope.substr(0, 8);\n\n\t// Windows: use named pipe\n\tif (process.platform === 'win32') {\n\t\treturn `\\\\\\\\.\\\\pipe\\\\${scopeForSocket}-${version}-${type}-sock`;\n\t}\n\n\t// Mac & Unix: Use socket file\n\t// Unix: Prefer XDG_RUNTIME_DIR over user data path, unless portable\n\t// Trim the version and type values for the socket to prevent too large\n\t// file names causing issues: https://unix.stackexchange.com/q/367008\n\n\tconst versionForSocket = version.substr(0, 4);\n\tconst typeForSocket = type.substr(0, 6);\n\n\tlet result: string;\n\tif (process.platform !== 'darwin' && XDG_RUNTIME_DIR && !process.env['VSCODE_PORTABLE']) {\n\t\tresult = join(XDG_RUNTIME_DIR, `vscode-${scopeForSocket}-${versionForSocket}-${typeForSocket}.sock`);\n\t} else {\n\t\tresult = join(directoryPath, `${versionForSocket}-${typeForSocket}.sock`);\n\t}\n\n\t// Validate length\n\tvalidateIPCHandleLength(result);\n\n\treturn result;\n}\n\nfunction validateIPCHandleLength(handle: string): void {\n\tconst limit = safeIpcPathLengths[platform];\n\tif (typeof limit === 'number' && handle.length >= limit) {\n\t\t// https://nodejs.org/api/net.html#net_identifying_paths_for_ipc_connections\n\t\tconsole.warn(`WARNING: IPC handle \"${handle}\" is longer than ${limit} chars, try a shorter --user-data-dir`);\n\t}\n}\n\nexport class Server extends IPCServer {\n\n\tprivate static toClientConnectionEvent(server: NetServer): Event<ClientConnectionEvent> {\n\t\tconst onConnection = Event.fromNodeEventEmitter<Socket>(server, 'connection');\n\n\t\treturn Event.map(onConnection, socket => ({\n\t\t\tprotocol: new Protocol(new NodeSocket(socket, 'ipc-server-connection')),\n\t\t\tonDidClientDisconnect: Event.once(Event.fromNodeEventEmitter<void>(socket, 'close'))\n\t\t}));\n\t}\n\n\tprivate server: NetServer | null;\n\n\tconstructor(server: NetServer) {\n\t\tsuper(Server.toClientConnectionEvent(server));\n\t\tthis.server = server;\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tif (this.server) {\n\t\t\tthis.server.close();\n\t\t\tthis.server = null;\n\t\t}\n\t}\n}\n\nexport function serve(port: number): Promise<Server>;\nexport function serve(namedPipe: string): Promise<Server>;\nexport function serve(hook: number | string): Promise<Server> {\n\treturn new Promise<Server>((resolve, reject) => {\n\t\tconst server = createServer();\n\n\t\tserver.on('error', reject);\n\t\tserver.listen(hook, () => {\n\t\t\tserver.removeListener('error', reject);\n\t\t\tresolve(new Server(server));\n\t\t});\n\t});\n}\n\nexport function connect(options: { host: string; port: number }, clientId: string): Promise<Client>;\nexport function connect(namedPipe: string, clientId: string): Promise<Client>;\nexport function connect(hook: { host: string; port: number } | string, clientId: string): Promise<Client> {\n\treturn new Promise<Client>((resolve, reject) => {\n\t\tlet socket: Socket;\n\n\t\tconst callbackHandler = () => {\n\t\t\tsocket.removeListener('error', reject);\n\t\t\tresolve(Client.fromSocket(new NodeSocket(socket, `ipc-client${clientId}`), clientId));\n\t\t};\n\n\t\tif (typeof hook === 'string') {\n\t\t\tsocket = createConnection(hook, callbackHandler);\n\t\t} else {\n\t\t\tsocket = createConnection(hook, callbackHandler);\n\t\t}\n\n\t\tsocket.once('error', reject);\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createHash } from 'crypto';\nimport type * as http from 'http';\nimport { Server as NetServer, Socket, createConnection, createServer } from 'net';\nimport { tmpdir } from 'os';\nimport { DeflateRaw, InflateRaw, ZlibOptions, createDeflateRaw, createInflateRaw } from 'zlib';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Disposable, IDisposable } from '../../../common/lifecycle.js';\nimport { join } from '../../../common/path.js';\nimport { Platform, platform } from '../../../common/platform.js';\nimport { generateUuid } from '../../../common/uuid.js';\nimport { ClientConnectionEvent, IPCServer } from '../common/ipc.js';\nimport { ChunkStream, Client, ISocket, Protocol, SocketCloseEvent, SocketCloseEventType, SocketDiagnostics, SocketDiagnosticsEventType } from '../common/ipc.net.js';\n\nexport function upgradeToISocket(req: http.IncomingMessage, socket: Socket, {\n\tdebugLabel,\n\tskipWebSocketFrames = false,\n\tdisableWebSocketCompression = false,\n}: {\n\tdebugLabel: string;\n\tskipWebSocketFrames?: boolean;\n\tdisableWebSocketCompression?: boolean;\n}): NodeSocket | WebSocketNodeSocket | undefined {\n\tif (req.headers.upgrade === undefined || req.headers.upgrade.toLowerCase() !== 'websocket') {\n\t\tsocket.end('HTTP/1.1 400 Bad Request');\n\t\treturn;\n\t}\n\n\t// https://tools.ietf.org/html/rfc6455#section-4\n\tconst requestNonce = req.headers['sec-websocket-key'];\n\tconst hash = createHash('sha1');// CodeQL [SM04514] SHA1 must be used here to respect the WebSocket protocol specification\n\thash.update(requestNonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n\tconst responseNonce = hash.digest('base64');\n\n\tconst responseHeaders = [\n\t\t`HTTP/1.1 101 Switching Protocols`,\n\t\t`Upgrade: websocket`,\n\t\t`Connection: Upgrade`,\n\t\t`Sec-WebSocket-Accept: ${responseNonce}`\n\t];\n\n\t// See https://tools.ietf.org/html/rfc7692#page-12\n\tlet permessageDeflate = false;\n\tif (!skipWebSocketFrames && !disableWebSocketCompression && req.headers['sec-websocket-extensions']) {\n\t\tconst websocketExtensionOptions = Array.isArray(req.headers['sec-websocket-extensions']) ? req.headers['sec-websocket-extensions'] : [req.headers['sec-websocket-extensions']];\n\t\tfor (const websocketExtensionOption of websocketExtensionOptions) {\n\t\t\tif (/\\b((server_max_window_bits)|(server_no_context_takeover)|(client_no_context_takeover))\\b/.test(websocketExtensionOption)) {\n\t\t\t\t// sorry, the server does not support zlib parameter tweaks\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (/\\b(permessage-deflate)\\b/.test(websocketExtensionOption)) {\n\t\t\t\tpermessageDeflate = true;\n\t\t\t\tresponseHeaders.push(`Sec-WebSocket-Extensions: permessage-deflate`);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (/\\b(x-webkit-deflate-frame)\\b/.test(websocketExtensionOption)) {\n\t\t\t\tpermessageDeflate = true;\n\t\t\t\tresponseHeaders.push(`Sec-WebSocket-Extensions: x-webkit-deflate-frame`);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsocket.write(responseHeaders.join('\\r\\n') + '\\r\\n\\r\\n');\n\n\t// Never timeout this socket due to inactivity!\n\tsocket.setTimeout(0);\n\t// Disable Nagle's algorithm\n\tsocket.setNoDelay(true);\n\t// Finally!\n\n\tif (skipWebSocketFrames) {\n\t\treturn new NodeSocket(socket, debugLabel);\n\t} else {\n\t\treturn new WebSocketNodeSocket(new NodeSocket(socket, debugLabel), permessageDeflate, null, true);\n\t}\n}\n\n/**\n * Maximum time to wait for a 'close' event to fire after the socket stream\n * ends. For unix domain sockets, the close event may not fire consistently\n * due to what appears to be a Node.js bug.\n *\n * @see https://github.com/microsoft/vscode/issues/211462#issuecomment-2155471996\n */\nconst socketEndTimeoutMs = 30_000;\n\nexport class NodeSocket implements ISocket {\n\n\tpublic readonly debugLabel: string;\n\tpublic readonly socket: Socket;\n\tprivate readonly _errorListener: (err: NodeJS.ErrnoException) => void;\n\tprivate readonly _closeListener: (hadError: boolean) => void;\n\tprivate readonly _endListener: () => void;\n\tprivate _canWrite = true;\n\n\tpublic traceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | unknown): void {\n\t\tSocketDiagnostics.traceSocketEvent(this.socket, this.debugLabel, type, data);\n\t}\n\n\tconstructor(socket: Socket, debugLabel = '') {\n\t\tthis.debugLabel = debugLabel;\n\t\tthis.socket = socket;\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Created, { type: 'NodeSocket' });\n\t\tthis._errorListener = (err: NodeJS.ErrnoException) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Error, { code: err?.code, message: err?.message });\n\t\t\tif (err) {\n\t\t\t\tif (err.code === 'EPIPE') {\n\t\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tonUnexpectedError(err);\n\t\t\t}\n\t\t};\n\t\tthis.socket.on('error', this._errorListener);\n\n\t\tlet endTimeoutHandle: Timeout | undefined;\n\t\tthis._closeListener = (hadError: boolean) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Close, { hadError });\n\t\t\tthis._canWrite = false;\n\t\t\tif (endTimeoutHandle) {\n\t\t\t\tclearTimeout(endTimeoutHandle);\n\t\t\t}\n\t\t};\n\t\tthis.socket.on('close', this._closeListener);\n\n\t\tthis._endListener = () => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeEndReceived);\n\t\t\tthis._canWrite = false;\n\t\t\tendTimeoutHandle = setTimeout(() => socket.destroy(), socketEndTimeoutMs);\n\t\t};\n\t\tthis.socket.on('end', this._endListener);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.socket.off('error', this._errorListener);\n\t\tthis.socket.off('close', this._closeListener);\n\t\tthis.socket.off('end', this._endListener);\n\t\tthis.socket.destroy();\n\t}\n\n\tpublic onData(_listener: (e: VSBuffer) => void): IDisposable {\n\t\tconst listener = (buff: Buffer) => {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Read, buff);\n\t\t\t_listener(VSBuffer.wrap(buff));\n\t\t};\n\t\tthis.socket.on('data', listener);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('data', listener)\n\t\t};\n\t}\n\n\tpublic onClose(listener: (e: SocketCloseEvent) => void): IDisposable {\n\t\tconst adapter = (hadError: boolean) => {\n\t\t\tlistener({\n\t\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\t\thadError: hadError,\n\t\t\t\terror: undefined\n\t\t\t});\n\t\t};\n\t\tthis.socket.on('close', adapter);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('close', adapter)\n\t\t};\n\t}\n\n\tpublic onEnd(listener: () => void): IDisposable {\n\t\tconst adapter = () => {\n\t\t\tlistener();\n\t\t};\n\t\tthis.socket.on('end', adapter);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('end', adapter)\n\t\t};\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\t// return early if socket has been destroyed in the meantime\n\t\tif (this.socket.destroyed || !this._canWrite) {\n\t\t\treturn;\n\t\t}\n\n\t\t// we ignore the returned value from `write` because we would have to cached the data\n\t\t// anyways and nodejs is already doing that for us:\n\t\t// > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\n\t\t// > However, the false return value is only advisory and the writable stream will unconditionally\n\t\t// > accept and buffer chunk even if it has not been allowed to drain.\n\t\ttry {\n\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Write, buffer);\n\t\t\tthis.socket.write(buffer.buffer, (err: NodeJS.ErrnoException | null | undefined) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === 'EPIPE') {\n\t\t\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tonUnexpectedError(err);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (err.code === 'EPIPE') {\n\t\t\t\t// An EPIPE exception at the wrong time can lead to a renderer process crash\n\t\t\t\t// so ignore the error since the socket will fire the close event soon anyways:\n\t\t\t\t// > https://nodejs.org/api/errors.html#errors_common_system_errors\n\t\t\t\t// > EPIPE (Broken pipe): A write on a pipe, socket, or FIFO for which there is no\n\t\t\t\t// > process to read the data. Commonly encountered at the net and http layers,\n\t\t\t\t// > indicative that the remote side of the stream being written to has been closed.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tonUnexpectedError(err);\n\t\t}\n\t}\n\n\tpublic end(): void {\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeEndSent);\n\t\tthis.socket.end();\n\t}\n\n\tpublic drain(): Promise<void> {\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainBegin);\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tif (this.socket.bufferSize === 0) {\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainEnd);\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst finished = () => {\n\t\t\t\tthis.socket.off('close', finished);\n\t\t\t\tthis.socket.off('end', finished);\n\t\t\t\tthis.socket.off('error', finished);\n\t\t\t\tthis.socket.off('timeout', finished);\n\t\t\t\tthis.socket.off('drain', finished);\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.NodeDrainEnd);\n\t\t\t\tresolve();\n\t\t\t};\n\t\t\tthis.socket.on('close', finished);\n\t\t\tthis.socket.on('end', finished);\n\t\t\tthis.socket.on('error', finished);\n\t\t\tthis.socket.on('timeout', finished);\n\t\t\tthis.socket.on('drain', finished);\n\t\t});\n\t}\n}\n\nconst enum Constants {\n\tMinHeaderByteSize = 2,\n\t/**\n\t * If we need to write a large buffer, we will split it into 256KB chunks and\n\t * send each chunk as a websocket message. This is to prevent that the sending\n\t * side is stuck waiting for the entire buffer to be compressed before writing\n\t * to the underlying socket or that the receiving side is stuck waiting for the\n\t * entire message to be received before processing the bytes.\n\t */\n\tMaxWebSocketMessageLength = 256 * 1024 // 256 KB\n}\n\nconst enum ReadState {\n\tPeekHeader = 1,\n\tReadHeader = 2,\n\tReadBody = 3,\n\tFin = 4\n}\n\ninterface ISocketTracer {\n\ttraceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | unknown): void;\n}\n\ninterface FrameOptions {\n\tcompressed: boolean;\n\topcode: number;\n}\n\n/**\n * See https://tools.ietf.org/html/rfc6455#section-5.2\n */\nexport class WebSocketNodeSocket extends Disposable implements ISocket, ISocketTracer {\n\n\tpublic readonly socket: NodeSocket;\n\tprivate readonly _flowManager: WebSocketFlowManager;\n\tprivate readonly _incomingData: ChunkStream;\n\tprivate readonly _onData = this._register(new Emitter<VSBuffer>());\n\tprivate readonly _onClose = this._register(new Emitter<SocketCloseEvent>());\n\tprivate _isEnded = false;\n\n\tprivate readonly _state = {\n\t\tstate: ReadState.PeekHeader,\n\t\treadLen: Constants.MinHeaderByteSize,\n\t\tfin: 0,\n\t\tcompressed: false,\n\t\tfirstFrameOfMessage: true,\n\t\tmask: 0,\n\t\topcode: 0\n\t};\n\n\tpublic get permessageDeflate(): boolean {\n\t\treturn this._flowManager.permessageDeflate;\n\t}\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\treturn this._flowManager.recordedInflateBytes;\n\t}\n\n\tpublic traceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | unknown): void {\n\t\tthis.socket.traceSocketEvent(type, data);\n\t}\n\n\t/**\n\t * Create a socket which can communicate using WebSocket frames.\n\t *\n\t * **NOTE**: When using the permessage-deflate WebSocket extension, if parts of inflating was done\n\t *  in a different zlib instance, we need to pass all those bytes into zlib, otherwise the inflate\n\t *  might hit an inflated portion referencing a distance too far back.\n\t *\n\t * @param socket The underlying socket\n\t * @param permessageDeflate Use the permessage-deflate WebSocket extension\n\t * @param inflateBytes \"Seed\" zlib inflate with these bytes.\n\t * @param recordInflateBytes Record all bytes sent to inflate\n\t */\n\tconstructor(socket: NodeSocket, permessageDeflate: boolean, inflateBytes: VSBuffer | null, recordInflateBytes: boolean) {\n\t\tsuper();\n\t\tthis.socket = socket;\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.Created, { type: 'WebSocketNodeSocket', permessageDeflate, inflateBytesLength: inflateBytes?.byteLength || 0, recordInflateBytes });\n\t\tthis._flowManager = this._register(new WebSocketFlowManager(\n\t\t\tthis,\n\t\t\tpermessageDeflate,\n\t\t\tinflateBytes,\n\t\t\trecordInflateBytes,\n\t\t\tthis._onData,\n\t\t\t(data, options) => this._write(data, options)\n\t\t));\n\t\tthis._register(this._flowManager.onError((err) => {\n\t\t\t// zlib errors are fatal, since we have no idea how to recover\n\t\t\tconsole.error(err);\n\t\t\tonUnexpectedError(err);\n\t\t\tthis._onClose.fire({\n\t\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\t\thadError: true,\n\t\t\t\terror: err\n\t\t\t});\n\t\t}));\n\t\tthis._incomingData = new ChunkStream();\n\t\tthis._register(this.socket.onData(data => this._acceptChunk(data)));\n\t\tthis._register(this.socket.onClose(async (e) => {\n\t\t\t// Delay surfacing the close event until the async inflating is done\n\t\t\t// and all data has been emitted\n\t\t\tif (this._flowManager.isProcessingReadQueue()) {\n\t\t\t\tawait Event.toPromise(this._flowManager.onDidFinishProcessingReadQueue);\n\t\t\t}\n\t\t\tthis._onClose.fire(e);\n\t\t}));\n\t}\n\n\tpublic override dispose(): void {\n\t\tif (this._flowManager.isProcessingWriteQueue()) {\n\t\t\t// Wait for any outstanding writes to finish before disposing\n\t\t\tthis._register(this._flowManager.onDidFinishProcessingWriteQueue(() => {\n\t\t\t\tthis.dispose();\n\t\t\t}));\n\t\t} else {\n\t\t\tthis.socket.dispose();\n\t\t\tsuper.dispose();\n\t\t}\n\t}\n\n\tpublic onData(listener: (e: VSBuffer) => void): IDisposable {\n\t\treturn this._onData.event(listener);\n\t}\n\n\tpublic onClose(listener: (e: SocketCloseEvent) => void): IDisposable {\n\t\treturn this._onClose.event(listener);\n\t}\n\n\tpublic onEnd(listener: () => void): IDisposable {\n\t\treturn this.socket.onEnd(listener);\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\t// If we write many logical messages (let's say 1000 messages of 100KB) during a single process tick, we do\n\t\t// this thing where we install a process.nextTick timer and group all of them together and we then issue a\n\t\t// single WebSocketNodeSocket.write with a 100MB buffer.\n\t\t//\n\t\t// The first problem is that the actual writing to the underlying node socket will only happen after all of\n\t\t// the 100MB have been deflated (due to waiting on zlib flush). The second problem is on the reading side,\n\t\t// where we will get a single WebSocketNodeSocket.onData event fired when all the 100MB have arrived,\n\t\t// delaying processing the 1000 received messages until all have arrived, instead of processing them as each\n\t\t// one arrives.\n\t\t//\n\t\t// We therefore split the buffer into chunks, and issue a write for each chunk.\n\n\t\tlet start = 0;\n\t\twhile (start < buffer.byteLength) {\n\t\t\tthis._flowManager.writeMessage(buffer.slice(start, Math.min(start + Constants.MaxWebSocketMessageLength, buffer.byteLength)), { compressed: true, opcode: 0x02 /* Binary frame */ });\n\t\t\tstart += Constants.MaxWebSocketMessageLength;\n\t\t}\n\t}\n\n\tprivate _write(buffer: VSBuffer, { compressed, opcode }: FrameOptions): void {\n\t\tif (this._isEnded) {\n\t\t\t// Avoid ERR_STREAM_WRITE_AFTER_END\n\t\t\treturn;\n\t\t}\n\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketWrite, buffer);\n\t\tlet headerLen = Constants.MinHeaderByteSize;\n\t\tif (buffer.byteLength < 126) {\n\t\t\theaderLen += 0;\n\t\t} else if (buffer.byteLength < 2 ** 16) {\n\t\t\theaderLen += 2;\n\t\t} else {\n\t\t\theaderLen += 8;\n\t\t}\n\t\tconst header = VSBuffer.alloc(headerLen);\n\n\t\t// The RSV1 bit indicates a compressed frame\n\t\tconst compressedFlag = compressed ? 0b01000000 : 0;\n\t\tconst opcodeFlag = opcode & 0b00001111;\n\t\theader.writeUInt8(0b10000000 | compressedFlag | opcodeFlag, 0);\n\t\tif (buffer.byteLength < 126) {\n\t\t\theader.writeUInt8(buffer.byteLength, 1);\n\t\t} else if (buffer.byteLength < 2 ** 16) {\n\t\t\theader.writeUInt8(126, 1);\n\t\t\tlet offset = 1;\n\t\t\theader.writeUInt8((buffer.byteLength >>> 8) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 0) & 0b11111111, ++offset);\n\t\t} else {\n\t\t\theader.writeUInt8(127, 1);\n\t\t\tlet offset = 1;\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8(0, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 24) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 16) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 8) & 0b11111111, ++offset);\n\t\t\theader.writeUInt8((buffer.byteLength >>> 0) & 0b11111111, ++offset);\n\t\t}\n\n\t\tthis.socket.write(VSBuffer.concat([header, buffer]));\n\t}\n\n\tpublic end(): void {\n\t\tthis._isEnded = true;\n\t\tthis.socket.end();\n\t}\n\n\tprivate _acceptChunk(data: VSBuffer): void {\n\t\tif (data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingData.acceptChunk(data);\n\n\t\twhile (this._incomingData.byteLength >= this._state.readLen) {\n\n\t\t\tif (this._state.state === ReadState.PeekHeader) {\n\t\t\t\t// peek to see if we can read the entire header\n\t\t\t\tconst peekHeader = this._incomingData.peek(this._state.readLen);\n\t\t\t\tconst firstByte = peekHeader.readUInt8(0);\n\t\t\t\tconst finBit = (firstByte & 0b10000000) >>> 7;\n\t\t\t\tconst rsv1Bit = (firstByte & 0b01000000) >>> 6;\n\t\t\t\tconst opcode = (firstByte & 0b00001111);\n\n\t\t\t\tconst secondByte = peekHeader.readUInt8(1);\n\t\t\t\tconst hasMask = (secondByte & 0b10000000) >>> 7;\n\t\t\t\tconst len = (secondByte & 0b01111111);\n\n\t\t\t\tthis._state.state = ReadState.ReadHeader;\n\t\t\t\tthis._state.readLen = Constants.MinHeaderByteSize + (hasMask ? 4 : 0) + (len === 126 ? 2 : 0) + (len === 127 ? 8 : 0);\n\t\t\t\tthis._state.fin = finBit;\n\t\t\t\tif (this._state.firstFrameOfMessage) {\n\t\t\t\t\t// if the frame is compressed, the RSV1 bit is set only for the first frame of the message\n\t\t\t\t\tthis._state.compressed = Boolean(rsv1Bit);\n\t\t\t\t}\n\t\t\t\tthis._state.firstFrameOfMessage = Boolean(finBit);\n\t\t\t\tthis._state.mask = 0;\n\t\t\t\tthis._state.opcode = opcode;\n\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketPeekedHeader, { headerSize: this._state.readLen, compressed: this._state.compressed, fin: this._state.fin, opcode: this._state.opcode });\n\n\t\t\t} else if (this._state.state === ReadState.ReadHeader) {\n\t\t\t\t// read entire header\n\t\t\t\tconst header = this._incomingData.read(this._state.readLen);\n\t\t\t\tconst secondByte = header.readUInt8(1);\n\t\t\t\tconst hasMask = (secondByte & 0b10000000) >>> 7;\n\t\t\t\tlet len = (secondByte & 0b01111111);\n\n\t\t\t\tlet offset = 1;\n\t\t\t\tif (len === 126) {\n\t\t\t\t\tlen = (\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 8\n\t\t\t\t\t\t+ header.readUInt8(++offset)\n\t\t\t\t\t);\n\t\t\t\t} else if (len === 127) {\n\t\t\t\t\tlen = (\n\t\t\t\t\t\theader.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 0\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 24\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 16\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 8\n\t\t\t\t\t\t+ header.readUInt8(++offset)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet mask = 0;\n\t\t\t\tif (hasMask) {\n\t\t\t\t\tmask = (\n\t\t\t\t\t\theader.readUInt8(++offset) * 2 ** 24\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 16\n\t\t\t\t\t\t+ header.readUInt8(++offset) * 2 ** 8\n\t\t\t\t\t\t+ header.readUInt8(++offset)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis._state.state = ReadState.ReadBody;\n\t\t\t\tthis._state.readLen = len;\n\t\t\t\tthis._state.mask = mask;\n\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketPeekedHeader, { bodySize: this._state.readLen, compressed: this._state.compressed, fin: this._state.fin, mask: this._state.mask, opcode: this._state.opcode });\n\n\t\t\t} else if (this._state.state === ReadState.ReadBody) {\n\t\t\t\t// read body\n\n\t\t\t\tconst body = this._incomingData.read(this._state.readLen);\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketReadData, body);\n\n\t\t\t\tunmask(body, this._state.mask);\n\t\t\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketUnmaskedData, body);\n\n\t\t\t\tthis._state.state = ReadState.PeekHeader;\n\t\t\t\tthis._state.readLen = Constants.MinHeaderByteSize;\n\t\t\t\tthis._state.mask = 0;\n\n\t\t\t\tif (this._state.opcode <= 0x02 /* Continuation frame or Text frame or binary frame */) {\n\t\t\t\t\tthis._flowManager.acceptFrame(body, this._state.compressed, !!this._state.fin);\n\t\t\t\t} else if (this._state.opcode === 0x09 /* Ping frame */) {\n\t\t\t\t\t// Ping frames could be send by some browsers e.g. Firefox\n\t\t\t\t\tthis._flowManager.writeMessage(body, { compressed: false, opcode: 0x0A /* Pong frame */ });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic async drain(): Promise<void> {\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketDrainBegin);\n\t\tif (this._flowManager.isProcessingWriteQueue()) {\n\t\t\tawait Event.toPromise(this._flowManager.onDidFinishProcessingWriteQueue);\n\t\t}\n\t\tawait this.socket.drain();\n\t\tthis.traceSocketEvent(SocketDiagnosticsEventType.WebSocketNodeSocketDrainEnd);\n\t}\n}\n\nclass WebSocketFlowManager extends Disposable {\n\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibInflateStream: ZlibInflateStream | null;\n\tprivate readonly _zlibDeflateStream: ZlibDeflateStream | null;\n\tprivate readonly _writeQueue: { data: VSBuffer; options: FrameOptions }[] = [];\n\tprivate readonly _readQueue: { data: VSBuffer; isCompressed: boolean; isLastFrameOfMessage: boolean }[] = [];\n\n\tprivate readonly _onDidFinishProcessingReadQueue = this._register(new Emitter<void>());\n\tpublic readonly onDidFinishProcessingReadQueue = this._onDidFinishProcessingReadQueue.event;\n\n\tprivate readonly _onDidFinishProcessingWriteQueue = this._register(new Emitter<void>());\n\tpublic readonly onDidFinishProcessingWriteQueue = this._onDidFinishProcessingWriteQueue.event;\n\n\tpublic get permessageDeflate(): boolean {\n\t\treturn Boolean(this._zlibInflateStream && this._zlibDeflateStream);\n\t}\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\tif (this._zlibInflateStream) {\n\t\t\treturn this._zlibInflateStream.recordedInflateBytes;\n\t\t}\n\t\treturn VSBuffer.alloc(0);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\tpermessageDeflate: boolean,\n\t\tinflateBytes: VSBuffer | null,\n\t\trecordInflateBytes: boolean,\n\t\tprivate readonly _onData: Emitter<VSBuffer>,\n\t\tprivate readonly _writeFn: (data: VSBuffer, options: FrameOptions) => void\n\t) {\n\t\tsuper();\n\t\tif (permessageDeflate) {\n\t\t\t// See https://tools.ietf.org/html/rfc7692#page-16\n\t\t\t// To simplify our logic, we don't negotiate the window size\n\t\t\t// and simply dedicate (2^15) / 32kb per web socket\n\t\t\tthis._zlibInflateStream = this._register(new ZlibInflateStream(this._tracer, recordInflateBytes, inflateBytes, { windowBits: 15 }));\n\t\t\tthis._zlibDeflateStream = this._register(new ZlibDeflateStream(this._tracer, { windowBits: 15 }));\n\t\t\tthis._register(this._zlibInflateStream.onError((err) => this._onError.fire(err)));\n\t\t\tthis._register(this._zlibDeflateStream.onError((err) => this._onError.fire(err)));\n\t\t} else {\n\t\t\tthis._zlibInflateStream = null;\n\t\t\tthis._zlibDeflateStream = null;\n\t\t}\n\t}\n\n\tpublic writeMessage(data: VSBuffer, options: FrameOptions): void {\n\t\tthis._writeQueue.push({ data, options });\n\t\tthis._processWriteQueue();\n\t}\n\n\tprivate _isProcessingWriteQueue = false;\n\tprivate async _processWriteQueue(): Promise<void> {\n\t\tif (this._isProcessingWriteQueue) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isProcessingWriteQueue = true;\n\t\twhile (this._writeQueue.length > 0) {\n\t\t\tconst { data, options } = this._writeQueue.shift()!;\n\t\t\tif (this._zlibDeflateStream && options.compressed) {\n\t\t\t\tconst compressedData = await this._deflateMessage(this._zlibDeflateStream, data);\n\t\t\t\tthis._writeFn(compressedData, options);\n\t\t\t} else {\n\t\t\t\tthis._writeFn(data, { ...options, compressed: false });\n\t\t\t}\n\t\t}\n\t\tthis._isProcessingWriteQueue = false;\n\t\tthis._onDidFinishProcessingWriteQueue.fire();\n\t}\n\n\tpublic isProcessingWriteQueue(): boolean {\n\t\treturn (this._isProcessingWriteQueue);\n\t}\n\n\t/**\n\t * Subsequent calls should wait for the previous `_deflateBuffer` call to complete.\n\t */\n\tprivate _deflateMessage(zlibDeflateStream: ZlibDeflateStream, buffer: VSBuffer): Promise<VSBuffer> {\n\t\treturn new Promise<VSBuffer>((resolve, reject) => {\n\t\t\tzlibDeflateStream.write(buffer);\n\t\t\tzlibDeflateStream.flush(data => resolve(data));\n\t\t});\n\t}\n\n\tpublic acceptFrame(data: VSBuffer, isCompressed: boolean, isLastFrameOfMessage: boolean): void {\n\t\tthis._readQueue.push({ data, isCompressed, isLastFrameOfMessage });\n\t\tthis._processReadQueue();\n\t}\n\n\tprivate _isProcessingReadQueue = false;\n\tprivate async _processReadQueue(): Promise<void> {\n\t\tif (this._isProcessingReadQueue) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isProcessingReadQueue = true;\n\t\twhile (this._readQueue.length > 0) {\n\t\t\tconst frameInfo = this._readQueue.shift()!;\n\t\t\tif (this._zlibInflateStream && frameInfo.isCompressed) {\n\t\t\t\t// See https://datatracker.ietf.org/doc/html/rfc7692#section-9.2\n\t\t\t\t// Even if permessageDeflate is negotiated, it is possible\n\t\t\t\t// that the other side might decide to send uncompressed messages\n\t\t\t\t// So only decompress messages that have the RSV 1 bit set\n\t\t\t\tconst data = await this._inflateFrame(this._zlibInflateStream, frameInfo.data, frameInfo.isLastFrameOfMessage);\n\t\t\t\tthis._onData.fire(data);\n\t\t\t} else {\n\t\t\t\tthis._onData.fire(frameInfo.data);\n\t\t\t}\n\t\t}\n\t\tthis._isProcessingReadQueue = false;\n\t\tthis._onDidFinishProcessingReadQueue.fire();\n\t}\n\n\tpublic isProcessingReadQueue(): boolean {\n\t\treturn (this._isProcessingReadQueue);\n\t}\n\n\t/**\n\t * Subsequent calls should wait for the previous `transformRead` call to complete.\n\t */\n\tprivate _inflateFrame(zlibInflateStream: ZlibInflateStream, buffer: VSBuffer, isLastFrameOfMessage: boolean): Promise<VSBuffer> {\n\t\treturn new Promise<VSBuffer>((resolve, reject) => {\n\t\t\t// See https://tools.ietf.org/html/rfc7692#section-7.2.2\n\t\t\tzlibInflateStream.write(buffer);\n\t\t\tif (isLastFrameOfMessage) {\n\t\t\t\tzlibInflateStream.write(VSBuffer.fromByteArray([0x00, 0x00, 0xff, 0xff]));\n\t\t\t}\n\t\t\tzlibInflateStream.flush(data => resolve(data));\n\t\t});\n\t}\n}\n\nclass ZlibInflateStream extends Disposable {\n\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibInflate: InflateRaw;\n\tprivate readonly _recordedInflateBytes: VSBuffer[] = [];\n\tprivate readonly _pendingInflateData: VSBuffer[] = [];\n\n\tpublic get recordedInflateBytes(): VSBuffer {\n\t\tif (this._recordInflateBytes) {\n\t\t\treturn VSBuffer.concat(this._recordedInflateBytes);\n\t\t}\n\t\treturn VSBuffer.alloc(0);\n\t}\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\tprivate readonly _recordInflateBytes: boolean,\n\t\tinflateBytes: VSBuffer | null,\n\t\toptions: ZlibOptions\n\t) {\n\t\tsuper();\n\t\tthis._zlibInflate = createInflateRaw(options);\n\t\tthis._zlibInflate.on('error', (err: Error) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateError, { message: err?.message, code: (err as NodeJS.ErrnoException)?.code });\n\t\t\tthis._onError.fire(err);\n\t\t});\n\t\tthis._zlibInflate.on('data', (data: Buffer) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateData, data);\n\t\t\tthis._pendingInflateData.push(VSBuffer.wrap(data));\n\t\t});\n\t\tif (inflateBytes) {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateInitialWrite, inflateBytes.buffer);\n\t\t\tthis._zlibInflate.write(inflateBytes.buffer);\n\t\t\tthis._zlibInflate.flush(() => {\n\t\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateInitialFlushFired);\n\t\t\t\tthis._pendingInflateData.length = 0;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\tif (this._recordInflateBytes) {\n\t\t\tthis._recordedInflateBytes.push(buffer.clone());\n\t\t}\n\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateWrite, buffer);\n\t\tthis._zlibInflate.write(buffer.buffer);\n\t}\n\n\tpublic flush(callback: (data: VSBuffer) => void): void {\n\t\tthis._zlibInflate.flush(() => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibInflateFlushFired);\n\t\t\tconst data = VSBuffer.concat(this._pendingInflateData);\n\t\t\tthis._pendingInflateData.length = 0;\n\t\t\tcallback(data);\n\t\t});\n\t}\n}\n\nclass ZlibDeflateStream extends Disposable {\n\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\tpublic readonly onError = this._onError.event;\n\n\tprivate readonly _zlibDeflate: DeflateRaw;\n\tprivate readonly _pendingDeflateData: VSBuffer[] = [];\n\n\tconstructor(\n\t\tprivate readonly _tracer: ISocketTracer,\n\t\toptions: ZlibOptions\n\t) {\n\t\tsuper();\n\n\t\tthis._zlibDeflate = createDeflateRaw({\n\t\t\twindowBits: 15\n\t\t});\n\t\tthis._zlibDeflate.on('error', (err: Error) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateError, { message: err?.message, code: (err as NodeJS.ErrnoException)?.code });\n\t\t\tthis._onError.fire(err);\n\t\t});\n\t\tthis._zlibDeflate.on('data', (data: Buffer) => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateData, data);\n\t\t\tthis._pendingDeflateData.push(VSBuffer.wrap(data));\n\t\t});\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateWrite, buffer.buffer);\n\t\tthis._zlibDeflate.write(<Buffer>buffer.buffer);\n\t}\n\n\tpublic flush(callback: (data: VSBuffer) => void): void {\n\t\t// See https://zlib.net/manual.html#Constants\n\t\tthis._zlibDeflate.flush(/*Z_SYNC_FLUSH*/2, () => {\n\t\t\tthis._tracer.traceSocketEvent(SocketDiagnosticsEventType.zlibDeflateFlushFired);\n\n\t\t\tlet data = VSBuffer.concat(this._pendingDeflateData);\n\t\t\tthis._pendingDeflateData.length = 0;\n\n\t\t\t// See https://tools.ietf.org/html/rfc7692#section-7.2.1\n\t\t\tdata = data.slice(0, data.byteLength - 4);\n\n\t\t\tcallback(data);\n\t\t});\n\t}\n}\n\nfunction unmask(buffer: VSBuffer, mask: number): void {\n\tif (mask === 0) {\n\t\treturn;\n\t}\n\tconst cnt = buffer.byteLength >>> 2;\n\tfor (let i = 0; i < cnt; i++) {\n\t\tconst v = buffer.readUInt32BE(i * 4);\n\t\tbuffer.writeUInt32BE(v ^ mask, i * 4);\n\t}\n\tconst offset = cnt * 4;\n\tconst bytesLeft = buffer.byteLength - offset;\n\tconst m3 = (mask >>> 24) & 0b11111111;\n\tconst m2 = (mask >>> 16) & 0b11111111;\n\tconst m1 = (mask >>> 8) & 0b11111111;\n\tif (bytesLeft >= 1) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset) ^ m3, offset);\n\t}\n\tif (bytesLeft >= 2) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset + 1) ^ m2, offset + 1);\n\t}\n\tif (bytesLeft >= 3) {\n\t\tbuffer.writeUInt8(buffer.readUInt8(offset + 2) ^ m1, offset + 2);\n\t}\n}\n\n// Read this before there's any chance it is overwritten\n// Related to https://github.com/microsoft/vscode/issues/30624\nexport const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];\n\nconst safeIpcPathLengths: { [platform: number]: number } = {\n\t[Platform.Linux]: 107,\n\t[Platform.Mac]: 103\n};\n\nexport function createRandomIPCHandle(): string {\n\tconst randomSuffix = generateUuid();\n\n\t// Windows: use named pipe\n\tif (process.platform === 'win32') {\n\t\treturn `\\\\\\\\.\\\\pipe\\\\vscode-ipc-${randomSuffix}-sock`;\n\t}\n\n\t// Mac & Unix: Use socket file\n\t// Unix: Prefer XDG_RUNTIME_DIR over user data path\n\tconst basePath = process.platform !== 'darwin' && XDG_RUNTIME_DIR ? XDG_RUNTIME_DIR : tmpdir();\n\tconst result = join(basePath, `vscode-ipc-${randomSuffix}.sock`);\n\n\t// Validate length\n\tvalidateIPCHandleLength(result);\n\n\treturn result;\n}\n\nexport function createStaticIPCHandle(directoryPath: string, type: string, version: string): string {\n\tconst scope = createHash('sha256').update(directoryPath).digest('hex');\n\tconst scopeForSocket = scope.substr(0, 8);\n\n\t// Windows: use named pipe\n\tif (process.platform === 'win32') {\n\t\treturn `\\\\\\\\.\\\\pipe\\\\${scopeForSocket}-${version}-${type}-sock`;\n\t}\n\n\t// Mac & Unix: Use socket file\n\t// Unix: Prefer XDG_RUNTIME_DIR over user data path, unless portable\n\t// Trim the version and type values for the socket to prevent too large\n\t// file names causing issues: https://unix.stackexchange.com/q/367008\n\n\tconst versionForSocket = version.substr(0, 4);\n\tconst typeForSocket = type.substr(0, 6);\n\n\tlet result: string;\n\tif (process.platform !== 'darwin' && XDG_RUNTIME_DIR && !process.env['VSCODE_PORTABLE']) {\n\t\tresult = join(XDG_RUNTIME_DIR, `vscode-${scopeForSocket}-${versionForSocket}-${typeForSocket}.sock`);\n\t} else {\n\t\tresult = join(directoryPath, `${versionForSocket}-${typeForSocket}.sock`);\n\t}\n\n\t// Validate length\n\tvalidateIPCHandleLength(result);\n\n\treturn result;\n}\n\nfunction validateIPCHandleLength(handle: string): void {\n\tconst limit = safeIpcPathLengths[platform];\n\tif (typeof limit === 'number' && handle.length >= limit) {\n\t\t// https://nodejs.org/api/net.html#net_identifying_paths_for_ipc_connections\n\t\tconsole.warn(`WARNING: IPC handle \"${handle}\" is longer than ${limit} chars, try a shorter --user-data-dir`);\n\t}\n}\n\nexport class Server extends IPCServer {\n\n\tprivate static toClientConnectionEvent(server: NetServer): Event<ClientConnectionEvent> {\n\t\tconst onConnection = Event.fromNodeEventEmitter<Socket>(server, 'connection');\n\n\t\treturn Event.map(onConnection, socket => ({\n\t\t\tprotocol: new Protocol(new NodeSocket(socket, 'ipc-server-connection')),\n\t\t\tonDidClientDisconnect: Event.once(Event.fromNodeEventEmitter<void>(socket, 'close'))\n\t\t}));\n\t}\n\n\tprivate server: NetServer | null;\n\n\tconstructor(server: NetServer) {\n\t\tsuper(Server.toClientConnectionEvent(server));\n\t\tthis.server = server;\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tif (this.server) {\n\t\t\tthis.server.close();\n\t\t\tthis.server = null;\n\t\t}\n\t}\n}\n\nexport function serve(port: number): Promise<Server>;\nexport function serve(namedPipe: string): Promise<Server>;\nexport function serve(hook: number | string): Promise<Server> {\n\treturn new Promise<Server>((resolve, reject) => {\n\t\tconst server = createServer();\n\n\t\tserver.on('error', reject);\n\t\tserver.listen(hook, () => {\n\t\t\tserver.removeListener('error', reject);\n\t\t\tresolve(new Server(server));\n\t\t});\n\t});\n}\n\nexport function connect(options: { host: string; port: number }, clientId: string): Promise<Client>;\nexport function connect(namedPipe: string, clientId: string): Promise<Client>;\nexport function connect(hook: { host: string; port: number } | string, clientId: string): Promise<Client> {\n\treturn new Promise<Client>((resolve, reject) => {\n\t\tlet socket: Socket;\n\n\t\tconst callbackHandler = () => {\n\t\t\tsocket.removeListener('error', reject);\n\t\t\tresolve(Client.fromSocket(new NodeSocket(socket, `ipc-client${clientId}`), clientId));\n\t\t};\n\n\t\tif (typeof hook === 'string') {\n\t\t\tsocket = createConnection(hook, callbackHandler);\n\t\t} else {\n\t\t\tsocket = createConnection(hook, callbackHandler);\n\t\t}\n\n\t\tsocket.once('error', reject);\n\t});\n}\n"]}