{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/parts/ipc/common/ipc.ts","vs/base/parts/ipc/common/ipc.ts"],"names":[],"mappings":"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","file":"ipc.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getRandomElement } from '../../../common/arrays.js';\nimport { CancelablePromise, createCancelablePromise, timeout } from '../../../common/async.js';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../common/cancellation.js';\nimport { memoize } from '../../../common/decorators.js';\nimport { CancellationError, ErrorNoTelemetry } from '../../../common/errors.js';\nimport { Emitter, Event, EventMultiplexer, Relay } from '../../../common/event.js';\nimport { createSingleCallFunction } from '../../../common/functional.js';\nimport { DisposableStore, dispose, IDisposable, toDisposable } from '../../../common/lifecycle.js';\nimport { revive } from '../../../common/marshalling.js';\nimport * as strings from '../../../common/strings.js';\nimport { isFunction, isUndefinedOrNull } from '../../../common/types.js';\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the counter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\nconst enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\nfunction requestTypeToStr(type: RequestType): string {\n\tswitch (type) {\n\t\tcase RequestType.Promise:\n\t\t\treturn 'req';\n\t\tcase RequestType.PromiseCancel:\n\t\t\treturn 'cancel';\n\t\tcase RequestType.EventListen:\n\t\t\treturn 'subscribe';\n\t\tcase RequestType.EventDispose:\n\t\t\treturn 'unsubscribe';\n\t}\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel; id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose; id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nconst enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\nfunction responseTypeToStr(type: ResponseType): string {\n\tswitch (type) {\n\t\tcase ResponseType.Initialize:\n\t\t\treturn `init`;\n\t\tcase ResponseType.PromiseSuccess:\n\t\t\treturn `reply:`;\n\t\tcase ResponseType.PromiseError:\n\t\tcase ResponseType.PromiseErrorObj:\n\t\t\treturn `replyErr:`;\n\t\tcase ResponseType.EventFire:\n\t\t\treturn `event:`;\n\t}\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string; name: string; stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: VSBuffer): void;\n\treadonly onMessage: Event<VSBuffer>;\n\t/**\n\t * Wait for the write buffer (if applicable) to become empty.\n\t */\n\tdrain?(): Promise<void>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidAddConnection: Event<Connection<TContext>>;\n\treadonly onDidRemoveConnection: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router?: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): VSBuffer;\n}\n\ninterface IWriter {\n\twrite(buffer: VSBuffer): void;\n}\n\n\n/**\n * @see https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nfunction readIntVQL(reader: IReader) {\n\tlet value = 0;\n\tfor (let n = 0; ; n += 7) {\n\t\tconst next = reader.read(1);\n\t\tvalue |= (next.buffer[0] & 0b01111111) << n;\n\t\tif (!(next.buffer[0] & 0b10000000)) {\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nconst vqlZero = createOneByteBuffer(0);\n\n/**\n * @see https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nfunction writeInt32VQL(writer: IWriter, value: number) {\n\tif (value === 0) {\n\t\twriter.write(vqlZero);\n\t\treturn;\n\t}\n\n\tlet len = 0;\n\tfor (let v2 = value; v2 !== 0; v2 = v2 >>> 7) {\n\t\tlen++;\n\t}\n\n\tconst scratch = VSBuffer.alloc(len);\n\tfor (let i = 0; value !== 0; i++) {\n\t\tscratch.buffer[i] = value & 0b01111111;\n\t\tvalue = value >>> 7;\n\t\tif (value > 0) {\n\t\t\tscratch.buffer[i] |= 0b10000000;\n\t\t}\n\t}\n\n\twriter.write(scratch);\n}\n\nexport class BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: VSBuffer) { }\n\n\tread(bytes: number): VSBuffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.byteLength;\n\t\treturn result;\n\t}\n}\n\nexport class BufferWriter implements IWriter {\n\n\tprivate buffers: VSBuffer[] = [];\n\n\tget buffer(): VSBuffer {\n\t\treturn VSBuffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: VSBuffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tVSBuffer = 3,\n\tArray = 4,\n\tObject = 5,\n\tInt = 6\n}\n\nfunction createOneByteBuffer(value: number): VSBuffer {\n\tconst result = VSBuffer.alloc(1);\n\tresult.writeUInt8(value, 0);\n\treturn result;\n}\n\nconst BufferPresets = {\n\tUndefined: createOneByteBuffer(DataType.Undefined),\n\tString: createOneByteBuffer(DataType.String),\n\tBuffer: createOneByteBuffer(DataType.Buffer),\n\tVSBuffer: createOneByteBuffer(DataType.VSBuffer),\n\tArray: createOneByteBuffer(DataType.Array),\n\tObject: createOneByteBuffer(DataType.Object),\n\tUint: createOneByteBuffer(DataType.Int),\n};\n\nexport function serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = VSBuffer.fromString(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t} else if (VSBuffer.isNativeBuffer(data)) {\n\t\tconst buffer = VSBuffer.wrap(data);\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t} else if (data instanceof VSBuffer) {\n\t\twriter.write(BufferPresets.VSBuffer);\n\t\twriteInt32VQL(writer, data.byteLength);\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriteInt32VQL(writer, data.length);\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else if (typeof data === 'number' && (data | 0) === data) {\n\t\t// write a vql if it's a number that we can do bitwise operations on\n\t\twriter.write(BufferPresets.Uint);\n\t\twriteInt32VQL(writer, data);\n\t} else {\n\t\tconst buffer = VSBuffer.fromString(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t}\n}\n\nexport function deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readIntVQL(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readIntVQL(reader)).buffer;\n\t\tcase DataType.VSBuffer: return reader.read(readIntVQL(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readIntVQL(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readIntVQL(reader)).toString());\n\t\tcase DataType.Int: return readIntVQL(reader);\n\t}\n}\n\ninterface PendingRequest {\n\trequest: IRawPromiseRequest | IRawEventListenRequest;\n\ttimeoutTimer: Timeout;\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\t// Requests might come in for channels which are not yet registered.\n\t// They will timeout after `timeoutDelay`.\n\tprivate pendingRequests = new Map<string, PendingRequest[]>();\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext, private logger: IIPCLogger | null = null, private timeoutDelay = 1000) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\t// https://github.com/microsoft/vscode/issues/72531\n\t\tsetTimeout(() => this.flushPendingRequests(channelName), 0);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize: {\n\t\t\t\tconst msgLength = this.send([response.type]);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, 0, RequestInitiator.OtherSide, responseTypeToStr(response.type));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj: {\n\t\t\t\tconst msgLength = this.send([response.type, response.id], response.data);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, response.id, RequestInitiator.OtherSide, responseTypeToStr(response.type), response.data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: unknown, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse({ id, data, type: ResponseType.PromiseSuccess });\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse({\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? err.stack.split('\\n') : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse({ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\t\t}).finally(() => {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse({ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tprivate collectPendingRequest(request: IRawPromiseRequest | IRawEventListenRequest): void {\n\t\tlet pendingRequests = this.pendingRequests.get(request.channelName);\n\n\t\tif (!pendingRequests) {\n\t\t\tpendingRequests = [];\n\t\t\tthis.pendingRequests.set(request.channelName, pendingRequests);\n\t\t}\n\n\t\tconst timer = setTimeout(() => {\n\t\t\tconsole.error(`Unknown channel: ${request.channelName}`);\n\n\t\t\tif (request.type === RequestType.Promise) {\n\t\t\t\tthis.sendResponse({\n\t\t\t\t\tid: request.id,\n\t\t\t\t\tdata: { name: 'Unknown channel', message: `Channel name '${request.channelName}' timed out after ${this.timeoutDelay}ms`, stack: undefined },\n\t\t\t\t\ttype: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t}\n\t\t}, this.timeoutDelay);\n\n\t\tpendingRequests.push({ request, timeoutTimer: timer });\n\t}\n\n\tprivate flushPendingRequests(channelName: string): void {\n\t\tconst requests = this.pendingRequests.get(channelName);\n\n\t\tif (requests) {\n\t\t\tfor (const request of requests) {\n\t\t\t\tclearTimeout(request.timeoutTimer);\n\n\t\t\t\tswitch (request.request.type) {\n\t\t\t\t\tcase RequestType.Promise: this.onPromise(request.request); break;\n\t\t\t\t\tcase RequestType.EventListen: this.onEventListen(request.request); break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.pendingRequests.delete(channelName);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport const enum RequestInitiator {\n\tLocalSide = 0,\n\tOtherSide = 1\n}\n\nexport interface IIPCLogger {\n\tlogIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n\tlogOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate isDisposed = false;\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId = 0;\n\tprivate protocolListener: IDisposable | null;\n\tprivate logger: IIPCLogger | null;\n\n\tprivate readonly _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol, logger: IIPCLogger | null = null) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t\tthis.logger = logger;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Promise.reject(new CancellationError());\n\t\t\t\t}\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Event.None;\n\t\t\t\t}\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<unknown> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(new CancellationError());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\t\tlet disposableWithRequestCancel: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(new CancellationError());\n\t\t\t}\n\n\t\t\tconst doRequest = () => {\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError: {\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\terror.stack = Array.isArray(response.data.stack) ? response.data.stack.join('\\n') : response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t};\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\t\t\tif (this.state === State.Idle) {\n\t\t\t\tdoRequest();\n\t\t\t} else {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tdoRequest();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(new CancellationError());\n\t\t\t};\n\n\t\t\tdisposable = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposableWithRequestCancel = {\n\t\t\t\tdispose: createSingleCallFunction(() => {\n\t\t\t\t\tcancel();\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t})\n\t\t\t};\n\n\t\t\tthis.activeRequests.add(disposableWithRequestCancel);\n\t\t});\n\n\t\treturn result.finally(() => {\n\t\t\tdisposable?.dispose(); // Seen as undefined in tests.\n\t\t\tthis.activeRequests.delete(disposableWithRequestCancel);\n\t\t});\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tconst doRequest = () => {\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t};\n\t\t\t\tif (this.state === State.Idle) {\n\t\t\t\t\tdoRequest();\n\t\t\t\t} else {\n\t\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\t\tdoRequest();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawResponse) => emitter.fire((res as IRawEventFireResponse).data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, `${requestTypeToStr(request.type)}: ${request.channelName}.${request.name}`, request.arg);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id]);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, requestTypeToStr(request.type));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: unknown, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onBuffer(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, 0, RequestInitiator.LocalSide, responseTypeToStr(type));\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.LocalSide, responseTypeToStr(type), body);\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\thandler?.(response);\n\t}\n\n\t@memoize\n\tget onDidInitializePromise(): Promise<void> {\n\t\treturn Event.toPromise(this.onDidInitialize);\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn this.onDidInitializePromise;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\treadonly onDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelServer: ChannelServer<TContext>;\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate readonly _onDidAddConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidAddConnection: Event<Connection<TContext>> = this._onDidAddConnection.event;\n\n\tprivate readonly _onDidRemoveConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidRemoveConnection: Event<Connection<TContext>> = this._onDidRemoveConnection.event;\n\n\tprivate readonly disposables = new DisposableStore();\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>, ipcLogger?: IIPCLogger | null, timeoutDelay?: number) {\n\t\tthis.disposables.add(onDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tthis.disposables.add(onFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx, ipcLogger, timeoutDelay);\n\t\t\t\tconst channelClient = new ChannelClient(protocol, ipcLogger);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelServer, channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidAddConnection.fire(connection);\n\n\t\t\t\tthis.disposables.add(onDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t\tthis._onDidRemoveConnection.fire(connection);\n\t\t\t\t}));\n\t\t\t}));\n\t\t}));\n\t}\n\n\t/**\n\t * Get a channel from a remote client. When passed a router,\n\t * one can specify which client it wants to call and listen to/from.\n\t * Otherwise, when calling without a router, a random client will\n\t * be selected and when listening without a router, every client\n\t * will be listened to.\n\t */\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n\tgetChannel<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean): T;\n\tgetChannel<T extends IChannel>(channelName: string, routerOrClientFilter: IClientRouter<TContext> | ((client: Client<TContext>) => boolean)): T {\n\t\tconst that = this;\n\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\tlet connectionPromise: Promise<Client<TContext>>;\n\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\t// when no router is provided, we go random client picking\n\t\t\t\t\tconst connection = getRandomElement(that.connections.filter(routerOrClientFilter));\n\n\t\t\t\t\tconnectionPromise = connection\n\t\t\t\t\t\t// if we found a client, let's call on it\n\t\t\t\t\t\t? Promise.resolve(connection)\n\t\t\t\t\t\t// else, let's wait for a client to come along\n\t\t\t\t\t\t: Event.toPromise(Event.filter(that.onDidAddConnection, routerOrClientFilter));\n\t\t\t\t} else {\n\t\t\t\t\tconnectionPromise = routerOrClientFilter.routeCall(that, command, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = connectionPromise\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any): Event<T> {\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\treturn that.getMulticastEvent(channelName, routerOrClientFilter, event, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = routerOrClientFilter.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate getMulticastEvent<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean, eventName: string, arg: any): Event<T> {\n\t\tconst that = this;\n\t\tlet disposables: DisposableStore | undefined;\n\n\t\t// Create an emitter which hooks up to all clients\n\t\t// as soon as first listener is added. It also\n\t\t// disconnects from all clients as soon as the last listener\n\t\t// is removed.\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tdisposables = new DisposableStore();\n\n\t\t\t\t// The event multiplexer is useful since the active\n\t\t\t\t// client list is dynamic. We need to hook up and disconnection\n\t\t\t\t// to/from clients as they come and go.\n\t\t\t\tconst eventMultiplexer = new EventMultiplexer<T>();\n\t\t\t\tconst map = new Map<Connection<TContext>, IDisposable>();\n\n\t\t\t\tconst onDidAddConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst channel = connection.channelClient.getChannel(channelName);\n\t\t\t\t\tconst event = channel.listen<T>(eventName, arg);\n\t\t\t\t\tconst disposable = eventMultiplexer.add(event);\n\n\t\t\t\t\tmap.set(connection, disposable);\n\t\t\t\t};\n\n\t\t\t\tconst onDidRemoveConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst disposable = map.get(connection);\n\n\t\t\t\t\tif (!disposable) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\tmap.delete(connection);\n\t\t\t\t};\n\n\t\t\t\tthat.connections.filter(clientFilter).forEach(onDidAddConnection);\n\t\t\t\tEvent.filter(that.onDidAddConnection, clientFilter)(onDidAddConnection, undefined, disposables);\n\t\t\t\tthat.onDidRemoveConnection(onDidRemoveConnection, undefined, disposables);\n\t\t\t\teventMultiplexer.event(emitter.fire, emitter, disposables);\n\n\t\t\t\tdisposables.add(eventMultiplexer);\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tdisposables?.dispose();\n\t\t\t\tdisposables = undefined;\n\t\t\t}\n\t\t});\n\t\tthat.disposables.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\tfor (const connection of this._connections) {\n\t\t\tconnection.channelServer.registerChannel(channelName, channel);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\n\t\tfor (const connection of this._connections) {\n\t\t\tconnection.channelClient.dispose();\n\t\t\tconnection.channelServer.dispose();\n\t\t}\n\n\t\tthis._connections.clear();\n\t\tthis.channels.clear();\n\t\tthis._onDidAddConnection.dispose();\n\t\tthis._onDidRemoveConnection.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCServer` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol, ipcLogger);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx, ipcLogger);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName);\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidAddConnection);\n\t\treturn await this.route(hub);\n\t}\n}\n\n/**\n * Use ProxyChannels to automatically wrapping and unwrapping\n * services to/from IPC channels, instead of manually wrapping\n * each service method and event.\n *\n * Restrictions:\n * - If marshalling is enabled, only `URI` and `RegExp` is converted\n *   automatically for you\n * - Events must follow the naming convention `onUpperCase`\n * - `CancellationToken` is currently not supported\n * - If a context is provided, you can use `AddFirstParameterToFunctions`\n *   utility to signal this in the receiving side type\n */\nexport namespace ProxyChannel {\n\n\texport interface IProxyOptions {\n\n\t\t/**\n\t\t * Disables automatic marshalling of `URI`.\n\t\t * If marshalling is disabled, `UriComponents`\n\t\t * must be used instead.\n\t\t */\n\t\tdisableMarshalling?: boolean;\n\t}\n\n\texport interface ICreateServiceChannelOptions extends IProxyOptions { }\n\n\texport function fromService<TContext>(service: unknown, disposables: DisposableStore, options?: ICreateServiceChannelOptions): IServerChannel<TContext> {\n\t\tconst handler = service as { [key: string]: unknown };\n\t\tconst disableMarshalling = options?.disableMarshalling;\n\n\t\t// Buffer any event that should be supported by\n\t\t// iterating over all property keys and finding them\n\t\t// However, this will not work for services that\n\t\t// are lazy and use a Proxy within. For that we\n\t\t// still need to check later (see below).\n\t\tconst mapEventNameToEvent = new Map<string, Event<unknown>>();\n\t\tfor (const key in handler) {\n\t\t\tif (propertyIsEvent(key)) {\n\t\t\t\tmapEventNameToEvent.set(key, Event.buffer(handler[key] as Event<unknown>, true, undefined, disposables));\n\t\t\t}\n\t\t}\n\n\t\treturn new class implements IServerChannel {\n\n\t\t\tlisten<T>(_: unknown, event: string, arg: any): Event<T> {\n\t\t\t\tconst eventImpl = mapEventNameToEvent.get(event);\n\t\t\t\tif (eventImpl) {\n\t\t\t\t\treturn eventImpl as Event<T>;\n\t\t\t\t}\n\n\t\t\t\tconst target = handler[event];\n\t\t\t\tif (typeof target === 'function') {\n\t\t\t\t\tif (propertyIsDynamicEvent(event)) {\n\t\t\t\t\t\treturn target.call(handler, arg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (propertyIsEvent(event)) {\n\t\t\t\t\t\tmapEventNameToEvent.set(event, Event.buffer(handler[event] as Event<unknown>, true, undefined, disposables));\n\n\t\t\t\t\t\treturn mapEventNameToEvent.get(event) as Event<T>;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Event not found: ${event}`);\n\t\t\t}\n\n\t\t\tcall(_: unknown, command: string, args?: any[]): Promise<any> {\n\t\t\t\tconst target = handler[command];\n\t\t\t\tif (typeof target === 'function') {\n\n\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\tif (!disableMarshalling && Array.isArray(args)) {\n\t\t\t\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\t\t\t\targs[i] = revive(args[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet res = target.apply(handler, args);\n\t\t\t\t\tif (!(res instanceof Promise)) {\n\t\t\t\t\t\tres = Promise.resolve(res);\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Method not found: ${command}`);\n\t\t\t}\n\t\t};\n\t}\n\n\texport interface ICreateProxyServiceOptions extends IProxyOptions {\n\n\t\t/**\n\t\t * If provided, will add the value of `context`\n\t\t * to each method call to the target.\n\t\t */\n\t\tcontext?: unknown;\n\n\t\t/**\n\t\t * If provided, will not proxy any of the properties\n\t\t * that are part of the Map but rather return that value.\n\t\t */\n\t\tproperties?: Map<string, unknown>;\n\t}\n\n\texport function toService<T extends object>(channel: IChannel, options?: ICreateProxyServiceOptions): T {\n\t\tconst disableMarshalling = options?.disableMarshalling;\n\n\t\treturn new Proxy({}, {\n\t\t\tget(_target: T, propKey: PropertyKey) {\n\t\t\t\tif (typeof propKey === 'string') {\n\n\t\t\t\t\t// Check for predefined values\n\t\t\t\t\tif (options?.properties?.has(propKey)) {\n\t\t\t\t\t\treturn options.properties.get(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Dynamic Event\n\t\t\t\t\tif (propertyIsDynamicEvent(propKey)) {\n\t\t\t\t\t\treturn function (arg: unknown) {\n\t\t\t\t\t\t\treturn channel.listen(propKey, arg);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Event\n\t\t\t\t\tif (propertyIsEvent(propKey)) {\n\t\t\t\t\t\treturn channel.listen(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Function\n\t\t\t\t\treturn async function (...args: any[]) {\n\n\t\t\t\t\t\t// Add context if any\n\t\t\t\t\t\tlet methodArgs: any[];\n\t\t\t\t\t\tif (options && !isUndefinedOrNull(options.context)) {\n\t\t\t\t\t\t\tmethodArgs = [options.context, ...args];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmethodArgs = args;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = await channel.call(propKey, methodArgs);\n\n\t\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\t\tif (!disableMarshalling) {\n\t\t\t\t\t\t\treturn revive(result);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Property not found: ${String(propKey)}`);\n\t\t\t}\n\t\t}) as T;\n\t}\n\n\tfunction propertyIsEvent(name: string): boolean {\n\t\t// Assume a property is an event if it has a form of \"onSomething\"\n\t\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\n\t}\n\n\tfunction propertyIsDynamicEvent(name: string): boolean {\n\t\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\n\t\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\n\t}\n}\n\nconst colorTables = [\n\t['#2977B1', '#FC802D', '#34A13A', '#D3282F', '#9366BA'],\n\t['#8B564C', '#E177C0', '#7F7F7F', '#BBBE3D', '#2EBECD']\n];\n\nfunction prettyWithoutArrays(data: unknown): any {\n\tif (Array.isArray(data)) {\n\t\treturn data;\n\t}\n\tif (data && typeof data === 'object' && typeof data.toString === 'function') {\n\t\tconst result = data.toString();\n\t\tif (result !== '[object Object]') {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction pretty(data: unknown): any {\n\tif (Array.isArray(data)) {\n\t\treturn data.map(prettyWithoutArrays);\n\t}\n\treturn prettyWithoutArrays(data);\n}\n\nfunction logWithColors(direction: string, totalLength: number, msgLength: number, req: number, initiator: RequestInitiator, str: string, data: any): void {\n\tdata = pretty(data);\n\n\tconst colorTable = colorTables[initiator];\n\tconst color = colorTable[req % colorTable.length];\n\tlet args = [`%c[${direction}]%c[${String(totalLength).padStart(7, ' ')}]%c[len: ${String(msgLength).padStart(5, ' ')}]%c${String(req).padStart(5, ' ')} - ${str}`, 'color: darkgreen', 'color: grey', 'color: grey', `color: ${color}`];\n\tif (/\\($/.test(str)) {\n\t\targs = args.concat(data);\n\t\targs.push(')');\n\t} else {\n\t\targs.push(data);\n\t}\n\tconsole.log.apply(console, args as [string, ...string[]]);\n}\n\nexport class IPCLogger implements IIPCLogger {\n\tprivate _totalIncoming = 0;\n\tprivate _totalOutgoing = 0;\n\n\tconstructor(\n\t\tprivate readonly _outgoingPrefix: string,\n\t\tprivate readonly _incomingPrefix: string,\n\t) { }\n\n\tpublic logOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalOutgoing += msgLength;\n\t\tlogWithColors(this._outgoingPrefix, this._totalOutgoing, msgLength, requestId, initiator, str, data);\n\t}\n\n\tpublic logIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalIncoming += msgLength;\n\t\tlogWithColors(this._incomingPrefix, this._totalIncoming, msgLength, requestId, initiator, str, data);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getRandomElement } from '../../../common/arrays.js';\nimport { CancelablePromise, createCancelablePromise, timeout } from '../../../common/async.js';\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../common/cancellation.js';\nimport { memoize } from '../../../common/decorators.js';\nimport { CancellationError, ErrorNoTelemetry } from '../../../common/errors.js';\nimport { Emitter, Event, EventMultiplexer, Relay } from '../../../common/event.js';\nimport { createSingleCallFunction } from '../../../common/functional.js';\nimport { DisposableStore, dispose, IDisposable, toDisposable } from '../../../common/lifecycle.js';\nimport { revive } from '../../../common/marshalling.js';\nimport * as strings from '../../../common/strings.js';\nimport { isFunction, isUndefinedOrNull } from '../../../common/types.js';\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the counter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\nconst enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\nfunction requestTypeToStr(type: RequestType): string {\n\tswitch (type) {\n\t\tcase RequestType.Promise:\n\t\t\treturn 'req';\n\t\tcase RequestType.PromiseCancel:\n\t\t\treturn 'cancel';\n\t\tcase RequestType.EventListen:\n\t\t\treturn 'subscribe';\n\t\tcase RequestType.EventDispose:\n\t\t\treturn 'unsubscribe';\n\t}\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel; id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose; id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nconst enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\nfunction responseTypeToStr(type: ResponseType): string {\n\tswitch (type) {\n\t\tcase ResponseType.Initialize:\n\t\t\treturn `init`;\n\t\tcase ResponseType.PromiseSuccess:\n\t\t\treturn `reply:`;\n\t\tcase ResponseType.PromiseError:\n\t\tcase ResponseType.PromiseErrorObj:\n\t\t\treturn `replyErr:`;\n\t\tcase ResponseType.EventFire:\n\t\t\treturn `event:`;\n\t}\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string; name: string; stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: VSBuffer): void;\n\treadonly onMessage: Event<VSBuffer>;\n\t/**\n\t * Wait for the write buffer (if applicable) to become empty.\n\t */\n\tdrain?(): Promise<void>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidAddConnection: Event<Connection<TContext>>;\n\treadonly onDidRemoveConnection: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router?: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): VSBuffer;\n}\n\ninterface IWriter {\n\twrite(buffer: VSBuffer): void;\n}\n\n\n/**\n * @see https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nfunction readIntVQL(reader: IReader) {\n\tlet value = 0;\n\tfor (let n = 0; ; n += 7) {\n\t\tconst next = reader.read(1);\n\t\tvalue |= (next.buffer[0] & 0b01111111) << n;\n\t\tif (!(next.buffer[0] & 0b10000000)) {\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nconst vqlZero = createOneByteBuffer(0);\n\n/**\n * @see https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nfunction writeInt32VQL(writer: IWriter, value: number) {\n\tif (value === 0) {\n\t\twriter.write(vqlZero);\n\t\treturn;\n\t}\n\n\tlet len = 0;\n\tfor (let v2 = value; v2 !== 0; v2 = v2 >>> 7) {\n\t\tlen++;\n\t}\n\n\tconst scratch = VSBuffer.alloc(len);\n\tfor (let i = 0; value !== 0; i++) {\n\t\tscratch.buffer[i] = value & 0b01111111;\n\t\tvalue = value >>> 7;\n\t\tif (value > 0) {\n\t\t\tscratch.buffer[i] |= 0b10000000;\n\t\t}\n\t}\n\n\twriter.write(scratch);\n}\n\nexport class BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: VSBuffer) { }\n\n\tread(bytes: number): VSBuffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.byteLength;\n\t\treturn result;\n\t}\n}\n\nexport class BufferWriter implements IWriter {\n\n\tprivate buffers: VSBuffer[] = [];\n\n\tget buffer(): VSBuffer {\n\t\treturn VSBuffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: VSBuffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tVSBuffer = 3,\n\tArray = 4,\n\tObject = 5,\n\tInt = 6\n}\n\nfunction createOneByteBuffer(value: number): VSBuffer {\n\tconst result = VSBuffer.alloc(1);\n\tresult.writeUInt8(value, 0);\n\treturn result;\n}\n\nconst BufferPresets = {\n\tUndefined: createOneByteBuffer(DataType.Undefined),\n\tString: createOneByteBuffer(DataType.String),\n\tBuffer: createOneByteBuffer(DataType.Buffer),\n\tVSBuffer: createOneByteBuffer(DataType.VSBuffer),\n\tArray: createOneByteBuffer(DataType.Array),\n\tObject: createOneByteBuffer(DataType.Object),\n\tUint: createOneByteBuffer(DataType.Int),\n};\n\nexport function serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = VSBuffer.fromString(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t} else if (VSBuffer.isNativeBuffer(data)) {\n\t\tconst buffer = VSBuffer.wrap(data);\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t} else if (data instanceof VSBuffer) {\n\t\twriter.write(BufferPresets.VSBuffer);\n\t\twriteInt32VQL(writer, data.byteLength);\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriteInt32VQL(writer, data.length);\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else if (typeof data === 'number' && (data | 0) === data) {\n\t\t// write a vql if it's a number that we can do bitwise operations on\n\t\twriter.write(BufferPresets.Uint);\n\t\twriteInt32VQL(writer, data);\n\t} else {\n\t\tconst buffer = VSBuffer.fromString(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t}\n}\n\nexport function deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readIntVQL(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readIntVQL(reader)).buffer;\n\t\tcase DataType.VSBuffer: return reader.read(readIntVQL(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readIntVQL(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readIntVQL(reader)).toString());\n\t\tcase DataType.Int: return readIntVQL(reader);\n\t}\n}\n\ninterface PendingRequest {\n\trequest: IRawPromiseRequest | IRawEventListenRequest;\n\ttimeoutTimer: Timeout;\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\t// Requests might come in for channels which are not yet registered.\n\t// They will timeout after `timeoutDelay`.\n\tprivate pendingRequests = new Map<string, PendingRequest[]>();\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext, private logger: IIPCLogger | null = null, private timeoutDelay = 1000) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\t// https://github.com/microsoft/vscode/issues/72531\n\t\tsetTimeout(() => this.flushPendingRequests(channelName), 0);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize: {\n\t\t\t\tconst msgLength = this.send([response.type]);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, 0, RequestInitiator.OtherSide, responseTypeToStr(response.type));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj: {\n\t\t\t\tconst msgLength = this.send([response.type, response.id], response.data);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, response.id, RequestInitiator.OtherSide, responseTypeToStr(response.type), response.data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: unknown, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse({ id, data, type: ResponseType.PromiseSuccess });\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse({\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? err.stack.split('\\n') : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse({ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\t\t}).finally(() => {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse({ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tprivate collectPendingRequest(request: IRawPromiseRequest | IRawEventListenRequest): void {\n\t\tlet pendingRequests = this.pendingRequests.get(request.channelName);\n\n\t\tif (!pendingRequests) {\n\t\t\tpendingRequests = [];\n\t\t\tthis.pendingRequests.set(request.channelName, pendingRequests);\n\t\t}\n\n\t\tconst timer = setTimeout(() => {\n\t\t\tconsole.error(`Unknown channel: ${request.channelName}`);\n\n\t\t\tif (request.type === RequestType.Promise) {\n\t\t\t\tthis.sendResponse({\n\t\t\t\t\tid: request.id,\n\t\t\t\t\tdata: { name: 'Unknown channel', message: `Channel name '${request.channelName}' timed out after ${this.timeoutDelay}ms`, stack: undefined },\n\t\t\t\t\ttype: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t}\n\t\t}, this.timeoutDelay);\n\n\t\tpendingRequests.push({ request, timeoutTimer: timer });\n\t}\n\n\tprivate flushPendingRequests(channelName: string): void {\n\t\tconst requests = this.pendingRequests.get(channelName);\n\n\t\tif (requests) {\n\t\t\tfor (const request of requests) {\n\t\t\t\tclearTimeout(request.timeoutTimer);\n\n\t\t\t\tswitch (request.request.type) {\n\t\t\t\t\tcase RequestType.Promise: this.onPromise(request.request); break;\n\t\t\t\t\tcase RequestType.EventListen: this.onEventListen(request.request); break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.pendingRequests.delete(channelName);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport const enum RequestInitiator {\n\tLocalSide = 0,\n\tOtherSide = 1\n}\n\nexport interface IIPCLogger {\n\tlogIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n\tlogOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate isDisposed = false;\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId = 0;\n\tprivate protocolListener: IDisposable | null;\n\tprivate logger: IIPCLogger | null;\n\n\tprivate readonly _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol, logger: IIPCLogger | null = null) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t\tthis.logger = logger;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Promise.reject(new CancellationError());\n\t\t\t\t}\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Event.None;\n\t\t\t\t}\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<unknown> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(new CancellationError());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\t\tlet disposableWithRequestCancel: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(new CancellationError());\n\t\t\t}\n\n\t\t\tconst doRequest = () => {\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError: {\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\terror.stack = Array.isArray(response.data.stack) ? response.data.stack.join('\\n') : response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t};\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\t\t\tif (this.state === State.Idle) {\n\t\t\t\tdoRequest();\n\t\t\t} else {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tdoRequest();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(new CancellationError());\n\t\t\t};\n\n\t\t\tdisposable = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposableWithRequestCancel = {\n\t\t\t\tdispose: createSingleCallFunction(() => {\n\t\t\t\t\tcancel();\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t})\n\t\t\t};\n\n\t\t\tthis.activeRequests.add(disposableWithRequestCancel);\n\t\t});\n\n\t\treturn result.finally(() => {\n\t\t\tdisposable?.dispose(); // Seen as undefined in tests.\n\t\t\tthis.activeRequests.delete(disposableWithRequestCancel);\n\t\t});\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tconst doRequest = () => {\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t};\n\t\t\t\tif (this.state === State.Idle) {\n\t\t\t\t\tdoRequest();\n\t\t\t\t} else {\n\t\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\t\tdoRequest();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawResponse) => emitter.fire((res as IRawEventFireResponse).data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, `${requestTypeToStr(request.type)}: ${request.channelName}.${request.name}`, request.arg);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id]);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, requestTypeToStr(request.type));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: unknown, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onBuffer(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, 0, RequestInitiator.LocalSide, responseTypeToStr(type));\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.LocalSide, responseTypeToStr(type), body);\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\thandler?.(response);\n\t}\n\n\t@memoize\n\tget onDidInitializePromise(): Promise<void> {\n\t\treturn Event.toPromise(this.onDidInitialize);\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn this.onDidInitializePromise;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\treadonly onDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelServer: ChannelServer<TContext>;\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate readonly _onDidAddConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidAddConnection: Event<Connection<TContext>> = this._onDidAddConnection.event;\n\n\tprivate readonly _onDidRemoveConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidRemoveConnection: Event<Connection<TContext>> = this._onDidRemoveConnection.event;\n\n\tprivate readonly disposables = new DisposableStore();\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>, ipcLogger?: IIPCLogger | null, timeoutDelay?: number) {\n\t\tthis.disposables.add(onDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tthis.disposables.add(onFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx, ipcLogger, timeoutDelay);\n\t\t\t\tconst channelClient = new ChannelClient(protocol, ipcLogger);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelServer, channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidAddConnection.fire(connection);\n\n\t\t\t\tthis.disposables.add(onDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t\tthis._onDidRemoveConnection.fire(connection);\n\t\t\t\t}));\n\t\t\t}));\n\t\t}));\n\t}\n\n\t/**\n\t * Get a channel from a remote client. When passed a router,\n\t * one can specify which client it wants to call and listen to/from.\n\t * Otherwise, when calling without a router, a random client will\n\t * be selected and when listening without a router, every client\n\t * will be listened to.\n\t */\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n\tgetChannel<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean): T;\n\tgetChannel<T extends IChannel>(channelName: string, routerOrClientFilter: IClientRouter<TContext> | ((client: Client<TContext>) => boolean)): T {\n\t\tconst that = this;\n\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\tlet connectionPromise: Promise<Client<TContext>>;\n\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\t// when no router is provided, we go random client picking\n\t\t\t\t\tconst connection = getRandomElement(that.connections.filter(routerOrClientFilter));\n\n\t\t\t\t\tconnectionPromise = connection\n\t\t\t\t\t\t// if we found a client, let's call on it\n\t\t\t\t\t\t? Promise.resolve(connection)\n\t\t\t\t\t\t// else, let's wait for a client to come along\n\t\t\t\t\t\t: Event.toPromise(Event.filter(that.onDidAddConnection, routerOrClientFilter));\n\t\t\t\t} else {\n\t\t\t\t\tconnectionPromise = routerOrClientFilter.routeCall(that, command, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = connectionPromise\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any): Event<T> {\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\treturn that.getMulticastEvent(channelName, routerOrClientFilter, event, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = routerOrClientFilter.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate getMulticastEvent<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean, eventName: string, arg: any): Event<T> {\n\t\tconst that = this;\n\t\tlet disposables: DisposableStore | undefined;\n\n\t\t// Create an emitter which hooks up to all clients\n\t\t// as soon as first listener is added. It also\n\t\t// disconnects from all clients as soon as the last listener\n\t\t// is removed.\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tdisposables = new DisposableStore();\n\n\t\t\t\t// The event multiplexer is useful since the active\n\t\t\t\t// client list is dynamic. We need to hook up and disconnection\n\t\t\t\t// to/from clients as they come and go.\n\t\t\t\tconst eventMultiplexer = new EventMultiplexer<T>();\n\t\t\t\tconst map = new Map<Connection<TContext>, IDisposable>();\n\n\t\t\t\tconst onDidAddConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst channel = connection.channelClient.getChannel(channelName);\n\t\t\t\t\tconst event = channel.listen<T>(eventName, arg);\n\t\t\t\t\tconst disposable = eventMultiplexer.add(event);\n\n\t\t\t\t\tmap.set(connection, disposable);\n\t\t\t\t};\n\n\t\t\t\tconst onDidRemoveConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst disposable = map.get(connection);\n\n\t\t\t\t\tif (!disposable) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\tmap.delete(connection);\n\t\t\t\t};\n\n\t\t\t\tthat.connections.filter(clientFilter).forEach(onDidAddConnection);\n\t\t\t\tEvent.filter(that.onDidAddConnection, clientFilter)(onDidAddConnection, undefined, disposables);\n\t\t\t\tthat.onDidRemoveConnection(onDidRemoveConnection, undefined, disposables);\n\t\t\t\teventMultiplexer.event(emitter.fire, emitter, disposables);\n\n\t\t\t\tdisposables.add(eventMultiplexer);\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tdisposables?.dispose();\n\t\t\t\tdisposables = undefined;\n\t\t\t}\n\t\t});\n\t\tthat.disposables.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\tfor (const connection of this._connections) {\n\t\t\tconnection.channelServer.registerChannel(channelName, channel);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\n\t\tfor (const connection of this._connections) {\n\t\t\tconnection.channelClient.dispose();\n\t\t\tconnection.channelServer.dispose();\n\t\t}\n\n\t\tthis._connections.clear();\n\t\tthis.channels.clear();\n\t\tthis._onDidAddConnection.dispose();\n\t\tthis._onDidRemoveConnection.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCServer` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol, ipcLogger);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx, ipcLogger);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName);\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidAddConnection);\n\t\treturn await this.route(hub);\n\t}\n}\n\n/**\n * Use ProxyChannels to automatically wrapping and unwrapping\n * services to/from IPC channels, instead of manually wrapping\n * each service method and event.\n *\n * Restrictions:\n * - If marshalling is enabled, only `URI` and `RegExp` is converted\n *   automatically for you\n * - Events must follow the naming convention `onUpperCase`\n * - `CancellationToken` is currently not supported\n * - If a context is provided, you can use `AddFirstParameterToFunctions`\n *   utility to signal this in the receiving side type\n */\nexport namespace ProxyChannel {\n\n\texport interface IProxyOptions {\n\n\t\t/**\n\t\t * Disables automatic marshalling of `URI`.\n\t\t * If marshalling is disabled, `UriComponents`\n\t\t * must be used instead.\n\t\t */\n\t\tdisableMarshalling?: boolean;\n\t}\n\n\texport interface ICreateServiceChannelOptions extends IProxyOptions { }\n\n\texport function fromService<TContext>(service: unknown, disposables: DisposableStore, options?: ICreateServiceChannelOptions): IServerChannel<TContext> {\n\t\tconst handler = service as { [key: string]: unknown };\n\t\tconst disableMarshalling = options?.disableMarshalling;\n\n\t\t// Buffer any event that should be supported by\n\t\t// iterating over all property keys and finding them\n\t\t// However, this will not work for services that\n\t\t// are lazy and use a Proxy within. For that we\n\t\t// still need to check later (see below).\n\t\tconst mapEventNameToEvent = new Map<string, Event<unknown>>();\n\t\tfor (const key in handler) {\n\t\t\tif (propertyIsEvent(key)) {\n\t\t\t\tmapEventNameToEvent.set(key, Event.buffer(handler[key] as Event<unknown>, true, undefined, disposables));\n\t\t\t}\n\t\t}\n\n\t\treturn new class implements IServerChannel {\n\n\t\t\tlisten<T>(_: unknown, event: string, arg: any): Event<T> {\n\t\t\t\tconst eventImpl = mapEventNameToEvent.get(event);\n\t\t\t\tif (eventImpl) {\n\t\t\t\t\treturn eventImpl as Event<T>;\n\t\t\t\t}\n\n\t\t\t\tconst target = handler[event];\n\t\t\t\tif (typeof target === 'function') {\n\t\t\t\t\tif (propertyIsDynamicEvent(event)) {\n\t\t\t\t\t\treturn target.call(handler, arg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (propertyIsEvent(event)) {\n\t\t\t\t\t\tmapEventNameToEvent.set(event, Event.buffer(handler[event] as Event<unknown>, true, undefined, disposables));\n\n\t\t\t\t\t\treturn mapEventNameToEvent.get(event) as Event<T>;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Event not found: ${event}`);\n\t\t\t}\n\n\t\t\tcall(_: unknown, command: string, args?: any[]): Promise<any> {\n\t\t\t\tconst target = handler[command];\n\t\t\t\tif (typeof target === 'function') {\n\n\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\tif (!disableMarshalling && Array.isArray(args)) {\n\t\t\t\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\t\t\t\targs[i] = revive(args[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet res = target.apply(handler, args);\n\t\t\t\t\tif (!(res instanceof Promise)) {\n\t\t\t\t\t\tres = Promise.resolve(res);\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Method not found: ${command}`);\n\t\t\t}\n\t\t};\n\t}\n\n\texport interface ICreateProxyServiceOptions extends IProxyOptions {\n\n\t\t/**\n\t\t * If provided, will add the value of `context`\n\t\t * to each method call to the target.\n\t\t */\n\t\tcontext?: unknown;\n\n\t\t/**\n\t\t * If provided, will not proxy any of the properties\n\t\t * that are part of the Map but rather return that value.\n\t\t */\n\t\tproperties?: Map<string, unknown>;\n\t}\n\n\texport function toService<T extends object>(channel: IChannel, options?: ICreateProxyServiceOptions): T {\n\t\tconst disableMarshalling = options?.disableMarshalling;\n\n\t\treturn new Proxy({}, {\n\t\t\tget(_target: T, propKey: PropertyKey) {\n\t\t\t\tif (typeof propKey === 'string') {\n\n\t\t\t\t\t// Check for predefined values\n\t\t\t\t\tif (options?.properties?.has(propKey)) {\n\t\t\t\t\t\treturn options.properties.get(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Dynamic Event\n\t\t\t\t\tif (propertyIsDynamicEvent(propKey)) {\n\t\t\t\t\t\treturn function (arg: unknown) {\n\t\t\t\t\t\t\treturn channel.listen(propKey, arg);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Event\n\t\t\t\t\tif (propertyIsEvent(propKey)) {\n\t\t\t\t\t\treturn channel.listen(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Function\n\t\t\t\t\treturn async function (...args: any[]) {\n\n\t\t\t\t\t\t// Add context if any\n\t\t\t\t\t\tlet methodArgs: any[];\n\t\t\t\t\t\tif (options && !isUndefinedOrNull(options.context)) {\n\t\t\t\t\t\t\tmethodArgs = [options.context, ...args];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmethodArgs = args;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = await channel.call(propKey, methodArgs);\n\n\t\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\t\tif (!disableMarshalling) {\n\t\t\t\t\t\t\treturn revive(result);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Property not found: ${String(propKey)}`);\n\t\t\t}\n\t\t}) as T;\n\t}\n\n\tfunction propertyIsEvent(name: string): boolean {\n\t\t// Assume a property is an event if it has a form of \"onSomething\"\n\t\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\n\t}\n\n\tfunction propertyIsDynamicEvent(name: string): boolean {\n\t\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\n\t\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\n\t}\n}\n\nconst colorTables = [\n\t['#2977B1', '#FC802D', '#34A13A', '#D3282F', '#9366BA'],\n\t['#8B564C', '#E177C0', '#7F7F7F', '#BBBE3D', '#2EBECD']\n];\n\nfunction prettyWithoutArrays(data: unknown): any {\n\tif (Array.isArray(data)) {\n\t\treturn data;\n\t}\n\tif (data && typeof data === 'object' && typeof data.toString === 'function') {\n\t\tconst result = data.toString();\n\t\tif (result !== '[object Object]') {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction pretty(data: unknown): any {\n\tif (Array.isArray(data)) {\n\t\treturn data.map(prettyWithoutArrays);\n\t}\n\treturn prettyWithoutArrays(data);\n}\n\nfunction logWithColors(direction: string, totalLength: number, msgLength: number, req: number, initiator: RequestInitiator, str: string, data: any): void {\n\tdata = pretty(data);\n\n\tconst colorTable = colorTables[initiator];\n\tconst color = colorTable[req % colorTable.length];\n\tlet args = [`%c[${direction}]%c[${String(totalLength).padStart(7, ' ')}]%c[len: ${String(msgLength).padStart(5, ' ')}]%c${String(req).padStart(5, ' ')} - ${str}`, 'color: darkgreen', 'color: grey', 'color: grey', `color: ${color}`];\n\tif (/\\($/.test(str)) {\n\t\targs = args.concat(data);\n\t\targs.push(')');\n\t} else {\n\t\targs.push(data);\n\t}\n\tconsole.log.apply(console, args as [string, ...string[]]);\n}\n\nexport class IPCLogger implements IIPCLogger {\n\tprivate _totalIncoming = 0;\n\tprivate _totalOutgoing = 0;\n\n\tconstructor(\n\t\tprivate readonly _outgoingPrefix: string,\n\t\tprivate readonly _incomingPrefix: string,\n\t) { }\n\n\tpublic logOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalOutgoing += msgLength;\n\t\tlogWithColors(this._outgoingPrefix, this._totalOutgoing, msgLength, requestId, initiator, str, data);\n\t}\n\n\tpublic logIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalIncoming += msgLength;\n\t\tlogWithColors(this._incomingPrefix, this._totalIncoming, msgLength, requestId, initiator, str, data);\n\t}\n}\n"]}