{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/parts/ipc/common/ipc.net.ts","vs/base/parts/ipc/common/ipc.net.ts"],"names":[],"mappings":"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","file":"ipc.net.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Disposable, DisposableStore, IDisposable } from '../../../common/lifecycle.js';\nimport { IIPCLogger, IMessagePassingProtocol, IPCClient } from './ipc.js';\n\nexport const enum SocketDiagnosticsEventType {\n\tCreated = 'created',\n\tRead = 'read',\n\tWrite = 'write',\n\tOpen = 'open',\n\tError = 'error',\n\tClose = 'close',\n\n\tBrowserWebSocketBlobReceived = 'browserWebSocketBlobReceived',\n\n\tNodeEndReceived = 'nodeEndReceived',\n\tNodeEndSent = 'nodeEndSent',\n\tNodeDrainBegin = 'nodeDrainBegin',\n\tNodeDrainEnd = 'nodeDrainEnd',\n\n\tzlibInflateError = 'zlibInflateError',\n\tzlibInflateData = 'zlibInflateData',\n\tzlibInflateInitialWrite = 'zlibInflateInitialWrite',\n\tzlibInflateInitialFlushFired = 'zlibInflateInitialFlushFired',\n\tzlibInflateWrite = 'zlibInflateWrite',\n\tzlibInflateFlushFired = 'zlibInflateFlushFired',\n\tzlibDeflateError = 'zlibDeflateError',\n\tzlibDeflateData = 'zlibDeflateData',\n\tzlibDeflateWrite = 'zlibDeflateWrite',\n\tzlibDeflateFlushFired = 'zlibDeflateFlushFired',\n\n\tWebSocketNodeSocketWrite = 'webSocketNodeSocketWrite',\n\tWebSocketNodeSocketPeekedHeader = 'webSocketNodeSocketPeekedHeader',\n\tWebSocketNodeSocketReadHeader = 'webSocketNodeSocketReadHeader',\n\tWebSocketNodeSocketReadData = 'webSocketNodeSocketReadData',\n\tWebSocketNodeSocketUnmaskedData = 'webSocketNodeSocketUnmaskedData',\n\tWebSocketNodeSocketDrainBegin = 'webSocketNodeSocketDrainBegin',\n\tWebSocketNodeSocketDrainEnd = 'webSocketNodeSocketDrainEnd',\n\n\tProtocolHeaderRead = 'protocolHeaderRead',\n\tProtocolMessageRead = 'protocolMessageRead',\n\tProtocolHeaderWrite = 'protocolHeaderWrite',\n\tProtocolMessageWrite = 'protocolMessageWrite',\n\tProtocolWrite = 'protocolWrite',\n}\n\nexport namespace SocketDiagnostics {\n\n\texport const enableDiagnostics = false;\n\n\texport interface IRecord {\n\t\ttimestamp: number;\n\t\tid: string;\n\t\tlabel: string;\n\t\ttype: SocketDiagnosticsEventType;\n\t\tbuff?: VSBuffer;\n\t\tdata?: any;\n\t}\n\n\texport const records: IRecord[] = [];\n\tconst socketIds = new WeakMap<any, string>();\n\tlet lastUsedSocketId = 0;\n\n\tfunction getSocketId(nativeObject: unknown, label: string): string {\n\t\tif (!socketIds.has(nativeObject)) {\n\t\t\tconst id = String(++lastUsedSocketId);\n\t\t\tsocketIds.set(nativeObject, id);\n\t\t}\n\t\treturn socketIds.get(nativeObject)!;\n\t}\n\n\texport function traceSocketEvent(nativeObject: unknown, socketDebugLabel: string, type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void {\n\t\tif (!enableDiagnostics) {\n\t\t\treturn;\n\t\t}\n\t\tconst id = getSocketId(nativeObject, socketDebugLabel);\n\n\t\tif (data instanceof VSBuffer || data instanceof Uint8Array || data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n\t\t\tconst copiedData = VSBuffer.alloc(data.byteLength);\n\t\t\tcopiedData.set(data);\n\t\t\trecords.push({ timestamp: Date.now(), id, label: socketDebugLabel, type, buff: copiedData });\n\t\t} else {\n\t\t\t// data is a custom object\n\t\t\trecords.push({ timestamp: Date.now(), id, label: socketDebugLabel, type, data: data });\n\t\t}\n\t}\n}\n\nexport const enum SocketCloseEventType {\n\tNodeSocketCloseEvent = 0,\n\tWebSocketCloseEvent = 1\n}\n\nexport interface NodeSocketCloseEvent {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: SocketCloseEventType.NodeSocketCloseEvent;\n\t/**\n\t * `true` if the socket had a transmission error.\n\t */\n\treadonly hadError: boolean;\n\t/**\n\t * Underlying error.\n\t */\n\treadonly error: Error | undefined;\n}\n\nexport interface WebSocketCloseEvent {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: SocketCloseEventType.WebSocketCloseEvent;\n\t/**\n\t * Returns the WebSocket connection close code provided by the server.\n\t */\n\treadonly code: number;\n\t/**\n\t * Returns the WebSocket connection close reason provided by the server.\n\t */\n\treadonly reason: string;\n\t/**\n\t * Returns true if the connection closed cleanly; false otherwise.\n\t */\n\treadonly wasClean: boolean;\n\t/**\n\t * Underlying event.\n\t */\n\treadonly event: any | undefined;\n}\n\nexport type SocketCloseEvent = NodeSocketCloseEvent | WebSocketCloseEvent | undefined;\n\nexport interface SocketTimeoutEvent {\n\treadonly unacknowledgedMsgCount: number;\n\treadonly timeSinceOldestUnacknowledgedMsg: number;\n\treadonly timeSinceLastReceivedSomeData: number;\n}\n\nexport interface ISocket extends IDisposable {\n\tonData(listener: (e: VSBuffer) => void): IDisposable;\n\tonClose(listener: (e: SocketCloseEvent) => void): IDisposable;\n\tonEnd(listener: () => void): IDisposable;\n\twrite(buffer: VSBuffer): void;\n\tend(): void;\n\tdrain(): Promise<void>;\n\n\ttraceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void;\n}\n\nlet emptyBuffer: VSBuffer | null = null;\nfunction getEmptyBuffer(): VSBuffer {\n\tif (!emptyBuffer) {\n\t\temptyBuffer = VSBuffer.alloc(0);\n\t}\n\treturn emptyBuffer;\n}\n\nexport class ChunkStream {\n\n\tprivate _chunks: VSBuffer[];\n\tprivate _totalLength: number;\n\n\tpublic get byteLength() {\n\t\treturn this._totalLength;\n\t}\n\n\tconstructor() {\n\t\tthis._chunks = [];\n\t\tthis._totalLength = 0;\n\t}\n\n\tpublic acceptChunk(buff: VSBuffer) {\n\t\tthis._chunks.push(buff);\n\t\tthis._totalLength += buff.byteLength;\n\t}\n\n\tpublic read(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, true);\n\t}\n\n\tpublic peek(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, false);\n\t}\n\n\tprivate _read(byteCount: number, advance: boolean): VSBuffer {\n\n\t\tif (byteCount === 0) {\n\t\t\treturn getEmptyBuffer();\n\t\t}\n\n\t\tif (byteCount > this._totalLength) {\n\t\t\tthrow new Error(`Cannot read so many bytes!`);\n\t\t}\n\n\t\tif (this._chunks[0].byteLength === byteCount) {\n\t\t\t// super fast path, precisely first chunk must be returned\n\t\t\tconst result = this._chunks[0];\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks.shift();\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif (this._chunks[0].byteLength > byteCount) {\n\t\t\t// fast path, the reading is entirely within the first chunk\n\t\t\tconst result = this._chunks[0].slice(0, byteCount);\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks[0] = this._chunks[0].slice(byteCount);\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tconst result = VSBuffer.alloc(byteCount);\n\t\tlet resultOffset = 0;\n\t\tlet chunkIndex = 0;\n\t\twhile (byteCount > 0) {\n\t\t\tconst chunk = this._chunks[chunkIndex];\n\t\t\tif (chunk.byteLength > byteCount) {\n\t\t\t\t// this chunk will survive\n\t\t\t\tconst chunkPart = chunk.slice(0, byteCount);\n\t\t\t\tresult.set(chunkPart, resultOffset);\n\t\t\t\tresultOffset += byteCount;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks[chunkIndex] = chunk.slice(byteCount);\n\t\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= byteCount;\n\t\t\t} else {\n\t\t\t\t// this chunk will be entirely read\n\t\t\t\tresult.set(chunk, resultOffset);\n\t\t\t\tresultOffset += chunk.byteLength;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks.shift();\n\t\t\t\t\tthis._totalLength -= chunk.byteLength;\n\t\t\t\t} else {\n\t\t\t\t\tchunkIndex++;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= chunk.byteLength;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nconst enum ProtocolMessageType {\n\tNone = 0,\n\tRegular = 1,\n\tControl = 2,\n\tAck = 3,\n\tDisconnect = 5,\n\tReplayRequest = 6,\n\tPause = 7,\n\tResume = 8,\n\tKeepAlive = 9\n}\n\nfunction protocolMessageTypeToString(messageType: ProtocolMessageType) {\n\tswitch (messageType) {\n\t\tcase ProtocolMessageType.None: return 'None';\n\t\tcase ProtocolMessageType.Regular: return 'Regular';\n\t\tcase ProtocolMessageType.Control: return 'Control';\n\t\tcase ProtocolMessageType.Ack: return 'Ack';\n\t\tcase ProtocolMessageType.Disconnect: return 'Disconnect';\n\t\tcase ProtocolMessageType.ReplayRequest: return 'ReplayRequest';\n\t\tcase ProtocolMessageType.Pause: return 'PauseWriting';\n\t\tcase ProtocolMessageType.Resume: return 'ResumeWriting';\n\t\tcase ProtocolMessageType.KeepAlive: return 'KeepAlive';\n\t}\n}\n\nexport const enum ProtocolConstants {\n\tHeaderLength = 13,\n\t/**\n\t * Send an Acknowledge message at most 2 seconds later...\n\t */\n\tAcknowledgeTime = 2000, // 2 seconds\n\t/**\n\t * If there is a sent message that has been unacknowledged for 20 seconds,\n\t * and we didn't see any incoming server data in the past 20 seconds,\n\t * then consider the connection has timed out.\n\t */\n\tTimeoutTime = 20000, // 20 seconds\n\t/**\n\t * If there is no reconnection within this time-frame, consider the connection permanently closed...\n\t */\n\tReconnectionGraceTime = 3 * 60 * 60 * 1000, // 3hrs\n\t/**\n\t * Maximal grace time between the first and the last reconnection...\n\t */\n\tReconnectionShortGraceTime = 5 * 60 * 1000, // 5min\n\t/**\n\t * Send a message every 5 seconds to avoid that the connection is closed by the OS.\n\t */\n\tKeepAliveSendTime = 5000, // 5 seconds\n}\n\nclass ProtocolMessage {\n\n\tpublic writtenTime: number;\n\n\tconstructor(\n\t\tpublic readonly type: ProtocolMessageType,\n\t\tpublic readonly id: number,\n\t\tpublic readonly ack: number,\n\t\tpublic readonly data: VSBuffer\n\t) {\n\t\tthis.writtenTime = 0;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this.data.byteLength;\n\t}\n}\n\nclass ProtocolReader extends Disposable {\n\n\tprivate readonly _socket: ISocket;\n\tprivate _isDisposed: boolean;\n\tprivate readonly _incomingData: ChunkStream;\n\tpublic lastReadTime: number;\n\n\tprivate readonly _onMessage = this._register(new Emitter<ProtocolMessage>());\n\tpublic readonly onMessage: Event<ProtocolMessage> = this._onMessage.event;\n\n\tprivate readonly _state = {\n\t\treadHead: true,\n\t\treadLen: ProtocolConstants.HeaderLength,\n\t\tmessageType: ProtocolMessageType.None,\n\t\tid: 0,\n\t\tack: 0\n\t};\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._isDisposed = false;\n\t\tthis._incomingData = new ChunkStream();\n\t\tthis._register(this._socket.onData(data => this.acceptChunk(data)));\n\t\tthis.lastReadTime = Date.now();\n\t}\n\n\tpublic acceptChunk(data: VSBuffer | null): void {\n\t\tif (!data || data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.lastReadTime = Date.now();\n\n\t\tthis._incomingData.acceptChunk(data);\n\n\t\twhile (this._incomingData.byteLength >= this._state.readLen) {\n\n\t\t\tconst buff = this._incomingData.read(this._state.readLen);\n\n\t\t\tif (this._state.readHead) {\n\t\t\t\t// buff is the header\n\n\t\t\t\t// save new state => next time will read the body\n\t\t\t\tthis._state.readHead = false;\n\t\t\t\tthis._state.readLen = buff.readUInt32BE(9);\n\t\t\t\tthis._state.messageType = buff.readUInt8(0);\n\t\t\t\tthis._state.id = buff.readUInt32BE(1);\n\t\t\t\tthis._state.ack = buff.readUInt32BE(5);\n\n\t\t\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolHeaderRead, { messageType: protocolMessageTypeToString(this._state.messageType), id: this._state.id, ack: this._state.ack, messageSize: this._state.readLen });\n\n\t\t\t} else {\n\t\t\t\t// buff is the body\n\t\t\t\tconst messageType = this._state.messageType;\n\t\t\t\tconst id = this._state.id;\n\t\t\t\tconst ack = this._state.ack;\n\n\t\t\t\t// save new state => next time will read the header\n\t\t\t\tthis._state.readHead = true;\n\t\t\t\tthis._state.readLen = ProtocolConstants.HeaderLength;\n\t\t\t\tthis._state.messageType = ProtocolMessageType.None;\n\t\t\t\tthis._state.id = 0;\n\t\t\t\tthis._state.ack = 0;\n\n\t\t\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolMessageRead, buff);\n\n\t\t\t\tthis._onMessage.fire(new ProtocolMessage(messageType, id, ack, buff));\n\n\t\t\t\tif (this._isDisposed) {\n\t\t\t\t\t// check if an event listener lead to our disposal\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic readEntireBuffer(): VSBuffer {\n\t\treturn this._incomingData.read(this._incomingData.byteLength);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n}\n\nclass ProtocolWriter {\n\n\tprivate _isDisposed: boolean;\n\tprivate _isPaused: boolean;\n\tprivate readonly _socket: ISocket;\n\tprivate _data: VSBuffer[];\n\tprivate _totalLength: number;\n\tpublic lastWriteTime: number;\n\n\tconstructor(socket: ISocket) {\n\t\tthis._isDisposed = false;\n\t\tthis._isPaused = false;\n\t\tthis._socket = socket;\n\t\tthis._data = [];\n\t\tthis._totalLength = 0;\n\t\tthis.lastWriteTime = 0;\n\t}\n\n\tpublic dispose(): void {\n\t\ttry {\n\t\t\tthis.flush();\n\t\t} catch (err) {\n\t\t\t// ignore error, since the socket could be already closed\n\t\t}\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic drain(): Promise<void> {\n\t\tthis.flush();\n\t\treturn this._socket.drain();\n\t}\n\n\tpublic flush(): void {\n\t\t// flush\n\t\tthis._writeNow();\n\t}\n\n\tpublic pause(): void {\n\t\tthis._isPaused = true;\n\t}\n\n\tpublic resume(): void {\n\t\tthis._isPaused = false;\n\t\tthis._scheduleWriting();\n\t}\n\n\tpublic write(msg: ProtocolMessage) {\n\t\tif (this._isDisposed) {\n\t\t\t// ignore: there could be left-over promises which complete and then\n\t\t\t// decide to write a response, etc...\n\t\t\treturn;\n\t\t}\n\t\tmsg.writtenTime = Date.now();\n\t\tthis.lastWriteTime = Date.now();\n\t\tconst header = VSBuffer.alloc(ProtocolConstants.HeaderLength);\n\t\theader.writeUInt8(msg.type, 0);\n\t\theader.writeUInt32BE(msg.id, 1);\n\t\theader.writeUInt32BE(msg.ack, 5);\n\t\theader.writeUInt32BE(msg.data.byteLength, 9);\n\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolHeaderWrite, { messageType: protocolMessageTypeToString(msg.type), id: msg.id, ack: msg.ack, messageSize: msg.data.byteLength });\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolMessageWrite, msg.data);\n\n\t\tthis._writeSoon(header, msg.data);\n\t}\n\n\tprivate _bufferAdd(head: VSBuffer, body: VSBuffer): boolean {\n\t\tconst wasEmpty = this._totalLength === 0;\n\t\tthis._data.push(head, body);\n\t\tthis._totalLength += head.byteLength + body.byteLength;\n\t\treturn wasEmpty;\n\t}\n\n\tprivate _bufferTake(): VSBuffer {\n\t\tconst ret = VSBuffer.concat(this._data, this._totalLength);\n\t\tthis._data.length = 0;\n\t\tthis._totalLength = 0;\n\t\treturn ret;\n\t}\n\n\tprivate _writeSoon(header: VSBuffer, data: VSBuffer): void {\n\t\tif (this._bufferAdd(header, data)) {\n\t\t\tthis._scheduleWriting();\n\t\t}\n\t}\n\n\tprivate _writeNowTimeout: Timeout | null = null;\n\tprivate _scheduleWriting(): void {\n\t\tif (this._writeNowTimeout) {\n\t\t\treturn;\n\t\t}\n\t\tthis._writeNowTimeout = setTimeout(() => {\n\t\t\tthis._writeNowTimeout = null;\n\t\t\tthis._writeNow();\n\t\t});\n\t}\n\n\tprivate _writeNow(): void {\n\t\tif (this._totalLength === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._isPaused) {\n\t\t\treturn;\n\t\t}\n\t\tconst data = this._bufferTake();\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolWrite, { byteLength: data.byteLength });\n\t\tthis._socket.write(data);\n\t}\n}\n\n/**\n * A message has the following format:\n * ```\n *     /-------------------------------|------\\\n *     |             HEADER            |      |\n *     |-------------------------------| DATA |\n *     | TYPE | ID | ACK | DATA_LENGTH |      |\n *     \\-------------------------------|------/\n * ```\n * The header is 9 bytes and consists of:\n *  - TYPE is 1 byte (ProtocolMessageType) - the message type\n *  - ID is 4 bytes (u32be) - the message id (can be 0 to indicate to be ignored)\n *  - ACK is 4 bytes (u32be) - the acknowledged message id (can be 0 to indicate to be ignored)\n *  - DATA_LENGTH is 4 bytes (u32be) - the length in bytes of DATA\n *\n * Only Regular messages are counted, other messages are not counted, nor acknowledged.\n */\nexport class Protocol extends Disposable implements IMessagePassingProtocol {\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\n\tprivate readonly _onMessage = new Emitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new Emitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._register(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._register(new ProtocolReader(this._socket));\n\n\t\tthis._register(this._socketReader.onMessage((msg) => {\n\t\t\tif (msg.type === ProtocolMessageType.Regular) {\n\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(this._socket.onClose(() => this._onDidDispose.fire()));\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tgetSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tsendDisconnect(): void {\n\t\t// Nothing to do...\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tthis._socketWriter.write(new ProtocolMessage(ProtocolMessageType.Regular, 0, 0, buffer));\n\t}\n}\n\nexport class Client<TContext = string> extends IPCClient<TContext> {\n\n\tstatic fromSocket<TContext = string>(socket: ISocket, id: TContext): Client<TContext> {\n\t\treturn new Client(new Protocol(socket), id);\n\t}\n\n\tget onDidDispose(): Event<void> { return this.protocol.onDidDispose; }\n\n\tconstructor(private protocol: Protocol | PersistentProtocol, id: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tsuper(protocol, id, ipcLogger);\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tconst socket = this.protocol.getSocket();\n\t\t// should be sent gracefully with a .flush(), but try to send it out as a\n\t\t// last resort here if nothing else:\n\t\tthis.protocol.sendDisconnect();\n\t\tthis.protocol.dispose();\n\t\tsocket.end();\n\t}\n}\n\n/**\n * Will ensure no messages are lost if there are no event listeners.\n */\nexport class BufferedEmitter<T> {\n\tprivate _emitter: Emitter<T>;\n\tpublic readonly event: Event<T>;\n\n\tprivate _hasListeners = false;\n\tprivate _isDeliveringMessages = false;\n\tprivate _bufferedMessages: T[] = [];\n\n\tconstructor() {\n\t\tthis._emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tthis._hasListeners = true;\n\t\t\t\t// it is important to deliver these messages after this call, but before\n\t\t\t\t// other messages have a chance to be received (to guarantee in order delivery)\n\t\t\t\t// that's why we're using here queueMicrotask and not other types of timeouts\n\t\t\t\tqueueMicrotask(() => this._deliverMessages());\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tthis._hasListeners = false;\n\t\t\t}\n\t\t});\n\n\t\tthis.event = this._emitter.event;\n\t}\n\n\tprivate _deliverMessages(): void {\n\t\tif (this._isDeliveringMessages) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isDeliveringMessages = true;\n\t\twhile (this._hasListeners && this._bufferedMessages.length > 0) {\n\t\t\tthis._emitter.fire(this._bufferedMessages.shift()!);\n\t\t}\n\t\tthis._isDeliveringMessages = false;\n\t}\n\n\tpublic fire(event: T): void {\n\t\tif (this._hasListeners) {\n\t\t\tif (this._bufferedMessages.length > 0) {\n\t\t\t\tthis._bufferedMessages.push(event);\n\t\t\t} else {\n\t\t\t\tthis._emitter.fire(event);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._bufferedMessages.push(event);\n\t\t}\n\t}\n\n\tpublic flushBuffer(): void {\n\t\tthis._bufferedMessages = [];\n\t}\n}\n\nclass QueueElement<T> {\n\tpublic readonly data: T;\n\tpublic next: QueueElement<T> | null;\n\n\tconstructor(data: T) {\n\t\tthis.data = data;\n\t\tthis.next = null;\n\t}\n}\n\nclass Queue<T> {\n\n\tprivate _first: QueueElement<T> | null;\n\tprivate _last: QueueElement<T> | null;\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t}\n\n\tpublic length(): number {\n\t\tlet result = 0;\n\t\tlet current = this._first;\n\t\twhile (current) {\n\t\t\tcurrent = current.next;\n\t\t\tresult++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic peek(): T | null {\n\t\tif (!this._first) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._first.data;\n\t}\n\n\tpublic toArray(): T[] {\n\t\tconst result: T[] = [];\n\t\tlet resultLen = 0;\n\t\tlet it = this._first;\n\t\twhile (it) {\n\t\t\tresult[resultLen++] = it.data;\n\t\t\tit = it.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic pop(): void {\n\t\tif (!this._first) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._first === this._last) {\n\t\t\tthis._first = null;\n\t\t\tthis._last = null;\n\t\t\treturn;\n\t\t}\n\t\tthis._first = this._first.next;\n\t}\n\n\tpublic push(item: T): void {\n\t\tconst element = new QueueElement(item);\n\t\tif (!this._first) {\n\t\t\tthis._first = element;\n\t\t\tthis._last = element;\n\t\t\treturn;\n\t\t}\n\t\tthis._last!.next = element;\n\t\tthis._last = element;\n\t}\n}\n\nclass LoadEstimator {\n\n\tprivate static _HISTORY_LENGTH = 10;\n\tprivate static _INSTANCE: LoadEstimator | null = null;\n\tpublic static getInstance(): LoadEstimator {\n\t\tif (!LoadEstimator._INSTANCE) {\n\t\t\tLoadEstimator._INSTANCE = new LoadEstimator();\n\t\t}\n\t\treturn LoadEstimator._INSTANCE;\n\t}\n\n\tprivate lastRuns: number[];\n\n\tconstructor() {\n\t\tthis.lastRuns = [];\n\t\tconst now = Date.now();\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tthis.lastRuns[i] = now - 1000 * i;\n\t\t}\n\t\tsetInterval(() => {\n\t\t\tfor (let i = LoadEstimator._HISTORY_LENGTH; i >= 1; i--) {\n\t\t\t\tthis.lastRuns[i] = this.lastRuns[i - 1];\n\t\t\t}\n\t\t\tthis.lastRuns[0] = Date.now();\n\t\t}, 1000);\n\t}\n\n\t/**\n\t * returns an estimative number, from 0 (low load) to 1 (high load)\n\t */\n\tprivate load(): number {\n\t\tconst now = Date.now();\n\t\tconst historyLimit = (1 + LoadEstimator._HISTORY_LENGTH) * 1000;\n\t\tlet score = 0;\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tif (now - this.lastRuns[i] <= historyLimit) {\n\t\t\t\tscore++;\n\t\t\t}\n\t\t}\n\t\treturn 1 - score / LoadEstimator._HISTORY_LENGTH;\n\t}\n\n\tpublic hasHighLoad(): boolean {\n\t\treturn this.load() >= 0.5;\n\t}\n}\n\nexport interface ILoadEstimator {\n\thasHighLoad(): boolean;\n}\n\nexport interface PersistentProtocolOptions {\n\t/**\n\t * The socket to use.\n\t */\n\tsocket: ISocket;\n\t/**\n\t * The initial chunk of data that has already been received from the socket.\n\t */\n\tinitialChunk?: VSBuffer | null;\n\t/**\n\t * The CPU load estimator to use.\n\t */\n\tloadEstimator?: ILoadEstimator;\n\t/**\n\t * Whether to send keep alive messages. Defaults to true.\n\t */\n\tsendKeepAlive?: boolean;\n}\n\n/**\n * Same as Protocol, but will actually track messages and acks.\n * Moreover, it will ensure no messages are lost if there are no event listeners.\n */\nexport class PersistentProtocol implements IMessagePassingProtocol {\n\n\tprivate _isReconnecting: boolean;\n\tprivate _didSendDisconnect?: boolean;\n\n\tprivate _outgoingUnackMsg: Queue<ProtocolMessage>;\n\tprivate _outgoingMsgId: number;\n\tprivate _outgoingAckId: number;\n\tprivate _outgoingAckTimeout: Timeout | null;\n\n\tprivate _incomingMsgId: number;\n\tprivate _incomingAckId: number;\n\tprivate _incomingMsgLastTime: number;\n\tprivate _incomingAckTimeout: Timeout | null;\n\n\tprivate _keepAliveInterval: Timeout | null;\n\n\tprivate _lastReplayRequestTime: number;\n\tprivate _lastSocketTimeoutTime: number;\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\t// eslint-disable-next-line local/code-no-potentially-unsafe-disposables\n\tprivate _socketDisposables: DisposableStore;\n\n\tprivate readonly _loadEstimator: ILoadEstimator;\n\tprivate readonly _shouldSendKeepAlive: boolean;\n\n\tprivate readonly _onControlMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onControlMessage: Event<VSBuffer> = this._onControlMessage.event;\n\n\tprivate readonly _onMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new BufferedEmitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tprivate readonly _onSocketClose = new BufferedEmitter<SocketCloseEvent>();\n\treadonly onSocketClose: Event<SocketCloseEvent> = this._onSocketClose.event;\n\n\tprivate readonly _onSocketTimeout = new BufferedEmitter<SocketTimeoutEvent>();\n\treadonly onSocketTimeout: Event<SocketTimeoutEvent> = this._onSocketTimeout.event;\n\n\tpublic get unacknowledgedCount(): number {\n\t\treturn this._outgoingMsgId - this._outgoingAckId;\n\t}\n\n\tconstructor(opts: PersistentProtocolOptions) {\n\t\tthis._loadEstimator = opts.loadEstimator ?? LoadEstimator.getInstance();\n\t\tthis._shouldSendKeepAlive = opts.sendKeepAlive ?? true;\n\t\tthis._isReconnecting = false;\n\t\tthis._outgoingUnackMsg = new Queue<ProtocolMessage>();\n\t\tthis._outgoingMsgId = 0;\n\t\tthis._outgoingAckId = 0;\n\t\tthis._outgoingAckTimeout = null;\n\n\t\tthis._incomingMsgId = 0;\n\t\tthis._incomingAckId = 0;\n\t\tthis._incomingMsgLastTime = 0;\n\t\tthis._incomingAckTimeout = null;\n\n\t\tthis._lastReplayRequestTime = 0;\n\t\tthis._lastSocketTimeoutTime = Date.now();\n\n\t\tthis._socketDisposables = new DisposableStore();\n\t\tthis._socket = opts.socket;\n\t\tthis._socketWriter = this._socketDisposables.add(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._socketDisposables.add(new ProtocolReader(this._socket));\n\t\tthis._socketDisposables.add(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.add(this._socket.onClose(e => this._onSocketClose.fire(e)));\n\n\t\tif (opts.initialChunk) {\n\t\t\tthis._socketReader.acceptChunk(opts.initialChunk);\n\t\t}\n\n\t\tif (this._shouldSendKeepAlive) {\n\t\t\tthis._keepAliveInterval = setInterval(() => {\n\t\t\t\tthis._sendKeepAlive();\n\t\t\t}, ProtocolConstants.KeepAliveSendTime);\n\t\t} else {\n\t\t\tthis._keepAliveInterval = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this._outgoingAckTimeout) {\n\t\t\tclearTimeout(this._outgoingAckTimeout);\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t}\n\t\tif (this._incomingAckTimeout) {\n\t\t\tclearTimeout(this._incomingAckTimeout);\n\t\t\tthis._incomingAckTimeout = null;\n\t\t}\n\t\tif (this._keepAliveInterval) {\n\t\t\tclearInterval(this._keepAliveInterval);\n\t\t\tthis._keepAliveInterval = null;\n\t\t}\n\t\tthis._socketDisposables.dispose();\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tsendDisconnect(): void {\n\t\tif (!this._didSendDisconnect) {\n\t\t\tthis._didSendDisconnect = true;\n\t\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Disconnect, 0, 0, getEmptyBuffer());\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._socketWriter.flush();\n\t\t}\n\t}\n\n\tsendPause(): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Pause, 0, 0, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tsendResume(): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Resume, 0, 0, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tpauseSocketWriting() {\n\t\tthis._socketWriter.pause();\n\t}\n\n\tpublic getSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tpublic getMillisSinceLastIncomingData(): number {\n\t\treturn Date.now() - this._socketReader.lastReadTime;\n\t}\n\n\tpublic beginAcceptReconnection(socket: ISocket, initialDataChunk: VSBuffer | null): void {\n\t\tthis._isReconnecting = true;\n\n\t\tthis._socketDisposables.dispose();\n\t\tthis._socketDisposables = new DisposableStore();\n\t\tthis._onControlMessage.flushBuffer();\n\t\tthis._onSocketClose.flushBuffer();\n\t\tthis._onSocketTimeout.flushBuffer();\n\t\tthis._socket.dispose();\n\n\t\tthis._lastReplayRequestTime = 0;\n\t\tthis._lastSocketTimeoutTime = Date.now();\n\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._socketDisposables.add(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._socketDisposables.add(new ProtocolReader(this._socket));\n\t\tthis._socketDisposables.add(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.add(this._socket.onClose(e => this._onSocketClose.fire(e)));\n\n\t\tthis._socketReader.acceptChunk(initialDataChunk);\n\t}\n\n\tpublic endAcceptReconnection(): void {\n\t\tthis._isReconnecting = false;\n\n\t\t// After a reconnection, let the other party know (again) which messages have been received.\n\t\t// (perhaps the other party didn't receive a previous ACK)\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\n\t\t// Send again all unacknowledged messages\n\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t}\n\t\tthis._recvAckCheck();\n\t}\n\n\tpublic acceptDisconnect(): void {\n\t\tthis._onDidDispose.fire();\n\t}\n\n\tprivate _receiveMessage(msg: ProtocolMessage): void {\n\t\tif (msg.ack > this._outgoingAckId) {\n\t\t\tthis._outgoingAckId = msg.ack;\n\t\t\tdo {\n\t\t\t\tconst first = this._outgoingUnackMsg.peek();\n\t\t\t\tif (first && first.id <= msg.ack) {\n\t\t\t\t\t// this message has been confirmed, remove it\n\t\t\t\t\tthis._outgoingUnackMsg.pop();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\t\t}\n\n\t\tswitch (msg.type) {\n\t\t\tcase ProtocolMessageType.None: {\n\t\t\t\t// N/A\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Regular: {\n\t\t\t\tif (msg.id > this._incomingMsgId) {\n\t\t\t\t\tif (msg.id !== this._incomingMsgId + 1) {\n\t\t\t\t\t\t// in case we missed some messages we ask the other party to resend them\n\t\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t\tif (now - this._lastReplayRequestTime > 10000) {\n\t\t\t\t\t\t\t// send a replay request at most once every 10s\n\t\t\t\t\t\t\tthis._lastReplayRequestTime = now;\n\t\t\t\t\t\t\tthis._socketWriter.write(new ProtocolMessage(ProtocolMessageType.ReplayRequest, 0, 0, getEmptyBuffer()));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._incomingMsgId = msg.id;\n\t\t\t\t\t\tthis._incomingMsgLastTime = Date.now();\n\t\t\t\t\t\tthis._sendAckCheck();\n\t\t\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Control: {\n\t\t\t\tthis._onControlMessage.fire(msg.data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Ack: {\n\t\t\t\t// nothing to do, .ack is handled above already\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Disconnect: {\n\t\t\t\tthis._onDidDispose.fire();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.ReplayRequest: {\n\t\t\t\t// Send again all unacknowledged messages\n\t\t\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\t\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t\t\t}\n\t\t\t\tthis._recvAckCheck();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Pause: {\n\t\t\t\tthis._socketWriter.pause();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Resume: {\n\t\t\t\tthis._socketWriter.resume();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.KeepAlive: {\n\t\t\t\t// nothing to do\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treadEntireBuffer(): VSBuffer {\n\t\treturn this._socketReader.readEntireBuffer();\n\t}\n\n\tflush(): void {\n\t\tthis._socketWriter.flush();\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tconst myId = ++this._outgoingMsgId;\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Regular, myId, this._incomingAckId, buffer);\n\t\tthis._outgoingUnackMsg.push(msg);\n\t\tif (!this._isReconnecting) {\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._recvAckCheck();\n\t\t}\n\t}\n\n\t/**\n\t * Send a message which will not be part of the regular acknowledge flow.\n\t * Use this for early control messages which are repeated in case of reconnection.\n\t */\n\tsendControl(buffer: VSBuffer): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Control, 0, 0, buffer);\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendAckCheck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._incomingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst timeSinceLastIncomingMsg = Date.now() - this._incomingMsgLastTime;\n\t\tif (timeSinceLastIncomingMsg >= ProtocolConstants.AcknowledgeTime) {\n\t\t\t// sufficient time has passed since this message has been received,\n\t\t\t// and no message from our side needed to be sent in the meantime,\n\t\t\t// so we will send a message containing only an ack.\n\t\t\tthis._sendAck();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckTimeout = setTimeout(() => {\n\t\t\tthis._incomingAckTimeout = null;\n\t\t\tthis._sendAckCheck();\n\t\t}, ProtocolConstants.AcknowledgeTime - timeSinceLastIncomingMsg + 5);\n\t}\n\n\tprivate _recvAckCheck(): void {\n\t\tif (this._outgoingMsgId <= this._outgoingAckId) {\n\t\t\t// everything has been acknowledged\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._outgoingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._isReconnecting) {\n\t\t\t// do not cause a timeout during reconnection,\n\t\t\t// because messages will not be actually written until `endAcceptReconnection`\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldestUnacknowledgedMsg = this._outgoingUnackMsg.peek()!;\n\t\tconst timeSinceOldestUnacknowledgedMsg = Date.now() - oldestUnacknowledgedMsg.writtenTime;\n\t\tconst timeSinceLastReceivedSomeData = Date.now() - this._socketReader.lastReadTime;\n\t\tconst timeSinceLastTimeout = Date.now() - this._lastSocketTimeoutTime;\n\n\t\tif (\n\t\t\ttimeSinceOldestUnacknowledgedMsg >= ProtocolConstants.TimeoutTime\n\t\t\t&& timeSinceLastReceivedSomeData >= ProtocolConstants.TimeoutTime\n\t\t\t&& timeSinceLastTimeout >= ProtocolConstants.TimeoutTime\n\t\t) {\n\t\t\t// It's been a long time since our sent message was acknowledged\n\t\t\t// and a long time since we received some data\n\n\t\t\t// But this might be caused by the event loop being busy and failing to read messages\n\t\t\tif (!this._loadEstimator.hasHighLoad()) {\n\t\t\t\t// Trash the socket\n\t\t\t\tthis._lastSocketTimeoutTime = Date.now();\n\t\t\t\tthis._onSocketTimeout.fire({\n\t\t\t\t\tunacknowledgedMsgCount: this._outgoingUnackMsg.length(),\n\t\t\t\t\ttimeSinceOldestUnacknowledgedMsg,\n\t\t\t\t\ttimeSinceLastReceivedSomeData\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst minimumTimeUntilTimeout = Math.max(\n\t\t\tProtocolConstants.TimeoutTime - timeSinceOldestUnacknowledgedMsg,\n\t\t\tProtocolConstants.TimeoutTime - timeSinceLastReceivedSomeData,\n\t\t\tProtocolConstants.TimeoutTime - timeSinceLastTimeout,\n\t\t\t500\n\t\t);\n\n\t\tthis._outgoingAckTimeout = setTimeout(() => {\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t\tthis._recvAckCheck();\n\t\t}, minimumTimeUntilTimeout);\n\t}\n\n\tprivate _sendAck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendKeepAlive(): void {\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.KeepAlive, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../common/buffer.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Disposable, DisposableStore, IDisposable } from '../../../common/lifecycle.js';\nimport { IIPCLogger, IMessagePassingProtocol, IPCClient } from './ipc.js';\n\nexport const enum SocketDiagnosticsEventType {\n\tCreated = 'created',\n\tRead = 'read',\n\tWrite = 'write',\n\tOpen = 'open',\n\tError = 'error',\n\tClose = 'close',\n\n\tBrowserWebSocketBlobReceived = 'browserWebSocketBlobReceived',\n\n\tNodeEndReceived = 'nodeEndReceived',\n\tNodeEndSent = 'nodeEndSent',\n\tNodeDrainBegin = 'nodeDrainBegin',\n\tNodeDrainEnd = 'nodeDrainEnd',\n\n\tzlibInflateError = 'zlibInflateError',\n\tzlibInflateData = 'zlibInflateData',\n\tzlibInflateInitialWrite = 'zlibInflateInitialWrite',\n\tzlibInflateInitialFlushFired = 'zlibInflateInitialFlushFired',\n\tzlibInflateWrite = 'zlibInflateWrite',\n\tzlibInflateFlushFired = 'zlibInflateFlushFired',\n\tzlibDeflateError = 'zlibDeflateError',\n\tzlibDeflateData = 'zlibDeflateData',\n\tzlibDeflateWrite = 'zlibDeflateWrite',\n\tzlibDeflateFlushFired = 'zlibDeflateFlushFired',\n\n\tWebSocketNodeSocketWrite = 'webSocketNodeSocketWrite',\n\tWebSocketNodeSocketPeekedHeader = 'webSocketNodeSocketPeekedHeader',\n\tWebSocketNodeSocketReadHeader = 'webSocketNodeSocketReadHeader',\n\tWebSocketNodeSocketReadData = 'webSocketNodeSocketReadData',\n\tWebSocketNodeSocketUnmaskedData = 'webSocketNodeSocketUnmaskedData',\n\tWebSocketNodeSocketDrainBegin = 'webSocketNodeSocketDrainBegin',\n\tWebSocketNodeSocketDrainEnd = 'webSocketNodeSocketDrainEnd',\n\n\tProtocolHeaderRead = 'protocolHeaderRead',\n\tProtocolMessageRead = 'protocolMessageRead',\n\tProtocolHeaderWrite = 'protocolHeaderWrite',\n\tProtocolMessageWrite = 'protocolMessageWrite',\n\tProtocolWrite = 'protocolWrite',\n}\n\nexport namespace SocketDiagnostics {\n\n\texport const enableDiagnostics = false;\n\n\texport interface IRecord {\n\t\ttimestamp: number;\n\t\tid: string;\n\t\tlabel: string;\n\t\ttype: SocketDiagnosticsEventType;\n\t\tbuff?: VSBuffer;\n\t\tdata?: any;\n\t}\n\n\texport const records: IRecord[] = [];\n\tconst socketIds = new WeakMap<any, string>();\n\tlet lastUsedSocketId = 0;\n\n\tfunction getSocketId(nativeObject: unknown, label: string): string {\n\t\tif (!socketIds.has(nativeObject)) {\n\t\t\tconst id = String(++lastUsedSocketId);\n\t\t\tsocketIds.set(nativeObject, id);\n\t\t}\n\t\treturn socketIds.get(nativeObject)!;\n\t}\n\n\texport function traceSocketEvent(nativeObject: unknown, socketDebugLabel: string, type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void {\n\t\tif (!enableDiagnostics) {\n\t\t\treturn;\n\t\t}\n\t\tconst id = getSocketId(nativeObject, socketDebugLabel);\n\n\t\tif (data instanceof VSBuffer || data instanceof Uint8Array || data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n\t\t\tconst copiedData = VSBuffer.alloc(data.byteLength);\n\t\t\tcopiedData.set(data);\n\t\t\trecords.push({ timestamp: Date.now(), id, label: socketDebugLabel, type, buff: copiedData });\n\t\t} else {\n\t\t\t// data is a custom object\n\t\t\trecords.push({ timestamp: Date.now(), id, label: socketDebugLabel, type, data: data });\n\t\t}\n\t}\n}\n\nexport const enum SocketCloseEventType {\n\tNodeSocketCloseEvent = 0,\n\tWebSocketCloseEvent = 1\n}\n\nexport interface NodeSocketCloseEvent {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: SocketCloseEventType.NodeSocketCloseEvent;\n\t/**\n\t * `true` if the socket had a transmission error.\n\t */\n\treadonly hadError: boolean;\n\t/**\n\t * Underlying error.\n\t */\n\treadonly error: Error | undefined;\n}\n\nexport interface WebSocketCloseEvent {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: SocketCloseEventType.WebSocketCloseEvent;\n\t/**\n\t * Returns the WebSocket connection close code provided by the server.\n\t */\n\treadonly code: number;\n\t/**\n\t * Returns the WebSocket connection close reason provided by the server.\n\t */\n\treadonly reason: string;\n\t/**\n\t * Returns true if the connection closed cleanly; false otherwise.\n\t */\n\treadonly wasClean: boolean;\n\t/**\n\t * Underlying event.\n\t */\n\treadonly event: any | undefined;\n}\n\nexport type SocketCloseEvent = NodeSocketCloseEvent | WebSocketCloseEvent | undefined;\n\nexport interface SocketTimeoutEvent {\n\treadonly unacknowledgedMsgCount: number;\n\treadonly timeSinceOldestUnacknowledgedMsg: number;\n\treadonly timeSinceLastReceivedSomeData: number;\n}\n\nexport interface ISocket extends IDisposable {\n\tonData(listener: (e: VSBuffer) => void): IDisposable;\n\tonClose(listener: (e: SocketCloseEvent) => void): IDisposable;\n\tonEnd(listener: () => void): IDisposable;\n\twrite(buffer: VSBuffer): void;\n\tend(): void;\n\tdrain(): Promise<void>;\n\n\ttraceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void;\n}\n\nlet emptyBuffer: VSBuffer | null = null;\nfunction getEmptyBuffer(): VSBuffer {\n\tif (!emptyBuffer) {\n\t\temptyBuffer = VSBuffer.alloc(0);\n\t}\n\treturn emptyBuffer;\n}\n\nexport class ChunkStream {\n\n\tprivate _chunks: VSBuffer[];\n\tprivate _totalLength: number;\n\n\tpublic get byteLength() {\n\t\treturn this._totalLength;\n\t}\n\n\tconstructor() {\n\t\tthis._chunks = [];\n\t\tthis._totalLength = 0;\n\t}\n\n\tpublic acceptChunk(buff: VSBuffer) {\n\t\tthis._chunks.push(buff);\n\t\tthis._totalLength += buff.byteLength;\n\t}\n\n\tpublic read(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, true);\n\t}\n\n\tpublic peek(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, false);\n\t}\n\n\tprivate _read(byteCount: number, advance: boolean): VSBuffer {\n\n\t\tif (byteCount === 0) {\n\t\t\treturn getEmptyBuffer();\n\t\t}\n\n\t\tif (byteCount > this._totalLength) {\n\t\t\tthrow new Error(`Cannot read so many bytes!`);\n\t\t}\n\n\t\tif (this._chunks[0].byteLength === byteCount) {\n\t\t\t// super fast path, precisely first chunk must be returned\n\t\t\tconst result = this._chunks[0];\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks.shift();\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif (this._chunks[0].byteLength > byteCount) {\n\t\t\t// fast path, the reading is entirely within the first chunk\n\t\t\tconst result = this._chunks[0].slice(0, byteCount);\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks[0] = this._chunks[0].slice(byteCount);\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tconst result = VSBuffer.alloc(byteCount);\n\t\tlet resultOffset = 0;\n\t\tlet chunkIndex = 0;\n\t\twhile (byteCount > 0) {\n\t\t\tconst chunk = this._chunks[chunkIndex];\n\t\t\tif (chunk.byteLength > byteCount) {\n\t\t\t\t// this chunk will survive\n\t\t\t\tconst chunkPart = chunk.slice(0, byteCount);\n\t\t\t\tresult.set(chunkPart, resultOffset);\n\t\t\t\tresultOffset += byteCount;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks[chunkIndex] = chunk.slice(byteCount);\n\t\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= byteCount;\n\t\t\t} else {\n\t\t\t\t// this chunk will be entirely read\n\t\t\t\tresult.set(chunk, resultOffset);\n\t\t\t\tresultOffset += chunk.byteLength;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks.shift();\n\t\t\t\t\tthis._totalLength -= chunk.byteLength;\n\t\t\t\t} else {\n\t\t\t\t\tchunkIndex++;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= chunk.byteLength;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nconst enum ProtocolMessageType {\n\tNone = 0,\n\tRegular = 1,\n\tControl = 2,\n\tAck = 3,\n\tDisconnect = 5,\n\tReplayRequest = 6,\n\tPause = 7,\n\tResume = 8,\n\tKeepAlive = 9\n}\n\nfunction protocolMessageTypeToString(messageType: ProtocolMessageType) {\n\tswitch (messageType) {\n\t\tcase ProtocolMessageType.None: return 'None';\n\t\tcase ProtocolMessageType.Regular: return 'Regular';\n\t\tcase ProtocolMessageType.Control: return 'Control';\n\t\tcase ProtocolMessageType.Ack: return 'Ack';\n\t\tcase ProtocolMessageType.Disconnect: return 'Disconnect';\n\t\tcase ProtocolMessageType.ReplayRequest: return 'ReplayRequest';\n\t\tcase ProtocolMessageType.Pause: return 'PauseWriting';\n\t\tcase ProtocolMessageType.Resume: return 'ResumeWriting';\n\t\tcase ProtocolMessageType.KeepAlive: return 'KeepAlive';\n\t}\n}\n\nexport const enum ProtocolConstants {\n\tHeaderLength = 13,\n\t/**\n\t * Send an Acknowledge message at most 2 seconds later...\n\t */\n\tAcknowledgeTime = 2000, // 2 seconds\n\t/**\n\t * If there is a sent message that has been unacknowledged for 20 seconds,\n\t * and we didn't see any incoming server data in the past 20 seconds,\n\t * then consider the connection has timed out.\n\t */\n\tTimeoutTime = 20000, // 20 seconds\n\t/**\n\t * If there is no reconnection within this time-frame, consider the connection permanently closed...\n\t */\n\tReconnectionGraceTime = 3 * 60 * 60 * 1000, // 3hrs\n\t/**\n\t * Maximal grace time between the first and the last reconnection...\n\t */\n\tReconnectionShortGraceTime = 5 * 60 * 1000, // 5min\n\t/**\n\t * Send a message every 5 seconds to avoid that the connection is closed by the OS.\n\t */\n\tKeepAliveSendTime = 5000, // 5 seconds\n}\n\nclass ProtocolMessage {\n\n\tpublic writtenTime: number;\n\n\tconstructor(\n\t\tpublic readonly type: ProtocolMessageType,\n\t\tpublic readonly id: number,\n\t\tpublic readonly ack: number,\n\t\tpublic readonly data: VSBuffer\n\t) {\n\t\tthis.writtenTime = 0;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this.data.byteLength;\n\t}\n}\n\nclass ProtocolReader extends Disposable {\n\n\tprivate readonly _socket: ISocket;\n\tprivate _isDisposed: boolean;\n\tprivate readonly _incomingData: ChunkStream;\n\tpublic lastReadTime: number;\n\n\tprivate readonly _onMessage = this._register(new Emitter<ProtocolMessage>());\n\tpublic readonly onMessage: Event<ProtocolMessage> = this._onMessage.event;\n\n\tprivate readonly _state = {\n\t\treadHead: true,\n\t\treadLen: ProtocolConstants.HeaderLength,\n\t\tmessageType: ProtocolMessageType.None,\n\t\tid: 0,\n\t\tack: 0\n\t};\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._isDisposed = false;\n\t\tthis._incomingData = new ChunkStream();\n\t\tthis._register(this._socket.onData(data => this.acceptChunk(data)));\n\t\tthis.lastReadTime = Date.now();\n\t}\n\n\tpublic acceptChunk(data: VSBuffer | null): void {\n\t\tif (!data || data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.lastReadTime = Date.now();\n\n\t\tthis._incomingData.acceptChunk(data);\n\n\t\twhile (this._incomingData.byteLength >= this._state.readLen) {\n\n\t\t\tconst buff = this._incomingData.read(this._state.readLen);\n\n\t\t\tif (this._state.readHead) {\n\t\t\t\t// buff is the header\n\n\t\t\t\t// save new state => next time will read the body\n\t\t\t\tthis._state.readHead = false;\n\t\t\t\tthis._state.readLen = buff.readUInt32BE(9);\n\t\t\t\tthis._state.messageType = buff.readUInt8(0);\n\t\t\t\tthis._state.id = buff.readUInt32BE(1);\n\t\t\t\tthis._state.ack = buff.readUInt32BE(5);\n\n\t\t\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolHeaderRead, { messageType: protocolMessageTypeToString(this._state.messageType), id: this._state.id, ack: this._state.ack, messageSize: this._state.readLen });\n\n\t\t\t} else {\n\t\t\t\t// buff is the body\n\t\t\t\tconst messageType = this._state.messageType;\n\t\t\t\tconst id = this._state.id;\n\t\t\t\tconst ack = this._state.ack;\n\n\t\t\t\t// save new state => next time will read the header\n\t\t\t\tthis._state.readHead = true;\n\t\t\t\tthis._state.readLen = ProtocolConstants.HeaderLength;\n\t\t\t\tthis._state.messageType = ProtocolMessageType.None;\n\t\t\t\tthis._state.id = 0;\n\t\t\t\tthis._state.ack = 0;\n\n\t\t\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolMessageRead, buff);\n\n\t\t\t\tthis._onMessage.fire(new ProtocolMessage(messageType, id, ack, buff));\n\n\t\t\t\tif (this._isDisposed) {\n\t\t\t\t\t// check if an event listener lead to our disposal\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic readEntireBuffer(): VSBuffer {\n\t\treturn this._incomingData.read(this._incomingData.byteLength);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n}\n\nclass ProtocolWriter {\n\n\tprivate _isDisposed: boolean;\n\tprivate _isPaused: boolean;\n\tprivate readonly _socket: ISocket;\n\tprivate _data: VSBuffer[];\n\tprivate _totalLength: number;\n\tpublic lastWriteTime: number;\n\n\tconstructor(socket: ISocket) {\n\t\tthis._isDisposed = false;\n\t\tthis._isPaused = false;\n\t\tthis._socket = socket;\n\t\tthis._data = [];\n\t\tthis._totalLength = 0;\n\t\tthis.lastWriteTime = 0;\n\t}\n\n\tpublic dispose(): void {\n\t\ttry {\n\t\t\tthis.flush();\n\t\t} catch (err) {\n\t\t\t// ignore error, since the socket could be already closed\n\t\t}\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic drain(): Promise<void> {\n\t\tthis.flush();\n\t\treturn this._socket.drain();\n\t}\n\n\tpublic flush(): void {\n\t\t// flush\n\t\tthis._writeNow();\n\t}\n\n\tpublic pause(): void {\n\t\tthis._isPaused = true;\n\t}\n\n\tpublic resume(): void {\n\t\tthis._isPaused = false;\n\t\tthis._scheduleWriting();\n\t}\n\n\tpublic write(msg: ProtocolMessage) {\n\t\tif (this._isDisposed) {\n\t\t\t// ignore: there could be left-over promises which complete and then\n\t\t\t// decide to write a response, etc...\n\t\t\treturn;\n\t\t}\n\t\tmsg.writtenTime = Date.now();\n\t\tthis.lastWriteTime = Date.now();\n\t\tconst header = VSBuffer.alloc(ProtocolConstants.HeaderLength);\n\t\theader.writeUInt8(msg.type, 0);\n\t\theader.writeUInt32BE(msg.id, 1);\n\t\theader.writeUInt32BE(msg.ack, 5);\n\t\theader.writeUInt32BE(msg.data.byteLength, 9);\n\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolHeaderWrite, { messageType: protocolMessageTypeToString(msg.type), id: msg.id, ack: msg.ack, messageSize: msg.data.byteLength });\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolMessageWrite, msg.data);\n\n\t\tthis._writeSoon(header, msg.data);\n\t}\n\n\tprivate _bufferAdd(head: VSBuffer, body: VSBuffer): boolean {\n\t\tconst wasEmpty = this._totalLength === 0;\n\t\tthis._data.push(head, body);\n\t\tthis._totalLength += head.byteLength + body.byteLength;\n\t\treturn wasEmpty;\n\t}\n\n\tprivate _bufferTake(): VSBuffer {\n\t\tconst ret = VSBuffer.concat(this._data, this._totalLength);\n\t\tthis._data.length = 0;\n\t\tthis._totalLength = 0;\n\t\treturn ret;\n\t}\n\n\tprivate _writeSoon(header: VSBuffer, data: VSBuffer): void {\n\t\tif (this._bufferAdd(header, data)) {\n\t\t\tthis._scheduleWriting();\n\t\t}\n\t}\n\n\tprivate _writeNowTimeout: Timeout | null = null;\n\tprivate _scheduleWriting(): void {\n\t\tif (this._writeNowTimeout) {\n\t\t\treturn;\n\t\t}\n\t\tthis._writeNowTimeout = setTimeout(() => {\n\t\t\tthis._writeNowTimeout = null;\n\t\t\tthis._writeNow();\n\t\t});\n\t}\n\n\tprivate _writeNow(): void {\n\t\tif (this._totalLength === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._isPaused) {\n\t\t\treturn;\n\t\t}\n\t\tconst data = this._bufferTake();\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolWrite, { byteLength: data.byteLength });\n\t\tthis._socket.write(data);\n\t}\n}\n\n/**\n * A message has the following format:\n * ```\n *     /-------------------------------|------\\\n *     |             HEADER            |      |\n *     |-------------------------------| DATA |\n *     | TYPE | ID | ACK | DATA_LENGTH |      |\n *     \\-------------------------------|------/\n * ```\n * The header is 9 bytes and consists of:\n *  - TYPE is 1 byte (ProtocolMessageType) - the message type\n *  - ID is 4 bytes (u32be) - the message id (can be 0 to indicate to be ignored)\n *  - ACK is 4 bytes (u32be) - the acknowledged message id (can be 0 to indicate to be ignored)\n *  - DATA_LENGTH is 4 bytes (u32be) - the length in bytes of DATA\n *\n * Only Regular messages are counted, other messages are not counted, nor acknowledged.\n */\nexport class Protocol extends Disposable implements IMessagePassingProtocol {\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\n\tprivate readonly _onMessage = new Emitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new Emitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._register(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._register(new ProtocolReader(this._socket));\n\n\t\tthis._register(this._socketReader.onMessage((msg) => {\n\t\t\tif (msg.type === ProtocolMessageType.Regular) {\n\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(this._socket.onClose(() => this._onDidDispose.fire()));\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tgetSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tsendDisconnect(): void {\n\t\t// Nothing to do...\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tthis._socketWriter.write(new ProtocolMessage(ProtocolMessageType.Regular, 0, 0, buffer));\n\t}\n}\n\nexport class Client<TContext = string> extends IPCClient<TContext> {\n\n\tstatic fromSocket<TContext = string>(socket: ISocket, id: TContext): Client<TContext> {\n\t\treturn new Client(new Protocol(socket), id);\n\t}\n\n\tget onDidDispose(): Event<void> { return this.protocol.onDidDispose; }\n\n\tconstructor(private protocol: Protocol | PersistentProtocol, id: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tsuper(protocol, id, ipcLogger);\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tconst socket = this.protocol.getSocket();\n\t\t// should be sent gracefully with a .flush(), but try to send it out as a\n\t\t// last resort here if nothing else:\n\t\tthis.protocol.sendDisconnect();\n\t\tthis.protocol.dispose();\n\t\tsocket.end();\n\t}\n}\n\n/**\n * Will ensure no messages are lost if there are no event listeners.\n */\nexport class BufferedEmitter<T> {\n\tprivate _emitter: Emitter<T>;\n\tpublic readonly event: Event<T>;\n\n\tprivate _hasListeners = false;\n\tprivate _isDeliveringMessages = false;\n\tprivate _bufferedMessages: T[] = [];\n\n\tconstructor() {\n\t\tthis._emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tthis._hasListeners = true;\n\t\t\t\t// it is important to deliver these messages after this call, but before\n\t\t\t\t// other messages have a chance to be received (to guarantee in order delivery)\n\t\t\t\t// that's why we're using here queueMicrotask and not other types of timeouts\n\t\t\t\tqueueMicrotask(() => this._deliverMessages());\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tthis._hasListeners = false;\n\t\t\t}\n\t\t});\n\n\t\tthis.event = this._emitter.event;\n\t}\n\n\tprivate _deliverMessages(): void {\n\t\tif (this._isDeliveringMessages) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isDeliveringMessages = true;\n\t\twhile (this._hasListeners && this._bufferedMessages.length > 0) {\n\t\t\tthis._emitter.fire(this._bufferedMessages.shift()!);\n\t\t}\n\t\tthis._isDeliveringMessages = false;\n\t}\n\n\tpublic fire(event: T): void {\n\t\tif (this._hasListeners) {\n\t\t\tif (this._bufferedMessages.length > 0) {\n\t\t\t\tthis._bufferedMessages.push(event);\n\t\t\t} else {\n\t\t\t\tthis._emitter.fire(event);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._bufferedMessages.push(event);\n\t\t}\n\t}\n\n\tpublic flushBuffer(): void {\n\t\tthis._bufferedMessages = [];\n\t}\n}\n\nclass QueueElement<T> {\n\tpublic readonly data: T;\n\tpublic next: QueueElement<T> | null;\n\n\tconstructor(data: T) {\n\t\tthis.data = data;\n\t\tthis.next = null;\n\t}\n}\n\nclass Queue<T> {\n\n\tprivate _first: QueueElement<T> | null;\n\tprivate _last: QueueElement<T> | null;\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t}\n\n\tpublic length(): number {\n\t\tlet result = 0;\n\t\tlet current = this._first;\n\t\twhile (current) {\n\t\t\tcurrent = current.next;\n\t\t\tresult++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic peek(): T | null {\n\t\tif (!this._first) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._first.data;\n\t}\n\n\tpublic toArray(): T[] {\n\t\tconst result: T[] = [];\n\t\tlet resultLen = 0;\n\t\tlet it = this._first;\n\t\twhile (it) {\n\t\t\tresult[resultLen++] = it.data;\n\t\t\tit = it.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic pop(): void {\n\t\tif (!this._first) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._first === this._last) {\n\t\t\tthis._first = null;\n\t\t\tthis._last = null;\n\t\t\treturn;\n\t\t}\n\t\tthis._first = this._first.next;\n\t}\n\n\tpublic push(item: T): void {\n\t\tconst element = new QueueElement(item);\n\t\tif (!this._first) {\n\t\t\tthis._first = element;\n\t\t\tthis._last = element;\n\t\t\treturn;\n\t\t}\n\t\tthis._last!.next = element;\n\t\tthis._last = element;\n\t}\n}\n\nclass LoadEstimator {\n\n\tprivate static _HISTORY_LENGTH = 10;\n\tprivate static _INSTANCE: LoadEstimator | null = null;\n\tpublic static getInstance(): LoadEstimator {\n\t\tif (!LoadEstimator._INSTANCE) {\n\t\t\tLoadEstimator._INSTANCE = new LoadEstimator();\n\t\t}\n\t\treturn LoadEstimator._INSTANCE;\n\t}\n\n\tprivate lastRuns: number[];\n\n\tconstructor() {\n\t\tthis.lastRuns = [];\n\t\tconst now = Date.now();\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tthis.lastRuns[i] = now - 1000 * i;\n\t\t}\n\t\tsetInterval(() => {\n\t\t\tfor (let i = LoadEstimator._HISTORY_LENGTH; i >= 1; i--) {\n\t\t\t\tthis.lastRuns[i] = this.lastRuns[i - 1];\n\t\t\t}\n\t\t\tthis.lastRuns[0] = Date.now();\n\t\t}, 1000);\n\t}\n\n\t/**\n\t * returns an estimative number, from 0 (low load) to 1 (high load)\n\t */\n\tprivate load(): number {\n\t\tconst now = Date.now();\n\t\tconst historyLimit = (1 + LoadEstimator._HISTORY_LENGTH) * 1000;\n\t\tlet score = 0;\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tif (now - this.lastRuns[i] <= historyLimit) {\n\t\t\t\tscore++;\n\t\t\t}\n\t\t}\n\t\treturn 1 - score / LoadEstimator._HISTORY_LENGTH;\n\t}\n\n\tpublic hasHighLoad(): boolean {\n\t\treturn this.load() >= 0.5;\n\t}\n}\n\nexport interface ILoadEstimator {\n\thasHighLoad(): boolean;\n}\n\nexport interface PersistentProtocolOptions {\n\t/**\n\t * The socket to use.\n\t */\n\tsocket: ISocket;\n\t/**\n\t * The initial chunk of data that has already been received from the socket.\n\t */\n\tinitialChunk?: VSBuffer | null;\n\t/**\n\t * The CPU load estimator to use.\n\t */\n\tloadEstimator?: ILoadEstimator;\n\t/**\n\t * Whether to send keep alive messages. Defaults to true.\n\t */\n\tsendKeepAlive?: boolean;\n}\n\n/**\n * Same as Protocol, but will actually track messages and acks.\n * Moreover, it will ensure no messages are lost if there are no event listeners.\n */\nexport class PersistentProtocol implements IMessagePassingProtocol {\n\n\tprivate _isReconnecting: boolean;\n\tprivate _didSendDisconnect?: boolean;\n\n\tprivate _outgoingUnackMsg: Queue<ProtocolMessage>;\n\tprivate _outgoingMsgId: number;\n\tprivate _outgoingAckId: number;\n\tprivate _outgoingAckTimeout: Timeout | null;\n\n\tprivate _incomingMsgId: number;\n\tprivate _incomingAckId: number;\n\tprivate _incomingMsgLastTime: number;\n\tprivate _incomingAckTimeout: Timeout | null;\n\n\tprivate _keepAliveInterval: Timeout | null;\n\n\tprivate _lastReplayRequestTime: number;\n\tprivate _lastSocketTimeoutTime: number;\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\t// eslint-disable-next-line local/code-no-potentially-unsafe-disposables\n\tprivate _socketDisposables: DisposableStore;\n\n\tprivate readonly _loadEstimator: ILoadEstimator;\n\tprivate readonly _shouldSendKeepAlive: boolean;\n\n\tprivate readonly _onControlMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onControlMessage: Event<VSBuffer> = this._onControlMessage.event;\n\n\tprivate readonly _onMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new BufferedEmitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tprivate readonly _onSocketClose = new BufferedEmitter<SocketCloseEvent>();\n\treadonly onSocketClose: Event<SocketCloseEvent> = this._onSocketClose.event;\n\n\tprivate readonly _onSocketTimeout = new BufferedEmitter<SocketTimeoutEvent>();\n\treadonly onSocketTimeout: Event<SocketTimeoutEvent> = this._onSocketTimeout.event;\n\n\tpublic get unacknowledgedCount(): number {\n\t\treturn this._outgoingMsgId - this._outgoingAckId;\n\t}\n\n\tconstructor(opts: PersistentProtocolOptions) {\n\t\tthis._loadEstimator = opts.loadEstimator ?? LoadEstimator.getInstance();\n\t\tthis._shouldSendKeepAlive = opts.sendKeepAlive ?? true;\n\t\tthis._isReconnecting = false;\n\t\tthis._outgoingUnackMsg = new Queue<ProtocolMessage>();\n\t\tthis._outgoingMsgId = 0;\n\t\tthis._outgoingAckId = 0;\n\t\tthis._outgoingAckTimeout = null;\n\n\t\tthis._incomingMsgId = 0;\n\t\tthis._incomingAckId = 0;\n\t\tthis._incomingMsgLastTime = 0;\n\t\tthis._incomingAckTimeout = null;\n\n\t\tthis._lastReplayRequestTime = 0;\n\t\tthis._lastSocketTimeoutTime = Date.now();\n\n\t\tthis._socketDisposables = new DisposableStore();\n\t\tthis._socket = opts.socket;\n\t\tthis._socketWriter = this._socketDisposables.add(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._socketDisposables.add(new ProtocolReader(this._socket));\n\t\tthis._socketDisposables.add(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.add(this._socket.onClose(e => this._onSocketClose.fire(e)));\n\n\t\tif (opts.initialChunk) {\n\t\t\tthis._socketReader.acceptChunk(opts.initialChunk);\n\t\t}\n\n\t\tif (this._shouldSendKeepAlive) {\n\t\t\tthis._keepAliveInterval = setInterval(() => {\n\t\t\t\tthis._sendKeepAlive();\n\t\t\t}, ProtocolConstants.KeepAliveSendTime);\n\t\t} else {\n\t\t\tthis._keepAliveInterval = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this._outgoingAckTimeout) {\n\t\t\tclearTimeout(this._outgoingAckTimeout);\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t}\n\t\tif (this._incomingAckTimeout) {\n\t\t\tclearTimeout(this._incomingAckTimeout);\n\t\t\tthis._incomingAckTimeout = null;\n\t\t}\n\t\tif (this._keepAliveInterval) {\n\t\t\tclearInterval(this._keepAliveInterval);\n\t\t\tthis._keepAliveInterval = null;\n\t\t}\n\t\tthis._socketDisposables.dispose();\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tsendDisconnect(): void {\n\t\tif (!this._didSendDisconnect) {\n\t\t\tthis._didSendDisconnect = true;\n\t\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Disconnect, 0, 0, getEmptyBuffer());\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._socketWriter.flush();\n\t\t}\n\t}\n\n\tsendPause(): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Pause, 0, 0, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tsendResume(): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Resume, 0, 0, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tpauseSocketWriting() {\n\t\tthis._socketWriter.pause();\n\t}\n\n\tpublic getSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tpublic getMillisSinceLastIncomingData(): number {\n\t\treturn Date.now() - this._socketReader.lastReadTime;\n\t}\n\n\tpublic beginAcceptReconnection(socket: ISocket, initialDataChunk: VSBuffer | null): void {\n\t\tthis._isReconnecting = true;\n\n\t\tthis._socketDisposables.dispose();\n\t\tthis._socketDisposables = new DisposableStore();\n\t\tthis._onControlMessage.flushBuffer();\n\t\tthis._onSocketClose.flushBuffer();\n\t\tthis._onSocketTimeout.flushBuffer();\n\t\tthis._socket.dispose();\n\n\t\tthis._lastReplayRequestTime = 0;\n\t\tthis._lastSocketTimeoutTime = Date.now();\n\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._socketDisposables.add(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._socketDisposables.add(new ProtocolReader(this._socket));\n\t\tthis._socketDisposables.add(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.add(this._socket.onClose(e => this._onSocketClose.fire(e)));\n\n\t\tthis._socketReader.acceptChunk(initialDataChunk);\n\t}\n\n\tpublic endAcceptReconnection(): void {\n\t\tthis._isReconnecting = false;\n\n\t\t// After a reconnection, let the other party know (again) which messages have been received.\n\t\t// (perhaps the other party didn't receive a previous ACK)\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\n\t\t// Send again all unacknowledged messages\n\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t}\n\t\tthis._recvAckCheck();\n\t}\n\n\tpublic acceptDisconnect(): void {\n\t\tthis._onDidDispose.fire();\n\t}\n\n\tprivate _receiveMessage(msg: ProtocolMessage): void {\n\t\tif (msg.ack > this._outgoingAckId) {\n\t\t\tthis._outgoingAckId = msg.ack;\n\t\t\tdo {\n\t\t\t\tconst first = this._outgoingUnackMsg.peek();\n\t\t\t\tif (first && first.id <= msg.ack) {\n\t\t\t\t\t// this message has been confirmed, remove it\n\t\t\t\t\tthis._outgoingUnackMsg.pop();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\t\t}\n\n\t\tswitch (msg.type) {\n\t\t\tcase ProtocolMessageType.None: {\n\t\t\t\t// N/A\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Regular: {\n\t\t\t\tif (msg.id > this._incomingMsgId) {\n\t\t\t\t\tif (msg.id !== this._incomingMsgId + 1) {\n\t\t\t\t\t\t// in case we missed some messages we ask the other party to resend them\n\t\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t\tif (now - this._lastReplayRequestTime > 10000) {\n\t\t\t\t\t\t\t// send a replay request at most once every 10s\n\t\t\t\t\t\t\tthis._lastReplayRequestTime = now;\n\t\t\t\t\t\t\tthis._socketWriter.write(new ProtocolMessage(ProtocolMessageType.ReplayRequest, 0, 0, getEmptyBuffer()));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._incomingMsgId = msg.id;\n\t\t\t\t\t\tthis._incomingMsgLastTime = Date.now();\n\t\t\t\t\t\tthis._sendAckCheck();\n\t\t\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Control: {\n\t\t\t\tthis._onControlMessage.fire(msg.data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Ack: {\n\t\t\t\t// nothing to do, .ack is handled above already\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Disconnect: {\n\t\t\t\tthis._onDidDispose.fire();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.ReplayRequest: {\n\t\t\t\t// Send again all unacknowledged messages\n\t\t\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\t\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t\t\t}\n\t\t\t\tthis._recvAckCheck();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Pause: {\n\t\t\t\tthis._socketWriter.pause();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Resume: {\n\t\t\t\tthis._socketWriter.resume();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.KeepAlive: {\n\t\t\t\t// nothing to do\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treadEntireBuffer(): VSBuffer {\n\t\treturn this._socketReader.readEntireBuffer();\n\t}\n\n\tflush(): void {\n\t\tthis._socketWriter.flush();\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tconst myId = ++this._outgoingMsgId;\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Regular, myId, this._incomingAckId, buffer);\n\t\tthis._outgoingUnackMsg.push(msg);\n\t\tif (!this._isReconnecting) {\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._recvAckCheck();\n\t\t}\n\t}\n\n\t/**\n\t * Send a message which will not be part of the regular acknowledge flow.\n\t * Use this for early control messages which are repeated in case of reconnection.\n\t */\n\tsendControl(buffer: VSBuffer): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Control, 0, 0, buffer);\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendAckCheck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._incomingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst timeSinceLastIncomingMsg = Date.now() - this._incomingMsgLastTime;\n\t\tif (timeSinceLastIncomingMsg >= ProtocolConstants.AcknowledgeTime) {\n\t\t\t// sufficient time has passed since this message has been received,\n\t\t\t// and no message from our side needed to be sent in the meantime,\n\t\t\t// so we will send a message containing only an ack.\n\t\t\tthis._sendAck();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckTimeout = setTimeout(() => {\n\t\t\tthis._incomingAckTimeout = null;\n\t\t\tthis._sendAckCheck();\n\t\t}, ProtocolConstants.AcknowledgeTime - timeSinceLastIncomingMsg + 5);\n\t}\n\n\tprivate _recvAckCheck(): void {\n\t\tif (this._outgoingMsgId <= this._outgoingAckId) {\n\t\t\t// everything has been acknowledged\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._outgoingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._isReconnecting) {\n\t\t\t// do not cause a timeout during reconnection,\n\t\t\t// because messages will not be actually written until `endAcceptReconnection`\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldestUnacknowledgedMsg = this._outgoingUnackMsg.peek()!;\n\t\tconst timeSinceOldestUnacknowledgedMsg = Date.now() - oldestUnacknowledgedMsg.writtenTime;\n\t\tconst timeSinceLastReceivedSomeData = Date.now() - this._socketReader.lastReadTime;\n\t\tconst timeSinceLastTimeout = Date.now() - this._lastSocketTimeoutTime;\n\n\t\tif (\n\t\t\ttimeSinceOldestUnacknowledgedMsg >= ProtocolConstants.TimeoutTime\n\t\t\t&& timeSinceLastReceivedSomeData >= ProtocolConstants.TimeoutTime\n\t\t\t&& timeSinceLastTimeout >= ProtocolConstants.TimeoutTime\n\t\t) {\n\t\t\t// It's been a long time since our sent message was acknowledged\n\t\t\t// and a long time since we received some data\n\n\t\t\t// But this might be caused by the event loop being busy and failing to read messages\n\t\t\tif (!this._loadEstimator.hasHighLoad()) {\n\t\t\t\t// Trash the socket\n\t\t\t\tthis._lastSocketTimeoutTime = Date.now();\n\t\t\t\tthis._onSocketTimeout.fire({\n\t\t\t\t\tunacknowledgedMsgCount: this._outgoingUnackMsg.length(),\n\t\t\t\t\ttimeSinceOldestUnacknowledgedMsg,\n\t\t\t\t\ttimeSinceLastReceivedSomeData\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst minimumTimeUntilTimeout = Math.max(\n\t\t\tProtocolConstants.TimeoutTime - timeSinceOldestUnacknowledgedMsg,\n\t\t\tProtocolConstants.TimeoutTime - timeSinceLastReceivedSomeData,\n\t\t\tProtocolConstants.TimeoutTime - timeSinceLastTimeout,\n\t\t\t500\n\t\t);\n\n\t\tthis._outgoingAckTimeout = setTimeout(() => {\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t\tthis._recvAckCheck();\n\t\t}, minimumTimeUntilTimeout);\n\t}\n\n\tprivate _sendAck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendKeepAlive(): void {\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.KeepAlive, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n}\n"]}