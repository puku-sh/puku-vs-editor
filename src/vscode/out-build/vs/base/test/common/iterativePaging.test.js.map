{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/test/common/iterativePaging.test.ts","vs/base/test/common/iterativePaging.test.ts"],"names":[],"mappings":"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","file":"iterativePaging.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { CancellationToken, CancellationTokenSource } from '../../common/cancellation.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from './utils.js';\nimport { IterativePagedModel, IIterativePager, IIterativePage } from '../../common/paging.js';\n\nfunction createTestPager(pageSize: number, maxPages: number): IIterativePager<number> {\n\tlet currentPage = 0;\n\n\tconst createPage = (page: number): IIterativePage<number> => {\n\t\tconst start = page * pageSize;\n\t\tconst items: number[] = [];\n\t\tfor (let i = 0; i < pageSize; i++) {\n\t\t\titems.push(start + i);\n\t\t}\n\t\tconst hasMore = page + 1 < maxPages;\n\t\treturn { items, hasMore };\n\t};\n\n\treturn {\n\t\tfirstPage: createPage(currentPage++),\n\t\tgetNextPage: async (cancellationToken: CancellationToken): Promise<IIterativePage<number>> => {\n\t\t\tif (currentPage >= maxPages) {\n\t\t\t\treturn { items: [], hasMore: false };\n\t\t\t}\n\t\t\treturn createPage(currentPage++);\n\t\t}\n\t};\n}\n\nsuite('IterativePagedModel', () => {\n\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('initial state', () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Initially first page is loaded, so length should be 10 + 1 sentinel\n\t\tassert.strictEqual(model.length, 11);\n\t\tassert.strictEqual(model.isResolved(0), true);\n\t\tassert.strictEqual(model.isResolved(9), true);\n\t\tassert.strictEqual(model.isResolved(10), false); // sentinel\n\t});\n\n\ttest('load first page via sentinel access', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Access an item in the first page (already loaded)\n\t\tconst item = await model.resolve(0, CancellationToken.None);\n\n\t\tassert.strictEqual(item, 0);\n\t\tassert.strictEqual(model.length, 11); // 10 items + 1 sentinel\n\t\tassert.strictEqual(model.isResolved(0), true);\n\t\tassert.strictEqual(model.isResolved(9), true);\n\t\tassert.strictEqual(model.isResolved(10), false); // sentinel\n\t});\n\n\ttest('load multiple pages', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// First page already loaded\n\t\tassert.strictEqual(model.length, 11);\n\n\t\t// Load second page by accessing its sentinel\n\t\tawait model.resolve(10, CancellationToken.None);\n\t\tassert.strictEqual(model.length, 21); // 20 items + 1 sentinel\n\t\tassert.strictEqual(model.get(10), 10); // First item of second page\n\n\t\t// Load third (final) page\n\t\tawait model.resolve(20, CancellationToken.None);\n\t\tassert.strictEqual(model.length, 30); // 30 items, no sentinel (no more pages)\n\t});\n\n\ttest('onDidIncrementLength event fires correctly', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\t\tconst lengths: number[] = [];\n\n\t\tstore.add(model.onDidIncrementLength((length: number) => lengths.push(length)));\n\n\t\t// Load second page\n\t\tawait model.resolve(10, CancellationToken.None);\n\n\t\tassert.strictEqual(lengths.length, 1);\n\t\tassert.strictEqual(lengths[0], 21); // 20 items + 1 sentinel\n\n\t\t// Load third page\n\t\tawait model.resolve(20, CancellationToken.None);\n\n\t\tassert.strictEqual(lengths.length, 2);\n\t\tassert.strictEqual(lengths[1], 30); // 30 items, no sentinel\n\t});\n\n\ttest('accessing regular items does not trigger loading', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\tconst initialLength = model.length;\n\n\t\t// Access items within the loaded range\n\t\tassert.strictEqual(model.get(5), 5);\n\t\tassert.strictEqual(model.isResolved(5), true);\n\n\t\t// Length should not change\n\t\tassert.strictEqual(model.length, initialLength);\n\t});\n\n\ttest('reaching end of data removes sentinel', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Load all pages\n\t\tawait model.resolve(10, CancellationToken.None);  // Page 2\n\t\tawait model.resolve(20, CancellationToken.None);  // Page 3 (final)\n\n\t\t// After loading all data, there should be no more pages\n\t\tassert.strictEqual(model.length, 30); // Exactly 30 items, no sentinel\n\n\t\t// Accessing resolved items should work\n\t\tassert.strictEqual(model.isResolved(29), true);\n\t\tassert.strictEqual(model.isResolved(30), false);\n\t});\n\n\ttest('concurrent access to sentinel only loads once', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Access sentinel concurrently\n\t\tconst [item1, item2, item3] = await Promise.all([\n\t\t\tmodel.resolve(10, CancellationToken.None),\n\t\t\tmodel.resolve(10, CancellationToken.None),\n\t\t\tmodel.resolve(10, CancellationToken.None)\n\t\t]);\n\n\t\t// All should get the same item\n\t\tassert.strictEqual(item1, 10);\n\t\tassert.strictEqual(item2, 10);\n\t\tassert.strictEqual(item3, 10);\n\t\tassert.strictEqual(model.length, 21); // 20 items + 1 sentinel\n\t});\n\n\ttest('empty pager with no items', () => {\n\t\tconst emptyPager: IIterativePager<number> = {\n\t\t\tfirstPage: { items: [], hasMore: false },\n\t\t\tgetNextPage: async () => ({ items: [], hasMore: false })\n\t\t};\n\t\tconst model = store.add(new IterativePagedModel(emptyPager));\n\n\t\tassert.strictEqual(model.length, 0);\n\t\tassert.strictEqual(model.isResolved(0), false);\n\t});\n\n\ttest('single page pager with no more pages', () => {\n\t\tconst singlePagePager: IIterativePager<number> = {\n\t\t\tfirstPage: { items: [1, 2, 3], hasMore: false },\n\t\t\tgetNextPage: async () => ({ items: [], hasMore: false })\n\t\t};\n\t\tconst model = store.add(new IterativePagedModel(singlePagePager));\n\n\t\tassert.strictEqual(model.length, 3); // No sentinel\n\t\tassert.strictEqual(model.isResolved(0), true);\n\t\tassert.strictEqual(model.isResolved(2), true);\n\t\tassert.strictEqual(model.isResolved(3), false);\n\t\tassert.strictEqual(model.get(0), 1);\n\t\tassert.strictEqual(model.get(2), 3);\n\t});\n\n\ttest('accessing item beyond loaded range throws', () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Try to access item beyond current length\n\t\tassert.throws(() => model.get(15), /Item not resolved yet/);\n\t});\n\n\ttest('resolving item beyond all pages throws', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Load all pages\n\t\tawait model.resolve(10, CancellationToken.None);\n\t\tawait model.resolve(20, CancellationToken.None);\n\n\t\t// Try to resolve beyond the last item\n\t\tawait assert.rejects(\n\t\t\tasync () => model.resolve(30, CancellationToken.None),\n\t\t\t/Index out of bounds/\n\t\t);\n\t});\n\n\ttest('cancelled token during initial resolve', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tcts.cancel();\n\n\t\tawait assert.rejects(\n\t\t\tasync () => model.resolve(0, cts.token),\n\t\t\t/Canceled/\n\t\t);\n\t});\n\n\ttest('event fires for each page load', async () => {\n\t\tconst pager = createTestPager(5, 4);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\t\tconst lengths: number[] = [];\n\n\t\tstore.add(model.onDidIncrementLength((length: number) => lengths.push(length)));\n\n\t\t// Initially has first page (5 items + 1 sentinel = 6)\n\t\tassert.strictEqual(model.length, 6);\n\n\t\t// Load page 2\n\t\tawait model.resolve(5, CancellationToken.None);\n\t\tassert.deepStrictEqual(lengths, [11]); // 10 items + 1 sentinel\n\n\t\t// Load page 3\n\t\tawait model.resolve(10, CancellationToken.None);\n\t\tassert.deepStrictEqual(lengths, [11, 16]); // 15 items + 1 sentinel\n\n\t\t// Load page 4 (final)\n\t\tawait model.resolve(15, CancellationToken.None);\n\t\tassert.deepStrictEqual(lengths, [11, 16, 20]); // 20 items, no sentinel\n\t});\n\n\ttest('sequential page loads work correctly', async () => {\n\t\tconst pager = createTestPager(5, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Load pages sequentially\n\t\tfor (let page = 1; page < 3; page++) {\n\t\t\tconst sentinelIndex = page * 5;\n\t\t\tawait model.resolve(sentinelIndex, CancellationToken.None);\n\t\t}\n\n\t\t// Verify all items are accessible\n\t\tassert.strictEqual(model.length, 15); // 3 pages * 5 items, no sentinel\n\t\tfor (let i = 0; i < 15; i++) {\n\t\t\tassert.strictEqual(model.get(i), i);\n\t\t\tassert.strictEqual(model.isResolved(i), true);\n\t\t}\n\t});\n\n\ttest('accessing items after loading all pages', async () => {\n\t\tconst pager = createTestPager(10, 2);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Load second page\n\t\tawait model.resolve(10, CancellationToken.None);\n\n\t\t// No sentinel after loading all pages\n\t\tassert.strictEqual(model.length, 20);\n\t\tassert.strictEqual(model.isResolved(19), true);\n\t\tassert.strictEqual(model.isResolved(20), false);\n\n\t\t// All items should be accessible\n\t\tfor (let i = 0; i < 20; i++) {\n\t\t\tassert.strictEqual(model.get(i), i);\n\t\t}\n\t});\n\n\ttest('pager with varying page sizes', async () => {\n\t\tlet pageNum = 0;\n\t\tconst varyingPager: IIterativePager<string> = {\n\t\t\tfirstPage: { items: ['a', 'b', 'c'], hasMore: true },\n\t\t\tgetNextPage: async (): Promise<IIterativePage<string>> => {\n\t\t\t\tpageNum++;\n\t\t\t\tif (pageNum === 1) {\n\t\t\t\t\treturn { items: ['d', 'e'], hasMore: true };\n\t\t\t\t} else if (pageNum === 2) {\n\t\t\t\t\treturn { items: ['f', 'g', 'h', 'i'], hasMore: false };\n\t\t\t\t}\n\t\t\t\treturn { items: [], hasMore: false };\n\t\t\t}\n\t\t};\n\n\t\tconst model = store.add(new IterativePagedModel(varyingPager));\n\n\t\tassert.strictEqual(model.length, 4); // 3 items + 1 sentinel\n\n\t\t// Load second page (2 items)\n\t\tawait model.resolve(3, CancellationToken.None);\n\t\tassert.strictEqual(model.length, 6); // 5 items + 1 sentinel\n\t\tassert.strictEqual(model.get(3), 'd');\n\n\t\t// Load third page (4 items)\n\t\tawait model.resolve(5, CancellationToken.None);\n\t\tassert.strictEqual(model.length, 9); // 9 items, no sentinel\n\t\tassert.strictEqual(model.get(5), 'f');\n\t\tassert.strictEqual(model.get(8), 'i');\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { CancellationToken, CancellationTokenSource } from '../../common/cancellation.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from './utils.js';\nimport { IterativePagedModel, IIterativePager, IIterativePage } from '../../common/paging.js';\n\nfunction createTestPager(pageSize: number, maxPages: number): IIterativePager<number> {\n\tlet currentPage = 0;\n\n\tconst createPage = (page: number): IIterativePage<number> => {\n\t\tconst start = page * pageSize;\n\t\tconst items: number[] = [];\n\t\tfor (let i = 0; i < pageSize; i++) {\n\t\t\titems.push(start + i);\n\t\t}\n\t\tconst hasMore = page + 1 < maxPages;\n\t\treturn { items, hasMore };\n\t};\n\n\treturn {\n\t\tfirstPage: createPage(currentPage++),\n\t\tgetNextPage: async (cancellationToken: CancellationToken): Promise<IIterativePage<number>> => {\n\t\t\tif (currentPage >= maxPages) {\n\t\t\t\treturn { items: [], hasMore: false };\n\t\t\t}\n\t\t\treturn createPage(currentPage++);\n\t\t}\n\t};\n}\n\nsuite('IterativePagedModel', () => {\n\n\tconst store = ensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('initial state', () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Initially first page is loaded, so length should be 10 + 1 sentinel\n\t\tassert.strictEqual(model.length, 11);\n\t\tassert.strictEqual(model.isResolved(0), true);\n\t\tassert.strictEqual(model.isResolved(9), true);\n\t\tassert.strictEqual(model.isResolved(10), false); // sentinel\n\t});\n\n\ttest('load first page via sentinel access', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Access an item in the first page (already loaded)\n\t\tconst item = await model.resolve(0, CancellationToken.None);\n\n\t\tassert.strictEqual(item, 0);\n\t\tassert.strictEqual(model.length, 11); // 10 items + 1 sentinel\n\t\tassert.strictEqual(model.isResolved(0), true);\n\t\tassert.strictEqual(model.isResolved(9), true);\n\t\tassert.strictEqual(model.isResolved(10), false); // sentinel\n\t});\n\n\ttest('load multiple pages', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// First page already loaded\n\t\tassert.strictEqual(model.length, 11);\n\n\t\t// Load second page by accessing its sentinel\n\t\tawait model.resolve(10, CancellationToken.None);\n\t\tassert.strictEqual(model.length, 21); // 20 items + 1 sentinel\n\t\tassert.strictEqual(model.get(10), 10); // First item of second page\n\n\t\t// Load third (final) page\n\t\tawait model.resolve(20, CancellationToken.None);\n\t\tassert.strictEqual(model.length, 30); // 30 items, no sentinel (no more pages)\n\t});\n\n\ttest('onDidIncrementLength event fires correctly', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\t\tconst lengths: number[] = [];\n\n\t\tstore.add(model.onDidIncrementLength((length: number) => lengths.push(length)));\n\n\t\t// Load second page\n\t\tawait model.resolve(10, CancellationToken.None);\n\n\t\tassert.strictEqual(lengths.length, 1);\n\t\tassert.strictEqual(lengths[0], 21); // 20 items + 1 sentinel\n\n\t\t// Load third page\n\t\tawait model.resolve(20, CancellationToken.None);\n\n\t\tassert.strictEqual(lengths.length, 2);\n\t\tassert.strictEqual(lengths[1], 30); // 30 items, no sentinel\n\t});\n\n\ttest('accessing regular items does not trigger loading', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\tconst initialLength = model.length;\n\n\t\t// Access items within the loaded range\n\t\tassert.strictEqual(model.get(5), 5);\n\t\tassert.strictEqual(model.isResolved(5), true);\n\n\t\t// Length should not change\n\t\tassert.strictEqual(model.length, initialLength);\n\t});\n\n\ttest('reaching end of data removes sentinel', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Load all pages\n\t\tawait model.resolve(10, CancellationToken.None);  // Page 2\n\t\tawait model.resolve(20, CancellationToken.None);  // Page 3 (final)\n\n\t\t// After loading all data, there should be no more pages\n\t\tassert.strictEqual(model.length, 30); // Exactly 30 items, no sentinel\n\n\t\t// Accessing resolved items should work\n\t\tassert.strictEqual(model.isResolved(29), true);\n\t\tassert.strictEqual(model.isResolved(30), false);\n\t});\n\n\ttest('concurrent access to sentinel only loads once', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Access sentinel concurrently\n\t\tconst [item1, item2, item3] = await Promise.all([\n\t\t\tmodel.resolve(10, CancellationToken.None),\n\t\t\tmodel.resolve(10, CancellationToken.None),\n\t\t\tmodel.resolve(10, CancellationToken.None)\n\t\t]);\n\n\t\t// All should get the same item\n\t\tassert.strictEqual(item1, 10);\n\t\tassert.strictEqual(item2, 10);\n\t\tassert.strictEqual(item3, 10);\n\t\tassert.strictEqual(model.length, 21); // 20 items + 1 sentinel\n\t});\n\n\ttest('empty pager with no items', () => {\n\t\tconst emptyPager: IIterativePager<number> = {\n\t\t\tfirstPage: { items: [], hasMore: false },\n\t\t\tgetNextPage: async () => ({ items: [], hasMore: false })\n\t\t};\n\t\tconst model = store.add(new IterativePagedModel(emptyPager));\n\n\t\tassert.strictEqual(model.length, 0);\n\t\tassert.strictEqual(model.isResolved(0), false);\n\t});\n\n\ttest('single page pager with no more pages', () => {\n\t\tconst singlePagePager: IIterativePager<number> = {\n\t\t\tfirstPage: { items: [1, 2, 3], hasMore: false },\n\t\t\tgetNextPage: async () => ({ items: [], hasMore: false })\n\t\t};\n\t\tconst model = store.add(new IterativePagedModel(singlePagePager));\n\n\t\tassert.strictEqual(model.length, 3); // No sentinel\n\t\tassert.strictEqual(model.isResolved(0), true);\n\t\tassert.strictEqual(model.isResolved(2), true);\n\t\tassert.strictEqual(model.isResolved(3), false);\n\t\tassert.strictEqual(model.get(0), 1);\n\t\tassert.strictEqual(model.get(2), 3);\n\t});\n\n\ttest('accessing item beyond loaded range throws', () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Try to access item beyond current length\n\t\tassert.throws(() => model.get(15), /Item not resolved yet/);\n\t});\n\n\ttest('resolving item beyond all pages throws', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Load all pages\n\t\tawait model.resolve(10, CancellationToken.None);\n\t\tawait model.resolve(20, CancellationToken.None);\n\n\t\t// Try to resolve beyond the last item\n\t\tawait assert.rejects(\n\t\t\tasync () => model.resolve(30, CancellationToken.None),\n\t\t\t/Index out of bounds/\n\t\t);\n\t});\n\n\ttest('cancelled token during initial resolve', async () => {\n\t\tconst pager = createTestPager(10, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tcts.cancel();\n\n\t\tawait assert.rejects(\n\t\t\tasync () => model.resolve(0, cts.token),\n\t\t\t/Canceled/\n\t\t);\n\t});\n\n\ttest('event fires for each page load', async () => {\n\t\tconst pager = createTestPager(5, 4);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\t\tconst lengths: number[] = [];\n\n\t\tstore.add(model.onDidIncrementLength((length: number) => lengths.push(length)));\n\n\t\t// Initially has first page (5 items + 1 sentinel = 6)\n\t\tassert.strictEqual(model.length, 6);\n\n\t\t// Load page 2\n\t\tawait model.resolve(5, CancellationToken.None);\n\t\tassert.deepStrictEqual(lengths, [11]); // 10 items + 1 sentinel\n\n\t\t// Load page 3\n\t\tawait model.resolve(10, CancellationToken.None);\n\t\tassert.deepStrictEqual(lengths, [11, 16]); // 15 items + 1 sentinel\n\n\t\t// Load page 4 (final)\n\t\tawait model.resolve(15, CancellationToken.None);\n\t\tassert.deepStrictEqual(lengths, [11, 16, 20]); // 20 items, no sentinel\n\t});\n\n\ttest('sequential page loads work correctly', async () => {\n\t\tconst pager = createTestPager(5, 3);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Load pages sequentially\n\t\tfor (let page = 1; page < 3; page++) {\n\t\t\tconst sentinelIndex = page * 5;\n\t\t\tawait model.resolve(sentinelIndex, CancellationToken.None);\n\t\t}\n\n\t\t// Verify all items are accessible\n\t\tassert.strictEqual(model.length, 15); // 3 pages * 5 items, no sentinel\n\t\tfor (let i = 0; i < 15; i++) {\n\t\t\tassert.strictEqual(model.get(i), i);\n\t\t\tassert.strictEqual(model.isResolved(i), true);\n\t\t}\n\t});\n\n\ttest('accessing items after loading all pages', async () => {\n\t\tconst pager = createTestPager(10, 2);\n\t\tconst model = store.add(new IterativePagedModel(pager));\n\n\t\t// Load second page\n\t\tawait model.resolve(10, CancellationToken.None);\n\n\t\t// No sentinel after loading all pages\n\t\tassert.strictEqual(model.length, 20);\n\t\tassert.strictEqual(model.isResolved(19), true);\n\t\tassert.strictEqual(model.isResolved(20), false);\n\n\t\t// All items should be accessible\n\t\tfor (let i = 0; i < 20; i++) {\n\t\t\tassert.strictEqual(model.get(i), i);\n\t\t}\n\t});\n\n\ttest('pager with varying page sizes', async () => {\n\t\tlet pageNum = 0;\n\t\tconst varyingPager: IIterativePager<string> = {\n\t\t\tfirstPage: { items: ['a', 'b', 'c'], hasMore: true },\n\t\t\tgetNextPage: async (): Promise<IIterativePage<string>> => {\n\t\t\t\tpageNum++;\n\t\t\t\tif (pageNum === 1) {\n\t\t\t\t\treturn { items: ['d', 'e'], hasMore: true };\n\t\t\t\t} else if (pageNum === 2) {\n\t\t\t\t\treturn { items: ['f', 'g', 'h', 'i'], hasMore: false };\n\t\t\t\t}\n\t\t\t\treturn { items: [], hasMore: false };\n\t\t\t}\n\t\t};\n\n\t\tconst model = store.add(new IterativePagedModel(varyingPager));\n\n\t\tassert.strictEqual(model.length, 4); // 3 items + 1 sentinel\n\n\t\t// Load second page (2 items)\n\t\tawait model.resolve(3, CancellationToken.None);\n\t\tassert.strictEqual(model.length, 6); // 5 items + 1 sentinel\n\t\tassert.strictEqual(model.get(3), 'd');\n\n\t\t// Load third page (4 items)\n\t\tawait model.resolve(5, CancellationToken.None);\n\t\tassert.strictEqual(model.length, 9); // 9 items, no sentinel\n\t\tassert.strictEqual(model.get(5), 'f');\n\t\tassert.strictEqual(model.get(8), 'i');\n\t});\n});\n"]}