{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/test/common/utils.ts","vs/base/test/common/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, DisposableTracker, IDisposable, setDisposableTracker } from '../../common/lifecycle.js';\nimport { join } from '../../common/path.js';\nimport { isWindows } from '../../common/platform.js';\nimport { URI } from '../../common/uri.js';\n\nexport type ValueCallback<T = any> = (value: T | Promise<T>) => void;\n\nexport function toResource(this: any, path: string): URI {\n\tif (isWindows) {\n\t\treturn URI.file(join('C:\\\\', btoa(this.test.fullTitle()), path));\n\t}\n\n\treturn URI.file(join('/', btoa(this.test.fullTitle()), path));\n}\n\nexport function suiteRepeat(n: number, description: string, callback: (this: any) => void): void {\n\tfor (let i = 0; i < n; i++) {\n\t\tsuite(`${description} (iteration ${i})`, callback);\n\t}\n}\n\nexport function testRepeat(n: number, description: string, callback: (this: any) => any): void {\n\tfor (let i = 0; i < n; i++) {\n\t\ttest(`${description} (iteration ${i})`, callback);\n\t}\n}\n\nexport async function assertThrowsAsync(block: () => any, message: string | Error = 'Missing expected exception'): Promise<void> {\n\ttry {\n\t\tawait block();\n\t} catch {\n\t\treturn;\n\t}\n\n\tconst err = message instanceof Error ? message : new Error(message);\n\tthrow err;\n}\n\n/**\n * Use this function to ensure that all disposables are cleaned up at the end of each test in the current suite.\n *\n * Use `markAsSingleton` if disposable singletons are created lazily that are allowed to outlive the test.\n * Make sure that the singleton properly registers all child disposables so that they are excluded too.\n *\n * @returns A {@link DisposableStore} that can optionally be used to track disposables in the test.\n * This will be automatically disposed on test teardown.\n*/\nexport function ensureNoDisposablesAreLeakedInTestSuite(): Pick<DisposableStore, 'add'> {\n\tlet tracker: DisposableTracker | undefined;\n\tlet store: DisposableStore;\n\tsetup(() => {\n\t\tstore = new DisposableStore();\n\t\ttracker = new DisposableTracker();\n\t\tsetDisposableTracker(tracker);\n\t});\n\n\tteardown(function (this: import('mocha').Context) {\n\t\tstore.dispose();\n\t\tsetDisposableTracker(null);\n\t\tif (this.currentTest?.state !== 'failed') {\n\t\t\tconst result = tracker!.computeLeakingDisposables();\n\t\t\tif (result) {\n\t\t\t\tconsole.error(result.details);\n\t\t\t\tthrow new Error(`There are ${result.leaks.length} undisposed disposables!${result.details}`);\n\t\t\t}\n\t\t}\n\t});\n\n\t// Wrap store as the suite function is called before it's initialized\n\tconst testContext = {\n\t\tadd<T extends IDisposable>(o: T): T {\n\t\t\treturn store.add(o);\n\t\t}\n\t};\n\treturn testContext;\n}\n\nexport function throwIfDisposablesAreLeaked(body: () => void, logToConsole = true): void {\n\tconst tracker = new DisposableTracker();\n\tsetDisposableTracker(tracker);\n\tbody();\n\tsetDisposableTracker(null);\n\tcomputeLeakingDisposables(tracker, logToConsole);\n}\n\nexport async function throwIfDisposablesAreLeakedAsync(body: () => Promise<void>): Promise<void> {\n\tconst tracker = new DisposableTracker();\n\tsetDisposableTracker(tracker);\n\tawait body();\n\tsetDisposableTracker(null);\n\tcomputeLeakingDisposables(tracker);\n}\n\nfunction computeLeakingDisposables(tracker: DisposableTracker, logToConsole = true) {\n\tconst result = tracker.computeLeakingDisposables();\n\tif (result) {\n\t\tif (logToConsole) {\n\t\t\tconsole.error(result.details);\n\t\t}\n\t\tthrow new Error(`There are ${result.leaks.length} undisposed disposables!${result.details}`);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, DisposableTracker, IDisposable, setDisposableTracker } from '../../common/lifecycle.js';\nimport { join } from '../../common/path.js';\nimport { isWindows } from '../../common/platform.js';\nimport { URI } from '../../common/uri.js';\n\nexport type ValueCallback<T = any> = (value: T | Promise<T>) => void;\n\nexport function toResource(this: any, path: string): URI {\n\tif (isWindows) {\n\t\treturn URI.file(join('C:\\\\', btoa(this.test.fullTitle()), path));\n\t}\n\n\treturn URI.file(join('/', btoa(this.test.fullTitle()), path));\n}\n\nexport function suiteRepeat(n: number, description: string, callback: (this: any) => void): void {\n\tfor (let i = 0; i < n; i++) {\n\t\tsuite(`${description} (iteration ${i})`, callback);\n\t}\n}\n\nexport function testRepeat(n: number, description: string, callback: (this: any) => any): void {\n\tfor (let i = 0; i < n; i++) {\n\t\ttest(`${description} (iteration ${i})`, callback);\n\t}\n}\n\nexport async function assertThrowsAsync(block: () => any, message: string | Error = 'Missing expected exception'): Promise<void> {\n\ttry {\n\t\tawait block();\n\t} catch {\n\t\treturn;\n\t}\n\n\tconst err = message instanceof Error ? message : new Error(message);\n\tthrow err;\n}\n\n/**\n * Use this function to ensure that all disposables are cleaned up at the end of each test in the current suite.\n *\n * Use `markAsSingleton` if disposable singletons are created lazily that are allowed to outlive the test.\n * Make sure that the singleton properly registers all child disposables so that they are excluded too.\n *\n * @returns A {@link DisposableStore} that can optionally be used to track disposables in the test.\n * This will be automatically disposed on test teardown.\n*/\nexport function ensureNoDisposablesAreLeakedInTestSuite(): Pick<DisposableStore, 'add'> {\n\tlet tracker: DisposableTracker | undefined;\n\tlet store: DisposableStore;\n\tsetup(() => {\n\t\tstore = new DisposableStore();\n\t\ttracker = new DisposableTracker();\n\t\tsetDisposableTracker(tracker);\n\t});\n\n\tteardown(function (this: import('mocha').Context) {\n\t\tstore.dispose();\n\t\tsetDisposableTracker(null);\n\t\tif (this.currentTest?.state !== 'failed') {\n\t\t\tconst result = tracker!.computeLeakingDisposables();\n\t\t\tif (result) {\n\t\t\t\tconsole.error(result.details);\n\t\t\t\tthrow new Error(`There are ${result.leaks.length} undisposed disposables!${result.details}`);\n\t\t\t}\n\t\t}\n\t});\n\n\t// Wrap store as the suite function is called before it's initialized\n\tconst testContext = {\n\t\tadd<T extends IDisposable>(o: T): T {\n\t\t\treturn store.add(o);\n\t\t}\n\t};\n\treturn testContext;\n}\n\nexport function throwIfDisposablesAreLeaked(body: () => void, logToConsole = true): void {\n\tconst tracker = new DisposableTracker();\n\tsetDisposableTracker(tracker);\n\tbody();\n\tsetDisposableTracker(null);\n\tcomputeLeakingDisposables(tracker, logToConsole);\n}\n\nexport async function throwIfDisposablesAreLeakedAsync(body: () => Promise<void>): Promise<void> {\n\tconst tracker = new DisposableTracker();\n\tsetDisposableTracker(tracker);\n\tawait body();\n\tsetDisposableTracker(null);\n\tcomputeLeakingDisposables(tracker);\n}\n\nfunction computeLeakingDisposables(tracker: DisposableTracker, logToConsole = true) {\n\tconst result = tracker.computeLeakingDisposables();\n\tif (result) {\n\t\tif (logToConsole) {\n\t\t\tconsole.error(result.details);\n\t\t}\n\t\tthrow new Error(`There are ${result.leaks.length} undisposed disposables!${result.details}`);\n\t}\n}\n"]}