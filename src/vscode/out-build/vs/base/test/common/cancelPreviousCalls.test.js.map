{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/test/common/cancelPreviousCalls.test.ts","vs/base/test/common/cancelPreviousCalls.test.ts"],"names":[],"mappings":"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","file":"cancelPreviousCalls.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { Disposable } from '../../common/lifecycle.js';\nimport { CancellationToken } from '../../common/cancellation.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from './utils.js';\nimport { cancelPreviousCalls } from '../../common/decorators/cancelPreviousCalls.js';\n\nsuite('cancelPreviousCalls decorator', () => {\n\tconst disposables = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tclass MockDisposable extends Disposable {\n\t\t/**\n\t\t * Arguments that the {@linkcode doSomethingAsync} method was called with.\n\t\t */\n\t\tprivate readonly callArgs1: ([number, string, CancellationToken | undefined])[] = [];\n\n\t\t/**\n\t\t * Arguments that the {@linkcode doSomethingElseAsync} method was called with.\n\t\t */\n\t\tprivate readonly callArgs2: ([number, string, CancellationToken | undefined])[] = [];\n\n\t\t/**\n\t\t * Returns the arguments that the {@linkcode doSomethingAsync} method was called with.\n\t\t */\n\t\tpublic get callArguments1() {\n\t\t\treturn this.callArgs1;\n\t\t}\n\n\t\t/**\n\t\t * Returns the arguments that the {@linkcode doSomethingElseAsync} method was called with.\n\t\t */\n\t\tpublic get callArguments2() {\n\t\t\treturn this.callArgs2;\n\t\t}\n\n\t\t@cancelPreviousCalls\n\t\tasync doSomethingAsync(arg1: number, arg2: string, cancellationToken?: CancellationToken): Promise<void> {\n\t\t\tthis.callArgs1.push([arg1, arg2, cancellationToken]);\n\n\t\t\tawait new Promise(resolve => setTimeout(resolve, 25));\n\t\t}\n\n\t\t@cancelPreviousCalls\n\t\tasync doSomethingElseAsync(arg1: number, arg2: string, cancellationToken?: CancellationToken): Promise<void> {\n\t\t\tthis.callArgs2.push([arg1, arg2, cancellationToken]);\n\n\t\t\tawait new Promise(resolve => setTimeout(resolve, 25));\n\t\t}\n\t}\n\n\ttest('should call method with CancellationToken', async () => {\n\t\tconst instance = disposables.add(new MockDisposable());\n\n\t\tawait instance.doSomethingAsync(1, 'foo');\n\n\t\tconst callArguments = instance.callArguments1;\n\t\tassert.strictEqual(\n\t\t\tcallArguments.length,\n\t\t\t1,\n\t\t\t`The 'doSomethingAsync' method must be called just once.`,\n\t\t);\n\n\t\tconst args = callArguments[0];\n\t\tassert(\n\t\t\targs.length === 3,\n\t\t\t`The 'doSomethingAsync' method must be called with '3' arguments, got '${args.length}'.`,\n\t\t);\n\n\t\tconst arg1 = args[0];\n\t\tconst arg2 = args[1];\n\t\tconst arg3 = args[2];\n\n\t\tassert.strictEqual(\n\t\t\targ1,\n\t\t\t1,\n\t\t\t`The 'doSomethingAsync' method call must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\targ2,\n\t\t\t'foo',\n\t\t\t`The 'doSomethingAsync' method call must have the correct 2nd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(arg3),\n\t\t\t`The last argument of the 'doSomethingAsync' method must be a 'CancellationToken', got '${arg3}'.`,\n\t\t);\n\n\t\tassert(\n\t\t\targ3.isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' argument must not yet be cancelled.`,\n\t\t);\n\n\t\tassert(\n\t\t\tinstance.callArguments2.length === 0,\n\t\t\t`The 'doSomethingElseAsync' method must not be called.`,\n\t\t);\n\t});\n\n\ttest('cancel token of the previous call when method is called again', async () => {\n\t\tconst instance = disposables.add(new MockDisposable());\n\n\t\tinstance.doSomethingAsync(1, 'foo');\n\t\tawait new Promise(resolve => setTimeout(resolve, 10));\n\t\tinstance.doSomethingAsync(2, 'bar');\n\n\t\tconst callArguments = instance.callArguments1;\n\t\tassert.strictEqual(\n\t\t\tcallArguments.length,\n\t\t\t2,\n\t\t\t`The 'doSomethingAsync' method must be called twice.`,\n\t\t);\n\n\t\tconst call1Args = callArguments[0];\n\t\tassert(\n\t\t\tcall1Args.length === 3,\n\t\t\t`The first call of the 'doSomethingAsync' method must have '3' arguments, got '${call1Args.length}'.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall1Args[0],\n\t\t\t1,\n\t\t\t`The first call of the 'doSomethingAsync' method must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall1Args[1],\n\t\t\t'foo',\n\t\t\t`The first call of the 'doSomethingAsync' method must have the correct 2nd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(call1Args[2]),\n\t\t\t`The first call of the 'doSomethingAsync' method must have the 'CancellationToken' as the 3rd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall1Args[2].isCancellationRequested === true,\n\t\t\t`The 'CancellationToken' of the first call must be cancelled.`,\n\t\t);\n\n\t\tconst call2Args = callArguments[1];\n\t\tassert(\n\t\t\tcall2Args.length === 3,\n\t\t\t`The second call of the 'doSomethingAsync' method must have '3' arguments, got '${call1Args.length}'.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall2Args[0],\n\t\t\t2,\n\t\t\t`The second call of the 'doSomethingAsync' method must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall2Args[1],\n\t\t\t'bar',\n\t\t\t`The second call of the 'doSomethingAsync' method must have the correct 2nd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(call2Args[2]),\n\t\t\t`The second call of the 'doSomethingAsync' method must have the 'CancellationToken' as the 3rd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall2Args[2].isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' of the second call must be cancelled.`,\n\t\t);\n\n\t\tassert(\n\t\t\tinstance.callArguments2.length === 0,\n\t\t\t`The 'doSomethingElseAsync' method must not be called.`,\n\t\t);\n\t});\n\n\ttest('different method calls must not interfere with each other', async () => {\n\t\tconst instance = disposables.add(new MockDisposable());\n\n\t\tinstance.doSomethingAsync(10, 'baz');\n\t\tawait new Promise(resolve => setTimeout(resolve, 10));\n\t\tinstance.doSomethingElseAsync(25, 'qux');\n\n\t\tassert.strictEqual(\n\t\t\tinstance.callArguments1.length,\n\t\t\t1,\n\t\t\t`The 'doSomethingAsync' method must be called once.`,\n\t\t);\n\n\t\tconst call1Args = instance.callArguments1[0];\n\t\tassert(\n\t\t\tcall1Args.length === 3,\n\t\t\t`The first call of the 'doSomethingAsync' method must have '3' arguments, got '${call1Args.length}'.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall1Args[0],\n\t\t\t10,\n\t\t\t`The first call of the 'doSomethingAsync' method must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall1Args[1],\n\t\t\t'baz',\n\t\t\t`The first call of the 'doSomethingAsync' method must have the correct 2nd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(call1Args[2]),\n\t\t\t`The first call of the 'doSomethingAsync' method must have the 'CancellationToken' as the 3rd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall1Args[2].isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' of the first call must not be cancelled.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tinstance.callArguments2.length,\n\t\t\t1,\n\t\t\t`The 'doSomethingElseAsync' method must be called once.`,\n\t\t);\n\n\t\tconst call2Args = instance.callArguments2[0];\n\t\tassert(\n\t\t\tcall2Args.length === 3,\n\t\t\t`The first call of the 'doSomethingElseAsync' method must have '3' arguments, got '${call1Args.length}'.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall2Args[0],\n\t\t\t25,\n\t\t\t`The first call of the 'doSomethingElseAsync' method must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall2Args[1],\n\t\t\t'qux',\n\t\t\t`The first call of the 'doSomethingElseAsync' method must have the correct 2nd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(call2Args[2]),\n\t\t\t`The first call of the 'doSomethingElseAsync' method must have the 'CancellationToken' as the 3rd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall2Args[2].isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' of the second call must be cancelled.`,\n\t\t);\n\n\t\tinstance.doSomethingElseAsync(105, 'uxi');\n\n\t\tassert.strictEqual(\n\t\t\tinstance.callArguments1.length,\n\t\t\t1,\n\t\t\t`The 'doSomethingAsync' method must be called once.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tinstance.callArguments2.length,\n\t\t\t2,\n\t\t\t`The 'doSomethingElseAsync' method must be called twice.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall1Args[2].isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' of the first call must not be cancelled.`,\n\t\t);\n\n\t\tconst call3Args = instance.callArguments2[1];\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(call3Args[2]),\n\t\t\t`The last argument of the second call of the 'doSomethingElseAsync' method must be a 'CancellationToken'.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall2Args[2].isCancellationRequested,\n\t\t\t`The 'CancellationToken' of the first call must be cancelled.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall3Args[2].isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' of the second call must not be cancelled.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall3Args[0],\n\t\t\t105,\n\t\t\t`The second call of the 'doSomethingElseAsync' method must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall3Args[1],\n\t\t\t'uxi',\n\t\t\t`The second call of the 'doSomethingElseAsync' method must have the correct 2nd argument.`,\n\t\t);\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { Disposable } from '../../common/lifecycle.js';\nimport { CancellationToken } from '../../common/cancellation.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from './utils.js';\nimport { cancelPreviousCalls } from '../../common/decorators/cancelPreviousCalls.js';\n\nsuite('cancelPreviousCalls decorator', () => {\n\tconst disposables = ensureNoDisposablesAreLeakedInTestSuite();\n\n\tclass MockDisposable extends Disposable {\n\t\t/**\n\t\t * Arguments that the {@linkcode doSomethingAsync} method was called with.\n\t\t */\n\t\tprivate readonly callArgs1: ([number, string, CancellationToken | undefined])[] = [];\n\n\t\t/**\n\t\t * Arguments that the {@linkcode doSomethingElseAsync} method was called with.\n\t\t */\n\t\tprivate readonly callArgs2: ([number, string, CancellationToken | undefined])[] = [];\n\n\t\t/**\n\t\t * Returns the arguments that the {@linkcode doSomethingAsync} method was called with.\n\t\t */\n\t\tpublic get callArguments1() {\n\t\t\treturn this.callArgs1;\n\t\t}\n\n\t\t/**\n\t\t * Returns the arguments that the {@linkcode doSomethingElseAsync} method was called with.\n\t\t */\n\t\tpublic get callArguments2() {\n\t\t\treturn this.callArgs2;\n\t\t}\n\n\t\t@cancelPreviousCalls\n\t\tasync doSomethingAsync(arg1: number, arg2: string, cancellationToken?: CancellationToken): Promise<void> {\n\t\t\tthis.callArgs1.push([arg1, arg2, cancellationToken]);\n\n\t\t\tawait new Promise(resolve => setTimeout(resolve, 25));\n\t\t}\n\n\t\t@cancelPreviousCalls\n\t\tasync doSomethingElseAsync(arg1: number, arg2: string, cancellationToken?: CancellationToken): Promise<void> {\n\t\t\tthis.callArgs2.push([arg1, arg2, cancellationToken]);\n\n\t\t\tawait new Promise(resolve => setTimeout(resolve, 25));\n\t\t}\n\t}\n\n\ttest('should call method with CancellationToken', async () => {\n\t\tconst instance = disposables.add(new MockDisposable());\n\n\t\tawait instance.doSomethingAsync(1, 'foo');\n\n\t\tconst callArguments = instance.callArguments1;\n\t\tassert.strictEqual(\n\t\t\tcallArguments.length,\n\t\t\t1,\n\t\t\t`The 'doSomethingAsync' method must be called just once.`,\n\t\t);\n\n\t\tconst args = callArguments[0];\n\t\tassert(\n\t\t\targs.length === 3,\n\t\t\t`The 'doSomethingAsync' method must be called with '3' arguments, got '${args.length}'.`,\n\t\t);\n\n\t\tconst arg1 = args[0];\n\t\tconst arg2 = args[1];\n\t\tconst arg3 = args[2];\n\n\t\tassert.strictEqual(\n\t\t\targ1,\n\t\t\t1,\n\t\t\t`The 'doSomethingAsync' method call must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\targ2,\n\t\t\t'foo',\n\t\t\t`The 'doSomethingAsync' method call must have the correct 2nd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(arg3),\n\t\t\t`The last argument of the 'doSomethingAsync' method must be a 'CancellationToken', got '${arg3}'.`,\n\t\t);\n\n\t\tassert(\n\t\t\targ3.isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' argument must not yet be cancelled.`,\n\t\t);\n\n\t\tassert(\n\t\t\tinstance.callArguments2.length === 0,\n\t\t\t`The 'doSomethingElseAsync' method must not be called.`,\n\t\t);\n\t});\n\n\ttest('cancel token of the previous call when method is called again', async () => {\n\t\tconst instance = disposables.add(new MockDisposable());\n\n\t\tinstance.doSomethingAsync(1, 'foo');\n\t\tawait new Promise(resolve => setTimeout(resolve, 10));\n\t\tinstance.doSomethingAsync(2, 'bar');\n\n\t\tconst callArguments = instance.callArguments1;\n\t\tassert.strictEqual(\n\t\t\tcallArguments.length,\n\t\t\t2,\n\t\t\t`The 'doSomethingAsync' method must be called twice.`,\n\t\t);\n\n\t\tconst call1Args = callArguments[0];\n\t\tassert(\n\t\t\tcall1Args.length === 3,\n\t\t\t`The first call of the 'doSomethingAsync' method must have '3' arguments, got '${call1Args.length}'.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall1Args[0],\n\t\t\t1,\n\t\t\t`The first call of the 'doSomethingAsync' method must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall1Args[1],\n\t\t\t'foo',\n\t\t\t`The first call of the 'doSomethingAsync' method must have the correct 2nd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(call1Args[2]),\n\t\t\t`The first call of the 'doSomethingAsync' method must have the 'CancellationToken' as the 3rd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall1Args[2].isCancellationRequested === true,\n\t\t\t`The 'CancellationToken' of the first call must be cancelled.`,\n\t\t);\n\n\t\tconst call2Args = callArguments[1];\n\t\tassert(\n\t\t\tcall2Args.length === 3,\n\t\t\t`The second call of the 'doSomethingAsync' method must have '3' arguments, got '${call1Args.length}'.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall2Args[0],\n\t\t\t2,\n\t\t\t`The second call of the 'doSomethingAsync' method must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall2Args[1],\n\t\t\t'bar',\n\t\t\t`The second call of the 'doSomethingAsync' method must have the correct 2nd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(call2Args[2]),\n\t\t\t`The second call of the 'doSomethingAsync' method must have the 'CancellationToken' as the 3rd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall2Args[2].isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' of the second call must be cancelled.`,\n\t\t);\n\n\t\tassert(\n\t\t\tinstance.callArguments2.length === 0,\n\t\t\t`The 'doSomethingElseAsync' method must not be called.`,\n\t\t);\n\t});\n\n\ttest('different method calls must not interfere with each other', async () => {\n\t\tconst instance = disposables.add(new MockDisposable());\n\n\t\tinstance.doSomethingAsync(10, 'baz');\n\t\tawait new Promise(resolve => setTimeout(resolve, 10));\n\t\tinstance.doSomethingElseAsync(25, 'qux');\n\n\t\tassert.strictEqual(\n\t\t\tinstance.callArguments1.length,\n\t\t\t1,\n\t\t\t`The 'doSomethingAsync' method must be called once.`,\n\t\t);\n\n\t\tconst call1Args = instance.callArguments1[0];\n\t\tassert(\n\t\t\tcall1Args.length === 3,\n\t\t\t`The first call of the 'doSomethingAsync' method must have '3' arguments, got '${call1Args.length}'.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall1Args[0],\n\t\t\t10,\n\t\t\t`The first call of the 'doSomethingAsync' method must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall1Args[1],\n\t\t\t'baz',\n\t\t\t`The first call of the 'doSomethingAsync' method must have the correct 2nd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(call1Args[2]),\n\t\t\t`The first call of the 'doSomethingAsync' method must have the 'CancellationToken' as the 3rd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall1Args[2].isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' of the first call must not be cancelled.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tinstance.callArguments2.length,\n\t\t\t1,\n\t\t\t`The 'doSomethingElseAsync' method must be called once.`,\n\t\t);\n\n\t\tconst call2Args = instance.callArguments2[0];\n\t\tassert(\n\t\t\tcall2Args.length === 3,\n\t\t\t`The first call of the 'doSomethingElseAsync' method must have '3' arguments, got '${call1Args.length}'.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall2Args[0],\n\t\t\t25,\n\t\t\t`The first call of the 'doSomethingElseAsync' method must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall2Args[1],\n\t\t\t'qux',\n\t\t\t`The first call of the 'doSomethingElseAsync' method must have the correct 2nd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(call2Args[2]),\n\t\t\t`The first call of the 'doSomethingElseAsync' method must have the 'CancellationToken' as the 3rd argument.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall2Args[2].isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' of the second call must be cancelled.`,\n\t\t);\n\n\t\tinstance.doSomethingElseAsync(105, 'uxi');\n\n\t\tassert.strictEqual(\n\t\t\tinstance.callArguments1.length,\n\t\t\t1,\n\t\t\t`The 'doSomethingAsync' method must be called once.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tinstance.callArguments2.length,\n\t\t\t2,\n\t\t\t`The 'doSomethingElseAsync' method must be called twice.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall1Args[2].isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' of the first call must not be cancelled.`,\n\t\t);\n\n\t\tconst call3Args = instance.callArguments2[1];\n\t\tassert(\n\t\t\tCancellationToken.isCancellationToken(call3Args[2]),\n\t\t\t`The last argument of the second call of the 'doSomethingElseAsync' method must be a 'CancellationToken'.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall2Args[2].isCancellationRequested,\n\t\t\t`The 'CancellationToken' of the first call must be cancelled.`,\n\t\t);\n\n\t\tassert(\n\t\t\tcall3Args[2].isCancellationRequested === false,\n\t\t\t`The 'CancellationToken' of the second call must not be cancelled.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall3Args[0],\n\t\t\t105,\n\t\t\t`The second call of the 'doSomethingElseAsync' method must have the correct 1st argument.`,\n\t\t);\n\n\t\tassert.strictEqual(\n\t\t\tcall3Args[1],\n\t\t\t'uxi',\n\t\t\t`The second call of the 'doSomethingElseAsync' method must have the correct 2nd argument.`,\n\t\t);\n\t});\n});\n"]}