{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/test/common/oauth.test.ts","vs/base/test/common/oauth.test.ts"],"names":[],"mappings":"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","file":"oauth.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport * as sinon from 'sinon';\nimport {\n\tgetClaimsFromJWT,\n\tgetDefaultMetadataForUrl,\n\tisAuthorizationAuthorizeResponse,\n\tisAuthorizationDeviceResponse,\n\tisAuthorizationErrorResponse,\n\tisAuthorizationDynamicClientRegistrationResponse,\n\tisAuthorizationProtectedResourceMetadata,\n\tisAuthorizationServerMetadata,\n\tisAuthorizationTokenResponse,\n\tparseWWWAuthenticateHeader,\n\tfetchDynamicRegistration,\n\tfetchResourceMetadata,\n\tfetchAuthorizationServerMetadata,\n\tscopesMatch,\n\tIAuthorizationJWTClaims,\n\tIAuthorizationServerMetadata,\n\tDEFAULT_AUTH_FLOW_PORT\n} from '../../common/oauth.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from './utils.js';\nimport { encodeBase64, VSBuffer } from '../../common/buffer.js';\n\nsuite('OAuth', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\tsuite('Type Guards', () => {\n\t\ttest('isAuthorizationProtectedResourceMetadata should correctly identify protected resource metadata', () => {\n\t\t\t// Valid metadata with minimal required fields\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata({ resource: 'https://example.com' }), true);\n\n\t\t\t// Valid metadata with scopes_supported as array\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata({\n\t\t\t\tresource: 'https://example.com',\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t}), true);\n\n\t\t\t// Invalid cases - missing resource\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata(null), false);\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata({}), false);\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata('not an object'), false);\n\n\t\t\t// Invalid cases - scopes_supported is not an array when provided\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata({\n\t\t\t\tresource: 'https://example.com',\n\t\t\t\tscopes_supported: 'not an array'\n\t\t\t}), false);\n\t\t});\n\n\t\ttest('isAuthorizationServerMetadata should correctly identify server metadata', () => {\n\t\t\t// Valid metadata with minimal required fields\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), true);\n\n\t\t\t// Valid metadata with valid URLs\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tauthorization_endpoint: 'https://example.com/auth',\n\t\t\t\ttoken_endpoint: 'https://example.com/token',\n\t\t\t\tregistration_endpoint: 'https://example.com/register',\n\t\t\t\tjwks_uri: 'https://example.com/jwks',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), true);\n\n\t\t\t// Valid metadata with http URLs (for localhost/testing)\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'http://localhost:8080',\n\t\t\t\tauthorization_endpoint: 'http://localhost:8080/auth',\n\t\t\t\ttoken_endpoint: 'http://localhost:8080/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), true);\n\n\t\t\t// Invalid cases - not an object\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata(null), false);\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata('not an object'), false);\n\n\t\t\t// Invalid cases - missing issuer should throw\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({}), /Authorization server metadata must have an issuer/);\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({ response_types_supported: ['code'] }), /Authorization server metadata must have an issuer/);\n\n\t\t\t// Invalid cases - URI fields must be strings when provided (truthy values)\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tauthorization_endpoint: 123,\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'authorization_endpoint' must be a string/);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\ttoken_endpoint: 123,\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'token_endpoint' must be a string/);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tregistration_endpoint: [],\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'registration_endpoint' must be a string/);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tjwks_uri: {},\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'jwks_uri' must be a string/);\n\n\t\t\t// Invalid cases - URI fields must start with http:// or https://\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'ftp://example.com',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'issuer' must start with http:\\/\\/ or https:\\/\\//);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tauthorization_endpoint: 'ftp://example.com/auth',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'authorization_endpoint' must start with http:\\/\\/ or https:\\/\\//);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\ttoken_endpoint: 'file:///path/to/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'token_endpoint' must start with http:\\/\\/ or https:\\/\\//);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tregistration_endpoint: 'mailto:admin@example.com',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'registration_endpoint' must start with http:\\/\\/ or https:\\/\\//);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tjwks_uri: 'data:application/json,{}',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'jwks_uri' must start with http:\\/\\/ or https:\\/\\//);\n\t\t});\n\n\t\ttest('isAuthorizationDynamicClientRegistrationResponse should correctly identify registration response', () => {\n\t\t\t// Valid response\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse({\n\t\t\t\tclient_id: 'client-123',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t}), true);\n\n\t\t\t// Invalid cases\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse(null), false);\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse({}), false);\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse({ client_id: 'just-id' }), true);\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse({ client_name: 'missing-id' }), false);\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse('not an object'), false);\n\t\t});\n\n\t\ttest('isAuthorizationAuthorizeResponse should correctly identify authorization response', () => {\n\t\t\t// Valid response\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse({\n\t\t\t\tcode: 'auth-code-123',\n\t\t\t\tstate: 'state-123'\n\t\t\t}), true);\n\n\t\t\t// Invalid cases\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse(null), false);\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse({}), false);\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse({ code: 'missing-state' }), false);\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse({ state: 'missing-code' }), false);\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse('not an object'), false);\n\t\t});\n\n\t\ttest('isAuthorizationTokenResponse should correctly identify token response', () => {\n\t\t\t// Valid response\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse({\n\t\t\t\taccess_token: 'token-123',\n\t\t\t\ttoken_type: 'Bearer'\n\t\t\t}), true);\n\n\t\t\t// Invalid cases\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse(null), false);\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse({}), false);\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse({ access_token: 'missing-type' }), false);\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse({ token_type: 'missing-token' }), false);\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse('not an object'), false);\n\t\t});\n\n\t\ttest('isAuthorizationDeviceResponse should correctly identify device authorization response', () => {\n\t\t\t// Valid response\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({\n\t\t\t\tdevice_code: 'device-code-123',\n\t\t\t\tuser_code: 'ABCD-EFGH',\n\t\t\t\tverification_uri: 'https://example.com/verify',\n\t\t\t\texpires_in: 1800\n\t\t\t}), true);\n\n\t\t\t// Valid response with optional fields\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({\n\t\t\t\tdevice_code: 'device-code-123',\n\t\t\t\tuser_code: 'ABCD-EFGH',\n\t\t\t\tverification_uri: 'https://example.com/verify',\n\t\t\t\tverification_uri_complete: 'https://example.com/verify?user_code=ABCD-EFGH',\n\t\t\t\texpires_in: 1800,\n\t\t\t\tinterval: 5\n\t\t\t}), true);\n\n\t\t\t// Invalid cases\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse(null), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({}), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({ device_code: 'missing-others' }), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({ user_code: 'missing-others' }), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({ verification_uri: 'missing-others' }), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({ expires_in: 1800 }), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({\n\t\t\t\tdevice_code: 'device-code-123',\n\t\t\t\tuser_code: 'ABCD-EFGH',\n\t\t\t\tverification_uri: 'https://example.com/verify'\n\t\t\t\t// Missing expires_in\n\t\t\t}), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse('not an object'), false);\n\t\t});\n\n\t\ttest('isAuthorizationErrorResponse should correctly identify error response', () => {\n\t\t\t// Valid error response\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({\n\t\t\t\terror: 'authorization_pending',\n\t\t\t\terror_description: 'The authorization request is still pending'\n\t\t\t}), true);\n\n\t\t\t// Valid error response with different error codes\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({\n\t\t\t\terror: 'slow_down',\n\t\t\t\terror_description: 'Polling too fast'\n\t\t\t}), true);\n\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({\n\t\t\t\terror: 'access_denied',\n\t\t\t\terror_description: 'The user denied the request'\n\t\t\t}), true);\n\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({\n\t\t\t\terror: 'expired_token',\n\t\t\t\terror_description: 'The device code has expired'\n\t\t\t}), true);\n\n\t\t\t// Valid response with optional error_uri\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({\n\t\t\t\terror: 'invalid_request',\n\t\t\t\terror_description: 'The request is missing a required parameter',\n\t\t\t\terror_uri: 'https://example.com/error'\n\t\t\t}), true);\n\n\t\t\t// Invalid cases\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse(null), false);\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({}), false);\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({ error_description: 'missing-error' }), false);\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse('not an object'), false);\n\t\t});\n\t});\n\n\tsuite('Scope Matching', () => {\n\t\ttest('scopesMatch should return true for identical scopes', () => {\n\t\t\tconst scopes1 = ['test', 'scopes'];\n\t\t\tconst scopes2 = ['test', 'scopes'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), true);\n\t\t});\n\n\t\ttest('scopesMatch should return true for scopes in different order', () => {\n\t\t\tconst scopes1 = ['6f1cc985-85e8-487e-b0dd-aa633302a731/.default', 'VSCODE_TENANT:organizations'];\n\t\t\tconst scopes2 = ['VSCODE_TENANT:organizations', '6f1cc985-85e8-487e-b0dd-aa633302a731/.default'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), true);\n\t\t});\n\n\t\ttest('scopesMatch should return false for different scopes', () => {\n\t\t\tconst scopes1 = ['test', 'scopes'];\n\t\t\tconst scopes2 = ['different', 'scopes'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), false);\n\t\t});\n\n\t\ttest('scopesMatch should return false for different length arrays', () => {\n\t\t\tconst scopes1 = ['test'];\n\t\t\tconst scopes2 = ['test', 'scopes'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), false);\n\t\t});\n\n\t\ttest('scopesMatch should handle complex Microsoft scopes', () => {\n\t\t\tconst scopes1 = ['6f1cc985-85e8-487e-b0dd-aa633302a731/.default', 'VSCODE_TENANT:organizations'];\n\t\t\tconst scopes2 = ['VSCODE_TENANT:organizations', '6f1cc985-85e8-487e-b0dd-aa633302a731/.default'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), true);\n\t\t});\n\n\t\ttest('scopesMatch should handle empty arrays', () => {\n\t\t\tassert.strictEqual(scopesMatch([], []), true);\n\t\t});\n\n\t\ttest('scopesMatch should handle single scope arrays', () => {\n\t\t\tassert.strictEqual(scopesMatch(['single'], ['single']), true);\n\t\t\tassert.strictEqual(scopesMatch(['single'], ['different']), false);\n\t\t});\n\n\t\ttest('scopesMatch should handle duplicate scopes within arrays', () => {\n\t\t\tconst scopes1 = ['scope1', 'scope2', 'scope1'];\n\t\t\tconst scopes2 = ['scope2', 'scope1', 'scope1'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), true);\n\t\t});\n\n\t\ttest('scopesMatch should handle undefined values', () => {\n\t\t\tassert.strictEqual(scopesMatch(undefined, undefined), true);\n\t\t\tassert.strictEqual(scopesMatch(['read'], undefined), false);\n\t\t\tassert.strictEqual(scopesMatch(undefined, ['write']), false);\n\t\t});\n\n\t\ttest('scopesMatch should handle mixed undefined and empty arrays', () => {\n\t\t\tassert.strictEqual(scopesMatch([], undefined), false);\n\t\t\tassert.strictEqual(scopesMatch(undefined, []), false);\n\t\t\tassert.strictEqual(scopesMatch([], []), true);\n\t\t});\n\t});\n\n\tsuite('Utility Functions', () => {\n\t\ttest('getDefaultMetadataForUrl should return correct default endpoints', () => {\n\t\t\tconst authorizationServer = new URL('https://auth.example.com');\n\t\t\tconst metadata = getDefaultMetadataForUrl(authorizationServer);\n\n\t\t\tassert.strictEqual(metadata.issuer, 'https://auth.example.com/');\n\t\t\tassert.strictEqual(metadata.authorization_endpoint, 'https://auth.example.com/authorize');\n\t\t\tassert.strictEqual(metadata.token_endpoint, 'https://auth.example.com/token');\n\t\t\tassert.strictEqual(metadata.registration_endpoint, 'https://auth.example.com/register');\n\t\t\tassert.deepStrictEqual(metadata.response_types_supported, ['code', 'id_token', 'id_token token']);\n\t\t});\n\t});\n\n\tsuite('Parsing Functions', () => {\n\t\ttest('parseWWWAuthenticateHeader should correctly parse simple header', () => {\n\t\t\tconst result = parseWWWAuthenticateHeader('Bearer');\n\t\t\tassert.strictEqual(result.length, 1);\n\t\t\tassert.strictEqual(result[0].scheme, 'Bearer');\n\t\t\tassert.deepStrictEqual(result[0].params, {});\n\t\t});\n\n\t\ttest('parseWWWAuthenticateHeader should correctly parse header with parameters', () => {\n\t\t\tconst result = parseWWWAuthenticateHeader('Bearer realm=\"api\", error=\"invalid_token\", error_description=\"The access token expired\"');\n\n\t\t\tassert.strictEqual(result.length, 1);\n\t\t\tassert.strictEqual(result[0].scheme, 'Bearer');\n\t\t\tassert.deepStrictEqual(result[0].params, {\n\t\t\t\trealm: 'api',\n\t\t\t\terror: 'invalid_token',\n\t\t\t\terror_description: 'The access token expired'\n\t\t\t});\n\t\t});\n\n\t\ttest('parseWWWAuthenticateHeader should correctly parse parameters with equal signs', () => {\n\t\t\tconst result = parseWWWAuthenticateHeader('Bearer resource_metadata=\"https://example.com/.well-known/oauth-protected-resource?v=1\"');\n\t\t\tassert.strictEqual(result.length, 1);\n\t\t\tassert.strictEqual(result[0].scheme, 'Bearer');\n\t\t\tassert.deepStrictEqual(result[0].params, {\n\t\t\t\tresource_metadata: 'https://example.com/.well-known/oauth-protected-resource?v=1'\n\t\t\t});\n\t\t});\n\n\t\ttest('parseWWWAuthenticateHeader should correctly parse multiple', () => {\n\t\t\tconst result = parseWWWAuthenticateHeader('Bearer realm=\"api\", error=\"invalid_token\", error_description=\"The access token expired\", Basic realm=\"hi\"');\n\n\t\t\tassert.strictEqual(result.length, 2);\n\t\t\tassert.strictEqual(result[0].scheme, 'Bearer');\n\t\t\tassert.deepStrictEqual(result[0].params, {\n\t\t\t\trealm: 'api',\n\t\t\t\terror: 'invalid_token',\n\t\t\t\terror_description: 'The access token expired'\n\t\t\t});\n\t\t\tassert.strictEqual(result[1].scheme, 'Basic');\n\t\t\tassert.deepStrictEqual(result[1].params, {\n\t\t\t\trealm: 'hi'\n\t\t\t});\n\t\t});\n\n\n\t\ttest('getClaimsFromJWT should correctly parse a JWT token', () => {\n\t\t\t// Create a sample JWT with known payload\n\t\t\tconst payload: IAuthorizationJWTClaims = {\n\t\t\t\tjti: 'id123',\n\t\t\t\tsub: 'user123',\n\t\t\t\tiss: 'https://example.com',\n\t\t\t\taud: 'client123',\n\t\t\t\texp: 1716239022,\n\t\t\t\tiat: 1716235422,\n\t\t\t\tname: 'Test User'\n\t\t\t};\n\n\t\t\t// Create fake but properly formatted JWT\n\t\t\tconst header = { alg: 'HS256', typ: 'JWT' };\n\t\t\tconst encodedHeader = encodeBase64(VSBuffer.fromString(JSON.stringify(header)));\n\t\t\tconst encodedPayload = encodeBase64(VSBuffer.fromString(JSON.stringify(payload)));\n\t\t\tconst fakeSignature = 'fake-signature';\n\t\t\tconst token = `${encodedHeader}.${encodedPayload}.${fakeSignature}`;\n\n\t\t\tconst claims = getClaimsFromJWT(token);\n\t\t\tassert.deepStrictEqual(claims, payload);\n\t\t});\n\n\t\ttest('getClaimsFromJWT should throw for invalid JWT format', () => {\n\t\t\t// Test with wrong number of parts - should throw \"Invalid JWT token format\"\n\t\t\tassert.throws(() => getClaimsFromJWT('only.two'), /Invalid JWT token format.*three parts/);\n\t\t\tassert.throws(() => getClaimsFromJWT('one'), /Invalid JWT token format.*three parts/);\n\t\t\tassert.throws(() => getClaimsFromJWT('has.four.parts.here'), /Invalid JWT token format.*three parts/);\n\t\t});\n\n\t\ttest('getClaimsFromJWT should throw for invalid header content', () => {\n\t\t\t// Create JWT with invalid header\n\t\t\tconst encodedHeader = encodeBase64(VSBuffer.fromString('not-json'));\n\t\t\tconst encodedPayload = encodeBase64(VSBuffer.fromString(JSON.stringify({ sub: 'test' })));\n\t\t\tconst token = `${encodedHeader}.${encodedPayload}.signature`;\n\n\t\t\tassert.throws(() => getClaimsFromJWT(token), /Failed to parse JWT token/);\n\t\t});\n\n\t\ttest('getClaimsFromJWT should throw for invalid payload content', () => {\n\t\t\t// Create JWT with valid header but invalid payload\n\t\t\tconst header = { alg: 'HS256', typ: 'JWT' };\n\t\t\tconst encodedHeader = encodeBase64(VSBuffer.fromString(JSON.stringify(header)));\n\t\t\tconst encodedPayload = encodeBase64(VSBuffer.fromString('not-json'));\n\t\t\tconst token = `${encodedHeader}.${encodedPayload}.signature`;\n\n\t\t\tassert.throws(() => getClaimsFromJWT(token), /Failed to parse JWT token/);\n\t\t});\n\t});\n\n\tsuite('Network Functions', () => {\n\t\tlet sandbox: sinon.SinonSandbox;\n\t\tlet fetchStub: sinon.SinonStub;\n\n\t\tsetup(() => {\n\t\t\tsandbox = sinon.createSandbox();\n\t\t\tfetchStub = sandbox.stub(globalThis, 'fetch');\n\t\t});\n\n\t\tteardown(() => {\n\t\t\tsandbox.restore();\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should make correct request and parse response', async () => {\n\t\t\t// Setup successful response\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client',\n\t\t\t\tclient_uri: 'https://code.visualstudio.com'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tconst result = await fetchDynamicRegistration(\n\t\t\t\tserverMetadata,\n\t\t\t\t'Test Client'\n\t\t\t);\n\n\t\t\t// Verify fetch was called correctly\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\tconst [url, options] = fetchStub.firstCall.args;\n\t\t\tassert.strictEqual(url, 'https://auth.example.com/register');\n\t\t\tassert.strictEqual(options.method, 'POST');\n\t\t\tassert.strictEqual(options.headers['Content-Type'], 'application/json');\n\n\t\t\t// Verify request body\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.strictEqual(requestBody.client_name, 'Test Client');\n\t\t\tassert.strictEqual(requestBody.client_uri, 'https://code.visualstudio.com');\n\t\t\tassert.deepStrictEqual(requestBody.grant_types, ['authorization_code', 'refresh_token', 'urn:ietf:params:oauth:grant-type:device_code']);\n\t\t\tassert.deepStrictEqual(requestBody.response_types, ['code']);\n\t\t\tassert.deepStrictEqual(requestBody.redirect_uris, [\n\t\t\t\t'https://insiders.vscode.dev/redirect',\n\t\t\t\t'https://vscode.dev/redirect',\n\t\t\t\t'http://127.0.0.1/',\n\t\t\t\t`http://127.0.0.1:${DEFAULT_AUTH_FLOW_PORT}/`\n\t\t\t]);\n\n\t\t\t// Verify response is processed correctly\n\t\t\tassert.deepStrictEqual(result, mockResponse);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should throw error on non-OK response', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\tstatusText: 'Bad Request',\n\t\t\t\ttext: async () => 'Bad Request'\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Registration to https:\\/\\/auth\\.example\\.com\\/register failed: Bad Request/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should throw error on invalid response format', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => ({ invalid: 'response' }) // Missing required fields\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Invalid authorization dynamic client registration response/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should filter grant types based on server metadata', async () => {\n\t\t\t// Setup successful response\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code'],\n\t\t\t\tgrant_types_supported: ['authorization_code', 'client_credentials', 'refresh_token'] // Mix of supported and unsupported\n\t\t\t};\n\n\t\t\tawait fetchDynamicRegistration(serverMetadata, 'Test Client');\n\n\t\t\t// Verify fetch was called correctly\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\tconst [, options] = fetchStub.firstCall.args;\n\n\t\t\t// Verify request body contains only the intersection of supported grant types\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.deepStrictEqual(requestBody.grant_types, ['authorization_code', 'refresh_token']); // client_credentials should be filtered out\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should use default grant types when server metadata has none', async () => {\n\t\t\t// Setup successful response\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t\t// No grant_types_supported specified\n\t\t\t};\n\n\t\t\tawait fetchDynamicRegistration(serverMetadata, 'Test Client');\n\n\t\t\t// Verify fetch was called correctly\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\tconst [, options] = fetchStub.firstCall.args;\n\n\t\t\t// Verify request body contains default grant types\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.deepStrictEqual(requestBody.grant_types, ['authorization_code', 'refresh_token', 'urn:ietf:params:oauth:grant-type:device_code']);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should throw error when registration endpoint is missing', async () => {\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t\t// registration_endpoint is missing\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Server does not support dynamic registration/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle structured error response', async () => {\n\t\t\tconst errorResponse = {\n\t\t\t\terror: 'invalid_client_metadata',\n\t\t\t\terror_description: 'The client metadata is invalid'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\ttext: async () => JSON.stringify(errorResponse)\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Registration to https:\\/\\/auth\\.example\\.com\\/register failed: invalid_client_metadata: The client metadata is invalid/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle structured error response without description', async () => {\n\t\t\tconst errorResponse = {\n\t\t\t\terror: 'invalid_redirect_uri'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\ttext: async () => JSON.stringify(errorResponse)\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Registration to https:\\/\\/auth\\.example\\.com\\/register failed: invalid_redirect_uri/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle malformed JSON error response', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\ttext: async () => 'Invalid JSON {'\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Registration to https:\\/\\/auth\\.example\\.com\\/register failed: Invalid JSON \\{/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should include scopes in request when provided', async () => {\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait fetchDynamicRegistration(serverMetadata, 'Test Client', ['read', 'write']);\n\n\t\t\t// Verify request includes scopes\n\t\t\tconst [, options] = fetchStub.firstCall.args;\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.strictEqual(requestBody.scope, 'read write');\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should omit scope from request when not provided', async () => {\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait fetchDynamicRegistration(serverMetadata, 'Test Client');\n\n\t\t\t// Verify request does not include scope when not provided\n\t\t\tconst [, options] = fetchStub.firstCall.args;\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.strictEqual(requestBody.scope, undefined);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle empty scopes array', async () => {\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait fetchDynamicRegistration(serverMetadata, 'Test Client', []);\n\n\t\t\t// Verify request includes empty scope\n\t\t\tconst [, options] = fetchStub.firstCall.args;\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.strictEqual(requestBody.scope, '');\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle network fetch failure', async () => {\n\t\t\tfetchStub.rejects(new Error('Network error'));\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Network error/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle response.json() failure', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => {\n\t\t\t\t\tthrow new Error('JSON parsing failed');\n\t\t\t\t}\n\t\t\t} as unknown as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/JSON parsing failed/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle response.text() failure for error cases', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\ttext: async () => {\n\t\t\t\t\tthrow new Error('Text parsing failed');\n\t\t\t\t}\n\t\t\t} as unknown as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Text parsing failed/\n\t\t\t);\n\t\t});\n\t});\n\n\tsuite('Client ID Fallback Scenarios', () => {\n\t\tlet sandbox: sinon.SinonSandbox;\n\t\tlet fetchStub: sinon.SinonStub;\n\n\t\tsetup(() => {\n\t\t\tsandbox = sinon.createSandbox();\n\t\t\tfetchStub = sandbox.stub(globalThis, 'fetch');\n\t\t});\n\n\t\tteardown(() => {\n\t\t\tsandbox.restore();\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should throw specific error for missing registration endpoint', async () => {\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t\t// registration_endpoint is missing\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t{\n\t\t\t\t\tmessage: 'Server does not support dynamic registration'\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should throw specific error for DCR failure', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\ttext: async () => 'DCR not supported'\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Registration to https:\\/\\/auth\\.example\\.com\\/register failed: DCR not supported/\n\t\t\t);\n\t\t});\n\t});\n\n\tsuite('fetchResourceMetadata', () => {\n\t\tlet sandbox: sinon.SinonSandbox;\n\t\tlet fetchStub: sinon.SinonStub;\n\n\t\tsetup(() => {\n\t\t\tsandbox = sinon.createSandbox();\n\t\t\tfetchStub = sandbox.stub();\n\t\t});\n\n\t\tteardown(() => {\n\t\t\tsandbox.restore();\n\t\t});\n\n\t\ttest('should successfully fetch and validate resource metadata', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api',\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tresourceMetadataUrl,\n\t\t\t\t{ fetch: fetchStub }\n\t\t\t);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], resourceMetadataUrl);\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[1].method, 'GET');\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[1].headers['Accept'], 'application/json');\n\t\t});\n\n\t\ttest('should include same-origin headers when origins match', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst sameOriginHeaders = {\n\t\t\t\t'X-Test-Header': 'test-value',\n\t\t\t\t'X-Custom-Header': 'value'\n\t\t\t};\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tawait fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tresourceMetadataUrl,\n\t\t\t\t{ fetch: fetchStub, sameOriginHeaders }\n\t\t\t);\n\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['Accept'], 'application/json');\n\t\t\tassert.strictEqual(headers['X-Test-Header'], 'test-value');\n\t\t\tassert.strictEqual(headers['X-Custom-Header'], 'value');\n\t\t});\n\n\t\ttest('should not include same-origin headers when origins differ', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://other-domain.com/.well-known/oauth-protected-resource';\n\t\t\tconst sameOriginHeaders = {\n\t\t\t\t'X-Test-Header': 'test-value'\n\t\t\t};\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tawait fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tresourceMetadataUrl,\n\t\t\t\t{ fetch: fetchStub, sameOriginHeaders }\n\t\t\t);\n\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['Accept'], 'application/json');\n\t\t\tassert.strictEqual(headers['X-Test-Header'], undefined);\n\t\t});\n\n\t\ttest('should throw error when fetch returns non-200 status', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/Failed to fetch resource metadata from.*404 Not Found/\n\t\t\t);\n\t\t});\n\n\t\ttest('should handle error when response.text() throws', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 500,\n\t\t\t\tstatusText: 'Internal Server Error',\n\t\t\t\ttext: async () => { throw new Error('Cannot read response'); }\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/Failed to fetch resource metadata from.*500 Internal Server Error/\n\t\t\t);\n\t\t});\n\n\t\ttest('should throw error when resource property does not match target resource', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://different.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/Protected Resource Metadata resource property value.*does not match target server url.*These MUST match to follow OAuth spec/\n\t\t\t);\n\t\t});\n\n\t\ttest('should normalize URLs when comparing resource values', async () => {\n\t\t\tconst targetResource = 'https://EXAMPLE.COM/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\t// URL normalization should handle hostname case differences\n\t\t\tconst result = await fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub });\n\t\t\tassert.deepStrictEqual(result, metadata);\n\t\t});\n\n\t\ttest('should normalize hostnames when comparing resource values', async () => {\n\t\t\tconst targetResource = 'https://EXAMPLE.COM/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub });\n\t\t\tassert.deepStrictEqual(result, metadata);\n\t\t});\n\n\t\ttest('should throw error when response is not valid resource metadata', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst invalidMetadata = {\n\t\t\t\t// Missing required 'resource' property\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => invalidMetadata,\n\t\t\t\ttext: async () => JSON.stringify(invalidMetadata)\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/Invalid resource metadata.*Expected to follow shape of.*is scopes_supported an array\\? Is resource a string\\?/\n\t\t\t);\n\t\t});\n\n\t\ttest('should throw error when scopes_supported is not an array', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst invalidMetadata = {\n\t\t\t\tresource: 'https://example.com/api',\n\t\t\t\tscopes_supported: 'not an array'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => invalidMetadata,\n\t\t\t\ttext: async () => JSON.stringify(invalidMetadata)\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/Invalid resource metadata/\n\t\t\t);\n\t\t});\n\n\t\ttest('should handle metadata with optional fields', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://example.com/api',\n\t\t\t\tresource_name: 'Example API',\n\t\t\t\tauthorization_servers: ['https://auth.example.com'],\n\t\t\t\tjwks_uri: 'https://example.com/jwks',\n\t\t\t\tscopes_supported: ['read', 'write', 'admin'],\n\t\t\t\tbearer_methods_supported: ['header', 'body'],\n\t\t\t\tresource_documentation: 'https://example.com/docs'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub });\n\t\t\tassert.deepStrictEqual(result, metadata);\n\t\t});\n\n\t\ttest('should use global fetch when custom fetch is not provided', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tconst globalFetchStub = sandbox.stub(globalThis, 'fetch').resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t} as any);\n\n\t\t\tconst result = await fetchResourceMetadata(targetResource, resourceMetadataUrl);\n\n\t\t\tassert.deepStrictEqual(result, metadata);\n\t\t\tassert.strictEqual(globalFetchStub.callCount, 1);\n\t\t});\n\n\t\ttest('should handle same origin with different ports', async () => {\n\t\t\tconst targetResource = 'https://example.com:8080/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com:9090/.well-known/oauth-protected-resource';\n\t\t\tconst sameOriginHeaders = {\n\t\t\t\t'X-Test-Header': 'test-value'\n\t\t\t};\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://example.com:8080/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\tawait fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tresourceMetadataUrl,\n\t\t\t\t{ fetch: fetchStub, sameOriginHeaders }\n\t\t\t);\n\n\t\t\t// Different ports mean different origins\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['X-Test-Header'], undefined);\n\t\t});\n\n\t\ttest('should handle same origin with different protocols', async () => {\n\t\t\tconst targetResource = 'http://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst sameOriginHeaders = {\n\t\t\t\t'X-Test-Header': 'test-value'\n\t\t\t};\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'http://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\tawait fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tresourceMetadataUrl,\n\t\t\t\t{ fetch: fetchStub, sameOriginHeaders }\n\t\t\t);\n\n\t\t\t// Different protocols mean different origins\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['X-Test-Header'], undefined);\n\t\t});\n\n\t\ttest('should include error details in message with length information', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://different.com/other'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tawait fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub });\n\t\t\t\tassert.fail('Should have thrown an error');\n\t\t\t} catch (error: any) {\n\t\t\t\tassert.ok(/length:/.test(error.message), 'Error message should include length information');\n\t\t\t\tassert.ok(/https:\\/\\/different\\.com\\/other/.test(error.message), 'Error message should include actual resource value');\n\t\t\t\tassert.ok(/https:\\/\\/example\\.com\\/api/.test(error.message), 'Error message should include expected resource value');\n\t\t\t}\n\t\t});\n\n\t\ttest('should fallback to well-known URI with path when no resourceMetadataUrl provided', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api/v1',\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tundefined,\n\t\t\t\t{ fetch: fetchStub }\n\t\t\t);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\t// Should try path-appended version first\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://example.com/.well-known/oauth-protected-resource/api/v1');\n\t\t});\n\n\t\ttest('should fallback to well-known URI at root when path version fails', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api/v1',\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t};\n\n\t\t\t// First call fails, second succeeds\n\t\t\tfetchStub.onFirstCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found'\n\t\t\t});\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tundefined,\n\t\t\t\t{ fetch: fetchStub }\n\t\t\t);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t\t// First attempt with path\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://example.com/.well-known/oauth-protected-resource/api/v1');\n\t\t\t// Second attempt at root\n\t\t\tassert.strictEqual(fetchStub.secondCall.args[0], 'https://example.com/.well-known/oauth-protected-resource');\n\t\t});\n\n\t\ttest('should throw error when all well-known URIs fail', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, undefined, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 2, 'Should contain 2 errors');\n\t\t\t\t\tassert.ok(/Failed to fetch resource metadata from.*\\/api\\/v1.*404/.test(error.errors[0].message), 'First error should mention /api/v1 and 404');\n\t\t\t\t\tassert.ok(/Failed to fetch resource metadata from.*\\.well-known.*404/.test(error.errors[1].message), 'Second error should mention .well-known and 404');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t); assert.strictEqual(fetchStub.callCount, 2);\n\t\t});\n\n\t\ttest('should not append path when target resource is root', async () => {\n\t\t\tconst targetResource = 'https://example.com/';\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/',\n\t\t\t\tscopes_supported: ['read']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tundefined,\n\t\t\t\t{ fetch: fetchStub }\n\t\t\t);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\t// Both URLs should be the same when path is /\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://example.com/.well-known/oauth-protected-resource');\n\t\t});\n\n\t\ttest('should include same-origin headers when using well-known fallback', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst sameOriginHeaders = {\n\t\t\t\t'X-Test-Header': 'test-value',\n\t\t\t\t'X-Custom-Header': 'value'\n\t\t\t};\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tawait fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tundefined,\n\t\t\t\t{ fetch: fetchStub, sameOriginHeaders }\n\t\t\t);\n\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['Accept'], 'application/json');\n\t\t\tassert.strictEqual(headers['X-Test-Header'], 'test-value');\n\t\t\tassert.strictEqual(headers['X-Custom-Header'], 'value');\n\t\t});\n\n\t\ttest('should handle fetchImpl throwing network error and continue to next URL', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api/v1',\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t};\n\n\t\t\t// First call throws network error, second succeeds\n\t\t\tfetchStub.onFirstCall().rejects(new Error('Network connection failed'));\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tundefined,\n\t\t\t\t{ fetch: fetchStub }\n\t\t\t);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t\t// First attempt with path should have thrown error\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://example.com/.well-known/oauth-protected-resource/api/v1');\n\t\t\t// Second attempt at root should succeed\n\t\t\tassert.strictEqual(fetchStub.secondCall.args[0], 'https://example.com/.well-known/oauth-protected-resource');\n\t\t});\n\n\t\ttest('should throw AggregateError when fetchImpl throws on all URLs', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\n\t\t\t// Both calls throw network errors\n\t\t\tfetchStub.rejects(new Error('Network connection failed'));\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, undefined, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 2, 'Should contain 2 errors');\n\t\t\t\t\tassert.ok(/Network connection failed/.test(error.errors[0].message), 'First error should mention network failure');\n\t\t\t\t\tassert.ok(/Network connection failed/.test(error.errors[1].message), 'Second error should mention network failure');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t});\n\n\t\ttest('should handle mix of fetch error and non-200 response', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\n\t\t\t// First call throws network error\n\t\t\tfetchStub.onFirstCall().rejects(new Error('Connection timeout'));\n\n\t\t\t// Second call returns 404\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, undefined, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 2, 'Should contain 2 errors');\n\t\t\t\t\tassert.ok(/Connection timeout/.test(error.errors[0].message), 'First error should be network error');\n\t\t\t\t\tassert.ok(/Failed to fetch resource metadata.*404/.test(error.errors[1].message), 'Second error should be 404');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t});\n\n\t\ttest('should handle fetchImpl throwing error with explicit resourceMetadataUrl', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\n\t\t\tfetchStub.rejects(new Error('DNS resolution failed'));\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/DNS resolution failed/\n\t\t\t);\n\n\t\t\t// Should only try once when explicit URL is provided\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], resourceMetadataUrl);\n\t\t});\n\t});\n\n\tsuite('fetchAuthorizationServerMetadata', () => {\n\t\tlet sandbox: sinon.SinonSandbox;\n\t\tlet fetchStub: sinon.SinonStub;\n\n\t\tsetup(() => {\n\t\t\tsandbox = sinon.createSandbox();\n\t\t\tfetchStub = sandbox.stub();\n\t\t});\n\n\t\tteardown(() => {\n\t\t\tsandbox.restore();\n\t\t});\n\n\t\ttest('should successfully fetch metadata from OAuth discovery endpoint with path insertion', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/tenant/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/tenant/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\t// Should try OAuth discovery with path insertion: https://auth.example.com/.well-known/oauth-authorization-server/tenant\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://auth.example.com/.well-known/oauth-authorization-server/tenant');\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[1].method, 'GET');\n\t\t});\n\n\t\ttest('should fallback to OpenID Connect discovery with path insertion', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/tenant/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/tenant/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// First call fails, second succeeds\n\t\t\tfetchStub.onFirstCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t\t// First attempt: OAuth discovery\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://auth.example.com/.well-known/oauth-authorization-server/tenant');\n\t\t\t// Second attempt: OpenID Connect discovery with path insertion\n\t\t\tassert.strictEqual(fetchStub.secondCall.args[0], 'https://auth.example.com/.well-known/openid-configuration/tenant');\n\t\t});\n\n\t\ttest('should fallback to OpenID Connect discovery with path addition', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/tenant/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/tenant/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// First two calls fail, third succeeds\n\t\t\tfetchStub.onFirstCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tfetchStub.onThirdCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t\t// First attempt: OAuth discovery\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://auth.example.com/.well-known/oauth-authorization-server/tenant');\n\t\t\t// Second attempt: OpenID Connect discovery with path insertion\n\t\t\tassert.strictEqual(fetchStub.secondCall.args[0], 'https://auth.example.com/.well-known/openid-configuration/tenant');\n\t\t\t// Third attempt: OpenID Connect discovery with path addition\n\t\t\tassert.strictEqual(fetchStub.thirdCall.args[0], 'https://auth.example.com/tenant/.well-known/openid-configuration');\n\t\t});\n\n\t\ttest('should handle authorization server at root without extra path', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\t// For root URLs, no extra path is added\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://auth.example.com/.well-known/oauth-authorization-server');\n\t\t});\n\n\t\ttest('should handle authorization server with trailing slash', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant/';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant/',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/tenant/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/tenant/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t});\n\n\t\ttest('should include additional headers in all requests', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\t\t\tconst additionalHeaders = {\n\t\t\t\t'X-Custom-Header': 'custom-value',\n\t\t\t\t'Authorization': 'Bearer token123'\n\t\t\t};\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tawait fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub, additionalHeaders });\n\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['X-Custom-Header'], 'custom-value');\n\t\t\tassert.strictEqual(headers['Authorization'], 'Bearer token123');\n\t\t\tassert.strictEqual(headers['Accept'], 'application/json');\n\t\t});\n\t\ttest('should throw AggregateError when all discovery endpoints fail', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 3, 'Should contain 3 errors (one for each URL)');\n\t\t\t\t\tassert.strictEqual(error.message, 'Failed to fetch authorization server metadata from all attempted URLs');\n\t\t\t\t\t// Verify each error includes the URL it attempted\n\t\t\t\t\tassert.ok(/oauth-authorization-server.*404/.test(error.errors[0].message), 'First error should mention OAuth discovery and 404');\n\t\t\t\t\tassert.ok(/openid-configuration.*404/.test(error.errors[1].message), 'Second error should mention OpenID path insertion and 404');\n\t\t\t\t\tassert.ok(/openid-configuration.*404/.test(error.errors[2].message), 'Third error should mention OpenID path addition and 404');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// Should have tried all three endpoints\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t});\n\n\t\ttest('should throw single error (not AggregateError) when only one URL is tried and fails', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\n\t\t\t// First attempt succeeds on second try, so only one error is collected for first URL\n\t\t\tfetchStub.onFirstCall().resolves({\n\t\t\t\tstatus: 500,\n\t\t\t\ttext: async () => 'Internal Server Error',\n\t\t\t\tstatusText: 'Internal Server Error',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\t// Should succeed on second attempt\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t});\n\n\t\ttest('should throw AggregateError when multiple URLs fail with mixed error types', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\n\t\t\t// First call: network error\n\t\t\tfetchStub.onFirstCall().rejects(new Error('Connection timeout'));\n\n\t\t\t// Second call: 404\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\t// Third call: 500\n\t\t\tfetchStub.onThirdCall().resolves({\n\t\t\t\tstatus: 500,\n\t\t\t\ttext: async () => 'Internal Server Error',\n\t\t\t\tstatusText: 'Internal Server Error',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 3, 'Should contain 3 errors');\n\t\t\t\t\t// First error is network error\n\t\t\t\t\tassert.ok(/Connection timeout/.test(error.errors[0].message), 'First error should be network error');\n\t\t\t\t\t// Second error is 404\n\t\t\t\t\tassert.ok(/404.*Not Found/.test(error.errors[1].message), 'Second error should be 404');\n\t\t\t\t\t// Third error is 500\n\t\t\t\t\tassert.ok(/500.*Internal Server Error/.test(error.errors[2].message), 'Third error should be 500');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t});\n\n\t\ttest('should handle invalid JSON response', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => { throw new Error('Invalid JSON'); },\n\t\t\t\ttext: async () => 'Invalid JSON',\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t/Failed to fetch authorization server metadata/\n\t\t\t);\n\t\t});\n\n\t\ttest('should handle valid JSON but invalid metadata structure', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst invalidMetadata = {\n\t\t\t\t// Missing required 'issuer' field\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/authorize'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => invalidMetadata,\n\t\t\t\ttext: async () => JSON.stringify(invalidMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t/Failed to fetch authorization server metadata/\n\t\t\t);\n\t\t});\n\n\t\ttest('should use global fetch when custom fetch is not provided', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tconst globalFetchStub = sandbox.stub(globalThis, 'fetch').resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t} as any);\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(globalFetchStub.callCount, 1);\n\t\t});\n\n\t\ttest('should handle network fetch failure and continue to next endpoint', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// First call throws network error, second succeeds\n\t\t\tfetchStub.onFirstCall().rejects(new Error('Network error'));\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\t// Should have tried two endpoints\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t});\n\n\t\ttest('should throw error when network fails on all endpoints', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\n\t\t\tfetchStub.rejects(new Error('Network error'));\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 3, 'Should contain 3 errors');\n\t\t\t\t\tassert.strictEqual(error.message, 'Failed to fetch authorization server metadata from all attempted URLs');\n\t\t\t\t\t// All errors should be network errors\n\t\t\t\t\tassert.ok(/Network error/.test(error.errors[0].message), 'First error should be network error');\n\t\t\t\t\tassert.ok(/Network error/.test(error.errors[1].message), 'Second error should be network error');\n\t\t\t\t\tassert.ok(/Network error/.test(error.errors[2].message), 'Third error should be network error');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// Should have tried all three endpoints\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t});\n\n\t\ttest('should handle mix of network error and non-200 response', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// First call throws network error\n\t\t\tfetchStub.onFirstCall().rejects(new Error('Connection timeout'));\n\n\t\t\t// Second call returns 404\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\t// Third call succeeds\n\t\t\tfetchStub.onThirdCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\t// Should have tried all three endpoints\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t});\n\n\t\ttest('should handle response.text() failure in error case', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 500,\n\t\t\t\ttext: async () => { throw new Error('Cannot read text'); },\n\t\t\t\tstatusText: 'Internal Server Error',\n\t\t\t\tjson: async () => { throw new Error('Cannot read json'); }\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 3, 'Should contain 3 errors');\n\t\t\t\t\t// All errors should include status code and statusText (fallback when text() fails)\n\t\t\t\t\tfor (const err of error.errors) {\n\t\t\t\t\t\tassert.ok(/500 Internal Server Error/.test(err.message), `Error should mention 500 and statusText: ${err.message}`);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\n\t\ttest('should correctly handle path addition with trailing slash', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant/';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant/',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// First two calls fail, third succeeds\n\t\t\tfetchStub.onFirstCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tfetchStub.onThirdCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t\t// Third attempt should correctly handle trailing slash (not double-slash)\n\t\t\tassert.strictEqual(fetchStub.thirdCall.args[0], 'https://auth.example.com/tenant/.well-known/openid-configuration');\n\t\t});\n\n\t\ttest('should handle deeply nested paths', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant/org/sub';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant/org/sub',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\t// Should correctly insert well-known path with nested paths\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://auth.example.com/.well-known/oauth-authorization-server/tenant/org/sub');\n\t\t});\n\n\t\ttest('should handle 200 response with non-metadata JSON', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst invalidResponse = {\n\t\t\t\terror: 'not_supported',\n\t\t\t\tmessage: 'Metadata not available'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => invalidResponse,\n\t\t\t\ttext: async () => JSON.stringify(invalidResponse),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 3, 'Should contain 3 errors');\n\t\t\t\t\t// All errors should indicate failed to fetch with status code\n\t\t\t\t\tfor (const err of error.errors) {\n\t\t\t\t\t\tassert.ok(/Failed to fetch authorization server metadata from/.test(err.message), `Error should mention failed fetch: ${err.message}`);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// Should try all three endpoints\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t});\n\n\t\ttest('should validate metadata according to isAuthorizationServerMetadata', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\t// Valid metadata with all required fields\n\t\t\tconst validMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/token',\n\t\t\t\tjwks_uri: 'https://auth.example.com/jwks',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code', 'token']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => validMetadata,\n\t\t\t\ttext: async () => JSON.stringify(validMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, validMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t});\n\n\t\ttest('should handle URLs with query parameters', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant?version=v2';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant?version=v2',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t});\n\n\t\ttest('should handle empty additionalHeaders', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tawait fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub, additionalHeaders: {} });\n\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['Accept'], 'application/json');\n\t\t});\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport * as sinon from 'sinon';\nimport {\n\tgetClaimsFromJWT,\n\tgetDefaultMetadataForUrl,\n\tisAuthorizationAuthorizeResponse,\n\tisAuthorizationDeviceResponse,\n\tisAuthorizationErrorResponse,\n\tisAuthorizationDynamicClientRegistrationResponse,\n\tisAuthorizationProtectedResourceMetadata,\n\tisAuthorizationServerMetadata,\n\tisAuthorizationTokenResponse,\n\tparseWWWAuthenticateHeader,\n\tfetchDynamicRegistration,\n\tfetchResourceMetadata,\n\tfetchAuthorizationServerMetadata,\n\tscopesMatch,\n\tIAuthorizationJWTClaims,\n\tIAuthorizationServerMetadata,\n\tDEFAULT_AUTH_FLOW_PORT\n} from '../../common/oauth.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from './utils.js';\nimport { encodeBase64, VSBuffer } from '../../common/buffer.js';\n\nsuite('OAuth', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\tsuite('Type Guards', () => {\n\t\ttest('isAuthorizationProtectedResourceMetadata should correctly identify protected resource metadata', () => {\n\t\t\t// Valid metadata with minimal required fields\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata({ resource: 'https://example.com' }), true);\n\n\t\t\t// Valid metadata with scopes_supported as array\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata({\n\t\t\t\tresource: 'https://example.com',\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t}), true);\n\n\t\t\t// Invalid cases - missing resource\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata(null), false);\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata({}), false);\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata('not an object'), false);\n\n\t\t\t// Invalid cases - scopes_supported is not an array when provided\n\t\t\tassert.strictEqual(isAuthorizationProtectedResourceMetadata({\n\t\t\t\tresource: 'https://example.com',\n\t\t\t\tscopes_supported: 'not an array'\n\t\t\t}), false);\n\t\t});\n\n\t\ttest('isAuthorizationServerMetadata should correctly identify server metadata', () => {\n\t\t\t// Valid metadata with minimal required fields\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), true);\n\n\t\t\t// Valid metadata with valid URLs\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tauthorization_endpoint: 'https://example.com/auth',\n\t\t\t\ttoken_endpoint: 'https://example.com/token',\n\t\t\t\tregistration_endpoint: 'https://example.com/register',\n\t\t\t\tjwks_uri: 'https://example.com/jwks',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), true);\n\n\t\t\t// Valid metadata with http URLs (for localhost/testing)\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'http://localhost:8080',\n\t\t\t\tauthorization_endpoint: 'http://localhost:8080/auth',\n\t\t\t\ttoken_endpoint: 'http://localhost:8080/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), true);\n\n\t\t\t// Invalid cases - not an object\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata(null), false);\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationServerMetadata('not an object'), false);\n\n\t\t\t// Invalid cases - missing issuer should throw\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({}), /Authorization server metadata must have an issuer/);\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({ response_types_supported: ['code'] }), /Authorization server metadata must have an issuer/);\n\n\t\t\t// Invalid cases - URI fields must be strings when provided (truthy values)\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tauthorization_endpoint: 123,\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'authorization_endpoint' must be a string/);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\ttoken_endpoint: 123,\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'token_endpoint' must be a string/);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tregistration_endpoint: [],\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'registration_endpoint' must be a string/);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tjwks_uri: {},\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'jwks_uri' must be a string/);\n\n\t\t\t// Invalid cases - URI fields must start with http:// or https://\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'ftp://example.com',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'issuer' must start with http:\\/\\/ or https:\\/\\//);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tauthorization_endpoint: 'ftp://example.com/auth',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'authorization_endpoint' must start with http:\\/\\/ or https:\\/\\//);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\ttoken_endpoint: 'file:///path/to/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'token_endpoint' must start with http:\\/\\/ or https:\\/\\//);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tregistration_endpoint: 'mailto:admin@example.com',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'registration_endpoint' must start with http:\\/\\/ or https:\\/\\//);\n\n\t\t\tassert.throws(() => isAuthorizationServerMetadata({\n\t\t\t\tissuer: 'https://example.com',\n\t\t\t\tjwks_uri: 'data:application/json,{}',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t}), /Authorization server metadata 'jwks_uri' must start with http:\\/\\/ or https:\\/\\//);\n\t\t});\n\n\t\ttest('isAuthorizationDynamicClientRegistrationResponse should correctly identify registration response', () => {\n\t\t\t// Valid response\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse({\n\t\t\t\tclient_id: 'client-123',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t}), true);\n\n\t\t\t// Invalid cases\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse(null), false);\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse({}), false);\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse({ client_id: 'just-id' }), true);\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse({ client_name: 'missing-id' }), false);\n\t\t\tassert.strictEqual(isAuthorizationDynamicClientRegistrationResponse('not an object'), false);\n\t\t});\n\n\t\ttest('isAuthorizationAuthorizeResponse should correctly identify authorization response', () => {\n\t\t\t// Valid response\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse({\n\t\t\t\tcode: 'auth-code-123',\n\t\t\t\tstate: 'state-123'\n\t\t\t}), true);\n\n\t\t\t// Invalid cases\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse(null), false);\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse({}), false);\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse({ code: 'missing-state' }), false);\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse({ state: 'missing-code' }), false);\n\t\t\tassert.strictEqual(isAuthorizationAuthorizeResponse('not an object'), false);\n\t\t});\n\n\t\ttest('isAuthorizationTokenResponse should correctly identify token response', () => {\n\t\t\t// Valid response\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse({\n\t\t\t\taccess_token: 'token-123',\n\t\t\t\ttoken_type: 'Bearer'\n\t\t\t}), true);\n\n\t\t\t// Invalid cases\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse(null), false);\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse({}), false);\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse({ access_token: 'missing-type' }), false);\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse({ token_type: 'missing-token' }), false);\n\t\t\tassert.strictEqual(isAuthorizationTokenResponse('not an object'), false);\n\t\t});\n\n\t\ttest('isAuthorizationDeviceResponse should correctly identify device authorization response', () => {\n\t\t\t// Valid response\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({\n\t\t\t\tdevice_code: 'device-code-123',\n\t\t\t\tuser_code: 'ABCD-EFGH',\n\t\t\t\tverification_uri: 'https://example.com/verify',\n\t\t\t\texpires_in: 1800\n\t\t\t}), true);\n\n\t\t\t// Valid response with optional fields\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({\n\t\t\t\tdevice_code: 'device-code-123',\n\t\t\t\tuser_code: 'ABCD-EFGH',\n\t\t\t\tverification_uri: 'https://example.com/verify',\n\t\t\t\tverification_uri_complete: 'https://example.com/verify?user_code=ABCD-EFGH',\n\t\t\t\texpires_in: 1800,\n\t\t\t\tinterval: 5\n\t\t\t}), true);\n\n\t\t\t// Invalid cases\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse(null), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({}), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({ device_code: 'missing-others' }), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({ user_code: 'missing-others' }), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({ verification_uri: 'missing-others' }), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({ expires_in: 1800 }), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse({\n\t\t\t\tdevice_code: 'device-code-123',\n\t\t\t\tuser_code: 'ABCD-EFGH',\n\t\t\t\tverification_uri: 'https://example.com/verify'\n\t\t\t\t// Missing expires_in\n\t\t\t}), false);\n\t\t\tassert.strictEqual(isAuthorizationDeviceResponse('not an object'), false);\n\t\t});\n\n\t\ttest('isAuthorizationErrorResponse should correctly identify error response', () => {\n\t\t\t// Valid error response\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({\n\t\t\t\terror: 'authorization_pending',\n\t\t\t\terror_description: 'The authorization request is still pending'\n\t\t\t}), true);\n\n\t\t\t// Valid error response with different error codes\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({\n\t\t\t\terror: 'slow_down',\n\t\t\t\terror_description: 'Polling too fast'\n\t\t\t}), true);\n\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({\n\t\t\t\terror: 'access_denied',\n\t\t\t\terror_description: 'The user denied the request'\n\t\t\t}), true);\n\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({\n\t\t\t\terror: 'expired_token',\n\t\t\t\terror_description: 'The device code has expired'\n\t\t\t}), true);\n\n\t\t\t// Valid response with optional error_uri\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({\n\t\t\t\terror: 'invalid_request',\n\t\t\t\terror_description: 'The request is missing a required parameter',\n\t\t\t\terror_uri: 'https://example.com/error'\n\t\t\t}), true);\n\n\t\t\t// Invalid cases\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse(null), false);\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse(undefined), false);\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({}), false);\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse({ error_description: 'missing-error' }), false);\n\t\t\tassert.strictEqual(isAuthorizationErrorResponse('not an object'), false);\n\t\t});\n\t});\n\n\tsuite('Scope Matching', () => {\n\t\ttest('scopesMatch should return true for identical scopes', () => {\n\t\t\tconst scopes1 = ['test', 'scopes'];\n\t\t\tconst scopes2 = ['test', 'scopes'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), true);\n\t\t});\n\n\t\ttest('scopesMatch should return true for scopes in different order', () => {\n\t\t\tconst scopes1 = ['6f1cc985-85e8-487e-b0dd-aa633302a731/.default', 'VSCODE_TENANT:organizations'];\n\t\t\tconst scopes2 = ['VSCODE_TENANT:organizations', '6f1cc985-85e8-487e-b0dd-aa633302a731/.default'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), true);\n\t\t});\n\n\t\ttest('scopesMatch should return false for different scopes', () => {\n\t\t\tconst scopes1 = ['test', 'scopes'];\n\t\t\tconst scopes2 = ['different', 'scopes'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), false);\n\t\t});\n\n\t\ttest('scopesMatch should return false for different length arrays', () => {\n\t\t\tconst scopes1 = ['test'];\n\t\t\tconst scopes2 = ['test', 'scopes'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), false);\n\t\t});\n\n\t\ttest('scopesMatch should handle complex Microsoft scopes', () => {\n\t\t\tconst scopes1 = ['6f1cc985-85e8-487e-b0dd-aa633302a731/.default', 'VSCODE_TENANT:organizations'];\n\t\t\tconst scopes2 = ['VSCODE_TENANT:organizations', '6f1cc985-85e8-487e-b0dd-aa633302a731/.default'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), true);\n\t\t});\n\n\t\ttest('scopesMatch should handle empty arrays', () => {\n\t\t\tassert.strictEqual(scopesMatch([], []), true);\n\t\t});\n\n\t\ttest('scopesMatch should handle single scope arrays', () => {\n\t\t\tassert.strictEqual(scopesMatch(['single'], ['single']), true);\n\t\t\tassert.strictEqual(scopesMatch(['single'], ['different']), false);\n\t\t});\n\n\t\ttest('scopesMatch should handle duplicate scopes within arrays', () => {\n\t\t\tconst scopes1 = ['scope1', 'scope2', 'scope1'];\n\t\t\tconst scopes2 = ['scope2', 'scope1', 'scope1'];\n\t\t\tassert.strictEqual(scopesMatch(scopes1, scopes2), true);\n\t\t});\n\n\t\ttest('scopesMatch should handle undefined values', () => {\n\t\t\tassert.strictEqual(scopesMatch(undefined, undefined), true);\n\t\t\tassert.strictEqual(scopesMatch(['read'], undefined), false);\n\t\t\tassert.strictEqual(scopesMatch(undefined, ['write']), false);\n\t\t});\n\n\t\ttest('scopesMatch should handle mixed undefined and empty arrays', () => {\n\t\t\tassert.strictEqual(scopesMatch([], undefined), false);\n\t\t\tassert.strictEqual(scopesMatch(undefined, []), false);\n\t\t\tassert.strictEqual(scopesMatch([], []), true);\n\t\t});\n\t});\n\n\tsuite('Utility Functions', () => {\n\t\ttest('getDefaultMetadataForUrl should return correct default endpoints', () => {\n\t\t\tconst authorizationServer = new URL('https://auth.example.com');\n\t\t\tconst metadata = getDefaultMetadataForUrl(authorizationServer);\n\n\t\t\tassert.strictEqual(metadata.issuer, 'https://auth.example.com/');\n\t\t\tassert.strictEqual(metadata.authorization_endpoint, 'https://auth.example.com/authorize');\n\t\t\tassert.strictEqual(metadata.token_endpoint, 'https://auth.example.com/token');\n\t\t\tassert.strictEqual(metadata.registration_endpoint, 'https://auth.example.com/register');\n\t\t\tassert.deepStrictEqual(metadata.response_types_supported, ['code', 'id_token', 'id_token token']);\n\t\t});\n\t});\n\n\tsuite('Parsing Functions', () => {\n\t\ttest('parseWWWAuthenticateHeader should correctly parse simple header', () => {\n\t\t\tconst result = parseWWWAuthenticateHeader('Bearer');\n\t\t\tassert.strictEqual(result.length, 1);\n\t\t\tassert.strictEqual(result[0].scheme, 'Bearer');\n\t\t\tassert.deepStrictEqual(result[0].params, {});\n\t\t});\n\n\t\ttest('parseWWWAuthenticateHeader should correctly parse header with parameters', () => {\n\t\t\tconst result = parseWWWAuthenticateHeader('Bearer realm=\"api\", error=\"invalid_token\", error_description=\"The access token expired\"');\n\n\t\t\tassert.strictEqual(result.length, 1);\n\t\t\tassert.strictEqual(result[0].scheme, 'Bearer');\n\t\t\tassert.deepStrictEqual(result[0].params, {\n\t\t\t\trealm: 'api',\n\t\t\t\terror: 'invalid_token',\n\t\t\t\terror_description: 'The access token expired'\n\t\t\t});\n\t\t});\n\n\t\ttest('parseWWWAuthenticateHeader should correctly parse parameters with equal signs', () => {\n\t\t\tconst result = parseWWWAuthenticateHeader('Bearer resource_metadata=\"https://example.com/.well-known/oauth-protected-resource?v=1\"');\n\t\t\tassert.strictEqual(result.length, 1);\n\t\t\tassert.strictEqual(result[0].scheme, 'Bearer');\n\t\t\tassert.deepStrictEqual(result[0].params, {\n\t\t\t\tresource_metadata: 'https://example.com/.well-known/oauth-protected-resource?v=1'\n\t\t\t});\n\t\t});\n\n\t\ttest('parseWWWAuthenticateHeader should correctly parse multiple', () => {\n\t\t\tconst result = parseWWWAuthenticateHeader('Bearer realm=\"api\", error=\"invalid_token\", error_description=\"The access token expired\", Basic realm=\"hi\"');\n\n\t\t\tassert.strictEqual(result.length, 2);\n\t\t\tassert.strictEqual(result[0].scheme, 'Bearer');\n\t\t\tassert.deepStrictEqual(result[0].params, {\n\t\t\t\trealm: 'api',\n\t\t\t\terror: 'invalid_token',\n\t\t\t\terror_description: 'The access token expired'\n\t\t\t});\n\t\t\tassert.strictEqual(result[1].scheme, 'Basic');\n\t\t\tassert.deepStrictEqual(result[1].params, {\n\t\t\t\trealm: 'hi'\n\t\t\t});\n\t\t});\n\n\n\t\ttest('getClaimsFromJWT should correctly parse a JWT token', () => {\n\t\t\t// Create a sample JWT with known payload\n\t\t\tconst payload: IAuthorizationJWTClaims = {\n\t\t\t\tjti: 'id123',\n\t\t\t\tsub: 'user123',\n\t\t\t\tiss: 'https://example.com',\n\t\t\t\taud: 'client123',\n\t\t\t\texp: 1716239022,\n\t\t\t\tiat: 1716235422,\n\t\t\t\tname: 'Test User'\n\t\t\t};\n\n\t\t\t// Create fake but properly formatted JWT\n\t\t\tconst header = { alg: 'HS256', typ: 'JWT' };\n\t\t\tconst encodedHeader = encodeBase64(VSBuffer.fromString(JSON.stringify(header)));\n\t\t\tconst encodedPayload = encodeBase64(VSBuffer.fromString(JSON.stringify(payload)));\n\t\t\tconst fakeSignature = 'fake-signature';\n\t\t\tconst token = `${encodedHeader}.${encodedPayload}.${fakeSignature}`;\n\n\t\t\tconst claims = getClaimsFromJWT(token);\n\t\t\tassert.deepStrictEqual(claims, payload);\n\t\t});\n\n\t\ttest('getClaimsFromJWT should throw for invalid JWT format', () => {\n\t\t\t// Test with wrong number of parts - should throw \"Invalid JWT token format\"\n\t\t\tassert.throws(() => getClaimsFromJWT('only.two'), /Invalid JWT token format.*three parts/);\n\t\t\tassert.throws(() => getClaimsFromJWT('one'), /Invalid JWT token format.*three parts/);\n\t\t\tassert.throws(() => getClaimsFromJWT('has.four.parts.here'), /Invalid JWT token format.*three parts/);\n\t\t});\n\n\t\ttest('getClaimsFromJWT should throw for invalid header content', () => {\n\t\t\t// Create JWT with invalid header\n\t\t\tconst encodedHeader = encodeBase64(VSBuffer.fromString('not-json'));\n\t\t\tconst encodedPayload = encodeBase64(VSBuffer.fromString(JSON.stringify({ sub: 'test' })));\n\t\t\tconst token = `${encodedHeader}.${encodedPayload}.signature`;\n\n\t\t\tassert.throws(() => getClaimsFromJWT(token), /Failed to parse JWT token/);\n\t\t});\n\n\t\ttest('getClaimsFromJWT should throw for invalid payload content', () => {\n\t\t\t// Create JWT with valid header but invalid payload\n\t\t\tconst header = { alg: 'HS256', typ: 'JWT' };\n\t\t\tconst encodedHeader = encodeBase64(VSBuffer.fromString(JSON.stringify(header)));\n\t\t\tconst encodedPayload = encodeBase64(VSBuffer.fromString('not-json'));\n\t\t\tconst token = `${encodedHeader}.${encodedPayload}.signature`;\n\n\t\t\tassert.throws(() => getClaimsFromJWT(token), /Failed to parse JWT token/);\n\t\t});\n\t});\n\n\tsuite('Network Functions', () => {\n\t\tlet sandbox: sinon.SinonSandbox;\n\t\tlet fetchStub: sinon.SinonStub;\n\n\t\tsetup(() => {\n\t\t\tsandbox = sinon.createSandbox();\n\t\t\tfetchStub = sandbox.stub(globalThis, 'fetch');\n\t\t});\n\n\t\tteardown(() => {\n\t\t\tsandbox.restore();\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should make correct request and parse response', async () => {\n\t\t\t// Setup successful response\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client',\n\t\t\t\tclient_uri: 'https://code.visualstudio.com'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tconst result = await fetchDynamicRegistration(\n\t\t\t\tserverMetadata,\n\t\t\t\t'Test Client'\n\t\t\t);\n\n\t\t\t// Verify fetch was called correctly\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\tconst [url, options] = fetchStub.firstCall.args;\n\t\t\tassert.strictEqual(url, 'https://auth.example.com/register');\n\t\t\tassert.strictEqual(options.method, 'POST');\n\t\t\tassert.strictEqual(options.headers['Content-Type'], 'application/json');\n\n\t\t\t// Verify request body\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.strictEqual(requestBody.client_name, 'Test Client');\n\t\t\tassert.strictEqual(requestBody.client_uri, 'https://code.visualstudio.com');\n\t\t\tassert.deepStrictEqual(requestBody.grant_types, ['authorization_code', 'refresh_token', 'urn:ietf:params:oauth:grant-type:device_code']);\n\t\t\tassert.deepStrictEqual(requestBody.response_types, ['code']);\n\t\t\tassert.deepStrictEqual(requestBody.redirect_uris, [\n\t\t\t\t'https://insiders.vscode.dev/redirect',\n\t\t\t\t'https://vscode.dev/redirect',\n\t\t\t\t'http://127.0.0.1/',\n\t\t\t\t`http://127.0.0.1:${DEFAULT_AUTH_FLOW_PORT}/`\n\t\t\t]);\n\n\t\t\t// Verify response is processed correctly\n\t\t\tassert.deepStrictEqual(result, mockResponse);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should throw error on non-OK response', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\tstatusText: 'Bad Request',\n\t\t\t\ttext: async () => 'Bad Request'\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Registration to https:\\/\\/auth\\.example\\.com\\/register failed: Bad Request/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should throw error on invalid response format', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => ({ invalid: 'response' }) // Missing required fields\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Invalid authorization dynamic client registration response/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should filter grant types based on server metadata', async () => {\n\t\t\t// Setup successful response\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code'],\n\t\t\t\tgrant_types_supported: ['authorization_code', 'client_credentials', 'refresh_token'] // Mix of supported and unsupported\n\t\t\t};\n\n\t\t\tawait fetchDynamicRegistration(serverMetadata, 'Test Client');\n\n\t\t\t// Verify fetch was called correctly\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\tconst [, options] = fetchStub.firstCall.args;\n\n\t\t\t// Verify request body contains only the intersection of supported grant types\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.deepStrictEqual(requestBody.grant_types, ['authorization_code', 'refresh_token']); // client_credentials should be filtered out\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should use default grant types when server metadata has none', async () => {\n\t\t\t// Setup successful response\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t\t// No grant_types_supported specified\n\t\t\t};\n\n\t\t\tawait fetchDynamicRegistration(serverMetadata, 'Test Client');\n\n\t\t\t// Verify fetch was called correctly\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\tconst [, options] = fetchStub.firstCall.args;\n\n\t\t\t// Verify request body contains default grant types\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.deepStrictEqual(requestBody.grant_types, ['authorization_code', 'refresh_token', 'urn:ietf:params:oauth:grant-type:device_code']);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should throw error when registration endpoint is missing', async () => {\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t\t// registration_endpoint is missing\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Server does not support dynamic registration/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle structured error response', async () => {\n\t\t\tconst errorResponse = {\n\t\t\t\terror: 'invalid_client_metadata',\n\t\t\t\terror_description: 'The client metadata is invalid'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\ttext: async () => JSON.stringify(errorResponse)\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Registration to https:\\/\\/auth\\.example\\.com\\/register failed: invalid_client_metadata: The client metadata is invalid/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle structured error response without description', async () => {\n\t\t\tconst errorResponse = {\n\t\t\t\terror: 'invalid_redirect_uri'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\ttext: async () => JSON.stringify(errorResponse)\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Registration to https:\\/\\/auth\\.example\\.com\\/register failed: invalid_redirect_uri/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle malformed JSON error response', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\ttext: async () => 'Invalid JSON {'\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Registration to https:\\/\\/auth\\.example\\.com\\/register failed: Invalid JSON \\{/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should include scopes in request when provided', async () => {\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait fetchDynamicRegistration(serverMetadata, 'Test Client', ['read', 'write']);\n\n\t\t\t// Verify request includes scopes\n\t\t\tconst [, options] = fetchStub.firstCall.args;\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.strictEqual(requestBody.scope, 'read write');\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should omit scope from request when not provided', async () => {\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait fetchDynamicRegistration(serverMetadata, 'Test Client');\n\n\t\t\t// Verify request does not include scope when not provided\n\t\t\tconst [, options] = fetchStub.firstCall.args;\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.strictEqual(requestBody.scope, undefined);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle empty scopes array', async () => {\n\t\t\tconst mockResponse = {\n\t\t\t\tclient_id: 'generated-client-id',\n\t\t\t\tclient_name: 'Test Client'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => mockResponse\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait fetchDynamicRegistration(serverMetadata, 'Test Client', []);\n\n\t\t\t// Verify request includes empty scope\n\t\t\tconst [, options] = fetchStub.firstCall.args;\n\t\t\tconst requestBody = JSON.parse(options.body as string);\n\t\t\tassert.strictEqual(requestBody.scope, '');\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle network fetch failure', async () => {\n\t\t\tfetchStub.rejects(new Error('Network error'));\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Network error/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle response.json() failure', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: true,\n\t\t\t\tjson: async () => {\n\t\t\t\t\tthrow new Error('JSON parsing failed');\n\t\t\t\t}\n\t\t\t} as unknown as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/JSON parsing failed/\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should handle response.text() failure for error cases', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\ttext: async () => {\n\t\t\t\t\tthrow new Error('Text parsing failed');\n\t\t\t\t}\n\t\t\t} as unknown as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Text parsing failed/\n\t\t\t);\n\t\t});\n\t});\n\n\tsuite('Client ID Fallback Scenarios', () => {\n\t\tlet sandbox: sinon.SinonSandbox;\n\t\tlet fetchStub: sinon.SinonStub;\n\n\t\tsetup(() => {\n\t\t\tsandbox = sinon.createSandbox();\n\t\t\tfetchStub = sandbox.stub(globalThis, 'fetch');\n\t\t});\n\n\t\tteardown(() => {\n\t\t\tsandbox.restore();\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should throw specific error for missing registration endpoint', async () => {\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t\t// registration_endpoint is missing\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t{\n\t\t\t\t\tmessage: 'Server does not support dynamic registration'\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\n\t\ttest('fetchDynamicRegistration should throw specific error for DCR failure', async () => {\n\t\t\tfetchStub.resolves({\n\t\t\t\tok: false,\n\t\t\t\ttext: async () => 'DCR not supported'\n\t\t\t} as Response);\n\n\t\t\tconst serverMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => await fetchDynamicRegistration(serverMetadata, 'Test Client'),\n\t\t\t\t/Registration to https:\\/\\/auth\\.example\\.com\\/register failed: DCR not supported/\n\t\t\t);\n\t\t});\n\t});\n\n\tsuite('fetchResourceMetadata', () => {\n\t\tlet sandbox: sinon.SinonSandbox;\n\t\tlet fetchStub: sinon.SinonStub;\n\n\t\tsetup(() => {\n\t\t\tsandbox = sinon.createSandbox();\n\t\t\tfetchStub = sandbox.stub();\n\t\t});\n\n\t\tteardown(() => {\n\t\t\tsandbox.restore();\n\t\t});\n\n\t\ttest('should successfully fetch and validate resource metadata', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api',\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tresourceMetadataUrl,\n\t\t\t\t{ fetch: fetchStub }\n\t\t\t);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], resourceMetadataUrl);\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[1].method, 'GET');\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[1].headers['Accept'], 'application/json');\n\t\t});\n\n\t\ttest('should include same-origin headers when origins match', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst sameOriginHeaders = {\n\t\t\t\t'X-Test-Header': 'test-value',\n\t\t\t\t'X-Custom-Header': 'value'\n\t\t\t};\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tawait fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tresourceMetadataUrl,\n\t\t\t\t{ fetch: fetchStub, sameOriginHeaders }\n\t\t\t);\n\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['Accept'], 'application/json');\n\t\t\tassert.strictEqual(headers['X-Test-Header'], 'test-value');\n\t\t\tassert.strictEqual(headers['X-Custom-Header'], 'value');\n\t\t});\n\n\t\ttest('should not include same-origin headers when origins differ', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://other-domain.com/.well-known/oauth-protected-resource';\n\t\t\tconst sameOriginHeaders = {\n\t\t\t\t'X-Test-Header': 'test-value'\n\t\t\t};\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tawait fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tresourceMetadataUrl,\n\t\t\t\t{ fetch: fetchStub, sameOriginHeaders }\n\t\t\t);\n\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['Accept'], 'application/json');\n\t\t\tassert.strictEqual(headers['X-Test-Header'], undefined);\n\t\t});\n\n\t\ttest('should throw error when fetch returns non-200 status', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/Failed to fetch resource metadata from.*404 Not Found/\n\t\t\t);\n\t\t});\n\n\t\ttest('should handle error when response.text() throws', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 500,\n\t\t\t\tstatusText: 'Internal Server Error',\n\t\t\t\ttext: async () => { throw new Error('Cannot read response'); }\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/Failed to fetch resource metadata from.*500 Internal Server Error/\n\t\t\t);\n\t\t});\n\n\t\ttest('should throw error when resource property does not match target resource', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://different.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/Protected Resource Metadata resource property value.*does not match target server url.*These MUST match to follow OAuth spec/\n\t\t\t);\n\t\t});\n\n\t\ttest('should normalize URLs when comparing resource values', async () => {\n\t\t\tconst targetResource = 'https://EXAMPLE.COM/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\t// URL normalization should handle hostname case differences\n\t\t\tconst result = await fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub });\n\t\t\tassert.deepStrictEqual(result, metadata);\n\t\t});\n\n\t\ttest('should normalize hostnames when comparing resource values', async () => {\n\t\t\tconst targetResource = 'https://EXAMPLE.COM/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub });\n\t\t\tassert.deepStrictEqual(result, metadata);\n\t\t});\n\n\t\ttest('should throw error when response is not valid resource metadata', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst invalidMetadata = {\n\t\t\t\t// Missing required 'resource' property\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => invalidMetadata,\n\t\t\t\ttext: async () => JSON.stringify(invalidMetadata)\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/Invalid resource metadata.*Expected to follow shape of.*is scopes_supported an array\\? Is resource a string\\?/\n\t\t\t);\n\t\t});\n\n\t\ttest('should throw error when scopes_supported is not an array', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst invalidMetadata = {\n\t\t\t\tresource: 'https://example.com/api',\n\t\t\t\tscopes_supported: 'not an array'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => invalidMetadata,\n\t\t\t\ttext: async () => JSON.stringify(invalidMetadata)\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/Invalid resource metadata/\n\t\t\t);\n\t\t});\n\n\t\ttest('should handle metadata with optional fields', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://example.com/api',\n\t\t\t\tresource_name: 'Example API',\n\t\t\t\tauthorization_servers: ['https://auth.example.com'],\n\t\t\t\tjwks_uri: 'https://example.com/jwks',\n\t\t\t\tscopes_supported: ['read', 'write', 'admin'],\n\t\t\t\tbearer_methods_supported: ['header', 'body'],\n\t\t\t\tresource_documentation: 'https://example.com/docs'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub });\n\t\t\tassert.deepStrictEqual(result, metadata);\n\t\t});\n\n\t\ttest('should use global fetch when custom fetch is not provided', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tconst globalFetchStub = sandbox.stub(globalThis, 'fetch').resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t} as any);\n\n\t\t\tconst result = await fetchResourceMetadata(targetResource, resourceMetadataUrl);\n\n\t\t\tassert.deepStrictEqual(result, metadata);\n\t\t\tassert.strictEqual(globalFetchStub.callCount, 1);\n\t\t});\n\n\t\ttest('should handle same origin with different ports', async () => {\n\t\t\tconst targetResource = 'https://example.com:8080/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com:9090/.well-known/oauth-protected-resource';\n\t\t\tconst sameOriginHeaders = {\n\t\t\t\t'X-Test-Header': 'test-value'\n\t\t\t};\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://example.com:8080/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\tawait fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tresourceMetadataUrl,\n\t\t\t\t{ fetch: fetchStub, sameOriginHeaders }\n\t\t\t);\n\n\t\t\t// Different ports mean different origins\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['X-Test-Header'], undefined);\n\t\t});\n\n\t\ttest('should handle same origin with different protocols', async () => {\n\t\t\tconst targetResource = 'http://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst sameOriginHeaders = {\n\t\t\t\t'X-Test-Header': 'test-value'\n\t\t\t};\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'http://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\tawait fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tresourceMetadataUrl,\n\t\t\t\t{ fetch: fetchStub, sameOriginHeaders }\n\t\t\t);\n\n\t\t\t// Different protocols mean different origins\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['X-Test-Header'], undefined);\n\t\t});\n\n\t\ttest('should include error details in message with length information', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\t\t\tconst metadata = {\n\t\t\t\tresource: 'https://different.com/other'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => metadata,\n\t\t\t\ttext: async () => JSON.stringify(metadata)\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tawait fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub });\n\t\t\t\tassert.fail('Should have thrown an error');\n\t\t\t} catch (error: any) {\n\t\t\t\tassert.ok(/length:/.test(error.message), 'Error message should include length information');\n\t\t\t\tassert.ok(/https:\\/\\/different\\.com\\/other/.test(error.message), 'Error message should include actual resource value');\n\t\t\t\tassert.ok(/https:\\/\\/example\\.com\\/api/.test(error.message), 'Error message should include expected resource value');\n\t\t\t}\n\t\t});\n\n\t\ttest('should fallback to well-known URI with path when no resourceMetadataUrl provided', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api/v1',\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tundefined,\n\t\t\t\t{ fetch: fetchStub }\n\t\t\t);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\t// Should try path-appended version first\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://example.com/.well-known/oauth-protected-resource/api/v1');\n\t\t});\n\n\t\ttest('should fallback to well-known URI at root when path version fails', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api/v1',\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t};\n\n\t\t\t// First call fails, second succeeds\n\t\t\tfetchStub.onFirstCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found'\n\t\t\t});\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tundefined,\n\t\t\t\t{ fetch: fetchStub }\n\t\t\t);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t\t// First attempt with path\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://example.com/.well-known/oauth-protected-resource/api/v1');\n\t\t\t// Second attempt at root\n\t\t\tassert.strictEqual(fetchStub.secondCall.args[0], 'https://example.com/.well-known/oauth-protected-resource');\n\t\t});\n\n\t\ttest('should throw error when all well-known URIs fail', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, undefined, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 2, 'Should contain 2 errors');\n\t\t\t\t\tassert.ok(/Failed to fetch resource metadata from.*\\/api\\/v1.*404/.test(error.errors[0].message), 'First error should mention /api/v1 and 404');\n\t\t\t\t\tassert.ok(/Failed to fetch resource metadata from.*\\.well-known.*404/.test(error.errors[1].message), 'Second error should mention .well-known and 404');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t); assert.strictEqual(fetchStub.callCount, 2);\n\t\t});\n\n\t\ttest('should not append path when target resource is root', async () => {\n\t\t\tconst targetResource = 'https://example.com/';\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/',\n\t\t\t\tscopes_supported: ['read']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tundefined,\n\t\t\t\t{ fetch: fetchStub }\n\t\t\t);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\t// Both URLs should be the same when path is /\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://example.com/.well-known/oauth-protected-resource');\n\t\t});\n\n\t\ttest('should include same-origin headers when using well-known fallback', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst sameOriginHeaders = {\n\t\t\t\t'X-Test-Header': 'test-value',\n\t\t\t\t'X-Custom-Header': 'value'\n\t\t\t};\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tawait fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tundefined,\n\t\t\t\t{ fetch: fetchStub, sameOriginHeaders }\n\t\t\t);\n\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['Accept'], 'application/json');\n\t\t\tassert.strictEqual(headers['X-Test-Header'], 'test-value');\n\t\t\tassert.strictEqual(headers['X-Custom-Header'], 'value');\n\t\t});\n\n\t\ttest('should handle fetchImpl throwing network error and continue to next URL', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\t\t\tconst expectedMetadata = {\n\t\t\t\tresource: 'https://example.com/api/v1',\n\t\t\t\tscopes_supported: ['read', 'write']\n\t\t\t};\n\n\t\t\t// First call throws network error, second succeeds\n\t\t\tfetchStub.onFirstCall().rejects(new Error('Network connection failed'));\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata)\n\t\t\t});\n\n\t\t\tconst result = await fetchResourceMetadata(\n\t\t\t\ttargetResource,\n\t\t\t\tundefined,\n\t\t\t\t{ fetch: fetchStub }\n\t\t\t);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t\t// First attempt with path should have thrown error\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://example.com/.well-known/oauth-protected-resource/api/v1');\n\t\t\t// Second attempt at root should succeed\n\t\t\tassert.strictEqual(fetchStub.secondCall.args[0], 'https://example.com/.well-known/oauth-protected-resource');\n\t\t});\n\n\t\ttest('should throw AggregateError when fetchImpl throws on all URLs', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\n\t\t\t// Both calls throw network errors\n\t\t\tfetchStub.rejects(new Error('Network connection failed'));\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, undefined, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 2, 'Should contain 2 errors');\n\t\t\t\t\tassert.ok(/Network connection failed/.test(error.errors[0].message), 'First error should mention network failure');\n\t\t\t\t\tassert.ok(/Network connection failed/.test(error.errors[1].message), 'Second error should mention network failure');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t});\n\n\t\ttest('should handle mix of fetch error and non-200 response', async () => {\n\t\t\tconst targetResource = 'https://example.com/api/v1';\n\n\t\t\t// First call throws network error\n\t\t\tfetchStub.onFirstCall().rejects(new Error('Connection timeout'));\n\n\t\t\t// Second call returns 404\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, undefined, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 2, 'Should contain 2 errors');\n\t\t\t\t\tassert.ok(/Connection timeout/.test(error.errors[0].message), 'First error should be network error');\n\t\t\t\t\tassert.ok(/Failed to fetch resource metadata.*404/.test(error.errors[1].message), 'Second error should be 404');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t});\n\n\t\ttest('should handle fetchImpl throwing error with explicit resourceMetadataUrl', async () => {\n\t\t\tconst targetResource = 'https://example.com/api';\n\t\t\tconst resourceMetadataUrl = 'https://example.com/.well-known/oauth-protected-resource';\n\n\t\t\tfetchStub.rejects(new Error('DNS resolution failed'));\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchResourceMetadata(targetResource, resourceMetadataUrl, { fetch: fetchStub }),\n\t\t\t\t/DNS resolution failed/\n\t\t\t);\n\n\t\t\t// Should only try once when explicit URL is provided\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], resourceMetadataUrl);\n\t\t});\n\t});\n\n\tsuite('fetchAuthorizationServerMetadata', () => {\n\t\tlet sandbox: sinon.SinonSandbox;\n\t\tlet fetchStub: sinon.SinonStub;\n\n\t\tsetup(() => {\n\t\t\tsandbox = sinon.createSandbox();\n\t\t\tfetchStub = sandbox.stub();\n\t\t});\n\n\t\tteardown(() => {\n\t\t\tsandbox.restore();\n\t\t});\n\n\t\ttest('should successfully fetch metadata from OAuth discovery endpoint with path insertion', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/tenant/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/tenant/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\t// Should try OAuth discovery with path insertion: https://auth.example.com/.well-known/oauth-authorization-server/tenant\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://auth.example.com/.well-known/oauth-authorization-server/tenant');\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[1].method, 'GET');\n\t\t});\n\n\t\ttest('should fallback to OpenID Connect discovery with path insertion', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/tenant/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/tenant/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// First call fails, second succeeds\n\t\t\tfetchStub.onFirstCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t\t// First attempt: OAuth discovery\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://auth.example.com/.well-known/oauth-authorization-server/tenant');\n\t\t\t// Second attempt: OpenID Connect discovery with path insertion\n\t\t\tassert.strictEqual(fetchStub.secondCall.args[0], 'https://auth.example.com/.well-known/openid-configuration/tenant');\n\t\t});\n\n\t\ttest('should fallback to OpenID Connect discovery with path addition', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/tenant/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/tenant/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// First two calls fail, third succeeds\n\t\t\tfetchStub.onFirstCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tfetchStub.onThirdCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t\t// First attempt: OAuth discovery\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://auth.example.com/.well-known/oauth-authorization-server/tenant');\n\t\t\t// Second attempt: OpenID Connect discovery with path insertion\n\t\t\tassert.strictEqual(fetchStub.secondCall.args[0], 'https://auth.example.com/.well-known/openid-configuration/tenant');\n\t\t\t// Third attempt: OpenID Connect discovery with path addition\n\t\t\tassert.strictEqual(fetchStub.thirdCall.args[0], 'https://auth.example.com/tenant/.well-known/openid-configuration');\n\t\t});\n\n\t\ttest('should handle authorization server at root without extra path', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\t// For root URLs, no extra path is added\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://auth.example.com/.well-known/oauth-authorization-server');\n\t\t});\n\n\t\ttest('should handle authorization server with trailing slash', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant/';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant/',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/tenant/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/tenant/token',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t});\n\n\t\ttest('should include additional headers in all requests', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\t\t\tconst additionalHeaders = {\n\t\t\t\t'X-Custom-Header': 'custom-value',\n\t\t\t\t'Authorization': 'Bearer token123'\n\t\t\t};\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tawait fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub, additionalHeaders });\n\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['X-Custom-Header'], 'custom-value');\n\t\t\tassert.strictEqual(headers['Authorization'], 'Bearer token123');\n\t\t\tassert.strictEqual(headers['Accept'], 'application/json');\n\t\t});\n\t\ttest('should throw AggregateError when all discovery endpoints fail', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 3, 'Should contain 3 errors (one for each URL)');\n\t\t\t\t\tassert.strictEqual(error.message, 'Failed to fetch authorization server metadata from all attempted URLs');\n\t\t\t\t\t// Verify each error includes the URL it attempted\n\t\t\t\t\tassert.ok(/oauth-authorization-server.*404/.test(error.errors[0].message), 'First error should mention OAuth discovery and 404');\n\t\t\t\t\tassert.ok(/openid-configuration.*404/.test(error.errors[1].message), 'Second error should mention OpenID path insertion and 404');\n\t\t\t\t\tassert.ok(/openid-configuration.*404/.test(error.errors[2].message), 'Third error should mention OpenID path addition and 404');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// Should have tried all three endpoints\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t});\n\n\t\ttest('should throw single error (not AggregateError) when only one URL is tried and fails', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\n\t\t\t// First attempt succeeds on second try, so only one error is collected for first URL\n\t\t\tfetchStub.onFirstCall().resolves({\n\t\t\t\tstatus: 500,\n\t\t\t\ttext: async () => 'Internal Server Error',\n\t\t\t\tstatusText: 'Internal Server Error',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\t// Should succeed on second attempt\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t});\n\n\t\ttest('should throw AggregateError when multiple URLs fail with mixed error types', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\n\t\t\t// First call: network error\n\t\t\tfetchStub.onFirstCall().rejects(new Error('Connection timeout'));\n\n\t\t\t// Second call: 404\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\t// Third call: 500\n\t\t\tfetchStub.onThirdCall().resolves({\n\t\t\t\tstatus: 500,\n\t\t\t\ttext: async () => 'Internal Server Error',\n\t\t\t\tstatusText: 'Internal Server Error',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 3, 'Should contain 3 errors');\n\t\t\t\t\t// First error is network error\n\t\t\t\t\tassert.ok(/Connection timeout/.test(error.errors[0].message), 'First error should be network error');\n\t\t\t\t\t// Second error is 404\n\t\t\t\t\tassert.ok(/404.*Not Found/.test(error.errors[1].message), 'Second error should be 404');\n\t\t\t\t\t// Third error is 500\n\t\t\t\t\tassert.ok(/500.*Internal Server Error/.test(error.errors[2].message), 'Third error should be 500');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t});\n\n\t\ttest('should handle invalid JSON response', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => { throw new Error('Invalid JSON'); },\n\t\t\t\ttext: async () => 'Invalid JSON',\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t/Failed to fetch authorization server metadata/\n\t\t\t);\n\t\t});\n\n\t\ttest('should handle valid JSON but invalid metadata structure', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst invalidMetadata = {\n\t\t\t\t// Missing required 'issuer' field\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/authorize'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => invalidMetadata,\n\t\t\t\ttext: async () => JSON.stringify(invalidMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t/Failed to fetch authorization server metadata/\n\t\t\t);\n\t\t});\n\n\t\ttest('should use global fetch when custom fetch is not provided', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tconst globalFetchStub = sandbox.stub(globalThis, 'fetch').resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t} as any);\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer);\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(globalFetchStub.callCount, 1);\n\t\t});\n\n\t\ttest('should handle network fetch failure and continue to next endpoint', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// First call throws network error, second succeeds\n\t\t\tfetchStub.onFirstCall().rejects(new Error('Network error'));\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\t// Should have tried two endpoints\n\t\t\tassert.strictEqual(fetchStub.callCount, 2);\n\t\t});\n\n\t\ttest('should throw error when network fails on all endpoints', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\n\t\t\tfetchStub.rejects(new Error('Network error'));\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 3, 'Should contain 3 errors');\n\t\t\t\t\tassert.strictEqual(error.message, 'Failed to fetch authorization server metadata from all attempted URLs');\n\t\t\t\t\t// All errors should be network errors\n\t\t\t\t\tassert.ok(/Network error/.test(error.errors[0].message), 'First error should be network error');\n\t\t\t\t\tassert.ok(/Network error/.test(error.errors[1].message), 'Second error should be network error');\n\t\t\t\t\tassert.ok(/Network error/.test(error.errors[2].message), 'Third error should be network error');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// Should have tried all three endpoints\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t});\n\n\t\ttest('should handle mix of network error and non-200 response', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// First call throws network error\n\t\t\tfetchStub.onFirstCall().rejects(new Error('Connection timeout'));\n\n\t\t\t// Second call returns 404\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\t// Third call succeeds\n\t\t\tfetchStub.onThirdCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\t// Should have tried all three endpoints\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t});\n\n\t\ttest('should handle response.text() failure in error case', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 500,\n\t\t\t\ttext: async () => { throw new Error('Cannot read text'); },\n\t\t\t\tstatusText: 'Internal Server Error',\n\t\t\t\tjson: async () => { throw new Error('Cannot read json'); }\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 3, 'Should contain 3 errors');\n\t\t\t\t\t// All errors should include status code and statusText (fallback when text() fails)\n\t\t\t\t\tfor (const err of error.errors) {\n\t\t\t\t\t\tassert.ok(/500 Internal Server Error/.test(err.message), `Error should mention 500 and statusText: ${err.message}`);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\n\t\ttest('should correctly handle path addition with trailing slash', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant/';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant/',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\t// First two calls fail, third succeeds\n\t\t\tfetchStub.onFirstCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tfetchStub.onSecondCall().resolves({\n\t\t\t\tstatus: 404,\n\t\t\t\ttext: async () => 'Not Found',\n\t\t\t\tstatusText: 'Not Found',\n\t\t\t\tjson: async () => { throw new Error('Not JSON'); }\n\t\t\t});\n\n\t\t\tfetchStub.onThirdCall().resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t\t// Third attempt should correctly handle trailing slash (not double-slash)\n\t\t\tassert.strictEqual(fetchStub.thirdCall.args[0], 'https://auth.example.com/tenant/.well-known/openid-configuration');\n\t\t});\n\n\t\ttest('should handle deeply nested paths', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant/org/sub';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant/org/sub',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t\t// Should correctly insert well-known path with nested paths\n\t\t\tassert.strictEqual(fetchStub.firstCall.args[0], 'https://auth.example.com/.well-known/oauth-authorization-server/tenant/org/sub');\n\t\t});\n\n\t\ttest('should handle 200 response with non-metadata JSON', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst invalidResponse = {\n\t\t\t\terror: 'not_supported',\n\t\t\t\tmessage: 'Metadata not available'\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => invalidResponse,\n\t\t\t\ttext: async () => JSON.stringify(invalidResponse),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tawait assert.rejects(\n\t\t\t\tasync () => fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub }),\n\t\t\t\t(error: any) => {\n\t\t\t\t\tassert.ok(error instanceof AggregateError, 'Should be an AggregateError');\n\t\t\t\t\tassert.strictEqual(error.errors.length, 3, 'Should contain 3 errors');\n\t\t\t\t\t// All errors should indicate failed to fetch with status code\n\t\t\t\t\tfor (const err of error.errors) {\n\t\t\t\t\t\tassert.ok(/Failed to fetch authorization server metadata from/.test(err.message), `Error should mention failed fetch: ${err.message}`);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// Should try all three endpoints\n\t\t\tassert.strictEqual(fetchStub.callCount, 3);\n\t\t});\n\n\t\ttest('should validate metadata according to isAuthorizationServerMetadata', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\t// Valid metadata with all required fields\n\t\t\tconst validMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tauthorization_endpoint: 'https://auth.example.com/authorize',\n\t\t\t\ttoken_endpoint: 'https://auth.example.com/token',\n\t\t\t\tjwks_uri: 'https://auth.example.com/jwks',\n\t\t\t\tregistration_endpoint: 'https://auth.example.com/register',\n\t\t\t\tresponse_types_supported: ['code', 'token']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => validMetadata,\n\t\t\t\ttext: async () => JSON.stringify(validMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, validMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t});\n\n\t\ttest('should handle URLs with query parameters', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com/tenant?version=v2';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/tenant?version=v2',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tconst result = await fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub });\n\n\t\t\tassert.deepStrictEqual(result, expectedMetadata);\n\t\t\tassert.strictEqual(fetchStub.callCount, 1);\n\t\t});\n\n\t\ttest('should handle empty additionalHeaders', async () => {\n\t\t\tconst authorizationServer = 'https://auth.example.com';\n\t\t\tconst expectedMetadata: IAuthorizationServerMetadata = {\n\t\t\t\tissuer: 'https://auth.example.com/',\n\t\t\t\tresponse_types_supported: ['code']\n\t\t\t};\n\n\t\t\tfetchStub.resolves({\n\t\t\t\tstatus: 200,\n\t\t\t\tjson: async () => expectedMetadata,\n\t\t\t\ttext: async () => JSON.stringify(expectedMetadata),\n\t\t\t\tstatusText: 'OK'\n\t\t\t});\n\n\t\t\tawait fetchAuthorizationServerMetadata(authorizationServer, { fetch: fetchStub, additionalHeaders: {} });\n\n\t\t\tconst headers = fetchStub.firstCall.args[1].headers;\n\t\t\tassert.strictEqual(headers['Accept'], 'application/json');\n\t\t});\n\t});\n});\n"]}