{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/test/common/observables/observable.test.ts","vs/base/test/common/observables/observable.test.ts"],"names":[],"mappings":"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","file":"observable.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { setUnexpectedErrorHandler } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { DisposableStore, toDisposable } from '../../../common/lifecycle.js';\nimport { IDerivedReader, IObservableWithChange, autorun, autorunHandleChanges, autorunWithStoreHandleChanges, derived, derivedDisposable, IObservable, IObserver, ISettableObservable, ITransaction, keepObserved, observableFromEvent, observableSignal, observableValue, recordChanges, transaction, waitForState, derivedHandleChanges, runOnChange, DebugLocation } from '../../../common/observable.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../utils.js';\n// eslint-disable-next-line local/code-no-deep-import-of-internal\nimport { observableReducer } from '../../../common/observableInternal/experimental/reducer.js';\n// eslint-disable-next-line local/code-no-deep-import-of-internal\nimport { BaseObservable } from '../../../common/observableInternal/observables/baseObservable.js';\n\nsuite('observables', () => {\n\tconst ds = ensureNoDisposablesAreLeakedInTestSuite();\n\n\t/**\n\t * Reads these tests to understand how to use observables.\n\t */\n\tsuite('tutorial', () => {\n\t\ttest('observable + autorun', () => {\n\t\t\tconst log = new Log();\n\t\t\t// This creates a variable that stores a value and whose value changes can be observed.\n\t\t\t// The name is only used for debugging purposes.\n\t\t\t// The second arg is the initial value.\n\t\t\tconst myObservable = observableValue('myObservable', 0);\n\n\t\t\t// This creates an autorun: It runs immediately and then again whenever any of the\n\t\t\t// dependencies change. Dependencies are tracked by reading observables with the `reader` parameter.\n\t\t\t//\n\t\t\t// The @description is only used for debugging purposes.\n\t\t\t// The autorun has to be disposed! This is very important.\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\n\t\t\t\t// This code is run immediately.\n\n\t\t\t\t// Use the `reader` to read observable values and track the dependency to them.\n\t\t\t\t// If you use `observable.get()` instead of `observable.read(reader)`, you will just\n\t\t\t\t// get the value and not subscribe to it.\n\t\t\t\tlog.log(`myAutorun.run(myObservable: ${myObservable.read(reader)})`);\n\n\t\t\t\t// Now that all dependencies are tracked, the autorun is re-run whenever any of the\n\t\t\t\t// dependencies change.\n\t\t\t}));\n\t\t\t// The autorun runs immediately\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myAutorun.run(myObservable: 0)']);\n\n\t\t\t// We set the observable.\n\t\t\tmyObservable.set(1, undefined);\n\t\t\t// -> The autorun runs again when any read observable changed\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myAutorun.run(myObservable: 1)']);\n\n\t\t\t// We set the observable again.\n\t\t\tmyObservable.set(1, undefined);\n\t\t\t// -> The autorun does not run again, because the observable didn't change.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t// Transactions batch autorun runs\n\t\t\ttransaction((tx) => {\n\t\t\t\tmyObservable.set(2, tx);\n\t\t\t\t// No auto-run ran yet, even though the value changed!\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tmyObservable.set(3, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\t// Only at the end of the transaction the autorun re-runs\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myAutorun.run(myObservable: 3)']);\n\n\t\t\t// Note that the autorun did not see the intermediate value `2`!\n\t\t});\n\n\t\ttest('derived + autorun', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst observable1 = observableValue('myObservable1', 0);\n\t\t\tconst observable2 = observableValue('myObservable2', 0);\n\n\t\t\t// A derived value is an observable that is derived from other observables.\n\t\t\tconst myDerived = derived(reader => {\n\t\t\t\t/** @description myDerived */\n\t\t\t\tconst value1 = observable1.read(reader); // Use the reader to track dependencies.\n\t\t\t\tconst value2 = observable2.read(reader);\n\t\t\t\tconst sum = value1 + value2;\n\t\t\t\tlog.log(`myDerived.recompute: ${value1} + ${value2} = ${sum}`);\n\t\t\t\treturn sum;\n\t\t\t});\n\n\t\t\t// We create an autorun that reacts on changes to our derived value.\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\t\t\t\t// Autoruns work with observable values and deriveds - in short, they work with any observable.\n\t\t\t\tlog.log(`myAutorun(myDerived: ${myDerived.read(reader)})`);\n\t\t\t}));\n\t\t\t// autorun runs immediately\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: 0 + 0 = 0',\n\t\t\t\t'myAutorun(myDerived: 0)',\n\t\t\t]);\n\n\t\t\tobservable1.set(1, undefined);\n\t\t\t// and on changes...\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: 1 + 0 = 1',\n\t\t\t\t'myAutorun(myDerived: 1)',\n\t\t\t]);\n\n\t\t\tobservable2.set(1, undefined);\n\t\t\t// ... of any dependency.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: 1 + 1 = 2',\n\t\t\t\t'myAutorun(myDerived: 2)',\n\t\t\t]);\n\n\t\t\t// Now we change multiple observables in a transaction to batch process the effects.\n\t\t\ttransaction((tx) => {\n\t\t\t\tobservable1.set(5, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tobservable2.set(5, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\t// When changing multiple observables in a transaction,\n\t\t\t// deriveds are only recomputed on demand.\n\t\t\t// (Note that you cannot see the intermediate value when `obs1 == 5` and `obs2 == 1`)\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: 5 + 5 = 10',\n\t\t\t\t'myAutorun(myDerived: 10)',\n\t\t\t]);\n\n\t\t\ttransaction((tx) => {\n\t\t\t\tobservable1.set(6, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tobservable2.set(4, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\t// Now the autorun didn't run again, because its dependency changed from 10 to 10 (= no change).\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), (['myDerived.recompute: 6 + 4 = 10']));\n\t\t});\n\n\t\ttest('read during transaction', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst observable1 = observableValue('myObservable1', 0);\n\t\t\tconst observable2 = observableValue('myObservable2', 0);\n\n\t\t\tconst myDerived = derived((reader) => {\n\t\t\t\t/** @description myDerived */\n\t\t\t\tconst value1 = observable1.read(reader);\n\t\t\t\tconst value2 = observable2.read(reader);\n\t\t\t\tconst sum = value1 + value2;\n\t\t\t\tlog.log(`myDerived.recompute: ${value1} + ${value2} = ${sum}`);\n\t\t\t\treturn sum;\n\t\t\t});\n\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\t\t\t\tlog.log(`myAutorun(myDerived: ${myDerived.read(reader)})`);\n\t\t\t}));\n\t\t\t// autorun runs immediately\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: 0 + 0 = 0',\n\t\t\t\t'myAutorun(myDerived: 0)',\n\t\t\t]);\n\n\t\t\ttransaction((tx) => {\n\t\t\t\tobservable1.set(-10, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tmyDerived.get(); // This forces a (sync) recomputation of the current value!\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), (['myDerived.recompute: -10 + 0 = -10']));\n\t\t\t\t// This means, that even in transactions you can assume that all values you can read with `get` and `read` are up-to-date.\n\t\t\t\t// Read these values just might cause additional (potentially unneeded) recomputations.\n\n\t\t\t\tobservable2.set(10, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\t// This autorun runs again, because its dependency changed from 0 to -10 and then back to 0.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: -10 + 10 = 0',\n\t\t\t\t'myAutorun(myDerived: 0)',\n\t\t\t]);\n\t\t});\n\n\t\ttest('get without observers', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst observable1 = observableValue('myObservableValue1', 0);\n\n\t\t\t// We set up some computeds.\n\t\t\tconst computed1 = derived((reader) => {\n\t\t\t\t/** @description computed */\n\t\t\t\tconst value1 = observable1.read(reader);\n\t\t\t\tconst result = value1 % 3;\n\t\t\t\tlog.log(`recompute1: ${value1} % 3 = ${result}`);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\tconst computed2 = derived((reader) => {\n\t\t\t\t/** @description computed */\n\t\t\t\tconst value1 = computed1.read(reader);\n\t\t\t\tconst result = value1 * 2;\n\t\t\t\tlog.log(`recompute2: ${value1} * 2 = ${result}`);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\tconst computed3 = derived((reader) => {\n\t\t\t\t/** @description computed */\n\t\t\t\tconst value1 = computed1.read(reader);\n\t\t\t\tconst result = value1 * 3;\n\t\t\t\tlog.log(`recompute3: ${value1} * 3 = ${result}`);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\tconst computedSum = derived((reader) => {\n\t\t\t\t/** @description computed */\n\t\t\t\tconst value1 = computed2.read(reader);\n\t\t\t\tconst value2 = computed3.read(reader);\n\t\t\t\tconst result = value1 + value2;\n\t\t\t\tlog.log(`recompute4: ${value1} + ${value2} = ${result}`);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\tobservable1.set(1, undefined);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t// And now read the computed that dependens on all the others.\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 1 % 3 = 1',\n\t\t\t\t'recompute2: 1 * 2 = 2',\n\t\t\t\t'recompute3: 1 * 3 = 3',\n\t\t\t\t'recompute4: 2 + 3 = 5',\n\t\t\t\t'value: 5',\n\t\t\t]);\n\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\t// Because there are no observers, the derived values are not cached (!), but computed from scratch.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 1 % 3 = 1',\n\t\t\t\t'recompute2: 1 * 2 = 2',\n\t\t\t\t'recompute3: 1 * 3 = 3',\n\t\t\t\t'recompute4: 2 + 3 = 5',\n\t\t\t\t'value: 5',\n\t\t\t]);\n\n\t\t\tconst disposable = keepObserved(computedSum); // Use keepObserved to keep the cache.\n\t\t\t// You can also use `computedSum.keepObserved(store)` for an inline experience.\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 1 % 3 = 1',\n\t\t\t\t'recompute2: 1 * 2 = 2',\n\t\t\t\t'recompute3: 1 * 3 = 3',\n\t\t\t\t'recompute4: 2 + 3 = 5',\n\t\t\t\t'value: 5',\n\t\t\t]);\n\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'value: 5',\n\t\t\t]);\n\t\t\t// Tada, no recomputations!\n\n\t\t\tobservable1.set(2, undefined);\n\t\t\t// The keepObserved does not force deriveds to be recomputed! They are still lazy.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\t// Those deriveds are recomputed on demand, i.e. when someone reads them.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 2 % 3 = 2',\n\t\t\t\t'recompute2: 2 * 2 = 4',\n\t\t\t\t'recompute3: 2 * 3 = 6',\n\t\t\t\t'recompute4: 4 + 6 = 10',\n\t\t\t\t'value: 10',\n\t\t\t]);\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\t// ... and then cached again\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), (['value: 10']));\n\n\t\t\tdisposable.dispose(); // Don't forget to dispose the keepAlive to prevent memory leaks!\n\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\t// Which disables the cache again\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 2 % 3 = 2',\n\t\t\t\t'recompute2: 2 * 2 = 4',\n\t\t\t\t'recompute3: 2 * 3 = 6',\n\t\t\t\t'recompute4: 4 + 6 = 10',\n\t\t\t\t'value: 10',\n\t\t\t]);\n\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 2 % 3 = 2',\n\t\t\t\t'recompute2: 2 * 2 = 4',\n\t\t\t\t'recompute3: 2 * 3 = 6',\n\t\t\t\t'recompute4: 4 + 6 = 10',\n\t\t\t\t'value: 10',\n\t\t\t]);\n\n\t\t\t// Why don't we just always keep the cache alive?\n\t\t\t// This is because in order to keep the cache alive, we have to keep our subscriptions to our dependencies alive,\n\t\t\t// which could cause memory-leaks.\n\t\t\t// So instead, when the last observer of a derived is disposed, we dispose our subscriptions to our dependencies.\n\t\t\t// `keepObserved` just prevents this from happening.\n\t\t});\n\n\t\ttest('autorun that receives deltas of signals', () => {\n\t\t\tconst log = new Log();\n\n\t\t\t// A signal is an observable without a value.\n\t\t\t// However, it can ship change information when it is triggered.\n\t\t\t// Readers can process/aggregate this change information.\n\t\t\tconst signal = observableSignal<{ msg: string }>('signal');\n\n\t\t\tconst disposable = autorunHandleChanges({\n\t\t\t\tchangeTracker: {\n\t\t\t\t\t// The change summary is used to collect the changes\n\t\t\t\t\tcreateChangeSummary: () => ({ msgs: [] as string[] }),\n\t\t\t\t\thandleChange(context, changeSummary) {\n\t\t\t\t\t\tif (context.didChange(signal)) {\n\t\t\t\t\t\t\t// We just push the changes into an array\n\t\t\t\t\t\t\tchangeSummary.msgs.push(context.change.msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true; // We want to handle the change\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}, (reader, changeSummary) => {\n\t\t\t\t// When handling the change, make sure to read the signal!\n\t\t\t\tsignal.read(reader);\n\t\t\t\tlog.log('msgs: ' + changeSummary.msgs.join(', '));\n\t\t\t});\n\n\n\t\t\tsignal.trigger(undefined, { msg: 'foobar' });\n\n\t\t\ttransaction(tx => {\n\t\t\t\t// You can batch triggering signals.\n\t\t\t\t// No delta information is lost!\n\t\t\t\tsignal.trigger(tx, { msg: 'hello' });\n\t\t\t\tsignal.trigger(tx, { msg: 'world' });\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'msgs: ',\n\t\t\t\t'msgs: foobar',\n\t\t\t\t'msgs: hello, world'\n\t\t\t]);\n\n\t\t\tdisposable.dispose();\n\t\t});\n\n\t\t// That is the end of the tutorial.\n\t\t// There are lots of utilities you can explore now, like `observableFromEvent`, `Event.fromObservableLight`,\n\t\t// autorunWithStore, observableWithStore and so on.\n\t});\n\n\ttest('topological order', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable1 = observableValue('myObservable1', 0);\n\t\tconst myObservable2 = observableValue('myObservable2', 0);\n\n\t\tconst myComputed1 = derived(reader => {\n\t\t\t/** @description myComputed1 */\n\t\t\tconst value1 = myObservable1.read(reader);\n\t\t\tconst value2 = myObservable2.read(reader);\n\t\t\tconst sum = value1 + value2;\n\t\t\tlog.log(`myComputed1.recompute(myObservable1: ${value1} + myObservable2: ${value2} = ${sum})`);\n\t\t\treturn sum;\n\t\t});\n\n\t\tconst myComputed2 = derived(reader => {\n\t\t\t/** @description myComputed2 */\n\t\t\tconst value1 = myComputed1.read(reader);\n\t\t\tconst value2 = myObservable1.read(reader);\n\t\t\tconst value3 = myObservable2.read(reader);\n\t\t\tconst sum = value1 + value2 + value3;\n\t\t\tlog.log(`myComputed2.recompute(myComputed1: ${value1} + myObservable1: ${value2} + myObservable2: ${value3} = ${sum})`);\n\t\t\treturn sum;\n\t\t});\n\n\t\tconst myComputed3 = derived(reader => {\n\t\t\t/** @description myComputed3 */\n\t\t\tconst value1 = myComputed2.read(reader);\n\t\t\tconst value2 = myObservable1.read(reader);\n\t\t\tconst value3 = myObservable2.read(reader);\n\t\t\tconst sum = value1 + value2 + value3;\n\t\t\tlog.log(`myComputed3.recompute(myComputed2: ${value1} + myObservable1: ${value2} + myObservable2: ${value3} = ${sum})`);\n\t\t\treturn sum;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tlog.log(`myAutorun.run(myComputed3: ${myComputed3.read(reader)})`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myComputed1.recompute(myObservable1: 0 + myObservable2: 0 = 0)',\n\t\t\t'myComputed2.recompute(myComputed1: 0 + myObservable1: 0 + myObservable2: 0 = 0)',\n\t\t\t'myComputed3.recompute(myComputed2: 0 + myObservable1: 0 + myObservable2: 0 = 0)',\n\t\t\t'myAutorun.run(myComputed3: 0)',\n\t\t]);\n\n\t\tmyObservable1.set(1, undefined);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myComputed1.recompute(myObservable1: 1 + myObservable2: 0 = 1)',\n\t\t\t'myComputed2.recompute(myComputed1: 1 + myObservable1: 1 + myObservable2: 0 = 2)',\n\t\t\t'myComputed3.recompute(myComputed2: 2 + myObservable1: 1 + myObservable2: 0 = 3)',\n\t\t\t'myAutorun.run(myComputed3: 3)',\n\t\t]);\n\n\t\ttransaction((tx) => {\n\t\t\tmyObservable1.set(2, tx);\n\t\t\tmyComputed2.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myComputed1.recompute(myObservable1: 2 + myObservable2: 0 = 2)',\n\t\t\t\t'myComputed2.recompute(myComputed1: 2 + myObservable1: 2 + myObservable2: 0 = 4)',\n\t\t\t]);\n\n\t\t\tmyObservable1.set(3, tx);\n\t\t\tmyComputed2.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myComputed1.recompute(myObservable1: 3 + myObservable2: 0 = 3)',\n\t\t\t\t'myComputed2.recompute(myComputed1: 3 + myObservable1: 3 + myObservable2: 0 = 6)',\n\t\t\t]);\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myComputed3.recompute(myComputed2: 6 + myObservable1: 3 + myObservable2: 0 = 9)',\n\t\t\t'myAutorun.run(myComputed3: 9)',\n\t\t]);\n\t});\n\n\tsuite('from event', () => {\n\n\t\tfunction init(): { log: Log; setValue: (value: number | undefined) => void; observable: IObservable<number | undefined> } {\n\t\t\tconst log = new Log();\n\n\t\t\tlet value: number | undefined = 0;\n\t\t\tconst eventEmitter = new Emitter<void>();\n\n\t\t\tlet id = 0;\n\t\t\tconst observable = observableFromEvent(\n\t\t\t\t(handler) => {\n\t\t\t\t\tconst curId = id++;\n\t\t\t\t\tlog.log(`subscribed handler ${curId}`);\n\t\t\t\t\tconst disposable = eventEmitter.event(handler);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdispose: () => {\n\t\t\t\t\t\t\tlog.log(`unsubscribed handler ${curId}`);\n\t\t\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tlog.log(`compute value ${value}`);\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tlog,\n\t\t\t\tsetValue: (newValue) => {\n\t\t\t\t\tvalue = newValue;\n\t\t\t\t\teventEmitter.fire();\n\t\t\t\t},\n\t\t\t\tobservable,\n\t\t\t};\n\t\t}\n\n\t\ttest('Handle undefined', () => {\n\t\t\tconst { log, setValue, observable } = init();\n\n\t\t\tsetValue(undefined);\n\n\t\t\tconst autorunDisposable = autorun(reader => {\n\t\t\t\t/** @description MyAutorun */\n\t\t\t\tobservable.read(reader);\n\t\t\t\tlog.log(\n\t\t\t\t\t`autorun, value: ${observable.read(reader)}`\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'subscribed handler 0',\n\t\t\t\t'compute value undefined',\n\t\t\t\t'autorun, value: undefined',\n\t\t\t]);\n\n\t\t\tsetValue(1);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'compute value 1',\n\t\t\t\t'autorun, value: 1'\n\t\t\t]);\n\n\t\t\tautorunDisposable.dispose();\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'unsubscribed handler 0'\n\t\t\t]);\n\t\t});\n\n\t\ttest('basic', () => {\n\t\t\tconst { log, setValue, observable } = init();\n\n\t\t\tconst shouldReadObservable = observableValue('shouldReadObservable', true);\n\n\t\t\tconst autorunDisposable = autorun(reader => {\n\t\t\t\t/** @description MyAutorun */\n\t\t\t\tif (shouldReadObservable.read(reader)) {\n\t\t\t\t\tobservable.read(reader);\n\t\t\t\t\tlog.log(\n\t\t\t\t\t\t`autorun, should read: true, value: ${observable.read(reader)}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tlog.log(`autorun, should read: false`);\n\t\t\t\t}\n\t\t\t});\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'subscribed handler 0',\n\t\t\t\t'compute value 0',\n\t\t\t\t'autorun, should read: true, value: 0',\n\t\t\t]);\n\n\t\t\t// Cached get\n\t\t\tlog.log(`get value: ${observable.get()}`);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['get value: 0']);\n\n\t\t\tsetValue(1);\n\t\t\t// Trigger autorun, no unsub/sub\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'compute value 1',\n\t\t\t\t'autorun, should read: true, value: 1',\n\t\t\t]);\n\n\t\t\t// Unsubscribe when not read\n\t\t\tshouldReadObservable.set(false, undefined);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'autorun, should read: false',\n\t\t\t\t'unsubscribed handler 0',\n\t\t\t]);\n\n\t\t\tshouldReadObservable.set(true, undefined);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'subscribed handler 1',\n\t\t\t\t'compute value 1',\n\t\t\t\t'autorun, should read: true, value: 1',\n\t\t\t]);\n\n\t\t\tautorunDisposable.dispose();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'unsubscribed handler 1',\n\t\t\t]);\n\t\t});\n\n\t\ttest('get without observers', () => {\n\t\t\tconst { log, observable } = init();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\tlog.log(`get value: ${observable.get()}`);\n\t\t\t// Not cached or subscribed\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'compute value 0',\n\t\t\t\t'get value: 0',\n\t\t\t]);\n\n\t\t\tlog.log(`get value: ${observable.get()}`);\n\t\t\t// Still not cached or subscribed\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'compute value 0',\n\t\t\t\t'get value: 0',\n\t\t\t]);\n\t\t});\n\t});\n\n\ttest('reading derived in transaction unsubscribes unnecessary observables', () => {\n\t\tconst log = new Log();\n\n\t\tconst shouldReadObservable = observableValue('shouldReadMyObs1', true);\n\t\tconst myObs1 = new LoggingObservableValue('myObs1', 0, log);\n\t\tconst myComputed = derived(reader => {\n\t\t\t/** @description myComputed */\n\t\t\tlog.log('myComputed.recompute');\n\t\t\tif (shouldReadObservable.read(reader)) {\n\t\t\t\treturn myObs1.read(reader);\n\t\t\t}\n\t\t\treturn 1;\n\t\t});\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst value = myComputed.read(reader);\n\t\t\tlog.log(`myAutorun: ${value}`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myComputed.recompute',\n\t\t\t'myObs1.firstObserverAdded',\n\t\t\t'myObs1.get',\n\t\t\t'myAutorun: 0',\n\t\t]);\n\n\t\ttransaction(tx => {\n\t\t\tmyObs1.set(1, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), (['myObs1.set (value 1)']));\n\n\t\t\tshouldReadObservable.set(false, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\t\tmyComputed.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myComputed.recompute',\n\t\t\t\t'myObs1.lastObserverRemoved',\n\t\t\t]);\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), (['myAutorun: 1']));\n\t});\n\n\ttest('avoid recomputation of deriveds that are no longer read', () => {\n\t\tconst log = new Log();\n\n\t\tconst myObsShouldRead = new LoggingObservableValue('myObsShouldRead', true, log);\n\t\tconst myObs1 = new LoggingObservableValue('myObs1', 0, log);\n\n\t\tconst myComputed1 = derived(reader => {\n\t\t\t/** @description myComputed1 */\n\t\t\tconst myObs1Val = myObs1.read(reader);\n\t\t\tconst result = myObs1Val % 10;\n\t\t\tlog.log(`myComputed1(myObs1: ${myObs1Val}): Computed ${result}`);\n\t\t\treturn myObs1Val;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst shouldRead = myObsShouldRead.read(reader);\n\t\t\tif (shouldRead) {\n\t\t\t\tconst v = myComputed1.read(reader);\n\t\t\t\tlog.log(`myAutorun(shouldRead: true, myComputed1: ${v}): run`);\n\t\t\t} else {\n\t\t\t\tlog.log(`myAutorun(shouldRead: false): run`);\n\t\t\t}\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObsShouldRead.firstObserverAdded',\n\t\t\t'myObsShouldRead.get',\n\t\t\t'myObs1.firstObserverAdded',\n\t\t\t'myObs1.get',\n\t\t\t'myComputed1(myObs1: 0): Computed 0',\n\t\t\t'myAutorun(shouldRead: true, myComputed1: 0): run',\n\t\t]);\n\n\t\ttransaction(tx => {\n\t\t\tmyObsShouldRead.set(false, tx);\n\t\t\tmyObs1.set(1, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObsShouldRead.set (value false)',\n\t\t\t\t'myObs1.set (value 1)',\n\t\t\t]);\n\t\t});\n\t\t// myComputed1 should not be recomputed here, even though its dependency myObs1 changed!\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObsShouldRead.get',\n\t\t\t'myAutorun(shouldRead: false): run',\n\t\t\t'myObs1.lastObserverRemoved',\n\t\t]);\n\n\t\ttransaction(tx => {\n\t\t\tmyObsShouldRead.set(true, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObsShouldRead.set (value true)',\n\t\t\t]);\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObsShouldRead.get',\n\t\t\t'myObs1.firstObserverAdded',\n\t\t\t'myObs1.get',\n\t\t\t'myComputed1(myObs1: 1): Computed 1',\n\t\t\t'myAutorun(shouldRead: true, myComputed1: 1): run',\n\t\t]);\n\t});\n\n\tsuite('autorun rerun on neutral change', () => {\n\t\ttest('autorun reruns on neutral observable double change', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = observableValue('myObservable', 0);\n\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\t\t\t\tlog.log(`myAutorun.run(myObservable: ${myObservable.read(reader)})`);\n\t\t\t}));\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myAutorun.run(myObservable: 0)']);\n\n\n\t\t\ttransaction((tx) => {\n\t\t\t\tmyObservable.set(2, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tmyObservable.set(0, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myAutorun.run(myObservable: 0)']);\n\t\t});\n\n\t\ttest('autorun does not rerun on indirect neutral observable double change', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = observableValue('myObservable', 0);\n\t\t\tconst myDerived = derived(reader => {\n\t\t\t\t/** @description myDerived */\n\t\t\t\tconst val = myObservable.read(reader);\n\t\t\t\tlog.log(`myDerived.read(myObservable: ${val})`);\n\t\t\t\treturn val;\n\t\t\t});\n\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\t\t\t\tlog.log(`myAutorun.run(myDerived: ${myDerived.read(reader)})`);\n\t\t\t}));\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.read(myObservable: 0)',\n\t\t\t\t'myAutorun.run(myDerived: 0)'\n\t\t\t]);\n\n\t\t\ttransaction((tx) => {\n\t\t\t\tmyObservable.set(2, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tmyObservable.set(0, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.read(myObservable: 0)'\n\t\t\t]);\n\t\t});\n\n\t\ttest('autorun reruns on indirect neutral observable double change when changes propagate', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = observableValue('myObservable', 0);\n\t\t\tconst myDerived = derived(reader => {\n\t\t\t\t/** @description myDerived */\n\t\t\t\tconst val = myObservable.read(reader);\n\t\t\t\tlog.log(`myDerived.read(myObservable: ${val})`);\n\t\t\t\treturn val;\n\t\t\t});\n\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\t\t\t\tlog.log(`myAutorun.run(myDerived: ${myDerived.read(reader)})`);\n\t\t\t}));\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.read(myObservable: 0)',\n\t\t\t\t'myAutorun.run(myDerived: 0)'\n\t\t\t]);\n\n\t\t\ttransaction((tx) => {\n\t\t\t\tmyObservable.set(2, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tmyDerived.get(); // This marks the auto-run as changed\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t\t'myDerived.read(myObservable: 2)'\n\t\t\t\t]);\n\n\t\t\t\tmyObservable.set(0, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.read(myObservable: 0)',\n\t\t\t\t'myAutorun.run(myDerived: 0)'\n\t\t\t]);\n\t\t});\n\t});\n\n\ttest('self-disposing autorun', () => {\n\t\tconst log = new Log();\n\n\t\tconst observable1 = new LoggingObservableValue('myObservable1', 0, log);\n\t\tconst myObservable2 = new LoggingObservableValue('myObservable2', 0, log);\n\t\tconst myObservable3 = new LoggingObservableValue('myObservable3', 0, log);\n\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description autorun */\n\t\t\tif (observable1.read(reader) >= 2) {\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t\t'myObservable1.set (value 2)',\n\t\t\t\t\t'myObservable1.get',\n\t\t\t\t]);\n\n\t\t\t\tmyObservable2.read(reader);\n\t\t\t\t// First time this observable is read\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t\t'myObservable2.firstObserverAdded',\n\t\t\t\t\t'myObservable2.get',\n\t\t\t\t]);\n\n\t\t\t\td.dispose();\n\t\t\t\t// Disposing removes all observers\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t\t'myObservable1.lastObserverRemoved',\n\t\t\t\t\t'myObservable2.lastObserverRemoved',\n\t\t\t\t]);\n\n\t\t\t\tmyObservable3.read(reader);\n\t\t\t\t// This does not subscribe the observable, because the autorun is disposed\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t\t'myObservable3.get',\n\t\t\t\t]);\n\t\t\t}\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable1.firstObserverAdded',\n\t\t\t'myObservable1.get',\n\t\t]);\n\n\t\tobservable1.set(1, undefined);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable1.set (value 1)',\n\t\t\t'myObservable1.get',\n\t\t]);\n\n\t\tobservable1.set(2, undefined);\n\t\t// See asserts in the autorun\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\t});\n\n\ttest('changing observables in endUpdate', () => {\n\t\tconst log = new Log();\n\n\t\tconst myObservable1 = new LoggingObservableValue('myObservable1', 0, log);\n\t\tconst myObservable2 = new LoggingObservableValue('myObservable2', 0, log);\n\n\t\tconst myDerived1 = derived(reader => {\n\t\t\t/** @description myDerived1 */\n\t\t\tconst val = myObservable1.read(reader);\n\t\t\tlog.log(`myDerived1.read(myObservable: ${val})`);\n\t\t\treturn val;\n\t\t});\n\n\t\tconst myDerived2 = derived(reader => {\n\t\t\t/** @description myDerived2 */\n\t\t\tconst val = myObservable2.read(reader);\n\t\t\tif (val === 1) {\n\t\t\t\tmyDerived1.read(reader);\n\t\t\t}\n\t\t\tlog.log(`myDerived2.read(myObservable: ${val})`);\n\t\t\treturn val;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst myDerived1Val = myDerived1.read(reader);\n\t\t\tconst myDerived2Val = myDerived2.read(reader);\n\t\t\tlog.log(`myAutorun.run(myDerived1: ${myDerived1Val}, myDerived2: ${myDerived2Val})`);\n\t\t}));\n\n\t\ttransaction(tx => {\n\t\t\tmyObservable2.set(1, tx);\n\t\t\t// end update of this observable will trigger endUpdate of myDerived1 and\n\t\t\t// the autorun and the autorun will add myDerived2 as observer to myDerived1\n\t\t\tmyObservable1.set(1, tx);\n\t\t});\n\t});\n\n\ttest('set dependency in derived', () => {\n\t\tconst log = new Log();\n\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\t\tconst myComputed = derived(reader => {\n\t\t\t/** @description myComputed */\n\t\t\tlet value = myObservable.read(reader);\n\t\t\tconst origValue = value;\n\t\t\tlog.log(`myComputed(myObservable: ${origValue}): start computing`);\n\t\t\tif (value % 3 !== 0) {\n\t\t\t\tvalue++;\n\t\t\t\tmyObservable.set(value, undefined);\n\t\t\t}\n\t\t\tlog.log(`myComputed(myObservable: ${origValue}): finished computing`);\n\t\t\treturn value;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst value = myComputed.read(reader);\n\t\t\tlog.log(`myAutorun(myComputed: ${value})`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'myComputed(myObservable: 0): start computing',\n\t\t\t'myComputed(myObservable: 0): finished computing',\n\t\t\t'myAutorun(myComputed: 0)'\n\t\t]);\n\n\t\tmyObservable.set(1, undefined);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.set (value 1)',\n\t\t\t'myObservable.get',\n\t\t\t'myComputed(myObservable: 1): start computing',\n\t\t\t'myObservable.set (value 2)',\n\t\t\t'myComputed(myObservable: 1): finished computing',\n\t\t\t'myObservable.get',\n\t\t\t'myComputed(myObservable: 2): start computing',\n\t\t\t'myObservable.set (value 3)',\n\t\t\t'myComputed(myObservable: 2): finished computing',\n\t\t\t'myObservable.get',\n\t\t\t'myComputed(myObservable: 3): start computing',\n\t\t\t'myComputed(myObservable: 3): finished computing',\n\t\t\t'myAutorun(myComputed: 3)',\n\t\t]);\n\t});\n\n\ttest('set dependency in autorun', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst value = myObservable.read(reader);\n\t\t\tlog.log(`myAutorun(myObservable: ${value}): start`);\n\t\t\tif (value !== 0 && value < 4) {\n\t\t\t\tmyObservable.set(value + 1, undefined);\n\t\t\t}\n\t\t\tlog.log(`myAutorun(myObservable: ${value}): end`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'myAutorun(myObservable: 0): start',\n\t\t\t'myAutorun(myObservable: 0): end',\n\t\t]);\n\n\t\tmyObservable.set(1, undefined);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.set (value 1)',\n\t\t\t'myObservable.get',\n\t\t\t'myAutorun(myObservable: 1): start',\n\t\t\t'myObservable.set (value 2)',\n\t\t\t'myAutorun(myObservable: 1): end',\n\t\t\t'myObservable.get',\n\t\t\t'myAutorun(myObservable: 2): start',\n\t\t\t'myObservable.set (value 3)',\n\t\t\t'myAutorun(myObservable: 2): end',\n\t\t\t'myObservable.get',\n\t\t\t'myAutorun(myObservable: 3): start',\n\t\t\t'myObservable.set (value 4)',\n\t\t\t'myAutorun(myObservable: 3): end',\n\t\t\t'myObservable.get',\n\t\t\t'myAutorun(myObservable: 4): start',\n\t\t\t'myAutorun(myObservable: 4): end',\n\t\t]);\n\t});\n\n\ttest('get in transaction between sets', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\tconst myDerived1 = derived(reader => {\n\t\t\t/** @description myDerived1 */\n\t\t\tconst value = myObservable.read(reader);\n\t\t\tlog.log(`myDerived1(myObservable: ${value}): start computing`);\n\t\t\treturn value;\n\t\t});\n\n\t\tconst myDerived2 = derived(reader => {\n\t\t\t/** @description myDerived2 */\n\t\t\tconst value = myDerived1.read(reader);\n\t\t\tlog.log(`myDerived2(myDerived1: ${value}): start computing`);\n\t\t\treturn value;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst value = myDerived2.read(reader);\n\t\t\tlog.log(`myAutorun(myDerived2: ${value})`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'myDerived1(myObservable: 0): start computing',\n\t\t\t'myDerived2(myDerived1: 0): start computing',\n\t\t\t'myAutorun(myDerived2: 0)',\n\t\t]);\n\n\t\ttransaction(tx => {\n\t\t\tmyObservable.set(1, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value 1)',\n\t\t\t]);\n\n\t\t\tmyDerived2.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.get',\n\t\t\t\t'myDerived1(myObservable: 1): start computing',\n\t\t\t\t'myDerived2(myDerived1: 1): start computing',\n\t\t\t]);\n\n\t\t\tmyObservable.set(2, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value 2)',\n\t\t\t]);\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.get',\n\t\t\t'myDerived1(myObservable: 2): start computing',\n\t\t\t'myDerived2(myDerived1: 2): start computing',\n\t\t\t'myAutorun(myDerived2: 2)',\n\t\t]);\n\t});\n\n\ttest('bug: Dont reset states', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable1 = new LoggingObservableValue('myObservable1', 0, log);\n\n\t\tconst myObservable2 = new LoggingObservableValue('myObservable2', 0, log);\n\t\tconst myDerived2 = derived(reader => {\n\t\t\t/** @description myDerived2 */\n\t\t\tconst val = myObservable2.read(reader);\n\t\t\tlog.log(`myDerived2.computed(myObservable2: ${val})`);\n\t\t\treturn val % 10;\n\t\t});\n\n\t\tconst myDerived3 = derived(reader => {\n\t\t\t/** @description myDerived3 */\n\t\t\tconst val1 = myObservable1.read(reader);\n\t\t\tconst val2 = myDerived2.read(reader);\n\t\t\tlog.log(`myDerived3.computed(myDerived1: ${val1}, myDerived2: ${val2})`);\n\t\t\treturn `${val1} + ${val2}`;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst val = myDerived3.read(reader);\n\t\t\tlog.log(`myAutorun(myDerived3: ${val})`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable1.firstObserverAdded',\n\t\t\t'myObservable1.get',\n\t\t\t'myObservable2.firstObserverAdded',\n\t\t\t'myObservable2.get',\n\t\t\t'myDerived2.computed(myObservable2: 0)',\n\t\t\t'myDerived3.computed(myDerived1: 0, myDerived2: 0)',\n\t\t\t'myAutorun(myDerived3: 0 + 0)',\n\t\t]);\n\n\t\ttransaction(tx => {\n\t\t\tmyObservable1.set(1, tx); // Mark myDerived 3 as stale\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable1.set (value 1)',\n\t\t\t]);\n\n\t\t\tmyObservable2.set(10, tx); // This is a non-change. myDerived3 should not be marked as possibly-depedency-changed!\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable2.set (value 10)',\n\t\t\t]);\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable1.get',\n\t\t\t'myObservable2.get',\n\t\t\t'myDerived2.computed(myObservable2: 10)',\n\t\t\t'myDerived3.computed(myDerived1: 1, myDerived2: 0)',\n\t\t\t'myAutorun(myDerived3: 1 + 0)',\n\t\t]);\n\t});\n\n\ttest('bug: Add observable in endUpdate', () => {\n\t\tconst myObservable1 = observableValue('myObservable1', 0);\n\t\tconst myObservable2 = observableValue('myObservable2', 0);\n\n\t\tconst myDerived1 = derived(reader => {\n\t\t\t/** @description myDerived1 */\n\t\t\treturn myObservable1.read(reader);\n\t\t});\n\n\t\tconst myDerived2 = derived(reader => {\n\t\t\t/** @description myDerived2 */\n\t\t\treturn myObservable2.read(reader);\n\t\t});\n\n\t\tconst myDerivedA1 = derived(reader => /** @description myDerivedA1 */ {\n\t\t\tconst d1 = myDerived1.read(reader);\n\t\t\tif (d1 === 1) {\n\t\t\t\t// This adds an observer while myDerived is still in update mode.\n\t\t\t\t// When myDerived exits update mode, the observer shouldn't receive\n\t\t\t\t// more endUpdate than beginUpdate calls.\n\t\t\t\tmyDerived2.read(reader);\n\t\t\t}\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun1 */\n\t\t\tmyDerivedA1.read(reader);\n\t\t}));\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun2 */\n\t\t\tmyDerived2.read(reader);\n\t\t}));\n\n\t\ttransaction(tx => {\n\t\t\tmyObservable1.set(1, tx);\n\t\t\tmyObservable2.set(1, tx);\n\t\t});\n\t});\n\n\ttest('bug: fromObservableLight doesnt subscribe', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\tconst myDerived = derived(reader => /** @description myDerived */ {\n\t\t\tconst val = myObservable.read(reader);\n\t\t\tlog.log(`myDerived.computed(myObservable2: ${val})`);\n\t\t\treturn val % 10;\n\t\t});\n\n\t\tconst e = Event.fromObservableLight(myDerived);\n\t\tlog.log('event created');\n\t\te(() => {\n\t\t\tlog.log('event fired');\n\t\t});\n\n\t\tmyObservable.set(1, undefined);\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'event created',\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'myDerived.computed(myObservable2: 0)',\n\t\t\t'myObservable.set (value 1)',\n\t\t\t'myObservable.get',\n\t\t\t'myDerived.computed(myObservable2: 1)',\n\t\t\t'event fired',\n\t\t]);\n\t});\n\n\ttest('bug: Event.fromObservable always should get events', () => {\n\t\tconst emitter = new Emitter();\n\t\tconst log = new Log();\n\t\tlet i = 0;\n\t\tconst obs = observableFromEvent(emitter.event, () => i);\n\n\t\ti++;\n\t\temitter.fire(1);\n\n\t\tconst evt2 = Event.fromObservable(obs);\n\t\tconst d = evt2(e => {\n\t\t\tlog.log(`event fired ${e}`);\n\t\t});\n\n\t\ti++;\n\t\temitter.fire(2);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['event fired 2']);\n\n\t\ti++;\n\t\temitter.fire(3);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['event fired 3']);\n\n\t\td.dispose();\n\t});\n\n\ttest('dont run autorun after dispose', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description update */\n\t\t\tconst v = myObservable.read(reader);\n\t\t\tlog.log('autorun, myObservable:' + v);\n\t\t});\n\n\t\ttransaction(tx => {\n\t\t\tmyObservable.set(1, tx);\n\t\t\td.dispose();\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'autorun, myObservable:0',\n\t\t\t'myObservable.set (value 1)',\n\t\t\t'myObservable.lastObserverRemoved',\n\t\t]);\n\t});\n\n\tsuite('waitForState', () => {\n\t\ttest('resolve', async () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = new LoggingObservableValue('myObservable', { state: 'initializing' as 'initializing' | 'ready' | 'error' }, log);\n\n\t\t\tconst p = waitForState(myObservable, p => p.state === 'ready', p => p.state === 'error').then(r => {\n\t\t\t\tlog.log(`resolved ${JSON.stringify(r)}`);\n\t\t\t}, (err) => {\n\t\t\t\tlog.log(`rejected ${JSON.stringify(err)}`);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.firstObserverAdded',\n\t\t\t\t'myObservable.get',\n\t\t\t]);\n\n\t\t\tmyObservable.set({ state: 'ready' }, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value [object Object])',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'myObservable.lastObserverRemoved',\n\t\t\t]);\n\n\t\t\tawait p;\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'resolved {\\\"state\\\":\\\"ready\\\"}',\n\t\t\t]);\n\t\t});\n\n\t\ttest('resolveImmediate', async () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = new LoggingObservableValue('myObservable', { state: 'ready' as 'initializing' | 'ready' | 'error' }, log);\n\n\t\t\tconst p = waitForState(myObservable, p => p.state === 'ready', p => p.state === 'error').then(r => {\n\t\t\t\tlog.log(`resolved ${JSON.stringify(r)}`);\n\t\t\t}, (err) => {\n\t\t\t\tlog.log(`rejected ${JSON.stringify(err)}`);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.firstObserverAdded',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'myObservable.lastObserverRemoved',\n\t\t\t]);\n\n\t\t\tmyObservable.set({ state: 'error' }, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value [object Object])',\n\t\t\t]);\n\n\t\t\tawait p;\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'resolved {\\\"state\\\":\\\"ready\\\"}',\n\t\t\t]);\n\t\t});\n\n\t\ttest('reject', async () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = new LoggingObservableValue('myObservable', { state: 'initializing' as 'initializing' | 'ready' | 'error' }, log);\n\n\t\t\tconst p = waitForState(myObservable, p => p.state === 'ready', p => p.state === 'error').then(r => {\n\t\t\t\tlog.log(`resolved ${JSON.stringify(r)}`);\n\t\t\t}, (err) => {\n\t\t\t\tlog.log(`rejected ${JSON.stringify(err)}`);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.firstObserverAdded',\n\t\t\t\t'myObservable.get',\n\t\t\t]);\n\n\t\t\tmyObservable.set({ state: 'error' }, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value [object Object])',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'myObservable.lastObserverRemoved',\n\t\t\t]);\n\n\t\t\tawait p;\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'rejected {\\\"state\\\":\\\"error\\\"}'\n\t\t\t]);\n\t\t});\n\n\t\ttest('derived as lazy', () => {\n\t\t\tconst store = new DisposableStore();\n\t\t\tconst log = new Log();\n\t\t\tlet i = 0;\n\t\t\tconst d = derivedDisposable(() => {\n\t\t\t\tconst id = i++;\n\t\t\t\tlog.log('myDerived ' + id);\n\t\t\t\treturn {\n\t\t\t\t\tdispose: () => log.log(`disposed ${id}`)\n\t\t\t\t};\n\t\t\t});\n\n\t\t\td.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myDerived 0', 'disposed 0']);\n\t\t\td.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myDerived 1', 'disposed 1']);\n\n\t\t\td.keepObserved(store);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\td.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myDerived 2']);\n\t\t\td.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\tstore.dispose();\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['disposed 2']);\n\t\t});\n\t});\n\n\ttest('observableValue', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable1 = observableValue<number>('myObservable1', 0);\n\t\tconst myObservable2 = observableValue<number, { message: string }>('myObservable2', 0);\n\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description update */\n\t\t\tconst v1 = myObservable1.read(reader);\n\t\t\tconst v2 = myObservable2.read(reader);\n\t\t\tlog.log('autorun, myObservable1:' + v1 + ', myObservable2:' + v2);\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'autorun, myObservable1:0, myObservable2:0'\n\t\t]);\n\n\t\t// Doesn't trigger the autorun, because no delta was provided and the value did not change\n\t\tmyObservable1.set(0, undefined);\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t]);\n\n\t\t// Triggers the autorun. The value did not change, but a delta value was provided\n\t\tmyObservable2.set(0, undefined, { message: 'change1' });\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'autorun, myObservable1:0, myObservable2:0'\n\t\t]);\n\n\t\td.dispose();\n\t});\n\n\tsuite('autorun error handling', () => {\n\t\ttest('immediate throw', () => {\n\t\t\tconst log = new Log();\n\n\t\t\tsetUnexpectedErrorHandler(e => {\n\t\t\t\tlog.log(`error: ${e.message}`);\n\t\t\t});\n\n\t\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\t\tconst d = autorun(reader => {\n\t\t\t\tmyObservable.read(reader);\n\t\t\t\tthrow new Error('foobar');\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.firstObserverAdded',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'error: foobar'\n\t\t\t]);\n\n\t\t\tmyObservable.set(1, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value 1)',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'error: foobar',\n\t\t\t]);\n\n\t\t\td.dispose();\n\t\t});\n\n\t\ttest('late throw', () => {\n\t\t\tconst log = new Log();\n\n\t\t\tsetUnexpectedErrorHandler(e => {\n\t\t\t\tlog.log(`error: ${e.message}`);\n\t\t\t});\n\n\t\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\t\tconst d = autorun(reader => {\n\t\t\t\tconst value = myObservable.read(reader);\n\t\t\t\tif (value >= 1) {\n\t\t\t\t\tthrow new Error('foobar');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.firstObserverAdded',\n\t\t\t\t'myObservable.get',\n\t\t\t]);\n\n\t\t\tmyObservable.set(1, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value 1)',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'error: foobar',\n\t\t\t]);\n\n\t\t\tmyObservable.set(2, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value 2)',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'error: foobar',\n\t\t\t]);\n\n\t\t\td.dispose();\n\t\t});\n\t});\n\n\ttest('recomputeInitiallyAndOnChange should work when a dependency sets an observable', () => {\n\t\tconst store = new DisposableStore();\n\t\tconst log = new Log();\n\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\tlet shouldUpdate = true;\n\n\t\tconst myDerived = derived(reader => {\n\t\t\t/** @description myDerived */\n\n\t\t\tlog.log('myDerived.computed start');\n\n\t\t\tconst val = myObservable.read(reader);\n\n\t\t\tif (shouldUpdate) {\n\t\t\t\tshouldUpdate = false;\n\t\t\t\tmyObservable.set(1, undefined);\n\t\t\t}\n\n\t\t\tlog.log('myDerived.computed end');\n\n\t\t\treturn val;\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\tmyDerived.recomputeInitiallyAndOnChange(store, val => {\n\t\t\tlog.log(`recomputeInitiallyAndOnChange, myDerived: ${val}`);\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myDerived.computed start',\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'myObservable.set (value 1)',\n\t\t\t'myDerived.computed end',\n\t\t\t'myDerived.computed start',\n\t\t\t'myObservable.get',\n\t\t\t'myDerived.computed end',\n\t\t\t'recomputeInitiallyAndOnChange, myDerived: 1',\n\t\t]);\n\n\t\tmyDerived.get();\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\tstore.dispose();\n\t});\n\n\tsuite('prevent invalid usage', () => {\n\t\tsuite('reading outside of compute function', () => {\n\t\t\ttest('derived', () => {\n\t\t\t\tlet fn: () => void = () => { };\n\n\t\t\t\tconst obs = observableValue('obs', 0);\n\t\t\t\tconst d = derived(reader => {\n\t\t\t\t\tfn = () => { obs.read(reader); };\n\t\t\t\t\treturn obs.read(reader);\n\t\t\t\t});\n\n\t\t\t\tconst disp = autorun(reader => {\n\t\t\t\t\td.read(reader);\n\t\t\t\t});\n\n\t\t\t\tassert.throws(() => {\n\t\t\t\t\tfn();\n\t\t\t\t});\n\n\t\t\t\tdisp.dispose();\n\t\t\t});\n\n\t\t\ttest('autorun', () => {\n\t\t\t\tlet fn: () => void = () => { };\n\n\t\t\t\tconst obs = observableValue('obs', 0);\n\t\t\t\tconst disp = autorun(reader => {\n\t\t\t\t\tfn = () => { obs.read(reader); };\n\t\t\t\t\tobs.read(reader);\n\t\t\t\t});\n\n\t\t\t\tassert.throws(() => {\n\t\t\t\t\tfn();\n\t\t\t\t});\n\n\t\t\t\tdisp.dispose();\n\t\t\t});\n\t\t});\n\n\t\ttest.skip('catches cyclic dependencies', () => {\n\t\t\tconst log = new Log();\n\n\t\t\tsetUnexpectedErrorHandler((e) => {\n\t\t\t\tlog.log(e.toString());\n\t\t\t});\n\n\t\t\tconst obs = observableValue('obs', 0);\n\t\t\tconst d1 = derived(reader => {\n\t\t\t\tlog.log('d1.computed start');\n\t\t\t\tconst x = obs.read(reader) + d2.read(reader);\n\t\t\t\tlog.log('d1.computed end');\n\t\t\t\treturn x;\n\t\t\t});\n\t\t\tconst d2 = derived(reader => {\n\t\t\t\tlog.log('d2.computed start');\n\t\t\t\td1.read(reader);\n\t\t\t\tlog.log('d2.computed end');\n\t\t\t\treturn 0;\n\t\t\t});\n\n\t\t\tconst disp = autorun(reader => {\n\t\t\t\tlog.log('autorun start');\n\t\t\t\td1.read(reader);\n\t\t\t\tlog.log('autorun end');\n\t\t\t\treturn 0;\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'autorun start',\n\t\t\t\t'd1.computed start',\n\t\t\t\t'd2.computed start',\n\t\t\t\t'Error: Cyclic deriveds are not supported yet!',\n\t\t\t\t'd1.computed end',\n\t\t\t\t'autorun end'\n\t\t\t]));\n\n\t\t\tdisp.dispose();\n\t\t});\n\t});\n\n\tsuite('observableReducer', () => {\n\t\ttest('main', () => {\n\t\t\tconst store = new DisposableStore();\n\t\t\tconst log = new Log();\n\n\t\t\tconst myObservable1 = observableValue<number, number>('myObservable1', 5);\n\t\t\tconst myObservable2 = observableValue<number, number>('myObservable2', 9);\n\n\t\t\tconst sum = observableReducer(this, {\n\t\t\t\tinitial: () => {\n\t\t\t\t\tlog.log('createInitial');\n\t\t\t\t\treturn myObservable1.get() + myObservable2.get();\n\t\t\t\t},\n\t\t\t\tdisposeFinal: (values) => {\n\t\t\t\t\tlog.log(`disposeFinal ${values}`);\n\t\t\t\t},\n\t\t\t\tchangeTracker: recordChanges({ myObservable1, myObservable2 }),\n\t\t\t\tupdate: (reader: IDerivedReader<number>, previousValue, changes) => {\n\t\t\t\t\tlog.log(`update ${JSON.stringify(changes)}`);\n\t\t\t\t\tlet delta = 0;\n\t\t\t\t\tfor (const change of changes.changes) {\n\t\t\t\t\t\tdelta += change.change;\n\t\t\t\t\t}\n\n\t\t\t\t\treader.reportChange(delta);\n\t\t\t\t\tconst resultValue = previousValue + delta;\n\t\t\t\t\tlog.log(`update -> ${resultValue}`);\n\t\t\t\t\treturn resultValue;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\t\tstore.add(autorunWithStoreHandleChanges({\n\t\t\t\tchangeTracker: recordChanges({ sum })\n\t\t\t}, (_reader, changes) => {\n\t\t\t\tlog.log(`autorun ${JSON.stringify(changes)}`);\n\t\t\t}));\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'createInitial',\n\t\t\t\t'update {\"changes\":[],\"myObservable1\":5,\"myObservable2\":9}',\n\t\t\t\t'update -> 14',\n\t\t\t\t'autorun {\"changes\":[],\"sum\":14}',\n\t\t\t]);\n\n\t\t\ttransaction(tx => {\n\t\t\t\tmyObservable1.set(myObservable1.get() + 1, tx, 1);\n\t\t\t\tmyObservable2.set(myObservable2.get() + 3, tx, 3);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'update {\"changes\":[{\"key\":\"myObservable1\",\"change\":1},{\"key\":\"myObservable2\",\"change\":3}],\"myObservable1\":6,\"myObservable2\":12}',\n\t\t\t\t'update -> 18',\n\t\t\t\t'autorun {\"changes\":[{\"key\":\"sum\",\"change\":4}],\"sum\":18}'\n\t\t\t]));\n\n\t\t\ttransaction(tx => {\n\t\t\t\tmyObservable1.set(myObservable1.get() + 1, tx, 1);\n\t\t\t\tconst s = sum.get();\n\t\t\t\tlog.log(`sum.get() ${s}`);\n\t\t\t\tmyObservable2.set(myObservable2.get() + 3, tx, 3);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'update {\"changes\":[{\"key\":\"myObservable1\",\"change\":1}],\"myObservable1\":7,\"myObservable2\":12}',\n\t\t\t\t'update -> 19',\n\t\t\t\t'sum.get() 19',\n\t\t\t\t'update {\"changes\":[{\"key\":\"myObservable2\",\"change\":3}],\"myObservable1\":7,\"myObservable2\":15}',\n\t\t\t\t'update -> 22',\n\t\t\t\t'autorun {\"changes\":[{\"key\":\"sum\",\"change\":1}],\"sum\":22}'\n\t\t\t]));\n\n\t\t\tstore.dispose();\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'disposeFinal 22'\n\t\t\t]));\n\t\t});\n\t});\n\n\tsuite('disposableStores', () => {\n\t\ttest('derived with store', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst observable1 = observableValue('myObservableValue1', 0);\n\n\t\t\tconst computed1 = derived((reader) => {\n\t\t\t\tconst value = observable1.read(reader);\n\t\t\t\tlog.log(`computed ${value}`);\n\t\t\t\treader.store.add(toDisposable(() => {\n\t\t\t\t\tlog.log(`computed1: ${value} disposed`);\n\t\t\t\t}));\n\t\t\t\treturn value;\n\t\t\t});\n\n\t\t\tconst a = autorun(reader => {\n\t\t\t\tlog.log(`a: ${computed1.read(reader)}`);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed 0',\n\t\t\t\t'a: 0'\n\t\t\t]));\n\n\t\t\tobservable1.set(1, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed1: 0 disposed',\n\t\t\t\t'computed 1',\n\t\t\t\t'a: 1'\n\t\t\t]));\n\n\t\t\ta.dispose();\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed1: 1 disposed'\n\t\t\t]));\n\t\t});\n\n\t\ttest('derived with delayedStore', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst observable1 = observableValue('myObservableValue1', 0);\n\n\t\t\tconst computed1 = derived((reader) => {\n\t\t\t\tconst value = observable1.read(reader);\n\t\t\t\tlog.log(`computed ${value}`);\n\t\t\t\treader.delayedStore.add(toDisposable(() => {\n\t\t\t\t\tlog.log(`computed1: ${value} disposed`);\n\t\t\t\t}));\n\t\t\t\treturn value;\n\t\t\t});\n\n\t\t\tconst a = autorun(reader => {\n\t\t\t\tlog.log(`a: ${computed1.read(reader)}`);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed 0',\n\t\t\t\t'a: 0'\n\t\t\t]));\n\n\t\t\tobservable1.set(1, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed 1',\n\t\t\t\t'computed1: 0 disposed',\n\t\t\t\t'a: 1'\n\t\t\t]));\n\n\t\t\ta.dispose();\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed1: 1 disposed'\n\t\t\t]));\n\t\t});\n\t});\n\n\ttest('derivedHandleChanges with reportChanges', () => {\n\t\tconst log = new Log();\n\n\t\tconst signal1 = observableSignal<{ message: string }>('signal1');\n\t\tconst signal2 = observableSignal<{ message: string }>('signal2');\n\n\t\tconst signal2Derived = derivedHandleChanges(\n\t\t\t{ changeTracker: recordChanges({ signal2 }) },\n\t\t\t(reader: IDerivedReader<{ message: string }>, changeSummary) => {\n\t\t\t\tfor (const c of changeSummary.changes) {\n\t\t\t\t\treader.reportChange({ message: c.change.message + ' (derived)' });\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tconst d = derivedHandleChanges({\n\t\t\tchangeTracker: recordChanges({ signal1, signal2Derived }),\n\t\t}, (r: IDerivedReader<string>, changes) => {\n\t\t\tconst log = changes.changes.map(c => `${c.key}: ${c.change.message}`).join(', ');\n\t\t\tr.reportChange(log);\n\t\t});\n\n\t\tconst disp = runOnChange(d, (_val, _prev, changes) => {\n\t\t\tlog.log(`runOnChange ${JSON.stringify(changes)}`);\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\ttransaction(tx => {\n\t\t\tsignal1.trigger(tx, { message: 'foo' });\n\t\t\tsignal2.trigger(tx, { message: 'bar' });\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t'runOnChange [\"signal1: foo, signal2Derived: bar (derived)\"]'\n\t\t]));\n\n\n\t\ttransaction(tx => {\n\t\t\tsignal2.trigger(tx, { message: 'baz' });\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t'runOnChange [\"signal2Derived: baz (derived)\"]'\n\t\t]));\n\n\t\tdisp.dispose();\n\t});\n});\n\nexport class LoggingObserver implements IObserver {\n\tprivate count = 0;\n\n\tconstructor(public readonly debugName: string, private readonly log: Log) {\n\t}\n\n\tbeginUpdate<T>(observable: IObservable<T>): void {\n\t\tthis.count++;\n\t\tthis.log.log(`${this.debugName}.beginUpdate (count ${this.count})`);\n\t}\n\tendUpdate<T>(observable: IObservable<T>): void {\n\t\tthis.log.log(`${this.debugName}.endUpdate (count ${this.count})`);\n\t\tthis.count--;\n\t}\n\thandleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\tthis.log.log(`${this.debugName}.handleChange (count ${this.count})`);\n\t}\n\thandlePossibleChange<T>(observable: IObservable<T>): void {\n\t\tthis.log.log(`${this.debugName}.handlePossibleChange`);\n\t}\n}\n\nexport class LoggingObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprivate value: T;\n\n\tconstructor(\n\t\tpublic readonly debugName: string,\n\t\tinitialValue: T,\n\t\tprivate readonly logger: Log\n\t) {\n\t\tsuper(DebugLocation.ofCaller());\n\t\tthis.value = initialValue;\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.logger.log(`${this.debugName}.firstObserverAdded`);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.logger.log(`${this.debugName}.lastObserverRemoved`);\n\t}\n\n\tpublic get(): T {\n\t\tthis.logger.log(`${this.debugName}.get`);\n\t\treturn this.value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (this.value === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!tx) {\n\t\t\ttransaction((tx) => {\n\t\t\t\tthis.set(value, tx, change);\n\t\t\t}, () => `Setting ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.logger.log(`${this.debugName}.set (value ${value})`);\n\n\t\tthis.value = value;\n\n\t\tfor (const observer of this._observers) {\n\t\t\ttx.updateObserver(observer, this);\n\t\t\tobserver.handleChange(this, change);\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this.value}`;\n\t}\n}\n\nclass Log {\n\tprivate readonly entries: string[] = [];\n\tpublic log(message: string): void {\n\t\tthis.entries.push(message);\n\t}\n\n\tpublic getAndClearEntries(): string[] {\n\t\tconst entries = [...this.entries];\n\t\tthis.entries.length = 0;\n\t\treturn entries;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { setUnexpectedErrorHandler } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { DisposableStore, toDisposable } from '../../../common/lifecycle.js';\nimport { IDerivedReader, IObservableWithChange, autorun, autorunHandleChanges, autorunWithStoreHandleChanges, derived, derivedDisposable, IObservable, IObserver, ISettableObservable, ITransaction, keepObserved, observableFromEvent, observableSignal, observableValue, recordChanges, transaction, waitForState, derivedHandleChanges, runOnChange, DebugLocation } from '../../../common/observable.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../utils.js';\n// eslint-disable-next-line local/code-no-deep-import-of-internal\nimport { observableReducer } from '../../../common/observableInternal/experimental/reducer.js';\n// eslint-disable-next-line local/code-no-deep-import-of-internal\nimport { BaseObservable } from '../../../common/observableInternal/observables/baseObservable.js';\n\nsuite('observables', () => {\n\tconst ds = ensureNoDisposablesAreLeakedInTestSuite();\n\n\t/**\n\t * Reads these tests to understand how to use observables.\n\t */\n\tsuite('tutorial', () => {\n\t\ttest('observable + autorun', () => {\n\t\t\tconst log = new Log();\n\t\t\t// This creates a variable that stores a value and whose value changes can be observed.\n\t\t\t// The name is only used for debugging purposes.\n\t\t\t// The second arg is the initial value.\n\t\t\tconst myObservable = observableValue('myObservable', 0);\n\n\t\t\t// This creates an autorun: It runs immediately and then again whenever any of the\n\t\t\t// dependencies change. Dependencies are tracked by reading observables with the `reader` parameter.\n\t\t\t//\n\t\t\t// The @description is only used for debugging purposes.\n\t\t\t// The autorun has to be disposed! This is very important.\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\n\t\t\t\t// This code is run immediately.\n\n\t\t\t\t// Use the `reader` to read observable values and track the dependency to them.\n\t\t\t\t// If you use `observable.get()` instead of `observable.read(reader)`, you will just\n\t\t\t\t// get the value and not subscribe to it.\n\t\t\t\tlog.log(`myAutorun.run(myObservable: ${myObservable.read(reader)})`);\n\n\t\t\t\t// Now that all dependencies are tracked, the autorun is re-run whenever any of the\n\t\t\t\t// dependencies change.\n\t\t\t}));\n\t\t\t// The autorun runs immediately\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myAutorun.run(myObservable: 0)']);\n\n\t\t\t// We set the observable.\n\t\t\tmyObservable.set(1, undefined);\n\t\t\t// -> The autorun runs again when any read observable changed\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myAutorun.run(myObservable: 1)']);\n\n\t\t\t// We set the observable again.\n\t\t\tmyObservable.set(1, undefined);\n\t\t\t// -> The autorun does not run again, because the observable didn't change.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t// Transactions batch autorun runs\n\t\t\ttransaction((tx) => {\n\t\t\t\tmyObservable.set(2, tx);\n\t\t\t\t// No auto-run ran yet, even though the value changed!\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tmyObservable.set(3, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\t// Only at the end of the transaction the autorun re-runs\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myAutorun.run(myObservable: 3)']);\n\n\t\t\t// Note that the autorun did not see the intermediate value `2`!\n\t\t});\n\n\t\ttest('derived + autorun', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst observable1 = observableValue('myObservable1', 0);\n\t\t\tconst observable2 = observableValue('myObservable2', 0);\n\n\t\t\t// A derived value is an observable that is derived from other observables.\n\t\t\tconst myDerived = derived(reader => {\n\t\t\t\t/** @description myDerived */\n\t\t\t\tconst value1 = observable1.read(reader); // Use the reader to track dependencies.\n\t\t\t\tconst value2 = observable2.read(reader);\n\t\t\t\tconst sum = value1 + value2;\n\t\t\t\tlog.log(`myDerived.recompute: ${value1} + ${value2} = ${sum}`);\n\t\t\t\treturn sum;\n\t\t\t});\n\n\t\t\t// We create an autorun that reacts on changes to our derived value.\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\t\t\t\t// Autoruns work with observable values and deriveds - in short, they work with any observable.\n\t\t\t\tlog.log(`myAutorun(myDerived: ${myDerived.read(reader)})`);\n\t\t\t}));\n\t\t\t// autorun runs immediately\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: 0 + 0 = 0',\n\t\t\t\t'myAutorun(myDerived: 0)',\n\t\t\t]);\n\n\t\t\tobservable1.set(1, undefined);\n\t\t\t// and on changes...\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: 1 + 0 = 1',\n\t\t\t\t'myAutorun(myDerived: 1)',\n\t\t\t]);\n\n\t\t\tobservable2.set(1, undefined);\n\t\t\t// ... of any dependency.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: 1 + 1 = 2',\n\t\t\t\t'myAutorun(myDerived: 2)',\n\t\t\t]);\n\n\t\t\t// Now we change multiple observables in a transaction to batch process the effects.\n\t\t\ttransaction((tx) => {\n\t\t\t\tobservable1.set(5, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tobservable2.set(5, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\t// When changing multiple observables in a transaction,\n\t\t\t// deriveds are only recomputed on demand.\n\t\t\t// (Note that you cannot see the intermediate value when `obs1 == 5` and `obs2 == 1`)\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: 5 + 5 = 10',\n\t\t\t\t'myAutorun(myDerived: 10)',\n\t\t\t]);\n\n\t\t\ttransaction((tx) => {\n\t\t\t\tobservable1.set(6, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tobservable2.set(4, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\t// Now the autorun didn't run again, because its dependency changed from 10 to 10 (= no change).\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), (['myDerived.recompute: 6 + 4 = 10']));\n\t\t});\n\n\t\ttest('read during transaction', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst observable1 = observableValue('myObservable1', 0);\n\t\t\tconst observable2 = observableValue('myObservable2', 0);\n\n\t\t\tconst myDerived = derived((reader) => {\n\t\t\t\t/** @description myDerived */\n\t\t\t\tconst value1 = observable1.read(reader);\n\t\t\t\tconst value2 = observable2.read(reader);\n\t\t\t\tconst sum = value1 + value2;\n\t\t\t\tlog.log(`myDerived.recompute: ${value1} + ${value2} = ${sum}`);\n\t\t\t\treturn sum;\n\t\t\t});\n\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\t\t\t\tlog.log(`myAutorun(myDerived: ${myDerived.read(reader)})`);\n\t\t\t}));\n\t\t\t// autorun runs immediately\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: 0 + 0 = 0',\n\t\t\t\t'myAutorun(myDerived: 0)',\n\t\t\t]);\n\n\t\t\ttransaction((tx) => {\n\t\t\t\tobservable1.set(-10, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tmyDerived.get(); // This forces a (sync) recomputation of the current value!\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), (['myDerived.recompute: -10 + 0 = -10']));\n\t\t\t\t// This means, that even in transactions you can assume that all values you can read with `get` and `read` are up-to-date.\n\t\t\t\t// Read these values just might cause additional (potentially unneeded) recomputations.\n\n\t\t\t\tobservable2.set(10, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\t// This autorun runs again, because its dependency changed from 0 to -10 and then back to 0.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.recompute: -10 + 10 = 0',\n\t\t\t\t'myAutorun(myDerived: 0)',\n\t\t\t]);\n\t\t});\n\n\t\ttest('get without observers', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst observable1 = observableValue('myObservableValue1', 0);\n\n\t\t\t// We set up some computeds.\n\t\t\tconst computed1 = derived((reader) => {\n\t\t\t\t/** @description computed */\n\t\t\t\tconst value1 = observable1.read(reader);\n\t\t\t\tconst result = value1 % 3;\n\t\t\t\tlog.log(`recompute1: ${value1} % 3 = ${result}`);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\tconst computed2 = derived((reader) => {\n\t\t\t\t/** @description computed */\n\t\t\t\tconst value1 = computed1.read(reader);\n\t\t\t\tconst result = value1 * 2;\n\t\t\t\tlog.log(`recompute2: ${value1} * 2 = ${result}`);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\tconst computed3 = derived((reader) => {\n\t\t\t\t/** @description computed */\n\t\t\t\tconst value1 = computed1.read(reader);\n\t\t\t\tconst result = value1 * 3;\n\t\t\t\tlog.log(`recompute3: ${value1} * 3 = ${result}`);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\tconst computedSum = derived((reader) => {\n\t\t\t\t/** @description computed */\n\t\t\t\tconst value1 = computed2.read(reader);\n\t\t\t\tconst value2 = computed3.read(reader);\n\t\t\t\tconst result = value1 + value2;\n\t\t\t\tlog.log(`recompute4: ${value1} + ${value2} = ${result}`);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\tobservable1.set(1, undefined);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t// And now read the computed that dependens on all the others.\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 1 % 3 = 1',\n\t\t\t\t'recompute2: 1 * 2 = 2',\n\t\t\t\t'recompute3: 1 * 3 = 3',\n\t\t\t\t'recompute4: 2 + 3 = 5',\n\t\t\t\t'value: 5',\n\t\t\t]);\n\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\t// Because there are no observers, the derived values are not cached (!), but computed from scratch.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 1 % 3 = 1',\n\t\t\t\t'recompute2: 1 * 2 = 2',\n\t\t\t\t'recompute3: 1 * 3 = 3',\n\t\t\t\t'recompute4: 2 + 3 = 5',\n\t\t\t\t'value: 5',\n\t\t\t]);\n\n\t\t\tconst disposable = keepObserved(computedSum); // Use keepObserved to keep the cache.\n\t\t\t// You can also use `computedSum.keepObserved(store)` for an inline experience.\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 1 % 3 = 1',\n\t\t\t\t'recompute2: 1 * 2 = 2',\n\t\t\t\t'recompute3: 1 * 3 = 3',\n\t\t\t\t'recompute4: 2 + 3 = 5',\n\t\t\t\t'value: 5',\n\t\t\t]);\n\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'value: 5',\n\t\t\t]);\n\t\t\t// Tada, no recomputations!\n\n\t\t\tobservable1.set(2, undefined);\n\t\t\t// The keepObserved does not force deriveds to be recomputed! They are still lazy.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\t// Those deriveds are recomputed on demand, i.e. when someone reads them.\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 2 % 3 = 2',\n\t\t\t\t'recompute2: 2 * 2 = 4',\n\t\t\t\t'recompute3: 2 * 3 = 6',\n\t\t\t\t'recompute4: 4 + 6 = 10',\n\t\t\t\t'value: 10',\n\t\t\t]);\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\t// ... and then cached again\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), (['value: 10']));\n\n\t\t\tdisposable.dispose(); // Don't forget to dispose the keepAlive to prevent memory leaks!\n\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\t// Which disables the cache again\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 2 % 3 = 2',\n\t\t\t\t'recompute2: 2 * 2 = 4',\n\t\t\t\t'recompute3: 2 * 3 = 6',\n\t\t\t\t'recompute4: 4 + 6 = 10',\n\t\t\t\t'value: 10',\n\t\t\t]);\n\n\t\t\tlog.log(`value: ${computedSum.get()}`);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'recompute1: 2 % 3 = 2',\n\t\t\t\t'recompute2: 2 * 2 = 4',\n\t\t\t\t'recompute3: 2 * 3 = 6',\n\t\t\t\t'recompute4: 4 + 6 = 10',\n\t\t\t\t'value: 10',\n\t\t\t]);\n\n\t\t\t// Why don't we just always keep the cache alive?\n\t\t\t// This is because in order to keep the cache alive, we have to keep our subscriptions to our dependencies alive,\n\t\t\t// which could cause memory-leaks.\n\t\t\t// So instead, when the last observer of a derived is disposed, we dispose our subscriptions to our dependencies.\n\t\t\t// `keepObserved` just prevents this from happening.\n\t\t});\n\n\t\ttest('autorun that receives deltas of signals', () => {\n\t\t\tconst log = new Log();\n\n\t\t\t// A signal is an observable without a value.\n\t\t\t// However, it can ship change information when it is triggered.\n\t\t\t// Readers can process/aggregate this change information.\n\t\t\tconst signal = observableSignal<{ msg: string }>('signal');\n\n\t\t\tconst disposable = autorunHandleChanges({\n\t\t\t\tchangeTracker: {\n\t\t\t\t\t// The change summary is used to collect the changes\n\t\t\t\t\tcreateChangeSummary: () => ({ msgs: [] as string[] }),\n\t\t\t\t\thandleChange(context, changeSummary) {\n\t\t\t\t\t\tif (context.didChange(signal)) {\n\t\t\t\t\t\t\t// We just push the changes into an array\n\t\t\t\t\t\t\tchangeSummary.msgs.push(context.change.msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true; // We want to handle the change\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}, (reader, changeSummary) => {\n\t\t\t\t// When handling the change, make sure to read the signal!\n\t\t\t\tsignal.read(reader);\n\t\t\t\tlog.log('msgs: ' + changeSummary.msgs.join(', '));\n\t\t\t});\n\n\n\t\t\tsignal.trigger(undefined, { msg: 'foobar' });\n\n\t\t\ttransaction(tx => {\n\t\t\t\t// You can batch triggering signals.\n\t\t\t\t// No delta information is lost!\n\t\t\t\tsignal.trigger(tx, { msg: 'hello' });\n\t\t\t\tsignal.trigger(tx, { msg: 'world' });\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'msgs: ',\n\t\t\t\t'msgs: foobar',\n\t\t\t\t'msgs: hello, world'\n\t\t\t]);\n\n\t\t\tdisposable.dispose();\n\t\t});\n\n\t\t// That is the end of the tutorial.\n\t\t// There are lots of utilities you can explore now, like `observableFromEvent`, `Event.fromObservableLight`,\n\t\t// autorunWithStore, observableWithStore and so on.\n\t});\n\n\ttest('topological order', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable1 = observableValue('myObservable1', 0);\n\t\tconst myObservable2 = observableValue('myObservable2', 0);\n\n\t\tconst myComputed1 = derived(reader => {\n\t\t\t/** @description myComputed1 */\n\t\t\tconst value1 = myObservable1.read(reader);\n\t\t\tconst value2 = myObservable2.read(reader);\n\t\t\tconst sum = value1 + value2;\n\t\t\tlog.log(`myComputed1.recompute(myObservable1: ${value1} + myObservable2: ${value2} = ${sum})`);\n\t\t\treturn sum;\n\t\t});\n\n\t\tconst myComputed2 = derived(reader => {\n\t\t\t/** @description myComputed2 */\n\t\t\tconst value1 = myComputed1.read(reader);\n\t\t\tconst value2 = myObservable1.read(reader);\n\t\t\tconst value3 = myObservable2.read(reader);\n\t\t\tconst sum = value1 + value2 + value3;\n\t\t\tlog.log(`myComputed2.recompute(myComputed1: ${value1} + myObservable1: ${value2} + myObservable2: ${value3} = ${sum})`);\n\t\t\treturn sum;\n\t\t});\n\n\t\tconst myComputed3 = derived(reader => {\n\t\t\t/** @description myComputed3 */\n\t\t\tconst value1 = myComputed2.read(reader);\n\t\t\tconst value2 = myObservable1.read(reader);\n\t\t\tconst value3 = myObservable2.read(reader);\n\t\t\tconst sum = value1 + value2 + value3;\n\t\t\tlog.log(`myComputed3.recompute(myComputed2: ${value1} + myObservable1: ${value2} + myObservable2: ${value3} = ${sum})`);\n\t\t\treturn sum;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tlog.log(`myAutorun.run(myComputed3: ${myComputed3.read(reader)})`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myComputed1.recompute(myObservable1: 0 + myObservable2: 0 = 0)',\n\t\t\t'myComputed2.recompute(myComputed1: 0 + myObservable1: 0 + myObservable2: 0 = 0)',\n\t\t\t'myComputed3.recompute(myComputed2: 0 + myObservable1: 0 + myObservable2: 0 = 0)',\n\t\t\t'myAutorun.run(myComputed3: 0)',\n\t\t]);\n\n\t\tmyObservable1.set(1, undefined);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myComputed1.recompute(myObservable1: 1 + myObservable2: 0 = 1)',\n\t\t\t'myComputed2.recompute(myComputed1: 1 + myObservable1: 1 + myObservable2: 0 = 2)',\n\t\t\t'myComputed3.recompute(myComputed2: 2 + myObservable1: 1 + myObservable2: 0 = 3)',\n\t\t\t'myAutorun.run(myComputed3: 3)',\n\t\t]);\n\n\t\ttransaction((tx) => {\n\t\t\tmyObservable1.set(2, tx);\n\t\t\tmyComputed2.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myComputed1.recompute(myObservable1: 2 + myObservable2: 0 = 2)',\n\t\t\t\t'myComputed2.recompute(myComputed1: 2 + myObservable1: 2 + myObservable2: 0 = 4)',\n\t\t\t]);\n\n\t\t\tmyObservable1.set(3, tx);\n\t\t\tmyComputed2.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myComputed1.recompute(myObservable1: 3 + myObservable2: 0 = 3)',\n\t\t\t\t'myComputed2.recompute(myComputed1: 3 + myObservable1: 3 + myObservable2: 0 = 6)',\n\t\t\t]);\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myComputed3.recompute(myComputed2: 6 + myObservable1: 3 + myObservable2: 0 = 9)',\n\t\t\t'myAutorun.run(myComputed3: 9)',\n\t\t]);\n\t});\n\n\tsuite('from event', () => {\n\n\t\tfunction init(): { log: Log; setValue: (value: number | undefined) => void; observable: IObservable<number | undefined> } {\n\t\t\tconst log = new Log();\n\n\t\t\tlet value: number | undefined = 0;\n\t\t\tconst eventEmitter = new Emitter<void>();\n\n\t\t\tlet id = 0;\n\t\t\tconst observable = observableFromEvent(\n\t\t\t\t(handler) => {\n\t\t\t\t\tconst curId = id++;\n\t\t\t\t\tlog.log(`subscribed handler ${curId}`);\n\t\t\t\t\tconst disposable = eventEmitter.event(handler);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdispose: () => {\n\t\t\t\t\t\t\tlog.log(`unsubscribed handler ${curId}`);\n\t\t\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tlog.log(`compute value ${value}`);\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tlog,\n\t\t\t\tsetValue: (newValue) => {\n\t\t\t\t\tvalue = newValue;\n\t\t\t\t\teventEmitter.fire();\n\t\t\t\t},\n\t\t\t\tobservable,\n\t\t\t};\n\t\t}\n\n\t\ttest('Handle undefined', () => {\n\t\t\tconst { log, setValue, observable } = init();\n\n\t\t\tsetValue(undefined);\n\n\t\t\tconst autorunDisposable = autorun(reader => {\n\t\t\t\t/** @description MyAutorun */\n\t\t\t\tobservable.read(reader);\n\t\t\t\tlog.log(\n\t\t\t\t\t`autorun, value: ${observable.read(reader)}`\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'subscribed handler 0',\n\t\t\t\t'compute value undefined',\n\t\t\t\t'autorun, value: undefined',\n\t\t\t]);\n\n\t\t\tsetValue(1);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'compute value 1',\n\t\t\t\t'autorun, value: 1'\n\t\t\t]);\n\n\t\t\tautorunDisposable.dispose();\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'unsubscribed handler 0'\n\t\t\t]);\n\t\t});\n\n\t\ttest('basic', () => {\n\t\t\tconst { log, setValue, observable } = init();\n\n\t\t\tconst shouldReadObservable = observableValue('shouldReadObservable', true);\n\n\t\t\tconst autorunDisposable = autorun(reader => {\n\t\t\t\t/** @description MyAutorun */\n\t\t\t\tif (shouldReadObservable.read(reader)) {\n\t\t\t\t\tobservable.read(reader);\n\t\t\t\t\tlog.log(\n\t\t\t\t\t\t`autorun, should read: true, value: ${observable.read(reader)}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tlog.log(`autorun, should read: false`);\n\t\t\t\t}\n\t\t\t});\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'subscribed handler 0',\n\t\t\t\t'compute value 0',\n\t\t\t\t'autorun, should read: true, value: 0',\n\t\t\t]);\n\n\t\t\t// Cached get\n\t\t\tlog.log(`get value: ${observable.get()}`);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['get value: 0']);\n\n\t\t\tsetValue(1);\n\t\t\t// Trigger autorun, no unsub/sub\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'compute value 1',\n\t\t\t\t'autorun, should read: true, value: 1',\n\t\t\t]);\n\n\t\t\t// Unsubscribe when not read\n\t\t\tshouldReadObservable.set(false, undefined);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'autorun, should read: false',\n\t\t\t\t'unsubscribed handler 0',\n\t\t\t]);\n\n\t\t\tshouldReadObservable.set(true, undefined);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'subscribed handler 1',\n\t\t\t\t'compute value 1',\n\t\t\t\t'autorun, should read: true, value: 1',\n\t\t\t]);\n\n\t\t\tautorunDisposable.dispose();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'unsubscribed handler 1',\n\t\t\t]);\n\t\t});\n\n\t\ttest('get without observers', () => {\n\t\t\tconst { log, observable } = init();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\tlog.log(`get value: ${observable.get()}`);\n\t\t\t// Not cached or subscribed\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'compute value 0',\n\t\t\t\t'get value: 0',\n\t\t\t]);\n\n\t\t\tlog.log(`get value: ${observable.get()}`);\n\t\t\t// Still not cached or subscribed\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'compute value 0',\n\t\t\t\t'get value: 0',\n\t\t\t]);\n\t\t});\n\t});\n\n\ttest('reading derived in transaction unsubscribes unnecessary observables', () => {\n\t\tconst log = new Log();\n\n\t\tconst shouldReadObservable = observableValue('shouldReadMyObs1', true);\n\t\tconst myObs1 = new LoggingObservableValue('myObs1', 0, log);\n\t\tconst myComputed = derived(reader => {\n\t\t\t/** @description myComputed */\n\t\t\tlog.log('myComputed.recompute');\n\t\t\tif (shouldReadObservable.read(reader)) {\n\t\t\t\treturn myObs1.read(reader);\n\t\t\t}\n\t\t\treturn 1;\n\t\t});\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst value = myComputed.read(reader);\n\t\t\tlog.log(`myAutorun: ${value}`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myComputed.recompute',\n\t\t\t'myObs1.firstObserverAdded',\n\t\t\t'myObs1.get',\n\t\t\t'myAutorun: 0',\n\t\t]);\n\n\t\ttransaction(tx => {\n\t\t\tmyObs1.set(1, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), (['myObs1.set (value 1)']));\n\n\t\t\tshouldReadObservable.set(false, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\t\tmyComputed.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myComputed.recompute',\n\t\t\t\t'myObs1.lastObserverRemoved',\n\t\t\t]);\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), (['myAutorun: 1']));\n\t});\n\n\ttest('avoid recomputation of deriveds that are no longer read', () => {\n\t\tconst log = new Log();\n\n\t\tconst myObsShouldRead = new LoggingObservableValue('myObsShouldRead', true, log);\n\t\tconst myObs1 = new LoggingObservableValue('myObs1', 0, log);\n\n\t\tconst myComputed1 = derived(reader => {\n\t\t\t/** @description myComputed1 */\n\t\t\tconst myObs1Val = myObs1.read(reader);\n\t\t\tconst result = myObs1Val % 10;\n\t\t\tlog.log(`myComputed1(myObs1: ${myObs1Val}): Computed ${result}`);\n\t\t\treturn myObs1Val;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst shouldRead = myObsShouldRead.read(reader);\n\t\t\tif (shouldRead) {\n\t\t\t\tconst v = myComputed1.read(reader);\n\t\t\t\tlog.log(`myAutorun(shouldRead: true, myComputed1: ${v}): run`);\n\t\t\t} else {\n\t\t\t\tlog.log(`myAutorun(shouldRead: false): run`);\n\t\t\t}\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObsShouldRead.firstObserverAdded',\n\t\t\t'myObsShouldRead.get',\n\t\t\t'myObs1.firstObserverAdded',\n\t\t\t'myObs1.get',\n\t\t\t'myComputed1(myObs1: 0): Computed 0',\n\t\t\t'myAutorun(shouldRead: true, myComputed1: 0): run',\n\t\t]);\n\n\t\ttransaction(tx => {\n\t\t\tmyObsShouldRead.set(false, tx);\n\t\t\tmyObs1.set(1, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObsShouldRead.set (value false)',\n\t\t\t\t'myObs1.set (value 1)',\n\t\t\t]);\n\t\t});\n\t\t// myComputed1 should not be recomputed here, even though its dependency myObs1 changed!\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObsShouldRead.get',\n\t\t\t'myAutorun(shouldRead: false): run',\n\t\t\t'myObs1.lastObserverRemoved',\n\t\t]);\n\n\t\ttransaction(tx => {\n\t\t\tmyObsShouldRead.set(true, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObsShouldRead.set (value true)',\n\t\t\t]);\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObsShouldRead.get',\n\t\t\t'myObs1.firstObserverAdded',\n\t\t\t'myObs1.get',\n\t\t\t'myComputed1(myObs1: 1): Computed 1',\n\t\t\t'myAutorun(shouldRead: true, myComputed1: 1): run',\n\t\t]);\n\t});\n\n\tsuite('autorun rerun on neutral change', () => {\n\t\ttest('autorun reruns on neutral observable double change', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = observableValue('myObservable', 0);\n\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\t\t\t\tlog.log(`myAutorun.run(myObservable: ${myObservable.read(reader)})`);\n\t\t\t}));\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myAutorun.run(myObservable: 0)']);\n\n\n\t\t\ttransaction((tx) => {\n\t\t\t\tmyObservable.set(2, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tmyObservable.set(0, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myAutorun.run(myObservable: 0)']);\n\t\t});\n\n\t\ttest('autorun does not rerun on indirect neutral observable double change', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = observableValue('myObservable', 0);\n\t\t\tconst myDerived = derived(reader => {\n\t\t\t\t/** @description myDerived */\n\t\t\t\tconst val = myObservable.read(reader);\n\t\t\t\tlog.log(`myDerived.read(myObservable: ${val})`);\n\t\t\t\treturn val;\n\t\t\t});\n\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\t\t\t\tlog.log(`myAutorun.run(myDerived: ${myDerived.read(reader)})`);\n\t\t\t}));\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.read(myObservable: 0)',\n\t\t\t\t'myAutorun.run(myDerived: 0)'\n\t\t\t]);\n\n\t\t\ttransaction((tx) => {\n\t\t\t\tmyObservable.set(2, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tmyObservable.set(0, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.read(myObservable: 0)'\n\t\t\t]);\n\t\t});\n\n\t\ttest('autorun reruns on indirect neutral observable double change when changes propagate', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = observableValue('myObservable', 0);\n\t\t\tconst myDerived = derived(reader => {\n\t\t\t\t/** @description myDerived */\n\t\t\t\tconst val = myObservable.read(reader);\n\t\t\t\tlog.log(`myDerived.read(myObservable: ${val})`);\n\t\t\t\treturn val;\n\t\t\t});\n\n\t\t\tds.add(autorun(reader => {\n\t\t\t\t/** @description myAutorun */\n\t\t\t\tlog.log(`myAutorun.run(myDerived: ${myDerived.read(reader)})`);\n\t\t\t}));\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.read(myObservable: 0)',\n\t\t\t\t'myAutorun.run(myDerived: 0)'\n\t\t\t]);\n\n\t\t\ttransaction((tx) => {\n\t\t\t\tmyObservable.set(2, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\t\tmyDerived.get(); // This marks the auto-run as changed\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t\t'myDerived.read(myObservable: 2)'\n\t\t\t\t]);\n\n\t\t\t\tmyObservable.set(0, tx);\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\t});\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myDerived.read(myObservable: 0)',\n\t\t\t\t'myAutorun.run(myDerived: 0)'\n\t\t\t]);\n\t\t});\n\t});\n\n\ttest('self-disposing autorun', () => {\n\t\tconst log = new Log();\n\n\t\tconst observable1 = new LoggingObservableValue('myObservable1', 0, log);\n\t\tconst myObservable2 = new LoggingObservableValue('myObservable2', 0, log);\n\t\tconst myObservable3 = new LoggingObservableValue('myObservable3', 0, log);\n\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description autorun */\n\t\t\tif (observable1.read(reader) >= 2) {\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t\t'myObservable1.set (value 2)',\n\t\t\t\t\t'myObservable1.get',\n\t\t\t\t]);\n\n\t\t\t\tmyObservable2.read(reader);\n\t\t\t\t// First time this observable is read\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t\t'myObservable2.firstObserverAdded',\n\t\t\t\t\t'myObservable2.get',\n\t\t\t\t]);\n\n\t\t\t\td.dispose();\n\t\t\t\t// Disposing removes all observers\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t\t'myObservable1.lastObserverRemoved',\n\t\t\t\t\t'myObservable2.lastObserverRemoved',\n\t\t\t\t]);\n\n\t\t\t\tmyObservable3.read(reader);\n\t\t\t\t// This does not subscribe the observable, because the autorun is disposed\n\t\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t\t'myObservable3.get',\n\t\t\t\t]);\n\t\t\t}\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable1.firstObserverAdded',\n\t\t\t'myObservable1.get',\n\t\t]);\n\n\t\tobservable1.set(1, undefined);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable1.set (value 1)',\n\t\t\t'myObservable1.get',\n\t\t]);\n\n\t\tobservable1.set(2, undefined);\n\t\t// See asserts in the autorun\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\t});\n\n\ttest('changing observables in endUpdate', () => {\n\t\tconst log = new Log();\n\n\t\tconst myObservable1 = new LoggingObservableValue('myObservable1', 0, log);\n\t\tconst myObservable2 = new LoggingObservableValue('myObservable2', 0, log);\n\n\t\tconst myDerived1 = derived(reader => {\n\t\t\t/** @description myDerived1 */\n\t\t\tconst val = myObservable1.read(reader);\n\t\t\tlog.log(`myDerived1.read(myObservable: ${val})`);\n\t\t\treturn val;\n\t\t});\n\n\t\tconst myDerived2 = derived(reader => {\n\t\t\t/** @description myDerived2 */\n\t\t\tconst val = myObservable2.read(reader);\n\t\t\tif (val === 1) {\n\t\t\t\tmyDerived1.read(reader);\n\t\t\t}\n\t\t\tlog.log(`myDerived2.read(myObservable: ${val})`);\n\t\t\treturn val;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst myDerived1Val = myDerived1.read(reader);\n\t\t\tconst myDerived2Val = myDerived2.read(reader);\n\t\t\tlog.log(`myAutorun.run(myDerived1: ${myDerived1Val}, myDerived2: ${myDerived2Val})`);\n\t\t}));\n\n\t\ttransaction(tx => {\n\t\t\tmyObservable2.set(1, tx);\n\t\t\t// end update of this observable will trigger endUpdate of myDerived1 and\n\t\t\t// the autorun and the autorun will add myDerived2 as observer to myDerived1\n\t\t\tmyObservable1.set(1, tx);\n\t\t});\n\t});\n\n\ttest('set dependency in derived', () => {\n\t\tconst log = new Log();\n\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\t\tconst myComputed = derived(reader => {\n\t\t\t/** @description myComputed */\n\t\t\tlet value = myObservable.read(reader);\n\t\t\tconst origValue = value;\n\t\t\tlog.log(`myComputed(myObservable: ${origValue}): start computing`);\n\t\t\tif (value % 3 !== 0) {\n\t\t\t\tvalue++;\n\t\t\t\tmyObservable.set(value, undefined);\n\t\t\t}\n\t\t\tlog.log(`myComputed(myObservable: ${origValue}): finished computing`);\n\t\t\treturn value;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst value = myComputed.read(reader);\n\t\t\tlog.log(`myAutorun(myComputed: ${value})`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'myComputed(myObservable: 0): start computing',\n\t\t\t'myComputed(myObservable: 0): finished computing',\n\t\t\t'myAutorun(myComputed: 0)'\n\t\t]);\n\n\t\tmyObservable.set(1, undefined);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.set (value 1)',\n\t\t\t'myObservable.get',\n\t\t\t'myComputed(myObservable: 1): start computing',\n\t\t\t'myObservable.set (value 2)',\n\t\t\t'myComputed(myObservable: 1): finished computing',\n\t\t\t'myObservable.get',\n\t\t\t'myComputed(myObservable: 2): start computing',\n\t\t\t'myObservable.set (value 3)',\n\t\t\t'myComputed(myObservable: 2): finished computing',\n\t\t\t'myObservable.get',\n\t\t\t'myComputed(myObservable: 3): start computing',\n\t\t\t'myComputed(myObservable: 3): finished computing',\n\t\t\t'myAutorun(myComputed: 3)',\n\t\t]);\n\t});\n\n\ttest('set dependency in autorun', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst value = myObservable.read(reader);\n\t\t\tlog.log(`myAutorun(myObservable: ${value}): start`);\n\t\t\tif (value !== 0 && value < 4) {\n\t\t\t\tmyObservable.set(value + 1, undefined);\n\t\t\t}\n\t\t\tlog.log(`myAutorun(myObservable: ${value}): end`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'myAutorun(myObservable: 0): start',\n\t\t\t'myAutorun(myObservable: 0): end',\n\t\t]);\n\n\t\tmyObservable.set(1, undefined);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.set (value 1)',\n\t\t\t'myObservable.get',\n\t\t\t'myAutorun(myObservable: 1): start',\n\t\t\t'myObservable.set (value 2)',\n\t\t\t'myAutorun(myObservable: 1): end',\n\t\t\t'myObservable.get',\n\t\t\t'myAutorun(myObservable: 2): start',\n\t\t\t'myObservable.set (value 3)',\n\t\t\t'myAutorun(myObservable: 2): end',\n\t\t\t'myObservable.get',\n\t\t\t'myAutorun(myObservable: 3): start',\n\t\t\t'myObservable.set (value 4)',\n\t\t\t'myAutorun(myObservable: 3): end',\n\t\t\t'myObservable.get',\n\t\t\t'myAutorun(myObservable: 4): start',\n\t\t\t'myAutorun(myObservable: 4): end',\n\t\t]);\n\t});\n\n\ttest('get in transaction between sets', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\tconst myDerived1 = derived(reader => {\n\t\t\t/** @description myDerived1 */\n\t\t\tconst value = myObservable.read(reader);\n\t\t\tlog.log(`myDerived1(myObservable: ${value}): start computing`);\n\t\t\treturn value;\n\t\t});\n\n\t\tconst myDerived2 = derived(reader => {\n\t\t\t/** @description myDerived2 */\n\t\t\tconst value = myDerived1.read(reader);\n\t\t\tlog.log(`myDerived2(myDerived1: ${value}): start computing`);\n\t\t\treturn value;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst value = myDerived2.read(reader);\n\t\t\tlog.log(`myAutorun(myDerived2: ${value})`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'myDerived1(myObservable: 0): start computing',\n\t\t\t'myDerived2(myDerived1: 0): start computing',\n\t\t\t'myAutorun(myDerived2: 0)',\n\t\t]);\n\n\t\ttransaction(tx => {\n\t\t\tmyObservable.set(1, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value 1)',\n\t\t\t]);\n\n\t\t\tmyDerived2.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.get',\n\t\t\t\t'myDerived1(myObservable: 1): start computing',\n\t\t\t\t'myDerived2(myDerived1: 1): start computing',\n\t\t\t]);\n\n\t\t\tmyObservable.set(2, tx);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value 2)',\n\t\t\t]);\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.get',\n\t\t\t'myDerived1(myObservable: 2): start computing',\n\t\t\t'myDerived2(myDerived1: 2): start computing',\n\t\t\t'myAutorun(myDerived2: 2)',\n\t\t]);\n\t});\n\n\ttest('bug: Dont reset states', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable1 = new LoggingObservableValue('myObservable1', 0, log);\n\n\t\tconst myObservable2 = new LoggingObservableValue('myObservable2', 0, log);\n\t\tconst myDerived2 = derived(reader => {\n\t\t\t/** @description myDerived2 */\n\t\t\tconst val = myObservable2.read(reader);\n\t\t\tlog.log(`myDerived2.computed(myObservable2: ${val})`);\n\t\t\treturn val % 10;\n\t\t});\n\n\t\tconst myDerived3 = derived(reader => {\n\t\t\t/** @description myDerived3 */\n\t\t\tconst val1 = myObservable1.read(reader);\n\t\t\tconst val2 = myDerived2.read(reader);\n\t\t\tlog.log(`myDerived3.computed(myDerived1: ${val1}, myDerived2: ${val2})`);\n\t\t\treturn `${val1} + ${val2}`;\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun */\n\t\t\tconst val = myDerived3.read(reader);\n\t\t\tlog.log(`myAutorun(myDerived3: ${val})`);\n\t\t}));\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable1.firstObserverAdded',\n\t\t\t'myObservable1.get',\n\t\t\t'myObservable2.firstObserverAdded',\n\t\t\t'myObservable2.get',\n\t\t\t'myDerived2.computed(myObservable2: 0)',\n\t\t\t'myDerived3.computed(myDerived1: 0, myDerived2: 0)',\n\t\t\t'myAutorun(myDerived3: 0 + 0)',\n\t\t]);\n\n\t\ttransaction(tx => {\n\t\t\tmyObservable1.set(1, tx); // Mark myDerived 3 as stale\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable1.set (value 1)',\n\t\t\t]);\n\n\t\t\tmyObservable2.set(10, tx); // This is a non-change. myDerived3 should not be marked as possibly-depedency-changed!\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable2.set (value 10)',\n\t\t\t]);\n\t\t});\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable1.get',\n\t\t\t'myObservable2.get',\n\t\t\t'myDerived2.computed(myObservable2: 10)',\n\t\t\t'myDerived3.computed(myDerived1: 1, myDerived2: 0)',\n\t\t\t'myAutorun(myDerived3: 1 + 0)',\n\t\t]);\n\t});\n\n\ttest('bug: Add observable in endUpdate', () => {\n\t\tconst myObservable1 = observableValue('myObservable1', 0);\n\t\tconst myObservable2 = observableValue('myObservable2', 0);\n\n\t\tconst myDerived1 = derived(reader => {\n\t\t\t/** @description myDerived1 */\n\t\t\treturn myObservable1.read(reader);\n\t\t});\n\n\t\tconst myDerived2 = derived(reader => {\n\t\t\t/** @description myDerived2 */\n\t\t\treturn myObservable2.read(reader);\n\t\t});\n\n\t\tconst myDerivedA1 = derived(reader => /** @description myDerivedA1 */ {\n\t\t\tconst d1 = myDerived1.read(reader);\n\t\t\tif (d1 === 1) {\n\t\t\t\t// This adds an observer while myDerived is still in update mode.\n\t\t\t\t// When myDerived exits update mode, the observer shouldn't receive\n\t\t\t\t// more endUpdate than beginUpdate calls.\n\t\t\t\tmyDerived2.read(reader);\n\t\t\t}\n\t\t});\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun1 */\n\t\t\tmyDerivedA1.read(reader);\n\t\t}));\n\n\t\tds.add(autorun(reader => {\n\t\t\t/** @description myAutorun2 */\n\t\t\tmyDerived2.read(reader);\n\t\t}));\n\n\t\ttransaction(tx => {\n\t\t\tmyObservable1.set(1, tx);\n\t\t\tmyObservable2.set(1, tx);\n\t\t});\n\t});\n\n\ttest('bug: fromObservableLight doesnt subscribe', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\tconst myDerived = derived(reader => /** @description myDerived */ {\n\t\t\tconst val = myObservable.read(reader);\n\t\t\tlog.log(`myDerived.computed(myObservable2: ${val})`);\n\t\t\treturn val % 10;\n\t\t});\n\n\t\tconst e = Event.fromObservableLight(myDerived);\n\t\tlog.log('event created');\n\t\te(() => {\n\t\t\tlog.log('event fired');\n\t\t});\n\n\t\tmyObservable.set(1, undefined);\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'event created',\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'myDerived.computed(myObservable2: 0)',\n\t\t\t'myObservable.set (value 1)',\n\t\t\t'myObservable.get',\n\t\t\t'myDerived.computed(myObservable2: 1)',\n\t\t\t'event fired',\n\t\t]);\n\t});\n\n\ttest('bug: Event.fromObservable always should get events', () => {\n\t\tconst emitter = new Emitter();\n\t\tconst log = new Log();\n\t\tlet i = 0;\n\t\tconst obs = observableFromEvent(emitter.event, () => i);\n\n\t\ti++;\n\t\temitter.fire(1);\n\n\t\tconst evt2 = Event.fromObservable(obs);\n\t\tconst d = evt2(e => {\n\t\t\tlog.log(`event fired ${e}`);\n\t\t});\n\n\t\ti++;\n\t\temitter.fire(2);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['event fired 2']);\n\n\t\ti++;\n\t\temitter.fire(3);\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['event fired 3']);\n\n\t\td.dispose();\n\t});\n\n\ttest('dont run autorun after dispose', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description update */\n\t\t\tconst v = myObservable.read(reader);\n\t\t\tlog.log('autorun, myObservable:' + v);\n\t\t});\n\n\t\ttransaction(tx => {\n\t\t\tmyObservable.set(1, tx);\n\t\t\td.dispose();\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'autorun, myObservable:0',\n\t\t\t'myObservable.set (value 1)',\n\t\t\t'myObservable.lastObserverRemoved',\n\t\t]);\n\t});\n\n\tsuite('waitForState', () => {\n\t\ttest('resolve', async () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = new LoggingObservableValue('myObservable', { state: 'initializing' as 'initializing' | 'ready' | 'error' }, log);\n\n\t\t\tconst p = waitForState(myObservable, p => p.state === 'ready', p => p.state === 'error').then(r => {\n\t\t\t\tlog.log(`resolved ${JSON.stringify(r)}`);\n\t\t\t}, (err) => {\n\t\t\t\tlog.log(`rejected ${JSON.stringify(err)}`);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.firstObserverAdded',\n\t\t\t\t'myObservable.get',\n\t\t\t]);\n\n\t\t\tmyObservable.set({ state: 'ready' }, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value [object Object])',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'myObservable.lastObserverRemoved',\n\t\t\t]);\n\n\t\t\tawait p;\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'resolved {\\\"state\\\":\\\"ready\\\"}',\n\t\t\t]);\n\t\t});\n\n\t\ttest('resolveImmediate', async () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = new LoggingObservableValue('myObservable', { state: 'ready' as 'initializing' | 'ready' | 'error' }, log);\n\n\t\t\tconst p = waitForState(myObservable, p => p.state === 'ready', p => p.state === 'error').then(r => {\n\t\t\t\tlog.log(`resolved ${JSON.stringify(r)}`);\n\t\t\t}, (err) => {\n\t\t\t\tlog.log(`rejected ${JSON.stringify(err)}`);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.firstObserverAdded',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'myObservable.lastObserverRemoved',\n\t\t\t]);\n\n\t\t\tmyObservable.set({ state: 'error' }, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value [object Object])',\n\t\t\t]);\n\n\t\t\tawait p;\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'resolved {\\\"state\\\":\\\"ready\\\"}',\n\t\t\t]);\n\t\t});\n\n\t\ttest('reject', async () => {\n\t\t\tconst log = new Log();\n\t\t\tconst myObservable = new LoggingObservableValue('myObservable', { state: 'initializing' as 'initializing' | 'ready' | 'error' }, log);\n\n\t\t\tconst p = waitForState(myObservable, p => p.state === 'ready', p => p.state === 'error').then(r => {\n\t\t\t\tlog.log(`resolved ${JSON.stringify(r)}`);\n\t\t\t}, (err) => {\n\t\t\t\tlog.log(`rejected ${JSON.stringify(err)}`);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.firstObserverAdded',\n\t\t\t\t'myObservable.get',\n\t\t\t]);\n\n\t\t\tmyObservable.set({ state: 'error' }, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value [object Object])',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'myObservable.lastObserverRemoved',\n\t\t\t]);\n\n\t\t\tawait p;\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'rejected {\\\"state\\\":\\\"error\\\"}'\n\t\t\t]);\n\t\t});\n\n\t\ttest('derived as lazy', () => {\n\t\t\tconst store = new DisposableStore();\n\t\t\tconst log = new Log();\n\t\t\tlet i = 0;\n\t\t\tconst d = derivedDisposable(() => {\n\t\t\t\tconst id = i++;\n\t\t\t\tlog.log('myDerived ' + id);\n\t\t\t\treturn {\n\t\t\t\t\tdispose: () => log.log(`disposed ${id}`)\n\t\t\t\t};\n\t\t\t});\n\n\t\t\td.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myDerived 0', 'disposed 0']);\n\t\t\td.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myDerived 1', 'disposed 1']);\n\n\t\t\td.keepObserved(store);\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\t\t\td.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['myDerived 2']);\n\t\t\td.get();\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), []);\n\n\t\t\tstore.dispose();\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ['disposed 2']);\n\t\t});\n\t});\n\n\ttest('observableValue', () => {\n\t\tconst log = new Log();\n\t\tconst myObservable1 = observableValue<number>('myObservable1', 0);\n\t\tconst myObservable2 = observableValue<number, { message: string }>('myObservable2', 0);\n\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description update */\n\t\t\tconst v1 = myObservable1.read(reader);\n\t\t\tconst v2 = myObservable2.read(reader);\n\t\t\tlog.log('autorun, myObservable1:' + v1 + ', myObservable2:' + v2);\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'autorun, myObservable1:0, myObservable2:0'\n\t\t]);\n\n\t\t// Doesn't trigger the autorun, because no delta was provided and the value did not change\n\t\tmyObservable1.set(0, undefined);\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t]);\n\n\t\t// Triggers the autorun. The value did not change, but a delta value was provided\n\t\tmyObservable2.set(0, undefined, { message: 'change1' });\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'autorun, myObservable1:0, myObservable2:0'\n\t\t]);\n\n\t\td.dispose();\n\t});\n\n\tsuite('autorun error handling', () => {\n\t\ttest('immediate throw', () => {\n\t\t\tconst log = new Log();\n\n\t\t\tsetUnexpectedErrorHandler(e => {\n\t\t\t\tlog.log(`error: ${e.message}`);\n\t\t\t});\n\n\t\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\t\tconst d = autorun(reader => {\n\t\t\t\tmyObservable.read(reader);\n\t\t\t\tthrow new Error('foobar');\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.firstObserverAdded',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'error: foobar'\n\t\t\t]);\n\n\t\t\tmyObservable.set(1, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value 1)',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'error: foobar',\n\t\t\t]);\n\n\t\t\td.dispose();\n\t\t});\n\n\t\ttest('late throw', () => {\n\t\t\tconst log = new Log();\n\n\t\t\tsetUnexpectedErrorHandler(e => {\n\t\t\t\tlog.log(`error: ${e.message}`);\n\t\t\t});\n\n\t\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\t\tconst d = autorun(reader => {\n\t\t\t\tconst value = myObservable.read(reader);\n\t\t\t\tif (value >= 1) {\n\t\t\t\t\tthrow new Error('foobar');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.firstObserverAdded',\n\t\t\t\t'myObservable.get',\n\t\t\t]);\n\n\t\t\tmyObservable.set(1, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value 1)',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'error: foobar',\n\t\t\t]);\n\n\t\t\tmyObservable.set(2, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'myObservable.set (value 2)',\n\t\t\t\t'myObservable.get',\n\t\t\t\t'error: foobar',\n\t\t\t]);\n\n\t\t\td.dispose();\n\t\t});\n\t});\n\n\ttest('recomputeInitiallyAndOnChange should work when a dependency sets an observable', () => {\n\t\tconst store = new DisposableStore();\n\t\tconst log = new Log();\n\n\t\tconst myObservable = new LoggingObservableValue('myObservable', 0, log);\n\n\t\tlet shouldUpdate = true;\n\n\t\tconst myDerived = derived(reader => {\n\t\t\t/** @description myDerived */\n\n\t\t\tlog.log('myDerived.computed start');\n\n\t\t\tconst val = myObservable.read(reader);\n\n\t\t\tif (shouldUpdate) {\n\t\t\t\tshouldUpdate = false;\n\t\t\t\tmyObservable.set(1, undefined);\n\t\t\t}\n\n\t\t\tlog.log('myDerived.computed end');\n\n\t\t\treturn val;\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\tmyDerived.recomputeInitiallyAndOnChange(store, val => {\n\t\t\tlog.log(`recomputeInitiallyAndOnChange, myDerived: ${val}`);\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t'myDerived.computed start',\n\t\t\t'myObservable.firstObserverAdded',\n\t\t\t'myObservable.get',\n\t\t\t'myObservable.set (value 1)',\n\t\t\t'myDerived.computed end',\n\t\t\t'myDerived.computed start',\n\t\t\t'myObservable.get',\n\t\t\t'myDerived.computed end',\n\t\t\t'recomputeInitiallyAndOnChange, myDerived: 1',\n\t\t]);\n\n\t\tmyDerived.get();\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\tstore.dispose();\n\t});\n\n\tsuite('prevent invalid usage', () => {\n\t\tsuite('reading outside of compute function', () => {\n\t\t\ttest('derived', () => {\n\t\t\t\tlet fn: () => void = () => { };\n\n\t\t\t\tconst obs = observableValue('obs', 0);\n\t\t\t\tconst d = derived(reader => {\n\t\t\t\t\tfn = () => { obs.read(reader); };\n\t\t\t\t\treturn obs.read(reader);\n\t\t\t\t});\n\n\t\t\t\tconst disp = autorun(reader => {\n\t\t\t\t\td.read(reader);\n\t\t\t\t});\n\n\t\t\t\tassert.throws(() => {\n\t\t\t\t\tfn();\n\t\t\t\t});\n\n\t\t\t\tdisp.dispose();\n\t\t\t});\n\n\t\t\ttest('autorun', () => {\n\t\t\t\tlet fn: () => void = () => { };\n\n\t\t\t\tconst obs = observableValue('obs', 0);\n\t\t\t\tconst disp = autorun(reader => {\n\t\t\t\t\tfn = () => { obs.read(reader); };\n\t\t\t\t\tobs.read(reader);\n\t\t\t\t});\n\n\t\t\t\tassert.throws(() => {\n\t\t\t\t\tfn();\n\t\t\t\t});\n\n\t\t\t\tdisp.dispose();\n\t\t\t});\n\t\t});\n\n\t\ttest.skip('catches cyclic dependencies', () => {\n\t\t\tconst log = new Log();\n\n\t\t\tsetUnexpectedErrorHandler((e) => {\n\t\t\t\tlog.log(e.toString());\n\t\t\t});\n\n\t\t\tconst obs = observableValue('obs', 0);\n\t\t\tconst d1 = derived(reader => {\n\t\t\t\tlog.log('d1.computed start');\n\t\t\t\tconst x = obs.read(reader) + d2.read(reader);\n\t\t\t\tlog.log('d1.computed end');\n\t\t\t\treturn x;\n\t\t\t});\n\t\t\tconst d2 = derived(reader => {\n\t\t\t\tlog.log('d2.computed start');\n\t\t\t\td1.read(reader);\n\t\t\t\tlog.log('d2.computed end');\n\t\t\t\treturn 0;\n\t\t\t});\n\n\t\t\tconst disp = autorun(reader => {\n\t\t\t\tlog.log('autorun start');\n\t\t\t\td1.read(reader);\n\t\t\t\tlog.log('autorun end');\n\t\t\t\treturn 0;\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'autorun start',\n\t\t\t\t'd1.computed start',\n\t\t\t\t'd2.computed start',\n\t\t\t\t'Error: Cyclic deriveds are not supported yet!',\n\t\t\t\t'd1.computed end',\n\t\t\t\t'autorun end'\n\t\t\t]));\n\n\t\t\tdisp.dispose();\n\t\t});\n\t});\n\n\tsuite('observableReducer', () => {\n\t\ttest('main', () => {\n\t\t\tconst store = new DisposableStore();\n\t\t\tconst log = new Log();\n\n\t\t\tconst myObservable1 = observableValue<number, number>('myObservable1', 5);\n\t\t\tconst myObservable2 = observableValue<number, number>('myObservable2', 9);\n\n\t\t\tconst sum = observableReducer(this, {\n\t\t\t\tinitial: () => {\n\t\t\t\t\tlog.log('createInitial');\n\t\t\t\t\treturn myObservable1.get() + myObservable2.get();\n\t\t\t\t},\n\t\t\t\tdisposeFinal: (values) => {\n\t\t\t\t\tlog.log(`disposeFinal ${values}`);\n\t\t\t\t},\n\t\t\t\tchangeTracker: recordChanges({ myObservable1, myObservable2 }),\n\t\t\t\tupdate: (reader: IDerivedReader<number>, previousValue, changes) => {\n\t\t\t\t\tlog.log(`update ${JSON.stringify(changes)}`);\n\t\t\t\t\tlet delta = 0;\n\t\t\t\t\tfor (const change of changes.changes) {\n\t\t\t\t\t\tdelta += change.change;\n\t\t\t\t\t}\n\n\t\t\t\t\treader.reportChange(delta);\n\t\t\t\t\tconst resultValue = previousValue + delta;\n\t\t\t\t\tlog.log(`update -> ${resultValue}`);\n\t\t\t\t\treturn resultValue;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\t\tstore.add(autorunWithStoreHandleChanges({\n\t\t\t\tchangeTracker: recordChanges({ sum })\n\t\t\t}, (_reader, changes) => {\n\t\t\t\tlog.log(`autorun ${JSON.stringify(changes)}`);\n\t\t\t}));\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), [\n\t\t\t\t'createInitial',\n\t\t\t\t'update {\"changes\":[],\"myObservable1\":5,\"myObservable2\":9}',\n\t\t\t\t'update -> 14',\n\t\t\t\t'autorun {\"changes\":[],\"sum\":14}',\n\t\t\t]);\n\n\t\t\ttransaction(tx => {\n\t\t\t\tmyObservable1.set(myObservable1.get() + 1, tx, 1);\n\t\t\t\tmyObservable2.set(myObservable2.get() + 3, tx, 3);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'update {\"changes\":[{\"key\":\"myObservable1\",\"change\":1},{\"key\":\"myObservable2\",\"change\":3}],\"myObservable1\":6,\"myObservable2\":12}',\n\t\t\t\t'update -> 18',\n\t\t\t\t'autorun {\"changes\":[{\"key\":\"sum\",\"change\":4}],\"sum\":18}'\n\t\t\t]));\n\n\t\t\ttransaction(tx => {\n\t\t\t\tmyObservable1.set(myObservable1.get() + 1, tx, 1);\n\t\t\t\tconst s = sum.get();\n\t\t\t\tlog.log(`sum.get() ${s}`);\n\t\t\t\tmyObservable2.set(myObservable2.get() + 3, tx, 3);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'update {\"changes\":[{\"key\":\"myObservable1\",\"change\":1}],\"myObservable1\":7,\"myObservable2\":12}',\n\t\t\t\t'update -> 19',\n\t\t\t\t'sum.get() 19',\n\t\t\t\t'update {\"changes\":[{\"key\":\"myObservable2\",\"change\":3}],\"myObservable1\":7,\"myObservable2\":15}',\n\t\t\t\t'update -> 22',\n\t\t\t\t'autorun {\"changes\":[{\"key\":\"sum\",\"change\":1}],\"sum\":22}'\n\t\t\t]));\n\n\t\t\tstore.dispose();\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'disposeFinal 22'\n\t\t\t]));\n\t\t});\n\t});\n\n\tsuite('disposableStores', () => {\n\t\ttest('derived with store', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst observable1 = observableValue('myObservableValue1', 0);\n\n\t\t\tconst computed1 = derived((reader) => {\n\t\t\t\tconst value = observable1.read(reader);\n\t\t\t\tlog.log(`computed ${value}`);\n\t\t\t\treader.store.add(toDisposable(() => {\n\t\t\t\t\tlog.log(`computed1: ${value} disposed`);\n\t\t\t\t}));\n\t\t\t\treturn value;\n\t\t\t});\n\n\t\t\tconst a = autorun(reader => {\n\t\t\t\tlog.log(`a: ${computed1.read(reader)}`);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed 0',\n\t\t\t\t'a: 0'\n\t\t\t]));\n\n\t\t\tobservable1.set(1, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed1: 0 disposed',\n\t\t\t\t'computed 1',\n\t\t\t\t'a: 1'\n\t\t\t]));\n\n\t\t\ta.dispose();\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed1: 1 disposed'\n\t\t\t]));\n\t\t});\n\n\t\ttest('derived with delayedStore', () => {\n\t\t\tconst log = new Log();\n\t\t\tconst observable1 = observableValue('myObservableValue1', 0);\n\n\t\t\tconst computed1 = derived((reader) => {\n\t\t\t\tconst value = observable1.read(reader);\n\t\t\t\tlog.log(`computed ${value}`);\n\t\t\t\treader.delayedStore.add(toDisposable(() => {\n\t\t\t\t\tlog.log(`computed1: ${value} disposed`);\n\t\t\t\t}));\n\t\t\t\treturn value;\n\t\t\t});\n\n\t\t\tconst a = autorun(reader => {\n\t\t\t\tlog.log(`a: ${computed1.read(reader)}`);\n\t\t\t});\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed 0',\n\t\t\t\t'a: 0'\n\t\t\t]));\n\n\t\t\tobservable1.set(1, undefined);\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed 1',\n\t\t\t\t'computed1: 0 disposed',\n\t\t\t\t'a: 1'\n\t\t\t]));\n\n\t\t\ta.dispose();\n\n\t\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t\t'computed1: 1 disposed'\n\t\t\t]));\n\t\t});\n\t});\n\n\ttest('derivedHandleChanges with reportChanges', () => {\n\t\tconst log = new Log();\n\n\t\tconst signal1 = observableSignal<{ message: string }>('signal1');\n\t\tconst signal2 = observableSignal<{ message: string }>('signal2');\n\n\t\tconst signal2Derived = derivedHandleChanges(\n\t\t\t{ changeTracker: recordChanges({ signal2 }) },\n\t\t\t(reader: IDerivedReader<{ message: string }>, changeSummary) => {\n\t\t\t\tfor (const c of changeSummary.changes) {\n\t\t\t\t\treader.reportChange({ message: c.change.message + ' (derived)' });\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tconst d = derivedHandleChanges({\n\t\t\tchangeTracker: recordChanges({ signal1, signal2Derived }),\n\t\t}, (r: IDerivedReader<string>, changes) => {\n\t\t\tconst log = changes.changes.map(c => `${c.key}: ${c.change.message}`).join(', ');\n\t\t\tr.reportChange(log);\n\t\t});\n\n\t\tconst disp = runOnChange(d, (_val, _prev, changes) => {\n\t\t\tlog.log(`runOnChange ${JSON.stringify(changes)}`);\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([]));\n\n\t\ttransaction(tx => {\n\t\t\tsignal1.trigger(tx, { message: 'foo' });\n\t\t\tsignal2.trigger(tx, { message: 'bar' });\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t'runOnChange [\"signal1: foo, signal2Derived: bar (derived)\"]'\n\t\t]));\n\n\n\t\ttransaction(tx => {\n\t\t\tsignal2.trigger(tx, { message: 'baz' });\n\t\t});\n\n\t\tassert.deepStrictEqual(log.getAndClearEntries(), ([\n\t\t\t'runOnChange [\"signal2Derived: baz (derived)\"]'\n\t\t]));\n\n\t\tdisp.dispose();\n\t});\n});\n\nexport class LoggingObserver implements IObserver {\n\tprivate count = 0;\n\n\tconstructor(public readonly debugName: string, private readonly log: Log) {\n\t}\n\n\tbeginUpdate<T>(observable: IObservable<T>): void {\n\t\tthis.count++;\n\t\tthis.log.log(`${this.debugName}.beginUpdate (count ${this.count})`);\n\t}\n\tendUpdate<T>(observable: IObservable<T>): void {\n\t\tthis.log.log(`${this.debugName}.endUpdate (count ${this.count})`);\n\t\tthis.count--;\n\t}\n\thandleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\tthis.log.log(`${this.debugName}.handleChange (count ${this.count})`);\n\t}\n\thandlePossibleChange<T>(observable: IObservable<T>): void {\n\t\tthis.log.log(`${this.debugName}.handlePossibleChange`);\n\t}\n}\n\nexport class LoggingObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprivate value: T;\n\n\tconstructor(\n\t\tpublic readonly debugName: string,\n\t\tinitialValue: T,\n\t\tprivate readonly logger: Log\n\t) {\n\t\tsuper(DebugLocation.ofCaller());\n\t\tthis.value = initialValue;\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.logger.log(`${this.debugName}.firstObserverAdded`);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.logger.log(`${this.debugName}.lastObserverRemoved`);\n\t}\n\n\tpublic get(): T {\n\t\tthis.logger.log(`${this.debugName}.get`);\n\t\treturn this.value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (this.value === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!tx) {\n\t\t\ttransaction((tx) => {\n\t\t\t\tthis.set(value, tx, change);\n\t\t\t}, () => `Setting ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.logger.log(`${this.debugName}.set (value ${value})`);\n\n\t\tthis.value = value;\n\n\t\tfor (const observer of this._observers) {\n\t\t\ttx.updateObserver(observer, this);\n\t\t\tobserver.handleChange(this, change);\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this.value}`;\n\t}\n}\n\nclass Log {\n\tprivate readonly entries: string[] = [];\n\tpublic log(message: string): void {\n\t\tthis.entries.push(message);\n\t}\n\n\tpublic getAndClearEntries(): string[] {\n\t\tconst entries = [...this.entries];\n\t\tthis.entries.length = 0;\n\t\treturn entries;\n\t}\n}\n"]}