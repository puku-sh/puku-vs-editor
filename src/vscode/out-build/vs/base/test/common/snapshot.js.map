{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/test/common/snapshot.ts","vs/base/test/common/snapshot.ts"],"names":[],"mappings":"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","file":"snapshot.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Lazy } from '../../common/lazy.js';\nimport { FileAccess } from '../../common/network.js';\nimport { URI } from '../../common/uri.js';\n\ndeclare const __readFileInTests: (path: string) => Promise<string>;\ndeclare const __writeFileInTests: (path: string, contents: string) => Promise<void>;\ndeclare const __readDirInTests: (path: string) => Promise<string[]>;\ndeclare const __unlinkInTests: (path: string) => Promise<void>;\ndeclare const __mkdirPInTests: (path: string) => Promise<void>;\n\n// setup on import so assertSnapshot has the current context without explicit passing\nlet context: Lazy<SnapshotContext> | undefined;\nconst sanitizeName = (name: string) => name.replace(/[^a-z0-9_-]/gi, '_');\nconst normalizeCrlf = (str: string) => str.replace(/\\r\\n/g, '\\n');\n\nexport interface ISnapshotOptions {\n\t/** Name for snapshot file, rather than an incremented number */\n\tname?: string;\n\t/** Extension name of the snapshot file, defaults to `.snap` */\n\textension?: string;\n}\n\n/**\n * This is exported only for tests against the snapshotting itself! Use\n * {@link assertSnapshot} as a consumer!\n */\nexport class SnapshotContext {\n\tprivate nextIndex = 0;\n\tprotected snapshotsDir: URI;\n\tprivate readonly namePrefix: string;\n\tprivate readonly usedNames = new Set();\n\n\tconstructor(private readonly test: Mocha.Test | undefined) {\n\t\tif (!test) {\n\t\t\tthrow new Error('assertSnapshot can only be used in a test');\n\t\t}\n\n\t\tif (!test.file) {\n\t\t\tthrow new Error('currentTest.file is not set, please open an issue with the test you\\'re trying to run');\n\t\t}\n\n\t\tconst src = URI.joinPath(FileAccess.asFileUri(''), '../src');\n\t\tconst parts = test.file.split(/[/\\\\]/g);\n\n\t\tthis.namePrefix = sanitizeName(test.fullTitle()) + '.';\n\t\tthis.snapshotsDir = URI.joinPath(src, ...[...parts.slice(0, -1), '__snapshots__']);\n\t}\n\n\tpublic async assert(value: unknown, options?: ISnapshotOptions) {\n\t\tconst originalStack = new Error().stack!; // save to make the stack nicer on failure\n\t\tconst nameOrIndex = (options?.name ? sanitizeName(options.name) : this.nextIndex++);\n\t\tconst fileName = this.namePrefix + nameOrIndex + '.' + (options?.extension || 'snap');\n\t\tthis.usedNames.add(fileName);\n\n\t\tconst fpath = URI.joinPath(this.snapshotsDir, fileName).fsPath;\n\t\tconst actual = formatValue(value);\n\t\tlet expected: string;\n\t\ttry {\n\t\t\texpected = await __readFileInTests(fpath);\n\t\t} catch {\n\t\t\tconsole.info(`Creating new snapshot in: ${fpath}`);\n\t\t\tawait __mkdirPInTests(this.snapshotsDir.fsPath);\n\t\t\tawait __writeFileInTests(fpath, actual);\n\t\t\treturn;\n\t\t}\n\n\t\tif (normalizeCrlf(expected) !== normalizeCrlf(actual)) {\n\t\t\tawait __writeFileInTests(fpath + '.actual', actual);\n\t\t\tconst err: any = new Error(`Snapshot #${nameOrIndex} does not match expected output`);\n\t\t\terr.expected = expected;\n\t\t\terr.actual = actual;\n\t\t\terr.snapshotPath = fpath;\n\t\t\terr.stack = (err.stack as string)\n\t\t\t\t.split('\\n')\n\t\t\t\t// remove all frames from the async stack and keep the original caller's frame\n\t\t\t\t.slice(0, 1)\n\t\t\t\t.concat(originalStack.split('\\n').slice(3))\n\t\t\t\t.join('\\n');\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tpublic async removeOldSnapshots() {\n\t\tconst contents = await __readDirInTests(this.snapshotsDir.fsPath);\n\t\tconst toDelete = contents.filter(f => f.startsWith(this.namePrefix) && !this.usedNames.has(f));\n\t\tif (toDelete.length) {\n\t\t\tconsole.info(`Deleting ${toDelete.length} old snapshots for ${this.test?.fullTitle()}`);\n\t\t}\n\n\t\tawait Promise.all(toDelete.map(f => __unlinkInTests(URI.joinPath(this.snapshotsDir, f).fsPath)));\n\t}\n}\n\nconst debugDescriptionSymbol = Symbol.for('debug.description');\n\nfunction formatValue(value: unknown, level = 0, seen: unknown[] = []): string {\n\tswitch (typeof value) {\n\t\tcase 'bigint':\n\t\tcase 'boolean':\n\t\tcase 'number':\n\t\tcase 'symbol':\n\t\tcase 'undefined':\n\t\t\treturn String(value);\n\t\tcase 'string':\n\t\t\treturn level === 0 ? value : JSON.stringify(value);\n\t\tcase 'function':\n\t\t\treturn `[Function ${value.name}]`;\n\t\tcase 'object': {\n\t\t\tif (value === null) {\n\t\t\t\treturn 'null';\n\t\t\t}\n\t\t\tif (value instanceof RegExp) {\n\t\t\t\treturn String(value);\n\t\t\t}\n\t\t\tif (seen.includes(value)) {\n\t\t\t\treturn '[Circular]';\n\t\t\t}\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tif (debugDescriptionSymbol in value && typeof (value as any)[debugDescriptionSymbol] === 'function') {\n\t\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t\treturn (value as any)[debugDescriptionSymbol]();\n\t\t\t}\n\t\t\tconst oi = '  '.repeat(level);\n\t\t\tconst ci = '  '.repeat(level + 1);\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tconst children = value.map(v => formatValue(v, level + 1, [...seen, value]));\n\t\t\t\tconst multiline = children.some(c => c.includes('\\n')) || children.join(', ').length > 80;\n\t\t\t\treturn multiline ? `[\\n${ci}${children.join(`,\\n${ci}`)}\\n${oi}]` : `[ ${children.join(', ')} ]`;\n\t\t\t}\n\n\t\t\tlet entries;\n\t\t\tlet prefix = '';\n\t\t\tif (value instanceof Map) {\n\t\t\t\tprefix = 'Map ';\n\t\t\t\tentries = [...value.entries()];\n\t\t\t} else if (value instanceof Set) {\n\t\t\t\tprefix = 'Set ';\n\t\t\t\tentries = [...value.entries()];\n\t\t\t} else {\n\t\t\t\tentries = Object.entries(value);\n\t\t\t}\n\n\t\t\tconst lines = entries.map(([k, v]) => `${k}: ${formatValue(v, level + 1, [...seen, value])}`);\n\t\t\treturn prefix + (lines.length > 1\n\t\t\t\t? `{\\n${ci}${lines.join(`,\\n${ci}`)}\\n${oi}}`\n\t\t\t\t: `{ ${lines.join(',\\n')} }`);\n\t\t}\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown type ${value}`);\n\t}\n}\n\nsetup(function () {\n\tconst currentTest = this.currentTest;\n\tcontext = new Lazy(() => new SnapshotContext(currentTest));\n});\nteardown(async function () {\n\tif (this.currentTest?.state === 'passed') {\n\t\tawait context?.rawValue?.removeOldSnapshots();\n\t}\n\tcontext = undefined;\n});\n\n/**\n * Implements a snapshot testing utility. ⚠️ This is async! ⚠️\n *\n * The first time a snapshot test is run, it'll record the value it's called\n * with as the expected value. Subsequent runs will fail if the value differs,\n * but the snapshot can be regenerated by hand or using the Selfhost Test\n * Provider Extension which'll offer to update it.\n *\n * The snapshot will be associated with the currently running test and stored\n * in a `__snapshots__` directory next to the test file, which is expected to\n * be the first `.test.js` file in the callstack.\n */\nexport function assertSnapshot(value: unknown, options?: ISnapshotOptions): Promise<void> {\n\tif (!context) {\n\t\tthrow new Error('assertSnapshot can only be used in a test');\n\t}\n\n\treturn context.value.assert(value, options);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Lazy } from '../../common/lazy.js';\nimport { FileAccess } from '../../common/network.js';\nimport { URI } from '../../common/uri.js';\n\ndeclare const __readFileInTests: (path: string) => Promise<string>;\ndeclare const __writeFileInTests: (path: string, contents: string) => Promise<void>;\ndeclare const __readDirInTests: (path: string) => Promise<string[]>;\ndeclare const __unlinkInTests: (path: string) => Promise<void>;\ndeclare const __mkdirPInTests: (path: string) => Promise<void>;\n\n// setup on import so assertSnapshot has the current context without explicit passing\nlet context: Lazy<SnapshotContext> | undefined;\nconst sanitizeName = (name: string) => name.replace(/[^a-z0-9_-]/gi, '_');\nconst normalizeCrlf = (str: string) => str.replace(/\\r\\n/g, '\\n');\n\nexport interface ISnapshotOptions {\n\t/** Name for snapshot file, rather than an incremented number */\n\tname?: string;\n\t/** Extension name of the snapshot file, defaults to `.snap` */\n\textension?: string;\n}\n\n/**\n * This is exported only for tests against the snapshotting itself! Use\n * {@link assertSnapshot} as a consumer!\n */\nexport class SnapshotContext {\n\tprivate nextIndex = 0;\n\tprotected snapshotsDir: URI;\n\tprivate readonly namePrefix: string;\n\tprivate readonly usedNames = new Set();\n\n\tconstructor(private readonly test: Mocha.Test | undefined) {\n\t\tif (!test) {\n\t\t\tthrow new Error('assertSnapshot can only be used in a test');\n\t\t}\n\n\t\tif (!test.file) {\n\t\t\tthrow new Error('currentTest.file is not set, please open an issue with the test you\\'re trying to run');\n\t\t}\n\n\t\tconst src = URI.joinPath(FileAccess.asFileUri(''), '../src');\n\t\tconst parts = test.file.split(/[/\\\\]/g);\n\n\t\tthis.namePrefix = sanitizeName(test.fullTitle()) + '.';\n\t\tthis.snapshotsDir = URI.joinPath(src, ...[...parts.slice(0, -1), '__snapshots__']);\n\t}\n\n\tpublic async assert(value: unknown, options?: ISnapshotOptions) {\n\t\tconst originalStack = new Error().stack!; // save to make the stack nicer on failure\n\t\tconst nameOrIndex = (options?.name ? sanitizeName(options.name) : this.nextIndex++);\n\t\tconst fileName = this.namePrefix + nameOrIndex + '.' + (options?.extension || 'snap');\n\t\tthis.usedNames.add(fileName);\n\n\t\tconst fpath = URI.joinPath(this.snapshotsDir, fileName).fsPath;\n\t\tconst actual = formatValue(value);\n\t\tlet expected: string;\n\t\ttry {\n\t\t\texpected = await __readFileInTests(fpath);\n\t\t} catch {\n\t\t\tconsole.info(`Creating new snapshot in: ${fpath}`);\n\t\t\tawait __mkdirPInTests(this.snapshotsDir.fsPath);\n\t\t\tawait __writeFileInTests(fpath, actual);\n\t\t\treturn;\n\t\t}\n\n\t\tif (normalizeCrlf(expected) !== normalizeCrlf(actual)) {\n\t\t\tawait __writeFileInTests(fpath + '.actual', actual);\n\t\t\tconst err: any = new Error(`Snapshot #${nameOrIndex} does not match expected output`);\n\t\t\terr.expected = expected;\n\t\t\terr.actual = actual;\n\t\t\terr.snapshotPath = fpath;\n\t\t\terr.stack = (err.stack as string)\n\t\t\t\t.split('\\n')\n\t\t\t\t// remove all frames from the async stack and keep the original caller's frame\n\t\t\t\t.slice(0, 1)\n\t\t\t\t.concat(originalStack.split('\\n').slice(3))\n\t\t\t\t.join('\\n');\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tpublic async removeOldSnapshots() {\n\t\tconst contents = await __readDirInTests(this.snapshotsDir.fsPath);\n\t\tconst toDelete = contents.filter(f => f.startsWith(this.namePrefix) && !this.usedNames.has(f));\n\t\tif (toDelete.length) {\n\t\t\tconsole.info(`Deleting ${toDelete.length} old snapshots for ${this.test?.fullTitle()}`);\n\t\t}\n\n\t\tawait Promise.all(toDelete.map(f => __unlinkInTests(URI.joinPath(this.snapshotsDir, f).fsPath)));\n\t}\n}\n\nconst debugDescriptionSymbol = Symbol.for('debug.description');\n\nfunction formatValue(value: unknown, level = 0, seen: unknown[] = []): string {\n\tswitch (typeof value) {\n\t\tcase 'bigint':\n\t\tcase 'boolean':\n\t\tcase 'number':\n\t\tcase 'symbol':\n\t\tcase 'undefined':\n\t\t\treturn String(value);\n\t\tcase 'string':\n\t\t\treturn level === 0 ? value : JSON.stringify(value);\n\t\tcase 'function':\n\t\t\treturn `[Function ${value.name}]`;\n\t\tcase 'object': {\n\t\t\tif (value === null) {\n\t\t\t\treturn 'null';\n\t\t\t}\n\t\t\tif (value instanceof RegExp) {\n\t\t\t\treturn String(value);\n\t\t\t}\n\t\t\tif (seen.includes(value)) {\n\t\t\t\treturn '[Circular]';\n\t\t\t}\n\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\tif (debugDescriptionSymbol in value && typeof (value as any)[debugDescriptionSymbol] === 'function') {\n\t\t\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t\t\treturn (value as any)[debugDescriptionSymbol]();\n\t\t\t}\n\t\t\tconst oi = '  '.repeat(level);\n\t\t\tconst ci = '  '.repeat(level + 1);\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tconst children = value.map(v => formatValue(v, level + 1, [...seen, value]));\n\t\t\t\tconst multiline = children.some(c => c.includes('\\n')) || children.join(', ').length > 80;\n\t\t\t\treturn multiline ? `[\\n${ci}${children.join(`,\\n${ci}`)}\\n${oi}]` : `[ ${children.join(', ')} ]`;\n\t\t\t}\n\n\t\t\tlet entries;\n\t\t\tlet prefix = '';\n\t\t\tif (value instanceof Map) {\n\t\t\t\tprefix = 'Map ';\n\t\t\t\tentries = [...value.entries()];\n\t\t\t} else if (value instanceof Set) {\n\t\t\t\tprefix = 'Set ';\n\t\t\t\tentries = [...value.entries()];\n\t\t\t} else {\n\t\t\t\tentries = Object.entries(value);\n\t\t\t}\n\n\t\t\tconst lines = entries.map(([k, v]) => `${k}: ${formatValue(v, level + 1, [...seen, value])}`);\n\t\t\treturn prefix + (lines.length > 1\n\t\t\t\t? `{\\n${ci}${lines.join(`,\\n${ci}`)}\\n${oi}}`\n\t\t\t\t: `{ ${lines.join(',\\n')} }`);\n\t\t}\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown type ${value}`);\n\t}\n}\n\nsetup(function () {\n\tconst currentTest = this.currentTest;\n\tcontext = new Lazy(() => new SnapshotContext(currentTest));\n});\nteardown(async function () {\n\tif (this.currentTest?.state === 'passed') {\n\t\tawait context?.rawValue?.removeOldSnapshots();\n\t}\n\tcontext = undefined;\n});\n\n/**\n * Implements a snapshot testing utility. ⚠️ This is async! ⚠️\n *\n * The first time a snapshot test is run, it'll record the value it's called\n * with as the expected value. Subsequent runs will fail if the value differs,\n * but the snapshot can be regenerated by hand or using the Selfhost Test\n * Provider Extension which'll offer to update it.\n *\n * The snapshot will be associated with the currently running test and stored\n * in a `__snapshots__` directory next to the test file, which is expected to\n * be the first `.test.js` file in the callstack.\n */\nexport function assertSnapshot(value: unknown, options?: ISnapshotOptions): Promise<void> {\n\tif (!context) {\n\t\tthrow new Error('assertSnapshot can only be used in a test');\n\t}\n\n\treturn context.value.assert(value, options);\n}\n"]}