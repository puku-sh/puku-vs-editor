{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/test/common/diff/diff.test.ts","vs/base/test/common/diff/diff.test.ts"],"names":[],"mappings":"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","file":"diff.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { IDiffChange, LcsDiff, StringDiffSequence } from '../../../common/diff/diff.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../utils.js';\n\nfunction createArray<T>(length: number, value: T): T[] {\n\tconst r: T[] = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tr[i] = value;\n\t}\n\treturn r;\n}\n\nfunction maskBasedSubstring(str: string, mask: boolean[]): string {\n\tlet r = '';\n\tfor (let i = 0; i < str.length; i++) {\n\t\tif (mask[i]) {\n\t\t\tr += str.charAt(i);\n\t\t}\n\t}\n\treturn r;\n}\n\nfunction assertAnswer(originalStr: string, modifiedStr: string, changes: IDiffChange[], answerStr: string, onlyLength: boolean = false): void {\n\tconst originalMask = createArray(originalStr.length, true);\n\tconst modifiedMask = createArray(modifiedStr.length, true);\n\n\tlet i, j, change;\n\tfor (i = 0; i < changes.length; i++) {\n\t\tchange = changes[i];\n\n\t\tif (change.originalLength) {\n\t\t\tfor (j = 0; j < change.originalLength; j++) {\n\t\t\t\toriginalMask[change.originalStart + j] = false;\n\t\t\t}\n\t\t}\n\n\t\tif (change.modifiedLength) {\n\t\t\tfor (j = 0; j < change.modifiedLength; j++) {\n\t\t\t\tmodifiedMask[change.modifiedStart + j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst originalAnswer = maskBasedSubstring(originalStr, originalMask);\n\tconst modifiedAnswer = maskBasedSubstring(modifiedStr, modifiedMask);\n\n\tif (onlyLength) {\n\t\tassert.strictEqual(originalAnswer.length, answerStr.length);\n\t\tassert.strictEqual(modifiedAnswer.length, answerStr.length);\n\t} else {\n\t\tassert.strictEqual(originalAnswer, answerStr);\n\t\tassert.strictEqual(modifiedAnswer, answerStr);\n\t}\n}\n\nfunction lcsInnerTest(originalStr: string, modifiedStr: string, answerStr: string, onlyLength: boolean = false): void {\n\tconst diff = new LcsDiff(new StringDiffSequence(originalStr), new StringDiffSequence(modifiedStr));\n\tconst changes = diff.ComputeDiff(false).changes;\n\tassertAnswer(originalStr, modifiedStr, changes, answerStr, onlyLength);\n}\n\nfunction stringPower(str: string, power: number): string {\n\tlet r = str;\n\tfor (let i = 0; i < power; i++) {\n\t\tr += r;\n\t}\n\treturn r;\n}\n\nfunction lcsTest(originalStr: string, modifiedStr: string, answerStr: string) {\n\tlcsInnerTest(originalStr, modifiedStr, answerStr);\n\tfor (let i = 2; i <= 5; i++) {\n\t\tlcsInnerTest(stringPower(originalStr, i), stringPower(modifiedStr, i), stringPower(answerStr, i), true);\n\t}\n}\n\nsuite('Diff', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('LcsDiff - different strings tests', function () {\n\t\tthis.timeout(10000);\n\t\tlcsTest('heLLo world', 'hello orlando', 'heo orld');\n\t\tlcsTest('abcde', 'acd', 'acd'); // simple\n\t\tlcsTest('abcdbce', 'bcede', 'bcde'); // skip\n\t\tlcsTest('abcdefgabcdefg', 'bcehafg', 'bceafg'); // long\n\t\tlcsTest('abcde', 'fgh', ''); // no match\n\t\tlcsTest('abcfabc', 'fabc', 'fabc');\n\t\tlcsTest('0azby0', '9axbzby9', 'azby');\n\t\tlcsTest('0abc00000', '9a1b2c399999', 'abc');\n\n\t\tlcsTest('fooBar', 'myfooBar', 'fooBar'); // all insertions\n\t\tlcsTest('fooBar', 'fooMyBar', 'fooBar'); // all insertions\n\t\tlcsTest('fooBar', 'fooBar', 'fooBar'); // identical sequences\n\t});\n});\n\nsuite('Diff - Ported from VS', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('using continue processing predicate to quit early', function () {\n\t\tconst left = 'abcdef';\n\t\tconst right = 'abxxcyyydzzzzezzzzzzzzzzzzzzzzzzzzf';\n\n\t\t// We use a long non-matching portion at the end of the right-side string, so the backwards tracking logic\n\t\t// doesn't get there first.\n\t\tlet predicateCallCount = 0;\n\n\t\tlet diff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert.strictEqual(predicateCallCount, 0);\n\n\t\t\tpredicateCallCount++;\n\n\t\t\tassert.strictEqual(leftIndex, 1);\n\n\t\t\t// cancel processing\n\t\t\treturn false;\n\t\t});\n\t\tlet changes = diff.ComputeDiff(true).changes;\n\n\t\tassert.strictEqual(predicateCallCount, 1);\n\n\t\t// Doesn't include 'c', 'd', or 'e', since we quit on the first request\n\t\tassertAnswer(left, right, changes, 'abf');\n\n\n\n\t\t// Cancel after the first match ('c')\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 1); // We never see a match of length > 1\n\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn longestMatchSoFar < 1;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcf');\n\n\n\n\t\t// Cancel after the second match ('d')\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 2); // We never see a match of length > 2\n\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn longestMatchSoFar < 2;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcdf');\n\n\n\n\t\t// Cancel *one iteration* after the second match ('d')\n\t\tlet hitSecondMatch = false;\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 2); // We never see a match of length > 2\n\n\t\t\tconst hitYet = hitSecondMatch;\n\t\t\thitSecondMatch = longestMatchSoFar > 1;\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn !hitYet;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcdf');\n\n\n\n\t\t// Cancel after the third and final match ('e')\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 3); // We never see a match of length > 3\n\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn longestMatchSoFar < 3;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcdef');\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { IDiffChange, LcsDiff, StringDiffSequence } from '../../../common/diff/diff.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../utils.js';\n\nfunction createArray<T>(length: number, value: T): T[] {\n\tconst r: T[] = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tr[i] = value;\n\t}\n\treturn r;\n}\n\nfunction maskBasedSubstring(str: string, mask: boolean[]): string {\n\tlet r = '';\n\tfor (let i = 0; i < str.length; i++) {\n\t\tif (mask[i]) {\n\t\t\tr += str.charAt(i);\n\t\t}\n\t}\n\treturn r;\n}\n\nfunction assertAnswer(originalStr: string, modifiedStr: string, changes: IDiffChange[], answerStr: string, onlyLength: boolean = false): void {\n\tconst originalMask = createArray(originalStr.length, true);\n\tconst modifiedMask = createArray(modifiedStr.length, true);\n\n\tlet i, j, change;\n\tfor (i = 0; i < changes.length; i++) {\n\t\tchange = changes[i];\n\n\t\tif (change.originalLength) {\n\t\t\tfor (j = 0; j < change.originalLength; j++) {\n\t\t\t\toriginalMask[change.originalStart + j] = false;\n\t\t\t}\n\t\t}\n\n\t\tif (change.modifiedLength) {\n\t\t\tfor (j = 0; j < change.modifiedLength; j++) {\n\t\t\t\tmodifiedMask[change.modifiedStart + j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst originalAnswer = maskBasedSubstring(originalStr, originalMask);\n\tconst modifiedAnswer = maskBasedSubstring(modifiedStr, modifiedMask);\n\n\tif (onlyLength) {\n\t\tassert.strictEqual(originalAnswer.length, answerStr.length);\n\t\tassert.strictEqual(modifiedAnswer.length, answerStr.length);\n\t} else {\n\t\tassert.strictEqual(originalAnswer, answerStr);\n\t\tassert.strictEqual(modifiedAnswer, answerStr);\n\t}\n}\n\nfunction lcsInnerTest(originalStr: string, modifiedStr: string, answerStr: string, onlyLength: boolean = false): void {\n\tconst diff = new LcsDiff(new StringDiffSequence(originalStr), new StringDiffSequence(modifiedStr));\n\tconst changes = diff.ComputeDiff(false).changes;\n\tassertAnswer(originalStr, modifiedStr, changes, answerStr, onlyLength);\n}\n\nfunction stringPower(str: string, power: number): string {\n\tlet r = str;\n\tfor (let i = 0; i < power; i++) {\n\t\tr += r;\n\t}\n\treturn r;\n}\n\nfunction lcsTest(originalStr: string, modifiedStr: string, answerStr: string) {\n\tlcsInnerTest(originalStr, modifiedStr, answerStr);\n\tfor (let i = 2; i <= 5; i++) {\n\t\tlcsInnerTest(stringPower(originalStr, i), stringPower(modifiedStr, i), stringPower(answerStr, i), true);\n\t}\n}\n\nsuite('Diff', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('LcsDiff - different strings tests', function () {\n\t\tthis.timeout(10000);\n\t\tlcsTest('heLLo world', 'hello orlando', 'heo orld');\n\t\tlcsTest('abcde', 'acd', 'acd'); // simple\n\t\tlcsTest('abcdbce', 'bcede', 'bcde'); // skip\n\t\tlcsTest('abcdefgabcdefg', 'bcehafg', 'bceafg'); // long\n\t\tlcsTest('abcde', 'fgh', ''); // no match\n\t\tlcsTest('abcfabc', 'fabc', 'fabc');\n\t\tlcsTest('0azby0', '9axbzby9', 'azby');\n\t\tlcsTest('0abc00000', '9a1b2c399999', 'abc');\n\n\t\tlcsTest('fooBar', 'myfooBar', 'fooBar'); // all insertions\n\t\tlcsTest('fooBar', 'fooMyBar', 'fooBar'); // all insertions\n\t\tlcsTest('fooBar', 'fooBar', 'fooBar'); // identical sequences\n\t});\n});\n\nsuite('Diff - Ported from VS', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('using continue processing predicate to quit early', function () {\n\t\tconst left = 'abcdef';\n\t\tconst right = 'abxxcyyydzzzzezzzzzzzzzzzzzzzzzzzzf';\n\n\t\t// We use a long non-matching portion at the end of the right-side string, so the backwards tracking logic\n\t\t// doesn't get there first.\n\t\tlet predicateCallCount = 0;\n\n\t\tlet diff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert.strictEqual(predicateCallCount, 0);\n\n\t\t\tpredicateCallCount++;\n\n\t\t\tassert.strictEqual(leftIndex, 1);\n\n\t\t\t// cancel processing\n\t\t\treturn false;\n\t\t});\n\t\tlet changes = diff.ComputeDiff(true).changes;\n\n\t\tassert.strictEqual(predicateCallCount, 1);\n\n\t\t// Doesn't include 'c', 'd', or 'e', since we quit on the first request\n\t\tassertAnswer(left, right, changes, 'abf');\n\n\n\n\t\t// Cancel after the first match ('c')\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 1); // We never see a match of length > 1\n\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn longestMatchSoFar < 1;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcf');\n\n\n\n\t\t// Cancel after the second match ('d')\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 2); // We never see a match of length > 2\n\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn longestMatchSoFar < 2;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcdf');\n\n\n\n\t\t// Cancel *one iteration* after the second match ('d')\n\t\tlet hitSecondMatch = false;\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 2); // We never see a match of length > 2\n\n\t\t\tconst hitYet = hitSecondMatch;\n\t\t\thitSecondMatch = longestMatchSoFar > 1;\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn !hitYet;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcdf');\n\n\n\n\t\t// Cancel after the third and final match ('e')\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 3); // We never see a match of length > 3\n\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn longestMatchSoFar < 3;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcdef');\n\t});\n});\n"]}