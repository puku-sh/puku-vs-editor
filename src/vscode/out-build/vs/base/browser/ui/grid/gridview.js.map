{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/browser/ui/grid/gridview.ts","vs/base/browser/ui/grid/gridview.ts"],"names":[],"mappings":"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","file":"gridview.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { $ } from '../../dom.js';\nimport { IBoundarySashes, Orientation, Sash } from '../sash/sash.js';\nimport { DistributeSizing, ISplitViewStyles, IView as ISplitView, LayoutPriority, Sizing, AutoSizing, SplitView } from '../splitview/splitview.js';\nimport { equals as arrayEquals, tail } from '../../../common/arrays.js';\nimport { Color } from '../../../common/color.js';\nimport { Emitter, Event, Relay } from '../../../common/event.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../common/lifecycle.js';\nimport { rot } from '../../../common/numbers.js';\nimport { isUndefined } from '../../../common/types.js';\nimport './gridview.css';\n\nexport { Orientation } from '../sash/sash.js';\nexport { LayoutPriority, Sizing } from '../splitview/splitview.js';\n\nexport interface IGridViewStyles extends ISplitViewStyles { }\n\nconst defaultStyles: IGridViewStyles = {\n\tseparatorBorder: Color.transparent\n};\n\nexport interface IViewSize {\n\treadonly width: number;\n\treadonly height: number;\n}\n\ninterface IRelativeBoundarySashes {\n\treadonly start?: Sash;\n\treadonly end?: Sash;\n\treadonly orthogonalStart?: Sash;\n\treadonly orthogonalEnd?: Sash;\n}\n\n/**\n * The interface to implement for views within a {@link GridView}.\n */\nexport interface IView {\n\n\t/**\n\t * The DOM element for this view.\n\t */\n\treadonly element: HTMLElement;\n\n\t/**\n\t * A minimum width for this view.\n\t *\n\t * @remarks If none, set it to `0`.\n\t */\n\treadonly minimumWidth: number;\n\n\t/**\n\t * A minimum width for this view.\n\t *\n\t * @remarks If none, set it to `Number.POSITIVE_INFINITY`.\n\t */\n\treadonly maximumWidth: number;\n\n\t/**\n\t * A minimum height for this view.\n\t *\n\t * @remarks If none, set it to `0`.\n\t */\n\treadonly minimumHeight: number;\n\n\t/**\n\t * A minimum height for this view.\n\t *\n\t * @remarks If none, set it to `Number.POSITIVE_INFINITY`.\n\t */\n\treadonly maximumHeight: number;\n\n\t/**\n\t * The priority of the view when the {@link GridView} layout algorithm\n\t * runs. Views with higher priority will be resized first.\n\t *\n\t * @remarks Only used when `proportionalLayout` is false.\n\t */\n\treadonly priority?: LayoutPriority;\n\n\t/**\n\t * If the {@link GridView} supports proportional layout,\n\t * this property allows for finer control over the proportional layout algorithm, per view.\n\t *\n\t * @defaultValue `true`\n\t */\n\treadonly proportionalLayout?: boolean;\n\n\t/**\n\t * Whether the view will snap whenever the user reaches its minimum size or\n\t * attempts to grow it beyond the minimum size.\n\t *\n\t * @defaultValue `false`\n\t */\n\treadonly snap?: boolean;\n\n\t/**\n\t * View instances are supposed to fire this event whenever any of the constraint\n\t * properties have changed:\n\t *\n\t * - {@link IView.minimumWidth}\n\t * - {@link IView.maximumWidth}\n\t * - {@link IView.minimumHeight}\n\t * - {@link IView.maximumHeight}\n\t * - {@link IView.priority}\n\t * - {@link IView.snap}\n\t *\n\t * The {@link GridView} will relayout whenever that happens. The event can\n\t * optionally emit the view's preferred size for that relayout.\n\t */\n\treadonly onDidChange: Event<IViewSize | undefined>;\n\n\t/**\n\t * This will be called by the {@link GridView} during layout. A view meant to\n\t * pass along the layout information down to its descendants.\n\t */\n\tlayout(width: number, height: number, top: number, left: number): void;\n\n\t/**\n\t * This will be called by the {@link GridView} whenever this view is made\n\t * visible or hidden.\n\t *\n\t * @param visible Whether the view becomes visible.\n\t */\n\tsetVisible?(visible: boolean): void;\n\n\t/**\n\t * This will be called by the {@link GridView} whenever this view is on\n\t * an edge of the grid and the grid's\n\t * {@link GridView.boundarySashes boundary sashes} change.\n\t */\n\tsetBoundarySashes?(sashes: IBoundarySashes): void;\n}\n\nexport interface ISerializableView extends IView {\n\ttoJSON(): object;\n}\n\nexport interface IViewDeserializer<T extends ISerializableView> {\n\tfromJSON(json: any): T;\n}\n\nexport interface ISerializedLeafNode {\n\ttype: 'leaf';\n\tdata: unknown;\n\tsize: number;\n\tvisible?: boolean;\n\tmaximized?: boolean;\n}\n\nexport interface ISerializedBranchNode {\n\ttype: 'branch';\n\tdata: ISerializedNode[];\n\tsize: number;\n\tvisible?: boolean;\n}\n\nexport type ISerializedNode = ISerializedLeafNode | ISerializedBranchNode;\n\nexport interface ISerializedGridView {\n\troot: ISerializedNode;\n\torientation: Orientation;\n\twidth: number;\n\theight: number;\n}\n\nexport function orthogonal(orientation: Orientation): Orientation {\n\treturn orientation === Orientation.VERTICAL ? Orientation.HORIZONTAL : Orientation.VERTICAL;\n}\n\nexport interface Box {\n\treadonly top: number;\n\treadonly left: number;\n\treadonly width: number;\n\treadonly height: number;\n}\n\nexport interface GridLeafNode {\n\treadonly view: IView;\n\treadonly box: Box;\n\treadonly cachedVisibleSize: number | undefined;\n\treadonly maximized: boolean;\n}\n\nexport interface GridBranchNode {\n\treadonly children: GridNode[];\n\treadonly box: Box;\n}\n\nexport type GridNode = GridLeafNode | GridBranchNode;\n\nexport function isGridBranchNode(node: GridNode): node is GridBranchNode {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!(node as any).children;\n}\n\nclass LayoutController {\n\tconstructor(public isLayoutEnabled: boolean) { }\n}\n\nexport interface IGridViewOptions {\n\n\t/**\n\t * Styles overriding the {@link defaultStyles default ones}.\n\t */\n\treadonly styles?: IGridViewStyles;\n\n\t/**\n\t * Resize each view proportionally when resizing the {@link GridView}.\n\t *\n\t * @defaultValue `true`\n\t */\n\treadonly proportionalLayout?: boolean; // default true\n}\n\ninterface ILayoutContext {\n\treadonly orthogonalSize: number;\n\treadonly absoluteOffset: number;\n\treadonly absoluteOrthogonalOffset: number;\n\treadonly absoluteSize: number;\n\treadonly absoluteOrthogonalSize: number;\n}\n\nfunction toAbsoluteBoundarySashes(sashes: IRelativeBoundarySashes, orientation: Orientation): IBoundarySashes {\n\tif (orientation === Orientation.HORIZONTAL) {\n\t\treturn { left: sashes.start, right: sashes.end, top: sashes.orthogonalStart, bottom: sashes.orthogonalEnd };\n\t} else {\n\t\treturn { top: sashes.start, bottom: sashes.end, left: sashes.orthogonalStart, right: sashes.orthogonalEnd };\n\t}\n}\n\nfunction fromAbsoluteBoundarySashes(sashes: IBoundarySashes, orientation: Orientation): IRelativeBoundarySashes {\n\tif (orientation === Orientation.HORIZONTAL) {\n\t\treturn { start: sashes.left, end: sashes.right, orthogonalStart: sashes.top, orthogonalEnd: sashes.bottom };\n\t} else {\n\t\treturn { start: sashes.top, end: sashes.bottom, orthogonalStart: sashes.left, orthogonalEnd: sashes.right };\n\t}\n}\n\nfunction validateIndex(index: number, numChildren: number): number {\n\tif (Math.abs(index) > numChildren) {\n\t\tthrow new Error('Invalid index');\n\t}\n\n\treturn rot(index, numChildren + 1);\n}\n\nclass BranchNode implements ISplitView<ILayoutContext>, IDisposable {\n\n\treadonly element: HTMLElement;\n\treadonly children: Node[] = [];\n\tprivate splitview: SplitView<ILayoutContext, Node>;\n\n\tprivate _size: number;\n\tget size(): number { return this._size; }\n\n\tprivate _orthogonalSize: number;\n\tget orthogonalSize(): number { return this._orthogonalSize; }\n\n\tprivate _absoluteOffset: number = 0;\n\tget absoluteOffset(): number { return this._absoluteOffset; }\n\n\tprivate _absoluteOrthogonalOffset: number = 0;\n\tget absoluteOrthogonalOffset(): number { return this._absoluteOrthogonalOffset; }\n\n\tprivate absoluteOrthogonalSize: number = 0;\n\n\tprivate _styles: IGridViewStyles;\n\tget styles(): IGridViewStyles { return this._styles; }\n\n\tget width(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.size : this.orthogonalSize;\n\t}\n\n\tget height(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.orthogonalSize : this.size;\n\t}\n\n\tget top(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this._absoluteOffset : this._absoluteOrthogonalOffset;\n\t}\n\n\tget left(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this._absoluteOrthogonalOffset : this._absoluteOffset;\n\t}\n\n\tget minimumSize(): number {\n\t\treturn this.children.length === 0 ? 0 : Math.max(...this.children.map((c, index) => this.splitview.isViewVisible(index) ? c.minimumOrthogonalSize : 0));\n\t}\n\n\tget maximumSize(): number {\n\t\treturn Math.min(...this.children.map((c, index) => this.splitview.isViewVisible(index) ? c.maximumOrthogonalSize : Number.POSITIVE_INFINITY));\n\t}\n\n\tget priority(): LayoutPriority {\n\t\tif (this.children.length === 0) {\n\t\t\treturn LayoutPriority.Normal;\n\t\t}\n\n\t\tconst priorities = this.children.map(c => typeof c.priority === 'undefined' ? LayoutPriority.Normal : c.priority);\n\n\t\tif (priorities.some(p => p === LayoutPriority.High)) {\n\t\t\treturn LayoutPriority.High;\n\t\t} else if (priorities.some(p => p === LayoutPriority.Low)) {\n\t\t\treturn LayoutPriority.Low;\n\t\t}\n\n\t\treturn LayoutPriority.Normal;\n\t}\n\n\tget proportionalLayout(): boolean {\n\t\tif (this.children.length === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn this.children.every(c => c.proportionalLayout);\n\t}\n\n\tget minimumOrthogonalSize(): number {\n\t\treturn this.splitview.minimumSize;\n\t}\n\n\tget maximumOrthogonalSize(): number {\n\t\treturn this.splitview.maximumSize;\n\t}\n\n\tget minimumWidth(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.minimumOrthogonalSize : this.minimumSize;\n\t}\n\n\tget minimumHeight(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.minimumSize : this.minimumOrthogonalSize;\n\t}\n\n\tget maximumWidth(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.maximumOrthogonalSize : this.maximumSize;\n\t}\n\n\tget maximumHeight(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.maximumSize : this.maximumOrthogonalSize;\n\t}\n\n\tprivate readonly _onDidChange = new Emitter<number | undefined>();\n\treadonly onDidChange: Event<number | undefined> = this._onDidChange.event;\n\n\tprivate readonly _onDidVisibilityChange = new Emitter<boolean>();\n\treadonly onDidVisibilityChange: Event<boolean> = this._onDidVisibilityChange.event;\n\tprivate readonly childrenVisibilityChangeDisposable: DisposableStore = new DisposableStore();\n\n\tprivate _onDidScroll = new Emitter<void>();\n\tprivate onDidScrollDisposable: IDisposable = Disposable.None;\n\treadonly onDidScroll: Event<void> = this._onDidScroll.event;\n\n\tprivate childrenChangeDisposable: IDisposable = Disposable.None;\n\n\tprivate readonly _onDidSashReset = new Emitter<GridLocation>();\n\treadonly onDidSashReset: Event<GridLocation> = this._onDidSashReset.event;\n\tprivate splitviewSashResetDisposable: IDisposable = Disposable.None;\n\tprivate childrenSashResetDisposable: IDisposable = Disposable.None;\n\n\tprivate _boundarySashes: IRelativeBoundarySashes = {};\n\tget boundarySashes(): IRelativeBoundarySashes { return this._boundarySashes; }\n\tset boundarySashes(boundarySashes: IRelativeBoundarySashes) {\n\t\tif (this._boundarySashes.start === boundarySashes.start\n\t\t\t&& this._boundarySashes.end === boundarySashes.end\n\t\t\t&& this._boundarySashes.orthogonalStart === boundarySashes.orthogonalStart\n\t\t\t&& this._boundarySashes.orthogonalEnd === boundarySashes.orthogonalEnd) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._boundarySashes = boundarySashes;\n\n\t\tthis.splitview.orthogonalStartSash = boundarySashes.orthogonalStart;\n\t\tthis.splitview.orthogonalEndSash = boundarySashes.orthogonalEnd;\n\n\t\tfor (let index = 0; index < this.children.length; index++) {\n\t\t\tconst child = this.children[index];\n\t\t\tconst first = index === 0;\n\t\t\tconst last = index === this.children.length - 1;\n\n\t\t\tchild.boundarySashes = {\n\t\t\t\tstart: boundarySashes.orthogonalStart,\n\t\t\t\tend: boundarySashes.orthogonalEnd,\n\t\t\t\torthogonalStart: first ? boundarySashes.start : child.boundarySashes.orthogonalStart,\n\t\t\t\torthogonalEnd: last ? boundarySashes.end : child.boundarySashes.orthogonalEnd,\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate _edgeSnapping = false;\n\tget edgeSnapping(): boolean { return this._edgeSnapping; }\n\tset edgeSnapping(edgeSnapping: boolean) {\n\t\tif (this._edgeSnapping === edgeSnapping) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._edgeSnapping = edgeSnapping;\n\n\t\tfor (const child of this.children) {\n\t\t\tif (child instanceof BranchNode) {\n\t\t\t\tchild.edgeSnapping = edgeSnapping;\n\t\t\t}\n\t\t}\n\n\t\tthis.updateSplitviewEdgeSnappingEnablement();\n\t}\n\n\tconstructor(\n\t\treadonly orientation: Orientation,\n\t\treadonly layoutController: LayoutController,\n\t\tstyles: IGridViewStyles,\n\t\treadonly splitviewProportionalLayout: boolean,\n\t\tsize: number = 0,\n\t\torthogonalSize: number = 0,\n\t\tedgeSnapping: boolean = false,\n\t\tchildDescriptors?: INodeDescriptor[]\n\t) {\n\t\tthis._styles = styles;\n\t\tthis._size = size;\n\t\tthis._orthogonalSize = orthogonalSize;\n\n\t\tthis.element = $('.monaco-grid-branch-node');\n\n\t\tif (!childDescriptors) {\n\t\t\t// Normal behavior, we have no children yet, just set up the splitview\n\t\t\tthis.splitview = new SplitView(this.element, { orientation, styles, proportionalLayout: splitviewProportionalLayout });\n\t\t\tthis.splitview.layout(size, { orthogonalSize, absoluteOffset: 0, absoluteOrthogonalOffset: 0, absoluteSize: size, absoluteOrthogonalSize: orthogonalSize });\n\t\t} else {\n\t\t\t// Reconstruction behavior, we want to reconstruct a splitview\n\t\t\tconst descriptor = {\n\t\t\t\tviews: childDescriptors.map(childDescriptor => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tview: childDescriptor.node,\n\t\t\t\t\t\tsize: childDescriptor.node.size,\n\t\t\t\t\t\tvisible: childDescriptor.visible !== false\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t\tsize: this.orthogonalSize\n\t\t\t};\n\n\t\t\tconst options = { proportionalLayout: splitviewProportionalLayout, orientation, styles };\n\n\t\t\tthis.children = childDescriptors.map(c => c.node);\n\t\t\tthis.splitview = new SplitView(this.element, { ...options, descriptor });\n\n\t\t\tthis.children.forEach((node, index) => {\n\t\t\t\tconst first = index === 0;\n\t\t\t\tconst last = index === this.children.length;\n\n\t\t\t\tnode.boundarySashes = {\n\t\t\t\t\tstart: this.boundarySashes.orthogonalStart,\n\t\t\t\t\tend: this.boundarySashes.orthogonalEnd,\n\t\t\t\t\torthogonalStart: first ? this.boundarySashes.start : this.splitview.sashes[index - 1],\n\t\t\t\t\torthogonalEnd: last ? this.boundarySashes.end : this.splitview.sashes[index],\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\tconst onDidSashReset = Event.map(this.splitview.onDidSashReset, i => [i]);\n\t\tthis.splitviewSashResetDisposable = onDidSashReset(this._onDidSashReset.fire, this._onDidSashReset);\n\n\t\tthis.updateChildrenEvents();\n\t}\n\n\tstyle(styles: IGridViewStyles): void {\n\t\tthis._styles = styles;\n\t\tthis.splitview.style(styles);\n\n\t\tfor (const child of this.children) {\n\t\t\tif (child instanceof BranchNode) {\n\t\t\t\tchild.style(styles);\n\t\t\t}\n\t\t}\n\t}\n\n\tlayout(size: number, offset: number, ctx: ILayoutContext | undefined): void {\n\t\tif (!this.layoutController.isLayoutEnabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof ctx === 'undefined') {\n\t\t\tthrow new Error('Invalid state');\n\t\t}\n\n\t\t// branch nodes should flip the normal/orthogonal directions\n\t\tthis._size = ctx.orthogonalSize;\n\t\tthis._orthogonalSize = size;\n\t\tthis._absoluteOffset = ctx.absoluteOffset + offset;\n\t\tthis._absoluteOrthogonalOffset = ctx.absoluteOrthogonalOffset;\n\t\tthis.absoluteOrthogonalSize = ctx.absoluteOrthogonalSize;\n\n\t\tthis.splitview.layout(ctx.orthogonalSize, {\n\t\t\torthogonalSize: size,\n\t\t\tabsoluteOffset: this._absoluteOrthogonalOffset,\n\t\t\tabsoluteOrthogonalOffset: this._absoluteOffset,\n\t\t\tabsoluteSize: ctx.absoluteOrthogonalSize,\n\t\t\tabsoluteOrthogonalSize: ctx.absoluteSize\n\t\t});\n\n\t\tthis.updateSplitviewEdgeSnappingEnablement();\n\t}\n\n\tsetVisible(visible: boolean): void {\n\t\tfor (const child of this.children) {\n\t\t\tchild.setVisible(visible);\n\t\t}\n\t}\n\n\taddChild(node: Node, size: number | Sizing, index: number, skipLayout?: boolean): void {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\tthis.splitview.addView(node, size, index, skipLayout);\n\t\tthis.children.splice(index, 0, node);\n\n\t\tthis.updateBoundarySashes();\n\t\tthis.onDidChildrenChange();\n\t}\n\n\tremoveChild(index: number, sizing?: Sizing): Node {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\tconst result = this.splitview.removeView(index, sizing);\n\t\tthis.children.splice(index, 1);\n\n\t\tthis.updateBoundarySashes();\n\t\tthis.onDidChildrenChange();\n\n\t\treturn result;\n\t}\n\n\tremoveAllChildren(): Node[] {\n\t\tconst result = this.splitview.removeAllViews();\n\n\t\tthis.children.splice(0, this.children.length);\n\n\t\tthis.updateBoundarySashes();\n\t\tthis.onDidChildrenChange();\n\n\t\treturn result;\n\t}\n\n\tmoveChild(from: number, to: number): void {\n\t\tfrom = validateIndex(from, this.children.length);\n\t\tto = validateIndex(to, this.children.length);\n\n\t\tif (from === to) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (from < to) {\n\t\t\tto -= 1;\n\t\t}\n\n\t\tthis.splitview.moveView(from, to);\n\t\tthis.children.splice(to, 0, this.children.splice(from, 1)[0]);\n\n\t\tthis.updateBoundarySashes();\n\t\tthis.onDidChildrenChange();\n\t}\n\n\tswapChildren(from: number, to: number): void {\n\t\tfrom = validateIndex(from, this.children.length);\n\t\tto = validateIndex(to, this.children.length);\n\n\t\tif (from === to) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.splitview.swapViews(from, to);\n\n\t\t// swap boundary sashes\n\t\t[this.children[from].boundarySashes, this.children[to].boundarySashes]\n\t\t\t= [this.children[from].boundarySashes, this.children[to].boundarySashes];\n\n\t\t// swap children\n\t\t[this.children[from], this.children[to]] = [this.children[to], this.children[from]];\n\n\t\tthis.onDidChildrenChange();\n\t}\n\n\tresizeChild(index: number, size: number): void {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\tthis.splitview.resizeView(index, size);\n\t}\n\n\tisChildExpanded(index: number): boolean {\n\t\treturn this.splitview.isViewExpanded(index);\n\t}\n\n\tdistributeViewSizes(recursive = false): void {\n\t\tthis.splitview.distributeViewSizes();\n\n\t\tif (recursive) {\n\t\t\tfor (const child of this.children) {\n\t\t\t\tif (child instanceof BranchNode) {\n\t\t\t\t\tchild.distributeViewSizes(true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetChildSize(index: number): number {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\treturn this.splitview.getViewSize(index);\n\t}\n\n\tisChildVisible(index: number): boolean {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\treturn this.splitview.isViewVisible(index);\n\t}\n\n\tsetChildVisible(index: number, visible: boolean): void {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\tif (this.splitview.isViewVisible(index) === visible) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst wereAllChildrenHidden = this.splitview.contentSize === 0;\n\t\tthis.splitview.setViewVisible(index, visible);\n\t\tconst areAllChildrenHidden = this.splitview.contentSize === 0;\n\n\t\t// If all children are hidden then the parent should hide the entire splitview\n\t\t// If the entire splitview is hidden then the parent should show the splitview when a child is shown\n\t\tif ((visible && wereAllChildrenHidden) || (!visible && areAllChildrenHidden)) {\n\t\t\tthis._onDidVisibilityChange.fire(visible);\n\t\t}\n\t}\n\n\tgetChildCachedVisibleSize(index: number): number | undefined {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\treturn this.splitview.getViewCachedVisibleSize(index);\n\t}\n\n\tprivate updateBoundarySashes(): void {\n\t\tfor (let i = 0; i < this.children.length; i++) {\n\t\t\tthis.children[i].boundarySashes = {\n\t\t\t\tstart: this.boundarySashes.orthogonalStart,\n\t\t\t\tend: this.boundarySashes.orthogonalEnd,\n\t\t\t\torthogonalStart: i === 0 ? this.boundarySashes.start : this.splitview.sashes[i - 1],\n\t\t\t\torthogonalEnd: i === this.children.length - 1 ? this.boundarySashes.end : this.splitview.sashes[i],\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate onDidChildrenChange(): void {\n\t\tthis.updateChildrenEvents();\n\t\tthis._onDidChange.fire(undefined);\n\t}\n\n\tprivate updateChildrenEvents(): void {\n\t\tconst onDidChildrenChange = Event.map(Event.any(...this.children.map(c => c.onDidChange)), () => undefined);\n\t\tthis.childrenChangeDisposable.dispose();\n\t\tthis.childrenChangeDisposable = onDidChildrenChange(this._onDidChange.fire, this._onDidChange);\n\n\t\tconst onDidChildrenSashReset = Event.any(...this.children.map((c, i) => Event.map(c.onDidSashReset, location => [i, ...location])));\n\t\tthis.childrenSashResetDisposable.dispose();\n\t\tthis.childrenSashResetDisposable = onDidChildrenSashReset(this._onDidSashReset.fire, this._onDidSashReset);\n\n\t\tconst onDidScroll = Event.any(Event.signal(this.splitview.onDidScroll), ...this.children.map(c => c.onDidScroll));\n\t\tthis.onDidScrollDisposable.dispose();\n\t\tthis.onDidScrollDisposable = onDidScroll(this._onDidScroll.fire, this._onDidScroll);\n\n\t\tthis.childrenVisibilityChangeDisposable.clear();\n\t\tthis.children.forEach((child, index) => {\n\t\t\tif (child instanceof BranchNode) {\n\t\t\t\tthis.childrenVisibilityChangeDisposable.add(child.onDidVisibilityChange((visible) => {\n\t\t\t\t\tthis.setChildVisible(index, visible);\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\t}\n\n\ttrySet2x2(other: BranchNode): IDisposable {\n\t\tif (this.children.length !== 2 || other.children.length !== 2) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tif (this.getChildSize(0) !== other.getChildSize(0)) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tconst [firstChild, secondChild] = this.children;\n\t\tconst [otherFirstChild, otherSecondChild] = other.children;\n\n\t\tif (!(firstChild instanceof LeafNode) || !(secondChild instanceof LeafNode)) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tif (!(otherFirstChild instanceof LeafNode) || !(otherSecondChild instanceof LeafNode)) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tif (this.orientation === Orientation.VERTICAL) {\n\t\t\tsecondChild.linkedWidthNode = otherFirstChild.linkedHeightNode = firstChild;\n\t\t\tfirstChild.linkedWidthNode = otherSecondChild.linkedHeightNode = secondChild;\n\t\t\totherSecondChild.linkedWidthNode = firstChild.linkedHeightNode = otherFirstChild;\n\t\t\totherFirstChild.linkedWidthNode = secondChild.linkedHeightNode = otherSecondChild;\n\t\t} else {\n\t\t\totherFirstChild.linkedWidthNode = secondChild.linkedHeightNode = firstChild;\n\t\t\totherSecondChild.linkedWidthNode = firstChild.linkedHeightNode = secondChild;\n\t\t\tfirstChild.linkedWidthNode = otherSecondChild.linkedHeightNode = otherFirstChild;\n\t\t\tsecondChild.linkedWidthNode = otherFirstChild.linkedHeightNode = otherSecondChild;\n\t\t}\n\n\t\tconst mySash = this.splitview.sashes[0];\n\t\tconst otherSash = other.splitview.sashes[0];\n\t\tmySash.linkedSash = otherSash;\n\t\totherSash.linkedSash = mySash;\n\n\t\tthis._onDidChange.fire(undefined);\n\t\tother._onDidChange.fire(undefined);\n\n\t\treturn toDisposable(() => {\n\t\t\tmySash.linkedSash = otherSash.linkedSash = undefined;\n\t\t\tfirstChild.linkedHeightNode = firstChild.linkedWidthNode = undefined;\n\t\t\tsecondChild.linkedHeightNode = secondChild.linkedWidthNode = undefined;\n\t\t\totherFirstChild.linkedHeightNode = otherFirstChild.linkedWidthNode = undefined;\n\t\t\totherSecondChild.linkedHeightNode = otherSecondChild.linkedWidthNode = undefined;\n\t\t});\n\t}\n\n\tprivate updateSplitviewEdgeSnappingEnablement(): void {\n\t\tthis.splitview.startSnappingEnabled = this._edgeSnapping || this._absoluteOrthogonalOffset > 0;\n\t\tthis.splitview.endSnappingEnabled = this._edgeSnapping || this._absoluteOrthogonalOffset + this._size < this.absoluteOrthogonalSize;\n\t}\n\n\tdispose(): void {\n\t\tfor (const child of this.children) {\n\t\t\tchild.dispose();\n\t\t}\n\n\t\tthis._onDidChange.dispose();\n\t\tthis._onDidSashReset.dispose();\n\t\tthis._onDidVisibilityChange.dispose();\n\n\t\tthis.childrenVisibilityChangeDisposable.dispose();\n\t\tthis.splitviewSashResetDisposable.dispose();\n\t\tthis.childrenSashResetDisposable.dispose();\n\t\tthis.childrenChangeDisposable.dispose();\n\t\tthis.onDidScrollDisposable.dispose();\n\t\tthis.splitview.dispose();\n\t}\n}\n\n/**\n * Creates a latched event that avoids being fired when the view\n * constraints do not change at all.\n */\nfunction createLatchedOnDidChangeViewEvent(view: IView): Event<IViewSize | undefined> {\n\tconst [onDidChangeViewConstraints, onDidSetViewSize] = Event.split<undefined, IViewSize>(view.onDidChange, isUndefined);\n\n\treturn Event.any(\n\t\tonDidSetViewSize,\n\t\tEvent.map(\n\t\t\tEvent.latch(\n\t\t\t\tEvent.map(onDidChangeViewConstraints, _ => ([view.minimumWidth, view.maximumWidth, view.minimumHeight, view.maximumHeight])),\n\t\t\t\tarrayEquals\n\t\t\t),\n\t\t\t_ => undefined\n\t\t)\n\t);\n}\n\nclass LeafNode implements ISplitView<ILayoutContext>, IDisposable {\n\n\tprivate _size: number = 0;\n\tget size(): number { return this._size; }\n\n\tprivate _orthogonalSize: number;\n\tget orthogonalSize(): number { return this._orthogonalSize; }\n\n\tprivate absoluteOffset: number = 0;\n\tprivate absoluteOrthogonalOffset: number = 0;\n\n\treadonly onDidScroll: Event<void> = Event.None;\n\treadonly onDidSashReset: Event<GridLocation> = Event.None;\n\n\tprivate _onDidLinkedWidthNodeChange = new Relay<number | undefined>();\n\tprivate _linkedWidthNode: LeafNode | undefined = undefined;\n\tget linkedWidthNode(): LeafNode | undefined { return this._linkedWidthNode; }\n\tset linkedWidthNode(node: LeafNode | undefined) {\n\t\tthis._onDidLinkedWidthNodeChange.input = node ? node._onDidViewChange : Event.None;\n\t\tthis._linkedWidthNode = node;\n\t\tthis._onDidSetLinkedNode.fire(undefined);\n\t}\n\n\tprivate _onDidLinkedHeightNodeChange = new Relay<number | undefined>();\n\tprivate _linkedHeightNode: LeafNode | undefined = undefined;\n\tget linkedHeightNode(): LeafNode | undefined { return this._linkedHeightNode; }\n\tset linkedHeightNode(node: LeafNode | undefined) {\n\t\tthis._onDidLinkedHeightNodeChange.input = node ? node._onDidViewChange : Event.None;\n\t\tthis._linkedHeightNode = node;\n\t\tthis._onDidSetLinkedNode.fire(undefined);\n\t}\n\n\tprivate readonly _onDidSetLinkedNode = new Emitter<number | undefined>();\n\tprivate _onDidViewChange: Event<number | undefined>;\n\treadonly onDidChange: Event<number | undefined>;\n\n\tprivate readonly disposables = new DisposableStore();\n\n\tconstructor(\n\t\treadonly view: IView,\n\t\treadonly orientation: Orientation,\n\t\treadonly layoutController: LayoutController,\n\t\torthogonalSize: number,\n\t\tsize: number = 0\n\t) {\n\t\tthis._orthogonalSize = orthogonalSize;\n\t\tthis._size = size;\n\n\t\tconst onDidChange = createLatchedOnDidChangeViewEvent(view);\n\t\tthis._onDidViewChange = Event.map(onDidChange, e => e && (this.orientation === Orientation.VERTICAL ? e.width : e.height), this.disposables);\n\t\tthis.onDidChange = Event.any(this._onDidViewChange, this._onDidSetLinkedNode.event, this._onDidLinkedWidthNodeChange.event, this._onDidLinkedHeightNodeChange.event);\n\t}\n\n\tget width(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.orthogonalSize : this.size;\n\t}\n\n\tget height(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.size : this.orthogonalSize;\n\t}\n\n\tget top(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.absoluteOffset : this.absoluteOrthogonalOffset;\n\t}\n\n\tget left(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.absoluteOrthogonalOffset : this.absoluteOffset;\n\t}\n\n\tget element(): HTMLElement {\n\t\treturn this.view.element;\n\t}\n\n\tprivate get minimumWidth(): number {\n\t\treturn this.linkedWidthNode ? Math.max(this.linkedWidthNode.view.minimumWidth, this.view.minimumWidth) : this.view.minimumWidth;\n\t}\n\n\tprivate get maximumWidth(): number {\n\t\treturn this.linkedWidthNode ? Math.min(this.linkedWidthNode.view.maximumWidth, this.view.maximumWidth) : this.view.maximumWidth;\n\t}\n\n\tprivate get minimumHeight(): number {\n\t\treturn this.linkedHeightNode ? Math.max(this.linkedHeightNode.view.minimumHeight, this.view.minimumHeight) : this.view.minimumHeight;\n\t}\n\n\tprivate get maximumHeight(): number {\n\t\treturn this.linkedHeightNode ? Math.min(this.linkedHeightNode.view.maximumHeight, this.view.maximumHeight) : this.view.maximumHeight;\n\t}\n\n\tget minimumSize(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.minimumHeight : this.minimumWidth;\n\t}\n\n\tget maximumSize(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.maximumHeight : this.maximumWidth;\n\t}\n\n\tget priority(): LayoutPriority | undefined {\n\t\treturn this.view.priority;\n\t}\n\n\tget proportionalLayout(): boolean {\n\t\treturn this.view.proportionalLayout ?? true;\n\t}\n\n\tget snap(): boolean | undefined {\n\t\treturn this.view.snap;\n\t}\n\n\tget minimumOrthogonalSize(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.minimumWidth : this.minimumHeight;\n\t}\n\n\tget maximumOrthogonalSize(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.maximumWidth : this.maximumHeight;\n\t}\n\n\tprivate _boundarySashes: IRelativeBoundarySashes = {};\n\tget boundarySashes(): IRelativeBoundarySashes { return this._boundarySashes; }\n\tset boundarySashes(boundarySashes: IRelativeBoundarySashes) {\n\t\tthis._boundarySashes = boundarySashes;\n\n\t\tthis.view.setBoundarySashes?.(toAbsoluteBoundarySashes(boundarySashes, this.orientation));\n\t}\n\n\tlayout(size: number, offset: number, ctx: ILayoutContext | undefined): void {\n\t\tif (!this.layoutController.isLayoutEnabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof ctx === 'undefined') {\n\t\t\tthrow new Error('Invalid state');\n\t\t}\n\n\t\tthis._size = size;\n\t\tthis._orthogonalSize = ctx.orthogonalSize;\n\t\tthis.absoluteOffset = ctx.absoluteOffset + offset;\n\t\tthis.absoluteOrthogonalOffset = ctx.absoluteOrthogonalOffset;\n\n\t\tthis._layout(this.width, this.height, this.top, this.left);\n\t}\n\n\tprivate cachedWidth: number = 0;\n\tprivate cachedHeight: number = 0;\n\tprivate cachedTop: number = 0;\n\tprivate cachedLeft: number = 0;\n\n\tprivate _layout(width: number, height: number, top: number, left: number): void {\n\t\tif (this.cachedWidth === width && this.cachedHeight === height && this.cachedTop === top && this.cachedLeft === left) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.cachedWidth = width;\n\t\tthis.cachedHeight = height;\n\t\tthis.cachedTop = top;\n\t\tthis.cachedLeft = left;\n\t\tthis.view.layout(width, height, top, left);\n\t}\n\n\tsetVisible(visible: boolean): void {\n\t\tthis.view.setVisible?.(visible);\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\t}\n}\n\ntype Node = BranchNode | LeafNode;\n\nexport interface INodeDescriptor {\n\tnode: Node;\n\tvisible?: boolean;\n}\n\nfunction flipNode(node: BranchNode, size: number, orthogonalSize: number): BranchNode;\nfunction flipNode(node: LeafNode, size: number, orthogonalSize: number): LeafNode;\nfunction flipNode(node: Node, size: number, orthogonalSize: number): Node;\nfunction flipNode(node: Node, size: number, orthogonalSize: number): Node {\n\tif (node instanceof BranchNode) {\n\t\tconst result = new BranchNode(orthogonal(node.orientation), node.layoutController, node.styles, node.splitviewProportionalLayout, size, orthogonalSize, node.edgeSnapping);\n\n\t\tlet totalSize = 0;\n\n\t\tfor (let i = node.children.length - 1; i >= 0; i--) {\n\t\t\tconst child = node.children[i];\n\t\t\tconst childSize = child instanceof BranchNode ? child.orthogonalSize : child.size;\n\n\t\t\tlet newSize = node.size === 0 ? 0 : Math.round((size * childSize) / node.size);\n\t\t\ttotalSize += newSize;\n\n\t\t\t// The last view to add should adjust to rounding errors\n\t\t\tif (i === 0) {\n\t\t\t\tnewSize += size - totalSize;\n\t\t\t}\n\n\t\t\tresult.addChild(flipNode(child, orthogonalSize, newSize), newSize, 0, true);\n\t\t}\n\n\t\tnode.dispose();\n\t\treturn result;\n\t} else {\n\t\tconst result = new LeafNode(node.view, orthogonal(node.orientation), node.layoutController, orthogonalSize);\n\t\tnode.dispose();\n\t\treturn result;\n\t}\n}\n\n/**\n * The location of a {@link IView view} within a {@link GridView}.\n *\n * A GridView is a tree composition of multiple {@link SplitView} instances, orthogonal\n * between one another. Here's an example:\n *\n * ```\n *  +-----+---------------+\n *  |  A  |      B        |\n *  +-----+---------+-----+\n *  |        C      |     |\n *  +---------------+  D  |\n *  |        E      |     |\n *  +---------------+-----+\n * ```\n *\n * The above grid's tree structure is:\n *\n * ```\n *  Vertical SplitView\n *  +-Horizontal SplitView\n *  | +-A\n *  | +-B\n *  +- Horizontal SplitView\n *    +-Vertical SplitView\n *    | +-C\n *    | +-E\n *    +-D\n * ```\n *\n * So, {@link IView views} within a {@link GridView} can be referenced by\n * a sequence of indexes, each index referencing each SplitView. Here are\n * each view's locations, from the example above:\n *\n * - `A`: `[0,0]`\n * - `B`: `[0,1]`\n * - `C`: `[1,0,0]`\n * - `D`: `[1,1]`\n * - `E`: `[1,0,1]`\n */\nexport type GridLocation = number[];\n\n/**\n * The {@link GridView} is the UI component which implements a two dimensional\n * flex-like layout algorithm for a collection of {@link IView} instances, which\n * are mostly HTMLElement instances with size constraints. A {@link GridView} is a\n * tree composition of multiple {@link SplitView} instances, orthogonal between\n * one another. It will respect view's size contraints, just like the SplitView.\n *\n * It has a low-level index based API, allowing for fine grain performant operations.\n * Look into the {@link Grid} widget for a higher-level API.\n *\n * Features:\n * - flex-like layout algorithm\n * - snap support\n * - corner sash support\n * - Alt key modifier behavior, macOS style\n * - layout (de)serialization\n */\nexport class GridView implements IDisposable {\n\n\t/**\n\t * The DOM element for this view.\n\t */\n\treadonly element: HTMLElement;\n\n\tprivate styles: IGridViewStyles;\n\tprivate proportionalLayout: boolean;\n\tprivate _root!: BranchNode;\n\tprivate onDidSashResetRelay = new Relay<GridLocation>();\n\tprivate _onDidScroll = new Relay<void>();\n\tprivate _onDidChange = new Relay<IViewSize | undefined>();\n\tprivate _boundarySashes: IBoundarySashes = {};\n\n\t/**\n\t * The layout controller makes sure layout only propagates\n\t * to the views after the very first call to {@link GridView.layout}.\n\t */\n\tprivate layoutController: LayoutController;\n\tprivate disposable2x2: IDisposable = Disposable.None;\n\n\tprivate get root(): BranchNode { return this._root; }\n\n\tprivate set root(root: BranchNode) {\n\t\tconst oldRoot = this._root;\n\n\t\tif (oldRoot) {\n\t\t\toldRoot.element.remove();\n\t\t\toldRoot.dispose();\n\t\t}\n\n\t\tthis._root = root;\n\t\tthis.element.appendChild(root.element);\n\t\tthis.onDidSashResetRelay.input = root.onDidSashReset;\n\t\tthis._onDidChange.input = Event.map(root.onDidChange, () => undefined); // TODO\n\t\tthis._onDidScroll.input = root.onDidScroll;\n\t}\n\n\t/**\n\t * Fires whenever the user double clicks a {@link Sash sash}.\n\t */\n\treadonly onDidSashReset = this.onDidSashResetRelay.event;\n\n\t/**\n\t * Fires whenever the user scrolls a {@link SplitView} within\n\t * the grid.\n\t */\n\treadonly onDidScroll = this._onDidScroll.event;\n\n\t/**\n\t * Fires whenever a view within the grid changes its size constraints.\n\t */\n\treadonly onDidChange = this._onDidChange.event;\n\n\t/**\n\t * The width of the grid.\n\t */\n\tget width(): number { return this.root.width; }\n\n\t/**\n\t * The height of the grid.\n\t */\n\tget height(): number { return this.root.height; }\n\n\t/**\n\t * The minimum width of the grid.\n\t */\n\tget minimumWidth(): number { return this.root.minimumWidth; }\n\n\t/**\n\t * The minimum height of the grid.\n\t */\n\tget minimumHeight(): number { return this.root.minimumHeight; }\n\n\t/**\n\t * The maximum width of the grid.\n\t */\n\tget maximumWidth(): number { return this.root.maximumHeight; }\n\n\t/**\n\t * The maximum height of the grid.\n\t */\n\tget maximumHeight(): number { return this.root.maximumHeight; }\n\n\tget orientation(): Orientation { return this._root.orientation; }\n\tget boundarySashes(): IBoundarySashes { return this._boundarySashes; }\n\n\t/**\n\t * The orientation of the grid. Matches the orientation of the root\n\t * {@link SplitView} in the grid's tree model.\n\t */\n\tset orientation(orientation: Orientation) {\n\t\tif (this._root.orientation === orientation) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { size, orthogonalSize, absoluteOffset, absoluteOrthogonalOffset } = this._root;\n\t\tthis.root = flipNode(this._root, orthogonalSize, size);\n\t\tthis.root.layout(size, 0, { orthogonalSize, absoluteOffset: absoluteOrthogonalOffset, absoluteOrthogonalOffset: absoluteOffset, absoluteSize: size, absoluteOrthogonalSize: orthogonalSize });\n\t\tthis.boundarySashes = this.boundarySashes;\n\t}\n\n\t/**\n\t * A collection of sashes perpendicular to each edge of the grid.\n\t * Corner sashes will be created for each intersection.\n\t */\n\tset boundarySashes(boundarySashes: IBoundarySashes) {\n\t\tthis._boundarySashes = boundarySashes;\n\t\tthis.root.boundarySashes = fromAbsoluteBoundarySashes(boundarySashes, this.orientation);\n\t}\n\n\t/**\n\t * Enable/disable edge snapping across all grid views.\n\t */\n\tset edgeSnapping(edgeSnapping: boolean) {\n\t\tthis.root.edgeSnapping = edgeSnapping;\n\t}\n\n\tprivate maximizedNode: LeafNode | undefined = undefined;\n\n\tprivate readonly _onDidChangeViewMaximized = new Emitter<boolean>();\n\treadonly onDidChangeViewMaximized = this._onDidChangeViewMaximized.event;\n\n\t/**\n\t * Create a new {@link GridView} instance.\n\t *\n\t * @remarks It's the caller's responsibility to append the\n\t * {@link GridView.element} to the page's DOM.\n\t */\n\tconstructor(options: IGridViewOptions = {}) {\n\t\tthis.element = $('.monaco-grid-view');\n\t\tthis.styles = options.styles || defaultStyles;\n\t\tthis.proportionalLayout = typeof options.proportionalLayout !== 'undefined' ? !!options.proportionalLayout : true;\n\t\tthis.layoutController = new LayoutController(false);\n\t\tthis.root = new BranchNode(Orientation.VERTICAL, this.layoutController, this.styles, this.proportionalLayout);\n\t}\n\n\tstyle(styles: IGridViewStyles): void {\n\t\tthis.styles = styles;\n\t\tthis.root.style(styles);\n\t}\n\n\t/**\n\t * Layout the {@link GridView}.\n\t *\n\t * Optionally provide a `top` and `left` positions, those will propagate\n\t * as an origin for positions passed to {@link IView.layout}.\n\t *\n\t * @param width The width of the {@link GridView}.\n\t * @param height The height of the {@link GridView}.\n\t * @param top Optional, the top location of the {@link GridView}.\n\t * @param left Optional, the left location of the {@link GridView}.\n\t */\n\tlayout(width: number, height: number, top: number = 0, left: number = 0): void {\n\t\tthis.layoutController.isLayoutEnabled = true;\n\n\t\tconst [size, orthogonalSize, offset, orthogonalOffset] = this.root.orientation === Orientation.HORIZONTAL ? [height, width, top, left] : [width, height, left, top];\n\t\tthis.root.layout(size, 0, { orthogonalSize, absoluteOffset: offset, absoluteOrthogonalOffset: orthogonalOffset, absoluteSize: size, absoluteOrthogonalSize: orthogonalSize });\n\t}\n\n\t/**\n\t * Add a {@link IView view} to this {@link GridView}.\n\t *\n\t * @param view The view to add.\n\t * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.\n\t * @param location The {@link GridLocation location} to insert the view on.\n\t */\n\taddView(view: IView, size: number | Sizing, location: GridLocation): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tthis.disposable2x2.dispose();\n\t\tthis.disposable2x2 = Disposable.None;\n\n\t\tconst [rest, index] = tail(location);\n\t\tconst [pathToParent, parent] = this.getNode(rest);\n\n\t\tif (parent instanceof BranchNode) {\n\t\t\tconst node = new LeafNode(view, orthogonal(parent.orientation), this.layoutController, parent.orthogonalSize);\n\n\t\t\ttry {\n\t\t\t\tparent.addChild(node, size, index);\n\t\t\t} catch (err) {\n\t\t\t\tnode.dispose();\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t} else {\n\t\t\tconst [, grandParent] = tail(pathToParent);\n\t\t\tconst [, parentIndex] = tail(rest);\n\n\t\t\tlet newSiblingSize: number | Sizing = 0;\n\n\t\t\tconst newSiblingCachedVisibleSize = grandParent.getChildCachedVisibleSize(parentIndex);\n\t\t\tif (typeof newSiblingCachedVisibleSize === 'number') {\n\t\t\t\tnewSiblingSize = Sizing.Invisible(newSiblingCachedVisibleSize);\n\t\t\t}\n\n\t\t\tconst oldChild = grandParent.removeChild(parentIndex);\n\t\t\toldChild.dispose();\n\n\t\t\tconst newParent = new BranchNode(parent.orientation, parent.layoutController, this.styles, this.proportionalLayout, parent.size, parent.orthogonalSize, grandParent.edgeSnapping);\n\t\t\tgrandParent.addChild(newParent, parent.size, parentIndex);\n\n\t\t\tconst newSibling = new LeafNode(parent.view, grandParent.orientation, this.layoutController, parent.size);\n\t\t\tnewParent.addChild(newSibling, newSiblingSize, 0);\n\n\t\t\tif (typeof size !== 'number' && size.type === 'split') {\n\t\t\t\tsize = Sizing.Split(0);\n\t\t\t}\n\n\t\t\tconst node = new LeafNode(view, grandParent.orientation, this.layoutController, parent.size);\n\t\t\tnewParent.addChild(node, size, index);\n\t\t}\n\n\t\tthis.trySet2x2();\n\t}\n\n\t/**\n\t * Remove a {@link IView view} from this {@link GridView}.\n\t *\n\t * @param location The {@link GridLocation location} of the {@link IView view}.\n\t * @param sizing Whether to distribute other {@link IView view}'s sizes.\n\t */\n\tremoveView(location: GridLocation, sizing?: DistributeSizing | AutoSizing): IView {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tthis.disposable2x2.dispose();\n\t\tthis.disposable2x2 = Disposable.None;\n\n\t\tconst [rest, index] = tail(location);\n\t\tconst [pathToParent, parent] = this.getNode(rest);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tconst node = parent.children[index];\n\n\t\tif (!(node instanceof LeafNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tparent.removeChild(index, sizing);\n\t\tnode.dispose();\n\n\t\tif (parent.children.length === 0) {\n\t\t\tthrow new Error('Invalid grid state');\n\t\t}\n\n\t\tif (parent.children.length > 1) {\n\t\t\tthis.trySet2x2();\n\t\t\treturn node.view;\n\t\t}\n\n\t\tif (pathToParent.length === 0) { // parent is root\n\t\t\tconst sibling = parent.children[0];\n\n\t\t\tif (sibling instanceof LeafNode) {\n\t\t\t\treturn node.view;\n\t\t\t}\n\n\t\t\t// we must promote sibling to be the new root\n\t\t\tparent.removeChild(0);\n\t\t\tparent.dispose();\n\t\t\tthis.root = sibling;\n\t\t\tthis.boundarySashes = this.boundarySashes;\n\t\t\tthis.trySet2x2();\n\t\t\treturn node.view;\n\t\t}\n\n\t\tconst [, grandParent] = tail(pathToParent);\n\t\tconst [, parentIndex] = tail(rest);\n\n\t\tconst isSiblingVisible = parent.isChildVisible(0);\n\t\tconst sibling = parent.removeChild(0);\n\n\t\tconst sizes = grandParent.children.map((_, i) => grandParent.getChildSize(i));\n\t\tgrandParent.removeChild(parentIndex, sizing);\n\t\tparent.dispose();\n\n\t\tif (sibling instanceof BranchNode) {\n\t\t\tsizes.splice(parentIndex, 1, ...sibling.children.map(c => c.size));\n\n\t\t\tconst siblingChildren = sibling.removeAllChildren();\n\n\t\t\tfor (let i = 0; i < siblingChildren.length; i++) {\n\t\t\t\tgrandParent.addChild(siblingChildren[i], siblingChildren[i].size, parentIndex + i);\n\t\t\t}\n\t\t} else {\n\t\t\tconst newSibling = new LeafNode(sibling.view, orthogonal(sibling.orientation), this.layoutController, sibling.size);\n\t\t\tconst sizing = isSiblingVisible ? sibling.orthogonalSize : Sizing.Invisible(sibling.orthogonalSize);\n\t\t\tgrandParent.addChild(newSibling, sizing, parentIndex);\n\t\t}\n\n\t\tsibling.dispose();\n\n\t\tfor (let i = 0; i < sizes.length; i++) {\n\t\t\tgrandParent.resizeChild(i, sizes[i]);\n\t\t}\n\n\t\tthis.trySet2x2();\n\t\treturn node.view;\n\t}\n\n\t/**\n\t * Move a {@link IView view} within its parent.\n\t *\n\t * @param parentLocation The {@link GridLocation location} of the {@link IView view}'s parent.\n\t * @param from The index of the {@link IView view} to move.\n\t * @param to The index where the {@link IView view} should move to.\n\t */\n\tmoveView(parentLocation: GridLocation, from: number, to: number): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tconst [, parent] = this.getNode(parentLocation);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tparent.moveChild(from, to);\n\n\t\tthis.trySet2x2();\n\t}\n\n\t/**\n\t * Swap two {@link IView views} within the {@link GridView}.\n\t *\n\t * @param from The {@link GridLocation location} of one view.\n\t * @param to The {@link GridLocation location} of another view.\n\t */\n\tswapViews(from: GridLocation, to: GridLocation): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tconst [fromRest, fromIndex] = tail(from);\n\t\tconst [, fromParent] = this.getNode(fromRest);\n\n\t\tif (!(fromParent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid from location');\n\t\t}\n\n\t\tconst fromSize = fromParent.getChildSize(fromIndex);\n\t\tconst fromNode = fromParent.children[fromIndex];\n\n\t\tif (!(fromNode instanceof LeafNode)) {\n\t\t\tthrow new Error('Invalid from location');\n\t\t}\n\n\t\tconst [toRest, toIndex] = tail(to);\n\t\tconst [, toParent] = this.getNode(toRest);\n\n\t\tif (!(toParent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid to location');\n\t\t}\n\n\t\tconst toSize = toParent.getChildSize(toIndex);\n\t\tconst toNode = toParent.children[toIndex];\n\n\t\tif (!(toNode instanceof LeafNode)) {\n\t\t\tthrow new Error('Invalid to location');\n\t\t}\n\n\t\tif (fromParent === toParent) {\n\t\t\tfromParent.swapChildren(fromIndex, toIndex);\n\t\t} else {\n\t\t\tfromParent.removeChild(fromIndex);\n\t\t\ttoParent.removeChild(toIndex);\n\n\t\t\tfromParent.addChild(toNode, fromSize, fromIndex);\n\t\t\ttoParent.addChild(fromNode, toSize, toIndex);\n\t\t}\n\n\t\tthis.trySet2x2();\n\t}\n\n\t/**\n\t * Resize a {@link IView view}.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t * @param size The size the view should be. Optionally provide a single dimension.\n\t */\n\tresizeView(location: GridLocation, size: Partial<IViewSize>): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tconst [rest, index] = tail(location);\n\t\tconst [pathToParent, parent] = this.getNode(rest);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tif (!size.width && !size.height) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [parentSize, grandParentSize] = parent.orientation === Orientation.HORIZONTAL ? [size.width, size.height] : [size.height, size.width];\n\n\t\tif (typeof grandParentSize === 'number' && pathToParent.length > 0) {\n\t\t\tconst [, grandParent] = tail(pathToParent);\n\t\t\tconst [, parentIndex] = tail(rest);\n\n\t\t\tgrandParent.resizeChild(parentIndex, grandParentSize);\n\t\t}\n\n\t\tif (typeof parentSize === 'number') {\n\t\t\tparent.resizeChild(index, parentSize);\n\t\t}\n\n\t\tthis.trySet2x2();\n\t}\n\n\t/**\n\t * Get the size of a {@link IView view}.\n\t *\n\t * @param location The {@link GridLocation location} of the view. Provide `undefined` to get\n\t * the size of the grid itself.\n\t */\n\tgetViewSize(location?: GridLocation): IViewSize {\n\t\tif (!location) {\n\t\t\treturn { width: this.root.width, height: this.root.height };\n\t\t}\n\n\t\tconst [, node] = this.getNode(location);\n\t\treturn { width: node.width, height: node.height };\n\t}\n\n\t/**\n\t * Get the cached visible size of a {@link IView view}. This was the size\n\t * of the view at the moment it last became hidden.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\tgetViewCachedVisibleSize(location: GridLocation): number | undefined {\n\t\tconst [rest, index] = tail(location);\n\t\tconst [, parent] = this.getNode(rest);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\treturn parent.getChildCachedVisibleSize(index);\n\t}\n\n\t/**\n\t * Maximize the size of a {@link IView view} by collapsing all other views\n\t * to their minimum sizes.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\texpandView(location: GridLocation): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tconst [ancestors, node] = this.getNode(location);\n\n\t\tif (!(node instanceof LeafNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tfor (let i = 0; i < ancestors.length; i++) {\n\t\t\tancestors[i].resizeChild(location[i], Number.POSITIVE_INFINITY);\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether all other {@link IView views} are at their minimum size.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\tisViewExpanded(location: GridLocation): boolean {\n\t\tif (this.hasMaximizedView()) {\n\t\t\t// No view can be expanded when a view is maximized\n\t\t\treturn false;\n\t\t}\n\n\t\tconst [ancestors, node] = this.getNode(location);\n\n\t\tif (!(node instanceof LeafNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tfor (let i = 0; i < ancestors.length; i++) {\n\t\t\tif (!ancestors[i].isChildExpanded(location[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tmaximizeView(location: GridLocation) {\n\t\tconst [, nodeToMaximize] = this.getNode(location);\n\t\tif (!(nodeToMaximize instanceof LeafNode)) {\n\t\t\tthrow new Error('Location is not a LeafNode');\n\t\t}\n\n\t\tif (this.maximizedNode === nodeToMaximize) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tfunction hideAllViewsBut(parent: BranchNode, exclude: LeafNode): void {\n\t\t\tfor (let i = 0; i < parent.children.length; i++) {\n\t\t\t\tconst child = parent.children[i];\n\t\t\t\tif (child instanceof LeafNode) {\n\t\t\t\t\tif (child !== exclude) {\n\t\t\t\t\t\tparent.setChildVisible(i, false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thideAllViewsBut(child, exclude);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thideAllViewsBut(this.root, nodeToMaximize);\n\n\t\tthis.maximizedNode = nodeToMaximize;\n\t\tthis._onDidChangeViewMaximized.fire(true);\n\t}\n\n\texitMaximizedView(): void {\n\t\tif (!this.maximizedNode) {\n\t\t\treturn;\n\t\t}\n\t\tthis.maximizedNode = undefined;\n\n\t\t// When hiding a view, it's previous size is cached.\n\t\t// To restore the sizes of all views, they need to be made visible in reverse order.\n\t\tfunction showViewsInReverseOrder(parent: BranchNode): void {\n\t\t\tfor (let index = parent.children.length - 1; index >= 0; index--) {\n\t\t\t\tconst child = parent.children[index];\n\t\t\t\tif (child instanceof LeafNode) {\n\t\t\t\t\tparent.setChildVisible(index, true);\n\t\t\t\t} else {\n\t\t\t\t\tshowViewsInReverseOrder(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tshowViewsInReverseOrder(this.root);\n\n\t\tthis._onDidChangeViewMaximized.fire(false);\n\t}\n\n\thasMaximizedView(): boolean {\n\t\treturn this.maximizedNode !== undefined;\n\t}\n\n\t/**\n\t * Returns whether the {@link IView view} is maximized.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\tisViewMaximized(location: GridLocation): boolean {\n\t\tconst [, node] = this.getNode(location);\n\t\tif (!(node instanceof LeafNode)) {\n\t\t\tthrow new Error('Location is not a LeafNode');\n\t\t}\n\t\treturn node === this.maximizedNode;\n\t}\n\n\t/**\n\t * Distribute the size among all {@link IView views} within the entire\n\t * grid or within a single {@link SplitView}.\n\t *\n\t * @param location The {@link GridLocation location} of a view containing\n\t * children views, which will have their sizes distributed within the parent\n\t * view's size. Provide `undefined` to recursively distribute all views' sizes\n\t * in the entire grid.\n\t */\n\tdistributeViewSizes(location?: GridLocation): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tif (!location) {\n\t\t\tthis.root.distributeViewSizes(true);\n\t\t\treturn;\n\t\t}\n\n\t\tconst [, node] = this.getNode(location);\n\n\t\tif (!(node instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tnode.distributeViewSizes();\n\t\tthis.trySet2x2();\n\t}\n\n\t/**\n\t * Returns whether a {@link IView view} is visible.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\tisViewVisible(location: GridLocation): boolean {\n\t\tconst [rest, index] = tail(location);\n\t\tconst [, parent] = this.getNode(rest);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid from location');\n\t\t}\n\n\t\treturn parent.isChildVisible(index);\n\t}\n\n\t/**\n\t * Set the visibility state of a {@link IView view}.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\tsetViewVisible(location: GridLocation, visible: boolean): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t\treturn;\n\t\t}\n\n\t\tconst [rest, index] = tail(location);\n\t\tconst [, parent] = this.getNode(rest);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid from location');\n\t\t}\n\n\t\tparent.setChildVisible(index, visible);\n\t}\n\n\t/**\n\t * Returns a descriptor for the entire grid.\n\t */\n\tgetView(): GridBranchNode;\n\n\t/**\n\t * Returns a descriptor for a {@link GridLocation subtree} within the\n\t * {@link GridView}.\n\t *\n\t * @param location The {@link GridLocation location} of the root of\n\t * the {@link GridLocation subtree}.\n\t */\n\tgetView(location: GridLocation): GridNode;\n\tgetView(location?: GridLocation): GridNode {\n\t\tconst node = location ? this.getNode(location)[1] : this._root;\n\t\treturn this._getViews(node, this.orientation);\n\t}\n\n\t/**\n\t * Construct a new {@link GridView} from a JSON object.\n\t *\n\t * @param json The JSON object.\n\t * @param deserializer A deserializer which can revive each view.\n\t * @returns A new {@link GridView} instance.\n\t */\n\tstatic deserialize<T extends ISerializableView>(json: ISerializedGridView, deserializer: IViewDeserializer<T>, options: IGridViewOptions = {}): GridView {\n\t\tif (typeof json.orientation !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'orientation\\' property must be a number.');\n\t\t} else if (typeof json.width !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'width\\' property must be a number.');\n\t\t} else if (typeof json.height !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'height\\' property must be a number.');\n\t\t} else if (json.root?.type !== 'branch') {\n\t\t\tthrow new Error('Invalid JSON: \\'root\\' property must have \\'type\\' value of branch.');\n\t\t}\n\n\t\tconst orientation = json.orientation;\n\t\tconst height = json.height;\n\n\t\tconst result = new GridView(options);\n\t\tresult._deserialize(json.root, orientation, deserializer, height);\n\n\t\treturn result;\n\t}\n\n\tprivate _deserialize(root: ISerializedBranchNode, orientation: Orientation, deserializer: IViewDeserializer<ISerializableView>, orthogonalSize: number): void {\n\t\tthis.root = this._deserializeNode(root, orientation, deserializer, orthogonalSize) as BranchNode;\n\t}\n\n\tprivate _deserializeNode(node: ISerializedNode, orientation: Orientation, deserializer: IViewDeserializer<ISerializableView>, orthogonalSize: number): Node {\n\t\tlet result: Node;\n\t\tif (node.type === 'branch') {\n\t\t\tconst serializedChildren = node.data;\n\t\t\tconst children = serializedChildren.map(serializedChild => {\n\t\t\t\treturn {\n\t\t\t\t\tnode: this._deserializeNode(serializedChild, orthogonal(orientation), deserializer, node.size),\n\t\t\t\t\tvisible: (serializedChild as { visible?: boolean }).visible\n\t\t\t\t} satisfies INodeDescriptor;\n\t\t\t});\n\n\t\t\tresult = new BranchNode(orientation, this.layoutController, this.styles, this.proportionalLayout, node.size, orthogonalSize, undefined, children);\n\t\t} else {\n\t\t\tresult = new LeafNode(deserializer.fromJSON(node.data), orientation, this.layoutController, orthogonalSize, node.size);\n\t\t\tif (node.maximized && !this.maximizedNode) {\n\t\t\t\tthis.maximizedNode = result;\n\t\t\t\tthis._onDidChangeViewMaximized.fire(true);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate _getViews(node: Node, orientation: Orientation, cachedVisibleSize?: number): GridNode {\n\t\tconst box = { top: node.top, left: node.left, width: node.width, height: node.height };\n\n\t\tif (node instanceof LeafNode) {\n\t\t\treturn { view: node.view, box, cachedVisibleSize, maximized: this.maximizedNode === node };\n\t\t}\n\n\t\tconst children: GridNode[] = [];\n\n\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\tconst child = node.children[i];\n\t\t\tconst cachedVisibleSize = node.getChildCachedVisibleSize(i);\n\n\t\t\tchildren.push(this._getViews(child, orthogonal(orientation), cachedVisibleSize));\n\t\t}\n\n\t\treturn { children, box };\n\t}\n\n\tprivate getNode(location: GridLocation, node: Node = this.root, path: BranchNode[] = []): [BranchNode[], Node] {\n\t\tif (location.length === 0) {\n\t\t\treturn [path, node];\n\t\t}\n\n\t\tif (!(node instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index >= node.children.length) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tconst child = node.children[index];\n\t\tpath.push(node);\n\n\t\treturn this.getNode(rest, child, path);\n\t}\n\n\t/**\n\t * Attempt to lock the {@link Sash sashes} in this {@link GridView} so\n\t * the grid behaves as a 2x2 matrix, with a corner sash in the middle.\n\t *\n\t * In case the grid isn't a 2x2 grid _and_ all sashes are not aligned,\n\t * this method is a no-op.\n\t */\n\ttrySet2x2(): void {\n\t\tthis.disposable2x2.dispose();\n\t\tthis.disposable2x2 = Disposable.None;\n\n\t\tif (this.root.children.length !== 2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [first, second] = this.root.children;\n\n\t\tif (!(first instanceof BranchNode) || !(second instanceof BranchNode)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.disposable2x2 = first.trySet2x2(second);\n\t}\n\n\t/**\n\t * Populate a map with views to DOM nodes.\n\t * @remarks To be used internally only.\n\t */\n\tgetViewMap(map: Map<IView, HTMLElement>, node?: Node): void {\n\t\tif (!node) {\n\t\t\tnode = this.root;\n\t\t}\n\n\t\tif (node instanceof BranchNode) {\n\t\t\tnode.children.forEach(child => this.getViewMap(map, child));\n\t\t} else {\n\t\t\tmap.set(node.view, node.element);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.onDidSashResetRelay.dispose();\n\t\tthis.root.dispose();\n\t\tthis.element.remove();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { $ } from '../../dom.js';\nimport { IBoundarySashes, Orientation, Sash } from '../sash/sash.js';\nimport { DistributeSizing, ISplitViewStyles, IView as ISplitView, LayoutPriority, Sizing, AutoSizing, SplitView } from '../splitview/splitview.js';\nimport { equals as arrayEquals, tail } from '../../../common/arrays.js';\nimport { Color } from '../../../common/color.js';\nimport { Emitter, Event, Relay } from '../../../common/event.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../common/lifecycle.js';\nimport { rot } from '../../../common/numbers.js';\nimport { isUndefined } from '../../../common/types.js';\nimport './gridview.css';\n\nexport { Orientation } from '../sash/sash.js';\nexport { LayoutPriority, Sizing } from '../splitview/splitview.js';\n\nexport interface IGridViewStyles extends ISplitViewStyles { }\n\nconst defaultStyles: IGridViewStyles = {\n\tseparatorBorder: Color.transparent\n};\n\nexport interface IViewSize {\n\treadonly width: number;\n\treadonly height: number;\n}\n\ninterface IRelativeBoundarySashes {\n\treadonly start?: Sash;\n\treadonly end?: Sash;\n\treadonly orthogonalStart?: Sash;\n\treadonly orthogonalEnd?: Sash;\n}\n\n/**\n * The interface to implement for views within a {@link GridView}.\n */\nexport interface IView {\n\n\t/**\n\t * The DOM element for this view.\n\t */\n\treadonly element: HTMLElement;\n\n\t/**\n\t * A minimum width for this view.\n\t *\n\t * @remarks If none, set it to `0`.\n\t */\n\treadonly minimumWidth: number;\n\n\t/**\n\t * A minimum width for this view.\n\t *\n\t * @remarks If none, set it to `Number.POSITIVE_INFINITY`.\n\t */\n\treadonly maximumWidth: number;\n\n\t/**\n\t * A minimum height for this view.\n\t *\n\t * @remarks If none, set it to `0`.\n\t */\n\treadonly minimumHeight: number;\n\n\t/**\n\t * A minimum height for this view.\n\t *\n\t * @remarks If none, set it to `Number.POSITIVE_INFINITY`.\n\t */\n\treadonly maximumHeight: number;\n\n\t/**\n\t * The priority of the view when the {@link GridView} layout algorithm\n\t * runs. Views with higher priority will be resized first.\n\t *\n\t * @remarks Only used when `proportionalLayout` is false.\n\t */\n\treadonly priority?: LayoutPriority;\n\n\t/**\n\t * If the {@link GridView} supports proportional layout,\n\t * this property allows for finer control over the proportional layout algorithm, per view.\n\t *\n\t * @defaultValue `true`\n\t */\n\treadonly proportionalLayout?: boolean;\n\n\t/**\n\t * Whether the view will snap whenever the user reaches its minimum size or\n\t * attempts to grow it beyond the minimum size.\n\t *\n\t * @defaultValue `false`\n\t */\n\treadonly snap?: boolean;\n\n\t/**\n\t * View instances are supposed to fire this event whenever any of the constraint\n\t * properties have changed:\n\t *\n\t * - {@link IView.minimumWidth}\n\t * - {@link IView.maximumWidth}\n\t * - {@link IView.minimumHeight}\n\t * - {@link IView.maximumHeight}\n\t * - {@link IView.priority}\n\t * - {@link IView.snap}\n\t *\n\t * The {@link GridView} will relayout whenever that happens. The event can\n\t * optionally emit the view's preferred size for that relayout.\n\t */\n\treadonly onDidChange: Event<IViewSize | undefined>;\n\n\t/**\n\t * This will be called by the {@link GridView} during layout. A view meant to\n\t * pass along the layout information down to its descendants.\n\t */\n\tlayout(width: number, height: number, top: number, left: number): void;\n\n\t/**\n\t * This will be called by the {@link GridView} whenever this view is made\n\t * visible or hidden.\n\t *\n\t * @param visible Whether the view becomes visible.\n\t */\n\tsetVisible?(visible: boolean): void;\n\n\t/**\n\t * This will be called by the {@link GridView} whenever this view is on\n\t * an edge of the grid and the grid's\n\t * {@link GridView.boundarySashes boundary sashes} change.\n\t */\n\tsetBoundarySashes?(sashes: IBoundarySashes): void;\n}\n\nexport interface ISerializableView extends IView {\n\ttoJSON(): object;\n}\n\nexport interface IViewDeserializer<T extends ISerializableView> {\n\tfromJSON(json: any): T;\n}\n\nexport interface ISerializedLeafNode {\n\ttype: 'leaf';\n\tdata: unknown;\n\tsize: number;\n\tvisible?: boolean;\n\tmaximized?: boolean;\n}\n\nexport interface ISerializedBranchNode {\n\ttype: 'branch';\n\tdata: ISerializedNode[];\n\tsize: number;\n\tvisible?: boolean;\n}\n\nexport type ISerializedNode = ISerializedLeafNode | ISerializedBranchNode;\n\nexport interface ISerializedGridView {\n\troot: ISerializedNode;\n\torientation: Orientation;\n\twidth: number;\n\theight: number;\n}\n\nexport function orthogonal(orientation: Orientation): Orientation {\n\treturn orientation === Orientation.VERTICAL ? Orientation.HORIZONTAL : Orientation.VERTICAL;\n}\n\nexport interface Box {\n\treadonly top: number;\n\treadonly left: number;\n\treadonly width: number;\n\treadonly height: number;\n}\n\nexport interface GridLeafNode {\n\treadonly view: IView;\n\treadonly box: Box;\n\treadonly cachedVisibleSize: number | undefined;\n\treadonly maximized: boolean;\n}\n\nexport interface GridBranchNode {\n\treadonly children: GridNode[];\n\treadonly box: Box;\n}\n\nexport type GridNode = GridLeafNode | GridBranchNode;\n\nexport function isGridBranchNode(node: GridNode): node is GridBranchNode {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!(node as any).children;\n}\n\nclass LayoutController {\n\tconstructor(public isLayoutEnabled: boolean) { }\n}\n\nexport interface IGridViewOptions {\n\n\t/**\n\t * Styles overriding the {@link defaultStyles default ones}.\n\t */\n\treadonly styles?: IGridViewStyles;\n\n\t/**\n\t * Resize each view proportionally when resizing the {@link GridView}.\n\t *\n\t * @defaultValue `true`\n\t */\n\treadonly proportionalLayout?: boolean; // default true\n}\n\ninterface ILayoutContext {\n\treadonly orthogonalSize: number;\n\treadonly absoluteOffset: number;\n\treadonly absoluteOrthogonalOffset: number;\n\treadonly absoluteSize: number;\n\treadonly absoluteOrthogonalSize: number;\n}\n\nfunction toAbsoluteBoundarySashes(sashes: IRelativeBoundarySashes, orientation: Orientation): IBoundarySashes {\n\tif (orientation === Orientation.HORIZONTAL) {\n\t\treturn { left: sashes.start, right: sashes.end, top: sashes.orthogonalStart, bottom: sashes.orthogonalEnd };\n\t} else {\n\t\treturn { top: sashes.start, bottom: sashes.end, left: sashes.orthogonalStart, right: sashes.orthogonalEnd };\n\t}\n}\n\nfunction fromAbsoluteBoundarySashes(sashes: IBoundarySashes, orientation: Orientation): IRelativeBoundarySashes {\n\tif (orientation === Orientation.HORIZONTAL) {\n\t\treturn { start: sashes.left, end: sashes.right, orthogonalStart: sashes.top, orthogonalEnd: sashes.bottom };\n\t} else {\n\t\treturn { start: sashes.top, end: sashes.bottom, orthogonalStart: sashes.left, orthogonalEnd: sashes.right };\n\t}\n}\n\nfunction validateIndex(index: number, numChildren: number): number {\n\tif (Math.abs(index) > numChildren) {\n\t\tthrow new Error('Invalid index');\n\t}\n\n\treturn rot(index, numChildren + 1);\n}\n\nclass BranchNode implements ISplitView<ILayoutContext>, IDisposable {\n\n\treadonly element: HTMLElement;\n\treadonly children: Node[] = [];\n\tprivate splitview: SplitView<ILayoutContext, Node>;\n\n\tprivate _size: number;\n\tget size(): number { return this._size; }\n\n\tprivate _orthogonalSize: number;\n\tget orthogonalSize(): number { return this._orthogonalSize; }\n\n\tprivate _absoluteOffset: number = 0;\n\tget absoluteOffset(): number { return this._absoluteOffset; }\n\n\tprivate _absoluteOrthogonalOffset: number = 0;\n\tget absoluteOrthogonalOffset(): number { return this._absoluteOrthogonalOffset; }\n\n\tprivate absoluteOrthogonalSize: number = 0;\n\n\tprivate _styles: IGridViewStyles;\n\tget styles(): IGridViewStyles { return this._styles; }\n\n\tget width(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.size : this.orthogonalSize;\n\t}\n\n\tget height(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.orthogonalSize : this.size;\n\t}\n\n\tget top(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this._absoluteOffset : this._absoluteOrthogonalOffset;\n\t}\n\n\tget left(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this._absoluteOrthogonalOffset : this._absoluteOffset;\n\t}\n\n\tget minimumSize(): number {\n\t\treturn this.children.length === 0 ? 0 : Math.max(...this.children.map((c, index) => this.splitview.isViewVisible(index) ? c.minimumOrthogonalSize : 0));\n\t}\n\n\tget maximumSize(): number {\n\t\treturn Math.min(...this.children.map((c, index) => this.splitview.isViewVisible(index) ? c.maximumOrthogonalSize : Number.POSITIVE_INFINITY));\n\t}\n\n\tget priority(): LayoutPriority {\n\t\tif (this.children.length === 0) {\n\t\t\treturn LayoutPriority.Normal;\n\t\t}\n\n\t\tconst priorities = this.children.map(c => typeof c.priority === 'undefined' ? LayoutPriority.Normal : c.priority);\n\n\t\tif (priorities.some(p => p === LayoutPriority.High)) {\n\t\t\treturn LayoutPriority.High;\n\t\t} else if (priorities.some(p => p === LayoutPriority.Low)) {\n\t\t\treturn LayoutPriority.Low;\n\t\t}\n\n\t\treturn LayoutPriority.Normal;\n\t}\n\n\tget proportionalLayout(): boolean {\n\t\tif (this.children.length === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn this.children.every(c => c.proportionalLayout);\n\t}\n\n\tget minimumOrthogonalSize(): number {\n\t\treturn this.splitview.minimumSize;\n\t}\n\n\tget maximumOrthogonalSize(): number {\n\t\treturn this.splitview.maximumSize;\n\t}\n\n\tget minimumWidth(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.minimumOrthogonalSize : this.minimumSize;\n\t}\n\n\tget minimumHeight(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.minimumSize : this.minimumOrthogonalSize;\n\t}\n\n\tget maximumWidth(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.maximumOrthogonalSize : this.maximumSize;\n\t}\n\n\tget maximumHeight(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.maximumSize : this.maximumOrthogonalSize;\n\t}\n\n\tprivate readonly _onDidChange = new Emitter<number | undefined>();\n\treadonly onDidChange: Event<number | undefined> = this._onDidChange.event;\n\n\tprivate readonly _onDidVisibilityChange = new Emitter<boolean>();\n\treadonly onDidVisibilityChange: Event<boolean> = this._onDidVisibilityChange.event;\n\tprivate readonly childrenVisibilityChangeDisposable: DisposableStore = new DisposableStore();\n\n\tprivate _onDidScroll = new Emitter<void>();\n\tprivate onDidScrollDisposable: IDisposable = Disposable.None;\n\treadonly onDidScroll: Event<void> = this._onDidScroll.event;\n\n\tprivate childrenChangeDisposable: IDisposable = Disposable.None;\n\n\tprivate readonly _onDidSashReset = new Emitter<GridLocation>();\n\treadonly onDidSashReset: Event<GridLocation> = this._onDidSashReset.event;\n\tprivate splitviewSashResetDisposable: IDisposable = Disposable.None;\n\tprivate childrenSashResetDisposable: IDisposable = Disposable.None;\n\n\tprivate _boundarySashes: IRelativeBoundarySashes = {};\n\tget boundarySashes(): IRelativeBoundarySashes { return this._boundarySashes; }\n\tset boundarySashes(boundarySashes: IRelativeBoundarySashes) {\n\t\tif (this._boundarySashes.start === boundarySashes.start\n\t\t\t&& this._boundarySashes.end === boundarySashes.end\n\t\t\t&& this._boundarySashes.orthogonalStart === boundarySashes.orthogonalStart\n\t\t\t&& this._boundarySashes.orthogonalEnd === boundarySashes.orthogonalEnd) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._boundarySashes = boundarySashes;\n\n\t\tthis.splitview.orthogonalStartSash = boundarySashes.orthogonalStart;\n\t\tthis.splitview.orthogonalEndSash = boundarySashes.orthogonalEnd;\n\n\t\tfor (let index = 0; index < this.children.length; index++) {\n\t\t\tconst child = this.children[index];\n\t\t\tconst first = index === 0;\n\t\t\tconst last = index === this.children.length - 1;\n\n\t\t\tchild.boundarySashes = {\n\t\t\t\tstart: boundarySashes.orthogonalStart,\n\t\t\t\tend: boundarySashes.orthogonalEnd,\n\t\t\t\torthogonalStart: first ? boundarySashes.start : child.boundarySashes.orthogonalStart,\n\t\t\t\torthogonalEnd: last ? boundarySashes.end : child.boundarySashes.orthogonalEnd,\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate _edgeSnapping = false;\n\tget edgeSnapping(): boolean { return this._edgeSnapping; }\n\tset edgeSnapping(edgeSnapping: boolean) {\n\t\tif (this._edgeSnapping === edgeSnapping) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._edgeSnapping = edgeSnapping;\n\n\t\tfor (const child of this.children) {\n\t\t\tif (child instanceof BranchNode) {\n\t\t\t\tchild.edgeSnapping = edgeSnapping;\n\t\t\t}\n\t\t}\n\n\t\tthis.updateSplitviewEdgeSnappingEnablement();\n\t}\n\n\tconstructor(\n\t\treadonly orientation: Orientation,\n\t\treadonly layoutController: LayoutController,\n\t\tstyles: IGridViewStyles,\n\t\treadonly splitviewProportionalLayout: boolean,\n\t\tsize: number = 0,\n\t\torthogonalSize: number = 0,\n\t\tedgeSnapping: boolean = false,\n\t\tchildDescriptors?: INodeDescriptor[]\n\t) {\n\t\tthis._styles = styles;\n\t\tthis._size = size;\n\t\tthis._orthogonalSize = orthogonalSize;\n\n\t\tthis.element = $('.monaco-grid-branch-node');\n\n\t\tif (!childDescriptors) {\n\t\t\t// Normal behavior, we have no children yet, just set up the splitview\n\t\t\tthis.splitview = new SplitView(this.element, { orientation, styles, proportionalLayout: splitviewProportionalLayout });\n\t\t\tthis.splitview.layout(size, { orthogonalSize, absoluteOffset: 0, absoluteOrthogonalOffset: 0, absoluteSize: size, absoluteOrthogonalSize: orthogonalSize });\n\t\t} else {\n\t\t\t// Reconstruction behavior, we want to reconstruct a splitview\n\t\t\tconst descriptor = {\n\t\t\t\tviews: childDescriptors.map(childDescriptor => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tview: childDescriptor.node,\n\t\t\t\t\t\tsize: childDescriptor.node.size,\n\t\t\t\t\t\tvisible: childDescriptor.visible !== false\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t\tsize: this.orthogonalSize\n\t\t\t};\n\n\t\t\tconst options = { proportionalLayout: splitviewProportionalLayout, orientation, styles };\n\n\t\t\tthis.children = childDescriptors.map(c => c.node);\n\t\t\tthis.splitview = new SplitView(this.element, { ...options, descriptor });\n\n\t\t\tthis.children.forEach((node, index) => {\n\t\t\t\tconst first = index === 0;\n\t\t\t\tconst last = index === this.children.length;\n\n\t\t\t\tnode.boundarySashes = {\n\t\t\t\t\tstart: this.boundarySashes.orthogonalStart,\n\t\t\t\t\tend: this.boundarySashes.orthogonalEnd,\n\t\t\t\t\torthogonalStart: first ? this.boundarySashes.start : this.splitview.sashes[index - 1],\n\t\t\t\t\torthogonalEnd: last ? this.boundarySashes.end : this.splitview.sashes[index],\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\tconst onDidSashReset = Event.map(this.splitview.onDidSashReset, i => [i]);\n\t\tthis.splitviewSashResetDisposable = onDidSashReset(this._onDidSashReset.fire, this._onDidSashReset);\n\n\t\tthis.updateChildrenEvents();\n\t}\n\n\tstyle(styles: IGridViewStyles): void {\n\t\tthis._styles = styles;\n\t\tthis.splitview.style(styles);\n\n\t\tfor (const child of this.children) {\n\t\t\tif (child instanceof BranchNode) {\n\t\t\t\tchild.style(styles);\n\t\t\t}\n\t\t}\n\t}\n\n\tlayout(size: number, offset: number, ctx: ILayoutContext | undefined): void {\n\t\tif (!this.layoutController.isLayoutEnabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof ctx === 'undefined') {\n\t\t\tthrow new Error('Invalid state');\n\t\t}\n\n\t\t// branch nodes should flip the normal/orthogonal directions\n\t\tthis._size = ctx.orthogonalSize;\n\t\tthis._orthogonalSize = size;\n\t\tthis._absoluteOffset = ctx.absoluteOffset + offset;\n\t\tthis._absoluteOrthogonalOffset = ctx.absoluteOrthogonalOffset;\n\t\tthis.absoluteOrthogonalSize = ctx.absoluteOrthogonalSize;\n\n\t\tthis.splitview.layout(ctx.orthogonalSize, {\n\t\t\torthogonalSize: size,\n\t\t\tabsoluteOffset: this._absoluteOrthogonalOffset,\n\t\t\tabsoluteOrthogonalOffset: this._absoluteOffset,\n\t\t\tabsoluteSize: ctx.absoluteOrthogonalSize,\n\t\t\tabsoluteOrthogonalSize: ctx.absoluteSize\n\t\t});\n\n\t\tthis.updateSplitviewEdgeSnappingEnablement();\n\t}\n\n\tsetVisible(visible: boolean): void {\n\t\tfor (const child of this.children) {\n\t\t\tchild.setVisible(visible);\n\t\t}\n\t}\n\n\taddChild(node: Node, size: number | Sizing, index: number, skipLayout?: boolean): void {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\tthis.splitview.addView(node, size, index, skipLayout);\n\t\tthis.children.splice(index, 0, node);\n\n\t\tthis.updateBoundarySashes();\n\t\tthis.onDidChildrenChange();\n\t}\n\n\tremoveChild(index: number, sizing?: Sizing): Node {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\tconst result = this.splitview.removeView(index, sizing);\n\t\tthis.children.splice(index, 1);\n\n\t\tthis.updateBoundarySashes();\n\t\tthis.onDidChildrenChange();\n\n\t\treturn result;\n\t}\n\n\tremoveAllChildren(): Node[] {\n\t\tconst result = this.splitview.removeAllViews();\n\n\t\tthis.children.splice(0, this.children.length);\n\n\t\tthis.updateBoundarySashes();\n\t\tthis.onDidChildrenChange();\n\n\t\treturn result;\n\t}\n\n\tmoveChild(from: number, to: number): void {\n\t\tfrom = validateIndex(from, this.children.length);\n\t\tto = validateIndex(to, this.children.length);\n\n\t\tif (from === to) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (from < to) {\n\t\t\tto -= 1;\n\t\t}\n\n\t\tthis.splitview.moveView(from, to);\n\t\tthis.children.splice(to, 0, this.children.splice(from, 1)[0]);\n\n\t\tthis.updateBoundarySashes();\n\t\tthis.onDidChildrenChange();\n\t}\n\n\tswapChildren(from: number, to: number): void {\n\t\tfrom = validateIndex(from, this.children.length);\n\t\tto = validateIndex(to, this.children.length);\n\n\t\tif (from === to) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.splitview.swapViews(from, to);\n\n\t\t// swap boundary sashes\n\t\t[this.children[from].boundarySashes, this.children[to].boundarySashes]\n\t\t\t= [this.children[from].boundarySashes, this.children[to].boundarySashes];\n\n\t\t// swap children\n\t\t[this.children[from], this.children[to]] = [this.children[to], this.children[from]];\n\n\t\tthis.onDidChildrenChange();\n\t}\n\n\tresizeChild(index: number, size: number): void {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\tthis.splitview.resizeView(index, size);\n\t}\n\n\tisChildExpanded(index: number): boolean {\n\t\treturn this.splitview.isViewExpanded(index);\n\t}\n\n\tdistributeViewSizes(recursive = false): void {\n\t\tthis.splitview.distributeViewSizes();\n\n\t\tif (recursive) {\n\t\t\tfor (const child of this.children) {\n\t\t\t\tif (child instanceof BranchNode) {\n\t\t\t\t\tchild.distributeViewSizes(true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetChildSize(index: number): number {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\treturn this.splitview.getViewSize(index);\n\t}\n\n\tisChildVisible(index: number): boolean {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\treturn this.splitview.isViewVisible(index);\n\t}\n\n\tsetChildVisible(index: number, visible: boolean): void {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\tif (this.splitview.isViewVisible(index) === visible) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst wereAllChildrenHidden = this.splitview.contentSize === 0;\n\t\tthis.splitview.setViewVisible(index, visible);\n\t\tconst areAllChildrenHidden = this.splitview.contentSize === 0;\n\n\t\t// If all children are hidden then the parent should hide the entire splitview\n\t\t// If the entire splitview is hidden then the parent should show the splitview when a child is shown\n\t\tif ((visible && wereAllChildrenHidden) || (!visible && areAllChildrenHidden)) {\n\t\t\tthis._onDidVisibilityChange.fire(visible);\n\t\t}\n\t}\n\n\tgetChildCachedVisibleSize(index: number): number | undefined {\n\t\tindex = validateIndex(index, this.children.length);\n\n\t\treturn this.splitview.getViewCachedVisibleSize(index);\n\t}\n\n\tprivate updateBoundarySashes(): void {\n\t\tfor (let i = 0; i < this.children.length; i++) {\n\t\t\tthis.children[i].boundarySashes = {\n\t\t\t\tstart: this.boundarySashes.orthogonalStart,\n\t\t\t\tend: this.boundarySashes.orthogonalEnd,\n\t\t\t\torthogonalStart: i === 0 ? this.boundarySashes.start : this.splitview.sashes[i - 1],\n\t\t\t\torthogonalEnd: i === this.children.length - 1 ? this.boundarySashes.end : this.splitview.sashes[i],\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate onDidChildrenChange(): void {\n\t\tthis.updateChildrenEvents();\n\t\tthis._onDidChange.fire(undefined);\n\t}\n\n\tprivate updateChildrenEvents(): void {\n\t\tconst onDidChildrenChange = Event.map(Event.any(...this.children.map(c => c.onDidChange)), () => undefined);\n\t\tthis.childrenChangeDisposable.dispose();\n\t\tthis.childrenChangeDisposable = onDidChildrenChange(this._onDidChange.fire, this._onDidChange);\n\n\t\tconst onDidChildrenSashReset = Event.any(...this.children.map((c, i) => Event.map(c.onDidSashReset, location => [i, ...location])));\n\t\tthis.childrenSashResetDisposable.dispose();\n\t\tthis.childrenSashResetDisposable = onDidChildrenSashReset(this._onDidSashReset.fire, this._onDidSashReset);\n\n\t\tconst onDidScroll = Event.any(Event.signal(this.splitview.onDidScroll), ...this.children.map(c => c.onDidScroll));\n\t\tthis.onDidScrollDisposable.dispose();\n\t\tthis.onDidScrollDisposable = onDidScroll(this._onDidScroll.fire, this._onDidScroll);\n\n\t\tthis.childrenVisibilityChangeDisposable.clear();\n\t\tthis.children.forEach((child, index) => {\n\t\t\tif (child instanceof BranchNode) {\n\t\t\t\tthis.childrenVisibilityChangeDisposable.add(child.onDidVisibilityChange((visible) => {\n\t\t\t\t\tthis.setChildVisible(index, visible);\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\t}\n\n\ttrySet2x2(other: BranchNode): IDisposable {\n\t\tif (this.children.length !== 2 || other.children.length !== 2) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tif (this.getChildSize(0) !== other.getChildSize(0)) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tconst [firstChild, secondChild] = this.children;\n\t\tconst [otherFirstChild, otherSecondChild] = other.children;\n\n\t\tif (!(firstChild instanceof LeafNode) || !(secondChild instanceof LeafNode)) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tif (!(otherFirstChild instanceof LeafNode) || !(otherSecondChild instanceof LeafNode)) {\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tif (this.orientation === Orientation.VERTICAL) {\n\t\t\tsecondChild.linkedWidthNode = otherFirstChild.linkedHeightNode = firstChild;\n\t\t\tfirstChild.linkedWidthNode = otherSecondChild.linkedHeightNode = secondChild;\n\t\t\totherSecondChild.linkedWidthNode = firstChild.linkedHeightNode = otherFirstChild;\n\t\t\totherFirstChild.linkedWidthNode = secondChild.linkedHeightNode = otherSecondChild;\n\t\t} else {\n\t\t\totherFirstChild.linkedWidthNode = secondChild.linkedHeightNode = firstChild;\n\t\t\totherSecondChild.linkedWidthNode = firstChild.linkedHeightNode = secondChild;\n\t\t\tfirstChild.linkedWidthNode = otherSecondChild.linkedHeightNode = otherFirstChild;\n\t\t\tsecondChild.linkedWidthNode = otherFirstChild.linkedHeightNode = otherSecondChild;\n\t\t}\n\n\t\tconst mySash = this.splitview.sashes[0];\n\t\tconst otherSash = other.splitview.sashes[0];\n\t\tmySash.linkedSash = otherSash;\n\t\totherSash.linkedSash = mySash;\n\n\t\tthis._onDidChange.fire(undefined);\n\t\tother._onDidChange.fire(undefined);\n\n\t\treturn toDisposable(() => {\n\t\t\tmySash.linkedSash = otherSash.linkedSash = undefined;\n\t\t\tfirstChild.linkedHeightNode = firstChild.linkedWidthNode = undefined;\n\t\t\tsecondChild.linkedHeightNode = secondChild.linkedWidthNode = undefined;\n\t\t\totherFirstChild.linkedHeightNode = otherFirstChild.linkedWidthNode = undefined;\n\t\t\totherSecondChild.linkedHeightNode = otherSecondChild.linkedWidthNode = undefined;\n\t\t});\n\t}\n\n\tprivate updateSplitviewEdgeSnappingEnablement(): void {\n\t\tthis.splitview.startSnappingEnabled = this._edgeSnapping || this._absoluteOrthogonalOffset > 0;\n\t\tthis.splitview.endSnappingEnabled = this._edgeSnapping || this._absoluteOrthogonalOffset + this._size < this.absoluteOrthogonalSize;\n\t}\n\n\tdispose(): void {\n\t\tfor (const child of this.children) {\n\t\t\tchild.dispose();\n\t\t}\n\n\t\tthis._onDidChange.dispose();\n\t\tthis._onDidSashReset.dispose();\n\t\tthis._onDidVisibilityChange.dispose();\n\n\t\tthis.childrenVisibilityChangeDisposable.dispose();\n\t\tthis.splitviewSashResetDisposable.dispose();\n\t\tthis.childrenSashResetDisposable.dispose();\n\t\tthis.childrenChangeDisposable.dispose();\n\t\tthis.onDidScrollDisposable.dispose();\n\t\tthis.splitview.dispose();\n\t}\n}\n\n/**\n * Creates a latched event that avoids being fired when the view\n * constraints do not change at all.\n */\nfunction createLatchedOnDidChangeViewEvent(view: IView): Event<IViewSize | undefined> {\n\tconst [onDidChangeViewConstraints, onDidSetViewSize] = Event.split<undefined, IViewSize>(view.onDidChange, isUndefined);\n\n\treturn Event.any(\n\t\tonDidSetViewSize,\n\t\tEvent.map(\n\t\t\tEvent.latch(\n\t\t\t\tEvent.map(onDidChangeViewConstraints, _ => ([view.minimumWidth, view.maximumWidth, view.minimumHeight, view.maximumHeight])),\n\t\t\t\tarrayEquals\n\t\t\t),\n\t\t\t_ => undefined\n\t\t)\n\t);\n}\n\nclass LeafNode implements ISplitView<ILayoutContext>, IDisposable {\n\n\tprivate _size: number = 0;\n\tget size(): number { return this._size; }\n\n\tprivate _orthogonalSize: number;\n\tget orthogonalSize(): number { return this._orthogonalSize; }\n\n\tprivate absoluteOffset: number = 0;\n\tprivate absoluteOrthogonalOffset: number = 0;\n\n\treadonly onDidScroll: Event<void> = Event.None;\n\treadonly onDidSashReset: Event<GridLocation> = Event.None;\n\n\tprivate _onDidLinkedWidthNodeChange = new Relay<number | undefined>();\n\tprivate _linkedWidthNode: LeafNode | undefined = undefined;\n\tget linkedWidthNode(): LeafNode | undefined { return this._linkedWidthNode; }\n\tset linkedWidthNode(node: LeafNode | undefined) {\n\t\tthis._onDidLinkedWidthNodeChange.input = node ? node._onDidViewChange : Event.None;\n\t\tthis._linkedWidthNode = node;\n\t\tthis._onDidSetLinkedNode.fire(undefined);\n\t}\n\n\tprivate _onDidLinkedHeightNodeChange = new Relay<number | undefined>();\n\tprivate _linkedHeightNode: LeafNode | undefined = undefined;\n\tget linkedHeightNode(): LeafNode | undefined { return this._linkedHeightNode; }\n\tset linkedHeightNode(node: LeafNode | undefined) {\n\t\tthis._onDidLinkedHeightNodeChange.input = node ? node._onDidViewChange : Event.None;\n\t\tthis._linkedHeightNode = node;\n\t\tthis._onDidSetLinkedNode.fire(undefined);\n\t}\n\n\tprivate readonly _onDidSetLinkedNode = new Emitter<number | undefined>();\n\tprivate _onDidViewChange: Event<number | undefined>;\n\treadonly onDidChange: Event<number | undefined>;\n\n\tprivate readonly disposables = new DisposableStore();\n\n\tconstructor(\n\t\treadonly view: IView,\n\t\treadonly orientation: Orientation,\n\t\treadonly layoutController: LayoutController,\n\t\torthogonalSize: number,\n\t\tsize: number = 0\n\t) {\n\t\tthis._orthogonalSize = orthogonalSize;\n\t\tthis._size = size;\n\n\t\tconst onDidChange = createLatchedOnDidChangeViewEvent(view);\n\t\tthis._onDidViewChange = Event.map(onDidChange, e => e && (this.orientation === Orientation.VERTICAL ? e.width : e.height), this.disposables);\n\t\tthis.onDidChange = Event.any(this._onDidViewChange, this._onDidSetLinkedNode.event, this._onDidLinkedWidthNodeChange.event, this._onDidLinkedHeightNodeChange.event);\n\t}\n\n\tget width(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.orthogonalSize : this.size;\n\t}\n\n\tget height(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.size : this.orthogonalSize;\n\t}\n\n\tget top(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.absoluteOffset : this.absoluteOrthogonalOffset;\n\t}\n\n\tget left(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.absoluteOrthogonalOffset : this.absoluteOffset;\n\t}\n\n\tget element(): HTMLElement {\n\t\treturn this.view.element;\n\t}\n\n\tprivate get minimumWidth(): number {\n\t\treturn this.linkedWidthNode ? Math.max(this.linkedWidthNode.view.minimumWidth, this.view.minimumWidth) : this.view.minimumWidth;\n\t}\n\n\tprivate get maximumWidth(): number {\n\t\treturn this.linkedWidthNode ? Math.min(this.linkedWidthNode.view.maximumWidth, this.view.maximumWidth) : this.view.maximumWidth;\n\t}\n\n\tprivate get minimumHeight(): number {\n\t\treturn this.linkedHeightNode ? Math.max(this.linkedHeightNode.view.minimumHeight, this.view.minimumHeight) : this.view.minimumHeight;\n\t}\n\n\tprivate get maximumHeight(): number {\n\t\treturn this.linkedHeightNode ? Math.min(this.linkedHeightNode.view.maximumHeight, this.view.maximumHeight) : this.view.maximumHeight;\n\t}\n\n\tget minimumSize(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.minimumHeight : this.minimumWidth;\n\t}\n\n\tget maximumSize(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.maximumHeight : this.maximumWidth;\n\t}\n\n\tget priority(): LayoutPriority | undefined {\n\t\treturn this.view.priority;\n\t}\n\n\tget proportionalLayout(): boolean {\n\t\treturn this.view.proportionalLayout ?? true;\n\t}\n\n\tget snap(): boolean | undefined {\n\t\treturn this.view.snap;\n\t}\n\n\tget minimumOrthogonalSize(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.minimumWidth : this.minimumHeight;\n\t}\n\n\tget maximumOrthogonalSize(): number {\n\t\treturn this.orientation === Orientation.HORIZONTAL ? this.maximumWidth : this.maximumHeight;\n\t}\n\n\tprivate _boundarySashes: IRelativeBoundarySashes = {};\n\tget boundarySashes(): IRelativeBoundarySashes { return this._boundarySashes; }\n\tset boundarySashes(boundarySashes: IRelativeBoundarySashes) {\n\t\tthis._boundarySashes = boundarySashes;\n\n\t\tthis.view.setBoundarySashes?.(toAbsoluteBoundarySashes(boundarySashes, this.orientation));\n\t}\n\n\tlayout(size: number, offset: number, ctx: ILayoutContext | undefined): void {\n\t\tif (!this.layoutController.isLayoutEnabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof ctx === 'undefined') {\n\t\t\tthrow new Error('Invalid state');\n\t\t}\n\n\t\tthis._size = size;\n\t\tthis._orthogonalSize = ctx.orthogonalSize;\n\t\tthis.absoluteOffset = ctx.absoluteOffset + offset;\n\t\tthis.absoluteOrthogonalOffset = ctx.absoluteOrthogonalOffset;\n\n\t\tthis._layout(this.width, this.height, this.top, this.left);\n\t}\n\n\tprivate cachedWidth: number = 0;\n\tprivate cachedHeight: number = 0;\n\tprivate cachedTop: number = 0;\n\tprivate cachedLeft: number = 0;\n\n\tprivate _layout(width: number, height: number, top: number, left: number): void {\n\t\tif (this.cachedWidth === width && this.cachedHeight === height && this.cachedTop === top && this.cachedLeft === left) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.cachedWidth = width;\n\t\tthis.cachedHeight = height;\n\t\tthis.cachedTop = top;\n\t\tthis.cachedLeft = left;\n\t\tthis.view.layout(width, height, top, left);\n\t}\n\n\tsetVisible(visible: boolean): void {\n\t\tthis.view.setVisible?.(visible);\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\t}\n}\n\ntype Node = BranchNode | LeafNode;\n\nexport interface INodeDescriptor {\n\tnode: Node;\n\tvisible?: boolean;\n}\n\nfunction flipNode(node: BranchNode, size: number, orthogonalSize: number): BranchNode;\nfunction flipNode(node: LeafNode, size: number, orthogonalSize: number): LeafNode;\nfunction flipNode(node: Node, size: number, orthogonalSize: number): Node;\nfunction flipNode(node: Node, size: number, orthogonalSize: number): Node {\n\tif (node instanceof BranchNode) {\n\t\tconst result = new BranchNode(orthogonal(node.orientation), node.layoutController, node.styles, node.splitviewProportionalLayout, size, orthogonalSize, node.edgeSnapping);\n\n\t\tlet totalSize = 0;\n\n\t\tfor (let i = node.children.length - 1; i >= 0; i--) {\n\t\t\tconst child = node.children[i];\n\t\t\tconst childSize = child instanceof BranchNode ? child.orthogonalSize : child.size;\n\n\t\t\tlet newSize = node.size === 0 ? 0 : Math.round((size * childSize) / node.size);\n\t\t\ttotalSize += newSize;\n\n\t\t\t// The last view to add should adjust to rounding errors\n\t\t\tif (i === 0) {\n\t\t\t\tnewSize += size - totalSize;\n\t\t\t}\n\n\t\t\tresult.addChild(flipNode(child, orthogonalSize, newSize), newSize, 0, true);\n\t\t}\n\n\t\tnode.dispose();\n\t\treturn result;\n\t} else {\n\t\tconst result = new LeafNode(node.view, orthogonal(node.orientation), node.layoutController, orthogonalSize);\n\t\tnode.dispose();\n\t\treturn result;\n\t}\n}\n\n/**\n * The location of a {@link IView view} within a {@link GridView}.\n *\n * A GridView is a tree composition of multiple {@link SplitView} instances, orthogonal\n * between one another. Here's an example:\n *\n * ```\n *  +-----+---------------+\n *  |  A  |      B        |\n *  +-----+---------+-----+\n *  |        C      |     |\n *  +---------------+  D  |\n *  |        E      |     |\n *  +---------------+-----+\n * ```\n *\n * The above grid's tree structure is:\n *\n * ```\n *  Vertical SplitView\n *  +-Horizontal SplitView\n *  | +-A\n *  | +-B\n *  +- Horizontal SplitView\n *    +-Vertical SplitView\n *    | +-C\n *    | +-E\n *    +-D\n * ```\n *\n * So, {@link IView views} within a {@link GridView} can be referenced by\n * a sequence of indexes, each index referencing each SplitView. Here are\n * each view's locations, from the example above:\n *\n * - `A`: `[0,0]`\n * - `B`: `[0,1]`\n * - `C`: `[1,0,0]`\n * - `D`: `[1,1]`\n * - `E`: `[1,0,1]`\n */\nexport type GridLocation = number[];\n\n/**\n * The {@link GridView} is the UI component which implements a two dimensional\n * flex-like layout algorithm for a collection of {@link IView} instances, which\n * are mostly HTMLElement instances with size constraints. A {@link GridView} is a\n * tree composition of multiple {@link SplitView} instances, orthogonal between\n * one another. It will respect view's size contraints, just like the SplitView.\n *\n * It has a low-level index based API, allowing for fine grain performant operations.\n * Look into the {@link Grid} widget for a higher-level API.\n *\n * Features:\n * - flex-like layout algorithm\n * - snap support\n * - corner sash support\n * - Alt key modifier behavior, macOS style\n * - layout (de)serialization\n */\nexport class GridView implements IDisposable {\n\n\t/**\n\t * The DOM element for this view.\n\t */\n\treadonly element: HTMLElement;\n\n\tprivate styles: IGridViewStyles;\n\tprivate proportionalLayout: boolean;\n\tprivate _root!: BranchNode;\n\tprivate onDidSashResetRelay = new Relay<GridLocation>();\n\tprivate _onDidScroll = new Relay<void>();\n\tprivate _onDidChange = new Relay<IViewSize | undefined>();\n\tprivate _boundarySashes: IBoundarySashes = {};\n\n\t/**\n\t * The layout controller makes sure layout only propagates\n\t * to the views after the very first call to {@link GridView.layout}.\n\t */\n\tprivate layoutController: LayoutController;\n\tprivate disposable2x2: IDisposable = Disposable.None;\n\n\tprivate get root(): BranchNode { return this._root; }\n\n\tprivate set root(root: BranchNode) {\n\t\tconst oldRoot = this._root;\n\n\t\tif (oldRoot) {\n\t\t\toldRoot.element.remove();\n\t\t\toldRoot.dispose();\n\t\t}\n\n\t\tthis._root = root;\n\t\tthis.element.appendChild(root.element);\n\t\tthis.onDidSashResetRelay.input = root.onDidSashReset;\n\t\tthis._onDidChange.input = Event.map(root.onDidChange, () => undefined); // TODO\n\t\tthis._onDidScroll.input = root.onDidScroll;\n\t}\n\n\t/**\n\t * Fires whenever the user double clicks a {@link Sash sash}.\n\t */\n\treadonly onDidSashReset = this.onDidSashResetRelay.event;\n\n\t/**\n\t * Fires whenever the user scrolls a {@link SplitView} within\n\t * the grid.\n\t */\n\treadonly onDidScroll = this._onDidScroll.event;\n\n\t/**\n\t * Fires whenever a view within the grid changes its size constraints.\n\t */\n\treadonly onDidChange = this._onDidChange.event;\n\n\t/**\n\t * The width of the grid.\n\t */\n\tget width(): number { return this.root.width; }\n\n\t/**\n\t * The height of the grid.\n\t */\n\tget height(): number { return this.root.height; }\n\n\t/**\n\t * The minimum width of the grid.\n\t */\n\tget minimumWidth(): number { return this.root.minimumWidth; }\n\n\t/**\n\t * The minimum height of the grid.\n\t */\n\tget minimumHeight(): number { return this.root.minimumHeight; }\n\n\t/**\n\t * The maximum width of the grid.\n\t */\n\tget maximumWidth(): number { return this.root.maximumHeight; }\n\n\t/**\n\t * The maximum height of the grid.\n\t */\n\tget maximumHeight(): number { return this.root.maximumHeight; }\n\n\tget orientation(): Orientation { return this._root.orientation; }\n\tget boundarySashes(): IBoundarySashes { return this._boundarySashes; }\n\n\t/**\n\t * The orientation of the grid. Matches the orientation of the root\n\t * {@link SplitView} in the grid's tree model.\n\t */\n\tset orientation(orientation: Orientation) {\n\t\tif (this._root.orientation === orientation) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { size, orthogonalSize, absoluteOffset, absoluteOrthogonalOffset } = this._root;\n\t\tthis.root = flipNode(this._root, orthogonalSize, size);\n\t\tthis.root.layout(size, 0, { orthogonalSize, absoluteOffset: absoluteOrthogonalOffset, absoluteOrthogonalOffset: absoluteOffset, absoluteSize: size, absoluteOrthogonalSize: orthogonalSize });\n\t\tthis.boundarySashes = this.boundarySashes;\n\t}\n\n\t/**\n\t * A collection of sashes perpendicular to each edge of the grid.\n\t * Corner sashes will be created for each intersection.\n\t */\n\tset boundarySashes(boundarySashes: IBoundarySashes) {\n\t\tthis._boundarySashes = boundarySashes;\n\t\tthis.root.boundarySashes = fromAbsoluteBoundarySashes(boundarySashes, this.orientation);\n\t}\n\n\t/**\n\t * Enable/disable edge snapping across all grid views.\n\t */\n\tset edgeSnapping(edgeSnapping: boolean) {\n\t\tthis.root.edgeSnapping = edgeSnapping;\n\t}\n\n\tprivate maximizedNode: LeafNode | undefined = undefined;\n\n\tprivate readonly _onDidChangeViewMaximized = new Emitter<boolean>();\n\treadonly onDidChangeViewMaximized = this._onDidChangeViewMaximized.event;\n\n\t/**\n\t * Create a new {@link GridView} instance.\n\t *\n\t * @remarks It's the caller's responsibility to append the\n\t * {@link GridView.element} to the page's DOM.\n\t */\n\tconstructor(options: IGridViewOptions = {}) {\n\t\tthis.element = $('.monaco-grid-view');\n\t\tthis.styles = options.styles || defaultStyles;\n\t\tthis.proportionalLayout = typeof options.proportionalLayout !== 'undefined' ? !!options.proportionalLayout : true;\n\t\tthis.layoutController = new LayoutController(false);\n\t\tthis.root = new BranchNode(Orientation.VERTICAL, this.layoutController, this.styles, this.proportionalLayout);\n\t}\n\n\tstyle(styles: IGridViewStyles): void {\n\t\tthis.styles = styles;\n\t\tthis.root.style(styles);\n\t}\n\n\t/**\n\t * Layout the {@link GridView}.\n\t *\n\t * Optionally provide a `top` and `left` positions, those will propagate\n\t * as an origin for positions passed to {@link IView.layout}.\n\t *\n\t * @param width The width of the {@link GridView}.\n\t * @param height The height of the {@link GridView}.\n\t * @param top Optional, the top location of the {@link GridView}.\n\t * @param left Optional, the left location of the {@link GridView}.\n\t */\n\tlayout(width: number, height: number, top: number = 0, left: number = 0): void {\n\t\tthis.layoutController.isLayoutEnabled = true;\n\n\t\tconst [size, orthogonalSize, offset, orthogonalOffset] = this.root.orientation === Orientation.HORIZONTAL ? [height, width, top, left] : [width, height, left, top];\n\t\tthis.root.layout(size, 0, { orthogonalSize, absoluteOffset: offset, absoluteOrthogonalOffset: orthogonalOffset, absoluteSize: size, absoluteOrthogonalSize: orthogonalSize });\n\t}\n\n\t/**\n\t * Add a {@link IView view} to this {@link GridView}.\n\t *\n\t * @param view The view to add.\n\t * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.\n\t * @param location The {@link GridLocation location} to insert the view on.\n\t */\n\taddView(view: IView, size: number | Sizing, location: GridLocation): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tthis.disposable2x2.dispose();\n\t\tthis.disposable2x2 = Disposable.None;\n\n\t\tconst [rest, index] = tail(location);\n\t\tconst [pathToParent, parent] = this.getNode(rest);\n\n\t\tif (parent instanceof BranchNode) {\n\t\t\tconst node = new LeafNode(view, orthogonal(parent.orientation), this.layoutController, parent.orthogonalSize);\n\n\t\t\ttry {\n\t\t\t\tparent.addChild(node, size, index);\n\t\t\t} catch (err) {\n\t\t\t\tnode.dispose();\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t} else {\n\t\t\tconst [, grandParent] = tail(pathToParent);\n\t\t\tconst [, parentIndex] = tail(rest);\n\n\t\t\tlet newSiblingSize: number | Sizing = 0;\n\n\t\t\tconst newSiblingCachedVisibleSize = grandParent.getChildCachedVisibleSize(parentIndex);\n\t\t\tif (typeof newSiblingCachedVisibleSize === 'number') {\n\t\t\t\tnewSiblingSize = Sizing.Invisible(newSiblingCachedVisibleSize);\n\t\t\t}\n\n\t\t\tconst oldChild = grandParent.removeChild(parentIndex);\n\t\t\toldChild.dispose();\n\n\t\t\tconst newParent = new BranchNode(parent.orientation, parent.layoutController, this.styles, this.proportionalLayout, parent.size, parent.orthogonalSize, grandParent.edgeSnapping);\n\t\t\tgrandParent.addChild(newParent, parent.size, parentIndex);\n\n\t\t\tconst newSibling = new LeafNode(parent.view, grandParent.orientation, this.layoutController, parent.size);\n\t\t\tnewParent.addChild(newSibling, newSiblingSize, 0);\n\n\t\t\tif (typeof size !== 'number' && size.type === 'split') {\n\t\t\t\tsize = Sizing.Split(0);\n\t\t\t}\n\n\t\t\tconst node = new LeafNode(view, grandParent.orientation, this.layoutController, parent.size);\n\t\t\tnewParent.addChild(node, size, index);\n\t\t}\n\n\t\tthis.trySet2x2();\n\t}\n\n\t/**\n\t * Remove a {@link IView view} from this {@link GridView}.\n\t *\n\t * @param location The {@link GridLocation location} of the {@link IView view}.\n\t * @param sizing Whether to distribute other {@link IView view}'s sizes.\n\t */\n\tremoveView(location: GridLocation, sizing?: DistributeSizing | AutoSizing): IView {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tthis.disposable2x2.dispose();\n\t\tthis.disposable2x2 = Disposable.None;\n\n\t\tconst [rest, index] = tail(location);\n\t\tconst [pathToParent, parent] = this.getNode(rest);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tconst node = parent.children[index];\n\n\t\tif (!(node instanceof LeafNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tparent.removeChild(index, sizing);\n\t\tnode.dispose();\n\n\t\tif (parent.children.length === 0) {\n\t\t\tthrow new Error('Invalid grid state');\n\t\t}\n\n\t\tif (parent.children.length > 1) {\n\t\t\tthis.trySet2x2();\n\t\t\treturn node.view;\n\t\t}\n\n\t\tif (pathToParent.length === 0) { // parent is root\n\t\t\tconst sibling = parent.children[0];\n\n\t\t\tif (sibling instanceof LeafNode) {\n\t\t\t\treturn node.view;\n\t\t\t}\n\n\t\t\t// we must promote sibling to be the new root\n\t\t\tparent.removeChild(0);\n\t\t\tparent.dispose();\n\t\t\tthis.root = sibling;\n\t\t\tthis.boundarySashes = this.boundarySashes;\n\t\t\tthis.trySet2x2();\n\t\t\treturn node.view;\n\t\t}\n\n\t\tconst [, grandParent] = tail(pathToParent);\n\t\tconst [, parentIndex] = tail(rest);\n\n\t\tconst isSiblingVisible = parent.isChildVisible(0);\n\t\tconst sibling = parent.removeChild(0);\n\n\t\tconst sizes = grandParent.children.map((_, i) => grandParent.getChildSize(i));\n\t\tgrandParent.removeChild(parentIndex, sizing);\n\t\tparent.dispose();\n\n\t\tif (sibling instanceof BranchNode) {\n\t\t\tsizes.splice(parentIndex, 1, ...sibling.children.map(c => c.size));\n\n\t\t\tconst siblingChildren = sibling.removeAllChildren();\n\n\t\t\tfor (let i = 0; i < siblingChildren.length; i++) {\n\t\t\t\tgrandParent.addChild(siblingChildren[i], siblingChildren[i].size, parentIndex + i);\n\t\t\t}\n\t\t} else {\n\t\t\tconst newSibling = new LeafNode(sibling.view, orthogonal(sibling.orientation), this.layoutController, sibling.size);\n\t\t\tconst sizing = isSiblingVisible ? sibling.orthogonalSize : Sizing.Invisible(sibling.orthogonalSize);\n\t\t\tgrandParent.addChild(newSibling, sizing, parentIndex);\n\t\t}\n\n\t\tsibling.dispose();\n\n\t\tfor (let i = 0; i < sizes.length; i++) {\n\t\t\tgrandParent.resizeChild(i, sizes[i]);\n\t\t}\n\n\t\tthis.trySet2x2();\n\t\treturn node.view;\n\t}\n\n\t/**\n\t * Move a {@link IView view} within its parent.\n\t *\n\t * @param parentLocation The {@link GridLocation location} of the {@link IView view}'s parent.\n\t * @param from The index of the {@link IView view} to move.\n\t * @param to The index where the {@link IView view} should move to.\n\t */\n\tmoveView(parentLocation: GridLocation, from: number, to: number): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tconst [, parent] = this.getNode(parentLocation);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tparent.moveChild(from, to);\n\n\t\tthis.trySet2x2();\n\t}\n\n\t/**\n\t * Swap two {@link IView views} within the {@link GridView}.\n\t *\n\t * @param from The {@link GridLocation location} of one view.\n\t * @param to The {@link GridLocation location} of another view.\n\t */\n\tswapViews(from: GridLocation, to: GridLocation): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tconst [fromRest, fromIndex] = tail(from);\n\t\tconst [, fromParent] = this.getNode(fromRest);\n\n\t\tif (!(fromParent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid from location');\n\t\t}\n\n\t\tconst fromSize = fromParent.getChildSize(fromIndex);\n\t\tconst fromNode = fromParent.children[fromIndex];\n\n\t\tif (!(fromNode instanceof LeafNode)) {\n\t\t\tthrow new Error('Invalid from location');\n\t\t}\n\n\t\tconst [toRest, toIndex] = tail(to);\n\t\tconst [, toParent] = this.getNode(toRest);\n\n\t\tif (!(toParent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid to location');\n\t\t}\n\n\t\tconst toSize = toParent.getChildSize(toIndex);\n\t\tconst toNode = toParent.children[toIndex];\n\n\t\tif (!(toNode instanceof LeafNode)) {\n\t\t\tthrow new Error('Invalid to location');\n\t\t}\n\n\t\tif (fromParent === toParent) {\n\t\t\tfromParent.swapChildren(fromIndex, toIndex);\n\t\t} else {\n\t\t\tfromParent.removeChild(fromIndex);\n\t\t\ttoParent.removeChild(toIndex);\n\n\t\t\tfromParent.addChild(toNode, fromSize, fromIndex);\n\t\t\ttoParent.addChild(fromNode, toSize, toIndex);\n\t\t}\n\n\t\tthis.trySet2x2();\n\t}\n\n\t/**\n\t * Resize a {@link IView view}.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t * @param size The size the view should be. Optionally provide a single dimension.\n\t */\n\tresizeView(location: GridLocation, size: Partial<IViewSize>): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tconst [rest, index] = tail(location);\n\t\tconst [pathToParent, parent] = this.getNode(rest);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tif (!size.width && !size.height) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [parentSize, grandParentSize] = parent.orientation === Orientation.HORIZONTAL ? [size.width, size.height] : [size.height, size.width];\n\n\t\tif (typeof grandParentSize === 'number' && pathToParent.length > 0) {\n\t\t\tconst [, grandParent] = tail(pathToParent);\n\t\t\tconst [, parentIndex] = tail(rest);\n\n\t\t\tgrandParent.resizeChild(parentIndex, grandParentSize);\n\t\t}\n\n\t\tif (typeof parentSize === 'number') {\n\t\t\tparent.resizeChild(index, parentSize);\n\t\t}\n\n\t\tthis.trySet2x2();\n\t}\n\n\t/**\n\t * Get the size of a {@link IView view}.\n\t *\n\t * @param location The {@link GridLocation location} of the view. Provide `undefined` to get\n\t * the size of the grid itself.\n\t */\n\tgetViewSize(location?: GridLocation): IViewSize {\n\t\tif (!location) {\n\t\t\treturn { width: this.root.width, height: this.root.height };\n\t\t}\n\n\t\tconst [, node] = this.getNode(location);\n\t\treturn { width: node.width, height: node.height };\n\t}\n\n\t/**\n\t * Get the cached visible size of a {@link IView view}. This was the size\n\t * of the view at the moment it last became hidden.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\tgetViewCachedVisibleSize(location: GridLocation): number | undefined {\n\t\tconst [rest, index] = tail(location);\n\t\tconst [, parent] = this.getNode(rest);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\treturn parent.getChildCachedVisibleSize(index);\n\t}\n\n\t/**\n\t * Maximize the size of a {@link IView view} by collapsing all other views\n\t * to their minimum sizes.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\texpandView(location: GridLocation): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tconst [ancestors, node] = this.getNode(location);\n\n\t\tif (!(node instanceof LeafNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tfor (let i = 0; i < ancestors.length; i++) {\n\t\t\tancestors[i].resizeChild(location[i], Number.POSITIVE_INFINITY);\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether all other {@link IView views} are at their minimum size.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\tisViewExpanded(location: GridLocation): boolean {\n\t\tif (this.hasMaximizedView()) {\n\t\t\t// No view can be expanded when a view is maximized\n\t\t\treturn false;\n\t\t}\n\n\t\tconst [ancestors, node] = this.getNode(location);\n\n\t\tif (!(node instanceof LeafNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tfor (let i = 0; i < ancestors.length; i++) {\n\t\t\tif (!ancestors[i].isChildExpanded(location[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tmaximizeView(location: GridLocation) {\n\t\tconst [, nodeToMaximize] = this.getNode(location);\n\t\tif (!(nodeToMaximize instanceof LeafNode)) {\n\t\t\tthrow new Error('Location is not a LeafNode');\n\t\t}\n\n\t\tif (this.maximizedNode === nodeToMaximize) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tfunction hideAllViewsBut(parent: BranchNode, exclude: LeafNode): void {\n\t\t\tfor (let i = 0; i < parent.children.length; i++) {\n\t\t\t\tconst child = parent.children[i];\n\t\t\t\tif (child instanceof LeafNode) {\n\t\t\t\t\tif (child !== exclude) {\n\t\t\t\t\t\tparent.setChildVisible(i, false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thideAllViewsBut(child, exclude);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thideAllViewsBut(this.root, nodeToMaximize);\n\n\t\tthis.maximizedNode = nodeToMaximize;\n\t\tthis._onDidChangeViewMaximized.fire(true);\n\t}\n\n\texitMaximizedView(): void {\n\t\tif (!this.maximizedNode) {\n\t\t\treturn;\n\t\t}\n\t\tthis.maximizedNode = undefined;\n\n\t\t// When hiding a view, it's previous size is cached.\n\t\t// To restore the sizes of all views, they need to be made visible in reverse order.\n\t\tfunction showViewsInReverseOrder(parent: BranchNode): void {\n\t\t\tfor (let index = parent.children.length - 1; index >= 0; index--) {\n\t\t\t\tconst child = parent.children[index];\n\t\t\t\tif (child instanceof LeafNode) {\n\t\t\t\t\tparent.setChildVisible(index, true);\n\t\t\t\t} else {\n\t\t\t\t\tshowViewsInReverseOrder(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tshowViewsInReverseOrder(this.root);\n\n\t\tthis._onDidChangeViewMaximized.fire(false);\n\t}\n\n\thasMaximizedView(): boolean {\n\t\treturn this.maximizedNode !== undefined;\n\t}\n\n\t/**\n\t * Returns whether the {@link IView view} is maximized.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\tisViewMaximized(location: GridLocation): boolean {\n\t\tconst [, node] = this.getNode(location);\n\t\tif (!(node instanceof LeafNode)) {\n\t\t\tthrow new Error('Location is not a LeafNode');\n\t\t}\n\t\treturn node === this.maximizedNode;\n\t}\n\n\t/**\n\t * Distribute the size among all {@link IView views} within the entire\n\t * grid or within a single {@link SplitView}.\n\t *\n\t * @param location The {@link GridLocation location} of a view containing\n\t * children views, which will have their sizes distributed within the parent\n\t * view's size. Provide `undefined` to recursively distribute all views' sizes\n\t * in the entire grid.\n\t */\n\tdistributeViewSizes(location?: GridLocation): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t}\n\n\t\tif (!location) {\n\t\t\tthis.root.distributeViewSizes(true);\n\t\t\treturn;\n\t\t}\n\n\t\tconst [, node] = this.getNode(location);\n\n\t\tif (!(node instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tnode.distributeViewSizes();\n\t\tthis.trySet2x2();\n\t}\n\n\t/**\n\t * Returns whether a {@link IView view} is visible.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\tisViewVisible(location: GridLocation): boolean {\n\t\tconst [rest, index] = tail(location);\n\t\tconst [, parent] = this.getNode(rest);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid from location');\n\t\t}\n\n\t\treturn parent.isChildVisible(index);\n\t}\n\n\t/**\n\t * Set the visibility state of a {@link IView view}.\n\t *\n\t * @param location The {@link GridLocation location} of the view.\n\t */\n\tsetViewVisible(location: GridLocation, visible: boolean): void {\n\t\tif (this.hasMaximizedView()) {\n\t\t\tthis.exitMaximizedView();\n\t\t\treturn;\n\t\t}\n\n\t\tconst [rest, index] = tail(location);\n\t\tconst [, parent] = this.getNode(rest);\n\n\t\tif (!(parent instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid from location');\n\t\t}\n\n\t\tparent.setChildVisible(index, visible);\n\t}\n\n\t/**\n\t * Returns a descriptor for the entire grid.\n\t */\n\tgetView(): GridBranchNode;\n\n\t/**\n\t * Returns a descriptor for a {@link GridLocation subtree} within the\n\t * {@link GridView}.\n\t *\n\t * @param location The {@link GridLocation location} of the root of\n\t * the {@link GridLocation subtree}.\n\t */\n\tgetView(location: GridLocation): GridNode;\n\tgetView(location?: GridLocation): GridNode {\n\t\tconst node = location ? this.getNode(location)[1] : this._root;\n\t\treturn this._getViews(node, this.orientation);\n\t}\n\n\t/**\n\t * Construct a new {@link GridView} from a JSON object.\n\t *\n\t * @param json The JSON object.\n\t * @param deserializer A deserializer which can revive each view.\n\t * @returns A new {@link GridView} instance.\n\t */\n\tstatic deserialize<T extends ISerializableView>(json: ISerializedGridView, deserializer: IViewDeserializer<T>, options: IGridViewOptions = {}): GridView {\n\t\tif (typeof json.orientation !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'orientation\\' property must be a number.');\n\t\t} else if (typeof json.width !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'width\\' property must be a number.');\n\t\t} else if (typeof json.height !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'height\\' property must be a number.');\n\t\t} else if (json.root?.type !== 'branch') {\n\t\t\tthrow new Error('Invalid JSON: \\'root\\' property must have \\'type\\' value of branch.');\n\t\t}\n\n\t\tconst orientation = json.orientation;\n\t\tconst height = json.height;\n\n\t\tconst result = new GridView(options);\n\t\tresult._deserialize(json.root, orientation, deserializer, height);\n\n\t\treturn result;\n\t}\n\n\tprivate _deserialize(root: ISerializedBranchNode, orientation: Orientation, deserializer: IViewDeserializer<ISerializableView>, orthogonalSize: number): void {\n\t\tthis.root = this._deserializeNode(root, orientation, deserializer, orthogonalSize) as BranchNode;\n\t}\n\n\tprivate _deserializeNode(node: ISerializedNode, orientation: Orientation, deserializer: IViewDeserializer<ISerializableView>, orthogonalSize: number): Node {\n\t\tlet result: Node;\n\t\tif (node.type === 'branch') {\n\t\t\tconst serializedChildren = node.data;\n\t\t\tconst children = serializedChildren.map(serializedChild => {\n\t\t\t\treturn {\n\t\t\t\t\tnode: this._deserializeNode(serializedChild, orthogonal(orientation), deserializer, node.size),\n\t\t\t\t\tvisible: (serializedChild as { visible?: boolean }).visible\n\t\t\t\t} satisfies INodeDescriptor;\n\t\t\t});\n\n\t\t\tresult = new BranchNode(orientation, this.layoutController, this.styles, this.proportionalLayout, node.size, orthogonalSize, undefined, children);\n\t\t} else {\n\t\t\tresult = new LeafNode(deserializer.fromJSON(node.data), orientation, this.layoutController, orthogonalSize, node.size);\n\t\t\tif (node.maximized && !this.maximizedNode) {\n\t\t\t\tthis.maximizedNode = result;\n\t\t\t\tthis._onDidChangeViewMaximized.fire(true);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate _getViews(node: Node, orientation: Orientation, cachedVisibleSize?: number): GridNode {\n\t\tconst box = { top: node.top, left: node.left, width: node.width, height: node.height };\n\n\t\tif (node instanceof LeafNode) {\n\t\t\treturn { view: node.view, box, cachedVisibleSize, maximized: this.maximizedNode === node };\n\t\t}\n\n\t\tconst children: GridNode[] = [];\n\n\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\tconst child = node.children[i];\n\t\t\tconst cachedVisibleSize = node.getChildCachedVisibleSize(i);\n\n\t\t\tchildren.push(this._getViews(child, orthogonal(orientation), cachedVisibleSize));\n\t\t}\n\n\t\treturn { children, box };\n\t}\n\n\tprivate getNode(location: GridLocation, node: Node = this.root, path: BranchNode[] = []): [BranchNode[], Node] {\n\t\tif (location.length === 0) {\n\t\t\treturn [path, node];\n\t\t}\n\n\t\tif (!(node instanceof BranchNode)) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index >= node.children.length) {\n\t\t\tthrow new Error('Invalid location');\n\t\t}\n\n\t\tconst child = node.children[index];\n\t\tpath.push(node);\n\n\t\treturn this.getNode(rest, child, path);\n\t}\n\n\t/**\n\t * Attempt to lock the {@link Sash sashes} in this {@link GridView} so\n\t * the grid behaves as a 2x2 matrix, with a corner sash in the middle.\n\t *\n\t * In case the grid isn't a 2x2 grid _and_ all sashes are not aligned,\n\t * this method is a no-op.\n\t */\n\ttrySet2x2(): void {\n\t\tthis.disposable2x2.dispose();\n\t\tthis.disposable2x2 = Disposable.None;\n\n\t\tif (this.root.children.length !== 2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [first, second] = this.root.children;\n\n\t\tif (!(first instanceof BranchNode) || !(second instanceof BranchNode)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.disposable2x2 = first.trySet2x2(second);\n\t}\n\n\t/**\n\t * Populate a map with views to DOM nodes.\n\t * @remarks To be used internally only.\n\t */\n\tgetViewMap(map: Map<IView, HTMLElement>, node?: Node): void {\n\t\tif (!node) {\n\t\t\tnode = this.root;\n\t\t}\n\n\t\tif (node instanceof BranchNode) {\n\t\t\tnode.children.forEach(child => this.getViewMap(map, child));\n\t\t} else {\n\t\t\tmap.set(node.view, node.element);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.onDidSashResetRelay.dispose();\n\t\tthis.root.dispose();\n\t\tthis.element.remove();\n\t}\n}\n"]}