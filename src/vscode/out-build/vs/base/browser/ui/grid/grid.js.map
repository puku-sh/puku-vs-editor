{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/browser/ui/grid/grid.ts","vs/base/browser/ui/grid/grid.ts"],"names":[],"mappings":"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","file":"grid.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IBoundarySashes, Orientation } from '../sash/sash.js';\nimport { equals, tail } from '../../../common/arrays.js';\nimport { Event } from '../../../common/event.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport './gridview.css';\nimport { Box, GridView, IGridViewOptions, IGridViewStyles, IView as IGridViewView, IViewSize, orthogonal, Sizing as GridViewSizing, GridLocation } from './gridview.js';\nimport type { SplitView, AutoSizing as SplitViewAutoSizing } from '../splitview/splitview.js';\n\nexport type { IViewSize };\nexport { LayoutPriority, Orientation, orthogonal } from './gridview.js';\n\nexport const enum Direction {\n\tUp,\n\tDown,\n\tLeft,\n\tRight\n}\n\nfunction oppositeDirection(direction: Direction): Direction {\n\tswitch (direction) {\n\t\tcase Direction.Up: return Direction.Down;\n\t\tcase Direction.Down: return Direction.Up;\n\t\tcase Direction.Left: return Direction.Right;\n\t\tcase Direction.Right: return Direction.Left;\n\t}\n}\n\n/**\n * The interface to implement for views within a {@link Grid}.\n */\nexport interface IView extends IGridViewView {\n\n\t/**\n\t * The preferred width for when the user double clicks a sash\n\t * adjacent to this view.\n\t */\n\treadonly preferredWidth?: number;\n\n\t/**\n\t * The preferred height for when the user double clicks a sash\n\t * adjacent to this view.\n\t */\n\treadonly preferredHeight?: number;\n}\n\nexport interface GridLeafNode<T extends IView> {\n\treadonly view: T;\n\treadonly box: Box;\n\treadonly cachedVisibleSize: number | undefined;\n\treadonly maximized: boolean;\n}\n\nexport interface GridBranchNode<T extends IView> {\n\treadonly children: GridNode<T>[];\n\treadonly box: Box;\n}\n\nexport type GridNode<T extends IView> = GridLeafNode<T> | GridBranchNode<T>;\n\nexport function isGridBranchNode<T extends IView>(node: GridNode<T>): node is GridBranchNode<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!(node as any).children;\n}\n\nfunction getGridNode<T extends IView>(node: GridNode<T>, location: GridLocation): GridNode<T> {\n\tif (location.length === 0) {\n\t\treturn node;\n\t}\n\n\tif (!isGridBranchNode(node)) {\n\t\tthrow new Error('Invalid location');\n\t}\n\n\tconst [index, ...rest] = location;\n\treturn getGridNode(node.children[index], rest);\n}\n\ninterface Range {\n\treadonly start: number;\n\treadonly end: number;\n}\n\nfunction intersects(one: Range, other: Range): boolean {\n\treturn !(one.start >= other.end || other.start >= one.end);\n}\n\ninterface Boundary {\n\treadonly offset: number;\n\treadonly range: Range;\n}\n\nfunction getBoxBoundary(box: Box, direction: Direction): Boundary {\n\tconst orientation = getDirectionOrientation(direction);\n\tconst offset = direction === Direction.Up ? box.top :\n\t\tdirection === Direction.Right ? box.left + box.width :\n\t\t\tdirection === Direction.Down ? box.top + box.height :\n\t\t\t\tbox.left;\n\n\tconst range = {\n\t\tstart: orientation === Orientation.HORIZONTAL ? box.top : box.left,\n\t\tend: orientation === Orientation.HORIZONTAL ? box.top + box.height : box.left + box.width\n\t};\n\n\treturn { offset, range };\n}\n\nfunction findAdjacentBoxLeafNodes<T extends IView>(boxNode: GridNode<T>, direction: Direction, boundary: Boundary): GridLeafNode<T>[] {\n\tconst result: GridLeafNode<T>[] = [];\n\n\tfunction _(boxNode: GridNode<T>, direction: Direction, boundary: Boundary): void {\n\t\tif (isGridBranchNode(boxNode)) {\n\t\t\tfor (const child of boxNode.children) {\n\t\t\t\t_(child, direction, boundary);\n\t\t\t}\n\t\t} else {\n\t\t\tconst { offset, range } = getBoxBoundary(boxNode.box, direction);\n\n\t\t\tif (offset === boundary.offset && intersects(range, boundary.range)) {\n\t\t\t\tresult.push(boxNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t_(boxNode, direction, boundary);\n\treturn result;\n}\n\nfunction getLocationOrientation(rootOrientation: Orientation, location: GridLocation): Orientation {\n\treturn location.length % 2 === 0 ? orthogonal(rootOrientation) : rootOrientation;\n}\n\nfunction getDirectionOrientation(direction: Direction): Orientation {\n\treturn direction === Direction.Up || direction === Direction.Down ? Orientation.VERTICAL : Orientation.HORIZONTAL;\n}\n\nexport function getRelativeLocation(rootOrientation: Orientation, location: GridLocation, direction: Direction): GridLocation {\n\tconst orientation = getLocationOrientation(rootOrientation, location);\n\tconst directionOrientation = getDirectionOrientation(direction);\n\n\tif (orientation === directionOrientation) {\n\t\tlet [rest, index] = tail(location);\n\n\t\tif (direction === Direction.Right || direction === Direction.Down) {\n\t\t\tindex += 1;\n\t\t}\n\n\t\treturn [...rest, index];\n\t} else {\n\t\tconst index = (direction === Direction.Right || direction === Direction.Down) ? 1 : 0;\n\t\treturn [...location, index];\n\t}\n}\n\nfunction indexInParent(element: HTMLElement): number {\n\tconst parentElement = element.parentElement;\n\n\tif (!parentElement) {\n\t\tthrow new Error('Invalid grid element');\n\t}\n\n\tlet el = parentElement.firstElementChild;\n\tlet index = 0;\n\n\twhile (el !== element && el !== parentElement.lastElementChild && el) {\n\t\tel = el.nextElementSibling;\n\t\tindex++;\n\t}\n\n\treturn index;\n}\n\n/**\n * Find the grid location of a specific DOM element by traversing the parent\n * chain and finding each child index on the way.\n *\n * This will break as soon as DOM structures of the Splitview or Gridview change.\n */\nfunction getGridLocation(element: HTMLElement): GridLocation {\n\tconst parentElement = element.parentElement;\n\n\tif (!parentElement) {\n\t\tthrow new Error('Invalid grid element');\n\t}\n\n\tif (/\\bmonaco-grid-view\\b/.test(parentElement.className)) {\n\t\treturn [];\n\t}\n\n\tconst index = indexInParent(parentElement);\n\tconst ancestor = parentElement.parentElement!.parentElement!.parentElement!.parentElement!;\n\treturn [...getGridLocation(ancestor), index];\n}\n\nexport type DistributeSizing = { type: 'distribute' };\nexport type SplitSizing = { type: 'split' };\nexport type AutoSizing = { type: 'auto' };\nexport type InvisibleSizing = { type: 'invisible'; cachedVisibleSize: number };\nexport type Sizing = DistributeSizing | SplitSizing | AutoSizing | InvisibleSizing;\n\nexport namespace Sizing {\n\texport const Distribute: DistributeSizing = { type: 'distribute' };\n\texport const Split: SplitSizing = { type: 'split' };\n\texport const Auto: AutoSizing = { type: 'auto' };\n\texport function Invisible(cachedVisibleSize: number): InvisibleSizing { return { type: 'invisible', cachedVisibleSize }; }\n}\n\nexport interface IGridStyles extends IGridViewStyles { }\nexport interface IGridOptions extends IGridViewOptions { }\n\n/**\n * The {@link Grid} exposes a Grid widget in a friendlier API than the underlying\n * {@link GridView} widget. Namely, all mutation operations are addressed by the\n * model elements, rather than indexes.\n *\n * It support the same features as the {@link GridView}.\n */\nexport class Grid<T extends IView = IView> extends Disposable {\n\n\tprotected gridview: GridView;\n\tprivate views = new Map<T, HTMLElement>();\n\n\t/**\n\t * The orientation of the grid. Matches the orientation of the root\n\t * {@link SplitView} in the grid's {@link GridLocation} model.\n\t */\n\tget orientation(): Orientation { return this.gridview.orientation; }\n\tset orientation(orientation: Orientation) { this.gridview.orientation = orientation; }\n\n\t/**\n\t * The width of the grid.\n\t */\n\tget width(): number { return this.gridview.width; }\n\n\t/**\n\t * The height of the grid.\n\t */\n\tget height(): number { return this.gridview.height; }\n\n\t/**\n\t * The minimum width of the grid.\n\t */\n\tget minimumWidth(): number { return this.gridview.minimumWidth; }\n\n\t/**\n\t * The minimum height of the grid.\n\t */\n\tget minimumHeight(): number { return this.gridview.minimumHeight; }\n\n\t/**\n\t * The maximum width of the grid.\n\t */\n\tget maximumWidth(): number { return this.gridview.maximumWidth; }\n\n\t/**\n\t * The maximum height of the grid.\n\t */\n\tget maximumHeight(): number { return this.gridview.maximumHeight; }\n\n\t/**\n\t * Fires whenever a view within the grid changes its size constraints.\n\t */\n\treadonly onDidChange: Event<{ width: number; height: number } | undefined>;\n\n\t/**\n\t * Fires whenever the user scrolls a {@link SplitView} within\n\t * the grid.\n\t */\n\treadonly onDidScroll: Event<void>;\n\n\t/**\n\t * A collection of sashes perpendicular to each edge of the grid.\n\t * Corner sashes will be created for each intersection.\n\t */\n\tget boundarySashes(): IBoundarySashes { return this.gridview.boundarySashes; }\n\tset boundarySashes(boundarySashes: IBoundarySashes) { this.gridview.boundarySashes = boundarySashes; }\n\n\t/**\n\t * Enable/disable edge snapping across all grid views.\n\t */\n\tset edgeSnapping(edgeSnapping: boolean) { this.gridview.edgeSnapping = edgeSnapping; }\n\n\t/**\n\t * The DOM element for this view.\n\t */\n\tget element(): HTMLElement { return this.gridview.element; }\n\n\tprivate didLayout = false;\n\n\treadonly onDidChangeViewMaximized: Event<boolean>;\n\t/**\n\t * Create a new {@link Grid}. A grid must *always* have a view\n\t * inside.\n\t *\n\t * @param view An initial view for this Grid.\n\t */\n\tconstructor(view: T | GridView, options: IGridOptions = {}) {\n\t\tsuper();\n\n\t\tif (view instanceof GridView) {\n\t\t\tthis.gridview = view;\n\t\t\tthis.gridview.getViewMap(this.views);\n\t\t} else {\n\t\t\tthis.gridview = new GridView(options);\n\t\t}\n\n\t\tthis._register(this.gridview);\n\t\tthis._register(this.gridview.onDidSashReset(this.onDidSashReset, this));\n\n\t\tif (!(view instanceof GridView)) {\n\t\t\tthis._addView(view, 0, [0]);\n\t\t}\n\n\t\tthis.onDidChange = this.gridview.onDidChange;\n\t\tthis.onDidScroll = this.gridview.onDidScroll;\n\t\tthis.onDidChangeViewMaximized = this.gridview.onDidChangeViewMaximized;\n\t}\n\n\tstyle(styles: IGridStyles): void {\n\t\tthis.gridview.style(styles);\n\t}\n\n\t/**\n\t * Layout the {@link Grid}.\n\t *\n\t * Optionally provide a `top` and `left` positions, those will propagate\n\t * as an origin for positions passed to {@link IView.layout}.\n\t *\n\t * @param width The width of the {@link Grid}.\n\t * @param height The height of the {@link Grid}.\n\t * @param top Optional, the top location of the {@link Grid}.\n\t * @param left Optional, the left location of the {@link Grid}.\n\t */\n\tlayout(width: number, height: number, top: number = 0, left: number = 0): void {\n\t\tthis.gridview.layout(width, height, top, left);\n\t\tthis.didLayout = true;\n\t}\n\n\t/**\n\t * Add a {@link IView view} to this {@link Grid}, based on another reference view.\n\t *\n\t * Take this grid as an example:\n\t *\n\t * ```\n\t *  +-----+---------------+\n\t *  |  A  |      B        |\n\t *  +-----+---------+-----+\n\t *  |        C      |     |\n\t *  +---------------+  D  |\n\t *  |        E      |     |\n\t *  +---------------+-----+\n\t * ```\n\t *\n\t * Calling `addView(X, Sizing.Distribute, C, Direction.Right)` will make the following\n\t * changes:\n\t *\n\t * ```\n\t *  +-----+---------------+\n\t *  |  A  |      B        |\n\t *  +-----+-+-------+-----+\n\t *  |   C   |   X   |     |\n\t *  +-------+-------+  D  |\n\t *  |        E      |     |\n\t *  +---------------+-----+\n\t * ```\n\t *\n\t * Or `addView(X, Sizing.Distribute, D, Direction.Down)`:\n\t *\n\t * ```\n\t *  +-----+---------------+\n\t *  |  A  |      B        |\n\t *  +-----+---------+-----+\n\t *  |        C      |  D  |\n\t *  +---------------+-----+\n\t *  |        E      |  X  |\n\t *  +---------------+-----+\n\t * ```\n\t *\n\t * @param newView The view to add.\n\t * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.\n\t * @param referenceView Another view to place this new view next to.\n\t * @param direction The direction the new view should be placed next to the reference view.\n\t */\n\taddView(newView: T, size: number | Sizing, referenceView: T, direction: Direction): void {\n\t\tif (this.views.has(newView)) {\n\t\t\tthrow new Error('Can\\'t add same view twice');\n\t\t}\n\n\t\tconst orientation = getDirectionOrientation(direction);\n\n\t\tif (this.views.size === 1 && this.orientation !== orientation) {\n\t\t\tthis.orientation = orientation;\n\t\t}\n\n\t\tconst referenceLocation = this.getViewLocation(referenceView);\n\t\tconst location = getRelativeLocation(this.gridview.orientation, referenceLocation, direction);\n\n\t\tlet viewSize: number | GridViewSizing;\n\n\t\tif (typeof size === 'number') {\n\t\t\tviewSize = size;\n\t\t} else if (size.type === 'split') {\n\t\t\tconst [, index] = tail(referenceLocation);\n\t\t\tviewSize = GridViewSizing.Split(index);\n\t\t} else if (size.type === 'distribute') {\n\t\t\tviewSize = GridViewSizing.Distribute;\n\t\t} else if (size.type === 'auto') {\n\t\t\tconst [, index] = tail(referenceLocation);\n\t\t\tviewSize = GridViewSizing.Auto(index);\n\t\t} else {\n\t\t\tviewSize = size;\n\t\t}\n\n\t\tthis._addView(newView, viewSize, location);\n\t}\n\n\tprivate addViewAt(newView: T, size: number | DistributeSizing | InvisibleSizing, location: GridLocation): void {\n\t\tif (this.views.has(newView)) {\n\t\t\tthrow new Error('Can\\'t add same view twice');\n\t\t}\n\n\t\tlet viewSize: number | GridViewSizing;\n\n\t\tif (typeof size === 'number') {\n\t\t\tviewSize = size;\n\t\t} else if (size.type === 'distribute') {\n\t\t\tviewSize = GridViewSizing.Distribute;\n\t\t} else {\n\t\t\tviewSize = size;\n\t\t}\n\n\t\tthis._addView(newView, viewSize, location);\n\t}\n\n\tprotected _addView(newView: T, size: number | GridViewSizing, location: GridLocation): void {\n\t\tthis.views.set(newView, newView.element);\n\t\tthis.gridview.addView(newView, size, location);\n\t}\n\n\t/**\n\t * Remove a {@link IView view} from this {@link Grid}.\n\t *\n\t * @param view The {@link IView view} to remove.\n\t * @param sizing Whether to distribute other {@link IView view}'s sizes.\n\t */\n\tremoveView(view: T, sizing?: Sizing): void {\n\t\tif (this.views.size === 1) {\n\t\t\tthrow new Error('Can\\'t remove last view');\n\t\t}\n\n\t\tconst location = this.getViewLocation(view);\n\n\t\tlet gridViewSizing: DistributeSizing | SplitViewAutoSizing | undefined;\n\n\t\tif (sizing?.type === 'distribute') {\n\t\t\tgridViewSizing = GridViewSizing.Distribute;\n\t\t} else if (sizing?.type === 'auto') {\n\t\t\tconst index = location[location.length - 1];\n\t\t\tgridViewSizing = GridViewSizing.Auto(index === 0 ? 1 : index - 1);\n\t\t}\n\n\t\tthis.gridview.removeView(location, gridViewSizing);\n\t\tthis.views.delete(view);\n\t}\n\n\t/**\n\t * Move a {@link IView view} to another location in the grid.\n\t *\n\t * @remarks See {@link Grid.addView}.\n\t *\n\t * @param view The {@link IView view} to move.\n\t * @param sizing Either a fixed size, or a dynamic {@link Sizing} strategy.\n\t * @param referenceView Another view to place the view next to.\n\t * @param direction The direction the view should be placed next to the reference view.\n\t */\n\tmoveView(view: T, sizing: number | Sizing, referenceView: T, direction: Direction): void {\n\t\tconst sourceLocation = this.getViewLocation(view);\n\t\tconst [sourceParentLocation, from] = tail(sourceLocation);\n\n\t\tconst referenceLocation = this.getViewLocation(referenceView);\n\t\tconst targetLocation = getRelativeLocation(this.gridview.orientation, referenceLocation, direction);\n\t\tconst [targetParentLocation, to] = tail(targetLocation);\n\n\t\tif (equals(sourceParentLocation, targetParentLocation)) {\n\t\t\tthis.gridview.moveView(sourceParentLocation, from, to);\n\t\t} else {\n\t\t\tthis.removeView(view, typeof sizing === 'number' ? undefined : sizing);\n\t\t\tthis.addView(view, sizing, referenceView, direction);\n\t\t}\n\t}\n\n\t/**\n\t * Move a {@link IView view} to another location in the grid.\n\t *\n\t * @remarks Internal method, do not use without knowing what you're doing.\n\t * @remarks See {@link GridView.moveView}.\n\t *\n\t * @param view The {@link IView view} to move.\n\t * @param location The {@link GridLocation location} to insert the view on.\n\t */\n\tmoveViewTo(view: T, location: GridLocation): void {\n\t\tconst sourceLocation = this.getViewLocation(view);\n\t\tconst [sourceParentLocation, from] = tail(sourceLocation);\n\t\tconst [targetParentLocation, to] = tail(location);\n\n\t\tif (equals(sourceParentLocation, targetParentLocation)) {\n\t\t\tthis.gridview.moveView(sourceParentLocation, from, to);\n\t\t} else {\n\t\t\tconst size = this.getViewSize(view);\n\t\t\tconst orientation = getLocationOrientation(this.gridview.orientation, sourceLocation);\n\t\t\tconst cachedViewSize = this.getViewCachedVisibleSize(view);\n\t\t\tconst sizing = typeof cachedViewSize === 'undefined'\n\t\t\t\t? (orientation === Orientation.HORIZONTAL ? size.width : size.height)\n\t\t\t\t: Sizing.Invisible(cachedViewSize);\n\n\t\t\tthis.removeView(view);\n\t\t\tthis.addViewAt(view, sizing, location);\n\t\t}\n\t}\n\n\t/**\n\t * Swap two {@link IView views} within the {@link Grid}.\n\t *\n\t * @param from One {@link IView view}.\n\t * @param to Another {@link IView view}.\n\t */\n\tswapViews(from: T, to: T): void {\n\t\tconst fromLocation = this.getViewLocation(from);\n\t\tconst toLocation = this.getViewLocation(to);\n\t\treturn this.gridview.swapViews(fromLocation, toLocation);\n\t}\n\n\t/**\n\t * Resize a {@link IView view}.\n\t *\n\t * @param view The {@link IView view} to resize.\n\t * @param size The size the view should be.\n\t */\n\tresizeView(view: T, size: IViewSize): void {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.resizeView(location, size);\n\t}\n\n\t/**\n\t * Returns whether all other {@link IView views} are at their minimum size.\n\t *\n\t * @param view The reference {@link IView view}.\n\t */\n\tisViewExpanded(view: T): boolean {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.isViewExpanded(location);\n\t}\n\n\t/**\n\t * Returns whether the {@link IView view} is maximized.\n\t *\n\t * @param view The reference {@link IView view}.\n\t */\n\tisViewMaximized(view: T): boolean {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.isViewMaximized(location);\n\t}\n\n\t/**\n\t * Returns whether the {@link IView view} is maximized.\n\t *\n\t * @param view The reference {@link IView view}.\n\t */\n\thasMaximizedView(): boolean {\n\t\treturn this.gridview.hasMaximizedView();\n\t}\n\n\t/**\n\t * Get the size of a {@link IView view}.\n\t *\n\t * @param view The {@link IView view}. Provide `undefined` to get the size\n\t * of the grid itself.\n\t */\n\tgetViewSize(view?: T): IViewSize {\n\t\tif (!view) {\n\t\t\treturn this.gridview.getViewSize();\n\t\t}\n\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.getViewSize(location);\n\t}\n\n\t/**\n\t * Get the cached visible size of a {@link IView view}. This was the size\n\t * of the view at the moment it last became hidden.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\tgetViewCachedVisibleSize(view: T): number | undefined {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.getViewCachedVisibleSize(location);\n\t}\n\n\t/**\n\t * Maximizes the specified view and hides all other views.\n\t * @param view The view to maximize.\n\t */\n\tmaximizeView(view: T) {\n\t\tif (this.views.size < 2) {\n\t\t\tthrow new Error('At least two views are required to maximize a view');\n\t\t}\n\t\tconst location = this.getViewLocation(view);\n\t\tthis.gridview.maximizeView(location);\n\t}\n\n\texitMaximizedView(): void {\n\t\tthis.gridview.exitMaximizedView();\n\t}\n\n\t/**\n\t * Expand the size of a {@link IView view} by collapsing all other views\n\t * to their minimum sizes.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\texpandView(view: T): void {\n\t\tconst location = this.getViewLocation(view);\n\t\tthis.gridview.expandView(location);\n\t}\n\n\t/**\n\t * Distribute the size among all {@link IView views} within the entire\n\t * grid or within a single {@link SplitView}.\n\t */\n\tdistributeViewSizes(): void {\n\t\tthis.gridview.distributeViewSizes();\n\t}\n\n\t/**\n\t * Returns whether a {@link IView view} is visible.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\tisViewVisible(view: T): boolean {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.isViewVisible(location);\n\t}\n\n\t/**\n\t * Set the visibility state of a {@link IView view}.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\tsetViewVisible(view: T, visible: boolean): void {\n\t\tconst location = this.getViewLocation(view);\n\t\tthis.gridview.setViewVisible(location, visible);\n\t}\n\n\t/**\n\t * Returns a descriptor for the entire grid.\n\t */\n\tgetViews(): GridBranchNode<T> {\n\t\treturn this.gridview.getView() as GridBranchNode<T>;\n\t}\n\n\t/**\n\t * Utility method to return the collection all views which intersect\n\t * a view's edge.\n\t *\n\t * @param view The {@link IView view}.\n\t * @param direction Which direction edge to be considered.\n\t * @param wrap Whether the grid wraps around (from right to left, from bottom to top).\n\t */\n\tgetNeighborViews(view: T, direction: Direction, wrap: boolean = false): T[] {\n\t\tif (!this.didLayout) {\n\t\t\tthrow new Error('Can\\'t call getNeighborViews before first layout');\n\t\t}\n\n\t\tconst location = this.getViewLocation(view);\n\t\tconst root = this.getViews();\n\t\tconst node = getGridNode(root, location);\n\t\tlet boundary = getBoxBoundary(node.box, direction);\n\n\t\tif (wrap) {\n\t\t\tif (direction === Direction.Up && node.box.top === 0) {\n\t\t\t\tboundary = { offset: root.box.top + root.box.height, range: boundary.range };\n\t\t\t} else if (direction === Direction.Right && node.box.left + node.box.width === root.box.width) {\n\t\t\t\tboundary = { offset: 0, range: boundary.range };\n\t\t\t} else if (direction === Direction.Down && node.box.top + node.box.height === root.box.height) {\n\t\t\t\tboundary = { offset: 0, range: boundary.range };\n\t\t\t} else if (direction === Direction.Left && node.box.left === 0) {\n\t\t\t\tboundary = { offset: root.box.left + root.box.width, range: boundary.range };\n\t\t\t}\n\t\t}\n\n\t\treturn findAdjacentBoxLeafNodes(root, oppositeDirection(direction), boundary)\n\t\t\t.map(node => node.view);\n\t}\n\n\tprivate getViewLocation(view: T): GridLocation {\n\t\tconst element = this.views.get(view);\n\n\t\tif (!element) {\n\t\t\tthrow new Error('View not found');\n\t\t}\n\n\t\treturn getGridLocation(element);\n\t}\n\n\tprivate onDidSashReset(location: GridLocation): void {\n\t\tconst resizeToPreferredSize = (location: GridLocation): boolean => {\n\t\t\tconst node = this.gridview.getView(location) as GridNode<T>;\n\n\t\t\tif (isGridBranchNode(node)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst direction = getLocationOrientation(this.orientation, location);\n\t\t\tconst size = direction === Orientation.HORIZONTAL ? node.view.preferredWidth : node.view.preferredHeight;\n\n\t\t\tif (typeof size !== 'number') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst viewSize = direction === Orientation.HORIZONTAL ? { width: Math.round(size) } : { height: Math.round(size) };\n\t\t\tthis.gridview.resizeView(location, viewSize);\n\t\t\treturn true;\n\t\t};\n\n\t\tif (resizeToPreferredSize(location)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [parentLocation, index] = tail(location);\n\n\t\tif (resizeToPreferredSize([...parentLocation, index + 1])) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.gridview.distributeViewSizes(parentLocation);\n\t}\n}\n\nexport interface ISerializableView extends IView {\n\ttoJSON(): object;\n}\n\nexport interface IViewDeserializer<T extends ISerializableView> {\n\tfromJSON(json: any): T;\n}\n\nexport interface ISerializedLeafNode {\n\ttype: 'leaf';\n\tdata: unknown;\n\tsize: number;\n\tvisible?: boolean;\n\tmaximized?: boolean;\n}\n\nexport interface ISerializedBranchNode {\n\ttype: 'branch';\n\tdata: ISerializedNode[];\n\tsize: number;\n\tvisible?: boolean;\n}\n\nexport type ISerializedNode = ISerializedLeafNode | ISerializedBranchNode;\n\nexport interface ISerializedGrid {\n\troot: ISerializedNode;\n\torientation: Orientation;\n\twidth: number;\n\theight: number;\n}\n\n/**\n * A {@link Grid} which can serialize itself.\n */\nexport class SerializableGrid<T extends ISerializableView> extends Grid<T> {\n\n\tprivate static serializeNode<T extends ISerializableView>(node: GridNode<T>, orientation: Orientation): ISerializedNode {\n\t\tconst size = orientation === Orientation.VERTICAL ? node.box.width : node.box.height;\n\n\t\tif (!isGridBranchNode(node)) {\n\t\t\tconst serializedLeafNode: ISerializedLeafNode = { type: 'leaf', data: node.view.toJSON(), size };\n\n\t\t\tif (typeof node.cachedVisibleSize === 'number') {\n\t\t\t\tserializedLeafNode.size = node.cachedVisibleSize;\n\t\t\t\tserializedLeafNode.visible = false;\n\t\t\t} else if (node.maximized) {\n\t\t\t\tserializedLeafNode.maximized = true;\n\t\t\t}\n\n\t\t\treturn serializedLeafNode;\n\t\t}\n\n\t\tconst data = node.children.map(c => SerializableGrid.serializeNode(c, orthogonal(orientation)));\n\t\tif (data.some(c => c.visible !== false)) {\n\t\t\treturn { type: 'branch', data: data, size };\n\t\t}\n\t\treturn { type: 'branch', data: data, size, visible: false };\n\t}\n\n\t/**\n\t * Construct a new {@link SerializableGrid} from a JSON object.\n\t *\n\t * @param json The JSON object.\n\t * @param deserializer A deserializer which can revive each view.\n\t * @returns A new {@link SerializableGrid} instance.\n\t */\n\tstatic deserialize<T extends ISerializableView>(json: ISerializedGrid, deserializer: IViewDeserializer<T>, options: IGridOptions = {}): SerializableGrid<T> {\n\t\tif (typeof json.orientation !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'orientation\\' property must be a number.');\n\t\t} else if (typeof json.width !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'width\\' property must be a number.');\n\t\t} else if (typeof json.height !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'height\\' property must be a number.');\n\t\t}\n\n\t\tconst gridview = GridView.deserialize(json, deserializer, options);\n\t\tconst result = new SerializableGrid<T>(gridview, options);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Construct a new {@link SerializableGrid} from a grid descriptor.\n\t *\n\t * @param gridDescriptor A grid descriptor in which leaf nodes point to actual views.\n\t * @returns A new {@link SerializableGrid} instance.\n\t */\n\tstatic from<T extends ISerializableView>(gridDescriptor: GridDescriptor<T>, options: IGridOptions = {}): SerializableGrid<T> {\n\t\treturn SerializableGrid.deserialize(createSerializedGrid(gridDescriptor), { fromJSON: view => view }, options);\n\t}\n\n\t/**\n\t * Useful information in order to proportionally restore view sizes\n\t * upon the very first layout call.\n\t */\n\tprivate initialLayoutContext: boolean = true;\n\n\t/**\n\t * Serialize this grid into a JSON object.\n\t */\n\tserialize(): ISerializedGrid {\n\t\treturn {\n\t\t\troot: SerializableGrid.serializeNode(this.getViews(), this.orientation),\n\t\t\torientation: this.orientation,\n\t\t\twidth: this.width,\n\t\t\theight: this.height\n\t\t};\n\t}\n\n\toverride layout(width: number, height: number, top: number = 0, left: number = 0): void {\n\t\tsuper.layout(width, height, top, left);\n\n\t\tif (this.initialLayoutContext) {\n\t\t\tthis.initialLayoutContext = false;\n\t\t\tthis.gridview.trySet2x2();\n\t\t}\n\t}\n}\n\nexport type GridLeafNodeDescriptor<T> = { size?: number; data?: any };\nexport type GridBranchNodeDescriptor<T> = { size?: number; groups: GridNodeDescriptor<T>[] };\nexport type GridNodeDescriptor<T> = GridBranchNodeDescriptor<T> | GridLeafNodeDescriptor<T>;\nexport type GridDescriptor<T> = { orientation: Orientation } & GridBranchNodeDescriptor<T>;\n\nfunction isGridBranchNodeDescriptor<T>(nodeDescriptor: GridNodeDescriptor<T>): nodeDescriptor is GridBranchNodeDescriptor<T> {\n\treturn !!(nodeDescriptor as GridBranchNodeDescriptor<T>).groups;\n}\n\nexport function sanitizeGridNodeDescriptor<T>(nodeDescriptor: GridNodeDescriptor<T>, rootNode: boolean): void {\n\t// eslint-disable-next-line local/code-no-any-casts\n\tif (!rootNode && (nodeDescriptor as any).groups && (nodeDescriptor as any).groups.length <= 1) {\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t(nodeDescriptor as any).groups = undefined;\n\t}\n\n\tif (!isGridBranchNodeDescriptor(nodeDescriptor)) {\n\t\treturn;\n\t}\n\n\tlet totalDefinedSize = 0;\n\tlet totalDefinedSizeCount = 0;\n\n\tfor (const child of nodeDescriptor.groups) {\n\t\tsanitizeGridNodeDescriptor(child, false);\n\n\t\tif (child.size) {\n\t\t\ttotalDefinedSize += child.size;\n\t\t\ttotalDefinedSizeCount++;\n\t\t}\n\t}\n\n\tconst totalUndefinedSize = totalDefinedSizeCount > 0 ? totalDefinedSize : 1;\n\tconst totalUndefinedSizeCount = nodeDescriptor.groups.length - totalDefinedSizeCount;\n\tconst eachUndefinedSize = totalUndefinedSize / totalUndefinedSizeCount;\n\n\tfor (const child of nodeDescriptor.groups) {\n\t\tif (!child.size) {\n\t\t\tchild.size = eachUndefinedSize;\n\t\t}\n\t}\n}\n\nfunction createSerializedNode<T>(nodeDescriptor: GridNodeDescriptor<T>): ISerializedNode {\n\tif (isGridBranchNodeDescriptor(nodeDescriptor)) {\n\t\treturn { type: 'branch', data: nodeDescriptor.groups.map(c => createSerializedNode(c)), size: nodeDescriptor.size! };\n\t} else {\n\t\treturn { type: 'leaf', data: nodeDescriptor.data, size: nodeDescriptor.size! };\n\t}\n}\n\nfunction getDimensions(node: ISerializedNode, orientation: Orientation): { width?: number; height?: number } {\n\tif (node.type === 'branch') {\n\t\tconst childrenDimensions = node.data.map(c => getDimensions(c, orthogonal(orientation)));\n\n\t\tif (orientation === Orientation.VERTICAL) {\n\t\t\tconst width = node.size || (childrenDimensions.length === 0 ? undefined : Math.max(...childrenDimensions.map(d => d.width || 0)));\n\t\t\tconst height = childrenDimensions.length === 0 ? undefined : childrenDimensions.reduce((r, d) => r + (d.height || 0), 0);\n\t\t\treturn { width, height };\n\t\t} else {\n\t\t\tconst width = childrenDimensions.length === 0 ? undefined : childrenDimensions.reduce((r, d) => r + (d.width || 0), 0);\n\t\t\tconst height = node.size || (childrenDimensions.length === 0 ? undefined : Math.max(...childrenDimensions.map(d => d.height || 0)));\n\t\t\treturn { width, height };\n\t\t}\n\t} else {\n\t\tconst width = orientation === Orientation.VERTICAL ? node.size : undefined;\n\t\tconst height = orientation === Orientation.VERTICAL ? undefined : node.size;\n\t\treturn { width, height };\n\t}\n}\n\n/**\n * Creates a new JSON object from a {@link GridDescriptor}, which can\n * be deserialized by {@link SerializableGrid.deserialize}.\n */\nexport function createSerializedGrid<T>(gridDescriptor: GridDescriptor<T>): ISerializedGrid {\n\tsanitizeGridNodeDescriptor(gridDescriptor, true);\n\n\tconst root = createSerializedNode(gridDescriptor);\n\tconst { width, height } = getDimensions(root, gridDescriptor.orientation);\n\n\treturn {\n\t\troot,\n\t\torientation: gridDescriptor.orientation,\n\t\twidth: width || 1,\n\t\theight: height || 1\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IBoundarySashes, Orientation } from '../sash/sash.js';\nimport { equals, tail } from '../../../common/arrays.js';\nimport { Event } from '../../../common/event.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport './gridview.css';\nimport { Box, GridView, IGridViewOptions, IGridViewStyles, IView as IGridViewView, IViewSize, orthogonal, Sizing as GridViewSizing, GridLocation } from './gridview.js';\nimport type { SplitView, AutoSizing as SplitViewAutoSizing } from '../splitview/splitview.js';\n\nexport type { IViewSize };\nexport { LayoutPriority, Orientation, orthogonal } from './gridview.js';\n\nexport const enum Direction {\n\tUp,\n\tDown,\n\tLeft,\n\tRight\n}\n\nfunction oppositeDirection(direction: Direction): Direction {\n\tswitch (direction) {\n\t\tcase Direction.Up: return Direction.Down;\n\t\tcase Direction.Down: return Direction.Up;\n\t\tcase Direction.Left: return Direction.Right;\n\t\tcase Direction.Right: return Direction.Left;\n\t}\n}\n\n/**\n * The interface to implement for views within a {@link Grid}.\n */\nexport interface IView extends IGridViewView {\n\n\t/**\n\t * The preferred width for when the user double clicks a sash\n\t * adjacent to this view.\n\t */\n\treadonly preferredWidth?: number;\n\n\t/**\n\t * The preferred height for when the user double clicks a sash\n\t * adjacent to this view.\n\t */\n\treadonly preferredHeight?: number;\n}\n\nexport interface GridLeafNode<T extends IView> {\n\treadonly view: T;\n\treadonly box: Box;\n\treadonly cachedVisibleSize: number | undefined;\n\treadonly maximized: boolean;\n}\n\nexport interface GridBranchNode<T extends IView> {\n\treadonly children: GridNode<T>[];\n\treadonly box: Box;\n}\n\nexport type GridNode<T extends IView> = GridLeafNode<T> | GridBranchNode<T>;\n\nexport function isGridBranchNode<T extends IView>(node: GridNode<T>): node is GridBranchNode<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!(node as any).children;\n}\n\nfunction getGridNode<T extends IView>(node: GridNode<T>, location: GridLocation): GridNode<T> {\n\tif (location.length === 0) {\n\t\treturn node;\n\t}\n\n\tif (!isGridBranchNode(node)) {\n\t\tthrow new Error('Invalid location');\n\t}\n\n\tconst [index, ...rest] = location;\n\treturn getGridNode(node.children[index], rest);\n}\n\ninterface Range {\n\treadonly start: number;\n\treadonly end: number;\n}\n\nfunction intersects(one: Range, other: Range): boolean {\n\treturn !(one.start >= other.end || other.start >= one.end);\n}\n\ninterface Boundary {\n\treadonly offset: number;\n\treadonly range: Range;\n}\n\nfunction getBoxBoundary(box: Box, direction: Direction): Boundary {\n\tconst orientation = getDirectionOrientation(direction);\n\tconst offset = direction === Direction.Up ? box.top :\n\t\tdirection === Direction.Right ? box.left + box.width :\n\t\t\tdirection === Direction.Down ? box.top + box.height :\n\t\t\t\tbox.left;\n\n\tconst range = {\n\t\tstart: orientation === Orientation.HORIZONTAL ? box.top : box.left,\n\t\tend: orientation === Orientation.HORIZONTAL ? box.top + box.height : box.left + box.width\n\t};\n\n\treturn { offset, range };\n}\n\nfunction findAdjacentBoxLeafNodes<T extends IView>(boxNode: GridNode<T>, direction: Direction, boundary: Boundary): GridLeafNode<T>[] {\n\tconst result: GridLeafNode<T>[] = [];\n\n\tfunction _(boxNode: GridNode<T>, direction: Direction, boundary: Boundary): void {\n\t\tif (isGridBranchNode(boxNode)) {\n\t\t\tfor (const child of boxNode.children) {\n\t\t\t\t_(child, direction, boundary);\n\t\t\t}\n\t\t} else {\n\t\t\tconst { offset, range } = getBoxBoundary(boxNode.box, direction);\n\n\t\t\tif (offset === boundary.offset && intersects(range, boundary.range)) {\n\t\t\t\tresult.push(boxNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t_(boxNode, direction, boundary);\n\treturn result;\n}\n\nfunction getLocationOrientation(rootOrientation: Orientation, location: GridLocation): Orientation {\n\treturn location.length % 2 === 0 ? orthogonal(rootOrientation) : rootOrientation;\n}\n\nfunction getDirectionOrientation(direction: Direction): Orientation {\n\treturn direction === Direction.Up || direction === Direction.Down ? Orientation.VERTICAL : Orientation.HORIZONTAL;\n}\n\nexport function getRelativeLocation(rootOrientation: Orientation, location: GridLocation, direction: Direction): GridLocation {\n\tconst orientation = getLocationOrientation(rootOrientation, location);\n\tconst directionOrientation = getDirectionOrientation(direction);\n\n\tif (orientation === directionOrientation) {\n\t\tlet [rest, index] = tail(location);\n\n\t\tif (direction === Direction.Right || direction === Direction.Down) {\n\t\t\tindex += 1;\n\t\t}\n\n\t\treturn [...rest, index];\n\t} else {\n\t\tconst index = (direction === Direction.Right || direction === Direction.Down) ? 1 : 0;\n\t\treturn [...location, index];\n\t}\n}\n\nfunction indexInParent(element: HTMLElement): number {\n\tconst parentElement = element.parentElement;\n\n\tif (!parentElement) {\n\t\tthrow new Error('Invalid grid element');\n\t}\n\n\tlet el = parentElement.firstElementChild;\n\tlet index = 0;\n\n\twhile (el !== element && el !== parentElement.lastElementChild && el) {\n\t\tel = el.nextElementSibling;\n\t\tindex++;\n\t}\n\n\treturn index;\n}\n\n/**\n * Find the grid location of a specific DOM element by traversing the parent\n * chain and finding each child index on the way.\n *\n * This will break as soon as DOM structures of the Splitview or Gridview change.\n */\nfunction getGridLocation(element: HTMLElement): GridLocation {\n\tconst parentElement = element.parentElement;\n\n\tif (!parentElement) {\n\t\tthrow new Error('Invalid grid element');\n\t}\n\n\tif (/\\bmonaco-grid-view\\b/.test(parentElement.className)) {\n\t\treturn [];\n\t}\n\n\tconst index = indexInParent(parentElement);\n\tconst ancestor = parentElement.parentElement!.parentElement!.parentElement!.parentElement!;\n\treturn [...getGridLocation(ancestor), index];\n}\n\nexport type DistributeSizing = { type: 'distribute' };\nexport type SplitSizing = { type: 'split' };\nexport type AutoSizing = { type: 'auto' };\nexport type InvisibleSizing = { type: 'invisible'; cachedVisibleSize: number };\nexport type Sizing = DistributeSizing | SplitSizing | AutoSizing | InvisibleSizing;\n\nexport namespace Sizing {\n\texport const Distribute: DistributeSizing = { type: 'distribute' };\n\texport const Split: SplitSizing = { type: 'split' };\n\texport const Auto: AutoSizing = { type: 'auto' };\n\texport function Invisible(cachedVisibleSize: number): InvisibleSizing { return { type: 'invisible', cachedVisibleSize }; }\n}\n\nexport interface IGridStyles extends IGridViewStyles { }\nexport interface IGridOptions extends IGridViewOptions { }\n\n/**\n * The {@link Grid} exposes a Grid widget in a friendlier API than the underlying\n * {@link GridView} widget. Namely, all mutation operations are addressed by the\n * model elements, rather than indexes.\n *\n * It support the same features as the {@link GridView}.\n */\nexport class Grid<T extends IView = IView> extends Disposable {\n\n\tprotected gridview: GridView;\n\tprivate views = new Map<T, HTMLElement>();\n\n\t/**\n\t * The orientation of the grid. Matches the orientation of the root\n\t * {@link SplitView} in the grid's {@link GridLocation} model.\n\t */\n\tget orientation(): Orientation { return this.gridview.orientation; }\n\tset orientation(orientation: Orientation) { this.gridview.orientation = orientation; }\n\n\t/**\n\t * The width of the grid.\n\t */\n\tget width(): number { return this.gridview.width; }\n\n\t/**\n\t * The height of the grid.\n\t */\n\tget height(): number { return this.gridview.height; }\n\n\t/**\n\t * The minimum width of the grid.\n\t */\n\tget minimumWidth(): number { return this.gridview.minimumWidth; }\n\n\t/**\n\t * The minimum height of the grid.\n\t */\n\tget minimumHeight(): number { return this.gridview.minimumHeight; }\n\n\t/**\n\t * The maximum width of the grid.\n\t */\n\tget maximumWidth(): number { return this.gridview.maximumWidth; }\n\n\t/**\n\t * The maximum height of the grid.\n\t */\n\tget maximumHeight(): number { return this.gridview.maximumHeight; }\n\n\t/**\n\t * Fires whenever a view within the grid changes its size constraints.\n\t */\n\treadonly onDidChange: Event<{ width: number; height: number } | undefined>;\n\n\t/**\n\t * Fires whenever the user scrolls a {@link SplitView} within\n\t * the grid.\n\t */\n\treadonly onDidScroll: Event<void>;\n\n\t/**\n\t * A collection of sashes perpendicular to each edge of the grid.\n\t * Corner sashes will be created for each intersection.\n\t */\n\tget boundarySashes(): IBoundarySashes { return this.gridview.boundarySashes; }\n\tset boundarySashes(boundarySashes: IBoundarySashes) { this.gridview.boundarySashes = boundarySashes; }\n\n\t/**\n\t * Enable/disable edge snapping across all grid views.\n\t */\n\tset edgeSnapping(edgeSnapping: boolean) { this.gridview.edgeSnapping = edgeSnapping; }\n\n\t/**\n\t * The DOM element for this view.\n\t */\n\tget element(): HTMLElement { return this.gridview.element; }\n\n\tprivate didLayout = false;\n\n\treadonly onDidChangeViewMaximized: Event<boolean>;\n\t/**\n\t * Create a new {@link Grid}. A grid must *always* have a view\n\t * inside.\n\t *\n\t * @param view An initial view for this Grid.\n\t */\n\tconstructor(view: T | GridView, options: IGridOptions = {}) {\n\t\tsuper();\n\n\t\tif (view instanceof GridView) {\n\t\t\tthis.gridview = view;\n\t\t\tthis.gridview.getViewMap(this.views);\n\t\t} else {\n\t\t\tthis.gridview = new GridView(options);\n\t\t}\n\n\t\tthis._register(this.gridview);\n\t\tthis._register(this.gridview.onDidSashReset(this.onDidSashReset, this));\n\n\t\tif (!(view instanceof GridView)) {\n\t\t\tthis._addView(view, 0, [0]);\n\t\t}\n\n\t\tthis.onDidChange = this.gridview.onDidChange;\n\t\tthis.onDidScroll = this.gridview.onDidScroll;\n\t\tthis.onDidChangeViewMaximized = this.gridview.onDidChangeViewMaximized;\n\t}\n\n\tstyle(styles: IGridStyles): void {\n\t\tthis.gridview.style(styles);\n\t}\n\n\t/**\n\t * Layout the {@link Grid}.\n\t *\n\t * Optionally provide a `top` and `left` positions, those will propagate\n\t * as an origin for positions passed to {@link IView.layout}.\n\t *\n\t * @param width The width of the {@link Grid}.\n\t * @param height The height of the {@link Grid}.\n\t * @param top Optional, the top location of the {@link Grid}.\n\t * @param left Optional, the left location of the {@link Grid}.\n\t */\n\tlayout(width: number, height: number, top: number = 0, left: number = 0): void {\n\t\tthis.gridview.layout(width, height, top, left);\n\t\tthis.didLayout = true;\n\t}\n\n\t/**\n\t * Add a {@link IView view} to this {@link Grid}, based on another reference view.\n\t *\n\t * Take this grid as an example:\n\t *\n\t * ```\n\t *  +-----+---------------+\n\t *  |  A  |      B        |\n\t *  +-----+---------+-----+\n\t *  |        C      |     |\n\t *  +---------------+  D  |\n\t *  |        E      |     |\n\t *  +---------------+-----+\n\t * ```\n\t *\n\t * Calling `addView(X, Sizing.Distribute, C, Direction.Right)` will make the following\n\t * changes:\n\t *\n\t * ```\n\t *  +-----+---------------+\n\t *  |  A  |      B        |\n\t *  +-----+-+-------+-----+\n\t *  |   C   |   X   |     |\n\t *  +-------+-------+  D  |\n\t *  |        E      |     |\n\t *  +---------------+-----+\n\t * ```\n\t *\n\t * Or `addView(X, Sizing.Distribute, D, Direction.Down)`:\n\t *\n\t * ```\n\t *  +-----+---------------+\n\t *  |  A  |      B        |\n\t *  +-----+---------+-----+\n\t *  |        C      |  D  |\n\t *  +---------------+-----+\n\t *  |        E      |  X  |\n\t *  +---------------+-----+\n\t * ```\n\t *\n\t * @param newView The view to add.\n\t * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.\n\t * @param referenceView Another view to place this new view next to.\n\t * @param direction The direction the new view should be placed next to the reference view.\n\t */\n\taddView(newView: T, size: number | Sizing, referenceView: T, direction: Direction): void {\n\t\tif (this.views.has(newView)) {\n\t\t\tthrow new Error('Can\\'t add same view twice');\n\t\t}\n\n\t\tconst orientation = getDirectionOrientation(direction);\n\n\t\tif (this.views.size === 1 && this.orientation !== orientation) {\n\t\t\tthis.orientation = orientation;\n\t\t}\n\n\t\tconst referenceLocation = this.getViewLocation(referenceView);\n\t\tconst location = getRelativeLocation(this.gridview.orientation, referenceLocation, direction);\n\n\t\tlet viewSize: number | GridViewSizing;\n\n\t\tif (typeof size === 'number') {\n\t\t\tviewSize = size;\n\t\t} else if (size.type === 'split') {\n\t\t\tconst [, index] = tail(referenceLocation);\n\t\t\tviewSize = GridViewSizing.Split(index);\n\t\t} else if (size.type === 'distribute') {\n\t\t\tviewSize = GridViewSizing.Distribute;\n\t\t} else if (size.type === 'auto') {\n\t\t\tconst [, index] = tail(referenceLocation);\n\t\t\tviewSize = GridViewSizing.Auto(index);\n\t\t} else {\n\t\t\tviewSize = size;\n\t\t}\n\n\t\tthis._addView(newView, viewSize, location);\n\t}\n\n\tprivate addViewAt(newView: T, size: number | DistributeSizing | InvisibleSizing, location: GridLocation): void {\n\t\tif (this.views.has(newView)) {\n\t\t\tthrow new Error('Can\\'t add same view twice');\n\t\t}\n\n\t\tlet viewSize: number | GridViewSizing;\n\n\t\tif (typeof size === 'number') {\n\t\t\tviewSize = size;\n\t\t} else if (size.type === 'distribute') {\n\t\t\tviewSize = GridViewSizing.Distribute;\n\t\t} else {\n\t\t\tviewSize = size;\n\t\t}\n\n\t\tthis._addView(newView, viewSize, location);\n\t}\n\n\tprotected _addView(newView: T, size: number | GridViewSizing, location: GridLocation): void {\n\t\tthis.views.set(newView, newView.element);\n\t\tthis.gridview.addView(newView, size, location);\n\t}\n\n\t/**\n\t * Remove a {@link IView view} from this {@link Grid}.\n\t *\n\t * @param view The {@link IView view} to remove.\n\t * @param sizing Whether to distribute other {@link IView view}'s sizes.\n\t */\n\tremoveView(view: T, sizing?: Sizing): void {\n\t\tif (this.views.size === 1) {\n\t\t\tthrow new Error('Can\\'t remove last view');\n\t\t}\n\n\t\tconst location = this.getViewLocation(view);\n\n\t\tlet gridViewSizing: DistributeSizing | SplitViewAutoSizing | undefined;\n\n\t\tif (sizing?.type === 'distribute') {\n\t\t\tgridViewSizing = GridViewSizing.Distribute;\n\t\t} else if (sizing?.type === 'auto') {\n\t\t\tconst index = location[location.length - 1];\n\t\t\tgridViewSizing = GridViewSizing.Auto(index === 0 ? 1 : index - 1);\n\t\t}\n\n\t\tthis.gridview.removeView(location, gridViewSizing);\n\t\tthis.views.delete(view);\n\t}\n\n\t/**\n\t * Move a {@link IView view} to another location in the grid.\n\t *\n\t * @remarks See {@link Grid.addView}.\n\t *\n\t * @param view The {@link IView view} to move.\n\t * @param sizing Either a fixed size, or a dynamic {@link Sizing} strategy.\n\t * @param referenceView Another view to place the view next to.\n\t * @param direction The direction the view should be placed next to the reference view.\n\t */\n\tmoveView(view: T, sizing: number | Sizing, referenceView: T, direction: Direction): void {\n\t\tconst sourceLocation = this.getViewLocation(view);\n\t\tconst [sourceParentLocation, from] = tail(sourceLocation);\n\n\t\tconst referenceLocation = this.getViewLocation(referenceView);\n\t\tconst targetLocation = getRelativeLocation(this.gridview.orientation, referenceLocation, direction);\n\t\tconst [targetParentLocation, to] = tail(targetLocation);\n\n\t\tif (equals(sourceParentLocation, targetParentLocation)) {\n\t\t\tthis.gridview.moveView(sourceParentLocation, from, to);\n\t\t} else {\n\t\t\tthis.removeView(view, typeof sizing === 'number' ? undefined : sizing);\n\t\t\tthis.addView(view, sizing, referenceView, direction);\n\t\t}\n\t}\n\n\t/**\n\t * Move a {@link IView view} to another location in the grid.\n\t *\n\t * @remarks Internal method, do not use without knowing what you're doing.\n\t * @remarks See {@link GridView.moveView}.\n\t *\n\t * @param view The {@link IView view} to move.\n\t * @param location The {@link GridLocation location} to insert the view on.\n\t */\n\tmoveViewTo(view: T, location: GridLocation): void {\n\t\tconst sourceLocation = this.getViewLocation(view);\n\t\tconst [sourceParentLocation, from] = tail(sourceLocation);\n\t\tconst [targetParentLocation, to] = tail(location);\n\n\t\tif (equals(sourceParentLocation, targetParentLocation)) {\n\t\t\tthis.gridview.moveView(sourceParentLocation, from, to);\n\t\t} else {\n\t\t\tconst size = this.getViewSize(view);\n\t\t\tconst orientation = getLocationOrientation(this.gridview.orientation, sourceLocation);\n\t\t\tconst cachedViewSize = this.getViewCachedVisibleSize(view);\n\t\t\tconst sizing = typeof cachedViewSize === 'undefined'\n\t\t\t\t? (orientation === Orientation.HORIZONTAL ? size.width : size.height)\n\t\t\t\t: Sizing.Invisible(cachedViewSize);\n\n\t\t\tthis.removeView(view);\n\t\t\tthis.addViewAt(view, sizing, location);\n\t\t}\n\t}\n\n\t/**\n\t * Swap two {@link IView views} within the {@link Grid}.\n\t *\n\t * @param from One {@link IView view}.\n\t * @param to Another {@link IView view}.\n\t */\n\tswapViews(from: T, to: T): void {\n\t\tconst fromLocation = this.getViewLocation(from);\n\t\tconst toLocation = this.getViewLocation(to);\n\t\treturn this.gridview.swapViews(fromLocation, toLocation);\n\t}\n\n\t/**\n\t * Resize a {@link IView view}.\n\t *\n\t * @param view The {@link IView view} to resize.\n\t * @param size The size the view should be.\n\t */\n\tresizeView(view: T, size: IViewSize): void {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.resizeView(location, size);\n\t}\n\n\t/**\n\t * Returns whether all other {@link IView views} are at their minimum size.\n\t *\n\t * @param view The reference {@link IView view}.\n\t */\n\tisViewExpanded(view: T): boolean {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.isViewExpanded(location);\n\t}\n\n\t/**\n\t * Returns whether the {@link IView view} is maximized.\n\t *\n\t * @param view The reference {@link IView view}.\n\t */\n\tisViewMaximized(view: T): boolean {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.isViewMaximized(location);\n\t}\n\n\t/**\n\t * Returns whether the {@link IView view} is maximized.\n\t *\n\t * @param view The reference {@link IView view}.\n\t */\n\thasMaximizedView(): boolean {\n\t\treturn this.gridview.hasMaximizedView();\n\t}\n\n\t/**\n\t * Get the size of a {@link IView view}.\n\t *\n\t * @param view The {@link IView view}. Provide `undefined` to get the size\n\t * of the grid itself.\n\t */\n\tgetViewSize(view?: T): IViewSize {\n\t\tif (!view) {\n\t\t\treturn this.gridview.getViewSize();\n\t\t}\n\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.getViewSize(location);\n\t}\n\n\t/**\n\t * Get the cached visible size of a {@link IView view}. This was the size\n\t * of the view at the moment it last became hidden.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\tgetViewCachedVisibleSize(view: T): number | undefined {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.getViewCachedVisibleSize(location);\n\t}\n\n\t/**\n\t * Maximizes the specified view and hides all other views.\n\t * @param view The view to maximize.\n\t */\n\tmaximizeView(view: T) {\n\t\tif (this.views.size < 2) {\n\t\t\tthrow new Error('At least two views are required to maximize a view');\n\t\t}\n\t\tconst location = this.getViewLocation(view);\n\t\tthis.gridview.maximizeView(location);\n\t}\n\n\texitMaximizedView(): void {\n\t\tthis.gridview.exitMaximizedView();\n\t}\n\n\t/**\n\t * Expand the size of a {@link IView view} by collapsing all other views\n\t * to their minimum sizes.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\texpandView(view: T): void {\n\t\tconst location = this.getViewLocation(view);\n\t\tthis.gridview.expandView(location);\n\t}\n\n\t/**\n\t * Distribute the size among all {@link IView views} within the entire\n\t * grid or within a single {@link SplitView}.\n\t */\n\tdistributeViewSizes(): void {\n\t\tthis.gridview.distributeViewSizes();\n\t}\n\n\t/**\n\t * Returns whether a {@link IView view} is visible.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\tisViewVisible(view: T): boolean {\n\t\tconst location = this.getViewLocation(view);\n\t\treturn this.gridview.isViewVisible(location);\n\t}\n\n\t/**\n\t * Set the visibility state of a {@link IView view}.\n\t *\n\t * @param view The {@link IView view}.\n\t */\n\tsetViewVisible(view: T, visible: boolean): void {\n\t\tconst location = this.getViewLocation(view);\n\t\tthis.gridview.setViewVisible(location, visible);\n\t}\n\n\t/**\n\t * Returns a descriptor for the entire grid.\n\t */\n\tgetViews(): GridBranchNode<T> {\n\t\treturn this.gridview.getView() as GridBranchNode<T>;\n\t}\n\n\t/**\n\t * Utility method to return the collection all views which intersect\n\t * a view's edge.\n\t *\n\t * @param view The {@link IView view}.\n\t * @param direction Which direction edge to be considered.\n\t * @param wrap Whether the grid wraps around (from right to left, from bottom to top).\n\t */\n\tgetNeighborViews(view: T, direction: Direction, wrap: boolean = false): T[] {\n\t\tif (!this.didLayout) {\n\t\t\tthrow new Error('Can\\'t call getNeighborViews before first layout');\n\t\t}\n\n\t\tconst location = this.getViewLocation(view);\n\t\tconst root = this.getViews();\n\t\tconst node = getGridNode(root, location);\n\t\tlet boundary = getBoxBoundary(node.box, direction);\n\n\t\tif (wrap) {\n\t\t\tif (direction === Direction.Up && node.box.top === 0) {\n\t\t\t\tboundary = { offset: root.box.top + root.box.height, range: boundary.range };\n\t\t\t} else if (direction === Direction.Right && node.box.left + node.box.width === root.box.width) {\n\t\t\t\tboundary = { offset: 0, range: boundary.range };\n\t\t\t} else if (direction === Direction.Down && node.box.top + node.box.height === root.box.height) {\n\t\t\t\tboundary = { offset: 0, range: boundary.range };\n\t\t\t} else if (direction === Direction.Left && node.box.left === 0) {\n\t\t\t\tboundary = { offset: root.box.left + root.box.width, range: boundary.range };\n\t\t\t}\n\t\t}\n\n\t\treturn findAdjacentBoxLeafNodes(root, oppositeDirection(direction), boundary)\n\t\t\t.map(node => node.view);\n\t}\n\n\tprivate getViewLocation(view: T): GridLocation {\n\t\tconst element = this.views.get(view);\n\n\t\tif (!element) {\n\t\t\tthrow new Error('View not found');\n\t\t}\n\n\t\treturn getGridLocation(element);\n\t}\n\n\tprivate onDidSashReset(location: GridLocation): void {\n\t\tconst resizeToPreferredSize = (location: GridLocation): boolean => {\n\t\t\tconst node = this.gridview.getView(location) as GridNode<T>;\n\n\t\t\tif (isGridBranchNode(node)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst direction = getLocationOrientation(this.orientation, location);\n\t\t\tconst size = direction === Orientation.HORIZONTAL ? node.view.preferredWidth : node.view.preferredHeight;\n\n\t\t\tif (typeof size !== 'number') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst viewSize = direction === Orientation.HORIZONTAL ? { width: Math.round(size) } : { height: Math.round(size) };\n\t\t\tthis.gridview.resizeView(location, viewSize);\n\t\t\treturn true;\n\t\t};\n\n\t\tif (resizeToPreferredSize(location)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [parentLocation, index] = tail(location);\n\n\t\tif (resizeToPreferredSize([...parentLocation, index + 1])) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.gridview.distributeViewSizes(parentLocation);\n\t}\n}\n\nexport interface ISerializableView extends IView {\n\ttoJSON(): object;\n}\n\nexport interface IViewDeserializer<T extends ISerializableView> {\n\tfromJSON(json: any): T;\n}\n\nexport interface ISerializedLeafNode {\n\ttype: 'leaf';\n\tdata: unknown;\n\tsize: number;\n\tvisible?: boolean;\n\tmaximized?: boolean;\n}\n\nexport interface ISerializedBranchNode {\n\ttype: 'branch';\n\tdata: ISerializedNode[];\n\tsize: number;\n\tvisible?: boolean;\n}\n\nexport type ISerializedNode = ISerializedLeafNode | ISerializedBranchNode;\n\nexport interface ISerializedGrid {\n\troot: ISerializedNode;\n\torientation: Orientation;\n\twidth: number;\n\theight: number;\n}\n\n/**\n * A {@link Grid} which can serialize itself.\n */\nexport class SerializableGrid<T extends ISerializableView> extends Grid<T> {\n\n\tprivate static serializeNode<T extends ISerializableView>(node: GridNode<T>, orientation: Orientation): ISerializedNode {\n\t\tconst size = orientation === Orientation.VERTICAL ? node.box.width : node.box.height;\n\n\t\tif (!isGridBranchNode(node)) {\n\t\t\tconst serializedLeafNode: ISerializedLeafNode = { type: 'leaf', data: node.view.toJSON(), size };\n\n\t\t\tif (typeof node.cachedVisibleSize === 'number') {\n\t\t\t\tserializedLeafNode.size = node.cachedVisibleSize;\n\t\t\t\tserializedLeafNode.visible = false;\n\t\t\t} else if (node.maximized) {\n\t\t\t\tserializedLeafNode.maximized = true;\n\t\t\t}\n\n\t\t\treturn serializedLeafNode;\n\t\t}\n\n\t\tconst data = node.children.map(c => SerializableGrid.serializeNode(c, orthogonal(orientation)));\n\t\tif (data.some(c => c.visible !== false)) {\n\t\t\treturn { type: 'branch', data: data, size };\n\t\t}\n\t\treturn { type: 'branch', data: data, size, visible: false };\n\t}\n\n\t/**\n\t * Construct a new {@link SerializableGrid} from a JSON object.\n\t *\n\t * @param json The JSON object.\n\t * @param deserializer A deserializer which can revive each view.\n\t * @returns A new {@link SerializableGrid} instance.\n\t */\n\tstatic deserialize<T extends ISerializableView>(json: ISerializedGrid, deserializer: IViewDeserializer<T>, options: IGridOptions = {}): SerializableGrid<T> {\n\t\tif (typeof json.orientation !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'orientation\\' property must be a number.');\n\t\t} else if (typeof json.width !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'width\\' property must be a number.');\n\t\t} else if (typeof json.height !== 'number') {\n\t\t\tthrow new Error('Invalid JSON: \\'height\\' property must be a number.');\n\t\t}\n\n\t\tconst gridview = GridView.deserialize(json, deserializer, options);\n\t\tconst result = new SerializableGrid<T>(gridview, options);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Construct a new {@link SerializableGrid} from a grid descriptor.\n\t *\n\t * @param gridDescriptor A grid descriptor in which leaf nodes point to actual views.\n\t * @returns A new {@link SerializableGrid} instance.\n\t */\n\tstatic from<T extends ISerializableView>(gridDescriptor: GridDescriptor<T>, options: IGridOptions = {}): SerializableGrid<T> {\n\t\treturn SerializableGrid.deserialize(createSerializedGrid(gridDescriptor), { fromJSON: view => view }, options);\n\t}\n\n\t/**\n\t * Useful information in order to proportionally restore view sizes\n\t * upon the very first layout call.\n\t */\n\tprivate initialLayoutContext: boolean = true;\n\n\t/**\n\t * Serialize this grid into a JSON object.\n\t */\n\tserialize(): ISerializedGrid {\n\t\treturn {\n\t\t\troot: SerializableGrid.serializeNode(this.getViews(), this.orientation),\n\t\t\torientation: this.orientation,\n\t\t\twidth: this.width,\n\t\t\theight: this.height\n\t\t};\n\t}\n\n\toverride layout(width: number, height: number, top: number = 0, left: number = 0): void {\n\t\tsuper.layout(width, height, top, left);\n\n\t\tif (this.initialLayoutContext) {\n\t\t\tthis.initialLayoutContext = false;\n\t\t\tthis.gridview.trySet2x2();\n\t\t}\n\t}\n}\n\nexport type GridLeafNodeDescriptor<T> = { size?: number; data?: any };\nexport type GridBranchNodeDescriptor<T> = { size?: number; groups: GridNodeDescriptor<T>[] };\nexport type GridNodeDescriptor<T> = GridBranchNodeDescriptor<T> | GridLeafNodeDescriptor<T>;\nexport type GridDescriptor<T> = { orientation: Orientation } & GridBranchNodeDescriptor<T>;\n\nfunction isGridBranchNodeDescriptor<T>(nodeDescriptor: GridNodeDescriptor<T>): nodeDescriptor is GridBranchNodeDescriptor<T> {\n\treturn !!(nodeDescriptor as GridBranchNodeDescriptor<T>).groups;\n}\n\nexport function sanitizeGridNodeDescriptor<T>(nodeDescriptor: GridNodeDescriptor<T>, rootNode: boolean): void {\n\t// eslint-disable-next-line local/code-no-any-casts\n\tif (!rootNode && (nodeDescriptor as any).groups && (nodeDescriptor as any).groups.length <= 1) {\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t(nodeDescriptor as any).groups = undefined;\n\t}\n\n\tif (!isGridBranchNodeDescriptor(nodeDescriptor)) {\n\t\treturn;\n\t}\n\n\tlet totalDefinedSize = 0;\n\tlet totalDefinedSizeCount = 0;\n\n\tfor (const child of nodeDescriptor.groups) {\n\t\tsanitizeGridNodeDescriptor(child, false);\n\n\t\tif (child.size) {\n\t\t\ttotalDefinedSize += child.size;\n\t\t\ttotalDefinedSizeCount++;\n\t\t}\n\t}\n\n\tconst totalUndefinedSize = totalDefinedSizeCount > 0 ? totalDefinedSize : 1;\n\tconst totalUndefinedSizeCount = nodeDescriptor.groups.length - totalDefinedSizeCount;\n\tconst eachUndefinedSize = totalUndefinedSize / totalUndefinedSizeCount;\n\n\tfor (const child of nodeDescriptor.groups) {\n\t\tif (!child.size) {\n\t\t\tchild.size = eachUndefinedSize;\n\t\t}\n\t}\n}\n\nfunction createSerializedNode<T>(nodeDescriptor: GridNodeDescriptor<T>): ISerializedNode {\n\tif (isGridBranchNodeDescriptor(nodeDescriptor)) {\n\t\treturn { type: 'branch', data: nodeDescriptor.groups.map(c => createSerializedNode(c)), size: nodeDescriptor.size! };\n\t} else {\n\t\treturn { type: 'leaf', data: nodeDescriptor.data, size: nodeDescriptor.size! };\n\t}\n}\n\nfunction getDimensions(node: ISerializedNode, orientation: Orientation): { width?: number; height?: number } {\n\tif (node.type === 'branch') {\n\t\tconst childrenDimensions = node.data.map(c => getDimensions(c, orthogonal(orientation)));\n\n\t\tif (orientation === Orientation.VERTICAL) {\n\t\t\tconst width = node.size || (childrenDimensions.length === 0 ? undefined : Math.max(...childrenDimensions.map(d => d.width || 0)));\n\t\t\tconst height = childrenDimensions.length === 0 ? undefined : childrenDimensions.reduce((r, d) => r + (d.height || 0), 0);\n\t\t\treturn { width, height };\n\t\t} else {\n\t\t\tconst width = childrenDimensions.length === 0 ? undefined : childrenDimensions.reduce((r, d) => r + (d.width || 0), 0);\n\t\t\tconst height = node.size || (childrenDimensions.length === 0 ? undefined : Math.max(...childrenDimensions.map(d => d.height || 0)));\n\t\t\treturn { width, height };\n\t\t}\n\t} else {\n\t\tconst width = orientation === Orientation.VERTICAL ? node.size : undefined;\n\t\tconst height = orientation === Orientation.VERTICAL ? undefined : node.size;\n\t\treturn { width, height };\n\t}\n}\n\n/**\n * Creates a new JSON object from a {@link GridDescriptor}, which can\n * be deserialized by {@link SerializableGrid.deserialize}.\n */\nexport function createSerializedGrid<T>(gridDescriptor: GridDescriptor<T>): ISerializedGrid {\n\tsanitizeGridNodeDescriptor(gridDescriptor, true);\n\n\tconst root = createSerializedNode(gridDescriptor);\n\tconst { width, height } = getDimensions(root, gridDescriptor.orientation);\n\n\treturn {\n\t\troot,\n\t\torientation: gridDescriptor.orientation,\n\t\twidth: width || 1,\n\t\theight: height || 1\n\t};\n}\n"]}