{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/async.ts","vs/base/common/async.ts"],"names":[],"mappings":"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","file":"async.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { BugIndicatingError, CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, isDisposable, MutableDisposable, toDisposable } from './lifecycle.js';\nimport { extUri as defaultExtUri, IExtUri } from './resources.js';\nimport { URI } from './uri.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\nimport { Lazy } from './lazy.js';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\n/**\n * Returns a promise that can be cancelled using the provided cancellation token.\n *\n * @remarks When cancellation is requested, the promise will be rejected with a {@link CancellationError}.\n * If the promise resolves to a disposable object, it will be automatically disposed when cancellation\n * is requested.\n *\n * @param callback A function that accepts a cancellation token and returns a promise\n * @returns A promise that can be cancelled\n */\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\n\tlet isCancelled = false;\n\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tisCancelled = true;\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\n\t\t\tif (!isCancelled) {\n\t\t\t\tresolve(value);\n\n\t\t\t} else if (isDisposable(value)) {\n\t\t\t\t// promise has been cancelled, result is disposable and will\n\t\t\t\t// be cleaned up\n\t\t\t\tvalue.dispose();\n\t\t\t}\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: unknown) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: unknown) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Wraps a cancellable promise such that it is no cancellable. Can be used to\n * avoid issues with shared promises that would normally be returned as\n * cancellable to consumers.\n */\nexport function notCancellablePromise<T>(promise: CancelablePromise<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tpromise.then(resolve, reject);\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport function raceCancellablePromises<T>(cancellablePromises: (CancelablePromise<T> | Promise<T>)[]): CancelablePromise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst promise = Promise.race(promises) as CancelablePromise<T>;\n\tpromise.cancel = () => {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex && (cancellablePromise as CancelablePromise<T>).cancel) {\n\t\t\t\t(cancellablePromise as CancelablePromise<T>).cancel();\n\t\t\t}\n\t\t});\n\t};\n\tpromise.finally(() => {\n\t\tpromise.cancel();\n\t});\n\treturn promise;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nexport function promiseWithResolvers<T>(): { promise: Promise<T>; resolve: (value: T | PromiseLike<T>) => void; reject: (err?: any) => void } {\n\tlet resolve: (value: T | PromiseLike<T>) => void;\n\tlet reject: (reason?: any) => void;\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\nexport interface ICancellableTask<T> {\n\t(token: CancellationToken): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ICancellableTask<Promise<any>> | null;\n\tprivate cancellationTokenSource: CancellationTokenSource;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\n\t\tthis.cancellationTokenSource = new CancellationTokenSource();\n\t}\n\n\tqueue<T>(promiseFactory: ICancellableTask<Promise<T>>): Promise<T> {\n\t\tif (this.cancellationTokenSource.token.isCancellationRequested) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.cancellationTokenSource.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory(this.cancellationTokenSource.token);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancellationTokenSource.cancel();\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n\n\tpeek(key: TKey): Promise<unknown> | undefined {\n\t\treturn this.promiseMap.get(key) || undefined;\n\t}\n\n\tkeys(): IterableIterator<TKey> {\n\t\treturn this.promiseMap.keys();\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: unknown) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ICancellableTask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: Timeout;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.delete(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: unknown): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result as T);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n\n\tclear(): void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T> {\n\n\tprivate _size = 0;\n\tprivate _isDisposed = false;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t *\n\t * @returns A promise that resolved when all work is done (onDrained) or when\n\t * there is nothing to do\n\t */\n\twhenIdle(): Promise<void> {\n\t\treturn this.size > 0\n\t\t\t? Event.toPromise(this.onDrained)\n\t\t\t: Promise.resolve();\n\t}\n\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis.runningPromises--;\n\t\tif (--this._size === 0) {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis.outstandingPromises.length = 0;\n\t\tthis._size = this.runningPromises;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis.outstandingPromises.length = 0; // stop further processing\n\t\tthis._size = 0;\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueSize(resource: URI, extUri: IExtUri = defaultExtUri): number {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\treturn this.queues.get(key)?.size ?? 0;\n\t}\n\n\tqueueFor(resource: URI, factory: ITask<Promise<void>>, extUri: IExtUri = defaultExtUri): Promise<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue.queue(factory);\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport type Task<T = void> = () => (Promise<T> | T);\n\n/**\n * Wrap a type in an optional promise. This can be useful to avoid the runtime\n * overhead of creating a promise.\n */\nexport type MaybePromise<T> = Promise<T> | T;\n\n/**\n * Processes tasks in the order they were scheduled.\n*/\nexport class TaskQueue {\n\tprivate _runningTask: Task<any> | undefined = undefined;\n\tprivate _pendingTasks: { task: Task<any>; deferred: DeferredPromise<any>; setUndefinedWhenCleared: boolean }[] = [];\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is rejected with a CancellationError.\n\t*/\n\tpublic schedule<T>(task: Task<T>): Promise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: false });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is resolved with undefined.\n\t*/\n\tpublic scheduleSkipIfCleared<T>(task: Task<T>): Promise<T | undefined> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: true });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\tprivate _runIfNotRunning(): void {\n\t\tif (this._runningTask === undefined) {\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\tprivate async _processQueue(): Promise<void> {\n\t\tif (this._pendingTasks.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst next = this._pendingTasks.shift();\n\t\tif (!next) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._runningTask) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tthis._runningTask = next.task;\n\n\t\ttry {\n\t\t\tconst result = await next.task();\n\t\t\tnext.deferred.complete(result);\n\t\t} catch (e) {\n\t\t\tnext.deferred.error(e);\n\t\t} finally {\n\t\t\tthis._runningTask = undefined;\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\t/**\n\t * Clears all pending tasks. Does not cancel the currently running task.\n\t*/\n\tpublic clearPending(): void {\n\t\tconst tasks = this._pendingTasks;\n\t\tthis._pendingTasks = [];\n\t\tfor (const task of tasks) {\n\t\t\tif (task.setUndefinedWhenCleared) {\n\t\t\t\ttask.deferred.complete(undefined);\n\t\t\t} else {\n\t\t\t\ttask.deferred.error(new CancellationError());\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: Timeout | undefined;\n\tprivate _isDisposed = false;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = undefined;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis._isDisposed = true;\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== undefined) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = undefined;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tif (this._token !== undefined) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\tprivate isDisposed = false;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: Timeout | undefined;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = undefined;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== undefined;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = undefined;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: Timeout | undefined;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = undefined;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== undefined;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = undefined;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n\n\t/**\n\t * When enabled will guarantee that two distinct calls to `work()` are not executed\n\t * without throttle delay between them.\n\t * Otherwise if the worker isn't currently throttling it will execute work immediately.\n\t */\n\twaitThrottleDelayBetweenWorkUnits?: boolean;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\tprivate lastExecutionTime = 0;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\tconst timeSinceLastExecution = Date.now() - this.lastExecutionTime;\n\n\t\tif (!this.throttler.value && (!this.options.waitThrottleDelayBetweenWorkUnits || timeSinceLastExecution >= this.options.throttleDelay)) {\n\t\t\t// Work directly if we are not throttling and we are not\n\t\t\t// enforced to throttle between `work()` calls.\n\t\t\tthis.doWork();\n\t\t} else if (!this.throttler.value && this.options.waitThrottleDelayBetweenWorkUnits) {\n\t\t\t// Otherwise, schedule the throttler to work.\n\t\t\tthis.scheduleThrottler(Math.max(this.options.throttleDelay - timeSinceLastExecution, 0));\n\t\t} else {\n\t\t\t// Otherwise, our work will be picked up by the running throttler\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\t\tthis.lastExecutionTime = Date.now();\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.scheduleThrottler();\n\t\t}\n\t}\n\n\tprivate scheduleThrottler(delay = this.options.throttleDelay): void {\n\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\tthis.throttler.clear();\n\n\t\t\tthis.doWork();\n\t\t}, delay);\n\t\tthis.throttler.value.schedule();\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.pendingWork.length = 0;\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tconst safeGlobal: any = globalThis;\n\tif (typeof safeGlobal.requestIdleCallback !== 'function' || typeof safeGlobal.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner, timeout?) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: typeof safeGlobal, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner, timeout) => _runWhenIdle(globalThis, runner, timeout);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tconst { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers<void>();\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve,\n\t\t\t\tpromiseReject\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tpublic static fromPromise<T>(promise: Promise<T>): DeferredPromise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tdeferred.settleWith(promise);\n\t\treturn deferred;\n\t}\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: unknown } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic settleWith(promise: Promise<T>): Promise<void> {\n\t\treturn promise.then(\n\t\t\tvalue => this.complete(value),\n\t\t\terror => this.error(error)\n\t\t);\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class StatefulPromise<T> {\n\tprivate _value: T | undefined = undefined;\n\tget value(): T | undefined { return this._value; }\n\n\tprivate _error: unknown = undefined;\n\tget error(): unknown { return this._error; }\n\n\tprivate _isResolved = false;\n\tget isResolved() { return this._isResolved; }\n\n\tpublic readonly promise: Promise<T>;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(\n\t\t\tvalue => {\n\t\t\t\tthis._value = value;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tthis._error = error;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\tif (!this._isResolved) {\n\t\t\tthrow new BugIndicatingError('Promise is not resolved yet');\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\nexport class LazyStatefulPromise<T> {\n\tprivate readonly _promise = new Lazy(() => new StatefulPromise(this._compute()));\n\n\tconstructor(\n\t\tprivate readonly _compute: () => Promise<T>,\n\t) { }\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\treturn this._promise.value.requireValue();\n\t}\n\n\t/**\n\t * Returns the promise (and triggers a computation of the promise if not yet done so).\n\t */\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._promise.value.promise;\n\t}\n\n\t/**\n\t * Reads the current value without triggering a computation of the promise.\n\t */\n\tpublic get currentValue(): T | undefined {\n\t\treturn this._promise.rawValue?.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): unknown | Promise<unknown>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onReturn?: () => void | Promise<void>;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>, onReturn?: () => void | Promise<void>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onReturn = onReturn;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t},\n\t\t\treturn: async () => {\n\t\t\t\tthis._onReturn?.();\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableObject<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\n\nexport function createCancelableAsyncIterableProducer<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableProducer<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableProducer<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\nexport class AsyncIterableSource<T> {\n\n\tprivate readonly _deferred = new DeferredPromise<void>();\n\tprivate readonly _asyncIterable: AsyncIterableObject<T>;\n\n\tprivate _errorFn: (error: Error) => void;\n\tprivate _emitOneFn: (item: T) => void;\n\tprivate _emitManyFn: (item: T[]) => void;\n\n\t/**\n\t *\n\t * @param onReturn A function that will be called when consuming the async iterable\n\t * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.\n\t * This is NOT called when resolving this source by its owner.\n\t */\n\tconstructor(onReturn?: () => Promise<void> | void) {\n\t\tthis._asyncIterable = new AsyncIterableObject(emitter => {\n\n\t\t\tif (earlyError) {\n\t\t\t\temitter.reject(earlyError);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (earlyItems) {\n\t\t\t\temitter.emitMany(earlyItems);\n\t\t\t}\n\t\t\tthis._errorFn = (error: Error) => emitter.reject(error);\n\t\t\tthis._emitOneFn = (item: T) => emitter.emitOne(item);\n\t\t\tthis._emitManyFn = (items: T[]) => emitter.emitMany(items);\n\t\t\treturn this._deferred.p;\n\t\t}, onReturn);\n\n\t\tlet earlyError: Error | undefined;\n\t\tlet earlyItems: T[] | undefined;\n\n\n\t\tthis._errorFn = (error: Error) => {\n\t\t\tif (!earlyError) {\n\t\t\t\tearlyError = error;\n\t\t\t}\n\t\t};\n\t\tthis._emitOneFn = (item: T) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = [];\n\t\t\t}\n\t\t\tearlyItems.push(item);\n\t\t};\n\t\tthis._emitManyFn = (items: T[]) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = items.slice();\n\t\t\t} else {\n\t\t\t\titems.forEach(item => earlyItems!.push(item));\n\t\t\t}\n\t\t};\n\t}\n\n\tget asyncIterable(): AsyncIterableObject<T> {\n\t\treturn this._asyncIterable;\n\t}\n\n\tresolve(): void {\n\t\tthis._deferred.complete();\n\t}\n\n\treject(error: Error): void {\n\t\tthis._errorFn(error);\n\t\tthis._deferred.complete();\n\t}\n\n\temitOne(item: T): void {\n\t\tthis._emitOneFn(item);\n\t}\n\n\temitMany(items: T[]) {\n\t\tthis._emitManyFn(items);\n\t}\n}\n\nexport function cancellableIterable<T>(iterableOrIterator: AsyncIterator<T> | AsyncIterable<T>, token: CancellationToken): AsyncIterableIterator<T> {\n\tconst iterator = Symbol.asyncIterator in iterableOrIterator ? iterableOrIterator[Symbol.asyncIterator]() : iterableOrIterator;\n\n\treturn {\n\t\tasync next(): Promise<IteratorResult<T>> {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t\tconst result = await raceCancellation(iterator.next(), token);\n\t\t\treturn result || { done: true, value: undefined };\n\t\t},\n\t\tthrow: iterator.throw?.bind(iterator),\n\t\treturn: iterator.return?.bind(iterator),\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t}\n\t};\n}\n\ntype ProducerConsumerValue<T> = {\n\tok: true;\n\tvalue: T;\n} | {\n\tok: false;\n\terror: Error;\n};\n\nclass ProducerConsumer<T> {\n\tprivate readonly _unsatisfiedConsumers: DeferredPromise<T>[] = [];\n\tprivate readonly _unconsumedValues: ProducerConsumerValue<T>[] = [];\n\tprivate _finalValue: ProducerConsumerValue<T> | undefined;\n\n\tpublic get hasFinalValue(): boolean {\n\t\treturn !!this._finalValue;\n\t}\n\n\tproduce(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tif (this._unsatisfiedConsumers.length > 0) {\n\t\t\tconst deferred = this._unsatisfiedConsumers.shift()!;\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t} else {\n\t\t\tthis._unconsumedValues.push(value);\n\t\t}\n\t}\n\n\tproduceFinal(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tthis._finalValue = value;\n\t\tfor (const deferred of this._unsatisfiedConsumers) {\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t}\n\t\tthis._unsatisfiedConsumers.length = 0;\n\t}\n\n\tprivate _ensureNoFinalValue(): void {\n\t\tif (this._finalValue) {\n\t\t\tthrow new BugIndicatingError('ProducerConsumer: cannot produce after final value has been set');\n\t\t}\n\t}\n\n\tprivate _resolveOrRejectDeferred(deferred: DeferredPromise<T>, value: ProducerConsumerValue<T>): void {\n\t\tif (value.ok) {\n\t\t\tdeferred.complete(value.value);\n\t\t} else {\n\t\t\tdeferred.error(value.error);\n\t\t}\n\t}\n\n\tconsume(): Promise<T> {\n\t\tif (this._unconsumedValues.length > 0 || this._finalValue) {\n\t\t\tconst value = this._unconsumedValues.length > 0 ? this._unconsumedValues.shift()! : this._finalValue!;\n\t\t\tif (value.ok) {\n\t\t\t\treturn Promise.resolve(value.value);\n\t\t\t} else {\n\t\t\t\treturn Promise.reject(value.error);\n\t\t\t}\n\t\t} else {\n\t\t\tconst deferred = new DeferredPromise<T>();\n\t\t\tthis._unsatisfiedConsumers.push(deferred);\n\t\t\treturn deferred.p;\n\t\t}\n\t}\n}\n\n/**\n * Important difference to AsyncIterableObject:\n * If it is iterated two times, the second iterator will not see the values emitted by the first iterator.\n */\nexport class AsyncIterableProducer<T> implements AsyncIterable<T> {\n\tprivate readonly _producerConsumer = new ProducerConsumer<IteratorResult<T>>();\n\n\tconstructor(executor: AsyncIterableExecutor<T>, private readonly _onReturn?: () => void) {\n\t\tqueueMicrotask(async () => {\n\t\t\tconst p = executor({\n\t\t\t\temitOne: value => this._producerConsumer.produce({ ok: true, value: { done: false, value: value } }),\n\t\t\t\temitMany: values => {\n\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\tthis._producerConsumer.produce({ ok: true, value: { done: false, value: value } });\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treject: error => this._finishError(error),\n\t\t\t});\n\n\t\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\t\ttry {\n\t\t\t\t\tawait p;\n\t\t\t\t\tthis._finishOk();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._finishError(error);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableProducer.fromArray<any>([]);\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn new AsyncIterableProducer<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static tee<T>(iterable: AsyncIterable<T>): [AsyncIterableProducer<T>, AsyncIterableProducer<T>] {\n\t\tlet emitter1: AsyncIterableEmitter<T> | undefined;\n\t\tlet emitter2: AsyncIterableEmitter<T> | undefined;\n\n\t\tconst defer = new DeferredPromise<void>();\n\n\t\tconst start = async () => {\n\t\t\tif (!emitter1 || !emitter2) {\n\t\t\t\treturn; // not yet ready\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter1.emitOne(item);\n\t\t\t\t\temitter2.emitOne(item);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\temitter1.reject(err);\n\t\t\t\temitter2.reject(err);\n\t\t\t} finally {\n\t\t\t\tdefer.complete();\n\t\t\t}\n\t\t};\n\n\t\tconst p1 = new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter1 = emitter;\n\t\t\tstart();\n\t\t\treturn defer.p;\n\t\t});\n\t\tconst p2 = new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter2 = emitter;\n\t\t\tstart();\n\t\t\treturn defer.p;\n\t\t});\n\t\treturn [p1, p2];\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn AsyncIterableProducer.map(this, mapFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableProducer<T> {\n\t\treturn <AsyncIterableProducer<T>>AsyncIterableProducer.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableProducer<NonNullable<T>> {\n\t\treturn AsyncIterableProducer.coalesce(this) as AsyncIterableProducer<NonNullable<T>>;\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableProducer<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn AsyncIterableProducer.filter(this, filterFn);\n\t}\n\n\tprivate _finishOk(): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: true, value: { done: true, value: undefined } });\n\t\t}\n\t}\n\n\tprivate _finishError(error: Error): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: false, error: error });\n\t\t}\n\t\t// Warning: this can cause to dropped errors.\n\t}\n\n\tprivate readonly _iterator: AsyncIterator<T, void, void> = {\n\t\tnext: () => this._producerConsumer.consume(),\n\t\treturn: () => {\n\t\t\tthis._onReturn?.();\n\t\t\treturn Promise.resolve({ done: true, value: undefined });\n\t\t},\n\t\tthrow: async (e) => {\n\t\t\tthis._finishError(e);\n\t\t\treturn { done: true, value: undefined };\n\t\t},\n\t};\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, void, void> {\n\t\treturn this._iterator;\n\t}\n}\n\nexport class CancelableAsyncIterableProducer<T> extends AsyncIterableProducer<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\n//#endregion\n\nexport const AsyncReaderEndOfStream = Symbol('AsyncReaderEndOfStream');\n\nexport class AsyncReader<T> {\n\tprivate _buffer: T[] = [];\n\tprivate _atEnd = false;\n\n\tpublic get endOfStream(): boolean { return this._buffer.length === 0 && this._atEnd; }\n\tprivate _extendBufferPromise: Promise<void> | undefined;\n\n\tconstructor(\n\t\tprivate readonly _source: AsyncIterator<T>\n\t) {\n\t}\n\n\tpublic async read(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer.shift()!;\n\t}\n\n\tpublic async readWhile(predicate: (value: T) => boolean, callback: (element: T) => unknown): Promise<void> {\n\t\tdo {\n\t\t\tconst piece = await this.peek();\n\t\t\tif (piece === AsyncReaderEndOfStream) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!predicate(piece)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait this.read(); // consume\n\t\t\tawait callback(piece);\n\t\t} while (true);\n\t}\n\n\tpublic readBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tconst value = this.peekBufferedOrThrow();\n\t\tthis._buffer.shift();\n\t\treturn value;\n\t}\n\n\tpublic async consumeToEnd(): Promise<void> {\n\t\twhile (!this.endOfStream) {\n\t\t\tawait this.read();\n\t\t}\n\t}\n\n\tpublic async peek(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic peekBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tif (this._buffer.length === 0) {\n\t\t\tif (this._atEnd) {\n\t\t\t\treturn AsyncReaderEndOfStream;\n\t\t\t}\n\t\t\tthrow new BugIndicatingError('No buffered elements');\n\t\t}\n\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic async peekTimeout(timeoutMs: number): Promise<T | typeof AsyncReaderEndOfStream | undefined> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait raceTimeout(this._extendBuffer(), timeoutMs);\n\t\t}\n\t\tif (this._atEnd) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tprivate _extendBuffer(): Promise<void> {\n\t\tif (this._atEnd) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tif (!this._extendBufferPromise) {\n\t\t\tthis._extendBufferPromise = (async () => {\n\t\t\t\tconst { value, done } = await this._source.next();\n\t\t\t\tthis._extendBufferPromise = undefined;\n\t\t\t\tif (done) {\n\t\t\t\t\tthis._atEnd = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._buffer.push(value);\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\n\t\treturn this._extendBufferPromise;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { BugIndicatingError, CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, isDisposable, MutableDisposable, toDisposable } from './lifecycle.js';\nimport { extUri as defaultExtUri, IExtUri } from './resources.js';\nimport { URI } from './uri.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\nimport { Lazy } from './lazy.js';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\n/**\n * Returns a promise that can be cancelled using the provided cancellation token.\n *\n * @remarks When cancellation is requested, the promise will be rejected with a {@link CancellationError}.\n * If the promise resolves to a disposable object, it will be automatically disposed when cancellation\n * is requested.\n *\n * @param callback A function that accepts a cancellation token and returns a promise\n * @returns A promise that can be cancelled\n */\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\n\tlet isCancelled = false;\n\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tisCancelled = true;\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\n\t\t\tif (!isCancelled) {\n\t\t\t\tresolve(value);\n\n\t\t\t} else if (isDisposable(value)) {\n\t\t\t\t// promise has been cancelled, result is disposable and will\n\t\t\t\t// be cleaned up\n\t\t\t\tvalue.dispose();\n\t\t\t}\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: unknown) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: unknown) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Wraps a cancellable promise such that it is no cancellable. Can be used to\n * avoid issues with shared promises that would normally be returned as\n * cancellable to consumers.\n */\nexport function notCancellablePromise<T>(promise: CancelablePromise<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tpromise.then(resolve, reject);\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport function raceCancellablePromises<T>(cancellablePromises: (CancelablePromise<T> | Promise<T>)[]): CancelablePromise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst promise = Promise.race(promises) as CancelablePromise<T>;\n\tpromise.cancel = () => {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex && (cancellablePromise as CancelablePromise<T>).cancel) {\n\t\t\t\t(cancellablePromise as CancelablePromise<T>).cancel();\n\t\t\t}\n\t\t});\n\t};\n\tpromise.finally(() => {\n\t\tpromise.cancel();\n\t});\n\treturn promise;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nexport function promiseWithResolvers<T>(): { promise: Promise<T>; resolve: (value: T | PromiseLike<T>) => void; reject: (err?: any) => void } {\n\tlet resolve: (value: T | PromiseLike<T>) => void;\n\tlet reject: (reason?: any) => void;\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\nexport interface ICancellableTask<T> {\n\t(token: CancellationToken): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ICancellableTask<Promise<any>> | null;\n\tprivate cancellationTokenSource: CancellationTokenSource;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\n\t\tthis.cancellationTokenSource = new CancellationTokenSource();\n\t}\n\n\tqueue<T>(promiseFactory: ICancellableTask<Promise<T>>): Promise<T> {\n\t\tif (this.cancellationTokenSource.token.isCancellationRequested) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.cancellationTokenSource.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory(this.cancellationTokenSource.token);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancellationTokenSource.cancel();\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n\n\tpeek(key: TKey): Promise<unknown> | undefined {\n\t\treturn this.promiseMap.get(key) || undefined;\n\t}\n\n\tkeys(): IterableIterator<TKey> {\n\t\treturn this.promiseMap.keys();\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: unknown) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ICancellableTask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: Timeout;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.delete(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: unknown): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result as T);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n\n\tclear(): void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T> {\n\n\tprivate _size = 0;\n\tprivate _isDisposed = false;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t *\n\t * @returns A promise that resolved when all work is done (onDrained) or when\n\t * there is nothing to do\n\t */\n\twhenIdle(): Promise<void> {\n\t\treturn this.size > 0\n\t\t\t? Event.toPromise(this.onDrained)\n\t\t\t: Promise.resolve();\n\t}\n\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis.runningPromises--;\n\t\tif (--this._size === 0) {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis.outstandingPromises.length = 0;\n\t\tthis._size = this.runningPromises;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis.outstandingPromises.length = 0; // stop further processing\n\t\tthis._size = 0;\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueSize(resource: URI, extUri: IExtUri = defaultExtUri): number {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\treturn this.queues.get(key)?.size ?? 0;\n\t}\n\n\tqueueFor(resource: URI, factory: ITask<Promise<void>>, extUri: IExtUri = defaultExtUri): Promise<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue.queue(factory);\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport type Task<T = void> = () => (Promise<T> | T);\n\n/**\n * Wrap a type in an optional promise. This can be useful to avoid the runtime\n * overhead of creating a promise.\n */\nexport type MaybePromise<T> = Promise<T> | T;\n\n/**\n * Processes tasks in the order they were scheduled.\n*/\nexport class TaskQueue {\n\tprivate _runningTask: Task<any> | undefined = undefined;\n\tprivate _pendingTasks: { task: Task<any>; deferred: DeferredPromise<any>; setUndefinedWhenCleared: boolean }[] = [];\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is rejected with a CancellationError.\n\t*/\n\tpublic schedule<T>(task: Task<T>): Promise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: false });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is resolved with undefined.\n\t*/\n\tpublic scheduleSkipIfCleared<T>(task: Task<T>): Promise<T | undefined> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: true });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\tprivate _runIfNotRunning(): void {\n\t\tif (this._runningTask === undefined) {\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\tprivate async _processQueue(): Promise<void> {\n\t\tif (this._pendingTasks.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst next = this._pendingTasks.shift();\n\t\tif (!next) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._runningTask) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tthis._runningTask = next.task;\n\n\t\ttry {\n\t\t\tconst result = await next.task();\n\t\t\tnext.deferred.complete(result);\n\t\t} catch (e) {\n\t\t\tnext.deferred.error(e);\n\t\t} finally {\n\t\t\tthis._runningTask = undefined;\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\t/**\n\t * Clears all pending tasks. Does not cancel the currently running task.\n\t*/\n\tpublic clearPending(): void {\n\t\tconst tasks = this._pendingTasks;\n\t\tthis._pendingTasks = [];\n\t\tfor (const task of tasks) {\n\t\t\tif (task.setUndefinedWhenCleared) {\n\t\t\t\ttask.deferred.complete(undefined);\n\t\t\t} else {\n\t\t\t\ttask.deferred.error(new CancellationError());\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: Timeout | undefined;\n\tprivate _isDisposed = false;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = undefined;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis._isDisposed = true;\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== undefined) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = undefined;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tif (this._token !== undefined) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\tprivate isDisposed = false;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: Timeout | undefined;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = undefined;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== undefined;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = undefined;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: Timeout | undefined;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = undefined;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== undefined;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = undefined;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n\n\t/**\n\t * When enabled will guarantee that two distinct calls to `work()` are not executed\n\t * without throttle delay between them.\n\t * Otherwise if the worker isn't currently throttling it will execute work immediately.\n\t */\n\twaitThrottleDelayBetweenWorkUnits?: boolean;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\tprivate lastExecutionTime = 0;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\tconst timeSinceLastExecution = Date.now() - this.lastExecutionTime;\n\n\t\tif (!this.throttler.value && (!this.options.waitThrottleDelayBetweenWorkUnits || timeSinceLastExecution >= this.options.throttleDelay)) {\n\t\t\t// Work directly if we are not throttling and we are not\n\t\t\t// enforced to throttle between `work()` calls.\n\t\t\tthis.doWork();\n\t\t} else if (!this.throttler.value && this.options.waitThrottleDelayBetweenWorkUnits) {\n\t\t\t// Otherwise, schedule the throttler to work.\n\t\t\tthis.scheduleThrottler(Math.max(this.options.throttleDelay - timeSinceLastExecution, 0));\n\t\t} else {\n\t\t\t// Otherwise, our work will be picked up by the running throttler\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\t\tthis.lastExecutionTime = Date.now();\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.scheduleThrottler();\n\t\t}\n\t}\n\n\tprivate scheduleThrottler(delay = this.options.throttleDelay): void {\n\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\tthis.throttler.clear();\n\n\t\t\tthis.doWork();\n\t\t}, delay);\n\t\tthis.throttler.value.schedule();\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.pendingWork.length = 0;\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tconst safeGlobal: any = globalThis;\n\tif (typeof safeGlobal.requestIdleCallback !== 'function' || typeof safeGlobal.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner, timeout?) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: typeof safeGlobal, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner, timeout) => _runWhenIdle(globalThis, runner, timeout);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tconst { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers<void>();\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve,\n\t\t\t\tpromiseReject\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tpublic static fromPromise<T>(promise: Promise<T>): DeferredPromise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tdeferred.settleWith(promise);\n\t\treturn deferred;\n\t}\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: unknown } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic settleWith(promise: Promise<T>): Promise<void> {\n\t\treturn promise.then(\n\t\t\tvalue => this.complete(value),\n\t\t\terror => this.error(error)\n\t\t);\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class StatefulPromise<T> {\n\tprivate _value: T | undefined = undefined;\n\tget value(): T | undefined { return this._value; }\n\n\tprivate _error: unknown = undefined;\n\tget error(): unknown { return this._error; }\n\n\tprivate _isResolved = false;\n\tget isResolved() { return this._isResolved; }\n\n\tpublic readonly promise: Promise<T>;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(\n\t\t\tvalue => {\n\t\t\t\tthis._value = value;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tthis._error = error;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\tif (!this._isResolved) {\n\t\t\tthrow new BugIndicatingError('Promise is not resolved yet');\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\nexport class LazyStatefulPromise<T> {\n\tprivate readonly _promise = new Lazy(() => new StatefulPromise(this._compute()));\n\n\tconstructor(\n\t\tprivate readonly _compute: () => Promise<T>,\n\t) { }\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\treturn this._promise.value.requireValue();\n\t}\n\n\t/**\n\t * Returns the promise (and triggers a computation of the promise if not yet done so).\n\t */\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._promise.value.promise;\n\t}\n\n\t/**\n\t * Reads the current value without triggering a computation of the promise.\n\t */\n\tpublic get currentValue(): T | undefined {\n\t\treturn this._promise.rawValue?.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): unknown | Promise<unknown>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onReturn?: () => void | Promise<void>;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>, onReturn?: () => void | Promise<void>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onReturn = onReturn;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t},\n\t\t\treturn: async () => {\n\t\t\t\tthis._onReturn?.();\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableObject<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\n\nexport function createCancelableAsyncIterableProducer<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableProducer<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableProducer<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\nexport class AsyncIterableSource<T> {\n\n\tprivate readonly _deferred = new DeferredPromise<void>();\n\tprivate readonly _asyncIterable: AsyncIterableObject<T>;\n\n\tprivate _errorFn: (error: Error) => void;\n\tprivate _emitOneFn: (item: T) => void;\n\tprivate _emitManyFn: (item: T[]) => void;\n\n\t/**\n\t *\n\t * @param onReturn A function that will be called when consuming the async iterable\n\t * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.\n\t * This is NOT called when resolving this source by its owner.\n\t */\n\tconstructor(onReturn?: () => Promise<void> | void) {\n\t\tthis._asyncIterable = new AsyncIterableObject(emitter => {\n\n\t\t\tif (earlyError) {\n\t\t\t\temitter.reject(earlyError);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (earlyItems) {\n\t\t\t\temitter.emitMany(earlyItems);\n\t\t\t}\n\t\t\tthis._errorFn = (error: Error) => emitter.reject(error);\n\t\t\tthis._emitOneFn = (item: T) => emitter.emitOne(item);\n\t\t\tthis._emitManyFn = (items: T[]) => emitter.emitMany(items);\n\t\t\treturn this._deferred.p;\n\t\t}, onReturn);\n\n\t\tlet earlyError: Error | undefined;\n\t\tlet earlyItems: T[] | undefined;\n\n\n\t\tthis._errorFn = (error: Error) => {\n\t\t\tif (!earlyError) {\n\t\t\t\tearlyError = error;\n\t\t\t}\n\t\t};\n\t\tthis._emitOneFn = (item: T) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = [];\n\t\t\t}\n\t\t\tearlyItems.push(item);\n\t\t};\n\t\tthis._emitManyFn = (items: T[]) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = items.slice();\n\t\t\t} else {\n\t\t\t\titems.forEach(item => earlyItems!.push(item));\n\t\t\t}\n\t\t};\n\t}\n\n\tget asyncIterable(): AsyncIterableObject<T> {\n\t\treturn this._asyncIterable;\n\t}\n\n\tresolve(): void {\n\t\tthis._deferred.complete();\n\t}\n\n\treject(error: Error): void {\n\t\tthis._errorFn(error);\n\t\tthis._deferred.complete();\n\t}\n\n\temitOne(item: T): void {\n\t\tthis._emitOneFn(item);\n\t}\n\n\temitMany(items: T[]) {\n\t\tthis._emitManyFn(items);\n\t}\n}\n\nexport function cancellableIterable<T>(iterableOrIterator: AsyncIterator<T> | AsyncIterable<T>, token: CancellationToken): AsyncIterableIterator<T> {\n\tconst iterator = Symbol.asyncIterator in iterableOrIterator ? iterableOrIterator[Symbol.asyncIterator]() : iterableOrIterator;\n\n\treturn {\n\t\tasync next(): Promise<IteratorResult<T>> {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t\tconst result = await raceCancellation(iterator.next(), token);\n\t\t\treturn result || { done: true, value: undefined };\n\t\t},\n\t\tthrow: iterator.throw?.bind(iterator),\n\t\treturn: iterator.return?.bind(iterator),\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t}\n\t};\n}\n\ntype ProducerConsumerValue<T> = {\n\tok: true;\n\tvalue: T;\n} | {\n\tok: false;\n\terror: Error;\n};\n\nclass ProducerConsumer<T> {\n\tprivate readonly _unsatisfiedConsumers: DeferredPromise<T>[] = [];\n\tprivate readonly _unconsumedValues: ProducerConsumerValue<T>[] = [];\n\tprivate _finalValue: ProducerConsumerValue<T> | undefined;\n\n\tpublic get hasFinalValue(): boolean {\n\t\treturn !!this._finalValue;\n\t}\n\n\tproduce(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tif (this._unsatisfiedConsumers.length > 0) {\n\t\t\tconst deferred = this._unsatisfiedConsumers.shift()!;\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t} else {\n\t\t\tthis._unconsumedValues.push(value);\n\t\t}\n\t}\n\n\tproduceFinal(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tthis._finalValue = value;\n\t\tfor (const deferred of this._unsatisfiedConsumers) {\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t}\n\t\tthis._unsatisfiedConsumers.length = 0;\n\t}\n\n\tprivate _ensureNoFinalValue(): void {\n\t\tif (this._finalValue) {\n\t\t\tthrow new BugIndicatingError('ProducerConsumer: cannot produce after final value has been set');\n\t\t}\n\t}\n\n\tprivate _resolveOrRejectDeferred(deferred: DeferredPromise<T>, value: ProducerConsumerValue<T>): void {\n\t\tif (value.ok) {\n\t\t\tdeferred.complete(value.value);\n\t\t} else {\n\t\t\tdeferred.error(value.error);\n\t\t}\n\t}\n\n\tconsume(): Promise<T> {\n\t\tif (this._unconsumedValues.length > 0 || this._finalValue) {\n\t\t\tconst value = this._unconsumedValues.length > 0 ? this._unconsumedValues.shift()! : this._finalValue!;\n\t\t\tif (value.ok) {\n\t\t\t\treturn Promise.resolve(value.value);\n\t\t\t} else {\n\t\t\t\treturn Promise.reject(value.error);\n\t\t\t}\n\t\t} else {\n\t\t\tconst deferred = new DeferredPromise<T>();\n\t\t\tthis._unsatisfiedConsumers.push(deferred);\n\t\t\treturn deferred.p;\n\t\t}\n\t}\n}\n\n/**\n * Important difference to AsyncIterableObject:\n * If it is iterated two times, the second iterator will not see the values emitted by the first iterator.\n */\nexport class AsyncIterableProducer<T> implements AsyncIterable<T> {\n\tprivate readonly _producerConsumer = new ProducerConsumer<IteratorResult<T>>();\n\n\tconstructor(executor: AsyncIterableExecutor<T>, private readonly _onReturn?: () => void) {\n\t\tqueueMicrotask(async () => {\n\t\t\tconst p = executor({\n\t\t\t\temitOne: value => this._producerConsumer.produce({ ok: true, value: { done: false, value: value } }),\n\t\t\t\temitMany: values => {\n\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\tthis._producerConsumer.produce({ ok: true, value: { done: false, value: value } });\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treject: error => this._finishError(error),\n\t\t\t});\n\n\t\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\t\ttry {\n\t\t\t\t\tawait p;\n\t\t\t\t\tthis._finishOk();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._finishError(error);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableProducer.fromArray<any>([]);\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn new AsyncIterableProducer<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static tee<T>(iterable: AsyncIterable<T>): [AsyncIterableProducer<T>, AsyncIterableProducer<T>] {\n\t\tlet emitter1: AsyncIterableEmitter<T> | undefined;\n\t\tlet emitter2: AsyncIterableEmitter<T> | undefined;\n\n\t\tconst defer = new DeferredPromise<void>();\n\n\t\tconst start = async () => {\n\t\t\tif (!emitter1 || !emitter2) {\n\t\t\t\treturn; // not yet ready\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter1.emitOne(item);\n\t\t\t\t\temitter2.emitOne(item);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\temitter1.reject(err);\n\t\t\t\temitter2.reject(err);\n\t\t\t} finally {\n\t\t\t\tdefer.complete();\n\t\t\t}\n\t\t};\n\n\t\tconst p1 = new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter1 = emitter;\n\t\t\tstart();\n\t\t\treturn defer.p;\n\t\t});\n\t\tconst p2 = new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter2 = emitter;\n\t\t\tstart();\n\t\t\treturn defer.p;\n\t\t});\n\t\treturn [p1, p2];\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn AsyncIterableProducer.map(this, mapFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableProducer<T> {\n\t\treturn <AsyncIterableProducer<T>>AsyncIterableProducer.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableProducer<NonNullable<T>> {\n\t\treturn AsyncIterableProducer.coalesce(this) as AsyncIterableProducer<NonNullable<T>>;\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableProducer<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn AsyncIterableProducer.filter(this, filterFn);\n\t}\n\n\tprivate _finishOk(): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: true, value: { done: true, value: undefined } });\n\t\t}\n\t}\n\n\tprivate _finishError(error: Error): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: false, error: error });\n\t\t}\n\t\t// Warning: this can cause to dropped errors.\n\t}\n\n\tprivate readonly _iterator: AsyncIterator<T, void, void> = {\n\t\tnext: () => this._producerConsumer.consume(),\n\t\treturn: () => {\n\t\t\tthis._onReturn?.();\n\t\t\treturn Promise.resolve({ done: true, value: undefined });\n\t\t},\n\t\tthrow: async (e) => {\n\t\t\tthis._finishError(e);\n\t\t\treturn { done: true, value: undefined };\n\t\t},\n\t};\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, void, void> {\n\t\treturn this._iterator;\n\t}\n}\n\nexport class CancelableAsyncIterableProducer<T> extends AsyncIterableProducer<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\n//#endregion\n\nexport const AsyncReaderEndOfStream = Symbol('AsyncReaderEndOfStream');\n\nexport class AsyncReader<T> {\n\tprivate _buffer: T[] = [];\n\tprivate _atEnd = false;\n\n\tpublic get endOfStream(): boolean { return this._buffer.length === 0 && this._atEnd; }\n\tprivate _extendBufferPromise: Promise<void> | undefined;\n\n\tconstructor(\n\t\tprivate readonly _source: AsyncIterator<T>\n\t) {\n\t}\n\n\tpublic async read(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer.shift()!;\n\t}\n\n\tpublic async readWhile(predicate: (value: T) => boolean, callback: (element: T) => unknown): Promise<void> {\n\t\tdo {\n\t\t\tconst piece = await this.peek();\n\t\t\tif (piece === AsyncReaderEndOfStream) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!predicate(piece)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait this.read(); // consume\n\t\t\tawait callback(piece);\n\t\t} while (true);\n\t}\n\n\tpublic readBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tconst value = this.peekBufferedOrThrow();\n\t\tthis._buffer.shift();\n\t\treturn value;\n\t}\n\n\tpublic async consumeToEnd(): Promise<void> {\n\t\twhile (!this.endOfStream) {\n\t\t\tawait this.read();\n\t\t}\n\t}\n\n\tpublic async peek(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic peekBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tif (this._buffer.length === 0) {\n\t\t\tif (this._atEnd) {\n\t\t\t\treturn AsyncReaderEndOfStream;\n\t\t\t}\n\t\t\tthrow new BugIndicatingError('No buffered elements');\n\t\t}\n\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic async peekTimeout(timeoutMs: number): Promise<T | typeof AsyncReaderEndOfStream | undefined> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait raceTimeout(this._extendBuffer(), timeoutMs);\n\t\t}\n\t\tif (this._atEnd) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tprivate _extendBuffer(): Promise<void> {\n\t\tif (this._atEnd) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tif (!this._extendBufferPromise) {\n\t\t\tthis._extendBufferPromise = (async () => {\n\t\t\t\tconst { value, done } = await this._source.next();\n\t\t\t\tthis._extendBufferPromise = undefined;\n\t\t\t\tif (done) {\n\t\t\t\t\tthis._atEnd = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._buffer.push(value);\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\n\t\treturn this._extendBufferPromise;\n\t}\n}\n"]}