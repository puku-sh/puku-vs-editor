{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/sseParser.ts","vs/base/common/sseParser.ts"],"names":[],"mappings":"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","file":"sseParser.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Parser for Server-Sent Events (SSE) streams according to the HTML specification.\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n */\n\n/**\n * Represents an event dispatched from an SSE stream.\n */\nexport interface ISSEEvent {\n\t/**\n\t * The event type. If not specified, the type is \"message\".\n\t */\n\ttype: string;\n\n\t/**\n\t * The event data.\n\t */\n\tdata: string;\n\n\t/**\n\t * The last event ID, used for reconnection.\n\t */\n\tid?: string;\n\n\t/**\n\t * Reconnection time in milliseconds.\n\t */\n\tretry?: number;\n}\n\n/**\n * Callback function type for event dispatch.\n */\nexport type SSEEventHandler = (event: ISSEEvent) => void;\n\nconst enum Chr {\n\tCR = 13, // '\\r'\n\tLF = 10, // '\\n'\n\tCOLON = 58, // ':'\n\tSPACE = 32, // ' '\n}\n\n/**\n * Parser for Server-Sent Events (SSE) streams.\n */\nexport class SSEParser {\n\tprivate dataBuffer = '';\n\tprivate eventTypeBuffer = '';\n\tprivate currentEventId?: string;\n\tprivate lastEventIdBuffer?: string;\n\tprivate reconnectionTime?: number;\n\tprivate buffer: Uint8Array[] = [];\n\tprivate endedOnCR = false;\n\tprivate readonly onEventHandler: SSEEventHandler;\n\tprivate readonly decoder: TextDecoder;\n\t/**\n\t * Creates a new SSE parser.\n\t * @param onEvent The callback to invoke when an event is dispatched.\n\t */\n\tconstructor(onEvent: SSEEventHandler) {\n\t\tthis.onEventHandler = onEvent;\n\t\tthis.decoder = new TextDecoder('utf-8');\n\t}\n\n\t/**\n\t * Gets the last event ID received by this parser.\n\t */\n\tpublic getLastEventId(): string | undefined {\n\t\treturn this.lastEventIdBuffer;\n\t}\n\t/**\n\t * Gets the reconnection time in milliseconds, if one was specified by the server.\n\t */\n\tpublic getReconnectionTime(): number | undefined {\n\t\treturn this.reconnectionTime;\n\t}\n\n\t/**\n\t * Feeds a chunk of the SSE stream to the parser.\n\t * @param chunk The chunk to parse as a Uint8Array of UTF-8 encoded data.\n\t */\n\tpublic feed(chunk: Uint8Array): void {\n\t\tif (chunk.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet offset = 0;\n\n\t\t// If the data stream was bifurcated between a CR and LF, avoid processing the CR as an extra newline\n\t\tif (this.endedOnCR && chunk[0] === Chr.LF) {\n\t\t\toffset++;\n\t\t}\n\t\tthis.endedOnCR = false;\n\n\t\t// Process complete lines from the buffer\n\t\twhile (offset < chunk.length) {\n\t\t\tconst indexCR = chunk.indexOf(Chr.CR, offset);\n\t\t\tconst indexLF = chunk.indexOf(Chr.LF, offset);\n\t\t\tconst index = indexCR === -1 ? indexLF : (indexLF === -1 ? indexCR : Math.min(indexCR, indexLF));\n\t\t\tif (index === -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet str = '';\n\t\t\tfor (const buf of this.buffer) {\n\t\t\t\tstr += this.decoder.decode(buf, { stream: true });\n\t\t\t}\n\t\t\tstr += this.decoder.decode(chunk.subarray(offset, index));\n\t\t\tthis.processLine(str);\n\n\t\t\tthis.buffer.length = 0;\n\t\t\toffset = index + (chunk[index] === Chr.CR && chunk[index + 1] === Chr.LF ? 2 : 1);\n\t\t}\n\n\n\t\tif (offset < chunk.length) {\n\t\t\tthis.buffer.push(chunk.subarray(offset));\n\t\t} else {\n\t\t\tthis.endedOnCR = chunk[chunk.length - 1] === Chr.CR;\n\t\t}\n\t}\n\t/**\n\t * Processes a single line from the SSE stream.\n\t */\n\tprivate processLine(line: string): void {\n\t\tif (!line.length) {\n\t\t\tthis.dispatchEvent();\n\t\t\treturn;\n\t\t}\n\n\t\tif (line.startsWith(':')) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse the field name and value\n\t\tlet field: string;\n\t\tlet value: string;\n\n\t\tconst colonIndex = line.indexOf(':');\n\t\tif (colonIndex === -1) {\n\t\t\t// Line with no colon - the entire line is the field name, value is empty\n\t\t\tfield = line;\n\t\t\tvalue = '';\n\t\t} else {\n\t\t\t// Line with a colon - split into field name and value\n\t\t\tfield = line.substring(0, colonIndex);\n\t\t\tvalue = line.substring(colonIndex + 1);\n\n\t\t\t// If value starts with a space, remove it\n\t\t\tif (value.startsWith(' ')) {\n\t\t\t\tvalue = value.substring(1);\n\t\t\t}\n\t\t}\n\n\t\tthis.processField(field, value);\n\t}\n\t/**\n\t * Processes a field with the given name and value.\n\t */\n\tprivate processField(field: string, value: string): void {\n\t\tswitch (field) {\n\t\t\tcase 'event':\n\t\t\t\tthis.eventTypeBuffer = value;\n\t\t\t\tbreak;\n\n\t\t\tcase 'data':\n\t\t\t\t// Append the value to the data buffer, followed by a newline\n\t\t\t\tthis.dataBuffer += value;\n\t\t\t\tthis.dataBuffer += '\\n';\n\t\t\t\tbreak;\n\n\t\t\tcase 'id':\n\t\t\t\t// If the field value doesn't contain NULL, set the last event ID buffer\n\t\t\t\tif (!value.includes('\\0')) {\n\t\t\t\t\tthis.currentEventId = this.lastEventIdBuffer = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis.currentEventId = undefined;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'retry':\n\t\t\t\t// If the field value consists only of ASCII digits, set the reconnection time\n\t\t\t\tif (/^\\d+$/.test(value)) {\n\t\t\t\t\tthis.reconnectionTime = parseInt(value, 10);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Ignore any other fields\n\t\t}\n\t}\n\t/**\n\t * Dispatches the event based on the current buffer states.\n\t */\n\tprivate dispatchEvent(): void {\n\t\t// If the data buffer is empty, reset the buffers and return\n\t\tif (this.dataBuffer === '') {\n\t\t\tthis.dataBuffer = '';\n\t\t\tthis.eventTypeBuffer = '';\n\t\t\treturn;\n\t\t}\n\n\t\t// If the data buffer's last character is a newline, remove it\n\t\tif (this.dataBuffer.endsWith('\\n')) {\n\t\t\tthis.dataBuffer = this.dataBuffer.substring(0, this.dataBuffer.length - 1);\n\t\t}\n\n\t\t// Create and dispatch the event\n\t\tconst event: ISSEEvent = {\n\t\t\ttype: this.eventTypeBuffer || 'message',\n\t\t\tdata: this.dataBuffer,\n\t\t};\n\n\t\t// Add optional fields if they exist\n\t\tif (this.currentEventId !== undefined) {\n\t\t\tevent.id = this.currentEventId;\n\t\t}\n\n\t\tif (this.reconnectionTime !== undefined) {\n\t\t\tevent.retry = this.reconnectionTime;\n\t\t}\n\n\t\t// Dispatch the event\n\t\tthis.onEventHandler(event);\n\n\t\t// Reset the data and event type buffers\n\t\tthis.reset();\n\t}\n\n\t/**\n\t * Resets the parser state.\n\t */\n\tpublic reset(): void {\n\t\tthis.dataBuffer = '';\n\t\tthis.eventTypeBuffer = '';\n\t\tthis.currentEventId = undefined;\n\t\t// Note: lastEventIdBuffer is not reset as it's used for reconnection\n\t}\n}\n\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Parser for Server-Sent Events (SSE) streams according to the HTML specification.\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n */\n\n/**\n * Represents an event dispatched from an SSE stream.\n */\nexport interface ISSEEvent {\n\t/**\n\t * The event type. If not specified, the type is \"message\".\n\t */\n\ttype: string;\n\n\t/**\n\t * The event data.\n\t */\n\tdata: string;\n\n\t/**\n\t * The last event ID, used for reconnection.\n\t */\n\tid?: string;\n\n\t/**\n\t * Reconnection time in milliseconds.\n\t */\n\tretry?: number;\n}\n\n/**\n * Callback function type for event dispatch.\n */\nexport type SSEEventHandler = (event: ISSEEvent) => void;\n\nconst enum Chr {\n\tCR = 13, // '\\r'\n\tLF = 10, // '\\n'\n\tCOLON = 58, // ':'\n\tSPACE = 32, // ' '\n}\n\n/**\n * Parser for Server-Sent Events (SSE) streams.\n */\nexport class SSEParser {\n\tprivate dataBuffer = '';\n\tprivate eventTypeBuffer = '';\n\tprivate currentEventId?: string;\n\tprivate lastEventIdBuffer?: string;\n\tprivate reconnectionTime?: number;\n\tprivate buffer: Uint8Array[] = [];\n\tprivate endedOnCR = false;\n\tprivate readonly onEventHandler: SSEEventHandler;\n\tprivate readonly decoder: TextDecoder;\n\t/**\n\t * Creates a new SSE parser.\n\t * @param onEvent The callback to invoke when an event is dispatched.\n\t */\n\tconstructor(onEvent: SSEEventHandler) {\n\t\tthis.onEventHandler = onEvent;\n\t\tthis.decoder = new TextDecoder('utf-8');\n\t}\n\n\t/**\n\t * Gets the last event ID received by this parser.\n\t */\n\tpublic getLastEventId(): string | undefined {\n\t\treturn this.lastEventIdBuffer;\n\t}\n\t/**\n\t * Gets the reconnection time in milliseconds, if one was specified by the server.\n\t */\n\tpublic getReconnectionTime(): number | undefined {\n\t\treturn this.reconnectionTime;\n\t}\n\n\t/**\n\t * Feeds a chunk of the SSE stream to the parser.\n\t * @param chunk The chunk to parse as a Uint8Array of UTF-8 encoded data.\n\t */\n\tpublic feed(chunk: Uint8Array): void {\n\t\tif (chunk.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet offset = 0;\n\n\t\t// If the data stream was bifurcated between a CR and LF, avoid processing the CR as an extra newline\n\t\tif (this.endedOnCR && chunk[0] === Chr.LF) {\n\t\t\toffset++;\n\t\t}\n\t\tthis.endedOnCR = false;\n\n\t\t// Process complete lines from the buffer\n\t\twhile (offset < chunk.length) {\n\t\t\tconst indexCR = chunk.indexOf(Chr.CR, offset);\n\t\t\tconst indexLF = chunk.indexOf(Chr.LF, offset);\n\t\t\tconst index = indexCR === -1 ? indexLF : (indexLF === -1 ? indexCR : Math.min(indexCR, indexLF));\n\t\t\tif (index === -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet str = '';\n\t\t\tfor (const buf of this.buffer) {\n\t\t\t\tstr += this.decoder.decode(buf, { stream: true });\n\t\t\t}\n\t\t\tstr += this.decoder.decode(chunk.subarray(offset, index));\n\t\t\tthis.processLine(str);\n\n\t\t\tthis.buffer.length = 0;\n\t\t\toffset = index + (chunk[index] === Chr.CR && chunk[index + 1] === Chr.LF ? 2 : 1);\n\t\t}\n\n\n\t\tif (offset < chunk.length) {\n\t\t\tthis.buffer.push(chunk.subarray(offset));\n\t\t} else {\n\t\t\tthis.endedOnCR = chunk[chunk.length - 1] === Chr.CR;\n\t\t}\n\t}\n\t/**\n\t * Processes a single line from the SSE stream.\n\t */\n\tprivate processLine(line: string): void {\n\t\tif (!line.length) {\n\t\t\tthis.dispatchEvent();\n\t\t\treturn;\n\t\t}\n\n\t\tif (line.startsWith(':')) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse the field name and value\n\t\tlet field: string;\n\t\tlet value: string;\n\n\t\tconst colonIndex = line.indexOf(':');\n\t\tif (colonIndex === -1) {\n\t\t\t// Line with no colon - the entire line is the field name, value is empty\n\t\t\tfield = line;\n\t\t\tvalue = '';\n\t\t} else {\n\t\t\t// Line with a colon - split into field name and value\n\t\t\tfield = line.substring(0, colonIndex);\n\t\t\tvalue = line.substring(colonIndex + 1);\n\n\t\t\t// If value starts with a space, remove it\n\t\t\tif (value.startsWith(' ')) {\n\t\t\t\tvalue = value.substring(1);\n\t\t\t}\n\t\t}\n\n\t\tthis.processField(field, value);\n\t}\n\t/**\n\t * Processes a field with the given name and value.\n\t */\n\tprivate processField(field: string, value: string): void {\n\t\tswitch (field) {\n\t\t\tcase 'event':\n\t\t\t\tthis.eventTypeBuffer = value;\n\t\t\t\tbreak;\n\n\t\t\tcase 'data':\n\t\t\t\t// Append the value to the data buffer, followed by a newline\n\t\t\t\tthis.dataBuffer += value;\n\t\t\t\tthis.dataBuffer += '\\n';\n\t\t\t\tbreak;\n\n\t\t\tcase 'id':\n\t\t\t\t// If the field value doesn't contain NULL, set the last event ID buffer\n\t\t\t\tif (!value.includes('\\0')) {\n\t\t\t\t\tthis.currentEventId = this.lastEventIdBuffer = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis.currentEventId = undefined;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'retry':\n\t\t\t\t// If the field value consists only of ASCII digits, set the reconnection time\n\t\t\t\tif (/^\\d+$/.test(value)) {\n\t\t\t\t\tthis.reconnectionTime = parseInt(value, 10);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Ignore any other fields\n\t\t}\n\t}\n\t/**\n\t * Dispatches the event based on the current buffer states.\n\t */\n\tprivate dispatchEvent(): void {\n\t\t// If the data buffer is empty, reset the buffers and return\n\t\tif (this.dataBuffer === '') {\n\t\t\tthis.dataBuffer = '';\n\t\t\tthis.eventTypeBuffer = '';\n\t\t\treturn;\n\t\t}\n\n\t\t// If the data buffer's last character is a newline, remove it\n\t\tif (this.dataBuffer.endsWith('\\n')) {\n\t\t\tthis.dataBuffer = this.dataBuffer.substring(0, this.dataBuffer.length - 1);\n\t\t}\n\n\t\t// Create and dispatch the event\n\t\tconst event: ISSEEvent = {\n\t\t\ttype: this.eventTypeBuffer || 'message',\n\t\t\tdata: this.dataBuffer,\n\t\t};\n\n\t\t// Add optional fields if they exist\n\t\tif (this.currentEventId !== undefined) {\n\t\t\tevent.id = this.currentEventId;\n\t\t}\n\n\t\tif (this.reconnectionTime !== undefined) {\n\t\t\tevent.retry = this.reconnectionTime;\n\t\t}\n\n\t\t// Dispatch the event\n\t\tthis.onEventHandler(event);\n\n\t\t// Reset the data and event type buffers\n\t\tthis.reset();\n\t}\n\n\t/**\n\t * Resets the parser state.\n\t */\n\tpublic reset(): void {\n\t\tthis.dataBuffer = '';\n\t\tthis.eventTypeBuffer = '';\n\t\tthis.currentEventId = undefined;\n\t\t// Note: lastEventIdBuffer is not reset as it's used for reconnection\n\t}\n}\n\n\n"]}