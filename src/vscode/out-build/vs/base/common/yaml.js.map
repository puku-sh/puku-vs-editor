{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/yaml.ts","vs/base/common/yaml.ts"],"names":[],"mappings":"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","file":"yaml.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Parses a simplified YAML-like input from a single string.\n * Supports objects, arrays, primitive types (string, number, boolean, null).\n * Tracks positions for error reporting and node locations.\n *\n * Limitations:\n * - No multi-line strings or block literals\n * - No anchors or references\n * - No complex types (dates, binary)\n * - No special handling for escape sequences in strings\n * - Indentation must be consistent (spaces only, no tabs)\n *\n * Notes:\n * - New line separators can be either \"\\n\" or \"\\r\\n\". The input string is split into lines internally.\n *\n * @param input A string containing the YAML-like input\n * @param errors Array to collect parsing errors\n * @param options Parsing options\n * @returns The parsed representation (ObjectNode, ArrayNode, or primitive node)\n */\nexport function parse(input: string, errors: YamlParseError[] = [], options: ParseOptions = {}): YamlNode | undefined {\n\t// Normalize both LF and CRLF by splitting on either; CR characters are not retained as part of line text.\n\t// This keeps the existing line/character based lexer logic intact.\n\tconst lines = input.length === 0 ? [] : input.split(/\\r\\n|\\n/);\n\tconst parser = new YamlParser(lines, errors, options);\n\treturn parser.parse();\n}\n\nexport interface YamlParseError {\n\treadonly message: string;\n\treadonly start: Position;\n\treadonly end: Position;\n\treadonly code: string;\n}\n\nexport interface ParseOptions {\n\treadonly allowDuplicateKeys?: boolean;\n}\n\nexport interface Position {\n\treadonly line: number;\n\treadonly character: number;\n}\n\nexport interface YamlStringNode {\n\treadonly type: 'string';\n\treadonly value: string;\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport interface YamlNumberNode {\n\treadonly type: 'number';\n\treadonly value: number;\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport interface YamlBooleanNode {\n\treadonly type: 'boolean';\n\treadonly value: boolean;\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport interface YamlNullNode {\n\treadonly type: 'null';\n\treadonly value: null;\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport interface YamlObjectNode {\n\treadonly type: 'object';\n\treadonly properties: { key: YamlStringNode; value: YamlNode }[];\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport interface YamlArrayNode {\n\treadonly type: 'array';\n\treadonly items: YamlNode[];\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport type YamlNode = YamlStringNode | YamlNumberNode | YamlBooleanNode | YamlNullNode | YamlObjectNode | YamlArrayNode;\n\n// Helper functions for position and node creation\nfunction createPosition(line: number, character: number): Position {\n\treturn { line, character };\n}\n\n// Specialized node creation functions using a more concise approach\nfunction createStringNode(value: string, start: Position, end: Position): YamlStringNode {\n\treturn { type: 'string', value, start, end };\n}\n\nfunction createNumberNode(value: number, start: Position, end: Position): YamlNumberNode {\n\treturn { type: 'number', value, start, end };\n}\n\nfunction createBooleanNode(value: boolean, start: Position, end: Position): YamlBooleanNode {\n\treturn { type: 'boolean', value, start, end };\n}\n\nfunction createNullNode(start: Position, end: Position): YamlNullNode {\n\treturn { type: 'null', value: null, start, end };\n}\n\nfunction createObjectNode(properties: { key: YamlStringNode; value: YamlNode }[], start: Position, end: Position): YamlObjectNode {\n\treturn { type: 'object', start, end, properties };\n}\n\nfunction createArrayNode(items: YamlNode[], start: Position, end: Position): YamlArrayNode {\n\treturn { type: 'array', start, end, items };\n}\n\n// Utility functions for parsing\nfunction isWhitespace(char: string): boolean {\n\treturn char === ' ' || char === '\\t';\n}\n\n// Simplified number validation using regex\nfunction isValidNumber(value: string): boolean {\n\treturn /^-?\\d*\\.?\\d+$/.test(value);\n}\n\n// Lexer/Tokenizer for YAML content\nclass YamlLexer {\n\tprivate lines: string[];\n\tprivate currentLine: number = 0;\n\tprivate currentChar: number = 0;\n\n\tconstructor(lines: string[]) {\n\t\tthis.lines = lines;\n\t}\n\n\tgetCurrentPosition(): Position {\n\t\treturn createPosition(this.currentLine, this.currentChar);\n\t}\n\n\tgetCurrentLineNumber(): number {\n\t\treturn this.currentLine;\n\t}\n\n\tgetCurrentCharNumber(): number {\n\t\treturn this.currentChar;\n\t}\n\n\tgetCurrentLineText(): string {\n\t\treturn this.currentLine < this.lines.length ? this.lines[this.currentLine] : '';\n\t}\n\n\tsavePosition(): { line: number; char: number } {\n\t\treturn { line: this.currentLine, char: this.currentChar };\n\t}\n\n\trestorePosition(pos: { line: number; char: number }): void {\n\t\tthis.currentLine = pos.line;\n\t\tthis.currentChar = pos.char;\n\t}\n\n\tisAtEnd(): boolean {\n\t\treturn this.currentLine >= this.lines.length;\n\t}\n\n\tgetCurrentChar(): string {\n\t\tif (this.isAtEnd() || this.currentChar >= this.lines[this.currentLine].length) {\n\t\t\treturn '';\n\t\t}\n\t\treturn this.lines[this.currentLine][this.currentChar];\n\t}\n\n\tpeek(offset: number = 1): string {\n\t\tconst newChar = this.currentChar + offset;\n\t\tif (this.currentLine >= this.lines.length || newChar >= this.lines[this.currentLine].length) {\n\t\t\treturn '';\n\t\t}\n\t\treturn this.lines[this.currentLine][newChar];\n\t}\n\n\tadvance(): string {\n\t\tconst char = this.getCurrentChar();\n\t\tif (this.currentChar >= this.lines[this.currentLine].length && this.currentLine < this.lines.length - 1) {\n\t\t\tthis.currentLine++;\n\t\t\tthis.currentChar = 0;\n\t\t} else {\n\t\t\tthis.currentChar++;\n\t\t}\n\t\treturn char;\n\t}\n\n\tadvanceLine(): void {\n\t\tthis.currentLine++;\n\t\tthis.currentChar = 0;\n\t}\n\n\tskipWhitespace(): void {\n\t\twhile (!this.isAtEnd() && this.currentChar < this.lines[this.currentLine].length && isWhitespace(this.getCurrentChar())) {\n\t\t\tthis.advance();\n\t\t}\n\t}\n\n\tskipToEndOfLine(): void {\n\t\tthis.currentChar = this.lines[this.currentLine].length;\n\t}\n\n\tgetIndentation(): number {\n\t\tif (this.isAtEnd()) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet indent = 0;\n\t\tfor (let i = 0; i < this.lines[this.currentLine].length; i++) {\n\t\t\tif (this.lines[this.currentLine][i] === ' ') {\n\t\t\t\tindent++;\n\t\t\t} else if (this.lines[this.currentLine][i] === '\\t') {\n\t\t\t\tindent += 4; // Treat tab as 4 spaces\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn indent;\n\t}\n\n\tmoveToNextNonEmptyLine(): void {\n\t\twhile (this.currentLine < this.lines.length) {\n\t\t\t// First check current line from current position\n\t\t\tif (this.currentChar < this.lines[this.currentLine].length) {\n\t\t\t\tconst remainingLine = this.lines[this.currentLine].substring(this.currentChar).trim();\n\t\t\t\tif (remainingLine.length > 0 && !remainingLine.startsWith('#')) {\n\t\t\t\t\tthis.skipWhitespace();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Move to next line and check from beginning\n\t\t\tthis.currentLine++;\n\t\t\tthis.currentChar = 0;\n\n\t\t\tif (this.currentLine < this.lines.length) {\n\t\t\t\tconst line = this.lines[this.currentLine].trim();\n\t\t\t\tif (line.length > 0 && !line.startsWith('#')) {\n\t\t\t\t\tthis.skipWhitespace();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Parser class for handling YAML parsing\nclass YamlParser {\n\tprivate lexer: YamlLexer;\n\tprivate errors: YamlParseError[];\n\tprivate options: ParseOptions;\n\t// Track nesting level of flow (inline) collections '[' ']' '{' '}'\n\tprivate flowLevel: number = 0;\n\n\tconstructor(lines: string[], errors: YamlParseError[], options: ParseOptions) {\n\t\tthis.lexer = new YamlLexer(lines);\n\t\tthis.errors = errors;\n\t\tthis.options = options;\n\t}\n\n\taddError(message: string, code: string, start: Position, end: Position): void {\n\t\tthis.errors.push({ message, code, start, end });\n\t}\n\n\tparseValue(expectedIndent?: number): YamlNode {\n\t\tthis.lexer.skipWhitespace();\n\n\t\tif (this.lexer.isAtEnd()) {\n\t\t\tconst pos = this.lexer.getCurrentPosition();\n\t\t\treturn createStringNode('', pos, pos);\n\t\t}\n\n\t\tconst char = this.lexer.getCurrentChar();\n\n\t\t// Handle quoted strings\n\t\tif (char === '\"' || char === `'`) {\n\t\t\treturn this.parseQuotedString(char);\n\t\t}\n\n\t\t// Handle inline arrays\n\t\tif (char === '[') {\n\t\t\treturn this.parseInlineArray();\n\t\t}\n\n\t\t// Handle inline objects\n\t\tif (char === '{') {\n\t\t\treturn this.parseInlineObject();\n\t\t}\n\n\t\t// Handle unquoted values\n\t\treturn this.parseUnquotedValue();\n\t}\n\n\tparseQuotedString(quote: string): YamlNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tthis.lexer.advance(); // Skip opening quote\n\n\t\tlet value = '';\n\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== quote) {\n\t\t\tvalue += this.lexer.advance();\n\t\t}\n\n\t\tif (this.lexer.getCurrentChar() === quote) {\n\t\t\tthis.lexer.advance(); // Skip closing quote\n\t\t}\n\n\t\tconst end = this.lexer.getCurrentPosition();\n\t\treturn createStringNode(value, start, end);\n\t}\n\n\tparseUnquotedValue(): YamlNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tlet value = '';\n\t\tlet endPos = start;\n\n\t\t// Helper function to check for value terminators\n\t\tconst isTerminator = (char: string): boolean => {\n\t\t\tif (char === '#') { return true; }\n\t\t\t// Comma, ']' and '}' only terminate inside flow collections\n\t\t\tif (this.flowLevel > 0 && (char === ',' || char === ']' || char === '}')) { return true; }\n\t\t\treturn false;\n\t\t};\n\n\t\t// Handle opening quote that might not be closed\n\t\tconst firstChar = this.lexer.getCurrentChar();\n\t\tif (firstChar === '\"' || firstChar === `'`) {\n\t\t\tvalue += this.lexer.advance();\n\t\t\tendPos = this.lexer.getCurrentPosition();\n\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '') {\n\t\t\t\tconst char = this.lexer.getCurrentChar();\n\t\t\t\tif (char === firstChar || isTerminator(char)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvalue += this.lexer.advance();\n\t\t\t\tendPos = this.lexer.getCurrentPosition();\n\t\t\t}\n\t\t} else {\n\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '') {\n\t\t\t\tconst char = this.lexer.getCurrentChar();\n\t\t\t\tif (isTerminator(char)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvalue += this.lexer.advance();\n\t\t\t\tendPos = this.lexer.getCurrentPosition();\n\t\t\t}\n\t\t}\n\t\tconst trimmed = value.trimEnd();\n\t\tconst diff = value.length - trimmed.length;\n\t\tif (diff) {\n\t\t\tendPos = createPosition(start.line, endPos.character - diff);\n\t\t}\n\t\tconst finalValue = (firstChar === '\"' || firstChar === `'`) ? trimmed.substring(1) : trimmed;\n\t\treturn this.createValueNode(finalValue, start, endPos);\n\t}\n\n\tprivate createValueNode(value: string, start: Position, end: Position): YamlNode {\n\t\tif (value === '') {\n\t\t\treturn createStringNode('', start, start);\n\t\t}\n\n\t\t// Boolean values\n\t\tif (value === 'true') {\n\t\t\treturn createBooleanNode(true, start, end);\n\t\t}\n\t\tif (value === 'false') {\n\t\t\treturn createBooleanNode(false, start, end);\n\t\t}\n\n\t\t// Null values\n\t\tif (value === 'null' || value === '~') {\n\t\t\treturn createNullNode(start, end);\n\t\t}\n\n\t\t// Number values\n\t\tconst numberValue = Number(value);\n\t\tif (!isNaN(numberValue) && isFinite(numberValue) && isValidNumber(value)) {\n\t\t\treturn createNumberNode(numberValue, start, end);\n\t\t}\n\n\t\t// Default to string\n\t\treturn createStringNode(value, start, end);\n\t}\n\n\tparseInlineArray(): YamlArrayNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tthis.lexer.advance(); // Skip '['\n\t\tthis.flowLevel++;\n\n\t\tconst items: YamlNode[] = [];\n\n\t\twhile (!this.lexer.isAtEnd()) {\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Handle end of array\n\t\t\tif (this.lexer.getCurrentChar() === ']') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Handle end of line - continue to next line for multi-line arrays\n\t\t\tif (this.lexer.getCurrentChar() === '') {\n\t\t\t\tthis.lexer.advanceLine();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Handle comments - comments should terminate the array parsing\n\t\t\tif (this.lexer.getCurrentChar() === '#') {\n\t\t\t\t// Skip the rest of the line (comment)\n\t\t\t\tthis.lexer.skipToEndOfLine();\n\t\t\t\tthis.lexer.advanceLine();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Save position before parsing to detect if we're making progress\n\t\t\tconst positionBefore = this.lexer.savePosition();\n\n\t\t\t// Parse array item\n\t\t\tconst item = this.parseValue();\n\t\t\t// Skip implicit empty items that arise from a leading comma at the beginning of a new line\n\t\t\t// (e.g. a line starting with \",foo\" after a comment). A legitimate empty string element\n\t\t\t// would have quotes and thus a non-zero span. We only filter zero-length spans.\n\t\t\tif (!(item.type === 'string' && item.value === '' && item.start.line === item.end.line && item.start.character === item.end.character)) {\n\t\t\t\titems.push(item);\n\t\t\t}\n\n\t\t\t// Check if we made progress - if not, we're likely stuck\n\t\t\tconst positionAfter = this.lexer.savePosition();\n\t\t\tif (positionBefore.line === positionAfter.line && positionBefore.char === positionAfter.char) {\n\t\t\t\t// No progress made, advance at least one character to prevent infinite loop\n\t\t\t\tif (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '') {\n\t\t\t\t\tthis.lexer.advance();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Handle comma separator\n\t\t\tif (this.lexer.getCurrentChar() === ',') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t}\n\t\t}\n\n\t\tconst end = this.lexer.getCurrentPosition();\n\t\tthis.flowLevel--;\n\t\treturn createArrayNode(items, start, end);\n\t}\n\n\tparseInlineObject(): YamlObjectNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tthis.lexer.advance(); // Skip '{'\n\t\tthis.flowLevel++;\n\n\t\tconst properties: { key: YamlStringNode; value: YamlNode }[] = [];\n\n\t\twhile (!this.lexer.isAtEnd()) {\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Handle end of object\n\t\t\tif (this.lexer.getCurrentChar() === '}') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Handle comments - comments should terminate the object parsing\n\t\t\tif (this.lexer.getCurrentChar() === '#') {\n\t\t\t\t// Skip the rest of the line (comment)\n\t\t\t\tthis.lexer.skipToEndOfLine();\n\t\t\t\tthis.lexer.advanceLine();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Save position before parsing to detect if we're making progress\n\t\t\tconst positionBefore = this.lexer.savePosition();\n\n\t\t\t// Parse key - read until colon\n\t\t\tconst keyStart = this.lexer.getCurrentPosition();\n\t\t\tlet keyValue = '';\n\n\t\t\t// Handle quoted keys\n\t\t\tif (this.lexer.getCurrentChar() === '\"' || this.lexer.getCurrentChar() === `'`) {\n\t\t\t\tconst quote = this.lexer.getCurrentChar();\n\t\t\t\tthis.lexer.advance(); // Skip opening quote\n\n\t\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== quote) {\n\t\t\t\t\tkeyValue += this.lexer.advance();\n\t\t\t\t}\n\n\t\t\t\tif (this.lexer.getCurrentChar() === quote) {\n\t\t\t\t\tthis.lexer.advance(); // Skip closing quote\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Handle unquoted keys - read until colon\n\t\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== ':') {\n\t\t\t\t\tkeyValue += this.lexer.advance();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tkeyValue = keyValue.trim();\n\t\t\tconst keyEnd = this.lexer.getCurrentPosition();\n\t\t\tconst key = createStringNode(keyValue, keyStart, keyEnd);\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Expect colon\n\t\t\tif (this.lexer.getCurrentChar() === ':') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t}\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Parse value\n\t\t\tconst value = this.parseValue();\n\n\t\t\tproperties.push({ key, value });\n\n\t\t\t// Check if we made progress - if not, we're likely stuck\n\t\t\tconst positionAfter = this.lexer.savePosition();\n\t\t\tif (positionBefore.line === positionAfter.line && positionBefore.char === positionAfter.char) {\n\t\t\t\t// No progress made, advance at least one character to prevent infinite loop\n\t\t\t\tif (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '') {\n\t\t\t\t\tthis.lexer.advance();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Handle comma separator\n\t\t\tif (this.lexer.getCurrentChar() === ',') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t}\n\t\t}\n\n\t\tconst end = this.lexer.getCurrentPosition();\n\t\tthis.flowLevel--;\n\t\treturn createObjectNode(properties, start, end);\n\t}\n\n\tparseBlockArray(baseIndent: number): YamlArrayNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tconst items: YamlNode[] = [];\n\n\t\twhile (!this.lexer.isAtEnd()) {\n\t\t\tthis.lexer.moveToNextNonEmptyLine();\n\n\t\t\tif (this.lexer.isAtEnd()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst currentIndent = this.lexer.getIndentation();\n\n\t\t\t// If indentation is less than expected, we're done with this array\n\t\t\tif (currentIndent < baseIndent) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Check for array item marker\n\t\t\tif (this.lexer.getCurrentChar() === '-') {\n\t\t\t\tthis.lexer.advance(); // Skip '-'\n\t\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t\tconst itemStart = this.lexer.getCurrentPosition();\n\n\t\t\t\t// Check if this is a nested structure\n\t\t\t\tif (this.lexer.getCurrentChar() === '' || this.lexer.getCurrentChar() === '#') {\n\t\t\t\t\t// Empty item - check if next lines form a nested structure\n\t\t\t\t\tthis.lexer.advanceLine();\n\n\t\t\t\t\tif (!this.lexer.isAtEnd()) {\n\t\t\t\t\t\tconst nextIndent = this.lexer.getIndentation();\n\n\t\t\t\t\t\tif (nextIndent > currentIndent) {\n\t\t\t\t\t\t\t// Check if the next line starts with a dash (nested array) or has properties (nested object)\n\t\t\t\t\t\t\tthis.lexer.skipWhitespace();\n\t\t\t\t\t\t\tif (this.lexer.getCurrentChar() === '-') {\n\t\t\t\t\t\t\t\t// It's a nested array\n\t\t\t\t\t\t\t\tconst nestedArray = this.parseBlockArray(nextIndent);\n\t\t\t\t\t\t\t\titems.push(nestedArray);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Check if it looks like an object property (has a colon)\n\t\t\t\t\t\t\t\tconst currentLine = this.lexer.getCurrentLineText();\n\t\t\t\t\t\t\t\tconst currentPos = this.lexer.getCurrentCharNumber();\n\t\t\t\t\t\t\t\tconst remainingLine = currentLine.substring(currentPos);\n\n\t\t\t\t\t\t\t\tif (remainingLine.includes(':') && !remainingLine.trim().startsWith('#')) {\n\t\t\t\t\t\t\t\t\t// It's a nested object\n\t\t\t\t\t\t\t\t\tconst nestedObject = this.parseBlockObject(nextIndent, this.lexer.getCurrentCharNumber());\n\t\t\t\t\t\t\t\t\titems.push(nestedObject);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Not a nested structure, create empty string\n\t\t\t\t\t\t\t\t\titems.push(createStringNode('', itemStart, itemStart));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// No nested content, empty item\n\t\t\t\t\t\t\titems.push(createStringNode('', itemStart, itemStart));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// End of input, empty item\n\t\t\t\t\t\titems.push(createStringNode('', itemStart, itemStart));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Parse the item value\n\t\t\t\t\t// Check if this is a multi-line object by looking for a colon and checking next lines\n\t\t\t\t\tconst currentLine = this.lexer.getCurrentLineText();\n\t\t\t\t\tconst currentPos = this.lexer.getCurrentCharNumber();\n\t\t\t\t\tconst remainingLine = currentLine.substring(currentPos);\n\n\t\t\t\t\t// Check if there's a colon on this line (indicating object properties)\n\t\t\t\t\tconst hasColon = remainingLine.includes(':');\n\n\t\t\t\t\tif (hasColon) {\n\t\t\t\t\t\t// Any line with a colon should be treated as an object\n\t\t\t\t\t\t// Parse as an object with the current item's indentation as the base\n\t\t\t\t\t\tconst item = this.parseBlockObject(itemStart.character, itemStart.character);\n\t\t\t\t\t\titems.push(item);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No colon, parse as regular value\n\t\t\t\t\t\tconst item = this.parseValue();\n\t\t\t\t\t\titems.push(item);\n\n\t\t\t\t\t\t// Skip to end of line\n\t\t\t\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== '#') {\n\t\t\t\t\t\t\tthis.lexer.advance();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.lexer.advanceLine();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No dash found at expected indent level, break\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Calculate end position based on the last item\n\t\tlet end = start;\n\t\tif (items.length > 0) {\n\t\t\tconst lastItem = items[items.length - 1];\n\t\t\tend = lastItem.end;\n\t\t} else {\n\t\t\t// If no items, end is right after the start\n\t\t\tend = createPosition(start.line, start.character + 1);\n\t\t}\n\n\t\treturn createArrayNode(items, start, end);\n\t}\n\n\tparseBlockObject(baseIndent: number, baseCharPosition?: number): YamlObjectNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tconst properties: { key: YamlStringNode; value: YamlNode }[] = [];\n\t\tconst localKeysSeen = new Set<string>();\n\n\t\t// For parsing from current position (inline object parsing)\n\t\tconst fromCurrentPosition = baseCharPosition !== undefined;\n\t\tlet firstIteration = true;\n\n\t\twhile (!this.lexer.isAtEnd()) {\n\t\t\tif (!firstIteration || !fromCurrentPosition) {\n\t\t\t\tthis.lexer.moveToNextNonEmptyLine();\n\t\t\t}\n\t\t\tfirstIteration = false;\n\n\t\t\tif (this.lexer.isAtEnd()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst currentIndent = this.lexer.getIndentation();\n\n\t\t\tif (fromCurrentPosition) {\n\t\t\t\t// For current position parsing, check character position alignment\n\t\t\t\tthis.lexer.skipWhitespace();\n\t\t\t\tconst currentCharPosition = this.lexer.getCurrentCharNumber();\n\n\t\t\t\tif (currentCharPosition < baseCharPosition) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For normal block parsing, check indentation level\n\t\t\t\tif (currentIndent < baseIndent) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Check for incorrect indentation\n\t\t\t\tif (currentIndent > baseIndent) {\n\t\t\t\t\tconst lineStart = createPosition(this.lexer.getCurrentLineNumber(), 0);\n\t\t\t\t\tconst lineEnd = createPosition(this.lexer.getCurrentLineNumber(), this.lexer.getCurrentLineText().length);\n\t\t\t\t\tthis.addError('Unexpected indentation', 'indentation', lineStart, lineEnd);\n\n\t\t\t\t\t// Try to recover by treating it as a property anyway\n\t\t\t\t\tthis.lexer.skipWhitespace();\n\t\t\t\t} else {\n\t\t\t\t\tthis.lexer.skipWhitespace();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Parse key\n\t\t\tconst keyStart = this.lexer.getCurrentPosition();\n\t\t\tlet keyValue = '';\n\n\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== ':') {\n\t\t\t\tkeyValue += this.lexer.advance();\n\t\t\t}\n\n\t\t\tkeyValue = keyValue.trim();\n\t\t\tconst keyEnd = this.lexer.getCurrentPosition();\n\t\t\tconst key = createStringNode(keyValue, keyStart, keyEnd);\n\n\t\t\t// Check for duplicate keys\n\t\t\tif (!this.options.allowDuplicateKeys && localKeysSeen.has(keyValue)) {\n\t\t\t\tthis.addError(`Duplicate key '${keyValue}'`, 'duplicateKey', keyStart, keyEnd);\n\t\t\t}\n\t\t\tlocalKeysSeen.add(keyValue);\n\n\t\t\t// Expect colon\n\t\t\tif (this.lexer.getCurrentChar() === ':') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t}\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Determine if value is on same line or next line(s)\n\t\t\tlet value: YamlNode;\n\t\t\tconst valueStart = this.lexer.getCurrentPosition();\n\n\t\t\tif (this.lexer.getCurrentChar() === '' || this.lexer.getCurrentChar() === '#') {\n\t\t\t\t// Value is on next line(s) or empty\n\t\t\t\tthis.lexer.advanceLine();\n\n\t\t\t\t// Check next line for nested content\n\t\t\t\tif (!this.lexer.isAtEnd()) {\n\t\t\t\t\tconst nextIndent = this.lexer.getIndentation();\n\n\t\t\t\t\tif (nextIndent > currentIndent) {\n\t\t\t\t\t\t// Nested content - determine if it's an object, array, or just a scalar value\n\t\t\t\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t\t\t\tif (this.lexer.getCurrentChar() === '-') {\n\t\t\t\t\t\t\tvalue = this.parseBlockArray(nextIndent);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Check if this looks like an object property (has a colon)\n\t\t\t\t\t\t\tconst currentLine = this.lexer.getCurrentLineText();\n\t\t\t\t\t\t\tconst currentPos = this.lexer.getCurrentCharNumber();\n\t\t\t\t\t\t\tconst remainingLine = currentLine.substring(currentPos);\n\n\t\t\t\t\t\t\tif (remainingLine.includes(':') && !remainingLine.trim().startsWith('#')) {\n\t\t\t\t\t\t\t\t// It's a nested object\n\t\t\t\t\t\t\t\tvalue = this.parseBlockObject(nextIndent);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// It's just a scalar value on the next line\n\t\t\t\t\t\t\t\tvalue = this.parseValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!fromCurrentPosition && nextIndent === currentIndent) {\n\t\t\t\t\t\t// Same indentation level - check if it's an array item\n\t\t\t\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t\t\t\tif (this.lexer.getCurrentChar() === '-') {\n\t\t\t\t\t\t\tvalue = this.parseBlockArray(currentIndent);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue = createStringNode('', valueStart, valueStart);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = createStringNode('', valueStart, valueStart);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvalue = createStringNode('', valueStart, valueStart);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Value is on the same line\n\t\t\t\tvalue = this.parseValue();\n\n\t\t\t\t// Skip any remaining content on this line (comments, etc.)\n\t\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== '#') {\n\t\t\t\t\tif (isWhitespace(this.lexer.getCurrentChar())) {\n\t\t\t\t\t\tthis.lexer.advance();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Skip to end of line if we hit a comment\n\t\t\t\tif (this.lexer.getCurrentChar() === '#') {\n\t\t\t\t\tthis.lexer.skipToEndOfLine();\n\t\t\t\t}\n\n\t\t\t\t// Move to next line for next iteration\n\t\t\t\tif (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() === '') {\n\t\t\t\t\tthis.lexer.advanceLine();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproperties.push({ key, value });\n\t\t}\n\n\t\t// Calculate the end position based on the last property\n\t\tlet end = start;\n\t\tif (properties.length > 0) {\n\t\t\tconst lastProperty = properties[properties.length - 1];\n\t\t\tend = lastProperty.value.end;\n\t\t}\n\n\t\treturn createObjectNode(properties, start, end);\n\t}\n\n\tparse(): YamlNode | undefined {\n\t\tif (this.lexer.isAtEnd()) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis.lexer.moveToNextNonEmptyLine();\n\n\t\tif (this.lexer.isAtEnd()) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Determine the root structure type\n\t\tthis.lexer.skipWhitespace();\n\n\t\tif (this.lexer.getCurrentChar() === '-') {\n\t\t\t// Check if this is an array item or a negative number\n\t\t\t// Look at the character after the dash\n\t\t\tconst nextChar = this.lexer.peek();\n\t\t\tif (nextChar === ' ' || nextChar === '\\t' || nextChar === '' || nextChar === '#') {\n\t\t\t\t// It's an array item (dash followed by whitespace/end/comment)\n\t\t\t\treturn this.parseBlockArray(0);\n\t\t\t} else {\n\t\t\t\t// It's likely a negative number or other value, treat as single value\n\t\t\t\treturn this.parseValue();\n\t\t\t}\n\t\t} else if (this.lexer.getCurrentChar() === '[') {\n\t\t\t// Root is an inline array\n\t\t\treturn this.parseInlineArray();\n\t\t} else if (this.lexer.getCurrentChar() === '{') {\n\t\t\t// Root is an inline object\n\t\t\treturn this.parseInlineObject();\n\t\t} else {\n\t\t\t// Check if this looks like a key-value pair by looking for a colon\n\t\t\t// For single values, there shouldn't be a colon\n\t\t\tconst currentLine = this.lexer.getCurrentLineText();\n\t\t\tconst currentPos = this.lexer.getCurrentCharNumber();\n\t\t\tconst remainingLine = currentLine.substring(currentPos);\n\n\t\t\t// Check if there's a colon that's not inside quotes\n\t\t\tlet hasColon = false;\n\t\t\tlet inQuotes = false;\n\t\t\tlet quoteChar = '';\n\n\t\t\tfor (let i = 0; i < remainingLine.length; i++) {\n\t\t\t\tconst char = remainingLine[i];\n\n\t\t\t\tif (!inQuotes && (char === '\"' || char === `'`)) {\n\t\t\t\t\tinQuotes = true;\n\t\t\t\t\tquoteChar = char;\n\t\t\t\t} else if (inQuotes && char === quoteChar) {\n\t\t\t\t\tinQuotes = false;\n\t\t\t\t\tquoteChar = '';\n\t\t\t\t} else if (!inQuotes && char === ':') {\n\t\t\t\t\thasColon = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (!inQuotes && char === '#') {\n\t\t\t\t\t// Comment starts, stop looking\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasColon) {\n\t\t\t\t// Root is an object\n\t\t\t\treturn this.parseBlockObject(0);\n\t\t\t} else {\n\t\t\t\t// Root is a single value\n\t\t\t\treturn this.parseValue();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Parses a simplified YAML-like input from a single string.\n * Supports objects, arrays, primitive types (string, number, boolean, null).\n * Tracks positions for error reporting and node locations.\n *\n * Limitations:\n * - No multi-line strings or block literals\n * - No anchors or references\n * - No complex types (dates, binary)\n * - No special handling for escape sequences in strings\n * - Indentation must be consistent (spaces only, no tabs)\n *\n * Notes:\n * - New line separators can be either \"\\n\" or \"\\r\\n\". The input string is split into lines internally.\n *\n * @param input A string containing the YAML-like input\n * @param errors Array to collect parsing errors\n * @param options Parsing options\n * @returns The parsed representation (ObjectNode, ArrayNode, or primitive node)\n */\nexport function parse(input: string, errors: YamlParseError[] = [], options: ParseOptions = {}): YamlNode | undefined {\n\t// Normalize both LF and CRLF by splitting on either; CR characters are not retained as part of line text.\n\t// This keeps the existing line/character based lexer logic intact.\n\tconst lines = input.length === 0 ? [] : input.split(/\\r\\n|\\n/);\n\tconst parser = new YamlParser(lines, errors, options);\n\treturn parser.parse();\n}\n\nexport interface YamlParseError {\n\treadonly message: string;\n\treadonly start: Position;\n\treadonly end: Position;\n\treadonly code: string;\n}\n\nexport interface ParseOptions {\n\treadonly allowDuplicateKeys?: boolean;\n}\n\nexport interface Position {\n\treadonly line: number;\n\treadonly character: number;\n}\n\nexport interface YamlStringNode {\n\treadonly type: 'string';\n\treadonly value: string;\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport interface YamlNumberNode {\n\treadonly type: 'number';\n\treadonly value: number;\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport interface YamlBooleanNode {\n\treadonly type: 'boolean';\n\treadonly value: boolean;\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport interface YamlNullNode {\n\treadonly type: 'null';\n\treadonly value: null;\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport interface YamlObjectNode {\n\treadonly type: 'object';\n\treadonly properties: { key: YamlStringNode; value: YamlNode }[];\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport interface YamlArrayNode {\n\treadonly type: 'array';\n\treadonly items: YamlNode[];\n\treadonly start: Position;\n\treadonly end: Position;\n}\n\nexport type YamlNode = YamlStringNode | YamlNumberNode | YamlBooleanNode | YamlNullNode | YamlObjectNode | YamlArrayNode;\n\n// Helper functions for position and node creation\nfunction createPosition(line: number, character: number): Position {\n\treturn { line, character };\n}\n\n// Specialized node creation functions using a more concise approach\nfunction createStringNode(value: string, start: Position, end: Position): YamlStringNode {\n\treturn { type: 'string', value, start, end };\n}\n\nfunction createNumberNode(value: number, start: Position, end: Position): YamlNumberNode {\n\treturn { type: 'number', value, start, end };\n}\n\nfunction createBooleanNode(value: boolean, start: Position, end: Position): YamlBooleanNode {\n\treturn { type: 'boolean', value, start, end };\n}\n\nfunction createNullNode(start: Position, end: Position): YamlNullNode {\n\treturn { type: 'null', value: null, start, end };\n}\n\nfunction createObjectNode(properties: { key: YamlStringNode; value: YamlNode }[], start: Position, end: Position): YamlObjectNode {\n\treturn { type: 'object', start, end, properties };\n}\n\nfunction createArrayNode(items: YamlNode[], start: Position, end: Position): YamlArrayNode {\n\treturn { type: 'array', start, end, items };\n}\n\n// Utility functions for parsing\nfunction isWhitespace(char: string): boolean {\n\treturn char === ' ' || char === '\\t';\n}\n\n// Simplified number validation using regex\nfunction isValidNumber(value: string): boolean {\n\treturn /^-?\\d*\\.?\\d+$/.test(value);\n}\n\n// Lexer/Tokenizer for YAML content\nclass YamlLexer {\n\tprivate lines: string[];\n\tprivate currentLine: number = 0;\n\tprivate currentChar: number = 0;\n\n\tconstructor(lines: string[]) {\n\t\tthis.lines = lines;\n\t}\n\n\tgetCurrentPosition(): Position {\n\t\treturn createPosition(this.currentLine, this.currentChar);\n\t}\n\n\tgetCurrentLineNumber(): number {\n\t\treturn this.currentLine;\n\t}\n\n\tgetCurrentCharNumber(): number {\n\t\treturn this.currentChar;\n\t}\n\n\tgetCurrentLineText(): string {\n\t\treturn this.currentLine < this.lines.length ? this.lines[this.currentLine] : '';\n\t}\n\n\tsavePosition(): { line: number; char: number } {\n\t\treturn { line: this.currentLine, char: this.currentChar };\n\t}\n\n\trestorePosition(pos: { line: number; char: number }): void {\n\t\tthis.currentLine = pos.line;\n\t\tthis.currentChar = pos.char;\n\t}\n\n\tisAtEnd(): boolean {\n\t\treturn this.currentLine >= this.lines.length;\n\t}\n\n\tgetCurrentChar(): string {\n\t\tif (this.isAtEnd() || this.currentChar >= this.lines[this.currentLine].length) {\n\t\t\treturn '';\n\t\t}\n\t\treturn this.lines[this.currentLine][this.currentChar];\n\t}\n\n\tpeek(offset: number = 1): string {\n\t\tconst newChar = this.currentChar + offset;\n\t\tif (this.currentLine >= this.lines.length || newChar >= this.lines[this.currentLine].length) {\n\t\t\treturn '';\n\t\t}\n\t\treturn this.lines[this.currentLine][newChar];\n\t}\n\n\tadvance(): string {\n\t\tconst char = this.getCurrentChar();\n\t\tif (this.currentChar >= this.lines[this.currentLine].length && this.currentLine < this.lines.length - 1) {\n\t\t\tthis.currentLine++;\n\t\t\tthis.currentChar = 0;\n\t\t} else {\n\t\t\tthis.currentChar++;\n\t\t}\n\t\treturn char;\n\t}\n\n\tadvanceLine(): void {\n\t\tthis.currentLine++;\n\t\tthis.currentChar = 0;\n\t}\n\n\tskipWhitespace(): void {\n\t\twhile (!this.isAtEnd() && this.currentChar < this.lines[this.currentLine].length && isWhitespace(this.getCurrentChar())) {\n\t\t\tthis.advance();\n\t\t}\n\t}\n\n\tskipToEndOfLine(): void {\n\t\tthis.currentChar = this.lines[this.currentLine].length;\n\t}\n\n\tgetIndentation(): number {\n\t\tif (this.isAtEnd()) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet indent = 0;\n\t\tfor (let i = 0; i < this.lines[this.currentLine].length; i++) {\n\t\t\tif (this.lines[this.currentLine][i] === ' ') {\n\t\t\t\tindent++;\n\t\t\t} else if (this.lines[this.currentLine][i] === '\\t') {\n\t\t\t\tindent += 4; // Treat tab as 4 spaces\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn indent;\n\t}\n\n\tmoveToNextNonEmptyLine(): void {\n\t\twhile (this.currentLine < this.lines.length) {\n\t\t\t// First check current line from current position\n\t\t\tif (this.currentChar < this.lines[this.currentLine].length) {\n\t\t\t\tconst remainingLine = this.lines[this.currentLine].substring(this.currentChar).trim();\n\t\t\t\tif (remainingLine.length > 0 && !remainingLine.startsWith('#')) {\n\t\t\t\t\tthis.skipWhitespace();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Move to next line and check from beginning\n\t\t\tthis.currentLine++;\n\t\t\tthis.currentChar = 0;\n\n\t\t\tif (this.currentLine < this.lines.length) {\n\t\t\t\tconst line = this.lines[this.currentLine].trim();\n\t\t\t\tif (line.length > 0 && !line.startsWith('#')) {\n\t\t\t\t\tthis.skipWhitespace();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Parser class for handling YAML parsing\nclass YamlParser {\n\tprivate lexer: YamlLexer;\n\tprivate errors: YamlParseError[];\n\tprivate options: ParseOptions;\n\t// Track nesting level of flow (inline) collections '[' ']' '{' '}'\n\tprivate flowLevel: number = 0;\n\n\tconstructor(lines: string[], errors: YamlParseError[], options: ParseOptions) {\n\t\tthis.lexer = new YamlLexer(lines);\n\t\tthis.errors = errors;\n\t\tthis.options = options;\n\t}\n\n\taddError(message: string, code: string, start: Position, end: Position): void {\n\t\tthis.errors.push({ message, code, start, end });\n\t}\n\n\tparseValue(expectedIndent?: number): YamlNode {\n\t\tthis.lexer.skipWhitespace();\n\n\t\tif (this.lexer.isAtEnd()) {\n\t\t\tconst pos = this.lexer.getCurrentPosition();\n\t\t\treturn createStringNode('', pos, pos);\n\t\t}\n\n\t\tconst char = this.lexer.getCurrentChar();\n\n\t\t// Handle quoted strings\n\t\tif (char === '\"' || char === `'`) {\n\t\t\treturn this.parseQuotedString(char);\n\t\t}\n\n\t\t// Handle inline arrays\n\t\tif (char === '[') {\n\t\t\treturn this.parseInlineArray();\n\t\t}\n\n\t\t// Handle inline objects\n\t\tif (char === '{') {\n\t\t\treturn this.parseInlineObject();\n\t\t}\n\n\t\t// Handle unquoted values\n\t\treturn this.parseUnquotedValue();\n\t}\n\n\tparseQuotedString(quote: string): YamlNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tthis.lexer.advance(); // Skip opening quote\n\n\t\tlet value = '';\n\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== quote) {\n\t\t\tvalue += this.lexer.advance();\n\t\t}\n\n\t\tif (this.lexer.getCurrentChar() === quote) {\n\t\t\tthis.lexer.advance(); // Skip closing quote\n\t\t}\n\n\t\tconst end = this.lexer.getCurrentPosition();\n\t\treturn createStringNode(value, start, end);\n\t}\n\n\tparseUnquotedValue(): YamlNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tlet value = '';\n\t\tlet endPos = start;\n\n\t\t// Helper function to check for value terminators\n\t\tconst isTerminator = (char: string): boolean => {\n\t\t\tif (char === '#') { return true; }\n\t\t\t// Comma, ']' and '}' only terminate inside flow collections\n\t\t\tif (this.flowLevel > 0 && (char === ',' || char === ']' || char === '}')) { return true; }\n\t\t\treturn false;\n\t\t};\n\n\t\t// Handle opening quote that might not be closed\n\t\tconst firstChar = this.lexer.getCurrentChar();\n\t\tif (firstChar === '\"' || firstChar === `'`) {\n\t\t\tvalue += this.lexer.advance();\n\t\t\tendPos = this.lexer.getCurrentPosition();\n\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '') {\n\t\t\t\tconst char = this.lexer.getCurrentChar();\n\t\t\t\tif (char === firstChar || isTerminator(char)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvalue += this.lexer.advance();\n\t\t\t\tendPos = this.lexer.getCurrentPosition();\n\t\t\t}\n\t\t} else {\n\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '') {\n\t\t\t\tconst char = this.lexer.getCurrentChar();\n\t\t\t\tif (isTerminator(char)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvalue += this.lexer.advance();\n\t\t\t\tendPos = this.lexer.getCurrentPosition();\n\t\t\t}\n\t\t}\n\t\tconst trimmed = value.trimEnd();\n\t\tconst diff = value.length - trimmed.length;\n\t\tif (diff) {\n\t\t\tendPos = createPosition(start.line, endPos.character - diff);\n\t\t}\n\t\tconst finalValue = (firstChar === '\"' || firstChar === `'`) ? trimmed.substring(1) : trimmed;\n\t\treturn this.createValueNode(finalValue, start, endPos);\n\t}\n\n\tprivate createValueNode(value: string, start: Position, end: Position): YamlNode {\n\t\tif (value === '') {\n\t\t\treturn createStringNode('', start, start);\n\t\t}\n\n\t\t// Boolean values\n\t\tif (value === 'true') {\n\t\t\treturn createBooleanNode(true, start, end);\n\t\t}\n\t\tif (value === 'false') {\n\t\t\treturn createBooleanNode(false, start, end);\n\t\t}\n\n\t\t// Null values\n\t\tif (value === 'null' || value === '~') {\n\t\t\treturn createNullNode(start, end);\n\t\t}\n\n\t\t// Number values\n\t\tconst numberValue = Number(value);\n\t\tif (!isNaN(numberValue) && isFinite(numberValue) && isValidNumber(value)) {\n\t\t\treturn createNumberNode(numberValue, start, end);\n\t\t}\n\n\t\t// Default to string\n\t\treturn createStringNode(value, start, end);\n\t}\n\n\tparseInlineArray(): YamlArrayNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tthis.lexer.advance(); // Skip '['\n\t\tthis.flowLevel++;\n\n\t\tconst items: YamlNode[] = [];\n\n\t\twhile (!this.lexer.isAtEnd()) {\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Handle end of array\n\t\t\tif (this.lexer.getCurrentChar() === ']') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Handle end of line - continue to next line for multi-line arrays\n\t\t\tif (this.lexer.getCurrentChar() === '') {\n\t\t\t\tthis.lexer.advanceLine();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Handle comments - comments should terminate the array parsing\n\t\t\tif (this.lexer.getCurrentChar() === '#') {\n\t\t\t\t// Skip the rest of the line (comment)\n\t\t\t\tthis.lexer.skipToEndOfLine();\n\t\t\t\tthis.lexer.advanceLine();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Save position before parsing to detect if we're making progress\n\t\t\tconst positionBefore = this.lexer.savePosition();\n\n\t\t\t// Parse array item\n\t\t\tconst item = this.parseValue();\n\t\t\t// Skip implicit empty items that arise from a leading comma at the beginning of a new line\n\t\t\t// (e.g. a line starting with \",foo\" after a comment). A legitimate empty string element\n\t\t\t// would have quotes and thus a non-zero span. We only filter zero-length spans.\n\t\t\tif (!(item.type === 'string' && item.value === '' && item.start.line === item.end.line && item.start.character === item.end.character)) {\n\t\t\t\titems.push(item);\n\t\t\t}\n\n\t\t\t// Check if we made progress - if not, we're likely stuck\n\t\t\tconst positionAfter = this.lexer.savePosition();\n\t\t\tif (positionBefore.line === positionAfter.line && positionBefore.char === positionAfter.char) {\n\t\t\t\t// No progress made, advance at least one character to prevent infinite loop\n\t\t\t\tif (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '') {\n\t\t\t\t\tthis.lexer.advance();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Handle comma separator\n\t\t\tif (this.lexer.getCurrentChar() === ',') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t}\n\t\t}\n\n\t\tconst end = this.lexer.getCurrentPosition();\n\t\tthis.flowLevel--;\n\t\treturn createArrayNode(items, start, end);\n\t}\n\n\tparseInlineObject(): YamlObjectNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tthis.lexer.advance(); // Skip '{'\n\t\tthis.flowLevel++;\n\n\t\tconst properties: { key: YamlStringNode; value: YamlNode }[] = [];\n\n\t\twhile (!this.lexer.isAtEnd()) {\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Handle end of object\n\t\t\tif (this.lexer.getCurrentChar() === '}') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Handle comments - comments should terminate the object parsing\n\t\t\tif (this.lexer.getCurrentChar() === '#') {\n\t\t\t\t// Skip the rest of the line (comment)\n\t\t\t\tthis.lexer.skipToEndOfLine();\n\t\t\t\tthis.lexer.advanceLine();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Save position before parsing to detect if we're making progress\n\t\t\tconst positionBefore = this.lexer.savePosition();\n\n\t\t\t// Parse key - read until colon\n\t\t\tconst keyStart = this.lexer.getCurrentPosition();\n\t\t\tlet keyValue = '';\n\n\t\t\t// Handle quoted keys\n\t\t\tif (this.lexer.getCurrentChar() === '\"' || this.lexer.getCurrentChar() === `'`) {\n\t\t\t\tconst quote = this.lexer.getCurrentChar();\n\t\t\t\tthis.lexer.advance(); // Skip opening quote\n\n\t\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== quote) {\n\t\t\t\t\tkeyValue += this.lexer.advance();\n\t\t\t\t}\n\n\t\t\t\tif (this.lexer.getCurrentChar() === quote) {\n\t\t\t\t\tthis.lexer.advance(); // Skip closing quote\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Handle unquoted keys - read until colon\n\t\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== ':') {\n\t\t\t\t\tkeyValue += this.lexer.advance();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tkeyValue = keyValue.trim();\n\t\t\tconst keyEnd = this.lexer.getCurrentPosition();\n\t\t\tconst key = createStringNode(keyValue, keyStart, keyEnd);\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Expect colon\n\t\t\tif (this.lexer.getCurrentChar() === ':') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t}\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Parse value\n\t\t\tconst value = this.parseValue();\n\n\t\t\tproperties.push({ key, value });\n\n\t\t\t// Check if we made progress - if not, we're likely stuck\n\t\t\tconst positionAfter = this.lexer.savePosition();\n\t\t\tif (positionBefore.line === positionAfter.line && positionBefore.char === positionAfter.char) {\n\t\t\t\t// No progress made, advance at least one character to prevent infinite loop\n\t\t\t\tif (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '') {\n\t\t\t\t\tthis.lexer.advance();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Handle comma separator\n\t\t\tif (this.lexer.getCurrentChar() === ',') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t}\n\t\t}\n\n\t\tconst end = this.lexer.getCurrentPosition();\n\t\tthis.flowLevel--;\n\t\treturn createObjectNode(properties, start, end);\n\t}\n\n\tparseBlockArray(baseIndent: number): YamlArrayNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tconst items: YamlNode[] = [];\n\n\t\twhile (!this.lexer.isAtEnd()) {\n\t\t\tthis.lexer.moveToNextNonEmptyLine();\n\n\t\t\tif (this.lexer.isAtEnd()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst currentIndent = this.lexer.getIndentation();\n\n\t\t\t// If indentation is less than expected, we're done with this array\n\t\t\tif (currentIndent < baseIndent) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Check for array item marker\n\t\t\tif (this.lexer.getCurrentChar() === '-') {\n\t\t\t\tthis.lexer.advance(); // Skip '-'\n\t\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t\tconst itemStart = this.lexer.getCurrentPosition();\n\n\t\t\t\t// Check if this is a nested structure\n\t\t\t\tif (this.lexer.getCurrentChar() === '' || this.lexer.getCurrentChar() === '#') {\n\t\t\t\t\t// Empty item - check if next lines form a nested structure\n\t\t\t\t\tthis.lexer.advanceLine();\n\n\t\t\t\t\tif (!this.lexer.isAtEnd()) {\n\t\t\t\t\t\tconst nextIndent = this.lexer.getIndentation();\n\n\t\t\t\t\t\tif (nextIndent > currentIndent) {\n\t\t\t\t\t\t\t// Check if the next line starts with a dash (nested array) or has properties (nested object)\n\t\t\t\t\t\t\tthis.lexer.skipWhitespace();\n\t\t\t\t\t\t\tif (this.lexer.getCurrentChar() === '-') {\n\t\t\t\t\t\t\t\t// It's a nested array\n\t\t\t\t\t\t\t\tconst nestedArray = this.parseBlockArray(nextIndent);\n\t\t\t\t\t\t\t\titems.push(nestedArray);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Check if it looks like an object property (has a colon)\n\t\t\t\t\t\t\t\tconst currentLine = this.lexer.getCurrentLineText();\n\t\t\t\t\t\t\t\tconst currentPos = this.lexer.getCurrentCharNumber();\n\t\t\t\t\t\t\t\tconst remainingLine = currentLine.substring(currentPos);\n\n\t\t\t\t\t\t\t\tif (remainingLine.includes(':') && !remainingLine.trim().startsWith('#')) {\n\t\t\t\t\t\t\t\t\t// It's a nested object\n\t\t\t\t\t\t\t\t\tconst nestedObject = this.parseBlockObject(nextIndent, this.lexer.getCurrentCharNumber());\n\t\t\t\t\t\t\t\t\titems.push(nestedObject);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Not a nested structure, create empty string\n\t\t\t\t\t\t\t\t\titems.push(createStringNode('', itemStart, itemStart));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// No nested content, empty item\n\t\t\t\t\t\t\titems.push(createStringNode('', itemStart, itemStart));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// End of input, empty item\n\t\t\t\t\t\titems.push(createStringNode('', itemStart, itemStart));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Parse the item value\n\t\t\t\t\t// Check if this is a multi-line object by looking for a colon and checking next lines\n\t\t\t\t\tconst currentLine = this.lexer.getCurrentLineText();\n\t\t\t\t\tconst currentPos = this.lexer.getCurrentCharNumber();\n\t\t\t\t\tconst remainingLine = currentLine.substring(currentPos);\n\n\t\t\t\t\t// Check if there's a colon on this line (indicating object properties)\n\t\t\t\t\tconst hasColon = remainingLine.includes(':');\n\n\t\t\t\t\tif (hasColon) {\n\t\t\t\t\t\t// Any line with a colon should be treated as an object\n\t\t\t\t\t\t// Parse as an object with the current item's indentation as the base\n\t\t\t\t\t\tconst item = this.parseBlockObject(itemStart.character, itemStart.character);\n\t\t\t\t\t\titems.push(item);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No colon, parse as regular value\n\t\t\t\t\t\tconst item = this.parseValue();\n\t\t\t\t\t\titems.push(item);\n\n\t\t\t\t\t\t// Skip to end of line\n\t\t\t\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== '#') {\n\t\t\t\t\t\t\tthis.lexer.advance();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.lexer.advanceLine();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No dash found at expected indent level, break\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Calculate end position based on the last item\n\t\tlet end = start;\n\t\tif (items.length > 0) {\n\t\t\tconst lastItem = items[items.length - 1];\n\t\t\tend = lastItem.end;\n\t\t} else {\n\t\t\t// If no items, end is right after the start\n\t\t\tend = createPosition(start.line, start.character + 1);\n\t\t}\n\n\t\treturn createArrayNode(items, start, end);\n\t}\n\n\tparseBlockObject(baseIndent: number, baseCharPosition?: number): YamlObjectNode {\n\t\tconst start = this.lexer.getCurrentPosition();\n\t\tconst properties: { key: YamlStringNode; value: YamlNode }[] = [];\n\t\tconst localKeysSeen = new Set<string>();\n\n\t\t// For parsing from current position (inline object parsing)\n\t\tconst fromCurrentPosition = baseCharPosition !== undefined;\n\t\tlet firstIteration = true;\n\n\t\twhile (!this.lexer.isAtEnd()) {\n\t\t\tif (!firstIteration || !fromCurrentPosition) {\n\t\t\t\tthis.lexer.moveToNextNonEmptyLine();\n\t\t\t}\n\t\t\tfirstIteration = false;\n\n\t\t\tif (this.lexer.isAtEnd()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst currentIndent = this.lexer.getIndentation();\n\n\t\t\tif (fromCurrentPosition) {\n\t\t\t\t// For current position parsing, check character position alignment\n\t\t\t\tthis.lexer.skipWhitespace();\n\t\t\t\tconst currentCharPosition = this.lexer.getCurrentCharNumber();\n\n\t\t\t\tif (currentCharPosition < baseCharPosition) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For normal block parsing, check indentation level\n\t\t\t\tif (currentIndent < baseIndent) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Check for incorrect indentation\n\t\t\t\tif (currentIndent > baseIndent) {\n\t\t\t\t\tconst lineStart = createPosition(this.lexer.getCurrentLineNumber(), 0);\n\t\t\t\t\tconst lineEnd = createPosition(this.lexer.getCurrentLineNumber(), this.lexer.getCurrentLineText().length);\n\t\t\t\t\tthis.addError('Unexpected indentation', 'indentation', lineStart, lineEnd);\n\n\t\t\t\t\t// Try to recover by treating it as a property anyway\n\t\t\t\t\tthis.lexer.skipWhitespace();\n\t\t\t\t} else {\n\t\t\t\t\tthis.lexer.skipWhitespace();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Parse key\n\t\t\tconst keyStart = this.lexer.getCurrentPosition();\n\t\t\tlet keyValue = '';\n\n\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== ':') {\n\t\t\t\tkeyValue += this.lexer.advance();\n\t\t\t}\n\n\t\t\tkeyValue = keyValue.trim();\n\t\t\tconst keyEnd = this.lexer.getCurrentPosition();\n\t\t\tconst key = createStringNode(keyValue, keyStart, keyEnd);\n\n\t\t\t// Check for duplicate keys\n\t\t\tif (!this.options.allowDuplicateKeys && localKeysSeen.has(keyValue)) {\n\t\t\t\tthis.addError(`Duplicate key '${keyValue}'`, 'duplicateKey', keyStart, keyEnd);\n\t\t\t}\n\t\t\tlocalKeysSeen.add(keyValue);\n\n\t\t\t// Expect colon\n\t\t\tif (this.lexer.getCurrentChar() === ':') {\n\t\t\t\tthis.lexer.advance();\n\t\t\t}\n\n\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t// Determine if value is on same line or next line(s)\n\t\t\tlet value: YamlNode;\n\t\t\tconst valueStart = this.lexer.getCurrentPosition();\n\n\t\t\tif (this.lexer.getCurrentChar() === '' || this.lexer.getCurrentChar() === '#') {\n\t\t\t\t// Value is on next line(s) or empty\n\t\t\t\tthis.lexer.advanceLine();\n\n\t\t\t\t// Check next line for nested content\n\t\t\t\tif (!this.lexer.isAtEnd()) {\n\t\t\t\t\tconst nextIndent = this.lexer.getIndentation();\n\n\t\t\t\t\tif (nextIndent > currentIndent) {\n\t\t\t\t\t\t// Nested content - determine if it's an object, array, or just a scalar value\n\t\t\t\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t\t\t\tif (this.lexer.getCurrentChar() === '-') {\n\t\t\t\t\t\t\tvalue = this.parseBlockArray(nextIndent);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Check if this looks like an object property (has a colon)\n\t\t\t\t\t\t\tconst currentLine = this.lexer.getCurrentLineText();\n\t\t\t\t\t\t\tconst currentPos = this.lexer.getCurrentCharNumber();\n\t\t\t\t\t\t\tconst remainingLine = currentLine.substring(currentPos);\n\n\t\t\t\t\t\t\tif (remainingLine.includes(':') && !remainingLine.trim().startsWith('#')) {\n\t\t\t\t\t\t\t\t// It's a nested object\n\t\t\t\t\t\t\t\tvalue = this.parseBlockObject(nextIndent);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// It's just a scalar value on the next line\n\t\t\t\t\t\t\t\tvalue = this.parseValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!fromCurrentPosition && nextIndent === currentIndent) {\n\t\t\t\t\t\t// Same indentation level - check if it's an array item\n\t\t\t\t\t\tthis.lexer.skipWhitespace();\n\n\t\t\t\t\t\tif (this.lexer.getCurrentChar() === '-') {\n\t\t\t\t\t\t\tvalue = this.parseBlockArray(currentIndent);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue = createStringNode('', valueStart, valueStart);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = createStringNode('', valueStart, valueStart);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvalue = createStringNode('', valueStart, valueStart);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Value is on the same line\n\t\t\t\tvalue = this.parseValue();\n\n\t\t\t\t// Skip any remaining content on this line (comments, etc.)\n\t\t\t\twhile (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() !== '' && this.lexer.getCurrentChar() !== '#') {\n\t\t\t\t\tif (isWhitespace(this.lexer.getCurrentChar())) {\n\t\t\t\t\t\tthis.lexer.advance();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Skip to end of line if we hit a comment\n\t\t\t\tif (this.lexer.getCurrentChar() === '#') {\n\t\t\t\t\tthis.lexer.skipToEndOfLine();\n\t\t\t\t}\n\n\t\t\t\t// Move to next line for next iteration\n\t\t\t\tif (!this.lexer.isAtEnd() && this.lexer.getCurrentChar() === '') {\n\t\t\t\t\tthis.lexer.advanceLine();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproperties.push({ key, value });\n\t\t}\n\n\t\t// Calculate the end position based on the last property\n\t\tlet end = start;\n\t\tif (properties.length > 0) {\n\t\t\tconst lastProperty = properties[properties.length - 1];\n\t\t\tend = lastProperty.value.end;\n\t\t}\n\n\t\treturn createObjectNode(properties, start, end);\n\t}\n\n\tparse(): YamlNode | undefined {\n\t\tif (this.lexer.isAtEnd()) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis.lexer.moveToNextNonEmptyLine();\n\n\t\tif (this.lexer.isAtEnd()) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Determine the root structure type\n\t\tthis.lexer.skipWhitespace();\n\n\t\tif (this.lexer.getCurrentChar() === '-') {\n\t\t\t// Check if this is an array item or a negative number\n\t\t\t// Look at the character after the dash\n\t\t\tconst nextChar = this.lexer.peek();\n\t\t\tif (nextChar === ' ' || nextChar === '\\t' || nextChar === '' || nextChar === '#') {\n\t\t\t\t// It's an array item (dash followed by whitespace/end/comment)\n\t\t\t\treturn this.parseBlockArray(0);\n\t\t\t} else {\n\t\t\t\t// It's likely a negative number or other value, treat as single value\n\t\t\t\treturn this.parseValue();\n\t\t\t}\n\t\t} else if (this.lexer.getCurrentChar() === '[') {\n\t\t\t// Root is an inline array\n\t\t\treturn this.parseInlineArray();\n\t\t} else if (this.lexer.getCurrentChar() === '{') {\n\t\t\t// Root is an inline object\n\t\t\treturn this.parseInlineObject();\n\t\t} else {\n\t\t\t// Check if this looks like a key-value pair by looking for a colon\n\t\t\t// For single values, there shouldn't be a colon\n\t\t\tconst currentLine = this.lexer.getCurrentLineText();\n\t\t\tconst currentPos = this.lexer.getCurrentCharNumber();\n\t\t\tconst remainingLine = currentLine.substring(currentPos);\n\n\t\t\t// Check if there's a colon that's not inside quotes\n\t\t\tlet hasColon = false;\n\t\t\tlet inQuotes = false;\n\t\t\tlet quoteChar = '';\n\n\t\t\tfor (let i = 0; i < remainingLine.length; i++) {\n\t\t\t\tconst char = remainingLine[i];\n\n\t\t\t\tif (!inQuotes && (char === '\"' || char === `'`)) {\n\t\t\t\t\tinQuotes = true;\n\t\t\t\t\tquoteChar = char;\n\t\t\t\t} else if (inQuotes && char === quoteChar) {\n\t\t\t\t\tinQuotes = false;\n\t\t\t\t\tquoteChar = '';\n\t\t\t\t} else if (!inQuotes && char === ':') {\n\t\t\t\t\thasColon = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (!inQuotes && char === '#') {\n\t\t\t\t\t// Comment starts, stop looking\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasColon) {\n\t\t\t\t// Root is an object\n\t\t\t\treturn this.parseBlockObject(0);\n\t\t\t} else {\n\t\t\t\t// Root is a single value\n\t\t\t\treturn this.parseValue();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"]}