{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/controlFlow.ts","vs/base/common/controlFlow.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAChG,OAAO,EAAE,kBAAkB,EAAE,MAAM,aAAa,CAAC;AAEjD;;EAEE;AAEF;;EAEE;AACF,MAAM,OAAO,iBAAiB;IAA9B;QACS,gBAAW,GAAG,KAAK,CAAC;IAsD7B,CAAC;IApDA;;;OAGG;IACI,oBAAoB,CAAC,MAAkB;QAC7C,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACtB,OAAO;QACR,CAAC;QACD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,IAAI,CAAC;YACJ,MAAM,EAAE,CAAC;QACV,CAAC;gBAAS,CAAC;YACV,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;QAC1B,CAAC;IACF,CAAC;IAED;;;OAGG;IACI,qBAAqB,CAAC,MAAkB;QAC9C,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACtB,MAAM,IAAI,kBAAkB,CAAC,6CAA6C,CAAC,CAAC;QAC7E,CAAC;QACD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,IAAI,CAAC;YACJ,MAAM,EAAE,CAAC;QACV,CAAC;gBAAS,CAAC;YACV,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;QAC1B,CAAC;IACF,CAAC;IAED;;MAEE;IACF,IAAW,UAAU;QACpB,OAAO,IAAI,CAAC,WAAW,CAAC;IACzB,CAAC;IAEM,mBAAmB,CAA0B,EAA4B;QAC/E,OAAO,CAAC,CAAC,GAAG,IAAW,EAAE,EAAE;YAC1B,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;gBACtB,OAAO;YACR,CAAC;YACD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;YACxB,IAAI,CAAC;gBACJ,OAAO,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;YACpB,CAAC;oBAAS,CAAC;gBACV,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;YAC1B,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;CACD","file":"controlFlow.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from './errors.js';\n\n/*\n * This file contains helper classes to manage control flow.\n*/\n\n/**\n * Prevents code from being re-entrant.\n*/\nexport class ReentrancyBarrier {\n\tprivate _isOccupied = false;\n\n\t/**\n\t * Calls `runner` if the barrier is not occupied.\n\t * During the call, the barrier becomes occupied.\n\t */\n\tpublic runExclusivelyOrSkip(runner: () => void): void {\n\t\tif (this._isOccupied) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isOccupied = true;\n\t\ttry {\n\t\t\trunner();\n\t\t} finally {\n\t\t\tthis._isOccupied = false;\n\t\t}\n\t}\n\n\t/**\n\t * Calls `runner`. If the barrier is occupied, throws an error.\n\t * During the call, the barrier becomes active.\n\t */\n\tpublic runExclusivelyOrThrow(runner: () => void): void {\n\t\tif (this._isOccupied) {\n\t\t\tthrow new BugIndicatingError(`ReentrancyBarrier: reentrant call detected!`);\n\t\t}\n\t\tthis._isOccupied = true;\n\t\ttry {\n\t\t\trunner();\n\t\t} finally {\n\t\t\tthis._isOccupied = false;\n\t\t}\n\t}\n\n\t/**\n\t * Indicates if some runner occupies this barrier.\n\t*/\n\tpublic get isOccupied() {\n\t\treturn this._isOccupied;\n\t}\n\n\tpublic makeExclusiveOrSkip<TArgs extends unknown[]>(fn: (...args: TArgs) => void): (...args: TArgs) => void {\n\t\treturn ((...args: TArgs) => {\n\t\t\tif (this._isOccupied) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._isOccupied = true;\n\t\t\ttry {\n\t\t\t\treturn fn(...args);\n\t\t\t} finally {\n\t\t\t\tthis._isOccupied = false;\n\t\t\t}\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from './errors.js';\n\n/*\n * This file contains helper classes to manage control flow.\n*/\n\n/**\n * Prevents code from being re-entrant.\n*/\nexport class ReentrancyBarrier {\n\tprivate _isOccupied = false;\n\n\t/**\n\t * Calls `runner` if the barrier is not occupied.\n\t * During the call, the barrier becomes occupied.\n\t */\n\tpublic runExclusivelyOrSkip(runner: () => void): void {\n\t\tif (this._isOccupied) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isOccupied = true;\n\t\ttry {\n\t\t\trunner();\n\t\t} finally {\n\t\t\tthis._isOccupied = false;\n\t\t}\n\t}\n\n\t/**\n\t * Calls `runner`. If the barrier is occupied, throws an error.\n\t * During the call, the barrier becomes active.\n\t */\n\tpublic runExclusivelyOrThrow(runner: () => void): void {\n\t\tif (this._isOccupied) {\n\t\t\tthrow new BugIndicatingError(`ReentrancyBarrier: reentrant call detected!`);\n\t\t}\n\t\tthis._isOccupied = true;\n\t\ttry {\n\t\t\trunner();\n\t\t} finally {\n\t\t\tthis._isOccupied = false;\n\t\t}\n\t}\n\n\t/**\n\t * Indicates if some runner occupies this barrier.\n\t*/\n\tpublic get isOccupied() {\n\t\treturn this._isOccupied;\n\t}\n\n\tpublic makeExclusiveOrSkip<TArgs extends unknown[]>(fn: (...args: TArgs) => void): (...args: TArgs) => void {\n\t\treturn ((...args: TArgs) => {\n\t\t\tif (this._isOccupied) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._isOccupied = true;\n\t\t\ttry {\n\t\t\t\treturn fn(...args);\n\t\t\t} finally {\n\t\t\t\tthis._isOccupied = false;\n\t\t\t}\n\t\t});\n\t}\n}\n"]}