{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/prefixTree.ts","vs/base/common/prefixTree.ts"],"names":[],"mappings":"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","file":"prefixTree.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from './iterator.js';\n\nconst unset = Symbol('unset');\n\nexport interface IPrefixTreeNode<T> {\n\t/** Possible children of the node. */\n\tchildren?: ReadonlyMap<string, Node<T>>;\n\n\t/** The value if data exists for this node in the tree. Mutable. */\n\tvalue: T | undefined;\n}\n\n/**\n * A simple prefix tree implementation where a value is stored based on\n * well-defined prefix segments.\n */\nexport class WellDefinedPrefixTree<V> {\n\tpublic readonly root = new Node<V>();\n\tprivate _size = 0;\n\n\t/** Tree size, not including the root. */\n\tpublic get size() {\n\t\treturn this._size;\n\t}\n\n\t/** Gets the top-level nodes of the tree */\n\tpublic get nodes(): Iterable<IPrefixTreeNode<V>> {\n\t\treturn this.root.children?.values() || Iterable.empty();\n\t}\n\n\t/** Gets the top-level nodes of the tree */\n\tpublic get entries(): Iterable<[string, IPrefixTreeNode<V>]> {\n\t\treturn this.root.children?.entries() || Iterable.empty();\n\t}\n\n\t/**\n\t * Inserts a new value in the prefix tree.\n\t * @param onNode - called for each node as we descend to the insertion point,\n\t * including the insertion point itself.\n\t */\n\tinsert(key: Iterable<string>, value: V, onNode?: (n: IPrefixTreeNode<V>) => void): void {\n\t\tthis.opNode(key, n => n._value = value, onNode);\n\t}\n\n\t/** Mutates a value in the prefix tree. */\n\tmutate(key: Iterable<string>, mutate: (value?: V) => V): void {\n\t\tthis.opNode(key, n => n._value = mutate(n._value === unset ? undefined : n._value));\n\t}\n\n\t/** Mutates nodes along the path in the prefix tree. */\n\tmutatePath(key: Iterable<string>, mutate: (node: IPrefixTreeNode<V>) => void): void {\n\t\tthis.opNode(key, () => { }, n => mutate(n));\n\t}\n\n\t/** Deletes a node from the prefix tree, returning the value it contained. */\n\tdelete(key: Iterable<string>): V | undefined {\n\t\tconst path = this.getPathToKey(key);\n\t\tif (!path) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet i = path.length - 1;\n\t\tconst value = path[i].node._value;\n\t\tif (value === unset) {\n\t\t\treturn; // not actually a real node\n\t\t}\n\n\t\tthis._size--;\n\t\tpath[i].node._value = unset;\n\n\t\tfor (; i > 0; i--) {\n\t\t\tconst { node, part } = path[i];\n\t\t\tif (node.children?.size || node._value !== unset) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpath[i - 1].node.children!.delete(part);\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/** Deletes a subtree from the prefix tree, returning the values they contained. */\n\t*deleteRecursive(key: Iterable<string>): Iterable<V> {\n\t\tconst path = this.getPathToKey(key);\n\t\tif (!path) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst subtree = path[path.length - 1].node;\n\n\t\t// important: run the deletion before we start to yield results, so that\n\t\t// it still runs even if the caller doesn't consumer the iterator\n\t\tfor (let i = path.length - 1; i > 0; i--) {\n\t\t\tconst parent = path[i - 1];\n\t\t\tparent.node.children!.delete(path[i].part);\n\t\t\tif (parent.node.children!.size > 0 || parent.node._value !== unset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (const node of bfsIterate(subtree)) {\n\t\t\tif (node._value !== unset) {\n\t\t\t\tthis._size--;\n\t\t\t\tyield node._value;\n\t\t\t}\n\t\t}\n\n\t\t// special case for the root note\n\t\tif (subtree === this.root) {\n\t\t\tthis.root._value = unset;\n\t\t\tthis.root.children = undefined;\n\t\t}\n\t}\n\n\t/** Gets a value from the tree. */\n\tfind(key: Iterable<string>): V | undefined {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn node._value === unset ? undefined : node._value;\n\t}\n\n\t/** Gets whether the tree has the key, or a parent of the key, already inserted. */\n\thasKeyOrParent(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (next._value !== unset) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** Gets whether the tree has the given key or any children. */\n\thasKeyOrChildren(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Gets whether the tree has the given key. */\n\thasKey(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn node._value !== unset;\n\t}\n\n\tprivate getPathToKey(key: Iterable<string>) {\n\t\tconst path = [{ part: '', node: this.root }];\n\t\tlet i = 0;\n\t\tfor (const part of key) {\n\t\t\tconst node = path[i].node.children?.get(part);\n\t\t\tif (!node) {\n\t\t\t\treturn; // node not in tree\n\t\t\t}\n\n\t\t\tpath.push({ part, node });\n\t\t\ti++;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\tprivate opNode(key: Iterable<string>, fn: (node: Node<V>) => void, onDescend?: (node: Node<V>) => void): void {\n\t\tlet node = this.root;\n\t\tfor (const part of key) {\n\t\t\tif (!node.children) {\n\t\t\t\tconst next = new Node<V>();\n\t\t\t\tnode.children = new Map([[part, next]]);\n\t\t\t\tnode = next;\n\t\t\t} else if (!node.children.has(part)) {\n\t\t\t\tconst next = new Node<V>();\n\t\t\t\tnode.children.set(part, next);\n\t\t\t\tnode = next;\n\t\t\t} else {\n\t\t\t\tnode = node.children.get(part)!;\n\t\t\t}\n\t\t\tonDescend?.(node);\n\t\t}\n\n\t\tconst sizeBefore = node._value === unset ? 0 : 1;\n\t\tfn(node);\n\t\tconst sizeAfter = node._value === unset ? 0 : 1;\n\t\tthis._size += sizeAfter - sizeBefore;\n\t}\n\n\t/** Returns an iterable of the tree values in no defined order. */\n\t*values() {\n\t\tfor (const { _value } of bfsIterate(this.root)) {\n\t\t\tif (_value !== unset) {\n\t\t\t\tyield _value;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction* bfsIterate<T>(root: Node<T>): Iterable<Node<T>> {\n\tconst stack = [root];\n\twhile (stack.length > 0) {\n\t\tconst node = stack.pop()!;\n\t\tyield node;\n\n\t\tif (node.children) {\n\t\t\tfor (const child of node.children.values()) {\n\t\t\t\tstack.push(child);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Node<T> implements IPrefixTreeNode<T> {\n\tpublic children?: Map<string, Node<T>>;\n\n\tpublic get value() {\n\t\treturn this._value === unset ? undefined : this._value;\n\t}\n\n\tpublic set value(value: T | undefined) {\n\t\tthis._value = value === undefined ? unset : value;\n\t}\n\n\tpublic _value: T | typeof unset = unset;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from './iterator.js';\n\nconst unset = Symbol('unset');\n\nexport interface IPrefixTreeNode<T> {\n\t/** Possible children of the node. */\n\tchildren?: ReadonlyMap<string, Node<T>>;\n\n\t/** The value if data exists for this node in the tree. Mutable. */\n\tvalue: T | undefined;\n}\n\n/**\n * A simple prefix tree implementation where a value is stored based on\n * well-defined prefix segments.\n */\nexport class WellDefinedPrefixTree<V> {\n\tpublic readonly root = new Node<V>();\n\tprivate _size = 0;\n\n\t/** Tree size, not including the root. */\n\tpublic get size() {\n\t\treturn this._size;\n\t}\n\n\t/** Gets the top-level nodes of the tree */\n\tpublic get nodes(): Iterable<IPrefixTreeNode<V>> {\n\t\treturn this.root.children?.values() || Iterable.empty();\n\t}\n\n\t/** Gets the top-level nodes of the tree */\n\tpublic get entries(): Iterable<[string, IPrefixTreeNode<V>]> {\n\t\treturn this.root.children?.entries() || Iterable.empty();\n\t}\n\n\t/**\n\t * Inserts a new value in the prefix tree.\n\t * @param onNode - called for each node as we descend to the insertion point,\n\t * including the insertion point itself.\n\t */\n\tinsert(key: Iterable<string>, value: V, onNode?: (n: IPrefixTreeNode<V>) => void): void {\n\t\tthis.opNode(key, n => n._value = value, onNode);\n\t}\n\n\t/** Mutates a value in the prefix tree. */\n\tmutate(key: Iterable<string>, mutate: (value?: V) => V): void {\n\t\tthis.opNode(key, n => n._value = mutate(n._value === unset ? undefined : n._value));\n\t}\n\n\t/** Mutates nodes along the path in the prefix tree. */\n\tmutatePath(key: Iterable<string>, mutate: (node: IPrefixTreeNode<V>) => void): void {\n\t\tthis.opNode(key, () => { }, n => mutate(n));\n\t}\n\n\t/** Deletes a node from the prefix tree, returning the value it contained. */\n\tdelete(key: Iterable<string>): V | undefined {\n\t\tconst path = this.getPathToKey(key);\n\t\tif (!path) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet i = path.length - 1;\n\t\tconst value = path[i].node._value;\n\t\tif (value === unset) {\n\t\t\treturn; // not actually a real node\n\t\t}\n\n\t\tthis._size--;\n\t\tpath[i].node._value = unset;\n\n\t\tfor (; i > 0; i--) {\n\t\t\tconst { node, part } = path[i];\n\t\t\tif (node.children?.size || node._value !== unset) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpath[i - 1].node.children!.delete(part);\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/** Deletes a subtree from the prefix tree, returning the values they contained. */\n\t*deleteRecursive(key: Iterable<string>): Iterable<V> {\n\t\tconst path = this.getPathToKey(key);\n\t\tif (!path) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst subtree = path[path.length - 1].node;\n\n\t\t// important: run the deletion before we start to yield results, so that\n\t\t// it still runs even if the caller doesn't consumer the iterator\n\t\tfor (let i = path.length - 1; i > 0; i--) {\n\t\t\tconst parent = path[i - 1];\n\t\t\tparent.node.children!.delete(path[i].part);\n\t\t\tif (parent.node.children!.size > 0 || parent.node._value !== unset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (const node of bfsIterate(subtree)) {\n\t\t\tif (node._value !== unset) {\n\t\t\t\tthis._size--;\n\t\t\t\tyield node._value;\n\t\t\t}\n\t\t}\n\n\t\t// special case for the root note\n\t\tif (subtree === this.root) {\n\t\t\tthis.root._value = unset;\n\t\t\tthis.root.children = undefined;\n\t\t}\n\t}\n\n\t/** Gets a value from the tree. */\n\tfind(key: Iterable<string>): V | undefined {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn node._value === unset ? undefined : node._value;\n\t}\n\n\t/** Gets whether the tree has the key, or a parent of the key, already inserted. */\n\thasKeyOrParent(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (next._value !== unset) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** Gets whether the tree has the given key or any children. */\n\thasKeyOrChildren(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Gets whether the tree has the given key. */\n\thasKey(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn node._value !== unset;\n\t}\n\n\tprivate getPathToKey(key: Iterable<string>) {\n\t\tconst path = [{ part: '', node: this.root }];\n\t\tlet i = 0;\n\t\tfor (const part of key) {\n\t\t\tconst node = path[i].node.children?.get(part);\n\t\t\tif (!node) {\n\t\t\t\treturn; // node not in tree\n\t\t\t}\n\n\t\t\tpath.push({ part, node });\n\t\t\ti++;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\tprivate opNode(key: Iterable<string>, fn: (node: Node<V>) => void, onDescend?: (node: Node<V>) => void): void {\n\t\tlet node = this.root;\n\t\tfor (const part of key) {\n\t\t\tif (!node.children) {\n\t\t\t\tconst next = new Node<V>();\n\t\t\t\tnode.children = new Map([[part, next]]);\n\t\t\t\tnode = next;\n\t\t\t} else if (!node.children.has(part)) {\n\t\t\t\tconst next = new Node<V>();\n\t\t\t\tnode.children.set(part, next);\n\t\t\t\tnode = next;\n\t\t\t} else {\n\t\t\t\tnode = node.children.get(part)!;\n\t\t\t}\n\t\t\tonDescend?.(node);\n\t\t}\n\n\t\tconst sizeBefore = node._value === unset ? 0 : 1;\n\t\tfn(node);\n\t\tconst sizeAfter = node._value === unset ? 0 : 1;\n\t\tthis._size += sizeAfter - sizeBefore;\n\t}\n\n\t/** Returns an iterable of the tree values in no defined order. */\n\t*values() {\n\t\tfor (const { _value } of bfsIterate(this.root)) {\n\t\t\tif (_value !== unset) {\n\t\t\t\tyield _value;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction* bfsIterate<T>(root: Node<T>): Iterable<Node<T>> {\n\tconst stack = [root];\n\twhile (stack.length > 0) {\n\t\tconst node = stack.pop()!;\n\t\tyield node;\n\n\t\tif (node.children) {\n\t\t\tfor (const child of node.children.values()) {\n\t\t\t\tstack.push(child);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Node<T> implements IPrefixTreeNode<T> {\n\tpublic children?: Map<string, Node<T>>;\n\n\tpublic get value() {\n\t\treturn this._value === unset ? undefined : this._value;\n\t}\n\n\tpublic set value(value: T | undefined) {\n\t\tthis._value = value === undefined ? unset : value;\n\t}\n\n\tpublic _value: T | typeof unset = unset;\n}\n"]}