{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/observableInternal/utils/promise.ts","vs/base/common/observableInternal/utils/promise.ts"],"names":[],"mappings":"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","file":"promise.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IObservable } from '../base.js';\nimport { transaction } from '../transaction.js';\nimport { derived } from '../observables/derived.js';\nimport { observableValue } from '../observables/observableValue.js';\n\nexport class ObservableLazy<T> {\n\tprivate readonly _value = observableValue<T | undefined>(this, undefined);\n\n\t/**\n\t * The cached value.\n\t * Does not force a computation of the value.\n\t */\n\tpublic get cachedValue(): IObservable<T | undefined> { return this._value; }\n\n\tconstructor(private readonly _computeValue: () => T) {\n\t}\n\n\t/**\n\t * Returns the cached value.\n\t * Computes the value if the value has not been cached yet.\n\t */\n\tpublic getValue(): T {\n\t\tlet v = this._value.get();\n\t\tif (!v) {\n\t\t\tv = this._computeValue();\n\t\t\tthis._value.set(v, undefined);\n\t\t}\n\t\treturn v;\n\t}\n}\n\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise<T> {\n\tpublic static fromFn<T>(fn: () => Promise<T>): ObservablePromise<T> {\n\t\treturn new ObservablePromise(fn());\n\t}\n\n\tpublic static resolved<T>(value: T): ObservablePromise<T> {\n\t\treturn new ObservablePromise(Promise.resolve(value));\n\t}\n\n\tprivate readonly _value = observableValue<PromiseResult<T> | undefined>(this, undefined);\n\n\t/**\n\t * The promise that this object wraps.\n\t */\n\tpublic readonly promise: Promise<T>;\n\n\t/**\n\t * The current state of the promise.\n\t * Is `undefined` if the promise didn't resolve yet.\n\t */\n\tpublic readonly promiseResult: IObservable<PromiseResult<T> | undefined> = this._value;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(value => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseResolved */\n\t\t\t\tthis._value.set(new PromiseResult(value, undefined), tx);\n\t\t\t});\n\t\t\treturn value;\n\t\t}, error => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseRejected */\n\t\t\t\tthis._value.set(new PromiseResult<T>(undefined, error), tx);\n\t\t\t});\n\t\t\tthrow error;\n\t\t});\n\t}\n\n\tpublic readonly resolvedValue = derived(this, reader => {\n\t\tconst result = this.promiseResult.read(reader);\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn result.getDataOrThrow();\n\t});\n}\n\nexport class PromiseResult<T> {\n\tconstructor(\n\t\t/**\n\t\t * The value of the resolved promise.\n\t\t * Undefined if the promise rejected.\n\t\t */\n\t\tpublic readonly data: T | undefined,\n\n\t\t/**\n\t\t * The error in case of a rejected promise.\n\t\t * Undefined if the promise resolved.\n\t\t */\n\t\tpublic readonly error: unknown | undefined,\n\t) {\n\t}\n\n\t/**\n\t * Returns the value if the promise resolved, otherwise throws the error.\n\t */\n\tpublic getDataOrThrow(): T {\n\t\tif (this.error) {\n\t\t\tthrow this.error;\n\t\t}\n\t\treturn this.data!;\n\t}\n}\n\n/**\n * A lazy promise whose state is observable.\n */\nexport class ObservableLazyPromise<T> {\n\tprivate readonly _lazyValue = new ObservableLazy(() => new ObservablePromise(this._computePromise()));\n\n\t/**\n\t * Does not enforce evaluation of the promise compute function.\n\t * Is undefined if the promise has not been computed yet.\n\t */\n\tpublic readonly cachedPromiseResult = derived(this, reader => this._lazyValue.cachedValue.read(reader)?.promiseResult.read(reader));\n\n\tconstructor(private readonly _computePromise: () => Promise<T>) {\n\t}\n\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._lazyValue.getValue().promise;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IObservable } from '../base.js';\nimport { transaction } from '../transaction.js';\nimport { derived } from '../observables/derived.js';\nimport { observableValue } from '../observables/observableValue.js';\n\nexport class ObservableLazy<T> {\n\tprivate readonly _value = observableValue<T | undefined>(this, undefined);\n\n\t/**\n\t * The cached value.\n\t * Does not force a computation of the value.\n\t */\n\tpublic get cachedValue(): IObservable<T | undefined> { return this._value; }\n\n\tconstructor(private readonly _computeValue: () => T) {\n\t}\n\n\t/**\n\t * Returns the cached value.\n\t * Computes the value if the value has not been cached yet.\n\t */\n\tpublic getValue(): T {\n\t\tlet v = this._value.get();\n\t\tif (!v) {\n\t\t\tv = this._computeValue();\n\t\t\tthis._value.set(v, undefined);\n\t\t}\n\t\treturn v;\n\t}\n}\n\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise<T> {\n\tpublic static fromFn<T>(fn: () => Promise<T>): ObservablePromise<T> {\n\t\treturn new ObservablePromise(fn());\n\t}\n\n\tpublic static resolved<T>(value: T): ObservablePromise<T> {\n\t\treturn new ObservablePromise(Promise.resolve(value));\n\t}\n\n\tprivate readonly _value = observableValue<PromiseResult<T> | undefined>(this, undefined);\n\n\t/**\n\t * The promise that this object wraps.\n\t */\n\tpublic readonly promise: Promise<T>;\n\n\t/**\n\t * The current state of the promise.\n\t * Is `undefined` if the promise didn't resolve yet.\n\t */\n\tpublic readonly promiseResult: IObservable<PromiseResult<T> | undefined> = this._value;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(value => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseResolved */\n\t\t\t\tthis._value.set(new PromiseResult(value, undefined), tx);\n\t\t\t});\n\t\t\treturn value;\n\t\t}, error => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseRejected */\n\t\t\t\tthis._value.set(new PromiseResult<T>(undefined, error), tx);\n\t\t\t});\n\t\t\tthrow error;\n\t\t});\n\t}\n\n\tpublic readonly resolvedValue = derived(this, reader => {\n\t\tconst result = this.promiseResult.read(reader);\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn result.getDataOrThrow();\n\t});\n}\n\nexport class PromiseResult<T> {\n\tconstructor(\n\t\t/**\n\t\t * The value of the resolved promise.\n\t\t * Undefined if the promise rejected.\n\t\t */\n\t\tpublic readonly data: T | undefined,\n\n\t\t/**\n\t\t * The error in case of a rejected promise.\n\t\t * Undefined if the promise resolved.\n\t\t */\n\t\tpublic readonly error: unknown | undefined,\n\t) {\n\t}\n\n\t/**\n\t * Returns the value if the promise resolved, otherwise throws the error.\n\t */\n\tpublic getDataOrThrow(): T {\n\t\tif (this.error) {\n\t\t\tthrow this.error;\n\t\t}\n\t\treturn this.data!;\n\t}\n}\n\n/**\n * A lazy promise whose state is observable.\n */\nexport class ObservableLazyPromise<T> {\n\tprivate readonly _lazyValue = new ObservableLazy(() => new ObservablePromise(this._computePromise()));\n\n\t/**\n\t * Does not enforce evaluation of the promise compute function.\n\t * Is undefined if the promise has not been computed yet.\n\t */\n\tpublic readonly cachedPromiseResult = derived(this, reader => this._lazyValue.cachedValue.read(reader)?.promiseResult.read(reader));\n\n\tconstructor(private readonly _computePromise: () => Promise<T>) {\n\t}\n\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._lazyValue.getValue().promise;\n\t}\n}\n"]}