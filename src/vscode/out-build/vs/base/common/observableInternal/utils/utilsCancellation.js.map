{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/observableInternal/utils/utilsCancellation.ts","vs/base/common/observableInternal/utils/utilsCancellation.ts"],"names":[],"mappings":"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","file":"utilsCancellation.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IReader, IObservable } from '../base.js';\nimport { DebugOwner, DebugNameData } from '../debugName.js';\nimport { CancellationError, CancellationToken, CancellationTokenSource } from '../commonFacade/cancellation.js';\nimport { strictEquals } from '../commonFacade/deps.js';\nimport { autorun } from '../reactions/autorun.js';\nimport { Derived } from '../observables/derivedImpl.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Resolves the promise when the observables state matches the predicate.\n */\nexport function waitForState<T>(observable: IObservable<T | null | undefined>): Promise<T>;\nexport function waitForState<T, TState extends T>(observable: IObservable<T>, predicate: (state: T) => state is TState, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<TState>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<T>;\nexport function waitForState<T>(observable: IObservable<T>, predicate?: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<T> {\n\tif (!predicate) {\n\t\tpredicate = state => state !== null && state !== undefined;\n\t}\n\treturn new Promise((resolve, reject) => {\n\t\tlet isImmediateRun = true;\n\t\tlet shouldDispose = false;\n\t\tconst stateObs = observable.map(state => {\n\t\t\t/** @description waitForState.state */\n\t\t\treturn {\n\t\t\t\tisFinished: predicate(state),\n\t\t\t\terror: isError ? isError(state) : false,\n\t\t\t\tstate\n\t\t\t};\n\t\t});\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description waitForState */\n\t\t\tconst { isFinished, error, state } = stateObs.read(reader);\n\t\t\tif (isFinished || error) {\n\t\t\t\tif (isImmediateRun) {\n\t\t\t\t\t// The variable `d` is not initialized yet\n\t\t\t\t\tshouldDispose = true;\n\t\t\t\t} else {\n\t\t\t\t\td.dispose();\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error === true ? state : error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(state);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (cancellationToken) {\n\t\t\tconst dc = cancellationToken.onCancellationRequested(() => {\n\t\t\t\td.dispose();\n\t\t\t\tdc.dispose();\n\t\t\t\treject(new CancellationError());\n\t\t\t});\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\td.dispose();\n\t\t\t\tdc.dispose();\n\t\t\t\treject(new CancellationError());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tisImmediateRun = false;\n\t\tif (shouldDispose) {\n\t\t\td.dispose();\n\t\t}\n\t});\n}\n\nexport function derivedWithCancellationToken<T>(computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(owner: object, computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(computeFnOrOwner: ((reader: IReader, cancellationToken: CancellationToken) => T) | object, computeFnOrUndefined?: ((reader: IReader, cancellationToken: CancellationToken) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: CancellationToken) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet cancellationTokenSource: CancellationTokenSource | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (cancellationTokenSource) {\n\t\t\t\tcancellationTokenSource.dispose(true);\n\t\t\t}\n\t\t\tcancellationTokenSource = new CancellationTokenSource();\n\t\t\treturn computeFn(r, cancellationTokenSource.token);\n\t\t}, undefined,\n\t\t() => cancellationTokenSource?.dispose(),\n\t\tstrictEquals,\n\t\tDebugLocation.ofCaller()\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IReader, IObservable } from '../base.js';\nimport { DebugOwner, DebugNameData } from '../debugName.js';\nimport { CancellationError, CancellationToken, CancellationTokenSource } from '../commonFacade/cancellation.js';\nimport { strictEquals } from '../commonFacade/deps.js';\nimport { autorun } from '../reactions/autorun.js';\nimport { Derived } from '../observables/derivedImpl.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Resolves the promise when the observables state matches the predicate.\n */\nexport function waitForState<T>(observable: IObservable<T | null | undefined>): Promise<T>;\nexport function waitForState<T, TState extends T>(observable: IObservable<T>, predicate: (state: T) => state is TState, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<TState>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<T>;\nexport function waitForState<T>(observable: IObservable<T>, predicate?: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<T> {\n\tif (!predicate) {\n\t\tpredicate = state => state !== null && state !== undefined;\n\t}\n\treturn new Promise((resolve, reject) => {\n\t\tlet isImmediateRun = true;\n\t\tlet shouldDispose = false;\n\t\tconst stateObs = observable.map(state => {\n\t\t\t/** @description waitForState.state */\n\t\t\treturn {\n\t\t\t\tisFinished: predicate(state),\n\t\t\t\terror: isError ? isError(state) : false,\n\t\t\t\tstate\n\t\t\t};\n\t\t});\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description waitForState */\n\t\t\tconst { isFinished, error, state } = stateObs.read(reader);\n\t\t\tif (isFinished || error) {\n\t\t\t\tif (isImmediateRun) {\n\t\t\t\t\t// The variable `d` is not initialized yet\n\t\t\t\t\tshouldDispose = true;\n\t\t\t\t} else {\n\t\t\t\t\td.dispose();\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error === true ? state : error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(state);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (cancellationToken) {\n\t\t\tconst dc = cancellationToken.onCancellationRequested(() => {\n\t\t\t\td.dispose();\n\t\t\t\tdc.dispose();\n\t\t\t\treject(new CancellationError());\n\t\t\t});\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\td.dispose();\n\t\t\t\tdc.dispose();\n\t\t\t\treject(new CancellationError());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tisImmediateRun = false;\n\t\tif (shouldDispose) {\n\t\t\td.dispose();\n\t\t}\n\t});\n}\n\nexport function derivedWithCancellationToken<T>(computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(owner: object, computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(computeFnOrOwner: ((reader: IReader, cancellationToken: CancellationToken) => T) | object, computeFnOrUndefined?: ((reader: IReader, cancellationToken: CancellationToken) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: CancellationToken) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet cancellationTokenSource: CancellationTokenSource | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (cancellationTokenSource) {\n\t\t\t\tcancellationTokenSource.dispose(true);\n\t\t\t}\n\t\t\tcancellationTokenSource = new CancellationTokenSource();\n\t\t\treturn computeFn(r, cancellationTokenSource.token);\n\t\t}, undefined,\n\t\t() => cancellationTokenSource?.dispose(),\n\t\tstrictEquals,\n\t\tDebugLocation.ofCaller()\n\t);\n}\n"]}