{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/observableInternal/experimental/utils.ts","vs/base/common/observableInternal/experimental/utils.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAGhG,OAAO,EAAE,kBAAkB,EAAE,eAAe,EAAE,MAAM,yBAAyB,CAAC;AAC9E,OAAO,EAAc,YAAY,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAC1E,OAAO,EAAE,mBAAmB,EAAE,MAAM,uCAAuC,CAAC;AAC5E,OAAO,EAAE,WAAW,EAAE,MAAM,yBAAyB,CAAC;AACtD,OAAO,EAAE,0BAA0B,EAAE,MAAM,mBAAmB,CAAC;AAE/D;;;;;EAKE;AACF,MAAM,UAAU,kBAAkB,CAA+B,KAAiB,EAAE,WAAc;IACjG,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAC9B,MAAM,IAAI,kBAAkB,EAAE,CAAC;IAChC,CAAC;IAED,IAAI,mBAAmB,GAAG,KAAK,CAAC;IAChC,IAAI,gBAAgB,GAAY,SAAS,CAAC;IAE1C,MAAM,MAAM,GAAG,mBAAmB,CAAY,KAAK,EAAE,EAAE,CAAC,EAAE;QACzD,MAAM,KAAK,GAAG,IAAI,eAAe,EAAE,CAAC;QACpC,KAAK,MAAM,CAAC,IAAI,WAAW,EAAE,CAAC;YAC7B,KAAK,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,SAAS,EAAE,GAAG,EAAE,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,aAAa,CAAC,KAAK,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC,GAAG,yBAAyB,EAAE,EAAE,MAAM,CAAC,EAAE;gBACrJ,mBAAmB,GAAG,IAAI,CAAC;gBAC3B,gBAAgB,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAClC,EAAE,EAAE,CAAC;YACN,CAAC,CAAC,CAAC,CAAC;QACL,CAAC;QACD,KAAK,CAAC,GAAG,CAAC;YACT,OAAO;gBACN,mBAAmB,GAAG,KAAK,CAAC;gBAC5B,gBAAgB,GAAG,SAAS,CAAC;YAC9B,CAAC;SACD,CAAC,CAAC;QACH,OAAO,KAAK,CAAC;IACd,CAAC,EAAE,GAAG,EAAE;QACP,IAAI,mBAAmB,EAAE,CAAC;YACzB,OAAO,gBAAgB,CAAC;QACzB,CAAC;aAAM,CAAC;YACP,OAAO,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;QAClD,CAAC;IACF,CAAC,CAAC,CAAC;IACH,OAAO,MAAM,CAAC;AACf,CAAC;AAED;;;;EAIE;AACF,MAAM,UAAU,uBAAuB,CAAI,KAAiB,EAAE,EAA0B;IACvF,OAAO,0BAA0B,CAAgB,KAAK,EAAE,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,CAAC,SAAS,IAAI,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;AACzG,CAAC","file":"utils.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IReader } from '../base.js';\nimport { BugIndicatingError, DisposableStore } from '../commonFacade/deps.js';\nimport { DebugOwner, getDebugName, DebugNameData } from '../debugName.js';\nimport { observableFromEvent } from '../observables/observableFromEvent.js';\nimport { autorunOpts } from '../reactions/autorun.js';\nimport { derivedObservableWithCache } from '../utils/utils.js';\n\n/**\n * Creates an observable that has the latest changed value of the given observables.\n * Initially (and when not observed), it has the value of the last observable.\n * When observed and any of the observables change, it has the value of the last changed observable.\n * If multiple observables change in the same transaction, the last observable wins.\n*/\nexport function latestChangedValue<T extends IObservable<any>[]>(owner: DebugOwner, observables: T): IObservable<ReturnType<T[number]['get']>> {\n\tif (observables.length === 0) {\n\t\tthrow new BugIndicatingError();\n\t}\n\n\tlet hasLastChangedValue = false;\n\tlet lastChangedValue: unknown = undefined;\n\n\tconst result = observableFromEvent<any, void>(owner, cb => {\n\t\tconst store = new DisposableStore();\n\t\tfor (const o of observables) {\n\t\t\tstore.add(autorunOpts({ debugName: () => getDebugName(result, new DebugNameData(owner, undefined, undefined)) + '.updateLastChangedValue' }, reader => {\n\t\t\t\thasLastChangedValue = true;\n\t\t\t\tlastChangedValue = o.read(reader);\n\t\t\t\tcb();\n\t\t\t}));\n\t\t}\n\t\tstore.add({\n\t\t\tdispose() {\n\t\t\t\thasLastChangedValue = false;\n\t\t\t\tlastChangedValue = undefined;\n\t\t\t},\n\t\t});\n\t\treturn store;\n\t}, () => {\n\t\tif (hasLastChangedValue) {\n\t\t\treturn lastChangedValue;\n\t\t} else {\n\t\t\treturn observables[observables.length - 1].get();\n\t\t}\n\t});\n\treturn result;\n}\n\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined<T>(owner: DebugOwner, fn: (reader: IReader) => T): IObservable<T | undefined> {\n\treturn derivedObservableWithCache<T | undefined>(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IReader } from '../base.js';\nimport { BugIndicatingError, DisposableStore } from '../commonFacade/deps.js';\nimport { DebugOwner, getDebugName, DebugNameData } from '../debugName.js';\nimport { observableFromEvent } from '../observables/observableFromEvent.js';\nimport { autorunOpts } from '../reactions/autorun.js';\nimport { derivedObservableWithCache } from '../utils/utils.js';\n\n/**\n * Creates an observable that has the latest changed value of the given observables.\n * Initially (and when not observed), it has the value of the last observable.\n * When observed and any of the observables change, it has the value of the last changed observable.\n * If multiple observables change in the same transaction, the last observable wins.\n*/\nexport function latestChangedValue<T extends IObservable<any>[]>(owner: DebugOwner, observables: T): IObservable<ReturnType<T[number]['get']>> {\n\tif (observables.length === 0) {\n\t\tthrow new BugIndicatingError();\n\t}\n\n\tlet hasLastChangedValue = false;\n\tlet lastChangedValue: unknown = undefined;\n\n\tconst result = observableFromEvent<any, void>(owner, cb => {\n\t\tconst store = new DisposableStore();\n\t\tfor (const o of observables) {\n\t\t\tstore.add(autorunOpts({ debugName: () => getDebugName(result, new DebugNameData(owner, undefined, undefined)) + '.updateLastChangedValue' }, reader => {\n\t\t\t\thasLastChangedValue = true;\n\t\t\t\tlastChangedValue = o.read(reader);\n\t\t\t\tcb();\n\t\t\t}));\n\t\t}\n\t\tstore.add({\n\t\t\tdispose() {\n\t\t\t\thasLastChangedValue = false;\n\t\t\t\tlastChangedValue = undefined;\n\t\t\t},\n\t\t});\n\t\treturn store;\n\t}, () => {\n\t\tif (hasLastChangedValue) {\n\t\t\treturn lastChangedValue;\n\t\t} else {\n\t\t\treturn observables[observables.length - 1].get();\n\t\t}\n\t});\n\treturn result;\n}\n\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined<T>(owner: DebugOwner, fn: (reader: IReader) => T): IObservable<T | undefined> {\n\treturn derivedObservableWithCache<T | undefined>(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n"]}