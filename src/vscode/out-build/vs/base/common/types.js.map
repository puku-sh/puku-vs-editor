{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/types.ts","vs/base/common/types.ts"],"names":[],"mappings":"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","file":"types.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from './assert.js';\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: unknown): str is string {\n\treturn (typeof str === 'string');\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: unknown): value is string[] {\n\treturn isArrayOf(value, isString);\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array satisfies the provided type guard.\n */\nexport function isArrayOf<T>(value: unknown, check: (item: unknown) => item is T): value is T[] {\n\treturn Array.isArray(value) && value.every(check);\n}\n\n/**\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: unknown): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === 'object'\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\n */\nexport function isTypedArray(obj: unknown): obj is Object {\n\tconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\treturn typeof obj === 'object'\n\t\t&& obj instanceof TypedArray;\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: unknown): obj is number {\n\treturn (typeof obj === 'number' && !isNaN(obj));\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isIterable<T>(obj: unknown): obj is Iterable<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!obj && typeof (obj as any)[Symbol.iterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isAsyncIterable<T>(obj: unknown): obj is AsyncIterable<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!obj && typeof (obj as any)[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: unknown): obj is boolean {\n\treturn (obj === true || obj === false);\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: unknown): obj is undefined {\n\treturn (typeof obj === 'undefined');\n}\n\n/**\n * @returns whether the provided parameter is defined.\n */\nexport function isDefined<T>(arg: T | null | undefined): arg is T {\n\treturn !isUndefinedOrNull(arg);\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: unknown): obj is undefined | null {\n\treturn (isUndefined(obj) || obj === null);\n}\n\n\nexport function assertType(condition: unknown, type?: string): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\n\t}\n}\n\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n *\n * @see {@link assertDefined} for a similar utility that leverages TS assertion functions to narrow down the type of `arg` to be non-nullable.\n */\nexport function assertReturnsDefined<T>(arg: T | null | undefined): NonNullable<T> {\n\tassert(\n\t\targ !== null && arg !== undefined,\n\t\t'Argument is `undefined` or `null`.',\n\t);\n\n\treturn arg;\n}\n\n/**\n * Asserts that a provided `value` is `defined` - not `null` or `undefined`,\n * throwing an error with the provided error or error message, while also\n * narrowing down the type of the `value` to be `NonNullable` using TS\n * assertion functions.\n *\n * @throws if the provided `value` is `null` or `undefined`.\n *\n * ## Examples\n *\n * ```typescript\n * // an assert with an error message\n * assertDefined('some value', 'String constant is not defined o_O.');\n *\n * // `throws!` the provided error\n * assertDefined(null, new Error('Should throw this error.'));\n *\n * // narrows down the type of `someValue` to be non-nullable\n * const someValue: string | undefined | null = blackbox();\n * assertDefined(someValue, 'Some value must be defined.');\n * console.log(someValue.length); // now type of `someValue` is `string`\n * ```\n *\n * @see {@link assertReturnsDefined} for a similar utility but without assertion.\n * @see {@link https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions typescript-3-7.html#assertion-functions}\n */\nexport function assertDefined<T>(value: T, error: string | NonNullable<Error>): asserts value is NonNullable<T> {\n\tif (value === null || value === undefined) {\n\t\tconst errorToThrow = typeof error === 'string' ? new Error(error) : error;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Asserts that each argument passed in is neither undefined nor null.\n */\nexport function assertReturnsAllDefined<T1, T2>(t1: T1 | null | undefined, t2: T2 | null | undefined): [T1, T2];\nexport function assertReturnsAllDefined<T1, T2, T3>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined): [T1, T2, T3];\nexport function assertReturnsAllDefined<T1, T2, T3, T4>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined, t4: T4 | null | undefined): [T1, T2, T3, T4];\nexport function assertReturnsAllDefined(...args: (unknown | null | undefined)[]): unknown[] {\n\tconst result = [];\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tconst arg = args[i];\n\n\t\tif (isUndefinedOrNull(arg)) {\n\t\t\tthrow new Error(`Assertion Failed: argument at index ${i} is undefined or null`);\n\t\t}\n\n\t\tresult.push(arg);\n\t}\n\n\treturn result;\n}\n\n/**\n * Checks if the provided value is one of the vales in the provided list.\n *\n * ## Examples\n *\n * ```typescript\n * // note! item type is a `subset of string`\n * type TItem = ':' | '.' | '/';\n *\n * // note! item is type of `string` here\n * const item: string = ':';\n * // list of the items to check against\n * const list: TItem[] = [':', '.'];\n *\n * // ok\n * assert(\n *   isOneOf(item, list),\n *   'Must succeed.',\n * );\n *\n * // `item` is of `TItem` type now\n * ```\n */\nexport const isOneOf = <TType, TSubtype extends TType>(\n\tvalue: TType,\n\tvalidValues: readonly TSubtype[],\n): value is TSubtype => {\n\t// note! it is OK to type cast here, because we rely on the includes\n\t//       utility to check if the value is present in the provided list\n\treturn validValues.includes(<TSubtype>value);\n};\n\n/**\n * Compile-time type check of a variable.\n */\nexport function typeCheck<T = never>(_thing: NoInfer<T>): void { }\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: unknown): obj is object {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (const key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: unknown): obj is Function {\n\treturn (typeof obj === 'function');\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: unknown[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: unknown[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: unknown, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tif (!isUndefinedOrNull(arg) && (arg as any).constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\n/**\n * Helper type assertion that safely upcasts a type to a supertype.\n *\n * This can be used to make sure the argument correctly conforms to the subtype while still being able to pass it\n * to contexts that expects the supertype.\n */\nexport function upcast<Base, Sub extends Base = Base>(x: Sub): Base {\n\treturn x;\n}\n\ntype AddFirstParameterToFunction<T, TargetFunctionsReturnType, FirstParameter> = T extends (...args: any[]) => TargetFunctionsReturnType ?\n\t// Function: add param to function\n\t(firstArg: FirstParameter, ...args: Parameters<T>) => ReturnType<T> :\n\n\t// Else: just leave as is\n\tT;\n\n/**\n * Allows to add a first parameter to functions of a type.\n */\nexport type AddFirstParameterToFunctions<Target, TargetFunctionsReturnType, FirstParameter> = {\n\t// For every property\n\t[K in keyof Target]: AddFirstParameterToFunction<Target[K], TargetFunctionsReturnType, FirstParameter>;\n};\n\n/**\n * Given an object with all optional properties, requires at least one to be defined.\n * i.e. AtLeastOne<MyObject>;\n */\nexport type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U];\n\n/**\n * Only picks the non-optional properties of a type.\n */\nexport type OmitOptional<T> = { [K in keyof T as T[K] extends Required<T>[K] ? K : never]: T[K] };\n\n/**\n * A type that removed readonly-less from all properties of `T`\n */\nexport type Mutable<T> = {\n\t-readonly [P in keyof T]: T[P]\n};\n\n/**\n * A type that adds readonly to all properties of T, recursively.\n */\nexport type DeepImmutable<T> = T extends (infer U)[]\n\t? ReadonlyArray<DeepImmutable<U>>\n\t: T extends ReadonlyArray<infer U>\n\t? ReadonlyArray<DeepImmutable<U>>\n\t: T extends Map<infer K, infer V>\n\t? ReadonlyMap<K, DeepImmutable<V>>\n\t: T extends Set<infer U>\n\t? ReadonlySet<DeepImmutable<U>>\n\t: T extends object\n\t? {\n\t\treadonly [K in keyof T]: DeepImmutable<T[K]>;\n\t}\n\t: T;\n\n/**\n * A single object or an array of the objects.\n */\nexport type SingleOrMany<T> = T | T[];\n\n/**\n * Given a `type X = { foo?: string }` checking that an object `satisfies X`\n * will ensure each property was explicitly defined, ensuring no properties\n * are omitted or forgotten.\n */\nexport type WithDefinedProps<T> = { [K in keyof Required<T>]: T[K] };\n\n\n/**\n * A type that recursively makes all properties of `T` required\n */\nexport type DeepRequiredNonNullable<T> = {\n\t[P in keyof T]-?: T[P] extends object ? DeepRequiredNonNullable<T[P]> : Required<NonNullable<T[P]>>;\n};\n\n\n/**\n * Represents a type that is a partial version of a given type `T`, where all properties are optional and can be deeply nested.\n */\nexport type DeepPartial<T> = {\n\t[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : Partial<T[P]>;\n};\n\n/**\n * Represents a type that is a partial version of a given type `T`, except a subset.\n */\nexport type PartialExcept<T, K extends keyof T> = Partial<Omit<T, K>> & Pick<T, K>;\n\n\ntype KeysOfUnionType<T> = T extends T ? keyof T : never;\ntype FilterType<T, TTest> = T extends TTest ? T : never;\ntype MakeOptionalAndTrue<T extends object> = { [K in keyof T]?: true };\n\n/**\n * Type guard that checks if an object has specific keys and narrows the type accordingly.\n *\n * @param x - The object to check\n * @param key - An object with boolean values indicating which keys to check for\n * @returns true if all specified keys exist in the object, false otherwise\n *\n * @example\n * ```typescript\n * type A = { a: string };\n * type B = { b: number };\n * const obj: A | B = getObject();\n *\n * if (hasKey(obj, { a: true })) {\n *   // obj is now narrowed to type A\n *   console.log(obj.a);\n * }\n * ```\n */\nexport function hasKey<T extends object, TKeys extends MakeOptionalAndTrue<T>>(x: T, key: TKeys): x is FilterType<T, { [K in KeysOfUnionType<T> & keyof TKeys]: unknown }> {\n\tfor (const k in key) {\n\t\tif (!(k in x)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from './assert.js';\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: unknown): str is string {\n\treturn (typeof str === 'string');\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: unknown): value is string[] {\n\treturn isArrayOf(value, isString);\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array satisfies the provided type guard.\n */\nexport function isArrayOf<T>(value: unknown, check: (item: unknown) => item is T): value is T[] {\n\treturn Array.isArray(value) && value.every(check);\n}\n\n/**\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: unknown): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === 'object'\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\n */\nexport function isTypedArray(obj: unknown): obj is Object {\n\tconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\treturn typeof obj === 'object'\n\t\t&& obj instanceof TypedArray;\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: unknown): obj is number {\n\treturn (typeof obj === 'number' && !isNaN(obj));\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isIterable<T>(obj: unknown): obj is Iterable<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!obj && typeof (obj as any)[Symbol.iterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isAsyncIterable<T>(obj: unknown): obj is AsyncIterable<T> {\n\t// eslint-disable-next-line local/code-no-any-casts\n\treturn !!obj && typeof (obj as any)[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: unknown): obj is boolean {\n\treturn (obj === true || obj === false);\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: unknown): obj is undefined {\n\treturn (typeof obj === 'undefined');\n}\n\n/**\n * @returns whether the provided parameter is defined.\n */\nexport function isDefined<T>(arg: T | null | undefined): arg is T {\n\treturn !isUndefinedOrNull(arg);\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: unknown): obj is undefined | null {\n\treturn (isUndefined(obj) || obj === null);\n}\n\n\nexport function assertType(condition: unknown, type?: string): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\n\t}\n}\n\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n *\n * @see {@link assertDefined} for a similar utility that leverages TS assertion functions to narrow down the type of `arg` to be non-nullable.\n */\nexport function assertReturnsDefined<T>(arg: T | null | undefined): NonNullable<T> {\n\tassert(\n\t\targ !== null && arg !== undefined,\n\t\t'Argument is `undefined` or `null`.',\n\t);\n\n\treturn arg;\n}\n\n/**\n * Asserts that a provided `value` is `defined` - not `null` or `undefined`,\n * throwing an error with the provided error or error message, while also\n * narrowing down the type of the `value` to be `NonNullable` using TS\n * assertion functions.\n *\n * @throws if the provided `value` is `null` or `undefined`.\n *\n * ## Examples\n *\n * ```typescript\n * // an assert with an error message\n * assertDefined('some value', 'String constant is not defined o_O.');\n *\n * // `throws!` the provided error\n * assertDefined(null, new Error('Should throw this error.'));\n *\n * // narrows down the type of `someValue` to be non-nullable\n * const someValue: string | undefined | null = blackbox();\n * assertDefined(someValue, 'Some value must be defined.');\n * console.log(someValue.length); // now type of `someValue` is `string`\n * ```\n *\n * @see {@link assertReturnsDefined} for a similar utility but without assertion.\n * @see {@link https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions typescript-3-7.html#assertion-functions}\n */\nexport function assertDefined<T>(value: T, error: string | NonNullable<Error>): asserts value is NonNullable<T> {\n\tif (value === null || value === undefined) {\n\t\tconst errorToThrow = typeof error === 'string' ? new Error(error) : error;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Asserts that each argument passed in is neither undefined nor null.\n */\nexport function assertReturnsAllDefined<T1, T2>(t1: T1 | null | undefined, t2: T2 | null | undefined): [T1, T2];\nexport function assertReturnsAllDefined<T1, T2, T3>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined): [T1, T2, T3];\nexport function assertReturnsAllDefined<T1, T2, T3, T4>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined, t4: T4 | null | undefined): [T1, T2, T3, T4];\nexport function assertReturnsAllDefined(...args: (unknown | null | undefined)[]): unknown[] {\n\tconst result = [];\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tconst arg = args[i];\n\n\t\tif (isUndefinedOrNull(arg)) {\n\t\t\tthrow new Error(`Assertion Failed: argument at index ${i} is undefined or null`);\n\t\t}\n\n\t\tresult.push(arg);\n\t}\n\n\treturn result;\n}\n\n/**\n * Checks if the provided value is one of the vales in the provided list.\n *\n * ## Examples\n *\n * ```typescript\n * // note! item type is a `subset of string`\n * type TItem = ':' | '.' | '/';\n *\n * // note! item is type of `string` here\n * const item: string = ':';\n * // list of the items to check against\n * const list: TItem[] = [':', '.'];\n *\n * // ok\n * assert(\n *   isOneOf(item, list),\n *   'Must succeed.',\n * );\n *\n * // `item` is of `TItem` type now\n * ```\n */\nexport const isOneOf = <TType, TSubtype extends TType>(\n\tvalue: TType,\n\tvalidValues: readonly TSubtype[],\n): value is TSubtype => {\n\t// note! it is OK to type cast here, because we rely on the includes\n\t//       utility to check if the value is present in the provided list\n\treturn validValues.includes(<TSubtype>value);\n};\n\n/**\n * Compile-time type check of a variable.\n */\nexport function typeCheck<T = never>(_thing: NoInfer<T>): void { }\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: unknown): obj is object {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (const key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: unknown): obj is Function {\n\treturn (typeof obj === 'function');\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: unknown[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: unknown[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: unknown, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\tif (!isUndefinedOrNull(arg) && (arg as any).constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\n/**\n * Helper type assertion that safely upcasts a type to a supertype.\n *\n * This can be used to make sure the argument correctly conforms to the subtype while still being able to pass it\n * to contexts that expects the supertype.\n */\nexport function upcast<Base, Sub extends Base = Base>(x: Sub): Base {\n\treturn x;\n}\n\ntype AddFirstParameterToFunction<T, TargetFunctionsReturnType, FirstParameter> = T extends (...args: any[]) => TargetFunctionsReturnType ?\n\t// Function: add param to function\n\t(firstArg: FirstParameter, ...args: Parameters<T>) => ReturnType<T> :\n\n\t// Else: just leave as is\n\tT;\n\n/**\n * Allows to add a first parameter to functions of a type.\n */\nexport type AddFirstParameterToFunctions<Target, TargetFunctionsReturnType, FirstParameter> = {\n\t// For every property\n\t[K in keyof Target]: AddFirstParameterToFunction<Target[K], TargetFunctionsReturnType, FirstParameter>;\n};\n\n/**\n * Given an object with all optional properties, requires at least one to be defined.\n * i.e. AtLeastOne<MyObject>;\n */\nexport type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U];\n\n/**\n * Only picks the non-optional properties of a type.\n */\nexport type OmitOptional<T> = { [K in keyof T as T[K] extends Required<T>[K] ? K : never]: T[K] };\n\n/**\n * A type that removed readonly-less from all properties of `T`\n */\nexport type Mutable<T> = {\n\t-readonly [P in keyof T]: T[P]\n};\n\n/**\n * A type that adds readonly to all properties of T, recursively.\n */\nexport type DeepImmutable<T> = T extends (infer U)[]\n\t? ReadonlyArray<DeepImmutable<U>>\n\t: T extends ReadonlyArray<infer U>\n\t? ReadonlyArray<DeepImmutable<U>>\n\t: T extends Map<infer K, infer V>\n\t? ReadonlyMap<K, DeepImmutable<V>>\n\t: T extends Set<infer U>\n\t? ReadonlySet<DeepImmutable<U>>\n\t: T extends object\n\t? {\n\t\treadonly [K in keyof T]: DeepImmutable<T[K]>;\n\t}\n\t: T;\n\n/**\n * A single object or an array of the objects.\n */\nexport type SingleOrMany<T> = T | T[];\n\n/**\n * Given a `type X = { foo?: string }` checking that an object `satisfies X`\n * will ensure each property was explicitly defined, ensuring no properties\n * are omitted or forgotten.\n */\nexport type WithDefinedProps<T> = { [K in keyof Required<T>]: T[K] };\n\n\n/**\n * A type that recursively makes all properties of `T` required\n */\nexport type DeepRequiredNonNullable<T> = {\n\t[P in keyof T]-?: T[P] extends object ? DeepRequiredNonNullable<T[P]> : Required<NonNullable<T[P]>>;\n};\n\n\n/**\n * Represents a type that is a partial version of a given type `T`, where all properties are optional and can be deeply nested.\n */\nexport type DeepPartial<T> = {\n\t[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : Partial<T[P]>;\n};\n\n/**\n * Represents a type that is a partial version of a given type `T`, except a subset.\n */\nexport type PartialExcept<T, K extends keyof T> = Partial<Omit<T, K>> & Pick<T, K>;\n\n\ntype KeysOfUnionType<T> = T extends T ? keyof T : never;\ntype FilterType<T, TTest> = T extends TTest ? T : never;\ntype MakeOptionalAndTrue<T extends object> = { [K in keyof T]?: true };\n\n/**\n * Type guard that checks if an object has specific keys and narrows the type accordingly.\n *\n * @param x - The object to check\n * @param key - An object with boolean values indicating which keys to check for\n * @returns true if all specified keys exist in the object, false otherwise\n *\n * @example\n * ```typescript\n * type A = { a: string };\n * type B = { b: number };\n * const obj: A | B = getObject();\n *\n * if (hasKey(obj, { a: true })) {\n *   // obj is now narrowed to type A\n *   console.log(obj.a);\n * }\n * ```\n */\nexport function hasKey<T extends object, TKeys extends MakeOptionalAndTrue<T>>(x: T, key: TKeys): x is FilterType<T, { [K in KeysOfUnionType<T> & keyof TKeys]: unknown }> {\n\tfor (const k in key) {\n\t\tif (!(k in x)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n"]}