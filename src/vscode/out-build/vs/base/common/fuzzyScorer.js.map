{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/fuzzyScorer.ts","vs/base/common/fuzzyScorer.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAGhG,OAAO,EAAE,eAAe,EAAE,MAAM,gBAAgB,CAAC;AACjD,OAAO,EAAE,aAAa,IAAI,kBAAkB,EAAE,UAAU,EAAU,OAAO,EAAE,aAAa,EAAE,MAAM,cAAc,CAAC;AAC/G,OAAO,EAAE,IAAI,EAAE,MAAM,WAAW,CAAC;AACjC,OAAO,EAAE,GAAG,EAAE,MAAM,WAAW,CAAC;AAChC,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AACnD,OAAO,EAAE,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAOhD,MAAM,QAAQ,GAAG,CAAC,CAAC;AACnB,MAAM,QAAQ,GAAe,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;AAE5C,sBAAsB;AACtB,8BAA8B;AAE9B,MAAM,UAAU,UAAU,CAAC,MAAc,EAAE,KAAa,EAAE,UAAkB,EAAE,yBAAkC;IAC/G,IAAI,CAAC,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;QACvB,OAAO,QAAQ,CAAC,CAAC,gDAAgD;IAClE,CAAC;IAED,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC;IACnC,MAAM,WAAW,GAAG,KAAK,CAAC,MAAM,CAAC;IAEjC,IAAI,YAAY,GAAG,WAAW,EAAE,CAAC;QAChC,OAAO,QAAQ,CAAC,CAAC,iDAAiD;IACnE,CAAC;IAED,eAAe;IACf,wDAAwD;IACxD,IAAI;IAEJ,MAAM,WAAW,GAAG,MAAM,CAAC,WAAW,EAAE,CAAC;IACzC,MAAM,GAAG,GAAG,YAAY,CAAC,KAAK,EAAE,UAAU,EAAE,WAAW,EAAE,MAAM,EAAE,WAAW,EAAE,YAAY,EAAE,yBAAyB,CAAC,CAAC;IAEvH,eAAe;IACf,iEAAiE;IACjE,uBAAuB;IACvB,IAAI;IAEJ,OAAO,GAAG,CAAC;AACZ,CAAC;AAED,SAAS,YAAY,CAAC,KAAa,EAAE,UAAkB,EAAE,WAAmB,EAAE,MAAc,EAAE,WAAmB,EAAE,YAAoB,EAAE,yBAAkC;IAC1K,MAAM,MAAM,GAAa,EAAE,CAAC;IAC5B,MAAM,OAAO,GAAa,EAAE,CAAC;IAE7B,EAAE;IACF,uBAAuB;IACvB,EAAE;IACF,0EAA0E;IAC1E,2EAA2E;IAC3E,6EAA6E;IAC7E,uEAAuE;IACvE,EAAE;IACF,6BAA6B;IAC7B,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,EAAE;IACF,KAAK,IAAI,UAAU,GAAG,CAAC,EAAE,UAAU,GAAG,WAAW,EAAE,UAAU,EAAE,EAAE,CAAC;QACjE,MAAM,gBAAgB,GAAG,UAAU,GAAG,YAAY,CAAC;QACnD,MAAM,wBAAwB,GAAG,gBAAgB,GAAG,YAAY,CAAC;QAEjE,MAAM,gBAAgB,GAAG,UAAU,GAAG,CAAC,CAAC;QAExC,MAAM,gBAAgB,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC;QAC3C,MAAM,qBAAqB,GAAG,UAAU,CAAC,UAAU,CAAC,CAAC;QAErD,KAAK,IAAI,WAAW,GAAG,CAAC,EAAE,WAAW,GAAG,YAAY,EAAE,WAAW,EAAE,EAAE,CAAC;YACrE,MAAM,iBAAiB,GAAG,WAAW,GAAG,CAAC,CAAC;YAE1C,MAAM,YAAY,GAAG,gBAAgB,GAAG,WAAW,CAAC;YACpD,MAAM,SAAS,GAAG,YAAY,GAAG,CAAC,CAAC;YACnC,MAAM,SAAS,GAAG,wBAAwB,GAAG,WAAW,GAAG,CAAC,CAAC;YAE7D,MAAM,SAAS,GAAG,iBAAiB,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC5D,MAAM,SAAS,GAAG,gBAAgB,IAAI,iBAAiB,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAEhF,MAAM,qBAAqB,GAAG,gBAAgB,IAAI,iBAAiB,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAE7F,kFAAkF;YAClF,6FAA6F;YAC7F,uFAAuF;YACvF,6FAA6F;YAC7F,2FAA2F;YAC3F,IAAI,KAAa,CAAC;YAClB,IAAI,CAAC,SAAS,IAAI,gBAAgB,EAAE,CAAC;gBACpC,KAAK,GAAG,CAAC,CAAC;YACX,CAAC;iBAAM,CAAC;gBACP,KAAK,GAAG,gBAAgB,CAAC,gBAAgB,EAAE,qBAAqB,EAAE,MAAM,EAAE,WAAW,EAAE,WAAW,EAAE,qBAAqB,CAAC,CAAC;YAC5H,CAAC;YAED,8DAA8D;YAC9D,6DAA6D;YAC7D,uCAAuC;YACvC,MAAM,YAAY,GAAG,KAAK,IAAI,SAAS,GAAG,KAAK,IAAI,SAAS,CAAC;YAC7D,IAAI,YAAY,IAAI;YACnB,+EAA+E;YAC/E,yBAAyB;gBACzB,6CAA6C;gBAC7C,4EAA4E;gBAC5E,0EAA0E;gBAC1E,gBAAgB;gBAChB,iFAAiF;gBACjF,WAAW,CAAC,UAAU,CAAC,UAAU,EAAE,WAAW,CAAC,CAC/C,EAAE,CAAC;gBACH,OAAO,CAAC,YAAY,CAAC,GAAG,qBAAqB,GAAG,CAAC,CAAC;gBAClD,MAAM,CAAC,YAAY,CAAC,GAAG,SAAS,GAAG,KAAK,CAAC;YAC1C,CAAC;YAED,oEAAoE;YACpE,oBAAoB;YACpB,qCAAqC;iBAChC,CAAC;gBACL,OAAO,CAAC,YAAY,CAAC,GAAG,QAAQ,CAAC;gBACjC,MAAM,CAAC,YAAY,CAAC,GAAG,SAAS,CAAC;YAClC,CAAC;QACF,CAAC;IACF,CAAC;IAED,2DAA2D;IAC3D,MAAM,SAAS,GAAa,EAAE,CAAC;IAC/B,IAAI,UAAU,GAAG,WAAW,GAAG,CAAC,CAAC;IACjC,IAAI,WAAW,GAAG,YAAY,GAAG,CAAC,CAAC;IACnC,OAAO,UAAU,IAAI,CAAC,IAAI,WAAW,IAAI,CAAC,EAAE,CAAC;QAC5C,MAAM,YAAY,GAAG,UAAU,GAAG,YAAY,GAAG,WAAW,CAAC;QAC7D,MAAM,KAAK,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;QACpC,IAAI,KAAK,KAAK,QAAQ,EAAE,CAAC;YACxB,WAAW,EAAE,CAAC,CAAC,UAAU;QAC1B,CAAC;aAAM,CAAC;YACP,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAE5B,iBAAiB;YACjB,UAAU,EAAE,CAAC;YACb,WAAW,EAAE,CAAC;QACf,CAAC;IACF,CAAC;IAED,eAAe;IACf,sBAAsB;IACtB,gDAAgD;IAChD,IAAI;IAEJ,OAAO,CAAC,MAAM,CAAC,WAAW,GAAG,YAAY,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,OAAO,EAAE,CAAC,CAAC;AACtE,CAAC;AAED,SAAS,gBAAgB,CAAC,gBAAwB,EAAE,qBAA6B,EAAE,MAAc,EAAE,WAAmB,EAAE,WAAmB,EAAE,qBAA6B;IACzK,IAAI,KAAK,GAAG,CAAC,CAAC;IAEd,IAAI,CAAC,eAAe,CAAC,qBAAqB,EAAE,WAAW,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC;QACvE,OAAO,KAAK,CAAC,CAAC,yBAAyB;IACxC,CAAC;IAED,eAAe;IACf,+HAA+H;IAC/H,IAAI;IAEJ,wBAAwB;IACxB,KAAK,IAAI,CAAC,CAAC;IAEX,eAAe;IACf,sEAAsE;IACtE,IAAI;IAEJ,oEAAoE;IACpE,mEAAmE;IACnE,2CAA2C;IAC3C,IAAI,qBAAqB,GAAG,CAAC,EAAE,CAAC;QAC/B,KAAK,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,qBAAqB,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,qBAAqB,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAEjG,eAAe;QACf,0EAA0E;QAC1E,IAAI;IACL,CAAC;IAED,kBAAkB;IAClB,IAAI,gBAAgB,KAAK,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC;QAC9C,KAAK,IAAI,CAAC,CAAC;QAEX,eAAe;QACf,uCAAuC;QACvC,IAAI;IACL,CAAC;IAED,sBAAsB;IACtB,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC;QACvB,KAAK,IAAI,CAAC,CAAC;QAEX,eAAe;QACf,2CAA2C;QAC3C,IAAI;IACL,CAAC;SAEI,CAAC;QAEL,wBAAwB;QACxB,MAAM,cAAc,GAAG,mBAAmB,CAAC,MAAM,CAAC,UAAU,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/E,IAAI,cAAc,EAAE,CAAC;YACpB,KAAK,IAAI,cAAc,CAAC;YAExB,eAAe;YACf,6DAA6D;YAC7D,IAAI;QACL,CAAC;QAED,4GAA4G;QAC5G,eAAe;QACf,sCAAsC;QACtC,2BAA2B;aACtB,IAAI,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,IAAI,qBAAqB,KAAK,CAAC,EAAE,CAAC;YACjF,KAAK,IAAI,CAAC,CAAC;YAEX,eAAe;YACf,oDAAoD;YACpD,IAAI;QACL,CAAC;IACF,CAAC;IAED,eAAe;IACf,yCAAyC;IACzC,uBAAuB;IACvB,IAAI;IAEJ,OAAO,KAAK,CAAC;AACd,CAAC;AAED,SAAS,eAAe,CAAC,CAAS,EAAE,CAAS;IAC5C,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;QACb,OAAO,IAAI,CAAC;IACb,CAAC;IAED,4DAA4D;IAC5D,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;QAC7B,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,CAAC;IAChC,CAAC;IAED,OAAO,KAAK,CAAC;AACd,CAAC;AAED,SAAS,mBAAmB,CAAC,QAAgB;IAC5C,QAAQ,QAAQ,EAAE,CAAC;QAClB,6BAAoB;QACpB;YACC,OAAO,CAAC,CAAC,CAAC,4BAA4B;QACvC,iCAAwB;QACxB,4BAAmB;QACnB,8BAAqB;QACrB,6BAAoB;QACpB,mCAA0B;QAC1B,mCAA0B;QAC1B;YACC,OAAO,CAAC,CAAC,CAAC,2BAA2B;QACtC;YACC,OAAO,CAAC,CAAC;IACX,CAAC;AACF,CAAC;AAsBD,MAAM,SAAS,GAAgB,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;AAE/C,MAAM,UAAU,WAAW,CAAC,MAAc,EAAE,KAA2C,EAAE,YAAY,GAAG,CAAC,EAAE,SAAS,GAAG,CAAC;IAEvH,yBAAyB;IACzB,MAAM,aAAa,GAAG,KAAuB,CAAC;IAC9C,IAAI,aAAa,CAAC,MAAM,IAAI,aAAa,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC7D,OAAO,qBAAqB,CAAC,MAAM,EAAE,aAAa,CAAC,MAAM,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC;IACrF,CAAC;IAED,sBAAsB;IACtB,OAAO,mBAAmB,CAAC,MAAM,EAAE,KAAK,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC;AACpE,CAAC;AAED,SAAS,qBAAqB,CAAC,MAAc,EAAE,KAA4B,EAAE,YAAoB,EAAE,SAAiB;IACnH,IAAI,UAAU,GAAG,CAAC,CAAC;IACnB,MAAM,YAAY,GAAa,EAAE,CAAC;IAElC,KAAK,MAAM,UAAU,IAAI,KAAK,EAAE,CAAC;QAChC,MAAM,CAAC,KAAK,EAAE,OAAO,CAAC,GAAG,mBAAmB,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC;QAC1F,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;YAC/B,sDAAsD;YACtD,qDAAqD;YACrD,OAAO,SAAS,CAAC;QAClB,CAAC;QAED,UAAU,IAAI,KAAK,CAAC;QACpB,YAAY,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,CAAC;IAC/B,CAAC;IAED,oDAAoD;IACpD,yCAAyC;IACzC,OAAO,CAAC,UAAU,EAAE,gBAAgB,CAAC,YAAY,CAAC,CAAC,CAAC;AACrD,CAAC;AAED,SAAS,mBAAmB,CAAC,MAAc,EAAE,KAA0B,EAAE,YAAoB,EAAE,SAAiB;IAC/G,MAAM,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAK,CAAC,iBAAiB,EAAE,YAAY,EAAE,MAAM,EAAE,MAAM,CAAC,WAAW,EAAE,EAAE,SAAS,EAAE,EAAE,mBAAmB,EAAE,IAAI,EAAE,cAAc,EAAE,IAAI,EAAE,CAAC,CAAC;IAC9K,IAAI,CAAC,KAAK,EAAE,CAAC;QACZ,OAAO,SAAS,CAAC;IAClB,CAAC;IAED,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC;AAC9C,CAAC;AA4BD,MAAM,aAAa,GAAG,MAAM,CAAC,MAAM,CAAa,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;AAoB9D,MAAM,mBAAmB,GAAG,CAAC,IAAI,EAAE,CAAC;AACpC,MAAM,4BAA4B,GAAG,CAAC,IAAI,EAAE,CAAC;AAC7C,MAAM,qBAAqB,GAAG,CAAC,IAAI,EAAE,CAAC;AAEtC,SAAS,YAAY,CAAC,KAAa,EAAE,WAA+B,EAAE,yBAAkC,EAAE,KAAqB;IAC9H,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IACrD,MAAM,SAAS,GAAG,IAAI,CAAC;QACtB,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;YACnB,MAAM,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,UAAU,EAAE,qBAAqB,EAAE,CAAC,CAAC,qBAAqB,EAAE,CAAC,CAAC;YAClG,KAAK;YACL,WAAW;YACX,yBAAyB;SACzB;KACD,CAAC,CAAC;IACH,OAAO,SAAS,CAAC;AAClB,CAAC;AAED,MAAM,UAAU,cAAc,CAAI,IAAO,EAAE,KAAqB,EAAE,yBAAkC,EAAE,QAA0B,EAAE,KAAuB;IACxJ,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC;QAChC,OAAO,aAAa,CAAC,CAAC,iDAAiD;IACxE,CAAC;IAED,MAAM,KAAK,GAAG,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;IAC1C,IAAI,CAAC,KAAK,EAAE,CAAC;QACZ,OAAO,aAAa,CAAC,CAAC,2BAA2B;IAClD,CAAC;IAED,MAAM,WAAW,GAAG,QAAQ,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;IAEtD,gFAAgF;IAChF,UAAU;IACV,8BAA8B;IAC9B,sDAAsD;IACtD,0CAA0C;IAC1C,MAAM,SAAS,GAAG,YAAY,CAAC,KAAK,EAAE,WAAW,EAAE,yBAAyB,EAAE,KAAK,CAAC,CAAC;IACrF,MAAM,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC;IAChC,IAAI,MAAM,EAAE,CAAC;QACZ,OAAO,MAAM,CAAC;IACf,CAAC;IAED,MAAM,SAAS,GAAG,gBAAgB,CAAC,KAAK,EAAE,WAAW,EAAE,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,yBAAyB,CAAC,CAAC;IACrH,KAAK,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC;IAE7B,OAAO,SAAS,CAAC;AAClB,CAAC;AAED,SAAS,gBAAgB,CAAC,KAAa,EAAE,WAA+B,EAAE,IAAwB,EAAE,KAAqB,EAAE,yBAAkC;IAC5J,MAAM,kBAAkB,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC;IAEjE,8CAA8C;IAC9C,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,cAAc,KAAK,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC,KAAK,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC,EAAE,CAAC;QACtG,OAAO,EAAE,KAAK,EAAE,mBAAmB,EAAE,UAAU,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,gBAAgB,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,WAAW,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC;IAC3K,CAAC;IAED,yBAAyB;IACzB,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC7C,OAAO,wBAAwB,CAAC,KAAK,EAAE,WAAW,EAAE,IAAI,EAAE,KAAK,CAAC,MAAM,EAAE,kBAAkB,EAAE,yBAAyB,CAAC,CAAC;IACxH,CAAC;IAED,sBAAsB;IACtB,OAAO,sBAAsB,CAAC,KAAK,EAAE,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,kBAAkB,EAAE,yBAAyB,CAAC,CAAC;AAC/G,CAAC;AAED,SAAS,wBAAwB,CAAC,KAAa,EAAE,WAA+B,EAAE,IAAwB,EAAE,KAA4B,EAAE,kBAA2B,EAAE,yBAAkC;IACxM,IAAI,UAAU,GAAG,CAAC,CAAC;IACnB,MAAM,iBAAiB,GAAa,EAAE,CAAC;IACvC,MAAM,uBAAuB,GAAa,EAAE,CAAC;IAE7C,KAAK,MAAM,UAAU,IAAI,KAAK,EAAE,CAAC;QAChC,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,gBAAgB,EAAE,GAAG,sBAAsB,CAAC,KAAK,EAAE,WAAW,EAAE,IAAI,EAAE,UAAU,EAAE,kBAAkB,EAAE,yBAAyB,CAAC,CAAC;QAC5J,IAAI,KAAK,KAAK,QAAQ,EAAE,CAAC;YACxB,sDAAsD;YACtD,qDAAqD;YACrD,OAAO,aAAa,CAAC;QACtB,CAAC;QAED,UAAU,IAAI,KAAK,CAAC;QACpB,IAAI,UAAU,EAAE,CAAC;YAChB,iBAAiB,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,CAAC;QACvC,CAAC;QAED,IAAI,gBAAgB,EAAE,CAAC;YACtB,uBAAuB,CAAC,IAAI,CAAC,GAAG,gBAAgB,CAAC,CAAC;QACnD,CAAC;IACF,CAAC;IAED,oDAAoD;IACpD,yCAAyC;IACzC,OAAO;QACN,KAAK,EAAE,UAAU;QACjB,UAAU,EAAE,gBAAgB,CAAC,iBAAiB,CAAC;QAC/C,gBAAgB,EAAE,gBAAgB,CAAC,uBAAuB,CAAC;KAC3D,CAAC;AACH,CAAC;AAED,SAAS,sBAAsB,CAAC,KAAa,EAAE,WAA+B,EAAE,IAAwB,EAAE,KAA0B,EAAE,kBAA2B,EAAE,yBAAkC;IAEpM,4DAA4D;IAC5D,IAAI,kBAAkB,IAAI,CAAC,WAAW,EAAE,CAAC;QACxC,MAAM,CAAC,UAAU,EAAE,cAAc,CAAC,GAAG,UAAU,CAC9C,KAAK,EACL,KAAK,CAAC,UAAU,EAChB,KAAK,CAAC,mBAAmB,EACzB,yBAAyB,IAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;QAC5D,IAAI,UAAU,EAAE,CAAC;YAEhB,yDAAyD;YACzD,wDAAwD;YACxD,yDAAyD;YACzD,uDAAuD;YACvD,aAAa;YACb,MAAM,gBAAgB,GAAG,aAAa,CAAC,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;YAChE,IAAI,SAAiB,CAAC;YACtB,IAAI,gBAAgB,EAAE,CAAC;gBACtB,SAAS,GAAG,4BAA4B,CAAC;gBAEzC,6DAA6D;gBAC7D,0DAA0D;gBAC1D,2DAA2D;gBAC3D,6DAA6D;gBAC7D,uCAAuC;gBACvC,MAAM,iBAAiB,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC;gBACrF,SAAS,IAAI,iBAAiB,CAAC;YAChC,CAAC;iBAAM,CAAC;gBACP,SAAS,GAAG,qBAAqB,CAAC;YACnC,CAAC;YAED,OAAO,EAAE,KAAK,EAAE,SAAS,GAAG,UAAU,EAAE,UAAU,EAAE,gBAAgB,IAAI,aAAa,CAAC,cAAc,CAAC,EAAE,CAAC;QACzG,CAAC;IACF,CAAC;IAED,sEAAsE;IACtE,IAAI,WAAW,EAAE,CAAC;QACjB,IAAI,iBAAiB,GAAG,WAAW,CAAC;QACpC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC;YACZ,iBAAiB,GAAG,GAAG,WAAW,GAAG,GAAG,EAAE,CAAC,CAAC,6BAA6B;QAC1E,CAAC;QAED,MAAM,uBAAuB,GAAG,iBAAiB,CAAC,MAAM,CAAC;QACzD,MAAM,mBAAmB,GAAG,GAAG,iBAAiB,GAAG,KAAK,EAAE,CAAC;QAE3D,MAAM,CAAC,qBAAqB,EAAE,yBAAyB,CAAC,GAAG,UAAU,CACpE,mBAAmB,EACnB,KAAK,CAAC,UAAU,EAChB,KAAK,CAAC,mBAAmB,EACzB,yBAAyB,IAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;QAC5D,IAAI,qBAAqB,EAAE,CAAC;YAC3B,MAAM,uBAAuB,GAAG,aAAa,CAAC,yBAAyB,CAAC,CAAC;YACzE,MAAM,UAAU,GAAa,EAAE,CAAC;YAChC,MAAM,gBAAgB,GAAa,EAAE,CAAC;YAEtC,4EAA4E;YAC5E,uBAAuB,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;gBAEnC,oEAAoE;gBACpE,IAAI,CAAC,CAAC,KAAK,GAAG,uBAAuB,IAAI,CAAC,CAAC,GAAG,GAAG,uBAAuB,EAAE,CAAC;oBAC1E,UAAU,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,GAAG,uBAAuB,EAAE,CAAC,CAAC;oBACpE,gBAAgB,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,KAAK,EAAE,GAAG,EAAE,uBAAuB,EAAE,CAAC,CAAC;gBACzE,CAAC;gBAED,sBAAsB;qBACjB,IAAI,CAAC,CAAC,KAAK,IAAI,uBAAuB,EAAE,CAAC;oBAC7C,UAAU,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,KAAK,GAAG,uBAAuB,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,GAAG,uBAAuB,EAAE,CAAC,CAAC;gBACrG,CAAC;gBAED,4BAA4B;qBACvB,CAAC;oBACL,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC1B,CAAC;YACF,CAAC,CAAC,CAAC;YAEH,OAAO,EAAE,KAAK,EAAE,qBAAqB,EAAE,UAAU,EAAE,gBAAgB,EAAE,CAAC;QACvE,CAAC;IACF,CAAC;IAED,OAAO,aAAa,CAAC;AACtB,CAAC;AAED,SAAS,aAAa,CAAC,OAA6B;IACnD,MAAM,GAAG,GAAa,EAAE,CAAC;IACzB,IAAI,CAAC,OAAO,EAAE,CAAC;QACd,OAAO,GAAG,CAAC;IACZ,CAAC;IAED,IAAI,IAAwB,CAAC;IAC7B,KAAK,MAAM,GAAG,IAAI,OAAO,EAAE,CAAC;QAC3B,IAAI,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,GAAG,EAAE,CAAC;YAC9B,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;QACf,CAAC;aAAM,CAAC;YACP,IAAI,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC,EAAE,CAAC;YACpC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChB,CAAC;IACF,CAAC;IAED,OAAO,GAAG,CAAC;AACZ,CAAC;AAED,SAAS,gBAAgB,CAAC,OAAiB;IAE1C,gDAAgD;IAChD,MAAM,aAAa,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE;QACrD,OAAO,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;IACpC,CAAC,CAAC,CAAC;IAEH,6BAA6B;IAC7B,MAAM,iBAAiB,GAAa,EAAE,CAAC;IACvC,IAAI,YAAY,GAAuB,SAAS,CAAC;IACjD,KAAK,MAAM,KAAK,IAAI,aAAa,EAAE,CAAC;QAEnC,6CAA6C;QAC7C,gDAAgD;QAChD,wBAAwB;QACxB,IAAI,CAAC,YAAY,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE,KAAK,CAAC,EAAE,CAAC;YAC1D,YAAY,GAAG,KAAK,CAAC;YACrB,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC/B,CAAC;QAED,iCAAiC;aAC5B,CAAC;YACL,YAAY,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;YAC/D,YAAY,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC;QAC1D,CAAC;IACF,CAAC;IAED,OAAO,iBAAiB,CAAC;AAC1B,CAAC;AAED,SAAS,aAAa,CAAC,MAAc,EAAE,MAAc;IACpD,IAAI,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;QAC/B,OAAO,KAAK,CAAC,CAAC,yBAAyB;IACxC,CAAC;IAED,IAAI,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;QAC/B,OAAO,KAAK,CAAC,CAAC,yBAAyB;IACxC,CAAC;IAED,OAAO,IAAI,CAAC;AACb,CAAC;AAED,YAAY;AAGZ,mBAAmB;AAEnB,MAAM,UAAU,wBAAwB,CAAI,KAAQ,EAAE,KAAQ,EAAE,KAAqB,EAAE,yBAAkC,EAAE,QAA0B,EAAE,KAAuB;IAC7K,MAAM,UAAU,GAAG,cAAc,CAAC,KAAK,EAAE,KAAK,EAAE,yBAAyB,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;IAC5F,MAAM,UAAU,GAAG,cAAc,CAAC,KAAK,EAAE,KAAK,EAAE,yBAAyB,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;IAE5F,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC;IAChC,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC;IAEhC,0CAA0C;IAC1C,IAAI,MAAM,KAAK,mBAAmB,IAAI,MAAM,KAAK,mBAAmB,EAAE,CAAC;QACtE,IAAI,MAAM,KAAK,MAAM,EAAE,CAAC;YACvB,OAAO,MAAM,KAAK,mBAAmB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAChD,CAAC;IACF,CAAC;IAED,mFAAmF;IACnF,IAAI,MAAM,GAAG,qBAAqB,IAAI,MAAM,GAAG,qBAAqB,EAAE,CAAC;QACtE,IAAI,MAAM,KAAK,MAAM,EAAE,CAAC;YACvB,OAAO,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACjC,CAAC;QAED,wFAAwF;QACxF,gDAAgD;QAChD,IAAI,MAAM,GAAG,4BAA4B,IAAI,MAAM,GAAG,4BAA4B,EAAE,CAAC;YACpF,MAAM,qBAAqB,GAAG,oBAAoB,CAAC,UAAU,CAAC,UAAU,EAAE,UAAU,CAAC,UAAU,CAAC,CAAC;YACjG,IAAI,qBAAqB,KAAK,CAAC,EAAE,CAAC;gBACjC,OAAO,qBAAqB,CAAC;YAC9B,CAAC;QACF,CAAC;QAED,2CAA2C;QAC3C,MAAM,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;QAClD,MAAM,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;QAClD,IAAI,MAAM,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,EAAE,CAAC;YACrC,OAAO,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;QACtC,CAAC;IACF,CAAC;IAED,4CAA4C;IAC5C,IAAI,MAAM,KAAK,MAAM,EAAE,CAAC;QACvB,OAAO,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACjC,CAAC;IAED,2EAA2E;IAC3E,MAAM,oBAAoB,GAAG,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;IACtG,MAAM,oBAAoB,GAAG,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;IACtG,IAAI,oBAAoB,IAAI,CAAC,oBAAoB,EAAE,CAAC;QACnD,OAAO,CAAC,CAAC,CAAC;IACX,CAAC;SAAM,IAAI,oBAAoB,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC1D,OAAO,CAAC,CAAC;IACV,CAAC;IAED,gFAAgF;IAChF,MAAM,kBAAkB,GAAG,uCAAuC,CAAC,KAAK,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;IAChG,MAAM,kBAAkB,GAAG,uCAAuC,CAAC,KAAK,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;IAChG,IAAI,kBAAkB,IAAI,kBAAkB,IAAI,kBAAkB,KAAK,kBAAkB,EAAE,CAAC;QAC3F,OAAO,kBAAkB,GAAG,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACzD,CAAC;IAED,8DAA8D;IAC9D,OAAO,eAAe,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;AACvD,CAAC;AAED,SAAS,uCAAuC,CAAI,IAAO,EAAE,KAAiB,EAAE,QAA0B;IACzG,IAAI,UAAU,GAAG,CAAC,CAAC,CAAC;IACpB,IAAI,QAAQ,GAAG,CAAC,CAAC,CAAC;IAElB,0EAA0E;IAC1E,IAAI,KAAK,CAAC,gBAAgB,EAAE,MAAM,EAAE,CAAC;QACpC,UAAU,GAAG,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IAC9C,CAAC;IAED,gDAAgD;SAC3C,IAAI,KAAK,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;QACnC,UAAU,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IACxC,CAAC;IAED,0DAA0D;IAC1D,sEAAsE;IACtE,yCAAyC;IACzC,IAAI,KAAK,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;QAC9B,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;QAC7D,IAAI,KAAK,CAAC,gBAAgB,EAAE,MAAM,EAAE,CAAC;YACpC,MAAM,eAAe,GAAG,QAAQ,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;YAC1D,IAAI,eAAe,EAAE,CAAC;gBACrB,QAAQ,IAAI,eAAe,CAAC,MAAM,CAAC;YACpC,CAAC;QACF,CAAC;IACF,CAAC;IAED,6EAA6E;SACxE,IAAI,KAAK,CAAC,gBAAgB,EAAE,MAAM,EAAE,CAAC;QACzC,QAAQ,GAAG,KAAK,CAAC,gBAAgB,CAAC,KAAK,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;IAC1E,CAAC;IAED,OAAO,QAAQ,GAAG,UAAU,CAAC;AAC9B,CAAC;AAED,SAAS,oBAAoB,CAAC,QAAmB,EAAE,QAAmB;IACrE,IAAI,CAAC,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,EAAE,CAAC;QAC9E,OAAO,CAAC,CAAC,CAAC,qEAAqE;IAChF,CAAC;IAED,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,CAAC;QACvB,OAAO,CAAC,CAAC,CAAC;IACX,CAAC;IAED,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,CAAC;QACvB,OAAO,CAAC,CAAC;IACV,CAAC;IAED,kDAAkD;IAClD,MAAM,WAAW,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IACtC,MAAM,SAAS,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;IACpD,MAAM,YAAY,GAAG,SAAS,GAAG,WAAW,CAAC;IAE7C,kDAAkD;IAClD,MAAM,WAAW,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IACtC,MAAM,SAAS,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;IACpD,MAAM,YAAY,GAAG,SAAS,GAAG,WAAW,CAAC;IAE7C,8BAA8B;IAC9B,OAAO,YAAY,KAAK,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,YAAY,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjF,CAAC;AAED,SAAS,eAAe,CAAI,KAAQ,EAAE,KAAQ,EAAE,KAAqB,EAAE,QAA0B;IAEhG,0DAA0D;IAC1D,MAAM,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;IAClD,MAAM,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;IAElD,MAAM,YAAY,GAAG,QAAQ,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;IACxD,MAAM,YAAY,GAAG,QAAQ,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;IAExD,MAAM,uBAAuB,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACzF,MAAM,uBAAuB,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAEzF,IAAI,uBAAuB,KAAK,uBAAuB,EAAE,CAAC;QACzD,OAAO,uBAAuB,GAAG,uBAAuB,CAAC;IAC1D,CAAC;IAED,2CAA2C;IAC3C,MAAM,KAAK,GAAG,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IAC1C,MAAM,KAAK,GAAG,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IAE1C,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,EAAE,CAAC;QACrD,OAAO,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;IACpC,CAAC;IAED,6EAA6E;IAE7E,mBAAmB;IACnB,IAAI,MAAM,KAAK,MAAM,EAAE,CAAC;QACvB,OAAO,eAAe,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;IAC1D,CAAC;IAED,yBAAyB;IACzB,IAAI,YAAY,IAAI,YAAY,IAAI,YAAY,KAAK,YAAY,EAAE,CAAC;QACnE,OAAO,eAAe,CAAC,YAAY,EAAE,YAAY,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;IACtE,CAAC;IAED,kBAAkB;IAClB,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,KAAK,KAAK,EAAE,CAAC;QACvC,OAAO,eAAe,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;IACxD,CAAC;IAED,QAAQ;IACR,OAAO,CAAC,CAAC;AACV,CAAC;AAkDD;;;GAGG;AACH,SAAS,sBAAsB,CAAC,KAAa;IAC5C,OAAO,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;AACrD,CAAC;AAED;;;GAGG;AACH,MAAM,+BAA+B,GAAG,GAAG,CAAC;AAC5C,MAAM,UAAU,YAAY,CAAC,QAAgB;IAC5C,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE,CAAC;QAClC,QAAQ,GAAG,EAAE,CAAC;IACf,CAAC;IAED,MAAM,iBAAiB,GAAG,QAAQ,CAAC,WAAW,EAAE,CAAC;IACjD,MAAM,EAAE,cAAc,EAAE,UAAU,EAAE,mBAAmB,EAAE,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC;IACrF,MAAM,qBAAqB,GAAG,cAAc,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAC/D,MAAM,gBAAgB,GAAG,sBAAsB,CAAC,QAAQ,CAAC,CAAC;IAE1D,IAAI,MAAM,GAAsC,SAAS,CAAC;IAE1D,MAAM,aAAa,GAAG,QAAQ,CAAC,KAAK,CAAC,+BAA+B,CAAC,CAAC;IACtE,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC9B,KAAK,MAAM,aAAa,IAAI,aAAa,EAAE,CAAC;YAC3C,MAAM,qBAAqB,GAAG,sBAAsB,CAAC,aAAa,CAAC,CAAC;YACpE,MAAM,EACL,cAAc,EAAE,mBAAmB,EACnC,UAAU,EAAE,eAAe,EAC3B,mBAAmB,EAAE,wBAAwB,EAC7C,GAAG,cAAc,CAAC,aAAa,CAAC,CAAC;YAElC,IAAI,eAAe,EAAE,CAAC;gBACrB,IAAI,CAAC,MAAM,EAAE,CAAC;oBACb,MAAM,GAAG,EAAE,CAAC;gBACb,CAAC;gBAED,MAAM,CAAC,IAAI,CAAC;oBACX,QAAQ,EAAE,aAAa;oBACvB,iBAAiB,EAAE,aAAa,CAAC,WAAW,EAAE;oBAC9C,cAAc,EAAE,mBAAmB;oBACnC,UAAU,EAAE,eAAe;oBAC3B,mBAAmB,EAAE,wBAAwB;oBAC7C,qBAAqB,EAAE,qBAAqB;iBAC5C,CAAC,CAAC;YACJ,CAAC;QACF,CAAC;IACF,CAAC;IAED,OAAO,EAAE,QAAQ,EAAE,iBAAiB,EAAE,cAAc,EAAE,UAAU,EAAE,mBAAmB,EAAE,MAAM,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,gBAAgB,EAAE,CAAC;AACjK,CAAC;AAED,SAAS,cAAc,CAAC,QAAgB;IACvC,IAAI,cAAsB,CAAC;IAC3B,IAAI,SAAS,EAAE,CAAC;QACf,cAAc,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,0DAA0D;IAC1G,CAAC;SAAM,CAAC;QACP,cAAc,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,kEAAkE;IAClH,CAAC;IAED,2DAA2D;IAC3D,4CAA4C;IAC5C,2CAA2C;IAC3C,6CAA6C;IAC7C,2DAA2D;IAC3D,MAAM,UAAU,GAAG,cAAc,CAAC,OAAO,CAAC,gBAAgB,EAAE,EAAE,CAAC,CAAC;IAEhE,OAAO;QACN,cAAc;QACd,UAAU;QACV,mBAAmB,EAAE,UAAU,CAAC,WAAW,EAAE;KAC7C,CAAC;AACH,CAAC;AAID,MAAM,UAAU,YAAY,CAAC,IAAiD;IAC7E,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;QACzB,OAAO,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,+BAA+B,CAAC,CAAC,CAAC;IAC9F,CAAC;IAED,OAAO,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AACpC,CAAC;AAED,YAAY","file":"fuzzyScorer.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { compareAnything } from './comparers.js';\nimport { createMatches as createFuzzyMatches, fuzzyScore, IMatch, isUpper, matchesPrefix } from './filters.js';\nimport { hash } from './hash.js';\nimport { sep } from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { equalsIgnoreCase } from './strings.js';\n\n//#region Fuzzy scorer\n\nexport type FuzzyScore = [number /* score */, number[] /* match positions */];\nexport type FuzzyScorerCache = { [key: string]: IItemScore };\n\nconst NO_MATCH = 0;\nconst NO_SCORE: FuzzyScore = [NO_MATCH, []];\n\n// const DEBUG = true;\n// const DEBUG_MATRIX = false;\n\nexport function scoreFuzzy(target: string, query: string, queryLower: string, allowNonContiguousMatches: boolean): FuzzyScore {\n\tif (!target || !query) {\n\t\treturn NO_SCORE; // return early if target or query are undefined\n\t}\n\n\tconst targetLength = target.length;\n\tconst queryLength = query.length;\n\n\tif (targetLength < queryLength) {\n\t\treturn NO_SCORE; // impossible for query to be contained in target\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.group(`Target: ${target}, Query: ${query}`);\n\t// }\n\n\tconst targetLower = target.toLowerCase();\n\tconst res = doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength, allowNonContiguousMatches);\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn res;\n}\n\nfunction doScoreFuzzy(query: string, queryLower: string, queryLength: number, target: string, targetLower: string, targetLength: number, allowNonContiguousMatches: boolean): FuzzyScore {\n\tconst scores: number[] = [];\n\tconst matches: number[] = [];\n\n\t//\n\t// Build Scorer Matrix:\n\t//\n\t// The matrix is composed of query q and target t. For each index we score\n\t// q[i] with t[i] and compare that with the previous score. If the score is\n\t// equal or larger, we keep the match. In addition to the score, we also keep\n\t// the length of the consecutive matches to use as boost for the score.\n\t//\n\t//      t   a   r   g   e   t\n\t//  q\n\t//  u\n\t//  e\n\t//  r\n\t//  y\n\t//\n\tfor (let queryIndex = 0; queryIndex < queryLength; queryIndex++) {\n\t\tconst queryIndexOffset = queryIndex * targetLength;\n\t\tconst queryIndexPreviousOffset = queryIndexOffset - targetLength;\n\n\t\tconst queryIndexGtNull = queryIndex > 0;\n\n\t\tconst queryCharAtIndex = query[queryIndex];\n\t\tconst queryLowerCharAtIndex = queryLower[queryIndex];\n\n\t\tfor (let targetIndex = 0; targetIndex < targetLength; targetIndex++) {\n\t\t\tconst targetIndexGtNull = targetIndex > 0;\n\n\t\t\tconst currentIndex = queryIndexOffset + targetIndex;\n\t\t\tconst leftIndex = currentIndex - 1;\n\t\t\tconst diagIndex = queryIndexPreviousOffset + targetIndex - 1;\n\n\t\t\tconst leftScore = targetIndexGtNull ? scores[leftIndex] : 0;\n\t\t\tconst diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;\n\n\t\t\tconst matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;\n\n\t\t\t// If we are not matching on the first query character any more, we only produce a\n\t\t\t// score if we had a score previously for the last query index (by looking at the diagScore).\n\t\t\t// This makes sure that the query always matches in sequence on the target. For example\n\t\t\t// given a target of \"ede\" and a query of \"de\", we would otherwise produce a wrong high score\n\t\t\t// for query[1] (\"e\") matching on target[0] (\"e\") because of the \"beginning of word\" boost.\n\t\t\tlet score: number;\n\t\t\tif (!diagScore && queryIndexGtNull) {\n\t\t\t\tscore = 0;\n\t\t\t} else {\n\t\t\t\tscore = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength);\n\t\t\t}\n\n\t\t\t// We have a score and its equal or larger than the left score\n\t\t\t// Match: sequence continues growing from previous diag value\n\t\t\t// Score: increases by diag score value\n\t\t\tconst isValidScore = score && diagScore + score >= leftScore;\n\t\t\tif (isValidScore && (\n\t\t\t\t// We don't need to check if it's contiguous if we allow non-contiguous matches\n\t\t\t\tallowNonContiguousMatches ||\n\t\t\t\t// We must be looking for a contiguous match.\n\t\t\t\t// Looking at an index higher than 0 in the query means we must have already\n\t\t\t\t// found out this is contiguous otherwise there wouldn't have been a score\n\t\t\t\tqueryIndexGtNull ||\n\t\t\t\t// lastly check if the query is completely contiguous at this index in the target\n\t\t\t\ttargetLower.startsWith(queryLower, targetIndex)\n\t\t\t)) {\n\t\t\t\tmatches[currentIndex] = matchesSequenceLength + 1;\n\t\t\t\tscores[currentIndex] = diagScore + score;\n\t\t\t}\n\n\t\t\t// We either have no score or the score is lower than the left score\n\t\t\t// Match: reset to 0\n\t\t\t// Score: pick up from left hand side\n\t\t\telse {\n\t\t\t\tmatches[currentIndex] = NO_MATCH;\n\t\t\t\tscores[currentIndex] = leftScore;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Restore Positions (starting from bottom right of matrix)\n\tconst positions: number[] = [];\n\tlet queryIndex = queryLength - 1;\n\tlet targetIndex = targetLength - 1;\n\twhile (queryIndex >= 0 && targetIndex >= 0) {\n\t\tconst currentIndex = queryIndex * targetLength + targetIndex;\n\t\tconst match = matches[currentIndex];\n\t\tif (match === NO_MATCH) {\n\t\t\ttargetIndex--; // go left\n\t\t} else {\n\t\t\tpositions.push(targetIndex);\n\n\t\t\t// go up and left\n\t\t\tqueryIndex--;\n\t\t\ttargetIndex--;\n\t\t}\n\t}\n\n\t// Print matrix\n\t// if (DEBUG_MATRIX) {\n\t// \tprintMatrix(query, target, matches, scores);\n\t// }\n\n\treturn [scores[queryLength * targetLength - 1], positions.reverse()];\n}\n\nfunction computeCharScore(queryCharAtIndex: string, queryLowerCharAtIndex: string, target: string, targetLower: string, targetIndex: number, matchesSequenceLength: number): number {\n\tlet score = 0;\n\n\tif (!considerAsEqual(queryLowerCharAtIndex, targetLower[targetIndex])) {\n\t\treturn score; // no match of characters\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.groupCollapsed(`%cFound a match of char: ${queryLowerCharAtIndex} at index ${targetIndex}`, 'font-weight: normal');\n\t// }\n\n\t// Character match bonus\n\tscore += 1;\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cCharacter match bonus: +1`, 'font-weight: normal');\n\t// }\n\n\t// Consecutive match bonus: sequences up to 3 get the full bonus (6)\n\t// and the remainder gets half the bonus (3). This helps reduce the\n\t// overall boost for long sequence matches.\n\tif (matchesSequenceLength > 0) {\n\t\tscore += (Math.min(matchesSequenceLength, 3) * 6) + (Math.max(0, matchesSequenceLength - 3) * 3);\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log(`Consecutive match bonus: +${matchesSequenceLength * 5}`);\n\t\t// }\n\t}\n\n\t// Same case bonus\n\tif (queryCharAtIndex === target[targetIndex]) {\n\t\tscore += 1;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Same case bonus: +1');\n\t\t// }\n\t}\n\n\t// Start of word bonus\n\tif (targetIndex === 0) {\n\t\tscore += 8;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Start of word bonus: +8');\n\t\t// }\n\t}\n\n\telse {\n\n\t\t// After separator bonus\n\t\tconst separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));\n\t\tif (separatorBonus) {\n\t\t\tscore += separatorBonus;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log(`After separator bonus: +${separatorBonus}`);\n\t\t\t// }\n\t\t}\n\n\t\t// Inside word upper case bonus (camel case). We only give this bonus if we're not in a contiguous sequence.\n\t\t// For example:\n\t\t// NPE => NullPointerException = boost\n\t\t// HTTP => HTTP = not boost\n\t\telse if (isUpper(target.charCodeAt(targetIndex)) && matchesSequenceLength === 0) {\n\t\t\tscore += 2;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log('Inside word upper case bonus: +2');\n\t\t\t// }\n\t\t}\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`Total score: ${score}`);\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn score;\n}\n\nfunction considerAsEqual(a: string, b: string): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\t// Special case path separators: ignore platform differences\n\tif (a === '/' || a === '\\\\') {\n\t\treturn b === '/' || b === '\\\\';\n\t}\n\n\treturn false;\n}\n\nfunction scoreSeparatorAtPos(charCode: number): number {\n\tswitch (charCode) {\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\t\treturn 5; // prefer path separators...\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\t\treturn 4; // ...over other separators\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n// function printMatrix(query: string, target: string, matches: number[], scores: number[]): void {\n// \tconsole.log('\\t' + target.split('').join('\\t'));\n// \tfor (let queryIndex = 0; queryIndex < query.length; queryIndex++) {\n// \t\tlet line = query[queryIndex] + '\\t';\n// \t\tfor (let targetIndex = 0; targetIndex < target.length; targetIndex++) {\n// \t\t\tconst currentIndex = queryIndex * target.length + targetIndex;\n// \t\t\tline = line + 'M' + matches[currentIndex] + '/' + 'S' + scores[currentIndex] + '\\t';\n// \t\t}\n\n// \t\tconsole.log(line);\n// \t}\n// }\n\n//#endregion\n\n\n//#region Alternate fuzzy scorer implementation that is e.g. used for symbols\n\nexport type FuzzyScore2 = [number | undefined /* score */, IMatch[]];\n\nconst NO_SCORE2: FuzzyScore2 = [undefined, []];\n\nexport function scoreFuzzy2(target: string, query: IPreparedQuery | IPreparedQueryPiece, patternStart = 0, wordStart = 0): FuzzyScore2 {\n\n\t// Score: multiple inputs\n\tconst preparedQuery = query as IPreparedQuery;\n\tif (preparedQuery.values && preparedQuery.values.length > 1) {\n\t\treturn doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n\t}\n\n\t// Score: single input\n\treturn doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\n\nfunction doScoreFuzzy2Multiple(target: string, query: IPreparedQueryPiece[], patternStart: number, wordStart: number): FuzzyScore2 {\n\tlet totalScore = 0;\n\tconst totalMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n\t\tif (typeof score !== 'number') {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_SCORE2;\n\t\t}\n\n\t\ttotalScore += score;\n\t\ttotalMatches.push(...matches);\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn [totalScore, normalizeMatches(totalMatches)];\n}\n\nfunction doScoreFuzzy2Single(target: string, query: IPreparedQueryPiece, patternStart: number, wordStart: number): FuzzyScore2 {\n\tconst score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\tif (!score) {\n\t\treturn NO_SCORE2;\n\t}\n\n\treturn [score[0], createFuzzyMatches(score)];\n}\n\n//#endregion\n\n\n//#region Item (label, description, path) scorer\n\n/**\n * Scoring on structural items that have a label and optional description.\n */\nexport interface IItemScore {\n\n\t/**\n\t * Overall score.\n\t */\n\tscore: number;\n\n\t/**\n\t * Matches within the label.\n\t */\n\tlabelMatch?: IMatch[];\n\n\t/**\n\t * Matches within the description.\n\t */\n\tdescriptionMatch?: IMatch[];\n}\n\nconst NO_ITEM_SCORE = Object.freeze<IItemScore>({ score: 0 });\n\nexport interface IItemAccessor<T> {\n\n\t/**\n\t * Just the label of the item to score on.\n\t */\n\tgetItemLabel(item: T): string | undefined;\n\n\t/**\n\t * The optional description of the item to score on.\n\t */\n\tgetItemDescription(item: T): string | undefined;\n\n\t/**\n\t * If the item is a file, the path of the file to score on.\n\t */\n\tgetItemPath(file: T): string | undefined;\n}\n\nconst PATH_IDENTITY_SCORE = 1 << 18;\nconst LABEL_PREFIX_SCORE_THRESHOLD = 1 << 17;\nconst LABEL_SCORE_THRESHOLD = 1 << 16;\n\nfunction getCacheHash(label: string, description: string | undefined, allowNonContiguousMatches: boolean, query: IPreparedQuery) {\n\tconst values = query.values ? query.values : [query];\n\tconst cacheHash = hash({\n\t\t[query.normalized]: {\n\t\t\tvalues: values.map(v => ({ value: v.normalized, expectContiguousMatch: v.expectContiguousMatch })),\n\t\t\tlabel,\n\t\t\tdescription,\n\t\t\tallowNonContiguousMatches\n\t\t}\n\t});\n\treturn cacheHash;\n}\n\nexport function scoreItemFuzzy<T>(item: T, query: IPreparedQuery, allowNonContiguousMatches: boolean, accessor: IItemAccessor<T>, cache: FuzzyScorerCache): IItemScore {\n\tif (!item || !query.normalized) {\n\t\treturn NO_ITEM_SCORE; // we need an item and query to score on at least\n\t}\n\n\tconst label = accessor.getItemLabel(item);\n\tif (!label) {\n\t\treturn NO_ITEM_SCORE; // we need a label at least\n\t}\n\n\tconst description = accessor.getItemDescription(item);\n\n\t// in order to speed up scoring, we cache the score with a unique hash based on:\n\t// - label\n\t// - description (if provided)\n\t// - whether non-contiguous matching is enabled or not\n\t// - hash of the query (normalized) values\n\tconst cacheHash = getCacheHash(label, description, allowNonContiguousMatches, query);\n\tconst cached = cache[cacheHash];\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst itemScore = doScoreItemFuzzy(label, description, accessor.getItemPath(item), query, allowNonContiguousMatches);\n\tcache[cacheHash] = itemScore;\n\n\treturn itemScore;\n}\n\nfunction doScoreItemFuzzy(label: string, description: string | undefined, path: string | undefined, query: IPreparedQuery, allowNonContiguousMatches: boolean): IItemScore {\n\tconst preferLabelMatches = !path || !query.containsPathSeparator;\n\n\t// Treat identity matches on full path highest\n\tif (path && (isLinux ? query.pathNormalized === path : equalsIgnoreCase(query.pathNormalized, path))) {\n\t\treturn { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : undefined };\n\t}\n\n\t// Score: multiple inputs\n\tif (query.values && query.values.length > 1) {\n\t\treturn doScoreItemFuzzyMultiple(label, description, path, query.values, preferLabelMatches, allowNonContiguousMatches);\n\t}\n\n\t// Score: single input\n\treturn doScoreItemFuzzySingle(label, description, path, query, preferLabelMatches, allowNonContiguousMatches);\n}\n\nfunction doScoreItemFuzzyMultiple(label: string, description: string | undefined, path: string | undefined, query: IPreparedQueryPiece[], preferLabelMatches: boolean, allowNonContiguousMatches: boolean): IItemScore {\n\tlet totalScore = 0;\n\tconst totalLabelMatches: IMatch[] = [];\n\tconst totalDescriptionMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst { score, labelMatch, descriptionMatch } = doScoreItemFuzzySingle(label, description, path, queryPiece, preferLabelMatches, allowNonContiguousMatches);\n\t\tif (score === NO_MATCH) {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_ITEM_SCORE;\n\t\t}\n\n\t\ttotalScore += score;\n\t\tif (labelMatch) {\n\t\t\ttotalLabelMatches.push(...labelMatch);\n\t\t}\n\n\t\tif (descriptionMatch) {\n\t\t\ttotalDescriptionMatches.push(...descriptionMatch);\n\t\t}\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn {\n\t\tscore: totalScore,\n\t\tlabelMatch: normalizeMatches(totalLabelMatches),\n\t\tdescriptionMatch: normalizeMatches(totalDescriptionMatches)\n\t};\n}\n\nfunction doScoreItemFuzzySingle(label: string, description: string | undefined, path: string | undefined, query: IPreparedQueryPiece, preferLabelMatches: boolean, allowNonContiguousMatches: boolean): IItemScore {\n\n\t// Prefer label matches if told so or we have no description\n\tif (preferLabelMatches || !description) {\n\t\tconst [labelScore, labelPositions] = scoreFuzzy(\n\t\t\tlabel,\n\t\t\tquery.normalized,\n\t\t\tquery.normalizedLowercase,\n\t\t\tallowNonContiguousMatches && !query.expectContiguousMatch);\n\t\tif (labelScore) {\n\n\t\t\t// If we have a prefix match on the label, we give a much\n\t\t\t// higher baseScore to elevate these matches over others\n\t\t\t// This ensures that typing a file name wins over results\n\t\t\t// that are present somewhere in the label, but not the\n\t\t\t// beginning.\n\t\t\tconst labelPrefixMatch = matchesPrefix(query.normalized, label);\n\t\t\tlet baseScore: number;\n\t\t\tif (labelPrefixMatch) {\n\t\t\t\tbaseScore = LABEL_PREFIX_SCORE_THRESHOLD;\n\n\t\t\t\t// We give another boost to labels that are short, e.g. given\n\t\t\t\t// files \"window.ts\" and \"windowActions.ts\" and a query of\n\t\t\t\t// \"window\", we want \"window.ts\" to receive a higher score.\n\t\t\t\t// As such we compute the percentage the query has within the\n\t\t\t\t// label and add that to the baseScore.\n\t\t\t\tconst prefixLengthBoost = Math.round((query.normalized.length / label.length) * 100);\n\t\t\t\tbaseScore += prefixLengthBoost;\n\t\t\t} else {\n\t\t\t\tbaseScore = LABEL_SCORE_THRESHOLD;\n\t\t\t}\n\n\t\t\treturn { score: baseScore + labelScore, labelMatch: labelPrefixMatch || createMatches(labelPositions) };\n\t\t}\n\t}\n\n\t// Finally compute description + label scores if we have a description\n\tif (description) {\n\t\tlet descriptionPrefix = description;\n\t\tif (!!path) {\n\t\t\tdescriptionPrefix = `${description}${sep}`; // assume this is a file path\n\t\t}\n\n\t\tconst descriptionPrefixLength = descriptionPrefix.length;\n\t\tconst descriptionAndLabel = `${descriptionPrefix}${label}`;\n\n\t\tconst [labelDescriptionScore, labelDescriptionPositions] = scoreFuzzy(\n\t\t\tdescriptionAndLabel,\n\t\t\tquery.normalized,\n\t\t\tquery.normalizedLowercase,\n\t\t\tallowNonContiguousMatches && !query.expectContiguousMatch);\n\t\tif (labelDescriptionScore) {\n\t\t\tconst labelDescriptionMatches = createMatches(labelDescriptionPositions);\n\t\t\tconst labelMatch: IMatch[] = [];\n\t\t\tconst descriptionMatch: IMatch[] = [];\n\n\t\t\t// We have to split the matches back onto the label and description portions\n\t\t\tlabelDescriptionMatches.forEach(h => {\n\n\t\t\t\t// Match overlaps label and description part, we need to split it up\n\t\t\t\tif (h.start < descriptionPrefixLength && h.end > descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: 0, end: h.end - descriptionPrefixLength });\n\t\t\t\t\tdescriptionMatch.push({ start: h.start, end: descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on label part\n\t\t\t\telse if (h.start >= descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: h.start - descriptionPrefixLength, end: h.end - descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on description part\n\t\t\t\telse {\n\t\t\t\t\tdescriptionMatch.push(h);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn { score: labelDescriptionScore, labelMatch, descriptionMatch };\n\t\t}\n\t}\n\n\treturn NO_ITEM_SCORE;\n}\n\nfunction createMatches(offsets: number[] | undefined): IMatch[] {\n\tconst ret: IMatch[] = [];\n\tif (!offsets) {\n\t\treturn ret;\n\t}\n\n\tlet last: IMatch | undefined;\n\tfor (const pos of offsets) {\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end += 1;\n\t\t} else {\n\t\t\tlast = { start: pos, end: pos + 1 };\n\t\t\tret.push(last);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nfunction normalizeMatches(matches: IMatch[]): IMatch[] {\n\n\t// sort matches by start to be able to normalize\n\tconst sortedMatches = matches.sort((matchA, matchB) => {\n\t\treturn matchA.start - matchB.start;\n\t});\n\n\t// merge matches that overlap\n\tconst normalizedMatches: IMatch[] = [];\n\tlet currentMatch: IMatch | undefined = undefined;\n\tfor (const match of sortedMatches) {\n\n\t\t// if we have no current match or the matches\n\t\t// do not overlap, we take it as is and remember\n\t\t// it for future merging\n\t\tif (!currentMatch || !matchOverlaps(currentMatch, match)) {\n\t\t\tcurrentMatch = match;\n\t\t\tnormalizedMatches.push(match);\n\t\t}\n\n\t\t// otherwise we merge the matches\n\t\telse {\n\t\t\tcurrentMatch.start = Math.min(currentMatch.start, match.start);\n\t\t\tcurrentMatch.end = Math.max(currentMatch.end, match.end);\n\t\t}\n\t}\n\n\treturn normalizedMatches;\n}\n\nfunction matchOverlaps(matchA: IMatch, matchB: IMatch): boolean {\n\tif (matchA.end < matchB.start) {\n\t\treturn false;\t// A ends before B starts\n\t}\n\n\tif (matchB.end < matchA.start) {\n\t\treturn false; // B ends before A starts\n\t}\n\n\treturn true;\n}\n\n//#endregion\n\n\n//#region Comparers\n\nexport function compareItemsByFuzzyScore<T>(itemA: T, itemB: T, query: IPreparedQuery, allowNonContiguousMatches: boolean, accessor: IItemAccessor<T>, cache: FuzzyScorerCache): number {\n\tconst itemScoreA = scoreItemFuzzy(itemA, query, allowNonContiguousMatches, accessor, cache);\n\tconst itemScoreB = scoreItemFuzzy(itemB, query, allowNonContiguousMatches, accessor, cache);\n\n\tconst scoreA = itemScoreA.score;\n\tconst scoreB = itemScoreB.score;\n\n\t// 1.) identity matches have highest score\n\tif (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === PATH_IDENTITY_SCORE ? -1 : 1;\n\t\t}\n\t}\n\n\t// 2.) matches on label are considered higher compared to label+description matches\n\tif (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA > scoreB ? -1 : 1;\n\t\t}\n\n\t\t// prefer more compact matches over longer in label (unless this is a prefix match where\n\t\t// longer prefix matches are actually preferred)\n\t\tif (scoreA < LABEL_PREFIX_SCORE_THRESHOLD && scoreB < LABEL_PREFIX_SCORE_THRESHOLD) {\n\t\t\tconst comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);\n\t\t\tif (comparedByMatchLength !== 0) {\n\t\t\t\treturn comparedByMatchLength;\n\t\t\t}\n\t\t}\n\n\t\t// prefer shorter labels over longer labels\n\t\tconst labelA = accessor.getItemLabel(itemA) || '';\n\t\tconst labelB = accessor.getItemLabel(itemB) || '';\n\t\tif (labelA.length !== labelB.length) {\n\t\t\treturn labelA.length - labelB.length;\n\t\t}\n\t}\n\n\t// 3.) compare by score in label+description\n\tif (scoreA !== scoreB) {\n\t\treturn scoreA > scoreB ? -1 : 1;\n\t}\n\n\t// 4.) scores are identical: prefer matches in label over non-label matches\n\tconst itemAHasLabelMatches = Array.isArray(itemScoreA.labelMatch) && itemScoreA.labelMatch.length > 0;\n\tconst itemBHasLabelMatches = Array.isArray(itemScoreB.labelMatch) && itemScoreB.labelMatch.length > 0;\n\tif (itemAHasLabelMatches && !itemBHasLabelMatches) {\n\t\treturn -1;\n\t} else if (itemBHasLabelMatches && !itemAHasLabelMatches) {\n\t\treturn 1;\n\t}\n\n\t// 5.) scores are identical: prefer more compact matches (label and description)\n\tconst itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);\n\tconst itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);\n\tif (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {\n\t\treturn itemBMatchDistance > itemAMatchDistance ? -1 : 1;\n\t}\n\n\t// 6.) scores are identical: start to use the fallback compare\n\treturn fallbackCompare(itemA, itemB, query, accessor);\n}\n\nfunction computeLabelAndDescriptionMatchDistance<T>(item: T, score: IItemScore, accessor: IItemAccessor<T>): number {\n\tlet matchStart = -1;\n\tlet matchEnd = -1;\n\n\t// If we have description matches, the start is first of description match\n\tif (score.descriptionMatch?.length) {\n\t\tmatchStart = score.descriptionMatch[0].start;\n\t}\n\n\t// Otherwise, the start is the first label match\n\telse if (score.labelMatch?.length) {\n\t\tmatchStart = score.labelMatch[0].start;\n\t}\n\n\t// If we have label match, the end is the last label match\n\t// If we had a description match, we add the length of the description\n\t// as offset to the end to indicate this.\n\tif (score.labelMatch?.length) {\n\t\tmatchEnd = score.labelMatch[score.labelMatch.length - 1].end;\n\t\tif (score.descriptionMatch?.length) {\n\t\t\tconst itemDescription = accessor.getItemDescription(item);\n\t\t\tif (itemDescription) {\n\t\t\t\tmatchEnd += itemDescription.length;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we have just a description match, the end is the last description match\n\telse if (score.descriptionMatch?.length) {\n\t\tmatchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;\n\t}\n\n\treturn matchEnd - matchStart;\n}\n\nfunction compareByMatchLength(matchesA?: IMatch[], matchesB?: IMatch[]): number {\n\tif ((!matchesA && !matchesB) || ((!matchesA?.length) && (!matchesB?.length))) {\n\t\treturn 0; // make sure to not cause bad comparing when matches are not provided\n\t}\n\n\tif (!matchesB?.length) {\n\t\treturn -1;\n\t}\n\n\tif (!matchesA?.length) {\n\t\treturn 1;\n\t}\n\n\t// Compute match length of A (first to last match)\n\tconst matchStartA = matchesA[0].start;\n\tconst matchEndA = matchesA[matchesA.length - 1].end;\n\tconst matchLengthA = matchEndA - matchStartA;\n\n\t// Compute match length of B (first to last match)\n\tconst matchStartB = matchesB[0].start;\n\tconst matchEndB = matchesB[matchesB.length - 1].end;\n\tconst matchLengthB = matchEndB - matchStartB;\n\n\t// Prefer shorter match length\n\treturn matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;\n}\n\nfunction fallbackCompare<T>(itemA: T, itemB: T, query: IPreparedQuery, accessor: IItemAccessor<T>): number {\n\n\t// check for label + description length and prefer shorter\n\tconst labelA = accessor.getItemLabel(itemA) || '';\n\tconst labelB = accessor.getItemLabel(itemB) || '';\n\n\tconst descriptionA = accessor.getItemDescription(itemA);\n\tconst descriptionB = accessor.getItemDescription(itemB);\n\n\tconst labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);\n\tconst labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);\n\n\tif (labelDescriptionALength !== labelDescriptionBLength) {\n\t\treturn labelDescriptionALength - labelDescriptionBLength;\n\t}\n\n\t// check for path length and prefer shorter\n\tconst pathA = accessor.getItemPath(itemA);\n\tconst pathB = accessor.getItemPath(itemB);\n\n\tif (pathA && pathB && pathA.length !== pathB.length) {\n\t\treturn pathA.length - pathB.length;\n\t}\n\n\t// 7.) finally we have equal scores and equal length, we fallback to comparer\n\n\t// compare by label\n\tif (labelA !== labelB) {\n\t\treturn compareAnything(labelA, labelB, query.normalized);\n\t}\n\n\t// compare by description\n\tif (descriptionA && descriptionB && descriptionA !== descriptionB) {\n\t\treturn compareAnything(descriptionA, descriptionB, query.normalized);\n\t}\n\n\t// compare by path\n\tif (pathA && pathB && pathA !== pathB) {\n\t\treturn compareAnything(pathA, pathB, query.normalized);\n\t}\n\n\t// equal\n\treturn 0;\n}\n\n//#endregion\n\n\n//#region Query Normalizer\n\nexport interface IPreparedQueryPiece {\n\n\t/**\n\t * The original query as provided as input.\n\t */\n\toriginal: string;\n\toriginalLowercase: string;\n\n\t/**\n\t * Original normalized to platform separators:\n\t * - Windows: \\\n\t * - Posix: /\n\t */\n\tpathNormalized: string;\n\n\t/**\n\t * In addition to the normalized path, will have\n\t * whitespace and wildcards removed.\n\t */\n\tnormalized: string;\n\tnormalizedLowercase: string;\n\n\t/**\n\t * The query is wrapped in quotes which means\n\t * this query must be a substring of the input.\n\t * In other words, no fuzzy matching is used.\n\t */\n\texpectContiguousMatch: boolean;\n}\n\nexport interface IPreparedQuery extends IPreparedQueryPiece {\n\n\t/**\n\t * Query split by spaces into pieces.\n\t */\n\tvalues: IPreparedQueryPiece[] | undefined;\n\n\t/**\n\t * Whether the query contains path separator(s) or not.\n\t */\n\tcontainsPathSeparator: boolean;\n}\n\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query: string) {\n\treturn query.startsWith('\"') && query.endsWith('\"');\n}\n\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original: string): IPreparedQuery {\n\tif (typeof original !== 'string') {\n\t\toriginal = '';\n\t}\n\n\tconst originalLowercase = original.toLowerCase();\n\tconst { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);\n\tconst containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n\tconst expectExactMatch = queryExpectsExactMatch(original);\n\n\tlet values: IPreparedQueryPiece[] | undefined = undefined;\n\n\tconst originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n\tif (originalSplit.length > 1) {\n\t\tfor (const originalPiece of originalSplit) {\n\t\t\tconst expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n\t\t\tconst {\n\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\tnormalizedLowercase: normalizedLowercasePiece\n\t\t\t} = normalizeQuery(originalPiece);\n\n\t\t\tif (normalizedPiece) {\n\t\t\t\tif (!values) {\n\t\t\t\t\tvalues = [];\n\t\t\t\t}\n\n\t\t\t\tvalues.push({\n\t\t\t\t\toriginal: originalPiece,\n\t\t\t\t\toriginalLowercase: originalPiece.toLowerCase(),\n\t\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\t\tnormalizedLowercase: normalizedLowercasePiece,\n\t\t\t\t\texpectContiguousMatch: expectExactMatchPiece\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };\n}\n\nfunction normalizeQuery(original: string): { pathNormalized: string; normalized: string; normalizedLowercase: string } {\n\tlet pathNormalized: string;\n\tif (isWindows) {\n\t\tpathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n\t} else {\n\t\tpathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n\t}\n\n\t// remove certain characters that help find better results:\n\t// - quotes: are used for exact match search\n\t// - wildcards: are used for fuzzy matching\n\t// - whitespace: are used to separate queries\n\t// - ellipsis: sometimes used to indicate any path segments\n\tconst normalized = pathNormalized.replace(/[\\*\\u2026\\s\"]/g, '');\n\n\treturn {\n\t\tpathNormalized,\n\t\tnormalized,\n\t\tnormalizedLowercase: normalized.toLowerCase()\n\t};\n}\n\nexport function pieceToQuery(piece: IPreparedQueryPiece): IPreparedQuery;\nexport function pieceToQuery(pieces: IPreparedQueryPiece[]): IPreparedQuery;\nexport function pieceToQuery(arg1: IPreparedQueryPiece | IPreparedQueryPiece[]): IPreparedQuery {\n\tif (Array.isArray(arg1)) {\n\t\treturn prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n\t}\n\n\treturn prepareQuery(arg1.original);\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { compareAnything } from './comparers.js';\nimport { createMatches as createFuzzyMatches, fuzzyScore, IMatch, isUpper, matchesPrefix } from './filters.js';\nimport { hash } from './hash.js';\nimport { sep } from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { equalsIgnoreCase } from './strings.js';\n\n//#region Fuzzy scorer\n\nexport type FuzzyScore = [number /* score */, number[] /* match positions */];\nexport type FuzzyScorerCache = { [key: string]: IItemScore };\n\nconst NO_MATCH = 0;\nconst NO_SCORE: FuzzyScore = [NO_MATCH, []];\n\n// const DEBUG = true;\n// const DEBUG_MATRIX = false;\n\nexport function scoreFuzzy(target: string, query: string, queryLower: string, allowNonContiguousMatches: boolean): FuzzyScore {\n\tif (!target || !query) {\n\t\treturn NO_SCORE; // return early if target or query are undefined\n\t}\n\n\tconst targetLength = target.length;\n\tconst queryLength = query.length;\n\n\tif (targetLength < queryLength) {\n\t\treturn NO_SCORE; // impossible for query to be contained in target\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.group(`Target: ${target}, Query: ${query}`);\n\t// }\n\n\tconst targetLower = target.toLowerCase();\n\tconst res = doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength, allowNonContiguousMatches);\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn res;\n}\n\nfunction doScoreFuzzy(query: string, queryLower: string, queryLength: number, target: string, targetLower: string, targetLength: number, allowNonContiguousMatches: boolean): FuzzyScore {\n\tconst scores: number[] = [];\n\tconst matches: number[] = [];\n\n\t//\n\t// Build Scorer Matrix:\n\t//\n\t// The matrix is composed of query q and target t. For each index we score\n\t// q[i] with t[i] and compare that with the previous score. If the score is\n\t// equal or larger, we keep the match. In addition to the score, we also keep\n\t// the length of the consecutive matches to use as boost for the score.\n\t//\n\t//      t   a   r   g   e   t\n\t//  q\n\t//  u\n\t//  e\n\t//  r\n\t//  y\n\t//\n\tfor (let queryIndex = 0; queryIndex < queryLength; queryIndex++) {\n\t\tconst queryIndexOffset = queryIndex * targetLength;\n\t\tconst queryIndexPreviousOffset = queryIndexOffset - targetLength;\n\n\t\tconst queryIndexGtNull = queryIndex > 0;\n\n\t\tconst queryCharAtIndex = query[queryIndex];\n\t\tconst queryLowerCharAtIndex = queryLower[queryIndex];\n\n\t\tfor (let targetIndex = 0; targetIndex < targetLength; targetIndex++) {\n\t\t\tconst targetIndexGtNull = targetIndex > 0;\n\n\t\t\tconst currentIndex = queryIndexOffset + targetIndex;\n\t\t\tconst leftIndex = currentIndex - 1;\n\t\t\tconst diagIndex = queryIndexPreviousOffset + targetIndex - 1;\n\n\t\t\tconst leftScore = targetIndexGtNull ? scores[leftIndex] : 0;\n\t\t\tconst diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;\n\n\t\t\tconst matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;\n\n\t\t\t// If we are not matching on the first query character any more, we only produce a\n\t\t\t// score if we had a score previously for the last query index (by looking at the diagScore).\n\t\t\t// This makes sure that the query always matches in sequence on the target. For example\n\t\t\t// given a target of \"ede\" and a query of \"de\", we would otherwise produce a wrong high score\n\t\t\t// for query[1] (\"e\") matching on target[0] (\"e\") because of the \"beginning of word\" boost.\n\t\t\tlet score: number;\n\t\t\tif (!diagScore && queryIndexGtNull) {\n\t\t\t\tscore = 0;\n\t\t\t} else {\n\t\t\t\tscore = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength);\n\t\t\t}\n\n\t\t\t// We have a score and its equal or larger than the left score\n\t\t\t// Match: sequence continues growing from previous diag value\n\t\t\t// Score: increases by diag score value\n\t\t\tconst isValidScore = score && diagScore + score >= leftScore;\n\t\t\tif (isValidScore && (\n\t\t\t\t// We don't need to check if it's contiguous if we allow non-contiguous matches\n\t\t\t\tallowNonContiguousMatches ||\n\t\t\t\t// We must be looking for a contiguous match.\n\t\t\t\t// Looking at an index higher than 0 in the query means we must have already\n\t\t\t\t// found out this is contiguous otherwise there wouldn't have been a score\n\t\t\t\tqueryIndexGtNull ||\n\t\t\t\t// lastly check if the query is completely contiguous at this index in the target\n\t\t\t\ttargetLower.startsWith(queryLower, targetIndex)\n\t\t\t)) {\n\t\t\t\tmatches[currentIndex] = matchesSequenceLength + 1;\n\t\t\t\tscores[currentIndex] = diagScore + score;\n\t\t\t}\n\n\t\t\t// We either have no score or the score is lower than the left score\n\t\t\t// Match: reset to 0\n\t\t\t// Score: pick up from left hand side\n\t\t\telse {\n\t\t\t\tmatches[currentIndex] = NO_MATCH;\n\t\t\t\tscores[currentIndex] = leftScore;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Restore Positions (starting from bottom right of matrix)\n\tconst positions: number[] = [];\n\tlet queryIndex = queryLength - 1;\n\tlet targetIndex = targetLength - 1;\n\twhile (queryIndex >= 0 && targetIndex >= 0) {\n\t\tconst currentIndex = queryIndex * targetLength + targetIndex;\n\t\tconst match = matches[currentIndex];\n\t\tif (match === NO_MATCH) {\n\t\t\ttargetIndex--; // go left\n\t\t} else {\n\t\t\tpositions.push(targetIndex);\n\n\t\t\t// go up and left\n\t\t\tqueryIndex--;\n\t\t\ttargetIndex--;\n\t\t}\n\t}\n\n\t// Print matrix\n\t// if (DEBUG_MATRIX) {\n\t// \tprintMatrix(query, target, matches, scores);\n\t// }\n\n\treturn [scores[queryLength * targetLength - 1], positions.reverse()];\n}\n\nfunction computeCharScore(queryCharAtIndex: string, queryLowerCharAtIndex: string, target: string, targetLower: string, targetIndex: number, matchesSequenceLength: number): number {\n\tlet score = 0;\n\n\tif (!considerAsEqual(queryLowerCharAtIndex, targetLower[targetIndex])) {\n\t\treturn score; // no match of characters\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.groupCollapsed(`%cFound a match of char: ${queryLowerCharAtIndex} at index ${targetIndex}`, 'font-weight: normal');\n\t// }\n\n\t// Character match bonus\n\tscore += 1;\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cCharacter match bonus: +1`, 'font-weight: normal');\n\t// }\n\n\t// Consecutive match bonus: sequences up to 3 get the full bonus (6)\n\t// and the remainder gets half the bonus (3). This helps reduce the\n\t// overall boost for long sequence matches.\n\tif (matchesSequenceLength > 0) {\n\t\tscore += (Math.min(matchesSequenceLength, 3) * 6) + (Math.max(0, matchesSequenceLength - 3) * 3);\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log(`Consecutive match bonus: +${matchesSequenceLength * 5}`);\n\t\t// }\n\t}\n\n\t// Same case bonus\n\tif (queryCharAtIndex === target[targetIndex]) {\n\t\tscore += 1;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Same case bonus: +1');\n\t\t// }\n\t}\n\n\t// Start of word bonus\n\tif (targetIndex === 0) {\n\t\tscore += 8;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Start of word bonus: +8');\n\t\t// }\n\t}\n\n\telse {\n\n\t\t// After separator bonus\n\t\tconst separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));\n\t\tif (separatorBonus) {\n\t\t\tscore += separatorBonus;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log(`After separator bonus: +${separatorBonus}`);\n\t\t\t// }\n\t\t}\n\n\t\t// Inside word upper case bonus (camel case). We only give this bonus if we're not in a contiguous sequence.\n\t\t// For example:\n\t\t// NPE => NullPointerException = boost\n\t\t// HTTP => HTTP = not boost\n\t\telse if (isUpper(target.charCodeAt(targetIndex)) && matchesSequenceLength === 0) {\n\t\t\tscore += 2;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log('Inside word upper case bonus: +2');\n\t\t\t// }\n\t\t}\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`Total score: ${score}`);\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn score;\n}\n\nfunction considerAsEqual(a: string, b: string): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\t// Special case path separators: ignore platform differences\n\tif (a === '/' || a === '\\\\') {\n\t\treturn b === '/' || b === '\\\\';\n\t}\n\n\treturn false;\n}\n\nfunction scoreSeparatorAtPos(charCode: number): number {\n\tswitch (charCode) {\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\t\treturn 5; // prefer path separators...\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\t\treturn 4; // ...over other separators\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n// function printMatrix(query: string, target: string, matches: number[], scores: number[]): void {\n// \tconsole.log('\\t' + target.split('').join('\\t'));\n// \tfor (let queryIndex = 0; queryIndex < query.length; queryIndex++) {\n// \t\tlet line = query[queryIndex] + '\\t';\n// \t\tfor (let targetIndex = 0; targetIndex < target.length; targetIndex++) {\n// \t\t\tconst currentIndex = queryIndex * target.length + targetIndex;\n// \t\t\tline = line + 'M' + matches[currentIndex] + '/' + 'S' + scores[currentIndex] + '\\t';\n// \t\t}\n\n// \t\tconsole.log(line);\n// \t}\n// }\n\n//#endregion\n\n\n//#region Alternate fuzzy scorer implementation that is e.g. used for symbols\n\nexport type FuzzyScore2 = [number | undefined /* score */, IMatch[]];\n\nconst NO_SCORE2: FuzzyScore2 = [undefined, []];\n\nexport function scoreFuzzy2(target: string, query: IPreparedQuery | IPreparedQueryPiece, patternStart = 0, wordStart = 0): FuzzyScore2 {\n\n\t// Score: multiple inputs\n\tconst preparedQuery = query as IPreparedQuery;\n\tif (preparedQuery.values && preparedQuery.values.length > 1) {\n\t\treturn doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n\t}\n\n\t// Score: single input\n\treturn doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\n\nfunction doScoreFuzzy2Multiple(target: string, query: IPreparedQueryPiece[], patternStart: number, wordStart: number): FuzzyScore2 {\n\tlet totalScore = 0;\n\tconst totalMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n\t\tif (typeof score !== 'number') {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_SCORE2;\n\t\t}\n\n\t\ttotalScore += score;\n\t\ttotalMatches.push(...matches);\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn [totalScore, normalizeMatches(totalMatches)];\n}\n\nfunction doScoreFuzzy2Single(target: string, query: IPreparedQueryPiece, patternStart: number, wordStart: number): FuzzyScore2 {\n\tconst score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\tif (!score) {\n\t\treturn NO_SCORE2;\n\t}\n\n\treturn [score[0], createFuzzyMatches(score)];\n}\n\n//#endregion\n\n\n//#region Item (label, description, path) scorer\n\n/**\n * Scoring on structural items that have a label and optional description.\n */\nexport interface IItemScore {\n\n\t/**\n\t * Overall score.\n\t */\n\tscore: number;\n\n\t/**\n\t * Matches within the label.\n\t */\n\tlabelMatch?: IMatch[];\n\n\t/**\n\t * Matches within the description.\n\t */\n\tdescriptionMatch?: IMatch[];\n}\n\nconst NO_ITEM_SCORE = Object.freeze<IItemScore>({ score: 0 });\n\nexport interface IItemAccessor<T> {\n\n\t/**\n\t * Just the label of the item to score on.\n\t */\n\tgetItemLabel(item: T): string | undefined;\n\n\t/**\n\t * The optional description of the item to score on.\n\t */\n\tgetItemDescription(item: T): string | undefined;\n\n\t/**\n\t * If the item is a file, the path of the file to score on.\n\t */\n\tgetItemPath(file: T): string | undefined;\n}\n\nconst PATH_IDENTITY_SCORE = 1 << 18;\nconst LABEL_PREFIX_SCORE_THRESHOLD = 1 << 17;\nconst LABEL_SCORE_THRESHOLD = 1 << 16;\n\nfunction getCacheHash(label: string, description: string | undefined, allowNonContiguousMatches: boolean, query: IPreparedQuery) {\n\tconst values = query.values ? query.values : [query];\n\tconst cacheHash = hash({\n\t\t[query.normalized]: {\n\t\t\tvalues: values.map(v => ({ value: v.normalized, expectContiguousMatch: v.expectContiguousMatch })),\n\t\t\tlabel,\n\t\t\tdescription,\n\t\t\tallowNonContiguousMatches\n\t\t}\n\t});\n\treturn cacheHash;\n}\n\nexport function scoreItemFuzzy<T>(item: T, query: IPreparedQuery, allowNonContiguousMatches: boolean, accessor: IItemAccessor<T>, cache: FuzzyScorerCache): IItemScore {\n\tif (!item || !query.normalized) {\n\t\treturn NO_ITEM_SCORE; // we need an item and query to score on at least\n\t}\n\n\tconst label = accessor.getItemLabel(item);\n\tif (!label) {\n\t\treturn NO_ITEM_SCORE; // we need a label at least\n\t}\n\n\tconst description = accessor.getItemDescription(item);\n\n\t// in order to speed up scoring, we cache the score with a unique hash based on:\n\t// - label\n\t// - description (if provided)\n\t// - whether non-contiguous matching is enabled or not\n\t// - hash of the query (normalized) values\n\tconst cacheHash = getCacheHash(label, description, allowNonContiguousMatches, query);\n\tconst cached = cache[cacheHash];\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst itemScore = doScoreItemFuzzy(label, description, accessor.getItemPath(item), query, allowNonContiguousMatches);\n\tcache[cacheHash] = itemScore;\n\n\treturn itemScore;\n}\n\nfunction doScoreItemFuzzy(label: string, description: string | undefined, path: string | undefined, query: IPreparedQuery, allowNonContiguousMatches: boolean): IItemScore {\n\tconst preferLabelMatches = !path || !query.containsPathSeparator;\n\n\t// Treat identity matches on full path highest\n\tif (path && (isLinux ? query.pathNormalized === path : equalsIgnoreCase(query.pathNormalized, path))) {\n\t\treturn { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : undefined };\n\t}\n\n\t// Score: multiple inputs\n\tif (query.values && query.values.length > 1) {\n\t\treturn doScoreItemFuzzyMultiple(label, description, path, query.values, preferLabelMatches, allowNonContiguousMatches);\n\t}\n\n\t// Score: single input\n\treturn doScoreItemFuzzySingle(label, description, path, query, preferLabelMatches, allowNonContiguousMatches);\n}\n\nfunction doScoreItemFuzzyMultiple(label: string, description: string | undefined, path: string | undefined, query: IPreparedQueryPiece[], preferLabelMatches: boolean, allowNonContiguousMatches: boolean): IItemScore {\n\tlet totalScore = 0;\n\tconst totalLabelMatches: IMatch[] = [];\n\tconst totalDescriptionMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst { score, labelMatch, descriptionMatch } = doScoreItemFuzzySingle(label, description, path, queryPiece, preferLabelMatches, allowNonContiguousMatches);\n\t\tif (score === NO_MATCH) {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_ITEM_SCORE;\n\t\t}\n\n\t\ttotalScore += score;\n\t\tif (labelMatch) {\n\t\t\ttotalLabelMatches.push(...labelMatch);\n\t\t}\n\n\t\tif (descriptionMatch) {\n\t\t\ttotalDescriptionMatches.push(...descriptionMatch);\n\t\t}\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn {\n\t\tscore: totalScore,\n\t\tlabelMatch: normalizeMatches(totalLabelMatches),\n\t\tdescriptionMatch: normalizeMatches(totalDescriptionMatches)\n\t};\n}\n\nfunction doScoreItemFuzzySingle(label: string, description: string | undefined, path: string | undefined, query: IPreparedQueryPiece, preferLabelMatches: boolean, allowNonContiguousMatches: boolean): IItemScore {\n\n\t// Prefer label matches if told so or we have no description\n\tif (preferLabelMatches || !description) {\n\t\tconst [labelScore, labelPositions] = scoreFuzzy(\n\t\t\tlabel,\n\t\t\tquery.normalized,\n\t\t\tquery.normalizedLowercase,\n\t\t\tallowNonContiguousMatches && !query.expectContiguousMatch);\n\t\tif (labelScore) {\n\n\t\t\t// If we have a prefix match on the label, we give a much\n\t\t\t// higher baseScore to elevate these matches over others\n\t\t\t// This ensures that typing a file name wins over results\n\t\t\t// that are present somewhere in the label, but not the\n\t\t\t// beginning.\n\t\t\tconst labelPrefixMatch = matchesPrefix(query.normalized, label);\n\t\t\tlet baseScore: number;\n\t\t\tif (labelPrefixMatch) {\n\t\t\t\tbaseScore = LABEL_PREFIX_SCORE_THRESHOLD;\n\n\t\t\t\t// We give another boost to labels that are short, e.g. given\n\t\t\t\t// files \"window.ts\" and \"windowActions.ts\" and a query of\n\t\t\t\t// \"window\", we want \"window.ts\" to receive a higher score.\n\t\t\t\t// As such we compute the percentage the query has within the\n\t\t\t\t// label and add that to the baseScore.\n\t\t\t\tconst prefixLengthBoost = Math.round((query.normalized.length / label.length) * 100);\n\t\t\t\tbaseScore += prefixLengthBoost;\n\t\t\t} else {\n\t\t\t\tbaseScore = LABEL_SCORE_THRESHOLD;\n\t\t\t}\n\n\t\t\treturn { score: baseScore + labelScore, labelMatch: labelPrefixMatch || createMatches(labelPositions) };\n\t\t}\n\t}\n\n\t// Finally compute description + label scores if we have a description\n\tif (description) {\n\t\tlet descriptionPrefix = description;\n\t\tif (!!path) {\n\t\t\tdescriptionPrefix = `${description}${sep}`; // assume this is a file path\n\t\t}\n\n\t\tconst descriptionPrefixLength = descriptionPrefix.length;\n\t\tconst descriptionAndLabel = `${descriptionPrefix}${label}`;\n\n\t\tconst [labelDescriptionScore, labelDescriptionPositions] = scoreFuzzy(\n\t\t\tdescriptionAndLabel,\n\t\t\tquery.normalized,\n\t\t\tquery.normalizedLowercase,\n\t\t\tallowNonContiguousMatches && !query.expectContiguousMatch);\n\t\tif (labelDescriptionScore) {\n\t\t\tconst labelDescriptionMatches = createMatches(labelDescriptionPositions);\n\t\t\tconst labelMatch: IMatch[] = [];\n\t\t\tconst descriptionMatch: IMatch[] = [];\n\n\t\t\t// We have to split the matches back onto the label and description portions\n\t\t\tlabelDescriptionMatches.forEach(h => {\n\n\t\t\t\t// Match overlaps label and description part, we need to split it up\n\t\t\t\tif (h.start < descriptionPrefixLength && h.end > descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: 0, end: h.end - descriptionPrefixLength });\n\t\t\t\t\tdescriptionMatch.push({ start: h.start, end: descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on label part\n\t\t\t\telse if (h.start >= descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: h.start - descriptionPrefixLength, end: h.end - descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on description part\n\t\t\t\telse {\n\t\t\t\t\tdescriptionMatch.push(h);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn { score: labelDescriptionScore, labelMatch, descriptionMatch };\n\t\t}\n\t}\n\n\treturn NO_ITEM_SCORE;\n}\n\nfunction createMatches(offsets: number[] | undefined): IMatch[] {\n\tconst ret: IMatch[] = [];\n\tif (!offsets) {\n\t\treturn ret;\n\t}\n\n\tlet last: IMatch | undefined;\n\tfor (const pos of offsets) {\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end += 1;\n\t\t} else {\n\t\t\tlast = { start: pos, end: pos + 1 };\n\t\t\tret.push(last);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nfunction normalizeMatches(matches: IMatch[]): IMatch[] {\n\n\t// sort matches by start to be able to normalize\n\tconst sortedMatches = matches.sort((matchA, matchB) => {\n\t\treturn matchA.start - matchB.start;\n\t});\n\n\t// merge matches that overlap\n\tconst normalizedMatches: IMatch[] = [];\n\tlet currentMatch: IMatch | undefined = undefined;\n\tfor (const match of sortedMatches) {\n\n\t\t// if we have no current match or the matches\n\t\t// do not overlap, we take it as is and remember\n\t\t// it for future merging\n\t\tif (!currentMatch || !matchOverlaps(currentMatch, match)) {\n\t\t\tcurrentMatch = match;\n\t\t\tnormalizedMatches.push(match);\n\t\t}\n\n\t\t// otherwise we merge the matches\n\t\telse {\n\t\t\tcurrentMatch.start = Math.min(currentMatch.start, match.start);\n\t\t\tcurrentMatch.end = Math.max(currentMatch.end, match.end);\n\t\t}\n\t}\n\n\treturn normalizedMatches;\n}\n\nfunction matchOverlaps(matchA: IMatch, matchB: IMatch): boolean {\n\tif (matchA.end < matchB.start) {\n\t\treturn false;\t// A ends before B starts\n\t}\n\n\tif (matchB.end < matchA.start) {\n\t\treturn false; // B ends before A starts\n\t}\n\n\treturn true;\n}\n\n//#endregion\n\n\n//#region Comparers\n\nexport function compareItemsByFuzzyScore<T>(itemA: T, itemB: T, query: IPreparedQuery, allowNonContiguousMatches: boolean, accessor: IItemAccessor<T>, cache: FuzzyScorerCache): number {\n\tconst itemScoreA = scoreItemFuzzy(itemA, query, allowNonContiguousMatches, accessor, cache);\n\tconst itemScoreB = scoreItemFuzzy(itemB, query, allowNonContiguousMatches, accessor, cache);\n\n\tconst scoreA = itemScoreA.score;\n\tconst scoreB = itemScoreB.score;\n\n\t// 1.) identity matches have highest score\n\tif (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === PATH_IDENTITY_SCORE ? -1 : 1;\n\t\t}\n\t}\n\n\t// 2.) matches on label are considered higher compared to label+description matches\n\tif (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA > scoreB ? -1 : 1;\n\t\t}\n\n\t\t// prefer more compact matches over longer in label (unless this is a prefix match where\n\t\t// longer prefix matches are actually preferred)\n\t\tif (scoreA < LABEL_PREFIX_SCORE_THRESHOLD && scoreB < LABEL_PREFIX_SCORE_THRESHOLD) {\n\t\t\tconst comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);\n\t\t\tif (comparedByMatchLength !== 0) {\n\t\t\t\treturn comparedByMatchLength;\n\t\t\t}\n\t\t}\n\n\t\t// prefer shorter labels over longer labels\n\t\tconst labelA = accessor.getItemLabel(itemA) || '';\n\t\tconst labelB = accessor.getItemLabel(itemB) || '';\n\t\tif (labelA.length !== labelB.length) {\n\t\t\treturn labelA.length - labelB.length;\n\t\t}\n\t}\n\n\t// 3.) compare by score in label+description\n\tif (scoreA !== scoreB) {\n\t\treturn scoreA > scoreB ? -1 : 1;\n\t}\n\n\t// 4.) scores are identical: prefer matches in label over non-label matches\n\tconst itemAHasLabelMatches = Array.isArray(itemScoreA.labelMatch) && itemScoreA.labelMatch.length > 0;\n\tconst itemBHasLabelMatches = Array.isArray(itemScoreB.labelMatch) && itemScoreB.labelMatch.length > 0;\n\tif (itemAHasLabelMatches && !itemBHasLabelMatches) {\n\t\treturn -1;\n\t} else if (itemBHasLabelMatches && !itemAHasLabelMatches) {\n\t\treturn 1;\n\t}\n\n\t// 5.) scores are identical: prefer more compact matches (label and description)\n\tconst itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);\n\tconst itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);\n\tif (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {\n\t\treturn itemBMatchDistance > itemAMatchDistance ? -1 : 1;\n\t}\n\n\t// 6.) scores are identical: start to use the fallback compare\n\treturn fallbackCompare(itemA, itemB, query, accessor);\n}\n\nfunction computeLabelAndDescriptionMatchDistance<T>(item: T, score: IItemScore, accessor: IItemAccessor<T>): number {\n\tlet matchStart = -1;\n\tlet matchEnd = -1;\n\n\t// If we have description matches, the start is first of description match\n\tif (score.descriptionMatch?.length) {\n\t\tmatchStart = score.descriptionMatch[0].start;\n\t}\n\n\t// Otherwise, the start is the first label match\n\telse if (score.labelMatch?.length) {\n\t\tmatchStart = score.labelMatch[0].start;\n\t}\n\n\t// If we have label match, the end is the last label match\n\t// If we had a description match, we add the length of the description\n\t// as offset to the end to indicate this.\n\tif (score.labelMatch?.length) {\n\t\tmatchEnd = score.labelMatch[score.labelMatch.length - 1].end;\n\t\tif (score.descriptionMatch?.length) {\n\t\t\tconst itemDescription = accessor.getItemDescription(item);\n\t\t\tif (itemDescription) {\n\t\t\t\tmatchEnd += itemDescription.length;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we have just a description match, the end is the last description match\n\telse if (score.descriptionMatch?.length) {\n\t\tmatchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;\n\t}\n\n\treturn matchEnd - matchStart;\n}\n\nfunction compareByMatchLength(matchesA?: IMatch[], matchesB?: IMatch[]): number {\n\tif ((!matchesA && !matchesB) || ((!matchesA?.length) && (!matchesB?.length))) {\n\t\treturn 0; // make sure to not cause bad comparing when matches are not provided\n\t}\n\n\tif (!matchesB?.length) {\n\t\treturn -1;\n\t}\n\n\tif (!matchesA?.length) {\n\t\treturn 1;\n\t}\n\n\t// Compute match length of A (first to last match)\n\tconst matchStartA = matchesA[0].start;\n\tconst matchEndA = matchesA[matchesA.length - 1].end;\n\tconst matchLengthA = matchEndA - matchStartA;\n\n\t// Compute match length of B (first to last match)\n\tconst matchStartB = matchesB[0].start;\n\tconst matchEndB = matchesB[matchesB.length - 1].end;\n\tconst matchLengthB = matchEndB - matchStartB;\n\n\t// Prefer shorter match length\n\treturn matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;\n}\n\nfunction fallbackCompare<T>(itemA: T, itemB: T, query: IPreparedQuery, accessor: IItemAccessor<T>): number {\n\n\t// check for label + description length and prefer shorter\n\tconst labelA = accessor.getItemLabel(itemA) || '';\n\tconst labelB = accessor.getItemLabel(itemB) || '';\n\n\tconst descriptionA = accessor.getItemDescription(itemA);\n\tconst descriptionB = accessor.getItemDescription(itemB);\n\n\tconst labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);\n\tconst labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);\n\n\tif (labelDescriptionALength !== labelDescriptionBLength) {\n\t\treturn labelDescriptionALength - labelDescriptionBLength;\n\t}\n\n\t// check for path length and prefer shorter\n\tconst pathA = accessor.getItemPath(itemA);\n\tconst pathB = accessor.getItemPath(itemB);\n\n\tif (pathA && pathB && pathA.length !== pathB.length) {\n\t\treturn pathA.length - pathB.length;\n\t}\n\n\t// 7.) finally we have equal scores and equal length, we fallback to comparer\n\n\t// compare by label\n\tif (labelA !== labelB) {\n\t\treturn compareAnything(labelA, labelB, query.normalized);\n\t}\n\n\t// compare by description\n\tif (descriptionA && descriptionB && descriptionA !== descriptionB) {\n\t\treturn compareAnything(descriptionA, descriptionB, query.normalized);\n\t}\n\n\t// compare by path\n\tif (pathA && pathB && pathA !== pathB) {\n\t\treturn compareAnything(pathA, pathB, query.normalized);\n\t}\n\n\t// equal\n\treturn 0;\n}\n\n//#endregion\n\n\n//#region Query Normalizer\n\nexport interface IPreparedQueryPiece {\n\n\t/**\n\t * The original query as provided as input.\n\t */\n\toriginal: string;\n\toriginalLowercase: string;\n\n\t/**\n\t * Original normalized to platform separators:\n\t * - Windows: \\\n\t * - Posix: /\n\t */\n\tpathNormalized: string;\n\n\t/**\n\t * In addition to the normalized path, will have\n\t * whitespace and wildcards removed.\n\t */\n\tnormalized: string;\n\tnormalizedLowercase: string;\n\n\t/**\n\t * The query is wrapped in quotes which means\n\t * this query must be a substring of the input.\n\t * In other words, no fuzzy matching is used.\n\t */\n\texpectContiguousMatch: boolean;\n}\n\nexport interface IPreparedQuery extends IPreparedQueryPiece {\n\n\t/**\n\t * Query split by spaces into pieces.\n\t */\n\tvalues: IPreparedQueryPiece[] | undefined;\n\n\t/**\n\t * Whether the query contains path separator(s) or not.\n\t */\n\tcontainsPathSeparator: boolean;\n}\n\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query: string) {\n\treturn query.startsWith('\"') && query.endsWith('\"');\n}\n\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original: string): IPreparedQuery {\n\tif (typeof original !== 'string') {\n\t\toriginal = '';\n\t}\n\n\tconst originalLowercase = original.toLowerCase();\n\tconst { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);\n\tconst containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n\tconst expectExactMatch = queryExpectsExactMatch(original);\n\n\tlet values: IPreparedQueryPiece[] | undefined = undefined;\n\n\tconst originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n\tif (originalSplit.length > 1) {\n\t\tfor (const originalPiece of originalSplit) {\n\t\t\tconst expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n\t\t\tconst {\n\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\tnormalizedLowercase: normalizedLowercasePiece\n\t\t\t} = normalizeQuery(originalPiece);\n\n\t\t\tif (normalizedPiece) {\n\t\t\t\tif (!values) {\n\t\t\t\t\tvalues = [];\n\t\t\t\t}\n\n\t\t\t\tvalues.push({\n\t\t\t\t\toriginal: originalPiece,\n\t\t\t\t\toriginalLowercase: originalPiece.toLowerCase(),\n\t\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\t\tnormalizedLowercase: normalizedLowercasePiece,\n\t\t\t\t\texpectContiguousMatch: expectExactMatchPiece\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };\n}\n\nfunction normalizeQuery(original: string): { pathNormalized: string; normalized: string; normalizedLowercase: string } {\n\tlet pathNormalized: string;\n\tif (isWindows) {\n\t\tpathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n\t} else {\n\t\tpathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n\t}\n\n\t// remove certain characters that help find better results:\n\t// - quotes: are used for exact match search\n\t// - wildcards: are used for fuzzy matching\n\t// - whitespace: are used to separate queries\n\t// - ellipsis: sometimes used to indicate any path segments\n\tconst normalized = pathNormalized.replace(/[\\*\\u2026\\s\"]/g, '');\n\n\treturn {\n\t\tpathNormalized,\n\t\tnormalized,\n\t\tnormalizedLowercase: normalized.toLowerCase()\n\t};\n}\n\nexport function pieceToQuery(piece: IPreparedQueryPiece): IPreparedQuery;\nexport function pieceToQuery(pieces: IPreparedQueryPiece[]): IPreparedQuery;\nexport function pieceToQuery(arg1: IPreparedQueryPiece | IPreparedQueryPiece[]): IPreparedQuery {\n\tif (Array.isArray(arg1)) {\n\t\treturn prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n\t}\n\n\treturn prepareQuery(arg1.original);\n}\n\n//#endregion\n"]}