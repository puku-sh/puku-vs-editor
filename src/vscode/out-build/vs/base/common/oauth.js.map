{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/oauth.ts","vs/base/common/oauth.ts"],"names":[],"mappings":"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","file":"oauth.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { decodeBase64 } from './buffer.js';\n\nconst WELL_KNOWN_ROUTE = '/.well-known';\nexport const AUTH_PROTECTED_RESOURCE_METADATA_DISCOVERY_PATH = `${WELL_KNOWN_ROUTE}/oauth-protected-resource`;\nexport const AUTH_SERVER_METADATA_DISCOVERY_PATH = `${WELL_KNOWN_ROUTE}/oauth-authorization-server`;\nexport const OPENID_CONNECT_DISCOVERY_PATH = `${WELL_KNOWN_ROUTE}/openid-configuration`;\nexport const AUTH_SCOPE_SEPARATOR = ' ';\n\n//#region types\n\n/**\n * Base OAuth 2.0 error codes as specified in RFC 6749.\n */\nexport const enum AuthorizationErrorType {\n\tInvalidRequest = 'invalid_request',\n\tInvalidClient = 'invalid_client',\n\tInvalidGrant = 'invalid_grant',\n\tUnauthorizedClient = 'unauthorized_client',\n\tUnsupportedGrantType = 'unsupported_grant_type',\n\tInvalidScope = 'invalid_scope'\n}\n\n/**\n * Device authorization grant specific error codes as specified in RFC 8628 section 3.5.\n */\nexport const enum AuthorizationDeviceCodeErrorType {\n\t/**\n\t * The authorization request is still pending as the end user hasn't completed the user interaction steps.\n\t */\n\tAuthorizationPending = 'authorization_pending',\n\t/**\n\t * A variant of \"authorization_pending\", polling should continue but interval must be increased by 5 seconds.\n\t */\n\tSlowDown = 'slow_down',\n\t/**\n\t * The authorization request was denied.\n\t */\n\tAccessDenied = 'access_denied',\n\t/**\n\t * The \"device_code\" has expired and the device authorization session has concluded.\n\t */\n\tExpiredToken = 'expired_token'\n}\n\n/**\n * Dynamic client registration specific error codes as specified in RFC 7591.\n */\nexport const enum AuthorizationRegistrationErrorType {\n\t/**\n\t * The value of one or more redirection URIs is invalid.\n\t */\n\tInvalidRedirectUri = 'invalid_redirect_uri',\n\t/**\n\t * The value of one of the client metadata fields is invalid and the server has rejected this request.\n\t */\n\tInvalidClientMetadata = 'invalid_client_metadata',\n\t/**\n\t * The software statement presented is invalid.\n\t */\n\tInvalidSoftwareStatement = 'invalid_software_statement',\n\t/**\n\t * The software statement presented is not approved for use by this authorization server.\n\t */\n\tUnapprovedSoftwareStatement = 'unapproved_software_statement'\n}\n\n/**\n * Metadata about a protected resource.\n */\nexport interface IAuthorizationProtectedResourceMetadata {\n\t/**\n\t * REQUIRED. The protected resource's resource identifier URL that uses https scheme and has no fragment components.\n\t */\n\tresource: string;\n\n\t/**\n\t * OPTIONAL. Human-readable name of the protected resource intended for display to the end user.\n\t */\n\tresource_name?: string;\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of OAuth authorization server identifiers.\n\t */\n\tauthorization_servers?: string[];\n\n\t/**\n\t * OPTIONAL. URL of the protected resource's JWK Set document.\n\t */\n\tjwks_uri?: string;\n\n\t/**\n\t * RECOMMENDED. JSON array containing a list of the OAuth 2.0 scope values used in authorization requests.\n\t */\n\tscopes_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of the OAuth 2.0 Bearer Token presentation methods supported.\n\t */\n\tbearer_methods_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of the JWS signing algorithms supported.\n\t */\n\tresource_signing_alg_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of the JWE encryption algorithms supported.\n\t */\n\tresource_encryption_alg_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of the JWE encryption algorithms supported.\n\t */\n\tresource_encryption_enc_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. URL of a page containing human-readable documentation.\n\t */\n\tresource_documentation?: string;\n\n\t/**\n\t * OPTIONAL. URL that provides the resource's requirements on how clients can use the data.\n\t */\n\tresource_policy_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL that provides the resource's terms of service.\n\t */\n\tresource_tos_uri?: string;\n}\n\n/**\n * Metadata about an OAuth 2.0 Authorization Server.\n */\nexport interface IAuthorizationServerMetadata {\n\t/**\n\t * REQUIRED. The authorization server's issuer identifier URL that uses https scheme and has no query or fragment components.\n\t */\n\tissuer: string;\n\n\t/**\n\t * URL of the authorization server's authorization endpoint.\n\t * This is REQUIRED unless no grant types are supported that use the authorization endpoint.\n\t */\n\tauthorization_endpoint?: string;\n\n\t/**\n\t * URL of the authorization server's token endpoint.\n\t * This is REQUIRED unless only the implicit grant type is supported.\n\t */\n\ttoken_endpoint?: string;\n\n\t/**\n\t * OPTIONAL. URL of the authorization server's device code endpoint.\n\t */\n\tdevice_authorization_endpoint?: string;\n\n\t/**\n\t * OPTIONAL. URL of the authorization server's JWK Set document containing signing keys.\n\t */\n\tjwks_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL of the authorization server's OAuth 2.0 Dynamic Client Registration endpoint.\n\t */\n\tregistration_endpoint?: string;\n\n\t/**\n\t * RECOMMENDED. JSON array containing a list of the OAuth 2.0 scope values supported.\n\t */\n\tscopes_supported?: string[];\n\n\t/**\n\t * REQUIRED. JSON array containing a list of the OAuth 2.0 response_type values supported.\n\t */\n\tresponse_types_supported: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of the OAuth 2.0 response_mode values supported.\n\t * Default is [\"query\", \"fragment\"].\n\t */\n\tresponse_modes_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of OAuth 2.0 grant type values supported.\n\t * Default is [\"authorization_code\", \"implicit\"].\n\t */\n\tgrant_types_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of client authentication methods supported by the token endpoint.\n\t * Default is \"client_secret_basic\".\n\t */\n\ttoken_endpoint_auth_methods_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of JWS signing algorithms supported by the token endpoint.\n\t */\n\ttoken_endpoint_auth_signing_alg_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. URL of a page containing human-readable documentation for developers.\n\t */\n\tservice_documentation?: string;\n\n\t/**\n\t * OPTIONAL. Languages and scripts supported for the user interface, as a JSON array of BCP 47 language tags.\n\t */\n\tui_locales_supported?: string[];\n\n\t/**\n\t * OPTIONAL. URL that the authorization server provides to read about the authorization server's requirements.\n\t */\n\top_policy_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL that the authorization server provides to read about the authorization server's terms of service.\n\t */\n\top_tos_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL of the authorization server's OAuth 2.0 revocation endpoint.\n\t */\n\trevocation_endpoint?: string;\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of client authentication methods supported by the revocation endpoint.\n\t */\n\trevocation_endpoint_auth_methods_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of JWS signing algorithms supported by the revocation endpoint.\n\t */\n\trevocation_endpoint_auth_signing_alg_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. URL of the authorization server's OAuth 2.0 introspection endpoint.\n\t */\n\tintrospection_endpoint?: string;\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of client authentication methods supported by the introspection endpoint.\n\t */\n\tintrospection_endpoint_auth_methods_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of JWS signing algorithms supported by the introspection endpoint.\n\t */\n\tintrospection_endpoint_auth_signing_alg_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of PKCE code challenge methods supported.\n\t */\n\tcode_challenge_methods_supported?: string[];\n\n\t/**\n\t * OPTIONAL. Boolean flag indicating whether the authorization server supports the\n\t * client_id_metadata document.\n\t * ref https://datatracker.ietf.org/doc/html/draft-parecki-oauth-client-id-metadata-document-03\n\t */\n\tclient_id_metadata_document_supported?: boolean;\n}\n\n/**\n * Request for the dynamic client registration endpoint.\n * @see https://datatracker.ietf.org/doc/html/rfc7591#section-2\n */\nexport interface IAuthorizationDynamicClientRegistrationRequest {\n\t/**\n\t * OPTIONAL. Array of redirection URI strings for use in redirect-based flows\n\t * such as the authorization code and implicit flows.\n\t */\n\tredirect_uris?: string[];\n\n\t/**\n\t * OPTIONAL. String indicator of the requested authentication method for the token endpoint.\n\t * Values: \"none\", \"client_secret_post\", \"client_secret_basic\".\n\t * Default is \"client_secret_basic\".\n\t */\n\ttoken_endpoint_auth_method?: string;\n\n\t/**\n\t * OPTIONAL. Array of OAuth 2.0 grant type strings that the client can use at the token endpoint.\n\t * Default is [\"authorization_code\"].\n\t */\n\tgrant_types?: string[];\n\n\t/**\n\t * OPTIONAL. Array of the OAuth 2.0 response type strings that the client can use at the authorization endpoint.\n\t * Default is [\"code\"].\n\t */\n\tresponse_types?: string[];\n\n\t/**\n\t * OPTIONAL. Human-readable string name of the client to be presented to the end-user during authorization.\n\t */\n\tclient_name?: string;\n\n\t/**\n\t * OPTIONAL. URL string of a web page providing information about the client.\n\t */\n\tclient_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL string that references a logo for the client.\n\t */\n\tlogo_uri?: string;\n\n\t/**\n\t * OPTIONAL. String containing a space-separated list of scope values that the client can use when requesting access tokens.\n\t */\n\tscope?: string;\n\n\t/**\n\t * OPTIONAL. Array of strings representing ways to contact people responsible for this client, typically email addresses.\n\t */\n\tcontacts?: string[];\n\n\t/**\n\t * OPTIONAL. URL string that points to a human-readable terms of service document for the client.\n\t */\n\ttos_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL string that points to a human-readable privacy policy document.\n\t */\n\tpolicy_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL string referencing the client's JSON Web Key (JWK) Set document.\n\t */\n\tjwks_uri?: string;\n\n\t/**\n\t * OPTIONAL. Client's JSON Web Key Set document value.\n\t */\n\tjwks?: object;\n\n\t/**\n\t * OPTIONAL. A unique identifier string assigned by the client developer or software publisher.\n\t */\n\tsoftware_id?: string;\n\n\t/**\n\t * OPTIONAL. A version identifier string for the client software.\n\t */\n\tsoftware_version?: string;\n\n\t/**\n\t * OPTIONAL. A software statement containing client metadata values about the client software as claims.\n\t */\n\tsoftware_statement?: string;\n\n\t/**\n\t * OPTIONAL. Application type. Usually \"native\" for OAuth clients.\n\t * https://openid.net/specs/openid-connect-registration-1_0.html\n\t */\n\tapplication_type?: 'native' | 'web' | string;\n\n\t/**\n\t * OPTIONAL. Additional metadata fields as defined by extensions.\n\t */\n\t[key: string]: unknown;\n}\n\n/**\n * Response from the dynamic client registration endpoint.\n */\nexport interface IAuthorizationDynamicClientRegistrationResponse {\n\t/**\n\t * REQUIRED. The client identifier issued by the authorization server.\n\t */\n\tclient_id: string;\n\n\t/**\n\t * OPTIONAL. The client secret issued by the authorization server.\n\t * Not returned for public clients.\n\t */\n\tclient_secret?: string;\n\n\t/**\n\t * OPTIONAL. Time at which the client secret will expire in seconds since the Unix Epoch.\n\t */\n\tclient_secret_expires_at?: number;\n\n\t/**\n\t * OPTIONAL. Client name as provided during registration.\n\t */\n\tclient_name?: string;\n\n\t/**\n\t * OPTIONAL. Client URI as provided during registration.\n\t */\n\tclient_uri?: string;\n\n\t/**\n\t * OPTIONAL. Array of redirection URIs as provided during registration.\n\t */\n\tredirect_uris?: string[];\n\n\t/**\n\t * OPTIONAL. Array of grant types allowed for the client.\n\t */\n\tgrant_types?: string[];\n\n\t/**\n\t * OPTIONAL. Array of response types allowed for the client.\n\t */\n\tresponse_types?: string[];\n\n\t/**\n\t * OPTIONAL. Type of authentication method used by the client.\n\t */\n\ttoken_endpoint_auth_method?: string;\n}\n\n/**\n * Response from the authorization endpoint.\n * Typically returned as query parameters in a redirect.\n */\nexport interface IAuthorizationAuthorizeResponse {\n\t/**\n\t * REQUIRED. The authorization code generated by the authorization server.\n\t */\n\tcode: string;\n\n\t/**\n\t * REQUIRED. The state value that was sent in the authorization request.\n\t * Used to prevent CSRF attacks.\n\t */\n\tstate: string;\n}\n\n/**\n * Error response from the authorization endpoint.\n */\nexport interface IAuthorizationAuthorizeErrorResponse {\n\t/**\n\t * REQUIRED. Error code as specified in OAuth 2.0.\n\t */\n\terror: string;\n\n\t/**\n\t * OPTIONAL. Human-readable description of the error.\n\t */\n\terror_description?: string;\n\n\t/**\n\t * OPTIONAL. URI to a human-readable web page with more information about the error.\n\t */\n\terror_uri?: string;\n\n\t/**\n\t * REQUIRED. The state value that was sent in the authorization request.\n\t */\n\tstate: string;\n}\n\n/**\n * Response from the token endpoint.\n */\nexport interface IAuthorizationTokenResponse {\n\t/**\n\t * REQUIRED. The access token issued by the authorization server.\n\t */\n\taccess_token: string;\n\n\t/**\n\t * REQUIRED. The type of the token issued. Usually \"Bearer\".\n\t */\n\ttoken_type: string;\n\n\t/**\n\t * RECOMMENDED. The lifetime in seconds of the access token.\n\t */\n\texpires_in?: number;\n\n\t/**\n\t * OPTIONAL. The refresh token, which can be used to obtain new access tokens.\n\t */\n\trefresh_token?: string;\n\n\t/**\n\t * OPTIONAL. The scope of the access token as a space-delimited list of strings.\n\t */\n\tscope?: string;\n\n\t/**\n\t * OPTIONAL. ID Token value associated with the authenticated session for OpenID Connect flows.\n\t */\n\tid_token?: string;\n}\n\n/**\n * Error response from the token endpoint.\n */\nexport interface IAuthorizationTokenErrorResponse {\n\t/**\n\t * REQUIRED. Error code as specified in OAuth 2.0.\n\t */\n\terror: string;\n\n\t/**\n\t * OPTIONAL. Human-readable description of the error.\n\t */\n\terror_description?: string;\n\n\t/**\n\t * OPTIONAL. URI to a human-readable web page with more information about the error.\n\t */\n\terror_uri?: string;\n}\n\n/**\n * Response from the device authorization endpoint as per RFC 8628 section 3.2.\n */\nexport interface IAuthorizationDeviceResponse {\n\t/**\n\t * REQUIRED. The device verification code.\n\t */\n\tdevice_code: string;\n\n\t/**\n\t * REQUIRED. The end-user verification code.\n\t */\n\tuser_code: string;\n\n\t/**\n\t * REQUIRED. The end-user verification URI on the authorization server.\n\t */\n\tverification_uri: string;\n\n\t/**\n\t * OPTIONAL. A verification URI that includes the user_code, designed for non-textual transmission.\n\t */\n\tverification_uri_complete?: string;\n\n\t/**\n\t * REQUIRED. The lifetime in seconds of the device_code and user_code.\n\t */\n\texpires_in: number;\n\n\t/**\n\t * OPTIONAL. The minimum amount of time in seconds that the client should wait between polling requests.\n\t * If no value is provided, clients must use 5 as the default.\n\t */\n\tinterval?: number;\n}\n\n/**\n * Error response from the token endpoint when using device authorization grant.\n * As defined in RFC 8628 section 3.5.\n */\nexport interface IAuthorizationErrorResponse {\n\t/**\n\t * REQUIRED. Error code as specified in OAuth 2.0 or in RFC 8628 section 3.5.\n\t */\n\terror: AuthorizationErrorType | string;\n\n\t/**\n\t * OPTIONAL. Human-readable description of the error.\n\t */\n\terror_description?: string;\n\n\t/**\n\t * OPTIONAL. URI to a human-readable web page with more information about the error.\n\t */\n\terror_uri?: string;\n}\n\n/**\n * Error response from the token endpoint when using device authorization grant.\n * As defined in RFC 8628 section 3.5.\n */\nexport interface IAuthorizationDeviceTokenErrorResponse extends IAuthorizationErrorResponse {\n\t/**\n\t * REQUIRED. Error code as specified in OAuth 2.0 or in RFC 8628 section 3.5.\n\t */\n\terror: AuthorizationErrorType | AuthorizationDeviceCodeErrorType | string;\n}\n\nexport interface IAuthorizationRegistrationErrorResponse {\n\t/**\n\t * REQUIRED. Error code as specified in OAuth 2.0 or Dynamic Client Registration.\n\t */\n\terror: AuthorizationRegistrationErrorType | string;\n\n\t/**\n\t * OPTIONAL. Human-readable description of the error.\n\t */\n\terror_description?: string;\n}\n\nexport interface IAuthorizationJWTClaims {\n\t/**\n\t * REQUIRED. JWT ID. Unique identifier for the token.\n\t */\n\tjti: string;\n\n\t/**\n\t * REQUIRED. Subject. Principal about which the token asserts information.\n\t */\n\tsub: string;\n\n\t/**\n\t * REQUIRED. Issuer. Entity that issued the token.\n\t */\n\tiss: string;\n\n\t/**\n\t * OPTIONAL. Audience. Recipients that the token is intended for.\n\t */\n\taud?: string | string[];\n\n\t/**\n\t * OPTIONAL. Expiration time. Time after which the token is invalid (seconds since Unix epoch).\n\t */\n\texp?: number;\n\n\t/**\n\t * OPTIONAL. Not before time. Time before which the token is not valid (seconds since Unix epoch).\n\t */\n\tnbf?: number;\n\n\t/**\n\t * OPTIONAL. Issued at time when the token was issued (seconds since Unix epoch).\n\t */\n\tiat?: number;\n\n\t/**\n\t * OPTIONAL. Authorized party. The party to which the token was issued.\n\t */\n\tazp?: string;\n\n\t/**\n\t * OPTIONAL. Scope values for which the token is valid.\n\t */\n\tscope?: string;\n\n\t/**\n\t * OPTIONAL. Full name of the user.\n\t */\n\tname?: string;\n\n\t/**\n\t * OPTIONAL. Given or first name of the user.\n\t */\n\tgiven_name?: string;\n\n\t/**\n\t * OPTIONAL. Family name or last name of the user.\n\t */\n\tfamily_name?: string;\n\n\t/**\n\t * OPTIONAL. Middle name of the user.\n\t */\n\tmiddle_name?: string;\n\n\t/**\n\t * OPTIONAL. Preferred username or email the user wishes to be referred to.\n\t */\n\tpreferred_username?: string;\n\n\t/**\n\t * OPTIONAL. Email address of the user.\n\t */\n\temail?: string;\n\n\t/**\n\t * OPTIONAL. True if the user's email has been verified.\n\t */\n\temail_verified?: boolean;\n\n\t/**\n\t * OPTIONAL. User's profile picture URL.\n\t */\n\tpicture?: string;\n\n\t/**\n\t * OPTIONAL. Authentication time. Time when the user authentication occurred.\n\t */\n\tauth_time?: number;\n\n\t/**\n\t * OPTIONAL. Authentication context class reference.\n\t */\n\tacr?: string;\n\n\t/**\n\t * OPTIONAL. Authentication methods references.\n\t */\n\tamr?: string[];\n\n\t/**\n\t * OPTIONAL. Session ID. String identifier for a session.\n\t */\n\tsid?: string;\n\n\t/**\n\t * OPTIONAL. Address component.\n\t */\n\taddress?: {\n\t\tformatted?: string;\n\t\tstreet_address?: string;\n\t\tlocality?: string;\n\t\tregion?: string;\n\t\tpostal_code?: string;\n\t\tcountry?: string;\n\t};\n\n\t/**\n\t * OPTIONAL. Groups that the user belongs to.\n\t */\n\tgroups?: string[];\n\n\t/**\n\t * OPTIONAL. Roles assigned to the user.\n\t */\n\troles?: string[];\n\n\t/**\n\t * OPTIONAL. Handles optional claims that are not explicitly defined in the standard.\n\t */\n\t[key: string]: unknown;\n}\n\n//#endregion\n\n//#region is functions\n\nexport function isAuthorizationProtectedResourceMetadata(obj: unknown): obj is IAuthorizationProtectedResourceMetadata {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\n\tconst metadata = obj as IAuthorizationProtectedResourceMetadata;\n\tif (!metadata.resource) {\n\t\treturn false;\n\t}\n\tif (metadata.scopes_supported !== undefined && !Array.isArray(metadata.scopes_supported)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst urisToCheck: Array<keyof IAuthorizationServerMetadata> = [\n\t'issuer',\n\t'authorization_endpoint',\n\t'token_endpoint',\n\t'registration_endpoint',\n\t'jwks_uri'\n];\nexport function isAuthorizationServerMetadata(obj: unknown): obj is IAuthorizationServerMetadata {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst metadata = obj as IAuthorizationServerMetadata;\n\tif (!metadata.issuer) {\n\t\tthrow new Error('Authorization server metadata must have an issuer');\n\t}\n\n\tfor (const uri of urisToCheck) {\n\t\tif (!metadata[uri]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (typeof metadata[uri] !== 'string') {\n\t\t\tthrow new Error(`Authorization server metadata '${uri}' must be a string`);\n\t\t}\n\t\tif (!metadata[uri].startsWith('https://') && !metadata[uri].startsWith('http://')) {\n\t\t\tthrow new Error(`Authorization server metadata '${uri}' must start with http:// or https://`);\n\t\t}\n\t}\n\treturn true;\n}\n\nexport function isAuthorizationDynamicClientRegistrationResponse(obj: unknown): obj is IAuthorizationDynamicClientRegistrationResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationDynamicClientRegistrationResponse;\n\treturn response.client_id !== undefined;\n}\n\nexport function isAuthorizationAuthorizeResponse(obj: unknown): obj is IAuthorizationAuthorizeResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationAuthorizeResponse;\n\treturn response.code !== undefined && response.state !== undefined;\n}\n\nexport function isAuthorizationTokenResponse(obj: unknown): obj is IAuthorizationTokenResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationTokenResponse;\n\treturn response.access_token !== undefined && response.token_type !== undefined;\n}\n\nexport function isAuthorizationDeviceResponse(obj: unknown): obj is IAuthorizationDeviceResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationDeviceResponse;\n\treturn response.device_code !== undefined && response.user_code !== undefined && response.verification_uri !== undefined && response.expires_in !== undefined;\n}\n\nexport function isAuthorizationErrorResponse(obj: unknown): obj is IAuthorizationErrorResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationErrorResponse;\n\treturn response.error !== undefined;\n}\n\nexport function isAuthorizationRegistrationErrorResponse(obj: unknown): obj is IAuthorizationRegistrationErrorResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationRegistrationErrorResponse;\n\treturn response.error !== undefined;\n}\n\n//#endregion\n\nexport function getDefaultMetadataForUrl(authorizationServer: URL): IAuthorizationServerMetadata {\n\treturn {\n\t\tissuer: authorizationServer.toString(),\n\t\tauthorization_endpoint: new URL('/authorize', authorizationServer).toString(),\n\t\ttoken_endpoint: new URL('/token', authorizationServer).toString(),\n\t\tregistration_endpoint: new URL('/register', authorizationServer).toString(),\n\t\t// Default values for Dynamic OpenID Providers\n\t\t// https://openid.net/specs/openid-connect-discovery-1_0.html\n\t\tresponse_types_supported: ['code', 'id_token', 'id_token token'],\n\t};\n}\n\n/**\n * The grant types that we support\n */\nconst grantTypesSupported = ['authorization_code', 'refresh_token', 'urn:ietf:params:oauth:grant-type:device_code'];\n\n/**\n * Default port for the authorization flow. We try to use this port so that\n * the redirect URI does not change when running on localhost. This is useful\n * for servers that only allow exact matches on the redirect URI. The spec\n * says that the port should not matter, but some servers do not follow\n * the spec and require an exact match.\n */\nexport const DEFAULT_AUTH_FLOW_PORT = 33418;\nexport async function fetchDynamicRegistration(serverMetadata: IAuthorizationServerMetadata, clientName: string, scopes?: string[]): Promise<IAuthorizationDynamicClientRegistrationResponse> {\n\tif (!serverMetadata.registration_endpoint) {\n\t\tthrow new Error('Server does not support dynamic registration');\n\t}\n\n\tconst requestBody: IAuthorizationDynamicClientRegistrationRequest = {\n\t\tclient_name: clientName,\n\t\tclient_uri: 'https://code.visualstudio.com',\n\t\tgrant_types: serverMetadata.grant_types_supported\n\t\t\t? serverMetadata.grant_types_supported.filter(gt => grantTypesSupported.includes(gt))\n\t\t\t: grantTypesSupported,\n\t\tresponse_types: ['code'],\n\t\tredirect_uris: [\n\t\t\t'https://insiders.vscode.dev/redirect',\n\t\t\t'https://vscode.dev/redirect',\n\t\t\t'http://127.0.0.1/',\n\t\t\t// Added these for any server that might do\n\t\t\t// only exact match on the redirect URI even\n\t\t\t// though the spec says it should not care\n\t\t\t// about the port.\n\t\t\t`http://127.0.0.1:${DEFAULT_AUTH_FLOW_PORT}/`\n\t\t],\n\t\tscope: scopes?.join(AUTH_SCOPE_SEPARATOR),\n\t\ttoken_endpoint_auth_method: 'none',\n\t\tapplication_type: 'native'\n\t};\n\n\tconst response = await fetch(serverMetadata.registration_endpoint, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json'\n\t\t},\n\t\tbody: JSON.stringify(requestBody)\n\t});\n\n\tif (!response.ok) {\n\t\tconst result = await response.text();\n\t\tlet errorDetails: string = result;\n\n\t\ttry {\n\t\t\tconst errorResponse = JSON.parse(result);\n\t\t\tif (isAuthorizationRegistrationErrorResponse(errorResponse)) {\n\t\t\t\terrorDetails = `${errorResponse.error}${errorResponse.error_description ? `: ${errorResponse.error_description}` : ''}`;\n\t\t\t}\n\t\t} catch {\n\t\t\t// JSON parsing failed, use raw text\n\t\t}\n\n\t\tthrow new Error(`Registration to ${serverMetadata.registration_endpoint} failed: ${errorDetails}`);\n\t}\n\n\tconst registration = await response.json();\n\tif (isAuthorizationDynamicClientRegistrationResponse(registration)) {\n\t\treturn registration;\n\t}\n\tthrow new Error(`Invalid authorization dynamic client registration response: ${JSON.stringify(registration)}`);\n}\n\nexport interface IAuthenticationChallenge {\n\tscheme: string;\n\tparams: Record<string, string>;\n}\n\nexport function parseWWWAuthenticateHeader(wwwAuthenticateHeaderValue: string): IAuthenticationChallenge[] {\n\tconst challenges: IAuthenticationChallenge[] = [];\n\n\t// According to RFC 7235, multiple challenges are separated by commas\n\t// But parameters within a challenge can also be separated by commas\n\t// We need to identify scheme names to know where challenges start\n\n\t// First, split by commas while respecting quoted strings\n\tconst tokens: string[] = [];\n\tlet current = '';\n\tlet inQuotes = false;\n\n\tfor (let i = 0; i < wwwAuthenticateHeaderValue.length; i++) {\n\t\tconst char = wwwAuthenticateHeaderValue[i];\n\n\t\tif (char === '\"') {\n\t\t\tinQuotes = !inQuotes;\n\t\t\tcurrent += char;\n\t\t} else if (char === ',' && !inQuotes) {\n\t\t\tif (current.trim()) {\n\t\t\t\ttokens.push(current.trim());\n\t\t\t}\n\t\t\tcurrent = '';\n\t\t} else {\n\t\t\tcurrent += char;\n\t\t}\n\t}\n\n\tif (current.trim()) {\n\t\ttokens.push(current.trim());\n\t}\n\n\t// Now process tokens to identify challenges\n\t// A challenge starts with a scheme name (a token that doesn't contain '=' and is followed by parameters or is standalone)\n\tlet currentChallenge: { scheme: string; params: Record<string, string> } | undefined;\n\n\tfor (const token of tokens) {\n\t\tconst hasEquals = token.includes('=');\n\n\t\tif (!hasEquals) {\n\t\t\t// This token doesn't have '=', so it's likely a scheme name\n\t\t\tif (currentChallenge) {\n\t\t\t\tchallenges.push(currentChallenge);\n\t\t\t}\n\t\t\tcurrentChallenge = { scheme: token.trim(), params: {} };\n\t\t} else {\n\t\t\t// This token has '=', it could be:\n\t\t\t// 1. A parameter for the current challenge\n\t\t\t// 2. A new challenge that starts with \"Scheme param=value\"\n\n\t\t\tconst spaceIndex = token.indexOf(' ');\n\t\t\tif (spaceIndex > 0) {\n\t\t\t\tconst beforeSpace = token.substring(0, spaceIndex);\n\t\t\t\tconst afterSpace = token.substring(spaceIndex + 1);\n\n\t\t\t\t// Check if what's before the space looks like a scheme name (no '=')\n\t\t\t\tif (!beforeSpace.includes('=') && afterSpace.includes('=')) {\n\t\t\t\t\t// This is a new challenge starting with \"Scheme param=value\"\n\t\t\t\t\tif (currentChallenge) {\n\t\t\t\t\t\tchallenges.push(currentChallenge);\n\t\t\t\t\t}\n\t\t\t\t\tcurrentChallenge = { scheme: beforeSpace.trim(), params: {} };\n\n\t\t\t\t\t// Parse the parameter part\n\t\t\t\t\tconst equalIndex = afterSpace.indexOf('=');\n\t\t\t\t\tif (equalIndex > 0) {\n\t\t\t\t\t\tconst key = afterSpace.substring(0, equalIndex).trim();\n\t\t\t\t\t\tconst value = afterSpace.substring(equalIndex + 1).trim().replace(/^\"|\"$/g, '');\n\t\t\t\t\t\tif (key && value !== undefined) {\n\t\t\t\t\t\t\tcurrentChallenge.params[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// This is a parameter for the current challenge\n\t\t\tif (currentChallenge) {\n\t\t\t\tconst equalIndex = token.indexOf('=');\n\t\t\t\tif (equalIndex > 0) {\n\t\t\t\t\tconst key = token.substring(0, equalIndex).trim();\n\t\t\t\t\tconst value = token.substring(equalIndex + 1).trim().replace(/^\"|\"$/g, '');\n\t\t\t\t\tif (key && value !== undefined) {\n\t\t\t\t\t\tcurrentChallenge.params[key] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Don't forget the last challenge\n\tif (currentChallenge) {\n\t\tchallenges.push(currentChallenge);\n\t}\n\n\treturn challenges;\n}\n\nexport function getClaimsFromJWT(token: string): IAuthorizationJWTClaims {\n\tconst parts = token.split('.');\n\tif (parts.length !== 3) {\n\t\tthrow new Error('Invalid JWT token format: token must have three parts separated by dots');\n\t}\n\n\tconst [header, payload, _signature] = parts;\n\n\ttry {\n\t\tconst decodedHeader = JSON.parse(decodeBase64(header).toString());\n\t\tif (typeof decodedHeader !== 'object') {\n\t\t\tthrow new Error('Invalid JWT token format: header is not a JSON object');\n\t\t}\n\n\t\tconst decodedPayload = JSON.parse(decodeBase64(payload).toString());\n\t\tif (typeof decodedPayload !== 'object') {\n\t\t\tthrow new Error('Invalid JWT token format: payload is not a JSON object');\n\t\t}\n\n\t\treturn decodedPayload;\n\t} catch (e) {\n\t\tif (e instanceof Error) {\n\t\t\tthrow new Error(`Failed to parse JWT token: ${e.message}`);\n\t\t}\n\t\tthrow new Error('Failed to parse JWT token');\n\t}\n}\n\n/**\n * Checks if two scope lists are equivalent, regardless of order.\n * This is useful for comparing OAuth scopes where the order should not matter.\n *\n * @param scopes1 First list of scopes to compare (can be undefined)\n * @param scopes2 Second list of scopes to compare (can be undefined)\n * @returns true if the scope lists contain the same scopes (order-independent), false otherwise\n *\n * @example\n * ```typescript\n * scopesMatch(['read', 'write'], ['write', 'read']) // Returns: true\n * scopesMatch(['read'], ['write']) // Returns: false\n * scopesMatch(undefined, undefined) // Returns: true\n * scopesMatch(['read'], undefined) // Returns: false\n * ```\n */\nexport function scopesMatch(scopes1: readonly string[] | undefined, scopes2: readonly string[] | undefined): boolean {\n\tif (scopes1 === scopes2) {\n\t\treturn true;\n\t}\n\tif (!scopes1 || !scopes2) {\n\t\treturn false;\n\t}\n\tif (scopes1.length !== scopes2.length) {\n\t\treturn false;\n\t}\n\n\t// Sort both arrays for comparison to handle different orderings\n\tconst sortedScopes1 = [...scopes1].sort();\n\tconst sortedScopes2 = [...scopes2].sort();\n\n\treturn sortedScopes1.every((scope, index) => scope === sortedScopes2[index]);\n}\n\ninterface CommonResponse {\n\tstatus: number;\n\tstatusText: string;\n\tjson(): Promise<unknown>;\n\ttext(): Promise<string>;\n}\n\ninterface IFetcher {\n\t(input: string, init: { method: string; headers: Record<string, string> }): Promise<CommonResponse>;\n}\n\nexport interface IFetchResourceMetadataOptions {\n\t/**\n\t * Headers to include only when the resource metadata URL has the same origin as the target resource\n\t */\n\tsameOriginHeaders?: Record<string, string>;\n\t/**\n\t * Optional custom fetch implementation (defaults to global fetch)\n\t */\n\tfetch?: IFetcher;\n}\n\n/**\n * Fetches and validates OAuth 2.0 protected resource metadata from the given URL.\n *\n * @param targetResource The target resource URL to compare origins with (e.g., the MCP server URL)\n * @param resourceMetadataUrl Optional URL to fetch the resource metadata from. If not provided, will try well-known URIs.\n * @param options Configuration options for the fetch operation\n * @returns Promise that resolves to the validated resource metadata\n * @throws Error if the fetch fails, returns non-200 status, or the response is invalid\n */\nexport async function fetchResourceMetadata(\n\ttargetResource: string,\n\tresourceMetadataUrl: string | undefined,\n\toptions: IFetchResourceMetadataOptions = {}\n): Promise<IAuthorizationProtectedResourceMetadata> {\n\tconst {\n\t\tsameOriginHeaders = {},\n\t\tfetch: fetchImpl = fetch\n\t} = options;\n\n\tconst targetResourceUrlObj = new URL(targetResource);\n\n\t// If no resourceMetadataUrl is provided, try well-known URIs as per RFC 9728\n\tlet urlsToTry: string[];\n\tif (!resourceMetadataUrl) {\n\t\t// Try in order: 1) with path appended, 2) at root\n\t\tconst pathComponent = targetResourceUrlObj.pathname === '/' ? undefined : targetResourceUrlObj.pathname;\n\t\tconst rootUrl = `${targetResourceUrlObj.origin}${AUTH_PROTECTED_RESOURCE_METADATA_DISCOVERY_PATH}`;\n\t\tif (pathComponent) {\n\t\t\t// Only try both URLs if we have a path component\n\t\t\turlsToTry = [\n\t\t\t\t`${rootUrl}${pathComponent}`,\n\t\t\t\trootUrl\n\t\t\t];\n\t\t} else {\n\t\t\t// If target is already at root, only try the root URL once\n\t\t\turlsToTry = [rootUrl];\n\t\t}\n\t} else {\n\t\turlsToTry = [resourceMetadataUrl];\n\t}\n\n\tconst errors: Error[] = [];\n\tfor (const urlToTry of urlsToTry) {\n\t\ttry {\n\t\t\t// Determine if we should include same-origin headers\n\t\t\tlet headers: Record<string, string> = {\n\t\t\t\t'Accept': 'application/json'\n\t\t\t};\n\n\t\t\tconst resourceMetadataUrlObj = new URL(urlToTry);\n\t\t\tif (resourceMetadataUrlObj.origin === targetResourceUrlObj.origin) {\n\t\t\t\theaders = {\n\t\t\t\t\t...headers,\n\t\t\t\t\t...sameOriginHeaders\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst response = await fetchImpl(urlToTry, { method: 'GET', headers });\n\t\t\tif (response.status !== 200) {\n\t\t\t\tlet errorText: string;\n\t\t\t\ttry {\n\t\t\t\t\terrorText = await response.text();\n\t\t\t\t} catch {\n\t\t\t\t\terrorText = response.statusText;\n\t\t\t\t}\n\t\t\t\terrors.push(new Error(`Failed to fetch resource metadata from ${urlToTry}: ${response.status} ${errorText}`));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst body = await response.json();\n\t\t\tif (isAuthorizationProtectedResourceMetadata(body)) {\n\t\t\t\t// Use URL constructor for normalization - it handles hostname case and trailing slashes\n\t\t\t\tconst prmValue = new URL(body.resource).toString();\n\t\t\t\tconst targetValue = targetResourceUrlObj.toString();\n\t\t\t\tif (prmValue !== targetValue) {\n\t\t\t\t\tthrow new Error(`Protected Resource Metadata resource property value \"${prmValue}\" (length: ${prmValue.length}) does not match target server url \"${targetValue}\" (length: ${targetValue.length}). These MUST match to follow OAuth spec https://datatracker.ietf.org/doc/html/rfc9728#PRConfigurationValidation`);\n\t\t\t\t}\n\t\t\t\treturn body;\n\t\t\t} else {\n\t\t\t\terrors.push(new Error(`Invalid resource metadata from ${urlToTry}. Expected to follow shape of https://datatracker.ietf.org/doc/html/rfc9728#name-protected-resource-metadata (Hints: is scopes_supported an array? Is resource a string?). Current payload: ${JSON.stringify(body)}`));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\terrors.push(e instanceof Error ? e : new Error(String(e)));\n\t\t\tcontinue;\n\t\t}\n\t}\n\t// If we've tried all URLs and none worked, throw the error(s)\n\tif (errors.length === 1) {\n\t\tthrow errors[0];\n\t} else {\n\t\tthrow new AggregateError(errors, 'Failed to fetch resource metadata from all attempted URLs');\n\t}\n}\n\nexport interface IFetchAuthorizationServerMetadataOptions {\n\t/**\n\t * Headers to include in the requests\n\t */\n\tadditionalHeaders?: Record<string, string>;\n\t/**\n\t * Optional custom fetch implementation (defaults to global fetch)\n\t */\n\tfetch?: IFetcher;\n}\n\n/** Helper to try parsing the response as authorization server metadata */\nasync function tryParseAuthServerMetadata(response: CommonResponse): Promise<IAuthorizationServerMetadata | undefined> {\n\tif (response.status !== 200) {\n\t\treturn undefined;\n\t}\n\ttry {\n\t\tconst body = await response.json();\n\t\tif (isAuthorizationServerMetadata(body)) {\n\t\t\treturn body;\n\t\t}\n\t} catch {\n\t\t// Failed to parse as JSON or not valid metadata\n\t}\n\treturn undefined;\n}\n\n/** Helper to get error text from response */\nasync function getErrText(res: CommonResponse): Promise<string> {\n\ttry {\n\t\treturn await res.text();\n\t} catch {\n\t\treturn res.statusText;\n\t}\n}\n\n/**\n * Fetches and validates OAuth 2.0 authorization server metadata from the given authorization server URL.\n *\n * This function tries multiple discovery endpoints in the following order:\n * 1. OAuth 2.0 Authorization Server Metadata with path insertion (RFC 8414)\n * 2. OpenID Connect Discovery with path insertion\n * 3. OpenID Connect Discovery with path addition\n *\n * Path insertion: For issuer URLs with path components (e.g., https://example.com/tenant),\n * the well-known path is inserted after the origin and before the path:\n * https://example.com/.well-known/oauth-authorization-server/tenant\n *\n * Path addition: The well-known path is simply appended to the existing path:\n * https://example.com/tenant/.well-known/openid-configuration\n *\n * @param authorizationServer The authorization server URL (issuer identifier)\n * @param options Configuration options for the fetch operation\n * @returns Promise that resolves to the validated authorization server metadata\n * @throws Error if all discovery attempts fail or the response is invalid\n *\n * @see https://datatracker.ietf.org/doc/html/rfc8414#section-3\n */\nexport async function fetchAuthorizationServerMetadata(\n\tauthorizationServer: string,\n\toptions: IFetchAuthorizationServerMetadataOptions = {}\n): Promise<IAuthorizationServerMetadata> {\n\tconst {\n\t\tadditionalHeaders = {},\n\t\tfetch: fetchImpl = fetch\n\t} = options;\n\n\tconst authorizationServerUrl = new URL(authorizationServer);\n\tconst extraPath = authorizationServerUrl.pathname === '/' ? '' : authorizationServerUrl.pathname;\n\n\tconst errors: Error[] = [];\n\n\tconst doFetch = async (url: string): Promise<IAuthorizationServerMetadata | undefined> => {\n\t\ttry {\n\t\t\tconst rawResponse = await fetchImpl(url, {\n\t\t\t\tmethod: 'GET',\n\t\t\t\theaders: {\n\t\t\t\t\t...additionalHeaders,\n\t\t\t\t\t'Accept': 'application/json'\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst metadata = await tryParseAuthServerMetadata(rawResponse);\n\t\t\tif (metadata) {\n\t\t\t\treturn metadata;\n\t\t\t}\n\t\t\t// No metadata found, collect error from response\n\t\t\terrors.push(new Error(`Failed to fetch authorization server metadata from ${url}: ${rawResponse.status} ${await getErrText(rawResponse)}`));\n\t\t\treturn undefined;\n\t\t} catch (e) {\n\t\t\t// Collect error from fetch failure\n\t\t\terrors.push(e instanceof Error ? e : new Error(String(e)));\n\t\t\treturn undefined;\n\t\t}\n\t};\n\n\t// For the oauth server metadata discovery path, we _INSERT_\n\t// the well known path after the origin and before the path.\n\t// https://datatracker.ietf.org/doc/html/rfc8414#section-3\n\tconst pathToFetch = new URL(AUTH_SERVER_METADATA_DISCOVERY_PATH, authorizationServer).toString() + extraPath;\n\tlet metadata = await doFetch(pathToFetch);\n\tif (metadata) {\n\t\treturn metadata;\n\t}\n\n\t// Try fetching the OpenID Connect Discovery with path insertion.\n\t// For issuer URLs with path components, this inserts the well-known path\n\t// after the origin and before the path.\n\tconst openidPathInsertionUrl = new URL(OPENID_CONNECT_DISCOVERY_PATH, authorizationServer).toString() + extraPath;\n\tmetadata = await doFetch(openidPathInsertionUrl);\n\tif (metadata) {\n\t\treturn metadata;\n\t}\n\n\t// Try fetching the other discovery URL. For the openid metadata discovery\n\t// path, we _ADD_ the well known path after the existing path.\n\t// https://datatracker.ietf.org/doc/html/rfc8414#section-3\n\tconst openidPathAdditionUrl = authorizationServer.endsWith('/')\n\t\t? authorizationServer + OPENID_CONNECT_DISCOVERY_PATH.substring(1) // Remove leading slash if authServer ends with slash\n\t\t: authorizationServer + OPENID_CONNECT_DISCOVERY_PATH;\n\tmetadata = await doFetch(openidPathAdditionUrl);\n\tif (metadata) {\n\t\treturn metadata;\n\t}\n\n\t// If we've tried all URLs and none worked, throw the error(s)\n\tif (errors.length === 1) {\n\t\tthrow errors[0];\n\t} else {\n\t\tthrow new AggregateError(errors, 'Failed to fetch authorization server metadata from all attempted URLs');\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { decodeBase64 } from './buffer.js';\n\nconst WELL_KNOWN_ROUTE = '/.well-known';\nexport const AUTH_PROTECTED_RESOURCE_METADATA_DISCOVERY_PATH = `${WELL_KNOWN_ROUTE}/oauth-protected-resource`;\nexport const AUTH_SERVER_METADATA_DISCOVERY_PATH = `${WELL_KNOWN_ROUTE}/oauth-authorization-server`;\nexport const OPENID_CONNECT_DISCOVERY_PATH = `${WELL_KNOWN_ROUTE}/openid-configuration`;\nexport const AUTH_SCOPE_SEPARATOR = ' ';\n\n//#region types\n\n/**\n * Base OAuth 2.0 error codes as specified in RFC 6749.\n */\nexport const enum AuthorizationErrorType {\n\tInvalidRequest = 'invalid_request',\n\tInvalidClient = 'invalid_client',\n\tInvalidGrant = 'invalid_grant',\n\tUnauthorizedClient = 'unauthorized_client',\n\tUnsupportedGrantType = 'unsupported_grant_type',\n\tInvalidScope = 'invalid_scope'\n}\n\n/**\n * Device authorization grant specific error codes as specified in RFC 8628 section 3.5.\n */\nexport const enum AuthorizationDeviceCodeErrorType {\n\t/**\n\t * The authorization request is still pending as the end user hasn't completed the user interaction steps.\n\t */\n\tAuthorizationPending = 'authorization_pending',\n\t/**\n\t * A variant of \"authorization_pending\", polling should continue but interval must be increased by 5 seconds.\n\t */\n\tSlowDown = 'slow_down',\n\t/**\n\t * The authorization request was denied.\n\t */\n\tAccessDenied = 'access_denied',\n\t/**\n\t * The \"device_code\" has expired and the device authorization session has concluded.\n\t */\n\tExpiredToken = 'expired_token'\n}\n\n/**\n * Dynamic client registration specific error codes as specified in RFC 7591.\n */\nexport const enum AuthorizationRegistrationErrorType {\n\t/**\n\t * The value of one or more redirection URIs is invalid.\n\t */\n\tInvalidRedirectUri = 'invalid_redirect_uri',\n\t/**\n\t * The value of one of the client metadata fields is invalid and the server has rejected this request.\n\t */\n\tInvalidClientMetadata = 'invalid_client_metadata',\n\t/**\n\t * The software statement presented is invalid.\n\t */\n\tInvalidSoftwareStatement = 'invalid_software_statement',\n\t/**\n\t * The software statement presented is not approved for use by this authorization server.\n\t */\n\tUnapprovedSoftwareStatement = 'unapproved_software_statement'\n}\n\n/**\n * Metadata about a protected resource.\n */\nexport interface IAuthorizationProtectedResourceMetadata {\n\t/**\n\t * REQUIRED. The protected resource's resource identifier URL that uses https scheme and has no fragment components.\n\t */\n\tresource: string;\n\n\t/**\n\t * OPTIONAL. Human-readable name of the protected resource intended for display to the end user.\n\t */\n\tresource_name?: string;\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of OAuth authorization server identifiers.\n\t */\n\tauthorization_servers?: string[];\n\n\t/**\n\t * OPTIONAL. URL of the protected resource's JWK Set document.\n\t */\n\tjwks_uri?: string;\n\n\t/**\n\t * RECOMMENDED. JSON array containing a list of the OAuth 2.0 scope values used in authorization requests.\n\t */\n\tscopes_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of the OAuth 2.0 Bearer Token presentation methods supported.\n\t */\n\tbearer_methods_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of the JWS signing algorithms supported.\n\t */\n\tresource_signing_alg_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of the JWE encryption algorithms supported.\n\t */\n\tresource_encryption_alg_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of the JWE encryption algorithms supported.\n\t */\n\tresource_encryption_enc_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. URL of a page containing human-readable documentation.\n\t */\n\tresource_documentation?: string;\n\n\t/**\n\t * OPTIONAL. URL that provides the resource's requirements on how clients can use the data.\n\t */\n\tresource_policy_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL that provides the resource's terms of service.\n\t */\n\tresource_tos_uri?: string;\n}\n\n/**\n * Metadata about an OAuth 2.0 Authorization Server.\n */\nexport interface IAuthorizationServerMetadata {\n\t/**\n\t * REQUIRED. The authorization server's issuer identifier URL that uses https scheme and has no query or fragment components.\n\t */\n\tissuer: string;\n\n\t/**\n\t * URL of the authorization server's authorization endpoint.\n\t * This is REQUIRED unless no grant types are supported that use the authorization endpoint.\n\t */\n\tauthorization_endpoint?: string;\n\n\t/**\n\t * URL of the authorization server's token endpoint.\n\t * This is REQUIRED unless only the implicit grant type is supported.\n\t */\n\ttoken_endpoint?: string;\n\n\t/**\n\t * OPTIONAL. URL of the authorization server's device code endpoint.\n\t */\n\tdevice_authorization_endpoint?: string;\n\n\t/**\n\t * OPTIONAL. URL of the authorization server's JWK Set document containing signing keys.\n\t */\n\tjwks_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL of the authorization server's OAuth 2.0 Dynamic Client Registration endpoint.\n\t */\n\tregistration_endpoint?: string;\n\n\t/**\n\t * RECOMMENDED. JSON array containing a list of the OAuth 2.0 scope values supported.\n\t */\n\tscopes_supported?: string[];\n\n\t/**\n\t * REQUIRED. JSON array containing a list of the OAuth 2.0 response_type values supported.\n\t */\n\tresponse_types_supported: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of the OAuth 2.0 response_mode values supported.\n\t * Default is [\"query\", \"fragment\"].\n\t */\n\tresponse_modes_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of OAuth 2.0 grant type values supported.\n\t * Default is [\"authorization_code\", \"implicit\"].\n\t */\n\tgrant_types_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of client authentication methods supported by the token endpoint.\n\t * Default is \"client_secret_basic\".\n\t */\n\ttoken_endpoint_auth_methods_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of JWS signing algorithms supported by the token endpoint.\n\t */\n\ttoken_endpoint_auth_signing_alg_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. URL of a page containing human-readable documentation for developers.\n\t */\n\tservice_documentation?: string;\n\n\t/**\n\t * OPTIONAL. Languages and scripts supported for the user interface, as a JSON array of BCP 47 language tags.\n\t */\n\tui_locales_supported?: string[];\n\n\t/**\n\t * OPTIONAL. URL that the authorization server provides to read about the authorization server's requirements.\n\t */\n\top_policy_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL that the authorization server provides to read about the authorization server's terms of service.\n\t */\n\top_tos_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL of the authorization server's OAuth 2.0 revocation endpoint.\n\t */\n\trevocation_endpoint?: string;\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of client authentication methods supported by the revocation endpoint.\n\t */\n\trevocation_endpoint_auth_methods_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of JWS signing algorithms supported by the revocation endpoint.\n\t */\n\trevocation_endpoint_auth_signing_alg_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. URL of the authorization server's OAuth 2.0 introspection endpoint.\n\t */\n\tintrospection_endpoint?: string;\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of client authentication methods supported by the introspection endpoint.\n\t */\n\tintrospection_endpoint_auth_methods_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of JWS signing algorithms supported by the introspection endpoint.\n\t */\n\tintrospection_endpoint_auth_signing_alg_values_supported?: string[];\n\n\t/**\n\t * OPTIONAL. JSON array containing a list of PKCE code challenge methods supported.\n\t */\n\tcode_challenge_methods_supported?: string[];\n\n\t/**\n\t * OPTIONAL. Boolean flag indicating whether the authorization server supports the\n\t * client_id_metadata document.\n\t * ref https://datatracker.ietf.org/doc/html/draft-parecki-oauth-client-id-metadata-document-03\n\t */\n\tclient_id_metadata_document_supported?: boolean;\n}\n\n/**\n * Request for the dynamic client registration endpoint.\n * @see https://datatracker.ietf.org/doc/html/rfc7591#section-2\n */\nexport interface IAuthorizationDynamicClientRegistrationRequest {\n\t/**\n\t * OPTIONAL. Array of redirection URI strings for use in redirect-based flows\n\t * such as the authorization code and implicit flows.\n\t */\n\tredirect_uris?: string[];\n\n\t/**\n\t * OPTIONAL. String indicator of the requested authentication method for the token endpoint.\n\t * Values: \"none\", \"client_secret_post\", \"client_secret_basic\".\n\t * Default is \"client_secret_basic\".\n\t */\n\ttoken_endpoint_auth_method?: string;\n\n\t/**\n\t * OPTIONAL. Array of OAuth 2.0 grant type strings that the client can use at the token endpoint.\n\t * Default is [\"authorization_code\"].\n\t */\n\tgrant_types?: string[];\n\n\t/**\n\t * OPTIONAL. Array of the OAuth 2.0 response type strings that the client can use at the authorization endpoint.\n\t * Default is [\"code\"].\n\t */\n\tresponse_types?: string[];\n\n\t/**\n\t * OPTIONAL. Human-readable string name of the client to be presented to the end-user during authorization.\n\t */\n\tclient_name?: string;\n\n\t/**\n\t * OPTIONAL. URL string of a web page providing information about the client.\n\t */\n\tclient_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL string that references a logo for the client.\n\t */\n\tlogo_uri?: string;\n\n\t/**\n\t * OPTIONAL. String containing a space-separated list of scope values that the client can use when requesting access tokens.\n\t */\n\tscope?: string;\n\n\t/**\n\t * OPTIONAL. Array of strings representing ways to contact people responsible for this client, typically email addresses.\n\t */\n\tcontacts?: string[];\n\n\t/**\n\t * OPTIONAL. URL string that points to a human-readable terms of service document for the client.\n\t */\n\ttos_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL string that points to a human-readable privacy policy document.\n\t */\n\tpolicy_uri?: string;\n\n\t/**\n\t * OPTIONAL. URL string referencing the client's JSON Web Key (JWK) Set document.\n\t */\n\tjwks_uri?: string;\n\n\t/**\n\t * OPTIONAL. Client's JSON Web Key Set document value.\n\t */\n\tjwks?: object;\n\n\t/**\n\t * OPTIONAL. A unique identifier string assigned by the client developer or software publisher.\n\t */\n\tsoftware_id?: string;\n\n\t/**\n\t * OPTIONAL. A version identifier string for the client software.\n\t */\n\tsoftware_version?: string;\n\n\t/**\n\t * OPTIONAL. A software statement containing client metadata values about the client software as claims.\n\t */\n\tsoftware_statement?: string;\n\n\t/**\n\t * OPTIONAL. Application type. Usually \"native\" for OAuth clients.\n\t * https://openid.net/specs/openid-connect-registration-1_0.html\n\t */\n\tapplication_type?: 'native' | 'web' | string;\n\n\t/**\n\t * OPTIONAL. Additional metadata fields as defined by extensions.\n\t */\n\t[key: string]: unknown;\n}\n\n/**\n * Response from the dynamic client registration endpoint.\n */\nexport interface IAuthorizationDynamicClientRegistrationResponse {\n\t/**\n\t * REQUIRED. The client identifier issued by the authorization server.\n\t */\n\tclient_id: string;\n\n\t/**\n\t * OPTIONAL. The client secret issued by the authorization server.\n\t * Not returned for public clients.\n\t */\n\tclient_secret?: string;\n\n\t/**\n\t * OPTIONAL. Time at which the client secret will expire in seconds since the Unix Epoch.\n\t */\n\tclient_secret_expires_at?: number;\n\n\t/**\n\t * OPTIONAL. Client name as provided during registration.\n\t */\n\tclient_name?: string;\n\n\t/**\n\t * OPTIONAL. Client URI as provided during registration.\n\t */\n\tclient_uri?: string;\n\n\t/**\n\t * OPTIONAL. Array of redirection URIs as provided during registration.\n\t */\n\tredirect_uris?: string[];\n\n\t/**\n\t * OPTIONAL. Array of grant types allowed for the client.\n\t */\n\tgrant_types?: string[];\n\n\t/**\n\t * OPTIONAL. Array of response types allowed for the client.\n\t */\n\tresponse_types?: string[];\n\n\t/**\n\t * OPTIONAL. Type of authentication method used by the client.\n\t */\n\ttoken_endpoint_auth_method?: string;\n}\n\n/**\n * Response from the authorization endpoint.\n * Typically returned as query parameters in a redirect.\n */\nexport interface IAuthorizationAuthorizeResponse {\n\t/**\n\t * REQUIRED. The authorization code generated by the authorization server.\n\t */\n\tcode: string;\n\n\t/**\n\t * REQUIRED. The state value that was sent in the authorization request.\n\t * Used to prevent CSRF attacks.\n\t */\n\tstate: string;\n}\n\n/**\n * Error response from the authorization endpoint.\n */\nexport interface IAuthorizationAuthorizeErrorResponse {\n\t/**\n\t * REQUIRED. Error code as specified in OAuth 2.0.\n\t */\n\terror: string;\n\n\t/**\n\t * OPTIONAL. Human-readable description of the error.\n\t */\n\terror_description?: string;\n\n\t/**\n\t * OPTIONAL. URI to a human-readable web page with more information about the error.\n\t */\n\terror_uri?: string;\n\n\t/**\n\t * REQUIRED. The state value that was sent in the authorization request.\n\t */\n\tstate: string;\n}\n\n/**\n * Response from the token endpoint.\n */\nexport interface IAuthorizationTokenResponse {\n\t/**\n\t * REQUIRED. The access token issued by the authorization server.\n\t */\n\taccess_token: string;\n\n\t/**\n\t * REQUIRED. The type of the token issued. Usually \"Bearer\".\n\t */\n\ttoken_type: string;\n\n\t/**\n\t * RECOMMENDED. The lifetime in seconds of the access token.\n\t */\n\texpires_in?: number;\n\n\t/**\n\t * OPTIONAL. The refresh token, which can be used to obtain new access tokens.\n\t */\n\trefresh_token?: string;\n\n\t/**\n\t * OPTIONAL. The scope of the access token as a space-delimited list of strings.\n\t */\n\tscope?: string;\n\n\t/**\n\t * OPTIONAL. ID Token value associated with the authenticated session for OpenID Connect flows.\n\t */\n\tid_token?: string;\n}\n\n/**\n * Error response from the token endpoint.\n */\nexport interface IAuthorizationTokenErrorResponse {\n\t/**\n\t * REQUIRED. Error code as specified in OAuth 2.0.\n\t */\n\terror: string;\n\n\t/**\n\t * OPTIONAL. Human-readable description of the error.\n\t */\n\terror_description?: string;\n\n\t/**\n\t * OPTIONAL. URI to a human-readable web page with more information about the error.\n\t */\n\terror_uri?: string;\n}\n\n/**\n * Response from the device authorization endpoint as per RFC 8628 section 3.2.\n */\nexport interface IAuthorizationDeviceResponse {\n\t/**\n\t * REQUIRED. The device verification code.\n\t */\n\tdevice_code: string;\n\n\t/**\n\t * REQUIRED. The end-user verification code.\n\t */\n\tuser_code: string;\n\n\t/**\n\t * REQUIRED. The end-user verification URI on the authorization server.\n\t */\n\tverification_uri: string;\n\n\t/**\n\t * OPTIONAL. A verification URI that includes the user_code, designed for non-textual transmission.\n\t */\n\tverification_uri_complete?: string;\n\n\t/**\n\t * REQUIRED. The lifetime in seconds of the device_code and user_code.\n\t */\n\texpires_in: number;\n\n\t/**\n\t * OPTIONAL. The minimum amount of time in seconds that the client should wait between polling requests.\n\t * If no value is provided, clients must use 5 as the default.\n\t */\n\tinterval?: number;\n}\n\n/**\n * Error response from the token endpoint when using device authorization grant.\n * As defined in RFC 8628 section 3.5.\n */\nexport interface IAuthorizationErrorResponse {\n\t/**\n\t * REQUIRED. Error code as specified in OAuth 2.0 or in RFC 8628 section 3.5.\n\t */\n\terror: AuthorizationErrorType | string;\n\n\t/**\n\t * OPTIONAL. Human-readable description of the error.\n\t */\n\terror_description?: string;\n\n\t/**\n\t * OPTIONAL. URI to a human-readable web page with more information about the error.\n\t */\n\terror_uri?: string;\n}\n\n/**\n * Error response from the token endpoint when using device authorization grant.\n * As defined in RFC 8628 section 3.5.\n */\nexport interface IAuthorizationDeviceTokenErrorResponse extends IAuthorizationErrorResponse {\n\t/**\n\t * REQUIRED. Error code as specified in OAuth 2.0 or in RFC 8628 section 3.5.\n\t */\n\terror: AuthorizationErrorType | AuthorizationDeviceCodeErrorType | string;\n}\n\nexport interface IAuthorizationRegistrationErrorResponse {\n\t/**\n\t * REQUIRED. Error code as specified in OAuth 2.0 or Dynamic Client Registration.\n\t */\n\terror: AuthorizationRegistrationErrorType | string;\n\n\t/**\n\t * OPTIONAL. Human-readable description of the error.\n\t */\n\terror_description?: string;\n}\n\nexport interface IAuthorizationJWTClaims {\n\t/**\n\t * REQUIRED. JWT ID. Unique identifier for the token.\n\t */\n\tjti: string;\n\n\t/**\n\t * REQUIRED. Subject. Principal about which the token asserts information.\n\t */\n\tsub: string;\n\n\t/**\n\t * REQUIRED. Issuer. Entity that issued the token.\n\t */\n\tiss: string;\n\n\t/**\n\t * OPTIONAL. Audience. Recipients that the token is intended for.\n\t */\n\taud?: string | string[];\n\n\t/**\n\t * OPTIONAL. Expiration time. Time after which the token is invalid (seconds since Unix epoch).\n\t */\n\texp?: number;\n\n\t/**\n\t * OPTIONAL. Not before time. Time before which the token is not valid (seconds since Unix epoch).\n\t */\n\tnbf?: number;\n\n\t/**\n\t * OPTIONAL. Issued at time when the token was issued (seconds since Unix epoch).\n\t */\n\tiat?: number;\n\n\t/**\n\t * OPTIONAL. Authorized party. The party to which the token was issued.\n\t */\n\tazp?: string;\n\n\t/**\n\t * OPTIONAL. Scope values for which the token is valid.\n\t */\n\tscope?: string;\n\n\t/**\n\t * OPTIONAL. Full name of the user.\n\t */\n\tname?: string;\n\n\t/**\n\t * OPTIONAL. Given or first name of the user.\n\t */\n\tgiven_name?: string;\n\n\t/**\n\t * OPTIONAL. Family name or last name of the user.\n\t */\n\tfamily_name?: string;\n\n\t/**\n\t * OPTIONAL. Middle name of the user.\n\t */\n\tmiddle_name?: string;\n\n\t/**\n\t * OPTIONAL. Preferred username or email the user wishes to be referred to.\n\t */\n\tpreferred_username?: string;\n\n\t/**\n\t * OPTIONAL. Email address of the user.\n\t */\n\temail?: string;\n\n\t/**\n\t * OPTIONAL. True if the user's email has been verified.\n\t */\n\temail_verified?: boolean;\n\n\t/**\n\t * OPTIONAL. User's profile picture URL.\n\t */\n\tpicture?: string;\n\n\t/**\n\t * OPTIONAL. Authentication time. Time when the user authentication occurred.\n\t */\n\tauth_time?: number;\n\n\t/**\n\t * OPTIONAL. Authentication context class reference.\n\t */\n\tacr?: string;\n\n\t/**\n\t * OPTIONAL. Authentication methods references.\n\t */\n\tamr?: string[];\n\n\t/**\n\t * OPTIONAL. Session ID. String identifier for a session.\n\t */\n\tsid?: string;\n\n\t/**\n\t * OPTIONAL. Address component.\n\t */\n\taddress?: {\n\t\tformatted?: string;\n\t\tstreet_address?: string;\n\t\tlocality?: string;\n\t\tregion?: string;\n\t\tpostal_code?: string;\n\t\tcountry?: string;\n\t};\n\n\t/**\n\t * OPTIONAL. Groups that the user belongs to.\n\t */\n\tgroups?: string[];\n\n\t/**\n\t * OPTIONAL. Roles assigned to the user.\n\t */\n\troles?: string[];\n\n\t/**\n\t * OPTIONAL. Handles optional claims that are not explicitly defined in the standard.\n\t */\n\t[key: string]: unknown;\n}\n\n//#endregion\n\n//#region is functions\n\nexport function isAuthorizationProtectedResourceMetadata(obj: unknown): obj is IAuthorizationProtectedResourceMetadata {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\n\tconst metadata = obj as IAuthorizationProtectedResourceMetadata;\n\tif (!metadata.resource) {\n\t\treturn false;\n\t}\n\tif (metadata.scopes_supported !== undefined && !Array.isArray(metadata.scopes_supported)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst urisToCheck: Array<keyof IAuthorizationServerMetadata> = [\n\t'issuer',\n\t'authorization_endpoint',\n\t'token_endpoint',\n\t'registration_endpoint',\n\t'jwks_uri'\n];\nexport function isAuthorizationServerMetadata(obj: unknown): obj is IAuthorizationServerMetadata {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst metadata = obj as IAuthorizationServerMetadata;\n\tif (!metadata.issuer) {\n\t\tthrow new Error('Authorization server metadata must have an issuer');\n\t}\n\n\tfor (const uri of urisToCheck) {\n\t\tif (!metadata[uri]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (typeof metadata[uri] !== 'string') {\n\t\t\tthrow new Error(`Authorization server metadata '${uri}' must be a string`);\n\t\t}\n\t\tif (!metadata[uri].startsWith('https://') && !metadata[uri].startsWith('http://')) {\n\t\t\tthrow new Error(`Authorization server metadata '${uri}' must start with http:// or https://`);\n\t\t}\n\t}\n\treturn true;\n}\n\nexport function isAuthorizationDynamicClientRegistrationResponse(obj: unknown): obj is IAuthorizationDynamicClientRegistrationResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationDynamicClientRegistrationResponse;\n\treturn response.client_id !== undefined;\n}\n\nexport function isAuthorizationAuthorizeResponse(obj: unknown): obj is IAuthorizationAuthorizeResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationAuthorizeResponse;\n\treturn response.code !== undefined && response.state !== undefined;\n}\n\nexport function isAuthorizationTokenResponse(obj: unknown): obj is IAuthorizationTokenResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationTokenResponse;\n\treturn response.access_token !== undefined && response.token_type !== undefined;\n}\n\nexport function isAuthorizationDeviceResponse(obj: unknown): obj is IAuthorizationDeviceResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationDeviceResponse;\n\treturn response.device_code !== undefined && response.user_code !== undefined && response.verification_uri !== undefined && response.expires_in !== undefined;\n}\n\nexport function isAuthorizationErrorResponse(obj: unknown): obj is IAuthorizationErrorResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationErrorResponse;\n\treturn response.error !== undefined;\n}\n\nexport function isAuthorizationRegistrationErrorResponse(obj: unknown): obj is IAuthorizationRegistrationErrorResponse {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\tconst response = obj as IAuthorizationRegistrationErrorResponse;\n\treturn response.error !== undefined;\n}\n\n//#endregion\n\nexport function getDefaultMetadataForUrl(authorizationServer: URL): IAuthorizationServerMetadata {\n\treturn {\n\t\tissuer: authorizationServer.toString(),\n\t\tauthorization_endpoint: new URL('/authorize', authorizationServer).toString(),\n\t\ttoken_endpoint: new URL('/token', authorizationServer).toString(),\n\t\tregistration_endpoint: new URL('/register', authorizationServer).toString(),\n\t\t// Default values for Dynamic OpenID Providers\n\t\t// https://openid.net/specs/openid-connect-discovery-1_0.html\n\t\tresponse_types_supported: ['code', 'id_token', 'id_token token'],\n\t};\n}\n\n/**\n * The grant types that we support\n */\nconst grantTypesSupported = ['authorization_code', 'refresh_token', 'urn:ietf:params:oauth:grant-type:device_code'];\n\n/**\n * Default port for the authorization flow. We try to use this port so that\n * the redirect URI does not change when running on localhost. This is useful\n * for servers that only allow exact matches on the redirect URI. The spec\n * says that the port should not matter, but some servers do not follow\n * the spec and require an exact match.\n */\nexport const DEFAULT_AUTH_FLOW_PORT = 33418;\nexport async function fetchDynamicRegistration(serverMetadata: IAuthorizationServerMetadata, clientName: string, scopes?: string[]): Promise<IAuthorizationDynamicClientRegistrationResponse> {\n\tif (!serverMetadata.registration_endpoint) {\n\t\tthrow new Error('Server does not support dynamic registration');\n\t}\n\n\tconst requestBody: IAuthorizationDynamicClientRegistrationRequest = {\n\t\tclient_name: clientName,\n\t\tclient_uri: 'https://code.visualstudio.com',\n\t\tgrant_types: serverMetadata.grant_types_supported\n\t\t\t? serverMetadata.grant_types_supported.filter(gt => grantTypesSupported.includes(gt))\n\t\t\t: grantTypesSupported,\n\t\tresponse_types: ['code'],\n\t\tredirect_uris: [\n\t\t\t'https://insiders.vscode.dev/redirect',\n\t\t\t'https://vscode.dev/redirect',\n\t\t\t'http://127.0.0.1/',\n\t\t\t// Added these for any server that might do\n\t\t\t// only exact match on the redirect URI even\n\t\t\t// though the spec says it should not care\n\t\t\t// about the port.\n\t\t\t`http://127.0.0.1:${DEFAULT_AUTH_FLOW_PORT}/`\n\t\t],\n\t\tscope: scopes?.join(AUTH_SCOPE_SEPARATOR),\n\t\ttoken_endpoint_auth_method: 'none',\n\t\tapplication_type: 'native'\n\t};\n\n\tconst response = await fetch(serverMetadata.registration_endpoint, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json'\n\t\t},\n\t\tbody: JSON.stringify(requestBody)\n\t});\n\n\tif (!response.ok) {\n\t\tconst result = await response.text();\n\t\tlet errorDetails: string = result;\n\n\t\ttry {\n\t\t\tconst errorResponse = JSON.parse(result);\n\t\t\tif (isAuthorizationRegistrationErrorResponse(errorResponse)) {\n\t\t\t\terrorDetails = `${errorResponse.error}${errorResponse.error_description ? `: ${errorResponse.error_description}` : ''}`;\n\t\t\t}\n\t\t} catch {\n\t\t\t// JSON parsing failed, use raw text\n\t\t}\n\n\t\tthrow new Error(`Registration to ${serverMetadata.registration_endpoint} failed: ${errorDetails}`);\n\t}\n\n\tconst registration = await response.json();\n\tif (isAuthorizationDynamicClientRegistrationResponse(registration)) {\n\t\treturn registration;\n\t}\n\tthrow new Error(`Invalid authorization dynamic client registration response: ${JSON.stringify(registration)}`);\n}\n\nexport interface IAuthenticationChallenge {\n\tscheme: string;\n\tparams: Record<string, string>;\n}\n\nexport function parseWWWAuthenticateHeader(wwwAuthenticateHeaderValue: string): IAuthenticationChallenge[] {\n\tconst challenges: IAuthenticationChallenge[] = [];\n\n\t// According to RFC 7235, multiple challenges are separated by commas\n\t// But parameters within a challenge can also be separated by commas\n\t// We need to identify scheme names to know where challenges start\n\n\t// First, split by commas while respecting quoted strings\n\tconst tokens: string[] = [];\n\tlet current = '';\n\tlet inQuotes = false;\n\n\tfor (let i = 0; i < wwwAuthenticateHeaderValue.length; i++) {\n\t\tconst char = wwwAuthenticateHeaderValue[i];\n\n\t\tif (char === '\"') {\n\t\t\tinQuotes = !inQuotes;\n\t\t\tcurrent += char;\n\t\t} else if (char === ',' && !inQuotes) {\n\t\t\tif (current.trim()) {\n\t\t\t\ttokens.push(current.trim());\n\t\t\t}\n\t\t\tcurrent = '';\n\t\t} else {\n\t\t\tcurrent += char;\n\t\t}\n\t}\n\n\tif (current.trim()) {\n\t\ttokens.push(current.trim());\n\t}\n\n\t// Now process tokens to identify challenges\n\t// A challenge starts with a scheme name (a token that doesn't contain '=' and is followed by parameters or is standalone)\n\tlet currentChallenge: { scheme: string; params: Record<string, string> } | undefined;\n\n\tfor (const token of tokens) {\n\t\tconst hasEquals = token.includes('=');\n\n\t\tif (!hasEquals) {\n\t\t\t// This token doesn't have '=', so it's likely a scheme name\n\t\t\tif (currentChallenge) {\n\t\t\t\tchallenges.push(currentChallenge);\n\t\t\t}\n\t\t\tcurrentChallenge = { scheme: token.trim(), params: {} };\n\t\t} else {\n\t\t\t// This token has '=', it could be:\n\t\t\t// 1. A parameter for the current challenge\n\t\t\t// 2. A new challenge that starts with \"Scheme param=value\"\n\n\t\t\tconst spaceIndex = token.indexOf(' ');\n\t\t\tif (spaceIndex > 0) {\n\t\t\t\tconst beforeSpace = token.substring(0, spaceIndex);\n\t\t\t\tconst afterSpace = token.substring(spaceIndex + 1);\n\n\t\t\t\t// Check if what's before the space looks like a scheme name (no '=')\n\t\t\t\tif (!beforeSpace.includes('=') && afterSpace.includes('=')) {\n\t\t\t\t\t// This is a new challenge starting with \"Scheme param=value\"\n\t\t\t\t\tif (currentChallenge) {\n\t\t\t\t\t\tchallenges.push(currentChallenge);\n\t\t\t\t\t}\n\t\t\t\t\tcurrentChallenge = { scheme: beforeSpace.trim(), params: {} };\n\n\t\t\t\t\t// Parse the parameter part\n\t\t\t\t\tconst equalIndex = afterSpace.indexOf('=');\n\t\t\t\t\tif (equalIndex > 0) {\n\t\t\t\t\t\tconst key = afterSpace.substring(0, equalIndex).trim();\n\t\t\t\t\t\tconst value = afterSpace.substring(equalIndex + 1).trim().replace(/^\"|\"$/g, '');\n\t\t\t\t\t\tif (key && value !== undefined) {\n\t\t\t\t\t\t\tcurrentChallenge.params[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// This is a parameter for the current challenge\n\t\t\tif (currentChallenge) {\n\t\t\t\tconst equalIndex = token.indexOf('=');\n\t\t\t\tif (equalIndex > 0) {\n\t\t\t\t\tconst key = token.substring(0, equalIndex).trim();\n\t\t\t\t\tconst value = token.substring(equalIndex + 1).trim().replace(/^\"|\"$/g, '');\n\t\t\t\t\tif (key && value !== undefined) {\n\t\t\t\t\t\tcurrentChallenge.params[key] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Don't forget the last challenge\n\tif (currentChallenge) {\n\t\tchallenges.push(currentChallenge);\n\t}\n\n\treturn challenges;\n}\n\nexport function getClaimsFromJWT(token: string): IAuthorizationJWTClaims {\n\tconst parts = token.split('.');\n\tif (parts.length !== 3) {\n\t\tthrow new Error('Invalid JWT token format: token must have three parts separated by dots');\n\t}\n\n\tconst [header, payload, _signature] = parts;\n\n\ttry {\n\t\tconst decodedHeader = JSON.parse(decodeBase64(header).toString());\n\t\tif (typeof decodedHeader !== 'object') {\n\t\t\tthrow new Error('Invalid JWT token format: header is not a JSON object');\n\t\t}\n\n\t\tconst decodedPayload = JSON.parse(decodeBase64(payload).toString());\n\t\tif (typeof decodedPayload !== 'object') {\n\t\t\tthrow new Error('Invalid JWT token format: payload is not a JSON object');\n\t\t}\n\n\t\treturn decodedPayload;\n\t} catch (e) {\n\t\tif (e instanceof Error) {\n\t\t\tthrow new Error(`Failed to parse JWT token: ${e.message}`);\n\t\t}\n\t\tthrow new Error('Failed to parse JWT token');\n\t}\n}\n\n/**\n * Checks if two scope lists are equivalent, regardless of order.\n * This is useful for comparing OAuth scopes where the order should not matter.\n *\n * @param scopes1 First list of scopes to compare (can be undefined)\n * @param scopes2 Second list of scopes to compare (can be undefined)\n * @returns true if the scope lists contain the same scopes (order-independent), false otherwise\n *\n * @example\n * ```typescript\n * scopesMatch(['read', 'write'], ['write', 'read']) // Returns: true\n * scopesMatch(['read'], ['write']) // Returns: false\n * scopesMatch(undefined, undefined) // Returns: true\n * scopesMatch(['read'], undefined) // Returns: false\n * ```\n */\nexport function scopesMatch(scopes1: readonly string[] | undefined, scopes2: readonly string[] | undefined): boolean {\n\tif (scopes1 === scopes2) {\n\t\treturn true;\n\t}\n\tif (!scopes1 || !scopes2) {\n\t\treturn false;\n\t}\n\tif (scopes1.length !== scopes2.length) {\n\t\treturn false;\n\t}\n\n\t// Sort both arrays for comparison to handle different orderings\n\tconst sortedScopes1 = [...scopes1].sort();\n\tconst sortedScopes2 = [...scopes2].sort();\n\n\treturn sortedScopes1.every((scope, index) => scope === sortedScopes2[index]);\n}\n\ninterface CommonResponse {\n\tstatus: number;\n\tstatusText: string;\n\tjson(): Promise<unknown>;\n\ttext(): Promise<string>;\n}\n\ninterface IFetcher {\n\t(input: string, init: { method: string; headers: Record<string, string> }): Promise<CommonResponse>;\n}\n\nexport interface IFetchResourceMetadataOptions {\n\t/**\n\t * Headers to include only when the resource metadata URL has the same origin as the target resource\n\t */\n\tsameOriginHeaders?: Record<string, string>;\n\t/**\n\t * Optional custom fetch implementation (defaults to global fetch)\n\t */\n\tfetch?: IFetcher;\n}\n\n/**\n * Fetches and validates OAuth 2.0 protected resource metadata from the given URL.\n *\n * @param targetResource The target resource URL to compare origins with (e.g., the MCP server URL)\n * @param resourceMetadataUrl Optional URL to fetch the resource metadata from. If not provided, will try well-known URIs.\n * @param options Configuration options for the fetch operation\n * @returns Promise that resolves to the validated resource metadata\n * @throws Error if the fetch fails, returns non-200 status, or the response is invalid\n */\nexport async function fetchResourceMetadata(\n\ttargetResource: string,\n\tresourceMetadataUrl: string | undefined,\n\toptions: IFetchResourceMetadataOptions = {}\n): Promise<IAuthorizationProtectedResourceMetadata> {\n\tconst {\n\t\tsameOriginHeaders = {},\n\t\tfetch: fetchImpl = fetch\n\t} = options;\n\n\tconst targetResourceUrlObj = new URL(targetResource);\n\n\t// If no resourceMetadataUrl is provided, try well-known URIs as per RFC 9728\n\tlet urlsToTry: string[];\n\tif (!resourceMetadataUrl) {\n\t\t// Try in order: 1) with path appended, 2) at root\n\t\tconst pathComponent = targetResourceUrlObj.pathname === '/' ? undefined : targetResourceUrlObj.pathname;\n\t\tconst rootUrl = `${targetResourceUrlObj.origin}${AUTH_PROTECTED_RESOURCE_METADATA_DISCOVERY_PATH}`;\n\t\tif (pathComponent) {\n\t\t\t// Only try both URLs if we have a path component\n\t\t\turlsToTry = [\n\t\t\t\t`${rootUrl}${pathComponent}`,\n\t\t\t\trootUrl\n\t\t\t];\n\t\t} else {\n\t\t\t// If target is already at root, only try the root URL once\n\t\t\turlsToTry = [rootUrl];\n\t\t}\n\t} else {\n\t\turlsToTry = [resourceMetadataUrl];\n\t}\n\n\tconst errors: Error[] = [];\n\tfor (const urlToTry of urlsToTry) {\n\t\ttry {\n\t\t\t// Determine if we should include same-origin headers\n\t\t\tlet headers: Record<string, string> = {\n\t\t\t\t'Accept': 'application/json'\n\t\t\t};\n\n\t\t\tconst resourceMetadataUrlObj = new URL(urlToTry);\n\t\t\tif (resourceMetadataUrlObj.origin === targetResourceUrlObj.origin) {\n\t\t\t\theaders = {\n\t\t\t\t\t...headers,\n\t\t\t\t\t...sameOriginHeaders\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst response = await fetchImpl(urlToTry, { method: 'GET', headers });\n\t\t\tif (response.status !== 200) {\n\t\t\t\tlet errorText: string;\n\t\t\t\ttry {\n\t\t\t\t\terrorText = await response.text();\n\t\t\t\t} catch {\n\t\t\t\t\terrorText = response.statusText;\n\t\t\t\t}\n\t\t\t\terrors.push(new Error(`Failed to fetch resource metadata from ${urlToTry}: ${response.status} ${errorText}`));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst body = await response.json();\n\t\t\tif (isAuthorizationProtectedResourceMetadata(body)) {\n\t\t\t\t// Use URL constructor for normalization - it handles hostname case and trailing slashes\n\t\t\t\tconst prmValue = new URL(body.resource).toString();\n\t\t\t\tconst targetValue = targetResourceUrlObj.toString();\n\t\t\t\tif (prmValue !== targetValue) {\n\t\t\t\t\tthrow new Error(`Protected Resource Metadata resource property value \"${prmValue}\" (length: ${prmValue.length}) does not match target server url \"${targetValue}\" (length: ${targetValue.length}). These MUST match to follow OAuth spec https://datatracker.ietf.org/doc/html/rfc9728#PRConfigurationValidation`);\n\t\t\t\t}\n\t\t\t\treturn body;\n\t\t\t} else {\n\t\t\t\terrors.push(new Error(`Invalid resource metadata from ${urlToTry}. Expected to follow shape of https://datatracker.ietf.org/doc/html/rfc9728#name-protected-resource-metadata (Hints: is scopes_supported an array? Is resource a string?). Current payload: ${JSON.stringify(body)}`));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\terrors.push(e instanceof Error ? e : new Error(String(e)));\n\t\t\tcontinue;\n\t\t}\n\t}\n\t// If we've tried all URLs and none worked, throw the error(s)\n\tif (errors.length === 1) {\n\t\tthrow errors[0];\n\t} else {\n\t\tthrow new AggregateError(errors, 'Failed to fetch resource metadata from all attempted URLs');\n\t}\n}\n\nexport interface IFetchAuthorizationServerMetadataOptions {\n\t/**\n\t * Headers to include in the requests\n\t */\n\tadditionalHeaders?: Record<string, string>;\n\t/**\n\t * Optional custom fetch implementation (defaults to global fetch)\n\t */\n\tfetch?: IFetcher;\n}\n\n/** Helper to try parsing the response as authorization server metadata */\nasync function tryParseAuthServerMetadata(response: CommonResponse): Promise<IAuthorizationServerMetadata | undefined> {\n\tif (response.status !== 200) {\n\t\treturn undefined;\n\t}\n\ttry {\n\t\tconst body = await response.json();\n\t\tif (isAuthorizationServerMetadata(body)) {\n\t\t\treturn body;\n\t\t}\n\t} catch {\n\t\t// Failed to parse as JSON or not valid metadata\n\t}\n\treturn undefined;\n}\n\n/** Helper to get error text from response */\nasync function getErrText(res: CommonResponse): Promise<string> {\n\ttry {\n\t\treturn await res.text();\n\t} catch {\n\t\treturn res.statusText;\n\t}\n}\n\n/**\n * Fetches and validates OAuth 2.0 authorization server metadata from the given authorization server URL.\n *\n * This function tries multiple discovery endpoints in the following order:\n * 1. OAuth 2.0 Authorization Server Metadata with path insertion (RFC 8414)\n * 2. OpenID Connect Discovery with path insertion\n * 3. OpenID Connect Discovery with path addition\n *\n * Path insertion: For issuer URLs with path components (e.g., https://example.com/tenant),\n * the well-known path is inserted after the origin and before the path:\n * https://example.com/.well-known/oauth-authorization-server/tenant\n *\n * Path addition: The well-known path is simply appended to the existing path:\n * https://example.com/tenant/.well-known/openid-configuration\n *\n * @param authorizationServer The authorization server URL (issuer identifier)\n * @param options Configuration options for the fetch operation\n * @returns Promise that resolves to the validated authorization server metadata\n * @throws Error if all discovery attempts fail or the response is invalid\n *\n * @see https://datatracker.ietf.org/doc/html/rfc8414#section-3\n */\nexport async function fetchAuthorizationServerMetadata(\n\tauthorizationServer: string,\n\toptions: IFetchAuthorizationServerMetadataOptions = {}\n): Promise<IAuthorizationServerMetadata> {\n\tconst {\n\t\tadditionalHeaders = {},\n\t\tfetch: fetchImpl = fetch\n\t} = options;\n\n\tconst authorizationServerUrl = new URL(authorizationServer);\n\tconst extraPath = authorizationServerUrl.pathname === '/' ? '' : authorizationServerUrl.pathname;\n\n\tconst errors: Error[] = [];\n\n\tconst doFetch = async (url: string): Promise<IAuthorizationServerMetadata | undefined> => {\n\t\ttry {\n\t\t\tconst rawResponse = await fetchImpl(url, {\n\t\t\t\tmethod: 'GET',\n\t\t\t\theaders: {\n\t\t\t\t\t...additionalHeaders,\n\t\t\t\t\t'Accept': 'application/json'\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst metadata = await tryParseAuthServerMetadata(rawResponse);\n\t\t\tif (metadata) {\n\t\t\t\treturn metadata;\n\t\t\t}\n\t\t\t// No metadata found, collect error from response\n\t\t\terrors.push(new Error(`Failed to fetch authorization server metadata from ${url}: ${rawResponse.status} ${await getErrText(rawResponse)}`));\n\t\t\treturn undefined;\n\t\t} catch (e) {\n\t\t\t// Collect error from fetch failure\n\t\t\terrors.push(e instanceof Error ? e : new Error(String(e)));\n\t\t\treturn undefined;\n\t\t}\n\t};\n\n\t// For the oauth server metadata discovery path, we _INSERT_\n\t// the well known path after the origin and before the path.\n\t// https://datatracker.ietf.org/doc/html/rfc8414#section-3\n\tconst pathToFetch = new URL(AUTH_SERVER_METADATA_DISCOVERY_PATH, authorizationServer).toString() + extraPath;\n\tlet metadata = await doFetch(pathToFetch);\n\tif (metadata) {\n\t\treturn metadata;\n\t}\n\n\t// Try fetching the OpenID Connect Discovery with path insertion.\n\t// For issuer URLs with path components, this inserts the well-known path\n\t// after the origin and before the path.\n\tconst openidPathInsertionUrl = new URL(OPENID_CONNECT_DISCOVERY_PATH, authorizationServer).toString() + extraPath;\n\tmetadata = await doFetch(openidPathInsertionUrl);\n\tif (metadata) {\n\t\treturn metadata;\n\t}\n\n\t// Try fetching the other discovery URL. For the openid metadata discovery\n\t// path, we _ADD_ the well known path after the existing path.\n\t// https://datatracker.ietf.org/doc/html/rfc8414#section-3\n\tconst openidPathAdditionUrl = authorizationServer.endsWith('/')\n\t\t? authorizationServer + OPENID_CONNECT_DISCOVERY_PATH.substring(1) // Remove leading slash if authServer ends with slash\n\t\t: authorizationServer + OPENID_CONNECT_DISCOVERY_PATH;\n\tmetadata = await doFetch(openidPathAdditionUrl);\n\tif (metadata) {\n\t\treturn metadata;\n\t}\n\n\t// If we've tried all URLs and none worked, throw the error(s)\n\tif (errors.length === 1) {\n\t\tthrow errors[0];\n\t} else {\n\t\tthrow new AggregateError(errors, 'Failed to fetch authorization server metadata from all attempted URLs');\n\t}\n}\n"]}