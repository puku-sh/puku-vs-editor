{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/jsonSchema.ts","vs/base/common/jsonSchema.ts"],"names":[],"mappings":"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","file":"jsonSchema.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type JSONSchemaType = 'string' | 'number' | 'integer' | 'boolean' | 'null' | 'array' | 'object';\n\nexport interface IJSONSchema {\n\tid?: string;\n\t$id?: string;\n\t$schema?: string;\n\ttype?: JSONSchemaType | JSONSchemaType[];\n\ttitle?: string;\n\tdefault?: any;\n\tdefinitions?: IJSONSchemaMap;\n\tdescription?: string;\n\tproperties?: IJSONSchemaMap;\n\tpatternProperties?: IJSONSchemaMap;\n\tadditionalProperties?: boolean | IJSONSchema;\n\tminProperties?: number;\n\tmaxProperties?: number;\n\tdependencies?: IJSONSchemaMap | { [prop: string]: string[] };\n\titems?: IJSONSchema | IJSONSchema[];\n\tminItems?: number;\n\tmaxItems?: number;\n\tuniqueItems?: boolean;\n\tadditionalItems?: boolean | IJSONSchema;\n\tpattern?: string;\n\tminLength?: number;\n\tmaxLength?: number;\n\tminimum?: number;\n\tmaximum?: number;\n\texclusiveMinimum?: boolean | number;\n\texclusiveMaximum?: boolean | number;\n\tmultipleOf?: number;\n\trequired?: string[];\n\t$ref?: string;\n\tanyOf?: IJSONSchema[];\n\tallOf?: IJSONSchema[];\n\toneOf?: IJSONSchema[];\n\tnot?: IJSONSchema;\n\tenum?: any[];\n\tformat?: string;\n\n\t// schema draft 06\n\tconst?: any;\n\tcontains?: IJSONSchema;\n\tpropertyNames?: IJSONSchema;\n\texamples?: any[];\n\n\t// schema draft 07\n\t$comment?: string;\n\tif?: IJSONSchema;\n\tthen?: IJSONSchema;\n\telse?: IJSONSchema;\n\n\t// schema 2019-09\n\tunevaluatedProperties?: boolean | IJSONSchema;\n\tunevaluatedItems?: boolean | IJSONSchema;\n\tminContains?: number;\n\tmaxContains?: number;\n\tdeprecated?: boolean;\n\tdependentRequired?: { [prop: string]: string[] };\n\tdependentSchemas?: IJSONSchemaMap;\n\t$defs?: { [name: string]: IJSONSchema };\n\t$anchor?: string;\n\t$recursiveRef?: string;\n\t$recursiveAnchor?: string;\n\t$vocabulary?: any;\n\n\t// schema 2020-12\n\tprefixItems?: IJSONSchema[];\n\t$dynamicRef?: string;\n\t$dynamicAnchor?: string;\n\n\t// VSCode extensions\n\n\tdefaultSnippets?: IJSONSchemaSnippet[];\n\terrorMessage?: string;\n\tpatternErrorMessage?: string;\n\tdeprecationMessage?: string;\n\tmarkdownDeprecationMessage?: string;\n\tenumDescriptions?: string[];\n\tmarkdownEnumDescriptions?: string[];\n\tmarkdownDescription?: string;\n\tdoNotSuggest?: boolean;\n\tsuggestSortText?: string;\n\tallowComments?: boolean;\n\tallowTrailingCommas?: boolean;\n}\n\nexport interface IJSONSchemaMap {\n\t[name: string]: IJSONSchema;\n}\n\nexport interface IJSONSchemaSnippet {\n\tlabel?: string;\n\tdescription?: string;\n\tbody?: any; // a object that will be JSON stringified\n\tbodyText?: string; // an already stringified JSON object that can contain new lines (\\n) and tabs (\\t)\n}\n\n/**\n * Converts a basic JSON schema to a TypeScript type.\n */\nexport type TypeFromJsonSchema<T> =\n\t// enum\n\tT extends { enum: infer EnumValues }\n\t? UnionOf<EnumValues>\n\n\t// Object with list of required properties.\n\t// Values are required or optional based on `required` list.\n\t: T extends { type: 'object'; properties: infer P; required: infer RequiredList }\n\t? {\n\t\t[K in keyof P]: IsRequired<K, RequiredList> extends true ? TypeFromJsonSchema<P[K]> : TypeFromJsonSchema<P[K]> | undefined;\n\t} & AdditionalPropertiesType<T>\n\n\t// Object with no required properties.\n\t// All values are optional\n\t: T extends { type: 'object'; properties: infer P }\n\t? { [K in keyof P]: TypeFromJsonSchema<P[K]> | undefined } & AdditionalPropertiesType<T>\n\n\t// Array\n\t: T extends { type: 'array'; items: infer Items }\n\t? Items extends [...infer R]\n\t// If items is an array, we treat it like a tuple\n\t? { [K in keyof R]: TypeFromJsonSchema<Items[K]> }\n\t: Array<TypeFromJsonSchema<Items>>\n\n\t// oneOf / anyof\n\t// These are handled the same way as they both represent a union type.\n\t// However at the validation level, they have different semantics.\n\t: T extends { oneOf: infer I }\n\t? MapSchemaToType<I>\n\t: T extends { anyOf: infer I }\n\t? MapSchemaToType<I>\n\n\t// Primitive types\n\t: T extends { type: infer Type }\n\t// Basic type\n\t? Type extends 'string' | 'number' | 'integer' | 'boolean' | 'null'\n\t? SchemaPrimitiveTypeNameToType<Type>\n\t// Union of primitive types\n\t: Type extends [...infer R]\n\t? UnionOf<{ [K in keyof R]: SchemaPrimitiveTypeNameToType<R[K]> }>\n\t: never\n\n\t// Fallthrough\n\t: never;\n\ntype SchemaPrimitiveTypeNameToType<T> =\n\tT extends 'string' ? string :\n\tT extends 'number' | 'integer' ? number :\n\tT extends 'boolean' ? boolean :\n\tT extends 'null' ? null :\n\tnever;\n\ntype UnionOf<T> =\n\tT extends [infer First, ...infer Rest]\n\t? First | UnionOf<Rest>\n\t: never;\n\ntype IsRequired<K, RequiredList> =\n\tRequiredList extends []\n\t? false\n\n\t: RequiredList extends [K, ...infer _]\n\t? true\n\n\t: RequiredList extends [infer _, ...infer R]\n\t? IsRequired<K, R>\n\n\t: false;\n\ntype AdditionalPropertiesType<Schema> =\n\tSchema extends { additionalProperties: infer AP }\n\t? AP extends false ? {} : { [key: string]: TypeFromJsonSchema<Schema['additionalProperties']> }\n\t: {};\n\ntype MapSchemaToType<T> = T extends [infer First, ...infer Rest]\n\t? TypeFromJsonSchema<First> | MapSchemaToType<Rest>\n\t: never;\n\ninterface Equals { schemas: IJSONSchema[]; id?: string }\n\nexport function getCompressedContent(schema: IJSONSchema): string {\n\tlet hasDups = false;\n\n\n\t// visit all schema nodes and collect the ones that are equal\n\tconst equalsByString = new Map<string, Equals>();\n\tconst nodeToEquals = new Map<IJSONSchema, Equals>();\n\tconst visitSchemas = (next: IJSONSchema) => {\n\t\tif (schema === next) {\n\t\t\treturn true;\n\t\t}\n\t\tconst val = JSON.stringify(next);\n\t\tif (val.length < 30) {\n\t\t\t// the $ref takes around 25 chars, so we don't save anything\n\t\t\treturn true;\n\t\t}\n\t\tconst eq = equalsByString.get(val);\n\t\tif (!eq) {\n\t\t\tconst newEq = { schemas: [next] };\n\t\t\tequalsByString.set(val, newEq);\n\t\t\tnodeToEquals.set(next, newEq);\n\t\t\treturn true;\n\t\t}\n\t\teq.schemas.push(next);\n\t\tnodeToEquals.set(next, eq);\n\t\thasDups = true;\n\t\treturn false;\n\t};\n\ttraverseNodes(schema, visitSchemas);\n\tequalsByString.clear();\n\n\tif (!hasDups) {\n\t\treturn JSON.stringify(schema);\n\t}\n\n\tlet defNodeName = '$defs';\n\twhile (schema.hasOwnProperty(defNodeName)) {\n\t\tdefNodeName += '_';\n\t}\n\n\t// used to collect all schemas that are later put in `$defs`. The index in the array is the id of the schema.\n\tconst definitions: IJSONSchema[] = [];\n\n\tfunction stringify(root: IJSONSchema): string {\n\t\treturn JSON.stringify(root, (_key: string, value: any) => {\n\t\t\tif (value !== root) {\n\t\t\t\tconst eq = nodeToEquals.get(value);\n\t\t\t\tif (eq && eq.schemas.length > 1) {\n\t\t\t\t\tif (!eq.id) {\n\t\t\t\t\t\teq.id = `_${definitions.length}`;\n\t\t\t\t\t\tdefinitions.push(eq.schemas[0]);\n\t\t\t\t\t}\n\t\t\t\t\treturn { $ref: `#/${defNodeName}/${eq.id}` };\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t});\n\t}\n\n\t// stringify the schema and replace duplicate subtrees with $ref\n\t// this will add new items to the definitions array\n\tconst str = stringify(schema);\n\n\t// now stringify the definitions. Each invication of stringify cann add new items to the definitions array, so the length can grow while we iterate\n\tconst defStrings: string[] = [];\n\tfor (let i = 0; i < definitions.length; i++) {\n\t\tdefStrings.push(`\"_${i}\":${stringify(definitions[i])}`);\n\t}\n\tif (defStrings.length) {\n\t\treturn `${str.substring(0, str.length - 1)},\"${defNodeName}\":{${defStrings.join(',')}}}`;\n\t}\n\treturn str;\n}\n\ntype IJSONSchemaRef = IJSONSchema | boolean;\n\nfunction isObject(thing: unknown): thing is object {\n\treturn typeof thing === 'object' && thing !== null;\n}\n\n/*\n * Traverse a JSON schema and visit each schema node\n*/\nfunction traverseNodes(root: IJSONSchema, visit: (schema: IJSONSchema) => boolean) {\n\tif (!root || typeof root !== 'object') {\n\t\treturn;\n\t}\n\tconst collectEntries = (...entries: (IJSONSchemaRef | undefined)[]) => {\n\t\tfor (const entry of entries) {\n\t\t\tif (isObject(entry)) {\n\t\t\t\ttoWalk.push(entry);\n\t\t\t}\n\t\t}\n\t};\n\tconst collectMapEntries = (...maps: (IJSONSchemaMap | undefined)[]) => {\n\t\tfor (const map of maps) {\n\t\t\tif (isObject(map)) {\n\t\t\t\tfor (const key in map) {\n\t\t\t\t\tconst entry = map[key];\n\t\t\t\t\tif (isObject(entry)) {\n\t\t\t\t\t\ttoWalk.push(entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tconst collectArrayEntries = (...arrays: (IJSONSchemaRef[] | undefined)[]) => {\n\t\tfor (const array of arrays) {\n\t\t\tif (Array.isArray(array)) {\n\t\t\t\tfor (const entry of array) {\n\t\t\t\t\tif (isObject(entry)) {\n\t\t\t\t\t\ttoWalk.push(entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tconst collectEntryOrArrayEntries = (items: (IJSONSchemaRef[] | IJSONSchemaRef | undefined)) => {\n\t\tif (Array.isArray(items)) {\n\t\t\tfor (const entry of items) {\n\t\t\t\tif (isObject(entry)) {\n\t\t\t\t\ttoWalk.push(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(items)) {\n\t\t\ttoWalk.push(items);\n\t\t}\n\t};\n\n\tconst toWalk: IJSONSchema[] = [root];\n\n\tlet next = toWalk.pop();\n\twhile (next) {\n\t\tconst visitChildern = visit(next);\n\t\tif (visitChildern) {\n\t\t\tcollectEntries(next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else, next.unevaluatedItems, next.unevaluatedProperties);\n\t\t\tcollectMapEntries(next.definitions, next.$defs, next.properties, next.patternProperties, <IJSONSchemaMap>next.dependencies, next.dependentSchemas);\n\t\t\tcollectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.prefixItems);\n\t\t\tcollectEntryOrArrayEntries(next.items);\n\t\t}\n\t\tnext = toWalk.pop();\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type JSONSchemaType = 'string' | 'number' | 'integer' | 'boolean' | 'null' | 'array' | 'object';\n\nexport interface IJSONSchema {\n\tid?: string;\n\t$id?: string;\n\t$schema?: string;\n\ttype?: JSONSchemaType | JSONSchemaType[];\n\ttitle?: string;\n\tdefault?: any;\n\tdefinitions?: IJSONSchemaMap;\n\tdescription?: string;\n\tproperties?: IJSONSchemaMap;\n\tpatternProperties?: IJSONSchemaMap;\n\tadditionalProperties?: boolean | IJSONSchema;\n\tminProperties?: number;\n\tmaxProperties?: number;\n\tdependencies?: IJSONSchemaMap | { [prop: string]: string[] };\n\titems?: IJSONSchema | IJSONSchema[];\n\tminItems?: number;\n\tmaxItems?: number;\n\tuniqueItems?: boolean;\n\tadditionalItems?: boolean | IJSONSchema;\n\tpattern?: string;\n\tminLength?: number;\n\tmaxLength?: number;\n\tminimum?: number;\n\tmaximum?: number;\n\texclusiveMinimum?: boolean | number;\n\texclusiveMaximum?: boolean | number;\n\tmultipleOf?: number;\n\trequired?: string[];\n\t$ref?: string;\n\tanyOf?: IJSONSchema[];\n\tallOf?: IJSONSchema[];\n\toneOf?: IJSONSchema[];\n\tnot?: IJSONSchema;\n\tenum?: any[];\n\tformat?: string;\n\n\t// schema draft 06\n\tconst?: any;\n\tcontains?: IJSONSchema;\n\tpropertyNames?: IJSONSchema;\n\texamples?: any[];\n\n\t// schema draft 07\n\t$comment?: string;\n\tif?: IJSONSchema;\n\tthen?: IJSONSchema;\n\telse?: IJSONSchema;\n\n\t// schema 2019-09\n\tunevaluatedProperties?: boolean | IJSONSchema;\n\tunevaluatedItems?: boolean | IJSONSchema;\n\tminContains?: number;\n\tmaxContains?: number;\n\tdeprecated?: boolean;\n\tdependentRequired?: { [prop: string]: string[] };\n\tdependentSchemas?: IJSONSchemaMap;\n\t$defs?: { [name: string]: IJSONSchema };\n\t$anchor?: string;\n\t$recursiveRef?: string;\n\t$recursiveAnchor?: string;\n\t$vocabulary?: any;\n\n\t// schema 2020-12\n\tprefixItems?: IJSONSchema[];\n\t$dynamicRef?: string;\n\t$dynamicAnchor?: string;\n\n\t// VSCode extensions\n\n\tdefaultSnippets?: IJSONSchemaSnippet[];\n\terrorMessage?: string;\n\tpatternErrorMessage?: string;\n\tdeprecationMessage?: string;\n\tmarkdownDeprecationMessage?: string;\n\tenumDescriptions?: string[];\n\tmarkdownEnumDescriptions?: string[];\n\tmarkdownDescription?: string;\n\tdoNotSuggest?: boolean;\n\tsuggestSortText?: string;\n\tallowComments?: boolean;\n\tallowTrailingCommas?: boolean;\n}\n\nexport interface IJSONSchemaMap {\n\t[name: string]: IJSONSchema;\n}\n\nexport interface IJSONSchemaSnippet {\n\tlabel?: string;\n\tdescription?: string;\n\tbody?: any; // a object that will be JSON stringified\n\tbodyText?: string; // an already stringified JSON object that can contain new lines (\\n) and tabs (\\t)\n}\n\n/**\n * Converts a basic JSON schema to a TypeScript type.\n */\nexport type TypeFromJsonSchema<T> =\n\t// enum\n\tT extends { enum: infer EnumValues }\n\t? UnionOf<EnumValues>\n\n\t// Object with list of required properties.\n\t// Values are required or optional based on `required` list.\n\t: T extends { type: 'object'; properties: infer P; required: infer RequiredList }\n\t? {\n\t\t[K in keyof P]: IsRequired<K, RequiredList> extends true ? TypeFromJsonSchema<P[K]> : TypeFromJsonSchema<P[K]> | undefined;\n\t} & AdditionalPropertiesType<T>\n\n\t// Object with no required properties.\n\t// All values are optional\n\t: T extends { type: 'object'; properties: infer P }\n\t? { [K in keyof P]: TypeFromJsonSchema<P[K]> | undefined } & AdditionalPropertiesType<T>\n\n\t// Array\n\t: T extends { type: 'array'; items: infer Items }\n\t? Items extends [...infer R]\n\t// If items is an array, we treat it like a tuple\n\t? { [K in keyof R]: TypeFromJsonSchema<Items[K]> }\n\t: Array<TypeFromJsonSchema<Items>>\n\n\t// oneOf / anyof\n\t// These are handled the same way as they both represent a union type.\n\t// However at the validation level, they have different semantics.\n\t: T extends { oneOf: infer I }\n\t? MapSchemaToType<I>\n\t: T extends { anyOf: infer I }\n\t? MapSchemaToType<I>\n\n\t// Primitive types\n\t: T extends { type: infer Type }\n\t// Basic type\n\t? Type extends 'string' | 'number' | 'integer' | 'boolean' | 'null'\n\t? SchemaPrimitiveTypeNameToType<Type>\n\t// Union of primitive types\n\t: Type extends [...infer R]\n\t? UnionOf<{ [K in keyof R]: SchemaPrimitiveTypeNameToType<R[K]> }>\n\t: never\n\n\t// Fallthrough\n\t: never;\n\ntype SchemaPrimitiveTypeNameToType<T> =\n\tT extends 'string' ? string :\n\tT extends 'number' | 'integer' ? number :\n\tT extends 'boolean' ? boolean :\n\tT extends 'null' ? null :\n\tnever;\n\ntype UnionOf<T> =\n\tT extends [infer First, ...infer Rest]\n\t? First | UnionOf<Rest>\n\t: never;\n\ntype IsRequired<K, RequiredList> =\n\tRequiredList extends []\n\t? false\n\n\t: RequiredList extends [K, ...infer _]\n\t? true\n\n\t: RequiredList extends [infer _, ...infer R]\n\t? IsRequired<K, R>\n\n\t: false;\n\ntype AdditionalPropertiesType<Schema> =\n\tSchema extends { additionalProperties: infer AP }\n\t? AP extends false ? {} : { [key: string]: TypeFromJsonSchema<Schema['additionalProperties']> }\n\t: {};\n\ntype MapSchemaToType<T> = T extends [infer First, ...infer Rest]\n\t? TypeFromJsonSchema<First> | MapSchemaToType<Rest>\n\t: never;\n\ninterface Equals { schemas: IJSONSchema[]; id?: string }\n\nexport function getCompressedContent(schema: IJSONSchema): string {\n\tlet hasDups = false;\n\n\n\t// visit all schema nodes and collect the ones that are equal\n\tconst equalsByString = new Map<string, Equals>();\n\tconst nodeToEquals = new Map<IJSONSchema, Equals>();\n\tconst visitSchemas = (next: IJSONSchema) => {\n\t\tif (schema === next) {\n\t\t\treturn true;\n\t\t}\n\t\tconst val = JSON.stringify(next);\n\t\tif (val.length < 30) {\n\t\t\t// the $ref takes around 25 chars, so we don't save anything\n\t\t\treturn true;\n\t\t}\n\t\tconst eq = equalsByString.get(val);\n\t\tif (!eq) {\n\t\t\tconst newEq = { schemas: [next] };\n\t\t\tequalsByString.set(val, newEq);\n\t\t\tnodeToEquals.set(next, newEq);\n\t\t\treturn true;\n\t\t}\n\t\teq.schemas.push(next);\n\t\tnodeToEquals.set(next, eq);\n\t\thasDups = true;\n\t\treturn false;\n\t};\n\ttraverseNodes(schema, visitSchemas);\n\tequalsByString.clear();\n\n\tif (!hasDups) {\n\t\treturn JSON.stringify(schema);\n\t}\n\n\tlet defNodeName = '$defs';\n\twhile (schema.hasOwnProperty(defNodeName)) {\n\t\tdefNodeName += '_';\n\t}\n\n\t// used to collect all schemas that are later put in `$defs`. The index in the array is the id of the schema.\n\tconst definitions: IJSONSchema[] = [];\n\n\tfunction stringify(root: IJSONSchema): string {\n\t\treturn JSON.stringify(root, (_key: string, value: any) => {\n\t\t\tif (value !== root) {\n\t\t\t\tconst eq = nodeToEquals.get(value);\n\t\t\t\tif (eq && eq.schemas.length > 1) {\n\t\t\t\t\tif (!eq.id) {\n\t\t\t\t\t\teq.id = `_${definitions.length}`;\n\t\t\t\t\t\tdefinitions.push(eq.schemas[0]);\n\t\t\t\t\t}\n\t\t\t\t\treturn { $ref: `#/${defNodeName}/${eq.id}` };\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t});\n\t}\n\n\t// stringify the schema and replace duplicate subtrees with $ref\n\t// this will add new items to the definitions array\n\tconst str = stringify(schema);\n\n\t// now stringify the definitions. Each invication of stringify cann add new items to the definitions array, so the length can grow while we iterate\n\tconst defStrings: string[] = [];\n\tfor (let i = 0; i < definitions.length; i++) {\n\t\tdefStrings.push(`\"_${i}\":${stringify(definitions[i])}`);\n\t}\n\tif (defStrings.length) {\n\t\treturn `${str.substring(0, str.length - 1)},\"${defNodeName}\":{${defStrings.join(',')}}}`;\n\t}\n\treturn str;\n}\n\ntype IJSONSchemaRef = IJSONSchema | boolean;\n\nfunction isObject(thing: unknown): thing is object {\n\treturn typeof thing === 'object' && thing !== null;\n}\n\n/*\n * Traverse a JSON schema and visit each schema node\n*/\nfunction traverseNodes(root: IJSONSchema, visit: (schema: IJSONSchema) => boolean) {\n\tif (!root || typeof root !== 'object') {\n\t\treturn;\n\t}\n\tconst collectEntries = (...entries: (IJSONSchemaRef | undefined)[]) => {\n\t\tfor (const entry of entries) {\n\t\t\tif (isObject(entry)) {\n\t\t\t\ttoWalk.push(entry);\n\t\t\t}\n\t\t}\n\t};\n\tconst collectMapEntries = (...maps: (IJSONSchemaMap | undefined)[]) => {\n\t\tfor (const map of maps) {\n\t\t\tif (isObject(map)) {\n\t\t\t\tfor (const key in map) {\n\t\t\t\t\tconst entry = map[key];\n\t\t\t\t\tif (isObject(entry)) {\n\t\t\t\t\t\ttoWalk.push(entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tconst collectArrayEntries = (...arrays: (IJSONSchemaRef[] | undefined)[]) => {\n\t\tfor (const array of arrays) {\n\t\t\tif (Array.isArray(array)) {\n\t\t\t\tfor (const entry of array) {\n\t\t\t\t\tif (isObject(entry)) {\n\t\t\t\t\t\ttoWalk.push(entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tconst collectEntryOrArrayEntries = (items: (IJSONSchemaRef[] | IJSONSchemaRef | undefined)) => {\n\t\tif (Array.isArray(items)) {\n\t\t\tfor (const entry of items) {\n\t\t\t\tif (isObject(entry)) {\n\t\t\t\t\ttoWalk.push(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(items)) {\n\t\t\ttoWalk.push(items);\n\t\t}\n\t};\n\n\tconst toWalk: IJSONSchema[] = [root];\n\n\tlet next = toWalk.pop();\n\twhile (next) {\n\t\tconst visitChildern = visit(next);\n\t\tif (visitChildern) {\n\t\t\tcollectEntries(next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else, next.unevaluatedItems, next.unevaluatedProperties);\n\t\t\tcollectMapEntries(next.definitions, next.$defs, next.properties, next.patternProperties, <IJSONSchemaMap>next.dependencies, next.dependentSchemas);\n\t\t\tcollectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.prefixItems);\n\t\t\tcollectEntryOrArrayEntries(next.items);\n\t\t}\n\t\tnext = toWalk.pop();\n\t}\n}\n\n"]}