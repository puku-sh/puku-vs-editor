{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/jsonFormatter.ts","vs/base/common/jsonFormatter.ts"],"names":[],"mappings":"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","file":"jsonFormatter.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createScanner, ScanError, SyntaxKind } from './json.js';\n\nexport interface FormattingOptions {\n\t/**\n\t * If indentation is based on spaces (`insertSpaces` = true), then what is the number of spaces that make an indent?\n\t */\n\ttabSize?: number;\n\t/**\n\t * Is indentation based on spaces?\n\t */\n\tinsertSpaces?: boolean;\n\t/**\n\t * The default 'end of line' character. If not set, '\\n' is used as default.\n\t */\n\teol?: string;\n}\n\n/**\n * Represents a text modification\n */\nexport interface Edit {\n\t/**\n\t * The start offset of the modification.\n\t */\n\toffset: number;\n\t/**\n\t * The length of the modification. Must not be negative. Empty length represents an *insert*.\n\t */\n\tlength: number;\n\t/**\n\t * The new content. Empty content represents a *remove*.\n\t */\n\tcontent: string;\n}\n\n/**\n * A text range in the document\n*/\nexport interface Range {\n\t/**\n\t * The start offset of the range.\n\t */\n\toffset: number;\n\t/**\n\t * The length of the range. Must not be negative.\n\t */\n\tlength: number;\n}\n\n\nexport function format(documentText: string, range: Range | undefined, options: FormattingOptions): Edit[] {\n\tlet initialIndentLevel: number;\n\tlet formatText: string;\n\tlet formatTextStart: number;\n\tlet rangeStart: number;\n\tlet rangeEnd: number;\n\tif (range) {\n\t\trangeStart = range.offset;\n\t\trangeEnd = rangeStart + range.length;\n\n\t\tformatTextStart = rangeStart;\n\t\twhile (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n\t\t\tformatTextStart--;\n\t\t}\n\t\tlet endOffset = rangeEnd;\n\t\twhile (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n\t\t\tendOffset++;\n\t\t}\n\t\tformatText = documentText.substring(formatTextStart, endOffset);\n\t\tinitialIndentLevel = computeIndentLevel(formatText, options);\n\t} else {\n\t\tformatText = documentText;\n\t\tinitialIndentLevel = 0;\n\t\tformatTextStart = 0;\n\t\trangeStart = 0;\n\t\trangeEnd = documentText.length;\n\t}\n\tconst eol = getEOL(options, documentText);\n\n\tlet lineBreak = false;\n\tlet indentLevel = 0;\n\tlet indentValue: string;\n\tif (options.insertSpaces) {\n\t\tindentValue = repeat(' ', options.tabSize || 4);\n\t} else {\n\t\tindentValue = '\\t';\n\t}\n\n\tconst scanner = createScanner(formatText, false);\n\tlet hasError = false;\n\n\tfunction newLineAndIndent(): string {\n\t\treturn eol + repeat(indentValue, initialIndentLevel + indentLevel);\n\t}\n\tfunction scanNext(): SyntaxKind {\n\t\tlet token = scanner.scan();\n\t\tlineBreak = false;\n\t\twhile (token === SyntaxKind.Trivia || token === SyntaxKind.LineBreakTrivia) {\n\t\t\tlineBreak = lineBreak || (token === SyntaxKind.LineBreakTrivia);\n\t\t\ttoken = scanner.scan();\n\t\t}\n\t\thasError = token === SyntaxKind.Unknown || scanner.getTokenError() !== ScanError.None;\n\t\treturn token;\n\t}\n\tconst editOperations: Edit[] = [];\n\tfunction addEdit(text: string, startOffset: number, endOffset: number) {\n\t\tif (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n\t\t\teditOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n\t\t}\n\t}\n\n\tlet firstToken = scanNext();\n\n\tif (firstToken !== SyntaxKind.EOF) {\n\t\tconst firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n\t\tconst initialIndent = repeat(indentValue, initialIndentLevel);\n\t\taddEdit(initialIndent, formatTextStart, firstTokenStart);\n\t}\n\n\twhile (firstToken !== SyntaxKind.EOF) {\n\t\tlet firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n\t\tlet secondToken = scanNext();\n\n\t\tlet replaceContent = '';\n\t\twhile (!lineBreak && (secondToken === SyntaxKind.LineCommentTrivia || secondToken === SyntaxKind.BlockCommentTrivia)) {\n\t\t\t// comments on the same line: keep them on the same line, but ignore them otherwise\n\t\t\tconst commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n\t\t\taddEdit(' ', firstTokenEnd, commentTokenStart);\n\t\t\tfirstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n\t\t\treplaceContent = secondToken === SyntaxKind.LineCommentTrivia ? newLineAndIndent() : '';\n\t\t\tsecondToken = scanNext();\n\t\t}\n\n\t\tif (secondToken === SyntaxKind.CloseBraceToken) {\n\t\t\tif (firstToken !== SyntaxKind.OpenBraceToken) {\n\t\t\t\tindentLevel--;\n\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t}\n\t\t} else if (secondToken === SyntaxKind.CloseBracketToken) {\n\t\t\tif (firstToken !== SyntaxKind.OpenBracketToken) {\n\t\t\t\tindentLevel--;\n\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (firstToken) {\n\t\t\t\tcase SyntaxKind.OpenBracketToken:\n\t\t\t\tcase SyntaxKind.OpenBraceToken:\n\t\t\t\t\tindentLevel++;\n\t\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.CommaToken:\n\t\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\t\t\tif (lineBreak) {\n\t\t\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// symbol following comment on the same line: keep on same line, separate with ' '\n\t\t\t\t\t\treplaceContent = ' ';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.ColonToken:\n\t\t\t\t\treplaceContent = ' ';\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.StringLiteral:\n\t\t\t\t\tif (secondToken === SyntaxKind.ColonToken) {\n\t\t\t\t\t\treplaceContent = '';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t// fall through\n\t\t\t\tcase SyntaxKind.NullKeyword:\n\t\t\t\tcase SyntaxKind.TrueKeyword:\n\t\t\t\tcase SyntaxKind.FalseKeyword:\n\t\t\t\tcase SyntaxKind.NumericLiteral:\n\t\t\t\tcase SyntaxKind.CloseBraceToken:\n\t\t\t\tcase SyntaxKind.CloseBracketToken:\n\t\t\t\t\tif (secondToken === SyntaxKind.LineCommentTrivia || secondToken === SyntaxKind.BlockCommentTrivia) {\n\t\t\t\t\t\treplaceContent = ' ';\n\t\t\t\t\t} else if (secondToken !== SyntaxKind.CommaToken && secondToken !== SyntaxKind.EOF) {\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Unknown:\n\t\t\t\t\thasError = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (lineBreak && (secondToken === SyntaxKind.LineCommentTrivia || secondToken === SyntaxKind.BlockCommentTrivia)) {\n\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t}\n\n\t\t}\n\t\tconst secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n\t\taddEdit(replaceContent, firstTokenEnd, secondTokenStart);\n\t\tfirstToken = secondToken;\n\t}\n\treturn editOperations;\n}\n\n/**\n * Creates a formatted string out of the object passed as argument, using the given formatting options\n * @param any The object to stringify and format\n * @param options The formatting options to use\n */\nexport function toFormattedString(obj: unknown, options: FormattingOptions) {\n\tconst content = JSON.stringify(obj, undefined, options.insertSpaces ? options.tabSize || 4 : '\\t');\n\tif (options.eol !== undefined) {\n\t\treturn content.replace(/\\r\\n|\\r|\\n/g, options.eol);\n\t}\n\treturn content;\n}\n\nfunction repeat(s: string, count: number): string {\n\tlet result = '';\n\tfor (let i = 0; i < count; i++) {\n\t\tresult += s;\n\t}\n\treturn result;\n}\n\nfunction computeIndentLevel(content: string, options: FormattingOptions): number {\n\tlet i = 0;\n\tlet nChars = 0;\n\tconst tabSize = options.tabSize || 4;\n\twhile (i < content.length) {\n\t\tconst ch = content.charAt(i);\n\t\tif (ch === ' ') {\n\t\t\tnChars++;\n\t\t} else if (ch === '\\t') {\n\t\t\tnChars += tabSize;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn Math.floor(nChars / tabSize);\n}\n\nexport function getEOL(options: FormattingOptions, text: string): string {\n\tfor (let i = 0; i < text.length; i++) {\n\t\tconst ch = text.charAt(i);\n\t\tif (ch === '\\r') {\n\t\t\tif (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n\t\t\t\treturn '\\r\\n';\n\t\t\t}\n\t\t\treturn '\\r';\n\t\t} else if (ch === '\\n') {\n\t\t\treturn '\\n';\n\t\t}\n\t}\n\treturn (options && options.eol) || '\\n';\n}\n\nexport function isEOL(text: string, offset: number) {\n\treturn '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createScanner, ScanError, SyntaxKind } from './json.js';\n\nexport interface FormattingOptions {\n\t/**\n\t * If indentation is based on spaces (`insertSpaces` = true), then what is the number of spaces that make an indent?\n\t */\n\ttabSize?: number;\n\t/**\n\t * Is indentation based on spaces?\n\t */\n\tinsertSpaces?: boolean;\n\t/**\n\t * The default 'end of line' character. If not set, '\\n' is used as default.\n\t */\n\teol?: string;\n}\n\n/**\n * Represents a text modification\n */\nexport interface Edit {\n\t/**\n\t * The start offset of the modification.\n\t */\n\toffset: number;\n\t/**\n\t * The length of the modification. Must not be negative. Empty length represents an *insert*.\n\t */\n\tlength: number;\n\t/**\n\t * The new content. Empty content represents a *remove*.\n\t */\n\tcontent: string;\n}\n\n/**\n * A text range in the document\n*/\nexport interface Range {\n\t/**\n\t * The start offset of the range.\n\t */\n\toffset: number;\n\t/**\n\t * The length of the range. Must not be negative.\n\t */\n\tlength: number;\n}\n\n\nexport function format(documentText: string, range: Range | undefined, options: FormattingOptions): Edit[] {\n\tlet initialIndentLevel: number;\n\tlet formatText: string;\n\tlet formatTextStart: number;\n\tlet rangeStart: number;\n\tlet rangeEnd: number;\n\tif (range) {\n\t\trangeStart = range.offset;\n\t\trangeEnd = rangeStart + range.length;\n\n\t\tformatTextStart = rangeStart;\n\t\twhile (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n\t\t\tformatTextStart--;\n\t\t}\n\t\tlet endOffset = rangeEnd;\n\t\twhile (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n\t\t\tendOffset++;\n\t\t}\n\t\tformatText = documentText.substring(formatTextStart, endOffset);\n\t\tinitialIndentLevel = computeIndentLevel(formatText, options);\n\t} else {\n\t\tformatText = documentText;\n\t\tinitialIndentLevel = 0;\n\t\tformatTextStart = 0;\n\t\trangeStart = 0;\n\t\trangeEnd = documentText.length;\n\t}\n\tconst eol = getEOL(options, documentText);\n\n\tlet lineBreak = false;\n\tlet indentLevel = 0;\n\tlet indentValue: string;\n\tif (options.insertSpaces) {\n\t\tindentValue = repeat(' ', options.tabSize || 4);\n\t} else {\n\t\tindentValue = '\\t';\n\t}\n\n\tconst scanner = createScanner(formatText, false);\n\tlet hasError = false;\n\n\tfunction newLineAndIndent(): string {\n\t\treturn eol + repeat(indentValue, initialIndentLevel + indentLevel);\n\t}\n\tfunction scanNext(): SyntaxKind {\n\t\tlet token = scanner.scan();\n\t\tlineBreak = false;\n\t\twhile (token === SyntaxKind.Trivia || token === SyntaxKind.LineBreakTrivia) {\n\t\t\tlineBreak = lineBreak || (token === SyntaxKind.LineBreakTrivia);\n\t\t\ttoken = scanner.scan();\n\t\t}\n\t\thasError = token === SyntaxKind.Unknown || scanner.getTokenError() !== ScanError.None;\n\t\treturn token;\n\t}\n\tconst editOperations: Edit[] = [];\n\tfunction addEdit(text: string, startOffset: number, endOffset: number) {\n\t\tif (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n\t\t\teditOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n\t\t}\n\t}\n\n\tlet firstToken = scanNext();\n\n\tif (firstToken !== SyntaxKind.EOF) {\n\t\tconst firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n\t\tconst initialIndent = repeat(indentValue, initialIndentLevel);\n\t\taddEdit(initialIndent, formatTextStart, firstTokenStart);\n\t}\n\n\twhile (firstToken !== SyntaxKind.EOF) {\n\t\tlet firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n\t\tlet secondToken = scanNext();\n\n\t\tlet replaceContent = '';\n\t\twhile (!lineBreak && (secondToken === SyntaxKind.LineCommentTrivia || secondToken === SyntaxKind.BlockCommentTrivia)) {\n\t\t\t// comments on the same line: keep them on the same line, but ignore them otherwise\n\t\t\tconst commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n\t\t\taddEdit(' ', firstTokenEnd, commentTokenStart);\n\t\t\tfirstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n\t\t\treplaceContent = secondToken === SyntaxKind.LineCommentTrivia ? newLineAndIndent() : '';\n\t\t\tsecondToken = scanNext();\n\t\t}\n\n\t\tif (secondToken === SyntaxKind.CloseBraceToken) {\n\t\t\tif (firstToken !== SyntaxKind.OpenBraceToken) {\n\t\t\t\tindentLevel--;\n\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t}\n\t\t} else if (secondToken === SyntaxKind.CloseBracketToken) {\n\t\t\tif (firstToken !== SyntaxKind.OpenBracketToken) {\n\t\t\t\tindentLevel--;\n\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (firstToken) {\n\t\t\t\tcase SyntaxKind.OpenBracketToken:\n\t\t\t\tcase SyntaxKind.OpenBraceToken:\n\t\t\t\t\tindentLevel++;\n\t\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.CommaToken:\n\t\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\t\t\tif (lineBreak) {\n\t\t\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// symbol following comment on the same line: keep on same line, separate with ' '\n\t\t\t\t\t\treplaceContent = ' ';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.ColonToken:\n\t\t\t\t\treplaceContent = ' ';\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.StringLiteral:\n\t\t\t\t\tif (secondToken === SyntaxKind.ColonToken) {\n\t\t\t\t\t\treplaceContent = '';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t// fall through\n\t\t\t\tcase SyntaxKind.NullKeyword:\n\t\t\t\tcase SyntaxKind.TrueKeyword:\n\t\t\t\tcase SyntaxKind.FalseKeyword:\n\t\t\t\tcase SyntaxKind.NumericLiteral:\n\t\t\t\tcase SyntaxKind.CloseBraceToken:\n\t\t\t\tcase SyntaxKind.CloseBracketToken:\n\t\t\t\t\tif (secondToken === SyntaxKind.LineCommentTrivia || secondToken === SyntaxKind.BlockCommentTrivia) {\n\t\t\t\t\t\treplaceContent = ' ';\n\t\t\t\t\t} else if (secondToken !== SyntaxKind.CommaToken && secondToken !== SyntaxKind.EOF) {\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Unknown:\n\t\t\t\t\thasError = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (lineBreak && (secondToken === SyntaxKind.LineCommentTrivia || secondToken === SyntaxKind.BlockCommentTrivia)) {\n\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t}\n\n\t\t}\n\t\tconst secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n\t\taddEdit(replaceContent, firstTokenEnd, secondTokenStart);\n\t\tfirstToken = secondToken;\n\t}\n\treturn editOperations;\n}\n\n/**\n * Creates a formatted string out of the object passed as argument, using the given formatting options\n * @param any The object to stringify and format\n * @param options The formatting options to use\n */\nexport function toFormattedString(obj: unknown, options: FormattingOptions) {\n\tconst content = JSON.stringify(obj, undefined, options.insertSpaces ? options.tabSize || 4 : '\\t');\n\tif (options.eol !== undefined) {\n\t\treturn content.replace(/\\r\\n|\\r|\\n/g, options.eol);\n\t}\n\treturn content;\n}\n\nfunction repeat(s: string, count: number): string {\n\tlet result = '';\n\tfor (let i = 0; i < count; i++) {\n\t\tresult += s;\n\t}\n\treturn result;\n}\n\nfunction computeIndentLevel(content: string, options: FormattingOptions): number {\n\tlet i = 0;\n\tlet nChars = 0;\n\tconst tabSize = options.tabSize || 4;\n\twhile (i < content.length) {\n\t\tconst ch = content.charAt(i);\n\t\tif (ch === ' ') {\n\t\t\tnChars++;\n\t\t} else if (ch === '\\t') {\n\t\t\tnChars += tabSize;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn Math.floor(nChars / tabSize);\n}\n\nexport function getEOL(options: FormattingOptions, text: string): string {\n\tfor (let i = 0; i < text.length; i++) {\n\t\tconst ch = text.charAt(i);\n\t\tif (ch === '\\r') {\n\t\t\tif (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n\t\t\t\treturn '\\r\\n';\n\t\t\t}\n\t\t\treturn '\\r';\n\t\t} else if (ch === '\\n') {\n\t\t\treturn '\\n';\n\t\t}\n\t}\n\treturn (options && options.eol) || '\\n';\n}\n\nexport function isEOL(text: string, offset: number) {\n\treturn '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n"]}