{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/common/decorators/cancelPreviousCalls.ts","vs/base/common/decorators/cancelPreviousCalls.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAC5C,OAAO,EAAc,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAC5D,OAAO,EAAE,uBAAuB,EAAE,iBAAiB,EAAE,MAAM,oBAAoB,CAAC;AAahF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiEG;AACH,MAAM,UAAU,mBAAmB,CAKlC,MAAe,EACf,UAAkB,EAClB,UAAgG;IAEhG,MAAM,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC;IAExC,aAAa,CACZ,cAAc,EACd,WAAW,UAAU,mBAAmB,CACxC,CAAC;IAEF,uFAAuF;IACvF,wFAAwF;IACxF,qFAAqF;IACrF,0FAA0F;IAC1F,MAAM,aAAa,GAAG,IAAI,OAAO,EAA2D,CAAC;IAE7F,mFAAmF;IACnF,kFAAkF;IAClF,UAAU,CAAC,KAAK,GAAG,UAElB,GAAG,IAAuC;QAE1C,yDAAyD;QACzD,qDAAqD;QACrD,IAAI,MAAM,GAAG,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACrC,IAAI,CAAC,MAAM,EAAE,CAAC;YACb,MAAM,GAAG,IAAI,aAAa,EAAE,CAAC;YAC7B,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YAEhC,IAAI,CAAC,SAAS,CAAC;gBACd,OAAO,EAAE,GAAG,EAAE;oBACb,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,CAAC;oBACnC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBAC5B,CAAC;aACD,CAAC,CAAC;QACJ,CAAC;QAED,8EAA8E;QAC9E,4EAA4E;QAC5E,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;QAEtC,qEAAqE;QACrE,yDAAyD;QACzD,yEAAyE;QACzE,oEAAoE;QACpE,2EAA2E;QAC3E,0EAA0E;QAC1E,gEAAgE;QAChE,aAAa;QAEb,oEAAoE;QACpE,8DAA8D;QAC9D,MAAM,YAAY,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YACrC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YACvB,CAAC,CAAC,SAAS,CAAC;QACb,MAAM,KAAK,GAAG,iBAAiB,CAAC,mBAAmB,CAAC,YAAY,CAAC;YAChE,CAAC,CAAC,YAAY;YACd,CAAC,CAAC,SAAS,CAAC;QAEb,MAAM,kBAAkB,GAAG,IAAI,uBAAuB,CAAC,KAAK,CAAC,CAAC;QAC9D,MAAM,CAAC,GAAG,CAAC,UAAU,EAAE,kBAAkB,CAAC,CAAC;QAE3C,yEAAyE;QACzE,IAAI,iBAAiB,CAAC,mBAAmB,CAAC,YAAY,CAAC,EAAE,CAAC;YACzD,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,kBAAkB,CAAC,KAAK,CAAC;QAClD,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;QACrC,CAAC;QAED,oEAAoE;QACpE,8DAA8D;QAC9D,OAAO,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC;IAC3C,CAAC,CAAC;IAEF,OAAO,UAAU,CAAC;AACnB,CAAC","file":"cancelPreviousCalls.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertDefined } from '../types.js';\nimport { Disposable, DisposableMap } from '../lifecycle.js';\nimport { CancellationTokenSource, CancellationToken } from '../cancellation.js';\n\n/**\n * Helper type that represents a function that has an optional {@linkcode CancellationToken}\n * argument argument at the end of the arguments list.\n *\n * @typeparam `TFunction` - Type of the function arguments list of which will be extended\n * \t\t\t\t\t\t\twith an optional {@linkcode CancellationToken} argument.\n */\ntype TWithOptionalCancellationToken<TFunction extends Function> = TFunction extends (...args: infer TArgs) => infer TReturn\n\t? (...args: [...TArgs, cancellatioNToken?: CancellationToken]) => TReturn\n\t: never;\n\n/**\n * Decorator that provides a mechanism to cancel previous calls of the decorated method\n * by providing a `cancellation token` as the last argument of the method, which gets\n * cancelled immediately on subsequent call of the decorated method.\n *\n * Therefore to use this decorator, the two conditions must be met:\n *\n * - the decorated method must have an *optional* {@linkcode CancellationToken} argument at\n * \t the end of the arguments list\n * - the object that the decorated method belongs to must implement the {@linkcode Disposable};\n *   this requirement comes from the internal implementation of the decorator that\n *   creates new resources that need to be eventually disposed by someone\n *\n * @typeparam `TObject` - Object type that the decorated method belongs to.\n * @typeparam `TArgs` - Argument list of the decorated method.\n * @typeparam `TReturn` - Return value type of the decorated method.\n *\n * ### Examples\n *\n * ```typescript\n * // let's say we have a class that implements the `Disposable` interface that we want\n * // to use the decorator on\n * class Example extends Disposable {\n * \t\tasync doSomethingAsync(arg1: number, arg2: string): Promise<void> {\n * \t\t\t// do something async..\n * \t\t\tawait new Promise(resolve => setTimeout(resolve, 1000));\n * \t\t}\n * }\n * ```\n *\n * ```typescript\n * // to do that we need to add the `CancellationToken` argument to the end of args list\n * class Example extends Disposable {\n * \t\t@cancelPreviousCalls\n * \t\tasync doSomethingAsync(arg1: number, arg2: string, cancellationToken?: CancellationToken): Promise<void> {\n * \t\t\tconsole.log(`call with args ${arg1} and ${arg2} initiated`);\n *\n * \t\t\t// the decorator will create the cancellation token automatically\n * \t\t\tassertDefined(\n * \t\t\t\tcancellationToken,\n * \t\t\t\t`The method must now have the `CancellationToken` passed to it.`,\n * \t\t\t);\n *\n * \t\t\tcancellationToken.onCancellationRequested(() => {\n * \t\t\t\tconsole.log(`call with args ${arg1} and ${arg2} was cancelled`);\n * \t\t\t});\n *\n * \t\t\t// do something async..\n * \t\t\tawait new Promise(resolve => setTimeout(resolve, 1000));\n *\n * \t\t\t// check cancellation token state after the async operations\n * \t\t\tconsole.log(\n * \t\t\t\t`call with args ${arg1} and ${arg2} completed, canceled?: ${cancellationToken.isCancellationRequested}`,\n * \t\t\t);\n * \t\t}\n * }\n *\n * const example = new Example();\n * // call the decorate method first time\n * example.doSomethingAsync(1, 'foo');\n * // wait for 500ms which is less than 1000ms of the async operation in the first call\n * await new Promise(resolve => setTimeout(resolve, 500));\n * // calling the decorate method second time cancels the token passed to the first call\n * example.doSomethingAsync(2, 'bar');\n * ```\n */\nexport function cancelPreviousCalls<\n\tTObject extends Disposable,\n\tTArgs extends unknown[],\n\tTReturn,\n>(\n\t_proto: TObject,\n\tmethodName: string,\n\tdescriptor: TypedPropertyDescriptor<TWithOptionalCancellationToken<(...args: TArgs) => TReturn>>,\n) {\n\tconst originalMethod = descriptor.value;\n\n\tassertDefined(\n\t\toriginalMethod,\n\t\t`Method '${methodName}' is not defined.`,\n\t);\n\n\t// we create the global map that contains `TObjectRecord` for each object instance that\n\t// uses this decorator, which itself contains a `{method name} -> TMethodRecord` mapping\n\t// for each decorated method on the object; the `TMethodRecord` record stores current\n\t// `cancellationTokenSource`, token of which was passed to the previous call of the method\n\tconst objectRecords = new WeakMap<TObject, DisposableMap<string, CancellationTokenSource>>();\n\n\t// decorate the original method with the following logic that upon a new invocation\n\t// of the method cancels the cancellation token that was passed to a previous call\n\tdescriptor.value = function (\n\t\tthis: TObject,\n\t\t...args: Parameters<typeof originalMethod>\n\t): TReturn {\n\t\t// get or create a record for the current object instance\n\t\t// the creation is done once per each object instance\n\t\tlet record = objectRecords.get(this);\n\t\tif (!record) {\n\t\t\trecord = new DisposableMap();\n\t\t\tobjectRecords.set(this, record);\n\n\t\t\tthis._register({\n\t\t\t\tdispose: () => {\n\t\t\t\t\tobjectRecords.get(this)?.dispose();\n\t\t\t\t\tobjectRecords.delete(this);\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// when the decorated method is called again and there is a cancellation token\n\t\t// source exists from a previous call, cancel and dispose it, then remove it\n\t\trecord.get(methodName)?.dispose(true);\n\n\t\t// now we need to provide a cancellation token to the original method\n\t\t// as the last argument, there are two cases to consider:\n\t\t// \t- (common case) the arguments list does not have a cancellation token\n\t\t// \t   as the last argument, - in this case we need to add a new one\n\t\t//  - (possible case) - the arguments list already has a cancellation token\n\t\t//    as the last argument, - in this case we need to reuse the token when\n\t\t//    we create ours, and replace the old token with the new one\n\t\t// therefore,\n\n\t\t// get the last argument of the arguments list and if it is present,\n\t\t// reuse it as the token for the new cancellation token source\n\t\tconst lastArgument = (args.length > 0)\n\t\t\t? args[args.length - 1]\n\t\t\t: undefined;\n\t\tconst token = CancellationToken.isCancellationToken(lastArgument)\n\t\t\t? lastArgument\n\t\t\t: undefined;\n\n\t\tconst cancellationSource = new CancellationTokenSource(token);\n\t\trecord.set(methodName, cancellationSource);\n\n\t\t// then update or add cancellation token at the end of the arguments list\n\t\tif (CancellationToken.isCancellationToken(lastArgument)) {\n\t\t\targs[args.length - 1] = cancellationSource.token;\n\t\t} else {\n\t\t\targs.push(cancellationSource.token);\n\t\t}\n\n\t\t// finally invoke the original method passing original arguments and\n\t\t// the new cancellation token at the end of the arguments list\n\t\treturn originalMethod.call(this, ...args);\n\t};\n\n\treturn descriptor;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertDefined } from '../types.js';\nimport { Disposable, DisposableMap } from '../lifecycle.js';\nimport { CancellationTokenSource, CancellationToken } from '../cancellation.js';\n\n/**\n * Helper type that represents a function that has an optional {@linkcode CancellationToken}\n * argument argument at the end of the arguments list.\n *\n * @typeparam `TFunction` - Type of the function arguments list of which will be extended\n * \t\t\t\t\t\t\twith an optional {@linkcode CancellationToken} argument.\n */\ntype TWithOptionalCancellationToken<TFunction extends Function> = TFunction extends (...args: infer TArgs) => infer TReturn\n\t? (...args: [...TArgs, cancellatioNToken?: CancellationToken]) => TReturn\n\t: never;\n\n/**\n * Decorator that provides a mechanism to cancel previous calls of the decorated method\n * by providing a `cancellation token` as the last argument of the method, which gets\n * cancelled immediately on subsequent call of the decorated method.\n *\n * Therefore to use this decorator, the two conditions must be met:\n *\n * - the decorated method must have an *optional* {@linkcode CancellationToken} argument at\n * \t the end of the arguments list\n * - the object that the decorated method belongs to must implement the {@linkcode Disposable};\n *   this requirement comes from the internal implementation of the decorator that\n *   creates new resources that need to be eventually disposed by someone\n *\n * @typeparam `TObject` - Object type that the decorated method belongs to.\n * @typeparam `TArgs` - Argument list of the decorated method.\n * @typeparam `TReturn` - Return value type of the decorated method.\n *\n * ### Examples\n *\n * ```typescript\n * // let's say we have a class that implements the `Disposable` interface that we want\n * // to use the decorator on\n * class Example extends Disposable {\n * \t\tasync doSomethingAsync(arg1: number, arg2: string): Promise<void> {\n * \t\t\t// do something async..\n * \t\t\tawait new Promise(resolve => setTimeout(resolve, 1000));\n * \t\t}\n * }\n * ```\n *\n * ```typescript\n * // to do that we need to add the `CancellationToken` argument to the end of args list\n * class Example extends Disposable {\n * \t\t@cancelPreviousCalls\n * \t\tasync doSomethingAsync(arg1: number, arg2: string, cancellationToken?: CancellationToken): Promise<void> {\n * \t\t\tconsole.log(`call with args ${arg1} and ${arg2} initiated`);\n *\n * \t\t\t// the decorator will create the cancellation token automatically\n * \t\t\tassertDefined(\n * \t\t\t\tcancellationToken,\n * \t\t\t\t`The method must now have the `CancellationToken` passed to it.`,\n * \t\t\t);\n *\n * \t\t\tcancellationToken.onCancellationRequested(() => {\n * \t\t\t\tconsole.log(`call with args ${arg1} and ${arg2} was cancelled`);\n * \t\t\t});\n *\n * \t\t\t// do something async..\n * \t\t\tawait new Promise(resolve => setTimeout(resolve, 1000));\n *\n * \t\t\t// check cancellation token state after the async operations\n * \t\t\tconsole.log(\n * \t\t\t\t`call with args ${arg1} and ${arg2} completed, canceled?: ${cancellationToken.isCancellationRequested}`,\n * \t\t\t);\n * \t\t}\n * }\n *\n * const example = new Example();\n * // call the decorate method first time\n * example.doSomethingAsync(1, 'foo');\n * // wait for 500ms which is less than 1000ms of the async operation in the first call\n * await new Promise(resolve => setTimeout(resolve, 500));\n * // calling the decorate method second time cancels the token passed to the first call\n * example.doSomethingAsync(2, 'bar');\n * ```\n */\nexport function cancelPreviousCalls<\n\tTObject extends Disposable,\n\tTArgs extends unknown[],\n\tTReturn,\n>(\n\t_proto: TObject,\n\tmethodName: string,\n\tdescriptor: TypedPropertyDescriptor<TWithOptionalCancellationToken<(...args: TArgs) => TReturn>>,\n) {\n\tconst originalMethod = descriptor.value;\n\n\tassertDefined(\n\t\toriginalMethod,\n\t\t`Method '${methodName}' is not defined.`,\n\t);\n\n\t// we create the global map that contains `TObjectRecord` for each object instance that\n\t// uses this decorator, which itself contains a `{method name} -> TMethodRecord` mapping\n\t// for each decorated method on the object; the `TMethodRecord` record stores current\n\t// `cancellationTokenSource`, token of which was passed to the previous call of the method\n\tconst objectRecords = new WeakMap<TObject, DisposableMap<string, CancellationTokenSource>>();\n\n\t// decorate the original method with the following logic that upon a new invocation\n\t// of the method cancels the cancellation token that was passed to a previous call\n\tdescriptor.value = function (\n\t\tthis: TObject,\n\t\t...args: Parameters<typeof originalMethod>\n\t): TReturn {\n\t\t// get or create a record for the current object instance\n\t\t// the creation is done once per each object instance\n\t\tlet record = objectRecords.get(this);\n\t\tif (!record) {\n\t\t\trecord = new DisposableMap();\n\t\t\tobjectRecords.set(this, record);\n\n\t\t\tthis._register({\n\t\t\t\tdispose: () => {\n\t\t\t\t\tobjectRecords.get(this)?.dispose();\n\t\t\t\t\tobjectRecords.delete(this);\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// when the decorated method is called again and there is a cancellation token\n\t\t// source exists from a previous call, cancel and dispose it, then remove it\n\t\trecord.get(methodName)?.dispose(true);\n\n\t\t// now we need to provide a cancellation token to the original method\n\t\t// as the last argument, there are two cases to consider:\n\t\t// \t- (common case) the arguments list does not have a cancellation token\n\t\t// \t   as the last argument, - in this case we need to add a new one\n\t\t//  - (possible case) - the arguments list already has a cancellation token\n\t\t//    as the last argument, - in this case we need to reuse the token when\n\t\t//    we create ours, and replace the old token with the new one\n\t\t// therefore,\n\n\t\t// get the last argument of the arguments list and if it is present,\n\t\t// reuse it as the token for the new cancellation token source\n\t\tconst lastArgument = (args.length > 0)\n\t\t\t? args[args.length - 1]\n\t\t\t: undefined;\n\t\tconst token = CancellationToken.isCancellationToken(lastArgument)\n\t\t\t? lastArgument\n\t\t\t: undefined;\n\n\t\tconst cancellationSource = new CancellationTokenSource(token);\n\t\trecord.set(methodName, cancellationSource);\n\n\t\t// then update or add cancellation token at the end of the arguments list\n\t\tif (CancellationToken.isCancellationToken(lastArgument)) {\n\t\t\targs[args.length - 1] = cancellationSource.token;\n\t\t} else {\n\t\t\targs.push(cancellationSource.token);\n\t\t}\n\n\t\t// finally invoke the original method passing original arguments and\n\t\t// the new cancellation token at the end of the arguments list\n\t\treturn originalMethod.call(this, ...args);\n\t};\n\n\treturn descriptor;\n}\n"]}