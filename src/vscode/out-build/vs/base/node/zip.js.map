{"version":3,"sources":["vs/base/node/zip.ts"],"names":[],"mappings":"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","file":"zip.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createWriteStream, WriteStream, promises } from 'fs';\nimport { Readable } from 'stream';\nimport { createCancelablePromise, Sequencer } from '../common/async.js';\nimport { CancellationToken } from '../common/cancellation.js';\nimport * as path from '../common/path.js';\nimport { assertReturnsDefined } from '../common/types.js';\nimport { Promises } from './pfs.js';\nimport * as nls from '../../nls.js';\nimport type { Entry, ZipFile } from 'yauzl';\n\nexport const CorruptZipMessage: string = 'end of central directory record signature not found';\nconst CORRUPT_ZIP_PATTERN = new RegExp(CorruptZipMessage);\n\nexport interface IExtractOptions {\n\toverwrite?: boolean;\n\n\t/**\n\t * Source path within the ZIP archive. Only the files contained in this\n\t * path will be extracted.\n\t */\n\tsourcePath?: string;\n}\n\ninterface IOptions {\n\tsourcePathRegex: RegExp;\n}\n\nexport type ExtractErrorType = 'CorruptZip' | 'Incomplete';\n\nexport class ExtractError extends Error {\n\n\treadonly type?: ExtractErrorType;\n\n\tconstructor(type: ExtractErrorType | undefined, cause: Error) {\n\t\tlet message = cause.message;\n\n\t\tswitch (type) {\n\t\t\tcase 'CorruptZip': message = `Corrupt ZIP: ${message}`; break;\n\t\t}\n\n\t\tsuper(message);\n\t\tthis.type = type;\n\t\tthis.cause = cause;\n\t}\n}\n\nfunction modeFromEntry(entry: Entry) {\n\tconst attr = entry.externalFileAttributes >> 16 || 33188;\n\n\treturn [448 /* S_IRWXU */, 56 /* S_IRWXG */, 7 /* S_IRWXO */]\n\t\t.map(mask => attr & mask)\n\t\t.reduce((a, b) => a + b, attr & 61440 /* S_IFMT */);\n}\n\nfunction toExtractError(err: Error): ExtractError {\n\tif (err instanceof ExtractError) {\n\t\treturn err;\n\t}\n\n\tlet type: ExtractErrorType | undefined = undefined;\n\n\tif (CORRUPT_ZIP_PATTERN.test(err.message)) {\n\t\ttype = 'CorruptZip';\n\t}\n\n\treturn new ExtractError(type, err);\n}\n\nfunction extractEntry(stream: Readable, fileName: string, mode: number, targetPath: string, options: IOptions, token: CancellationToken): Promise<void> {\n\tconst dirName = path.dirname(fileName);\n\tconst targetDirName = path.join(targetPath, dirName);\n\tif (!targetDirName.startsWith(targetPath)) {\n\t\treturn Promise.reject(new Error(nls.localize('invalid file', \"Error extracting {0}. Invalid file.\", fileName)));\n\t}\n\tconst targetFileName = path.join(targetPath, fileName);\n\n\tlet istream: WriteStream;\n\n\ttoken.onCancellationRequested(() => {\n\t\tistream?.destroy();\n\t});\n\n\treturn Promise.resolve(promises.mkdir(targetDirName, { recursive: true })).then(() => new Promise<void>((c, e) => {\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tistream = createWriteStream(targetFileName, { mode });\n\t\t\tistream.once('close', () => c());\n\t\t\tistream.once('error', e);\n\t\t\tstream.once('error', e);\n\t\t\tstream.pipe(istream);\n\t\t} catch (error) {\n\t\t\te(error);\n\t\t}\n\t}));\n}\n\nfunction extractZip(zipfile: ZipFile, targetPath: string, options: IOptions, token: CancellationToken): Promise<void> {\n\tlet last = createCancelablePromise<void>(() => Promise.resolve());\n\tlet extractedEntriesCount = 0;\n\n\tconst listener = token.onCancellationRequested(() => {\n\t\tlast.cancel();\n\t\tzipfile.close();\n\t});\n\n\treturn new Promise<void>((c, e) => {\n\t\tconst throttler = new Sequencer();\n\n\t\tconst readNextEntry = (token: CancellationToken) => {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\textractedEntriesCount++;\n\t\t\tzipfile.readEntry();\n\t\t};\n\n\t\tzipfile.once('error', e);\n\t\tzipfile.once('close', () => last.then(() => {\n\t\t\tif (token.isCancellationRequested || zipfile.entryCount === extractedEntriesCount) {\n\t\t\t\tc();\n\t\t\t} else {\n\t\t\t\te(new ExtractError('Incomplete', new Error(nls.localize('incompleteExtract', \"Incomplete. Found {0} of {1} entries\", extractedEntriesCount, zipfile.entryCount))));\n\t\t\t}\n\t\t}, e));\n\t\tzipfile.readEntry();\n\t\tzipfile.on('entry', (entry: Entry) => {\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!options.sourcePathRegex.test(entry.fileName)) {\n\t\t\t\treadNextEntry(token);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst fileName = entry.fileName.replace(options.sourcePathRegex, '');\n\n\t\t\t// directory file names end with '/'\n\t\t\tif (/\\/$/.test(fileName)) {\n\t\t\t\tconst targetFileName = path.join(targetPath, fileName);\n\t\t\t\tlast = createCancelablePromise(token => promises.mkdir(targetFileName, { recursive: true }).then(() => readNextEntry(token)).then(undefined, e));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst stream = openZipStream(zipfile, entry);\n\t\t\tconst mode = modeFromEntry(entry);\n\n\t\t\tlast = createCancelablePromise(token => throttler.queue(() => stream.then(stream => extractEntry(stream, fileName, mode, targetPath, options, token).then(() => readNextEntry(token)))).then(null, e));\n\t\t});\n\t}).finally(() => listener.dispose());\n}\n\nasync function openZip(zipFile: string, lazy: boolean = false): Promise<ZipFile> {\n\tconst { open } = await import('yauzl');\n\n\treturn new Promise<ZipFile>((resolve, reject) => {\n\t\topen(zipFile, lazy ? { lazyEntries: true } : undefined!, (error: Error | null, zipfile?: ZipFile) => {\n\t\t\tif (error) {\n\t\t\t\treject(toExtractError(error));\n\t\t\t} else {\n\t\t\t\tresolve(assertReturnsDefined(zipfile));\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction openZipStream(zipFile: ZipFile, entry: Entry): Promise<Readable> {\n\treturn new Promise<Readable>((resolve, reject) => {\n\t\tzipFile.openReadStream(entry, (error: Error | null, stream?: Readable) => {\n\t\t\tif (error) {\n\t\t\t\treject(toExtractError(error));\n\t\t\t} else {\n\t\t\t\tresolve(assertReturnsDefined(stream));\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IFile {\n\tpath: string;\n\tcontents?: Buffer | string;\n\tlocalPath?: string;\n}\n\nexport async function zip(zipPath: string, files: IFile[]): Promise<string> {\n\tconst { ZipFile } = await import('yazl');\n\n\treturn new Promise<string>((c, e) => {\n\t\tconst zip = new ZipFile();\n\t\tfiles.forEach(f => {\n\t\t\tif (f.contents) {\n\t\t\t\tzip.addBuffer(typeof f.contents === 'string' ? Buffer.from(f.contents, 'utf8') : f.contents, f.path);\n\t\t\t} else if (f.localPath) {\n\t\t\t\tzip.addFile(f.localPath, f.path);\n\t\t\t}\n\t\t});\n\t\tzip.end();\n\n\t\tconst zipStream = createWriteStream(zipPath);\n\t\tzip.outputStream.pipe(zipStream);\n\n\t\tzip.outputStream.once('error', e);\n\t\tzipStream.once('error', e);\n\t\tzipStream.once('finish', () => c(zipPath));\n\t});\n}\n\nexport function extract(zipPath: string, targetPath: string, options: IExtractOptions = {}, token: CancellationToken): Promise<void> {\n\tconst sourcePathRegex = new RegExp(options.sourcePath ? `^${options.sourcePath}` : '');\n\n\tlet promise = openZip(zipPath, true);\n\n\tif (options.overwrite) {\n\t\tpromise = promise.then(zipfile => Promises.rm(targetPath).then(() => zipfile));\n\t}\n\n\treturn promise.then(zipfile => extractZip(zipfile, targetPath, { sourcePathRegex }, token));\n}\n\nfunction read(zipPath: string, filePath: string): Promise<Readable> {\n\treturn openZip(zipPath).then(zipfile => {\n\t\treturn new Promise<Readable>((c, e) => {\n\t\t\tzipfile.on('entry', (entry: Entry) => {\n\t\t\t\tif (entry.fileName === filePath) {\n\t\t\t\t\topenZipStream(zipfile, entry).then(stream => c(stream), err => e(err));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tzipfile.once('close', () => e(new Error(nls.localize('notFound', \"{0} not found inside zip.\", filePath))));\n\t\t});\n\t});\n}\n\nexport function buffer(zipPath: string, filePath: string): Promise<Buffer> {\n\treturn read(zipPath, filePath).then(stream => {\n\t\treturn new Promise<Buffer>((c, e) => {\n\t\t\tconst buffers: Buffer[] = [];\n\t\t\tstream.once('error', e);\n\t\t\tstream.on('data', (b: Buffer) => buffers.push(b));\n\t\t\tstream.on('end', () => c(Buffer.concat(buffers)));\n\t\t});\n\t});\n}\n"]}