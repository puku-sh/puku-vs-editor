{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/node/powershell.ts","vs/base/node/powershell.ts"],"names":[],"mappings":"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","file":"powershell.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as os from 'os';\nimport * as path from '../common/path.js';\nimport * as pfs from './pfs.js';\n\n// This is required, since parseInt(\"7-preview\") will return 7.\nconst IntRegex: RegExp = /^\\d+$/;\n\nconst PwshMsixRegex: RegExp = /^Microsoft.PowerShell_.*/;\nconst PwshPreviewMsixRegex: RegExp = /^Microsoft.PowerShellPreview_.*/;\n\nconst enum Arch {\n\tx64,\n\tx86,\n\tARM\n}\n\nlet processArch: Arch;\nswitch (process.arch) {\n\tcase 'ia32':\n\t\tprocessArch = Arch.x86;\n\t\tbreak;\n\tcase 'arm':\n\tcase 'arm64':\n\t\tprocessArch = Arch.ARM;\n\t\tbreak;\n\tdefault:\n\t\tprocessArch = Arch.x64;\n\t\tbreak;\n}\n\n/*\nCurrently, here are the values for these environment variables on their respective archs:\n\nOn x86 process on x86:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn x86 process on x64:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is AMD64\n\nOn x64 process on x64:\nPROCESSOR_ARCHITECTURE is AMD64\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn ARM process on ARM:\nPROCESSOR_ARCHITECTURE is ARM64\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn x86 process on ARM:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is ARM64\n\nOn x64 process on ARM:\nPROCESSOR_ARCHITECTURE is ARM64\nPROCESSOR_ARCHITEW6432 is undefined\n*/\nlet osArch: Arch;\nif (process.env['PROCESSOR_ARCHITEW6432']) {\n\tosArch = process.env['PROCESSOR_ARCHITEW6432'] === 'ARM64'\n\t\t? Arch.ARM\n\t\t: Arch.x64;\n} else if (process.env['PROCESSOR_ARCHITECTURE'] === 'ARM64') {\n\tosArch = Arch.ARM;\n} else if (process.env['PROCESSOR_ARCHITECTURE'] === 'X86') {\n\tosArch = Arch.x86;\n} else {\n\tosArch = Arch.x64;\n}\n\nexport interface IPowerShellExeDetails {\n\treadonly displayName: string;\n\treadonly exePath: string;\n}\n\ninterface IPossiblePowerShellExe extends IPowerShellExeDetails {\n\texists(): Promise<boolean>;\n}\n\nclass PossiblePowerShellExe implements IPossiblePowerShellExe {\n\tconstructor(\n\t\tpublic readonly exePath: string,\n\t\tpublic readonly displayName: string,\n\t\tprivate knownToExist?: boolean) { }\n\n\tpublic async exists(): Promise<boolean> {\n\t\tif (this.knownToExist === undefined) {\n\t\t\tthis.knownToExist = await pfs.SymlinkSupport.existsFile(this.exePath);\n\t\t}\n\t\treturn this.knownToExist;\n\t}\n}\n\nfunction getProgramFilesPath(\n\t{ useAlternateBitness = false }: { useAlternateBitness?: boolean } = {}): string | null {\n\n\tif (!useAlternateBitness) {\n\t\t// Just use the native system bitness\n\t\treturn process.env.ProgramFiles || null;\n\t}\n\n\t// We might be a 64-bit process looking for 32-bit program files\n\tif (processArch === Arch.x64) {\n\t\treturn process.env['ProgramFiles(x86)'] || null;\n\t}\n\n\t// We might be a 32-bit process looking for 64-bit program files\n\tif (osArch === Arch.x64) {\n\t\treturn process.env.ProgramW6432 || null;\n\t}\n\n\t// We're a 32-bit process on 32-bit Windows, there is no other Program Files dir\n\treturn null;\n}\n\nasync function findPSCoreWindowsInstallation(\n\t{ useAlternateBitness = false, findPreview = false }:\n\t\t{ useAlternateBitness?: boolean; findPreview?: boolean } = {}): Promise<IPossiblePowerShellExe | null> {\n\n\tconst programFilesPath = getProgramFilesPath({ useAlternateBitness });\n\tif (!programFilesPath) {\n\t\treturn null;\n\t}\n\n\tconst powerShellInstallBaseDir = path.join(programFilesPath, 'PowerShell');\n\n\t// Ensure the base directory exists\n\tif (!await pfs.SymlinkSupport.existsDirectory(powerShellInstallBaseDir)) {\n\t\treturn null;\n\t}\n\n\tlet highestSeenVersion: number = -1;\n\tlet pwshExePath: string | null = null;\n\tfor (const item of await pfs.Promises.readdir(powerShellInstallBaseDir)) {\n\n\t\tlet currentVersion: number = -1;\n\t\tif (findPreview) {\n\t\t\t// We are looking for something like \"7-preview\"\n\n\t\t\t// Preview dirs all have dashes in them\n\t\t\tconst dashIndex = item.indexOf('-');\n\t\t\tif (dashIndex < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Verify that the part before the dash is an integer\n\t\t\t// and that the part after the dash is \"preview\"\n\t\t\tconst intPart: string = item.substring(0, dashIndex);\n\t\t\tif (!IntRegex.test(intPart) || item.substring(dashIndex + 1) !== 'preview') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrentVersion = parseInt(intPart, 10);\n\t\t} else {\n\t\t\t// Search for a directory like \"6\" or \"7\"\n\t\t\tif (!IntRegex.test(item)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrentVersion = parseInt(item, 10);\n\t\t}\n\n\t\t// Ensure we haven't already seen a higher version\n\t\tif (currentVersion <= highestSeenVersion) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Now look for the file\n\t\tconst exePath = path.join(powerShellInstallBaseDir, item, 'pwsh.exe');\n\t\tif (!await pfs.SymlinkSupport.existsFile(exePath)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpwshExePath = exePath;\n\t\thighestSeenVersion = currentVersion;\n\t}\n\n\tif (!pwshExePath) {\n\t\treturn null;\n\t}\n\n\tconst bitness: string = programFilesPath.includes('x86') ? ' (x86)' : '';\n\tconst preview: string = findPreview ? ' Preview' : '';\n\n\treturn new PossiblePowerShellExe(pwshExePath, `PowerShell${preview}${bitness}`, true);\n}\n\nasync function findPSCoreMsix({ findPreview }: { findPreview?: boolean } = {}): Promise<IPossiblePowerShellExe | null> {\n\t// We can't proceed if there's no LOCALAPPDATA path\n\tif (!process.env.LOCALAPPDATA) {\n\t\treturn null;\n\t}\n\n\t// Find the base directory for MSIX application exe shortcuts\n\tconst msixAppDir = path.join(process.env.LOCALAPPDATA, 'Microsoft', 'WindowsApps');\n\n\tif (!await pfs.SymlinkSupport.existsDirectory(msixAppDir)) {\n\t\treturn null;\n\t}\n\n\t// Define whether we're looking for the preview or the stable\n\tconst { pwshMsixDirRegex, pwshMsixName } = findPreview\n\t\t? { pwshMsixDirRegex: PwshPreviewMsixRegex, pwshMsixName: 'PowerShell Preview (Store)' }\n\t\t: { pwshMsixDirRegex: PwshMsixRegex, pwshMsixName: 'PowerShell (Store)' };\n\n\t// We should find only one such application, so return on the first one\n\tfor (const subdir of await pfs.Promises.readdir(msixAppDir)) {\n\t\tif (pwshMsixDirRegex.test(subdir)) {\n\t\t\tconst pwshMsixPath = path.join(msixAppDir, subdir, 'pwsh.exe');\n\t\t\treturn new PossiblePowerShellExe(pwshMsixPath, pwshMsixName);\n\t\t}\n\t}\n\n\t// If we find nothing, return null\n\treturn null;\n}\n\nfunction findPSCoreDotnetGlobalTool(): IPossiblePowerShellExe {\n\tconst dotnetGlobalToolExePath: string = path.join(os.homedir(), '.dotnet', 'tools', 'pwsh.exe');\n\n\treturn new PossiblePowerShellExe(dotnetGlobalToolExePath, '.NET Core PowerShell Global Tool');\n}\n\nfunction findPSCoreScoopInstallation(): IPossiblePowerShellExe {\n\tconst scoopAppsDir = path.join(os.homedir(), 'scoop', 'apps');\n\tconst scoopPwsh = path.join(scoopAppsDir, 'pwsh', 'current', 'pwsh.exe');\n\n\treturn new PossiblePowerShellExe(scoopPwsh, 'PowerShell (Scoop)');\n}\n\nfunction findWinPS(): IPossiblePowerShellExe | null {\n\tconst winPSPath = path.join(\n\t\tprocess.env.windir!,\n\t\tprocessArch === Arch.x86 && osArch !== Arch.x86 ? 'SysNative' : 'System32',\n\t\t'WindowsPowerShell', 'v1.0', 'powershell.exe');\n\n\treturn new PossiblePowerShellExe(winPSPath, 'Windows PowerShell', true);\n}\n\n/**\n * Iterates through all the possible well-known PowerShell installations on a machine.\n * Returned values may not exist, but come with an .exists property\n * which will check whether the executable exists.\n */\nasync function* enumerateDefaultPowerShellInstallations(): AsyncIterable<IPossiblePowerShellExe> {\n\t// Find PSCore stable first\n\tlet pwshExe = await findPSCoreWindowsInstallation();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Windows may have a 32-bit pwsh.exe\n\tpwshExe = await findPSCoreWindowsInstallation({ useAlternateBitness: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Also look for the MSIX/UWP installation\n\tpwshExe = await findPSCoreMsix();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for the .NET global tool\n\t// Some older versions of PowerShell have a bug in this where startup will fail,\n\t// but this is fixed in newer versions\n\tpwshExe = findPSCoreDotnetGlobalTool();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for PSCore preview\n\tpwshExe = await findPSCoreWindowsInstallation({ findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Find a preview MSIX\n\tpwshExe = await findPSCoreMsix({ findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for pwsh-preview with the opposite bitness\n\tpwshExe = await findPSCoreWindowsInstallation({ useAlternateBitness: true, findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\tpwshExe = await findPSCoreScoopInstallation();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Finally, get Windows PowerShell\n\tpwshExe = findWinPS();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n}\n\n/**\n * Iterates through PowerShell installations on the machine according\n * to configuration passed in through the constructor.\n * PowerShell items returned by this object are verified\n * to exist on the filesystem.\n */\nexport async function* enumeratePowerShellInstallations(): AsyncIterable<IPowerShellExeDetails> {\n\t// Get the default PowerShell installations first\n\tfor await (const defaultPwsh of enumerateDefaultPowerShellInstallations()) {\n\t\tif (await defaultPwsh.exists()) {\n\t\t\tyield defaultPwsh;\n\t\t}\n\t}\n}\n\n/**\n* Returns the first available PowerShell executable found in the search order.\n*/\nexport async function getFirstAvailablePowerShellInstallation(): Promise<IPowerShellExeDetails | null> {\n\tfor await (const pwsh of enumeratePowerShellInstallations()) {\n\t\treturn pwsh;\n\t}\n\treturn null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as os from 'os';\nimport * as path from '../common/path.js';\nimport * as pfs from './pfs.js';\n\n// This is required, since parseInt(\"7-preview\") will return 7.\nconst IntRegex: RegExp = /^\\d+$/;\n\nconst PwshMsixRegex: RegExp = /^Microsoft.PowerShell_.*/;\nconst PwshPreviewMsixRegex: RegExp = /^Microsoft.PowerShellPreview_.*/;\n\nconst enum Arch {\n\tx64,\n\tx86,\n\tARM\n}\n\nlet processArch: Arch;\nswitch (process.arch) {\n\tcase 'ia32':\n\t\tprocessArch = Arch.x86;\n\t\tbreak;\n\tcase 'arm':\n\tcase 'arm64':\n\t\tprocessArch = Arch.ARM;\n\t\tbreak;\n\tdefault:\n\t\tprocessArch = Arch.x64;\n\t\tbreak;\n}\n\n/*\nCurrently, here are the values for these environment variables on their respective archs:\n\nOn x86 process on x86:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn x86 process on x64:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is AMD64\n\nOn x64 process on x64:\nPROCESSOR_ARCHITECTURE is AMD64\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn ARM process on ARM:\nPROCESSOR_ARCHITECTURE is ARM64\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn x86 process on ARM:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is ARM64\n\nOn x64 process on ARM:\nPROCESSOR_ARCHITECTURE is ARM64\nPROCESSOR_ARCHITEW6432 is undefined\n*/\nlet osArch: Arch;\nif (process.env['PROCESSOR_ARCHITEW6432']) {\n\tosArch = process.env['PROCESSOR_ARCHITEW6432'] === 'ARM64'\n\t\t? Arch.ARM\n\t\t: Arch.x64;\n} else if (process.env['PROCESSOR_ARCHITECTURE'] === 'ARM64') {\n\tosArch = Arch.ARM;\n} else if (process.env['PROCESSOR_ARCHITECTURE'] === 'X86') {\n\tosArch = Arch.x86;\n} else {\n\tosArch = Arch.x64;\n}\n\nexport interface IPowerShellExeDetails {\n\treadonly displayName: string;\n\treadonly exePath: string;\n}\n\ninterface IPossiblePowerShellExe extends IPowerShellExeDetails {\n\texists(): Promise<boolean>;\n}\n\nclass PossiblePowerShellExe implements IPossiblePowerShellExe {\n\tconstructor(\n\t\tpublic readonly exePath: string,\n\t\tpublic readonly displayName: string,\n\t\tprivate knownToExist?: boolean) { }\n\n\tpublic async exists(): Promise<boolean> {\n\t\tif (this.knownToExist === undefined) {\n\t\t\tthis.knownToExist = await pfs.SymlinkSupport.existsFile(this.exePath);\n\t\t}\n\t\treturn this.knownToExist;\n\t}\n}\n\nfunction getProgramFilesPath(\n\t{ useAlternateBitness = false }: { useAlternateBitness?: boolean } = {}): string | null {\n\n\tif (!useAlternateBitness) {\n\t\t// Just use the native system bitness\n\t\treturn process.env.ProgramFiles || null;\n\t}\n\n\t// We might be a 64-bit process looking for 32-bit program files\n\tif (processArch === Arch.x64) {\n\t\treturn process.env['ProgramFiles(x86)'] || null;\n\t}\n\n\t// We might be a 32-bit process looking for 64-bit program files\n\tif (osArch === Arch.x64) {\n\t\treturn process.env.ProgramW6432 || null;\n\t}\n\n\t// We're a 32-bit process on 32-bit Windows, there is no other Program Files dir\n\treturn null;\n}\n\nasync function findPSCoreWindowsInstallation(\n\t{ useAlternateBitness = false, findPreview = false }:\n\t\t{ useAlternateBitness?: boolean; findPreview?: boolean } = {}): Promise<IPossiblePowerShellExe | null> {\n\n\tconst programFilesPath = getProgramFilesPath({ useAlternateBitness });\n\tif (!programFilesPath) {\n\t\treturn null;\n\t}\n\n\tconst powerShellInstallBaseDir = path.join(programFilesPath, 'PowerShell');\n\n\t// Ensure the base directory exists\n\tif (!await pfs.SymlinkSupport.existsDirectory(powerShellInstallBaseDir)) {\n\t\treturn null;\n\t}\n\n\tlet highestSeenVersion: number = -1;\n\tlet pwshExePath: string | null = null;\n\tfor (const item of await pfs.Promises.readdir(powerShellInstallBaseDir)) {\n\n\t\tlet currentVersion: number = -1;\n\t\tif (findPreview) {\n\t\t\t// We are looking for something like \"7-preview\"\n\n\t\t\t// Preview dirs all have dashes in them\n\t\t\tconst dashIndex = item.indexOf('-');\n\t\t\tif (dashIndex < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Verify that the part before the dash is an integer\n\t\t\t// and that the part after the dash is \"preview\"\n\t\t\tconst intPart: string = item.substring(0, dashIndex);\n\t\t\tif (!IntRegex.test(intPart) || item.substring(dashIndex + 1) !== 'preview') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrentVersion = parseInt(intPart, 10);\n\t\t} else {\n\t\t\t// Search for a directory like \"6\" or \"7\"\n\t\t\tif (!IntRegex.test(item)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrentVersion = parseInt(item, 10);\n\t\t}\n\n\t\t// Ensure we haven't already seen a higher version\n\t\tif (currentVersion <= highestSeenVersion) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Now look for the file\n\t\tconst exePath = path.join(powerShellInstallBaseDir, item, 'pwsh.exe');\n\t\tif (!await pfs.SymlinkSupport.existsFile(exePath)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpwshExePath = exePath;\n\t\thighestSeenVersion = currentVersion;\n\t}\n\n\tif (!pwshExePath) {\n\t\treturn null;\n\t}\n\n\tconst bitness: string = programFilesPath.includes('x86') ? ' (x86)' : '';\n\tconst preview: string = findPreview ? ' Preview' : '';\n\n\treturn new PossiblePowerShellExe(pwshExePath, `PowerShell${preview}${bitness}`, true);\n}\n\nasync function findPSCoreMsix({ findPreview }: { findPreview?: boolean } = {}): Promise<IPossiblePowerShellExe | null> {\n\t// We can't proceed if there's no LOCALAPPDATA path\n\tif (!process.env.LOCALAPPDATA) {\n\t\treturn null;\n\t}\n\n\t// Find the base directory for MSIX application exe shortcuts\n\tconst msixAppDir = path.join(process.env.LOCALAPPDATA, 'Microsoft', 'WindowsApps');\n\n\tif (!await pfs.SymlinkSupport.existsDirectory(msixAppDir)) {\n\t\treturn null;\n\t}\n\n\t// Define whether we're looking for the preview or the stable\n\tconst { pwshMsixDirRegex, pwshMsixName } = findPreview\n\t\t? { pwshMsixDirRegex: PwshPreviewMsixRegex, pwshMsixName: 'PowerShell Preview (Store)' }\n\t\t: { pwshMsixDirRegex: PwshMsixRegex, pwshMsixName: 'PowerShell (Store)' };\n\n\t// We should find only one such application, so return on the first one\n\tfor (const subdir of await pfs.Promises.readdir(msixAppDir)) {\n\t\tif (pwshMsixDirRegex.test(subdir)) {\n\t\t\tconst pwshMsixPath = path.join(msixAppDir, subdir, 'pwsh.exe');\n\t\t\treturn new PossiblePowerShellExe(pwshMsixPath, pwshMsixName);\n\t\t}\n\t}\n\n\t// If we find nothing, return null\n\treturn null;\n}\n\nfunction findPSCoreDotnetGlobalTool(): IPossiblePowerShellExe {\n\tconst dotnetGlobalToolExePath: string = path.join(os.homedir(), '.dotnet', 'tools', 'pwsh.exe');\n\n\treturn new PossiblePowerShellExe(dotnetGlobalToolExePath, '.NET Core PowerShell Global Tool');\n}\n\nfunction findPSCoreScoopInstallation(): IPossiblePowerShellExe {\n\tconst scoopAppsDir = path.join(os.homedir(), 'scoop', 'apps');\n\tconst scoopPwsh = path.join(scoopAppsDir, 'pwsh', 'current', 'pwsh.exe');\n\n\treturn new PossiblePowerShellExe(scoopPwsh, 'PowerShell (Scoop)');\n}\n\nfunction findWinPS(): IPossiblePowerShellExe | null {\n\tconst winPSPath = path.join(\n\t\tprocess.env.windir!,\n\t\tprocessArch === Arch.x86 && osArch !== Arch.x86 ? 'SysNative' : 'System32',\n\t\t'WindowsPowerShell', 'v1.0', 'powershell.exe');\n\n\treturn new PossiblePowerShellExe(winPSPath, 'Windows PowerShell', true);\n}\n\n/**\n * Iterates through all the possible well-known PowerShell installations on a machine.\n * Returned values may not exist, but come with an .exists property\n * which will check whether the executable exists.\n */\nasync function* enumerateDefaultPowerShellInstallations(): AsyncIterable<IPossiblePowerShellExe> {\n\t// Find PSCore stable first\n\tlet pwshExe = await findPSCoreWindowsInstallation();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Windows may have a 32-bit pwsh.exe\n\tpwshExe = await findPSCoreWindowsInstallation({ useAlternateBitness: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Also look for the MSIX/UWP installation\n\tpwshExe = await findPSCoreMsix();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for the .NET global tool\n\t// Some older versions of PowerShell have a bug in this where startup will fail,\n\t// but this is fixed in newer versions\n\tpwshExe = findPSCoreDotnetGlobalTool();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for PSCore preview\n\tpwshExe = await findPSCoreWindowsInstallation({ findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Find a preview MSIX\n\tpwshExe = await findPSCoreMsix({ findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for pwsh-preview with the opposite bitness\n\tpwshExe = await findPSCoreWindowsInstallation({ useAlternateBitness: true, findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\tpwshExe = await findPSCoreScoopInstallation();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Finally, get Windows PowerShell\n\tpwshExe = findWinPS();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n}\n\n/**\n * Iterates through PowerShell installations on the machine according\n * to configuration passed in through the constructor.\n * PowerShell items returned by this object are verified\n * to exist on the filesystem.\n */\nexport async function* enumeratePowerShellInstallations(): AsyncIterable<IPowerShellExeDetails> {\n\t// Get the default PowerShell installations first\n\tfor await (const defaultPwsh of enumerateDefaultPowerShellInstallations()) {\n\t\tif (await defaultPwsh.exists()) {\n\t\t\tyield defaultPwsh;\n\t\t}\n\t}\n}\n\n/**\n* Returns the first available PowerShell executable found in the search order.\n*/\nexport async function getFirstAvailablePowerShellInstallation(): Promise<IPowerShellExeDetails | null> {\n\tfor await (const pwsh of enumeratePowerShellInstallations()) {\n\t\treturn pwsh;\n\t}\n\treturn null;\n}\n"]}