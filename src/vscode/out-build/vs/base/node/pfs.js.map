{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/node/pfs.ts","vs/base/node/pfs.ts"],"names":[],"mappings":"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","file":"pfs.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { tmpdir } from 'os';\nimport { promisify } from 'util';\nimport { ResourceQueue, timeout } from '../common/async.js';\nimport { isEqualOrParent, isRootOrDriveLetter, randomPath } from '../common/extpath.js';\nimport { normalizeNFC } from '../common/normalization.js';\nimport { basename, dirname, join, normalize, sep } from '../common/path.js';\nimport { isLinux, isMacintosh, isWindows } from '../common/platform.js';\nimport { extUriBiasedIgnorePathCase } from '../common/resources.js';\nimport { URI } from '../common/uri.js';\nimport { CancellationToken } from '../common/cancellation.js';\nimport { rtrim } from '../common/strings.js';\n\n//#region rimraf\n\nexport enum RimRafMode {\n\n\t/**\n\t * Slow version that unlinks each file and folder.\n\t */\n\tUNLINK,\n\n\t/**\n\t * Fast version that first moves the file/folder\n\t * into a temp directory and then deletes that\n\t * without waiting for it.\n\t */\n\tMOVE\n}\n\n/**\n * Allows to delete the provided path (either file or folder) recursively\n * with the options:\n * - `UNLINK`: direct removal from disk\n * - `MOVE`: faster variant that first moves the target to temp dir and then\n *           deletes it in the background without waiting for that to finish.\n *           the optional `moveToPath` allows to override where to rename the\n *           path to before deleting it.\n */\nasync function rimraf(path: string, mode: RimRafMode.UNLINK): Promise<void>;\nasync function rimraf(path: string, mode: RimRafMode.MOVE, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode?: RimRafMode, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode = RimRafMode.UNLINK, moveToPath?: string): Promise<void> {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\t// delete: via rm\n\tif (mode === RimRafMode.UNLINK) {\n\t\treturn rimrafUnlink(path);\n\t}\n\n\t// delete: via move\n\treturn rimrafMove(path, moveToPath);\n}\n\nasync function rimrafMove(path: string, moveToPath = randomPath(tmpdir())): Promise<void> {\n\ttry {\n\t\ttry {\n\t\t\tawait fs.promises.rename(path, moveToPath);\n\t\t} catch (error) {\n\t\t\tif (error.code === 'ENOENT') {\n\t\t\t\treturn; // ignore - path to delete did not exist\n\t\t\t}\n\n\t\t\treturn rimrafUnlink(path); // otherwise fallback to unlink\n\t\t}\n\n\t\t// Delete but do not return as promise\n\t\trimrafUnlink(moveToPath).catch(() => {/* ignore */ });\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function rimrafUnlink(path: string): Promise<void> {\n\treturn fs.promises.rm(path, { recursive: true, force: true, maxRetries: 3 });\n}\n\n//#endregion\n\n//#region readdir with NFC support (macos)\n\nexport interface IDirent {\n\tname: string;\n\n\tisFile(): boolean;\n\tisDirectory(): boolean;\n\tisSymbolicLink(): boolean;\n}\n\n/**\n * Drop-in replacement of `fs.readdir` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nasync function readdir(path: string): Promise<string[]>;\nasync function readdir(path: string, options: { withFileTypes: true }): Promise<IDirent[]>;\nasync function readdir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\ttry {\n\t\treturn await doReaddir(path, options);\n\t} catch (error) {\n\t\t// Workaround for #252361 that should be removed once the upstream issue\n\t\t// in node.js is resolved. Adds a trailing dot to a root drive letter path\n\t\t// (G:\\ => G:\\.) as a workaround.\n\t\tif (error.code === 'ENOENT' && isWindows && isRootOrDriveLetter(path)) {\n\t\t\ttry {\n\t\t\t\treturn await doReaddir(`${path}.`, options);\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\tthrow error;\n\t}\n}\n\nasync function doReaddir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\treturn handleDirectoryChildren(await (options ? safeReaddirWithFileTypes(path) : fs.promises.readdir(path)));\n}\n\nasync function safeReaddirWithFileTypes(path: string): Promise<IDirent[]> {\n\ttry {\n\t\treturn await fs.promises.readdir(path, { withFileTypes: true });\n\t} catch (error) {\n\t\tconsole.warn('[node.js fs] readdir with filetypes failed with error: ', error);\n\t}\n\n\t// Fallback to manually reading and resolving each\n\t// children of the folder in case we hit an error\n\t// previously.\n\t// This can only really happen on exotic file systems\n\t// such as explained in #115645 where we get entries\n\t// from `readdir` that we can later not `lstat`.\n\tconst result: IDirent[] = [];\n\tconst children = await readdir(path);\n\tfor (const child of children) {\n\t\tlet isFile = false;\n\t\tlet isDirectory = false;\n\t\tlet isSymbolicLink = false;\n\n\t\ttry {\n\t\t\tconst lstat = await fs.promises.lstat(join(path, child));\n\n\t\t\tisFile = lstat.isFile();\n\t\t\tisDirectory = lstat.isDirectory();\n\t\t\tisSymbolicLink = lstat.isSymbolicLink();\n\t\t} catch (error) {\n\t\t\tconsole.warn('[node.js fs] unexpected error from lstat after readdir: ', error);\n\t\t}\n\n\t\tresult.push({\n\t\t\tname: child,\n\t\t\tisFile: () => isFile,\n\t\t\tisDirectory: () => isDirectory,\n\t\t\tisSymbolicLink: () => isSymbolicLink\n\t\t});\n\t}\n\n\treturn result;\n}\n\nfunction handleDirectoryChildren(children: string[]): string[];\nfunction handleDirectoryChildren(children: IDirent[]): IDirent[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[] {\n\treturn children.map(child => {\n\n\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t// See also https://github.com/nodejs/node/issues/2165\n\n\t\tif (typeof child === 'string') {\n\t\t\treturn isMacintosh ? normalizeNFC(child) : child;\n\t\t}\n\n\t\tchild.name = isMacintosh ? normalizeNFC(child.name) : child.name;\n\n\t\treturn child;\n\t});\n}\n\n/**\n * A convenience method to read all children of a path that\n * are directories.\n */\nasync function readDirsInDir(dirPath: string): Promise<string[]> {\n\tconst children = await readdir(dirPath);\n\tconst directories: string[] = [];\n\n\tfor (const child of children) {\n\t\tif (await SymlinkSupport.existsDirectory(join(dirPath, child))) {\n\t\t\tdirectories.push(child);\n\t\t}\n\t}\n\n\treturn directories;\n}\n\n//#endregion\n\n//#region whenDeleted()\n\n/**\n * A `Promise` that resolves when the provided `path`\n * is deleted from disk.\n */\nexport function whenDeleted(path: string, intervalMs = 1000): Promise<void> {\n\treturn new Promise<void>(resolve => {\n\t\tlet running = false;\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!running) {\n\t\t\t\trunning = true;\n\t\t\t\tfs.access(path, err => {\n\t\t\t\t\trunning = false;\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, intervalMs);\n\t});\n}\n\n//#endregion\n\n//#region Methods with symbolic links support\n\nexport namespace SymlinkSupport {\n\n\texport interface IStats {\n\n\t\t// The stats of the file. If the file is a symbolic\n\t\t// link, the stats will be of that target file and\n\t\t// not the link itself.\n\t\t// If the file is a symbolic link pointing to a non\n\t\t// existing file, the stat will be of the link and\n\t\t// the `dangling` flag will indicate this.\n\t\tstat: fs.Stats;\n\n\t\t// Will be provided if the resource is a symbolic link\n\t\t// on disk. Use the `dangling` flag to find out if it\n\t\t// points to a resource that does not exist on disk.\n\t\tsymbolicLink?: { dangling: boolean };\n\t}\n\n\t/**\n\t * Resolves the `fs.Stats` of the provided path. If the path is a\n\t * symbolic link, the `fs.Stats` will be from the target it points\n\t * to. If the target does not exist, `dangling: true` will be returned\n\t * as `symbolicLink` value.\n\t */\n\texport async function stat(path: string): Promise<IStats> {\n\n\t\t// First stat the link\n\t\tlet lstats: fs.Stats | undefined;\n\t\ttry {\n\t\t\tlstats = await fs.promises.lstat(path);\n\n\t\t\t// Return early if the stat is not a symbolic link at all\n\t\t\tif (!lstats.isSymbolicLink()) {\n\t\t\t\treturn { stat: lstats };\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore - use stat() instead */\n\t\t}\n\n\t\t// If the stat is a symbolic link or failed to stat, use fs.stat()\n\t\t// which for symbolic links will stat the target they point to\n\t\ttry {\n\t\t\tconst stats = await fs.promises.stat(path);\n\n\t\t\treturn { stat: stats, symbolicLink: lstats?.isSymbolicLink() ? { dangling: false } : undefined };\n\t\t} catch (error) {\n\n\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t// to return it as result while setting dangling: true flag\n\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t}\n\n\t\t\t// Windows: workaround a node.js bug where reparse points\n\t\t\t// are not supported (https://github.com/nodejs/node/issues/36790)\n\t\t\tif (isWindows && error.code === 'EACCES') {\n\t\t\t\ttry {\n\t\t\t\t\tconst stats = await fs.promises.stat(await fs.promises.readlink(path));\n\n\t\t\t\t\treturn { stat: stats, symbolicLink: { dangling: false } };\n\t\t\t\t} catch (error) {\n\n\t\t\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t\t\t// to return it as result while setting dangling: true flag\n\t\t\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a file with support\n\t * for symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsFile(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isFile() && symbolicLink?.dangling !== true;\n\t\t} catch {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a directory with support for\n\t * symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsDirectory(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isDirectory() && symbolicLink?.dangling !== true;\n\t\t} catch {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n//#endregion\n\n//#region Write File\n\n// According to node.js docs (https://nodejs.org/docs/v14.16.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nconst writeQueues = new ResourceQueue();\n\n/**\n * Same as `fs.writeFile` but with an additional call to\n * `fs.fdatasync` after writing to ensure changes are\n * flushed to disk.\n *\n * In addition, multiple writes to the same path are queued.\n */\nfunction writeFile(path: string, data: string, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Buffer, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void> {\n\treturn writeQueues.queueFor(URI.file(path), () => {\n\t\tconst ensuredOptions = ensureWriteOptions(options);\n\n\t\treturn new Promise((resolve, reject) => doWriteFileAndFlush(path, data, ensuredOptions, error => error ? reject(error) : resolve()));\n\t}, extUriBiasedIgnorePathCase);\n}\n\ninterface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n}\n\ninterface IEnsuredWriteFileOptions extends IWriteFileOptions {\n\tmode: number;\n\tflag: string;\n}\n\nlet canFlush = true;\nexport function configureFlushOnWrite(enabled: boolean): void {\n\tcanFlush = enabled;\n}\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer | Uint8Array, options: IEnsuredWriteFileOptions, callback: (error: Error | null) => void): void {\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, options.flag, options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(fd, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\t// https://github.com/microsoft/vscode/issues/9589\n\t\t\tfs.fdatasync(fd, (syncError: Error | null) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tconfigureFlushOnWrite(false);\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\n/**\n * Same as `fs.writeFileSync` but with an additional call to\n * `fs.fdatasyncSync` after writing to ensure changes are\n * flushed to disk.\n *\n * @deprecated always prefer async variants over sync!\n */\nexport function writeFileSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\tconst ensuredOptions = ensureWriteOptions(options);\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: ensuredOptions.mode, flag: ensuredOptions.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, ensuredOptions.flag, ensuredOptions.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(fd, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd); // https://github.com/microsoft/vscode/issues/9589\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tconfigureFlushOnWrite(false);\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureWriteOptions(options?: IWriteFileOptions): IEnsuredWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666 /* default node.js mode for files */, flag: 'w' };\n\t}\n\n\treturn {\n\t\tmode: typeof options.mode === 'number' ? options.mode : 0o666 /* default node.js mode for files */,\n\t\tflag: typeof options.flag === 'string' ? options.flag : 'w'\n\t};\n}\n\n//#endregion\n\n//#region Move / Copy\n\n/**\n * A drop-in replacement for `fs.rename` that:\n * - allows to move across multiple disks\n * - attempts to retry the operation for certain error codes on Windows\n */\nasync function rename(source: string, target: string, windowsRetryTimeout: number | false = 60000): Promise<void> {\n\tif (source === target) {\n\t\treturn;  // simulate node.js behaviour here and do a no-op if paths match\n\t}\n\n\ttry {\n\t\tif (isWindows && typeof windowsRetryTimeout === 'number') {\n\t\t\t// On Windows, a rename can fail when either source or target\n\t\t\t// is locked by AV software.\n\t\t\tawait renameWithRetry(source, target, Date.now(), windowsRetryTimeout);\n\t\t} else {\n\t\t\tawait fs.promises.rename(source, target);\n\t\t}\n\t} catch (error) {\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (source.toLowerCase() !== target.toLowerCase() && error.code === 'EXDEV' || source.endsWith('.')) {\n\t\t\tawait copy(source, target, { preserveSymlinks: false /* copying to another device */ });\n\t\t\tawait rimraf(source, RimRafMode.MOVE);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function renameWithRetry(source: string, target: string, startTime: number, retryTimeout: number, attempt = 0): Promise<void> {\n\ttry {\n\t\treturn await fs.promises.rename(source, target);\n\t} catch (error) {\n\t\tif (error.code !== 'EACCES' && error.code !== 'EPERM' && error.code !== 'EBUSY') {\n\t\t\tthrow error; // only for errors we think are temporary\n\t\t}\n\n\t\tif (Date.now() - startTime >= retryTimeout) {\n\t\t\tconsole.error(`[node.js fs] rename failed after ${attempt} retries with error: ${error}`);\n\n\t\t\tthrow error; // give up after configurable timeout\n\t\t}\n\n\t\tif (attempt === 0) {\n\t\t\tlet abortRetry = false;\n\t\t\ttry {\n\t\t\t\tconst { stat } = await SymlinkSupport.stat(target);\n\t\t\t\tif (!stat.isFile()) {\n\t\t\t\t\tabortRetry = true; // if target is not a file, EPERM error may be raised and we should not attempt to retry\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Ignore\n\t\t\t}\n\n\t\t\tif (abortRetry) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// Delay with incremental backoff up to 100ms\n\t\tawait timeout(Math.min(100, attempt * 10));\n\n\t\t// Attempt again\n\t\treturn renameWithRetry(source, target, startTime, retryTimeout, attempt + 1);\n\t}\n}\n\ninterface ICopyPayload {\n\treadonly root: { source: string; target: string };\n\treadonly options: { preserveSymlinks: boolean };\n\treadonly handledSourcePaths: Set<string>;\n}\n\n/**\n * Recursively copies all of `source` to `target`.\n *\n * The options `preserveSymlinks` configures how symbolic\n * links should be handled when encountered. Set to\n * `false` to not preserve them and `true` otherwise.\n */\nasync function copy(source: string, target: string, options: { preserveSymlinks: boolean }): Promise<void> {\n\treturn doCopy(source, target, { root: { source, target }, options, handledSourcePaths: new Set<string>() });\n}\n\n// When copying a file or folder, we want to preserve the mode\n// it had and as such provide it when creating. However, modes\n// can go beyond what we expect (see link below), so we mask it.\n// (https://github.com/nodejs/node-v0.x-archive/issues/3045#issuecomment-4862588)\nconst COPY_MODE_MASK = 0o777;\n\nasync function doCopy(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Keep track of paths already copied to prevent\n\t// cycles from symbolic links to cause issues\n\tif (payload.handledSourcePaths.has(source)) {\n\t\treturn;\n\t} else {\n\t\tpayload.handledSourcePaths.add(source);\n\t}\n\n\tconst { stat, symbolicLink } = await SymlinkSupport.stat(source);\n\n\t// Symlink\n\tif (symbolicLink) {\n\n\t\t// Try to re-create the symlink unless `preserveSymlinks: false`\n\t\tif (payload.options.preserveSymlinks) {\n\t\t\ttry {\n\t\t\t\treturn await doCopySymlink(source, target, payload);\n\t\t\t} catch {\n\t\t\t\t// in any case of an error fallback to normal copy via dereferencing\n\t\t\t}\n\t\t}\n\n\t\tif (symbolicLink.dangling) {\n\t\t\treturn; // skip dangling symbolic links from here on (https://github.com/microsoft/vscode/issues/111621)\n\t\t}\n\t}\n\n\t// Folder\n\tif (stat.isDirectory()) {\n\t\treturn doCopyDirectory(source, target, stat.mode & COPY_MODE_MASK, payload);\n\t}\n\n\t// File or file-like\n\telse {\n\t\treturn doCopyFile(source, target, stat.mode & COPY_MODE_MASK);\n\t}\n}\n\nasync function doCopyDirectory(source: string, target: string, mode: number, payload: ICopyPayload): Promise<void> {\n\n\t// Create folder\n\tawait fs.promises.mkdir(target, { recursive: true, mode });\n\n\t// Copy each file recursively\n\tconst files = await readdir(source);\n\tfor (const file of files) {\n\t\tawait doCopy(join(source, file), join(target, file), payload);\n\t}\n}\n\nasync function doCopyFile(source: string, target: string, mode: number): Promise<void> {\n\n\t// Copy file\n\tawait fs.promises.copyFile(source, target);\n\n\t// restore mode (https://github.com/nodejs/node/issues/1104)\n\tawait fs.promises.chmod(target, mode);\n}\n\nasync function doCopySymlink(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Figure out link target\n\tlet linkTarget = await fs.promises.readlink(source);\n\n\t// Special case: the symlink points to a target that is\n\t// actually within the path that is being copied. In that\n\t// case we want the symlink to point to the target and\n\t// not the source\n\tif (isEqualOrParent(linkTarget, payload.root.source, !isLinux)) {\n\t\tlinkTarget = join(payload.root.target, linkTarget.substr(payload.root.source.length + 1));\n\t}\n\n\t// Create symlink\n\tawait fs.promises.symlink(linkTarget, target);\n}\n\n//#endregion\n\n//#region Path resolvers\n\n/**\n * Given an absolute, normalized, and existing file path 'realcase' returns the\n * exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original\n * path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the\n * original path.\n * In case of errors, null is returned. But you cannot use this function to verify that\n * a path exists.\n *\n * realcase does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nexport async function realcase(path: string, token?: CancellationToken): Promise<string | null> {\n\tif (isLinux) {\n\t\t// This method is unsupported on OS that have case sensitive\n\t\t// file system where the same path can exist in different forms\n\t\t// (see also https://github.com/microsoft/vscode/issues/139709)\n\t\treturn path;\n\t}\n\n\tconst dir = dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst entries = await Promises.readdir(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = await realcase(dir, token);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = await realcase(dir, token);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nasync function realpath(path: string): Promise<string> {\n\ttry {\n\t\t// DO NOT USE `fs.promises.realpath` here as it internally\n\t\t// calls `fs.native.realpath` which will result in subst\n\t\t// drives to be resolved to their target on Windows\n\t\t// https://github.com/microsoft/vscode/issues/118562\n\t\treturn await promisify(fs.realpath)(path);\n\t} catch {\n\n\t\t// We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tawait fs.promises.access(normalizedPath, fs.constants.R_OK);\n\n\t\treturn normalizedPath;\n\t}\n}\n\n/**\n * @deprecated always prefer async variants over sync!\n */\nexport function realpathSync(path: string): string {\n\ttry {\n\t\treturn fs.realpathSync(path);\n\t} catch {\n\n\t\t// We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tfs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n\n\t\treturn normalizedPath;\n\t}\n}\n\nfunction normalizePath(path: string): string {\n\treturn rtrim(normalize(path), sep);\n}\n\n//#endregion\n\n//#region Promise based fs methods\n\n/**\n * Some low level `fs` methods provided as `Promises` similar to\n * `fs.promises` but with notable differences, either implemented\n * by us or by restoring the original callback based behavior.\n *\n * At least `realpath` is implemented differently in the promise\n * based implementation compared to the callback based one. The\n * promise based implementation actually calls `fs.realpath.native`.\n * (https://github.com/microsoft/vscode/issues/118562)\n */\nexport const Promises = new class {\n\n\t//#region Implemented by node.js\n\n\tget read() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes read, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number, length: number, position: number | null) => {\n\t\t\treturn new Promise<{ bytesRead: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesRead, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget write() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes written, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number | undefined | null, length: number | undefined | null, position: number | undefined | null) => {\n\t\t\treturn new Promise<{ bytesWritten: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.write(fd, buffer, offset, length, position, (err, bytesWritten, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesWritten, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget fdatasync() { return promisify(fs.fdatasync); } // not exposed as API in 22.x yet\n\n\tget open() { return promisify(fs.open); } \t\t\t// changed to return `FileHandle` in promise API\n\tget close() { return promisify(fs.close); } \t\t// not exposed as API due to the `FileHandle` return type of `open`\n\n\tget ftruncate() { return promisify(fs.ftruncate); } // not exposed as API in 22.x yet\n\n\t//#endregion\n\n\t//#region Implemented by us\n\n\tasync exists(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait fs.promises.access(path);\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tget readdir() { return readdir; }\n\tget readDirsInDir() { return readDirsInDir; }\n\n\tget writeFile() { return writeFile; }\n\n\tget rm() { return rimraf; }\n\n\tget rename() { return rename; }\n\tget copy() { return copy; }\n\n\tget realpath() { return realpath; }\t// `fs.promises.realpath` will use `fs.realpath.native` which we do not want\n\n\t//#endregion\n};\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { tmpdir } from 'os';\nimport { promisify } from 'util';\nimport { ResourceQueue, timeout } from '../common/async.js';\nimport { isEqualOrParent, isRootOrDriveLetter, randomPath } from '../common/extpath.js';\nimport { normalizeNFC } from '../common/normalization.js';\nimport { basename, dirname, join, normalize, sep } from '../common/path.js';\nimport { isLinux, isMacintosh, isWindows } from '../common/platform.js';\nimport { extUriBiasedIgnorePathCase } from '../common/resources.js';\nimport { URI } from '../common/uri.js';\nimport { CancellationToken } from '../common/cancellation.js';\nimport { rtrim } from '../common/strings.js';\n\n//#region rimraf\n\nexport enum RimRafMode {\n\n\t/**\n\t * Slow version that unlinks each file and folder.\n\t */\n\tUNLINK,\n\n\t/**\n\t * Fast version that first moves the file/folder\n\t * into a temp directory and then deletes that\n\t * without waiting for it.\n\t */\n\tMOVE\n}\n\n/**\n * Allows to delete the provided path (either file or folder) recursively\n * with the options:\n * - `UNLINK`: direct removal from disk\n * - `MOVE`: faster variant that first moves the target to temp dir and then\n *           deletes it in the background without waiting for that to finish.\n *           the optional `moveToPath` allows to override where to rename the\n *           path to before deleting it.\n */\nasync function rimraf(path: string, mode: RimRafMode.UNLINK): Promise<void>;\nasync function rimraf(path: string, mode: RimRafMode.MOVE, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode?: RimRafMode, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode = RimRafMode.UNLINK, moveToPath?: string): Promise<void> {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\t// delete: via rm\n\tif (mode === RimRafMode.UNLINK) {\n\t\treturn rimrafUnlink(path);\n\t}\n\n\t// delete: via move\n\treturn rimrafMove(path, moveToPath);\n}\n\nasync function rimrafMove(path: string, moveToPath = randomPath(tmpdir())): Promise<void> {\n\ttry {\n\t\ttry {\n\t\t\tawait fs.promises.rename(path, moveToPath);\n\t\t} catch (error) {\n\t\t\tif (error.code === 'ENOENT') {\n\t\t\t\treturn; // ignore - path to delete did not exist\n\t\t\t}\n\n\t\t\treturn rimrafUnlink(path); // otherwise fallback to unlink\n\t\t}\n\n\t\t// Delete but do not return as promise\n\t\trimrafUnlink(moveToPath).catch(() => {/* ignore */ });\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function rimrafUnlink(path: string): Promise<void> {\n\treturn fs.promises.rm(path, { recursive: true, force: true, maxRetries: 3 });\n}\n\n//#endregion\n\n//#region readdir with NFC support (macos)\n\nexport interface IDirent {\n\tname: string;\n\n\tisFile(): boolean;\n\tisDirectory(): boolean;\n\tisSymbolicLink(): boolean;\n}\n\n/**\n * Drop-in replacement of `fs.readdir` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nasync function readdir(path: string): Promise<string[]>;\nasync function readdir(path: string, options: { withFileTypes: true }): Promise<IDirent[]>;\nasync function readdir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\ttry {\n\t\treturn await doReaddir(path, options);\n\t} catch (error) {\n\t\t// Workaround for #252361 that should be removed once the upstream issue\n\t\t// in node.js is resolved. Adds a trailing dot to a root drive letter path\n\t\t// (G:\\ => G:\\.) as a workaround.\n\t\tif (error.code === 'ENOENT' && isWindows && isRootOrDriveLetter(path)) {\n\t\t\ttry {\n\t\t\t\treturn await doReaddir(`${path}.`, options);\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\tthrow error;\n\t}\n}\n\nasync function doReaddir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\treturn handleDirectoryChildren(await (options ? safeReaddirWithFileTypes(path) : fs.promises.readdir(path)));\n}\n\nasync function safeReaddirWithFileTypes(path: string): Promise<IDirent[]> {\n\ttry {\n\t\treturn await fs.promises.readdir(path, { withFileTypes: true });\n\t} catch (error) {\n\t\tconsole.warn('[node.js fs] readdir with filetypes failed with error: ', error);\n\t}\n\n\t// Fallback to manually reading and resolving each\n\t// children of the folder in case we hit an error\n\t// previously.\n\t// This can only really happen on exotic file systems\n\t// such as explained in #115645 where we get entries\n\t// from `readdir` that we can later not `lstat`.\n\tconst result: IDirent[] = [];\n\tconst children = await readdir(path);\n\tfor (const child of children) {\n\t\tlet isFile = false;\n\t\tlet isDirectory = false;\n\t\tlet isSymbolicLink = false;\n\n\t\ttry {\n\t\t\tconst lstat = await fs.promises.lstat(join(path, child));\n\n\t\t\tisFile = lstat.isFile();\n\t\t\tisDirectory = lstat.isDirectory();\n\t\t\tisSymbolicLink = lstat.isSymbolicLink();\n\t\t} catch (error) {\n\t\t\tconsole.warn('[node.js fs] unexpected error from lstat after readdir: ', error);\n\t\t}\n\n\t\tresult.push({\n\t\t\tname: child,\n\t\t\tisFile: () => isFile,\n\t\t\tisDirectory: () => isDirectory,\n\t\t\tisSymbolicLink: () => isSymbolicLink\n\t\t});\n\t}\n\n\treturn result;\n}\n\nfunction handleDirectoryChildren(children: string[]): string[];\nfunction handleDirectoryChildren(children: IDirent[]): IDirent[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[] {\n\treturn children.map(child => {\n\n\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t// See also https://github.com/nodejs/node/issues/2165\n\n\t\tif (typeof child === 'string') {\n\t\t\treturn isMacintosh ? normalizeNFC(child) : child;\n\t\t}\n\n\t\tchild.name = isMacintosh ? normalizeNFC(child.name) : child.name;\n\n\t\treturn child;\n\t});\n}\n\n/**\n * A convenience method to read all children of a path that\n * are directories.\n */\nasync function readDirsInDir(dirPath: string): Promise<string[]> {\n\tconst children = await readdir(dirPath);\n\tconst directories: string[] = [];\n\n\tfor (const child of children) {\n\t\tif (await SymlinkSupport.existsDirectory(join(dirPath, child))) {\n\t\t\tdirectories.push(child);\n\t\t}\n\t}\n\n\treturn directories;\n}\n\n//#endregion\n\n//#region whenDeleted()\n\n/**\n * A `Promise` that resolves when the provided `path`\n * is deleted from disk.\n */\nexport function whenDeleted(path: string, intervalMs = 1000): Promise<void> {\n\treturn new Promise<void>(resolve => {\n\t\tlet running = false;\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!running) {\n\t\t\t\trunning = true;\n\t\t\t\tfs.access(path, err => {\n\t\t\t\t\trunning = false;\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, intervalMs);\n\t});\n}\n\n//#endregion\n\n//#region Methods with symbolic links support\n\nexport namespace SymlinkSupport {\n\n\texport interface IStats {\n\n\t\t// The stats of the file. If the file is a symbolic\n\t\t// link, the stats will be of that target file and\n\t\t// not the link itself.\n\t\t// If the file is a symbolic link pointing to a non\n\t\t// existing file, the stat will be of the link and\n\t\t// the `dangling` flag will indicate this.\n\t\tstat: fs.Stats;\n\n\t\t// Will be provided if the resource is a symbolic link\n\t\t// on disk. Use the `dangling` flag to find out if it\n\t\t// points to a resource that does not exist on disk.\n\t\tsymbolicLink?: { dangling: boolean };\n\t}\n\n\t/**\n\t * Resolves the `fs.Stats` of the provided path. If the path is a\n\t * symbolic link, the `fs.Stats` will be from the target it points\n\t * to. If the target does not exist, `dangling: true` will be returned\n\t * as `symbolicLink` value.\n\t */\n\texport async function stat(path: string): Promise<IStats> {\n\n\t\t// First stat the link\n\t\tlet lstats: fs.Stats | undefined;\n\t\ttry {\n\t\t\tlstats = await fs.promises.lstat(path);\n\n\t\t\t// Return early if the stat is not a symbolic link at all\n\t\t\tif (!lstats.isSymbolicLink()) {\n\t\t\t\treturn { stat: lstats };\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore - use stat() instead */\n\t\t}\n\n\t\t// If the stat is a symbolic link or failed to stat, use fs.stat()\n\t\t// which for symbolic links will stat the target they point to\n\t\ttry {\n\t\t\tconst stats = await fs.promises.stat(path);\n\n\t\t\treturn { stat: stats, symbolicLink: lstats?.isSymbolicLink() ? { dangling: false } : undefined };\n\t\t} catch (error) {\n\n\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t// to return it as result while setting dangling: true flag\n\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t}\n\n\t\t\t// Windows: workaround a node.js bug where reparse points\n\t\t\t// are not supported (https://github.com/nodejs/node/issues/36790)\n\t\t\tif (isWindows && error.code === 'EACCES') {\n\t\t\t\ttry {\n\t\t\t\t\tconst stats = await fs.promises.stat(await fs.promises.readlink(path));\n\n\t\t\t\t\treturn { stat: stats, symbolicLink: { dangling: false } };\n\t\t\t\t} catch (error) {\n\n\t\t\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t\t\t// to return it as result while setting dangling: true flag\n\t\t\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a file with support\n\t * for symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsFile(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isFile() && symbolicLink?.dangling !== true;\n\t\t} catch {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a directory with support for\n\t * symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsDirectory(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isDirectory() && symbolicLink?.dangling !== true;\n\t\t} catch {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n//#endregion\n\n//#region Write File\n\n// According to node.js docs (https://nodejs.org/docs/v14.16.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nconst writeQueues = new ResourceQueue();\n\n/**\n * Same as `fs.writeFile` but with an additional call to\n * `fs.fdatasync` after writing to ensure changes are\n * flushed to disk.\n *\n * In addition, multiple writes to the same path are queued.\n */\nfunction writeFile(path: string, data: string, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Buffer, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void> {\n\treturn writeQueues.queueFor(URI.file(path), () => {\n\t\tconst ensuredOptions = ensureWriteOptions(options);\n\n\t\treturn new Promise((resolve, reject) => doWriteFileAndFlush(path, data, ensuredOptions, error => error ? reject(error) : resolve()));\n\t}, extUriBiasedIgnorePathCase);\n}\n\ninterface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n}\n\ninterface IEnsuredWriteFileOptions extends IWriteFileOptions {\n\tmode: number;\n\tflag: string;\n}\n\nlet canFlush = true;\nexport function configureFlushOnWrite(enabled: boolean): void {\n\tcanFlush = enabled;\n}\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer | Uint8Array, options: IEnsuredWriteFileOptions, callback: (error: Error | null) => void): void {\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, options.flag, options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(fd, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\t// https://github.com/microsoft/vscode/issues/9589\n\t\t\tfs.fdatasync(fd, (syncError: Error | null) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tconfigureFlushOnWrite(false);\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\n/**\n * Same as `fs.writeFileSync` but with an additional call to\n * `fs.fdatasyncSync` after writing to ensure changes are\n * flushed to disk.\n *\n * @deprecated always prefer async variants over sync!\n */\nexport function writeFileSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\tconst ensuredOptions = ensureWriteOptions(options);\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: ensuredOptions.mode, flag: ensuredOptions.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, ensuredOptions.flag, ensuredOptions.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(fd, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd); // https://github.com/microsoft/vscode/issues/9589\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tconfigureFlushOnWrite(false);\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureWriteOptions(options?: IWriteFileOptions): IEnsuredWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666 /* default node.js mode for files */, flag: 'w' };\n\t}\n\n\treturn {\n\t\tmode: typeof options.mode === 'number' ? options.mode : 0o666 /* default node.js mode for files */,\n\t\tflag: typeof options.flag === 'string' ? options.flag : 'w'\n\t};\n}\n\n//#endregion\n\n//#region Move / Copy\n\n/**\n * A drop-in replacement for `fs.rename` that:\n * - allows to move across multiple disks\n * - attempts to retry the operation for certain error codes on Windows\n */\nasync function rename(source: string, target: string, windowsRetryTimeout: number | false = 60000): Promise<void> {\n\tif (source === target) {\n\t\treturn;  // simulate node.js behaviour here and do a no-op if paths match\n\t}\n\n\ttry {\n\t\tif (isWindows && typeof windowsRetryTimeout === 'number') {\n\t\t\t// On Windows, a rename can fail when either source or target\n\t\t\t// is locked by AV software.\n\t\t\tawait renameWithRetry(source, target, Date.now(), windowsRetryTimeout);\n\t\t} else {\n\t\t\tawait fs.promises.rename(source, target);\n\t\t}\n\t} catch (error) {\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (source.toLowerCase() !== target.toLowerCase() && error.code === 'EXDEV' || source.endsWith('.')) {\n\t\t\tawait copy(source, target, { preserveSymlinks: false /* copying to another device */ });\n\t\t\tawait rimraf(source, RimRafMode.MOVE);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function renameWithRetry(source: string, target: string, startTime: number, retryTimeout: number, attempt = 0): Promise<void> {\n\ttry {\n\t\treturn await fs.promises.rename(source, target);\n\t} catch (error) {\n\t\tif (error.code !== 'EACCES' && error.code !== 'EPERM' && error.code !== 'EBUSY') {\n\t\t\tthrow error; // only for errors we think are temporary\n\t\t}\n\n\t\tif (Date.now() - startTime >= retryTimeout) {\n\t\t\tconsole.error(`[node.js fs] rename failed after ${attempt} retries with error: ${error}`);\n\n\t\t\tthrow error; // give up after configurable timeout\n\t\t}\n\n\t\tif (attempt === 0) {\n\t\t\tlet abortRetry = false;\n\t\t\ttry {\n\t\t\t\tconst { stat } = await SymlinkSupport.stat(target);\n\t\t\t\tif (!stat.isFile()) {\n\t\t\t\t\tabortRetry = true; // if target is not a file, EPERM error may be raised and we should not attempt to retry\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Ignore\n\t\t\t}\n\n\t\t\tif (abortRetry) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// Delay with incremental backoff up to 100ms\n\t\tawait timeout(Math.min(100, attempt * 10));\n\n\t\t// Attempt again\n\t\treturn renameWithRetry(source, target, startTime, retryTimeout, attempt + 1);\n\t}\n}\n\ninterface ICopyPayload {\n\treadonly root: { source: string; target: string };\n\treadonly options: { preserveSymlinks: boolean };\n\treadonly handledSourcePaths: Set<string>;\n}\n\n/**\n * Recursively copies all of `source` to `target`.\n *\n * The options `preserveSymlinks` configures how symbolic\n * links should be handled when encountered. Set to\n * `false` to not preserve them and `true` otherwise.\n */\nasync function copy(source: string, target: string, options: { preserveSymlinks: boolean }): Promise<void> {\n\treturn doCopy(source, target, { root: { source, target }, options, handledSourcePaths: new Set<string>() });\n}\n\n// When copying a file or folder, we want to preserve the mode\n// it had and as such provide it when creating. However, modes\n// can go beyond what we expect (see link below), so we mask it.\n// (https://github.com/nodejs/node-v0.x-archive/issues/3045#issuecomment-4862588)\nconst COPY_MODE_MASK = 0o777;\n\nasync function doCopy(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Keep track of paths already copied to prevent\n\t// cycles from symbolic links to cause issues\n\tif (payload.handledSourcePaths.has(source)) {\n\t\treturn;\n\t} else {\n\t\tpayload.handledSourcePaths.add(source);\n\t}\n\n\tconst { stat, symbolicLink } = await SymlinkSupport.stat(source);\n\n\t// Symlink\n\tif (symbolicLink) {\n\n\t\t// Try to re-create the symlink unless `preserveSymlinks: false`\n\t\tif (payload.options.preserveSymlinks) {\n\t\t\ttry {\n\t\t\t\treturn await doCopySymlink(source, target, payload);\n\t\t\t} catch {\n\t\t\t\t// in any case of an error fallback to normal copy via dereferencing\n\t\t\t}\n\t\t}\n\n\t\tif (symbolicLink.dangling) {\n\t\t\treturn; // skip dangling symbolic links from here on (https://github.com/microsoft/vscode/issues/111621)\n\t\t}\n\t}\n\n\t// Folder\n\tif (stat.isDirectory()) {\n\t\treturn doCopyDirectory(source, target, stat.mode & COPY_MODE_MASK, payload);\n\t}\n\n\t// File or file-like\n\telse {\n\t\treturn doCopyFile(source, target, stat.mode & COPY_MODE_MASK);\n\t}\n}\n\nasync function doCopyDirectory(source: string, target: string, mode: number, payload: ICopyPayload): Promise<void> {\n\n\t// Create folder\n\tawait fs.promises.mkdir(target, { recursive: true, mode });\n\n\t// Copy each file recursively\n\tconst files = await readdir(source);\n\tfor (const file of files) {\n\t\tawait doCopy(join(source, file), join(target, file), payload);\n\t}\n}\n\nasync function doCopyFile(source: string, target: string, mode: number): Promise<void> {\n\n\t// Copy file\n\tawait fs.promises.copyFile(source, target);\n\n\t// restore mode (https://github.com/nodejs/node/issues/1104)\n\tawait fs.promises.chmod(target, mode);\n}\n\nasync function doCopySymlink(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Figure out link target\n\tlet linkTarget = await fs.promises.readlink(source);\n\n\t// Special case: the symlink points to a target that is\n\t// actually within the path that is being copied. In that\n\t// case we want the symlink to point to the target and\n\t// not the source\n\tif (isEqualOrParent(linkTarget, payload.root.source, !isLinux)) {\n\t\tlinkTarget = join(payload.root.target, linkTarget.substr(payload.root.source.length + 1));\n\t}\n\n\t// Create symlink\n\tawait fs.promises.symlink(linkTarget, target);\n}\n\n//#endregion\n\n//#region Path resolvers\n\n/**\n * Given an absolute, normalized, and existing file path 'realcase' returns the\n * exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original\n * path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the\n * original path.\n * In case of errors, null is returned. But you cannot use this function to verify that\n * a path exists.\n *\n * realcase does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nexport async function realcase(path: string, token?: CancellationToken): Promise<string | null> {\n\tif (isLinux) {\n\t\t// This method is unsupported on OS that have case sensitive\n\t\t// file system where the same path can exist in different forms\n\t\t// (see also https://github.com/microsoft/vscode/issues/139709)\n\t\treturn path;\n\t}\n\n\tconst dir = dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst entries = await Promises.readdir(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = await realcase(dir, token);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = await realcase(dir, token);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nasync function realpath(path: string): Promise<string> {\n\ttry {\n\t\t// DO NOT USE `fs.promises.realpath` here as it internally\n\t\t// calls `fs.native.realpath` which will result in subst\n\t\t// drives to be resolved to their target on Windows\n\t\t// https://github.com/microsoft/vscode/issues/118562\n\t\treturn await promisify(fs.realpath)(path);\n\t} catch {\n\n\t\t// We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tawait fs.promises.access(normalizedPath, fs.constants.R_OK);\n\n\t\treturn normalizedPath;\n\t}\n}\n\n/**\n * @deprecated always prefer async variants over sync!\n */\nexport function realpathSync(path: string): string {\n\ttry {\n\t\treturn fs.realpathSync(path);\n\t} catch {\n\n\t\t// We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tfs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n\n\t\treturn normalizedPath;\n\t}\n}\n\nfunction normalizePath(path: string): string {\n\treturn rtrim(normalize(path), sep);\n}\n\n//#endregion\n\n//#region Promise based fs methods\n\n/**\n * Some low level `fs` methods provided as `Promises` similar to\n * `fs.promises` but with notable differences, either implemented\n * by us or by restoring the original callback based behavior.\n *\n * At least `realpath` is implemented differently in the promise\n * based implementation compared to the callback based one. The\n * promise based implementation actually calls `fs.realpath.native`.\n * (https://github.com/microsoft/vscode/issues/118562)\n */\nexport const Promises = new class {\n\n\t//#region Implemented by node.js\n\n\tget read() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes read, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number, length: number, position: number | null) => {\n\t\t\treturn new Promise<{ bytesRead: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesRead, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget write() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes written, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number | undefined | null, length: number | undefined | null, position: number | undefined | null) => {\n\t\t\treturn new Promise<{ bytesWritten: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.write(fd, buffer, offset, length, position, (err, bytesWritten, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesWritten, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget fdatasync() { return promisify(fs.fdatasync); } // not exposed as API in 22.x yet\n\n\tget open() { return promisify(fs.open); } \t\t\t// changed to return `FileHandle` in promise API\n\tget close() { return promisify(fs.close); } \t\t// not exposed as API due to the `FileHandle` return type of `open`\n\n\tget ftruncate() { return promisify(fs.ftruncate); } // not exposed as API in 22.x yet\n\n\t//#endregion\n\n\t//#region Implemented by us\n\n\tasync exists(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait fs.promises.access(path);\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tget readdir() { return readdir; }\n\tget readDirsInDir() { return readDirsInDir; }\n\n\tget writeFile() { return writeFile; }\n\n\tget rm() { return rimraf; }\n\n\tget rename() { return rename; }\n\tget copy() { return copy; }\n\n\tget realpath() { return realpath; }\t// `fs.promises.realpath` will use `fs.realpath.native` which we do not want\n\n\t//#endregion\n};\n\n//#endregion\n"]}