{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/base/node/processes.ts","vs/base/node/processes.ts"],"names":[],"mappings":"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","file":"processes.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { Stats, promises } from 'fs';\nimport { getCaseInsensitive } from '../common/objects.js';\nimport * as path from '../common/path.js';\nimport * as Platform from '../common/platform.js';\nimport * as processCommon from '../common/process.js';\nimport { CommandOptions, ForkOptions, Source, SuccessData, TerminateResponse, TerminateResponseCode } from '../common/processes.js';\nimport * as Types from '../common/types.js';\nimport * as pfs from './pfs.js';\nimport { FileAccess } from '../common/network.js';\nimport Stream from 'stream';\nexport { Source, TerminateResponseCode, type CommandOptions, type ForkOptions, type SuccessData, type TerminateResponse };\n\nexport type ValueCallback<T> = (value: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\n\nexport function getWindowsShell(env = processCommon.env): string {\n\treturn env['comspec'] || 'cmd.exe';\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(childProcess: cp.ChildProcess): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = function (msg: any): void {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error | null) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach(entry => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nasync function fileExistsDefault(path: string): Promise<boolean> {\n\tif (await pfs.Promises.exists(path)) {\n\t\tlet statValue: Stats | undefined;\n\t\ttry {\n\t\t\tstatValue = await promises.stat(path);\n\t\t} catch (e) {\n\t\t\tif (e.message.startsWith('EACCES')) {\n\t\t\t\t// it might be symlink\n\t\t\t\tstatValue = await promises.lstat(path);\n\t\t\t}\n\t\t}\n\t\treturn statValue ? !statValue.isDirectory() : false;\n\t}\n\treturn false;\n}\n\nexport async function findExecutable(command: string, cwd?: string, paths?: string[], env: Platform.IProcessEnvironment = processCommon.env, fileExists: (path: string) => Promise<boolean> = fileExistsDefault): Promise<string | undefined> {\n\t// If we have an absolute path then we take it.\n\tif (path.isAbsolute(command)) {\n\t\treturn await fileExists(command) ? command : undefined;\n\t}\n\tif (cwd === undefined) {\n\t\tcwd = processCommon.cwd();\n\t}\n\tconst dir = path.dirname(command);\n\tif (dir !== '.') {\n\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t// to the current working directory.\n\t\tconst fullPath = path.join(cwd, command);\n\t\treturn await fileExists(fullPath) ? fullPath : undefined;\n\t}\n\tconst envPath = getCaseInsensitive(env, 'PATH');\n\tif (paths === undefined && Types.isString(envPath)) {\n\t\tpaths = envPath.split(path.delimiter);\n\t}\n\t// No PATH environment. Make path absolute to the cwd.\n\tif (paths === undefined || paths.length === 0) {\n\t\tconst fullPath = path.join(cwd, command);\n\t\treturn await fileExists(fullPath) ? fullPath : undefined;\n\t}\n\n\t// We have a simple file name. We get the path variable from the env\n\t// and try to find the executable on the path.\n\tfor (const pathEntry of paths) {\n\t\t// The path entry is absolute.\n\t\tlet fullPath: string;\n\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\tfullPath = path.join(pathEntry, command);\n\t\t} else {\n\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t}\n\t\tif (Platform.isWindows) {\n\t\t\tconst pathExt = getCaseInsensitive(env, 'PATHEXT') as string || '.COM;.EXE;.BAT;.CMD';\n\t\t\tconst pathExtsFound = pathExt.split(';').map(async ext => {\n\t\t\t\tconst withExtension = fullPath + ext;\n\t\t\t\treturn await fileExists(withExtension) ? withExtension : undefined;\n\t\t\t});\n\t\t\tfor (const foundPromise of pathExtsFound) {\n\t\t\t\tconst found = await foundPromise;\n\t\t\t\tif (found) {\n\t\t\t\t\treturn found;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (await fileExists(fullPath)) {\n\t\t\treturn fullPath;\n\t\t}\n\t}\n\tconst fullPath = path.join(cwd, command);\n\treturn await fileExists(fullPath) ? fullPath : undefined;\n}\n\n/**\n * Kills a process and all its children.\n * @param pid the process id to kill\n * @param forceful whether to forcefully kill the process (default: false). Note\n * that on Windows, terminal processes can _only_ be killed forcefully and this\n * will throw when not forceful.\n */\nexport async function killTree(pid: number, forceful = false) {\n\tlet child: cp.ChildProcessByStdio<null, Stream.Readable, Stream.Readable>;\n\tif (Platform.isWindows) {\n\t\tconst windir = process.env['WINDIR'] || 'C:\\\\Windows';\n\t\tconst taskKill = path.join(windir, 'System32', 'taskkill.exe');\n\n\t\tconst args = ['/T'];\n\t\tif (forceful) {\n\t\t\targs.push('/F');\n\t\t}\n\t\targs.push('/PID', String(pid));\n\t\tchild = cp.spawn(taskKill, args, { stdio: ['ignore', 'pipe', 'pipe'] });\n\t} else {\n\t\tconst killScript = FileAccess.asFileUri('vs/base/node/terminateProcess.sh').fsPath;\n\t\tchild = cp.spawn('/bin/sh', [killScript, String(pid), forceful ? '9' : '15'], { stdio: ['ignore', 'pipe', 'pipe'] });\n\t}\n\n\treturn new Promise<void>((resolve, reject) => {\n\t\tconst stdout: Buffer[] = [];\n\t\tchild.stdout.on('data', (data) => stdout.push(data));\n\t\tchild.stderr.on('data', (data) => stdout.push(data));\n\t\tchild.on('error', reject);\n\t\tchild.on('exit', (code) => {\n\t\t\tif (code === 0) {\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\treject(new Error(`taskkill exited with code ${code}: ${Buffer.concat(stdout).toString()}`));\n\t\t\t}\n\t\t});\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { Stats, promises } from 'fs';\nimport { getCaseInsensitive } from '../common/objects.js';\nimport * as path from '../common/path.js';\nimport * as Platform from '../common/platform.js';\nimport * as processCommon from '../common/process.js';\nimport { CommandOptions, ForkOptions, Source, SuccessData, TerminateResponse, TerminateResponseCode } from '../common/processes.js';\nimport * as Types from '../common/types.js';\nimport * as pfs from './pfs.js';\nimport { FileAccess } from '../common/network.js';\nimport Stream from 'stream';\nexport { Source, TerminateResponseCode, type CommandOptions, type ForkOptions, type SuccessData, type TerminateResponse };\n\nexport type ValueCallback<T> = (value: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\n\nexport function getWindowsShell(env = processCommon.env): string {\n\treturn env['comspec'] || 'cmd.exe';\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(childProcess: cp.ChildProcess): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = function (msg: any): void {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error | null) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach(entry => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nasync function fileExistsDefault(path: string): Promise<boolean> {\n\tif (await pfs.Promises.exists(path)) {\n\t\tlet statValue: Stats | undefined;\n\t\ttry {\n\t\t\tstatValue = await promises.stat(path);\n\t\t} catch (e) {\n\t\t\tif (e.message.startsWith('EACCES')) {\n\t\t\t\t// it might be symlink\n\t\t\t\tstatValue = await promises.lstat(path);\n\t\t\t}\n\t\t}\n\t\treturn statValue ? !statValue.isDirectory() : false;\n\t}\n\treturn false;\n}\n\nexport async function findExecutable(command: string, cwd?: string, paths?: string[], env: Platform.IProcessEnvironment = processCommon.env, fileExists: (path: string) => Promise<boolean> = fileExistsDefault): Promise<string | undefined> {\n\t// If we have an absolute path then we take it.\n\tif (path.isAbsolute(command)) {\n\t\treturn await fileExists(command) ? command : undefined;\n\t}\n\tif (cwd === undefined) {\n\t\tcwd = processCommon.cwd();\n\t}\n\tconst dir = path.dirname(command);\n\tif (dir !== '.') {\n\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t// to the current working directory.\n\t\tconst fullPath = path.join(cwd, command);\n\t\treturn await fileExists(fullPath) ? fullPath : undefined;\n\t}\n\tconst envPath = getCaseInsensitive(env, 'PATH');\n\tif (paths === undefined && Types.isString(envPath)) {\n\t\tpaths = envPath.split(path.delimiter);\n\t}\n\t// No PATH environment. Make path absolute to the cwd.\n\tif (paths === undefined || paths.length === 0) {\n\t\tconst fullPath = path.join(cwd, command);\n\t\treturn await fileExists(fullPath) ? fullPath : undefined;\n\t}\n\n\t// We have a simple file name. We get the path variable from the env\n\t// and try to find the executable on the path.\n\tfor (const pathEntry of paths) {\n\t\t// The path entry is absolute.\n\t\tlet fullPath: string;\n\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\tfullPath = path.join(pathEntry, command);\n\t\t} else {\n\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t}\n\t\tif (Platform.isWindows) {\n\t\t\tconst pathExt = getCaseInsensitive(env, 'PATHEXT') as string || '.COM;.EXE;.BAT;.CMD';\n\t\t\tconst pathExtsFound = pathExt.split(';').map(async ext => {\n\t\t\t\tconst withExtension = fullPath + ext;\n\t\t\t\treturn await fileExists(withExtension) ? withExtension : undefined;\n\t\t\t});\n\t\t\tfor (const foundPromise of pathExtsFound) {\n\t\t\t\tconst found = await foundPromise;\n\t\t\t\tif (found) {\n\t\t\t\t\treturn found;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (await fileExists(fullPath)) {\n\t\t\treturn fullPath;\n\t\t}\n\t}\n\tconst fullPath = path.join(cwd, command);\n\treturn await fileExists(fullPath) ? fullPath : undefined;\n}\n\n/**\n * Kills a process and all its children.\n * @param pid the process id to kill\n * @param forceful whether to forcefully kill the process (default: false). Note\n * that on Windows, terminal processes can _only_ be killed forcefully and this\n * will throw when not forceful.\n */\nexport async function killTree(pid: number, forceful = false) {\n\tlet child: cp.ChildProcessByStdio<null, Stream.Readable, Stream.Readable>;\n\tif (Platform.isWindows) {\n\t\tconst windir = process.env['WINDIR'] || 'C:\\\\Windows';\n\t\tconst taskKill = path.join(windir, 'System32', 'taskkill.exe');\n\n\t\tconst args = ['/T'];\n\t\tif (forceful) {\n\t\t\targs.push('/F');\n\t\t}\n\t\targs.push('/PID', String(pid));\n\t\tchild = cp.spawn(taskKill, args, { stdio: ['ignore', 'pipe', 'pipe'] });\n\t} else {\n\t\tconst killScript = FileAccess.asFileUri('vs/base/node/terminateProcess.sh').fsPath;\n\t\tchild = cp.spawn('/bin/sh', [killScript, String(pid), forceful ? '9' : '15'], { stdio: ['ignore', 'pipe', 'pipe'] });\n\t}\n\n\treturn new Promise<void>((resolve, reject) => {\n\t\tconst stdout: Buffer[] = [];\n\t\tchild.stdout.on('data', (data) => stdout.push(data));\n\t\tchild.stderr.on('data', (data) => stdout.push(data));\n\t\tchild.on('error', reject);\n\t\tchild.on('exit', (code) => {\n\t\t\tif (code === 0) {\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\treject(new Error(`taskkill exited with code ${code}: ${Buffer.concat(stdout).toString()}`));\n\t\t\t}\n\t\t});\n\t});\n}\n"]}