{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/request/common/requestIpc.ts","vs/platform/request/common/requestIpc.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,cAAc,EAAE,cAAc,EAAY,MAAM,gCAAgC,CAAC;AAC1F,OAAO,EAAE,iBAAiB,EAAE,MAAM,sCAAsC,CAAC;AAczE,MAAM,OAAO,cAAc;IAE1B,YAA6B,OAAwB;QAAxB,YAAO,GAAP,OAAO,CAAiB;IAAI,CAAC;IAE1D,MAAM,CAAC,OAAY,EAAE,KAAa;QACjC,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC;IACnC,CAAC;IAED,IAAI,CAAC,OAAY,EAAE,OAAe,EAAE,IAAU,EAAE,QAA2B,iBAAiB,CAAC,IAAI;QAChG,QAAQ,OAAO,EAAE,CAAC;YACjB,KAAK,SAAS,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;iBACzD,IAAI,CAAC,KAAK,EAAE,EAAE,GAAG,EAAE,MAAM,EAAE,EAAE,EAAE;gBAC/B,MAAM,MAAM,GAAG,MAAM,cAAc,CAAC,MAAM,CAAC,CAAC;gBAC5C,OAAwB,CAAC,EAAE,UAAU,EAAE,GAAG,CAAC,UAAU,EAAE,OAAO,EAAE,GAAG,CAAC,OAAO,EAAE,EAAE,MAAM,CAAC,CAAC;YACxF,CAAC,CAAC,CAAC;YACJ,KAAK,cAAc,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/D,KAAK,qBAAqB,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YAC7E,KAAK,6BAA6B,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YAC7F,KAAK,kBAAkB,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,gBAAgB,EAAE,CAAC;QACjE,CAAC;QACD,MAAM,IAAI,KAAK,CAAC,cAAc,CAAC,CAAC;IACjC,CAAC;CACD;AAED,MAAM,OAAO,oBAAoB;IAIhC,YAA6B,OAAiB;QAAjB,YAAO,GAAP,OAAO,CAAU;IAAI,CAAC;IAEnD,KAAK,CAAC,OAAO,CAAC,OAAwB,EAAE,KAAwB;QAC/D,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,CAAkB,SAAS,EAAE,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,CAAC;QAC5F,OAAO,EAAE,GAAG,EAAE,MAAM,EAAE,cAAc,CAAC,MAAM,CAAC,EAAE,CAAC;IAChD,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,GAAW;QAC7B,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAqB,cAAc,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;IACrE,CAAC;IAED,KAAK,CAAC,mBAAmB,CAAC,QAAkB;QAC3C,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAqD,qBAAqB,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;IACjH,CAAC;IAED,KAAK,CAAC,2BAA2B,CAAC,GAAW;QAC5C,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAqB,6BAA6B,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;IACpF,CAAC;IAED,KAAK,CAAC,gBAAgB;QACrB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAW,kBAAkB,CAAC,CAAC;IACxD,CAAC;CACD","file":"requestIpc.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { bufferToStream, streamToBuffer, VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Event } from '../../../base/common/event.js';\nimport { IChannel, IServerChannel } from '../../../base/parts/ipc/common/ipc.js';\nimport { IHeaders, IRequestContext, IRequestOptions } from '../../../base/parts/request/common/request.js';\nimport { AuthInfo, Credentials, IRequestService } from './request.js';\n\ntype RequestResponse = [\n\t{\n\t\theaders: IHeaders;\n\t\tstatusCode?: number;\n\t},\n\tVSBuffer\n];\n\nexport class RequestChannel implements IServerChannel {\n\n\tconstructor(private readonly service: IRequestService) { }\n\n\tlisten(context: any, event: string): Event<any> {\n\t\tthrow new Error('Invalid listen');\n\t}\n\n\tcall(context: any, command: string, args?: any, token: CancellationToken = CancellationToken.None): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'request': return this.service.request(args[0], token)\n\t\t\t\t.then(async ({ res, stream }) => {\n\t\t\t\t\tconst buffer = await streamToBuffer(stream);\n\t\t\t\t\treturn <RequestResponse>[{ statusCode: res.statusCode, headers: res.headers }, buffer];\n\t\t\t\t});\n\t\t\tcase 'resolveProxy': return this.service.resolveProxy(args[0]);\n\t\t\tcase 'lookupAuthorization': return this.service.lookupAuthorization(args[0]);\n\t\t\tcase 'lookupKerberosAuthorization': return this.service.lookupKerberosAuthorization(args[0]);\n\t\t\tcase 'loadCertificates': return this.service.loadCertificates();\n\t\t}\n\t\tthrow new Error('Invalid call');\n\t}\n}\n\nexport class RequestChannelClient implements IRequestService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(private readonly channel: IChannel) { }\n\n\tasync request(options: IRequestOptions, token: CancellationToken): Promise<IRequestContext> {\n\t\tconst [res, buffer] = await this.channel.call<RequestResponse>('request', [options], token);\n\t\treturn { res, stream: bufferToStream(buffer) };\n\t}\n\n\tasync resolveProxy(url: string): Promise<string | undefined> {\n\t\treturn this.channel.call<string | undefined>('resolveProxy', [url]);\n\t}\n\n\tasync lookupAuthorization(authInfo: AuthInfo): Promise<Credentials | undefined> {\n\t\treturn this.channel.call<{ username: string; password: string } | undefined>('lookupAuthorization', [authInfo]);\n\t}\n\n\tasync lookupKerberosAuthorization(url: string): Promise<string | undefined> {\n\t\treturn this.channel.call<string | undefined>('lookupKerberosAuthorization', [url]);\n\t}\n\n\tasync loadCertificates(): Promise<string[]> {\n\t\treturn this.channel.call<string[]>('loadCertificates');\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { bufferToStream, streamToBuffer, VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Event } from '../../../base/common/event.js';\nimport { IChannel, IServerChannel } from '../../../base/parts/ipc/common/ipc.js';\nimport { IHeaders, IRequestContext, IRequestOptions } from '../../../base/parts/request/common/request.js';\nimport { AuthInfo, Credentials, IRequestService } from './request.js';\n\ntype RequestResponse = [\n\t{\n\t\theaders: IHeaders;\n\t\tstatusCode?: number;\n\t},\n\tVSBuffer\n];\n\nexport class RequestChannel implements IServerChannel {\n\n\tconstructor(private readonly service: IRequestService) { }\n\n\tlisten(context: any, event: string): Event<any> {\n\t\tthrow new Error('Invalid listen');\n\t}\n\n\tcall(context: any, command: string, args?: any, token: CancellationToken = CancellationToken.None): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'request': return this.service.request(args[0], token)\n\t\t\t\t.then(async ({ res, stream }) => {\n\t\t\t\t\tconst buffer = await streamToBuffer(stream);\n\t\t\t\t\treturn <RequestResponse>[{ statusCode: res.statusCode, headers: res.headers }, buffer];\n\t\t\t\t});\n\t\t\tcase 'resolveProxy': return this.service.resolveProxy(args[0]);\n\t\t\tcase 'lookupAuthorization': return this.service.lookupAuthorization(args[0]);\n\t\t\tcase 'lookupKerberosAuthorization': return this.service.lookupKerberosAuthorization(args[0]);\n\t\t\tcase 'loadCertificates': return this.service.loadCertificates();\n\t\t}\n\t\tthrow new Error('Invalid call');\n\t}\n}\n\nexport class RequestChannelClient implements IRequestService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(private readonly channel: IChannel) { }\n\n\tasync request(options: IRequestOptions, token: CancellationToken): Promise<IRequestContext> {\n\t\tconst [res, buffer] = await this.channel.call<RequestResponse>('request', [options], token);\n\t\treturn { res, stream: bufferToStream(buffer) };\n\t}\n\n\tasync resolveProxy(url: string): Promise<string | undefined> {\n\t\treturn this.channel.call<string | undefined>('resolveProxy', [url]);\n\t}\n\n\tasync lookupAuthorization(authInfo: AuthInfo): Promise<Credentials | undefined> {\n\t\treturn this.channel.call<{ username: string; password: string } | undefined>('lookupAuthorization', [authInfo]);\n\t}\n\n\tasync lookupKerberosAuthorization(url: string): Promise<string | undefined> {\n\t\treturn this.channel.call<string | undefined>('lookupKerberosAuthorization', [url]);\n\t}\n\n\tasync loadCertificates(): Promise<string[]> {\n\t\treturn this.channel.call<string[]>('loadCertificates');\n\t}\n}\n"]}