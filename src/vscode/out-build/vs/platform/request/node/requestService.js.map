{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/request/node/requestService.ts","vs/platform/request/node/requestService.ts"],"names":[],"mappings":"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","file":"requestService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type * as http from 'http';\nimport type * as https from 'https';\nimport { parse as parseUrl } from 'url';\nimport { Promises } from '../../../base/common/async.js';\nimport { streamToBufferReadableStream } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { CancellationError, getErrorMessage } from '../../../base/common/errors.js';\nimport * as streams from '../../../base/common/stream.js';\nimport { isBoolean, isNumber } from '../../../base/common/types.js';\nimport { IRequestContext, IRequestOptions } from '../../../base/parts/request/common/request.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { INativeEnvironmentService } from '../../environment/common/environment.js';\nimport { getResolvedShellEnv } from '../../shell/node/shellEnv.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { AbstractRequestService, AuthInfo, Credentials, IRequestService, systemCertificatesNodeDefault } from '../common/request.js';\nimport { Agent, getProxyAgent } from './proxy.js';\nimport { createGunzip } from 'zlib';\n\nexport interface IRawRequestFunction {\n\t(options: http.RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n}\n\nexport interface NodeRequestOptions extends IRequestOptions {\n\tagent?: Agent;\n\tstrictSSL?: boolean;\n\tisChromiumNetwork?: boolean;\n\tgetRawRequest?(options: IRequestOptions): IRawRequestFunction;\n}\n\n/**\n * This service exposes the `request` API, while using the global\n * or configured proxy settings.\n */\nexport class RequestService extends AbstractRequestService implements IRequestService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate proxyUrl?: string;\n\tprivate strictSSL: boolean | undefined;\n\tprivate authorization?: string;\n\tprivate shellEnvErrorLogged?: boolean;\n\n\tconstructor(\n\t\tprivate readonly machine: 'local' | 'remote',\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@INativeEnvironmentService private readonly environmentService: INativeEnvironmentService,\n\t\t@ILogService logService: ILogService,\n\t) {\n\t\tsuper(logService);\n\t\tthis.configure();\n\t\tthis._register(configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration('http')) {\n\t\t\t\tthis.configure();\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate configure() {\n\t\tthis.proxyUrl = this.getConfigValue<string>('http.proxy');\n\t\tthis.strictSSL = !!this.getConfigValue<boolean>('http.proxyStrictSSL');\n\t\tthis.authorization = this.getConfigValue<string>('http.proxyAuthorization');\n\t}\n\n\tasync request(options: NodeRequestOptions, token: CancellationToken): Promise<IRequestContext> {\n\t\tconst { proxyUrl, strictSSL } = this;\n\n\t\tlet shellEnv: typeof process.env | undefined = undefined;\n\t\ttry {\n\t\t\tshellEnv = await getResolvedShellEnv(this.configurationService, this.logService, this.environmentService.args, process.env);\n\t\t} catch (error) {\n\t\t\tif (!this.shellEnvErrorLogged) {\n\t\t\t\tthis.shellEnvErrorLogged = true;\n\t\t\t\tthis.logService.error(`resolving shell environment failed`, getErrorMessage(error));\n\t\t\t}\n\t\t}\n\n\t\tconst env = {\n\t\t\t...process.env,\n\t\t\t...shellEnv\n\t\t};\n\t\tconst agent = options.agent ? options.agent : await getProxyAgent(options.url || '', env, { proxyUrl, strictSSL });\n\n\t\toptions.agent = agent;\n\t\toptions.strictSSL = strictSSL;\n\n\t\tif (this.authorization) {\n\t\t\toptions.headers = {\n\t\t\t\t...(options.headers || {}),\n\t\t\t\t'Proxy-Authorization': this.authorization\n\t\t\t};\n\t\t}\n\n\t\treturn this.logAndRequest(options, () => nodeRequest(options, token));\n\t}\n\n\tasync resolveProxy(url: string): Promise<string | undefined> {\n\t\treturn undefined; // currently not implemented in node\n\t}\n\n\tasync lookupAuthorization(authInfo: AuthInfo): Promise<Credentials | undefined> {\n\t\treturn undefined; // currently not implemented in node\n\t}\n\n\tasync lookupKerberosAuthorization(urlStr: string): Promise<string | undefined> {\n\t\ttry {\n\t\t\tconst spnConfig = this.getConfigValue<string>('http.proxyKerberosServicePrincipal');\n\t\t\tconst response = await lookupKerberosAuthorization(urlStr, spnConfig, this.logService, 'RequestService#lookupKerberosAuthorization');\n\t\t\treturn 'Negotiate ' + response;\n\t\t} catch (err) {\n\t\t\tthis.logService.debug('RequestService#lookupKerberosAuthorization Kerberos authentication failed', err);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync loadCertificates(): Promise<string[]> {\n\t\tconst proxyAgent = await import('@vscode/proxy-agent');\n\t\treturn proxyAgent.loadSystemCertificates({\n\t\t\tloadSystemCertificatesFromNode: () => this.getConfigValue<boolean>('http.systemCertificatesNode', systemCertificatesNodeDefault),\n\t\t\tlog: this.logService,\n\t\t});\n\t}\n\n\tprivate getConfigValue<T>(key: string, fallback?: T): T | undefined {\n\t\tif (this.machine === 'remote') {\n\t\t\treturn this.configurationService.getValue<T>(key);\n\t\t}\n\t\tconst values = this.configurationService.inspect<T>(key);\n\t\treturn values.userLocalValue ?? values.defaultValue ?? fallback;\n\t}\n}\n\nexport async function lookupKerberosAuthorization(urlStr: string, spnConfig: string | undefined, logService: ILogService, logPrefix: string) {\n\tconst importKerberos = await import('kerberos');\n\tconst kerberos = importKerberos.default || importKerberos;\n\tconst url = new URL(urlStr);\n\tconst spn = spnConfig\n\t\t|| (process.platform === 'win32' ? `HTTP/${url.hostname}` : `HTTP@${url.hostname}`);\n\tlogService.debug(`${logPrefix} Kerberos authentication lookup`, `proxyURL:${url}`, `spn:${spn}`);\n\tconst client = await kerberos.initializeClient(spn);\n\treturn client.step('');\n}\n\nasync function getNodeRequest(options: IRequestOptions): Promise<IRawRequestFunction> {\n\tconst endpoint = parseUrl(options.url!);\n\tconst module = endpoint.protocol === 'https:' ? await import('https') : await import('http');\n\n\treturn module.request;\n}\n\nexport async function nodeRequest(options: NodeRequestOptions, token: CancellationToken): Promise<IRequestContext> {\n\treturn Promises.withAsyncBody<IRequestContext>(async (resolve, reject) => {\n\t\tconst endpoint = parseUrl(options.url!);\n\t\tconst rawRequest = options.getRawRequest\n\t\t\t? options.getRawRequest(options)\n\t\t\t: await getNodeRequest(options);\n\n\t\tconst opts: https.RequestOptions & { cache?: 'default' | 'no-store' | 'reload' | 'no-cache' | 'force-cache' | 'only-if-cached' } = {\n\t\t\thostname: endpoint.hostname,\n\t\t\tport: endpoint.port ? parseInt(endpoint.port) : (endpoint.protocol === 'https:' ? 443 : 80),\n\t\t\tprotocol: endpoint.protocol,\n\t\t\tpath: endpoint.path,\n\t\t\tmethod: options.type || 'GET',\n\t\t\theaders: options.headers,\n\t\t\tagent: options.agent,\n\t\t\trejectUnauthorized: isBoolean(options.strictSSL) ? options.strictSSL : true\n\t\t};\n\n\t\tif (options.user && options.password) {\n\t\t\topts.auth = options.user + ':' + options.password;\n\t\t}\n\n\t\tif (options.disableCache) {\n\t\t\topts.cache = 'no-store';\n\t\t}\n\n\t\tconst req = rawRequest(opts, (res: http.IncomingMessage) => {\n\t\t\tconst followRedirects: number = isNumber(options.followRedirects) ? options.followRedirects : 3;\n\t\t\tif (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && followRedirects > 0 && res.headers['location']) {\n\t\t\t\tnodeRequest({\n\t\t\t\t\t...options,\n\t\t\t\t\turl: res.headers['location'],\n\t\t\t\t\tfollowRedirects: followRedirects - 1\n\t\t\t\t}, token).then(resolve, reject);\n\t\t\t} else {\n\t\t\t\tlet stream: streams.ReadableStreamEvents<Uint8Array> = res;\n\n\t\t\t\t// Responses from Electron net module should be treated as response\n\t\t\t\t// from browser, which will apply gzip filter and decompress the response\n\t\t\t\t// using zlib before passing the result to us. Following step can be bypassed\n\t\t\t\t// in this case and proceed further.\n\t\t\t\t// Refs https://source.chromium.org/chromium/chromium/src/+/main:net/url_request/url_request_http_job.cc;l=1266-1318\n\t\t\t\tif (!options.isChromiumNetwork && res.headers['content-encoding'] === 'gzip') {\n\t\t\t\t\tstream = res.pipe(createGunzip());\n\t\t\t\t}\n\n\t\t\t\tresolve({ res, stream: streamToBufferReadableStream(stream) } satisfies IRequestContext);\n\t\t\t}\n\t\t});\n\n\t\treq.on('error', reject);\n\n\t\t// Handle timeout\n\t\tif (options.timeout) {\n\t\t\t// Chromium network requests do not support the `timeout` option\n\t\t\tif (options.isChromiumNetwork) {\n\t\t\t\t// Use Node's setTimeout for Chromium network requests\n\t\t\t\tconst timeout = setTimeout(() => {\n\t\t\t\t\treq.abort();\n\t\t\t\t\treject(new Error(`Request timeout after ${options.timeout}ms`));\n\t\t\t\t}, options.timeout);\n\n\t\t\t\t// Clear timeout when request completes\n\t\t\t\treq.on('response', () => clearTimeout(timeout));\n\t\t\t\treq.on('error', () => clearTimeout(timeout));\n\t\t\t\treq.on('abort', () => clearTimeout(timeout));\n\t\t\t} else {\n\t\t\t\treq.setTimeout(options.timeout);\n\t\t\t}\n\t\t}\n\n\t\t// Chromium will abort the request if forbidden headers are set.\n\t\t// Ref https://source.chromium.org/chromium/chromium/src/+/main:services/network/public/cpp/header_util.cc;l=14-48;\n\t\t// for additional context.\n\t\tif (options.isChromiumNetwork) {\n\t\t\treq.removeHeader('Content-Length');\n\t\t}\n\n\t\tif (options.data) {\n\t\t\tif (typeof options.data === 'string') {\n\t\t\t\treq.write(options.data);\n\t\t\t}\n\t\t}\n\n\t\treq.end();\n\n\t\ttoken.onCancellationRequested(() => {\n\t\t\treq.abort();\n\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type * as http from 'http';\nimport type * as https from 'https';\nimport { parse as parseUrl } from 'url';\nimport { Promises } from '../../../base/common/async.js';\nimport { streamToBufferReadableStream } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { CancellationError, getErrorMessage } from '../../../base/common/errors.js';\nimport * as streams from '../../../base/common/stream.js';\nimport { isBoolean, isNumber } from '../../../base/common/types.js';\nimport { IRequestContext, IRequestOptions } from '../../../base/parts/request/common/request.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { INativeEnvironmentService } from '../../environment/common/environment.js';\nimport { getResolvedShellEnv } from '../../shell/node/shellEnv.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { AbstractRequestService, AuthInfo, Credentials, IRequestService, systemCertificatesNodeDefault } from '../common/request.js';\nimport { Agent, getProxyAgent } from './proxy.js';\nimport { createGunzip } from 'zlib';\n\nexport interface IRawRequestFunction {\n\t(options: http.RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n}\n\nexport interface NodeRequestOptions extends IRequestOptions {\n\tagent?: Agent;\n\tstrictSSL?: boolean;\n\tisChromiumNetwork?: boolean;\n\tgetRawRequest?(options: IRequestOptions): IRawRequestFunction;\n}\n\n/**\n * This service exposes the `request` API, while using the global\n * or configured proxy settings.\n */\nexport class RequestService extends AbstractRequestService implements IRequestService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate proxyUrl?: string;\n\tprivate strictSSL: boolean | undefined;\n\tprivate authorization?: string;\n\tprivate shellEnvErrorLogged?: boolean;\n\n\tconstructor(\n\t\tprivate readonly machine: 'local' | 'remote',\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@INativeEnvironmentService private readonly environmentService: INativeEnvironmentService,\n\t\t@ILogService logService: ILogService,\n\t) {\n\t\tsuper(logService);\n\t\tthis.configure();\n\t\tthis._register(configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration('http')) {\n\t\t\t\tthis.configure();\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate configure() {\n\t\tthis.proxyUrl = this.getConfigValue<string>('http.proxy');\n\t\tthis.strictSSL = !!this.getConfigValue<boolean>('http.proxyStrictSSL');\n\t\tthis.authorization = this.getConfigValue<string>('http.proxyAuthorization');\n\t}\n\n\tasync request(options: NodeRequestOptions, token: CancellationToken): Promise<IRequestContext> {\n\t\tconst { proxyUrl, strictSSL } = this;\n\n\t\tlet shellEnv: typeof process.env | undefined = undefined;\n\t\ttry {\n\t\t\tshellEnv = await getResolvedShellEnv(this.configurationService, this.logService, this.environmentService.args, process.env);\n\t\t} catch (error) {\n\t\t\tif (!this.shellEnvErrorLogged) {\n\t\t\t\tthis.shellEnvErrorLogged = true;\n\t\t\t\tthis.logService.error(`resolving shell environment failed`, getErrorMessage(error));\n\t\t\t}\n\t\t}\n\n\t\tconst env = {\n\t\t\t...process.env,\n\t\t\t...shellEnv\n\t\t};\n\t\tconst agent = options.agent ? options.agent : await getProxyAgent(options.url || '', env, { proxyUrl, strictSSL });\n\n\t\toptions.agent = agent;\n\t\toptions.strictSSL = strictSSL;\n\n\t\tif (this.authorization) {\n\t\t\toptions.headers = {\n\t\t\t\t...(options.headers || {}),\n\t\t\t\t'Proxy-Authorization': this.authorization\n\t\t\t};\n\t\t}\n\n\t\treturn this.logAndRequest(options, () => nodeRequest(options, token));\n\t}\n\n\tasync resolveProxy(url: string): Promise<string | undefined> {\n\t\treturn undefined; // currently not implemented in node\n\t}\n\n\tasync lookupAuthorization(authInfo: AuthInfo): Promise<Credentials | undefined> {\n\t\treturn undefined; // currently not implemented in node\n\t}\n\n\tasync lookupKerberosAuthorization(urlStr: string): Promise<string | undefined> {\n\t\ttry {\n\t\t\tconst spnConfig = this.getConfigValue<string>('http.proxyKerberosServicePrincipal');\n\t\t\tconst response = await lookupKerberosAuthorization(urlStr, spnConfig, this.logService, 'RequestService#lookupKerberosAuthorization');\n\t\t\treturn 'Negotiate ' + response;\n\t\t} catch (err) {\n\t\t\tthis.logService.debug('RequestService#lookupKerberosAuthorization Kerberos authentication failed', err);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync loadCertificates(): Promise<string[]> {\n\t\tconst proxyAgent = await import('@vscode/proxy-agent');\n\t\treturn proxyAgent.loadSystemCertificates({\n\t\t\tloadSystemCertificatesFromNode: () => this.getConfigValue<boolean>('http.systemCertificatesNode', systemCertificatesNodeDefault),\n\t\t\tlog: this.logService,\n\t\t});\n\t}\n\n\tprivate getConfigValue<T>(key: string, fallback?: T): T | undefined {\n\t\tif (this.machine === 'remote') {\n\t\t\treturn this.configurationService.getValue<T>(key);\n\t\t}\n\t\tconst values = this.configurationService.inspect<T>(key);\n\t\treturn values.userLocalValue ?? values.defaultValue ?? fallback;\n\t}\n}\n\nexport async function lookupKerberosAuthorization(urlStr: string, spnConfig: string | undefined, logService: ILogService, logPrefix: string) {\n\tconst importKerberos = await import('kerberos');\n\tconst kerberos = importKerberos.default || importKerberos;\n\tconst url = new URL(urlStr);\n\tconst spn = spnConfig\n\t\t|| (process.platform === 'win32' ? `HTTP/${url.hostname}` : `HTTP@${url.hostname}`);\n\tlogService.debug(`${logPrefix} Kerberos authentication lookup`, `proxyURL:${url}`, `spn:${spn}`);\n\tconst client = await kerberos.initializeClient(spn);\n\treturn client.step('');\n}\n\nasync function getNodeRequest(options: IRequestOptions): Promise<IRawRequestFunction> {\n\tconst endpoint = parseUrl(options.url!);\n\tconst module = endpoint.protocol === 'https:' ? await import('https') : await import('http');\n\n\treturn module.request;\n}\n\nexport async function nodeRequest(options: NodeRequestOptions, token: CancellationToken): Promise<IRequestContext> {\n\treturn Promises.withAsyncBody<IRequestContext>(async (resolve, reject) => {\n\t\tconst endpoint = parseUrl(options.url!);\n\t\tconst rawRequest = options.getRawRequest\n\t\t\t? options.getRawRequest(options)\n\t\t\t: await getNodeRequest(options);\n\n\t\tconst opts: https.RequestOptions & { cache?: 'default' | 'no-store' | 'reload' | 'no-cache' | 'force-cache' | 'only-if-cached' } = {\n\t\t\thostname: endpoint.hostname,\n\t\t\tport: endpoint.port ? parseInt(endpoint.port) : (endpoint.protocol === 'https:' ? 443 : 80),\n\t\t\tprotocol: endpoint.protocol,\n\t\t\tpath: endpoint.path,\n\t\t\tmethod: options.type || 'GET',\n\t\t\theaders: options.headers,\n\t\t\tagent: options.agent,\n\t\t\trejectUnauthorized: isBoolean(options.strictSSL) ? options.strictSSL : true\n\t\t};\n\n\t\tif (options.user && options.password) {\n\t\t\topts.auth = options.user + ':' + options.password;\n\t\t}\n\n\t\tif (options.disableCache) {\n\t\t\topts.cache = 'no-store';\n\t\t}\n\n\t\tconst req = rawRequest(opts, (res: http.IncomingMessage) => {\n\t\t\tconst followRedirects: number = isNumber(options.followRedirects) ? options.followRedirects : 3;\n\t\t\tif (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && followRedirects > 0 && res.headers['location']) {\n\t\t\t\tnodeRequest({\n\t\t\t\t\t...options,\n\t\t\t\t\turl: res.headers['location'],\n\t\t\t\t\tfollowRedirects: followRedirects - 1\n\t\t\t\t}, token).then(resolve, reject);\n\t\t\t} else {\n\t\t\t\tlet stream: streams.ReadableStreamEvents<Uint8Array> = res;\n\n\t\t\t\t// Responses from Electron net module should be treated as response\n\t\t\t\t// from browser, which will apply gzip filter and decompress the response\n\t\t\t\t// using zlib before passing the result to us. Following step can be bypassed\n\t\t\t\t// in this case and proceed further.\n\t\t\t\t// Refs https://source.chromium.org/chromium/chromium/src/+/main:net/url_request/url_request_http_job.cc;l=1266-1318\n\t\t\t\tif (!options.isChromiumNetwork && res.headers['content-encoding'] === 'gzip') {\n\t\t\t\t\tstream = res.pipe(createGunzip());\n\t\t\t\t}\n\n\t\t\t\tresolve({ res, stream: streamToBufferReadableStream(stream) } satisfies IRequestContext);\n\t\t\t}\n\t\t});\n\n\t\treq.on('error', reject);\n\n\t\t// Handle timeout\n\t\tif (options.timeout) {\n\t\t\t// Chromium network requests do not support the `timeout` option\n\t\t\tif (options.isChromiumNetwork) {\n\t\t\t\t// Use Node's setTimeout for Chromium network requests\n\t\t\t\tconst timeout = setTimeout(() => {\n\t\t\t\t\treq.abort();\n\t\t\t\t\treject(new Error(`Request timeout after ${options.timeout}ms`));\n\t\t\t\t}, options.timeout);\n\n\t\t\t\t// Clear timeout when request completes\n\t\t\t\treq.on('response', () => clearTimeout(timeout));\n\t\t\t\treq.on('error', () => clearTimeout(timeout));\n\t\t\t\treq.on('abort', () => clearTimeout(timeout));\n\t\t\t} else {\n\t\t\t\treq.setTimeout(options.timeout);\n\t\t\t}\n\t\t}\n\n\t\t// Chromium will abort the request if forbidden headers are set.\n\t\t// Ref https://source.chromium.org/chromium/chromium/src/+/main:services/network/public/cpp/header_util.cc;l=14-48;\n\t\t// for additional context.\n\t\tif (options.isChromiumNetwork) {\n\t\t\treq.removeHeader('Content-Length');\n\t\t}\n\n\t\tif (options.data) {\n\t\t\tif (typeof options.data === 'string') {\n\t\t\t\treq.write(options.data);\n\t\t\t}\n\t\t}\n\n\t\treq.end();\n\n\t\ttoken.onCancellationRequested(() => {\n\t\t\treq.abort();\n\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n"]}