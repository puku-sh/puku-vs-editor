{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/backup/test/electron-main/backupMainService.test.ts","vs/platform/backup/test/electron-main/backupMainService.test.ts"],"names":[],"mappings":"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","file":"backupMainService.test.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { createHash } from 'crypto';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport { Schemas } from '../../../../base/common/network.js';\nimport * as path from '../../../../base/common/path.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Promises } from '../../../../base/node/pfs.js';\nimport { flakySuite, getRandomTestPath } from '../../../../base/test/node/testUtils.js';\nimport { BackupMainService } from '../../electron-main/backupMainService.js';\nimport { ISerializedBackupWorkspaces, ISerializedWorkspaceBackupInfo } from '../../node/backup.js';\nimport { TestConfigurationService } from '../../../configuration/test/common/testConfigurationService.js';\nimport { EnvironmentMainService } from '../../../environment/electron-main/environmentMainService.js';\nimport { OPTIONS, parseArgs } from '../../../environment/node/argv.js';\nimport { HotExitConfiguration } from '../../../files/common/files.js';\nimport { ConsoleMainLogger } from '../../../log/common/log.js';\nimport product from '../../../product/common/product.js';\nimport { IFolderBackupInfo, isFolderBackupInfo, IWorkspaceBackupInfo } from '../../common/backup.js';\nimport { IWorkspaceIdentifier } from '../../../workspace/common/workspace.js';\nimport { InMemoryTestStateMainService } from '../../../test/electron-main/workbenchTestServices.js';\nimport { LogService } from '../../../log/common/logService.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../base/test/common/utils.js';\n\nflakySuite('BackupMainService', () => {\n\n\tfunction assertEqualFolderInfos(actual: IFolderBackupInfo[], expected: IFolderBackupInfo[]) {\n\t\tconst withUriAsString = (f: IFolderBackupInfo) => ({ folderUri: f.folderUri.toString(), remoteAuthority: f.remoteAuthority });\n\t\tassert.deepStrictEqual(actual.map(withUriAsString), expected.map(withUriAsString));\n\t}\n\n\tfunction toWorkspace(path: string): IWorkspaceIdentifier {\n\t\treturn {\n\t\t\tid: createHash('md5').update(sanitizePath(path)).digest('hex'), // CodeQL [SM04514] Using MD5 to convert a file path to a fixed length\n\t\t\tconfigPath: URI.file(path)\n\t\t};\n\t}\n\n\tfunction toWorkspaceBackupInfo(path: string, remoteAuthority?: string): IWorkspaceBackupInfo {\n\t\treturn {\n\t\t\tworkspace: {\n\t\t\t\tid: createHash('md5').update(sanitizePath(path)).digest('hex'), // CodeQL [SM04514] Using MD5 to convert a file path to a fixed length\n\t\t\t\tconfigPath: URI.file(path)\n\t\t\t},\n\t\t\tremoteAuthority\n\t\t};\n\t}\n\n\tfunction toFolderBackupInfo(uri: URI, remoteAuthority?: string): IFolderBackupInfo {\n\t\treturn { folderUri: uri, remoteAuthority };\n\t}\n\n\tfunction toSerializedWorkspace(ws: IWorkspaceIdentifier): ISerializedWorkspaceBackupInfo {\n\t\treturn {\n\t\t\tid: ws.id,\n\t\t\tconfigURIPath: ws.configPath.toString()\n\t\t};\n\t}\n\n\tfunction ensureFolderExists(uri: URI): Promise<void> {\n\t\tif (!fs.existsSync(uri.fsPath)) {\n\t\t\tfs.mkdirSync(uri.fsPath);\n\t\t}\n\n\t\tconst backupFolder = service.toBackupPath(uri);\n\t\treturn createBackupFolder(backupFolder);\n\t}\n\n\tasync function ensureWorkspaceExists(workspace: IWorkspaceIdentifier): Promise<IWorkspaceIdentifier> {\n\t\tif (!fs.existsSync(workspace.configPath.fsPath)) {\n\t\t\tawait Promises.writeFile(workspace.configPath.fsPath, 'Hello');\n\t\t}\n\n\t\tconst backupFolder = service.toBackupPath(workspace.id);\n\t\tawait createBackupFolder(backupFolder);\n\n\t\treturn workspace;\n\t}\n\n\tasync function createBackupFolder(backupFolder: string): Promise<void> {\n\t\tif (!fs.existsSync(backupFolder)) {\n\t\t\tfs.mkdirSync(backupFolder);\n\t\t\tfs.mkdirSync(path.join(backupFolder, Schemas.file));\n\t\t\tawait Promises.writeFile(path.join(backupFolder, Schemas.file, 'foo.txt'), 'Hello');\n\t\t}\n\t}\n\n\tfunction readWorkspacesMetadata(): ISerializedBackupWorkspaces {\n\t\treturn stateMainService.getItem('backupWorkspaces') as ISerializedBackupWorkspaces;\n\t}\n\n\tfunction writeWorkspacesMetadata(data: string): void {\n\t\tif (!data) {\n\t\t\tstateMainService.removeItem('backupWorkspaces');\n\t\t} else {\n\t\t\tstateMainService.setItem('backupWorkspaces', JSON.parse(data));\n\t\t}\n\t}\n\n\tfunction sanitizePath(p: string): string {\n\t\treturn platform.isLinux ? p : p.toLowerCase();\n\t}\n\n\tconst fooFile = URI.file(platform.isWindows ? 'C:\\\\foo' : '/foo');\n\tconst barFile = URI.file(platform.isWindows ? 'C:\\\\bar' : '/bar');\n\n\tlet service: BackupMainService & {\n\t\ttoBackupPath(arg: URI | string): string;\n\t\ttestGetFolderHash(folder: IFolderBackupInfo): string;\n\t\ttestGetWorkspaceBackups(): IWorkspaceBackupInfo[];\n\t\ttestGetFolderBackups(): IFolderBackupInfo[];\n\t};\n\tlet configService: TestConfigurationService;\n\tlet stateMainService: InMemoryTestStateMainService;\n\n\tlet environmentService: EnvironmentMainService;\n\tlet testDir: string;\n\tlet backupHome: string;\n\tlet existingTestFolder1: URI;\n\n\tsetup(async () => {\n\t\ttestDir = getRandomTestPath(os.tmpdir(), 'vsctests', 'backupmainservice');\n\t\tbackupHome = path.join(testDir, 'Backups');\n\t\texistingTestFolder1 = URI.file(path.join(testDir, 'folder1'));\n\n\t\tenvironmentService = new EnvironmentMainService(parseArgs(process.argv, OPTIONS), { _serviceBrand: undefined, ...product });\n\n\t\tawait fs.promises.mkdir(backupHome, { recursive: true });\n\n\t\tconfigService = new TestConfigurationService();\n\t\tstateMainService = new InMemoryTestStateMainService();\n\n\t\tservice = new class TestBackupMainService extends BackupMainService {\n\t\t\tconstructor() {\n\t\t\t\tsuper(environmentService, configService, new LogService(new ConsoleMainLogger()), stateMainService);\n\n\t\t\t\tthis.backupHome = backupHome;\n\t\t\t}\n\n\t\t\ttoBackupPath(arg: URI | string): string {\n\t\t\t\tconst id = arg instanceof URI ? super.getFolderHash({ folderUri: arg }) : arg;\n\t\t\t\treturn path.join(this.backupHome, id);\n\t\t\t}\n\n\t\t\ttestGetFolderHash(folder: IFolderBackupInfo): string {\n\t\t\t\treturn super.getFolderHash(folder);\n\t\t\t}\n\n\t\t\ttestGetWorkspaceBackups(): IWorkspaceBackupInfo[] {\n\t\t\t\treturn super.getWorkspaceBackups();\n\t\t\t}\n\n\t\t\ttestGetFolderBackups(): IFolderBackupInfo[] {\n\t\t\t\treturn super.getFolderBackups();\n\t\t\t}\n\t\t};\n\n\t\treturn service.initialize();\n\t});\n\n\tteardown(() => {\n\t\treturn Promises.rm(testDir);\n\t});\n\n\ttest('service validates backup workspaces on startup and cleans up (folder workspaces)', async function () {\n\n\t\t// 1) backup workspace path does not exist\n\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\tservice.registerFolderBackup(toFolderBackupInfo(barFile));\n\t\tawait service.initialize();\n\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\n\t\t// 2) backup workspace path exists with empty contents within\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\tservice.registerFolderBackup(toFolderBackupInfo(barFile));\n\t\tawait service.initialize();\n\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(fooFile)));\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(barFile)));\n\n\t\t// 3) backup workspace path exists with empty folders within\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tfs.mkdirSync(path.join(service.toBackupPath(fooFile), Schemas.file));\n\t\tfs.mkdirSync(path.join(service.toBackupPath(barFile), Schemas.untitled));\n\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\tservice.registerFolderBackup(toFolderBackupInfo(barFile));\n\t\tawait service.initialize();\n\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(fooFile)));\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(barFile)));\n\n\t\t// 4) backup workspace path points to a workspace that no longer exists\n\t\t// so it should convert the backup worspace to an empty workspace backup\n\t\tconst fileBackups = path.join(service.toBackupPath(fooFile), Schemas.file);\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tfs.mkdirSync(fileBackups);\n\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\tassert.strictEqual(service.testGetFolderBackups().length, 1);\n\t\tassert.strictEqual(service.getEmptyWindowBackups().length, 0);\n\t\tfs.writeFileSync(path.join(fileBackups, 'backup.txt'), '');\n\t\tawait service.initialize();\n\t\tassert.strictEqual(service.testGetFolderBackups().length, 0);\n\t\tassert.strictEqual(service.getEmptyWindowBackups().length, 1);\n\t});\n\n\ttest('service validates backup workspaces on startup and cleans up (root workspaces)', async function () {\n\n\t\t// 1) backup workspace path does not exist\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath));\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(barFile.fsPath));\n\t\tawait service.initialize();\n\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\n\t\t// 2) backup workspace path exists with empty contents within\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath));\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(barFile.fsPath));\n\t\tawait service.initialize();\n\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(fooFile)));\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(barFile)));\n\n\t\t// 3) backup workspace path exists with empty folders within\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tfs.mkdirSync(path.join(service.toBackupPath(fooFile), Schemas.file));\n\t\tfs.mkdirSync(path.join(service.toBackupPath(barFile), Schemas.untitled));\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath));\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(barFile.fsPath));\n\t\tawait service.initialize();\n\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(fooFile)));\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(barFile)));\n\n\t\t// 4) backup workspace path points to a workspace that no longer exists\n\t\t// so it should convert the backup worspace to an empty workspace backup\n\t\tconst fileBackups = path.join(service.toBackupPath(fooFile), Schemas.file);\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tfs.mkdirSync(fileBackups);\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath));\n\t\tassert.strictEqual(service.testGetWorkspaceBackups().length, 1);\n\t\tassert.strictEqual(service.getEmptyWindowBackups().length, 0);\n\t\tfs.writeFileSync(path.join(fileBackups, 'backup.txt'), '');\n\t\tawait service.initialize();\n\t\tassert.strictEqual(service.testGetWorkspaceBackups().length, 0);\n\t\tassert.strictEqual(service.getEmptyWindowBackups().length, 1);\n\t});\n\n\ttest('service supports to migrate backup data from another location', async () => {\n\t\tconst backupPathToMigrate = service.toBackupPath(fooFile);\n\t\tfs.mkdirSync(backupPathToMigrate);\n\t\tfs.writeFileSync(path.join(backupPathToMigrate, 'backup.txt'), 'Some Data');\n\t\tservice.registerFolderBackup(toFolderBackupInfo(URI.file(backupPathToMigrate)));\n\n\t\tconst workspaceBackupPath = await service.registerWorkspaceBackup(toWorkspaceBackupInfo(barFile.fsPath), backupPathToMigrate);\n\n\t\tassert.ok(fs.existsSync(workspaceBackupPath));\n\t\tassert.ok(fs.existsSync(path.join(workspaceBackupPath, 'backup.txt')));\n\t\tassert.ok(!fs.existsSync(backupPathToMigrate));\n\n\t\tconst emptyBackups = service.getEmptyWindowBackups();\n\t\tassert.strictEqual(0, emptyBackups.length);\n\t});\n\n\ttest('service backup migration makes sure to preserve existing backups', async () => {\n\t\tconst backupPathToMigrate = service.toBackupPath(fooFile);\n\t\tfs.mkdirSync(backupPathToMigrate);\n\t\tfs.writeFileSync(path.join(backupPathToMigrate, 'backup.txt'), 'Some Data');\n\t\tservice.registerFolderBackup(toFolderBackupInfo(URI.file(backupPathToMigrate)));\n\n\t\tconst backupPathToPreserve = service.toBackupPath(barFile);\n\t\tfs.mkdirSync(backupPathToPreserve);\n\t\tfs.writeFileSync(path.join(backupPathToPreserve, 'backup.txt'), 'Some Data');\n\t\tservice.registerFolderBackup(toFolderBackupInfo(URI.file(backupPathToPreserve)));\n\n\t\tconst workspaceBackupPath = await service.registerWorkspaceBackup(toWorkspaceBackupInfo(barFile.fsPath), backupPathToMigrate);\n\n\t\tassert.ok(fs.existsSync(workspaceBackupPath));\n\t\tassert.ok(fs.existsSync(path.join(workspaceBackupPath, 'backup.txt')));\n\t\tassert.ok(!fs.existsSync(backupPathToMigrate));\n\n\t\tconst emptyBackups = service.getEmptyWindowBackups();\n\t\tassert.strictEqual(1, emptyBackups.length);\n\t\tassert.strictEqual(1, fs.readdirSync(path.join(backupHome, emptyBackups[0].backupFolder)).length);\n\t});\n\n\tsuite('loadSync', () => {\n\t\ttest('getFolderBackupPaths() should return [] when workspaces.json doesn\\'t exist', () => {\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t});\n\n\t\ttest('getFolderBackupPaths() should return [] when folders in workspaces.json is absent', async () => {\n\t\t\twriteWorkspacesMetadata('{}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t});\n\n\t\ttest('getFolderBackupPaths() should return [] when folders in workspaces.json is not a string array', async () => {\n\t\t\twriteWorkspacesMetadata('{\"folders\":{}}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"folders\":{\"foo\": [\"bar\"]}}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"folders\":{\"foo\": []}}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"folders\":{\"foo\": \"bar\"}}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"folders\":\"foo\"}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"folders\":1}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t});\n\n\t\ttest('getFolderBackupPaths() should return [] when files.hotExit = \"onExitAndWindowClose\"', async () => {\n\t\t\tconst fi = toFolderBackupInfo(URI.file(fooFile.fsPath.toUpperCase()));\n\t\t\tservice.registerFolderBackup(fi);\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), [fi]);\n\t\t\tconfigService.setUserConfiguration('files.hotExit', HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE);\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t});\n\n\t\ttest('getWorkspaceBackups() should return [] when workspaces.json doesn\\'t exist', () => {\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t});\n\n\t\ttest('getWorkspaceBackups() should return [] when folderWorkspaces in workspaces.json is absent', async () => {\n\t\t\twriteWorkspacesMetadata('{}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t});\n\n\t\ttest('getWorkspaceBackups() should return [] when rootWorkspaces in workspaces.json is not a object array', async () => {\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":{}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":{\"foo\": [\"bar\"]}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":{\"foo\": []}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":{\"foo\": \"bar\"}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":\"foo\"}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":1}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t});\n\n\t\ttest('getWorkspaceBackups() should return [] when workspaces in workspaces.json is not a object array', async () => {\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":{}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":{\"foo\": [\"bar\"]}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":{\"foo\": []}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":{\"foo\": \"bar\"}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":\"foo\"}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":1}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t});\n\n\t\ttest('getWorkspaceBackups() should return [] when files.hotExit = \"onExitAndWindowClose\"', async () => {\n\t\t\tconst upperFooPath = fooFile.fsPath.toUpperCase();\n\t\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(upperFooPath));\n\t\t\tassert.strictEqual(service.testGetWorkspaceBackups().length, 1);\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups().map(r => r.workspace.configPath.toString()), [URI.file(upperFooPath).toString()]);\n\t\t\tconfigService.setUserConfiguration('files.hotExit', HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE);\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t});\n\n\t\ttest('getEmptyWorkspaceBackupPaths() should return [] when workspaces.json doesn\\'t exist', () => {\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t});\n\n\t\ttest('getEmptyWorkspaceBackupPaths() should return [] when folderWorkspaces in workspaces.json is absent', async () => {\n\t\t\twriteWorkspacesMetadata('{}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t});\n\n\t\ttest('getEmptyWorkspaceBackupPaths() should return [] when folderWorkspaces in workspaces.json is not a string array', async function () {\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":{}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":{\"foo\": [\"bar\"]}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":{\"foo\": []}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":{\"foo\": \"bar\"}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":\"foo\"}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":1}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t});\n\t});\n\n\tsuite('dedupeFolderWorkspaces', () => {\n\t\ttest('should ignore duplicates (folder workspace)', async () => {\n\n\t\t\tawait ensureFolderExists(existingTestFolder1);\n\n\t\t\tconst workspacesJson: ISerializedBackupWorkspaces = {\n\t\t\t\tworkspaces: [],\n\t\t\t\tfolders: [{ folderUri: existingTestFolder1.toString() }, { folderUri: existingTestFolder1.toString() }],\n\t\t\t\temptyWindows: []\n\t\t\t};\n\t\t\twriteWorkspacesMetadata(JSON.stringify(workspacesJson));\n\t\t\tawait service.initialize();\n\n\t\t\tconst json = readWorkspacesMetadata();\n\t\t\tassert.deepStrictEqual(json.folders, [{ folderUri: existingTestFolder1.toString() }]);\n\t\t});\n\n\t\ttest('should ignore duplicates on Windows and Mac (folder workspace)', async () => {\n\n\t\t\tawait ensureFolderExists(existingTestFolder1);\n\n\t\t\tconst workspacesJson: ISerializedBackupWorkspaces = {\n\t\t\t\tworkspaces: [],\n\t\t\t\tfolders: [{ folderUri: existingTestFolder1.toString() }, { folderUri: existingTestFolder1.toString().toLowerCase() }],\n\t\t\t\temptyWindows: []\n\t\t\t};\n\t\t\twriteWorkspacesMetadata(JSON.stringify(workspacesJson));\n\t\t\tawait service.initialize();\n\t\t\tconst json = readWorkspacesMetadata();\n\t\t\tassert.deepStrictEqual(json.folders, [{ folderUri: existingTestFolder1.toString() }]);\n\t\t});\n\n\t\ttest('should ignore duplicates on Windows and Mac (root workspace)', async () => {\n\t\t\tconst workspacePath = path.join(testDir, 'Foo.code-workspace');\n\t\t\tconst workspacePath1 = path.join(testDir, 'FOO.code-workspace');\n\t\t\tconst workspacePath2 = path.join(testDir, 'foo.code-workspace');\n\n\t\t\tconst workspace1 = await ensureWorkspaceExists(toWorkspace(workspacePath));\n\t\t\tconst workspace2 = await ensureWorkspaceExists(toWorkspace(workspacePath1));\n\t\t\tconst workspace3 = await ensureWorkspaceExists(toWorkspace(workspacePath2));\n\n\t\t\tconst workspacesJson: ISerializedBackupWorkspaces = {\n\t\t\t\tworkspaces: [workspace1, workspace2, workspace3].map(toSerializedWorkspace),\n\t\t\t\tfolders: [],\n\t\t\t\temptyWindows: []\n\t\t\t};\n\t\t\twriteWorkspacesMetadata(JSON.stringify(workspacesJson));\n\t\t\tawait service.initialize();\n\n\t\t\tconst json = readWorkspacesMetadata();\n\t\t\tassert.strictEqual(json.workspaces.length, platform.isLinux ? 3 : 1);\n\t\t\tif (platform.isLinux) {\n\t\t\t\tassert.deepStrictEqual(json.workspaces.map(r => r.configURIPath), [URI.file(workspacePath).toString(), URI.file(workspacePath1).toString(), URI.file(workspacePath2).toString()]);\n\t\t\t} else {\n\t\t\t\tassert.deepStrictEqual(json.workspaces.map(r => r.configURIPath), [URI.file(workspacePath).toString()], 'should return the first duplicated entry');\n\t\t\t}\n\t\t});\n\t});\n\n\tsuite('registerWindowForBackups', () => {\n\t\ttest('should persist paths to workspaces.json (folder workspace)', async () => {\n\t\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\t\tservice.registerFolderBackup(toFolderBackupInfo(barFile));\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), [toFolderBackupInfo(fooFile), toFolderBackupInfo(barFile)]);\n\n\t\t\tconst json = readWorkspacesMetadata();\n\t\t\tassert.deepStrictEqual(json.folders, [{ folderUri: fooFile.toString() }, { folderUri: barFile.toString() }]);\n\t\t});\n\n\t\ttest('should persist paths to workspaces.json (root workspace)', async () => {\n\t\t\tconst ws1 = toWorkspaceBackupInfo(fooFile.fsPath);\n\t\t\tservice.registerWorkspaceBackup(ws1);\n\t\t\tconst ws2 = toWorkspaceBackupInfo(barFile.fsPath);\n\t\t\tservice.registerWorkspaceBackup(ws2);\n\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups().map(b => b.workspace.configPath.toString()), [fooFile.toString(), barFile.toString()]);\n\t\t\tassert.strictEqual(ws1.workspace.id, service.testGetWorkspaceBackups()[0].workspace.id);\n\t\t\tassert.strictEqual(ws2.workspace.id, service.testGetWorkspaceBackups()[1].workspace.id);\n\n\t\t\tconst json = readWorkspacesMetadata();\n\t\t\tassert.deepStrictEqual(json.workspaces.map(b => b.configURIPath), [fooFile.toString(), barFile.toString()]);\n\t\t\tassert.strictEqual(ws1.workspace.id, json.workspaces[0].id);\n\t\t\tassert.strictEqual(ws2.workspace.id, json.workspaces[1].id);\n\t\t});\n\t});\n\n\ttest('should always store the workspace path in workspaces.json using the case given, regardless of whether the file system is case-sensitive (folder workspace)', async () => {\n\t\tservice.registerFolderBackup(toFolderBackupInfo(URI.file(fooFile.fsPath.toUpperCase())));\n\t\tassertEqualFolderInfos(service.testGetFolderBackups(), [toFolderBackupInfo(URI.file(fooFile.fsPath.toUpperCase()))]);\n\n\t\tconst json = readWorkspacesMetadata();\n\t\tassert.deepStrictEqual(json.folders, [{ folderUri: URI.file(fooFile.fsPath.toUpperCase()).toString() }]);\n\t});\n\n\ttest('should always store the workspace path in workspaces.json using the case given, regardless of whether the file system is case-sensitive (root workspace)', async () => {\n\t\tconst upperFooPath = fooFile.fsPath.toUpperCase();\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(upperFooPath));\n\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups().map(b => b.workspace.configPath.toString()), [URI.file(upperFooPath).toString()]);\n\n\t\tconst json = readWorkspacesMetadata();\n\t\tassert.deepStrictEqual(json.workspaces.map(b => b.configURIPath), [URI.file(upperFooPath).toString()]);\n\t});\n\n\tsuite('getWorkspaceHash', () => {\n\t\t(platform.isLinux ? test.skip : test)('should ignore case on Windows and Mac', () => {\n\t\t\tconst assertFolderHash = (uri1: URI, uri2: URI) => {\n\t\t\t\tassert.strictEqual(service.testGetFolderHash(toFolderBackupInfo(uri1)), service.testGetFolderHash(toFolderBackupInfo(uri2)));\n\t\t\t};\n\n\t\t\tif (platform.isMacintosh) {\n\t\t\t\tassertFolderHash(URI.file('/foo'), URI.file('/FOO'));\n\t\t\t}\n\n\t\t\tif (platform.isWindows) {\n\t\t\t\tassertFolderHash(URI.file('c:\\\\foo'), URI.file('C:\\\\FOO'));\n\t\t\t}\n\t\t});\n\t});\n\n\tsuite('mixed path casing', () => {\n\t\ttest('should handle case insensitive paths properly (registerWindowForBackupsSync) (folder workspace)', () => {\n\t\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\t\tservice.registerFolderBackup(toFolderBackupInfo(URI.file(fooFile.fsPath.toUpperCase())));\n\n\t\t\tif (platform.isLinux) {\n\t\t\t\tassert.strictEqual(service.testGetFolderBackups().length, 2);\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(service.testGetFolderBackups().length, 1);\n\t\t\t}\n\t\t});\n\n\t\ttest('should handle case insensitive paths properly (registerWindowForBackupsSync) (root workspace)', () => {\n\t\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath));\n\t\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath.toUpperCase()));\n\n\t\t\tif (platform.isLinux) {\n\t\t\t\tassert.strictEqual(service.testGetWorkspaceBackups().length, 2);\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(service.testGetWorkspaceBackups().length, 1);\n\t\t\t}\n\t\t});\n\t});\n\n\tsuite('getDirtyWorkspaces', () => {\n\t\ttest('should report if a workspace or folder has backups', async () => {\n\t\t\tconst folderBackupPath = service.registerFolderBackup(toFolderBackupInfo(fooFile));\n\n\t\t\tconst backupWorkspaceInfo = toWorkspaceBackupInfo(fooFile.fsPath);\n\t\t\tconst workspaceBackupPath = service.registerWorkspaceBackup(backupWorkspaceInfo);\n\n\t\t\tassert.strictEqual(((await service.getDirtyWorkspaces()).length), 0);\n\n\t\t\ttry {\n\t\t\t\tawait fs.promises.mkdir(path.join(folderBackupPath, Schemas.file), { recursive: true });\n\t\t\t\tawait fs.promises.mkdir(path.join(workspaceBackupPath, Schemas.untitled), { recursive: true });\n\t\t\t} catch {\n\t\t\t\t// ignore - folder might exist already\n\t\t\t}\n\n\t\t\tassert.strictEqual(((await service.getDirtyWorkspaces()).length), 0);\n\n\t\t\tfs.writeFileSync(path.join(folderBackupPath, Schemas.file, '594a4a9d82a277a899d4713a5b08f504'), '');\n\t\t\tfs.writeFileSync(path.join(workspaceBackupPath, Schemas.untitled, '594a4a9d82a277a899d4713a5b08f504'), '');\n\n\t\t\tconst dirtyWorkspaces = await service.getDirtyWorkspaces();\n\t\t\tassert.strictEqual(dirtyWorkspaces.length, 2);\n\n\t\t\tlet found = 0;\n\t\t\tfor (const dirtyWorkpspace of dirtyWorkspaces) {\n\t\t\t\tif (isFolderBackupInfo(dirtyWorkpspace)) {\n\t\t\t\t\tif (isEqual(fooFile, dirtyWorkpspace.folderUri)) {\n\t\t\t\t\t\tfound++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isEqual(backupWorkspaceInfo.workspace.configPath, dirtyWorkpspace.workspace.configPath)) {\n\t\t\t\t\t\tfound++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassert.strictEqual(found, 2);\n\t\t});\n\t});\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { createHash } from 'crypto';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport { Schemas } from '../../../../base/common/network.js';\nimport * as path from '../../../../base/common/path.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Promises } from '../../../../base/node/pfs.js';\nimport { flakySuite, getRandomTestPath } from '../../../../base/test/node/testUtils.js';\nimport { BackupMainService } from '../../electron-main/backupMainService.js';\nimport { ISerializedBackupWorkspaces, ISerializedWorkspaceBackupInfo } from '../../node/backup.js';\nimport { TestConfigurationService } from '../../../configuration/test/common/testConfigurationService.js';\nimport { EnvironmentMainService } from '../../../environment/electron-main/environmentMainService.js';\nimport { OPTIONS, parseArgs } from '../../../environment/node/argv.js';\nimport { HotExitConfiguration } from '../../../files/common/files.js';\nimport { ConsoleMainLogger } from '../../../log/common/log.js';\nimport product from '../../../product/common/product.js';\nimport { IFolderBackupInfo, isFolderBackupInfo, IWorkspaceBackupInfo } from '../../common/backup.js';\nimport { IWorkspaceIdentifier } from '../../../workspace/common/workspace.js';\nimport { InMemoryTestStateMainService } from '../../../test/electron-main/workbenchTestServices.js';\nimport { LogService } from '../../../log/common/logService.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../base/test/common/utils.js';\n\nflakySuite('BackupMainService', () => {\n\n\tfunction assertEqualFolderInfos(actual: IFolderBackupInfo[], expected: IFolderBackupInfo[]) {\n\t\tconst withUriAsString = (f: IFolderBackupInfo) => ({ folderUri: f.folderUri.toString(), remoteAuthority: f.remoteAuthority });\n\t\tassert.deepStrictEqual(actual.map(withUriAsString), expected.map(withUriAsString));\n\t}\n\n\tfunction toWorkspace(path: string): IWorkspaceIdentifier {\n\t\treturn {\n\t\t\tid: createHash('md5').update(sanitizePath(path)).digest('hex'), // CodeQL [SM04514] Using MD5 to convert a file path to a fixed length\n\t\t\tconfigPath: URI.file(path)\n\t\t};\n\t}\n\n\tfunction toWorkspaceBackupInfo(path: string, remoteAuthority?: string): IWorkspaceBackupInfo {\n\t\treturn {\n\t\t\tworkspace: {\n\t\t\t\tid: createHash('md5').update(sanitizePath(path)).digest('hex'), // CodeQL [SM04514] Using MD5 to convert a file path to a fixed length\n\t\t\t\tconfigPath: URI.file(path)\n\t\t\t},\n\t\t\tremoteAuthority\n\t\t};\n\t}\n\n\tfunction toFolderBackupInfo(uri: URI, remoteAuthority?: string): IFolderBackupInfo {\n\t\treturn { folderUri: uri, remoteAuthority };\n\t}\n\n\tfunction toSerializedWorkspace(ws: IWorkspaceIdentifier): ISerializedWorkspaceBackupInfo {\n\t\treturn {\n\t\t\tid: ws.id,\n\t\t\tconfigURIPath: ws.configPath.toString()\n\t\t};\n\t}\n\n\tfunction ensureFolderExists(uri: URI): Promise<void> {\n\t\tif (!fs.existsSync(uri.fsPath)) {\n\t\t\tfs.mkdirSync(uri.fsPath);\n\t\t}\n\n\t\tconst backupFolder = service.toBackupPath(uri);\n\t\treturn createBackupFolder(backupFolder);\n\t}\n\n\tasync function ensureWorkspaceExists(workspace: IWorkspaceIdentifier): Promise<IWorkspaceIdentifier> {\n\t\tif (!fs.existsSync(workspace.configPath.fsPath)) {\n\t\t\tawait Promises.writeFile(workspace.configPath.fsPath, 'Hello');\n\t\t}\n\n\t\tconst backupFolder = service.toBackupPath(workspace.id);\n\t\tawait createBackupFolder(backupFolder);\n\n\t\treturn workspace;\n\t}\n\n\tasync function createBackupFolder(backupFolder: string): Promise<void> {\n\t\tif (!fs.existsSync(backupFolder)) {\n\t\t\tfs.mkdirSync(backupFolder);\n\t\t\tfs.mkdirSync(path.join(backupFolder, Schemas.file));\n\t\t\tawait Promises.writeFile(path.join(backupFolder, Schemas.file, 'foo.txt'), 'Hello');\n\t\t}\n\t}\n\n\tfunction readWorkspacesMetadata(): ISerializedBackupWorkspaces {\n\t\treturn stateMainService.getItem('backupWorkspaces') as ISerializedBackupWorkspaces;\n\t}\n\n\tfunction writeWorkspacesMetadata(data: string): void {\n\t\tif (!data) {\n\t\t\tstateMainService.removeItem('backupWorkspaces');\n\t\t} else {\n\t\t\tstateMainService.setItem('backupWorkspaces', JSON.parse(data));\n\t\t}\n\t}\n\n\tfunction sanitizePath(p: string): string {\n\t\treturn platform.isLinux ? p : p.toLowerCase();\n\t}\n\n\tconst fooFile = URI.file(platform.isWindows ? 'C:\\\\foo' : '/foo');\n\tconst barFile = URI.file(platform.isWindows ? 'C:\\\\bar' : '/bar');\n\n\tlet service: BackupMainService & {\n\t\ttoBackupPath(arg: URI | string): string;\n\t\ttestGetFolderHash(folder: IFolderBackupInfo): string;\n\t\ttestGetWorkspaceBackups(): IWorkspaceBackupInfo[];\n\t\ttestGetFolderBackups(): IFolderBackupInfo[];\n\t};\n\tlet configService: TestConfigurationService;\n\tlet stateMainService: InMemoryTestStateMainService;\n\n\tlet environmentService: EnvironmentMainService;\n\tlet testDir: string;\n\tlet backupHome: string;\n\tlet existingTestFolder1: URI;\n\n\tsetup(async () => {\n\t\ttestDir = getRandomTestPath(os.tmpdir(), 'vsctests', 'backupmainservice');\n\t\tbackupHome = path.join(testDir, 'Backups');\n\t\texistingTestFolder1 = URI.file(path.join(testDir, 'folder1'));\n\n\t\tenvironmentService = new EnvironmentMainService(parseArgs(process.argv, OPTIONS), { _serviceBrand: undefined, ...product });\n\n\t\tawait fs.promises.mkdir(backupHome, { recursive: true });\n\n\t\tconfigService = new TestConfigurationService();\n\t\tstateMainService = new InMemoryTestStateMainService();\n\n\t\tservice = new class TestBackupMainService extends BackupMainService {\n\t\t\tconstructor() {\n\t\t\t\tsuper(environmentService, configService, new LogService(new ConsoleMainLogger()), stateMainService);\n\n\t\t\t\tthis.backupHome = backupHome;\n\t\t\t}\n\n\t\t\ttoBackupPath(arg: URI | string): string {\n\t\t\t\tconst id = arg instanceof URI ? super.getFolderHash({ folderUri: arg }) : arg;\n\t\t\t\treturn path.join(this.backupHome, id);\n\t\t\t}\n\n\t\t\ttestGetFolderHash(folder: IFolderBackupInfo): string {\n\t\t\t\treturn super.getFolderHash(folder);\n\t\t\t}\n\n\t\t\ttestGetWorkspaceBackups(): IWorkspaceBackupInfo[] {\n\t\t\t\treturn super.getWorkspaceBackups();\n\t\t\t}\n\n\t\t\ttestGetFolderBackups(): IFolderBackupInfo[] {\n\t\t\t\treturn super.getFolderBackups();\n\t\t\t}\n\t\t};\n\n\t\treturn service.initialize();\n\t});\n\n\tteardown(() => {\n\t\treturn Promises.rm(testDir);\n\t});\n\n\ttest('service validates backup workspaces on startup and cleans up (folder workspaces)', async function () {\n\n\t\t// 1) backup workspace path does not exist\n\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\tservice.registerFolderBackup(toFolderBackupInfo(barFile));\n\t\tawait service.initialize();\n\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\n\t\t// 2) backup workspace path exists with empty contents within\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\tservice.registerFolderBackup(toFolderBackupInfo(barFile));\n\t\tawait service.initialize();\n\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(fooFile)));\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(barFile)));\n\n\t\t// 3) backup workspace path exists with empty folders within\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tfs.mkdirSync(path.join(service.toBackupPath(fooFile), Schemas.file));\n\t\tfs.mkdirSync(path.join(service.toBackupPath(barFile), Schemas.untitled));\n\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\tservice.registerFolderBackup(toFolderBackupInfo(barFile));\n\t\tawait service.initialize();\n\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(fooFile)));\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(barFile)));\n\n\t\t// 4) backup workspace path points to a workspace that no longer exists\n\t\t// so it should convert the backup worspace to an empty workspace backup\n\t\tconst fileBackups = path.join(service.toBackupPath(fooFile), Schemas.file);\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tfs.mkdirSync(fileBackups);\n\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\tassert.strictEqual(service.testGetFolderBackups().length, 1);\n\t\tassert.strictEqual(service.getEmptyWindowBackups().length, 0);\n\t\tfs.writeFileSync(path.join(fileBackups, 'backup.txt'), '');\n\t\tawait service.initialize();\n\t\tassert.strictEqual(service.testGetFolderBackups().length, 0);\n\t\tassert.strictEqual(service.getEmptyWindowBackups().length, 1);\n\t});\n\n\ttest('service validates backup workspaces on startup and cleans up (root workspaces)', async function () {\n\n\t\t// 1) backup workspace path does not exist\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath));\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(barFile.fsPath));\n\t\tawait service.initialize();\n\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\n\t\t// 2) backup workspace path exists with empty contents within\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath));\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(barFile.fsPath));\n\t\tawait service.initialize();\n\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(fooFile)));\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(barFile)));\n\n\t\t// 3) backup workspace path exists with empty folders within\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tfs.mkdirSync(path.join(service.toBackupPath(fooFile), Schemas.file));\n\t\tfs.mkdirSync(path.join(service.toBackupPath(barFile), Schemas.untitled));\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath));\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(barFile.fsPath));\n\t\tawait service.initialize();\n\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(fooFile)));\n\t\tassert.ok(!fs.existsSync(service.toBackupPath(barFile)));\n\n\t\t// 4) backup workspace path points to a workspace that no longer exists\n\t\t// so it should convert the backup worspace to an empty workspace backup\n\t\tconst fileBackups = path.join(service.toBackupPath(fooFile), Schemas.file);\n\t\tfs.mkdirSync(service.toBackupPath(fooFile));\n\t\tfs.mkdirSync(service.toBackupPath(barFile));\n\t\tfs.mkdirSync(fileBackups);\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath));\n\t\tassert.strictEqual(service.testGetWorkspaceBackups().length, 1);\n\t\tassert.strictEqual(service.getEmptyWindowBackups().length, 0);\n\t\tfs.writeFileSync(path.join(fileBackups, 'backup.txt'), '');\n\t\tawait service.initialize();\n\t\tassert.strictEqual(service.testGetWorkspaceBackups().length, 0);\n\t\tassert.strictEqual(service.getEmptyWindowBackups().length, 1);\n\t});\n\n\ttest('service supports to migrate backup data from another location', async () => {\n\t\tconst backupPathToMigrate = service.toBackupPath(fooFile);\n\t\tfs.mkdirSync(backupPathToMigrate);\n\t\tfs.writeFileSync(path.join(backupPathToMigrate, 'backup.txt'), 'Some Data');\n\t\tservice.registerFolderBackup(toFolderBackupInfo(URI.file(backupPathToMigrate)));\n\n\t\tconst workspaceBackupPath = await service.registerWorkspaceBackup(toWorkspaceBackupInfo(barFile.fsPath), backupPathToMigrate);\n\n\t\tassert.ok(fs.existsSync(workspaceBackupPath));\n\t\tassert.ok(fs.existsSync(path.join(workspaceBackupPath, 'backup.txt')));\n\t\tassert.ok(!fs.existsSync(backupPathToMigrate));\n\n\t\tconst emptyBackups = service.getEmptyWindowBackups();\n\t\tassert.strictEqual(0, emptyBackups.length);\n\t});\n\n\ttest('service backup migration makes sure to preserve existing backups', async () => {\n\t\tconst backupPathToMigrate = service.toBackupPath(fooFile);\n\t\tfs.mkdirSync(backupPathToMigrate);\n\t\tfs.writeFileSync(path.join(backupPathToMigrate, 'backup.txt'), 'Some Data');\n\t\tservice.registerFolderBackup(toFolderBackupInfo(URI.file(backupPathToMigrate)));\n\n\t\tconst backupPathToPreserve = service.toBackupPath(barFile);\n\t\tfs.mkdirSync(backupPathToPreserve);\n\t\tfs.writeFileSync(path.join(backupPathToPreserve, 'backup.txt'), 'Some Data');\n\t\tservice.registerFolderBackup(toFolderBackupInfo(URI.file(backupPathToPreserve)));\n\n\t\tconst workspaceBackupPath = await service.registerWorkspaceBackup(toWorkspaceBackupInfo(barFile.fsPath), backupPathToMigrate);\n\n\t\tassert.ok(fs.existsSync(workspaceBackupPath));\n\t\tassert.ok(fs.existsSync(path.join(workspaceBackupPath, 'backup.txt')));\n\t\tassert.ok(!fs.existsSync(backupPathToMigrate));\n\n\t\tconst emptyBackups = service.getEmptyWindowBackups();\n\t\tassert.strictEqual(1, emptyBackups.length);\n\t\tassert.strictEqual(1, fs.readdirSync(path.join(backupHome, emptyBackups[0].backupFolder)).length);\n\t});\n\n\tsuite('loadSync', () => {\n\t\ttest('getFolderBackupPaths() should return [] when workspaces.json doesn\\'t exist', () => {\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t});\n\n\t\ttest('getFolderBackupPaths() should return [] when folders in workspaces.json is absent', async () => {\n\t\t\twriteWorkspacesMetadata('{}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t});\n\n\t\ttest('getFolderBackupPaths() should return [] when folders in workspaces.json is not a string array', async () => {\n\t\t\twriteWorkspacesMetadata('{\"folders\":{}}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"folders\":{\"foo\": [\"bar\"]}}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"folders\":{\"foo\": []}}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"folders\":{\"foo\": \"bar\"}}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"folders\":\"foo\"}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"folders\":1}');\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t});\n\n\t\ttest('getFolderBackupPaths() should return [] when files.hotExit = \"onExitAndWindowClose\"', async () => {\n\t\t\tconst fi = toFolderBackupInfo(URI.file(fooFile.fsPath.toUpperCase()));\n\t\t\tservice.registerFolderBackup(fi);\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), [fi]);\n\t\t\tconfigService.setUserConfiguration('files.hotExit', HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE);\n\t\t\tawait service.initialize();\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), []);\n\t\t});\n\n\t\ttest('getWorkspaceBackups() should return [] when workspaces.json doesn\\'t exist', () => {\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t});\n\n\t\ttest('getWorkspaceBackups() should return [] when folderWorkspaces in workspaces.json is absent', async () => {\n\t\t\twriteWorkspacesMetadata('{}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t});\n\n\t\ttest('getWorkspaceBackups() should return [] when rootWorkspaces in workspaces.json is not a object array', async () => {\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":{}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":{\"foo\": [\"bar\"]}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":{\"foo\": []}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":{\"foo\": \"bar\"}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":\"foo\"}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"rootWorkspaces\":1}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t});\n\n\t\ttest('getWorkspaceBackups() should return [] when workspaces in workspaces.json is not a object array', async () => {\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":{}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":{\"foo\": [\"bar\"]}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":{\"foo\": []}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":{\"foo\": \"bar\"}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":\"foo\"}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"workspaces\":1}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t});\n\n\t\ttest('getWorkspaceBackups() should return [] when files.hotExit = \"onExitAndWindowClose\"', async () => {\n\t\t\tconst upperFooPath = fooFile.fsPath.toUpperCase();\n\t\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(upperFooPath));\n\t\t\tassert.strictEqual(service.testGetWorkspaceBackups().length, 1);\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups().map(r => r.workspace.configPath.toString()), [URI.file(upperFooPath).toString()]);\n\t\t\tconfigService.setUserConfiguration('files.hotExit', HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE);\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups(), []);\n\t\t});\n\n\t\ttest('getEmptyWorkspaceBackupPaths() should return [] when workspaces.json doesn\\'t exist', () => {\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t});\n\n\t\ttest('getEmptyWorkspaceBackupPaths() should return [] when folderWorkspaces in workspaces.json is absent', async () => {\n\t\t\twriteWorkspacesMetadata('{}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t});\n\n\t\ttest('getEmptyWorkspaceBackupPaths() should return [] when folderWorkspaces in workspaces.json is not a string array', async function () {\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":{}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":{\"foo\": [\"bar\"]}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":{\"foo\": []}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":{\"foo\": \"bar\"}}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":\"foo\"}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t\twriteWorkspacesMetadata('{\"emptyWorkspaces\":1}');\n\t\t\tawait service.initialize();\n\t\t\tassert.deepStrictEqual(service.getEmptyWindowBackups(), []);\n\t\t});\n\t});\n\n\tsuite('dedupeFolderWorkspaces', () => {\n\t\ttest('should ignore duplicates (folder workspace)', async () => {\n\n\t\t\tawait ensureFolderExists(existingTestFolder1);\n\n\t\t\tconst workspacesJson: ISerializedBackupWorkspaces = {\n\t\t\t\tworkspaces: [],\n\t\t\t\tfolders: [{ folderUri: existingTestFolder1.toString() }, { folderUri: existingTestFolder1.toString() }],\n\t\t\t\temptyWindows: []\n\t\t\t};\n\t\t\twriteWorkspacesMetadata(JSON.stringify(workspacesJson));\n\t\t\tawait service.initialize();\n\n\t\t\tconst json = readWorkspacesMetadata();\n\t\t\tassert.deepStrictEqual(json.folders, [{ folderUri: existingTestFolder1.toString() }]);\n\t\t});\n\n\t\ttest('should ignore duplicates on Windows and Mac (folder workspace)', async () => {\n\n\t\t\tawait ensureFolderExists(existingTestFolder1);\n\n\t\t\tconst workspacesJson: ISerializedBackupWorkspaces = {\n\t\t\t\tworkspaces: [],\n\t\t\t\tfolders: [{ folderUri: existingTestFolder1.toString() }, { folderUri: existingTestFolder1.toString().toLowerCase() }],\n\t\t\t\temptyWindows: []\n\t\t\t};\n\t\t\twriteWorkspacesMetadata(JSON.stringify(workspacesJson));\n\t\t\tawait service.initialize();\n\t\t\tconst json = readWorkspacesMetadata();\n\t\t\tassert.deepStrictEqual(json.folders, [{ folderUri: existingTestFolder1.toString() }]);\n\t\t});\n\n\t\ttest('should ignore duplicates on Windows and Mac (root workspace)', async () => {\n\t\t\tconst workspacePath = path.join(testDir, 'Foo.code-workspace');\n\t\t\tconst workspacePath1 = path.join(testDir, 'FOO.code-workspace');\n\t\t\tconst workspacePath2 = path.join(testDir, 'foo.code-workspace');\n\n\t\t\tconst workspace1 = await ensureWorkspaceExists(toWorkspace(workspacePath));\n\t\t\tconst workspace2 = await ensureWorkspaceExists(toWorkspace(workspacePath1));\n\t\t\tconst workspace3 = await ensureWorkspaceExists(toWorkspace(workspacePath2));\n\n\t\t\tconst workspacesJson: ISerializedBackupWorkspaces = {\n\t\t\t\tworkspaces: [workspace1, workspace2, workspace3].map(toSerializedWorkspace),\n\t\t\t\tfolders: [],\n\t\t\t\temptyWindows: []\n\t\t\t};\n\t\t\twriteWorkspacesMetadata(JSON.stringify(workspacesJson));\n\t\t\tawait service.initialize();\n\n\t\t\tconst json = readWorkspacesMetadata();\n\t\t\tassert.strictEqual(json.workspaces.length, platform.isLinux ? 3 : 1);\n\t\t\tif (platform.isLinux) {\n\t\t\t\tassert.deepStrictEqual(json.workspaces.map(r => r.configURIPath), [URI.file(workspacePath).toString(), URI.file(workspacePath1).toString(), URI.file(workspacePath2).toString()]);\n\t\t\t} else {\n\t\t\t\tassert.deepStrictEqual(json.workspaces.map(r => r.configURIPath), [URI.file(workspacePath).toString()], 'should return the first duplicated entry');\n\t\t\t}\n\t\t});\n\t});\n\n\tsuite('registerWindowForBackups', () => {\n\t\ttest('should persist paths to workspaces.json (folder workspace)', async () => {\n\t\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\t\tservice.registerFolderBackup(toFolderBackupInfo(barFile));\n\t\t\tassertEqualFolderInfos(service.testGetFolderBackups(), [toFolderBackupInfo(fooFile), toFolderBackupInfo(barFile)]);\n\n\t\t\tconst json = readWorkspacesMetadata();\n\t\t\tassert.deepStrictEqual(json.folders, [{ folderUri: fooFile.toString() }, { folderUri: barFile.toString() }]);\n\t\t});\n\n\t\ttest('should persist paths to workspaces.json (root workspace)', async () => {\n\t\t\tconst ws1 = toWorkspaceBackupInfo(fooFile.fsPath);\n\t\t\tservice.registerWorkspaceBackup(ws1);\n\t\t\tconst ws2 = toWorkspaceBackupInfo(barFile.fsPath);\n\t\t\tservice.registerWorkspaceBackup(ws2);\n\n\t\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups().map(b => b.workspace.configPath.toString()), [fooFile.toString(), barFile.toString()]);\n\t\t\tassert.strictEqual(ws1.workspace.id, service.testGetWorkspaceBackups()[0].workspace.id);\n\t\t\tassert.strictEqual(ws2.workspace.id, service.testGetWorkspaceBackups()[1].workspace.id);\n\n\t\t\tconst json = readWorkspacesMetadata();\n\t\t\tassert.deepStrictEqual(json.workspaces.map(b => b.configURIPath), [fooFile.toString(), barFile.toString()]);\n\t\t\tassert.strictEqual(ws1.workspace.id, json.workspaces[0].id);\n\t\t\tassert.strictEqual(ws2.workspace.id, json.workspaces[1].id);\n\t\t});\n\t});\n\n\ttest('should always store the workspace path in workspaces.json using the case given, regardless of whether the file system is case-sensitive (folder workspace)', async () => {\n\t\tservice.registerFolderBackup(toFolderBackupInfo(URI.file(fooFile.fsPath.toUpperCase())));\n\t\tassertEqualFolderInfos(service.testGetFolderBackups(), [toFolderBackupInfo(URI.file(fooFile.fsPath.toUpperCase()))]);\n\n\t\tconst json = readWorkspacesMetadata();\n\t\tassert.deepStrictEqual(json.folders, [{ folderUri: URI.file(fooFile.fsPath.toUpperCase()).toString() }]);\n\t});\n\n\ttest('should always store the workspace path in workspaces.json using the case given, regardless of whether the file system is case-sensitive (root workspace)', async () => {\n\t\tconst upperFooPath = fooFile.fsPath.toUpperCase();\n\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(upperFooPath));\n\t\tassert.deepStrictEqual(service.testGetWorkspaceBackups().map(b => b.workspace.configPath.toString()), [URI.file(upperFooPath).toString()]);\n\n\t\tconst json = readWorkspacesMetadata();\n\t\tassert.deepStrictEqual(json.workspaces.map(b => b.configURIPath), [URI.file(upperFooPath).toString()]);\n\t});\n\n\tsuite('getWorkspaceHash', () => {\n\t\t(platform.isLinux ? test.skip : test)('should ignore case on Windows and Mac', () => {\n\t\t\tconst assertFolderHash = (uri1: URI, uri2: URI) => {\n\t\t\t\tassert.strictEqual(service.testGetFolderHash(toFolderBackupInfo(uri1)), service.testGetFolderHash(toFolderBackupInfo(uri2)));\n\t\t\t};\n\n\t\t\tif (platform.isMacintosh) {\n\t\t\t\tassertFolderHash(URI.file('/foo'), URI.file('/FOO'));\n\t\t\t}\n\n\t\t\tif (platform.isWindows) {\n\t\t\t\tassertFolderHash(URI.file('c:\\\\foo'), URI.file('C:\\\\FOO'));\n\t\t\t}\n\t\t});\n\t});\n\n\tsuite('mixed path casing', () => {\n\t\ttest('should handle case insensitive paths properly (registerWindowForBackupsSync) (folder workspace)', () => {\n\t\t\tservice.registerFolderBackup(toFolderBackupInfo(fooFile));\n\t\t\tservice.registerFolderBackup(toFolderBackupInfo(URI.file(fooFile.fsPath.toUpperCase())));\n\n\t\t\tif (platform.isLinux) {\n\t\t\t\tassert.strictEqual(service.testGetFolderBackups().length, 2);\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(service.testGetFolderBackups().length, 1);\n\t\t\t}\n\t\t});\n\n\t\ttest('should handle case insensitive paths properly (registerWindowForBackupsSync) (root workspace)', () => {\n\t\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath));\n\t\t\tservice.registerWorkspaceBackup(toWorkspaceBackupInfo(fooFile.fsPath.toUpperCase()));\n\n\t\t\tif (platform.isLinux) {\n\t\t\t\tassert.strictEqual(service.testGetWorkspaceBackups().length, 2);\n\t\t\t} else {\n\t\t\t\tassert.strictEqual(service.testGetWorkspaceBackups().length, 1);\n\t\t\t}\n\t\t});\n\t});\n\n\tsuite('getDirtyWorkspaces', () => {\n\t\ttest('should report if a workspace or folder has backups', async () => {\n\t\t\tconst folderBackupPath = service.registerFolderBackup(toFolderBackupInfo(fooFile));\n\n\t\t\tconst backupWorkspaceInfo = toWorkspaceBackupInfo(fooFile.fsPath);\n\t\t\tconst workspaceBackupPath = service.registerWorkspaceBackup(backupWorkspaceInfo);\n\n\t\t\tassert.strictEqual(((await service.getDirtyWorkspaces()).length), 0);\n\n\t\t\ttry {\n\t\t\t\tawait fs.promises.mkdir(path.join(folderBackupPath, Schemas.file), { recursive: true });\n\t\t\t\tawait fs.promises.mkdir(path.join(workspaceBackupPath, Schemas.untitled), { recursive: true });\n\t\t\t} catch {\n\t\t\t\t// ignore - folder might exist already\n\t\t\t}\n\n\t\t\tassert.strictEqual(((await service.getDirtyWorkspaces()).length), 0);\n\n\t\t\tfs.writeFileSync(path.join(folderBackupPath, Schemas.file, '594a4a9d82a277a899d4713a5b08f504'), '');\n\t\t\tfs.writeFileSync(path.join(workspaceBackupPath, Schemas.untitled, '594a4a9d82a277a899d4713a5b08f504'), '');\n\n\t\t\tconst dirtyWorkspaces = await service.getDirtyWorkspaces();\n\t\t\tassert.strictEqual(dirtyWorkspaces.length, 2);\n\n\t\t\tlet found = 0;\n\t\t\tfor (const dirtyWorkpspace of dirtyWorkspaces) {\n\t\t\t\tif (isFolderBackupInfo(dirtyWorkpspace)) {\n\t\t\t\t\tif (isEqual(fooFile, dirtyWorkpspace.folderUri)) {\n\t\t\t\t\t\tfound++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isEqual(backupWorkspaceInfo.workspace.configPath, dirtyWorkpspace.workspace.configPath)) {\n\t\t\t\t\t\tfound++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassert.strictEqual(found, 2);\n\t\t});\n\t});\n\n\tensureNoDisposablesAreLeakedInTestSuite();\n});\n"]}