{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/backup/electron-main/backupMainService.ts","vs/platform/backup/electron-main/backupMainService.ts"],"names":[],"mappings":"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","file":"backupMainService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createHash } from 'crypto';\nimport { isEqual } from '../../../base/common/extpath.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { join } from '../../../base/common/path.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport { extUriBiasedIgnorePathCase } from '../../../base/common/resources.js';\nimport { Promises, RimRafMode } from '../../../base/node/pfs.js';\nimport { IBackupMainService } from './backup.js';\nimport { ISerializedBackupWorkspaces, IEmptyWindowBackupInfo, isEmptyWindowBackupInfo, deserializeWorkspaceInfos, deserializeFolderInfos, ISerializedWorkspaceBackupInfo, ISerializedFolderBackupInfo, ISerializedEmptyWindowBackupInfo } from '../node/backup.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { IStateService } from '../../state/node/state.js';\nimport { HotExitConfiguration, IFilesConfiguration } from '../../files/common/files.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IFolderBackupInfo, isFolderBackupInfo, IWorkspaceBackupInfo } from '../common/backup.js';\nimport { isWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { createEmptyWorkspaceIdentifier } from '../../workspaces/node/workspaces.js';\n\nexport class BackupMainService implements IBackupMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly backupWorkspacesMetadataStorageKey = 'backupWorkspaces';\n\n\tprotected backupHome: string;\n\n\tprivate workspaces: IWorkspaceBackupInfo[] = [];\n\tprivate folders: IFolderBackupInfo[] = [];\n\tprivate emptyWindows: IEmptyWindowBackupInfo[] = [];\n\n\t// Comparers for paths and resources that will\n\t// - ignore path casing on Windows/macOS\n\t// - respect path casing on Linux\n\tprivate readonly backupUriComparer = extUriBiasedIgnorePathCase;\n\tprivate readonly backupPathComparer = { isEqual: (pathA: string, pathB: string) => isEqual(pathA, pathB, !isLinux) };\n\n\tconstructor(\n\t\t@IEnvironmentMainService environmentMainService: IEnvironmentMainService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStateService private readonly stateService: IStateService\n\t) {\n\t\tthis.backupHome = environmentMainService.backupHome;\n\t}\n\n\tasync initialize(): Promise<void> {\n\n\t\t// read backup workspaces\n\t\tconst serializedBackupWorkspaces = this.stateService.getItem<ISerializedBackupWorkspaces>(BackupMainService.backupWorkspacesMetadataStorageKey) ?? { workspaces: [], folders: [], emptyWindows: [] };\n\n\t\t// validate empty workspaces backups first\n\t\tthis.emptyWindows = await this.validateEmptyWorkspaces(serializedBackupWorkspaces.emptyWindows);\n\n\t\t// validate workspace backups\n\t\tthis.workspaces = await this.validateWorkspaces(deserializeWorkspaceInfos(serializedBackupWorkspaces));\n\n\t\t// validate folder backups\n\t\tthis.folders = await this.validateFolders(deserializeFolderInfos(serializedBackupWorkspaces));\n\n\t\t// store metadata in case some workspaces or folders have been removed\n\t\tthis.storeWorkspacesMetadata();\n\t}\n\n\tprotected getWorkspaceBackups(): IWorkspaceBackupInfo[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.workspaces.slice(0); // return a copy\n\t}\n\n\tprotected getFolderBackups(): IFolderBackupInfo[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.folders.slice(0); // return a copy\n\t}\n\n\tisHotExitEnabled(): boolean {\n\t\treturn this.getHotExitConfig() !== HotExitConfiguration.OFF;\n\t}\n\n\tprivate isHotExitOnExitAndWindowClose(): boolean {\n\t\treturn this.getHotExitConfig() === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE;\n\t}\n\n\tprivate getHotExitConfig(): string {\n\t\tconst config = this.configurationService.getValue<IFilesConfiguration>();\n\n\t\treturn config?.files?.hotExit || HotExitConfiguration.ON_EXIT;\n\t}\n\n\tgetEmptyWindowBackups(): IEmptyWindowBackupInfo[] {\n\t\treturn this.emptyWindows.slice(0); // return a copy\n\t}\n\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo): string;\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo, migrateFrom: string): Promise<string>;\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo, migrateFrom?: string): string | Promise<string> {\n\t\tif (!this.workspaces.some(workspace => workspaceInfo.workspace.id === workspace.workspace.id)) {\n\t\t\tthis.workspaces.push(workspaceInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\tconst backupPath = join(this.backupHome, workspaceInfo.workspace.id);\n\n\t\tif (migrateFrom) {\n\t\t\treturn this.moveBackupFolder(backupPath, migrateFrom).then(() => backupPath);\n\t\t}\n\n\t\treturn backupPath;\n\t}\n\n\tprivate async moveBackupFolder(backupPath: string, moveFromPath: string): Promise<void> {\n\n\t\t// Target exists: make sure to convert existing backups to empty window backups\n\t\tif (await Promises.exists(backupPath)) {\n\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t}\n\n\t\t// When we have data to migrate from, move it over to the target location\n\t\tif (await Promises.exists(moveFromPath)) {\n\t\t\ttry {\n\t\t\t\tawait Promises.rename(moveFromPath, backupPath, false /* no retry */);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`Backup: Could not move backup folder to new location: ${error.toString()}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterFolderBackup(folderInfo: IFolderBackupInfo): string {\n\t\tif (!this.folders.some(folder => this.backupUriComparer.isEqual(folderInfo.folderUri, folder.folderUri))) {\n\t\t\tthis.folders.push(folderInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\treturn join(this.backupHome, this.getFolderHash(folderInfo));\n\t}\n\n\tregisterEmptyWindowBackup(emptyWindowInfo: IEmptyWindowBackupInfo): string {\n\t\tif (!this.emptyWindows.some(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, emptyWindowInfo.backupFolder))) {\n\t\t\tthis.emptyWindows.push(emptyWindowInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\treturn join(this.backupHome, emptyWindowInfo.backupFolder);\n\t}\n\n\tprivate async validateWorkspaces(rootWorkspaces: IWorkspaceBackupInfo[]): Promise<IWorkspaceBackupInfo[]> {\n\t\tif (!Array.isArray(rootWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst seenIds: Set<string> = new Set();\n\t\tconst result: IWorkspaceBackupInfo[] = [];\n\n\t\t// Validate Workspaces\n\t\tfor (const workspaceInfo of rootWorkspaces) {\n\t\t\tconst workspace = workspaceInfo.workspace;\n\t\t\tif (!isWorkspaceIdentifier(workspace)) {\n\t\t\t\treturn []; // wrong format, skip all entries\n\t\t\t}\n\n\t\t\tif (!seenIds.has(workspace.id)) {\n\t\t\t\tseenIds.add(workspace.id);\n\n\t\t\t\tconst backupPath = join(this.backupHome, workspace.id);\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the workspace has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (workspace.configPath.scheme !== Schemas.file || await Promises.exists(workspace.configPath.fsPath)) {\n\t\t\t\t\t\tresult.push(workspaceInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the workspace has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateFolders(folderWorkspaces: IFolderBackupInfo[]): Promise<IFolderBackupInfo[]> {\n\t\tif (!Array.isArray(folderWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IFolderBackupInfo[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\t\tfor (const folderInfo of folderWorkspaces) {\n\t\t\tconst folderURI = folderInfo.folderUri;\n\t\t\tconst key = this.backupUriComparer.getComparisonKey(folderURI);\n\t\t\tif (!seenIds.has(key)) {\n\t\t\t\tseenIds.add(key);\n\n\t\t\t\tconst backupPath = join(this.backupHome, this.getFolderHash(folderInfo));\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the folder has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (folderURI.scheme !== Schemas.file || await Promises.exists(folderURI.fsPath)) {\n\t\t\t\t\t\tresult.push(folderInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the folder has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateEmptyWorkspaces(emptyWorkspaces: IEmptyWindowBackupInfo[]): Promise<IEmptyWindowBackupInfo[]> {\n\t\tif (!Array.isArray(emptyWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IEmptyWindowBackupInfo[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\n\t\t// Validate Empty Windows\n\t\tfor (const backupInfo of emptyWorkspaces) {\n\t\t\tconst backupFolder = backupInfo.backupFolder;\n\t\t\tif (typeof backupFolder !== 'string') {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tif (!seenIds.has(backupFolder)) {\n\t\t\t\tseenIds.add(backupFolder);\n\n\t\t\t\tconst backupPath = join(this.backupHome, backupFolder);\n\t\t\t\tif (await this.doHasBackups(backupPath)) {\n\t\t\t\t\tresult.push(backupInfo);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async deleteStaleBackup(backupPath: string): Promise<void> {\n\t\ttry {\n\t\t\tawait Promises.rm(backupPath, RimRafMode.MOVE);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not delete stale backup: ${error.toString()}`);\n\t\t}\n\t}\n\n\tprivate prepareNewEmptyWindowBackup(): IEmptyWindowBackupInfo {\n\n\t\t// We are asked to prepare a new empty window backup folder.\n\t\t// Empty windows backup folders are derived from a workspace\n\t\t// identifier, so we generate a new empty workspace identifier\n\t\t// until we found a unique one.\n\n\t\tlet emptyWorkspaceIdentifier = createEmptyWorkspaceIdentifier();\n\t\twhile (this.emptyWindows.some(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, emptyWorkspaceIdentifier.id))) {\n\t\t\temptyWorkspaceIdentifier = createEmptyWorkspaceIdentifier();\n\t\t}\n\n\t\treturn { backupFolder: emptyWorkspaceIdentifier.id };\n\t}\n\n\tprivate async convertToEmptyWindowBackup(backupPath: string): Promise<boolean> {\n\t\tconst newEmptyWindowBackupInfo = this.prepareNewEmptyWindowBackup();\n\n\t\t// Rename backupPath to new empty window backup path\n\t\tconst newEmptyWindowBackupPath = join(this.backupHome, newEmptyWindowBackupInfo.backupFolder);\n\t\ttry {\n\t\t\tawait Promises.rename(backupPath, newEmptyWindowBackupPath, false /* no retry */);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not rename backup folder: ${error.toString()}`);\n\t\t\treturn false;\n\t\t}\n\t\tthis.emptyWindows.push(newEmptyWindowBackupInfo);\n\n\t\treturn true;\n\t}\n\n\tasync getDirtyWorkspaces(): Promise<Array<IWorkspaceBackupInfo | IFolderBackupInfo>> {\n\t\tconst dirtyWorkspaces: Array<IWorkspaceBackupInfo | IFolderBackupInfo> = [];\n\n\t\t// Workspaces with backups\n\t\tfor (const workspace of this.workspaces) {\n\t\t\tif ((await this.hasBackups(workspace))) {\n\t\t\t\tdirtyWorkspaces.push(workspace);\n\t\t\t}\n\t\t}\n\n\t\t// Folders with backups\n\t\tfor (const folder of this.folders) {\n\t\t\tif ((await this.hasBackups(folder))) {\n\t\t\t\tdirtyWorkspaces.push(folder);\n\t\t\t}\n\t\t}\n\n\t\treturn dirtyWorkspaces;\n\t}\n\n\tprivate hasBackups(backupLocation: IWorkspaceBackupInfo | IEmptyWindowBackupInfo | IFolderBackupInfo): Promise<boolean> {\n\t\tlet backupPath: string;\n\n\t\t// Empty\n\t\tif (isEmptyWindowBackupInfo(backupLocation)) {\n\t\t\tbackupPath = join(this.backupHome, backupLocation.backupFolder);\n\t\t}\n\n\t\t// Folder\n\t\telse if (isFolderBackupInfo(backupLocation)) {\n\t\t\tbackupPath = join(this.backupHome, this.getFolderHash(backupLocation));\n\t\t}\n\n\t\t// Workspace\n\t\telse {\n\t\t\tbackupPath = join(this.backupHome, backupLocation.workspace.id);\n\t\t}\n\n\t\treturn this.doHasBackups(backupPath);\n\t}\n\n\tprivate async doHasBackups(backupPath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst backupSchemas = await Promises.readdir(backupPath);\n\n\t\t\tfor (const backupSchema of backupSchemas) {\n\t\t\t\ttry {\n\t\t\t\t\tconst backupSchemaChildren = await Promises.readdir(join(backupPath, backupSchema));\n\t\t\t\t\tif (backupSchemaChildren.length > 0) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// invalid folder\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\t// backup path does not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\n\tprivate storeWorkspacesMetadata(): void {\n\t\tconst serializedBackupWorkspaces: ISerializedBackupWorkspaces = {\n\t\t\tworkspaces: this.workspaces.map(({ workspace, remoteAuthority }) => {\n\t\t\t\tconst serializedWorkspaceBackupInfo: ISerializedWorkspaceBackupInfo = {\n\t\t\t\t\tid: workspace.id,\n\t\t\t\t\tconfigURIPath: workspace.configPath.toString()\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedWorkspaceBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedWorkspaceBackupInfo;\n\t\t\t}),\n\t\t\tfolders: this.folders.map(({ folderUri, remoteAuthority }) => {\n\t\t\t\tconst serializedFolderBackupInfo: ISerializedFolderBackupInfo =\n\t\t\t\t{\n\t\t\t\t\tfolderUri: folderUri.toString()\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedFolderBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedFolderBackupInfo;\n\t\t\t}),\n\t\t\temptyWindows: this.emptyWindows.map(({ backupFolder, remoteAuthority }) => {\n\t\t\t\tconst serializedEmptyWindowBackupInfo: ISerializedEmptyWindowBackupInfo = {\n\t\t\t\t\tbackupFolder\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedEmptyWindowBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedEmptyWindowBackupInfo;\n\t\t\t})\n\t\t};\n\n\t\tthis.stateService.setItem(BackupMainService.backupWorkspacesMetadataStorageKey, serializedBackupWorkspaces);\n\t}\n\n\tprotected getFolderHash(folder: IFolderBackupInfo): string {\n\t\tconst folderUri = folder.folderUri;\n\n\t\tlet key: string;\n\t\tif (folderUri.scheme === Schemas.file) {\n\t\t\tkey = isLinux ? folderUri.fsPath : folderUri.fsPath.toLowerCase(); // for backward compatibility, use the fspath as key\n\t\t} else {\n\t\t\tkey = folderUri.toString().toLowerCase();\n\t\t}\n\n\t\treturn createHash('md5').update(key).digest('hex'); // CodeQL [SM04514] Using MD5 to convert a file path to a fixed length\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createHash } from 'crypto';\nimport { isEqual } from '../../../base/common/extpath.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { join } from '../../../base/common/path.js';\nimport { isLinux } from '../../../base/common/platform.js';\nimport { extUriBiasedIgnorePathCase } from '../../../base/common/resources.js';\nimport { Promises, RimRafMode } from '../../../base/node/pfs.js';\nimport { IBackupMainService } from './backup.js';\nimport { ISerializedBackupWorkspaces, IEmptyWindowBackupInfo, isEmptyWindowBackupInfo, deserializeWorkspaceInfos, deserializeFolderInfos, ISerializedWorkspaceBackupInfo, ISerializedFolderBackupInfo, ISerializedEmptyWindowBackupInfo } from '../node/backup.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { IStateService } from '../../state/node/state.js';\nimport { HotExitConfiguration, IFilesConfiguration } from '../../files/common/files.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IFolderBackupInfo, isFolderBackupInfo, IWorkspaceBackupInfo } from '../common/backup.js';\nimport { isWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { createEmptyWorkspaceIdentifier } from '../../workspaces/node/workspaces.js';\n\nexport class BackupMainService implements IBackupMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly backupWorkspacesMetadataStorageKey = 'backupWorkspaces';\n\n\tprotected backupHome: string;\n\n\tprivate workspaces: IWorkspaceBackupInfo[] = [];\n\tprivate folders: IFolderBackupInfo[] = [];\n\tprivate emptyWindows: IEmptyWindowBackupInfo[] = [];\n\n\t// Comparers for paths and resources that will\n\t// - ignore path casing on Windows/macOS\n\t// - respect path casing on Linux\n\tprivate readonly backupUriComparer = extUriBiasedIgnorePathCase;\n\tprivate readonly backupPathComparer = { isEqual: (pathA: string, pathB: string) => isEqual(pathA, pathB, !isLinux) };\n\n\tconstructor(\n\t\t@IEnvironmentMainService environmentMainService: IEnvironmentMainService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStateService private readonly stateService: IStateService\n\t) {\n\t\tthis.backupHome = environmentMainService.backupHome;\n\t}\n\n\tasync initialize(): Promise<void> {\n\n\t\t// read backup workspaces\n\t\tconst serializedBackupWorkspaces = this.stateService.getItem<ISerializedBackupWorkspaces>(BackupMainService.backupWorkspacesMetadataStorageKey) ?? { workspaces: [], folders: [], emptyWindows: [] };\n\n\t\t// validate empty workspaces backups first\n\t\tthis.emptyWindows = await this.validateEmptyWorkspaces(serializedBackupWorkspaces.emptyWindows);\n\n\t\t// validate workspace backups\n\t\tthis.workspaces = await this.validateWorkspaces(deserializeWorkspaceInfos(serializedBackupWorkspaces));\n\n\t\t// validate folder backups\n\t\tthis.folders = await this.validateFolders(deserializeFolderInfos(serializedBackupWorkspaces));\n\n\t\t// store metadata in case some workspaces or folders have been removed\n\t\tthis.storeWorkspacesMetadata();\n\t}\n\n\tprotected getWorkspaceBackups(): IWorkspaceBackupInfo[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.workspaces.slice(0); // return a copy\n\t}\n\n\tprotected getFolderBackups(): IFolderBackupInfo[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.folders.slice(0); // return a copy\n\t}\n\n\tisHotExitEnabled(): boolean {\n\t\treturn this.getHotExitConfig() !== HotExitConfiguration.OFF;\n\t}\n\n\tprivate isHotExitOnExitAndWindowClose(): boolean {\n\t\treturn this.getHotExitConfig() === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE;\n\t}\n\n\tprivate getHotExitConfig(): string {\n\t\tconst config = this.configurationService.getValue<IFilesConfiguration>();\n\n\t\treturn config?.files?.hotExit || HotExitConfiguration.ON_EXIT;\n\t}\n\n\tgetEmptyWindowBackups(): IEmptyWindowBackupInfo[] {\n\t\treturn this.emptyWindows.slice(0); // return a copy\n\t}\n\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo): string;\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo, migrateFrom: string): Promise<string>;\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo, migrateFrom?: string): string | Promise<string> {\n\t\tif (!this.workspaces.some(workspace => workspaceInfo.workspace.id === workspace.workspace.id)) {\n\t\t\tthis.workspaces.push(workspaceInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\tconst backupPath = join(this.backupHome, workspaceInfo.workspace.id);\n\n\t\tif (migrateFrom) {\n\t\t\treturn this.moveBackupFolder(backupPath, migrateFrom).then(() => backupPath);\n\t\t}\n\n\t\treturn backupPath;\n\t}\n\n\tprivate async moveBackupFolder(backupPath: string, moveFromPath: string): Promise<void> {\n\n\t\t// Target exists: make sure to convert existing backups to empty window backups\n\t\tif (await Promises.exists(backupPath)) {\n\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t}\n\n\t\t// When we have data to migrate from, move it over to the target location\n\t\tif (await Promises.exists(moveFromPath)) {\n\t\t\ttry {\n\t\t\t\tawait Promises.rename(moveFromPath, backupPath, false /* no retry */);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`Backup: Could not move backup folder to new location: ${error.toString()}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterFolderBackup(folderInfo: IFolderBackupInfo): string {\n\t\tif (!this.folders.some(folder => this.backupUriComparer.isEqual(folderInfo.folderUri, folder.folderUri))) {\n\t\t\tthis.folders.push(folderInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\treturn join(this.backupHome, this.getFolderHash(folderInfo));\n\t}\n\n\tregisterEmptyWindowBackup(emptyWindowInfo: IEmptyWindowBackupInfo): string {\n\t\tif (!this.emptyWindows.some(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, emptyWindowInfo.backupFolder))) {\n\t\t\tthis.emptyWindows.push(emptyWindowInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\treturn join(this.backupHome, emptyWindowInfo.backupFolder);\n\t}\n\n\tprivate async validateWorkspaces(rootWorkspaces: IWorkspaceBackupInfo[]): Promise<IWorkspaceBackupInfo[]> {\n\t\tif (!Array.isArray(rootWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst seenIds: Set<string> = new Set();\n\t\tconst result: IWorkspaceBackupInfo[] = [];\n\n\t\t// Validate Workspaces\n\t\tfor (const workspaceInfo of rootWorkspaces) {\n\t\t\tconst workspace = workspaceInfo.workspace;\n\t\t\tif (!isWorkspaceIdentifier(workspace)) {\n\t\t\t\treturn []; // wrong format, skip all entries\n\t\t\t}\n\n\t\t\tif (!seenIds.has(workspace.id)) {\n\t\t\t\tseenIds.add(workspace.id);\n\n\t\t\t\tconst backupPath = join(this.backupHome, workspace.id);\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the workspace has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (workspace.configPath.scheme !== Schemas.file || await Promises.exists(workspace.configPath.fsPath)) {\n\t\t\t\t\t\tresult.push(workspaceInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the workspace has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateFolders(folderWorkspaces: IFolderBackupInfo[]): Promise<IFolderBackupInfo[]> {\n\t\tif (!Array.isArray(folderWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IFolderBackupInfo[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\t\tfor (const folderInfo of folderWorkspaces) {\n\t\t\tconst folderURI = folderInfo.folderUri;\n\t\t\tconst key = this.backupUriComparer.getComparisonKey(folderURI);\n\t\t\tif (!seenIds.has(key)) {\n\t\t\t\tseenIds.add(key);\n\n\t\t\t\tconst backupPath = join(this.backupHome, this.getFolderHash(folderInfo));\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the folder has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (folderURI.scheme !== Schemas.file || await Promises.exists(folderURI.fsPath)) {\n\t\t\t\t\t\tresult.push(folderInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the folder has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateEmptyWorkspaces(emptyWorkspaces: IEmptyWindowBackupInfo[]): Promise<IEmptyWindowBackupInfo[]> {\n\t\tif (!Array.isArray(emptyWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IEmptyWindowBackupInfo[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\n\t\t// Validate Empty Windows\n\t\tfor (const backupInfo of emptyWorkspaces) {\n\t\t\tconst backupFolder = backupInfo.backupFolder;\n\t\t\tif (typeof backupFolder !== 'string') {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tif (!seenIds.has(backupFolder)) {\n\t\t\t\tseenIds.add(backupFolder);\n\n\t\t\t\tconst backupPath = join(this.backupHome, backupFolder);\n\t\t\t\tif (await this.doHasBackups(backupPath)) {\n\t\t\t\t\tresult.push(backupInfo);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async deleteStaleBackup(backupPath: string): Promise<void> {\n\t\ttry {\n\t\t\tawait Promises.rm(backupPath, RimRafMode.MOVE);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not delete stale backup: ${error.toString()}`);\n\t\t}\n\t}\n\n\tprivate prepareNewEmptyWindowBackup(): IEmptyWindowBackupInfo {\n\n\t\t// We are asked to prepare a new empty window backup folder.\n\t\t// Empty windows backup folders are derived from a workspace\n\t\t// identifier, so we generate a new empty workspace identifier\n\t\t// until we found a unique one.\n\n\t\tlet emptyWorkspaceIdentifier = createEmptyWorkspaceIdentifier();\n\t\twhile (this.emptyWindows.some(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, emptyWorkspaceIdentifier.id))) {\n\t\t\temptyWorkspaceIdentifier = createEmptyWorkspaceIdentifier();\n\t\t}\n\n\t\treturn { backupFolder: emptyWorkspaceIdentifier.id };\n\t}\n\n\tprivate async convertToEmptyWindowBackup(backupPath: string): Promise<boolean> {\n\t\tconst newEmptyWindowBackupInfo = this.prepareNewEmptyWindowBackup();\n\n\t\t// Rename backupPath to new empty window backup path\n\t\tconst newEmptyWindowBackupPath = join(this.backupHome, newEmptyWindowBackupInfo.backupFolder);\n\t\ttry {\n\t\t\tawait Promises.rename(backupPath, newEmptyWindowBackupPath, false /* no retry */);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not rename backup folder: ${error.toString()}`);\n\t\t\treturn false;\n\t\t}\n\t\tthis.emptyWindows.push(newEmptyWindowBackupInfo);\n\n\t\treturn true;\n\t}\n\n\tasync getDirtyWorkspaces(): Promise<Array<IWorkspaceBackupInfo | IFolderBackupInfo>> {\n\t\tconst dirtyWorkspaces: Array<IWorkspaceBackupInfo | IFolderBackupInfo> = [];\n\n\t\t// Workspaces with backups\n\t\tfor (const workspace of this.workspaces) {\n\t\t\tif ((await this.hasBackups(workspace))) {\n\t\t\t\tdirtyWorkspaces.push(workspace);\n\t\t\t}\n\t\t}\n\n\t\t// Folders with backups\n\t\tfor (const folder of this.folders) {\n\t\t\tif ((await this.hasBackups(folder))) {\n\t\t\t\tdirtyWorkspaces.push(folder);\n\t\t\t}\n\t\t}\n\n\t\treturn dirtyWorkspaces;\n\t}\n\n\tprivate hasBackups(backupLocation: IWorkspaceBackupInfo | IEmptyWindowBackupInfo | IFolderBackupInfo): Promise<boolean> {\n\t\tlet backupPath: string;\n\n\t\t// Empty\n\t\tif (isEmptyWindowBackupInfo(backupLocation)) {\n\t\t\tbackupPath = join(this.backupHome, backupLocation.backupFolder);\n\t\t}\n\n\t\t// Folder\n\t\telse if (isFolderBackupInfo(backupLocation)) {\n\t\t\tbackupPath = join(this.backupHome, this.getFolderHash(backupLocation));\n\t\t}\n\n\t\t// Workspace\n\t\telse {\n\t\t\tbackupPath = join(this.backupHome, backupLocation.workspace.id);\n\t\t}\n\n\t\treturn this.doHasBackups(backupPath);\n\t}\n\n\tprivate async doHasBackups(backupPath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst backupSchemas = await Promises.readdir(backupPath);\n\n\t\t\tfor (const backupSchema of backupSchemas) {\n\t\t\t\ttry {\n\t\t\t\t\tconst backupSchemaChildren = await Promises.readdir(join(backupPath, backupSchema));\n\t\t\t\t\tif (backupSchemaChildren.length > 0) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// invalid folder\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\t// backup path does not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\n\tprivate storeWorkspacesMetadata(): void {\n\t\tconst serializedBackupWorkspaces: ISerializedBackupWorkspaces = {\n\t\t\tworkspaces: this.workspaces.map(({ workspace, remoteAuthority }) => {\n\t\t\t\tconst serializedWorkspaceBackupInfo: ISerializedWorkspaceBackupInfo = {\n\t\t\t\t\tid: workspace.id,\n\t\t\t\t\tconfigURIPath: workspace.configPath.toString()\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedWorkspaceBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedWorkspaceBackupInfo;\n\t\t\t}),\n\t\t\tfolders: this.folders.map(({ folderUri, remoteAuthority }) => {\n\t\t\t\tconst serializedFolderBackupInfo: ISerializedFolderBackupInfo =\n\t\t\t\t{\n\t\t\t\t\tfolderUri: folderUri.toString()\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedFolderBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedFolderBackupInfo;\n\t\t\t}),\n\t\t\temptyWindows: this.emptyWindows.map(({ backupFolder, remoteAuthority }) => {\n\t\t\t\tconst serializedEmptyWindowBackupInfo: ISerializedEmptyWindowBackupInfo = {\n\t\t\t\t\tbackupFolder\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedEmptyWindowBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedEmptyWindowBackupInfo;\n\t\t\t})\n\t\t};\n\n\t\tthis.stateService.setItem(BackupMainService.backupWorkspacesMetadataStorageKey, serializedBackupWorkspaces);\n\t}\n\n\tprotected getFolderHash(folder: IFolderBackupInfo): string {\n\t\tconst folderUri = folder.folderUri;\n\n\t\tlet key: string;\n\t\tif (folderUri.scheme === Schemas.file) {\n\t\t\tkey = isLinux ? folderUri.fsPath : folderUri.fsPath.toLowerCase(); // for backward compatibility, use the fspath as key\n\t\t} else {\n\t\t\tkey = folderUri.toString().toLowerCase();\n\t\t}\n\n\t\treturn createHash('md5').update(key).digest('hex'); // CodeQL [SM04514] Using MD5 to convert a file path to a fixed length\n\t}\n}\n"]}