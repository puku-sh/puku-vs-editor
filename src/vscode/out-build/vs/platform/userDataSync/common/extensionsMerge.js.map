{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/userDataSync/common/extensionsMerge.ts","vs/platform/userDataSync/common/extensionsMerge.ts"],"names":[],"mappings":"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","file":"extensionsMerge.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport { deepClone, equals } from '../../../base/common/objects.js';\nimport * as semver from '../../../base/common/semver/semver.js';\nimport { assertReturnsDefined } from '../../../base/common/types.js';\nimport { IExtensionIdentifier } from '../../extensions/common/extensions.js';\nimport { ILocalSyncExtension, IRemoteSyncExtension, ISyncExtension } from './userDataSync.js';\n\nexport interface IMergeResult {\n\treadonly local: { added: ISyncExtension[]; removed: IExtensionIdentifier[]; updated: ISyncExtension[] };\n\treadonly remote: { added: ISyncExtension[]; removed: ISyncExtension[]; updated: ISyncExtension[]; all: ISyncExtension[] } | null;\n}\n\nexport function merge(localExtensions: ILocalSyncExtension[], remoteExtensions: IRemoteSyncExtension[] | null, lastSyncExtensions: IRemoteSyncExtension[] | null, skippedExtensions: ISyncExtension[], ignoredExtensions: string[], lastSyncBuiltinExtensions: IExtensionIdentifier[] | null): IMergeResult {\n\tconst added: ISyncExtension[] = [];\n\tconst removed: IExtensionIdentifier[] = [];\n\tconst updated: ISyncExtension[] = [];\n\n\tif (!remoteExtensions) {\n\t\tconst remote = localExtensions.filter(({ identifier }) => ignoredExtensions.every(id => id.toLowerCase() !== identifier.id.toLowerCase()));\n\t\treturn {\n\t\t\tlocal: {\n\t\t\t\tadded,\n\t\t\t\tremoved,\n\t\t\t\tupdated,\n\t\t\t},\n\t\t\tremote: remote.length > 0 ? {\n\t\t\t\tadded: remote,\n\t\t\t\tupdated: [],\n\t\t\t\tremoved: [],\n\t\t\t\tall: remote\n\t\t\t} : null\n\t\t};\n\t}\n\n\tlocalExtensions = localExtensions.map(massageIncomingExtension) as ILocalSyncExtension[];\n\tremoteExtensions = remoteExtensions.map(massageIncomingExtension);\n\tlastSyncExtensions = lastSyncExtensions ? lastSyncExtensions.map(massageIncomingExtension) : null;\n\n\tconst uuids: Map<string, string> = new Map<string, string>();\n\tconst addUUID = (identifier: IExtensionIdentifier) => { if (identifier.uuid) { uuids.set(identifier.id.toLowerCase(), identifier.uuid); } };\n\tlocalExtensions.forEach(({ identifier }) => addUUID(identifier));\n\tremoteExtensions.forEach(({ identifier }) => addUUID(identifier));\n\tlastSyncExtensions?.forEach(({ identifier }) => addUUID(identifier));\n\tskippedExtensions?.forEach(({ identifier }) => addUUID(identifier));\n\tlastSyncBuiltinExtensions?.forEach(identifier => addUUID(identifier));\n\n\tconst getKey = (extension: ISyncExtension): string => {\n\t\tconst uuid = extension.identifier.uuid || uuids.get(extension.identifier.id.toLowerCase());\n\t\treturn uuid ? `uuid:${uuid}` : `id:${extension.identifier.id.toLowerCase()}`;\n\t};\n\tconst addExtensionToMap = (map: Map<string, ISyncExtension>, extension: ISyncExtension) => {\n\t\tmap.set(getKey(extension), extension);\n\t\treturn map;\n\t};\n\tconst localExtensionsMap: Map<string, ISyncExtension> = localExtensions.reduce(addExtensionToMap, new Map<string, ISyncExtension>());\n\tconst remoteExtensionsMap = remoteExtensions.reduce(addExtensionToMap, new Map<string, ISyncExtension>());\n\tconst newRemoteExtensionsMap = remoteExtensions.reduce((map: Map<string, ISyncExtension>, extension: ISyncExtension) => addExtensionToMap(map, deepClone(extension)), new Map<string, ISyncExtension>());\n\tconst lastSyncExtensionsMap = lastSyncExtensions ? lastSyncExtensions.reduce(addExtensionToMap, new Map<string, ISyncExtension>()) : null;\n\tconst skippedExtensionsMap = skippedExtensions.reduce(addExtensionToMap, new Map<string, ISyncExtension>());\n\tconst ignoredExtensionsSet = ignoredExtensions.reduce((set, id) => {\n\t\tconst uuid = uuids.get(id.toLowerCase());\n\t\treturn set.add(uuid ? `uuid:${uuid}` : `id:${id.toLowerCase()}`);\n\t}, new Set<string>());\n\tconst lastSyncBuiltinExtensionsSet = lastSyncBuiltinExtensions ? lastSyncBuiltinExtensions.reduce((set, { id, uuid }) => {\n\t\tuuid = uuid ?? uuids.get(id.toLowerCase());\n\t\treturn set.add(uuid ? `uuid:${uuid}` : `id:${id.toLowerCase()}`);\n\t}, new Set<string>()) : null;\n\n\tconst localToRemote = compare(localExtensionsMap, remoteExtensionsMap, ignoredExtensionsSet, false);\n\tif (localToRemote.added.size > 0 || localToRemote.removed.size > 0 || localToRemote.updated.size > 0) {\n\n\t\tconst baseToLocal = compare(lastSyncExtensionsMap, localExtensionsMap, ignoredExtensionsSet, false);\n\t\tconst baseToRemote = compare(lastSyncExtensionsMap, remoteExtensionsMap, ignoredExtensionsSet, true);\n\n\t\tconst merge = (key: string, localExtension: ISyncExtension, remoteExtension: ISyncExtension, preferred: ISyncExtension): ISyncExtension => {\n\t\t\tlet pinned: boolean | undefined, version: string | undefined, preRelease: boolean | undefined;\n\t\t\tif (localExtension.installed) {\n\t\t\t\tpinned = preferred.pinned;\n\t\t\t\tpreRelease = preferred.preRelease;\n\t\t\t\tif (pinned) {\n\t\t\t\t\tversion = preferred.version;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpinned = remoteExtension.pinned;\n\t\t\t\tpreRelease = remoteExtension.preRelease;\n\t\t\t\tif (pinned) {\n\t\t\t\t\tversion = remoteExtension.version;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pinned === undefined /* from older client*/) {\n\t\t\t\tpinned = localExtension.pinned;\n\t\t\t\tif (pinned) {\n\t\t\t\t\tversion = localExtension.version;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (preRelease === undefined /* from older client*/) {\n\t\t\t\tpreRelease = localExtension.preRelease;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...preferred,\n\t\t\t\tinstalled: localExtension.installed || remoteExtension.installed,\n\t\t\t\tpinned,\n\t\t\t\tpreRelease,\n\t\t\t\tversion: version ?? (remoteExtension.version && (!localExtension.installed || semver.gt(remoteExtension.version, localExtension.version)) ? remoteExtension.version : localExtension.version),\n\t\t\t\tstate: mergeExtensionState(localExtension, remoteExtension, lastSyncExtensionsMap?.get(key)),\n\t\t\t};\n\t\t};\n\n\t\t// Remotely removed extension => exist in base and does not in remote\n\t\tfor (const key of baseToRemote.removed.values()) {\n\t\t\tconst localExtension = localExtensionsMap.get(key);\n\t\t\tif (!localExtension) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst baseExtension = assertReturnsDefined(lastSyncExtensionsMap?.get(key));\n\t\t\tconst wasAnInstalledExtensionDuringLastSync = lastSyncBuiltinExtensionsSet && !lastSyncBuiltinExtensionsSet.has(key) && baseExtension.installed;\n\t\t\tif (localExtension.installed && wasAnInstalledExtensionDuringLastSync /* It is an installed extension now and during last sync */) {\n\t\t\t\t// Installed extension is removed from remote. Remove it from local.\n\t\t\t\tremoved.push(localExtension.identifier);\n\t\t\t} else {\n\t\t\t\t// Add to remote: It is a builtin extenision or got installed after last sync\n\t\t\t\tnewRemoteExtensionsMap.set(key, localExtension);\n\t\t\t}\n\n\t\t}\n\n\t\t// Remotely added extension => does not exist in base and exist in remote\n\t\tfor (const key of baseToRemote.added.values()) {\n\t\t\tconst remoteExtension = assertReturnsDefined(remoteExtensionsMap.get(key));\n\t\t\tconst localExtension = localExtensionsMap.get(key);\n\n\t\t\t// Also exist in local\n\t\t\tif (localExtension) {\n\t\t\t\t// Is different from local to remote\n\t\t\t\tif (localToRemote.updated.has(key)) {\n\t\t\t\t\tconst mergedExtension = merge(key, localExtension, remoteExtension, remoteExtension);\n\t\t\t\t\t// Update locally only when the extension has changes in properties other than installed poperty\n\t\t\t\t\tif (!areSame(localExtension, remoteExtension, false, false)) {\n\t\t\t\t\t\tupdated.push(massageOutgoingExtension(mergedExtension, key));\n\t\t\t\t\t}\n\t\t\t\t\tnewRemoteExtensionsMap.set(key, mergedExtension);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Add only if the extension is an installed extension\n\t\t\t\tif (remoteExtension.installed) {\n\t\t\t\t\tadded.push(massageOutgoingExtension(remoteExtension, key));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remotely updated extension => exist in base and remote\n\t\tfor (const key of baseToRemote.updated.values()) {\n\t\t\tconst remoteExtension = assertReturnsDefined(remoteExtensionsMap.get(key));\n\t\t\tconst baseExtension = assertReturnsDefined(lastSyncExtensionsMap?.get(key));\n\t\t\tconst localExtension = localExtensionsMap.get(key);\n\n\t\t\t// Also exist in local\n\t\t\tif (localExtension) {\n\t\t\t\tconst wasAnInstalledExtensionDuringLastSync = lastSyncBuiltinExtensionsSet && !lastSyncBuiltinExtensionsSet.has(key) && baseExtension.installed;\n\t\t\t\tif (wasAnInstalledExtensionDuringLastSync && localExtension.installed && !remoteExtension.installed) {\n\t\t\t\t\t// Remove it locally if it is installed locally and not remotely\n\t\t\t\t\tremoved.push(localExtension.identifier);\n\t\t\t\t} else {\n\t\t\t\t\t// Update in local always\n\t\t\t\t\tconst mergedExtension = merge(key, localExtension, remoteExtension, remoteExtension);\n\t\t\t\t\tupdated.push(massageOutgoingExtension(mergedExtension, key));\n\t\t\t\t\tnewRemoteExtensionsMap.set(key, mergedExtension);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Add it locally if does not exist locally and installed remotely\n\t\t\telse if (remoteExtension.installed) {\n\t\t\t\tadded.push(massageOutgoingExtension(remoteExtension, key));\n\t\t\t}\n\n\t\t}\n\n\t\t// Locally added extension => does not exist in base and exist in local\n\t\tfor (const key of baseToLocal.added.values()) {\n\t\t\t// If added in remote (already handled)\n\t\t\tif (baseToRemote.added.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnewRemoteExtensionsMap.set(key, assertReturnsDefined(localExtensionsMap.get(key)));\n\t\t}\n\n\t\t// Locally updated extension => exist in base and local\n\t\tfor (const key of baseToLocal.updated.values()) {\n\t\t\t// If removed in remote (already handled)\n\t\t\tif (baseToRemote.removed.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// If updated in remote (already handled)\n\t\t\tif (baseToRemote.updated.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst localExtension = assertReturnsDefined(localExtensionsMap.get(key));\n\t\t\tconst remoteExtension = assertReturnsDefined(remoteExtensionsMap.get(key));\n\t\t\t// Update remotely\n\t\t\tnewRemoteExtensionsMap.set(key, merge(key, localExtension, remoteExtension, localExtension));\n\t\t}\n\n\t\t// Locally removed extensions => exist in base and does not exist in local\n\t\tfor (const key of baseToLocal.removed.values()) {\n\t\t\t// If updated in remote (already handled)\n\t\t\tif (baseToRemote.updated.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// If removed in remote (already handled)\n\t\t\tif (baseToRemote.removed.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Skipped\n\t\t\tif (skippedExtensionsMap.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Skip if it is a builtin extension\n\t\t\tif (!assertReturnsDefined(remoteExtensionsMap.get(key)).installed) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Skip if last sync builtin extensions set is not available\n\t\t\tif (!lastSyncBuiltinExtensionsSet) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Skip if it was a builtin extension during last sync\n\t\t\tif (lastSyncBuiltinExtensionsSet.has(key) || !assertReturnsDefined(lastSyncExtensionsMap?.get(key)).installed) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnewRemoteExtensionsMap.delete(key);\n\t\t}\n\t}\n\n\tconst remote: ISyncExtension[] = [];\n\tconst remoteChanges = compare(remoteExtensionsMap, newRemoteExtensionsMap, new Set<string>(), true);\n\tconst hasRemoteChanges = remoteChanges.added.size > 0 || remoteChanges.updated.size > 0 || remoteChanges.removed.size > 0;\n\tif (hasRemoteChanges) {\n\t\tnewRemoteExtensionsMap.forEach((value, key) => remote.push(massageOutgoingExtension(value, key)));\n\t}\n\n\treturn {\n\t\tlocal: { added, removed, updated },\n\t\tremote: hasRemoteChanges ? {\n\t\t\tadded: [...remoteChanges.added].map(id => newRemoteExtensionsMap.get(id)!),\n\t\t\tupdated: [...remoteChanges.updated].map(id => newRemoteExtensionsMap.get(id)!),\n\t\t\tremoved: [...remoteChanges.removed].map(id => remoteExtensionsMap.get(id)!),\n\t\t\tall: remote\n\t\t} : null\n\t};\n}\n\nfunction compare(from: Map<string, ISyncExtension> | null, to: Map<string, ISyncExtension>, ignoredExtensions: Set<string>, checkVersionProperty: boolean): { added: Set<string>; removed: Set<string>; updated: Set<string> } {\n\tconst fromKeys = from ? [...from.keys()].filter(key => !ignoredExtensions.has(key)) : [];\n\tconst toKeys = [...to.keys()].filter(key => !ignoredExtensions.has(key));\n\tconst added = toKeys.filter(key => !fromKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst removed = fromKeys.filter(key => !toKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst updated: Set<string> = new Set<string>();\n\n\tfor (const key of fromKeys) {\n\t\tif (removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst fromExtension = from!.get(key)!;\n\t\tconst toExtension = to.get(key);\n\t\tif (!toExtension || !areSame(fromExtension, toExtension, checkVersionProperty, true)) {\n\t\t\tupdated.add(key);\n\t\t}\n\t}\n\n\treturn { added, removed, updated };\n}\n\nfunction areSame(fromExtension: ISyncExtension, toExtension: ISyncExtension, checkVersionProperty: boolean, checkInstalledProperty: boolean): boolean {\n\tif (fromExtension.disabled !== toExtension.disabled) {\n\t\t/* extension enablement changed */\n\t\treturn false;\n\t}\n\n\tif (!!fromExtension.isApplicationScoped !== !!toExtension.isApplicationScoped) {\n\t\t/* extension application scope has changed */\n\t\treturn false;\n\t}\n\n\tif (checkInstalledProperty && fromExtension.installed !== toExtension.installed) {\n\t\t/* extension installed property changed */\n\t\treturn false;\n\t}\n\n\tif (fromExtension.installed && toExtension.installed) {\n\n\t\tif (fromExtension.preRelease !== toExtension.preRelease) {\n\t\t\t/* installed extension's pre-release version changed */\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fromExtension.pinned !== toExtension.pinned) {\n\t\t\t/* installed extension's pinning changed */\n\t\t\treturn false;\n\t\t}\n\n\t\tif (toExtension.pinned && fromExtension.version !== toExtension.version) {\n\t\t\t/* installed extension's pinned version changed */\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!isSameExtensionState(fromExtension.state, toExtension.state)) {\n\t\t/* extension state changed */\n\t\treturn false;\n\t}\n\n\tif ((checkVersionProperty && fromExtension.version !== toExtension.version)) {\n\t\t/* extension version changed */\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nfunction mergeExtensionState(localExtension: ISyncExtension, remoteExtension: ISyncExtension, lastSyncExtension: ISyncExtension | undefined): IStringDictionary<any> | undefined {\n\tconst localState = localExtension.state;\n\tconst remoteState = remoteExtension.state;\n\tconst baseState = lastSyncExtension?.state;\n\n\t// If remote extension has no version, use local state\n\tif (!remoteExtension.version) {\n\t\treturn localState;\n\t}\n\n\t// If local state exists and local extension is latest then use local state\n\tif (localState && semver.gt(localExtension.version, remoteExtension.version)) {\n\t\treturn localState;\n\t}\n\t// If remote state exists and remote extension is latest, use remote state\n\tif (remoteState && semver.gt(remoteExtension.version, localExtension.version)) {\n\t\treturn remoteState;\n\t}\n\n\n\t/* Remote and local are on same version */\n\n\t// If local state is not yet set, use remote state\n\tif (!localState) {\n\t\treturn remoteState;\n\t}\n\t// If remote state is not yet set, use local state\n\tif (!remoteState) {\n\t\treturn localState;\n\t}\n\n\tconst mergedState: IStringDictionary<any> = deepClone(localState);\n\tconst baseToRemote = baseState ? compareExtensionState(baseState, remoteState) : { added: Object.keys(remoteState).reduce((r, k) => { r.add(k); return r; }, new Set<string>()), removed: new Set<string>(), updated: new Set<string>() };\n\tconst baseToLocal = baseState ? compareExtensionState(baseState, localState) : { added: Object.keys(localState).reduce((r, k) => { r.add(k); return r; }, new Set<string>()), removed: new Set<string>(), updated: new Set<string>() };\n\t// Added/Updated in remote\n\tfor (const key of [...baseToRemote.added.values(), ...baseToRemote.updated.values()]) {\n\t\tmergedState[key] = remoteState[key];\n\t}\n\t// Removed in remote\n\tfor (const key of baseToRemote.removed.values()) {\n\t\t// Not updated in local\n\t\tif (!baseToLocal.updated.has(key)) {\n\t\t\tdelete mergedState[key];\n\t\t}\n\t}\n\treturn mergedState;\n}\n\nfunction compareExtensionState(from: IStringDictionary<any>, to: IStringDictionary<any>): { added: Set<string>; removed: Set<string>; updated: Set<string> } {\n\tconst fromKeys = Object.keys(from);\n\tconst toKeys = Object.keys(to);\n\tconst added = toKeys.filter(key => !fromKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst removed = fromKeys.filter(key => !toKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst updated: Set<string> = new Set<string>();\n\n\tfor (const key of fromKeys) {\n\t\tif (removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst value1 = from[key];\n\t\tconst value2 = to[key];\n\t\tif (!equals(value1, value2)) {\n\t\t\tupdated.add(key);\n\t\t}\n\t}\n\n\treturn { added, removed, updated };\n}\n\nfunction isSameExtensionState(a: IStringDictionary<any> = {}, b: IStringDictionary<any> = {}): boolean {\n\tconst { added, removed, updated } = compareExtensionState(a, b);\n\treturn added.size === 0 && removed.size === 0 && updated.size === 0;\n}\n\n// massage incoming extension - add optional properties\nfunction massageIncomingExtension(extension: ISyncExtension): ISyncExtension {\n\treturn { ...extension, ...{ disabled: !!extension.disabled, installed: !!extension.installed } };\n}\n\n// massage outgoing extension - remove optional properties\nfunction massageOutgoingExtension(extension: ISyncExtension, key: string): ISyncExtension {\n\tconst massagedExtension: ISyncExtension = {\n\t\t...extension,\n\t\tidentifier: {\n\t\t\tid: extension.identifier.id,\n\t\t\tuuid: key.startsWith('uuid:') ? key.substring('uuid:'.length) : undefined\n\t\t},\n\t\t/* set following always so that to differentiate with older clients */\n\t\tpreRelease: !!extension.preRelease,\n\t\tpinned: !!extension.pinned,\n\t};\n\tif (!extension.disabled) {\n\t\tdelete massagedExtension.disabled;\n\t}\n\tif (!extension.installed) {\n\t\tdelete massagedExtension.installed;\n\t}\n\tif (!extension.state) {\n\t\tdelete massagedExtension.state;\n\t}\n\tif (!extension.isApplicationScoped) {\n\t\tdelete massagedExtension.isApplicationScoped;\n\t}\n\treturn massagedExtension;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport { deepClone, equals } from '../../../base/common/objects.js';\nimport * as semver from '../../../base/common/semver/semver.js';\nimport { assertReturnsDefined } from '../../../base/common/types.js';\nimport { IExtensionIdentifier } from '../../extensions/common/extensions.js';\nimport { ILocalSyncExtension, IRemoteSyncExtension, ISyncExtension } from './userDataSync.js';\n\nexport interface IMergeResult {\n\treadonly local: { added: ISyncExtension[]; removed: IExtensionIdentifier[]; updated: ISyncExtension[] };\n\treadonly remote: { added: ISyncExtension[]; removed: ISyncExtension[]; updated: ISyncExtension[]; all: ISyncExtension[] } | null;\n}\n\nexport function merge(localExtensions: ILocalSyncExtension[], remoteExtensions: IRemoteSyncExtension[] | null, lastSyncExtensions: IRemoteSyncExtension[] | null, skippedExtensions: ISyncExtension[], ignoredExtensions: string[], lastSyncBuiltinExtensions: IExtensionIdentifier[] | null): IMergeResult {\n\tconst added: ISyncExtension[] = [];\n\tconst removed: IExtensionIdentifier[] = [];\n\tconst updated: ISyncExtension[] = [];\n\n\tif (!remoteExtensions) {\n\t\tconst remote = localExtensions.filter(({ identifier }) => ignoredExtensions.every(id => id.toLowerCase() !== identifier.id.toLowerCase()));\n\t\treturn {\n\t\t\tlocal: {\n\t\t\t\tadded,\n\t\t\t\tremoved,\n\t\t\t\tupdated,\n\t\t\t},\n\t\t\tremote: remote.length > 0 ? {\n\t\t\t\tadded: remote,\n\t\t\t\tupdated: [],\n\t\t\t\tremoved: [],\n\t\t\t\tall: remote\n\t\t\t} : null\n\t\t};\n\t}\n\n\tlocalExtensions = localExtensions.map(massageIncomingExtension) as ILocalSyncExtension[];\n\tremoteExtensions = remoteExtensions.map(massageIncomingExtension);\n\tlastSyncExtensions = lastSyncExtensions ? lastSyncExtensions.map(massageIncomingExtension) : null;\n\n\tconst uuids: Map<string, string> = new Map<string, string>();\n\tconst addUUID = (identifier: IExtensionIdentifier) => { if (identifier.uuid) { uuids.set(identifier.id.toLowerCase(), identifier.uuid); } };\n\tlocalExtensions.forEach(({ identifier }) => addUUID(identifier));\n\tremoteExtensions.forEach(({ identifier }) => addUUID(identifier));\n\tlastSyncExtensions?.forEach(({ identifier }) => addUUID(identifier));\n\tskippedExtensions?.forEach(({ identifier }) => addUUID(identifier));\n\tlastSyncBuiltinExtensions?.forEach(identifier => addUUID(identifier));\n\n\tconst getKey = (extension: ISyncExtension): string => {\n\t\tconst uuid = extension.identifier.uuid || uuids.get(extension.identifier.id.toLowerCase());\n\t\treturn uuid ? `uuid:${uuid}` : `id:${extension.identifier.id.toLowerCase()}`;\n\t};\n\tconst addExtensionToMap = (map: Map<string, ISyncExtension>, extension: ISyncExtension) => {\n\t\tmap.set(getKey(extension), extension);\n\t\treturn map;\n\t};\n\tconst localExtensionsMap: Map<string, ISyncExtension> = localExtensions.reduce(addExtensionToMap, new Map<string, ISyncExtension>());\n\tconst remoteExtensionsMap = remoteExtensions.reduce(addExtensionToMap, new Map<string, ISyncExtension>());\n\tconst newRemoteExtensionsMap = remoteExtensions.reduce((map: Map<string, ISyncExtension>, extension: ISyncExtension) => addExtensionToMap(map, deepClone(extension)), new Map<string, ISyncExtension>());\n\tconst lastSyncExtensionsMap = lastSyncExtensions ? lastSyncExtensions.reduce(addExtensionToMap, new Map<string, ISyncExtension>()) : null;\n\tconst skippedExtensionsMap = skippedExtensions.reduce(addExtensionToMap, new Map<string, ISyncExtension>());\n\tconst ignoredExtensionsSet = ignoredExtensions.reduce((set, id) => {\n\t\tconst uuid = uuids.get(id.toLowerCase());\n\t\treturn set.add(uuid ? `uuid:${uuid}` : `id:${id.toLowerCase()}`);\n\t}, new Set<string>());\n\tconst lastSyncBuiltinExtensionsSet = lastSyncBuiltinExtensions ? lastSyncBuiltinExtensions.reduce((set, { id, uuid }) => {\n\t\tuuid = uuid ?? uuids.get(id.toLowerCase());\n\t\treturn set.add(uuid ? `uuid:${uuid}` : `id:${id.toLowerCase()}`);\n\t}, new Set<string>()) : null;\n\n\tconst localToRemote = compare(localExtensionsMap, remoteExtensionsMap, ignoredExtensionsSet, false);\n\tif (localToRemote.added.size > 0 || localToRemote.removed.size > 0 || localToRemote.updated.size > 0) {\n\n\t\tconst baseToLocal = compare(lastSyncExtensionsMap, localExtensionsMap, ignoredExtensionsSet, false);\n\t\tconst baseToRemote = compare(lastSyncExtensionsMap, remoteExtensionsMap, ignoredExtensionsSet, true);\n\n\t\tconst merge = (key: string, localExtension: ISyncExtension, remoteExtension: ISyncExtension, preferred: ISyncExtension): ISyncExtension => {\n\t\t\tlet pinned: boolean | undefined, version: string | undefined, preRelease: boolean | undefined;\n\t\t\tif (localExtension.installed) {\n\t\t\t\tpinned = preferred.pinned;\n\t\t\t\tpreRelease = preferred.preRelease;\n\t\t\t\tif (pinned) {\n\t\t\t\t\tversion = preferred.version;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpinned = remoteExtension.pinned;\n\t\t\t\tpreRelease = remoteExtension.preRelease;\n\t\t\t\tif (pinned) {\n\t\t\t\t\tversion = remoteExtension.version;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pinned === undefined /* from older client*/) {\n\t\t\t\tpinned = localExtension.pinned;\n\t\t\t\tif (pinned) {\n\t\t\t\t\tversion = localExtension.version;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (preRelease === undefined /* from older client*/) {\n\t\t\t\tpreRelease = localExtension.preRelease;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...preferred,\n\t\t\t\tinstalled: localExtension.installed || remoteExtension.installed,\n\t\t\t\tpinned,\n\t\t\t\tpreRelease,\n\t\t\t\tversion: version ?? (remoteExtension.version && (!localExtension.installed || semver.gt(remoteExtension.version, localExtension.version)) ? remoteExtension.version : localExtension.version),\n\t\t\t\tstate: mergeExtensionState(localExtension, remoteExtension, lastSyncExtensionsMap?.get(key)),\n\t\t\t};\n\t\t};\n\n\t\t// Remotely removed extension => exist in base and does not in remote\n\t\tfor (const key of baseToRemote.removed.values()) {\n\t\t\tconst localExtension = localExtensionsMap.get(key);\n\t\t\tif (!localExtension) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst baseExtension = assertReturnsDefined(lastSyncExtensionsMap?.get(key));\n\t\t\tconst wasAnInstalledExtensionDuringLastSync = lastSyncBuiltinExtensionsSet && !lastSyncBuiltinExtensionsSet.has(key) && baseExtension.installed;\n\t\t\tif (localExtension.installed && wasAnInstalledExtensionDuringLastSync /* It is an installed extension now and during last sync */) {\n\t\t\t\t// Installed extension is removed from remote. Remove it from local.\n\t\t\t\tremoved.push(localExtension.identifier);\n\t\t\t} else {\n\t\t\t\t// Add to remote: It is a builtin extenision or got installed after last sync\n\t\t\t\tnewRemoteExtensionsMap.set(key, localExtension);\n\t\t\t}\n\n\t\t}\n\n\t\t// Remotely added extension => does not exist in base and exist in remote\n\t\tfor (const key of baseToRemote.added.values()) {\n\t\t\tconst remoteExtension = assertReturnsDefined(remoteExtensionsMap.get(key));\n\t\t\tconst localExtension = localExtensionsMap.get(key);\n\n\t\t\t// Also exist in local\n\t\t\tif (localExtension) {\n\t\t\t\t// Is different from local to remote\n\t\t\t\tif (localToRemote.updated.has(key)) {\n\t\t\t\t\tconst mergedExtension = merge(key, localExtension, remoteExtension, remoteExtension);\n\t\t\t\t\t// Update locally only when the extension has changes in properties other than installed poperty\n\t\t\t\t\tif (!areSame(localExtension, remoteExtension, false, false)) {\n\t\t\t\t\t\tupdated.push(massageOutgoingExtension(mergedExtension, key));\n\t\t\t\t\t}\n\t\t\t\t\tnewRemoteExtensionsMap.set(key, mergedExtension);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Add only if the extension is an installed extension\n\t\t\t\tif (remoteExtension.installed) {\n\t\t\t\t\tadded.push(massageOutgoingExtension(remoteExtension, key));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remotely updated extension => exist in base and remote\n\t\tfor (const key of baseToRemote.updated.values()) {\n\t\t\tconst remoteExtension = assertReturnsDefined(remoteExtensionsMap.get(key));\n\t\t\tconst baseExtension = assertReturnsDefined(lastSyncExtensionsMap?.get(key));\n\t\t\tconst localExtension = localExtensionsMap.get(key);\n\n\t\t\t// Also exist in local\n\t\t\tif (localExtension) {\n\t\t\t\tconst wasAnInstalledExtensionDuringLastSync = lastSyncBuiltinExtensionsSet && !lastSyncBuiltinExtensionsSet.has(key) && baseExtension.installed;\n\t\t\t\tif (wasAnInstalledExtensionDuringLastSync && localExtension.installed && !remoteExtension.installed) {\n\t\t\t\t\t// Remove it locally if it is installed locally and not remotely\n\t\t\t\t\tremoved.push(localExtension.identifier);\n\t\t\t\t} else {\n\t\t\t\t\t// Update in local always\n\t\t\t\t\tconst mergedExtension = merge(key, localExtension, remoteExtension, remoteExtension);\n\t\t\t\t\tupdated.push(massageOutgoingExtension(mergedExtension, key));\n\t\t\t\t\tnewRemoteExtensionsMap.set(key, mergedExtension);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Add it locally if does not exist locally and installed remotely\n\t\t\telse if (remoteExtension.installed) {\n\t\t\t\tadded.push(massageOutgoingExtension(remoteExtension, key));\n\t\t\t}\n\n\t\t}\n\n\t\t// Locally added extension => does not exist in base and exist in local\n\t\tfor (const key of baseToLocal.added.values()) {\n\t\t\t// If added in remote (already handled)\n\t\t\tif (baseToRemote.added.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnewRemoteExtensionsMap.set(key, assertReturnsDefined(localExtensionsMap.get(key)));\n\t\t}\n\n\t\t// Locally updated extension => exist in base and local\n\t\tfor (const key of baseToLocal.updated.values()) {\n\t\t\t// If removed in remote (already handled)\n\t\t\tif (baseToRemote.removed.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// If updated in remote (already handled)\n\t\t\tif (baseToRemote.updated.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst localExtension = assertReturnsDefined(localExtensionsMap.get(key));\n\t\t\tconst remoteExtension = assertReturnsDefined(remoteExtensionsMap.get(key));\n\t\t\t// Update remotely\n\t\t\tnewRemoteExtensionsMap.set(key, merge(key, localExtension, remoteExtension, localExtension));\n\t\t}\n\n\t\t// Locally removed extensions => exist in base and does not exist in local\n\t\tfor (const key of baseToLocal.removed.values()) {\n\t\t\t// If updated in remote (already handled)\n\t\t\tif (baseToRemote.updated.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// If removed in remote (already handled)\n\t\t\tif (baseToRemote.removed.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Skipped\n\t\t\tif (skippedExtensionsMap.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Skip if it is a builtin extension\n\t\t\tif (!assertReturnsDefined(remoteExtensionsMap.get(key)).installed) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Skip if last sync builtin extensions set is not available\n\t\t\tif (!lastSyncBuiltinExtensionsSet) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Skip if it was a builtin extension during last sync\n\t\t\tif (lastSyncBuiltinExtensionsSet.has(key) || !assertReturnsDefined(lastSyncExtensionsMap?.get(key)).installed) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnewRemoteExtensionsMap.delete(key);\n\t\t}\n\t}\n\n\tconst remote: ISyncExtension[] = [];\n\tconst remoteChanges = compare(remoteExtensionsMap, newRemoteExtensionsMap, new Set<string>(), true);\n\tconst hasRemoteChanges = remoteChanges.added.size > 0 || remoteChanges.updated.size > 0 || remoteChanges.removed.size > 0;\n\tif (hasRemoteChanges) {\n\t\tnewRemoteExtensionsMap.forEach((value, key) => remote.push(massageOutgoingExtension(value, key)));\n\t}\n\n\treturn {\n\t\tlocal: { added, removed, updated },\n\t\tremote: hasRemoteChanges ? {\n\t\t\tadded: [...remoteChanges.added].map(id => newRemoteExtensionsMap.get(id)!),\n\t\t\tupdated: [...remoteChanges.updated].map(id => newRemoteExtensionsMap.get(id)!),\n\t\t\tremoved: [...remoteChanges.removed].map(id => remoteExtensionsMap.get(id)!),\n\t\t\tall: remote\n\t\t} : null\n\t};\n}\n\nfunction compare(from: Map<string, ISyncExtension> | null, to: Map<string, ISyncExtension>, ignoredExtensions: Set<string>, checkVersionProperty: boolean): { added: Set<string>; removed: Set<string>; updated: Set<string> } {\n\tconst fromKeys = from ? [...from.keys()].filter(key => !ignoredExtensions.has(key)) : [];\n\tconst toKeys = [...to.keys()].filter(key => !ignoredExtensions.has(key));\n\tconst added = toKeys.filter(key => !fromKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst removed = fromKeys.filter(key => !toKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst updated: Set<string> = new Set<string>();\n\n\tfor (const key of fromKeys) {\n\t\tif (removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst fromExtension = from!.get(key)!;\n\t\tconst toExtension = to.get(key);\n\t\tif (!toExtension || !areSame(fromExtension, toExtension, checkVersionProperty, true)) {\n\t\t\tupdated.add(key);\n\t\t}\n\t}\n\n\treturn { added, removed, updated };\n}\n\nfunction areSame(fromExtension: ISyncExtension, toExtension: ISyncExtension, checkVersionProperty: boolean, checkInstalledProperty: boolean): boolean {\n\tif (fromExtension.disabled !== toExtension.disabled) {\n\t\t/* extension enablement changed */\n\t\treturn false;\n\t}\n\n\tif (!!fromExtension.isApplicationScoped !== !!toExtension.isApplicationScoped) {\n\t\t/* extension application scope has changed */\n\t\treturn false;\n\t}\n\n\tif (checkInstalledProperty && fromExtension.installed !== toExtension.installed) {\n\t\t/* extension installed property changed */\n\t\treturn false;\n\t}\n\n\tif (fromExtension.installed && toExtension.installed) {\n\n\t\tif (fromExtension.preRelease !== toExtension.preRelease) {\n\t\t\t/* installed extension's pre-release version changed */\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fromExtension.pinned !== toExtension.pinned) {\n\t\t\t/* installed extension's pinning changed */\n\t\t\treturn false;\n\t\t}\n\n\t\tif (toExtension.pinned && fromExtension.version !== toExtension.version) {\n\t\t\t/* installed extension's pinned version changed */\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!isSameExtensionState(fromExtension.state, toExtension.state)) {\n\t\t/* extension state changed */\n\t\treturn false;\n\t}\n\n\tif ((checkVersionProperty && fromExtension.version !== toExtension.version)) {\n\t\t/* extension version changed */\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nfunction mergeExtensionState(localExtension: ISyncExtension, remoteExtension: ISyncExtension, lastSyncExtension: ISyncExtension | undefined): IStringDictionary<any> | undefined {\n\tconst localState = localExtension.state;\n\tconst remoteState = remoteExtension.state;\n\tconst baseState = lastSyncExtension?.state;\n\n\t// If remote extension has no version, use local state\n\tif (!remoteExtension.version) {\n\t\treturn localState;\n\t}\n\n\t// If local state exists and local extension is latest then use local state\n\tif (localState && semver.gt(localExtension.version, remoteExtension.version)) {\n\t\treturn localState;\n\t}\n\t// If remote state exists and remote extension is latest, use remote state\n\tif (remoteState && semver.gt(remoteExtension.version, localExtension.version)) {\n\t\treturn remoteState;\n\t}\n\n\n\t/* Remote and local are on same version */\n\n\t// If local state is not yet set, use remote state\n\tif (!localState) {\n\t\treturn remoteState;\n\t}\n\t// If remote state is not yet set, use local state\n\tif (!remoteState) {\n\t\treturn localState;\n\t}\n\n\tconst mergedState: IStringDictionary<any> = deepClone(localState);\n\tconst baseToRemote = baseState ? compareExtensionState(baseState, remoteState) : { added: Object.keys(remoteState).reduce((r, k) => { r.add(k); return r; }, new Set<string>()), removed: new Set<string>(), updated: new Set<string>() };\n\tconst baseToLocal = baseState ? compareExtensionState(baseState, localState) : { added: Object.keys(localState).reduce((r, k) => { r.add(k); return r; }, new Set<string>()), removed: new Set<string>(), updated: new Set<string>() };\n\t// Added/Updated in remote\n\tfor (const key of [...baseToRemote.added.values(), ...baseToRemote.updated.values()]) {\n\t\tmergedState[key] = remoteState[key];\n\t}\n\t// Removed in remote\n\tfor (const key of baseToRemote.removed.values()) {\n\t\t// Not updated in local\n\t\tif (!baseToLocal.updated.has(key)) {\n\t\t\tdelete mergedState[key];\n\t\t}\n\t}\n\treturn mergedState;\n}\n\nfunction compareExtensionState(from: IStringDictionary<any>, to: IStringDictionary<any>): { added: Set<string>; removed: Set<string>; updated: Set<string> } {\n\tconst fromKeys = Object.keys(from);\n\tconst toKeys = Object.keys(to);\n\tconst added = toKeys.filter(key => !fromKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst removed = fromKeys.filter(key => !toKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst updated: Set<string> = new Set<string>();\n\n\tfor (const key of fromKeys) {\n\t\tif (removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst value1 = from[key];\n\t\tconst value2 = to[key];\n\t\tif (!equals(value1, value2)) {\n\t\t\tupdated.add(key);\n\t\t}\n\t}\n\n\treturn { added, removed, updated };\n}\n\nfunction isSameExtensionState(a: IStringDictionary<any> = {}, b: IStringDictionary<any> = {}): boolean {\n\tconst { added, removed, updated } = compareExtensionState(a, b);\n\treturn added.size === 0 && removed.size === 0 && updated.size === 0;\n}\n\n// massage incoming extension - add optional properties\nfunction massageIncomingExtension(extension: ISyncExtension): ISyncExtension {\n\treturn { ...extension, ...{ disabled: !!extension.disabled, installed: !!extension.installed } };\n}\n\n// massage outgoing extension - remove optional properties\nfunction massageOutgoingExtension(extension: ISyncExtension, key: string): ISyncExtension {\n\tconst massagedExtension: ISyncExtension = {\n\t\t...extension,\n\t\tidentifier: {\n\t\t\tid: extension.identifier.id,\n\t\t\tuuid: key.startsWith('uuid:') ? key.substring('uuid:'.length) : undefined\n\t\t},\n\t\t/* set following always so that to differentiate with older clients */\n\t\tpreRelease: !!extension.preRelease,\n\t\tpinned: !!extension.pinned,\n\t};\n\tif (!extension.disabled) {\n\t\tdelete massagedExtension.disabled;\n\t}\n\tif (!extension.installed) {\n\t\tdelete massagedExtension.installed;\n\t}\n\tif (!extension.state) {\n\t\tdelete massagedExtension.state;\n\t}\n\tif (!extension.isApplicationScoped) {\n\t\tdelete massagedExtension.isApplicationScoped;\n\t}\n\treturn massagedExtension;\n}\n"]}