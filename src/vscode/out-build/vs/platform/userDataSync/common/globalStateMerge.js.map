{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/userDataSync/common/globalStateMerge.ts","vs/platform/userDataSync/common/globalStateMerge.ts"],"names":[],"mappings":"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","file":"globalStateMerge.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport * as objects from '../../../base/common/objects.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IStorageValue, SYNC_SERVICE_URL_TYPE } from './userDataSync.js';\n\nexport interface IMergeResult {\n\tlocal: { added: IStringDictionary<IStorageValue>; removed: string[]; updated: IStringDictionary<IStorageValue> };\n\tremote: { added: string[]; removed: string[]; updated: string[]; all: IStringDictionary<IStorageValue> | null };\n}\n\nexport function merge(localStorage: IStringDictionary<IStorageValue>, remoteStorage: IStringDictionary<IStorageValue> | null, baseStorage: IStringDictionary<IStorageValue> | null, storageKeys: { machine: ReadonlyArray<string>; unregistered: ReadonlyArray<string> }, logService: ILogService): IMergeResult {\n\tif (!remoteStorage) {\n\t\treturn { remote: { added: Object.keys(localStorage), removed: [], updated: [], all: Object.keys(localStorage).length > 0 ? localStorage : null }, local: { added: {}, removed: [], updated: {} } };\n\t}\n\n\tconst localToRemote = compare(localStorage, remoteStorage);\n\tif (localToRemote.added.size === 0 && localToRemote.removed.size === 0 && localToRemote.updated.size === 0) {\n\t\t// No changes found between local and remote.\n\t\treturn { remote: { added: [], removed: [], updated: [], all: null }, local: { added: {}, removed: [], updated: {} } };\n\t}\n\n\tconst baseToRemote = baseStorage ? compare(baseStorage, remoteStorage) : { added: Object.keys(remoteStorage).reduce((r, k) => { r.add(k); return r; }, new Set<string>()), removed: new Set<string>(), updated: new Set<string>() };\n\tconst baseToLocal = baseStorage ? compare(baseStorage, localStorage) : { added: Object.keys(localStorage).reduce((r, k) => { r.add(k); return r; }, new Set<string>()), removed: new Set<string>(), updated: new Set<string>() };\n\n\tconst local: { added: IStringDictionary<IStorageValue>; removed: string[]; updated: IStringDictionary<IStorageValue> } = { added: {}, removed: [], updated: {} };\n\tconst remote: IStringDictionary<IStorageValue> = objects.deepClone(remoteStorage);\n\n\tconst isFirstTimeSync = !baseStorage;\n\n\t// Added in local\n\tfor (const key of baseToLocal.added.values()) {\n\t\t// If syncing for first time remote value gets precedence always,\n\t\t// except for sync service type key - local value takes precedence for this key\n\t\tif (key !== SYNC_SERVICE_URL_TYPE && isFirstTimeSync && baseToRemote.added.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tremote[key] = localStorage[key];\n\t}\n\n\t// Updated in local\n\tfor (const key of baseToLocal.updated.values()) {\n\t\tremote[key] = localStorage[key];\n\t}\n\n\t// Removed in local\n\tfor (const key of baseToLocal.removed.values()) {\n\t\t// Do not remove from remote if key is not registered.\n\t\tif (storageKeys.unregistered.includes(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tdelete remote[key];\n\t}\n\n\t// Added in remote\n\tfor (const key of baseToRemote.added.values()) {\n\t\tconst remoteValue = remoteStorage[key];\n\t\tif (storageKeys.machine.includes(key)) {\n\t\t\tlogService.info(`GlobalState: Skipped adding ${key} in local storage because it is declared as machine scoped.`);\n\t\t\tcontinue;\n\t\t}\n\t\t// Skip if the value is also added in local from the time it is last synced\n\t\tif (baseStorage && baseToLocal.added.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst localValue = localStorage[key];\n\t\tif (localValue && localValue.value === remoteValue.value) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Local sync service type value takes precedence if syncing for first time\n\t\tif (key === SYNC_SERVICE_URL_TYPE && isFirstTimeSync && baseToLocal.added.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (localValue) {\n\t\t\tlocal.updated[key] = remoteValue;\n\t\t} else {\n\t\t\tlocal.added[key] = remoteValue;\n\t\t}\n\t}\n\n\t// Updated in Remote\n\tfor (const key of baseToRemote.updated.values()) {\n\t\tconst remoteValue = remoteStorage[key];\n\t\tif (storageKeys.machine.includes(key)) {\n\t\t\tlogService.info(`GlobalState: Skipped updating ${key} in local storage because it is declared as machine scoped.`);\n\t\t\tcontinue;\n\t\t}\n\t\t// Skip if the value is also updated or removed in local\n\t\tif (baseToLocal.updated.has(key) || baseToLocal.removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst localValue = localStorage[key];\n\t\tif (localValue && localValue.value === remoteValue.value) {\n\t\t\tcontinue;\n\t\t}\n\t\tlocal.updated[key] = remoteValue;\n\t}\n\n\t// Removed in remote\n\tfor (const key of baseToRemote.removed.values()) {\n\t\tif (storageKeys.machine.includes(key)) {\n\t\t\tlogService.trace(`GlobalState: Skipped removing ${key} in local storage because it is declared as machine scoped.`);\n\t\t\tcontinue;\n\t\t}\n\t\t// Skip if the value is also updated or removed in local\n\t\tif (baseToLocal.updated.has(key) || baseToLocal.removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tlocal.removed.push(key);\n\t}\n\n\tconst result = compare(remoteStorage, remote);\n\treturn { local, remote: { added: [...result.added], updated: [...result.updated], removed: [...result.removed], all: result.added.size === 0 && result.removed.size === 0 && result.updated.size === 0 ? null : remote } };\n}\n\nfunction compare(from: IStringDictionary<any>, to: IStringDictionary<any>): { added: Set<string>; removed: Set<string>; updated: Set<string> } {\n\tconst fromKeys = Object.keys(from);\n\tconst toKeys = Object.keys(to);\n\tconst added = toKeys.filter(key => !fromKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst removed = fromKeys.filter(key => !toKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst updated: Set<string> = new Set<string>();\n\n\tfor (const key of fromKeys) {\n\t\tif (removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst value1 = from[key];\n\t\tconst value2 = to[key];\n\t\tif (!objects.equals(value1, value2)) {\n\t\t\tupdated.add(key);\n\t\t}\n\t}\n\n\treturn { added, removed, updated };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IStringDictionary } from '../../../base/common/collections.js';\nimport * as objects from '../../../base/common/objects.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IStorageValue, SYNC_SERVICE_URL_TYPE } from './userDataSync.js';\n\nexport interface IMergeResult {\n\tlocal: { added: IStringDictionary<IStorageValue>; removed: string[]; updated: IStringDictionary<IStorageValue> };\n\tremote: { added: string[]; removed: string[]; updated: string[]; all: IStringDictionary<IStorageValue> | null };\n}\n\nexport function merge(localStorage: IStringDictionary<IStorageValue>, remoteStorage: IStringDictionary<IStorageValue> | null, baseStorage: IStringDictionary<IStorageValue> | null, storageKeys: { machine: ReadonlyArray<string>; unregistered: ReadonlyArray<string> }, logService: ILogService): IMergeResult {\n\tif (!remoteStorage) {\n\t\treturn { remote: { added: Object.keys(localStorage), removed: [], updated: [], all: Object.keys(localStorage).length > 0 ? localStorage : null }, local: { added: {}, removed: [], updated: {} } };\n\t}\n\n\tconst localToRemote = compare(localStorage, remoteStorage);\n\tif (localToRemote.added.size === 0 && localToRemote.removed.size === 0 && localToRemote.updated.size === 0) {\n\t\t// No changes found between local and remote.\n\t\treturn { remote: { added: [], removed: [], updated: [], all: null }, local: { added: {}, removed: [], updated: {} } };\n\t}\n\n\tconst baseToRemote = baseStorage ? compare(baseStorage, remoteStorage) : { added: Object.keys(remoteStorage).reduce((r, k) => { r.add(k); return r; }, new Set<string>()), removed: new Set<string>(), updated: new Set<string>() };\n\tconst baseToLocal = baseStorage ? compare(baseStorage, localStorage) : { added: Object.keys(localStorage).reduce((r, k) => { r.add(k); return r; }, new Set<string>()), removed: new Set<string>(), updated: new Set<string>() };\n\n\tconst local: { added: IStringDictionary<IStorageValue>; removed: string[]; updated: IStringDictionary<IStorageValue> } = { added: {}, removed: [], updated: {} };\n\tconst remote: IStringDictionary<IStorageValue> = objects.deepClone(remoteStorage);\n\n\tconst isFirstTimeSync = !baseStorage;\n\n\t// Added in local\n\tfor (const key of baseToLocal.added.values()) {\n\t\t// If syncing for first time remote value gets precedence always,\n\t\t// except for sync service type key - local value takes precedence for this key\n\t\tif (key !== SYNC_SERVICE_URL_TYPE && isFirstTimeSync && baseToRemote.added.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tremote[key] = localStorage[key];\n\t}\n\n\t// Updated in local\n\tfor (const key of baseToLocal.updated.values()) {\n\t\tremote[key] = localStorage[key];\n\t}\n\n\t// Removed in local\n\tfor (const key of baseToLocal.removed.values()) {\n\t\t// Do not remove from remote if key is not registered.\n\t\tif (storageKeys.unregistered.includes(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tdelete remote[key];\n\t}\n\n\t// Added in remote\n\tfor (const key of baseToRemote.added.values()) {\n\t\tconst remoteValue = remoteStorage[key];\n\t\tif (storageKeys.machine.includes(key)) {\n\t\t\tlogService.info(`GlobalState: Skipped adding ${key} in local storage because it is declared as machine scoped.`);\n\t\t\tcontinue;\n\t\t}\n\t\t// Skip if the value is also added in local from the time it is last synced\n\t\tif (baseStorage && baseToLocal.added.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst localValue = localStorage[key];\n\t\tif (localValue && localValue.value === remoteValue.value) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Local sync service type value takes precedence if syncing for first time\n\t\tif (key === SYNC_SERVICE_URL_TYPE && isFirstTimeSync && baseToLocal.added.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (localValue) {\n\t\t\tlocal.updated[key] = remoteValue;\n\t\t} else {\n\t\t\tlocal.added[key] = remoteValue;\n\t\t}\n\t}\n\n\t// Updated in Remote\n\tfor (const key of baseToRemote.updated.values()) {\n\t\tconst remoteValue = remoteStorage[key];\n\t\tif (storageKeys.machine.includes(key)) {\n\t\t\tlogService.info(`GlobalState: Skipped updating ${key} in local storage because it is declared as machine scoped.`);\n\t\t\tcontinue;\n\t\t}\n\t\t// Skip if the value is also updated or removed in local\n\t\tif (baseToLocal.updated.has(key) || baseToLocal.removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst localValue = localStorage[key];\n\t\tif (localValue && localValue.value === remoteValue.value) {\n\t\t\tcontinue;\n\t\t}\n\t\tlocal.updated[key] = remoteValue;\n\t}\n\n\t// Removed in remote\n\tfor (const key of baseToRemote.removed.values()) {\n\t\tif (storageKeys.machine.includes(key)) {\n\t\t\tlogService.trace(`GlobalState: Skipped removing ${key} in local storage because it is declared as machine scoped.`);\n\t\t\tcontinue;\n\t\t}\n\t\t// Skip if the value is also updated or removed in local\n\t\tif (baseToLocal.updated.has(key) || baseToLocal.removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tlocal.removed.push(key);\n\t}\n\n\tconst result = compare(remoteStorage, remote);\n\treturn { local, remote: { added: [...result.added], updated: [...result.updated], removed: [...result.removed], all: result.added.size === 0 && result.removed.size === 0 && result.updated.size === 0 ? null : remote } };\n}\n\nfunction compare(from: IStringDictionary<any>, to: IStringDictionary<any>): { added: Set<string>; removed: Set<string>; updated: Set<string> } {\n\tconst fromKeys = Object.keys(from);\n\tconst toKeys = Object.keys(to);\n\tconst added = toKeys.filter(key => !fromKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst removed = fromKeys.filter(key => !toKeys.includes(key)).reduce((r, key) => { r.add(key); return r; }, new Set<string>());\n\tconst updated: Set<string> = new Set<string>();\n\n\tfor (const key of fromKeys) {\n\t\tif (removed.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst value1 = from[key];\n\t\tconst value2 = to[key];\n\t\tif (!objects.equals(value1, value2)) {\n\t\t\tupdated.add(key);\n\t\t}\n\t}\n\n\treturn { added, removed, updated };\n}\n"]}