{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/remote/common/remoteAgentConnection.ts","vs/platform/remote/common/remoteAgentConnection.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAqB,uBAAuB,EAAE,oBAAoB,EAAE,MAAM,+BAA+B,CAAC;AACjH,OAAO,EAAE,QAAQ,EAAE,MAAM,gCAAgC,CAAC;AAC1D,OAAO,EAAE,iBAAiB,EAAE,uBAAuB,EAAE,MAAM,sCAAsC,CAAC;AAClG,OAAO,EAAE,mBAAmB,EAAE,iBAAiB,EAAE,MAAM,gCAAgC,CAAC;AACxF,OAAO,EAAE,OAAO,EAAE,MAAM,+BAA+B,CAAC;AACxD,OAAO,EAAE,UAAU,EAAE,eAAe,EAAe,YAAY,EAAE,MAAM,mCAAmC,CAAC;AAC3G,OAAO,EAAE,iBAAiB,EAAE,MAAM,iCAAiC,CAAC;AACpE,OAAO,KAAK,WAAW,MAAM,qCAAqC,CAAC;AACnE,OAAO,EAAE,SAAS,EAAE,MAAM,mCAAmC,CAAC;AAC9D,OAAO,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AAE5D,OAAO,EAAE,MAAM,EAAW,kBAAkB,EAA2C,MAAM,2CAA2C,CAAC;AAGzI,OAAO,EAAE,4BAA4B,EAAoB,MAAM,8BAA8B,CAAC;AAI9F,MAAM,iBAAiB,GAAG,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC;AAE9C,MAAM,CAAN,IAAkB,cAIjB;AAJD,WAAkB,cAAc;IAC/B,+DAAc,CAAA;IACd,qEAAiB,CAAA;IACjB,uDAAU,CAAA;AACX,CAAC,EAJiB,cAAc,KAAd,cAAc,QAI/B;AAED,SAAS,sBAAsB,CAAC,cAA8B;IAC7D,QAAQ,cAAc,EAAE,CAAC;QACxB;YACC,OAAO,YAAY,CAAC;QACrB;YACC,OAAO,eAAe,CAAC;QACxB;YACC,OAAO,QAAQ,CAAC;IAClB,CAAC;AACF,CAAC;AA8CD,SAAS,yBAAyB,CAAC,MAAc;IAChD,MAAM,MAAM,GAAG,IAAI,uBAAuB,EAAE,CAAC;IAC7C,UAAU,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,MAAM,CAAC,CAAC;IAC1C,OAAO,MAAM,CAAC,KAAK,CAAC;AACrB,CAAC;AAED,SAAS,0BAA0B,CAAC,CAAoB,EAAE,CAAoB;IAC7E,IAAI,CAAC,CAAC,uBAAuB,IAAI,CAAC,CAAC,uBAAuB,EAAE,CAAC;QAC5D,OAAO,iBAAiB,CAAC,SAAS,CAAC;IACpC,CAAC;IACD,MAAM,MAAM,GAAG,IAAI,uBAAuB,EAAE,CAAC;IAC7C,CAAC,CAAC,uBAAuB,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;IACjD,CAAC,CAAC,uBAAuB,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;IACjD,OAAO,MAAM,CAAC,KAAK,CAAC;AACrB,CAAC;AAED,MAAM,kBAAkB;IAQvB,IAAW,UAAU;QACpB,OAAO,CAAC,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,CAAC;IACrC,CAAC;IAED,YAAY,wBAA2C;QACtD,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;QACxB,IAAI,CAAC,YAAY,GAAG,IAAI,eAAe,EAAE,CAAC;QAE1C,CAAC,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,eAAe,EAAE,MAAM,EAAE,IAAI,CAAC,cAAc,EAAE,GAAG,oBAAoB,EAAK,CAAC,CAAC;QAEpH,IAAI,wBAAwB,CAAC,uBAAuB,EAAE,CAAC;YACtD,IAAI,CAAC,QAAQ,EAAE,CAAC;QACjB,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,wBAAwB,CAAC,uBAAuB,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;QAChG,CAAC;IACF,CAAC;IAEM,kBAAkB,CAAC,UAAuB;QAChD,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;YAC/B,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QACnC,CAAC;aAAM,CAAC;YACP,UAAU,CAAC,OAAO,EAAE,CAAC;QACtB,CAAC;IACF,CAAC;IAEO,QAAQ;QACf,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;YAC/B,OAAO;QACR,CAAC;QACD,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;QAC5B,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC;QACzB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC,CAAC;IACjD,CAAC;IAEO,mBAAmB;QAC1B,MAAM,GAAG,GAAQ,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;QACjD,GAAG,CAAC,IAAI,GAAG,WAAW,CAAC;QACvB,GAAG,CAAC,OAAO,GAAG,SAAS,CAAC;QACxB,OAAO,GAAG,CAAC;IACZ,CAAC;IAEM,OAAO,CAAC,KAAQ;QACtB,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;YAC/B,OAAO;QACR,CAAC;QACD,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;QAC5B,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC;QACzB,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;IAEM,MAAM,CAAC,GAAQ;QACrB,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;YAC/B,OAAO;QACR,CAAC;QACD,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;QAC5B,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC;QACzB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;IAC1B,CAAC;CACD;AAED,SAAS,qBAAqB,CAAI,QAA4B,EAAE,wBAA2C;IAC1G,MAAM,MAAM,GAAG,IAAI,kBAAkB,CAAI,wBAAwB,CAAC,CAAC;IACnE,MAAM,CAAC,kBAAkB,CAAC,QAAQ,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE;QACzD,MAAM,GAAG,GAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC;QAC1C,MAAM,KAAK,GAAG,mBAAmB,CAAC,GAAG,CAAC,CAAC;QACvC,IAAI,KAAK,EAAE,CAAC;YACX,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACtB,CAAC;aAAM,CAAC;YACP,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACrB,CAAC;IACF,CAAC,CAAC,CAAC,CAAC;IACJ,OAAO,MAAM,CAAC,OAAO,CAAC;AACvB,CAAC;AAED,SAAS,YAAY,CAA6B,UAAuB,EAAE,0BAAuD,EAAE,SAAY,EAAE,IAAY,EAAE,KAAa,EAAE,mBAA2B,EAAE,UAAkB,EAAE,wBAA2C;IAC1Q,MAAM,MAAM,GAAG,IAAI,kBAAkB,CAAU,wBAAwB,CAAC,CAAC;IACzE,MAAM,EAAE,GAAG,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IACnC,UAAU,CAAC,IAAI,CAAC,sBAAsB,UAAU,MAAM,CAAC,CAAC;IACxD,WAAW,CAAC,IAAI,CAAC,yBAAyB,mBAAmB,EAAE,CAAC,CAAC;IAEjE,0BAA0B,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE;QACtF,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC;YACvB,WAAW,CAAC,IAAI,CAAC,6BAA6B,mBAAmB,EAAE,CAAC,CAAC;YACrE,UAAU,CAAC,IAAI,CAAC,sBAAsB,UAAU,oBAAoB,EAAE,CAAC,OAAO,EAAE,sDAAsD,CAAC,CAAC;YACxI,MAAM,EAAE,OAAO,EAAE,CAAC;QACnB,CAAC;aAAM,CAAC;YACP,WAAW,CAAC,IAAI,CAAC,0BAA0B,mBAAmB,EAAE,CAAC,CAAC;YAClE,UAAU,CAAC,IAAI,CAAC,sBAAsB,UAAU,0BAA0B,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YAC9F,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACxB,CAAC;IACF,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE;QACV,WAAW,CAAC,IAAI,CAAC,6BAA6B,mBAAmB,EAAE,CAAC,CAAC;QACrE,UAAU,CAAC,IAAI,CAAC,sBAAsB,UAAU,6BAA6B,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QACjG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACtB,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACpB,CAAC,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC,OAAO,CAAC;AACvB,CAAC;AAED,SAAS,2BAA2B,CAAI,OAAmB,EAAE,wBAA2C;IACvG,MAAM,MAAM,GAAG,IAAI,kBAAkB,CAAI,wBAAwB,CAAC,CAAC;IACnE,OAAO,CAAC,IAAI,CACX,CAAC,GAAG,EAAE,EAAE;QACP,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC;YACxB,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACrB,CAAC;IACF,CAAC,EACD,CAAC,GAAG,EAAE,EAAE;QACP,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC;YACxB,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACpB,CAAC;IACF,CAAC,CACD,CAAC;IACF,OAAO,MAAM,CAAC,OAAO,CAAC;AACvB,CAAC;AAED,KAAK,UAAU,iCAAiC,CAA6B,OAAoC,EAAE,cAA8B,EAAE,IAAqB,EAAE,wBAA2C;IACpN,MAAM,SAAS,GAAG,gBAAgB,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;IAE5D,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,yCAAyC,CAAC,CAAC;IAEhF,IAAI,MAAe,CAAC;IACpB,IAAI,CAAC;QACJ,MAAM,GAAG,MAAM,YAAY,CAAC,OAAO,CAAC,UAAU,EAAE,OAAO,CAAC,0BAA0B,EAAE,OAAO,CAAC,SAAS,EAAE,iBAAiB,CAAC,iBAAiB,EAAE,EAAE,qBAAqB,OAAO,CAAC,iBAAiB,iBAAiB,OAAO,CAAC,oBAAoB,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,EAAE,EAAE,sBAAsB,CAAC,cAAc,CAAC,EAAE,YAAY,sBAAsB,CAAC,cAAc,CAAC,IAAI,OAAO,CAAC,iBAAiB,EAAE,EAAE,wBAAwB,CAAC,CAAC;IACtZ,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QAChB,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,sDAAsD,CAAC,CAAC;QAC7F,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QAChC,MAAM,KAAK,CAAC;IACb,CAAC;IAED,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,+CAA+C,CAAC,CAAC;IAEtF,IAAI,QAA4B,CAAC;IACjC,IAAI,YAAqB,CAAC;IAC1B,IAAI,OAAO,CAAC,oBAAoB,EAAE,CAAC;QAClC,OAAO,CAAC,oBAAoB,CAAC,uBAAuB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QACnE,QAAQ,GAAG,OAAO,CAAC,oBAAoB,CAAC;QACxC,YAAY,GAAG,KAAK,CAAC;IACtB,CAAC;SAAM,CAAC;QACP,QAAQ,GAAG,IAAI,kBAAkB,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC;QAC9C,YAAY,GAAG,IAAI,CAAC;IACrB,CAAC;IAED,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,4CAA4C,CAAC,CAAC;IACnF,MAAM,OAAO,GAAG,MAAM,2BAA2B,CAAC,OAAO,CAAC,WAAW,CAAC,gBAAgB,CAAC,YAAY,EAAE,CAAC,EAAE,wBAAwB,CAAC,CAAC;IAElI,MAAM,WAAW,GAAgB;QAChC,IAAI,EAAE,MAAM;QACZ,IAAI,EAAE,OAAO,CAAC,eAAe,IAAI,sBAAsB;QACvD,IAAI,EAAE,OAAO,CAAC,IAAI;KAClB,CAAC;IACF,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;IAEvE,IAAI,CAAC;QACJ,MAAM,GAAG,GAAG,MAAM,qBAAqB,CAAmB,QAAQ,EAAE,0BAA0B,CAAC,wBAAwB,EAAE,yBAAyB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAE5J,IAAI,GAAG,CAAC,IAAI,KAAK,MAAM,IAAI,OAAO,GAAG,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;YACzD,MAAM,KAAK,GAAQ,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;YAC7D,KAAK,CAAC,IAAI,GAAG,yBAAyB,CAAC;YACvC,MAAM,KAAK,CAAC;QACb,CAAC;QAED,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,6CAA6C,CAAC,CAAC;QAEpF,MAAM,OAAO,GAAG,MAAM,2BAA2B,CAAC,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,OAAO,EAAE,GAAG,CAAC,UAAU,CAAC,EAAE,wBAAwB,CAAC,CAAC;QACnI,IAAI,CAAC,OAAO,EAAE,CAAC;YACd,MAAM,KAAK,GAAQ,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;YACzE,KAAK,CAAC,IAAI,GAAG,yBAAyB,CAAC;YACvC,MAAM,KAAK,CAAC;QACb,CAAC;QAED,MAAM,MAAM,GAAG,MAAM,2BAA2B,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,wBAAwB,CAAC,CAAC;QAC/G,MAAM,eAAe,GAA0B;YAC9C,IAAI,EAAE,gBAAgB;YACtB,MAAM,EAAE,OAAO,CAAC,MAAM;YACtB,UAAU,EAAE,MAAM;YAClB,qBAAqB,EAAE,cAAc;SACrC,CAAC;QACF,IAAI,IAAI,EAAE,CAAC;YACV,eAAe,CAAC,IAAI,GAAG,IAAI,CAAC;QAC7B,CAAC;QAED,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,sDAAsD,CAAC,CAAC;QAC7F,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;QAE3E,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE,CAAC;IAEnC,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QAChB,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE,CAAC;YACzC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,kCAAkC,CAAC,CAAC;YACzE,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACjC,CAAC;QACD,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,yBAAyB,EAAE,CAAC;YACvD,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,qEAAqE,CAAC,CAAC;YAC5G,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACjC,CAAC;QACD,IAAI,YAAY,EAAE,CAAC;YAClB,4BAA4B,CAAC,QAAQ,CAAC,CAAC;QACxC,CAAC;QACD,MAAM,KAAK,CAAC;IACb,CAAC;AACF,CAAC;AAMD,KAAK,UAAU,kDAAkD,CAAI,OAAiC,EAAE,cAA8B,EAAE,IAAqB,EAAE,wBAA2C;IACzM,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IAC7B,MAAM,SAAS,GAAG,gBAAgB,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;IAC5D,MAAM,EAAE,QAAQ,EAAE,YAAY,EAAE,GAAG,MAAM,iCAAiC,CAAC,OAAO,EAAE,cAAc,EAAE,IAAI,EAAE,wBAAwB,CAAC,CAAC;IACpI,MAAM,MAAM,GAAG,IAAI,kBAAkB,CAAoD,wBAAwB,CAAC,CAAC;IACnH,MAAM,CAAC,kBAAkB,CAAC,QAAQ,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE;QACzD,MAAM,GAAG,GAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC;QAC1C,MAAM,KAAK,GAAG,mBAAmB,CAAC,GAAG,CAAC,CAAC;QACvC,IAAI,KAAK,EAAE,CAAC;YACX,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,qEAAqE,CAAC,CAAC;YAC5G,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YAChC,IAAI,YAAY,EAAE,CAAC;gBAClB,4BAA4B,CAAC,QAAQ,CAAC,CAAC;YACxC,CAAC;YACD,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACtB,CAAC;aAAM,CAAC;YACP,OAAO,CAAC,oBAAoB,EAAE,qBAAqB,EAAE,CAAC;YACtD,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,gEAAgE,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;YAC/H,MAAM,CAAC,OAAO,CAAC,EAAE,QAAQ,EAAE,YAAY,EAAE,GAAG,EAAE,CAAC,CAAC;QACjD,CAAC;IACF,CAAC,CAAC,CAAC,CAAC;IACJ,OAAO,MAAM,CAAC,OAAO,CAAC;AACvB,CAAC;AAED,KAAK,UAAU,8BAA8B,CAAC,OAAiC,EAAE,wBAA2C;IAC3H,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,kDAAkD,CAAC,OAAO,qCAA6B,SAAS,EAAE,wBAAwB,CAAC,CAAC;IACvJ,OAAO,EAAE,QAAQ,EAAE,CAAC;AACrB,CAAC;AAeD,KAAK,UAAU,iCAAiC,CAAC,OAAiC,EAAE,cAA+C,EAAE,wBAA2C;IAC/K,MAAM,EAAE,QAAQ,EAAE,YAAY,EAAE,GAAG,MAAM,kDAAkD,CAAyB,OAAO,wCAAgC,cAAc,EAAE,wBAAwB,CAAC,CAAC;IACrM,MAAM,SAAS,GAAG,YAAY,IAAI,YAAY,CAAC,SAAS,CAAC;IACzD,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC;AAChC,CAAC;AAOD,KAAK,UAAU,0BAA0B,CAAC,OAAiC,EAAE,WAAyC,EAAE,wBAA2C;IAClK,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IAC7B,MAAM,SAAS,GAAG,gBAAgB,CAAC,OAAO,gCAAwB,CAAC;IACnE,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,iCAAiC,CAAC,OAAO,iCAAyB,WAAW,EAAE,wBAAwB,CAAC,CAAC;IACpI,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,gEAAgE,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;IAC/H,OAAO,QAAQ,CAAC;AACjB,CAAC;AAYD,KAAK,UAAU,wBAAwB,CAA6B,OAA8B,EAAE,iBAAyB,EAAE,oBAA+C;IAC7K,MAAM,EAAE,SAAS,EAAE,eAAe,EAAE,GAAG,MAAM,OAAO,CAAC,eAAe,CAAC,UAAU,EAAE,CAAC;IAClF,OAAO;QACN,MAAM,EAAE,OAAO,CAAC,MAAM;QACtB,OAAO,EAAE,OAAO,CAAC,OAAO;QACxB,SAAS;QACT,eAAe,EAAE,eAAe;QAChC,iBAAiB,EAAE,iBAAiB;QACpC,oBAAoB,EAAE,oBAAoB;QAC1C,0BAA0B,EAAE,OAAO,CAAC,0BAA0B;QAC9D,WAAW,EAAE,OAAO,CAAC,WAAW;QAChC,UAAU,EAAE,OAAO,CAAC,UAAU;KAC9B,CAAC;AACH,CAAC;AAWD,MAAM,CAAC,KAAK,UAAU,4BAA4B,CAAC,OAA2B,EAAE,eAAuB,EAAE,QAAgB;IACxH,OAAO,uBAAuB,CAC7B,OAAO,EACP,KAAK,EAAE,aAAa,EAAE,EAAE;QACvB,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,8BAA8B,CAAC,aAAa,EAAE,iBAAiB,CAAC,IAAI,CAAC,CAAC;QACjG,OAAO,IAAI,8BAA8B,CAAC,OAAO,EAAE,eAAe,EAAE,QAAQ,EAAE,aAAa,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;IAC1H,CAAC,CACD,CAAC;AACH,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,+BAA+B,CAAC,OAA2B,EAAE,cAA+C;IACjI,OAAO,uBAAuB,CAC7B,OAAO,EACP,KAAK,EAAE,aAAa,EAAE,EAAE;QACvB,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG,MAAM,iCAAiC,CAAC,aAAa,EAAE,cAAc,EAAE,iBAAiB,CAAC,IAAI,CAAC,CAAC;QAC/H,OAAO,IAAI,iCAAiC,CAAC,OAAO,EAAE,cAAc,EAAE,aAAa,CAAC,iBAAiB,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;IAC7H,CAAC,CACD,CAAC;AACH,CAAC;AAED;;GAEG;AACH,KAAK,UAAU,uBAAuB,CAA6D,OAA8B,EAAE,iBAA6E;IAC/M,MAAM,YAAY,GAAG,CAAC,CAAC;IAEvB,KAAK,IAAI,OAAO,GAAG,CAAC,GAAI,OAAO,EAAE,EAAE,CAAC;QACnC,IAAI,CAAC;YACJ,MAAM,iBAAiB,GAAG,YAAY,EAAE,CAAC;YACzC,MAAM,aAAa,GAAG,MAAM,wBAAwB,CAAC,OAAO,EAAE,iBAAiB,EAAE,IAAI,CAAC,CAAC;YACvF,MAAM,MAAM,GAAG,MAAM,iBAAiB,CAAC,aAAa,CAAC,CAAC;YACtD,OAAO,MAAM,CAAC;QACf,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACd,IAAI,OAAO,GAAG,YAAY,EAAE,CAAC;gBAC5B,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,+BAA+B,OAAO,iEAAiE,CAAC,CAAC;gBAClI,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC/B,CAAC;iBAAM,CAAC;gBACP,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,+BAA+B,OAAO,6FAA6F,CAAC,CAAC;gBAC9J,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;gBAC9B,oBAAoB,CAAC,uBAAuB,CAAC,CAAC,EAAE,CAAC,EAAE,4BAA4B,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;gBAChG,MAAM,GAAG,CAAC;YACX,CAAC;QACF,CAAC;IACF,CAAC;AACF,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,wBAAwB,CAAC,OAA2B,EAAE,gBAAwB,EAAE,gBAAwB;IAC7H,MAAM,aAAa,GAAG,MAAM,wBAAwB,CAAC,OAAO,EAAE,YAAY,EAAE,EAAE,IAAI,CAAC,CAAC;IACpF,MAAM,QAAQ,GAAG,MAAM,0BAA0B,CAAC,aAAa,EAAE,EAAE,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,gBAAgB,EAAE,EAAE,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC7I,OAAO,QAAQ,CAAC;AACjB,CAAC;AAED,SAAS,KAAK,CAAC,OAAe;IAC7B,OAAO,uBAAuB,CAAC,KAAK,CAAC,EAAE;QACtC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACtC,MAAM,OAAO,GAAG,UAAU,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI,CAAC,CAAC;YACpD,KAAK,CAAC,uBAAuB,CAAC,GAAG,EAAE;gBAClC,YAAY,CAAC,OAAO,CAAC,CAAC;gBACtB,OAAO,EAAE,CAAC;YACX,CAAC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;AACJ,CAAC;AAED,MAAM,CAAN,IAAkB,6BAMjB;AAND,WAAkB,6BAA6B;IAC9C,qGAAc,CAAA;IACd,yGAAgB,CAAA;IAChB,+GAAmB,CAAA;IACnB,iIAA4B,CAAA;IAC5B,qGAAc,CAAA;AACf,CAAC,EANiB,6BAA6B,KAA7B,6BAA6B,QAM9C;AACD,MAAM,OAAO,mBAAmB;IAE/B,YACiB,iBAAyB,EACzB,2BAAmC;QADnC,sBAAiB,GAAjB,iBAAiB,CAAQ;QACzB,gCAA2B,GAA3B,2BAA2B,CAAQ;QAHpC,SAAI,wDAAgD;IAIhE,CAAC;CACL;AACD,MAAM,OAAO,qBAAqB;IAEjC,YACiB,iBAAyB,EACzB,2BAAmC,EACnC,eAAuB,EACtB,gBAAyC;QAH1C,sBAAiB,GAAjB,iBAAiB,CAAQ;QACzB,gCAA2B,GAA3B,2BAA2B,CAAQ;QACnC,oBAAe,GAAf,eAAe,CAAQ;QACtB,qBAAgB,GAAhB,gBAAgB,CAAyB;QAL3C,SAAI,0DAAkD;IAMlE,CAAC;IAEE,QAAQ;QACd,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC;IAChC,CAAC;CACD;AACD,MAAM,OAAO,wBAAwB;IAEpC,YACiB,iBAAyB,EACzB,2BAAmC,EACnC,OAAe;QAFf,sBAAiB,GAAjB,iBAAiB,CAAQ;QACzB,gCAA2B,GAA3B,2BAA2B,CAAQ;QACnC,YAAO,GAAP,OAAO,CAAQ;QAJhB,SAAI,6DAAqD;IAKrE,CAAC;CACL;AACD,MAAM,OAAO,mBAAmB;IAE/B,YACiB,iBAAyB,EACzB,2BAAmC,EACnC,OAAe;QAFf,sBAAiB,GAAjB,iBAAiB,CAAQ;QACzB,gCAA2B,GAA3B,2BAA2B,CAAQ;QACnC,YAAO,GAAP,OAAO,CAAQ;QAJhB,SAAI,wDAAgD;IAKhE,CAAC;CACL;AACD,MAAM,OAAO,iCAAiC;IAE7C,YACiB,iBAAyB,EACzB,2BAAmC,EACnC,OAAe,EACf,OAAgB;QAHhB,sBAAiB,GAAjB,iBAAiB,CAAQ;QACzB,gCAA2B,GAA3B,2BAA2B,CAAQ;QACnC,YAAO,GAAP,OAAO,CAAQ;QACf,YAAO,GAAP,OAAO,CAAS;QALjB,SAAI,sEAA8D;IAM9E,CAAC;CACL;AAGD,MAAM,OAAgB,oBAAqB,SAAQ,UAAU;IAErD,MAAM,CAAC,uBAAuB,CAAC,2BAAmC,EAAE,OAAe,EAAE,OAAgB;QAC3G,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;QAC9B,IAAI,CAAC,4CAA4C,GAAG,2BAA2B,CAAC;QAChF,IAAI,CAAC,wBAAwB,GAAG,OAAO,CAAC;QACxC,IAAI,CAAC,wBAAwB,GAAG,OAAO,CAAC;QACxC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,4CAA4C,EAAE,IAAI,CAAC,wBAAwB,EAAE,IAAI,CAAC,wBAAwB,CAAC,CAAC,CAAC;IACtL,CAAC;IAEM,MAAM,CAAC,wBAAwB;QACrC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,kBAAkB,EAAE,CAAC,CAAC;IACpE,CAAC;IAEM,MAAM,CAAC,uBAAuB;QACpC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,mBAAmB,EAAE,CAAC,CAAC;IACrE,CAAC;aAEc,sBAAiB,GAAY,KAAZ,AAAiB,CAAC;aACnC,iDAA4C,GAAW,CAAX,AAAY,CAAC;aACzD,6BAAwB,GAAW,CAAX,AAAY,CAAC;aACrC,6BAAwB,GAAY,KAAZ,AAAiB,CAAC;aAC1C,eAAU,GAA2B,EAA3B,AAA6B,CAAC;IAMvD,IAAY,mBAAmB;QAC9B,OAAO,IAAI,CAAC,iBAAiB,IAAI,oBAAoB,CAAC,iBAAiB,CAAC;IACzE,CAAC;IAMD,YACkB,eAA+B,EAC7B,QAA4B,EAC/B,iBAAyB,EACzB,QAA4B,EAC3B,2BAAoC;QAErD,KAAK,EAAE,CAAC;QANS,oBAAe,GAAf,eAAe,CAAgB;QAC7B,aAAQ,GAAR,QAAQ,CAAoB;QAC/B,sBAAiB,GAAjB,iBAAiB,CAAQ;QACzB,aAAQ,GAAR,QAAQ,CAAoB;QAC3B,gCAA2B,GAA3B,2BAA2B,CAAS;QAjBrC,sBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAA6B,CAAC,CAAC;QAC9E,qBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;QAExD,sBAAiB,GAAY,KAAK,CAAC;QAKnC,oBAAe,GAAY,KAAK,CAAC;QACjC,gBAAW,GAAY,KAAK,CAAC;QAC7B,2BAAsB,0DAAmD;QAYhF,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,mBAAmB,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAEnF,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE,EAAE;YAC3C,MAAM,SAAS,GAAG,eAAe,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;YACtF,IAAI,CAAC,CAAC,EAAE,CAAC;gBACR,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,+BAA+B,CAAC,CAAC;YAC5E,CAAC;iBAAM,IAAI,CAAC,CAAC,IAAI,sDAA8C,EAAE,CAAC;gBACjE,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,2CAA2C,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC;gBACrG,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC;oBACb,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;gBACzC,CAAC;YACF,CAAC;iBAAM,CAAC;gBACP,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,2CAA2C,CAAC,CAAC,QAAQ,WAAW,CAAC,CAAC,IAAI,aAAa,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC;gBAC3I,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC;oBACb,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;gBACzC,CAAC;YACF,CAAC;YACD,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC3B,CAAC,CAAC,CAAC,CAAC;QACJ,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC,CAAC,EAAE,EAAE;YAC7C,MAAM,SAAS,GAAG,eAAe,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;YACtF,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,2DAA2D,CAAC,CAAC,sBAAsB,uCAAuC,CAAC,CAAC,gCAAgC,oCAAoC,CAAC,CAAC,6BAA6B,IAAI,CAAC,CAAC;YAC/Q,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC3B,CAAC,CAAC,CAAC,CAAC;QAEJ,oBAAoB,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC3C,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE;YAChC,MAAM,OAAO,GAAG,oBAAoB,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC9D,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC;gBAClB,oBAAoB,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;YACpD,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;QAEJ,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC9B,IAAI,CAAC,qBAAqB,CAAC,oBAAoB,CAAC,4CAA4C,EAAE,oBAAoB,CAAC,wBAAwB,EAAE,oBAAoB,CAAC,wBAAwB,CAAC,CAAC;QAC7L,CAAC;IACF,CAAC;IAEM,eAAe,CAAC,SAAiB;QACvC,MAAM,cAAc,GAAG,iBAAiB,CAAC,SAAS,yDAA0C,CAAC;QAC7F,MAAM,SAAS,GAAG,eAAe,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC;QACvF,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,sCAAsC,cAAc,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;QAC7I,IAAI,CAAC,sBAAsB,GAAG,cAAc,CAAC;IAC9C,CAAC;IAEe,OAAO;QACtB,KAAK,CAAC,OAAO,EAAE,CAAC;QAChB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;IACzB,CAAC;IAEO,KAAK,CAAC,kBAAkB;QAC/B,oDAAoD;QACpD,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;YAC1B,OAAO;QACR,CAAC;QACD,IAAI,CAAC;YACJ,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;YAC5B,MAAM,IAAI,CAAC,oBAAoB,EAAE,CAAC;QACnC,CAAC;gBAAS,CAAC;YACV,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;QAC9B,CAAC;IACF,CAAC;IAEO,KAAK,CAAC,oBAAoB;QACjC,IAAI,IAAI,CAAC,mBAAmB,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YAClD,oBAAoB;YACpB,OAAO;QACR,CAAC;QACD,MAAM,SAAS,GAAG,eAAe,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;QACtF,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,qFAAqF,CAAC,CAAC;QACjI,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,mBAAmB,CAAC,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,QAAQ,CAAC,8BAA8B,EAAE,CAAC,CAAC,CAAC;QAC7H,MAAM,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;QAChD,MAAM,SAAS,GAAG,IAAI,CAAC,sBAAsB,CAAC;QAC9C,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,2CAA2C,SAAS,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;QACvI,IAAI,SAAS,IAAI,CAAC,EAAE,CAAC;YACpB,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,wEAAwE,CAAC,CAAC;YACrH,IAAI,CAAC,+BAA+B,CAAC,IAAI,CAAC,QAAQ,CAAC,8BAA8B,EAAE,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;YAC/F,OAAO;QACR,CAAC;QACD,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACjC,IAAI,OAAO,GAAG,CAAC,CAAC,CAAC;QACjB,GAAG,CAAC;YACH,OAAO,EAAE,CAAC;YACV,MAAM,QAAQ,GAAG,CAAC,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACrF,IAAI,CAAC;gBACJ,IAAI,QAAQ,GAAG,CAAC,EAAE,CAAC;oBAClB,MAAM,YAAY,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;oBACrC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,qBAAqB,CAAC,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,QAAQ,CAAC,8BAA8B,EAAE,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAC,CAAC;oBAEvJ,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,gBAAgB,QAAQ,iCAAiC,CAAC,CAAC;oBACrG,IAAI,CAAC;wBACJ,MAAM,YAAY,CAAC;oBACpB,CAAC;oBAAC,MAAM,CAAC,CAAC,CAAC,CAAC,sBAAsB;gBACnC,CAAC;gBAED,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;oBAC9B,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,kEAAkE,CAAC,CAAC;oBAC/G,MAAM;gBACP,CAAC;gBAED,oDAAoD;gBACpD,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,wBAAwB,CAAC,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,QAAQ,CAAC,8BAA8B,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC/I,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,0BAA0B,CAAC,CAAC;gBACtE,MAAM,aAAa,GAAG,MAAM,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC3G,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,kBAAkB,aAAa,CAAC,SAAS,KAAK,CAAC,CAAC;gBAC1F,MAAM,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,yBAAyB,CAAC,iBAAiB,CAAC,CAAC,CAAC;gBACnF,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,eAAe,CAAC,CAAC;gBAC3D,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,mBAAmB,CAAC,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,QAAQ,CAAC,8BAA8B,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;gBAE1I,MAAM;YACP,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;gBACd,IAAI,GAAG,CAAC,IAAI,KAAK,yBAAyB,EAAE,CAAC;oBAC5C,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,gFAAgF,CAAC,CAAC;oBAC7H,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBACpC,IAAI,CAAC,+BAA+B,CAAC,IAAI,CAAC,QAAQ,CAAC,8BAA8B,EAAE,EAAE,OAAO,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;oBACzG,MAAM;gBACP,CAAC;gBACD,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,aAAa,IAAI,SAAS,EAAE,CAAC;oBAC7C,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,CAAC;oBAClD,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,2HAA2H,YAAY,0CAA0C,CAAC,CAAC;oBAC9N,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBACpC,IAAI,CAAC,+BAA+B,CAAC,IAAI,CAAC,QAAQ,CAAC,8BAA8B,EAAE,EAAE,OAAO,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;oBACzG,MAAM;gBACP,CAAC;gBACD,IAAI,4BAA4B,CAAC,yBAAyB,CAAC,GAAG,CAAC,EAAE,CAAC;oBACjE,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,0FAA0F,CAAC,CAAC;oBACtI,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBACpC,aAAa;oBACb,SAAS;gBACV,CAAC;gBACD,IAAI,CAAC,GAAG,CAAC,IAAI,KAAK,WAAW,IAAI,GAAG,CAAC,IAAI,KAAK,aAAa,IAAI,GAAG,CAAC,IAAI,KAAK,cAAc,IAAI,GAAG,CAAC,IAAI,KAAK,YAAY,CAAC,IAAI,GAAG,CAAC,OAAO,KAAK,SAAS,EAAE,CAAC;oBACvJ,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,wEAAwE,CAAC,CAAC;oBACpH,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBACpC,aAAa;oBACb,SAAS;gBACV,CAAC;gBACD,IAAI,mBAAmB,CAAC,GAAG,CAAC,EAAE,CAAC;oBAC9B,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,oFAAoF,CAAC,CAAC;oBAChI,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBACpC,aAAa;oBACb,SAAS;gBACV,CAAC;gBACD,IAAI,GAAG,YAAY,4BAA4B,EAAE,CAAC;oBACjD,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,8FAA8F,CAAC,CAAC;oBAC3I,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBACpC,IAAI,CAAC,+BAA+B,CAAC,IAAI,CAAC,QAAQ,CAAC,8BAA8B,EAAE,EAAE,OAAO,GAAG,CAAC,EAAE,4BAA4B,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;oBAC/I,MAAM;gBACP,CAAC;gBACD,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,wJAAwJ,CAAC,CAAC;gBACrM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;gBACpC,IAAI,CAAC,+BAA+B,CAAC,IAAI,CAAC,QAAQ,CAAC,8BAA8B,EAAE,EAAE,OAAO,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;gBACzG,MAAM;YACP,CAAC;QACF,CAAC,QAAQ,CAAC,IAAI,CAAC,mBAAmB,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;IAC1D,CAAC;IAEO,+BAA+B,CAAC,2BAAmC,EAAE,OAAe,EAAE,OAAgB;QAC7G,IAAI,IAAI,CAAC,2BAA2B,EAAE,CAAC;YACtC,oBAAoB,CAAC,uBAAuB,CAAC,2BAA2B,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;QAC7F,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,qBAAqB,CAAC,2BAA2B,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;QAC3E,CAAC;IACF,CAAC;IAEO,qBAAqB,CAAC,2BAAmC,EAAE,OAAe,EAAE,OAAgB;QACnG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,iCAAiC,CAAC,IAAI,CAAC,iBAAiB,EAAE,2BAA2B,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC;QAC1I,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC7C,CAAC;IAEO,mBAAmB;QAC1B,IAAI,CAAC,QAAQ,CAAC,kBAAkB,EAAE,CAAC;IACpC,CAAC;;AAKF,MAAM,OAAO,8BAA+B,SAAQ,oBAAoB;IAIvE,YAAY,OAA2B,EAAE,eAAuB,EAAE,QAAgB,EAAE,iBAAyB,EAAE,QAA4B;QAC1I,KAAK,oCAA4B,OAAO,EAAE,iBAAiB,EAAE,QAAQ,EAAE,8BAA8B,CAAA,IAAI,CAAC,CAAC;QAC3G,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,MAAM,CAA+B,QAAQ,EAAE;YAC/E,eAAe,EAAE,eAAe;YAChC,QAAQ,EAAE,QAAQ;SAClB,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC;IACxB,CAAC;IAES,KAAK,CAAC,UAAU,CAAC,OAAiC,EAAE,wBAA2C;QACxG,MAAM,8BAA8B,CAAC,OAAO,EAAE,wBAAwB,CAAC,CAAC;IACzE,CAAC;CACD;AAED,MAAM,OAAO,iCAAkC,SAAQ,oBAAoB;IAK1E,YAAY,OAA2B,EAAE,cAA+C,EAAE,iBAAyB,EAAE,QAA4B,EAAE,SAA6B;QAC/K,KAAK,uCAA+B,OAAO,EAAE,iBAAiB,EAAE,QAAQ,EAAE,8BAA8B,CAAA,KAAK,CAAC,CAAC;QAC/G,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;QACtC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC5B,CAAC;IAES,KAAK,CAAC,UAAU,CAAC,OAAiC,EAAE,wBAA2C;QACxG,MAAM,iCAAiC,CAAC,OAAO,EAAE,IAAI,CAAC,eAAe,EAAE,wBAAwB,CAAC,CAAC;IAClG,CAAC;CACD;AAED,SAAS,4BAA4B,CAAC,QAA4B;IACjE,IAAI,CAAC;QACJ,QAAQ,CAAC,gBAAgB,EAAE,CAAC;QAC5B,MAAM,MAAM,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;QACpC,QAAQ,CAAC,OAAO,EAAE,CAAC;QACnB,MAAM,CAAC,OAAO,EAAE,CAAC;IAClB,CAAC;IAAC,OAAO,GAAG,EAAE,CAAC;QACd,iBAAiB,CAAC,GAAG,CAAC,CAAC;IACxB,CAAC;AACF,CAAC;AAED,SAAS,mBAAmB,CAAC,GAAQ;IACpC,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;QACjC,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,qBAAqB,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC;QAC3D,mDAAmD;QAC7C,KAAM,CAAC,IAAI,GAAG,yBAAyB,CAAC;QAC9C,OAAO,KAAK,CAAC;IACd,CAAC;IACD,OAAO,IAAI,CAAC;AACb,CAAC;AAED,SAAS,iBAAiB,CAAC,SAAiB,EAAE,QAAgB;IAC7D,IAAI,OAAO,SAAS,KAAK,QAAQ,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,SAAS,GAAG,CAAC,EAAE,CAAC;QAC5E,OAAO,QAAQ,CAAC;IACjB,CAAC;IACD,IAAI,SAAS,GAAG,MAAM,CAAC,gBAAgB,EAAE,CAAC;QACzC,OAAO,MAAM,CAAC,gBAAgB,CAAC;IAChC,CAAC;IACD,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;AAC9B,CAAC;AAED,SAAS,cAAc,CAAC,GAAW,EAAE,GAAW;IAC/C,OAAO,GAAG,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC;QACzB,GAAG,IAAI,GAAG,CAAC;IACZ,CAAC;IACD,OAAO,GAAG,CAAC;AACZ,CAAC;AAED,SAAS,gBAAgB,CAAC,cAA8B,EAAE,iBAAyB;IAClF,OAAO,uBAAuB,cAAc,CAAC,sBAAsB,CAAC,cAAc,CAAC,EAAE,EAAE,CAAC,KAAK,iBAAiB,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC;AACjI,CAAC;AAED,SAAS,eAAe,CAAC,cAA8B,EAAE,iBAAyB,EAAE,WAAoB;IACvG,OAAO,GAAG,gBAAgB,CAAC,cAAc,EAAE,iBAAiB,CAAC,IAAI,WAAW,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,SAAS,GAAG,CAAC;AAC3G,CAAC;AAED,SAAS,gBAAgB,CAAC,OAAiC,EAAE,cAA8B;IAC1F,OAAO,GAAG,eAAe,CAAC,cAAc,EAAE,OAAO,CAAC,iBAAiB,EAAE,CAAC,CAAC,OAAO,CAAC,oBAAoB,CAAC,IAAI,OAAO,CAAC,SAAS,GAAG,CAAC;AAC9H,CAAC;AAED,SAAS,UAAU,CAAC,SAAiB;IACpC,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,KAAK,CAAC;AACvC,CAAC","file":"remoteAgentConnection.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancelablePromise, createCancelablePromise, promiseWithResolvers } from '../../../base/common/async.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { isCancellationError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { RemoteAuthorities } from '../../../base/common/network.js';\nimport * as performance from '../../../base/common/performance.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { IIPCLogger } from '../../../base/parts/ipc/common/ipc.js';\nimport { Client, ISocket, PersistentProtocol, ProtocolConstants, SocketCloseEventType } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { RemoteAgentConnectionContext } from './remoteAgentEnvironment.js';\nimport { RemoteAuthorityResolverError, RemoteConnection } from './remoteAuthorityResolver.js';\nimport { IRemoteSocketFactoryService } from './remoteSocketFactoryService.js';\nimport { ISignService } from '../../sign/common/sign.js';\n\nconst RECONNECT_TIMEOUT = 30 * 1000 /* 30s */;\n\nexport const enum ConnectionType {\n\tManagement = 1,\n\tExtensionHost = 2,\n\tTunnel = 3,\n}\n\nfunction connectionTypeToString(connectionType: ConnectionType): string {\n\tswitch (connectionType) {\n\t\tcase ConnectionType.Management:\n\t\t\treturn 'Management';\n\t\tcase ConnectionType.ExtensionHost:\n\t\t\treturn 'ExtensionHost';\n\t\tcase ConnectionType.Tunnel:\n\t\t\treturn 'Tunnel';\n\t}\n}\n\nexport interface AuthRequest {\n\ttype: 'auth';\n\tauth: string;\n\tdata: string;\n}\n\nexport interface SignRequest {\n\ttype: 'sign';\n\tdata: string;\n\tsignedData: string;\n}\n\nexport interface ConnectionTypeRequest {\n\ttype: 'connectionType';\n\tcommit?: string;\n\tsignedData: string;\n\tdesiredConnectionType?: ConnectionType;\n\targs?: any;\n}\n\nexport interface ErrorMessage {\n\ttype: 'error';\n\treason: string;\n}\n\nexport interface OKMessage {\n\ttype: 'ok';\n}\n\nexport type HandshakeMessage = AuthRequest | SignRequest | ConnectionTypeRequest | ErrorMessage | OKMessage;\n\n\ninterface ISimpleConnectionOptions<T extends RemoteConnection = RemoteConnection> {\n\tcommit: string | undefined;\n\tquality: string | undefined;\n\tconnectTo: T;\n\tconnectionToken: string | undefined;\n\treconnectionToken: string;\n\treconnectionProtocol: PersistentProtocol | null;\n\tremoteSocketFactoryService: IRemoteSocketFactoryService;\n\tsignService: ISignService;\n\tlogService: ILogService;\n}\n\nfunction createTimeoutCancellation(millis: number): CancellationToken {\n\tconst source = new CancellationTokenSource();\n\tsetTimeout(() => source.cancel(), millis);\n\treturn source.token;\n}\n\nfunction combineTimeoutCancellation(a: CancellationToken, b: CancellationToken): CancellationToken {\n\tif (a.isCancellationRequested || b.isCancellationRequested) {\n\t\treturn CancellationToken.Cancelled;\n\t}\n\tconst source = new CancellationTokenSource();\n\ta.onCancellationRequested(() => source.cancel());\n\tb.onCancellationRequested(() => source.cancel());\n\treturn source.token;\n}\n\nclass PromiseWithTimeout<T> {\n\n\tprivate _state: 'pending' | 'resolved' | 'rejected' | 'timedout';\n\tprivate readonly _disposables: DisposableStore;\n\tpublic readonly promise: Promise<T>;\n\tprivate readonly _resolvePromise: (value: T) => void;\n\tprivate readonly _rejectPromise: (err: any) => void;\n\n\tpublic get didTimeout(): boolean {\n\t\treturn (this._state === 'timedout');\n\t}\n\n\tconstructor(timeoutCancellationToken: CancellationToken) {\n\t\tthis._state = 'pending';\n\t\tthis._disposables = new DisposableStore();\n\n\t\t({ promise: this.promise, resolve: this._resolvePromise, reject: this._rejectPromise } = promiseWithResolvers<T>());\n\n\t\tif (timeoutCancellationToken.isCancellationRequested) {\n\t\t\tthis._timeout();\n\t\t} else {\n\t\t\tthis._disposables.add(timeoutCancellationToken.onCancellationRequested(() => this._timeout()));\n\t\t}\n\t}\n\n\tpublic registerDisposable(disposable: IDisposable): void {\n\t\tif (this._state === 'pending') {\n\t\t\tthis._disposables.add(disposable);\n\t\t} else {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}\n\n\tprivate _timeout(): void {\n\t\tif (this._state !== 'pending') {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = 'timedout';\n\t\tthis._rejectPromise(this._createTimeoutError());\n\t}\n\n\tprivate _createTimeoutError(): Error {\n\t\tconst err: any = new Error('Time limit reached');\n\t\terr.code = 'ETIMEDOUT';\n\t\terr.syscall = 'connect';\n\t\treturn err;\n\t}\n\n\tpublic resolve(value: T): void {\n\t\tif (this._state !== 'pending') {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = 'resolved';\n\t\tthis._resolvePromise(value);\n\t}\n\n\tpublic reject(err: any): void {\n\t\tif (this._state !== 'pending') {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = 'rejected';\n\t\tthis._rejectPromise(err);\n\t}\n}\n\nfunction readOneControlMessage<T>(protocol: PersistentProtocol, timeoutCancellationToken: CancellationToken): Promise<T> {\n\tconst result = new PromiseWithTimeout<T>(timeoutCancellationToken);\n\tresult.registerDisposable(protocol.onControlMessage(raw => {\n\t\tconst msg: T = JSON.parse(raw.toString());\n\t\tconst error = getErrorFromMessage(msg);\n\t\tif (error) {\n\t\t\tresult.reject(error);\n\t\t} else {\n\t\t\tresult.resolve(msg);\n\t\t}\n\t}));\n\treturn result.promise;\n}\n\nfunction createSocket<T extends RemoteConnection>(logService: ILogService, remoteSocketFactoryService: IRemoteSocketFactoryService, connectTo: T, path: string, query: string, debugConnectionType: string, debugLabel: string, timeoutCancellationToken: CancellationToken): Promise<ISocket> {\n\tconst result = new PromiseWithTimeout<ISocket>(timeoutCancellationToken);\n\tconst sw = StopWatch.create(false);\n\tlogService.info(`Creating a socket (${debugLabel})...`);\n\tperformance.mark(`code/willCreateSocket/${debugConnectionType}`);\n\n\tremoteSocketFactoryService.connect(connectTo, path, query, debugLabel).then((socket) => {\n\t\tif (result.didTimeout) {\n\t\t\tperformance.mark(`code/didCreateSocketError/${debugConnectionType}`);\n\t\t\tlogService.info(`Creating a socket (${debugLabel}) finished after ${sw.elapsed()} ms, but this is too late and has timed out already.`);\n\t\t\tsocket?.dispose();\n\t\t} else {\n\t\t\tperformance.mark(`code/didCreateSocketOK/${debugConnectionType}`);\n\t\t\tlogService.info(`Creating a socket (${debugLabel}) was successful after ${sw.elapsed()} ms.`);\n\t\t\tresult.resolve(socket);\n\t\t}\n\t}, (err) => {\n\t\tperformance.mark(`code/didCreateSocketError/${debugConnectionType}`);\n\t\tlogService.info(`Creating a socket (${debugLabel}) returned an error after ${sw.elapsed()} ms.`);\n\t\tlogService.error(err);\n\t\tresult.reject(err);\n\t});\n\n\treturn result.promise;\n}\n\nfunction raceWithTimeoutCancellation<T>(promise: Promise<T>, timeoutCancellationToken: CancellationToken): Promise<T> {\n\tconst result = new PromiseWithTimeout<T>(timeoutCancellationToken);\n\tpromise.then(\n\t\t(res) => {\n\t\t\tif (!result.didTimeout) {\n\t\t\t\tresult.resolve(res);\n\t\t\t}\n\t\t},\n\t\t(err) => {\n\t\t\tif (!result.didTimeout) {\n\t\t\t\tresult.reject(err);\n\t\t\t}\n\t\t}\n\t);\n\treturn result.promise;\n}\n\nasync function connectToRemoteExtensionHostAgent<T extends RemoteConnection>(options: ISimpleConnectionOptions<T>, connectionType: ConnectionType, args: any | undefined, timeoutCancellationToken: CancellationToken): Promise<{ protocol: PersistentProtocol; ownsProtocol: boolean }> {\n\tconst logPrefix = connectLogPrefix(options, connectionType);\n\n\toptions.logService.trace(`${logPrefix} 1/6. invoking socketFactory.connect().`);\n\n\tlet socket: ISocket;\n\ttry {\n\t\tsocket = await createSocket(options.logService, options.remoteSocketFactoryService, options.connectTo, RemoteAuthorities.getServerRootPath(), `reconnectionToken=${options.reconnectionToken}&reconnection=${options.reconnectionProtocol ? 'true' : 'false'}`, connectionTypeToString(connectionType), `renderer-${connectionTypeToString(connectionType)}-${options.reconnectionToken}`, timeoutCancellationToken);\n\t} catch (error) {\n\t\toptions.logService.error(`${logPrefix} socketFactory.connect() failed or timed out. Error:`);\n\t\toptions.logService.error(error);\n\t\tthrow error;\n\t}\n\n\toptions.logService.trace(`${logPrefix} 2/6. socketFactory.connect() was successful.`);\n\n\tlet protocol: PersistentProtocol;\n\tlet ownsProtocol: boolean;\n\tif (options.reconnectionProtocol) {\n\t\toptions.reconnectionProtocol.beginAcceptReconnection(socket, null);\n\t\tprotocol = options.reconnectionProtocol;\n\t\townsProtocol = false;\n\t} else {\n\t\tprotocol = new PersistentProtocol({ socket });\n\t\townsProtocol = true;\n\t}\n\n\toptions.logService.trace(`${logPrefix} 3/6. sending AuthRequest control message.`);\n\tconst message = await raceWithTimeoutCancellation(options.signService.createNewMessage(generateUuid()), timeoutCancellationToken);\n\n\tconst authRequest: AuthRequest = {\n\t\ttype: 'auth',\n\t\tauth: options.connectionToken || '00000000000000000000',\n\t\tdata: message.data\n\t};\n\tprotocol.sendControl(VSBuffer.fromString(JSON.stringify(authRequest)));\n\n\ttry {\n\t\tconst msg = await readOneControlMessage<HandshakeMessage>(protocol, combineTimeoutCancellation(timeoutCancellationToken, createTimeoutCancellation(10000)));\n\n\t\tif (msg.type !== 'sign' || typeof msg.data !== 'string') {\n\t\t\tconst error: any = new Error('Unexpected handshake message');\n\t\t\terror.code = 'VSCODE_CONNECTION_ERROR';\n\t\t\tthrow error;\n\t\t}\n\n\t\toptions.logService.trace(`${logPrefix} 4/6. received SignRequest control message.`);\n\n\t\tconst isValid = await raceWithTimeoutCancellation(options.signService.validate(message, msg.signedData), timeoutCancellationToken);\n\t\tif (!isValid) {\n\t\t\tconst error: any = new Error('Refused to connect to unsupported server');\n\t\t\terror.code = 'VSCODE_CONNECTION_ERROR';\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst signed = await raceWithTimeoutCancellation(options.signService.sign(msg.data), timeoutCancellationToken);\n\t\tconst connTypeRequest: ConnectionTypeRequest = {\n\t\t\ttype: 'connectionType',\n\t\t\tcommit: options.commit,\n\t\t\tsignedData: signed,\n\t\t\tdesiredConnectionType: connectionType\n\t\t};\n\t\tif (args) {\n\t\t\tconnTypeRequest.args = args;\n\t\t}\n\n\t\toptions.logService.trace(`${logPrefix} 5/6. sending ConnectionTypeRequest control message.`);\n\t\tprotocol.sendControl(VSBuffer.fromString(JSON.stringify(connTypeRequest)));\n\n\t\treturn { protocol, ownsProtocol };\n\n\t} catch (error) {\n\t\tif (error && error.code === 'ETIMEDOUT') {\n\t\t\toptions.logService.error(`${logPrefix} the handshake timed out. Error:`);\n\t\t\toptions.logService.error(error);\n\t\t}\n\t\tif (error && error.code === 'VSCODE_CONNECTION_ERROR') {\n\t\t\toptions.logService.error(`${logPrefix} received error control message when negotiating connection. Error:`);\n\t\t\toptions.logService.error(error);\n\t\t}\n\t\tif (ownsProtocol) {\n\t\t\tsafeDisposeProtocolAndSocket(protocol);\n\t\t}\n\t\tthrow error;\n\t}\n}\n\ninterface IManagementConnectionResult {\n\tprotocol: PersistentProtocol;\n}\n\nasync function connectToRemoteExtensionHostAgentAndReadOneMessage<T>(options: ISimpleConnectionOptions, connectionType: ConnectionType, args: any | undefined, timeoutCancellationToken: CancellationToken): Promise<{ protocol: PersistentProtocol; firstMessage: T }> {\n\tconst startTime = Date.now();\n\tconst logPrefix = connectLogPrefix(options, connectionType);\n\tconst { protocol, ownsProtocol } = await connectToRemoteExtensionHostAgent(options, connectionType, args, timeoutCancellationToken);\n\tconst result = new PromiseWithTimeout<{ protocol: PersistentProtocol; firstMessage: T }>(timeoutCancellationToken);\n\tresult.registerDisposable(protocol.onControlMessage(raw => {\n\t\tconst msg: T = JSON.parse(raw.toString());\n\t\tconst error = getErrorFromMessage(msg);\n\t\tif (error) {\n\t\t\toptions.logService.error(`${logPrefix} received error control message when negotiating connection. Error:`);\n\t\t\toptions.logService.error(error);\n\t\t\tif (ownsProtocol) {\n\t\t\t\tsafeDisposeProtocolAndSocket(protocol);\n\t\t\t}\n\t\t\tresult.reject(error);\n\t\t} else {\n\t\t\toptions.reconnectionProtocol?.endAcceptReconnection();\n\t\t\toptions.logService.trace(`${logPrefix} 6/6. handshake finished, connection is up and running after ${logElapsed(startTime)}!`);\n\t\t\tresult.resolve({ protocol, firstMessage: msg });\n\t\t}\n\t}));\n\treturn result.promise;\n}\n\nasync function doConnectRemoteAgentManagement(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<IManagementConnectionResult> {\n\tconst { protocol } = await connectToRemoteExtensionHostAgentAndReadOneMessage(options, ConnectionType.Management, undefined, timeoutCancellationToken);\n\treturn { protocol };\n}\n\nexport interface IRemoteExtensionHostStartParams {\n\tlanguage: string;\n\tdebugId?: string;\n\tbreak?: boolean;\n\tport?: number | null;\n\tenv?: { [key: string]: string | null };\n}\n\ninterface IExtensionHostConnectionResult {\n\tprotocol: PersistentProtocol;\n\tdebugPort?: number;\n}\n\nasync function doConnectRemoteAgentExtensionHost(options: ISimpleConnectionOptions, startArguments: IRemoteExtensionHostStartParams, timeoutCancellationToken: CancellationToken): Promise<IExtensionHostConnectionResult> {\n\tconst { protocol, firstMessage } = await connectToRemoteExtensionHostAgentAndReadOneMessage<{ debugPort?: number }>(options, ConnectionType.ExtensionHost, startArguments, timeoutCancellationToken);\n\tconst debugPort = firstMessage && firstMessage.debugPort;\n\treturn { protocol, debugPort };\n}\n\nexport interface ITunnelConnectionStartParams {\n\thost: string;\n\tport: number;\n}\n\nasync function doConnectRemoteAgentTunnel(options: ISimpleConnectionOptions, startParams: ITunnelConnectionStartParams, timeoutCancellationToken: CancellationToken): Promise<PersistentProtocol> {\n\tconst startTime = Date.now();\n\tconst logPrefix = connectLogPrefix(options, ConnectionType.Tunnel);\n\tconst { protocol } = await connectToRemoteExtensionHostAgent(options, ConnectionType.Tunnel, startParams, timeoutCancellationToken);\n\toptions.logService.trace(`${logPrefix} 6/6. handshake finished, connection is up and running after ${logElapsed(startTime)}!`);\n\treturn protocol;\n}\n\nexport interface IConnectionOptions<T extends RemoteConnection = RemoteConnection> {\n\tcommit: string | undefined;\n\tquality: string | undefined;\n\taddressProvider: IAddressProvider<T>;\n\tremoteSocketFactoryService: IRemoteSocketFactoryService;\n\tsignService: ISignService;\n\tlogService: ILogService;\n\tipcLogger: IIPCLogger | null;\n}\n\nasync function resolveConnectionOptions<T extends RemoteConnection>(options: IConnectionOptions<T>, reconnectionToken: string, reconnectionProtocol: PersistentProtocol | null): Promise<ISimpleConnectionOptions<T>> {\n\tconst { connectTo, connectionToken } = await options.addressProvider.getAddress();\n\treturn {\n\t\tcommit: options.commit,\n\t\tquality: options.quality,\n\t\tconnectTo,\n\t\tconnectionToken: connectionToken,\n\t\treconnectionToken: reconnectionToken,\n\t\treconnectionProtocol: reconnectionProtocol,\n\t\tremoteSocketFactoryService: options.remoteSocketFactoryService,\n\t\tsignService: options.signService,\n\t\tlogService: options.logService\n\t};\n}\n\nexport interface IAddress<T extends RemoteConnection = RemoteConnection> {\n\tconnectTo: T;\n\tconnectionToken: string | undefined;\n}\n\nexport interface IAddressProvider<T extends RemoteConnection = RemoteConnection> {\n\tgetAddress(): Promise<IAddress<T>>;\n}\n\nexport async function connectRemoteAgentManagement(options: IConnectionOptions, remoteAuthority: string, clientId: string): Promise<ManagementPersistentConnection> {\n\treturn createInitialConnection(\n\t\toptions,\n\t\tasync (simpleOptions) => {\n\t\t\tconst { protocol } = await doConnectRemoteAgentManagement(simpleOptions, CancellationToken.None);\n\t\t\treturn new ManagementPersistentConnection(options, remoteAuthority, clientId, simpleOptions.reconnectionToken, protocol);\n\t\t}\n\t);\n}\n\nexport async function connectRemoteAgentExtensionHost(options: IConnectionOptions, startArguments: IRemoteExtensionHostStartParams): Promise<ExtensionHostPersistentConnection> {\n\treturn createInitialConnection(\n\t\toptions,\n\t\tasync (simpleOptions) => {\n\t\t\tconst { protocol, debugPort } = await doConnectRemoteAgentExtensionHost(simpleOptions, startArguments, CancellationToken.None);\n\t\t\treturn new ExtensionHostPersistentConnection(options, startArguments, simpleOptions.reconnectionToken, protocol, debugPort);\n\t\t}\n\t);\n}\n\n/**\n * Will attempt to connect 5 times. If it fails 5 consecutive times, it will give up.\n */\nasync function createInitialConnection<T extends PersistentConnection, O extends RemoteConnection>(options: IConnectionOptions<O>, connectionFactory: (simpleOptions: ISimpleConnectionOptions<O>) => Promise<T>): Promise<T> {\n\tconst MAX_ATTEMPTS = 5;\n\n\tfor (let attempt = 1; ; attempt++) {\n\t\ttry {\n\t\t\tconst reconnectionToken = generateUuid();\n\t\t\tconst simpleOptions = await resolveConnectionOptions(options, reconnectionToken, null);\n\t\t\tconst result = await connectionFactory(simpleOptions);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tif (attempt < MAX_ATTEMPTS) {\n\t\t\t\toptions.logService.error(`[remote-connection][attempt ${attempt}] An error occurred in initial connection! Will retry... Error:`);\n\t\t\t\toptions.logService.error(err);\n\t\t\t} else {\n\t\t\t\toptions.logService.error(`[remote-connection][attempt ${attempt}]  An error occurred in initial connection! It will be treated as a permanent error. Error:`);\n\t\t\t\toptions.logService.error(err);\n\t\t\t\tPersistentConnection.triggerPermanentFailure(0, 0, RemoteAuthorityResolverError.isHandled(err));\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport async function connectRemoteAgentTunnel(options: IConnectionOptions, tunnelRemoteHost: string, tunnelRemotePort: number): Promise<PersistentProtocol> {\n\tconst simpleOptions = await resolveConnectionOptions(options, generateUuid(), null);\n\tconst protocol = await doConnectRemoteAgentTunnel(simpleOptions, { host: tunnelRemoteHost, port: tunnelRemotePort }, CancellationToken.None);\n\treturn protocol;\n}\n\nfunction sleep(seconds: number): CancelablePromise<void> {\n\treturn createCancelablePromise(token => {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst timeout = setTimeout(resolve, seconds * 1000);\n\t\t\ttoken.onCancellationRequested(() => {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t});\n}\n\nexport const enum PersistentConnectionEventType {\n\tConnectionLost,\n\tReconnectionWait,\n\tReconnectionRunning,\n\tReconnectionPermanentFailure,\n\tConnectionGain\n}\nexport class ConnectionLostEvent {\n\tpublic readonly type = PersistentConnectionEventType.ConnectionLost;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number\n\t) { }\n}\nexport class ReconnectionWaitEvent {\n\tpublic readonly type = PersistentConnectionEventType.ReconnectionWait;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly durationSeconds: number,\n\t\tprivate readonly cancellableTimer: CancelablePromise<void>\n\t) { }\n\n\tpublic skipWait(): void {\n\t\tthis.cancellableTimer.cancel();\n\t}\n}\nexport class ReconnectionRunningEvent {\n\tpublic readonly type = PersistentConnectionEventType.ReconnectionRunning;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number\n\t) { }\n}\nexport class ConnectionGainEvent {\n\tpublic readonly type = PersistentConnectionEventType.ConnectionGain;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number\n\t) { }\n}\nexport class ReconnectionPermanentFailureEvent {\n\tpublic readonly type = PersistentConnectionEventType.ReconnectionPermanentFailure;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number,\n\t\tpublic readonly handled: boolean\n\t) { }\n}\nexport type PersistentConnectionEvent = ConnectionGainEvent | ConnectionLostEvent | ReconnectionWaitEvent | ReconnectionRunningEvent | ReconnectionPermanentFailureEvent;\n\nexport abstract class PersistentConnection extends Disposable {\n\n\tpublic static triggerPermanentFailure(millisSinceLastIncomingData: number, attempt: number, handled: boolean): void {\n\t\tthis._permanentFailure = true;\n\t\tthis._permanentFailureMillisSinceLastIncomingData = millisSinceLastIncomingData;\n\t\tthis._permanentFailureAttempt = attempt;\n\t\tthis._permanentFailureHandled = handled;\n\t\tthis._instances.forEach(instance => instance._gotoPermanentFailure(this._permanentFailureMillisSinceLastIncomingData, this._permanentFailureAttempt, this._permanentFailureHandled));\n\t}\n\n\tpublic static debugTriggerReconnection() {\n\t\tthis._instances.forEach(instance => instance._beginReconnecting());\n\t}\n\n\tpublic static debugPauseSocketWriting() {\n\t\tthis._instances.forEach(instance => instance._pauseSocketWriting());\n\t}\n\n\tprivate static _permanentFailure: boolean = false;\n\tprivate static _permanentFailureMillisSinceLastIncomingData: number = 0;\n\tprivate static _permanentFailureAttempt: number = 0;\n\tprivate static _permanentFailureHandled: boolean = false;\n\tprivate static _instances: PersistentConnection[] = [];\n\n\tprivate readonly _onDidStateChange = this._register(new Emitter<PersistentConnectionEvent>());\n\tpublic readonly onDidStateChange = this._onDidStateChange.event;\n\n\tprivate _permanentFailure: boolean = false;\n\tprivate get _isPermanentFailure(): boolean {\n\t\treturn this._permanentFailure || PersistentConnection._permanentFailure;\n\t}\n\n\tprivate _isReconnecting: boolean = false;\n\tprivate _isDisposed: boolean = false;\n\tprivate _reconnectionGraceTime: number = ProtocolConstants.ReconnectionGraceTime;\n\n\tconstructor(\n\t\tprivate readonly _connectionType: ConnectionType,\n\t\tprotected readonly _options: IConnectionOptions,\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly protocol: PersistentProtocol,\n\t\tprivate readonly _reconnectionFailureIsFatal: boolean\n\t) {\n\t\tsuper();\n\n\n\t\tthis._onDidStateChange.fire(new ConnectionGainEvent(this.reconnectionToken, 0, 0));\n\n\t\tthis._register(protocol.onSocketClose((e) => {\n\t\t\tconst logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);\n\t\t\tif (!e) {\n\t\t\t\tthis._options.logService.info(`${logPrefix} received socket close event.`);\n\t\t\t} else if (e.type === SocketCloseEventType.NodeSocketCloseEvent) {\n\t\t\t\tthis._options.logService.info(`${logPrefix} received socket close event (hadError: ${e.hadError}).`);\n\t\t\t\tif (e.error) {\n\t\t\t\t\tthis._options.logService.error(e.error);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._options.logService.info(`${logPrefix} received socket close event (wasClean: ${e.wasClean}, code: ${e.code}, reason: ${e.reason}).`);\n\t\t\t\tif (e.event) {\n\t\t\t\t\tthis._options.logService.error(e.event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._beginReconnecting();\n\t\t}));\n\t\tthis._register(protocol.onSocketTimeout((e) => {\n\t\t\tconst logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);\n\t\t\tthis._options.logService.info(`${logPrefix} received socket timeout event (unacknowledgedMsgCount: ${e.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${e.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${e.timeSinceLastReceivedSomeData}).`);\n\t\t\tthis._beginReconnecting();\n\t\t}));\n\n\t\tPersistentConnection._instances.push(this);\n\t\tthis._register(toDisposable(() => {\n\t\t\tconst myIndex = PersistentConnection._instances.indexOf(this);\n\t\t\tif (myIndex >= 0) {\n\t\t\t\tPersistentConnection._instances.splice(myIndex, 1);\n\t\t\t}\n\t\t}));\n\n\t\tif (this._isPermanentFailure) {\n\t\t\tthis._gotoPermanentFailure(PersistentConnection._permanentFailureMillisSinceLastIncomingData, PersistentConnection._permanentFailureAttempt, PersistentConnection._permanentFailureHandled);\n\t\t}\n\t}\n\n\tpublic updateGraceTime(graceTime: number): void {\n\t\tconst sanitizedGrace = sanitizeGraceTime(graceTime, ProtocolConstants.ReconnectionGraceTime);\n\t\tconst logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, false);\n\t\tthis._options.logService.trace(`${logPrefix} Applying reconnection grace time: ${sanitizedGrace}ms (${Math.floor(sanitizedGrace / 1000)}s)`);\n\t\tthis._reconnectionGraceTime = sanitizedGrace;\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\tthis._isDisposed = true;\n\t}\n\n\tprivate async _beginReconnecting(): Promise<void> {\n\t\t// Only have one reconnection loop active at a time.\n\t\tif (this._isReconnecting) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis._isReconnecting = true;\n\t\t\tawait this._runReconnectingLoop();\n\t\t} finally {\n\t\t\tthis._isReconnecting = false;\n\t\t}\n\t}\n\n\tprivate async _runReconnectingLoop(): Promise<void> {\n\t\tif (this._isPermanentFailure || this._isDisposed) {\n\t\t\t// no more attempts!\n\t\t\treturn;\n\t\t}\n\t\tconst logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);\n\t\tthis._options.logService.info(`${logPrefix} starting reconnecting loop. You can get more information with the trace log level.`);\n\t\tthis._onDidStateChange.fire(new ConnectionLostEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData()));\n\t\tconst TIMES = [0, 5, 5, 10, 10, 10, 10, 10, 30];\n\t\tconst graceTime = this._reconnectionGraceTime;\n\t\tthis._options.logService.info(`${logPrefix} starting reconnection with grace time: ${graceTime}ms (${Math.floor(graceTime / 1000)}s)`);\n\t\tif (graceTime <= 0) {\n\t\t\tthis._options.logService.error(`${logPrefix} reconnection grace time is set to 0ms, will not attempt to reconnect.`);\n\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), 0, false);\n\t\t\treturn;\n\t\t}\n\t\tconst loopStartTime = Date.now();\n\t\tlet attempt = -1;\n\t\tdo {\n\t\t\tattempt++;\n\t\t\tconst waitTime = (attempt < TIMES.length ? TIMES[attempt] : TIMES[TIMES.length - 1]);\n\t\t\ttry {\n\t\t\t\tif (waitTime > 0) {\n\t\t\t\t\tconst sleepPromise = sleep(waitTime);\n\t\t\t\t\tthis._onDidStateChange.fire(new ReconnectionWaitEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), waitTime, sleepPromise));\n\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} waiting for ${waitTime} seconds before reconnecting...`);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait sleepPromise;\n\t\t\t\t\t} catch { } // User canceled timer\n\t\t\t\t}\n\n\t\t\t\tif (this._isPermanentFailure) {\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} permanent failure occurred while running the reconnecting loop.`);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// connection was lost, let's try to re-establish it\n\t\t\t\tthis._onDidStateChange.fire(new ReconnectionRunningEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), attempt + 1));\n\t\t\t\tthis._options.logService.info(`${logPrefix} resolving connection...`);\n\t\t\t\tconst simpleOptions = await resolveConnectionOptions(this._options, this.reconnectionToken, this.protocol);\n\t\t\t\tthis._options.logService.info(`${logPrefix} connecting to ${simpleOptions.connectTo}...`);\n\t\t\t\tawait this._reconnect(simpleOptions, createTimeoutCancellation(RECONNECT_TIMEOUT));\n\t\t\t\tthis._options.logService.info(`${logPrefix} reconnected!`);\n\t\t\t\tthis._onDidStateChange.fire(new ConnectionGainEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), attempt + 1));\n\n\t\t\t\tbreak;\n\t\t\t} catch (err) {\n\t\t\t\tif (err.code === 'VSCODE_CONNECTION_ERROR') {\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} A permanent error occurred in the reconnecting loop! Will give up now! Error:`);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (Date.now() - loopStartTime >= graceTime) {\n\t\t\t\t\tconst graceSeconds = Math.round(graceTime / 1000);\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} An error occurred while reconnecting, but it will be treated as a permanent error because the reconnection grace time (${graceSeconds}s) has expired! Will give up now! Error:`);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (RemoteAuthorityResolverError.isTemporarilyNotAvailable(err)) {\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} A temporarily not available error occurred while trying to reconnect, will try again...`);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((err.code === 'ETIMEDOUT' || err.code === 'ENETUNREACH' || err.code === 'ECONNREFUSED' || err.code === 'ECONNRESET') && err.syscall === 'connect') {\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} A network error occurred while trying to reconnect, will try again...`);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isCancellationError(err)) {\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} A promise cancelation error occurred while trying to reconnect, will try again...`);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (err instanceof RemoteAuthorityResolverError) {\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} A RemoteAuthorityResolverError occurred while trying to reconnect. Will give up now! Error:`);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, RemoteAuthorityResolverError.isHandled(err));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis._options.logService.error(`${logPrefix} An unknown error occurred while trying to reconnect, since this is an unknown case, it will be treated as a permanent error! Will give up now! Error:`);\n\t\t\t\tthis._options.logService.error(err);\n\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!this._isPermanentFailure && !this._isDisposed);\n\t}\n\n\tprivate _onReconnectionPermanentFailure(millisSinceLastIncomingData: number, attempt: number, handled: boolean): void {\n\t\tif (this._reconnectionFailureIsFatal) {\n\t\t\tPersistentConnection.triggerPermanentFailure(millisSinceLastIncomingData, attempt, handled);\n\t\t} else {\n\t\t\tthis._gotoPermanentFailure(millisSinceLastIncomingData, attempt, handled);\n\t\t}\n\t}\n\n\tprivate _gotoPermanentFailure(millisSinceLastIncomingData: number, attempt: number, handled: boolean): void {\n\t\tthis._onDidStateChange.fire(new ReconnectionPermanentFailureEvent(this.reconnectionToken, millisSinceLastIncomingData, attempt, handled));\n\t\tsafeDisposeProtocolAndSocket(this.protocol);\n\t}\n\n\tprivate _pauseSocketWriting(): void {\n\t\tthis.protocol.pauseSocketWriting();\n\t}\n\n\tprotected abstract _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void>;\n}\n\nexport class ManagementPersistentConnection extends PersistentConnection {\n\n\tpublic readonly client: Client<RemoteAgentConnectionContext>;\n\n\tconstructor(options: IConnectionOptions, remoteAuthority: string, clientId: string, reconnectionToken: string, protocol: PersistentProtocol) {\n\t\tsuper(ConnectionType.Management, options, reconnectionToken, protocol, /*reconnectionFailureIsFatal*/true);\n\t\tthis.client = this._register(new Client<RemoteAgentConnectionContext>(protocol, {\n\t\t\tremoteAuthority: remoteAuthority,\n\t\t\tclientId: clientId\n\t\t}, options.ipcLogger));\n\t}\n\n\tprotected async _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void> {\n\t\tawait doConnectRemoteAgentManagement(options, timeoutCancellationToken);\n\t}\n}\n\nexport class ExtensionHostPersistentConnection extends PersistentConnection {\n\n\tprivate readonly _startArguments: IRemoteExtensionHostStartParams;\n\tpublic readonly debugPort: number | undefined;\n\n\tconstructor(options: IConnectionOptions, startArguments: IRemoteExtensionHostStartParams, reconnectionToken: string, protocol: PersistentProtocol, debugPort: number | undefined) {\n\t\tsuper(ConnectionType.ExtensionHost, options, reconnectionToken, protocol, /*reconnectionFailureIsFatal*/false);\n\t\tthis._startArguments = startArguments;\n\t\tthis.debugPort = debugPort;\n\t}\n\n\tprotected async _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void> {\n\t\tawait doConnectRemoteAgentExtensionHost(options, this._startArguments, timeoutCancellationToken);\n\t}\n}\n\nfunction safeDisposeProtocolAndSocket(protocol: PersistentProtocol): void {\n\ttry {\n\t\tprotocol.acceptDisconnect();\n\t\tconst socket = protocol.getSocket();\n\t\tprotocol.dispose();\n\t\tsocket.dispose();\n\t} catch (err) {\n\t\tonUnexpectedError(err);\n\t}\n}\n\nfunction getErrorFromMessage(msg: any): Error | null {\n\tif (msg && msg.type === 'error') {\n\t\tconst error = new Error(`Connection error: ${msg.reason}`);\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t(<any>error).code = 'VSCODE_CONNECTION_ERROR';\n\t\treturn error;\n\t}\n\treturn null;\n}\n\nfunction sanitizeGraceTime(candidate: number, fallback: number): number {\n\tif (typeof candidate !== 'number' || !isFinite(candidate) || candidate < 0) {\n\t\treturn fallback;\n\t}\n\tif (candidate > Number.MAX_SAFE_INTEGER) {\n\t\treturn Number.MAX_SAFE_INTEGER;\n\t}\n\treturn Math.floor(candidate);\n}\n\nfunction stringRightPad(str: string, len: number): string {\n\twhile (str.length < len) {\n\t\tstr += ' ';\n\t}\n\treturn str;\n}\n\nfunction _commonLogPrefix(connectionType: ConnectionType, reconnectionToken: string): string {\n\treturn `[remote-connection][${stringRightPad(connectionTypeToString(connectionType), 13)}][${reconnectionToken.substr(0, 5)}]`;\n}\n\nfunction commonLogPrefix(connectionType: ConnectionType, reconnectionToken: string, isReconnect: boolean): string {\n\treturn `${_commonLogPrefix(connectionType, reconnectionToken)}[${isReconnect ? 'reconnect' : 'initial'}]`;\n}\n\nfunction connectLogPrefix(options: ISimpleConnectionOptions, connectionType: ConnectionType): string {\n\treturn `${commonLogPrefix(connectionType, options.reconnectionToken, !!options.reconnectionProtocol)}[${options.connectTo}]`;\n}\n\nfunction logElapsed(startTime: number): string {\n\treturn `${Date.now() - startTime} ms`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancelablePromise, createCancelablePromise, promiseWithResolvers } from '../../../base/common/async.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { isCancellationError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { RemoteAuthorities } from '../../../base/common/network.js';\nimport * as performance from '../../../base/common/performance.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { IIPCLogger } from '../../../base/parts/ipc/common/ipc.js';\nimport { Client, ISocket, PersistentProtocol, ProtocolConstants, SocketCloseEventType } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { RemoteAgentConnectionContext } from './remoteAgentEnvironment.js';\nimport { RemoteAuthorityResolverError, RemoteConnection } from './remoteAuthorityResolver.js';\nimport { IRemoteSocketFactoryService } from './remoteSocketFactoryService.js';\nimport { ISignService } from '../../sign/common/sign.js';\n\nconst RECONNECT_TIMEOUT = 30 * 1000 /* 30s */;\n\nexport const enum ConnectionType {\n\tManagement = 1,\n\tExtensionHost = 2,\n\tTunnel = 3,\n}\n\nfunction connectionTypeToString(connectionType: ConnectionType): string {\n\tswitch (connectionType) {\n\t\tcase ConnectionType.Management:\n\t\t\treturn 'Management';\n\t\tcase ConnectionType.ExtensionHost:\n\t\t\treturn 'ExtensionHost';\n\t\tcase ConnectionType.Tunnel:\n\t\t\treturn 'Tunnel';\n\t}\n}\n\nexport interface AuthRequest {\n\ttype: 'auth';\n\tauth: string;\n\tdata: string;\n}\n\nexport interface SignRequest {\n\ttype: 'sign';\n\tdata: string;\n\tsignedData: string;\n}\n\nexport interface ConnectionTypeRequest {\n\ttype: 'connectionType';\n\tcommit?: string;\n\tsignedData: string;\n\tdesiredConnectionType?: ConnectionType;\n\targs?: any;\n}\n\nexport interface ErrorMessage {\n\ttype: 'error';\n\treason: string;\n}\n\nexport interface OKMessage {\n\ttype: 'ok';\n}\n\nexport type HandshakeMessage = AuthRequest | SignRequest | ConnectionTypeRequest | ErrorMessage | OKMessage;\n\n\ninterface ISimpleConnectionOptions<T extends RemoteConnection = RemoteConnection> {\n\tcommit: string | undefined;\n\tquality: string | undefined;\n\tconnectTo: T;\n\tconnectionToken: string | undefined;\n\treconnectionToken: string;\n\treconnectionProtocol: PersistentProtocol | null;\n\tremoteSocketFactoryService: IRemoteSocketFactoryService;\n\tsignService: ISignService;\n\tlogService: ILogService;\n}\n\nfunction createTimeoutCancellation(millis: number): CancellationToken {\n\tconst source = new CancellationTokenSource();\n\tsetTimeout(() => source.cancel(), millis);\n\treturn source.token;\n}\n\nfunction combineTimeoutCancellation(a: CancellationToken, b: CancellationToken): CancellationToken {\n\tif (a.isCancellationRequested || b.isCancellationRequested) {\n\t\treturn CancellationToken.Cancelled;\n\t}\n\tconst source = new CancellationTokenSource();\n\ta.onCancellationRequested(() => source.cancel());\n\tb.onCancellationRequested(() => source.cancel());\n\treturn source.token;\n}\n\nclass PromiseWithTimeout<T> {\n\n\tprivate _state: 'pending' | 'resolved' | 'rejected' | 'timedout';\n\tprivate readonly _disposables: DisposableStore;\n\tpublic readonly promise: Promise<T>;\n\tprivate readonly _resolvePromise: (value: T) => void;\n\tprivate readonly _rejectPromise: (err: any) => void;\n\n\tpublic get didTimeout(): boolean {\n\t\treturn (this._state === 'timedout');\n\t}\n\n\tconstructor(timeoutCancellationToken: CancellationToken) {\n\t\tthis._state = 'pending';\n\t\tthis._disposables = new DisposableStore();\n\n\t\t({ promise: this.promise, resolve: this._resolvePromise, reject: this._rejectPromise } = promiseWithResolvers<T>());\n\n\t\tif (timeoutCancellationToken.isCancellationRequested) {\n\t\t\tthis._timeout();\n\t\t} else {\n\t\t\tthis._disposables.add(timeoutCancellationToken.onCancellationRequested(() => this._timeout()));\n\t\t}\n\t}\n\n\tpublic registerDisposable(disposable: IDisposable): void {\n\t\tif (this._state === 'pending') {\n\t\t\tthis._disposables.add(disposable);\n\t\t} else {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}\n\n\tprivate _timeout(): void {\n\t\tif (this._state !== 'pending') {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = 'timedout';\n\t\tthis._rejectPromise(this._createTimeoutError());\n\t}\n\n\tprivate _createTimeoutError(): Error {\n\t\tconst err: any = new Error('Time limit reached');\n\t\terr.code = 'ETIMEDOUT';\n\t\terr.syscall = 'connect';\n\t\treturn err;\n\t}\n\n\tpublic resolve(value: T): void {\n\t\tif (this._state !== 'pending') {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = 'resolved';\n\t\tthis._resolvePromise(value);\n\t}\n\n\tpublic reject(err: any): void {\n\t\tif (this._state !== 'pending') {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposables.dispose();\n\t\tthis._state = 'rejected';\n\t\tthis._rejectPromise(err);\n\t}\n}\n\nfunction readOneControlMessage<T>(protocol: PersistentProtocol, timeoutCancellationToken: CancellationToken): Promise<T> {\n\tconst result = new PromiseWithTimeout<T>(timeoutCancellationToken);\n\tresult.registerDisposable(protocol.onControlMessage(raw => {\n\t\tconst msg: T = JSON.parse(raw.toString());\n\t\tconst error = getErrorFromMessage(msg);\n\t\tif (error) {\n\t\t\tresult.reject(error);\n\t\t} else {\n\t\t\tresult.resolve(msg);\n\t\t}\n\t}));\n\treturn result.promise;\n}\n\nfunction createSocket<T extends RemoteConnection>(logService: ILogService, remoteSocketFactoryService: IRemoteSocketFactoryService, connectTo: T, path: string, query: string, debugConnectionType: string, debugLabel: string, timeoutCancellationToken: CancellationToken): Promise<ISocket> {\n\tconst result = new PromiseWithTimeout<ISocket>(timeoutCancellationToken);\n\tconst sw = StopWatch.create(false);\n\tlogService.info(`Creating a socket (${debugLabel})...`);\n\tperformance.mark(`code/willCreateSocket/${debugConnectionType}`);\n\n\tremoteSocketFactoryService.connect(connectTo, path, query, debugLabel).then((socket) => {\n\t\tif (result.didTimeout) {\n\t\t\tperformance.mark(`code/didCreateSocketError/${debugConnectionType}`);\n\t\t\tlogService.info(`Creating a socket (${debugLabel}) finished after ${sw.elapsed()} ms, but this is too late and has timed out already.`);\n\t\t\tsocket?.dispose();\n\t\t} else {\n\t\t\tperformance.mark(`code/didCreateSocketOK/${debugConnectionType}`);\n\t\t\tlogService.info(`Creating a socket (${debugLabel}) was successful after ${sw.elapsed()} ms.`);\n\t\t\tresult.resolve(socket);\n\t\t}\n\t}, (err) => {\n\t\tperformance.mark(`code/didCreateSocketError/${debugConnectionType}`);\n\t\tlogService.info(`Creating a socket (${debugLabel}) returned an error after ${sw.elapsed()} ms.`);\n\t\tlogService.error(err);\n\t\tresult.reject(err);\n\t});\n\n\treturn result.promise;\n}\n\nfunction raceWithTimeoutCancellation<T>(promise: Promise<T>, timeoutCancellationToken: CancellationToken): Promise<T> {\n\tconst result = new PromiseWithTimeout<T>(timeoutCancellationToken);\n\tpromise.then(\n\t\t(res) => {\n\t\t\tif (!result.didTimeout) {\n\t\t\t\tresult.resolve(res);\n\t\t\t}\n\t\t},\n\t\t(err) => {\n\t\t\tif (!result.didTimeout) {\n\t\t\t\tresult.reject(err);\n\t\t\t}\n\t\t}\n\t);\n\treturn result.promise;\n}\n\nasync function connectToRemoteExtensionHostAgent<T extends RemoteConnection>(options: ISimpleConnectionOptions<T>, connectionType: ConnectionType, args: any | undefined, timeoutCancellationToken: CancellationToken): Promise<{ protocol: PersistentProtocol; ownsProtocol: boolean }> {\n\tconst logPrefix = connectLogPrefix(options, connectionType);\n\n\toptions.logService.trace(`${logPrefix} 1/6. invoking socketFactory.connect().`);\n\n\tlet socket: ISocket;\n\ttry {\n\t\tsocket = await createSocket(options.logService, options.remoteSocketFactoryService, options.connectTo, RemoteAuthorities.getServerRootPath(), `reconnectionToken=${options.reconnectionToken}&reconnection=${options.reconnectionProtocol ? 'true' : 'false'}`, connectionTypeToString(connectionType), `renderer-${connectionTypeToString(connectionType)}-${options.reconnectionToken}`, timeoutCancellationToken);\n\t} catch (error) {\n\t\toptions.logService.error(`${logPrefix} socketFactory.connect() failed or timed out. Error:`);\n\t\toptions.logService.error(error);\n\t\tthrow error;\n\t}\n\n\toptions.logService.trace(`${logPrefix} 2/6. socketFactory.connect() was successful.`);\n\n\tlet protocol: PersistentProtocol;\n\tlet ownsProtocol: boolean;\n\tif (options.reconnectionProtocol) {\n\t\toptions.reconnectionProtocol.beginAcceptReconnection(socket, null);\n\t\tprotocol = options.reconnectionProtocol;\n\t\townsProtocol = false;\n\t} else {\n\t\tprotocol = new PersistentProtocol({ socket });\n\t\townsProtocol = true;\n\t}\n\n\toptions.logService.trace(`${logPrefix} 3/6. sending AuthRequest control message.`);\n\tconst message = await raceWithTimeoutCancellation(options.signService.createNewMessage(generateUuid()), timeoutCancellationToken);\n\n\tconst authRequest: AuthRequest = {\n\t\ttype: 'auth',\n\t\tauth: options.connectionToken || '00000000000000000000',\n\t\tdata: message.data\n\t};\n\tprotocol.sendControl(VSBuffer.fromString(JSON.stringify(authRequest)));\n\n\ttry {\n\t\tconst msg = await readOneControlMessage<HandshakeMessage>(protocol, combineTimeoutCancellation(timeoutCancellationToken, createTimeoutCancellation(10000)));\n\n\t\tif (msg.type !== 'sign' || typeof msg.data !== 'string') {\n\t\t\tconst error: any = new Error('Unexpected handshake message');\n\t\t\terror.code = 'VSCODE_CONNECTION_ERROR';\n\t\t\tthrow error;\n\t\t}\n\n\t\toptions.logService.trace(`${logPrefix} 4/6. received SignRequest control message.`);\n\n\t\tconst isValid = await raceWithTimeoutCancellation(options.signService.validate(message, msg.signedData), timeoutCancellationToken);\n\t\tif (!isValid) {\n\t\t\tconst error: any = new Error('Refused to connect to unsupported server');\n\t\t\terror.code = 'VSCODE_CONNECTION_ERROR';\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst signed = await raceWithTimeoutCancellation(options.signService.sign(msg.data), timeoutCancellationToken);\n\t\tconst connTypeRequest: ConnectionTypeRequest = {\n\t\t\ttype: 'connectionType',\n\t\t\tcommit: options.commit,\n\t\t\tsignedData: signed,\n\t\t\tdesiredConnectionType: connectionType\n\t\t};\n\t\tif (args) {\n\t\t\tconnTypeRequest.args = args;\n\t\t}\n\n\t\toptions.logService.trace(`${logPrefix} 5/6. sending ConnectionTypeRequest control message.`);\n\t\tprotocol.sendControl(VSBuffer.fromString(JSON.stringify(connTypeRequest)));\n\n\t\treturn { protocol, ownsProtocol };\n\n\t} catch (error) {\n\t\tif (error && error.code === 'ETIMEDOUT') {\n\t\t\toptions.logService.error(`${logPrefix} the handshake timed out. Error:`);\n\t\t\toptions.logService.error(error);\n\t\t}\n\t\tif (error && error.code === 'VSCODE_CONNECTION_ERROR') {\n\t\t\toptions.logService.error(`${logPrefix} received error control message when negotiating connection. Error:`);\n\t\t\toptions.logService.error(error);\n\t\t}\n\t\tif (ownsProtocol) {\n\t\t\tsafeDisposeProtocolAndSocket(protocol);\n\t\t}\n\t\tthrow error;\n\t}\n}\n\ninterface IManagementConnectionResult {\n\tprotocol: PersistentProtocol;\n}\n\nasync function connectToRemoteExtensionHostAgentAndReadOneMessage<T>(options: ISimpleConnectionOptions, connectionType: ConnectionType, args: any | undefined, timeoutCancellationToken: CancellationToken): Promise<{ protocol: PersistentProtocol; firstMessage: T }> {\n\tconst startTime = Date.now();\n\tconst logPrefix = connectLogPrefix(options, connectionType);\n\tconst { protocol, ownsProtocol } = await connectToRemoteExtensionHostAgent(options, connectionType, args, timeoutCancellationToken);\n\tconst result = new PromiseWithTimeout<{ protocol: PersistentProtocol; firstMessage: T }>(timeoutCancellationToken);\n\tresult.registerDisposable(protocol.onControlMessage(raw => {\n\t\tconst msg: T = JSON.parse(raw.toString());\n\t\tconst error = getErrorFromMessage(msg);\n\t\tif (error) {\n\t\t\toptions.logService.error(`${logPrefix} received error control message when negotiating connection. Error:`);\n\t\t\toptions.logService.error(error);\n\t\t\tif (ownsProtocol) {\n\t\t\t\tsafeDisposeProtocolAndSocket(protocol);\n\t\t\t}\n\t\t\tresult.reject(error);\n\t\t} else {\n\t\t\toptions.reconnectionProtocol?.endAcceptReconnection();\n\t\t\toptions.logService.trace(`${logPrefix} 6/6. handshake finished, connection is up and running after ${logElapsed(startTime)}!`);\n\t\t\tresult.resolve({ protocol, firstMessage: msg });\n\t\t}\n\t}));\n\treturn result.promise;\n}\n\nasync function doConnectRemoteAgentManagement(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<IManagementConnectionResult> {\n\tconst { protocol } = await connectToRemoteExtensionHostAgentAndReadOneMessage(options, ConnectionType.Management, undefined, timeoutCancellationToken);\n\treturn { protocol };\n}\n\nexport interface IRemoteExtensionHostStartParams {\n\tlanguage: string;\n\tdebugId?: string;\n\tbreak?: boolean;\n\tport?: number | null;\n\tenv?: { [key: string]: string | null };\n}\n\ninterface IExtensionHostConnectionResult {\n\tprotocol: PersistentProtocol;\n\tdebugPort?: number;\n}\n\nasync function doConnectRemoteAgentExtensionHost(options: ISimpleConnectionOptions, startArguments: IRemoteExtensionHostStartParams, timeoutCancellationToken: CancellationToken): Promise<IExtensionHostConnectionResult> {\n\tconst { protocol, firstMessage } = await connectToRemoteExtensionHostAgentAndReadOneMessage<{ debugPort?: number }>(options, ConnectionType.ExtensionHost, startArguments, timeoutCancellationToken);\n\tconst debugPort = firstMessage && firstMessage.debugPort;\n\treturn { protocol, debugPort };\n}\n\nexport interface ITunnelConnectionStartParams {\n\thost: string;\n\tport: number;\n}\n\nasync function doConnectRemoteAgentTunnel(options: ISimpleConnectionOptions, startParams: ITunnelConnectionStartParams, timeoutCancellationToken: CancellationToken): Promise<PersistentProtocol> {\n\tconst startTime = Date.now();\n\tconst logPrefix = connectLogPrefix(options, ConnectionType.Tunnel);\n\tconst { protocol } = await connectToRemoteExtensionHostAgent(options, ConnectionType.Tunnel, startParams, timeoutCancellationToken);\n\toptions.logService.trace(`${logPrefix} 6/6. handshake finished, connection is up and running after ${logElapsed(startTime)}!`);\n\treturn protocol;\n}\n\nexport interface IConnectionOptions<T extends RemoteConnection = RemoteConnection> {\n\tcommit: string | undefined;\n\tquality: string | undefined;\n\taddressProvider: IAddressProvider<T>;\n\tremoteSocketFactoryService: IRemoteSocketFactoryService;\n\tsignService: ISignService;\n\tlogService: ILogService;\n\tipcLogger: IIPCLogger | null;\n}\n\nasync function resolveConnectionOptions<T extends RemoteConnection>(options: IConnectionOptions<T>, reconnectionToken: string, reconnectionProtocol: PersistentProtocol | null): Promise<ISimpleConnectionOptions<T>> {\n\tconst { connectTo, connectionToken } = await options.addressProvider.getAddress();\n\treturn {\n\t\tcommit: options.commit,\n\t\tquality: options.quality,\n\t\tconnectTo,\n\t\tconnectionToken: connectionToken,\n\t\treconnectionToken: reconnectionToken,\n\t\treconnectionProtocol: reconnectionProtocol,\n\t\tremoteSocketFactoryService: options.remoteSocketFactoryService,\n\t\tsignService: options.signService,\n\t\tlogService: options.logService\n\t};\n}\n\nexport interface IAddress<T extends RemoteConnection = RemoteConnection> {\n\tconnectTo: T;\n\tconnectionToken: string | undefined;\n}\n\nexport interface IAddressProvider<T extends RemoteConnection = RemoteConnection> {\n\tgetAddress(): Promise<IAddress<T>>;\n}\n\nexport async function connectRemoteAgentManagement(options: IConnectionOptions, remoteAuthority: string, clientId: string): Promise<ManagementPersistentConnection> {\n\treturn createInitialConnection(\n\t\toptions,\n\t\tasync (simpleOptions) => {\n\t\t\tconst { protocol } = await doConnectRemoteAgentManagement(simpleOptions, CancellationToken.None);\n\t\t\treturn new ManagementPersistentConnection(options, remoteAuthority, clientId, simpleOptions.reconnectionToken, protocol);\n\t\t}\n\t);\n}\n\nexport async function connectRemoteAgentExtensionHost(options: IConnectionOptions, startArguments: IRemoteExtensionHostStartParams): Promise<ExtensionHostPersistentConnection> {\n\treturn createInitialConnection(\n\t\toptions,\n\t\tasync (simpleOptions) => {\n\t\t\tconst { protocol, debugPort } = await doConnectRemoteAgentExtensionHost(simpleOptions, startArguments, CancellationToken.None);\n\t\t\treturn new ExtensionHostPersistentConnection(options, startArguments, simpleOptions.reconnectionToken, protocol, debugPort);\n\t\t}\n\t);\n}\n\n/**\n * Will attempt to connect 5 times. If it fails 5 consecutive times, it will give up.\n */\nasync function createInitialConnection<T extends PersistentConnection, O extends RemoteConnection>(options: IConnectionOptions<O>, connectionFactory: (simpleOptions: ISimpleConnectionOptions<O>) => Promise<T>): Promise<T> {\n\tconst MAX_ATTEMPTS = 5;\n\n\tfor (let attempt = 1; ; attempt++) {\n\t\ttry {\n\t\t\tconst reconnectionToken = generateUuid();\n\t\t\tconst simpleOptions = await resolveConnectionOptions(options, reconnectionToken, null);\n\t\t\tconst result = await connectionFactory(simpleOptions);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tif (attempt < MAX_ATTEMPTS) {\n\t\t\t\toptions.logService.error(`[remote-connection][attempt ${attempt}] An error occurred in initial connection! Will retry... Error:`);\n\t\t\t\toptions.logService.error(err);\n\t\t\t} else {\n\t\t\t\toptions.logService.error(`[remote-connection][attempt ${attempt}]  An error occurred in initial connection! It will be treated as a permanent error. Error:`);\n\t\t\t\toptions.logService.error(err);\n\t\t\t\tPersistentConnection.triggerPermanentFailure(0, 0, RemoteAuthorityResolverError.isHandled(err));\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport async function connectRemoteAgentTunnel(options: IConnectionOptions, tunnelRemoteHost: string, tunnelRemotePort: number): Promise<PersistentProtocol> {\n\tconst simpleOptions = await resolveConnectionOptions(options, generateUuid(), null);\n\tconst protocol = await doConnectRemoteAgentTunnel(simpleOptions, { host: tunnelRemoteHost, port: tunnelRemotePort }, CancellationToken.None);\n\treturn protocol;\n}\n\nfunction sleep(seconds: number): CancelablePromise<void> {\n\treturn createCancelablePromise(token => {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst timeout = setTimeout(resolve, seconds * 1000);\n\t\t\ttoken.onCancellationRequested(() => {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t});\n}\n\nexport const enum PersistentConnectionEventType {\n\tConnectionLost,\n\tReconnectionWait,\n\tReconnectionRunning,\n\tReconnectionPermanentFailure,\n\tConnectionGain\n}\nexport class ConnectionLostEvent {\n\tpublic readonly type = PersistentConnectionEventType.ConnectionLost;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number\n\t) { }\n}\nexport class ReconnectionWaitEvent {\n\tpublic readonly type = PersistentConnectionEventType.ReconnectionWait;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly durationSeconds: number,\n\t\tprivate readonly cancellableTimer: CancelablePromise<void>\n\t) { }\n\n\tpublic skipWait(): void {\n\t\tthis.cancellableTimer.cancel();\n\t}\n}\nexport class ReconnectionRunningEvent {\n\tpublic readonly type = PersistentConnectionEventType.ReconnectionRunning;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number\n\t) { }\n}\nexport class ConnectionGainEvent {\n\tpublic readonly type = PersistentConnectionEventType.ConnectionGain;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number\n\t) { }\n}\nexport class ReconnectionPermanentFailureEvent {\n\tpublic readonly type = PersistentConnectionEventType.ReconnectionPermanentFailure;\n\tconstructor(\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly millisSinceLastIncomingData: number,\n\t\tpublic readonly attempt: number,\n\t\tpublic readonly handled: boolean\n\t) { }\n}\nexport type PersistentConnectionEvent = ConnectionGainEvent | ConnectionLostEvent | ReconnectionWaitEvent | ReconnectionRunningEvent | ReconnectionPermanentFailureEvent;\n\nexport abstract class PersistentConnection extends Disposable {\n\n\tpublic static triggerPermanentFailure(millisSinceLastIncomingData: number, attempt: number, handled: boolean): void {\n\t\tthis._permanentFailure = true;\n\t\tthis._permanentFailureMillisSinceLastIncomingData = millisSinceLastIncomingData;\n\t\tthis._permanentFailureAttempt = attempt;\n\t\tthis._permanentFailureHandled = handled;\n\t\tthis._instances.forEach(instance => instance._gotoPermanentFailure(this._permanentFailureMillisSinceLastIncomingData, this._permanentFailureAttempt, this._permanentFailureHandled));\n\t}\n\n\tpublic static debugTriggerReconnection() {\n\t\tthis._instances.forEach(instance => instance._beginReconnecting());\n\t}\n\n\tpublic static debugPauseSocketWriting() {\n\t\tthis._instances.forEach(instance => instance._pauseSocketWriting());\n\t}\n\n\tprivate static _permanentFailure: boolean = false;\n\tprivate static _permanentFailureMillisSinceLastIncomingData: number = 0;\n\tprivate static _permanentFailureAttempt: number = 0;\n\tprivate static _permanentFailureHandled: boolean = false;\n\tprivate static _instances: PersistentConnection[] = [];\n\n\tprivate readonly _onDidStateChange = this._register(new Emitter<PersistentConnectionEvent>());\n\tpublic readonly onDidStateChange = this._onDidStateChange.event;\n\n\tprivate _permanentFailure: boolean = false;\n\tprivate get _isPermanentFailure(): boolean {\n\t\treturn this._permanentFailure || PersistentConnection._permanentFailure;\n\t}\n\n\tprivate _isReconnecting: boolean = false;\n\tprivate _isDisposed: boolean = false;\n\tprivate _reconnectionGraceTime: number = ProtocolConstants.ReconnectionGraceTime;\n\n\tconstructor(\n\t\tprivate readonly _connectionType: ConnectionType,\n\t\tprotected readonly _options: IConnectionOptions,\n\t\tpublic readonly reconnectionToken: string,\n\t\tpublic readonly protocol: PersistentProtocol,\n\t\tprivate readonly _reconnectionFailureIsFatal: boolean\n\t) {\n\t\tsuper();\n\n\n\t\tthis._onDidStateChange.fire(new ConnectionGainEvent(this.reconnectionToken, 0, 0));\n\n\t\tthis._register(protocol.onSocketClose((e) => {\n\t\t\tconst logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);\n\t\t\tif (!e) {\n\t\t\t\tthis._options.logService.info(`${logPrefix} received socket close event.`);\n\t\t\t} else if (e.type === SocketCloseEventType.NodeSocketCloseEvent) {\n\t\t\t\tthis._options.logService.info(`${logPrefix} received socket close event (hadError: ${e.hadError}).`);\n\t\t\t\tif (e.error) {\n\t\t\t\t\tthis._options.logService.error(e.error);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._options.logService.info(`${logPrefix} received socket close event (wasClean: ${e.wasClean}, code: ${e.code}, reason: ${e.reason}).`);\n\t\t\t\tif (e.event) {\n\t\t\t\t\tthis._options.logService.error(e.event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._beginReconnecting();\n\t\t}));\n\t\tthis._register(protocol.onSocketTimeout((e) => {\n\t\t\tconst logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);\n\t\t\tthis._options.logService.info(`${logPrefix} received socket timeout event (unacknowledgedMsgCount: ${e.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${e.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${e.timeSinceLastReceivedSomeData}).`);\n\t\t\tthis._beginReconnecting();\n\t\t}));\n\n\t\tPersistentConnection._instances.push(this);\n\t\tthis._register(toDisposable(() => {\n\t\t\tconst myIndex = PersistentConnection._instances.indexOf(this);\n\t\t\tif (myIndex >= 0) {\n\t\t\t\tPersistentConnection._instances.splice(myIndex, 1);\n\t\t\t}\n\t\t}));\n\n\t\tif (this._isPermanentFailure) {\n\t\t\tthis._gotoPermanentFailure(PersistentConnection._permanentFailureMillisSinceLastIncomingData, PersistentConnection._permanentFailureAttempt, PersistentConnection._permanentFailureHandled);\n\t\t}\n\t}\n\n\tpublic updateGraceTime(graceTime: number): void {\n\t\tconst sanitizedGrace = sanitizeGraceTime(graceTime, ProtocolConstants.ReconnectionGraceTime);\n\t\tconst logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, false);\n\t\tthis._options.logService.trace(`${logPrefix} Applying reconnection grace time: ${sanitizedGrace}ms (${Math.floor(sanitizedGrace / 1000)}s)`);\n\t\tthis._reconnectionGraceTime = sanitizedGrace;\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\tthis._isDisposed = true;\n\t}\n\n\tprivate async _beginReconnecting(): Promise<void> {\n\t\t// Only have one reconnection loop active at a time.\n\t\tif (this._isReconnecting) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis._isReconnecting = true;\n\t\t\tawait this._runReconnectingLoop();\n\t\t} finally {\n\t\t\tthis._isReconnecting = false;\n\t\t}\n\t}\n\n\tprivate async _runReconnectingLoop(): Promise<void> {\n\t\tif (this._isPermanentFailure || this._isDisposed) {\n\t\t\t// no more attempts!\n\t\t\treturn;\n\t\t}\n\t\tconst logPrefix = commonLogPrefix(this._connectionType, this.reconnectionToken, true);\n\t\tthis._options.logService.info(`${logPrefix} starting reconnecting loop. You can get more information with the trace log level.`);\n\t\tthis._onDidStateChange.fire(new ConnectionLostEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData()));\n\t\tconst TIMES = [0, 5, 5, 10, 10, 10, 10, 10, 30];\n\t\tconst graceTime = this._reconnectionGraceTime;\n\t\tthis._options.logService.info(`${logPrefix} starting reconnection with grace time: ${graceTime}ms (${Math.floor(graceTime / 1000)}s)`);\n\t\tif (graceTime <= 0) {\n\t\t\tthis._options.logService.error(`${logPrefix} reconnection grace time is set to 0ms, will not attempt to reconnect.`);\n\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), 0, false);\n\t\t\treturn;\n\t\t}\n\t\tconst loopStartTime = Date.now();\n\t\tlet attempt = -1;\n\t\tdo {\n\t\t\tattempt++;\n\t\t\tconst waitTime = (attempt < TIMES.length ? TIMES[attempt] : TIMES[TIMES.length - 1]);\n\t\t\ttry {\n\t\t\t\tif (waitTime > 0) {\n\t\t\t\t\tconst sleepPromise = sleep(waitTime);\n\t\t\t\t\tthis._onDidStateChange.fire(new ReconnectionWaitEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), waitTime, sleepPromise));\n\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} waiting for ${waitTime} seconds before reconnecting...`);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait sleepPromise;\n\t\t\t\t\t} catch { } // User canceled timer\n\t\t\t\t}\n\n\t\t\t\tif (this._isPermanentFailure) {\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} permanent failure occurred while running the reconnecting loop.`);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// connection was lost, let's try to re-establish it\n\t\t\t\tthis._onDidStateChange.fire(new ReconnectionRunningEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), attempt + 1));\n\t\t\t\tthis._options.logService.info(`${logPrefix} resolving connection...`);\n\t\t\t\tconst simpleOptions = await resolveConnectionOptions(this._options, this.reconnectionToken, this.protocol);\n\t\t\t\tthis._options.logService.info(`${logPrefix} connecting to ${simpleOptions.connectTo}...`);\n\t\t\t\tawait this._reconnect(simpleOptions, createTimeoutCancellation(RECONNECT_TIMEOUT));\n\t\t\t\tthis._options.logService.info(`${logPrefix} reconnected!`);\n\t\t\t\tthis._onDidStateChange.fire(new ConnectionGainEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), attempt + 1));\n\n\t\t\t\tbreak;\n\t\t\t} catch (err) {\n\t\t\t\tif (err.code === 'VSCODE_CONNECTION_ERROR') {\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} A permanent error occurred in the reconnecting loop! Will give up now! Error:`);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (Date.now() - loopStartTime >= graceTime) {\n\t\t\t\t\tconst graceSeconds = Math.round(graceTime / 1000);\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} An error occurred while reconnecting, but it will be treated as a permanent error because the reconnection grace time (${graceSeconds}s) has expired! Will give up now! Error:`);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (RemoteAuthorityResolverError.isTemporarilyNotAvailable(err)) {\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} A temporarily not available error occurred while trying to reconnect, will try again...`);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((err.code === 'ETIMEDOUT' || err.code === 'ENETUNREACH' || err.code === 'ECONNREFUSED' || err.code === 'ECONNRESET') && err.syscall === 'connect') {\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} A network error occurred while trying to reconnect, will try again...`);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isCancellationError(err)) {\n\t\t\t\t\tthis._options.logService.info(`${logPrefix} A promise cancelation error occurred while trying to reconnect, will try again...`);\n\t\t\t\t\tthis._options.logService.trace(err);\n\t\t\t\t\t// try again!\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (err instanceof RemoteAuthorityResolverError) {\n\t\t\t\t\tthis._options.logService.error(`${logPrefix} A RemoteAuthorityResolverError occurred while trying to reconnect. Will give up now! Error:`);\n\t\t\t\t\tthis._options.logService.error(err);\n\t\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, RemoteAuthorityResolverError.isHandled(err));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis._options.logService.error(`${logPrefix} An unknown error occurred while trying to reconnect, since this is an unknown case, it will be treated as a permanent error! Will give up now! Error:`);\n\t\t\t\tthis._options.logService.error(err);\n\t\t\t\tthis._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), attempt + 1, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!this._isPermanentFailure && !this._isDisposed);\n\t}\n\n\tprivate _onReconnectionPermanentFailure(millisSinceLastIncomingData: number, attempt: number, handled: boolean): void {\n\t\tif (this._reconnectionFailureIsFatal) {\n\t\t\tPersistentConnection.triggerPermanentFailure(millisSinceLastIncomingData, attempt, handled);\n\t\t} else {\n\t\t\tthis._gotoPermanentFailure(millisSinceLastIncomingData, attempt, handled);\n\t\t}\n\t}\n\n\tprivate _gotoPermanentFailure(millisSinceLastIncomingData: number, attempt: number, handled: boolean): void {\n\t\tthis._onDidStateChange.fire(new ReconnectionPermanentFailureEvent(this.reconnectionToken, millisSinceLastIncomingData, attempt, handled));\n\t\tsafeDisposeProtocolAndSocket(this.protocol);\n\t}\n\n\tprivate _pauseSocketWriting(): void {\n\t\tthis.protocol.pauseSocketWriting();\n\t}\n\n\tprotected abstract _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void>;\n}\n\nexport class ManagementPersistentConnection extends PersistentConnection {\n\n\tpublic readonly client: Client<RemoteAgentConnectionContext>;\n\n\tconstructor(options: IConnectionOptions, remoteAuthority: string, clientId: string, reconnectionToken: string, protocol: PersistentProtocol) {\n\t\tsuper(ConnectionType.Management, options, reconnectionToken, protocol, /*reconnectionFailureIsFatal*/true);\n\t\tthis.client = this._register(new Client<RemoteAgentConnectionContext>(protocol, {\n\t\t\tremoteAuthority: remoteAuthority,\n\t\t\tclientId: clientId\n\t\t}, options.ipcLogger));\n\t}\n\n\tprotected async _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void> {\n\t\tawait doConnectRemoteAgentManagement(options, timeoutCancellationToken);\n\t}\n}\n\nexport class ExtensionHostPersistentConnection extends PersistentConnection {\n\n\tprivate readonly _startArguments: IRemoteExtensionHostStartParams;\n\tpublic readonly debugPort: number | undefined;\n\n\tconstructor(options: IConnectionOptions, startArguments: IRemoteExtensionHostStartParams, reconnectionToken: string, protocol: PersistentProtocol, debugPort: number | undefined) {\n\t\tsuper(ConnectionType.ExtensionHost, options, reconnectionToken, protocol, /*reconnectionFailureIsFatal*/false);\n\t\tthis._startArguments = startArguments;\n\t\tthis.debugPort = debugPort;\n\t}\n\n\tprotected async _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void> {\n\t\tawait doConnectRemoteAgentExtensionHost(options, this._startArguments, timeoutCancellationToken);\n\t}\n}\n\nfunction safeDisposeProtocolAndSocket(protocol: PersistentProtocol): void {\n\ttry {\n\t\tprotocol.acceptDisconnect();\n\t\tconst socket = protocol.getSocket();\n\t\tprotocol.dispose();\n\t\tsocket.dispose();\n\t} catch (err) {\n\t\tonUnexpectedError(err);\n\t}\n}\n\nfunction getErrorFromMessage(msg: any): Error | null {\n\tif (msg && msg.type === 'error') {\n\t\tconst error = new Error(`Connection error: ${msg.reason}`);\n\t\t// eslint-disable-next-line local/code-no-any-casts\n\t\t(<any>error).code = 'VSCODE_CONNECTION_ERROR';\n\t\treturn error;\n\t}\n\treturn null;\n}\n\nfunction sanitizeGraceTime(candidate: number, fallback: number): number {\n\tif (typeof candidate !== 'number' || !isFinite(candidate) || candidate < 0) {\n\t\treturn fallback;\n\t}\n\tif (candidate > Number.MAX_SAFE_INTEGER) {\n\t\treturn Number.MAX_SAFE_INTEGER;\n\t}\n\treturn Math.floor(candidate);\n}\n\nfunction stringRightPad(str: string, len: number): string {\n\twhile (str.length < len) {\n\t\tstr += ' ';\n\t}\n\treturn str;\n}\n\nfunction _commonLogPrefix(connectionType: ConnectionType, reconnectionToken: string): string {\n\treturn `[remote-connection][${stringRightPad(connectionTypeToString(connectionType), 13)}][${reconnectionToken.substr(0, 5)}]`;\n}\n\nfunction commonLogPrefix(connectionType: ConnectionType, reconnectionToken: string, isReconnect: boolean): string {\n\treturn `${_commonLogPrefix(connectionType, reconnectionToken)}[${isReconnect ? 'reconnect' : 'initial'}]`;\n}\n\nfunction connectLogPrefix(options: ISimpleConnectionOptions, connectionType: ConnectionType): string {\n\treturn `${commonLogPrefix(connectionType, options.reconnectionToken, !!options.reconnectionProtocol)}[${options.connectTo}]`;\n}\n\nfunction logElapsed(startTime: number): string {\n\treturn `${Date.now() - startTime} ms`;\n}\n"]}