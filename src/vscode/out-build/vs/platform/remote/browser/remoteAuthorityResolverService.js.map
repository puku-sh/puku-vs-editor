{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/remote/browser/remoteAuthorityResolverService.ts","vs/platform/remote/browser/remoteAuthorityResolverService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;AAEhG,OAAO,EAAE,UAAU,EAAE,MAAM,iCAAiC,CAAC;AAC7D,OAAO,EAAE,eAAe,EAAE,MAAM,+BAA+B,CAAC;AAChE,OAAO,KAAK,MAAM,MAAM,gCAAgC,CAAC;AACzD,OAAO,EAAE,OAAO,EAAE,MAAM,+BAA+B,CAAC;AACxD,OAAO,EAAE,UAAU,EAAE,MAAM,mCAAmC,CAAC;AAC/D,OAAO,EAAE,iBAAiB,EAAE,MAAM,iCAAiC,CAAC;AACpE,OAAO,KAAK,WAAW,MAAM,qCAAqC,CAAC;AACnE,OAAO,EAAE,SAAS,EAAE,MAAM,mCAAmC,CAAC;AAE9D,OAAO,EAAE,WAAW,EAAE,MAAM,yBAAyB,CAAC;AACtD,OAAO,EAAE,eAAe,EAAE,MAAM,wCAAwC,CAAC;AACzE,OAAO,EAAoI,yBAAyB,EAAE,wBAAwB,EAAE,MAAM,sCAAsC,CAAC;AAC7O,OAAO,EAAE,8BAA8B,EAAE,MAAM,0BAA0B,CAAC;AAEnE,IAAM,8BAA8B,GAApC,MAAM,8BAA+B,SAAQ,UAAU;IAa7D,YACC,iCAA0C,EAC1C,eAAqD,EACrD,mBAAoD,EACpD,cAAkC,EACjB,cAA+B,EACnC,WAAyC;QAEtD,KAAK,EAAE,CAAC;QAFsB,gBAAW,GAAX,WAAW,CAAa;QAftC,+BAA0B,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QAClE,8BAAyB,GAAG,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC;QAEjE,8BAAyB,GAAG,IAAI,GAAG,EAA2C,CAAC;QAC/E,WAAM,GAAG,IAAI,GAAG,EAA0B,CAAC;QAc3D,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;QACxC,IAAI,CAAC,iBAAiB,GAAG,IAAI,GAAG,EAAkB,CAAC;QACnD,IAAI,CAAC,kCAAkC,GAAG,iCAAiC,CAAC;QAC5E,IAAI,mBAAmB,EAAE,CAAC;YACzB,iBAAiB,CAAC,WAAW,CAAC,mBAAmB,CAAC,CAAC;QACpD,CAAC;QACD,iBAAiB,CAAC,iBAAiB,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;IACrE,CAAC;IAED,KAAK,CAAC,gBAAgB,CAAC,SAAiB;QACvC,IAAI,MAAM,GAAG,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAC3D,IAAI,CAAC,MAAM,EAAE,CAAC;YACb,MAAM,GAAG,IAAI,eAAe,EAAkB,CAAC;YAC/C,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;YACtD,IAAI,IAAI,CAAC,kCAAkC,EAAE,CAAC;gBAC7C,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,MAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,MAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;YACjG,CAAC;QACF,CAAC;QAED,OAAO,MAAM,CAAC,CAAC,CAAC;IACjB,CAAC;IAED,KAAK,CAAC,eAAe,CAAC,GAAQ;QAC7B,yCAAyC;QACzC,OAAO,GAAG,CAAC;IACZ,CAAC;IAED,iBAAiB,CAAC,SAAiB;QAClC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC;YACjC,OAAO,IAAI,CAAC;QACb,CAAC;QACD,MAAM,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAE,CAAC;QACnD,MAAM,eAAe,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,cAAc,CAAC,SAAS,CAAC,eAAe,CAAC;QAC1G,OAAO;YACN,SAAS,EAAE,cAAc,CAAC,SAAS,CAAC,SAAS;YAC7C,eAAe,EAAE,eAAe;SAChC,CAAC;IACH,CAAC;IAEO,KAAK,CAAC,mBAAmB,CAAC,SAAiB;QAClD,MAAM,eAAe,GAAG,wBAAwB,CAAC,SAAS,CAAC,CAAC;QAC5D,MAAM,EAAE,GAAG,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACnC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,+BAA+B,eAAe,MAAM,CAAC,CAAC;QAC5E,WAAW,CAAC,IAAI,CAAC,mCAAmC,eAAe,EAAE,CAAC,CAAC;QACvE,MAAM,eAAe,GAAG,MAAM,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC9G,WAAW,CAAC,IAAI,CAAC,kCAAkC,eAAe,EAAE,CAAC,CAAC;QACtE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,8BAA8B,eAAe,WAAW,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACjG,MAAM,WAAW,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QAC1E,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,8BAA8B,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;QAC9E,MAAM,MAAM,GAAmB,EAAE,SAAS,EAAE,EAAE,SAAS,EAAE,SAAS,EAAE,IAAI,yBAAyB,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,eAAe,EAAE,EAAE,CAAC;QACnI,iBAAiB,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QAC7C,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;QACnC,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,CAAC;QACvC,OAAO,MAAM,CAAC;IACf,CAAC;IAGD,uBAAuB,CAAC,SAAiB;QACxC,IAAI,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC;YACnD,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,SAAS,CAAE,CAAC,MAAM,EAAE,CAAC;YACxD,IAAI,CAAC,yBAAyB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAClD,CAAC;IACF,CAAC;IAED,qBAAqB,CAAC,iBAAoC,EAAE,OAAyB;QACpF,IAAI,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,iBAAiB,CAAC,SAAS,CAAC,EAAE,CAAC;YACrE,MAAM,OAAO,GAAG,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,iBAAiB,CAAC,SAAS,CAAE,CAAC;YACjF,wFAAwF;YACxF,wEAAwE;YACxE,IAAI,iBAAiB,CAAC,SAAS,CAAC,IAAI,2CAAmC,EAAE,CAAC;gBACzE,iBAAiB,CAAC,GAAG,CAAC,iBAAiB,CAAC,SAAS,EAAE,iBAAiB,CAAC,SAAS,CAAC,IAAI,EAAE,iBAAiB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YACxH,CAAC;YACD,IAAI,iBAAiB,CAAC,eAAe,EAAE,CAAC;gBACvC,iBAAiB,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,SAAS,EAAE,iBAAiB,CAAC,eAAe,CAAC,CAAC;YACtG,CAAC;YACD,OAAO,CAAC,QAAQ,CAAC,EAAE,SAAS,EAAE,iBAAiB,EAAE,OAAO,EAAE,CAAC,CAAC;YAC5D,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,CAAC;QACxC,CAAC;IACF,CAAC;IAED,0BAA0B,CAAC,SAAiB,EAAE,GAAQ;QACrD,IAAI,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC;YACnD,MAAM,OAAO,GAAG,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,SAAS,CAAE,CAAC;YAC/D,8CAA8C;YAC9C,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,gBAAgB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;QACvD,CAAC;IACF,CAAC;IAED,4BAA4B,CAAC,SAAiB,EAAE,eAAuB;QACtE,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,EAAE,eAAe,CAAC,CAAC;QACvD,iBAAiB,CAAC,kBAAkB,CAAC,SAAS,EAAE,eAAe,CAAC,CAAC;QACjE,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,CAAC;IACxC,CAAC;IAED,wBAAwB,CAAC,QAAoC;IAC7D,CAAC;CACD,CAAA;AAtHY,8BAA8B;IAkBxC,WAAA,eAAe,CAAA;IACf,WAAA,WAAW,CAAA;GAnBD,8BAA8B,CAsH1C","file":"remoteAuthorityResolverService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport * as errors from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { RemoteAuthorities } from '../../../base/common/network.js';\nimport * as performance from '../../../base/common/performance.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { IRemoteAuthorityResolverService, IRemoteConnectionData, RemoteConnectionType, ResolvedAuthority, ResolvedOptions, ResolverResult, WebSocketRemoteConnection, getRemoteAuthorityPrefix } from '../common/remoteAuthorityResolver.js';\nimport { parseAuthorityWithOptionalPort } from '../common/remoteHosts.js';\n\nexport class RemoteAuthorityResolverService extends Disposable implements IRemoteAuthorityResolverService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _onDidChangeConnectionData = this._register(new Emitter<void>());\n\tpublic readonly onDidChangeConnectionData = this._onDidChangeConnectionData.event;\n\n\tprivate readonly _resolveAuthorityRequests = new Map<string, DeferredPromise<ResolverResult>>();\n\tprivate readonly _cache = new Map<string, ResolverResult>();\n\tprivate readonly _connectionToken: Promise<string> | string | undefined;\n\tprivate readonly _connectionTokens: Map<string, string>;\n\tprivate readonly _isWorkbenchOptionsBasedResolution: boolean;\n\n\tconstructor(\n\t\tisWorkbenchOptionsBasedResolution: boolean,\n\t\tconnectionToken: Promise<string> | string | undefined,\n\t\tresourceUriProvider: ((uri: URI) => URI) | undefined,\n\t\tserverBasePath: string | undefined,\n\t\t@IProductService productService: IProductService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\t\tthis._connectionToken = connectionToken;\n\t\tthis._connectionTokens = new Map<string, string>();\n\t\tthis._isWorkbenchOptionsBasedResolution = isWorkbenchOptionsBasedResolution;\n\t\tif (resourceUriProvider) {\n\t\t\tRemoteAuthorities.setDelegate(resourceUriProvider);\n\t\t}\n\t\tRemoteAuthorities.setServerRootPath(productService, serverBasePath);\n\t}\n\n\tasync resolveAuthority(authority: string): Promise<ResolverResult> {\n\t\tlet result = this._resolveAuthorityRequests.get(authority);\n\t\tif (!result) {\n\t\t\tresult = new DeferredPromise<ResolverResult>();\n\t\t\tthis._resolveAuthorityRequests.set(authority, result);\n\t\t\tif (this._isWorkbenchOptionsBasedResolution) {\n\t\t\t\tthis._doResolveAuthority(authority).then(v => result!.complete(v), (err) => result!.error(err));\n\t\t\t}\n\t\t}\n\n\t\treturn result.p;\n\t}\n\n\tasync getCanonicalURI(uri: URI): Promise<URI> {\n\t\t// todo@connor4312 make this work for web\n\t\treturn uri;\n\t}\n\n\tgetConnectionData(authority: string): IRemoteConnectionData | null {\n\t\tif (!this._cache.has(authority)) {\n\t\t\treturn null;\n\t\t}\n\t\tconst resolverResult = this._cache.get(authority)!;\n\t\tconst connectionToken = this._connectionTokens.get(authority) || resolverResult.authority.connectionToken;\n\t\treturn {\n\t\t\tconnectTo: resolverResult.authority.connectTo,\n\t\t\tconnectionToken: connectionToken\n\t\t};\n\t}\n\n\tprivate async _doResolveAuthority(authority: string): Promise<ResolverResult> {\n\t\tconst authorityPrefix = getRemoteAuthorityPrefix(authority);\n\t\tconst sw = StopWatch.create(false);\n\t\tthis._logService.info(`Resolving connection token (${authorityPrefix})...`);\n\t\tperformance.mark(`code/willResolveConnectionToken/${authorityPrefix}`);\n\t\tconst connectionToken = await Promise.resolve(this._connectionTokens.get(authority) || this._connectionToken);\n\t\tperformance.mark(`code/didResolveConnectionToken/${authorityPrefix}`);\n\t\tthis._logService.info(`Resolved connection token (${authorityPrefix}) after ${sw.elapsed()} ms`);\n\t\tconst defaultPort = (/^https:/.test(mainWindow.location.href) ? 443 : 80);\n\t\tconst { host, port } = parseAuthorityWithOptionalPort(authority, defaultPort);\n\t\tconst result: ResolverResult = { authority: { authority, connectTo: new WebSocketRemoteConnection(host, port), connectionToken } };\n\t\tRemoteAuthorities.set(authority, host, port);\n\t\tthis._cache.set(authority, result);\n\t\tthis._onDidChangeConnectionData.fire();\n\t\treturn result;\n\t}\n\n\n\t_clearResolvedAuthority(authority: string): void {\n\t\tif (this._resolveAuthorityRequests.has(authority)) {\n\t\t\tthis._resolveAuthorityRequests.get(authority)!.cancel();\n\t\t\tthis._resolveAuthorityRequests.delete(authority);\n\t\t}\n\t}\n\n\t_setResolvedAuthority(resolvedAuthority: ResolvedAuthority, options?: ResolvedOptions): void {\n\t\tif (this._resolveAuthorityRequests.has(resolvedAuthority.authority)) {\n\t\t\tconst request = this._resolveAuthorityRequests.get(resolvedAuthority.authority)!;\n\t\t\t// For non-websocket types, it's expected the embedder passes a `remoteResourceProvider`\n\t\t\t// which is wrapped to a `IResourceUriProvider` and is not handled here.\n\t\t\tif (resolvedAuthority.connectTo.type === RemoteConnectionType.WebSocket) {\n\t\t\t\tRemoteAuthorities.set(resolvedAuthority.authority, resolvedAuthority.connectTo.host, resolvedAuthority.connectTo.port);\n\t\t\t}\n\t\t\tif (resolvedAuthority.connectionToken) {\n\t\t\t\tRemoteAuthorities.setConnectionToken(resolvedAuthority.authority, resolvedAuthority.connectionToken);\n\t\t\t}\n\t\t\trequest.complete({ authority: resolvedAuthority, options });\n\t\t\tthis._onDidChangeConnectionData.fire();\n\t\t}\n\t}\n\n\t_setResolvedAuthorityError(authority: string, err: any): void {\n\t\tif (this._resolveAuthorityRequests.has(authority)) {\n\t\t\tconst request = this._resolveAuthorityRequests.get(authority)!;\n\t\t\t// Avoid that this error makes it to telemetry\n\t\t\trequest.error(errors.ErrorNoTelemetry.fromError(err));\n\t\t}\n\t}\n\n\t_setAuthorityConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens.set(authority, connectionToken);\n\t\tRemoteAuthorities.setConnectionToken(authority, connectionToken);\n\t\tthis._onDidChangeConnectionData.fire();\n\t}\n\n\t_setCanonicalURIProvider(provider: (uri: URI) => Promise<URI>): void {\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport * as errors from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { RemoteAuthorities } from '../../../base/common/network.js';\nimport * as performance from '../../../base/common/performance.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { IRemoteAuthorityResolverService, IRemoteConnectionData, RemoteConnectionType, ResolvedAuthority, ResolvedOptions, ResolverResult, WebSocketRemoteConnection, getRemoteAuthorityPrefix } from '../common/remoteAuthorityResolver.js';\nimport { parseAuthorityWithOptionalPort } from '../common/remoteHosts.js';\n\nexport class RemoteAuthorityResolverService extends Disposable implements IRemoteAuthorityResolverService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _onDidChangeConnectionData = this._register(new Emitter<void>());\n\tpublic readonly onDidChangeConnectionData = this._onDidChangeConnectionData.event;\n\n\tprivate readonly _resolveAuthorityRequests = new Map<string, DeferredPromise<ResolverResult>>();\n\tprivate readonly _cache = new Map<string, ResolverResult>();\n\tprivate readonly _connectionToken: Promise<string> | string | undefined;\n\tprivate readonly _connectionTokens: Map<string, string>;\n\tprivate readonly _isWorkbenchOptionsBasedResolution: boolean;\n\n\tconstructor(\n\t\tisWorkbenchOptionsBasedResolution: boolean,\n\t\tconnectionToken: Promise<string> | string | undefined,\n\t\tresourceUriProvider: ((uri: URI) => URI) | undefined,\n\t\tserverBasePath: string | undefined,\n\t\t@IProductService productService: IProductService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\t\tthis._connectionToken = connectionToken;\n\t\tthis._connectionTokens = new Map<string, string>();\n\t\tthis._isWorkbenchOptionsBasedResolution = isWorkbenchOptionsBasedResolution;\n\t\tif (resourceUriProvider) {\n\t\t\tRemoteAuthorities.setDelegate(resourceUriProvider);\n\t\t}\n\t\tRemoteAuthorities.setServerRootPath(productService, serverBasePath);\n\t}\n\n\tasync resolveAuthority(authority: string): Promise<ResolverResult> {\n\t\tlet result = this._resolveAuthorityRequests.get(authority);\n\t\tif (!result) {\n\t\t\tresult = new DeferredPromise<ResolverResult>();\n\t\t\tthis._resolveAuthorityRequests.set(authority, result);\n\t\t\tif (this._isWorkbenchOptionsBasedResolution) {\n\t\t\t\tthis._doResolveAuthority(authority).then(v => result!.complete(v), (err) => result!.error(err));\n\t\t\t}\n\t\t}\n\n\t\treturn result.p;\n\t}\n\n\tasync getCanonicalURI(uri: URI): Promise<URI> {\n\t\t// todo@connor4312 make this work for web\n\t\treturn uri;\n\t}\n\n\tgetConnectionData(authority: string): IRemoteConnectionData | null {\n\t\tif (!this._cache.has(authority)) {\n\t\t\treturn null;\n\t\t}\n\t\tconst resolverResult = this._cache.get(authority)!;\n\t\tconst connectionToken = this._connectionTokens.get(authority) || resolverResult.authority.connectionToken;\n\t\treturn {\n\t\t\tconnectTo: resolverResult.authority.connectTo,\n\t\t\tconnectionToken: connectionToken\n\t\t};\n\t}\n\n\tprivate async _doResolveAuthority(authority: string): Promise<ResolverResult> {\n\t\tconst authorityPrefix = getRemoteAuthorityPrefix(authority);\n\t\tconst sw = StopWatch.create(false);\n\t\tthis._logService.info(`Resolving connection token (${authorityPrefix})...`);\n\t\tperformance.mark(`code/willResolveConnectionToken/${authorityPrefix}`);\n\t\tconst connectionToken = await Promise.resolve(this._connectionTokens.get(authority) || this._connectionToken);\n\t\tperformance.mark(`code/didResolveConnectionToken/${authorityPrefix}`);\n\t\tthis._logService.info(`Resolved connection token (${authorityPrefix}) after ${sw.elapsed()} ms`);\n\t\tconst defaultPort = (/^https:/.test(mainWindow.location.href) ? 443 : 80);\n\t\tconst { host, port } = parseAuthorityWithOptionalPort(authority, defaultPort);\n\t\tconst result: ResolverResult = { authority: { authority, connectTo: new WebSocketRemoteConnection(host, port), connectionToken } };\n\t\tRemoteAuthorities.set(authority, host, port);\n\t\tthis._cache.set(authority, result);\n\t\tthis._onDidChangeConnectionData.fire();\n\t\treturn result;\n\t}\n\n\n\t_clearResolvedAuthority(authority: string): void {\n\t\tif (this._resolveAuthorityRequests.has(authority)) {\n\t\t\tthis._resolveAuthorityRequests.get(authority)!.cancel();\n\t\t\tthis._resolveAuthorityRequests.delete(authority);\n\t\t}\n\t}\n\n\t_setResolvedAuthority(resolvedAuthority: ResolvedAuthority, options?: ResolvedOptions): void {\n\t\tif (this._resolveAuthorityRequests.has(resolvedAuthority.authority)) {\n\t\t\tconst request = this._resolveAuthorityRequests.get(resolvedAuthority.authority)!;\n\t\t\t// For non-websocket types, it's expected the embedder passes a `remoteResourceProvider`\n\t\t\t// which is wrapped to a `IResourceUriProvider` and is not handled here.\n\t\t\tif (resolvedAuthority.connectTo.type === RemoteConnectionType.WebSocket) {\n\t\t\t\tRemoteAuthorities.set(resolvedAuthority.authority, resolvedAuthority.connectTo.host, resolvedAuthority.connectTo.port);\n\t\t\t}\n\t\t\tif (resolvedAuthority.connectionToken) {\n\t\t\t\tRemoteAuthorities.setConnectionToken(resolvedAuthority.authority, resolvedAuthority.connectionToken);\n\t\t\t}\n\t\t\trequest.complete({ authority: resolvedAuthority, options });\n\t\t\tthis._onDidChangeConnectionData.fire();\n\t\t}\n\t}\n\n\t_setResolvedAuthorityError(authority: string, err: any): void {\n\t\tif (this._resolveAuthorityRequests.has(authority)) {\n\t\t\tconst request = this._resolveAuthorityRequests.get(authority)!;\n\t\t\t// Avoid that this error makes it to telemetry\n\t\t\trequest.error(errors.ErrorNoTelemetry.fromError(err));\n\t\t}\n\t}\n\n\t_setAuthorityConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens.set(authority, connectionToken);\n\t\tRemoteAuthorities.setConnectionToken(authority, connectionToken);\n\t\tthis._onDidChangeConnectionData.fire();\n\t}\n\n\t_setCanonicalURIProvider(provider: (uri: URI) => Promise<URI>): void {\n\t}\n}\n"]}