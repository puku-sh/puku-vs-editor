{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/telemetry/common/serverTelemetryService.ts","vs/platform/telemetry/common/serverTelemetryService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;AAEhG,OAAO,EAAE,qBAAqB,EAAE,MAAM,6CAA6C,CAAC;AACpF,OAAO,EAAE,sBAAsB,EAAE,MAAM,6CAA6C,CAAC;AACrF,OAAO,EAAE,eAAe,EAAE,MAAM,wCAAwC,CAAC;AAEzE,OAAO,EAAkB,iBAAiB,EAAkB,MAAM,gBAAgB,CAAC;AACnF,OAAO,EAA2B,gBAAgB,EAAE,MAAM,uBAAuB,CAAC;AAClF,OAAO,EAAE,yBAAyB,EAAE,MAAM,qBAAqB,CAAC;AAMzD,IAAM,sBAAsB,GAA5B,MAAM,sBAAuB,SAAQ,gBAAgB;IAK3D,YACC,MAA+B,EAC/B,sBAAsC,EACf,qBAA4C,EAClD,eAAgC;QAEjD,KAAK,CAAC,MAAM,EAAE,qBAAqB,EAAE,eAAe,CAAC,CAAC;QACtD,IAAI,CAAC,uBAAuB,GAAG,sBAAsB,CAAC;IACvD,CAAC;IAEQ,SAAS,CAAC,SAAiB,EAAE,IAAqB;QAC1D,IAAI,IAAI,CAAC,uBAAuB,+BAAuB,EAAE,CAAC;YACzD,OAAO;QACR,CAAC;QACD,OAAO,KAAK,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IACzC,CAAC;IAEQ,UAAU,CAAsF,SAAiB,EAAE,IAAgC;QAC3J,OAAO,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,IAAkC,CAAC,CAAC;IACtE,CAAC;IAEQ,cAAc,CAAC,cAAsB,EAAE,IAAqB;QACpE,IAAI,IAAI,CAAC,uBAAuB,+BAAuB,EAAE,CAAC;YACzD,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QACnC,CAAC;QACD,OAAO,KAAK,CAAC,cAAc,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;IACnD,CAAC;IAEQ,eAAe,CAAsF,SAAiB,EAAE,IAAgC;QAChK,OAAO,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,IAAkC,CAAC,CAAC;IAC3E,CAAC;IAED,KAAK,CAAC,4BAA4B,CAAC,cAA8B;QAChE,IAAI,cAAc,KAAK,SAAS,EAAE,CAAC;YAClC,IAAI,CAAC,uBAAuB,8BAAsB,CAAC;YACnD,MAAM,IAAI,KAAK,CAAC,wEAAwE,CAAC,CAAC;QAC3F,CAAC;QACD,6IAA6I;QAC7I,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,uBAAuB,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,uBAAuB,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC;QACtI,IAAI,IAAI,CAAC,uBAAuB,gCAAwB,EAAE,CAAC;YAC1D,IAAI,CAAC,OAAO,EAAE,CAAC;QAChB,CAAC;IACF,CAAC;CACD,CAAA;AAhDY,sBAAsB;IAQhC,WAAA,qBAAqB,CAAA;IACrB,WAAA,eAAe,CAAA;GATL,sBAAsB,CAgDlC;;AAED,MAAM,CAAC,MAAM,0BAA0B,GAAG,IAAI,KAAM,SAAQ,yBAAyB;IACpF,KAAK,CAAC,4BAA4B,KAAoB,OAAO,CAAC,CAAC,CAAC,uCAAuC;CACvG,CAAC;AAEF,MAAM,CAAC,MAAM,uBAAuB,GAAG,sBAAsB,CAA6C,iBAAiB,CAAC,CAAC","file":"serverTelemetryService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { refineServiceDecorator } from '../../instantiation/common/instantiation.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { ClassifiedEvent, IGDPRProperty, OmitMetadata, StrictPropertyCheck } from './gdprTypings.js';\nimport { ITelemetryData, ITelemetryService, TelemetryLevel } from './telemetry.js';\nimport { ITelemetryServiceConfig, TelemetryService } from './telemetryService.js';\nimport { NullTelemetryServiceShape } from './telemetryUtils.js';\n\nexport interface IServerTelemetryService extends ITelemetryService {\n\tupdateInjectedTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void>;\n}\n\nexport class ServerTelemetryService extends TelemetryService implements IServerTelemetryService {\n\t// Because we cannot read the workspace config on the remote site\n\t// the ServerTelemetryService is responsible for knowing its telemetry level\n\t// this is done through IPC calls and initial value injections\n\tprivate _injectedTelemetryLevel: TelemetryLevel;\n\tconstructor(\n\t\tconfig: ITelemetryServiceConfig,\n\t\tinjectedTelemetryLevel: TelemetryLevel,\n\t\t@IConfigurationService _configurationService: IConfigurationService,\n\t\t@IProductService _productService: IProductService\n\t) {\n\t\tsuper(config, _configurationService, _productService);\n\t\tthis._injectedTelemetryLevel = injectedTelemetryLevel;\n\t}\n\n\toverride publicLog(eventName: string, data?: ITelemetryData) {\n\t\tif (this._injectedTelemetryLevel < TelemetryLevel.USAGE) {\n\t\t\treturn;\n\t\t}\n\t\treturn super.publicLog(eventName, data);\n\t}\n\n\toverride publicLog2<E extends ClassifiedEvent<OmitMetadata<T>> = never, T extends IGDPRProperty = never>(eventName: string, data?: StrictPropertyCheck<T, E>) {\n\t\treturn this.publicLog(eventName, data as ITelemetryData | undefined);\n\t}\n\n\toverride publicLogError(errorEventName: string, data?: ITelemetryData) {\n\t\tif (this._injectedTelemetryLevel < TelemetryLevel.ERROR) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\t\treturn super.publicLogError(errorEventName, data);\n\t}\n\n\toverride publicLogError2<E extends ClassifiedEvent<OmitMetadata<T>> = never, T extends IGDPRProperty = never>(eventName: string, data?: StrictPropertyCheck<T, E>) {\n\t\treturn this.publicLogError(eventName, data as ITelemetryData | undefined);\n\t}\n\n\tasync updateInjectedTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void> {\n\t\tif (telemetryLevel === undefined) {\n\t\t\tthis._injectedTelemetryLevel = TelemetryLevel.NONE;\n\t\t\tthrow new Error('Telemetry level cannot be undefined. This will cause infinite looping!');\n\t\t}\n\t\t// We always take the most restrictive level because we don't want multiple clients to connect and send data when one client does not consent\n\t\tthis._injectedTelemetryLevel = this._injectedTelemetryLevel ? Math.min(this._injectedTelemetryLevel, telemetryLevel) : telemetryLevel;\n\t\tif (this._injectedTelemetryLevel === TelemetryLevel.NONE) {\n\t\t\tthis.dispose();\n\t\t}\n\t}\n}\n\nexport const ServerNullTelemetryService = new class extends NullTelemetryServiceShape implements IServerTelemetryService {\n\tasync updateInjectedTelemetryLevel(): Promise<void> { return; } // No-op, telemetry is already disabled\n};\n\nexport const IServerTelemetryService = refineServiceDecorator<ITelemetryService, IServerTelemetryService>(ITelemetryService);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { refineServiceDecorator } from '../../instantiation/common/instantiation.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { ClassifiedEvent, IGDPRProperty, OmitMetadata, StrictPropertyCheck } from './gdprTypings.js';\nimport { ITelemetryData, ITelemetryService, TelemetryLevel } from './telemetry.js';\nimport { ITelemetryServiceConfig, TelemetryService } from './telemetryService.js';\nimport { NullTelemetryServiceShape } from './telemetryUtils.js';\n\nexport interface IServerTelemetryService extends ITelemetryService {\n\tupdateInjectedTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void>;\n}\n\nexport class ServerTelemetryService extends TelemetryService implements IServerTelemetryService {\n\t// Because we cannot read the workspace config on the remote site\n\t// the ServerTelemetryService is responsible for knowing its telemetry level\n\t// this is done through IPC calls and initial value injections\n\tprivate _injectedTelemetryLevel: TelemetryLevel;\n\tconstructor(\n\t\tconfig: ITelemetryServiceConfig,\n\t\tinjectedTelemetryLevel: TelemetryLevel,\n\t\t@IConfigurationService _configurationService: IConfigurationService,\n\t\t@IProductService _productService: IProductService\n\t) {\n\t\tsuper(config, _configurationService, _productService);\n\t\tthis._injectedTelemetryLevel = injectedTelemetryLevel;\n\t}\n\n\toverride publicLog(eventName: string, data?: ITelemetryData) {\n\t\tif (this._injectedTelemetryLevel < TelemetryLevel.USAGE) {\n\t\t\treturn;\n\t\t}\n\t\treturn super.publicLog(eventName, data);\n\t}\n\n\toverride publicLog2<E extends ClassifiedEvent<OmitMetadata<T>> = never, T extends IGDPRProperty = never>(eventName: string, data?: StrictPropertyCheck<T, E>) {\n\t\treturn this.publicLog(eventName, data as ITelemetryData | undefined);\n\t}\n\n\toverride publicLogError(errorEventName: string, data?: ITelemetryData) {\n\t\tif (this._injectedTelemetryLevel < TelemetryLevel.ERROR) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\t\treturn super.publicLogError(errorEventName, data);\n\t}\n\n\toverride publicLogError2<E extends ClassifiedEvent<OmitMetadata<T>> = never, T extends IGDPRProperty = never>(eventName: string, data?: StrictPropertyCheck<T, E>) {\n\t\treturn this.publicLogError(eventName, data as ITelemetryData | undefined);\n\t}\n\n\tasync updateInjectedTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void> {\n\t\tif (telemetryLevel === undefined) {\n\t\t\tthis._injectedTelemetryLevel = TelemetryLevel.NONE;\n\t\t\tthrow new Error('Telemetry level cannot be undefined. This will cause infinite looping!');\n\t\t}\n\t\t// We always take the most restrictive level because we don't want multiple clients to connect and send data when one client does not consent\n\t\tthis._injectedTelemetryLevel = this._injectedTelemetryLevel ? Math.min(this._injectedTelemetryLevel, telemetryLevel) : telemetryLevel;\n\t\tif (this._injectedTelemetryLevel === TelemetryLevel.NONE) {\n\t\t\tthis.dispose();\n\t\t}\n\t}\n}\n\nexport const ServerNullTelemetryService = new class extends NullTelemetryServiceShape implements IServerTelemetryService {\n\tasync updateInjectedTelemetryLevel(): Promise<void> { return; } // No-op, telemetry is already disabled\n};\n\nexport const IServerTelemetryService = refineServiceDecorator<ITelemetryService, IServerTelemetryService>(ITelemetryService);\n"]}