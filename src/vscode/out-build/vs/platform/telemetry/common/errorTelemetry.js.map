{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/telemetry/common/errorTelemetry.ts","vs/platform/telemetry/common/errorTelemetry.ts"],"names":[],"mappings":"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","file":"errorTelemetry.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { binarySearch } from '../../../base/common/arrays.js';\nimport { errorHandler, ErrorNoTelemetry, PendingMigrationError } from '../../../base/common/errors.js';\nimport { DisposableStore, toDisposable } from '../../../base/common/lifecycle.js';\nimport { safeStringify } from '../../../base/common/objects.js';\nimport { FileOperationError } from '../../files/common/files.js';\nimport { ITelemetryService } from './telemetry.js';\n\ntype ErrorEventFragment = {\n\towner: 'lramos15, sbatten';\n\tcomment: 'Whenever an error in VS Code is thrown.';\n\tcallstack: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'The callstack of the error.' };\n\tmsg?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'The message of the error. Normally the first line int the callstack.' };\n\tfile?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'The file the error originated from.' };\n\tline?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'The line the error originate on.' };\n\tcolumn?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'The column of the line which the error orginated on.' };\n\tuncaught_error_name?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'If the error is uncaught what is the error type' };\n\tuncaught_error_msg?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'If the error is uncaught this is just msg but for uncaught errors.' };\n\tcount?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'How many times this error has been thrown' };\n};\nexport interface ErrorEvent {\n\tcallstack: string;\n\tmsg?: string;\n\tfile?: string;\n\tline?: number;\n\tcolumn?: number;\n\tuncaught_error_name?: string;\n\tuncaught_error_msg?: string;\n\tcount?: number;\n}\n\nexport namespace ErrorEvent {\n\texport function compare(a: ErrorEvent, b: ErrorEvent) {\n\t\tif (a.callstack < b.callstack) {\n\t\t\treturn -1;\n\t\t} else if (a.callstack > b.callstack) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nexport default abstract class BaseErrorTelemetry {\n\n\tpublic static ERROR_FLUSH_TIMEOUT: number = 5 * 1000;\n\n\tprivate _telemetryService: ITelemetryService;\n\tprivate _flushDelay: number;\n\tprivate _flushHandle: Timeout | undefined = undefined;\n\tprivate _buffer: ErrorEvent[] = [];\n\tprotected readonly _disposables = new DisposableStore();\n\n\tconstructor(telemetryService: ITelemetryService, flushDelay = BaseErrorTelemetry.ERROR_FLUSH_TIMEOUT) {\n\t\tthis._telemetryService = telemetryService;\n\t\tthis._flushDelay = flushDelay;\n\n\t\t// (1) check for unexpected but handled errors\n\t\tconst unbind = errorHandler.addListener((err) => this._onErrorEvent(err));\n\t\tthis._disposables.add(toDisposable(unbind));\n\n\t\t// (2) install implementation-specific error listeners\n\t\tthis.installErrorListeners();\n\t}\n\n\tdispose() {\n\t\tclearTimeout(this._flushHandle);\n\t\tthis._flushBuffer();\n\t\tthis._disposables.dispose();\n\t}\n\n\tprotected installErrorListeners(): void {\n\t\t// to override\n\t}\n\n\tprivate _onErrorEvent(err: any): void {\n\n\t\tif (!err || err.code) {\n\t\t\treturn;\n\t\t}\n\n\t\t// unwrap nested errors from loader\n\t\tif (err.detail && err.detail.stack) {\n\t\t\terr = err.detail;\n\t\t}\n\n\t\t// If it's the no telemetry error it doesn't get logged\n\t\t// TOOD @lramos15 hacking in FileOperation error because it's too messy to adopt ErrorNoTelemetry. A better solution should be found\n\t\t//\n\t\t// Explicitly filter out PendingMigrationError for https://github.com/microsoft/vscode/issues/250648#issuecomment-3394040431\n\t\t// We don't inherit from ErrorNoTelemetry to preserve the name used in reporting for exthostdeprecatedapiusage event.\n\t\t// TODO(deepak1556): remove when PendingMigrationError is no longer needed.\n\t\tif (ErrorNoTelemetry.isErrorNoTelemetry(err) || err instanceof FileOperationError || PendingMigrationError.is(err) || (typeof err?.message === 'string' && err.message.includes('Unable to read file'))) {\n\t\t\treturn;\n\t\t}\n\n\t\t// work around behavior in workerServer.ts that breaks up Error.stack\n\t\tconst callstack = Array.isArray(err.stack) ? err.stack.join('\\n') : err.stack;\n\t\tconst msg = err.message ? err.message : safeStringify(err);\n\n\t\t// errors without a stack are not useful telemetry\n\t\tif (!callstack) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._enqueue({ msg, callstack });\n\t}\n\n\tprotected _enqueue(e: ErrorEvent): void {\n\n\t\tconst idx = binarySearch(this._buffer, e, ErrorEvent.compare);\n\t\tif (idx < 0) {\n\t\t\te.count = 1;\n\t\t\tthis._buffer.splice(~idx, 0, e);\n\t\t} else {\n\t\t\tif (!this._buffer[idx].count) {\n\t\t\t\tthis._buffer[idx].count = 0;\n\t\t\t}\n\t\t\tthis._buffer[idx].count += 1;\n\t\t}\n\n\t\tif (this._flushHandle === undefined) {\n\t\t\tthis._flushHandle = setTimeout(() => {\n\t\t\t\tthis._flushBuffer();\n\t\t\t\tthis._flushHandle = undefined;\n\t\t\t}, this._flushDelay);\n\t\t}\n\t}\n\n\tprivate _flushBuffer(): void {\n\t\tfor (const error of this._buffer) {\n\t\t\ttype UnhandledErrorClassification = {} & ErrorEventFragment;\n\t\t\tthis._telemetryService.publicLogError2<ErrorEvent, UnhandledErrorClassification>('UnhandledError', error);\n\t\t}\n\t\tthis._buffer.length = 0;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { binarySearch } from '../../../base/common/arrays.js';\nimport { errorHandler, ErrorNoTelemetry, PendingMigrationError } from '../../../base/common/errors.js';\nimport { DisposableStore, toDisposable } from '../../../base/common/lifecycle.js';\nimport { safeStringify } from '../../../base/common/objects.js';\nimport { FileOperationError } from '../../files/common/files.js';\nimport { ITelemetryService } from './telemetry.js';\n\ntype ErrorEventFragment = {\n\towner: 'lramos15, sbatten';\n\tcomment: 'Whenever an error in VS Code is thrown.';\n\tcallstack: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'The callstack of the error.' };\n\tmsg?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'The message of the error. Normally the first line int the callstack.' };\n\tfile?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'The file the error originated from.' };\n\tline?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'The line the error originate on.' };\n\tcolumn?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'The column of the line which the error orginated on.' };\n\tuncaught_error_name?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'If the error is uncaught what is the error type' };\n\tuncaught_error_msg?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'If the error is uncaught this is just msg but for uncaught errors.' };\n\tcount?: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'How many times this error has been thrown' };\n};\nexport interface ErrorEvent {\n\tcallstack: string;\n\tmsg?: string;\n\tfile?: string;\n\tline?: number;\n\tcolumn?: number;\n\tuncaught_error_name?: string;\n\tuncaught_error_msg?: string;\n\tcount?: number;\n}\n\nexport namespace ErrorEvent {\n\texport function compare(a: ErrorEvent, b: ErrorEvent) {\n\t\tif (a.callstack < b.callstack) {\n\t\t\treturn -1;\n\t\t} else if (a.callstack > b.callstack) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nexport default abstract class BaseErrorTelemetry {\n\n\tpublic static ERROR_FLUSH_TIMEOUT: number = 5 * 1000;\n\n\tprivate _telemetryService: ITelemetryService;\n\tprivate _flushDelay: number;\n\tprivate _flushHandle: Timeout | undefined = undefined;\n\tprivate _buffer: ErrorEvent[] = [];\n\tprotected readonly _disposables = new DisposableStore();\n\n\tconstructor(telemetryService: ITelemetryService, flushDelay = BaseErrorTelemetry.ERROR_FLUSH_TIMEOUT) {\n\t\tthis._telemetryService = telemetryService;\n\t\tthis._flushDelay = flushDelay;\n\n\t\t// (1) check for unexpected but handled errors\n\t\tconst unbind = errorHandler.addListener((err) => this._onErrorEvent(err));\n\t\tthis._disposables.add(toDisposable(unbind));\n\n\t\t// (2) install implementation-specific error listeners\n\t\tthis.installErrorListeners();\n\t}\n\n\tdispose() {\n\t\tclearTimeout(this._flushHandle);\n\t\tthis._flushBuffer();\n\t\tthis._disposables.dispose();\n\t}\n\n\tprotected installErrorListeners(): void {\n\t\t// to override\n\t}\n\n\tprivate _onErrorEvent(err: any): void {\n\n\t\tif (!err || err.code) {\n\t\t\treturn;\n\t\t}\n\n\t\t// unwrap nested errors from loader\n\t\tif (err.detail && err.detail.stack) {\n\t\t\terr = err.detail;\n\t\t}\n\n\t\t// If it's the no telemetry error it doesn't get logged\n\t\t// TOOD @lramos15 hacking in FileOperation error because it's too messy to adopt ErrorNoTelemetry. A better solution should be found\n\t\t//\n\t\t// Explicitly filter out PendingMigrationError for https://github.com/microsoft/vscode/issues/250648#issuecomment-3394040431\n\t\t// We don't inherit from ErrorNoTelemetry to preserve the name used in reporting for exthostdeprecatedapiusage event.\n\t\t// TODO(deepak1556): remove when PendingMigrationError is no longer needed.\n\t\tif (ErrorNoTelemetry.isErrorNoTelemetry(err) || err instanceof FileOperationError || PendingMigrationError.is(err) || (typeof err?.message === 'string' && err.message.includes('Unable to read file'))) {\n\t\t\treturn;\n\t\t}\n\n\t\t// work around behavior in workerServer.ts that breaks up Error.stack\n\t\tconst callstack = Array.isArray(err.stack) ? err.stack.join('\\n') : err.stack;\n\t\tconst msg = err.message ? err.message : safeStringify(err);\n\n\t\t// errors without a stack are not useful telemetry\n\t\tif (!callstack) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._enqueue({ msg, callstack });\n\t}\n\n\tprotected _enqueue(e: ErrorEvent): void {\n\n\t\tconst idx = binarySearch(this._buffer, e, ErrorEvent.compare);\n\t\tif (idx < 0) {\n\t\t\te.count = 1;\n\t\t\tthis._buffer.splice(~idx, 0, e);\n\t\t} else {\n\t\t\tif (!this._buffer[idx].count) {\n\t\t\t\tthis._buffer[idx].count = 0;\n\t\t\t}\n\t\t\tthis._buffer[idx].count += 1;\n\t\t}\n\n\t\tif (this._flushHandle === undefined) {\n\t\t\tthis._flushHandle = setTimeout(() => {\n\t\t\t\tthis._flushBuffer();\n\t\t\t\tthis._flushHandle = undefined;\n\t\t\t}, this._flushDelay);\n\t\t}\n\t}\n\n\tprivate _flushBuffer(): void {\n\t\tfor (const error of this._buffer) {\n\t\t\ttype UnhandledErrorClassification = {} & ErrorEventFragment;\n\t\t\tthis._telemetryService.publicLogError2<ErrorEvent, UnhandledErrorClassification>('UnhandledError', error);\n\t\t}\n\t\tthis._buffer.length = 0;\n\t}\n}\n"]}