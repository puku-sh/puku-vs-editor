{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/tunnel/node/tunnelService.ts","vs/platform/tunnel/node/tunnelService.ts"],"names":[],"mappings":"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","file":"tunnelService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as net from 'net';\nimport * as os from 'os';\nimport { BROWSER_RESTRICTED_PORTS, findFreePortFaster } from '../../../base/node/ports.js';\nimport { NodeSocket } from '../../../base/parts/ipc/node/ipc.net.js';\n\nimport { Barrier } from '../../../base/common/async.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { OS } from '../../../base/common/platform.js';\nimport { ISocket } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { IAddressProvider, IConnectionOptions, connectRemoteAgentTunnel } from '../../remote/common/remoteAgentConnection.js';\nimport { IRemoteSocketFactoryService } from '../../remote/common/remoteSocketFactoryService.js';\nimport { ISignService } from '../../sign/common/sign.js';\nimport { AbstractTunnelService, ISharedTunnelsService, ITunnelProvider, ITunnelService, RemoteTunnel, TunnelPrivacyId, isAllInterfaces, isLocalhost, isPortPrivileged, isTunnelProvider } from '../common/tunnel.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\n\nasync function createRemoteTunnel(options: IConnectionOptions, defaultTunnelHost: string, tunnelRemoteHost: string, tunnelRemotePort: number, tunnelLocalPort?: number): Promise<RemoteTunnel> {\n\tlet readyTunnel: NodeRemoteTunnel | undefined;\n\tfor (let attempts = 3; attempts; attempts--) {\n\t\treadyTunnel?.dispose();\n\t\tconst tunnel = new NodeRemoteTunnel(options, defaultTunnelHost, tunnelRemoteHost, tunnelRemotePort, tunnelLocalPort);\n\t\treadyTunnel = await tunnel.waitForReady();\n\t\tif ((tunnelLocalPort && BROWSER_RESTRICTED_PORTS[tunnelLocalPort]) || !BROWSER_RESTRICTED_PORTS[readyTunnel.tunnelLocalPort]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn readyTunnel!;\n}\n\nexport class NodeRemoteTunnel extends Disposable implements RemoteTunnel {\n\n\tpublic readonly tunnelRemotePort: number;\n\tpublic tunnelLocalPort!: number;\n\tpublic tunnelRemoteHost: string;\n\tpublic localAddress!: string;\n\tpublic readonly privacy = TunnelPrivacyId.Private;\n\n\tprivate readonly _options: IConnectionOptions;\n\tprivate readonly _server: net.Server;\n\tprivate readonly _barrier: Barrier;\n\n\tprivate readonly _listeningListener: () => void;\n\tprivate readonly _connectionListener: (socket: net.Socket) => void;\n\tprivate readonly _errorListener: () => void;\n\n\tprivate readonly _socketsDispose: Map<string, () => void> = new Map();\n\n\tconstructor(options: IConnectionOptions, private readonly defaultTunnelHost: string, tunnelRemoteHost: string, tunnelRemotePort: number, private readonly suggestedLocalPort?: number) {\n\t\tsuper();\n\t\tthis._options = options;\n\t\tthis._server = net.createServer();\n\t\tthis._barrier = new Barrier();\n\n\t\tthis._listeningListener = () => this._barrier.open();\n\t\tthis._server.on('listening', this._listeningListener);\n\n\t\tthis._connectionListener = (socket) => this._onConnection(socket);\n\t\tthis._server.on('connection', this._connectionListener);\n\n\t\t// If there is no error listener and there is an error it will crash the whole window\n\t\tthis._errorListener = () => { };\n\t\tthis._server.on('error', this._errorListener);\n\n\t\tthis.tunnelRemotePort = tunnelRemotePort;\n\t\tthis.tunnelRemoteHost = tunnelRemoteHost;\n\t}\n\n\tpublic override async dispose(): Promise<void> {\n\t\tsuper.dispose();\n\t\tthis._server.removeListener('listening', this._listeningListener);\n\t\tthis._server.removeListener('connection', this._connectionListener);\n\t\tthis._server.removeListener('error', this._errorListener);\n\t\tthis._server.close();\n\t\tconst disposers = Array.from(this._socketsDispose.values());\n\t\tdisposers.forEach(disposer => {\n\t\t\tdisposer();\n\t\t});\n\t}\n\n\tpublic async waitForReady(): Promise<this> {\n\t\tconst startPort = this.suggestedLocalPort ?? this.tunnelRemotePort;\n\t\tconst hostname = isAllInterfaces(this.defaultTunnelHost) ? '0.0.0.0' : '127.0.0.1';\n\t\t// try to get the same port number as the remote port number...\n\t\tlet localPort = await findFreePortFaster(startPort, 2, 1000, hostname);\n\n\t\t// if that fails, the method above returns 0, which works out fine below...\n\t\tlet address: string | net.AddressInfo | null = null;\n\t\tthis._server.listen(localPort, this.defaultTunnelHost);\n\t\tawait this._barrier.wait();\n\t\taddress = <net.AddressInfo>this._server.address();\n\n\t\t// It is possible for findFreePortFaster to return a port that there is already a server listening on. This causes the previous listen call to error out.\n\t\tif (!address) {\n\t\t\tlocalPort = 0;\n\t\t\tthis._server.listen(localPort, this.defaultTunnelHost);\n\t\t\tawait this._barrier.wait();\n\t\t\taddress = <net.AddressInfo>this._server.address();\n\t\t}\n\n\t\tthis.tunnelLocalPort = address.port;\n\t\tthis.localAddress = `${this.tunnelRemoteHost === '127.0.0.1' ? '127.0.0.1' : 'localhost'}:${address.port}`;\n\t\treturn this;\n\t}\n\n\tprivate async _onConnection(localSocket: net.Socket): Promise<void> {\n\t\t// pause reading on the socket until we have a chance to forward its data\n\t\tlocalSocket.pause();\n\n\t\tconst tunnelRemoteHost = (isLocalhost(this.tunnelRemoteHost) || isAllInterfaces(this.tunnelRemoteHost)) ? 'localhost' : this.tunnelRemoteHost;\n\t\tconst protocol = await connectRemoteAgentTunnel(this._options, tunnelRemoteHost, this.tunnelRemotePort);\n\t\tconst remoteSocket = protocol.getSocket();\n\t\tconst dataChunk = protocol.readEntireBuffer();\n\t\tprotocol.dispose();\n\n\t\tif (dataChunk.byteLength > 0) {\n\t\t\tlocalSocket.write(dataChunk.buffer);\n\t\t}\n\n\t\tlocalSocket.on('end', () => {\n\t\t\tif (localSocket.localAddress) {\n\t\t\t\tthis._socketsDispose.delete(localSocket.localAddress);\n\t\t\t}\n\t\t\tremoteSocket.end();\n\t\t});\n\t\tlocalSocket.on('close', () => remoteSocket.end());\n\t\tlocalSocket.on('error', () => {\n\t\t\tif (localSocket.localAddress) {\n\t\t\t\tthis._socketsDispose.delete(localSocket.localAddress);\n\t\t\t}\n\t\t\tif (remoteSocket instanceof NodeSocket) {\n\t\t\t\tremoteSocket.socket.destroy();\n\t\t\t} else {\n\t\t\t\tremoteSocket.end();\n\t\t\t}\n\t\t});\n\n\t\tif (remoteSocket instanceof NodeSocket) {\n\t\t\tthis._mirrorNodeSocket(localSocket, remoteSocket);\n\t\t} else {\n\t\t\tthis._mirrorGenericSocket(localSocket, remoteSocket);\n\t\t}\n\n\t\tif (localSocket.localAddress) {\n\t\t\tthis._socketsDispose.set(localSocket.localAddress, () => {\n\t\t\t\t// Need to end instead of unpipe, otherwise whatever is connected locally could end up \"stuck\" with whatever state it had until manually exited.\n\t\t\t\tlocalSocket.end();\n\t\t\t\tremoteSocket.end();\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _mirrorGenericSocket(localSocket: net.Socket, remoteSocket: ISocket) {\n\t\tremoteSocket.onClose(() => localSocket.destroy());\n\t\tremoteSocket.onEnd(() => localSocket.end());\n\t\tremoteSocket.onData(d => localSocket.write(d.buffer));\n\t\tlocalSocket.on('data', d => remoteSocket.write(VSBuffer.wrap(d)));\n\t\tlocalSocket.resume();\n\t}\n\n\tprivate _mirrorNodeSocket(localSocket: net.Socket, remoteNodeSocket: NodeSocket) {\n\t\tconst remoteSocket = remoteNodeSocket.socket;\n\t\tremoteSocket.on('end', () => localSocket.end());\n\t\tremoteSocket.on('close', () => localSocket.end());\n\t\tremoteSocket.on('error', () => {\n\t\t\tlocalSocket.destroy();\n\t\t});\n\n\t\tremoteSocket.pipe(localSocket);\n\t\tlocalSocket.pipe(remoteSocket);\n\t}\n}\n\nexport class BaseTunnelService extends AbstractTunnelService {\n\tpublic constructor(\n\t\t@IRemoteSocketFactoryService private readonly remoteSocketFactoryService: IRemoteSocketFactoryService,\n\t\t@ILogService logService: ILogService,\n\t\t@ISignService private readonly signService: ISignService,\n\t\t@IProductService private readonly productService: IProductService,\n\t\t@IConfigurationService configurationService: IConfigurationService\n\t) {\n\t\tsuper(logService, configurationService);\n\t}\n\n\tpublic isPortPrivileged(port: number): boolean {\n\t\treturn isPortPrivileged(port, this.defaultTunnelHost, OS, os.release());\n\t}\n\n\tprotected retainOrCreateTunnel(addressOrTunnelProvider: IAddressProvider | ITunnelProvider, remoteHost: string, remotePort: number, localHost: string, localPort: number | undefined, elevateIfNeeded: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tconst existing = this.getTunnelFromMap(remoteHost, remotePort);\n\t\tif (existing) {\n\t\t\t++existing.refcount;\n\t\t\treturn existing.value;\n\t\t}\n\n\t\tif (isTunnelProvider(addressOrTunnelProvider)) {\n\t\t\treturn this.createWithProvider(addressOrTunnelProvider, remoteHost, remotePort, localPort, elevateIfNeeded, privacy, protocol);\n\t\t} else {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel without provider ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\t\tconst options: IConnectionOptions = {\n\t\t\t\tcommit: this.productService.commit,\n\t\t\t\tquality: this.productService.quality,\n\t\t\t\taddressProvider: addressOrTunnelProvider,\n\t\t\t\tremoteSocketFactoryService: this.remoteSocketFactoryService,\n\t\t\t\tsignService: this.signService,\n\t\t\t\tlogService: this.logService,\n\t\t\t\tipcLogger: null\n\t\t\t};\n\n\t\t\tconst tunnel = createRemoteTunnel(options, localHost, remoteHost, remotePort, localPort);\n\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) Tunnel created without provider.');\n\t\t\tthis.addTunnelToMap(remoteHost, remotePort, tunnel);\n\t\t\treturn tunnel;\n\t\t}\n\t}\n}\n\nexport class TunnelService extends BaseTunnelService {\n\tpublic constructor(\n\t\t@IRemoteSocketFactoryService remoteSocketFactoryService: IRemoteSocketFactoryService,\n\t\t@ILogService logService: ILogService,\n\t\t@ISignService signService: ISignService,\n\t\t@IProductService productService: IProductService,\n\t\t@IConfigurationService configurationService: IConfigurationService\n\t) {\n\t\tsuper(remoteSocketFactoryService, logService, signService, productService, configurationService);\n\t}\n}\n\nexport class SharedTunnelsService extends Disposable implements ISharedTunnelsService {\n\tdeclare readonly _serviceBrand: undefined;\n\tprivate readonly _tunnelServices: Map<string, ITunnelService> = new Map();\n\n\tpublic constructor(\n\t\t@IRemoteSocketFactoryService protected readonly remoteSocketFactoryService: IRemoteSocketFactoryService,\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IProductService private readonly productService: IProductService,\n\t\t@ISignService private readonly signService: ISignService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t) {\n\t\tsuper();\n\t}\n\n\tasync openTunnel(authority: string, addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> {\n\t\tthis.logService.trace(`ForwardedPorts: (SharedTunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tif (!this._tunnelServices.has(authority)) {\n\t\t\tconst tunnelService = new TunnelService(this.remoteSocketFactoryService, this.logService, this.signService, this.productService, this.configurationService);\n\t\t\tthis._register(tunnelService);\n\t\t\tthis._tunnelServices.set(authority, tunnelService);\n\t\t\ttunnelService.onTunnelClosed(async () => {\n\t\t\t\tif ((await tunnelService.tunnels).length === 0) {\n\t\t\t\t\ttunnelService.dispose();\n\t\t\t\t\tthis._tunnelServices.delete(authority);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this._tunnelServices.get(authority)!.openTunnel(addressProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded, privacy, protocol);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as net from 'net';\nimport * as os from 'os';\nimport { BROWSER_RESTRICTED_PORTS, findFreePortFaster } from '../../../base/node/ports.js';\nimport { NodeSocket } from '../../../base/parts/ipc/node/ipc.net.js';\n\nimport { Barrier } from '../../../base/common/async.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { OS } from '../../../base/common/platform.js';\nimport { ISocket } from '../../../base/parts/ipc/common/ipc.net.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IProductService } from '../../product/common/productService.js';\nimport { IAddressProvider, IConnectionOptions, connectRemoteAgentTunnel } from '../../remote/common/remoteAgentConnection.js';\nimport { IRemoteSocketFactoryService } from '../../remote/common/remoteSocketFactoryService.js';\nimport { ISignService } from '../../sign/common/sign.js';\nimport { AbstractTunnelService, ISharedTunnelsService, ITunnelProvider, ITunnelService, RemoteTunnel, TunnelPrivacyId, isAllInterfaces, isLocalhost, isPortPrivileged, isTunnelProvider } from '../common/tunnel.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\n\nasync function createRemoteTunnel(options: IConnectionOptions, defaultTunnelHost: string, tunnelRemoteHost: string, tunnelRemotePort: number, tunnelLocalPort?: number): Promise<RemoteTunnel> {\n\tlet readyTunnel: NodeRemoteTunnel | undefined;\n\tfor (let attempts = 3; attempts; attempts--) {\n\t\treadyTunnel?.dispose();\n\t\tconst tunnel = new NodeRemoteTunnel(options, defaultTunnelHost, tunnelRemoteHost, tunnelRemotePort, tunnelLocalPort);\n\t\treadyTunnel = await tunnel.waitForReady();\n\t\tif ((tunnelLocalPort && BROWSER_RESTRICTED_PORTS[tunnelLocalPort]) || !BROWSER_RESTRICTED_PORTS[readyTunnel.tunnelLocalPort]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn readyTunnel!;\n}\n\nexport class NodeRemoteTunnel extends Disposable implements RemoteTunnel {\n\n\tpublic readonly tunnelRemotePort: number;\n\tpublic tunnelLocalPort!: number;\n\tpublic tunnelRemoteHost: string;\n\tpublic localAddress!: string;\n\tpublic readonly privacy = TunnelPrivacyId.Private;\n\n\tprivate readonly _options: IConnectionOptions;\n\tprivate readonly _server: net.Server;\n\tprivate readonly _barrier: Barrier;\n\n\tprivate readonly _listeningListener: () => void;\n\tprivate readonly _connectionListener: (socket: net.Socket) => void;\n\tprivate readonly _errorListener: () => void;\n\n\tprivate readonly _socketsDispose: Map<string, () => void> = new Map();\n\n\tconstructor(options: IConnectionOptions, private readonly defaultTunnelHost: string, tunnelRemoteHost: string, tunnelRemotePort: number, private readonly suggestedLocalPort?: number) {\n\t\tsuper();\n\t\tthis._options = options;\n\t\tthis._server = net.createServer();\n\t\tthis._barrier = new Barrier();\n\n\t\tthis._listeningListener = () => this._barrier.open();\n\t\tthis._server.on('listening', this._listeningListener);\n\n\t\tthis._connectionListener = (socket) => this._onConnection(socket);\n\t\tthis._server.on('connection', this._connectionListener);\n\n\t\t// If there is no error listener and there is an error it will crash the whole window\n\t\tthis._errorListener = () => { };\n\t\tthis._server.on('error', this._errorListener);\n\n\t\tthis.tunnelRemotePort = tunnelRemotePort;\n\t\tthis.tunnelRemoteHost = tunnelRemoteHost;\n\t}\n\n\tpublic override async dispose(): Promise<void> {\n\t\tsuper.dispose();\n\t\tthis._server.removeListener('listening', this._listeningListener);\n\t\tthis._server.removeListener('connection', this._connectionListener);\n\t\tthis._server.removeListener('error', this._errorListener);\n\t\tthis._server.close();\n\t\tconst disposers = Array.from(this._socketsDispose.values());\n\t\tdisposers.forEach(disposer => {\n\t\t\tdisposer();\n\t\t});\n\t}\n\n\tpublic async waitForReady(): Promise<this> {\n\t\tconst startPort = this.suggestedLocalPort ?? this.tunnelRemotePort;\n\t\tconst hostname = isAllInterfaces(this.defaultTunnelHost) ? '0.0.0.0' : '127.0.0.1';\n\t\t// try to get the same port number as the remote port number...\n\t\tlet localPort = await findFreePortFaster(startPort, 2, 1000, hostname);\n\n\t\t// if that fails, the method above returns 0, which works out fine below...\n\t\tlet address: string | net.AddressInfo | null = null;\n\t\tthis._server.listen(localPort, this.defaultTunnelHost);\n\t\tawait this._barrier.wait();\n\t\taddress = <net.AddressInfo>this._server.address();\n\n\t\t// It is possible for findFreePortFaster to return a port that there is already a server listening on. This causes the previous listen call to error out.\n\t\tif (!address) {\n\t\t\tlocalPort = 0;\n\t\t\tthis._server.listen(localPort, this.defaultTunnelHost);\n\t\t\tawait this._barrier.wait();\n\t\t\taddress = <net.AddressInfo>this._server.address();\n\t\t}\n\n\t\tthis.tunnelLocalPort = address.port;\n\t\tthis.localAddress = `${this.tunnelRemoteHost === '127.0.0.1' ? '127.0.0.1' : 'localhost'}:${address.port}`;\n\t\treturn this;\n\t}\n\n\tprivate async _onConnection(localSocket: net.Socket): Promise<void> {\n\t\t// pause reading on the socket until we have a chance to forward its data\n\t\tlocalSocket.pause();\n\n\t\tconst tunnelRemoteHost = (isLocalhost(this.tunnelRemoteHost) || isAllInterfaces(this.tunnelRemoteHost)) ? 'localhost' : this.tunnelRemoteHost;\n\t\tconst protocol = await connectRemoteAgentTunnel(this._options, tunnelRemoteHost, this.tunnelRemotePort);\n\t\tconst remoteSocket = protocol.getSocket();\n\t\tconst dataChunk = protocol.readEntireBuffer();\n\t\tprotocol.dispose();\n\n\t\tif (dataChunk.byteLength > 0) {\n\t\t\tlocalSocket.write(dataChunk.buffer);\n\t\t}\n\n\t\tlocalSocket.on('end', () => {\n\t\t\tif (localSocket.localAddress) {\n\t\t\t\tthis._socketsDispose.delete(localSocket.localAddress);\n\t\t\t}\n\t\t\tremoteSocket.end();\n\t\t});\n\t\tlocalSocket.on('close', () => remoteSocket.end());\n\t\tlocalSocket.on('error', () => {\n\t\t\tif (localSocket.localAddress) {\n\t\t\t\tthis._socketsDispose.delete(localSocket.localAddress);\n\t\t\t}\n\t\t\tif (remoteSocket instanceof NodeSocket) {\n\t\t\t\tremoteSocket.socket.destroy();\n\t\t\t} else {\n\t\t\t\tremoteSocket.end();\n\t\t\t}\n\t\t});\n\n\t\tif (remoteSocket instanceof NodeSocket) {\n\t\t\tthis._mirrorNodeSocket(localSocket, remoteSocket);\n\t\t} else {\n\t\t\tthis._mirrorGenericSocket(localSocket, remoteSocket);\n\t\t}\n\n\t\tif (localSocket.localAddress) {\n\t\t\tthis._socketsDispose.set(localSocket.localAddress, () => {\n\t\t\t\t// Need to end instead of unpipe, otherwise whatever is connected locally could end up \"stuck\" with whatever state it had until manually exited.\n\t\t\t\tlocalSocket.end();\n\t\t\t\tremoteSocket.end();\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _mirrorGenericSocket(localSocket: net.Socket, remoteSocket: ISocket) {\n\t\tremoteSocket.onClose(() => localSocket.destroy());\n\t\tremoteSocket.onEnd(() => localSocket.end());\n\t\tremoteSocket.onData(d => localSocket.write(d.buffer));\n\t\tlocalSocket.on('data', d => remoteSocket.write(VSBuffer.wrap(d)));\n\t\tlocalSocket.resume();\n\t}\n\n\tprivate _mirrorNodeSocket(localSocket: net.Socket, remoteNodeSocket: NodeSocket) {\n\t\tconst remoteSocket = remoteNodeSocket.socket;\n\t\tremoteSocket.on('end', () => localSocket.end());\n\t\tremoteSocket.on('close', () => localSocket.end());\n\t\tremoteSocket.on('error', () => {\n\t\t\tlocalSocket.destroy();\n\t\t});\n\n\t\tremoteSocket.pipe(localSocket);\n\t\tlocalSocket.pipe(remoteSocket);\n\t}\n}\n\nexport class BaseTunnelService extends AbstractTunnelService {\n\tpublic constructor(\n\t\t@IRemoteSocketFactoryService private readonly remoteSocketFactoryService: IRemoteSocketFactoryService,\n\t\t@ILogService logService: ILogService,\n\t\t@ISignService private readonly signService: ISignService,\n\t\t@IProductService private readonly productService: IProductService,\n\t\t@IConfigurationService configurationService: IConfigurationService\n\t) {\n\t\tsuper(logService, configurationService);\n\t}\n\n\tpublic isPortPrivileged(port: number): boolean {\n\t\treturn isPortPrivileged(port, this.defaultTunnelHost, OS, os.release());\n\t}\n\n\tprotected retainOrCreateTunnel(addressOrTunnelProvider: IAddressProvider | ITunnelProvider, remoteHost: string, remotePort: number, localHost: string, localPort: number | undefined, elevateIfNeeded: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tconst existing = this.getTunnelFromMap(remoteHost, remotePort);\n\t\tif (existing) {\n\t\t\t++existing.refcount;\n\t\t\treturn existing.value;\n\t\t}\n\n\t\tif (isTunnelProvider(addressOrTunnelProvider)) {\n\t\t\treturn this.createWithProvider(addressOrTunnelProvider, remoteHost, remotePort, localPort, elevateIfNeeded, privacy, protocol);\n\t\t} else {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel without provider ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\t\tconst options: IConnectionOptions = {\n\t\t\t\tcommit: this.productService.commit,\n\t\t\t\tquality: this.productService.quality,\n\t\t\t\taddressProvider: addressOrTunnelProvider,\n\t\t\t\tremoteSocketFactoryService: this.remoteSocketFactoryService,\n\t\t\t\tsignService: this.signService,\n\t\t\t\tlogService: this.logService,\n\t\t\t\tipcLogger: null\n\t\t\t};\n\n\t\t\tconst tunnel = createRemoteTunnel(options, localHost, remoteHost, remotePort, localPort);\n\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) Tunnel created without provider.');\n\t\t\tthis.addTunnelToMap(remoteHost, remotePort, tunnel);\n\t\t\treturn tunnel;\n\t\t}\n\t}\n}\n\nexport class TunnelService extends BaseTunnelService {\n\tpublic constructor(\n\t\t@IRemoteSocketFactoryService remoteSocketFactoryService: IRemoteSocketFactoryService,\n\t\t@ILogService logService: ILogService,\n\t\t@ISignService signService: ISignService,\n\t\t@IProductService productService: IProductService,\n\t\t@IConfigurationService configurationService: IConfigurationService\n\t) {\n\t\tsuper(remoteSocketFactoryService, logService, signService, productService, configurationService);\n\t}\n}\n\nexport class SharedTunnelsService extends Disposable implements ISharedTunnelsService {\n\tdeclare readonly _serviceBrand: undefined;\n\tprivate readonly _tunnelServices: Map<string, ITunnelService> = new Map();\n\n\tpublic constructor(\n\t\t@IRemoteSocketFactoryService protected readonly remoteSocketFactoryService: IRemoteSocketFactoryService,\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IProductService private readonly productService: IProductService,\n\t\t@ISignService private readonly signService: ISignService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t) {\n\t\tsuper();\n\t}\n\n\tasync openTunnel(authority: string, addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> {\n\t\tthis.logService.trace(`ForwardedPorts: (SharedTunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tif (!this._tunnelServices.has(authority)) {\n\t\t\tconst tunnelService = new TunnelService(this.remoteSocketFactoryService, this.logService, this.signService, this.productService, this.configurationService);\n\t\t\tthis._register(tunnelService);\n\t\t\tthis._tunnelServices.set(authority, tunnelService);\n\t\t\ttunnelService.onTunnelClosed(async () => {\n\t\t\t\tif ((await tunnelService.tunnels).length === 0) {\n\t\t\t\t\ttunnelService.dispose();\n\t\t\t\t\tthis._tunnelServices.delete(authority);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this._tunnelServices.get(authority)!.openTunnel(addressProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded, privacy, protocol);\n\t}\n}\n"]}