{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/tunnel/common/tunnel.ts","vs/platform/tunnel/common/tunnel.ts"],"names":[],"mappings":"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","file":"tunnel.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IDisposable, Disposable } from '../../../base/common/lifecycle.js';\nimport { OperatingSystem } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IAddressProvider } from '../../remote/common/remoteAgentConnection.js';\nimport { TunnelPrivacy } from '../../remote/common/remoteAuthorityResolver.js';\n\nexport const ITunnelService = createDecorator<ITunnelService>('tunnelService');\nexport const ISharedTunnelsService = createDecorator<ISharedTunnelsService>('sharedTunnelsService');\n\nexport interface RemoteTunnel {\n\treadonly tunnelRemotePort: number;\n\treadonly tunnelRemoteHost: string;\n\treadonly tunnelLocalPort?: number;\n\treadonly localAddress: string;\n\treadonly privacy: string;\n\treadonly protocol?: string;\n\tdispose(silent?: boolean): Promise<void>;\n}\n\nexport function isRemoteTunnel(something: unknown): something is RemoteTunnel {\n\tconst asTunnel: Partial<RemoteTunnel> = something as Partial<RemoteTunnel>;\n\treturn !!(asTunnel.tunnelRemotePort && asTunnel.tunnelRemoteHost && asTunnel.localAddress && asTunnel.privacy && asTunnel.dispose);\n}\n\nexport interface TunnelOptions {\n\tremoteAddress: { port: number; host: string };\n\tlocalAddressPort?: number;\n\tlabel?: string;\n\tpublic?: boolean;\n\tprivacy?: string;\n\tprotocol?: string;\n}\n\nexport enum TunnelProtocol {\n\tHttp = 'http',\n\tHttps = 'https'\n}\n\nexport enum TunnelPrivacyId {\n\tConstantPrivate = 'constantPrivate', // private, and changing is unsupported\n\tPrivate = 'private',\n\tPublic = 'public'\n}\n\nexport interface TunnelCreationOptions {\n\televationRequired?: boolean;\n}\n\nexport interface TunnelProviderFeatures {\n\televation: boolean;\n\t/**\n\t * @deprecated\n\t */\n\tpublic?: boolean;\n\tprivacyOptions: TunnelPrivacy[];\n\tprotocol: boolean;\n}\n\nexport interface ITunnelProvider {\n\tforwardPort(tunnelOptions: TunnelOptions, tunnelCreationOptions: TunnelCreationOptions): Promise<RemoteTunnel | string | undefined> | undefined;\n}\n\nexport function isTunnelProvider(addressOrTunnelProvider: IAddressProvider | ITunnelProvider): addressOrTunnelProvider is ITunnelProvider {\n\treturn !!(addressOrTunnelProvider as ITunnelProvider).forwardPort;\n}\n\nexport enum ProvidedOnAutoForward {\n\tNotify = 1,\n\tOpenBrowser = 2,\n\tOpenPreview = 3,\n\tSilent = 4,\n\tIgnore = 5,\n\tOpenBrowserOnce = 6\n}\n\nexport interface ProvidedPortAttributes {\n\tport: number;\n\tautoForwardAction: ProvidedOnAutoForward;\n}\n\nexport interface PortAttributesProvider {\n\tprovidePortAttributes(ports: number[], pid: number | undefined, commandLine: string | undefined, token: CancellationToken): Promise<ProvidedPortAttributes[]>;\n}\n\nexport interface ITunnel {\n\tremoteAddress: { port: number; host: string };\n\n\t/**\n\t * The complete local address(ex. localhost:1234)\n\t */\n\tlocalAddress: string;\n\n\t/**\n\t * @deprecated Use privacy instead\n\t */\n\tpublic?: boolean;\n\n\tprivacy?: string;\n\n\tprotocol?: string;\n\n\t/**\n\t * Implementers of Tunnel should fire onDidDispose when dispose is called.\n\t */\n\treadonly onDidDispose: Event<void>;\n\n\tdispose(): Promise<void> | void;\n}\n\nexport interface ISharedTunnelsService {\n\treadonly _serviceBrand: undefined;\n\n\topenTunnel(authority: string, addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n}\n\nexport interface ITunnelService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly tunnels: Promise<readonly RemoteTunnel[]>;\n\treadonly canChangePrivacy: boolean;\n\treadonly privacyOptions: TunnelPrivacy[];\n\treadonly onTunnelOpened: Event<RemoteTunnel>;\n\treadonly onTunnelClosed: Event<{ host: string; port: number }>;\n\treadonly canElevate: boolean;\n\treadonly canChangeProtocol: boolean;\n\treadonly hasTunnelProvider: boolean;\n\treadonly onAddedTunnelProvider: Event<void>;\n\n\tcanTunnel(uri: URI): boolean;\n\topenTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost?: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n\tgetExistingTunnel(remoteHost: string, remotePort: number): Promise<RemoteTunnel | string | undefined>;\n\tsetEnvironmentTunnel(remoteHost: string, remotePort: number, localAddress: string, privacy: string, protocol: string): void;\n\tcloseTunnel(remoteHost: string, remotePort: number): Promise<void>;\n\tsetTunnelProvider(provider: ITunnelProvider | undefined): IDisposable;\n\tsetTunnelFeatures(features: TunnelProviderFeatures): void;\n\tisPortPrivileged(port: number): boolean;\n}\n\nexport function extractLocalHostUriMetaDataForPortMapping(uri: URI): { address: string; port: number } | undefined {\n\tif (uri.scheme !== 'http' && uri.scheme !== 'https') {\n\t\treturn undefined;\n\t}\n\tconst localhostMatch = /^(localhost|127\\.0\\.0\\.1|0\\.0\\.0\\.0):(\\d+)$/.exec(uri.authority);\n\tif (!localhostMatch) {\n\t\treturn undefined;\n\t}\n\treturn {\n\t\taddress: localhostMatch[1],\n\t\tport: +localhostMatch[2],\n\t};\n}\n\nexport function extractQueryLocalHostUriMetaDataForPortMapping(uri: URI): { address: string; port: number } | undefined {\n\tif (uri.scheme !== 'http' && uri.scheme !== 'https' || !uri.query) {\n\t\treturn undefined;\n\t}\n\tconst keyvalues = uri.query.split('&');\n\tfor (const keyvalue of keyvalues) {\n\t\tconst value = keyvalue.split('=')[1];\n\t\tif (/^https?:/.exec(value)) {\n\t\t\tconst result = extractLocalHostUriMetaDataForPortMapping(URI.parse(value));\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\treturn undefined;\n}\n\nexport const LOCALHOST_ADDRESSES = ['localhost', '127.0.0.1', '0:0:0:0:0:0:0:1', '::1'];\nexport function isLocalhost(host: string): boolean {\n\treturn LOCALHOST_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport const ALL_INTERFACES_ADDRESSES = ['0.0.0.0', '0:0:0:0:0:0:0:0', '::'];\nexport function isAllInterfaces(host: string): boolean {\n\treturn ALL_INTERFACES_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport function isPortPrivileged(port: number, host: string, os: OperatingSystem, osRelease: string): boolean {\n\tif (os === OperatingSystem.Windows) {\n\t\treturn false;\n\t}\n\tif (os === OperatingSystem.Macintosh) {\n\t\tif (isAllInterfaces(host)) {\n\t\t\tconst osVersion = (/(\\d+)\\.(\\d+)\\.(\\d+)/g).exec(osRelease);\n\t\t\tif (osVersion?.length === 4) {\n\t\t\t\tconst major = parseInt(osVersion[1]);\n\t\t\t\tif (major >= 18 /* since macOS Mojave, darwin version 18.0.0 */) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn port < 1024;\n}\n\nexport class DisposableTunnel {\n\tprivate _onDispose: Emitter<void> = new Emitter();\n\treadonly onDidDispose: Event<void> = this._onDispose.event;\n\n\tconstructor(\n\t\tpublic readonly remoteAddress: { port: number; host: string },\n\t\tpublic readonly localAddress: { port: number; host: string } | string,\n\t\tprivate readonly _dispose: () => Promise<void>) { }\n\n\tdispose(): Promise<void> {\n\t\tthis._onDispose.fire();\n\t\treturn this._dispose();\n\t}\n}\n\nexport abstract class AbstractTunnelService extends Disposable implements ITunnelService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _onTunnelOpened: Emitter<RemoteTunnel> = new Emitter();\n\tpublic onTunnelOpened: Event<RemoteTunnel> = this._onTunnelOpened.event;\n\tprivate _onTunnelClosed: Emitter<{ host: string; port: number }> = new Emitter();\n\tpublic onTunnelClosed: Event<{ host: string; port: number }> = this._onTunnelClosed.event;\n\tprivate _onAddedTunnelProvider: Emitter<void> = new Emitter();\n\tpublic onAddedTunnelProvider: Event<void> = this._onAddedTunnelProvider.event;\n\tprotected readonly _tunnels = new Map</*host*/ string, Map</* port */ number, { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> }>>();\n\tprotected _tunnelProvider: ITunnelProvider | undefined;\n\tprotected _canElevate: boolean = false;\n\tprivate _canChangeProtocol: boolean = true;\n\tprivate _privacyOptions: TunnelPrivacy[] = [];\n\tprivate _factoryInProgress: Set<number/*port*/> = new Set();\n\n\tpublic constructor(\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IConfigurationService protected readonly configurationService: IConfigurationService\n\t) { super(); }\n\n\tget hasTunnelProvider(): boolean {\n\t\treturn !!this._tunnelProvider;\n\t}\n\n\tprotected get defaultTunnelHost(): string {\n\t\tconst settingValue = this.configurationService.getValue('remote.localPortHost');\n\t\treturn (!settingValue || settingValue === 'localhost') ? '127.0.0.1' : '0.0.0.0';\n\t}\n\n\tsetTunnelProvider(provider: ITunnelProvider | undefined): IDisposable {\n\t\tthis._tunnelProvider = provider;\n\t\tif (!provider) {\n\t\t\t// clear features\n\t\t\tthis._canElevate = false;\n\t\t\tthis._privacyOptions = [];\n\t\t\tthis._onAddedTunnelProvider.fire();\n\t\t\treturn {\n\t\t\t\tdispose: () => { }\n\t\t\t};\n\t\t}\n\n\t\tthis._onAddedTunnelProvider.fire();\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tthis._tunnelProvider = undefined;\n\t\t\t\tthis._canElevate = false;\n\t\t\t\tthis._privacyOptions = [];\n\t\t\t}\n\t\t};\n\t}\n\n\tsetTunnelFeatures(features: TunnelProviderFeatures): void {\n\t\tthis._canElevate = features.elevation;\n\t\tthis._privacyOptions = features.privacyOptions;\n\t\tthis._canChangeProtocol = features.protocol;\n\t}\n\n\tpublic get canChangeProtocol(): boolean {\n\t\treturn this._canChangeProtocol;\n\t}\n\n\tpublic get canElevate(): boolean {\n\t\treturn this._canElevate;\n\t}\n\n\tpublic get canChangePrivacy() {\n\t\treturn this._privacyOptions.length > 0;\n\t}\n\n\tpublic get privacyOptions() {\n\t\treturn this._privacyOptions;\n\t}\n\n\tpublic get tunnels(): Promise<readonly RemoteTunnel[]> {\n\t\treturn this.getTunnels();\n\t}\n\n\tprivate async getTunnels(): Promise<readonly RemoteTunnel[]> {\n\t\tconst tunnels: RemoteTunnel[] = [];\n\t\tconst tunnelArray = Array.from(this._tunnels.values());\n\t\tfor (const portMap of tunnelArray) {\n\t\t\tconst portArray = Array.from(portMap.values());\n\t\t\tfor (const x of portArray) {\n\t\t\t\tconst tunnelValue = await x.value;\n\t\t\t\tif (tunnelValue && (typeof tunnelValue !== 'string')) {\n\t\t\t\t\ttunnels.push(tunnelValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tunnels;\n\t}\n\n\toverride async dispose(): Promise<void> {\n\t\tsuper.dispose();\n\t\tfor (const portMap of this._tunnels.values()) {\n\t\t\tfor (const { value } of portMap.values()) {\n\t\t\t\tawait value.then(tunnel => typeof tunnel !== 'string' ? tunnel?.dispose() : undefined);\n\t\t\t}\n\t\t\tportMap.clear();\n\t\t}\n\t\tthis._tunnels.clear();\n\t}\n\n\tsetEnvironmentTunnel(remoteHost: string, remotePort: number, localAddress: string, privacy: string, protocol: string): void {\n\t\tthis.addTunnelToMap(remoteHost, remotePort, Promise.resolve({\n\t\t\ttunnelRemoteHost: remoteHost,\n\t\t\ttunnelRemotePort: remotePort,\n\t\t\tlocalAddress,\n\t\t\tprivacy,\n\t\t\tprotocol,\n\t\t\tdispose: () => Promise.resolve()\n\t\t}));\n\t}\n\n\tasync getExistingTunnel(remoteHost: string, remotePort: number): Promise<RemoteTunnel | string | undefined> {\n\t\tif (isAllInterfaces(remoteHost) || isLocalhost(remoteHost)) {\n\t\t\tremoteHost = LOCALHOST_ADDRESSES[0];\n\t\t}\n\n\t\tconst existing = this.getTunnelFromMap(remoteHost, remotePort);\n\t\tif (existing) {\n\t\t\t++existing.refcount;\n\t\t\treturn existing.value;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\topenTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost?: string, localPort?: number, elevateIfNeeded: boolean = false, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tconst addressOrTunnelProvider = this._tunnelProvider ?? addressProvider;\n\t\tif (!addressOrTunnelProvider) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!remoteHost) {\n\t\t\tremoteHost = 'localhost';\n\t\t}\n\t\tif (!localHost) {\n\t\t\tlocalHost = this.defaultTunnelHost;\n\t\t}\n\n\t\t// Prevent tunnel factories from calling openTunnel from within the factory\n\t\tif (this._tunnelProvider && this._factoryInProgress.has(remotePort)) {\n\t\t\tthis.logService.debug(`ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst resolvedTunnel = this.retainOrCreateTunnel(addressOrTunnelProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded, privacy, protocol);\n\t\tif (!resolvedTunnel) {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Tunnel was not created.`);\n\t\t\treturn resolvedTunnel;\n\t\t}\n\n\t\treturn resolvedTunnel.then(tunnel => {\n\t\t\tif (!tunnel) {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) New tunnel is undefined.');\n\t\t\t\tthis.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);\n\t\t\t\treturn undefined;\n\t\t\t} else if (typeof tunnel === 'string') {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.');\n\t\t\t\tthis.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);\n\t\t\t\treturn tunnel;\n\t\t\t}\n\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) New tunnel established.');\n\t\t\tconst newTunnel = this.makeTunnel(tunnel);\n\t\t\tif (tunnel.tunnelRemoteHost !== remoteHost || tunnel.tunnelRemotePort !== remotePort) {\n\t\t\t\tthis.logService.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.');\n\t\t\t}\n\t\t\tif (privacy && tunnel.privacy !== privacy) {\n\t\t\t\tthis.logService.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.');\n\t\t\t}\n\t\t\tthis._onTunnelOpened.fire(newTunnel);\n\t\t\treturn newTunnel;\n\t\t});\n\t}\n\n\tprivate makeTunnel(tunnel: RemoteTunnel): RemoteTunnel {\n\t\treturn {\n\t\t\ttunnelRemotePort: tunnel.tunnelRemotePort,\n\t\t\ttunnelRemoteHost: tunnel.tunnelRemoteHost,\n\t\t\ttunnelLocalPort: tunnel.tunnelLocalPort,\n\t\t\tlocalAddress: tunnel.localAddress,\n\t\t\tprivacy: tunnel.privacy,\n\t\t\tprotocol: tunnel.protocol,\n\t\t\tdispose: async () => {\n\t\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) dispose request for ${tunnel.tunnelRemoteHost}:${tunnel.tunnelRemotePort} `);\n\t\t\t\tconst existingHost = this._tunnels.get(tunnel.tunnelRemoteHost);\n\t\t\t\tif (existingHost) {\n\t\t\t\t\tconst existing = existingHost.get(tunnel.tunnelRemotePort);\n\t\t\t\t\tif (existing) {\n\t\t\t\t\t\texisting.refcount--;\n\t\t\t\t\t\tawait this.tryDisposeTunnel(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort, existing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate async tryDisposeTunnel(remoteHost: string, remotePort: number, tunnel: { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> }): Promise<void> {\n\t\tif (tunnel.refcount <= 0) {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${remoteHost}:${remotePort}.`);\n\t\t\tconst disposePromise: Promise<void> = tunnel.value.then(async (tunnel) => {\n\t\t\t\tif (tunnel && (typeof tunnel !== 'string')) {\n\t\t\t\t\tawait tunnel.dispose(true);\n\t\t\t\t\tthis._onTunnelClosed.fire({ host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort });\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (this._tunnels.has(remoteHost)) {\n\t\t\t\tthis._tunnels.get(remoteHost)!.delete(remotePort);\n\t\t\t}\n\t\t\treturn disposePromise;\n\t\t}\n\t}\n\n\tasync closeTunnel(remoteHost: string, remotePort: number): Promise<void> {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) close request for ${remoteHost}:${remotePort} `);\n\t\tconst portMap = this._tunnels.get(remoteHost);\n\t\tif (portMap && portMap.has(remotePort)) {\n\t\t\tconst value = portMap.get(remotePort)!;\n\t\t\tvalue.refcount = 0;\n\t\t\tawait this.tryDisposeTunnel(remoteHost, remotePort, value);\n\t\t}\n\t}\n\n\tprotected addTunnelToMap(remoteHost: string, remotePort: number, tunnel: Promise<RemoteTunnel | string | undefined>) {\n\t\tif (!this._tunnels.has(remoteHost)) {\n\t\t\tthis._tunnels.set(remoteHost, new Map());\n\t\t}\n\t\tthis._tunnels.get(remoteHost)!.set(remotePort, { refcount: 1, value: tunnel });\n\t}\n\n\tprivate async removeEmptyOrErrorTunnelFromMap(remoteHost: string, remotePort: number) {\n\t\tconst hostMap = this._tunnels.get(remoteHost);\n\t\tif (hostMap) {\n\t\t\tconst tunnel = hostMap.get(remotePort);\n\t\t\tconst tunnelResult = tunnel ? await tunnel.value : undefined;\n\t\t\tif (!tunnelResult || (typeof tunnelResult === 'string')) {\n\t\t\t\thostMap.delete(remotePort);\n\t\t\t}\n\t\t\tif (hostMap.size === 0) {\n\t\t\t\tthis._tunnels.delete(remoteHost);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected getTunnelFromMap(remoteHost: string, remotePort: number): { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> } | undefined {\n\t\tconst hosts = [remoteHost];\n\t\t// Order matters. We want the original host to be first.\n\t\tif (isLocalhost(remoteHost)) {\n\t\t\thosts.push(...LOCALHOST_ADDRESSES);\n\t\t\t// For localhost, we add the all interfaces hosts because if the tunnel is already available at all interfaces,\n\t\t\t// then of course it is available at localhost.\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t} else if (isAllInterfaces(remoteHost)) {\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t}\n\n\t\tconst existingPortMaps = hosts.map(host => this._tunnels.get(host));\n\t\tfor (const map of existingPortMaps) {\n\t\t\tconst existingTunnel = map?.get(remotePort);\n\t\t\tif (existingTunnel) {\n\t\t\t\treturn existingTunnel;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tcanTunnel(uri: URI): boolean {\n\t\treturn !!extractLocalHostUriMetaDataForPortMapping(uri);\n\t}\n\n\tpublic abstract isPortPrivileged(port: number): boolean;\n\n\tprotected abstract retainOrCreateTunnel(addressProvider: IAddressProvider | ITunnelProvider, remoteHost: string, remotePort: number, localHost: string, localPort: number | undefined, elevateIfNeeded: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n\n\tprotected createWithProvider(tunnelProvider: ITunnelProvider, remoteHost: string, remotePort: number, localPort: number | undefined, elevateIfNeeded: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tconst key = remotePort;\n\t\tthis._factoryInProgress.add(key);\n\t\tconst preferredLocalPort = localPort === undefined ? remotePort : localPort;\n\t\tconst creationInfo = { elevationRequired: elevateIfNeeded ? this.isPortPrivileged(preferredLocalPort) : false };\n\t\tconst tunnelOptions: TunnelOptions = { remoteAddress: { host: remoteHost, port: remotePort }, localAddressPort: localPort, privacy, public: privacy ? (privacy !== TunnelPrivacyId.Private) : undefined, protocol };\n\t\tconst tunnel = tunnelProvider.forwardPort(tunnelOptions, creationInfo);\n\t\tif (tunnel) {\n\t\t\tthis.addTunnelToMap(remoteHost, remotePort, tunnel);\n\t\t\ttunnel.finally(() => {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) Tunnel created by provider.');\n\t\t\t\tthis._factoryInProgress.delete(key);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._factoryInProgress.delete(key);\n\t\t}\n\t\treturn tunnel;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IDisposable, Disposable } from '../../../base/common/lifecycle.js';\nimport { OperatingSystem } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IAddressProvider } from '../../remote/common/remoteAgentConnection.js';\nimport { TunnelPrivacy } from '../../remote/common/remoteAuthorityResolver.js';\n\nexport const ITunnelService = createDecorator<ITunnelService>('tunnelService');\nexport const ISharedTunnelsService = createDecorator<ISharedTunnelsService>('sharedTunnelsService');\n\nexport interface RemoteTunnel {\n\treadonly tunnelRemotePort: number;\n\treadonly tunnelRemoteHost: string;\n\treadonly tunnelLocalPort?: number;\n\treadonly localAddress: string;\n\treadonly privacy: string;\n\treadonly protocol?: string;\n\tdispose(silent?: boolean): Promise<void>;\n}\n\nexport function isRemoteTunnel(something: unknown): something is RemoteTunnel {\n\tconst asTunnel: Partial<RemoteTunnel> = something as Partial<RemoteTunnel>;\n\treturn !!(asTunnel.tunnelRemotePort && asTunnel.tunnelRemoteHost && asTunnel.localAddress && asTunnel.privacy && asTunnel.dispose);\n}\n\nexport interface TunnelOptions {\n\tremoteAddress: { port: number; host: string };\n\tlocalAddressPort?: number;\n\tlabel?: string;\n\tpublic?: boolean;\n\tprivacy?: string;\n\tprotocol?: string;\n}\n\nexport enum TunnelProtocol {\n\tHttp = 'http',\n\tHttps = 'https'\n}\n\nexport enum TunnelPrivacyId {\n\tConstantPrivate = 'constantPrivate', // private, and changing is unsupported\n\tPrivate = 'private',\n\tPublic = 'public'\n}\n\nexport interface TunnelCreationOptions {\n\televationRequired?: boolean;\n}\n\nexport interface TunnelProviderFeatures {\n\televation: boolean;\n\t/**\n\t * @deprecated\n\t */\n\tpublic?: boolean;\n\tprivacyOptions: TunnelPrivacy[];\n\tprotocol: boolean;\n}\n\nexport interface ITunnelProvider {\n\tforwardPort(tunnelOptions: TunnelOptions, tunnelCreationOptions: TunnelCreationOptions): Promise<RemoteTunnel | string | undefined> | undefined;\n}\n\nexport function isTunnelProvider(addressOrTunnelProvider: IAddressProvider | ITunnelProvider): addressOrTunnelProvider is ITunnelProvider {\n\treturn !!(addressOrTunnelProvider as ITunnelProvider).forwardPort;\n}\n\nexport enum ProvidedOnAutoForward {\n\tNotify = 1,\n\tOpenBrowser = 2,\n\tOpenPreview = 3,\n\tSilent = 4,\n\tIgnore = 5,\n\tOpenBrowserOnce = 6\n}\n\nexport interface ProvidedPortAttributes {\n\tport: number;\n\tautoForwardAction: ProvidedOnAutoForward;\n}\n\nexport interface PortAttributesProvider {\n\tprovidePortAttributes(ports: number[], pid: number | undefined, commandLine: string | undefined, token: CancellationToken): Promise<ProvidedPortAttributes[]>;\n}\n\nexport interface ITunnel {\n\tremoteAddress: { port: number; host: string };\n\n\t/**\n\t * The complete local address(ex. localhost:1234)\n\t */\n\tlocalAddress: string;\n\n\t/**\n\t * @deprecated Use privacy instead\n\t */\n\tpublic?: boolean;\n\n\tprivacy?: string;\n\n\tprotocol?: string;\n\n\t/**\n\t * Implementers of Tunnel should fire onDidDispose when dispose is called.\n\t */\n\treadonly onDidDispose: Event<void>;\n\n\tdispose(): Promise<void> | void;\n}\n\nexport interface ISharedTunnelsService {\n\treadonly _serviceBrand: undefined;\n\n\topenTunnel(authority: string, addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n}\n\nexport interface ITunnelService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly tunnels: Promise<readonly RemoteTunnel[]>;\n\treadonly canChangePrivacy: boolean;\n\treadonly privacyOptions: TunnelPrivacy[];\n\treadonly onTunnelOpened: Event<RemoteTunnel>;\n\treadonly onTunnelClosed: Event<{ host: string; port: number }>;\n\treadonly canElevate: boolean;\n\treadonly canChangeProtocol: boolean;\n\treadonly hasTunnelProvider: boolean;\n\treadonly onAddedTunnelProvider: Event<void>;\n\n\tcanTunnel(uri: URI): boolean;\n\topenTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost?: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n\tgetExistingTunnel(remoteHost: string, remotePort: number): Promise<RemoteTunnel | string | undefined>;\n\tsetEnvironmentTunnel(remoteHost: string, remotePort: number, localAddress: string, privacy: string, protocol: string): void;\n\tcloseTunnel(remoteHost: string, remotePort: number): Promise<void>;\n\tsetTunnelProvider(provider: ITunnelProvider | undefined): IDisposable;\n\tsetTunnelFeatures(features: TunnelProviderFeatures): void;\n\tisPortPrivileged(port: number): boolean;\n}\n\nexport function extractLocalHostUriMetaDataForPortMapping(uri: URI): { address: string; port: number } | undefined {\n\tif (uri.scheme !== 'http' && uri.scheme !== 'https') {\n\t\treturn undefined;\n\t}\n\tconst localhostMatch = /^(localhost|127\\.0\\.0\\.1|0\\.0\\.0\\.0):(\\d+)$/.exec(uri.authority);\n\tif (!localhostMatch) {\n\t\treturn undefined;\n\t}\n\treturn {\n\t\taddress: localhostMatch[1],\n\t\tport: +localhostMatch[2],\n\t};\n}\n\nexport function extractQueryLocalHostUriMetaDataForPortMapping(uri: URI): { address: string; port: number } | undefined {\n\tif (uri.scheme !== 'http' && uri.scheme !== 'https' || !uri.query) {\n\t\treturn undefined;\n\t}\n\tconst keyvalues = uri.query.split('&');\n\tfor (const keyvalue of keyvalues) {\n\t\tconst value = keyvalue.split('=')[1];\n\t\tif (/^https?:/.exec(value)) {\n\t\t\tconst result = extractLocalHostUriMetaDataForPortMapping(URI.parse(value));\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\treturn undefined;\n}\n\nexport const LOCALHOST_ADDRESSES = ['localhost', '127.0.0.1', '0:0:0:0:0:0:0:1', '::1'];\nexport function isLocalhost(host: string): boolean {\n\treturn LOCALHOST_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport const ALL_INTERFACES_ADDRESSES = ['0.0.0.0', '0:0:0:0:0:0:0:0', '::'];\nexport function isAllInterfaces(host: string): boolean {\n\treturn ALL_INTERFACES_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport function isPortPrivileged(port: number, host: string, os: OperatingSystem, osRelease: string): boolean {\n\tif (os === OperatingSystem.Windows) {\n\t\treturn false;\n\t}\n\tif (os === OperatingSystem.Macintosh) {\n\t\tif (isAllInterfaces(host)) {\n\t\t\tconst osVersion = (/(\\d+)\\.(\\d+)\\.(\\d+)/g).exec(osRelease);\n\t\t\tif (osVersion?.length === 4) {\n\t\t\t\tconst major = parseInt(osVersion[1]);\n\t\t\t\tif (major >= 18 /* since macOS Mojave, darwin version 18.0.0 */) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn port < 1024;\n}\n\nexport class DisposableTunnel {\n\tprivate _onDispose: Emitter<void> = new Emitter();\n\treadonly onDidDispose: Event<void> = this._onDispose.event;\n\n\tconstructor(\n\t\tpublic readonly remoteAddress: { port: number; host: string },\n\t\tpublic readonly localAddress: { port: number; host: string } | string,\n\t\tprivate readonly _dispose: () => Promise<void>) { }\n\n\tdispose(): Promise<void> {\n\t\tthis._onDispose.fire();\n\t\treturn this._dispose();\n\t}\n}\n\nexport abstract class AbstractTunnelService extends Disposable implements ITunnelService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _onTunnelOpened: Emitter<RemoteTunnel> = new Emitter();\n\tpublic onTunnelOpened: Event<RemoteTunnel> = this._onTunnelOpened.event;\n\tprivate _onTunnelClosed: Emitter<{ host: string; port: number }> = new Emitter();\n\tpublic onTunnelClosed: Event<{ host: string; port: number }> = this._onTunnelClosed.event;\n\tprivate _onAddedTunnelProvider: Emitter<void> = new Emitter();\n\tpublic onAddedTunnelProvider: Event<void> = this._onAddedTunnelProvider.event;\n\tprotected readonly _tunnels = new Map</*host*/ string, Map</* port */ number, { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> }>>();\n\tprotected _tunnelProvider: ITunnelProvider | undefined;\n\tprotected _canElevate: boolean = false;\n\tprivate _canChangeProtocol: boolean = true;\n\tprivate _privacyOptions: TunnelPrivacy[] = [];\n\tprivate _factoryInProgress: Set<number/*port*/> = new Set();\n\n\tpublic constructor(\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IConfigurationService protected readonly configurationService: IConfigurationService\n\t) { super(); }\n\n\tget hasTunnelProvider(): boolean {\n\t\treturn !!this._tunnelProvider;\n\t}\n\n\tprotected get defaultTunnelHost(): string {\n\t\tconst settingValue = this.configurationService.getValue('remote.localPortHost');\n\t\treturn (!settingValue || settingValue === 'localhost') ? '127.0.0.1' : '0.0.0.0';\n\t}\n\n\tsetTunnelProvider(provider: ITunnelProvider | undefined): IDisposable {\n\t\tthis._tunnelProvider = provider;\n\t\tif (!provider) {\n\t\t\t// clear features\n\t\t\tthis._canElevate = false;\n\t\t\tthis._privacyOptions = [];\n\t\t\tthis._onAddedTunnelProvider.fire();\n\t\t\treturn {\n\t\t\t\tdispose: () => { }\n\t\t\t};\n\t\t}\n\n\t\tthis._onAddedTunnelProvider.fire();\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tthis._tunnelProvider = undefined;\n\t\t\t\tthis._canElevate = false;\n\t\t\t\tthis._privacyOptions = [];\n\t\t\t}\n\t\t};\n\t}\n\n\tsetTunnelFeatures(features: TunnelProviderFeatures): void {\n\t\tthis._canElevate = features.elevation;\n\t\tthis._privacyOptions = features.privacyOptions;\n\t\tthis._canChangeProtocol = features.protocol;\n\t}\n\n\tpublic get canChangeProtocol(): boolean {\n\t\treturn this._canChangeProtocol;\n\t}\n\n\tpublic get canElevate(): boolean {\n\t\treturn this._canElevate;\n\t}\n\n\tpublic get canChangePrivacy() {\n\t\treturn this._privacyOptions.length > 0;\n\t}\n\n\tpublic get privacyOptions() {\n\t\treturn this._privacyOptions;\n\t}\n\n\tpublic get tunnels(): Promise<readonly RemoteTunnel[]> {\n\t\treturn this.getTunnels();\n\t}\n\n\tprivate async getTunnels(): Promise<readonly RemoteTunnel[]> {\n\t\tconst tunnels: RemoteTunnel[] = [];\n\t\tconst tunnelArray = Array.from(this._tunnels.values());\n\t\tfor (const portMap of tunnelArray) {\n\t\t\tconst portArray = Array.from(portMap.values());\n\t\t\tfor (const x of portArray) {\n\t\t\t\tconst tunnelValue = await x.value;\n\t\t\t\tif (tunnelValue && (typeof tunnelValue !== 'string')) {\n\t\t\t\t\ttunnels.push(tunnelValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tunnels;\n\t}\n\n\toverride async dispose(): Promise<void> {\n\t\tsuper.dispose();\n\t\tfor (const portMap of this._tunnels.values()) {\n\t\t\tfor (const { value } of portMap.values()) {\n\t\t\t\tawait value.then(tunnel => typeof tunnel !== 'string' ? tunnel?.dispose() : undefined);\n\t\t\t}\n\t\t\tportMap.clear();\n\t\t}\n\t\tthis._tunnels.clear();\n\t}\n\n\tsetEnvironmentTunnel(remoteHost: string, remotePort: number, localAddress: string, privacy: string, protocol: string): void {\n\t\tthis.addTunnelToMap(remoteHost, remotePort, Promise.resolve({\n\t\t\ttunnelRemoteHost: remoteHost,\n\t\t\ttunnelRemotePort: remotePort,\n\t\t\tlocalAddress,\n\t\t\tprivacy,\n\t\t\tprotocol,\n\t\t\tdispose: () => Promise.resolve()\n\t\t}));\n\t}\n\n\tasync getExistingTunnel(remoteHost: string, remotePort: number): Promise<RemoteTunnel | string | undefined> {\n\t\tif (isAllInterfaces(remoteHost) || isLocalhost(remoteHost)) {\n\t\t\tremoteHost = LOCALHOST_ADDRESSES[0];\n\t\t}\n\n\t\tconst existing = this.getTunnelFromMap(remoteHost, remotePort);\n\t\tif (existing) {\n\t\t\t++existing.refcount;\n\t\t\treturn existing.value;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\topenTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost?: string, localPort?: number, elevateIfNeeded: boolean = false, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tconst addressOrTunnelProvider = this._tunnelProvider ?? addressProvider;\n\t\tif (!addressOrTunnelProvider) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!remoteHost) {\n\t\t\tremoteHost = 'localhost';\n\t\t}\n\t\tif (!localHost) {\n\t\t\tlocalHost = this.defaultTunnelHost;\n\t\t}\n\n\t\t// Prevent tunnel factories from calling openTunnel from within the factory\n\t\tif (this._tunnelProvider && this._factoryInProgress.has(remotePort)) {\n\t\t\tthis.logService.debug(`ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst resolvedTunnel = this.retainOrCreateTunnel(addressOrTunnelProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded, privacy, protocol);\n\t\tif (!resolvedTunnel) {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Tunnel was not created.`);\n\t\t\treturn resolvedTunnel;\n\t\t}\n\n\t\treturn resolvedTunnel.then(tunnel => {\n\t\t\tif (!tunnel) {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) New tunnel is undefined.');\n\t\t\t\tthis.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);\n\t\t\t\treturn undefined;\n\t\t\t} else if (typeof tunnel === 'string') {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.');\n\t\t\t\tthis.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);\n\t\t\t\treturn tunnel;\n\t\t\t}\n\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) New tunnel established.');\n\t\t\tconst newTunnel = this.makeTunnel(tunnel);\n\t\t\tif (tunnel.tunnelRemoteHost !== remoteHost || tunnel.tunnelRemotePort !== remotePort) {\n\t\t\t\tthis.logService.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.');\n\t\t\t}\n\t\t\tif (privacy && tunnel.privacy !== privacy) {\n\t\t\t\tthis.logService.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.');\n\t\t\t}\n\t\t\tthis._onTunnelOpened.fire(newTunnel);\n\t\t\treturn newTunnel;\n\t\t});\n\t}\n\n\tprivate makeTunnel(tunnel: RemoteTunnel): RemoteTunnel {\n\t\treturn {\n\t\t\ttunnelRemotePort: tunnel.tunnelRemotePort,\n\t\t\ttunnelRemoteHost: tunnel.tunnelRemoteHost,\n\t\t\ttunnelLocalPort: tunnel.tunnelLocalPort,\n\t\t\tlocalAddress: tunnel.localAddress,\n\t\t\tprivacy: tunnel.privacy,\n\t\t\tprotocol: tunnel.protocol,\n\t\t\tdispose: async () => {\n\t\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) dispose request for ${tunnel.tunnelRemoteHost}:${tunnel.tunnelRemotePort} `);\n\t\t\t\tconst existingHost = this._tunnels.get(tunnel.tunnelRemoteHost);\n\t\t\t\tif (existingHost) {\n\t\t\t\t\tconst existing = existingHost.get(tunnel.tunnelRemotePort);\n\t\t\t\t\tif (existing) {\n\t\t\t\t\t\texisting.refcount--;\n\t\t\t\t\t\tawait this.tryDisposeTunnel(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort, existing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate async tryDisposeTunnel(remoteHost: string, remotePort: number, tunnel: { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> }): Promise<void> {\n\t\tif (tunnel.refcount <= 0) {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${remoteHost}:${remotePort}.`);\n\t\t\tconst disposePromise: Promise<void> = tunnel.value.then(async (tunnel) => {\n\t\t\t\tif (tunnel && (typeof tunnel !== 'string')) {\n\t\t\t\t\tawait tunnel.dispose(true);\n\t\t\t\t\tthis._onTunnelClosed.fire({ host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort });\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (this._tunnels.has(remoteHost)) {\n\t\t\t\tthis._tunnels.get(remoteHost)!.delete(remotePort);\n\t\t\t}\n\t\t\treturn disposePromise;\n\t\t}\n\t}\n\n\tasync closeTunnel(remoteHost: string, remotePort: number): Promise<void> {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) close request for ${remoteHost}:${remotePort} `);\n\t\tconst portMap = this._tunnels.get(remoteHost);\n\t\tif (portMap && portMap.has(remotePort)) {\n\t\t\tconst value = portMap.get(remotePort)!;\n\t\t\tvalue.refcount = 0;\n\t\t\tawait this.tryDisposeTunnel(remoteHost, remotePort, value);\n\t\t}\n\t}\n\n\tprotected addTunnelToMap(remoteHost: string, remotePort: number, tunnel: Promise<RemoteTunnel | string | undefined>) {\n\t\tif (!this._tunnels.has(remoteHost)) {\n\t\t\tthis._tunnels.set(remoteHost, new Map());\n\t\t}\n\t\tthis._tunnels.get(remoteHost)!.set(remotePort, { refcount: 1, value: tunnel });\n\t}\n\n\tprivate async removeEmptyOrErrorTunnelFromMap(remoteHost: string, remotePort: number) {\n\t\tconst hostMap = this._tunnels.get(remoteHost);\n\t\tif (hostMap) {\n\t\t\tconst tunnel = hostMap.get(remotePort);\n\t\t\tconst tunnelResult = tunnel ? await tunnel.value : undefined;\n\t\t\tif (!tunnelResult || (typeof tunnelResult === 'string')) {\n\t\t\t\thostMap.delete(remotePort);\n\t\t\t}\n\t\t\tif (hostMap.size === 0) {\n\t\t\t\tthis._tunnels.delete(remoteHost);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected getTunnelFromMap(remoteHost: string, remotePort: number): { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> } | undefined {\n\t\tconst hosts = [remoteHost];\n\t\t// Order matters. We want the original host to be first.\n\t\tif (isLocalhost(remoteHost)) {\n\t\t\thosts.push(...LOCALHOST_ADDRESSES);\n\t\t\t// For localhost, we add the all interfaces hosts because if the tunnel is already available at all interfaces,\n\t\t\t// then of course it is available at localhost.\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t} else if (isAllInterfaces(remoteHost)) {\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t}\n\n\t\tconst existingPortMaps = hosts.map(host => this._tunnels.get(host));\n\t\tfor (const map of existingPortMaps) {\n\t\t\tconst existingTunnel = map?.get(remotePort);\n\t\t\tif (existingTunnel) {\n\t\t\t\treturn existingTunnel;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tcanTunnel(uri: URI): boolean {\n\t\treturn !!extractLocalHostUriMetaDataForPortMapping(uri);\n\t}\n\n\tpublic abstract isPortPrivileged(port: number): boolean;\n\n\tprotected abstract retainOrCreateTunnel(addressProvider: IAddressProvider | ITunnelProvider, remoteHost: string, remotePort: number, localHost: string, localPort: number | undefined, elevateIfNeeded: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n\n\tprotected createWithProvider(tunnelProvider: ITunnelProvider, remoteHost: string, remotePort: number, localPort: number | undefined, elevateIfNeeded: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tconst key = remotePort;\n\t\tthis._factoryInProgress.add(key);\n\t\tconst preferredLocalPort = localPort === undefined ? remotePort : localPort;\n\t\tconst creationInfo = { elevationRequired: elevateIfNeeded ? this.isPortPrivileged(preferredLocalPort) : false };\n\t\tconst tunnelOptions: TunnelOptions = { remoteAddress: { host: remoteHost, port: remotePort }, localAddressPort: localPort, privacy, public: privacy ? (privacy !== TunnelPrivacyId.Private) : undefined, protocol };\n\t\tconst tunnel = tunnelProvider.forwardPort(tunnelOptions, creationInfo);\n\t\tif (tunnel) {\n\t\t\tthis.addTunnelToMap(remoteHost, remotePort, tunnel);\n\t\t\ttunnel.finally(() => {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) Tunnel created by provider.');\n\t\t\t\tthis._factoryInProgress.delete(key);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._factoryInProgress.delete(key);\n\t\t}\n\t\treturn tunnel;\n\t}\n}\n"]}