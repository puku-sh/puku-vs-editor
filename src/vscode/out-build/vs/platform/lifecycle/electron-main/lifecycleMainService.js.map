{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/lifecycle/electron-main/lifecycleMainService.ts","vs/platform/lifecycle/electron-main/lifecycleMainService.ts"],"names":[],"mappings":"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","file":"lifecycleMainService.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport electron from 'electron';\nimport { validatedIpcMain } from '../../../base/parts/ipc/electron-main/ipcMain.js';\nimport { Barrier, Promises, timeout } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { isMacintosh, isWindows } from '../../../base/common/platform.js';\nimport { cwd } from '../../../base/common/process.js';\nimport { assertReturnsDefined } from '../../../base/common/types.js';\nimport { NativeParsedArgs } from '../../environment/common/argv.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IStateService } from '../../state/node/state.js';\nimport { ICodeWindow, LoadReason, UnloadReason } from '../../window/electron-main/window.js';\nimport { ISingleFolderWorkspaceIdentifier, IWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { IAuxiliaryWindow } from '../../auxiliaryWindow/electron-main/auxiliaryWindow.js';\nimport { getAllWindowsExcludingOffscreen } from '../../windows/electron-main/windows.js';\n\nexport const ILifecycleMainService = createDecorator<ILifecycleMainService>('lifecycleMainService');\n\ninterface WindowLoadEvent {\n\n\t/**\n\t * The window that is loaded to a new workspace.\n\t */\n\treadonly window: ICodeWindow;\n\n\t/**\n\t * The workspace the window is loaded into.\n\t */\n\treadonly workspace: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | undefined;\n\n\t/**\n\t * More details why the window loads to a new workspace.\n\t */\n\treadonly reason: LoadReason;\n}\n\nexport const enum ShutdownReason {\n\n\t/**\n\t * The application exits normally.\n\t */\n\tQUIT = 1,\n\n\t/**\n\t * The application exits abnormally and is being\n\t * killed with an exit code (e.g. from integration\n\t * test run)\n\t */\n\tKILL\n}\n\nexport interface ShutdownEvent {\n\n\t/**\n\t * More details why the application is shutting down.\n\t */\n\treason: ShutdownReason;\n\n\t/**\n\t * Allows to join the shutdown. The promise can be a long running operation but it\n\t * will block the application from closing.\n\t */\n\tjoin(id: string, promise: Promise<void>): void;\n}\n\nexport interface IRelaunchHandler {\n\n\t/**\n\t * Allows a handler to deal with relaunching the application. The return\n\t * value indicates if the relaunch is handled or not.\n\t */\n\thandleRelaunch(options?: IRelaunchOptions): boolean;\n}\n\nexport interface IRelaunchOptions {\n\treadonly addArgs?: string[];\n\treadonly removeArgs?: string[];\n}\n\nexport interface ILifecycleMainService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Will be true if the program was restarted (e.g. due to explicit request or update).\n\t */\n\treadonly wasRestarted: boolean;\n\n\t/**\n\t * Will be true if the program was requested to quit.\n\t */\n\treadonly quitRequested: boolean;\n\n\t/**\n\t * A flag indicating in what phase of the lifecycle we currently are.\n\t */\n\tphase: LifecycleMainPhase;\n\n\t/**\n\t * An event that fires when the application is about to shutdown before any window is closed.\n\t * The shutdown can still be prevented by any window that vetos this event.\n\t */\n\treadonly onBeforeShutdown: Event<void>;\n\n\t/**\n\t * An event that fires after the onBeforeShutdown event has been fired and after no window has\n\t * vetoed the shutdown sequence. At this point listeners are ensured that the application will\n\t * quit without veto.\n\t */\n\treadonly onWillShutdown: Event<ShutdownEvent>;\n\n\t/**\n\t * An event that fires when a window is loading. This can either be a window opening for the\n\t * first time or a window reloading or changing to another URL.\n\t */\n\treadonly onWillLoadWindow: Event<WindowLoadEvent>;\n\n\t/**\n\t * An event that fires before a window closes. This event is fired after any veto has been dealt\n\t * with so that listeners know for sure that the window will close without veto.\n\t */\n\treadonly onBeforeCloseWindow: Event<ICodeWindow>;\n\n\t/**\n\t * Make a `ICodeWindow` known to the lifecycle main service.\n\t */\n\tregisterWindow(window: ICodeWindow): void;\n\n\t/**\n\t * Make a `IAuxiliaryWindow` known to the lifecycle main service.\n\t */\n\tregisterAuxWindow(auxWindow: IAuxiliaryWindow): void;\n\n\t/**\n\t * Reload a window. All lifecycle event handlers are triggered.\n\t */\n\treload(window: ICodeWindow, cli?: NativeParsedArgs): Promise<void>;\n\n\t/**\n\t * Unload a window for the provided reason. All lifecycle event handlers are triggered.\n\t */\n\tunload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */>;\n\n\t/**\n\t * Restart the application with optional arguments (CLI). All lifecycle event handlers are triggered.\n\t */\n\trelaunch(options?: IRelaunchOptions): Promise<void>;\n\n\t/**\n\t * Sets a custom handler for relaunching the application.\n\t */\n\tsetRelaunchHandler(handler: IRelaunchHandler): void;\n\n\t/**\n\t * Shutdown the application normally. All lifecycle event handlers are triggered.\n\t */\n\tquit(willRestart?: boolean): Promise<boolean /* veto */>;\n\n\t/**\n\t * Forcefully shutdown the application and optionally set an exit code.\n\t *\n\t * This method should only be used in rare situations where it is important\n\t * to set an exit code (e.g. running tests) or when the application is\n\t * not in a healthy state and should terminate asap.\n\t *\n\t * This method does not fire the normal lifecycle events to the windows,\n\t * that normally can be vetoed. Windows are destroyed without a chance\n\t * of components to participate. The only lifecycle event handler that\n\t * is triggered is `onWillShutdown` in the main process.\n\t */\n\tkill(code?: number): Promise<void>;\n\n\t/**\n\t * Returns a promise that resolves when a certain lifecycle phase\n\t * has started.\n\t */\n\twhen(phase: LifecycleMainPhase): Promise<void>;\n}\n\nexport const enum LifecycleMainPhase {\n\n\t/**\n\t * The first phase signals that we are about to startup.\n\t */\n\tStarting = 1,\n\n\t/**\n\t * Services are ready and first window is about to open.\n\t */\n\tReady = 2,\n\n\t/**\n\t * This phase signals a point in time after the window has opened\n\t * and is typically the best place to do work that is not required\n\t * for the window to open.\n\t */\n\tAfterWindowOpen = 3,\n\n\t/**\n\t * The last phase after a window has opened and some time has passed\n\t * (2-5 seconds).\n\t */\n\tEventually = 4\n}\n\nexport class LifecycleMainService extends Disposable implements ILifecycleMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly QUIT_AND_RESTART_KEY = 'lifecycle.quitAndRestart';\n\n\tprivate readonly _onBeforeShutdown = this._register(new Emitter<void>());\n\treadonly onBeforeShutdown = this._onBeforeShutdown.event;\n\n\tprivate readonly _onWillShutdown = this._register(new Emitter<ShutdownEvent>());\n\treadonly onWillShutdown = this._onWillShutdown.event;\n\n\tprivate readonly _onWillLoadWindow = this._register(new Emitter<WindowLoadEvent>());\n\treadonly onWillLoadWindow = this._onWillLoadWindow.event;\n\n\tprivate readonly _onBeforeCloseWindow = this._register(new Emitter<ICodeWindow>());\n\treadonly onBeforeCloseWindow = this._onBeforeCloseWindow.event;\n\n\tprivate _quitRequested = false;\n\tget quitRequested(): boolean { return this._quitRequested; }\n\n\tprivate _wasRestarted = false;\n\tget wasRestarted(): boolean { return this._wasRestarted; }\n\n\tprivate _phase = LifecycleMainPhase.Starting;\n\tget phase(): LifecycleMainPhase { return this._phase; }\n\n\tprivate readonly windowToCloseRequest = new Set<number>();\n\tprivate oneTimeListenerTokenGenerator = 0;\n\tprivate windowCounter = 0;\n\n\tprivate pendingQuitPromise: Promise<boolean> | undefined = undefined;\n\tprivate pendingQuitPromiseResolve: { (veto: boolean): void } | undefined = undefined;\n\n\tprivate pendingWillShutdownPromise: Promise<void> | undefined = undefined;\n\n\tprivate readonly mapWindowIdToPendingUnload = new Map<number, Promise<boolean>>();\n\n\tprivate readonly phaseWhen = new Map<LifecycleMainPhase, Barrier>();\n\n\tprivate relaunchHandler: IRelaunchHandler | undefined = undefined;\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStateService private readonly stateService: IStateService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService\n\t) {\n\t\tsuper();\n\n\t\tthis.resolveRestarted();\n\t\tthis.when(LifecycleMainPhase.Ready).then(() => this.registerListeners());\n\t}\n\n\tprivate resolveRestarted(): void {\n\t\tthis._wasRestarted = !!this.stateService.getItem(LifecycleMainService.QUIT_AND_RESTART_KEY);\n\n\t\tif (this._wasRestarted) {\n\t\t\t// remove the marker right after if found\n\t\t\tthis.stateService.removeItem(LifecycleMainService.QUIT_AND_RESTART_KEY);\n\t\t}\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// before-quit: an event that is fired if application quit was\n\t\t// requested but before any window was closed.\n\t\tconst beforeQuitListener = () => {\n\t\t\tif (this._quitRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.trace('Lifecycle#app.on(before-quit)');\n\t\t\tthis._quitRequested = true;\n\n\t\t\t// Emit event to indicate that we are about to shutdown\n\t\t\tthis.trace('Lifecycle#onBeforeShutdown.fire()');\n\t\t\tthis._onBeforeShutdown.fire();\n\n\t\t\t// macOS: can run without any window open. in that case we fire\n\t\t\t// the onWillShutdown() event directly because there is no veto\n\t\t\t// to be expected.\n\t\t\tif (isMacintosh && this.windowCounter === 0) {\n\t\t\t\tthis.fireOnWillShutdown(ShutdownReason.QUIT);\n\t\t\t}\n\t\t};\n\t\telectron.app.addListener('before-quit', beforeQuitListener);\n\n\t\t// window-all-closed: an event that only fires when the last window\n\t\t// was closed. We override this event to be in charge if app.quit()\n\t\t// should be called or not.\n\t\tconst windowAllClosedListener = () => {\n\t\t\tthis.trace('Lifecycle#app.on(window-all-closed)');\n\n\t\t\t// Windows/Linux: we quit when all windows have closed\n\t\t\t// Mac: we only quit when quit was requested\n\t\t\tif (this._quitRequested || !isMacintosh) {\n\t\t\t\telectron.app.quit();\n\t\t\t}\n\t\t};\n\t\telectron.app.addListener('window-all-closed', windowAllClosedListener);\n\n\t\t// will-quit: an event that is fired after all windows have been\n\t\t// closed, but before actually quitting.\n\t\telectron.app.once('will-quit', e => {\n\t\t\tthis.trace('Lifecycle#app.on(will-quit) - begin');\n\n\t\t\t// Prevent the quit until the shutdown promise was resolved\n\t\t\te.preventDefault();\n\n\t\t\t// Start shutdown sequence\n\t\t\tconst shutdownPromise = this.fireOnWillShutdown(ShutdownReason.QUIT);\n\n\t\t\t// Wait until shutdown is signaled to be complete\n\t\t\tshutdownPromise.finally(() => {\n\t\t\t\tthis.trace('Lifecycle#app.on(will-quit) - after fireOnWillShutdown');\n\n\t\t\t\t// Resolve pending quit promise now without veto\n\t\t\t\tthis.resolvePendingQuitPromise(false /* no veto */);\n\n\t\t\t\t// Quit again, this time do not prevent this, since our\n\t\t\t\t// will-quit listener is only installed \"once\". Also\n\t\t\t\t// remove any listener we have that is no longer needed\n\n\t\t\t\telectron.app.removeListener('before-quit', beforeQuitListener);\n\t\t\t\telectron.app.removeListener('window-all-closed', windowAllClosedListener);\n\n\t\t\t\tthis.trace('Lifecycle#app.on(will-quit) - calling app.quit()');\n\n\t\t\t\telectron.app.quit();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate fireOnWillShutdown(reason: ShutdownReason): Promise<void> {\n\t\tif (this.pendingWillShutdownPromise) {\n\t\t\treturn this.pendingWillShutdownPromise; // shutdown is already running\n\t\t}\n\n\t\tconst logService = this.logService;\n\t\tthis.trace('Lifecycle#onWillShutdown.fire()');\n\n\t\tconst joiners: Promise<void>[] = [];\n\n\t\tthis._onWillShutdown.fire({\n\t\t\treason,\n\t\t\tjoin(id, promise) {\n\t\t\t\tlogService.trace(`Lifecycle#onWillShutdown - begin '${id}'`);\n\t\t\t\tjoiners.push(promise.finally(() => {\n\t\t\t\t\tlogService.trace(`Lifecycle#onWillShutdown - end '${id}'`);\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\n\t\tthis.pendingWillShutdownPromise = (async () => {\n\n\t\t\t// Settle all shutdown event joiners\n\t\t\ttry {\n\t\t\t\tawait Promises.settled(joiners);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\n\t\t\t// Then, always make sure at the end\n\t\t\t// the state service is flushed.\n\t\t\ttry {\n\t\t\t\tawait this.stateService.close();\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\t\t})();\n\n\t\treturn this.pendingWillShutdownPromise;\n\t}\n\n\tset phase(value: LifecycleMainPhase) {\n\t\tif (value < this.phase) {\n\t\t\tthrow new Error('Lifecycle cannot go backwards');\n\t\t}\n\n\t\tif (this._phase === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.trace(`lifecycle (main): phase changed (value: ${value})`);\n\n\t\tthis._phase = value;\n\n\t\tconst barrier = this.phaseWhen.get(this._phase);\n\t\tif (barrier) {\n\t\t\tbarrier.open();\n\t\t\tthis.phaseWhen.delete(this._phase);\n\t\t}\n\t}\n\n\tasync when(phase: LifecycleMainPhase): Promise<void> {\n\t\tif (phase <= this._phase) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet barrier = this.phaseWhen.get(phase);\n\t\tif (!barrier) {\n\t\t\tbarrier = new Barrier();\n\t\t\tthis.phaseWhen.set(phase, barrier);\n\t\t}\n\n\t\tawait barrier.wait();\n\t}\n\n\tregisterWindow(window: ICodeWindow): void {\n\t\tconst windowListeners = new DisposableStore();\n\n\t\t// track window count\n\t\tthis.windowCounter++;\n\n\t\t// Window Will Load\n\t\twindowListeners.add(window.onWillLoad(e => this._onWillLoadWindow.fire({ window, workspace: e.workspace, reason: e.reason })));\n\n\t\t// Window Before Closing: Main -> Renderer\n\t\tconst win = assertReturnsDefined(window.win);\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'close')(e => {\n\n\t\t\t// The window already acknowledged to be closed\n\t\t\tconst windowId = window.id;\n\t\t\tif (this.windowToCloseRequest.has(windowId)) {\n\t\t\t\tthis.windowToCloseRequest.delete(windowId);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.trace(`Lifecycle#window.on('close') - window ID ${window.id}`);\n\n\t\t\t// Otherwise prevent unload and handle it from window\n\t\t\te.preventDefault();\n\t\t\tthis.unload(window, UnloadReason.CLOSE).then(veto => {\n\t\t\t\tif (veto) {\n\t\t\t\t\tthis.windowToCloseRequest.delete(windowId);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.windowToCloseRequest.add(windowId);\n\n\t\t\t\t// Fire onBeforeCloseWindow before actually closing\n\t\t\t\tthis.trace(`Lifecycle#onBeforeCloseWindow.fire() - window ID ${windowId}`);\n\t\t\t\tthis._onBeforeCloseWindow.fire(window);\n\n\t\t\t\t// No veto, close window now\n\t\t\t\twindow.close();\n\t\t\t});\n\t\t}));\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'closed')(() => {\n\t\t\tthis.trace(`Lifecycle#window.on('closed') - window ID ${window.id}`);\n\n\t\t\t// update window count\n\t\t\tthis.windowCounter--;\n\n\t\t\t// clear window listeners\n\t\t\twindowListeners.dispose();\n\n\t\t\t// if there are no more code windows opened, fire the onWillShutdown event, unless\n\t\t\t// we are on macOS where it is perfectly fine to close the last window and\n\t\t\t// the application continues running (unless quit was actually requested)\n\t\t\tif (this.windowCounter === 0 && (!isMacintosh || this._quitRequested)) {\n\t\t\t\tthis.fireOnWillShutdown(ShutdownReason.QUIT);\n\t\t\t}\n\t\t}));\n\t}\n\n\tregisterAuxWindow(auxWindow: IAuxiliaryWindow): void {\n\t\tconst win = assertReturnsDefined(auxWindow.win);\n\n\t\tconst windowListeners = new DisposableStore();\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'close')(e => {\n\t\t\tthis.trace(`Lifecycle#auxWindow.on('close') - window ID ${auxWindow.id}`);\n\n\t\t\tif (this._quitRequested) {\n\t\t\t\tthis.trace(`Lifecycle#auxWindow.on('close') - preventDefault() because quit requested`);\n\n\t\t\t\t// When quit is requested, Electron will close all\n\t\t\t\t// auxiliary windows before closing the main windows.\n\t\t\t\t// This prevents us from storing the auxiliary window\n\t\t\t\t// state on shutdown and thus we prevent closing if\n\t\t\t\t// quit is requested.\n\t\t\t\t//\n\t\t\t\t// Interestingly, this will not prevent the application\n\t\t\t\t// from quitting because the auxiliary windows will still\n\t\t\t\t// close once the owning window closes.\n\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t}));\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'closed')(() => {\n\t\t\tthis.trace(`Lifecycle#auxWindow.on('closed') - window ID ${auxWindow.id}`);\n\n\t\t\twindowListeners.dispose();\n\t\t}));\n\t}\n\n\tasync reload(window: ICodeWindow, cli?: NativeParsedArgs): Promise<void> {\n\n\t\t// Only reload when the window has not vetoed this\n\t\tconst veto = await this.unload(window, UnloadReason.RELOAD);\n\t\tif (!veto) {\n\t\t\twindow.reload(cli);\n\t\t}\n\t}\n\n\tunload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\n\t\t// Ensure there is only 1 unload running at the same time\n\t\tconst pendingUnloadPromise = this.mapWindowIdToPendingUnload.get(window.id);\n\t\tif (pendingUnloadPromise) {\n\t\t\treturn pendingUnloadPromise;\n\t\t}\n\n\t\t// Start unload and remember in map until finished\n\t\tconst unloadPromise = this.doUnload(window, reason).finally(() => {\n\t\t\tthis.mapWindowIdToPendingUnload.delete(window.id);\n\t\t});\n\t\tthis.mapWindowIdToPendingUnload.set(window.id, unloadPromise);\n\n\t\treturn unloadPromise;\n\t}\n\n\tprivate async doUnload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\n\t\t// Always allow to unload a window that is not yet ready\n\t\tif (!window.isReady) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.trace(`Lifecycle#unload() - window ID ${window.id}`);\n\n\t\t// first ask the window itself if it vetos the unload\n\t\tconst windowUnloadReason = this._quitRequested ? UnloadReason.QUIT : reason;\n\t\tconst veto = await this.onBeforeUnloadWindowInRenderer(window, windowUnloadReason);\n\t\tif (veto) {\n\t\t\tthis.trace(`Lifecycle#unload() - veto in renderer (window ID ${window.id})`);\n\n\t\t\treturn this.handleWindowUnloadVeto(veto);\n\t\t}\n\n\t\t// finally if there are no vetos, unload the renderer\n\t\tawait this.onWillUnloadWindowInRenderer(window, windowUnloadReason);\n\n\t\treturn false;\n\t}\n\n\tprivate handleWindowUnloadVeto(veto: boolean): boolean {\n\t\tif (!veto) {\n\t\t\treturn false; // no veto\n\t\t}\n\n\t\t// a veto resolves any pending quit with veto\n\t\tthis.resolvePendingQuitPromise(true /* veto */);\n\n\t\t// a veto resets the pending quit request flag\n\t\tthis._quitRequested = false;\n\n\t\treturn true; // veto\n\t}\n\n\tprivate resolvePendingQuitPromise(veto: boolean): void {\n\t\tif (this.pendingQuitPromiseResolve) {\n\t\t\tthis.pendingQuitPromiseResolve(veto);\n\t\t\tthis.pendingQuitPromiseResolve = undefined;\n\t\t\tthis.pendingQuitPromise = undefined;\n\t\t}\n\t}\n\n\tprivate onBeforeUnloadWindowInRenderer(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\t\treturn new Promise<boolean>(resolve => {\n\t\t\tconst oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n\t\t\tconst okChannel = `vscode:ok${oneTimeEventToken}`;\n\t\t\tconst cancelChannel = `vscode:cancel${oneTimeEventToken}`;\n\n\t\t\tvalidatedIpcMain.once(okChannel, () => {\n\t\t\t\tresolve(false); // no veto\n\t\t\t});\n\n\t\t\tvalidatedIpcMain.once(cancelChannel, () => {\n\t\t\t\tresolve(true); // veto\n\t\t\t});\n\n\t\t\twindow.send('vscode:onBeforeUnload', { okChannel, cancelChannel, reason });\n\t\t});\n\t}\n\n\tprivate onWillUnloadWindowInRenderer(window: ICodeWindow, reason: UnloadReason): Promise<void> {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tconst oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n\t\t\tconst replyChannel = `vscode:reply${oneTimeEventToken}`;\n\n\t\t\tvalidatedIpcMain.once(replyChannel, () => resolve());\n\n\t\t\twindow.send('vscode:onWillUnload', { replyChannel, reason });\n\t\t});\n\t}\n\n\tquit(willRestart?: boolean): Promise<boolean /* veto */> {\n\t\treturn this.doQuit(willRestart).then(veto => {\n\t\t\tif (!veto && willRestart) {\n\t\t\t\t// Windows: we are about to restart and as such we need to restore the original\n\t\t\t\t// current working directory we had on startup to get the exact same startup\n\t\t\t\t// behaviour. As such, we briefly change back to that directory and then when\n\t\t\t\t// Code starts it will set it back to the installation directory again.\n\t\t\t\ttry {\n\t\t\t\t\tif (isWindows) {\n\t\t\t\t\t\tconst currentWorkingDir = cwd();\n\t\t\t\t\t\tif (currentWorkingDir !== process.cwd()) {\n\t\t\t\t\t\t\tprocess.chdir(currentWorkingDir);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.logService.error(err);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn veto;\n\t\t});\n\t}\n\n\tprivate doQuit(willRestart?: boolean): Promise<boolean /* veto */> {\n\t\tthis.trace(`Lifecycle#quit() - begin (willRestart: ${willRestart})`);\n\n\t\tif (this.pendingQuitPromise) {\n\t\t\tthis.trace('Lifecycle#quit() - returning pending quit promise');\n\n\t\t\treturn this.pendingQuitPromise;\n\t\t}\n\n\t\t// Remember if we are about to restart\n\t\tif (willRestart) {\n\t\t\tthis.stateService.setItem(LifecycleMainService.QUIT_AND_RESTART_KEY, true);\n\t\t}\n\n\t\tthis.pendingQuitPromise = new Promise(resolve => {\n\n\t\t\t// Store as field to access it from a window cancellation\n\t\t\tthis.pendingQuitPromiseResolve = resolve;\n\n\t\t\t// Calling app.quit() will trigger the close handlers of each opened window\n\t\t\t// and only if no window vetoed the shutdown, we will get the will-quit event\n\t\t\tthis.trace('Lifecycle#quit() - calling app.quit()');\n\t\t\telectron.app.quit();\n\t\t});\n\n\t\treturn this.pendingQuitPromise;\n\t}\n\n\tprivate trace(msg: string): void {\n\t\tif (this.environmentMainService.args['enable-smoke-test-driver']) {\n\t\t\tthis.logService.info(msg); // helps diagnose issues with exiting from smoke tests\n\t\t} else {\n\t\t\tthis.logService.trace(msg);\n\t\t}\n\t}\n\n\tsetRelaunchHandler(handler: IRelaunchHandler): void {\n\t\tthis.relaunchHandler = handler;\n\t}\n\n\tasync relaunch(options?: IRelaunchOptions): Promise<void> {\n\t\tthis.trace('Lifecycle#relaunch()');\n\n\t\tconst args = process.argv.slice(1);\n\t\tif (options?.addArgs) {\n\t\t\targs.push(...options.addArgs);\n\t\t}\n\n\t\tif (options?.removeArgs) {\n\t\t\tfor (const a of options.removeArgs) {\n\t\t\t\tconst idx = args.indexOf(a);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\targs.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst quitListener = () => {\n\t\t\tif (!this.relaunchHandler?.handleRelaunch(options)) {\n\t\t\t\tthis.trace('Lifecycle#relaunch() - calling app.relaunch()');\n\t\t\t\telectron.app.relaunch({ args });\n\t\t\t}\n\t\t};\n\t\telectron.app.once('quit', quitListener);\n\n\t\t// `app.relaunch()` does not quit automatically, so we quit first,\n\t\t// check for vetoes and then relaunch from the `app.on('quit')` event\n\t\tconst veto = await this.quit(true /* will restart */);\n\t\tif (veto) {\n\t\t\telectron.app.removeListener('quit', quitListener);\n\t\t}\n\t}\n\n\tasync kill(code?: number): Promise<void> {\n\t\tthis.trace('Lifecycle#kill()');\n\n\t\t// Give main process participants a chance to orderly shutdown\n\t\tawait this.fireOnWillShutdown(ShutdownReason.KILL);\n\n\t\t// From extension tests we have seen issues where calling app.exit()\n\t\t// with an opened window can lead to native crashes (Linux). As such,\n\t\t// we should make sure to destroy any opened window before calling\n\t\t// `app.exit()`.\n\t\t//\n\t\t// Note: Electron implements a similar logic here:\n\t\t// https://github.com/electron/electron/blob/fe5318d753637c3903e23fc1ed1b263025887b6a/spec-main/window-helpers.ts#L5\n\n\t\tawait Promise.race([\n\n\t\t\t// Still do not block more than 1s\n\t\t\ttimeout(1000),\n\n\t\t\t// Destroy any opened window: we do not unload windows here because\n\t\t\t// there is a chance that the unload is veto'd or long running due\n\t\t\t// to a participant within the window. this is not wanted when we\n\t\t\t// are asked to kill the application.\n\t\t\t(async () => {\n\t\t\t\tfor (const window of getAllWindowsExcludingOffscreen()) {\n\t\t\t\t\tif (window && !window.isDestroyed()) {\n\t\t\t\t\t\tlet whenWindowClosed: Promise<void>;\n\t\t\t\t\t\tif (window.webContents && !window.webContents.isDestroyed()) {\n\t\t\t\t\t\t\twhenWindowClosed = new Promise(resolve => window.once('closed', resolve));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhenWindowClosed = Promise.resolve();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twindow.destroy();\n\t\t\t\t\t\tawait whenWindowClosed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})()\n\t\t]);\n\n\t\t// Now exit either after 1s or all windows destroyed\n\t\telectron.app.exit(code);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport electron from 'electron';\nimport { validatedIpcMain } from '../../../base/parts/ipc/electron-main/ipcMain.js';\nimport { Barrier, Promises, timeout } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { isMacintosh, isWindows } from '../../../base/common/platform.js';\nimport { cwd } from '../../../base/common/process.js';\nimport { assertReturnsDefined } from '../../../base/common/types.js';\nimport { NativeParsedArgs } from '../../environment/common/argv.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IStateService } from '../../state/node/state.js';\nimport { ICodeWindow, LoadReason, UnloadReason } from '../../window/electron-main/window.js';\nimport { ISingleFolderWorkspaceIdentifier, IWorkspaceIdentifier } from '../../workspace/common/workspace.js';\nimport { IEnvironmentMainService } from '../../environment/electron-main/environmentMainService.js';\nimport { IAuxiliaryWindow } from '../../auxiliaryWindow/electron-main/auxiliaryWindow.js';\nimport { getAllWindowsExcludingOffscreen } from '../../windows/electron-main/windows.js';\n\nexport const ILifecycleMainService = createDecorator<ILifecycleMainService>('lifecycleMainService');\n\ninterface WindowLoadEvent {\n\n\t/**\n\t * The window that is loaded to a new workspace.\n\t */\n\treadonly window: ICodeWindow;\n\n\t/**\n\t * The workspace the window is loaded into.\n\t */\n\treadonly workspace: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | undefined;\n\n\t/**\n\t * More details why the window loads to a new workspace.\n\t */\n\treadonly reason: LoadReason;\n}\n\nexport const enum ShutdownReason {\n\n\t/**\n\t * The application exits normally.\n\t */\n\tQUIT = 1,\n\n\t/**\n\t * The application exits abnormally and is being\n\t * killed with an exit code (e.g. from integration\n\t * test run)\n\t */\n\tKILL\n}\n\nexport interface ShutdownEvent {\n\n\t/**\n\t * More details why the application is shutting down.\n\t */\n\treason: ShutdownReason;\n\n\t/**\n\t * Allows to join the shutdown. The promise can be a long running operation but it\n\t * will block the application from closing.\n\t */\n\tjoin(id: string, promise: Promise<void>): void;\n}\n\nexport interface IRelaunchHandler {\n\n\t/**\n\t * Allows a handler to deal with relaunching the application. The return\n\t * value indicates if the relaunch is handled or not.\n\t */\n\thandleRelaunch(options?: IRelaunchOptions): boolean;\n}\n\nexport interface IRelaunchOptions {\n\treadonly addArgs?: string[];\n\treadonly removeArgs?: string[];\n}\n\nexport interface ILifecycleMainService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Will be true if the program was restarted (e.g. due to explicit request or update).\n\t */\n\treadonly wasRestarted: boolean;\n\n\t/**\n\t * Will be true if the program was requested to quit.\n\t */\n\treadonly quitRequested: boolean;\n\n\t/**\n\t * A flag indicating in what phase of the lifecycle we currently are.\n\t */\n\tphase: LifecycleMainPhase;\n\n\t/**\n\t * An event that fires when the application is about to shutdown before any window is closed.\n\t * The shutdown can still be prevented by any window that vetos this event.\n\t */\n\treadonly onBeforeShutdown: Event<void>;\n\n\t/**\n\t * An event that fires after the onBeforeShutdown event has been fired and after no window has\n\t * vetoed the shutdown sequence. At this point listeners are ensured that the application will\n\t * quit without veto.\n\t */\n\treadonly onWillShutdown: Event<ShutdownEvent>;\n\n\t/**\n\t * An event that fires when a window is loading. This can either be a window opening for the\n\t * first time or a window reloading or changing to another URL.\n\t */\n\treadonly onWillLoadWindow: Event<WindowLoadEvent>;\n\n\t/**\n\t * An event that fires before a window closes. This event is fired after any veto has been dealt\n\t * with so that listeners know for sure that the window will close without veto.\n\t */\n\treadonly onBeforeCloseWindow: Event<ICodeWindow>;\n\n\t/**\n\t * Make a `ICodeWindow` known to the lifecycle main service.\n\t */\n\tregisterWindow(window: ICodeWindow): void;\n\n\t/**\n\t * Make a `IAuxiliaryWindow` known to the lifecycle main service.\n\t */\n\tregisterAuxWindow(auxWindow: IAuxiliaryWindow): void;\n\n\t/**\n\t * Reload a window. All lifecycle event handlers are triggered.\n\t */\n\treload(window: ICodeWindow, cli?: NativeParsedArgs): Promise<void>;\n\n\t/**\n\t * Unload a window for the provided reason. All lifecycle event handlers are triggered.\n\t */\n\tunload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */>;\n\n\t/**\n\t * Restart the application with optional arguments (CLI). All lifecycle event handlers are triggered.\n\t */\n\trelaunch(options?: IRelaunchOptions): Promise<void>;\n\n\t/**\n\t * Sets a custom handler for relaunching the application.\n\t */\n\tsetRelaunchHandler(handler: IRelaunchHandler): void;\n\n\t/**\n\t * Shutdown the application normally. All lifecycle event handlers are triggered.\n\t */\n\tquit(willRestart?: boolean): Promise<boolean /* veto */>;\n\n\t/**\n\t * Forcefully shutdown the application and optionally set an exit code.\n\t *\n\t * This method should only be used in rare situations where it is important\n\t * to set an exit code (e.g. running tests) or when the application is\n\t * not in a healthy state and should terminate asap.\n\t *\n\t * This method does not fire the normal lifecycle events to the windows,\n\t * that normally can be vetoed. Windows are destroyed without a chance\n\t * of components to participate. The only lifecycle event handler that\n\t * is triggered is `onWillShutdown` in the main process.\n\t */\n\tkill(code?: number): Promise<void>;\n\n\t/**\n\t * Returns a promise that resolves when a certain lifecycle phase\n\t * has started.\n\t */\n\twhen(phase: LifecycleMainPhase): Promise<void>;\n}\n\nexport const enum LifecycleMainPhase {\n\n\t/**\n\t * The first phase signals that we are about to startup.\n\t */\n\tStarting = 1,\n\n\t/**\n\t * Services are ready and first window is about to open.\n\t */\n\tReady = 2,\n\n\t/**\n\t * This phase signals a point in time after the window has opened\n\t * and is typically the best place to do work that is not required\n\t * for the window to open.\n\t */\n\tAfterWindowOpen = 3,\n\n\t/**\n\t * The last phase after a window has opened and some time has passed\n\t * (2-5 seconds).\n\t */\n\tEventually = 4\n}\n\nexport class LifecycleMainService extends Disposable implements ILifecycleMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly QUIT_AND_RESTART_KEY = 'lifecycle.quitAndRestart';\n\n\tprivate readonly _onBeforeShutdown = this._register(new Emitter<void>());\n\treadonly onBeforeShutdown = this._onBeforeShutdown.event;\n\n\tprivate readonly _onWillShutdown = this._register(new Emitter<ShutdownEvent>());\n\treadonly onWillShutdown = this._onWillShutdown.event;\n\n\tprivate readonly _onWillLoadWindow = this._register(new Emitter<WindowLoadEvent>());\n\treadonly onWillLoadWindow = this._onWillLoadWindow.event;\n\n\tprivate readonly _onBeforeCloseWindow = this._register(new Emitter<ICodeWindow>());\n\treadonly onBeforeCloseWindow = this._onBeforeCloseWindow.event;\n\n\tprivate _quitRequested = false;\n\tget quitRequested(): boolean { return this._quitRequested; }\n\n\tprivate _wasRestarted = false;\n\tget wasRestarted(): boolean { return this._wasRestarted; }\n\n\tprivate _phase = LifecycleMainPhase.Starting;\n\tget phase(): LifecycleMainPhase { return this._phase; }\n\n\tprivate readonly windowToCloseRequest = new Set<number>();\n\tprivate oneTimeListenerTokenGenerator = 0;\n\tprivate windowCounter = 0;\n\n\tprivate pendingQuitPromise: Promise<boolean> | undefined = undefined;\n\tprivate pendingQuitPromiseResolve: { (veto: boolean): void } | undefined = undefined;\n\n\tprivate pendingWillShutdownPromise: Promise<void> | undefined = undefined;\n\n\tprivate readonly mapWindowIdToPendingUnload = new Map<number, Promise<boolean>>();\n\n\tprivate readonly phaseWhen = new Map<LifecycleMainPhase, Barrier>();\n\n\tprivate relaunchHandler: IRelaunchHandler | undefined = undefined;\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStateService private readonly stateService: IStateService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService\n\t) {\n\t\tsuper();\n\n\t\tthis.resolveRestarted();\n\t\tthis.when(LifecycleMainPhase.Ready).then(() => this.registerListeners());\n\t}\n\n\tprivate resolveRestarted(): void {\n\t\tthis._wasRestarted = !!this.stateService.getItem(LifecycleMainService.QUIT_AND_RESTART_KEY);\n\n\t\tif (this._wasRestarted) {\n\t\t\t// remove the marker right after if found\n\t\t\tthis.stateService.removeItem(LifecycleMainService.QUIT_AND_RESTART_KEY);\n\t\t}\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// before-quit: an event that is fired if application quit was\n\t\t// requested but before any window was closed.\n\t\tconst beforeQuitListener = () => {\n\t\t\tif (this._quitRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.trace('Lifecycle#app.on(before-quit)');\n\t\t\tthis._quitRequested = true;\n\n\t\t\t// Emit event to indicate that we are about to shutdown\n\t\t\tthis.trace('Lifecycle#onBeforeShutdown.fire()');\n\t\t\tthis._onBeforeShutdown.fire();\n\n\t\t\t// macOS: can run without any window open. in that case we fire\n\t\t\t// the onWillShutdown() event directly because there is no veto\n\t\t\t// to be expected.\n\t\t\tif (isMacintosh && this.windowCounter === 0) {\n\t\t\t\tthis.fireOnWillShutdown(ShutdownReason.QUIT);\n\t\t\t}\n\t\t};\n\t\telectron.app.addListener('before-quit', beforeQuitListener);\n\n\t\t// window-all-closed: an event that only fires when the last window\n\t\t// was closed. We override this event to be in charge if app.quit()\n\t\t// should be called or not.\n\t\tconst windowAllClosedListener = () => {\n\t\t\tthis.trace('Lifecycle#app.on(window-all-closed)');\n\n\t\t\t// Windows/Linux: we quit when all windows have closed\n\t\t\t// Mac: we only quit when quit was requested\n\t\t\tif (this._quitRequested || !isMacintosh) {\n\t\t\t\telectron.app.quit();\n\t\t\t}\n\t\t};\n\t\telectron.app.addListener('window-all-closed', windowAllClosedListener);\n\n\t\t// will-quit: an event that is fired after all windows have been\n\t\t// closed, but before actually quitting.\n\t\telectron.app.once('will-quit', e => {\n\t\t\tthis.trace('Lifecycle#app.on(will-quit) - begin');\n\n\t\t\t// Prevent the quit until the shutdown promise was resolved\n\t\t\te.preventDefault();\n\n\t\t\t// Start shutdown sequence\n\t\t\tconst shutdownPromise = this.fireOnWillShutdown(ShutdownReason.QUIT);\n\n\t\t\t// Wait until shutdown is signaled to be complete\n\t\t\tshutdownPromise.finally(() => {\n\t\t\t\tthis.trace('Lifecycle#app.on(will-quit) - after fireOnWillShutdown');\n\n\t\t\t\t// Resolve pending quit promise now without veto\n\t\t\t\tthis.resolvePendingQuitPromise(false /* no veto */);\n\n\t\t\t\t// Quit again, this time do not prevent this, since our\n\t\t\t\t// will-quit listener is only installed \"once\". Also\n\t\t\t\t// remove any listener we have that is no longer needed\n\n\t\t\t\telectron.app.removeListener('before-quit', beforeQuitListener);\n\t\t\t\telectron.app.removeListener('window-all-closed', windowAllClosedListener);\n\n\t\t\t\tthis.trace('Lifecycle#app.on(will-quit) - calling app.quit()');\n\n\t\t\t\telectron.app.quit();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate fireOnWillShutdown(reason: ShutdownReason): Promise<void> {\n\t\tif (this.pendingWillShutdownPromise) {\n\t\t\treturn this.pendingWillShutdownPromise; // shutdown is already running\n\t\t}\n\n\t\tconst logService = this.logService;\n\t\tthis.trace('Lifecycle#onWillShutdown.fire()');\n\n\t\tconst joiners: Promise<void>[] = [];\n\n\t\tthis._onWillShutdown.fire({\n\t\t\treason,\n\t\t\tjoin(id, promise) {\n\t\t\t\tlogService.trace(`Lifecycle#onWillShutdown - begin '${id}'`);\n\t\t\t\tjoiners.push(promise.finally(() => {\n\t\t\t\t\tlogService.trace(`Lifecycle#onWillShutdown - end '${id}'`);\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\n\t\tthis.pendingWillShutdownPromise = (async () => {\n\n\t\t\t// Settle all shutdown event joiners\n\t\t\ttry {\n\t\t\t\tawait Promises.settled(joiners);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\n\t\t\t// Then, always make sure at the end\n\t\t\t// the state service is flushed.\n\t\t\ttry {\n\t\t\t\tawait this.stateService.close();\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\t\t})();\n\n\t\treturn this.pendingWillShutdownPromise;\n\t}\n\n\tset phase(value: LifecycleMainPhase) {\n\t\tif (value < this.phase) {\n\t\t\tthrow new Error('Lifecycle cannot go backwards');\n\t\t}\n\n\t\tif (this._phase === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.trace(`lifecycle (main): phase changed (value: ${value})`);\n\n\t\tthis._phase = value;\n\n\t\tconst barrier = this.phaseWhen.get(this._phase);\n\t\tif (barrier) {\n\t\t\tbarrier.open();\n\t\t\tthis.phaseWhen.delete(this._phase);\n\t\t}\n\t}\n\n\tasync when(phase: LifecycleMainPhase): Promise<void> {\n\t\tif (phase <= this._phase) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet barrier = this.phaseWhen.get(phase);\n\t\tif (!barrier) {\n\t\t\tbarrier = new Barrier();\n\t\t\tthis.phaseWhen.set(phase, barrier);\n\t\t}\n\n\t\tawait barrier.wait();\n\t}\n\n\tregisterWindow(window: ICodeWindow): void {\n\t\tconst windowListeners = new DisposableStore();\n\n\t\t// track window count\n\t\tthis.windowCounter++;\n\n\t\t// Window Will Load\n\t\twindowListeners.add(window.onWillLoad(e => this._onWillLoadWindow.fire({ window, workspace: e.workspace, reason: e.reason })));\n\n\t\t// Window Before Closing: Main -> Renderer\n\t\tconst win = assertReturnsDefined(window.win);\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'close')(e => {\n\n\t\t\t// The window already acknowledged to be closed\n\t\t\tconst windowId = window.id;\n\t\t\tif (this.windowToCloseRequest.has(windowId)) {\n\t\t\t\tthis.windowToCloseRequest.delete(windowId);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.trace(`Lifecycle#window.on('close') - window ID ${window.id}`);\n\n\t\t\t// Otherwise prevent unload and handle it from window\n\t\t\te.preventDefault();\n\t\t\tthis.unload(window, UnloadReason.CLOSE).then(veto => {\n\t\t\t\tif (veto) {\n\t\t\t\t\tthis.windowToCloseRequest.delete(windowId);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.windowToCloseRequest.add(windowId);\n\n\t\t\t\t// Fire onBeforeCloseWindow before actually closing\n\t\t\t\tthis.trace(`Lifecycle#onBeforeCloseWindow.fire() - window ID ${windowId}`);\n\t\t\t\tthis._onBeforeCloseWindow.fire(window);\n\n\t\t\t\t// No veto, close window now\n\t\t\t\twindow.close();\n\t\t\t});\n\t\t}));\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'closed')(() => {\n\t\t\tthis.trace(`Lifecycle#window.on('closed') - window ID ${window.id}`);\n\n\t\t\t// update window count\n\t\t\tthis.windowCounter--;\n\n\t\t\t// clear window listeners\n\t\t\twindowListeners.dispose();\n\n\t\t\t// if there are no more code windows opened, fire the onWillShutdown event, unless\n\t\t\t// we are on macOS where it is perfectly fine to close the last window and\n\t\t\t// the application continues running (unless quit was actually requested)\n\t\t\tif (this.windowCounter === 0 && (!isMacintosh || this._quitRequested)) {\n\t\t\t\tthis.fireOnWillShutdown(ShutdownReason.QUIT);\n\t\t\t}\n\t\t}));\n\t}\n\n\tregisterAuxWindow(auxWindow: IAuxiliaryWindow): void {\n\t\tconst win = assertReturnsDefined(auxWindow.win);\n\n\t\tconst windowListeners = new DisposableStore();\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'close')(e => {\n\t\t\tthis.trace(`Lifecycle#auxWindow.on('close') - window ID ${auxWindow.id}`);\n\n\t\t\tif (this._quitRequested) {\n\t\t\t\tthis.trace(`Lifecycle#auxWindow.on('close') - preventDefault() because quit requested`);\n\n\t\t\t\t// When quit is requested, Electron will close all\n\t\t\t\t// auxiliary windows before closing the main windows.\n\t\t\t\t// This prevents us from storing the auxiliary window\n\t\t\t\t// state on shutdown and thus we prevent closing if\n\t\t\t\t// quit is requested.\n\t\t\t\t//\n\t\t\t\t// Interestingly, this will not prevent the application\n\t\t\t\t// from quitting because the auxiliary windows will still\n\t\t\t\t// close once the owning window closes.\n\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t}));\n\t\twindowListeners.add(Event.fromNodeEventEmitter<electron.Event>(win, 'closed')(() => {\n\t\t\tthis.trace(`Lifecycle#auxWindow.on('closed') - window ID ${auxWindow.id}`);\n\n\t\t\twindowListeners.dispose();\n\t\t}));\n\t}\n\n\tasync reload(window: ICodeWindow, cli?: NativeParsedArgs): Promise<void> {\n\n\t\t// Only reload when the window has not vetoed this\n\t\tconst veto = await this.unload(window, UnloadReason.RELOAD);\n\t\tif (!veto) {\n\t\t\twindow.reload(cli);\n\t\t}\n\t}\n\n\tunload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\n\t\t// Ensure there is only 1 unload running at the same time\n\t\tconst pendingUnloadPromise = this.mapWindowIdToPendingUnload.get(window.id);\n\t\tif (pendingUnloadPromise) {\n\t\t\treturn pendingUnloadPromise;\n\t\t}\n\n\t\t// Start unload and remember in map until finished\n\t\tconst unloadPromise = this.doUnload(window, reason).finally(() => {\n\t\t\tthis.mapWindowIdToPendingUnload.delete(window.id);\n\t\t});\n\t\tthis.mapWindowIdToPendingUnload.set(window.id, unloadPromise);\n\n\t\treturn unloadPromise;\n\t}\n\n\tprivate async doUnload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\n\t\t// Always allow to unload a window that is not yet ready\n\t\tif (!window.isReady) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.trace(`Lifecycle#unload() - window ID ${window.id}`);\n\n\t\t// first ask the window itself if it vetos the unload\n\t\tconst windowUnloadReason = this._quitRequested ? UnloadReason.QUIT : reason;\n\t\tconst veto = await this.onBeforeUnloadWindowInRenderer(window, windowUnloadReason);\n\t\tif (veto) {\n\t\t\tthis.trace(`Lifecycle#unload() - veto in renderer (window ID ${window.id})`);\n\n\t\t\treturn this.handleWindowUnloadVeto(veto);\n\t\t}\n\n\t\t// finally if there are no vetos, unload the renderer\n\t\tawait this.onWillUnloadWindowInRenderer(window, windowUnloadReason);\n\n\t\treturn false;\n\t}\n\n\tprivate handleWindowUnloadVeto(veto: boolean): boolean {\n\t\tif (!veto) {\n\t\t\treturn false; // no veto\n\t\t}\n\n\t\t// a veto resolves any pending quit with veto\n\t\tthis.resolvePendingQuitPromise(true /* veto */);\n\n\t\t// a veto resets the pending quit request flag\n\t\tthis._quitRequested = false;\n\n\t\treturn true; // veto\n\t}\n\n\tprivate resolvePendingQuitPromise(veto: boolean): void {\n\t\tif (this.pendingQuitPromiseResolve) {\n\t\t\tthis.pendingQuitPromiseResolve(veto);\n\t\t\tthis.pendingQuitPromiseResolve = undefined;\n\t\t\tthis.pendingQuitPromise = undefined;\n\t\t}\n\t}\n\n\tprivate onBeforeUnloadWindowInRenderer(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\t\treturn new Promise<boolean>(resolve => {\n\t\t\tconst oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n\t\t\tconst okChannel = `vscode:ok${oneTimeEventToken}`;\n\t\t\tconst cancelChannel = `vscode:cancel${oneTimeEventToken}`;\n\n\t\t\tvalidatedIpcMain.once(okChannel, () => {\n\t\t\t\tresolve(false); // no veto\n\t\t\t});\n\n\t\t\tvalidatedIpcMain.once(cancelChannel, () => {\n\t\t\t\tresolve(true); // veto\n\t\t\t});\n\n\t\t\twindow.send('vscode:onBeforeUnload', { okChannel, cancelChannel, reason });\n\t\t});\n\t}\n\n\tprivate onWillUnloadWindowInRenderer(window: ICodeWindow, reason: UnloadReason): Promise<void> {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tconst oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n\t\t\tconst replyChannel = `vscode:reply${oneTimeEventToken}`;\n\n\t\t\tvalidatedIpcMain.once(replyChannel, () => resolve());\n\n\t\t\twindow.send('vscode:onWillUnload', { replyChannel, reason });\n\t\t});\n\t}\n\n\tquit(willRestart?: boolean): Promise<boolean /* veto */> {\n\t\treturn this.doQuit(willRestart).then(veto => {\n\t\t\tif (!veto && willRestart) {\n\t\t\t\t// Windows: we are about to restart and as such we need to restore the original\n\t\t\t\t// current working directory we had on startup to get the exact same startup\n\t\t\t\t// behaviour. As such, we briefly change back to that directory and then when\n\t\t\t\t// Code starts it will set it back to the installation directory again.\n\t\t\t\ttry {\n\t\t\t\t\tif (isWindows) {\n\t\t\t\t\t\tconst currentWorkingDir = cwd();\n\t\t\t\t\t\tif (currentWorkingDir !== process.cwd()) {\n\t\t\t\t\t\t\tprocess.chdir(currentWorkingDir);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.logService.error(err);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn veto;\n\t\t});\n\t}\n\n\tprivate doQuit(willRestart?: boolean): Promise<boolean /* veto */> {\n\t\tthis.trace(`Lifecycle#quit() - begin (willRestart: ${willRestart})`);\n\n\t\tif (this.pendingQuitPromise) {\n\t\t\tthis.trace('Lifecycle#quit() - returning pending quit promise');\n\n\t\t\treturn this.pendingQuitPromise;\n\t\t}\n\n\t\t// Remember if we are about to restart\n\t\tif (willRestart) {\n\t\t\tthis.stateService.setItem(LifecycleMainService.QUIT_AND_RESTART_KEY, true);\n\t\t}\n\n\t\tthis.pendingQuitPromise = new Promise(resolve => {\n\n\t\t\t// Store as field to access it from a window cancellation\n\t\t\tthis.pendingQuitPromiseResolve = resolve;\n\n\t\t\t// Calling app.quit() will trigger the close handlers of each opened window\n\t\t\t// and only if no window vetoed the shutdown, we will get the will-quit event\n\t\t\tthis.trace('Lifecycle#quit() - calling app.quit()');\n\t\t\telectron.app.quit();\n\t\t});\n\n\t\treturn this.pendingQuitPromise;\n\t}\n\n\tprivate trace(msg: string): void {\n\t\tif (this.environmentMainService.args['enable-smoke-test-driver']) {\n\t\t\tthis.logService.info(msg); // helps diagnose issues with exiting from smoke tests\n\t\t} else {\n\t\t\tthis.logService.trace(msg);\n\t\t}\n\t}\n\n\tsetRelaunchHandler(handler: IRelaunchHandler): void {\n\t\tthis.relaunchHandler = handler;\n\t}\n\n\tasync relaunch(options?: IRelaunchOptions): Promise<void> {\n\t\tthis.trace('Lifecycle#relaunch()');\n\n\t\tconst args = process.argv.slice(1);\n\t\tif (options?.addArgs) {\n\t\t\targs.push(...options.addArgs);\n\t\t}\n\n\t\tif (options?.removeArgs) {\n\t\t\tfor (const a of options.removeArgs) {\n\t\t\t\tconst idx = args.indexOf(a);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\targs.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst quitListener = () => {\n\t\t\tif (!this.relaunchHandler?.handleRelaunch(options)) {\n\t\t\t\tthis.trace('Lifecycle#relaunch() - calling app.relaunch()');\n\t\t\t\telectron.app.relaunch({ args });\n\t\t\t}\n\t\t};\n\t\telectron.app.once('quit', quitListener);\n\n\t\t// `app.relaunch()` does not quit automatically, so we quit first,\n\t\t// check for vetoes and then relaunch from the `app.on('quit')` event\n\t\tconst veto = await this.quit(true /* will restart */);\n\t\tif (veto) {\n\t\t\telectron.app.removeListener('quit', quitListener);\n\t\t}\n\t}\n\n\tasync kill(code?: number): Promise<void> {\n\t\tthis.trace('Lifecycle#kill()');\n\n\t\t// Give main process participants a chance to orderly shutdown\n\t\tawait this.fireOnWillShutdown(ShutdownReason.KILL);\n\n\t\t// From extension tests we have seen issues where calling app.exit()\n\t\t// with an opened window can lead to native crashes (Linux). As such,\n\t\t// we should make sure to destroy any opened window before calling\n\t\t// `app.exit()`.\n\t\t//\n\t\t// Note: Electron implements a similar logic here:\n\t\t// https://github.com/electron/electron/blob/fe5318d753637c3903e23fc1ed1b263025887b6a/spec-main/window-helpers.ts#L5\n\n\t\tawait Promise.race([\n\n\t\t\t// Still do not block more than 1s\n\t\t\ttimeout(1000),\n\n\t\t\t// Destroy any opened window: we do not unload windows here because\n\t\t\t// there is a chance that the unload is veto'd or long running due\n\t\t\t// to a participant within the window. this is not wanted when we\n\t\t\t// are asked to kill the application.\n\t\t\t(async () => {\n\t\t\t\tfor (const window of getAllWindowsExcludingOffscreen()) {\n\t\t\t\t\tif (window && !window.isDestroyed()) {\n\t\t\t\t\t\tlet whenWindowClosed: Promise<void>;\n\t\t\t\t\t\tif (window.webContents && !window.webContents.isDestroyed()) {\n\t\t\t\t\t\t\twhenWindowClosed = new Promise(resolve => window.once('closed', resolve));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhenWindowClosed = Promise.resolve();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twindow.destroy();\n\t\t\t\t\t\tawait whenWindowClosed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})()\n\t\t]);\n\n\t\t// Now exit either after 1s or all windows destroyed\n\t\telectron.app.exit(code);\n\t}\n}\n"]}