{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/node/watcher/parcel/parcelWatcher.ts","vs/platform/files/node/watcher/parcel/parcelWatcher.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,aAAa,MAAM,iBAAiB,CAAC;AAC5C,OAAO,EAAE,QAAQ,EAAE,MAAM,IAAI,CAAC;AAC9B,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,IAAI,CAAC;AACrC,OAAO,EAAE,GAAG,EAAE,MAAM,mCAAmC,CAAC;AACxD,OAAO,EAAE,eAAe,EAAE,gBAAgB,EAAE,aAAa,EAAE,eAAe,EAAE,MAAM,qCAAqC,CAAC;AACxH,OAAO,EAAqB,uBAAuB,EAAE,MAAM,4CAA4C,CAAC;AACxG,OAAO,EAAE,cAAc,EAAE,MAAM,4CAA4C,CAAC;AAC5E,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,qCAAqC,CAAC;AACrE,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,eAAe,EAAE,MAAM,uCAAuC,CAAC;AAC7F,OAAO,EAAE,QAAQ,EAAiB,cAAc,EAAE,MAAM,oCAAoC,CAAC;AAC7F,OAAO,EAAE,WAAW,EAAE,MAAM,mBAAmB,CAAC;AAChD,OAAO,EAAE,iBAAiB,EAAE,MAAM,iDAAiD,CAAC;AACpF,OAAO,EAAE,YAAY,EAAE,MAAM,6CAA6C,CAAC;AAC3E,OAAO,EAAE,SAAS,EAAE,IAAI,EAAE,MAAM,oCAAoC,CAAC;AACrE,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,SAAS,EAAE,MAAM,wCAAwC,CAAC;AACzF,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,iCAAiC,CAAC;AAErE,OAAO,EAAE,cAAc,EAA0B,oBAAoB,EAAkC,UAAU,EAAsB,MAAM,4BAA4B,CAAC;AAC1K,OAAO,EAAE,UAAU,EAAE,eAAe,EAAe,YAAY,EAAE,MAAM,yCAAyC,CAAC;AAEjH,MAAM,OAAO,qBAAsB,SAAQ,UAAU;IASpD,IAAI,MAAM,KAAc,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAG9C,IAAI,OAAO,KAAc,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAO/C;IACC;;OAEG;IACM,KAAuB,EACvB,OAA+B;IACxC;;;OAGG;IACM,QAAgB;IACzB;;OAEG;IACM,KAAwB;IACjC;;OAEG;IACM,MAAkC,EAC1B,MAA2B;QAE5C,KAAK,EAAE,CAAC;QAjBC,UAAK,GAAL,KAAK,CAAkB;QACvB,YAAO,GAAP,OAAO,CAAwB;QAK/B,aAAQ,GAAR,QAAQ,CAAQ;QAIhB,UAAK,GAAL,KAAK,CAAmB;QAIxB,WAAM,GAAN,MAAM,CAA4B;QAC1B,WAAM,GAAN,MAAM,CAAqB;QApC5B,eAAU,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAmC,CAAC,CAAC;QACpF,cAAS,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;QAE1B,eAAU,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QACzD,cAAS,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;QAEnC,YAAO,GAAG,KAAK,CAAC;QAGhB,YAAO,GAAG,KAAK,CAAC;QAMP,kBAAa,GAAG,IAAI,GAAG,EAA8C,CAAC;QAyBtF,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACnH,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAEnH,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IAChE,CAAC;IAED,SAAS,CAAC,IAAY,EAAE,QAAuC;QAC9D,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,6EAA6E;QAE3G,IAAI,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACjD,IAAI,CAAC,aAAa,EAAE,CAAC;YACpB,aAAa,GAAG,IAAI,GAAG,EAAE,CAAC;YAC1B,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;QAC7C,CAAC;QAED,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAE5B,OAAO,YAAY,CAAC,GAAG,EAAE;YACxB,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACnD,IAAI,aAAa,EAAE,CAAC;gBACnB,aAAa,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;gBAE/B,IAAI,aAAa,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;oBAC9B,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBACjC,CAAC;YACF,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,IAAI,kBAAkB;QACrB,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC;IAChC,CAAC;IAED,gBAAgB,CAAC,IAAY,EAAE,MAAmB;QACjD,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnD,IAAI,aAAa,EAAE,CAAC;YACnB,KAAK,MAAM,YAAY,IAAI,aAAa,EAAE,CAAC;gBAC1C,YAAY,CAAC,MAAM,CAAC,CAAC;YACtB,CAAC;QACF,CAAC;IACF,CAAC;IAED,iBAAiB;QAChB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QAEpB,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;IACxB,CAAC;IAED,OAAO,CAAC,IAAY;QACnB,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAClD,OAAO,IAAI,CAAC,CAAC,4CAA4C;QAC1D,CAAC;QAED,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;IACrD,CAAC;IAED,OAAO,CAAC,IAAY;QACnB,OAAO,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAC/D,CAAC;IAED,KAAK,CAAC,IAAI,CAAC,WAAsC;QAChD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QAEpB,IAAI,CAAC;YACJ,MAAM,IAAI,CAAC,MAAM,EAAE,CAAC;QACrB,CAAC;gBAAS,CAAC;YACV,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,WAAW,EAAE,CAAC,CAAC;YACtC,IAAI,CAAC,OAAO,EAAE,CAAC;QAChB,CAAC;IACF,CAAC;CACD;AAED,MAAM,OAAO,aAAc,SAAQ,WAAW;aAErB,6CAAwC,GAAG,IAAI,GAAG,CACzE;QACC,CAAC,QAAQ,+BAAuB;QAChC,CAAC,QAAQ,iCAAyB;QAClC,CAAC,QAAQ,iCAAyB;KAClC,CAL8D,AAM/D,CAAC;aAEsB,wBAAmB,GAAqC;QAC/E,OAAO,EAAE,EAAE;QACX,QAAQ,EAAE;YACT,IAAI,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC,2FAA2F;SACpI;QACD,OAAO,EAAE,EAAE;KAL+B,AAM1C,CAAC;aAEsB,2BAAsB,GAAG,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,WAAjD,AAA4D,CAAC;IAM3G,IAAI,QAAQ,KAAK,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;IAElD,kDAAkD;IAClD,sDAAsD;IACtD,wDAAwD;IACxD,yCAAyC;IACzC,EAAE;IACF,oDAAoD;IACpD,oDAAoD;IACpD,qDAAqD;IACrD,uCAAuC;IACvC,EAAE;aACsB,+BAA0B,GAAG,EAAH,AAAK,CAAC;IAexD;QACC,KAAK,EAAE,CAAC;QAhCQ,gBAAW,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAsB,CAAC,CAAC;QACxE,eAAU,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;QAE5B,cAAS,GAAG,IAAI,GAAG,EAA0E,CAAC;QAe/G,6DAA6D;QAC7D,sDAAsD;QACrC,gCAA2B,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAe,CAChF;YACC,gBAAgB,EAAE,GAAG,EAAE,mDAAmD;YAC1E,aAAa,EAAE,GAAG,EAAK,wDAAwD;YAC/E,eAAe,EAAE,KAAK,CAAE,0DAA0D;SAClF,EACD,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,CAC5C,CAAC,CAAC;QAEK,sBAAiB,GAAG,KAAK,CAAC;QAKjC,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC1B,CAAC;IAEO,iBAAiB;QACxB,MAAM,mBAAmB,GAAG,CAAC,KAAc,EAAE,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;QAC9E,MAAM,oBAAoB,GAAG,CAAC,KAAc,EAAE,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;QAE/E,OAAO,CAAC,EAAE,CAAC,mBAAmB,EAAE,mBAAmB,CAAC,CAAC;QACrD,OAAO,CAAC,EAAE,CAAC,oBAAoB,EAAE,oBAAoB,CAAC,CAAC;QAEvD,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE;YAChC,OAAO,CAAC,GAAG,CAAC,mBAAmB,EAAE,mBAAmB,CAAC,CAAC;YACtD,OAAO,CAAC,GAAG,CAAC,oBAAoB,EAAE,oBAAoB,CAAC,CAAC;QACzD,CAAC,CAAC,CAAC,CAAC;IACL,CAAC;IAEkB,KAAK,CAAC,OAAO,CAAC,QAAkC;QAElE,oDAAoD;QACpD,QAAQ,GAAG,MAAM,IAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC;QAExD,uDAAuD;QACvD,MAAM,eAAe,GAA6B,EAAE,CAAC;QACrD,MAAM,cAAc,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC1D,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAChC,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC,CAAC;YACtE,IAAI,OAAO,IAAI,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,IAAI,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,eAAe,KAAK,OAAO,CAAC,eAAe,EAAE,CAAC;gBACxM,cAAc,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,eAAe;YAChD,CAAC;iBAAM,CAAC;gBACP,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,iBAAiB;YACjD,CAAC;QACF,CAAC;QAED,UAAU;QACV,IAAI,eAAe,CAAC,MAAM,EAAE,CAAC;YAC5B,IAAI,CAAC,KAAK,CAAC,8BAA8B,eAAe,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACrH,CAAC;QAED,IAAI,cAAc,CAAC,IAAI,EAAE,CAAC;YACzB,IAAI,CAAC,KAAK,CAAC,6BAA6B,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACvI,CAAC;QAED,8BAA8B;QAC9B,KAAK,MAAM,OAAO,IAAI,cAAc,EAAE,CAAC;YACtC,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;QAClC,CAAC;QAED,+BAA+B;QAC/B,KAAK,MAAM,OAAO,IAAI,eAAe,EAAE,CAAC;YACvC,IAAI,OAAO,CAAC,eAAe,EAAE,CAAC;gBAC7B,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,eAAe,CAAC,CAAC;YAC3D,CAAC;iBAAM,CAAC;gBACP,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YACnC,CAAC;QACF,CAAC;IACF,CAAC;IAEO,mBAAmB,CAAC,OAA+B;QAC1D,OAAO,OAAO,OAAO,CAAC,aAAa,KAAK,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAChH,CAAC;IAEO,gBAAgB,CAAC,IAAY;QACpC,OAAO,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,wBAAwB,CAAC;IACrE,CAAC;IAEO,KAAK,CAAC,YAAY,CAAC,OAA+B,EAAE,eAAuB,EAAE,QAAQ,GAAG,CAAC;QAChG,MAAM,GAAG,GAAG,IAAI,uBAAuB,EAAE,CAAC;QAE1C,MAAM,QAAQ,GAAG,IAAI,eAAe,EAAQ,CAAC;QAE7C,MAAM,YAAY,GAAG,UAAU,CAAC,MAAM,EAAE,EAAE,yBAAyB,CAAC,CAAC;QAErE,+BAA+B;QAC/B,MAAM,OAAO,GAA0B,IAAI,qBAAqB,CAC/D,QAAQ,CAAC,CAAC,EACV,OAAO,EACP,QAAQ,EACR,GAAG,CAAC,KAAK,EACT,IAAI,aAAa,CAAc,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,aAAa,CAAC,0BAA0B,CAAC,EAC5H,KAAK,IAAI,EAAE;YACV,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAElB,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;YACvB,OAAO,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;YAEzB,cAAc,CAAC,OAAO,EAAE,CAAC;YACzB,MAAM,QAAQ,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;QACrC,CAAC,CACD,CAAC;QACF,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,CAAC;QAE/D,gDAAgD;QAChD,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE,cAAc,EAAE,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAExF,IAAI,CAAC,KAAK,CAAC,sBAAsB,QAAQ,4BAA4B,eAAe,GAAG,CAAC,CAAC;QAEzF,IAAI,OAAO,GAAG,CAAC,CAAC;QAEhB,MAAM,cAAc,GAAG,IAAI,gBAAgB,CAAC,KAAK,IAAI,EAAE;YACtD,OAAO,EAAE,CAAC;YAEV,IAAI,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;gBACvC,OAAO;YACR,CAAC;YAED,gDAAgD;YAChD,MAAM,gBAAgB,GAAG,aAAa,CAAC;YACvC,IAAI,CAAC;gBACJ,IAAI,OAAO,GAAG,CAAC,EAAE,CAAC;oBACjB,MAAM,YAAY,GAAG,MAAM,gBAAgB,CAAC,cAAc,CAAC,QAAQ,EAAE,YAAY,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,aAAa,CAAC,sBAAsB,EAAE,CAAC,CAAC;oBAE5L,IAAI,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;wBACvC,OAAO;oBACR,CAAC;oBAED,uBAAuB;oBACvB,IAAI,CAAC,cAAc,CAAC,YAAY,EAAE,OAAO,EAAE,eAAe,EAAE,cAAc,CAAC,CAAC;gBAC7E,CAAC;gBAED,iDAAiD;gBACjD,MAAM,gBAAgB,CAAC,aAAa,CAAC,QAAQ,EAAE,YAAY,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,aAAa,CAAC,sBAAsB,EAAE,CAAC,CAAC;YACvK,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBAChB,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YACxC,CAAC;YAED,8DAA8D;YAC9D,IAAI,OAAO,KAAK,CAAC,EAAE,CAAC;gBACnB,QAAQ,CAAC,QAAQ,EAAE,CAAC;YACrB,CAAC;YAED,IAAI,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;gBACvC,OAAO;YACR,CAAC;YAED,sCAAsC;YACtC,cAAc,CAAC,QAAQ,EAAE,CAAC;QAC3B,CAAC,EAAE,eAAe,CAAC,CAAC;QACpB,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IAC5B,CAAC;IAEO,KAAK,CAAC,aAAa,CAAC,OAA+B,EAAE,QAAQ,GAAG,CAAC;QACxE,MAAM,GAAG,GAAG,IAAI,uBAAuB,EAAE,CAAC;QAE1C,MAAM,QAAQ,GAAG,IAAI,eAAe,EAA+C,CAAC;QAEpF,+BAA+B;QAC/B,MAAM,OAAO,GAA0B,IAAI,qBAAqB,CAC/D,QAAQ,CAAC,CAAC,EACV,OAAO,EACP,QAAQ,EACR,GAAG,CAAC,KAAK,EACT,IAAI,aAAa,CAAc,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,aAAa,CAAC,0BAA0B,CAAC,EAC5H,KAAK,IAAI,EAAE;YACV,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAElB,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;YACvB,OAAO,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;YAEzB,MAAM,eAAe,GAAG,MAAM,QAAQ,CAAC,CAAC,CAAC;YACzC,MAAM,eAAe,EAAE,WAAW,EAAE,CAAC;QACtC,CAAC,CACD,CAAC;QACF,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,CAAC;QAE/D,gDAAgD;QAChD,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE,cAAc,EAAE,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAExF,IAAI,CAAC;YACJ,MAAM,gBAAgB,GAAG,aAAa,CAAC;YACvC,MAAM,qBAAqB,GAAG,MAAM,gBAAgB,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,YAAY,EAAE,EAAE;gBAChG,IAAI,OAAO,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;oBAC3C,OAAO,CAAC,6BAA6B;gBACtC,CAAC;gBAED,iEAAiE;gBACjE,mEAAmE;gBACnE,oEAAoE;gBACpE,iCAAiC;gBACjC,IAAI,KAAK,EAAE,CAAC;oBACX,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;gBACxC,CAAC;gBAED,uBAAuB;gBACvB,IAAI,CAAC,cAAc,CAAC,YAAY,EAAE,OAAO,EAAE,eAAe,EAAE,cAAc,CAAC,CAAC;YAC7E,CAAC,EAAE;gBACF,OAAO,EAAE,aAAa,CAAC,sBAAsB;gBAC7C,MAAM,EAAE,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC;aAC5D,CAAC,CAAC;YAEH,IAAI,CAAC,KAAK,CAAC,sBAAsB,QAAQ,mBAAmB,aAAa,CAAC,sBAAsB,GAAG,CAAC,CAAC;YAErG,QAAQ,CAAC,QAAQ,CAAC,qBAAqB,CAAC,CAAC;QAC1C,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YAEvC,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YAE7B,OAAO,CAAC,iBAAiB,EAAE,CAAC;YAC5B,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACpC,CAAC;IACF,CAAC;IAEO,qBAAqB,CAAC,eAAyB;QACtD,MAAM,QAAQ,GAAG,CAAC,GAAG,eAAe,CAAC,CAAC;QAEtC,MAAM,kBAAkB,GAAG,aAAa,CAAC,mBAAmB,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAC/E,IAAI,KAAK,CAAC,OAAO,CAAC,kBAAkB,CAAC,EAAE,CAAC;YACvC,KAAK,MAAM,OAAO,IAAI,kBAAkB,EAAE,CAAC;gBAC1C,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,CAAC;oBACjC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBACxB,CAAC;YACF,CAAC;QACF,CAAC;QAED,OAAO,QAAQ,CAAC;IACjB,CAAC;IAEO,cAAc,CAAC,YAAmC,EAAE,OAA8B,EAAE,eAAwB,EAAE,cAAsB;QAC3I,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC/B,OAAO;QACR,CAAC;QAED,0DAA0D;QAC1D,0DAA0D;QAC1D,iCAAiC;QACjC,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,OAAO,CAAC,OAAO,EAAE,eAAe,EAAE,cAAc,CAAC,CAAC;QAErF,qBAAqB;QACrB,MAAM,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;QAElE,+CAA+C;QAC/C,KAAK,MAAM,aAAa,IAAI,cAAc,EAAE,CAAC;YAC5C,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACpC,CAAC;IACF,CAAC;IAEO,cAAc,CAAC,OAA8B,EAAE,YAAmC;QACzF,MAAM,MAAM,GAAkB,EAAE,CAAC;QAEjC,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,eAAe,EAAE,IAAI,YAAY,EAAE,CAAC;YAC5D,MAAM,IAAI,GAAG,aAAa,CAAC,wCAAwC,CAAC,GAAG,CAAC,eAAe,CAAE,CAAC;YAC1F,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;gBACzB,IAAI,CAAC,oBAAoB,CAAC,GAAG,IAAI,iCAAyB,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,mCAA2B,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,WAAW,IAAI,IAAI,EAAE,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;YAClK,CAAC;YAED,8BAA8B;YAC9B,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC5B,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;oBACzB,IAAI,CAAC,oBAAoB,CAAC,8BAA8B,IAAI,EAAE,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;gBAClF,CAAC;YACF,CAAC;iBAAM,CAAC;gBACP,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,OAAO,CAAC,OAAO,CAAC,aAAa,EAAE,CAAC,CAAC;YACrF,CAAC;QACF,CAAC;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAEO,kBAAkB,CAAC,YAA2B,EAAE,OAA8B;QAErF,6CAA6C;QAC7C,MAAM,eAAe,GAAG,cAAc,CAAC,YAAY,CAAC,CAAC;QAErD,8DAA8D;QAC9D,MAAM,EAAE,MAAM,EAAE,cAAc,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;QAE5F,uBAAuB;QACvB,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC;QAEzC,2BAA2B;QAC3B,IAAI,WAAW,EAAE,CAAC;YACjB,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;QACpC,CAAC;IACF,CAAC;IAEO,UAAU,CAAC,MAAqB,EAAE,OAA8B;QACvE,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACzB,OAAO;QACR,CAAC;QAED,qCAAqC;QACrC,MAAM,MAAM,GAAG,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAE7D,UAAU;QACV,IAAI,CAAC,MAAM,EAAE,CAAC;YACb,IAAI,CAAC,IAAI,CAAC,iFAAiF,MAAM,CAAC,MAAM,yBAAyB,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,iHAAiH,CAAC,CAAC;QAC9Q,CAAC;aAAM,CAAC;YACP,IAAI,IAAI,CAAC,2BAA2B,CAAC,OAAO,GAAG,CAAC,EAAE,CAAC;gBAClD,IAAI,CAAC,KAAK,CAAC,yFAAyF,IAAI,CAAC,2BAA2B,CAAC,OAAO,yBAAyB,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,iHAAiH,EAAE,OAAO,CAAC,CAAC;YAC3T,CAAC;QACF,CAAC;IACF,CAAC;IAEO,KAAK,CAAC,aAAa,CAAC,OAA+B;QAC1D,IAAI,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC;QAC5B,IAAI,eAAe,GAAG,KAAK,CAAC;QAC5B,IAAI,cAAc,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC;QAEzC,IAAI,CAAC;YAEJ,gCAAgC;YAChC,QAAQ,GAAG,MAAM,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAEjD,qCAAqC;YACrC,gDAAgD;YAChD,IAAI,OAAO,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;gBAC/B,QAAQ,GAAG,MAAM,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,IAAI,CAAC;YACzD,CAAC;YAED,+BAA+B;YAC/B,IAAI,OAAO,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;gBAC/B,cAAc,GAAG,QAAQ,CAAC,MAAM,CAAC;gBACjC,eAAe,GAAG,IAAI,CAAC;gBAEvB,IAAI,CAAC,KAAK,CAAC,0FAA0F,OAAO,CAAC,IAAI,WAAW,QAAQ,GAAG,CAAC,CAAC;YAC1I,CAAC;QACF,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,SAAS;QACV,CAAC;QAED,OAAO,EAAE,QAAQ,EAAE,eAAe,EAAE,cAAc,EAAE,CAAC;IACtD,CAAC;IAEO,eAAe,CAAC,MAA6B,EAAE,OAA+B,EAAE,eAAwB,EAAE,cAAsB;QACvI,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;YAE5B,qDAAqD;YACrD,IAAI,WAAW,EAAE,CAAC;gBACjB,KAAK,CAAC,IAAI,GAAG,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACvC,CAAC;YAED,qEAAqE;YACrE,2DAA2D;YAC3D,IAAI,SAAS,EAAE,CAAC;gBACf,IAAI,OAAO,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,CAAC,CAAC,kBAAkB;oBACjD,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBACpC,CAAC;YACF,CAAC;YAED,yDAAyD;YACzD,IAAI,eAAe,EAAE,CAAC;gBACrB,KAAK,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;YAC/D,CAAC;QACF,CAAC;IACF,CAAC;IAEO,YAAY,CAAC,MAAqB,EAAE,OAA8B;QACzE,MAAM,cAAc,GAAkB,EAAE,CAAC;QACzC,IAAI,WAAW,GAAG,KAAK,CAAC;QAExB,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,+FAA+F;QACvL,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;YAE5B,yDAAyD;YACzD,IAAI,OAAO,CAAC,kBAAkB,GAAG,CAAC,EAAE,CAAC;gBACpC,OAAO,CAAC,gBAAgB,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;YACxD,CAAC;YAED,YAAY;YACZ,WAAW,GAAG,KAAK,CAAC,IAAI,mCAA2B,IAAI,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,OAAO,CAAC,CAAC;YACtH,IAAI,UAAU,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE,CAAC;gBAC/B,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;oBACzB,IAAI,CAAC,oBAAoB,CAAC,0BAA0B,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;gBAC/F,CAAC;gBAED,SAAS;YACV,CAAC;YAED,UAAU;YACV,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;YAExC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC5B,CAAC;QAED,OAAO,EAAE,MAAM,EAAE,cAAc,EAAE,WAAW,EAAE,CAAC;IAChD,CAAC;IAEO,oBAAoB,CAAC,OAA8B;QAC1D,IAAI,CAAC,IAAI,CAAC,mDAAmD,EAAE,OAAO,CAAC,CAAC;QAExE,OAAO,CAAC,iBAAiB,EAAE,CAAC;QAC5B,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;IAC5C,CAAC;IAEO,iBAAiB,CAAC,KAAc,EAAE,OAAgC;QACzE,MAAM,GAAG,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;QAElC,sDAAsD;QACtD,qDAAqD;QACrD,oDAAoD;QACpD,uCAAuC;QACvC,sDAAsD;QACtD,IAAI,GAAG,CAAC,OAAO,CAAC,yBAAyB,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;YACnD,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBAC7B,IAAI,CAAC,KAAK,CAAC,gCAAgC,EAAE,OAAO,CAAC,CAAC;gBAEtD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;YAC/B,CAAC;QACF,CAAC;QAED,iDAAiD;QACjD,yDAAyD;aACpD,IAAI,GAAG,CAAC,OAAO,CAAC,gCAAgC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;YAC/D,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;QAC1B,CAAC;QAED,qDAAqD;QACrD,sDAAsD;QACtD,wDAAwD;aACnD,CAAC;YACL,IAAI,CAAC,KAAK,CAAC,qBAAqB,GAAG,aAAa,EAAE,OAAO,CAAC,CAAC;YAE3D,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC;QAChD,CAAC;IACF,CAAC;IAEQ,KAAK,CAAC,IAAI;QAClB,MAAM,KAAK,CAAC,IAAI,EAAE,CAAC;QAEnB,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACrC,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;QAClC,CAAC;IACF,CAAC;IAES,eAAe,CAAC,OAA8B,EAAE,KAAK,GAAG,GAAG;QAEpE,4CAA4C;QAC5C,0CAA0C;QAC1C,yCAAyC;QACzC,MAAM,SAAS,GAAG,IAAI,gBAAgB,CAAC,KAAK,IAAI,EAAE;YACjD,IAAI,OAAO,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;gBAC3C,OAAO,CAAC,6BAA6B;YACtC,CAAC;YAED,MAAM,cAAc,GAAG,IAAI,eAAe,EAAQ,CAAC;YACnD,IAAI,CAAC;gBAEJ,+CAA+C;gBAC/C,4CAA4C;gBAC5C,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC;gBAEnD,4CAA4C;gBAC5C,IAAI,OAAO,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC;oBACrC,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO,CAAC,eAAe,EAAE,OAAO,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC;gBACjG,CAAC;qBAAM,CAAC;oBACP,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC;gBACjE,CAAC;YACF,CAAC;oBAAS,CAAC;gBACV,cAAc,CAAC,QAAQ,EAAE,CAAC;YAC3B,CAAC;QACF,CAAC,EAAE,KAAK,CAAC,CAAC;QAEV,SAAS,CAAC,QAAQ,EAAE,CAAC;QACrB,OAAO,CAAC,KAAK,CAAC,uBAAuB,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,CAAC;IAClE,CAAC;IAEO,KAAK,CAAC,YAAY,CAAC,OAA8B,EAAE,WAA2B;QACrF,IAAI,CAAC,KAAK,CAAC,uBAAuB,EAAE,OAAO,CAAC,CAAC;QAE7C,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;QAEjE,IAAI,CAAC;YACJ,MAAM,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACjC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,CAAC,KAAK,CAAC,sCAAsC,cAAc,CAAC,KAAK,CAAC,EAAE,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;QAC5F,CAAC;IACF,CAAC;IAES,KAAK,CAAC,uBAAuB,CAAC,QAAkC,EAAE,aAAa,GAAG,IAAI;QAE/F,sDAAsD;QACtD,qDAAqD;QACrD,iBAAiB;QACjB,QAAQ,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAEnF,oEAAoE;QACpE,MAAM,wBAAwB,GAAG,IAAI,GAAG,EAA6E,CAAC;QACtH,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAChC,IAAI,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;gBACzC,SAAS,CAAC,mDAAmD;YAC9D,CAAC;YAGD,IAAI,sBAAsB,GAAG,wBAAwB,CAAC,GAAG,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;YACjF,IAAI,CAAC,sBAAsB,EAAE,CAAC;gBAC7B,sBAAsB,GAAG,IAAI,GAAG,EAAkC,CAAC;gBACnE,wBAAwB,CAAC,GAAG,CAAC,OAAO,CAAC,aAAa,EAAE,sBAAsB,CAAC,CAAC;YAC7E,CAAC;YAED,MAAM,IAAI,GAAG,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YACjD,IAAI,sBAAsB,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;gBACtC,IAAI,CAAC,KAAK,CAAC,kEAAkE,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;YAC/G,CAAC;YAED,sBAAsB,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC3C,CAAC;QAED,MAAM,kBAAkB,GAA6B,EAAE,CAAC;QAExD,KAAK,MAAM,sBAAsB,IAAI,wBAAwB,CAAC,MAAM,EAAE,EAAE,CAAC;YAExE,mDAAmD;YACnD,iDAAiD;YACjD,mDAAmD;YACnD,0CAA0C;YAC1C,EAAE;YACF,oDAAoD;YACpD,qDAAqD;YACrD,sDAAsD;YAEtD,MAAM,WAAW,GAAG,iBAAiB,CAAC,QAAQ,CAAyB,CAAC,OAAO,CAAC,CAAC;YAEjF,KAAK,MAAM,OAAO,IAAI,sBAAsB,CAAC,MAAM,EAAE,EAAE,CAAC;gBAEvD,oEAAoE;gBACpE,IAAI,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;oBAC1C,IAAI,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;wBACnC,IAAI,CAAC,KAAK,CAAC,kEAAkE,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;oBAC/G,CAAC;yBAAM,CAAC;wBACP,IAAI,CAAC;4BACJ,IAAI,CAAC,CAAC,MAAM,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,cAAc,EAAE,EAAE,CAAC;gCAC5D,IAAI,CAAC,KAAK,CAAC,oEAAoE,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;gCAEhH,SAAS;4BACV,CAAC;wBACF,CAAC;wBAAC,OAAO,KAAK,EAAE,CAAC;4BAChB,IAAI,CAAC,KAAK,CAAC,kEAAkE,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,YAAY,KAAK,GAAG,CAAC,CAAC;4BAEhI,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;4BAEnC,SAAS;wBACV,CAAC;oBACF,CAAC;gBACF,CAAC;gBAED,0BAA0B;gBAC1B,IAAI,aAAa,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;oBAC9D,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;oBAEnC,SAAS;gBACV,CAAC;gBAED,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;YACxC,CAAC;YAED,kBAAkB,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;QACnF,CAAC;QAED,OAAO,kBAAkB,CAAC;IAC3B,CAAC;IAEO,KAAK,CAAC,WAAW,CAAC,IAAY;QACrC,IAAI,CAAC;YACJ,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACvC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC;gBACzB,IAAI,CAAC,KAAK,CAAC,iEAAiE,IAAI,EAAE,CAAC,CAAC;gBAEpF,OAAO,KAAK,CAAC;YACd,CAAC;QACF,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,CAAC,KAAK,CAAC,mEAAmE,IAAI,YAAY,KAAK,GAAG,CAAC,CAAC;YAExG,OAAO,KAAK,CAAC;QACd,CAAC;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAED,SAAS,CAAC,IAAY,EAAE,QAA4D;QACnF,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACrC,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;gBACpB,SAAS,CAAC,6BAA6B;YACxC,CAAC;YAED,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC;gBAC5D,SAAS,CAAC,sCAAsC;YACjD,CAAC;YAED,IACC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC;gBACrB,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EACrB,CAAC;gBACF,SAAS,CAAC,8CAA8C;YACzD,CAAC;YAED,MAAM,WAAW,GAAG,IAAI,eAAe,EAAE,CAAC;YAE1C,WAAW,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,KAAK,EAAC,CAAC,EAAC,EAAE;gBACvD,MAAM,CAAC,CAAC,WAAW,CAAC,CAAC,oFAAoF;gBACzG,IAAI,WAAW,CAAC,UAAU,EAAE,CAAC;oBAC5B,OAAO;gBACR,CAAC;gBAED,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAC5B,CAAC,CAAC,CAAC,CAAC;YACJ,WAAW,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;YACjF,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC;YAE3E,OAAO,WAAW,CAAC;QACpB,CAAC;QAED,OAAO,SAAS,CAAC;IAClB,CAAC;IAES,KAAK,CAAC,OAAe,EAAE,OAA+B;QAC/D,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACzB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC;QACnG,CAAC;IACF,CAAC;IAES,IAAI,CAAC,OAAe,EAAE,OAA+B;QAC9D,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC;IAClG,CAAC;IAEO,KAAK,CAAC,OAAe,EAAE,OAAgC;QAC9D,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC;IAC1F,CAAC;IAEO,SAAS,CAAC,OAAe,EAAE,OAAgC;QAClE,OAAO,OAAO,CAAC,CAAC,CAAC,6BAA6B,OAAO,WAAW,OAAO,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,6BAA6B,OAAO,EAAE,CAAC;IAC1H,CAAC;IAED,IAAc,gBAAgB,KAAK,OAAO,IAAI,CAAC,CAAC,CAAC","file":"parcelWatcher.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport parcelWatcher from '@parcel/watcher';\nimport { promises } from 'fs';\nimport { tmpdir, homedir } from 'os';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { DeferredPromise, RunOnceScheduler, RunOnceWorker, ThrottledWorker } from '../../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../../../base/common/errorMessage.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { randomPath, isEqual, isEqualOrParent } from '../../../../../base/common/extpath.js';\nimport { GLOBSTAR, ParsedPattern, patternsEquals } from '../../../../../base/common/glob.js';\nimport { BaseWatcher } from '../baseWatcher.js';\nimport { TernarySearchTree } from '../../../../../base/common/ternarySearchTree.js';\nimport { normalizeNFC } from '../../../../../base/common/normalization.js';\nimport { normalize, join } from '../../../../../base/common/path.js';\nimport { isLinux, isMacintosh, isWindows } from '../../../../../base/common/platform.js';\nimport { Promises, realcase } from '../../../../../base/node/pfs.js';\nimport { FileChangeType, IFileChange } from '../../../common/files.js';\nimport { coalesceEvents, IRecursiveWatchRequest, parseWatcherPatterns, IRecursiveWatcherWithSubscribe, isFiltered, IWatcherErrorEvent } from '../../../common/watcher.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../../../base/common/lifecycle.js';\n\nexport class ParcelWatcherInstance extends Disposable {\n\n\tprivate readonly _onDidStop = this._register(new Emitter<{ joinRestart?: Promise<void> }>());\n\treadonly onDidStop = this._onDidStop.event;\n\n\tprivate readonly _onDidFail = this._register(new Emitter<void>());\n\treadonly onDidFail = this._onDidFail.event;\n\n\tprivate didFail = false;\n\tget failed(): boolean { return this.didFail; }\n\n\tprivate didStop = false;\n\tget stopped(): boolean { return this.didStop; }\n\n\tprivate readonly includes: ParsedPattern[] | undefined;\n\tprivate readonly excludes: ParsedPattern[] | undefined;\n\n\tprivate readonly subscriptions = new Map<string, Set<(change: IFileChange) => void>>();\n\n\tconstructor(\n\t\t/**\n\t\t * Signals when the watcher is ready to watch.\n\t\t */\n\t\treadonly ready: Promise<unknown>,\n\t\treadonly request: IRecursiveWatchRequest,\n\t\t/**\n\t\t * How often this watcher has been restarted in case of an unexpected\n\t\t * shutdown.\n\t\t */\n\t\treadonly restarts: number,\n\t\t/**\n\t\t * The cancellation token associated with the lifecycle of the watcher.\n\t\t */\n\t\treadonly token: CancellationToken,\n\t\t/**\n\t\t * An event aggregator to coalesce events and reduce duplicates.\n\t\t */\n\t\treadonly worker: RunOnceWorker<IFileChange>,\n\t\tprivate readonly stopFn: () => Promise<void>\n\t) {\n\t\tsuper();\n\n\t\tthis.includes = this.request.includes ? parseWatcherPatterns(this.request.path, this.request.includes) : undefined;\n\t\tthis.excludes = this.request.excludes ? parseWatcherPatterns(this.request.path, this.request.excludes) : undefined;\n\n\t\tthis._register(toDisposable(() => this.subscriptions.clear()));\n\t}\n\n\tsubscribe(path: string, callback: (change: IFileChange) => void): IDisposable {\n\t\tpath = URI.file(path).fsPath; // make sure to store the path in `fsPath` form to match it with events later\n\n\t\tlet subscriptions = this.subscriptions.get(path);\n\t\tif (!subscriptions) {\n\t\t\tsubscriptions = new Set();\n\t\t\tthis.subscriptions.set(path, subscriptions);\n\t\t}\n\n\t\tsubscriptions.add(callback);\n\n\t\treturn toDisposable(() => {\n\t\t\tconst subscriptions = this.subscriptions.get(path);\n\t\t\tif (subscriptions) {\n\t\t\t\tsubscriptions.delete(callback);\n\n\t\t\t\tif (subscriptions.size === 0) {\n\t\t\t\t\tthis.subscriptions.delete(path);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tget subscriptionsCount(): number {\n\t\treturn this.subscriptions.size;\n\t}\n\n\tnotifyFileChange(path: string, change: IFileChange): void {\n\t\tconst subscriptions = this.subscriptions.get(path);\n\t\tif (subscriptions) {\n\t\t\tfor (const subscription of subscriptions) {\n\t\t\t\tsubscription(change);\n\t\t\t}\n\t\t}\n\t}\n\n\tnotifyWatchFailed(): void {\n\t\tthis.didFail = true;\n\n\t\tthis._onDidFail.fire();\n\t}\n\n\tinclude(path: string): boolean {\n\t\tif (!this.includes || this.includes.length === 0) {\n\t\t\treturn true; // no specific includes defined, include all\n\t\t}\n\n\t\treturn this.includes.some(include => include(path));\n\t}\n\n\texclude(path: string): boolean {\n\t\treturn Boolean(this.excludes?.some(exclude => exclude(path)));\n\t}\n\n\tasync stop(joinRestart: Promise<void> | undefined): Promise<void> {\n\t\tthis.didStop = true;\n\n\t\ttry {\n\t\t\tawait this.stopFn();\n\t\t} finally {\n\t\t\tthis._onDidStop.fire({ joinRestart });\n\t\t\tthis.dispose();\n\t\t}\n\t}\n}\n\nexport class ParcelWatcher extends BaseWatcher implements IRecursiveWatcherWithSubscribe {\n\n\tprivate static readonly MAP_PARCEL_WATCHER_ACTION_TO_FILE_CHANGE = new Map<parcelWatcher.EventType, number>(\n\t\t[\n\t\t\t['create', FileChangeType.ADDED],\n\t\t\t['update', FileChangeType.UPDATED],\n\t\t\t['delete', FileChangeType.DELETED]\n\t\t]\n\t);\n\n\tprivate static readonly PREDEFINED_EXCLUDES: { [platform: string]: string[] } = {\n\t\t'win32': [],\n\t\t'darwin': [\n\t\t\tjoin(homedir(), 'Library', 'Containers') // Triggers access dialog from macOS 14 (https://github.com/microsoft/vscode/issues/208105)\n\t\t],\n\t\t'linux': []\n\t};\n\n\tprivate static readonly PARCEL_WATCHER_BACKEND = isWindows ? 'windows' : isLinux ? 'inotify' : 'fs-events';\n\n\tprivate readonly _onDidError = this._register(new Emitter<IWatcherErrorEvent>());\n\treadonly onDidError = this._onDidError.event;\n\n\tprivate readonly _watchers = new Map<string /* path */ | number /* correlation ID */, ParcelWatcherInstance>();\n\tget watchers() { return this._watchers.values(); }\n\n\t// A delay for collecting file changes from Parcel\n\t// before collecting them for coalescing and emitting.\n\t// Parcel internally uses 50ms as delay, so we use 75ms,\n\t// to schedule sufficiently after Parcel.\n\t//\n\t// Note: since Parcel 2.0.7, the very first event is\n\t// emitted without delay if no events occured over a\n\t// duration of 500ms. But we always want to aggregate\n\t// events to apply our coleasing logic.\n\t//\n\tprivate static readonly FILE_CHANGES_HANDLER_DELAY = 75;\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesEmitter = this._register(new ThrottledWorker<IFileChange>(\n\t\t{\n\t\t\tmaxWorkChunkSize: 500,\t// only process up to 500 changes at once before...\n\t\t\tthrottleDelay: 200,\t  \t// ...resting for 200ms until we process events again...\n\t\t\tmaxBufferedWork: 30000 \t// ...but never buffering more than 30000 events in memory\n\t\t},\n\t\tevents => this._onDidChangeFile.fire(events)\n\t));\n\n\tprivate enospcErrorLogged = false;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tconst onUncaughtException = (error: unknown) => this.onUnexpectedError(error);\n\t\tconst onUnhandledRejection = (error: unknown) => this.onUnexpectedError(error);\n\n\t\tprocess.on('uncaughtException', onUncaughtException);\n\t\tprocess.on('unhandledRejection', onUnhandledRejection);\n\n\t\tthis._register(toDisposable(() => {\n\t\t\tprocess.off('uncaughtException', onUncaughtException);\n\t\t\tprocess.off('unhandledRejection', onUnhandledRejection);\n\t\t}));\n\t}\n\n\tprotected override async doWatch(requests: IRecursiveWatchRequest[]): Promise<void> {\n\n\t\t// Figure out duplicates to remove from the requests\n\t\trequests = await this.removeDuplicateRequests(requests);\n\n\t\t// Figure out which watchers to start and which to stop\n\t\tconst requestsToStart: IRecursiveWatchRequest[] = [];\n\t\tconst watchersToStop = new Set(Array.from(this.watchers));\n\t\tfor (const request of requests) {\n\t\t\tconst watcher = this._watchers.get(this.requestToWatcherKey(request));\n\t\t\tif (watcher && patternsEquals(watcher.request.excludes, request.excludes) && patternsEquals(watcher.request.includes, request.includes) && watcher.request.pollingInterval === request.pollingInterval) {\n\t\t\t\twatchersToStop.delete(watcher); // keep watcher\n\t\t\t} else {\n\t\t\t\trequestsToStart.push(request); // start watching\n\t\t\t}\n\t\t}\n\n\t\t// Logging\n\t\tif (requestsToStart.length) {\n\t\t\tthis.trace(`Request to start watching: ${requestsToStart.map(request => this.requestToString(request)).join(',')}`);\n\t\t}\n\n\t\tif (watchersToStop.size) {\n\t\t\tthis.trace(`Request to stop watching: ${Array.from(watchersToStop).map(watcher => this.requestToString(watcher.request)).join(',')}`);\n\t\t}\n\n\t\t// Stop watching as instructed\n\t\tfor (const watcher of watchersToStop) {\n\t\t\tawait this.stopWatching(watcher);\n\t\t}\n\n\t\t// Start watching as instructed\n\t\tfor (const request of requestsToStart) {\n\t\t\tif (request.pollingInterval) {\n\t\t\t\tawait this.startPolling(request, request.pollingInterval);\n\t\t\t} else {\n\t\t\t\tawait this.startWatching(request);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate requestToWatcherKey(request: IRecursiveWatchRequest): string | number {\n\t\treturn typeof request.correlationId === 'number' ? request.correlationId : this.pathToWatcherKey(request.path);\n\t}\n\n\tprivate pathToWatcherKey(path: string): string {\n\t\treturn isLinux ? path : path.toLowerCase() /* ignore path casing */;\n\t}\n\n\tprivate async startPolling(request: IRecursiveWatchRequest, pollingInterval: number, restarts = 0): Promise<void> {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst instance = new DeferredPromise<void>();\n\n\t\tconst snapshotFile = randomPath(tmpdir(), 'vscode-watcher-snapshot');\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: ParcelWatcherInstance = new ParcelWatcherInstance(\n\t\t\tinstance.p,\n\t\t\trequest,\n\t\t\trestarts,\n\t\t\tcts.token,\n\t\t\tnew RunOnceWorker<IFileChange>(events => this.handleParcelEvents(events, watcher), ParcelWatcher.FILE_CHANGES_HANDLER_DELAY),\n\t\t\tasync () => {\n\t\t\t\tcts.dispose(true);\n\n\t\t\t\twatcher.worker.flush();\n\t\t\t\twatcher.worker.dispose();\n\n\t\t\t\tpollingWatcher.dispose();\n\t\t\t\tawait promises.unlink(snapshotFile);\n\t\t\t}\n\t\t);\n\t\tthis._watchers.set(this.requestToWatcherKey(request), watcher);\n\n\t\t// Path checks for symbolic links / wrong casing\n\t\tconst { realPath, realPathDiffers, realPathLength } = await this.normalizePath(request);\n\n\t\tthis.trace(`Started watching: '${realPath}' with polling interval '${pollingInterval}'`);\n\n\t\tlet counter = 0;\n\n\t\tconst pollingWatcher = new RunOnceScheduler(async () => {\n\t\t\tcounter++;\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// We already ran before, check for events since\n\t\t\tconst parcelWatcherLib = parcelWatcher;\n\t\t\ttry {\n\t\t\t\tif (counter > 1) {\n\t\t\t\t\tconst parcelEvents = await parcelWatcherLib.getEventsSince(realPath, snapshotFile, { ignore: this.addPredefinedExcludes(request.excludes), backend: ParcelWatcher.PARCEL_WATCHER_BACKEND });\n\n\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle & emit events\n\t\t\t\t\tthis.onParcelEvents(parcelEvents, watcher, realPathDiffers, realPathLength);\n\t\t\t\t}\n\n\t\t\t\t// Store a snapshot of files to the snapshot file\n\t\t\t\tawait parcelWatcherLib.writeSnapshot(realPath, snapshotFile, { ignore: this.addPredefinedExcludes(request.excludes), backend: ParcelWatcher.PARCEL_WATCHER_BACKEND });\n\t\t\t} catch (error) {\n\t\t\t\tthis.onUnexpectedError(error, request);\n\t\t\t}\n\n\t\t\t// Signal we are ready now when the first snapshot was written\n\t\t\tif (counter === 1) {\n\t\t\t\tinstance.complete();\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Schedule again at the next interval\n\t\t\tpollingWatcher.schedule();\n\t\t}, pollingInterval);\n\t\tpollingWatcher.schedule(0);\n\t}\n\n\tprivate async startWatching(request: IRecursiveWatchRequest, restarts = 0): Promise<void> {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst instance = new DeferredPromise<parcelWatcher.AsyncSubscription | undefined>();\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: ParcelWatcherInstance = new ParcelWatcherInstance(\n\t\t\tinstance.p,\n\t\t\trequest,\n\t\t\trestarts,\n\t\t\tcts.token,\n\t\t\tnew RunOnceWorker<IFileChange>(events => this.handleParcelEvents(events, watcher), ParcelWatcher.FILE_CHANGES_HANDLER_DELAY),\n\t\t\tasync () => {\n\t\t\t\tcts.dispose(true);\n\n\t\t\t\twatcher.worker.flush();\n\t\t\t\twatcher.worker.dispose();\n\n\t\t\t\tconst watcherInstance = await instance.p;\n\t\t\t\tawait watcherInstance?.unsubscribe();\n\t\t\t}\n\t\t);\n\t\tthis._watchers.set(this.requestToWatcherKey(request), watcher);\n\n\t\t// Path checks for symbolic links / wrong casing\n\t\tconst { realPath, realPathDiffers, realPathLength } = await this.normalizePath(request);\n\n\t\ttry {\n\t\t\tconst parcelWatcherLib = parcelWatcher;\n\t\t\tconst parcelWatcherInstance = await parcelWatcherLib.subscribe(realPath, (error, parcelEvents) => {\n\t\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\t\treturn; // return early when disposed\n\t\t\t\t}\n\n\t\t\t\t// In any case of an error, treat this like a unhandled exception\n\t\t\t\t// that might require the watcher to restart. We do not really know\n\t\t\t\t// the state of parcel at this point and as such will try to restart\n\t\t\t\t// up to our maximum of restarts.\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.onUnexpectedError(error, request);\n\t\t\t\t}\n\n\t\t\t\t// Handle & emit events\n\t\t\t\tthis.onParcelEvents(parcelEvents, watcher, realPathDiffers, realPathLength);\n\t\t\t}, {\n\t\t\t\tbackend: ParcelWatcher.PARCEL_WATCHER_BACKEND,\n\t\t\t\tignore: this.addPredefinedExcludes(watcher.request.excludes)\n\t\t\t});\n\n\t\t\tthis.trace(`Started watching: '${realPath}' with backend '${ParcelWatcher.PARCEL_WATCHER_BACKEND}'`);\n\n\t\t\tinstance.complete(parcelWatcherInstance);\n\t\t} catch (error) {\n\t\t\tthis.onUnexpectedError(error, request);\n\n\t\t\tinstance.complete(undefined);\n\n\t\t\twatcher.notifyWatchFailed();\n\t\t\tthis._onDidWatchFail.fire(request);\n\t\t}\n\t}\n\n\tprivate addPredefinedExcludes(initialExcludes: string[]): string[] {\n\t\tconst excludes = [...initialExcludes];\n\n\t\tconst predefinedExcludes = ParcelWatcher.PREDEFINED_EXCLUDES[process.platform];\n\t\tif (Array.isArray(predefinedExcludes)) {\n\t\t\tfor (const exclude of predefinedExcludes) {\n\t\t\t\tif (!excludes.includes(exclude)) {\n\t\t\t\t\texcludes.push(exclude);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn excludes;\n\t}\n\n\tprivate onParcelEvents(parcelEvents: parcelWatcher.Event[], watcher: ParcelWatcherInstance, realPathDiffers: boolean, realPathLength: number): void {\n\t\tif (parcelEvents.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Normalize events: handle NFC normalization and symlinks\n\t\t// It is important to do this before checking for includes\n\t\t// to check on the original path.\n\t\tthis.normalizeEvents(parcelEvents, watcher.request, realPathDiffers, realPathLength);\n\n\t\t// Check for includes\n\t\tconst includedEvents = this.handleIncludes(watcher, parcelEvents);\n\n\t\t// Add to event aggregator for later processing\n\t\tfor (const includedEvent of includedEvents) {\n\t\t\twatcher.worker.work(includedEvent);\n\t\t}\n\t}\n\n\tprivate handleIncludes(watcher: ParcelWatcherInstance, parcelEvents: parcelWatcher.Event[]): IFileChange[] {\n\t\tconst events: IFileChange[] = [];\n\n\t\tfor (const { path, type: parcelEventType } of parcelEvents) {\n\t\t\tconst type = ParcelWatcher.MAP_PARCEL_WATCHER_ACTION_TO_FILE_CHANGE.get(parcelEventType)!;\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(`${type === FileChangeType.ADDED ? '[ADDED]' : type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${path}`, watcher.request);\n\t\t\t}\n\n\t\t\t// Apply include filter if any\n\t\t\tif (!watcher.include(path)) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(` >> ignored (not included) ${path}`, watcher.request);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tevents.push({ type, resource: URI.file(path), cId: watcher.request.correlationId });\n\t\t\t}\n\t\t}\n\n\t\treturn events;\n\t}\n\n\tprivate handleParcelEvents(parcelEvents: IFileChange[], watcher: ParcelWatcherInstance): void {\n\n\t\t// Coalesce events: merge events of same kind\n\t\tconst coalescedEvents = coalesceEvents(parcelEvents);\n\n\t\t// Filter events: check for specific events we want to exclude\n\t\tconst { events: filteredEvents, rootDeleted } = this.filterEvents(coalescedEvents, watcher);\n\n\t\t// Broadcast to clients\n\t\tthis.emitEvents(filteredEvents, watcher);\n\n\t\t// Handle root path deletes\n\t\tif (rootDeleted) {\n\t\t\tthis.onWatchedPathDeleted(watcher);\n\t\t}\n\t}\n\n\tprivate emitEvents(events: IFileChange[], watcher: ParcelWatcherInstance): void {\n\t\tif (events.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Broadcast to clients via throttler\n\t\tconst worked = this.throttledFileChangesEmitter.work(events);\n\n\t\t// Logging\n\t\tif (!worked) {\n\t\t\tthis.warn(`started ignoring events due to too many file change events at once (incoming: ${events.length}, most recent change: ${events[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t} else {\n\t\t\tif (this.throttledFileChangesEmitter.pending > 0) {\n\t\t\t\tthis.trace(`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${events[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`, watcher);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async normalizePath(request: IRecursiveWatchRequest): Promise<{ realPath: string; realPathDiffers: boolean; realPathLength: number }> {\n\t\tlet realPath = request.path;\n\t\tlet realPathDiffers = false;\n\t\tlet realPathLength = request.path.length;\n\n\t\ttry {\n\n\t\t\t// First check for symbolic link\n\t\t\trealPath = await Promises.realpath(request.path);\n\n\t\t\t// Second check for casing difference\n\t\t\t// Note: this will be a no-op on Linux platforms\n\t\t\tif (request.path === realPath) {\n\t\t\t\trealPath = await realcase(request.path) ?? request.path;\n\t\t\t}\n\n\t\t\t// Correct watch path as needed\n\t\t\tif (request.path !== realPath) {\n\t\t\t\trealPathLength = realPath.length;\n\t\t\t\trealPathDiffers = true;\n\n\t\t\t\tthis.trace(`correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${request.path}, real: ${realPath})`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn { realPath, realPathDiffers, realPathLength };\n\t}\n\n\tprivate normalizeEvents(events: parcelWatcher.Event[], request: IRecursiveWatchRequest, realPathDiffers: boolean, realPathLength: number): void {\n\t\tfor (const event of events) {\n\n\t\t\t// Mac uses NFD unicode form on disk, but we want NFC\n\t\t\tif (isMacintosh) {\n\t\t\t\tevent.path = normalizeNFC(event.path);\n\t\t\t}\n\n\t\t\t// Workaround for https://github.com/parcel-bundler/watcher/issues/68\n\t\t\t// where watching root drive letter adds extra backslashes.\n\t\t\tif (isWindows) {\n\t\t\t\tif (request.path.length <= 3) { // for ex. c:, C:\\\n\t\t\t\t\tevent.path = normalize(event.path);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Convert paths back to original form in case it differs\n\t\t\tif (realPathDiffers) {\n\t\t\t\tevent.path = request.path + event.path.substr(realPathLength);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate filterEvents(events: IFileChange[], watcher: ParcelWatcherInstance): { events: IFileChange[]; rootDeleted?: boolean } {\n\t\tconst filteredEvents: IFileChange[] = [];\n\t\tlet rootDeleted = false;\n\n\t\tconst filter = this.isCorrelated(watcher.request) ? watcher.request.filter : undefined; // filtering is only enabled when correlating because watchers are otherwise potentially reused\n\t\tfor (const event of events) {\n\n\t\t\t// Emit to instance subscriptions if any before filtering\n\t\t\tif (watcher.subscriptionsCount > 0) {\n\t\t\t\twatcher.notifyFileChange(event.resource.fsPath, event);\n\t\t\t}\n\n\t\t\t// Filtering\n\t\t\trootDeleted = event.type === FileChangeType.DELETED && isEqual(event.resource.fsPath, watcher.request.path, !isLinux);\n\t\t\tif (isFiltered(event, filter)) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(` >> ignored (filtered) ${event.resource.fsPath}`, watcher.request);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Logging\n\t\t\tthis.traceEvent(event, watcher.request);\n\n\t\t\tfilteredEvents.push(event);\n\t\t}\n\n\t\treturn { events: filteredEvents, rootDeleted };\n\t}\n\n\tprivate onWatchedPathDeleted(watcher: ParcelWatcherInstance): void {\n\t\tthis.warn('Watcher shutdown because watched path got deleted', watcher);\n\n\t\twatcher.notifyWatchFailed();\n\t\tthis._onDidWatchFail.fire(watcher.request);\n\t}\n\n\tprivate onUnexpectedError(error: unknown, request?: IRecursiveWatchRequest): void {\n\t\tconst msg = toErrorMessage(error);\n\n\t\t// Specially handle ENOSPC errors that can happen when\n\t\t// the watcher consumes so many file descriptors that\n\t\t// we are running into a limit. We only want to warn\n\t\t// once in this case to avoid log spam.\n\t\t// See https://github.com/microsoft/vscode/issues/7950\n\t\tif (msg.indexOf('No space left on device') !== -1) {\n\t\t\tif (!this.enospcErrorLogged) {\n\t\t\t\tthis.error('Inotify limit reached (ENOSPC)', request);\n\n\t\t\t\tthis.enospcErrorLogged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Version 2.5.1 introduces 3 new errors on macOS\n\t\t// via https://github.dev/parcel-bundler/watcher/pull/196\n\t\telse if (msg.indexOf('File system must be re-scanned') !== -1) {\n\t\t\tthis.error(msg, request);\n\t\t}\n\n\t\t// Any other error is unexpected and we should try to\n\t\t// restart the watcher as a result to get into healthy\n\t\t// state again if possible and if not attempted too much\n\t\telse {\n\t\t\tthis.error(`Unexpected error: ${msg} (EUNKNOWN)`, request);\n\n\t\t\tthis._onDidError.fire({ request, error: msg });\n\t\t}\n\t}\n\n\toverride async stop(): Promise<void> {\n\t\tawait super.stop();\n\n\t\tfor (const watcher of this.watchers) {\n\t\t\tawait this.stopWatching(watcher);\n\t\t}\n\t}\n\n\tprotected restartWatching(watcher: ParcelWatcherInstance, delay = 800): void {\n\n\t\t// Restart watcher delayed to accomodate for\n\t\t// changes on disk that have triggered the\n\t\t// need for a restart in the first place.\n\t\tconst scheduler = new RunOnceScheduler(async () => {\n\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\treturn; // return early when disposed\n\t\t\t}\n\n\t\t\tconst restartPromise = new DeferredPromise<void>();\n\t\t\ttry {\n\n\t\t\t\t// Await the watcher having stopped, as this is\n\t\t\t\t// needed to properly re-watch the same path\n\t\t\t\tawait this.stopWatching(watcher, restartPromise.p);\n\n\t\t\t\t// Start watcher again counting the restarts\n\t\t\t\tif (watcher.request.pollingInterval) {\n\t\t\t\t\tawait this.startPolling(watcher.request, watcher.request.pollingInterval, watcher.restarts + 1);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.startWatching(watcher.request, watcher.restarts + 1);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\trestartPromise.complete();\n\t\t\t}\n\t\t}, delay);\n\n\t\tscheduler.schedule();\n\t\twatcher.token.onCancellationRequested(() => scheduler.dispose());\n\t}\n\n\tprivate async stopWatching(watcher: ParcelWatcherInstance, joinRestart?: Promise<void>): Promise<void> {\n\t\tthis.trace(`stopping file watcher`, watcher);\n\n\t\tthis._watchers.delete(this.requestToWatcherKey(watcher.request));\n\n\t\ttry {\n\t\t\tawait watcher.stop(joinRestart);\n\t\t} catch (error) {\n\t\t\tthis.error(`Unexpected error stopping watcher: ${toErrorMessage(error)}`, watcher.request);\n\t\t}\n\t}\n\n\tprotected async removeDuplicateRequests(requests: IRecursiveWatchRequest[], validatePaths = true): Promise<IRecursiveWatchRequest[]> {\n\n\t\t// Sort requests by path length to have shortest first\n\t\t// to have a way to prevent children to be watched if\n\t\t// parents exist.\n\t\trequests.sort((requestA, requestB) => requestA.path.length - requestB.path.length);\n\n\t\t// Ignore requests for the same paths that have the same correlation\n\t\tconst mapCorrelationtoRequests = new Map<number | undefined /* correlation */, Map<string, IRecursiveWatchRequest>>();\n\t\tfor (const request of requests) {\n\t\t\tif (request.excludes.includes(GLOBSTAR)) {\n\t\t\t\tcontinue; // path is ignored entirely (via `**` glob exclude)\n\t\t\t}\n\n\n\t\t\tlet requestsForCorrelation = mapCorrelationtoRequests.get(request.correlationId);\n\t\t\tif (!requestsForCorrelation) {\n\t\t\t\trequestsForCorrelation = new Map<string, IRecursiveWatchRequest>();\n\t\t\t\tmapCorrelationtoRequests.set(request.correlationId, requestsForCorrelation);\n\t\t\t}\n\n\t\t\tconst path = this.pathToWatcherKey(request.path);\n\t\t\tif (requestsForCorrelation.has(path)) {\n\t\t\t\tthis.trace(`ignoring a request for watching who's path is already watched: ${this.requestToString(request)}`);\n\t\t\t}\n\n\t\t\trequestsForCorrelation.set(path, request);\n\t\t}\n\n\t\tconst normalizedRequests: IRecursiveWatchRequest[] = [];\n\n\t\tfor (const requestsForCorrelation of mapCorrelationtoRequests.values()) {\n\n\t\t\t// Only consider requests for watching that are not\n\t\t\t// a child of an existing request path to prevent\n\t\t\t// duplication. In addition, drop any request where\n\t\t\t// everything is excluded (via `**` glob).\n\t\t\t//\n\t\t\t// However, allow explicit requests to watch folders\n\t\t\t// that are symbolic links because the Parcel watcher\n\t\t\t// does not allow to recursively watch symbolic links.\n\n\t\t\tconst requestTrie = TernarySearchTree.forPaths<IRecursiveWatchRequest>(!isLinux);\n\n\t\t\tfor (const request of requestsForCorrelation.values()) {\n\n\t\t\t\t// Check for overlapping request paths (but preserve symbolic links)\n\t\t\t\tif (requestTrie.findSubstr(request.path)) {\n\t\t\t\t\tif (requestTrie.has(request.path)) {\n\t\t\t\t\t\tthis.trace(`ignoring a request for watching who's path is already watched: ${this.requestToString(request)}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!(await promises.lstat(request.path)).isSymbolicLink()) {\n\t\t\t\t\t\t\t\tthis.trace(`ignoring a request for watching who's parent is already watched: ${this.requestToString(request)}`);\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthis.trace(`ignoring a request for watching who's lstat failed to resolve: ${this.requestToString(request)} (error: ${error})`);\n\n\t\t\t\t\t\t\tthis._onDidWatchFail.fire(request);\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Check for invalid paths\n\t\t\t\tif (validatePaths && !(await this.isPathValid(request.path))) {\n\t\t\t\t\tthis._onDidWatchFail.fire(request);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trequestTrie.set(request.path, request);\n\t\t\t}\n\n\t\t\tnormalizedRequests.push(...Array.from(requestTrie).map(([, request]) => request));\n\t\t}\n\n\t\treturn normalizedRequests;\n\t}\n\n\tprivate async isPathValid(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst stat = await promises.stat(path);\n\t\t\tif (!stat.isDirectory()) {\n\t\t\t\tthis.trace(`ignoring a path for watching that is a file and not a folder: ${path}`);\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.trace(`ignoring a path for watching who's stat info failed to resolve: ${path} (error: ${error})`);\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsubscribe(path: string, callback: (error: true | null, change?: IFileChange) => void): IDisposable | undefined {\n\t\tfor (const watcher of this.watchers) {\n\t\t\tif (watcher.failed) {\n\t\t\t\tcontinue; // watcher has already failed\n\t\t\t}\n\n\t\t\tif (!isEqualOrParent(path, watcher.request.path, !isLinux)) {\n\t\t\t\tcontinue; // watcher does not consider this path\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\twatcher.exclude(path) ||\n\t\t\t\t!watcher.include(path)\n\t\t\t) {\n\t\t\t\tcontinue; // parcel instance does not consider this path\n\t\t\t}\n\n\t\t\tconst disposables = new DisposableStore();\n\n\t\t\tdisposables.add(Event.once(watcher.onDidStop)(async e => {\n\t\t\t\tawait e.joinRestart; // if we are restarting, await that so that we can possibly reuse this watcher again\n\t\t\t\tif (disposables.isDisposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcallback(true /* error */);\n\t\t\t}));\n\t\t\tdisposables.add(Event.once(watcher.onDidFail)(() => callback(true /* error */)));\n\t\t\tdisposables.add(watcher.subscribe(path, change => callback(null, change)));\n\n\t\t\treturn disposables;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprotected trace(message: string, watcher?: ParcelWatcherInstance): void {\n\t\tif (this.verboseLogging) {\n\t\t\tthis._onDidLogMessage.fire({ type: 'trace', message: this.toMessage(message, watcher?.request) });\n\t\t}\n\t}\n\n\tprotected warn(message: string, watcher?: ParcelWatcherInstance) {\n\t\tthis._onDidLogMessage.fire({ type: 'warn', message: this.toMessage(message, watcher?.request) });\n\t}\n\n\tprivate error(message: string, request?: IRecursiveWatchRequest) {\n\t\tthis._onDidLogMessage.fire({ type: 'error', message: this.toMessage(message, request) });\n\t}\n\n\tprivate toMessage(message: string, request?: IRecursiveWatchRequest): string {\n\t\treturn request ? `[File Watcher ('parcel')] ${message} (path: ${request.path})` : `[File Watcher ('parcel')] ${message}`;\n\t}\n\n\tprotected get recursiveWatcher() { return this; }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport parcelWatcher from '@parcel/watcher';\nimport { promises } from 'fs';\nimport { tmpdir, homedir } from 'os';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { DeferredPromise, RunOnceScheduler, RunOnceWorker, ThrottledWorker } from '../../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../../../base/common/errorMessage.js';\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { randomPath, isEqual, isEqualOrParent } from '../../../../../base/common/extpath.js';\nimport { GLOBSTAR, ParsedPattern, patternsEquals } from '../../../../../base/common/glob.js';\nimport { BaseWatcher } from '../baseWatcher.js';\nimport { TernarySearchTree } from '../../../../../base/common/ternarySearchTree.js';\nimport { normalizeNFC } from '../../../../../base/common/normalization.js';\nimport { normalize, join } from '../../../../../base/common/path.js';\nimport { isLinux, isMacintosh, isWindows } from '../../../../../base/common/platform.js';\nimport { Promises, realcase } from '../../../../../base/node/pfs.js';\nimport { FileChangeType, IFileChange } from '../../../common/files.js';\nimport { coalesceEvents, IRecursiveWatchRequest, parseWatcherPatterns, IRecursiveWatcherWithSubscribe, isFiltered, IWatcherErrorEvent } from '../../../common/watcher.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../../../base/common/lifecycle.js';\n\nexport class ParcelWatcherInstance extends Disposable {\n\n\tprivate readonly _onDidStop = this._register(new Emitter<{ joinRestart?: Promise<void> }>());\n\treadonly onDidStop = this._onDidStop.event;\n\n\tprivate readonly _onDidFail = this._register(new Emitter<void>());\n\treadonly onDidFail = this._onDidFail.event;\n\n\tprivate didFail = false;\n\tget failed(): boolean { return this.didFail; }\n\n\tprivate didStop = false;\n\tget stopped(): boolean { return this.didStop; }\n\n\tprivate readonly includes: ParsedPattern[] | undefined;\n\tprivate readonly excludes: ParsedPattern[] | undefined;\n\n\tprivate readonly subscriptions = new Map<string, Set<(change: IFileChange) => void>>();\n\n\tconstructor(\n\t\t/**\n\t\t * Signals when the watcher is ready to watch.\n\t\t */\n\t\treadonly ready: Promise<unknown>,\n\t\treadonly request: IRecursiveWatchRequest,\n\t\t/**\n\t\t * How often this watcher has been restarted in case of an unexpected\n\t\t * shutdown.\n\t\t */\n\t\treadonly restarts: number,\n\t\t/**\n\t\t * The cancellation token associated with the lifecycle of the watcher.\n\t\t */\n\t\treadonly token: CancellationToken,\n\t\t/**\n\t\t * An event aggregator to coalesce events and reduce duplicates.\n\t\t */\n\t\treadonly worker: RunOnceWorker<IFileChange>,\n\t\tprivate readonly stopFn: () => Promise<void>\n\t) {\n\t\tsuper();\n\n\t\tthis.includes = this.request.includes ? parseWatcherPatterns(this.request.path, this.request.includes) : undefined;\n\t\tthis.excludes = this.request.excludes ? parseWatcherPatterns(this.request.path, this.request.excludes) : undefined;\n\n\t\tthis._register(toDisposable(() => this.subscriptions.clear()));\n\t}\n\n\tsubscribe(path: string, callback: (change: IFileChange) => void): IDisposable {\n\t\tpath = URI.file(path).fsPath; // make sure to store the path in `fsPath` form to match it with events later\n\n\t\tlet subscriptions = this.subscriptions.get(path);\n\t\tif (!subscriptions) {\n\t\t\tsubscriptions = new Set();\n\t\t\tthis.subscriptions.set(path, subscriptions);\n\t\t}\n\n\t\tsubscriptions.add(callback);\n\n\t\treturn toDisposable(() => {\n\t\t\tconst subscriptions = this.subscriptions.get(path);\n\t\t\tif (subscriptions) {\n\t\t\t\tsubscriptions.delete(callback);\n\n\t\t\t\tif (subscriptions.size === 0) {\n\t\t\t\t\tthis.subscriptions.delete(path);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tget subscriptionsCount(): number {\n\t\treturn this.subscriptions.size;\n\t}\n\n\tnotifyFileChange(path: string, change: IFileChange): void {\n\t\tconst subscriptions = this.subscriptions.get(path);\n\t\tif (subscriptions) {\n\t\t\tfor (const subscription of subscriptions) {\n\t\t\t\tsubscription(change);\n\t\t\t}\n\t\t}\n\t}\n\n\tnotifyWatchFailed(): void {\n\t\tthis.didFail = true;\n\n\t\tthis._onDidFail.fire();\n\t}\n\n\tinclude(path: string): boolean {\n\t\tif (!this.includes || this.includes.length === 0) {\n\t\t\treturn true; // no specific includes defined, include all\n\t\t}\n\n\t\treturn this.includes.some(include => include(path));\n\t}\n\n\texclude(path: string): boolean {\n\t\treturn Boolean(this.excludes?.some(exclude => exclude(path)));\n\t}\n\n\tasync stop(joinRestart: Promise<void> | undefined): Promise<void> {\n\t\tthis.didStop = true;\n\n\t\ttry {\n\t\t\tawait this.stopFn();\n\t\t} finally {\n\t\t\tthis._onDidStop.fire({ joinRestart });\n\t\t\tthis.dispose();\n\t\t}\n\t}\n}\n\nexport class ParcelWatcher extends BaseWatcher implements IRecursiveWatcherWithSubscribe {\n\n\tprivate static readonly MAP_PARCEL_WATCHER_ACTION_TO_FILE_CHANGE = new Map<parcelWatcher.EventType, number>(\n\t\t[\n\t\t\t['create', FileChangeType.ADDED],\n\t\t\t['update', FileChangeType.UPDATED],\n\t\t\t['delete', FileChangeType.DELETED]\n\t\t]\n\t);\n\n\tprivate static readonly PREDEFINED_EXCLUDES: { [platform: string]: string[] } = {\n\t\t'win32': [],\n\t\t'darwin': [\n\t\t\tjoin(homedir(), 'Library', 'Containers') // Triggers access dialog from macOS 14 (https://github.com/microsoft/vscode/issues/208105)\n\t\t],\n\t\t'linux': []\n\t};\n\n\tprivate static readonly PARCEL_WATCHER_BACKEND = isWindows ? 'windows' : isLinux ? 'inotify' : 'fs-events';\n\n\tprivate readonly _onDidError = this._register(new Emitter<IWatcherErrorEvent>());\n\treadonly onDidError = this._onDidError.event;\n\n\tprivate readonly _watchers = new Map<string /* path */ | number /* correlation ID */, ParcelWatcherInstance>();\n\tget watchers() { return this._watchers.values(); }\n\n\t// A delay for collecting file changes from Parcel\n\t// before collecting them for coalescing and emitting.\n\t// Parcel internally uses 50ms as delay, so we use 75ms,\n\t// to schedule sufficiently after Parcel.\n\t//\n\t// Note: since Parcel 2.0.7, the very first event is\n\t// emitted without delay if no events occured over a\n\t// duration of 500ms. But we always want to aggregate\n\t// events to apply our coleasing logic.\n\t//\n\tprivate static readonly FILE_CHANGES_HANDLER_DELAY = 75;\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesEmitter = this._register(new ThrottledWorker<IFileChange>(\n\t\t{\n\t\t\tmaxWorkChunkSize: 500,\t// only process up to 500 changes at once before...\n\t\t\tthrottleDelay: 200,\t  \t// ...resting for 200ms until we process events again...\n\t\t\tmaxBufferedWork: 30000 \t// ...but never buffering more than 30000 events in memory\n\t\t},\n\t\tevents => this._onDidChangeFile.fire(events)\n\t));\n\n\tprivate enospcErrorLogged = false;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tconst onUncaughtException = (error: unknown) => this.onUnexpectedError(error);\n\t\tconst onUnhandledRejection = (error: unknown) => this.onUnexpectedError(error);\n\n\t\tprocess.on('uncaughtException', onUncaughtException);\n\t\tprocess.on('unhandledRejection', onUnhandledRejection);\n\n\t\tthis._register(toDisposable(() => {\n\t\t\tprocess.off('uncaughtException', onUncaughtException);\n\t\t\tprocess.off('unhandledRejection', onUnhandledRejection);\n\t\t}));\n\t}\n\n\tprotected override async doWatch(requests: IRecursiveWatchRequest[]): Promise<void> {\n\n\t\t// Figure out duplicates to remove from the requests\n\t\trequests = await this.removeDuplicateRequests(requests);\n\n\t\t// Figure out which watchers to start and which to stop\n\t\tconst requestsToStart: IRecursiveWatchRequest[] = [];\n\t\tconst watchersToStop = new Set(Array.from(this.watchers));\n\t\tfor (const request of requests) {\n\t\t\tconst watcher = this._watchers.get(this.requestToWatcherKey(request));\n\t\t\tif (watcher && patternsEquals(watcher.request.excludes, request.excludes) && patternsEquals(watcher.request.includes, request.includes) && watcher.request.pollingInterval === request.pollingInterval) {\n\t\t\t\twatchersToStop.delete(watcher); // keep watcher\n\t\t\t} else {\n\t\t\t\trequestsToStart.push(request); // start watching\n\t\t\t}\n\t\t}\n\n\t\t// Logging\n\t\tif (requestsToStart.length) {\n\t\t\tthis.trace(`Request to start watching: ${requestsToStart.map(request => this.requestToString(request)).join(',')}`);\n\t\t}\n\n\t\tif (watchersToStop.size) {\n\t\t\tthis.trace(`Request to stop watching: ${Array.from(watchersToStop).map(watcher => this.requestToString(watcher.request)).join(',')}`);\n\t\t}\n\n\t\t// Stop watching as instructed\n\t\tfor (const watcher of watchersToStop) {\n\t\t\tawait this.stopWatching(watcher);\n\t\t}\n\n\t\t// Start watching as instructed\n\t\tfor (const request of requestsToStart) {\n\t\t\tif (request.pollingInterval) {\n\t\t\t\tawait this.startPolling(request, request.pollingInterval);\n\t\t\t} else {\n\t\t\t\tawait this.startWatching(request);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate requestToWatcherKey(request: IRecursiveWatchRequest): string | number {\n\t\treturn typeof request.correlationId === 'number' ? request.correlationId : this.pathToWatcherKey(request.path);\n\t}\n\n\tprivate pathToWatcherKey(path: string): string {\n\t\treturn isLinux ? path : path.toLowerCase() /* ignore path casing */;\n\t}\n\n\tprivate async startPolling(request: IRecursiveWatchRequest, pollingInterval: number, restarts = 0): Promise<void> {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst instance = new DeferredPromise<void>();\n\n\t\tconst snapshotFile = randomPath(tmpdir(), 'vscode-watcher-snapshot');\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: ParcelWatcherInstance = new ParcelWatcherInstance(\n\t\t\tinstance.p,\n\t\t\trequest,\n\t\t\trestarts,\n\t\t\tcts.token,\n\t\t\tnew RunOnceWorker<IFileChange>(events => this.handleParcelEvents(events, watcher), ParcelWatcher.FILE_CHANGES_HANDLER_DELAY),\n\t\t\tasync () => {\n\t\t\t\tcts.dispose(true);\n\n\t\t\t\twatcher.worker.flush();\n\t\t\t\twatcher.worker.dispose();\n\n\t\t\t\tpollingWatcher.dispose();\n\t\t\t\tawait promises.unlink(snapshotFile);\n\t\t\t}\n\t\t);\n\t\tthis._watchers.set(this.requestToWatcherKey(request), watcher);\n\n\t\t// Path checks for symbolic links / wrong casing\n\t\tconst { realPath, realPathDiffers, realPathLength } = await this.normalizePath(request);\n\n\t\tthis.trace(`Started watching: '${realPath}' with polling interval '${pollingInterval}'`);\n\n\t\tlet counter = 0;\n\n\t\tconst pollingWatcher = new RunOnceScheduler(async () => {\n\t\t\tcounter++;\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// We already ran before, check for events since\n\t\t\tconst parcelWatcherLib = parcelWatcher;\n\t\t\ttry {\n\t\t\t\tif (counter > 1) {\n\t\t\t\t\tconst parcelEvents = await parcelWatcherLib.getEventsSince(realPath, snapshotFile, { ignore: this.addPredefinedExcludes(request.excludes), backend: ParcelWatcher.PARCEL_WATCHER_BACKEND });\n\n\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle & emit events\n\t\t\t\t\tthis.onParcelEvents(parcelEvents, watcher, realPathDiffers, realPathLength);\n\t\t\t\t}\n\n\t\t\t\t// Store a snapshot of files to the snapshot file\n\t\t\t\tawait parcelWatcherLib.writeSnapshot(realPath, snapshotFile, { ignore: this.addPredefinedExcludes(request.excludes), backend: ParcelWatcher.PARCEL_WATCHER_BACKEND });\n\t\t\t} catch (error) {\n\t\t\t\tthis.onUnexpectedError(error, request);\n\t\t\t}\n\n\t\t\t// Signal we are ready now when the first snapshot was written\n\t\t\tif (counter === 1) {\n\t\t\t\tinstance.complete();\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Schedule again at the next interval\n\t\t\tpollingWatcher.schedule();\n\t\t}, pollingInterval);\n\t\tpollingWatcher.schedule(0);\n\t}\n\n\tprivate async startWatching(request: IRecursiveWatchRequest, restarts = 0): Promise<void> {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst instance = new DeferredPromise<parcelWatcher.AsyncSubscription | undefined>();\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: ParcelWatcherInstance = new ParcelWatcherInstance(\n\t\t\tinstance.p,\n\t\t\trequest,\n\t\t\trestarts,\n\t\t\tcts.token,\n\t\t\tnew RunOnceWorker<IFileChange>(events => this.handleParcelEvents(events, watcher), ParcelWatcher.FILE_CHANGES_HANDLER_DELAY),\n\t\t\tasync () => {\n\t\t\t\tcts.dispose(true);\n\n\t\t\t\twatcher.worker.flush();\n\t\t\t\twatcher.worker.dispose();\n\n\t\t\t\tconst watcherInstance = await instance.p;\n\t\t\t\tawait watcherInstance?.unsubscribe();\n\t\t\t}\n\t\t);\n\t\tthis._watchers.set(this.requestToWatcherKey(request), watcher);\n\n\t\t// Path checks for symbolic links / wrong casing\n\t\tconst { realPath, realPathDiffers, realPathLength } = await this.normalizePath(request);\n\n\t\ttry {\n\t\t\tconst parcelWatcherLib = parcelWatcher;\n\t\t\tconst parcelWatcherInstance = await parcelWatcherLib.subscribe(realPath, (error, parcelEvents) => {\n\t\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\t\treturn; // return early when disposed\n\t\t\t\t}\n\n\t\t\t\t// In any case of an error, treat this like a unhandled exception\n\t\t\t\t// that might require the watcher to restart. We do not really know\n\t\t\t\t// the state of parcel at this point and as such will try to restart\n\t\t\t\t// up to our maximum of restarts.\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.onUnexpectedError(error, request);\n\t\t\t\t}\n\n\t\t\t\t// Handle & emit events\n\t\t\t\tthis.onParcelEvents(parcelEvents, watcher, realPathDiffers, realPathLength);\n\t\t\t}, {\n\t\t\t\tbackend: ParcelWatcher.PARCEL_WATCHER_BACKEND,\n\t\t\t\tignore: this.addPredefinedExcludes(watcher.request.excludes)\n\t\t\t});\n\n\t\t\tthis.trace(`Started watching: '${realPath}' with backend '${ParcelWatcher.PARCEL_WATCHER_BACKEND}'`);\n\n\t\t\tinstance.complete(parcelWatcherInstance);\n\t\t} catch (error) {\n\t\t\tthis.onUnexpectedError(error, request);\n\n\t\t\tinstance.complete(undefined);\n\n\t\t\twatcher.notifyWatchFailed();\n\t\t\tthis._onDidWatchFail.fire(request);\n\t\t}\n\t}\n\n\tprivate addPredefinedExcludes(initialExcludes: string[]): string[] {\n\t\tconst excludes = [...initialExcludes];\n\n\t\tconst predefinedExcludes = ParcelWatcher.PREDEFINED_EXCLUDES[process.platform];\n\t\tif (Array.isArray(predefinedExcludes)) {\n\t\t\tfor (const exclude of predefinedExcludes) {\n\t\t\t\tif (!excludes.includes(exclude)) {\n\t\t\t\t\texcludes.push(exclude);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn excludes;\n\t}\n\n\tprivate onParcelEvents(parcelEvents: parcelWatcher.Event[], watcher: ParcelWatcherInstance, realPathDiffers: boolean, realPathLength: number): void {\n\t\tif (parcelEvents.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Normalize events: handle NFC normalization and symlinks\n\t\t// It is important to do this before checking for includes\n\t\t// to check on the original path.\n\t\tthis.normalizeEvents(parcelEvents, watcher.request, realPathDiffers, realPathLength);\n\n\t\t// Check for includes\n\t\tconst includedEvents = this.handleIncludes(watcher, parcelEvents);\n\n\t\t// Add to event aggregator for later processing\n\t\tfor (const includedEvent of includedEvents) {\n\t\t\twatcher.worker.work(includedEvent);\n\t\t}\n\t}\n\n\tprivate handleIncludes(watcher: ParcelWatcherInstance, parcelEvents: parcelWatcher.Event[]): IFileChange[] {\n\t\tconst events: IFileChange[] = [];\n\n\t\tfor (const { path, type: parcelEventType } of parcelEvents) {\n\t\t\tconst type = ParcelWatcher.MAP_PARCEL_WATCHER_ACTION_TO_FILE_CHANGE.get(parcelEventType)!;\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(`${type === FileChangeType.ADDED ? '[ADDED]' : type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${path}`, watcher.request);\n\t\t\t}\n\n\t\t\t// Apply include filter if any\n\t\t\tif (!watcher.include(path)) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(` >> ignored (not included) ${path}`, watcher.request);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tevents.push({ type, resource: URI.file(path), cId: watcher.request.correlationId });\n\t\t\t}\n\t\t}\n\n\t\treturn events;\n\t}\n\n\tprivate handleParcelEvents(parcelEvents: IFileChange[], watcher: ParcelWatcherInstance): void {\n\n\t\t// Coalesce events: merge events of same kind\n\t\tconst coalescedEvents = coalesceEvents(parcelEvents);\n\n\t\t// Filter events: check for specific events we want to exclude\n\t\tconst { events: filteredEvents, rootDeleted } = this.filterEvents(coalescedEvents, watcher);\n\n\t\t// Broadcast to clients\n\t\tthis.emitEvents(filteredEvents, watcher);\n\n\t\t// Handle root path deletes\n\t\tif (rootDeleted) {\n\t\t\tthis.onWatchedPathDeleted(watcher);\n\t\t}\n\t}\n\n\tprivate emitEvents(events: IFileChange[], watcher: ParcelWatcherInstance): void {\n\t\tif (events.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Broadcast to clients via throttler\n\t\tconst worked = this.throttledFileChangesEmitter.work(events);\n\n\t\t// Logging\n\t\tif (!worked) {\n\t\t\tthis.warn(`started ignoring events due to too many file change events at once (incoming: ${events.length}, most recent change: ${events[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t} else {\n\t\t\tif (this.throttledFileChangesEmitter.pending > 0) {\n\t\t\t\tthis.trace(`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${events[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`, watcher);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async normalizePath(request: IRecursiveWatchRequest): Promise<{ realPath: string; realPathDiffers: boolean; realPathLength: number }> {\n\t\tlet realPath = request.path;\n\t\tlet realPathDiffers = false;\n\t\tlet realPathLength = request.path.length;\n\n\t\ttry {\n\n\t\t\t// First check for symbolic link\n\t\t\trealPath = await Promises.realpath(request.path);\n\n\t\t\t// Second check for casing difference\n\t\t\t// Note: this will be a no-op on Linux platforms\n\t\t\tif (request.path === realPath) {\n\t\t\t\trealPath = await realcase(request.path) ?? request.path;\n\t\t\t}\n\n\t\t\t// Correct watch path as needed\n\t\t\tif (request.path !== realPath) {\n\t\t\t\trealPathLength = realPath.length;\n\t\t\t\trealPathDiffers = true;\n\n\t\t\t\tthis.trace(`correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${request.path}, real: ${realPath})`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn { realPath, realPathDiffers, realPathLength };\n\t}\n\n\tprivate normalizeEvents(events: parcelWatcher.Event[], request: IRecursiveWatchRequest, realPathDiffers: boolean, realPathLength: number): void {\n\t\tfor (const event of events) {\n\n\t\t\t// Mac uses NFD unicode form on disk, but we want NFC\n\t\t\tif (isMacintosh) {\n\t\t\t\tevent.path = normalizeNFC(event.path);\n\t\t\t}\n\n\t\t\t// Workaround for https://github.com/parcel-bundler/watcher/issues/68\n\t\t\t// where watching root drive letter adds extra backslashes.\n\t\t\tif (isWindows) {\n\t\t\t\tif (request.path.length <= 3) { // for ex. c:, C:\\\n\t\t\t\t\tevent.path = normalize(event.path);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Convert paths back to original form in case it differs\n\t\t\tif (realPathDiffers) {\n\t\t\t\tevent.path = request.path + event.path.substr(realPathLength);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate filterEvents(events: IFileChange[], watcher: ParcelWatcherInstance): { events: IFileChange[]; rootDeleted?: boolean } {\n\t\tconst filteredEvents: IFileChange[] = [];\n\t\tlet rootDeleted = false;\n\n\t\tconst filter = this.isCorrelated(watcher.request) ? watcher.request.filter : undefined; // filtering is only enabled when correlating because watchers are otherwise potentially reused\n\t\tfor (const event of events) {\n\n\t\t\t// Emit to instance subscriptions if any before filtering\n\t\t\tif (watcher.subscriptionsCount > 0) {\n\t\t\t\twatcher.notifyFileChange(event.resource.fsPath, event);\n\t\t\t}\n\n\t\t\t// Filtering\n\t\t\trootDeleted = event.type === FileChangeType.DELETED && isEqual(event.resource.fsPath, watcher.request.path, !isLinux);\n\t\t\tif (isFiltered(event, filter)) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(` >> ignored (filtered) ${event.resource.fsPath}`, watcher.request);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Logging\n\t\t\tthis.traceEvent(event, watcher.request);\n\n\t\t\tfilteredEvents.push(event);\n\t\t}\n\n\t\treturn { events: filteredEvents, rootDeleted };\n\t}\n\n\tprivate onWatchedPathDeleted(watcher: ParcelWatcherInstance): void {\n\t\tthis.warn('Watcher shutdown because watched path got deleted', watcher);\n\n\t\twatcher.notifyWatchFailed();\n\t\tthis._onDidWatchFail.fire(watcher.request);\n\t}\n\n\tprivate onUnexpectedError(error: unknown, request?: IRecursiveWatchRequest): void {\n\t\tconst msg = toErrorMessage(error);\n\n\t\t// Specially handle ENOSPC errors that can happen when\n\t\t// the watcher consumes so many file descriptors that\n\t\t// we are running into a limit. We only want to warn\n\t\t// once in this case to avoid log spam.\n\t\t// See https://github.com/microsoft/vscode/issues/7950\n\t\tif (msg.indexOf('No space left on device') !== -1) {\n\t\t\tif (!this.enospcErrorLogged) {\n\t\t\t\tthis.error('Inotify limit reached (ENOSPC)', request);\n\n\t\t\t\tthis.enospcErrorLogged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Version 2.5.1 introduces 3 new errors on macOS\n\t\t// via https://github.dev/parcel-bundler/watcher/pull/196\n\t\telse if (msg.indexOf('File system must be re-scanned') !== -1) {\n\t\t\tthis.error(msg, request);\n\t\t}\n\n\t\t// Any other error is unexpected and we should try to\n\t\t// restart the watcher as a result to get into healthy\n\t\t// state again if possible and if not attempted too much\n\t\telse {\n\t\t\tthis.error(`Unexpected error: ${msg} (EUNKNOWN)`, request);\n\n\t\t\tthis._onDidError.fire({ request, error: msg });\n\t\t}\n\t}\n\n\toverride async stop(): Promise<void> {\n\t\tawait super.stop();\n\n\t\tfor (const watcher of this.watchers) {\n\t\t\tawait this.stopWatching(watcher);\n\t\t}\n\t}\n\n\tprotected restartWatching(watcher: ParcelWatcherInstance, delay = 800): void {\n\n\t\t// Restart watcher delayed to accomodate for\n\t\t// changes on disk that have triggered the\n\t\t// need for a restart in the first place.\n\t\tconst scheduler = new RunOnceScheduler(async () => {\n\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\treturn; // return early when disposed\n\t\t\t}\n\n\t\t\tconst restartPromise = new DeferredPromise<void>();\n\t\t\ttry {\n\n\t\t\t\t// Await the watcher having stopped, as this is\n\t\t\t\t// needed to properly re-watch the same path\n\t\t\t\tawait this.stopWatching(watcher, restartPromise.p);\n\n\t\t\t\t// Start watcher again counting the restarts\n\t\t\t\tif (watcher.request.pollingInterval) {\n\t\t\t\t\tawait this.startPolling(watcher.request, watcher.request.pollingInterval, watcher.restarts + 1);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.startWatching(watcher.request, watcher.restarts + 1);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\trestartPromise.complete();\n\t\t\t}\n\t\t}, delay);\n\n\t\tscheduler.schedule();\n\t\twatcher.token.onCancellationRequested(() => scheduler.dispose());\n\t}\n\n\tprivate async stopWatching(watcher: ParcelWatcherInstance, joinRestart?: Promise<void>): Promise<void> {\n\t\tthis.trace(`stopping file watcher`, watcher);\n\n\t\tthis._watchers.delete(this.requestToWatcherKey(watcher.request));\n\n\t\ttry {\n\t\t\tawait watcher.stop(joinRestart);\n\t\t} catch (error) {\n\t\t\tthis.error(`Unexpected error stopping watcher: ${toErrorMessage(error)}`, watcher.request);\n\t\t}\n\t}\n\n\tprotected async removeDuplicateRequests(requests: IRecursiveWatchRequest[], validatePaths = true): Promise<IRecursiveWatchRequest[]> {\n\n\t\t// Sort requests by path length to have shortest first\n\t\t// to have a way to prevent children to be watched if\n\t\t// parents exist.\n\t\trequests.sort((requestA, requestB) => requestA.path.length - requestB.path.length);\n\n\t\t// Ignore requests for the same paths that have the same correlation\n\t\tconst mapCorrelationtoRequests = new Map<number | undefined /* correlation */, Map<string, IRecursiveWatchRequest>>();\n\t\tfor (const request of requests) {\n\t\t\tif (request.excludes.includes(GLOBSTAR)) {\n\t\t\t\tcontinue; // path is ignored entirely (via `**` glob exclude)\n\t\t\t}\n\n\n\t\t\tlet requestsForCorrelation = mapCorrelationtoRequests.get(request.correlationId);\n\t\t\tif (!requestsForCorrelation) {\n\t\t\t\trequestsForCorrelation = new Map<string, IRecursiveWatchRequest>();\n\t\t\t\tmapCorrelationtoRequests.set(request.correlationId, requestsForCorrelation);\n\t\t\t}\n\n\t\t\tconst path = this.pathToWatcherKey(request.path);\n\t\t\tif (requestsForCorrelation.has(path)) {\n\t\t\t\tthis.trace(`ignoring a request for watching who's path is already watched: ${this.requestToString(request)}`);\n\t\t\t}\n\n\t\t\trequestsForCorrelation.set(path, request);\n\t\t}\n\n\t\tconst normalizedRequests: IRecursiveWatchRequest[] = [];\n\n\t\tfor (const requestsForCorrelation of mapCorrelationtoRequests.values()) {\n\n\t\t\t// Only consider requests for watching that are not\n\t\t\t// a child of an existing request path to prevent\n\t\t\t// duplication. In addition, drop any request where\n\t\t\t// everything is excluded (via `**` glob).\n\t\t\t//\n\t\t\t// However, allow explicit requests to watch folders\n\t\t\t// that are symbolic links because the Parcel watcher\n\t\t\t// does not allow to recursively watch symbolic links.\n\n\t\t\tconst requestTrie = TernarySearchTree.forPaths<IRecursiveWatchRequest>(!isLinux);\n\n\t\t\tfor (const request of requestsForCorrelation.values()) {\n\n\t\t\t\t// Check for overlapping request paths (but preserve symbolic links)\n\t\t\t\tif (requestTrie.findSubstr(request.path)) {\n\t\t\t\t\tif (requestTrie.has(request.path)) {\n\t\t\t\t\t\tthis.trace(`ignoring a request for watching who's path is already watched: ${this.requestToString(request)}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!(await promises.lstat(request.path)).isSymbolicLink()) {\n\t\t\t\t\t\t\t\tthis.trace(`ignoring a request for watching who's parent is already watched: ${this.requestToString(request)}`);\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthis.trace(`ignoring a request for watching who's lstat failed to resolve: ${this.requestToString(request)} (error: ${error})`);\n\n\t\t\t\t\t\t\tthis._onDidWatchFail.fire(request);\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Check for invalid paths\n\t\t\t\tif (validatePaths && !(await this.isPathValid(request.path))) {\n\t\t\t\t\tthis._onDidWatchFail.fire(request);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trequestTrie.set(request.path, request);\n\t\t\t}\n\n\t\t\tnormalizedRequests.push(...Array.from(requestTrie).map(([, request]) => request));\n\t\t}\n\n\t\treturn normalizedRequests;\n\t}\n\n\tprivate async isPathValid(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst stat = await promises.stat(path);\n\t\t\tif (!stat.isDirectory()) {\n\t\t\t\tthis.trace(`ignoring a path for watching that is a file and not a folder: ${path}`);\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.trace(`ignoring a path for watching who's stat info failed to resolve: ${path} (error: ${error})`);\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsubscribe(path: string, callback: (error: true | null, change?: IFileChange) => void): IDisposable | undefined {\n\t\tfor (const watcher of this.watchers) {\n\t\t\tif (watcher.failed) {\n\t\t\t\tcontinue; // watcher has already failed\n\t\t\t}\n\n\t\t\tif (!isEqualOrParent(path, watcher.request.path, !isLinux)) {\n\t\t\t\tcontinue; // watcher does not consider this path\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\twatcher.exclude(path) ||\n\t\t\t\t!watcher.include(path)\n\t\t\t) {\n\t\t\t\tcontinue; // parcel instance does not consider this path\n\t\t\t}\n\n\t\t\tconst disposables = new DisposableStore();\n\n\t\t\tdisposables.add(Event.once(watcher.onDidStop)(async e => {\n\t\t\t\tawait e.joinRestart; // if we are restarting, await that so that we can possibly reuse this watcher again\n\t\t\t\tif (disposables.isDisposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcallback(true /* error */);\n\t\t\t}));\n\t\t\tdisposables.add(Event.once(watcher.onDidFail)(() => callback(true /* error */)));\n\t\t\tdisposables.add(watcher.subscribe(path, change => callback(null, change)));\n\n\t\t\treturn disposables;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprotected trace(message: string, watcher?: ParcelWatcherInstance): void {\n\t\tif (this.verboseLogging) {\n\t\t\tthis._onDidLogMessage.fire({ type: 'trace', message: this.toMessage(message, watcher?.request) });\n\t\t}\n\t}\n\n\tprotected warn(message: string, watcher?: ParcelWatcherInstance) {\n\t\tthis._onDidLogMessage.fire({ type: 'warn', message: this.toMessage(message, watcher?.request) });\n\t}\n\n\tprivate error(message: string, request?: IRecursiveWatchRequest) {\n\t\tthis._onDidLogMessage.fire({ type: 'error', message: this.toMessage(message, request) });\n\t}\n\n\tprivate toMessage(message: string, request?: IRecursiveWatchRequest): string {\n\t\treturn request ? `[File Watcher ('parcel')] ${message} (path: ${request.path})` : `[File Watcher ('parcel')] ${message}`;\n\t}\n\n\tprotected get recursiveWatcher() { return this; }\n}\n"]}