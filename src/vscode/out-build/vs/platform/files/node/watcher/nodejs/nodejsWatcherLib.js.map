{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/node/watcher/nodejs/nodejsWatcherLib.ts","vs/platform/files/node/watcher/nodejs/nodejsWatcherLib.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,MAAM,IAAI,CAAC;AACrC,OAAO,EAAE,aAAa,EAAE,eAAe,EAAE,MAAM,qCAAqC,CAAC;AACrF,OAAO,EAAqB,uBAAuB,EAAE,MAAM,4CAA4C,CAAC;AACxG,OAAO,EAAE,OAAO,EAAE,eAAe,EAAE,MAAM,uCAAuC,CAAC;AACjF,OAAO,EAAE,UAAU,EAAE,eAAe,EAAe,qBAAqB,EAAE,YAAY,EAAE,MAAM,yCAAyC,CAAC;AACxI,OAAO,EAAE,YAAY,EAAE,MAAM,6CAA6C,CAAC;AAC3E,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,oCAAoC,CAAC;AAC7E,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,wCAAwC,CAAC;AAC9E,OAAO,EAAE,QAAQ,EAAE,MAAM,yCAAyC,CAAC;AACnE,OAAO,EAAE,GAAG,EAAE,MAAM,mCAAmC,CAAC;AACxD,OAAO,EAAE,QAAQ,EAAE,MAAM,iCAAiC,CAAC;AAE3D,OAAO,EAAe,cAAc,EAA6B,oBAAoB,EAAkC,UAAU,EAAE,6BAA6B,EAAE,MAAM,4BAA4B,CAAC;AACrM,OAAO,EAAE,IAAI,EAAE,MAAM,oCAAoC,CAAC;AAG1D,MAAM,OAAO,wBAAyB,SAAQ,UAAU;IAEvD,iDAAiD;IACjD,gDAAgD;IAChD,gDAAgD;IAChD,aAAa;aACW,8BAAyB,GAAG,GAAH,AAAM,CAAC;IAExD,mDAAmD;IACnD,qDAAqD;IACrD,gDAAgD;aACxB,+BAA0B,GAAG,EAAH,AAAK,CAAC;IAmDxD,IAAI,yBAAyB,KAAc,OAAO,IAAI,CAAC,0BAA0B,CAAC,CAAC,CAAC;IAGpF,IAAI,MAAM,KAAc,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAE9C,YACkB,OAAkC,EAClC,gBAA4D,EAC5D,gBAAkD,EAClD,cAA2B,EAC3B,YAAyC,EAClD,cAAwB;QAEhC,KAAK,EAAE,CAAC;QAPS,YAAO,GAAP,OAAO,CAA2B;QAClC,qBAAgB,GAAhB,gBAAgB,CAA4C;QAC5D,qBAAgB,GAAhB,gBAAgB,CAAkC;QAClD,mBAAc,GAAd,cAAc,CAAa;QAC3B,iBAAY,GAAZ,YAAY,CAA6B;QAClD,mBAAc,GAAd,cAAc,CAAU;QA5DjC,6DAA6D;QAC7D,0DAA0D;QAC1D,wDAAwD;QACxD,gCAAgC;QAChC,sDAAsD;QACrC,gCAA2B,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAe,CAChF;YACC,gBAAgB,EAAE,GAAG,EAAE,mDAAmD;YAC1E,aAAa,EAAE,GAAG,EAAK,wDAAwD;YAC/E,eAAe,EAAE,KAAK,CAAE,0DAA0D;SAClF,EACD,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CACvC,CAAC,CAAC;QAEH,yDAAyD;QACzD,sCAAsC;QACrB,0BAAqB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,aAAa,CAAc,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,wBAAwB,CAAC,0BAA0B,CAAC,CAAC,CAAC;QAMtK,QAAG,GAAG,IAAI,uBAAuB,EAAE,CAAC;QAEpC,aAAQ,GAAG,IAAI,IAAI,CAAC,KAAK,IAAI,EAAE;YAE/C,sFAAsF;YACtF,wFAAwF;YACxF,uFAAuF;YACvF,yDAAyD;YAEzD,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;YAE/B,IAAI,CAAC;gBACJ,MAAM,GAAG,MAAM,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBAEpD,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,KAAK,MAAM,EAAE,CAAC;oBAClC,IAAI,CAAC,KAAK,CAAC,0EAA0E,IAAI,CAAC,OAAO,CAAC,IAAI,WAAW,MAAM,GAAG,CAAC,CAAC;gBAC7H,CAAC;YACF,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBAChB,SAAS;YACV,CAAC;YAED,OAAO,MAAM,CAAC;QACf,CAAC,CAAC,CAAC;QAIK,+BAA0B,GAAG,KAAK,CAAC;QAGnC,YAAO,GAAG,KAAK,CAAC;QAavB,IAAI,CAAC,QAAQ,GAAG,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAC/E,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACnH,IAAI,CAAC,MAAM,GAAG,6BAA6B,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,+FAA+F;QAE5L,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;IAC3B,CAAC;IAEO,KAAK,CAAC,KAAK;QAClB,IAAI,CAAC;YACJ,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAEpD,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;gBAC5C,OAAO;YACR,CAAC;YAED,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;QACxD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;gBAC7B,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACnB,CAAC;iBAAM,CAAC;gBACP,IAAI,CAAC,KAAK,CAAC,mEAAmE,IAAI,CAAC,OAAO,CAAC,IAAI,YAAY,KAAK,GAAG,CAAC,CAAC;YACtH,CAAC;YAED,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC1B,CAAC;IACF,CAAC;IAEO,iBAAiB;QACxB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QAEpB,IAAI,CAAC,cAAc,EAAE,EAAE,CAAC;IACzB,CAAC;IAEO,KAAK,CAAC,OAAO,CAAC,WAAoB;QACzC,MAAM,WAAW,GAAG,IAAI,eAAe,EAAE,CAAC;QAE1C,IAAI,IAAI,CAAC,0BAA0B,CAAC,WAAW,EAAE,WAAW,CAAC,EAAE,CAAC;YAC/D,IAAI,CAAC,KAAK,CAAC,6CAA6C,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;YAC7E,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC;QACxC,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,0BAA0B,GAAG,KAAK,CAAC;YACxC,MAAM,IAAI,CAAC,iBAAiB,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;QACxD,CAAC;QAED,OAAO,WAAW,CAAC;IACpB,CAAC;IAEO,0BAA0B,CAAC,WAAoB,EAAE,WAA4B;QACpF,IAAI,WAAW,EAAE,CAAC;YACjB,6DAA6D;YAC7D,8DAA8D;YAC9D,+DAA+D;YAC/D,6DAA6D;YAC7D,uBAAuB;YACvB,OAAO,KAAK,CAAC;QACd,CAAC;QAED,MAAM,QAAQ,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC7C,MAAM,YAAY,GAAG,IAAI,CAAC,gBAAgB,EAAE,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,EAAE;YAChG,IAAI,WAAW,CAAC,UAAU,EAAE,CAAC;gBAC5B,OAAO,CAAC,mCAAmC;YAC5C,CAAC;YAED,IAAI,KAAK,EAAE,CAAC;gBACX,MAAM,qBAAqB,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE,WAAW,CAAC,CAAC;YACrE,CAAC;iBAAM,IAAI,MAAM,EAAE,CAAC;gBACnB,IAAI,OAAO,MAAM,CAAC,GAAG,KAAK,QAAQ,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,KAAK,QAAQ,EAAE,CAAC;oBACtF,6DAA6D;oBAC7D,8DAA8D;oBAC9D,2DAA2D;oBAC3D,gEAAgE;oBAChE,IAAI,CAAC,YAAY,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,EAAE,IAAI,CAAC,yDAAyD,CAAC,CAAC;gBACrJ,CAAC;YACF,CAAC;QACF,CAAC,CAAC,CAAC;QAEH,IAAI,YAAY,EAAE,CAAC;YAClB,WAAW,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;YAE9B,OAAO,IAAI,CAAC;QACb,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAEO,KAAK,CAAC,iBAAiB,CAAC,WAAoB,EAAE,WAA4B;QACjF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC;QAE3C,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;YAC5C,OAAO;QACR,CAAC;QAED,yDAAyD;QACzD,wDAAwD;QACxD,sDAAsD;QACtD,uDAAuD;QACvD,+BAA+B;QAC/B,IAAI,WAAW,IAAI,eAAe,CAAC,QAAQ,EAAE,WAAW,EAAE,IAAI,CAAC,EAAE,CAAC;YACjE,IAAI,CAAC,KAAK,CAAC,qBAAqB,QAAQ,6GAA6G,CAAC,CAAC;YAEvJ,OAAO;QACR,CAAC;QAED,MAAM,GAAG,GAAG,IAAI,uBAAuB,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACxD,WAAW,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAEvD,MAAM,kBAAkB,GAAG,IAAI,eAAe,EAAE,CAAC,CAAC,iGAAiG;QACnJ,WAAW,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC;QAEpC,IAAI,CAAC;YACJ,MAAM,eAAe,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YACpD,MAAM,YAAY,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC;YAExC,8CAA8C;YAC9C,MAAM,OAAO,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;YAChC,kBAAkB,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,EAAE;gBACxC,OAAO,CAAC,kBAAkB,EAAE,CAAC;gBAC7B,OAAO,CAAC,KAAK,EAAE,CAAC;YACjB,CAAC,CAAC,CAAC,CAAC;YAEJ,IAAI,CAAC,KAAK,CAAC,sBAAsB,QAAQ,GAAG,CAAC,CAAC;YAE9C,iDAAiD;YACjD,MAAM,cAAc,GAAG,IAAI,GAAG,EAAU,CAAC;YACzC,IAAI,WAAW,EAAE,CAAC;gBACjB,IAAI,CAAC;oBACJ,KAAK,MAAM,KAAK,IAAI,MAAM,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC;wBACtD,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;oBAC3B,CAAC;gBACF,CAAC;gBAAC,OAAO,KAAK,EAAE,CAAC;oBAChB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACnB,CAAC;YACF,CAAC;YAED,IAAI,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;gBACvC,OAAO;YACR,CAAC;YAED,MAAM,uBAAuB,GAAG,IAAI,GAAG,EAAuB,CAAC;YAC/D,kBAAkB,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,EAAE;gBACxC,KAAK,MAAM,CAAC,EAAE,UAAU,CAAC,IAAI,uBAAuB,EAAE,CAAC;oBACtD,UAAU,CAAC,OAAO,EAAE,CAAC;gBACtB,CAAC;gBACD,uBAAuB,CAAC,KAAK,EAAE,CAAC;YACjC,CAAC,CAAC,CAAC,CAAC;YAEJ,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,IAAY,EAAE,MAAc,EAAE,EAAE;gBACpD,IAAI,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;oBACvC,OAAO;gBACR,CAAC;gBAED,IAAI,CAAC,KAAK,CAAC,mBAAmB,QAAQ,kCAAkC,IAAI,KAAK,MAAM,GAAG,CAAC,CAAC;gBAE5F,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC1B,CAAC,CAAC,CAAC;YAEH,OAAO,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE;gBAClC,IAAI,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;oBACvC,OAAO,CAAC,6BAA6B;gBACtC,CAAC;gBAED,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;oBACzB,IAAI,CAAC,oBAAoB,CAAC,WAAW,IAAI,MAAM,GAAG,EAAE,CAAC,CAAC;gBACvD,CAAC;gBAED,sBAAsB;gBACtB,IAAI,eAAe,GAAG,EAAE,CAAC;gBACzB,IAAI,GAAG,EAAE,CAAC,CAAC,mDAAmD;oBAC7D,eAAe,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC;oBACjC,IAAI,WAAW,EAAE,CAAC;wBACjB,sDAAsD;wBACtD,sDAAsD;wBACtD,eAAe,GAAG,YAAY,CAAC,eAAe,CAAC,CAAC;oBACjD,CAAC;gBACF,CAAC;gBAED,IAAI,CAAC,eAAe,IAAI,CAAC,IAAI,KAAK,QAAQ,IAAI,IAAI,KAAK,QAAQ,CAAC,EAAE,CAAC;oBAClE,OAAO,CAAC,2BAA2B;gBACpC,CAAC;gBAED,SAAS;gBACT,IAAI,WAAW,EAAE,CAAC;oBAEjB,6BAA6B;oBAC7B,IAAI,IAAI,KAAK,QAAQ,EAAE,CAAC;wBAEvB,sDAAsD;wBACtD,uBAAuB,CAAC,GAAG,CAAC,eAAe,CAAC,EAAE,OAAO,EAAE,CAAC;wBAExD,0DAA0D;wBAC1D,mCAAmC;wBACnC,MAAM,aAAa,GAAG,UAAU,CAAC,KAAK,IAAI,EAAE;4BAC3C,uBAAuB,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;4BAEhD,iDAAiD;4BACjD,8CAA8C;4BAC9C,gCAAgC;4BAChC,EAAE;4BACF,iDAAiD;4BACjD,kDAAkD;4BAClD,gDAAgD;4BAChD,+CAA+C;4BAC/C,iDAAiD;4BACjD,gDAAgD;4BAChD,qBAAqB;4BACrB,8CAA8C;4BAC9C,iDAAiD;4BACjD,EAAE;4BACF,gDAAgD;4BAChD,+CAA+C;4BAC/C,+CAA+C;4BAC/C,iDAAiD;4BACjD,iDAAiD;4BACjD,IAAI,OAAO,CAAC,eAAe,EAAE,YAAY,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;gCAC1F,IAAI,CAAC,oBAAoB,CAAC,eAAe,CAAC,CAAC;gCAE3C,OAAO;4BACR,CAAC;4BAED,IAAI,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;gCACvC,OAAO;4BACR,CAAC;4BAED,4DAA4D;4BAC5D,6DAA6D;4BAC7D,0DAA0D;4BAC1D,uDAAuD;4BACvD,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC,CAAC;4BAErF,IAAI,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;gCACvC,OAAO,CAAC,4BAA4B;4BACrC,CAAC;4BAED,qCAAqC;4BACrC,2DAA2D;4BAC3D,wCAAwC;4BACxC,IAAI,IAAoB,CAAC;4BACzB,IAAI,UAAU,EAAE,CAAC;gCAChB,IAAI,cAAc,CAAC,GAAG,CAAC,eAAe,CAAC,EAAE,CAAC;oCACzC,IAAI,iCAAyB,CAAC;gCAC/B,CAAC;qCAAM,CAAC;oCACP,IAAI,+BAAuB,CAAC;oCAC5B,cAAc,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;gCACrC,CAAC;4BACF,CAAC;iCAAM,CAAC;gCACP,cAAc,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;gCACvC,IAAI,iCAAyB,CAAC;4BAC/B,CAAC;4BAED,IAAI,CAAC,YAAY,CAAC,EAAE,QAAQ,EAAE,QAAQ,CAAC,eAAe,EAAE,eAAe,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,CAAC,CAAC;wBACpH,CAAC,EAAE,wBAAwB,CAAC,yBAAyB,CAAC,CAAC;wBAEvD,uBAAuB,CAAC,GAAG,CAAC,eAAe,EAAE,YAAY,CAAC,GAAG,EAAE,CAAC,YAAY,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;oBAC/F,CAAC;oBAED,uBAAuB;yBAClB,CAAC;wBAEL,oDAAoD;wBACpD,qDAAqD;wBACrD,IAAI,IAAoB,CAAC;wBACzB,IAAI,cAAc,CAAC,GAAG,CAAC,eAAe,CAAC,EAAE,CAAC;4BACzC,IAAI,iCAAyB,CAAC;wBAC/B,CAAC;6BAAM,CAAC;4BACP,IAAI,+BAAuB,CAAC;4BAC5B,cAAc,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;wBACrC,CAAC;wBAED,IAAI,CAAC,YAAY,CAAC,EAAE,QAAQ,EAAE,QAAQ,CAAC,eAAe,EAAE,eAAe,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,CAAC,CAAC;oBACpH,CAAC;gBACF,CAAC;gBAED,OAAO;qBACF,CAAC;oBAEL,qBAAqB;oBACrB,IAAI,IAAI,KAAK,QAAQ,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,YAAY,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC;wBAE5E,iDAAiD;wBACjD,8CAA8C;wBAC9C,8BAA8B;wBAC9B,EAAE;wBACF,mDAAmD;wBACnD,0BAA0B;wBAC1B,mDAAmD;wBACnD,0BAA0B;wBAC1B,mDAAmD;wBACnD,oDAAoD;wBACpD,EAAE;wBACF,kDAAkD;wBAClD,uDAAuD;wBACvD,sDAAsD;wBACtD,gDAAgD;wBAChD,EAAE;wBACF,uDAAuD;wBACvD,uDAAuD;wBACvD,wCAAwC;wBAExC,MAAM,aAAa,GAAG,UAAU,CAAC,KAAK,IAAI,EAAE;4BAC3C,MAAM,UAAU,GAAG,MAAM,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;4BAEnD,IAAI,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;gCACvC,OAAO,CAAC,4BAA4B;4BACrC,CAAC;4BAED,qEAAqE;4BACrE,IAAI,UAAU,EAAE,CAAC;gCAChB,IAAI,CAAC,YAAY,CAAC,EAAE,QAAQ,EAAE,eAAe,EAAE,IAAI,gCAAwB,EAAE,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,EAAE,IAAI,CAAC,yDAAyD,CAAC,CAAC;gCAEhL,kBAAkB,CAAC,GAAG,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;4BACnD,CAAC;4BAED,mEAAmE;iCAC9D,CAAC;gCACL,IAAI,CAAC,oBAAoB,CAAC,eAAe,CAAC,CAAC;4BAC5C,CAAC;wBACF,CAAC,EAAE,wBAAwB,CAAC,yBAAyB,CAAC,CAAC;wBAEvD,0EAA0E;wBAC1E,yEAAyE;wBACzE,kBAAkB,CAAC,KAAK,EAAE,CAAC;wBAC3B,kBAAkB,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,YAAY,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;oBACzE,CAAC;oBAED,eAAe;yBACV,CAAC;wBACL,IAAI,CAAC,YAAY,CAAC,EAAE,QAAQ,EAAE,eAAe,EAAE,IAAI,gCAAwB,EAAE,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,EAAE,IAAI,CAAC,yDAAyD,CAAC,CAAC;oBACjL,CAAC;gBACF,CAAC;YACF,CAAC,CAAC,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;gBACvC,OAAO;YACR,CAAC;YAED,IAAI,CAAC,KAAK,CAAC,mBAAmB,QAAQ,kCAAkC,KAAK,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;YAE7F,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC1B,CAAC;IACF,CAAC;IAEO,oBAAoB,CAAC,QAAa;QACzC,IAAI,CAAC,IAAI,CAAC,mDAAmD,CAAC,CAAC;QAE/D,0DAA0D;QAC1D,IAAI,CAAC,YAAY,CAAC,EAAE,QAAQ,EAAE,IAAI,gCAAwB,EAAE,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,EAAE,IAAI,CAAC,yDAAyD,CAAC,CAAC;QAC/J,IAAI,CAAC,qBAAqB,CAAC,KAAK,EAAE,CAAC;QAEnC,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC1B,CAAC;IAEO,YAAY,CAAC,KAAkB,EAAE,wBAAwB,GAAG,KAAK;QACxE,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;YAC5C,OAAO;QACR,CAAC;QAED,UAAU;QACV,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACzB,IAAI,CAAC,oBAAoB,CAAC,GAAG,KAAK,CAAC,IAAI,iCAAyB,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,mCAA2B,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,WAAW,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC;QAC9K,CAAC;QAED,iFAAiF;QACjF,IAAI,CAAC,wBAAwB,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC;YAChG,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;gBACzB,IAAI,CAAC,oBAAoB,CAAC,0BAA0B,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC;YAC9E,CAAC;QACF,CAAC;aAAM,IAAI,CAAC,wBAAwB,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC;YACrJ,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;gBACzB,IAAI,CAAC,oBAAoB,CAAC,8BAA8B,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC;YAClF,CAAC;QACF,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACxC,CAAC;IACF,CAAC;IAEO,iBAAiB,CAAC,WAA0B;QAEnD,6CAA6C;QAC7C,MAAM,oBAAoB,GAAG,cAAc,CAAC,WAAW,CAAC,CAAC;QAEzD,kDAAkD;QAClD,MAAM,cAAc,GAAkB,EAAE,CAAC;QACzC,KAAK,MAAM,KAAK,IAAI,oBAAoB,EAAE,CAAC;YAC1C,IAAI,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;gBACpC,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;oBACzB,IAAI,CAAC,oBAAoB,CAAC,0BAA0B,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC;gBAC9E,CAAC;gBAED,SAAS;YACV,CAAC;YAED,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC5B,CAAC;QAED,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACjC,OAAO;QACR,CAAC;QAED,UAAU;QACV,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACzB,KAAK,MAAM,KAAK,IAAI,cAAc,EAAE,CAAC;gBACpC,IAAI,CAAC,oBAAoB,CAAC,kBAAkB,KAAK,CAAC,IAAI,iCAAyB,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,mCAA2B,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,WAAW,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC;YAC7L,CAAC;QACF,CAAC;QAED,6CAA6C;QAC7C,MAAM,MAAM,GAAG,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAErE,UAAU;QACV,IAAI,CAAC,MAAM,EAAE,CAAC;YACb,IAAI,CAAC,IAAI,CAAC,iFAAiF,cAAc,CAAC,MAAM,yBAAyB,cAAc,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,iHAAiH,CAAC,CAAC;QAC9R,CAAC;aAAM,CAAC;YACP,IAAI,IAAI,CAAC,2BAA2B,CAAC,OAAO,GAAG,CAAC,EAAE,CAAC;gBAClD,IAAI,CAAC,KAAK,CAAC,yFAAyF,IAAI,CAAC,2BAA2B,CAAC,OAAO,yBAAyB,cAAc,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,iHAAiH,CAAC,CAAC;YAC1T,CAAC;QACF,CAAC;IACF,CAAC;IAEO,KAAK,CAAC,qBAAqB,CAAC,IAAY;QAC/C,IAAI,OAAO,EAAE,CAAC;YACb,OAAO,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC9B,CAAC;QAED,IAAI,CAAC;YACJ,MAAM,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;YACpC,MAAM,QAAQ,GAAG,MAAM,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;YAEvD,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,KAAK,YAAY,CAAC,CAAC;QACvD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YAElB,OAAO,KAAK,CAAC;QACd,CAAC;IACF,CAAC;IAED,iBAAiB,CAAC,cAAuB;QACxC,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACtC,CAAC;IAEO,KAAK,CAAC,KAAa;QAC1B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;YAC7C,IAAI,CAAC,YAAY,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,4BAA4B,KAAK,EAAE,EAAE,CAAC,CAAC;QACtF,CAAC;IACF,CAAC;IAEO,IAAI,CAAC,OAAe;QAC3B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;YAC7C,IAAI,CAAC,YAAY,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,4BAA4B,OAAO,EAAE,EAAE,CAAC,CAAC;QACvF,CAAC;IACF,CAAC;IAEO,KAAK,CAAC,OAAe;QAC5B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,uBAAuB,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACpE,IAAI,CAAC,YAAY,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,4BAA4B,OAAO,EAAE,EAAE,CAAC,CAAC;QACxF,CAAC;IACF,CAAC;IAEO,oBAAoB,CAAC,OAAe;QAC3C,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,uBAAuB,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACpE,IAAI,CAAC,KAAK,CAAC,GAAG,OAAO,GAAG,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,OAAO,CAAC,aAAa,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QACtH,CAAC;IACF,CAAC;IAEQ,OAAO;QACf,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAEvB,KAAK,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;;AAGF;;;GAGG;AACH,MAAM,CAAC,KAAK,UAAU,iBAAiB,CAAC,IAAY,EAAE,MAAmC,EAAE,OAAmB,EAAE,KAAwB,EAAE,UAAU,GAAG,GAAG;IACzJ,MAAM,MAAM,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;IAC9C,MAAM,MAAM,GAAG,MAAM,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;IAE9C,MAAM,GAAG,GAAG,IAAI,uBAAuB,CAAC,KAAK,CAAC,CAAC;IAE/C,IAAI,KAAK,GAAsB,SAAS,CAAC;IACzC,IAAI,SAAS,GAAG,KAAK,CAAC;IAEtB,MAAM,OAAO,GAA8B,EAAE,IAAI,EAAE,QAAQ,EAAE,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC;IACpF,MAAM,OAAO,GAAG,IAAI,wBAAwB,CAAC,OAAO,EAAE,SAAS,EAAE,OAAO,CAAC,EAAE;QAC1E,CAAC,KAAK,IAAI,EAAE;YACX,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,OAAO,EAAE,CAAC;gBAChC,IAAI,IAAI,mCAA2B,EAAE,CAAC;oBAErC,IAAI,SAAS,EAAE,CAAC;wBACf,OAAO,CAAC,oDAAoD;oBAC7D,CAAC;oBAED,SAAS,GAAG,IAAI,CAAC;oBAEjB,IAAI,CAAC;wBACJ,sDAAsD;wBACtD,wDAAwD;wBACxD,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;4BAC3C,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;4BAC/E,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;gCACrD,MAAM;4BACP,CAAC;4BAED,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC;wBACpC,CAAC;oBACF,CAAC;oBAAC,OAAO,GAAG,EAAE,CAAC;wBACd,KAAK,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC;wBACvB,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;oBACnB,CAAC;4BAAS,CAAC;wBACV,SAAS,GAAG,KAAK,CAAC;oBACnB,CAAC;gBACF,CAAC;YACF,CAAC;QACF,CAAC,CAAC,EAAE,CAAC;IACN,CAAC,CAAC,CAAC;IAEH,MAAM,OAAO,CAAC,KAAK,CAAC;IACpB,OAAO,EAAE,CAAC;IAEV,OAAO,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QAC5C,GAAG,CAAC,KAAK,CAAC,uBAAuB,CAAC,KAAK,IAAI,EAAE;YAC5C,OAAO,CAAC,OAAO,EAAE,CAAC;YAElB,IAAI,CAAC;gBACJ,MAAM,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YAC9B,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;gBACd,KAAK,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC;YACxB,CAAC;YAED,IAAI,KAAK,EAAE,CAAC;gBACX,MAAM,CAAC,KAAK,CAAC,CAAC;YACf,CAAC;iBAAM,CAAC;gBACP,OAAO,EAAE,CAAC;YACX,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;AACJ,CAAC","file":"nodejsWatcherLib.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { watch, promises } from 'fs';\nimport { RunOnceWorker, ThrottledWorker } from '../../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { isEqual, isEqualOrParent } from '../../../../../base/common/extpath.js';\nimport { Disposable, DisposableStore, IDisposable, thenRegisterOrDispose, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { normalizeNFC } from '../../../../../base/common/normalization.js';\nimport { basename, dirname, join } from '../../../../../base/common/path.js';\nimport { isLinux, isMacintosh } from '../../../../../base/common/platform.js';\nimport { joinPath } from '../../../../../base/common/resources.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { Promises } from '../../../../../base/node/pfs.js';\nimport { FileChangeFilter, FileChangeType, IFileChange } from '../../../common/files.js';\nimport { ILogMessage, coalesceEvents, INonRecursiveWatchRequest, parseWatcherPatterns, IRecursiveWatcherWithSubscribe, isFiltered, isWatchRequestWithCorrelation } from '../../../common/watcher.js';\nimport { Lazy } from '../../../../../base/common/lazy.js';\nimport { ParsedPattern } from '../../../../../base/common/glob.js';\n\nexport class NodeJSFileWatcherLibrary extends Disposable {\n\n\t// A delay in reacting to file deletes to support\n\t// atomic save operations where a tool may chose\n\t// to delete a file before creating it again for\n\t// an update.\n\tprivate static readonly FILE_DELETE_HANDLER_DELAY = 100;\n\n\t// A delay for collecting file changes from node.js\n\t// before collecting them for coalescing and emitting\n\t// Same delay as used for the recursive watcher.\n\tprivate static readonly FILE_CHANGES_HANDLER_DELAY = 75;\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// These numbers are a bit more aggressive compared to the\n\t// recursive watcher because we can have many individual\n\t// node.js watchers per request.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesEmitter = this._register(new ThrottledWorker<IFileChange>(\n\t\t{\n\t\t\tmaxWorkChunkSize: 100,\t// only process up to 100 changes at once before...\n\t\t\tthrottleDelay: 200,\t  \t// ...resting for 200ms until we process events again...\n\t\t\tmaxBufferedWork: 10000 \t// ...but never buffering more than 10000 events in memory\n\t\t},\n\t\tevents => this.onDidFilesChange(events)\n\t));\n\n\t// Aggregate file changes over FILE_CHANGES_HANDLER_DELAY\n\t// to coalesce events and reduce spam.\n\tprivate readonly fileChangesAggregator = this._register(new RunOnceWorker<IFileChange>(events => this.handleFileChanges(events), NodeJSFileWatcherLibrary.FILE_CHANGES_HANDLER_DELAY));\n\n\tprivate readonly excludes: ParsedPattern[];\n\tprivate readonly includes: ParsedPattern[] | undefined;\n\tprivate readonly filter: FileChangeFilter | undefined;\n\n\tprivate readonly cts = new CancellationTokenSource();\n\n\tprivate readonly realPath = new Lazy(async () => {\n\n\t\t// This property is intentionally `Lazy` and not using `realcase()` as the counterpart\n\t\t// in the recursive watcher because of the amount of paths this watcher is dealing with.\n\t\t// We try as much as possible to avoid even needing `realpath()` if we can because even\n\t\t// that method does an `lstat()` per segment of the path.\n\n\t\tlet result = this.request.path;\n\n\t\ttry {\n\t\t\tresult = await Promises.realpath(this.request.path);\n\n\t\t\tif (this.request.path !== result) {\n\t\t\t\tthis.trace(`correcting a path to watch that seems to be a symbolic link (original: ${this.request.path}, real: ${result})`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn result;\n\t});\n\n\treadonly ready: Promise<void>;\n\n\tprivate _isReusingRecursiveWatcher = false;\n\tget isReusingRecursiveWatcher(): boolean { return this._isReusingRecursiveWatcher; }\n\n\tprivate didFail = false;\n\tget failed(): boolean { return this.didFail; }\n\n\tconstructor(\n\t\tprivate readonly request: INonRecursiveWatchRequest,\n\t\tprivate readonly recursiveWatcher: IRecursiveWatcherWithSubscribe | undefined,\n\t\tprivate readonly onDidFilesChange: (changes: IFileChange[]) => void,\n\t\tprivate readonly onDidWatchFail?: () => void,\n\t\tprivate readonly onLogMessage?: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging?: boolean\n\t) {\n\t\tsuper();\n\n\t\tthis.excludes = parseWatcherPatterns(this.request.path, this.request.excludes);\n\t\tthis.includes = this.request.includes ? parseWatcherPatterns(this.request.path, this.request.includes) : undefined;\n\t\tthis.filter = isWatchRequestWithCorrelation(this.request) ? this.request.filter : undefined; // filtering is only enabled when correlating because watchers are otherwise potentially reused\n\n\t\tthis.ready = this.watch();\n\t}\n\n\tprivate async watch(): Promise<void> {\n\t\ttry {\n\t\t\tconst stat = await promises.stat(this.request.path);\n\n\t\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._register(await this.doWatch(stat.isDirectory()));\n\t\t} catch (error) {\n\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\tthis.error(error);\n\t\t\t} else {\n\t\t\t\tthis.trace(`ignoring a path for watching who's stat info failed to resolve: ${this.request.path} (error: ${error})`);\n\t\t\t}\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate notifyWatchFailed(): void {\n\t\tthis.didFail = true;\n\n\t\tthis.onDidWatchFail?.();\n\t}\n\n\tprivate async doWatch(isDirectory: boolean): Promise<IDisposable> {\n\t\tconst disposables = new DisposableStore();\n\n\t\tif (this.doWatchWithExistingWatcher(isDirectory, disposables)) {\n\t\t\tthis.trace(`reusing an existing recursive watcher for ${this.request.path}`);\n\t\t\tthis._isReusingRecursiveWatcher = true;\n\t\t} else {\n\t\t\tthis._isReusingRecursiveWatcher = false;\n\t\t\tawait this.doWatchWithNodeJS(isDirectory, disposables);\n\t\t}\n\n\t\treturn disposables;\n\t}\n\n\tprivate doWatchWithExistingWatcher(isDirectory: boolean, disposables: DisposableStore): boolean {\n\t\tif (isDirectory) {\n\t\t\t// Recursive watcher re-use is currently not enabled for when\n\t\t\t// folders are watched. this is because the dispatching in the\n\t\t\t// recursive watcher for non-recurive requests is optimized for\n\t\t\t// file changes  where we really only match on the exact path\n\t\t\t// and not child paths.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst resource = URI.file(this.request.path);\n\t\tconst subscription = this.recursiveWatcher?.subscribe(this.request.path, async (error, change) => {\n\t\t\tif (disposables.isDisposed) {\n\t\t\t\treturn; // return early if already disposed\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tawait thenRegisterOrDispose(this.doWatch(isDirectory), disposables);\n\t\t\t} else if (change) {\n\t\t\t\tif (typeof change.cId === 'number' || typeof this.request.correlationId === 'number') {\n\t\t\t\t\t// Re-emit this change with the correlation id of the request\n\t\t\t\t\t// so that the client can correlate the event with the request\n\t\t\t\t\t// properly. Without correlation, we do not have to do that\n\t\t\t\t\t// because the event will appear on the global listener already.\n\t\t\t\t\tthis.onFileChange({ resource, type: change.type, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (subscription) {\n\t\t\tdisposables.add(subscription);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate async doWatchWithNodeJS(isDirectory: boolean, disposables: DisposableStore): Promise<void> {\n\t\tconst realPath = await this.realPath.value;\n\n\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// macOS: watching samba shares can crash VSCode so we do\n\t\t// a simple check for the file path pointing to /Volumes\n\t\t// (https://github.com/microsoft/vscode/issues/106879)\n\t\t// TODO@electron this needs a revisit when the crash is\n\t\t// fixed or mitigated upstream.\n\t\tif (isMacintosh && isEqualOrParent(realPath, '/Volumes/', true)) {\n\t\t\tthis.error(`Refusing to watch ${realPath} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource(this.cts.token);\n\t\tdisposables.add(toDisposable(() => cts.dispose(true)));\n\n\t\tconst watcherDisposables = new DisposableStore(); // we need a separate disposable store because we re-create the watcher from within in some cases\n\t\tdisposables.add(watcherDisposables);\n\n\t\ttry {\n\t\t\tconst requestResource = URI.file(this.request.path);\n\t\t\tconst pathBasename = basename(realPath);\n\n\t\t\t// Creating watcher can fail with an exception\n\t\t\tconst watcher = watch(realPath);\n\t\t\twatcherDisposables.add(toDisposable(() => {\n\t\t\t\twatcher.removeAllListeners();\n\t\t\t\twatcher.close();\n\t\t\t}));\n\n\t\t\tthis.trace(`Started watching: '${realPath}'`);\n\n\t\t\t// Folder: resolve children to emit proper events\n\t\t\tconst folderChildren = new Set<string>();\n\t\t\tif (isDirectory) {\n\t\t\t\ttry {\n\t\t\t\t\tfor (const child of await Promises.readdir(realPath)) {\n\t\t\t\t\t\tfolderChildren.add(child);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst mapPathToStatDisposable = new Map<string, IDisposable>();\n\t\t\twatcherDisposables.add(toDisposable(() => {\n\t\t\t\tfor (const [, disposable] of mapPathToStatDisposable) {\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t}\n\t\t\t\tmapPathToStatDisposable.clear();\n\t\t\t}));\n\n\t\t\twatcher.on('error', (code: number, signal: string) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.error(`Failed to watch ${realPath} for changes using fs.watch() (${code}, ${signal})`);\n\n\t\t\t\tthis.notifyWatchFailed();\n\t\t\t});\n\n\t\t\twatcher.on('change', (type, raw) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn; // ignore if already disposed\n\t\t\t\t}\n\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(`[raw] [\"${type}\"] ${raw}`);\n\t\t\t\t}\n\n\t\t\t\t// Normalize file name\n\t\t\t\tlet changedFileName = '';\n\t\t\t\tif (raw) { // https://github.com/microsoft/vscode/issues/38191\n\t\t\t\t\tchangedFileName = raw.toString();\n\t\t\t\t\tif (isMacintosh) {\n\t\t\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\t\t\tchangedFileName = normalizeNFC(changedFileName);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!changedFileName || (type !== 'change' && type !== 'rename')) {\n\t\t\t\t\treturn; // ignore unexpected events\n\t\t\t\t}\n\n\t\t\t\t// Folder\n\t\t\t\tif (isDirectory) {\n\n\t\t\t\t\t// Folder child added/deleted\n\t\t\t\t\tif (type === 'rename') {\n\n\t\t\t\t\t\t// Cancel any previous stats for this file if existing\n\t\t\t\t\t\tmapPathToStatDisposable.get(changedFileName)?.dispose();\n\n\t\t\t\t\t\t// Wait a bit and try see if the file still exists on disk\n\t\t\t\t\t\t// to decide on the resulting event\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tmapPathToStatDisposable.delete(changedFileName);\n\n\t\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t\t// folder path is being deleted:\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// -   macOS: not reported but events continue to\n\t\t\t\t\t\t\t//            work even when the folder is brought\n\t\t\t\t\t\t\t//            back, though it seems every change\n\t\t\t\t\t\t\t//            to a file is reported as \"rename\"\n\t\t\t\t\t\t\t// -   Linux: \"rename\" event is reported with the\n\t\t\t\t\t\t\t//            name of the folder and events stop\n\t\t\t\t\t\t\t//            working\n\t\t\t\t\t\t\t// - Windows: an EPERM error is thrown that we\n\t\t\t\t\t\t\t//            handle from the `on('error')` event\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// We do not re-attach the watcher after timeout\n\t\t\t\t\t\t\t// though as we do for file watches because for\n\t\t\t\t\t\t\t// file watching specifically we want to handle\n\t\t\t\t\t\t\t// the atomic-write cases where the file is being\n\t\t\t\t\t\t\t// deleted and recreated with different contents.\n\t\t\t\t\t\t\tif (isEqual(changedFileName, pathBasename, !isLinux) && !await Promises.exists(realPath)) {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// In order to properly detect renames on a case-insensitive\n\t\t\t\t\t\t\t// file system, we need to use `existsChildStrictCase` helper\n\t\t\t\t\t\t\t// because otherwise we would wrongly assume a file exists\n\t\t\t\t\t\t\t// when it was renamed to same name but different case.\n\t\t\t\t\t\t\tconst fileExists = await this.existsChildStrictCase(join(realPath, changedFileName));\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Figure out the correct event type:\n\t\t\t\t\t\t\t// File Exists: either 'added' or 'updated' if known before\n\t\t\t\t\t\t\t// File Does not Exist: always 'deleted'\n\t\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfolderChildren.delete(changedFileName);\n\t\t\t\t\t\t\t\ttype = FileChangeType.DELETED;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.onFileChange({ resource: joinPath(requestResource, changedFileName), type, cId: this.request.correlationId });\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\tmapPathToStatDisposable.set(changedFileName, toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Folder child changed\n\t\t\t\t\telse {\n\n\t\t\t\t\t\t// Figure out the correct event type: if this is the\n\t\t\t\t\t\t// first time we see this child, it can only be added\n\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.onFileChange({ resource: joinPath(requestResource, changedFileName), type, cId: this.request.correlationId });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// File\n\t\t\t\telse {\n\n\t\t\t\t\t// File added/deleted\n\t\t\t\t\tif (type === 'rename' || !isEqual(changedFileName, pathBasename, !isLinux)) {\n\n\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t// file path is being deleted:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// -   macOS: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// -   Linux: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// - Windows: \"rename\" event is reported and events\n\t\t\t\t\t\t//            continue to work when file is restored\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// As opposed to folder watching, we re-attach the\n\t\t\t\t\t\t// watcher after brief timeout to support \"atomic save\"\n\t\t\t\t\t\t// operations where a tool may decide to delete a file\n\t\t\t\t\t\t// and then create it with the updated contents.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Different to folder watching, we emit a delete event\n\t\t\t\t\t\t// though we never detect when the file is brought back\n\t\t\t\t\t\t// because the watcher is disposed then.\n\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tconst fileExists = await Promises.exists(realPath);\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File still exists, so emit as change event and reapply the watcher\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tthis.onFileChange({ resource: requestResource, type: FileChangeType.UPDATED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\n\t\t\t\t\t\t\t\twatcherDisposables.add(await this.doWatch(false));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File seems to be really gone, so emit a deleted and failed event\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\t// Very important to dispose the watcher which now points to a stale inode\n\t\t\t\t\t\t// and wire in a new disposable that tracks our timeout that is installed\n\t\t\t\t\t\twatcherDisposables.clear();\n\t\t\t\t\t\twatcherDisposables.add(toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// File changed\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.onFileChange({ resource: requestResource, type: FileChangeType.UPDATED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.error(`Failed to watch ${realPath} for changes using fs.watch() (${error.toString()})`);\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate onWatchedPathDeleted(resource: URI): void {\n\t\tthis.warn('Watcher shutdown because watched path got deleted');\n\n\t\t// Emit events and flush in case the watcher gets disposed\n\t\tthis.onFileChange({ resource, type: FileChangeType.DELETED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\tthis.fileChangesAggregator.flush();\n\n\t\tthis.notifyWatchFailed();\n\t}\n\n\tprivate onFileChange(event: IFileChange, skipIncludeExcludeChecks = false): void {\n\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tthis.traceWithCorrelation(`${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`);\n\t\t}\n\n\t\t// Add to aggregator unless excluded or not included (not if explicitly disabled)\n\t\tif (!skipIncludeExcludeChecks && this.excludes.some(exclude => exclude(event.resource.fsPath))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(` >> ignored (excluded) ${event.resource.fsPath}`);\n\t\t\t}\n\t\t} else if (!skipIncludeExcludeChecks && this.includes && this.includes.length > 0 && !this.includes.some(include => include(event.resource.fsPath))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(` >> ignored (not included) ${event.resource.fsPath}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.fileChangesAggregator.work(event);\n\t\t}\n\t}\n\n\tprivate handleFileChanges(fileChanges: IFileChange[]): void {\n\n\t\t// Coalesce events: merge events of same kind\n\t\tconst coalescedFileChanges = coalesceEvents(fileChanges);\n\n\t\t// Filter events: based on request filter property\n\t\tconst filteredEvents: IFileChange[] = [];\n\t\tfor (const event of coalescedFileChanges) {\n\t\t\tif (isFiltered(event, this.filter)) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(` >> ignored (filtered) ${event.resource.fsPath}`);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfilteredEvents.push(event);\n\t\t}\n\n\t\tif (filteredEvents.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tfor (const event of filteredEvents) {\n\t\t\t\tthis.traceWithCorrelation(` >> normalized ${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`);\n\t\t\t}\n\t\t}\n\n\t\t// Broadcast to clients via throttled emitter\n\t\tconst worked = this.throttledFileChangesEmitter.work(filteredEvents);\n\n\t\t// Logging\n\t\tif (!worked) {\n\t\t\tthis.warn(`started ignoring events due to too many file change events at once (incoming: ${filteredEvents.length}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t} else {\n\t\t\tif (this.throttledFileChangesEmitter.pending > 0) {\n\t\t\t\tthis.trace(`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async existsChildStrictCase(path: string): Promise<boolean> {\n\t\tif (isLinux) {\n\t\t\treturn Promises.exists(path);\n\t\t}\n\n\t\ttry {\n\t\t\tconst pathBasename = basename(path);\n\t\t\tconst children = await Promises.readdir(dirname(path));\n\n\t\t\treturn children.some(child => child === pathBasename);\n\t\t} catch (error) {\n\t\t\tthis.trace(error);\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsetVerboseLogging(verboseLogging: boolean): void {\n\t\tthis.verboseLogging = verboseLogging;\n\t}\n\n\tprivate error(error: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'error', message: `[File Watcher (node.js)] ${error}` });\n\t\t}\n\t}\n\n\tprivate warn(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'warn', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\tprivate trace(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.onLogMessage?.({ type: 'trace', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\tprivate traceWithCorrelation(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.trace(`${message}${typeof this.request.correlationId === 'number' ? ` <${this.request.correlationId}> ` : ``}`);\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis.cts.dispose(true);\n\n\t\tsuper.dispose();\n\t}\n}\n\n/**\n * Watch the provided `path` for changes and return\n * the data in chunks of `Uint8Array` for further use.\n */\nexport async function watchFileContents(path: string, onData: (chunk: Uint8Array) => void, onReady: () => void, token: CancellationToken, bufferSize = 512): Promise<void> {\n\tconst handle = await Promises.open(path, 'r');\n\tconst buffer = Buffer.allocUnsafe(bufferSize);\n\n\tconst cts = new CancellationTokenSource(token);\n\n\tlet error: Error | undefined = undefined;\n\tlet isReading = false;\n\n\tconst request: INonRecursiveWatchRequest = { path, excludes: [], recursive: false };\n\tconst watcher = new NodeJSFileWatcherLibrary(request, undefined, changes => {\n\t\t(async () => {\n\t\t\tfor (const { type } of changes) {\n\t\t\t\tif (type === FileChangeType.UPDATED) {\n\n\t\t\t\t\tif (isReading) {\n\t\t\t\t\t\treturn; // return early if we are already reading the output\n\t\t\t\t\t}\n\n\t\t\t\t\tisReading = true;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Consume the new contents of the file until finished\n\t\t\t\t\t\t// everytime there is a change event signalling a change\n\t\t\t\t\t\twhile (!cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\tconst { bytesRead } = await Promises.read(handle, buffer, 0, bufferSize, null);\n\t\t\t\t\t\t\tif (!bytesRead || cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tonData(buffer.slice(0, bytesRead));\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\terror = new Error(err);\n\t\t\t\t\t\tcts.dispose(true);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tisReading = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n\n\tawait watcher.ready;\n\tonReady();\n\n\treturn new Promise<void>((resolve, reject) => {\n\t\tcts.token.onCancellationRequested(async () => {\n\t\t\twatcher.dispose();\n\n\t\t\ttry {\n\t\t\t\tawait Promises.close(handle);\n\t\t\t} catch (err) {\n\t\t\t\terror = new Error(err);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { watch, promises } from 'fs';\nimport { RunOnceWorker, ThrottledWorker } from '../../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { isEqual, isEqualOrParent } from '../../../../../base/common/extpath.js';\nimport { Disposable, DisposableStore, IDisposable, thenRegisterOrDispose, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { normalizeNFC } from '../../../../../base/common/normalization.js';\nimport { basename, dirname, join } from '../../../../../base/common/path.js';\nimport { isLinux, isMacintosh } from '../../../../../base/common/platform.js';\nimport { joinPath } from '../../../../../base/common/resources.js';\nimport { URI } from '../../../../../base/common/uri.js';\nimport { Promises } from '../../../../../base/node/pfs.js';\nimport { FileChangeFilter, FileChangeType, IFileChange } from '../../../common/files.js';\nimport { ILogMessage, coalesceEvents, INonRecursiveWatchRequest, parseWatcherPatterns, IRecursiveWatcherWithSubscribe, isFiltered, isWatchRequestWithCorrelation } from '../../../common/watcher.js';\nimport { Lazy } from '../../../../../base/common/lazy.js';\nimport { ParsedPattern } from '../../../../../base/common/glob.js';\n\nexport class NodeJSFileWatcherLibrary extends Disposable {\n\n\t// A delay in reacting to file deletes to support\n\t// atomic save operations where a tool may chose\n\t// to delete a file before creating it again for\n\t// an update.\n\tprivate static readonly FILE_DELETE_HANDLER_DELAY = 100;\n\n\t// A delay for collecting file changes from node.js\n\t// before collecting them for coalescing and emitting\n\t// Same delay as used for the recursive watcher.\n\tprivate static readonly FILE_CHANGES_HANDLER_DELAY = 75;\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// These numbers are a bit more aggressive compared to the\n\t// recursive watcher because we can have many individual\n\t// node.js watchers per request.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesEmitter = this._register(new ThrottledWorker<IFileChange>(\n\t\t{\n\t\t\tmaxWorkChunkSize: 100,\t// only process up to 100 changes at once before...\n\t\t\tthrottleDelay: 200,\t  \t// ...resting for 200ms until we process events again...\n\t\t\tmaxBufferedWork: 10000 \t// ...but never buffering more than 10000 events in memory\n\t\t},\n\t\tevents => this.onDidFilesChange(events)\n\t));\n\n\t// Aggregate file changes over FILE_CHANGES_HANDLER_DELAY\n\t// to coalesce events and reduce spam.\n\tprivate readonly fileChangesAggregator = this._register(new RunOnceWorker<IFileChange>(events => this.handleFileChanges(events), NodeJSFileWatcherLibrary.FILE_CHANGES_HANDLER_DELAY));\n\n\tprivate readonly excludes: ParsedPattern[];\n\tprivate readonly includes: ParsedPattern[] | undefined;\n\tprivate readonly filter: FileChangeFilter | undefined;\n\n\tprivate readonly cts = new CancellationTokenSource();\n\n\tprivate readonly realPath = new Lazy(async () => {\n\n\t\t// This property is intentionally `Lazy` and not using `realcase()` as the counterpart\n\t\t// in the recursive watcher because of the amount of paths this watcher is dealing with.\n\t\t// We try as much as possible to avoid even needing `realpath()` if we can because even\n\t\t// that method does an `lstat()` per segment of the path.\n\n\t\tlet result = this.request.path;\n\n\t\ttry {\n\t\t\tresult = await Promises.realpath(this.request.path);\n\n\t\t\tif (this.request.path !== result) {\n\t\t\t\tthis.trace(`correcting a path to watch that seems to be a symbolic link (original: ${this.request.path}, real: ${result})`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn result;\n\t});\n\n\treadonly ready: Promise<void>;\n\n\tprivate _isReusingRecursiveWatcher = false;\n\tget isReusingRecursiveWatcher(): boolean { return this._isReusingRecursiveWatcher; }\n\n\tprivate didFail = false;\n\tget failed(): boolean { return this.didFail; }\n\n\tconstructor(\n\t\tprivate readonly request: INonRecursiveWatchRequest,\n\t\tprivate readonly recursiveWatcher: IRecursiveWatcherWithSubscribe | undefined,\n\t\tprivate readonly onDidFilesChange: (changes: IFileChange[]) => void,\n\t\tprivate readonly onDidWatchFail?: () => void,\n\t\tprivate readonly onLogMessage?: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging?: boolean\n\t) {\n\t\tsuper();\n\n\t\tthis.excludes = parseWatcherPatterns(this.request.path, this.request.excludes);\n\t\tthis.includes = this.request.includes ? parseWatcherPatterns(this.request.path, this.request.includes) : undefined;\n\t\tthis.filter = isWatchRequestWithCorrelation(this.request) ? this.request.filter : undefined; // filtering is only enabled when correlating because watchers are otherwise potentially reused\n\n\t\tthis.ready = this.watch();\n\t}\n\n\tprivate async watch(): Promise<void> {\n\t\ttry {\n\t\t\tconst stat = await promises.stat(this.request.path);\n\n\t\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._register(await this.doWatch(stat.isDirectory()));\n\t\t} catch (error) {\n\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\tthis.error(error);\n\t\t\t} else {\n\t\t\t\tthis.trace(`ignoring a path for watching who's stat info failed to resolve: ${this.request.path} (error: ${error})`);\n\t\t\t}\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate notifyWatchFailed(): void {\n\t\tthis.didFail = true;\n\n\t\tthis.onDidWatchFail?.();\n\t}\n\n\tprivate async doWatch(isDirectory: boolean): Promise<IDisposable> {\n\t\tconst disposables = new DisposableStore();\n\n\t\tif (this.doWatchWithExistingWatcher(isDirectory, disposables)) {\n\t\t\tthis.trace(`reusing an existing recursive watcher for ${this.request.path}`);\n\t\t\tthis._isReusingRecursiveWatcher = true;\n\t\t} else {\n\t\t\tthis._isReusingRecursiveWatcher = false;\n\t\t\tawait this.doWatchWithNodeJS(isDirectory, disposables);\n\t\t}\n\n\t\treturn disposables;\n\t}\n\n\tprivate doWatchWithExistingWatcher(isDirectory: boolean, disposables: DisposableStore): boolean {\n\t\tif (isDirectory) {\n\t\t\t// Recursive watcher re-use is currently not enabled for when\n\t\t\t// folders are watched. this is because the dispatching in the\n\t\t\t// recursive watcher for non-recurive requests is optimized for\n\t\t\t// file changes  where we really only match on the exact path\n\t\t\t// and not child paths.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst resource = URI.file(this.request.path);\n\t\tconst subscription = this.recursiveWatcher?.subscribe(this.request.path, async (error, change) => {\n\t\t\tif (disposables.isDisposed) {\n\t\t\t\treturn; // return early if already disposed\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tawait thenRegisterOrDispose(this.doWatch(isDirectory), disposables);\n\t\t\t} else if (change) {\n\t\t\t\tif (typeof change.cId === 'number' || typeof this.request.correlationId === 'number') {\n\t\t\t\t\t// Re-emit this change with the correlation id of the request\n\t\t\t\t\t// so that the client can correlate the event with the request\n\t\t\t\t\t// properly. Without correlation, we do not have to do that\n\t\t\t\t\t// because the event will appear on the global listener already.\n\t\t\t\t\tthis.onFileChange({ resource, type: change.type, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (subscription) {\n\t\t\tdisposables.add(subscription);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate async doWatchWithNodeJS(isDirectory: boolean, disposables: DisposableStore): Promise<void> {\n\t\tconst realPath = await this.realPath.value;\n\n\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// macOS: watching samba shares can crash VSCode so we do\n\t\t// a simple check for the file path pointing to /Volumes\n\t\t// (https://github.com/microsoft/vscode/issues/106879)\n\t\t// TODO@electron this needs a revisit when the crash is\n\t\t// fixed or mitigated upstream.\n\t\tif (isMacintosh && isEqualOrParent(realPath, '/Volumes/', true)) {\n\t\t\tthis.error(`Refusing to watch ${realPath} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource(this.cts.token);\n\t\tdisposables.add(toDisposable(() => cts.dispose(true)));\n\n\t\tconst watcherDisposables = new DisposableStore(); // we need a separate disposable store because we re-create the watcher from within in some cases\n\t\tdisposables.add(watcherDisposables);\n\n\t\ttry {\n\t\t\tconst requestResource = URI.file(this.request.path);\n\t\t\tconst pathBasename = basename(realPath);\n\n\t\t\t// Creating watcher can fail with an exception\n\t\t\tconst watcher = watch(realPath);\n\t\t\twatcherDisposables.add(toDisposable(() => {\n\t\t\t\twatcher.removeAllListeners();\n\t\t\t\twatcher.close();\n\t\t\t}));\n\n\t\t\tthis.trace(`Started watching: '${realPath}'`);\n\n\t\t\t// Folder: resolve children to emit proper events\n\t\t\tconst folderChildren = new Set<string>();\n\t\t\tif (isDirectory) {\n\t\t\t\ttry {\n\t\t\t\t\tfor (const child of await Promises.readdir(realPath)) {\n\t\t\t\t\t\tfolderChildren.add(child);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst mapPathToStatDisposable = new Map<string, IDisposable>();\n\t\t\twatcherDisposables.add(toDisposable(() => {\n\t\t\t\tfor (const [, disposable] of mapPathToStatDisposable) {\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t}\n\t\t\t\tmapPathToStatDisposable.clear();\n\t\t\t}));\n\n\t\t\twatcher.on('error', (code: number, signal: string) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.error(`Failed to watch ${realPath} for changes using fs.watch() (${code}, ${signal})`);\n\n\t\t\t\tthis.notifyWatchFailed();\n\t\t\t});\n\n\t\t\twatcher.on('change', (type, raw) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn; // ignore if already disposed\n\t\t\t\t}\n\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(`[raw] [\"${type}\"] ${raw}`);\n\t\t\t\t}\n\n\t\t\t\t// Normalize file name\n\t\t\t\tlet changedFileName = '';\n\t\t\t\tif (raw) { // https://github.com/microsoft/vscode/issues/38191\n\t\t\t\t\tchangedFileName = raw.toString();\n\t\t\t\t\tif (isMacintosh) {\n\t\t\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\t\t\tchangedFileName = normalizeNFC(changedFileName);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!changedFileName || (type !== 'change' && type !== 'rename')) {\n\t\t\t\t\treturn; // ignore unexpected events\n\t\t\t\t}\n\n\t\t\t\t// Folder\n\t\t\t\tif (isDirectory) {\n\n\t\t\t\t\t// Folder child added/deleted\n\t\t\t\t\tif (type === 'rename') {\n\n\t\t\t\t\t\t// Cancel any previous stats for this file if existing\n\t\t\t\t\t\tmapPathToStatDisposable.get(changedFileName)?.dispose();\n\n\t\t\t\t\t\t// Wait a bit and try see if the file still exists on disk\n\t\t\t\t\t\t// to decide on the resulting event\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tmapPathToStatDisposable.delete(changedFileName);\n\n\t\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t\t// folder path is being deleted:\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// -   macOS: not reported but events continue to\n\t\t\t\t\t\t\t//            work even when the folder is brought\n\t\t\t\t\t\t\t//            back, though it seems every change\n\t\t\t\t\t\t\t//            to a file is reported as \"rename\"\n\t\t\t\t\t\t\t// -   Linux: \"rename\" event is reported with the\n\t\t\t\t\t\t\t//            name of the folder and events stop\n\t\t\t\t\t\t\t//            working\n\t\t\t\t\t\t\t// - Windows: an EPERM error is thrown that we\n\t\t\t\t\t\t\t//            handle from the `on('error')` event\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// We do not re-attach the watcher after timeout\n\t\t\t\t\t\t\t// though as we do for file watches because for\n\t\t\t\t\t\t\t// file watching specifically we want to handle\n\t\t\t\t\t\t\t// the atomic-write cases where the file is being\n\t\t\t\t\t\t\t// deleted and recreated with different contents.\n\t\t\t\t\t\t\tif (isEqual(changedFileName, pathBasename, !isLinux) && !await Promises.exists(realPath)) {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// In order to properly detect renames on a case-insensitive\n\t\t\t\t\t\t\t// file system, we need to use `existsChildStrictCase` helper\n\t\t\t\t\t\t\t// because otherwise we would wrongly assume a file exists\n\t\t\t\t\t\t\t// when it was renamed to same name but different case.\n\t\t\t\t\t\t\tconst fileExists = await this.existsChildStrictCase(join(realPath, changedFileName));\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Figure out the correct event type:\n\t\t\t\t\t\t\t// File Exists: either 'added' or 'updated' if known before\n\t\t\t\t\t\t\t// File Does not Exist: always 'deleted'\n\t\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfolderChildren.delete(changedFileName);\n\t\t\t\t\t\t\t\ttype = FileChangeType.DELETED;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.onFileChange({ resource: joinPath(requestResource, changedFileName), type, cId: this.request.correlationId });\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\tmapPathToStatDisposable.set(changedFileName, toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Folder child changed\n\t\t\t\t\telse {\n\n\t\t\t\t\t\t// Figure out the correct event type: if this is the\n\t\t\t\t\t\t// first time we see this child, it can only be added\n\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.onFileChange({ resource: joinPath(requestResource, changedFileName), type, cId: this.request.correlationId });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// File\n\t\t\t\telse {\n\n\t\t\t\t\t// File added/deleted\n\t\t\t\t\tif (type === 'rename' || !isEqual(changedFileName, pathBasename, !isLinux)) {\n\n\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t// file path is being deleted:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// -   macOS: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// -   Linux: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// - Windows: \"rename\" event is reported and events\n\t\t\t\t\t\t//            continue to work when file is restored\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// As opposed to folder watching, we re-attach the\n\t\t\t\t\t\t// watcher after brief timeout to support \"atomic save\"\n\t\t\t\t\t\t// operations where a tool may decide to delete a file\n\t\t\t\t\t\t// and then create it with the updated contents.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Different to folder watching, we emit a delete event\n\t\t\t\t\t\t// though we never detect when the file is brought back\n\t\t\t\t\t\t// because the watcher is disposed then.\n\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tconst fileExists = await Promises.exists(realPath);\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File still exists, so emit as change event and reapply the watcher\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tthis.onFileChange({ resource: requestResource, type: FileChangeType.UPDATED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\n\t\t\t\t\t\t\t\twatcherDisposables.add(await this.doWatch(false));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File seems to be really gone, so emit a deleted and failed event\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.onWatchedPathDeleted(requestResource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\t// Very important to dispose the watcher which now points to a stale inode\n\t\t\t\t\t\t// and wire in a new disposable that tracks our timeout that is installed\n\t\t\t\t\t\twatcherDisposables.clear();\n\t\t\t\t\t\twatcherDisposables.add(toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// File changed\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.onFileChange({ resource: requestResource, type: FileChangeType.UPDATED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.error(`Failed to watch ${realPath} for changes using fs.watch() (${error.toString()})`);\n\n\t\t\tthis.notifyWatchFailed();\n\t\t}\n\t}\n\n\tprivate onWatchedPathDeleted(resource: URI): void {\n\t\tthis.warn('Watcher shutdown because watched path got deleted');\n\n\t\t// Emit events and flush in case the watcher gets disposed\n\t\tthis.onFileChange({ resource, type: FileChangeType.DELETED, cId: this.request.correlationId }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\tthis.fileChangesAggregator.flush();\n\n\t\tthis.notifyWatchFailed();\n\t}\n\n\tprivate onFileChange(event: IFileChange, skipIncludeExcludeChecks = false): void {\n\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tthis.traceWithCorrelation(`${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`);\n\t\t}\n\n\t\t// Add to aggregator unless excluded or not included (not if explicitly disabled)\n\t\tif (!skipIncludeExcludeChecks && this.excludes.some(exclude => exclude(event.resource.fsPath))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(` >> ignored (excluded) ${event.resource.fsPath}`);\n\t\t\t}\n\t\t} else if (!skipIncludeExcludeChecks && this.includes && this.includes.length > 0 && !this.includes.some(include => include(event.resource.fsPath))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.traceWithCorrelation(` >> ignored (not included) ${event.resource.fsPath}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.fileChangesAggregator.work(event);\n\t\t}\n\t}\n\n\tprivate handleFileChanges(fileChanges: IFileChange[]): void {\n\n\t\t// Coalesce events: merge events of same kind\n\t\tconst coalescedFileChanges = coalesceEvents(fileChanges);\n\n\t\t// Filter events: based on request filter property\n\t\tconst filteredEvents: IFileChange[] = [];\n\t\tfor (const event of coalescedFileChanges) {\n\t\t\tif (isFiltered(event, this.filter)) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.traceWithCorrelation(` >> ignored (filtered) ${event.resource.fsPath}`);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfilteredEvents.push(event);\n\t\t}\n\n\t\tif (filteredEvents.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tfor (const event of filteredEvents) {\n\t\t\t\tthis.traceWithCorrelation(` >> normalized ${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`);\n\t\t\t}\n\t\t}\n\n\t\t// Broadcast to clients via throttled emitter\n\t\tconst worked = this.throttledFileChangesEmitter.work(filteredEvents);\n\n\t\t// Logging\n\t\tif (!worked) {\n\t\t\tthis.warn(`started ignoring events due to too many file change events at once (incoming: ${filteredEvents.length}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t} else {\n\t\t\tif (this.throttledFileChangesEmitter.pending > 0) {\n\t\t\t\tthis.trace(`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${filteredEvents[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async existsChildStrictCase(path: string): Promise<boolean> {\n\t\tif (isLinux) {\n\t\t\treturn Promises.exists(path);\n\t\t}\n\n\t\ttry {\n\t\t\tconst pathBasename = basename(path);\n\t\t\tconst children = await Promises.readdir(dirname(path));\n\n\t\t\treturn children.some(child => child === pathBasename);\n\t\t} catch (error) {\n\t\t\tthis.trace(error);\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsetVerboseLogging(verboseLogging: boolean): void {\n\t\tthis.verboseLogging = verboseLogging;\n\t}\n\n\tprivate error(error: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'error', message: `[File Watcher (node.js)] ${error}` });\n\t\t}\n\t}\n\n\tprivate warn(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'warn', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\tprivate trace(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.onLogMessage?.({ type: 'trace', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\tprivate traceWithCorrelation(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.trace(`${message}${typeof this.request.correlationId === 'number' ? ` <${this.request.correlationId}> ` : ``}`);\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis.cts.dispose(true);\n\n\t\tsuper.dispose();\n\t}\n}\n\n/**\n * Watch the provided `path` for changes and return\n * the data in chunks of `Uint8Array` for further use.\n */\nexport async function watchFileContents(path: string, onData: (chunk: Uint8Array) => void, onReady: () => void, token: CancellationToken, bufferSize = 512): Promise<void> {\n\tconst handle = await Promises.open(path, 'r');\n\tconst buffer = Buffer.allocUnsafe(bufferSize);\n\n\tconst cts = new CancellationTokenSource(token);\n\n\tlet error: Error | undefined = undefined;\n\tlet isReading = false;\n\n\tconst request: INonRecursiveWatchRequest = { path, excludes: [], recursive: false };\n\tconst watcher = new NodeJSFileWatcherLibrary(request, undefined, changes => {\n\t\t(async () => {\n\t\t\tfor (const { type } of changes) {\n\t\t\t\tif (type === FileChangeType.UPDATED) {\n\n\t\t\t\t\tif (isReading) {\n\t\t\t\t\t\treturn; // return early if we are already reading the output\n\t\t\t\t\t}\n\n\t\t\t\t\tisReading = true;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Consume the new contents of the file until finished\n\t\t\t\t\t\t// everytime there is a change event signalling a change\n\t\t\t\t\t\twhile (!cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\tconst { bytesRead } = await Promises.read(handle, buffer, 0, bufferSize, null);\n\t\t\t\t\t\t\tif (!bytesRead || cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tonData(buffer.slice(0, bytesRead));\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\terror = new Error(err);\n\t\t\t\t\t\tcts.dispose(true);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tisReading = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n\n\tawait watcher.ready;\n\tonReady();\n\n\treturn new Promise<void>((resolve, reject) => {\n\t\tcts.token.onCancellationRequested(async () => {\n\t\t\twatcher.dispose();\n\n\t\t\ttry {\n\t\t\t\tawait Promises.close(handle);\n\t\t\t} catch (err) {\n\t\t\t\terror = new Error(err);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n"]}