{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/node/watcher/nodejs/nodejsWatcher.ts","vs/platform/files/node/watcher/nodejs/nodejsWatcher.ts"],"names":[],"mappings":"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","file":"nodejsWatcher.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../../base/common/event.js';\nimport { patternsEquals } from '../../../../../base/common/glob.js';\nimport { BaseWatcher } from '../baseWatcher.js';\nimport { isLinux } from '../../../../../base/common/platform.js';\nimport { INonRecursiveWatchRequest, INonRecursiveWatcher, IRecursiveWatcherWithSubscribe } from '../../../common/watcher.js';\nimport { NodeJSFileWatcherLibrary } from './nodejsWatcherLib.js';\nimport { ThrottledWorker } from '../../../../../base/common/async.js';\nimport { MutableDisposable } from '../../../../../base/common/lifecycle.js';\n\nexport interface INodeJSWatcherInstance {\n\n\t/**\n\t * The watcher instance.\n\t */\n\treadonly instance: NodeJSFileWatcherLibrary;\n\n\t/**\n\t * The watch request associated to the watcher.\n\t */\n\treadonly request: INonRecursiveWatchRequest;\n}\n\nexport class NodeJSWatcher extends BaseWatcher implements INonRecursiveWatcher {\n\n\treadonly onDidError = Event.None;\n\n\tprivate readonly _watchers = new Map<string /* path */ | number /* correlation ID */, INodeJSWatcherInstance>();\n\tget watchers() { return this._watchers.values(); }\n\n\tprivate readonly worker = this._register(new MutableDisposable<ThrottledWorker<INonRecursiveWatchRequest>>());\n\n\tconstructor(protected readonly recursiveWatcher: IRecursiveWatcherWithSubscribe | undefined) {\n\t\tsuper();\n\t}\n\n\tprotected override async doWatch(requests: INonRecursiveWatchRequest[]): Promise<void> {\n\n\t\t// Figure out duplicates to remove from the requests\n\t\trequests = this.removeDuplicateRequests(requests);\n\n\t\t// Figure out which watchers to start and which to stop\n\t\tconst requestsToStart: INonRecursiveWatchRequest[] = [];\n\t\tconst watchersToStop = new Set(Array.from(this.watchers));\n\t\tfor (const request of requests) {\n\t\t\tconst watcher = this._watchers.get(this.requestToWatcherKey(request));\n\t\t\tif (watcher && patternsEquals(watcher.request.excludes, request.excludes) && patternsEquals(watcher.request.includes, request.includes)) {\n\t\t\t\twatchersToStop.delete(watcher); // keep watcher\n\t\t\t} else {\n\t\t\t\trequestsToStart.push(request); // start watching\n\t\t\t}\n\t\t}\n\n\t\t// Logging\n\n\t\tif (requestsToStart.length) {\n\t\t\tthis.trace(`Request to start watching: ${requestsToStart.map(request => this.requestToString(request)).join(',')}`);\n\t\t}\n\n\t\tif (watchersToStop.size) {\n\t\t\tthis.trace(`Request to stop watching: ${Array.from(watchersToStop).map(watcher => this.requestToString(watcher.request)).join(',')}`);\n\t\t}\n\n\t\t// Stop the worker\n\t\tthis.worker.clear();\n\n\t\t// Stop watching as instructed\n\t\tfor (const watcher of watchersToStop) {\n\t\t\tthis.stopWatching(watcher);\n\t\t}\n\n\t\t// Start watching as instructed\n\t\tthis.createWatchWorker().work(requestsToStart);\n\t}\n\n\tprivate createWatchWorker(): ThrottledWorker<INonRecursiveWatchRequest> {\n\n\t\t// We see very large amount of non-recursive file watcher requests\n\t\t// in large workspaces. To prevent the overhead of starting thousands\n\t\t// of watchers at once, we use a throttled worker to distribute this\n\t\t// work over time.\n\n\t\tthis.worker.value = new ThrottledWorker<INonRecursiveWatchRequest>({\n\t\t\tmaxWorkChunkSize: 100,\t\t\t\t// only start 100 watchers at once before...\n\t\t\tthrottleDelay: 100,\t  \t\t\t\t// ...resting for 100ms until we start watchers again...\n\t\t\tmaxBufferedWork: Number.MAX_VALUE \t// ...and never refuse any work.\n\t\t}, requests => {\n\t\t\tfor (const request of requests) {\n\t\t\t\tthis.startWatching(request);\n\t\t\t}\n\t\t});\n\n\t\treturn this.worker.value;\n\t}\n\n\tprivate requestToWatcherKey(request: INonRecursiveWatchRequest): string | number {\n\t\treturn typeof request.correlationId === 'number' ? request.correlationId : this.pathToWatcherKey(request.path);\n\t}\n\n\tprivate pathToWatcherKey(path: string): string {\n\t\treturn isLinux ? path : path.toLowerCase() /* ignore path casing */;\n\t}\n\n\tprivate startWatching(request: INonRecursiveWatchRequest): void {\n\n\t\t// Start via node.js lib\n\t\tconst instance = new NodeJSFileWatcherLibrary(request, this.recursiveWatcher, changes => this._onDidChangeFile.fire(changes), () => this._onDidWatchFail.fire(request), msg => this._onDidLogMessage.fire(msg), this.verboseLogging);\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: INodeJSWatcherInstance = { request, instance };\n\t\tthis._watchers.set(this.requestToWatcherKey(request), watcher);\n\t}\n\n\toverride async stop(): Promise<void> {\n\t\tawait super.stop();\n\n\t\tfor (const watcher of this.watchers) {\n\t\t\tthis.stopWatching(watcher);\n\t\t}\n\t}\n\n\tprivate stopWatching(watcher: INodeJSWatcherInstance): void {\n\t\tthis.trace(`stopping file watcher`, watcher);\n\n\t\tthis._watchers.delete(this.requestToWatcherKey(watcher.request));\n\n\t\twatcher.instance.dispose();\n\t}\n\n\tprivate removeDuplicateRequests(requests: INonRecursiveWatchRequest[]): INonRecursiveWatchRequest[] {\n\t\tconst mapCorrelationtoRequests = new Map<number | undefined /* correlation */, Map<string, INonRecursiveWatchRequest>>();\n\n\t\t// Ignore requests for the same paths that have the same correlation\n\t\tfor (const request of requests) {\n\n\t\t\tlet requestsForCorrelation = mapCorrelationtoRequests.get(request.correlationId);\n\t\t\tif (!requestsForCorrelation) {\n\t\t\t\trequestsForCorrelation = new Map<string, INonRecursiveWatchRequest>();\n\t\t\t\tmapCorrelationtoRequests.set(request.correlationId, requestsForCorrelation);\n\t\t\t}\n\n\t\t\tconst path = this.pathToWatcherKey(request.path);\n\t\t\tif (requestsForCorrelation.has(path)) {\n\t\t\t\tthis.trace(`ignoring a request for watching who's path is already watched: ${this.requestToString(request)}`);\n\t\t\t}\n\n\t\t\trequestsForCorrelation.set(path, request);\n\t\t}\n\n\t\treturn Array.from(mapCorrelationtoRequests.values()).flatMap(requests => Array.from(requests.values()));\n\t}\n\n\toverride async setVerboseLogging(enabled: boolean): Promise<void> {\n\t\tsuper.setVerboseLogging(enabled);\n\n\t\tfor (const watcher of this.watchers) {\n\t\t\twatcher.instance.setVerboseLogging(enabled);\n\t\t}\n\t}\n\n\tprotected trace(message: string, watcher?: INodeJSWatcherInstance): void {\n\t\tif (this.verboseLogging) {\n\t\t\tthis._onDidLogMessage.fire({ type: 'trace', message: this.toMessage(message, watcher) });\n\t\t}\n\t}\n\n\tprotected warn(message: string): void {\n\t\tthis._onDidLogMessage.fire({ type: 'warn', message: this.toMessage(message) });\n\t}\n\n\tprivate toMessage(message: string, watcher?: INodeJSWatcherInstance): string {\n\t\treturn watcher ? `[File Watcher (node.js)] ${message} (${this.requestToString(watcher.request)})` : `[File Watcher (node.js)] ${message}`;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../../base/common/event.js';\nimport { patternsEquals } from '../../../../../base/common/glob.js';\nimport { BaseWatcher } from '../baseWatcher.js';\nimport { isLinux } from '../../../../../base/common/platform.js';\nimport { INonRecursiveWatchRequest, INonRecursiveWatcher, IRecursiveWatcherWithSubscribe } from '../../../common/watcher.js';\nimport { NodeJSFileWatcherLibrary } from './nodejsWatcherLib.js';\nimport { ThrottledWorker } from '../../../../../base/common/async.js';\nimport { MutableDisposable } from '../../../../../base/common/lifecycle.js';\n\nexport interface INodeJSWatcherInstance {\n\n\t/**\n\t * The watcher instance.\n\t */\n\treadonly instance: NodeJSFileWatcherLibrary;\n\n\t/**\n\t * The watch request associated to the watcher.\n\t */\n\treadonly request: INonRecursiveWatchRequest;\n}\n\nexport class NodeJSWatcher extends BaseWatcher implements INonRecursiveWatcher {\n\n\treadonly onDidError = Event.None;\n\n\tprivate readonly _watchers = new Map<string /* path */ | number /* correlation ID */, INodeJSWatcherInstance>();\n\tget watchers() { return this._watchers.values(); }\n\n\tprivate readonly worker = this._register(new MutableDisposable<ThrottledWorker<INonRecursiveWatchRequest>>());\n\n\tconstructor(protected readonly recursiveWatcher: IRecursiveWatcherWithSubscribe | undefined) {\n\t\tsuper();\n\t}\n\n\tprotected override async doWatch(requests: INonRecursiveWatchRequest[]): Promise<void> {\n\n\t\t// Figure out duplicates to remove from the requests\n\t\trequests = this.removeDuplicateRequests(requests);\n\n\t\t// Figure out which watchers to start and which to stop\n\t\tconst requestsToStart: INonRecursiveWatchRequest[] = [];\n\t\tconst watchersToStop = new Set(Array.from(this.watchers));\n\t\tfor (const request of requests) {\n\t\t\tconst watcher = this._watchers.get(this.requestToWatcherKey(request));\n\t\t\tif (watcher && patternsEquals(watcher.request.excludes, request.excludes) && patternsEquals(watcher.request.includes, request.includes)) {\n\t\t\t\twatchersToStop.delete(watcher); // keep watcher\n\t\t\t} else {\n\t\t\t\trequestsToStart.push(request); // start watching\n\t\t\t}\n\t\t}\n\n\t\t// Logging\n\n\t\tif (requestsToStart.length) {\n\t\t\tthis.trace(`Request to start watching: ${requestsToStart.map(request => this.requestToString(request)).join(',')}`);\n\t\t}\n\n\t\tif (watchersToStop.size) {\n\t\t\tthis.trace(`Request to stop watching: ${Array.from(watchersToStop).map(watcher => this.requestToString(watcher.request)).join(',')}`);\n\t\t}\n\n\t\t// Stop the worker\n\t\tthis.worker.clear();\n\n\t\t// Stop watching as instructed\n\t\tfor (const watcher of watchersToStop) {\n\t\t\tthis.stopWatching(watcher);\n\t\t}\n\n\t\t// Start watching as instructed\n\t\tthis.createWatchWorker().work(requestsToStart);\n\t}\n\n\tprivate createWatchWorker(): ThrottledWorker<INonRecursiveWatchRequest> {\n\n\t\t// We see very large amount of non-recursive file watcher requests\n\t\t// in large workspaces. To prevent the overhead of starting thousands\n\t\t// of watchers at once, we use a throttled worker to distribute this\n\t\t// work over time.\n\n\t\tthis.worker.value = new ThrottledWorker<INonRecursiveWatchRequest>({\n\t\t\tmaxWorkChunkSize: 100,\t\t\t\t// only start 100 watchers at once before...\n\t\t\tthrottleDelay: 100,\t  \t\t\t\t// ...resting for 100ms until we start watchers again...\n\t\t\tmaxBufferedWork: Number.MAX_VALUE \t// ...and never refuse any work.\n\t\t}, requests => {\n\t\t\tfor (const request of requests) {\n\t\t\t\tthis.startWatching(request);\n\t\t\t}\n\t\t});\n\n\t\treturn this.worker.value;\n\t}\n\n\tprivate requestToWatcherKey(request: INonRecursiveWatchRequest): string | number {\n\t\treturn typeof request.correlationId === 'number' ? request.correlationId : this.pathToWatcherKey(request.path);\n\t}\n\n\tprivate pathToWatcherKey(path: string): string {\n\t\treturn isLinux ? path : path.toLowerCase() /* ignore path casing */;\n\t}\n\n\tprivate startWatching(request: INonRecursiveWatchRequest): void {\n\n\t\t// Start via node.js lib\n\t\tconst instance = new NodeJSFileWatcherLibrary(request, this.recursiveWatcher, changes => this._onDidChangeFile.fire(changes), () => this._onDidWatchFail.fire(request), msg => this._onDidLogMessage.fire(msg), this.verboseLogging);\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: INodeJSWatcherInstance = { request, instance };\n\t\tthis._watchers.set(this.requestToWatcherKey(request), watcher);\n\t}\n\n\toverride async stop(): Promise<void> {\n\t\tawait super.stop();\n\n\t\tfor (const watcher of this.watchers) {\n\t\t\tthis.stopWatching(watcher);\n\t\t}\n\t}\n\n\tprivate stopWatching(watcher: INodeJSWatcherInstance): void {\n\t\tthis.trace(`stopping file watcher`, watcher);\n\n\t\tthis._watchers.delete(this.requestToWatcherKey(watcher.request));\n\n\t\twatcher.instance.dispose();\n\t}\n\n\tprivate removeDuplicateRequests(requests: INonRecursiveWatchRequest[]): INonRecursiveWatchRequest[] {\n\t\tconst mapCorrelationtoRequests = new Map<number | undefined /* correlation */, Map<string, INonRecursiveWatchRequest>>();\n\n\t\t// Ignore requests for the same paths that have the same correlation\n\t\tfor (const request of requests) {\n\n\t\t\tlet requestsForCorrelation = mapCorrelationtoRequests.get(request.correlationId);\n\t\t\tif (!requestsForCorrelation) {\n\t\t\t\trequestsForCorrelation = new Map<string, INonRecursiveWatchRequest>();\n\t\t\t\tmapCorrelationtoRequests.set(request.correlationId, requestsForCorrelation);\n\t\t\t}\n\n\t\t\tconst path = this.pathToWatcherKey(request.path);\n\t\t\tif (requestsForCorrelation.has(path)) {\n\t\t\t\tthis.trace(`ignoring a request for watching who's path is already watched: ${this.requestToString(request)}`);\n\t\t\t}\n\n\t\t\trequestsForCorrelation.set(path, request);\n\t\t}\n\n\t\treturn Array.from(mapCorrelationtoRequests.values()).flatMap(requests => Array.from(requests.values()));\n\t}\n\n\toverride async setVerboseLogging(enabled: boolean): Promise<void> {\n\t\tsuper.setVerboseLogging(enabled);\n\n\t\tfor (const watcher of this.watchers) {\n\t\t\twatcher.instance.setVerboseLogging(enabled);\n\t\t}\n\t}\n\n\tprotected trace(message: string, watcher?: INodeJSWatcherInstance): void {\n\t\tif (this.verboseLogging) {\n\t\t\tthis._onDidLogMessage.fire({ type: 'trace', message: this.toMessage(message, watcher) });\n\t\t}\n\t}\n\n\tprotected warn(message: string): void {\n\t\tthis._onDidLogMessage.fire({ type: 'warn', message: this.toMessage(message) });\n\t}\n\n\tprivate toMessage(message: string, watcher?: INodeJSWatcherInstance): string {\n\t\treturn watcher ? `[File Watcher (node.js)] ${message} (${this.requestToString(watcher.request)})` : `[File Watcher (node.js)] ${message}`;\n\t}\n}\n"]}