{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/node/watcher/baseWatcher.ts","vs/platform/files/node/watcher/baseWatcher.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,SAAS,EAAE,WAAW,EAAS,MAAM,IAAI,CAAC;AACnD,OAAO,EAAE,UAAU,EAAE,aAAa,EAAE,eAAe,EAAE,YAAY,EAAE,MAAM,sCAAsC,CAAC;AAChH,OAAO,EAAmI,6BAA6B,EAAE,qBAAqB,EAAE,MAAM,yBAAyB,CAAC;AAChO,OAAO,EAAE,OAAO,EAAS,MAAM,kCAAkC,CAAC;AAElE,OAAO,EAAE,GAAG,EAAE,MAAM,gCAAgC,CAAC;AACrD,OAAO,EAAE,eAAe,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AACrF,OAAO,EAAE,IAAI,EAAE,MAAM,iCAAiC,CAAC;AACvD,OAAO,EAAE,iBAAiB,EAAE,MAAM,mCAAmC,CAAC;AAQtE,MAAM,OAAgB,WAAY,SAAQ,UAAU;IAuBnD;QACC,KAAK,EAAE,CAAC;QAtBU,qBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAiB,CAAC,CAAC;QAC1E,oBAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC;QAEpC,qBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAe,CAAC,CAAC;QACxE,oBAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC;QAEpC,oBAAe,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAA0B,CAAC,CAAC;QAC1E,mBAAc,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC;QAE5C,4BAAuB,GAAG,IAAI,GAAG,EAAyD,CAAC;QAC3F,+BAA0B,GAAG,IAAI,GAAG,EAAmD,CAAC;QAExF,2BAAsB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,aAAa,EAA2B,CAAC,CAAC;QACtF,sCAAiC,GAAG,IAAI,GAAG,EAA2B,CAAC;QAEvE,0BAAqB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,gBAAgB,CAAO,IAAI,CAAC,sBAAsB,EAAE,CAAC,CAAC,CAAC;QAEhG,yCAAoC,GAAW,IAAI,CAAC,CAAC,kBAAkB;QAElF,cAAS,GAAG,IAAI,eAAe,EAAQ,CAAC;QAmOtC,mBAAc,GAAG,KAAK,CAAC;QA9NhC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,mBAAmB,CAAC;YACtE,EAAE,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;YAC3B,aAAa,EAAE,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,SAAS;YAC7E,IAAI,EAAE,OAAO,CAAC,IAAI;SAClB,CAAC,CAAC,CAAC,CAAC;IACN,CAAC;IAES,YAAY,CAAC,OAA+B;QACrD,OAAO,6BAA6B,CAAC,OAAO,CAAC,CAAC;IAC/C,CAAC;IAEO,SAAS,CAAC,OAA+B;QAChD,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,EAAE,CAAC;YAChC,OAAO,OAAO,CAAC,aAAa,CAAC;QAC9B,CAAC;aAAM,CAAC;YACP,iFAAiF;YACjF,8EAA8E;YAC9E,qEAAqE;YACrE,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC;QACtB,CAAC;IACF,CAAC;IAED,KAAK,CAAC,KAAK,CAAC,QAAkC;QAC7C,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,CAAC;YAC/B,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC;QAC3B,CAAC;QACD,IAAI,CAAC,SAAS,GAAG,IAAI,eAAe,EAAQ,CAAC;QAE7C,IAAI,CAAC;YACJ,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,CAAC;YACrC,IAAI,CAAC,0BAA0B,CAAC,KAAK,EAAE,CAAC;YAExC,oDAAoD;YACpD,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;gBAChC,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,EAAE,CAAC;oBAChC,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;gBAClE,CAAC;qBAAM,CAAC;oBACP,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,CAAC;gBACvE,CAAC;YACF,CAAC;YAED,iEAAiE;YACjE,KAAK,MAAM,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;gBAChD,IAAI,CAAC,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;oBACvF,IAAI,CAAC,sBAAsB,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC;oBACjD,IAAI,CAAC,iCAAiC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;gBACnD,CAAC;YACF,CAAC;YAED,OAAO,MAAM,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;QAC3D,CAAC;gBAAS,CAAC;YACV,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC;QAC3B,CAAC;IACF,CAAC;IAEO,cAAc,CAAC,OAAgB;QACtC,MAAM,oBAAoB,GAA6B,EAAE,CAAC;QAC1D,KAAK,MAAM,CAAC,EAAE,EAAE,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,0BAA0B,EAAE,GAAG,IAAI,CAAC,uBAAuB,CAAC,EAAE,CAAC;YACnG,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;gBAC1C,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACpC,CAAC;QACF,CAAC;QAED,OAAO,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,sBAAsB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC,CAAC;IAC3K,CAAC;IAES,sBAAsB;QAC/B,OAAO,GAAG,CAAC;IACZ,CAAC;IAED,WAAW,CAAC,OAA+B;QAC1C,MAAM,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QACnC,OAAO,IAAI,CAAC,iCAAiC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IACzG,CAAC;IAEO,KAAK,CAAC,mBAAmB,CAAC,OAA+B;QAChE,IAAI,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC;YACjD,OAAO,CAAC,oBAAoB;QAC7B,CAAC;QAED,MAAM,WAAW,GAAG,IAAI,eAAe,EAAE,CAAC;QAC1C,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,EAAE,WAAW,CAAC,CAAC;QAEzD,iEAAiE;QACjE,gEAAgE;QAChE,gEAAgE;QAChE,uCAAuC;QAEvC,MAAM,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;QAEvB,IAAI,WAAW,CAAC,UAAU,EAAE,CAAC;YAC5B,OAAO;QACR,CAAC;QAED,IAAI,CAAC,4BAA4B,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;QAExD,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,mFAAmF,CAAC,CAAC;IAC/G,CAAC;IAEO,kBAAkB,CAAC,OAA+B;QACzD,IAAI,CAAC,sBAAsB,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QACzD,IAAI,CAAC,iCAAiC,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QAE1D,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;IAC5B,CAAC;IAEO,4BAA4B,CAAC,OAA+B,EAAE,WAA4B;QACjG,IAAI,IAAI,CAAC,4BAA4B,CAAC,OAAO,EAAE,WAAW,CAAC,EAAE,CAAC;YAC7D,IAAI,CAAC,KAAK,CAAC,oDAAoD,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;YAC/E,IAAI,CAAC,iCAAiC,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QAC3D,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,mBAAmB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YAC/C,IAAI,CAAC,iCAAiC,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QACxD,CAAC;IACF,CAAC;IAEO,4BAA4B,CAAC,OAA+B,EAAE,WAA4B;QACjG,MAAM,YAAY,GAAG,IAAI,CAAC,gBAAgB,EAAE,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE;YACrF,IAAI,WAAW,CAAC,UAAU,EAAE,CAAC;gBAC5B,OAAO,CAAC,mCAAmC;YAC5C,CAAC;YAED,IAAI,KAAK,EAAE,CAAC;gBACX,IAAI,CAAC,4BAA4B,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YACzD,CAAC;iBAAM,IAAI,MAAM,EAAE,IAAI,iCAAyB,EAAE,CAAC;gBAClD,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;YACpC,CAAC;QACF,CAAC,CAAC,CAAC;QAEH,IAAI,YAAY,EAAE,CAAC;YAClB,WAAW,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;YAE9B,OAAO,IAAI,CAAC;QACb,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAEO,mBAAmB,CAAC,OAA+B,EAAE,WAA4B;QACxF,IAAI,YAAY,GAAG,KAAK,CAAC;QAEzB,MAAM,iBAAiB,GAAuC,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE;YAC5E,IAAI,WAAW,CAAC,UAAU,EAAE,CAAC;gBAC5B,OAAO,CAAC,mCAAmC;YAC5C,CAAC;YAED,MAAM,mBAAmB,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YACtD,MAAM,oBAAoB,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YACvD,MAAM,eAAe,GAAG,YAAY,CAAC;YACrC,YAAY,GAAG,mBAAmB,CAAC;YAEnC,8CAA8C;YAC9C,IAAI,CAAC,mBAAmB,IAAI,CAAC,oBAAoB,IAAI,eAAe,CAAC,EAAE,CAAC;gBACvE,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;YACpC,CAAC;QACF,CAAC,CAAC;QAEF,IAAI,CAAC,KAAK,CAAC,8BAA8B,OAAO,CAAC,IAAI,oBAAoB,OAAO,CAAC,aAAa,GAAG,CAAC,CAAC;QACnG,IAAI,CAAC;YACJ,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,UAAU,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,oCAAoC,EAAE,EAAE,iBAAiB,CAAC,CAAC;QACxH,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,CAAC,IAAI,CAAC,oCAAoC,KAAK,YAAY,OAAO,CAAC,IAAI,oBAAoB,OAAO,CAAC,aAAa,GAAG,CAAC,CAAC;QAC1H,CAAC;QAED,WAAW,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,EAAE;YACjC,IAAI,CAAC,KAAK,CAAC,8BAA8B,OAAO,CAAC,IAAI,oBAAoB,OAAO,CAAC,aAAa,GAAG,CAAC,CAAC;YAEnG,IAAI,CAAC;gBACJ,WAAW,CAAC,OAAO,CAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC;YAC9C,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBAChB,IAAI,CAAC,IAAI,CAAC,sCAAsC,KAAK,YAAY,OAAO,CAAC,IAAI,oBAAoB,OAAO,CAAC,aAAa,GAAG,CAAC,CAAC;YAC5H,CAAC;QACF,CAAC,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,oBAAoB,CAAC,OAA+B;QAC3D,IAAI,CAAC,KAAK,CAAC,YAAY,OAAO,CAAC,IAAI,mDAAmD,OAAO,CAAC,aAAa,GAAG,CAAC,CAAC;QAEhH,gBAAgB;QAChB,MAAM,KAAK,GAAgB,EAAE,QAAQ,EAAE,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,8BAAsB,EAAE,GAAG,EAAE,OAAO,CAAC,aAAa,EAAE,CAAC;QACxH,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;QACpC,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QAEhC,kBAAkB;QAClB,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;IAClC,CAAC;IAEO,cAAc,CAAC,KAAY;QAClC,OAAO,KAAK,CAAC,OAAO,KAAK,CAAC,IAAI,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;IAC/C,CAAC;IAED,KAAK,CAAC,IAAI;QACT,IAAI,CAAC,sBAAsB,CAAC,kBAAkB,EAAE,CAAC;QACjD,IAAI,CAAC,iCAAiC,CAAC,KAAK,EAAE,CAAC;IAChD,CAAC;IAES,UAAU,CAAC,KAAkB,EAAE,OAAwD;QAChG,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACzB,MAAM,QAAQ,GAAG,kBAAkB,KAAK,CAAC,IAAI,iCAAyB,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,mCAA2B,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,WAAW,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC;YAClL,IAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAC9C,CAAC;IACF,CAAC;IAES,oBAAoB,CAAC,OAAe,EAAE,OAAwD;QACvG,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACzB,IAAI,CAAC,KAAK,CAAC,GAAG,OAAO,GAAG,OAAO,OAAO,CAAC,aAAa,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC,aAAa,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QAC5G,CAAC;IACF,CAAC;IAES,eAAe,CAAC,OAA+B;QACxD,OAAO,GAAG,OAAO,CAAC,IAAI,eAAe,OAAO,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,eAAe,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,aAAa,qBAAqB,CAAC,OAAO,CAAC,MAAM,CAAC,oBAAoB,OAAO,OAAO,CAAC,aAAa,KAAK,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC;IAChW,CAAC;IAaD,KAAK,CAAC,iBAAiB,CAAC,OAAgB;QACvC,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC;IAC/B,CAAC;CACD","file":"baseWatcher.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { watchFile, unwatchFile, Stats } from 'fs';\nimport { Disposable, DisposableMap, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { ILogMessage, IRecursiveWatcherWithSubscribe, IUniversalWatchRequest, IWatchRequestWithCorrelation, IWatcher, IWatcherErrorEvent, isWatchRequestWithCorrelation, requestFilterToString } from '../../common/watcher.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { FileChangeType, IFileChange } from '../../common/files.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { DeferredPromise, ThrottledDelayer } from '../../../../base/common/async.js';\nimport { hash } from '../../../../base/common/hash.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\n\ninterface ISuspendedWatchRequest {\n\treadonly id: number;\n\treadonly correlationId: number | undefined;\n\treadonly path: string;\n}\n\nexport abstract class BaseWatcher extends Disposable implements IWatcher {\n\n\tprotected readonly _onDidChangeFile = this._register(new Emitter<IFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tprotected readonly _onDidLogMessage = this._register(new Emitter<ILogMessage>());\n\treadonly onDidLogMessage = this._onDidLogMessage.event;\n\n\tprotected readonly _onDidWatchFail = this._register(new Emitter<IUniversalWatchRequest>());\n\tprivate readonly onDidWatchFail = this._onDidWatchFail.event;\n\n\tprivate readonly correlatedWatchRequests = new Map<number /* request ID */, IWatchRequestWithCorrelation>();\n\tprivate readonly nonCorrelatedWatchRequests = new Map<number /* request ID */, IUniversalWatchRequest>();\n\n\tprivate readonly suspendedWatchRequests = this._register(new DisposableMap<number /* request ID */>());\n\tprivate readonly suspendedWatchRequestsWithPolling = new Set<number /* request ID */>();\n\n\tprivate readonly updateWatchersDelayer = this._register(new ThrottledDelayer<void>(this.getUpdateWatchersDelay()));\n\n\tprotected readonly suspendedWatchRequestPollingInterval: number = 5007; // node.js default\n\n\tprivate joinWatch = new DeferredPromise<void>();\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._register(this.onDidWatchFail(request => this.suspendWatchRequest({\n\t\t\tid: this.computeId(request),\n\t\t\tcorrelationId: this.isCorrelated(request) ? request.correlationId : undefined,\n\t\t\tpath: request.path\n\t\t})));\n\t}\n\n\tprotected isCorrelated(request: IUniversalWatchRequest): request is IWatchRequestWithCorrelation {\n\t\treturn isWatchRequestWithCorrelation(request);\n\t}\n\n\tprivate computeId(request: IUniversalWatchRequest): number {\n\t\tif (this.isCorrelated(request)) {\n\t\t\treturn request.correlationId;\n\t\t} else {\n\t\t\t// Requests without correlation do not carry any unique identifier, so we have to\n\t\t\t// come up with one based on the options of the request. This matches what the\n\t\t\t// file service does (vs/platform/files/common/fileService.ts#L1178).\n\t\t\treturn hash(request);\n\t\t}\n\t}\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tif (!this.joinWatch.isSettled) {\n\t\t\tthis.joinWatch.complete();\n\t\t}\n\t\tthis.joinWatch = new DeferredPromise<void>();\n\n\t\ttry {\n\t\t\tthis.correlatedWatchRequests.clear();\n\t\t\tthis.nonCorrelatedWatchRequests.clear();\n\n\t\t\t// Figure out correlated vs. non-correlated requests\n\t\t\tfor (const request of requests) {\n\t\t\t\tif (this.isCorrelated(request)) {\n\t\t\t\t\tthis.correlatedWatchRequests.set(request.correlationId, request);\n\t\t\t\t} else {\n\t\t\t\t\tthis.nonCorrelatedWatchRequests.set(this.computeId(request), request);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove all suspended watch requests that are no longer watched\n\t\t\tfor (const [id] of this.suspendedWatchRequests) {\n\t\t\t\tif (!this.nonCorrelatedWatchRequests.has(id) && !this.correlatedWatchRequests.has(id)) {\n\t\t\t\t\tthis.suspendedWatchRequests.deleteAndDispose(id);\n\t\t\t\t\tthis.suspendedWatchRequestsWithPolling.delete(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await this.updateWatchers(false /* not delayed */);\n\t\t} finally {\n\t\t\tthis.joinWatch.complete();\n\t\t}\n\t}\n\n\tprivate updateWatchers(delayed: boolean): Promise<void> {\n\t\tconst nonSuspendedRequests: IUniversalWatchRequest[] = [];\n\t\tfor (const [id, request] of [...this.nonCorrelatedWatchRequests, ...this.correlatedWatchRequests]) {\n\t\t\tif (!this.suspendedWatchRequests.has(id)) {\n\t\t\t\tnonSuspendedRequests.push(request);\n\t\t\t}\n\t\t}\n\n\t\treturn this.updateWatchersDelayer.trigger(() => this.doWatch(nonSuspendedRequests), delayed ? this.getUpdateWatchersDelay() : 0).catch(error => onUnexpectedError(error));\n\t}\n\n\tprotected getUpdateWatchersDelay(): number {\n\t\treturn 800;\n\t}\n\n\tisSuspended(request: IUniversalWatchRequest): 'polling' | boolean {\n\t\tconst id = this.computeId(request);\n\t\treturn this.suspendedWatchRequestsWithPolling.has(id) ? 'polling' : this.suspendedWatchRequests.has(id);\n\t}\n\n\tprivate async suspendWatchRequest(request: ISuspendedWatchRequest): Promise<void> {\n\t\tif (this.suspendedWatchRequests.has(request.id)) {\n\t\t\treturn; // already suspended\n\t\t}\n\n\t\tconst disposables = new DisposableStore();\n\t\tthis.suspendedWatchRequests.set(request.id, disposables);\n\n\t\t// It is possible that a watch request fails right during watch()\n\t\t// phase while other requests succeed. To increase the chance of\n\t\t// reusing another watcher for suspend/resume tracking, we await\n\t\t// all watch requests having processed.\n\n\t\tawait this.joinWatch.p;\n\n\t\tif (disposables.isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.monitorSuspendedWatchRequest(request, disposables);\n\n\t\tthis.updateWatchers(true /* delay this call as we might accumulate many failing watch requests on startup */);\n\t}\n\n\tprivate resumeWatchRequest(request: ISuspendedWatchRequest): void {\n\t\tthis.suspendedWatchRequests.deleteAndDispose(request.id);\n\t\tthis.suspendedWatchRequestsWithPolling.delete(request.id);\n\n\t\tthis.updateWatchers(false);\n\t}\n\n\tprivate monitorSuspendedWatchRequest(request: ISuspendedWatchRequest, disposables: DisposableStore): void {\n\t\tif (this.doMonitorWithExistingWatcher(request, disposables)) {\n\t\t\tthis.trace(`reusing an existing recursive watcher to monitor ${request.path}`);\n\t\t\tthis.suspendedWatchRequestsWithPolling.delete(request.id);\n\t\t} else {\n\t\t\tthis.doMonitorWithNodeJS(request, disposables);\n\t\t\tthis.suspendedWatchRequestsWithPolling.add(request.id);\n\t\t}\n\t}\n\n\tprivate doMonitorWithExistingWatcher(request: ISuspendedWatchRequest, disposables: DisposableStore): boolean {\n\t\tconst subscription = this.recursiveWatcher?.subscribe(request.path, (error, change) => {\n\t\t\tif (disposables.isDisposed) {\n\t\t\t\treturn; // return early if already disposed\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tthis.monitorSuspendedWatchRequest(request, disposables);\n\t\t\t} else if (change?.type === FileChangeType.ADDED) {\n\t\t\t\tthis.onMonitoredPathAdded(request);\n\t\t\t}\n\t\t});\n\n\t\tif (subscription) {\n\t\t\tdisposables.add(subscription);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate doMonitorWithNodeJS(request: ISuspendedWatchRequest, disposables: DisposableStore): void {\n\t\tlet pathNotFound = false;\n\n\t\tconst watchFileCallback: (curr: Stats, prev: Stats) => void = (curr, prev) => {\n\t\t\tif (disposables.isDisposed) {\n\t\t\t\treturn; // return early if already disposed\n\t\t\t}\n\n\t\t\tconst currentPathNotFound = this.isPathNotFound(curr);\n\t\t\tconst previousPathNotFound = this.isPathNotFound(prev);\n\t\t\tconst oldPathNotFound = pathNotFound;\n\t\t\tpathNotFound = currentPathNotFound;\n\n\t\t\t// Watch path created: resume watching request\n\t\t\tif (!currentPathNotFound && (previousPathNotFound || oldPathNotFound)) {\n\t\t\t\tthis.onMonitoredPathAdded(request);\n\t\t\t}\n\t\t};\n\n\t\tthis.trace(`starting fs.watchFile() on ${request.path} (correlationId: ${request.correlationId})`);\n\t\ttry {\n\t\t\twatchFile(request.path, { persistent: false, interval: this.suspendedWatchRequestPollingInterval }, watchFileCallback);\n\t\t} catch (error) {\n\t\t\tthis.warn(`fs.watchFile() failed with error ${error} on path ${request.path} (correlationId: ${request.correlationId})`);\n\t\t}\n\n\t\tdisposables.add(toDisposable(() => {\n\t\t\tthis.trace(`stopping fs.watchFile() on ${request.path} (correlationId: ${request.correlationId})`);\n\n\t\t\ttry {\n\t\t\t\tunwatchFile(request.path, watchFileCallback);\n\t\t\t} catch (error) {\n\t\t\t\tthis.warn(`fs.unwatchFile() failed with error ${error} on path ${request.path} (correlationId: ${request.correlationId})`);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate onMonitoredPathAdded(request: ISuspendedWatchRequest): void {\n\t\tthis.trace(`detected ${request.path} exists again, resuming watcher (correlationId: ${request.correlationId})`);\n\n\t\t// Emit as event\n\t\tconst event: IFileChange = { resource: URI.file(request.path), type: FileChangeType.ADDED, cId: request.correlationId };\n\t\tthis._onDidChangeFile.fire([event]);\n\t\tthis.traceEvent(event, request);\n\n\t\t// Resume watching\n\t\tthis.resumeWatchRequest(request);\n\t}\n\n\tprivate isPathNotFound(stats: Stats): boolean {\n\t\treturn stats.ctimeMs === 0 && stats.ino === 0;\n\t}\n\n\tasync stop(): Promise<void> {\n\t\tthis.suspendedWatchRequests.clearAndDisposeAll();\n\t\tthis.suspendedWatchRequestsWithPolling.clear();\n\t}\n\n\tprotected traceEvent(event: IFileChange, request: IUniversalWatchRequest | ISuspendedWatchRequest): void {\n\t\tif (this.verboseLogging) {\n\t\t\tconst traceMsg = ` >> normalized ${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`;\n\t\t\tthis.traceWithCorrelation(traceMsg, request);\n\t\t}\n\t}\n\n\tprotected traceWithCorrelation(message: string, request: IUniversalWatchRequest | ISuspendedWatchRequest): void {\n\t\tif (this.verboseLogging) {\n\t\t\tthis.trace(`${message}${typeof request.correlationId === 'number' ? ` <${request.correlationId}> ` : ``}`);\n\t\t}\n\t}\n\n\tprotected requestToString(request: IUniversalWatchRequest): string {\n\t\treturn `${request.path} (excludes: ${request.excludes.length > 0 ? request.excludes : '<none>'}, includes: ${request.includes && request.includes.length > 0 ? JSON.stringify(request.includes) : '<all>'}, filter: ${requestFilterToString(request.filter)}, correlationId: ${typeof request.correlationId === 'number' ? request.correlationId : '<none>'})`;\n\t}\n\n\tprotected abstract doWatch(requests: IUniversalWatchRequest[]): Promise<void>;\n\n\tprotected abstract readonly recursiveWatcher: IRecursiveWatcherWithSubscribe | undefined;\n\n\tprotected abstract trace(message: string): void;\n\tprotected abstract warn(message: string): void;\n\n\tabstract onDidError: Event<IWatcherErrorEvent>;\n\n\tprotected verboseLogging = false;\n\n\tasync setVerboseLogging(enabled: boolean): Promise<void> {\n\t\tthis.verboseLogging = enabled;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { watchFile, unwatchFile, Stats } from 'fs';\nimport { Disposable, DisposableMap, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { ILogMessage, IRecursiveWatcherWithSubscribe, IUniversalWatchRequest, IWatchRequestWithCorrelation, IWatcher, IWatcherErrorEvent, isWatchRequestWithCorrelation, requestFilterToString } from '../../common/watcher.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { FileChangeType, IFileChange } from '../../common/files.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { DeferredPromise, ThrottledDelayer } from '../../../../base/common/async.js';\nimport { hash } from '../../../../base/common/hash.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\n\ninterface ISuspendedWatchRequest {\n\treadonly id: number;\n\treadonly correlationId: number | undefined;\n\treadonly path: string;\n}\n\nexport abstract class BaseWatcher extends Disposable implements IWatcher {\n\n\tprotected readonly _onDidChangeFile = this._register(new Emitter<IFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tprotected readonly _onDidLogMessage = this._register(new Emitter<ILogMessage>());\n\treadonly onDidLogMessage = this._onDidLogMessage.event;\n\n\tprotected readonly _onDidWatchFail = this._register(new Emitter<IUniversalWatchRequest>());\n\tprivate readonly onDidWatchFail = this._onDidWatchFail.event;\n\n\tprivate readonly correlatedWatchRequests = new Map<number /* request ID */, IWatchRequestWithCorrelation>();\n\tprivate readonly nonCorrelatedWatchRequests = new Map<number /* request ID */, IUniversalWatchRequest>();\n\n\tprivate readonly suspendedWatchRequests = this._register(new DisposableMap<number /* request ID */>());\n\tprivate readonly suspendedWatchRequestsWithPolling = new Set<number /* request ID */>();\n\n\tprivate readonly updateWatchersDelayer = this._register(new ThrottledDelayer<void>(this.getUpdateWatchersDelay()));\n\n\tprotected readonly suspendedWatchRequestPollingInterval: number = 5007; // node.js default\n\n\tprivate joinWatch = new DeferredPromise<void>();\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._register(this.onDidWatchFail(request => this.suspendWatchRequest({\n\t\t\tid: this.computeId(request),\n\t\t\tcorrelationId: this.isCorrelated(request) ? request.correlationId : undefined,\n\t\t\tpath: request.path\n\t\t})));\n\t}\n\n\tprotected isCorrelated(request: IUniversalWatchRequest): request is IWatchRequestWithCorrelation {\n\t\treturn isWatchRequestWithCorrelation(request);\n\t}\n\n\tprivate computeId(request: IUniversalWatchRequest): number {\n\t\tif (this.isCorrelated(request)) {\n\t\t\treturn request.correlationId;\n\t\t} else {\n\t\t\t// Requests without correlation do not carry any unique identifier, so we have to\n\t\t\t// come up with one based on the options of the request. This matches what the\n\t\t\t// file service does (vs/platform/files/common/fileService.ts#L1178).\n\t\t\treturn hash(request);\n\t\t}\n\t}\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tif (!this.joinWatch.isSettled) {\n\t\t\tthis.joinWatch.complete();\n\t\t}\n\t\tthis.joinWatch = new DeferredPromise<void>();\n\n\t\ttry {\n\t\t\tthis.correlatedWatchRequests.clear();\n\t\t\tthis.nonCorrelatedWatchRequests.clear();\n\n\t\t\t// Figure out correlated vs. non-correlated requests\n\t\t\tfor (const request of requests) {\n\t\t\t\tif (this.isCorrelated(request)) {\n\t\t\t\t\tthis.correlatedWatchRequests.set(request.correlationId, request);\n\t\t\t\t} else {\n\t\t\t\t\tthis.nonCorrelatedWatchRequests.set(this.computeId(request), request);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove all suspended watch requests that are no longer watched\n\t\t\tfor (const [id] of this.suspendedWatchRequests) {\n\t\t\t\tif (!this.nonCorrelatedWatchRequests.has(id) && !this.correlatedWatchRequests.has(id)) {\n\t\t\t\t\tthis.suspendedWatchRequests.deleteAndDispose(id);\n\t\t\t\t\tthis.suspendedWatchRequestsWithPolling.delete(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await this.updateWatchers(false /* not delayed */);\n\t\t} finally {\n\t\t\tthis.joinWatch.complete();\n\t\t}\n\t}\n\n\tprivate updateWatchers(delayed: boolean): Promise<void> {\n\t\tconst nonSuspendedRequests: IUniversalWatchRequest[] = [];\n\t\tfor (const [id, request] of [...this.nonCorrelatedWatchRequests, ...this.correlatedWatchRequests]) {\n\t\t\tif (!this.suspendedWatchRequests.has(id)) {\n\t\t\t\tnonSuspendedRequests.push(request);\n\t\t\t}\n\t\t}\n\n\t\treturn this.updateWatchersDelayer.trigger(() => this.doWatch(nonSuspendedRequests), delayed ? this.getUpdateWatchersDelay() : 0).catch(error => onUnexpectedError(error));\n\t}\n\n\tprotected getUpdateWatchersDelay(): number {\n\t\treturn 800;\n\t}\n\n\tisSuspended(request: IUniversalWatchRequest): 'polling' | boolean {\n\t\tconst id = this.computeId(request);\n\t\treturn this.suspendedWatchRequestsWithPolling.has(id) ? 'polling' : this.suspendedWatchRequests.has(id);\n\t}\n\n\tprivate async suspendWatchRequest(request: ISuspendedWatchRequest): Promise<void> {\n\t\tif (this.suspendedWatchRequests.has(request.id)) {\n\t\t\treturn; // already suspended\n\t\t}\n\n\t\tconst disposables = new DisposableStore();\n\t\tthis.suspendedWatchRequests.set(request.id, disposables);\n\n\t\t// It is possible that a watch request fails right during watch()\n\t\t// phase while other requests succeed. To increase the chance of\n\t\t// reusing another watcher for suspend/resume tracking, we await\n\t\t// all watch requests having processed.\n\n\t\tawait this.joinWatch.p;\n\n\t\tif (disposables.isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.monitorSuspendedWatchRequest(request, disposables);\n\n\t\tthis.updateWatchers(true /* delay this call as we might accumulate many failing watch requests on startup */);\n\t}\n\n\tprivate resumeWatchRequest(request: ISuspendedWatchRequest): void {\n\t\tthis.suspendedWatchRequests.deleteAndDispose(request.id);\n\t\tthis.suspendedWatchRequestsWithPolling.delete(request.id);\n\n\t\tthis.updateWatchers(false);\n\t}\n\n\tprivate monitorSuspendedWatchRequest(request: ISuspendedWatchRequest, disposables: DisposableStore): void {\n\t\tif (this.doMonitorWithExistingWatcher(request, disposables)) {\n\t\t\tthis.trace(`reusing an existing recursive watcher to monitor ${request.path}`);\n\t\t\tthis.suspendedWatchRequestsWithPolling.delete(request.id);\n\t\t} else {\n\t\t\tthis.doMonitorWithNodeJS(request, disposables);\n\t\t\tthis.suspendedWatchRequestsWithPolling.add(request.id);\n\t\t}\n\t}\n\n\tprivate doMonitorWithExistingWatcher(request: ISuspendedWatchRequest, disposables: DisposableStore): boolean {\n\t\tconst subscription = this.recursiveWatcher?.subscribe(request.path, (error, change) => {\n\t\t\tif (disposables.isDisposed) {\n\t\t\t\treturn; // return early if already disposed\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tthis.monitorSuspendedWatchRequest(request, disposables);\n\t\t\t} else if (change?.type === FileChangeType.ADDED) {\n\t\t\t\tthis.onMonitoredPathAdded(request);\n\t\t\t}\n\t\t});\n\n\t\tif (subscription) {\n\t\t\tdisposables.add(subscription);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate doMonitorWithNodeJS(request: ISuspendedWatchRequest, disposables: DisposableStore): void {\n\t\tlet pathNotFound = false;\n\n\t\tconst watchFileCallback: (curr: Stats, prev: Stats) => void = (curr, prev) => {\n\t\t\tif (disposables.isDisposed) {\n\t\t\t\treturn; // return early if already disposed\n\t\t\t}\n\n\t\t\tconst currentPathNotFound = this.isPathNotFound(curr);\n\t\t\tconst previousPathNotFound = this.isPathNotFound(prev);\n\t\t\tconst oldPathNotFound = pathNotFound;\n\t\t\tpathNotFound = currentPathNotFound;\n\n\t\t\t// Watch path created: resume watching request\n\t\t\tif (!currentPathNotFound && (previousPathNotFound || oldPathNotFound)) {\n\t\t\t\tthis.onMonitoredPathAdded(request);\n\t\t\t}\n\t\t};\n\n\t\tthis.trace(`starting fs.watchFile() on ${request.path} (correlationId: ${request.correlationId})`);\n\t\ttry {\n\t\t\twatchFile(request.path, { persistent: false, interval: this.suspendedWatchRequestPollingInterval }, watchFileCallback);\n\t\t} catch (error) {\n\t\t\tthis.warn(`fs.watchFile() failed with error ${error} on path ${request.path} (correlationId: ${request.correlationId})`);\n\t\t}\n\n\t\tdisposables.add(toDisposable(() => {\n\t\t\tthis.trace(`stopping fs.watchFile() on ${request.path} (correlationId: ${request.correlationId})`);\n\n\t\t\ttry {\n\t\t\t\tunwatchFile(request.path, watchFileCallback);\n\t\t\t} catch (error) {\n\t\t\t\tthis.warn(`fs.unwatchFile() failed with error ${error} on path ${request.path} (correlationId: ${request.correlationId})`);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate onMonitoredPathAdded(request: ISuspendedWatchRequest): void {\n\t\tthis.trace(`detected ${request.path} exists again, resuming watcher (correlationId: ${request.correlationId})`);\n\n\t\t// Emit as event\n\t\tconst event: IFileChange = { resource: URI.file(request.path), type: FileChangeType.ADDED, cId: request.correlationId };\n\t\tthis._onDidChangeFile.fire([event]);\n\t\tthis.traceEvent(event, request);\n\n\t\t// Resume watching\n\t\tthis.resumeWatchRequest(request);\n\t}\n\n\tprivate isPathNotFound(stats: Stats): boolean {\n\t\treturn stats.ctimeMs === 0 && stats.ino === 0;\n\t}\n\n\tasync stop(): Promise<void> {\n\t\tthis.suspendedWatchRequests.clearAndDisposeAll();\n\t\tthis.suspendedWatchRequestsWithPolling.clear();\n\t}\n\n\tprotected traceEvent(event: IFileChange, request: IUniversalWatchRequest | ISuspendedWatchRequest): void {\n\t\tif (this.verboseLogging) {\n\t\t\tconst traceMsg = ` >> normalized ${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.resource.fsPath}`;\n\t\t\tthis.traceWithCorrelation(traceMsg, request);\n\t\t}\n\t}\n\n\tprotected traceWithCorrelation(message: string, request: IUniversalWatchRequest | ISuspendedWatchRequest): void {\n\t\tif (this.verboseLogging) {\n\t\t\tthis.trace(`${message}${typeof request.correlationId === 'number' ? ` <${request.correlationId}> ` : ``}`);\n\t\t}\n\t}\n\n\tprotected requestToString(request: IUniversalWatchRequest): string {\n\t\treturn `${request.path} (excludes: ${request.excludes.length > 0 ? request.excludes : '<none>'}, includes: ${request.includes && request.includes.length > 0 ? JSON.stringify(request.includes) : '<all>'}, filter: ${requestFilterToString(request.filter)}, correlationId: ${typeof request.correlationId === 'number' ? request.correlationId : '<none>'})`;\n\t}\n\n\tprotected abstract doWatch(requests: IUniversalWatchRequest[]): Promise<void>;\n\n\tprotected abstract readonly recursiveWatcher: IRecursiveWatcherWithSubscribe | undefined;\n\n\tprotected abstract trace(message: string): void;\n\tprotected abstract warn(message: string): void;\n\n\tabstract onDidError: Event<IWatcherErrorEvent>;\n\n\tprotected verboseLogging = false;\n\n\tasync setVerboseLogging(enabled: boolean): Promise<void> {\n\t\tthis.verboseLogging = enabled;\n\t}\n}\n"]}