{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/node/diskFileSystemProviderServer.ts","vs/platform/files/node/diskFileSystemProviderServer.ts"],"names":[],"mappings":"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","file":"diskFileSystemProviderServer.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IServerChannel } from '../../../base/parts/ipc/common/ipc.js';\nimport { DiskFileSystemProvider } from './diskFileSystemProvider.js';\nimport { Disposable, dispose, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IURITransformer } from '../../../base/common/uriIpc.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { ReadableStreamEventPayload, listenStream } from '../../../base/common/stream.js';\nimport { IStat, IFileReadStreamOptions, IFileWriteOptions, IFileOpenOptions, IFileDeleteOptions, IFileOverwriteOptions, IFileChange, IWatchOptions, FileType, IFileAtomicReadOptions } from '../common/files.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { IEnvironmentService } from '../../environment/common/environment.js';\nimport { IRecursiveWatcherOptions } from '../common/watcher.js';\n\nexport interface ISessionFileWatcher extends IDisposable {\n\twatch(req: number, resource: URI, opts: IWatchOptions): IDisposable;\n}\n\n/**\n * A server implementation for a IPC based file system provider client.\n */\nexport abstract class AbstractDiskFileSystemProviderChannel<T> extends Disposable implements IServerChannel<T> {\n\n\tconstructor(\n\t\tprotected readonly provider: DiskFileSystemProvider,\n\t\tprotected readonly logService: ILogService\n\t) {\n\t\tsuper();\n\t}\n\n\tcall<TResult>(ctx: T, command: string, args: unknown[]): Promise<TResult> {\n\t\tconst uriTransformer = this.getUriTransformer(ctx);\n\n\t\tswitch (command) {\n\t\t\tcase 'stat': return this.stat(uriTransformer, args[0] as UriComponents) as Promise<TResult>;\n\t\t\tcase 'realpath': return this.realpath(uriTransformer, args[0] as UriComponents) as Promise<TResult>;\n\t\t\tcase 'readdir': return this.readdir(uriTransformer, args[0] as UriComponents) as Promise<TResult>;\n\t\t\tcase 'open': return this.open(uriTransformer, args[0] as UriComponents, args[1] as IFileOpenOptions) as Promise<TResult>;\n\t\t\tcase 'close': return this.close(args[0] as number) as Promise<TResult>;\n\t\t\tcase 'read': return this.read(args[0] as number, args[1] as number, args[2] as number) as Promise<TResult>;\n\t\t\tcase 'readFile': return this.readFile(uriTransformer, args[0] as UriComponents, args[1] as IFileAtomicReadOptions) as Promise<TResult>;\n\t\t\tcase 'write': return this.write(args[0] as number, args[1] as number, args[2] as VSBuffer, args[3] as number, args[4] as number) as Promise<TResult>;\n\t\t\tcase 'writeFile': return this.writeFile(uriTransformer, args[0] as UriComponents, args[1] as VSBuffer, args[2] as IFileWriteOptions) as Promise<TResult>;\n\t\t\tcase 'rename': return this.rename(uriTransformer, args[0] as UriComponents, args[1] as UriComponents, args[2] as IFileOverwriteOptions) as Promise<TResult>;\n\t\t\tcase 'copy': return this.copy(uriTransformer, args[0] as UriComponents, args[1] as UriComponents, args[2] as IFileOverwriteOptions) as Promise<TResult>;\n\t\t\tcase 'cloneFile': return this.cloneFile(uriTransformer, args[0] as UriComponents, args[1] as UriComponents) as Promise<TResult>;\n\t\t\tcase 'mkdir': return this.mkdir(uriTransformer, args[0] as UriComponents) as Promise<TResult>;\n\t\t\tcase 'delete': return this.delete(uriTransformer, args[0] as UriComponents, args[1] as IFileDeleteOptions) as Promise<TResult>;\n\t\t\tcase 'watch': return this.watch(uriTransformer, args[0] as string, args[1] as number, args[2] as UriComponents, args[3] as IWatchOptions) as Promise<TResult>;\n\t\t\tcase 'unwatch': return this.unwatch(args[0] as string, args[1] as number) as Promise<TResult>;\n\t\t}\n\n\t\tthrow new Error(`IPC Command ${command} not found`);\n\t}\n\n\tlisten<TResult>(ctx: T, event: string, args: unknown[]): Event<TResult> {\n\t\tconst uriTransformer = this.getUriTransformer(ctx);\n\n\t\tswitch (event) {\n\t\t\tcase 'fileChange': return this.onFileChange(uriTransformer, args[0] as string) as Event<TResult>;\n\t\t\tcase 'readFileStream': return this.onReadFileStream(uriTransformer, args[0] as URI, args[1] as IFileReadStreamOptions) as Event<TResult>;\n\t\t}\n\n\t\tthrow new Error(`Unknown event ${event}`);\n\t}\n\n\tprotected abstract getUriTransformer(ctx: T): IURITransformer;\n\n\tprotected abstract transformIncoming(uriTransformer: IURITransformer, _resource: UriComponents, supportVSCodeResource?: boolean): URI;\n\n\t//#region File Metadata Resolving\n\n\tprivate stat(uriTransformer: IURITransformer, _resource: UriComponents): Promise<IStat> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource, true);\n\n\t\treturn this.provider.stat(resource);\n\t}\n\n\tprivate realpath(uriTransformer: IURITransformer, _resource: UriComponents): Promise<string> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource, true);\n\n\t\treturn this.provider.realpath(resource);\n\t}\n\n\tprivate readdir(uriTransformer: IURITransformer, _resource: UriComponents): Promise<[string, FileType][]> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.readdir(resource);\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tprivate async readFile(uriTransformer: IURITransformer, _resource: UriComponents, opts?: IFileAtomicReadOptions): Promise<VSBuffer> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource, true);\n\t\tconst buffer = await this.provider.readFile(resource, opts);\n\n\t\treturn VSBuffer.wrap(buffer);\n\t}\n\n\tprivate onReadFileStream(uriTransformer: IURITransformer, _resource: URI, opts: IFileReadStreamOptions): Event<ReadableStreamEventPayload<VSBuffer>> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource, true);\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst emitter = new Emitter<ReadableStreamEventPayload<VSBuffer>>({\n\t\t\tonDidRemoveLastListener: () => {\n\n\t\t\t\t// Ensure to cancel the read operation when there is no more\n\t\t\t\t// listener on the other side to prevent unneeded work.\n\t\t\t\tcts.cancel();\n\t\t\t}\n\t\t});\n\n\t\tconst fileStream = this.provider.readFileStream(resource, opts, cts.token);\n\t\tlistenStream(fileStream, {\n\t\t\tonData: chunk => emitter.fire(VSBuffer.wrap(chunk)),\n\t\t\tonError: error => emitter.fire(error),\n\t\t\tonEnd: () => {\n\n\t\t\t\t// Forward event\n\t\t\t\temitter.fire('end');\n\n\t\t\t\t// Cleanup\n\t\t\t\temitter.dispose();\n\t\t\t\tcts.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate writeFile(uriTransformer: IURITransformer, _resource: UriComponents, content: VSBuffer, opts: IFileWriteOptions): Promise<void> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.writeFile(resource, content.buffer, opts);\n\t}\n\n\tprivate open(uriTransformer: IURITransformer, _resource: UriComponents, opts: IFileOpenOptions): Promise<number> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource, true);\n\n\t\treturn this.provider.open(resource, opts);\n\t}\n\n\tprivate close(fd: number): Promise<void> {\n\t\treturn this.provider.close(fd);\n\t}\n\n\tprivate async read(fd: number, pos: number, length: number): Promise<[VSBuffer, number]> {\n\t\tconst buffer = VSBuffer.alloc(length);\n\t\tconst bufferOffset = 0; // offset is 0 because we create a buffer to read into for each call\n\t\tconst bytesRead = await this.provider.read(fd, pos, buffer.buffer, bufferOffset, length);\n\n\t\treturn [buffer, bytesRead];\n\t}\n\n\tprivate write(fd: number, pos: number, data: VSBuffer, offset: number, length: number): Promise<number> {\n\t\treturn this.provider.write(fd, pos, data.buffer, offset, length);\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tprivate mkdir(uriTransformer: IURITransformer, _resource: UriComponents): Promise<void> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.mkdir(resource);\n\t}\n\n\tprotected delete(uriTransformer: IURITransformer, _resource: UriComponents, opts: IFileDeleteOptions): Promise<void> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.delete(resource, opts);\n\t}\n\n\tprivate rename(uriTransformer: IURITransformer, _source: UriComponents, _target: UriComponents, opts: IFileOverwriteOptions): Promise<void> {\n\t\tconst source = this.transformIncoming(uriTransformer, _source);\n\t\tconst target = this.transformIncoming(uriTransformer, _target);\n\n\t\treturn this.provider.rename(source, target, opts);\n\t}\n\n\tprivate copy(uriTransformer: IURITransformer, _source: UriComponents, _target: UriComponents, opts: IFileOverwriteOptions): Promise<void> {\n\t\tconst source = this.transformIncoming(uriTransformer, _source);\n\t\tconst target = this.transformIncoming(uriTransformer, _target);\n\n\t\treturn this.provider.copy(source, target, opts);\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tprivate cloneFile(uriTransformer: IURITransformer, _source: UriComponents, _target: UriComponents): Promise<void> {\n\t\tconst source = this.transformIncoming(uriTransformer, _source);\n\t\tconst target = this.transformIncoming(uriTransformer, _target);\n\n\t\treturn this.provider.cloneFile(source, target);\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly sessionToWatcher = new Map<string /* session ID */, ISessionFileWatcher>();\n\tprivate readonly watchRequests = new Map<string /* session ID + request ID */, IDisposable>();\n\n\tprivate onFileChange(uriTransformer: IURITransformer, sessionId: string): Event<IFileChange[] | string> {\n\n\t\t// We want a specific emitter for the given session so that events\n\t\t// from the one session do not end up on the other session. As such\n\t\t// we create a `SessionFileWatcher` and a `Emitter` for that session.\n\n\t\tconst emitter = new Emitter<IFileChange[] | string>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tthis.sessionToWatcher.set(sessionId, this.createSessionFileWatcher(uriTransformer, emitter));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tdispose(this.sessionToWatcher.get(sessionId));\n\t\t\t\tthis.sessionToWatcher.delete(sessionId);\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate async watch(uriTransformer: IURITransformer, sessionId: string, req: number, _resource: UriComponents, opts: IWatchOptions): Promise<void> {\n\t\tconst watcher = this.sessionToWatcher.get(sessionId);\n\t\tif (watcher) {\n\t\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\t\t\tconst disposable = watcher.watch(req, resource, opts);\n\t\t\tthis.watchRequests.set(sessionId + req, disposable);\n\t\t}\n\t}\n\n\tprivate async unwatch(sessionId: string, req: number): Promise<void> {\n\t\tconst id = sessionId + req;\n\t\tconst disposable = this.watchRequests.get(id);\n\t\tif (disposable) {\n\t\t\tdispose(disposable);\n\t\t\tthis.watchRequests.delete(id);\n\t\t}\n\t}\n\n\tprotected abstract createSessionFileWatcher(uriTransformer: IURITransformer, emitter: Emitter<IFileChange[] | string>): ISessionFileWatcher;\n\n\t//#endregion\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tfor (const [, disposable] of this.watchRequests) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.watchRequests.clear();\n\n\t\tfor (const [, disposable] of this.sessionToWatcher) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.sessionToWatcher.clear();\n\t}\n}\n\nexport abstract class AbstractSessionFileWatcher extends Disposable implements ISessionFileWatcher {\n\n\tprivate readonly watcherRequests = new Map<number, IDisposable>();\n\n\t// To ensure we use one file watcher per session, we keep a\n\t// disk file system provider instantiated for this session.\n\t// The provider is cheap and only stateful when file watching\n\t// starts.\n\t//\n\t// This is important because we want to ensure that we only\n\t// forward events from the watched paths for this session and\n\t// not other clients that asked to watch other paths.\n\tprivate readonly fileWatcher: DiskFileSystemProvider;\n\n\tconstructor(\n\t\tprivate readonly uriTransformer: IURITransformer,\n\t\tsessionEmitter: Emitter<IFileChange[] | string>,\n\t\tlogService: ILogService,\n\t\tprivate readonly environmentService: IEnvironmentService\n\t) {\n\t\tsuper();\n\n\t\tthis.fileWatcher = this._register(new DiskFileSystemProvider(logService));\n\n\t\tthis.registerListeners(sessionEmitter);\n\t}\n\n\tprivate registerListeners(sessionEmitter: Emitter<IFileChange[] | string>): void {\n\t\tconst localChangeEmitter = this._register(new Emitter<readonly IFileChange[]>());\n\n\t\tthis._register(localChangeEmitter.event((events) => {\n\t\t\tsessionEmitter.fire(\n\t\t\t\tevents.map(e => ({\n\t\t\t\t\tresource: this.uriTransformer.transformOutgoingURI(e.resource),\n\t\t\t\t\ttype: e.type,\n\t\t\t\t\tcId: e.cId\n\t\t\t\t}))\n\t\t\t);\n\t\t}));\n\n\t\tthis._register(this.fileWatcher.onDidChangeFile(events => localChangeEmitter.fire(events)));\n\t\tthis._register(this.fileWatcher.onDidWatchError(error => sessionEmitter.fire(error)));\n\t}\n\n\tprotected getRecursiveWatcherOptions(environmentService: IEnvironmentService): IRecursiveWatcherOptions | undefined {\n\t\treturn undefined; // subclasses can override\n\t}\n\n\tprotected getExtraExcludes(environmentService: IEnvironmentService): string[] | undefined {\n\t\treturn undefined; // subclasses can override\n\t}\n\n\twatch(req: number, resource: URI, opts: IWatchOptions): IDisposable {\n\t\tconst extraExcludes = this.getExtraExcludes(this.environmentService);\n\t\tif (Array.isArray(extraExcludes)) {\n\t\t\topts.excludes = [...opts.excludes, ...extraExcludes];\n\t\t}\n\n\t\tthis.watcherRequests.set(req, this.fileWatcher.watch(resource, opts));\n\n\t\treturn toDisposable(() => {\n\t\t\tdispose(this.watcherRequests.get(req));\n\t\t\tthis.watcherRequests.delete(req);\n\t\t});\n\t}\n\n\toverride dispose(): void {\n\t\tfor (const [, disposable] of this.watcherRequests) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.watcherRequests.clear();\n\n\t\tsuper.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IServerChannel } from '../../../base/parts/ipc/common/ipc.js';\nimport { DiskFileSystemProvider } from './diskFileSystemProvider.js';\nimport { Disposable, dispose, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { IURITransformer } from '../../../base/common/uriIpc.js';\nimport { URI, UriComponents } from '../../../base/common/uri.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { ReadableStreamEventPayload, listenStream } from '../../../base/common/stream.js';\nimport { IStat, IFileReadStreamOptions, IFileWriteOptions, IFileOpenOptions, IFileDeleteOptions, IFileOverwriteOptions, IFileChange, IWatchOptions, FileType, IFileAtomicReadOptions } from '../common/files.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { IEnvironmentService } from '../../environment/common/environment.js';\nimport { IRecursiveWatcherOptions } from '../common/watcher.js';\n\nexport interface ISessionFileWatcher extends IDisposable {\n\twatch(req: number, resource: URI, opts: IWatchOptions): IDisposable;\n}\n\n/**\n * A server implementation for a IPC based file system provider client.\n */\nexport abstract class AbstractDiskFileSystemProviderChannel<T> extends Disposable implements IServerChannel<T> {\n\n\tconstructor(\n\t\tprotected readonly provider: DiskFileSystemProvider,\n\t\tprotected readonly logService: ILogService\n\t) {\n\t\tsuper();\n\t}\n\n\tcall<TResult>(ctx: T, command: string, args: unknown[]): Promise<TResult> {\n\t\tconst uriTransformer = this.getUriTransformer(ctx);\n\n\t\tswitch (command) {\n\t\t\tcase 'stat': return this.stat(uriTransformer, args[0] as UriComponents) as Promise<TResult>;\n\t\t\tcase 'realpath': return this.realpath(uriTransformer, args[0] as UriComponents) as Promise<TResult>;\n\t\t\tcase 'readdir': return this.readdir(uriTransformer, args[0] as UriComponents) as Promise<TResult>;\n\t\t\tcase 'open': return this.open(uriTransformer, args[0] as UriComponents, args[1] as IFileOpenOptions) as Promise<TResult>;\n\t\t\tcase 'close': return this.close(args[0] as number) as Promise<TResult>;\n\t\t\tcase 'read': return this.read(args[0] as number, args[1] as number, args[2] as number) as Promise<TResult>;\n\t\t\tcase 'readFile': return this.readFile(uriTransformer, args[0] as UriComponents, args[1] as IFileAtomicReadOptions) as Promise<TResult>;\n\t\t\tcase 'write': return this.write(args[0] as number, args[1] as number, args[2] as VSBuffer, args[3] as number, args[4] as number) as Promise<TResult>;\n\t\t\tcase 'writeFile': return this.writeFile(uriTransformer, args[0] as UriComponents, args[1] as VSBuffer, args[2] as IFileWriteOptions) as Promise<TResult>;\n\t\t\tcase 'rename': return this.rename(uriTransformer, args[0] as UriComponents, args[1] as UriComponents, args[2] as IFileOverwriteOptions) as Promise<TResult>;\n\t\t\tcase 'copy': return this.copy(uriTransformer, args[0] as UriComponents, args[1] as UriComponents, args[2] as IFileOverwriteOptions) as Promise<TResult>;\n\t\t\tcase 'cloneFile': return this.cloneFile(uriTransformer, args[0] as UriComponents, args[1] as UriComponents) as Promise<TResult>;\n\t\t\tcase 'mkdir': return this.mkdir(uriTransformer, args[0] as UriComponents) as Promise<TResult>;\n\t\t\tcase 'delete': return this.delete(uriTransformer, args[0] as UriComponents, args[1] as IFileDeleteOptions) as Promise<TResult>;\n\t\t\tcase 'watch': return this.watch(uriTransformer, args[0] as string, args[1] as number, args[2] as UriComponents, args[3] as IWatchOptions) as Promise<TResult>;\n\t\t\tcase 'unwatch': return this.unwatch(args[0] as string, args[1] as number) as Promise<TResult>;\n\t\t}\n\n\t\tthrow new Error(`IPC Command ${command} not found`);\n\t}\n\n\tlisten<TResult>(ctx: T, event: string, args: unknown[]): Event<TResult> {\n\t\tconst uriTransformer = this.getUriTransformer(ctx);\n\n\t\tswitch (event) {\n\t\t\tcase 'fileChange': return this.onFileChange(uriTransformer, args[0] as string) as Event<TResult>;\n\t\t\tcase 'readFileStream': return this.onReadFileStream(uriTransformer, args[0] as URI, args[1] as IFileReadStreamOptions) as Event<TResult>;\n\t\t}\n\n\t\tthrow new Error(`Unknown event ${event}`);\n\t}\n\n\tprotected abstract getUriTransformer(ctx: T): IURITransformer;\n\n\tprotected abstract transformIncoming(uriTransformer: IURITransformer, _resource: UriComponents, supportVSCodeResource?: boolean): URI;\n\n\t//#region File Metadata Resolving\n\n\tprivate stat(uriTransformer: IURITransformer, _resource: UriComponents): Promise<IStat> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource, true);\n\n\t\treturn this.provider.stat(resource);\n\t}\n\n\tprivate realpath(uriTransformer: IURITransformer, _resource: UriComponents): Promise<string> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource, true);\n\n\t\treturn this.provider.realpath(resource);\n\t}\n\n\tprivate readdir(uriTransformer: IURITransformer, _resource: UriComponents): Promise<[string, FileType][]> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.readdir(resource);\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tprivate async readFile(uriTransformer: IURITransformer, _resource: UriComponents, opts?: IFileAtomicReadOptions): Promise<VSBuffer> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource, true);\n\t\tconst buffer = await this.provider.readFile(resource, opts);\n\n\t\treturn VSBuffer.wrap(buffer);\n\t}\n\n\tprivate onReadFileStream(uriTransformer: IURITransformer, _resource: URI, opts: IFileReadStreamOptions): Event<ReadableStreamEventPayload<VSBuffer>> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource, true);\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst emitter = new Emitter<ReadableStreamEventPayload<VSBuffer>>({\n\t\t\tonDidRemoveLastListener: () => {\n\n\t\t\t\t// Ensure to cancel the read operation when there is no more\n\t\t\t\t// listener on the other side to prevent unneeded work.\n\t\t\t\tcts.cancel();\n\t\t\t}\n\t\t});\n\n\t\tconst fileStream = this.provider.readFileStream(resource, opts, cts.token);\n\t\tlistenStream(fileStream, {\n\t\t\tonData: chunk => emitter.fire(VSBuffer.wrap(chunk)),\n\t\t\tonError: error => emitter.fire(error),\n\t\t\tonEnd: () => {\n\n\t\t\t\t// Forward event\n\t\t\t\temitter.fire('end');\n\n\t\t\t\t// Cleanup\n\t\t\t\temitter.dispose();\n\t\t\t\tcts.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate writeFile(uriTransformer: IURITransformer, _resource: UriComponents, content: VSBuffer, opts: IFileWriteOptions): Promise<void> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.writeFile(resource, content.buffer, opts);\n\t}\n\n\tprivate open(uriTransformer: IURITransformer, _resource: UriComponents, opts: IFileOpenOptions): Promise<number> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource, true);\n\n\t\treturn this.provider.open(resource, opts);\n\t}\n\n\tprivate close(fd: number): Promise<void> {\n\t\treturn this.provider.close(fd);\n\t}\n\n\tprivate async read(fd: number, pos: number, length: number): Promise<[VSBuffer, number]> {\n\t\tconst buffer = VSBuffer.alloc(length);\n\t\tconst bufferOffset = 0; // offset is 0 because we create a buffer to read into for each call\n\t\tconst bytesRead = await this.provider.read(fd, pos, buffer.buffer, bufferOffset, length);\n\n\t\treturn [buffer, bytesRead];\n\t}\n\n\tprivate write(fd: number, pos: number, data: VSBuffer, offset: number, length: number): Promise<number> {\n\t\treturn this.provider.write(fd, pos, data.buffer, offset, length);\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tprivate mkdir(uriTransformer: IURITransformer, _resource: UriComponents): Promise<void> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.mkdir(resource);\n\t}\n\n\tprotected delete(uriTransformer: IURITransformer, _resource: UriComponents, opts: IFileDeleteOptions): Promise<void> {\n\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\n\t\treturn this.provider.delete(resource, opts);\n\t}\n\n\tprivate rename(uriTransformer: IURITransformer, _source: UriComponents, _target: UriComponents, opts: IFileOverwriteOptions): Promise<void> {\n\t\tconst source = this.transformIncoming(uriTransformer, _source);\n\t\tconst target = this.transformIncoming(uriTransformer, _target);\n\n\t\treturn this.provider.rename(source, target, opts);\n\t}\n\n\tprivate copy(uriTransformer: IURITransformer, _source: UriComponents, _target: UriComponents, opts: IFileOverwriteOptions): Promise<void> {\n\t\tconst source = this.transformIncoming(uriTransformer, _source);\n\t\tconst target = this.transformIncoming(uriTransformer, _target);\n\n\t\treturn this.provider.copy(source, target, opts);\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tprivate cloneFile(uriTransformer: IURITransformer, _source: UriComponents, _target: UriComponents): Promise<void> {\n\t\tconst source = this.transformIncoming(uriTransformer, _source);\n\t\tconst target = this.transformIncoming(uriTransformer, _target);\n\n\t\treturn this.provider.cloneFile(source, target);\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly sessionToWatcher = new Map<string /* session ID */, ISessionFileWatcher>();\n\tprivate readonly watchRequests = new Map<string /* session ID + request ID */, IDisposable>();\n\n\tprivate onFileChange(uriTransformer: IURITransformer, sessionId: string): Event<IFileChange[] | string> {\n\n\t\t// We want a specific emitter for the given session so that events\n\t\t// from the one session do not end up on the other session. As such\n\t\t// we create a `SessionFileWatcher` and a `Emitter` for that session.\n\n\t\tconst emitter = new Emitter<IFileChange[] | string>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tthis.sessionToWatcher.set(sessionId, this.createSessionFileWatcher(uriTransformer, emitter));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tdispose(this.sessionToWatcher.get(sessionId));\n\t\t\t\tthis.sessionToWatcher.delete(sessionId);\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate async watch(uriTransformer: IURITransformer, sessionId: string, req: number, _resource: UriComponents, opts: IWatchOptions): Promise<void> {\n\t\tconst watcher = this.sessionToWatcher.get(sessionId);\n\t\tif (watcher) {\n\t\t\tconst resource = this.transformIncoming(uriTransformer, _resource);\n\t\t\tconst disposable = watcher.watch(req, resource, opts);\n\t\t\tthis.watchRequests.set(sessionId + req, disposable);\n\t\t}\n\t}\n\n\tprivate async unwatch(sessionId: string, req: number): Promise<void> {\n\t\tconst id = sessionId + req;\n\t\tconst disposable = this.watchRequests.get(id);\n\t\tif (disposable) {\n\t\t\tdispose(disposable);\n\t\t\tthis.watchRequests.delete(id);\n\t\t}\n\t}\n\n\tprotected abstract createSessionFileWatcher(uriTransformer: IURITransformer, emitter: Emitter<IFileChange[] | string>): ISessionFileWatcher;\n\n\t//#endregion\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tfor (const [, disposable] of this.watchRequests) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.watchRequests.clear();\n\n\t\tfor (const [, disposable] of this.sessionToWatcher) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.sessionToWatcher.clear();\n\t}\n}\n\nexport abstract class AbstractSessionFileWatcher extends Disposable implements ISessionFileWatcher {\n\n\tprivate readonly watcherRequests = new Map<number, IDisposable>();\n\n\t// To ensure we use one file watcher per session, we keep a\n\t// disk file system provider instantiated for this session.\n\t// The provider is cheap and only stateful when file watching\n\t// starts.\n\t//\n\t// This is important because we want to ensure that we only\n\t// forward events from the watched paths for this session and\n\t// not other clients that asked to watch other paths.\n\tprivate readonly fileWatcher: DiskFileSystemProvider;\n\n\tconstructor(\n\t\tprivate readonly uriTransformer: IURITransformer,\n\t\tsessionEmitter: Emitter<IFileChange[] | string>,\n\t\tlogService: ILogService,\n\t\tprivate readonly environmentService: IEnvironmentService\n\t) {\n\t\tsuper();\n\n\t\tthis.fileWatcher = this._register(new DiskFileSystemProvider(logService));\n\n\t\tthis.registerListeners(sessionEmitter);\n\t}\n\n\tprivate registerListeners(sessionEmitter: Emitter<IFileChange[] | string>): void {\n\t\tconst localChangeEmitter = this._register(new Emitter<readonly IFileChange[]>());\n\n\t\tthis._register(localChangeEmitter.event((events) => {\n\t\t\tsessionEmitter.fire(\n\t\t\t\tevents.map(e => ({\n\t\t\t\t\tresource: this.uriTransformer.transformOutgoingURI(e.resource),\n\t\t\t\t\ttype: e.type,\n\t\t\t\t\tcId: e.cId\n\t\t\t\t}))\n\t\t\t);\n\t\t}));\n\n\t\tthis._register(this.fileWatcher.onDidChangeFile(events => localChangeEmitter.fire(events)));\n\t\tthis._register(this.fileWatcher.onDidWatchError(error => sessionEmitter.fire(error)));\n\t}\n\n\tprotected getRecursiveWatcherOptions(environmentService: IEnvironmentService): IRecursiveWatcherOptions | undefined {\n\t\treturn undefined; // subclasses can override\n\t}\n\n\tprotected getExtraExcludes(environmentService: IEnvironmentService): string[] | undefined {\n\t\treturn undefined; // subclasses can override\n\t}\n\n\twatch(req: number, resource: URI, opts: IWatchOptions): IDisposable {\n\t\tconst extraExcludes = this.getExtraExcludes(this.environmentService);\n\t\tif (Array.isArray(extraExcludes)) {\n\t\t\topts.excludes = [...opts.excludes, ...extraExcludes];\n\t\t}\n\n\t\tthis.watcherRequests.set(req, this.fileWatcher.watch(resource, opts));\n\n\t\treturn toDisposable(() => {\n\t\t\tdispose(this.watcherRequests.get(req));\n\t\t\tthis.watcherRequests.delete(req);\n\t\t});\n\t}\n\n\toverride dispose(): void {\n\t\tfor (const [, disposable] of this.watcherRequests) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.watcherRequests.clear();\n\n\t\tsuper.dispose();\n\t}\n}\n"]}