{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/common/diskFileSystemProvider.ts","vs/platform/files/common/diskFileSystemProvider.ts"],"names":[],"mappings":"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","file":"diskFileSystemProvider.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { insert } from '../../../base/common/arrays.js';\nimport { ThrottledDelayer } from '../../../base/common/async.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { removeTrailingPathSeparator } from '../../../base/common/extpath.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { normalize } from '../../../base/common/path.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IFileChange, IFileSystemProvider, IWatchOptions } from './files.js';\nimport { AbstractNonRecursiveWatcherClient, AbstractUniversalWatcherClient, ILogMessage, INonRecursiveWatchRequest, IRecursiveWatcherOptions, isRecursiveWatchRequest, IUniversalWatchRequest, reviveFileChanges } from './watcher.js';\nimport { ILogService, LogLevel } from '../../log/common/log.js';\n\nexport interface IDiskFileSystemProviderOptions {\n\twatcher?: {\n\n\t\t/**\n\t\t * Extra options for the recursive file watching.\n\t\t */\n\t\trecursive?: IRecursiveWatcherOptions;\n\n\t\t/**\n\t\t * Forces all file watch requests to run through a\n\t\t * single universal file watcher, both recursive\n\t\t * and non-recursively.\n\t\t *\n\t\t * Enabling this option might cause some overhead,\n\t\t * specifically the universal file watcher will run\n\t\t * in a separate process given its complexity. Only\n\t\t * enable it when you understand the consequences.\n\t\t */\n\t\tforceUniversal?: boolean;\n\t};\n}\n\nexport abstract class AbstractDiskFileSystemProvider extends Disposable implements\n\tPick<IFileSystemProvider, 'watch'>,\n\tPick<IFileSystemProvider, 'onDidChangeFile'>,\n\tPick<IFileSystemProvider, 'onDidWatchError'> {\n\n\tconstructor(\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly options?: IDiskFileSystemProviderOptions\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected readonly _onDidChangeFile = this._register(new Emitter<readonly IFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tprotected readonly _onDidWatchError = this._register(new Emitter<string>());\n\treadonly onDidWatchError = this._onDidWatchError.event;\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable {\n\t\tif (opts.recursive || this.options?.watcher?.forceUniversal) {\n\t\t\treturn this.watchUniversal(resource, opts);\n\t\t}\n\n\t\treturn this.watchNonRecursive(resource, opts);\n\t}\n\n\tprivate getRefreshWatchersDelay(count: number): number {\n\t\tif (count > 200) {\n\t\t\t// If there are many requests to refresh, start to throttle\n\t\t\t// the refresh to reduce pressure. We see potentially thousands\n\t\t\t// of requests coming in on startup repeatedly so we take it easy.\n\t\t\treturn 500;\n\t\t}\n\n\t\t// By default, use a short delay to keep watchers updating fast but still\n\t\t// with a delay so that we can efficiently deduplicate requests or reuse\n\t\t// existing watchers.\n\t\treturn 0;\n\t}\n\n\t//#region File Watching (universal)\n\n\tprivate universalWatcher: AbstractUniversalWatcherClient | undefined;\n\n\tprivate readonly universalWatchRequests: IUniversalWatchRequest[] = [];\n\tprivate readonly universalWatchRequestDelayer = this._register(new ThrottledDelayer<void>(this.getRefreshWatchersDelay(this.universalWatchRequests.length)));\n\n\tprivate watchUniversal(resource: URI, opts: IWatchOptions): IDisposable {\n\t\tconst request = this.toWatchRequest(resource, opts);\n\t\tconst remove = insert(this.universalWatchRequests, request);\n\n\t\t// Trigger update\n\t\tthis.refreshUniversalWatchers();\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Remove from list of paths to watch universally\n\t\t\tremove();\n\n\t\t\t// Trigger update\n\t\t\tthis.refreshUniversalWatchers();\n\t\t});\n\t}\n\n\tprivate toWatchRequest(resource: URI, opts: IWatchOptions): IUniversalWatchRequest {\n\t\tconst request: IUniversalWatchRequest = {\n\t\t\tpath: this.toWatchPath(resource),\n\t\t\texcludes: opts.excludes,\n\t\t\tincludes: opts.includes,\n\t\t\trecursive: opts.recursive,\n\t\t\tfilter: opts.filter,\n\t\t\tcorrelationId: opts.correlationId\n\t\t};\n\n\t\tif (isRecursiveWatchRequest(request)) {\n\n\t\t\t// Adjust for polling\n\t\t\tconst usePolling = this.options?.watcher?.recursive?.usePolling;\n\t\t\tif (usePolling === true) {\n\t\t\t\trequest.pollingInterval = this.options?.watcher?.recursive?.pollingInterval ?? 5000;\n\t\t\t} else if (Array.isArray(usePolling)) {\n\t\t\t\tif (usePolling.includes(request.path)) {\n\t\t\t\t\trequest.pollingInterval = this.options?.watcher?.recursive?.pollingInterval ?? 5000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn request;\n\t}\n\n\tprivate refreshUniversalWatchers(): void {\n\t\tthis.universalWatchRequestDelayer.trigger(() => {\n\t\t\treturn this.doRefreshUniversalWatchers();\n\t\t}, this.getRefreshWatchersDelay(this.universalWatchRequests.length)).catch(error => onUnexpectedError(error));\n\t}\n\n\tprivate doRefreshUniversalWatchers(): Promise<void> {\n\n\t\t// Create watcher if this is the first time\n\t\tif (!this.universalWatcher) {\n\t\t\tthis.universalWatcher = this._register(this.createUniversalWatcher(\n\t\t\t\tchanges => this._onDidChangeFile.fire(reviveFileChanges(changes)),\n\t\t\t\tmsg => this.onWatcherLogMessage(msg),\n\t\t\t\tthis.logService.getLevel() === LogLevel.Trace\n\t\t\t));\n\n\t\t\t// Apply log levels dynamically\n\t\t\tthis._register(this.logService.onDidChangeLogLevel(() => {\n\t\t\t\tthis.universalWatcher?.setVerboseLogging(this.logService.getLevel() === LogLevel.Trace);\n\t\t\t}));\n\t\t}\n\n\t\t// Ask to watch the provided paths\n\t\treturn this.universalWatcher.watch(this.universalWatchRequests);\n\t}\n\n\tprotected abstract createUniversalWatcher(\n\t\tonChange: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t): AbstractUniversalWatcherClient;\n\n\t//#endregion\n\n\t//#region File Watching (non-recursive)\n\n\tprivate nonRecursiveWatcher: AbstractNonRecursiveWatcherClient | undefined;\n\n\tprivate readonly nonRecursiveWatchRequests: INonRecursiveWatchRequest[] = [];\n\tprivate readonly nonRecursiveWatchRequestDelayer = this._register(new ThrottledDelayer<void>(this.getRefreshWatchersDelay(this.nonRecursiveWatchRequests.length)));\n\n\tprivate watchNonRecursive(resource: URI, opts: IWatchOptions): IDisposable {\n\n\t\t// Add to list of paths to watch non-recursively\n\t\tconst request: INonRecursiveWatchRequest = {\n\t\t\tpath: this.toWatchPath(resource),\n\t\t\texcludes: opts.excludes,\n\t\t\tincludes: opts.includes,\n\t\t\trecursive: false,\n\t\t\tfilter: opts.filter,\n\t\t\tcorrelationId: opts.correlationId\n\t\t};\n\t\tconst remove = insert(this.nonRecursiveWatchRequests, request);\n\n\t\t// Trigger update\n\t\tthis.refreshNonRecursiveWatchers();\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Remove from list of paths to watch non-recursively\n\t\t\tremove();\n\n\t\t\t// Trigger update\n\t\t\tthis.refreshNonRecursiveWatchers();\n\t\t});\n\t}\n\n\tprivate refreshNonRecursiveWatchers(): void {\n\t\tthis.nonRecursiveWatchRequestDelayer.trigger(() => {\n\t\t\treturn this.doRefreshNonRecursiveWatchers();\n\t\t}, this.getRefreshWatchersDelay(this.nonRecursiveWatchRequests.length)).catch(error => onUnexpectedError(error));\n\t}\n\n\tprivate doRefreshNonRecursiveWatchers(): Promise<void> {\n\n\t\t// Create watcher if this is the first time\n\t\tif (!this.nonRecursiveWatcher) {\n\t\t\tthis.nonRecursiveWatcher = this._register(this.createNonRecursiveWatcher(\n\t\t\t\tchanges => this._onDidChangeFile.fire(reviveFileChanges(changes)),\n\t\t\t\tmsg => this.onWatcherLogMessage(msg),\n\t\t\t\tthis.logService.getLevel() === LogLevel.Trace\n\t\t\t));\n\n\t\t\t// Apply log levels dynamically\n\t\t\tthis._register(this.logService.onDidChangeLogLevel(() => {\n\t\t\t\tthis.nonRecursiveWatcher?.setVerboseLogging(this.logService.getLevel() === LogLevel.Trace);\n\t\t\t}));\n\t\t}\n\n\t\t// Ask to watch the provided paths\n\t\treturn this.nonRecursiveWatcher.watch(this.nonRecursiveWatchRequests);\n\t}\n\n\tprotected abstract createNonRecursiveWatcher(\n\t\tonChange: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t): AbstractNonRecursiveWatcherClient;\n\n\t//#endregion\n\n\tprivate onWatcherLogMessage(msg: ILogMessage): void {\n\t\tif (msg.type === 'error') {\n\t\t\tthis._onDidWatchError.fire(msg.message);\n\t\t}\n\n\t\tthis.logWatcherMessage(msg);\n\t}\n\n\tprotected logWatcherMessage(msg: ILogMessage): void {\n\t\tthis.logService[msg.type](msg.message);\n\t}\n\n\tprotected toFilePath(resource: URI): string {\n\t\treturn normalize(resource.fsPath);\n\t}\n\n\tprivate toWatchPath(resource: URI): string {\n\t\tconst filePath = this.toFilePath(resource);\n\n\t\t// Ensure to have any trailing path separators removed, otherwise\n\t\t// we may believe the path is not \"real\" and will convert every\n\t\t// event back to this form, which is not warranted.\n\t\t// See also https://github.com/microsoft/vscode/issues/210517\n\t\treturn removeTrailingPathSeparator(filePath);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { insert } from '../../../base/common/arrays.js';\nimport { ThrottledDelayer } from '../../../base/common/async.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { removeTrailingPathSeparator } from '../../../base/common/extpath.js';\nimport { Disposable, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { normalize } from '../../../base/common/path.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IFileChange, IFileSystemProvider, IWatchOptions } from './files.js';\nimport { AbstractNonRecursiveWatcherClient, AbstractUniversalWatcherClient, ILogMessage, INonRecursiveWatchRequest, IRecursiveWatcherOptions, isRecursiveWatchRequest, IUniversalWatchRequest, reviveFileChanges } from './watcher.js';\nimport { ILogService, LogLevel } from '../../log/common/log.js';\n\nexport interface IDiskFileSystemProviderOptions {\n\twatcher?: {\n\n\t\t/**\n\t\t * Extra options for the recursive file watching.\n\t\t */\n\t\trecursive?: IRecursiveWatcherOptions;\n\n\t\t/**\n\t\t * Forces all file watch requests to run through a\n\t\t * single universal file watcher, both recursive\n\t\t * and non-recursively.\n\t\t *\n\t\t * Enabling this option might cause some overhead,\n\t\t * specifically the universal file watcher will run\n\t\t * in a separate process given its complexity. Only\n\t\t * enable it when you understand the consequences.\n\t\t */\n\t\tforceUniversal?: boolean;\n\t};\n}\n\nexport abstract class AbstractDiskFileSystemProvider extends Disposable implements\n\tPick<IFileSystemProvider, 'watch'>,\n\tPick<IFileSystemProvider, 'onDidChangeFile'>,\n\tPick<IFileSystemProvider, 'onDidWatchError'> {\n\n\tconstructor(\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly options?: IDiskFileSystemProviderOptions\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected readonly _onDidChangeFile = this._register(new Emitter<readonly IFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tprotected readonly _onDidWatchError = this._register(new Emitter<string>());\n\treadonly onDidWatchError = this._onDidWatchError.event;\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable {\n\t\tif (opts.recursive || this.options?.watcher?.forceUniversal) {\n\t\t\treturn this.watchUniversal(resource, opts);\n\t\t}\n\n\t\treturn this.watchNonRecursive(resource, opts);\n\t}\n\n\tprivate getRefreshWatchersDelay(count: number): number {\n\t\tif (count > 200) {\n\t\t\t// If there are many requests to refresh, start to throttle\n\t\t\t// the refresh to reduce pressure. We see potentially thousands\n\t\t\t// of requests coming in on startup repeatedly so we take it easy.\n\t\t\treturn 500;\n\t\t}\n\n\t\t// By default, use a short delay to keep watchers updating fast but still\n\t\t// with a delay so that we can efficiently deduplicate requests or reuse\n\t\t// existing watchers.\n\t\treturn 0;\n\t}\n\n\t//#region File Watching (universal)\n\n\tprivate universalWatcher: AbstractUniversalWatcherClient | undefined;\n\n\tprivate readonly universalWatchRequests: IUniversalWatchRequest[] = [];\n\tprivate readonly universalWatchRequestDelayer = this._register(new ThrottledDelayer<void>(this.getRefreshWatchersDelay(this.universalWatchRequests.length)));\n\n\tprivate watchUniversal(resource: URI, opts: IWatchOptions): IDisposable {\n\t\tconst request = this.toWatchRequest(resource, opts);\n\t\tconst remove = insert(this.universalWatchRequests, request);\n\n\t\t// Trigger update\n\t\tthis.refreshUniversalWatchers();\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Remove from list of paths to watch universally\n\t\t\tremove();\n\n\t\t\t// Trigger update\n\t\t\tthis.refreshUniversalWatchers();\n\t\t});\n\t}\n\n\tprivate toWatchRequest(resource: URI, opts: IWatchOptions): IUniversalWatchRequest {\n\t\tconst request: IUniversalWatchRequest = {\n\t\t\tpath: this.toWatchPath(resource),\n\t\t\texcludes: opts.excludes,\n\t\t\tincludes: opts.includes,\n\t\t\trecursive: opts.recursive,\n\t\t\tfilter: opts.filter,\n\t\t\tcorrelationId: opts.correlationId\n\t\t};\n\n\t\tif (isRecursiveWatchRequest(request)) {\n\n\t\t\t// Adjust for polling\n\t\t\tconst usePolling = this.options?.watcher?.recursive?.usePolling;\n\t\t\tif (usePolling === true) {\n\t\t\t\trequest.pollingInterval = this.options?.watcher?.recursive?.pollingInterval ?? 5000;\n\t\t\t} else if (Array.isArray(usePolling)) {\n\t\t\t\tif (usePolling.includes(request.path)) {\n\t\t\t\t\trequest.pollingInterval = this.options?.watcher?.recursive?.pollingInterval ?? 5000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn request;\n\t}\n\n\tprivate refreshUniversalWatchers(): void {\n\t\tthis.universalWatchRequestDelayer.trigger(() => {\n\t\t\treturn this.doRefreshUniversalWatchers();\n\t\t}, this.getRefreshWatchersDelay(this.universalWatchRequests.length)).catch(error => onUnexpectedError(error));\n\t}\n\n\tprivate doRefreshUniversalWatchers(): Promise<void> {\n\n\t\t// Create watcher if this is the first time\n\t\tif (!this.universalWatcher) {\n\t\t\tthis.universalWatcher = this._register(this.createUniversalWatcher(\n\t\t\t\tchanges => this._onDidChangeFile.fire(reviveFileChanges(changes)),\n\t\t\t\tmsg => this.onWatcherLogMessage(msg),\n\t\t\t\tthis.logService.getLevel() === LogLevel.Trace\n\t\t\t));\n\n\t\t\t// Apply log levels dynamically\n\t\t\tthis._register(this.logService.onDidChangeLogLevel(() => {\n\t\t\t\tthis.universalWatcher?.setVerboseLogging(this.logService.getLevel() === LogLevel.Trace);\n\t\t\t}));\n\t\t}\n\n\t\t// Ask to watch the provided paths\n\t\treturn this.universalWatcher.watch(this.universalWatchRequests);\n\t}\n\n\tprotected abstract createUniversalWatcher(\n\t\tonChange: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t): AbstractUniversalWatcherClient;\n\n\t//#endregion\n\n\t//#region File Watching (non-recursive)\n\n\tprivate nonRecursiveWatcher: AbstractNonRecursiveWatcherClient | undefined;\n\n\tprivate readonly nonRecursiveWatchRequests: INonRecursiveWatchRequest[] = [];\n\tprivate readonly nonRecursiveWatchRequestDelayer = this._register(new ThrottledDelayer<void>(this.getRefreshWatchersDelay(this.nonRecursiveWatchRequests.length)));\n\n\tprivate watchNonRecursive(resource: URI, opts: IWatchOptions): IDisposable {\n\n\t\t// Add to list of paths to watch non-recursively\n\t\tconst request: INonRecursiveWatchRequest = {\n\t\t\tpath: this.toWatchPath(resource),\n\t\t\texcludes: opts.excludes,\n\t\t\tincludes: opts.includes,\n\t\t\trecursive: false,\n\t\t\tfilter: opts.filter,\n\t\t\tcorrelationId: opts.correlationId\n\t\t};\n\t\tconst remove = insert(this.nonRecursiveWatchRequests, request);\n\n\t\t// Trigger update\n\t\tthis.refreshNonRecursiveWatchers();\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Remove from list of paths to watch non-recursively\n\t\t\tremove();\n\n\t\t\t// Trigger update\n\t\t\tthis.refreshNonRecursiveWatchers();\n\t\t});\n\t}\n\n\tprivate refreshNonRecursiveWatchers(): void {\n\t\tthis.nonRecursiveWatchRequestDelayer.trigger(() => {\n\t\t\treturn this.doRefreshNonRecursiveWatchers();\n\t\t}, this.getRefreshWatchersDelay(this.nonRecursiveWatchRequests.length)).catch(error => onUnexpectedError(error));\n\t}\n\n\tprivate doRefreshNonRecursiveWatchers(): Promise<void> {\n\n\t\t// Create watcher if this is the first time\n\t\tif (!this.nonRecursiveWatcher) {\n\t\t\tthis.nonRecursiveWatcher = this._register(this.createNonRecursiveWatcher(\n\t\t\t\tchanges => this._onDidChangeFile.fire(reviveFileChanges(changes)),\n\t\t\t\tmsg => this.onWatcherLogMessage(msg),\n\t\t\t\tthis.logService.getLevel() === LogLevel.Trace\n\t\t\t));\n\n\t\t\t// Apply log levels dynamically\n\t\t\tthis._register(this.logService.onDidChangeLogLevel(() => {\n\t\t\t\tthis.nonRecursiveWatcher?.setVerboseLogging(this.logService.getLevel() === LogLevel.Trace);\n\t\t\t}));\n\t\t}\n\n\t\t// Ask to watch the provided paths\n\t\treturn this.nonRecursiveWatcher.watch(this.nonRecursiveWatchRequests);\n\t}\n\n\tprotected abstract createNonRecursiveWatcher(\n\t\tonChange: (changes: IFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t): AbstractNonRecursiveWatcherClient;\n\n\t//#endregion\n\n\tprivate onWatcherLogMessage(msg: ILogMessage): void {\n\t\tif (msg.type === 'error') {\n\t\t\tthis._onDidWatchError.fire(msg.message);\n\t\t}\n\n\t\tthis.logWatcherMessage(msg);\n\t}\n\n\tprotected logWatcherMessage(msg: ILogMessage): void {\n\t\tthis.logService[msg.type](msg.message);\n\t}\n\n\tprotected toFilePath(resource: URI): string {\n\t\treturn normalize(resource.fsPath);\n\t}\n\n\tprivate toWatchPath(resource: URI): string {\n\t\tconst filePath = this.toFilePath(resource);\n\n\t\t// Ensure to have any trailing path separators removed, otherwise\n\t\t// we may believe the path is not \"real\" and will convert every\n\t\t// event back to this form, which is not warranted.\n\t\t// See also https://github.com/microsoft/vscode/issues/210517\n\t\treturn removeTrailingPathSeparator(filePath);\n\t}\n}\n"]}