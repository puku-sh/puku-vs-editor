{"version":3,"sources":["file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src/vs/platform/files/common/diskFileSystemProviderClient.ts","vs/platform/files/common/diskFileSystemProviderClient.ts"],"names":[],"mappings":"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","file":"diskFileSystemProviderClient.js","sourceRoot":"file:///Users/sahamed/Desktop/puku-vs-editor/puku-editor/github/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { canceled } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { newWriteableStream, ReadableStreamEventPayload, ReadableStreamEvents } from '../../../base/common/stream.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { IChannel } from '../../../base/parts/ipc/common/ipc.js';\nimport { createFileSystemProviderError, IFileAtomicReadOptions, IFileDeleteOptions, IFileOpenOptions, IFileOverwriteOptions, IFileReadStreamOptions, FileSystemProviderCapabilities, FileSystemProviderErrorCode, FileType, IFileWriteOptions, IFileChange, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileCloneCapability, IFileSystemProviderWithFileFolderCopyCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, IStat, IWatchOptions, IFileSystemProviderError } from './files.js';\nimport { reviveFileChanges } from './watcher.js';\n\nexport const LOCAL_FILE_SYSTEM_CHANNEL_NAME = 'localFilesystem';\n\n/**\n * An implementation of a local disk file system provider\n * that is backed by a `IChannel` and thus implemented via\n * IPC on a different process.\n */\nexport class DiskFileSystemProviderClient extends Disposable implements\n\tIFileSystemProviderWithFileReadWriteCapability,\n\tIFileSystemProviderWithOpenReadWriteCloseCapability,\n\tIFileSystemProviderWithFileReadStreamCapability,\n\tIFileSystemProviderWithFileFolderCopyCapability,\n\tIFileSystemProviderWithFileAtomicReadCapability,\n\tIFileSystemProviderWithFileCloneCapability {\n\n\tconstructor(\n\t\tprivate readonly channel: IChannel,\n\t\tprivate readonly extraCapabilities: { trash?: boolean; pathCaseSensitive?: boolean }\n\t) {\n\t\tsuper();\n\n\t\tthis.registerFileChangeListeners();\n\t}\n\n\t//#region File Capabilities\n\n\treadonly onDidChangeCapabilities: Event<void> = Event.None;\n\n\tprivate _capabilities: FileSystemProviderCapabilities | undefined;\n\tget capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._capabilities) {\n\t\t\tthis._capabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileOpenReadWriteClose |\n\t\t\t\tFileSystemProviderCapabilities.FileReadStream |\n\t\t\t\tFileSystemProviderCapabilities.FileFolderCopy |\n\t\t\t\tFileSystemProviderCapabilities.FileWriteUnlock |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicRead |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicDelete |\n\t\t\t\tFileSystemProviderCapabilities.FileClone |\n\t\t\t\tFileSystemProviderCapabilities.FileRealpath;\n\n\t\t\tif (this.extraCapabilities.pathCaseSensitive) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\n\t\t\tif (this.extraCapabilities.trash) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.Trash;\n\t\t\t}\n\t\t}\n\n\t\treturn this._capabilities;\n\t}\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tstat(resource: URI): Promise<IStat> {\n\t\treturn this.channel.call('stat', [resource]);\n\t}\n\n\trealpath(resource: URI): Promise<string> {\n\t\treturn this.channel.call('realpath', [resource]);\n\t}\n\n\treaddir(resource: URI): Promise<[string, FileType][]> {\n\t\treturn this.channel.call('readdir', [resource]);\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync readFile(resource: URI, opts?: IFileAtomicReadOptions): Promise<Uint8Array> {\n\t\tconst { buffer } = await this.channel.call('readFile', [resource, opts]) as VSBuffer;\n\n\t\treturn buffer;\n\t}\n\n\treadFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer);\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Reading as file stream goes through an event to the remote side\n\t\tdisposables.add(this.channel.listen<ReadableStreamEventPayload<VSBuffer>>('readFileStream', [resource, opts])(dataOrErrorOrEnd => {\n\n\t\t\t// data\n\t\t\tif (dataOrErrorOrEnd instanceof VSBuffer) {\n\t\t\t\tstream.write(dataOrErrorOrEnd.buffer);\n\t\t\t}\n\n\t\t\t// end or error\n\t\t\telse {\n\t\t\t\tif (dataOrErrorOrEnd === 'end') {\n\t\t\t\t\tstream.end();\n\t\t\t\t} else {\n\t\t\t\t\tlet error: Error;\n\n\t\t\t\t\t// Take Error as is if type matches\n\t\t\t\t\tif (dataOrErrorOrEnd instanceof Error) {\n\t\t\t\t\t\terror = dataOrErrorOrEnd;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, try to deserialize into an error.\n\t\t\t\t\t// Since we communicate via IPC, we cannot be sure\n\t\t\t\t\t// that Error objects are properly serialized.\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst errorCandidate = dataOrErrorOrEnd as IFileSystemProviderError;\n\n\t\t\t\t\t\terror = createFileSystemProviderError(errorCandidate.message ?? toErrorMessage(errorCandidate), errorCandidate.code ?? FileSystemProviderErrorCode.Unknown);\n\t\t\t\t\t}\n\n\t\t\t\t\tstream.error(error);\n\t\t\t\t\tstream.end();\n\t\t\t\t}\n\n\t\t\t\t// Signal to the remote side that we no longer listen\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\t\t}));\n\n\t\t// Support cancellation\n\t\tdisposables.add(token.onCancellationRequested(() => {\n\n\t\t\t// Ensure to end the stream properly with an error\n\t\t\t// to indicate the cancellation.\n\t\t\tstream.error(canceled());\n\t\t\tstream.end();\n\n\t\t\t// Ensure to dispose the listener upon cancellation. This will\n\t\t\t// bubble through the remote side as event and allows to stop\n\t\t\t// reading the file.\n\t\t\tdisposables.dispose();\n\t\t}));\n\n\t\treturn stream;\n\t}\n\n\twriteFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\t\treturn this.channel.call('writeFile', [resource, VSBuffer.wrap(content), opts]);\n\t}\n\n\topen(resource: URI, opts: IFileOpenOptions): Promise<number> {\n\t\treturn this.channel.call('open', [resource, opts]);\n\t}\n\n\tclose(fd: number): Promise<void> {\n\t\treturn this.channel.call('close', [fd]);\n\t}\n\n\tasync read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst [bytes, bytesRead]: [VSBuffer, number] = await this.channel.call('read', [fd, pos, length]);\n\n\t\t// copy back the data that was written into the buffer on the remote\n\t\t// side. we need to do this because buffers are not referenced by\n\t\t// pointer, but only by value and as such cannot be directly written\n\t\t// to from the other process.\n\t\tdata.set(bytes.buffer.slice(0, bytesRead), offset);\n\n\t\treturn bytesRead;\n\t}\n\n\twrite(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\treturn this.channel.call('write', [fd, pos, VSBuffer.wrap(data), offset, length]);\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tmkdir(resource: URI): Promise<void> {\n\t\treturn this.channel.call('mkdir', [resource]);\n\t}\n\n\tdelete(resource: URI, opts: IFileDeleteOptions): Promise<void> {\n\t\treturn this.channel.call('delete', [resource, opts]);\n\t}\n\n\trename(resource: URI, target: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\treturn this.channel.call('rename', [resource, target, opts]);\n\t}\n\n\tcopy(resource: URI, target: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\treturn this.channel.call('copy', [resource, target, opts]);\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tcloneFile(resource: URI, target: URI): Promise<void> {\n\t\treturn this.channel.call('cloneFile', [resource, target]);\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly _onDidChange = this._register(new Emitter<readonly IFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChange.event;\n\n\tprivate readonly _onDidWatchError = this._register(new Emitter<string>());\n\treadonly onDidWatchError = this._onDidWatchError.event;\n\n\t// The contract for file watching via remote is to identify us\n\t// via a unique but readonly session ID. Since the remote is\n\t// managing potentially many watchers from different clients,\n\t// this helps the server to properly partition events to the right\n\t// clients.\n\tprivate readonly sessionId = generateUuid();\n\n\tprivate registerFileChangeListeners(): void {\n\n\t\t// The contract for file changes is that there is one listener\n\t\t// for both events and errors from the watcher. So we need to\n\t\t// unwrap the event from the remote and emit through the proper\n\t\t// emitter.\n\t\tthis._register(this.channel.listen<IFileChange[] | string>('fileChange', [this.sessionId])(eventsOrError => {\n\t\t\tif (Array.isArray(eventsOrError)) {\n\t\t\t\tconst events = eventsOrError;\n\t\t\t\tthis._onDidChange.fire(reviveFileChanges(events));\n\t\t\t} else {\n\t\t\t\tconst error = eventsOrError;\n\t\t\t\tthis._onDidWatchError.fire(error);\n\t\t\t}\n\t\t}));\n\t}\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable {\n\n\t\t// Generate a request UUID to correlate the watcher\n\t\t// back to us when we ask to dispose the watcher later.\n\t\tconst req = generateUuid();\n\n\t\tthis.channel.call('watch', [this.sessionId, req, resource, opts]);\n\n\t\treturn toDisposable(() => this.channel.call('unwatch', [this.sessionId, req]));\n\t}\n\n\t//#endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { canceled } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { newWriteableStream, ReadableStreamEventPayload, ReadableStreamEvents } from '../../../base/common/stream.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { IChannel } from '../../../base/parts/ipc/common/ipc.js';\nimport { createFileSystemProviderError, IFileAtomicReadOptions, IFileDeleteOptions, IFileOpenOptions, IFileOverwriteOptions, IFileReadStreamOptions, FileSystemProviderCapabilities, FileSystemProviderErrorCode, FileType, IFileWriteOptions, IFileChange, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileCloneCapability, IFileSystemProviderWithFileFolderCopyCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, IStat, IWatchOptions, IFileSystemProviderError } from './files.js';\nimport { reviveFileChanges } from './watcher.js';\n\nexport const LOCAL_FILE_SYSTEM_CHANNEL_NAME = 'localFilesystem';\n\n/**\n * An implementation of a local disk file system provider\n * that is backed by a `IChannel` and thus implemented via\n * IPC on a different process.\n */\nexport class DiskFileSystemProviderClient extends Disposable implements\n\tIFileSystemProviderWithFileReadWriteCapability,\n\tIFileSystemProviderWithOpenReadWriteCloseCapability,\n\tIFileSystemProviderWithFileReadStreamCapability,\n\tIFileSystemProviderWithFileFolderCopyCapability,\n\tIFileSystemProviderWithFileAtomicReadCapability,\n\tIFileSystemProviderWithFileCloneCapability {\n\n\tconstructor(\n\t\tprivate readonly channel: IChannel,\n\t\tprivate readonly extraCapabilities: { trash?: boolean; pathCaseSensitive?: boolean }\n\t) {\n\t\tsuper();\n\n\t\tthis.registerFileChangeListeners();\n\t}\n\n\t//#region File Capabilities\n\n\treadonly onDidChangeCapabilities: Event<void> = Event.None;\n\n\tprivate _capabilities: FileSystemProviderCapabilities | undefined;\n\tget capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._capabilities) {\n\t\t\tthis._capabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileOpenReadWriteClose |\n\t\t\t\tFileSystemProviderCapabilities.FileReadStream |\n\t\t\t\tFileSystemProviderCapabilities.FileFolderCopy |\n\t\t\t\tFileSystemProviderCapabilities.FileWriteUnlock |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicRead |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicDelete |\n\t\t\t\tFileSystemProviderCapabilities.FileClone |\n\t\t\t\tFileSystemProviderCapabilities.FileRealpath;\n\n\t\t\tif (this.extraCapabilities.pathCaseSensitive) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\n\t\t\tif (this.extraCapabilities.trash) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.Trash;\n\t\t\t}\n\t\t}\n\n\t\treturn this._capabilities;\n\t}\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tstat(resource: URI): Promise<IStat> {\n\t\treturn this.channel.call('stat', [resource]);\n\t}\n\n\trealpath(resource: URI): Promise<string> {\n\t\treturn this.channel.call('realpath', [resource]);\n\t}\n\n\treaddir(resource: URI): Promise<[string, FileType][]> {\n\t\treturn this.channel.call('readdir', [resource]);\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync readFile(resource: URI, opts?: IFileAtomicReadOptions): Promise<Uint8Array> {\n\t\tconst { buffer } = await this.channel.call('readFile', [resource, opts]) as VSBuffer;\n\n\t\treturn buffer;\n\t}\n\n\treadFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer);\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Reading as file stream goes through an event to the remote side\n\t\tdisposables.add(this.channel.listen<ReadableStreamEventPayload<VSBuffer>>('readFileStream', [resource, opts])(dataOrErrorOrEnd => {\n\n\t\t\t// data\n\t\t\tif (dataOrErrorOrEnd instanceof VSBuffer) {\n\t\t\t\tstream.write(dataOrErrorOrEnd.buffer);\n\t\t\t}\n\n\t\t\t// end or error\n\t\t\telse {\n\t\t\t\tif (dataOrErrorOrEnd === 'end') {\n\t\t\t\t\tstream.end();\n\t\t\t\t} else {\n\t\t\t\t\tlet error: Error;\n\n\t\t\t\t\t// Take Error as is if type matches\n\t\t\t\t\tif (dataOrErrorOrEnd instanceof Error) {\n\t\t\t\t\t\terror = dataOrErrorOrEnd;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, try to deserialize into an error.\n\t\t\t\t\t// Since we communicate via IPC, we cannot be sure\n\t\t\t\t\t// that Error objects are properly serialized.\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst errorCandidate = dataOrErrorOrEnd as IFileSystemProviderError;\n\n\t\t\t\t\t\terror = createFileSystemProviderError(errorCandidate.message ?? toErrorMessage(errorCandidate), errorCandidate.code ?? FileSystemProviderErrorCode.Unknown);\n\t\t\t\t\t}\n\n\t\t\t\t\tstream.error(error);\n\t\t\t\t\tstream.end();\n\t\t\t\t}\n\n\t\t\t\t// Signal to the remote side that we no longer listen\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\t\t}));\n\n\t\t// Support cancellation\n\t\tdisposables.add(token.onCancellationRequested(() => {\n\n\t\t\t// Ensure to end the stream properly with an error\n\t\t\t// to indicate the cancellation.\n\t\t\tstream.error(canceled());\n\t\t\tstream.end();\n\n\t\t\t// Ensure to dispose the listener upon cancellation. This will\n\t\t\t// bubble through the remote side as event and allows to stop\n\t\t\t// reading the file.\n\t\t\tdisposables.dispose();\n\t\t}));\n\n\t\treturn stream;\n\t}\n\n\twriteFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\t\treturn this.channel.call('writeFile', [resource, VSBuffer.wrap(content), opts]);\n\t}\n\n\topen(resource: URI, opts: IFileOpenOptions): Promise<number> {\n\t\treturn this.channel.call('open', [resource, opts]);\n\t}\n\n\tclose(fd: number): Promise<void> {\n\t\treturn this.channel.call('close', [fd]);\n\t}\n\n\tasync read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst [bytes, bytesRead]: [VSBuffer, number] = await this.channel.call('read', [fd, pos, length]);\n\n\t\t// copy back the data that was written into the buffer on the remote\n\t\t// side. we need to do this because buffers are not referenced by\n\t\t// pointer, but only by value and as such cannot be directly written\n\t\t// to from the other process.\n\t\tdata.set(bytes.buffer.slice(0, bytesRead), offset);\n\n\t\treturn bytesRead;\n\t}\n\n\twrite(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\treturn this.channel.call('write', [fd, pos, VSBuffer.wrap(data), offset, length]);\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tmkdir(resource: URI): Promise<void> {\n\t\treturn this.channel.call('mkdir', [resource]);\n\t}\n\n\tdelete(resource: URI, opts: IFileDeleteOptions): Promise<void> {\n\t\treturn this.channel.call('delete', [resource, opts]);\n\t}\n\n\trename(resource: URI, target: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\treturn this.channel.call('rename', [resource, target, opts]);\n\t}\n\n\tcopy(resource: URI, target: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\treturn this.channel.call('copy', [resource, target, opts]);\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tcloneFile(resource: URI, target: URI): Promise<void> {\n\t\treturn this.channel.call('cloneFile', [resource, target]);\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly _onDidChange = this._register(new Emitter<readonly IFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChange.event;\n\n\tprivate readonly _onDidWatchError = this._register(new Emitter<string>());\n\treadonly onDidWatchError = this._onDidWatchError.event;\n\n\t// The contract for file watching via remote is to identify us\n\t// via a unique but readonly session ID. Since the remote is\n\t// managing potentially many watchers from different clients,\n\t// this helps the server to properly partition events to the right\n\t// clients.\n\tprivate readonly sessionId = generateUuid();\n\n\tprivate registerFileChangeListeners(): void {\n\n\t\t// The contract for file changes is that there is one listener\n\t\t// for both events and errors from the watcher. So we need to\n\t\t// unwrap the event from the remote and emit through the proper\n\t\t// emitter.\n\t\tthis._register(this.channel.listen<IFileChange[] | string>('fileChange', [this.sessionId])(eventsOrError => {\n\t\t\tif (Array.isArray(eventsOrError)) {\n\t\t\t\tconst events = eventsOrError;\n\t\t\t\tthis._onDidChange.fire(reviveFileChanges(events));\n\t\t\t} else {\n\t\t\t\tconst error = eventsOrError;\n\t\t\t\tthis._onDidWatchError.fire(error);\n\t\t\t}\n\t\t}));\n\t}\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable {\n\n\t\t// Generate a request UUID to correlate the watcher\n\t\t// back to us when we ask to dispose the watcher later.\n\t\tconst req = generateUuid();\n\n\t\tthis.channel.call('watch', [this.sessionId, req, resource, opts]);\n\n\t\treturn toDisposable(() => this.channel.call('unwatch', [this.sessionId, req]));\n\t}\n\n\t//#endregion\n}\n"]}